{"sha": "8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNjOWE1YTU4NGE1N2UwNmYxZTJjODNjYjhjY2QxOGEwMmExYmM5MQ==", "commit": {"author": {"name": "Edgar E. Iglesias", "email": "edgar.iglesias@xilinx.com", "date": "2013-03-14T15:43:23Z"}, "committer": {"name": "Michael Eager", "email": "eager@gcc.gnu.org", "date": "2013-03-14T15:43:23Z"}, "message": "Add support for TLS in MicroBlaze\n\n * configure.ac: Add MicroBlaze TLS support detection.\n * configure: Regenerate.\n * config/microblaze/microblaze-protos.h: (microblaze_cannot_force_const_mem,\n   microblaze_tls_referenced_p, symbol_mentioned_p,\n   label_mentioned_p): Add prototypes.\n * config/microblaze/microblaze.c (microblaze_address_type): Add ADDRESS_TLS\n   and tls_reloc address types.\n   (microblaze_address_info): Add tls_reloc.\n   (TARGET_HAVE_TLS): Define.\n   (get_tls_get_addr, microblaze_tls_symbol_p, microblaze_tls_operand_p_1,\n    microblaze_tls_referenced_p, microblaze_cannot_force_const_mem,\n    symbol_mentioned_p, label_mentioned_p, tls_mentioned_p, load_tls_operand,\n    microblaze_call_tls_get_addr, microblaze_legitimize_tls_address): New functions.\n   (microblaze_classify_unspec): Handle UNSPEC_TLS.\n   (get_base_reg): Use microblaze_tls_symbol_p.\n   (microblaze_classify_address): Handle TLS.\n   (microblaze_legitimate_pic_operand): Use symbol_mentioned_p, label_mentioned_p\n    and microblaze_tls_referenced_p.\n   (microblaze_legitimize_address): Handle TLS.\n   (microblaze_address_insns): Handle ADDRESS_TLS.\n   (pic_address_needs_scratch): Handle TLS.\n   (print_operand_address): Handle TLS.\n   (microblaze_expand_prologue): Check TLS_NEEDS_GOT.\n   (microblaze_expand_move): Handle TLS.\n   (microblaze_legitimate_constant_p): Check microblaze_cannot_force_const_mem\n    and microblaze_tls_symbol_p.\n   (TARGET_CANNOT_FORCE_CONST_MEM): Define.\n * config/microblaze/microblaze.h (TLS_NEEDS_GOT): Define\n   (PIC_OFFSET_TABLE_REGNUM): Set.\n * config/microblaze/linux.h (TLS_NEEDS_GOT): Define.\n * config/microblaze/microblaze.md (UNSPEC_TLS): Define.\n   (addsi3, movsi_internal2, movdf_internal): Update constraints\n * config/microblaze/predicates.md (arith_plus_operand): Define\n   (move_operand): Redefine as move_src_operand, check microblaze_tls_referenced_p.\n\n\n\nCo-Authored-By: David Holsgrove <david.holsgrove@xilinx.com>\n\nFrom-SVN: r196659", "tree": {"sha": "d50aa5b7886fb5d93895d40669595dd9aa771577", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d50aa5b7886fb5d93895d40669595dd9aa771577"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/comments", "author": {"login": "edgarigl", "id": 86901, "node_id": "MDQ6VXNlcjg2OTAx", "avatar_url": "https://avatars.githubusercontent.com/u/86901?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edgarigl", "html_url": "https://github.com/edgarigl", "followers_url": "https://api.github.com/users/edgarigl/followers", "following_url": "https://api.github.com/users/edgarigl/following{/other_user}", "gists_url": "https://api.github.com/users/edgarigl/gists{/gist_id}", "starred_url": "https://api.github.com/users/edgarigl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edgarigl/subscriptions", "organizations_url": "https://api.github.com/users/edgarigl/orgs", "repos_url": "https://api.github.com/users/edgarigl/repos", "events_url": "https://api.github.com/users/edgarigl/events{/privacy}", "received_events_url": "https://api.github.com/users/edgarigl/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a7137ee176cc7491b220281df0b592674740e2a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7137ee176cc7491b220281df0b592674740e2a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7137ee176cc7491b220281df0b592674740e2a6"}], "stats": {"total": 748, "additions": 623, "deletions": 125}, "files": [{"sha": "c7639ea470a29d8c2f827b1d11c3891db6f8447e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91", "patch": "@@ -1,3 +1,41 @@\n+2013-03-14  Edgar E. Iglesias <edgar.iglesias@xilinx.com>\n+\t    David Holsgrove <david.holsgrove@xilinx.com>\n+\n+\t* configure.ac: Add MicroBlaze TLS support detection.\n+\t* configure: Regenerate.\n+\t* config/microblaze/microblaze-protos.h: (microblaze_cannot_force_const_mem,\n+\tmicroblaze_tls_referenced_p, symbol_mentioned_p, label_mentioned_p): \n+\tAdd prototypes.\n+\t* config/microblaze/microblaze.c (microblaze_address_type): Add ADDRESS_TLS\n+\tand tls_reloc address types.\n+\t(microblaze_address_info): Add tls_reloc.\n+\t(TARGET_HAVE_TLS): Define.\n+\t(get_tls_get_addr, microblaze_tls_symbol_p, microblaze_tls_operand_p_1,\n+\t microblaze_tls_referenced_p, microblaze_cannot_force_const_mem,\n+\t symbol_mentioned_p, label_mentioned_p, tls_mentioned_p, load_tls_operand,\n+\t microblaze_call_tls_get_addr, microblaze_legitimize_tls_address): New functions.\n+\t(microblaze_classify_unspec): Handle UNSPEC_TLS.\n+\t(get_base_reg): Use microblaze_tls_symbol_p.\n+\t(microblaze_classify_address): Handle TLS.\n+\t(microblaze_legitimate_pic_operand): Use symbol_mentioned_p, label_mentioned_p\n+\tand microblaze_tls_referenced_p.\n+\t(microblaze_legitimize_address): Handle TLS.\n+\t(microblaze_address_insns): Handle ADDRESS_TLS.\n+\t(pic_address_needs_scratch): Handle TLS.\n+\t(print_operand_address): Handle TLS.\n+\t(microblaze_expand_prologue): Check TLS_NEEDS_GOT.\n+\t(microblaze_expand_move): Handle TLS.\n+\t(microblaze_legitimate_constant_p): Check microblaze_cannot_force_const_mem\n+\tand microblaze_tls_symbol_p.\n+\t(TARGET_CANNOT_FORCE_CONST_MEM): Define.\n+\t* config/microblaze/microblaze.h (TLS_NEEDS_GOT): Define\n+\t(PIC_OFFSET_TABLE_REGNUM): Set.\n+\t* config/microblaze/linux.h (TLS_NEEDS_GOT): Define.\n+\t* config/microblaze/microblaze.md (UNSPEC_TLS): Define.\n+\t(addsi3, movsi_internal2, movdf_internal): Update constraints\n+\t* config/microblaze/predicates.md (arith_plus_operand): Define\n+\t(move_operand): Redefine as move_src_operand, check microblaze_tls_referenced_p.\n+\n 2013-03-14  Ian Bolton  <ian.bolton@arm.com>\n \n \t* config/aarch64/aarch64.md: (*and<mode>3nr_compare0): Use CC_NZ."}, {"sha": "a7b7a1adcfa56c0d30cbe6ec68adb2fcf1726849", "filename": "gcc/config/microblaze/linux.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfig%2Fmicroblaze%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfig%2Fmicroblaze%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Flinux.h?ref=8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91", "patch": "@@ -22,6 +22,9 @@\n #undef TARGET_SUPPORTS_PIC\n #define TARGET_SUPPORTS_PIC 1\n \n+#undef TLS_NEEDS_GOT\n+#define TLS_NEEDS_GOT 1\n+\n #define DYNAMIC_LINKER \"/lib/ld.so.1\"\n #undef  SUBTARGET_EXTRA_SPECS\n #define SUBTARGET_EXTRA_SPECS \\"}, {"sha": "34be76ffa637dcbff223fba42c368521a8994d9b", "filename": "gcc/config/microblaze/microblaze-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-protos.h?ref=8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91", "patch": "@@ -50,6 +50,10 @@ extern void microblaze_declare_object (FILE *, const char *, const char *,\n    const char *, int);\n extern void microblaze_asm_output_ident (const char *);\n extern int microblaze_legitimate_pic_operand (rtx);\n+extern bool microblaze_tls_referenced_p (rtx);\n+extern int symbol_mentioned_p (rtx);\n+extern int label_mentioned_p (rtx);\n+extern bool microblaze_cannot_force_const_mem (enum machine_mode, rtx);\n #endif  /* RTX_CODE */\n \n /* Declare functions in microblaze-c.c.  */"}, {"sha": "c121c2baec32e7c977aabf90410275b37237ba60", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 487, "deletions": 109, "changes": 596, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91", "patch": "@@ -84,7 +84,8 @@ enum microblaze_address_type\n   ADDRESS_CONST_INT,\n   ADDRESS_SYMBOLIC,\n   ADDRESS_GOTOFF,\n-  ADDRESS_PLT\n+  ADDRESS_PLT,\n+  ADDRESS_TLS\n };\n \n /* Classifies symbols\n@@ -98,6 +99,15 @@ enum microblaze_symbol_type\n   SYMBOL_TYPE_GENERAL\n };\n \n+/* TLS Address Type.  */\n+enum tls_reloc {\n+  TLS_GD,\n+  TLS_LDM,\n+  TLS_DTPREL,\n+  TLS_IE,\n+  TLS_LE\n+};\n+\n /* Classification of a MicroBlaze address.  */\n struct microblaze_address_info\n {\n@@ -108,6 +118,7 @@ struct microblaze_address_info\n   rtx offset; \t/* Contains valid values on ADDRESS_CONST_INT and ADDRESS_REG.  */\n   rtx symbol; \t/* Contains valid values on ADDRESS_SYMBOLIC.  */\n   enum microblaze_symbol_type symbol_type;\n+  enum tls_reloc tls_type;\n };\n \n /* Structure to be filled in by compute_frame_size with register\n@@ -215,6 +226,11 @@ static int microblaze_interrupt_function_p (tree);\n \n section *sdata2_section;\n \n+#ifdef HAVE_AS_TLS\n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS true\n+#endif\n+\n /* Return truth value if a CONST_DOUBLE is ok to be a legitimate constant.  */\n static bool\n microblaze_const_double_ok (rtx op, enum machine_mode mode)\n@@ -287,6 +303,9 @@ simple_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n       plus0 = XEXP (addr, 0);\n       plus1 = XEXP (addr, 1);\n \n+      if (GET_CODE (plus0) != REG)\n+        return 0;\n+\n       if (GET_CODE (plus0) == REG && GET_CODE (plus1) == CONST_INT\n \t  && SMALL_INT (plus1))\n \t{\n@@ -386,6 +405,225 @@ microblaze_valid_base_register_p (rtx x,\n \t  && microblaze_regno_ok_for_base_p (REGNO (x), strict));\n }\n \n+/* Build the SYMBOL_REF for __tls_get_addr.  */\n+\n+static GTY(()) rtx tls_get_addr_libfunc;\n+\n+static rtx\n+get_tls_get_addr (void)\n+{\n+  if (!tls_get_addr_libfunc)\n+    tls_get_addr_libfunc = init_one_libfunc (\"__tls_get_addr\");\n+  return tls_get_addr_libfunc;\n+}\n+\n+/* Return TRUE if X is a thread-local symbol.  */\n+bool\n+microblaze_tls_symbol_p (rtx x)\n+{\n+  if (!TARGET_HAVE_TLS)\n+    return false;\n+\n+  if (GET_CODE (x) != SYMBOL_REF)\n+    return false;\n+\n+  return SYMBOL_REF_TLS_MODEL (x) != 0;\n+}\n+\n+static int\n+microblaze_tls_operand_p_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n+{\n+  if (GET_CODE (*x) == SYMBOL_REF)\n+    return SYMBOL_REF_TLS_MODEL (*x) != 0;\n+\n+  /* Don't recurse into UNSPEC_TLS looking for TLS symbols; these are\n+     TLS offsets, not real symbol references.  */\n+  if (GET_CODE (*x) == UNSPEC && XINT (*x, 1) == UNSPEC_TLS)\n+    return -1;\n+\n+  return 0;\n+}\n+\n+/* Return TRUE if X contains any TLS symbol references.  */\n+\n+bool\n+microblaze_tls_referenced_p (rtx x)\n+{\n+  if (!TARGET_HAVE_TLS)\n+    return false;\n+\n+  return for_each_rtx (&x, microblaze_tls_operand_p_1, NULL);\n+}\n+\n+bool\n+microblaze_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+{\n+  return microblaze_tls_referenced_p(x);\n+}\n+\n+/* Return TRUE if X references a SYMBOL_REF.  */\n+int\n+symbol_mentioned_p (rtx x)\n+{\n+  const char * fmt;\n+  int i;\n+\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    return 1;\n+\n+  /* UNSPEC entries for a symbol include the SYMBOL_REF, but they\n+     are constant offsets, not symbols.  */\n+  if (GET_CODE (x) == UNSPEC)\n+    return 0;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+        {\n+          int j;\n+\n+          for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+            if (symbol_mentioned_p (XVECEXP (x, i, j)))\n+              return 1;\n+        }\n+      else if (fmt[i] == 'e' && symbol_mentioned_p (XEXP (x, i)))\n+        return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return TRUE if X references a LABEL_REF.  */\n+int\n+label_mentioned_p (rtx x)\n+{\n+  const char * fmt;\n+  int i;\n+\n+  if (GET_CODE (x) == LABEL_REF)\n+    return 1;\n+\n+  /* UNSPEC entries for a symbol include a LABEL_REF for the referencing\n+     instruction, but they are constant offsets, not symbols.  */\n+  if (GET_CODE (x) == UNSPEC)\n+    return 0;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+        {\n+          int j;\n+\n+          for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+            if (label_mentioned_p (XVECEXP (x, i, j)))\n+              return 1;\n+        }\n+      else if (fmt[i] == 'e' && label_mentioned_p (XEXP (x, i)))\n+        return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+int\n+tls_mentioned_p (rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+      case CONST:\n+        return tls_mentioned_p (XEXP (x, 0));\n+\n+      case UNSPEC:\n+        if (XINT (x, 1) == UNSPEC_TLS)\n+          return 1;\n+\n+      default:\n+        return 0;\n+    }\n+}\n+\n+static rtx\n+load_tls_operand (rtx x, rtx reg)\n+{\n+  rtx tmp;\n+\n+  if (reg == NULL_RTX)\n+    reg = gen_reg_rtx (Pmode);\n+\n+  tmp = gen_rtx_CONST (Pmode, x);\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, reg,\n+                          gen_rtx_PLUS (Pmode, pic_offset_table_rtx, tmp)));\n+\n+  return reg;\n+}\n+\n+static rtx\n+microblaze_call_tls_get_addr (rtx x, rtx reg, rtx *valuep, int reloc)\n+{\n+  rtx insns, tls_entry;\n+\n+  df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n+\n+  start_sequence ();\n+\n+  tls_entry = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, x, GEN_INT (reloc)),\n+                              UNSPEC_TLS);\n+\n+  reg = load_tls_operand (tls_entry, reg);\n+\n+  *valuep = emit_library_call_value (get_tls_get_addr (), NULL_RTX,\n+                                     LCT_PURE, /* LCT_CONST?  */\n+                                     Pmode, 1, reg, Pmode);\n+\n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  return insns;\n+}\n+\n+rtx\n+microblaze_legitimize_tls_address(rtx x, rtx reg)\n+{\n+  rtx dest, insns, ret, eqv, addend;\n+  enum tls_model model;\n+  model = SYMBOL_REF_TLS_MODEL (x);\n+\n+  switch (model)\n+    {\n+       case TLS_MODEL_LOCAL_DYNAMIC:\n+       case TLS_MODEL_GLOBAL_DYNAMIC:\n+       case TLS_MODEL_INITIAL_EXEC:\n+         insns = microblaze_call_tls_get_addr (x, reg, &ret, TLS_GD);\n+         dest = gen_reg_rtx (Pmode);\n+         emit_libcall_block (insns, dest, ret, x);\n+         break;\n+\n+       case TLS_MODEL_LOCAL_EXEC:\n+         insns = microblaze_call_tls_get_addr (x, reg, &ret, TLS_LDM);\n+\n+         /* Attach a unique REG_EQUIV, to allow the RTL optimizers to\n+            share the LDM result with other LD model accesses.  */\n+         eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const1_rtx), UNSPEC_TLS);\n+         dest = gen_reg_rtx (Pmode);\n+         emit_libcall_block (insns, dest, ret, eqv);\n+\n+         /* Load the addend.  */\n+         addend = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, x, GEN_INT (TLS_DTPREL)),\n+\t\t\t\t  UNSPEC_TLS);\n+         addend = force_reg (SImode, gen_rtx_CONST (SImode, addend));\n+         dest = gen_rtx_PLUS (Pmode, dest, addend);\n+         break;\n+\n+       default:\n+         gcc_unreachable ();\n+    }\n+  return dest;\n+}\n+\n static bool\n microblaze_classify_unspec (struct microblaze_address_info *info, rtx x)\n {\n@@ -401,6 +639,11 @@ microblaze_classify_unspec (struct microblaze_address_info *info, rtx x)\n     {\n       info->type = ADDRESS_PLT;\n     }\n+  else if (XINT (x, 1) == UNSPEC_TLS)\n+    {\n+      info->type = ADDRESS_TLS;\n+      info->tls_type = tls_reloc INTVAL(XVECEXP(x, 0, 1));\n+    }\n   else\n     {\n       return false;\n@@ -431,7 +674,12 @@ static int\n get_base_reg (rtx x)\n {\n   tree decl;\n-  int base_reg = (flag_pic ? MB_ABI_PIC_ADDR_REGNUM : MB_ABI_BASE_REGNUM);\n+  int base_reg;\n+\n+  if (!flag_pic || microblaze_tls_symbol_p(x))\n+    base_reg = MB_ABI_BASE_REGNUM;\n+  else if (flag_pic)\n+    base_reg = MB_ABI_PIC_ADDR_REGNUM;\n \n   if (TARGET_XLGPOPT\n       && GET_CODE (x) == SYMBOL_REF\n@@ -509,28 +757,61 @@ microblaze_classify_address (struct microblaze_address_info *info, rtx x,\n \t      }\n \t    else if (GET_CODE (xplus1) == UNSPEC)\n \t      {\n+\t\t/* Need offsettable address.  */\n+\t\tif (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+\t\t  return false;\n+\n \t\treturn microblaze_classify_unspec (info, xplus1);\n \t      }\n \t    else if ((GET_CODE (xplus1) == SYMBOL_REF ||\n-\t\t      GET_CODE (xplus1) == LABEL_REF) && flag_pic == 2)\n-\t      {\n-\t\treturn false;\n-\t      }\n-\t    else if (GET_CODE (xplus1) == SYMBOL_REF ||\n-\t\t     GET_CODE (xplus1) == LABEL_REF ||\n-\t\t     GET_CODE (xplus1) == CONST)\n+\t\t      GET_CODE (xplus1) == LABEL_REF))\n \t      {\n-\t\tif (GET_CODE (XEXP (xplus1, 0)) == UNSPEC)\n-\t\t  return microblaze_classify_unspec (info, XEXP (xplus1, 0));\n-\t\telse if (flag_pic == 2)\n-\t\t  {\n-\t\t    return false;\n-\t\t  }\n+\t\tif (flag_pic == 2 || microblaze_tls_symbol_p(xplus1))\n+\t\t  return false;\n \t\tinfo->type = ADDRESS_SYMBOLIC;\n \t\tinfo->symbol = xplus1;\n \t\tinfo->symbol_type = SYMBOL_TYPE_GENERAL;\n \t\treturn true;\n \t      }\n+\t    else if (GET_CODE (xplus1) == CONST)\n+\t      {\n+\t\trtx xconst0 = XEXP(xplus1, 0);\n+\n+\t\t/* base + unspec.  */\n+\t\tif (GET_CODE (xconst0) == UNSPEC)\n+\t\t  {\n+\t\t    /* Need offsettable address.  */\n+\t\t    if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+\t\t      return false;\n+\t\t    return microblaze_classify_unspec(info, xconst0);\n+\t\t  }\n+\n+\t\t/* for (plus x const_int) just look at x.  */\n+\t\tif (GET_CODE (xconst0) == PLUS\n+\t\t    && GET_CODE (XEXP (xconst0, 1)) == CONST_INT\n+\t\t    && SMALL_INT (XEXP (xconst0, 1)))\n+\t\t  {\n+\t\t    /* This is ok as info->symbol is set to xplus1 the full\n+\t\t       const-expression below.  */\n+\t\t    xconst0 = XEXP (xconst0, 0);\n+\t\t  }\n+\n+\t\tif (GET_CODE (xconst0) == SYMBOL_REF\n+\t\t    || GET_CODE (xconst0) == LABEL_REF)\n+\t\t  {\n+\t\t    if (flag_pic == 2 || microblaze_tls_symbol_p(xconst0))\n+\t\t      return false;\n+\n+\t\t    info->type = ADDRESS_SYMBOLIC;\n+\t\t    info->symbol = xplus1;\n+\t\t    info->symbol_type = SYMBOL_TYPE_GENERAL;\n+\t\t    return true;\n+\t\t  }\n+\n+\t\t/* Not base + symbol || base + UNSPEC.  */\n+\t\treturn false;\n+\n+\t      }\n \t    else if (GET_CODE (xplus1) == REG\n \t\t     && microblaze_valid_index_register_p (xplus1, mode,\n \t\t\t\t\t\t\t   strict)\n@@ -562,13 +843,20 @@ microblaze_classify_address (struct microblaze_address_info *info, rtx x,\n \n \tif (GET_CODE (x) == CONST)\n \t  {\n-\t    return !(flag_pic && pic_address_needs_scratch (x));\n-\t  }\n-\telse if (flag_pic == 2)\n-\t  {\n-\t    return false;\n+\t    if (GET_CODE (XEXP (x, 0)) == UNSPEC)\n+\t     {\n+\t\tinfo->regA = gen_rtx_raw_REG (mode,\n+\t\t\t\t  get_base_reg (XVECEXP (XEXP (x,0), 0, 0)));\n+\t\treturn microblaze_classify_unspec (info, XEXP (x, 0));\n+\t     }\n+\t     return !(flag_pic && pic_address_needs_scratch (x));\n \t  }\n \n+\tif (flag_pic == 2)\n+\t  return false;\n+\telse if (microblaze_tls_symbol_p(x))\n+\t  return false;\n+\n \treturn true;\n       }\n \n@@ -616,11 +904,10 @@ microblaze_valid_pic_const (rtx x)\n int\n microblaze_legitimate_pic_operand (rtx x)\n {\n-  struct microblaze_address_info addr;\n-\n-  if (pic_address_needs_scratch (x))\n+  if (flag_pic == 2 && (symbol_mentioned_p(x) || label_mentioned_p(x)))\n     return 0;\n-  if (!microblaze_valid_pic_const(x))\n+\n+  if (microblaze_tls_referenced_p(x))\n     return 0;\n \n   return 1;\n@@ -706,7 +993,7 @@ microblaze_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t  return result;\n \t}\n \n-      if (code0 == REG && REG_OK_FOR_BASE_P (xplus0) && flag_pic == 2)\n+      if (code0 == REG && REG_OK_FOR_BASE_P (xplus0))\n \t{\n \t  if (reload_in_progress)\n \t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n@@ -717,26 +1004,58 @@ microblaze_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t    }\n \t  if (code1 == SYMBOL_REF)\n \t    {\n-\t      result =\n-\t\tgen_rtx_UNSPEC (Pmode, gen_rtvec (1, xplus1), UNSPEC_GOTOFF);\n-\t      result = gen_rtx_CONST (Pmode, result);\n-\t      result = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, result);\n-\t      result = gen_const_mem (Pmode, result);\n-\t      result = gen_rtx_PLUS (Pmode, xplus0, result);\n-\t      return result;\n+\t      if (microblaze_tls_symbol_p(xplus1))\n+\t\t{\n+\t\t  rtx tls_ref, reg;\n+\t\t  reg = gen_reg_rtx (Pmode);\n+\n+\t\t  tls_ref = microblaze_legitimize_tls_address (xplus1,\n+\t\t\t\t\t\t\t       NULL_RTX);\n+\t\t  emit_move_insn (reg, tls_ref);\n+\n+\t\t  result = gen_rtx_PLUS (Pmode, xplus0, reg);\n+\n+\t\t  return result;\n+\t\t}\n+\t      else if (flag_pic == 2)\n+\t\t{\n+\t\t  rtx pic_ref, reg;\n+\t\t  reg = gen_reg_rtx (Pmode);\n+\n+\t\t  pic_ref = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, xplus1),\n+\t\t\t\t\t    UNSPEC_GOTOFF);\n+\t\t  pic_ref = gen_rtx_CONST (Pmode, pic_ref);\n+\t\t  pic_ref = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, pic_ref);\n+\t\t  pic_ref = gen_const_mem (Pmode, pic_ref);\n+\t\t  emit_move_insn (reg, pic_ref);\n+\t\t  result = gen_rtx_PLUS (Pmode, xplus0, reg);\n+\t\t  return result;\n+\t\t}\n \t    }\n \t}\n     }\n \n   if (GET_CODE (xinsn) == SYMBOL_REF)\n     {\n-      if (reload_in_progress)\n-\tdf_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n-      result = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, xinsn), UNSPEC_GOTOFF);\n-      result = gen_rtx_CONST (Pmode, result);\n-      result = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, result);\n-      result = gen_const_mem (Pmode, result);\n-      return result;\n+      rtx reg;\n+      if (microblaze_tls_symbol_p(xinsn))\n+        {\n+          reg = microblaze_legitimize_tls_address (xinsn, NULL_RTX);\n+        }\n+      else\n+        {\n+          rtx pic_ref;\n+\n+          if (reload_in_progress)\n+            df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n+\n+          pic_ref = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, xinsn), UNSPEC_GOTOFF);\n+          pic_ref = gen_rtx_CONST (Pmode, pic_ref);\n+          pic_ref = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, pic_ref);\n+          pic_ref = gen_const_mem (Pmode, pic_ref);\n+          reg = pic_ref;\n+        }\n+      return reg;\n     }\n \n   return x;\n@@ -1061,10 +1380,22 @@ microblaze_address_insns (rtx x, enum machine_mode mode)\n \t  else\n \t    return 2;\n \tcase ADDRESS_REG_INDEX:\n-\tcase ADDRESS_SYMBOLIC:\n \t  return 1;\n+\tcase ADDRESS_SYMBOLIC:\n \tcase ADDRESS_GOTOFF:\n \t  return 2;\n+\tcase ADDRESS_TLS:\n+\t  switch (addr.tls_type)\n+\t    {\n+\t      case TLS_GD:\n+\t\treturn 2;\n+\t      case TLS_LDM:\n+\t\treturn 2;\n+\t      case TLS_DTPREL:\n+\t\treturn 1;\n+\t      default :\n+\t\tabort();\n+\t    }\n \tdefault:\n \t  break;\n \t}\n@@ -1088,13 +1419,18 @@ microblaze_address_cost (rtx addr, enum machine_mode mode ATTRIBUTE_UNUSED,\n int\n pic_address_needs_scratch (rtx x)\n {\n-  /* An address which is a symbolic plus a non SMALL_INT needs a temp reg.  */\n-  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n-      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-      && (flag_pic == 2 || !SMALL_INT (XEXP (XEXP (x, 0), 1))))\n-    return 1;\n+  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x,0)) == PLUS)\n+    {\n+     rtx p0, p1;\n \n+      p0 = XEXP (XEXP (x, 0), 0);\n+      p1 = XEXP (XEXP (x, 0), 1);\n+\n+      if ((GET_CODE (p0) == SYMBOL_REF || GET_CODE (p0) == LABEL_REF)\n+          && (GET_CODE (p1) == CONST_INT)\n+          && (flag_pic == 2 || microblaze_tls_symbol_p (p0) || !SMALL_INT (p1)))\n+        return 1;\n+    }\n   return 0;\n }\n \n@@ -1918,6 +2254,7 @@ print_operand (FILE * file, rtx op, int letter)\n \t    case ADDRESS_CONST_INT:\n \t    case ADDRESS_SYMBOLIC:\n \t    case ADDRESS_GOTOFF:\n+\t    case ADDRESS_TLS:\n \t      fputs (\"i\", file);\n \t      break;\n \t    case ADDRESS_REG_INDEX:\n@@ -2034,10 +2371,19 @@ print_operand (FILE * file, rtx op, int letter)\n   else if (letter == 't')\n     fputs (code == EQ ? \"t\" : \"f\", file);\n \n-  else if (code == CONST && GET_CODE (XEXP (op, 0)) == REG)\n+  else if (code == CONST\n+           && ((GET_CODE (XEXP (op, 0)) == REG)\n+               || (GET_CODE (XEXP (op, 0)) == UNSPEC)))\n     {\n       print_operand (file, XEXP (op, 0), letter);\n     }\n+  else if (code == CONST\n+           && (GET_CODE (XEXP (op, 0)) == PLUS)\n+           && (GET_CODE (XEXP (XEXP (op, 0), 0)) == REG)\n+           && (GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST))\n+    {\n+      print_operand_address (file, XEXP (op, 0));\n+    }\n   else if (letter == 'm')\n     fprintf (file, HOST_WIDE_INT_PRINT_DEC, (1L << INTVAL (op)));\n   else\n@@ -2098,6 +2444,7 @@ print_operand_address (FILE * file, rtx addr)\n     case ADDRESS_SYMBOLIC:\n     case ADDRESS_GOTOFF:\n     case ADDRESS_PLT:\n+    case ADDRESS_TLS:\n       if (info.regA)\n \tfprintf (file, \"%s,\", reg_names[REGNO (info.regA)]);\n       output_addr_const (file, info.symbol);\n@@ -2109,6 +2456,24 @@ print_operand_address (FILE * file, rtx addr)\n \t{\n \t  fputs (\"@PLT\", file);\n \t}\n+      else if (type == ADDRESS_TLS)\n+\t{\n+\t  switch (info.tls_type)\n+\t    {\n+\t      case TLS_GD:\n+\t\tfputs (\"@TLSGD\", file);\n+\t\tbreak;\n+\t      case TLS_LDM:\n+\t\tfputs (\"@TLSLDM\", file);\n+\t\tbreak;\n+\t      case TLS_DTPREL:\n+\t\tfputs (\"@TLSDTPREL\", file);\n+\t\tbreak;\n+\t      default :\n+\t\tabort();\n+\t\tbreak;\n+\t    }\n+\t}\n       break;\n     case ADDRESS_INVALID:\n       fatal_insn (\"invalid address\", addr);\n@@ -2471,7 +2836,8 @@ microblaze_expand_prologue (void)\n \t}\n     }\n \n-  if (flag_pic == 2 && df_regs_ever_live_p (MB_ABI_PIC_ADDR_REGNUM))\n+  if ((flag_pic == 2 || TLS_NEEDS_GOT )\n+      && df_regs_ever_live_p (MB_ABI_PIC_ADDR_REGNUM))\n     {\n       SET_REGNO (pic_offset_table_rtx, MB_ABI_PIC_ADDR_REGNUM);\n       emit_insn (gen_set_got (pic_offset_table_rtx));\t/* setting GOT.  */\n@@ -2701,83 +3067,62 @@ expand_pic_symbol_ref (enum machine_mode mode ATTRIBUTE_UNUSED, rtx op)\n bool\n microblaze_expand_move (enum machine_mode mode, rtx operands[])\n {\n+  rtx op0, op1;\n+\n+  op0 = operands[0];\n+  op1 = operands[1];\n+\n+  if (!register_operand (op0, SImode)\n+      && !register_operand (op1, SImode)\n+      && (GET_CODE (op1) != CONST_INT || INTVAL (op1) != 0))\n+    {\n+      rtx temp = force_reg (SImode, op1);\n+      emit_move_insn (op0, temp);\n+      return true;\n+    }\n   /* If operands[1] is a constant address invalid for pic, then we need to\n      handle it just like LEGITIMIZE_ADDRESS does.  */\n-  if (flag_pic)\n+  if (GET_CODE (op1) == SYMBOL_REF || GET_CODE (op1) == LABEL_REF)\n     {\n-      if (GET_CODE (operands[0]) == MEM)\n+      rtx result;\n+      if (microblaze_tls_symbol_p(op1))\n \t{\n-\t  rtx addr = XEXP (operands[0], 0);\n-\t  if (GET_CODE (addr) == SYMBOL_REF)\n-\t    {\n-\t      rtx ptr_reg, result;\n-\n-\t      if (reload_in_progress)\n-\t\tdf_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n-\n-\t      addr = expand_pic_symbol_ref (mode, addr);\n-\t      ptr_reg = gen_reg_rtx (Pmode);\n-\t      emit_move_insn (ptr_reg, addr);\n-\t      result = gen_rtx_MEM (mode, ptr_reg);\n-\t      operands[0] = result;\n-\t    }\n+\t  result = microblaze_legitimize_tls_address (op1, NULL_RTX);\n+\t  emit_move_insn (op0, result);\n+\t  return true;\n \t}\n-      if (GET_CODE (operands[1]) == SYMBOL_REF\n-\t  || GET_CODE (operands[1]) == LABEL_REF)\n+      else if (flag_pic)\n \t{\n-\t  rtx result;\n \t  if (reload_in_progress)\n \t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n-\t  result = expand_pic_symbol_ref (mode, operands[1]);\n-\t  if (GET_CODE (operands[0]) != REG)\n-\t    {\n-\t      rtx ptr_reg = gen_reg_rtx (Pmode);\n-\t      emit_move_insn (ptr_reg, result);\n-\t      emit_move_insn (operands[0], ptr_reg);\n-\t    }\n-\t  else\n-\t    {\n-\t      emit_move_insn (operands[0], result);\n-\t    }\n+\t  result = expand_pic_symbol_ref (mode, op1);\n+\t  emit_move_insn (op0, result);\n \t  return true;\n \t}\n-      else if (GET_CODE (operands[1]) == MEM &&\n-\t       GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n-\t{\n-\t  rtx result;\n-\t  rtx ptr_reg;\n-\t  if (reload_in_progress)\n-\t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n-\t  result = expand_pic_symbol_ref (mode, XEXP (operands[1], 0));\n+    }\n+  /* Handle Case of (const (plus symbol const_int)).  */\n+  if (GET_CODE (op1) == CONST && GET_CODE (XEXP (op1,0)) == PLUS)\n+    {\n+      rtx p0, p1;\n \n-\t  ptr_reg = gen_reg_rtx (Pmode);\n+      p0 = XEXP (XEXP (op1, 0), 0);\n+      p1 = XEXP (XEXP (op1, 0), 1);\n \n-\t  emit_move_insn (ptr_reg, result);\n-\t  result = gen_rtx_MEM (mode, ptr_reg);\n-\t  emit_move_insn (operands[0], result);\n-\t  return true;\n-\t}\n-      else if (pic_address_needs_scratch (operands[1]))\n+      if ((GET_CODE (p1) == CONST_INT)\n+\t  && ((GET_CODE (p0) == UNSPEC)\n+\t      || ((GET_CODE (p0) == SYMBOL_REF || GET_CODE (p0) == LABEL_REF)\n+\t          && (flag_pic == 2 || microblaze_tls_symbol_p (p0)\n+\t\t      || !SMALL_INT (p1)))))\n \t{\n-\t  rtx temp = force_reg (SImode, XEXP (XEXP (operands[1], 0), 0));\n-\t  rtx temp2 = XEXP (XEXP (operands[1], 0), 1);\n+\t  rtx temp = force_reg (SImode, p0);\n+\t  rtx temp2 = p1;\n \n-\t  if (reload_in_progress)\n+\t  if (flag_pic && reload_in_progress)\n \t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n-\t  emit_move_insn (operands[0], gen_rtx_PLUS (SImode, temp, temp2));\n+\t  emit_move_insn (op0, gen_rtx_PLUS (SImode, temp, temp2));\n \t  return true;\n \t}\n     }\n-\n-  if ((reload_in_progress | reload_completed) == 0\n-      && !register_operand (operands[0], SImode)\n-      && !register_operand (operands[1], SImode)\n-      && (GET_CODE (operands[1]) != CONST_INT || INTVAL (operands[1]) != 0))\n-    {\n-      rtx temp = force_reg (SImode, operands[1]);\n-      emit_move_insn (operands[0], temp);\n-      return true;\n-    }\n   return false;\n }\n \n@@ -3048,10 +3393,40 @@ microblaze_adjust_cost (rtx insn ATTRIBUTE_UNUSED, rtx link,\n    At present, GAS doesn't understand li.[sd], so don't allow it\n    to be generated at present.  */\n static bool\n-microblaze_legitimate_constant_p (enum machine_mode mode, rtx x)\n+microblaze_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n-  return GET_CODE (x) != CONST_DOUBLE || microblaze_const_double_ok (x, mode);\n+\n+  if (microblaze_cannot_force_const_mem(mode, x))\n+        return false;\n+\n+  if (GET_CODE (x) == CONST_DOUBLE)\n+    {\n+      return microblaze_const_double_ok (x, GET_MODE (x));\n+    }\n+\n+   /* Handle Case of (const (plus unspec const_int)).  */\n+   if (GET_CODE (x) == CONST && GET_CODE (XEXP (x,0)) == PLUS)\n+     {\n+        rtx p0, p1;\n+\n+        p0 = XEXP (XEXP (x, 0), 0);\n+        p1 = XEXP (XEXP (x, 0), 1);\n+\n+        if (GET_CODE(p1) == CONST_INT)\n+          {\n+            /* Const offset from UNSPEC is not supported.  */\n+            if ((GET_CODE (p0) == UNSPEC))\n+              return false;\n+\n+            if ((GET_CODE (p0) == SYMBOL_REF || GET_CODE (p0) == LABEL_REF)\n+                 && (microblaze_tls_symbol_p (p0) || !SMALL_INT (p1)))\n+              return false;\n+          }\n+      }\n+\n+  return true;\n }\n+\n \f\n #undef TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO      microblaze_encode_section_info\n@@ -3068,6 +3443,9 @@ microblaze_legitimate_constant_p (enum machine_mode mode, rtx x)\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS                microblaze_rtx_costs\n \n+#undef TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM   microblaze_cannot_force_const_mem\n+\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST             microblaze_address_cost\n "}, {"sha": "bc4d9a128d1de46ca1669c6d7ab897e0f48f7cb7", "filename": "gcc/config/microblaze/microblaze.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h?ref=8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91", "patch": "@@ -65,6 +65,9 @@ extern enum pipeline_type microblaze_pipe;\n /* The default is to support PIC.  */\n #define TARGET_SUPPORTS_PIC 1\n \n+/* The default is to not need GOT for TLS.  */\n+#define TLS_NEEDS_GOT 0\n+\n /* What is the default setting for -mcpu= . We set it to v4.00.a even though \n    we are actually ahead. This is safest version that has generate code \n    compatible for the original ISA */\n@@ -326,9 +329,7 @@ extern char microblaze_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n \n #define NO_FUNCTION_CSE                 1\n \n-#define PIC_OFFSET_TABLE_REGNUM         \\\n-        (flag_pic ? (GP_REG_FIRST + MB_ABI_PIC_ADDR_REGNUM) : \\\n-        INVALID_REGNUM)\n+#define PIC_OFFSET_TABLE_REGNUM   (GP_REG_FIRST + MB_ABI_PIC_ADDR_REGNUM)\n \n enum reg_class\n {"}, {"sha": "3618cad524b6b7b766497976d2453864d010709c", "filename": "gcc/config/microblaze/microblaze.md", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md?ref=8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91", "patch": "@@ -40,6 +40,7 @@\n   (UNSPEC_PLT           103)    ;; jump table\n   (UNSPEC_CMP\t\t104)    ;; signed compare\n   (UNSPEC_CMPU\t\t105)    ;; unsigned compare\n+  (UNSPEC_TLS           106)    ;; jump table\n ])\n \n \n@@ -459,7 +460,7 @@\n (define_insn \"addsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n \t(plus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%dJ,dJ,dJ\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"d,I,i\")))]\n+\t\t (match_operand:SI 2 \"arith_plus_operand\" \"d,I,i\")))]\n   \"\"\n   \"@\n    addk\\t%0,%z1,%2\n@@ -892,8 +893,8 @@\n \n \n (define_insn \"*movdi_internal\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,R,m\")\n-\t(match_operand:DI 1 \"general_operand\"      \" d,i,J,R,m,d,d\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,R,o\")\n+\t(match_operand:DI 1 \"general_operand\"      \" d,i,J,R,o,d,d\"))]\n   \"\"\n   { \n     switch (which_alternative)\n@@ -999,13 +1000,9 @@\n   (set_attr \"length\"\t\"4\")])\n \n (define_insn \"*movsi_internal2\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,   d,d,R, T\")\n-\t(match_operand:SI 1 \"move_operand\"         \" d,I,Mnis,R,m,dJ,dJ\"))]\n-  \"(register_operand (operands[0], SImode)\n-    || register_operand (operands[1], SImode) \n-    || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\n-    && (flag_pic != 2 || (GET_CODE (operands[1]) != SYMBOL_REF \n-                         && GET_CODE (operands[1]) != LABEL_REF))\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,   d,d,R,m\")\n+\t(match_operand:SI 1 \"move_src_operand\"         \" d,I,Mnis,R,m,dJ,dJ\"))]\n+  \"\"\n   \"@\n    addk\\t%0,%1,r0\n    addik\\t%0,r0,%1\\t# %X1\n@@ -1196,7 +1193,7 @@\n ;; Applies to both TARGET_SOFT_FLOAT and TARGET_HARD_FLOAT\n ;;\n (define_insn \"*movdf_internal\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=d,d,d,d,To\")\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=d,d,d,d,o\")\n         (match_operand:DF 1 \"general_operand\" \"dG,o,F,T,d\"))]\n   \"\"\n   {"}, {"sha": "5fd1bd403720c8a7d442efc7bee48a42be25eb1c", "filename": "gcc/config/microblaze/predicates.md", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfig%2Fmicroblaze%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfig%2Fmicroblaze%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fpredicates.md?ref=8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91", "patch": "@@ -30,6 +30,52 @@\n        (and (match_code \"const_int,const_double\")\n \t    (match_test \"LARGE_INT (op)\"))))\n \n+(define_predicate \"arith_plus_operand\"\n+ (match_operand 0 \"general_operand\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+      default:\n+        return 0;\n+      case CONST_INT:\n+      case REG:\n+        return 1;\n+      case SYMBOL_REF:\n+      case LABEL_REF:\n+        if (flag_pic || microblaze_tls_referenced_p(op))\n+          return 0;\n+        return 1;\n+      case CONST:\n+        {\n+          rtx const0;\n+          const0 = XEXP (op, 0);\n+\n+          switch (GET_CODE(const0))\n+            {\n+              default:\n+                return 0;\n+              case UNSPEC :\n+                return 1;\n+\n+              case PLUS :\n+                {\n+                  rtx p0, p1;\n+                  p0 = XEXP (const0, 0);\n+                  p1 = XEXP (const0, 1);\n+\n+                  if ((GET_CODE(p0) == SYMBOL_REF\n+                       || GET_CODE (p0) == LABEL_REF)\n+                      && GET_CODE(p1) == CONST_INT)\n+                    {\n+                      return arith_plus_operand (p0, GET_MODE(p0));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+  return 0;\n+})\n+\n (define_predicate \"const_0_operand\"\n   (and (match_code \"const_int,const_double\")\n        (match_test \"op == CONST0_RTX (GET_MODE (op))\")))\n@@ -54,14 +100,21 @@\n        (match_test \"GET_CODE (op) == REG || GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST_INT\")))\n \n ;; Return if OPERAND is valid as a source operand for a move instruction.\n-(define_predicate \"move_operand\"\n+(define_predicate \"move_src_operand\"\n   (and (\n      not (\n        and (match_code \"plus\")\n            (not (match_test \"(GET_CODE (XEXP (op, 0)) == REG) ^ (GET_CODE (XEXP (op,1)) == REG)\"))\n \t )\n        )\n-       (match_operand 0 \"general_operand\")))\n+       (match_operand 0 \"general_operand\"))\n+{\n+  if (microblaze_tls_referenced_p(op)\n+      || (flag_pic && (symbol_mentioned_p(op) || label_mentioned_p(op))))\n+    return false;\n+\n+  return true;\n+})\n \n ;; Test for valid PIC call operand\n (define_predicate \"call_insn_plt_operand\""}, {"sha": "e12a1803140eef202a26d76e813b2a5aeb35e2bb", "filename": "gcc/configure", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91", "patch": "@@ -23205,6 +23205,18 @@ foo:\tdata8\t25\n \ttls_first_minor=13\n \ttls_as_opt=--fatal-warnings\n \t;;\n+  microblaze*-*-*)\n+    conftest_s='\n+\t.section .tdata,\"awT\",@progbits\n+x:\n+\t.word 2\n+\t.text\n+\taddik r5,r20,x@TLSGD\n+\taddik r5,r20,x@TLSLDM'\n+\ttls_first_major=2\n+\ttls_first_minor=20\n+\ttls_as_opt='--fatal-warnings'\n+\t;;\n   mips*-*-*)\n     conftest_s='\n \t.section .tdata,\"awT\",@progbits"}, {"sha": "eba357746480f6a284464cdadd0af0debe750abf", "filename": "gcc/configure.ac", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=8cc9a5a584a57e06f1e2c83cb8ccd18a02a1bc91", "patch": "@@ -2968,6 +2968,18 @@ foo:\tdata8\t25\n \ttls_first_minor=13\n \ttls_as_opt=--fatal-warnings\n \t;;\n+  microblaze*-*-*)\n+    conftest_s='\n+\t.section .tdata,\"awT\",@progbits\n+x:\n+\t.word 2\n+\t.text\n+\taddik r5,r20,x@TLSGD\n+\taddik r5,r20,x@TLSLDM'\n+\ttls_first_major=2\n+\ttls_first_minor=20\n+\ttls_as_opt='--fatal-warnings'\n+\t;;\n   mips*-*-*)\n     conftest_s='\n \t.section .tdata,\"awT\",@progbits"}]}