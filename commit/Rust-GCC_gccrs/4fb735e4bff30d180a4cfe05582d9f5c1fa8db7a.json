{"sha": "4fb735e4bff30d180a4cfe05582d9f5c1fa8db7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZiNzM1ZTRiZmYzMGQxODBhNGNmZTA1NTgyZDlmNWMxZmE4ZGI3YQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-12-18T15:26:32Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-12-18T15:26:32Z"}, "message": "ifcvt.c (total_bb_rtx_cost): Rename function to cheap_bb_rtx_cost_p.\n\n\n\t* ifcvt.c (total_bb_rtx_cost): Rename function to cheap_bb_rtx_cost_p.\n\tTake a max_cost argument to avoid scanning large blocks, by returning\n\ta Boolean instead of a total.  Include the cost of a \"fstp %st(0)\"\n\tinstruction required to pop dead values off of a register stack.\n\nFrom-SVN: r92352", "tree": {"sha": "57af61e53f016ae3b3b8e14efe56886c54b417e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57af61e53f016ae3b3b8e14efe56886c54b417e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fb735e4bff30d180a4cfe05582d9f5c1fa8db7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb735e4bff30d180a4cfe05582d9f5c1fa8db7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fb735e4bff30d180a4cfe05582d9f5c1fa8db7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb735e4bff30d180a4cfe05582d9f5c1fa8db7a/comments", "author": null, "committer": null, "parents": [{"sha": "dbedefae43f712ee9f0636585bb1f91793c088d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbedefae43f712ee9f0636585bb1f91793c088d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbedefae43f712ee9f0636585bb1f91793c088d0"}], "stats": {"total": 50, "additions": 35, "deletions": 15}, "files": [{"sha": "55c29f996604b9afa57f2061f4907d856edcde05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb735e4bff30d180a4cfe05582d9f5c1fa8db7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb735e4bff30d180a4cfe05582d9f5c1fa8db7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fb735e4bff30d180a4cfe05582d9f5c1fa8db7a", "patch": "@@ -1,3 +1,10 @@\n+2004-12-18  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* ifcvt.c (total_bb_rtx_cost): Rename function to cheap_bb_rtx_cost_p.\n+\tTake a max_cost argument to avoid scanning large blocks, by returning\n+\ta Boolean instead of a total.  Include the cost of a \"fstp %st(0)\"\n+\tinstruction required to pop dead values off of a register stack.\n+\n 2004-12-18  Roger Sayle  <roger@eyesopen.com>\n \n \tPR middle-end/18548"}, {"sha": "98fbd667a01ac2dca65c09259a75ae4e41487000", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb735e4bff30d180a4cfe05582d9f5c1fa8db7a/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb735e4bff30d180a4cfe05582d9f5c1fa8db7a/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=4fb735e4bff30d180a4cfe05582d9f5c1fa8db7a", "patch": "@@ -86,7 +86,7 @@ static bool life_data_ok;\n \n /* Forward references.  */\n static int count_bb_insns (basic_block);\n-static int total_bb_rtx_cost (basic_block);\n+static bool cheap_bb_rtx_cost_p (basic_block, int);\n static rtx first_active_insn (basic_block);\n static rtx last_active_insn (basic_block, int);\n static basic_block block_fallthru (basic_block);\n@@ -162,12 +162,12 @@ count_bb_insns (basic_block bb)\n   return count;\n }\n \n-/* Count the total insn_rtx_cost of non-jump active insns in BB.\n-   This function returns -1, if the cost of any instruction could\n-   not be estimated.  */\n+/* Determine whether the total insn_rtx_cost on non-jump insns in\n+   basic block BB is less than MAX_COST.  This function returns\n+   false if the cost of any instruction could not be estimated.  */\n \n-static int\n-total_bb_rtx_cost (basic_block bb)\n+static bool\n+cheap_bb_rtx_cost_p (basic_block bb, int max_cost)\n {\n   int count = 0;\n   rtx insn = BB_HEAD (bb);\n@@ -178,18 +178,34 @@ total_bb_rtx_cost (basic_block bb)\n \t{\n \t  int cost = insn_rtx_cost (PATTERN (insn));\n \t  if (cost == 0)\n-\t    return -1;\n+\t    return false;\n+\n+\t  /* If this instruction is the load or set of a \"stack\" register,\n+\t     such as a floating point register on x87, then the cost of\n+\t     speculatively executing this instruction needs to include\n+\t     the additional cost of popping this register off of the\n+\t     register stack.  */\n+#ifdef STACK_REGS\n+\t  {\n+\t    rtx set = single_set (insn);\n+\t    if (set && STACK_REG_P (SET_DEST (set)))\n+\t      cost += COSTS_N_INSNS (1);\n+\t  }\n+#endif\n+\n \t  count += cost;\n+\t  if (count >= max_cost)\n+\t    return false;\n \t}\n       else if (CALL_P (insn))\n-\treturn -1;\n+\treturn false;\n  \n       if (insn == BB_END (bb))\n \tbreak;\n       insn = NEXT_INSN (insn);\n     }\n \n-  return count;\n+  return true;\n }\n \n /* Return the first non-jump active insn in the basic block.  */\n@@ -2853,7 +2869,7 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n {\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest, new_bb;\n-  int then_bb_index, bb_cost;\n+  int then_bb_index;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -2896,8 +2912,7 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \t     test_bb->index, then_bb->index);\n \n   /* THEN is small.  */\n-  bb_cost = total_bb_rtx_cost (then_bb);\n-  if (bb_cost < 0 || bb_cost >= COSTS_N_INSNS (BRANCH_COST))\n+  if (! cheap_bb_rtx_cost_p (then_bb, COSTS_N_INSNS (BRANCH_COST)))\n     return FALSE;\n \n   /* Registers set are dead, or are predicable.  */\n@@ -2944,7 +2959,6 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest;\n   edge else_succ;\n-  int bb_cost;\n   rtx note;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n@@ -3001,8 +3015,7 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n \t     test_bb->index, else_bb->index);\n \n   /* ELSE is small.  */\n-  bb_cost = total_bb_rtx_cost (else_bb);\n-  if (bb_cost < 0 || bb_cost >= COSTS_N_INSNS (BRANCH_COST))\n+  if (! cheap_bb_rtx_cost_p (else_bb, COSTS_N_INSNS (BRANCH_COST)))\n     return FALSE;\n \n   /* Registers set are dead, or are predicable.  */"}]}