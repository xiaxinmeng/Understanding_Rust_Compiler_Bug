{"sha": "a142a996267f9c8adf239a565725174265c67749", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE0MmE5OTYyNjdmOWM4YWRmMjM5YTU2NTcyNTE3NDI2NWM2Nzc0OQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2001-02-14T04:44:21Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-02-14T04:44:21Z"}, "message": "re PR libgcj/1758 (java.util package lacks TreeMap)\n\n        * java/util/TreeMap.java: New file.\n        * java/util/TreeSet.java: New file.\n        * Makefile.am: Add TreeMap and TreeSet. Enable WeakHashMap.\n        * Makefile.in: Rebuilt.\n        * java/util/HashSet.java (clone): Use constructor instead of calling\n        clone on itself.\n        * java/util/SortedSet.java: Sync with classpath.\n        * java/util/HashMap.java (hash): Use if statement instead of ternary,\n        for clarity.\n\tResolves PR libgcj/1758.\n\tResolves PR java/1684.\n\nFrom-SVN: r39657", "tree": {"sha": "058bbfd9bedd55a01efac0191014b8d48e5086bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/058bbfd9bedd55a01efac0191014b8d48e5086bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a142a996267f9c8adf239a565725174265c67749", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a142a996267f9c8adf239a565725174265c67749", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a142a996267f9c8adf239a565725174265c67749", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a142a996267f9c8adf239a565725174265c67749/comments", "author": null, "committer": null, "parents": [{"sha": "cbc59f0118e787e09ebded7c595bc577b35a6791", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbc59f0118e787e09ebded7c595bc577b35a6791", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbc59f0118e787e09ebded7c595bc577b35a6791"}], "stats": {"total": 1805, "additions": 1781, "deletions": 24}, "files": [{"sha": "6e8a5a4063f45d45fd9a7a40d7633d8a713f3dd3", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a142a996267f9c8adf239a565725174265c67749/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a142a996267f9c8adf239a565725174265c67749/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a142a996267f9c8adf239a565725174265c67749", "patch": "@@ -1,3 +1,15 @@\n+2001-02-14  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* java/util/TreeMap.java: New file.\n+\t* java/util/TreeSet.java: New file.\n+\t* Makefile.am: Add TreeMap and TreeSet. Enable WeakHashMap.\n+\t* Makefile.in: Rebuilt.\n+\t* java/util/HashSet.java (clone): Use constructor instead of calling\n+\tclone on itself.\n+\t* java/util/SortedSet.java: Sync with classpath.\n+\t* java/util/HashMap.java (hash): Use if statement instead of ternary,\n+\tfor clarity.\n+\n 2001-02-13  Tom Tromey  <tromey@redhat.com>\n \n \t* java/io/PipedReader.java (ready): Throw IOException if pipe"}, {"sha": "73d3b3a4464b32c3542c92208e8e4e7b7fb5abdb", "filename": "libjava/Makefile.am", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a142a996267f9c8adf239a565725174265c67749/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a142a996267f9c8adf239a565725174265c67749/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=a142a996267f9c8adf239a565725174265c67749", "patch": "@@ -980,9 +980,11 @@ java/util/StringTokenizer.java \\\n java/util/TimeZone.java\t\\\n java/util/Timer.java \\\n java/util/TimerTask.java \\\n+java/util/TreeMap.java \\\n+java/util/TreeSet.java \\\n java/util/TooManyListenersException.java \\\n-java/util/Vector.java\n-#java/util/WeakHashMap.java \\\n+java/util/Vector.java \\\n+java/util/WeakHashMap.java\n \n \n ## List of all .java files to be compiled.  Please keep this list"}, {"sha": "be75b67c9d921154d10098bd16d3601cf7848e6e", "filename": "libjava/Makefile.in", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a142a996267f9c8adf239a565725174265c67749/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a142a996267f9c8adf239a565725174265c67749/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=a142a996267f9c8adf239a565725174265c67749", "patch": "@@ -724,10 +724,12 @@ java/util/StringTokenizer.java \\\n java/util/TimeZone.java\t\\\n java/util/Timer.java \\\n java/util/TimerTask.java \\\n+java/util/TreeMap.java \\\n+java/util/TreeSet.java \\\n java/util/TooManyListenersException.java \\\n-java/util/Vector.java\n+java/util/Vector.java \\\n+java/util/WeakHashMap.java\n \n-#java/util/WeakHashMap.java \\\n \n ordinary_java_source_files = $(core_java_source_files) \\\n gnu/gcj/RawData.java \\\n@@ -1702,10 +1704,11 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/SortedSet.P .deps/java/util/Stack.P \\\n .deps/java/util/StringTokenizer.P .deps/java/util/TimeZone.P \\\n .deps/java/util/Timer.P .deps/java/util/TimerTask.P \\\n-.deps/java/util/TooManyListenersException.P .deps/java/util/Vector.P \\\n-.deps/java/util/jar/Attributes.P .deps/java/util/jar/JarEntry.P \\\n-.deps/java/util/jar/JarException.P .deps/java/util/jar/JarFile.P \\\n-.deps/java/util/jar/JarInputStream.P \\\n+.deps/java/util/TooManyListenersException.P .deps/java/util/TreeMap.P \\\n+.deps/java/util/TreeSet.P .deps/java/util/Vector.P \\\n+.deps/java/util/WeakHashMap.P .deps/java/util/jar/Attributes.P \\\n+.deps/java/util/jar/JarEntry.P .deps/java/util/jar/JarException.P \\\n+.deps/java/util/jar/JarFile.P .deps/java/util/jar/JarInputStream.P \\\n .deps/java/util/jar/JarOutputStream.P .deps/java/util/jar/Manifest.P \\\n .deps/java/util/natGregorianCalendar.P .deps/java/util/zip/Adler32.P \\\n .deps/java/util/zip/CRC32.P .deps/java/util/zip/CheckedInputStream.P \\"}, {"sha": "6304333295ec57fdebfd465069c95fc5c9b7bacf", "filename": "libjava/java/util/HashMap.java", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a142a996267f9c8adf239a565725174265c67749/libjava%2Fjava%2Futil%2FHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a142a996267f9c8adf239a565725174265c67749/libjava%2Fjava%2Futil%2FHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashMap.java?ref=a142a996267f9c8adf239a565725174265c67749", "patch": "@@ -60,8 +60,8 @@\n  * @author         Jon Zeppieri\n  * @author         Jochen Hoenicke\n  * @author\t   Bryce McKinlay\n- * @version        $Revision: 1.3 $\n- * @modified       $Id: HashMap.java,v 1.3 2000/12/17 09:15:51 bryce Exp $\n+ * @version        $Revision: 1.4 $\n+ * @modified       $Id: HashMap.java,v 1.4 2000/12/21 02:00:15 bryce Exp $\n  */\n public class HashMap extends AbstractMap\n   implements Map, Cloneable, Serializable\n@@ -500,7 +500,10 @@ public boolean remove(Object o)\n   /** Return an index in the buckets array for `key' based on its hashCode() */\n   private int hash(Object key)\n   {\n-    return (key == null ? 0 : Math.abs(key.hashCode() % buckets.length));\n+    if (key == null)\n+      return 0;\n+    else\n+      return Math.abs(key.hashCode() % buckets.length);\n   }\n \n   /** Return an Entry who's key and value equal the supplied Map.Entry. \n@@ -611,15 +614,13 @@ private void readObject(ObjectInputStream s)\n   }\n \n   /**\n-   * a class which implements the Iterator interface and is used for\n-   * iterating over HashMaps;\n-   * this implementation is parameterized to give a sequential view of\n-   * keys, values, or entries; it also allows the removal of elements, \n-   * as per the Javasoft spec.\n+   * Iterate over HashMap's entries.\n+   * This implementation is parameterized to give a sequential view of\n+   * keys, values, or entries.\n    *\n    * @author       Jon Zeppieri\n-   * @version      $Revision: 1.3 $\n-   * @modified     $Id: HashMap.java,v 1.3 2000/12/17 09:15:51 bryce Exp $\n+   * @version      $Revision: 1.4 $\n+   * @modified     $Id: HashMap.java,v 1.4 2000/12/21 02:00:15 bryce Exp $\n    */\n   class HashIterator implements Iterator\n   {"}, {"sha": "1d1f106637e7370036594d2bf98469f01bcd9381", "filename": "libjava/java/util/HashSet.java", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a142a996267f9c8adf239a565725174265c67749/libjava%2Fjava%2Futil%2FHashSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a142a996267f9c8adf239a565725174265c67749/libjava%2Fjava%2Futil%2FHashSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashSet.java?ref=a142a996267f9c8adf239a565725174265c67749", "patch": "@@ -45,8 +45,8 @@\n  * HashSet is a part of the JDK1.2 Collections API.\n  *\n  * @author      Jon Zeppieri\n- * @version     $Revision: 1.5 $\n- * @modified    $Id: HashSet.java,v 1.5 2000/10/26 10:19:00 bryce Exp $\n+ * @version     $Revision: 1.1 $\n+ * @modified    $Id: HashSet.java,v 1.1 2000/12/11 03:47:47 bryce Exp $\n  */\n public class HashSet extends AbstractSet\n   implements Set, Cloneable, Serializable\n@@ -128,10 +128,9 @@ public void clear()\n    */\n   public Object clone()\n   {\n-    HashSet copy = null;\n+    HashSet copy = new HashSet();\n     try\n       {\n-\tcopy = (HashSet) super.clone();\n \tcopy.map = (HashMap) map.clone();\n       }\n     catch (CloneNotSupportedException ex)"}, {"sha": "f72dd66ef97b3cee910208c63793755696a40990", "filename": "libjava/java/util/SortedSet.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a142a996267f9c8adf239a565725174265c67749/libjava%2Fjava%2Futil%2FSortedSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a142a996267f9c8adf239a565725174265c67749/libjava%2Fjava%2Futil%2FSortedSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FSortedSet.java?ref=a142a996267f9c8adf239a565725174265c67749", "patch": "@@ -8,7 +8,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -31,7 +31,8 @@\n \n package java.util;\n \n-public interface SortedSet extends Set {\n+public interface SortedSet extends Set\n+{\n   Comparator comparator();\n   Object first();\n   SortedSet headSet(Object toElement);"}, {"sha": "ce111053299e06cc2814be4c9497edbbf38f7bbf", "filename": "libjava/java/util/TreeMap.java", "status": "added", "additions": 1450, "deletions": 0, "changes": 1450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a142a996267f9c8adf239a565725174265c67749/libjava%2Fjava%2Futil%2FTreeMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a142a996267f9c8adf239a565725174265c67749/libjava%2Fjava%2Futil%2FTreeMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTreeMap.java?ref=a142a996267f9c8adf239a565725174265c67749", "patch": "@@ -0,0 +1,1450 @@\n+/* TreeMap.java -- a class providing a basic Red-Black Tree data structure,\n+   mapping Object --> Object\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.util;\n+\n+import java.io.Serializable;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+/**\n+ * This class provides a red-black tree implementation of the SortedMap\n+ * interface.  Elements in the Map will be sorted by either a user-provided\n+ * Comparator object, or by the natural ordering of the keys.\n+ *\n+ * The algorithms are adopted from Corman, Leiserson,\n+ * and Rivest's <i>Introduction to Algorithms.<i>  In other words,\n+ * I cribbed from the same pseudocode as Sun.  <em>Any similarity\n+ * between my code and Sun's (if there is any -- I have never looked\n+ * at Sun's) is a result of this fact.</em>\n+ *\n+ * TreeMap guarantees O(log n) insertion and deletion of elements.  That \n+ * being said, there is a large enough constant coefficient in front of \n+ * that \"log n\" (overhead involved in keeping the tree \n+ * balanced), that TreeMap may not be the best choice for small\n+ * collections.\n+ *\n+ * TreeMap is a part of the JDK1.2 Collections API.  Null keys are allowed\n+ * only if a Comparator is used which can deal with them.  Null values are \n+ * always allowed.\n+ *\n+ * @author           Jon Zeppieri\n+ * @author\t     Bryce McKinlay\n+ * @modified         $Id: TreeMap.java,v 1.8 2000/10/26 10:19:01 bryce Exp $\n+ */\n+public class TreeMap extends AbstractMap\n+  implements SortedMap, Cloneable, Serializable\n+{\n+  private static final int RED = -1,\n+                           BLACK = 1;\n+\n+  /** Sentinal node, used to avoid null checks for corner cases and make the\n+      delete rebalance code simpler. Note that this must not be static, due \n+      to thread-safety concerns. */\n+  transient final Node nil = new Node(null, null);\n+\n+  /** The root node of this TreeMap */\n+  transient Node root = nil;\n+\n+  /** The size of this TreeMap */\n+  transient int size = 0;\n+\n+  /** Number of modifications */\n+  transient int modCount = 0;\n+\n+  /** This TreeMap's comparator, if any. */\n+  Comparator comparator = null;\n+\n+  static final long serialVersionUID = 919286545866124006L;\n+\n+  private static class Node extends BasicMapEntry implements Map.Entry\n+  {\n+    int color;\n+    Node left;\n+    Node right;\n+    Node parent;\n+\n+    Node(Object key, Object value)\n+    {\n+      super(key, value);\n+      this.color = BLACK;\n+    }\n+  }\n+\n+  /**\n+   * Instantiate a new TreeMap with no elements, using the keys'\n+   * natural ordering to sort.\n+   *\n+   * @see java.lang.Comparable\n+   */\n+  public TreeMap()\n+  {\n+  }\n+\n+  /**\n+   * Instantiate a new TreeMap with no elements, using the provided\n+   * comparator to sort.\n+   *\n+   * @param        oComparator        a Comparator object, used to sort \n+   *                                  the keys of this SortedMap\n+   */\n+  public TreeMap(Comparator c)\n+  {\n+    comparator = c;\n+  }\n+\n+  /**\n+   * Instantiate a new TreeMap, initializing it with all of the\n+   * elements in the provided Map.  The elements will be sorted \n+   * using the natural ordering of the keys.\n+   *\n+   * @param              map         a Map, whose keys will be put into\n+   *                                  this TreeMap\n+   *\n+   * @throws             ClassCastException     if the keys in the provided\n+   *                                            Map do not implement \n+   *                                            Comparable\n+   *\n+   * @see                java.lang.Comparable\n+   */\n+  public TreeMap(Map map)\n+  {\n+    putAll(map);\n+  }\n+\n+  /** \n+   * Instantiate a new TreeMap, initializing it with all of the\n+   * elements in the provided SortedMap.  The elements will be sorted \n+   * using the same method as in the provided SortedMap.\n+   */\n+  public TreeMap(SortedMap sm)\n+  {\n+    this(sm.comparator());\n+\n+    int sm_size = sm.size();\n+    Iterator itr = sm.entrySet().iterator();\n+\n+    fabricateTree(sm_size);\n+    Node node = firstNode();\n+    \n+    for (int i = 0; i < sm_size; i++)\n+      {\n+\tMap.Entry me = (Map.Entry) itr.next();\n+\tnode.key = me.getKey();\n+\tnode.value = me.getValue();\t\n+\tnode = successor(node);\n+      }\n+  }\n+\n+  public int size()\n+  {\n+    return size;\n+  }\n+\n+  public void clear()\n+  {\n+    modCount++;\n+    root = nil;\n+    // nil node could have a residual parent reference, clear it for GC.\n+    nil.parent = null;\n+    size = 0;\n+  }\n+\n+  public Object clone()\n+  {\n+    TreeMap copy = new TreeMap();\n+    copy.comparator = comparator;\n+    copy.fabricateTree(size);\n+\n+    Node node = firstNode();\n+    Node cnode = copy.firstNode();\n+    \n+    while (node != nil)\n+      {\n+        cnode.key = node.key;\n+\tcnode.value = node.value;\n+\tnode = successor(node);\n+\tcnode = copy.successor(cnode);\n+      }\n+    return copy;\n+  }\n+  \n+  public Comparator comparator()\n+  {\n+    return comparator;\n+  }\n+\n+  public boolean containsKey(Object key)\n+  {\n+    return getNode(key) != nil;\n+  }\n+\n+  public boolean containsValue(Object value)\n+  {\n+    Node node = firstNode();\n+    Object currentVal;\n+\n+    while (node != nil)\n+      {\n+\tcurrentVal = node.getValue();\n+\n+        if (value == null ? currentVal == null : value.equals (currentVal))\n+\t  return true;\n+\n+\tnode = successor(node);\n+      }\n+    return false;\n+  }\n+\n+  public Set entrySet()\n+  {\n+    // Create an AbstractSet with custom implementations of those methods that \n+    // can be overriden easily and efficiently.\n+    return new AbstractSet()\n+    {\n+      public int size()\n+      {\n+        return size;\n+      }\n+      \n+      public Iterator iterator()\n+      {\n+        return new TreeIterator(TreeIterator.ENTRIES);\n+      }\n+            \n+      public void clear()\n+      {\n+        TreeMap.this.clear();\n+      }\n+\n+      public boolean contains(Object o)\n+      {\n+        if (!(o instanceof Map.Entry))\n+\t  return false;\n+\tMap.Entry me = (Map.Entry) o;\n+\tNode n = getNode(me.getKey());\n+\treturn (n != nil && me.getValue().equals(n.value));\n+      }\n+      \n+      public boolean remove(Object o)\n+      {\n+        if (!(o instanceof Map.Entry))\n+\t  return false;\n+\tMap.Entry me = (Map.Entry) o;\n+\tNode n = getNode(me.getKey());\n+\tif (n != nil && me.getValue().equals(n.value))\n+\t  {\n+\t    removeNode(n);\n+\t    return true;\n+\t  }\n+\treturn false;\n+      }\n+    };\n+  }\n+\n+  public Object firstKey()\n+  {\n+    if (root == nil)\n+      throw new NoSuchElementException(\"empty\");\n+    return firstNode().getKey();\n+  }\n+  \n+  private Node firstNode()\n+  {\n+    if (root == nil)\n+      return nil;\n+    Node node = root;\n+    while (node.left != nil)\n+      node = node.left;\n+    return node;\n+  }\n+\n+  public Object lastKey()\n+  {\n+    if (root == nil)\n+      throw new NoSuchElementException(\"empty\");\n+    return lastNode().getKey();\n+  }\n+  \n+  private Node lastNode()\n+  {\n+    if (root == nil)\n+      return nil;\n+    Node node = root;\n+    while (node.right != nil)\n+      node = node.right;\n+    return node;  \n+  }\n+  \n+  public Object get(Object key)\n+  {\n+    return getNode(key).value;\n+  }\n+  \n+  /** Return the TreeMap.Node associated with KEY, or the nil node if no such\n+      node exists in the tree. */\n+  private Node getNode(Object key)\n+  {\n+    int comparison;\n+    Node current = root;\n+\n+    while (current != nil)\n+      {\n+        comparison = compare(key, current.key);\n+\tif (comparison > 0)\n+\t  current = current.right;\n+\telse if (comparison < 0)\n+\t  current = current.left;\n+\telse\n+\t  return current;\n+      }\n+    return current; \n+  }\n+\n+  public Set keySet()\n+  {\n+    // Create an AbstractSet with custom implementations of those methods that \n+    // can be overriden easily and efficiently.\n+    return new AbstractSet()\n+    {\n+      public int size()\n+      {\n+        return size;\n+      }\n+      \n+      public Iterator iterator()\n+      {\n+        return new TreeIterator(TreeIterator.KEYS);\n+      }\n+\n+      public void clear()\n+      {\n+        TreeMap.this.clear();\n+      }\n+\n+      public boolean contains(Object o)\n+      {\n+        return TreeMap.this.containsKey(o);\n+      }\n+      \n+      public boolean remove(Object key)\n+      {\n+        Node n = getNode(key);\n+\tif (n == nil)\n+\t  return false;\n+        TreeMap.this.removeNode(n);\n+\treturn true;\n+      }\n+    };\n+  }\n+\n+  public Object put(Object key, Object value)\n+  {\n+    modCount++;\n+    Node current = root;\n+    Node parent = nil;\n+    int comparison = 0;\n+    \n+    // Find new node's parent.\n+    while (current != nil)\n+      {\n+\tparent = current;\n+\tcomparison = compare(key, current.key);\n+\tif (comparison > 0)\n+\t  current = current.right;\n+\telse if (comparison < 0)\n+\t  current = current.left;\n+\telse\n+\t  {\n+\t    // Key already in tree.\n+\t    Object r = current.value;\n+\t    current.value = value;\n+\t    return r;\n+\t  }\n+      }\n+    \n+    // Set up new node.\n+    Node n = new Node(key, value);\n+    n.color = RED;\n+    n.parent = parent;\n+    n.left = nil;\n+    n.right = nil;\n+    \n+    // Insert node in tree.\n+    size++;\n+    if (parent == nil)\n+      {\n+        // Special case: inserting into an empty tree.\n+\troot = n;\n+\tn.color = BLACK;\n+\treturn null;\n+      }\n+    else if (comparison > 0)\n+      parent.right = n;\n+    else\n+      parent.left = n;   \n+    \n+    // Rebalance after insert.\n+    insertFixup(n);\n+    //verifyTree();\n+    return null;\n+  }\n+\n+  /** Maintain red-black balance after inserting a new node. */\n+  private void insertFixup(Node n)\n+  {\n+    // Only need to rebalance when parent is a RED node, and while at least\n+    // 2 levels deep into the tree (ie: node has a grandparent).\n+    while (n != root && n.parent.parent != nil && n.parent.color == RED)\n+      {\n+\tif (n.parent == n.parent.parent.left)\n+\t  {\n+            Node uncle = n.parent.parent.right;\n+            if (uncle != nil && uncle.color == RED) \n+\t      {\n+        \tn.parent.color = BLACK;\n+        \tuncle.color = BLACK;\n+        \tn.parent.parent.color = RED;\n+        \tn = n.parent.parent;\n+              }\n+\t    else // Uncle is BLACK.\n+\t      {                \n+                if (n == n.parent.right)\n+\t\t  {\n+                    // Make n a left child.\n+                    n = n.parent;\n+                    rotateLeft(n);\n+                  }\n+\n+                // Recolor and rotate.\n+                n.parent.color = BLACK;\n+                n.parent.parent.color = RED;\n+                rotateRight(n.parent.parent);\n+              }\n+\t  }\n+\telse\n+\t  {\n+\t    // Mirror image of above code.\n+\t    Node uncle = n.parent.parent.left;\n+            if (uncle != nil && uncle.color == RED)\n+\t      {\n+                n.parent.color = BLACK;\n+                uncle.color = BLACK;\n+                n.parent.parent.color = RED;\n+                n = n.parent.parent;\n+              }\n+\t    else\n+\t      {\n+                if (n == n.parent.left)\n+\t\t  {\n+                    n = n.parent;\n+                    rotateRight(n);\n+                  }\n+                n.parent.color = BLACK;\n+                n.parent.parent.color = RED;\n+                rotateLeft(n.parent.parent);\n+\t      }\n+\t  }\n+      }\n+    root.color = BLACK;\n+  }\n+\n+  public void putAll(Map m)\n+  {\n+    Iterator itr = m.entrySet().iterator();\n+    int msize = m.size();\n+    Map.Entry e;\n+\n+    for (int i = 0; i < msize; i++)\n+      {\n+\te = (Map.Entry) itr.next();\n+\tput(e.getKey(), e.getValue());\n+      }\n+  }\n+\n+  public Object remove(Object key)\n+  {\n+    Node n = getNode(key);\n+    if (n != nil)\n+      {\n+        removeNode(n);\n+\treturn n.value;\n+      }\n+    return null;\n+  }\n+  \n+  // Remove node from tree. This will increment modCount and decrement size. \n+  // Node must exist in the tree.\n+  private void removeNode(Node node) // z\n+  {\n+    Node splice; // y\n+    Node child;  // x\n+    \n+    modCount++;\n+    size--;\n+\n+    // Find splice, the node at the position to actually remove from the tree. \n+    if (node.left == nil || node.right == nil)\n+      {\n+\t// Node to be deleted has 0 or 1 children.\n+        splice = node;\n+\tif (node.left == nil)\n+\t  child = node.right;\n+\telse\n+\t  child = node.left;\n+      }\n+    else\n+      {\n+\t// Node has 2 children. Splice is node's successor, and will be \n+\t// swapped with node since we can't remove node directly.\n+        splice = node.right;\n+        while (splice.left != nil)\n+\t  splice = splice.left;\n+\tchild = splice.right;\n+      }\n+\n+    // Unlink splice from the tree.\n+    Node parent = splice.parent;\n+    child.parent = parent;\n+    if (parent != nil)\n+      {\n+\tif (splice == parent.left)\n+          parent.left = child;\n+\telse\n+          parent.right = child;\n+      }\n+    else\n+      root = child;\n+\n+    // Keep track of splice's color in case it gets changed in the swap.\n+    int spliceColor = splice.color;\n+\n+/*\n+    if (splice != node)\n+      {\n+        node.key = splice.key;\n+\tnode.value = splice.value;\n+      }\n+*/\n+    if (splice != node)\n+      {\n+        // Swap SPLICE for NODE. Some implementations optimize here by simply\n+\t// swapping the values, but we can't do that: if an iterator was\n+\t// referencing a node in its \"next\" field, and that node got swapped, \n+\t// things would get confused.\n+\tif (node == root)\n+\t  {\n+\t    root = splice;\n+\t  }\n+\telse\n+\t  {\n+\t    if (node.parent.left == node)\n+\t      node.parent.left = splice;\n+\t    else\n+\t      node.parent.right = splice;\n+          }\n+\tsplice.parent = node.parent;\n+\tsplice.left = node.left;\n+\tsplice.right = node.right;\n+\tsplice.left.parent = splice;\n+\tsplice.right.parent = splice;\n+\tsplice.color = node.color;\n+      }\n+\n+    if (spliceColor == BLACK)\n+      deleteFixup (child);\n+    \n+    //verifyTree();      \n+  }\n+\n+  /** Maintain red-black balance after deleting a node. */\n+  private void deleteFixup (Node node)\n+  {\n+    // A black node has been removed, so we need to rebalance to avoid \n+    // violating the \"same number of black nodes on any path\" rule. If\n+    // node is red, we can simply recolor it black and all is well. \n+    while (node != root && node.color == BLACK)\n+      {\n+        if (node == node.parent.left)\n+\t  {\n+\t    // Rebalance left side.\n+\t    Node sibling = node.parent.right;\n+\t    if (sibling.color == RED)\n+\t      {\n+                sibling.color = BLACK;\n+                node.parent.color = RED;\n+                rotateLeft(node.parent);\n+                sibling = node.parent.right;\n+\t      }\n+\n+\t    if (sibling.left.color == BLACK && sibling.right.color == BLACK)\n+              {\n+\t        // Case 2: Sibling has no red children.\n+\t\tsibling.color = RED;\n+\t\t// Black height has been decreased, so move up the tree and \n+\t\t// repeat.\n+\t\tnode = node.parent;\n+              }\n+\t    else\n+\t      {\t      \n+\t        if (sibling.right.color == BLACK)\n+\t\t  {\n+\t\t    // Case 3: Sibling has red left child.\n+\t\t    sibling.left.color = BLACK;\n+\t\t    sibling.color = RED;\n+                    rotateRight(sibling);\n+                    sibling = node.parent.right;\n+\t\t  }\t\t  \n+\t\t\n+\t\t// Case 4: Sibling has red right child.\n+\t\tsibling.color = sibling.parent.color;\n+\t\tsibling.parent.color = BLACK;\n+\t\tsibling.right.color = BLACK;\n+                rotateLeft(node.parent);\n+                node = root; // Finished.\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    // Symmetric \"mirror\" of left-side case.\n+\t    Node sibling = node.parent.left;\n+\t    if (sibling.color == RED)\n+\t      {\n+                sibling.color = BLACK;\n+                node.parent.color = RED;\n+                rotateRight(node.parent);\n+                sibling = node.parent.left;\n+\t      }\n+\n+\t    if (sibling.left.color == BLACK && sibling.right.color == BLACK)\n+              {\n+\t\tsibling.color = RED;\n+\t\tnode = node.parent;\n+              }\n+\t    else\n+\t      {\t      \n+\t        if (sibling.left.color == BLACK)\n+\t\t  {\n+\t\t    sibling.right.color = BLACK;\n+\t\t    sibling.color = RED;\n+                    rotateLeft(sibling);\n+                    sibling = node.parent.left;\n+\t\t  }\t\t  \n+\t\t\n+\t\tsibling.color = sibling.parent.color;\n+\t\tsibling.parent.color = BLACK;\n+\t\tsibling.left.color = BLACK;\n+                rotateRight(node.parent);\n+                node = root;\n+\t      }\n+\t  }\n+      }\n+    node.color = BLACK;\n+  }\n+\n+  public SortedMap subMap(Object fromKey, Object toKey)\n+  {\n+    if (compare(fromKey, toKey) <= 0)\n+      return new SubMap(fromKey, toKey);\n+    else\n+      throw new IllegalArgumentException(\"fromKey > toKey\");\n+  }\n+\n+  public SortedMap headMap(Object toKey)\n+  {\n+    return new SubMap(nil, toKey);\n+  }\n+\n+  public SortedMap tailMap(Object fromKey)\n+  {\n+    return new SubMap(fromKey, nil);\n+  }\n+\n+  /** Returns a \"collection view\" (or \"bag view\") of this TreeMap's values. */\n+  public Collection values()\n+  {\n+    // We don't bother overriding many of the optional methods, as doing so\n+    // wouldn't provide any significant performance advantage.\n+    return new AbstractCollection()\n+    {\n+      public int size()\n+      {\n+        return size;\n+      }\n+      \n+      public Iterator iterator()\n+      {\n+        return new TreeIterator(TreeIterator.VALUES);\n+      }\n+      \n+      public void clear()\n+      {\n+        TreeMap.this.clear();\n+      }\n+    };\n+  }\n+\n+  // Find the \"highest\" node which is < key. If key is nil, return last node.\n+  // Note that highestLessThan is exclusive (it won't return a key which is\n+  // equal to \"key\"), while lowestGreaterThan is inclusive, in order to be \n+  // consistent with the semantics of subMap().\n+  private Node highestLessThan(Object key)\n+  {\n+    if (key == nil)\n+      return lastNode();\n+  \n+    Node last = nil;\n+    Node current = root;\n+    int comparison = 0;\n+\n+    while (current != nil)\n+      {\n+        last = current;\n+        comparison = compare(key, current.key);\n+\tif (comparison > 0)\n+\t  current = current.right;\n+\telse if (comparison < 0)\n+\t  current = current.left;\n+\telse /* Exact match. */\n+\t  return predecessor(last);\n+      }\n+    if (comparison <= 0)\n+      return predecessor(last);\n+    else\n+      return last;\n+  }\n+\n+  // Find the \"lowest\" node which is >= key. If key is nil, return first node.\n+  private Node lowestGreaterThan(Object key)\n+  {\n+    if (key == nil)\n+      return firstNode();\n+\n+    Node last = nil;\n+    Node current = root;\n+    int comparison = 0;\n+\n+    while (current != nil)\n+      {\n+        last = current;\n+        comparison = compare(key, current.key);\n+\tif (comparison > 0)\n+\t  current = current.right;\n+\telse if (comparison < 0)\n+\t  current = current.left;\n+\telse\n+\t  return current;\n+      }\n+    if (comparison > 0)\n+      return successor(last);\n+    else\n+      return last;\n+  }  \n+\n+  private void writeObject(ObjectOutputStream out) throws IOException\n+  {\n+    ObjectOutputStream.PutField fields = out.putFields();\n+    fields.put(\"comparator\", comparator);\n+    out.writeFields();\n+\n+    Node node = firstNode();\n+    out.writeInt(size);\n+    \n+    while (node != nil)\n+      {\n+        out.writeObject(node.key);\n+\tout.writeObject(node.value);\n+\tnode = successor(node);\n+      }\n+  }\n+\n+  private void readObject(ObjectInputStream in)\n+    throws IOException, ClassNotFoundException\n+  {\n+    ObjectInputStream.GetField fields = in.readFields();\n+    comparator = (Comparator) fields.get(\"comparator\", null);\n+    int size = in.readInt();\n+    putFromObjStream(in, size, true);\n+  }\n+\n+  private int compare(Object o1, Object o2)\n+  {\n+    if (comparator == null)\n+      return ((Comparable) o1).compareTo(o2);\n+    else\n+      return comparator.compare(o1, o2);\n+  }\n+\n+  /* Return the node following Node, or nil if there isn't one. */\n+  private Node successor(Node node)\n+  {\n+    if (node.right != nil)\n+      {\n+        node = node.right;\n+\twhile (node.left != nil)\n+\t  node = node.left;\n+\treturn node;\n+      }\n+\n+    Node parent = node.parent;\n+    while (parent != nil && node == parent.right)\n+      {\n+\tnode = parent;\n+\tparent = parent.parent;\n+      }\n+    return parent;\n+  }\n+\n+  /* Return the node preceeding Node, or nil if there isn't one. */\n+  private Node predecessor(Node node)\n+  {\n+    if (node.left != nil)\n+      {\n+        node = node.left;\n+\twhile (node.right != nil)\n+\t  node = node.right;\n+\treturn node;\n+      }\n+      \n+    Node parent = node.parent;\n+    while (parent != nil && node == parent.left)\n+      {\n+\tnode = parent;\n+\tparent = parent.parent;\n+      }\n+    return parent;\n+  }\n+\n+  /** Rotate node n to the left. */\n+  private void rotateLeft(Node node)\n+  {\n+    Node child = node.right;\n+    \n+    // Establish node.right link.\n+    node.right = child.left;\n+    if (child.left != nil)\n+      child.left.parent = node;\n+\n+    // Establish child->parent link.\n+    child.parent = node.parent;\n+    if (node.parent != nil)\n+      {\n+        if (node == node.parent.left)\n+\t  node.parent.left = child;\n+\telse\n+\t  node.parent.right = child;\n+      }\n+    else\n+      root = child;\n+\n+    // Link n and child.\n+    child.left = node;\n+    if (node != nil)\n+      node.parent = child;\n+  }\n+\n+  /** Rotate node n to the right. */\n+  private void rotateRight(Node node)\n+  {\n+    Node child = node.left;\n+    \n+    // Establish node.left link.\n+    node.left = child.right;\n+    if (child.right != nil)\n+      child.right.parent = node;\n+      \n+    // Establish child->parent link.\n+    child.parent = node.parent;\n+    if (node.parent != nil)\n+      {\n+        if (node == node.parent.right)\n+\t  node.parent.right = child;\n+\telse\n+\t  node.parent.left = child;\n+      }\n+    else\n+      root = child;\n+    \n+    // Link n and child.\n+    child.right = node;\n+    if (node != nil)\n+      node.parent = child;\n+  }\n+  \n+  /* Construct a tree from sorted keys in linear time. This is used to\n+     implement TreeSet's SortedSet constructor. */\n+  void putKeysLinear(Iterator keys, int count)\n+  {\n+    fabricateTree(count);    \n+    Node node = firstNode();\n+    \n+    for (int i = 0; i < count; i++)\n+      {\n+\tnode.key = keys.next();\n+\tnode.value = Boolean.TRUE;\n+\tnode = successor(node);\n+      }\n+  }\n+  \n+  /* As above, but load keys from an ObjectInputStream. Used by readObject()\n+     methods. If \"readValues\" is set, entry values will also be read from the \n+     stream. If not, only keys will be read. */\n+  void putFromObjStream(ObjectInputStream in, int count, boolean readValues) \n+    throws IOException, ClassNotFoundException\n+  {\n+    fabricateTree(count);    \n+    Node node = firstNode();\n+    \n+    for (int i = 0; i < count; i++)\n+      {\n+\tnode.key = in.readObject();\n+\tif (readValues)\n+\t  node.value = in.readObject();\n+\telse\n+\t  node.value = Boolean.TRUE;\t  \n+\tnode = successor(node);\n+      }\n+  }\n+     \n+  /* Construct a perfectly balanced tree consisting of n \"blank\" nodes. \n+     This permits a tree to be generated from pre-sorted input in linear \n+     time. */\n+  private void fabricateTree(int count)\n+  {\n+    if (count == 0)\n+      return;\n+    // Calculate the (maximum) depth of the perfectly balanced tree.\n+    double ddepth = (Math.log (count + 1) / Math.log (2));\n+    int maxdepth = (int) Math.ceil (ddepth);\n+    \n+    // The number of nodes which can fit in a perfectly-balanced tree of \n+    // height \"depth - 1\".\n+    int max = (int) Math.pow (2, maxdepth - 1) - 1;\n+    \n+    // Number of nodes which spill over into the deepest row of the tree.\n+    int overflow = (int) count - max;\n+    \n+    size = count;\n+    // Make the root node.\n+    root = new Node(null, null);\n+    root.parent = nil;\n+    root.left = nil;\n+    root.right = nil;\n+    \n+    Node row = root;\n+    for (int depth = 2; depth <= maxdepth; depth++)  // each row\n+      {\t\n+\t// Number of nodes at this depth\n+\tint rowcap = (int) Math.pow (2, depth - 1);\n+\tNode parent = row;\n+\tNode last = null;\n+\t\n+\t// Actual number of nodes to create in this row\n+\tint rowsize;\n+\tif (depth == maxdepth)\n+\t  rowsize = overflow;\n+\telse\n+\t  rowsize = rowcap;\n+\t\n+\t// The bottom most row of nodes is coloured red, as is every second row \n+\t// going up, except the root node (row 1). I'm not sure if this is the \n+\t// optimal configuration for the tree, but it seems logical enough.\n+\t// We just need to honour the black-height and red-parent rules here.\n+\tboolean colorRowRed = (depth % 2 == maxdepth % 2);\n+\t\n+\tint i;\n+\tfor (i = 1; i <= rowsize; i++)  // each node in row\n+\t  {\n+\t    Node node = new Node(null, null);\n+\t    node.parent = parent;\n+\t    if (i % 2 == 1)\n+\t      parent.left = node;\n+\t    else\n+\t      {\n+\t\tNode nextparent = parent.right;\n+\t\tparent.right = node;\n+\t\tparent = nextparent;\n+\t      }\n+\t    if (last != null)\n+\t      last.right = node;\n+\t    last = node;\n+\t    \n+\t    if (colorRowRed)\n+\t      node.color = RED;\n+\t    \n+\t    if (i == 1)\n+\t      row = node;\n+\t  }\n+\n+        // Set nil child pointers on leaf nodes.\n+\tif (depth == maxdepth)\n+\t  {\n+\t    // leaf nodes at maxdepth-1.\n+\t    if (parent != null)\n+\t      {\n+\t\tif (i % 2 == 0)\n+\t\t  {\n+\t            // Current \"parent\" has \"left\" set already.\n+\t\t    Node next = parent.right;\n+\t\t    parent.right = nil;\n+\t\t    parent = next;\n+\t\t  }\t\t  \t\t  \n+\t\twhile (parent != null)\n+\t\t  {\n+\t\t    parent.left = nil;\n+\t\t    Node next = parent.right;\n+\t\t    parent.right = nil;\n+\t\t    parent = next;\n+\t\t  }\n+\t      }\n+\t    // leaf nodes at maxdepth.\n+\t    Node node = row;\n+\t    Node next;\n+\t    while (node != null)\n+\t      {\n+\t        node.left = nil;\n+\t\tnext = node.right;\n+\t\tnode.right = nil;\n+\t\tnode = next;\n+\t      }\n+\t  }\n+      }\n+  }\n+  \n+  private class VerifyResult\n+  {\n+    int count; // Total number of nodes.\n+    int black; // Black height/depth.\n+    int maxdepth; // Maximum depth of branch.\n+  }\n+\n+  /* Check that red-black properties are consistent for the tree. */\n+  private void verifyTree()\n+  {\n+    if (root == nil)\n+      {\n+        System.err.println (\"Verify: empty tree\");\n+\tif (size != 0)\n+\t  verifyError (this, \"no root node but size=\" + size);\n+\treturn;\n+      }\n+    VerifyResult vr = verifySub (root);\n+    if (vr.count != size)\n+      {\n+\tverifyError (this, \"Tree size not consistent with actual nodes counted. \"\n+                     + \"counted \" + vr.count + \", size=\" + size);\n+        System.exit(1);\n+      }\n+    System.err.println (\"Verify: \" + vr.count + \" nodes, black height=\" + vr.black\n+                        + \", maxdepth=\" + vr.maxdepth);\n+  }\n+  \n+  /* Recursive call to check that rbtree rules hold. Returns total node count\n+     and black height of the given branch. */\n+  private VerifyResult verifySub(Node n)\n+  {\n+    VerifyResult vr1 = null;\n+    VerifyResult vr2 = null;\n+    \n+    if (n.left == nil && n.right == nil)\n+      {\n+        // leaf node\n+\tVerifyResult r = new VerifyResult();\n+\tr.black = (n.color == BLACK ? 1 : 0);\n+\tr.count = 1;\n+\tr.maxdepth = 1;\n+\treturn r;\n+      }\n+    \n+    if (n.left != nil)\n+      {\n+        if (n.left.parent != n)\n+\t  verifyError(n.left, \"Node's parent link does not point to \" + n);\n+\t\n+\tif (n.color == RED && n.left.color == RED)\n+\t  verifyError(n, \"Red node has red left child\");\n+\t\n+\tvr1 = verifySub (n.left);\n+\tif (n.right == nil)\n+\t  {\n+\t    if (n.color == BLACK)\n+\t      vr1.black++;\n+\t    vr1.count++;\n+\t    vr1.maxdepth++;\n+\t    return vr1;\n+\t  }\n+      }\n+\n+    if (n.right != nil)\n+      {\n+        if (n.right.parent != n)\n+\t  verifyError(n.right, \"Node's parent link does not point to \" + n);\n+\n+\tif (n.color == RED && n.right.color == RED)\n+\t  verifyError(n, \"Red node has red right child\");\n+\n+\tvr2 = verifySub (n.right);\n+\tif (n.left == nil)\n+\t  {\n+\t    if (n.color == BLACK)\n+\t      vr2.black++;\n+\t    vr2.count++;\n+\t    vr2.maxdepth++;\n+\t    return vr2;\n+\t  }\n+      }\n+    \n+    if (vr1.black != vr2.black)\n+      verifyError (n, \"Black heights: \" + vr1.black + \",\" + vr2.black + \" don't match.\");\n+    vr1.count += vr2.count + 1;\n+    vr1.maxdepth = Math.max(vr1.maxdepth, vr2.maxdepth) + 1;\n+    if (n.color == BLACK)\n+      vr1.black++;\n+    return vr1;\n+  }\n+  \n+  private void verifyError (Object obj, String msg)\n+  {\n+    System.err.print (\"Verify error: \");\n+    try\n+      {\n+        System.err.print (obj);\n+      }\n+    catch (Exception x)\n+      {\n+        System.err.print (\"(error printing obj): \" + x);\n+      }\n+    System.err.println();\n+    System.err.println (msg);\n+    Thread.dumpStack();\n+    System.exit(1);\n+  }\n+\n+  /**\n+   * Iterate over HashMap's entries.\n+   * This implementation is parameterized to give a sequential view of\n+   * keys, values, or entries.\n+   */   \n+  class TreeIterator implements Iterator\n+  {\n+    static final int ENTRIES = 0,\n+                     KEYS = 1,\n+                     VALUES = 2;  \n+  \n+    // the type of this Iterator: KEYS, VALUES, or ENTRIES.\n+    int type;\n+    // the number of modifications to the backing Map that we know about.\n+    int knownMod = TreeMap.this.modCount;\n+    // The last Entry returned by a next() call.\n+    Node last;\n+    // The next entry that should be returned by next().\n+    Node next;\n+    // The last node visible to this iterator. This is used when iterating\n+    // on a SubMap.\n+    Node max;\n+\n+    /* Create Iterator with the supplied type: KEYS, VALUES, or ENTRIES */\n+    TreeIterator(int type)\n+    {\n+      this.type = type;\n+      this.next = firstNode();\n+    }\n+    \n+    /* Construct an interator for a SubMap. Iteration will begin at node\n+       \"first\", and stop when \"max\" is reached. */    \n+    TreeIterator(int type, Node first, Node max)\n+    {\n+      this.type = type;\n+      this.next = first;\n+      this.max = max;\n+    }\n+\n+    public boolean hasNext()\n+    {\n+      if (knownMod != TreeMap.this.modCount)\n+\tthrow new ConcurrentModificationException();\n+      return (next != nil);\n+    }\n+\n+    public Object next()\n+    {\n+      if (knownMod != TreeMap.this.modCount)\n+\tthrow new ConcurrentModificationException();\n+      if (next == nil)\n+\tthrow new NoSuchElementException();\n+      Node n = next;\n+\n+      // Check limit in case we are iterating through a submap.\n+      if (n != max)\n+\tnext = successor(n);\n+      else\n+        next = nil;\n+      \n+      last = n;\n+      \n+      if (type == VALUES)\n+        return n.value;\n+      else if (type == KEYS)\n+        return n.key;\n+      return n;\n+    }\n+\n+    public void remove()\n+    {\n+      if (knownMod != TreeMap.this.modCount)\n+\tthrow new ConcurrentModificationException();\n+\n+      if (last == null)\n+\tthrow new IllegalStateException();\n+/*\n+      Object key = null;\n+      if (next != nil)\n+        key = next.key;\n+*/\n+      TreeMap.this.removeNode(last);\n+      knownMod++;\n+/*\n+      if (key != null)\n+        next = getNode(key);\n+*/\t\n+      last = null;\n+    }\n+  }\n+\n+  class SubMap extends AbstractMap implements SortedMap\n+  {\n+    Object minKey;\n+    Object maxKey;\n+\n+    /* Create a SubMap representing the elements between minKey and maxKey\n+       (inclusive). If minKey is nil, SubMap has no lower bound (headMap).\n+       If maxKey is nil, the SubMap has no upper bound (tailMap). */\n+    SubMap(Object minKey, Object maxKey)\n+    {\n+      this.minKey = minKey;\n+      this.maxKey = maxKey;\n+    }\n+\n+    public void clear()\n+    {\n+      Node current;\n+      Node next = lowestGreaterThan(minKey);\n+      Node max = highestLessThan(maxKey);\n+      \n+      if (compare(next.key, max.key) > 0)\n+        // Nothing to delete.\n+\treturn;\n+        \n+      do\n+        {\n+\t  current = next;\n+\t  next = successor(current);\n+\t  remove(current);\n+\t}\n+      while (current != max);\n+    }\n+    \n+    /* Check if \"key\" is in within the range bounds for this SubMap. \n+       The lower (\"from\") SubMap range is inclusive, and the upper (to) bound\n+       is exclusive. */\n+    private boolean keyInRange(Object key)\n+    {\n+      return ((minKey == nil || compare(key, minKey) >= 0)\n+\t      && (maxKey == nil || compare(key, maxKey) < 0));\n+    }\n+\n+    public boolean containsKey(Object key)\n+    {\n+      return (keyInRange(key) && TreeMap.this.containsKey(key));\n+    }\n+\n+    public boolean containsValue(Object value)\n+    {\n+      Node node = lowestGreaterThan(minKey);\n+      Node max = highestLessThan(maxKey);\n+      Object currentVal;\n+\n+      if (node == nil || max == nil || compare(node.key, max.key) > 0)\n+        // Nothing to search.\n+\treturn false;\n+\n+      while (true)\n+\t{\n+\t  currentVal = node.getValue();\n+          if (value == null ? currentVal == null : value.equals (currentVal))\n+\t    return true;\n+\t  if (node == max)\n+\t    return false;\n+\t  node = successor(node);\n+\t}\n+    }\n+\n+    public Object get(Object key)\n+    {\n+      if (keyInRange(key))\n+\treturn TreeMap.this.get(key);\n+      return null;\n+    }\n+\n+    public Object put(Object key, Object value)\n+    {\n+      if (keyInRange(key))\n+\treturn TreeMap.this.put(key, value);\n+      else\n+\tthrow new IllegalArgumentException(\"Key outside range\");\n+    }\n+\n+    public Object remove(Object key)\n+    {\n+      if (keyInRange(key))\n+\treturn TreeMap.this.remove(key);\n+      else\n+        return null;\n+    }\n+\n+    public int size()\n+    {\n+      Node node = lowestGreaterThan(minKey);\n+      Node max = highestLessThan(maxKey);\n+\n+      if (node == nil || max == nil || compare(node.key, max.key) > 0)\n+\treturn 0;  // Empty.\n+\n+      int count = 1;\n+      while (node != max)\n+        {\n+\t  count++;\n+\t  node = successor(node);\n+\t}\n+\n+      return count;\n+    }\n+\n+    public Set entrySet()\n+    {\n+      // Create an AbstractSet with custom implementations of those methods that \n+      // can be overriden easily and efficiently.\n+      return new AbstractSet()\n+      {\n+\tpublic int size()\n+\t{\n+          return SubMap.this.size();\n+\t}\n+\n+\tpublic Iterator iterator()\n+\t{\n+\t  Node first = lowestGreaterThan(minKey);\n+\t  Node max = highestLessThan(maxKey);\n+          return new TreeIterator(TreeIterator.ENTRIES, first, max);\n+\t}\n+\n+\tpublic void clear()\n+\t{\n+          this.clear();\n+\t}\n+\n+\tpublic boolean contains(Object o)\n+\t{\n+          if (!(o instanceof Map.Entry))\n+\t    return false;\n+\t  Map.Entry me = (Map.Entry) o;\n+\t  Object key = me.getKey();\n+\t  if (!keyInRange(key))\n+\t    return false;\n+\t  Node n = getNode(key);\n+\t  return (n != nil && me.getValue().equals(n.value));\n+\t}\n+\n+\tpublic boolean remove(Object o)\n+\t{\n+          if (!(o instanceof Map.Entry))\n+\t    return false;\n+\t  Map.Entry me = (Map.Entry) o;\n+\t  Object key = me.getKey();\n+\t  if (!keyInRange(key))\n+\t    return false;\n+\t  Node n = getNode(key);\n+\t  if (n != nil && me.getValue().equals(n.value))\n+\t    {\n+\t      removeNode(n);\n+\t      return true;\n+\t    }\n+\t  return false;\n+\t}\n+      };    \n+    }\n+\n+    public Comparator comparator()\n+    {\n+      return comparator;\n+    }\n+\n+    public Object firstKey()\n+    {\n+      Node node = lowestGreaterThan(minKey);\n+      // Do a range check in case SubMap is empty.\n+      if (keyInRange(node.key))\n+        return node.key;\n+      return null;\n+    }\n+\n+    public Object lastKey()\n+    {\n+      Node node = highestLessThan(maxKey);\n+      // Do a range check in case SubMap is empty.\n+      if (keyInRange(node.key))\n+        return node.key;\n+      return null;\n+    }\n+\n+    public SortedMap subMap(Object fromKey, Object toKey)\n+    {\n+      if (!keyInRange(fromKey) || !keyInRange(toKey))\n+        throw new IllegalArgumentException(\"key outside range\");\n+\n+      return TreeMap.this.subMap(fromKey, toKey);\n+    }\n+\n+    public SortedMap headMap(Object toKey)\n+    {\n+      if (!keyInRange(toKey))\n+        throw new IllegalArgumentException(\"key outside range\");\n+\n+      return TreeMap.this.subMap(minKey, toKey);\n+    }\n+\n+    public SortedMap tailMap(Object fromKey)\n+    {\n+      if (!keyInRange(fromKey))\n+        throw new IllegalArgumentException(\"key outside range\");\n+\n+      return TreeMap.this.subMap(fromKey, maxKey);\n+    }\n+  }\n+}"}, {"sha": "36224aab8522018af53fb361a7d123fb78a59999", "filename": "libjava/java/util/TreeSet.java", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a142a996267f9c8adf239a565725174265c67749/libjava%2Fjava%2Futil%2FTreeSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a142a996267f9c8adf239a565725174265c67749/libjava%2Fjava%2Futil%2FTreeSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTreeSet.java?ref=a142a996267f9c8adf239a565725174265c67749", "patch": "@@ -0,0 +1,289 @@\n+/* TreeSet.java -- a class providing a TreeMap-backet SortedSet\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.util;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+/**\n+ * This class provides a TreeMap-backed implementation of the \n+ * SortedSet interface.\n+ *\n+ * Each element in the Set is a key in the backing TreeMap; each key\n+ * maps to a static token, denoting that the key does, in fact, exist.\n+ *\n+ * Most operations are O(log n).\n+ *\n+ * TreeSet is a part of the JDK1.2 Collections API.\n+ *\n+ * @author      Jon Zeppieri\n+ * @version     $Revision: 1.7 $\n+ * @modified    $Id: TreeSet.java,v 1.7 2000/10/26 10:19:01 bryce Exp $\n+ */\n+\n+public class TreeSet extends AbstractSet\n+  implements SortedSet, Cloneable, Serializable\n+{\n+  /** The TreeMap which backs this Set */\n+  transient SortedMap map;\n+\n+  static final long serialVersionUID = -2479143000061671589L;\n+\n+  /**\n+   * Construct a new TreeSet whose backing TreeMap using the \"natural\" \n+   * ordering of keys.\n+   */\n+  public TreeSet()\n+  {\n+    map = new TreeMap();\n+  }\n+\n+  /** \n+   * Construct a new TreeSet whose backing TreeMap uses the supplied \n+   * Comparator.\n+   *\n+   * @param     oComparator      the Comparator this Set will use\n+   */\n+  public TreeSet(Comparator comparator)\n+  {\n+    map = new TreeMap(comparator);\n+  }\n+\n+  /** \n+   * Construct a new TreeSet whose backing TreeMap uses the \"natural\"\n+   * orering of the keys and which contains all of the elements in the\n+   * supplied Collection.\n+   *\n+   * @param     oCollection      the new Set will be initialized with all\n+   *                             of the elements in this Collection\n+   */\n+  public TreeSet(Collection collection)\n+  {\n+    map = new TreeMap();\n+    addAll(collection);\n+  }\n+\n+  /**\n+   * Construct a new TreeSet, using the same key ordering as the supplied\n+   * SortedSet and containing all of the elements in the supplied SortedSet.\n+   * This constructor runs in linear time.\n+   *\n+   * @param     sortedSet       the new TreeSet will use this SortedSet's\n+   *                            comparator and will initialize itself\n+   *                            with all of the elements in this SortedSet\n+   */\n+  public TreeSet(SortedSet sortedSet)\n+  {\n+    TreeMap map = new TreeMap(sortedSet.comparator());\n+    int i = 0;\n+    Iterator itr = sortedSet.iterator();\n+    map.putKeysLinear(itr, sortedSet.size());\n+    this.map = map;\n+  }\n+  \n+  /* This private constructor is used to implement the subSet() calls around\n+    a backing TreeMap.SubMap. */\n+  TreeSet(SortedMap backingMap)\n+  {\n+    map = backingMap;\n+  }\n+\n+  /** \n+   * Adds the spplied Object to the Set if it is not already in the Set;\n+   * returns true if the element is added, false otherwise\n+   *\n+   * @param       obj       the Object to be added to this Set\n+   */\n+  public boolean add(Object obj)\n+  {\n+    return (map.put(obj, Boolean.TRUE) == null);\n+  }\n+\n+  /**\n+   * Adds all of the elements in the supplied Collection to this TreeSet.\n+   *\n+   * @param        c         All of the elements in this Collection\n+   *                         will be added to the Set.\n+   *\n+   * @return       true if the Set is altered, false otherwise\n+   */\n+  public boolean addAll(Collection c)\n+  {\n+    boolean result = false;\n+    int size = c.size();\n+    Iterator itr = c.iterator();\n+\n+    for (int i = 0; i < size; i++)\n+      result |= (map.put(itr.next(), Boolean.TRUE) == null);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Removes all elements in this Set.\n+   */\n+  public void clear()\n+  {\n+    map.clear();\n+  }\n+\n+  /** Returns a shallow copy of this Set. */\n+  public Object clone()\n+  {\n+    TreeSet copy = new TreeSet();\n+    try\n+      {\n+\tcopy.map = (TreeMap) map.clone();\n+      }\n+    catch (CloneNotSupportedException ex)\n+      {\n+      }\n+\n+    return copy;\n+  }\n+\n+  /** Returns this Set's comparator */\n+  public Comparator comparator()\n+  {\n+    return map.comparator();\n+  }\n+\n+  /** \n+   * Returns true if this Set contains the supplied Object, \n+   * false otherwise \n+   *\n+   * @param       oObject        the Object whose existence in the Set is\n+   *                             being tested\n+   */\n+  public boolean contains(Object obj)\n+  {\n+    return map.containsKey(obj);\n+  }\n+\n+  /** Returns true if this Set has size 0, false otherwise */\n+  public boolean isEmpty()\n+  {\n+    return map.isEmpty();\n+  }\n+\n+  /** Returns the number of elements in this Set */\n+  public int size()\n+  {\n+    return map.size();\n+  }\n+\n+  /** \n+   * If the supplied Object is in this Set, it is removed, and true is\n+   * returned; otherwise, false is returned.\n+   *\n+   * @param         obj        the Object we are attempting to remove\n+   *                           from this Set\n+   */\n+  public boolean remove(Object obj)\n+  {\n+    return (map.remove(obj) != null);\n+  }\n+\n+  /** Returns the first (by order) element in this Set */\n+  public Object first()\n+  {\n+    return map.firstKey();\n+  }\n+\n+  /** Returns the last (by order) element in this Set */\n+  public Object last()\n+  {\n+    return map.lastKey();\n+  }\n+\n+  /**\n+   * Returns a view of this Set including all elements in the interval\n+   * [oFromElement, oToElement).\n+   *\n+   * @param       from  the resultant view will contain all\n+   *                    elements greater than or equal to this element\n+   * @param       to    the resultant view will contain all\n+   *                    elements less than this element\n+   */\n+  public SortedSet subSet(Object from, Object to)\n+  {\n+    return new TreeSet(map.subMap(from, to));\n+  }\n+\n+  /**\n+   * Returns a view of this Set including all elements less than oToElement\n+   *\n+   * @param       toElement    the resultant view will contain all\n+   *                            elements less than this element\n+   */\n+  public SortedSet headSet(Object to)\n+  {\n+    return new TreeSet(map.headMap(to));\n+  }\n+\n+  /**\n+   * Returns a view of this Set including all elements greater than or\n+   * equal to oFromElement.\n+   *\n+   * @param       from  the resultant view will contain all\n+   *              elements greater than or equal to this element\n+   */\n+  public SortedSet tailSet(Object from)\n+  {\n+    return new TreeSet(map.tailMap(from));\n+  }\n+\n+  /** Returns in Iterator over the elements in this TreeSet */\n+  public Iterator iterator()\n+  {\n+    return map.keySet().iterator();\n+  }\n+\n+  private void writeObject(ObjectOutputStream out) throws IOException\n+  {\n+    Iterator itr = map.keySet().iterator();\n+\n+    out.writeObject(map.comparator());\n+    out.writeInt(map.size());\n+\n+    while (itr.hasNext())\n+      out.writeObject(itr.next());\n+  }\n+\n+  private void readObject(ObjectInputStream in)\n+    throws IOException, ClassNotFoundException\n+  {\n+    Comparator comparator = (Comparator) in.readObject();\n+    int size = in.readInt();\n+    TreeMap map = new TreeMap(comparator);    \n+    map.putFromObjStream(in, size, false);\n+    this.map = map;\n+  }\n+}"}]}