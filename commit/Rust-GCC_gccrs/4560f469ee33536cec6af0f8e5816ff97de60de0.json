{"sha": "4560f469ee33536cec6af0f8e5816ff97de60de0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU2MGY0NjllZTMzNTM2Y2VjNmFmMGY4ZTU4MTZmZjk3ZGU2MGRlMA==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-10T21:02:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-10T21:02:06Z"}, "message": "Merge #551\n\n551: Initial AssociatedType support r=philberty a=philberty\n\nTraits can define Type aliasses which must enforce the correct resolution\r\nonto their respective TraitImplBlocks. This PR adds all the necessary building\r\nblocks for the initial support.\r\n\r\nMore work is needed in checking for trait-impl-item consistency with its respective\r\nTrait item types.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "9787b1f711ea87021e42dfa9d3316c6b8645a762", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9787b1f711ea87021e42dfa9d3316c6b8645a762"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4560f469ee33536cec6af0f8e5816ff97de60de0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg6grOCRBK7hj4Ov3rIwAABeQIABeFqopV8IrWEza0EX1rHwGc\nrJIOGOeTpigHD3y4BVFn9krD+EuBAsQRWtMTSn+4NUGLr4J66DPovAIhPVkG6kWU\n4rP1Dpijk6O79iMU1lf4hvy19EWsTQBDz4i6Pa6IQ9l7pHbtJG+WtDxz6kwy3ddG\n49ikYZInUCgJhoF1JbeaQPiab88dRa9dZYfMt9ZyXwAOXwAdic0Tim43wFlN0xdG\nDbYEJquS3/DZH2EbQOb9CyiDs9ixHa7nW7VCM+lZlA7QKkl2Mg6Fainq5hI7qyJd\nRhVO9gDCWmHsmtIggoNYi3//0SGD5GAMKQ87hjtqhTPUvUlDaQJIwy9H/ob3Koc=\n=kJhh\n-----END PGP SIGNATURE-----\n", "payload": "tree 9787b1f711ea87021e42dfa9d3316c6b8645a762\nparent f090e7ca9fa0b19f1cd7df16a0476b6e252c5ef1\nparent defb583203923bf4edeb0531e85fa28de5015ecb\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1625950926 +0000\ncommitter GitHub <noreply@github.com> 1625950926 +0000\n\nMerge #551\n\n551: Initial AssociatedType support r=philberty a=philberty\n\nTraits can define Type aliasses which must enforce the correct resolution\r\nonto their respective TraitImplBlocks. This PR adds all the necessary building\r\nblocks for the initial support.\r\n\r\nMore work is needed in checking for trait-impl-item consistency with its respective\r\nTrait item types.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4560f469ee33536cec6af0f8e5816ff97de60de0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4560f469ee33536cec6af0f8e5816ff97de60de0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4560f469ee33536cec6af0f8e5816ff97de60de0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f090e7ca9fa0b19f1cd7df16a0476b6e252c5ef1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f090e7ca9fa0b19f1cd7df16a0476b6e252c5ef1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f090e7ca9fa0b19f1cd7df16a0476b6e252c5ef1"}, {"sha": "defb583203923bf4edeb0531e85fa28de5015ecb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/defb583203923bf4edeb0531e85fa28de5015ecb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/defb583203923bf4edeb0531e85fa28de5015ecb"}], "stats": {"total": 1670, "additions": 1288, "deletions": 382}, "files": [{"sha": "011ac3ebee422979b1872041736b0dd230e72eca", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -406,18 +406,14 @@ class PathInExpression : public PathPattern, public PathExpr\n  * ident-only segment) */\n class TypePathSegment\n {\n-  /* TODO: may have to unify TypePathSegment and PathExprSegment (which are\n-   * mostly the same anyway) in order to resolve goddamn syntax ambiguities. One\n-   * difference is that function on TypePathSegment is not allowed if\n-   * GenericArgs are, so could disallow that in constructor, which won't give\n-   * that much size overhead. */\n   PathIdentSegment ident_segment;\n   Location locus;\n \n protected:\n   /* This is protected because it is only really used by derived classes, not\n    * the base. */\n   bool has_separating_scope_resolution;\n+  NodeId node_id;\n \n   // Clone function implementation - not pure virtual as overrided by subclasses\n   virtual TypePathSegment *clone_type_path_segment_impl () const\n@@ -437,14 +433,16 @@ class TypePathSegment\n   TypePathSegment (PathIdentSegment ident_segment,\n \t\t   bool has_separating_scope_resolution, Location locus)\n     : ident_segment (std::move (ident_segment)), locus (locus),\n-      has_separating_scope_resolution (has_separating_scope_resolution)\n+      has_separating_scope_resolution (has_separating_scope_resolution),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   TypePathSegment (std::string segment_name,\n \t\t   bool has_separating_scope_resolution, Location locus)\n     : ident_segment (PathIdentSegment (std::move (segment_name))),\n       locus (locus),\n-      has_separating_scope_resolution (has_separating_scope_resolution)\n+      has_separating_scope_resolution (has_separating_scope_resolution),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   virtual std::string as_string () const { return ident_segment.as_string (); }\n@@ -454,7 +452,7 @@ class TypePathSegment\n   bool is_error () const { return ident_segment.is_error (); }\n \n   /* Returns whether segment is identifier only (as opposed to generic args or\n-   * function). Overriden in derived classes with other segments. */\n+   * function). Overridden in derived classes with other segments. */\n   virtual bool is_ident_only () const { return true; }\n \n   Location get_locus () const { return locus; }\n@@ -468,6 +466,8 @@ class TypePathSegment\n   }\n \n   PathIdentSegment get_ident_segment () { return ident_segment; };\n+\n+  NodeId get_node_id () const { return node_id; }\n };\n \n // Segment used in type path with generic args"}, {"sha": "d8229376138f70a213f01e3dcf34d055fa4596a2", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -336,6 +336,8 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n \n+  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n+\n   void visit (TyTy::ParamType &param) override\n   {\n     param.resolve ()->accept_vis (*this);"}, {"sha": "d2890e0f7c6b33528502ab9a20f62cab4f5673ae", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -48,6 +48,8 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::ADTType &) override { gcc_unreachable (); }\n \n+  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n+\n   void visit (TyTy::TupleType &type) override\n   {\n     if (type.num_fields () == 0)"}, {"sha": "b08a1667e2711ede311eb9ce2baf099f832aebfd", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -52,6 +52,38 @@ class ASTLowerImplItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n+  void visit (AST::TypeAlias &alias) override\n+  {\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (alias.has_generics ())\n+      generic_params = lower_generic_params (alias.get_generic_params ());\n+\n+    HIR::Type *existing_type\n+      = ASTLoweringType::translate (alias.get_type_aliased ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, alias.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::TypeAlias (mapping, alias.get_new_type_name (),\n+\t\t\t\t     std::move (generic_params),\n+\t\t\t\t     std::move (where_clause),\n+\t\t\t\t     std::unique_ptr<HIR::Type> (existing_type),\n+\t\t\t\t     std::move (vis), alias.get_outer_attrs (),\n+\t\t\t\t     alias.get_locus ());\n+\n+    mappings->insert_hir_implitem (mapping.get_crate_num (),\n+\t\t\t\t   mapping.get_hirid (), parent_impl_id,\n+\t\t\t\t   translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       alias.get_locus ());\n+  }\n+\n   void visit (AST::ConstantItem &constant) override\n   {\n     HIR::Visibility vis = HIR::Visibility::create_public ();"}, {"sha": "68324c7b191d1ab0ec49c5a8fcaa418617ef1293", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -379,6 +379,7 @@ class ASTLoweringItem : public ASTLoweringBase\n \tHIR::ImplItem *lowered\n \t  = ASTLowerImplItem::translate (impl_item.get (),\n \t\t\t\t\t mapping.get_hirid ());\n+\trust_assert (lowered != nullptr);\n \timpl_items.push_back (std::unique_ptr<HIR::ImplItem> (lowered));\n \timpl_item_ids.push_back (lowered->get_impl_mappings ().get_hirid ());\n       }\n@@ -521,6 +522,7 @@ class ASTLoweringItem : public ASTLoweringBase\n \tHIR::ImplItem *lowered\n \t  = ASTLowerImplItem::translate (impl_item.get (),\n \t\t\t\t\t mapping.get_hirid ());\n+\trust_assert (lowered != nullptr);\n \timpl_items.push_back (std::unique_ptr<HIR::ImplItem> (lowered));\n \timpl_item_ids.push_back (lowered->get_impl_mappings ().get_hirid ());\n       }"}, {"sha": "0b534d0093d4b9eeb76026be52dcef71d4247de3", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -35,17 +35,22 @@ class ASTLowerTypePath : public ASTLoweringBase\n   {\n     ASTLowerTypePath resolver;\n     type.accept_vis (resolver);\n-\n     rust_assert (resolver.translated != nullptr);\n-\n     return resolver.translated;\n   }\n \n+  void visit (AST::TypePathSegmentFunction &) override { gcc_unreachable (); }\n+\n   void visit (AST::TypePathSegment &segment) override\n   {\n+    auto crate_num = mappings->get_current_crate ();\n+    auto hirid = mappings->get_next_hir_id (crate_num);\n+    Analysis::NodeMapping mapping (crate_num, segment.get_node_id (), hirid,\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n     HIR::PathIdentSegment ident (segment.get_ident_segment ().as_string ());\n     translated_segment\n-      = new HIR::TypePathSegment (ident,\n+      = new HIR::TypePathSegment (std::move (mapping), ident,\n \t\t\t\t  segment.get_separating_scope_resolution (),\n \t\t\t\t  segment.get_locus ());\n   }"}, {"sha": "516b5ba9f76001d1ef15cc04136b3e597ccf7369", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -383,9 +383,15 @@ ASTLowerTypePath::visit (AST::TypePathSegmentGeneric &segment)\n       type_args.push_back (std::unique_ptr<HIR::Type> (t));\n     }\n \n+  auto crate_num = mappings->get_current_crate ();\n+  auto hirid = mappings->get_next_hir_id (crate_num);\n+  Analysis::NodeMapping mapping (crate_num, segment.get_node_id (), hirid,\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n   translated_segment = new HIR::TypePathSegmentGeneric (\n-    segment_name, has_separating_scope_resolution, std::move (lifetime_args),\n-    std::move (type_args), std::move (binding_args), segment.get_locus ());\n+    std::move (mapping), segment_name, has_separating_scope_resolution,\n+    std::move (lifetime_args), std::move (type_args), std::move (binding_args),\n+    segment.get_locus ());\n }\n \n } // namespace HIR"}, {"sha": "5d9f965347b4d4f517a9d02010723ad02d854304", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 57, "deletions": 30, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -351,19 +351,22 @@ class PathInExpression : public PathPattern, public PathExpr\n  * ident-only segment) */\n class TypePathSegment\n {\n-  /* TODO: may have to unify TypePathSegment and PathExprSegment (which are\n-   * mostly the same anyway) in order to resolve goddamn syntax ambiguities. One\n-   * difference is that function on TypePathSegment is not allowed if\n-   * GenericArgs are, so could disallow that in constructor, which won't give\n-   * that much size overhead. */\n-  PathIdentSegment ident_segment;\n+public:\n+  enum SegmentType\n+  {\n+    REG,\n+    GENERIC,\n+    FUNCTION\n+  };\n \n+private:\n+  Analysis::NodeMapping mappings;\n+  PathIdentSegment ident_segment;\n   Location locus;\n \n protected:\n-  /* This is protected because it is only really used by derived classes, not\n-   * the base. */\n   bool has_separating_scope_resolution;\n+  SegmentType type;\n \n   // Clone function implementation - not pure virtual as overrided by subclasses\n   virtual TypePathSegment *clone_type_path_segment_impl () const\n@@ -374,23 +377,30 @@ class TypePathSegment\n public:\n   virtual ~TypePathSegment () {}\n \n+  virtual SegmentType get_type () const { return SegmentType::REG; }\n+\n   // Unique pointer custom clone function\n   std::unique_ptr<TypePathSegment> clone_type_path_segment () const\n   {\n     return std::unique_ptr<TypePathSegment> (clone_type_path_segment_impl ());\n   }\n \n-  TypePathSegment (PathIdentSegment ident_segment,\n+  TypePathSegment (Analysis::NodeMapping mappings,\n+\t\t   PathIdentSegment ident_segment,\n \t\t   bool has_separating_scope_resolution, Location locus)\n-    : ident_segment (std::move (ident_segment)), locus (locus),\n-      has_separating_scope_resolution (has_separating_scope_resolution)\n+    : mappings (std::move (mappings)),\n+      ident_segment (std::move (ident_segment)), locus (locus),\n+      has_separating_scope_resolution (has_separating_scope_resolution),\n+      type (SegmentType::REG)\n   {}\n \n-  TypePathSegment (std::string segment_name,\n+  TypePathSegment (Analysis::NodeMapping mappings, std::string segment_name,\n \t\t   bool has_separating_scope_resolution, Location locus)\n-    : ident_segment (PathIdentSegment (std::move (segment_name))),\n+    : mappings (std::move (mappings)),\n+      ident_segment (PathIdentSegment (std::move (segment_name))),\n       locus (locus),\n-      has_separating_scope_resolution (has_separating_scope_resolution)\n+      has_separating_scope_resolution (has_separating_scope_resolution),\n+      type (SegmentType::REG)\n   {}\n \n   virtual std::string as_string () const { return ident_segment.as_string (); }\n@@ -407,6 +417,10 @@ class TypePathSegment\n \n   // not pure virtual as class not abstract\n   virtual void accept_vis (HIRVisitor &vis);\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n+\n+  const PathIdentSegment &get_ident_segment () const { return ident_segment; }\n };\n \n // Segment used in type path with generic args\n@@ -420,22 +434,24 @@ class TypePathSegmentGeneric : public TypePathSegment\n   bool is_ident_only () const override { return false; }\n \n   // Constructor with PathIdentSegment and GenericArgs\n-  TypePathSegmentGeneric (PathIdentSegment ident_segment,\n+  TypePathSegmentGeneric (Analysis::NodeMapping mappings,\n+\t\t\t  PathIdentSegment ident_segment,\n \t\t\t  bool has_separating_scope_resolution,\n \t\t\t  GenericArgs generic_args, Location locus)\n-    : TypePathSegment (std::move (ident_segment),\n+    : TypePathSegment (std::move (mappings), std::move (ident_segment),\n \t\t       has_separating_scope_resolution, locus),\n       generic_args (std::move (generic_args))\n   {}\n \n   // Constructor from segment name and all args\n-  TypePathSegmentGeneric (std::string segment_name,\n+  TypePathSegmentGeneric (Analysis::NodeMapping mappings,\n+\t\t\t  std::string segment_name,\n \t\t\t  bool has_separating_scope_resolution,\n \t\t\t  std::vector<Lifetime> lifetime_args,\n \t\t\t  std::vector<std::unique_ptr<Type> > type_args,\n \t\t\t  std::vector<GenericArgsBinding> binding_args,\n \t\t\t  Location locus)\n-    : TypePathSegment (std::move (segment_name),\n+    : TypePathSegment (std::move (mappings), std::move (segment_name),\n \t\t       has_separating_scope_resolution, locus),\n       generic_args (GenericArgs (std::move (lifetime_args),\n \t\t\t\t std::move (type_args),\n@@ -446,7 +462,12 @@ class TypePathSegmentGeneric : public TypePathSegment\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  GenericArgs get_generic_args () { return generic_args; }\n+  GenericArgs &get_generic_args () { return generic_args; }\n+\n+  virtual SegmentType get_type () const override final\n+  {\n+    return SegmentType::GENERIC;\n+  }\n \n protected:\n   // Use covariance to override base class method\n@@ -544,19 +565,21 @@ class TypePathSegmentFunction : public TypePathSegment\n \n public:\n   // Constructor with PathIdentSegment and TypePathFn\n-  TypePathSegmentFunction (PathIdentSegment ident_segment,\n+  TypePathSegmentFunction (Analysis::NodeMapping mappings,\n+\t\t\t   PathIdentSegment ident_segment,\n \t\t\t   bool has_separating_scope_resolution,\n \t\t\t   TypePathFunction function_path, Location locus)\n-    : TypePathSegment (std::move (ident_segment),\n+    : TypePathSegment (std::move (mappings), std::move (ident_segment),\n \t\t       has_separating_scope_resolution, locus),\n       function_path (std::move (function_path))\n   {}\n \n   // Constructor with segment name and TypePathFn\n-  TypePathSegmentFunction (std::string segment_name,\n+  TypePathSegmentFunction (Analysis::NodeMapping mappings,\n+\t\t\t   std::string segment_name,\n \t\t\t   bool has_separating_scope_resolution,\n \t\t\t   TypePathFunction function_path, Location locus)\n-    : TypePathSegment (std::move (segment_name),\n+    : TypePathSegment (std::move (mappings), std::move (segment_name),\n \t\t       has_separating_scope_resolution, locus),\n       function_path (std::move (function_path))\n   {}\n@@ -567,6 +590,11 @@ class TypePathSegmentFunction : public TypePathSegment\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  virtual SegmentType get_type () const override final\n+  {\n+    return SegmentType::FUNCTION;\n+  }\n+\n protected:\n   // Use covariance to override base class method\n   TypePathSegmentFunction *clone_type_path_segment_impl () const override\n@@ -667,16 +695,15 @@ class TypePath : public TypeNoBounds\n \n   size_t get_num_segments () const { return segments.size (); }\n \n-  void iterate_segments (std::function<bool (TypePathSegment *)> cb)\n+  std::vector<std::unique_ptr<TypePathSegment> > &get_segments ()\n   {\n-    for (auto &seg : segments)\n-      {\n-\tif (!cb (seg.get ()))\n-\t  return;\n-      }\n+    return segments;\n   }\n \n-  TypePathSegment *get_final_segment () { return segments.back ().get (); }\n+  std::unique_ptr<TypePathSegment> &get_final_segment ()\n+  {\n+    return segments.back ();\n+  }\n };\n \n struct QualifiedPathType"}, {"sha": "ec89f6ccb25145ac77f6d72a450e60a16432c308", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -117,16 +117,18 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::IdentifierExpr &expr) override\n   {\n-    if (resolver->get_name_scope ().lookup (CanonicalPath (expr.as_string ()),\n-\t\t\t\t\t    &resolved_node))\n+    if (resolver->get_name_scope ().lookup (\n+\t  CanonicalPath::new_seg (expr.get_node_id (), expr.as_string ()),\n+\t  &resolved_node))\n       {\n \tresolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (expr.get_node_id (),\n \t\t\t\t\t Definition{expr.get_node_id (),\n \t\t\t\t\t\t    parent});\n       }\n     else if (resolver->get_type_scope ().lookup (\n-\t       CanonicalPath (expr.as_string ()), &resolved_node))\n+\t       CanonicalPath::new_seg (expr.get_node_id (), expr.as_string ()),\n+\t       &resolved_node))\n       {\n \tresolver->insert_resolved_type (expr.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (expr.get_node_id (),\n@@ -272,8 +274,8 @@ class ResolveExpr : public ResolverBase\n \tauto label_name = label.get_lifetime ().get_lifetime_name ();\n \tauto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n \tresolver->get_label_scope ().insert (\n-\t  CanonicalPath (label_name), label_lifetime_node_id,\n-\t  label.get_locus (), false,\n+\t  CanonicalPath::new_seg (expr.get_node_id (), label_name),\n+\t  label_lifetime_node_id, label.get_locus (), false,\n \t  [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \t    rust_error_at (label.get_locus (),\n \t\t\t   \"label redefined multiple times\");\n@@ -300,7 +302,9 @@ class ResolveExpr : public ResolverBase\n \n \tNodeId resolved_node = UNKNOWN_NODEID;\n \tif (!resolver->get_label_scope ().lookup (\n-\t      CanonicalPath (label.get_lifetime_name ()), &resolved_node))\n+\t      CanonicalPath::new_seg (label.get_node_id (),\n+\t\t\t\t      label.get_lifetime_name ()),\n+\t      &resolved_node))\n \t  {\n \t    rust_error_at (expr.get_label ().get_locus (),\n \t\t\t   \"failed to resolve label\");\n@@ -329,8 +333,8 @@ class ResolveExpr : public ResolverBase\n \tauto label_name = label.get_lifetime ().get_lifetime_name ();\n \tauto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n \tresolver->get_label_scope ().insert (\n-\t  CanonicalPath (label_name), label_lifetime_node_id,\n-\t  label.get_locus (), false,\n+\t  CanonicalPath::new_seg (label.get_node_id (), label_name),\n+\t  label_lifetime_node_id, label.get_locus (), false,\n \t  [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \t    rust_error_at (label.get_locus (),\n \t\t\t   \"label redefined multiple times\");\n@@ -358,7 +362,9 @@ class ResolveExpr : public ResolverBase\n \n \tNodeId resolved_node = UNKNOWN_NODEID;\n \tif (!resolver->get_label_scope ().lookup (\n-\t      CanonicalPath (label.get_lifetime_name ()), &resolved_node))\n+\t      CanonicalPath::new_seg (label.get_node_id (),\n+\t\t\t\t      label.get_lifetime_name ()),\n+\t      &resolved_node))\n \t  {\n \t    rust_error_at (expr.get_label ().get_locus (),\n \t\t\t   \"failed to resolve label\");"}, {"sha": "2b3a09a6fa4573ed52b43fb20bf88a0f1f8f77b6", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -43,6 +43,22 @@ class ResolveToplevelImplItem : public ResolverBase\n     item->accept_vis (resolver);\n   }\n \n+  void visit (AST::TypeAlias &type) override\n+  {\n+    auto path = prefix.append (\n+      CanonicalPath::new_seg (type.get_node_id (), type.get_new_type_name ()));\n+    resolver->get_type_scope ().insert (\n+      path, type.get_node_id (), type.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (type.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+    resolver->insert_new_definition (type.get_node_id (),\n+\t\t\t\t     Definition{type.get_node_id (),\n+\t\t\t\t\t\ttype.get_node_id ()});\n+  }\n+\n   void visit (AST::ConstantItem &constant) override\n   {\n     auto path"}, {"sha": "1f1ff300476f0f02724f4fca4d65e99565bb6820", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 239, "deletions": 111, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -28,11 +28,168 @@\n namespace Rust {\n namespace Resolver {\n \n-class ResolveItem : public ResolverBase\n+class ResolveTraitItems : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n+  static void go (AST::TraitItem *item, const CanonicalPath &self)\n+  {\n+    ResolveTraitItems resolver (self);\n+    item->accept_vis (resolver);\n+  };\n+\n+  void visit (AST::TraitItemType &type) override\n+  {\n+    // insert Self::type_alias for TypePath lookup\n+    auto path\n+      = self.append (ResolveTraitItemTypeToCanonicalPath::resolve (type));\n+    resolver->get_type_scope ().insert (\n+      path, type.get_node_id (), type.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (type.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    // FIXME this stops the erronious unused decls which will be fixed later on\n+    resolver->get_type_scope ().append_reference_for_def (type.get_node_id (),\n+\t\t\t\t\t\t\t  type.get_node_id ());\n+\n+    // TODO resolve the type-bounds\n+  }\n+\n+  void visit (AST::TraitItemFunc &func) override\n+  {\n+    NodeId scope_node_id = func.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n+    resolver->get_type_scope ().push (scope_node_id);\n+    resolver->get_label_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+    AST::TraitFunctionDecl &function = func.get_trait_function_decl ();\n+    if (function.has_generics ())\n+      {\n+\tfor (auto &generic : function.get_generic_params ())\n+\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n+      }\n+\n+    if (function.has_return_type ())\n+      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+\n+    // we make a new scope so the names of parameters are resolved and shadowed\n+    // correctly\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n+\tPatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t\tparam.get_node_id ());\n+\n+\t// the mutability checker needs to verify for immutable decls the number\n+\t// of assignments are <1. This marks an implicit assignment\n+\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n+\t\t\t\t\t   param.get_node_id ());\n+      }\n+\n+    // trait items have an optional body\n+    if (func.has_definition ())\n+      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n+\n+    resolver->get_name_scope ().pop ();\n+    resolver->get_type_scope ().pop ();\n+    resolver->get_label_scope ().pop ();\n+  }\n+\n+  void visit (AST::TraitItemMethod &func) override\n+  {\n+    NodeId scope_node_id = func.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n+    resolver->get_type_scope ().push (scope_node_id);\n+    resolver->get_label_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+    AST::TraitMethodDecl &function = func.get_trait_method_decl ();\n+    if (function.has_generics ())\n+      {\n+\tfor (auto &generic : function.get_generic_params ())\n+\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n+      }\n+\n+    if (function.has_return_type ())\n+      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+\n+    // self turns into (self: Self) as a function param\n+    AST::SelfParam &self_param = function.get_self_param ();\n+    AST::IdentifierPattern self_pattern (\n+      self_param.get_node_id (), \"self\", self_param.get_locus (),\n+      self_param.get_has_ref (), self_param.get_is_mut (),\n+      std::unique_ptr<AST::Pattern> (nullptr));\n+\n+    std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+    segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n+      new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n+\n+    AST::TypePath self_type_path (std::move (segments),\n+\t\t\t\t  self_param.get_locus ());\n+\n+    ResolveType::go (&self_type_path, self_param.get_node_id ());\n+    PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n+\n+    resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n+\t\t\t\t       self_pattern.get_node_id ());\n+\n+    // we make a new scope so the names of parameters are resolved and shadowed\n+    // correctly\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n+\tPatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t\tparam.get_node_id ());\n+\n+\t// the mutability checker needs to verify for immutable decls the number\n+\t// of assignments are <1. This marks an implicit assignment\n+\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n+\t\t\t\t\t   param.get_node_id ());\n+      }\n+\n+    // trait items have an optional body\n+    if (func.has_definition ())\n+      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n+\n+    resolver->get_name_scope ().pop ();\n+    resolver->get_type_scope ().pop ();\n+    resolver->get_label_scope ().pop ();\n+  }\n+\n+  void visit (AST::TraitItemConst &constant) override\n+  {\n+    ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n+    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id ());\n+\n+    // the mutability checker needs to verify for immutable decls the number\n+    // of assignments are <1. This marks an implicit assignment\n+    resolver->mark_decl_mutability (constant.get_node_id (), false);\n+    resolver->mark_assignment_to_decl (constant.get_node_id (),\n+\t\t\t\t       constant.get_node_id ());\n+  }\n+\n+private:\n+  ResolveTraitItems (const CanonicalPath &self)\n+    : ResolverBase (UNKNOWN_NODEID), self (self)\n+  {}\n+\n+  const CanonicalPath &self;\n+};\n+\n+class ResolveItem : public ResolverBase\n+{\n+public:\n+  using Rust::Resolver::ResolverBase::visit;\n+\n   static void go (AST::Item *item)\n   {\n     ResolveItem resolver;\n@@ -169,7 +326,10 @@ class ResolveItem : public ResolverBase\n   void visit (AST::InherentImpl &impl_block) override\n   {\n     NodeId scope_node_id = impl_block.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n \n     if (impl_block.has_generics ())\n       {\n@@ -184,18 +344,29 @@ class ResolveItem : public ResolverBase\n \t\t\t\t\t    impl_block.get_node_id (),\n \t\t\t\t\t    canonicalize_type_with_generics);\n     if (resolved_node == UNKNOWN_NODEID)\n-      return;\n+      {\n+\tresolver->get_type_scope ().pop ();\n+\tresolver->get_name_scope ().pop ();\n+\treturn;\n+      }\n+\n+    auto Self\n+      = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n \n     resolver->get_type_scope ().insert (\n-      CanonicalPath::get_big_self (), impl_block.get_type ()->get_node_id (),\n+      Self, impl_block.get_type ()->get_node_id (),\n       impl_block.get_type ()->get_locus_slow ());\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n-      impl_item->accept_vis (*this);\n+      {\n+\tresolve_impl_item (impl_item.get (), Self);\n+      }\n \n     resolver->get_type_scope ().peek ()->clear_name (\n-      CanonicalPath::get_big_self (), impl_block.get_type ()->get_node_id ());\n+      Self, impl_block.get_type ()->get_node_id ());\n+\n     resolver->get_type_scope ().pop ();\n+    resolver->get_name_scope ().pop ();\n   }\n \n   void visit (AST::Method &method) override\n@@ -262,7 +433,10 @@ class ResolveItem : public ResolverBase\n   void visit (AST::TraitImpl &impl_block) override\n   {\n     NodeId scope_node_id = impl_block.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n \n     if (impl_block.has_generics ())\n       {\n@@ -280,6 +454,7 @@ class ResolveItem : public ResolverBase\n     if (trait_resolved_node == UNKNOWN_NODEID)\n       {\n \tresolver->get_type_scope ().pop ();\n+\tresolver->get_name_scope ().pop ();\n \treturn;\n       }\n \n@@ -290,156 +465,109 @@ class ResolveItem : public ResolverBase\n     if (type_resolved_node == UNKNOWN_NODEID)\n       {\n \tresolver->get_type_scope ().pop ();\n+\tresolver->get_name_scope ().pop ();\n \treturn;\n       }\n \n+    auto Self\n+      = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n+\n     resolver->get_type_scope ().insert (\n-      CanonicalPath::get_big_self (), impl_block.get_type ()->get_node_id (),\n+      Self, impl_block.get_type ()->get_node_id (),\n       impl_block.get_type ()->get_locus_slow ());\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n-      impl_item->accept_vis (*this);\n+      {\n+\tresolve_impl_item (impl_item.get (), Self);\n+      }\n \n     resolver->get_type_scope ().peek ()->clear_name (\n-      CanonicalPath::get_big_self (), impl_block.get_type ()->get_node_id ());\n+      Self, impl_block.get_type ()->get_node_id ());\n     resolver->get_type_scope ().pop ();\n   }\n \n   void visit (AST::Trait &trait) override\n   {\n     NodeId scope_node_id = trait.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n \n     // we need to inject an implicit self TypeParam here\n     AST::TypeParam *implicit_self\n       = new AST::TypeParam (\"Self\", trait.get_locus ());\n     trait.insert_implict_self (\n       std::unique_ptr<AST::GenericParam> (implicit_self));\n+    CanonicalPath Self = CanonicalPath::get_big_self (trait.get_node_id ());\n \n     for (auto &generic : trait.get_generic_params ())\n       {\n \tResolveGenericParam::go (generic.get (), trait.get_node_id ());\n       }\n \n-    for (auto &item : trait.get_trait_items ())\n-      item->accept_vis (*this);\n-\n-    resolver->get_type_scope ().pop ();\n-  }\n-\n-  void visit (AST::TraitItemFunc &func) override\n-  {\n-    NodeId scope_node_id = func.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    AST::TraitFunctionDecl &function = func.get_trait_function_decl ();\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic : function.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n-      }\n-\n-    if (function.has_return_type ())\n-      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+    // Self is an implicit TypeParam so lets mark it as such\n+    resolver->get_type_scope ().append_reference_for_def (\n+      Self.get_id (), implicit_self->get_node_id ());\n \n-    // we make a new scope so the names of parameters are resolved and shadowed\n-    // correctly\n-    for (auto &param : function.get_function_params ())\n+    for (auto &item : trait.get_trait_items ())\n       {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-\tPatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t\tparam.get_node_id ());\n-\n-\t// the mutability checker needs to verify for immutable decls the number\n-\t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n-\t\t\t\t\t   param.get_node_id ());\n+\tResolveTraitItems::go (item.get (), Self);\n       }\n \n-    // trait items have an optional body\n-    if (func.has_definition ())\n-      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n-\n-    resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n+    resolver->get_name_scope ().pop ();\n   }\n \n-  void visit (AST::TraitItemMethod &func) override\n-  {\n-    NodeId scope_node_id = func.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    AST::TraitMethodDecl &function = func.get_trait_method_decl ();\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic : function.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n-      }\n-\n-    if (function.has_return_type ())\n-      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n-\n-    // self turns into (self: Self) as a function param\n-    AST::SelfParam &self_param = function.get_self_param ();\n-    AST::IdentifierPattern self_pattern (\n-      self_param.get_node_id (), \"self\", self_param.get_locus (),\n-      self_param.get_has_ref (), self_param.get_is_mut (),\n-      std::unique_ptr<AST::Pattern> (nullptr));\n+protected:\n+  void resolve_impl_item (AST::TraitImplItem *item, const CanonicalPath &self);\n+  void resolve_impl_item (AST::InherentImplItem *item,\n+\t\t\t  const CanonicalPath &self);\n \n-    std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n-    segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n-      new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n-\n-    AST::TypePath self_type_path (std::move (segments),\n-\t\t\t\t  self_param.get_locus ());\n-\n-    ResolveType::go (&self_type_path, self_param.get_node_id ());\n-    PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n+  ResolveItem () : ResolverBase (UNKNOWN_NODEID) {}\n+};\n \n-    resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n-\t\t\t\t       self_pattern.get_node_id ());\n+class ResolveImplItems : public ResolveItem\n+{\n+  using Rust::Resolver::ResolveItem::visit;\n \n-    // we make a new scope so the names of parameters are resolved and shadowed\n-    // correctly\n-    for (auto &param : function.get_function_params ())\n-      {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-\tPatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t\tparam.get_node_id ());\n+public:\n+  static void go (AST::InherentImplItem *item, const CanonicalPath &self)\n+  {\n+    ResolveImplItems resolver (self);\n+    item->accept_vis (resolver);\n+  };\n \n-\t// the mutability checker needs to verify for immutable decls the number\n-\t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n-\t\t\t\t\t   param.get_node_id ());\n-      }\n+  static void go (AST::TraitImplItem *item, const CanonicalPath &self)\n+  {\n+    ResolveImplItems resolver (self);\n+    item->accept_vis (resolver);\n+  };\n \n-    // trait items have an optional body\n-    if (func.has_definition ())\n-      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n+  void visit (AST::TypeAlias &alias) override\n+  {\n+    ResolveItem::visit (alias);\n \n-    resolver->get_name_scope ().pop ();\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n+    auto path\n+      = self.append (CanonicalPath::new_seg (alias.get_node_id (),\n+\t\t\t\t\t     alias.get_new_type_name ()));\n+    resolver->get_type_scope ().insert (\n+      path, alias.get_node_id (), alias.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (alias.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    // FIXME this stops the erronious unused decls which will be fixed later on\n+    resolver->get_type_scope ().append_reference_for_def (alias.get_node_id (),\n+\t\t\t\t\t\t\t  alias.get_node_id ());\n   }\n \n-  // TODO\n-  void visit (AST::TraitItemConst &) override { gcc_unreachable (); }\n-\n-  void visit (AST::TraitItemType &) override { gcc_unreachable (); }\n-\n private:\n-  ResolveItem () : ResolverBase (UNKNOWN_NODEID) {}\n+  ResolveImplItems (const CanonicalPath &self) : ResolveItem (), self (self) {}\n+\n+  const CanonicalPath &self;\n };\n \n } // namespace Resolver"}, {"sha": "a41764a46c233c491072e1eef19dc779fd065fc8", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -44,7 +44,8 @@ class ResolvePattern : public ResolverBase\n   void visit (AST::IdentifierPattern &pattern) override\n   {\n     if (resolver->get_name_scope ().lookup (\n-\t  CanonicalPath (pattern.get_ident ()), &resolved_node))\n+\t  CanonicalPath::new_seg (pattern.get_node_id (), pattern.get_ident ()),\n+\t  &resolved_node))\n       {\n \tresolver->insert_resolved_name (pattern.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (pattern.get_node_id (),\n@@ -72,9 +73,9 @@ class PatternDeclaration : public ResolverBase\n   {\n     // if we have a duplicate id this then allows for shadowing correctly\n     // as new refs to this decl will match back here so it is ok to overwrite\n-    resolver->get_name_scope ().insert (CanonicalPath (pattern.get_ident ()),\n-\t\t\t\t\tpattern.get_node_id (),\n-\t\t\t\t\tpattern.get_locus ());\n+    resolver->get_name_scope ().insert (\n+      CanonicalPath::new_seg (pattern.get_node_id (), pattern.get_ident ()),\n+      pattern.get_node_id (), pattern.get_locus ());\n     resolver->insert_new_definition (pattern.get_node_id (),\n \t\t\t\t     Definition{pattern.get_node_id (),\n \t\t\t\t\t\tparent});"}, {"sha": "210a9fc047d420429f4f769abd06f8c7851e1f63", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -67,7 +67,8 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::TupleStruct &struct_decl) override\n   {\n-    auto path = CanonicalPath (struct_decl.get_identifier ());\n+    auto path = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_identifier ());\n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -99,7 +100,8 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::StructStruct &struct_decl) override\n   {\n-    auto path = CanonicalPath (struct_decl.get_identifier ());\n+    auto path = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_identifier ());\n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {"}, {"sha": "9abbb18e080fd143f6417570c78530dfc263cd04", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -41,7 +41,9 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::TypeAlias &alias) override\n   {\n-    auto path = prefix.append (CanonicalPath (alias.get_new_type_name ()));\n+    auto path\n+      = prefix.append (CanonicalPath::new_seg (alias.get_node_id (),\n+\t\t\t\t\t       alias.get_new_type_name ()));\n     resolver->get_type_scope ().insert (\n       path, alias.get_node_id (), alias.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -53,7 +55,9 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::TupleStruct &struct_decl) override\n   {\n-    auto path = prefix.append (CanonicalPath (struct_decl.get_identifier ()));\n+    auto path\n+      = prefix.append (CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\t       struct_decl.get_identifier ()));\n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -65,7 +69,9 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::StructStruct &struct_decl) override\n   {\n-    auto path = prefix.append (CanonicalPath (struct_decl.get_identifier ()));\n+    auto path\n+      = prefix.append (CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\t       struct_decl.get_identifier ()));\n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -77,7 +83,8 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::StaticItem &var) override\n   {\n-    auto path = prefix.append (CanonicalPath (var.get_identifier ()));\n+    auto path = prefix.append (\n+      CanonicalPath::new_seg (var.get_node_id (), var.get_identifier ()));\n     resolver->get_name_scope ().insert (\n       path, var.get_node_id (), var.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -160,7 +167,8 @@ class ResolveTopLevel : public ResolverBase\n \t\t\t\t\t     type_resolve_generic_args);\n \n     CanonicalPath projection\n-      = TraitImplProjection::resolve (trait_type_seg, impl_type_seg);\n+      = TraitImplProjection::resolve (impl_block.get_node_id (), trait_type_seg,\n+\t\t\t\t      impl_type_seg);\n     CanonicalPath impl_prefix = prefix.append (projection);\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n@@ -169,8 +177,8 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::Trait &trait) override\n   {\n-    CanonicalPath path\n-      = prefix.append (CanonicalPath (trait.get_identifier ()));\n+    CanonicalPath path = prefix.append (\n+      CanonicalPath::new_seg (trait.get_node_id (), trait.get_identifier ()));\n     resolver->get_type_scope ().insert (\n       path, trait.get_node_id (), trait.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -180,7 +188,7 @@ class ResolveTopLevel : public ResolverBase\n       });\n \n     for (auto &item : trait.get_trait_items ())\n-      ResolveTopLevelTraitItems::go (item.get ());\n+      ResolveTopLevelTraitItems::go (item.get (), path);\n   }\n \n private:"}, {"sha": "23419b024029104afe21758fca911358232dd2cd", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -30,7 +30,8 @@ class ResolveConstantItemToCanonicalPath\n public:\n   static CanonicalPath resolve (AST::ConstantItem &constant)\n   {\n-    return CanonicalPath (constant.get_identifier ());\n+    return CanonicalPath::new_seg (constant.get_node_id (),\n+\t\t\t\t   constant.get_identifier ());\n   }\n };\n \n@@ -39,7 +40,8 @@ class ResolveFunctionItemToCanonicalPath\n public:\n   static CanonicalPath resolve (AST::Function &function)\n   {\n-    return CanonicalPath (function.get_function_name ());\n+    return CanonicalPath::new_seg (function.get_node_id (),\n+\t\t\t\t   function.get_function_name ());\n   }\n };\n \n@@ -48,7 +50,8 @@ class ResolveMethodItemToCanonicalPath\n public:\n   static CanonicalPath resolve (AST::Method &method)\n   {\n-    return CanonicalPath (method.get_method_name ());\n+    return CanonicalPath::new_seg (method.get_node_id (),\n+\t\t\t\t   method.get_method_name ());\n   }\n };\n \n@@ -57,7 +60,8 @@ class ResolveTraitItemFunctionToCanonicalPath\n public:\n   static CanonicalPath resolve (AST::TraitItemFunc &function)\n   {\n-    return CanonicalPath (\n+    return CanonicalPath::new_seg (\n+      function.get_node_id (),\n       function.get_trait_function_decl ().get_identifier ());\n   }\n };\n@@ -67,7 +71,8 @@ class ResolveTraitItemMethodToCanonicalPath\n public:\n   static CanonicalPath resolve (AST::TraitItemMethod &method)\n   {\n-    return CanonicalPath (method.get_trait_method_decl ().get_identifier ());\n+    return CanonicalPath::new_seg (\n+      method.get_node_id (), method.get_trait_method_decl ().get_identifier ());\n   }\n };\n \n@@ -76,7 +81,8 @@ class ResolveTraitItemConstToCanonicalPath\n public:\n   static CanonicalPath resolve (AST::TraitItemConst &constant)\n   {\n-    return CanonicalPath (constant.get_identifier ());\n+    return CanonicalPath::new_seg (constant.get_node_id (),\n+\t\t\t\t   constant.get_identifier ());\n   }\n };\n \n@@ -85,7 +91,7 @@ class ResolveTraitItemTypeToCanonicalPath\n public:\n   static CanonicalPath resolve (AST::TraitItemType &type)\n   {\n-    return CanonicalPath (type.get_identifier ());\n+    return CanonicalPath::new_seg (type.get_node_id (), type.get_identifier ());\n   }\n };\n \n@@ -118,7 +124,7 @@ class ResolveTypeToCanonicalPath : public ResolverBase\n \n   void visit (AST::TypePathSegment &seg) override;\n \n-  static CanonicalPath canonicalize_generic_args (AST::GenericArgs &args);\n+  static std::string canonicalize_generic_args (AST::GenericArgs &args);\n \n   static bool type_resolve_generic_args (AST::GenericArgs &args);\n \n@@ -142,40 +148,40 @@ class ResolvePathSegmentToCanonicalPath\n public:\n   static CanonicalPath resolve (AST::PathExprSegment &seg)\n   {\n-    CanonicalPath path = CanonicalPath (seg.get_ident_segment ().as_string ());\n-    if (seg.has_generic_args ())\n+    if (!seg.has_generic_args ())\n+      return CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t\t     seg.get_ident_segment ().as_string ());\n+\n+    bool ok = ResolveTypeToCanonicalPath::type_resolve_generic_args (\n+      seg.get_generic_args ());\n+    if (!ok)\n       {\n-\tbool ok = ResolveTypeToCanonicalPath::type_resolve_generic_args (\n-\t  seg.get_generic_args ());\n-\tif (!ok)\n-\t  {\n-\t    rust_error_at (seg.get_locus (),\n-\t\t\t   \"failed to resolve all generic arguments\");\n-\t    return CanonicalPath::create_empty ();\n-\t  }\n-\n-\tpath\n-\t  = path.append (ResolveTypeToCanonicalPath::canonicalize_generic_args (\n-\t    seg.get_generic_args ()));\n+\trust_error_at (seg.get_locus (),\n+\t\t       \"failed to resolve all generic arguments\");\n+\treturn CanonicalPath::create_empty ();\n       }\n-    return path;\n+\n+    std::string generics\n+      = ResolveTypeToCanonicalPath::canonicalize_generic_args (\n+\tseg.get_generic_args ());\n+\n+    return CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t\t   seg.get_ident_segment ().as_string ()\n+\t\t\t\t     + \"::\" + generics);\n   }\n };\n \n class TraitImplProjection\n {\n public:\n-  static CanonicalPath resolve (const CanonicalPath &trait_seg,\n+  static CanonicalPath resolve (NodeId id, const CanonicalPath &trait_seg,\n \t\t\t\tconst CanonicalPath &impl_type_seg)\n   {\n-    return CanonicalPath (\"<\" + impl_type_seg.get () + \" as \" + trait_seg.get ()\n-\t\t\t  + \">\");\n+    return CanonicalPath::new_seg (id, \"<\" + impl_type_seg.get () + \" as \"\n+\t\t\t\t\t + trait_seg.get () + \">\");\n   }\n };\n \n-// FIXME: as part of imports and visibility we need to be able to keep a context\n-// for handling PathInExpressions segments as they can be local to a particular\n-// lexical scope requiring a context to be maintained for resolution\n class ResolveRelativeTypePath\n {\n public:\n@@ -189,7 +195,8 @@ class ResolveRelativeTypePath\n \t\t\t\t\t     true);\n     if (canonical_path.is_error ())\n       {\n-\trust_error_at (path.get_locus (), \"Failed to resolve canonical path\");\n+\trust_error_at (path.get_locus (),\n+\t\t       \"Failed to resolve canonical path for TypePath\");\n \treturn UNKNOWN_NODEID;\n       }\n \n@@ -316,8 +323,9 @@ class ResolveGenericParam : public ResolverBase\n \n     // for now lets focus on handling the basics: like struct<T> { a:T, ....}\n     resolver->get_type_scope ().insert (\n-      CanonicalPath (param.get_type_representation ()), param.get_node_id (),\n-      param.get_locus (), false,\n+      CanonicalPath::new_seg (param.get_node_id (),\n+\t\t\t      param.get_type_representation ()),\n+      param.get_node_id (), param.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (param.get_locus (),\n \t\t       \"generic param redefined multiple times\");"}, {"sha": "18047db89180f4ef2556880a1e891cd46424ebb5", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 47, "deletions": 19, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -121,7 +121,9 @@ Resolver::insert_builtin_types (Rib *r)\n   auto builtins = get_builtin_types ();\n   for (auto &builtin : builtins)\n     {\n-      CanonicalPath builtin_path (builtin->as_string ());\n+      CanonicalPath builtin_path\n+\t= CanonicalPath::new_seg (builtin->get_node_id (),\n+\t\t\t\t  builtin->as_string ());\n       r->insert_name (builtin_path, builtin->get_node_id (),\n \t\t      Linemap::predeclared_location (), false,\n \t\t      [] (const CanonicalPath &, NodeId, Location) -> void {});\n@@ -384,7 +386,7 @@ ResolveStructExprField::visit (AST::StructExprFieldIdentifier &field)\n \n // rust-ast-resolve-type.h\n \n-CanonicalPath\n+std::string\n ResolveTypeToCanonicalPath::canonicalize_generic_args (AST::GenericArgs &args)\n {\n   std::string buf;\n@@ -401,7 +403,7 @@ ResolveTypeToCanonicalPath::canonicalize_generic_args (AST::GenericArgs &args)\n       i++;\n     }\n \n-  return CanonicalPath (\"<\" + buf + \">\");\n+  return \"<\" + buf + \">\";\n }\n \n bool\n@@ -428,24 +430,31 @@ ResolveTypeToCanonicalPath::visit (AST::TypePathSegmentGeneric &seg)\n       return;\n     }\n \n-  // ident seg\n-  CanonicalPath ident_seg\n-    = CanonicalPath (seg.get_ident_segment ().as_string ());\n-  result = result.append (ident_seg);\n+  if (!seg.has_generic_args ())\n+    {\n+      result = CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t\t       seg.get_ident_segment ().as_string ());\n+      return;\n+    }\n \n-  // generic args\n-  if (seg.has_generic_args ())\n+  if (type_resolve_generic_args_flag)\n     {\n-      if (include_generic_args_flag)\n-\tresult\n-\t  = result.append (canonicalize_generic_args (seg.get_generic_args ()));\n+      bool ok = type_resolve_generic_args (seg.get_generic_args ());\n+      failure_flag = !ok;\n+    }\n \n-      if (type_resolve_generic_args_flag)\n-\t{\n-\t  bool ok = type_resolve_generic_args (seg.get_generic_args ());\n-\t  failure_flag = !ok;\n-\t}\n+  if (include_generic_args_flag)\n+    {\n+      std::string generics\n+\t= canonicalize_generic_args (seg.get_generic_args ());\n+      result = CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t\t       seg.get_ident_segment ().as_string ()\n+\t\t\t\t\t + \"::\" + generics);\n+      return;\n     }\n+\n+  result = CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t\t   seg.get_ident_segment ().as_string ());\n }\n \n void\n@@ -460,7 +469,8 @@ ResolveTypeToCanonicalPath::visit (AST::TypePathSegment &seg)\n     }\n \n   CanonicalPath ident_seg\n-    = CanonicalPath (seg.get_ident_segment ().as_string ());\n+    = CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t      seg.get_ident_segment ().as_string ());\n   result = result.append (ident_seg);\n }\n \n@@ -474,7 +484,9 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n   AST::PathIdentSegment &root_ident_seg = root_segment.get_ident_segment ();\n \n   bool segment_is_type = false;\n-  CanonicalPath root_seg_path (root_ident_seg.as_string ());\n+  CanonicalPath root_seg_path\n+    = CanonicalPath::new_seg (expr->get_node_id (),\n+\t\t\t      root_ident_seg.as_string ());\n \n   // name scope first\n   if (resolver->get_name_scope ().lookup (root_seg_path, &resolved_node))\n@@ -607,5 +619,21 @@ ResolveType::visit (AST::ArrayType &type)\n   ResolveExpr::go (type.get_size_expr ().get (), type.get_node_id ());\n }\n \n+// rust-ast-resolve-item.h\n+\n+void\n+ResolveItem::resolve_impl_item (AST::TraitImplItem *item,\n+\t\t\t\tconst CanonicalPath &self)\n+{\n+  ResolveImplItems::go (item, self);\n+}\n+\n+void\n+ResolveItem::resolve_impl_item (AST::InherentImplItem *item,\n+\t\t\t\tconst CanonicalPath &self)\n+{\n+  ResolveImplItems::go (item, self);\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "aed01196f810d5cd4d5760bbbefe82fdd3c7ebd5", "filename": "gcc/rust/resolve/rust-ast-verify-assignee.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -57,8 +57,9 @@ class VerifyAsignee : public ResolverBase\n \n   void visit (AST::IdentifierExpr &expr) override\n   {\n-    if (!resolver->get_name_scope ().lookup (CanonicalPath (expr.as_string ()),\n-\t\t\t\t\t     &resolved_node))\n+    if (!resolver->get_name_scope ().lookup (\n+\t  CanonicalPath::new_seg (expr.get_node_id (), expr.as_string ()),\n+\t  &resolved_node))\n       return;\n \n     ok = true;"}, {"sha": "7938c7c83aa163eb264c8df326429c4d7b094c3b", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 60, "deletions": 19, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -47,34 +47,74 @@ namespace Resolver {\n class CanonicalPath\n {\n public:\n-  explicit CanonicalPath (std::string path) : path (path) {}\n-\n-  CanonicalPath (const CanonicalPath &other) : path (other.path) {}\n+  CanonicalPath (const CanonicalPath &other) : segs (other.segs) {}\n \n   CanonicalPath &operator= (const CanonicalPath &other)\n   {\n-    path = other.path;\n+    segs = other.segs;\n     return *this;\n   }\n \n-  std::string get () const { return path; }\n-\n-  static CanonicalPath get_big_self () { return CanonicalPath (\"Self\"); }\n+  static CanonicalPath new_seg (NodeId id, const std::string &path)\n+  {\n+    rust_assert (!path.empty ());\n+    return CanonicalPath ({std::pair<NodeId, std::string> (id, path)});\n+  }\n \n-  static CanonicalPath get_wee_self () { return CanonicalPath (\"self\"); }\n+  std::string get () const\n+  {\n+    std::string buf;\n+    for (size_t i = 0; i < segs.size (); i++)\n+      {\n+\tbool have_more = (i + 1) < segs.size ();\n+\tconst std::string &seg = segs.at (i).second;\n+\tbuf += seg + (have_more ? \"::\" : \"\");\n+      }\n+    return buf;\n+  }\n \n-  static CanonicalPath create_empty ()\n+  static CanonicalPath get_big_self (NodeId id)\n   {\n-    return CanonicalPath (std::string ());\n+    return CanonicalPath::new_seg (id, \"Self\");\n   }\n \n-  bool is_error () const { return path.empty (); }\n+  static CanonicalPath create_empty () { return CanonicalPath ({}); }\n+\n+  bool is_error () const { return segs.size () == 0; }\n \n   CanonicalPath append (const CanonicalPath &other) const\n   {\n     rust_assert (!other.is_error ());\n-    return is_error () ? CanonicalPath (other.get ())\n-\t\t       : CanonicalPath (append (other.get ()));\n+    if (is_error ())\n+      return CanonicalPath (other.segs);\n+\n+    std::vector<std::pair<NodeId, std::string>> copy (segs);\n+    for (auto &s : other.segs)\n+      copy.push_back (s);\n+\n+    return CanonicalPath (copy);\n+  }\n+\n+  // if we have the path A::B::C this will give a callback for each segment\n+  // example:\n+  //   A\n+  //   A::B\n+  //   A::B::C\n+  void iterate (std::function<bool (const CanonicalPath &)> cb) const\n+  {\n+    std::vector<std::pair<NodeId, std::string>> buf;\n+    for (auto &seg : segs)\n+      {\n+\tbuf.push_back (seg);\n+\tif (!cb (CanonicalPath (buf)))\n+\t  return;\n+      }\n+  }\n+\n+  NodeId get_id () const\n+  {\n+    rust_assert (!segs.empty ());\n+    return segs.back ().first;\n   }\n \n   bool operator== (const CanonicalPath &b) const\n@@ -85,9 +125,11 @@ class CanonicalPath\n   bool operator< (const CanonicalPath &b) const { return get () < b.get (); }\n \n private:\n-  std::string append (std::string elem) const { return path + \"::\" + elem; }\n+  explicit CanonicalPath (std::vector<std::pair<NodeId, std::string>> path)\n+    : segs (path)\n+  {}\n \n-  std::string path;\n+  std::vector<std::pair<NodeId, std::string>> segs;\n };\n \n class Rib\n@@ -216,8 +258,8 @@ class Rib\n   NodeId node_id;\n   std::map<CanonicalPath, NodeId> mappings;\n   std::map<NodeId, CanonicalPath> reverse_mappings;\n-  std::set<std::pair<NodeId, Location> > decls_within_rib;\n-  std::map<NodeId, std::set<NodeId> > references;\n+  std::set<std::pair<NodeId, Location>> decls_within_rib;\n+  std::map<NodeId, std::set<NodeId>> references;\n };\n \n class Scope\n@@ -284,7 +326,6 @@ class Scope\n \t{\n \t  ok = true;\n \t  r->append_reference_for_def (defId, refId);\n-\t  return false;\n \t}\n       return true;\n     });\n@@ -455,7 +496,7 @@ class Resolver\n   // map of resolved names mutability flag\n   std::map<NodeId, bool> decl_mutability;\n   // map of resolved names and set of assignments to the decl\n-  std::map<NodeId, std::set<NodeId> > assignment_to_decl;\n+  std::map<NodeId, std::set<NodeId>> assignment_to_decl;\n };\n \n } // namespace Resolver"}, {"sha": "c71dd39868e474d87acae01fe37b681fb45d5068", "filename": "gcc/rust/typecheck/rust-hir-const-fold.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -51,6 +51,8 @@ class ConstFoldType : public TyTy::TyVisitor\n \n   void visit (TyTy::FnType &) override { gcc_unreachable (); }\n \n+  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n+\n   void visit (TyTy::TupleType &type) override\n   {\n     if (type.num_fields () == 0)"}, {"sha": "08793601e56f17ec48f3ac4393d596bb162d8ad8", "filename": "gcc/rust/typecheck/rust-hir-inherent-impl-overlap.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -37,6 +37,12 @@ class ImplItemToName : public TypeCheckBase\n     return resolver.ok;\n   }\n \n+  void visit (HIR::TypeAlias &alias) override\n+  {\n+    ok = true;\n+    result.assign (alias.get_new_type_name ());\n+  }\n+\n   void visit (HIR::Function &function) override\n   {\n     ok = true;\n@@ -145,7 +151,7 @@ class OverlappingImplItemPass : public TypeCheckBase\n \t    if (query == candidate)\n \t      continue;\n \n-\t    if (query->can_eq (candidate))\n+\t    if (query->can_eq (candidate, false))\n \t      possible_collision (it->second, iy->second);\n \t  }\n       }"}, {"sha": "a10a5627bb5962b86d7b4914edaf8c5ee836925c", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -58,13 +58,28 @@ class PathProbeType : public TypeCheckBase\n     bool ok = context->lookup_type (impl_ty_id, &impl_block_ty);\n     rust_assert (ok);\n \n-    if (!receiver->can_eq (impl_block_ty))\n+    if (!receiver->can_eq (impl_block_ty, false))\n       return;\n \n     // lets visit the impl_item\n     item->accept_vis (*this);\n   }\n \n+  void visit (HIR::TypeAlias &alias) override\n+  {\n+    Identifier name = alias.get_new_type_name ();\n+    if (search.as_string ().compare (name) == 0)\n+      {\n+\tHirId tyid = alias.get_mappings ().get_hirid ();\n+\tTyTy::BaseType *ty = nullptr;\n+\tbool ok = context->lookup_type (tyid, &ty);\n+\trust_assert (ok);\n+\n+\tPathProbeCandidate candidate{&alias, ty};\n+\tcandidates.push_back (std::move (candidate));\n+      }\n+  }\n+\n   void visit (HIR::ConstantItem &constant) override\n   {\n     Identifier name = constant.get_identifier ();\n@@ -122,6 +137,11 @@ class ReportMultipleCandidateError : private TypeCheckBase\n \t\t   query.as_string ().c_str ());\n   }\n \n+  void visit (HIR::TypeAlias &alias) override\n+  {\n+    r.add_range (alias.get_locus ());\n+  }\n+\n   void visit (HIR::ConstantItem &constant) override\n   {\n     r.add_range (constant.get_locus ());"}, {"sha": "1b83be3741900b08e74bfdcda72815e7589389b3", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -44,8 +44,9 @@ class ResolveTraitItemToRef : public TypeCheckBase\n \n   void visit (HIR::TraitItemType &type) override\n   {\n-    // associated types are not typed and only support bounds\n-    TyTy::BaseType *ty = nullptr;\n+    TyTy::BaseType *ty\n+      = new TyTy::PlaceholderType (type.get_mappings ().get_hirid ());\n+    context->insert_type (type.get_mappings (), ty);\n \n     // create trait-item-ref\n     Location locus = type.get_locus ();"}, {"sha": "dd10d421fab051b3035357b70a85f018ed136a38", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -275,7 +275,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t    // always be at the end of the list\n \n \t    auto s = fn->get_self_type ();\n-\t    rust_assert (s->can_eq (adt));\n+\t    rust_assert (s->can_eq (adt, false));\n \t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n \t    TyTy::ADTType *self_adt = static_cast<TyTy::ADTType *> (s);\n "}, {"sha": "b0264e504577bad0753b6628cc049b0cb4dc13d2", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 87, "deletions": 3, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -41,6 +41,14 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n     item->accept_vis (resolver);\n   }\n \n+  void visit (HIR::TypeAlias &alias) override\n+  {\n+    TyTy::BaseType *actual_type\n+      = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n+\n+    context->insert_type (alias.get_mappings (), actual_type);\n+  }\n+\n   void visit (HIR::ConstantItem &constant) override\n   {\n     TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n@@ -204,9 +212,85 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n     return resolver.resolved_trait_item;\n   }\n \n-  void visit (HIR::ConstantItem &constant) override { gcc_unreachable (); }\n+  void visit (HIR::ConstantItem &constant) override\n+  {\n+    TypeCheckImplItem::visit (constant);\n+\n+    // we get the error checking from the base method here\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (constant.get_mappings ().get_hirid (), &lookup))\n+      return;\n+\n+    const TraitItemReference &trait_item_ref\n+      = trait_reference.lookup_trait_item (\n+\tconstant.get_identifier (), TraitItemReference::TraitItemType::CONST);\n \n-  void visit (HIR::TypeAlias &type) override { gcc_unreachable (); }\n+    // unknown trait item\n+    if (trait_item_ref.is_error ())\n+      {\n+\tRichLocation r (constant.get_locus ());\n+\tr.add_range (trait_reference.get_locus ());\n+\trust_error_at (r, \"constant %<%s%> is not a member of trait %<%s%>\",\n+\t\t       constant.get_identifier ().c_str (),\n+\t\t       trait_reference.get_name ().c_str ());\n+\treturn;\n+      }\n+\n+    // check the types are compatible\n+    if (!trait_item_ref.get_tyty ()->can_eq (lookup, true))\n+      {\n+\tRichLocation r (constant.get_locus ());\n+\tr.add_range (trait_item_ref.get_locus ());\n+\n+\trust_error_at (\n+\t  r, \"constant %<%s%> has an incompatible type for trait %<%s%>\",\n+\t  constant.get_identifier ().c_str (),\n+\t  trait_reference.get_name ().c_str ());\n+\treturn;\n+      }\n+\n+    resolved_trait_item = trait_item_ref;\n+  }\n+\n+  void visit (HIR::TypeAlias &type) override\n+  {\n+    TypeCheckImplItem::visit (type);\n+\n+    // we get the error checking from the base method here\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n+      return;\n+\n+    const TraitItemReference &trait_item_ref\n+      = trait_reference.lookup_trait_item (\n+\ttype.get_new_type_name (), TraitItemReference::TraitItemType::TYPE);\n+\n+    // unknown trait item\n+    if (trait_item_ref.is_error ())\n+      {\n+\tRichLocation r (type.get_locus ());\n+\tr.add_range (trait_reference.get_locus ());\n+\trust_error_at (r, \"type alias %<%s%> is not a member of trait %<%s%>\",\n+\t\t       type.get_new_type_name ().c_str (),\n+\t\t       trait_reference.get_name ().c_str ());\n+\treturn;\n+      }\n+\n+    // check the types are compatible\n+    if (!trait_item_ref.get_tyty ()->can_eq (lookup, true))\n+      {\n+\tRichLocation r (type.get_locus ());\n+\tr.add_range (trait_item_ref.get_locus ());\n+\n+\trust_error_at (\n+\t  r, \"type alias %<%s%> has an incompatible type for trait %<%s%>\",\n+\t  type.get_new_type_name ().c_str (),\n+\t  trait_reference.get_name ().c_str ());\n+\treturn;\n+      }\n+\n+    resolved_trait_item = trait_item_ref;\n+  }\n \n   void visit (HIR::Function &function) override\n   {\n@@ -263,7 +347,7 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n       = trait_item_fntype->handle_substitions (implicit_self_substs);\n \n     // check the types are compatible\n-    if (!trait_item_fntype->can_eq (fntype))\n+    if (!trait_item_fntype->can_eq (fntype, true))\n       {\n \tRichLocation r (function.get_locus ());\n \tr.add_range (trait_item_ref.get_locus ());"}, {"sha": "e9a3bdeda38817d2303ea8cf4601630c952e4cad", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -1,3 +1,4 @@\n+\n // Copyright (C) 2020 Free Software Foundation, Inc.\n \n // This file is part of GCC.\n@@ -22,6 +23,7 @@\n #include \"rust-hir-type-check-base.h\"\n #include \"rust-hir-full.h\"\n #include \"rust-substitution-mapper.h\"\n+#include \"rust-hir-path-probe.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -145,7 +147,7 @@ class TypeCheckType : public TypeCheckBase\n     TyTy::BaseType *path_type = lookup->clone ();\n     path_type->set_ref (path.get_mappings ().get_hirid ());\n \n-    HIR::TypePathSegment *final_seg = path.get_final_segment ();\n+    HIR::TypePathSegment *final_seg = path.get_final_segment ().get ();\n     HIR::GenericArgs args\n       = TypeCheckResolveGenericArguments::resolve (final_seg);\n "}, {"sha": "9741dfac3e836ec470092eb66bf476820964a7f7", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -106,6 +106,7 @@ class SubstMapper : public TyTy::TyVisitor\n   void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n   void visit (TyTy::StrType &) override { gcc_unreachable (); }\n   void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n+  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n \n private:\n   SubstMapper (HirId ref, HIR::GenericArgs *generics, Location locus)\n@@ -183,6 +184,7 @@ class SubstMapperInternal : public TyTy::TyVisitor\n   void visit (TyTy::CharType &) override { gcc_unreachable (); }\n   void visit (TyTy::StrType &) override { gcc_unreachable (); }\n   void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n+  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n \n private:\n   SubstMapperInternal (HirId ref, TyTy::SubstitutionArgumentMappings &mappings)\n@@ -238,6 +240,7 @@ class SubstMapperFromExisting : public TyTy::TyVisitor\n   void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n   void visit (TyTy::StrType &) override { gcc_unreachable (); }\n   void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n+  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n \n private:\n   SubstMapperFromExisting (TyTy::BaseType *concrete, TyTy::BaseType *receiver)\n@@ -286,6 +289,7 @@ class GetUsedSubstArgs : public TyTy::TyVisitor\n   void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n   void visit (TyTy::StrType &) override { gcc_unreachable (); }\n   void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n+  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n \n private:\n   GetUsedSubstArgs () : args (TyTy::SubstitutionArgumentMappings::error ()) {}"}, {"sha": "f6121ca9bca4d505bdf7a71d17e79a9400ff0d62", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -54,6 +54,7 @@ class TypeCheckCallExpr : private TyVisitor\n   void visit (ParamType &) override { gcc_unreachable (); }\n   void visit (StrType &) override { gcc_unreachable (); }\n   void visit (NeverType &) override { gcc_unreachable (); }\n+  void visit (PlaceholderType &) override { gcc_unreachable (); }\n \n   // tuple-structs\n   void visit (ADTType &type) override;\n@@ -102,6 +103,7 @@ class TypeCheckMethodCallExpr : private TyVisitor\n   void visit (ParamType &) override { gcc_unreachable (); }\n   void visit (StrType &) override { gcc_unreachable (); }\n   void visit (NeverType &) override { gcc_unreachable (); }\n+  void visit (PlaceholderType &) override { gcc_unreachable (); }\n \n   // FIXME\n   void visit (FnPtr &type) override { gcc_unreachable (); }"}, {"sha": "f01ef3b0d19eb2e2d33fd42cb87191ede1bf7d2d", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 393, "deletions": 67, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -46,56 +46,303 @@ class BaseCmp : public TyVisitor\n     return ok;\n   }\n \n-  virtual void visit (TupleType &) override { ok = false; }\n+  virtual void visit (TupleType &type) override\n+  {\n+    ok = false;\n+\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n \n-  virtual void visit (ADTType &) override { ok = false; }\n+  virtual void visit (ADTType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n \n-  virtual void visit (InferType &) override { ok = false; }\n+  virtual void visit (InferType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (FnType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n \n-  virtual void visit (FnType &) override { ok = false; }\n+  virtual void visit (FnPtr &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n \n-  virtual void visit (FnPtr &) override { ok = false; }\n+  virtual void visit (ArrayType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n \n-  virtual void visit (ArrayType &) override { ok = false; }\n+  virtual void visit (BoolType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n \n-  virtual void visit (BoolType &) override { ok = false; }\n+  virtual void visit (IntType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n \n-  virtual void visit (IntType &) override { ok = false; }\n+  virtual void visit (UintType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n \n-  virtual void visit (UintType &) override { ok = false; }\n+  virtual void visit (USizeType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n \n-  virtual void visit (USizeType &) override { ok = false; }\n+  virtual void visit (ISizeType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n \n-  virtual void visit (ISizeType &) override { ok = false; }\n+  virtual void visit (FloatType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n \n-  virtual void visit (FloatType &) override { ok = false; }\n+  virtual void visit (ErrorType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n \n-  virtual void visit (ErrorType &) override { ok = false; }\n+  virtual void visit (CharType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n \n-  virtual void visit (CharType &) override { ok = false; }\n+  virtual void visit (ReferenceType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n \n-  virtual void visit (ReferenceType &) override { ok = false; }\n+  virtual void visit (StrType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n \n-  virtual void visit (ParamType &) override\n+  virtual void visit (NeverType &type) override\n   {\n-    // it is ok for types to can eq to a ParamType\n-    ok = true;\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n   }\n \n-  virtual void visit (StrType &) override { ok = false; }\n+  virtual void visit (PlaceholderType &type) override\n+  {\n+    // it is ok for types to can eq to a placeholder\n+    ok = true;\n+  }\n \n-  virtual void visit (NeverType &) override { ok = false; }\n+  virtual void visit (ParamType &type) override\n+  {\n+    // it is ok for types to can eq to a ParamType\n+    ok = true;\n+  }\n \n protected:\n-  BaseCmp (BaseType *base)\n+  BaseCmp (BaseType *base, bool emit_errors)\n     : mappings (Analysis::Mappings::get ()),\n-      context (Resolver::TypeCheckContext::get ()), ok (false)\n+      context (Resolver::TypeCheckContext::get ()), ok (false),\n+      emit_error_flag (emit_errors)\n   {}\n \n   Analysis::Mappings *mappings;\n   Resolver::TypeCheckContext *context;\n \n   bool ok;\n+  bool emit_error_flag;\n \n private:\n   /* Returns a pointer to the ty that created this rule. */\n@@ -107,7 +354,9 @@ class InferCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  InferCmp (InferType *base) : BaseCmp (base), base (base) {}\n+  InferCmp (InferType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (BoolType &type) override\n   {\n@@ -328,7 +577,9 @@ class FnCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  FnCmp (FnType *base) : BaseCmp (base), base (base) {}\n+  FnCmp (FnType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (InferType &type) override\n   {\n@@ -348,18 +599,18 @@ class FnCmp : public BaseCmp\n \tauto a = base->param_at (i).second;\n \tauto b = type.param_at (i).second;\n \n-\tauto unified_param = a->unify (b);\n-\tif (unified_param->get_kind () == TypeKind::ERROR)\n+\tif (!a->can_eq (b, emit_error_flag))\n \t  {\n+\t    emit_error_flag = false;\n \t    BaseCmp::visit (type);\n \t    return;\n \t  }\n       }\n \n-    auto unified_return\n-      = base->get_return_type ()->unify (type.get_return_type ());\n-    if (unified_return->get_kind () == TypeKind::ERROR)\n+    if (!base->get_return_type ()->can_eq (type.get_return_type (),\n+\t\t\t\t\t   emit_error_flag))\n       {\n+\temit_error_flag = false;\n \tBaseCmp::visit (type);\n \treturn;\n       }\n@@ -378,7 +629,9 @@ class FnptrCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  FnptrCmp (FnPtr *base) : BaseCmp (base), base (base) {}\n+  FnptrCmp (FnPtr *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (InferType &type) override\n   {\n@@ -393,17 +646,15 @@ class FnptrCmp : public BaseCmp\n \n   void visit (FnPtr &type) override\n   {\n-    auto this_ret_type = base->get_return_type ();\n-    auto other_ret_type = type.get_return_type ();\n-    auto unified_result = this_ret_type->unify (other_ret_type);\n-    if (unified_result == nullptr\n-\t|| unified_result->get_kind () == TypeKind::ERROR)\n+    if (base->num_params () != type.num_params ())\n       {\n \tBaseCmp::visit (type);\n \treturn;\n       }\n \n-    if (base->num_params () != type.num_params ())\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    if (!this_ret_type->can_eq (other_ret_type, emit_error_flag))\n       {\n \tBaseCmp::visit (type);\n \treturn;\n@@ -413,9 +664,7 @@ class FnptrCmp : public BaseCmp\n       {\n \tauto this_param = base->param_at (i);\n \tauto other_param = type.param_at (i);\n-\tauto unified_param = this_param->unify (other_param);\n-\tif (unified_param == nullptr\n-\t    || unified_param->get_kind () == TypeKind::ERROR)\n+\tif (!this_param->can_eq (other_param, emit_error_flag))\n \t  {\n \t    BaseCmp::visit (type);\n \t    return;\n@@ -427,17 +676,15 @@ class FnptrCmp : public BaseCmp\n \n   void visit (FnType &type) override\n   {\n-    auto this_ret_type = base->get_return_type ();\n-    auto other_ret_type = type.get_return_type ();\n-    auto unified_result = this_ret_type->unify (other_ret_type);\n-    if (unified_result == nullptr\n-\t|| unified_result->get_kind () == TypeKind::ERROR)\n+    if (base->num_params () != type.num_params ())\n       {\n \tBaseCmp::visit (type);\n \treturn;\n       }\n \n-    if (base->num_params () != type.num_params ())\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    if (!this_ret_type->can_eq (other_ret_type, emit_error_flag))\n       {\n \tBaseCmp::visit (type);\n \treturn;\n@@ -447,9 +694,7 @@ class FnptrCmp : public BaseCmp\n       {\n \tauto this_param = base->param_at (i);\n \tauto other_param = type.param_at (i).second;\n-\tauto unified_param = this_param->unify (other_param);\n-\tif (unified_param == nullptr\n-\t    || unified_param->get_kind () == TypeKind::ERROR)\n+\tif (!this_param->can_eq (other_param, emit_error_flag))\n \t  {\n \t    BaseCmp::visit (type);\n \t    return;\n@@ -470,7 +715,9 @@ class ArrayCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ArrayCmp (ArrayType *base) : BaseCmp (base), base (base) {}\n+  ArrayCmp (ArrayType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (ArrayType &type) override\n   {\n@@ -506,7 +753,9 @@ class BoolCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  BoolCmp (BoolType *base) : BaseCmp (base), base (base) {}\n+  BoolCmp (BoolType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (BoolType &type) override { ok = true; }\n \n@@ -526,7 +775,9 @@ class IntCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  IntCmp (IntType *base) : BaseCmp (base), base (base) {}\n+  IntCmp (IntType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (InferType &type) override\n   {\n@@ -549,7 +800,9 @@ class UintCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  UintCmp (UintType *base) : BaseCmp (base), base (base) {}\n+  UintCmp (UintType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (InferType &type) override\n   {\n@@ -572,7 +825,9 @@ class FloatCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  FloatCmp (FloatType *base) : BaseCmp (base), base (base) {}\n+  FloatCmp (FloatType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (InferType &type) override\n   {\n@@ -595,7 +850,9 @@ class ADTCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ADTCmp (ADTType *base) : BaseCmp (base), base (base) {}\n+  ADTCmp (ADTType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (ADTType &type) override\n   {\n@@ -619,7 +876,7 @@ class ADTCmp : public BaseCmp\n \tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n \tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n \n-\tif (!this_field_ty->can_eq (other_field_ty))\n+\tif (!this_field_ty->can_eq (other_field_ty, emit_error_flag))\n \t  {\n \t    BaseCmp::visit (type);\n \t    return;\n@@ -640,7 +897,9 @@ class TupleCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  TupleCmp (TupleType *base) : BaseCmp (base), base (base) {}\n+  TupleCmp (TupleType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (TupleType &type) override\n   {\n@@ -655,7 +914,7 @@ class TupleCmp : public BaseCmp\n \tBaseType *bo = base->get_field (i);\n \tBaseType *fo = type.get_field (i);\n \n-\tif (!bo->can_eq (fo))\n+\tif (!bo->can_eq (fo, emit_error_flag))\n \t  {\n \t    BaseCmp::visit (type);\n \t    return;\n@@ -676,7 +935,9 @@ class USizeCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  USizeCmp (USizeType *base) : BaseCmp (base), base (base) {}\n+  USizeCmp (USizeType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (InferType &type) override\n   {\n@@ -696,7 +957,9 @@ class ISizeCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ISizeCmp (ISizeType *base) : BaseCmp (base), base (base) {}\n+  ISizeCmp (ISizeType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (InferType &type) override\n   {\n@@ -716,7 +979,9 @@ class CharCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  CharCmp (CharType *base) : BaseCmp (base), base (base) {}\n+  CharCmp (CharType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (InferType &type) override\n   {\n@@ -736,14 +1001,16 @@ class ReferenceCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ReferenceCmp (ReferenceType *base) : BaseCmp (base), base (base) {}\n+  ReferenceCmp (ReferenceType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (ReferenceType &type) override\n   {\n     auto base_type = base->get_base ();\n     auto other_base_type = type.get_base ();\n \n-    ok = base_type->can_eq (other_base_type);\n+    ok = base_type->can_eq (other_base_type, emit_error_flag);\n   }\n \n private:\n@@ -757,7 +1024,9 @@ class ParamCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ParamCmp (ParamType *base) : BaseCmp (base), base (base) {}\n+  ParamCmp (ParamType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   // param types are a placeholder we shouldn't have cases where we unify\n   // against it. eg: struct foo<T> { a: T }; When we invoke it we can do either:\n@@ -781,10 +1050,10 @@ class ParamCmp : public BaseCmp\n     if (lookup->get_kind () == TypeKind::PARAM)\n       {\n \tInferType infer (UNKNOWN_HIRID, InferType::InferTypeKind::GENERAL);\n-\treturn infer.can_eq (other);\n+\treturn infer.can_eq (other, emit_error_flag);\n       }\n \n-    return lookup->can_eq (other);\n+    return lookup->can_eq (other, emit_error_flag);\n   }\n \n   // imagine the case where we have:\n@@ -807,7 +1076,9 @@ class StrCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  StrCmp (StrType *base) : BaseCmp (base), base (base) {}\n+  StrCmp (StrType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (StrType &type) override { ok = true; }\n \n@@ -822,7 +1093,9 @@ class NeverCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  NeverCmp (NeverType *base) : BaseCmp (base), base (base) {}\n+  NeverCmp (NeverType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n \n   void visit (NeverType &type) override { ok = true; }\n \n@@ -832,6 +1105,59 @@ class NeverCmp : public BaseCmp\n   NeverType *base;\n };\n \n+class PlaceholderCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  PlaceholderCmp (PlaceholderType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  virtual void visit (TupleType &) override { ok = true; }\n+\n+  virtual void visit (ADTType &) override { ok = true; }\n+\n+  virtual void visit (InferType &) override { ok = true; }\n+\n+  virtual void visit (FnType &) override { ok = true; }\n+\n+  virtual void visit (FnPtr &) override { ok = true; }\n+\n+  virtual void visit (ArrayType &) override { ok = true; }\n+\n+  virtual void visit (BoolType &) override { ok = true; }\n+\n+  virtual void visit (IntType &) override { ok = true; }\n+\n+  virtual void visit (UintType &) override { ok = true; }\n+\n+  virtual void visit (USizeType &) override { ok = true; }\n+\n+  virtual void visit (ISizeType &) override { ok = true; }\n+\n+  virtual void visit (FloatType &) override { ok = true; }\n+\n+  virtual void visit (ErrorType &) override { ok = true; }\n+\n+  virtual void visit (CharType &) override { ok = true; }\n+\n+  virtual void visit (ReferenceType &) override { ok = true; }\n+\n+  virtual void visit (ParamType &) override { ok = true; }\n+\n+  virtual void visit (StrType &) override { ok = true; }\n+\n+  virtual void visit (NeverType &) override { ok = true; }\n+\n+  virtual void visit (PlaceholderType &) override { ok = true; }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  PlaceholderType *base;\n+};\n+\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "5db005b51898f0fc62bb81bfdbde402f856f2c10", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -299,7 +299,21 @@ class BaseRules : public TyVisitor\n   virtual void visit (NeverType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (PlaceholderType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n \t\t   get_base ()->as_string ().c_str (),\n \t\t   type.as_string ().c_str ());\n   }\n@@ -1165,6 +1179,19 @@ class NeverRules : public BaseRules\n   NeverType *base;\n };\n \n+class PlaceholderRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  PlaceholderRules (PlaceholderType *base) : BaseRules (base), base (base) {}\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  PlaceholderType *base;\n+};\n+\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "2bac5fe4d712dc758c0bbdf49b2ee8a2524957b7", "filename": "gcc/rust/typecheck/rust-tyty-visitor.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -45,6 +45,7 @@ class TyVisitor\n   virtual void visit (ParamType &type) = 0;\n   virtual void visit (StrType &type) = 0;\n   virtual void visit (NeverType &type) = 0;\n+  virtual void visit (PlaceholderType &type) = 0;\n };\n \n } // namespace TyTy"}, {"sha": "ba98212486cbb21c024ae3126196ebf519e9a386", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 68, "deletions": 36, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -98,9 +98,9 @@ InferType::unify (BaseType *other)\n }\n \n bool\n-InferType::can_eq (BaseType *other)\n+InferType::can_eq (BaseType *other, bool emit_errors)\n {\n-  InferCmp r (this);\n+  InferCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -155,7 +155,7 @@ ErrorType::unify (BaseType *other)\n }\n \n bool\n-ErrorType::can_eq (BaseType *other)\n+ErrorType::can_eq (BaseType *other, bool emit_errors)\n {\n   return get_kind () == other->get_kind ();\n }\n@@ -421,9 +421,9 @@ ADTType::unify (BaseType *other)\n }\n \n bool\n-ADTType::can_eq (BaseType *other)\n+ADTType::can_eq (BaseType *other, bool emit_errors)\n {\n-  ADTCmp r (this);\n+  ADTCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -582,9 +582,9 @@ TupleType::unify (BaseType *other)\n }\n \n bool\n-TupleType::can_eq (BaseType *other)\n+TupleType::can_eq (BaseType *other, bool emit_errors)\n {\n-  TupleCmp r (this);\n+  TupleCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -666,9 +666,9 @@ FnType::unify (BaseType *other)\n }\n \n bool\n-FnType::can_eq (BaseType *other)\n+FnType::can_eq (BaseType *other, bool emit_errors)\n {\n-  FnCmp r (this);\n+  FnCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -861,9 +861,9 @@ FnPtr::unify (BaseType *other)\n }\n \n bool\n-FnPtr::can_eq (BaseType *other)\n+FnPtr::can_eq (BaseType *other, bool emit_errors)\n {\n-  FnptrCmp r (this);\n+  FnptrCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -928,9 +928,9 @@ ArrayType::unify (BaseType *other)\n }\n \n bool\n-ArrayType::can_eq (BaseType *other)\n+ArrayType::can_eq (BaseType *other, bool emit_errors)\n {\n-  ArrayCmp r (this);\n+  ArrayCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -983,9 +983,9 @@ BoolType::unify (BaseType *other)\n }\n \n bool\n-BoolType::can_eq (BaseType *other)\n+BoolType::can_eq (BaseType *other, bool emit_errors)\n {\n-  BoolCmp r (this);\n+  BoolCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1029,9 +1029,9 @@ IntType::unify (BaseType *other)\n }\n \n bool\n-IntType::can_eq (BaseType *other)\n+IntType::can_eq (BaseType *other, bool emit_errors)\n {\n-  IntCmp r (this);\n+  IntCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1086,9 +1086,9 @@ UintType::unify (BaseType *other)\n }\n \n bool\n-UintType::can_eq (BaseType *other)\n+UintType::can_eq (BaseType *other, bool emit_errors)\n {\n-  UintCmp r (this);\n+  UintCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1137,9 +1137,9 @@ FloatType::unify (BaseType *other)\n }\n \n bool\n-FloatType::can_eq (BaseType *other)\n+FloatType::can_eq (BaseType *other, bool emit_errors)\n {\n-  FloatCmp r (this);\n+  FloatCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1180,9 +1180,9 @@ USizeType::unify (BaseType *other)\n }\n \n bool\n-USizeType::can_eq (BaseType *other)\n+USizeType::can_eq (BaseType *other, bool emit_errors)\n {\n-  USizeCmp r (this);\n+  USizeCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1212,9 +1212,9 @@ ISizeType::unify (BaseType *other)\n }\n \n bool\n-ISizeType::can_eq (BaseType *other)\n+ISizeType::can_eq (BaseType *other, bool emit_errors)\n {\n-  ISizeCmp r (this);\n+  ISizeCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1244,9 +1244,9 @@ CharType::unify (BaseType *other)\n }\n \n bool\n-CharType::can_eq (BaseType *other)\n+CharType::can_eq (BaseType *other, bool emit_errors)\n {\n-  CharCmp r (this);\n+  CharCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1276,9 +1276,9 @@ ReferenceType::unify (BaseType *other)\n }\n \n bool\n-ReferenceType::can_eq (BaseType *other)\n+ReferenceType::can_eq (BaseType *other, bool emit_errors)\n {\n-  ReferenceCmp r (this);\n+  ReferenceCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1351,9 +1351,9 @@ ParamType::unify (BaseType *other)\n }\n \n bool\n-ParamType::can_eq (BaseType *other)\n+ParamType::can_eq (BaseType *other, bool emit_errors)\n {\n-  ParamCmp r (this);\n+  ParamCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1407,7 +1407,7 @@ ParamType::is_equal (const BaseType &other) const\n     return false;\n \n   if (can_resolve ())\n-    return resolve ()->can_eq (other2.resolve ());\n+    return resolve ()->can_eq (other2.resolve (), false);\n \n   return get_symbol ().compare (other2.get_symbol ()) == 0;\n }\n@@ -1451,9 +1451,9 @@ StrType::unify (BaseType *other)\n }\n \n bool\n-StrType::can_eq (BaseType *other)\n+StrType::can_eq (BaseType *other, bool emit_errors)\n {\n-  StrCmp r (this);\n+  StrCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1483,9 +1483,9 @@ NeverType::unify (BaseType *other)\n }\n \n bool\n-NeverType::can_eq (BaseType *other)\n+NeverType::can_eq (BaseType *other, bool emit_errors)\n {\n-  NeverCmp r (this);\n+  NeverCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1495,6 +1495,38 @@ NeverType::clone ()\n   return new NeverType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n \n+void\n+PlaceholderType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+PlaceholderType::as_string () const\n+{\n+  return \"<placeholder>\";\n+}\n+\n+BaseType *\n+PlaceholderType::unify (BaseType *other)\n+{\n+  PlaceholderRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+PlaceholderType::can_eq (BaseType *other, bool emit_errors)\n+{\n+  PlaceholderCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+BaseType *\n+PlaceholderType::clone ()\n+{\n+  return new PlaceholderType (get_ref (), get_ty_ref (), get_combined_refs ());\n+}\n+\n // rust-tyty-call.h\n \n void"}, {"sha": "d85b8a8efa63314218203bb7f3e1d5452382c4bc", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 51, "deletions": 19, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -48,6 +48,7 @@ enum TypeKind\n   USIZE,\n   ISIZE,\n   NEVER,\n+  PLACEHOLDER,\n   // there are more to add...\n   ERROR\n };\n@@ -110,6 +111,9 @@ class TypeKindFormat\n       case TypeKind::NEVER:\n \treturn \"Never\";\n \n+      case TypeKind::PLACEHOLDER:\n+\treturn \"Placeholder\";\n+\n       case TypeKind::ERROR:\n \treturn \"ERROR\";\n       }\n@@ -151,7 +155,7 @@ class BaseType\n \n   // similar to unify but does not actually perform type unification but\n   // determines whether they are compatible\n-  virtual bool can_eq (BaseType *other) = 0;\n+  virtual bool can_eq (BaseType *other, bool emit_errors) = 0;\n \n   // Check value equality between two ty. Type inference rules are ignored. Two\n   //   ty are considered equal if they're of the same kind, and\n@@ -270,7 +274,7 @@ class InferType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n \n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   BaseType *clone () final override;\n \n@@ -304,7 +308,7 @@ class ErrorType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   BaseType *clone () final override;\n \n@@ -332,7 +336,7 @@ class ParamType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   BaseType *clone () final override;\n \n@@ -417,7 +421,7 @@ class TupleType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -849,7 +853,7 @@ class ADTType : public BaseType, public SubstitutionRef\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -956,7 +960,7 @@ class FnType : public BaseType, public SubstitutionRef\n   std::string get_identifier () const { return identifier; }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1052,7 +1056,7 @@ class FnPtr : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1094,7 +1098,7 @@ class ArrayType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1133,7 +1137,7 @@ class BoolType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   BaseType *clone () final override;\n };\n@@ -1166,7 +1170,7 @@ class IntType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   IntKind get_int_kind () const { return int_kind; }\n \n@@ -1206,7 +1210,7 @@ class UintType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   UintKind get_uint_kind () const { return uint_kind; }\n \n@@ -1244,7 +1248,7 @@ class FloatType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   FloatKind get_float_kind () const { return float_kind; }\n \n@@ -1284,7 +1288,7 @@ class USizeType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   BaseType *clone () final override;\n };\n@@ -1317,7 +1321,7 @@ class ISizeType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   BaseType *clone () final override;\n };\n@@ -1350,7 +1354,7 @@ class CharType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   BaseType *clone () final override;\n };\n@@ -1387,7 +1391,7 @@ class ReferenceType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1432,7 +1436,7 @@ class StrType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1465,7 +1469,35 @@ class NeverType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n+\n+  BaseType *clone () final override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  bool is_unit () const override { return true; }\n+};\n+\n+// used at the type in associated types in traits\n+// see: https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+class PlaceholderType : public BaseType\n+{\n+public:\n+  PlaceholderType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::PLACEHOLDER, refs)\n+  {}\n+\n+  PlaceholderType (HirId ref, HirId ty_ref,\n+\t\t   std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::PLACEHOLDER, refs)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other, bool emit_errors) override;\n \n   BaseType *clone () final override;\n "}, {"sha": "2ab74e1e1819b215a8a56ce145ecdc8f20c3fc16", "filename": "gcc/testsuite/rust/compile/torture/traits3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits3.rs?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -1,7 +1,7 @@\n pub trait Foo {\n     fn Bar(self) -> i32;\n     // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n-    // { dg-warning \"unused name .Bar.\" \"\" { target *-*-* } .-2 }\n+    // { dg-warning \"unused name .Foo::Bar.\" \"\" { target *-*-* } .-2 }\n }\n \n struct Baz;"}, {"sha": "1db5f32fed38fce9d1b8f557abf546dbe9783ca1", "filename": "gcc/testsuite/rust/compile/torture/traits4.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits4.rs?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -0,0 +1,26 @@\n+trait Foo {\n+    type A;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+    type B;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn new(a: Self::A, b: Self::B) -> Self;\n+    // { dg-warning \"unused name .a.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .b.\" \"\" { target *-*-* } .-2 }\n+    // { dg-warning \"unused name .Foo::new.\" \"\" { target *-*-* } .-3 }\n+}\n+\n+struct Baz(i32, f32);\n+\n+impl Foo for Baz {\n+    type A = i32;\n+    type B = f32;\n+\n+    fn new(a: Self::A, b: Self::B) -> Self {\n+        Baz(a, b)\n+    }\n+}\n+\n+fn main() {\n+    Baz::new(123, 456f32);\n+}"}, {"sha": "87c02831f134c7533feffa3d6259f9672516eb5f", "filename": "gcc/testsuite/rust/compile/torture/traits5.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4560f469ee33536cec6af0f8e5816ff97de60de0/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits5.rs?ref=4560f469ee33536cec6af0f8e5816ff97de60de0", "patch": "@@ -0,0 +1,26 @@\n+trait Foo {\n+    type A;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+    type B;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn new(a: Self::A, b: Self::B) -> Self;\n+    // { dg-warning \"unused name .a.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .b.\" \"\" { target *-*-* } .-2 }\n+    // { dg-warning \"unused name .Foo::new.\" \"\" { target *-*-* } .-3 }\n+}\n+\n+struct Baz(i32, f32);\n+\n+impl Foo for Baz {\n+    type A = i32;\n+    type B = f32;\n+\n+    fn new(a: i32, b: f32) -> Self {\n+        Baz(a, b)\n+    }\n+}\n+\n+fn main() {\n+    Baz::new(123, 456f32);\n+}"}]}