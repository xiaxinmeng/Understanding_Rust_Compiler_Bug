{"sha": "a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA3YzQwNTRjMmU3ZjUwOGE5Yzc0ZWI2ZDVhYmRiMTZiNWI3NjQ4Yw==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2012-12-03T22:06:41Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2012-12-03T22:06:41Z"}, "message": "re PR fortran/55548 (SYSTEM_CLOCK with integer(8) provides nanosecond resolution, but only microsecond precision (without -lrt))\n\n2012-12-03  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/55548\n\t* intrinsics/system_clock.c (gf_gettime_mono): Add argument 'tck',\n\twhich returns the clock resolution.\n\t(system_clock_4): Get resolution from gf_gettime_mono, but limit to\n\t1000/s.\n\t(system_clock_8): Get resolution from gf_gettime_mono.\n\n2012-12-03  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/55548\n\t* intrinsic.texi (SYSTEM_CLOCK): Update documentation of SYSTEM_CLOCK.\n\nFrom-SVN: r194105", "tree": {"sha": "8dc0c5e4e2960946445f05352b2e3c0644e44266", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8dc0c5e4e2960946445f05352b2e3c0644e44266"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86035eeca65c54f7325fb6edd5839e3b59ad5002", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86035eeca65c54f7325fb6edd5839e3b59ad5002", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86035eeca65c54f7325fb6edd5839e3b59ad5002"}], "stats": {"total": 56, "additions": 35, "deletions": 21}, "files": [{"sha": "939888ef01dc5a459fe071aa3d2e2030da3f42e1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c", "patch": "@@ -1,3 +1,8 @@\n+2012-12-03  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/55548\n+\t* intrinsic.texi (SYSTEM_CLOCK): Update documentation of SYSTEM_CLOCK.\n+\n 2012-12-03  Tobias Burnus  <burnus@net-b.de>\n \t    Janus Weil  <janus@gcc.gnu.org>\n "}, {"sha": "3390959e20b410da058466d31a1902e2e71f92bb", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c", "patch": "@@ -12014,12 +12014,11 @@ nanosecond resolution.  If a high resolution monotonic clock is not\n available, the implementation falls back to a potentially lower\n resolution realtime clock.\n \n-@var{COUNT_RATE} and @var{COUNT_MAX} vary depending on the kind of the\n-arguments.  For @var{kind=8} arguments, @var{COUNT} represents\n-nanoseconds, and for @var{kind=4} arguments, @var{COUNT} represents\n-milliseconds. Other than the kind dependency, @var{COUNT_RATE} and\n-@var{COUNT_MAX} are constant, however the particular values are\n-specific to @command{gfortran}.\n+@var{COUNT_RATE} is system dependent and can vary depending on the kind of the\n+arguments. For @var{kind=4} arguments, @var{COUNT} usually represents\n+milliseconds, while for @var{kind=8} arguments, @var{COUNT} typically\n+represents micro- or nanoseconds. @var{COUNT_MAX} usually equals\n+@code{HUGE(COUNT_MAX)}.\n \n If there is no clock, @var{COUNT} is set to @code{-HUGE(COUNT)}, and\n @var{COUNT_RATE} and @var{COUNT_MAX} are set to zero."}, {"sha": "ecaa6e3ec48237872fdf187c0c19fb8730057dcf", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c", "patch": "@@ -1,3 +1,12 @@\n+2012-12-03  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/55548\n+\t* intrinsics/system_clock.c (gf_gettime_mono): Add argument 'tck',\n+\twhich returns the clock resolution.\n+\t(system_clock_4): Get resolution from gf_gettime_mono, but limit to\n+\t1000/s.\n+\t(system_clock_8): Get resolution from gf_gettime_mono.\n+\n 2012-10-28  Tobias Burnus  <burnus@net-b.de>\n \n \t * m4/bessel.m4: Remove useless statement."}, {"sha": "9d5ba528ce3e102e669d46ee1b3847519973c205", "filename": "libgfortran/intrinsics/system_clock.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c/libgfortran%2Fintrinsics%2Fsystem_clock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c/libgfortran%2Fintrinsics%2Fsystem_clock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fsystem_clock.c?ref=a07c4054c2e7f508a9c74eb6d5abdb16b5b7648c", "patch": "@@ -64,6 +64,7 @@ static int weak_gettime (clockid_t, struct timespec *)\n    Arguments:\n    secs     - OUTPUT, seconds\n    nanosecs - OUTPUT, nanoseconds\n+   tk       - OUTPUT, clock resolution [counts/sec]\n \n    If the target supports a monotonic clock, the OUTPUT arguments\n    represent a monotonically incrementing clock starting from some\n@@ -76,11 +77,12 @@ static int weak_gettime (clockid_t, struct timespec *)\n    is set.\n */\n static int\n-gf_gettime_mono (time_t * secs, long * nanosecs)\n+gf_gettime_mono (time_t * secs, long * nanosecs, long * tck)\n {\n   int err;\n #ifdef HAVE_CLOCK_GETTIME\n   struct timespec ts;\n+  *tck = 1000000000;\n   err = clock_gettime (GF_CLOCK_MONOTONIC, &ts);\n   *secs = ts.tv_sec;\n   *nanosecs = ts.tv_nsec;\n@@ -90,12 +92,14 @@ gf_gettime_mono (time_t * secs, long * nanosecs)\n   if (weak_gettime)\n     {\n       struct timespec ts;\n+      *tck = 1000000000;\n       err = weak_gettime (GF_CLOCK_MONOTONIC, &ts);\n       *secs = ts.tv_sec;\n       *nanosecs = ts.tv_nsec;\n       return err;\n     }\n #endif\n+  *tck = 1000000;\n   err = gf_gettime (secs, nanosecs);\n   *nanosecs *= 1000;\n   return err;\n@@ -118,21 +122,20 @@ void\n system_clock_4(GFC_INTEGER_4 *count, GFC_INTEGER_4 *count_rate,\n \t       GFC_INTEGER_4 *count_max)\n {\n-#undef TCK\n-#define TCK 1000\n   GFC_INTEGER_4 cnt;\n   GFC_INTEGER_4 mx;\n \n   time_t secs;\n-  long nanosecs;\n+  long nanosecs, tck;\n \n   if (sizeof (secs) < sizeof (GFC_INTEGER_4))\n     internal_error (NULL, \"secs too small\");\n \n-  if (gf_gettime_mono (&secs, &nanosecs) == 0)\n+  if (gf_gettime_mono (&secs, &nanosecs, &tck) == 0)\n     {\n-      GFC_UINTEGER_4 ucnt = (GFC_UINTEGER_4) secs * TCK;\n-      ucnt += (nanosecs + 500000000 / TCK) / (1000000000 / TCK);\n+      tck = tck>1000 ? 1000 : tck;\n+      GFC_UINTEGER_4 ucnt = (GFC_UINTEGER_4) secs * tck;\n+      ucnt += (nanosecs + 500000000 / tck) / (1000000000 / tck);\n       if (ucnt > GFC_INTEGER_4_HUGE)\n \tcnt = ucnt - GFC_INTEGER_4_HUGE - 1;\n       else\n@@ -153,7 +156,7 @@ system_clock_4(GFC_INTEGER_4 *count, GFC_INTEGER_4 *count_rate,\n   if (count != NULL)\n     *count = cnt;\n   if (count_rate != NULL)\n-    *count_rate = TCK;\n+    *count_rate = tck;\n   if (count_max != NULL)\n     *count_max = mx;\n }\n@@ -165,21 +168,19 @@ void\n system_clock_8 (GFC_INTEGER_8 *count, GFC_INTEGER_8 *count_rate,\n \t\tGFC_INTEGER_8 *count_max)\n {\n-#undef TCK\n-#define TCK 1000000000\n   GFC_INTEGER_8 cnt;\n   GFC_INTEGER_8 mx;\n \n   time_t secs;\n-  long nanosecs;\n+  long nanosecs, tck;\n \n   if (sizeof (secs) < sizeof (GFC_INTEGER_4))\n     internal_error (NULL, \"secs too small\");\n \n-  if (gf_gettime_mono (&secs, &nanosecs) == 0)\n+  if (gf_gettime_mono (&secs, &nanosecs, &tck) == 0)\n     {\n-      GFC_UINTEGER_8 ucnt = (GFC_UINTEGER_8) secs * TCK;\n-      ucnt += (nanosecs + 500000000 / TCK) / (1000000000 / TCK);\n+      GFC_UINTEGER_8 ucnt = (GFC_UINTEGER_8) secs * tck;\n+      ucnt += (nanosecs + 500000000 / tck) / (1000000000 / tck);\n       if (ucnt > GFC_INTEGER_8_HUGE)\n \tcnt = ucnt - GFC_INTEGER_8_HUGE - 1;\n       else\n@@ -201,7 +202,7 @@ system_clock_8 (GFC_INTEGER_8 *count, GFC_INTEGER_8 *count_rate,\n   if (count != NULL)\n     *count = cnt;\n   if (count_rate != NULL)\n-    *count_rate = TCK;\n+    *count_rate = tck;\n   if (count_max != NULL)\n     *count_max = mx;\n }"}]}