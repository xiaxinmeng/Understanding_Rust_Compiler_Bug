{"sha": "66f97d31f233e10870728947731db603b5dc0c9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZmOTdkMzFmMjMzZTEwODcwNzI4OTQ3NzMxZGI2MDNiNWRjMGM5Yw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-06-03T19:10:44Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-06-03T19:10:44Z"}, "message": "cfgloopmanip.c (remove_path, [...]): Change dom_bbs to vector.\n\n\t* cfgloopmanip.c (remove_path, loopify, duplicate_loop_to_header_edge):\n\tChange dom_bbs to vector.  Add argument to iterate_fix_dominators call.\n\t* loop-unroll.c (unroll_loop_runtime_iterations): Ditto.\n\t* tree-cfg.c (tree_duplicate_sese_region): Change doms to vector.\n\tAdd argument to iterate_fix_dominators call.\n\t(remove_edge_and_dominated_blocks): Pass vector to bbs_to_fix_dom.\n\t* gcse.c (hoist_code): Change domby to vector.\n\t* cfghooks.c (make_forwarder_block): Change doms_to_fix to vector.\n\tAdd argument to iterate_fix_dominators call.\n\t* loop-doloop.c (doloop_modify): Changed recount_dominator to\n\trecompute_dominator.\n\t* lambda-code.c (perfect_nestify): Ditto.\n\t* cfgloopanal.c: Include graphds.h.\n\t(struct edge, struct vertex, struct graph, dump_graph, new_graph,\n\tadd_edge, dfs, for_each_edge, free_graph): Moved to graphds.c.\n\t(mark_irreducible_loops): Use graphds_scc.  Remove argument from\n\tadd_edge call.\n\t* graphds.c: New file.\n\t* graphds.h: New file.\n\t* dominance.c: Include vecprim.h, pointer-set.h and graphds.h.\n\t(get_dominated_by, get_dominated_by_region): Change return type to\n\tvector.\n\t(verify_dominators): Recompute all dominators and compare the results.\n\t(recount_dominator): Renamed to ...\n\t(recompute_dominator): ... this.  Do not check that the block is\n\tdominated by entry.\n\t(iterate_fix_dominators): Reimplemented.\n\t(prune_bbs_to_update_dominators, root_of_dom_tree,\n\tdetermine_dominators_for_sons): New functions.\n\t* et-forest.c (et_root): New function.\n\t* et-forest.h (et_root): Declare.\n\t* Makefile.in (graphds.o): Add.\n\t(cfgloopanal.o): Add graphds.h dependency.\n\t(dominance.o): Add graphds.h, vecprim.h and pointer-set.h dependency.\n\t* basic-block.h (get_dominated_by, get_dominated_by_region,\n\titerate_fix_dominators): Declaration changed.\n\t(recount_dominator): Renamed to ...\n\t(recompute_dominator): ... this.\n\t* tree-ssa-threadupdate.c (thread_block): Free dominance info.\n\t(thread_through_all_blocks): Do not free dominance info.\n\nFrom-SVN: r125297", "tree": {"sha": "00a98b1b54819809ffb6999717d9263ac5558fe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00a98b1b54819809ffb6999717d9263ac5558fe2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66f97d31f233e10870728947731db603b5dc0c9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66f97d31f233e10870728947731db603b5dc0c9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66f97d31f233e10870728947731db603b5dc0c9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66f97d31f233e10870728947731db603b5dc0c9c/comments", "author": null, "committer": null, "parents": [{"sha": "b6a9c30c80a0713b0b27f434dfe34b0552fc7384", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6a9c30c80a0713b0b27f434dfe34b0552fc7384", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6a9c30c80a0713b0b27f434dfe34b0552fc7384"}], "stats": {"total": 1377, "additions": 1023, "deletions": 354}, "files": [{"sha": "2214ddf712a50d03fd7f41be61e5b811ce4fd9bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -1,3 +1,46 @@\n+2007-06-03  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* cfgloopmanip.c (remove_path, loopify, duplicate_loop_to_header_edge):\n+\tChange dom_bbs to vector.  Add argument to iterate_fix_dominators call.\n+\t* loop-unroll.c (unroll_loop_runtime_iterations): Ditto.\n+\t* tree-cfg.c (tree_duplicate_sese_region): Change doms to vector.\n+\tAdd argument to iterate_fix_dominators call.\n+\t(remove_edge_and_dominated_blocks): Pass vector to bbs_to_fix_dom.\n+\t* gcse.c (hoist_code): Change domby to vector.\n+\t* cfghooks.c (make_forwarder_block): Change doms_to_fix to vector.\n+\tAdd argument to iterate_fix_dominators call.\n+\t* loop-doloop.c (doloop_modify): Changed recount_dominator to\n+\trecompute_dominator.\n+\t* lambda-code.c (perfect_nestify): Ditto.\n+\t* cfgloopanal.c: Include graphds.h.\n+\t(struct edge, struct vertex, struct graph, dump_graph, new_graph,\n+\tadd_edge, dfs, for_each_edge, free_graph): Moved to graphds.c.\n+\t(mark_irreducible_loops): Use graphds_scc.  Remove argument from\n+\tadd_edge call.\n+\t* graphds.c: New file.\n+\t* graphds.h: New file.\n+\t* dominance.c: Include vecprim.h, pointer-set.h and graphds.h.\n+\t(get_dominated_by, get_dominated_by_region): Change return type to\n+\tvector.\n+\t(verify_dominators): Recompute all dominators and compare the results.\n+\t(recount_dominator): Renamed to ...\n+\t(recompute_dominator): ... this.  Do not check that the block is\n+\tdominated by entry.\n+\t(iterate_fix_dominators): Reimplemented.\n+\t(prune_bbs_to_update_dominators, root_of_dom_tree,\n+\tdetermine_dominators_for_sons): New functions.\n+\t* et-forest.c (et_root): New function.\n+\t* et-forest.h (et_root): Declare.\n+\t* Makefile.in (graphds.o): Add.\n+\t(cfgloopanal.o): Add graphds.h dependency.\n+\t(dominance.o): Add graphds.h, vecprim.h and pointer-set.h dependency.\n+\t* basic-block.h (get_dominated_by, get_dominated_by_region,\n+\titerate_fix_dominators): Declaration changed.\n+\t(recount_dominator): Renamed to ...\n+\t(recompute_dominator): ... this.\n+\t* tree-ssa-threadupdate.c (thread_block): Free dominance info.\n+\t(thread_through_all_blocks): Do not free dominance info.\n+\n 2007-06-03  Andreas Schwab  <schwab@suse.de>\n \n \t* config/m68k/m68k.c (override_options): Don't override"}, {"sha": "a8d5046f62acd6e670b85a555094c451bdc15083", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -1009,6 +1009,7 @@ OBJS-common = \\\n \tgimplify.o \\\n \tglobal.o \\\n \tgraph.o \\\n+\tgraphds.o \\\n \tgtype-desc.o \\\n \thaifa-sched.o \\\n \thooks.o \\\n@@ -2556,7 +2557,9 @@ cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) coretypes.h $(TM_H) \\\n    $(GGC_H)\n cfgloopanal.o : cfgloopanal.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h $(TM_H) \\\n-   $(OBSTACK_H) output.h\n+   $(OBSTACK_H) output.h graphds.h\n+graphds.o : graphds.c graphds.h $(CONFIG_H) $(SYSTEM_H) bitmap.h $(OBSTACK_H) \\\n+   coretypes.h vec.h vecprim.h\n struct-equiv.o : struct-equiv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) hard-reg-set.h output.h $(FLAGS_H) $(RECOG_H) \\\n    insn-config.h $(TARGET_H) $(TM_P_H) $(PARAMS_H) \\\n@@ -2582,7 +2585,8 @@ loop-unroll.o: loop-unroll.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n    output.h $(EXPR_H) coretypes.h $(TM_H) $(HASHTAB_H) $(RECOG_H) \\\n    $(OBSTACK_H)\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   hard-reg-set.h $(BASIC_BLOCK_H) et-forest.h $(OBSTACK_H) toplev.h $(TIMEVAR_H)\n+   hard-reg-set.h $(BASIC_BLOCK_H) et-forest.h $(OBSTACK_H) toplev.h \\\n+   $(TIMEVAR_H) graphds.h vecprim.h pointer-set.h\n et-forest.o : et-forest.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    et-forest.h alloc-pool.h $(BASIC_BLOCK_H)\n combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\"}, {"sha": "8d7dbe322b0390c98077c15987d75f83d8ef136a", "filename": "gcc/basic-block.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -959,15 +959,17 @@ extern void set_immediate_dominator (enum cdi_direction, basic_block,\n \t\t\t\t     basic_block);\n extern basic_block get_immediate_dominator (enum cdi_direction, basic_block);\n extern bool dominated_by_p (enum cdi_direction, basic_block, basic_block);\n-extern int get_dominated_by (enum cdi_direction, basic_block, basic_block **);\n-extern unsigned get_dominated_by_region (enum cdi_direction, basic_block *,\n-\t\t\t\t\t unsigned, basic_block *);\n+extern VEC (basic_block, heap) *get_dominated_by (enum cdi_direction, basic_block);\n+extern VEC (basic_block, heap) *get_dominated_by_region (enum cdi_direction,\n+\t\t\t\t\t\t\t basic_block *,\n+\t\t\t\t\t\t\t unsigned);\n extern void add_to_dominance_info (enum cdi_direction, basic_block);\n extern void delete_from_dominance_info (enum cdi_direction, basic_block);\n-basic_block recount_dominator (enum cdi_direction, basic_block);\n+basic_block recompute_dominator (enum cdi_direction, basic_block);\n extern void redirect_immediate_dominators (enum cdi_direction, basic_block,\n \t\t\t\t\t   basic_block);\n-extern void iterate_fix_dominators (enum cdi_direction, basic_block *, int);\n+extern void iterate_fix_dominators (enum cdi_direction,\n+\t\t\t\t    VEC (basic_block, heap) *, bool);\n extern void verify_dominators (enum cdi_direction);\n extern basic_block first_dom_son (enum cdi_direction, basic_block);\n extern basic_block next_dom_son (enum cdi_direction, basic_block);"}, {"sha": "beb377bd1e4bf6b496add6e4c546012cd95f4caf", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -735,11 +735,11 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n \n   if (dom_info_available_p (CDI_DOMINATORS))\n     {\n-      basic_block doms_to_fix[2];\n-\n-      doms_to_fix[0] = dummy;\n-      doms_to_fix[1] = bb;\n-      iterate_fix_dominators (CDI_DOMINATORS, doms_to_fix, 2);\n+      VEC (basic_block, heap) *doms_to_fix = VEC_alloc (basic_block, heap, 2);\n+      VEC_quick_push (basic_block, doms_to_fix, dummy);\n+      VEC_quick_push (basic_block, doms_to_fix, bb);\n+      iterate_fix_dominators (CDI_DOMINATORS, doms_to_fix, false);\n+      VEC_free (basic_block, heap, doms_to_fix);\n     }\n \n   if (current_loops != NULL)"}, {"sha": "30c871860f4753e5d1a08bc9a07319ce1147568e", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 7, "deletions": 211, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -29,6 +29,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"cfgloop.h\"\n #include \"expr.h\"\n #include \"output.h\"\n+#include \"graphds.h\"\n \n /* Checks whether BB is executed exactly once in each LOOP iteration.  */\n \n@@ -50,157 +51,6 @@ just_once_each_iteration_p (const struct loop *loop, basic_block bb)\n   return true;\n }\n \n-/* Structure representing edge of a graph.  */\n-\n-struct edge\n-{\n-  int src, dest;\t/* Source and destination.  */\n-  struct edge *pred_next, *succ_next;\n-\t\t\t/* Next edge in predecessor and successor lists.  */\n-  void *data;\t\t/* Data attached to the edge.  */\n-};\n-\n-/* Structure representing vertex of a graph.  */\n-\n-struct vertex\n-{\n-  struct edge *pred, *succ;\n-\t\t\t/* Lists of predecessors and successors.  */\n-  int component;\t/* Number of dfs restarts before reaching the\n-\t\t\t   vertex.  */\n-  int post;\t\t/* Postorder number.  */\n-};\n-\n-/* Structure representing a graph.  */\n-\n-struct graph\n-{\n-  int n_vertices;\t/* Number of vertices.  */\n-  struct vertex *vertices;\n-\t\t\t/* The vertices.  */\n-};\n-\n-/* Dumps graph G into F.  */\n-\n-extern void dump_graph (FILE *, struct graph *);\n-\n-void\n-dump_graph (FILE *f, struct graph *g)\n-{\n-  int i;\n-  struct edge *e;\n-\n-  for (i = 0; i < g->n_vertices; i++)\n-    {\n-      if (!g->vertices[i].pred\n-\t  && !g->vertices[i].succ)\n-\tcontinue;\n-\n-      fprintf (f, \"%d (%d)\\t<-\", i, g->vertices[i].component);\n-      for (e = g->vertices[i].pred; e; e = e->pred_next)\n-\tfprintf (f, \" %d\", e->src);\n-      fprintf (f, \"\\n\");\n-\n-      fprintf (f, \"\\t->\");\n-      for (e = g->vertices[i].succ; e; e = e->succ_next)\n-\tfprintf (f, \" %d\", e->dest);\n-      fprintf (f, \"\\n\");\n-    }\n-}\n-\n-/* Creates a new graph with N_VERTICES vertices.  */\n-\n-static struct graph *\n-new_graph (int n_vertices)\n-{\n-  struct graph *g = XNEW (struct graph);\n-\n-  g->n_vertices = n_vertices;\n-  g->vertices = XCNEWVEC (struct vertex, n_vertices);\n-\n-  return g;\n-}\n-\n-/* Adds an edge from F to T to graph G, with DATA attached.  */\n-\n-static void\n-add_edge (struct graph *g, int f, int t, void *data)\n-{\n-  struct edge *e = xmalloc (sizeof (struct edge));\n-\n-  e->src = f;\n-  e->dest = t;\n-  e->data = data;\n-\n-  e->pred_next = g->vertices[t].pred;\n-  g->vertices[t].pred = e;\n-\n-  e->succ_next = g->vertices[f].succ;\n-  g->vertices[f].succ = e;\n-}\n-\n-/* Runs dfs search over vertices of G, from NQ vertices in queue QS.\n-   The vertices in postorder are stored into QT.  If FORWARD is false,\n-   backward dfs is run.  */\n-\n-static void\n-dfs (struct graph *g, int *qs, int nq, int *qt, bool forward)\n-{\n-  int i, tick = 0, v, comp = 0, top;\n-  struct edge *e;\n-  struct edge **stack = xmalloc (sizeof (struct edge *) * g->n_vertices);\n-\n-  for (i = 0; i < g->n_vertices; i++)\n-    {\n-      g->vertices[i].component = -1;\n-      g->vertices[i].post = -1;\n-    }\n-\n-#define FST_EDGE(V) (forward ? g->vertices[(V)].succ : g->vertices[(V)].pred)\n-#define NEXT_EDGE(E) (forward ? (E)->succ_next : (E)->pred_next)\n-#define EDGE_SRC(E) (forward ? (E)->src : (E)->dest)\n-#define EDGE_DEST(E) (forward ? (E)->dest : (E)->src)\n-\n-  for (i = 0; i < nq; i++)\n-    {\n-      v = qs[i];\n-      if (g->vertices[v].post != -1)\n-\tcontinue;\n-\n-      g->vertices[v].component = comp++;\n-      e = FST_EDGE (v);\n-      top = 0;\n-\n-      while (1)\n-\t{\n-\t  while (e && g->vertices[EDGE_DEST (e)].component != -1)\n-\t    e = NEXT_EDGE (e);\n-\n-\t  if (!e)\n-\t    {\n-\t      if (qt)\n-\t\tqt[tick] = v;\n-\t      g->vertices[v].post = tick++;\n-\n-\t      if (!top)\n-\t\tbreak;\n-\n-\t      e = stack[--top];\n-\t      v = EDGE_SRC (e);\n-\t      e = NEXT_EDGE (e);\n-\t      continue;\n-\t    }\n-\n-\t  stack[top++] = e;\n-\t  v = EDGE_DEST (e);\n-\t  e = FST_EDGE (v);\n-\t  g->vertices[v].component = comp - 1;\n-\t}\n-    }\n-\n-  free (stack);\n-}\n-\n /* Marks the edge E in graph G irreducible if it connects two vertices in the\n    same scc.  */\n \n@@ -221,38 +71,6 @@ check_irred (struct graph *g, struct edge *e)\n     real->src->flags |= BB_IRREDUCIBLE_LOOP;\n }\n \n-/* Runs CALLBACK for all edges in G.  */\n-\n-static void\n-for_each_edge (struct graph *g,\n-\t       void (callback) (struct graph *, struct edge *))\n-{\n-  struct edge *e;\n-  int i;\n-\n-  for (i = 0; i < g->n_vertices; i++)\n-    for (e = g->vertices[i].succ; e; e = e->succ_next)\n-      callback (g, e);\n-}\n-\n-/* Releases the memory occupied by G.  */\n-\n-static void\n-free_graph (struct graph *g)\n-{\n-  struct edge *e, *n;\n-  int i;\n-\n-  for (i = 0; i < g->n_vertices; i++)\n-    for (e = g->vertices[i].succ; e; e = n)\n-      {\n-\tn = e->succ_next;\n-\tfree (e);\n-      }\n-  free (g->vertices);\n-  free (g);\n-}\n-\n /* Marks blocks and edges that are part of non-recognized loops; i.e. we\n    throw away all latch edges and mark blocks inside any remaining cycle.\n    Everything is a bit complicated due to fact we do not want to do this\n@@ -271,15 +89,11 @@ mark_irreducible_loops (void)\n   basic_block act;\n   edge e;\n   edge_iterator ei;\n-  int i, src, dest;\n+  int src, dest;\n+  unsigned depth;\n   struct graph *g;\n   int num = number_of_loops ();\n-  int *queue1 = XNEWVEC (int, last_basic_block + num);\n-  int *queue2 = XNEWVEC (int, last_basic_block + num);\n-  int nq;\n-  unsigned depth;\n-  struct loop *cloop, *loop;\n-  loop_iterator li;\n+  struct loop *cloop;\n \n   gcc_assert (current_loops != NULL);\n \n@@ -332,34 +146,16 @@ mark_irreducible_loops (void)\n \t    src = LOOP_REPR (cloop);\n \t  }\n \n-\tadd_edge (g, src, dest, e);\n+\tadd_edge (g, src, dest)->data = e;\n       }\n \n-  /* Find the strongly connected components.  Use the algorithm of Tarjan --\n-     first determine the postorder dfs numbering in reversed graph, then\n-     run the dfs on the original graph in the order given by decreasing\n-     numbers assigned by the previous pass.  */\n-  nq = 0;\n-  FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n-    {\n-      queue1[nq++] = BB_REPR (act);\n-    }\n-\n-  FOR_EACH_LOOP (li, loop, 0)\n-    {\n-      queue1[nq++] = LOOP_REPR (loop);\n-    }\n-  dfs (g, queue1, nq, queue2, false);\n-  for (i = 0; i < nq; i++)\n-    queue1[i] = queue2[nq - i - 1];\n-  dfs (g, queue1, nq, NULL, true);\n+  /* Find the strongly connected components.  */\n+  graphds_scc (g, NULL);\n \n   /* Mark the irreducible loops.  */\n   for_each_edge (g, check_irred);\n \n   free_graph (g);\n-  free (queue1);\n-  free (queue2);\n \n   current_loops->state |= LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS;\n }"}, {"sha": "4568833065bf0217ea04587534b90f9ec83c6cdc", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -276,8 +276,9 @@ bool\n remove_path (edge e)\n {\n   edge ae;\n-  basic_block *rem_bbs, *bord_bbs, *dom_bbs, from, bb;\n-  int i, nrem, n_bord_bbs, n_dom_bbs, nreml;\n+  basic_block *rem_bbs, *bord_bbs, from, bb;\n+  VEC (basic_block, heap) *dom_bbs;\n+  int i, nrem, n_bord_bbs, nreml;\n   sbitmap seen;\n   bool irred_invalidated = false;\n   struct loop **deleted_loop;\n@@ -338,7 +339,7 @@ remove_path (edge e)\n   /* Remove the path.  */\n   from = e->src;\n   remove_branch (e);\n-  dom_bbs = XCNEWVEC (basic_block, n_basic_blocks);\n+  dom_bbs = NULL;\n \n   /* Cancel loops contained in the path.  */\n   deleted_loop = XNEWVEC (struct loop *, nrem);\n@@ -355,7 +356,6 @@ remove_path (edge e)\n   free (deleted_loop);\n \n   /* Find blocks whose dominators may be affected.  */\n-  n_dom_bbs = 0;\n   sbitmap_zero (seen);\n   for (i = 0; i < n_bord_bbs; i++)\n     {\n@@ -370,14 +370,14 @@ remove_path (edge e)\n \t   ldom;\n \t   ldom = next_dom_son (CDI_DOMINATORS, ldom))\n \tif (!dominated_by_p (CDI_DOMINATORS, from, ldom))\n-\t  dom_bbs[n_dom_bbs++] = ldom;\n+\t  VEC_safe_push (basic_block, heap, dom_bbs, ldom);\n     }\n \n   free (seen);\n \n   /* Recount dominators.  */\n-  iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, n_dom_bbs);\n-  free (dom_bbs);\n+  iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, true);\n+  VEC_free (basic_block, heap, dom_bbs);\n   free (bord_bbs);\n \n   /* Fix placements of basic blocks inside loops and the placement of\n@@ -472,8 +472,9 @@ loopify (edge latch_edge, edge header_edge,\n {\n   basic_block succ_bb = latch_edge->dest;\n   basic_block pred_bb = header_edge->src;\n-  basic_block *dom_bbs, *body;\n-  unsigned n_dom_bbs, i;\n+  basic_block *body;\n+  VEC (basic_block, heap) *dom_bbs;\n+  unsigned i;\n   sbitmap seen;\n   struct loop *loop = alloc_loop ();\n   struct loop *outer = loop_outer (succ_bb->loop_father);\n@@ -528,8 +529,7 @@ loopify (edge latch_edge, edge header_edge,\n   scale_loop_frequencies (succ_bb->loop_father, true_scale, REG_BR_PROB_BASE);\n \n   /* Update dominators of blocks outside of LOOP.  */\n-  dom_bbs = XCNEWVEC (basic_block, n_basic_blocks);\n-  n_dom_bbs = 0;\n+  dom_bbs = NULL;\n   seen = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (seen);\n   body = get_loop_body (loop);\n@@ -547,15 +547,15 @@ loopify (edge latch_edge, edge header_edge,\n \tif (!TEST_BIT (seen, ldom->index))\n \t  {\n \t    SET_BIT (seen, ldom->index);\n-\t    dom_bbs[n_dom_bbs++] = ldom;\n+\t    VEC_safe_push (basic_block, heap, dom_bbs, ldom);\n \t  }\n     }\n \n-  iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, n_dom_bbs);\n+  iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, false);\n \n   free (body);\n   free (seen);\n-  free (dom_bbs);\n+  VEC_free (basic_block, heap, dom_bbs);\n \n   return loop;\n }\n@@ -1054,23 +1054,23 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n   /* Update dominators of outer blocks if affected.  */\n   for (i = 0; i < n; i++)\n     {\n-      basic_block dominated, dom_bb, *dom_bbs;\n-      int n_dom_bbs,j;\n+      basic_block dominated, dom_bb;\n+      VEC (basic_block, heap) *dom_bbs;\n+      unsigned j;\n \n       bb = bbs[i];\n       bb->aux = 0;\n \n-      n_dom_bbs = get_dominated_by (CDI_DOMINATORS, bb, &dom_bbs);\n-      for (j = 0; j < n_dom_bbs; j++)\n+      dom_bbs = get_dominated_by (CDI_DOMINATORS, bb);\n+      for (j = 0; VEC_iterate (basic_block, dom_bbs, j, dominated); j++)\n \t{\n-\t  dominated = dom_bbs[j];\n \t  if (flow_bb_inside_loop_p (loop, dominated))\n \t    continue;\n \t  dom_bb = nearest_common_dominator (\n \t\t\tCDI_DOMINATORS, first_active[i], first_active_latch);\n \t  set_immediate_dominator (CDI_DOMINATORS, dominated, dom_bb);\n \t}\n-      free (dom_bbs);\n+      VEC_free (basic_block, heap, dom_bbs);\n     }\n   free (first_active);\n "}, {"sha": "57a9df6baa48899d9423326efba750e48842e047", "filename": "gcc/dominance.c", "status": "modified", "additions": 347, "deletions": 70, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -44,6 +44,9 @@\n #include \"toplev.h\"\n #include \"et-forest.h\"\n #include \"timevar.h\"\n+#include \"vecprim.h\"\n+#include \"pointer-set.h\"\n+#include \"graphds.h\"\n \n /* Whether the dominators and the postdominators are available.  */\n static enum dom_state dom_computed[2];\n@@ -735,45 +738,39 @@ set_immediate_dominator (enum cdi_direction dir, basic_block bb,\n     dom_computed[dir_index] = DOM_NO_FAST_QUERY;\n }\n \n-/* Store all basic blocks immediately dominated by BB into BBS and return\n-   their number.  */\n-int\n-get_dominated_by (enum cdi_direction dir, basic_block bb, basic_block **bbs)\n+/* Returns the list of basic blocks immediately dominated by BB, in the\n+   direction DIR.  */\n+VEC (basic_block, heap) *\n+get_dominated_by (enum cdi_direction dir, basic_block bb)\n {\n-  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   int n;\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   struct et_node *node = bb->dom[dir_index], *son = node->son, *ason;\n- \n+  VEC (basic_block, heap) *bbs = NULL;\n+\n   gcc_assert (dom_computed[dir_index]);\n \n   if (!son)\n-    {\n-      *bbs = NULL;\n-      return 0;\n-    }\n-\n-  for (ason = son->right, n = 1; ason != son; ason = ason->right)\n-    n++;\n+    return NULL;\n \n-  *bbs = XNEWVEC (basic_block, n);\n-  (*bbs)[0] = son->data;\n+  VEC_safe_push (basic_block, heap, bbs, son->data);\n   for (ason = son->right, n = 1; ason != son; ason = ason->right)\n-    (*bbs)[n++] = ason->data;\n+    VEC_safe_push (basic_block, heap, bbs, ason->data);\n \n-  return n;\n+  return bbs;\n }\n \n-/* Find all basic blocks that are immediately dominated (in direction DIR)\n-   by some block between N_REGION ones stored in REGION, except for blocks\n-   in the REGION itself.  The found blocks are stored to DOMS and their number\n-   is returned.  */\n-\n-unsigned\n+/* Returns the list of basic blocks that are immediately dominated (in\n+   direction DIR) by some block between N_REGION ones stored in REGION,\n+   except for blocks in the REGION itself.  */\n+  \n+VEC (basic_block, heap) *\n get_dominated_by_region (enum cdi_direction dir, basic_block *region,\n-\t\t\t unsigned n_region, basic_block *doms)\n+\t\t\t unsigned n_region)\n {\n-  unsigned n_doms = 0, i;\n+  unsigned i;\n   basic_block dom;\n+  VEC (basic_block, heap) *doms = NULL;\n \n   for (i = 0; i < n_region; i++)\n     region[i]->flags |= BB_DUPLICATED;\n@@ -782,11 +779,11 @@ get_dominated_by_region (enum cdi_direction dir, basic_block *region,\n \t dom;\n \t dom = next_dom_son (dir, dom))\n       if (!(dom->flags & BB_DUPLICATED))\n-\tdoms[n_doms++] = dom;\n+\tVEC_safe_push (basic_block, heap, doms, dom);\n   for (i = 0; i < n_region; i++)\n     region[i]->flags &= ~BB_DUPLICATED;\n \n-  return n_doms;\n+  return doms;\n }\n \n /* Redirect all edges pointing to BB to TO.  */\n@@ -973,40 +970,37 @@ void\n verify_dominators (enum cdi_direction dir)\n {\n   int err = 0;\n-  basic_block bb;\n+  basic_block *old_dom = XNEWVEC (basic_block, last_basic_block);\n+  basic_block bb, imm_bb;\n \n   gcc_assert (dom_info_available_p (dir));\n \n   FOR_EACH_BB (bb)\n     {\n-      basic_block dom_bb;\n-      basic_block imm_bb;\n+      old_dom[bb->index] = get_immediate_dominator (dir, bb);\n \n-      dom_bb = recount_dominator (dir, bb);\n-      imm_bb = get_immediate_dominator (dir, bb);\n-      if (dom_bb != imm_bb)\n+      if (!old_dom[bb->index])\n \t{\n-\t  if ((dom_bb == NULL) || (imm_bb == NULL))\n-\t    error (\"dominator of %d status unknown\", bb->index);\n-\t  else\n-\t    error (\"dominator of %d should be %d, not %d\",\n-\t\t   bb->index, dom_bb->index, imm_bb->index);\n+\t  error (\"dominator of %d status unknown\", bb->index);\n \t  err = 1;\n \t}\n     }\n \n-  if (dir == CDI_DOMINATORS)\n+  free_dominance_info (dir);\n+  calculate_dominance_info (dir);\n+\n+  FOR_EACH_BB (bb)\n     {\n-      FOR_EACH_BB (bb)\n+      imm_bb = get_immediate_dominator (dir, bb);\n+      if (old_dom[bb->index] != imm_bb)\n \t{\n-\t  if (!dominated_by_p (dir, bb, ENTRY_BLOCK_PTR))\n-\t    {\n-\t      error (\"ENTRY does not dominate bb %d\", bb->index);\n-\t      err = 1;\n-\t    }\n+\t  error (\"dominator of %d should be %d, not %d\",\n+\t\t bb->index, imm_bb->index, old_dom[bb->index]->index);\n+\t  err = 1;\n \t}\n     }\n \n+  free (old_dom);\n   gcc_assert (!err);\n }\n \n@@ -1016,7 +1010,7 @@ verify_dominators (enum cdi_direction dir)\n    reaches a fixed point.  */\n \n basic_block\n-recount_dominator (enum cdi_direction dir, basic_block bb)\n+recompute_dominator (enum cdi_direction dir, basic_block bb)\n {\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   basic_block dom_bb = NULL;\n@@ -1029,11 +1023,6 @@ recount_dominator (enum cdi_direction dir, basic_block bb)\n     {\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n-\t  /* Ignore the predecessors that either are not reachable from\n-\t     the entry block, or whose dominator was not determined yet.  */\n-\t  if (!dominated_by_p (dir, e->src, ENTRY_BLOCK_PTR))\n-\t    continue;\n-\n \t  if (!dominated_by_p (dir, e->src, bb))\n \t    dom_bb = nearest_common_dominator (dir, dom_bb, e->src);\n \t}\n@@ -1050,37 +1039,325 @@ recount_dominator (enum cdi_direction dir, basic_block bb)\n   return dom_bb;\n }\n \n-/* Iteratively recount dominators of BBS. The change is supposed to be local\n-   and not to grow further.  */\n+/* Use simple heuristics (see iterate_fix_dominators) to determine dominators\n+   of BBS.  We assume that all the immediate dominators except for those of the\n+   blocks in BBS are correct.  If CONSERVATIVE is true, we also assume that the\n+   currently recorded immediate dominators of blocks in BBS really dominate the\n+   blocks.  The basic blocks for that we determine the dominator are removed\n+   from BBS.  */\n+\n+static void\n+prune_bbs_to_update_dominators (VEC (basic_block, heap) *bbs,\n+\t\t\t\tbool conservative)\n+{\n+  unsigned i;\n+  bool single;\n+  basic_block bb, dom = NULL;\n+  edge_iterator ei;\n+  edge e;\n+\n+  for (i = 0; VEC_iterate (basic_block, bbs, i, bb);)\n+    {\n+      if (bb == ENTRY_BLOCK_PTR)\n+\tgoto succeed;\n+\n+      if (single_pred_p (bb))\n+\t{\n+\t  set_immediate_dominator (CDI_DOMINATORS, bb, single_pred (bb));\n+\t  goto succeed;\n+\t}\n+\n+      if (!conservative)\n+\tgoto fail;\n+\n+      single = true;\n+      dom = NULL;\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t{\n+\t  if (dominated_by_p (CDI_DOMINATORS, e->src, bb))\n+\t    continue;\n+\n+\t  if (!dom)\n+\t    dom = e->src;\n+\t  else\n+\t    {\n+\t      single = false;\n+\t      dom = nearest_common_dominator (CDI_DOMINATORS, dom, e->src);\n+\t    }\n+\t}\n+\n+      gcc_assert (dom != NULL);\n+      if (single\n+\t  || find_edge (dom, bb))\n+\t{\n+\t  set_immediate_dominator (CDI_DOMINATORS, bb, dom);\n+\t  goto succeed;\n+\t}\n+\n+fail:\n+      i++;\n+      continue;\n+\n+succeed:\n+      VEC_unordered_remove (basic_block, bbs, i);\n+    }\n+}\n+\n+/* Returns root of the dominance tree in the direction DIR that contains\n+   BB.  */\n+\n+static basic_block\n+root_of_dom_tree (enum cdi_direction dir, basic_block bb)\n+{\n+  return et_root (bb->dom[dom_convert_dir_to_idx (dir)])->data;\n+}\n+\n+/* See the comment in iterate_fix_dominators.  Finds the immediate dominators\n+   for the sons of Y, found using the SON and BROTHER arrays representing\n+   the dominance tree of graph G.  BBS maps the vertices of G to the basic\n+   blocks.  */\n+\n+static void\n+determine_dominators_for_sons (struct graph *g, VEC (basic_block, heap) *bbs,\n+\t\t\t       int y, int *son, int *brother)\n+{\n+  bitmap gprime;\n+  int i, a, nc;\n+  VEC (int, heap) **sccs;\n+  basic_block bb, dom, ybb;\n+  unsigned si;\n+  edge e;\n+  edge_iterator ei;\n+\n+  if (son[y] == -1)\n+    return;\n+  if (y == (int) VEC_length (basic_block, bbs))\n+    ybb = ENTRY_BLOCK_PTR;\n+  else\n+    ybb = VEC_index (basic_block, bbs, y);\n+\n+  if (brother[son[y]] == -1)\n+    {\n+      /* Handle the common case Y has just one son specially.  */\n+      bb = VEC_index (basic_block, bbs, son[y]);\n+      set_immediate_dominator (CDI_DOMINATORS, bb,\n+\t\t\t       recompute_dominator (CDI_DOMINATORS, bb));\n+      identify_vertices (g, y, son[y]);\n+      return;\n+    }\n+\n+  gprime = BITMAP_ALLOC (NULL);\n+  for (a = son[y]; a != -1; a = brother[a])\n+    bitmap_set_bit (gprime, a);\n+\n+  nc = graphds_scc (g, gprime);\n+  BITMAP_FREE (gprime);\n+\n+  sccs = XCNEWVEC (VEC (int, heap) *, nc);\n+  for (a = son[y]; a != -1; a = brother[a])\n+    VEC_safe_push (int, heap, sccs[g->vertices[a].component], a);\n+\n+  for (i = nc - 1; i >= 0; i--)\n+    {\n+      dom = NULL;\n+      for (si = 0; VEC_iterate (int, sccs[i], si, a); si++)\n+\t{\n+\t  bb = VEC_index (basic_block, bbs, a);\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    {\n+\t      if (root_of_dom_tree (CDI_DOMINATORS, e->src) != ybb)\n+\t\tcontinue;\n+\n+\t      dom = nearest_common_dominator (CDI_DOMINATORS, dom, e->src);\n+\t    }\n+\t}\n+\n+      gcc_assert (dom != NULL);\n+      for (si = 0; VEC_iterate (int, sccs[i], si, a); si++)\n+\t{\n+\t  bb = VEC_index (basic_block, bbs, a);\n+\t  set_immediate_dominator (CDI_DOMINATORS, bb, dom);\n+\t}\n+    }\n+\n+  for (i = 0; i < nc; i++)\n+    VEC_free (int, heap, sccs[i]);\n+  free (sccs);\n+\n+  for (a = son[y]; a != -1; a = brother[a])\n+    identify_vertices (g, y, a);\n+}\n+\n+/* Recompute dominance information for basic blocks in the set BBS.  The\n+   function assumes that the immediate dominators of all the other blocks\n+   in CFG are correct, and that there are no unreachable blocks.\n+\n+   If CONSERVATIVE is true, we additionally assume that all the ancestors of\n+   a block of BBS in the current dominance tree dominate it.  */\n+\n void\n-iterate_fix_dominators (enum cdi_direction dir, basic_block *bbs, int n)\n+iterate_fix_dominators (enum cdi_direction dir, VEC (basic_block, heap) *bbs,\n+\t\t\tbool conservative)\n {\n+  unsigned i;\n+  basic_block bb, dom;\n+  struct graph *g;\n+  int n, y;\n+  size_t dom_i;\n+  edge e;\n+  edge_iterator ei;\n+  struct pointer_map_t *map;\n+  int *parent, *son, *brother;\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n-  int i, changed = 1;\n-  basic_block old_dom, new_dom;\n \n+  /* We only support updating dominators.  There are some problems with\n+     updating postdominators (need to add fake edges from infinite loops\n+     and noreturn functions), and since we do not currently use\n+     iterate_fix_dominators for postdominators, any attempt to handle these\n+     problems would be unused, untested, and almost surely buggy.  We keep\n+     the DIR argument for consistency with the rest of the dominator analysis\n+     interface.  */\n+  gcc_assert (dir == CDI_DOMINATORS);\n   gcc_assert (dom_computed[dir_index]);\n \n-  for (i = 0; i < n; i++)\n-    set_immediate_dominator (dir, bbs[i], NULL);\n+  /* The algorithm we use takes inspiration from the following papers, although\n+     the details are quite different from any of them:\n+\n+     [1] G. Ramalingam, T. Reps, An Incremental Algorithm for Maintaining the\n+\t Dominator Tree of a Reducible Flowgraph\n+     [2]  V. C. Sreedhar, G. R. Gao, Y.-F. Lee: Incremental computation of\n+\t  dominator trees\n+     [3]  K. D. Cooper, T. J. Harvey and K. Kennedy: A Simple, Fast Dominance\n+\t  Algorithm\n+\n+     First, we use the following heuristics to decrease the size of the BBS\n+     set:\n+       a) if BB has a single predecessor, then its immediate dominator is this\n+\t  predecessor\n+       additionally, if CONSERVATIVE is true:\n+       b) if all the predecessors of BB except for one (X) are dominated by BB,\n+\t  then X is the immediate dominator of BB\n+       c) if the nearest common ancestor of the predecessors of BB is X and\n+\t  X -> BB is an edge in CFG, then X is the immediate dominator of BB\n+\n+     Then, we need to establish the dominance relation among the basic blocks\n+     in BBS.  We split the dominance tree by removing the immediate dominator\n+     edges from BBS, creating a forrest F.  We form a graph G whose vertices\n+     are BBS and ENTRY and X -> Y is an edge of G if there exists an edge\n+     X' -> Y in CFG such that X' belongs to the tree of the dominance forrest\n+     whose root is X.  We then determine dominance tree of G.  Note that\n+     for X, Y in BBS, X dominates Y in CFG if and only if X dominates Y in G.\n+     In this step, we can use arbitrary algorithm to determine dominators.\n+     We decided to prefer the algorithm [3] to the algorithm of\n+     Lengauer and Tarjan, since the set BBS is usually small (rarely exceeding\n+     10 during gcc bootstrap), and [3] should perform better in this case.\n+\n+     Finally, we need to determine the immediate dominators for the basic\n+     blocks of BBS.  If the immediate dominator of X in G is Y, then\n+     the immediate dominator of X in CFG belongs to the tree of F rooted in\n+     Y.  We process the dominator tree T of G recursively, starting from leaves.\n+     Suppose that X_1, X_2, ..., X_k are the sons of Y in T, and that the\n+     subtrees of the dominance tree of CFG rooted in X_i are already correct.\n+     Let G' be the subgraph of G induced by {X_1, X_2, ..., X_k}.  We make\n+     the following observations:\n+       (i) the immediate dominator of all blocks in a strongly connected\n+\t   component of G' is the same\n+       (ii) if X has no predecessors in G', then the immediate dominator of X\n+\t    is the nearest common ancestor of the predecessors of X in the\n+\t    subtree of F rooted in Y\n+     Therefore, it suffices to find the topological ordering of G', and\n+     process the nodes X_i in this order using the rules (i) and (ii).\n+     Then, we contract all the nodes X_i with Y in G, so that the further\n+     steps work correctly.  */\n+\n+  if (!conservative)\n+    {\n+      /* Split the tree now.  If the idoms of blocks in BBS are not\n+\t conservatively correct, setting the dominators using the\n+\t heuristics in prune_bbs_to_update_dominators could\n+\t create cycles in the dominance \"tree\", and cause ICE.  */\n+      for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n+\tset_immediate_dominator (CDI_DOMINATORS, bb, NULL);\n+    }\n+\n+  prune_bbs_to_update_dominators (bbs, conservative);\n+  n = VEC_length (basic_block, bbs);\n+\n+  if (n == 0)\n+    return;\n \n-  while (changed)\n+  if (n == 1)\n     {\n-      changed = 0;\n-      for (i = 0; i < n; i++)\n+      bb = VEC_index (basic_block, bbs, 0);\n+      set_immediate_dominator (CDI_DOMINATORS, bb,\n+\t\t\t       recompute_dominator (CDI_DOMINATORS, bb));\n+      return;\n+    }\n+\n+  /* Construct the graph G.  */\n+  map = pointer_map_create ();\n+  for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n+    {\n+      /* If the dominance tree is conservatively correct, split it now.  */\n+      if (conservative)\n+\tset_immediate_dominator (CDI_DOMINATORS, bb, NULL);\n+      *pointer_map_insert (map, bb) = (void *) (size_t) i;\n+    }\n+  *pointer_map_insert (map, ENTRY_BLOCK_PTR) = (void *) (size_t) n;\n+\n+  g = new_graph (n + 1);\n+  for (y = 0; y < g->n_vertices; y++)\n+    g->vertices[y].data = BITMAP_ALLOC (NULL);\n+  for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n+    {\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n-\t  old_dom = get_immediate_dominator (dir, bbs[i]);\n-\t  new_dom = recount_dominator (dir, bbs[i]);\n-\t  if (old_dom != new_dom)\n-\t    {\n-\t      changed = 1;\n-\t      set_immediate_dominator (dir, bbs[i], new_dom);\n-\t    }\n+\t  dom = root_of_dom_tree (CDI_DOMINATORS, e->src);\n+\t  if (dom == bb)\n+\t    continue;\n+\n+\t  dom_i = (size_t) *pointer_map_contains (map, dom);\n+\n+\t  /* Do not include parallel edges to G.  */\n+\t  if (bitmap_bit_p (g->vertices[dom_i].data, i))\n+\t    continue;\n+\n+\t  bitmap_set_bit (g->vertices[dom_i].data, i);\n+\t  add_edge (g, dom_i, i);\n \t}\n     }\n+  for (y = 0; y < g->n_vertices; y++)\n+    BITMAP_FREE (g->vertices[y].data);\n+  pointer_map_destroy (map);\n+\n+  /* Find the dominator tree of G.  */\n+  son = XNEWVEC (int, n + 1);\n+  brother = XNEWVEC (int, n + 1);\n+  parent = XNEWVEC (int, n + 1);\n+  graphds_domtree (g, n, parent, son, brother);\n+\n+  /* Finally, traverse the tree and find the immediate dominators.  */\n+  for (y = n; son[y] != -1; y = son[y])\n+    continue;\n+  while (y != -1)\n+    {\n+      determine_dominators_for_sons (g, bbs, y, son, brother);\n+\n+      if (brother[y] != -1)\n+\t{\n+\t  y = brother[y];\n+\t  while (son[y] != -1)\n+\t    y = son[y];\n+\t}\n+      else\n+\ty = parent[y];\n+    }\n+\n+  free (son);\n+  free (brother);\n+  free (parent);\n \n-  for (i = 0; i < n; i++)\n-    gcc_assert (get_immediate_dominator (dir, bbs[i]));\n+  free_graph (g);\n }\n \n void"}, {"sha": "b9dacc9b3e33a100a4767d4dab7c8b6dbaafbe4f", "filename": "gcc/et-forest.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -747,3 +747,20 @@ et_below (struct et_node *down, struct et_node *up)\n \n   return !d->next || d->next->min + d->depth >= 0;\n }\n+\n+/* Returns the root of the tree that contains NODE.  */\n+\n+struct et_node *\n+et_root (struct et_node *node)\n+{\n+  struct et_occ *occ = node->rightmost_occ, *r;\n+\n+  /* The root of the tree corresponds to the rightmost occurence in the\n+     represented path.  */\n+  et_splay (occ);\n+  for (r = occ; r->next; r = r->next)\n+    continue;\n+  et_splay (r);\n+\n+  return r->of;\n+}"}, {"sha": "fd25cbed194f550de73e5bd3d8c6a84e25363d9c", "filename": "gcc/et-forest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fet-forest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fet-forest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.h?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -79,6 +79,7 @@ void et_set_father (struct et_node *, struct et_node *);\n void et_split (struct et_node *);\n struct et_node *et_nca (struct et_node *, struct et_node *);\n bool et_below (struct et_node *, struct et_node *);\n+struct et_node *et_root (struct et_node *);\n \n #ifdef __cplusplus\n }"}, {"sha": "461e26c855c490fd17c8490147e5523b514aa9c2", "filename": "gcc/gcse.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -4829,8 +4829,7 @@ static void\n hoist_code (void)\n {\n   basic_block bb, dominated;\n-  basic_block *domby;\n-  unsigned int domby_len;\n+  VEC (basic_block, heap) *domby;\n   unsigned int i,j;\n   struct expr **index_map;\n   struct expr *expr;\n@@ -4852,7 +4851,7 @@ hoist_code (void)\n       int found = 0;\n       int insn_inserted_p;\n \n-      domby_len = get_dominated_by (CDI_DOMINATORS, bb, &domby);\n+      domby = get_dominated_by (CDI_DOMINATORS, bb);\n       /* Examine each expression that is very busy at the exit of this\n \t block.  These are the potentially hoistable expressions.  */\n       for (i = 0; i < hoist_vbeout[bb->index]->n_bits; i++)\n@@ -4865,9 +4864,8 @@ hoist_code (void)\n \t      /* We've found a potentially hoistable expression, now\n \t\t we look at every block BB dominates to see if it\n \t\t computes the expression.  */\n-\t      for (j = 0; j < domby_len; j++)\n+\t      for (j = 0; VEC_iterate (basic_block, domby, j, dominated); j++)\n \t\t{\n-\t\t  dominated = domby[j];\n \t\t  /* Ignore self dominance.  */\n \t\t  if (bb == dominated)\n \t\t    continue;\n@@ -4906,8 +4904,8 @@ hoist_code (void)\n       /* If we found nothing to hoist, then quit now.  */\n       if (! found)\n         {\n-\t  free (domby);\n-\tcontinue;\n+\t  VEC_free (basic_block, heap, domby);\n+\t  continue;\n \t}\n \n       /* Loop over all the hoistable expressions.  */\n@@ -4923,9 +4921,8 @@ hoist_code (void)\n \t      /* We've found a potentially hoistable expression, now\n \t\t we look at every block BB dominates to see if it\n \t\t computes the expression.  */\n-\t      for (j = 0; j < domby_len; j++)\n+\t      for (j = 0; VEC_iterate (basic_block, domby, j, dominated); j++)\n \t\t{\n-\t\t  dominated = domby[j];\n \t\t  /* Ignore self dominance.  */\n \t\t  if (bb == dominated)\n \t\t    continue;\n@@ -4976,7 +4973,7 @@ hoist_code (void)\n \t\t}\n \t    }\n \t}\n-      free (domby);\n+      VEC_free (basic_block, heap, domby);\n     }\n \n   free (index_map);"}, {"sha": "1496e09a0281206a21cf2823d2922693c2baf45d", "filename": "gcc/graphds.c", "status": "added", "additions": 473, "deletions": 0, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fgraphds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fgraphds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphds.c?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -0,0 +1,473 @@\n+/* Graph representation and manipulation functions.\n+   Copyright (C) 2007\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"obstack.h\"\n+#include \"bitmap.h\"\n+#include \"vec.h\"\n+#include \"vecprim.h\"\n+#include \"graphds.h\"\n+\n+/* Dumps graph G into F.  */\n+\n+void\n+dump_graph (FILE *f, struct graph *g)\n+{\n+  int i;\n+  struct edge *e;\n+\n+  for (i = 0; i < g->n_vertices; i++)\n+    {\n+      if (!g->vertices[i].pred\n+\t  && !g->vertices[i].succ)\n+\tcontinue;\n+\n+      fprintf (f, \"%d (%d)\\t<-\", i, g->vertices[i].component);\n+      for (e = g->vertices[i].pred; e; e = e->pred_next)\n+\tfprintf (f, \" %d\", e->src);\n+      fprintf (f, \"\\n\");\n+\n+      fprintf (f, \"\\t->\");\n+      for (e = g->vertices[i].succ; e; e = e->succ_next)\n+\tfprintf (f, \" %d\", e->dest);\n+      fprintf (f, \"\\n\");\n+    }\n+}\n+\n+/* Creates a new graph with N_VERTICES vertices.  */\n+\n+struct graph *\n+new_graph (int n_vertices)\n+{\n+  struct graph *g = XNEW (struct graph);\n+\n+  g->n_vertices = n_vertices;\n+  g->vertices = XCNEWVEC (struct vertex, n_vertices);\n+\n+  return g;\n+}\n+\n+/* Adds an edge from F to T to graph G.  The new edge is returned.  */\n+\n+struct edge *\n+add_edge (struct graph *g, int f, int t)\n+{\n+  struct edge *e = XNEW (struct edge);\n+  struct vertex *vf = &g->vertices[f], *vt = &g->vertices[t];\n+\n+\n+  e->src = f;\n+  e->dest = t;\n+\n+  e->pred_next = vt->pred;\n+  vt->pred = e;\n+\n+  e->succ_next = vf->succ;\n+  vf->succ = e;\n+\n+  return e;\n+}\n+\n+/* Moves all the edges incident with U to V.  */\n+\n+void\n+identify_vertices (struct graph *g, int v, int u)\n+{\n+  struct vertex *vv = &g->vertices[v];\n+  struct vertex *uu = &g->vertices[u];\n+  struct edge *e, *next;\n+\n+  for (e = uu->succ; e; e = next)\n+    {\n+      next = e->succ_next;\n+\n+      e->src = v;\n+      e->succ_next = vv->succ;\n+      vv->succ = e;\n+    }\n+  uu->succ = NULL;\n+\n+  for (e = uu->pred; e; e = next)\n+    {\n+      next = e->pred_next;\n+\n+      e->dest = v;\n+      e->pred_next = vv->pred;\n+      vv->pred = e;\n+    }\n+  uu->pred = NULL;\n+}\n+\n+/* Helper function for graphds_dfs.  Returns the source vertex of E, in the\n+   direction given by FORWARD.  */\n+\n+static inline int\n+dfs_edge_src (struct edge *e, bool forward)\n+{\n+  return forward ? e->src : e->dest;\n+}\n+\n+/* Helper function for graphds_dfs.  Returns the destination vertex of E, in\n+   the direction given by FORWARD.  */\n+\n+static inline int\n+dfs_edge_dest (struct edge *e, bool forward)\n+{\n+  return forward ? e->dest : e->src;\n+}\n+\n+/* Helper function for graphds_dfs.  Returns the first edge after E (including\n+   E), in the graph direction given by FORWARD, that belongs to SUBGRAPH.  */\n+\n+static inline struct edge *\n+foll_in_subgraph (struct edge *e, bool forward, bitmap subgraph)\n+{\n+  int d;\n+\n+  if (!subgraph)\n+    return e;\n+\n+  while (e)\n+    {\n+      d = dfs_edge_dest (e, forward);\n+      if (bitmap_bit_p (subgraph, d))\n+\treturn e;\n+\n+      e = forward ? e->succ_next : e->pred_next;\n+    }\n+\n+  return e;\n+}\n+\n+/* Helper function for graphds_dfs.  Select the first edge from V in G, in the\n+   direction given by FORWARD, that belongs to SUBGRAPH.  */\n+\n+static inline struct edge *\n+dfs_fst_edge (struct graph *g, int v, bool forward, bitmap subgraph)\n+{\n+  struct edge *e;\n+\n+  e = (forward ? g->vertices[v].succ : g->vertices[v].pred);\n+  return foll_in_subgraph (e, forward, subgraph);\n+}\n+\n+/* Helper function for graphds_dfs.  Returns the next edge after E, in the\n+   graph direction given by FORWARD, that belongs to SUBGRAPH.  */\n+\n+static inline struct edge *\n+dfs_next_edge (struct edge *e, bool forward, bitmap subgraph)\n+{\n+  return foll_in_subgraph (forward ? e->succ_next : e->pred_next,\n+\t\t\t   forward, subgraph);\n+}\n+\n+/* Runs dfs search over vertices of G, from NQ vertices in queue QS.\n+   The vertices in postorder are stored into QT.  If FORWARD is false,\n+   backward dfs is run.  If SUBGRAPH is not NULL, it specifies the\n+   subgraph of G to run DFS on.  Returns the number of the components\n+   of the graph (number of the restarts of DFS).  */\n+\n+int\n+graphds_dfs (struct graph *g, int *qs, int nq, VEC (int, heap) **qt,\n+\t     bool forward, bitmap subgraph)\n+{\n+  int i, tick = 0, v, comp = 0, top;\n+  struct edge *e;\n+  struct edge **stack = XNEWVEC (struct edge *, g->n_vertices);\n+  bitmap_iterator bi;\n+  unsigned av;\n+\n+  if (subgraph)\n+    {\n+      EXECUTE_IF_SET_IN_BITMAP (subgraph, 0, av, bi)\n+\t{\n+\t  g->vertices[av].component = -1;\n+\t  g->vertices[av].post = -1;\n+\t}\n+    }\n+  else\n+    {\n+      for (i = 0; i < g->n_vertices; i++)\n+\t{\n+\t  g->vertices[i].component = -1;\n+\t  g->vertices[i].post = -1;\n+\t}\n+    }\n+\n+  for (i = 0; i < nq; i++)\n+    {\n+      v = qs[i];\n+      if (g->vertices[v].post != -1)\n+\tcontinue;\n+\n+      g->vertices[v].component = comp++;\n+      e = dfs_fst_edge (g, v, forward, subgraph);\n+      top = 0;\n+\n+      while (1)\n+\t{\n+\t  while (e)\n+\t    {\n+\t      if (g->vertices[dfs_edge_dest (e, forward)].component\n+\t\t  == -1)\n+\t\tbreak;\n+\t      e = dfs_next_edge (e, forward, subgraph);\n+\t    }\n+\n+\t  if (!e)\n+\t    {\n+\t      if (qt)\n+\t\tVEC_safe_push (int, heap, *qt, v);\n+\t      g->vertices[v].post = tick++;\n+\n+\t      if (!top)\n+\t\tbreak;\n+\n+\t      e = stack[--top];\n+\t      v = dfs_edge_src (e, forward);\n+\t      e = dfs_next_edge (e, forward, subgraph);\n+\t      continue;\n+\t    }\n+\n+\t  stack[top++] = e;\n+\t  v = dfs_edge_dest (e, forward);\n+\t  e = dfs_fst_edge (g, v, forward, subgraph);\n+\t  g->vertices[v].component = comp - 1;\n+\t}\n+    }\n+\n+  free (stack);\n+\n+  return comp;\n+}\n+\n+/* Determines the strongly connected components of G, using the algorithm of\n+   Tarjan -- first determine the postorder dfs numbering in reversed graph,\n+   then run the dfs on the original graph in the order given by decreasing\n+   numbers assigned by the previous pass.  If SUBGRAPH is not NULL, it\n+   specifies the subgraph of G whose strongly connected components we want\n+   to determine.\n+   \n+   After running this function, v->component is the number of the strongly\n+   connected component for each vertex of G.  Returns the number of the\n+   sccs of G.  */\n+\n+int\n+graphds_scc (struct graph *g, bitmap subgraph)\n+{\n+  int *queue = XNEWVEC (int, g->n_vertices);\n+  VEC (int, heap) *postorder = NULL;\n+  int nq, i, comp;\n+  unsigned v;\n+  bitmap_iterator bi;\n+\n+  if (subgraph)\n+    {\n+      nq = 0;\n+      EXECUTE_IF_SET_IN_BITMAP (subgraph, 0, v, bi)\n+\t{\n+\t  queue[nq++] = v;\n+\t}\n+    }\n+  else\n+    {\n+      for (i = 0; i < g->n_vertices; i++)\n+\tqueue[i] = i;\n+      nq = g->n_vertices;\n+    }\n+\n+  graphds_dfs (g, queue, nq, &postorder, false, subgraph);\n+  gcc_assert (VEC_length (int, postorder) == (unsigned) nq);\n+\n+  for (i = 0; i < nq; i++)\n+    queue[i] = VEC_index (int, postorder, nq - i - 1);\n+  comp = graphds_dfs (g, queue, nq, NULL, true, subgraph);\n+\n+  free (queue);\n+  VEC_free (int, heap, postorder);\n+\n+  return comp;\n+}\n+\n+/* Runs CALLBACK for all edges in G.  */\n+\n+void\n+for_each_edge (struct graph *g, graphds_edge_callback callback)\n+{\n+  struct edge *e;\n+  int i;\n+\n+  for (i = 0; i < g->n_vertices; i++)\n+    for (e = g->vertices[i].succ; e; e = e->succ_next)\n+      callback (g, e);\n+}\n+\n+/* Releases the memory occupied by G.  */\n+\n+void\n+free_graph (struct graph *g)\n+{\n+  struct edge *e, *n;\n+  struct vertex *v;\n+  int i;\n+\n+  for (i = 0; i < g->n_vertices; i++)\n+    {\n+      v = &g->vertices[i];\n+      for (e = v->succ; e; e = n)\n+\t{\n+\t  n = e->succ_next;\n+\t  free (e);\n+\t}\n+    }\n+  free (g->vertices);\n+  free (g);\n+}\n+\n+/* Returns the nearest common ancestor of X and Y in tree whose parent\n+   links are given by PARENT.  MARKS is the array used to mark the\n+   vertices of the tree, and MARK is the number currently used as a mark.  */\n+\n+static int\n+tree_nca (int x, int y, int *parent, int *marks, int mark)\n+{\n+  if (x == -1 || x == y)\n+    return y;\n+\n+  /* We climb with X and Y up the tree, marking the visited nodes.  When\n+     we first arrive to a marked node, it is the common ancestor.  */\n+  marks[x] = mark;\n+  marks[y] = mark;\n+\n+  while (1)\n+    {\n+      x = parent[x];\n+      if (x == -1)\n+\tbreak;\n+      if (marks[x] == mark)\n+\treturn x;\n+      marks[x] = mark;\n+\n+      y = parent[y];\n+      if (y == -1)\n+\tbreak;\n+      if (marks[y] == mark)\n+\treturn y;\n+      marks[y] = mark;\n+    }\n+\n+  /* If we reached the root with one of the vertices, continue\n+     with the other one till we reach the marked part of the\n+     tree.  */\n+  if (x == -1)\n+    {\n+      for (y = parent[y]; marks[y] != mark; y = parent[y])\n+\tcontinue;\n+\n+      return y;\n+    }\n+  else\n+    {\n+      for (x = parent[x]; marks[x] != mark; x = parent[x])\n+\tcontinue;\n+\n+      return x;\n+    }\n+}\n+\n+/* Determines the dominance tree of G (stored in the PARENT, SON and BROTHER\n+   arrays), where the entry node is ENTRY.  */\n+\n+void\n+graphds_domtree (struct graph *g, int entry,\n+\t\t int *parent, int *son, int *brother)\n+{\n+  VEC (int, heap) *postorder = NULL;\n+  int *marks = XCNEWVEC (int, g->n_vertices);\n+  int mark = 1, i, v, idom;\n+  bool changed = true;\n+  struct edge *e;\n+\n+  /* We use a slight modification of the standard iterative algorithm, as\n+     described in\n+     \n+     K. D. Cooper, T. J. Harvey and K. Kennedy: A Simple, Fast Dominance\n+\tAlgorithm\n+\n+     sort vertices in reverse postorder\n+     foreach v\n+       dom(v) = everything\n+     dom(entry) = entry;\n+\n+     while (anything changes)\n+       foreach v\n+         dom(v) = {v} union (intersection of dom(p) over all predecessors of v)\n+\n+     The sets dom(v) are represented by the parent links in the current version\n+     of the dominance tree.  */\n+\n+  for (i = 0; i < g->n_vertices; i++)\n+    {\n+      parent[i] = -1;\n+      son[i] = -1;\n+      brother[i] = -1;\n+    }\n+  graphds_dfs (g, &entry, 1, &postorder, true, NULL);\n+  gcc_assert (VEC_length (int, postorder) == (unsigned) g->n_vertices);\n+  gcc_assert (VEC_index (int, postorder, g->n_vertices - 1) == entry);\n+\n+  while (changed)\n+    {\n+      changed = false;\n+\n+      for (i = g->n_vertices - 2; i >= 0; i--)\n+\t{\n+\t  v = VEC_index (int, postorder, i);\n+\t  idom = -1;\n+\t  for (e = g->vertices[v].pred; e; e = e->pred_next)\n+\t    {\n+\t      if (e->src != entry\n+\t\t  && parent[e->src] == -1)\n+\t\tcontinue;\n+\n+\t      idom = tree_nca (idom, e->src, parent, marks, mark++);\n+\t    }\n+\n+\t  if (idom != parent[v])\n+\t    {\n+\t      parent[v] = idom;\n+\t      changed = true;\n+\t    }\n+\t}\n+    }\n+\n+  free (marks);\n+  VEC_free (int, heap, postorder);\n+\n+  for (i = 0; i < g->n_vertices; i++)\n+    if (parent[i] != -1)\n+      {\n+\tbrother[i] = son[parent[i]];\n+\tson[parent[i]] = i;\n+      }\n+}"}, {"sha": "2aad4b00a7394022a631c8e738460fd80f33191f", "filename": "gcc/graphds.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fgraphds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Fgraphds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphds.h?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -0,0 +1,63 @@\n+/* Graph representation.\n+   Copyright (C) 2007\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/* Structure representing edge of a graph.  */\n+\n+struct edge\n+{\n+  int src, dest;\t/* Source and destination.  */\n+  struct edge *pred_next, *succ_next;\n+\t\t\t/* Next edge in predecessor and successor lists.  */\n+  void *data;\t\t/* Data attached to the edge.  */\n+};\n+\n+/* Structure representing vertex of a graph.  */\n+\n+struct vertex\n+{\n+  struct edge *pred, *succ;\n+\t\t\t/* Lists of predecessors and successors.  */\n+  int component;\t/* Number of dfs restarts before reaching the\n+\t\t\t   vertex.  */\n+  int post;\t\t/* Postorder number.  */\n+  void *data;\t\t/* Data attached to the vertex.  */\n+};\n+\n+/* Structure representing a graph.  */\n+\n+struct graph\n+{\n+  int n_vertices;\t/* Number of vertices.  */\n+  struct vertex *vertices;\n+\t\t\t/* The vertices.  */\n+};\n+\n+struct graph *new_graph (int);\n+void dump_graph (FILE *, struct graph *);\n+struct edge *add_edge (struct graph *, int, int);\n+void identify_vertices (struct graph *, int, int);\n+int graphds_dfs (struct graph *, int *, int,\n+\t\t VEC (int, heap) **, bool, bitmap);\n+int graphds_scc (struct graph *, bitmap);\n+void graphds_domtree (struct graph *, int, int *, int *, int *);\n+typedef void (*graphds_edge_callback) (struct graph *, struct edge *);\n+void for_each_edge (struct graph *, graphds_edge_callback);\n+void free_graph (struct graph *g);"}, {"sha": "291d1d91e5b135d6d78267fba5a4b5c3daef8473", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -2521,7 +2521,7 @@ perfect_nestify (struct loop *loop,\n \t\t\t   single_exit (loop)->src);\n   set_immediate_dominator (CDI_DOMINATORS, latchbb, bodybb);\n   set_immediate_dominator (CDI_DOMINATORS, olddest,\n-\t\t\t   recount_dominator (CDI_DOMINATORS, olddest));\n+\t\t\t   recompute_dominator (CDI_DOMINATORS, olddest));\n   /* Create the new iv.  */\n   oldivvar = VEC_index (tree, loopivs, 0);\n   ivvar = create_tmp_var (TREE_TYPE (oldivvar), \"perfectiv\");"}, {"sha": "f59feae78adc90de84bff7947e3f6a5d04cdcfdb", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -422,13 +422,13 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n \t  emit_insn_after (sequence, BB_END (set_zero));\n       \n \t  set_immediate_dominator (CDI_DOMINATORS, set_zero,\n-\t\t\t\t   recount_dominator (CDI_DOMINATORS,\n-\t\t\t\t\t\t      set_zero));\n+\t\t\t\t   recompute_dominator (CDI_DOMINATORS,\n+\t\t\t\t\t\t\tset_zero));\n \t}\n \n       set_immediate_dominator (CDI_DOMINATORS, new_preheader,\n-\t\t\t       recount_dominator (CDI_DOMINATORS,\n-\t\t\t\t\t\t  new_preheader));\n+\t\t\t       recompute_dominator (CDI_DOMINATORS,\n+\t\t\t\t\t\t    new_preheader));\n     }\n \n   /* Some targets (eg, C4x) need to initialize special looping"}, {"sha": "77d454f35bc77f6b70b563961cbf399498cefdb7", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -953,8 +953,8 @@ unroll_loop_runtime_iterations (struct loop *loop)\n {\n   rtx old_niter, niter, init_code, branch_code, tmp;\n   unsigned i, j, p;\n-  basic_block preheader, *body, *dom_bbs, swtch, ezc_swtch;\n-  unsigned n_dom_bbs;\n+  basic_block preheader, *body, swtch, ezc_swtch;\n+  VEC (basic_block, heap) *dom_bbs;\n   sbitmap wont_exit;\n   int may_exit_copy;\n   unsigned n_peel;\n@@ -972,21 +972,20 @@ unroll_loop_runtime_iterations (struct loop *loop)\n     opt_info = analyze_insns_in_loop (loop);\n   \n   /* Remember blocks whose dominators will have to be updated.  */\n-  dom_bbs = XCNEWVEC (basic_block, n_basic_blocks);\n-  n_dom_bbs = 0;\n+  dom_bbs = NULL;\n \n   body = get_loop_body (loop);\n   for (i = 0; i < loop->num_nodes; i++)\n     {\n-      unsigned nldom;\n-      basic_block *ldom;\n+      VEC (basic_block, heap) *ldom;\n+      basic_block bb;\n \n-      nldom = get_dominated_by (CDI_DOMINATORS, body[i], &ldom);\n-      for (j = 0; j < nldom; j++)\n-\tif (!flow_bb_inside_loop_p (loop, ldom[j]))\n-\t  dom_bbs[n_dom_bbs++] = ldom[j];\n+      ldom = get_dominated_by (CDI_DOMINATORS, body[i]);\n+      for (j = 0; VEC_iterate (basic_block, ldom, j, bb); j++)\n+\tif (!flow_bb_inside_loop_p (loop, bb))\n+\t  VEC_safe_push (basic_block, heap, dom_bbs, bb);\n \n-      free (ldom);\n+      VEC_free (basic_block, heap, ldom);\n     }\n   free (body);\n \n@@ -1105,7 +1104,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n     }\n \n   /* Recount dominators for outer blocks.  */\n-  iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, n_dom_bbs);\n+  iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, false);\n \n   /* And unroll loop.  */\n \n@@ -1177,8 +1176,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n \t     \"in runtime, %i insns\\n\",\n \t     max_unroll, num_loop_insns (loop));\n \n-  if (dom_bbs)\n-    free (dom_bbs);\n+  VEC_free (basic_block, heap, dom_bbs);\n }\n \n /* Decide whether to simply peel LOOP and how much.  */"}, {"sha": "6dc0d3e4203a4622163814f8f384d496a2876743", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -4336,11 +4336,11 @@ tree_duplicate_sese_region (edge entry, edge exit,\n \t\t\t    basic_block *region, unsigned n_region,\n \t\t\t    basic_block *region_copy)\n {\n-  unsigned i, n_doms;\n+  unsigned i;\n   bool free_region_copy = false, copying_header = false;\n   struct loop *loop = entry->dest->loop_father;\n   edge exit_copy;\n-  basic_block *doms;\n+  VEC (basic_block, heap) *doms;\n   edge redirected;\n   int total_freq = 0, entry_freq = 0;\n   gcov_type total_count = 0, entry_count = 0;\n@@ -4392,10 +4392,10 @@ tree_duplicate_sese_region (edge entry, edge exit,\n \n   /* Record blocks outside the region that are dominated by something\n      inside.  */\n-  doms = XNEWVEC (basic_block, n_basic_blocks);\n+  doms = NULL;\n   initialize_original_copy_tables ();\n \n-  n_doms = get_dominated_by_region (CDI_DOMINATORS, region, n_region, doms);\n+  doms = get_dominated_by_region (CDI_DOMINATORS, region, n_region);\n \n   if (entry->dest->count)\n     {\n@@ -4451,8 +4451,8 @@ tree_duplicate_sese_region (edge entry, edge exit,\n      region, but was dominated by something inside needs recounting as\n      well.  */\n   set_immediate_dominator (CDI_DOMINATORS, entry->dest, entry->src);\n-  doms[n_doms++] = get_bb_original (entry->dest);\n-  iterate_fix_dominators (CDI_DOMINATORS, doms, n_doms);\n+  VEC_safe_push (basic_block, heap, doms, get_bb_original (entry->dest));\n+  iterate_fix_dominators (CDI_DOMINATORS, doms, false);\n   free (doms);\n \n   /* Add the other PHI node arguments.  */\n@@ -5476,9 +5476,7 @@ remove_edge_and_dominated_blocks (edge e)\n \tVEC_safe_push (basic_block, heap, bbs_to_fix_dom, dbb);\n     }\n \n-  iterate_fix_dominators (CDI_DOMINATORS,\n-\t\t\t  VEC_address (basic_block, bbs_to_fix_dom),\n-\t\t\t  VEC_length (basic_block, bbs_to_fix_dom));\n+  iterate_fix_dominators (CDI_DOMINATORS, bbs_to_fix_dom, true);\n \n   BITMAP_FREE (df);\n   BITMAP_FREE (df_idom);"}, {"sha": "e8a05ed857bfb363e4fcfab659828bdf6a46dd9e", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f97d31f233e10870728947731db603b5dc0c9c/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=66f97d31f233e10870728947731db603b5dc0c9c", "patch": "@@ -577,6 +577,9 @@ thread_block (basic_block bb, bool noloop_only)\n       lookup_redirection_data (e, NULL, NO_INSERT)->do_not_duplicate = true;\n     }\n \n+  /* We do not update dominance info.  */\n+  free_dominance_info (CDI_DOMINATORS);\n+\n   /* Now create duplicates of BB.\n \n      Note that for a block with a high outgoing degree we can waste\n@@ -1057,9 +1060,6 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n       retval |= thread_through_loop_header (loop, may_peel_loop_headers);\n     }\n \n-  if (retval)\n-    free_dominance_info (CDI_DOMINATORS);\n-\n   if (dump_file && (dump_flags & TDF_STATS))\n     fprintf (dump_file, \"\\nJumps threaded: %lu\\n\",\n \t     thread_stats.num_threaded_edges);"}]}