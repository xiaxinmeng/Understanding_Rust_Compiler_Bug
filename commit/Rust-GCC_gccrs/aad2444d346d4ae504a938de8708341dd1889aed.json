{"sha": "aad2444d346d4ae504a938de8708341dd1889aed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFkMjQ0NGQzNDZkNGFlNTA0YTkzOGRlODcwODM0MWRkMTg4OWFlZA==", "commit": {"author": {"name": "Paul Koning", "email": "ni1d@arrl.net", "date": "2018-07-09T14:00:52Z"}, "committer": {"name": "Paul Koning", "email": "pkoning@gcc.gnu.org", "date": "2018-07-09T14:00:52Z"}, "message": "Improve code generation for pdp11 target.\n\n\t* config/pdp11/pdp11.c (pdp11_addr_cost): New function.\n\t(pdp11_insn_cost): New function.\n\t(pdp11_md_asm_adjust): New function.\n\t(TARGET_INVALID_WITHIN_DOLOOP): Define.\n\t(pdp11_rtx_costs): Update to match machine better.\n\t(output_addr_const_pdp11): Correct format mismatch warnings.\n\t* config/pdp11/pdp11.h (SLOW_BYTE_ACCESS): Correct definition.\n\t* config/pdp11/pdp11.md: General change to add base_cost and/or\n\tlength attributes for use by new pdp11_insn_cost function.\n\t(MIN_BRANCH): Correct definition.\n\t(MIN_SOB): Ditto.\n\t(doloop_end): Use standard pattern name for looping pattern.\n\t(doloop_end_nocc): New.\n\t(movsf): Add another constraint alternative.\n\t(zero_extendqihi2): Add constraint alternatives for not in place\n\textend.\n\t(zero_extendhisi2): Remove.\n\t(shift patterns): Add CC handling variants.\n\t(bswaphi2): New.\n\t(bswapsi2): New.\n\t(rothi3): New.\n\t(define_peephole2): New peephole to recognize mov that sets CC for\n\tsubsequent test.\n\nFrom-SVN: r262519", "tree": {"sha": "8217f61c2e480fd7af7ef37b10122f424ce73595", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8217f61c2e480fd7af7ef37b10122f424ce73595"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aad2444d346d4ae504a938de8708341dd1889aed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aad2444d346d4ae504a938de8708341dd1889aed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aad2444d346d4ae504a938de8708341dd1889aed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aad2444d346d4ae504a938de8708341dd1889aed/comments", "author": null, "committer": null, "parents": [{"sha": "c36c567c59336e3b611c2961864f567995f98051", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c36c567c59336e3b611c2961864f567995f98051", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c36c567c59336e3b611c2961864f567995f98051"}], "stats": {"total": 994, "additions": 732, "deletions": 262}, "files": [{"sha": "706dd47af20dd30b8c87bfb5f6cc0ed9883d8f15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aad2444d346d4ae504a938de8708341dd1889aed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aad2444d346d4ae504a938de8708341dd1889aed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aad2444d346d4ae504a938de8708341dd1889aed", "patch": "@@ -1,3 +1,29 @@\n+2018-07-09  Paul Koning  <ni1d@arrl.net>\n+\n+\t* config/pdp11/pdp11.c (pdp11_addr_cost): New function.\n+\t(pdp11_insn_cost): New function.\n+\t(pdp11_md_asm_adjust): New function.\n+\t(TARGET_INVALID_WITHIN_DOLOOP): Define.\n+\t(pdp11_rtx_costs): Update to match machine better.\n+\t(output_addr_const_pdp11): Correct format mismatch warnings.\n+\t* config/pdp11/pdp11.h (SLOW_BYTE_ACCESS): Correct definition.\n+\t* config/pdp11/pdp11.md: General change to add base_cost and/or\n+\tlength attributes for use by new pdp11_insn_cost function.\n+\t(MIN_BRANCH): Correct definition.\n+\t(MIN_SOB): Ditto.\n+\t(doloop_end): Use standard pattern name for looping pattern.\n+\t(doloop_end_nocc): New.\n+\t(movsf): Add another constraint alternative.\n+\t(zero_extendqihi2): Add constraint alternatives for not in place\n+\textend.\n+\t(zero_extendhisi2): Remove.\n+\t(shift patterns): Add CC handling variants.\n+\t(bswaphi2): New.\n+\t(bswapsi2): New.\n+\t(rothi3): New.\n+\t(define_peephole2): New peephole to recognize mov that sets CC for\n+\tsubsequent test.\n+\n 2018-07-09  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config/sparc/sparc.c (sparc_fold_builtin) <SPARC_BUILTIN_PDIST,"}, {"sha": "39081e3fb6dd97256329e2652b5ec0eb19cda41a", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 281, "deletions": 127, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aad2444d346d4ae504a938de8708341dd1889aed/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aad2444d346d4ae504a938de8708341dd1889aed/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=aad2444d346d4ae504a938de8708341dd1889aed", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"memmodel.h\"\n #include \"tm_p.h\"\n #include \"insn-config.h\"\n+#include \"insn-attr.h\"\n #include \"regs.h\"\n #include \"emit-rtl.h\"\n #include \"recog.h\"\n@@ -150,6 +151,11 @@ decode_pdp11_d (const struct real_format *fmt ATTRIBUTE_UNUSED,\n static const char *singlemove_string (rtx *);\n static bool pdp11_assemble_integer (rtx, unsigned int, int);\n static bool pdp11_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n+static int pdp11_addr_cost (rtx, machine_mode, addr_space_t, bool);\n+static int pdp11_insn_cost (rtx_insn *insn, bool speed);\n+static rtx_insn *pdp11_md_asm_adjust (vec<rtx> &, vec<rtx> &,\n+\t\t\t\t      vec<const char *> &,\n+\t\t\t\t      vec<rtx> &, HARD_REG_SET &);\n static bool pdp11_return_in_memory (const_tree, const_tree);\n static rtx pdp11_function_value (const_tree, const_tree, bool);\n static rtx pdp11_libcall_value (machine_mode, const_rtx);\n@@ -174,6 +180,8 @@ static bool pdp11_scalar_mode_supported_p (scalar_mode);\n #undef TARGET_ASM_INTEGER\n #define TARGET_ASM_INTEGER pdp11_assemble_integer\n \n+/* These two apply to Unix and GNU assembler; for DEC, they are\n+   overridden during option processing.  */\n #undef TARGET_ASM_OPEN_PAREN\n #define TARGET_ASM_OPEN_PAREN \"[\"\n #undef TARGET_ASM_CLOSE_PAREN\n@@ -182,6 +190,15 @@ static bool pdp11_scalar_mode_supported_p (scalar_mode);\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS pdp11_rtx_costs\n \n+#undef  TARGET_ADDRESS_COST\n+#define TARGET_ADDRESS_COST pdp11_addr_cost\n+\n+#undef  TARGET_INSN_COST\n+#define TARGET_INSN_COST pdp11_insn_cost\n+\n+#undef  TARGET_MD_ASM_ADJUST\n+#define TARGET_MD_ASM_ADJUST pdp11_md_asm_adjust\n+\n #undef TARGET_FUNCTION_ARG\n #define TARGET_FUNCTION_ARG pdp11_function_arg\n #undef TARGET_FUNCTION_ARG_ADVANCE\n@@ -271,6 +288,9 @@ static bool pdp11_scalar_mode_supported_p (scalar_mode);\n \n #undef  TARGET_CAN_CHANGE_MODE_CLASS\n #define TARGET_CAN_CHANGE_MODE_CLASS pdp11_can_change_mode_class\n+\n+#undef TARGET_INVALID_WITHIN_DOLOOP\n+#define TARGET_INVALID_WITHIN_DOLOOP hook_constcharptr_const_rtx_insn_null\n \f\n /* A helper function to determine if REGNO should be saved in the\n    current function's stack frame.  */\n@@ -968,12 +988,8 @@ pdp11_assemble_integer (rtx x, unsigned int size, int aligned_p)\n }\n \n \n-/* Register to register moves are cheap if both are general registers.\n-   The same is true for FPU, but there we return cost of 3 rather than\n-   2 to make reload look at the constraints.  The raeson is that\n-   load/store double require extra care since load touches condition\n-   codes and store doesn't, which is (partly anyway) described by\n-   constraints.  */\n+/* Register to register moves are cheap if both are general\n+   registers.  */\n static int \n pdp11_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  reg_class_t c1, reg_class_t c2)\n@@ -983,151 +999,270 @@ pdp11_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n     return 2;\n   else if ((c1 >= LOAD_FPU_REGS && c1 <= FPU_REGS && c2 == LOAD_FPU_REGS) ||\n \t   (c2 >= LOAD_FPU_REGS && c2 <= FPU_REGS && c1 == LOAD_FPU_REGS))\n-    return 3;\n+    return 2;\n   else\n     return 22;\n }\n \n-\n+/* This tries to approximate what pdp11_insn_cost would do, but\n+   without visibility into the actual instruction being generated it's\n+   inevitably a rough approximation.  */\n static bool\n-pdp11_rtx_costs (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n-\t\t int opno ATTRIBUTE_UNUSED, int *total,\n-\t\t bool speed ATTRIBUTE_UNUSED)\n+pdp11_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t\t int opno ATTRIBUTE_UNUSED, int *total, bool speed)\n {\n-  int code = GET_CODE (x);\n-\n+  const int code = GET_CODE (x);\n+  const int asize = (mode == QImode) ? 2 : GET_MODE_SIZE (mode);\n+  rtx src, dest;\n+  \n   switch (code)\n     {\n     case CONST_INT:\n-      if (INTVAL (x) == 0 || INTVAL (x) == -1 || INTVAL (x) == 1)\n+      /* Treat -1, 0, 1 as things that are optimized as clr or dec\n+\t etc. though that doesn't apply to every case.  */\n+      if (INTVAL (x) >= -1 && INTVAL (x) <= 1)\n \t{\n \t  *total = 0;\n \t  return true;\n \t}\n-      /* FALLTHRU */\n-\n+      /* FALL THROUGH.  */\n+    case REG:\n+    case MEM:\n     case CONST:\n     case LABEL_REF:\n     case SYMBOL_REF:\n-      /* Twice as expensive as REG.  */\n-      *total = 2;\n-      return true;\n-\n     case CONST_DOUBLE:\n-      /* Twice (or 4 times) as expensive as 16 bit.  */\n-      *total = 4;\n+      *total = pdp11_addr_cost (x, mode, ADDR_SPACE_GENERIC, speed);\n       return true;\n+    }\n \n-    case MULT:\n-      /* ??? There is something wrong in MULT because MULT is not \n-         as cheap as total = 2 even if we can shift!  */\n-      /* If optimizing for size make mult etc cheap, but not 1, so when \n-         in doubt the faster insn is chosen.  */\n-      if (optimize_size)\n-        *total = COSTS_N_INSNS (2);\n-      else\n-        *total = COSTS_N_INSNS (11);\n-      return false;\n+  /* Pick up source and dest.  We don't necessarily use the standard\n+     recursion in rtx_costs to figure the cost, because that would\n+     count the destination operand twice for three-operand insns.\n+     Also, this way we can catch special cases like move of zero, or\n+     add one.  */\n+  if (GET_RTX_LENGTH (code) > 1)\n+    src = XEXP (x, 1);\n+  dest = XEXP (x, 0);\n+      \n+  /* If optimizing for size, claim everything costs 2 per word, plus\n+     whatever the operands require.  */\n+  if (!speed)\n+    *total = asize;\n+  else\n+    {\n+      if (FLOAT_MODE_P (mode))\n+\t{\n+\t  switch (code)\n+\t    {\n+\t    case MULT:\n+\t    case DIV:\n+\t    case MOD:\n+\t      *total = 20;\n+\t      break;\n \n-    case DIV:\n-      if (optimize_size)\n-        *total = COSTS_N_INSNS (2);\n-      else\n-        *total = COSTS_N_INSNS (25);\n-      return false;\n+\t    case COMPARE:\n+\t      *total = 4;\n+\t      break;\n \n-    case MOD:\n-      if (optimize_size)\n-        *total = COSTS_N_INSNS (2);\n+\t    case PLUS:\n+\t    case MINUS:\n+\t      *total = 6;\n+\t      break;\n+\n+\t    default:\n+\t      *total = 2;\n+\t      break;\n+\t    }\n+\t}\n       else\n-        *total = COSTS_N_INSNS (26);\n-      return false;\n+\t{\n+\t  /* Integer operations are scaled for SI and DI modes, though the\n+\t     scaling is not exactly accurate.  */\n+\t  switch (code)\n+\t    {\n+\t    case MULT:\n+\t      *total = 5 * asize * asize;\n+\t      break;\n \n-    case ABS:\n-      /* Equivalent to length, so same for optimize_size.  */\n-      *total = COSTS_N_INSNS (3);\n-      return false;\n+\t    case DIV:\n+\t      *total = 10 * asize * asize;\n+\t      break;\n+\t  \n+\t    case MOD:\n+\t      /* Fake value because it's accounted for under DIV, since we\n+\t\t use a divmod pattern.  */\n+\t      total = 0;\n+\t      break;\n \n-    case ZERO_EXTEND:\n-      /* Only used for qi->hi.  */\n-      *total = COSTS_N_INSNS (1);\n-      return false;\n+\t    case ASHIFT:\n+\t    case ASHIFTRT:\n+\t    case LSHIFTRT:\n+\t      /* This is a bit problematic because the cost depends on the\n+\t\t shift amount.  Make it <asize> for now, which is for the\n+\t\t case of a one bit shift.  */\n+\t      *total = asize;\n+\t      break;\n+\t  \n+\t    default:\n+\t      *total = asize;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  \n+  /* Now see if we're looking at a SET.  If yes, then look at the\n+     source to see if this is a move or an arithmetic operation, and\n+     continue accordingly to handle the operands.  */\n+  if (code == SET)\n+    {\n+      switch (GET_CODE (src))\n+\t{\n+\tcase REG:\n+\tcase MEM:\n+\tcase CONST_INT:\n+\tcase CONST:\n+\tcase LABEL_REF:\n+\tcase SYMBOL_REF:\n+\tcase CONST_DOUBLE:\n+\t  /* It's a move.  */\n+\t  *total += pdp11_addr_cost (dest, mode, ADDR_SPACE_GENERIC, speed);\n+\t  if (src != const0_rtx)\n+\t    *total += pdp11_addr_cost (src, mode, ADDR_SPACE_GENERIC, speed);\n+\t  return true;\n+\tdefault:\n+\t  /* Not a move.  Get the cost of the source operand and add\n+\t     that in, but not the destination operand since we're\n+\t     dealing with read/modify/write operands.  */\n+\t  *total += rtx_cost (src, mode, (enum rtx_code) outer_code, 1, speed);\n+\t  return true;\n+\t}\n+    }\n+  else if (code == PLUS || code == MINUS)\n+    {\n+      if (GET_CODE (src) == CONST_INT &&\n+\t  (INTVAL (src) == 1 || INTVAL (src) == -1))\n+\t{\n+\t  *total += rtx_cost (dest, mode, (enum rtx_code) outer_code, 0, speed);\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n \n-    case SIGN_EXTEND:\n-      if (mode == HImode)\n-      \t*total = COSTS_N_INSNS (1);\n-      else if (mode == SImode)\n-\t*total = COSTS_N_INSNS (6);\n-      else\n-\t*total = COSTS_N_INSNS (2);\n-      return false;\n-\n-    case ASHIFT:\n-    case ASHIFTRT:\n-      if (optimize_size)\n-        *total = COSTS_N_INSNS (1);\n-      else if (mode ==  QImode)\n-        {\n-          if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n-   \t    *total = COSTS_N_INSNS (8); /* worst case */\n-          else\n-\t    *total = COSTS_N_INSNS (INTVAL (XEXP (x, 1)));\n-        }\n-      else if (mode == HImode)\n-        {\n-          if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-            {\n-\t      if (abs (INTVAL (XEXP (x, 1))) == 1)\n-                *total = COSTS_N_INSNS (1);\n-              else\n-\t        *total = COSTS_N_INSNS (2.5 + 0.5 * INTVAL (XEXP (x, 1)));\n-            }\n-          else\n-            *total = COSTS_N_INSNS (10); /* worst case */\n-        }\n-      else if (mode == SImode)\n-        {\n-          if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t    *total = COSTS_N_INSNS (2.5 + 0.5 * INTVAL (XEXP (x, 1)));\n-          else /* worst case */\n-            *total = COSTS_N_INSNS (18);\n-        }\n-      return false;\n-\n-    case LSHIFTRT:\n-      if (optimize_size)\n-        *total = COSTS_N_INSNS (2);\n-      else if (mode ==  QImode)\n-        {\n-          if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n-   \t    *total = COSTS_N_INSNS (12); /* worst case */\n-          else\n-\t    *total = COSTS_N_INSNS (1 + INTVAL (XEXP (x, 1)));\n-        }\n-      else if (mode == HImode)\n-        {\n-          if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-            {\n-\t      if (abs (INTVAL (XEXP (x, 1))) == 1)\n-                *total = COSTS_N_INSNS (2);\n-              else\n-\t        *total = COSTS_N_INSNS (3.5 + 0.5 * INTVAL (XEXP (x, 1)));\n-            }\n-          else\n-            *total = COSTS_N_INSNS (12); /* worst case */\n-        }\n-      else if (mode == SImode)\n-        {\n-          if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t    *total = COSTS_N_INSNS (3.5 + 0.5 * INTVAL (XEXP (x, 1)));\n-          else /* worst case */\n-            *total = COSTS_N_INSNS (20);\n-        }\n-      return false;\n+/* Return cost of accessing the supplied operand.  Registers are free.\n+   Anything else starts with a cost of two.  Add to that for memory\n+   references the memory accesses of the addressing mode (if any) plus\n+   the data reference; for other operands just the memory access (if\n+   any) for the mode.  */\n+static int\n+pdp11_addr_cost (rtx addr, machine_mode mode, addr_space_t as ATTRIBUTE_UNUSED,\n+\t\t bool speed)\n+{\n+  int cost = 0;\n+  \n+  if (GET_CODE (addr) != REG)\n+    {\n+      if (!simple_memory_operand (addr, mode))\n+\tcost = 2;\n+\n+      /* If optimizing for speed, account for the memory reference if\n+\t any.  */\n+      if (speed && !CONSTANT_P (addr))\n+\tcost += (mode == QImode) ? 2 : GET_MODE_SIZE (mode);\n+    }\n+  return cost;\n+}\n \n+\n+static int\n+pdp11_insn_cost (rtx_insn *insn, bool speed)\n+{\n+  int base_cost, i;\n+  rtx pat, set, dest, src, src2;\n+  machine_mode mode;\n+  const char *fmt;\n+  enum rtx_code op;\n+  \n+  if (recog_memoized (insn) < 0)\n+    return 0;\n+\n+  /* If optimizing for size, we want the insn size.  */\n+  if (!speed)\n+    return get_attr_length (insn);\n+  else\n+    {\n+      /* Optimizing for speed.  Get the base cost of the insn, then\n+\t adjust for the cost of accessing operands.  Zero means use\n+\t the length as the cost even when optimizing for speed.  */\n+      base_cost = get_attr_base_cost (insn);\n+      if (base_cost <= 0)\n+\tbase_cost = get_attr_length (insn);\n+    }\n+  /* Look for the operands.  Often we have a PARALLEL that's either\n+     the actual operation plus a clobber, or the implicit compare plus\n+     the actual operation.  Find the actual operation.  */\n+  pat = PATTERN (insn);\n+  \n+  if (GET_CODE (pat) == PARALLEL)\n+    {\n+      set = XVECEXP (pat, 0, 0);\n+      if (GET_CODE (set) != SET || GET_CODE (XEXP (set, 1)) == COMPARE)\n+\tset = XVECEXP (pat, 0, 1);\n+      if (GET_CODE (set) != SET || GET_CODE (XEXP (set, 1)) == COMPARE)\n+\treturn 0;\n+    }\n+  else\n+    {\n+      set = pat;\n+      if (GET_CODE (set) != SET)\n+\treturn 0;\n+    }\n+  \n+  /* Pick up the SET source and destination RTL.  */\n+  dest = XEXP (set, 0);\n+  src = XEXP (set, 1);\n+  mode = GET_MODE (dest);\n+\n+  /* See if we have a move, or some arithmetic operation.  If a move,\n+     account for source and destination operand costs.  Otherwise,\n+     account for the destination and for the second operand of the\n+     operation -- the first is also destination and we don't want to\n+     double-count it.  */\n+  base_cost += pdp11_addr_cost (dest, mode, ADDR_SPACE_GENERIC, speed);\n+  op = GET_CODE (src);\n+  switch (op)\n+    {\n+    case REG:\n+    case MEM:\n+    case CONST_INT:\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_DOUBLE:\n+      /* It's a move.  */\n+      if (src != const0_rtx)\n+\tbase_cost += pdp11_addr_cost (src, mode, ADDR_SPACE_GENERIC, speed);\n+      return base_cost;\n     default:\n-      return false;\n+      break;\n     }\n+  /* There are some other cases where souce and dest are distinct.  */\n+  if (FLOAT_MODE_P (mode) &&\n+      (op == FLOAT_TRUNCATE || op == FLOAT_EXTEND || op == FIX || op == FLOAT))\n+    {\n+      src2 = XEXP (src, 0);\n+      base_cost += pdp11_addr_cost (src2, mode, ADDR_SPACE_GENERIC, speed);\n+    }\n+  /* Otherwise, pick up the second operand of the arithmetic\n+     operation, if it has two operands.  */\n+  else if (op != SUBREG && op != UNSPEC && GET_RTX_LENGTH (op) > 1)\n+    {\n+      src2 = XEXP (src, 1);\n+      base_cost += pdp11_addr_cost (src2, mode, ADDR_SPACE_GENERIC, speed);\n+    }\n+  \n+  return base_cost;\n }\n \n const char *\n@@ -1192,7 +1327,7 @@ output_jump (rtx *operands, int ccnz, int length)\n    zero, given the compare operation code in op and the compare\n    operands in x in and y.  */\n machine_mode\n-pdp11_cc_mode (enum rtx_code op, rtx x, rtx y)\n+pdp11_cc_mode (enum rtx_code op ATTRIBUTE_UNUSED, rtx x, rtx y ATTRIBUTE_UNUSED)\n {\n   if (FLOAT_MODE_P (GET_MODE (x)))\n     {\n@@ -1863,11 +1998,10 @@ output_addr_const_pdp11 (FILE *file, rtx x)\n       if (GET_MODE (x) == VOIDmode)\n \t{\n \t  /* We can use %o if the number is one word and positive.  */\n-\t  gcc_assert (!CONST_DOUBLE_HIGH (x));\n \t  if (TARGET_DEC_ASM)\n-\t    fprintf (file, \"%ho\", CONST_DOUBLE_LOW (x) & 0xffff);\n+\t    fprintf (file, \"%o\", (int) CONST_DOUBLE_LOW (x) & 0xffff);\n \t  else\n-\t    fprintf (file, \"%#ho\", CONST_DOUBLE_LOW (x) & 0xffff);\n+\t    fprintf (file, \"%#o\", (int) CONST_DOUBLE_LOW (x) & 0xffff);\n \t}\n       else\n \t/* We can't handle floating point constants;\n@@ -2138,6 +2272,26 @@ pdp11_shift_length (rtx *operands, machine_mode m, int code, bool simple_operand\n   return shift_size;\n }\n \n+/* Prepend to CLOBBERS hard registers that are automatically clobbered\n+   for an asm We do this for CC_REGNUM and FCC_REGNUM (on FPU target)\n+   to maintain source compatibility with the original cc0-based\n+   compiler.  */\n+\n+static rtx_insn *\n+pdp11_md_asm_adjust (vec<rtx> &/*outputs*/, vec<rtx> &/*inputs*/,\n+\t\t     vec<const char *> &/*constraints*/,\n+\t\t     vec<rtx> &clobbers, HARD_REG_SET &clobbered_regs)\n+{\n+  clobbers.safe_push (gen_rtx_REG (CCmode, CC_REGNUM));\n+  SET_HARD_REG_BIT (clobbered_regs, CC_REGNUM);\n+  if (TARGET_FPU)\n+    {\n+      clobbers.safe_push (gen_rtx_REG (CCmode, FCC_REGNUM));\n+      SET_HARD_REG_BIT (clobbered_regs, FCC_REGNUM);\n+    }\n+  return NULL;\n+}\n+\n /* Worker function for TARGET_TRAMPOLINE_INIT.\n \n    trampoline - how should i do it in separate i+d ? "}, {"sha": "f4c91863b7a2e809d441653ca1845122efacd368", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aad2444d346d4ae504a938de8708341dd1889aed/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aad2444d346d4ae504a938de8708341dd1889aed/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=aad2444d346d4ae504a938de8708341dd1889aed", "patch": "@@ -441,9 +441,8 @@ extern int may_call_alloca;\n \n #define MOVE_MAX 2\n \n-/* Nonzero if access to memory by byte is slow and undesirable. -\n-*/\n-#define SLOW_BYTE_ACCESS 0\n+/* Nonzero if access to memory by byte is no faster than by word.  */\n+#define SLOW_BYTE_ACCESS 1\n \n /* Do not break .stabs pseudos into continuations.  */\n #define DBX_CONTIN_LENGTH 0\n@@ -453,8 +452,7 @@ extern int may_call_alloca;\n \n #define SELECT_CC_MODE(OP,X,Y) pdp11_cc_mode (OP, X, Y)\n \n-/* Enable compare elimination pass.\n-   FIXME: how can this be enabled for two registers?  */\n+/* Enable compare elimination pass.  */\n #undef TARGET_FLAGS_REGNUM\n #define TARGET_FLAGS_REGNUM CC_REGNUM\n "}, {"sha": "e51f5381967e1a76e9e5eac42fc922832b53084d", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 422, "deletions": 130, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aad2444d346d4ae504a938de8708341dd1889aed/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aad2444d346d4ae504a938de8708341dd1889aed/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=aad2444d346d4ae504a938de8708341dd1889aed", "patch": "@@ -50,10 +50,15 @@\n    ;; End of hard registers\n    (FIRST_PSEUDO_REGISTER 18)\n    \n-   ;; Branch offset limits, as byte offsets from instruction address\n+   ;; Branch offset limits, as byte offsets from (pc).  That is NOT\n+   ;; the same thing as \"instruction address\" -- it is for backward\n+   ;; branches, but for forward branches it refers to the address\n+   ;; following the instruction.  So the max forward distance\n+   ;; matches what the processor handbook says, while the max\n+   ;; backward branch is 2 less than the book.\n    (MIN_BRANCH            -254)\n-   (MAX_BRANCH            256)\n-   (MIN_SOB               -126)\n+   (MAX_BRANCH            254)\n+   (MIN_SOB               -124)\n    (MAX_SOB               0)])\n \n ;; DF is 64 bit\n@@ -142,6 +147,9 @@\n ;; length default is 2 bytes each\n (define_attr \"length\" \"\" (const_int 2))\n \n+;; instruction base cost (not counting operands)\n+(define_attr \"base_cost\" \"\" (const_int 2))\n+\n ;; a user's asm statement\n (define_asm_attributes\n   [(set_attr \"type\" \"unknown\")\n@@ -178,7 +186,7 @@\n (define_insn \"*rts\"\n   [(return)]\n   \"\"\n-  \"rts pc\")\n+  \"rts\\tpc\")\n \n (define_insn \"blockage\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]\n@@ -217,6 +225,7 @@\n     return \\\"{cmpd|cmpf}\\t%0,%1\\\";\n }\"\n   [(set_attr \"length\" \"2,2,4,4\")\n+   (set_attr \"base_cost\" \"4\")\n    (set_attr \"type\" \"fp\")]) \n \n ;; Copy floating point processor condition code register to main CPU\n@@ -240,44 +249,77 @@\n    cmp<PDPint:isfx>\\t%0,%1\"\n   [(set_attr \"length\" \"2,2,4,4,4,6\")])\n \n-;; sob instruction - FIXME: this doesn't do anything, need to use doloop_end.\n-\n-(define_insn \"\"\n+;; sob instruction\n+;;\n+;; Do a define_expand because some alternatives clobber CC.\n+;; Some don't, but it isn't all that interesting to cover that case.\n+(define_insn_and_split \"doloop_end\"\n   [(set (pc)\n \t(if_then_else\n-\t (ne (plus:HI (match_operand:HI 0 \"register_operand\" \"+r\")\n-\t\t      (const_int -1))\n-\t     (const_int 0))\n+\t (ne (match_operand:HI 0 \"nonimmediate_operand\" \"+r,!m\")\n+\t     (const_int 1))\n \t (label_ref (match_operand 1 \"\" \"\"))\n \t (pc)))\n    (set (match_dup 0)\n \t(plus:HI (match_dup 0)\n \t\t (const_int -1)))]\n   \"TARGET_40_PLUS\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (pc)\n+\t\t   (if_then_else\n+\t\t    (ne (match_dup 0) (const_int 1))\n+\t\t    (label_ref (match_dup 1))\n+\t\t    (pc)))\n+\t      (set (match_dup 0)\n+\t\t   (plus:HI (match_dup 0)\n+\t\t\t (const_int -1)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+;; Note that there is a memory alternative here.  This is as documented\n+;; in gccint, which says that doloop_end, since it has both a jump and\n+;; an output interrupt \"must handle its own reloads\".  That translates\n+;; to: must accept memory operands as valid though they may be deprecated.\n+(define_insn \"doloop_end_nocc\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (match_operand:HI 0 \"nonimmediate_operand\" \"+r,!m\")\n+\t     (const_int 1))\n+\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:HI (match_dup 0)\n+\t      (const_int -1)))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_40_PLUS && reload_completed\"\n   \"*\n {\n+ rtx lb[1];\n+\n  if (get_attr_length (insn) == 2)\n     return \\\"sob\\t%0,%l1\\\";\n \n  /* emulate sob */\n- operands[2] = gen_label_rtx ();\n+ lb[0] = gen_label_rtx ();\n  output_asm_insn (\\\"dec\\t%0\\\", operands);\n- output_asm_insn (\\\"beq\\t%l2\\\", operands);\n+ output_asm_insn (\\\"beq\\t%l0\\\", lb);\n  output_asm_insn (\\\"jmp\\t%l1\\\", operands);\n  \n- output_asm_label (operands[2]);\n+ output_asm_label (lb[0]);\n  fputs (\\\":\\\\n\\\", asm_out_file);\n \n  return \\\"\\\";\n }\"\n-  [(set (attr \"length\") (if_then_else (ior (lt (minus (match_dup 0)\n-\t\t\t\t\t\t       (pc))\n-\t\t\t\t\t\t(const_int MIN_SOB))\n-\t\t\t\t\t   (gt (minus (match_dup 0)\n-\t\t\t\t\t\t       (pc))\n-\t\t\t\t\t\t(const_int MAX_SOB)))\n-\t\t\t\t      (const_int 8)\n-\t\t\t\t      (const_int 2)))])\n+  [(set (attr \"length\")\n+        (if_then_else (eq (symbol_ref (\"which_alternative\")) (const_int 1))\n+                          (const_int 10)\n+                          (if_then_else (ior (lt (minus (match_dup 1) (pc))\n+\t\t\t\t\t         (const_int MIN_SOB))\n+\t\t\t\t\t     (gt (minus (match_dup 1) (pc))\n+\t\t\t\t\t         (const_int MAX_SOB)))\n+\t\t\t\t        (const_int 8)\n+\t\t\t\t        (const_int 2))))])\n \n ;; These control RTL generation for conditional jump insns\n ;; and match them for register allocation.\n@@ -377,11 +419,16 @@\n \f\n ;; Move instructions\n \n+;; \"length\" is defined even though this pattern won't appear at\n+;; assembly language output time.  But the length is used by\n+;; pdp11_insn_cost, before the post-reload splitter adds the\n+;; CC clobber to the insn.\n (define_insn \"movdi\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,g\")\n \t(match_operand:DI 1 \"general_operand\" \"rN,g\"))]\n   \"\"\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"16,32\")])\n \n \n (define_insn \"*movdi_nocc\"\n@@ -396,7 +443,8 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,g,g\")\n \t(match_operand:SI 1 \"general_operand\" \"rN,IJ,IJ,g\"))]\n   \"\"\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"4,6,8,16\")])\n \n (define_insn \"*movsi_nocc\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,g,g\")\n@@ -410,7 +458,8 @@\n   [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n \t(match_operand:PDPint 1 \"general_operand\" \"rRN,Qi,rRN,Qi\"))]\n   \"\"\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4,4,6\")])\n \n ;; This splits all the integer moves: DI and SI modes as well as\n ;; the simple machine operations.\n@@ -497,15 +546,16 @@\n ;; but then extend and truncate register-to-register are NOP and\n ;; generate no code.\n (define_insn_and_split \"movsf\"\n-  [(set (match_operand:SF 0 \"float_nonimm_operand\" \"=a,fR,a,Q\")\n-        (match_operand:SF 1 \"float_operand\" \"fRG,a,FQ,a\"))]\n+  [(set (match_operand:SF 0 \"float_nonimm_operand\" \"=a,fR,a,Q,a\")\n+        (match_operand:SF 1 \"float_operand\" \"fRG,a,FQ,a,G\"))]\n   \"TARGET_FPU\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0)\n \t\t   (match_dup 1))\n \t      (clobber (reg:CC FCC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,2,4,4,2\")])\n   \n (define_insn \"*movsf<fcc_ccnz>\"\n   [(set (match_operand:SF 0 \"float_nonimm_operand\" \"=a,fR,a,Q,a\")\n@@ -598,17 +648,36 @@\n   [(set_attr \"length\" \"2,4\")])\n \n \f\n-;;- zero extension instructions\n+;;- zero extension instruction\n \n (define_insn_and_split \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n-\t(zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,0\")))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rD,Q,&r,&r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,0,rR,Q\")))]\n   \"\"\n   \"#\"\n   \"reload_completed\"\n   [(parallel [(set (match_dup 0) (zero_extend:HI (match_dup 1)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"{\n+    rtx r;\n+\n+    if (!REG_P (operands[0]))\n+      {\n+        r = gen_rtx_MEM (QImode, operands[0]);\n+        adjust_address (r, QImode, 1);\n+        emit_move_insn (r, const0_rtx);\n+        DONE;\n+      }\n+    else if (!rtx_equal_p (operands[0], operands[1]))\n+      {\n+        /* Alternatives 2 and 3 */\n+        emit_move_insn (operands[0], const0_rtx);\n+        r = gen_rtx_REG (QImode, REGNO (operands[0]));\n+        emit_insn (gen_iorqi3_nocc (r, r, operands[1]));\n+        DONE;\n+      }\n+  }\"\n+  [(set_attr \"length\" \"4,4,4,6\")])\n \n (define_insn \"*zero_extendqihi2<cc_cc>\"\n   [(parallel [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n@@ -618,19 +687,6 @@\n   \"bic\\t%#0177400,%0\"\n   [(set_attr \"length\" \"4,6\")])\n \t\t\t \n-(define_expand \"zero_extendhisi2\"\n-  [(set (subreg:HI \n-          (match_dup 0)\n-          2)\n-        (match_operand:HI 1 \"register_operand\" \"r\"))\n-   (set (subreg:HI \n-          (match_operand:SI 0 \"register_operand\" \"=r\")\n-          0)\n-        (const_int 0))]\n-  \"\"\n-  \"/* operands[1] = make_safe_from (operands[1], operands[0]); */\")\n-\n-\f\n ;;- sign extension instructions\n \n ;; We sometimes end up doing a register to register extend,\n@@ -663,7 +719,8 @@\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n   \"{ldcfd|movof}\\t%1,%0\"\n-  [(set_attr \"length\" \"2,4\")])\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"6\")])\n \n ;; movb sign extends if destination is a register\n (define_insn_and_split \"extendqihi2\"\n@@ -674,7 +731,8 @@\n   \"reload_completed\"\n   [(parallel [(set (match_dup 0) (sign_extend:HI (match_dup 1)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4\")])\n \n ;; MOVB clears V\n (define_insn \"*extendqihi2<cc_cc>\"\n@@ -693,7 +751,8 @@\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (sign_extend:SI (match_dup 1)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"10,6,6\")])\n \n (define_insn \"*extendhisi2_nocc\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=o,<,r\")\n@@ -760,7 +819,8 @@\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (float:DF (match_dup 1)))\n \t      (clobber (reg:CC FCC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"10,6,8\")])\n \n (define_insn \"*floatsidf2<fcc_cc>\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=a,a,a\")\n@@ -784,7 +844,8 @@\n      else \n        return \\\"setl\\;{ldcld|movif}\\t%1,%0\\;seti\\\";\n   \"\n-  [(set_attr \"length\" \"10,6,8\")])\n+  [(set_attr \"length\" \"10,6,8\")\n+   (set_attr \"base_cost\" \"12\")])\n \n (define_insn_and_split \"floathidf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n@@ -794,16 +855,18 @@\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (float:DF (match_dup 1)))\n \t      (clobber (reg:CC FCC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4\")])\n \n (define_insn \"*floathidf2<fcc_cc>\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n \t(float:DF (match_operand:HI 1 \"general_operand\" \"rR,Qi\")))\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n   \"{ldcid|movif}\\t%1,%0\"\n-  [(set_attr \"length\" \"2,4\")])\n-\t\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"12\")])\n+\n ;; cut float to int\n \n ;; Note: the hardware treats register destination as\n@@ -819,7 +882,8 @@\n   [(parallel [(set (match_dup 0) (fix:SI (fix:DF (match_dup 1))))\n \t      (clobber (reg:CC CC_REGNUM))\n \t      (clobber (reg:CC FCC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"10,6,8\")])\n \n ;; Note: this clobbers both sets of condition codes!\n (define_insn \"*fix_truncdfsi2_nocc\"\n@@ -841,7 +905,8 @@\n      else \n        return \\\"setl\\;{stcdl|movfi}\\t%1,%0\\;seti\\\";\n   \"\n-  [(set_attr \"length\" \"10,6,8\")])\n+  [(set_attr \"length\" \"10,6,8\")\n+   (set_attr \"base_cost\" \"12\")])\n \n (define_insn_and_split \"fix_truncdfhi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n@@ -852,7 +917,8 @@\n   [(parallel [(set (match_dup 0) (fix:HI (fix:DF (match_dup 1))))\n \t      (clobber (reg:CC CC_REGNUM))\n \t      (clobber (reg:CC FCC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4\")])\n \n ;; Note: this clobbers both sets of condition codes!\n (define_insn \"*fix_truncdfhi2_nocc\"\n@@ -862,7 +928,8 @@\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n   \"{stcdi|movfi}\\t%1,%0\"\n-  [(set_attr \"length\" \"2,4\")])\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"12\")])\n \n \f\n ;;- arithmetic instructions\n@@ -878,7 +945,8 @@\n   [(parallel [(set (match_dup 0)\n \t\t   (plus:DF (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC FCC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4\")])\n \n ;; Float add sets V if overflow from add\n (define_insn \"*adddf3<fcc_ccnz>\"\n@@ -888,7 +956,8 @@\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n   \"{addd|addf}\\t%2,%0\"\n-  [(set_attr \"length\" \"2,4\")])\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"6\")])\n \n (define_insn_and_split \"adddi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n@@ -899,7 +968,8 @@\n   \"reload_completed\"\n   [(parallel [(set (match_dup 0) (plus:DI (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"20,28,40,48\")])\n \n (define_insn \"*adddi3_nocc\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n@@ -939,7 +1009,8 @@\n \n   return \\\"\\\";\n }\"\n-  [(set_attr \"length\" \"20,28,40,48\")])\n+  [(set_attr \"length\" \"20,28,40,48\")\n+   (set_attr \"base_cost\" \"0\")])\n \n ;; Note that the register operand is not marked earlyclobber.\n ;; The reason is that SI values go in register pairs, so they\n@@ -959,7 +1030,8 @@\n   \"reload_completed\"\n   [(parallel [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"6,10,12,16\")])\n \n (define_insn \"*addsi3_nocc\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n@@ -986,7 +1058,8 @@\n \n   return \\\"\\\";\n }\"\n-  [(set_attr \"length\" \"6,10,12,16\")])\n+  [(set_attr \"length\" \"6,10,12,16\")\n+   (set_attr \"base_cost\" \"0\")])\n \n (define_insn_and_split \"addhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n@@ -998,7 +1071,8 @@\n   [(parallel [(set (match_dup 0)\n \t\t   (plus:HI (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4,4,6\")])\n \n ;; Add sets V if overflow from the add\n (define_insn \"*addhi3<cc_ccnz>\"\n@@ -1037,7 +1111,8 @@\n   [(parallel [(set (match_dup 0)\n \t\t   (minus:DF (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC FCC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4\")])\n \n (define_insn \"*subdf3<fcc_ccnz>\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n@@ -1046,7 +1121,8 @@\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n   \"{subd|subf}\\t%2,%0\"\n-  [(set_attr \"length\" \"2,4\")])\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"6\")])\n \n (define_insn_and_split \"subdi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n@@ -1057,7 +1133,8 @@\n   \"reload_completed\"\n   [(parallel [(set (match_dup 0) (minus:DI (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"20,28,40,48\")])\n \n (define_insn \"*subdi3_nocc\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n@@ -1097,7 +1174,8 @@\n \n   return \\\"\\\";\n }\"\n-  [(set_attr \"length\" \"20,28,40,48\")])\n+  [(set_attr \"length\" \"20,28,40,48\")\n+   (set_attr \"base_cost\" \"0\")])\n \n (define_insn_and_split \"subsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n@@ -1108,7 +1186,8 @@\n   \"reload_completed\"\n   [(parallel [(set (match_dup 0) (minus:SI (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"6,10,12,16\")])\n \n (define_insn \"*subsi3_nocc\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n@@ -1135,7 +1214,8 @@\n \n   return \\\"\\\";\n }\"\n-  [(set_attr \"length\" \"6,10,12,16\")])\n+  [(set_attr \"length\" \"6,10,12,16\")\n+   (set_attr \"base_cost\" \"0\")])\n \n (define_insn_and_split \"subhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n@@ -1147,7 +1227,8 @@\n   [(parallel [(set (match_dup 0)\n \t\t   (minus:HI (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4,4,6\")])\n \n ;; Note: the manual says that (minus m (const_int n)) is converted\n ;; to (plus m (const_int -n)) but that does not appear to be\n@@ -1200,7 +1281,8 @@\n     operands[1] = GEN_INT (~INTVAL (op1));\n   else\n     operands[1] = expand_unop (<MODE>mode, one_cmpl_optab, op1, 0, 1);\n-}\")\n+}\"\n+  [(set_attr \"length\" \"2,4,4,6\")])\n \n (define_insn_and_split \"*bic<mode>\"\n   [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n@@ -1236,7 +1318,8 @@\n   [(parallel [(set (match_dup 0)\n \t\t   (ior:PDPint (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4,4,6\")])\n \n (define_insn \"ior<mode>3<cc_cc>\"\n   [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n@@ -1258,7 +1341,8 @@\n   [(parallel [(set (match_dup 0)\n \t\t   (xor:HI (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4\")])\n \n (define_insn \"*xorhi3<cc_cc>\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n@@ -1280,7 +1364,8 @@\n   [(parallel [(set (match_dup 0)\n \t\t   (not:PDPint (match_dup 1)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4\")])\n \n (define_insn \"*one_cmpl<mode>2<cc_cc>\"\n   [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,Q\")\n@@ -1297,48 +1382,129 @@\n ;; used to reduce the amount of very similar code.\n ;;\n ;; First the insns used for small constant shifts.\n-(define_insn \"<code><mode>_sc\"\n+(define_insn_and_split \"<code><mode>_sc\"\n   [(set (match_operand:QHSint 0 \"nonimmediate_operand\" \"=rD,Q\")\n \t(SHF:QHSint (match_operand:QHSint 1 \"general_operand\" \"0,0\")\n \t            (match_operand:HI 2 \"expand_shift_operand\" \"O,O\")))]\n   \"\"\n-  \"* return pdp11_assemble_shift (operands, <QHSint:mname>, <CODE>);\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (SHF:QHSint (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\"\n   [(set (attr \"length\")\n \t(symbol_ref \"pdp11_shift_length (operands, <QHSint:mname>, \n-                                         <CODE>, which_alternative == 0)\"))])\n+                                         <CODE>, which_alternative == 0)\"))\n+   (set_attr \"base_cost\" \"0\")])\n+\n+(define_insn \"<code><mode>_sc<cc_ccnz>\"\n+  [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rD,Q\")\n+\t(SHF:PDPint (match_operand:PDPint 1 \"general_operand\" \"0,0\")\n+\t     (match_operand:HI 2 \"expand_shift_operand\" \"O,O\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n+  \"* return pdp11_assemble_shift (operands, <PDPint:mname>, <CODE>);\"\n+  [(set (attr \"length\")\n+\t(symbol_ref \"pdp11_shift_length (operands, <PDPint:mname>, \n+                                         <CODE>, which_alternative == 0)\"))\n+   (set_attr \"base_cost\" \"0\")])\n+\n+;; This one comes only in clobber flavor.\n+(define_insn \"<code>si_sc_nocc\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rD,Q\")\n+\t(SHF:SI (match_operand:SI 1 \"general_operand\" \"0,0\")\n+\t     (match_operand:HI 2 \"expand_shift_operand\" \"O,O\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n+  \"* return pdp11_assemble_shift (operands, SImode, <CODE>);\"\n+  [(set (attr \"length\")\n+\t(symbol_ref \"pdp11_shift_length (operands, SImode, \n+                                         <CODE>, which_alternative == 0)\"))\n+   (set_attr \"base_cost\" \"0\")])\n \n ;; Next, shifts that are done as a loop on base (11/10 class) machines.\n ;; This applies to shift counts too large to unroll, or variable shift\n ;; counts.  The check for count <= 0 is done before we get here.\n-(define_insn \"<code><mode>_base\"\n+(define_insn_and_split \"<code><mode>_base\"\n   [(set (match_operand:QHSint 0 \"nonimmediate_operand\" \"=rD,Q\")\n \t(SHF:QHSint (match_operand:QHSint 1 \"general_operand\" \"0,0\")\n \t     (match_operand:HI 2 \"register_operand\" \"r,r\")))\n    (clobber (match_dup 2))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (SHF:QHSint (match_dup 1) (match_dup 2)))\n+\t      (clobber (match_dup 2))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\"\n+  [(set (attr \"length\")\n+\t(symbol_ref \"pdp11_shift_length (operands, <QHSint:mname>, \n+                                         <CODE>, which_alternative == 0)\"))\n+   (set_attr \"base_cost\" \"0\")])\n+\n+(define_insn \"<code><mode>_base_nocc\"\n+  [(set (match_operand:QHSint 0 \"nonimmediate_operand\" \"=rD,Q\")\n+\t(SHF:QHSint (match_operand:QHSint 1 \"general_operand\" \"0,0\")\n+\t     (match_operand:HI 2 \"register_operand\" \"r,r\")))\n+   (clobber (match_dup 2))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n   \"* return pdp11_assemble_shift (operands, <QHSint:mname>, <CODE>);\"\n   [(set (attr \"length\")\n \t(symbol_ref \"pdp11_shift_length (operands, <QHSint:mname>, \n-                                         <CODE>, which_alternative == 0)\"))])\n+                                         <CODE>, which_alternative == 0)\"))\n+   (set_attr \"base_cost\" \"0\")])\n \n ;; Next the insns that use the extended instructions ash and ashc.\n ;; Note that these are just left shifts, and HI/SI only.  (Right shifts\n ;; are done by shifting by a negative amount.)\n-(define_insn \"aslhi_op\"\n+(define_insn_and_split \"aslhi_op\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r\")\n \t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n-\t               (match_operand:HI 2 \"general_operand\" \"rR,Q\")))]\n+\t               (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))]\n   \"TARGET_40_PLUS\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ashift:HI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"8\")])\n+\n+(define_insn \"aslhi_op<cc_ccnz>\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r\")\n+\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"rR,Qi\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_40_PLUS && reload_completed\"\n   \"ash\\t%2,%0\"\n-  [(set_attr \"length\" \"2,4\")])\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"8\")])\n \n-(define_insn \"aslsi_op\"\n+(define_insn_and_split \"aslsi_op\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r\")\n \t(ashift:SI (match_operand:SI 1 \"general_operand\" \"0,0\")\n-\t           (match_operand:HI 2 \"general_operand\" \"rR,Q\")))]\n+\t           (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))]\n   \"TARGET_40_PLUS\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ashift:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"8\")])\n+\n+(define_insn \"aslsi_op_<cc_ccnz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"0,0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"rR,Qi\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_40_PLUS && reload_completed\"\n   \"ashc\\t%2,%0\"\n-  [(set_attr \"length\" \"2,4\")])\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"8\")])\n \n ;; Now the expanders that produce the insns defined above. \n (define_expand \"ashl<mode>3\"\n@@ -1437,7 +1603,8 @@\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (abs:DF (match_dup 1)))\n \t      (clobber (reg:CC FCC_REGNUM))])]\n-   \"\")\n+   \"\"\n+  [(set_attr \"length\" \"2,4\")])\n \n (define_insn \"absdf2<fcc_cc>\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=fR,Q\")\n@@ -1457,7 +1624,8 @@\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (neg:DF (match_dup 1)))\n \t      (clobber (reg:CC FCC_REGNUM))])]\n-   \"\")\n+   \"\"\n+  [(set_attr \"length\" \"2,4\")])\n \n (define_insn \"negdf2<fcc_cc>\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=fR,Q\")\n@@ -1475,31 +1643,33 @@\n   \"reload_completed\"\n   [(parallel [(set (match_dup 0) (neg:DI (match_dup 1)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"18,34\")])\n   \n ;; TODO: this can be neg/adc/neg/adc... I believe.  Check.  Saves one word.\n (define_insn \"negdi2_nocc\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o\")\n \t(neg:DI (match_operand:DI 1 \"general_operand\" \"0,0\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"reload_completed\"\n-{\n-  rtx exops[4][2];\n+  {\n+    rtx exops[4][2];\n+    \n+    pdp11_expand_operands (operands, exops, 1, NULL, either);\n   \n-  pdp11_expand_operands (operands, exops, 1, NULL, either);\n-\n-  output_asm_insn (\\\"com\\t%0\\\", exops[3]);\n-  output_asm_insn (\\\"com\\t%0\\\", exops[2]);\n-  output_asm_insn (\\\"com\\t%0\\\", exops[1]);\n-  output_asm_insn (\\\"com\\t%0\\\", exops[0]);\n-  output_asm_insn (\\\"add\\t%#1,%0\\\", exops[3]);\n-  output_asm_insn (\\\"adc\\t%0\\\", exops[2]);\n-  output_asm_insn (\\\"adc\\t%0\\\", exops[1]);\n-  output_asm_insn (\\\"adc\\t%0\\\", exops[0]);\n-\n-  return \\\"\\\";\n-}\n-[(set_attr \"length\" \"18,34\")])\n+    output_asm_insn (\\\"com\\t%0\\\", exops[3]);\n+    output_asm_insn (\\\"com\\t%0\\\", exops[2]);\n+    output_asm_insn (\\\"com\\t%0\\\", exops[1]);\n+    output_asm_insn (\\\"com\\t%0\\\", exops[0]);\n+    output_asm_insn (\\\"add\\t%#1,%0\\\", exops[3]);\n+    output_asm_insn (\\\"adc\\t%0\\\", exops[2]);\n+    output_asm_insn (\\\"adc\\t%0\\\", exops[1]);\n+    output_asm_insn (\\\"adc\\t%0\\\", exops[0]);\n+  \n+    return \\\"\\\";\n+  }\n+  [(set_attr \"length\" \"18,34\")\n+   (set_attr \"base_cost\" \"0\")])\n \n (define_insn_and_split \"negsi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,o\")\n@@ -1509,27 +1679,29 @@\n   \"reload_completed\"\n   [(parallel [(set (match_dup 0) (neg:SI (match_dup 1)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"10,18\")])\n   \n ;; TODO: this can be neg/adc/neg/adc... I believe.  Check.  Saves one word.\n (define_insn \"negsi2_nocc\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,o\")\n \t(neg:SI (match_operand:SI 1 \"general_operand\" \"0,0\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"reload_completed\"\n-{\n-  rtx exops[2][2];\n+  {\n+    rtx exops[2][2];\n+    \n+    pdp11_expand_operands (operands, exops, 1, NULL, either);\n   \n-  pdp11_expand_operands (operands, exops, 1, NULL, either);\n-\n-  output_asm_insn (\\\"com\\t%0\\\", exops[1]);\n-  output_asm_insn (\\\"com\\t%0\\\", exops[0]);\n-  output_asm_insn (\\\"add\\t%#1,%0\\\", exops[1]);\n-  output_asm_insn (\\\"adc\\t%0\\\", exops[0]);\n-\n-  return \\\"\\\";\n-}\n-[(set_attr \"length\" \"10,18\")])\n+    output_asm_insn (\\\"com\\t%0\\\", exops[1]);\n+    output_asm_insn (\\\"com\\t%0\\\", exops[0]);\n+    output_asm_insn (\\\"add\\t%#1,%0\\\", exops[1]);\n+    output_asm_insn (\\\"adc\\t%0\\\", exops[0]);\n+  \n+    return \\\"\\\";\n+  }\n+  [(set_attr \"length\" \"10,18\")\n+   (set_attr \"base_cost\" \"0\")])\n \n (define_insn_and_split \"neg<mode>2\"\n   [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,Q\")\n@@ -1539,7 +1711,8 @@\n   \"reload_completed\"\n   [(parallel [(set (match_dup 0) (neg:PDPint (match_dup 1)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4\")])\n   \n (define_insn \"neg<mode>2<cc_ccnz>\"\n   [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,Q\")\n@@ -1586,7 +1759,7 @@\n (define_insn \"indirect_jump\"\n   [(set (pc) (match_operand:HI 0 \"general_operand\" \"r\"))]\n   \"\"\n-  \"jmp @%0\"\n+  \"jmp\\t@%0\"\n   [(set_attr \"length\" \"2\")])\n \n ;;- jump to subroutine\n@@ -1596,7 +1769,7 @@\n \t (match_operand:HI 1 \"general_operand\" \"g,g\"))]\n   ;;- Don't use operand 1 for most machines.\n   \"\"\n-  \"jsr pc,%0\"\n+  \"jsr\\tpc,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n ;;- jump to subroutine\n@@ -1606,7 +1779,7 @@\n \t      (match_operand:HI 2 \"general_operand\" \"g,g\")))]\n   ;;- Don't use operand 2 for most machines.\n   \"\"\n-  \"jsr pc,%1\"\n+  \"jsr\\tpc,%1\"\n   [(set_attr \"length\" \"2,4\")])\n \n (define_expand \"untyped_call\"\n@@ -1653,7 +1826,8 @@\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (mult:DF (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC FCC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4\")])\n \n (define_insn \"muldf3<fcc_ccnz>\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n@@ -1662,7 +1836,8 @@\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n   \"{muld|mulf}\\t%2,%0\"\n-  [(set_attr \"length\" \"2,4\")])\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"20\")])\n \n ;; 16 bit result multiply.  This uses odd numbered registers.\n \n@@ -1675,7 +1850,8 @@\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (mult:HI (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4\")])\n \n (define_insn \"mulhi3<cc_cc>\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d,d\")\n@@ -1684,7 +1860,8 @@\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_40_PLUS && reload_completed\"\n   \"mul\\t%2,%0\"\n-  [(set_attr \"length\" \"2,4\")])\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"20\")])\n \n ;; 32 bit result from 16 bit operands\n (define_insn_and_split \"mulhisi3\"\n@@ -1698,7 +1875,8 @@\n \t\t   (mult:SI (sign_extend:SI (match_dup 1))\n \t\t\t (sign_extend:SI (match_dup 2))))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4\")])\n \n (define_insn \"mulhisi3<cc_cc>\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -1707,7 +1885,8 @@\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_40_PLUS && reload_completed\"\n   \"mul\\t%2,%0\"\n-  [(set_attr \"length\" \"2,4\")])\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"20\")])\n \n ;;- divide\n (define_insn_and_split \"divdf3\"\n@@ -1719,7 +1898,8 @@\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (div:DF (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC FCC_REGNUM))])]\n-   \"\")\n+   \"\"\n+  [(set_attr \"length\" \"2,4\")])\n   \n (define_insn \"divdf3<fcc_ccnz>\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n@@ -1728,7 +1908,8 @@\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n   \"{divd|divf}\\t%2,%0\"\n-  [(set_attr \"length\" \"2,4\")])\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"20\")])\n \n (define_expand \"divmodhi4\"\n   [(parallel\n@@ -1758,7 +1939,8 @@\n \t      (set (subreg:HI (match_dup 1) 2)\n \t\t   (mod:HI (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"2,4\")])\n \n ;; Note that there is no corresponding CC setter pattern.\n ;; The reason is that it won't be generated, because\n@@ -1774,4 +1956,114 @@\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_40_PLUS\"\n    \"div\\t%2,%0\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"40\")])\n+\n+;; Byte swap\n+(define_insn_and_split \"bswaphi2\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n+\t(bswap:HI (match_operand:HI 1 \"general_operand\" \"0,0\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (bswap:HI (match_dup 1)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\"\n   [(set_attr \"length\" \"2,4\")])\n+\n+(define_insn \"bswaphi2<cc_ccnz>\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n+\t(bswap:HI (match_operand:HI 1 \"general_operand\" \"0,0\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"swab\\t%0\"\n+  [(set_attr \"length\" \"2,4\")])\n+\n+(define_insn_and_split \"bswapsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(bswap:SI (match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (bswap:SI (match_dup 1)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\"\n+  [(set_attr \"length\" \"10\")])\n+\n+(define_insn \"bswapsi2_nocc\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r,&r,&r\")\n+\t(bswap:SI (match_operand:SI 1 \"general_operand\" \"r,D,Q\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  {\n+    rtx exops[2][2];\n+    rtx t;\n+  \n+    pdp11_expand_operands (operands, exops, 2, NULL, either);\n+\n+    t = exops[0][0];\n+    exops[0][0] = exops[1][0];\n+    exops[1][0] = t;\n+\n+    output_asm_insn (\"mov\\t%0,%1\", exops[0]);\n+    output_asm_insn (\"mov\\t%0,%1\", exops[1]);\n+    output_asm_insn (\"swab\\t%0\", exops[0]);\n+    output_asm_insn (\"swab\\t%0\", exops[1]);\n+    return \"\";\n+  }\n+  [(set_attr \"length\" \"8,10,12\")])\n+\n+(define_expand \"rotrhi3\"\n+  [(match_operand:HI 0 \"register_operand\" \"\")\n+   (match_operand:HI 1 \"register_operand\" \"\")\n+   (match_operand:HI 2 \"general_operand\" \"\")]\n+  \"TARGET_40_PLUS\"\n+  \"\n+{\n+  operands[2] = negate_rtx (HImode, operands[2]);\n+  emit_insn (gen_rotlhi3 (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_insn_and_split \"rotlhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,d\")\n+\t(rotate:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n+\t           (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))]\n+  \"TARGET_40_PLUS\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (rotate:HI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"8\")])\n+\n+(define_insn \"rotlhi3<cc_ccnz>\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,d\")\n+\t(rotate:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_40_PLUS && reload_completed\"\n+  \"ashc\\t%2,%0\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"base_cost\" \"8\")])\n+\n+\n+  \n+;; Some peephole optimizations\n+\n+;; Move then conditional branch on the result of the move is handled\n+;; by compare elimination, but an earlier pass sometimes changes the\n+;; compare operand to the move input, and then the compare is not\n+;; eliminated.  Do so here.\n+(define_peephole2\n+  [(parallel [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"\")\n+\t\t   (match_operand:PDPint 1 \"general_operand\" \"\"))\n+\t      (clobber (reg:CC CC_REGNUM))])\n+   (set (reg:CC CC_REGNUM) (compare:CC (match_dup 1) (const_int 0)))]\n+  \"\"\n+  [(parallel [(set (reg:CC CC_REGNUM) (compare:CC (match_dup 1) (const_int 0)))\n+\t      (set (match_dup 0) (match_dup 1))])]\n+  \"\")"}]}