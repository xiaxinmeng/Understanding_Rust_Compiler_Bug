{"sha": "048261647afd1a08f681b78c90c58a9baaeef76d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ4MjYxNjQ3YWZkMWEwOGY2ODFiNzhjOTBjNThhOWJhYWVlZjc2ZA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-19T20:12:31Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-20T12:32:14Z"}, "message": "Add qualified path support\n\nQualified paths need to lookup the associated trait item and mangle the\nnames apropriatly.", "tree": {"sha": "47dc551f706c4015c017a299a4054cb7db460857", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47dc551f706c4015c017a299a4054cb7db460857"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/048261647afd1a08f681b78c90c58a9baaeef76d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/048261647afd1a08f681b78c90c58a9baaeef76d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/048261647afd1a08f681b78c90c58a9baaeef76d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/048261647afd1a08f681b78c90c58a9baaeef76d/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dc718474044149ec1aa6bee9ea8e83d778f17f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dc718474044149ec1aa6bee9ea8e83d778f17f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dc718474044149ec1aa6bee9ea8e83d778f17f2"}], "stats": {"total": 322, "additions": 274, "deletions": 48}, "files": [{"sha": "66d037dd5da074c2adb9ab2e23f773e551313230", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=048261647afd1a08f681b78c90c58a9baaeef76d", "patch": "@@ -287,7 +287,7 @@ class Context\n \n   // this needs to support Legacy and V0 see github #429 or #305\n   std::string mangle_item (const TyTy::BaseType *ty,\n-\t\t\t   const std::string &name) const;\n+\t\t\t   const Resolver::CanonicalPath &path) const;\n \n   std::string mangle_impl_item (const TyTy::BaseType *self,\n \t\t\t\tconst TyTy::BaseType *ty,"}, {"sha": "80cdc5eaeb426a37e927222bd7c47be93510105b", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=048261647afd1a08f681b78c90c58a9baaeef76d", "patch": "@@ -629,6 +629,11 @@ class CompileExpr : public HIRCompileBase\n \t\t\t\t\t\t      expr.get_locus ());\n   }\n \n+  void visit (HIR::QualifiedPathInExpression &expr) override\n+  {\n+    translated = ResolvePathRef::Compile (expr, ctx);\n+  }\n+\n   void visit (HIR::PathInExpression &expr) override\n   {\n     translated = ResolvePathRef::Compile (expr, ctx);"}, {"sha": "7337154067bae91bcccaa22863e9a85c32920140", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=048261647afd1a08f681b78c90c58a9baaeef76d", "patch": "@@ -352,8 +352,7 @@ class CompileTraitItem : public HIRCompileBase\n       &canonical_path));\n \n     std::string fn_identifier = canonical_path->get ();\n-    std::string asm_name\n-      = ctx->mangle_impl_item (self, fntype, function.get_function_name ());\n+    std::string asm_name = ctx->mangle_item (fntype, *canonical_path);\n \n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,"}, {"sha": "a12e67ecde41e3ca9cbae22fdf0829dadf81e3c3", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=048261647afd1a08f681b78c90c58a9baaeef76d", "patch": "@@ -59,7 +59,7 @@ class CompileItem : public HIRCompileBase\n       &canonical_path));\n \n     std::string name = canonical_path->get ();\n-    std::string asm_name = ctx->mangle_item (resolved_type, name);\n+    std::string asm_name = ctx->mangle_item (resolved_type, *canonical_path);\n \n     bool is_external = false;\n     bool is_hidden = false;\n@@ -168,12 +168,24 @@ class CompileItem : public HIRCompileBase\n \n     std::string ir_symbol_name\n       = canonical_path->get () + fntype->subst_as_string ();\n+\n     std::string asm_name = function.get_function_name ();\n \n     // we don't mangle the main fn since we haven't implemented the main shim\n     // yet\n     if (!is_main_fn)\n-      asm_name = ctx->mangle_item (fntype, ir_symbol_name);\n+      {\n+\tstd::string substs_str = fntype->subst_as_string ();\n+\n+\tResolver::CanonicalPath mangle_me\n+\t  = substs_str.empty ()\n+\t      ? *canonical_path\n+\t      : canonical_path->append (\n+\t\tResolver::CanonicalPath::new_seg (0,\n+\t\t\t\t\t\t  fntype->subst_as_string ()));\n+\n+\tasm_name = ctx->mangle_item (fntype, mangle_me);\n+      }\n \n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,"}, {"sha": "1539378824998c13d3361b66638a5a445bed9839", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=048261647afd1a08f681b78c90c58a9baaeef76d", "patch": "@@ -26,19 +26,34 @@\n namespace Rust {\n namespace Compile {\n \n+void\n+ResolvePathRef::visit (HIR::QualifiedPathInExpression &expr)\n+{\n+  resolve (expr.get_final_segment ().get_segment (), expr.get_mappings (),\n+\t   expr.get_locus (), true);\n+}\n+\n void\n ResolvePathRef::visit (HIR::PathInExpression &expr)\n+{\n+  resolve (expr.get_final_segment ().get_segment (), expr.get_mappings (),\n+\t   expr.get_locus (), false);\n+}\n+\n+void\n+ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n+\t\t\t const Analysis::NodeMapping &mappings,\n+\t\t\t Location expr_locus, bool is_qualified_path)\n {\n   // need to look up the reference for this identifier\n   NodeId ref_node_id = UNKNOWN_NODEID;\n-  if (ctx->get_resolver ()->lookup_resolved_name (\n-\texpr.get_mappings ().get_nodeid (), &ref_node_id))\n+  if (ctx->get_resolver ()->lookup_resolved_name (mappings.get_nodeid (),\n+\t\t\t\t\t\t  &ref_node_id))\n     {\n       Resolver::Definition def;\n       if (!ctx->get_resolver ()->lookup_definition (ref_node_id, &def))\n \t{\n-\t  rust_error_at (expr.get_locus (),\n-\t\t\t \"unknown reference for resolved name\");\n+\t  rust_error_at (expr_locus, \"unknown reference for resolved name\");\n \t  return;\n \t}\n       ref_node_id = def.parent;\n@@ -50,10 +65,10 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n     return;\n \n   HirId ref;\n-  if (!ctx->get_mappings ()->lookup_node_to_hir (\n-\texpr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n+  if (!ctx->get_mappings ()->lookup_node_to_hir (mappings.get_crate_num (),\n+\t\t\t\t\t\t ref_node_id, &ref))\n     {\n-      rust_error_at (expr.get_locus (), \"reverse call path lookup failure\");\n+      rust_error_at (expr_locus, \"reverse call path lookup failure\");\n       return;\n     }\n \n@@ -65,15 +80,14 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n   Bvariable *var = nullptr;\n   if (ctx->lookup_var_decl (ref, &var))\n     {\n-      resolved = ctx->get_backend ()->var_expression (var, expr.get_locus ());\n+      resolved = ctx->get_backend ()->var_expression (var, expr_locus);\n       return;\n     }\n \n   // must be a function call but it might be a generic function which needs to\n   // be compiled first\n   TyTy::BaseType *lookup = nullptr;\n-  bool ok = ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t    &lookup);\n+  bool ok = ctx->get_tyctx ()->lookup_type (mappings.get_hirid (), &lookup);\n   rust_assert (ok);\n   rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n   TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n@@ -82,8 +96,9 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n   if (!ctx->lookup_function_decl (lookup->get_ty_ref (), &fn))\n     {\n       // it must resolve to some kind of HIR::Item or HIR::InheritImplItem\n-      HIR::Item *resolved_item = ctx->get_mappings ()->lookup_hir_item (\n-\texpr.get_mappings ().get_crate_num (), ref);\n+      HIR::Item *resolved_item\n+\t= ctx->get_mappings ()->lookup_hir_item (mappings.get_crate_num (),\n+\t\t\t\t\t\t ref);\n       if (resolved_item != nullptr)\n \t{\n \t  if (!lookup->has_subsititions_defined ())\n@@ -96,14 +111,14 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t  HirId parent_impl_id = UNKNOWN_HIRID;\n \t  HIR::ImplItem *resolved_item\n \t    = ctx->get_mappings ()->lookup_hir_implitem (\n-\t      expr.get_mappings ().get_crate_num (), ref, &parent_impl_id);\n+\t      mappings.get_crate_num (), ref, &parent_impl_id);\n \n \t  if (resolved_item == nullptr)\n \t    {\n \t      // it might be resolved to a trait item\n \t      HIR::TraitItem *trait_item\n \t\t= ctx->get_mappings ()->lookup_hir_trait_item (\n-\t\t  expr.get_mappings ().get_crate_num (), ref);\n+\t\t  mappings.get_crate_num (), ref);\n \t      HIR::Trait *trait\n \t\t= ctx->get_mappings ()->lookup_trait_item_mapping (\n \t\t  trait_item->get_mappings ().get_hirid ());\n@@ -115,8 +130,8 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t      rust_assert (ok);\n \n \t      TyTy::BaseType *receiver = nullptr;\n-\t      ok = ctx->get_tyctx ()->lookup_receiver (\n-\t\texpr.get_mappings ().get_hirid (), &receiver);\n+\t      ok = ctx->get_tyctx ()->lookup_receiver (mappings.get_hirid (),\n+\t\t\t\t\t\t       &receiver);\n \t      rust_assert (ok);\n \n \t      if (receiver->get_kind () == TyTy::TypeKind::PARAM)\n@@ -130,10 +145,13 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t      // item so its up to us to figure out if this path should resolve\n \t      // to an trait-impl-block-item or if it can be defaulted to the\n \t      // trait-impl-item's definition\n-\t      std::vector<Resolver::PathProbeCandidate> candidates\n-\t\t= Resolver::PathProbeType::Probe (\n-\t\t  receiver, expr.get_final_segment ().get_segment (), true,\n-\t\t  false, true);\n+\t      std::vector<Resolver::PathProbeCandidate> candidates;\n+\t      if (!is_qualified_path)\n+\t\t{\n+\t\t  candidates\n+\t\t    = Resolver::PathProbeType::Probe (receiver, final_segment,\n+\t\t\t\t\t\t      true, false, true);\n+\t\t}\n \n \t      if (candidates.size () == 0)\n \t\t{\n@@ -152,6 +170,7 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t\t    = ctx->get_tyctx ()\n \t\t\t->lookup_associated_impl_mapping_for_self (\n \t\t\t  trait_mappings.get_hirid (), receiver);\n+\n \t\t  rust_assert (associated_impl_id != UNKNOWN_HIRID);\n \n \t\t  Resolver::AssociatedImplTrait *associated = nullptr;\n@@ -168,7 +187,7 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n \t\t    {\n \t\t      resolved = ctx->get_backend ()->error_expression ();\n-\t\t      rust_error_at (expr.get_locus (),\n+\t\t      rust_error_at (expr_locus,\n \t\t\t\t     \"forward declaration was not compiled\");\n \t\t      return;\n \t\t    }\n@@ -201,7 +220,7 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t    {\n \t      rust_assert (parent_impl_id != UNKNOWN_HIRID);\n \t      HIR::Item *impl_ref = ctx->get_mappings ()->lookup_hir_item (\n-\t\texpr.get_mappings ().get_crate_num (), parent_impl_id);\n+\t\tmappings.get_crate_num (), parent_impl_id);\n \t      rust_assert (impl_ref != nullptr);\n \t      HIR::ImplBlock *impl = static_cast<HIR::ImplBlock *> (impl_ref);\n \n@@ -222,14 +241,12 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n       if (!ctx->lookup_function_decl (lookup->get_ty_ref (), &fn))\n \t{\n \t  resolved = ctx->get_backend ()->error_expression ();\n-\t  rust_error_at (expr.get_locus (),\n-\t\t\t \"forward declaration was not compiled\");\n+\t  rust_error_at (expr_locus, \"forward declaration was not compiled\");\n \t  return;\n \t}\n     }\n \n-  resolved\n-    = ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n+  resolved = ctx->get_backend ()->function_code_expression (fn, expr_locus);\n }\n \n } // namespace Compile"}, {"sha": "41067c88b04f090d43b3b3b1cb254eda78c43d28", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=048261647afd1a08f681b78c90c58a9baaeef76d", "patch": "@@ -30,6 +30,14 @@ class ResolvePathRef : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n+  static Bexpression *Compile (HIR::QualifiedPathInExpression &expr,\n+\t\t\t       Context *ctx)\n+  {\n+    ResolvePathRef resolver (ctx);\n+    expr.accept_vis (resolver);\n+    return resolver.resolved;\n+  }\n+\n   static Bexpression *Compile (HIR::PathInExpression &expr, Context *ctx)\n   {\n     ResolvePathRef resolver (ctx);\n@@ -39,8 +47,16 @@ class ResolvePathRef : public HIRCompileBase\n \n   void visit (HIR::PathInExpression &expr) override;\n \n+  void visit (HIR::QualifiedPathInExpression &expr) override;\n+\n private:\n-  ResolvePathRef (Context *ctx) : HIRCompileBase (ctx), resolved (nullptr) {}\n+  ResolvePathRef (Context *ctx)\n+    : HIRCompileBase (ctx), resolved (ctx->get_backend ()->error_expression ())\n+  {}\n+\n+  void resolve (const HIR::PathIdentSegment &final_segment,\n+\t\tconst Analysis::NodeMapping &mappings, Location locus,\n+\t\tbool is_qualified_path);\n \n   Bexpression *resolved;\n };"}, {"sha": "baaccf06c100c8231f3ec0e69a414a65ae671a3c", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=048261647afd1a08f681b78c90c58a9baaeef76d", "patch": "@@ -553,6 +553,17 @@ mangle_name (const std::string &name)\n   return std::to_string (name.size ()) + name;\n }\n \n+static std::string\n+mangle_canonical_path (const Resolver::CanonicalPath &path)\n+{\n+  std::string buffer;\n+  path.iterate_segs ([&] (const Resolver::CanonicalPath &p) -> bool {\n+    buffer += mangle_name (p.get ());\n+    return true;\n+  });\n+  return buffer;\n+}\n+\n // rustc uses a sip128 hash for legacy mangling, but an fnv 128 was quicker to\n // implement for now\n static std::string\n@@ -603,17 +614,19 @@ mangle_self (const TyTy::BaseType *self)\n }\n \n std::string\n-Context::mangle_item (const TyTy::BaseType *ty, const std::string &name) const\n+Context::mangle_item (const TyTy::BaseType *ty,\n+\t\t      const Resolver::CanonicalPath &path) const\n {\n   const std::string &crate_name = mappings->get_current_crate_name ();\n \n   const std::string hash = legacy_hash (ty->as_string ());\n   const std::string hash_sig = mangle_name (hash);\n \n-  return kMangledSymbolPrefix + mangle_name (crate_name) + mangle_name (name)\n-\t + hash_sig + kMangledSymbolDelim;\n+  return kMangledSymbolPrefix + mangle_name (crate_name)\n+\t + mangle_canonical_path (path) + hash_sig + kMangledSymbolDelim;\n }\n \n+// FIXME this is a wee bit broken\n std::string\n Context::mangle_impl_item (const TyTy::BaseType *self, const TyTy::BaseType *ty,\n \t\t\t   const std::string &name) const"}, {"sha": "9d16e3617de81be0aea23a06fa16f2fee0486901", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=048261647afd1a08f681b78c90c58a9baaeef76d", "patch": "@@ -359,6 +359,10 @@ class AssociatedImplTrait\n \n   void reset_associated_types ();\n \n+  TyTy::BaseType *get_projected_type (const TraitItemReference *trait_item_ref,\n+\t\t\t\t      TyTy::BaseType *reciever, HirId ref,\n+\t\t\t\t      Location expr_locus);\n+\n private:\n   TraitReference *trait;\n   HIR::ImplBlock *impl;"}, {"sha": "cf3f2fbf1bd739f0838d70c353e1d658108faf0d", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=048261647afd1a08f681b78c90c58a9baaeef76d", "patch": "@@ -193,5 +193,39 @@ TraitItemReference::get_parent_trait_mappings () const\n   return trait->get_mappings ();\n }\n \n+TyTy::BaseType *\n+AssociatedImplTrait::get_projected_type (\n+  const TraitItemReference *trait_item_ref, TyTy::BaseType *receiver, HirId ref,\n+  Location expr_locus)\n+{\n+  TyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ()->clone ();\n+\n+  // we can substitute the Self with the receiver here\n+  if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+    {\n+      TyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n+      TyTy::SubstitutionParamMapping *param = nullptr;\n+      for (auto &param_mapping : fn->get_substs ())\n+\t{\n+\t  const HIR::TypeParam &type_param = param_mapping.get_generic_param ();\n+\t  if (type_param.get_type_representation ().compare (\"Self\") == 0)\n+\t    {\n+\t      param = &param_mapping;\n+\t      break;\n+\t    }\n+\t}\n+      rust_assert (param != nullptr);\n+\n+      std::vector<TyTy::SubstitutionArg> mappings;\n+      mappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n+\n+      Location locus; // FIXME\n+      TyTy::SubstitutionArgumentMappings args (std::move (mappings), locus);\n+      trait_item_tyty = SubstMapperInternal::Resolve (trait_item_tyty, args);\n+    }\n+\n+  return trait_item_tyty;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "e3347ea1aba8bb1206ba88d4d10d08b14e6267f5", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 67, "deletions": 8, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=048261647afd1a08f681b78c90c58a9baaeef76d", "patch": "@@ -961,33 +961,92 @@ class TypeCheckExpr : public TypeCheckBase\n     if (expr.get_segments ().empty ())\n       return;\n \n+    // we need resolve to the impl block\n+    NodeId impl_resolved_id = UNKNOWN_NODEID;\n+    bool ok = resolver->lookup_resolved_name (\n+      qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n+    rust_assert (ok);\n+\n+    HirId impl_block_id;\n+    ok = mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t       impl_resolved_id, &impl_block_id);\n+    rust_assert (ok);\n+\n+    AssociatedImplTrait *lookup_associated = nullptr;\n+    bool found_impl_trait\n+      = context->lookup_associated_trait_impl (impl_block_id,\n+\t\t\t\t\t       &lookup_associated);\n+    rust_assert (found_impl_trait);\n+\n     DefId resolved_item_id = UNKNOWN_DEFID;\n     HIR::PathExprSegment &item_seg = expr.get_segments ().at (0);\n \n     const TraitItemReference *trait_item_ref = nullptr;\n-    bool ok\n-      = trait_ref->lookup_trait_item (item_seg.get_segment ().as_string (),\n-\t\t\t\t      &trait_item_ref);\n+    ok = trait_ref->lookup_trait_item (item_seg.get_segment ().as_string (),\n+\t\t\t\t       &trait_item_ref);\n     if (!ok)\n       {\n \trust_error_at (item_seg.get_locus (), \"unknown associated item\");\n \treturn;\n       }\n+    resolved_item_id = trait_item_ref->get_mappings ().get_defid ();\n+\n+    infered = lookup_associated->get_projected_type (\n+      trait_item_ref, root, item_seg.get_mappings ().get_hirid (),\n+      item_seg.get_locus ());\n \n-    // TODO self and generic arguments\n-    infered = trait_item_ref->get_tyty ();\n-    rust_debug_loc (expr.get_locus (), \"resolved to:\");\n-    infered->debug ();\n+    // turbo-fish segment path::<ty>\n+    if (item_seg.has_generic_args ())\n+      {\n+\tif (!infered->can_substitute ())\n+\t  {\n+\t    rust_error_at (item_seg.get_locus (),\n+\t\t\t   \"substitutions not supported for %s\",\n+\t\t\t   infered->as_string ().c_str ());\n+\t    infered = new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t    return;\n+\t  }\n+\tinfered = SubstMapper::Resolve (infered, expr.get_locus (),\n+\t\t\t\t\t&item_seg.get_generic_args ());\n+      }\n \n     TyTy::ProjectionType *projection\n       = new TyTy::ProjectionType (qual_path_type.get_mappings ().get_hirid (),\n \t\t\t\t  TyTy::TyVar (root->get_ref ()), trait_ref,\n-\t\t\t\t  resolved_item_id);\n+\t\t\t\t  resolved_item_id, lookup_associated);\n     context->insert_type (qual_path_type.get_mappings (), projection);\n \n     // continue on as a path-in-expression\n     NodeId root_resolved_node_id\n       = trait_item_ref->get_mappings ().get_nodeid ();\n+    bool fully_resolved = expr.get_segments ().size () <= 1;\n+\n+    if (fully_resolved)\n+      {\n+\t// lookup if the name resolver was able to canonically resolve this or\n+\t// not\n+\tNodeId path_resolved_id = UNKNOWN_NODEID;\n+\tif (resolver->lookup_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t\t    &path_resolved_id))\n+\t  {\n+\t    rust_assert (path_resolved_id == root_resolved_node_id);\n+\t  }\n+\t// check the type scope\n+\telse if (resolver->lookup_resolved_type (\n+\t\t   expr.get_mappings ().get_nodeid (), &path_resolved_id))\n+\t  {\n+\t    rust_assert (path_resolved_id == root_resolved_node_id);\n+\t  }\n+\telse\n+\t  {\n+\t    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t\t    root_resolved_node_id);\n+\t  }\n+\n+\tcontext->insert_receiver (expr.get_mappings ().get_hirid (), root);\n+\treturn;\n+      }\n+\n     resolve_segments (root_resolved_node_id, expr.get_segments (), 1, infered,\n \t\t      expr.get_mappings (), expr.get_locus ());\n   }"}, {"sha": "56fdafd7919ecc60d08fddf616b3436b8cb4b5d6", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=048261647afd1a08f681b78c90c58a9baaeef76d", "patch": "@@ -2174,7 +2174,7 @@ BaseType *\n ProjectionType::clone () const\n {\n   return new ProjectionType (get_ref (), get_ty_ref (), base, trait, item,\n-\t\t\t     get_combined_refs ());\n+\t\t\t     associated, get_combined_refs ());\n }\n \n // rust-tyty-call.h"}, {"sha": "743874a2b0b3cdf9eb2faad84455cc607e3941eb", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=048261647afd1a08f681b78c90c58a9baaeef76d", "patch": "@@ -27,7 +27,8 @@\n namespace Rust {\n namespace Resolver {\n class TraitReference;\n-}\n+class AssociatedImplTrait;\n+} // namespace Resolver\n \n namespace TyTy {\n \n@@ -1730,16 +1731,18 @@ class ProjectionType : public BaseType\n {\n public:\n   ProjectionType (HirId ref, TyVar base, Resolver::TraitReference *trait,\n-\t\t  DefId item, std::set<HirId> refs = std::set<HirId> ())\n+\t\t  DefId item, Resolver::AssociatedImplTrait *associated,\n+\t\t  std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::PROJECTION, refs), base (base),\n-      trait (trait), item (item)\n+      trait (trait), item (item), associated (associated)\n   {}\n \n   ProjectionType (HirId ref, HirId ty_ref, TyVar base,\n \t\t  Resolver::TraitReference *trait, DefId item,\n+\t\t  Resolver::AssociatedImplTrait *associated,\n \t\t  std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::PROJECTION, refs), base (base),\n-      trait (trait), item (item)\n+      trait (trait), item (item), associated (associated)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1762,6 +1765,7 @@ class ProjectionType : public BaseType\n   TyVar base;\n   Resolver::TraitReference *trait;\n   DefId item;\n+  Resolver::AssociatedImplTrait *associated;\n };\n \n } // namespace TyTy"}, {"sha": "b5f8dd7b5c821a1da48a54643c81e4b9729518e5", "filename": "gcc/rust/util/rust-canonical-path.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Futil%2Frust-canonical-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Frust%2Futil%2Frust-canonical-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-canonical-path.h?ref=048261647afd1a08f681b78c90c58a9baaeef76d", "patch": "@@ -110,6 +110,17 @@ class CanonicalPath\n       }\n   }\n \n+  void iterate_segs (std::function<bool (const CanonicalPath &)> cb) const\n+  {\n+    for (auto &seg : segs)\n+      {\n+\tstd::vector<std::pair<NodeId, std::string>> buf;\n+\tbuf.push_back ({seg.first, seg.second});\n+\tif (!cb (CanonicalPath (buf)))\n+\t  return;\n+      }\n+  }\n+\n   size_t size () const { return segs.size (); }\n \n   NodeId get_id () const"}, {"sha": "dc3cc471c3321b69aff96bc9bba626ebdfdb8416", "filename": "gcc/testsuite/rust/execute/torture/trait1.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048261647afd1a08f681b78c90c58a9baaeef76d/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait1.rs?ref=048261647afd1a08f681b78c90c58a9baaeef76d", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-output \"S::f\\nT1::f\\nT2::f\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct S;\n+\n+impl S {\n+    fn f() {\n+        unsafe {\n+            let a = \"S::f\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+    }\n+}\n+\n+trait T1 {\n+    fn f() {\n+        unsafe {\n+            let a = \"T1::f\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+    }\n+}\n+impl T1 for S {}\n+\n+trait T2 {\n+    fn f() {\n+        unsafe {\n+            let a = \"T2::f\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+    }\n+}\n+impl T2 for S {}\n+\n+fn main() -> i32 {\n+    S::f();\n+    <S as T1>::f();\n+    <S as T2>::f();\n+\n+    0\n+}"}]}