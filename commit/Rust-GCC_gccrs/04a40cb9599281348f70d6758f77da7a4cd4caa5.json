{"sha": "04a40cb9599281348f70d6758f77da7a4cd4caa5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRhNDBjYjk1OTkyODEzNDhmNzBkNjc1OGY3N2RhN2E0Y2Q0Y2FhNQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-05T10:12:14Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-05T10:12:14Z"}, "message": "expr.c (try_casesi): Remove bogus ATTRIBUTE_UNUSED markers.\n\ngcc/\n\t* expr.c (try_casesi): Remove bogus ATTRIBUTE_UNUSED markers.\n\t* stmt.c (dump_case_nodes): New.\n\t(expand_case): Split out code generation parts into new functions.\n\t(expand_switch_as_decision_tree_p): Split out from expand_case.\n\t(emit_case_decision_tree): Likewise.\n\t(emit_case_dispatch_table): Likewise.\n\ntestsuite/\n\t* gcc.c-torture/compile/20000326-1.c: Fix to not optimize to empty.\n\nFrom-SVN: r189285", "tree": {"sha": "5ba82ee1fa687f8bbcb0b24d8f46b093ad127454", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ba82ee1fa687f8bbcb0b24d8f46b093ad127454"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04a40cb9599281348f70d6758f77da7a4cd4caa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04a40cb9599281348f70d6758f77da7a4cd4caa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04a40cb9599281348f70d6758f77da7a4cd4caa5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04a40cb9599281348f70d6758f77da7a4cd4caa5/comments", "author": null, "committer": null, "parents": [{"sha": "12c0399e136f1e56d6437fff5cd6e01f5f7ec284", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c0399e136f1e56d6437fff5cd6e01f5f7ec284", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12c0399e136f1e56d6437fff5cd6e01f5f7ec284"}], "stats": {"total": 588, "additions": 348, "deletions": 240}, "files": [{"sha": "091bda2132d218e4c51143111b860e36822435af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04a40cb9599281348f70d6758f77da7a4cd4caa5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04a40cb9599281348f70d6758f77da7a4cd4caa5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=04a40cb9599281348f70d6758f77da7a4cd4caa5", "patch": "@@ -1,3 +1,12 @@\n+2012-07-05  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* expr.c (try_casesi): Remove bogus ATTRIBUTE_UNUSED markers.\n+\t* stmt.c (dump_case_nodes): New.\n+\t(expand_case): Split out code generation parts into new functions.\n+\t(expand_switch_as_decision_tree_p): Split out from expand_case.\n+\t(emit_case_decision_tree): Likewise.\n+\t(emit_case_dispatch_table): Likewise.\n+\n 2012-07-05  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>\n \n \t* config/arm/iterators.md (SDF): New mode iterator."}, {"sha": "1279186d82d649dfafb5c1ed2a7ec6fe20ce8562", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04a40cb9599281348f70d6758f77da7a4cd4caa5/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04a40cb9599281348f70d6758f77da7a4cd4caa5/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=04a40cb9599281348f70d6758f77da7a4cd4caa5", "patch": "@@ -10850,8 +10850,7 @@ do_store_flag (sepops ops, rtx target, enum machine_mode mode)\n    0 otherwise (i.e. if there is no casesi instruction).  */\n int\n try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n-\t    rtx table_label ATTRIBUTE_UNUSED, rtx default_label,\n-\t    rtx fallback_label ATTRIBUTE_UNUSED)\n+\t    rtx table_label, rtx default_label, rtx fallback_label)\n {\n   struct expand_operand ops[5];\n   enum machine_mode index_mode = SImode;"}, {"sha": "5b336e9528fafdb82c798ad1d889938a96e4cba0", "filename": "gcc/stmt.c", "status": "modified", "additions": 328, "deletions": 231, "changes": 559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04a40cb9599281348f70d6758f77da7a4cd4caa5/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04a40cb9599281348f70d6758f77da7a4cd4caa5/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=04a40cb9599281348f70d6758f77da7a4cd4caa5", "patch": "@@ -1716,6 +1716,35 @@ add_case_node (struct case_node *head, tree type, tree low, tree high,\n   return r;\n }\n \f\n+/* Dump ROOT, a list or tree of case nodes, to file.  */\n+\n+static void\n+dump_case_nodes (FILE *f, struct case_node *root,\n+\t\t int indent_step, int indent_level)\n+{\n+  HOST_WIDE_INT low, high;\n+\n+  if (root == 0)\n+    return;\n+  indent_level++;\n+\n+  dump_case_nodes (f, root->left, indent_step, indent_level);\n+\n+  low = tree_low_cst (root->low, 0);\n+  high = tree_low_cst (root->high, 0);\n+\n+  fputs (\";; \", f);\n+  if (high == low)\n+    fprintf(f, \"%*s\" HOST_WIDE_INT_PRINT_DEC,\n+\t    indent_step * indent_level, \"\", low);\n+  else\n+    fprintf(f, \"%*s\" HOST_WIDE_INT_PRINT_DEC \" ... \" HOST_WIDE_INT_PRINT_DEC,\n+\t    indent_step * indent_level, \"\", low, high);\n+  fputs (\"\\n\", f);\n+\n+  dump_case_nodes (f, root->right, indent_step, indent_level);\n+}\n+\f\n #ifndef HAVE_casesi\n #define HAVE_casesi 0\n #endif\n@@ -1738,276 +1767,344 @@ case_values_threshold (void)\n   return threshold;\n }\n \n-/* Terminate a case (Pascal/Ada) or switch (C) statement\n-   in which ORIG_INDEX is the expression to be tested.\n-   If ORIG_TYPE is not NULL, it is the original ORIG_INDEX\n-   type as given in the source before any compiler conversions.\n-   Generate the code to test it and jump to the right place.  */\n+/* Return true if a switch should be expanded as a decision tree.\n+   RANGE is the difference between highest and lowest case.\n+   UNIQ is number of unique case node targets, not counting the default case.\n+   COUNT is the number of comparisons needed, not counting the default case.  */\n \n-void\n-expand_case (gimple stmt)\n+static bool\n+expand_switch_as_decision_tree_p (tree range,\n+\t\t\t\t  unsigned int uniq ATTRIBUTE_UNUSED,\n+\t\t\t\t  unsigned int count)\n {\n-  tree minval = NULL_TREE, maxval = NULL_TREE, range = NULL_TREE;\n-  rtx default_label = 0;\n-  struct case_node *n;\n-  unsigned int count, uniq;\n-  rtx index;\n-  rtx table_label;\n-  int ncases;\n-  rtx *labelvec;\n-  int i;\n-  rtx before_case, end, lab;\n+  int max_ratio;\n+\n+  /* If neither casesi or tablejump is available, or flag_jump_tables\n+     over-ruled us, we really have no choice.  */\n+  if (!HAVE_casesi && !HAVE_tablejump)\n+    return true;\n+  if (!flag_jump_tables)\n+    return true;\n+\n+  /* If the switch is relatively small such that the cost of one\n+     indirect jump on the target are higher than the cost of a\n+     decision tree, go with the decision tree.\n+\n+     If range of values is much bigger than number of values,\n+     or if it is too large to represent in a HOST_WIDE_INT,\n+     make a sequence of conditional branches instead of a dispatch.\n+\n+     The definition of \"much bigger\" depends on whether we are\n+     optimizing for size or for speed.  If the former, the maximum\n+     ratio range/count = 3, because this was found to be the optimal\n+     ratio for size on i686-pc-linux-gnu, see PR11823.  The ratio\n+     10 is much older, and was probably selected after an extensive\n+     benchmarking investigation on numerous platforms.  Or maybe it\n+     just made sense to someone at some point in the history of GCC,\n+     who knows...  */\n+  max_ratio = optimize_insn_for_size_p () ? 3 : 10;\n+  if (count < case_values_threshold ()\n+      || ! host_integerp (range, /*pos=*/1)\n+      || compare_tree_int (range, max_ratio * count) > 0)\n+    return true;\n \n-  tree index_expr = gimple_switch_index (stmt);\n-  tree index_type = TREE_TYPE (index_expr);\n-  int unsignedp = TYPE_UNSIGNED (index_type);\n+  return false;\n+}\n \n-  /* The insn after which the case dispatch should finally\n-     be emitted.  Zero for a dummy.  */\n-  rtx start;\n+/* Generate a decision tree, switching on INDEX_EXPR and jumping to\n+   one of the labels in CASE_LIST or to the DEFAULT_LABEL.\n+   \n+   We generate a binary decision tree to select the appropriate target\n+   code.  This is done as follows:\n \n-  /* A list of case labels; it is first built as a list and it may then\n-     be rearranged into a nearly balanced binary tree.  */\n-  struct case_node *case_list = 0;\n+     If the index is a short or char that we do not have\n+     an insn to handle comparisons directly, convert it to\n+     a full integer now, rather than letting each comparison\n+     generate the conversion.\n+\n+     Load the index into a register.\n+\n+     The list of cases is rearranged into a binary tree,\n+     nearly optimal assuming equal probability for each case.\n+\n+     The tree is transformed into RTL, eliminating redundant\n+     test conditions at the same time.\n \n-  /* Label to jump to if no case matches.  */\n-  tree default_label_decl = NULL_TREE;\n+     If program flow could reach the end of the decision tree\n+     an unconditional jump to the default code is emitted.\n \n-  alloc_pool case_node_pool = create_alloc_pool (\"struct case_node pool\",\n-                                                 sizeof (struct case_node),\n-                                                 100);\n+   The above process is unaware of the CFG.  The caller has to fix up\n+   the CFG itself.  This is done in cfgexpand.c.  */     \n+\n+static void\n+emit_case_decision_tree (tree index_expr, tree index_type,\n+\t\t\t struct case_node *case_list, rtx default_label)\n+{\n+  rtx index = expand_normal (index_expr);\n+\n+  if (GET_MODE_CLASS (GET_MODE (index)) == MODE_INT\n+      && ! have_insn_for (COMPARE, GET_MODE (index)))\n+    {\n+      int unsignedp = TYPE_UNSIGNED (index_type);\n+      enum machine_mode wider_mode;\n+      for (wider_mode = GET_MODE (index); wider_mode != VOIDmode;\n+\t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+\tif (have_insn_for (COMPARE, wider_mode))\n+\t  {\n+\t    index = convert_to_mode (wider_mode, index, unsignedp);\n+\t    break;\n+\t  }\n+    }\n \n   do_pending_stack_adjust ();\n \n-  /* An ERROR_MARK occurs for various reasons including invalid data type.  */\n-  if (index_type != error_mark_node)\n+  if (MEM_P (index))\n     {\n-      tree elt;\n-      bitmap label_bitmap;\n-      int stopi = 0;\n+      index = copy_to_reg (index);\n+      if (TREE_CODE (index_expr) == SSA_NAME)\n+\tset_reg_attrs_for_decl_rtl (SSA_NAME_VAR (index_expr), index);\n+    }\n \n-      /* cleanup_tree_cfg removes all SWITCH_EXPR with their index\n-\t expressions being INTEGER_CST.  */\n-      gcc_assert (TREE_CODE (index_expr) != INTEGER_CST);\n+  balance_case_nodes (&case_list, NULL);\n \n-      /* The default case, if ever taken, is the first element.  */\n-      elt = gimple_switch_label (stmt, 0);\n-      if (!CASE_LOW (elt) && !CASE_HIGH (elt))\n-\t{\n-\t  default_label_decl = CASE_LABEL (elt);\n-\t  stopi = 1;\n-\t}\n+  /* Don't want to include tree-pass.h here.  This code will be moved\n+     to a GIMPLE pass for GCC 4.9 anyway, so for now always dump.  */\n+  if (dump_file && 1/*(dump_flags & TDF_DETAILS)*/)\n+    {\n+      int indent_step = ceil_log2 (TYPE_PRECISION (index_type)) + 2;\n+      fprintf (dump_file, \";; Expanding GIMPLE switch as decision tree:\\n\");\n+      dump_case_nodes (dump_file, case_list, indent_step, 0);\n+    }\n \n-      for (i = gimple_switch_num_labels (stmt) - 1; i >= stopi; --i)\n-\t{\n-\t  tree low, high;\n-\t  elt = gimple_switch_label (stmt, i);\n-\n-\t  low = CASE_LOW (elt);\n-\t  gcc_assert (low);\n-\t  high = CASE_HIGH (elt);\n-\n-\t  /* The canonical from of a case label in GIMPLE is that a simple case\n-\t     has an empty CASE_HIGH.  For the casesi and tablejump expanders,\n-\t     the back ends want simple cases to have high == low.  */\n-\t  gcc_assert (! high || tree_int_cst_lt (low, high));\n-\t  if (! high)\n-\t    high = low;\n-\n-\t  case_list = add_case_node (case_list, index_type, low, high,\n-                                     CASE_LABEL (elt), case_node_pool);\n-\t}\n+  emit_case_nodes (index, case_list, default_label, index_type);\n+  if (default_label)\n+    emit_jump (default_label);\n+}\n \n+/* Generate a dispatch tabler, switching on INDEX_EXPR and jumping to\n+   one of the labels in CASE_LIST or to the DEFAULT_LABEL.\n+   MINVAL, MAXVAL, and RANGE are the extrema and range of the case\n+   labels in CASE_LIST.\n \n-      before_case = start = get_last_insn ();\n-      if (default_label_decl)\n-\tdefault_label = label_rtx (default_label_decl);\n+   First, a jump insn is emitted.  First we try \"casesi\".  If that\n+   fails, try \"tablejump\".   A target *must* have one of them (or both).\n+\n+   Then, a table with the target labels is emitted.\n+\n+   The process is unaware of the CFG.  The caller has to fix up\n+   the CFG itself.  This is done in cfgexpand.c.  */     \n+\n+static void\n+emit_case_dispatch_table (tree index_expr, tree index_type,\n+\t\t\t  struct case_node *case_list, rtx default_label,\n+\t\t\t  tree minval, tree maxval, tree range)\n+{\n+  int i, ncases;\n+  struct case_node *n;\n+  rtx *labelvec;\n+  rtx fallback_label = label_rtx (case_list->code_label);\n+  rtx table_label = gen_label_rtx ();\n \n-      /* Get upper and lower bounds of case values.  */\n+  if (! try_casesi (index_type, index_expr, minval, range,\n+\t\t    table_label, default_label, fallback_label))\n+    {\n+      bool ok;\n \n-      uniq = 0;\n-      count = 0;\n-      label_bitmap = BITMAP_ALLOC (NULL);\n-      for (n = case_list; n; n = n->right)\n+      /* Index jumptables from zero for suitable values of minval to avoid\n+\t a subtraction.  For the rationale see:\n+\t \"http://gcc.gnu.org/ml/gcc-patches/2001-10/msg01234.html\".  */\n+      if (optimize_insn_for_speed_p ()\n+\t  && compare_tree_int (minval, 0) > 0\n+\t  && compare_tree_int (minval, 3) < 0)\n \t{\n-\t  /* Count the elements and track the largest and smallest\n-\t     of them (treating them as signed even if they are not).  */\n-\t  if (count++ == 0)\n-\t    {\n-\t      minval = n->low;\n-\t      maxval = n->high;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (tree_int_cst_lt (n->low, minval))\n-\t\tminval = n->low;\n-\t      if (tree_int_cst_lt (maxval, n->high))\n-\t\tmaxval = n->high;\n-\t    }\n-\t  /* A range counts double, since it requires two compares.  */\n-\t  if (! tree_int_cst_equal (n->low, n->high))\n-\t    count++;\n-\n-\t  /* If we have not seen this label yet, then increase the\n-\t     number of unique case node targets seen.  */\n-\t  lab = label_rtx (n->code_label);\n-\t  if (bitmap_set_bit (label_bitmap, CODE_LABEL_NUMBER (lab)))\n-\t    uniq++;\n+\t  minval = build_int_cst (index_type, 0);\n+\t  range = maxval;\n \t}\n \n-      BITMAP_FREE (label_bitmap);\n-\n-      /* cleanup_tree_cfg removes all SWITCH_EXPR with a single\n-\t destination, such as one with a default case only.\n-\t It also removes cases that are out of range for the switch\n-\t type, so we should never get a zero here.  */\n-      gcc_assert (count > 0);\n-\n-      /* Compute span of values.  */\n-      range = fold_build2 (MINUS_EXPR, index_type, maxval, minval);\n-\n-      /* If range of values is much bigger than number of values,\n-\t make a sequence of conditional branches instead of a dispatch.\n-\t If the switch-index is a constant, do it this way\n-\t because we can optimize it.  */\n-\n-      if (count < case_values_threshold ()\n-\t  || compare_tree_int (range,\n-\t\t\t       (optimize_insn_for_size_p () ? 3 : 10) * count) > 0\n-\t  /* RANGE may be signed, and really large ranges will show up\n-\t     as negative numbers.  */\n-\t  || compare_tree_int (range, 0) < 0\n-\t  || !flag_jump_tables\n-\t  || TREE_CONSTANT (index_expr)\n-\t  /* If neither casesi or tablejump is available, we can\n-\t     only go this way.  */\n-\t  || (!HAVE_casesi && !HAVE_tablejump))\n-\t{\n-\t  index = expand_normal (index_expr);\n+      ok = try_tablejump (index_type, index_expr, minval, range,\n+\t\t\t  table_label, default_label);\n+      gcc_assert (ok);\n+    }\n \n-\t  /* If the index is a short or char that we do not have\n-\t     an insn to handle comparisons directly, convert it to\n-\t     a full integer now, rather than letting each comparison\n-\t     generate the conversion.  */\n+  /* Get table of labels to jump to, in order of case index.  */\n \n-\t  if (GET_MODE_CLASS (GET_MODE (index)) == MODE_INT\n-\t      && ! have_insn_for (COMPARE, GET_MODE (index)))\n-\t    {\n-\t      enum machine_mode wider_mode;\n-\t      for (wider_mode = GET_MODE (index); wider_mode != VOIDmode;\n-\t\t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n-\t\tif (have_insn_for (COMPARE, wider_mode))\n-\t\t  {\n-\t\t    index = convert_to_mode (wider_mode, index, unsignedp);\n-\t\t    break;\n-\t\t  }\n-\t    }\n+  ncases = tree_low_cst (range, 0) + 1;\n+  labelvec = XALLOCAVEC (rtx, ncases);\n+  memset (labelvec, 0, ncases * sizeof (rtx));\n \n-\t  do_pending_stack_adjust ();\n+  for (n = case_list; n; n = n->right)\n+    {\n+      /* Compute the low and high bounds relative to the minimum\n+\t value since that should fit in a HOST_WIDE_INT while the\n+\t actual values may not.  */\n+      HOST_WIDE_INT i_low\n+\t= tree_low_cst (fold_build2 (MINUS_EXPR, index_type,\n+\t\t\t\t     n->low, minval), 1);\n+      HOST_WIDE_INT i_high\n+\t= tree_low_cst (fold_build2 (MINUS_EXPR, index_type,\n+\t\t\t\t     n->high, minval), 1);\n+      HOST_WIDE_INT i;\n+\n+      for (i = i_low; i <= i_high; i ++)\n+\tlabelvec[i]\n+\t  = gen_rtx_LABEL_REF (Pmode, label_rtx (n->code_label));\n+    }\n \n-\t  if (MEM_P (index))\n-\t    {\n-\t      index = copy_to_reg (index);\n-\t      if (TREE_CODE (index_expr) == SSA_NAME)\n-\t\tset_reg_attrs_for_decl_rtl (SSA_NAME_VAR (index_expr), index);\n-\t    }\n+  /* Fill in the gaps with the default.  We may have gaps at\n+     the beginning if we tried to avoid the minval subtraction,\n+     so substitute some label even if the default label was\n+     deemed unreachable.  */\n+  if (!default_label)\n+    default_label = fallback_label;\n+  for (i = 0; i < ncases; i++)\n+    if (labelvec[i] == 0)\n+      labelvec[i] = gen_rtx_LABEL_REF (Pmode, default_label);\n+\n+  /* Output the table.  */\n+  emit_label (table_label);\n+\n+  if (CASE_VECTOR_PC_RELATIVE || flag_pic)\n+    emit_jump_insn (gen_rtx_ADDR_DIFF_VEC (CASE_VECTOR_MODE,\n+\t\t\t\t\t   gen_rtx_LABEL_REF (Pmode, table_label),\n+\t\t\t\t\t   gen_rtvec_v (ncases, labelvec),\n+\t\t\t\t\t   const0_rtx, const0_rtx));\n+  else\n+    emit_jump_insn (gen_rtx_ADDR_VEC (CASE_VECTOR_MODE,\n+\t\t\t\t      gen_rtvec_v (ncases, labelvec)));\n \n-\t  /* We generate a binary decision tree to select the\n-\t     appropriate target code.  This is done as follows:\n+  /* Record no drop-through after the table.  */\n+  emit_barrier ();\n+}\n \n-\t     The list of cases is rearranged into a binary tree,\n-\t     nearly optimal assuming equal probability for each case.\n+/* Terminate a case (Pascal/Ada) or switch (C) statement\n+   in which ORIG_INDEX is the expression to be tested.\n+   If ORIG_TYPE is not NULL, it is the original ORIG_INDEX\n+   type as given in the source before any compiler conversions.\n+   Generate the code to test it and jump to the right place.  */\n+\n+void\n+expand_case (gimple stmt)\n+{\n+  tree minval = NULL_TREE, maxval = NULL_TREE, range = NULL_TREE;\n+  rtx default_label = NULL_RTX;\n+  unsigned int count, uniq;\n+  int i, stopi = 0;\n+  rtx before_case, end;\n+  int ncases = gimple_switch_num_labels (stmt);\n+  tree index_expr = gimple_switch_index (stmt);\n+  tree index_type = TREE_TYPE (index_expr);\n \n-\t     The tree is transformed into RTL, eliminating\n-\t     redundant test conditions at the same time.\n+  tree elt;\n+  bitmap label_bitmap;\n \n-\t     If program flow could reach the end of the\n-\t     decision tree an unconditional jump to the\n-\t     default code is emitted.  */\n+  /* The insn after which the case dispatch should finally\n+     be emitted.  Zero for a dummy.  */\n+  rtx start;\n \n-\t  balance_case_nodes (&case_list, NULL);\n-\t  emit_case_nodes (index, case_list, default_label, index_type);\n-\t  if (default_label)\n-\t    emit_jump (default_label);\n-\t}\n-      else\n-\t{\n-\t  rtx fallback_label = label_rtx (case_list->code_label);\n-\t  table_label = gen_label_rtx ();\n-\t  if (! try_casesi (index_type, index_expr, minval, range,\n-\t\t\t    table_label, default_label, fallback_label))\n-\t    {\n-\t      bool ok;\n+  /* A list of case labels; it is first built as a list and it may then\n+     be rearranged into a nearly balanced binary tree.  */\n+  struct case_node *case_list = 0;\n \n-\t      /* Index jumptables from zero for suitable values of\n-                 minval to avoid a subtraction.  */\n-\t      if (optimize_insn_for_speed_p ()\n-\t\t  && compare_tree_int (minval, 0) > 0\n-\t\t  && compare_tree_int (minval, 3) < 0)\n-\t\t{\n-\t\t  minval = build_int_cst (index_type, 0);\n-\t\t  range = maxval;\n-\t\t}\n+  /* A pool for case nodes.  */\n+  alloc_pool case_node_pool;\n \n-\t      ok = try_tablejump (index_type, index_expr, minval, range,\n-\t\t\t\t  table_label, default_label);\n-\t      gcc_assert (ok);\n-\t    }\n+  /* An ERROR_MARK occurs for various reasons including invalid data type.\n+     ??? Can this still happen, with GIMPLE and all?  */\n+  if (index_type == error_mark_node)\n+    return;\n \n-\t  /* Get table of labels to jump to, in order of case index.  */\n+  /* cleanup_tree_cfg removes all SWITCH_EXPR with their index\n+     expressions being INTEGER_CST.  */\n+  gcc_assert (TREE_CODE (index_expr) != INTEGER_CST);\n+  \n+  case_node_pool = create_alloc_pool (\"struct case_node pool\",\n+\t\t\t\t      sizeof (struct case_node),\n+\t\t\t\t      100);\n \n-\t  ncases = tree_low_cst (range, 0) + 1;\n-\t  labelvec = XALLOCAVEC (rtx, ncases);\n-\t  memset (labelvec, 0, ncases * sizeof (rtx));\n+  do_pending_stack_adjust ();\n \n-\t  for (n = case_list; n; n = n->right)\n-\t    {\n-\t      /* Compute the low and high bounds relative to the minimum\n-\t\t value since that should fit in a HOST_WIDE_INT while the\n-\t\t actual values may not.  */\n-\t      HOST_WIDE_INT i_low\n-\t\t= tree_low_cst (fold_build2 (MINUS_EXPR, index_type,\n-\t\t\t\t\t     n->low, minval), 1);\n-\t      HOST_WIDE_INT i_high\n-\t\t= tree_low_cst (fold_build2 (MINUS_EXPR, index_type,\n-\t\t\t\t\t     n->high, minval), 1);\n-\t      HOST_WIDE_INT i;\n-\n-\t      for (i = i_low; i <= i_high; i ++)\n-\t\tlabelvec[i]\n-\t\t  = gen_rtx_LABEL_REF (Pmode, label_rtx (n->code_label));\n-\t    }\n+  /* The default case, if ever taken, is the first element.  */\n+  elt = gimple_switch_label (stmt, 0);\n+  if (!CASE_LOW (elt) && !CASE_HIGH (elt))\n+    {\n+      default_label = label_rtx (CASE_LABEL (elt));\n+      stopi = 1;\n+    }\n \n-\t  /* Fill in the gaps with the default.  We may have gaps at\n-\t     the beginning if we tried to avoid the minval subtraction,\n-\t     so substitute some label even if the default label was\n-\t     deemed unreachable.  */\n-\t  if (!default_label)\n-\t    default_label = fallback_label;\n-\t  for (i = 0; i < ncases; i++)\n-\t    if (labelvec[i] == 0)\n-\t      labelvec[i] = gen_rtx_LABEL_REF (Pmode, default_label);\n-\n-\t  /* Output the table.  */\n-\t  emit_label (table_label);\n-\n-\t  if (CASE_VECTOR_PC_RELATIVE || flag_pic)\n-\t    emit_jump_insn (gen_rtx_ADDR_DIFF_VEC (CASE_VECTOR_MODE,\n-\t\t\t\t\t\t   gen_rtx_LABEL_REF (Pmode, table_label),\n-\t\t\t\t\t\t   gen_rtvec_v (ncases, labelvec),\n-\t\t\t\t\t\t   const0_rtx, const0_rtx));\n-\t  else\n-\t    emit_jump_insn (gen_rtx_ADDR_VEC (CASE_VECTOR_MODE,\n-\t\t\t\t\t      gen_rtvec_v (ncases, labelvec)));\n+  /* Get upper and lower bounds of case values.  */\n+  elt = gimple_switch_label (stmt, stopi);\n+  minval = fold_convert (index_type, CASE_LOW (elt));\n+  elt = gimple_switch_label (stmt, ncases - 1);\n+  if (CASE_HIGH (elt))\n+    maxval = fold_convert (index_type, CASE_HIGH (elt));\n+  else\n+    maxval = fold_convert (index_type, CASE_LOW (elt));\n \n-\t  /* Record no drop-through after the table.  */\n-\t  emit_barrier ();\n-\t}\n+  /* Compute span of values.  */\n+  range = fold_build2 (MINUS_EXPR, index_type, maxval, minval);\n \n-      before_case = NEXT_INSN (before_case);\n-      end = get_last_insn ();\n-      reorder_insns (before_case, end, start);\n+  /* Listify the labels queue and gather some numbers to decide\n+     how to expand this switch().  */\n+  uniq = 0;\n+  count = 0;\n+  label_bitmap = BITMAP_ALLOC (NULL);\n+  for (i = gimple_switch_num_labels (stmt) - 1; i >= stopi; --i)\n+    {\n+      tree low, high;\n+      rtx lab;\n+\n+      elt = gimple_switch_label (stmt, i);\n+      low = CASE_LOW (elt);\n+      gcc_assert (low);\n+      high = CASE_HIGH (elt);\n+      gcc_assert (! high || tree_int_cst_lt (low, high));\n+\n+      /* Count the elements.\n+\t A range counts double, since it requires two compares.  */\n+      count++;\n+      if (high)\n+\tcount++;\n+\n+      /* If we have not seen this label yet, then increase the\n+\t number of unique case node targets seen.  */\n+      lab = label_rtx (CASE_LABEL (elt));\n+      if (bitmap_set_bit (label_bitmap, CODE_LABEL_NUMBER (lab)))\n+\tuniq++;\n+\n+      /* The canonical from of a case label in GIMPLE is that a simple case\n+\t has an empty CASE_HIGH.  For the casesi and tablejump expanders,\n+\t the back ends want simple cases to have high == low.  */\n+      if (! high)\n+\thigh = low;\n+\n+      case_list = add_case_node (case_list, index_type, low, high,\n+\t\t\t\t CASE_LABEL (elt), case_node_pool);\n     }\n+  BITMAP_FREE (label_bitmap);\n+\n+  /* cleanup_tree_cfg removes all SWITCH_EXPR with a single\n+     destination, such as one with a default case only.\n+     It also removes cases that are out of range for the switch\n+     type, so we should never get a zero here.  */\n+  gcc_assert (count > 0);\n+\n+  before_case = start = get_last_insn ();\n+\n+  /* Decide how to expand this switch.\n+     The two options at this point are a dispatch table (casesi or\n+     tablejump) or a decision tree.  */\n+\n+  if (expand_switch_as_decision_tree_p (range, uniq, count))\n+    emit_case_decision_tree (index_expr, index_type,\n+\t\t\t     case_list, default_label);\n+  else\n+    emit_case_dispatch_table (index_expr, index_type,\n+\t\t\t      case_list, default_label,\n+\t\t\t      minval, maxval, range);\n+\n+  before_case = NEXT_INSN (before_case);\n+  end = get_last_insn ();\n+  reorder_insns (before_case, end, start);\n \n   free_temp_slots ();\n   free_alloc_pool (case_node_pool);"}, {"sha": "c6870a1ef875da5bb46d91ca5fb69006b7529093", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04a40cb9599281348f70d6758f77da7a4cd4caa5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04a40cb9599281348f70d6758f77da7a4cd4caa5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=04a40cb9599281348f70d6758f77da7a4cd4caa5", "patch": "@@ -1,3 +1,7 @@\n+2012-07-05  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* gcc.c-torture/compile/20000326-1.c: Fix to not optimize to empty.\n+\n 2012-07-05  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>\n \n \t* gcc.target/arm/fma-sp.c: New testcase."}, {"sha": "3b38106a50bf4491dac298632510f5a0d21fdc63", "filename": "gcc/testsuite/gcc.c-torture/compile/20000326-1.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04a40cb9599281348f70d6758f77da7a4cd4caa5/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20000326-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04a40cb9599281348f70d6758f77da7a4cd4caa5/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20000326-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20000326-1.c?ref=04a40cb9599281348f70d6758f77da7a4cd4caa5", "patch": "@@ -2,22 +2,21 @@ long sys_reboot(int magic1, int magic2, int cmd, void * arg)\n {\n   switch (cmd) {\n   case 0x89ABCDEF:\n-    break;\n+    return 1;\n \n   case 0x00000000:\n-    break;\n+    return 2;\n \n   case 0xCDEF0123:\n-    break;\n+    return 3;\n \n   case 0x4321FEDC:\n-    break;\n+    return 4;\n \n   case 0xA1B2C3D4:\n-    break;\n+    return 5;\n \n   default:\n-    break;\n+    return 0;\n   };\n-  return 0;\n }"}]}