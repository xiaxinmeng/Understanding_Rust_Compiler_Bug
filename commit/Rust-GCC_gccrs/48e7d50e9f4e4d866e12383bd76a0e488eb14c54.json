{"sha": "48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhlN2Q1MGU5ZjRlNGQ4NjZlMTIzODNiZDc2YTBlNDg4ZWIxNGM1NA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-11-22T20:24:44Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-11-22T20:24:44Z"}, "message": "runtime: New lock/note implementation.\n\nFrom-SVN: r181633", "tree": {"sha": "f19dd9facaf8d0ad06290f19a199cc449393ffdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f19dd9facaf8d0ad06290f19a199cc449393ffdd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/comments", "author": null, "committer": null, "parents": [{"sha": "2195c9beb6abfb06b7981643e2f3ea926ec0593b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2195c9beb6abfb06b7981643e2f3ea926ec0593b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2195c9beb6abfb06b7981643e2f3ea926ec0593b"}], "stats": {"total": 998, "additions": 705, "deletions": 293}, "files": [{"sha": "9172f7ed31869683ee5ff4ba75fbe4c9dac95844", "filename": "libgo/Makefile.am", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -394,6 +394,12 @@ else\n rtems_task_variable_add_file =\n endif\n \n+if LIBGO_IS_LINUX\n+runtime_lock_files = runtime/lock_futex.c runtime/thread-linux.c\n+else\n+runtime_lock_files = runtime/lock_sema.c runtime/thread-sema.c\n+endif\n+\n runtime_files = \\\n \truntime/go-append.c \\\n \truntime/go-assert.c \\\n@@ -432,7 +438,6 @@ runtime_files = \\\n \truntime/go-new-channel.c \\\n \truntime/go-new-map.c \\\n \truntime/go-new.c \\\n-\truntime/go-note.c \\\n \truntime/go-panic.c \\\n \truntime/go-print.c \\\n \truntime/go-rec-big.c \\\n@@ -474,6 +479,7 @@ runtime_files = \\\n \truntime/go-unsafe-pointer.c \\\n \truntime/go-unwind.c \\\n \truntime/cpuprof.c \\\n+\t$(runtime_lock_files) \\\n \truntime/mcache.c \\\n \truntime/mcentral.c \\\n \t$(runtime_mem_file) \\"}, {"sha": "1f7fa18f1ec2408e733b88da8c1942e04553ad4a", "filename": "libgo/Makefile.in", "status": "modified", "additions": 63, "deletions": 35, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -198,14 +198,13 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/go-map-index.c runtime/go-map-len.c \\\n \truntime/go-map-range.c runtime/go-nanotime.c \\\n \truntime/go-new-channel.c runtime/go-new-map.c runtime/go-new.c \\\n-\truntime/go-note.c runtime/go-panic.c runtime/go-print.c \\\n-\truntime/go-rec-big.c runtime/go-rec-nb-big.c \\\n-\truntime/go-rec-nb-small.c runtime/go-rec-small.c \\\n-\truntime/go-recover.c runtime/go-reflect.c \\\n-\truntime/go-reflect-call.c runtime/go-reflect-chan.c \\\n-\truntime/go-reflect-map.c runtime/go-rune.c \\\n-\truntime/go-runtime-error.c runtime/go-sched.c \\\n-\truntime/go-select.c runtime/go-semacquire.c \\\n+\truntime/go-panic.c runtime/go-print.c runtime/go-rec-big.c \\\n+\truntime/go-rec-nb-big.c runtime/go-rec-nb-small.c \\\n+\truntime/go-rec-small.c runtime/go-recover.c \\\n+\truntime/go-reflect.c runtime/go-reflect-call.c \\\n+\truntime/go-reflect-chan.c runtime/go-reflect-map.c \\\n+\truntime/go-rune.c runtime/go-runtime-error.c \\\n+\truntime/go-sched.c runtime/go-select.c runtime/go-semacquire.c \\\n \truntime/go-send-big.c runtime/go-send-nb-big.c \\\n \truntime/go-send-nb-small.c runtime/go-send-small.c \\\n \truntime/go-setenv.c runtime/go-signal.c runtime/go-strcmp.c \\\n@@ -218,17 +217,20 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/go-typestring.c runtime/go-unreflect.c \\\n \truntime/go-unsafe-new.c runtime/go-unsafe-newarray.c \\\n \truntime/go-unsafe-pointer.c runtime/go-unwind.c \\\n-\truntime/cpuprof.c runtime/mcache.c runtime/mcentral.c \\\n-\truntime/mem_posix_memalign.c runtime/mem.c runtime/mfinal.c \\\n-\truntime/mfixalloc.c runtime/mgc0.c runtime/mheap.c \\\n-\truntime/msize.c runtime/proc.c runtime/runtime.c \\\n-\truntime/thread.c runtime/yield.c \\\n+\truntime/cpuprof.c runtime/lock_sema.c runtime/thread-sema.c \\\n+\truntime/lock_futex.c runtime/thread-linux.c runtime/mcache.c \\\n+\truntime/mcentral.c runtime/mem_posix_memalign.c runtime/mem.c \\\n+\truntime/mfinal.c runtime/mfixalloc.c runtime/mgc0.c \\\n+\truntime/mheap.c runtime/msize.c runtime/proc.c \\\n+\truntime/runtime.c runtime/thread.c runtime/yield.c \\\n \truntime/rtems-task-variable-add.c chan.c iface.c malloc.c \\\n \tmap.c mprof.c reflect.c sigqueue.c string.c\n-@HAVE_SYS_MMAN_H_FALSE@am__objects_1 = mem_posix_memalign.lo\n-@HAVE_SYS_MMAN_H_TRUE@am__objects_1 = mem.lo\n-@LIBGO_IS_RTEMS_TRUE@am__objects_2 = rtems-task-variable-add.lo\n-am__objects_3 = go-append.lo go-assert.lo go-assert-interface.lo \\\n+@LIBGO_IS_LINUX_FALSE@am__objects_1 = lock_sema.lo thread-sema.lo\n+@LIBGO_IS_LINUX_TRUE@am__objects_1 = lock_futex.lo thread-linux.lo\n+@HAVE_SYS_MMAN_H_FALSE@am__objects_2 = mem_posix_memalign.lo\n+@HAVE_SYS_MMAN_H_TRUE@am__objects_2 = mem.lo\n+@LIBGO_IS_RTEMS_TRUE@am__objects_3 = rtems-task-variable-add.lo\n+am__objects_4 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-byte-array-to-string.lo go-breakpoint.lo go-caller.lo \\\n \tgo-can-convert-interface.lo go-cgo.lo go-chan-cap.lo \\\n \tgo-chan-len.lo go-check-interface.lo go-close.lo \\\n@@ -240,9 +242,9 @@ am__objects_3 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-interface-val-compare.lo go-lock-os-thread.lo \\\n \tgo-make-slice.lo go-map-delete.lo go-map-index.lo \\\n \tgo-map-len.lo go-map-range.lo go-nanotime.lo go-new-channel.lo \\\n-\tgo-new-map.lo go-new.lo go-note.lo go-panic.lo go-print.lo \\\n-\tgo-rec-big.lo go-rec-nb-big.lo go-rec-nb-small.lo \\\n-\tgo-rec-small.lo go-recover.lo go-reflect.lo go-reflect-call.lo \\\n+\tgo-new-map.lo go-new.lo go-panic.lo go-print.lo go-rec-big.lo \\\n+\tgo-rec-nb-big.lo go-rec-nb-small.lo go-rec-small.lo \\\n+\tgo-recover.lo go-reflect.lo go-reflect-call.lo \\\n \tgo-reflect-chan.lo go-reflect-map.lo go-rune.lo \\\n \tgo-runtime-error.lo go-sched.lo go-select.lo go-semacquire.lo \\\n \tgo-send-big.lo go-send-nb-big.lo go-send-nb-small.lo \\\n@@ -252,12 +254,12 @@ am__objects_3 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-type-error.lo go-type-identity.lo go-type-interface.lo \\\n \tgo-type-string.lo go-typedesc-equal.lo go-typestring.lo \\\n \tgo-unreflect.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n-\tgo-unsafe-pointer.lo go-unwind.lo cpuprof.lo mcache.lo \\\n-\tmcentral.lo $(am__objects_1) mfinal.lo mfixalloc.lo mgc0.lo \\\n-\tmheap.lo msize.lo proc.lo runtime.lo thread.lo yield.lo \\\n-\t$(am__objects_2) chan.lo iface.lo malloc.lo map.lo mprof.lo \\\n-\treflect.lo sigqueue.lo string.lo\n-am_libgo_la_OBJECTS = $(am__objects_3)\n+\tgo-unsafe-pointer.lo go-unwind.lo cpuprof.lo $(am__objects_1) \\\n+\tmcache.lo mcentral.lo $(am__objects_2) mfinal.lo mfixalloc.lo \\\n+\tmgc0.lo mheap.lo msize.lo proc.lo runtime.lo thread.lo \\\n+\tyield.lo $(am__objects_3) chan.lo iface.lo malloc.lo map.lo \\\n+\tmprof.lo reflect.lo sigqueue.lo string.lo\n+am_libgo_la_OBJECTS = $(am__objects_4)\n libgo_la_OBJECTS = $(am_libgo_la_OBJECTS)\n libgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(libgo_la_LDFLAGS) \\\n@@ -825,6 +827,8 @@ toolexeclibgotesting_DATA = \\\n @HAVE_SYS_MMAN_H_TRUE@runtime_mem_file = runtime/mem.c\n @LIBGO_IS_RTEMS_FALSE@rtems_task_variable_add_file = \n @LIBGO_IS_RTEMS_TRUE@rtems_task_variable_add_file = runtime/rtems-task-variable-add.c\n+@LIBGO_IS_LINUX_FALSE@runtime_lock_files = runtime/lock_sema.c runtime/thread-sema.c\n+@LIBGO_IS_LINUX_TRUE@runtime_lock_files = runtime/lock_futex.c runtime/thread-linux.c\n runtime_files = \\\n \truntime/go-append.c \\\n \truntime/go-assert.c \\\n@@ -863,7 +867,6 @@ runtime_files = \\\n \truntime/go-new-channel.c \\\n \truntime/go-new-map.c \\\n \truntime/go-new.c \\\n-\truntime/go-note.c \\\n \truntime/go-panic.c \\\n \truntime/go-print.c \\\n \truntime/go-rec-big.c \\\n@@ -905,6 +908,7 @@ runtime_files = \\\n \truntime/go-unsafe-pointer.c \\\n \truntime/go-unwind.c \\\n \truntime/cpuprof.c \\\n+\t$(runtime_lock_files) \\\n \truntime/mcache.c \\\n \truntime/mcentral.c \\\n \t$(runtime_mem_file) \\\n@@ -2490,7 +2494,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-new-channel.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-new-map.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-new.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-note.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-panic.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-print.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-rec-big.Plo@am__quote@\n@@ -2532,6 +2535,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unsafe-pointer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unwind.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iface.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock_futex.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock_sema.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/malloc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/map.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcache.Plo@am__quote@\n@@ -2550,6 +2555,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/runtime.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sigqueue.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/string.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread-linux.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread-sema.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/yield.Plo@am__quote@\n \n@@ -2847,13 +2854,6 @@ go-new.lo: runtime/go-new.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-new.lo `test -f 'runtime/go-new.c' || echo '$(srcdir)/'`runtime/go-new.c\n \n-go-note.lo: runtime/go-note.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-note.lo -MD -MP -MF $(DEPDIR)/go-note.Tpo -c -o go-note.lo `test -f 'runtime/go-note.c' || echo '$(srcdir)/'`runtime/go-note.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-note.Tpo $(DEPDIR)/go-note.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-note.c' object='go-note.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-note.lo `test -f 'runtime/go-note.c' || echo '$(srcdir)/'`runtime/go-note.c\n-\n go-panic.lo: runtime/go-panic.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-panic.lo -MD -MP -MF $(DEPDIR)/go-panic.Tpo -c -o go-panic.lo `test -f 'runtime/go-panic.c' || echo '$(srcdir)/'`runtime/go-panic.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-panic.Tpo $(DEPDIR)/go-panic.Plo\n@@ -3141,6 +3141,34 @@ cpuprof.lo: runtime/cpuprof.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cpuprof.lo `test -f 'runtime/cpuprof.c' || echo '$(srcdir)/'`runtime/cpuprof.c\n \n+lock_sema.lo: runtime/lock_sema.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT lock_sema.lo -MD -MP -MF $(DEPDIR)/lock_sema.Tpo -c -o lock_sema.lo `test -f 'runtime/lock_sema.c' || echo '$(srcdir)/'`runtime/lock_sema.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/lock_sema.Tpo $(DEPDIR)/lock_sema.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/lock_sema.c' object='lock_sema.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o lock_sema.lo `test -f 'runtime/lock_sema.c' || echo '$(srcdir)/'`runtime/lock_sema.c\n+\n+thread-sema.lo: runtime/thread-sema.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT thread-sema.lo -MD -MP -MF $(DEPDIR)/thread-sema.Tpo -c -o thread-sema.lo `test -f 'runtime/thread-sema.c' || echo '$(srcdir)/'`runtime/thread-sema.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/thread-sema.Tpo $(DEPDIR)/thread-sema.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/thread-sema.c' object='thread-sema.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o thread-sema.lo `test -f 'runtime/thread-sema.c' || echo '$(srcdir)/'`runtime/thread-sema.c\n+\n+lock_futex.lo: runtime/lock_futex.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT lock_futex.lo -MD -MP -MF $(DEPDIR)/lock_futex.Tpo -c -o lock_futex.lo `test -f 'runtime/lock_futex.c' || echo '$(srcdir)/'`runtime/lock_futex.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/lock_futex.Tpo $(DEPDIR)/lock_futex.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/lock_futex.c' object='lock_futex.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o lock_futex.lo `test -f 'runtime/lock_futex.c' || echo '$(srcdir)/'`runtime/lock_futex.c\n+\n+thread-linux.lo: runtime/thread-linux.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT thread-linux.lo -MD -MP -MF $(DEPDIR)/thread-linux.Tpo -c -o thread-linux.lo `test -f 'runtime/thread-linux.c' || echo '$(srcdir)/'`runtime/thread-linux.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/thread-linux.Tpo $(DEPDIR)/thread-linux.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/thread-linux.c' object='thread-linux.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o thread-linux.lo `test -f 'runtime/thread-linux.c' || echo '$(srcdir)/'`runtime/thread-linux.c\n+\n mcache.lo: runtime/mcache.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT mcache.lo -MD -MP -MF $(DEPDIR)/mcache.Tpo -c -o mcache.lo `test -f 'runtime/mcache.c' || echo '$(srcdir)/'`runtime/mcache.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/mcache.Tpo $(DEPDIR)/mcache.Plo"}, {"sha": "18cf595536480e0f4b5d0d9957ec6e9c2cdd2f92", "filename": "libgo/runtime/cpuprof.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fcpuprof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fcpuprof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fcpuprof.c?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -115,12 +115,6 @@ static void add(Profile*, uintptr*, int32);\n static bool evict(Profile*, Entry*);\n static bool flushlog(Profile*);\n \n-void\n-runtime_cpuprofinit(void)\n-{\n-\truntime_initlock(&lk);\n-}\n-\n // LostProfileData is a no-op function used in profiles\n // to mark the number of profiling stack traces that were\n // discarded due to slow data writers."}, {"sha": "6fa6a1fa717f1c81d685a08c72a8bfeae8650d67", "filename": "libgo/runtime/go-main.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fgo-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fgo-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-main.c?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -47,11 +47,10 @@ main (int argc, char **argv)\n   g = &runtime_g0;\n   m->curg = g;\n   g->m = m;\n-  runtime_initpanic ();\n   runtime_mallocinit ();\n-  runtime_cpuprofinit ();\n   __go_gc_goroutine_init (&argc);\n \n+  runtime_osinit();\n   runtime_goargs();\n   runtime_goenvs();\n "}, {"sha": "197fb15d2a5370ca0667bf114fcc0b64bfdcacac", "filename": "libgo/runtime/go-nanotime.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fgo-nanotime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fgo-nanotime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-nanotime.c?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Return time in nanoseconds.  This is only used for computing runtime.\n+// Return current time in nanoseconds.\n \n #include <sys/time.h>\n "}, {"sha": "62c229fa0d90f3cbcb6f79249e98fc0172af01b0", "filename": "libgo/runtime/go-note.c", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2195c9beb6abfb06b7981643e2f3ea926ec0593b/libgo%2Fruntime%2Fgo-note.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2195c9beb6abfb06b7981643e2f3ea926ec0593b/libgo%2Fruntime%2Fgo-note.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-note.c?ref=2195c9beb6abfb06b7981643e2f3ea926ec0593b", "patch": "@@ -1,74 +0,0 @@\n-/* go-note.c -- implement notesleep, notewakeup and noteclear.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-/* A note is a one-time notification.  noteclear clears the note.\n-   notesleep waits for a call to notewakeup.  notewakeup wakes up\n-   every thread waiting on the note.  */\n-\n-#include \"go-assert.h\"\n-#include \"runtime.h\"\n-\n-/* We use a single global lock and condition variable.  It would be\n-   better to use a futex on GNU/Linux.  */\n-\n-static pthread_mutex_t note_lock = PTHREAD_MUTEX_INITIALIZER;\n-static pthread_cond_t note_cond = PTHREAD_COND_INITIALIZER;\n-\n-/* noteclear is called before any calls to notesleep or\n-   notewakeup.  */\n-\n-void\n-runtime_noteclear (Note* n)\n-{\n-  int32 i;\n-\n-  i = pthread_mutex_lock (&note_lock);\n-  __go_assert (i == 0);\n-\n-  n->woken = 0;\n-\n-  i = pthread_mutex_unlock (&note_lock);\n-  __go_assert (i == 0);\n-}\n-\n-/* Wait until notewakeup is called.  */\n-\n-void\n-runtime_notesleep (Note* n)\n-{\n-  int32 i;\n-\n-  i = pthread_mutex_lock (&note_lock);\n-  __go_assert (i == 0);\n-\n-  while (!n->woken)\n-    {\n-      i = pthread_cond_wait (&note_cond, &note_lock);\n-      __go_assert (i == 0);\n-    }\n-\n-  i = pthread_mutex_unlock (&note_lock);\n-  __go_assert (i == 0);\n-}\n-\n-/* Wake up every thread sleeping on the note.  */\n-\n-void\n-runtime_notewakeup (Note *n)\n-{\n-  int32 i;\n-\n-  i = pthread_mutex_lock (&note_lock);\n-  __go_assert (i == 0);\n-\n-  n->woken = 1;\n-\n-  i = pthread_cond_broadcast (&note_cond);\n-  __go_assert (i == 0);\n-\n-  i = pthread_mutex_unlock (&note_lock);\n-  __go_assert (i == 0);\n-}"}, {"sha": "7c77c0b418bfa4e03512cdcfa2d1a5d00b5c89b0", "filename": "libgo/runtime/go-semacquire.c", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fgo-semacquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fgo-semacquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-semacquire.c?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -117,35 +117,3 @@ runtime_semrelease (uint32 *addr)\n       __go_assert (i == 0);\n     }\n }\n-\n-\n-#ifndef HAVE_SYNC_FETCH_AND_ADD_4\n-\n-/* For targets which don't have the required sync support.  Really\n-   this should be provided by gcc itself.  FIXME.  */\n-\n-static pthread_mutex_t sync_lock = PTHREAD_MUTEX_INITIALIZER;\n-\n-uint32\n-__sync_fetch_and_add_4(uint32*, uint32)\n-  __attribute__((visibility(\"hidden\")));\n-\n-uint32\n-__sync_fetch_and_add_4(uint32* ptr, uint32 add)\n-{\n-  int i;\n-  uint32 ret;\n-\n-  i = pthread_mutex_lock(&sync_lock);\n-  __go_assert(i == 0);\n-\n-  ret = *ptr;\n-  *ptr += add;\n-\n-  i = pthread_mutex_unlock(&sync_lock);\n-  __go_assert(i == 0);\n-\n-  return ret;\n-}\n-\n-#endif"}, {"sha": "e3b4a25bb7528347717eec08f22e0c44f94be470", "filename": "libgo/runtime/lock_futex.c", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Flock_futex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Flock_futex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Flock_futex.c?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -0,0 +1,146 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"runtime.h\"\n+\n+// This implementation depends on OS-specific implementations of\n+//\n+//\truntime.futexsleep(uint32 *addr, uint32 val, int64 ns)\n+//\t\tAtomically,\n+//\t\t\tif(*addr == val) sleep\n+//\t\tMight be woken up spuriously; that's allowed.\n+//\t\tDon't sleep longer than ns; ns < 0 means forever.\n+//\n+//\truntime.futexwakeup(uint32 *addr, uint32 cnt)\n+//\t\tIf any procs are sleeping on addr, wake up at most cnt.\n+\n+enum\n+{\n+\tMUTEX_UNLOCKED = 0,\n+\tMUTEX_LOCKED = 1,\n+\tMUTEX_SLEEPING = 2,\n+\n+\tACTIVE_SPIN = 4,\n+\tACTIVE_SPIN_CNT = 30,\n+\tPASSIVE_SPIN = 1,\n+};\n+\n+// Possible lock states are MUTEX_UNLOCKED, MUTEX_LOCKED and MUTEX_SLEEPING.\n+// MUTEX_SLEEPING means that there is presumably at least one sleeping thread.\n+// Note that there can be spinning threads during all states - they do not\n+// affect mutex's state.\n+void\n+runtime_lock(Lock *l)\n+{\n+\tuint32 i, v, wait, spin;\n+\n+\tif(m->locks++ < 0)\n+\t\truntime_throw(\"runtime_lock: lock count\");\n+\n+\t// Speculative grab for lock.\n+\tv = runtime_xchg(&l->key, MUTEX_LOCKED);\n+\tif(v == MUTEX_UNLOCKED)\n+\t\treturn;\n+\n+\t// wait is either MUTEX_LOCKED or MUTEX_SLEEPING\n+\t// depending on whether there is a thread sleeping\n+\t// on this mutex.  If we ever change l->key from\n+\t// MUTEX_SLEEPING to some other value, we must be\n+\t// careful to change it back to MUTEX_SLEEPING before\n+\t// returning, to ensure that the sleeping thread gets\n+\t// its wakeup call.\n+\twait = v;\n+\n+\t// On uniprocessor's, no point spinning.\n+\t// On multiprocessors, spin for ACTIVE_SPIN attempts.\n+\tspin = 0;\n+\tif(runtime_ncpu > 1)\n+\t\tspin = ACTIVE_SPIN;\n+\n+\tfor(;;) {\n+\t\t// Try for lock, spinning.\n+\t\tfor(i = 0; i < spin; i++) {\n+\t\t\twhile(l->key == MUTEX_UNLOCKED)\n+\t\t\t\tif(runtime_cas(&l->key, MUTEX_UNLOCKED, wait))\n+\t\t\t\t\treturn;\n+\t\t\truntime_procyield(ACTIVE_SPIN_CNT);\n+\t\t}\n+\n+\t\t// Try for lock, rescheduling.\n+\t\tfor(i=0; i < PASSIVE_SPIN; i++) {\n+\t\t\twhile(l->key == MUTEX_UNLOCKED)\n+\t\t\t\tif(runtime_cas(&l->key, MUTEX_UNLOCKED, wait))\n+\t\t\t\t\treturn;\n+\t\t\truntime_osyield();\n+\t\t}\n+\n+\t\t// Sleep.\n+\t\tv = runtime_xchg(&l->key, MUTEX_SLEEPING);\n+\t\tif(v == MUTEX_UNLOCKED)\n+\t\t\treturn;\n+\t\twait = MUTEX_SLEEPING;\n+\t\truntime_futexsleep(&l->key, MUTEX_SLEEPING, -1);\n+\t}\n+}\n+\n+void\n+runtime_unlock(Lock *l)\n+{\n+\tuint32 v;\n+\n+\tif(--m->locks < 0)\n+\t\truntime_throw(\"runtime_unlock: lock count\");\n+\n+\tv = runtime_xchg(&l->key, MUTEX_UNLOCKED);\n+\tif(v == MUTEX_UNLOCKED)\n+\t\truntime_throw(\"unlock of unlocked lock\");\n+\tif(v == MUTEX_SLEEPING)\n+\t\truntime_futexwakeup(&l->key, 1);\n+}\n+\n+// One-time notifications.\n+void\n+runtime_noteclear(Note *n)\n+{\n+\tn->key = 0;\n+}\n+\n+void\n+runtime_notewakeup(Note *n)\n+{\n+\truntime_xchg(&n->key, 1);\n+\truntime_futexwakeup(&n->key, 1);\n+}\n+\n+void\n+runtime_notesleep(Note *n)\n+{\n+\twhile(runtime_atomicload(&n->key) == 0)\n+\t\truntime_futexsleep(&n->key, 0, -1);\n+}\n+\n+void\n+runtime_notetsleep(Note *n, int64 ns)\n+{\n+\tint64 deadline, now;\n+\n+\tif(ns < 0) {\n+\t\truntime_notesleep(n);\n+\t\treturn;\n+\t}\n+\n+\tif(runtime_atomicload(&n->key) != 0)\n+\t\treturn;\n+\n+\tdeadline = runtime_nanotime() + ns;\n+\tfor(;;) {\n+\t\truntime_futexsleep(&n->key, 0, ns);\n+\t\tif(runtime_atomicload(&n->key) != 0)\n+\t\t\treturn;\n+\t\tnow = runtime_nanotime();\n+\t\tif(now >= deadline)\n+\t\t\treturn;\n+\t\tns = deadline - now;\n+\t}\n+}"}, {"sha": "2fa837d8b0e4ce0696f35e3ac39153c2ba7e882d", "filename": "libgo/runtime/lock_sema.c", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Flock_sema.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Flock_sema.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Flock_sema.c?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -0,0 +1,217 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"runtime.h\"\n+\n+// This implementation depends on OS-specific implementations of\n+//\n+//\tuintptr runtime.semacreate(void)\n+//\t\tCreate a semaphore, which will be assigned to m->waitsema.\n+//\t\tThe zero value is treated as absence of any semaphore,\n+//\t\tso be sure to return a non-zero value.\n+//\n+//\tint32 runtime.semasleep(int64 ns)\n+//\t\tIf ns < 0, acquire m->waitsema and return 0.\n+//\t\tIf ns >= 0, try to acquire m->waitsema for at most ns nanoseconds.\n+//\t\tReturn 0 if the semaphore was acquired, -1 if interrupted or timed out.\n+//\n+//\tint32 runtime.semawakeup(M *mp)\n+//\t\tWake up mp, which is or will soon be sleeping on mp->waitsema.\n+//\n+\n+enum\n+{\n+\tLOCKED = 1,\n+\n+\tACTIVE_SPIN = 4,\n+\tACTIVE_SPIN_CNT = 30,\n+\tPASSIVE_SPIN = 1,\n+};\n+\n+void\n+runtime_lock(Lock *l)\n+{\n+\tuintptr v;\n+\tuint32 i, spin;\n+\n+\tif(m->locks++ < 0)\n+\t\truntime_throw(\"runtime_lock: lock count\");\n+\n+\t// Speculative grab for lock.\n+\tif(runtime_casp(&l->waitm, nil, (void*)LOCKED))\n+\t\treturn;\n+\n+\tif(m->waitsema == 0)\n+\t\tm->waitsema = runtime_semacreate();\n+\n+\t// On uniprocessor's, no point spinning.\n+\t// On multiprocessors, spin for ACTIVE_SPIN attempts.\n+\tspin = 0;\n+\tif(runtime_ncpu > 1)\n+\t\tspin = ACTIVE_SPIN;\n+\n+\tfor(i=0;; i++) {\n+\t\tv = (uintptr)runtime_atomicloadp(&l->waitm);\n+\t\tif((v&LOCKED) == 0) {\n+unlocked:\n+\t\t\tif(runtime_casp(&l->waitm, (void*)v, (void*)(v|LOCKED)))\n+\t\t\t\treturn;\n+\t\t\ti = 0;\n+\t\t}\n+\t\tif(i<spin)\n+\t\t\truntime_procyield(ACTIVE_SPIN_CNT);\n+\t\telse if(i<spin+PASSIVE_SPIN)\n+\t\t\truntime_osyield();\n+\t\telse {\n+\t\t\t// Someone else has it.\n+\t\t\t// l->waitm points to a linked list of M's waiting\n+\t\t\t// for this lock, chained through m->nextwaitm.\n+\t\t\t// Queue this M.\n+\t\t\tfor(;;) {\n+\t\t\t\tm->nextwaitm = (void*)(v&~LOCKED);\n+\t\t\t\tif(runtime_casp(&l->waitm, (void*)v, (void*)((uintptr)m|LOCKED)))\n+\t\t\t\t\tbreak;\n+\t\t\t\tv = (uintptr)runtime_atomicloadp(&l->waitm);\n+\t\t\t\tif((v&LOCKED) == 0)\n+\t\t\t\t\tgoto unlocked;\n+\t\t\t}\n+\t\t\tif(v&LOCKED) {\n+\t\t\t\t// Queued.  Wait.\n+\t\t\t\truntime_semasleep(-1);\n+\t\t\t\ti = 0;\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+void\n+runtime_unlock(Lock *l)\n+{\n+\tuintptr v;\n+\tM *mp;\n+\n+\tif(--m->locks < 0)\n+\t\truntime_throw(\"runtime_unlock: lock count\");\n+\n+\tfor(;;) {\n+\t\tv = (uintptr)runtime_atomicloadp(&l->waitm);\n+\t\tif(v == LOCKED) {\n+\t\t\tif(runtime_casp(&l->waitm, (void*)LOCKED, nil))\n+\t\t\t\tbreak;\n+\t\t} else {\n+\t\t\t// Other M's are waiting for the lock.\n+\t\t\t// Dequeue an M.\n+\t\t\tmp = (void*)(v&~LOCKED);\n+\t\t\tif(runtime_casp(&l->waitm, (void*)v, mp->nextwaitm)) {\n+\t\t\t\t// Dequeued an M.  Wake it.\n+\t\t\t\truntime_semawakeup(mp);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// One-time notifications.\n+void\n+runtime_noteclear(Note *n)\n+{\n+\tn->waitm = nil;\n+}\n+\n+void\n+runtime_notewakeup(Note *n)\n+{\n+\tM *mp;\n+\n+\tdo\n+\t\tmp = runtime_atomicloadp(&n->waitm);\n+\twhile(!runtime_casp(&n->waitm, mp, (void*)LOCKED));\n+\n+\t// Successfully set waitm to LOCKED.\n+\t// What was it before?\n+\tif(mp == nil) {\n+\t\t// Nothing was waiting.  Done.\n+\t} else if(mp == (M*)LOCKED) {\n+\t\t// Two notewakeups!  Not allowed.\n+\t\truntime_throw(\"notewakeup - double wakeup\");\n+\t} else {\n+\t\t// Must be the waiting m.  Wake it up.\n+\t\truntime_semawakeup(mp);\n+\t}\n+}\n+\n+void\n+runtime_notesleep(Note *n)\n+{\n+\tif(m->waitsema == 0)\n+\t\tm->waitsema = runtime_semacreate();\n+\tif(!runtime_casp(&n->waitm, nil, m)) {  // must be LOCKED (got wakeup)\n+\t\tif(n->waitm != (void*)LOCKED)\n+\t\t\truntime_throw(\"notesleep - waitm out of sync\");\n+\t\treturn;\n+\t}\n+\t// Queued.  Sleep.\n+\truntime_semasleep(-1);\n+}\n+\n+void\n+runtime_notetsleep(Note *n, int64 ns)\n+{\n+\tM *mp;\n+\tint64 deadline, now;\n+\n+\tif(ns < 0) {\n+\t\truntime_notesleep(n);\n+\t\treturn;\n+\t}\n+\n+\tif(m->waitsema == 0)\n+\t\tm->waitsema = runtime_semacreate();\n+\n+\t// Register for wakeup on n->waitm.\n+\tif(!runtime_casp(&n->waitm, nil, m)) {  // must be LOCKED (got wakeup already)\n+\t\tif(n->waitm != (void*)LOCKED)\n+\t\t\truntime_throw(\"notetsleep - waitm out of sync\");\n+\t\treturn;\n+\t}\n+\n+\tdeadline = runtime_nanotime() + ns;\n+\tfor(;;) {\n+\t\t// Registered.  Sleep.\n+\t\tif(runtime_semasleep(ns) >= 0) {\n+\t\t\t// Acquired semaphore, semawakeup unregistered us.\n+\t\t\t// Done.\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// Interrupted or timed out.  Still registered.  Semaphore not acquired.\n+\t\tnow = runtime_nanotime();\n+\t\tif(now >= deadline)\n+\t\t\tbreak;\n+\n+\t\t// Deadline hasn't arrived.  Keep sleeping.\n+\t\tns = deadline - now;\n+\t}\n+\n+\t// Deadline arrived.  Still registered.  Semaphore not acquired.\n+\t// Want to give up and return, but have to unregister first,\n+\t// so that any notewakeup racing with the return does not\n+\t// try to grant us the semaphore when we don't expect it.\n+\tfor(;;) {\n+\t\tmp = runtime_atomicloadp(&n->waitm);\n+\t\tif(mp == m) {\n+\t\t\t// No wakeup yet; unregister if possible.\n+\t\t\tif(runtime_casp(&n->waitm, mp, nil))\n+\t\t\t\treturn;\n+\t\t} else if(mp == (M*)LOCKED) {\n+\t\t\t// Wakeup happened so semaphore is available.\n+\t\t\t// Grab it to avoid getting out of sync.\n+\t\t\tif(runtime_semasleep(-1) < 0)\n+\t\t\t\truntime_throw(\"runtime: unable to acquire - semaphore out of sync\");\n+\t\t\treturn;\n+\t\t} else {\n+\t\t\truntime_throw(\"runtime: unexpected waitm - semaphore out of sync\");\n+\t\t}\n+\t}\n+}"}, {"sha": "abf020dab45589615f4ebbca89b709940e1ab42b", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -376,12 +376,6 @@ runtime_mallocinit(void)\n \truntime_MHeap_Init(&runtime_mheap, runtime_SysAlloc);\n \tm->mcache = runtime_allocmcache();\n \n-\t// Initialize malloc profiling.\n-\truntime_Mprof_Init();\n-\n-\t// Initialize finalizer.\n-\truntime_initfintab();\n-\n \t// See if it works.\n \truntime_free(runtime_malloc(1));\n }"}, {"sha": "aad9a65f76a0f94362763987ab1f10dd03f971ed", "filename": "libgo/runtime/malloc.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fmalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fmalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.h?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -405,7 +405,6 @@ enum\n \tFlagNoGC = 1<<2,\t// must not free or scan for pointers\n };\n \n-void\truntime_Mprof_Init(void);\n void\truntime_MProf_Malloc(void*, uintptr);\n void\truntime_MProf_Free(void*, uintptr);\n void\truntime_MProf_Mark(void (*scan)(byte *, int64));"}, {"sha": "00c6f23a33d50be6056e94d72a4a7fe0686568a4", "filename": "libgo/runtime/mcentral.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fmcentral.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fmcentral.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmcentral.c?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -26,7 +26,6 @@ static void MCentral_Free(MCentral *c, void *v);\n void\n runtime_MCentral_Init(MCentral *c, int32 sizeclass)\n {\n-\truntime_initlock(c);\n \tc->sizeclass = sizeclass;\n \truntime_MSpanList_Init(&c->nonempty);\n \truntime_MSpanList_Init(&c->empty);"}, {"sha": "349425190bd2fb47d19737ad635c0311892dd6e9", "filename": "libgo/runtime/mfinal.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fmfinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fmfinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmfinal.c?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -41,15 +41,6 @@ static struct {\n \tuint8 pad[0 /* CacheLineSize - sizeof(Fintab) */];\t\n } fintab[TABSZ];\n \n-void\n-runtime_initfintab()\n-{\n-\tint32 i;\n-\n-\tfor(i=0; i<TABSZ; i++)\n-\t\truntime_initlock(&fintab[i]);\n-}\n-\n static void\n addfintab(Fintab *t, void *k, void (*fn)(void*), const struct __go_func_type *ft)\n {"}, {"sha": "5fd9368c35a6c346bf6197f91b0e4ee46d0bca82", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -860,12 +860,6 @@ runtime_gc(int32 force __attribute__ ((unused)))\n \t\tp = runtime_getenv(\"GOGCTRACE\");\n \t\tif(p != nil)\n \t\t\tgctrace = runtime_atoi(p);\n-\n-\t\truntime_initlock(&work.fmu);\n-\t\truntime_initlock(&work.emu);\n-\t\truntime_initlock(&work.markgate);\n-\t\truntime_initlock(&work.sweepgate);\n-\t\truntime_initlock(&work.Lock);\n \t}\n \tif(gcpercent < 0)\n \t\treturn;"}, {"sha": "4d02bfebd8ee02899ce215ff4d72c5c972d39229", "filename": "libgo/runtime/mheap.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fmheap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fmheap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmheap.c?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -40,7 +40,6 @@ runtime_MHeap_Init(MHeap *h, void *(*alloc)(uintptr))\n {\n \tuint32 i;\n \n-\truntime_initlock(h);\n \truntime_FixAlloc_Init(&h->spanalloc, sizeof(MSpan), alloc, RecordSpan, h);\n \truntime_FixAlloc_Init(&h->cachealloc, sizeof(MCache), alloc, nil, nil);\n \t// h->mapcache needs no init"}, {"sha": "600d8a8a9d2c542b76180050ab576dab7426b05f", "filename": "libgo/runtime/mprof.goc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fmprof.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fmprof.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmprof.goc?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -186,12 +186,6 @@ found:\n \treturn nil;\n }\n \n-void\n-runtime_Mprof_Init()\n-{\n-\truntime_initlock(&proflock);\n-}\n-\n // Called by malloc to record a profiled block.\n void\n runtime_MProf_Malloc(void *p, uintptr size)"}, {"sha": "182ec0e3257727999c4335798966db2556025b81", "filename": "libgo/runtime/runtime.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.c?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -13,12 +13,6 @@ uint32\truntime_panicking;\n \n static Lock paniclk;\n \n-void\n-runtime_initpanic(void)\n-{\n-\truntime_initlock(&paniclk);\n-}\n-\n void\n runtime_startpanic(void)\n {\n@@ -56,7 +50,6 @@ runtime_dopanic(int32 unused __attribute__ ((unused)))\n \t\t// Wait forever without chewing up cpu.\n \t\t// It will exit when it's done.\n \t\tstatic Lock deadlock;\n-\t\truntime_initlock(&deadlock);\n \t\truntime_lock(&deadlock);\n \t\truntime_lock(&deadlock);\n \t}"}, {"sha": "8a4153091e0c856340fb6e99165defc8ab9511f7", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 54, "deletions": 31, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -48,33 +48,17 @@ typedef unsigned int uintptr __attribute__ ((mode (pointer)));\n typedef\tuint8\t\t\tbool;\n typedef\tuint8\t\t\tbyte;\n typedef\tstruct\tG\t\tG;\n+typedef\tunion\tLock\t\tLock;\n typedef\tstruct\tM\t\tM;\n+typedef\tunion\tNote\t\tNote;\n typedef\tstruct\tMCache\t\tMCache;\n typedef struct\tFixAlloc\tFixAlloc;\n-typedef\tstruct\tLock\t\tLock;\n \n typedef\tstruct\t__go_defer_stack\tDefer;\n typedef\tstruct\t__go_panic_stack\tPanic;\n typedef\tstruct\t__go_open_array\t\tSlice;\n typedef\tstruct\t__go_string\t\tString;\n \n-/* We use mutexes for locks.  6g uses futexes directly, and perhaps\n-   someday we will do that too.  */\n-\n-struct\tLock\n-{\n-\tuint32 key;\n-\tsem_t sem;\n-};\n-\n-/* A Note.  */\n-\n-typedef\tstruct\tNote\t\tNote;\n-\n-struct Note {\n-\tint32 woken;\n-};\n-\n /* Per CPU declarations.  */\n \n #ifdef __rtems__\n@@ -99,8 +83,19 @@ enum\n \tfalse\t= 0,\n };\n \n-/* Structures.  */\n-\n+/*\n+ * structures\n+ */\n+union\tLock\n+{\n+\tuint32\tkey;\t// futex-based impl\n+\tM*\twaitm;\t// linked list of waiting M's (sema-based impl)\n+};\n+union\tNote\n+{\n+\tuint32\tkey;\t// futex-based impl\n+\tM*\twaitm;\t// waiting M (sema-based impl)\n+};\n struct\tG\n {\n \tDefer*\tdefer;\n@@ -141,6 +136,10 @@ struct\tM\n \tint32\tprofilehz;\n \tuint32\tfastrand;\n \tMCache\t*mcache;\n+\tM*\tnextwaitm;\t// next M waiting for lock\n+\tuintptr\twaitsema;\t// semaphore for parking on locks\n+\tuint32\twaitsemacount;\n+\tuint32\twaitsemalock;\n \n \t/* For the list of all threads.  */\n \tstruct __go_thread_id *list_entry;\n@@ -173,6 +172,7 @@ enum {\n  * external data\n  */\n extern\tuint32\truntime_panicking;\n+int32\truntime_ncpu;\n \n /*\n  * common functions and data\n@@ -183,13 +183,13 @@ int32\truntime_findnull(const byte*);\n  * very low level c-called\n  */\n void\truntime_args(int32, byte**);\n+void\truntime_osinit();\n void\truntime_goargs(void);\n void\truntime_goenvs(void);\n void\truntime_throw(const char*);\n void*\truntime_mal(uintptr);\n String\truntime_gostringnocopy(byte*);\n void\truntime_mallocinit(void);\n-void\truntime_initfintab(void);\n void\tsiginit(void);\n bool\t__go_sigsend(int32 sig);\n int64\truntime_nanotime(void);\n@@ -208,27 +208,45 @@ void\t__go_cachestats(void);\n  * mutual exclusion locks.  in the uncontended case,\n  * as fast as spin locks (just a few user-level instructions),\n  * but on the contention path they sleep in the kernel.\n+ * a zeroed Lock is unlocked (no need to initialize each lock).\n  */\n-void\truntime_initlock(Lock*);\n void\truntime_lock(Lock*);\n void\truntime_unlock(Lock*);\n-void\truntime_destroylock(Lock*);\n-\n-void runtime_semacquire (uint32 *) asm (\"libgo_runtime.runtime.Semacquire\");\n-void runtime_semrelease (uint32 *) asm (\"libgo_runtime.runtime.Semrelease\");\n \n /*\n  * sleep and wakeup on one-time events.\n  * before any calls to notesleep or notewakeup,\n  * must call noteclear to initialize the Note.\n- * then, any number of threads can call notesleep\n+ * then, exactly one thread can call notesleep\n  * and exactly one thread can call notewakeup (once).\n- * once notewakeup has been called, all the notesleeps\n- * will return.  future notesleeps will return immediately.\n+ * once notewakeup has been called, the notesleep\n+ * will return.  future notesleep will return immediately.\n+ * subsequent noteclear must be called only after\n+ * previous notesleep has returned, e.g. it's disallowed\n+ * to call noteclear straight after notewakeup.\n+ *\n+ * notetsleep is like notesleep but wakes up after\n+ * a given number of nanoseconds even if the event\n+ * has not yet happened.  if a goroutine uses notetsleep to\n+ * wake up early, it must wait to call noteclear until it\n+ * can be sure that no other goroutine is calling\n+ * notewakeup.\n  */\n void\truntime_noteclear(Note*);\n void\truntime_notesleep(Note*);\n void\truntime_notewakeup(Note*);\n+void\truntime_notetsleep(Note*, int64);\n+\n+/*\n+ * low-level synchronization for implementing the above\n+ */\n+uintptr\truntime_semacreate(void);\n+int32\truntime_semasleep(int64);\n+void\truntime_semawakeup(M*);\n+// or\n+void\truntime_futexsleep(uint32*, uint32, int64);\n+void\truntime_futexwakeup(uint32*, uint32);\n+\n \n /* Functions.  */\n #define runtime_printf printf\n@@ -248,17 +266,22 @@ bool\truntime_addfinalizer(void*, void(*fn)(void*), const struct __go_func_type *\n #define runtime_cas(pval, old, new) __sync_bool_compare_and_swap (pval, old, new)\n #define runtime_casp(pval, old, new) __sync_bool_compare_and_swap (pval, old, new)\n #define runtime_xadd(p, v) __sync_add_and_fetch (p, v)\n+#define runtime_xchg(p, v) __atomic_exchange_n (p, v, __ATOMIC_SEQ_CST)\n+#define runtime_atomicload(p) __atomic_load_n (p, __ATOMIC_SEQ_CST)\n+#define runtime_atomicstore(p, v) __atomic_store_n (p, v, __ATOMIC_SEQ_CST)\n+#define runtime_atomicloadp(p) __atomic_load_n (p, __ATOMIC_SEQ_CST)\n+#define runtime_atomicstorep(p, v) __atomic_store_n (p, v, __ATOMIC_SEQ_CST)\n \n-void\truntime_initpanic(void);\n void\truntime_dopanic(int32) __attribute__ ((noreturn));\n void\truntime_startpanic(void);\n const byte*\truntime_getenv(const char*);\n int32\truntime_atoi(const byte*);\n void\truntime_sigprof(uint8 *pc, uint8 *sp, uint8 *lr);\n-void\truntime_cpuprofinit(void);\n void\truntime_resetcpuprofiler(int32);\n void\truntime_setcpuprofilerate(void(*)(uintptr*, int32), int32);\n uint32\truntime_fastrand1(void);\n+void\truntime_semacquire (uint32 *) asm (\"libgo_runtime.runtime.Semacquire\");\n+void\truntime_semrelease (uint32 *) asm (\"libgo_runtime.runtime.Semrelease\");\n void\truntime_procyield(uint32);\n void\truntime_osyield(void);\n void\truntime_usleep(uint32);"}, {"sha": "dde4e707a2dd3b34f96964b095e2c66b951f045c", "filename": "libgo/runtime/thread-linux.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fthread-linux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fthread-linux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fthread-linux.c?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"runtime.h\"\n+\n+#include <errno.h>\n+#include <string.h>\n+#include <time.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <syscall.h>\n+#include <linux/futex.h>\n+\n+typedef struct timespec Timespec;\n+\n+// Atomically,\n+//\tif(*addr == val) sleep\n+// Might be woken up spuriously; that's allowed.\n+// Don't sleep longer than ns; ns < 0 means forever.\n+void\n+runtime_futexsleep(uint32 *addr, uint32 val, int64 ns)\n+{\n+\tTimespec ts, *tsp;\n+\n+\tif(ns < 0)\n+\t\ttsp = nil;\n+\telse {\n+\t\tts.tv_sec = ns/1000000000LL;\n+\t\tts.tv_nsec = ns%1000000000LL;\n+\t\t// Avoid overflowdefs\n+\t\tif(ts.tv_sec > 1<<30)\n+\t\t\tts.tv_sec = 1<<30;\n+\t\ttsp = &ts;\n+\t}\n+\n+\t// Some Linux kernels have a bug where futex of\n+\t// FUTEX_WAIT returns an internal error code\n+\t// as an errno.  Libpthread ignores the return value\n+\t// here, and so can we: as it says a few lines up,\n+\t// spurious wakeups are allowed.\n+\tsyscall(__NR_futex, addr, FUTEX_WAIT, val, tsp, nil, 0);\n+}\n+\n+// If any procs are sleeping on addr, wake up at most cnt.\n+void\n+runtime_futexwakeup(uint32 *addr, uint32 cnt)\n+{\n+\tint64 ret;\n+\n+\tret = syscall(__NR_futex, addr, FUTEX_WAKE, cnt, nil, nil, 0);\n+\n+\tif(ret >= 0)\n+\t\treturn;\n+\n+\t// I don't know that futex wakeup can return\n+\t// EAGAIN or EINTR, but if it does, it would be\n+\t// safe to loop and call futex again.\n+\truntime_printf(\"futexwakeup addr=%p returned %lld\\n\", addr, (long long)ret);\n+\t*(int32*)0x1006 = 0x1006;\n+}\n+\n+static int32\n+getproccount(void)\n+{\n+\tint32 fd, rd, cnt, cpustrlen;\n+\tconst byte *cpustr, *pos;\n+\tbyte *bufpos;\n+\tbyte buf[256];\n+\n+\tfd = open(\"/proc/stat\", O_RDONLY|O_CLOEXEC, 0);\n+\tif(fd == -1)\n+\t\treturn 1;\n+\tcnt = 0;\n+\tbufpos = buf;\n+\tcpustr = (const byte*)\"\\ncpu\";\n+\tcpustrlen = runtime_findnull((const byte*)cpustr);\n+\tfor(;;) {\n+\t\trd = read(fd, bufpos, sizeof(buf)-cpustrlen);\n+\t\tif(rd == -1)\n+\t\t\tbreak;\n+\t\tbufpos[rd] = 0;\n+\t\tfor(pos=buf; (pos=(const byte*)strstr((const char*)pos, (const char*)cpustr)) != nil; cnt++, pos++) {\n+\t\t}\n+\t\tif(rd < cpustrlen)\n+\t\t\tbreak;\n+\t\tmemmove(buf, bufpos+rd-cpustrlen+1, cpustrlen-1);\n+\t\tbufpos = buf+cpustrlen-1;\n+\t}\n+\tclose(fd);\n+\treturn cnt ? cnt : 1;\n+}\n+\n+void\n+runtime_osinit(void)\n+{\n+\truntime_ncpu = getproccount();\n+}"}, {"sha": "b0a6dc337fdd961a88928ac297d901372990cfab", "filename": "libgo/runtime/thread-sema.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fthread-sema.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fthread-sema.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fthread-sema.c?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"runtime.h\"\n+\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <time.h>\n+#include <semaphore.h>\n+\n+/* Create a semaphore.  */\n+\n+uintptr\n+runtime_semacreate(void)\n+{\n+  sem_t *p;\n+\n+  /* Call malloc rather than runtime_malloc.  This will allocate space\n+     on the C heap.  We can't call runtime_malloc here because it\n+     could cause a deadlock.  */\n+  p = malloc (sizeof (sem_t));\n+  if (sem_init (p, 0, 0) != 0)\n+    runtime_throw (\"sem_init\");\n+  return (uintptr) p;\n+}\n+\n+/* Acquire m->waitsema.  */\n+\n+int32\n+runtime_semasleep (int64 ns)\n+{\n+  int r;\n+\n+  if (ns >= 0)\n+    {\n+      struct timespec ts;\n+\n+      ns += runtime_nanotime ();\n+      ts.tv_sec = ns / 1000000000LL;\n+      ts.tv_nsec = ns % 1000000000LL;\n+      r = sem_timedwait ((sem_t *) m->waitsema, &ts);\n+      if (r != 0)\n+\t{\n+\t  if (errno == ETIMEDOUT || errno == EINTR)\n+\t    return -1;\n+\t  runtime_throw (\"sema_timedwait\");\n+\t}\n+      return 0;\n+    }\n+\n+  while (sem_wait ((sem_t *) m->waitsema) != 0)\n+    {\n+      if (errno == EINTR)\n+\tcontinue;\n+      runtime_throw (\"sem_wait\");\n+    }\n+\n+  return 0;\n+}\n+\n+/* Wake up mp->waitsema.  */\n+\n+void\n+runtime_semawakeup (M *mp)\n+{\n+  if (sem_post ((sem_t *) mp->waitsema) != 0)\n+    runtime_throw (\"sem_post\");\n+}\n+\n+void\n+runtime_osinit(void)\n+{\n+}"}, {"sha": "821668bc17af6e26ace086042e0433963579e08a", "filename": "libgo/runtime/thread.c", "status": "modified", "additions": 42, "deletions": 74, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fthread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e7d50e9f4e4d866e12383bd76a0e488eb14c54/libgo%2Fruntime%2Fthread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fthread.c?ref=48e7d50e9f4e4d866e12383bd76a0e488eb14c54", "patch": "@@ -6,98 +6,66 @@\n #include \"runtime.h\"\n #include \"go-assert.h\"\n \n-void\n-runtime_initlock(Lock *l)\n-{\n-\tl->key = 0;\n-\tif(sem_init(&l->sem, 0, 0) != 0)\n-\t\truntime_throw(\"sem_init failed\");\n-}\n+/* For targets which don't have the required sync support.  Really\n+   these should be provided by gcc itself.  FIXME.  */\n \n-// noinline so that runtime_lock doesn't have to split the stack.\n-static void runtime_lock_full(Lock *l) __attribute__ ((noinline));\n+#if !defined (HAVE_SYNC_BOOL_COMPARE_AND_SWAP_4) || !defined (HAVE_SYNC_FETCH_AND_ADD_4)\n \n-static void\n-runtime_lock_full(Lock *l)\n-{\n-\tfor(;;){\n-\t\tif(sem_wait(&l->sem) == 0)\n-\t\t\treturn;\n-\t\tif(errno != EINTR)\n-\t\t\truntime_throw(\"sem_wait failed\");\n-\t}\n-}\n+static pthread_mutex_t sync_lock = PTHREAD_MUTEX_INITIALIZER;\n \n-void\n-runtime_lock(Lock *l)\n-{\n-\tif(m != nil) {\n-\t\tif(m->locks < 0)\n-\t\t\truntime_throw(\"lock count\");\n-\t\tm->locks++;\n-\t}\n-\n-\tif(runtime_xadd(&l->key, 1) > 1)\t// someone else has it; wait\n-\t\truntime_lock_full(l);\n-}\n+#endif\n \n-static void runtime_unlock_full(Lock *l) __attribute__ ((noinline));\n+#ifndef HAVE_SYNC_BOOL_COMPARE_AND_SWAP_4\n \n-static void\n-runtime_unlock_full(Lock *l)\n-{\n-\tif(sem_post(&l->sem) != 0)\n-\t\truntime_throw(\"sem_post failed\");\n-}\n+_Bool\n+__sync_bool_compare_and_swap_4 (uint32*, uint32, uint32)\n+  __attribute__ ((visibility (\"hidden\")));\n \n-void\n-runtime_unlock(Lock *l)\n+_Bool\n+__sync_bool_compare_and_swap_4 (uint32* ptr, uint32 old, uint32 new)\n {\n-\tif(m != nil) {\n-\t\tm->locks--;\n-\t\tif(m->locks < 0)\n-\t\t\truntime_throw(\"lock count\");\n-\t}\n-\n-\tif(runtime_xadd(&l->key, -1) > 0)\t// someone else is waiting\n-\t\truntime_unlock_full(l);\n-}\n+  int i;\n+  _Bool ret;\n \n-void\n-runtime_destroylock(Lock *l)\n-{\n-\tsem_destroy(&l->sem);\n-}\n+  i = pthread_mutex_lock (&sync_lock);\n+  __go_assert (i == 0);\n \n-#ifndef HAVE_SYNC_BOOL_COMPARE_AND_SWAP_4\n+  if (*ptr != old)\n+    ret = 0;\n+  else\n+    {\n+      *ptr = new;\n+      ret = 1;\n+    }\n \n-// For targets which don't have the required sync support.  Really\n-// this should be provided by gcc itself.  FIXME.\n+  i = pthread_mutex_unlock (&sync_lock);\n+  __go_assert (i == 0);\n \n-static pthread_mutex_t sync_lock = PTHREAD_MUTEX_INITIALIZER;\n+  return ret;\n+}\n \n-_Bool\n-__sync_bool_compare_and_swap_4(uint32*, uint32, uint32)\n-  __attribute__((visibility(\"hidden\")));\n+#endif\n \n-_Bool\n-__sync_bool_compare_and_swap_4(uint32* ptr, uint32 old, uint32 new)\n+#ifndef HAVE_SYNC_FETCH_AND_ADD_4\n+\n+uint32\n+__sync_fetch_and_add_4 (uint32*, uint32)\n+  __attribute__ ((visibility (\"hidden\")));\n+\n+uint32\n+__sync_fetch_and_add_4 (uint32* ptr, uint32 add)\n {\n   int i;\n-  _Bool ret;\n+  uint32 ret;\n \n-  i = pthread_mutex_lock(&sync_lock);\n-  __go_assert(i == 0);\n+  i = pthread_mutex_lock (&sync_lock);\n+  __go_assert (i == 0);\n \n-  if(*ptr != old) {\n-    ret = 0;\n-  } else {\n-    *ptr = new;\n-    ret = 1;\n-  }\n+  ret = *ptr;\n+  *ptr += add;\n \n-  i = pthread_mutex_unlock(&sync_lock);\n-  __go_assert(i == 0);\n+  i = pthread_mutex_unlock (&sync_lock);\n+  __go_assert (i == 0);\n \n   return ret;\n }"}]}