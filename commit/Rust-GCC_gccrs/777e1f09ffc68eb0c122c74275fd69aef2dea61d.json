{"sha": "777e1f09ffc68eb0c122c74275fd69aef2dea61d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc3ZTFmMDlmZmM2OGViMGMxMjJjNzQyNzVmZDY5YWVmMmRlYTYxZA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-04-13T09:48:26Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-04-13T09:48:26Z"}, "message": "tree-vect-data-refs.c (vect_analyze_data_ref_dependence): Only add RW dependence for dependence distance zero.\n\n2010-04-13  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence):\n\tOnly add RW dependence for dependence distance zero.\n\tAdjust maximal vectorization factor according to dependences.\n\tMove alignment handling ...\n\t(vect_find_same_alignment_drs): ... here.  New function.\n\t(vect_analyze_data_ref_dependences): Adjust.\n\t(vect_analyze_data_refs_alignment): Call vect_find_same_alignment_drs.\n\t(vect_analyze_data_refs): Adjust minimal vectorization factor\n\taccording to data references.\n\t* tree-vect-loop.c (vect_analyze_loop): Analyze data-ref\n\tdependences before determining the vectorization factor.\n\tAnalyze alignment after determining the vectorization factor.\n\t* tree-vect-slp.c ((vect_slp_analyze_bb): Analyze data-ref\n\tdependences before alignment.\n\t* tree-vectorizer.h (vect_analyze_data_ref_dependences):\n\tAdjust prototype.\n\t(vect_analyze_data_refs): Likewise.\n\t(MAX_VECTORIZATION_FACTOR): New define.\n\n\t* gcc.dg/vect/no-vfa-vect-depend-1.c: Adjust.\n\nFrom-SVN: r158259", "tree": {"sha": "1b7bb981ab3207d6bac81f6a8d4c80f528a0e0ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b7bb981ab3207d6bac81f6a8d4c80f528a0e0ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/777e1f09ffc68eb0c122c74275fd69aef2dea61d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777e1f09ffc68eb0c122c74275fd69aef2dea61d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/777e1f09ffc68eb0c122c74275fd69aef2dea61d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777e1f09ffc68eb0c122c74275fd69aef2dea61d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1a71080889e16d01cccd6af982386633dcec9ec9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a71080889e16d01cccd6af982386633dcec9ec9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a71080889e16d01cccd6af982386633dcec9ec9"}], "stats": {"total": 243, "additions": 190, "deletions": 53}, "files": [{"sha": "32b9987565d1c2e8373449acbef7d5ef12e277ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e1f09ffc68eb0c122c74275fd69aef2dea61d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e1f09ffc68eb0c122c74275fd69aef2dea61d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=777e1f09ffc68eb0c122c74275fd69aef2dea61d", "patch": "@@ -1,3 +1,24 @@\n+2010-04-13  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence):\n+\tOnly add RW dependence for dependence distance zero.\n+\tAdjust maximal vectorization factor according to dependences.\n+\tMove alignment handling ...\n+\t(vect_find_same_alignment_drs): ... here.  New function.\n+\t(vect_analyze_data_ref_dependences): Adjust.\n+\t(vect_analyze_data_refs_alignment): Call vect_find_same_alignment_drs.\n+\t(vect_analyze_data_refs): Adjust minimal vectorization factor\n+\taccording to data references.\n+\t* tree-vect-loop.c (vect_analyze_loop): Analyze data-ref\n+\tdependences before determining the vectorization factor.\n+\tAnalyze alignment after determining the vectorization factor.\n+\t* tree-vect-slp.c ((vect_slp_analyze_bb): Analyze data-ref\n+\tdependences before alignment.\n+\t* tree-vectorizer.h (vect_analyze_data_ref_dependences):\n+\tAdjust prototype.\n+\t(vect_analyze_data_refs): Likewise.\n+\t(MAX_VECTORIZATION_FACTOR): New define.\n+\n 2010-04-13  Duncan Sands  <baldrick@free.fr>\n \n \t* except.h (lang_eh_type_covers): Remove."}, {"sha": "55f5e6358212113f50a3ddd79ed14b8f3c95cdac", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e1f09ffc68eb0c122c74275fd69aef2dea61d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e1f09ffc68eb0c122c74275fd69aef2dea61d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=777e1f09ffc68eb0c122c74275fd69aef2dea61d", "patch": "@@ -1,3 +1,7 @@\n+2010-04-13  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/vect/no-vfa-vect-depend-1.c: Adjust.\n+\n 2010-04-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/derived_type1.adb: New test."}, {"sha": "5679ff765c1c6f0fdfe743ca95966a8d0d347a93", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-depend-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e1f09ffc68eb0c122c74275fd69aef2dea61d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-depend-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e1f09ffc68eb0c122c74275fd69aef2dea61d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-depend-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-depend-1.c?ref=777e1f09ffc68eb0c122c74275fd69aef2dea61d", "patch": "@@ -51,6 +51,6 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" {xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"dependence distance >= VF or negative\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"dependence distance negative\" 1 \"vect\"  } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "ba537a062ef1b199be9effd6d3f9e66b88e79ceb", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 120, "deletions": 28, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e1f09ffc68eb0c122c74275fd69aef2dea61d/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e1f09ffc68eb0c122c74275fd69aef2dea61d/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=777e1f09ffc68eb0c122c74275fd69aef2dea61d", "patch": "@@ -487,21 +487,19 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n \n    Return TRUE if there (might) exist a dependence between a memory-reference\n    DRA and a memory-reference DRB.  When versioning for alias may check a\n-   dependence at run-time, return FALSE.  */\n+   dependence at run-time, return FALSE.  Adjust *MAX_VF according to\n+   the data dependence.  */\n \n static bool\n vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n-                                  loop_vec_info loop_vinfo)\n+                                  loop_vec_info loop_vinfo, int *max_vf)\n {\n   unsigned int i;\n   struct loop *loop = NULL;\n-  int vectorization_factor = 0;\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n   stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra));\n   stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n-  int dra_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dra))));\n-  int drb_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (drb))));\n   lambda_vector dist_v;\n   unsigned int loop_depth;\n \n@@ -513,10 +511,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n     }\n \n   if (loop_vinfo)\n-    {\n-      loop = LOOP_VINFO_LOOP (loop_vinfo);\n-      vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-    }\n+    loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   if ((DR_IS_READ (dra) && DR_IS_READ (drb) && loop_vinfo) || dra == drb)\n     return false;\n@@ -595,17 +590,11 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n       if (vect_print_dump_info (REPORT_DR_DETAILS))\n \tfprintf (vect_dump, \"dependence distance  = %d.\", dist);\n \n-      /* Same loop iteration.  */\n-      if (dist % vectorization_factor == 0 && dra_size == drb_size)\n+      if (dist == 0)\n \t{\n-\t  /* Two references with distance zero have the same alignment.  */\n-\t  VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_a), drb);\n-\t  VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_b), dra);\n-\t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n-\t    fprintf (vect_dump, \"accesses have the same alignment.\");\n \t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n \t    {\n-\t      fprintf (vect_dump, \"dependence distance modulo vf == 0 between \");\n+\t      fprintf (vect_dump, \"dependence distance == 0 between \");\n \t      print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n \t      fprintf (vect_dump, \" and \");\n \t      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n@@ -621,18 +610,36 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n                 DR_GROUP_READ_WRITE_DEPENDENCE (stmtinfo_b) = true;\n \t    }\n \n-          continue;\n+\t  continue;\n+\t}\n+\n+      if (dist > 0 && DDR_REVERSED_P (ddr))\n+\t{\n+\t  /* If DDR_REVERSED_P the order of the data-refs in DDR was\n+\t     reversed (to make distance vector positive), and the actual\n+\t     distance is negative.  */\n+\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t    fprintf (vect_dump, \"dependence distance negative.\");\n+\t  continue;\n+\t}\n+\n+      if (abs (dist) >= 2\n+\t  && abs (dist) < *max_vf)\n+\t{\n+\t  /* The dependence distance requires reduction of the maximal\n+\t     vectorization factor.  */\n+\t  *max_vf = abs (dist);\n+\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t    fprintf (vect_dump, \"adjusting maximal vectorization factor to %i\",\n+\t\t     *max_vf);\n \t}\n \n-      if (abs (dist) >= vectorization_factor\n-          || (dist > 0 && DDR_REVERSED_P (ddr)))\n+      if (abs (dist) >= *max_vf)\n \t{\n \t  /* Dependence distance does not create dependence, as far as\n-\t     vectorization is concerned, in this case. If DDR_REVERSED_P the\n-\t     order of the data-refs in DDR was reversed (to make distance\n-\t     vector positive), and the actual distance is negative.  */\n+\t     vectorization is concerned, in this case.  */\n \t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n-\t    fprintf (vect_dump, \"dependence distance >= VF or negative.\");\n+\t    fprintf (vect_dump, \"dependence distance >= VF.\");\n \t  continue;\n \t}\n \n@@ -654,11 +661,12 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n /* Function vect_analyze_data_ref_dependences.\n \n    Examine all the data references in the loop, and make sure there do not\n-   exist any data dependences between them.  */\n+   exist any data dependences between them.  Set *MAX_VF according to\n+   the maximum vectorization factor the data dependences allow.  */\n \n bool\n vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n-                                   bb_vec_info bb_vinfo)\n+                                   bb_vec_info bb_vinfo, int *max_vf)\n {\n   unsigned int i;\n   VEC (ddr_p, heap) *ddrs = NULL;\n@@ -673,7 +681,7 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n     ddrs = BB_VINFO_DDRS (bb_vinfo);\n \n   for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n-    if (vect_analyze_data_ref_dependence (ddr, loop_vinfo))\n+    if (vect_analyze_data_ref_dependence (ddr, loop_vinfo, max_vf))\n       return false;\n \n   return true;\n@@ -1410,6 +1418,69 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n }\n \n \n+/* Function vect_find_same_alignment_drs.\n+\n+   Update group and alignment relations according to the chosen\n+   vectorization factor.  */\n+\n+static void\n+vect_find_same_alignment_drs (struct data_dependence_relation *ddr,\n+\t\t\t      loop_vec_info loop_vinfo)\n+{\n+  unsigned int i;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  struct data_reference *dra = DDR_A (ddr);\n+  struct data_reference *drb = DDR_B (ddr);\n+  stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra));\n+  stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n+  int dra_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dra))));\n+  int drb_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (drb))));\n+  lambda_vector dist_v;\n+  unsigned int loop_depth;\n+\n+  if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n+    return;\n+\n+  if ((DR_IS_READ (dra) && DR_IS_READ (drb)) || dra == drb)\n+    return;\n+\n+  if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n+    return;\n+\n+  /* Loop-based vectorization and known data dependence.  */\n+  if (DDR_NUM_DIST_VECTS (ddr) == 0)\n+    return;\n+\n+  loop_depth = index_in_loop_nest (loop->num, DDR_LOOP_NEST (ddr));\n+  for (i = 0; VEC_iterate (lambda_vector, DDR_DIST_VECTS (ddr), i, dist_v); i++)\n+    {\n+      int dist = dist_v[loop_depth];\n+\n+      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\tfprintf (vect_dump, \"dependence distance  = %d.\", dist);\n+\n+      /* Same loop iteration.  */\n+      if (dist == 0\n+\t  || (dist % vectorization_factor == 0 && dra_size == drb_size))\n+\t{\n+\t  /* Two references with distance zero have the same alignment.  */\n+\t  VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_a), drb);\n+\t  VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_b), dra);\n+\t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n+\t    fprintf (vect_dump, \"accesses have the same alignment.\");\n+\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t    {\n+\t      fprintf (vect_dump, \"dependence distance modulo vf == 0 between \");\n+\t      print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n+\t      fprintf (vect_dump, \" and \");\n+\t      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n /* Function vect_analyze_data_refs_alignment\n \n    Analyze the alignment of the data-references in the loop.\n@@ -1422,6 +1493,18 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo,\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_data_refs_alignment ===\");\n \n+  /* Mark groups of data references with same alignment using\n+     data dependence information.  */\n+  if (loop_vinfo)\n+    {\n+      VEC (ddr_p, heap) *ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n+      struct data_dependence_relation *ddr;\n+      unsigned int i;\n+\n+      for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n+\tvect_find_same_alignment_drs (ddr, loop_vinfo);\n+    }\n+\n   if (!vect_compute_data_refs_alignment (loop_vinfo, bb_vinfo))\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n@@ -1852,7 +1935,9 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n */\n \n bool\n-vect_analyze_data_refs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n+vect_analyze_data_refs (loop_vec_info loop_vinfo,\n+\t\t\tbb_vec_info bb_vinfo,\n+\t\t\tint *min_vf)\n {\n   struct loop *loop = NULL;\n   basic_block bb = NULL;\n@@ -1907,6 +1992,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n       gimple stmt;\n       stmt_vec_info stmt_info;\n       tree base, offset, init;\n+      int vf;\n \n       if (!dr || !DR_REF (dr))\n         {\n@@ -2079,6 +2165,12 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n             }\n           return false;\n         }\n+\n+      /* Adjust the minimal vectorization factor according to the\n+\t vector type.  */\n+      vf = TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n+      if (vf > *min_vf)\n+\t*min_vf = vf;\n     }\n \n   return true;"}, {"sha": "809f3e15a029c24401722dbeb99645b6f7e928d1", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e1f09ffc68eb0c122c74275fd69aef2dea61d/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e1f09ffc68eb0c122c74275fd69aef2dea61d/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=777e1f09ffc68eb0c122c74275fd69aef2dea61d", "patch": "@@ -1354,6 +1354,8 @@ vect_analyze_loop (struct loop *loop)\n {\n   bool ok;\n   loop_vec_info loop_vinfo;\n+  int max_vf = MAX_VECTORIZATION_FACTOR;\n+  int min_vf = 2;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"===== analyze_loop_nest =====\");\n@@ -1378,12 +1380,13 @@ vect_analyze_loop (struct loop *loop)\n     }\n \n   /* Find all data references in the loop (which correspond to vdefs/vuses)\n-     and analyze their evolution in the loop.\n+     and analyze their evolution in the loop.  Also adjust the minimal\n+     vectorization factor according to the loads and stores.\n \n      FORNOW: Handle only simple, array references, which\n      alignment can be forced, and aligned pointer-references.  */\n \n-  ok = vect_analyze_data_refs (loop_vinfo, NULL);\n+  ok = vect_analyze_data_refs (loop_vinfo, NULL, &min_vf);\n   if (!ok)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1410,14 +1413,17 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n-  /* Analyze the alignment of the data-refs in the loop.\n-     Fail if a data reference is found that cannot be vectorized.  */\n+  /* Analyze data dependences between the data-refs in the loop\n+     and adjust the maximum vectorization factor according to\n+     the dependences.\n+     FORNOW: fail at the first data dependence that we encounter.  */\n \n-  ok = vect_analyze_data_refs_alignment (loop_vinfo, NULL);\n-  if (!ok)\n+  ok = vect_analyze_data_ref_dependences (loop_vinfo, NULL, &max_vf);\n+  if (!ok\n+      || max_vf < min_vf)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"bad data alignment.\");\n+\tfprintf (vect_dump, \"bad data dependence.\");\n       destroy_loop_vec_info (loop_vinfo, true);\n       return NULL;\n     }\n@@ -1430,15 +1436,22 @@ vect_analyze_loop (struct loop *loop)\n       destroy_loop_vec_info (loop_vinfo, true);\n       return NULL;\n     }\n+  if (max_vf < LOOP_VINFO_VECT_FACTOR (loop_vinfo))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"bad data dependence.\");\n+      destroy_loop_vec_info (loop_vinfo, true);\n+      return NULL;\n+    }\n \n-  /* Analyze data dependences between the data-refs in the loop.\n-     FORNOW: fail at the first data dependence that we encounter.  */\n+  /* Analyze the alignment of the data-refs in the loop.\n+     Fail if a data reference is found that cannot be vectorized.  */\n \n-  ok = vect_analyze_data_ref_dependences (loop_vinfo, NULL);\n+  ok = vect_analyze_data_refs_alignment (loop_vinfo, NULL);\n   if (!ok)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"bad data dependence.\");\n+\tfprintf (vect_dump, \"bad data alignment.\");\n       destroy_loop_vec_info (loop_vinfo, true);\n       return NULL;\n     }"}, {"sha": "d25d34787e0c8b96aa291b4fa62972ce4dfdb237", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e1f09ffc68eb0c122c74275fd69aef2dea61d/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e1f09ffc68eb0c122c74275fd69aef2dea61d/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=777e1f09ffc68eb0c122c74275fd69aef2dea61d", "patch": "@@ -1270,6 +1270,8 @@ vect_slp_analyze_bb (basic_block bb)\n   slp_instance instance;\n   int i, insns = 0;\n   gimple_stmt_iterator gsi;\n+  int min_vf = 2;\n+  int max_vf = MAX_VECTORIZATION_FACTOR;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"===vect_slp_analyze_bb===\\n\");\n@@ -1296,7 +1298,7 @@ vect_slp_analyze_bb (basic_block bb)\n   if (!bb_vinfo)\n     return NULL;\n \n-  if (!vect_analyze_data_refs (NULL, bb_vinfo))\n+  if (!vect_analyze_data_refs (NULL, bb_vinfo, &min_vf))\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n         fprintf (vect_dump, \"not vectorized: unhandled data-ref in basic \"\n@@ -1317,6 +1319,17 @@ vect_slp_analyze_bb (basic_block bb)\n       return NULL;\n     }\n \n+   if (!vect_analyze_data_ref_dependences (NULL, bb_vinfo, &max_vf)\n+       || min_vf > max_vf)\n+     {\n+       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+\t fprintf (vect_dump, \"not vectorized: unhandled data dependence \"\n+\t\t  \"in basic block.\\n\");\n+\n+       destroy_bb_vec_info (bb_vinfo);\n+       return NULL;\n+     }\n+\n   if (!vect_analyze_data_refs_alignment (NULL, bb_vinfo))\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n@@ -1327,16 +1340,6 @@ vect_slp_analyze_bb (basic_block bb)\n       return NULL;\n     }\n \n-   if (!vect_analyze_data_ref_dependences (NULL, bb_vinfo))\n-    {\n-     if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-       fprintf (vect_dump, \"not vectorized: unhandled data dependence in basic\"\n-                           \" block.\\n\");\n-\n-      destroy_bb_vec_info (bb_vinfo);\n-      return NULL;\n-    }\n-\n   if (!vect_analyze_data_ref_accesses (NULL, bb_vinfo))\n     {\n      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))"}, {"sha": "52b2a7ec59f71a5a0f840d72428d71498f5de00a", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e1f09ffc68eb0c122c74275fd69aef2dea61d/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e1f09ffc68eb0c122c74275fd69aef2dea61d/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=777e1f09ffc68eb0c122c74275fd69aef2dea61d", "patch": "@@ -601,6 +601,9 @@ typedef struct _stmt_vec_info {\n    conversion.  */\n #define MAX_INTERM_CVT_STEPS         3\n \n+/* The maximum vectorization factor supported by any target (V32QI).  */\n+#define MAX_VECTORIZATION_FACTOR 32\n+\n /* Avoid GTY(()) on stmt_vec_info.  */\n typedef void *vec_void_p;\n DEF_VEC_P (vec_void_p);\n@@ -802,13 +805,14 @@ extern enum dr_alignment_support vect_supportable_dr_alignment\n                                            (struct data_reference *);\n extern tree vect_get_smallest_scalar_type (gimple, HOST_WIDE_INT *,\n                                            HOST_WIDE_INT *);\n-extern bool vect_analyze_data_ref_dependences (loop_vec_info, bb_vec_info);\n+extern bool vect_analyze_data_ref_dependences (loop_vec_info, bb_vec_info,\n+\t\t\t\t\t       int *);\n extern bool vect_enhance_data_refs_alignment (loop_vec_info);\n extern bool vect_analyze_data_refs_alignment (loop_vec_info, bb_vec_info);\n extern bool vect_verify_datarefs_alignment (loop_vec_info, bb_vec_info);\n extern bool vect_analyze_data_ref_accesses (loop_vec_info, bb_vec_info);\n extern bool vect_prune_runtime_alias_test_list (loop_vec_info);\n-extern bool vect_analyze_data_refs (loop_vec_info, bb_vec_info);\n+extern bool vect_analyze_data_refs (loop_vec_info, bb_vec_info, int *);\n extern tree vect_create_data_ref_ptr (gimple, struct loop *, tree, tree *,\n                                       gimple *, bool, bool *);\n extern tree bump_vector_ptr (tree, gimple, gimple_stmt_iterator *, gimple, tree);"}]}