{"sha": "874e50cbd5b254f1f171bf04ecdfeedc405dff5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc0ZTUwY2JkNWIyNTRmMWYxNzFiZjA0ZWNkZmVlZGM0MDVkZmY1Yg==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2018-11-13T22:14:11Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2018-11-13T22:14:11Z"}, "message": "re PR middle-end/87899 (r264897 cause mis-compiled native arm-linux-gnueabihf toolchain)\n\ngcc/\n\tPR rtl-optimization/87899\n\t* lra-lives.c (start_living): Update white space in comment.\n\t(enum point_type): New.\n\t(sparseset_contains_pseudos_p): New function.\n\t(update_pseudo_point): Likewise.\n\t(make_hard_regno_live): Use HARD_REGISTER_NUM_P macro.\n\t(make_hard_regno_dead): Likewise.  Remove ignore_reg_for_conflicts\n\thandling.  Move early exit after adding conflicts.\n\t(mark_pseudo_live): Use HARD_REGISTER_NUM_P macro.  Add early exit\n\tif regno is already live.  Remove all handling of program points.\n\t(mark_pseudo_dead): Use HARD_REGISTER_NUM_P macro.  Add early exit\n\tafter adding conflicts.  Remove all handling of program points and\n\tignore_reg_for_conflicts.\n\t(mark_regno_live): Use HARD_REGISTER_NUM_P macro.  Remove return value\n\tand do not guard call to mark_pseudo_live.\n\t(mark_regno_dead): Use HARD_REGISTER_NUM_P macro.  Remove return value\n\tand do not guard call to mark_pseudo_dead.\n\t(check_pseudos_live_through_calls): Use HARD_REGISTER_NUM_P macro.\n\t(process_bb_lives): Use HARD_REGISTER_NUM_P and HARD_REGISTER_P macros.\n\tUse new function update_pseudo_point.  Handle register copies by\n\tremoving the source register from the live set.  Handle INOUT operands.\n\tUpdate to the next program point using the unused_set, dead_set and\n\tstart_dying sets.\n\t(lra_create_live_ranges_1): Use HARD_REGISTER_NUM_P macro.\n\nFrom-SVN: r266086", "tree": {"sha": "ba4baaa82eb6e5e4238d81d1c2fa872b736a13d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba4baaa82eb6e5e4238d81d1c2fa872b736a13d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/874e50cbd5b254f1f171bf04ecdfeedc405dff5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/874e50cbd5b254f1f171bf04ecdfeedc405dff5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/874e50cbd5b254f1f171bf04ecdfeedc405dff5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/874e50cbd5b254f1f171bf04ecdfeedc405dff5b/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "620e594be58d2f933902a6619fd20aa618070b4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/620e594be58d2f933902a6619fd20aa618070b4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/620e594be58d2f933902a6619fd20aa618070b4b"}], "stats": {"total": 354, "additions": 202, "deletions": 152}, "files": [{"sha": "da5a5382f5677d3a016af8a8c8d6f48a383dbf98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874e50cbd5b254f1f171bf04ecdfeedc405dff5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874e50cbd5b254f1f171bf04ecdfeedc405dff5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=874e50cbd5b254f1f171bf04ecdfeedc405dff5b", "patch": "@@ -1,3 +1,30 @@\n+2018-11-13  Peter Bergner  <bergner@linux.ibm.com>\n+\n+\tPR rtl-optimization/87899\n+\t* lra-lives.c (start_living): Update white space in comment.\n+\t(enum point_type): New.\n+\t(sparseset_contains_pseudos_p): New function.\n+\t(update_pseudo_point): Likewise.\n+\t(make_hard_regno_live): Use HARD_REGISTER_NUM_P macro.\n+\t(make_hard_regno_dead): Likewise.  Remove ignore_reg_for_conflicts\n+\thandling.  Move early exit after adding conflicts.\n+\t(mark_pseudo_live): Use HARD_REGISTER_NUM_P macro.  Add early exit\n+\tif regno is already live.  Remove all handling of program points.\n+\t(mark_pseudo_dead): Use HARD_REGISTER_NUM_P macro.  Add early exit\n+\tafter adding conflicts.  Remove all handling of program points and\n+\tignore_reg_for_conflicts.\n+\t(mark_regno_live): Use HARD_REGISTER_NUM_P macro.  Remove return value\n+\tand do not guard call to mark_pseudo_live.\n+\t(mark_regno_dead): Use HARD_REGISTER_NUM_P macro.  Remove return value\n+\tand do not guard call to mark_pseudo_dead.\n+\t(check_pseudos_live_through_calls): Use HARD_REGISTER_NUM_P macro.\n+\t(process_bb_lives): Use HARD_REGISTER_NUM_P and HARD_REGISTER_P macros.\n+\tUse new function update_pseudo_point.  Handle register copies by\n+\tremoving the source register from the live set.  Handle INOUT operands.\n+\tUpdate to the next program point using the unused_set, dead_set and\n+\tstart_dying sets.\n+\t(lra_create_live_ranges_1): Use HARD_REGISTER_NUM_P macro.\n+\n 2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n \n \t* builtins.c: Replace \"source_location\" with \"location_t\"."}, {"sha": "da47692c9041601c03eedbcd93a1881b7e51b0af", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 175, "deletions": 152, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874e50cbd5b254f1f171bf04ecdfeedc405dff5b/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874e50cbd5b254f1f171bf04ecdfeedc405dff5b/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=874e50cbd5b254f1f171bf04ecdfeedc405dff5b", "patch": "@@ -83,7 +83,7 @@ static HARD_REG_SET hard_regs_live;\n \n /* Set of pseudos and hard registers start living/dying in the current\n    insn.  These sets are used to update REG_DEAD and REG_UNUSED notes\n-   in the insn.\t */\n+   in the insn.  */\n static sparseset start_living, start_dying;\n \n /* Set of pseudos and hard regs dead and unused in the current\n@@ -96,10 +96,6 @@ static bitmap_head temp_bitmap;\n /* Pool for pseudo live ranges.\t */\n static object_allocator<lra_live_range> lra_live_range_pool (\"live ranges\");\n \n-/* If non-NULL, the source operand of a register to register copy for which\n-   we should not add a conflict with the copy's destination operand.  */\n-static rtx ignore_reg_for_conflicts;\n-\n /* Free live range list LR.  */\n static void\n free_live_range_list (lra_live_range_t lr)\n@@ -224,6 +220,57 @@ lra_intersected_live_ranges_p (lra_live_range_t r1, lra_live_range_t r2)\n   return false;\n }\n \n+enum point_type {\n+  DEF_POINT,\n+  USE_POINT\n+};\n+\n+/* Return TRUE if set A contains a pseudo register, otherwise, return FALSE.  */\n+static bool\n+sparseset_contains_pseudos_p (sparseset a)\n+{\n+  int regno;\n+  EXECUTE_IF_SET_IN_SPARSESET (a, regno)\n+    if (!HARD_REGISTER_NUM_P (regno))\n+      return true;\n+  return false;\n+}\n+\n+/* Mark pseudo REGNO as living or dying at program point POINT, depending on\n+   whether TYPE is a definition or a use.  If this is the first reference to\n+   REGNO that we've encountered, then create a new live range for it.  */\n+\n+static void\n+update_pseudo_point (int regno, int point, enum point_type type)\n+{\n+  lra_live_range_t p;\n+\n+  /* Don't compute points for hard registers.  */\n+  if (HARD_REGISTER_NUM_P (regno))\n+    return;\n+\n+  if (complete_info_p || lra_get_regno_hard_regno (regno) < 0)\n+    {\n+      if (type == DEF_POINT)\n+\t{\n+\t  if (sparseset_bit_p (pseudos_live, regno))\n+\t    {\n+\t      p = lra_reg_info[regno].live_ranges;\n+\t      lra_assert (p != NULL);\n+\t      p->finish = point;\n+\t    }\n+\t}\n+      else /* USE_POINT */\n+\t{\n+\t  if (!sparseset_bit_p (pseudos_live, regno)\n+\t      && ((p = lra_reg_info[regno].live_ranges) == NULL\n+\t\t  || (p->finish != point && p->finish + 1 != point)))\n+\t    lra_reg_info[regno].live_ranges\n+\t      = create_live_range (regno, point, -1, p);\n+\t}\n+    }\n+}\n+\n /* The corresponding bitmaps of BB currently being processed.  */\n static bitmap bb_killed_pseudos, bb_gen_pseudos;\n \n@@ -232,7 +279,7 @@ static bitmap bb_killed_pseudos, bb_gen_pseudos;\n static void\n make_hard_regno_live (int regno)\n {\n-  lra_assert (regno < FIRST_PSEUDO_REGISTER);\n+  lra_assert (HARD_REGISTER_NUM_P (regno));\n   if (TEST_HARD_REG_BIT (hard_regs_live, regno))\n     return;\n   SET_HARD_REG_BIT (hard_regs_live, regno);\n@@ -247,150 +294,85 @@ make_hard_regno_live (int regno)\n static void\n make_hard_regno_dead (int regno)\n {\n-  lra_assert (regno < FIRST_PSEUDO_REGISTER);\n-  if (! TEST_HARD_REG_BIT (hard_regs_live, regno))\n-    return;\n-  sparseset_set_bit (start_dying, regno);\n+  lra_assert (HARD_REGISTER_NUM_P (regno));\n   unsigned int i;\n   EXECUTE_IF_SET_IN_SPARSESET (pseudos_live, i)\n-    {\n-      if (ignore_reg_for_conflicts != NULL_RTX\n-\t  && REGNO (ignore_reg_for_conflicts) == i)\n-\tcontinue;\n-      SET_HARD_REG_BIT (lra_reg_info[i].conflict_hard_regs, regno);\n-    }\n+    SET_HARD_REG_BIT (lra_reg_info[i].conflict_hard_regs, regno);\n+\n+  if (! TEST_HARD_REG_BIT (hard_regs_live, regno))\n+    return;\n   CLEAR_HARD_REG_BIT (hard_regs_live, regno);\n+  sparseset_set_bit (start_dying, regno);\n   if (fixed_regs[regno] || TEST_HARD_REG_BIT (hard_regs_spilled_into, regno))\n     {\n       bitmap_clear_bit (bb_gen_pseudos, regno);\n       bitmap_set_bit (bb_killed_pseudos, regno);\n     }\n }\n \n-/* Mark pseudo REGNO as living at program point POINT, update START_LIVING\n-   and start a new live range for the pseudo corresponding to REGNO if it\n-   is necessary.  */\n+/* Mark pseudo REGNO as now being live and update START_LIVING.  */\n static void\n-mark_pseudo_live (int regno, int point)\n+mark_pseudo_live (int regno)\n {\n-  lra_live_range_t p;\n+  lra_assert (!HARD_REGISTER_NUM_P (regno));\n+  if (sparseset_bit_p (pseudos_live, regno))\n+    return;\n \n-  lra_assert (regno >= FIRST_PSEUDO_REGISTER);\n-  lra_assert (! sparseset_bit_p (pseudos_live, regno));\n   sparseset_set_bit (pseudos_live, regno);\n-\n-  if ((complete_info_p || lra_get_regno_hard_regno (regno) < 0)\n-      && ((p = lra_reg_info[regno].live_ranges) == NULL\n-\t  || (p->finish != point && p->finish + 1 != point)))\n-     lra_reg_info[regno].live_ranges\n-       = create_live_range (regno, point, -1, p);\n   sparseset_set_bit (start_living, regno);\n }\n \n-/* Mark pseudo REGNO as not living at program point POINT and update\n-   START_DYING.\n-   This finishes the current live range for the pseudo corresponding\n-   to REGNO.  */\n+/* Mark pseudo REGNO as now being dead and update START_DYING.  */\n static void\n-mark_pseudo_dead (int regno, int point)\n+mark_pseudo_dead (int regno)\n {\n-  lra_live_range_t p;\n-  int ignore_regno = -1;\n-  int end_regno = -1;\n+  lra_assert (!HARD_REGISTER_NUM_P (regno));\n+  IOR_HARD_REG_SET (lra_reg_info[regno].conflict_hard_regs, hard_regs_live);\n+  if (!sparseset_bit_p (pseudos_live, regno))\n+    return;\n \n-  lra_assert (regno >= FIRST_PSEUDO_REGISTER);\n-  lra_assert (sparseset_bit_p (pseudos_live, regno));\n   sparseset_clear_bit (pseudos_live, regno);\n   sparseset_set_bit (start_dying, regno);\n-\n-  /* Check whether any part of IGNORE_REG_FOR_CONFLICTS already conflicts\n-     with REGNO.  */\n-  if (ignore_reg_for_conflicts != NULL_RTX\n-      && REGNO (ignore_reg_for_conflicts) < FIRST_PSEUDO_REGISTER)\n-    {\n-      end_regno = END_REGNO (ignore_reg_for_conflicts);\n-      int src_regno = ignore_regno = REGNO (ignore_reg_for_conflicts);\n-\n-      while (src_regno < end_regno)\n-\t{\n-\t  if (TEST_HARD_REG_BIT (lra_reg_info[regno].conflict_hard_regs,\n-\t\t\t\t src_regno))\n-\t    {\n-\t      ignore_regno = end_regno = -1;\n-\t      break;\n-\t    }\n-\t  src_regno++;\n-\t}\n-    }\n-\n-  IOR_HARD_REG_SET (lra_reg_info[regno].conflict_hard_regs, hard_regs_live);\n-\n-  /* If IGNORE_REG_FOR_CONFLICTS did not already conflict with REGNO, make\n-     sure it still doesn't.  */\n-  for (; ignore_regno < end_regno; ignore_regno++)\n-    CLEAR_HARD_REG_BIT (lra_reg_info[regno].conflict_hard_regs, ignore_regno);\n-\n-  if (complete_info_p || lra_get_regno_hard_regno (regno) < 0)\n-    {\n-      p = lra_reg_info[regno].live_ranges;\n-      lra_assert (p != NULL);\n-      p->finish = point;\n-    }\n }\n \n-/* Mark register REGNO (pseudo or hard register) in MODE as live at\n-   program point POINT.  Update BB_GEN_PSEUDOS.\n-   Return TRUE if the liveness tracking sets were modified, or FALSE\n-   if nothing changed.  */\n-static bool\n-mark_regno_live (int regno, machine_mode mode, int point)\n+/* Mark register REGNO (pseudo or hard register) in MODE as being live\n+   and update BB_GEN_PSEUDOS.  */\n+static void\n+mark_regno_live (int regno, machine_mode mode)\n {\n   int last;\n-  bool changed = false;\n \n-  if (regno < FIRST_PSEUDO_REGISTER)\n+  if (HARD_REGISTER_NUM_P (regno))\n     {\n       for (last = end_hard_regno (mode, regno); regno < last; regno++)\n \tmake_hard_regno_live (regno);\n     }\n   else\n     {\n-      if (! sparseset_bit_p (pseudos_live, regno))\n-\t{\n-\t  mark_pseudo_live (regno, point);\n-\t  changed = true;\n-\t}\n+      mark_pseudo_live (regno);\n       bitmap_set_bit (bb_gen_pseudos, regno);\n     }\n-  return changed;\n }\n \n \n-/* Mark register REGNO in MODE as dead at program point POINT.  Update\n-   BB_GEN_PSEUDOS and BB_KILLED_PSEUDOS.  Return TRUE if the liveness\n-   tracking sets were modified, or FALSE if nothing changed.  */\n-static bool\n-mark_regno_dead (int regno, machine_mode mode, int point)\n+/* Mark register REGNO (pseudo or hard register) in MODE as being dead\n+   and update BB_GEN_PSEUDOS and BB_KILLED_PSEUDOS.  */\n+static void\n+mark_regno_dead (int regno, machine_mode mode)\n {\n   int last;\n-  bool changed = false;\n \n-  if (regno < FIRST_PSEUDO_REGISTER)\n+  if (HARD_REGISTER_NUM_P (regno))\n     {\n       for (last = end_hard_regno (mode, regno); regno < last; regno++)\n \tmake_hard_regno_dead (regno);\n     }\n   else\n     {\n-      if (sparseset_bit_p (pseudos_live, regno))\n-\t{\n-\t  mark_pseudo_dead (regno, point);\n-\t  changed = true;\n-\t}\n+      mark_pseudo_dead (regno);\n       bitmap_clear_bit (bb_gen_pseudos, regno);\n       bitmap_set_bit (bb_killed_pseudos, regno);\n     }\n-  return changed;\n }\n \n \f\n@@ -607,7 +589,7 @@ check_pseudos_live_through_calls (int regno,\n   IOR_HARD_REG_SET (lra_reg_info[regno].conflict_hard_regs,\n \t\t    last_call_used_reg_set);\n \n-  for (hr = 0; hr < FIRST_PSEUDO_REGISTER; hr++)\n+  for (hr = 0; HARD_REGISTER_NUM_P (hr); hr++)\n     if (targetm.hard_regno_call_part_clobbered (hr,\n \t\t\t\t\t\tPSEUDO_REGNO_MODE (regno)))\n       add_to_hard_reg_set (&lra_reg_info[regno].conflict_hard_regs,\n@@ -653,7 +635,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n   rtx link, *link_loc;\n   bool need_curr_point_incr;\n   HARD_REG_SET last_call_used_reg_set;\n-  \n+\n   reg_live_out = df_get_live_out (bb);\n   sparseset_clear (pseudos_live);\n   sparseset_clear (pseudos_live_through_calls);\n@@ -662,7 +644,10 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n   REG_SET_TO_HARD_REG_SET (hard_regs_live, reg_live_out);\n   AND_COMPL_HARD_REG_SET (hard_regs_live, eliminable_regset);\n   EXECUTE_IF_SET_IN_BITMAP (reg_live_out, FIRST_PSEUDO_REGISTER, j, bi)\n-    mark_pseudo_live (j, curr_point);\n+    {\n+      update_pseudo_point (j, curr_point, USE_POINT);\n+      mark_pseudo_live (j);\n+    }\n \n   bb_gen_pseudos = &get_bb_data (bb)->gen_pseudos;\n   bb_killed_pseudos = &get_bb_data (bb)->killed_pseudos;\n@@ -702,7 +687,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       set = single_set (curr_insn);\n \n       if (dead_insn_p && set != NULL_RTX\n-\t  && REG_P (SET_DEST (set)) && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n+\t  && REG_P (SET_DEST (set)) && !HARD_REGISTER_P (SET_DEST (set))\n \t  && find_reg_note (curr_insn, REG_EH_REGION, NULL_RTX) == NULL_RTX\n \t  && ! may_trap_p (PATTERN (curr_insn))\n \t  /* Don't do premature remove of pic offset pseudo as we can\n@@ -759,7 +744,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t  if (partial_subreg_p (lra_reg_info[regno].biggest_mode,\n \t\t\t\treg->biggest_mode))\n \t    lra_reg_info[regno].biggest_mode = reg->biggest_mode;\n-\t  if (regno < FIRST_PSEUDO_REGISTER)\n+\t  if (HARD_REGISTER_NUM_P (regno))\n \t    {\n \t      lra_hard_reg_usage[regno] += freq;\n \t      /* A hard register explicitly can be used in small mode,\n@@ -775,7 +760,26 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t}\n \n       call_p = CALL_P (curr_insn);\n-      ignore_reg_for_conflicts = non_conflicting_reg_copy_p (curr_insn);\n+\n+      /* If we have a simple register copy and the source reg is live after\n+\t this instruction, then remove the source reg from the live set so\n+\t that it will not conflict with the destination reg.  */\n+      rtx ignore_reg = non_conflicting_reg_copy_p (curr_insn);\n+      if (ignore_reg != NULL_RTX)\n+\t{\n+\t  int ignore_regno = REGNO (ignore_reg);\n+\t  if (HARD_REGISTER_NUM_P (ignore_regno)\n+\t      && TEST_HARD_REG_BIT (hard_regs_live, ignore_regno))\n+\t    CLEAR_HARD_REG_BIT (hard_regs_live, ignore_regno);\n+\t  else if (!HARD_REGISTER_NUM_P (ignore_regno)\n+\t\t   && sparseset_bit_p (pseudos_live, ignore_regno))\n+\t    sparseset_clear_bit (pseudos_live, ignore_regno);\n+\t  else\n+\t    /* We don't need any special handling of the source reg if\n+\t       it is dead after this instruction.  */\n+\t    ignore_reg = NULL_RTX;\n+\t}\n+\n       src_regno = (set != NULL_RTX && REG_P (SET_SRC (set))\n \t\t   ? REGNO (SET_SRC (set)) : -1);\n       dst_regno = (set != NULL_RTX && REG_P (SET_DEST (set))\n@@ -785,13 +789,13 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t  /* Check that source regno does not conflict with\n \t     destination regno to exclude most impossible\n \t     preferences.  */\n-\t  && (((src_regno >= FIRST_PSEUDO_REGISTER\n+\t  && (((!HARD_REGISTER_NUM_P (src_regno)\n \t\t&& (! sparseset_bit_p (pseudos_live, src_regno)\n-\t\t    || (dst_regno >= FIRST_PSEUDO_REGISTER\n+\t\t    || (!HARD_REGISTER_NUM_P (dst_regno)\n \t\t\t&& lra_reg_val_equal_p (src_regno,\n \t\t\t\t\t\tlra_reg_info[dst_regno].val,\n \t\t\t\t\t\tlra_reg_info[dst_regno].offset))))\n-\t       || (src_regno < FIRST_PSEUDO_REGISTER\n+\t       || (HARD_REGISTER_NUM_P (src_regno)\n \t\t   && ! TEST_HARD_REG_BIT (hard_regs_live, src_regno)))\n \t      /* It might be 'inheritance pseudo <- reload pseudo'.  */\n \t      || (src_regno >= lra_constraint_new_regno_start\n@@ -816,13 +820,13 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t    }\n \t  else if (dst_regno >= lra_constraint_new_regno_start)\n \t    {\n-\t      if ((hard_regno = src_regno) >= FIRST_PSEUDO_REGISTER)\n+\t      if (!HARD_REGISTER_NUM_P (hard_regno = src_regno))\n \t\thard_regno = reg_renumber[src_regno];\n \t      regno = dst_regno;\n \t    }\n \t  else if (src_regno >= lra_constraint_new_regno_start)\n \t    {\n-\t      if ((hard_regno = dst_regno) >= FIRST_PSEUDO_REGISTER)\n+\t      if (!HARD_REGISTER_NUM_P (hard_regno = dst_regno))\n \t\thard_regno = reg_renumber[dst_regno];\n \t      regno = src_regno;\n \t    }\n@@ -833,27 +837,20 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \n       sparseset_clear (start_living);\n \n-      /* Try to avoid unnecessary program point increments, this saves\n-\t a lot of time in remove_some_program_points_and_update_live_ranges.\n-\t We only need an increment if something becomes live or dies at this\n-\t program point.  */\n-      need_curr_point_incr = false;\n-\n       /* Mark each defined value as live.  We need to do this for\n \t unused values because they still conflict with quantities\n \t that are live at the time of the definition.  */\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n \t{\n \t  if (reg->type != OP_IN)\n \t    {\n-\t      need_curr_point_incr\n-\t\t|= mark_regno_live (reg->regno, reg->biggest_mode,\n-\t\t\t\t    curr_point);\n+\t      update_pseudo_point (reg->regno, curr_point, USE_POINT);\n+\t      mark_regno_live (reg->regno, reg->biggest_mode);\n \t      check_pseudos_live_through_calls (reg->regno,\n \t\t\t\t\t\tlast_call_used_reg_set);\n \t    }\n \n-\t  if (reg->regno >= FIRST_PSEUDO_REGISTER)\n+\t  if (!HARD_REGISTER_NUM_P (reg->regno))\n \t    for (hr = curr_static_id->hard_regs; hr != NULL; hr = hr->next)\n \t      if (hr->clobber_high\n \t\t  && maybe_gt (GET_MODE_SIZE (PSEUDO_REGNO_MODE (reg->regno)),\n@@ -868,7 +865,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \n       if (curr_id->arg_hard_regs != NULL)\n \tfor (i = 0; (regno = curr_id->arg_hard_regs[i]) >= 0; i++)\n-\t  if (regno >= FIRST_PSEUDO_REGISTER)\n+\t  if (!HARD_REGISTER_NUM_P (regno))\n \t    /* It is a clobber.  */\n \t    make_hard_regno_live (regno - FIRST_PSEUDO_REGISTER);\n \n@@ -878,20 +875,22 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \n       /* See which defined values die here.  */\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n-\tif (reg->type == OP_OUT\n+\tif (reg->type != OP_IN\n \t    && ! reg_early_clobber_p (reg, n_alt) && ! reg->subreg_p)\n-\t  need_curr_point_incr\n-\t    |= mark_regno_dead (reg->regno, reg->biggest_mode,\n-\t\t\t\tcurr_point);\n+\t  {\n+\t    if (reg->type == OP_OUT)\n+\t      update_pseudo_point (reg->regno, curr_point, DEF_POINT);\n+\t    mark_regno_dead (reg->regno, reg->biggest_mode);\n+\t  }\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n-\tif (reg->type == OP_OUT\n+\tif (reg->type != OP_IN\n \t    && ! reg_early_clobber_p (reg, n_alt) && ! reg->subreg_p)\n \t  make_hard_regno_dead (reg->regno);\n \n       if (curr_id->arg_hard_regs != NULL)\n \tfor (i = 0; (regno = curr_id->arg_hard_regs[i]) >= 0; i++)\n-\t  if (regno >= FIRST_PSEUDO_REGISTER)\n+\t  if (!HARD_REGISTER_NUM_P (regno))\n \t    /* It is a clobber.  */\n \t    make_hard_regno_dead (regno - FIRST_PSEUDO_REGISTER);\n \n@@ -931,50 +930,70 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t}\n \n       /* Increment the current program point if we must.  */\n-      if (need_curr_point_incr)\n+      if (sparseset_contains_pseudos_p (unused_set)\n+\t  || sparseset_contains_pseudos_p (start_dying))\n \tnext_program_point (curr_point, freq);\n \n-      sparseset_clear (start_living);\n+      /* If we removed the source reg from a simple register copy from the\n+\t live set above, then add it back now so we don't accidentally add\n+\t it to the start_living set below.  */\n+      if (ignore_reg != NULL_RTX)\n+\t{\n+\t  int ignore_regno = REGNO (ignore_reg);\n+\t  if (HARD_REGISTER_NUM_P (ignore_regno))\n+\t    SET_HARD_REG_BIT (hard_regs_live, ignore_regno);\n+\t  else\n+\t    sparseset_set_bit (pseudos_live, ignore_regno);\n+\t}\n \n-      need_curr_point_incr = false;\n+      sparseset_clear (start_living);\n \n       /* Mark each used value as live.\t*/\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n-\tif (reg->type == OP_IN)\n+\tif (reg->type != OP_OUT)\n \t  {\n-\t    need_curr_point_incr\n-\t      |= mark_regno_live (reg->regno, reg->biggest_mode,\n-\t\t\t\t  curr_point);\n+\t    if (reg->type == OP_IN)\n+\t      update_pseudo_point (reg->regno, curr_point, USE_POINT);\n+\t    mark_regno_live (reg->regno, reg->biggest_mode);\n \t    check_pseudos_live_through_calls (reg->regno,\n \t\t\t\t\t      last_call_used_reg_set);\n \t  }\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n-\tif (reg->type == OP_IN)\n+\tif (reg->type != OP_OUT)\n \t  make_hard_regno_live (reg->regno);\n \n       if (curr_id->arg_hard_regs != NULL)\n \t/* Make argument hard registers live.  */\n \tfor (i = 0; (regno = curr_id->arg_hard_regs[i]) >= 0; i++)\n-\t  if (regno < FIRST_PSEUDO_REGISTER)\n+\t  if (HARD_REGISTER_NUM_P (regno))\n \t    make_hard_regno_live (regno);\n \n       sparseset_and_compl (dead_set, start_living, start_dying);\n \n+      sparseset_clear (start_dying);\n+\n       /* Mark early clobber outputs dead.  */\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n-\tif (reg->type == OP_OUT\n+\tif (reg->type != OP_IN\n \t    && reg_early_clobber_p (reg, n_alt) && ! reg->subreg_p)\n-\t  need_curr_point_incr\n-\t    |= mark_regno_dead (reg->regno, reg->biggest_mode,\n-\t\t\t\tcurr_point);\n+\t  {\n+\t    if (reg->type == OP_OUT)\n+\t      update_pseudo_point (reg->regno, curr_point, DEF_POINT);\n+\t    mark_regno_dead (reg->regno, reg->biggest_mode);\n+\n+\t    /* We're done processing inputs, so make sure early clobber\n+\t       operands that are both inputs and outputs are still live.  */\n+\t    if (reg->type == OP_INOUT)\n+\t      mark_regno_live (reg->regno, reg->biggest_mode);\n+\t  }\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n-\tif (reg->type == OP_OUT\n+\tif (reg->type != OP_IN\n \t    && reg_early_clobber_p (reg, n_alt) && ! reg->subreg_p)\n \t  {\n \t    struct lra_insn_reg *reg2;\n-\t    \n+\n \t    /* We can have early clobbered non-operand hard reg and\n \t       the same hard reg as an insn input.  Don't make hard\n \t       reg dead before the insns.  */\n@@ -985,7 +1004,9 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t      make_hard_regno_dead (reg->regno);\n \t  }\n \n-      if (need_curr_point_incr)\n+      /* Increment the current program point if we must.  */\n+      if (sparseset_contains_pseudos_p (dead_set)\n+\t  || sparseset_contains_pseudos_p (start_dying))\n \tnext_program_point (curr_point, freq);\n \n       /* Update notes.\t*/\n@@ -1017,7 +1038,6 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       EXECUTE_IF_SET_IN_SPARSESET (unused_set, j)\n \tadd_reg_note (curr_insn, REG_UNUSED, regno_reg_rtx[j]);\n     }\n-  ignore_reg_for_conflicts = NULL_RTX;\n \n   if (bb_has_eh_pred (bb))\n     for (j = 0; ; ++j)\n@@ -1047,7 +1067,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t allocate such regs in this case.  */\n       if (!cfun->has_nonlocal_label\n \t  && has_abnormal_call_or_eh_pred_edge_p (bb))\n-\tfor (px = 0; px < FIRST_PSEUDO_REGISTER; px++)\n+\tfor (px = 0; HARD_REGISTER_NUM_P (px); px++)\n \t  if (call_used_regs[px]\n #ifdef REAL_PIC_OFFSET_TABLE_REGNUM\n \t      /* We should create a conflict of PIC pseudo with PIC\n@@ -1057,7 +1077,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t\t pseudo will also have a wrong value.  */\n \t      || (px == REAL_PIC_OFFSET_TABLE_REGNUM\n \t\t  && pic_offset_table_rtx != NULL_RTX\n-\t\t  && REGNO (pic_offset_table_rtx) >= FIRST_PSEUDO_REGISTER)\n+\t\t  && !HARD_REGISTER_P (pic_offset_table_rtx))\n #endif\n \t      )\n \t    make_hard_regno_live (px);\n@@ -1095,7 +1115,10 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n   need_curr_point_incr = (sparseset_cardinality (pseudos_live) > 0);\n \n   EXECUTE_IF_SET_IN_SPARSESET (pseudos_live, i)\n-    mark_pseudo_dead (i, curr_point);\n+    {\n+      update_pseudo_point (i, curr_point, DEF_POINT);\n+      mark_pseudo_dead (i);\n+    }\n \n   EXECUTE_IF_SET_IN_BITMAP (df_get_live_in (bb), FIRST_PSEUDO_REGISTER, j, bi)\n     {\n@@ -1105,7 +1128,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \tcheck_pseudos_live_through_calls (j, last_call_used_reg_set);\n     }\n \n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+  for (i = 0; HARD_REGISTER_NUM_P (i); ++i)\n     {\n       if (!TEST_HARD_REG_BIT (hard_regs_live, i))\n \tcontinue;\n@@ -1332,12 +1355,12 @@ lra_create_live_ranges_1 (bool all_p, bool dead_insn_p)\n \t conservative because of recent transformation.  Here in this\n \t file we recalculate it again as it costs practically\n \t nothing.  */\n-      if (i >= FIRST_PSEUDO_REGISTER && regno_reg_rtx[i] != NULL_RTX)\n+      if (!HARD_REGISTER_NUM_P (i) && regno_reg_rtx[i] != NULL_RTX)\n \tlra_reg_info[i].biggest_mode = GET_MODE (regno_reg_rtx[i]);\n       else\n \tlra_reg_info[i].biggest_mode = VOIDmode;\n       lra_reg_info[i].call_p = false;\n-      if (i >= FIRST_PSEUDO_REGISTER\n+      if (!HARD_REGISTER_NUM_P (i)\n \t  && lra_reg_info[i].nrefs != 0)\n \t{\n \t  if ((hard_regno = reg_renumber[i]) >= 0)\n@@ -1394,7 +1417,7 @@ lra_create_live_ranges_1 (bool all_p, bool dead_insn_p)\n \t}\n       /* As we did not change CFG since LRA start we can use\n \t DF-infrastructure solver to solve live data flow problem.  */\n-      for (int i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+      for (int i = 0; HARD_REGISTER_NUM_P (i); ++i)\n \t{\n \t  if (TEST_HARD_REG_BIT (hard_regs_spilled_into, i))\n \t    bitmap_clear_bit (&all_hard_regs_bitmap, i);"}]}