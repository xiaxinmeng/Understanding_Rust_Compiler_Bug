{"sha": "e448880c20c01a2925c7707838841c8c117c9e8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ0ODg4MGMyMGMwMWEyOTI1Yzc3MDc4Mzg4NDFjOGMxMTdjOWU4ZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-01-28T15:07:56Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-01-28T15:07:56Z"}, "message": "re PR c++/67407 (ice in friend_accessible_p)\n\n\tPR c++/67407\n\n\t* search.c (dfs_walk_once, dfs_walk_once_r)\n\t(dfs_walk_once_accessible_r, dfs_walk_once_accessible): Use\n\thash_set instead of BINFO_MARKED.\n\t(dfs_unmark_r): Remove.\n\nFrom-SVN: r232929", "tree": {"sha": "6303ccfc51dabcf6b066d2e7df91f654af5464d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6303ccfc51dabcf6b066d2e7df91f654af5464d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e448880c20c01a2925c7707838841c8c117c9e8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e448880c20c01a2925c7707838841c8c117c9e8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e448880c20c01a2925c7707838841c8c117c9e8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e448880c20c01a2925c7707838841c8c117c9e8d/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e2eb5056567bc3814ca236ee8cdb17e044a20392", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2eb5056567bc3814ca236ee8cdb17e044a20392", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2eb5056567bc3814ca236ee8cdb17e044a20392"}], "stats": {"total": 160, "additions": 78, "deletions": 82}, "files": [{"sha": "83a25f707789f8ce0442af50e91536d5cd0fdc21", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e448880c20c01a2925c7707838841c8c117c9e8d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e448880c20c01a2925c7707838841c8c117c9e8d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e448880c20c01a2925c7707838841c8c117c9e8d", "patch": "@@ -1,3 +1,11 @@\n+2016-01-28  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/67407\n+\t* search.c (dfs_walk_once, dfs_walk_once_r)\n+\t(dfs_walk_once_accessible_r, dfs_walk_once_accessible): Use\n+\thash_set instead of BINFO_MARKED.\n+\t(dfs_unmark_r): Remove.\n+\n 2016-01-28  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \tPR c++/24208"}, {"sha": "45d8a2432459b728bf74bade9d457241ca73eb53", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e448880c20c01a2925c7707838841c8c117c9e8d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e448880c20c01a2925c7707838841c8c117c9e8d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e448880c20c01a2925c7707838841c8c117c9e8d", "patch": "@@ -2608,9 +2608,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \t  /* There was no existing virtual thunk (which takes\n \t     precedence).  So find the binfo of the base function's\n \t     return type within the overriding function's return type.\n-\t     We cannot call lookup base here, because we're inside a\n-\t     dfs_walk, and will therefore clobber the BINFO_MARKED\n-\t     flags.  Fortunately we know the covariancy is valid (it\n+\t     Fortunately we know the covariancy is valid (it\n \t     has already been checked), so we can just iterate along\n \t     the binfos, which have been chained in inheritance graph\n \t     order.  Of course it is lame that we have to repeat the"}, {"sha": "792461189152ad68c40023ae4756d5c3403c7e3a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 18, "deletions": 79, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e448880c20c01a2925c7707838841c8c117c9e8d/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e448880c20c01a2925c7707838841c8c117c9e8d/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=e448880c20c01a2925c7707838841c8c117c9e8d", "patch": "@@ -34,20 +34,13 @@ static tree dfs_lookup_base (tree, void *);\n static tree dfs_dcast_hint_pre (tree, void *);\n static tree dfs_dcast_hint_post (tree, void *);\n static tree dfs_debug_mark (tree, void *);\n-static tree dfs_walk_once_r (tree, tree (*pre_fn) (tree, void *),\n-\t\t\t     tree (*post_fn) (tree, void *), void *data);\n-static void dfs_unmark_r (tree);\n static int check_hidden_convs (tree, int, int, tree, tree, tree);\n static tree split_conversions (tree, tree, tree, tree);\n static int lookup_conversions_r (tree, int, int,\n \t\t\t\t tree, tree, tree, tree, tree *, tree *);\n static int look_for_overrides_r (tree, tree);\n static tree lookup_field_r (tree, void *);\n static tree dfs_accessible_post (tree, void *);\n-static tree dfs_walk_once_accessible_r (tree, bool, bool,\n-\t\t\t\t\ttree (*pre_fn) (tree, void *),\n-\t\t\t\t\ttree (*post_fn) (tree, void *),\n-\t\t\t\t\tvoid *data);\n static tree dfs_walk_once_accessible (tree, bool,\n \t\t\t\t      tree (*pre_fn) (tree, void *),\n \t\t\t\t      tree (*post_fn) (tree, void *),\n@@ -1826,7 +1819,8 @@ dfs_walk_all (tree binfo, tree (*pre_fn) (tree, void *),\n \n static tree\n dfs_walk_once_r (tree binfo, tree (*pre_fn) (tree, void *),\n-\t\t tree (*post_fn) (tree, void *), void *data)\n+\t\t tree (*post_fn) (tree, void *), hash_set<tree> *pset,\n+\t\t void *data)\n {\n   tree rval;\n   unsigned ix;\n@@ -1849,13 +1843,10 @@ dfs_walk_once_r (tree binfo, tree (*pre_fn) (tree, void *),\n   for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n     {\n       if (BINFO_VIRTUAL_P (base_binfo))\n-\t{\n-\t  if (BINFO_MARKED (base_binfo))\n-\t    continue;\n-\t  BINFO_MARKED (base_binfo) = 1;\n-\t}\n+\tif (pset->add (base_binfo))\n+\t  continue;\n \n-      rval = dfs_walk_once_r (base_binfo, pre_fn, post_fn, data);\n+      rval = dfs_walk_once_r (base_binfo, pre_fn, post_fn, pset, data);\n       if (rval)\n \treturn rval;\n     }\n@@ -1872,30 +1863,6 @@ dfs_walk_once_r (tree binfo, tree (*pre_fn) (tree, void *),\n   return NULL_TREE;\n }\n \n-/* Worker for dfs_walk_once. Recursively unmark the virtual base binfos of\n-   BINFO.  */\n-\n-static void\n-dfs_unmark_r (tree binfo)\n-{\n-  unsigned ix;\n-  tree base_binfo;\n-\n-  /* Process the basetypes.  */\n-  for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n-    {\n-      if (BINFO_VIRTUAL_P (base_binfo))\n-\t{\n-\t  if (!BINFO_MARKED (base_binfo))\n-\t    continue;\n-\t  BINFO_MARKED (base_binfo) = 0;\n-\t}\n-      /* Only walk, if it can contain more virtual bases.  */\n-      if (CLASSTYPE_VBASECLASSES (BINFO_TYPE (base_binfo)))\n-\tdfs_unmark_r (base_binfo);\n-    }\n-}\n-\n /* Like dfs_walk_all, except that binfos are not multiply walked.  For\n    non-diamond shaped hierarchies this is the same as dfs_walk_all.\n    For diamond shaped hierarchies we must mark the virtual bases, to\n@@ -1918,22 +1885,8 @@ dfs_walk_once (tree binfo, tree (*pre_fn) (tree, void *),\n     rval = dfs_walk_all (binfo, pre_fn, post_fn, data);\n   else\n     {\n-      rval = dfs_walk_once_r (binfo, pre_fn, post_fn, data);\n-      if (!BINFO_INHERITANCE_CHAIN (binfo))\n-\t{\n-\t  /* We are at the top of the hierarchy, and can use the\n-\t     CLASSTYPE_VBASECLASSES list for unmarking the virtual\n-\t     bases.  */\n-\t  vec<tree, va_gc> *vbases;\n-\t  unsigned ix;\n-\t  tree base_binfo;\n-\n-\t  for (vbases = CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo)), ix = 0;\n-\t       vec_safe_iterate (vbases, ix, &base_binfo); ix++)\n-\t    BINFO_MARKED (base_binfo) = 0;\n-\t}\n-      else\n-\tdfs_unmark_r (binfo);\n+      hash_set<tree> pset;\n+      rval = dfs_walk_once_r (binfo, pre_fn, post_fn, &pset, data);\n     }\n \n   active--;\n@@ -1947,7 +1900,7 @@ dfs_walk_once (tree binfo, tree (*pre_fn) (tree, void *),\n    indicates whether bases should be marked during traversal.  */\n \n static tree\n-dfs_walk_once_accessible_r (tree binfo, bool friends_p, bool once,\n+dfs_walk_once_accessible_r (tree binfo, bool friends_p, hash_set<tree> *pset,\n \t\t\t    tree (*pre_fn) (tree, void *),\n \t\t\t    tree (*post_fn) (tree, void *), void *data)\n {\n@@ -1971,9 +1924,9 @@ dfs_walk_once_accessible_r (tree binfo, bool friends_p, bool once,\n   /* Find the next child binfo to walk.  */\n   for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n     {\n-      bool mark = once && BINFO_VIRTUAL_P (base_binfo);\n+      bool mark = pset && BINFO_VIRTUAL_P (base_binfo);\n \n-      if (mark && BINFO_MARKED (base_binfo))\n+      if (mark && pset->contains (base_binfo))\n \tcontinue;\n \n       /* If the base is inherited via private or protected\n@@ -1992,9 +1945,9 @@ dfs_walk_once_accessible_r (tree binfo, bool friends_p, bool once,\n \t}\n \n       if (mark)\n-\tBINFO_MARKED (base_binfo) = 1;\n+\tpset->add (base_binfo);\n \n-      rval = dfs_walk_once_accessible_r (base_binfo, friends_p, once,\n+      rval = dfs_walk_once_accessible_r (base_binfo, friends_p, pset,\n \t\t\t\t\t pre_fn, post_fn, data);\n       if (rval)\n \treturn rval;\n@@ -2021,28 +1974,14 @@ dfs_walk_once_accessible (tree binfo, bool friends_p,\n \t\t\t    tree (*pre_fn) (tree, void *),\n \t\t\t    tree (*post_fn) (tree, void *), void *data)\n {\n-  bool diamond_shaped = CLASSTYPE_DIAMOND_SHAPED_P (BINFO_TYPE (binfo));\n-  tree rval = dfs_walk_once_accessible_r (binfo, friends_p, diamond_shaped,\n+  hash_set<tree> *pset = NULL;\n+  if (CLASSTYPE_DIAMOND_SHAPED_P (BINFO_TYPE (binfo)))\n+    pset = new hash_set<tree>;\n+  tree rval = dfs_walk_once_accessible_r (binfo, friends_p, pset,\n \t\t\t\t\t  pre_fn, post_fn, data);\n \n-  if (diamond_shaped)\n-    {\n-      if (!BINFO_INHERITANCE_CHAIN (binfo))\n-\t{\n-\t  /* We are at the top of the hierarchy, and can use the\n-\t     CLASSTYPE_VBASECLASSES list for unmarking the virtual\n-\t     bases.  */\n-\t  vec<tree, va_gc> *vbases;\n-\t  unsigned ix;\n-\t  tree base_binfo;\n-\n-\t  for (vbases = CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo)), ix = 0;\n-\t       vec_safe_iterate (vbases, ix, &base_binfo); ix++)\n-\t    BINFO_MARKED (base_binfo) = 0;\n-\t}\n-      else\n-\tdfs_unmark_r (binfo);\n-    }\n+  if (pset)\n+    delete pset;\n   return rval;\n }\n "}, {"sha": "c71be53331f7a9f7f5cf7a2fb8ca6e1035824558", "filename": "gcc/testsuite/g++.dg/inherit/protected1.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e448880c20c01a2925c7707838841c8c117c9e8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fprotected1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e448880c20c01a2925c7707838841c8c117c9e8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fprotected1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fprotected1.C?ref=e448880c20c01a2925c7707838841c8c117c9e8d", "patch": "@@ -0,0 +1,51 @@\n+// PR c++/67407\n+\n+template <class> class A;\n+template <class> struct B;\n+template <class X> struct B<A<X> >\n+{\n+  static int\n+  check ()\n+  {\n+    A<X> a;\n+    a.m_class->m_object;\n+  }\n+};\n+template <class T> class A\n+{\n+public:\n+  template <class X> bool operator== (const X &) const;\n+  T *m_class;\n+};\n+template <class T>\n+template <class X>\n+bool\n+A<T>::operator== (const X &) const\n+{\n+  B<X>::check;\n+}\n+class C\n+{\n+protected:\n+  template <class> friend struct B;\n+  void *m_object;\n+};\n+class F : virtual C\n+{\n+};\n+class G : virtual public C\n+{\n+};\n+class H : F, public G\n+{\n+};\n+class D\n+{\n+  void onBusMessage (const A<int> &);\n+  A<H> m_pipeline;\n+};\n+void\n+D::onBusMessage (const A<int> &p1)\n+{\n+  p1 == m_pipeline;\n+}"}]}