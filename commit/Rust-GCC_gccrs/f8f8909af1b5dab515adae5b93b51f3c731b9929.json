{"sha": "f8f8909af1b5dab515adae5b93b51f3c731b9929", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhmODkwOWFmMWI1ZGFiNTE1YWRhZTViOTNiNTFmM2M3MzFiOTkyOQ==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.ibm.com", "date": "2020-11-17T16:38:20Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@linux.ibm.com", "date": "2020-11-21T13:42:03Z"}, "message": "Make MMA builtins use opaque modes\n\nThis patch changes powerpc MMA builtins to use the new opaque\nmode class and use modes OO (32 bytes) and XO (64 bytes)\ninstead of POI/PXI. Using the opaque modes prevents\noptimization from trying to do anything with vector\npair/quad, which was the problem we were seeing with the\npartial integer modes.\n\ngcc/\n\t* config/rs6000/mma.md (unspec): Add assemble/extract UNSPECs.\n\t(movoi): Change to movoo.\n\t(*movpoi): Change to *movoo.\n\t(movxi): Change to movxo.\n\t(*movpxi): Change to *movxo.\n\t(mma_assemble_pair): Change to OO mode.\n\t(*mma_assemble_pair): New define_insn_and_split.\n\t(mma_disassemble_pair): New define_expand.\n\t(*mma_disassemble_pair): New define_insn_and_split.\n\t(mma_assemble_acc): Change to XO mode.\n\t(*mma_assemble_acc): Change to XO mode.\n\t(mma_disassemble_acc): New define_expand.\n\t(*mma_disassemble_acc): New define_insn_and_split.\n\t(mma_<acc>): Change to XO mode.\n\t(mma_<vv>): Change to XO mode.\n\t(mma_<avv>): Change to XO mode.\n\t(mma_<pv>): Change to OO mode.\n\t(mma_<apv>): Change to XO/OO mode.\n\t(mma_<vvi4i4i8>): Change to XO mode.\n\t(mma_<avvi4i4i8>): Change to XO mode.\n\t(mma_<vvi4i4i2>): Change to XO mode.\n\t(mma_<avvi4i4i2>): Change to XO mode.\n\t(mma_<vvi4i4>): Change to XO mode.\n\t(mma_<avvi4i4>): Change to XO mode.\n\t(mma_<pvi4i2>): Change to XO/OO mode.\n\t(mma_<apvi4i2>): Change to XO/OO mode.\n\t(mma_<vvi4i4i4>): Change to XO mode.\n\t(mma_<avvi4i4i4>): Change to XO mode.\n\t* config/rs6000/predicates.md (input_operand): Allow opaque.\n\t(mma_disassemble_output_operand): New predicate.\n\t* config/rs6000/rs6000-builtin.def:\n\tChanges to disassemble builtins.\n\t* config/rs6000/rs6000-call.c (rs6000_return_in_memory):\n\tDisallow __vector_pair/__vector_quad as return types.\n\t(rs6000_promote_function_mode): Remove function return type\n\tcheck because we can't test it here any more.\n\t(rs6000_function_arg): Do not allow __vector_pair/__vector_quad\n\tas as function arguments.\n\t(rs6000_gimple_fold_mma_builtin):\n\tHandle mma_disassemble_* builtins.\n\t(rs6000_init_builtins): Create types for XO/OO modes.\n\t* config/rs6000/rs6000-modes.def: DElete OI, XI,\n\tPOI, and PXI modes, and create XO and OO modes.\n\t* config/rs6000/rs6000-string.c (expand_block_move):\n\tUpdate to OO mode.\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok_uncached):\n\tUpdate for XO/OO modes.\n\t(rs6000_rtx_costs): Make UNSPEC_MMA_XXSETACCZ cost 0.\n\t(rs6000_modes_tieable_p): Update for XO/OO modes.\n\t(rs6000_debug_reg_global): Update for XO/OO modes.\n\t(rs6000_setup_reg_addr_masks): Update for XO/OO modes.\n\t(rs6000_init_hard_regno_mode_ok): Update for XO/OO modes.\n\t(reg_offset_addressing_ok_p): Update for XO/OO modes.\n\t(rs6000_emit_move): Update for XO/OO modes.\n\t(rs6000_preferred_reload_class): Update for XO/OO modes.\n\t(rs6000_split_multireg_move): Update for XO/OO modes.\n\t(rs6000_mangle_type): Update for opaque types.\n\t(rs6000_invalid_conversion): Update for XO/OO modes.\n\t* config/rs6000/rs6000.h (VECTOR_ALIGNMENT_P):\n\tUpdate for XO/OO modes.\n\t* config/rs6000/rs6000.md (RELOAD): Update for XO/OO modes.\ngcc/testsuite/\n\t* gcc.target/powerpc/mma-double-test.c (main): Call abort for failure.\n\t* gcc.target/powerpc/mma-single-test.c (main): Call abort for failure.\n\t* gcc.target/powerpc/pr96506.c: Rename to pr96506-1.c.\n\t* gcc.target/powerpc/pr96506-2.c: New test.", "tree": {"sha": "6e004da0a2eb9387e2efa9377eb8bffea7f4562f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e004da0a2eb9387e2efa9377eb8bffea7f4562f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8f8909af1b5dab515adae5b93b51f3c731b9929", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8f8909af1b5dab515adae5b93b51f3c731b9929", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8f8909af1b5dab515adae5b93b51f3c731b9929", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8f8909af1b5dab515adae5b93b51f3c731b9929/comments", "author": {"login": "acsawdey", "id": 41373646, "node_id": "MDQ6VXNlcjQxMzczNjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/41373646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acsawdey", "html_url": "https://github.com/acsawdey", "followers_url": "https://api.github.com/users/acsawdey/followers", "following_url": "https://api.github.com/users/acsawdey/following{/other_user}", "gists_url": "https://api.github.com/users/acsawdey/gists{/gist_id}", "starred_url": "https://api.github.com/users/acsawdey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acsawdey/subscriptions", "organizations_url": "https://api.github.com/users/acsawdey/orgs", "repos_url": "https://api.github.com/users/acsawdey/repos", "events_url": "https://api.github.com/users/acsawdey/events{/privacy}", "received_events_url": "https://api.github.com/users/acsawdey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "acsawdey", "id": 41373646, "node_id": "MDQ6VXNlcjQxMzczNjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/41373646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acsawdey", "html_url": "https://github.com/acsawdey", "followers_url": "https://api.github.com/users/acsawdey/followers", "following_url": "https://api.github.com/users/acsawdey/following{/other_user}", "gists_url": "https://api.github.com/users/acsawdey/gists{/gist_id}", "starred_url": "https://api.github.com/users/acsawdey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acsawdey/subscriptions", "organizations_url": "https://api.github.com/users/acsawdey/orgs", "repos_url": "https://api.github.com/users/acsawdey/repos", "events_url": "https://api.github.com/users/acsawdey/events{/privacy}", "received_events_url": "https://api.github.com/users/acsawdey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e2d8575ace4e12dbe95ae2d4a49a4d89c6f67eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e2d8575ace4e12dbe95ae2d4a49a4d89c6f67eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e2d8575ace4e12dbe95ae2d4a49a4d89c6f67eb"}], "stats": {"total": 889, "additions": 517, "deletions": 372}, "files": [{"sha": "4d291c42f7a1e5be19a16030ccf1e8c317f1fa90", "filename": "gcc/config/rs6000/mma.md", "status": "modified", "additions": 245, "deletions": 176, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Fmma.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Fmma.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fmma.md?ref=f8f8909af1b5dab515adae5b93b51f3c731b9929", "patch": "@@ -19,24 +19,18 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n-;; The MMA patterns use the multi-register PXImode and POImode partial\n-;; integer modes to implement the target specific __vector_quad and\n-;; __vector_pair types that the MMA built-in functions reference.\n-;; To use these modes, we must define XImode and OImode move patterns\n-;; so the independent parts of the compiler can use our large partial\n-;; integer modes.  However, if we enable the XImode and OImode move\n-;; patterns, then the compiler will attempt to use them and this can\n-;; cause byte swapping issues on litte-endian systems.  We don't need\n-;; the XImode and OImode move patterns for actual code generation,\n-;; therefore, we define the XImode and OImode move patterns, but we\n-;; disable their use with a \"false\" condition flag.\n+;; The MMA patterns use the multi-register XOmode and OOmode opaque\n+;; modes to implement the target specific __vector_quad and\n+;; __vector_pair types that the MMA built-in functions reference.  We\n+;; use OPAQUE_MODE to prevent anything from trying to open them up.\n \n (define_constants [(MAX_MMA_OPERANDS 7)])\n \n ;; Constants for creating unspecs\n \n (define_c_enum \"unspec\"\n-  [UNSPEC_MMA_ASSEMBLE_ACC\n+  [UNSPEC_MMA_ASSEMBLE\n+   UNSPEC_MMA_EXTRACT\n    UNSPEC_MMA_PMXVBF16GER2\n    UNSPEC_MMA_PMXVBF16GER2NN\n    UNSPEC_MMA_PMXVBF16GER2NP\n@@ -97,6 +91,7 @@\n    UNSPEC_MMA_XVI8GER4SPP\n    UNSPEC_MMA_XXMFACC\n    UNSPEC_MMA_XXMTACC\n+   UNSPEC_MMA_XXSETACCZ\n   ])\n \n ;; MMA instructions with 1 accumulator argument\n@@ -265,31 +260,22 @@\n \t\t\t\t (UNSPEC_MMA_PMXVI8GER4SPP\t\"pmxvi8ger4spp\")])\n \n \n-;; Define a disabled OImode move pattern, so we can use POImode.\n-(define_expand \"movoi\"\n-  [(set (match_operand:OI 0 \"nonimmediate_operand\")\n-\t(match_operand:OI 1 \"input_operand\"))]\n-  \"0\"\n-{\n-  gcc_unreachable ();\n-})\n-\n-;; Vector pair support.  POImode can only live in VSRs.\n-(define_expand \"movpoi\"\n-  [(set (match_operand:POI 0 \"nonimmediate_operand\")\n-\t(match_operand:POI 1 \"input_operand\"))]\n+;; Vector pair support.  OOmode can only live in VSRs.\n+(define_expand \"movoo\"\n+  [(set (match_operand:OO 0 \"nonimmediate_operand\")\n+\t(match_operand:OO 1 \"input_operand\"))]\n   \"TARGET_MMA\"\n {\n-  rs6000_emit_move (operands[0], operands[1], POImode);\n+  rs6000_emit_move (operands[0], operands[1], OOmode);\n   DONE;\n })\n \n-(define_insn_and_split \"*movpoi\"\n-  [(set (match_operand:POI 0 \"nonimmediate_operand\" \"=wa,m,wa\")\n-\t(match_operand:POI 1 \"input_operand\" \"m,wa,wa\"))]\n+(define_insn_and_split \"*movoo\"\n+  [(set (match_operand:OO 0 \"nonimmediate_operand\" \"=wa,m,wa\")\n+\t(match_operand:OO 1 \"input_operand\" \"m,wa,wa\"))]\n   \"TARGET_MMA\n-   && (gpc_reg_operand (operands[0], POImode)\n-       || gpc_reg_operand (operands[1], POImode))\"\n+   && (gpc_reg_operand (operands[0], OOmode)\n+       || gpc_reg_operand (operands[1], OOmode))\"\n   \"@\n    lxvp%X1 %x0,%1\n    stxvp%X0 %x1,%0\n@@ -305,287 +291,370 @@\n    (set_attr \"length\" \"*,*,8\")])\n \n \f\n-;; Define a disabled XImode move pattern, so we can use PXImode.\n-(define_expand \"movxi\"\n-  [(set (match_operand:XI 0 \"nonimmediate_operand\")\n-\t(match_operand:XI 1 \"input_operand\"))]\n-  \"0\"\n-{\n-  gcc_unreachable ();\n-})\n-\n-;; Vector quad support.  PXImode can only live in FPRs.\n-(define_expand \"movpxi\"\n-  [(set (match_operand:PXI 0 \"nonimmediate_operand\")\n-\t(match_operand:PXI 1 \"input_operand\"))]\n+;; Vector quad support.  XOmode can only live in FPRs.\n+(define_expand \"movxo\"\n+  [(set (match_operand:XO 0 \"nonimmediate_operand\")\n+\t(match_operand:XO 1 \"input_operand\"))]\n   \"TARGET_MMA\"\n {\n-  rs6000_emit_move (operands[0], operands[1], PXImode);\n+  rs6000_emit_move (operands[0], operands[1], XOmode);\n   DONE;\n })\n \n-(define_insn_and_split \"*movpxi\"\n-  [(set (match_operand:PXI 0 \"nonimmediate_operand\" \"=d,m,d,d\")\n-\t(match_operand:PXI 1 \"input_operand\" \"m,d,d,O\"))]\n+(define_insn_and_split \"*movxo\"\n+  [(set (match_operand:XO 0 \"nonimmediate_operand\" \"=d,m,d\")\n+\t(match_operand:XO 1 \"input_operand\" \"m,d,d\"))]\n   \"TARGET_MMA\n-   && (gpc_reg_operand (operands[0], PXImode)\n-       || gpc_reg_operand (operands[1], PXImode))\"\n+   && (gpc_reg_operand (operands[0], XOmode)\n+       || gpc_reg_operand (operands[1], XOmode))\"\n   \"@\n    #\n    #\n-   #\n-   xxsetaccz %A0\"\n-  \"&& reload_completed\n-   && !(fpr_reg_operand (operands[0], PXImode) && operands[1] == const0_rtx)\"\n+   #\"\n+  \"&& reload_completed\"\n   [(const_int 0)]\n {\n   rs6000_split_multireg_move (operands[0], operands[1]);\n   DONE;\n }\n-  [(set_attr \"type\" \"vecload,vecstore,veclogical,mma\")\n-   (set_attr \"length\" \"8,8,16,*\")\n-   (set_attr \"max_prefixed_insns\" \"2,2,*,*\")])\n+  [(set_attr \"type\" \"vecload,vecstore,veclogical\")\n+   (set_attr \"length\" \"8,8,16\")\n+   (set_attr \"max_prefixed_insns\" \"2,2,*\")])\n \n (define_expand \"mma_assemble_pair\"\n-  [(match_operand:POI 0 \"vsx_register_operand\")\n-   (match_operand:V16QI 1 \"input_operand\")\n-   (match_operand:V16QI 2 \"input_operand\")]\n+  [(match_operand:OO 0 \"vsx_register_operand\")\n+   (match_operand:V16QI 1 \"mma_assemble_input_operand\")\n+   (match_operand:V16QI 2 \"mma_assemble_input_operand\")]\n   \"TARGET_MMA\"\n {\n-  rtx dst;\n+  rtx src = gen_rtx_UNSPEC (OOmode,\n+\t\t\t    gen_rtvec (2, operands[1], operands[2]),\n+\t\t\t    UNSPEC_MMA_ASSEMBLE);\n+  emit_move_insn (operands[0], src);\n+  DONE;\n+})\n \n-  /* Let the compiler know the code below fully defines our output value.  */\n-  emit_clobber (operands[0]);\n+(define_insn_and_split \"*mma_assemble_pair\"\n+  [(set (match_operand:OO 0 \"vsx_register_operand\" \"=wa\")\n+\t(unspec:OO [(match_operand:V16QI 1 \"mma_assemble_input_operand\" \"mwa\")\n+\t\t    (match_operand:V16QI 2 \"mma_assemble_input_operand\" \"mwa\")]\n+\t\t    UNSPEC_MMA_ASSEMBLE))]\n+  \"TARGET_MMA\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx src = gen_rtx_UNSPEC (OOmode,\n+\t\t\t    gen_rtvec (2, operands[1], operands[2]),\n+\t\t\t    UNSPEC_MMA_ASSEMBLE);\n+  rs6000_split_multireg_move (operands[0], src);\n+  DONE;\n+})\n+\n+(define_expand \"mma_disassemble_pair\"\n+  [(match_operand:V16QI 0 \"mma_disassemble_output_operand\")\n+   (match_operand:OO 1 \"vsx_register_operand\")\n+   (match_operand 2 \"const_0_to_1_operand\")]\n+  \"TARGET_MMA\"\n+{\n+  rtx src;\n+  int regoff = INTVAL (operands[2]);\n+  src = gen_rtx_UNSPEC (V16QImode,\n+\t\t\tgen_rtvec (2, operands[1], GEN_INT (regoff)),\n+\t\t\tUNSPEC_MMA_EXTRACT);\n+  emit_move_insn (operands[0], src);\n+  DONE;\n+})\n \n-  dst = simplify_gen_subreg (V16QImode, operands[0], POImode, 0);\n-  emit_move_insn (dst, operands[1]);\n-  dst = simplify_gen_subreg (V16QImode, operands[0], POImode, 16);\n-  emit_move_insn (dst, operands[2]);\n+(define_insn_and_split \"*mma_disassemble_pair\"\n+  [(set (match_operand:V16QI 0 \"mma_disassemble_output_operand\" \"=mwa\")\n+       (unspec:V16QI [(match_operand:OO 1 \"vsx_register_operand\" \"wa\")\n+\t\t      (match_operand 2 \"const_0_to_1_operand\")]\n+\t\t      UNSPEC_MMA_EXTRACT))]\n+  \"TARGET_MMA\n+   && vsx_register_operand (operands[1], OOmode)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  int reg = REGNO (operands[1]);\n+  int regoff = INTVAL (operands[2]);\n+  rtx src = gen_rtx_REG (V16QImode, reg + regoff);\n+  emit_move_insn (operands[0], src);\n   DONE;\n })\n \n (define_expand \"mma_assemble_acc\"\n-  [(match_operand:PXI 0 \"fpr_reg_operand\")\n-   (match_operand:V16QI 1 \"input_operand\")\n-   (match_operand:V16QI 2 \"input_operand\")\n-   (match_operand:V16QI 3 \"input_operand\")\n-   (match_operand:V16QI 4 \"input_operand\")]\n+  [(match_operand:XO 0 \"fpr_reg_operand\")\n+   (match_operand:V16QI 1 \"mma_assemble_input_operand\")\n+   (match_operand:V16QI 2 \"mma_assemble_input_operand\")\n+   (match_operand:V16QI 3 \"mma_assemble_input_operand\")\n+   (match_operand:V16QI 4 \"mma_assemble_input_operand\")]\n   \"TARGET_MMA\"\n {\n-  rtx src = gen_rtx_UNSPEC (PXImode,\n+  rtx src = gen_rtx_UNSPEC (XOmode,\n \t\t\t    gen_rtvec (4, operands[1], operands[2],\n \t\t\t\t       operands[3], operands[4]),\n-\t\t\t    UNSPEC_MMA_ASSEMBLE_ACC);\n+\t\t\t    UNSPEC_MMA_ASSEMBLE);\n   emit_move_insn (operands[0], src);\n   DONE;\n })\n \n (define_insn_and_split \"*mma_assemble_acc\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=d\")\n-\t(unspec:PXI [(match_operand:V16QI 1 \"mma_assemble_input_operand\" \"mwa\")\n-\t\t     (match_operand:V16QI 2 \"mma_assemble_input_operand\" \"mwa\")\n-\t\t     (match_operand:V16QI 3 \"mma_assemble_input_operand\" \"mwa\")\n-\t\t     (match_operand:V16QI 4 \"mma_assemble_input_operand\" \"mwa\")]\n-\t\t     UNSPEC_MMA_ASSEMBLE_ACC))]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=d\")\n+\t(unspec:XO [(match_operand:V16QI 1 \"mma_assemble_input_operand\" \"mwa\")\n+\t\t    (match_operand:V16QI 2 \"mma_assemble_input_operand\" \"mwa\")\n+\t\t    (match_operand:V16QI 3 \"mma_assemble_input_operand\" \"mwa\")\n+\t\t    (match_operand:V16QI 4 \"mma_assemble_input_operand\" \"mwa\")]\n+\t\t    UNSPEC_MMA_ASSEMBLE))]\n   \"TARGET_MMA\n-   && fpr_reg_operand (operands[0], PXImode)\"\n+   && fpr_reg_operand (operands[0], XOmode)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n-  rtx src = gen_rtx_UNSPEC (PXImode,\n+  rtx src = gen_rtx_UNSPEC (XOmode,\n \t\t\t    gen_rtvec (4, operands[1], operands[2],\n \t\t\t\t       operands[3], operands[4]),\n-\t\t\t    UNSPEC_MMA_ASSEMBLE_ACC);\n+\t\t\t    UNSPEC_MMA_ASSEMBLE);\n   rs6000_split_multireg_move (operands[0], src);\n   DONE;\n })\n \n+(define_expand \"mma_disassemble_acc\"\n+  [(match_operand:V16QI 0 \"mma_disassemble_output_operand\")\n+   (match_operand:XO 1 \"fpr_reg_operand\")\n+   (match_operand 2 \"const_0_to_3_operand\")]\n+  \"TARGET_MMA\"\n+{\n+  rtx src;\n+  int regoff = INTVAL (operands[2]);\n+  src = gen_rtx_UNSPEC (V16QImode,\n+\t\t\tgen_rtvec (2, operands[1], GEN_INT (regoff)),\n+\t\t\tUNSPEC_MMA_EXTRACT);\n+  emit_move_insn (operands[0], src);\n+  DONE;\n+})\n+\n+(define_insn_and_split \"*mma_disassemble_acc\"\n+  [(set (match_operand:V16QI 0 \"mma_disassemble_output_operand\" \"=mwa\")\n+       (unspec:V16QI [(match_operand:XO 1 \"fpr_reg_operand\" \"d\")\n+\t\t      (match_operand 2 \"const_0_to_3_operand\")]\n+\t\t      UNSPEC_MMA_EXTRACT))]\n+  \"TARGET_MMA\n+   && fpr_reg_operand (operands[1], XOmode)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  int reg = REGNO (operands[1]);\n+  int regoff = INTVAL (operands[2]);\n+  rtx src = gen_rtx_REG (V16QImode, reg + regoff);\n+  emit_move_insn (operands[0], src);\n+  DONE;\n+})\n+\n ;; MMA instructions that do not use their accumulators as an input, still\n ;; must not allow their vector operands to overlap the registers used by\n ;; the accumulator.  We enforce this by marking the output as early clobber.\n \n (define_insn \"mma_<acc>\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n-\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:XO [(match_operand:XO 1 \"fpr_reg_operand\" \"0\")]\n \t\t    MMA_ACC))]\n   \"TARGET_MMA\"\n   \"<acc> %A0\"\n   [(set_attr \"type\" \"mma\")])\n \n+;; We can't have integer constants in XOmode so we wrap this in an UNSPEC.\n+\n (define_expand \"mma_xxsetaccz\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\")\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\")\n \t(const_int 0))]\n   \"TARGET_MMA\"\n {\n-  emit_insn (gen_movpxi (operands[0], const0_rtx));\n+  rtx xo0 = gen_rtx_UNSPEC (XOmode, gen_rtvec (1, const0_rtx),\n+\t\t\t    UNSPEC_MMA_XXSETACCZ);\n+  emit_insn (gen_rtx_SET (operands[0], xo0));\n   DONE;\n })\n \n+(define_insn_and_split \"*mma_xxsetaccz\"\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=d\")\n+\t(unspec:XO [(match_operand 1 \"const_0_to_1_operand\" \"O\")]\n+\t UNSPEC_MMA_XXSETACCZ))]\n+  \"TARGET_MMA\"\n+  \"xxsetaccz %A0\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (unspec:XO [(match_dup 1)] UNSPEC_MMA_XXSETACCZ))]\n+  \"\"\n+  [(set_attr \"type\" \"mma\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"mma_<vv>\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n-\t(unspec:PXI [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")]\n-\t\t     MMA_VV))]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:XO [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")]\n+\t\t    MMA_VV))]\n   \"TARGET_MMA\"\n   \"<vv> %A0,%x1,%x2\"\n   [(set_attr \"type\" \"mma\")])\n \n (define_insn \"mma_<avv>\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n-\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")\n-\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")]\n-\t\t     MMA_AVV))]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:XO [(match_operand:XO 1 \"fpr_reg_operand\" \"0\")\n+\t\t    (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")]\n+\t\t    MMA_AVV))]\n   \"TARGET_MMA\"\n   \"<avv> %A0,%x2,%x3\"\n   [(set_attr \"type\" \"mma\")])\n \n (define_insn \"mma_<pv>\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n-\t(unspec:PXI [(match_operand:POI 1 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")]\n-\t\t     MMA_PV))]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:XO [(match_operand:OO 1 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")]\n+\t\t    MMA_PV))]\n   \"TARGET_MMA\"\n   \"<pv> %A0,%x1,%x2\"\n   [(set_attr \"type\" \"mma\")])\n \n (define_insn \"mma_<apv>\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n-\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")\n-\t\t     (match_operand:POI 2 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")]\n-\t\t     MMA_APV))]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:XO [(match_operand:XO 1 \"fpr_reg_operand\" \"0\")\n+\t\t    (match_operand:OO 2 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")]\n+\t\t    MMA_APV))]\n   \"TARGET_MMA\"\n   \"<apv> %A0,%x2,%x3\"\n   [(set_attr \"type\" \"mma\")])\n \n (define_insn \"mma_<vvi4i4i8>\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n-\t(unspec:PXI [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:SI 3 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 5 \"u8bit_cint_operand\" \"n\")]\n-\t\t     MMA_VVI4I4I8))]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:XO [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:SI 3 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 5 \"u8bit_cint_operand\" \"n\")]\n+\t\t    MMA_VVI4I4I8))]\n   \"TARGET_MMA\"\n   \"<vvi4i4i8> %A0,%x1,%x2,%3,%4,%5\"\n   [(set_attr \"type\" \"mma\")\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"mma_<avvi4i4i8>\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n-\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")\n-\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 5 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 6 \"u8bit_cint_operand\" \"n\")]\n-\t\t     MMA_AVVI4I4I8))]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:XO [(match_operand:XO 1 \"fpr_reg_operand\" \"0\")\n+\t\t    (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 5 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 6 \"u8bit_cint_operand\" \"n\")]\n+\t\t    MMA_AVVI4I4I8))]\n   \"TARGET_MMA\"\n   \"<avvi4i4i8> %A0,%x2,%x3,%4,%5,%6\"\n   [(set_attr \"type\" \"mma\")\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"mma_<vvi4i4i2>\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n-\t(unspec:PXI [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:SI 3 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 5 \"const_0_to_3_operand\" \"n\")]\n-\t\t     MMA_VVI4I4I2))]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:XO [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:SI 3 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 5 \"const_0_to_3_operand\" \"n\")]\n+\t\t    MMA_VVI4I4I2))]\n   \"TARGET_MMA\"\n   \"<vvi4i4i2> %A0,%x1,%x2,%3,%4,%5\"\n   [(set_attr \"type\" \"mma\")\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"mma_<avvi4i4i2>\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n-\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")\n-\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 5 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 6 \"const_0_to_3_operand\" \"n\")]\n-\t\t     MMA_AVVI4I4I2))]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:XO [(match_operand:XO 1 \"fpr_reg_operand\" \"0\")\n+\t\t    (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 5 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 6 \"const_0_to_3_operand\" \"n\")]\n+\t\t    MMA_AVVI4I4I2))]\n   \"TARGET_MMA\"\n   \"<avvi4i4i2> %A0,%x2,%x3,%4,%5,%6\"\n   [(set_attr \"type\" \"mma\")\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"mma_<vvi4i4>\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n-\t(unspec:PXI [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:SI 3 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")]\n-\t\t     MMA_VVI4I4))]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:XO [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:SI 3 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")]\n+\t\t    MMA_VVI4I4))]\n   \"TARGET_MMA\"\n   \"<vvi4i4> %A0,%x1,%x2,%3,%4\"\n   [(set_attr \"type\" \"mma\")\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"mma_<avvi4i4>\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n-\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")\n-\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 5 \"const_0_to_15_operand\" \"n\")]\n-\t\t     MMA_AVVI4I4))]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:XO [(match_operand:XO 1 \"fpr_reg_operand\" \"0\")\n+\t\t    (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 5 \"const_0_to_15_operand\" \"n\")]\n+\t\t    MMA_AVVI4I4))]\n   \"TARGET_MMA\"\n   \"<avvi4i4> %A0,%x2,%x3,%4,%5\"\n   [(set_attr \"type\" \"mma\")\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"mma_<pvi4i2>\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n-\t(unspec:PXI [(match_operand:POI 1 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:SI 3 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 4 \"const_0_to_3_operand\" \"n\")]\n-\t\t     MMA_PVI4I2))]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:XO [(match_operand:OO 1 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:SI 3 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 4 \"const_0_to_3_operand\" \"n\")]\n+\t\t    MMA_PVI4I2))]\n   \"TARGET_MMA\"\n   \"<pvi4i2> %A0,%x1,%x2,%3,%4\"\n   [(set_attr \"type\" \"mma\")\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"mma_<apvi4i2>\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n-\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")\n-\t\t     (match_operand:POI 2 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 5 \"const_0_to_3_operand\" \"n\")]\n-\t\t     MMA_APVI4I2))]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:XO [(match_operand:XO 1 \"fpr_reg_operand\" \"0\")\n+\t\t    (match_operand:OO 2 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 5 \"const_0_to_3_operand\" \"n\")]\n+\t\t    MMA_APVI4I2))]\n   \"TARGET_MMA\"\n   \"<apvi4i2> %A0,%x2,%x3,%4,%5\"\n   [(set_attr \"type\" \"mma\")\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"mma_<vvi4i4i4>\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n-\t(unspec:PXI [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:SI 3 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 5 \"const_0_to_15_operand\" \"n\")]\n-\t\t     MMA_VVI4I4I4))]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:XO [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:SI 3 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 5 \"const_0_to_15_operand\" \"n\")]\n+\t\t    MMA_VVI4I4I4))]\n   \"TARGET_MMA\"\n   \"<vvi4i4i4> %A0,%x1,%x2,%3,%4,%5\"\n   [(set_attr \"type\" \"mma\")\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"mma_<avvi4i4i4>\"\n-  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n-\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")\n-\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")\n-\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 5 \"const_0_to_15_operand\" \"n\")\n-\t\t     (match_operand:SI 6 \"const_0_to_15_operand\" \"n\")]\n-\t\t     MMA_AVVI4I4I4))]\n+  [(set (match_operand:XO 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:XO [(match_operand:XO 1 \"fpr_reg_operand\" \"0\")\n+\t\t    (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")\n+\t\t    (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 5 \"const_0_to_15_operand\" \"n\")\n+\t\t    (match_operand:SI 6 \"const_0_to_15_operand\" \"n\")]\n+\t\t    MMA_AVVI4I4I4))]\n   \"TARGET_MMA\"\n   \"<avvi4i4i4> %A0,%x2,%x3,%4,%5,%6\"\n   [(set_attr \"type\" \"mma\")"}, {"sha": "9ad5ae673029529d20c66ef9c340fac5dd2090b5", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=f8f8909af1b5dab515adae5b93b51f3c731b9929", "patch": "@@ -1144,6 +1144,18 @@\n   (match_test \"(mode == V16QImode\n \t\t&& (vsx_register_operand (op, mode) || MEM_P (op)))\"))\n \n+;; Return 1 if this operand is valid for an MMA disassemble insn.\n+(define_predicate \"mma_disassemble_output_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  if (SUBREG_P (op))\n+    op = SUBREG_REG (op);\n+  if (!REG_P (op))\n+    return true;\n+\n+  return vsx_register_operand (op, mode);\n+})\n+\n ;; Return true if operand is an operator used in rotate-and-mask instructions.\n (define_predicate \"rotate_mask_operator\"\n   (match_code \"rotate,ashift,lshiftrt\"))"}, {"sha": "47b1f74e616db5d54fd62a34cfd115ec948abefe", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=f8f8909af1b5dab515adae5b93b51f3c731b9929", "patch": "@@ -352,15 +352,21 @@\n \t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n \t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n \n-#define BU_MMA_V2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+#define BU_MMA_2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n   RS6000_BUILTIN_M (MMA_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n \t\t    \"__builtin_mma_\" NAME,\t\t/* NAME */\t\\\n \t\t    RS6000_BTM_MMA,\t\t\t/* MASK */\t\\\n \t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n \t\t     | RS6000_BTC_BINARY\t\t\t\t\\\n \t\t     | RS6000_BTC_VOID\t\t\t\t\t\\\n \t\t     | RS6000_BTC_GIMPLE),\t\t\t\t\\\n-\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n+\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\t\\\n+  RS6000_BUILTIN_M (MMA_BUILTIN_ ## ENUM ## _INTERNAL,\t/* ENUM */\t\\\n+\t\t    \"__builtin_mma_\" NAME \"_internal\",\t/* NAME */\t\\\n+\t\t    RS6000_BTM_MMA,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n \n #define BU_MMA_3(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n   RS6000_BUILTIN_M (MMA_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n@@ -3108,8 +3114,8 @@ BU_MMA_1 (XXMFACC,\t    \"xxmfacc\",\t\tQUAD, mma_xxmfacc)\n BU_MMA_1 (XXMTACC,\t    \"xxmtacc\",\t\tQUAD, mma_xxmtacc)\n BU_MMA_1 (XXSETACCZ,\t    \"xxsetaccz\",\tMISC, mma_xxsetaccz)\n \n-BU_MMA_V2 (DISASSEMBLE_ACC, \"disassemble_acc\",  QUAD, nothing)\n-BU_MMA_V2 (DISASSEMBLE_PAIR,\"disassemble_pair\", PAIR, nothing)\n+BU_MMA_2 (DISASSEMBLE_ACC, \"disassemble_acc\",\tQUAD, mma_disassemble_acc)\n+BU_MMA_2 (DISASSEMBLE_PAIR,\"disassemble_pair\",\tPAIR, mma_disassemble_pair)\n \n BU_MMA_3 (ASSEMBLE_PAIR,    \"assemble_pair\",\tMISC, mma_assemble_pair)\n BU_MMA_3 (XVBF16GER2,\t    \"xvbf16ger2\",\tMISC, mma_xvbf16ger2)"}, {"sha": "1572671067a10c02efff7cd38500780891a5ea83", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 85, "deletions": 75, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=f8f8909af1b5dab515adae5b93b51f3c731b9929", "patch": "@@ -6325,6 +6325,22 @@ rs6000_discover_homogeneous_aggregate (machine_mode mode, const_tree type,\n bool\n rs6000_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n {\n+  /* We do not allow MMA types being used as return values.  Only report\n+     the invalid return value usage the first time we encounter it.  */\n+  if (cfun\n+      && !cfun->machine->mma_return_type_error\n+      && TREE_TYPE (cfun->decl) == fntype\n+      && (TYPE_MODE (type) == OOmode || TYPE_MODE (type) == XOmode))\n+    {\n+      /* Record we have now handled function CFUN, so the next time we\n+\t are called, we do not re-report the same error.  */\n+      cfun->machine->mma_return_type_error = true;\n+      if (TYPE_CANONICAL (type) != NULL_TREE)\n+\ttype = TYPE_CANONICAL (type);\n+      error (\"invalid use of MMA type %qs as a function return value\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n+    }\n+\n   /* For the Darwin64 ABI, test if we can fit the return value in regs.  */\n   if (TARGET_MACHO\n       && rs6000_darwin64_abi\n@@ -6577,30 +6593,8 @@ machine_mode\n rs6000_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n \t\t\t      machine_mode mode,\n \t\t\t      int *punsignedp ATTRIBUTE_UNUSED,\n-\t\t\t      const_tree, int for_return)\n+\t\t\t      const_tree, int for_return ATTRIBUTE_UNUSED)\n {\n-  /* Warning: this is a static local variable and not always NULL!\n-     This function is called multiple times for the same function\n-     and return value.  PREV_FUNC is used to keep track of the\n-     first time we encounter a function's return value in order\n-     to not report an error with that return value multiple times.  */\n-  static struct function *prev_func = NULL;\n-\n-  /* We do not allow MMA types being used as return values.  Only report\n-     the invalid return value usage the first time we encounter it.  */\n-  if (for_return\n-      && prev_func != cfun\n-      && (mode == POImode || mode == PXImode))\n-    {\n-      /* Record we have now handled function CFUN, so the next time we\n-\t are called, we do not re-report the same error.  */\n-      prev_func = cfun;\n-      if (TYPE_CANONICAL (type) != NULL_TREE)\n-\ttype = TYPE_CANONICAL (type);\n-      error (\"invalid use of MMA type %qs as a function return value\",\n-\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n-    }\n-\n   PROMOTE_MODE (mode, *punsignedp, type);\n \n   return mode;\n@@ -7552,7 +7546,7 @@ rs6000_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n   int n_elts;\n \n   /* We do not allow MMA types being used as function arguments.  */\n-  if (mode == POImode || mode == PXImode)\n+  if (mode == OOmode || mode == XOmode)\n     {\n       if (TYPE_CANONICAL (type) != NULL_TREE)\n \ttype = TYPE_CANONICAL (type);\n@@ -10073,7 +10067,8 @@ mma_expand_builtin (tree exp, rtx target, bool *expandedp)\n     }\n \n   unsigned attr_args = attr & RS6000_BTC_OPND_MASK;\n-  if (attr & RS6000_BTC_QUAD)\n+  if (attr & RS6000_BTC_QUAD\n+      || fcode == MMA_BUILTIN_DISASSEMBLE_PAIR_INTERNAL)\n     attr_args++;\n \n   gcc_assert (nopnds == attr_args);\n@@ -11687,23 +11682,24 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi)\n   gimple *new_call;\n   tree new_decl;\n \n-  if (rs6000_builtin_info[fncode + 1].icode == CODE_FOR_nothing)\n+  if (fncode == MMA_BUILTIN_DISASSEMBLE_ACC\n+      || fncode == MMA_BUILTIN_DISASSEMBLE_PAIR)\n     {\n       /* This is an MMA disassemble built-in function.  */\n-      gcc_assert (fncode == MMA_BUILTIN_DISASSEMBLE_ACC\n-\t\t  || fncode == MMA_BUILTIN_DISASSEMBLE_PAIR);\n-\n       push_gimplify_context (true);\n+      unsigned nvec = (fncode == MMA_BUILTIN_DISASSEMBLE_ACC) ? 4 : 2;\n       tree dst_ptr = gimple_call_arg (stmt, 0);\n       tree src_ptr = gimple_call_arg (stmt, 1);\n       tree src_type = TREE_TYPE (src_ptr);\n       tree src = make_ssa_name (TREE_TYPE (src_type));\n       gimplify_assign (src, build_simple_mem_ref (src_ptr), &new_seq);\n \n-      /* If we are not disassembling an accumulator or our destination is\n-\t another accumulator, then just copy the entire thing as is.  */\n-      if (fncode != MMA_BUILTIN_DISASSEMBLE_ACC\n-\t  || TREE_TYPE (TREE_TYPE (dst_ptr)) == vector_quad_type_node)\n+      /* If we are not disassembling an accumulator/pair or our destination is\n+\t another accumulator/pair, then just copy the entire thing as is.  */\n+      if ((fncode == MMA_BUILTIN_DISASSEMBLE_ACC\n+\t   && TREE_TYPE (TREE_TYPE (dst_ptr)) == vector_quad_type_node)\n+\t  || (fncode == MMA_BUILTIN_DISASSEMBLE_PAIR\n+\t      && TREE_TYPE (TREE_TYPE (dst_ptr)) == vector_pair_type_node))\n \t{\n \t  tree dst = build_simple_mem_ref (build1 (VIEW_CONVERT_EXPR,\n \t\t\t\t\t\t   src_type, dst_ptr));\n@@ -11713,29 +11709,33 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi)\n \t  return true;\n \t}\n \n-      /* We're disassembling an accumulator into a different type, so we need\n+      /* If we're disassembling an accumulator into a different type, we need\n \t to emit a xxmfacc instruction now, since we cannot do it later.  */\n-      new_decl = rs6000_builtin_decls[MMA_BUILTIN_XXMFACC_INTERNAL];\n-      new_call = gimple_build_call (new_decl, 1, src);\n-      src = make_ssa_name (vector_quad_type_node);\n-      gimple_call_set_lhs (new_call, src);\n-      gimple_seq_add_stmt (&new_seq, new_call);\n+      if (fncode == MMA_BUILTIN_DISASSEMBLE_ACC)\n+\t{\n+\t  new_decl = rs6000_builtin_decls[MMA_BUILTIN_XXMFACC_INTERNAL];\n+\t  new_call = gimple_build_call (new_decl, 1, src);\n+\t  src = make_ssa_name (vector_quad_type_node);\n+\t  gimple_call_set_lhs (new_call, src);\n+\t  gimple_seq_add_stmt (&new_seq, new_call);\n+\t}\n \n-      /* Copy the accumulator vector by vector.  */\n+      /* Copy the accumulator/pair vector by vector.  */\n+      new_decl = rs6000_builtin_decls[fncode + 1];\n       tree dst_type = build_pointer_type_for_mode (unsigned_V16QI_type_node,\n \t\t\t\t\t\t   ptr_mode, true);\n       tree dst_base = build1 (VIEW_CONVERT_EXPR, dst_type, dst_ptr);\n-      tree array_type = build_array_type_nelts (unsigned_V16QI_type_node, 4);\n-      tree src_array = build1 (VIEW_CONVERT_EXPR, array_type, src);\n-      for (unsigned i = 0; i < 4; i++)\n+      for (unsigned i = 0; i < nvec; i++)\n \t{\n-\t  unsigned index = WORDS_BIG_ENDIAN ? i : 3 - i;\n-\t  tree ref = build4 (ARRAY_REF, unsigned_V16QI_type_node, src_array,\n-\t\t\t     build_int_cst (size_type_node, i),\n-\t\t\t     NULL_TREE, NULL_TREE);\n+\t  unsigned index = WORDS_BIG_ENDIAN ? i : nvec - 1 - i;\n \t  tree dst = build2 (MEM_REF, unsigned_V16QI_type_node, dst_base,\n \t\t\t     build_int_cst (dst_type, index * 16));\n-\t  gimplify_assign (dst, ref, &new_seq);\n+\t  tree dstssa = make_ssa_name (unsigned_V16QI_type_node);\n+\t  new_call = gimple_build_call (new_decl, 2, src,\n+\t\t\t\t\tbuild_int_cstu (uint16_type_node, i));\n+\t  gimple_call_set_lhs (new_call, dstssa);\n+\t  gimple_seq_add_stmt (&new_seq, new_call);\n+\t  gimplify_assign (dst, dstssa, &new_seq);\n \t}\n       pop_gimplify_context (NULL);\n       gsi_replace_with_seq (gsi, new_seq, true);\n@@ -13206,17 +13206,23 @@ rs6000_init_builtins (void)\n   /* Vector pair and vector quad support.  */\n   if (TARGET_EXTRA_BUILTINS)\n     {\n-      vector_pair_type_node = make_unsigned_type (256);\n+      vector_pair_type_node = make_node (OPAQUE_TYPE);\n+      SET_TYPE_MODE (vector_pair_type_node, OOmode);\n+      TYPE_SIZE (vector_pair_type_node) = bitsize_int (GET_MODE_BITSIZE (OOmode));\n+      TYPE_PRECISION (vector_pair_type_node) = GET_MODE_BITSIZE (OOmode);\n+      TYPE_SIZE_UNIT (vector_pair_type_node) = size_int (GET_MODE_SIZE (OOmode));\n       SET_TYPE_ALIGN (vector_pair_type_node, 256);\n-      SET_TYPE_MODE (vector_pair_type_node, POImode);\n-      layout_type (vector_pair_type_node);\n+      TYPE_USER_ALIGN (vector_pair_type_node) = 0;\n       lang_hooks.types.register_builtin_type (vector_pair_type_node,\n \t\t\t\t\t      \"__vector_pair\");\n \n-      vector_quad_type_node = make_unsigned_type (512);\n+      vector_quad_type_node = make_node (OPAQUE_TYPE);\n+      SET_TYPE_MODE (vector_quad_type_node, XOmode);\n+      TYPE_SIZE (vector_quad_type_node) = bitsize_int (GET_MODE_BITSIZE (XOmode));\n+      TYPE_PRECISION (vector_quad_type_node) = GET_MODE_BITSIZE (XOmode);\n+      TYPE_SIZE_UNIT (vector_quad_type_node) = size_int (GET_MODE_SIZE (XOmode));\n       SET_TYPE_ALIGN (vector_quad_type_node, 512);\n-      SET_TYPE_MODE (vector_quad_type_node, PXImode);\n-      layout_type (vector_quad_type_node);\n+      TYPE_USER_ALIGN (vector_quad_type_node) = 0;\n       lang_hooks.types.register_builtin_type (vector_quad_type_node,\n \t\t\t\t\t      \"__vector_quad\");\n     }\n@@ -13252,8 +13258,8 @@ rs6000_init_builtins (void)\n   builtin_mode_to_type[V8HImode][1] = unsigned_V8HI_type_node;\n   builtin_mode_to_type[V16QImode][0] = V16QI_type_node;\n   builtin_mode_to_type[V16QImode][1] = unsigned_V16QI_type_node;\n-  builtin_mode_to_type[POImode][1] = vector_pair_type_node;\n-  builtin_mode_to_type[PXImode][1] = vector_quad_type_node;\n+  builtin_mode_to_type[OOmode][1] = vector_pair_type_node;\n+  builtin_mode_to_type[XOmode][1] = vector_quad_type_node;\n \n   tdecl = add_builtin_type (\"__bool char\", bool_char_type_node);\n   TYPE_NAME (bool_char_type_node) = tdecl;\n@@ -14065,35 +14071,39 @@ mma_init_builtins (void)\n \t}\n       else\n \t{\n-\t  if ((attr & RS6000_BTC_QUAD) == 0)\n+\t  if (!(d->code == MMA_BUILTIN_DISASSEMBLE_ACC_INTERNAL\n+\t\t || d->code == MMA_BUILTIN_DISASSEMBLE_PAIR_INTERNAL)\n+\t       && (attr & RS6000_BTC_QUAD) == 0)\n \t    attr_args--;\n \n \t  /* Ensure we have the correct number and type of operands.  */\n \t  gcc_assert (attr_args == insn_data[icode].n_operands - 1);\n \t}\n \n-      if (icode == CODE_FOR_nothing)\n+      /* This is a disassemble pair/acc function. */\n+      if (d->code == MMA_BUILTIN_DISASSEMBLE_ACC\n+\t  || d->code == MMA_BUILTIN_DISASSEMBLE_PAIR)\n \t{\n-\t  /* This is a disassemble MMA built-in function.  */\n-\t  gcc_assert (attr_args == RS6000_BTC_BINARY\n-\t\t      && (d->code == MMA_BUILTIN_DISASSEMBLE_ACC\n-\t\t\t  || d->code == MMA_BUILTIN_DISASSEMBLE_PAIR));\n \t  op[nopnds++] = build_pointer_type (void_type_node);\n-\t  if (attr & RS6000_BTC_QUAD)\n+\t  if (d->code == MMA_BUILTIN_DISASSEMBLE_ACC)\n \t    op[nopnds++] = build_pointer_type (vector_quad_type_node);\n \t  else\n \t    op[nopnds++] = build_pointer_type (vector_pair_type_node);\n \t}\n       else\n \t{\n \t  /* This is a normal MMA built-in function.  */\n-\t  unsigned j = (attr & RS6000_BTC_QUAD) ? 1 : 0;\n+\t  unsigned j = 0;\n+\t  if (attr & RS6000_BTC_QUAD\n+\t      && d->code != MMA_BUILTIN_DISASSEMBLE_ACC_INTERNAL\n+\t      && d->code != MMA_BUILTIN_DISASSEMBLE_PAIR_INTERNAL)\n+\t    j = 1;\n \t  for (; j < (unsigned) insn_data[icode].n_operands; j++)\n \t    {\n \t      machine_mode mode = insn_data[icode].operand[j].mode;\n-\t      if (gimple_func && mode == PXImode)\n+\t      if (gimple_func && mode == XOmode)\n \t\top[nopnds++] = build_pointer_type (vector_quad_type_node);\n-\t      else if (gimple_func && mode == POImode\n+\t      else if (gimple_func && mode == OOmode\n \t\t       && d->code == MMA_BUILTIN_ASSEMBLE_PAIR)\n \t\top[nopnds++] = build_pointer_type (vector_pair_type_node);\n \t      else\n@@ -14725,7 +14735,7 @@ rs6000_common_init_builtins (void)\n \t      continue;\n \t    }\n \n-          if (icode == CODE_FOR_nothing)\n+\t  if (icode == CODE_FOR_nothing)\n \t    {\n \t      if (TARGET_DEBUG_BUILTIN)\n \t\tfprintf (stderr, \"rs6000_builtin, skip ternary %s (no code)\\n\",\n@@ -14791,7 +14801,7 @@ rs6000_common_init_builtins (void)\n \t      continue;\n \t    }\n \n-          if (icode == CODE_FOR_nothing)\n+\t  if (icode == CODE_FOR_nothing)\n \t    {\n \t      if (TARGET_DEBUG_BUILTIN)\n \t\tfprintf (stderr, \"rs6000_builtin, skip binary %s (no code)\\n\",\n@@ -14800,9 +14810,9 @@ rs6000_common_init_builtins (void)\n \t      continue;\n \t    }\n \n-          mode0 = insn_data[icode].operand[0].mode;\n-          mode1 = insn_data[icode].operand[1].mode;\n-          mode2 = insn_data[icode].operand[2].mode;\n+\t  mode0 = insn_data[icode].operand[0].mode;\n+\t  mode1 = insn_data[icode].operand[1].mode;\n+\t  mode2 = insn_data[icode].operand[2].mode;\n \n \t  type = builtin_function_type (mode0, mode1, mode2, VOIDmode,\n \t\t\t\t\td->code, d->name);\n@@ -14835,7 +14845,7 @@ rs6000_common_init_builtins (void)\n \t\t\t\t\t  NULL_TREE);\n \t}\n       else\n-        {\n+\t{\n \t  enum insn_code icode = d->icode;\n \t  if (d->name == 0)\n \t    {\n@@ -14846,7 +14856,7 @@ rs6000_common_init_builtins (void)\n \t      continue;\n \t    }\n \n-          if (icode == CODE_FOR_nothing)\n+\t  if (icode == CODE_FOR_nothing)\n \t    {\n \t      if (TARGET_DEBUG_BUILTIN)\n \t\tfprintf (stderr, \"rs6000_builtin, skip unary %s (no code)\\n\",\n@@ -14855,8 +14865,8 @@ rs6000_common_init_builtins (void)\n \t      continue;\n \t    }\n \n-          mode0 = insn_data[icode].operand[0].mode;\n-          mode1 = insn_data[icode].operand[1].mode;\n+\t  mode0 = insn_data[icode].operand[0].mode;\n+\t  mode1 = insn_data[icode].operand[1].mode;\n \n \t  type = builtin_function_type (mode0, mode1, VOIDmode, VOIDmode,\n \t\t\t\t\td->code, d->name);"}, {"sha": "e81a32c8c36c5dd84b5d77e625a17a1c1e0004a8", "filename": "gcc/config/rs6000/rs6000-modes.def", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def?ref=f8f8909af1b5dab515adae5b93b51f3c731b9929", "patch": "@@ -83,12 +83,6 @@ VECTOR_MODE (INT, SI, 2);     /*                 V2SI  */\n    combination.  */\n PARTIAL_INT_MODE (TI, 128, PTI);\n \n-/* Define, but don't use the larger integer modes.  We need an integer mode\n-   defined that is the same size as the vector pair and vector quad modes.  */\n-\n-INT_MODE (OI, 32);\n-INT_MODE (XI, 64);\n-\n /* Modes used by __vector_pair and __vector_quad.  */\n-PARTIAL_INT_MODE (OI, 256, POI);\t/* __vector_pair.  */\n-PARTIAL_INT_MODE (XI, 512, PXI);\t/* __vector_quad.  */\n+OPAQUE_MODE (OO, 32);\n+OPAQUE_MODE (XO, 64);"}, {"sha": "a2e6821d3537a2aa645a85c61dda3019e8eafb9f", "filename": "gcc/config/rs6000/rs6000-string.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-string.c?ref=f8f8909af1b5dab515adae5b93b51f3c731b9929", "patch": "@@ -2787,7 +2787,7 @@ expand_block_move (rtx operands[], bool might_overlap)\n       rtx src, dest;\n       bool move_with_length = false;\n \n-      /* Use POImode for paired vsx load/store.  Use V2DI for single\n+      /* Use OOmode for paired vsx load/store.  Use V2DI for single\n \t unaligned vsx load/store, for consistency with what other\n \t expansions (compare) already do, and so we can use lxvd2x on\n \t p8.  Order is VSX pair unaligned, VSX unaligned, Altivec, VSX\n@@ -2799,8 +2799,8 @@ expand_block_move (rtx operands[], bool might_overlap)\n \t  && (align >= 256 || !STRICT_ALIGNMENT))\n \t{\n \t  move_bytes = 32;\n-\t  mode = POImode;\n-\t  gen_func.mov = gen_movpoi;\n+\t  mode = OOmode;\n+\t  gen_func.mov = gen_movoo;\n \t}\n       else if (TARGET_POWERPC64 && TARGET_BLOCK_OPS_UNALIGNED_VSX\n \t       && VECTOR_MEM_VSX_P (V2DImode)"}, {"sha": "bd8205c87f7ef63b8b6ababe67c90686bbe509e6", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 113, "deletions": 80, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f8f8909af1b5dab515adae5b93b51f3c731b9929", "patch": "@@ -1826,15 +1826,12 @@ rs6000_hard_regno_mode_ok_uncached (int regno, machine_mode mode)\n     mode = GET_MODE_INNER (mode);\n \n   /* Vector pair modes need even/odd VSX register pairs.  Only allow vector\n-     registers.  We need to allow OImode to have the same registers as POImode,\n-     even though we do not enable the move pattern for OImode.  */\n-  if (mode == POImode || mode == OImode)\n+     registers.  */\n+  if (mode == OOmode)\n     return (TARGET_MMA && VSX_REGNO_P (regno) && (regno & 1) == 0);\n \n-  /* MMA accumulator modes need FPR registers divisible by 4.  We need to allow\n-     XImode to have the same registers as PXImode, even though we do not enable\n-     the move pattern for XImode.  */\n-  if (mode == PXImode || mode == XImode)\n+  /* MMA accumulator modes need FPR registers divisible by 4.  */\n+  if (mode == XOmode)\n     return (TARGET_MMA && FP_REGNO_P (regno) && (regno & 3) == 0);\n \n   /* PTImode can only go in GPRs.  Quad word memory operations require even/odd\n@@ -1941,8 +1938,8 @@ rs6000_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n    GPR registers, and TImode can go in any GPR as well as VSX registers (PR\n    57744).\n \n-   Similarly, don't allow POImode (vector pair, restricted to even VSX\n-   registers) or PXImode (vector quad, restricted to FPR registers divisible\n+   Similarly, don't allow OOmode (vector pair, restricted to even VSX\n+   registers) or XOmode (vector quad, restricted to FPR registers divisible\n    by 4) to tie with other modes.\n \n    Altivec/VSX vector tests were moved ahead of scalar float mode, so that IEEE\n@@ -1951,8 +1948,8 @@ rs6000_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n static bool\n rs6000_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n-  if (mode1 == PTImode || mode1 == POImode || mode1 == PXImode\n-      || mode2 == PTImode || mode2 == POImode || mode2 == PXImode)\n+  if (mode1 == PTImode || mode1 == OOmode || mode1 == XOmode\n+      || mode2 == PTImode || mode2 == OOmode || mode2 == XOmode)\n     return mode1 == mode2;\n \n   if (ALTIVEC_OR_VSX_VECTOR_MODE (mode1))\n@@ -2241,10 +2238,8 @@ rs6000_debug_reg_global (void)\n     V2DFmode,\n     V8SFmode,\n     V4DFmode,\n-    OImode,\n-    XImode,\n-    POImode,\n-    PXImode,\n+    OOmode,\n+    XOmode,\n     CCmode,\n     CCUNSmode,\n     CCEQmode,\n@@ -2706,13 +2701,13 @@ rs6000_setup_reg_addr_masks (void)\n \t     since it will be broken into two vector moves.  Vector quads can\n \t     only do offset loads.  */\n \t  else if ((addr_mask != 0) && TARGET_MMA\n-\t\t   && (m2 == POImode || m2 == PXImode))\n+\t\t   && (m2 == OOmode || m2 == XOmode))\n \t    {\n \t      addr_mask |= RELOAD_REG_OFFSET;\n \t      if (rc == RELOAD_REG_FPR || rc == RELOAD_REG_VMX)\n \t\t{\n \t\t  addr_mask |= RELOAD_REG_QUAD_OFFSET;\n-\t\t  if (m2 == POImode)\n+\t\t  if (m2 == OOmode)\n \t\t    addr_mask |= RELOAD_REG_INDEXED;\n \t\t}\n \t    }\n@@ -2921,13 +2916,13 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n   /* Add support for vector pairs and vector quad registers.  */\n   if (TARGET_MMA)\n     {\n-      rs6000_vector_unit[POImode] = VECTOR_NONE;\n-      rs6000_vector_mem[POImode] = VECTOR_VSX;\n-      rs6000_vector_align[POImode] = 256;\n+      rs6000_vector_unit[OOmode] = VECTOR_NONE;\n+      rs6000_vector_mem[OOmode] = VECTOR_VSX;\n+      rs6000_vector_align[OOmode] = 256;\n \n-      rs6000_vector_unit[PXImode] = VECTOR_NONE;\n-      rs6000_vector_mem[PXImode] = VECTOR_VSX;\n-      rs6000_vector_align[PXImode] = 512;\n+      rs6000_vector_unit[XOmode] = VECTOR_NONE;\n+      rs6000_vector_mem[XOmode] = VECTOR_VSX;\n+      rs6000_vector_align[XOmode] = 512;\n     }\n \n   /* Register class constraints for the constraints that depend on compile\n@@ -3064,10 +3059,10 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \n \t      if (TARGET_MMA)\n \t\t{\n-\t\t  reg_addr[POImode].reload_store = CODE_FOR_reload_poi_di_store;\n-\t\t  reg_addr[POImode].reload_load = CODE_FOR_reload_poi_di_load;\n-\t\t  reg_addr[PXImode].reload_store = CODE_FOR_reload_pxi_di_store;\n-\t\t  reg_addr[PXImode].reload_load = CODE_FOR_reload_pxi_di_load;\n+\t\t  reg_addr[OOmode].reload_store = CODE_FOR_reload_oo_di_store;\n+\t\t  reg_addr[OOmode].reload_load = CODE_FOR_reload_oo_di_load;\n+\t\t  reg_addr[XOmode].reload_store = CODE_FOR_reload_xo_di_store;\n+\t\t  reg_addr[XOmode].reload_load = CODE_FOR_reload_xo_di_load;\n \t\t}\n \t    }\n \t}\n@@ -8129,8 +8124,8 @@ reg_offset_addressing_ok_p (machine_mode mode)\n \n       /* The vector pair/quad types support offset addressing if the\n \t underlying vectors support offset addressing.  */\n-    case E_POImode:\n-    case E_PXImode:\n+    case E_OOmode:\n+    case E_XOmode:\n       return TARGET_MMA;\n \n     case E_SDmode:\n@@ -10323,11 +10318,11 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n \n-    case E_POImode:\n-    case E_PXImode:\n+    case E_OOmode:\n+    case E_XOmode:\n       if (CONST_INT_P (operands[1]) && INTVAL (operands[1]) != 0)\n \terror (\"%qs is an opaque type, and you can't set it to other values.\",\n-\t       (mode == POImode) ? \"__vector_pair\" : \"__vector_quad\");\n+\t       (mode == OOmode) ? \"__vector_pair\" : \"__vector_quad\");\n       break;\n \n     case E_SImode:\n@@ -12596,10 +12591,10 @@ rs6000_preferred_reload_class (rtx x, enum reg_class rclass)\n      the GPR registers.  */\n   if (rclass == GEN_OR_FLOAT_REGS)\n     {\n-      if (mode == POImode)\n+      if (mode == OOmode)\n \treturn VSX_REGS;\n \n-      if (mode == PXImode)\n+      if (mode == XOmode)\n \treturn FLOAT_REGS;\n \n       if (GET_MODE_CLASS (mode) == MODE_INT)\n@@ -16323,15 +16318,15 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \n   /* If we have a vector quad register for MMA, and this is a load or store,\n      see if we can use vector paired load/stores.  */\n-  if (mode == PXImode && TARGET_MMA\n+  if (mode == XOmode && TARGET_MMA\n       && (MEM_P (dst) || MEM_P (src)))\n     {\n-      reg_mode = POImode;\n+      reg_mode = OOmode;\n       nregs /= 2;\n     }\n   /* If we have a vector pair/quad mode, split it into two/four separate\n      vectors.  */\n-  else if (mode == POImode || mode == PXImode)\n+  else if (mode == OOmode || mode == XOmode)\n     reg_mode = V1TImode;\n   else if (FP_REGNO_P (reg))\n     reg_mode = DECIMAL_FLOAT_MODE_P (mode) ? DDmode :\n@@ -16377,12 +16372,16 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n       return;\n     }\n \n-  /* The __vector_pair and __vector_quad modes are multi-register modes,\n-     so if have to load or store the registers, we have to be careful to\n-     properly swap them if we're in little endian mode below.  This means\n-     the last register gets the first memory location.  */\n-  if (mode == POImode || mode == PXImode)\n+  /* The __vector_pair and __vector_quad modes are multi-register\n+     modes, so if we have to load or store the registers, we have to be\n+     careful to properly swap them if we're in little endian mode\n+     below.  This means the last register gets the first memory\n+     location.  We also need to be careful of using the right register\n+     numbers if we are splitting XO to OO.  */\n+  if (mode == OOmode || mode == XOmode)\n     {\n+      nregs = hard_regno_nregs (reg, mode);\n+      int reg_mode_nregs = hard_regno_nregs (reg, reg_mode);\n       if (MEM_P (dst))\n \t{\n \t  unsigned offset = 0;\n@@ -16391,15 +16390,15 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t  /* If we are reading an accumulator register, we have to\n \t     deprime it before we can access it.  */\n \t  if (TARGET_MMA\n-\t      && GET_MODE (src) == PXImode && FP_REGNO_P (REGNO (src)))\n+\t      && GET_MODE (src) == XOmode && FP_REGNO_P (REGNO (src)))\n \t    emit_insn (gen_mma_xxmfacc (src, src));\n \n-\t  for (int i = 0; i < nregs; i++)\n+\t  for (int i = 0; i < nregs; i += reg_mode_nregs)\n \t    {\n-\t      unsigned subreg = (WORDS_BIG_ENDIAN)\n-\t\t\t\t  ? i * size : (nregs - 1 - i) * size;\n+\t      unsigned subreg =\n+\t\t(WORDS_BIG_ENDIAN) ? i : (nregs - reg_mode_nregs - i);\n \t      rtx dst2 = adjust_address (dst, reg_mode, offset);\n-\t      rtx src2 = simplify_gen_subreg (reg_mode, src, mode, subreg);\n+\t      rtx src2 = gen_rtx_REG (reg_mode, reg + subreg);\n \t      offset += size;\n \t      emit_insn (gen_rtx_SET (dst2, src2));\n \t    }\n@@ -16412,11 +16411,11 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t  unsigned offset = 0;\n \t  unsigned size = GET_MODE_SIZE (reg_mode);\n \n-\t  for (int i = 0; i < nregs; i++)\n+\t  for (int i = 0; i < nregs; i += reg_mode_nregs)\n \t    {\n-\t      unsigned subreg = (WORDS_BIG_ENDIAN)\n-\t\t\t\t  ? i * size : (nregs - 1 - i) * size;\n-\t      rtx dst2 = simplify_gen_subreg (reg_mode, dst, mode, subreg);\n+\t      unsigned subreg =\n+\t\t(WORDS_BIG_ENDIAN) ? i : (nregs - reg_mode_nregs - i);\n+\t      rtx dst2 = gen_rtx_REG (reg_mode, reg + subreg);\n \t      rtx src2 = adjust_address (src, reg_mode, offset);\n \t      offset += size;\n \t      emit_insn (gen_rtx_SET (dst2, src2));\n@@ -16425,17 +16424,20 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t  /* If we are writing an accumulator register, we have to\n \t     prime it after we've written it.  */\n \t  if (TARGET_MMA\n-\t      && GET_MODE (dst) == PXImode && FP_REGNO_P (REGNO (dst)))\n+\t      && GET_MODE (dst) == XOmode && FP_REGNO_P (REGNO (dst)))\n \t    emit_insn (gen_mma_xxmtacc (dst, dst));\n \n \t  return;\n \t}\n \n       if (GET_CODE (src) == UNSPEC)\n \t{\n-\t  gcc_assert (REG_P (dst)\n-\t\t      && FP_REGNO_P (REGNO (dst))\n-\t\t      && XINT (src, 1) == UNSPEC_MMA_ASSEMBLE_ACC);\n+\t  gcc_assert (XINT (src, 1) == UNSPEC_MMA_ASSEMBLE);\n+\t  gcc_assert (REG_P (dst));\n+\t  if (GET_MODE (src) == XOmode)\n+\t    gcc_assert (FP_REGNO_P (REGNO (dst)));\n+\t  if (GET_MODE (src) == OOmode)\n+\t    gcc_assert (VSX_REGNO_P (REGNO (dst)));\n \n \t  reg_mode = GET_MODE (XVECEXP (src, 0, 0));\n \t  for (int i = 0; i < XVECLEN (src, 0); i++)\n@@ -16446,7 +16448,8 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \n \t  /* We are writing an accumulator register, so we have to\n \t     prime it after we've written it.  */\n-\t  emit_insn (gen_mma_xxmtacc (dst, dst));\n+\t  if (GET_MODE (src) == XOmode)\n+\t    emit_insn (gen_mma_xxmtacc (dst, dst));\n \n \t  return;\n \t}\n@@ -16459,22 +16462,35 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n       /* If we are reading an accumulator register, we have to\n \t deprime it before we can access it.  */\n       if (TARGET_MMA\n-\t  && GET_MODE (src) == PXImode && FP_REGNO_P (REGNO (src)))\n+\t  && GET_MODE (src) == XOmode && FP_REGNO_P (REGNO (src)))\n \temit_insn (gen_mma_xxmfacc (src, src));\n \n       /* Move register range backwards, if we might have destructive\n \t overlap.  */\n       int i;\n-      for (i = nregs - 1; i >= 0; i--)\n-\temit_insn (gen_rtx_SET (simplify_gen_subreg (reg_mode, dst, mode,\n-\t\t\t\t\t\t     i * reg_mode_size),\n-\t\t\t\tsimplify_gen_subreg (reg_mode, src, mode,\n-\t\t\t\t\t\t     i * reg_mode_size)));\n+      /* XO/OO are opaque so cannot use subregs. */\n+      if (mode == OOmode || mode == XOmode )\n+\t{\n+\t  for (i = nregs - 1; i >= 0; i--)\n+\t    {\n+\t      rtx dst_i = gen_rtx_REG (reg_mode, REGNO (dst) + i);\n+\t      rtx src_i = gen_rtx_REG (reg_mode, REGNO (src) + i);\n+\t      emit_insn (gen_rtx_SET (dst_i, src_i));\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (i = nregs - 1; i >= 0; i--)\n+\t    emit_insn (gen_rtx_SET (simplify_gen_subreg (reg_mode, dst, mode,\n+\t\t\t\t\t\t\t i * reg_mode_size),\n+\t\t\t\t    simplify_gen_subreg (reg_mode, src, mode,\n+\t\t\t\t\t\t\t i * reg_mode_size)));\n+\t}\n \n       /* If we are writing an accumulator register, we have to\n \t prime it after we've written it.  */\n       if (TARGET_MMA\n-\t  && GET_MODE (dst) == PXImode && FP_REGNO_P (REGNO (dst)))\n+\t  && GET_MODE (dst) == XOmode && FP_REGNO_P (REGNO (dst)))\n \temit_insn (gen_mma_xxmtacc (dst, dst));\n     }\n   else\n@@ -16611,7 +16627,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n       /* If we are reading an accumulator register, we have to\n \t deprime it before we can access it.  */\n       if (TARGET_MMA && REG_P (src)\n-\t  && GET_MODE (src) == PXImode && FP_REGNO_P (REGNO (src)))\n+\t  && GET_MODE (src) == XOmode && FP_REGNO_P (REGNO (src)))\n \temit_insn (gen_mma_xxmfacc (src, src));\n \n       for (i = 0; i < nregs; i++)\n@@ -16626,16 +16642,24 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t  if (j == 0 && used_update)\n \t    continue;\n \n-\t  emit_insn (gen_rtx_SET (simplify_gen_subreg (reg_mode, dst, mode,\n-\t\t\t\t\t\t       j * reg_mode_size),\n-\t\t\t\t  simplify_gen_subreg (reg_mode, src, mode,\n-\t\t\t\t\t\t       j * reg_mode_size)));\n+\t  /* XO/OO are opaque so cannot use subregs. */\n+\t  if (mode == OOmode || mode == XOmode )\n+\t    {\n+\t      rtx dst_i = gen_rtx_REG (reg_mode, REGNO (dst) + j);\n+\t      rtx src_i = gen_rtx_REG (reg_mode, REGNO (src) + j);\n+\t      emit_insn (gen_rtx_SET (dst_i, src_i));\n+\t    }\n+\t  else\n+\t    emit_insn (gen_rtx_SET (simplify_gen_subreg (reg_mode, dst, mode,\n+\t\t\t\t\t\t\t j * reg_mode_size),\n+\t\t\t\t    simplify_gen_subreg (reg_mode, src, mode,\n+\t\t\t\t\t\t\t j * reg_mode_size)));\n \t}\n \n       /* If we are writing an accumulator register, we have to\n \t prime it after we've written it.  */\n       if (TARGET_MMA && REG_P (dst)\n-\t  && GET_MODE (dst) == PXImode && FP_REGNO_P (REGNO (dst)))\n+\t  && GET_MODE (dst) == XOmode && FP_REGNO_P (REGNO (dst)))\n \temit_insn (gen_mma_xxmtacc (dst, dst));\n \n       if (restore_basereg != NULL_RTX)\n@@ -19865,7 +19889,8 @@ rs6000_mangle_type (const_tree type)\n   type = TYPE_MAIN_VARIANT (type);\n \n   if (TREE_CODE (type) != VOID_TYPE && TREE_CODE (type) != BOOLEAN_TYPE\n-      && TREE_CODE (type) != INTEGER_TYPE && TREE_CODE (type) != REAL_TYPE)\n+      && TREE_CODE (type) != INTEGER_TYPE && TREE_CODE (type) != REAL_TYPE\n+      && TREE_CODE (type) != OPAQUE_TYPE)\n     return NULL;\n \n   if (type == bool_char_type_node) return \"U6__boolc\";\n@@ -21753,6 +21778,14 @@ rs6000_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t}\n       break;\n \n+    case UNSPEC:\n+      if (XINT (x, 1) == UNSPEC_MMA_XXSETACCZ)\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n+      break;\n+\n     default:\n       break;\n     }\n@@ -27186,14 +27219,14 @@ rs6000_invalid_conversion (const_tree fromtype, const_tree totype)\n \n   if (frommode != tomode)\n     {\n-      /* Do not allow conversions to/from PXImode and POImode types.  */\n-      if (frommode == PXImode)\n+      /* Do not allow conversions to/from XOmode and OOmode types.  */\n+      if (frommode == XOmode)\n \treturn N_(\"invalid conversion from type %<__vector_quad%>\");\n-      if (tomode == PXImode)\n+      if (tomode == XOmode)\n \treturn N_(\"invalid conversion to type %<__vector_quad%>\");\n-      if (frommode == POImode)\n+      if (frommode == OOmode)\n \treturn N_(\"invalid conversion from type %<__vector_pair%>\");\n-      if (tomode == POImode)\n+      if (tomode == OOmode)\n \treturn N_(\"invalid conversion to type %<__vector_pair%>\");\n     }\n   else if (POINTER_TYPE_P (fromtype) && POINTER_TYPE_P (totype))\n@@ -27202,19 +27235,19 @@ rs6000_invalid_conversion (const_tree fromtype, const_tree totype)\n       frommode = TYPE_MODE (TREE_TYPE (fromtype));\n       tomode = TYPE_MODE (TREE_TYPE (totype));\n \n-      /* Do not allow conversions to/from PXImode and POImode pointer\n+      /* Do not allow conversions to/from XOmode and OOmode pointer\n \t types, except to/from void pointers.  */\n       if (frommode != tomode\n \t  && frommode != VOIDmode\n \t  && tomode != VOIDmode)\n \t{\n-\t  if (frommode == PXImode)\n+\t  if (frommode == XOmode)\n \t    return N_(\"invalid conversion from type %<* __vector_quad%>\");\n-\t  if (tomode == PXImode)\n+\t  if (tomode == XOmode)\n \t    return N_(\"invalid conversion to type %<* __vector_quad%>\");\n-\t  if (frommode == POImode)\n+\t  if (frommode == OOmode)\n \t    return N_(\"invalid conversion from type %<* __vector_pair%>\");\n-\t  if (tomode == POImode)\n+\t  if (tomode == OOmode)\n \t    return N_(\"invalid conversion to type %<* __vector_pair%>\");\n \t}\n     }"}, {"sha": "f35aaf4ffd12df834284227d4e3ac8ef396acac4", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=f8f8909af1b5dab515adae5b93b51f3c731b9929", "patch": "@@ -1041,7 +1041,7 @@ enum data_align { align_abi, align_opt, align_both };\n /* Modes that are not vectors, but require vector alignment.  Treat these like\n    vectors in terms of loads and stores.  */\n #define VECTOR_ALIGNMENT_P(MODE)\t\t\t\t\t\\\n-  (FLOAT128_VECTOR_P (MODE) || (MODE) == POImode || (MODE) == PXImode)\n+  (FLOAT128_VECTOR_P (MODE) || (MODE) == OOmode || (MODE) == XOmode)\n \n #define ALTIVEC_VECTOR_MODE(MODE)\t\t\t\t\t\\\n   ((MODE) == V16QImode\t\t\t\t\t\t\t\\\n@@ -2556,6 +2556,7 @@ typedef struct GTY(()) machine_function\n   bool fpr_is_wrapped_separately[32];\n   bool lr_is_wrapped_separately;\n   bool toc_is_wrapped_separately;\n+  bool mma_return_type_error;\n } machine_function;\n #endif\n "}, {"sha": "0e799198a50cc4f92060aa1c81079cc4850518ae", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=f8f8909af1b5dab515adae5b93b51f3c731b9929", "patch": "@@ -778,7 +778,7 @@\n ;; supplement addressing modes.\n (define_mode_iterator RELOAD [V16QI V8HI V4SI V2DI V4SF V2DF V1TI\n \t\t\t      SF SD SI DF DD DI TI PTI KF IF TF\n-\t\t\t      POI PXI])\n+\t\t\t      OO XO])\n \n ;; Iterate over smin, smax\n (define_code_iterator fp_minmax\t[smin smax])"}, {"sha": "254af7f8f79e2766fd1bdad9a518b6e3d7c85031", "filename": "gcc/testsuite/gcc.target/powerpc/mma-double-test.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-double-test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-double-test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-double-test.c?ref=f8f8909af1b5dab515adae5b93b51f3c731b9929", "patch": "@@ -181,6 +181,9 @@ main (int argc, char *argv[])\n     printf (\"MMA double test fail: %d errors\\n\",ret);\n   else\n     printf (\"MMA single test success: 0 MMA errors\\n\");\n+#else\n+  if (ret)\n+    abort();\n #endif\n       \n   return ret;"}, {"sha": "ebbc5ae2e1bfa26eaf89b4f706edbea6709fd22a", "filename": "gcc/testsuite/gcc.target/powerpc/mma-single-test.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-single-test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-single-test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-single-test.c?ref=f8f8909af1b5dab515adae5b93b51f3c731b9929", "patch": "@@ -189,6 +189,9 @@ main (int argc, char *argv[])\n     printf (\"MMA single test fail: %d errors\\n\",ret);\n   else\n     printf (\"MMA single test success: 0 MMA errors\\n\");\n+#else\n+  if (ret)\n+    abort();\n #endif\n       \n   return ret;"}, {"sha": "91835cec30c52f67eabf692afac45f3ae65520df", "filename": "gcc/testsuite/gcc.target/powerpc/pr96506-1.c", "status": "renamed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96506-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96506-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96506-1.c?ref=f8f8909af1b5dab515adae5b93b51f3c731b9929", "patch": "@@ -40,27 +40,3 @@ foo3 (void)\n   vquad_t v;\n   bar3 (v); /* { dg-error \"invalid use of MMA operand of type .__vector_quad. as a function parameter\" } */\n }\n-\n-__vector_pair\n-foo4 (__vector_pair *src) /* { dg-error \"invalid use of MMA type .__vector_pair. as a function return value\" } */\n-{\n-  return *src;\n-}\n-\n-vpair_t\n-foo5 (vpair_t *src) /* { dg-error \"invalid use of MMA type .__vector_pair. as a function return value\" } */\n-{\n-  return *src;\n-}\n-\n-__vector_quad\n-foo6 (__vector_quad *src) /* { dg-error \"invalid use of MMA type .__vector_quad. as a function return value\" } */\n-{\n-  return *src;\n-}\n-\n-vquad_t\n-foo7 (vquad_t *src) /* { dg-error \"invalid use of MMA type .__vector_quad. as a function return value\" } */\n-{\n-  return *src;\n-}", "previous_filename": "gcc/testsuite/gcc.target/powerpc/pr96506.c"}, {"sha": "9cffd2576c9bcc3807f737ae4466f0efe48e6210", "filename": "gcc/testsuite/gcc.target/powerpc/pr96506-2.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96506-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f8909af1b5dab515adae5b93b51f3c731b9929/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96506-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96506-2.c?ref=f8f8909af1b5dab515adae5b93b51f3c731b9929", "patch": "@@ -0,0 +1,38 @@\n+/* PR target/96506 */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+extern void bar0();\n+extern void bar1();\n+extern void bar2();\n+extern void bar3();\n+\n+typedef __vector_pair vpair_t;\n+typedef __vector_quad vquad_t;\n+\n+/* Verify we flag errors on the following.  */\n+\n+__vector_pair\n+foo4 (__vector_pair *src)\n+{ /* { dg-error \"invalid use of MMA type .__vector_pair. as a function return value\" } */\n+  return *src;\n+}\n+\n+vpair_t\n+foo5 (vpair_t *src)\n+{ /* { dg-error \"invalid use of MMA type .__vector_pair. as a function return value\" } */\n+  return *src;\n+}\n+\n+__vector_quad\n+foo6 (__vector_quad *src)\n+{ /* { dg-error \"invalid use of MMA type .__vector_quad. as a function return value\" } */\n+  return *src;\n+}\n+\n+vquad_t\n+foo7 (vquad_t *src)\n+{ /* { dg-error \"invalid use of MMA type .__vector_quad. as a function return value\" } */\n+  return *src;\n+}"}]}