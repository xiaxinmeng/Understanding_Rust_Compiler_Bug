{"sha": "6b940b3910721db1d168a99d4091a7133e04a5b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI5NDBiMzkxMDcyMWRiMWQxNjhhOTlkNDA5MWE3MTMzZTA0YTViMg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "2000-04-04T06:42:40Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-04-04T06:42:40Z"}, "message": "pa-64.h: New file.\n\n        * pa/pa-64.h: New file.\n        * pa/pa64-regs.h: New file.\n        * pa/pa64-start.h: New file.\n        * pa/t-pa64: New file.\n        * pa/xm-pa64hpux.h: New file.\n\nFrom-SVN: r32898", "tree": {"sha": "d2453179b18535379ccf707d76fefe7d7bed8ad8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2453179b18535379ccf707d76fefe7d7bed8ad8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b940b3910721db1d168a99d4091a7133e04a5b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b940b3910721db1d168a99d4091a7133e04a5b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b940b3910721db1d168a99d4091a7133e04a5b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b940b3910721db1d168a99d4091a7133e04a5b2/comments", "author": null, "committer": null, "parents": [{"sha": "e77d72cbc052a2462231aa1848d3e220a471d098", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e77d72cbc052a2462231aa1848d3e220a471d098", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e77d72cbc052a2462231aa1848d3e220a471d098"}], "stats": {"total": 786, "additions": 786, "deletions": 0}, "files": [{"sha": "9283be8dbd248103c5332e3553a17b0c74560481", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b940b3910721db1d168a99d4091a7133e04a5b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b940b3910721db1d168a99d4091a7133e04a5b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b940b3910721db1d168a99d4091a7133e04a5b2", "patch": "@@ -1,3 +1,11 @@\n+Tue Apr  4 00:41:53 2000  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* pa/pa-64.h: New file.\n+\t* pa/pa64-regs.h: New file.\n+\t* pa/pa64-start.h: New file.\n+\t* pa/t-pa64: New file.\n+\t* pa/xm-pa64hpux.h: New file.\n+\n 2000-04-03  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* sparc.c (output_restore_regs): Prototype."}, {"sha": "e26cf86c4030ab25ec19573e91ef3c7573507c02", "filename": "gcc/config/pa/pa-64.h", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b940b3910721db1d168a99d4091a7133e04a5b2/gcc%2Fconfig%2Fpa%2Fpa-64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b940b3910721db1d168a99d4091a7133e04a5b2/gcc%2Fconfig%2Fpa%2Fpa-64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-64.h?ref=6b940b3910721db1d168a99d4091a7133e04a5b2", "patch": "@@ -0,0 +1,404 @@\n+/* Definitions of target machine for GNU compiler, for HPs using the\n+   64bit runtime model.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* We can debug dynamically linked executables on hpux11; we also\n+   want dereferencing of a NULL pointer to cause a SEGV.  */\n+#undef LINK_SPEC\n+#define LINK_SPEC \\\n+  \"-E %{mlinker-opt:-O} %{!shared:-u main} %{static:-a archive} %{shared:-shared}\"\n+\n+/* Like the default, except no -lg.  */\n+#undef LIB_SPEC\n+#define LIB_SPEC \\\n+  \"%{!shared:\\\n+     %{!p:\\\n+       %{!pg:\\\n+         %{!threads:-lc}\\\n+         %{threads:-lcma -lc_r}}\\\n+       %{p: -L/lib/libp/ -lc}\\\n+       %{pg: -L/lib/libp/ -lc}}} /usr/lib/pa20_64/milli.a\"\n+\n+/* Under hpux11, the normal location of the `ld' and `as' programs is the\n+   /usr/ccs/bin directory.  */\n+\n+#ifndef CROSS_COMPILE\n+#undef MD_EXEC_PREFIX\n+#define MD_EXEC_PREFIX \"/opt/langtools/bin\"\n+#endif\n+\n+/* Under hpux11 the normal location of the various *crt*.o files is the\n+   /usr/ccs/lib directory.  */\n+\n+#ifndef CROSS_COMPILE\n+#undef MD_STARTFILE_PREFIX\n+#define MD_STARTFILE_PREFIX \"/opt/langtools/lib/pa20_64/\"\n+#endif\n+\n+/* hpux11 has the new HP assembler.  It's still lousy, but it's a whole lot\n+   better than the assembler shipped with older versions of hpux.  */\n+#define NEW_HP_ASSEMBLER\n+\n+/* The default sizes for basic datatypes provided by GCC are not\n+   correct for the PA64 runtime architecture.\n+\n+   In PA64, basic types have the following sizes\n+\n+     char\t1 byte\n+     short\t2 bytes\n+     int\t4 bytes\n+     long\t8 bytes\n+     long long\t8 bytes\n+     pointer\t8 bytes\n+     float\t4 bytes\n+     double\t8 bytes\n+     long double 16 bytes\n+     size_t\t8 bytes\n+     ptrdiff_t\t8 bytes\n+     wchar\t4 bytes\n+     \n+  Make GCC agree with types.h.  */\n+#undef SIZE_TYPE\n+#undef PTRDIFF_TYPE\n+\n+#define SIZE_TYPE \"long unsigned int\"\n+#define PTRDIFF_TYPE \"long int\"\n+\n+/* If it is not listed here, then the default selected by GCC is OK.  */\n+#define SHORT_TYPE_SIZE 16\n+#define INT_TYPE_SIZE 32\n+#define MAX_LONG_TYPE_SIZE 64\n+#define LONG_TYPE_SIZE 64\n+#define LONG_LONG_TYPE_SIZE 64\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 64\n+/* This should be 128, but until we work out the ABI for the 128bit\n+   FP codes supplied by HP we'll keep it at 64 bits.  */\n+#undef LONG_DOUBLE_TYPE_SIZE\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+#define MAX_WCHAR_TYPE_SIZE 32\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE) \\\n+do {  \\\n+     if (TARGET_64BIT) \\\n+       fputs(\"\\t.LEVEL 2.0w\\n\", FILE); \\\n+     else if (TARGET_PA_11) \\\n+       fputs(\"\\t.LEVEL 2.0\\n\", FILE); \\\n+     else if (TARGET_PA_11) \\\n+       fputs(\"\\t.LEVEL 1.1\\n\", FILE); \\\n+     else \\\n+       fputs(\"\\t.LEVEL 1.0\\n\", FILE); \\\n+     if (profile_flag)\\\n+       fprintf (FILE, \"\\t.IMPORT _mcount, CODE\\n\");\\\n+     if (write_symbols != NO_DEBUG) \\\n+       output_file_directive ((FILE), main_input_filename); \\\n+   } while (0)\n+\n+/* Temporary until we figure out what to do with those *(&@$ 32bit\n+   relocs which appear in stabs.  */\n+#undef DBX_DEBUGGING_INFO\n+\n+/* We want the compiler to select a suitable secondary memory location.\n+   ?!? This may not work reliably.  Keep an eye out for problems.  */\n+#undef SECONDARY_MEMORY_NEEDED_RTX\n+\n+\n+/* ?!? This needs to be made compile-time selectable.\n+\n+   The PA64 runtime model has arguments that grow to higher addresses\n+   (like most other targets).  The older runtime model has arguments\n+   that grow to lower addresses.  What fun.  */\n+#undef ARGS_GROW_DOWNWARD\n+#undef ARG_POINTER_REGNUM\n+#define ARG_POINTER_REGNUM 29\n+#undef STATIC_CHAIN_REGNUM\n+#define STATIC_CHAIN_REGNUM 31\n+\n+/* This is not needed for correct operation in 32bit mode, and since\n+   older versions of gas and the hpux assembler do not accept .dword\n+   we put this here instead of the more logical location, pa.h.  */\n+#define ASM_OUTPUT_DOUBLE_INT(FILE,VALUE)  \\\n+{ fputs (\"\\t.dword \", FILE);                    \\\n+  if (function_label_operand (VALUE, VOIDmode)) \\\n+    fputs (\"P%\", FILE);                         \\\n+  output_addr_const (FILE, (VALUE));            \\\n+  fputs (\"\\n\", FILE);}\n+\n+/* It looks like DWARF2 will be the easiest debug format to handle on this\n+   platform.  */\n+#define OBJECT_FORMAT_ELF\n+#define DWARF2_DEBUGGING_INFO\n+#define PREFERRED_DEBUGGING_FORMAT DWARF2_DEBUG\n+/* This isn't quite ready yet.  I'm seeing it mess up some line\n+   tables.  For example, we're getting lines starting/ending at\n+   impossible addresses.  */\n+#define DWARF2_ASM_LINE_DEBUG_INFO 1\n+\n+\n+/* Nonzero if we do not know how to pass TYPE solely in registers. */\n+#define MUST_PASS_IN_STACK(MODE,TYPE)                   \\\n+  ((TYPE) != 0                                          \\\n+   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST      \\\n+       || TREE_ADDRESSABLE (TYPE)))\n+\n+/* The rest of this file is copied from the generic svr4.h.  One day we\n+   would like to simply include svr4.h instead of copying all these\n+   definitions.  */\n+\n+/* Support const sections and the ctors and dtors sections for g++.\n+   Note that there appears to be two different ways to support const\n+   sections at the moment.  You can either #define the symbol\n+   READONLY_DATA_SECTION (giving it some code which switches to the\n+   readonly data section) or else you can #define the symbols\n+   EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS, SELECT_SECTION, and\n+   SELECT_RTX_SECTION.  We do both here just to be on the safe side.  */\n+\n+#define USE_CONST_SECTION\t1\n+\n+#define CONST_SECTION_ASM_OP\t\"\\t.section\\t.rodata\"\n+\n+/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.\n+\n+   Note that we want to give these sections the SHF_WRITE attribute\n+   because these sections will actually contain data (i.e. tables of\n+   addresses of functions in the current root executable or shared library\n+   file) and, in the case of a shared library, the relocatable addresses\n+   will have to be properly resolved/relocated (and then written into) by\n+   the dynamic linker when it actually attaches the given shared library\n+   to the executing process.  (Note that on SVR4, you may wish to use the\n+   `-z text' option to the ELF linker, when building a shared library, as\n+   an additional check that you are doing everything right.  But if you do\n+   use the `-z text' option when building a shared library, you will get\n+   errors unless the .ctors and .dtors sections are marked as writable\n+   via the SHF_WRITE attribute.)  */\n+\n+#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"aw\\\"\"\n+#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"aw\\\"\"\n+\n+/* On svr4, we *do* have support for the .init and .fini sections, and we\n+   can put stuff in there to be executed before and after `main'.  We let\n+   crtstuff.c and other files know this by defining the following symbols.\n+   The definitions say how to change sections to the .init and .fini\n+   sections.  This is the same for all known svr4 assemblers.  */\n+\n+/* ??? For the time being, we aren't using init sections. */\n+#if 0\n+#define INIT_SECTION_ASM_OP\t\"\\t.section\\t.init\"\n+#define FINI_SECTION_ASM_OP\t\"\\t.section\\t.fini\"\n+#endif\n+\n+/* A default list of other sections which we might be \"in\" at any given\n+   time.  For targets that use additional sections (e.g. .tdesc) you\n+   should override this definition in the target-specific file which\n+   includes this file.  */\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_const, in_ctors, in_dtors\n+\n+/* A default list of extra section function definitions.  For targets\n+   that use additional sections (e.g. .tdesc) you should override this\n+   definition in the target-specific file which includes this file.  */\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+  CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  DTORS_SECTION_FUNCTION\n+\n+#define READONLY_DATA_SECTION() const_section ()\n+\n+extern void text_section ();\n+\n+#define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+const_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (!USE_CONST_SECTION)\t\t\t\t\t\t\\\n+    text_section();\t\t\t\t\t\t\t\\\n+  else if (in_section != in_const)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CONST_SECTION_ASM_OP);\t\t\\\n+      in_section = in_const;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_ctors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_dtors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Switch into a generic section.\n+ \n+   We make the section read-only and executable for a function decl,\n+   read-only for a const data decl, and writable for a non-const data decl.\n+ \n+   If the section has already been defined, we must not\n+   emit the attributes here. The SVR4 assembler does not\n+   recognize section redefinitions.\n+   If DECL is NULL, no attributes are emitted.  */\n+\n+#define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME, RELOC)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  static struct section_info\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      struct section_info *next;\t\t\t\t        \\\n+      char *name;\t\t\t\t\t\t        \\\n+      enum sect_enum {SECT_RW, SECT_RO, SECT_EXEC} type;\t\t\\\n+    } *sections;\t\t\t\t\t\t\t\\\n+  struct section_info *s;\t\t\t\t\t\t\\\n+  char *mode;\t\t\t\t\t\t\t\t\\\n+  enum sect_enum type;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  for (s = sections; s; s = s->next)\t\t\t\t\t\\\n+    if (!strcmp (NAME, s->name))\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (DECL && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n+    type = SECT_EXEC, mode = \"ax\";\t\t\t\t\t\\\n+  else if (DECL && DECL_READONLY_SECTION (DECL, RELOC))\t\t\t\\\n+    type = SECT_RO, mode = \"a\";\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    type = SECT_RW, mode = \"aw\";\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (s == 0)\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      s = (struct section_info *) xmalloc (sizeof (struct section_info));  \\\n+      s->name = xmalloc ((strlen (NAME) + 1) * sizeof (*NAME));\t\t\\\n+      strcpy (s->name, NAME);\t\t\t\t\t\t\\\n+      s->type = type;\t\t\t\t\t\t\t\\\n+      s->next = sections;\t\t\t\t\t\t\\\n+      sections = s;\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.section\\t%s,\\\"%s\\\",@progbits\\n\", NAME, mode);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (DECL && s->type != type)\t\t\t\t\t\\\n+\terror_with_decl (DECL, \"%s causes a section type conflict\");\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.section\\t%s\\n\", NAME);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)\n+#define UNIQUE_SECTION_P(DECL) (DECL_ONE_ONLY (DECL))\n+#define UNIQUE_SECTION(DECL,RELOC)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  int len;\t\t\t\t\t\t\t\\\n+  char *name, *string, *prefix;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (DECL));\t\\\n+\t\t\t\t\t\t\t\t\\\n+  if (! DECL_ONE_ONLY (DECL))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      prefix = \".\";                                             \\\n+      if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n+\tprefix = \".text.\";\t\t\t\t\t\\\n+      else if (DECL_READONLY_SECTION (DECL, RELOC))\t\t\\\n+\tprefix = \".rodata.\";\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tprefix = \".data.\";\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n+    prefix = \".gnu.linkonce.t.\";\t\t\t\t\\\n+  else if (DECL_READONLY_SECTION (DECL, RELOC))\t\t\t\\\n+    prefix = \".gnu.linkonce.r.\";\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    prefix = \".gnu.linkonce.d.\";\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  len = strlen (name) + strlen (prefix);\t\t\t\\\n+  string = alloca (len + 1);\t\t\t\t\t\\\n+  sprintf (string, \"%s%s\", prefix, name);\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  DECL_SECTION_NAME (DECL) = build_string (len, string);\t\\\n+} while (0)\n+\n+#define INT_ASM_OP \".dword\"\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global constructors.  */\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    ctors_section ();\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t P%%\", INT_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    dtors_section ();                   \t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t P%%\", INT_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);              \t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* ??? For the time being, we aren't using .ctors/.dtors sections. */\n+#undef ASM_OUTPUT_DESTRUCTOR\n+#undef ASM_OUTPUT_CONSTRUCTOR\n+\n+/* Define the strings used for the special svr4 .type and .size directives.\n+   These strings generally do not vary from one system running svr4 to\n+   another, but if a given system (e.g. m88k running svr) needs to use\n+   different pseudo-op names for these, they may be overridden in the\n+   file which includes this one.  */\n+\n+#define TYPE_ASM_OP\t\".type\"\n+#define SIZE_ASM_OP\t\".size\"\n+\n+/* This is how we tell the assembler that a symbol is weak.  */\n+\n+#define ASM_WEAKEN_LABEL(FILE,NAME) \\\n+  do { fputs (\"\\t.weak\\t\", FILE); assemble_name (FILE, NAME); \\\n+       fputc ('\\n', FILE); } while (0)\n+\n+/* The following macro defines the format used to output the second\n+   operand of the .type assembler directive.  Different svr4 assemblers\n+   expect various different forms for this operand.  The one given here\n+   is just a default.  You may need to override it in your machine-\n+   specific tm.h file (depending upon the particulars of your assembler).  */\n+\n+#define TYPE_OPERAND_FMT\t\"@%s\"\n+\n+/* Write the extra assembler code needed to declare a function's result.\n+   Most svr4 assemblers don't require any special declaration of the\n+   result value, but there are exceptions.  */\n+\n+#ifndef ASM_DECLARE_RESULT\n+#define ASM_DECLARE_RESULT(FILE, RESULT)\n+#endif"}, {"sha": "e9affa0c4b8445d51bdd93cbc2d3ece5f9bdc534", "filename": "gcc/config/pa/pa64-regs.h", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b940b3910721db1d168a99d4091a7133e04a5b2/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b940b3910721db1d168a99d4091a7133e04a5b2/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=6b940b3910721db1d168a99d4091a7133e04a5b2", "patch": "@@ -0,0 +1,291 @@\n+/* Configuration for GNU C-compiler for PA-RISC.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Standard register usage.\n+\n+   It is safe to refer to actual register numbers in this file.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   HP-PA 2.0w has 32 fullword registers and 32 floating point\n+   registers. However, the floating point registers behave\n+   differently: the left and right halves of registers are addressable\n+   as 32 bit registers.\n+\n+   Due to limitations within GCC itself, we do not expose the left/right\n+   half addressability when in wide mode.  This is not a major performance\n+   issue as using the halves independently triggers false dependency stalls\n+   anyway.  */\n+\n+#define FIRST_PSEUDO_REGISTER 61  /* 32 general regs + 28 fp regs +\n+\t\t\t\t     + 1 shift reg */\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+\n+   On the HP-PA, these are:\n+   Reg 0\t= 0 (hardware). However, 0 is used for condition code,\n+                  so is not fixed.\n+   Reg 1\t= ADDIL target/Temporary (hardware).\n+   Reg 2\t= Return Pointer\n+   Reg 3\t= Frame Pointer\n+   Reg 4\t= Frame Pointer (>8k varying frame with HP compilers only)\n+   Reg 4-18\t= Preserved Registers\n+   Reg 19\t= Linkage Table Register in HPUX 8.0 shared library scheme.\n+   Reg 20-22\t= Temporary Registers\n+   Reg 23-26\t= Temporary/Parameter Registers\n+   Reg 27\t= Global Data Pointer (hp)\n+   Reg 28\t= Temporary/???/Return Value register\n+   Reg 29\t= Temporary/Static Chain/Return Value register #2\n+   Reg 30\t= stack pointer\n+   Reg 31\t= Temporary/Millicode Return Pointer (hp)\n+\n+   Freg 0-3\t= Status Registers\t-- Not known to the compiler.\n+   Freg 4-7\t= Arguments/Return Value\n+   Freg 8-11\t= Temporary Registers\n+   Freg 12-21\t= Preserved Registers\n+   Freg 22-31 = Temporary Registers\n+\n+*/\n+\n+#define FIXED_REGISTERS  \\\n+ {0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 1, 0, 0, 1, 0, \\\n+  /* fp registers */\t  \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0,\t\t  \\\n+  /* shift register */\t  \\\n+  0}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS  \\\n+ {1, 1, 1, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  /* fp registers */\t  \\\n+  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, \t\t  \\\n+  /* shift register */    \\\n+  1}\n+\n+#define CONDITIONAL_REGISTER_USAGE \\\n+{\t\t\t\t\t\t\\\n+  if (TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)\\\n+    {\t\t\t\t\t\t\\\n+      for (i = FP_REG_FIRST; i < FP_REG_LAST; i++)\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n+    }\t\t\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n+      fixed_regs[PIC_OFFSET_TABLE_REGNUM_SAVED] = 1;\\\n+    }\t\t\t\t\t\t\\\n+}\n+\n+/* Allocate the call used registers first.  This should minimize\n+   the number of registers that need to be saved (as call used\n+   registers will generally not be allocated across a call).\n+\n+   Experimentation has shown slightly better results by allocating\n+   FP registers first.  \n+\n+   FP registers are ordered so that all L registers are selected before\n+   R registers.  This works around a false dependency interlock on the\n+   PA8000 when accessing the high and low parts of an FP register\n+   independently.  */\n+\n+#define REG_ALLOC_ORDER \\\n+ {\t\t\t\t\t\\\n+  /* caller-saved fp regs.  */\t\t\\\n+  50, 51, 52, 53, 54, 55, 56, 57,\t\\\n+  58, 59, 36, 37, 38, 39, 32, 33,\t\\\n+  34, 35,\t\t\t\t\\\n+  /* caller-saved general regs.  */\t\\\n+  19, 20, 21, 22, 23, 24, 25, 26,\t\\\n+  27, 28, 29, 31,  2,\t\t\t\\\n+  /* callee-saved fp regs.  */\t\t\\\n+  40, 41, 42, 43, 44, 45, 46, 47,\t\\\n+  48, 49,\t\t\t\t\\\n+  /* callee-saved general regs.  */\t\\\n+   3,  4,  5,  6,  7,  8,  9, 10, \t\\\n+  11, 12, 13, 14, 15, 16, 17, 18,\t\\\n+  /* special registers.  */\t\t\\\n+   1, 30,  0, 60}\n+\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   For PA64, GPRs and FPRs hold 64 bits worth (we ignore the 32bit\n+   addressability of the FPRs).  ie, we pretend each register holds\n+   precisely WORD_SIZE bits.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n+   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On the HP-PA, the cpu registers can hold any mode.  We\n+   force this to be an even register is it cannot hold the full mode.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+  ((REGNO) == 0\t\t\t\t\t\t\t\t\\\n+   ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\t\t\\\n+   /* Make wide modes be in aligned registers. */\t\t\t\\\n+   : (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD\t\t\t\t\\\n+      || GET_MODE_SIZE (MODE) <= 2 * UNITS_PER_WORD && ((REGNO) & 1) == 0))\n+\n+/* How to renumber registers for dbx and gdb.\n+\n+   Registers 0  - 31 remain unchanged.\n+\n+   Registers 32 - 60 are mapped to 72, 74, 76 ...\n+\n+   Register 88 is mapped to 32.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) \\\n+  ((REGNO) <= 31 ? (REGNO) :\t\t\t\t\t\t\\\n+   ((REGNO) > 31 && (REGNO) <= 60 ? (REGNO - 32) * 2 + 72 : 32))\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+  /* The HP-PA has four kinds of registers: general regs, 1.0 fp regs,\n+     1.1 fp regs, and the high 1.1 fp regs, to which the operands of\n+     fmpyadd and fmpysub are restricted.  */\n+\n+enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n+\t\t GENERAL_OR_FP_REGS, SHIFT_REGS, ALL_REGS, LIM_REG_CLASSES};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+  {\"NO_REGS\", \"R1_REGS\", \"GENERAL_REGS\", \"FPUPPER_REGS\", \"FP_REGS\", \\\n+   \"GENERAL_OR_FP_REGS\", \"SHIFT_REGS\", \"ALL_REGS\"}\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES. Register 0, the \"condition code\" register,\n+   is in no class. */\n+\n+#define REG_CLASS_CONTENTS\t\\\n+ {{0x00000000, 0x00000000},\t/* NO_REGS */\t\t\t\\\n+  {0x00000002, 0x00000000},\t/* R1_REGS */\t\t\t\\\n+  {0xfffffffe, 0x00000000},\t/* GENERAL_REGS */\t\t\\\n+  {0x00000000, 0x00000000},\t/* FPUPPER_REGS */\t\t\t\\\n+  {0x00000000, 0x0fffffff},\t/* FP_REGS */\t\t\t\\\n+  {0xfffffffe, 0x0fffffff},\t/* GENERAL_OR_FP_REGS */\t\\\n+  {0x00000000, 0x10000000},\t/* SHIFT_REGS */\t\t\\\n+  {0xfffffffe, 0x1fffffff}}\t/* ALL_REGS */\n+\n+/* This may not actually be necessary anymore.  But until I can prove\n+   otherwise it will stay.  */\n+#define CLASS_CANNOT_CHANGE_SIZE (FP_REGS)\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO)\t\t\t\t\t\t\\\n+  ((REGNO) == 0 ? NO_REGS \t\t\t\t\t\t\\\n+   : (REGNO) == 1 ? R1_REGS\t\t\t\t\t\t\\\n+   : (REGNO) < 32 ? GENERAL_REGS\t\t\t\t\t\\\n+   : (REGNO) < 60 ? FP_REGS\t\t\t\t\t\t\\\n+   : SHIFT_REGS)\n+\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+/* Keep 'x' for backward compatibility with user asm.   */\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'f' ? FP_REGS :\t\t\t\t\t\\\n+   (C) == 'y' ? FP_REGS :\t\t\t\t\t\\\n+   (C) == 'x' ? FP_REGS :\t\t\t\t\t\\\n+   (C) == 'q' ? SHIFT_REGS :\t\t\t\t\t\\\n+   (C) == 'a' ? R1_REGS :\t\t\t\t\t\\\n+   (C) == 'Z' ? ALL_REGS : NO_REGS)\n+\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* 1 if N is a possible register number for function argument passing.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) \\\n+  ((((N) >= 19) && (N) <= 26) \\\n+   || (! TARGET_SOFT_FLOAT && (N) >= 32 && (N) <= 39))\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"%r0\",   \"%r1\",    \"%r2\",   \"%r3\",    \"%r4\",   \"%r5\",    \"%r6\",   \"%r7\",    \\\n+ \"%r8\",   \"%r9\",    \"%r10\",  \"%r11\",   \"%r12\",  \"%r13\",   \"%r14\",  \"%r15\",   \\\n+ \"%r16\",  \"%r17\",   \"%r18\",  \"%r19\",   \"%r20\",  \"%r21\",   \"%r22\",  \"%r23\",   \\\n+ \"%r24\",  \"%r25\",   \"%r26\",  \"%r27\",   \"%r28\",  \"%r29\",   \"%r30\",  \"%r31\",   \\\n+ \"%fr4\",  \"%fr5\",   \"%fr6\",  \"%fr7\",   \"%fr8\",  \"%fr9\",   \"%fr10\", \"%fr11\",  \\\n+ \"%fr12\", \"%fr13\",  \"%fr14\", \"%fr15\",  \"%fr16\", \"%fr17\",  \"%fr18\", \"%fr19\",  \\\n+ \"%fr20\", \"%fr21\",  \"%fr22\", \"%fr23\",  \"%fr24\", \"%fr25\",  \"%fr26\", \"%fr27\",  \\\n+ \"%fr28\", \"%fr29\",  \"%fr30\", \"%fr31\", \"SAR\"}\n+\n+#define ADDITIONAL_REGISTER_NAMES \\\n+ {{\"%cr11\",88}}\n+\n+#define FP_SAVED_REG_LAST 49\n+#define FP_SAVED_REG_FIRST 40\n+#define FP_REG_STEP 1\n+#define FP_REG_FIRST 32\n+#define FP_REG_LAST 59"}, {"sha": "6201b5ba67e71efefd660677eddb0d61db97ef71", "filename": "gcc/config/pa/pa64-start.h", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b940b3910721db1d168a99d4091a7133e04a5b2/gcc%2Fconfig%2Fpa%2Fpa64-start.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b940b3910721db1d168a99d4091a7133e04a5b2/gcc%2Fconfig%2Fpa%2Fpa64-start.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-start.h?ref=6b940b3910721db1d168a99d4091a7133e04a5b2", "patch": "@@ -0,0 +1,6 @@\n+/* It is currently impossible to switch between PA32 and PA64 based on a\n+   runtime compiler switch.  So we might as well lose the overhead with\n+   checking for TARGET_64BIT.  */\n+#define TARGET_64BIT 1\n+#define TARGET_PA_11 1\n+#defien TARGET_PA_20 1"}, {"sha": "8d12d03c2ce3fd6dd5e272fae6574cd1fe908ed8", "filename": "gcc/config/pa/t-pa64", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b940b3910721db1d168a99d4091a7133e04a5b2/gcc%2Fconfig%2Fpa%2Ft-pa64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b940b3910721db1d168a99d4091a7133e04a5b2/gcc%2Fconfig%2Fpa%2Ft-pa64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Ft-pa64?ref=6b940b3910721db1d168a99d4091a7133e04a5b2", "patch": "@@ -0,0 +1,17 @@\n+LIBGCC1=libgcc1.null\n+CROSS_LIBGCC1=libgcc1.null\n+ADA_CFLAGS=-mdisable-indexing\n+LIB2FUNCS_EXTRA=quadlib.c\n+\n+TARGET_LIBGCC2_CFLAGS = -fPIC\n+\n+# We'll need this once .init sections are enabled on PA64.\n+#EXTRA_PARTS = crtbegin.o crtend.o\n+\n+# For the time being, we are using collect.\n+#USE_COLLECT2 =\n+\n+quadlib.c: $(srcdir)/config/pa/quadlib.c\n+\trm -f quadlib.c\n+\tcp $(srcdir)/config/pa/quadlib.c .\n+"}, {"sha": "d245501f8c4bd7f1e430e5701a2255023d91064f", "filename": "gcc/config/pa/xm-pa64hpux.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b940b3910721db1d168a99d4091a7133e04a5b2/gcc%2Fconfig%2Fpa%2Fxm-pa64hpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b940b3910721db1d168a99d4091a7133e04a5b2/gcc%2Fconfig%2Fpa%2Fxm-pa64hpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fxm-pa64hpux.h?ref=6b940b3910721db1d168a99d4091a7133e04a5b2", "patch": "@@ -0,0 +1,60 @@\n+/* Configuration for GNU C-compiler for PA-RISC.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+/* HP-UX is a flavor of System V */\n+#define USG\n+\n+/* Use System V memory functions.  */\n+/* #defines that need visibility everywhere.  */\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR 8\n+#define HOST_BITS_PER_SHORT 16\n+#define HOST_BITS_PER_INT 32\n+#define HOST_BITS_PER_LONG 64\n+#define HOST_BITS_PER_LONGLONG 64\n+\n+/* Doubles are stored in memory with the high order word first.  This\n+   matters when cross-compiling.  */\n+#define HOST_WORDS_BIG_ENDIAN 1\n+\n+/* Place any machine-dependent include files here, in case we\n+   are bootstrapping.  */\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.   */\n+#include \"tm.h\"\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33\n+\n+/* Don't try to use sys_siglist.  */\n+#define NO_SYS_SIGLIST\n+\n+/* HP's compiler has problems with enum bitfields.  */\n+#define ONLY_INT_FIELDS\n+\n+/* Always claim to use C alloca; this prevents losing if building with\n+   gcc -fno-builtin ...  */\n+#define USE_C_ALLOCA"}]}