{"sha": "dda0439880fee40a90309ed74446c29a3ca08a05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRhMDQzOTg4MGZlZTQwYTkwMzA5ZWQ3NDQ0NmMyOWEzY2EwOGEwNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-03-31T17:36:17Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-03-31T17:36:17Z"}, "message": "PR c++/19203, implement DR 214\n\ncp:\n\tPR c++/19203, implement DR 214\n\t* call.c (joust): Use more_specialized_fn.\n\t* cp-tree.h (DEDUCE_ORDER): Remove.\n\t(more_specialized): Replace with ...\n\t(more_specialized_fn): ... this.\n\t* pt.c (maybe_adjust_types_for_deduction): Remove DEDUCE_ORDER\n\tcase.\n\t(type_unification_real): Remove DEDUCE_ORDER case.\n\t(more_specialized): Replace with ...\n\t(more_specialized_fn): ... this.  Implement DR 214.\n\t(most_specialized_instantiation): Use get_bindings_real directly.\ntestsuite:\n\tPR c++/19203, DR 214\n\t* g++.dg/parse/ambig3.C: Not ambiguous.\n\t* g++.dg/template/spec20.C: New.\n\t* g++.dg/template/spec21.C: New.\n\nFrom-SVN: r97336", "tree": {"sha": "5ecfece501acdb1b2be881d9444e863d74730ab4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ecfece501acdb1b2be881d9444e863d74730ab4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dda0439880fee40a90309ed74446c29a3ca08a05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dda0439880fee40a90309ed74446c29a3ca08a05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dda0439880fee40a90309ed74446c29a3ca08a05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dda0439880fee40a90309ed74446c29a3ca08a05/comments", "author": null, "committer": null, "parents": [{"sha": "27954bdbc3051fbf6adfdc8675fa33f36da7c292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27954bdbc3051fbf6adfdc8675fa33f36da7c292", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27954bdbc3051fbf6adfdc8675fa33f36da7c292"}], "stats": {"total": 352, "additions": 269, "deletions": 83}, "files": [{"sha": "93c7170f342d156f2824c67eee8a3437d35c5f3b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dda0439880fee40a90309ed74446c29a3ca08a05", "patch": "@@ -1,3 +1,17 @@\n+2005-03-31  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/19203, implement DR 214\n+\t* call.c (joust): Use more_specialized_fn.\n+\t* cp-tree.h (DEDUCE_ORDER): Remove.\n+\t(more_specialized): Replace with ...\n+\t(more_specialized_fn): ... this.\n+\t* pt.c (maybe_adjust_types_for_deduction): Remove DEDUCE_ORDER\n+\tcase.\n+\t(type_unification_real): Remove DEDUCE_ORDER case.\n+\t(more_specialized): Replace with ...\n+\t(more_specialized_fn): ... this.  Implement DR 214.\n+\t(most_specialized_instantiation): Use get_bindings_real directly.\n+\n 2005-03-31  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \tPR c++/18644"}, {"sha": "9d76276cfffae310d74c329d143213e8fb743edd", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=dda0439880fee40a90309ed74446c29a3ca08a05", "patch": "@@ -6084,10 +6084,9 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n   \n   if (cand1->template_decl && cand2->template_decl)\n     {\n-      winner = more_specialized\n+      winner = more_specialized_fn\n         (TI_TEMPLATE (cand1->template_decl),\n          TI_TEMPLATE (cand2->template_decl),\n-         DEDUCE_ORDER,\n          /* Tell the deduction code how many real function arguments\n \t    we saw, not counting the implicit 'this' argument.  But,\n \t    add_function_candidate() suppresses the \"this\" argument"}, {"sha": "7f4efc393fd21a736780e863da8f03196f4b1820", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=dda0439880fee40a90309ed74446c29a3ca08a05", "patch": "@@ -3112,8 +3112,7 @@ extern int function_depth;\n typedef enum unification_kind_t {\n   DEDUCE_CALL,\n   DEDUCE_CONV,\n-  DEDUCE_EXACT,\n-  DEDUCE_ORDER\n+  DEDUCE_EXACT\n } unification_kind_t;\n \n /* Macros for operating on a template instantiation level node.  */\n@@ -3998,7 +3997,7 @@ extern tree instantiate_class_template\t\t(tree);\n extern tree instantiate_template\t\t(tree, tree, tsubst_flags_t);\n extern int fn_type_unification                  (tree, tree, tree, tree, tree, unification_kind_t, int);\n extern void mark_decl_instantiated\t\t(tree, int);\n-extern int more_specialized\t\t\t(tree, tree, int, int);\n+extern int more_specialized_fn\t\t\t(tree, tree, int);\n extern void mark_class_instantiated\t\t(tree, int);\n extern void do_decl_instantiation\t\t(tree, tree);\n extern void do_type_instantiation\t\t(tree, tree, tsubst_flags_t);"}, {"sha": "b80faaeb68cd27f20c03c86bf3b96a968d2d5d4a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 186, "deletions": 75, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=dda0439880fee40a90309ed74446c29a3ca08a05", "patch": "@@ -9064,11 +9064,6 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n      as in [temp.expl.spec], or when taking the address of a function\n      template, as in [temp.deduct.funcaddr]. \n \n-   DEDUCE_ORDER:\n-     We are deducing arguments when calculating the partial\n-     ordering between specializations of function or class\n-     templates, as in [temp.func.order] and [temp.class.order].\n-\n    LEN is the number of parms to consider before returning success, or -1\n    for all.  This is used in partial ordering to avoid comparing parms for\n    which no actual argument was passed, since they are not considered in\n@@ -9216,28 +9211,6 @@ maybe_adjust_types_for_deduction (unification_kind_t strict,\n       /* There is nothing to do in this case.  */\n       return 0;\n \n-    case DEDUCE_ORDER:\n-      /* DR 214. [temp.func.order] is underspecified, and leads to no\n-         ordering between things like `T *' and `T const &' for `U *'.\n-         The former has T=U and the latter T=U*. The former looks more\n-         specialized and John Spicer considers it well-formed (the EDG\n-         compiler accepts it).\n-\n-         John also confirms that deduction should proceed as in a function\n-         call. Which implies the usual ARG and PARM conversions as DEDUCE_CALL.\n-         However, in ordering, ARG can have REFERENCE_TYPE, but no argument\n-         to an actual call can have such a type.\n-         \n-         If both ARG and PARM are REFERENCE_TYPE, we change neither.\n-         If only ARG is a REFERENCE_TYPE, we look through that and then\n-         proceed as with DEDUCE_CALL (which could further convert it).  */\n-      if (TREE_CODE (*arg) == REFERENCE_TYPE)\n-        {\n-          if (TREE_CODE (*parm) == REFERENCE_TYPE)\n-            return 0;\n-          *arg = TREE_TYPE (*arg);\n-        }\n-      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -9333,10 +9306,6 @@ type_unification_real (tree tparms,\n       sub_strict = UNIFY_ALLOW_NONE;\n       break;\n     \n-    case DEDUCE_ORDER:\n-      sub_strict = UNIFY_ALLOW_NONE;\n-      break;\n-      \n     default:\n       gcc_unreachable ();\n     }\n@@ -9379,7 +9348,7 @@ type_unification_real (tree tparms,\n \t  else\n \t    type = arg;\n \n-\t  if (strict == DEDUCE_EXACT || strict == DEDUCE_ORDER)\n+\t  if (strict == DEDUCE_EXACT)\n \t    {\n \t      if (same_type_p (parm, type))\n \t\tcontinue;\n@@ -10426,36 +10395,158 @@ mark_decl_instantiated (tree result, int extern_p)\n \n /* Given two function templates PAT1 and PAT2, return:\n \n-   DEDUCE should be DEDUCE_EXACT or DEDUCE_ORDER.\n-   \n    1 if PAT1 is more specialized than PAT2 as described in [temp.func.order].\n    -1 if PAT2 is more specialized than PAT1.\n    0 if neither is more specialized.\n \n-   LEN is passed through to fn_type_unification.  */\n+   LEN indicates the number of parameters we should consider\n+   (defaulted parameters should not be considered).\n+\n+   The 1998 std underspecified function template partial ordering, and\n+   DR214 addresses the issue.  We take pairs of arguments, one from\n+   each of the templates, and deduce them against eachother.  One of\n+   the templates will be more specialized if all the *other*\n+   template's arguments deduce against its arguments and at least one\n+   of its arguments *does* *not* deduce against the other template's\n+   corresponding argument.  Deduction is done as for class templates.\n+   The arguments used in deduction have reference and top level cv\n+   qualifiers removed.  Iff both arguments were originally reference\n+   types *and* deduction succeeds in both directions, the template\n+   with the more cv-qualified argument wins for that pairing (if\n+   neither is more cv-qualified, they both are equal).  Unlike regular\n+   deduction, after all the arguments have been deduced in this way,\n+   we do *not* verify the deduced template argument values can be\n+   substituted into non-deduced contexts, nor do we have to verify\n+   that all template arguments have been deduced.  */\n    \n int\n-more_specialized (tree pat1, tree pat2, int deduce, int len)\n-{\n-  tree targs;\n-  int winner = 0;\n+more_specialized_fn (tree pat1, tree pat2, int len)\n+{\n+  tree decl1 = DECL_TEMPLATE_RESULT (pat1);\n+  tree decl2 = DECL_TEMPLATE_RESULT (pat2);\n+  tree targs1 = make_tree_vec (DECL_NTPARMS (pat1));\n+  tree targs2 = make_tree_vec (DECL_NTPARMS (pat2));\n+  tree tparms1 = DECL_INNERMOST_TEMPLATE_PARMS (pat1);\n+  tree tparms2 = DECL_INNERMOST_TEMPLATE_PARMS (pat2);\n+  tree args1 = TYPE_ARG_TYPES (TREE_TYPE (decl1));\n+  tree args2 = TYPE_ARG_TYPES (TREE_TYPE (decl2));\n+  int better1 = 0;\n+  int better2 = 0;\n+\n+  /* Don't consider 'this' parameter.  */\n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (decl1))\n+    args1 = TREE_CHAIN (args1);\n+  \n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (decl2))\n+    args2 = TREE_CHAIN (args2);\n \n-  /* If template argument deduction succeeds, we substitute the\n-     resulting arguments into non-deduced contexts.  While doing that,\n-     we must be aware that we may encounter dependent types.  */\n-  ++processing_template_decl;\n-  targs = get_bindings_real (pat1, DECL_TEMPLATE_RESULT (pat2),\n-                             NULL_TREE, 0, deduce, len);\n-  if (targs)\n-    --winner;\n+  /* Consider the return type for a conversion function */\n+  if (DECL_CONV_FN_P (decl1))\n+    {\n+      gcc_assert (DECL_CONV_FN_P (decl2));\n+      args1 = tree_cons (NULL_TREE, TREE_TYPE (TREE_TYPE (decl1)), args1);\n+      args2 = tree_cons (NULL_TREE, TREE_TYPE (TREE_TYPE (decl2)), args2);\n+      len++;\n+    }\n+  \n+  processing_template_decl++;\n+  \n+  while (len--)\n+    {\n+      tree arg1 = TREE_VALUE (args1);\n+      tree arg2 = TREE_VALUE (args2);\n+      int deduce1, deduce2;\n+      int quals1 = -1;\n+      int quals2 = -1;\n \n-  targs = get_bindings_real (pat2, DECL_TEMPLATE_RESULT (pat1),\n-                             NULL_TREE, 0, deduce, len);\n-  if (targs)\n-    ++winner;\n-  --processing_template_decl;\n+      if (TREE_CODE (arg1) == REFERENCE_TYPE)\n+\t{\n+\t  arg1 = TREE_TYPE (arg1);\n+\t  quals1 = cp_type_quals (arg1);\n+\t}\n+      \n+      if (TREE_CODE (arg2) == REFERENCE_TYPE)\n+\t{\n+\t  arg2 = TREE_TYPE (arg2);\n+\t  quals2 = cp_type_quals (arg2);\n+\t}\n \n-  return winner;\n+      if ((quals1 < 0) != (quals2 < 0))\n+\t{\n+\t  /* Only of the args is a reference, see if we should apply\n+\t     array/function pointer decay to it.  This is not part of\n+\t     DR214, but is, IMHO, consistent with the deduction rules\n+\t     for the function call itself, and with our earlier\n+\t     implementation of the underspecified partial ordering\n+\t     rules.  (nathan).  */\n+\t  if (quals1 >= 0)\n+\t    {\n+\t      switch (TREE_CODE (arg1))\n+\t\t{\n+\t\tcase ARRAY_TYPE:\n+\t\t  arg1 = TREE_TYPE (arg1);\n+\t\t  /* FALLTHROUGH. */\n+\t\tcase FUNCTION_TYPE:\n+\t\t  arg1 = build_pointer_type (arg1);\n+\t\t  break;\n+\t\t  \n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      switch (TREE_CODE (arg2))\n+\t\t{\n+\t\tcase ARRAY_TYPE:\n+\t\t  arg2 = TREE_TYPE (arg2);\n+\t\t  /* FALLTHROUGH. */\n+\t\tcase FUNCTION_TYPE:\n+\t\t  arg2 = build_pointer_type (arg2);\n+\t\t  break;\n+\t\t  \n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      \n+      arg1 = TYPE_MAIN_VARIANT (arg1);\n+      arg2 = TYPE_MAIN_VARIANT (arg2);\n+      \n+      deduce1 = !unify (tparms1, targs1, arg1, arg2, UNIFY_ALLOW_NONE);\n+      deduce2 = !unify (tparms2, targs2, arg2, arg1, UNIFY_ALLOW_NONE);\n+\n+      if (!deduce1)\n+\tbetter2 = -1;\n+      if (!deduce2)\n+\tbetter1 = -1;\n+      if (better1 < 0 && better2 < 0)\n+\t/* We've failed to deduce something in either direction.\n+\t   These must be unordered.  */\n+\tbreak;\n+      \n+      if (deduce1 && deduce2 && quals1 >= 0 && quals2 >= 0)\n+\t{\n+\t  /* Deduces in both directions, see if quals can\n+\t     disambiguate.  Pretend the worse one failed to deduce. */\n+\t  if ((quals1 & quals2) == quals2)\n+\t    deduce1 = 0;\n+\t  if ((quals1 & quals2) == quals1)\n+\t    deduce2 = 0;\n+\t}\n+      if (deduce1 && !deduce2 && !better2)\n+\tbetter2 = 1;\n+      if (deduce2 && !deduce1 && !better1)\n+\tbetter1 = 1;\n+      \n+      args1 = TREE_CHAIN (args1);\n+      args2 = TREE_CHAIN (args2);\n+    }\n+\n+  processing_template_decl--;\n+\n+  return (better1 > 0) - (better2 > 0);\n }\n \n /* Given two class template specialization list nodes PAT1 and PAT2, return:\n@@ -10619,37 +10710,56 @@ tree\n most_specialized_instantiation (tree instantiations)\n {\n   tree fn, champ;\n-  int fate;\n \n   if (!instantiations)\n     return NULL_TREE;\n-\n+  \n+  ++processing_template_decl;\n+  \n   champ = instantiations;\n   for (fn = TREE_CHAIN (instantiations); fn; fn = TREE_CHAIN (fn))\n     {\n-      fate = more_specialized (TREE_VALUE (champ), TREE_VALUE (fn),\n-                               DEDUCE_EXACT, -1);\n-      if (fate == 1)\n-\t;\n-      else\n+      int fate = 0;\n+      \n+      if (get_bindings_real (TREE_VALUE (champ),\n+\t\t\t     DECL_TEMPLATE_RESULT (TREE_VALUE (fn)),\n+\t\t\t     NULL_TREE, 0, DEDUCE_EXACT, -1))\n+\tfate--;\n+\n+      if (get_bindings_real (TREE_VALUE (fn),\n+\t\t\t     DECL_TEMPLATE_RESULT (TREE_VALUE (champ)),\n+\t\t\t     NULL_TREE, 0, DEDUCE_EXACT, -1))\n+\tfate++;\n+      \n+      if (fate != 1)\n \t{\n-\t  if (fate == 0)\n-\t    {\n-\t      fn = TREE_CHAIN (fn);\n-\t      if (! fn)\n-\t\treturn error_mark_node;\n-\t    }\n+\t  if (!fate)\n+\t    /* Equally specialized, move to next function.  If there\n+\t       is no next function, nothing's most specialized.  */\n+\t    fn = TREE_CHAIN (fn);\n \t  champ = fn;\n \t}\n     }\n-\n-  for (fn = instantiations; fn && fn != champ; fn = TREE_CHAIN (fn))\n-    {\n-      fate = more_specialized (TREE_VALUE (champ), TREE_VALUE (fn),\n-                               DEDUCE_EXACT, -1);\n-      if (fate != 1)\n-\treturn error_mark_node;\n-    }\n+  \n+  if (champ)\n+    /* Now verify that champ is better than everything earlier in the\n+       instantiation list.  */\n+    for (fn = instantiations; fn != champ; fn = TREE_CHAIN (fn))\n+      if (get_bindings_real (TREE_VALUE (champ),\n+\t\t\t     DECL_TEMPLATE_RESULT (TREE_VALUE (fn)),\n+\t\t\t     NULL_TREE, 0, DEDUCE_EXACT, -1)\n+\t  || !get_bindings_real (TREE_VALUE (fn),\n+\t\t\t\t DECL_TEMPLATE_RESULT (TREE_VALUE (champ)),\n+\t\t\t\t NULL_TREE, 0, DEDUCE_EXACT, -1))\n+\t{\n+\t  champ = NULL_TREE;\n+\t  break;\n+\t}\n+  \n+  processing_template_decl--;\n+  \n+  if (!champ)\n+    return error_mark_node;\n \n   return TREE_PURPOSE (champ) ? TREE_PURPOSE (champ) : TREE_VALUE (champ);\n }\n@@ -12333,7 +12443,8 @@ dependent_template_id_p (tree tmpl, tree args)\n    TYPENAME_TYPE corresponds.  Returns ERROR_MARK_NODE if no such TYPE\n    can be found.  Note that this function peers inside uninstantiated\n    templates and therefore should be used only in extremely limited\n-   situations.  */\n+   situations.  ONLY_CURRENT_P restricts this peering to the currently\n+   open classes heirarchy (which is required when comparing types).  */\n \n tree\n resolve_typename_type (tree type, bool only_current_p)"}, {"sha": "afa03d5dec2ae7c65d27f122c37842a94b98085d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dda0439880fee40a90309ed74446c29a3ca08a05", "patch": "@@ -1,3 +1,10 @@\n+2005-03-31  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/19203, DR 214\n+\t* g++.dg/parse/ambig3.C: Not ambiguous.\n+\t* g++.dg/template/spec20.C: New.\n+\t* g++.dg/template/spec21.C: New.\n+\n 2005-03-31  Steve Ellcey  <sje@cup.hp.com>\n \n \tPR target/20045"}, {"sha": "41390710f803af6466eb3e5e2e8c6b01b2b38db4", "filename": "gcc/testsuite/g++.dg/parse/ambig3.C", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig3.C?ref=dda0439880fee40a90309ed74446c29a3ca08a05", "patch": "@@ -5,8 +5,17 @@\n template <int> struct A { static const int i = 1; };\n template <int> struct B {};\n \n-template <typename> void foo(B<0>) {} // { dg-error \"\" }\n+template <typename> int foo(B<0>)\n+{\n+  return 0;\n+} \n \n-template <typename, int j> B<A<j>::i-1> foo(B<j>) { return B<0>(); } // { dg-error \"\" }\n+template <typename, int j> B<A<j>::i-1> foo(B<j>)\n+{\n+  return B<0>();\n+} \n \n-void bar() { foo<int>(B<0>()); } // { dg-error \"ambiguous\" }\n+int main()\n+{\n+  return foo<int>(B<0>());\n+} "}, {"sha": "71548e4af9bca458c8d8fea2e40c7c16909e4c4f", "filename": "gcc/testsuite/g++.dg/template/spec20.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec20.C?ref=dda0439880fee40a90309ed74446c29a3ca08a05", "patch": "@@ -0,0 +1,19 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 31 Mar 2005 <nathan@codesourcery.com>\n+\n+// Origin: Giovanni Bajo <giovannibajo@libero.it>\n+// Bug 19203: Failure to implement DR 214\n+\n+template <class A>\n+void foo(const A& a);\n+\n+template <class RET, class ARG1>\n+int foo(RET (&)(ARG1)); // this one\n+\n+\n+float decl(int);\n+\n+int bar(void)\n+{\n+  return foo(decl);\n+}"}, {"sha": "e04ac5a2da9484d8694f15fb500d85ca954329c8", "filename": "gcc/testsuite/g++.dg/template/spec21.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda0439880fee40a90309ed74446c29a3ca08a05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec21.C?ref=dda0439880fee40a90309ed74446c29a3ca08a05", "patch": "@@ -0,0 +1,28 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 31 Mar 2005 <nathan@codesourcery.com>\n+\n+// { dg-do run }\n+// DR214\n+\n+template <class T> T f(int) {return 0;}\n+template <class T, class U> T f(U){return 1;}\n+\n+template <typename T, typename R> T checked_cast (R const &) {return 0;}\n+template <typename T, typename R> T checked_cast (R *) {return 1;}\n+\n+\n+int main ()\n+{\n+  int i = 0;\n+\n+  if (f<int>(1))\n+    return 1;\n+  \n+  if (checked_cast<int>(i) != 0)\n+    return 2;\n+\n+  if (checked_cast<int>(&i) != 1)\n+    return 3;\n+\n+  return 0;\n+}"}]}