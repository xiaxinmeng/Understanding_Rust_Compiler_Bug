{"sha": "5fd1486ce58297190c2b924e96e716087139a8b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZkMTQ4NmNlNTgyOTcxOTBjMmI5MjRlOTZlNzE2MDg3MTM5YThiNQ==", "commit": {"author": {"name": "Pekka J\u00e4\u00e4skel\u00e4inen", "email": "pekka@parmance.com", "date": "2017-01-24T12:45:56Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2017-01-24T12:45:56Z"}, "message": "Brig front-end\n\n2017-01-24  Pekka J\u00e4\u00e4skel\u00e4inen <pekka@parmance.com>\n\t    Martin Jambor  <mjambor@suse.cz>\n\n\t* Makefile.def (target_modules): Added libhsail-rt.\n\t(languages): Added language brig.\n\t* Makefile.in: Regenerated.\n\t* configure.ac (TOPLEVEL_CONFIGURE_ARGUMENTS): Added\n\ttgarget-libhsail-rt.  Make brig unsupported on untested architectures.\n\t* configure: Regenerated.\n\ngcc/\n\t* brig-builtins.def: New file.\n\t* builtins.def (DEF_HSAIL_BUILTIN): New macro.\n\t(DEF_HSAIL_ATOMIC_BUILTIN): Likewise.\n\t(DEF_HSAIL_SAT_BUILTIN): Likewise.\n\t(DEF_HSAIL_INTR_BUILTIN): Likewise.\n\t(DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN): Likewise.\n\t* builtin-types.def (BT_INT8): New.\n\t(BT_INT16): Likewise.\n\t(BT_UINT8): Likewise.\n\t(BT_UINT16): Likewise.\n\t(BT_FN_ULONG): Likewise.\n\t(BT_FN_UINT_INT): Likewise.\n\t(BT_FN_UINT_ULONG): Likewise.\n\t(BT_FN_UINT_LONG): Likewise.\n\t(BT_FN_UINT_PTR): Likewise.\n\t(BT_FN_ULONG_PTR): Likewise.\n\t(BT_FN_INT8_FLOAT): Likewise.\n\t(BT_FN_INT16_FLOAT): Likewise.\n\t(BT_FN_UINT32_FLOAT): Likewise.\n\t(BT_FN_UINT16_FLOAT): Likewise.\n\t(BT_FN_UINT8_FLOAT): Likewise.\n\t(BT_FN_UINT64_FLOAT): Likewise.\n\t(BT_FN_UINT16_UINT32): Likewise.\n\t(BT_FN_UINT32_UINT16): Likewise.\n\t(BT_FN_UINT16_UINT16_UINT16): Likewise.\n\t(BT_FN_INT_PTR_INT): Likewise.\n\t(BT_FN_UINT_PTR_UINT): Likewise.\n\t(BT_FN_LONG_PTR_LONG): Likewise.\n\t(BT_FN_ULONG_PTR_ULONG): Likewise.\n\t(BT_FN_VOID_UINT64_UINT64): Likewise.\n\t(BT_FN_UINT8_UINT8_UINT8): Likewise.\n\t(BT_FN_INT8_INT8_INT8): Likewise.\n\t(BT_FN_INT16_INT16_INT16): Likewise.\n\t(BT_FN_INT_INT_INT): Likewise.\n\t(BT_FN_UINT_FLOAT_UINT): Likewise.\n\t(BT_FN_FLOAT_UINT_UINT): Likewise.\n\t(BT_FN_ULONG_UINT_UINT): Likewise.\n\t(BT_FN_ULONG_UINT_PTR): Likewise.\n\t(BT_FN_ULONG_ULONG_ULONG): Likewise.\n\t(BT_FN_UINT_UINT_UINT): Likewise.\n\t(BT_FN_VOID_UINT_PTR): Likewise.\n\t(BT_FN_UINT_UINT_PTR: Likewise.\n\t(BT_FN_UINT32_UINT64_PTR): Likewise.\n\t(BT_FN_INT_INT_UINT_UINT): Likewise.\n\t(BT_FN_UINT_UINT_UINT_UINT): Likewise.\n\t(BT_FN_UINT_UINT_UINT_PTR): Likewise.\n\t(BT_FN_UINT_ULONG_ULONG_UINT): Likewise.\n\t(BT_FN_ULONG_ULONG_ULONG_ULONG): Likewise.\n\t(BT_FN_LONG_LONG_UINT_UINT): Likewise.\n\t(BT_FN_ULONG_ULONG_UINT_UINT): Likewise.\n\t(BT_FN_VOID_UINT32_UINT64_PTR): Likewise.\n\t(BT_FN_VOID_UINT32_UINT32_PTR): Likewise.\n\t(BT_FN_UINT_UINT_UINT_UINT_UINT): Likewise.\n\t(BT_FN_UINT_FLOAT_FLOAT_FLOAT_FLOAT): Likewise.\n\t(BT_FN_ULONG_ULONG_ULONG_UINT_UINT): Likewise.\n\t* doc/frontends.texi: List BRIG FE.\n\t* doc/install.texi (Testing): Add BRIG tesring requirements.\n\t* doc/invoke.texi (Overall Options): Mention BRIG.\n\t* doc/standards.texi (Standards): Doucment BRIG HSA version.\n\ngcc/brig/\n\n\t* Make-lang.in: New file.\n\t* brig-builtins.h: Likewise.\n\t* brig-c.h: Likewise.\n\t* brig-lang.c: Likewise.\n\t* brigspec.c: Likewise.\n\t* config-lang.in: Likewise.\n\t* lang-specs.h: Likewise.\n\t* lang.opt: Likewise.\n\t* brigfrontend/brig-arg-block-handler.cc: Likewise.\n\t* brigfrontend/brig-atomic-inst-handler.cc: Likewise.\n\t* brigfrontend/brig-basic-inst-handler.cc: Likewise.\n\t* brigfrontend/brig-branch-inst-handler.cc: Likewise.\n\t* brigfrontend/brig-cmp-inst-handler.cc: Likewise.\n\t* brigfrontend/brig-code-entry-handler.cc: Likewise.\n\t* brigfrontend/brig-code-entry-handler.h: Likewise.\n\t* brigfrontend/brig-comment-handler.cc: Likewise.\n\t* brigfrontend/brig-control-handler.cc: Likewise.\n\t* brigfrontend/brig-copy-move-inst-handler.cc: Likewise.\n\t* brigfrontend/brig-cvt-inst-handler.cc: Likewise.\n\t* brigfrontend/brig-fbarrier-handler.cc: Likewise.\n\t* brigfrontend/brig-function-handler.cc: Likewise.\n\t* brigfrontend/brig-function.cc: Likewise.\n\t* brigfrontend/brig-function.h: Likewise.\n\t* brigfrontend/brig-inst-mod-handler.cc: Likewise.\n\t* brigfrontend/brig-label-handler.cc: Likewise.\n\t* brigfrontend/brig-lane-inst-handler.cc: Likewise.\n\t* brigfrontend/brig-machine.c: Likewise.\n\t* brigfrontend/brig-machine.h: Likewise.\n\t* brigfrontend/brig-mem-inst-handler.cc: Likewise.\n\t* brigfrontend/brig-module-handler.cc: Likewise.\n\t* brigfrontend/brig-queue-inst-handler.cc: Likewise.\n\t* brigfrontend/brig-seg-inst-handler.cc: Likewise.\n\t* brigfrontend/brig-signal-inst-handler.cc: Likewise.\n\t* brigfrontend/brig-to-generic.cc: Likewise.\n\t* brigfrontend/brig-to-generic.h: Likewise.\n\t* brigfrontend/brig-util.cc: Likewise.\n\t* brigfrontend/brig-util.h: Likewise.\n\t* brigfrontend/brig-variable-handler.cc: Likewise.\n\t* brigfrontend/phsa.h: Likewise.\n\n\ngcc/testsuite/\n\n\t* lib/brig-dg.exp: New file.\n\t* lib/brig.exp: Likewise.\n\t* brig.dg/README: Likewise.\n\t* brig.dg/dg.exp: Likewise.\n\t* brig.dg/test/gimple/alloca.hsail: Likewise.\n\t* brig.dg/test/gimple/atomics.hsail: Likewise.\n\t* brig.dg/test/gimple/branches.hsail: Likewise.\n\t* brig.dg/test/gimple/fbarrier.hsail: Likewise.\n\t* brig.dg/test/gimple/function_calls.hsail: Likewise.\n\t* brig.dg/test/gimple/kernarg.hsail: Likewise.\n\t* brig.dg/test/gimple/mem.hsail: Likewise.\n\t* brig.dg/test/gimple/mulhi.hsail: Likewise.\n\t* brig.dg/test/gimple/packed.hsail: Likewise.\n\t* brig.dg/test/gimple/smoke_test.hsail: Likewise.\n\t* brig.dg/test/gimple/variables.hsail: Likewise.\n\t* brig.dg/test/gimple/vector.hsail: Likewise.\n\ninclude/\n\n\t* hsa.h: Moved here from libgomp/plugin/hsa.h.\n\nlibgomp/\n\n\t* plugin/hsa.h: Moved to top level include.\n\t* plugin/plugin-hsa.c: Chanfgd include of hsa.h accordingly.\n\nlibhsail-rt/\n\n\t* Makefile.am: New file.\n\t* target-config.h.in: Likewise.\n\t* configure.ac: Likewise.\n\t* configure: Likewise.\n\t* config.h.in: Likewise.\n\t* aclocal.m4: Likewise.\n\t* README: Likewise.\n\t* Makefile.in: Likewise.\n\t* include/internal/fibers.h: Likewise.\n\t* include/internal/phsa-queue-interface.h: Likewise.\n\t* include/internal/phsa-rt.h: Likewise.\n\t* include/internal/workitems.h: Likewise.\n\t* rt/arithmetic.c: Likewise.\n\t* rt/atomics.c: Likewise.\n\t* rt/bitstring.c: Likewise.\n\t* rt/fbarrier.c: Likewise.\n\t* rt/fibers.c: Likewise.\n\t* rt/fp16.c: Likewise.\n\t* rt/misc.c: Likewise.\n\t* rt/multimedia.c: Likewise.\n\t* rt/queue.c: Likewise.\n\t* rt/sat_arithmetic.c: Likewise.\n\t* rt/segment.c: Likewise.\n\t* rt/workitems.c: Likewise.\n\n\nCo-Authored-By: Martin Jambor <mjambor@suse.cz>\n\nFrom-SVN: r244867", "tree": {"sha": "80abae8778b2f25cc8bf5960402f20f16e4e7a8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80abae8778b2f25cc8bf5960402f20f16e4e7a8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fd1486ce58297190c2b924e96e716087139a8b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd1486ce58297190c2b924e96e716087139a8b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fd1486ce58297190c2b924e96e716087139a8b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd1486ce58297190c2b924e96e716087139a8b5/comments", "author": null, "committer": null, "parents": [{"sha": "e1e41b6f10c76dbdc8bfd2d4a345dffefd45968f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1e41b6f10c76dbdc8bfd2d4a345dffefd45968f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1e41b6f10c76dbdc8bfd2d4a345dffefd45968f"}], "stats": {"total": 34465, "additions": 34461, "deletions": 4}, "files": [{"sha": "9695f9d85d14c0b46b007660781048dcba2b25b6", "filename": "ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -1,3 +1,14 @@\n+2017-01-24  Pekka J\u00e4\u00e4skel\u00e4inen <pekka@parmance.com>\n+\t    Martin Jambor  <mjambor@suse.cz>\n+\n+\n+\t* Makefile.def (target_modules): Added libhsail-rt.\n+\t(languages): Added language brig.\n+\t* Makefile.in: Regenerated.\n+\t* configure.ac (TOPLEVEL_CONFIGURE_ARGUMENTS): Added\n+\ttgarget-libhsail-rt.  Make brig unsupported on untested architectures.\n+\t* configure: Regenerated.\n+\n 2017-01-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/78478"}, {"sha": "799b7ca5283678b13a4f86aa63c4fdcc540422ce", "filename": "Makefile.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -157,6 +157,7 @@ target_modules = { module= libquadmath; };\n target_modules = { module= libgfortran; };\n target_modules = { module= libobjc; };\n target_modules = { module= libgo; };\n+target_modules = { module= libhsail-rt; };\n target_modules = { module= libtermcap; no_check=true;\n                    missing=mostlyclean;\n                    missing=clean;\n@@ -601,6 +602,8 @@ languages = { language=objc;\tgcc-check-target=check-objc;\n languages = { language=obj-c++;\tgcc-check-target=check-obj-c++; };\n languages = { language=go;\tgcc-check-target=check-go;\n \t\t\t\tlib-check-target=check-target-libgo; };\n+languages = { language=brig;\tgcc-check-target=check-brig;\n+\t\t\t\tlib-check-target=check-target-libhsail-rt; };\n \n // Toplevel bootstrap\n bootstrap_stage = { id=1 ; };"}, {"sha": "1c0b9e7cdda9d72087d7d4b7ecc97261b83b2a80", "filename": "Makefile.in", "status": "modified", "additions": 489, "deletions": 0, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -993,6 +993,7 @@ configure-target:  \\\n     maybe-configure-target-libgfortran \\\n     maybe-configure-target-libobjc \\\n     maybe-configure-target-libgo \\\n+    maybe-configure-target-libhsail-rt \\\n     maybe-configure-target-libtermcap \\\n     maybe-configure-target-winsup \\\n     maybe-configure-target-libgloss \\\n@@ -1158,6 +1159,7 @@ all-target: maybe-all-target-libquadmath\n all-target: maybe-all-target-libgfortran\n all-target: maybe-all-target-libobjc\n all-target: maybe-all-target-libgo\n+all-target: maybe-all-target-libhsail-rt\n all-target: maybe-all-target-libtermcap\n all-target: maybe-all-target-winsup\n all-target: maybe-all-target-libgloss\n@@ -1250,6 +1252,7 @@ info-target: maybe-info-target-libquadmath\n info-target: maybe-info-target-libgfortran\n info-target: maybe-info-target-libobjc\n info-target: maybe-info-target-libgo\n+info-target: maybe-info-target-libhsail-rt\n info-target: maybe-info-target-libtermcap\n info-target: maybe-info-target-winsup\n info-target: maybe-info-target-libgloss\n@@ -1335,6 +1338,7 @@ dvi-target: maybe-dvi-target-libquadmath\n dvi-target: maybe-dvi-target-libgfortran\n dvi-target: maybe-dvi-target-libobjc\n dvi-target: maybe-dvi-target-libgo\n+dvi-target: maybe-dvi-target-libhsail-rt\n dvi-target: maybe-dvi-target-libtermcap\n dvi-target: maybe-dvi-target-winsup\n dvi-target: maybe-dvi-target-libgloss\n@@ -1420,6 +1424,7 @@ pdf-target: maybe-pdf-target-libquadmath\n pdf-target: maybe-pdf-target-libgfortran\n pdf-target: maybe-pdf-target-libobjc\n pdf-target: maybe-pdf-target-libgo\n+pdf-target: maybe-pdf-target-libhsail-rt\n pdf-target: maybe-pdf-target-libtermcap\n pdf-target: maybe-pdf-target-winsup\n pdf-target: maybe-pdf-target-libgloss\n@@ -1505,6 +1510,7 @@ html-target: maybe-html-target-libquadmath\n html-target: maybe-html-target-libgfortran\n html-target: maybe-html-target-libobjc\n html-target: maybe-html-target-libgo\n+html-target: maybe-html-target-libhsail-rt\n html-target: maybe-html-target-libtermcap\n html-target: maybe-html-target-winsup\n html-target: maybe-html-target-libgloss\n@@ -1590,6 +1596,7 @@ TAGS-target: maybe-TAGS-target-libquadmath\n TAGS-target: maybe-TAGS-target-libgfortran\n TAGS-target: maybe-TAGS-target-libobjc\n TAGS-target: maybe-TAGS-target-libgo\n+TAGS-target: maybe-TAGS-target-libhsail-rt\n TAGS-target: maybe-TAGS-target-libtermcap\n TAGS-target: maybe-TAGS-target-winsup\n TAGS-target: maybe-TAGS-target-libgloss\n@@ -1675,6 +1682,7 @@ install-info-target: maybe-install-info-target-libquadmath\n install-info-target: maybe-install-info-target-libgfortran\n install-info-target: maybe-install-info-target-libobjc\n install-info-target: maybe-install-info-target-libgo\n+install-info-target: maybe-install-info-target-libhsail-rt\n install-info-target: maybe-install-info-target-libtermcap\n install-info-target: maybe-install-info-target-winsup\n install-info-target: maybe-install-info-target-libgloss\n@@ -1760,6 +1768,7 @@ install-pdf-target: maybe-install-pdf-target-libquadmath\n install-pdf-target: maybe-install-pdf-target-libgfortran\n install-pdf-target: maybe-install-pdf-target-libobjc\n install-pdf-target: maybe-install-pdf-target-libgo\n+install-pdf-target: maybe-install-pdf-target-libhsail-rt\n install-pdf-target: maybe-install-pdf-target-libtermcap\n install-pdf-target: maybe-install-pdf-target-winsup\n install-pdf-target: maybe-install-pdf-target-libgloss\n@@ -1845,6 +1854,7 @@ install-html-target: maybe-install-html-target-libquadmath\n install-html-target: maybe-install-html-target-libgfortran\n install-html-target: maybe-install-html-target-libobjc\n install-html-target: maybe-install-html-target-libgo\n+install-html-target: maybe-install-html-target-libhsail-rt\n install-html-target: maybe-install-html-target-libtermcap\n install-html-target: maybe-install-html-target-winsup\n install-html-target: maybe-install-html-target-libgloss\n@@ -1930,6 +1940,7 @@ installcheck-target: maybe-installcheck-target-libquadmath\n installcheck-target: maybe-installcheck-target-libgfortran\n installcheck-target: maybe-installcheck-target-libobjc\n installcheck-target: maybe-installcheck-target-libgo\n+installcheck-target: maybe-installcheck-target-libhsail-rt\n installcheck-target: maybe-installcheck-target-libtermcap\n installcheck-target: maybe-installcheck-target-winsup\n installcheck-target: maybe-installcheck-target-libgloss\n@@ -2015,6 +2026,7 @@ mostlyclean-target: maybe-mostlyclean-target-libquadmath\n mostlyclean-target: maybe-mostlyclean-target-libgfortran\n mostlyclean-target: maybe-mostlyclean-target-libobjc\n mostlyclean-target: maybe-mostlyclean-target-libgo\n+mostlyclean-target: maybe-mostlyclean-target-libhsail-rt\n mostlyclean-target: maybe-mostlyclean-target-libtermcap\n mostlyclean-target: maybe-mostlyclean-target-winsup\n mostlyclean-target: maybe-mostlyclean-target-libgloss\n@@ -2100,6 +2112,7 @@ clean-target: maybe-clean-target-libquadmath\n clean-target: maybe-clean-target-libgfortran\n clean-target: maybe-clean-target-libobjc\n clean-target: maybe-clean-target-libgo\n+clean-target: maybe-clean-target-libhsail-rt\n clean-target: maybe-clean-target-libtermcap\n clean-target: maybe-clean-target-winsup\n clean-target: maybe-clean-target-libgloss\n@@ -2185,6 +2198,7 @@ distclean-target: maybe-distclean-target-libquadmath\n distclean-target: maybe-distclean-target-libgfortran\n distclean-target: maybe-distclean-target-libobjc\n distclean-target: maybe-distclean-target-libgo\n+distclean-target: maybe-distclean-target-libhsail-rt\n distclean-target: maybe-distclean-target-libtermcap\n distclean-target: maybe-distclean-target-winsup\n distclean-target: maybe-distclean-target-libgloss\n@@ -2270,6 +2284,7 @@ maintainer-clean-target: maybe-maintainer-clean-target-libquadmath\n maintainer-clean-target: maybe-maintainer-clean-target-libgfortran\n maintainer-clean-target: maybe-maintainer-clean-target-libobjc\n maintainer-clean-target: maybe-maintainer-clean-target-libgo\n+maintainer-clean-target: maybe-maintainer-clean-target-libhsail-rt\n maintainer-clean-target: maybe-maintainer-clean-target-libtermcap\n maintainer-clean-target: maybe-maintainer-clean-target-winsup\n maintainer-clean-target: maybe-maintainer-clean-target-libgloss\n@@ -2411,6 +2426,7 @@ check-target:  \\\n     maybe-check-target-libgfortran \\\n     maybe-check-target-libobjc \\\n     maybe-check-target-libgo \\\n+    maybe-check-target-libhsail-rt \\\n     maybe-check-target-libtermcap \\\n     maybe-check-target-winsup \\\n     maybe-check-target-libgloss \\\n@@ -2592,6 +2608,7 @@ install-target:  \\\n     maybe-install-target-libgfortran \\\n     maybe-install-target-libobjc \\\n     maybe-install-target-libgo \\\n+    maybe-install-target-libhsail-rt \\\n     maybe-install-target-libtermcap \\\n     maybe-install-target-winsup \\\n     maybe-install-target-libgloss \\\n@@ -2697,6 +2714,7 @@ install-strip-target:  \\\n     maybe-install-strip-target-libgfortran \\\n     maybe-install-strip-target-libobjc \\\n     maybe-install-strip-target-libgo \\\n+    maybe-install-strip-target-libhsail-rt \\\n     maybe-install-strip-target-libtermcap \\\n     maybe-install-strip-target-winsup \\\n     maybe-install-strip-target-libgloss \\\n@@ -46096,6 +46114,464 @@ maintainer-clean-target-libgo:\n \n \n \n+.PHONY: configure-target-libhsail-rt maybe-configure-target-libhsail-rt\n+maybe-configure-target-libhsail-rt:\n+@if gcc-bootstrap\n+configure-target-libhsail-rt: stage_current\n+@endif gcc-bootstrap\n+@if target-libhsail-rt\n+maybe-configure-target-libhsail-rt: configure-target-libhsail-rt\n+configure-target-libhsail-rt: \n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\techo \"Checking multilib configuration for libhsail-rt...\"; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libhsail-rt; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libhsail-rt/multilib.tmp 2> /dev/null; \\\n+\tif test -r $(TARGET_SUBDIR)/libhsail-rt/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libhsail-rt/multilib.tmp $(TARGET_SUBDIR)/libhsail-rt/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libhsail-rt/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libhsail-rt/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libhsail-rt/multilib.tmp $(TARGET_SUBDIR)/libhsail-rt/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libhsail-rt/multilib.tmp $(TARGET_SUBDIR)/libhsail-rt/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libhsail-rt/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libhsail-rt; \\\n+\t$(NORMAL_TARGET_EXPORTS)  \\\n+\techo Configuring in $(TARGET_SUBDIR)/libhsail-rt; \\\n+\tcd \"$(TARGET_SUBDIR)/libhsail-rt\" || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libhsail-rt/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tmodule_srcdir=libhsail-rt; \\\n+\trm -f no-such-file || : ; \\\n+\tCONFIG_SITE=no-such-file $(SHELL) \\\n+\t  $$s/$$module_srcdir/configure \\\n+\t  --srcdir=$${topdir}/$$module_srcdir \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias}  \\\n+\t  || exit 1\n+@endif target-libhsail-rt\n+\n+\n+\n+\n+\n+.PHONY: all-target-libhsail-rt maybe-all-target-libhsail-rt\n+maybe-all-target-libhsail-rt:\n+@if gcc-bootstrap\n+all-target-libhsail-rt: stage_current\n+@endif gcc-bootstrap\n+@if target-libhsail-rt\n+TARGET-target-libhsail-rt=all\n+maybe-all-target-libhsail-rt: all-target-libhsail-rt\n+all-target-libhsail-rt: configure-target-libhsail-rt\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS)  \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_TARGET_FLAGS)   \\\n+\t\t$(TARGET-target-libhsail-rt))\n+@endif target-libhsail-rt\n+\n+\n+\n+\n+\n+.PHONY: check-target-libhsail-rt maybe-check-target-libhsail-rt\n+maybe-check-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-check-target-libhsail-rt: check-target-libhsail-rt\n+\n+check-target-libhsail-rt:\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)   check)\n+\n+@endif target-libhsail-rt\n+\n+.PHONY: install-target-libhsail-rt maybe-install-target-libhsail-rt\n+maybe-install-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-install-target-libhsail-rt: install-target-libhsail-rt\n+\n+install-target-libhsail-rt: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install)\n+\n+@endif target-libhsail-rt\n+\n+.PHONY: install-strip-target-libhsail-rt maybe-install-strip-target-libhsail-rt\n+maybe-install-strip-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-install-strip-target-libhsail-rt: install-strip-target-libhsail-rt\n+\n+install-strip-target-libhsail-rt: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install-strip)\n+\n+@endif target-libhsail-rt\n+\n+# Other targets (info, dvi, pdf, etc.)\n+\n+.PHONY: maybe-info-target-libhsail-rt info-target-libhsail-rt\n+maybe-info-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-info-target-libhsail-rt: info-target-libhsail-rt\n+\n+info-target-libhsail-rt: \\\n+    configure-target-libhsail-rt \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libhsail-rt/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing info in $(TARGET_SUBDIR)/libhsail-rt\"; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           info) \\\n+\t  || exit 1\n+\n+@endif target-libhsail-rt\n+\n+.PHONY: maybe-dvi-target-libhsail-rt dvi-target-libhsail-rt\n+maybe-dvi-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-dvi-target-libhsail-rt: dvi-target-libhsail-rt\n+\n+dvi-target-libhsail-rt: \\\n+    configure-target-libhsail-rt \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libhsail-rt/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing dvi in $(TARGET_SUBDIR)/libhsail-rt\"; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           dvi) \\\n+\t  || exit 1\n+\n+@endif target-libhsail-rt\n+\n+.PHONY: maybe-pdf-target-libhsail-rt pdf-target-libhsail-rt\n+maybe-pdf-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-pdf-target-libhsail-rt: pdf-target-libhsail-rt\n+\n+pdf-target-libhsail-rt: \\\n+    configure-target-libhsail-rt \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libhsail-rt/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing pdf in $(TARGET_SUBDIR)/libhsail-rt\"; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           pdf) \\\n+\t  || exit 1\n+\n+@endif target-libhsail-rt\n+\n+.PHONY: maybe-html-target-libhsail-rt html-target-libhsail-rt\n+maybe-html-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-html-target-libhsail-rt: html-target-libhsail-rt\n+\n+html-target-libhsail-rt: \\\n+    configure-target-libhsail-rt \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libhsail-rt/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing html in $(TARGET_SUBDIR)/libhsail-rt\"; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           html) \\\n+\t  || exit 1\n+\n+@endif target-libhsail-rt\n+\n+.PHONY: maybe-TAGS-target-libhsail-rt TAGS-target-libhsail-rt\n+maybe-TAGS-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-TAGS-target-libhsail-rt: TAGS-target-libhsail-rt\n+\n+TAGS-target-libhsail-rt: \\\n+    configure-target-libhsail-rt \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libhsail-rt/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing TAGS in $(TARGET_SUBDIR)/libhsail-rt\"; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           TAGS) \\\n+\t  || exit 1\n+\n+@endif target-libhsail-rt\n+\n+.PHONY: maybe-install-info-target-libhsail-rt install-info-target-libhsail-rt\n+maybe-install-info-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-install-info-target-libhsail-rt: install-info-target-libhsail-rt\n+\n+install-info-target-libhsail-rt: \\\n+    configure-target-libhsail-rt \\\n+    info-target-libhsail-rt \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libhsail-rt/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-info in $(TARGET_SUBDIR)/libhsail-rt\"; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-info) \\\n+\t  || exit 1\n+\n+@endif target-libhsail-rt\n+\n+.PHONY: maybe-install-pdf-target-libhsail-rt install-pdf-target-libhsail-rt\n+maybe-install-pdf-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-install-pdf-target-libhsail-rt: install-pdf-target-libhsail-rt\n+\n+install-pdf-target-libhsail-rt: \\\n+    configure-target-libhsail-rt \\\n+    pdf-target-libhsail-rt \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libhsail-rt/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-pdf in $(TARGET_SUBDIR)/libhsail-rt\"; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-pdf) \\\n+\t  || exit 1\n+\n+@endif target-libhsail-rt\n+\n+.PHONY: maybe-install-html-target-libhsail-rt install-html-target-libhsail-rt\n+maybe-install-html-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-install-html-target-libhsail-rt: install-html-target-libhsail-rt\n+\n+install-html-target-libhsail-rt: \\\n+    configure-target-libhsail-rt \\\n+    html-target-libhsail-rt \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libhsail-rt/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-html in $(TARGET_SUBDIR)/libhsail-rt\"; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-html) \\\n+\t  || exit 1\n+\n+@endif target-libhsail-rt\n+\n+.PHONY: maybe-installcheck-target-libhsail-rt installcheck-target-libhsail-rt\n+maybe-installcheck-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-installcheck-target-libhsail-rt: installcheck-target-libhsail-rt\n+\n+installcheck-target-libhsail-rt: \\\n+    configure-target-libhsail-rt \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libhsail-rt/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing installcheck in $(TARGET_SUBDIR)/libhsail-rt\"; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           installcheck) \\\n+\t  || exit 1\n+\n+@endif target-libhsail-rt\n+\n+.PHONY: maybe-mostlyclean-target-libhsail-rt mostlyclean-target-libhsail-rt\n+maybe-mostlyclean-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-mostlyclean-target-libhsail-rt: mostlyclean-target-libhsail-rt\n+\n+mostlyclean-target-libhsail-rt: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libhsail-rt/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/libhsail-rt\"; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           mostlyclean) \\\n+\t  || exit 1\n+\n+@endif target-libhsail-rt\n+\n+.PHONY: maybe-clean-target-libhsail-rt clean-target-libhsail-rt\n+maybe-clean-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-clean-target-libhsail-rt: clean-target-libhsail-rt\n+\n+clean-target-libhsail-rt: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libhsail-rt/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing clean in $(TARGET_SUBDIR)/libhsail-rt\"; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           clean) \\\n+\t  || exit 1\n+\n+@endif target-libhsail-rt\n+\n+.PHONY: maybe-distclean-target-libhsail-rt distclean-target-libhsail-rt\n+maybe-distclean-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-distclean-target-libhsail-rt: distclean-target-libhsail-rt\n+\n+distclean-target-libhsail-rt: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libhsail-rt/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing distclean in $(TARGET_SUBDIR)/libhsail-rt\"; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           distclean) \\\n+\t  || exit 1\n+\n+@endif target-libhsail-rt\n+\n+.PHONY: maybe-maintainer-clean-target-libhsail-rt maintainer-clean-target-libhsail-rt\n+maybe-maintainer-clean-target-libhsail-rt:\n+@if target-libhsail-rt\n+maybe-maintainer-clean-target-libhsail-rt: maintainer-clean-target-libhsail-rt\n+\n+maintainer-clean-target-libhsail-rt: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libhsail-rt/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/libhsail-rt\"; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libhsail-rt && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           maintainer-clean) \\\n+\t  || exit 1\n+\n+@endif target-libhsail-rt\n+\n+\n+\n+\n+\n .PHONY: configure-target-libtermcap maybe-configure-target-libtermcap\n maybe-configure-target-libtermcap:\n @if gcc-bootstrap\n@@ -51382,6 +51858,14 @@ check-gcc-go:\n \t(cd gcc && $(MAKE) $(GCC_FLAGS_TO_PASS) check-go);\n check-go: check-gcc-go check-target-libgo\n \n+.PHONY: check-gcc-brig check-brig\n+check-gcc-brig:\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\t(cd gcc && $(MAKE) $(GCC_FLAGS_TO_PASS) check-brig);\n+check-brig: check-gcc-brig check-target-libhsail-rt\n+\n \n # The gcc part of install-no-fixedincludes, which relies on an intimate\n # knowledge of how a number of gcc internal targets (inter)operate.  Delegate.\n@@ -54259,6 +54743,7 @@ configure-target-libquadmath: stage_last\n configure-target-libgfortran: stage_last\n configure-target-libobjc: stage_last\n configure-target-libgo: stage_last\n+configure-target-libhsail-rt: stage_last\n configure-target-libtermcap: stage_last\n configure-target-winsup: stage_last\n configure-target-libgloss: stage_last\n@@ -54293,6 +54778,7 @@ configure-target-libquadmath: maybe-all-gcc\n configure-target-libgfortran: maybe-all-gcc\n configure-target-libobjc: maybe-all-gcc\n configure-target-libgo: maybe-all-gcc\n+configure-target-libhsail-rt: maybe-all-gcc\n configure-target-libtermcap: maybe-all-gcc\n configure-target-winsup: maybe-all-gcc\n configure-target-libgloss: maybe-all-gcc\n@@ -55445,6 +55931,7 @@ configure-target-libquadmath: maybe-all-target-libgcc\n configure-target-libgfortran: maybe-all-target-libgcc\n configure-target-libobjc: maybe-all-target-libgcc\n configure-target-libgo: maybe-all-target-libgcc\n+configure-target-libhsail-rt: maybe-all-target-libgcc\n configure-target-libtermcap: maybe-all-target-libgcc\n configure-target-winsup: maybe-all-target-libgcc\n configure-target-libgloss: maybe-all-target-libgcc\n@@ -55486,6 +55973,8 @@ configure-target-libobjc: maybe-all-target-newlib maybe-all-target-libgloss\n \n configure-target-libgo: maybe-all-target-newlib maybe-all-target-libgloss\n \n+configure-target-libhsail-rt: maybe-all-target-newlib maybe-all-target-libgloss\n+\n configure-target-libtermcap: maybe-all-target-newlib maybe-all-target-libgloss\n \n configure-target-winsup: maybe-all-target-newlib maybe-all-target-libgloss"}, {"sha": "d7573690383d50b802cb99d95d0e7983ec785c32", "filename": "configure", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -2754,6 +2754,7 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libgomp \\\n \t\ttarget-libcilkrts \\\n \t\ttarget-liboffloadmic \\\n+\t\ttarget-libhsail-rt \\\n \t\ttarget-libatomic \\\n \t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n@@ -3482,6 +3483,19 @@ if test x$enable_libgo = x; then\n     esac\n fi\n \n+# Disable the BRIG frontend and libhsail-rt on untested or known\n+# broken systems. Currently it has been tested only on x86_64 Linux\n+# of the upstream gcc targets. More targets shall be added after testing.\n+case \"${target}\" in\n+  x86_64-*-linux*)\n+    ;;\n+    *)\n+    unsupported_languages=\"$unsupported_languages brig\"\n+    # This implicitly disables also target-libhsail-rt as it won't\n+    # get added to the build without BRIG FE.\n+    ;;\n+esac\n+\n # Default libgloss CPU subdirectory.\n libgloss_dir=\"$target_cpu\"\n "}, {"sha": "5818332c7fc8de49395206493edfba1e85a56091", "filename": "configure.ac", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -152,6 +152,7 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libgomp \\\n \t\ttarget-libcilkrts \\\n \t\ttarget-liboffloadmic \\\n+\t\ttarget-libhsail-rt \\\n \t\ttarget-libatomic \\\n \t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n@@ -812,6 +813,19 @@ if test x$enable_libgo = x; then\n     esac\n fi\n \n+# Disable the BRIG frontend and libhsail-rt on untested or known\n+# broken systems. Currently it has been tested only on x86_64 Linux\n+# of the upstream gcc targets. More targets shall be added after testing.\n+case \"${target}\" in\n+  x86_64-*-linux*)\n+    ;;\n+    *)\n+    unsupported_languages=\"$unsupported_languages brig\"\n+    # This implicitly disables also target-libhsail-rt as it won't\n+    # get added to the build without BRIG FE.\n+    ;;\n+esac\n+\n # Default libgloss CPU subdirectory.\n libgloss_dir=\"$target_cpu\"\n "}, {"sha": "f638e952fee26369f20c9c24848ccc7498d44d66", "filename": "gcc/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -1,3 +1,66 @@\n+2017-01-24  Pekka J\u00e4\u00e4skel\u00e4inen <pekka@parmance.com>\n+\t    Martin Jambor  <mjambor@suse.cz>\n+\n+\t* brig-builtins.def: New file.\n+\t* builtins.def (DEF_HSAIL_BUILTIN): New macro.\n+\t(DEF_HSAIL_ATOMIC_BUILTIN): Likewise.\n+\t(DEF_HSAIL_SAT_BUILTIN): Likewise.\n+\t(DEF_HSAIL_INTR_BUILTIN): Likewise.\n+\t(DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN): Likewise.\n+\t* builtin-types.def (BT_INT8): New.\n+\t(BT_INT16): Likewise.\n+\t(BT_UINT8): Likewise.\n+\t(BT_UINT16): Likewise.\n+\t(BT_FN_ULONG): Likewise.\n+\t(BT_FN_UINT_INT): Likewise.\n+\t(BT_FN_UINT_ULONG): Likewise.\n+\t(BT_FN_UINT_LONG): Likewise.\n+\t(BT_FN_UINT_PTR): Likewise.\n+\t(BT_FN_ULONG_PTR): Likewise.\n+\t(BT_FN_INT8_FLOAT): Likewise.\n+\t(BT_FN_INT16_FLOAT): Likewise.\n+\t(BT_FN_UINT32_FLOAT): Likewise.\n+\t(BT_FN_UINT16_FLOAT): Likewise.\n+\t(BT_FN_UINT8_FLOAT): Likewise.\n+\t(BT_FN_UINT64_FLOAT): Likewise.\n+\t(BT_FN_UINT16_UINT32): Likewise.\n+\t(BT_FN_UINT32_UINT16): Likewise.\n+\t(BT_FN_UINT16_UINT16_UINT16): Likewise.\n+\t(BT_FN_INT_PTR_INT): Likewise.\n+\t(BT_FN_UINT_PTR_UINT): Likewise.\n+\t(BT_FN_LONG_PTR_LONG): Likewise.\n+\t(BT_FN_ULONG_PTR_ULONG): Likewise.\n+\t(BT_FN_VOID_UINT64_UINT64): Likewise.\n+\t(BT_FN_UINT8_UINT8_UINT8): Likewise.\n+\t(BT_FN_INT8_INT8_INT8): Likewise.\n+\t(BT_FN_INT16_INT16_INT16): Likewise.\n+\t(BT_FN_INT_INT_INT): Likewise.\n+\t(BT_FN_UINT_FLOAT_UINT): Likewise.\n+\t(BT_FN_FLOAT_UINT_UINT): Likewise.\n+\t(BT_FN_ULONG_UINT_UINT): Likewise.\n+\t(BT_FN_ULONG_UINT_PTR): Likewise.\n+\t(BT_FN_ULONG_ULONG_ULONG): Likewise.\n+\t(BT_FN_UINT_UINT_UINT): Likewise.\n+\t(BT_FN_VOID_UINT_PTR): Likewise.\n+\t(BT_FN_UINT_UINT_PTR: Likewise.\n+\t(BT_FN_UINT32_UINT64_PTR): Likewise.\n+\t(BT_FN_INT_INT_UINT_UINT): Likewise.\n+\t(BT_FN_UINT_UINT_UINT_UINT): Likewise.\n+\t(BT_FN_UINT_UINT_UINT_PTR): Likewise.\n+\t(BT_FN_UINT_ULONG_ULONG_UINT): Likewise.\n+\t(BT_FN_ULONG_ULONG_ULONG_ULONG): Likewise.\n+\t(BT_FN_LONG_LONG_UINT_UINT): Likewise.\n+\t(BT_FN_ULONG_ULONG_UINT_UINT): Likewise.\n+\t(BT_FN_VOID_UINT32_UINT64_PTR): Likewise.\n+\t(BT_FN_VOID_UINT32_UINT32_PTR): Likewise.\n+\t(BT_FN_UINT_UINT_UINT_UINT_UINT): Likewise.\n+\t(BT_FN_UINT_FLOAT_FLOAT_FLOAT_FLOAT): Likewise.\n+\t(BT_FN_ULONG_ULONG_ULONG_UINT_UINT): Likewise.\n+\t* doc/frontends.texi: List BRIG FE.\n+\t* doc/install.texi (Testing): Add BRIG tesring requirements.\n+\t* doc/invoke.texi (Overall Options): Mention BRIG.\n+\t* doc/standards.texi (Standards): Doucment BRIG HSA version.\n+\n 2017-01-24  Richard Biener  <rguenther@suse.de>\n \n \tPR translation/79208"}, {"sha": "329c88e8e95f3b73e81ce44bd94ebf81ef6b3d58", "filename": "gcc/brig-builtins.def", "status": "added", "additions": 659, "deletions": 0, "changes": 659, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig-builtins.def?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,659 @@\n+/* This file contains the definitions and documentation for the\n+   HSAIL builtins used in the GNU compiler.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Following builtins are used by the BRIG (the binary representation of\n+   HSAIL) frontend.  Software implementations are available in libhsail-rt.\n+   Use leading double underscore in the name to avoid name space clashes\n+   with kernel program symbols in case the builtin is implemented as\n+   a function call.  */\n+\n+/* Work-item ID related builtins are not constant in the work-group function\n+   mode (each WI has a different return value).  */\n+\n+#ifndef DEF_HSAIL_BUILTIN\n+#define DEF_HSAIL_BUILTIN(ENUM, HSAIL_OPCODE, HSAIL_TYPE,\t\\\n+\t\t\t  NAME, TYPE, ATTRS)\n+#endif\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMABSID, BRIG_OPCODE_WORKITEMABSID,\n+\t\t  BRIG_TYPE_U32, \"__hsail_workitemabsid\", BT_FN_UINT_UINT_PTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_GRIDSIZE, BRIG_OPCODE_GRIDSIZE,\n+\t\t  BRIG_TYPE_U32, \"__hsail_gridsize\", BT_FN_UINT_UINT_PTR,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMFLATABSID_U32,\n+\t\t  BRIG_OPCODE_WORKITEMFLATABSID, BRIG_TYPE_U32,\n+\t\t  \"__hsail_workitemflatabsid_u32\", BT_FN_UINT_PTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMFLATABSID_U64,\n+\t\t  BRIG_OPCODE_WORKITEMFLATABSID, BRIG_TYPE_U64,\n+\t\t  \"__hsail_workitemflatabsid_u64\", BT_FN_ULONG_PTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMFLATID, BRIG_OPCODE_WORKITEMFLATID,\n+\t\t  BRIG_TYPE_U32, \"__hsail_workitemflatid\", BT_FN_UINT_PTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMID, BRIG_OPCODE_WORKITEMID,\n+\t\t  BRIG_TYPE_U32, \"__hsail_workitemid\", BT_FN_UINT_UINT_PTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKGROUPID, BRIG_OPCODE_WORKGROUPID,\n+\t\t  BRIG_TYPE_U32, \"__hsail_workgroupid\", BT_FN_UINT_UINT_PTR,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CURRENTWORKITEMFLATID,\n+\t\t  BRIG_OPCODE_CURRENTWORKITEMFLATID,\n+\t\t  BRIG_TYPE_U32, \"__hsail_currentworkitemflatid\",\n+\t\t  BT_FN_UINT_PTR, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMABSID_U64, BRIG_OPCODE_WORKITEMABSID,\n+\t\t  BRIG_TYPE_U64, \"__hsail_workitemabsid_u64\",\n+\t\t  BT_FN_ULONG_UINT_PTR, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_PACKETID, BRIG_OPCODE_PACKETID,\n+\t\t  BRIG_TYPE_U64, \"__hsail_packetid\", BT_FN_ULONG_PTR,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_PACKETCOMPLETIONSIG_SIG64,\n+\t\t  BRIG_OPCODE_PACKETCOMPLETIONSIG, BRIG_TYPE_SIG64,\n+\t\t  \"__hsail_packetcompletionsig_sig64\", BT_FN_ULONG_PTR,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_PACKETCOMPLETIONSIG_SIG32,\n+\t\t  BRIG_OPCODE_PACKETCOMPLETIONSIG, BRIG_TYPE_SIG32,\n+\t\t  \"__hsail_packetcompletionsig_sig32\", BT_FN_UINT_PTR,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CURRENTWORKGROUPSIZE,\n+\t\t  BRIG_OPCODE_CURRENTWORKGROUPSIZE, BRIG_TYPE_U32,\n+\t\t  \"__hsail_currentworkgroupsize\", BT_FN_UINT_UINT_PTR,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKGROUPSIZE, BRIG_OPCODE_WORKGROUPSIZE,\n+\t\t  BRIG_TYPE_U32, \"__hsail_workgroupsize\", BT_FN_UINT_UINT_PTR,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_DIM, BRIG_OPCODE_DIM,\n+\t\t  BRIG_TYPE_U32, \"__hsail_dim\", BT_FN_UINT_PTR,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_GRIDGROUPS, BRIG_OPCODE_GRIDGROUPS,\n+\t\t  BRIG_TYPE_U32, \"__hsail_gridgroups\", BT_FN_UINT_UINT_PTR,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITEXTRACT_S32, BRIG_OPCODE_BITEXTRACT,\n+\t\t  BRIG_TYPE_S32, \"__hsail_bitextract_s32\",\n+\t\t  BT_FN_INT_INT_UINT_UINT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITEXTRACT_U32, BRIG_OPCODE_BITEXTRACT,\n+\t\t  BRIG_TYPE_U32, \"__hsail_bitextract_u32\",\n+\t\t  BT_FN_UINT_UINT_UINT_UINT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITEXTRACT_S64, BRIG_OPCODE_BITEXTRACT,\n+\t\t  BRIG_TYPE_S64, \"__hsail_bitextract_s64\",\n+\t\t  BT_FN_LONG_LONG_UINT_UINT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITEXTRACT_U64, BRIG_OPCODE_BITEXTRACT,\n+\t\t  BRIG_TYPE_U64, \"__hsail_bitextract_u64\",\n+\t\t  BT_FN_ULONG_ULONG_UINT_UINT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITINSERT_U32, BRIG_OPCODE_BITINSERT,\n+\t\t  BRIG_TYPE_U32, \"__hsail_bitinsert_u32\",\n+\t\t  BT_FN_UINT_UINT_UINT_UINT_UINT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITINSERT_U64, BRIG_OPCODE_BITINSERT,\n+\t\t  BRIG_TYPE_U64, \"__hsail_bitinsert_u64\",\n+\t\t  BT_FN_ULONG_ULONG_ULONG_UINT_UINT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITMASK_B32, BRIG_OPCODE_BITMASK,\n+\t\t  BRIG_TYPE_B32, \"__hsail_bitmask_u32\", BT_FN_UINT_UINT_UINT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITMASK_B64, BRIG_OPCODE_BITMASK,\n+\t\t  BRIG_TYPE_B64, \"__hsail_bitmask_u64\", BT_FN_ULONG_UINT_UINT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITREV_B32, BRIG_OPCODE_BITREV,\n+\t\t  BRIG_TYPE_B32, \"__hsail_bitrev_u32\", BT_FN_UINT_UINT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITREV_B64, BRIG_OPCODE_BITREV,\n+\t\t  BRIG_TYPE_B64, \"__hsail_bitrev_u64\", BT_FN_ULONG_ULONG,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITSELECT_B32, BRIG_OPCODE_BITSELECT,\n+\t\t  BRIG_TYPE_B32, \"__hsail_bitselect_u32\",\n+\t\t  BT_FN_UINT_UINT_UINT_UINT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITSELECT_U64, BRIG_OPCODE_BITSELECT,\n+\t\t  BRIG_TYPE_B64, \"__hsail_bitselect_u64\",\n+\t\t  BT_FN_ULONG_ULONG_ULONG_ULONG, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_FIRSTBIT_U32, BRIG_OPCODE_FIRSTBIT,\n+\t\t  BRIG_TYPE_U32, \"__hsail_firstbit_u32\", BT_FN_UINT_UINT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_FIRSTBIT_S32, BRIG_OPCODE_FIRSTBIT,\n+\t\t  BRIG_TYPE_S32, \"__hsail_firstbit_s32\", BT_FN_UINT_INT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_FIRSTBIT_U64, BRIG_OPCODE_FIRSTBIT,\n+\t\t  BRIG_TYPE_U64, \"__hsail_firstbit_u64\", BT_FN_UINT_ULONG,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_FIRSTBIT_S64, BRIG_OPCODE_FIRSTBIT,\n+\t\t  BRIG_TYPE_S64, \"__hsail_firstbit_s64\", BT_FN_UINT_LONG,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_LASTBIT_U32, BRIG_OPCODE_LASTBIT,\n+\t\t  BRIG_TYPE_U32, \"__hsail_lastbit_u32\", BT_FN_UINT_UINT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_LASTBIT_U64, BRIG_OPCODE_LASTBIT,\n+\t\t  BRIG_TYPE_U64, \"__hsail_lastbit_u64\", BT_FN_UINT_ULONG,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BORROW_U32, BRIG_OPCODE_BORROW,\n+\t\t  BRIG_TYPE_U32, \"__hsail_borrow_u32\", BT_FN_UINT_UINT_UINT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BORROW_U64, BRIG_OPCODE_BORROW,\n+\t\t  BRIG_TYPE_U64, \"__hsail_borrow_u64\", BT_FN_ULONG_ULONG_ULONG,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CARRY_U32, BRIG_OPCODE_CARRY,\n+\t\t  BRIG_TYPE_U32, \"__hsail_carry_u32\", BT_FN_UINT_UINT_UINT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CARRY_U64, BRIG_OPCODE_CARRY,\n+\t\t  BRIG_TYPE_U64, \"__hsail_carry_u64\", BT_FN_ULONG_ULONG_ULONG,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_REM_S32, BRIG_OPCODE_REM,\n+\t\t  BRIG_TYPE_S32, \"__hsail_rem_s32\", BT_FN_INT_INT_INT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_REM_S64, BRIG_OPCODE_REM,\n+\t\t  BRIG_TYPE_S64, \"__hsail_rem_s64\", BT_FN_LONG_LONG_LONG,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_MIN_F32, BRIG_OPCODE_MIN,\n+\t\t  BRIG_TYPE_F32, \"__hsail_min_f32\", BT_FN_FLOAT_FLOAT_FLOAT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_MAX_F32, BRIG_OPCODE_MAX,\n+\t\t  BRIG_TYPE_F32, \"__hsail_max_f32\", BT_FN_FLOAT_FLOAT_FLOAT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_MIN_F64, BRIG_OPCODE_MIN,\n+\t\t  BRIG_TYPE_F64, \"__hsail_min_f64\", BT_FN_DOUBLE_DOUBLE_DOUBLE,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_MAX_F64, BRIG_OPCODE_MAX,\n+\t\t  BRIG_TYPE_F64, \"__hsail_max_f64\", BT_FN_DOUBLE_DOUBLE_DOUBLE,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CLASS_F32, BRIG_OPCODE_CLASS,\n+\t\t  BRIG_TYPE_F32, \"__hsail_class_f32\", BT_FN_UINT_FLOAT_UINT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CLASS_F32_F16, BRIG_OPCODE_CLASS,\n+\t\t  BRIG_TYPE_F16, \"__hsail_class_f32_f16\", BT_FN_UINT_FLOAT_UINT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_FRACT_F32, BRIG_OPCODE_FRACT,\n+\t\t  BRIG_TYPE_F32, \"__hsail_fract_f32\", BT_FN_FLOAT_FLOAT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_FRACT_F64, BRIG_OPCODE_FRACT,\n+\t\t  BRIG_TYPE_F64, \"__hsail_fract_f64\", BT_FN_DOUBLE_DOUBLE,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BARRIER, BRIG_OPCODE_BARRIER,\n+\t\t  BRIG_TYPE_NONE, \"__hsail_barrier\", BT_FN_VOID_PTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_INITFBAR, BRIG_OPCODE_INITFBAR,\n+\t\t  BRIG_TYPE_NONE, \"__hsail_initfbar\", BT_FN_VOID_UINT_PTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_JOINFBAR, BRIG_OPCODE_JOINFBAR,\n+\t\t  BRIG_TYPE_NONE, \"__hsail_joinfbar\", BT_FN_VOID_UINT_PTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WAITFBAR, BRIG_OPCODE_WAITFBAR,\n+\t\t  BRIG_TYPE_NONE, \"__hsail_waitfbar\", BT_FN_VOID_UINT_PTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_ARRIVEFBAR, BRIG_OPCODE_ARRIVEFBAR,\n+\t\t  BRIG_TYPE_NONE, \"__hsail_arrivefbar\", BT_FN_VOID_UINT_PTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_LEAVEFBAR, BRIG_OPCODE_LEAVEFBAR,\n+\t\t  BRIG_TYPE_NONE, \"__hsail_leavefbar\", BT_FN_VOID_UINT_PTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_RELEASEFBAR, BRIG_OPCODE_RELEASEFBAR,\n+\t\t  BRIG_TYPE_NONE, \"__hsail_releasefbar\", BT_FN_VOID_UINT_PTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BITALIGN, BRIG_OPCODE_BITALIGN,\n+\t\t  BRIG_TYPE_B32, \"__hsail_bitalign\",\n+\t\t  BT_FN_UINT_ULONG_ULONG_UINT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_BYTEALIGN, BRIG_OPCODE_BYTEALIGN,\n+\t\t  BRIG_TYPE_B32, \"__hsail_bytealign\",\n+\t\t  BT_FN_UINT_ULONG_ULONG_UINT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_LERP, BRIG_OPCODE_LERP,\n+\t\t  BRIG_TYPE_U8X4, \"__hsail_lerp\", BT_FN_UINT_UINT_UINT_UINT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_PACKCVT, BRIG_OPCODE_PACKCVT,\n+\t\t  BRIG_TYPE_U8X4, \"__hsail_packcvt\",\n+\t\t  BT_FN_UINT_FLOAT_FLOAT_FLOAT_FLOAT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_UNPACKCVT, BRIG_OPCODE_UNPACKCVT,\n+\t\t  BRIG_TYPE_F32, \"__hsail_unpackcvt\", BT_FN_FLOAT_UINT_UINT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_SAD_U16X2, BRIG_OPCODE_SAD,\n+\t\t  BRIG_TYPE_U16X2, \"__hsail_sad_u16x2\",\n+\t\t  BT_FN_UINT_UINT_UINT_UINT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_SAD_U32, BRIG_OPCODE_SAD,\n+\t\t  BRIG_TYPE_U32, \"__hsail_sad_u32\", BT_FN_UINT_UINT_UINT_UINT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_SAD_U8X4, BRIG_OPCODE_SAD,\n+\t\t  BRIG_TYPE_U8X4, \"__hsail_sad_u8x4\", BT_FN_UINT_UINT_UINT_UINT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_SADHI_U8X4, BRIG_OPCODE_SADHI,\n+\t\t  BRIG_TYPE_U16X2, \"__hsail_sadhi_u16x2_u8x4\",\n+\t\t  BT_FN_UINT_UINT_UINT_UINT,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CLOCK, BRIG_OPCODE_CLOCK,\n+\t\t  BRIG_TYPE_U64, \"__hsail_clock\", BT_FN_ULONG,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CUID, BRIG_OPCODE_CUID,\n+\t\t  BRIG_TYPE_U32, \"__hsail_cuid\", BT_FN_UINT_PTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_MAXCUID, BRIG_OPCODE_MAXCUID,\n+\t\t  BRIG_TYPE_U32, \"__hsail_maxcuid\", BT_FN_UINT_PTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_DEBUGTRAP, BRIG_OPCODE_DEBUGTRAP,\n+\t\t  BRIG_TYPE_U32, \"__hsail_debugtrap\", BT_FN_VOID_UINT_PTR,\n+\t\t  ATTR_NORETURN_NOTHROW_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_GROUPBASEPTR, BRIG_OPCODE_GROUPBASEPTR,\n+\t\t  BRIG_TYPE_U32, \"__hsail_groupbaseptr\", BT_FN_UINT_PTR,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_KERNARGBASEPTR_U64,\n+\t\t  BRIG_OPCODE_KERNARGBASEPTR, BRIG_TYPE_U64,\n+\t\t  \"__hsail_kernargbaseptr_u64\", BT_FN_ULONG_PTR,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_KERNARGBASEPTR_U32,\n+\t\t  BRIG_OPCODE_KERNARGBASEPTR, BRIG_TYPE_U32,\n+\t\t  \"__hsail_kernargbaseptr_u32\", BT_FN_UINT_PTR,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_ALLOCA, BRIG_OPCODE_ALLOCA,\n+\t\t  BRIG_TYPE_U32, \"__hsail_alloca\", BT_FN_UINT_UINT_UINT_PTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_LDQUEUEWRITEINDEX,\n+\t\t  BRIG_OPCODE_LDQUEUEWRITEINDEX,\n+\t\t  BRIG_TYPE_U64, \"__hsail_ldqueuewriteindex\",\n+\t\t  BT_FN_ULONG_ULONG, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_LDQUEUEREADINDEX,\n+\t\t  BRIG_OPCODE_LDQUEUEREADINDEX,\n+\t\t  BRIG_TYPE_U64, \"__hsail_ldqueuereadindex\",\n+\t\t  BT_FN_ULONG_ULONG, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_STQUEUEWRITEINDEX,\n+\t\t  BRIG_OPCODE_STQUEUEWRITEINDEX,\n+\t\t  BRIG_TYPE_U64, \"__hsail_stqueuewriteindex\",\n+\t\t  BT_FN_VOID_UINT64_UINT64, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_STQUEUEREADINDEX,\n+\t\t  BRIG_OPCODE_STQUEUEREADINDEX,\n+\t\t  BRIG_TYPE_U64, \"__hsail_stqueuereadindex\",\n+\t\t  BT_FN_VOID_UINT64_UINT64, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_ADDQUEUEWRITEINDEX,\n+\t\t  BRIG_OPCODE_ADDQUEUEWRITEINDEX,\n+\t\t  BRIG_TYPE_U64, \"__hsail_addqueuewriteindex\",\n+\t\t  BT_FN_ULONG_ULONG_ULONG, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CASQUEUEWRITEINDEX,\n+\t\t  BRIG_OPCODE_CASQUEUEWRITEINDEX,\n+\t\t  BRIG_TYPE_U64, \"__hsail_casqueuewriteindex\",\n+\t\t  BT_FN_ULONG_ULONG_ULONG_ULONG, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_SEGMENTP_GLOBAL,\n+\t\t  BRIG_OPCODE_SEGMENTP,\n+\t\t  BRIG_TYPE_U32, \"__hsail_segmentp_global\",\n+\t\t  BT_FN_UINT32_UINT64_PTR, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_SEGMENTP_GROUP,\n+\t\t  BRIG_OPCODE_SEGMENTP,\n+\t\t  BRIG_TYPE_U32, \"__hsail_segmentp_group\",\n+\t\t  BT_FN_UINT32_UINT64_PTR, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_SEGMENTP_PRIVATE,\n+\t\t  BRIG_OPCODE_SEGMENTP,\n+\t\t  BRIG_TYPE_U32, \"__hsail_segmentp_private\",\n+\t\t  BT_FN_UINT32_UINT64_PTR, ATTR_NOTHROW_LEAF_LIST)\n+\n+#ifndef DEF_HSAIL_ATOMIC_BUILTIN\n+#define DEF_HSAIL_ATOMIC_BUILTIN(ENUM, ATOMIC_OPCODE, HSAIL_TYPE,\t\\\n+\t\t\t\t NAME, TYPE, ATTRS)\n+#endif\n+\n+DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MIN_S32, BRIG_ATOMIC_MIN,\n+\t\t\t BRIG_TYPE_S32, \"__hsail_atomic_min_s32\",\n+\t\t\t BT_FN_INT_PTR_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MIN_S64, BRIG_ATOMIC_MIN,\n+\t\t\t BRIG_TYPE_S64, \"__hsail_atomic_min_s64\",\n+\t\t\t BT_FN_LONG_PTR_LONG, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MIN_U32, BRIG_ATOMIC_MIN,\n+\t\t\t BRIG_TYPE_U32, \"__hsail_atomic_min_u32\",\n+\t\t\t BT_FN_UINT_PTR_UINT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MIN_U64, BRIG_ATOMIC_MIN,\n+\t\t\t BRIG_TYPE_U64, \"__hsail_atomic_min_u64\",\n+\t\t\t BT_FN_ULONG_PTR_ULONG, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MAX_S32, BRIG_ATOMIC_MAX,\n+\t\t\t BRIG_TYPE_S32, \"__hsail_atomic_max_s32\",\n+\t\t\t BT_FN_INT_PTR_INT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MAX_S64, BRIG_ATOMIC_MAX,\n+\t\t\t BRIG_TYPE_S64, \"__hsail_atomic_max_s64\",\n+\t\t\t BT_FN_LONG_PTR_LONG, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MAX_U32, BRIG_ATOMIC_MAX,\n+\t\t\t BRIG_TYPE_U32, \"__hsail_atomic_max_u32\",\n+\t\t\t BT_FN_UINT_PTR_UINT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_MAX_U64, BRIG_ATOMIC_MAX,\n+\t\t\t BRIG_TYPE_U64, \"__hsail_atomic_max_u64\",\n+\t\t\t BT_FN_ULONG_PTR_ULONG, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_WRAPDEC_U32,\n+\t\t\t BRIG_ATOMIC_WRAPDEC, BRIG_TYPE_U32,\n+\t\t\t \"__hsail_atomic_wrapdec_u32\",\n+\t\t\t BT_FN_UINT_PTR_UINT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_WRAPDEC_U64,\n+\t\t\t BRIG_ATOMIC_WRAPDEC, BRIG_TYPE_U64,\n+\t\t\t \"__hsail_atomic_wrapdec_u64\",\n+\t\t\t BT_FN_ULONG_PTR_ULONG, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_WRAPINC_U32,\n+\t\t\t BRIG_ATOMIC_WRAPINC, BRIG_TYPE_U32,\n+\t\t\t \"__hsail_atomic_wrapinc_u32\",\n+\t\t\t BT_FN_UINT_PTR_UINT, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_ATOMIC_BUILTIN (BUILT_IN_HSAIL_ATOMIC_WRAPINC_U64,\n+\t\t\t BRIG_ATOMIC_WRAPINC, BRIG_TYPE_U64,\n+\t\t\t \"__hsail_atomic_wrapinc_u64\",\n+\t\t\t BT_FN_ULONG_PTR_ULONG, ATTR_NOTHROW_LEAF_LIST)\n+\n+#ifndef DEF_HSAIL_SAT_BUILTIN\n+#define DEF_HSAIL_SAT_BUILTIN(ENUM, HSAIL_OPCODE, HSAIL_TYPE,\t\\\n+\t\t\t      NAME, TYPE, ATTRS)\n+#endif\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_U64, BRIG_OPCODE_ADD,\n+\t\t      BRIG_TYPE_U64, \"__hsail_sat_add_u64\",\n+\t\t      BT_FN_ULONG_ULONG_ULONG, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_S64, BRIG_OPCODE_ADD,\n+\t\t      BRIG_TYPE_S64, \"__hsail_sat_add_s64\",\n+\t\t      BT_FN_LONG_LONG_LONG, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_U32, BRIG_OPCODE_ADD,\n+\t\t      BRIG_TYPE_U32, \"__hsail_sat_add_u32\",\n+\t\t      BT_FN_UINT_UINT_UINT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_S32, BRIG_OPCODE_ADD,\n+\t\t      BRIG_TYPE_S32, \"__hsail_sat_add_s32\",\n+\t\t      BT_FN_INT_INT_INT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_U16, BRIG_OPCODE_ADD,\n+\t\t      BRIG_TYPE_U16, \"__hsail_sat_add_u16\",\n+\t\t      BT_FN_UINT16_UINT16_UINT16, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_S16, BRIG_OPCODE_ADD,\n+\t\t      BRIG_TYPE_S16, \"__hsail_sat_add_s16\",\n+\t\t      BT_FN_INT16_INT16_INT16, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_U8, BRIG_OPCODE_ADD,\n+\t\t      BRIG_TYPE_U8, \"__hsail_sat_add_u8\",\n+\t\t      BT_FN_UINT8_UINT8_UINT8, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_ADD_S8, BRIG_OPCODE_ADD,\n+\t\t      BRIG_TYPE_S8, \"__hsail_sat_add_s8\",\n+\t\t      BT_FN_INT8_INT8_INT8, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_U64, BRIG_OPCODE_SUB,\n+\t\t      BRIG_TYPE_U64, \"__hsail_sat_sub_u64\",\n+\t\t      BT_FN_ULONG_ULONG_ULONG, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_S64, BRIG_OPCODE_SUB,\n+\t\t      BRIG_TYPE_S64, \"__hsail_sat_sub_s64\",\n+\t\t      BT_FN_LONG_LONG_LONG, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_U32, BRIG_OPCODE_SUB,\n+\t\t      BRIG_TYPE_U32, \"__hsail_sat_sub_u32\",\n+\t\t      BT_FN_UINT_UINT_UINT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_S32, BRIG_OPCODE_SUB,\n+\t\t      BRIG_TYPE_S32, \"__hsail_sat_sub_s32\",\n+\t\t      BT_FN_INT_INT_INT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_U16, BRIG_OPCODE_SUB,\n+\t\t      BRIG_TYPE_U16, \"__hsail_sat_sub_u16\",\n+\t\t      BT_FN_UINT16_UINT16_UINT16, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_S16, BRIG_OPCODE_SUB,\n+\t\t      BRIG_TYPE_S16, \"__hsail_sat_sub_s16\",\n+\t\t      BT_FN_INT16_INT16_INT16, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_U8, BRIG_OPCODE_SUB,\n+\t\t      BRIG_TYPE_U8, \"__hsail_sat_sub_u8\",\n+\t\t      BT_FN_UINT8_UINT8_UINT8, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_SUB_S8, BRIG_OPCODE_SUB,\n+\t\t      BRIG_TYPE_S8, \"__hsail_sat_sub_s8\",\n+\t\t      BT_FN_INT8_INT8_INT8, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_U64, BRIG_OPCODE_MUL,\n+\t\t      BRIG_TYPE_U64, \"__hsail_sat_mul_u64\",\n+\t\t      BT_FN_ULONG_ULONG_ULONG, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_S64, BRIG_OPCODE_MUL,\n+\t\t      BRIG_TYPE_S64, \"__hsail_sat_mul_s64\",\n+\t\t      BT_FN_LONG_LONG_LONG, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_U32, BRIG_OPCODE_MUL,\n+\t\t      BRIG_TYPE_U32, \"__hsail_sat_mul_u32\",\n+\t\t      BT_FN_UINT_UINT_UINT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_S32, BRIG_OPCODE_MUL,\n+\t\t      BRIG_TYPE_S32, \"__hsail_sat_mul_s32\",\n+\t\t      BT_FN_INT_INT_INT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_U16, BRIG_OPCODE_MUL,\n+\t\t      BRIG_TYPE_U16, \"__hsail_sat_mul_u16\",\n+\t\t      BT_FN_UINT16_UINT16_UINT16, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_S16, BRIG_OPCODE_MUL,\n+\t\t      BRIG_TYPE_S16, \"__hsail_sat_mul_s16\",\n+\t\t      BT_FN_INT16_INT16_INT16, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_U8, BRIG_OPCODE_MUL,\n+\t\t      BRIG_TYPE_U8, \"__hsail_sat_mul_u8\",\n+\t\t      BT_FN_UINT8_UINT8_UINT8, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_SAT_BUILTIN (BUILT_IN_HSAIL_SAT_MUL_S8, BRIG_OPCODE_MUL,\n+\t\t      BRIG_TYPE_S8, \"__hsail_sat_mul_s8\",\n+\t\t      BT_FN_INT8_INT8_INT8, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+#ifndef DEF_HSAIL_INTR_BUILTIN\n+#define DEF_HSAIL_INTR_BUILTIN(ENUM, NAME, TYPE, ATTRS)\n+#endif\n+\n+DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_FTZ_F32_F16, \"__hsail_ftz_f32_f16\",\n+\t\t       BT_FN_FLOAT_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_FTZ_F32, \"__hsail_ftz_f32\",\n+\t\t       BT_FN_FLOAT_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_FTZ_F64, \"__hsail_ftz_f64\",\n+\t\t       BT_FN_DOUBLE_DOUBLE, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_PUSH_FRAME, \"__hsail_alloca_push_frame\",\n+\t\t       BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_POP_FRAME, \"__hsail_alloca_pop_frame\",\n+\t\t       BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_SETWORKITEMID, \"__hsail_setworkitemid\",\n+\t\t       BT_FN_VOID_UINT32_UINT32_PTR, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_LAUNCH_WG_FUNC,\n+\t\t       \"__hsail_launch_wg_function\",\n+\t\t       BT_FN_VOID_PTR_PTR_PTR, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_LAUNCH_KERNEL,\n+\t\t       \"__hsail_launch_kernel\",\n+\t\t       BT_FN_VOID_PTR_PTR_PTR, ATTR_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_F32_TO_F16, \"__hsail_f32_to_f16\",\n+\t\t       BT_FN_UINT16_UINT32, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_F16_TO_F32, \"__hsail_f16_to_f32\",\n+\t\t       BT_FN_UINT32_UINT16, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+#ifndef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n+#define DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN(ENUM, HSAIL_DEST_TYPE, HSAIL_SRC_TYPE, \\\n+\tNAME, TYPE, ATTRS)\n+#endif\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U8_F32,\n+\t\t\t\tBRIG_TYPE_U8, BRIG_TYPE_F32,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_u8_f32\",\n+\t\t\t\tBT_FN_UINT8_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S8_F32,\n+\t\t\t\tBRIG_TYPE_S8, BRIG_TYPE_F32,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_s8_f32\",\n+\t\t\t\tBT_FN_INT8_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U16_F32,\n+\t\t\t\tBRIG_TYPE_U16, BRIG_TYPE_F32,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_u16_f32\",\n+\t\t\t\tBT_FN_UINT16_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S16_F32,\n+\t\t\t\tBRIG_TYPE_S16, BRIG_TYPE_F32,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_s16_f32\",\n+\t\t\t\tBT_FN_INT16_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U32_F32,\n+\t\t\t\tBRIG_TYPE_U32, BRIG_TYPE_F32,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_u32_f32\",\n+\t\t\t\tBT_FN_UINT32_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S32_F32,\n+\t\t\t\tBRIG_TYPE_S32, BRIG_TYPE_F32,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_s32_f32\",\n+\t\t\t\tBT_FN_INT_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U64_F32,\n+\t\t\t\tBRIG_TYPE_U64, BRIG_TYPE_F32,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_u64_f32\",\n+\t\t\t\tBT_FN_UINT64_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S64_F32,\n+\t\t\t\tBRIG_TYPE_S64, BRIG_TYPE_F32,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_s64_f32\",\n+\t\t\t\tBT_FN_LONG_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U8_F64,\n+\t\t\t\tBRIG_TYPE_U8, BRIG_TYPE_F64,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_u8_f64\",\n+\t\t\t\tBT_FN_UINT8_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S8_F64,\n+\t\t\t\tBRIG_TYPE_S8, BRIG_TYPE_F64,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_s8_f64\",\n+\t\t\t\tBT_FN_INT8_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U16_F64,\n+\t\t\t\tBRIG_TYPE_U16, BRIG_TYPE_F64,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_u16_f64\",\n+\t\t\t\tBT_FN_UINT16_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S16_F64,\n+\t\t\t\tBRIG_TYPE_S16, BRIG_TYPE_F64,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_s16_f64\",\n+\t\t\t\tBT_FN_INT16_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U32_F64,\n+\t\t\t\tBRIG_TYPE_U32, BRIG_TYPE_F64,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_u32_f64\",\n+\t\t\t\tBT_FN_UINT32_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S32_F64,\n+\t\t\t\tBRIG_TYPE_S32, BRIG_TYPE_F64,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_s32_f64\",\n+\t\t\t\tBT_FN_INT_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_U64_F64,\n+\t\t\t\tBRIG_TYPE_U64, BRIG_TYPE_F64,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_u64_f64\",\n+\t\t\t\tBT_FN_UINT64_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)\n+\n+DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN (BUILT_IN_HSAIL_CVT_ZEROI_SAT_S64_F64,\n+\t\t\t\tBRIG_TYPE_S64, BRIG_TYPE_F64,\n+\t\t       \t\t\"__hsail_cvt_zeroi_sat_s64_f64\",\n+\t\t\t\tBT_FN_LONG_FLOAT, ATTR_PURE_NOTHROW_LEAF_LIST)"}, {"sha": "dcea9d3ad0595afd4e4560075c60e5faf09fc632", "filename": "gcc/brig/ChangeLog", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2FChangeLog?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,42 @@\n+2017-01-24  Pekka J\u00e4\u00e4skel\u00e4inen <pekka@parmance.com>\n+\t    Martin Jambor  <mjambor@suse.cz>\n+\n+\t* Make-lang.in: New file.\n+\t* brig-builtins.h: Likewise.\n+\t* brig-c.h: Likewise.\n+\t* brig-lang.c: Likewise.\n+\t* brigspec.c: Likewise.\n+\t* config-lang.in: Likewise.\n+\t* lang-specs.h: Likewise.\n+\t* lang.opt: Likewise.\n+\t* brigfrontend/brig-arg-block-handler.cc: Likewise.\n+\t* brigfrontend/brig-atomic-inst-handler.cc: Likewise.\n+\t* brigfrontend/brig-basic-inst-handler.cc: Likewise.\n+\t* brigfrontend/brig-branch-inst-handler.cc: Likewise.\n+\t* brigfrontend/brig-cmp-inst-handler.cc: Likewise.\n+\t* brigfrontend/brig-code-entry-handler.cc: Likewise.\n+\t* brigfrontend/brig-code-entry-handler.h: Likewise.\n+\t* brigfrontend/brig-comment-handler.cc: Likewise.\n+\t* brigfrontend/brig-control-handler.cc: Likewise.\n+\t* brigfrontend/brig-copy-move-inst-handler.cc: Likewise.\n+\t* brigfrontend/brig-cvt-inst-handler.cc: Likewise.\n+\t* brigfrontend/brig-fbarrier-handler.cc: Likewise.\n+\t* brigfrontend/brig-function-handler.cc: Likewise.\n+\t* brigfrontend/brig-function.cc: Likewise.\n+\t* brigfrontend/brig-function.h: Likewise.\n+\t* brigfrontend/brig-inst-mod-handler.cc: Likewise.\n+\t* brigfrontend/brig-label-handler.cc: Likewise.\n+\t* brigfrontend/brig-lane-inst-handler.cc: Likewise.\n+\t* brigfrontend/brig-machine.c: Likewise.\n+\t* brigfrontend/brig-machine.h: Likewise.\n+\t* brigfrontend/brig-mem-inst-handler.cc: Likewise.\n+\t* brigfrontend/brig-module-handler.cc: Likewise.\n+\t* brigfrontend/brig-queue-inst-handler.cc: Likewise.\n+\t* brigfrontend/brig-seg-inst-handler.cc: Likewise.\n+\t* brigfrontend/brig-signal-inst-handler.cc: Likewise.\n+\t* brigfrontend/brig-to-generic.cc: Likewise.\n+\t* brigfrontend/brig-to-generic.h: Likewise.\n+\t* brigfrontend/brig-util.cc: Likewise.\n+\t* brigfrontend/brig-util.h: Likewise.\n+\t* brigfrontend/brig-variable-handler.cc: Likewise.\n+\t* brigfrontend/phsa.h: Likewise."}, {"sha": "b85b1b022514e1837c5ac393c5bb96c1ff049c26", "filename": "gcc/brig/Make-lang.in", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2FMake-lang.in?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,247 @@\n+# Make-lang.in -- Top level -*- makefile -*- fragment for gcc BRIG (HSAIL)\n+# frontend.\n+\n+# Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+# This file is part of GCC.\n+\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# This file provides the language dependent support in the main Makefile.\n+\n+# Installation name.\n+\n+GCCBRIG_INSTALL_NAME := $(shell echo gccbrig|sed '$(program_transform_name)')\n+GCCBRIG_TARGET_INSTALL_NAME := $(target_noncanonical)-$(shell echo gccbrig|sed \\\n+\t'$(program_transform_name)')\n+\n+# The name for selecting brig in LANGUAGES.\n+brig: brig1$(exeext)\n+\n+.PHONY: brig\n+\n+CFLAGS-brig/brigspec.o += $(DRIVER_DEFINES)\n+\n+GCCBRIG_OBJS = $(GCC_OBJS) brig/brigspec.o\n+gccbrig$(exeext): $(GCCBRIG_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a \\\n+\t$(LIBDEPS)\n+\t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n+\t  $(GCCBRIG_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a \\\n+\t  $(EXTRA_GCC_LIBS) $(LIBS)\n+\n+# The cross-compiler version.  This is built mainly as a signal to the\n+# brig.install-common target.  If this executable exists, it means that\n+# brig.all.cross was run.\n+gccbrig-cross$(exeext): gccbrig$(exeext)\n+\t-rm -f gccbrig-cross$(exeext)\n+\tcp gccbrig$(exeext) gccbrig-cross$(exeext)\n+\n+# Use strict warnings.\n+brig-warn = $(STRICT_WARN)\n+\n+BRIG_OBJS = \\\n+\tbrig/brig-lang.o \\\n+\tbrig/brig-code-entry-handler.o \\\n+\tbrig/brig-function-handler.o \\\n+\tbrig/brig-variable-handler.o \\\n+\tbrig/brig-fbarrier-handler.o \\\n+\tbrig/brig-label-handler.o \\\n+\tbrig/brig-comment-handler.o \\\n+\tbrig/brig-basic-inst-handler.o \\\n+\tbrig/brig-cvt-inst-handler.o \\\n+\tbrig/brig-seg-inst-handler.o \\\n+\tbrig/brig-lane-inst-handler.o \\\n+\tbrig/brig-queue-inst-handler.o \\\n+\tbrig/brig-copy-move-inst-handler.o \\\n+\tbrig/brig-signal-inst-handler.o \\\n+\tbrig/brig-atomic-inst-handler.o \\\n+\tbrig/brig-arg-block-handler.o \\\n+\tbrig/brig-control-handler.o \\\n+\tbrig/brig-cmp-inst-handler.o \\\n+\tbrig/brig-branch-inst-handler.o \\\n+\tbrig/brig-mem-inst-handler.o \\\n+\tbrig/brig-module-handler.o \\\n+\tbrig/brig-inst-mod-handler.o \\\n+\tbrig/brig-function.o \\\n+\tbrig/brig-to-generic.o \\\n+\tbrig/brig-machine.o \\\n+\tbrig/brig-util.o\n+\n+brig_OBJS = $(BRIG_OBJS) brig/brigspec.o\n+\n+# brig1$(exeext): $(BRIG_OBJS) attribs.o $(BACKEND) $(LIBDEPS)\n+# \t+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n+# \t      $(BRIG_OBJS) attribs.o $(BACKEND) $(LIBS) $(BACKENDLIBS)\n+\n+\n+brig1$(exeext): $(BRIG_OBJS) attribs.o $(BACKEND) $(LIBDEPS)\n+\t+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n+\t      $(BRIG_OBJS) attribs.o $(BACKEND) $(LIBS) \\\n+\t\t  $(BACKENDLIBS)\n+\n+# Documentation.\n+\n+GO_TEXI_FILES = \\\n+\tbrig/gccbrig.texi \\\n+\t$(gcc_docdir)/include/fdl.texi \\\n+\t$(gcc_docdir)/include/gpl_v3.texi \\\n+\t$(gcc_docdir)/include/gcc-common.texi \\\n+\tgcc-vers.texi\n+\n+# doc/gccbrig.info: $(BRIG_TEXI_FILES)\n+# \tif test \"x$(BUILD_INFO)\" = xinfo; then \\\n+# \t  rm -f doc/gccbrig.info*; \\\n+# \t  $(MAKEINFO) $(MAKEINFOFLAGS) -I $(gcc_docdir) \\\n+# \t\t-I $(gcc_docdir)/include -o $@ $<; \\\n+# \telse true; fi\n+\n+# doc/gccbrig.dvi: $(BRIG_TEXI_FILES)\n+# \t$(TEXI2DVI) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<\n+\n+# doc/gccbrig.pdf: $(BRIG_TEXI_FILES)\n+# \t$(TEXI2PDF) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<\n+\n+$(build_htmldir)/brig/index.html: $(BRIG_TEXI_FILES)\n+\t$(mkinstalldirs) $(@D)\n+\trm -f $(@D)/*\n+\t$(TEXI2HTML) -I $(gcc_docdir) -I $(gcc_docdir)/include \\\n+\t\t-I $(srcdir)/brig -o $(@D) $<\n+\n+# Build hooks.\n+\n+brig.all.cross: gccbrig-cross$(exeext)\n+brig.start.encap: gccbrig$(exeext)\n+brig.rest.encap:\n+#brig.info: doc/gccbrig.info\n+brig.info:\n+brig.dvi: doc/gccbrig.dvi\n+brig.pdf: doc/gccbrig.pdf\n+brig.html: $(build_htmldir)/brig/index.html\n+brig.srcinfo: #doc/gccbrig.info\n+#\t-cp -p $^ $(srcdir)/doc\n+\n+brig.srcextra:\n+brig.tags: force\n+\tcd $(srcdir)/brig; \\\n+\tetags -o TAGS.sub *.c *.h; \\\n+\tetags --include TAGS.sub --include ../TAGS.sub\n+brig.man:\n+\n+#brig.srcman: doc/gccbrig.1\n+#\t-cp -p $^ $(srcdir)/doc\n+\n+lang_checks += check-brig\n+\n+# Install hooks.\n+\n+brig.install-common: installdirs\n+\t-rm -f $(DESTDIR)$(bindir)/$(GCCBRIG_INSTALL_NAME)$(exeext)\n+\t$(INSTALL_PROGRAM) gccbrig$(exeext) \\\n+\t$(DESTDIR)$(bindir)/$(GCCBRIG_INSTALL_NAME)$(exeext)\n+\t-if test -f brig1$(exeext); then \\\n+\t  if test -f gccbrig-cross$(exeext); then \\\n+\t    :; \\\n+\t  else \\\n+\t    rm -f $(DESTDIR)$(bindir)/$(GCCBRIG_TARGET_INSTALL_NAME)$(exeext); \\\n+\t    ( cd $(DESTDIR)$(bindir) && \\\n+\t      $(LN) $(GCCBRIG_INSTALL_NAME)$(exeext) \\\n+\t      $(GCCBRIG_TARGET_INSTALL_NAME)$(exeext) ); \\\n+\t  fi; \\\n+\tfi\n+\n+brig.install-plugin:\n+\n+brig.install-info: #$(DESTDIR)$(infodir)/gccbrig.info\n+\n+brig.install-pdf: doc/gccbrig.pdf\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(pdfdir)\" || $(mkinstalldirs) \"$(DESTDIR)$(pdfdir)/gcc\"\n+\t@for p in doc/gccbrig.pdf; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  f=$(pdf__strip_dir) \\\n+\t  echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(pdfdir)/gcc/$$f'\"; \\\n+\t  $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(pdfdir)/gcc/$$f\"; \\\n+\tdone\n+\n+brig.install-html: $(build_htmldir)/brig\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(htmldir)\" || $(mkinstalldirs) \"$(DESTDIR)$(htmldir)\"\n+\t@for p in $(build_htmldir)/brig; do \\\n+\t  if test -f \"$$p\" || test -d \"$$p\"; then d=\"\"; else d=\"$(srcdir)/\"; \\\n+\t  fi; \\\n+\t  f=$(html__strip_dir) \\\n+\t  if test -d \"$$d$$p\"; then \\\n+\t    echo \" $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t    $(mkinstalldirs) \"$(DESTDIR)$(htmldir)/$$f\" || exit 1; \\\n+\t    echo \" $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t    $(INSTALL_DATA) \"$$d$$p\"/* \"$(DESTDIR)$(htmldir)/$$f\"; \\\n+\t  else \\\n+\t    echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t    $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(htmldir)/$$f\"; \\\n+\t  fi; \\\n+\tdone\n+\n+brig.install-man: #$(DESTDIR)$(man1dir)/$(GCCBRIG_INSTALL_NAME)$(man1ext)\n+\n+#$(DESTDIR)$(man1dir)/$(GCCBRIG_INSTALL_NAME)$(man1ext): doc/gccbrig.1 \\\n+#\tinstalldirs\n+#\t-rm -f $@\n+#\t-$(INSTALL_DATA) $< $@\n+#\t-chmod a-x $@\n+\n+brig.uninstall:\n+\trm -rf $(DESTDIR)$(bindir)/$(GCCBRIG_INSTALL_NAME)$(exeext)\n+\trm -rf $(DESTDIR)$(man1dir)/$(GCCBRIG_INSTALL_NAME)$(man1ext)\n+\trm -rf $(DESTDIR)$(bindir)/$(GCCBRIG_TARGET_INSTALL_NAME)$(exeext)\n+\trm -rf $(DESTDIR)$(infodir)/gccbrig.info*\n+\n+# Clean hooks.\n+\n+brig.mostlyclean:\n+\t-rm -f brig/*$(objext)\n+\t-rm -f brig/*$(coverageexts)\n+brig.clean:\n+brig.distclean:\n+brig.maintainer-clean:\n+\t-rm -f $(docobjdir)/gccbrig.1\n+\n+# Stage hooks.\n+\n+brig.stage1: stage1-start\n+\t-mv brig/*$(objext) stage1/brig\n+brig.stage2: stage2-start\n+\t-mv brig/*$(objext) stage2/brig\n+brig.stage3: stage3-start\n+\t-mv brig/*$(objext) stage3/brig\n+brig.stage4: stage4-start\n+\t-mv brig/*$(objext) stage4/brig\n+brig.stageprofile: stageprofile-start\n+\t-mv brig/*$(objext) stageprofile/brig\n+brig.stagefeedback: stagefeedback-start\n+\t-mv brig/*$(objext) stagefeedback/brig\n+\n+CFLAGS-brig/brig-lang.o += -DDEFAULT_TARGET_VERSION=\\\"$(version)\\\" \\\n+\t-DDEFAULT_TARGET_MACHINE=\\\"$(target_noncanonical)\\\"\n+\n+BRIGINCLUDES = -I $(srcdir)/brig -I ${HOME}/local/include \\\n+\t-I $(srcdir)/brig/brigfrontend\n+\n+brig/brig-machine.o: brig/brigfrontend/brig-machine.c\n+\t$(COMPILE) $(BRIGINCLUDES) $<\n+\t$(POSTCOMPILE)\n+\n+brig/%.o: brig/brigfrontend/%.cc\n+\t$(COMPILE) $(BRIGINCLUDES) $<\n+\t$(POSTCOMPILE)"}, {"sha": "ef9d11f9672c693b73475e3ce8e378e5e0691845", "filename": "gcc/brig/brig-builtins.h", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrig-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrig-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrig-builtins.h?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,99 @@\n+/* brig-builtins.h -- brig builtin definitions\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+enum built_in_attribute\n+{\n+#define DEF_ATTR_NULL_TREE(ENUM) ENUM,\n+#define DEF_ATTR_INT(ENUM, VALUE) ENUM,\n+#define DEF_ATTR_STRING(ENUM, VALUE) ENUM,\n+#define DEF_ATTR_IDENT(ENUM, STRING) ENUM,\n+#define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN) ENUM,\n+#include \"builtin-attrs.def\"\n+#undef DEF_ATTR_NULL_TREE\n+#undef DEF_ATTR_INT\n+#undef DEF_ATTR_STRING\n+#undef DEF_ATTR_IDENT\n+#undef DEF_ATTR_TREE_LIST\n+  ATTR_LAST\n+};\n+\n+/* Builtin types.  */\n+\n+enum brig_builtin_type\n+{\n+#define DEF_PRIMITIVE_TYPE(NAME, VALUE) NAME,\n+#define DEF_FUNCTION_TYPE_0(NAME, RETURN) NAME,\n+#define DEF_FUNCTION_TYPE_1(NAME, RETURN, ARG1) NAME,\n+#define DEF_FUNCTION_TYPE_2(NAME, RETURN, ARG1, ARG2) NAME,\n+#define DEF_FUNCTION_TYPE_3(NAME, RETURN, ARG1, ARG2, ARG3) NAME,\n+#define DEF_FUNCTION_TYPE_4(NAME, RETURN, ARG1, ARG2, ARG3, ARG4) NAME,\n+#define DEF_FUNCTION_TYPE_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) NAME,\n+#define DEF_FUNCTION_TYPE_6(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6) NAME,\n+#define DEF_FUNCTION_TYPE_7(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7) NAME,\n+#define DEF_FUNCTION_TYPE_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8) NAME,\n+#define DEF_FUNCTION_TYPE_9(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8, ARG9) NAME,\n+#define DEF_FUNCTION_TYPE_10(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10) NAME,\n+#define DEF_FUNCTION_TYPE_11(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_1(NAME, RETURN, ARG1) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_2(NAME, RETURN, ARG1, ARG2) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_3(NAME, RETURN, ARG1, ARG2, ARG3) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_4(NAME, RETURN, ARG1, ARG2, ARG3, ARG4) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG6) \\\n+\t\t\t\tNAME,\n+#define DEF_FUNCTION_TYPE_VAR_6(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\t ARG6) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_7(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\tARG6, ARG7) NAME,\n+#define DEF_POINTER_TYPE(NAME, TYPE) NAME,\n+#include \"builtin-types.def\"\n+#undef DEF_PRIMITIVE_TYPE\n+#undef DEF_FUNCTION_TYPE_0\n+#undef DEF_FUNCTION_TYPE_1\n+#undef DEF_FUNCTION_TYPE_2\n+#undef DEF_FUNCTION_TYPE_3\n+#undef DEF_FUNCTION_TYPE_4\n+#undef DEF_FUNCTION_TYPE_5\n+#undef DEF_FUNCTION_TYPE_6\n+#undef DEF_FUNCTION_TYPE_7\n+#undef DEF_FUNCTION_TYPE_8\n+#undef DEF_FUNCTION_TYPE_9\n+#undef DEF_FUNCTION_TYPE_10\n+#undef DEF_FUNCTION_TYPE_11\n+#undef DEF_FUNCTION_TYPE_VAR_0\n+#undef DEF_FUNCTION_TYPE_VAR_1\n+#undef DEF_FUNCTION_TYPE_VAR_2\n+#undef DEF_FUNCTION_TYPE_VAR_3\n+#undef DEF_FUNCTION_TYPE_VAR_4\n+#undef DEF_FUNCTION_TYPE_VAR_5\n+#undef DEF_FUNCTION_TYPE_VAR_6\n+#undef DEF_FUNCTION_TYPE_VAR_7\n+#undef DEF_POINTER_TYPE\n+  BT_LAST\n+};\n+\n+typedef enum brig_builtin_type builtin_type;"}, {"sha": "c4e2f2dae11fed1e424ee89b5da0e75b2a265ce4", "filename": "gcc/brig/brig-c.h", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrig-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrig-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrig-c.h?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,66 @@\n+/* brig-c.h -- Header file for brig input's gcc C interface.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef BRIG_BRIG_C_H\n+#define BRIG_BRIG_C_H\n+\n+#define BRIG_EXTERN_C\n+\n+#include \"machmode.h\"\n+\n+/* Functions defined in the Brig frontend proper called by the GCC\n+   interface.  */\n+\n+extern int brig_enable_dump (const char *);\n+extern int brig_enable_optimize (const char *);\n+\n+extern void brig_add_search_path (const char *);\n+\n+extern void brig_create_brigbrig (int int_type_size, int pointer_size,\n+\t\t\t\t  const char *pkgpath, const char *prefix,\n+\t\t\t\t  const char *relative_import_path);\n+\n+extern void brig_parse_input_files (const char **, unsigned int,\n+\t\t\t\t    bool only_check_syntax,\n+\t\t\t\t    bool require_return_statement);\n+extern void brig_write_globals (void);\n+\n+extern tree brig_type_for_size (unsigned int bits, int unsignedp);\n+extern tree brig_type_for_mode (enum machine_mode, int unsignedp);\n+\n+/* Functions defined in the GCC interface called by the Brig frontend\n+   proper.  */\n+\n+extern void brig_preserve_from_gc (tree);\n+\n+extern const char *brig_localize_identifier (const char *);\n+\n+extern unsigned int brig_field_alignment (tree);\n+\n+extern void brig_trampoline_info (unsigned int *size, unsigned int *alignment);\n+\n+extern void brig_imported_unsafe (void);\n+\n+extern void brig_write_export_data (const char *, unsigned int);\n+\n+extern const char *brig_read_export_data (int, off_t, char **, size_t *, int *);\n+\n+#endif /* !defined (BRIG_BRIG_C_H) */"}, {"sha": "1642a950270540a807ed971db0ecceffc0cacd8e", "filename": "gcc/brig/brig-lang.c", "status": "added", "additions": 807, "deletions": 0, "changes": 807, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrig-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrig-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrig-lang.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,807 @@\n+/* brig-lang.c -- brig (HSAIL) input gcc interface.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"ansidecl.h\"\n+#include \"coretypes.h\"\n+#include \"opts.h\"\n+#include \"tree.h\"\n+#include \"tree-iterator.h\"\n+#include \"print-tree.h\"\n+#include \"stringpool.h\"\n+#include \"basic-block.h\"\n+#include \"gimple-expr.h\"\n+#include \"gimplify.h\"\n+#include \"dumpfile.h\"\n+#include \"stor-layout.h\"\n+#include \"toplev.h\"\n+#include \"debug.h\"\n+#include \"options.h\"\n+#include \"flags.h\"\n+#include \"convert.h\"\n+#include \"diagnostic.h\"\n+#include \"langhooks.h\"\n+#include \"langhooks-def.h\"\n+#include \"target.h\"\n+#include \"vec.h\"\n+#include \"brigfrontend/brig-to-generic.h\"\n+#include \"machmode.h\"\n+#include \"fold-const.h\"\n+#include \"common/common-target.h\"\n+#include <mpfr.h>\n+#include \"brig-c.h\"\n+#include \"brig-builtins.h\"\n+\n+/* This file is based on Go frontent'd go-lang.c and gogo-tree.cc.  */\n+\n+/* If -v set.  */\n+\n+int gccbrig_verbose = 0;\n+\n+/* Language-dependent contents of a type.  */\n+\n+struct GTY (()) lang_type\n+{\n+  char dummy;\n+};\n+\n+/* Language-dependent contents of a decl.  */\n+\n+struct GTY ((variable_size)) lang_decl\n+{\n+  char dummy;\n+};\n+\n+/* Language-dependent contents of an identifier.  This must include a\n+   tree_identifier.  */\n+\n+struct GTY (()) lang_identifier\n+{\n+  struct tree_identifier common;\n+};\n+\n+/* The resulting tree type.  */\n+\n+union GTY ((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n+\t    chain_next (\"CODE_CONTAINS_STRUCT (TREE_CODE (&%h.generic), \"\n+\t\t\t\"TS_COMMON) ? ((union lang_tree_node *) TREE_CHAIN \"\n+\t\t\t\"(&%h.generic)) : NULL\"))) lang_tree_node\n+{\n+  union tree_node GTY ((tag (\"0\"), desc (\"tree_node_structure (&%h)\"))) generic;\n+  struct lang_identifier GTY ((tag (\"1\"))) identifier;\n+};\n+\n+/* We don't use language_function.  */\n+\n+struct GTY (()) language_function\n+{\n+  int dummy;\n+};\n+\n+\n+/* The option mask.  */\n+\n+static unsigned int\n+brig_langhook_option_lang_mask (void)\n+{\n+  return CL_BRIG;\n+}\n+\n+/* Initialize the options structure.  */\n+\n+static void\n+brig_langhook_init_options_struct (struct gcc_options *opts)\n+{\n+  /* Signed overflow is precisely defined.  */\n+  opts->x_flag_wrapv = 1;\n+\n+  /* If we set this to one, the whole program optimizations internalize\n+     all global variables, making them invisible to the dyn loader (and\n+     thus the HSA runtime implementation).  */\n+  opts->x_flag_whole_program = 0;\n+\n+  /* The builtin math functions should not set errno.  */\n+  opts->x_flag_errno_math = 0;\n+  opts->frontend_set_flag_errno_math = false;\n+\n+  opts->x_flag_exceptions = 0;\n+  opts->x_flag_non_call_exceptions = 0;\n+\n+  opts->x_flag_finite_math_only = 0;\n+  opts->x_flag_signed_zeros = 1;\n+}\n+\n+/* Handle Brig specific options.  Return 0 if we didn't do anything.  */\n+\n+static bool\n+brig_langhook_handle_option\n+  (size_t scode, const char *arg ATTRIBUTE_UNUSED,\n+  int value ATTRIBUTE_UNUSED, int kind ATTRIBUTE_UNUSED,\n+  location_t loc ATTRIBUTE_UNUSED,\n+  const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n+{\n+  enum opt_code code = (enum opt_code) scode;\n+  switch (code)\n+    {\n+    case OPT_v:\n+      gccbrig_verbose = 1;\n+      break;\n+    default:\n+      break;\n+    }\n+  return 1;\n+}\n+\n+/* Run after parsing options.  */\n+\n+static bool\n+brig_langhook_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n+{\n+  if (flag_excess_precision_cmdline == EXCESS_PRECISION_DEFAULT)\n+    flag_excess_precision_cmdline = EXCESS_PRECISION_STANDARD;\n+\n+  /* gccbrig casts pointers around like crazy, TBAA produces\n+\t   broken code if not force disabling it.  */\n+  flag_strict_aliasing = 0;\n+\n+  /* Returning false means that the backend should be used.  */\n+  return false;\n+}\n+\n+static size_t\n+get_file_size (FILE *file)\n+{\n+  size_t size;\n+  fseek (file, 0, SEEK_END);\n+  size = (size_t) ftell (file);\n+  fseek (file, 0, SEEK_SET);\n+  return size;\n+}\n+\n+static void\n+brig_langhook_parse_file (void)\n+{\n+  brig_to_generic brig_to_gen;\n+\n+  for (unsigned int i = 0; i < num_in_fnames; ++i)\n+    {\n+\n+      FILE *f;\n+      f = fopen (in_fnames[i], \"r\");\n+      size_t fsize = get_file_size (f);\n+      char *brig_blob = new char[fsize];\n+      if (fread (brig_blob, 1, fsize, f) != fsize)\n+\t{\n+\t  error (\"could not read the BRIG file\");\n+\t  exit (1);\n+\t}\n+      brig_to_gen.parse (brig_blob);\n+      fclose (f);\n+    }\n+\n+  brig_to_gen.write_globals ();\n+}\n+\n+static tree\n+brig_langhook_type_for_size (unsigned int bits,\n+\t\t\t     int unsignedp)\n+{\n+  /* Copied from go-lang.c  */\n+  tree type;\n+  if (unsignedp)\n+    {\n+      if (bits == INT_TYPE_SIZE)\n+        type = unsigned_type_node;\n+      else if (bits == CHAR_TYPE_SIZE)\n+        type = unsigned_char_type_node;\n+      else if (bits == SHORT_TYPE_SIZE)\n+        type = short_unsigned_type_node;\n+      else if (bits == LONG_TYPE_SIZE)\n+        type = long_unsigned_type_node;\n+      else if (bits == LONG_LONG_TYPE_SIZE)\n+        type = long_long_unsigned_type_node;\n+      else\n+        type = make_unsigned_type(bits);\n+    }\n+  else\n+    {\n+      if (bits == INT_TYPE_SIZE)\n+        type = integer_type_node;\n+      else if (bits == CHAR_TYPE_SIZE)\n+        type = signed_char_type_node;\n+      else if (bits == SHORT_TYPE_SIZE)\n+        type = short_integer_type_node;\n+      else if (bits == LONG_TYPE_SIZE)\n+        type = long_integer_type_node;\n+      else if (bits == LONG_LONG_TYPE_SIZE)\n+        type = long_long_integer_type_node;\n+      else\n+        type = make_signed_type(bits);\n+    }\n+  return type;\n+}\n+\n+static tree\n+brig_langhook_type_for_mode (enum machine_mode mode, int unsignedp)\n+{\n+  if (mode == TYPE_MODE (void_type_node))\n+    return void_type_node;\n+\n+  if (VECTOR_MODE_P (mode))\n+    {\n+      tree inner;\n+\n+      inner = brig_langhook_type_for_mode (GET_MODE_INNER (mode), unsignedp);\n+      if (inner != NULL_TREE)\n+\treturn build_vector_type_for_mode (inner, mode);\n+      gcc_unreachable ();\n+      return NULL_TREE;\n+    }\n+\n+  enum mode_class mc = GET_MODE_CLASS (mode);\n+  if (mc == MODE_FLOAT)\n+    {\n+      switch (GET_MODE_BITSIZE (mode))\n+\t{\n+\tcase 32:\n+\t  return float_type_node;\n+\tcase 64:\n+\t  return double_type_node;\n+\tdefault:\n+\t  /* We have to check for long double in order to support\n+\t     i386 excess precision.  */\n+\t  if (mode == TYPE_MODE (long_double_type_node))\n+\t    return long_double_type_node;\n+\n+\t  gcc_unreachable ();\n+\t  return NULL_TREE;\n+\t}\n+    }\n+  else if (mc == MODE_INT)\n+    return brig_langhook_type_for_size(GET_MODE_BITSIZE(mode), unsignedp);\n+  else\n+    {\n+      /* E.g., build_common_builtin_nodes () asks for modes/builtins\n+\t       we do not generate or need.  Just ignore them silently for now.\n+      */\n+      return NULL_TREE;\n+    }\n+  return NULL_TREE;\n+}\n+\n+static tree\n+brig_langhook_builtin_function (tree decl)\n+{\n+  return decl;\n+}\n+\n+static GTY(()) tree registered_builtin_types;\n+\n+static void\n+brig_langhook_register_builtin_type (tree type, const char *name)\n+{\n+  tree decl;\n+\n+  if (!TYPE_NAME (type))\n+    {\n+      decl = build_decl (UNKNOWN_LOCATION, TYPE_DECL,\n+\t\t\t get_identifier (name), type);\n+      DECL_ARTIFICIAL (decl) = 1;\n+      TYPE_NAME (type) = decl;\n+    }\n+\n+  registered_builtin_types = tree_cons (0, type, registered_builtin_types);\n+}\n+\n+\n+/* Return true if we are in the global binding level.  */\n+\n+static bool\n+brig_langhook_global_bindings_p (void)\n+{\n+  return current_function_decl == NULL_TREE;\n+}\n+\n+/* Push a declaration into the current binding level.  From Go: We can't\n+   usefully implement this since we don't want to convert from tree\n+   back to one of our internal data structures.  I think the only way\n+   this is used is to record a decl which is to be returned by\n+   getdecls, and we could implement it for that purpose if\n+   necessary.  */\n+\n+static tree\n+brig_langhook_pushdecl (tree decl ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n+/* This hook is used to get the current list of declarations as trees.\n+   From Go: We don't support that; instead we use the write_globals hook.\n+   This can't simply crash because it is called by -gstabs.  */\n+\n+static tree\n+brig_langhook_getdecls (void)\n+{\n+  return NULL;\n+}\n+\n+static int\n+brig_langhook_gimplify_expr (tree *expr_p, gimple_seq *pre_p ATTRIBUTE_UNUSED,\n+\t\t\t     gimple_seq *post_p ATTRIBUTE_UNUSED)\n+{\n+\n+  /* Strip off the static chain info that appears to function\n+     calls for some strange reason even though we don't add\n+     nested functions.  Maybe something wrong with the function\n+     declaration contexts? */\n+  if (TREE_CODE (*expr_p) == CALL_EXPR\n+      && CALL_EXPR_STATIC_CHAIN (*expr_p) != NULL_TREE)\n+    CALL_EXPR_STATIC_CHAIN (*expr_p) = NULL_TREE;\n+  return GS_UNHANDLED;\n+}\n+\n+static tree\n+brig_langhook_eh_personality (void)\n+{\n+  gcc_unreachable ();\n+}\n+\n+/* Functions called directly by the generic backend.\n+   Adapted from go-lang.c.  */\n+\n+tree\n+convert (tree type, tree expr)\n+{\n+  if (type == error_mark_node || expr == error_mark_node\n+      || TREE_TYPE (expr) == error_mark_node)\n+    return error_mark_node;\n+\n+  if (type == TREE_TYPE (expr))\n+    return expr;\n+\n+  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))\n+    return fold_convert (type, expr);\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case VOID_TYPE:\n+    case BOOLEAN_TYPE:\n+      return fold_convert (type, expr);\n+    case INTEGER_TYPE:\n+      return fold (convert_to_integer (type, expr));\n+    case REAL_TYPE:\n+      return fold (convert_to_real (type, expr));\n+    case VECTOR_TYPE:\n+      return fold (convert_to_vector (type, expr));\n+    case POINTER_TYPE:\n+      return build1 (VIEW_CONVERT_EXPR, type, convert (size_type_node, expr));\n+    default:\n+      break;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+static GTY (()) tree brig_gc_root;\n+\n+/* Preserve trees that we create from the garbage collector.  */\n+\n+void\n+brig_preserve_from_gc (tree t)\n+{\n+  brig_gc_root = tree_cons (NULL_TREE, t, brig_gc_root);\n+}\n+\n+/* Convert an identifier for use in an error message.  */\n+\n+const char *\n+brig_localize_identifier (const char *ident)\n+{\n+  return identifier_to_locale (ident);\n+}\n+\n+/* Built-in initialization code cribbed from lto-lang.c which cribbed it\n+   from c-common.c.  */\n+\n+\n+static GTY(()) tree built_in_attributes[(int) ATTR_LAST];\n+\n+\n+static GTY(()) tree builtin_types[(int) BT_LAST + 1];\n+\n+static GTY(()) tree string_type_node;\n+static GTY(()) tree const_string_type_node;\n+static GTY(()) tree wint_type_node;\n+static GTY(()) tree intmax_type_node;\n+static GTY(()) tree uintmax_type_node;\n+static GTY(()) tree signed_size_type_node;\n+\n+/* Flags needed to process builtins.def.  */\n+int flag_isoc94;\n+int flag_isoc99;\n+int flag_isoc11;\n+\n+static void\n+def_fn_type (builtin_type def, builtin_type ret, bool var, int n, ...)\n+{\n+  tree t;\n+  tree *args = XALLOCAVEC (tree, n);\n+  va_list list;\n+  int i;\n+  bool err = false;\n+\n+  va_start (list, n);\n+  for (i = 0; i < n; ++i)\n+    {\n+      builtin_type a = (builtin_type) va_arg (list, int);\n+      t = builtin_types[a];\n+      if (t == error_mark_node)\n+\terr = true;\n+      args[i] = t;\n+    }\n+  va_end (list);\n+\n+  t = builtin_types[ret];\n+  if (err)\n+    t = error_mark_node;\n+  if (t == error_mark_node)\n+    ;\n+  else if (var)\n+    t = build_varargs_function_type_array (t, n, args);\n+  else\n+    t = build_function_type_array (t, n, args);\n+\n+  builtin_types[def] = t;\n+}\n+\n+/* Used to help initialize the builtin-types.def table.  When a type of\n+   the correct size doesn't exist, use error_mark_node instead of NULL.\n+   The later results in segfaults even when a decl using the type doesn't\n+   get invoked.  */\n+\n+static tree\n+builtin_type_for_size (int size, bool unsignedp)\n+{\n+  tree type = brig_langhook_type_for_size (size, unsignedp);\n+  return type ? type : error_mark_node;\n+}\n+\n+/* Support for DEF_BUILTIN.  */\n+\n+static void\n+def_builtin_1 (enum built_in_function fncode, const char *name,\n+\t       enum built_in_class fnclass, tree fntype, tree libtype,\n+\t       bool both_p, bool fallback_p, bool nonansi_p,\n+\t       tree fnattrs, bool implicit_p)\n+{\n+  tree decl;\n+  const char *libname;\n+\n+  if (fntype == error_mark_node)\n+    return;\n+\n+  libname = name + strlen (\"__builtin_\");\n+  decl = add_builtin_function (name, fntype, fncode, fnclass,\n+\t\t\t       (fallback_p ? libname : NULL),\n+\t\t\t       fnattrs);\n+\n+  if (both_p\n+      && !flag_no_builtin\n+      && !(nonansi_p && flag_no_nonansi_builtin))\n+    add_builtin_function (libname, libtype, fncode, fnclass,\n+\t\t\t  NULL, fnattrs);\n+\n+  set_builtin_decl (fncode, decl, implicit_p);\n+}\n+\n+\n+/* Initialize the attribute table for all the supported builtins.  */\n+\n+static void\n+brig_init_attributes (void)\n+{\n+  /* Fill in the built_in_attributes array.  */\n+#define DEF_ATTR_NULL_TREE(ENUM)\t\t\t\t\\\n+  built_in_attributes[(int) ENUM] = NULL_TREE;\n+#define DEF_ATTR_INT(ENUM, VALUE)\t\t\t\t\\\n+  built_in_attributes[(int) ENUM] = build_int_cst (NULL_TREE, VALUE);\n+#define DEF_ATTR_STRING(ENUM, VALUE)\t\t\t\t\\\n+  built_in_attributes[(int) ENUM] = build_string (strlen (VALUE), VALUE);\n+#define DEF_ATTR_IDENT(ENUM, STRING)\t\t\t\t\\\n+  built_in_attributes[(int) ENUM] = get_identifier (STRING);\n+#define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN)\t\\\n+  built_in_attributes[(int) ENUM]\t\t\t\\\n+    = tree_cons (built_in_attributes[(int) PURPOSE],\t\\\n+\t\t built_in_attributes[(int) VALUE],\t\\\n+\t\t built_in_attributes[(int) CHAIN]);\n+#include \"builtin-attrs.def\"\n+#undef DEF_ATTR_NULL_TREE\n+#undef DEF_ATTR_INT\n+#undef DEF_ATTR_STRING\n+#undef DEF_ATTR_IDENT\n+#undef DEF_ATTR_TREE_LIST\n+}\n+\n+/* Create builtin types and functions.  VA_LIST_REF_TYPE_NODE and\n+   VA_LIST_ARG_TYPE_NODE are used in builtin-types.def.  */\n+\n+static void\n+brig_define_builtins (tree va_list_ref_type_node ATTRIBUTE_UNUSED,\n+\t\t     tree va_list_arg_type_node ATTRIBUTE_UNUSED)\n+{\n+#define DEF_PRIMITIVE_TYPE(ENUM, VALUE) \\\n+  builtin_types[ENUM] = VALUE;\n+#define DEF_FUNCTION_TYPE_0(ENUM, RETURN) \\\n+  def_fn_type (ENUM, RETURN, 0, 0);\n+#define DEF_FUNCTION_TYPE_1(ENUM, RETURN, ARG1) \\\n+  def_fn_type (ENUM, RETURN, 0, 1, ARG1);\n+#define DEF_FUNCTION_TYPE_2(ENUM, RETURN, ARG1, ARG2) \\\n+  def_fn_type (ENUM, RETURN, 0, 2, ARG1, ARG2);\n+#define DEF_FUNCTION_TYPE_3(ENUM, RETURN, ARG1, ARG2, ARG3) \\\n+  def_fn_type (ENUM, RETURN, 0, 3, ARG1, ARG2, ARG3);\n+#define DEF_FUNCTION_TYPE_4(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4) \\\n+  def_fn_type (ENUM, RETURN, 0, 4, ARG1, ARG2, ARG3, ARG4);\n+#define DEF_FUNCTION_TYPE_5(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5)\t\\\n+  def_fn_type (ENUM, RETURN, 0, 5, ARG1, ARG2, ARG3, ARG4, ARG5);\n+#define DEF_FUNCTION_TYPE_6(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6)\t\t\t\t\t\\\n+  def_fn_type (ENUM, RETURN, 0, 6, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);\n+#define DEF_FUNCTION_TYPE_7(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7)\t\t\t\t\t\\\n+  def_fn_type (ENUM, RETURN, 0, 7, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);\n+#define DEF_FUNCTION_TYPE_8(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8)\t\t\t\t\\\n+  def_fn_type (ENUM, RETURN, 0, 8, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n+\t       ARG7, ARG8);\n+#define DEF_FUNCTION_TYPE_9(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8, ARG9)\t\t\t\\\n+  def_fn_type (ENUM, RETURN, 0, 9, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n+\t       ARG7, ARG8, ARG9);\n+#define DEF_FUNCTION_TYPE_10(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10)\t\t \\\n+  def_fn_type (ENUM, RETURN, 0, 10, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t \\\n+\t       ARG7, ARG8, ARG9, ARG10);\n+#define DEF_FUNCTION_TYPE_11(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t     ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)\t \\\n+  def_fn_type (ENUM, RETURN, 0, 11, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t \\\n+\t       ARG7, ARG8, ARG9, ARG10, ARG11);\n+#define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN) \\\n+  def_fn_type (ENUM, RETURN, 1, 0);\n+#define DEF_FUNCTION_TYPE_VAR_1(ENUM, RETURN, ARG1) \\\n+  def_fn_type (ENUM, RETURN, 1, 1, ARG1);\n+#define DEF_FUNCTION_TYPE_VAR_2(ENUM, RETURN, ARG1, ARG2) \\\n+  def_fn_type (ENUM, RETURN, 1, 2, ARG1, ARG2);\n+#define DEF_FUNCTION_TYPE_VAR_3(ENUM, RETURN, ARG1, ARG2, ARG3) \\\n+  def_fn_type (ENUM, RETURN, 1, 3, ARG1, ARG2, ARG3);\n+#define DEF_FUNCTION_TYPE_VAR_4(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4) \\\n+  def_fn_type (ENUM, RETURN, 1, 4, ARG1, ARG2, ARG3, ARG4);\n+#define DEF_FUNCTION_TYPE_VAR_5(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) \\\n+  def_fn_type (ENUM, RETURN, 1, 5, ARG1, ARG2, ARG3, ARG4, ARG5);\n+#define DEF_FUNCTION_TYPE_VAR_6(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\t ARG6)\t\\\n+  def_fn_type (ENUM, RETURN, 1, 6, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);\n+#define DEF_FUNCTION_TYPE_VAR_7(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\tARG6, ARG7)\t\t\t\t\\\n+  def_fn_type (ENUM, RETURN, 1, 7, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);\n+#define DEF_POINTER_TYPE(ENUM, TYPE) \\\n+  builtin_types[(int) ENUM] = build_pointer_type (builtin_types[(int) TYPE]);\n+\n+#include \"builtin-types.def\"\n+\n+#undef DEF_PRIMITIVE_TYPE\n+#undef DEF_FUNCTION_TYPE_0\n+#undef DEF_FUNCTION_TYPE_1\n+#undef DEF_FUNCTION_TYPE_2\n+#undef DEF_FUNCTION_TYPE_3\n+#undef DEF_FUNCTION_TYPE_4\n+#undef DEF_FUNCTION_TYPE_5\n+#undef DEF_FUNCTION_TYPE_6\n+#undef DEF_FUNCTION_TYPE_7\n+#undef DEF_FUNCTION_TYPE_8\n+#undef DEF_FUNCTION_TYPE_9\n+#undef DEF_FUNCTION_TYPE_10\n+#undef DEF_FUNCTION_TYPE_11\n+#undef DEF_FUNCTION_TYPE_VAR_0\n+#undef DEF_FUNCTION_TYPE_VAR_1\n+#undef DEF_FUNCTION_TYPE_VAR_2\n+#undef DEF_FUNCTION_TYPE_VAR_3\n+#undef DEF_FUNCTION_TYPE_VAR_4\n+#undef DEF_FUNCTION_TYPE_VAR_5\n+#undef DEF_FUNCTION_TYPE_VAR_6\n+#undef DEF_FUNCTION_TYPE_VAR_7\n+#undef DEF_POINTER_TYPE\n+  builtin_types[(int) BT_LAST] = NULL_TREE;\n+\n+  brig_init_attributes ();\n+\n+#define DEF_BUILTIN(ENUM, NAME, CLASS, TYPE, LIBTYPE, BOTH_P, FALLBACK_P,\\\n+\t\t    NONANSI_P, ATTRS, IMPLICIT, COND)\t\t\t\\\n+    if (NAME && COND)\t\t\t\t\t\t\t\\\n+      def_builtin_1 (ENUM, NAME, CLASS, builtin_types[(int) TYPE],\t\\\n+\t\t     builtin_types[(int) LIBTYPE], BOTH_P, FALLBACK_P,\t\\\n+\t\t     NONANSI_P, built_in_attributes[(int) ATTRS], IMPLICIT);\n+\n+#undef DEF_HSAIL_BUILTIN\n+#define DEF_HSAIL_BUILTIN(ENUM, HSAIL_OPCODE, HSAIL_TYPE, NAME, TYPE, ATTRS) \\\n+  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n+              false, true, true, ATTRS, false, true)\n+\n+/* HSAIL atomic builtins do not have separate identifying opcodes.  */\n+\n+#undef DEF_HSAIL_ATOMIC_BUILTIN\n+#define DEF_HSAIL_ATOMIC_BUILTIN(ENUM, ATOMIC_OPCODE, HSAIL_TYPE, NAME, \\\n+       TYPE, ATTRS) \\\n+  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n+              false, true, true, ATTRS, false, true)\n+\n+/* HSAIL saturating arithmetics builtins.  */\n+\n+#undef DEF_HSAIL_SAT_BUILTIN\n+#define DEF_HSAIL_SAT_BUILTIN(ENUM, BRIG_OPCODE, HSAIL_TYPE, NAME, \\\n+       TYPE, ATTRS) \\\n+  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n+              false, true, true, ATTRS, false, true)\n+\n+/* HSAIL builtins used internally by the frontend.  */\n+\n+#undef DEF_HSAIL_INTR_BUILTIN\n+#define DEF_HSAIL_INTR_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n+  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n+              false, true, true, ATTRS, false, true)\n+\n+/* HSAIL saturated conversions.  */\n+\n+#undef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n+#define DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN(ENUM, HSAIL_DEST_TYPE, HSAIL_SRC_TYPE, \\\n+  NAME, TYPE, ATTRS) \\\n+  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n+              false, true, true, ATTRS, false, true)\n+\n+#include \"builtins.def\"\n+}\n+\n+/* Build nodes that would have be created by the C front-end; necessary\n+   for including builtin-types.def and ultimately builtins.def.  Borrowed\n+   from lto-lang.c.  */\n+\n+static void\n+brig_build_c_type_nodes (void)\n+{\n+  gcc_assert (void_type_node);\n+\n+  void_list_node = build_tree_list (NULL_TREE, void_type_node);\n+  string_type_node = build_pointer_type (char_type_node);\n+  const_string_type_node\n+    = build_pointer_type (build_qualified_type (char_type_node,\n+\t\t\t\t\t\tTYPE_QUAL_CONST));\n+\n+  if (strcmp (SIZE_TYPE, \"unsigned int\") == 0)\n+    {\n+      intmax_type_node = integer_type_node;\n+      uintmax_type_node = unsigned_type_node;\n+      signed_size_type_node = integer_type_node;\n+    }\n+  else if (strcmp (SIZE_TYPE, \"long unsigned int\") == 0)\n+    {\n+      intmax_type_node = long_integer_type_node;\n+      uintmax_type_node = long_unsigned_type_node;\n+      signed_size_type_node = long_integer_type_node;\n+    }\n+  else if (strcmp (SIZE_TYPE, \"long long unsigned int\") == 0)\n+    {\n+      intmax_type_node = long_long_integer_type_node;\n+      uintmax_type_node = long_long_unsigned_type_node;\n+      signed_size_type_node = long_long_integer_type_node;\n+    }\n+  else\n+    {\n+      int i;\n+\n+      signed_size_type_node = NULL_TREE;\n+      for (i = 0; i < NUM_INT_N_ENTS; i++)\n+\tif (int_n_enabled_p[i])\n+\t  {\n+\t    char name[50];\n+\t    sprintf (name, \"__int%d unsigned\", int_n_data[i].bitsize);\n+\n+\t    if (strcmp (name, SIZE_TYPE) == 0)\n+\t      {\n+\t\tintmax_type_node = int_n_trees[i].signed_type;\n+\t\tuintmax_type_node = int_n_trees[i].unsigned_type;\n+\t\tsigned_size_type_node = int_n_trees[i].signed_type;\n+\t      }\n+\t  }\n+      if (signed_size_type_node == NULL_TREE)\n+\tgcc_unreachable ();\n+    }\n+\n+  wint_type_node = unsigned_type_node;\n+  pid_type_node = integer_type_node;\n+}\n+\n+\n+static bool\n+brig_langhook_init (void)\n+{\n+  build_common_tree_nodes (false);\n+\n+  /* Builtin initialization related code borrowed from lto-lang.c.  */\n+  void_list_node = build_tree_list (NULL_TREE, void_type_node);\n+\n+  brig_build_c_type_nodes ();\n+\n+  if (TREE_CODE (va_list_type_node) == ARRAY_TYPE)\n+    {\n+      tree x = build_pointer_type (TREE_TYPE (va_list_type_node));\n+      brig_define_builtins (x, x);\n+    }\n+  else\n+    {\n+      brig_define_builtins (build_reference_type (va_list_type_node),\n+\t\t\t    va_list_type_node);\n+    }\n+\n+  targetm.init_builtins ();\n+  build_common_builtin_nodes ();\n+\n+  return true;\n+}\n+\n+#undef LANG_HOOKS_NAME\n+#undef LANG_HOOKS_INIT\n+#undef LANG_HOOKS_OPTION_LANG_MASK\n+#undef LANG_HOOKS_INIT_OPTIONS_STRUCT\n+#undef LANG_HOOKS_HANDLE_OPTION\n+#undef LANG_HOOKS_POST_OPTIONS\n+#undef LANG_HOOKS_PARSE_FILE\n+#undef LANG_HOOKS_TYPE_FOR_MODE\n+#undef LANG_HOOKS_TYPE_FOR_SIZE\n+#undef LANG_HOOKS_REGISTER_BUILTIN_TYPE\n+#undef LANG_HOOKS_BUILTIN_FUNCTION\n+#undef LANG_HOOKS_GLOBAL_BINDINGS_P\n+#undef LANG_HOOKS_PUSHDECL\n+#undef LANG_HOOKS_GETDECLS\n+#undef LANG_HOOKS_WRITE_GLOBALS\n+#undef LANG_HOOKS_GIMPLIFY_EXPR\n+#undef LANG_HOOKS_EH_PERSONALITY\n+\n+#define LANG_HOOKS_NAME \"GNU Brig\"\n+#define LANG_HOOKS_INIT brig_langhook_init\n+#define LANG_HOOKS_OPTION_LANG_MASK brig_langhook_option_lang_mask\n+#define LANG_HOOKS_INIT_OPTIONS_STRUCT brig_langhook_init_options_struct\n+#define LANG_HOOKS_HANDLE_OPTION brig_langhook_handle_option\n+#define LANG_HOOKS_POST_OPTIONS brig_langhook_post_options\n+#define LANG_HOOKS_PARSE_FILE brig_langhook_parse_file\n+#define LANG_HOOKS_TYPE_FOR_MODE brig_langhook_type_for_mode\n+#define LANG_HOOKS_TYPE_FOR_SIZE brig_langhook_type_for_size\n+#define LANG_HOOKS_REGISTER_BUILTIN_TYPE brig_langhook_register_builtin_type\n+#define LANG_HOOKS_BUILTIN_FUNCTION brig_langhook_builtin_function\n+#define LANG_HOOKS_GLOBAL_BINDINGS_P brig_langhook_global_bindings_p\n+#define LANG_HOOKS_PUSHDECL brig_langhook_pushdecl\n+#define LANG_HOOKS_GETDECLS brig_langhook_getdecls\n+#define LANG_HOOKS_GIMPLIFY_EXPR brig_langhook_gimplify_expr\n+#define LANG_HOOKS_EH_PERSONALITY brig_langhook_eh_personality\n+\n+struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+\n+#include \"gt-brig-brig-lang.h\"\n+#include \"gtype-brig.h\""}, {"sha": "99945ee63e122bf695ee303b9c7a80ff3fbbdafa", "filename": "gcc/brig/brigfrontend/brig-arg-block-handler.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-arg-block-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-arg-block-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-arg-block-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,66 @@\n+/* brig-arg-block-handler.cc -- brig arg block start/end directive handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"brig-code-entry-handler.h\"\n+#include \"tree-iterator.h\"\n+#include \"system.h\"\n+#include \"errors.h\"\n+\n+#include \"tree-pretty-print.h\"\n+#include \"print-tree.h\"\n+\n+size_t\n+brig_directive_arg_block_handler::operator () (const BrigBase *base)\n+{\n+  if (base->kind == BRIG_KIND_DIRECTIVE_ARG_BLOCK_START)\n+    {\n+      /* Initiate a new code block for the call site.  */\n+      tree stmt_list = alloc_stmt_list ();\n+      tree bind_expr\n+\t= build3 (BIND_EXPR, void_type_node, NULL, stmt_list, NULL);\n+      tree block = make_node (BLOCK);\n+      BIND_EXPR_BLOCK (bind_expr) = block;\n+      static int block_id = 0;\n+      BLOCK_NUMBER (block) = block_id++;\n+      TREE_USED (block) = 1;\n+      tree m_parentblock = DECL_INITIAL (m_parent.m_cf->m_func_decl);\n+      BLOCK_SUPERCONTEXT (block) = m_parentblock;\n+\n+      chainon (BLOCK_SUBBLOCKS (m_parentblock), block);\n+\n+      m_parent.m_cf->m_current_bind_expr = bind_expr;\n+      m_parent.m_cf->m_generating_arg_block = true;\n+    }\n+  else if (base->kind == BRIG_KIND_DIRECTIVE_ARG_BLOCK_END)\n+    {\n+      /* Restore the used bind expression back to the function\n+\t scope.  */\n+      tree new_bind_expr = m_parent.m_cf->m_current_bind_expr;\n+      m_parent.m_cf->m_current_bind_expr\n+\t= DECL_SAVED_TREE (m_parent.m_cf->m_func_decl);\n+      m_parent.m_cf->append_statement (new_bind_expr);\n+      m_parent.m_cf->m_generating_arg_block = false;\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  return base->byteCount;\n+}"}, {"sha": "87abab89b26ca931fa1dbb58d5ee78e3f359dfdf", "filename": "gcc/brig/brigfrontend/brig-atomic-inst-handler.cc", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-atomic-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-atomic-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-atomic-inst-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,265 @@\n+/* brig-atomic-inst-handler.cc -- brig atomic instruction handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <sstream>\n+\n+#include \"brig-code-entry-handler.h\"\n+#include \"brig-util.h\"\n+#include \"fold-const.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"print-tree.h\"\n+#include \"convert.h\"\n+#include \"langhooks.h\"\n+#include \"gimple-expr.h\"\n+#include \"stringpool.h\"\n+#include \"brig-builtins.h\"\n+\n+brig_atomic_inst_handler::brig_atomic_inst_handler (brig_to_generic &parent)\n+  : brig_code_entry_handler (parent)\n+{\n+}\n+\n+size_t\n+brig_atomic_inst_handler::generate_tree (const BrigInstBase &inst,\n+\t\t\t\t\t BrigAtomicOperation8_t atomic_opcode)\n+{\n+  tree_stl_vec operands = build_operands (inst);\n+  const int first_input\n+    = gccbrig_hsa_opcode_op_output_p (inst.opcode, 0) ? 1 : 0;\n+\n+  tree instr_type = gccbrig_tree_type_for_hsa_type (inst.type);\n+\n+  /* Utilize the atomic data types (from C++11 support) for implementing\n+     atomic operations.  */\n+\n+  tree atomic_type = build_qualified_type (instr_type, TYPE_QUAL_ATOMIC);\n+\n+  gcc_assert (atomic_type != NULL_TREE);\n+\n+  tree signal_handle = operands[first_input];\n+  tree atomic_ptype = build_pointer_type (atomic_type);\n+  tree casted_to_ptr = convert_to_pointer (atomic_ptype, signal_handle);\n+\n+  tree src0 = NULL_TREE;\n+  if (atomic_opcode != BRIG_ATOMIC_LD)\n+    src0 = operands[first_input + 1];\n+\n+  tree instr_expr = NULL_TREE;\n+\n+  tree ptype = build_pointer_type (instr_type);\n+  tree ptr = convert_to_pointer (ptype, operands[first_input]);\n+\n+  if (atomic_opcode == BRIG_ATOMIC_ST)\n+    {\n+      tree mem_ref = build2 (MEM_REF, atomic_type, casted_to_ptr,\n+\t\t\t     build_int_cst (atomic_ptype, 0));\n+      instr_expr = build2 (MODIFY_EXPR, atomic_type, mem_ref, src0);\n+    }\n+  else if (atomic_opcode == BRIG_ATOMIC_LD\n+\t   || (atomic_opcode >= BRIG_ATOMIC_WAIT_EQ\n+\t       && atomic_opcode <= BRIG_ATOMIC_WAITTIMEOUT_GTE))\n+    {\n+      tree mem_ref = build2 (MEM_REF, atomic_type, casted_to_ptr,\n+\t\t\t     build_int_cst (atomic_ptype, 0));\n+      /* signal_wait* instructions can return spuriously before the\n+\t condition becomes true.  Therefore it's legal to return\n+\t right away.  TODO: builtin calls which can be\n+\t implemented with a power efficient sleep-wait.  */\n+      instr_expr = mem_ref;\n+    }\n+  else if (atomic_opcode == BRIG_ATOMIC_CAS)\n+    {\n+      /* Special case for CAS due to the two args.  */\n+      tree built_in = NULL_TREE;\n+      switch (gccbrig_hsa_type_bit_size (inst.type))\n+\t{\n+\tcase 32:\n+\t  built_in\n+\t    = builtin_decl_explicit (BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_4);\n+\t  break;\n+\tcase 64:\n+\t  built_in\n+\t    = builtin_decl_explicit (BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_8);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      tree src1 = operands[first_input + 2];\n+\n+      tree src0_type\n+\t= TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (built_in))));\n+\n+      tree src1_type = TREE_VALUE\n+\t(TREE_CHAIN (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (built_in)))));\n+\n+      instr_expr = call_builtin (built_in, 3, instr_type, ptype, ptr,\n+\t\t\t\t src0_type, src0, src1_type, src1);\n+    }\n+  else\n+    {\n+      tree built_in = NULL_TREE;\n+      /* The rest of the builtins have the same number of parameters.\n+\t Generate a big if..else that finds the correct builtin\n+\t automagically from the def file.  */\n+#undef DEF_HSAIL_SAT_BUILTIN\n+#undef DEF_HSAIL_BUILTIN\n+#undef DEF_HSAIL_ATOMIC_BUILTIN\n+#undef DEF_HSAIL_INTR_BUILTIN\n+#undef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n+\n+#define DEF_HSAIL_ATOMIC_BUILTIN(ENUM, ATOMIC_OPCODE, HSAIL_TYPE,\t\\\n+\t\t\t\t NAME, TYPE, ATTRS)\t\t\t\\\n+      if (atomic_opcode == ATOMIC_OPCODE && inst.type == HSAIL_TYPE)\t\\\n+\tbuilt_in = builtin_decl_explicit (ENUM);\t\t\t\\\n+      else\n+#include \"brig-builtins.def\"\n+      switch (atomic_opcode)\n+\t{\n+\tcase BRIG_ATOMIC_ADD:\n+\t  switch (gccbrig_hsa_type_bit_size (inst.type))\n+\t    {\n+\t    case 32:\n+\t      built_in\n+\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_ADD_4);\n+\t      break;\n+\t    case 64:\n+\t      built_in\n+\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_ADD_8);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  break;\n+\tcase BRIG_ATOMIC_SUB:\n+\t  switch (gccbrig_hsa_type_bit_size (inst.type))\n+\t    {\n+\t    case 32:\n+\t      built_in\n+\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_SUB_4);\n+\t      break;\n+\t    case 64:\n+\t      built_in\n+\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_SUB_8);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  break;\n+\tcase BRIG_ATOMIC_AND:\n+\t  switch (gccbrig_hsa_type_bit_size (inst.type))\n+\t    {\n+\t    case 32:\n+\t      built_in\n+\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_AND_4);\n+\t      break;\n+\t    case 64:\n+\t      built_in\n+\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_AND_8);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  break;\n+\tcase BRIG_ATOMIC_XOR:\n+\t  switch (gccbrig_hsa_type_bit_size (inst.type))\n+\t    {\n+\t    case 32:\n+\t      built_in\n+\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_XOR_4);\n+\t      break;\n+\t    case 64:\n+\t      built_in\n+\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_XOR_8);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  break;\n+\tcase BRIG_ATOMIC_OR:\n+\t  switch (gccbrig_hsa_type_bit_size (inst.type))\n+\t    {\n+\t    case 32:\n+\t      built_in\n+\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_OR_4);\n+\t      break;\n+\t    case 64:\n+\t      built_in\n+\t\t= builtin_decl_explicit (BUILT_IN_SYNC_FETCH_AND_OR_8);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  break;\n+\tcase BRIG_ATOMIC_EXCH:\n+\t  switch (gccbrig_hsa_type_bit_size (inst.type))\n+\t    {\n+\t    case 32:\n+\t      built_in\n+\t\t= builtin_decl_explicit (BUILT_IN_SYNC_LOCK_TEST_AND_SET_4);\n+\t      break;\n+\t    case 64:\n+\t      built_in\n+\t\t= builtin_decl_explicit (BUILT_IN_SYNC_LOCK_TEST_AND_SET_8);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t};\n+\n+      gcc_assert (built_in != NULL_TREE);\n+      tree arg0_type\n+\t= TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (built_in))));\n+\n+      instr_expr = call_builtin (built_in, 2, instr_type, ptr_type_node,\n+\t\t\t\t ptr, arg0_type, src0);\n+\n+      /* We need a temp variable for the result, because otherwise\n+\t the gimplifier drops a necessary (unsigned to signed) cast in\n+\t the output assignment and fails a check later.  */\n+      tree tmp_var = create_tmp_var (arg0_type, \"builtin_out\");\n+      tree tmp_assign\n+\t= build2 (MODIFY_EXPR, TREE_TYPE (tmp_var), tmp_var, instr_expr);\n+      m_parent.m_cf->append_statement (tmp_assign);\n+      instr_expr = tmp_var;\n+    }\n+\n+  if (first_input > 0)\n+    build_output_assignment (inst, operands[0], instr_expr);\n+  else\n+    m_parent.m_cf->append_statement (instr_expr);\n+\n+  return inst.base.byteCount;\n+}\n+\n+size_t\n+brig_atomic_inst_handler::operator () (const BrigBase *base)\n+{\n+  const BrigInstAtomic *inst = (const BrigInstAtomic *) base;\n+  BrigAtomicOperation8_t atomic_opcode;\n+  atomic_opcode = inst->atomicOperation;\n+\n+  return generate_tree (inst->base, atomic_opcode);\n+}"}, {"sha": "638f818ef0b90e7553fb16dba20a35ddb09b3128", "filename": "gcc/brig/brigfrontend/brig-basic-inst-handler.cc", "status": "added", "additions": 865, "deletions": 0, "changes": 865, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-basic-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-basic-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-basic-inst-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,865 @@\n+/* brig-basic-inst-handler.cc -- brig basic instruction handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <sstream>\n+\n+#include \"brig-code-entry-handler.h\"\n+#include \"brig-util.h\"\n+\n+#include \"errors.h\"\n+#include \"gimple-expr.h\"\n+#include \"convert.h\"\n+#include \"print-tree.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"langhooks.h\"\n+#include \"stor-layout.h\"\n+#include \"diagnostic-core.h\"\n+#include \"brig-builtins.h\"\n+\n+brig_basic_inst_handler::brig_basic_inst_handler (brig_to_generic &parent)\n+  : brig_code_entry_handler (parent)\n+{\n+}\n+\n+class scalarized_sat_arithmetics : public tree_element_binary_visitor\n+{\n+public:\n+  scalarized_sat_arithmetics (const BrigInstBase &brig_inst)\n+    : m_brig_inst (brig_inst)\n+  {\n+    BrigType16_t element_type = brig_inst.type & BRIG_TYPE_BASE_MASK;\n+\n+#undef DEF_HSAIL_SAT_BUILTIN\n+#undef DEF_HSAIL_BUILTIN\n+#undef DEF_HSAIL_ATOMIC_BUILTIN\n+#undef DEF_HSAIL_INTR_BUILTIN\n+#undef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n+\n+#define DEF_HSAIL_SAT_BUILTIN(ENUM, BRIG_OPCODE, HSAIL_TYPE,\t\t\\\n+\t\t\t      NAME, TYPE, ATTRS)\t\t\t\\\n+    if (brig_inst.opcode == BRIG_OPCODE && element_type == HSAIL_TYPE)\t\\\n+      m_builtin = builtin_decl_explicit (ENUM);\t\t\t\t\\\n+    else\n+#include \"brig-builtins.def\"\n+      gcc_unreachable ();\n+  }\n+\n+  virtual tree\n+  visit_element (brig_code_entry_handler &, tree operand0, tree operand1)\n+  {\n+    /* Implement saturating arithmetics with scalar built-ins for now.\n+       TODO: emit GENERIC nodes for the simplest cases or at least\n+       emit vector built-ins.  */\n+    return call_builtin (m_builtin, 2, TREE_TYPE (operand0),\n+\t\t\t TREE_TYPE (operand0), operand0,\n+\t\t\t TREE_TYPE (operand1), operand1);\n+  }\n+  const BrigInstBase &m_brig_inst;\n+  tree m_builtin;\n+};\n+\n+/* Implements a vector shuffle.  ARITH_TYPE is the type of the vector,\n+   OPERANDS[0] is the first vector, OPERAND[1] the second vector and\n+   OPERANDS[2] the shuffle mask in HSAIL format.  The output is a VEC_PERM_EXPR\n+   that implements the shuffle as a GENERIC expression.  */\n+\n+tree\n+brig_basic_inst_handler::build_shuffle (tree arith_type,\n+\t\t\t\t\ttree_stl_vec &operands)\n+{\n+  tree element_type\n+    = get_unsigned_int_type (TREE_TYPE (TREE_TYPE (operands[0])));\n+\n+  /* Offsets to add to the mask values to convert from the\n+     HSAIL mask to VEC_PERM_EXPR masks.  VEC_PERM_EXPR mask\n+     assumes an index spanning from 0 to 2 times the vec\n+     width while HSAIL refers separately to two different\n+     input vectors, thus is not a \"full shuffle\" where all\n+     output elements can originate from any input element.  */\n+  vec<constructor_elt, va_gc> *mask_offset_vals = NULL;\n+\n+  vec<constructor_elt, va_gc> *input_mask_vals = NULL;\n+  size_t input_mask_element_size\n+    = exact_log2 (TYPE_VECTOR_SUBPARTS (arith_type));\n+\n+  /* Unpack the tightly packed mask elements to BIT_FIELD_REFs\n+     from which to construct the mask vector as understood by\n+     VEC_PERM_EXPR.  */\n+  tree mask_operand = add_temp_var (\"shuffle_mask\", operands[2]);\n+\n+  tree mask_element_type\n+    = build_nonstandard_integer_type (input_mask_element_size, true);\n+\n+  for (size_t i = 0; i < TYPE_VECTOR_SUBPARTS (arith_type); ++i)\n+    {\n+      tree mask_element\n+\t= build3 (BIT_FIELD_REF, mask_element_type, mask_operand,\n+\t\t  build_int_cst (unsigned_char_type_node,\n+\t\t\t\t input_mask_element_size),\n+\t\t  build_int_cst (unsigned_char_type_node,\n+\t\t\t\t i * input_mask_element_size));\n+\n+      mask_element = convert (element_type, mask_element);\n+\n+      tree offset;\n+      if (i < TYPE_VECTOR_SUBPARTS (arith_type) / 2)\n+\toffset = build_int_cst (element_type, 0);\n+      else\n+\toffset\n+\t  = build_int_cst (element_type, TYPE_VECTOR_SUBPARTS (arith_type));\n+\n+      CONSTRUCTOR_APPEND_ELT (mask_offset_vals, NULL_TREE, offset);\n+      CONSTRUCTOR_APPEND_ELT (input_mask_vals, NULL_TREE, mask_element);\n+    }\n+  tree mask_vec_type\n+    = build_vector_type (element_type, TYPE_VECTOR_SUBPARTS (arith_type));\n+\n+  tree mask_vec = build_constructor (mask_vec_type, input_mask_vals);\n+  tree offset_vec = build_constructor (mask_vec_type, mask_offset_vals);\n+\n+  tree mask = build2 (PLUS_EXPR, mask_vec_type, mask_vec, offset_vec);\n+\n+  tree perm = build3 (VEC_PERM_EXPR, TREE_TYPE (operands[0]), operands[0],\n+\t\t      operands[1], mask);\n+  return perm;\n+}\n+\n+/* Unpacks (extracts) a scalar element with an index in OPERANDS[1]\n+   from the vector expression in OPERANDS[0].  */\n+\n+tree\n+brig_basic_inst_handler::build_unpack (tree_stl_vec &operands)\n+{\n+  /* Implement the unpack with a shuffle that stores the unpacked\n+     element to the lowest bit positions in the dest.  After that\n+     a bitwise AND is used to clear the uppermost bits.  */\n+  tree src_element_type = TREE_TYPE (TREE_TYPE (operands[0]));\n+\n+  /* Perform the operations with a raw (unsigned int type) type.  */\n+  tree element_type = get_unsigned_int_type (src_element_type);\n+\n+  vec<constructor_elt, va_gc> *input_mask_vals = NULL;\n+  vec<constructor_elt, va_gc> *and_mask_vals = NULL;\n+\n+  size_t element_count = TYPE_VECTOR_SUBPARTS (TREE_TYPE (operands[0]));\n+  tree vec_type = build_vector_type (element_type, element_count);\n+\n+  for (size_t i = 0; i < element_count; ++i)\n+    {\n+      tree mask_element;\n+      if (i == 0)\n+\tmask_element = convert (element_type, operands[1]);\n+      else\n+\tmask_element = build_int_cst (element_type, 0);\n+\n+      CONSTRUCTOR_APPEND_ELT (input_mask_vals, NULL_TREE, mask_element);\n+\n+      tree and_mask_element;\n+      if (i == 0)\n+\tand_mask_element = build_int_cst (element_type, -1);\n+      else\n+\tand_mask_element = build_int_cst (element_type, 0);\n+      CONSTRUCTOR_APPEND_ELT (and_mask_vals, NULL_TREE, and_mask_element);\n+    }\n+\n+  tree mask_vec = build_constructor (vec_type, input_mask_vals);\n+\n+  tree and_mask_vec = build_constructor (vec_type, and_mask_vals);\n+\n+  tree perm = build3 (VEC_PERM_EXPR, vec_type,\n+\t\t      build_reinterpret_cast (vec_type, operands[0]),\n+\t\t      build_reinterpret_cast (vec_type, operands[0]), mask_vec);\n+\n+  tree cleared = build2 (BIT_AND_EXPR, vec_type, perm, and_mask_vec);\n+\n+  size_t s = int_size_in_bytes (TREE_TYPE (cleared)) * BITS_PER_UNIT;\n+  tree raw_type = build_nonstandard_integer_type (s, true);\n+\n+  tree as_int = build_reinterpret_cast (raw_type, cleared);\n+\n+  if (int_size_in_bytes (src_element_type) < 4)\n+    {\n+      if (INTEGRAL_TYPE_P (src_element_type))\n+\treturn extend_int (as_int, uint32_type_node, src_element_type);\n+    }\n+  return as_int;\n+}\n+\n+/* Packs (inserts) a scalar element in OPERANDS[1]\n+   to the vector in OPERANDS[0] at element position defined by\n+   OPERANDS[2].  */\n+\n+tree\n+brig_basic_inst_handler::build_pack (tree_stl_vec &operands)\n+{\n+  /* Implement using a bit level insertion.\n+     TODO: Reuse this for implementing 'bitinsert'\n+     without a builtin call.  */\n+\n+  size_t ecount = TYPE_VECTOR_SUBPARTS (TREE_TYPE (operands[0]));\n+  size_t vecsize = int_size_in_bytes (TREE_TYPE (operands[0])) * BITS_PER_UNIT;\n+  tree wide_type = build_nonstandard_integer_type (vecsize, 1);\n+\n+  tree src_vect = build_reinterpret_cast (wide_type, operands[0]);\n+  src_vect = add_temp_var (\"src_vect\", src_vect);\n+\n+  tree scalar = operands[1];\n+  scalar = add_temp_var (\"scalar\", convert_to_integer (wide_type, scalar));\n+\n+  tree pos = operands[2];\n+\n+  /* The upper bits of the position can contain garbage.\n+     Zero them for well-defined semantics.  */\n+  tree t = build2 (BIT_AND_EXPR, TREE_TYPE (pos), operands[2],\n+\t\t   build_int_cstu (TREE_TYPE (pos), ecount - 1));\n+  pos = add_temp_var (\"pos\", convert (wide_type, t));\n+\n+  tree element_type = TREE_TYPE (TREE_TYPE (operands[0]));\n+  size_t element_width = int_size_in_bytes (element_type) * BITS_PER_UNIT;\n+  tree ewidth = build_int_cstu (wide_type, element_width);\n+\n+  tree bitoffset = build2 (MULT_EXPR, wide_type, ewidth, pos);\n+  bitoffset = add_temp_var (\"offset\", bitoffset);\n+\n+  uint64_t mask_int\n+    = element_width == 64 ? (uint64_t) -1 : ((uint64_t) 1 << element_width) - 1;\n+\n+  tree mask = build_int_cstu (wide_type, mask_int);\n+\n+  mask = add_temp_var (\"mask\", convert_to_integer (wide_type, mask));\n+\n+  tree clearing_mask\n+    = build1 (BIT_NOT_EXPR, wide_type,\n+\t      build2 (LSHIFT_EXPR, wide_type, mask, bitoffset));\n+\n+  tree zeroed_element\n+    = build2 (BIT_AND_EXPR, wide_type, src_vect, clearing_mask);\n+\n+  /* TODO: Is the AND necessary: does HSA define what\n+     happens if the upper bits in the inserted element are not\n+     zero? */\n+  tree element_in_position\n+    = build2 (LSHIFT_EXPR, wide_type,\n+\t      build2 (BIT_AND_EXPR, wide_type, scalar, mask), bitoffset);\n+\n+  tree inserted\n+    = build2 (BIT_IOR_EXPR, wide_type, zeroed_element, element_in_position);\n+  return inserted;\n+}\n+\n+/* Implement the unpack{lo,hi}.  BRIG_OPCODE should tell which one and\n+   ARITH_TYPE describe the type of the vector arithmetics.\n+   OPERANDS[0] and OPERANDS[1] are the input vectors.  */\n+\n+tree\n+brig_basic_inst_handler::build_unpack_lo_or_hi (BrigOpcode16_t brig_opcode,\n+\t\t\t\t\t\ttree arith_type,\n+\t\t\t\t\t\ttree_stl_vec &operands)\n+{\n+  tree element_type = get_unsigned_int_type (TREE_TYPE (arith_type));\n+  tree mask_vec_type\n+    = build_vector_type (element_type, TYPE_VECTOR_SUBPARTS (arith_type));\n+\n+  size_t element_count = TYPE_VECTOR_SUBPARTS (arith_type);\n+  vec<constructor_elt, va_gc> *input_mask_vals = NULL;\n+\n+  size_t offset = (brig_opcode == BRIG_OPCODE_UNPACKLO) ? 0 : element_count / 2;\n+\n+  for (size_t i = 0; i < element_count / 2; ++i)\n+    {\n+      CONSTRUCTOR_APPEND_ELT (input_mask_vals, NULL_TREE,\n+\t\t\t      build_int_cst (element_type, offset + i));\n+      CONSTRUCTOR_APPEND_ELT (input_mask_vals, NULL_TREE,\n+\t\t\t      build_int_cst (element_type,\n+\t\t\t\t\t     offset + i + element_count));\n+    }\n+\n+  tree mask_vec = build_constructor (mask_vec_type, input_mask_vals);\n+\n+  tree perm = build3 (VEC_PERM_EXPR, TREE_TYPE (operands[0]), operands[0],\n+\t\t      operands[1], mask_vec);\n+  return perm;\n+}\n+\n+/* Builds a basic instruction expression from a BRIG instruction.  BRIG_OPCODE\n+   is the opcode, BRIG_TYPE the brig type of the instruction, ARITH_TYPE the\n+   desired tree type for the instruction, and OPERANDS the instruction's\n+   input operands already converted to tree nodes.  */\n+\n+tree\n+brig_basic_inst_handler::build_inst_expr (BrigOpcode16_t brig_opcode,\n+\t\t\t\t\t  BrigType16_t brig_type,\n+\t\t\t\t\t  tree arith_type,\n+\t\t\t\t\t  tree_stl_vec &operands)\n+{\n+  tree_code opcode = get_tree_code_for_hsa_opcode (brig_opcode, brig_type);\n+\n+  BrigType16_t inner_type = brig_type & BRIG_TYPE_BASE_MASK;\n+\n+  tree instr_inner_type\n+    = VECTOR_TYPE_P (arith_type) ? TREE_TYPE (arith_type) : arith_type;\n+\n+  if (opcode == RSHIFT_EXPR || opcode == LSHIFT_EXPR)\n+    {\n+      /* HSA defines modulo/clipping behavior for shift amounts larger\n+\t than the bit width, while tree.def leaves it undefined.\n+\t We need to mask the upper bits to ensure the defined behavior.  */\n+      tree scalar_mask\n+\t= build_int_cst (instr_inner_type,\n+\t\t\t gccbrig_hsa_type_bit_size (inner_type) - 1);\n+\n+      tree mask = VECTOR_TYPE_P (arith_type)\n+\t\t    ? build_vector_from_val (arith_type, scalar_mask)\n+\t\t    : scalar_mask;\n+\n+      /* The shift amount is a scalar, broadcast it to produce\n+\t a vector shift.  */\n+      if (VECTOR_TYPE_P (arith_type))\n+\toperands[1] = build_vector_from_val (arith_type, operands[1]);\n+      operands[1] = build2 (BIT_AND_EXPR, arith_type, operands[1], mask);\n+    }\n+\n+  size_t input_count = operands.size ();\n+  size_t output_count = gccbrig_hsa_opcode_op_output_p (brig_opcode, 0) ?\n+    1 : 0;\n+\n+  if (opcode == TREE_LIST)\n+    {\n+      /* There was no direct GENERIC opcode for the instruction;\n+\t try to emulate it with a chain of GENERIC nodes.  */\n+      if (brig_opcode == BRIG_OPCODE_MAD || brig_opcode == BRIG_OPCODE_MAD24)\n+\t{\n+\t  /* There doesn't seem to be a \"standard\" MAD built-in in gcc so let's\n+\t     use a chain of multiply + add for now (double rounding method).\n+\t     It should be easier for optimizers than a custom built-in call\n+\t     WIDEN_MULT_EXPR is close, but requires a double size result\n+\t     type.  */\n+\t  tree mult_res\n+\t    = build2 (MULT_EXPR, arith_type, operands[0], operands[1]);\n+\t  return build2 (PLUS_EXPR, arith_type, mult_res, operands[2]);\n+\t}\n+      else if (brig_opcode == BRIG_OPCODE_MAD24HI)\n+\t{\n+\t  tree mult_res\n+\t    = build2 (MULT_HIGHPART_EXPR, arith_type, operands[0], operands[1]);\n+\t  return build2 (PLUS_EXPR, arith_type, mult_res, operands[2]);\n+\t}\n+      else if (brig_opcode == BRIG_OPCODE_SHUFFLE)\n+\t{\n+\t  return build_shuffle (arith_type, operands);\n+\t}\n+      else if (brig_opcode == BRIG_OPCODE_UNPACKLO\n+\t       || brig_opcode == BRIG_OPCODE_UNPACKHI)\n+\t{\n+\t  return build_unpack_lo_or_hi (brig_opcode, arith_type, operands);\n+\t}\n+      else if (brig_opcode == BRIG_OPCODE_UNPACK)\n+\t{\n+\t  return build_unpack (operands);\n+\t}\n+      else if (brig_opcode == BRIG_OPCODE_PACK)\n+\t{\n+\t  return build_pack (operands);\n+\t}\n+      else if (brig_opcode == BRIG_OPCODE_NRSQRT)\n+\t{\n+\t  /* Implement as 1.0/sqrt (x) and assume gcc instruction selects to\n+\t     native ISA other than a division, if available.\n+\t     TODO: this will happen only with unsafe math optimizations\n+\t     on which cannot be used in general to remain HSAIL compliant.\n+\t     Perhaps a builtin call would be better option here.  */\n+\t  return build2 (RDIV_EXPR, arith_type, build_one_cst (arith_type),\n+\t\t\t expand_or_call_builtin (BRIG_OPCODE_SQRT, brig_type,\n+\t\t\t\t\t\t arith_type, operands));\n+\t}\n+      else if (brig_opcode == BRIG_OPCODE_NRCP)\n+\t{\n+\t  /* Implement as 1.0/x and assume gcc instruction selects to\n+\t     native ISA other than a division, if available.  */\n+\t  return build2 (RDIV_EXPR, arith_type, build_one_cst (arith_type),\n+\t\t\t operands[0]);\n+\t}\n+      else if (brig_opcode == BRIG_OPCODE_LANEID\n+\t       || brig_opcode == BRIG_OPCODE_MAXWAVEID\n+\t       || brig_opcode == BRIG_OPCODE_WAVEID)\n+\t{\n+\t  /* Assuming WAVESIZE 1 (for now), therefore LANEID, WAVEID and\n+\t     MAXWAVEID always return 0.  */\n+\t  return build_zero_cst (arith_type);\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if (opcode == CALL_EXPR)\n+    return expand_or_call_builtin (brig_opcode, brig_type, arith_type,\n+\t\t\t\t   operands);\n+  else if (output_count == 1)\n+    {\n+      if (input_count == 1)\n+\t{\n+\t  if (opcode == MODIFY_EXPR)\n+\t    return operands[0];\n+\t  else\n+\t    return build1 (opcode, arith_type, operands[0]);\n+\t}\n+      else if (input_count == 2)\n+\treturn build2 (opcode, arith_type, operands[0], operands[1]);\n+      else if (input_count == 3)\n+\treturn build3 (opcode, arith_type, operands[0], operands[1],\n+\t\t       operands[2]);\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handles the basic instructions, including packed instructions. Deals\n+   with the different packing modes by unpacking/packing the wanted\n+   elements.  Delegates most of the instruction cases to build_inst_expr(). */\n+\n+size_t\n+brig_basic_inst_handler::operator () (const BrigBase *base)\n+{\n+  const BrigInstBase *brig_inst = (const BrigInstBase *) base;\n+\n+  tree_stl_vec operands = build_operands (*brig_inst);\n+\n+  size_t output_count\n+    = gccbrig_hsa_opcode_op_output_p (brig_inst->opcode, 0) ? 1 : 0;\n+  size_t input_count\n+    = operands.size () == 0 ? 0 : (operands.size () - output_count);\n+\n+  gcc_assert (output_count == 0 || output_count == 1);\n+\n+  tree_stl_vec::iterator first_input_i = operands.begin ();\n+  if (output_count > 0 && operands.size () > 0)\n+    ++first_input_i;\n+\n+  tree_stl_vec in_operands;\n+  in_operands.assign (first_input_i, operands.end ());\n+\n+  BrigType16_t brig_inst_type = brig_inst->type;\n+\n+  if (brig_inst->opcode == BRIG_OPCODE_NOP)\n+    return base->byteCount;\n+  else if (brig_inst->opcode == BRIG_OPCODE_FIRSTBIT\n+\t   || brig_inst->opcode == BRIG_OPCODE_LASTBIT\n+\t   || brig_inst->opcode == BRIG_OPCODE_SAD)\n+    /* These instructions are reported to be always 32b in HSAIL, but we want\n+       to treat them according to their input argument's type to select the\n+       correct instruction/builtin.  */\n+    brig_inst_type\n+      = gccbrig_tree_type_to_hsa_type (TREE_TYPE (in_operands[0]));\n+\n+  tree instr_type = gccbrig_tree_type_for_hsa_type (brig_inst_type);\n+\n+  if (!instr_type)\n+    {\n+      gcc_unreachable ();\n+      return base->byteCount;\n+    }\n+\n+  bool is_vec_instr = hsa_type_packed_p (brig_inst_type);\n+\n+  size_t element_size_bits;\n+  size_t element_count;\n+\n+  if (is_vec_instr)\n+    {\n+      BrigType16_t brig_element_type = brig_inst_type & BRIG_TYPE_BASE_MASK;\n+      element_size_bits = gccbrig_hsa_type_bit_size (brig_element_type);\n+      element_count = gccbrig_hsa_type_bit_size (brig_inst_type)\n+\t/ gccbrig_hsa_type_bit_size (brig_element_type);\n+    }\n+  else\n+    {\n+      element_size_bits = gccbrig_hsa_type_bit_size (brig_inst_type);\n+      element_count = 1;\n+    }\n+\n+  /* The actual arithmetics type that should be performed with the\n+     operation.  This is not always the same as the original BRIG\n+     opcode's type due to implicit conversions of storage-only f16.  */\n+  tree arith_type = gccbrig_is_bit_operation (brig_inst->opcode)\n+\t\t      ? gccbrig_tree_type_for_hsa_type (brig_inst_type)\n+\t\t      : get_tree_expr_type_for_hsa_type (brig_inst_type);\n+\n+  tree instr_expr = NULL_TREE;\n+\n+  BrigPack8_t p = BRIG_PACK_NONE;\n+  if (brig_inst->base.kind == BRIG_KIND_INST_MOD)\n+    p = ((const BrigInstMod *) brig_inst)->pack;\n+  else if (brig_inst->base.kind == BRIG_KIND_INST_CMP)\n+    p = ((const BrigInstCmp *) brig_inst)->pack;\n+\n+  if (p == BRIG_PACK_PS || p == BRIG_PACK_PSSAT)\n+    in_operands[1] = build_lower_element_broadcast (in_operands[1]);\n+  else if (p == BRIG_PACK_SP || p == BRIG_PACK_SPSAT)\n+    in_operands[0] = build_lower_element_broadcast (in_operands[0]);\n+\n+  tree_code opcode\n+    = get_tree_code_for_hsa_opcode (brig_inst->opcode, brig_inst_type);\n+\n+  if (p >= BRIG_PACK_PPSAT && p <= BRIG_PACK_PSAT)\n+    {\n+      scalarized_sat_arithmetics sat_arith (*brig_inst);\n+      gcc_assert (input_count == 2);\n+      instr_expr = sat_arith (*this, in_operands[0], in_operands[1]);\n+    }\n+  else if (opcode == RETURN_EXPR)\n+    {\n+      if (m_parent.m_cf->m_is_kernel)\n+\t{\n+\t  tree goto_stmt\n+\t    = build1 (GOTO_EXPR, void_type_node, m_parent.m_cf->m_exit_label);\n+\t  m_parent.m_cf->append_statement (goto_stmt);\n+\t  return base->byteCount;\n+\t}\n+      else\n+\t{\n+\t  m_parent.m_cf->append_return_stmt ();\n+\t  return base->byteCount;\n+\t}\n+    }\n+  else if (opcode == MULT_HIGHPART_EXPR &&\n+\t   is_vec_instr && element_size_bits < 64)\n+    {\n+      /* MULT_HIGHPART_EXPR works only on target dependent vector sizes and\n+\t even the scalars do not seem to work at least for char elements.\n+\n+\t Let's fall back to scalarization and promotion of the vector elements\n+\t to larger types with the MULHI computed as a regular MUL.\n+\t MULHI for 2x64b seems to work with the Intel CPUs I've tested so\n+\t that is passed on for vector processing so there is no need for\n+\t 128b scalar arithmetics.\n+\n+\t This is not modular as these type of things do not belong to the\n+\t frontend, there should be a legalization phase before the backend\n+\t that figures out the best way to compute the MULHI for any\n+\t integer vector datatype.\n+\n+\t TODO: promote to larger vector types instead.  For example\n+\t MULT_HIGHPART_EXPR with s8x8 doesn't work, but s16x8 seems to at least\n+\t with my x86-64.\n+      */\n+      tree_stl_vec operand0_elements;\n+      if (input_count > 0)\n+\tunpack (in_operands[0], operand0_elements);\n+\n+      tree_stl_vec operand1_elements;\n+      if (input_count > 1)\n+\tunpack (in_operands[1], operand1_elements);\n+\n+      tree_stl_vec result_elements;\n+\n+      tree scalar_type = TREE_TYPE (arith_type);\n+      BrigType16_t element_type = brig_inst_type & BRIG_TYPE_BASE_MASK;\n+      tree promoted_type = short_integer_type_node;\n+      switch (element_type)\n+\t{\n+\tcase BRIG_TYPE_S8:\n+\t  promoted_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_S16);\n+\t  break;\n+\tcase BRIG_TYPE_U8:\n+\t  promoted_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U16);\n+\t  break;\n+\tcase BRIG_TYPE_S16:\n+\t  promoted_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_S32);\n+\t  break;\n+\tcase BRIG_TYPE_U16:\n+\t  promoted_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U32);\n+\t  break;\n+\tcase BRIG_TYPE_S32:\n+\t  promoted_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_S64);\n+\t  break;\n+\tcase BRIG_TYPE_U32:\n+\t  promoted_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U64);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      size_t promoted_type_size = int_size_in_bytes (promoted_type) * 8;\n+\n+      for (size_t i = 0; i < TYPE_VECTOR_SUBPARTS (arith_type); ++i)\n+\t{\n+\t  tree operand0 = convert (promoted_type, operand0_elements.at (i));\n+\t  tree operand1 = convert (promoted_type, operand1_elements.at (i));\n+\n+\t  tree scalar_expr\n+\t    = build2 (MULT_EXPR, promoted_type, operand0, operand1);\n+\n+\t  scalar_expr\n+\t    = build2 (RSHIFT_EXPR, promoted_type, scalar_expr,\n+\t\t      build_int_cstu (promoted_type, promoted_type_size / 2));\n+\n+\t  result_elements.push_back (convert (scalar_type, scalar_expr));\n+\t}\n+      instr_expr = pack (result_elements);\n+    }\n+  else\n+    {\n+      /* 'class' is always of b1 type, let's consider it by its\n+\t float type when building the instruction to find the\n+\t correct builtin.  */\n+      if (brig_inst->opcode == BRIG_OPCODE_CLASS)\n+\tbrig_inst_type = ((const BrigInstSourceType *) base)->sourceType;\n+      instr_expr = build_inst_expr (brig_inst->opcode, brig_inst_type,\n+\t\t\t\t     arith_type, in_operands);\n+    }\n+\n+  if (instr_expr == NULL_TREE)\n+    {\n+      gcc_unreachable ();\n+      return base->byteCount;\n+    }\n+\n+  if (p == BRIG_PACK_SS || p == BRIG_PACK_S || p == BRIG_PACK_SSSAT\n+      || p == BRIG_PACK_SSAT)\n+    {\n+      /* In case of _s_ or _ss_, select only the lowest element\n+\t from the new input to the output.  We could extract\n+\t the element and use a scalar operation, but try\n+\t to keep data in vector registers as much as possible\n+\t to avoid copies between scalar and vector datapaths.  */\n+      tree old_value;\n+      tree half_storage_type = gccbrig_tree_type_for_hsa_type (brig_inst_type);\n+      bool is_fp16_operation\n+\t= (brig_inst_type & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16\n+\t&& !gccbrig_is_bit_operation (brig_inst->opcode);\n+\n+      if (is_fp16_operation)\n+\told_value = build_h2f_conversion\n+\t  (build_reinterpret_cast (half_storage_type, operands[0]));\n+      else\n+\told_value\n+\t  = build_reinterpret_cast (TREE_TYPE (instr_expr), operands[0]);\n+\n+      size_t esize = is_fp16_operation ? 32 : element_size_bits;\n+\n+      /* Construct a permutation mask where other elements than the lowest one\n+\t is picked from the old_value.  */\n+      tree mask_inner_type = build_nonstandard_integer_type (esize, 1);\n+      vec<constructor_elt, va_gc> *constructor_vals = NULL;\n+      for (size_t i = 0; i < element_count; ++i)\n+\t{\n+\t  tree cst;\n+\n+\t  if (i == 0)\n+\t    cst = build_int_cstu (mask_inner_type, element_count);\n+\t  else\n+\t    cst = build_int_cstu (mask_inner_type, i);\n+\t  CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, cst);\n+\t}\n+      tree mask_vec_type = build_vector_type (mask_inner_type, element_count);\n+      tree mask = build_vector_from_ctor (mask_vec_type, constructor_vals);\n+\n+      tree new_value = create_tmp_var (TREE_TYPE (instr_expr), \"new_output\");\n+      tree assign\n+\t= build2 (MODIFY_EXPR, TREE_TYPE (instr_expr), new_value, instr_expr);\n+      m_parent.m_cf->append_statement (assign);\n+\n+      instr_expr\n+\t= build3 (VEC_PERM_EXPR, arith_type, old_value, new_value, mask);\n+\n+      tree lower_output = create_tmp_var (TREE_TYPE (instr_expr), \"s_output\");\n+      tree assign_lower = build2 (MODIFY_EXPR, TREE_TYPE (instr_expr),\n+\t\t\t\t  lower_output, instr_expr);\n+      m_parent.m_cf->append_statement (assign_lower);\n+      instr_expr = lower_output;\n+    }\n+\n+  if (output_count == 1)\n+    build_output_assignment (*brig_inst, operands[0], instr_expr);\n+  else\n+    m_parent.m_cf->append_statement (instr_expr);\n+  return base->byteCount;\n+}\n+\n+/* Create an expression that broadcasts the lowest element of the\n+   vector in VEC_OPERAND to all elements of the returned vector.  */\n+\n+tree\n+brig_basic_inst_handler::build_lower_element_broadcast (tree vec_operand)\n+{\n+  /* Build the broadcast using shuffle because there's no\n+     direct broadcast in GENERIC and this way there's no need for\n+     a separate extract of the lowest element.  */\n+  tree element_type = TREE_TYPE (TREE_TYPE (vec_operand));\n+  size_t esize = 8 * int_size_in_bytes (element_type);\n+\n+  size_t element_count = TYPE_VECTOR_SUBPARTS (TREE_TYPE (vec_operand));\n+  tree mask_inner_type = build_nonstandard_integer_type (esize, 1);\n+  vec<constructor_elt, va_gc> *constructor_vals = NULL;\n+\n+  /* Construct the mask.  */\n+  for (size_t i = 0; i < element_count; ++i)\n+    {\n+      tree cst = build_int_cstu (mask_inner_type, element_count);\n+      CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, cst);\n+    }\n+  tree mask_vec_type = build_vector_type (mask_inner_type, element_count);\n+  tree mask = build_vector_from_ctor (mask_vec_type, constructor_vals);\n+\n+  return build3 (VEC_PERM_EXPR, TREE_TYPE (vec_operand), vec_operand,\n+\t\t vec_operand, mask);\n+}\n+\n+/* Returns the tree code that should be used to implement the given\n+   HSA instruction opcode (BRIG_OPCODE) for the given type of instruction\n+   (BRIG_TYPE).  In case the opcode cannot be mapped to a TREE node directly,\n+   returns TREE_LIST (if it can be emulated with a simple chain of tree\n+   nodes) or CALL_EXPR if the opcode should be implemented using a builtin\n+   call.  */\n+\n+tree_code\n+brig_basic_inst_handler::get_tree_code_for_hsa_opcode\n+  (BrigOpcode16_t brig_opcode, BrigType16_t brig_type) const\n+{\n+  BrigType16_t brig_inner_type = brig_type & BRIG_TYPE_BASE_MASK;\n+  switch (brig_opcode)\n+    {\n+    case BRIG_OPCODE_NOP:\n+      return NOP_EXPR;\n+    case BRIG_OPCODE_ADD:\n+      return PLUS_EXPR;\n+    case BRIG_OPCODE_CMOV:\n+      if (brig_inner_type == brig_type)\n+\treturn COND_EXPR;\n+      else\n+\treturn VEC_COND_EXPR;\n+    case BRIG_OPCODE_SUB:\n+      return MINUS_EXPR;\n+    case BRIG_OPCODE_MUL:\n+    case BRIG_OPCODE_MUL24:\n+      return MULT_EXPR;\n+    case BRIG_OPCODE_MULHI:\n+    case BRIG_OPCODE_MUL24HI:\n+      return MULT_HIGHPART_EXPR;\n+    case BRIG_OPCODE_DIV:\n+      if (gccbrig_is_float_type (brig_inner_type))\n+\treturn RDIV_EXPR;\n+      else\n+\treturn TRUNC_DIV_EXPR;\n+    case BRIG_OPCODE_NEG:\n+      return NEGATE_EXPR;\n+    case BRIG_OPCODE_MIN:\n+      if (gccbrig_is_float_type (brig_inner_type))\n+\treturn CALL_EXPR;\n+      else\n+\treturn MIN_EXPR;\n+    case BRIG_OPCODE_MAX:\n+      if (gccbrig_is_float_type (brig_inner_type))\n+\treturn CALL_EXPR;\n+      else\n+\treturn MAX_EXPR;\n+    case BRIG_OPCODE_FMA:\n+      return FMA_EXPR;\n+    case BRIG_OPCODE_ABS:\n+      return ABS_EXPR;\n+    case BRIG_OPCODE_SHL:\n+      return LSHIFT_EXPR;\n+    case BRIG_OPCODE_SHR:\n+      return RSHIFT_EXPR;\n+    case BRIG_OPCODE_OR:\n+      return BIT_IOR_EXPR;\n+    case BRIG_OPCODE_XOR:\n+      return BIT_XOR_EXPR;\n+    case BRIG_OPCODE_AND:\n+      return BIT_AND_EXPR;\n+    case BRIG_OPCODE_NOT:\n+      return BIT_NOT_EXPR;\n+    case BRIG_OPCODE_RET:\n+      return RETURN_EXPR;\n+    case BRIG_OPCODE_MOV:\n+    case BRIG_OPCODE_LDF:\n+      return MODIFY_EXPR;\n+    case BRIG_OPCODE_LD:\n+    case BRIG_OPCODE_ST:\n+      return MEM_REF;\n+    case BRIG_OPCODE_BR:\n+      return GOTO_EXPR;\n+    case BRIG_OPCODE_REM:\n+      if (brig_type == BRIG_TYPE_U64 || brig_type == BRIG_TYPE_U32)\n+\treturn TRUNC_MOD_EXPR;\n+      else\n+\treturn CALL_EXPR;\n+    case BRIG_OPCODE_NRCP:\n+    case BRIG_OPCODE_NRSQRT:\n+      /* Implement as 1/f (x).  gcc should pattern detect that and\n+\t use a native instruction, if available, for it.  */\n+      return TREE_LIST;\n+    case BRIG_OPCODE_FLOOR:\n+    case BRIG_OPCODE_CEIL:\n+    case BRIG_OPCODE_SQRT:\n+    case BRIG_OPCODE_NSQRT:\n+    case BRIG_OPCODE_RINT:\n+    case BRIG_OPCODE_TRUNC:\n+    case BRIG_OPCODE_POPCOUNT:\n+    case BRIG_OPCODE_COPYSIGN:\n+    case BRIG_OPCODE_NCOS:\n+    case BRIG_OPCODE_NSIN:\n+    case BRIG_OPCODE_NLOG2:\n+    case BRIG_OPCODE_NEXP2:\n+    case BRIG_OPCODE_NFMA:\n+      /* Class has type B1 regardless of the float type, thus\n+\t the below builtin map search cannot find it.  */\n+    case BRIG_OPCODE_CLASS:\n+    case BRIG_OPCODE_WORKITEMABSID:\n+      return CALL_EXPR;\n+    default:\n+\n+      /* Some BRIG opcodes can use the same builtins for unsigned and\n+\t signed types.  Force these cases to unsigned types.\n+      */\n+\n+      if (brig_opcode == BRIG_OPCODE_BORROW\n+\t  || brig_opcode == BRIG_OPCODE_CARRY\n+\t  || brig_opcode == BRIG_OPCODE_LASTBIT\n+\t  || brig_opcode == BRIG_OPCODE_BITINSERT)\n+\t{\n+\t  if (brig_type == BRIG_TYPE_S32)\n+\t    brig_type = BRIG_TYPE_U32;\n+\t  else if (brig_type == BRIG_TYPE_S64)\n+\t    brig_type = BRIG_TYPE_U64;\n+\t}\n+\n+\n+      builtin_map::const_iterator i\n+\t= s_custom_builtins.find (std::make_pair (brig_opcode, brig_type));\n+      if (i != s_custom_builtins.end ())\n+\treturn CALL_EXPR;\n+      else if (s_custom_builtins.find\n+\t       (std::make_pair (brig_opcode, brig_inner_type))\n+\t       != s_custom_builtins.end ())\n+\treturn CALL_EXPR;\n+      if (brig_inner_type == BRIG_TYPE_F16\n+\t  && s_custom_builtins.find\n+\t  (std::make_pair (brig_opcode, BRIG_TYPE_F32))\n+\t  != s_custom_builtins.end ())\n+\treturn CALL_EXPR;\n+      break;\n+    }\n+  return TREE_LIST; /* Emulate using a chain of nodes.  */\n+}"}, {"sha": "040ae5d35869e206e320a94c6b63d79327f25522", "filename": "gcc/brig/brigfrontend/brig-branch-inst-handler.cc", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-branch-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-branch-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-branch-inst-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,221 @@\n+/* brig-branch-inst-handler.cc -- brig branch instruction handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"brig-code-entry-handler.h\"\n+\n+#include \"errors.h\"\n+#include \"brig-util.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"print-tree.h\"\n+#include \"vec.h\"\n+#include \"fold-const.h\"\n+\n+size_t\n+brig_branch_inst_handler::operator () (const BrigBase *base)\n+{\n+  const BrigInstBase *brig_inst\n+    = (const BrigInstBase *) &((const BrigInstBasic *) base)->base;\n+\n+  if (brig_inst->opcode == BRIG_OPCODE_CALL)\n+    {\n+      const BrigData *operand_entries\n+\t= m_parent.get_brig_data_entry (brig_inst->operands);\n+      tree func_ref = NULL_TREE;\n+      vec<tree, va_gc> *out_args;\n+      vec_alloc (out_args, 1);\n+      vec<tree, va_gc> *in_args;\n+      vec_alloc (in_args, 4);\n+\n+      size_t operand_count = operand_entries->byteCount / 4;\n+      gcc_assert (operand_count < 4);\n+\n+      for (size_t i = 0; i < operand_count; ++i)\n+\t{\n+\t  uint32_t operand_offset\n+\t    = ((const uint32_t *) &operand_entries->bytes)[i];\n+\t  const BrigBase *operand_data\n+\t    = m_parent.get_brig_operand_entry (operand_offset);\n+\t  if (i == 1)\n+\t    {\n+\t      gcc_assert (operand_data->kind == BRIG_KIND_OPERAND_CODE_REF);\n+\t      func_ref = build_tree_operand (*brig_inst, *operand_data);\n+\t      continue;\n+\t    }\n+\t  gcc_assert (operand_data->kind == BRIG_KIND_OPERAND_CODE_LIST);\n+\t  const BrigOperandCodeList *codelist\n+\t    = (const BrigOperandCodeList *) operand_data;\n+\t  const BrigData *data\n+\t    = m_parent.get_brig_data_entry (codelist->elements);\n+\n+\t  size_t bytes = data->byteCount;\n+\t  const BrigOperandOffset32_t *operand_ptr\n+\t    = (const BrigOperandOffset32_t *) data->bytes;\n+\n+\t  vec<tree, va_gc> *args = i == 0 ? out_args : in_args;\n+\n+\t  while (bytes > 0)\n+\t    {\n+\t      BrigOperandOffset32_t offset = *operand_ptr;\n+\t      const BrigBase *code_element\n+\t\t= m_parent.get_brig_code_entry (offset);\n+\t      gcc_assert (code_element->kind == BRIG_KIND_DIRECTIVE_VARIABLE);\n+\t      const BrigDirectiveVariable *brig_var\n+\t\t= (const BrigDirectiveVariable *) code_element;\n+\t      tree var = m_parent.m_cf->arg_variable (brig_var);\n+\n+\t      if (brig_var->type & BRIG_TYPE_ARRAY)\n+\t\t{\n+\t\t  /* Array return values are passed as the first argument.  */\n+\t\t  args = in_args;\n+\t\t  /* Pass pointer to the element zero and use its element zero\n+\t\t     as the base address.  */\n+\t\t  tree etype = TREE_TYPE (TREE_TYPE (var));\n+\t\t  tree ptype = build_pointer_type (etype);\n+\t\t  tree element_zero\n+\t\t    = build4 (ARRAY_REF, etype, var, integer_zero_node,\n+\t\t\t      NULL_TREE, NULL_TREE);\n+\t\t  var = build1 (ADDR_EXPR, ptype, element_zero);\n+\t\t}\n+\n+\t      gcc_assert (var != NULL_TREE);\n+\t      vec_safe_push (args, var);\n+\t      ++operand_ptr;\n+\t      bytes -= 4;\n+\t    }\n+\t}\n+\n+      gcc_assert (func_ref != NULL_TREE);\n+      gcc_assert (out_args->length () == 0 || out_args->length () == 1);\n+\n+      tree ret_val_type = void_type_node;\n+      tree ret_val = NULL_TREE;\n+      if (out_args->length () == 1)\n+\t{\n+\t  ret_val = (*out_args)[0];\n+\t  ret_val_type = TREE_TYPE (ret_val);\n+\t}\n+\n+      /* Pass the hidden kernel arguments along to the called functions as\n+\t they might call builtins that need them or access group/private\n+\t memory.  */\n+\n+      vec_safe_push (in_args, m_parent.m_cf->m_context_arg);\n+      vec_safe_push (in_args, m_parent.m_cf->m_group_base_arg);\n+      vec_safe_push (in_args, m_parent.m_cf->m_private_base_arg);\n+\n+      tree call = build_call_vec (ret_val_type, build_fold_addr_expr (func_ref),\n+\t\t\t\t  in_args);\n+      TREE_NOTHROW (func_ref) = 1;\n+      TREE_NOTHROW (call) = 1;\n+\n+      if (ret_val != NULL_TREE)\n+\t{\n+\t  TREE_ADDRESSABLE (ret_val) = 1;\n+\t  tree result_assign\n+\t    = build2 (MODIFY_EXPR, TREE_TYPE (ret_val), ret_val, call);\n+\t  m_parent.m_cf->append_statement (result_assign);\n+\t}\n+      else\n+\t{\n+\t  m_parent.m_cf->append_statement (call);\n+\t}\n+\n+      m_parent.m_cf->m_has_unexpanded_dp_builtins = false;\n+      m_parent.m_cf->m_called_functions.push_back (func_ref);\n+\n+      return base->byteCount;\n+    }\n+\n+  tree instr_type = gccbrig_tree_type_for_hsa_type (brig_inst->type);\n+  tree_stl_vec operands = build_operands (*brig_inst);\n+\n+  if (brig_inst->opcode == BRIG_OPCODE_BR)\n+    {\n+      tree goto_stmt = build1 (GOTO_EXPR, instr_type, operands[0]);\n+      m_parent.m_cf->append_statement (goto_stmt);\n+    }\n+  else if (brig_inst->opcode == BRIG_OPCODE_SBR)\n+    {\n+      tree select = operands[0];\n+      tree cases = operands[1];\n+\n+      tree switch_expr = build3 (SWITCH_EXPR, TREE_TYPE (select), select,\n+\t\t\t\t NULL_TREE, NULL_TREE);\n+\n+      tree default_case\n+\t= build_case_label (NULL_TREE, NULL_TREE,\n+\t\t\t    create_artificial_label (UNKNOWN_LOCATION));\n+      append_to_statement_list (default_case, &SWITCH_BODY (switch_expr));\n+\n+      tree default_jump\n+\t= build1 (GOTO_EXPR, void_type_node, TREE_VEC_ELT (cases, 0));\n+      append_to_statement_list (default_jump, &SWITCH_BODY (switch_expr));\n+\n+      for (int c = 0; c < TREE_VEC_LENGTH (cases); ++c)\n+\t{\n+\t  tree case_label\n+\t    = build_case_label (build_int_cst (integer_type_node, c), NULL_TREE,\n+\t\t\t\tcreate_artificial_label (UNKNOWN_LOCATION));\n+\n+\t  append_to_statement_list (case_label, &SWITCH_BODY (switch_expr));\n+\n+\t  tree jump\n+\t    = build1 (GOTO_EXPR, void_type_node, TREE_VEC_ELT (cases, c));\n+\t  append_to_statement_list (jump, &SWITCH_BODY (switch_expr));\n+\t}\n+      m_parent.m_cf->append_statement (switch_expr);\n+    }\n+  else if (brig_inst->opcode == BRIG_OPCODE_CBR)\n+    {\n+      tree condition = operands[0];\n+      tree target_goto = build1 (GOTO_EXPR, void_type_node, operands[1]);\n+      /* Represents the if..else as (condition)?(goto foo):(goto bar).  */\n+      tree if_stmt\n+\t= build3 (COND_EXPR, void_type_node, condition, target_goto, NULL_TREE);\n+      m_parent.m_cf->append_statement (if_stmt);\n+    }\n+  else if (brig_inst->opcode == BRIG_OPCODE_WAVEBARRIER)\n+    {\n+      /* WAVEBARRIER is a NOP when WAVESIZE = 1.  */\n+    }\n+  else if (brig_inst->opcode == BRIG_OPCODE_BARRIER)\n+    {\n+      m_parent.m_cf->m_has_barriers = true;\n+      tree_stl_vec call_operands;\n+      /* FIXME.  We should add attributes (are there suitable ones in gcc?) that\n+\t ensure the barrier won't be duplicated or moved out of loops etc.\n+\t Like the 'noduplicate' of LLVM.  Same goes for fbarriers.  */\n+      m_parent.m_cf->append_statement\n+\t(expand_or_call_builtin (brig_inst->opcode, BRIG_TYPE_NONE, NULL_TREE,\n+\t\t\t\t call_operands));\n+    }\n+  else if (brig_inst->opcode >= BRIG_OPCODE_ARRIVEFBAR\n+\t   && brig_inst->opcode <= BRIG_OPCODE_WAITFBAR)\n+    {\n+      m_parent.m_cf->m_has_barriers = true;\n+      m_parent.m_cf->append_statement\n+\t(expand_or_call_builtin (brig_inst->opcode, BRIG_TYPE_NONE,\n+\t\t\t\t uint32_type_node, operands));\n+    }\n+  else\n+    gcc_unreachable ();\n+  return base->byteCount;\n+}"}, {"sha": "f455d1ec44ee53fec75f30e785d34fcf3a134d54", "filename": "gcc/brig/brigfrontend/brig-cmp-inst-handler.cc", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cmp-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cmp-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cmp-inst-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,198 @@\n+/* brig-cmp-inst-handler.cc -- brig cmp instruction handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"brig-code-entry-handler.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"print-tree.h\"\n+#include \"brig-util.h\"\n+#include \"convert.h\"\n+\n+size_t\n+brig_cmp_inst_handler::operator () (const BrigBase *base)\n+{\n+  const BrigInstBase *inst_base = (const BrigInstBase *) base;\n+  const BrigInstCmp *inst = (const BrigInstCmp *) base;\n+\n+  tree cmp_type = get_tree_expr_type_for_hsa_type (inst->sourceType);\n+\n+  /* The destination type to convert the comparison result to.  */\n+  tree dest_type = gccbrig_tree_type_for_hsa_type (inst_base->type);\n+\n+  const bool is_fp16_dest\n+    = (inst_base->type & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16;\n+  const bool is_boolean_dest\n+    = (inst_base->type & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_B1;\n+\n+  bool is_int_cmp = VECTOR_TYPE_P (cmp_type)\n+\t\t      ? INTEGRAL_TYPE_P (TREE_TYPE (cmp_type))\n+\t\t      : INTEGRAL_TYPE_P (cmp_type);\n+\n+  /* The type for the GENERIC comparison.  It should match the\n+     input operand width for vector comparisons, a boolean\n+     otherwise.  */\n+  tree result_type = get_comparison_result_type (cmp_type);\n+\n+  /* Save the result as a boolean and extend/convert it to the\n+     wanted destination type.  */\n+  tree expr = NULL_TREE;\n+\n+  std::vector<tree> operands = build_operands (*inst_base);\n+\n+  switch (inst->compare)\n+    {\n+    case BRIG_COMPARE_SEQ:\n+    case BRIG_COMPARE_EQ:\n+      expr = build2 (EQ_EXPR, result_type, operands[1], operands[2]);\n+      break;\n+    case BRIG_COMPARE_SNE:\n+    case BRIG_COMPARE_NE:\n+      expr = build2 (NE_EXPR, result_type, operands[1], operands[2]);\n+\n+      if (!is_int_cmp)\n+\texpr = build2 (BIT_AND_EXPR, TREE_TYPE (expr),\n+\t\t       expr,\n+\t\t       build2 (ORDERED_EXPR, result_type, operands[1],\n+\t\t\t       operands[2]));\n+      break;\n+    case BRIG_COMPARE_SLT:\n+    case BRIG_COMPARE_LT:\n+      expr = build2 (LT_EXPR, result_type, operands[1], operands[2]);\n+      break;\n+    case BRIG_COMPARE_SLE:\n+    case BRIG_COMPARE_LE:\n+      expr = build2 (LE_EXPR, result_type, operands[1], operands[2]);\n+      break;\n+    case BRIG_COMPARE_SGT:\n+    case BRIG_COMPARE_GT:\n+      expr = build2 (GT_EXPR, result_type, operands[1], operands[2]);\n+      break;\n+    case BRIG_COMPARE_SGE:\n+    case BRIG_COMPARE_GE:\n+      expr = build2 (GE_EXPR, result_type, operands[1], operands[2]);\n+      break;\n+    case BRIG_COMPARE_SEQU:\n+    case BRIG_COMPARE_EQU:\n+      expr = build2 (UNEQ_EXPR, result_type, operands[1], operands[2]);\n+      break;\n+    case BRIG_COMPARE_SNEU:\n+    case BRIG_COMPARE_NEU:\n+      expr = build2 (NE_EXPR, result_type, operands[1], operands[2]);\n+      break;\n+    case BRIG_COMPARE_SLTU:\n+    case BRIG_COMPARE_LTU:\n+      expr = build2 (UNLT_EXPR, result_type, operands[1], operands[2]);\n+      break;\n+    case BRIG_COMPARE_SLEU:\n+    case BRIG_COMPARE_LEU:\n+      expr = build2 (UNLE_EXPR, result_type, operands[1], operands[2]);\n+      break;\n+    case BRIG_COMPARE_SGTU:\n+    case BRIG_COMPARE_GTU:\n+      expr = build2 (UNGT_EXPR, result_type, operands[1], operands[2]);\n+      break;\n+    case BRIG_COMPARE_SGEU:\n+    case BRIG_COMPARE_GEU:\n+      expr = build2 (UNGE_EXPR, result_type, operands[1], operands[2]);\n+      break;\n+    case BRIG_COMPARE_SNUM:\n+    case BRIG_COMPARE_NUM:\n+      expr = build2 (ORDERED_EXPR, result_type, operands[1], operands[2]);\n+      break;\n+    case BRIG_COMPARE_SNAN:\n+    case BRIG_COMPARE_NAN:\n+      expr = build2 (UNORDERED_EXPR, result_type, operands[1], operands[2]);\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  if (expr == NULL_TREE)\n+    gcc_unreachable ();\n+\n+  if (is_fp16_dest)\n+    {\n+      expr = convert_to_real (brig_to_generic::s_fp32_type, expr);\n+    }\n+  else if (VECTOR_TYPE_P (dest_type) && ANY_INTEGRAL_TYPE_P (dest_type)\n+\t   && !is_boolean_dest\n+\t   && (inst->sourceType & BRIG_TYPE_BASE_MASK) != BRIG_TYPE_F16)\n+    {\n+      /* In later gcc versions, the output of comparison is not\n+\t all ones for vectors like still in 4.9.1.  We need to use\n+\t an additional VEC_COND_EXPR to produce the all ones 'true' value\n+\t required by HSA.\n+\t VEC_COND_EXPR <a == b, { -1, -1, -1, -1 }, { 0, 0, 0, 0 }>; */\n+\n+      tree all_ones\n+\t= build_vector_from_val (dest_type,\n+\t\t\t       build_minus_one_cst (TREE_TYPE (dest_type)));\n+      tree all_zeroes\n+\t= build_vector_from_val (dest_type,\n+\t\t\t       build_zero_cst (TREE_TYPE (dest_type)));\n+      expr = build3 (VEC_COND_EXPR, dest_type, expr, all_ones, all_zeroes);\n+    }\n+  else if (INTEGRAL_TYPE_P (dest_type) && !is_boolean_dest)\n+    {\n+      /* We need to produce the all-ones pattern for the width of the whole\n+\t resulting integer type.  Use back and forth shifts for propagating\n+\t the lower 1.  */\n+      tree signed_type = signed_type_for (dest_type);\n+      tree signed_result = convert_to_integer (signed_type, expr);\n+\n+      size_t result_width = int_size_in_bytes (dest_type) * BITS_PER_UNIT;\n+\n+      tree shift_amount_cst\n+\t= build_int_cstu (signed_type, result_width - 1);\n+\n+      tree shift_left_result\n+\t= build2 (LSHIFT_EXPR, signed_type, signed_result, shift_amount_cst);\n+\n+      expr = build2 (RSHIFT_EXPR, signed_type, shift_left_result,\n+\t\t     shift_amount_cst);\n+    }\n+  else if (SCALAR_FLOAT_TYPE_P (dest_type))\n+    {\n+      expr = convert_to_real (dest_type, expr);\n+    }\n+  else if (VECTOR_TYPE_P (dest_type)\n+\t   && (inst->sourceType & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16)\n+    {\n+      /* Because F16 comparison is emulated as an F32 comparison with S32\n+\t results, we must now truncate the result vector to S16s so it\n+\t fits to the destination register.  We can build the target vector\n+\t type from the f16 storage type (unsigned ints).  */\n+      expr = add_temp_var (\"wide_cmp_result\", expr);\n+      tree_stl_vec wide_elements;\n+      tree_stl_vec shrunk_elements;\n+      unpack (expr, wide_elements);\n+      for (size_t i = 0; i < wide_elements.size (); ++i)\n+\t{\n+\t  tree wide = wide_elements.at (i);\n+\t  shrunk_elements.push_back\n+\t    (convert_to_integer (short_integer_type_node, wide));\n+\t}\n+      expr = pack (shrunk_elements);\n+    }\n+  build_output_assignment (*inst_base, operands[0], expr);\n+\n+  return base->byteCount;\n+}"}, {"sha": "5fe20124152ca9dc30aff64dc7b839761587ca10", "filename": "gcc/brig/brigfrontend/brig-code-entry-handler.cc", "status": "added", "additions": 1716, "deletions": 0, "changes": 1716, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,1716 @@\n+/* brig-code-entry-handler.cc -- a gccbrig base class\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"brig-code-entry-handler.h\"\n+\n+#include \"stringpool.h\"\n+#include \"tree-iterator.h\"\n+#include \"toplev.h\"\n+#include \"diagnostic.h\"\n+#include \"brig-machine.h\"\n+#include \"brig-util.h\"\n+#include \"errors.h\"\n+#include \"real.h\"\n+#include \"print-tree.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"target.h\"\n+#include \"langhooks.h\"\n+#include \"gimple-expr.h\"\n+#include \"convert.h\"\n+#include \"brig-util.h\"\n+#include \"builtins.h\"\n+#include \"phsa.h\"\n+#include \"brig-builtins.h\"\n+#include \"fold-const.h\"\n+\n+brig_code_entry_handler::builtin_map brig_code_entry_handler::s_custom_builtins;\n+\n+brig_code_entry_handler::brig_code_entry_handler (brig_to_generic &parent)\n+  : brig_entry_handler (parent)\n+{\n+  if (s_custom_builtins.size () > 0) return;\n+\n+  /* Populate the builtin index.  */\n+#undef DEF_HSAIL_ATOMIC_BUILTIN\n+#undef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n+#undef DEF_HSAIL_INTR_BUILTIN\n+#undef DEF_HSAIL_SAT_BUILTIN\n+#undef DEF_HSAIL_BUILTIN\n+#define DEF_HSAIL_BUILTIN(ENUM, HSAIL_OPCODE, HSAIL_TYPE, NAME, TYPE, ATTRS) \\\n+  s_custom_builtins[std::make_pair (HSAIL_OPCODE, HSAIL_TYPE)]\t\t\\\n+    = builtin_decl_explicit (ENUM);\n+\n+#include \"brig-builtins.def\"\n+}\n+\n+/* Build a tree operand which is a reference to a piece of code.  REF is the\n+   original reference as a BRIG object.  */\n+\n+tree\n+brig_code_entry_handler::build_code_ref (const BrigBase &ref)\n+{\n+  if (ref.kind == BRIG_KIND_DIRECTIVE_LABEL)\n+    {\n+      const BrigDirectiveLabel *brig_label = (const BrigDirectiveLabel *) &ref;\n+\n+      const BrigData *label_name\n+\t= m_parent.get_brig_data_entry (brig_label->name);\n+\n+      std::string label_str ((const char *) (label_name->bytes),\n+\t\t\t     label_name->byteCount);\n+      return m_parent.m_cf->label (label_str);\n+    }\n+  else if (ref.kind == BRIG_KIND_DIRECTIVE_FUNCTION)\n+    {\n+      const BrigDirectiveExecutable *func\n+       = (const BrigDirectiveExecutable *) &ref;\n+      return m_parent.function_decl (m_parent.get_mangled_name (func));\n+    }\n+  else if (ref.kind == BRIG_KIND_DIRECTIVE_FBARRIER)\n+    {\n+      const BrigDirectiveFbarrier* fbar = (const BrigDirectiveFbarrier*)&ref;\n+\n+      uint64_t offset = m_parent.group_variable_segment_offset\n+\t(m_parent.get_mangled_name (fbar));\n+\n+      return build_int_cst (uint32_type_node, offset);\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Produce a tree operand for the given BRIG_INST and its OPERAND.\n+   OPERAND_TYPE should be the operand type in case it should not\n+   be dictated by the BrigBase.  IS_INPUT indicates if the operand\n+   is an input operand or a result.  */\n+\n+tree\n+brig_code_entry_handler::build_tree_operand (const BrigInstBase &brig_inst,\n+\t\t\t\t\t     const BrigBase &operand,\n+\t\t\t\t\t     tree operand_type, bool is_input)\n+{\n+  switch (operand.kind)\n+    {\n+    case BRIG_KIND_OPERAND_OPERAND_LIST:\n+      {\n+\tvec<constructor_elt, va_gc> *constructor_vals = NULL;\n+\tconst BrigOperandOperandList &oplist\n+\t  = (const BrigOperandOperandList &) operand;\n+\tconst BrigData *data = m_parent.get_brig_data_entry (oplist.elements);\n+\tsize_t bytes = data->byteCount;\n+\tconst BrigOperandOffset32_t *operand_ptr\n+\t  = (const BrigOperandOffset32_t *) data->bytes;\n+\twhile (bytes > 0)\n+\t  {\n+\t    BrigOperandOffset32_t offset = *operand_ptr;\n+\t    const BrigBase *operand_element\n+\t      = m_parent.get_brig_operand_entry (offset);\n+\t    tree element\n+\t      = build_tree_operand (brig_inst, *operand_element, operand_type);\n+\n+\t    /* In case a vector is used an input, cast the elements to\n+\t       correct size here so we don't need a separate unpack/pack for it.\n+\t       fp16-fp32 conversion is done in build_operands ().  */\n+\t    if (is_input && TREE_TYPE (element) != operand_type)\n+\t      {\n+\t\tif (int_size_in_bytes (TREE_TYPE (element))\n+\t\t    == int_size_in_bytes (operand_type)\n+\t\t    && !INTEGRAL_TYPE_P (operand_type))\n+\t\t  element = build1 (VIEW_CONVERT_EXPR, operand_type, element);\n+\t\telse\n+\t\t  element = convert (operand_type, element);\n+\t      }\n+\n+\t    CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, element);\n+\t    ++operand_ptr;\n+\t    bytes -= 4;\n+\t  }\n+\tsize_t element_count = data->byteCount / 4;\n+\ttree vec_type = build_vector_type (operand_type, element_count);\n+\n+\treturn build_constructor (vec_type, constructor_vals);\n+      }\n+    case BRIG_KIND_OPERAND_CODE_LIST:\n+      {\n+\t/* Build a TREE_VEC of code expressions.  */\n+\n+\tconst BrigOperandCodeList &oplist\n+\t  = (const BrigOperandCodeList &) operand;\n+\tconst BrigData *data = m_parent.get_brig_data_entry (oplist.elements);\n+\tsize_t bytes = data->byteCount;\n+\tconst BrigOperandOffset32_t *operand_ptr\n+\t  = (const BrigOperandOffset32_t *) data->bytes;\n+\n+\tsize_t case_index = 0;\n+\tsize_t element_count = data->byteCount / 4;\n+\n+\t/* Create a TREE_VEC out of the labels in the list.  */\n+\ttree vec = make_tree_vec (element_count);\n+\n+\twhile (bytes > 0)\n+\t  {\n+\t    BrigOperandOffset32_t offset = *operand_ptr;\n+\t    const BrigBase *ref = m_parent.get_brig_code_entry (offset);\n+\t    tree element = build_code_ref (*ref);\n+\n+\t    gcc_assert (case_index < element_count);\n+\t    TREE_VEC_ELT (vec, case_index) = element;\n+\t    case_index++;\n+\n+\t    ++operand_ptr;\n+\t    bytes -= 4;\n+\t  }\n+\treturn vec;\n+      }\n+    case BRIG_KIND_OPERAND_REGISTER:\n+      {\n+\tconst BrigOperandRegister *brig_reg\n+\t  = (const BrigOperandRegister *) &operand;\n+\treturn m_parent.m_cf->get_m_var_declfor_reg (brig_reg);\n+      }\n+    case BRIG_KIND_OPERAND_CONSTANT_BYTES:\n+      {\n+\tconst BrigOperandConstantBytes *brigConst\n+\t  = (const BrigOperandConstantBytes *) &operand;\n+\t/* The constants can be of different type than the instruction\n+\t   and are implicitly casted to the input operand.  */\n+\treturn get_tree_cst_for_hsa_operand (brigConst, NULL_TREE);\n+      }\n+    case BRIG_KIND_OPERAND_WAVESIZE:\n+      {\n+\tif (!INTEGRAL_TYPE_P (operand_type))\n+\t  {\n+\t    gcc_unreachable ();\n+\t    return NULL_TREE;\n+\t  }\n+\treturn build_int_cstu (operand_type, gccbrig_get_target_wavesize ());\n+      }\n+    case BRIG_KIND_OPERAND_CODE_REF:\n+      {\n+\tconst BrigOperandCodeRef *brig_code_ref\n+\t  = (const BrigOperandCodeRef *) &operand;\n+\n+\tconst BrigBase *ref = m_parent.get_brig_code_entry (brig_code_ref->ref);\n+\n+\treturn build_code_ref (*ref);\n+      }\n+    case BRIG_KIND_OPERAND_ADDRESS:\n+      {\n+\treturn build_address_operand (brig_inst,\n+\t\t\t\t      (const BrigOperandAddress &) operand);\n+      }\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Build a tree node representing an address reference from a BRIG_INST and its\n+   ADDR_OPERAND.  */\n+\n+tree\n+brig_code_entry_handler::build_address_operand\n+  (const BrigInstBase &brig_inst, const BrigOperandAddress &addr_operand)\n+{\n+  tree instr_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n+\n+  BrigSegment8_t segment = BRIG_SEGMENT_GLOBAL;\n+  if (brig_inst.opcode == BRIG_OPCODE_LDA)\n+    segment = ((const BrigInstAddr &) brig_inst).segment;\n+  else if (brig_inst.base.kind == BRIG_KIND_INST_MEM)\n+    segment = ((const BrigInstMem &) brig_inst).segment;\n+  else if (brig_inst.base.kind == BRIG_KIND_INST_ATOMIC)\n+    segment = ((const BrigInstAtomic &) brig_inst).segment;\n+\n+  tree var_offset = NULL_TREE;\n+  tree const_offset = NULL_TREE;\n+  tree symbol_base = NULL_TREE;\n+\n+  if (addr_operand.symbol != 0)\n+    {\n+      const BrigDirectiveVariable *arg_symbol\n+\t= (const BrigDirectiveVariable *) m_parent.get_brig_code_entry\n+\t(addr_operand.symbol);\n+\n+      std::string var_name = m_parent.get_mangled_name (arg_symbol);\n+\n+      if (segment == BRIG_SEGMENT_KERNARG)\n+\t{\n+\t  /* Find the offset to the kernarg buffer for the given\n+\t     kernel argument variable.  */\n+\t  tree func = m_parent.m_cf->m_func_decl;\n+\t  /* __args is the first parameter in kernel functions.  */\n+\t  symbol_base = DECL_ARGUMENTS (func);\n+\t  uint64_t offset = m_parent.m_cf->kernel_arg_offset (arg_symbol);\n+\t  if (offset > 0)\n+\t    const_offset = build_int_cst (size_type_node, offset);\n+\t}\n+      else if (segment == BRIG_SEGMENT_GROUP)\n+\t{\n+\n+\t  uint64_t offset = m_parent.group_variable_segment_offset (var_name);\n+\t  const_offset = build_int_cst (size_type_node, offset);\n+\t}\n+      else if (segment == BRIG_SEGMENT_PRIVATE || segment == BRIG_SEGMENT_SPILL)\n+\t{\n+\t  uint32_t offset = m_parent.private_variable_segment_offset (var_name);\n+\n+\t  /* Compute the offset to the work item's copy:\n+\n+\t     single-wi-offset * local_size + wiflatid * varsize\n+\n+\t     This way the work items have the same variable in\n+\t     successive elements to each other in the segment,\n+\t     helping to achieve autovectorization of loads/stores\n+\t     with stride 1.  */\n+\n+\t  tree_stl_vec uint32_0\n+\t    = tree_stl_vec (1, build_int_cst (uint32_type_node, 0));\n+\n+\t  tree_stl_vec uint32_1\n+\t    = tree_stl_vec (1, build_int_cst (uint32_type_node, 1));\n+\n+\t  tree_stl_vec uint32_2\n+\t    = tree_stl_vec (1, build_int_cst (uint32_type_node, 2));\n+\n+\t  tree local_size\n+\t    = build2 (MULT_EXPR, uint32_type_node,\n+\t\t      expand_or_call_builtin (BRIG_OPCODE_WORKGROUPSIZE,\n+\t\t\t\t\t      BRIG_TYPE_U32,\n+\t\t\t\t\t      uint32_type_node, uint32_0),\n+\t\t      expand_or_call_builtin (BRIG_OPCODE_WORKGROUPSIZE,\n+\t\t\t\t\t      BRIG_TYPE_U32,\n+\t\t\t\t\t      uint32_type_node, uint32_1));\n+\n+\t  local_size\n+\t    = build2 (MULT_EXPR, uint32_type_node,\n+\t\t      expand_or_call_builtin (BRIG_OPCODE_WORKGROUPSIZE,\n+\t\t\t\t\t      BRIG_TYPE_U32,\n+\t\t\t\t\t      uint32_type_node, uint32_2),\n+\t\t      local_size);\n+\n+\t  tree var_region\n+\t    = build2 (MULT_EXPR, uint32_type_node,\n+\t\t      build_int_cst (uint32_type_node, offset), local_size);\n+\n+\t  tree_stl_vec operands;\n+\t  tree pos\n+\t    = build2 (MULT_EXPR, uint32_type_node,\n+\t\t      build_int_cst (uint32_type_node,\n+\t\t\t\t     m_parent.private_variable_size (var_name)),\n+\t\t      expand_or_call_builtin (BRIG_OPCODE_WORKITEMFLATID,\n+\t\t\t\t\t      BRIG_TYPE_U32,\n+\t\t\t\t\t      uint32_type_node, operands));\n+\n+\t  tree var_offset\n+\t    = build2 (PLUS_EXPR, uint32_type_node, var_region, pos);\n+\n+\t  /* In case of LDA this is returned directly as an integer value.\n+\t     For other mem-related instructions, we will convert this segment\n+\t     offset to a flat address by adding it as an offset to a (private\n+\t     or group) base pointer later on.  Same applies to group_var_offset.  */\n+\t  symbol_base\n+\t    = add_temp_var (\"priv_var_offset\",\n+\t\t\t    convert (size_type_node, var_offset));\n+\t}\n+      else if (segment == BRIG_SEGMENT_ARG)\n+\t{\n+\t  tree arg_var_decl;\n+\t  if (m_parent.m_cf->m_ret_value_brig_var == arg_symbol)\n+\t    arg_var_decl = m_parent.m_cf->m_ret_temp;\n+\t  else\n+\t    arg_var_decl = m_parent.m_cf->arg_variable (arg_symbol);\n+\n+\t  gcc_assert (arg_var_decl != NULL_TREE);\n+\n+\t  tree ptype = build_pointer_type (instr_type);\n+\n+\t  if (arg_symbol->type & BRIG_TYPE_ARRAY)\n+\t    {\n+\n+\t      /* Two different type of array references in case of arguments\n+\t\t depending where they are referred at.  In the caller (argument\n+\t\t segment), the reference is to an array object and\n+\t\t in the callee, the array object has been passed as a pointer\n+\t\t to the array object.  */\n+\n+\t      if (POINTER_TYPE_P (TREE_TYPE (arg_var_decl)))\n+\t\tsymbol_base = build_reinterpret_cast (ptype, arg_var_decl);\n+\t      else\n+\t\t{\n+\t\t  /* In case we are referring to an array (the argument in\n+\t\t     call site), use its element zero as the base address.  */\n+\t\t  tree element_zero\n+\t\t    = build4 (ARRAY_REF, TREE_TYPE (TREE_TYPE (arg_var_decl)),\n+\t\t\t      arg_var_decl, integer_zero_node, NULL_TREE,\n+\t\t\t      NULL_TREE);\n+\t\t  symbol_base = build1 (ADDR_EXPR, ptype, element_zero);\n+\t\t}\n+\t    }\n+\t  else\n+\t    symbol_base = build1 (ADDR_EXPR, ptype, arg_var_decl);\n+\t}\n+      else\n+\t{\n+\t  tree global_var_decl = m_parent.global_variable (var_name);\n+\n+\t  /* In case the global variable hasn't been defined (yet),\n+\t     use the host def indirection ptr variable.  */\n+\t  if (global_var_decl == NULL_TREE)\n+\t    {\n+\t      std::string host_ptr_name\n+\t\t= std::string (PHSA_HOST_DEF_PTR_PREFIX) + var_name;\n+\t      tree host_defined_ptr = m_parent.global_variable (host_ptr_name);\n+\t      gcc_assert (host_defined_ptr != NULL_TREE);\n+\t      symbol_base = host_defined_ptr;\n+\t    }\n+\t  else\n+\t    {\n+\t      gcc_assert (global_var_decl != NULL_TREE);\n+\n+\t      tree ptype = build_pointer_type (instr_type);\n+\t      symbol_base = build1 (ADDR_EXPR, ptype, global_var_decl);\n+\t    }\n+\t}\n+    }\n+\n+  if (brig_inst.opcode != BRIG_OPCODE_LDA)\n+    {\n+      /* In case of lda_* we want to return the segment address because it's\n+\t used as a value, perhaps in address computation and later converted\n+\t explicitly to a flat address.\n+\n+\t In case of other instructions with memory operands we produce the flat\n+\t address directly here (assuming the target does not have a separate\n+\t address space for group/private segments for now).  */\n+      if (segment == BRIG_SEGMENT_GROUP)\n+\tsymbol_base = m_parent.m_cf->m_group_base_arg;\n+      else if (segment == BRIG_SEGMENT_PRIVATE\n+\t       || segment == BRIG_SEGMENT_SPILL)\n+\t{\n+\t  if (symbol_base != NULL_TREE)\n+\t    symbol_base = build2 (POINTER_PLUS_EXPR, ptr_type_node,\n+\t\t\t\t  m_parent.m_cf->m_private_base_arg,\n+\t\t\t\t  symbol_base);\n+\t  else\n+\t    symbol_base = m_parent.m_cf->m_private_base_arg;\n+\t}\n+    }\n+\n+  if (addr_operand.reg != 0)\n+    {\n+      const BrigOperandRegister *mem_base_reg\n+\t= (const BrigOperandRegister *) m_parent.get_brig_operand_entry\n+\t(addr_operand.reg);\n+      tree base_reg_var = m_parent.m_cf->get_m_var_declfor_reg (mem_base_reg);\n+      var_offset = convert_to_pointer (ptr_type_node, base_reg_var);\n+\n+      gcc_assert (var_offset != NULL_TREE);\n+    }\n+  /* The pointer type we use to access the memory.  Should be of the\n+     width of the load/store instruction, not the target/data\n+     register.  */\n+  tree ptype = build_pointer_type (instr_type);\n+\n+  gcc_assert (ptype != NULL_TREE);\n+\n+  tree addr = NULL_TREE;\n+  if (symbol_base != NULL_TREE && var_offset != NULL_TREE)\n+    /* The most complex addressing mode: symbol + reg [+ const offset].  */\n+    addr = build2 (POINTER_PLUS_EXPR, ptr_type_node,\n+\t\t   convert (ptr_type_node, symbol_base),\n+\t\t   convert (size_type_node, var_offset));\n+  else if (var_offset != NULL)\n+    addr = var_offset;\n+  else if (symbol_base != NULL)\n+    addr = symbol_base;\n+\n+  if (const_offset != NULL_TREE)\n+    {\n+      if (addr == NULL_TREE)\n+\t/* At least direct module-scope global group symbol access with LDA\n+\t   has only the const_offset.  Group base ptr is not added as LDA should\n+\t   return the segment address, not the flattened one.  */\n+\taddr = const_offset;\n+      else\n+\taddr = build2 (POINTER_PLUS_EXPR, ptr_type_node,\n+\t\t       addr, convert (size_type_node, const_offset));\n+    }\n+\n+  /* We might have two const offsets in case of group or private arrays\n+     which have the first offset to the incoming group/private pointer\n+     arg, and the second one an offset to it.  */\n+  uint64_t offs = gccbrig_to_uint64_t (addr_operand.offset);\n+  if (offs > 0)\n+    {\n+      tree const_offset_2 = build_int_cst (size_type_node, offs);\n+      if (addr == NULL_TREE)\n+\taddr = const_offset_2;\n+      else\n+\taddr = build2 (POINTER_PLUS_EXPR, ptr_type_node,\n+\t\t       addr, convert (size_type_node, const_offset_2));\n+\n+    }\n+\n+  gcc_assert (addr != NULL_TREE);\n+  return convert_to_pointer (ptype, addr);\n+}\n+\n+/* Builds a tree operand with the given OPERAND_INDEX for the given\n+   BRIG_INST with the desired tree OPERAND_TYPE.  OPERAND_TYPE can\n+   be NULL in case the type is forced by the BRIG_INST type.  */\n+\n+tree\n+brig_code_entry_handler::build_tree_operand_from_brig\n+  (const BrigInstBase *brig_inst, tree operand_type, size_t operand_index)\n+{\n+  const BrigData *operand_entries\n+    = m_parent.get_brig_data_entry (brig_inst->operands);\n+\n+  uint32_t operand_offset\n+    = ((const uint32_t *) &operand_entries->bytes)[operand_index];\n+  const BrigBase *operand_data\n+    = m_parent.get_brig_operand_entry (operand_offset);\n+  return build_tree_operand (*brig_inst, *operand_data, operand_type);\n+}\n+\n+/* Builds a single (scalar) constant initialized element of type\n+   ELEMENT_TYPE from the buffer pointed to by NEXT_DATA.  */\n+\n+tree\n+brig_code_entry_handler::build_tree_cst_element\n+  (BrigType16_t element_type, const unsigned char *next_data) const\n+{\n+\n+  tree tree_element_type = gccbrig_tree_type_for_hsa_type (element_type);\n+\n+  tree cst;\n+  switch (element_type)\n+    {\n+    case BRIG_TYPE_F16:\n+      {\n+\tHOST_WIDE_INT low = *(const uint16_t *) next_data;\n+\tcst = build_int_cst (uint16_type_node, low);\n+\tbreak;\n+      }\n+    case BRIG_TYPE_F32:\n+      {\n+\tREAL_VALUE_TYPE val;\n+\tieee_single_format.decode (&ieee_single_format, &val,\n+\t\t\t\t   (const long *) next_data);\n+\tcst = build_real (tree_element_type, val);\n+\tbreak;\n+      }\n+    case BRIG_TYPE_F64:\n+      {\n+\tlong data[2];\n+\tdata[0] = *(const uint32_t *) next_data;\n+\tdata[1] = *(const uint32_t *) (next_data + 4);\n+\tREAL_VALUE_TYPE val;\n+\tieee_double_format.decode (&ieee_double_format, &val, data);\n+\tcst = build_real (tree_element_type, val);\n+\tbreak;\n+      }\n+    case BRIG_TYPE_S8:\n+    case BRIG_TYPE_S16:\n+    case BRIG_TYPE_S32:\n+    case BRIG_TYPE_S64:\n+      {\n+\tHOST_WIDE_INT low = *(const int64_t *) next_data;\n+\tcst = build_int_cst (tree_element_type, low);\n+\tbreak;\n+      }\n+    case BRIG_TYPE_U8:\n+    case BRIG_TYPE_U16:\n+    case BRIG_TYPE_U32:\n+    case BRIG_TYPE_U64:\n+      {\n+\tunsigned HOST_WIDE_INT low = *(const uint64_t *) next_data;\n+\tcst = build_int_cstu (tree_element_type, low);\n+\tbreak;\n+      }\n+    case BRIG_TYPE_SIG64:\n+      {\n+\tunsigned HOST_WIDE_INT low = *(const uint64_t *) next_data;\n+\tcst = build_int_cstu (uint64_type_node, low);\n+\tbreak;\n+      }\n+    case BRIG_TYPE_SIG32:\n+      {\n+\tunsigned HOST_WIDE_INT low = *(const uint64_t *) next_data;\n+\tcst = build_int_cstu (uint32_type_node, low);\n+\tbreak;\n+      }\n+    default:\n+      gcc_unreachable ();\n+      return NULL_TREE;\n+    }\n+  return cst;\n+}\n+\n+/* Produce a tree constant type for the given BRIG constant (BRIG_CONST).\n+   TYPE should be the forced instruction type, otherwise the type is\n+   dictated by the BRIG_CONST.  */\n+\n+tree\n+brig_code_entry_handler::get_tree_cst_for_hsa_operand\n+  (const BrigOperandConstantBytes *brig_const, tree type) const\n+{\n+  const BrigData *data = m_parent.get_brig_data_entry (brig_const->bytes);\n+\n+  tree cst = NULL_TREE;\n+\n+  if (type == NULL_TREE)\n+    type = gccbrig_tree_type_for_hsa_type (brig_const->type);\n+\n+  /* The type of a single (scalar) element inside an array,\n+     vector or an array of vectors.  */\n+  BrigType16_t scalar_element_type\n+    = brig_const->type & BRIG_TYPE_BASE_MASK;\n+  tree tree_element_type = type;\n+\n+  vec<constructor_elt, va_gc> *constructor_vals = NULL;\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    tree_element_type = TREE_TYPE (type);\n+\n+  size_t bytes_left = data->byteCount;\n+  const unsigned char *next_data = data->bytes;\n+  size_t scalar_element_size\n+    = gccbrig_hsa_type_bit_size (scalar_element_type) / BITS_PER_UNIT;\n+\n+  while (bytes_left > 0)\n+    {\n+      if (VECTOR_TYPE_P (tree_element_type))\n+\t{\n+\t  /* In case of vector type elements (or sole vectors),\n+\t     create a vector ctor.  */\n+\t  size_t element_count = TYPE_VECTOR_SUBPARTS (tree_element_type);\n+\t  if (bytes_left < scalar_element_size * element_count)\n+\t    fatal_error (UNKNOWN_LOCATION,\n+\t\t\t \"Not enough bytes left for the initializer \"\n+\t\t\t \"(%lu need %lu).\",\n+\t\t\t bytes_left, scalar_element_size * element_count);\n+\n+\t  vec<constructor_elt, va_gc> *vec_els = NULL;\n+\t  for (size_t i = 0; i < element_count; ++i)\n+\t    {\n+\t      tree element\n+\t\t= build_tree_cst_element (scalar_element_type, next_data);\n+\t      CONSTRUCTOR_APPEND_ELT (vec_els, NULL_TREE, element);\n+\t      bytes_left -= scalar_element_size;\n+\t      next_data += scalar_element_size;\n+\t    }\n+\t  cst = build_vector_from_ctor (tree_element_type, vec_els);\n+\t}\n+      else\n+\t{\n+\t  if (bytes_left < scalar_element_size)\n+\t    fatal_error (UNKNOWN_LOCATION,\n+\t\t\t \"Not enough bytes left for the initializer \"\n+\t\t\t \"(%lu need %lu).\",\n+\t\t\t bytes_left, scalar_element_size);\n+\t  cst = build_tree_cst_element (scalar_element_type, next_data);\n+\t  bytes_left -= scalar_element_size;\n+\t  next_data += scalar_element_size;\n+\t}\n+      CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, cst);\n+    }\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    return build_constructor (type, constructor_vals);\n+  else\n+    return cst;\n+}\n+\n+/* Return the matching tree instruction arithmetics type for the\n+   given BRIG_TYPE.  The aritmethics type is the one with which\n+   computation is done (in contrast to the storage type).  F16\n+   arithmetics type is emulated using F32 for now.  */\n+\n+tree\n+brig_code_entry_handler::get_tree_expr_type_for_hsa_type\n+  (BrigType16_t brig_type) const\n+{\n+  BrigType16_t brig_inner_type = brig_type & BRIG_TYPE_BASE_MASK;\n+  if (brig_inner_type == BRIG_TYPE_F16)\n+    {\n+      if (brig_inner_type == brig_type)\n+\treturn m_parent.s_fp32_type;\n+      size_t element_count = gccbrig_hsa_type_bit_size (brig_type) / 16;\n+      return build_vector_type (m_parent.s_fp32_type, element_count);\n+    }\n+  else\n+    return gccbrig_tree_type_for_hsa_type (brig_type);\n+}\n+\n+/* In case the HSA instruction must be implemented using a builtin,\n+   this function is called to get the correct builtin function.\n+   TYPE is the instruction tree type, BRIG_OPCODE the opcode of the\n+   brig instruction and BRIG_TYPE the brig instruction's type.  */\n+\n+tree\n+brig_code_entry_handler::get_builtin_for_hsa_opcode\n+  (tree type, BrigOpcode16_t brig_opcode, BrigType16_t brig_type) const\n+{\n+  tree builtin = NULL_TREE;\n+  tree builtin_type = type;\n+\n+  /* For vector types, first find the scalar version of the builtin.  */\n+  if (type != NULL_TREE && VECTOR_TYPE_P (type))\n+    builtin_type = TREE_TYPE (type);\n+  BrigType16_t brig_inner_type = brig_type & BRIG_TYPE_BASE_MASK;\n+\n+  /* Some BRIG opcodes can use the same builtins for unsigned and\n+     signed types.  Force these cases to unsigned types.  */\n+\n+  if (brig_opcode == BRIG_OPCODE_BORROW\n+      || brig_opcode == BRIG_OPCODE_CARRY\n+      || brig_opcode == BRIG_OPCODE_LASTBIT\n+      || brig_opcode == BRIG_OPCODE_BITINSERT)\n+    {\n+      if (brig_type == BRIG_TYPE_S32)\n+\tbrig_type = BRIG_TYPE_U32;\n+      else if (brig_type == BRIG_TYPE_S64)\n+\tbrig_type = BRIG_TYPE_U64;\n+    }\n+\n+  switch (brig_opcode)\n+    {\n+    case BRIG_OPCODE_FLOOR:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_FLOOR);\n+      break;\n+    case BRIG_OPCODE_CEIL:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_CEIL);\n+      break;\n+    case BRIG_OPCODE_SQRT:\n+    case BRIG_OPCODE_NSQRT:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_SQRT);\n+      break;\n+    case BRIG_OPCODE_RINT:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_RINT);\n+      break;\n+    case BRIG_OPCODE_TRUNC:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_TRUNC);\n+      break;\n+    case BRIG_OPCODE_COPYSIGN:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_COPYSIGN);\n+      break;\n+    case BRIG_OPCODE_NSIN:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_SIN);\n+      break;\n+    case BRIG_OPCODE_NLOG2:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_LOG2);\n+      break;\n+    case BRIG_OPCODE_NEXP2:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_EXP2);\n+      break;\n+    case BRIG_OPCODE_NFMA:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_FMA);\n+      break;\n+    case BRIG_OPCODE_NCOS:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_COS);\n+      break;\n+    case BRIG_OPCODE_POPCOUNT:\n+      /* Popcount should be typed by its argument type (the return value\n+\t is always u32).  Let's use a b64 version for also for b32 for now.  */\n+      return builtin_decl_explicit (BUILT_IN_POPCOUNTL);\n+    case BRIG_OPCODE_BORROW:\n+      /* Borrow uses the same builtin for unsigned and signed types.  */\n+      if (brig_type == BRIG_TYPE_S32 || brig_type == BRIG_TYPE_U32)\n+\treturn builtin_decl_explicit (BUILT_IN_HSAIL_BORROW_U32);\n+      else\n+\treturn builtin_decl_explicit (BUILT_IN_HSAIL_BORROW_U64);\n+    case BRIG_OPCODE_CARRY:\n+      /* Carry also uses the same builtin for unsigned and signed types.  */\n+      if (brig_type == BRIG_TYPE_S32 || brig_type == BRIG_TYPE_U32)\n+\treturn builtin_decl_explicit (BUILT_IN_HSAIL_CARRY_U32);\n+      else\n+\treturn builtin_decl_explicit (BUILT_IN_HSAIL_CARRY_U64);\n+    default:\n+\n+      /* Use our builtin index for finding a proper builtin for the BRIG\n+\t opcode and BRIG type.  This takes care most of the builtin cases,\n+\t the special cases are handled in the separate 'case' statements\n+\t above.  */\n+      builtin_map::const_iterator i\n+\t= s_custom_builtins.find (std::make_pair (brig_opcode, brig_type));\n+      if (i != s_custom_builtins.end ())\n+\treturn (*i).second;\n+\n+      if (brig_inner_type != brig_type)\n+\t{\n+\t  /* Try to find a scalar built-in we could use.  */\n+\t  i = s_custom_builtins.find\n+\t    (std::make_pair (brig_opcode, brig_inner_type));\n+\t  if (i != s_custom_builtins.end ())\n+\t    return (*i).second;\n+\t}\n+\n+      /* In case this is an fp16 operation that is promoted to fp32,\n+\t try to find a fp32 scalar built-in.  */\n+      if (brig_inner_type == BRIG_TYPE_F16)\n+\t{\n+\t  i = s_custom_builtins.find\n+\t    (std::make_pair (brig_opcode, BRIG_TYPE_F32));\n+\t  if (i != s_custom_builtins.end ())\n+\t    return (*i).second;\n+\t}\n+      gcc_unreachable ();\n+    }\n+\n+  if (VECTOR_TYPE_P (type) && builtin != NULL_TREE)\n+    {\n+      /* Try to find a vectorized version of the built-in.\n+\t TODO: properly assert that builtin is a mathfn builtin? */\n+      tree vec_builtin\n+\t= targetm.vectorize.builtin_vectorized_function\n+\t(builtin_mathfn_code (builtin), type, type);\n+      if (vec_builtin != NULL_TREE)\n+\treturn vec_builtin;\n+      else\n+\treturn builtin;\n+    }\n+  if (builtin == NULL_TREE)\n+    gcc_unreachable ();\n+  return builtin;\n+}\n+\n+/* Return the correct GENERIC type for storing comparison results\n+   of operand with the type given in SOURCE_TYPE.  */\n+\n+tree\n+brig_code_entry_handler::get_comparison_result_type (tree source_type)\n+{\n+  if (VECTOR_TYPE_P (source_type))\n+    {\n+      size_t element_size = int_size_in_bytes (TREE_TYPE (source_type));\n+      return build_vector_type\n+\t(build_nonstandard_boolean_type (element_size * BITS_PER_UNIT),\n+\t TYPE_VECTOR_SUBPARTS (source_type));\n+    }\n+  else\n+    return gccbrig_tree_type_for_hsa_type (BRIG_TYPE_B1);\n+}\n+\n+/* Returns true in case the given opcode needs to know about work-item context\n+   data.  In such case the context data is passed as a pointer to a work-item\n+   context object, as the last argument in the builtin call.  */\n+\n+bool\n+brig_code_entry_handler::needs_workitem_context_data\n+  (BrigOpcode16_t brig_opcode) const\n+{\n+  switch (brig_opcode)\n+    {\n+    case BRIG_OPCODE_WORKITEMABSID:\n+    case BRIG_OPCODE_WORKITEMFLATABSID:\n+    case BRIG_OPCODE_WORKITEMFLATID:\n+    case BRIG_OPCODE_CURRENTWORKITEMFLATID:\n+    case BRIG_OPCODE_WORKITEMID:\n+    case BRIG_OPCODE_WORKGROUPID:\n+    case BRIG_OPCODE_WORKGROUPSIZE:\n+    case BRIG_OPCODE_CURRENTWORKGROUPSIZE:\n+    case BRIG_OPCODE_GRIDGROUPS:\n+    case BRIG_OPCODE_GRIDSIZE:\n+    case BRIG_OPCODE_DIM:\n+    case BRIG_OPCODE_PACKETID:\n+    case BRIG_OPCODE_PACKETCOMPLETIONSIG:\n+    case BRIG_OPCODE_BARRIER:\n+    case BRIG_OPCODE_WAVEBARRIER:\n+    case BRIG_OPCODE_ARRIVEFBAR:\n+    case BRIG_OPCODE_INITFBAR:\n+    case BRIG_OPCODE_JOINFBAR:\n+    case BRIG_OPCODE_LEAVEFBAR:\n+    case BRIG_OPCODE_RELEASEFBAR:\n+    case BRIG_OPCODE_WAITFBAR:\n+    case BRIG_OPCODE_CUID:\n+    case BRIG_OPCODE_MAXCUID:\n+    case BRIG_OPCODE_DEBUGTRAP:\n+    case BRIG_OPCODE_GROUPBASEPTR:\n+    case BRIG_OPCODE_KERNARGBASEPTR:\n+    case BRIG_OPCODE_ALLOCA:\n+      return true;\n+    default:\n+      return false;\n+    };\n+}\n+\n+/* Returns true in case the given opcode that would normally be generated\n+   as a builtin call can be expanded to tree nodes.  */\n+\n+bool\n+brig_code_entry_handler::can_expand_builtin (BrigOpcode16_t brig_opcode) const\n+{\n+  switch (brig_opcode)\n+    {\n+    case BRIG_OPCODE_WORKITEMFLATABSID:\n+    case BRIG_OPCODE_WORKITEMFLATID:\n+    case BRIG_OPCODE_WORKITEMABSID:\n+    case BRIG_OPCODE_WORKGROUPSIZE:\n+    case BRIG_OPCODE_CURRENTWORKGROUPSIZE:\n+      /* TODO: expand more builtins.  */\n+      return true;\n+    default:\n+      return false;\n+    };\n+}\n+\n+/* Try to expand the given builtin call to reuse a previously generated\n+   variable, if possible.  If not, just call the given builtin.\n+   BRIG_OPCODE and BRIG_TYPE identify the builtin's BRIG opcode/type,\n+   ARITH_TYPE its GENERIC type, and OPERANDS contains the builtin's\n+   input operands.  */\n+\n+tree\n+brig_code_entry_handler::expand_or_call_builtin (BrigOpcode16_t brig_opcode,\n+\t\t\t\t\t\t BrigType16_t brig_type,\n+\t\t\t\t\t\t tree arith_type,\n+\t\t\t\t\t\t tree_stl_vec &operands)\n+{\n+  if (m_parent.m_cf->m_is_kernel && can_expand_builtin (brig_opcode))\n+    return expand_builtin (brig_opcode, operands);\n+\n+  tree built_in\n+    = get_builtin_for_hsa_opcode (arith_type, brig_opcode, brig_type);\n+\n+  if (!VECTOR_TYPE_P (TREE_TYPE (TREE_TYPE (built_in)))\n+      && arith_type != NULL_TREE && VECTOR_TYPE_P (arith_type)\n+      && brig_opcode != BRIG_OPCODE_LERP\n+      && brig_opcode != BRIG_OPCODE_PACKCVT\n+      && brig_opcode != BRIG_OPCODE_SAD\n+      && brig_opcode != BRIG_OPCODE_SADHI)\n+    {\n+      /* Call the scalar built-in for all elements in the vector.  */\n+      tree_stl_vec operand0_elements;\n+      if (operands.size () > 0)\n+\tunpack (operands[0], operand0_elements);\n+\n+      tree_stl_vec operand1_elements;\n+      if (operands.size () > 1)\n+\tunpack (operands[1], operand1_elements);\n+\n+      tree_stl_vec result_elements;\n+\n+      for (size_t i = 0; i < TYPE_VECTOR_SUBPARTS (arith_type); ++i)\n+\t{\n+\t  tree_stl_vec call_operands;\n+\t  if (operand0_elements.size () > 0)\n+\t    call_operands.push_back (operand0_elements.at (i));\n+\n+\t  if (operand1_elements.size () > 0)\n+\t    call_operands.push_back (operand1_elements.at (i));\n+\n+\t  result_elements.push_back\n+\t    (expand_or_call_builtin (brig_opcode, brig_type,\n+\t\t\t\t     TREE_TYPE (arith_type),\n+\t\t\t\t     call_operands));\n+\t}\n+      return pack (result_elements);\n+    }\n+\n+  tree_stl_vec call_operands;\n+  tree_stl_vec operand_types;\n+\n+  tree arg_type_chain = TYPE_ARG_TYPES (TREE_TYPE (built_in));\n+\n+  for (size_t i = 0; i < operands.size (); ++i)\n+    {\n+      tree operand_type = TREE_VALUE (arg_type_chain);\n+      call_operands.push_back (convert (operand_type, operands[i]));\n+      operand_types.push_back (operand_type);\n+      arg_type_chain = TREE_CHAIN (arg_type_chain);\n+    }\n+\n+  if (needs_workitem_context_data (brig_opcode))\n+    {\n+      call_operands.push_back (m_parent.m_cf->m_context_arg);\n+      operand_types.push_back (ptr_type_node);\n+      m_parent.m_cf->m_has_unexpanded_dp_builtins = true;\n+    }\n+\n+  size_t operand_count = call_operands.size ();\n+\n+  call_operands.resize (4, NULL_TREE);\n+  operand_types.resize (4, NULL_TREE);\n+  for (size_t i = 0; i < operand_count; ++i)\n+    call_operands.at (i) = build_reinterpret_cast (operand_types.at (i),\n+\t\t\t\t\t\t   call_operands.at (i));\n+\n+  tree fnptr = build_fold_addr_expr (built_in);\n+  return build_call_array (TREE_TYPE (TREE_TYPE (built_in)), fnptr,\n+\t\t\t   operand_count, &call_operands[0]);\n+}\n+\n+/* Instead of calling a built-in, reuse a previously returned value known to\n+   be still valid.  This is beneficial especially for the work-item\n+   identification related builtins as not having them as calls can lead to\n+   more easily vectorizable parallel loops for multi work-item work-groups.\n+   BRIG_OPCODE identifies the builtin and OPERANDS store the operands.  */\n+\n+tree\n+brig_code_entry_handler::expand_builtin (BrigOpcode16_t brig_opcode,\n+\t\t\t\t\t tree_stl_vec &operands)\n+{\n+  tree_stl_vec uint32_0 = tree_stl_vec (1, build_int_cst (uint32_type_node, 0));\n+\n+  tree_stl_vec uint32_1 = tree_stl_vec (1, build_int_cst (uint32_type_node, 1));\n+\n+  tree_stl_vec uint32_2 = tree_stl_vec (1, build_int_cst (uint32_type_node, 2));\n+\n+  if (brig_opcode == BRIG_OPCODE_WORKITEMFLATABSID)\n+    {\n+      tree id0 = expand_builtin (BRIG_OPCODE_WORKITEMABSID, uint32_0);\n+      id0 = convert (uint64_type_node, id0);\n+\n+      tree id1 = expand_builtin (BRIG_OPCODE_WORKITEMABSID, uint32_1);\n+      id1 = convert (uint64_type_node, id1);\n+\n+      tree id2 = expand_builtin (BRIG_OPCODE_WORKITEMABSID, uint32_2);\n+      id2 = convert (uint64_type_node, id2);\n+\n+      tree max0 = convert (uint64_type_node,\n+\t\t\t   m_parent.m_cf->m_grid_size_vars[0]);\n+      tree max1 = convert (uint64_type_node,\n+\t\t\t   m_parent.m_cf->m_grid_size_vars[1]);\n+\n+      tree id2_x_max0_x_max1 = build2 (MULT_EXPR, uint64_type_node, id2, max0);\n+      id2_x_max0_x_max1\n+\t= build2 (MULT_EXPR, uint64_type_node, id2_x_max0_x_max1, max1);\n+\n+      tree id1_x_max0 = build2 (MULT_EXPR, uint64_type_node, id1, max0);\n+\n+      tree sum = build2 (PLUS_EXPR, uint64_type_node, id0, id1_x_max0);\n+      sum = build2 (PLUS_EXPR, uint64_type_node, sum, id2_x_max0_x_max1);\n+\n+      return add_temp_var (\"workitemflatabsid\", sum);\n+    }\n+  else if (brig_opcode == BRIG_OPCODE_WORKITEMABSID)\n+    {\n+      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n+\n+      tree local_id_var = m_parent.m_cf->m_local_id_vars[dim];\n+      tree wg_id_var = m_parent.m_cf->m_wg_id_vars[dim];\n+      tree wg_size_var = m_parent.m_cf->m_wg_size_vars[dim];\n+      tree grid_size_var = m_parent.m_cf->m_grid_size_vars[dim];\n+\n+      tree wg_id_x_wg_size = build2 (MULT_EXPR, uint32_type_node,\n+\t\t\t\t     convert (uint32_type_node, wg_id_var),\n+\t\t\t\t     convert (uint32_type_node, wg_size_var));\n+      tree sum\n+\t= build2 (PLUS_EXPR, uint32_type_node, wg_id_x_wg_size, local_id_var);\n+\n+      /* We need a modulo here because of work-groups which have dimensions\n+\t larger than the grid size :( TO CHECK: is this really allowed in the\n+\t specs?  */\n+      tree modulo\n+\t= build2 (TRUNC_MOD_EXPR, uint32_type_node, sum, grid_size_var);\n+\n+      return add_temp_var (std::string (\"workitemabsid_\")\n+\t\t\t     + (char) ((int) 'x' + dim),\n+\t\t\t   modulo);\n+    }\n+  else if (brig_opcode == BRIG_OPCODE_WORKITEMFLATID)\n+    {\n+      tree z_x_wgsx_wgsy\n+\t= build2 (MULT_EXPR, uint32_type_node,\n+\t\t  m_parent.m_cf->m_local_id_vars[2],\n+\t\t  m_parent.m_cf->m_wg_size_vars[0]);\n+      z_x_wgsx_wgsy = build2 (MULT_EXPR, uint32_type_node, z_x_wgsx_wgsy,\n+\t\t\t      m_parent.m_cf->m_wg_size_vars[1]);\n+\n+      tree y_x_wgsx\n+\t= build2 (MULT_EXPR, uint32_type_node,\n+\t\t  m_parent.m_cf->m_local_id_vars[1],\n+\t\t  m_parent.m_cf->m_wg_size_vars[0]);\n+\n+      tree sum = build2 (PLUS_EXPR, uint32_type_node, y_x_wgsx, z_x_wgsx_wgsy);\n+      sum = build2 (PLUS_EXPR, uint32_type_node,\n+\t\t    m_parent.m_cf->m_local_id_vars[0],\n+\t\t    sum);\n+      return add_temp_var (\"workitemflatid\", sum);\n+    }\n+  else if (brig_opcode == BRIG_OPCODE_WORKGROUPSIZE)\n+    {\n+      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n+      return m_parent.m_cf->m_wg_size_vars[dim];\n+    }\n+  else if (brig_opcode == BRIG_OPCODE_CURRENTWORKGROUPSIZE)\n+    {\n+      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n+      return m_parent.m_cf->m_cur_wg_size_vars[dim];\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  return NULL_TREE;\n+}\n+\n+/* Appends and returns a new temp variable and an accompanying assignment\n+   statement that stores the value of the given EXPR and has the given NAME.  */\n+\n+tree\n+brig_code_entry_handler::add_temp_var (std::string name, tree expr)\n+{\n+  tree temp_var = create_tmp_var (TREE_TYPE (expr), name.c_str ());\n+  tree assign = build2 (MODIFY_EXPR, TREE_TYPE (temp_var), temp_var, expr);\n+  m_parent.m_cf->append_statement (assign);\n+  return temp_var;\n+}\n+\n+/* Creates a FP32 to FP16 conversion call, assuming the source and destination\n+   are FP32 type variables.  */\n+\n+tree\n+brig_code_entry_handler::build_f2h_conversion (tree source)\n+{\n+  return float_to_half () (*this, source);\n+}\n+\n+/* Creates a FP16 to FP32 conversion call, assuming the source and destination\n+   are FP32 type variables.  */\n+\n+tree\n+brig_code_entry_handler::build_h2f_conversion (tree source)\n+{\n+  return half_to_float () (*this, source);\n+}\n+\n+/* Builds and \"normalizes\" the dest and source operands for the instruction\n+   execution; converts the input operands to the expected instruction type,\n+   performs half to float conversions, constant to correct type variable,\n+   and flush to zero (if applicable).  */\n+\n+tree_stl_vec\n+brig_code_entry_handler::build_operands (const BrigInstBase &brig_inst)\n+{\n+  /* Flush to zero.  */\n+  bool ftz = false;\n+  const BrigBase *base = &brig_inst.base;\n+\n+  if (base->kind == BRIG_KIND_INST_MOD)\n+    {\n+      const BrigInstMod *mod = (const BrigInstMod *) base;\n+      ftz = mod->modifier & BRIG_ALU_FTZ;\n+    }\n+  else if (base->kind == BRIG_KIND_INST_CMP)\n+    {\n+      const BrigInstCmp *cmp = (const BrigInstCmp *) base;\n+      ftz = cmp->modifier & BRIG_ALU_FTZ;\n+    }\n+\n+  bool is_vec_instr = hsa_type_packed_p (brig_inst.type);\n+\n+  size_t element_count;\n+  if (is_vec_instr)\n+    {\n+      BrigType16_t brig_element_type = brig_inst.type & BRIG_TYPE_BASE_MASK;\n+      element_count = gccbrig_hsa_type_bit_size (brig_inst.type)\n+\t\t      / gccbrig_hsa_type_bit_size (brig_element_type);\n+    }\n+  else\n+    element_count = 1;\n+\n+  bool is_fp16_arith = false;\n+\n+  tree src_type;\n+  tree dest_type;\n+  if (base->kind == BRIG_KIND_INST_CMP)\n+    {\n+      const BrigInstCmp *cmp_inst = (const BrigInstCmp *) base;\n+      src_type = gccbrig_tree_type_for_hsa_type (cmp_inst->sourceType);\n+      dest_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n+      is_fp16_arith\n+\t= (cmp_inst->sourceType & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16;\n+    }\n+  else if (base->kind == BRIG_KIND_INST_SOURCE_TYPE)\n+    {\n+      const BrigInstSourceType *src_type_inst\n+\t= (const BrigInstSourceType *) base;\n+      src_type = gccbrig_tree_type_for_hsa_type (src_type_inst->sourceType);\n+      dest_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n+      is_fp16_arith\n+\t= (src_type_inst->sourceType & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16\n+\t&& !gccbrig_is_bit_operation (brig_inst.opcode);\n+    }\n+  else if (base->kind == BRIG_KIND_INST_SEG_CVT)\n+    {\n+      const BrigInstSegCvt *seg_cvt_inst = (const BrigInstSegCvt *) base;\n+      src_type = gccbrig_tree_type_for_hsa_type (seg_cvt_inst->sourceType);\n+      dest_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n+    }\n+  else if (base->kind == BRIG_KIND_INST_MEM)\n+    {\n+      src_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n+      dest_type = src_type;\n+      /* With mem instructions we don't want to cast the fp16\n+\t back and forth between fp32, because the load/stores\n+\t are not specific to the data type.  */\n+      is_fp16_arith = false;\n+    }\n+  else if (base->kind == BRIG_KIND_INST_CVT)\n+    {\n+      const BrigInstCvt *cvt_inst = (const BrigInstCvt *) base;\n+\n+      src_type = gccbrig_tree_type_for_hsa_type (cvt_inst->sourceType);\n+      dest_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n+    }\n+  else\n+    {\n+      switch (brig_inst.opcode)\n+\t{\n+\tcase BRIG_OPCODE_INITFBAR:\n+\tcase BRIG_OPCODE_JOINFBAR:\n+\tcase BRIG_OPCODE_WAITFBAR:\n+\tcase BRIG_OPCODE_ARRIVEFBAR:\n+\tcase BRIG_OPCODE_LEAVEFBAR:\n+\tcase BRIG_OPCODE_RELEASEFBAR:\n+\t  src_type = uint32_type_node;\n+\t  break;\n+\tdefault:\n+\t  src_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n+\t  break;\n+\t}\n+      dest_type = src_type;\n+      is_fp16_arith\n+\t= !gccbrig_is_bit_operation (brig_inst.opcode)\n+\t&& (brig_inst.type & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16;\n+    }\n+\n+  /* Halfs are a tricky special case: their \"storage format\" is u16, but\n+     scalars are stored in 32b regs while packed f16 are... well packed.  */\n+  tree half_storage_type = element_count > 1\n+\t\t\t     ? gccbrig_tree_type_for_hsa_type (brig_inst.type)\n+\t\t\t     : uint32_type_node;\n+\n+  const BrigData *operand_entries\n+    = m_parent.get_brig_data_entry (brig_inst.operands);\n+  std::vector<tree> operands;\n+  for (size_t i = 0; i < operand_entries->byteCount / 4; ++i)\n+    {\n+      uint32_t operand_offset = ((const uint32_t *) &operand_entries->bytes)[i];\n+      const BrigBase *operand_data\n+\t= m_parent.get_brig_operand_entry (operand_offset);\n+\n+      const bool is_output\n+\t= gccbrig_hsa_opcode_op_output_p (brig_inst.opcode, i);\n+\n+      tree operand_type = is_output ? dest_type : src_type;\n+\n+      bool half_to_float = is_fp16_arith;\n+\n+      /* Special cases for operand types.  */\n+      if ((brig_inst.opcode == BRIG_OPCODE_SHL\n+\t   || brig_inst.opcode == BRIG_OPCODE_SHR)\n+\t  && i == 2)\n+\t  /* The shift amount is always a scalar.  */\n+\toperand_type\n+\t  = VECTOR_TYPE_P (src_type) ? TREE_TYPE (src_type) : src_type;\n+      else if (brig_inst.opcode == BRIG_OPCODE_SHUFFLE)\n+\t{\n+\t  if (i == 3)\n+\t    /* HSAIL shuffle inputs the MASK vector as tightly packed bits\n+\t       while GENERIC VEC_PERM_EXPR expects the mask elements to be\n+\t       of the same size as the elements in the input vectors.  Let's\n+\t       cast to a scalar type here and convert to the VEC_PERM_EXPR\n+\t       format in instruction handling.  There are no arbitrary bit\n+\t       width int types in GENERIC so we cannot use the original\n+\t       vector type.  */\n+\t    operand_type = uint32_type_node;\n+\t  else\n+\t    /* Always treat the element as unsigned ints to avoid\n+\t       sign extensions/negative offsets with masks, which\n+\t       are expected to be of the same element type as the\n+\t       data in VEC_PERM_EXPR.  With shuffles the data type\n+\t       should not matter as it's a \"raw operation\".  */\n+\t    operand_type = get_unsigned_int_type (operand_type);\n+\t}\n+      else if (brig_inst.opcode == BRIG_OPCODE_PACK)\n+\t{\n+\t  if (i == 1)\n+\t    operand_type = get_unsigned_int_type (dest_type);\n+\t  else if (i == 2)\n+\t    operand_type = get_unsigned_int_type (TREE_TYPE (dest_type));\n+\t  else if (i == 3)\n+\t    operand_type = uint32_type_node;\n+\t}\n+      else if (brig_inst.opcode == BRIG_OPCODE_UNPACK && i == 2)\n+\toperand_type = uint32_type_node;\n+      else if (brig_inst.opcode == BRIG_OPCODE_SAD && i == 3)\n+\toperand_type = uint32_type_node;\n+      else if (brig_inst.opcode == BRIG_OPCODE_CLASS && i == 2)\n+\t{\n+\t  operand_type = uint32_type_node;\n+\t  half_to_float = false;\n+\t}\n+      else if (half_to_float)\n+\t/* Treat the operands as the storage type at this point.  */\n+\toperand_type = half_storage_type;\n+\n+      tree operand = build_tree_operand (brig_inst, *operand_data, operand_type,\n+\t\t\t\t\t !is_output);\n+\n+      gcc_assert (operand);\n+\n+      /* Cast/convert the inputs to correct types as expected by the GENERIC\n+\t opcode instruction.  */\n+      if (!is_output)\n+\t{\n+\t  if (half_to_float)\n+\t    operand = build_h2f_conversion\n+\t      (build_reinterpret_cast (half_storage_type, operand));\n+\t  else if (TREE_CODE (operand) != LABEL_DECL\n+\t\t   && TREE_CODE (operand) != TREE_VEC\n+\t\t   && operand_data->kind != BRIG_KIND_OPERAND_ADDRESS\n+\t\t   && !VECTOR_TYPE_P (TREE_TYPE (operand)))\n+\t    {\n+\t      size_t reg_width = int_size_in_bytes (TREE_TYPE (operand));\n+\t      size_t instr_width = int_size_in_bytes (operand_type);\n+\t      if (reg_width == instr_width)\n+\t\toperand = build_reinterpret_cast (operand_type, operand);\n+\t      else if (reg_width > instr_width)\n+\t\t{\n+\t\t  /* Clip the operand because the instruction's bitwidth\n+\t\t     is smaller than the HSAIL reg width.  */\n+\t\t  if (INTEGRAL_TYPE_P (operand_type))\n+\t\t    operand\n+\t\t      = convert_to_integer (signed_or_unsigned_type_for\n+\t\t\t\t\t    (TYPE_UNSIGNED (operand_type),\n+\t\t\t\t\t     operand_type), operand);\n+\t\t  else\n+\t\t    operand = build_reinterpret_cast (operand_type, operand);\n+\t\t}\n+\t      else if (reg_width < instr_width)\n+\t\t/* At least shift amount operands can be read from smaller\n+\t\t   registers than the data operands.  */\n+\t\toperand = convert (operand_type, operand);\n+\t    }\n+\t  else if (brig_inst.opcode == BRIG_OPCODE_SHUFFLE)\n+\t    /* Force the operand type to be treated as the raw type.  */\n+\t    operand = build_reinterpret_cast (operand_type, operand);\n+\n+\t  if (brig_inst.opcode == BRIG_OPCODE_CMOV && i == 1)\n+\t    {\n+\t      /* gcc expects the lower bit to be 1 (or all ones in case of\n+\t\t vectors) while CMOV assumes false iff 0.  Convert the input\n+\t\t here to what gcc likes by generating\n+\t\t 'operand = operand != 0'.  */\n+\t      tree cmp_res_type = get_comparison_result_type (operand_type);\n+\t      operand = build2 (NE_EXPR, cmp_res_type, operand,\n+\t\t\t\tbuild_zero_cst (TREE_TYPE (operand)));\n+\t    }\n+\n+\t  if (ftz)\n+\t    operand = flush_to_zero (is_fp16_arith) (*this, operand);\n+\t}\n+      operands.push_back (operand);\n+    }\n+  return operands;\n+}\n+\n+/* Build the GENERIC for assigning the result of an instruction to the result\n+   \"register\" (variable).  BRIG_INST is the original brig instruction,\n+   OUTPUT the result variable/register, INST_EXPR the one producing the\n+   result.  Required bitcasts and fp32 to fp16 conversions are added as\n+   well.  */\n+\n+tree\n+brig_code_entry_handler::build_output_assignment (const BrigInstBase &brig_inst,\n+\t\t\t\t\t\t  tree output, tree inst_expr)\n+{\n+  /* The destination type might be different from the output register\n+     variable type (which is always an unsigned integer type).  */\n+  tree output_type = TREE_TYPE (output);\n+  tree input_type = TREE_TYPE (inst_expr);\n+  bool is_fp16 = (brig_inst.type & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16\n+\t\t && brig_inst.base.kind != BRIG_KIND_INST_MEM\n+\t\t && !gccbrig_is_bit_operation (brig_inst.opcode);\n+\n+  /* Flush to zero.  */\n+  bool ftz = false;\n+  const BrigBase *base = &brig_inst.base;\n+\n+  if (base->kind == BRIG_KIND_INST_MOD)\n+    {\n+      const BrigInstMod *mod = (const BrigInstMod *) base;\n+      ftz = mod->modifier & BRIG_ALU_FTZ;\n+    }\n+  else if (base->kind == BRIG_KIND_INST_CMP)\n+    {\n+      const BrigInstCmp *cmp = (const BrigInstCmp *) base;\n+      ftz = cmp->modifier & BRIG_ALU_FTZ;\n+    }\n+\n+  if (TREE_CODE (inst_expr) == CALL_EXPR)\n+    {\n+      tree func_decl = TREE_OPERAND (TREE_OPERAND (inst_expr, 1), 0);\n+      input_type = TREE_TYPE (TREE_TYPE (func_decl));\n+    }\n+\n+  if (ftz && (VECTOR_FLOAT_TYPE_P (TREE_TYPE (inst_expr))\n+\t      || SCALAR_FLOAT_TYPE_P (TREE_TYPE (inst_expr)) || is_fp16))\n+    {\n+      /* Ensure we don't duplicate the arithmetics to the arguments of the bit\n+\t field reference operators.  */\n+      inst_expr = add_temp_var (\"before_ftz\", inst_expr);\n+      inst_expr = flush_to_zero (is_fp16) (*this, inst_expr);\n+    }\n+\n+  if (is_fp16)\n+    {\n+      inst_expr = add_temp_var (\"before_f2h\", inst_expr);\n+      tree f2h_output = build_f2h_conversion (inst_expr);\n+      tree conv_int = convert_to_integer (output_type, f2h_output);\n+      tree assign = build2 (MODIFY_EXPR, output_type, output, conv_int);\n+      m_parent.m_cf->append_statement (assign);\n+      return assign;\n+    }\n+  else if (VECTOR_TYPE_P (TREE_TYPE (output)))\n+    {\n+      /* Expand/unpack the input value to the given vector elements.  */\n+      size_t i;\n+      tree input = inst_expr;\n+      tree element_type = gccbrig_tree_type_for_hsa_type (brig_inst.type);\n+      tree element;\n+      tree last_assign = NULL_TREE;\n+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (output), i, element)\n+\t{\n+\t  tree element_ref\n+\t    = build3 (BIT_FIELD_REF, element_type, input,\n+\t\t      TYPE_SIZE (element_type),\n+\t\t      build_int_cst (uint32_type_node,\n+\t\t\t\t     i * int_size_in_bytes (element_type)\n+\t\t\t\t     *  BITS_PER_UNIT));\n+\n+\t  last_assign\n+\t    = build_output_assignment (brig_inst, element, element_ref);\n+\t}\n+      return last_assign;\n+    }\n+  else\n+    {\n+      /* All we do here is to bitcast the result and store it to the\n+\t 'register' (variable).  Mainly need to take care of differing\n+\t bitwidths.  */\n+      size_t src_width = int_size_in_bytes (input_type);\n+      size_t dst_width = int_size_in_bytes (output_type);\n+\n+      if (src_width == dst_width)\n+\t{\n+\t  /* A simple bitcast should do.  */\n+\t  tree bitcast = build_reinterpret_cast (output_type, inst_expr);\n+\t  tree assign = build2 (MODIFY_EXPR, output_type, output, bitcast);\n+\t  m_parent.m_cf->append_statement (assign);\n+\t  return assign;\n+\t}\n+      else\n+\t{\n+\t  tree conv_int = convert_to_integer (output_type, inst_expr);\n+\t  tree assign = build2 (MODIFY_EXPR, output_type, output, conv_int);\n+\t  m_parent.m_cf->append_statement (assign);\n+\t  return assign;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Appends a GENERIC statement (STMT) to the currently constructed function.  */\n+\n+void\n+brig_code_entry_handler::append_statement (tree stmt)\n+{\n+  m_parent.m_cf->append_statement (stmt);\n+}\n+\n+/* Unpacks the elements of the vector in VALUE to scalars (bit field\n+   references) in ELEMENTS.  */\n+\n+void\n+brig_code_entry_handler::unpack (tree value, tree_stl_vec &elements)\n+{\n+  size_t vec_size = int_size_in_bytes (TREE_TYPE (value));\n+  size_t element_size\n+    = int_size_in_bytes (TREE_TYPE (TREE_TYPE (value))) * BITS_PER_UNIT;\n+  size_t element_count\n+    = vec_size * BITS_PER_UNIT / element_size;\n+\n+  tree input_element_type = TREE_TYPE (TREE_TYPE (value));\n+\n+  value = add_temp_var (\"unpack_input\", value);\n+\n+  for (size_t i = 0; i < element_count; ++i)\n+    {\n+      tree element\n+\t= build3 (BIT_FIELD_REF, input_element_type, value,\n+\t\t  TYPE_SIZE (input_element_type),\n+\t\t  build_int_cst (unsigned_char_type_node, i * element_size));\n+\n+      element = add_temp_var (\"scalar\", element);\n+      elements.push_back (element);\n+    }\n+}\n+\n+/* Pack the elements of the scalars in ELEMENTS to the returned vector.  */\n+\n+tree\n+brig_code_entry_handler::pack (tree_stl_vec &elements)\n+{\n+  size_t element_count = elements.size ();\n+\n+  gcc_assert (element_count > 1);\n+\n+  tree output_element_type = TREE_TYPE (elements.at (0));\n+\n+  vec<constructor_elt, va_gc> *constructor_vals = NULL;\n+  for (size_t i = 0; i < element_count; ++i)\n+    CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, elements.at (i));\n+\n+  tree vec_type = build_vector_type (output_element_type, element_count);\n+\n+  /* build_constructor creates a vector type which is not a vector_cst\n+     that requires compile time constant elements.  */\n+  tree vec = build_constructor (vec_type, constructor_vals);\n+\n+  /* Add a temp variable for readability.  */\n+  tree tmp_var = create_tmp_var (vec_type, \"vec_out\");\n+  tree vec_tmp_assign = build2 (MODIFY_EXPR, TREE_TYPE (tmp_var), tmp_var, vec);\n+  m_parent.m_cf->append_statement (vec_tmp_assign);\n+  return tmp_var;\n+}\n+\n+/* Visits the element(s) in the OPERAND, calling HANDLER to each of them.  */\n+\n+tree\n+tree_element_unary_visitor::operator () (brig_code_entry_handler &handler,\n+\t\t\t\t\ttree operand)\n+{\n+  if (VECTOR_TYPE_P (TREE_TYPE (operand)))\n+    {\n+      size_t vec_size = int_size_in_bytes (TREE_TYPE (operand));\n+      size_t element_size = int_size_in_bytes (TREE_TYPE (TREE_TYPE (operand)));\n+      size_t element_count = vec_size / element_size;\n+\n+      tree input_element_type = TREE_TYPE (TREE_TYPE (operand));\n+      tree output_element_type = NULL_TREE;\n+\n+      vec<constructor_elt, va_gc> *constructor_vals = NULL;\n+      for (size_t i = 0; i < element_count; ++i)\n+\t{\n+\t  tree element = build3 (BIT_FIELD_REF, input_element_type, operand,\n+\t\t\t\t TYPE_SIZE (input_element_type),\n+\t\t\t\t build_int_cst (unsigned_char_type_node,\n+\t\t\t\t\t\ti * element_size\n+\t\t\t\t\t\t* BITS_PER_UNIT));\n+\n+\t  tree output = visit_element (handler, element);\n+\t  output_element_type = TREE_TYPE (output);\n+\n+\t  CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, output);\n+\t}\n+\n+      tree vec_type = build_vector_type (output_element_type, element_count);\n+\n+      /* build_constructor creates a vector type which is not a vector_cst\n+\t that requires compile time constant elements.  */\n+      tree vec = build_constructor (vec_type, constructor_vals);\n+\n+      /* Add a temp variable for readability.  */\n+      tree tmp_var = create_tmp_var (vec_type, \"vec_out\");\n+      tree vec_tmp_assign\n+\t= build2 (MODIFY_EXPR, TREE_TYPE (tmp_var), tmp_var, vec);\n+      handler.append_statement (vec_tmp_assign);\n+      return tmp_var;\n+    }\n+  else\n+    return visit_element (handler, operand);\n+}\n+\n+/* Visits the element pair(s) in the OPERAND0 and OPERAND1, calling HANDLER\n+   to each of them.  */\n+\n+tree\n+tree_element_binary_visitor::operator () (brig_code_entry_handler &handler,\n+\t\t\t\t\t tree operand0, tree operand1)\n+{\n+  if (VECTOR_TYPE_P (TREE_TYPE (operand0)))\n+    {\n+      gcc_assert (VECTOR_TYPE_P (TREE_TYPE (operand1)));\n+      size_t vec_size = int_size_in_bytes (TREE_TYPE (operand0));\n+      size_t element_size\n+\t= int_size_in_bytes (TREE_TYPE (TREE_TYPE (operand0)));\n+      size_t element_count = vec_size / element_size;\n+\n+      tree input_element_type = TREE_TYPE (TREE_TYPE (operand0));\n+      tree output_element_type = NULL_TREE;\n+\n+      vec<constructor_elt, va_gc> *constructor_vals = NULL;\n+      for (size_t i = 0; i < element_count; ++i)\n+\t{\n+\n+\t  tree element0 = build3 (BIT_FIELD_REF, input_element_type, operand0,\n+\t\t\t\t  TYPE_SIZE (input_element_type),\n+\t\t\t\t  build_int_cst (unsigned_char_type_node,\n+\t\t\t\t\t\t i * element_size\n+\t\t\t\t\t\t * BITS_PER_UNIT));\n+\n+\t  tree element1 = build3 (BIT_FIELD_REF, input_element_type, operand1,\n+\t\t\t\t  TYPE_SIZE (input_element_type),\n+\t\t\t\t  build_int_cst (unsigned_char_type_node,\n+\t\t\t\t\t\t i * element_size\n+\t\t\t\t\t\t * BITS_PER_UNIT));\n+\n+\t  tree output = visit_element (handler, element0, element1);\n+\t  output_element_type = TREE_TYPE (output);\n+\n+\t  CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, output);\n+\t}\n+\n+      tree vec_type = build_vector_type (output_element_type, element_count);\n+\n+      /* build_constructor creates a vector type which is not a vector_cst\n+\t that requires compile time constant elements.  */\n+      tree vec = build_constructor (vec_type, constructor_vals);\n+\n+      /* Add a temp variable for readability.  */\n+      tree tmp_var = create_tmp_var (vec_type, \"vec_out\");\n+      tree vec_tmp_assign\n+\t= build2 (MODIFY_EXPR, TREE_TYPE (tmp_var), tmp_var, vec);\n+      handler.append_statement (vec_tmp_assign);\n+      return tmp_var;\n+    }\n+  else\n+    return visit_element (handler, operand0, operand1);\n+}\n+\n+/* Generates GENERIC code that flushes the visited element to zero.  */\n+\n+tree\n+flush_to_zero::visit_element (brig_code_entry_handler &, tree operand)\n+{\n+  size_t size = int_size_in_bytes (TREE_TYPE (operand));\n+  if (size == 4)\n+    {\n+      tree built_in\n+\t= (m_fp16) ? builtin_decl_explicit (BUILT_IN_HSAIL_FTZ_F32_F16) :\n+\tbuiltin_decl_explicit (BUILT_IN_HSAIL_FTZ_F32);\n+\n+      return call_builtin (built_in, 1, float_type_node, float_type_node,\n+\t\t\t   operand);\n+    }\n+  else if (size == 8)\n+    {\n+      return call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_FTZ_F64), 1,\n+\t\t\t   double_type_node, double_type_node, operand);\n+    }\n+  else\n+    gcc_unreachable ();\n+  return NULL_TREE;\n+}\n+\n+/* Generates GENERIC code that converts a single precision float to half\n+   precision float.  */\n+\n+tree\n+float_to_half::visit_element (brig_code_entry_handler &caller, tree operand)\n+{\n+  tree built_in = builtin_decl_explicit (BUILT_IN_HSAIL_F32_TO_F16);\n+\n+  tree casted_operand = build_reinterpret_cast (uint32_type_node, operand);\n+\n+  tree call = call_builtin (built_in, 1, uint16_type_node, uint32_type_node,\n+\t\t\t    casted_operand);\n+  tree output\n+    = create_tmp_var (TREE_TYPE (TREE_TYPE (built_in)), \"fp16out\");\n+  tree assign = build2 (MODIFY_EXPR, TREE_TYPE (output), output, call);\n+  caller.append_statement (assign);\n+  return output;\n+}\n+\n+/* Generates GENERIC code that converts a half precision float to single\n+   precision float.  */\n+\n+tree\n+half_to_float::visit_element (brig_code_entry_handler &caller, tree operand)\n+{\n+  tree built_in = builtin_decl_explicit (BUILT_IN_HSAIL_F16_TO_F32);\n+  tree truncated_source = convert_to_integer (uint16_type_node, operand);\n+\n+  tree call\n+    = call_builtin (built_in, 1, uint32_type_node, uint16_type_node,\n+\t\t    truncated_source);\n+\n+  tree const_fp32_type\n+    = build_type_variant (brig_to_generic::s_fp32_type, 1, 0);\n+\n+  tree output = create_tmp_var (const_fp32_type, \"fp32out\");\n+  tree casted_result\n+    = build_reinterpret_cast (brig_to_generic::s_fp32_type, call);\n+\n+  tree assign = build2 (MODIFY_EXPR, TREE_TYPE (output), output, casted_result);\n+\n+  caller.append_statement (assign);\n+\n+  return output;\n+}\n+\n+/* Treats the INPUT as SRC_TYPE and sign or zero extends it to DEST_TYPE.  */\n+\n+tree\n+brig_code_entry_handler::extend_int (tree input, tree dest_type, tree src_type)\n+{\n+  /* Extend integer conversions according to the destination's\n+     ext mode.  First we need to clip the input register to\n+     the possible smaller integer size to ensure the correct sign\n+     bit is extended.  */\n+  tree clipped_input = convert_to_integer (src_type, input);\n+  tree conversion_result;\n+\n+  if (TYPE_UNSIGNED (src_type))\n+    conversion_result\n+      = convert_to_integer (unsigned_type_for (dest_type), clipped_input);\n+  else\n+    conversion_result\n+      = convert_to_integer (signed_type_for (dest_type), clipped_input);\n+\n+  /* Treat the result as unsigned so we do not sign extend to the\n+     register width.  For some reason this GENERIC sequence sign\n+     extends to the s register:\n+\n+     D.1541 = (signed char) s1;\n+     D.1542 = (signed short) D.1541;\n+     s0 = (unsigned int) D.1542\n+  */\n+\n+  /* The converted result is then extended to the target register\n+     width, using the same sign as the destination.  */\n+  return convert_to_integer (dest_type, conversion_result);\n+}\n+\n+/* Returns the integer constant value of the given node.\n+   If it's a cast, looks into the source of the cast.  */\n+HOST_WIDE_INT\n+brig_code_entry_handler::int_constant_value (tree node)\n+{\n+  tree n = node;\n+  if (TREE_CODE (n) == VIEW_CONVERT_EXPR)\n+    n = TREE_OPERAND (n, 0);\n+  return int_cst_value (n);\n+}\n+"}, {"sha": "8e7fbe86823360ab1225a48d0193509af77e8484", "filename": "gcc/brig/brigfrontend/brig-code-entry-handler.h", "status": "added", "additions": 425, "deletions": 0, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.h?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,425 @@\n+/* brig-code-entry-handler.h -- a gccbrig base class\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_BRIG_CODE_ENTRY_HANDLER_H\n+#define GCC_BRIG_CODE_ENTRY_HANDLER_H\n+\n+#include \"brig-to-generic.h\"\n+\n+#include <map>\n+#include <vector>\n+\n+class tree_element_unary_visitor;\n+\n+/* An interface to organize the different types of element handlers\n+   for the code section.  */\n+\n+class brig_code_entry_handler : public brig_entry_handler\n+{\n+public:\n+  typedef std::map<std::pair<BrigOpcode16_t, BrigType16_t>, tree> builtin_map;\n+\n+  brig_code_entry_handler (brig_to_generic &parent);\n+\n+  /* Handles the brig_code data at the given pointer and adds it to the\n+     currently built tree.  Returns the number of consumed bytes.  */\n+\n+  virtual size_t operator () (const BrigBase *base) = 0;\n+\n+  void append_statement (tree stmt);\n+\n+protected:\n+\n+  tree get_tree_expr_type_for_hsa_type (BrigType16_t brig_type) const;\n+  tree get_tree_cst_for_hsa_operand (const BrigOperandConstantBytes *brigConst,\n+\t\t\t\t     tree type) const;\n+  tree get_builtin_for_hsa_opcode (tree type, BrigOpcode16_t brig_opcode,\n+\t\t\t\t   BrigType16_t brig_type) const;\n+  tree get_comparison_result_type (tree source_type);\n+\n+  tree build_code_ref (const BrigBase &ref);\n+\n+  tree build_tree_operand (const BrigInstBase &brig_inst,\n+\t\t\t   const BrigBase &operand,\n+\t\t\t   tree operand_type = NULL_TREE,\n+\t\t\t   bool is_input = false);\n+\n+  tree build_address_operand (const BrigInstBase &brig_inst,\n+\t\t\t      const BrigOperandAddress &addr_operand);\n+\n+  tree build_tree_operand_from_brig (const BrigInstBase *brig_inst,\n+\t\t\t\t     tree operand_type, size_t operand_index);\n+\n+  tree build_tree_cst_element (BrigType16_t element_type,\n+\t\t\t       const unsigned char *next_data) const;\n+\n+  bool needs_workitem_context_data (BrigOpcode16_t brig_opcode) const;\n+\n+  void unpack (tree value, tree_stl_vec &elements);\n+  tree pack (tree_stl_vec &elements);\n+\n+  bool can_expand_builtin (BrigOpcode16_t brig_opcode) const;\n+  tree expand_builtin (BrigOpcode16_t brig_opcode, tree_stl_vec &operands);\n+\n+  tree expand_or_call_builtin (BrigOpcode16_t brig_opcode,\n+\t\t\t       BrigType16_t brig_type, tree arith_type,\n+\t\t\t       tree_stl_vec &operands);\n+\n+  tree add_temp_var (std::string name, tree expr);\n+\n+  tree build_f2h_conversion (tree source);\n+  tree build_h2f_conversion (tree source);\n+\n+  tree_stl_vec build_operands (const BrigInstBase &brig_inst);\n+  tree build_output_assignment (const BrigInstBase &brig_inst, tree output,\n+\t\t\t\ttree inst_expr);\n+\n+  tree apply_to_all_elements (tree_element_unary_visitor &visitor,\n+\t\t\t      tree operand);\n+\n+  HOST_WIDE_INT int_constant_value (tree node);\n+\n+  tree extend_int (tree input, tree dest_type, tree src_type);\n+\n+  /* HSAIL-specific builtin functions not yet integrated to gcc.  */\n+\n+  static builtin_map s_custom_builtins;\n+};\n+\n+/* Implement the Visitor software pattern for performing various actions on\n+   elements of vector operands.  This enables separating the vector element\n+   traversal/extraction/packing code from whatever different actions are\n+   performed to each element.  */\n+\n+class tree_element_unary_visitor\n+{\n+public:\n+  tree operator () (brig_code_entry_handler &handler, tree operand);\n+\n+  /* Performs an action to a single element, which can have originally\n+     been a vector element or a scalar.  */\n+\n+  virtual tree visit_element (brig_code_entry_handler &handler, tree operand)\n+    = 0;\n+};\n+\n+class tree_element_binary_visitor\n+{\n+public:\n+  tree operator () (brig_code_entry_handler &handler, tree operand0,\n+\t\t   tree operand1);\n+\n+  /* Performs an action to a pair of elements, which can have originally\n+     been a vector element or a scalar.  */\n+\n+  virtual tree visit_element (brig_code_entry_handler &handler, tree operand0,\n+\t\t\t      tree operand1)\n+    = 0;\n+};\n+\n+/* Visitor for flushing float elements to zero.  */\n+\n+class flush_to_zero : public tree_element_unary_visitor\n+{\n+public:\n+  flush_to_zero (bool fp16) : m_fp16 (fp16)\n+  {\n+  }\n+\n+  virtual tree visit_element (brig_code_entry_handler &caller, tree operand);\n+\n+private:\n+\n+  /* True if the value should be flushed according to fp16 limits.  */\n+\n+  bool m_fp16;\n+};\n+\n+/* Visitor for converting F16 elements to F32.  */\n+\n+class half_to_float : public tree_element_unary_visitor\n+{\n+public:\n+  virtual tree visit_element (brig_code_entry_handler &caller, tree operand);\n+};\n+\n+/* Visitor for converting F32 elements to F16.  */\n+\n+class float_to_half : public tree_element_unary_visitor\n+{\n+public:\n+  virtual tree visit_element (brig_code_entry_handler &caller, tree operand);\n+};\n+\n+/* A base class for instruction types that support floating point\n+   modifiers.\n+\n+   operator () delegates to subclasses (template method pattern) in\n+   type specific parts.  */\n+\n+class brig_inst_mod_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_inst_mod_handler (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+\n+  virtual size_t generate (const BrigBase *base);\n+  virtual const BrigAluModifier8_t *modifier (const BrigBase *base) const;\n+  virtual const BrigRound8_t *round (const BrigBase *base) const;\n+\n+  size_t operator () (const BrigBase *base);\n+};\n+\n+class brig_directive_function_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_directive_function_handler (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+  size_t operator () (const BrigBase *base);\n+};\n+\n+class brig_directive_control_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_directive_control_handler (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+\n+  size_t operator () (const BrigBase *base);\n+};\n+\n+class brig_directive_variable_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_directive_variable_handler (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+\n+  size_t operator () (const BrigBase *base);\n+\n+  tree build_variable (const BrigDirectiveVariable *brigVar,\n+\t\t       tree_code var_decltype = VAR_DECL);\n+\n+  size_t get_brig_var_alignment (const BrigDirectiveVariable *brigVar);\n+};\n+\n+class brig_directive_fbarrier_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_directive_fbarrier_handler (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+\n+  size_t operator () (const BrigBase *base);\n+};\n+\n+class brig_directive_label_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_directive_label_handler (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+\n+  size_t operator () (const BrigBase *base);\n+};\n+\n+class brig_directive_comment_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_directive_comment_handler (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+\n+  size_t operator () (const BrigBase *base);\n+};\n+\n+class brig_directive_arg_block_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_directive_arg_block_handler (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+\n+  size_t operator () (const BrigBase *base);\n+};\n+\n+class brig_basic_inst_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_basic_inst_handler (brig_to_generic &parent);\n+\n+  size_t operator () (const BrigBase *base);\n+\n+private:\n+  tree build_lower_element_broadcast (tree vec_operand);\n+\n+  bool must_be_scalarized (const BrigInstBase *brig_inst,\n+\t\t\t   tree instr_type) const;\n+\n+  tree build_inst_expr (BrigOpcode16_t brig_opcode, BrigType16_t brig_type,\n+\t\t\t tree arith_type, tree_stl_vec &operands);\n+\n+  tree build_shuffle (tree arith_type, tree_stl_vec &operands);\n+  tree build_unpack (tree_stl_vec &operands);\n+  tree build_pack (tree_stl_vec &operands);\n+\n+  tree build_unpack_lo_or_hi (BrigOpcode16_t brig_opcode, tree arith_type,\n+\t\t\t      tree_stl_vec &operands);\n+\n+  tree_code get_tree_code_for_hsa_opcode (BrigOpcode16_t brig_opcode,\n+\t\t\t\t\t  BrigType16_t brig_type) const;\n+};\n+\n+class brig_cvt_inst_handler : public brig_inst_mod_handler\n+{\n+public:\n+  brig_cvt_inst_handler (brig_to_generic &parent)\n+    : brig_inst_mod_handler (parent)\n+  {\n+  }\n+\n+  virtual size_t generate (const BrigBase *base);\n+  virtual const BrigAluModifier8_t *modifier (const BrigBase *base) const;\n+  virtual const BrigRound8_t *round (const BrigBase *base) const;\n+};\n+\n+class brig_branch_inst_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_branch_inst_handler (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+\n+  size_t operator () (const BrigBase *base);\n+};\n+\n+class brig_mem_inst_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_mem_inst_handler (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+\n+  size_t operator () (const BrigBase *base);\n+\n+private:\n+  tree build_mem_access (const BrigInstBase *brig_inst, tree addr, tree data);\n+};\n+\n+class brig_copy_move_inst_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_copy_move_inst_handler (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+\n+  size_t operator () (const BrigBase *base);\n+\n+private:\n+  size_t handle_lda (const BrigInstBase *base);\n+};\n+\n+class brig_atomic_inst_handler : public brig_code_entry_handler\n+{\n+private:\n+  typedef std::map<std::string, tree> atomic_builtins_map;\n+\n+public:\n+  brig_atomic_inst_handler (brig_to_generic &parent);\n+\n+  size_t operator () (const BrigBase *base);\n+\n+protected:\n+  size_t generate_tree (const BrigInstBase &inst,\n+\t\t\tBrigAtomicOperation8_t atomic_opcode);\n+};\n+\n+class brig_signal_inst_handler : public brig_atomic_inst_handler\n+{\n+public:\n+  brig_signal_inst_handler (brig_to_generic &parent)\n+    : brig_atomic_inst_handler (parent)\n+  {\n+  }\n+  size_t operator () (const BrigBase *base);\n+};\n+\n+class brig_cmp_inst_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_cmp_inst_handler (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+\n+  size_t operator () (const BrigBase *base);\n+};\n+\n+class brig_seg_inst_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_seg_inst_handler (brig_to_generic &parent);\n+\n+  size_t operator () (const BrigBase *base);\n+};\n+\n+class brig_lane_inst_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_lane_inst_handler (brig_to_generic &parent);\n+\n+  size_t operator () (const BrigBase *base);\n+};\n+\n+class brig_queue_inst_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_queue_inst_handler (brig_to_generic &parent);\n+\n+  size_t operator () (const BrigBase *base);\n+};\n+\n+class brig_directive_module_handler : public brig_code_entry_handler\n+{\n+public:\n+  brig_directive_module_handler (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+\n+  size_t operator () (const BrigBase *base);\n+};\n+\n+\n+#endif"}, {"sha": "61a187fade1aa1f390113c1c90cb0feea0a23e71", "filename": "gcc/brig/brigfrontend/brig-comment-handler.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-comment-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-comment-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-comment-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,38 @@\n+/* brig-comment-handler.cc -- brig comment directive handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"brig-code-entry-handler.h\"\n+\n+extern int gccbrig_verbose;\n+\n+size_t\n+brig_directive_comment_handler::operator () (const BrigBase *base)\n+{\n+  const BrigDirectiveComment *brig_comment\n+    = (const BrigDirectiveComment *) base;\n+\n+  if (gccbrig_verbose)\n+    {\n+      std::string cmnt = m_parent.get_string (brig_comment->name);\n+      fprintf (stderr, \"brig: Comment: '%s'\\n\", cmnt.c_str());\n+    }\n+  return base->byteCount;\n+}"}, {"sha": "2e4f5e36a7762d2882fe42aa9ea80af00dab9afc", "filename": "gcc/brig/brigfrontend/brig-control-handler.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-control-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-control-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-control-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,108 @@\n+/* brig-control-handler.cc -- brig control directive handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"brig-code-entry-handler.h\"\n+#include \"diagnostic.h\"\n+#include \"print-tree.h\"\n+\n+size_t\n+brig_directive_control_handler::operator () (const BrigBase *base)\n+{\n+  const BrigDirectiveControl *inst = (const BrigDirectiveControl *) base;\n+  const BrigData *operand_entries\n+    = m_parent.get_brig_data_entry (inst->operands);\n+\n+  /* Parse the constant integer operands.  */\n+  std::vector<tree> operands;\n+  for (size_t i = 0; i < operand_entries->byteCount / 4; ++i)\n+    {\n+      uint32_t operand_offset\n+\t= ((const uint32_t *) &operand_entries->bytes)[i];\n+      const BrigBase *operand_data\n+\t= m_parent.get_brig_operand_entry (operand_offset);\n+\n+      tree operand_type\n+\t= (inst->control == BRIG_CONTROL_REQUIREDGRIDSIZE\n+\t   || inst->control == BRIG_CONTROL_MAXFLATGRIDSIZE) ?\n+\tuint64_type_node : uint32_type_node;\n+      operands.push_back\n+\t(build_tree_operand (*(const BrigInstBase*)inst, *operand_data,\n+\t\t\t     operand_type));\n+    }\n+\n+  switch (inst->control)\n+    {\n+    case BRIG_CONTROL_MAXDYNAMICGROUPSIZE:\n+      {\n+\tm_parent.m_cf->m_descriptor.max_dynamic_group_size\n+\t  = int_constant_value (operands.at (0));\n+\tbreak;\n+      }\n+    case BRIG_CONTROL_MAXFLATGRIDSIZE:\n+      {\n+\tm_parent.m_cf->m_descriptor.max_flat_grid_size\n+\t  = int_constant_value (operands.at (0));\n+\tbreak;\n+      }\n+    case BRIG_CONTROL_MAXFLATWORKGROUPSIZE:\n+      {\n+\tm_parent.m_cf->m_descriptor.max_flat_workgroup_size\n+\t  = int_constant_value (operands.at (0));\n+\tbreak;\n+      }\n+    case BRIG_CONTROL_REQUIREDDIM:\n+      {\n+\tm_parent.m_cf->m_descriptor.required_dim\n+\t  = int_constant_value (operands.at (0));\n+\tbreak;\n+      }\n+    case BRIG_CONTROL_REQUIREDGRIDSIZE:\n+      {\n+\tm_parent.m_cf->m_descriptor.required_grid_size[0]\n+\t  = int_constant_value (operands.at (0));\n+\tm_parent.m_cf->m_descriptor.required_grid_size[1]\n+\t  = int_constant_value (operands.at (1));\n+\tm_parent.m_cf->m_descriptor.required_grid_size[2]\n+\t  = int_constant_value (operands.at (2));\n+\tbreak;\n+      }\n+    case BRIG_CONTROL_REQUIREDWORKGROUPSIZE:\n+      {\n+\tm_parent.m_cf->m_descriptor.required_workgroup_size[0]\n+\t  = int_constant_value (operands.at (0));\n+\tm_parent.m_cf->m_descriptor.required_workgroup_size[1]\n+\t  = int_constant_value (operands.at (1));\n+\tm_parent.m_cf->m_descriptor.required_workgroup_size[2]\n+\t  = int_constant_value (operands.at (2));\n+\tbreak;\n+      }\n+    case BRIG_CONTROL_REQUIRENOPARTIALWORKGROUPS:\n+      /* Performance hint only, ignored for now.  */\n+      break;\n+    case BRIG_CONTROL_ENABLEBREAKEXCEPTIONS:\n+    case BRIG_CONTROL_ENABLEDETECTEXCEPTIONS:\n+      /* Unimplemented.  */\n+      break;\n+    default:\n+      sorry (\"Unsupported control directive %x.\\n\", inst->control);\n+    }\n+  return base->byteCount;\n+}"}, {"sha": "08ff26d928270dba4e450286ab274dac7bac3aca", "filename": "gcc/brig/brigfrontend/brig-copy-move-inst-handler.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-copy-move-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-copy-move-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-copy-move-inst-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,73 @@\n+/* brig-copy-move-inst-handler.cc -- brig copy/move instruction handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"brig-code-entry-handler.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"print-tree.h\"\n+#include \"errors.h\"\n+#include \"brig-util.h\"\n+\n+size_t\n+brig_copy_move_inst_handler::handle_lda (const BrigInstBase *brig_inst)\n+{\n+  tree dest_type = gccbrig_tree_type_for_hsa_type (brig_inst->type);\n+\n+  tree input = build_tree_operand_from_brig (brig_inst, NULL, 1);\n+  tree output = build_tree_operand_from_brig (brig_inst, dest_type, 0);\n+\n+  build_output_assignment (*brig_inst, output, input);\n+  return brig_inst->base.byteCount;\n+}\n+\n+size_t\n+brig_copy_move_inst_handler::operator () (const BrigBase *base)\n+{\n+  const BrigInstBase *brig_inst\n+    = (const BrigInstBase *) &((const BrigInstBasic *) base)->base;\n+\n+  if (brig_inst->opcode == BRIG_OPCODE_LDA)\n+    return handle_lda (brig_inst);\n+\n+  const BrigInstSourceType *inst_src_type = (const BrigInstSourceType *) base;\n+\n+  tree source_type = gccbrig_tree_type_for_hsa_type (inst_src_type->sourceType);\n+  tree dest_type = gccbrig_tree_type_for_hsa_type (brig_inst->type);\n+\n+  tree input = build_tree_operand_from_brig (brig_inst, source_type, 1);\n+  tree output = build_tree_operand_from_brig (brig_inst, dest_type, 0);\n+  if (brig_inst->opcode == BRIG_OPCODE_COMBINE)\n+    {\n+      /* For combine, a simple reinterpret cast from the array constructor\n+\t works.  */\n+\n+      tree casted = build_reinterpret_cast (dest_type, input);\n+      tree assign = build2 (MODIFY_EXPR, TREE_TYPE (output), output, casted);\n+      m_parent.m_cf->append_statement (assign);\n+    }\n+  else if (brig_inst->opcode == BRIG_OPCODE_EXPAND)\n+    build_output_assignment (*brig_inst, output, input);\n+  else\n+    {\n+      brig_basic_inst_handler basic (m_parent);\n+      return basic (base);\n+    }\n+  return base->byteCount;\n+}"}, {"sha": "a5b1619779322bad768562f837c5eed49236c7c2", "filename": "gcc/brig/brigfrontend/brig-cvt-inst-handler.cc", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cvt-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cvt-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cvt-inst-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,260 @@\n+/* brig-cvt-inst-handler.cc -- brig cvt (convert) instruction handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <sstream>\n+\n+#include \"brig-code-entry-handler.h\"\n+\n+#include \"gimple-expr.h\"\n+#include \"errors.h\"\n+#include \"convert.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"print-tree.h\"\n+#include \"diagnostic-core.h\"\n+#include \"brig-util.h\"\n+\n+const BrigAluModifier8_t *\n+brig_cvt_inst_handler::modifier (const BrigBase *base) const\n+{\n+  const BrigInstCvt *inst = (const BrigInstCvt *) base;\n+  return &inst->modifier;\n+}\n+\n+const BrigRound8_t *\n+brig_cvt_inst_handler::round (const BrigBase *base) const\n+{\n+  const BrigInstCvt *inst = (const BrigInstCvt *) base;\n+  return &inst->round;\n+}\n+\n+size_t\n+brig_cvt_inst_handler::generate (const BrigBase *base)\n+{\n+  /* In cvt instructions there can be at least four data types involved:\n+\n+     - the input register type\n+     - the output register type\n+     - the conversion source type\n+     - the conversion destination type\n+  */\n+\n+  const BrigInstBase *brig_inst\n+    = (const BrigInstBase *) &((const BrigInstBasic *) base)->base;\n+  const BrigInstCvt *cvt_inst = (const BrigInstCvt *) base;\n+\n+  const BrigAluModifier8_t *inst_modifier = modifier (base);\n+  const bool FTZ = inst_modifier != NULL && (*inst_modifier) & BRIG_ALU_FTZ;\n+\n+  /* The conversion source type.  */\n+  tree src_type = get_tree_expr_type_for_hsa_type (cvt_inst->sourceType);\n+\n+  bool src_is_fp16 = cvt_inst->sourceType == BRIG_TYPE_F16;\n+\n+  /* The conversion destination type.  */\n+  tree dest_type = gccbrig_tree_type_for_hsa_type (brig_inst->type);\n+\n+  bool dest_is_fp16 = brig_inst->type == BRIG_TYPE_F16;\n+\n+  if (!dest_type || !src_type)\n+    {\n+      gcc_unreachable ();\n+      return base->byteCount;\n+    }\n+\n+  tree_stl_vec operands = build_operands (*brig_inst);\n+  tree &input = operands.at (1);\n+  tree &output = operands.at (0);\n+\n+  size_t conv_src_size = int_size_in_bytes (src_type);\n+  size_t conv_dst_size = int_size_in_bytes (dest_type);\n+  size_t src_reg_size = int_size_in_bytes (TREE_TYPE (input));\n+\n+  /* The input register can be of different type&size than the\n+     conversion input size.  First cast the input to the conversion\n+     input type.  These casts are always bitcasts which can be\n+     expressed as casts between different unsigned integers.  */\n+  if (src_reg_size != conv_src_size)\n+    {\n+      tree unsigned_int_type = NULL_TREE;\n+      if (INTEGRAL_TYPE_P (src_type))\n+\tunsigned_int_type = unsigned_type_for (src_type);\n+      else /* Find a matching size int type for the REAL type.  */\n+\t{\n+\t  if (conv_src_size == 2)\n+\t    unsigned_int_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U16);\n+\t  else if (conv_src_size == 4)\n+\t    unsigned_int_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U32);\n+\t  else if (conv_src_size == 8)\n+\t    unsigned_int_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U64);\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+      input = convert_to_integer (unsigned_int_type, input);\n+    }\n+\n+  if (src_is_fp16)\n+    input = build_h2f_conversion (input);\n+\n+  /* Flush the float operand to zero if indicated with 'ftz'.  */\n+  if (FTZ && SCALAR_FLOAT_TYPE_P (src_type))\n+    {\n+      tree casted_input = build_reinterpret_cast (src_type, input);\n+      input = flush_to_zero (src_is_fp16) (*this, casted_input);\n+    }\n+\n+  tree conversion_result = NULL_TREE;\n+  if (brig_inst->type == BRIG_TYPE_B1)\n+    {\n+      /* When the destination is b1, cvt does a 'ztest' operation which is\n+\t defined as a != 0 for integers and similarly (!= 0.0f) for floats.  */\n+      if (INTEGRAL_TYPE_P (src_type))\n+\t{\n+\t  /* Generate an integer not equal operation.  */\n+\t  conversion_result = build2 (NE_EXPR, TREE_TYPE (input), input,\n+\t\t\t\t      build_int_cst (TREE_TYPE (input), 0));\n+\t}\n+      else\n+\t{\n+\t  /* For REAL source types, ztest returns 1 if the value is not +- 0.0f.\n+\t     We can perform this check with an integer comparison after\n+\t     masking away the sign bit from a correct position.  This is safer\n+\t     than using absf because of exceptions in case of a NaN\n+\t     input (NaN exceptions are not generated with cvt).  */\n+\t  tree unsigned_int_type = NULL_TREE;\n+\t  /* Bit battern with all but the upper bit 1.  */\n+\t  tree and_mask = NULL_TREE;\n+\t  if (conv_src_size == 2)\n+\t    {\n+\t      unsigned_int_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U16);\n+\t      and_mask = build_int_cst (unsigned_int_type, 0x7FFF);\n+\t    }\n+\t  else if (conv_src_size == 4)\n+\t    {\n+\t      unsigned_int_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U32);\n+\t      and_mask = build_int_cst (unsigned_int_type, 0x7FFFFFFF);\n+\t    }\n+\t  else if (conv_src_size == 8)\n+\t    {\n+\t      unsigned_int_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U64);\n+\t      and_mask = build_int_cst (unsigned_int_type, 0x7FFFFFFFFFFFFFFF);\n+\t    }\n+\t  else\n+\t    gcc_unreachable ();\n+\t  tree casted_input = build_reinterpret_cast (unsigned_int_type, input);\n+\t  tree masked_input\n+\t    = build2 (BIT_AND_EXPR, unsigned_int_type, casted_input, and_mask);\n+\t  conversion_result\n+\t    = build2 (NE_EXPR, TREE_TYPE (masked_input), masked_input,\n+\t\t      build_int_cst (unsigned_int_type, 0));\n+\t}\n+      /* The result from the comparison is a boolean, convert it to such.  */\n+      conversion_result\n+\t= convert_to_integer (gccbrig_tree_type_for_hsa_type (BRIG_TYPE_B1),\n+\t\t\t      conversion_result);\n+    }\n+  else if (dest_is_fp16)\n+    {\n+      tree casted_input = build_reinterpret_cast (src_type, input);\n+      conversion_result\n+\t= convert_to_real (brig_to_generic::s_fp32_type, casted_input);\n+      if (FTZ)\n+\tconversion_result = flush_to_zero (true) (*this, conversion_result);\n+      conversion_result = build_f2h_conversion (conversion_result);\n+    }\n+  else if (SCALAR_FLOAT_TYPE_P (dest_type))\n+    {\n+      tree casted_input = build_reinterpret_cast (src_type, input);\n+      conversion_result = convert_to_real (dest_type, casted_input);\n+    }\n+  else if (INTEGRAL_TYPE_P (dest_type) && INTEGRAL_TYPE_P (src_type))\n+    {\n+      conversion_result = extend_int (input, dest_type, src_type);\n+    }\n+  else if (INTEGRAL_TYPE_P (dest_type) && SCALAR_FLOAT_TYPE_P (src_type))\n+    {\n+\n+      if (cvt_inst->round == BRIG_ROUND_INTEGER_ZERO_SAT)\n+\t{\n+\n+\t  /* Use builtins for the saturating conversions.  */\n+#undef DEF_HSAIL_SAT_BUILTIN\n+#undef DEF_HSAIL_BUILTIN\n+#undef DEF_HSAIL_ATOMIC_BUILTIN\n+#undef DEF_HSAIL_INTR_BUILTIN\n+#undef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n+\n+\t  tree builtin = NULL_TREE;\n+\t  BrigType16_t src_arith_type\n+\t    = src_is_fp16\n+\t    ? (BrigType16_t) BRIG_TYPE_F32 : cvt_inst->sourceType;\n+#define DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN(ENUM, HSAIL_DST_TYPE, HSAIL_SRC_TYPE, \\\n+\t\t\t\t\tNAME, TYPE, ATTRS)\t\t\\\n+\t  if (brig_inst->type == HSAIL_DST_TYPE\t\t\t\t\\\n+\t      && src_arith_type == HSAIL_SRC_TYPE)\t\t\\\n+\t    builtin = builtin_decl_explicit (ENUM);\t\t\t\\\n+\t  else\n+#include \"brig-builtins.def\"\n+\t    gcc_unreachable ();\n+\n+\t  tree casted_input = build_reinterpret_cast (src_type, input);\n+\t  conversion_result\n+\t    = call_builtin (builtin, 1, dest_type, src_type, casted_input);\n+\t}\n+      else\n+\t{\n+\t  tree casted_input = build_reinterpret_cast (src_type, input);\n+\n+\t  /* Perform the int to float conversion.  */\n+\t  conversion_result = convert_to_integer (dest_type, casted_input);\n+\t}\n+      /* The converted result is finally extended to the target register\n+\t width, using the same sign as the destination.  */\n+      conversion_result\n+\t= convert_to_integer (TREE_TYPE (output), conversion_result);\n+    }\n+  else\n+    {\n+      /* Just use CONVERT_EXPR and hope for the best.  */\n+      tree casted_input = build_reinterpret_cast (dest_type, input);\n+      conversion_result = build1 (CONVERT_EXPR, dest_type, casted_input);\n+    }\n+\n+  size_t dst_reg_size = int_size_in_bytes (TREE_TYPE (output));\n+\n+  tree assign = NULL_TREE;\n+  /* The output register can be of different type&size than the\n+     conversion output size.  Cast it to the register variable type.  */\n+  if (dst_reg_size > conv_dst_size)\n+    {\n+      tree casted_output\n+\t= build1 (CONVERT_EXPR, TREE_TYPE (output), conversion_result);\n+      assign = build2 (MODIFY_EXPR, TREE_TYPE (output), output, casted_output);\n+    }\n+  else\n+    {\n+      tree casted_output\n+\t= build_reinterpret_cast (TREE_TYPE (output), conversion_result);\n+      assign = build2 (MODIFY_EXPR, TREE_TYPE (output), output, casted_output);\n+    }\n+  m_parent.m_cf->append_statement (assign);\n+\n+  return base->byteCount;\n+}"}, {"sha": "b236885d1647a157352883cdd6c8c95a67c34831", "filename": "gcc/brig/brigfrontend/brig-fbarrier-handler.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-fbarrier-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-fbarrier-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-fbarrier-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,44 @@\n+/* brig-fbarrier-handler.cc -- brig fbarrier directive handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"brig-code-entry-handler.h\"\n+\n+#include \"stringpool.h\"\n+#include \"errors.h\"\n+\n+/* Allocate this many bytes from the group segment for each fbarrier.  */\n+#define FBARRIER_STRUCT_SIZE 32\n+\n+size_t\n+brig_directive_fbarrier_handler::operator () (const BrigBase *base)\n+{\n+  /* Model fbarriers as group segment variables with fixed size\n+     large enough to store whatever data the actual target needs\n+     to store to maintain the barrier info.  The handle is the\n+     offset to the beginning of the object.  */\n+\n+  const BrigDirectiveFbarrier* fbar = (const BrigDirectiveFbarrier*)base;\n+  if (m_parent.m_cf != NULL)\n+    m_parent.m_cf->m_function_scope_vars.insert (base);\n+  std::string var_name = m_parent.get_mangled_name (fbar);\n+  m_parent.append_group_variable (var_name, FBARRIER_STRUCT_SIZE, 1);\n+  return base->byteCount;\n+}"}, {"sha": "4e05680872b62d8089ce18004f9fcd2dee3afbfd", "filename": "gcc/brig/brigfrontend/brig-function-handler.cc", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,374 @@\n+/* brig-code-entry-handler.cc -- brig function directive handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <sstream>\n+#include <iomanip>\n+\n+#include \"brig-code-entry-handler.h\"\n+\n+#include \"brig-machine.h\"\n+#include \"stringpool.h\"\n+#include \"tree-iterator.h\"\n+#include \"gimple-expr.h\"\n+#include \"function.h\"\n+#include \"phsa.h\"\n+\n+#include \"tree-pretty-print.h\"\n+#include \"print-tree.h\"\n+\n+extern int gccbrig_verbose;\n+\n+size_t\n+brig_directive_function_handler::operator () (const BrigBase *base)\n+{\n+  m_parent.finish_function ();\n+\n+  size_t bytes_consumed = base->byteCount;\n+\n+  const BrigDirectiveExecutable *exec = (const BrigDirectiveExecutable *) base;\n+\n+  if (gccbrig_verbose)\n+    {\n+      printf (\"brig: function name %s\\n\",\n+\t      m_parent.get_string (exec->name).c_str());\n+      printf (\"brig: inargs %d outargs %d name offset %d\\n\", exec->inArgCount,\n+\t      exec->outArgCount, exec->name);\n+    }\n+\n+  const bool is_definition\n+    = exec->modifier & BRIG_EXECUTABLE_DEFINITION;\n+\n+  const bool is_kernel = base->kind == BRIG_KIND_DIRECTIVE_KERNEL;\n+\n+  /* There doesn't seem to be actual use cases for kernel declarations\n+     as they cannot be called by the program.  Ignore them until there's\n+     a reason not to.  */\n+  if (is_kernel && !is_definition)\n+    return bytes_consumed;\n+\n+  m_parent.m_cf = new brig_function (exec, &m_parent);\n+\n+  std::string func_name = m_parent.get_mangled_name (exec);\n+\n+  tree fndecl;\n+  tree ret_value = NULL_TREE;\n+\n+  tree stmt_list = alloc_stmt_list ();\n+\n+  /* Add a function scope BIND_EXPR using which we can push local variables that\n+     represent HSAIL registers.  */\n+  tree bind_expr = build3 (BIND_EXPR, void_type_node, NULL, stmt_list, NULL);\n+\n+  if (is_kernel)\n+    {\n+      /* The generated kernel function is not the one that should be\n+\t called by the host.  */\n+      func_name = std::string (\"_\") + func_name;\n+\n+      tree name_identifier\n+\t= get_identifier_with_length (func_name.c_str (), func_name.size ());\n+\n+      /* The generated kernel functions take the following arguments:\n+\n+\t 1) a char* which is a starting address of the argument segment where\n+\t the call's arguments are stored by the launcher.\n+\t 2) a void* parameter that points to a phsail-finalizer context object\n+\t which passes the hsa kernel packet etc.\n+\t 3) a void* parameter that contains the first flat address of the group\n+\t region allocated to the current work-group.  */\n+\n+      tree char_ptr_type_node = build_pointer_type (char_type_node);\n+      fndecl = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, name_identifier,\n+\t\t\t   build_function_type_list (void_type_node,\n+\t\t\t\t\t\t     char_ptr_type_node,\n+\t\t\t\t\t\t     ptr_type_node,\n+\t\t\t\t\t\t     ptr_type_node, NULL_TREE));\n+\n+      SET_DECL_ASSEMBLER_NAME (fndecl, name_identifier);\n+\n+      tree resdecl\n+\t= build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE, void_type_node);\n+\n+      tree typelist = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+      tree argtype = TREE_VALUE (typelist);\n+      TYPE_ADDR_SPACE (argtype)\n+\t= gccbrig_get_target_addr_space_id (BRIG_SEGMENT_KERNARG);\n+\n+      tree arg_arg = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n+\t\t\t\t get_identifier (\"__args\"), char_ptr_type_node);\n+      DECL_ARGUMENTS (fndecl) = arg_arg;\n+      DECL_ARG_TYPE (arg_arg) = char_ptr_type_node;\n+      DECL_CONTEXT (arg_arg) = fndecl;\n+      DECL_ARTIFICIAL (arg_arg) = 1;\n+      TREE_READONLY (arg_arg) = 1;\n+      TREE_USED (arg_arg) = 1;\n+\n+      DECL_RESULT (fndecl) = resdecl;\n+      DECL_CONTEXT (resdecl) = fndecl;\n+      DECL_EXTERNAL (fndecl) = 0;\n+    }\n+  else\n+    {\n+      /* Build a regular function fingerprint to enable targets to optimize\n+\t the calling convention as they see fit.  */\n+      tree name_identifier\n+\t= get_identifier_with_length (func_name.c_str (), func_name.size ());\n+\n+      m_parent.m_cf->m_arg_variables.clear ();\n+\n+      brig_directive_variable_handler arg_handler (m_parent);\n+\n+      vec<tree, va_gc> *args;\n+      vec_alloc (args, 4);\n+\n+      tree arg_decls = NULL_TREE;\n+\n+      tree ret_type = void_type_node;\n+      if (exec->outArgCount == 1)\n+\t{\n+\t  /* The return value variable should be the first entry after the\n+\t     function directive.  */\n+\t  const BrigBase *retval\n+\t    = (const BrigBase *) ((const char *) base + base->byteCount);\n+\t  gcc_assert (retval->kind == BRIG_KIND_DIRECTIVE_VARIABLE);\n+\n+\t  const BrigDirectiveVariable *brigVar\n+\t    = (const BrigDirectiveVariable *) retval;\n+\n+\t  brig_directive_variable_handler varhandler (m_parent);\n+\n+\t  if (brigVar->type & BRIG_TYPE_ARRAY)\n+\t    {\n+\t      /* Push array output arguments to the beginning of the\n+\t\t function argument list instead of regular function\n+\t\t return values.  */\n+\n+\t      tree arg_var = varhandler.build_variable (brigVar, PARM_DECL);\n+\t      vec_safe_push (args, TREE_TYPE (arg_var));\n+\n+\t      m_parent.m_cf->add_arg_variable (brigVar, arg_var);\n+\n+\t      if (arg_decls == NULL_TREE)\n+\t\targ_decls = arg_var;\n+\t      else\n+\t\tchainon (arg_decls, arg_var);\n+\n+\t      m_parent.m_cf->add_arg_variable (brigVar, arg_var);\n+\n+\t      ret_value = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE,\n+\t\t\t\t      void_type_node);\n+\t    }\n+\t  else\n+\t    {\n+\t      ret_value = varhandler.build_variable (brigVar, RESULT_DECL);\n+\t      m_parent.m_cf->m_ret_value = ret_value;\n+\t      ret_type = TREE_TYPE (ret_value);\n+\t      m_parent.m_cf->m_ret_value_brig_var = brigVar;\n+\t    }\n+\t  bytes_consumed += retval->byteCount;\n+\t}\n+      else\n+\tret_value = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE,\n+\t\t\t\tvoid_type_node);\n+\n+      TREE_ADDRESSABLE (ret_value) = 1;\n+\n+      if (exec->inArgCount > 0)\n+\t{\n+\t  uint32_t arg_offset = exec->firstInArg;\n+\t  for (size_t arg = 0; arg < exec->inArgCount; ++arg)\n+\t    {\n+\n+\t      const BrigDirectiveVariable *brigVar\n+\t\t= (const BrigDirectiveVariable *) m_parent.get_brig_code_entry\n+\t\t(arg_offset);\n+\n+\t      gcc_assert (brigVar->base.kind == BRIG_KIND_DIRECTIVE_VARIABLE);\n+\n+\t      /* Delegate to the brig_directive_variable_handler.  */\n+\t      brig_directive_variable_handler varhandler (m_parent);\n+\t      tree arg_var = varhandler.build_variable (brigVar, PARM_DECL);\n+\t      arg_offset += brigVar->base.byteCount;\n+\t      vec_safe_push (args, TREE_TYPE (arg_var));\n+\n+\t      m_parent.m_cf->add_arg_variable (brigVar, arg_var);\n+\n+\t      if (arg_decls == NULL_TREE)\n+\t\targ_decls = arg_var;\n+\t      else\n+\t\tchainon (arg_decls, arg_var);\n+\t    }\n+\t}\n+\n+      vec_safe_push (args, ptr_type_node);\n+      vec_safe_push (args, ptr_type_node);\n+\n+      fndecl = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, name_identifier,\n+\t\t\t   build_function_type_vec (ret_type, args));\n+\n+      DECL_RESULT (fndecl) = ret_value;\n+      DECL_CONTEXT (ret_value) = fndecl;\n+      DECL_EXTERNAL (fndecl) = 0;\n+      DECL_ARGUMENTS (fndecl) = arg_decls;\n+    }\n+\n+  /* All functions need the hidden __context argument passed on\n+     because they might call WI-specific functions which need\n+     the context info.  */\n+  tree context_arg = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n+\t\t\t\t get_identifier (\"__context\"), ptr_type_node);\n+  if (DECL_ARGUMENTS (fndecl) == NULL_TREE)\n+    DECL_ARGUMENTS (fndecl) = context_arg;\n+  else\n+    chainon (DECL_ARGUMENTS (fndecl), context_arg);\n+  DECL_CONTEXT (context_arg) = fndecl;\n+  DECL_ARG_TYPE (context_arg) = ptr_type_node;\n+  DECL_ARTIFICIAL (context_arg) = 1;\n+  TREE_READONLY (context_arg) = 1;\n+  TREE_USED (context_arg) = 1;\n+\n+  /* They can also access group memory, so we need to pass the\n+     group pointer along too.  */\n+  tree group_base_arg\n+    = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n+\t\t  get_identifier (\"__group_base_addr\"), ptr_type_node);\n+  chainon (DECL_ARGUMENTS (fndecl), group_base_arg);\n+  DECL_ARG_TYPE (group_base_arg) = ptr_type_node;\n+  DECL_CONTEXT (group_base_arg) = fndecl;\n+  DECL_ARTIFICIAL (group_base_arg) = 1;\n+  TREE_READONLY (group_base_arg) = 1;\n+  TREE_USED (group_base_arg) = 1;\n+\n+  /* Same for private.  */\n+  tree private_base_arg\n+    = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n+\t\t  get_identifier (\"__private_base_addr\"), ptr_type_node);\n+  chainon (DECL_ARGUMENTS (fndecl), private_base_arg);\n+  DECL_ARG_TYPE (private_base_arg) = ptr_type_node;\n+  DECL_CONTEXT (private_base_arg) = fndecl;\n+  DECL_ARTIFICIAL (private_base_arg) = 1;\n+  TREE_READONLY (private_base_arg) = 1;\n+  TREE_USED (private_base_arg) = 1;\n+\n+  DECL_SAVED_TREE (fndecl) = bind_expr;\n+\n+  /* Try to preserve the functions across IPA.  */\n+  DECL_PRESERVE_P (fndecl) = 1;\n+  TREE_SIDE_EFFECTS (fndecl) = 1;\n+\n+  TREE_ADDRESSABLE (fndecl) = 1;\n+\n+  if (base->kind == BRIG_KIND_DIRECTIVE_FUNCTION)\n+    {\n+      TREE_STATIC (fndecl) = 1;\n+      TREE_PUBLIC (fndecl) = 1;\n+    }\n+  else if (base->kind == BRIG_KIND_DIRECTIVE_KERNEL)\n+    {\n+      TREE_STATIC (fndecl) = 1;\n+      TREE_PUBLIC (fndecl) = 1;\n+    }\n+  else if (base->kind == BRIG_KIND_DIRECTIVE_SIGNATURE)\n+    {\n+      TREE_STATIC (fndecl) = 0;\n+      TREE_PUBLIC (fndecl) = 1;\n+      DECL_EXTERNAL (fndecl) = 1;\n+    }\n+  else if (base->kind == BRIG_KIND_DIRECTIVE_INDIRECT_FUNCTION)\n+    {\n+      TREE_STATIC (fndecl) = 0;\n+      TREE_PUBLIC (fndecl) = 1;\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  TREE_USED (fndecl) = 1;\n+  DECL_ARTIFICIAL (fndecl) = 0;\n+\n+  tree initial_block = make_node (BLOCK);\n+  DECL_INITIAL (fndecl) = initial_block;\n+  TREE_USED (DECL_INITIAL (fndecl)) = 1;\n+\n+  if (ret_value != NULL_TREE && TREE_TYPE (ret_value) != void_type_node)\n+    {\n+      DECL_CONTEXT (ret_value) = fndecl;\n+      DECL_CHAIN (ret_value) = BIND_EXPR_VARS (bind_expr);\n+      BIND_EXPR_VARS (bind_expr) = ret_value;\n+    }\n+\n+  tree arg;\n+  for (arg = DECL_ARGUMENTS (fndecl); arg != NULL_TREE; arg = TREE_CHAIN (arg))\n+    {\n+      DECL_CONTEXT (arg) = fndecl;\n+      DECL_ARG_TYPE (arg) = TREE_TYPE (arg);\n+    }\n+\n+  m_parent.add_function_decl (func_name, fndecl);\n+  m_parent.append_global (fndecl);\n+\n+  if (!is_definition)\n+    return bytes_consumed;\n+\n+  m_parent.start_function (fndecl);\n+\n+  m_parent.m_cf->m_name = func_name;\n+  m_parent.m_cf->m_func_decl = fndecl;\n+  m_parent.m_cf->m_current_bind_expr = bind_expr;\n+  m_parent.m_cf->m_is_kernel = is_kernel;\n+  m_parent.m_cf->m_context_arg = context_arg;\n+  m_parent.m_cf->m_group_base_arg = group_base_arg;\n+  m_parent.m_cf->m_private_base_arg = private_base_arg;\n+\n+  if (ret_value != NULL_TREE && TREE_TYPE (ret_value) != void_type_node)\n+    {\n+      /* We cannot assign to <<retval>> directly in gcc trunk.  We need to\n+\t create a local temporary variable which can be stored to and when\n+\t returning from the function, we'll copy it to the actual <<retval>>\n+\t in return statement's argument.  */\n+      tree temp_var = m_parent.m_cf->m_ret_temp\n+\t= m_parent.m_cf->add_local_variable (\"_retvalue_temp\",\n+\t\t\t\t\t     TREE_TYPE (ret_value));\n+      TREE_ADDRESSABLE (temp_var) = 1;\n+    }\n+\n+  if (is_kernel)\n+    {\n+      m_parent.m_cf->add_id_variables ();\n+\n+      /* Create a single entry point in the function.  */\n+      m_parent.m_cf->m_entry_label_stmt\n+\t= build_stmt (LABEL_EXPR, m_parent.m_cf->label (\"__kernel_entry\"));\n+      m_parent.m_cf->append_statement (m_parent.m_cf->m_entry_label_stmt);\n+\n+      tree bind_expr = m_parent.m_cf->m_current_bind_expr;\n+      tree stmts = BIND_EXPR_BODY (bind_expr);\n+\n+      m_parent.m_cf->m_kernel_entry = tsi_last (stmts);\n+\n+      /* Let's not append the exit label yet, but only after the\n+\t function has been built.  We need to build it so it can\n+\t be referred to because returns are converted to gotos to this\n+\t label.  */\n+      m_parent.m_cf->m_exit_label = m_parent.m_cf->label (\"__kernel_exit\");\n+    }\n+\n+  return bytes_consumed;\n+}"}, {"sha": "5f9784c2deeb5dbfc9122b567a6de07f49298465", "filename": "gcc/brig/brigfrontend/brig-function.cc", "status": "added", "additions": 723, "deletions": 0, "changes": 723, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,723 @@\n+/* brig-function.cc -- declaration of brig_function class.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <sstream>\n+#include <iomanip>\n+\n+#include \"brig-function.h\"\n+#include \"stringpool.h\"\n+#include \"tree-iterator.h\"\n+#include \"toplev.h\"\n+#include \"gimplify.h\"\n+#include \"gimple-expr.h\"\n+#include \"print-tree.h\"\n+#include \"hsa-brig-format.h\"\n+#include \"stor-layout.h\"\n+#include \"diagnostic-core.h\"\n+#include \"brig-code-entry-handler.h\"\n+#include \"brig-machine.h\"\n+#include \"brig-util.h\"\n+#include \"phsa.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"dumpfile.h\"\n+#include \"tree-cfg.h\"\n+#include \"errors.h\"\n+#include \"function.h\"\n+#include \"brig-to-generic.h\"\n+#include \"brig-builtins.h\"\n+\n+brig_function::brig_function (const BrigDirectiveExecutable *exec,\n+\t\t\t      brig_to_generic *parent)\n+  : m_brig_def (exec), m_is_kernel (false), m_is_finished (false), m_name (\"\"),\n+    m_current_bind_expr (NULL_TREE), m_func_decl (NULL_TREE),\n+    m_context_arg (NULL_TREE), m_group_base_arg (NULL_TREE),\n+    m_private_base_arg (NULL_TREE), m_ret_value (NULL_TREE),\n+    m_next_kernarg_offset (0), m_kernarg_max_align (0),\n+    m_ret_value_brig_var (NULL), m_has_barriers (false),\n+    m_has_allocas (false), m_has_function_calls_with_barriers (false),\n+    m_calls_analyzed (false), m_is_wg_function (false),\n+    m_has_unexpanded_dp_builtins (false), m_generating_arg_block (false),\n+    m_parent (parent)\n+{\n+  memset (m_regs, 0,\n+\t  BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT * sizeof (BrigOperandRegister *));\n+  memset (&m_descriptor, 0, sizeof (phsa_descriptor));\n+}\n+\n+brig_function::~brig_function ()\n+{\n+  for (size_t i = 0; i < BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT; ++i)\n+    {\n+      if (m_regs[i] != NULL)\n+\t{\n+\t  delete m_regs[i];\n+\t  m_regs[i] = NULL;\n+\t}\n+    }\n+}\n+\n+/* Returns a GENERIC label with the given name in the given function.\n+   Creates it, if not yet found.  */\n+\n+tree\n+brig_function::label (const std::string &name)\n+{\n+  label_index::const_iterator i = m_label_index.find (name);\n+  if (i == m_label_index.end ())\n+    {\n+      tree name_identifier\n+\t= get_identifier_with_length (name.c_str (), name.size ());\n+\n+      tree label_decl = build_decl (UNKNOWN_LOCATION, LABEL_DECL,\n+\t\t\t\t    name_identifier, void_type_node);\n+\n+      DECL_CONTEXT (label_decl) = m_func_decl;\n+      DECL_ARTIFICIAL (label_decl) = 0;\n+\n+      m_label_index[name] = label_decl;\n+      return label_decl;\n+    }\n+  else\n+    return (*i).second;\n+}\n+\n+/* Record an argument variable for later use.  This includes both local\n+   variables inside arg blocks and incoming function arguments.  */\n+\n+void\n+brig_function::add_arg_variable (const BrigDirectiveVariable *brigVar,\n+\t\t\t\t tree treeDecl)\n+{\n+  m_arg_variables[brigVar] = treeDecl;\n+}\n+\n+tree\n+brig_function::arg_variable (const BrigDirectiveVariable *var) const\n+{\n+  variable_index::const_iterator i = m_arg_variables.find (var);\n+  if (i == m_arg_variables.end ())\n+    return NULL_TREE;\n+  else\n+    return (*i).second;\n+}\n+\n+/* Appends a new kernel argument descriptor for the current kernel's\n+   arg space.  */\n+\n+void\n+brig_function::append_kernel_arg (const BrigDirectiveVariable *var, size_t size,\n+\t\t\t\t  size_t alignment)\n+{\n+  gcc_assert (m_func_decl != NULL_TREE);\n+  gcc_assert (m_is_kernel);\n+\n+  size_t align_padding = m_next_kernarg_offset % alignment == 0 ?\n+    0 : (alignment - m_next_kernarg_offset % alignment);\n+  m_next_kernarg_offset += align_padding;\n+  m_kernarg_offsets[var] = m_next_kernarg_offset;\n+  m_next_kernarg_offset += size;\n+\n+  m_kernarg_max_align\n+    = m_kernarg_max_align < alignment ? alignment : m_kernarg_max_align;\n+}\n+\n+size_t\n+brig_function::kernel_arg_offset (const BrigDirectiveVariable *var) const\n+{\n+  var_offset_table::const_iterator i = m_kernarg_offsets.find (var);\n+  gcc_assert (i != m_kernarg_offsets.end ());\n+  return (*i).second;\n+}\n+\n+/* Add work-item ID variables to the beginning of the kernel function\n+   which can be used for address computation as kernel dispatch packet\n+   instructions can be expanded to GENERIC nodes referring to them.  */\n+\n+void\n+brig_function::add_id_variables ()\n+{\n+  tree bind_expr = m_current_bind_expr;\n+  tree stmts = BIND_EXPR_BODY (bind_expr);\n+\n+  /* Initialize the WG limits and local ids.  */\n+\n+  tree_stmt_iterator entry = tsi_start (stmts);\n+\n+  for (int i = 0; i < 3; ++i)\n+    {\n+      char dim_char = (char) ((int) 'x' + i);\n+\n+      /* The local sizes are limited to 16b values, but let's still use 32b\n+\t to avoid unnecessary casts (the ID functions are 32b).  */\n+      m_local_id_vars[i]\n+\t= add_local_variable (std::string (\"__local_\") + dim_char,\n+\t\t\t      uint32_type_node);\n+\n+      tree workitemid_call\n+\t= call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_WORKITEMID), 2,\n+\t\t\tuint32_type_node, uint32_type_node,\n+\t\t\tbuild_int_cst (uint32_type_node, i), ptr_type_node,\n+\t\t\tm_context_arg);\n+\n+      tree id_init = build2 (MODIFY_EXPR, TREE_TYPE (m_local_id_vars[i]),\n+\t\t\t     m_local_id_vars[i], workitemid_call);\n+\n+      tsi_link_after (&entry, id_init, TSI_NEW_STMT);\n+\n+      m_cur_wg_size_vars[i]\n+\t= add_local_variable (std::string (\"__cur_wg_size_\") + dim_char,\n+\t\t\t      uint32_type_node);\n+\n+      tree cwgz_call\n+\t= call_builtin\n+\t(builtin_decl_explicit (BUILT_IN_HSAIL_CURRENTWORKGROUPSIZE),\n+\t 2, uint32_type_node, uint32_type_node,\n+\t build_int_cst (uint32_type_node, i), ptr_type_node, m_context_arg);\n+\n+      tree limit_init = build2 (MODIFY_EXPR, TREE_TYPE (m_cur_wg_size_vars[i]),\n+\t\t\t\tm_cur_wg_size_vars[i], cwgz_call);\n+\n+      tsi_link_after (&entry, limit_init, TSI_NEW_STMT);\n+\n+      m_wg_id_vars[i]\n+\t= add_local_variable (std::string (\"__workgroupid_\") + dim_char,\n+\t\t\t      uint32_type_node);\n+\n+      tree wgid_call\n+\t= call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_WORKGROUPID),\n+\t\t\t2, uint32_type_node, uint32_type_node,\n+\t\t\tbuild_int_cst (uint32_type_node, i), ptr_type_node,\n+\t\t\tm_context_arg);\n+\n+      tree wgid_init = build2 (MODIFY_EXPR, TREE_TYPE (m_wg_id_vars[i]),\n+\t\t\t       m_wg_id_vars[i], wgid_call);\n+\n+      tsi_link_after (&entry, wgid_init, TSI_NEW_STMT);\n+\n+      m_wg_size_vars[i]\n+\t= add_local_variable (std::string (\"__workgroupsize_\") + dim_char,\n+\t\t\t      uint32_type_node);\n+\n+      tree wgsize_call\n+\t= call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_WORKGROUPSIZE),\n+\t\t\t2, uint32_type_node, uint32_type_node,\n+\t\t\tbuild_int_cst (uint32_type_node, i), ptr_type_node,\n+\t\t\tm_context_arg);\n+\n+      tree wgsize_init = build2 (MODIFY_EXPR, TREE_TYPE (m_wg_size_vars[i]),\n+\t\t\t\t m_wg_size_vars[i], wgsize_call);\n+\n+      tsi_link_after (&entry, wgsize_init, TSI_NEW_STMT);\n+\n+      m_grid_size_vars[i]\n+\t= add_local_variable (std::string (\"__gridsize_\") + dim_char,\n+\t\t\t      uint32_type_node);\n+\n+      tree gridsize_call\n+\t= call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_GRIDSIZE), 2,\n+\t\t\tuint32_type_node, uint32_type_node,\n+\t\t\tbuild_int_cst (uint32_type_node, i), ptr_type_node,\n+\t\t\tm_context_arg);\n+\n+      tree gridsize_init = build2 (MODIFY_EXPR, TREE_TYPE (m_grid_size_vars[i]),\n+\t\t\t\t   m_grid_size_vars[i], gridsize_call);\n+\n+      tsi_link_after (&entry, gridsize_init, TSI_NEW_STMT);\n+    }\n+\n+  m_kernel_entry = entry;\n+}\n+\n+/* Creates a new local variable with the given NAME and given GENERIC\n+   TYPE.  */\n+\n+tree\n+brig_function::add_local_variable (std::string name, tree type)\n+{\n+  tree name_identifier\n+    = get_identifier_with_length (name.c_str (), name.size ());\n+  tree variable\n+    = build_decl (UNKNOWN_LOCATION, VAR_DECL, name_identifier, type);\n+\n+  DECL_NONLOCAL (variable) = 0;\n+  TREE_ADDRESSABLE (variable) = 0;\n+  TREE_STATIC (variable) = 0;\n+  TREE_USED (variable) = 1;\n+  DECL_ARTIFICIAL (variable) = 0;\n+\n+  tree bind_expr = DECL_SAVED_TREE (m_func_decl);\n+\n+  DECL_CONTEXT (variable) = m_func_decl;\n+\n+  DECL_CHAIN (variable) = BIND_EXPR_VARS (bind_expr);\n+  BIND_EXPR_VARS (bind_expr) = variable;\n+  return variable;\n+}\n+\n+/* Returns a DECL_VAR for the given HSAIL operand register.\n+   If it has not been created yet for the function being generated,\n+   creates it as an unsigned int variable.  */\n+\n+tree\n+brig_function::get_m_var_declfor_reg (const BrigOperandRegister *reg)\n+{\n+  size_t offset = reg->regNum;\n+  switch (reg->regKind)\n+    {\n+    case BRIG_REGISTER_KIND_QUAD:\n+      offset\n+\t+= BRIG_2_TREE_HSAIL_D_REG_COUNT + BRIG_2_TREE_HSAIL_S_REG_COUNT +\n+\tBRIG_2_TREE_HSAIL_C_REG_COUNT;\n+      break;\n+    case BRIG_REGISTER_KIND_DOUBLE:\n+      offset += BRIG_2_TREE_HSAIL_S_REG_COUNT + BRIG_2_TREE_HSAIL_C_REG_COUNT;\n+      break;\n+    case BRIG_REGISTER_KIND_SINGLE:\n+      offset += BRIG_2_TREE_HSAIL_C_REG_COUNT;\n+    case BRIG_REGISTER_KIND_CONTROL:\n+      break;\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  reg_decl_index_entry *regEntry = m_regs[offset];\n+  if (regEntry == NULL)\n+    {\n+      size_t reg_size = gccbrig_reg_size (reg);\n+      tree type;\n+      if (reg_size > 1)\n+\ttype = build_nonstandard_integer_type (reg_size, true);\n+      else\n+\ttype = boolean_type_node;\n+\n+      /* Drop the const qualifier so we do not end up with a read only\n+\t register variable which cannot be written to later.  */\n+      tree nonconst_type = build_type_variant (type, false, false);\n+\n+      regEntry = new reg_decl_index_entry;\n+\n+      regEntry->m_var_decl\n+\t= add_local_variable (gccbrig_reg_name (reg), nonconst_type);\n+      m_regs[offset] = regEntry;\n+    }\n+  return regEntry->m_var_decl;\n+}\n+\n+/* Builds a work-item do..while loop for a single DIM.  HEADER_ENTRY is\n+   a statement after which the iteration variables should be initialized and\n+   the loop body starts.  BRANCH_AFTER is the statement after which the loop\n+   predicate check and the back edge goto will be appended.  */\n+\n+void\n+brig_function::add_wi_loop (int dim, tree_stmt_iterator *header_entry,\n+\t\t\t    tree_stmt_iterator *branch_after)\n+{\n+  tree ivar = m_local_id_vars[dim];\n+  tree ivar_max = m_cur_wg_size_vars[dim];\n+  tree_stmt_iterator entry = *header_entry;\n+\n+  /* TODO: this is not a parallel loop as we share the \"register variables\"\n+     across work-items.  Should create a copy of them per WI instance.  That\n+     is, declare temporaries for new definitions inside the loop body, not at\n+     function scope.  */\n+\n+  tree ivar_init = build2 (MODIFY_EXPR, TREE_TYPE (ivar), ivar,\n+\t\t\t   build_zero_cst (TREE_TYPE (ivar)));\n+  tsi_link_after (&entry, ivar_init, TSI_NEW_STMT);\n+\n+  tree loop_body_label\n+    = label (std::string (\"__wi_loop_\") + (char) ((int) 'x' + dim));\n+  tree loop_body_label_stmt = build_stmt (LABEL_EXPR, loop_body_label);\n+\n+  tsi_link_after (&entry, loop_body_label_stmt, TSI_NEW_STMT);\n+\n+  if (m_has_unexpanded_dp_builtins)\n+    {\n+      tree id_set_builtin\n+\t= builtin_decl_explicit (BUILT_IN_HSAIL_SETWORKITEMID);\n+      /* Set the local ID to the current wi-loop iteration variable value to\n+\t ensure the builtins see the correct values.  */\n+      tree id_set_call\n+\t= call_builtin (id_set_builtin, 3,\n+\t\t\tvoid_type_node, uint32_type_node,\n+\t\t\tbuild_int_cst (uint32_type_node, dim), uint32_type_node,\n+\t\t\tivar, ptr_type_node, m_context_arg);\n+      tsi_link_after (&entry, id_set_call, TSI_NEW_STMT);\n+    }\n+\n+  /* Increment the WI iteration variable.  */\n+  tree incr = build2 (PREINCREMENT_EXPR, TREE_TYPE (ivar), ivar,\n+\t\t      build_one_cst (TREE_TYPE (ivar)));\n+\n+  tsi_link_after (branch_after, incr, TSI_NEW_STMT);\n+\n+  /* Append the predicate check with the back edge goto.  */\n+  tree condition = build2 (LT_EXPR, TREE_TYPE (ivar), ivar, ivar_max);\n+  tree target_goto = build1 (GOTO_EXPR, void_type_node, loop_body_label);\n+  tree if_stmt\n+    = build3 (COND_EXPR, void_type_node, condition, target_goto, NULL_TREE);\n+  tsi_link_after (branch_after, if_stmt, TSI_NEW_STMT);\n+}\n+\n+/* Recursively analyzes the function and its callees for barrier usage.  */\n+\n+void\n+brig_function::analyze_calls ()\n+{\n+  if (m_calls_analyzed)\n+    return;\n+\n+  /* Set this early to not get stuck in case of recursive call graphs.\n+     This is safe because if the function calls itself, either the function\n+     has barrier calls which implies a call to a function with barrier calls,\n+     or it doesn't in which case the result depends on the later called\n+     functions.  */\n+  m_calls_analyzed = true;\n+\n+  for (size_t i = 0; i < m_called_functions.size (); ++i)\n+    {\n+      tree f = m_called_functions[i];\n+      brig_function *called_f = m_parent->get_finished_function (f);\n+      if (called_f == NULL)\n+\t{\n+\t  /* Unfinished function (only declaration within the set of BRIGs)\n+\t     found.  Cannot finish the CG analysis.  Have to assume it does have\n+\t     a barrier for safety.  */\n+\t  m_has_function_calls_with_barriers = true;\n+\t  m_has_unexpanded_dp_builtins = true;\n+\t  break;\n+\t}\n+      called_f->analyze_calls ();\n+      /* We can assume m_has_barriers has been correctly set during the\n+\t construction of the function decl.  No need to reanalyze it.  */\n+      m_has_function_calls_with_barriers |= called_f->m_has_barriers;\n+\n+      /* If the function or any of its called functions has dispatch\n+\t packet builtin calls that require the local id, we need to\n+\t set the local id to the context in the work item loop before\n+\t the functions are called.  If we analyze the opposite, these\n+\t function calls can be omitted.  */\n+      m_has_unexpanded_dp_builtins |= called_f->m_has_unexpanded_dp_builtins;\n+    }\n+}\n+\n+/* Tries to convert the current kernel to a work-group function that executes\n+   all work-items using loops.  Returns true in case the conversion was\n+   successful.  */\n+\n+bool\n+brig_function::convert_to_wg_function ()\n+{\n+  if (!m_calls_analyzed)\n+    analyze_calls ();\n+\n+  if (m_has_barriers || m_has_function_calls_with_barriers)\n+    return false;\n+\n+  /* The most trivial case: No barriers at all in the kernel.\n+     We can create one big work-item loop around the whole kernel.  */\n+  tree bind_expr = m_current_bind_expr;\n+  tree stmts = BIND_EXPR_BODY (bind_expr);\n+\n+  for (int i = 0; i < 3; ++i)\n+    {\n+      /* The previous loop has added a new label to the end of the function,\n+\t the next level loop should wrap around it also.  */\n+      tree_stmt_iterator function_exit = tsi_last (stmts);\n+      add_wi_loop (i, &m_kernel_entry, &function_exit);\n+    }\n+\n+  m_is_wg_function = true;\n+  return false;\n+}\n+\n+/* Emits a kernel description to a special ELF section so it can be\n+   utilized by an HSA runtime implementation.  The assembly block\n+   must be emitted to a statement list of an function, which is given\n+   as an argument.  Returns the assembly block used to emit the section. */\n+\n+tree\n+brig_function::emit_metadata (tree stmt_list)\n+{\n+  /* Emit an ELF section via an assembly directive that generates a special\n+     ELF section for each kernel that contains raw bytes of a descriptor\n+     object.  This is pretty disgusting, but life is never perfect ;)  */\n+\n+  /* Use the original kernel name without the '_' prefix in the section name.  */\n+  std::string kern_name = m_is_kernel ? m_name.substr (1) : m_name;\n+\n+  std::ostringstream strstr;\n+  strstr << std::endl\n+\t << \".pushsection \" << PHSA_DESC_SECTION_PREFIX << kern_name\n+\t << std::endl\n+\t << \"\\t.p2align 1, 1, 1\" << std::endl\n+\t << \"\\t.byte \";\n+\n+  for (size_t i = 0; i < sizeof (phsa_descriptor); ++i)\n+    {\n+      strstr << \"0x\" << std::setw (2) << std::setfill ('0') << std::hex\n+\t     << (unsigned) *((unsigned char *) &m_descriptor + i);\n+      if (i + 1 < sizeof (phsa_descriptor))\n+\tstrstr << \", \";\n+    }\n+\n+  strstr << std::endl << \".popsection\" << std::endl << std::endl;\n+\n+  tree metadata_asm\n+    = build_stmt (ASM_EXPR,\n+\t\t  build_string (strstr.str ().size (), strstr.str ().c_str ()),\n+\t\t  NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE);\n+\n+  append_to_statement_list_force (metadata_asm, &stmt_list);\n+  return metadata_asm;\n+}\n+\n+/* Emits the kernel launcher function.  Also emits the metadata section\n+   creation statements in it.\n+\n+   The launcher function calls the device-side runtime\n+   that runs the kernel for all work-items.  In C:\n+\n+   void KernelName (void* context, void* group_base_addr)\n+   {\n+     __hsail_launch_kernel (_KernelName, context, group_base_addr);\n+   }\n+\n+   or, in case of a successful conversion to a work-group function:\n+\n+   void KernelName (void* context, void* group_base_addr)\n+   {\n+     __hsail_launch_wg_function (_KernelName, context, group_base_addr);\n+   }\n+\n+   The user/host sees this function as the kernel to call from the\n+   outside.  The actual kernel generated from HSAIL was named _KernelName.\n+*/\n+\n+tree\n+brig_function::emit_launcher_and_metadata ()\n+{\n+  /* The original kernel name without the '_' prefix.  */\n+  std::string kern_name = m_name.substr (1);\n+\n+  tree name_identifier\n+    = get_identifier_with_length (kern_name.c_str (), kern_name.size ());\n+\n+  tree launcher\n+    = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, name_identifier,\n+\t\t  build_function_type_list (void_type_node, ptr_type_node,\n+\t\t\t\t\t    ptr_type_node, NULL_TREE));\n+\n+  TREE_USED (launcher) = 1;\n+  DECL_ARTIFICIAL (launcher) = 1;\n+\n+  tree context_arg = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n+\t\t\t\t get_identifier (\"__context\"), ptr_type_node);\n+\n+  DECL_ARGUMENTS (launcher) = context_arg;\n+  DECL_ARG_TYPE (context_arg) = ptr_type_node;\n+  DECL_CONTEXT (context_arg) = launcher;\n+  TREE_USED (context_arg) = 1;\n+  DECL_ARTIFICIAL (context_arg) = 1;\n+\n+  tree group_base_addr_arg\n+    = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n+\t\t  get_identifier (\"__group_base_addr\"), ptr_type_node);\n+\n+  chainon (DECL_ARGUMENTS (launcher), group_base_addr_arg);\n+  DECL_ARG_TYPE (group_base_addr_arg) = ptr_type_node;\n+  DECL_CONTEXT (group_base_addr_arg) = launcher;\n+  TREE_USED (group_base_addr_arg) = 1;\n+  DECL_ARTIFICIAL (group_base_addr_arg) = 1;\n+\n+  tree resdecl\n+    = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE, void_type_node);\n+\n+  DECL_RESULT (launcher) = resdecl;\n+  DECL_CONTEXT (resdecl) = launcher;\n+\n+  DECL_INITIAL (launcher) = make_node (BLOCK);\n+  TREE_USED (DECL_INITIAL (launcher)) = 1;\n+\n+  tree stmt_list = alloc_stmt_list ();\n+\n+  tree bind_expr = build3 (BIND_EXPR, void_type_node, NULL, stmt_list, NULL);\n+\n+  TREE_STATIC (launcher) = 0;\n+  TREE_PUBLIC (launcher) = 1;\n+\n+  DECL_SAVED_TREE (launcher) = bind_expr;\n+\n+  if (DECL_STRUCT_FUNCTION (launcher) == NULL)\n+    push_struct_function (launcher);\n+  else\n+    push_cfun (DECL_STRUCT_FUNCTION (launcher));\n+\n+  tree kernel_func_ptr = build1 (ADDR_EXPR, ptr_type_node, m_func_decl);\n+\n+  tree phsail_launch_kernel_call;\n+\n+  /* Emit a launcher depending whether we converted the kernel function to\n+     a work group function or not.  */\n+  if (m_is_wg_function)\n+    phsail_launch_kernel_call\n+      = call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_LAUNCH_WG_FUNC),\n+\t\t      3, void_type_node,\n+\t\t      ptr_type_node, kernel_func_ptr, ptr_type_node,\n+\t\t      context_arg, ptr_type_node, group_base_addr_arg);\n+  else\n+    phsail_launch_kernel_call\n+      = call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_LAUNCH_KERNEL),\n+\t\t      3, void_type_node,\n+\t\t      ptr_type_node, kernel_func_ptr, ptr_type_node,\n+\t\t      context_arg, ptr_type_node, group_base_addr_arg);\n+\n+  append_to_statement_list_force (phsail_launch_kernel_call, &stmt_list);\n+\n+  emit_metadata (stmt_list);\n+\n+  return launcher;\n+}\n+\n+tree\n+brig_function::append_statement (tree stmt)\n+{\n+  gcc_assert (m_func_decl != NULL);\n+\n+  tree bind_expr = m_current_bind_expr;\n+  tree stmts = BIND_EXPR_BODY (bind_expr);\n+\n+  append_to_statement_list_force (stmt, &stmts);\n+  return stmt;\n+}\n+\n+/* Creates a new \"alloca frame\" for the current function by\n+   injecting an alloca frame push in the beginning of the function\n+   and an alloca frame pop before all function exit points.  */\n+\n+void\n+brig_function::create_alloca_frame ()\n+{\n+  tree_stmt_iterator entry;\n+\n+  /* Adds the alloca push only after the ids have been initialized\n+     in case of a kernel function.  */\n+  if (m_is_kernel)\n+    entry = m_kernel_entry;\n+  else\n+    {\n+      tree bind_expr = m_current_bind_expr;\n+      tree stmts = BIND_EXPR_BODY (bind_expr);\n+      entry = tsi_start (stmts);\n+    }\n+\n+  tree push_frame_builtin = builtin_decl_explicit (BUILT_IN_HSAIL_PUSH_FRAME);\n+  tree push_frame_call\n+    = call_builtin (push_frame_builtin, 1, void_type_node, ptr_type_node,\n+\t\t    m_context_arg);\n+\n+  tsi_link_before (&entry, push_frame_call, TSI_NEW_STMT);\n+\n+  tree pop_frame_builtin = builtin_decl_explicit (BUILT_IN_HSAIL_POP_FRAME);\n+\n+  do\n+    {\n+      tree stmt = tsi_stmt (entry);\n+      if (TREE_CODE (stmt) == RETURN_EXPR)\n+\t{\n+\t  tree pop_frame_call\n+\t    = call_builtin (pop_frame_builtin, 1, void_type_node,\n+\t\t\t    ptr_type_node, m_context_arg);\n+\n+\t  tsi_link_before (&entry, pop_frame_call, TSI_SAME_STMT);\n+\t}\n+      tsi_next (&entry);\n+    }\n+  while (!tsi_end_p (entry));\n+}\n+\n+/* Finishes the currently built function.  After calling this, no new\n+   statements should be appeneded to the function.  */\n+void\n+brig_function::finish ()\n+{\n+  append_return_stmt ();\n+\n+  /* Currently assume single alloca frame per WG.  */\n+  if (m_has_allocas)\n+    create_alloca_frame ();\n+}\n+\n+void\n+brig_function::finish_kernel ()\n+{\n+  /* Kernel functions should have a single exit point.\n+     Let's create one.  The return instructions should have\n+     been converted to branches to this label.  */\n+  append_statement (build_stmt (LABEL_EXPR, m_exit_label));\n+  /* Attempt to convert the kernel to a work-group function that\n+     executes all work-items of the WG using a loop.  */\n+  convert_to_wg_function ();\n+\n+  append_return_stmt ();\n+\n+  /* Currently assume single alloca frame per WG.  */\n+  if (m_has_allocas)\n+    create_alloca_frame ();\n+}\n+\n+void\n+brig_function::append_return_stmt ()\n+{\n+  gcc_assert (m_current_bind_expr != NULL_TREE);\n+  tree stmts = BIND_EXPR_BODY (m_current_bind_expr);\n+\n+  if (STATEMENT_LIST_TAIL (stmts) == NULL)\n+    return; /* Empty function.  */\n+\n+  tree last_stmt = tsi_stmt (tsi_last (stmts));\n+\n+  if (TREE_CODE (last_stmt) == RETURN_EXPR)\n+    return;\n+\n+  if (m_ret_value != NULL_TREE)\n+    {\n+      tree result_assign\n+\t= build2 (MODIFY_EXPR, TREE_TYPE (m_ret_value), m_ret_value,\n+\t\t  m_ret_temp);\n+\n+      tree return_expr\n+\t= build1 (RETURN_EXPR, TREE_TYPE (result_assign), result_assign);\n+      append_to_statement_list_force (return_expr, &stmts);\n+    }\n+  else\n+    {\n+      tree return_stmt = build_stmt (RETURN_EXPR, NULL);\n+      append_to_statement_list_force (return_stmt, &stmts);\n+    }\n+}\n+\n+bool\n+brig_function::has_function_scope_var (const BrigBase* var) const\n+{\n+  return m_function_scope_vars.find (var) != m_function_scope_vars.end ();\n+}"}, {"sha": "81c3f89ecde64dd10c92a75a0130080fd03709d2", "filename": "gcc/brig/brigfrontend/brig-function.h", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.h?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,213 @@\n+/* brig-function.h -- declaration of brig_function class.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef BRIG_FUNCTION_H\n+#define BRIG_FUNCTION_H\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"ansidecl.h\"\n+#include \"coretypes.h\"\n+#include \"opts.h\"\n+#include \"tree.h\"\n+#include \"tree-iterator.h\"\n+#include \"hsa-brig-format.h\"\n+\n+class brig_to_generic;\n+\n+#include <map>\n+#include <string>\n+#include <vector>\n+#include <set>\n+\n+#include \"phsa.h\"\n+\n+typedef std::map<std::string, tree> label_index;\n+typedef std::map<const BrigDirectiveVariable *, tree> variable_index;\n+typedef std::vector<tree> tree_stl_vec;\n+\n+/* There are 128 c regs and 2048 s/d/q regs each in the HSAIL.  */\n+#define BRIG_2_TREE_HSAIL_C_REG_COUNT (128)\n+#define BRIG_2_TREE_HSAIL_S_REG_COUNT (2048)\n+#define BRIG_2_TREE_HSAIL_D_REG_COUNT (2048)\n+#define BRIG_2_TREE_HSAIL_Q_REG_COUNT (2048)\n+#define BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT\t\t\t\t       \\\n+  (BRIG_2_TREE_HSAIL_C_REG_COUNT + BRIG_2_TREE_HSAIL_S_REG_COUNT\t       \\\n+   + BRIG_2_TREE_HSAIL_D_REG_COUNT + BRIG_2_TREE_HSAIL_Q_REG_COUNT)\n+\n+/* Holds data for the currently built GENERIC function.  */\n+\n+class brig_function\n+{\n+public:\n+  typedef std::map<const BrigDirectiveVariable *, size_t> var_offset_table;\n+\n+private:\n+  struct reg_decl_index_entry\n+  {\n+    tree m_var_decl;\n+  };\n+\n+public:\n+  brig_function (const BrigDirectiveExecutable *exec, brig_to_generic *parent);\n+  ~brig_function ();\n+\n+  tree arg_variable (const BrigDirectiveVariable *var) const;\n+  void add_arg_variable (const BrigDirectiveVariable *brigVar, tree treeDecl);\n+\n+  void append_kernel_arg (const BrigDirectiveVariable *var, size_t size,\n+\t\t\t  size_t alignment);\n+\n+  size_t kernel_arg_offset (const BrigDirectiveVariable *var) const;\n+\n+  void add_id_variables ();\n+\n+  tree label (const std::string &name);\n+\n+  tree add_local_variable (std::string name, tree type);\n+\n+  tree get_m_var_declfor_reg (const BrigOperandRegister *reg);\n+\n+  bool convert_to_wg_function ();\n+\n+  void add_wi_loop (int dim, tree_stmt_iterator *header_entry,\n+\t\t    tree_stmt_iterator *branch_after);\n+\n+  tree emit_metadata (tree stmt_list);\n+  tree emit_launcher_and_metadata ();\n+\n+  tree append_statement (tree stmt);\n+\n+  void create_alloca_frame ();\n+\n+  void finish ();\n+  void finish_kernel ();\n+\n+  void append_return_stmt ();\n+\n+  bool has_function_scope_var (const BrigBase* var) const;\n+\n+  void analyze_calls ();\n+\n+  const BrigDirectiveExecutable *m_brig_def;\n+\n+  bool m_is_kernel;\n+  bool m_is_finished;\n+  std::string m_name;\n+  tree m_current_bind_expr;\n+  tree m_func_decl;\n+  tree m_entry_label_stmt;\n+  tree m_exit_label;\n+\n+  /* The __context function argument.  */\n+  tree m_context_arg;\n+  /* The __group_base_ptr argument in the current function.\n+     Points to the start of the group segment for the kernel\n+     instance.  */\n+  tree m_group_base_arg;\n+  /* The __private_base_ptr argument in the current function.\n+     Points to the start of the private segment.  */\n+  tree m_private_base_arg;\n+\n+  /* The return value variable for the current function.  */\n+  tree m_ret_value;\n+\n+  /* The offsets of the kernel arguments in the __arg blob\n+     pointing to the kernel argument space.  */\n+  size_t m_next_kernarg_offset;\n+\n+  /* The largest kernel argument variable alignment.  */\n+  size_t m_kernarg_max_align;\n+\n+  var_offset_table m_kernarg_offsets;\n+\n+  /* Argument variables in the currently handled binding expression\n+     (argument segment).  */\n+  variable_index m_arg_variables;\n+\n+  /* The brig variable for the function return value.  */\n+  const BrigDirectiveVariable *m_ret_value_brig_var;\n+\n+  /* The function local temporary variable for the return value.  */\n+  tree m_ret_temp;\n+\n+  /* Labels in the current function are collected here so we can refer\n+     to them from jumps before they have been placed to the function.  */\n+  label_index m_label_index;\n+\n+  /* If the kernel contains at least one barrier, this is set to true.  */\n+  bool m_has_barriers;\n+\n+  /* True if the function has at least one alloca instruction.  */\n+  bool m_has_allocas;\n+\n+  /* If the kernel containts at least one function call that _may_\n+     contain a barrier call, this is set to true.  */\n+  bool m_has_function_calls_with_barriers;\n+\n+  /* Set to true after this function has been analyzed for barrier and\n+     dispatch packet instruction usage in the final call graph analysis.  */\n+  bool m_calls_analyzed;\n+\n+  /* True in case the function was successfully converted to a WG function.  */\n+  bool m_is_wg_function;\n+\n+  /* Work-item ID related variables are cached in the entry of the kernel\n+     function in order to use them directly in address computations, leading\n+     to more efficient optimizations.  The references to the local variables\n+     are stored here.  */\n+  tree m_local_id_vars[3];\n+  tree m_cur_wg_size_vars[3];\n+  tree m_wg_id_vars[3];\n+  tree m_wg_size_vars[3];\n+  tree m_grid_size_vars[3];\n+\n+  /* Set to true in case the kernel contains at least one dispatch packet\n+     (work-item ID-related) builtin call that could not be expanded to\n+     tree nodes.  */\n+  bool m_has_unexpanded_dp_builtins;\n+\n+  /* Points to the instruction after which the real kernel code starts.\n+     Usually points to the last WI ID variable initialization statement.  */\n+  tree_stmt_iterator m_kernel_entry;\n+\n+  /* True if we are currently generating the contents of an arg block.  */\n+  bool m_generating_arg_block;\n+\n+  /* A collection of function scope variables seen so far for resolving\n+     variable references vs. module scope declarations.  */\n+  std::set<const BrigBase*> m_function_scope_vars;\n+\n+  /* The functions called by this function.  */\n+  std::vector<tree> m_called_functions;\n+\n+  brig_to_generic *m_parent;\n+  /* The metadata of the function that should be stored with the binary and\n+     passed to the HSA runtime:  */\n+  phsa_descriptor m_descriptor;\n+\n+private:\n+  /* Bookkeeping for the different HSA registers and their tree declarations\n+     for the currently generated function.  */\n+  reg_decl_index_entry *m_regs[BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT];\n+};\n+\n+#endif"}, {"sha": "8cd55035b49bf74dd6b5d28683b646ec80d9c2d6", "filename": "gcc/brig/brigfrontend/brig-inst-mod-handler.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-inst-mod-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-inst-mod-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-inst-mod-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,58 @@\n+/* brig-inst-mod-handler.cc -- brig rounding moded instruction handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"brig-code-entry-handler.h\"\n+\n+#include \"gimple-expr.h\"\n+#include \"errors.h\"\n+\n+size_t\n+brig_inst_mod_handler::generate (const BrigBase *base)\n+{\n+  brig_basic_inst_handler basic_handler (m_parent);\n+  return basic_handler (base);\n+}\n+\n+const BrigAluModifier8_t *\n+brig_inst_mod_handler::modifier (const BrigBase *base) const\n+{\n+  const BrigInstMod *inst = (const BrigInstMod *) base;\n+  return &inst->modifier;\n+}\n+\n+const BrigRound8_t *\n+brig_inst_mod_handler::round (const BrigBase *base) const\n+{\n+  const BrigInstMod *inst = (const BrigInstMod *) base;\n+  return &inst->round;\n+}\n+\n+/* This used to inject fesetround () calls to control the rounding mode of the\n+   actual executed floating point operation.  It turned out that supporting\n+   conversions using fesetround calls won't work in gcc due to it not being\n+   able to restrict code motions across calls at the moment.  This\n+   functionality is therefore disabled for now until a better solution is\n+   found or if fesetround () is fixed in gcc.  */\n+size_t\n+brig_inst_mod_handler::operator () (const BrigBase *base)\n+{\n+  return generate (base);\n+}"}, {"sha": "890cf5b25d67e2cb3bd490a9c525537adbe43008", "filename": "gcc/brig/brigfrontend/brig-label-handler.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-label-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-label-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-label-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,37 @@\n+/* brig-label-handler.cc -- brig label directive handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"brig-code-entry-handler.h\"\n+\n+size_t\n+brig_directive_label_handler::operator () (const BrigBase *base)\n+{\n+  const BrigDirectiveLabel *brig_label = (const BrigDirectiveLabel *) base;\n+\n+  const BrigData *label_name = m_parent.get_brig_data_entry (brig_label->name);\n+\n+  std::string label_str ((const char *) (label_name->bytes),\n+\t\t\t label_name->byteCount);\n+\n+  tree stmt = build_stmt (LABEL_EXPR, m_parent.m_cf->label (label_str));\n+  m_parent.m_cf->append_statement (stmt);\n+  return base->byteCount;\n+}"}, {"sha": "5cfe8d9671625e68c34c4f5a0cd8eba80c889a1a", "filename": "gcc/brig/brigfrontend/brig-lane-inst-handler.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-lane-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-lane-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-lane-inst-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,84 @@\n+/* brig-lane-inst-handler.cc -- brig lane instruction handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"brig-code-entry-handler.h\"\n+#include \"errors.h\"\n+#include \"diagnostic-core.h\"\n+#include \"brig-util.h\"\n+\n+brig_lane_inst_handler::brig_lane_inst_handler (brig_to_generic &parent)\n+  : brig_code_entry_handler (parent)\n+{\n+}\n+\n+size_t\n+brig_lane_inst_handler::operator () (const BrigBase *base)\n+{\n+  const BrigInstLane &inst = *(const BrigInstLane *) base;\n+  tree_stl_vec operands = build_operands (inst.base);\n+\n+  tree expr = NULL_TREE;\n+  if (inst.base.opcode == BRIG_OPCODE_ACTIVELANECOUNT)\n+    {\n+      /* Because we are fixed to single WI per wave, it's enough to\n+\t just check the src value of the single work item itself.  */\n+      expr = build2 (NE_EXPR, uint32_type_node,\n+\t\t     build_zero_cst (uint32_type_node), operands[1]);\n+    }\n+  else if (inst.base.opcode == BRIG_OPCODE_ACTIVELANEID)\n+    {\n+      expr = build_zero_cst (uint32_type_node);\n+    }\n+  else if (inst.base.opcode == BRIG_OPCODE_ACTIVELANEMASK)\n+    {\n+      tree u64_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U64);\n+      tree zero_cst = build_zero_cst (u64_type);\n+      expr = build2 (NE_EXPR, u64_type, zero_cst, operands[1]);\n+\n+      tree_stl_vec elements;\n+      elements.push_back (expr);\n+      elements.push_back (zero_cst);\n+      elements.push_back (zero_cst);\n+      elements.push_back (zero_cst);\n+\n+      expr = pack (elements);\n+    }\n+  else if (inst.base.opcode == BRIG_OPCODE_ACTIVELANEPERMUTE)\n+    {\n+      tree src = operands[1];\n+      tree identity = operands[3];\n+      tree use_identity = operands[4];\n+\n+      /* When WAVESIZE is 1, we either select the src of the work-item\n+\t itself or 'identity' in case use_identity is 1.  */\n+\n+      tree cmp = build2 (EQ_EXPR, uint32_type_node,\n+\t\t\t build_int_cstu (uint32_type_node, 1), use_identity);\n+\n+      expr = build3 (COND_EXPR, TREE_TYPE (src), cmp, identity, src);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  build_output_assignment (inst.base, operands[0], expr);\n+\n+  return base->byteCount;\n+}"}, {"sha": "62f07f7a8a64793dcb1ab8fdbbcab69ebdd0ed15", "filename": "gcc/brig/brigfrontend/brig-machine.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-machine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-machine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-machine.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,44 @@\n+/* brig-machine.c -- gccbrig machine queries\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"brig-machine.h\"\n+\n+/* Return the numerical address space id for the segment in the current\n+   target.  Currently a dummy function that always returns 0, serves as\n+   a placeholder for multi-AS machines.  */\n+\n+unsigned\n+gccbrig_get_target_addr_space_id (BrigSegment8_t)\n+{\n+  return 0;\n+}\n+\n+/* Return the WAVESIZE for the current target.  For now a dummy placeholder\n+   returning always 1.  */\n+\n+unsigned\n+gccbrig_get_target_wavesize ()\n+{\n+  return 1;\n+}"}, {"sha": "96efbf6153ecf4594944e1899c11c8b730d3e754", "filename": "gcc/brig/brigfrontend/brig-machine.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-machine.h?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,33 @@\n+/* brig-machine.h -- gccbrig machine queries\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_BRIG_MACHINE_H\n+#define GCC_BRIG_MACHINE_H\n+\n+#include \"hsa-brig-format.h\"\n+\n+/* These functions should be eventually converted to machine info queries and\n+   redefined at backends.  At that point make these functions delegate to\n+   those.  */\n+\n+unsigned gccbrig_get_target_addr_space_id (BrigSegment8_t segment);\n+\n+unsigned gccbrig_get_target_wavesize ();\n+\n+#endif"}, {"sha": "dfd336933be61a120988bef929035ccf7d3f309c", "filename": "gcc/brig/brigfrontend/brig-mem-inst-handler.cc", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-mem-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-mem-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-mem-inst-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,180 @@\n+/* brig-mem-inst-handler.cc -- brig memory inst handler\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"brig-code-entry-handler.h\"\n+\n+#include \"errors.h\"\n+#include \"brig-util.h\"\n+#include \"gimple-expr.h\"\n+#include \"print-tree.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"convert.h\"\n+#include \"diagnostic-core.h\"\n+\n+tree\n+brig_mem_inst_handler::build_mem_access (const BrigInstBase *brig_inst,\n+\t\t\t\t\t tree addr, tree data)\n+{\n+  bool is_load = brig_inst->opcode == BRIG_OPCODE_LD;\n+  bool is_store = brig_inst->opcode == BRIG_OPCODE_ST;\n+\n+  if (!is_load && !is_store)\n+    gcc_unreachable ();\n+\n+  tree instr_type = gccbrig_tree_type_for_hsa_type (brig_inst->type);\n+\n+  if (VECTOR_TYPE_P (TREE_TYPE (data)))\n+    instr_type = TREE_TYPE (data);\n+\n+  tree ptype = build_pointer_type (instr_type);\n+\n+  /* The HSAIL mem instructions are unaligned by default.\n+     TODO: exploit the align modifier, it should lead to faster code.\n+  */\n+  tree unaligned_type = build_aligned_type (instr_type, 8);\n+\n+  /* Create a mem ref from the previous result, without offset.  */\n+  tree mem_ref\n+    = build2 (MEM_REF, unaligned_type, addr, build_int_cst (ptype, 0));\n+\n+  if (is_load)\n+    {\n+      /* Add a temporary variable so there won't be multiple\n+\t reads in case of vector unpack.  */\n+      mem_ref = add_temp_var (\"mem_read\", mem_ref);\n+      return build_output_assignment (*brig_inst, data, mem_ref);\n+    }\n+  else\n+    {\n+      tree stmt = build2 (MODIFY_EXPR, TREE_TYPE (mem_ref), mem_ref, data);\n+      return m_parent.m_cf->append_statement (stmt);\n+    }\n+  return mem_ref;\n+}\n+\n+size_t\n+brig_mem_inst_handler::operator () (const BrigBase *base)\n+{\n+  const BrigInstBase *brig_inst\n+    = (const BrigInstBase *) &((const BrigInstBasic *) base)->base;\n+\n+  if (brig_inst->opcode == BRIG_OPCODE_ALLOCA)\n+    {\n+      tree_stl_vec operands = build_operands (*brig_inst);\n+      size_t alignment = 1;\n+      const BrigInstMem *mem_inst = (const BrigInstMem *) brig_inst;\n+      if (mem_inst->align != BRIG_ALIGNMENT_NONE)\n+\t{\n+\t  alignment = 1 << (mem_inst->align - 1);\n+\t}\n+\n+      tree align_opr = build_int_cstu (size_type_node, alignment);\n+      tree_stl_vec inputs;\n+      inputs.push_back (operands[1]);\n+      inputs.push_back (align_opr);\n+      tree builtin_call\n+\t= expand_or_call_builtin (BRIG_OPCODE_ALLOCA, BRIG_TYPE_U32,\n+\t\t\t\t  uint32_type_node, inputs);\n+      build_output_assignment (*brig_inst, operands[0], builtin_call);\n+      m_parent.m_cf->m_has_allocas = true;\n+      return base->byteCount;\n+    }\n+\n+  tree instr_type = gccbrig_tree_type_for_hsa_type (brig_inst->type);\n+\n+  const BrigData *operand_entries\n+    = m_parent.get_brig_data_entry (brig_inst->operands);\n+\n+  uint32_t data_operand_offset;\n+  memcpy (&data_operand_offset, &operand_entries->bytes, 4);\n+\n+  const BrigBase *operand\n+    = m_parent.get_brig_operand_entry (data_operand_offset);\n+\n+  const BrigData *operandData = NULL;\n+\n+  bool is_store = brig_inst->opcode == BRIG_OPCODE_ST;\n+\n+  bool is_three_element_vector_access\n+    = operand->kind == BRIG_KIND_OPERAND_OPERAND_LIST\n+      && (operandData = m_parent.get_brig_data_entry\n+\t  (((const BrigOperandOperandList *) operand)->elements))\n+      && operandData->byteCount / 4 == 3;\n+\n+  if (is_three_element_vector_access)\n+    {\n+      /* We need to scalarize the 3-element vector accesses here\n+\t because gcc assumes the GENERIC vector datatypes are of two exponent\n+\t size internally.  */\n+      size_t bytes = operandData->byteCount;\n+      const BrigOperandOffset32_t *operand_ptr\n+\t= (const BrigOperandOffset32_t *) operandData->bytes;\n+\n+      uint32_t addr_operand_offset;\n+      memcpy (&addr_operand_offset, &operand_entries->bytes + 4, 4);\n+\n+      const BrigOperandAddress *addr_operand\n+\t= (const BrigOperandAddress *) m_parent.get_brig_operand_entry\n+\t(addr_operand_offset);\n+\n+      tree address_base = build_address_operand (*brig_inst, *addr_operand);\n+\n+      uint32_t address_offset = 0;\n+      while (bytes > 0)\n+\t{\n+\t  BrigOperandOffset32_t offset = *operand_ptr;\n+\t  const BrigBase *operand_element\n+\t    = m_parent.get_brig_operand_entry (offset);\n+\t  tree data\n+\t    = build_tree_operand (*brig_inst, *operand_element, instr_type);\n+\n+\t  tree ptr_offset = build_int_cst (size_type_node, address_offset);\n+\t  tree address = build2 (POINTER_PLUS_EXPR, TREE_TYPE (address_base),\n+\t\t\t\t address_base, ptr_offset);\n+\n+\t  if (is_store && TREE_TYPE (data) != instr_type)\n+\t    {\n+\t      if (int_size_in_bytes (TREE_TYPE (data))\n+\t\t    == int_size_in_bytes (instr_type)\n+\t\t  && !INTEGRAL_TYPE_P (instr_type))\n+\t\tdata = build1 (VIEW_CONVERT_EXPR, instr_type, data);\n+\t      else\n+\t\tdata = convert (instr_type, data);\n+\t    }\n+\n+\t  build_mem_access (brig_inst, address, data);\n+\n+\t  address_offset += int_size_in_bytes (instr_type);\n+\t  ++operand_ptr;\n+\t  bytes -= 4;\n+\t}\n+    }\n+  else\n+    {\n+      tree_stl_vec operands = build_operands (*brig_inst);\n+\n+      tree &data = operands.at (0);\n+      tree &addr = operands.at (1);\n+      build_mem_access (brig_inst, addr, data);\n+    }\n+\n+  return base->byteCount;\n+}"}, {"sha": "2c25189e0c6918963fa0ea9817f1e03cfe5241f9", "filename": "gcc/brig/brigfrontend/brig-module-handler.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-module-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-module-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-module-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,41 @@\n+/* brig-module-handler.cc -- brig module directive handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"brig-code-entry-handler.h\"\n+#include \"diagnostic-core.h\"\n+\n+size_t\n+brig_directive_module_handler::operator () (const BrigBase *base)\n+{\n+  const BrigDirectiveModule* mod = (const BrigDirectiveModule*)base;\n+  m_parent.m_module_name = m_parent.get_string (mod->name).substr (1);\n+  if (mod->hsailMajor != 1 || mod->hsailMinor != 0)\n+    fatal_error (UNKNOWN_LOCATION, PHSA_ERROR_PREFIX_INCOMPATIBLE_MODULE \" \"\n+\t\t \"HSAIL version not supported. HSAIL 1.0 required.\");\n+  if (mod->machineModel != BRIG_MACHINE_LARGE)\n+    fatal_error (UNKNOWN_LOCATION, PHSA_ERROR_PREFIX_INCOMPATIBLE_MODULE \" \"\n+\t\t \"Only HSA 'large' machine model supported.\");\n+  /* Do not check for the profile as the runtime conformance suite tests\n+     with 'full' profile BRIGs even though they don't use any full profile\n+     features.  This allows us to run the conformance suite with the\n+     BRIG FE.  */\n+  return base->byteCount;\n+}"}, {"sha": "eaf9d8dcc133127401efb4abb52e6e984f8736d6", "filename": "gcc/brig/brigfrontend/brig-queue-inst-handler.cc", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-queue-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-queue-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-queue-inst-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,93 @@\n+/* brig-queue-inst-handler.cc -- brig user mode queue related instruction\n+   handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <sstream>\n+\n+#include \"brig-code-entry-handler.h\"\n+#include \"brig-util.h\"\n+#include \"convert.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"errors.h\"\n+#include \"diagnostic-core.h\"\n+#include \"brig-builtins.h\"\n+\n+brig_queue_inst_handler::brig_queue_inst_handler (brig_to_generic &parent)\n+  : brig_code_entry_handler (parent)\n+{\n+}\n+\n+size_t\n+brig_queue_inst_handler::operator () (const BrigBase *base)\n+{\n+  const BrigInstBase &inst_base = *(const BrigInstBase *) base;\n+\n+  tree_stl_vec operands = build_operands (inst_base);\n+\n+  if (inst_base.opcode == BRIG_OPCODE_LDQUEUEWRITEINDEX\n+      || inst_base.opcode == BRIG_OPCODE_LDQUEUEREADINDEX)\n+    {\n+      tree builtin\n+\t= inst_base.opcode == BRIG_OPCODE_LDQUEUEWRITEINDEX\n+\t? builtin_decl_explicit (BUILT_IN_HSAIL_LDQUEUEWRITEINDEX)\n+\t: builtin_decl_explicit (BUILT_IN_HSAIL_LDQUEUEREADINDEX);\n+\n+      tree expr\n+\t= call_builtin (builtin, 1, uint64_type_node,\n+\t\t\tuint64_type_node, operands[1]);\n+      build_output_assignment (inst_base, operands[0], expr);\n+    }\n+  else if (inst_base.opcode == BRIG_OPCODE_STQUEUEWRITEINDEX\n+\t   || inst_base.opcode == BRIG_OPCODE_STQUEUEREADINDEX)\n+    {\n+      tree builtin\n+\t= inst_base.opcode == BRIG_OPCODE_STQUEUEWRITEINDEX\n+\t? builtin_decl_explicit (BUILT_IN_HSAIL_STQUEUEWRITEINDEX)\n+\t: builtin_decl_explicit (BUILT_IN_HSAIL_STQUEUEREADINDEX);\n+\n+      call_builtin (builtin, 2, void_type_node,\n+\t\t    uint64_type_node, operands[0], uint64_type_node,\n+\t\t    operands[1]);\n+    }\n+  else if (inst_base.opcode == BRIG_OPCODE_ADDQUEUEWRITEINDEX)\n+    {\n+      tree builtin = builtin_decl_explicit (BUILT_IN_HSAIL_ADDQUEUEWRITEINDEX);\n+\n+      tree expr = call_builtin (builtin, 2,\n+\t\t\t\tuint64_type_node, uint64_type_node, operands[1],\n+\t\t\t\tuint64_type_node, operands[2]);\n+      build_output_assignment (inst_base, operands[0], expr);\n+    }\n+  else if (inst_base.opcode == BRIG_OPCODE_CASQUEUEWRITEINDEX)\n+    {\n+      tree builtin = builtin_decl_explicit (BUILT_IN_HSAIL_CASQUEUEWRITEINDEX);\n+\n+      tree expr\n+\t= call_builtin (builtin, 3, uint64_type_node,\n+\t\t\tuint64_type_node, operands[1], uint64_type_node,\n+\t\t\toperands[2], uint64_type_node, operands[3]);\n+      build_output_assignment (inst_base, operands[0], expr);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  return base->byteCount;\n+}"}, {"sha": "e6801146cc76180e422fed48a30525ce1da1091f", "filename": "gcc/brig/brigfrontend/brig-seg-inst-handler.cc", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-seg-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-seg-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-seg-inst-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,146 @@\n+/* brig-seg-inst-handler.cc -- brig segment related instruction handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <sstream>\n+\n+#include \"brig-code-entry-handler.h\"\n+#include \"brig-util.h\"\n+#include \"convert.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"errors.h\"\n+#include \"diagnostic-core.h\"\n+\n+brig_seg_inst_handler::brig_seg_inst_handler (brig_to_generic &parent)\n+  : brig_code_entry_handler (parent)\n+{\n+}\n+\n+size_t\n+brig_seg_inst_handler::operator () (const BrigBase *base)\n+{\n+  const BrigInstBase &inst_base = *(const BrigInstBase *) base;\n+\n+  std::vector<tree> operands = build_operands (inst_base);\n+\n+  tree expr = NULL_TREE;\n+\n+  if (inst_base.opcode == BRIG_OPCODE_STOF)\n+    {\n+      const BrigInstSegCvt &inst = *(const BrigInstSegCvt *) base;\n+\n+      if (inst.segment == BRIG_SEGMENT_GROUP)\n+\texpr = build2 (PLUS_EXPR, size_type_node,\n+\t\t       convert_to_integer (size_type_node,\n+\t\t\t\t\t   m_parent.m_cf->m_group_base_arg),\n+\t\t       convert_to_integer (size_type_node, operands[1]));\n+      else if (inst.segment == BRIG_SEGMENT_PRIVATE\n+\t       || inst.segment == BRIG_SEGMENT_SPILL)\n+\texpr = build2 (PLUS_EXPR, size_type_node,\n+\t\t       convert_to_integer (size_type_node,\n+\t\t\t\t\t   m_parent.m_cf->m_private_base_arg),\n+\t\t       convert_to_integer (size_type_node, operands[1]));\n+      else\n+       gcc_unreachable ();\n+\n+      if (!(inst.modifier & BRIG_SEG_CVT_NONULL))\n+\t{\n+\t  /* Need to convert the null value. -1 is used for 32b segments,\n+\t     and 0 for flat/global.  */\n+\t  tree cmp\n+\t    = build2 (EQ_EXPR, uint32_type_node,\n+\t\t      build_int_cstu (uint32_type_node, -1), operands[1]);\n+\n+\t  tree null_check = build3 (COND_EXPR, size_type_node, cmp,\n+\t\t\t\t    build_int_cstu (size_type_node, 0), expr);\n+\n+\t  expr = null_check;\n+\t}\n+    }\n+  else if (inst_base.opcode == BRIG_OPCODE_FTOS)\n+    {\n+      const BrigInstSegCvt &inst = *(const BrigInstSegCvt *) base;\n+\n+      if (inst.segment == BRIG_SEGMENT_GROUP)\n+\texpr = build2 (MINUS_EXPR, size_type_node,\n+\t\t       convert_to_integer (size_type_node,\n+\t\t\t\t\t   m_parent.m_cf->m_group_base_arg),\n+\t\t       convert_to_integer (size_type_node, operands[1]));\n+      else if (inst.segment == BRIG_SEGMENT_PRIVATE)\n+\texpr = build2 (MINUS_EXPR, size_type_node,\n+\t\t       convert_to_integer (size_type_node,\n+\t\t\t\t\t   m_parent.m_cf->m_private_base_arg),\n+\t\t       convert_to_integer (size_type_node, operands[1]));\n+      else\n+\tgcc_unreachable ();\n+\n+      if (!(inst.modifier & BRIG_SEG_CVT_NONULL))\n+\t{\n+\t  /* Need to convert the null value. -1 is used for 32b segments,\n+\t     and 0 for flat/global.  */\n+\t  tree cmp = build2 (EQ_EXPR, size_type_node,\n+\t\t\t     build_int_cstu (size_type_node, 0), operands[1]);\n+\n+\t  tree null_check\n+\t    = build3 (COND_EXPR, size_type_node, cmp,\n+\t\t      build_int_cstu (uint32_type_node, -1), expr);\n+\t  expr = null_check;\n+\t}\n+    }\n+  else if (inst_base.opcode == BRIG_OPCODE_NULLPTR)\n+    {\n+      const BrigInstSeg &inst = *(const BrigInstSeg *) base;\n+      if (inst.segment == BRIG_SEGMENT_GLOBAL\n+\t  || inst.segment == BRIG_SEGMENT_FLAT\n+\t  || inst.segment == BRIG_SEGMENT_READONLY)\n+\texpr = build_int_cstu (uint64_type_node, 0);\n+      else\n+\texpr = build_int_cstu (uint32_type_node, -1);\n+    }\n+  else if (inst_base.opcode == BRIG_OPCODE_SEGMENTP)\n+    {\n+      const BrigInstSegCvt &inst = *(const BrigInstSegCvt *) base;\n+\n+      tree builtin = NULL_TREE;\n+      switch (inst.segment)\n+\t{\n+\tcase BRIG_SEGMENT_GLOBAL:\n+\t  builtin = builtin_decl_explicit (BUILT_IN_HSAIL_SEGMENTP_GLOBAL);\n+\t  break;\n+\tcase BRIG_SEGMENT_GROUP:\n+\t  builtin = builtin_decl_explicit (BUILT_IN_HSAIL_SEGMENTP_GROUP);\n+\t  break;\n+\tcase BRIG_SEGMENT_PRIVATE:\n+\t  builtin = builtin_decl_explicit (BUILT_IN_HSAIL_SEGMENTP_PRIVATE);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      expr = call_builtin (builtin, 2,\n+\t\t\t   uint32_type_node, uint64_type_node, operands[1],\n+\t\t\t   ptr_type_node, m_parent.m_cf->m_context_arg);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  build_output_assignment (inst_base, operands[0], expr);\n+  return base->byteCount;\n+}"}, {"sha": "5dd2268a9ceef716c08cbd20c00632af918156a2", "filename": "gcc/brig/brigfrontend/brig-signal-inst-handler.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-signal-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-signal-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-signal-inst-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,42 @@\n+/* brig-signal-inst-handler.cc -- brig signal instruction handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <sstream>\n+\n+#include \"brig-code-entry-handler.h\"\n+#include \"brig-util.h\"\n+#include \"fold-const.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"print-tree.h\"\n+#include \"convert.h\"\n+#include \"langhooks.h\"\n+#include \"gimple-expr.h\"\n+\n+size_t\n+brig_signal_inst_handler::operator () (const BrigBase *base)\n+{\n+  const BrigInstSignal *inst = (const BrigInstSignal *) base;\n+  BrigAtomicOperation8_t atomic_opcode;\n+  atomic_opcode = inst->signalOperation;\n+\n+  return generate_tree (inst->base, atomic_opcode);\n+}"}, {"sha": "d3a6786417970f7514cbf5b1e9ca598f27cd421c", "filename": "gcc/brig/brigfrontend/brig-to-generic.cc", "status": "added", "additions": 796, "deletions": 0, "changes": 796, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,796 @@\n+/* brig2tree.cc -- brig to gcc generic/gimple tree conversion\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <cassert>\n+#include <iostream>\n+#include <iomanip>\n+#include <sstream>\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"function.h\"\n+#include \"brig-to-generic.h\"\n+#include \"stringpool.h\"\n+#include \"tree-iterator.h\"\n+#include \"toplev.h\"\n+#include \"gimplify.h\"\n+#include \"gimple-expr.h\"\n+#include \"print-tree.h\"\n+#include \"hsa-brig-format.h\"\n+#include \"stor-layout.h\"\n+#include \"diagnostic-core.h\"\n+#include \"brig-code-entry-handler.h\"\n+#include \"brig-machine.h\"\n+#include \"brig-util.h\"\n+#include \"phsa.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"dumpfile.h\"\n+#include \"tree-cfg.h\"\n+#include \"errors.h\"\n+#include \"fold-const.h\"\n+#include \"cgraph.h\"\n+#include \"dumpfile.h\"\n+#include \"tree-pretty-print.h\"\n+\n+extern int gccbrig_verbose;\n+\n+tree brig_to_generic::s_fp16_type;\n+tree brig_to_generic::s_fp32_type;\n+tree brig_to_generic::s_fp64_type;\n+\n+brig_to_generic::brig_to_generic ()\n+  : m_cf (NULL), m_brig (NULL), m_next_group_offset (0),\n+    m_next_private_offset (0)\n+{\n+  m_globals = NULL_TREE;\n+\n+  /* Initialize the basic REAL types.\n+     This doesn't work straight away because most of the targets\n+     do not support fp16 natively.  Let's by default convert\n+     to fp32 and back before and after each instruction (handle it as\n+     a storage format only), and later add an optimization pass\n+     that removes the extra converts (in case of multiple fp16 ops\n+     in a row).  */\n+  s_fp16_type = make_node (REAL_TYPE);\n+  TYPE_PRECISION (s_fp16_type) = 16;\n+  TYPE_SIZE (s_fp16_type) = bitsize_int (16);\n+  TYPE_SIZE_UNIT (s_fp16_type) = size_int (2);\n+  SET_TYPE_ALIGN (s_fp16_type, 16);\n+  layout_type (s_fp16_type);\n+\n+  s_fp32_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_F32);\n+  s_fp64_type = gccbrig_tree_type_for_hsa_type (BRIG_TYPE_F64);\n+\n+  /* TODO: (machine)query the preferred rounding mode that is set by\n+     the machine by default.  This can be redefined by each BRIG module\n+     header.  */\n+  m_default_float_rounding_mode = BRIG_ROUND_FLOAT_ZERO;\n+\n+  m_dump_file = dump_begin (TDI_original, &m_dump_flags);\n+}\n+\n+class unimplemented_entry_handler : public brig_code_entry_handler\n+{\n+public:\n+  unimplemented_entry_handler (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+\n+  size_t\n+  operator () (const BrigBase *base)\n+  {\n+    gcc_unreachable ();\n+    return base->byteCount;\n+  }\n+};\n+\n+/* Handler for entries that can be (and are) safely skipped for the purposes\n+   of GENERIC generation.  */\n+\n+class skipped_entry_handler : public brig_code_entry_handler\n+{\n+public:\n+  skipped_entry_handler (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+\n+  size_t\n+  operator () (const BrigBase *base)\n+  {\n+    return base->byteCount;\n+  }\n+};\n+\n+/* Parses the given BRIG blob.  */\n+\n+void\n+brig_to_generic::parse (const char *brig_blob)\n+{\n+  m_brig = brig_blob;\n+  m_brig_blobs.push_back (brig_blob);\n+\n+  const BrigModuleHeader *mheader = (const BrigModuleHeader *) brig_blob;\n+\n+  if (strncmp (mheader->identification, \"HSA BRIG\", 8) != 0)\n+    fatal_error (UNKNOWN_LOCATION, PHSA_ERROR_PREFIX_INCOMPATIBLE_MODULE\n+\t\t \"Unrecognized file format.\");\n+  if (mheader->brigMajor != 1 || mheader->brigMinor != 0)\n+    fatal_error (UNKNOWN_LOCATION, PHSA_ERROR_PREFIX_INCOMPATIBLE_MODULE\n+\t\t \"BRIG version not supported. BRIG 1.0 required.\");\n+\n+  m_data = m_code = m_operand = NULL;\n+\n+  /* Find the positions of the different sections.  */\n+  for (uint32_t sec = 0; sec < mheader->sectionCount; ++sec)\n+    {\n+      uint64_t offset\n+\t= ((const uint64_t *) (brig_blob + mheader->sectionIndex))[sec];\n+\n+      const BrigSectionHeader *section_header\n+\t= (const BrigSectionHeader *) (brig_blob + offset);\n+\n+      std::string name ((const char *) (&section_header->name),\n+\t\t\tsection_header->nameLength);\n+\n+      if (sec == BRIG_SECTION_INDEX_DATA && name == \"hsa_data\")\n+\t{\n+\t  m_data = (const char *) section_header;\n+\t  m_data_size = section_header->byteCount;\n+\t}\n+      else if (sec == BRIG_SECTION_INDEX_CODE && name == \"hsa_code\")\n+\t{\n+\t  m_code = (const char *) section_header;\n+\t  m_code_size = section_header->byteCount;\n+\t}\n+      else if (sec == BRIG_SECTION_INDEX_OPERAND && name == \"hsa_operand\")\n+\t{\n+\t  m_operand = (const char *) section_header;\n+\t  m_operand_size = section_header->byteCount;\n+\t}\n+      else\n+\t{\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  if (m_code == NULL)\n+    gcc_unreachable ();\n+  if (m_data == NULL)\n+    gcc_unreachable ();\n+  if (m_operand == NULL)\n+    gcc_unreachable ();\n+\n+  brig_basic_inst_handler inst_handler (*this);\n+  brig_branch_inst_handler branch_inst_handler (*this);\n+  brig_cvt_inst_handler cvt_inst_handler (*this);\n+  brig_seg_inst_handler seg_inst_handler (*this);\n+  brig_copy_move_inst_handler copy_move_inst_handler (*this);\n+  brig_signal_inst_handler signal_inst_handler (*this);\n+  brig_atomic_inst_handler atomic_inst_handler (*this);\n+  brig_cmp_inst_handler cmp_inst_handler (*this);\n+  brig_mem_inst_handler mem_inst_handler (*this);\n+  brig_inst_mod_handler inst_mod_handler (*this);\n+  brig_directive_label_handler label_handler (*this);\n+  brig_directive_variable_handler var_handler (*this);\n+  brig_directive_fbarrier_handler fbar_handler (*this);\n+  brig_directive_comment_handler comment_handler (*this);\n+  brig_directive_function_handler func_handler (*this);\n+  brig_directive_control_handler control_handler (*this);\n+  brig_directive_arg_block_handler arg_block_handler (*this);\n+  brig_directive_module_handler module_handler (*this);\n+  brig_lane_inst_handler lane_inst_handler (*this);\n+  brig_queue_inst_handler queue_inst_handler (*this);\n+  skipped_entry_handler skipped_handler (*this);\n+  unimplemented_entry_handler unimplemented_handler (*this);\n+\n+  struct code_entry_handler_info\n+  {\n+    BrigKind kind;\n+    brig_code_entry_handler *handler;\n+  };\n+\n+  /* TODO: Convert to a hash table / map.  For now, put the more common\n+     entries to the top to keep the scan fast on average.  */\n+  code_entry_handler_info handlers[]\n+    = {{BRIG_KIND_INST_BASIC, &inst_handler},\n+       {BRIG_KIND_INST_CMP, &cmp_inst_handler},\n+       {BRIG_KIND_INST_MEM, &mem_inst_handler},\n+       {BRIG_KIND_INST_MOD, &inst_mod_handler},\n+       {BRIG_KIND_INST_CVT, &cvt_inst_handler},\n+       {BRIG_KIND_INST_SEG_CVT, &seg_inst_handler},\n+       {BRIG_KIND_INST_SEG, &seg_inst_handler},\n+       {BRIG_KIND_INST_ADDR, &copy_move_inst_handler},\n+       {BRIG_KIND_INST_SOURCE_TYPE, &copy_move_inst_handler},\n+       {BRIG_KIND_INST_ATOMIC, &atomic_inst_handler},\n+       {BRIG_KIND_INST_SIGNAL, &signal_inst_handler},\n+       {BRIG_KIND_INST_BR, &branch_inst_handler},\n+       {BRIG_KIND_INST_LANE, &lane_inst_handler},\n+       {BRIG_KIND_INST_QUEUE, &queue_inst_handler},\n+       /* Assuming fences are not needed.  FIXME: call builtins\n+\t  when porting to a platform where they are.  */\n+       {BRIG_KIND_INST_MEM_FENCE, &skipped_handler},\n+       {BRIG_KIND_DIRECTIVE_LABEL, &label_handler},\n+       {BRIG_KIND_DIRECTIVE_VARIABLE, &var_handler},\n+       {BRIG_KIND_DIRECTIVE_ARG_BLOCK_START, &arg_block_handler},\n+       {BRIG_KIND_DIRECTIVE_ARG_BLOCK_END, &arg_block_handler},\n+       {BRIG_KIND_DIRECTIVE_FBARRIER, &fbar_handler},\n+       {BRIG_KIND_DIRECTIVE_COMMENT, &comment_handler},\n+       {BRIG_KIND_DIRECTIVE_KERNEL, &func_handler},\n+       {BRIG_KIND_DIRECTIVE_SIGNATURE, &func_handler},\n+       {BRIG_KIND_DIRECTIVE_FUNCTION, &func_handler},\n+       {BRIG_KIND_DIRECTIVE_INDIRECT_FUNCTION, &func_handler},\n+       {BRIG_KIND_DIRECTIVE_MODULE, &module_handler},\n+       /* Skipping debug locations for now as not needed for conformance.  */\n+       {BRIG_KIND_DIRECTIVE_LOC, &skipped_handler},\n+       /* There are no supported pragmas at this moment.  */\n+       {BRIG_KIND_DIRECTIVE_PRAGMA, &skipped_handler},\n+       {BRIG_KIND_DIRECTIVE_CONTROL, &control_handler},\n+       {BRIG_KIND_DIRECTIVE_EXTENSION, &skipped_handler}};\n+\n+  const BrigSectionHeader *csection_header = (const BrigSectionHeader *) m_code;\n+\n+  for (size_t b = csection_header->headerByteCount; b < m_code_size;)\n+    {\n+      const BrigBase *entry = (const BrigBase *) (m_code + b);\n+\n+      brig_code_entry_handler *handler = &unimplemented_handler;\n+\n+      if (m_cf != NULL && b >= m_cf->m_brig_def->nextModuleEntry)\n+\tfinish_function (); /* The function definition ended.  */\n+\n+      /* Find a handler.  */\n+      for (size_t i = 0;\n+\t   i < sizeof (handlers) / sizeof (code_entry_handler_info); ++i)\n+\t{\n+\t  if (handlers[i].kind == entry->kind)\n+\t    handler = handlers[i].handler;\n+\t}\n+      b += (*handler) (entry);\n+      continue;\n+    }\n+\n+  finish_function ();\n+}\n+\n+const BrigData *\n+brig_to_generic::get_brig_data_entry (size_t entry_offset) const\n+{\n+  return (const BrigData *) (m_data + entry_offset);\n+}\n+\n+const BrigBase *\n+brig_to_generic::get_brig_operand_entry (size_t entry_offset) const\n+{\n+  return (const BrigBase *) (m_operand + entry_offset);\n+}\n+\n+const BrigBase *\n+brig_to_generic::get_brig_code_entry (size_t entry_offset) const\n+{\n+  return (const BrigBase *) (m_code + entry_offset);\n+}\n+\n+void\n+brig_to_generic::append_global (tree g)\n+{\n+  if (m_globals == NULL_TREE)\n+    {\n+      m_globals = g;\n+      return;\n+    }\n+  else\n+    {\n+      tree last = tree_last (m_globals);\n+      TREE_CHAIN (last) = g;\n+    }\n+}\n+\n+tree\n+brig_to_generic::global_variable (const std::string &name) const\n+{\n+  label_index::const_iterator i = m_global_variables.find (name);\n+  if (i == m_global_variables.end ())\n+    return NULL_TREE;\n+  else\n+    return (*i).second;\n+}\n+\n+/* Returns a function declaration with the given name.  Assumes it has been\n+   created previously via a DirectiveFunction or similar.  */\n+\n+tree\n+brig_to_generic::function_decl (const std::string &name)\n+{\n+  label_index::const_iterator i = m_function_index.find (name);\n+  if (i == m_function_index.end ())\n+    return NULL_TREE;\n+  return (*i).second;\n+}\n+\n+void\n+brig_to_generic::add_function_decl (const std::string &name, tree func_decl)\n+{\n+  m_function_index[name] = func_decl;\n+}\n+\n+/* Adds a GENERIC global variable VAR_DECL with the given NAME to the\n+   current module.  If we have generated a host def var ptr (a place holder\n+   for variables that are defined by the HSA host code) for this global\n+   variable definition (because there was a declaration earlier which looked\n+   like it might have been a host defined variable), we now have\n+   to assign its address and make it private to allow the references to\n+   point to the defined variable instead.  */\n+\n+void\n+brig_to_generic::add_global_variable (const std::string &name, tree var_decl)\n+{\n+  append_global (var_decl);\n+  m_global_variables[name] = var_decl;\n+\n+  std::string host_def_var_name\n+    = std::string (PHSA_HOST_DEF_PTR_PREFIX) + name;\n+  tree host_def_var = global_variable (host_def_var_name.c_str ());\n+  if (host_def_var == NULL_TREE)\n+    return;\n+\n+  tree ptype = build_pointer_type (TREE_TYPE (var_decl));\n+  tree var_addr = build1 (ADDR_EXPR, ptype, var_decl);\n+\n+  DECL_INITIAL (host_def_var) = var_addr;\n+  TREE_PUBLIC (host_def_var) = 0;\n+}\n+\n+/* Adds an indirection pointer for a potential host-defined program scope\n+   variable declaration.  */\n+\n+void\n+brig_to_generic::add_host_def_var_ptr (const std::string &name, tree var_decl)\n+{\n+  std::string var_name = std::string (PHSA_HOST_DEF_PTR_PREFIX) + name;\n+\n+  tree name_identifier = get_identifier (var_name.c_str ());\n+\n+  tree ptr_var = build_decl (UNKNOWN_LOCATION, VAR_DECL, name_identifier,\n+\t\t\t     build_pointer_type (TREE_TYPE (var_decl)));\n+  DECL_EXTERNAL (ptr_var) = 0;\n+  DECL_ARTIFICIAL (ptr_var) = 0;\n+\n+  TREE_PUBLIC (ptr_var) = 1;\n+  TREE_USED (ptr_var) = 1;\n+  TREE_ADDRESSABLE (ptr_var) = 1;\n+  TREE_STATIC (ptr_var) = 1;\n+\n+  append_global (ptr_var);\n+  m_global_variables[var_name] = ptr_var;\n+}\n+\n+/* Produce a \"mangled name\" for the given brig function or kernel.\n+   The mangling is used to make unique global symbol name in case of\n+   module scope functions.  Program scope functions are not mangled\n+   (except for dropping the leading &), which makes the functions\n+   directly visible for linking using the original function name.  */\n+\n+std::string\n+brig_to_generic::get_mangled_name\n+(const BrigDirectiveExecutable *func) const\n+{\n+  /* Strip the leading &.  */\n+  std::string func_name = get_string (func->name).substr (1);\n+  if (func->linkage == BRIG_LINKAGE_MODULE)\n+    {\n+      /* Mangle the module scope function names with the module name and\n+\t make them public so they can be queried by the HSA runtime from\n+\t the produced binary.  Assume it's the currently processed function\n+\t we are always referring to.  */\n+      func_name = \"gccbrig.\" + m_module_name + \".\" + func_name;\n+    }\n+  return func_name;\n+}\n+\n+std::string\n+brig_to_generic::get_string (size_t entry_offset) const\n+{\n+  const BrigData *data_item = get_brig_data_entry (entry_offset);\n+  return std::string ((const char *) &data_item->bytes, data_item->byteCount);\n+}\n+\n+/* Adapted from c-semantics.c.  */\n+\n+tree\n+build_stmt (enum tree_code code, ...)\n+{\n+  tree ret;\n+  int length, i;\n+  va_list p;\n+  bool side_effects;\n+\n+  /* This function cannot be used to construct variably-sized nodes.  */\n+  gcc_assert (TREE_CODE_CLASS (code) != tcc_vl_exp);\n+\n+  va_start (p, code);\n+\n+  ret = make_node (code);\n+  TREE_TYPE (ret) = void_type_node;\n+  length = TREE_CODE_LENGTH (code);\n+\n+  /* TREE_SIDE_EFFECTS will already be set for statements with\n+     implicit side effects.  Here we make sure it is set for other\n+     expressions by checking whether the parameters have side\n+     effects.  */\n+\n+  side_effects = false;\n+  for (i = 0; i < length; i++)\n+    {\n+      tree t = va_arg (p, tree);\n+      if (t && !TYPE_P (t))\n+\tside_effects |= TREE_SIDE_EFFECTS (t);\n+      TREE_OPERAND (ret, i) = t;\n+    }\n+\n+  TREE_SIDE_EFFECTS (ret) |= side_effects;\n+\n+  va_end (p);\n+  return ret;\n+}\n+\n+/* BRIG regs are untyped, but GENERIC is not.  We need to add implicit casts\n+   in case treating the operand with an instruction with a type different\n+   than the created reg var type in order to select correct instruction type\n+   later on.  This function creates the necessary reinterpret type cast from\n+   a source variable to the destination type.  In case no cast is needed to\n+   the same type, SOURCE is returned directly.  */\n+\n+tree\n+build_reinterpret_cast (tree destination_type, tree source)\n+{\n+\n+  gcc_assert (source && destination_type && TREE_TYPE (source) != NULL_TREE\n+\t      && destination_type != NULL_TREE);\n+\n+  tree source_type = TREE_TYPE (source);\n+  if (TREE_CODE (source) == CALL_EXPR)\n+    {\n+      tree func_decl = TREE_OPERAND (TREE_OPERAND (source, 1), 0);\n+      source_type = TREE_TYPE (TREE_TYPE (func_decl));\n+    }\n+\n+  if (destination_type == source_type)\n+    return source;\n+\n+  size_t src_size = int_size_in_bytes (source_type);\n+  size_t dst_size = int_size_in_bytes (destination_type);\n+  if (src_size == dst_size)\n+    return build1 (VIEW_CONVERT_EXPR, destination_type, source);\n+  else if (src_size < dst_size)\n+    {\n+      /* The src_size can be smaller at least with f16 scalars which are\n+\t stored to 32b register variables.  First convert to an equivalent\n+\t size unsigned type, then extend to an unsigned type of the\n+\t target width, after which VIEW_CONVERT_EXPR can be used to\n+\t force to the target type.  */\n+      tree unsigned_temp = build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t   get_unsigned_int_type (source_type),\n+\t\t\t\t   source);\n+      return build1 (VIEW_CONVERT_EXPR, destination_type,\n+\t\t     convert (get_unsigned_int_type (destination_type),\n+\t\t\t      unsigned_temp));\n+    }\n+  else\n+    gcc_unreachable ();\n+  return NULL_TREE;\n+}\n+\n+/* Returns the finished brig_function for the given generic FUNC_DECL,\n+   or NULL, if not found.  */\n+\n+brig_function *\n+brig_to_generic::get_finished_function (tree func_decl)\n+{\n+  std::string func_name\n+    = identifier_to_locale (IDENTIFIER_POINTER (DECL_NAME (func_decl)));\n+  std::map<std::string, brig_function *>::iterator i\n+    = m_finished_functions.find (func_name);\n+  if (i != m_finished_functions.end ())\n+    return (*i).second;\n+  else\n+    return NULL;\n+}\n+\n+/* Finalizes the currently handled function.  Should be called before\n+   setting a new function.  */\n+\n+void\n+brig_to_generic::finish_function ()\n+{\n+  if (m_cf == NULL || m_cf->m_func_decl == NULL_TREE)\n+    {\n+      /* It can be a finished func declaration fingerprint, in that case we\n+\t don't have m_func_decl.  */\n+      m_cf = NULL;\n+      return;\n+    }\n+\n+  if (!m_cf->m_is_kernel)\n+    {\n+      tree bind_expr = m_cf->m_current_bind_expr;\n+      tree stmts = BIND_EXPR_BODY (bind_expr);\n+      m_cf->finish ();\n+      m_cf->emit_metadata (stmts);\n+      dump_function (m_dump_file, m_cf);\n+      gimplify_function_tree (m_cf->m_func_decl);\n+      cgraph_node::finalize_function (m_cf->m_func_decl, true);\n+    }\n+  else\n+    /* Emit the kernel only at the very end so we can analyze the total\n+       group and private memory usage.  */\n+    m_kernels.push_back (m_cf);\n+\n+  pop_cfun ();\n+\n+  m_finished_functions[m_cf->m_name] = m_cf;\n+  m_cf = NULL;\n+}\n+\n+/* Initializes a new currently handled function.  */\n+\n+void\n+brig_to_generic::start_function (tree f)\n+{\n+  if (DECL_STRUCT_FUNCTION (f) == NULL)\n+    push_struct_function (f);\n+  else\n+    push_cfun (DECL_STRUCT_FUNCTION (f));\n+\n+  m_cf->m_func_decl = f;\n+}\n+\n+/* Appends a new group variable (or an fbarrier) to the current kernel's\n+   group segment.  */\n+\n+void\n+brig_to_generic::append_group_variable (const std::string &name, size_t size,\n+\t\t\t\t\tsize_t alignment)\n+{\n+  size_t align_padding = m_next_group_offset % alignment == 0 ?\n+    0 : (alignment - m_next_group_offset % alignment);\n+  m_next_group_offset += align_padding;\n+  m_group_offsets[name] = m_next_group_offset;\n+  m_next_group_offset += size;\n+}\n+\n+size_t\n+brig_to_generic::group_variable_segment_offset (const std::string &name) const\n+{\n+  var_offset_table::const_iterator i = m_group_offsets.find (name);\n+  gcc_assert (i != m_group_offsets.end ());\n+  return (*i).second;\n+}\n+\n+/* The size of the group and private segments required by the currently\n+   processed kernel.  Private segment size must be multiplied by the\n+   number of work-items in the launch, in case of a work-group function.  */\n+\n+size_t\n+brig_to_generic::group_segment_size () const\n+{\n+  return m_next_group_offset;\n+}\n+\n+/* Appends a new group variable to the current kernel's private segment.  */\n+\n+void\n+brig_to_generic::append_private_variable (const std::string &name,\n+\t\t\t\t\t  size_t size, size_t alignment)\n+{\n+  size_t align_padding = m_next_private_offset % alignment == 0 ?\n+    0 : (alignment - m_next_private_offset % alignment);\n+  m_next_private_offset += align_padding;\n+  m_private_offsets[name] = m_next_private_offset;\n+  m_next_private_offset += size;\n+  m_private_data_sizes[name] = size + align_padding;\n+}\n+\n+size_t\n+brig_to_generic::private_variable_segment_offset\n+  (const std::string &name) const\n+{\n+  var_offset_table::const_iterator i = m_private_offsets.find (name);\n+  gcc_assert (i != m_private_offsets.end ());\n+  return (*i).second;\n+}\n+\n+bool\n+brig_to_generic::has_private_variable (const std::string &name) const\n+{\n+  std::map<std::string, size_t>::const_iterator i\n+    = m_private_data_sizes.find (name);\n+  return i != m_private_data_sizes.end ();\n+}\n+\n+bool\n+brig_to_generic::has_group_variable (const std::string &name) const\n+{\n+  var_offset_table::const_iterator i = m_group_offsets.find (name);\n+  return i != m_group_offsets.end ();\n+}\n+\n+size_t\n+brig_to_generic::private_variable_size (const std::string &name) const\n+{\n+  std::map<std::string, size_t>::const_iterator i\n+    = m_private_data_sizes.find (name);\n+  gcc_assert (i != m_private_data_sizes.end ());\n+  return (*i).second;\n+}\n+\n+size_t\n+brig_to_generic::private_segment_size () const\n+{\n+  return m_next_private_offset;\n+}\n+\n+/* Cached builtins indexed by name.  */\n+\n+typedef std::map<std::string, tree> builtin_index;\n+builtin_index builtin_cache_;\n+\n+/* Build a call to a builtin function.  PDECL is the builtin function to\n+   call.  NARGS is the number of input arguments, RETTYPE the built-in\n+   functions return value type, and ... is the list of arguments passed to\n+   the call with type first, then the value.  */\n+\n+tree\n+call_builtin (tree pdecl, int nargs, tree rettype, ...)\n+{\n+  if (rettype == error_mark_node)\n+    return error_mark_node;\n+\n+  tree *types = new tree[nargs];\n+  tree *args = new tree[nargs];\n+\n+  va_list ap;\n+  va_start (ap, rettype);\n+  for (int i = 0; i < nargs; ++i)\n+    {\n+      types[i] = va_arg (ap, tree);\n+      tree arg = va_arg (ap, tree);\n+      args[i] = build_reinterpret_cast (types[i], arg);\n+      if (types[i] == error_mark_node || args[i] == error_mark_node)\n+\t{\n+\t  delete[] types;\n+\t  delete[] args;\n+\t  return error_mark_node;\n+\t}\n+    }\n+  va_end (ap);\n+\n+  tree fnptr = build_fold_addr_expr (pdecl);\n+\n+  tree ret = build_call_array (rettype, fnptr, nargs, args);\n+\n+  delete[] types;\n+  delete[] args;\n+\n+  return ret;\n+}\n+\n+/* Generate all global declarations.  Should be called after the last\n+   BRIG has been fed in.  */\n+\n+void\n+brig_to_generic::write_globals ()\n+{\n+  /* Now that the whole BRIG module has been processed, build a launcher\n+     and a metadata section for each built kernel.  */\n+  for (size_t i = 0; i < m_kernels.size (); ++i)\n+    {\n+      brig_function *f = m_kernels[i];\n+\n+      /* Finish kernels now that we know the call graphs and their barrier\n+\t usage.  */\n+      f->finish_kernel ();\n+\n+      dump_function (m_dump_file, f);\n+      gimplify_function_tree (f->m_func_decl);\n+      cgraph_node::finalize_function (f->m_func_decl, true);\n+\n+      f->m_descriptor.is_kernel = 1;\n+      /* TODO: analyze the kernel's actual group and private segment usage\n+\t using a call graph.  Now the private and group mem sizes are overly\n+\t pessimistic in case of multiple kernels in the same module.  */\n+      f->m_descriptor.group_segment_size = group_segment_size ();\n+      f->m_descriptor.private_segment_size = private_segment_size ();\n+\n+      /* The kernarg size is rounded up to a multiple of 16 according to\n+\t the PRM specs.  */\n+      f->m_descriptor.kernarg_segment_size = f->m_next_kernarg_offset;\n+      if (f->m_descriptor.kernarg_segment_size % 16 > 0)\n+\tf->m_descriptor.kernarg_segment_size\n+\t  += 16 - f->m_next_kernarg_offset % 16;\n+      f->m_descriptor.kernarg_max_align = f->m_kernarg_max_align;\n+\n+      tree launcher = f->emit_launcher_and_metadata ();\n+\n+      append_global (launcher);\n+\n+      gimplify_function_tree (launcher);\n+      cgraph_node::finalize_function (launcher, true);\n+      pop_cfun ();\n+    }\n+\n+  int no_globals = list_length (m_globals);\n+  tree *vec = new tree[no_globals];\n+\n+  int i = 0;\n+  tree global = m_globals;\n+  while (global)\n+    {\n+      vec[i] = global;\n+      ++i;\n+      global = TREE_CHAIN (global);\n+    }\n+\n+  wrapup_global_declarations (vec, no_globals);\n+\n+  delete[] vec;\n+\n+  for (size_t i = 0; i < m_brig_blobs.size (); ++i)\n+    delete m_brig_blobs[i];\n+}\n+\n+/* Returns an type with unsigned int elements corresponding to the\n+   size and element count of ORIGINAL_TYPE.  */\n+\n+tree\n+get_unsigned_int_type (tree original_type)\n+{\n+  if (VECTOR_TYPE_P (original_type))\n+    {\n+      size_t esize\n+\t= int_size_in_bytes (TREE_TYPE (original_type)) * BITS_PER_UNIT;\n+      size_t ecount = TYPE_VECTOR_SUBPARTS (original_type);\n+      return build_vector_type (build_nonstandard_integer_type (esize, true),\n+\t\t\t\tecount);\n+    }\n+  else\n+    return build_nonstandard_integer_type (int_size_in_bytes (original_type)\n+\t\t\t\t\t   * BITS_PER_UNIT,\n+\t\t\t\t\t   true);\n+}\n+\n+void\n+dump_function (FILE *dump_file, brig_function *f)\n+{\n+  /* Dump the BRIG-specific tree IR.  */\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n;; Function %s\", f->m_name.c_str ());\n+      fprintf (dump_file, \"\\n;; enabled by -%s\\n\\n\",\n+\t       dump_flag_name (TDI_original));\n+      print_generic_decl (dump_file, f->m_func_decl, 0);\n+      print_generic_expr (dump_file, f->m_current_bind_expr, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+}"}, {"sha": "8e15589754ba46c2773c0511d5a8f9aa05423c51", "filename": "gcc/brig/brigfrontend/brig-to-generic.h", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.h?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,225 @@\n+/* brig-to-generic.h -- brig to gcc generic conversion\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef BRIG_TO_GENERIC_H\n+#define BRIG_TO_GENERIC_H\n+\n+#include <string>\n+#include <map>\n+#include <vector>\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"ansidecl.h\"\n+#include \"coretypes.h\"\n+#include \"opts.h\"\n+#include \"tree.h\"\n+#include \"tree-iterator.h\"\n+#include \"hsa-brig-format.h\"\n+#include \"brig-function.h\"\n+\n+\n+struct reg_decl_index_entry;\n+\n+/* Converts an HSAIL BRIG input to GENERIC.  This class holds global state\n+   for the translation process.  Handling of the smaller pieces of BRIG data\n+   is delegated to various handler classes declared in\n+   brig-code-entry-handlers.h.  */\n+\n+class brig_to_generic\n+{\n+public:\n+  typedef std::map<const BrigDirectiveVariable *, tree> variable_index;\n+\n+private:\n+  typedef std::map<std::string, size_t> var_offset_table;\n+  typedef std::map<const BrigBase *, std::string> name_index;\n+\n+public:\n+  brig_to_generic ();\n+\n+  void parse (const char *brig_blob);\n+\n+  void write_globals ();\n+\n+  std::string get_string (size_t entry_offset) const;\n+\n+  const BrigData *get_brig_data_entry (size_t entry_offset) const;\n+  const BrigBase *get_brig_operand_entry (size_t entry_offset) const;\n+  const BrigBase *get_brig_code_entry (size_t entry_offset) const;\n+\n+  void append_global (tree g);\n+\n+  tree function_decl (const std::string &name);\n+  void add_function_decl (const std::string &name, tree func_decl);\n+\n+  tree global_variable (const std::string &name) const;\n+  void add_global_variable (const std::string &name, tree var_decl);\n+  void add_host_def_var_ptr (const std::string &name, tree var_decl);\n+\n+  void start_function (tree f);\n+  void finish_function ();\n+\n+  void append_group_variable (const std::string &name, size_t size,\n+\t\t\t      size_t alignment);\n+\n+  void append_private_variable (const std::string &name, size_t size,\n+\t\t\t\tsize_t alignment);\n+\n+  size_t group_variable_segment_offset (const std::string &name) const;\n+\n+  bool\n+  has_group_variable (const std::string &name) const;\n+\n+  size_t\n+  private_variable_segment_offset (const std::string &name) const;\n+\n+  bool\n+  has_private_variable (const std::string &name) const;\n+\n+  size_t private_variable_size (const std::string &name) const;\n+\n+  template <typename T>\n+    std::string\n+    get_mangled_name_tmpl (const T *brigVar) const;\n+\n+  std::string get_mangled_name (const BrigDirectiveFbarrier *fbar) const\n+    { return get_mangled_name_tmpl (fbar); }\n+  std::string get_mangled_name (const BrigDirectiveVariable *var) const\n+    { return get_mangled_name_tmpl (var); }\n+  std::string get_mangled_name (const BrigDirectiveExecutable *func) const;\n+\n+  size_t group_segment_size () const;\n+  size_t private_segment_size () const;\n+\n+  brig_function *get_finished_function (tree func_decl);\n+\n+  static tree s_fp16_type;\n+  static tree s_fp32_type;\n+  static tree s_fp64_type;\n+\n+  /* The default rounding mode that should be used for float instructions.\n+     This can be set in each BRIG module header.  */\n+  BrigRound8_t m_default_float_rounding_mode;\n+\n+  /* The currently built function.  */\n+  brig_function *m_cf;\n+\n+  /* The name of the currently handled BRIG module.  */\n+  std::string m_module_name;\n+\n+private:\n+  /* The BRIG blob and its different sections of the file currently being\n+     parsed.  */\n+  const char *m_brig;\n+  const char *m_data;\n+  size_t m_data_size;\n+  const char *m_operand;\n+  size_t m_operand_size;\n+  const char *m_code;\n+  size_t m_code_size;\n+\n+  tree m_globals;\n+\n+  label_index m_global_variables;\n+\n+  /* The size of each private variable, including the alignment padding.  */\n+  std::map<std::string, size_t> m_private_data_sizes;\n+\n+  /* The same for group variables.  */\n+  size_t m_next_group_offset;\n+  var_offset_table m_group_offsets;\n+\n+  /* And private.  */\n+  size_t m_next_private_offset;\n+  var_offset_table m_private_offsets;\n+\n+  /* Name index for declared functions.  */\n+  label_index m_function_index;\n+\n+  /* Stores all processed kernels in order.  */\n+  std::vector<brig_function *> m_kernels;\n+\n+  /* Stores all already processed functions from the translation unit\n+     for some interprocedural analysis.  */\n+  std::map<std::string, brig_function *> m_finished_functions;\n+\n+  /* The parsed BRIG blobs.  Owned and will be deleted after use.  */\n+  std::vector<const char *> m_brig_blobs;\n+\n+  /* The original dump file.  */\n+  FILE *m_dump_file;\n+\n+  /* The original dump file flags.  */\n+  int m_dump_flags;\n+};\n+\n+/* Produce a \"mangled name\" for the given brig variable.  The mangling is used\n+   to make unique global symbol names for module and function scope variables.\n+   The templated version is suitable for most of the variable types.  Functions\n+   and kernels (BrigDirectiveExecutable) are handled with a specialized\n+   get_mangled_name() version.  */\n+\n+template <typename T>\n+std::string\n+brig_to_generic::get_mangled_name_tmpl (const T *brigVar) const\n+{\n+  std::string var_name = get_string (brigVar->name).substr (1);\n+\n+  /* Mangle the variable name using the function name and the module name\n+     in case of a function scope variable.  */\n+  if (m_cf != NULL\n+      && m_cf->has_function_scope_var (&brigVar->base))\n+    var_name = m_cf->m_name + \".\" + var_name;\n+\n+  if (brigVar->linkage == BRIG_LINKAGE_MODULE)\n+    var_name = \"gccbrig.\" + m_module_name + \".\" + var_name;\n+  return var_name;\n+}\n+\n+/* An interface to organize the different types of BRIG element handlers.  */\n+\n+class brig_entry_handler\n+{\n+public:\n+  brig_entry_handler (brig_to_generic &parent) : m_parent (parent)\n+  {\n+  }\n+\n+  /* Handles the brig_code data at the given pointer and adds it to the\n+     currently built tree.  Returns the number of consumed bytes;  */\n+  virtual size_t operator () (const BrigBase *base) = 0;\n+\n+protected:\n+  brig_to_generic &m_parent;\n+};\n+\n+tree call_builtin (tree pdecl, int nargs, tree rettype, ...);\n+\n+tree build_reinterpret_cast (tree destination_type, tree source);\n+\n+tree build_stmt (enum tree_code code, ...);\n+\n+tree get_unsigned_int_type (tree type);\n+\n+void dump_function (FILE *dump_file, brig_function *f);\n+\n+#endif"}, {"sha": "8b17b59d28898e2eba2c32739bc10c111a84c130", "filename": "gcc/brig/brigfrontend/brig-util.cc", "status": "added", "additions": 447, "deletions": 0, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,447 @@\n+/* brig-util.cc -- gccbrig utility functions\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <sstream>\n+\n+#include \"stdint.h\"\n+#include \"hsa-brig-format.h\"\n+#include \"brig-util.h\"\n+#include \"errors.h\"\n+#include \"diagnostic-core.h\"\n+\n+/* Return true if operand number OPNUM of instruction with OPCODE is an output.\n+   False if it is an input.  Some code reused from Martin Jambor's gcc-hsa\n+   tree.  */\n+\n+bool\n+gccbrig_hsa_opcode_op_output_p (BrigOpcode16_t opcode, int opnum)\n+{\n+  switch (opcode)\n+    {\n+    case BRIG_OPCODE_BR:\n+    case BRIG_OPCODE_SBR:\n+    case BRIG_OPCODE_CBR:\n+    case BRIG_OPCODE_ST:\n+    case BRIG_OPCODE_ATOMICNORET:\n+    case BRIG_OPCODE_SIGNALNORET:\n+    case BRIG_OPCODE_INITFBAR:\n+    case BRIG_OPCODE_JOINFBAR:\n+    case BRIG_OPCODE_WAITFBAR:\n+    case BRIG_OPCODE_ARRIVEFBAR:\n+    case BRIG_OPCODE_LEAVEFBAR:\n+    case BRIG_OPCODE_RELEASEFBAR:\n+    case BRIG_OPCODE_DEBUGTRAP:\n+      return false;\n+    default:\n+      return opnum == 0;\n+    }\n+}\n+\n+unsigned\n+gccbrig_hsa_type_bit_size (BrigType16_t t)\n+{\n+\n+  unsigned pack_type = t & ~BRIG_TYPE_BASE_MASK;\n+\n+  if (pack_type == BRIG_TYPE_PACK_32)\n+    return 32;\n+  else if (pack_type == BRIG_TYPE_PACK_64)\n+    return 64;\n+  else if (pack_type == BRIG_TYPE_PACK_128)\n+    return 128;\n+\n+  switch (t)\n+    {\n+    case BRIG_TYPE_NONE:\n+      return 0;\n+\n+    case BRIG_TYPE_B1:\n+      return 1;\n+\n+    case BRIG_TYPE_U8:\n+    case BRIG_TYPE_S8:\n+    case BRIG_TYPE_B8:\n+      return 8;\n+\n+    case BRIG_TYPE_U16:\n+    case BRIG_TYPE_S16:\n+    case BRIG_TYPE_B16:\n+    case BRIG_TYPE_F16:\n+      return 16;\n+\n+    case BRIG_TYPE_U32:\n+    case BRIG_TYPE_S32:\n+    case BRIG_TYPE_B32:\n+    case BRIG_TYPE_F32:\n+    case BRIG_TYPE_U8X4:\n+    case BRIG_TYPE_U16X2:\n+    case BRIG_TYPE_S8X4:\n+    case BRIG_TYPE_S16X2:\n+    case BRIG_TYPE_F16X2:\n+    case BRIG_TYPE_SIG32:\n+      return 32;\n+\n+    case BRIG_TYPE_U64:\n+    case BRIG_TYPE_S64:\n+    case BRIG_TYPE_F64:\n+    case BRIG_TYPE_B64:\n+    case BRIG_TYPE_U8X8:\n+    case BRIG_TYPE_U16X4:\n+    case BRIG_TYPE_U32X2:\n+    case BRIG_TYPE_S8X8:\n+    case BRIG_TYPE_S16X4:\n+    case BRIG_TYPE_S32X2:\n+    case BRIG_TYPE_F16X4:\n+    case BRIG_TYPE_F32X2:\n+    case BRIG_TYPE_SIG64:\n+      return 64;\n+\n+    case BRIG_TYPE_B128:\n+    case BRIG_TYPE_U8X16:\n+    case BRIG_TYPE_U16X8:\n+    case BRIG_TYPE_U32X4:\n+    case BRIG_TYPE_U64X2:\n+    case BRIG_TYPE_S8X16:\n+    case BRIG_TYPE_S16X8:\n+    case BRIG_TYPE_S32X4:\n+    case BRIG_TYPE_S64X2:\n+    case BRIG_TYPE_F16X8:\n+    case BRIG_TYPE_F32X4:\n+    case BRIG_TYPE_F64X2:\n+      return 128;\n+\n+    default:\n+      printf (\"HMM %d %x\\n\", t, t);\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* gcc-hsa borrowed code ENDS.  */\n+\n+uint64_t\n+gccbrig_to_uint64_t (const BrigUInt64 &brig_type)\n+{\n+  return (uint64_t (brig_type.hi) << 32) | uint64_t (brig_type.lo);\n+}\n+\n+int\n+gccbrig_reg_size (const BrigOperandRegister *brig_reg)\n+{\n+  switch (brig_reg->regKind)\n+    {\n+    case BRIG_REGISTER_KIND_CONTROL:\n+      return 1;\n+    case BRIG_REGISTER_KIND_SINGLE:\n+      return 32;\n+    case BRIG_REGISTER_KIND_DOUBLE:\n+      return 64;\n+    case BRIG_REGISTER_KIND_QUAD:\n+      return 128;\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+}\n+\n+std::string\n+gccbrig_reg_name (const BrigOperandRegister *reg)\n+{\n+  std::ostringstream strstr;\n+  switch (reg->regKind)\n+    {\n+    case BRIG_REGISTER_KIND_CONTROL:\n+      strstr << 'c';\n+      break;\n+    case BRIG_REGISTER_KIND_SINGLE:\n+      strstr << 's';\n+      break;\n+    case BRIG_REGISTER_KIND_DOUBLE:\n+      strstr << 'd';\n+      break;\n+    case BRIG_REGISTER_KIND_QUAD:\n+      strstr << 'q';\n+      break;\n+    default:\n+      gcc_unreachable ();\n+      return \"\";\n+    }\n+  strstr << reg->regNum;\n+  return strstr.str ();\n+}\n+\n+std::string\n+gccbrig_type_name (BrigType16_t type)\n+{\n+  switch (type)\n+    {\n+    case BRIG_TYPE_U8:\n+      return \"u8\";\n+    case BRIG_TYPE_U16:\n+      return \"u16\";\n+    case BRIG_TYPE_U32:\n+      return \"u32\";\n+    case BRIG_TYPE_U64:\n+      return \"u64\";\n+    case BRIG_TYPE_S8:\n+      return \"s8\";\n+    case BRIG_TYPE_S16:\n+      return \"s16\";\n+    case BRIG_TYPE_S32:\n+      return \"s32\";\n+    case BRIG_TYPE_S64:\n+      return \"s64\";\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+}\n+\n+std::string\n+gccbrig_segment_name (BrigSegment8_t segment)\n+{\n+  if (segment == BRIG_SEGMENT_GLOBAL)\n+    return \"global\";\n+  else if (segment == BRIG_SEGMENT_GROUP)\n+    return \"group\";\n+  else if (segment == BRIG_SEGMENT_PRIVATE)\n+    return \"private\";\n+  else\n+    gcc_unreachable ();\n+}\n+\n+bool\n+gccbrig_is_float_type (BrigType16_t type)\n+{\n+  return (type == BRIG_TYPE_F32 || type == BRIG_TYPE_F64\n+\t  || type == BRIG_TYPE_F16);\n+}\n+\n+BrigType16_t\n+gccbrig_tree_type_to_hsa_type (tree tree_type)\n+{\n+  if (INTEGRAL_TYPE_P (tree_type))\n+    {\n+      if (TYPE_UNSIGNED (tree_type))\n+\t{\n+\t  switch (int_size_in_bytes (tree_type))\n+\t    {\n+\t    case 1:\n+\t      return BRIG_TYPE_U8;\n+\t    case 2:\n+\t      return BRIG_TYPE_U16;\n+\t    case 4:\n+\t      return BRIG_TYPE_U32;\n+\t    case 8:\n+\t      return BRIG_TYPE_U64;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  switch (int_size_in_bytes (tree_type))\n+\t    {\n+\t    case 1:\n+\t      return BRIG_TYPE_S8;\n+\t    case 2:\n+\t      return BRIG_TYPE_S16;\n+\t    case 4:\n+\t      return BRIG_TYPE_S32;\n+\t    case 8:\n+\t      return BRIG_TYPE_S64;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  else if (VECTOR_TYPE_P (tree_type))\n+    {\n+      tree element_type = TREE_TYPE (tree_type);\n+      size_t element_size = int_size_in_bytes (element_type) * 8;\n+      BrigType16_t brig_element_type;\n+      switch (element_size)\n+\t{\n+\tcase 8:\n+\t  brig_element_type\n+\t    = TYPE_UNSIGNED (element_type) ? BRIG_TYPE_U8 : BRIG_TYPE_S8;\n+\t  break;\n+\tcase 16:\n+\t  brig_element_type\n+\t    = TYPE_UNSIGNED (element_type) ? BRIG_TYPE_U16 : BRIG_TYPE_S16;\n+\t  break;\n+\tcase 32:\n+\t  brig_element_type\n+\t    = TYPE_UNSIGNED (element_type) ? BRIG_TYPE_U32 : BRIG_TYPE_S32;\n+\t  break;\n+\tcase 64:\n+\t  brig_element_type\n+\t    = TYPE_UNSIGNED (element_type) ? BRIG_TYPE_U64 : BRIG_TYPE_S64;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      BrigType16_t pack_type;\n+      switch (int_size_in_bytes (tree_type) * 8)\n+\t{\n+\tcase 32:\n+\t  pack_type = BRIG_TYPE_PACK_32;\n+\t  break;\n+\tcase 64:\n+\t  pack_type = BRIG_TYPE_PACK_64;\n+\t  break;\n+\tcase 128:\n+\t  pack_type = BRIG_TYPE_PACK_128;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      return brig_element_type | pack_type;\n+    }\n+  gcc_unreachable ();\n+}\n+\n+/* Returns true in case the operation is a \"bit level\" operation,\n+   that is, not having operand type depending semantical differences.  */\n+\n+bool\n+gccbrig_is_bit_operation (BrigOpcode16_t opcode)\n+{\n+  return opcode == BRIG_OPCODE_CMOV || opcode == BRIG_OPCODE_SHUFFLE\n+\t || opcode == BRIG_OPCODE_UNPACK || opcode == BRIG_OPCODE_UNPACKLO\n+\t || opcode == BRIG_OPCODE_UNPACKHI || opcode == BRIG_OPCODE_ST\n+\t || opcode == BRIG_OPCODE_PACK;\n+}\n+\n+/* The program scope definition can be left external within the\n+   kernel binary which means it must be defined by the host via\n+   HSA runtime.  For these we have special treatment:\n+   Create additional pointer indirection when accessing the variable\n+   value from kernel code through a generated pointer\n+   __gccbrig_ptr_variable_name.  The pointer value then can be set either\n+   within the kernel binary (in case of a later linked in definition)\n+   or from the host.  */\n+\n+bool\n+gccbrig_might_be_host_defined_var_p (const BrigDirectiveVariable *brigVar)\n+{\n+  bool is_definition = brigVar->modifier & BRIG_VARIABLE_DEFINITION;\n+  return (brigVar->segment == BRIG_SEGMENT_GLOBAL\n+\t  || brigVar->segment == BRIG_SEGMENT_READONLY) && !is_definition\n+    && brigVar->linkage == BRIG_LINKAGE_PROGRAM\n+    && (brigVar->allocation == BRIG_ALLOCATION_PROGRAM\n+\t|| brigVar->allocation == BRIG_ALLOCATION_AGENT);\n+}\n+\n+/* Produce a GENERIC type for the given HSA/BRIG type.  Returns the element\n+   type in case of vector instructions.  */\n+\n+tree\n+gccbrig_tree_type_for_hsa_type (BrigType16_t brig_type)\n+{\n+  tree tree_type = NULL_TREE;\n+\n+  if (hsa_type_packed_p (brig_type))\n+    {\n+      /* The element type is encoded in the bottom 5 bits.  */\n+      BrigType16_t inner_brig_type = brig_type & BRIG_TYPE_BASE_MASK;\n+\n+      unsigned full_size = gccbrig_hsa_type_bit_size (brig_type);\n+\n+      if (inner_brig_type == BRIG_TYPE_F16)\n+\treturn build_vector_type (gccbrig_tree_type_for_hsa_type (BRIG_TYPE_U16),\n+\t\t\t\t  full_size / 16);\n+\n+      tree inner_type = gccbrig_tree_type_for_hsa_type (inner_brig_type);\n+\n+      unsigned inner_size = gccbrig_hsa_type_bit_size (inner_brig_type);\n+      unsigned nunits = full_size / inner_size;\n+      tree_type = build_vector_type (inner_type, nunits);\n+    }\n+  else\n+    {\n+      switch (brig_type)\n+\t{\n+\tcase BRIG_TYPE_NONE:\n+\t  tree_type = void_type_node;\n+\t  break;\n+\tcase BRIG_TYPE_B1:\n+\t  tree_type = boolean_type_node;\n+\t  break;\n+\tcase BRIG_TYPE_S8:\n+\tcase BRIG_TYPE_S16:\n+\tcase BRIG_TYPE_S32:\n+\tcase BRIG_TYPE_S64:\n+\t  /* Ensure a fixed width integer.  */\n+\t  tree_type\n+\t    = build_nonstandard_integer_type\n+\t    (gccbrig_hsa_type_bit_size (brig_type), false);\n+\t  break;\n+\tcase BRIG_TYPE_U8:\n+\t  return unsigned_char_type_node;\n+\tcase BRIG_TYPE_U16:\n+\tcase BRIG_TYPE_U32:\n+\tcase BRIG_TYPE_U64:\n+\tcase BRIG_TYPE_B8: /* Handle bit vectors as unsigned ints.  */\n+\tcase BRIG_TYPE_B16:\n+\tcase BRIG_TYPE_B32:\n+\tcase BRIG_TYPE_B64:\n+\tcase BRIG_TYPE_B128:\n+\tcase BRIG_TYPE_SIG32: /* Handle signals as integers for now.  */\n+\tcase BRIG_TYPE_SIG64:\n+\t  tree_type = build_nonstandard_integer_type\n+\t    (gccbrig_hsa_type_bit_size (brig_type), true);\n+\t  break;\n+\tcase BRIG_TYPE_F16:\n+\t  tree_type = uint16_type_node;\n+\t  break;\n+\tcase BRIG_TYPE_F32:\n+\t  /* TODO: make sure that the alignment of the float are at least as\n+\t     strict than mandated by HSA, and conform to IEEE (like mandated\n+\t     by HSA).  */\n+\t  tree_type = float_type_node;\n+\t  break;\n+\tcase BRIG_TYPE_F64:\n+\t  tree_type = double_type_node;\n+\t  break;\n+\tcase BRIG_TYPE_SAMP:\n+\tcase BRIG_TYPE_ROIMG:\n+\tcase BRIG_TYPE_WOIMG:\n+\tcase BRIG_TYPE_RWIMG:\n+\t  {\n+\t    /* Handle images and samplers as target-specific blobs of data\n+\t       that should be allocated earlier on from the runtime side.\n+\t       Create a void* that should be initialized to point to the blobs\n+\t       by the kernel launcher.  Images and samplers are accessed\n+\t       via builtins that take void* as the reference.  TODO: who and\n+\t       how these arrays should be initialized?  */\n+\t    tree void_ptr = build_pointer_type (void_type_node);\n+\t    return void_ptr;\n+\t  }\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  break;\n+\t}\n+    }\n+\n+  /* Drop const qualifiers.  */\n+  return tree_type;\n+}"}, {"sha": "3786616ee4daede74d6ec2d454c867832e85b623", "filename": "gcc/brig/brigfrontend/brig-util.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,53 @@\n+/* brig-util.h -- gccbrig utility functions\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_BRIG_UTIL_H\n+#define GCC_BRIG_UTIL_H\n+\n+#include \"brig-to-generic.h\"\n+\n+bool gccbrig_hsa_opcode_op_output_p (BrigOpcode16_t opcode, int opnum);\n+\n+unsigned gccbrig_hsa_type_bit_size (BrigType16_t t);\n+\n+uint64_t gccbrig_to_uint64_t (const BrigUInt64 &brig_type);\n+\n+int gccbrig_reg_size (const BrigOperandRegister *brig_reg);\n+\n+std::string gccbrig_reg_name (const BrigOperandRegister *reg);\n+\n+std::string gccbrig_type_name (BrigType16_t type);\n+\n+std::string gccbrig_segment_name (BrigSegment8_t segment);\n+\n+bool gccbrig_is_float_type (BrigType16_t type);\n+\n+bool gccbrig_is_bit_operation (BrigOpcode16_t opcode);\n+\n+BrigType16_t gccbrig_tree_type_to_hsa_type (tree tree_type);\n+tree gccbrig_tree_type_for_hsa_type (BrigType16_t brig_type);\n+\n+bool gccbrig_might_be_host_defined_var_p (const BrigDirectiveVariable *brigVar);\n+\n+/* From hsa.h.  */\n+bool hsa_type_packed_p (BrigType16_t type);\n+\n+#endif"}, {"sha": "b4a8d67438bf25dd9412f81638582bfc3f7f0a4d", "filename": "gcc/brig/brigfrontend/brig-variable-handler.cc", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-variable-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-variable-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-variable-handler.cc?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,264 @@\n+/* brig-variable-handler.cc -- brig variable directive handling\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"brig-code-entry-handler.h\"\n+\n+#include \"stringpool.h\"\n+#include \"errors.h\"\n+#include \"brig-machine.h\"\n+#include \"brig-util.h\"\n+#include \"print-tree.h\"\n+#include \"diagnostic-core.h\"\n+\n+tree\n+brig_directive_variable_handler::build_variable\n+  (const BrigDirectiveVariable *brigVar, tree_code var_decltype)\n+{\n+  std::string var_name = m_parent.get_mangled_name (brigVar);\n+\n+  bool is_definition = brigVar->modifier & BRIG_VARIABLE_DEFINITION;\n+\n+  tree name_identifier = get_identifier (var_name.c_str ());\n+\n+  tree var_decl;\n+  tree t;\n+  if (brigVar->type & BRIG_TYPE_ARRAY)\n+    {\n+      tree element_type\n+\t= gccbrig_tree_type_for_hsa_type (brigVar->type & ~BRIG_TYPE_ARRAY);\n+      uint64_t element_count = gccbrig_to_uint64_t (brigVar->dim);\n+      if (is_definition && element_count == 0)\n+\tfatal_error (UNKNOWN_LOCATION, \"Array definition with zero elements.\");\n+      if (var_decltype == PARM_DECL)\n+\tt = build_pointer_type (element_type);\n+      else\n+\tt = build_array_type_nelts (element_type, element_count);\n+    }\n+  else\n+    {\n+      t = gccbrig_tree_type_for_hsa_type (brigVar->type);\n+    }\n+\n+  size_t alignment = get_brig_var_alignment (brigVar);\n+\n+  if (brigVar->segment == BRIG_SEGMENT_READONLY\n+      || brigVar->segment == BRIG_SEGMENT_KERNARG\n+      || (brigVar->modifier & BRIG_VARIABLE_CONST))\n+    TYPE_READONLY (t) = 1;\n+\n+  TYPE_ADDR_SPACE (t) = gccbrig_get_target_addr_space_id (brigVar->segment);\n+\n+  var_decl = build_decl (UNKNOWN_LOCATION, var_decltype, name_identifier, t);\n+\n+  SET_DECL_ALIGN (var_decl, alignment * BITS_PER_UNIT);\n+\n+  /* Force the HSA alignments.  */\n+  DECL_USER_ALIGN (var_decl) = 1;\n+\n+  TREE_USED (var_decl) = 1;\n+\n+  TREE_PUBLIC (var_decl) = 1;\n+  if (is_definition)\n+    DECL_EXTERNAL (var_decl) = 0;\n+  else\n+    DECL_EXTERNAL (var_decl) = 1; /* The definition is elsewhere.  */\n+\n+  if (brigVar->init != 0)\n+    {\n+      gcc_assert (brigVar->segment == BRIG_SEGMENT_READONLY\n+\t\t  || brigVar->segment == BRIG_SEGMENT_GLOBAL);\n+\n+      const BrigBase *cst_operand_data\n+\t= m_parent.get_brig_operand_entry (brigVar->init);\n+\n+      tree initializer = NULL_TREE;\n+      if (cst_operand_data->kind == BRIG_KIND_OPERAND_CONSTANT_BYTES)\n+\tinitializer = get_tree_cst_for_hsa_operand\n+\t  ((const BrigOperandConstantBytes *) cst_operand_data, t);\n+      else\n+\terror (\"variable initializers of type %x not implemented\",\n+\t       cst_operand_data->kind);\n+      gcc_assert (initializer != NULL_TREE);\n+      DECL_INITIAL (var_decl) = initializer;\n+    }\n+\n+  if (var_decltype == PARM_DECL)\n+    {\n+      DECL_ARG_TYPE (var_decl) = TREE_TYPE (var_decl);\n+      DECL_EXTERNAL (var_decl) = 0;\n+      TREE_PUBLIC (var_decl) = 0;\n+    }\n+\n+  TREE_ADDRESSABLE (var_decl) = 1;\n+\n+  TREE_USED (var_decl) = 1;\n+  DECL_NONLOCAL (var_decl) = 1;\n+  DECL_ARTIFICIAL (var_decl) = 0;\n+\n+  return var_decl;\n+}\n+\n+size_t\n+brig_directive_variable_handler::operator () (const BrigBase *base)\n+{\n+  const BrigDirectiveVariable *brigVar = (const BrigDirectiveVariable *) base;\n+\n+  bool is_definition = brigVar->modifier & BRIG_VARIABLE_DEFINITION;\n+\n+  size_t var_size;\n+  tree var_type;\n+  if (brigVar->type & BRIG_TYPE_ARRAY)\n+    {\n+      tree element_type\n+\t= gccbrig_tree_type_for_hsa_type (brigVar->type & ~BRIG_TYPE_ARRAY);\n+      uint64_t element_count = gccbrig_to_uint64_t (brigVar->dim);\n+      if (is_definition && element_count == 0)\n+\tfatal_error (UNKNOWN_LOCATION, \"Array definition with zero elements.\");\n+      var_type = build_array_type_nelts (element_type, element_count);\n+      size_t element_size = tree_to_uhwi (TYPE_SIZE (element_type));\n+      var_size = element_size * element_count / 8;\n+    }\n+  else\n+    {\n+      var_type = gccbrig_tree_type_for_hsa_type (brigVar->type);\n+      var_size = tree_to_uhwi (TYPE_SIZE (var_type)) / 8;\n+    }\n+\n+  size_t alignment = get_brig_var_alignment (brigVar);\n+\n+  if (m_parent.m_cf != NULL)\n+    m_parent.m_cf->m_function_scope_vars.insert (base);\n+\n+  std::string var_name = m_parent.get_mangled_name (brigVar);\n+  if (brigVar->segment == BRIG_SEGMENT_KERNARG)\n+    {\n+      /* Do not create a real variable, but only a table of\n+\t offsets to the kernarg segment buffer passed as the\n+\t single argument by the kernel launcher for later\n+\t reference.  Ignore kernel declarations.  */\n+      if (m_parent.m_cf != NULL && m_parent.m_cf->m_func_decl != NULL_TREE)\n+\tm_parent.m_cf->append_kernel_arg (brigVar, var_size, alignment);\n+      return base->byteCount;\n+    }\n+  else if (brigVar->segment == BRIG_SEGMENT_GROUP)\n+    {\n+      /* Handle group region variables similarly as kernargs:\n+\t assign offsets to the group region on the fly when\n+\t a new module scope or function scope group variable is\n+\t introduced.  These offsets will be then added to the\n+\t group_base hidden pointer passed to the kernel in order to\n+\t get the flat address.  */\n+      if (!m_parent.has_group_variable (var_name))\n+\tm_parent.append_group_variable (var_name, var_size, alignment);\n+      return base->byteCount;\n+    }\n+  else if (brigVar->segment == BRIG_SEGMENT_PRIVATE\n+\t   || brigVar->segment == BRIG_SEGMENT_SPILL)\n+    {\n+      /* Private variables are handled like group variables,\n+\t except that their offsets are multiplied by the work-item\n+\t flat id, when accessed.  */\n+      if (!m_parent.has_private_variable (var_name))\n+\tm_parent.append_private_variable (var_name, var_size, alignment);\n+      return base->byteCount;\n+    }\n+  else if (brigVar->segment == BRIG_SEGMENT_GLOBAL\n+\t   || brigVar->segment == BRIG_SEGMENT_READONLY)\n+    {\n+      tree def = is_definition ? NULL_TREE :\n+\tm_parent.global_variable (var_name);\n+\n+      if (!is_definition && def != NULL_TREE)\n+\t{\n+\t  /* We have a definition already for this declaration.\n+\t     Use the definition instead of the declaration.  */\n+\t}\n+      else if (gccbrig_might_be_host_defined_var_p (brigVar))\n+\t{\n+\t  tree var_decl = build_variable (brigVar);\n+\t  m_parent.add_host_def_var_ptr (var_name, var_decl);\n+\t}\n+      else\n+\t{\n+\t  tree var_decl = build_variable (brigVar);\n+\t  /* Make all global variables program scope for now\n+\t     so we can get their address from the Runtime API.  */\n+\t  DECL_CONTEXT (var_decl) = NULL_TREE;\n+\t  TREE_STATIC (var_decl) = 1;\n+\t  m_parent.add_global_variable (var_name, var_decl);\n+\t}\n+    }\n+  else if (brigVar->segment == BRIG_SEGMENT_ARG)\n+    {\n+\n+      if (m_parent.m_cf->m_generating_arg_block)\n+\t{\n+\t  tree var_decl = build_variable (brigVar);\n+\t  tree bind_expr = m_parent.m_cf->m_current_bind_expr;\n+\n+\t  DECL_CONTEXT (var_decl) = m_parent.m_cf->m_func_decl;\n+\t  DECL_CHAIN (var_decl) = BIND_EXPR_VARS (bind_expr);\n+\t  BIND_EXPR_VARS (bind_expr) = var_decl;\n+\t  TREE_PUBLIC (var_decl) = 0;\n+\n+\t  m_parent.m_cf->add_arg_variable (brigVar, var_decl);\n+\t}\n+      else\n+\t{\n+\t  /* Must be an incoming function argument which has\n+\t     been parsed in brig-function-handler.cc.  No\n+\t     need to generate anything here.  */\n+\t}\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  return base->byteCount;\n+}\n+\n+/* Returns the alignment for the given BRIG variable.  In case the variable\n+   explicitly defines alignment and its larger than the natural alignment,\n+   returns it instead of the natural one.  */\n+\n+size_t\n+brig_directive_variable_handler::get_brig_var_alignment\n+(const BrigDirectiveVariable *brigVar)\n+{\n+\n+  size_t defined_alignment\n+    = brigVar->align == BRIG_ALIGNMENT_NONE ? 0 : 1 << (brigVar->align - 1);\n+  size_t natural_alignment;\n+  if (brigVar->type & BRIG_TYPE_ARRAY)\n+    {\n+      tree element_type\n+\t= gccbrig_tree_type_for_hsa_type (brigVar->type & ~BRIG_TYPE_ARRAY);\n+      size_t element_size = tree_to_uhwi (TYPE_SIZE (element_type));\n+      natural_alignment = element_size / BITS_PER_UNIT;\n+    }\n+  else\n+    {\n+      tree t = gccbrig_tree_type_for_hsa_type (brigVar->type);\n+      natural_alignment = tree_to_uhwi (TYPE_SIZE (t)) / BITS_PER_UNIT;\n+    }\n+\n+  return natural_alignment > defined_alignment\n+    ? natural_alignment : defined_alignment;\n+}"}, {"sha": "00e0a7cd4c60254326271e0a88b83350d4c50900", "filename": "gcc/brig/brigfrontend/phsa.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fphsa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigfrontend%2Fphsa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fphsa.h?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,69 @@\n+/* phsa.h -- interfacing between the gcc BRIG FE and the phsa runtime\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef PHSA_H\n+#define PHSA_H\n+\n+#include <stdint.h>\n+\n+/* This struct is used to pass information from the BRIG FE to the\n+   runtime of the finalizer kernel, its control directives etc.\n+   The data is passed raw in a special ELF section named\n+   phsa.kerneldesc.kernel_function_name.  */\n+\n+typedef struct __attribute__((__packed__))\n+{\n+  /* Set to 1 in case the function is a kernel.  */\n+  uint8_t is_kernel;\n+  /* The size of the group segment used by the kernel.  */\n+  uint32_t group_segment_size;\n+  /* Size of the private segment used by a single work-item.  */\n+  uint32_t private_segment_size;\n+  /* Total size of the kernel arguments.  */\n+  uint32_t kernarg_segment_size;\n+  /* Maximum alignment of a kernel argument variable.  */\n+  uint16_t kernarg_max_align;\n+  /* Maximum size (in bytes) of dynamic group memory.  */\n+  uint32_t max_dynamic_group_size;\n+  /* Max number of work-items used to launch the kernel.  */\n+  uint64_t max_flat_grid_size;\n+  /* Max number of work-items in a work-group used to launch the kernel.  */\n+  uint32_t max_flat_workgroup_size;\n+  /* The grid size required by the kernel.  */\n+  uint64_t required_grid_size[3];\n+  /* The work group size required by the kernel.  */\n+  uint32_t required_workgroup_size[3];\n+  /* The number of dimensions required by the kernel.  */\n+  uint8_t required_dim;\n+\n+} phsa_descriptor;\n+\n+/* The prefix to use in the ELF section containing descriptor for\n+   a function.  */\n+#define PHSA_DESC_SECTION_PREFIX \"phsa.desc.\"\n+#define PHSA_HOST_DEF_PTR_PREFIX \"__phsa.host_def.\"\n+\n+/* The frontend error messages are parsed by the host runtime, known\n+   prefix strings are used to separate the different runtime error\n+   codes.  */\n+#define PHSA_ERROR_PREFIX_INCOMPATIBLE_MODULE \"Incompatible module:\"\n+\n+#endif"}, {"sha": "42b7d53010c14bb4e76efad1967df22d570ec630", "filename": "gcc/brig/brigspec.c", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fbrigspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigspec.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,135 @@\n+/* brigspec.c -- Specific flags and argument handling of the gcc BRIG front end.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"gcc.h\"\n+#include \"opts.h\"\n+\n+/* This bit is set if we saw a `-xfoo' language specification.  */\n+#define LANGSPEC (1 << 1)\n+/* This bit is set if they did `-lm' or `-lmath'.  */\n+#define MATHLIB (1 << 2)\n+/* This bit is set if they did `-lpthread'.  */\n+#define THREADLIB (1 << 3)\n+/* This bit is set if they did `-lc'.  */\n+#define WITHLIBC (1 << 4)\n+/* Skip this option.  */\n+#define SKIPOPT (1 << 5)\n+\n+#ifndef MATH_LIBRARY\n+#define MATH_LIBRARY \"m\"\n+#endif\n+#ifndef MATH_LIBRARY_PROFILE\n+#define MATH_LIBRARY_PROFILE MATH_LIBRARY\n+#endif\n+\n+#define LIBHSAIL \"hsail-rt\"\n+\n+void\n+lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n+\t\t      unsigned int *in_decoded_options_count,\n+\t\t      int *in_added_libraries)\n+{\n+  unsigned int i, j;\n+\n+  /* The new argument list will be contained in this.  */\n+  struct cl_decoded_option *new_decoded_options;\n+\n+  /* An array used to flag each argument that needs a bit set for\n+     LANGSPEC, MATHLIB, or WITHLIBC.  */\n+  int *args;\n+\n+  /* By default, we throw on the math library if we have one.  */\n+  int need_math = (MATH_LIBRARY[0] != '\\0');\n+\n+  /* True if we should add -shared-libgcc to the command-line.  */\n+  int shared_libgcc = 1;\n+\n+  /* The total number of arguments with the new stuff.  */\n+  unsigned int argc;\n+\n+  /* The argument list.  */\n+  struct cl_decoded_option *decoded_options;\n+\n+  /* The number of libraries added in.  */\n+  int added_libraries;\n+\n+  /* The total number of arguments with the new stuff.  */\n+  int num_args = 1;\n+\n+  argc = *in_decoded_options_count;\n+  decoded_options = *in_decoded_options;\n+  added_libraries = *in_added_libraries;\n+\n+  args = XCNEWVEC (int, argc);\n+\n+  for (i = 1; i < argc; i++)\n+    {\n+      switch (decoded_options[i].opt_index)\n+\t{\n+\tcase OPT_o:\n+\t  break;\n+\n+\tcase OPT_SPECIAL_input_file:\n+\t  break;\n+\t}\n+    }\n+\n+  /* Make sure to have room for the trailing NULL argument.  */\n+  num_args = argc + need_math + shared_libgcc + 10;\n+  new_decoded_options = XNEWVEC (struct cl_decoded_option, num_args);\n+\n+  i = 0;\n+  j = 0;\n+\n+  /* Copy the 0th argument, i.e., the name of the program itself.  */\n+  new_decoded_options[j++] = decoded_options[i++];\n+\n+  /* NOTE: We start at 1 now, not 0.  */\n+  while (i < argc)\n+    {\n+      new_decoded_options[j] = decoded_options[i];\n+\n+      if ((args[i] & SKIPOPT) != 0)\n+\t--j;\n+\n+      i++;\n+      j++;\n+    }\n+\n+  generate_option (OPT_l, LIBHSAIL, 1, CL_DRIVER, &new_decoded_options[j]);\n+  j++;\n+\n+  *in_decoded_options_count = j;\n+  *in_decoded_options = new_decoded_options;\n+  *in_added_libraries = added_libraries;\n+}\n+\n+/* Called before linking.  Returns 0 on success and -1 on failure.  */\n+\n+int lang_specific_pre_link (void) /* Not used for Brig.  */ { return 0; }\n+\n+/* Number of extra output files that lang_specific_pre_link may generate.  */\n+\n+int lang_specific_extra_outfiles = 0; /* Not used for Brig.  */"}, {"sha": "6d07cae59e7be0bba35573f5d71b77067096e34f", "filename": "gcc/brig/config-lang.in", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fconfig-lang.in?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,41 @@\n+# config-lang.in -- Top level configure fragment for gcc BRIG (HSAIL) frontend.\n+\n+# Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+# This file is part of GCC.\n+\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Configure looks for the existence of this file to auto-config each language.\n+# We define several parameters used by configure:\n+#\n+# language\t- name of language as it would appear in $(LANGUAGES)\n+# compilers\t- value to add to $(COMPILERS)\n+\n+language=\"brig\"\n+\n+compilers=\"brig1\\$(exeext)\"\n+\n+target_libs=\"target-libbrig target-libhsail-rt\"\n+\n+# The BRIG frontend is written in C++, so we need to build the C++\n+# compiler during stage 1.  Note: when cross-compiling / not bootstrapping,\n+# this can be safely removed. gcc 4.9.1 force enables c++/libstdc++ to the\n+# target compiler due to this.\n+lang_requires_boot_languages=c++\n+\n+gtfiles=\"\\$(srcdir)/brig/brig-lang.c \\$(srcdir)/brig/brig-c.h\"\n+\n+build_by_default=\"no\""}, {"sha": "c5b9f5ec9e772cd94fabd3b6a1935f843ffb44ed", "filename": "gcc/brig/lang-specs.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Flang-specs.h?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,28 @@\n+/* lang-specs.h -- gcc driver specs for BRIG (HSAIL) frontend.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This is the contribution to the `default_compilers' array in gcc.c\n+   for the BRIG (HSAIL) input.  */\n+\n+{\".brig\", \"@brig\", 0, 1, 0},\n+  {\"@brig\",\n+   \"brig1 %i %(cc1_options) %{I*} %{L*} %D %{!fsyntax-only:%(invoke_as)}\", 0, 1,\n+   0},"}, {"sha": "0ba70aeba5c2922775d918759a511e7c6607e835", "filename": "gcc/brig/lang.opt", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbrig%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Flang.opt?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,41 @@\n+; lang.opt -- Options for the gcc BRIG (HSAIL) front end.\n+\n+; Copyright (C) 2015 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+; See the GCC internals manual for a description of this file's format.\n+\n+; Please try to keep this file in ASCII collating order.\n+\n+Language\n+BRIG\n+\n+-dump\n+BRIG Separate Alias(d)\n+\n+-dump=\n+BRIG Joined Alias(d)\n+\n+L\n+BRIG Joined Separate\n+; Not documented\n+\n+-output=\n+BRIG Driver Joined Alias(o) MissingArgError(missing filename after %qs)\n+\n+; This comment is to ensure we retain the blank line above."}, {"sha": "ee6d0522aa7ded38fb7c74fd79c76e0f686ce19f", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -67,7 +67,10 @@ DEF_PRIMITIVE_TYPE (BT_LONGLONG, long_long_integer_type_node)\n DEF_PRIMITIVE_TYPE (BT_ULONGLONG, long_long_unsigned_type_node)\n DEF_PRIMITIVE_TYPE (BT_INTMAX, intmax_type_node)\n DEF_PRIMITIVE_TYPE (BT_UINTMAX, uintmax_type_node)\n-DEF_PRIMITIVE_TYPE (BT_UINT16, uint16_type_node)\n+DEF_PRIMITIVE_TYPE (BT_INT8, signed_char_type_node)\n+DEF_PRIMITIVE_TYPE (BT_INT16, short_integer_type_node)\n+DEF_PRIMITIVE_TYPE (BT_UINT8, char_type_node)\n+DEF_PRIMITIVE_TYPE (BT_UINT16, short_unsigned_type_node)\n DEF_PRIMITIVE_TYPE (BT_UINT32, uint32_type_node)\n DEF_PRIMITIVE_TYPE (BT_UINT64, uint64_type_node)\n DEF_PRIMITIVE_TYPE (BT_WORD, (*lang_hooks.types.type_for_mode) (word_mode, 1))\n@@ -167,6 +170,7 @@ DEF_FUNCTION_TYPE_0 (BT_FN_CONST_STRING, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_0 (BT_FN_PID, BT_PID)\n DEF_FUNCTION_TYPE_0 (BT_FN_INT, BT_INT)\n DEF_FUNCTION_TYPE_0 (BT_FN_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_0 (BT_FN_ULONG, BT_ULONG)\n DEF_FUNCTION_TYPE_0 (BT_FN_FLOAT, BT_FLOAT)\n DEF_FUNCTION_TYPE_0 (BT_FN_DOUBLE, BT_DOUBLE)\n /* For \"long double\" we use LONGDOUBLE (not LONG_DOUBLE) to\n@@ -271,16 +275,29 @@ DEF_FUNCTION_TYPE_1 (BT_FN_VOID_VPTR, BT_VOID, BT_VOLATILE_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_PTRPTR, BT_VOID, BT_PTR_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_CONST_PTR, BT_VOID, BT_CONST_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT_UINT, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_1 (BT_FN_UINT_INT, BT_UINT, BT_INT)\n+DEF_FUNCTION_TYPE_1 (BT_FN_UINT_ULONG, BT_UINT, BT_ULONG)\n+DEF_FUNCTION_TYPE_1 (BT_FN_UINT_LONG, BT_UINT, BT_LONG)\n+DEF_FUNCTION_TYPE_1 (BT_FN_UINT_PTR, BT_UINT, BT_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_ULONG_PTR, BT_ULONG, BT_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_ULONG_ULONG, BT_ULONG, BT_ULONG)\n DEF_FUNCTION_TYPE_1 (BT_FN_ULONGLONG_ULONGLONG, BT_ULONGLONG, BT_ULONGLONG)\n+DEF_FUNCTION_TYPE_1 (BT_FN_INT8_FLOAT, BT_INT8, BT_FLOAT)\n+DEF_FUNCTION_TYPE_1 (BT_FN_INT16_FLOAT, BT_INT16, BT_FLOAT)\n+DEF_FUNCTION_TYPE_1 (BT_FN_UINT32_FLOAT, BT_UINT32, BT_FLOAT)\n+DEF_FUNCTION_TYPE_1 (BT_FN_UINT16_FLOAT, BT_UINT16, BT_FLOAT)\n+DEF_FUNCTION_TYPE_1 (BT_FN_UINT8_FLOAT, BT_UINT8, BT_FLOAT)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT16_UINT16, BT_UINT16, BT_UINT16)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT32_UINT32, BT_UINT32, BT_UINT32)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT64_UINT64, BT_UINT64, BT_UINT64)\n+DEF_FUNCTION_TYPE_1 (BT_FN_UINT64_FLOAT, BT_UINT64, BT_FLOAT)\n DEF_FUNCTION_TYPE_1 (BT_FN_BOOL_INT, BT_BOOL, BT_INT)\n DEF_FUNCTION_TYPE_1 (BT_FN_PTR_CONST_PTR, BT_PTR, BT_CONST_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_CONST_PTR_CONST_PTR, BT_CONST_PTR, BT_CONST_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_BND_CONST_PTR, BT_BND, BT_CONST_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_CONST_PTR_BND, BT_CONST_PTR, BT_BND)\n+DEF_FUNCTION_TYPE_1 (BT_FN_UINT16_UINT32, BT_UINT16, BT_UINT32)\n+DEF_FUNCTION_TYPE_1 (BT_FN_UINT32_UINT16, BT_UINT32, BT_UINT16)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)\n \n@@ -301,18 +318,52 @@ DEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_FILEPTR,\n \t\t     BT_INT, BT_CONST_STRING, BT_FILEPTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_INT_INT_FILEPTR,\n \t\t     BT_INT, BT_INT, BT_FILEPTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_UINT16_UINT16_UINT16,\n+\t\t     BT_UINT16, BT_UINT16, BT_UINT16)\n+DEF_FUNCTION_TYPE_2 (BT_FN_INT_PTR_INT,\n+     \t\t     BT_INT, BT_PTR, BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_UINT_PTR_UINT,\n+     \t\t     BT_UINT, BT_PTR, BT_UINT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_LONG_PTR_LONG,\n+\t\t     BT_LONG, BT_PTR, BT_LONG)\n+DEF_FUNCTION_TYPE_2 (BT_FN_ULONG_PTR_ULONG,\n+\t\t     BT_ULONG, BT_PTR, BT_ULONG)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTRMODE_PTR,\n \t\t     BT_VOID, BT_PTRMODE, BT_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_PTRMODE,\n \t\t     BT_VOID, BT_PTR, BT_PTRMODE)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_UINT64_UINT64,\n+     \t\t     BT_VOID, BT_UINT64, BT_UINT64)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VALIST_REF_VALIST_ARG,\n \t\t     BT_VOID, BT_VALIST_REF, BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_2 (BT_FN_LONG_LONG_LONG,\n \t\t     BT_LONG, BT_LONG, BT_LONG)\n+DEF_FUNCTION_TYPE_2 (BT_FN_UINT8_UINT8_UINT8,\n+\t\t     BT_UINT8, BT_UINT8, BT_UINT8)\n+DEF_FUNCTION_TYPE_2 (BT_FN_INT8_INT8_INT8,\n+\t\t     BT_INT8, BT_INT8, BT_INT8)\n+DEF_FUNCTION_TYPE_2 (BT_FN_INT16_INT16_INT16,\n+\t\t     BT_INT16, BT_INT16, BT_INT16)\n+DEF_FUNCTION_TYPE_2 (BT_FN_INT_INT_INT,\n+\t\t     BT_INT, BT_INT, BT_INT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_UINT_FLOAT_UINT,\n+\t\t     BT_UINT, BT_FLOAT, BT_UINT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT_UINT_UINT,\n+\t\t     BT_FLOAT, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_ULONG_UINT_UINT,\n+\t\t     BT_ULONG, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_ULONG_UINT_PTR,\n+\t\t     BT_ULONG, BT_UINT, BT_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_ULONG_ULONG_ULONG,\n+\t\t     BT_ULONG, BT_ULONG, BT_ULONG)\n+DEF_FUNCTION_TYPE_2 (BT_FN_UINT_UINT_UINT,\n+\t\t     BT_UINT, BT_UINT, BT_UINT)\n DEF_FUNCTION_TYPE_2 (BT_FN_INT_PTR_CONST_STRING,\n \t\t     BT_INT, BT_PTR, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_SIZE,\n \t\t     BT_VOID, BT_PTR, BT_SIZE)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_UINT_PTR,\n+\t\t     BT_VOID, BT_UINT, BT_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_FLOAT_FLOAT_FLOAT,\n \t\t     BT_FLOAT, BT_FLOAT, BT_FLOAT)\n DEF_FUNCTION_TYPE_2 (BT_FN_DOUBLE_DOUBLE_DOUBLE,\n@@ -408,13 +459,16 @@ DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_SIZE_CONST_VPTR, BT_BOOL, BT_SIZE,\n \t\t     BT_CONST_VOLATILE_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_INT_BOOL, BT_BOOL, BT_INT, BT_BOOL)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_UINT_UINT, BT_VOID, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_UINT_UINT_PTR, BT_UINT, BT_UINT, BT_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_PTR_CONST_PTR_SIZE, BT_PTR, BT_CONST_PTR, BT_SIZE)\n DEF_FUNCTION_TYPE_2 (BT_FN_PTR_CONST_PTR_CONST_PTR, BT_PTR, BT_CONST_PTR, BT_CONST_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTRPTR_CONST_PTR, BT_VOID, BT_PTR_PTR, BT_CONST_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_CONST_PTR_SIZE, BT_VOID, BT_CONST_PTR, BT_SIZE)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_BND, BT_VOID, BT_PTR, BT_BND)\n DEF_FUNCTION_TYPE_2 (BT_FN_CONST_PTR_CONST_PTR_CONST_PTR, BT_CONST_PTR, BT_CONST_PTR, BT_CONST_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_BND_CONST_PTR_SIZE, BT_BND, BT_CONST_PTR, BT_SIZE)\n+DEF_FUNCTION_TYPE_2 (BT_FN_UINT32_UINT64_PTR,\n+\t\t     BT_UINT32, BT_UINT64, BT_PTR)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR_PTR, BT_FN_VOID_PTR_PTR)\n \n@@ -444,6 +498,20 @@ DEF_FUNCTION_TYPE_3 (BT_FN_INT_FILEPTR_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_FILEPTR, BT_CONST_STRING, BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_3 (BT_FN_INT_PTR_PTR_PTR,\n \t\t     BT_INT, BT_PTR, BT_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_INT_INT_UINT_UINT,\n+\t\t     BT_INT, BT_INT, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_UINT_UINT_UINT_UINT,\n+\t\t     BT_UINT, BT_UINT, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_UINT_UINT_UINT_PTR,\n+\t\t     BT_UINT, BT_UINT, BT_UINT, BT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_UINT_ULONG_ULONG_UINT,\n+\t\t     BT_UINT, BT_ULONG, BT_ULONG, BT_UINT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_ULONG_ULONG_ULONG_ULONG,\n+\t\t     BT_ULONG, BT_ULONG, BT_ULONG, BT_ULONG)\n+DEF_FUNCTION_TYPE_3 (BT_FN_LONG_LONG_UINT_UINT,\n+\t\t     BT_LONG, BT_LONG, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_ULONG_ULONG_UINT_UINT,\n+\t\t     BT_ULONG, BT_ULONG, BT_UINT, BT_UINT)\n DEF_FUNCTION_TYPE_3 (BT_FN_STRING_CONST_STRING_CONST_STRING_INT,\n \t\t     BT_STRING, BT_CONST_STRING, BT_CONST_STRING, BT_INT)\n DEF_FUNCTION_TYPE_3 (BT_FN_FLOAT_FLOAT_FLOAT_FLOAT,\n@@ -512,6 +580,10 @@ DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_ULONG_ULONG_ULONGPTR, BT_BOOL, BT_ULONG,\n \t\t     BT_ULONG, BT_PTR_ULONG)\n DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_ULONGLONG_ULONGLONG_ULONGLONGPTR, BT_BOOL,\n \t\t     BT_ULONGLONG, BT_ULONGLONG, BT_PTR_ULONGLONG)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_UINT32_UINT64_PTR,\n+\t\t     BT_VOID, BT_UINT32, BT_UINT64, BT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_UINT32_UINT32_PTR,\n+\t\t     BT_VOID, BT_UINT32, BT_UINT32, BT_PTR)\n \n DEF_FUNCTION_TYPE_4 (BT_FN_SIZE_CONST_PTR_SIZE_SIZE_FILEPTR,\n \t\t     BT_SIZE, BT_CONST_PTR, BT_SIZE, BT_SIZE, BT_FILEPTR)\n@@ -523,6 +595,12 @@ DEF_FUNCTION_TYPE_4 (BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE,\n \t\t     BT_PTR, BT_PTR, BT_CONST_PTR, BT_SIZE, BT_SIZE)\n DEF_FUNCTION_TYPE_4 (BT_FN_PTR_PTR_INT_SIZE_SIZE,\n \t\t     BT_PTR, BT_PTR, BT_INT, BT_SIZE, BT_SIZE)\n+DEF_FUNCTION_TYPE_4 (BT_FN_UINT_UINT_UINT_UINT_UINT,\n+\t\t     BT_UINT, BT_UINT, BT_UINT, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_4 (BT_FN_UINT_FLOAT_FLOAT_FLOAT_FLOAT,\n+\t\t     BT_UINT, BT_FLOAT, BT_FLOAT, BT_FLOAT, BT_FLOAT)\n+DEF_FUNCTION_TYPE_4 (BT_FN_ULONG_ULONG_ULONG_UINT_UINT,\n+\t\t     BT_ULONG, BT_ULONG, BT_ULONG, BT_UINT, BT_UINT)\n DEF_FUNCTION_TYPE_4 (BT_FN_STRING_STRING_CONST_STRING_SIZE_SIZE,\n \t\t     BT_STRING, BT_STRING, BT_CONST_STRING, BT_SIZE, BT_SIZE)\n DEF_FUNCTION_TYPE_4 (BT_FN_INT_FILEPTR_INT_CONST_STRING_VALIST_ARG,"}, {"sha": "d7f80e66bd9332b740949375e051e06c07b958e8", "filename": "gcc/builtins.def", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -1000,5 +1000,48 @@ DEF_GCC_BUILTIN (BUILT_IN_LINE, \"LINE\", BT_FN_INT, ATTR_NOTHROW_LEAF_LIST)\n /* Pointer Bounds Checker builtins.  */\n #include \"chkp-builtins.def\"\n \n+/* Do not expose the BRIG builtins by default gcc-wide, but only privately in\n+   the BRIG FE as long as there are no references for them in the middle end\n+   or any of the upstream backends.  */\n+\n+#ifndef DEF_HSAIL_BUILTIN\n+#define DEF_HSAIL_BUILTIN(ENUM, HSAIL_OPCODE, HSAIL_TYPE, NAME, TYPE, ATTRS) \\\n+  DEF_BUILTIN_STUB (ENUM, \"__builtin_\" NAME)\n+#endif\n+\n+/* HSAIL atomic builtins do not have separate identifying opcodes.  */\n+\n+#ifndef DEF_HSAIL_ATOMIC_BUILTIN\n+#define DEF_HSAIL_ATOMIC_BUILTIN(ENUM, ATOMIC_OPCODE, HSAIL_TYPE, NAME, \\\n+\tTYPE, ATTRS) \\\n+  DEF_BUILTIN_STUB (ENUM, \"__builtin_\" NAME)\n+#endif\n+\n+/* HSAIL saturating arithmetics builtins.  */\n+\n+#ifndef DEF_HSAIL_SAT_BUILTIN\n+#define DEF_HSAIL_SAT_BUILTIN(ENUM, BRIG_OPCODE, HSAIL_TYPE, NAME, \\\n+\tTYPE, ATTRS) \\\n+  DEF_BUILTIN_STUB (ENUM, \"__builtin_\" NAME)\n+#endif\n+\n+/* HSAIL builtins used internally by the frontend.  */\n+\n+#ifndef DEF_HSAIL_INTR_BUILTIN\n+#define DEF_HSAIL_INTR_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n+  DEF_BUILTIN_STUB (ENUM, \"__builtin_\" NAME)\n+#endif\n+\n+/* HSAIL saturated conversions.  */\n+\n+#ifndef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n+#define DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN(ENUM, HSAIL_DEST_TYPE, HSAIL_SRC_TYPE, \\\n+  NAME, TYPE, ATTRS) \\\n+  DEF_BUILTIN_STUB (ENUM, \"__builtin_\" NAME)\n+#endif\n+\n+/* HSAIL/BRIG frontend builtins.  */\n+#include \"brig-builtins.def\"\n+\n #undef DEF_BUILTIN_CHKP\n #undef DEF_BUILTIN"}, {"sha": "09c2081d20c5994ab9adcccc3c1b299003731c08", "filename": "gcc/doc/frontends.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fdoc%2Ffrontends.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fdoc%2Ffrontends.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ffrontends.texi?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -16,7 +16,7 @@\n GCC stands for ``GNU Compiler Collection''.  GCC is an integrated\n distribution of compilers for several major programming languages.  These\n languages currently include C, C++, Objective-C, Objective-C++,\n-Fortran, Ada, and Go.\n+Fortran, Ada, Go, and BRIG (HSAIL).\n \n The abbreviation @dfn{GCC} has multiple meanings in common use.  The\n current official meaning is ``GNU Compiler Collection'', which refers"}, {"sha": "bc4edfdb096b19802d404d8292f3fd786fa1e2ea", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -2665,7 +2665,10 @@ separately.\n \n Second, you must have the testing tools installed.  This includes\n @uref{http://www.gnu.org/software/dejagnu/,,DejaGnu}, Tcl, and Expect;\n-the DejaGnu site has links to these.\n+the DejaGnu site has links to these. For running the BRIG frontend\n+tests, a tool to assemble the binary BRIGs from HSAIL text,\n+@uref{https://github.com/HSAFoundation/HSAIL-Tools/,,HSAILasm} must\n+be installed.\n \n If the directories where @command{runtest} and @command{expect} were\n installed are not in the @env{PATH}, you may need to set the following"}, {"sha": "d8724aacd28744354e65583c32ed09d3ec1c7f7d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -1338,6 +1338,9 @@ traditional preprocessor).\n @item @var{file}.go\n Go source code.\n \n+@item @var{file}.brig\n+BRIG files (binary representation of HSAIL).\n+\n @item @var{file}.ads\n Ada source code file that contains a library unit declaration (a\n declaration of a package, subprogram, or generic, or a generic\n@@ -1386,6 +1389,7 @@ assembler  assembler-with-cpp\n ada\n f77  f77-cpp-input f95  f95-cpp-input\n go\n+brig\n @end smallexample\n \n @item -x none"}, {"sha": "9f5317cc03e6eb895a8b204e4f8886a69cb38b04", "filename": "gcc/doc/standards.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fdoc%2Fstandards.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Fdoc%2Fstandards.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fstandards.texi?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -301,6 +301,14 @@ available online, see @uref{http://gcc.gnu.org/readings.html}\n As of the GCC 4.7.1 release, GCC supports the Go 1 language standard,\n described at @uref{http://golang.org/doc/go1.html}.\n \n+@section HSA Intermediate Language (HSAIL)\n+\n+GCC can compile the binary representation (BRIG) of the HSAIL text format as\n+described in HSA Programmer's Reference Manual version 1.0.1. This\n+capability is typically utilized to implement the HSA runtime API's HSAIL \n+finalization extension for a gcc supported processor. HSA standards are\n+freely available at @uref{http://www.hsafoundation.com/standards/}.\n+\n @section References for Other Languages\n \n @xref{Top, GNAT Reference Manual, About This Guide, gnat_rm,"}, {"sha": "f09180968bfc0cc94f6ab019137875de075f0c0d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -1,3 +1,23 @@\n+2017-01-24  Pekka J\u00e4\u00e4skel\u00e4inen <pekka@parmance.com>\n+\t    Martin Jambor  <mjambor@suse.cz>\n+\n+\t* lib/brig-dg.exp: New file.\n+\t* lib/brig.exp: Likewise.\n+\t* brig.dg/README: Likewise.\n+\t* brig.dg/dg.exp: Likewise.\n+\t* brig.dg/test/gimple/alloca.hsail: Likewise.\n+\t* brig.dg/test/gimple/atomics.hsail: Likewise.\n+\t* brig.dg/test/gimple/branches.hsail: Likewise.\n+\t* brig.dg/test/gimple/fbarrier.hsail: Likewise.\n+\t* brig.dg/test/gimple/function_calls.hsail: Likewise.\n+\t* brig.dg/test/gimple/kernarg.hsail: Likewise.\n+\t* brig.dg/test/gimple/mem.hsail: Likewise.\n+\t* brig.dg/test/gimple/mulhi.hsail: Likewise.\n+\t* brig.dg/test/gimple/packed.hsail: Likewise.\n+\t* brig.dg/test/gimple/smoke_test.hsail: Likewise.\n+\t* brig.dg/test/gimple/variables.hsail: Likewise.\n+\t* brig.dg/test/gimple/vector.hsail: Likewise.\n+\n 2017-01-24  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/asan/asan_test.C: Enable on all *-*-linux* targets that"}, {"sha": "2ad5b24e75e8b7465b0df7bdd96b8fbc426293b7", "filename": "gcc/testsuite/brig.dg/README", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2FREADME?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,12 @@\n+BRIG (HSAIL) frontend test cases\n+--------------------------------\n+\n+The suite consists of \"smoke tests\" that test several features of\n+the compilation and regression tests, but is not an exhaustive test\n+suite for all HSAIL instructions. The HSA PRM conformance suite\n+is supposed to be used for that.\n+\n+HSAILasm is required for converting the text HSAIL files to BRIGs\n+which the compiler consumes. It can be built from\n+https://github.com/HSAFoundation/HSAIL-Tools\n+"}, {"sha": "d4f37e6695b704b4bf11ad5690685a98e66b25e9", "filename": "gcc/testsuite/brig.dg/dg.exp", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Fdg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Fdg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Fdg.exp?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,31 @@\n+#   Copyright (C) 2009-2014 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+load_lib brig-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+\n+if [expr [llength [auto_execok HSAILasm]] > 0] {\n+    dg-runtest [find $srcdir/$subdir *.hsail] \"\" \"\"\n+} else {\n+    unsupported \"All BRIG FE tests require HSAILasm in PATH.\"\n+}\n+\n+# All done.\n+dg-finish"}, {"sha": "479ab7237b813dddcfb4ad25c89f901a9812dc86", "filename": "gcc/testsuite/brig.dg/test/gimple/alloca.hsail", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Falloca.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Falloca.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Falloca.hsail?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,37 @@\n+module &module:1:0:$full:$large:$default;\n+\n+/* Tests for alloca. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-gimple\" } */\n+\n+prog function &subfunction(arg_u32 %return_value)() {\n+     alloca_align(1)_u32 $s2, 256;\n+     st_arg_u32 $s2, [%return_value];\n+     ret;\n+};\n+\n+prog kernel &kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n+{\n+        ld_kernarg_u64 $d0, [%input_ptr];\n+        ld_global_u32 $s0, [$d0];\n+\n+\talloca_align(256)_u32 $s1, 16;\n+\t{\n+\t\targ_u32 %return_value;\n+\t\tcall &subfunction(%return_value)();\n+\t\tld_arg_u32 $s1, [%return_value];\n+\t}\n+        ld_kernarg_u64 $d1, [%output_ptr];\n+        st_global_u32 $s1, [$d0];\n+};\n+\n+/* { dg-final { scan-tree-dump \"s2 = __builtin___hsail_alloca \\\\\\(256, 1, __context\\\\\\);\" \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump \"s1 = __builtin___hsail_alloca \\\\\\(16, 256, __context\\\\\\);\" \"gimple\" } } */\n+\n+\n+/* Both functions should have an alloca frame push and pop. */\n+/* { dg-final { scan-tree-dump-times \"__builtin___hsail_alloca_push_frame \\\\\\(__context\\\\\\);\" 2 \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin___hsail_alloca_pop_frame \\\\\\(__context\\\\\\);\" 2 \"gimple\" } } */"}, {"sha": "b877a668ec924b22ca0b53f650849fd80bbfe154", "filename": "gcc/testsuite/brig.dg/test/gimple/atomics.hsail", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fatomics.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fatomics.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fatomics.hsail?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,33 @@\n+module &module:1:0:$full:$large:$default;\n+\n+/* Test for atomic instructions. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-original\" } */\n+\n+prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n+{\n+        ld_kernarg_u64 $d0, [%input_ptr];\n+\n+\tatomic_ld_global_rlx_system_b32 $s0, [$d0];\n+\tatomic_add_global_rlx_system_u32 $s1, [$d0 + 4], $s0;\n+\n+        ld_kernarg_u64 $d0, [%output_ptr];\n+        atomicnoret_st_global_rlx_system_b32 [$d0], $s2;\n+\n+\tatomicnoret_min_global_rlx_system_u32 [$d0 + 4], $s1;\n+\n+        ret;\n+};\n+\n+/* The atomic loads are implemented by casting to an atomic pointer. */\n+/* { dg-final { scan-tree-dump \"s0 = VIEW_CONVERT_EXPR<unsigned int>\\\\\\(\\\\\\*\\\\\\(atomic unsigned int \\\\\\*\\\\\\)\" \"original\"} } */\n+\n+/* The atomic add should call a gcc builtin. */\n+/* { dg-final { scan-tree-dump \"= __sync_fetch_and_add_4 \\\\\\(\" \"original\"} } */\n+\n+/* The atomic stores are implemented by casting to an atomic pointer. */\n+/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(atomic unsigned int \\\\\\*\\\\\\) d0 = s2;\" \"original\"} } */\n+\n+/* The atomic min is implemented by a custom builtin. */\n+/* { dg-final { scan-tree-dump \"builtin_out.\\[0-9\\]+ = __builtin___hsail_atomic_min_u32 \\\\\\(\" \"original\"} } */"}, {"sha": "081fde3f1c278f5d0837694431cdaab0b4c04bf7", "filename": "gcc/testsuite/brig.dg/test/gimple/branches.hsail", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fbranches.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fbranches.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fbranches.hsail?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,58 @@\n+module &module:1:0:$full:$large:$default;\n+\n+/* Test different style of branches. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-gimple\" } */\n+\n+prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n+{\n+        ld_kernarg_u64 $d0, [%input_ptr];\n+        ld_global_u64 $d1, [$d0];\n+        ld_global_u64 $d2, [$d0 + 8];\n+\n+        ld_global_u32 $s0, [$d0 + 16];\n+        ld_global_u32 $s1, [$d0 + 20];\n+\n+\tsbr_width(all)_u32 $s1 [@case0, @case1, @case2];\n+@case0:\n+        st_global_u64 0, [$d0];\n+\tbr @out;\n+@case1:\n+        st_global_u64 1, [$d0];\n+\tbr @out;\n+@case2:\n+        st_global_u64 2, [$d0];\n+@out:\n+\tcmp_eq_u32_u32 $s2, $s1, $s0;\n+\tcvt_b1_u32 $c0, $s2;\n+\n+\tcbr_width(all)_b1 $c0, @true_branch;\n+@false_branch:\n+        st_global_u64 $d1, [$d0];\n+\n+@true_branch:\n+        ld_kernarg_u64 $d0, [%output_ptr];\n+\n+        st_global_u32 $s2, [$d0 + 8];\n+\tbr @skip;\n+        st_global_u32 $s3, [$d0 + 12];\n+\n+@skip:\n+        ret;\n+};\n+\n+/* sbr is converted to a switch */\n+/* { dg-final { scan-tree-dump \"switch \\\\\\(s1\\\\\\) <default: <D.\\[0-9\\]+>, case 0: <D.\\[0-9\\]+>, case 1: <D.\\[0-9\\]+>, case 2: <D.\\[0-9\\]+>>\" \"gimple\"} } */\n+\n+/* br @out converted to gotos */\n+/* { dg-final { scan-tree-dump-times \"goto @out\" 2 \"gimple\"} } */ \n+\n+/* the comparison instruction */\n+/* { dg-final { scan-tree-dump \"c0 = s2 != 0;\" \"gimple\" } } */\n+\n+/* cbr to an if clause */\n+/* { dg-final { scan-tree-dump \"if \\\\\\(c0 != 0\\\\\\) goto @true_branch; else goto <D.\\[0-9\\]+>;\" \"gimple\" } } */\n+\n+/* br @skip converted to a goto */\n+/* { dg-final { scan-tree-dump \"goto @skip\" \"gimple\"} } */ "}, {"sha": "a58ca0964ad29288f2e3822faa0f4c48526a0a19", "filename": "gcc/testsuite/brig.dg/test/gimple/fbarrier.hsail", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffbarrier.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffbarrier.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffbarrier.hsail?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,74 @@\n+module &module:1:0:$full:$large:$default;\n+\n+/* Tests for fbarrier. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-gimple\" } */\n+\n+fbarrier &fb_module_scope;\n+\n+prog function &subfunction(arg_u32 %return_value)() {\n+\n+     workitemflatabsid_u32 $s3;\n+     cvt_b1_u32 $c1, $s3;\n+     cbr_width(all)_b1 $c1, @skip_fbar;\n+     waitfbar &fb_module_scope;\n+@skip_fbar:\n+\n+     st_arg_u32 $s3, [%return_value];\n+     ret;\n+};\n+\n+prog kernel &kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n+{\n+\tfbarrier %fb_func_scope;\n+\n+        ld_kernarg_u64 $d0, [%input_ptr];\n+        ld_global_u32 $s0, [$d0];\n+\n+\tworkitemflatabsid_u32 $s1;\n+\tcvt_b1_u32 $c1, $s1;\n+\tcbr_width(all)_b1 $c1, @skip_init;\n+\n+\tinitfbar &fb_module_scope;\n+\tinitfbar %fb_func_scope;\n+\n+        joinfbar &fb_module_scope;\n+\n+@skip_init:\n+\tbarrier_width(all);\n+\n+        joinfbar %fb_func_scope;\n+\n+\t{\n+\t\targ_u32 %return_value;\n+\t\tcall &subfunction(%return_value)();\n+\t\tld_arg_u32 $s1, [%return_value];\n+\t}\n+\tarrivefbar %fb_func_scope;\n+\n+        ld_kernarg_u64 $d1, [%output_ptr];\n+        st_global_u32 $s1, [$d0];\n+\n+\tworkitemflatabsid_u32 $s1;\n+\tcvt_b1_u32 $c0, $s1;\n+\tcbr_width(all)_b1 $c0, @skip_fini;\n+\n+\treleasefbar &fb_module_scope;\n+\treleasefbar %fb_func_scope;\n+\n+@skip_fini:\n+\n+};\n+/* fbarriers are allocated from the group memory in the order of \n+   appearance. The current implementation allocates 32B per fbarrier. */\n+\n+/* { dg-final { scan-tree-dump \"__hsail_waitfbar \\\\\\(0, __context\\\\\\);\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"__hsail_initfbar \\\\\\(0, __context\\\\\\);\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"__hsail_initfbar \\\\\\(32, __context\\\\\\);\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"__hsail_joinfbar \\\\\\(0, __context\\\\\\);\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"@skip_init:\\[\\n ]+__builtin___hsail_barrier \\\\\\(__context\\\\\\);\\[\\n ]+__builtin___hsail_joinfbar \\\\\\(32, __context\\\\\\);\" \"gimple\"} } */\n+\n+/* { dg-final { scan-tree-dump \"__hsail_arrivefbar \\\\\\(32, __context\\\\\\);\" \"gimple\"} } */\n+\n+/* { dg-final { scan-tree-dump \"__hsail_releasefbar \\\\\\(0, __context\\\\\\);\\[\\n ]+__builtin___hsail_releasefbar \\\\\\(32, __context\\\\\\);\" \"gimple\"} } */"}, {"sha": "d3b690cd37a5f39e9a6a6fe793a0de3a96f16e5f", "filename": "gcc/testsuite/brig.dg/test/gimple/function_calls.hsail", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffunction_calls.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffunction_calls.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffunction_calls.hsail?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,59 @@\n+module &module:1:0:$full:$large:$default;\n+\n+/* Function calls and argument passing. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-gimple\" } */\n+\n+prog function &subfunction(arg_u32 %return_value)(arg_f32 %float_arg, arg_f64 %double_arg, arg_f16 %half_arg) {\n+     ld_arg_f32 $s0, [%float_arg];\n+     cvt_u32_f32 $s0, $s0;\n+\n+     ld_arg_f64 $d0, [%double_arg];\n+     cvt_u32_f64 $s1, $d0;\n+\n+     ld_arg_f16 $s2, [%half_arg];\n+     cvt_u32_f16 $s2, $s2;\n+\n+     add_u32 $s3, $s0, $s1;\n+     add_u32 $s3, $s3, $s2;\n+\n+     st_arg_u32 $s3, [%return_value];\n+     ret;\n+};\n+\n+prog kernel &kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n+{\n+        ld_kernarg_u64 $d0, [%input_ptr];\n+        ld_global_u32 $s0, [$d0];\n+\t{\n+\t\targ_f32 %float_arg;\n+\t\targ_f64 %double_arg;\n+\t\targ_f16 %half_arg;\n+\t\targ_u32 %return_value;\n+\n+\t\tst_arg_f32 12.0f, [%float_arg];\n+\t\tst_arg_f64 640.0d, [%double_arg];\n+\t\tst_arg_f16 12.0h, [%half_arg];\n+\n+\t\tcall &subfunction(%return_value)(%float_arg, %double_arg, %half_arg);\n+\n+\t\tld_arg_u32 $s1, [%return_value];\n+\t}\t\n+        ld_kernarg_u64 $d1, [%output_ptr];\n+        st_global_u32 $s1, [$d0];\n+};\n+\n+/* The generated function call should have the incoming arguments and three hidden arguments. */\n+\n+/* { dg-final { scan-tree-dump \"_\\[0-9\\]+ = subfunction \\\\\\(_kernel.float_arg.\\[_0-9\\]+, _kernel.double_arg.\\[_0-9\\]+, _kernel.half_arg.\\[_0-9\\]+, __context, __group_base_addr, __private_base_addr\\\\\\);\" \"gimple\"} } */\n+\n+/* The callee should refer directly to the scalar arguments when it reads them. */\n+/* { dg-final { scan-tree-dump \"= float_arg;\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"= double_arg;\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"= half_arg;\" \"gimple\"} } */\n+\n+/* The return value is stored to a temporary before returned. */\n+/* { dg-final { scan-tree-dump \"_retvalue_temp = s3;\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"D.\\[0-9\\]+ = _retvalue_temp;\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"return D.\\[0-9\\]+;\" \"gimple\"} } */"}, {"sha": "7f30919e30819d0a42d9a48bb8c8a4bcead3bee5", "filename": "gcc/testsuite/brig.dg/test/gimple/kernarg.hsail", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fkernarg.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fkernarg.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fkernarg.hsail?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,25 @@\n+module &module:1:0:$full:$large:$default;\n+\n+/* Tests for kernarg addressing modes. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-original\" } */\n+\n+prog kernel &Kernel(kernarg_u64 %input[4], kernarg_u64 %output_ptr, kernarg_u64 %i)\n+{\n+\tld_kernarg_u64 $d0, [%i];\n+\tld_kernarg_u64 $d0, [%input][$d0 + 1];\n+\n+\tld_kernarg_u64 $d1, [%output_ptr];\n+\tst_global_u64 $d0, [$d1];\n+\n+\tret;\n+};\n+\n+/* [%i] */\n+/* { dg-final { scan-tree-dump \" = \\\\\\*\\\\\\(unsigned long \\\\\\*\\\\\\) \\\\\\(__args \\\\\\+ 40\\\\\\);\" \"original\"} } */\n+\n+/* [%input][$d0 + 1] */\n+/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(unsigned long \\\\\\*\\\\\\) \\\\\\(\\\\\\(VIEW_CONVERT_EXPR<void \\\\\\*>\\\\\\(\\\\\\(unsigned long\\\\\\) __args\\\\\\) \\\\\\+ \\\\\\(unsigned long\\\\\\) d0\\\\\\) \\\\\\+ 1\\\\\\);\" \"original\"} } */\n+\n+"}, {"sha": "75835a102592830405480c0073bf4e1c0fccd4b6", "filename": "gcc/testsuite/brig.dg/test/gimple/mem.hsail", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fmem.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fmem.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fmem.hsail?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,39 @@\n+module &module:1:0:$full:$large:$default;\n+\n+/* Tests for load/store addressing modes. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-original\" } */\n+\n+prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %input_ptr2, kernarg_u64 %output_ptr)\n+{\n+\tglobal_u32 %global_array[4];\n+\n+\tld_kernarg_u64 $d0, [%input_ptr];\n+\tld_kernarg_u64 $d2, [%input_ptr2];\n+\tld_global_u32 $s0, [$d0];\n+\tld_global_u64 $d1, [$d2 + 4];\n+\n+\tld_global_u32 $s2, [%global_array][$d1 + 4];\n+\n+\tld_kernarg_u64 $d0, [%output_ptr];\n+\tst_global_u32 $s0, [$d0];\n+\tst_global_u32 $s1, [$d0 + 4];\n+\tst_global_u32 $s2, [$d0 + 8];\n+\n+\tret;\n+};\n+\n+/* %input_ptr, %input_ptr2 and %output_ptr accesses should generate offsets to the __args array */\n+/* { dg-final { scan-tree-dump \"__args;\\[\\n \\]+d0 =\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"\\\\\\(__args \\\\\\+ 8\\\\\\);\\[\\n \\]+d2 =\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"\\\\\\(__args \\\\\\+ 16\\\\\\);\\[\\n \\]+d0 =\" \"original\"} } */\n+\n+/* ld_global_u32 $s0, [$d0] */\n+/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(unsigned int \\\\\\*\\\\\\) d0;\\[\\n \\]+s0 =\" \"original\"} } */\n+\n+/* ld_global_u64 $d1, [$d2 + 4] pointer arithmetics*/\n+/* { dg-final { scan-tree-dump \"d2 \\\\\\+ 4\\\\\\);\\[\\n \\]+d1 = \" \"original\"} } */\n+\n+/* ld_global_u32 $s2, [%global_array][$d1 + 4]; is the most complex form */\n+/* { dg-final { scan-tree-dump \"\\\\\\(unsigned long\\\\\\) &_Kernel.global_array\\\\\\) \\\\\\+ \\\\\\(unsigned long\\\\\\) d1\\\\\\) \\\\\\+ 4\" \"original\" } } */"}, {"sha": "acdced9ad1c4fe4e1f8fe372d77ab2085f195efe", "filename": "gcc/testsuite/brig.dg/test/gimple/mulhi.hsail", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fmulhi.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fmulhi.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fmulhi.hsail?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,33 @@\n+module &module:1:0:$full:$large:$default;\n+\n+/* Test high part multiplies. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-gimple\" } */\n+\n+prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n+{\n+        ld_kernarg_u64 $d0, [%input_ptr];\n+        ld_global_u64 $d1, [$d0];\n+        ld_global_u64 $d2, [$d0 + 8];\n+\n+        ld_global_u32 $s0, [$d0 + 16];\n+        ld_global_u32 $s1, [$d0 + 20];\n+\n+\tmulhi_s32 $s2, $s0, $s1;\n+\tmulhi_s64 $d2, $d1, $d2;\n+\n+\tmad24hi_s32 $s3, $s0, $s1, $s2;\n+\tmul24hi_s32 $s3, $s3, $s1;\n+\n+        ld_kernarg_u64 $d0, [%output_ptr];\n+        st_global_u64 $d1, [$d0];\n+        st_global_u32 $s2, [$d0 + 8];\n+        st_global_u32 $s3, [$d0 + 12];\n+\n+        ret;\n+};\n+\n+/* All of the hipart mults areImplemented using MULT_HIGHPART_EXPR (h*). */\n+/* { dg-final { scan-tree-dump-times \" h\\\\\\* \" 4 \"gimple\"} } */\n+"}, {"sha": "9219ffd480d4a2d6ff6dd4ec69a50e846eab27fa", "filename": "gcc/testsuite/brig.dg/test/gimple/packed.hsail", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fpacked.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fpacked.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fpacked.hsail?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,78 @@\n+module &module:1:0:$full:$large:$default;\n+\n+/* Test for different cases of packed instruction controls. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-gimple -fdump-tree-original\" } */\n+\n+prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n+{\n+        ld_kernarg_u64 $d0, [%input_ptr];\n+        ld_global_b128 $q0, [$d0];\n+\n+\tadd_pp_u8x16 $q1, $q0, u8x16(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n+\n+\t/* Broadcast the 15 as it's the lowest element (pos 0) in the resulting vector. */\n+\tadd_ps_u8x16 $q2, $q1, u8x16(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n+\n+\t/* Broadcast the lowest element of q1. */\n+\tadd_sp_u8x16 $q3, $q1, $q2;\n+\n+\t/* Perform a scalar computation with the lowest element of both inputs and store it to the lowest element of dest. */\n+\tadd_ss_u8x16 $q4, $q2, $q3;\n+\n+\t/* Saturating arithmetics variations. */\n+\tadd_pp_sat_u8x16 $q5, $q4, u8x16(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n+\n+\t/* Broadcast the 15 as it's the lowest element (pos 0) in the resulting vector. */\n+\tadd_ps_sat_u8x16 $q6, $q5, u8x16(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n+\n+\t/* Broadcast the lowest element of q1. */\n+\tadd_sp_sat_u8x16 $q7, $q6, $q5;\n+\n+\t/* Perform a scalar computation with the lowest element of both inputs and store it to the lowest element of dest. */\n+\tadd_ss_sat_u8x16 $q8, $q7, $q6;\n+\n+\t/* Single operand vector computation. */\n+\tneg_p_s16x8 $q9, $q8;\n+\n+        ld_kernarg_u64 $d0, [%output_ptr];\n+        st_global_b128 $q8, [$d0];\n+\n+        ret;\n+};\n+\n+/* The b128 load is done using uint128_t*.\n+/* { dg-final { scan-tree-dump \"q0 = VIEW_CONVERT_EXPR<uint128_t>\\\\\\(mem_read.\\[0-9\\]+\\\\\\);\" \"original\"} } */\n+\n+/* Before arithmetics, the uint128_t is casted to a vector datatype. */\n+/* { dg-final { scan-tree-dump \"<vector\\\\\\(16\\\\\\) unsigned char>\\\\\\(q0\\\\\\) \\\\\\+ \\\\\\{\" \"original\"} } */\n+\n+/* The u8x16 constant is generated to an array with elements in reverse order */\n+/* in comparison to the HSAIL syntax. */\n+/* { dg-final { scan-tree-dump \"\\\\\\+ { 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }\" \"original\"} } */\n+\n+/* After arithmetics, the vector DT is casted back to a uint128_t. */\n+/* { dg-final { scan-tree-dump \"q1 = VIEW_CONVERT_EXPR<uint128_t>\" \"original\"} } */\n+\n+/* Broadcasted the constant vector's lowest element and summed it up in the next line. */\n+/* { dg-final { scan-tree-dump \"= { 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 };\\[\\n \\]+_\\[0-9\\]+ = _\\[0-9\\]+ \\\\\\+ _\\[0-9\\]+;\" \"gimple\"} } */\n+\n+/* Broadcasted the registers lowest element via a VEC_PERM_EXPR that has an all-zeros mask. */\n+/* { dg-final { scan-tree-dump \"VEC_PERM_EXPR <_\\[0-9\\]+, _\\[0-9\\]+, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }>;\" \"gimple\" } } */\n+\n+/* For the add_ss we assume performing the computation over the whole vector is cheaper than */\n+/* extracting the scalar and performing a scalar operation. This aims to stay in the vector\n+/* datapath as long as possible. */\n+/* { dg-final { scan-tree-dump \"_\\[0-9\\]+ = VIEW_CONVERT_EXPR<vector\\\\\\(16\\\\\\) unsigned char>\\\\\\(q2\\\\\\);\\[\\n \\]+_\\[0-9\\]+ = VIEW_CONVERT_EXPR<vector\\\\\\(16\\\\\\) unsigned char>\\\\\\(q3\\\\\\);\\[\\n \\]+_\\[0-9\\]+ = _\\[0-9\\]+ \\\\\\+ _\\[0-9\\]+;\" \"gimple\" } } */\n+\n+/* Insert the lowest element of the result to the lowest element of the result register. */\n+/* { dg-final { scan-tree-dump \"= VEC_PERM_EXPR <_\\[0-9\\]+, new_output.\\[0-9\\]+_\\[0-9\\]+, { 16, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }>;\" \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump \"q4 = VIEW_CONVERT_EXPR<uint128_t>\\\\\\(s_output.\\[0-9\\]+_\\[0-9\\]+\\\\\\);\" \"gimple\" } } */\n+\n+/* The saturating arithmetics are (curently) implemented using scalar builtin calls. */\n+/* { dg-final { scan-tree-dump-times \"= __builtin___hsail_sat_add_u8\" 64 \"gimple\" } } */\n+\n+/* A single operand vector instr (neg.) */\n+/* { dg-final { scan-tree-dump \" = VIEW_CONVERT_EXPR<vector\\\\\\(8\\\\\\) signed short>\\\\\\(q8\\\\\\);\\[\\n \\]+_\\[0-9\\]+ = -_\\[0-9\\]+;\\[\\n \\]+\" \"gimple\" } } */"}, {"sha": "850aeeb6a849fc1214a01dda42af737b1f71ad92", "filename": "gcc/testsuite/brig.dg/test/gimple/smoke_test.hsail", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fsmoke_test.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fsmoke_test.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fsmoke_test.hsail?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,91 @@\n+module &module:1:0:$full:$large:$default;\n+\n+/* A basic smoke test. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-gimple\" } */\n+\n+prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n+{\n+\tld_kernarg_u64 $d0, [%input_ptr];\n+\tld_global_u32 $s0, [$d0];\n+\tld_global_u32 $s1, [$d0 + 4];\n+\n+\tadd_u32 $s2, $s0, $s1;\n+\tadd_u32 $s3, $s0, 4294967295;\n+\n+\tld_kernarg_u64 $d0, [%output_ptr];\n+\tst_global_u32 $s2, [$d0];\n+\tst_global_u32 $s3, [$d0 + 4];\n+\n+\tret;\n+};\n+\n+prog kernel &KernelWithBarrier(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n+{\n+\tld_kernarg_u64 $d0, [%input_ptr];\n+\tld_global_u32 $s0, [$d0];\n+\tld_global_u32 $s1, [$d0 + 4];\n+\n+\tadd_u32 $s2, $s0, $s1;\n+\n+\tbarrier_width(all);\n+\n+\tadd_u32 $s3, $s0, 4294967295;\n+\n+\tld_kernarg_u64 $d0, [%output_ptr];\n+\tst_global_u32 $s2, [$d0];\n+\tst_global_u32 $s3, [$d0 + 4];\n+\n+\tret;\n+};\n+\n+/* The kernel function itself should have a fingerprint as follows */\n+/* _Kernel (unsigned char * __args, void * __context, void * __group_base_addr, void * __private_base_addr) */\n+/* { dg-final { scan-tree-dump \"_Kernel \\\\\\(unsigned char \\\\\\* __args, void \\\\\\* __context, void \\\\\\* __group_base_addr, void \\\\\\* __private_base_addr\\\\\\)\" \"gimple\"} } */\n+\n+/* ld_kernarg: mem_read.0 = MEM[(unsigned long *)__args]; */\n+/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\] = MEM\\\\\\[\\\\\\(unsigned long \\\\\\*\\\\\\)__args\\\\\\];\" \"gimple\"} } */\n+\n+/* The latter ld_global_u32 should be visible as a pointer dereference (after pointer arithmetics on a temporary var): */\n+/* mem_read.2 = *D.1691; */\n+/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\] = \\\\\\*\\[_0-9\\]+;\" \"gimple\"} } */\n+\n+/* add_u32s should generate +operators */\n+/* { dg-final { scan-tree-dump \"s2 = s0 \\\\\\+ s1;\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"s3 = s0 \\\\\\+ 4294967295;\" \"gimple\"} } */\n+\n+/* The latter st_global_u32 should be visible as a pointer dereference (after pointer arithmetics on a temporary var): */\n+/* *D.1694 = s3; */\n+/* { dg-final { scan-tree-dump \"\\\\\\*\\[_0-9\\]+ = s3;\" \"gimple\"} } */\n+\n+/* The return inside the kernel should be generated to a goto to the end of the kernel. */\n+/*  goto __kernel_exit; */\n+/*  __kernel_exit: */\n+/* { dg-final { scan-tree-dump \"goto __kernel_exit;\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"__kernel_exit:\" \"gimple\"} } */\n+\n+/* Expecting a work item loop because there are no barrier calls. */\n+/* { dg-final { scan-tree-dump \"if \\\\\\(__local_x < __cur_wg_size_x\\\\\\) goto __wi_loop_x; else goto\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"if \\\\\\(__local_y < __cur_wg_size_y\\\\\\) goto __wi_loop_y; else goto\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"if \\\\\\(__local_z < __cur_wg_size_z\\\\\\) goto __wi_loop_z; else goto\" \"gimple\"} } */\n+\n+/* The launcher should call __hsail_launch_wg_function in this case: */\n+/* Kernel (void * __context, void * __group_base_addr) */\n+/* { dg-final { scan-tree-dump \"Kernel \\\\\\(void \\\\\\* __context, void \\\\\\* __group_base_addr\\\\\\)\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"__hsail_launch_wg_function \\\\\\(_Kernel, __context, __group_base_addr\\\\\\);\" \"gimple\"} }*/\n+\n+/* The kernel should have the magic metadata section injected to the ELF. */\n+/* TODO: this should be disabled in case not outputting to an ELF. */\n+/* Currently ELF is assumed by the brig frontend. Do not check for the context */\n+/* as it is likely to change. */\n+/* { dg-final { scan-tree-dump \"\\\\\\.pushsection phsa\\\\\\.desc\\\\\\.Kernel\" \"gimple\"} }*/\n+\n+/* The kernel with the barrier call should have the barrier builtin call in between the two summations. */\n+/* { dg-final { scan-tree-dump \"s2 = s0 \\\\\\+ s1;\\[\\n \\]+__builtin___hsail_barrier \\\\\\(__context\\\\\\);\\[\\n \\]+s3 = s0 \\\\\\+ 4294967295;\" \"gimple\"} } */\n+\n+/* The kernel with the barrier call's launcher function should call the thread-spawning function. */\n+/* { dg-final { scan-tree-dump \"__hsail_launch_kernel \\\\\\(_KernelWithBarrier, __context, __group_base_addr\\\\\\);\" \"gimple\" } } */\n+\n+\n+"}, {"sha": "c76ea6065751cc99c82fd64148ff6fa377b697dc", "filename": "gcc/testsuite/brig.dg/test/gimple/variables.hsail", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvariables.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvariables.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvariables.hsail?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,124 @@\n+module &module:1:0:$full:$large:$default;\n+\n+/* Tests for different variable scopes and address spaces. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-gimple\" } */\n+\n+prog align(256) private_u32 &prog_private;\n+private_u32 &mod_private;\n+\n+prog group_u32 &prog_group;\n+group_u32 &mod_group;\n+\n+prog global_u32 &prog_global;\n+global_u32 &mod_global;\n+\n+decl prog global_u32 &prog_global_host_def;\n+\n+prog readonly_u32 &prog_readonly;\n+readonly_u32 &mod_readonly;\n+\n+prog function &subfunction(arg_u32 %return_value)(arg_u32 %arg) {\n+\n+     private_u32 %func_private;\n+     group_u32 %func_group;\n+     align(256) global_u32 %func_global;\n+     readonly_u32 %func_readonly;\n+\n+     ld_private_u32 $s200, [%func_private];\n+     st_private_u32 $s200, [&prog_private];\n+\n+     ld_group_u32 $s203, [%func_group];\n+     st_group_u32 $s203, [&prog_group];\n+\n+     ld_global_u32 $s204, [%func_global];\n+     st_global_u32 $s204, [&prog_global];\n+\n+     ld_readonly_u32 $s205, [%func_readonly];\n+     st_global_u32 $s205, [%func_global];\n+\n+     st_arg_u32 $s2, [%return_value];\n+     ret;\n+};\n+\n+prog kernel &kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n+{\n+\tprivate_u32 %kern_private;\n+\tgroup_u32 %kern_group;\n+\tglobal_u32 %kern_global;\n+\treadonly_u32 %kern_readonly;\n+\n+        ld_kernarg_u64 $d0, [%input_ptr];\n+        ld_global_u32 $s0, [$d0];\n+\n+\tld_private_u32 $s2, [&prog_private];\n+\tst_private_u32 $s2, [%kern_private];\n+\tld_private_u32 $s3, [&mod_private];\n+\tst_private_u32 $s3, [&prog_private];\n+\n+\tld_group_u32 $s4, [&prog_group];\n+\tst_group_u32 $s4, [%kern_group];\n+\tld_group_u32 $s5, [&mod_group];\n+\tst_group_u32 $s5, [&prog_group];\n+\n+\tld_global_u32 $s6, [&prog_global];\n+\tst_global_u32 $s6, [%kern_global];\n+\tld_global_u32 $s7, [&mod_global];\n+\tst_global_u32 $s7, [&prog_global];\n+\n+\tld_readonly_u32 $s8, [&prog_readonly];\n+\tst_global_u32 $s8, [%kern_global];\n+\tld_readonly_u32 $s9, [&mod_readonly];\n+\tst_global_u32 $s9, [&prog_global];\n+\n+\tld_readonly_u32 $s10, [%kern_readonly];\n+\tst_global_u32 $s10, [%kern_global];\n+\tld_readonly_u32 $s11, [%kern_readonly];\n+\tst_global_u32 $s11, [&prog_global_host_def];\n+\n+\t{\n+\t\targ_u32 %arg;\n+\t\targ_u32 %return_value;\n+\t\tst_arg_u32 $s1, [%arg];\n+\t\tcall &subfunction(%return_value)(%arg);\n+\t\tld_arg_u32 $s1, [%return_value];\n+\t}\n+        ld_kernarg_u64 $d1, [%output_ptr];\n+        st_global_u32 $s1, [$d0];\n+};\n+\n+/* Private variable offsets assigned in the order of their appearance */\n+/*\n+ prog_private @0\t(align 256) -> until 254 to ensure all WIs\n+ mod_private  @256\t               have their chunks aligned\n+ func_private @260\n+ kern_private @264\n+*/\n+\n+/* Group variable offsets assigned in the order of their appearance */\n+/*\n+ prog_group @0\t\t(2)\n+ mod_group  @4\t\t(4)\n+ func_group @8\t\t(1)\n+ kern_group @12\t\t(3)\n+*/\n+\n+/* { dg-final { scan-tree-dump \"\\\\\\+ 8;.*\\\\\\+ 12;.*\\\\\\+ 4;\" \"gimple\" } } */\n+\n+/* The \"mangling\" of the global and readonly vars. */\n+/* { dg-final { scan-tree-dump \"\\[ \\]*prog_global = s204;\" \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump \"\\.module.mod_global;\" \"gimple\" } } */\n+\n+/* Host defined variables need indirect access as the address is\n+   known only at run time. */\n+/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\__phsa.host_def.prog_global_host_def.\\[0-9\\]+_\\[0-9\\]+ = s11;\" \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump \"\\.subfunction.func_global;\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"\\.subfunction.func_readonly;\" \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump \"kernel.kern_global\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"kernel.kern_readonly\" \"gimple\" } } */\n+\n+"}, {"sha": "20718408e27f4d1d68ea540d9e34c833c2b17a97", "filename": "gcc/testsuite/brig.dg/test/gimple/vector.hsail", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvector.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvector.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvector.hsail?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,57 @@\n+module &module:1:0:$full:$large:$default;\n+\n+/* A test for vector operands. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-original\" } */\n+\n+prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n+{\n+        ld_kernarg_u64 $d0, [%input_ptr];\n+\tld_v2_global_f32 ($s0, $s1), [$d0];\n+\tld_v3_global_f32 ($s2, $s3, $s4), [$d0 + 8];\n+\tld_v4_global_f32 ($s5, $s6, $s7, $s8), [$d0 + 20];\n+\n+\tadd_f32 $s9, $s0, $s1;\n+\tcombine_v2_b64_b32 $d2, ($s1, $s0);\n+\tcombine_v2_b64_b32 $d3, ($s2, $s3);\n+\n+\tadd_pp_f32x2 $d4, $d2, $d3;\n+\n+\texpand_v2_b32_b64 ($s0, $s3), $d4;\n+\n+        ld_kernarg_u64 $d1, [%output_ptr];\n+        st_v2_global_f32 ($s0, $s1), [$d1];\n+        st_v3_global_f32 ($s2, $s3, $s4), [$d1 + 8];\n+        st_v4_global_f32 ($s5, $s6, $s7, $s8), [$d1 + 20];\n+\n+        ret;\n+};\n+\n+/* The v2 load is done via casting to a vector datatype ptr. */\n+/* { dg-final { scan-tree-dump \" = MEM\\\\\\[\\\\\\(vector\\\\\\(2\\\\\\) <float:32> \\\\\\*\\\\\\)\" \"original\"} } */\n+\n+/* The v3 load is scalarized (at the moment) due to gcc requiring 2's exponent wide vectors. */\n+/* { dg-final { scan-tree-dump \"s0 = VIEW_CONVERT_EXPR<unsigned int>\\\\\\(BIT_FIELD_REF <mem_read.\\[0-9\\]+, 32, 0>\\\\\\);\\[\\n ]+s1 = VIEW_CONVERT_EXPR<unsigned int>\\\\\\(BIT_FIELD_REF <mem_read.\\[0-9\\]+, 32, 32>\\\\\\);\" \"original\"} } */\n+\n+/* The v4 load is done via casting to a vector datatype ptr. */\n+/* { dg-final { scan-tree-dump \" = MEM\\\\\\[\\\\\\(vector\\\\\\(4\\\\\\) <float:32> \\\\\\*\\\\\\)\" \"original\"} } */\n+\n+/* The combines are generated to vector constructors. */\n+/* { dg-final { scan-tree-dump \"{s1, s0}\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"{s2, s3}\" \"original\"} } */\n+\n+/* Expands to BIT_FIELD_REFs. */\n+/* { dg-final { scan-tree-dump \"s0 = BIT_FIELD_REF <d4, 32, 0>;\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"s3 = BIT_FIELD_REF <d4, 32, 32>;\" \"original\"} } */\n+\n+/* The v1 store is done via casting to a vector datatype ptr and constructing a vector from the inputs. */\n+/* { dg-final { scan-tree-dump \"MEM\\\\\\[\\\\\\(vector\\\\\\(2\\\\\\) <float:32> \\\\\\*\\\\\\)\\\\\\(<float:32> \\\\\\*\\\\\\) d1\\\\\\] = \" \"original\"} } */\n+\n+/* The v3 store is scalarized (at the moment) due to gcc requiring 2's exponent wide vectors. */\n+/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(<float:32> \\\\\\*\\\\\\) \\\\\\(\\\\\\(sizetype\\\\\\) d1 \\\\\\+ 8\\\\\\) \\\\\\+ 0 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s2\\\\\\);\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(<float:32> \\\\\\*\\\\\\) \\\\\\(\\\\\\(sizetype\\\\\\) d1 \\\\\\+ 8\\\\\\) \\\\\\+ 4 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s3\\\\\\);\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(<float:32> \\\\\\*\\\\\\) \\\\\\(\\\\\\(sizetype\\\\\\) d1 \\\\\\+ 8\\\\\\) \\\\\\+ 8 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s4\\\\\\);\" \"original\"} } */\n+\n+/* The v4 store is done via casting to a vector datatype and constructing a vector from the inputs. */\n+/* { dg-final { scan-tree-dump \"MEM\\\\\\[\\\\\\(vector\\\\\\(4\\\\\\) <float:32> \\\\\\*\\\\\\)\\\\\\(<float:32> \\\\\\*\\\\\\) \\\\\\(\\\\\\(sizetype\\\\\\) d1 \\\\\\+ 20\\\\\\)\\\\\\] = {VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s5\\\\\\), VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s6\\\\\\), VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s7\\\\\\), VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s8\\\\\\)};\" \"original\"} } */"}, {"sha": "ee96708523ca589bd283f0691f8e37a270a82b06", "filename": "gcc/testsuite/lib/brig-dg.exp", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Flib%2Fbrig-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Flib%2Fbrig-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fbrig-dg.exp?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,29 @@\n+#   Copyright (C) 2009-2014 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+load_lib gcc-dg.exp\n+\n+# Define brig callbacks for dg.exp.\n+\n+proc brig-dg-test { prog do_what extra_tool_flags } {\n+    set result \\\n+\t[gcc-dg-test-1 brig_target_compile $prog $do_what $extra_tool_flags]\n+    \n+    set comp_output [lindex $result 0]\n+    set output_file [lindex $result 1]\n+\n+    return [list $comp_output $output_file]\n+}"}, {"sha": "d1c967d36f3e99e4c7ce183f7c6e98c426d78466", "filename": "gcc/testsuite/lib/brig.exp", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Flib%2Fbrig.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/gcc%2Ftestsuite%2Flib%2Fbrig.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fbrig.exp?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,40 @@\n+# Copyright (C) 2009-2016 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+load_lib prune.exp\n+load_lib gcc-defs.exp\n+load_lib timeout.exp\n+load_lib target-libpath.exp\n+#\n+# brig_target_compile -- compile a HSAIL input to BRIG using HSAILasm and then\n+#                        compile the BRIG to target ISA using gcc\n+\n+proc brig_target_compile { source dest type options } {\n+    global tmpdir\n+    global testname_with_flags\n+    if { [file extension $source] == \".hsail\" } {\n+\t# We cannot assume all inputs are .hsail as the dg machinery\n+\t# calls this for a some c files to check linker plugin support or\n+\t# similar.\n+\tset brig_source ${tmpdir}/[file tail ${source}].brig\n+\texec HSAILasm $source -o ${brig_source}\n+\tset source ${brig_source}\n+\t# Change the testname the .brig.\n+\tset testname_with_flags [file tail $source]\n+    }\n+    return [target_compile $source $dest $type $options]\n+}\n+"}, {"sha": "4c1879b665388cae565310a3cfec5caf92959394", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -1,3 +1,8 @@\n+2017-01-24  Pekka J\u00e4\u00e4skel\u00e4inen <pekka@parmance.com>\n+\t    Martin Jambor  <mjambor@suse.cz>\n+\n+\t* hsa.h: Moved here from libgomp/plugin/hsa.h.\n+\n 2017-01-04  Richard Earnshaw  <rearnsha@arm.com>\n \t    Jiong Wang  <jiong.wang@arm.com>\n "}, {"sha": "9b9c826520fd08d9962ee28d9b886fba1300c200", "filename": "include/hsa.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/include%2Fhsa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/include%2Fhsa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fhsa.h?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "previous_filename": "libgomp/plugin/hsa.h"}, {"sha": "be6a13a99fc44eaddb8b86b979ecdb3d8c947296", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -1,3 +1,9 @@\n+2017-01-24  Pekka J\u00e4\u00e4skel\u00e4inen <pekka@parmance.com>\n+\t    Martin Jambor  <mjambor@suse.cz>\n+\n+\t* plugin/hsa.h: Moved to top level include.\n+\t* plugin/plugin-hsa.c: Chanfgd include of hsa.h accordingly.\n+\n 2017-01-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR other/79046"}, {"sha": "9757fc66b84471f7aee40c40f52913b883cd9964", "filename": "libgomp/plugin/plugin-hsa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libgomp%2Fplugin%2Fplugin-hsa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libgomp%2Fplugin%2Fplugin-hsa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-hsa.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -34,7 +34,7 @@\n #include <pthread.h>\n #include <inttypes.h>\n #include <stdbool.h>\n-#include <plugin/hsa.h>\n+#include <hsa.h>\n #include <plugin/hsa_ext_finalize.h>\n #include <dlfcn.h>\n #include \"libgomp-plugin.h\""}, {"sha": "51625f8e3a19720b8b0c7e30ed34b133926e24be", "filename": "libhsail-rt/ChangeLog", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2FChangeLog?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,27 @@\n+2017-01-24  Pekka J\u00e4\u00e4skel\u00e4inen <pekka@parmance.com>\n+\t    Martin Jambor  <mjambor@suse.cz>\n+\n+\t* Makefile.am: New file.\n+\t* target-config.h.in: Likewise.\n+\t* configure.ac: Likewise.\n+\t* configure: Likewise.\n+\t* config.h.in: Likewise.\n+\t* aclocal.m4: Likewise.\n+\t* README: Likewise.\n+\t* Makefile.in: Likewise.\n+\t* include/internal/fibers.h: Likewise.\n+\t* include/internal/phsa-queue-interface.h: Likewise.\n+\t* include/internal/phsa-rt.h: Likewise.\n+\t* include/internal/workitems.h: Likewise.\n+\t* rt/arithmetic.c: Likewise.\n+\t* rt/atomics.c: Likewise.\n+\t* rt/bitstring.c: Likewise.\n+\t* rt/fbarrier.c: Likewise.\n+\t* rt/fibers.c: Likewise.\n+\t* rt/fp16.c: Likewise.\n+\t* rt/misc.c: Likewise.\n+\t* rt/multimedia.c: Likewise.\n+\t* rt/queue.c: Likewise.\n+\t* rt/sat_arithmetic.c: Likewise.\n+\t* rt/segment.c: Likewise.\n+\t* rt/workitems.c: Likewise."}, {"sha": "ef12df8bb44234274eb6e1d037318bb912039bb5", "filename": "libhsail-rt/Makefile.am", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2FMakefile.am?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,124 @@\n+# Makefile.am -- libhsail-rt library Makefile.\n+\n+# Starting point copied from libcilkrts:\n+#  @copyright\n+#  Copyright (C) 2011, 2013, Intel Corporation\n+#  All rights reserved.\n+#\n+#  @copyright\n+#  Redistribution and use in source and binary forms, with or without\n+#  modification, are permitted provided that the following conditions\n+#  are met:\n+#\n+#    * Redistributions of source code must retain the above copyright\n+#      notice, this list of conditions and the following disclaimer.\n+#    * Redistributions in binary form must reproduce the above copyright\n+#      notice, this list of conditions and the following disclaimer in\n+#      the documentation and/or other materials provided with the\n+#      distribution.\n+#    * Neither the name of Intel Corporation nor the names of its\n+#      contributors may be used to endorse or promote products derived\n+#      from this software without specific prior written permission.\n+#\n+#  @copyright\n+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+#  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+#  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+#  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+#  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+#  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+#  POSSIBILITY OF SUCH DAMAGE.\n+\n+# libhsail-rt modifications:\n+# Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+# for General Processor Tech.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+# Process this file with autoreconf to produce Makefile.in.\n+\n+AUTOMAKE_OPTIONS = foreign subdir-objects\n+\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+\n+MAINT_CHARSET = latin1\n+\n+mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs\n+\n+ACLOCAL_AMFLAGS = -I m4\n+\n+WARN_CFLAGS = $(WARN_FLAGS) $(WERROR)\n+\n+# -I/-D flags to pass when compiling.\n+AM_CPPFLAGS = -I$(srcdir)/rt -I$(srcdir)/include/internal\n+\n+AM_CFLAGS = \\\n+\t-I $(srcdir)/../include \\\n+\t-I $(srcdir)/../libgcc \\\n+\t-I $(MULTIBUILDTOP)../../gcc/include $(PTH_CFLAGS)\n+\n+toolexeclib_LTLIBRARIES = libhsail-rt.la\n+\n+runtime_files = \\\n+\trt/arithmetic.c \\\n+\trt/atomics.c \\\n+\trt/bitstring.c \\\n+\trt/fbarrier.c \\\n+\trt/fp16.c \\\n+\trt/misc.c \\\n+\trt/multimedia.c \\\n+\trt/queue.c \\\n+\trt/sat_arithmetic.c \\\n+\trt/segment.c \\\n+\trt/workitems.c \\\n+\trt/fibers.c\n+\n+libhsail_rt_la_SOURCES = $(runtime_files)\n+libhsail_rt_la_LDFLAGS  = -rpath '$(libdir)'\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+       \"AR_FLAGS=$(AR_FLAGS)\" \\\n+       \"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+       \"CFLAGS=$(CFLAGS)\" \\\n+       \"CXXFLAGS=$(CXXFLAGS)\" \\\n+       \"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+       \"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+       \"INSTALL=$(INSTALL)\" \\\n+       \"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+       \"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+       \"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+       \"JC1FLAGS=$(JC1FLAGS)\" \\\n+       \"LDFLAGS=$(LDFLAGS)\" \\\n+       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+       \"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+       \"MAKE=$(MAKE)\" \\\n+       \"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+       \"PICFLAG=$(PICFLAG)\" \\\n+       \"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+       \"SHELL=$(SHELL)\" \\\n+       \"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+       \"exec_prefix=$(exec_prefix)\" \\\n+       \"infodir=$(infodir)\" \\\n+       \"libdir=$(libdir)\" \\\n+       \"prefix=$(prefix)\" \\\n+       \"includedir=$(includedir)\" \\\n+       \"AR=$(AR)\" \\\n+       \"AS=$(AS)\" \\\n+       \"LD=$(LD)\" \\\n+       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+       \"NM=$(NM)\" \\\n+       \"PICFLAG=$(PICFLAG)\" \\\n+       \"RANLIB=$(RANLIB)\" \\\n+       \"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES=\n+\n+"}, {"sha": "250cfbca544bb104bb8f3e7516a2a01bdb1f6ceb", "filename": "libhsail-rt/Makefile.in", "status": "added", "additions": 740, "deletions": 0, "changes": 740, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2FMakefile.in?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,740 @@\n+# Makefile.in generated by automake 1.11.6 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n+# Foundation, Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+# Makefile.am -- libhsail-rt library Makefile.\n+\n+# Starting point copied from libcilkrts:\n+#  @copyright\n+#  Copyright (C) 2011, 2013, Intel Corporation\n+#  All rights reserved.\n+#\n+#  @copyright\n+#  Redistribution and use in source and binary forms, with or without\n+#  modification, are permitted provided that the following conditions\n+#  are met:\n+#\n+#    * Redistributions of source code must retain the above copyright\n+#      notice, this list of conditions and the following disclaimer.\n+#    * Redistributions in binary form must reproduce the above copyright\n+#      notice, this list of conditions and the following disclaimer in\n+#      the documentation and/or other materials provided with the\n+#      distribution.\n+#    * Neither the name of Intel Corporation nor the names of its\n+#      contributors may be used to endorse or promote products derived\n+#      from this software without specific prior written permission.\n+#\n+#  @copyright\n+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+#  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+#  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+#  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+#  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+#  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+#  POSSIBILITY OF SUCH DAMAGE.\n+\n+# libhsail-rt modifications:\n+# Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+# for General Processor Tech.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+# Process this file with autoreconf to produce Makefile.in.\n+\n+VPATH = @srcdir@\n+am__make_dryrun = \\\n+  { \\\n+    am__dry=no; \\\n+    case $$MAKEFLAGS in \\\n+      *\\\\[\\ \\\t]*) \\\n+        echo 'am--echo: ; @echo \"AM\"  OK' | $(MAKE) -f - 2>/dev/null \\\n+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \\\n+      *) \\\n+        for am__flg in $$MAKEFLAGS; do \\\n+          case $$am__flg in \\\n+            *=*|--*) ;; \\\n+            *n*) am__dry=yes; break;; \\\n+          esac; \\\n+        done;; \\\n+    esac; \\\n+    test $$am__dry = yes; \\\n+  }\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+subdir = .\n+DIST_COMMON = README $(srcdir)/Makefile.in $(srcdir)/Makefile.am \\\n+\t$(top_srcdir)/configure $(am__configure_deps) \\\n+\t$(srcdir)/target-config.h.in $(srcdir)/../mkinstalldirs \\\n+\t$(srcdir)/../depcomp\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 $(top_srcdir)/../libtool.m4 \\\n+\t$(top_srcdir)/../ltoptions.m4 $(top_srcdir)/../ltsugar.m4 \\\n+\t$(top_srcdir)/../ltversion.m4 $(top_srcdir)/../lt~obsolete.m4 \\\n+\t$(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n+ configure.lineno config.status.lineno\n+CONFIG_HEADER = target-config.h\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n+am__vpath_adj = case $$p in \\\n+    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+    *) f=$$p;; \\\n+  esac;\n+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n+am__install_max = 40\n+am__nobase_strip_setup = \\\n+  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n+am__nobase_strip = \\\n+  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n+am__nobase_list = $(am__nobase_strip_setup); \\\n+  for p in $$list; do echo \"$$p $$p\"; done | \\\n+  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n+  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n+    if (++n[$$2] == $(am__install_max)) \\\n+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n+    END { for (dir in files) print dir, files[dir] }'\n+am__base_list = \\\n+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n+  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n+am__uninstall_files_from_dir = { \\\n+  test -z \"$$files\" \\\n+    || { test ! -d \"$$dir\" && test ! -f \"$$dir\" && test ! -r \"$$dir\"; } \\\n+    || { echo \" ( cd '$$dir' && rm -f\" $$files \")\"; \\\n+         $(am__cd) \"$$dir\" && rm -f $$files; }; \\\n+  }\n+am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\"\n+LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n+libhsail_rt_la_LIBADD =\n+am__dirstamp = $(am__leading_dot)dirstamp\n+am__objects_1 = rt/arithmetic.lo rt/atomics.lo rt/bitstring.lo \\\n+\trt/fbarrier.lo rt/fp16.lo rt/misc.lo rt/multimedia.lo \\\n+\trt/queue.lo rt/sat_arithmetic.lo rt/segment.lo rt/workitems.lo \\\n+\trt/fibers.lo\n+am_libhsail_rt_la_OBJECTS = $(am__objects_1)\n+libhsail_rt_la_OBJECTS = $(am_libhsail_rt_la_OBJECTS)\n+libhsail_rt_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n+\t$(libhsail_rt_la_LDFLAGS) $(LDFLAGS) -o $@\n+DEFAULT_INCLUDES = -I.@am__isrc@\n+depcomp = $(SHELL) $(top_srcdir)/../depcomp\n+am__depfiles_maybe = depfiles\n+am__mv = mv -f\n+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n+\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+CCLD = $(CC)\n+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+SOURCES = $(libhsail_rt_la_SOURCES)\n+am__can_run_installinfo = \\\n+  case $$AM_UPDATE_INFO_DIR in \\\n+    n|no|NO) false;; \\\n+    *) (install-info --version) >/dev/null 2>&1;; \\\n+  esac\n+ETAGS = etags\n+CTAGS = ctags\n+ACLOCAL = @ACLOCAL@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = @DEFS@\n+DEPDIR = @DEPDIR@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+RANLIB = @RANLIB@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+config_dir = @config_dir@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+AUTOMAKE_OPTIONS = foreign subdir-objects\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+MAINT_CHARSET = latin1\n+mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs\n+ACLOCAL_AMFLAGS = -I m4\n+WARN_CFLAGS = $(WARN_FLAGS) $(WERROR)\n+\n+# -I/-D flags to pass when compiling.\n+AM_CPPFLAGS = -I$(srcdir)/rt -I$(srcdir)/include/internal\n+AM_CFLAGS = \\\n+\t-I $(srcdir)/../include \\\n+\t-I $(srcdir)/../libgcc \\\n+\t-I $(MULTIBUILDTOP)../../gcc/include $(PTH_CFLAGS)\n+\n+toolexeclib_LTLIBRARIES = libhsail-rt.la\n+runtime_files = \\\n+\trt/arithmetic.c \\\n+\trt/atomics.c \\\n+\trt/bitstring.c \\\n+\trt/fbarrier.c \\\n+\trt/fp16.c \\\n+\trt/misc.c \\\n+\trt/multimedia.c \\\n+\trt/queue.c \\\n+\trt/sat_arithmetic.c \\\n+\trt/segment.c \\\n+\trt/workitems.c \\\n+\trt/fibers.c\n+\n+libhsail_rt_la_SOURCES = $(runtime_files)\n+libhsail_rt_la_LDFLAGS = -rpath '$(libdir)'\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+       \"AR_FLAGS=$(AR_FLAGS)\" \\\n+       \"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+       \"CFLAGS=$(CFLAGS)\" \\\n+       \"CXXFLAGS=$(CXXFLAGS)\" \\\n+       \"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+       \"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+       \"INSTALL=$(INSTALL)\" \\\n+       \"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+       \"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+       \"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+       \"JC1FLAGS=$(JC1FLAGS)\" \\\n+       \"LDFLAGS=$(LDFLAGS)\" \\\n+       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+       \"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+       \"MAKE=$(MAKE)\" \\\n+       \"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+       \"PICFLAG=$(PICFLAG)\" \\\n+       \"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+       \"SHELL=$(SHELL)\" \\\n+       \"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+       \"exec_prefix=$(exec_prefix)\" \\\n+       \"infodir=$(infodir)\" \\\n+       \"libdir=$(libdir)\" \\\n+       \"prefix=$(prefix)\" \\\n+       \"includedir=$(includedir)\" \\\n+       \"AR=$(AR)\" \\\n+       \"AS=$(AS)\" \\\n+       \"LD=$(LD)\" \\\n+       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+       \"NM=$(NM)\" \\\n+       \"PICFLAG=$(PICFLAG)\" \\\n+       \"RANLIB=$(RANLIB)\" \\\n+       \"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES = \n+all: target-config.h\n+\t$(MAKE) $(AM_MAKEFLAGS) all-am\n+\n+.SUFFIXES:\n+.SUFFIXES: .c .lo .o .obj\n+am--refresh: Makefile\n+\t@:\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n+\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n+\t\t&& exit 0; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    echo ' $(SHELL) ./config.status'; \\\n+\t    $(SHELL) ./config.status;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\t$(SHELL) ./config.status --recheck\n+\n+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n+\t$(am__cd) $(srcdir) && $(AUTOCONF)\n+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n+\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n+$(am__aclocal_m4_deps):\n+\n+target-config.h: stamp-h1\n+\t@if test ! -f $@; then rm -f stamp-h1; else :; fi\n+\t@if test ! -f $@; then $(MAKE) $(AM_MAKEFLAGS) stamp-h1; else :; fi\n+\n+stamp-h1: $(srcdir)/target-config.h.in $(top_builddir)/config.status\n+\t@rm -f stamp-h1\n+\tcd $(top_builddir) && $(SHELL) ./config.status target-config.h\n+$(srcdir)/target-config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) \n+\t($(am__cd) $(top_srcdir) && $(AUTOHEADER))\n+\trm -f stamp-h1\n+\ttouch $@\n+\n+distclean-hdr:\n+\t-rm -f target-config.h stamp-h1\n+install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n+\t@$(NORMAL_INSTALL)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tlist2=; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    list2=\"$$list2 $$p\"; \\\n+\t  else :; fi; \\\n+\tdone; \\\n+\ttest -z \"$$list2\" || { \\\n+\t  echo \" $(MKDIR_P) '$(DESTDIR)$(toolexeclibdir)'\"; \\\n+\t  $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\" || exit 1; \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(toolexeclibdir)\"; \\\n+\t}\n+\n+uninstall-toolexeclibLTLIBRARIES:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  $(am__strip_dir) \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n+\tdone\n+\n+clean-toolexeclibLTLIBRARIES:\n+\t-test -z \"$(toolexeclib_LTLIBRARIES)\" || rm -f $(toolexeclib_LTLIBRARIES)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+rt/$(am__dirstamp):\n+\t@$(MKDIR_P) rt\n+\t@: > rt/$(am__dirstamp)\n+rt/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) rt/$(DEPDIR)\n+\t@: > rt/$(DEPDIR)/$(am__dirstamp)\n+rt/arithmetic.lo: rt/$(am__dirstamp) rt/$(DEPDIR)/$(am__dirstamp)\n+rt/atomics.lo: rt/$(am__dirstamp) rt/$(DEPDIR)/$(am__dirstamp)\n+rt/bitstring.lo: rt/$(am__dirstamp) rt/$(DEPDIR)/$(am__dirstamp)\n+rt/fbarrier.lo: rt/$(am__dirstamp) rt/$(DEPDIR)/$(am__dirstamp)\n+rt/fp16.lo: rt/$(am__dirstamp) rt/$(DEPDIR)/$(am__dirstamp)\n+rt/misc.lo: rt/$(am__dirstamp) rt/$(DEPDIR)/$(am__dirstamp)\n+rt/multimedia.lo: rt/$(am__dirstamp) rt/$(DEPDIR)/$(am__dirstamp)\n+rt/queue.lo: rt/$(am__dirstamp) rt/$(DEPDIR)/$(am__dirstamp)\n+rt/sat_arithmetic.lo: rt/$(am__dirstamp) rt/$(DEPDIR)/$(am__dirstamp)\n+rt/segment.lo: rt/$(am__dirstamp) rt/$(DEPDIR)/$(am__dirstamp)\n+rt/workitems.lo: rt/$(am__dirstamp) rt/$(DEPDIR)/$(am__dirstamp)\n+rt/fibers.lo: rt/$(am__dirstamp) rt/$(DEPDIR)/$(am__dirstamp)\n+libhsail-rt.la: $(libhsail_rt_la_OBJECTS) $(libhsail_rt_la_DEPENDENCIES) $(EXTRA_libhsail_rt_la_DEPENDENCIES) \n+\t$(libhsail_rt_la_LINK) -rpath $(toolexeclibdir) $(libhsail_rt_la_OBJECTS) $(libhsail_rt_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\t-rm -f rt/arithmetic.$(OBJEXT)\n+\t-rm -f rt/arithmetic.lo\n+\t-rm -f rt/atomics.$(OBJEXT)\n+\t-rm -f rt/atomics.lo\n+\t-rm -f rt/bitstring.$(OBJEXT)\n+\t-rm -f rt/bitstring.lo\n+\t-rm -f rt/fbarrier.$(OBJEXT)\n+\t-rm -f rt/fbarrier.lo\n+\t-rm -f rt/fibers.$(OBJEXT)\n+\t-rm -f rt/fibers.lo\n+\t-rm -f rt/fp16.$(OBJEXT)\n+\t-rm -f rt/fp16.lo\n+\t-rm -f rt/misc.$(OBJEXT)\n+\t-rm -f rt/misc.lo\n+\t-rm -f rt/multimedia.$(OBJEXT)\n+\t-rm -f rt/multimedia.lo\n+\t-rm -f rt/queue.$(OBJEXT)\n+\t-rm -f rt/queue.lo\n+\t-rm -f rt/sat_arithmetic.$(OBJEXT)\n+\t-rm -f rt/sat_arithmetic.lo\n+\t-rm -f rt/segment.$(OBJEXT)\n+\t-rm -f rt/segment.lo\n+\t-rm -f rt/workitems.$(OBJEXT)\n+\t-rm -f rt/workitems.lo\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+@AMDEP_TRUE@@am__include@ @am__quote@rt/$(DEPDIR)/arithmetic.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@rt/$(DEPDIR)/atomics.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@rt/$(DEPDIR)/bitstring.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@rt/$(DEPDIR)/fbarrier.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@rt/$(DEPDIR)/fibers.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@rt/$(DEPDIR)/fp16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@rt/$(DEPDIR)/misc.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@rt/$(DEPDIR)/multimedia.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@rt/$(DEPDIR)/queue.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@rt/$(DEPDIR)/sat_arithmetic.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@rt/$(DEPDIR)/segment.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@rt/$(DEPDIR)/workitems.Plo@am__quote@\n+\n+.c.o:\n+@am__fastdepCC_TRUE@\tdepbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\\.o$$||'`;\\\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\\\n+@am__fastdepCC_TRUE@\t$(am__mv) $$depbase.Tpo $$depbase.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c -o $@ $<\n+\n+.c.obj:\n+@am__fastdepCC_TRUE@\tdepbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\\.obj$$||'`;\\\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ `$(CYGPATH_W) '$<'` &&\\\n+@am__fastdepCC_TRUE@\t$(am__mv) $$depbase.Tpo $$depbase.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.c.lo:\n+@am__fastdepCC_TRUE@\tdepbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\\.lo$$||'`;\\\n+@am__fastdepCC_TRUE@\t$(LTCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\\\n+@am__fastdepCC_TRUE@\t$(am__mv) $$depbase.Tpo $$depbase.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LTCOMPILE) -c -o $@ $<\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\t-rm -rf rt/.libs rt/_libs\n+\n+distclean-libtool:\n+\t-rm -f libtool config.lt\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS:  $(HEADERS) $(SOURCES) target-config.h.in $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tlist='$(SOURCES) $(HEADERS) target-config.h.in $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS:  $(HEADERS) $(SOURCES) target-config.h.in $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS) target-config.h.in $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+check-am: all-am\n+check: check-am\n+all-am: Makefile $(LTLIBRARIES) target-config.h\n+installdirs:\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n+\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n+\tdone\n+install: install-am\n+install-exec: install-exec-am\n+install-data: install-data-am\n+uninstall: uninstall-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-am\n+install-strip:\n+\tif test -z '$(STRIP)'; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t      install; \\\n+\telse \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n+\tfi\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\t-rm -f rt/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f rt/$(am__dirstamp)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-am\n+\n+clean-am: clean-generic clean-libtool clean-toolexeclibLTLIBRARIES \\\n+\tmostlyclean-am\n+\n+distclean: distclean-am\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf rt/$(DEPDIR)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-hdr distclean-libtool distclean-tags\n+\n+dvi: dvi-am\n+\n+dvi-am:\n+\n+html: html-am\n+\n+html-am:\n+\n+info: info-am\n+\n+info-am:\n+\n+install-data-am:\n+\n+install-dvi: install-dvi-am\n+\n+install-dvi-am:\n+\n+install-exec-am: install-toolexeclibLTLIBRARIES\n+\n+install-html: install-html-am\n+\n+install-html-am:\n+\n+install-info: install-info-am\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-am\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-am\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-am\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf $(top_srcdir)/autom4te.cache\n+\t-rm -rf rt/$(DEPDIR)\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-am\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-am\n+\n+pdf-am:\n+\n+ps: ps-am\n+\n+ps-am:\n+\n+uninstall-am: uninstall-toolexeclibLTLIBRARIES\n+\n+.MAKE: all install-am install-strip\n+\n+.PHONY: CTAGS GTAGS all all-am am--refresh check check-am clean \\\n+\tclean-generic clean-libtool clean-toolexeclibLTLIBRARIES ctags \\\n+\tdistclean distclean-compile distclean-generic distclean-hdr \\\n+\tdistclean-libtool distclean-tags dvi dvi-am html html-am info \\\n+\tinfo-am install install-am install-data install-data-am \\\n+\tinstall-dvi install-dvi-am install-exec install-exec-am \\\n+\tinstall-html install-html-am install-info install-info-am \\\n+\tinstall-man install-pdf install-pdf-am install-ps \\\n+\tinstall-ps-am install-strip install-toolexeclibLTLIBRARIES \\\n+\tinstallcheck installcheck-am installdirs maintainer-clean \\\n+\tmaintainer-clean-generic mostlyclean mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \\\n+\ttags uninstall uninstall-am uninstall-toolexeclibLTLIBRARIES\n+\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "2792253f6d345596b39e761e0d211c931e9489d1", "filename": "libhsail-rt/README", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2FREADME?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,4 @@\n+Run autoconf2.64 && automake-1.11  to regenerate the buildfiles.\n+You might need to manually tweak the minor automake version number\n+in configure.ac and aclocal.m4 (search for 1.11.6) in case your\n+local 1.11 minor version doesn't match. \n\\ No newline at end of file"}, {"sha": "f77a2dab7aea2d84d0ed28dc543af04826bc3824", "filename": "libhsail-rt/aclocal.m4", "status": "added", "additions": 978, "deletions": 0, "changes": 978, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Faclocal.m4?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,978 @@\n+# generated automatically by aclocal 1.11.1 -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,\n+[m4_warning([this file was generated for autoconf 2.64.\n+You have another version of autoconf.  It may work, but is not guaranteed to.\n+If you have problems, you may need to regenerate the build system entirely.\n+To do so, use the procedure documented by the package, typically `autoreconf'.])])\n+\n+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_AUTOMAKE_VERSION(VERSION)\n+# ----------------------------\n+# Automake X.Y traces this macro to ensure aclocal.m4 has been\n+# generated from the m4 files accompanying Automake X.Y.\n+# (This private macro should not be called outside this file.)\n+AC_DEFUN([AM_AUTOMAKE_VERSION],\n+[am__api_version='1.11'\n+dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n+dnl require some minimum version.  Point them to the right macro.\n+m4_if([$1], [1.11.6], [],\n+      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n+])\n+\n+# _AM_AUTOCONF_VERSION(VERSION)\n+# -----------------------------\n+# aclocal traces this macro to find the Autoconf version.\n+# This is a private macro too.  Using m4_define simplifies\n+# the logic in aclocal, which can simply ignore this definition.\n+m4_define([_AM_AUTOCONF_VERSION], [])\n+\n+# AM_SET_CURRENT_AUTOMAKE_VERSION\n+# -------------------------------\n+# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n+# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n+[AM_AUTOMAKE_VERSION([1.11.6])dnl\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n+\n+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n+#\n+# Of course, Automake must honor this variable whenever it calls a\n+# tool from the auxiliary directory.  The problem is that $srcdir (and\n+# therefore $ac_aux_dir as well) can be either absolute or relative,\n+# depending on how configure is run.  This is pretty annoying, since\n+# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n+# source directory, any form will work fine, but in subdirectories a\n+# relative path needs to be adjusted first.\n+#\n+# $ac_aux_dir/missing\n+#    fails when called from a subdirectory if $ac_aux_dir is relative\n+# $top_srcdir/$ac_aux_dir/missing\n+#    fails if $ac_aux_dir is absolute,\n+#    fails when called from a subdirectory in a VPATH build with\n+#          a relative $ac_aux_dir\n+#\n+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n+# are both prefixed by $srcdir.  In an in-source build this is usually\n+# harmless because $srcdir is `.', but things will broke when you\n+# start a VPATH build or use an absolute $srcdir.\n+#\n+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n+#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n+# and then we would define $MISSING as\n+#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n+# This will work as long as MISSING is not called from configure, because\n+# unfortunately $(top_srcdir) has no meaning in configure.\n+# However there are other variables, like CC, which are often used in\n+# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n+#\n+# Another solution, used here, is to always expand $ac_aux_dir to an\n+# absolute PATH.  The drawback is that using absolute paths prevent a\n+# configured tree to be moved without reconfiguration.\n+\n+AC_DEFUN([AM_AUX_DIR_EXPAND],\n+[dnl Rely on autoconf to set up CDPATH properly.\n+AC_PREREQ([2.50])dnl\n+# expand $ac_aux_dir to an absolute path\n+am_aux_dir=`cd $ac_aux_dir && pwd`\n+])\n+\n+# AM_CONDITIONAL                                            -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 9\n+\n+# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n+# -------------------------------------\n+# Define a conditional.\n+AC_DEFUN([AM_CONDITIONAL],\n+[AC_PREREQ(2.52)dnl\n+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n+\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n+AC_SUBST([$1_TRUE])dnl\n+AC_SUBST([$1_FALSE])dnl\n+_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n+_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n+m4_define([_AM_COND_VALUE_$1], [$2])dnl\n+if $2; then\n+  $1_TRUE=\n+  $1_FALSE='#'\n+else\n+  $1_TRUE='#'\n+  $1_FALSE=\n+fi\n+AC_CONFIG_COMMANDS_PRE(\n+[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n+  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n+Usually this means the macro was only invoked conditionally.]])\n+fi])])\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 10\n+\n+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n+# written in clear, in which case automake, when reading aclocal.m4,\n+# will think it sees a *use*, and therefore will trigger all it's\n+# C support machinery.  Also note that it means that autoscan, seeing\n+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n+\n+\n+# _AM_DEPENDENCIES(NAME)\n+# ----------------------\n+# See how the compiler implements dependency checking.\n+# NAME is \"CC\", \"CXX\", \"GCJ\", or \"OBJC\".\n+# We try a few techniques and use that to set a single cache variable.\n+#\n+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n+# dependency, and given that the user is not expected to run this macro,\n+# just rely on AC_PROG_CC.\n+AC_DEFUN([_AM_DEPENDENCIES],\n+[AC_REQUIRE([AM_SET_DEPDIR])dnl\n+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\n+AC_REQUIRE([AM_MAKE_INCLUDE])dnl\n+AC_REQUIRE([AM_DEP_TRACK])dnl\n+\n+ifelse([$1], CC,   [depcc=\"$CC\"   am_compiler_list=],\n+       [$1], CXX,  [depcc=\"$CXX\"  am_compiler_list=],\n+       [$1], OBJC, [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n+       [$1], UPC,  [depcc=\"$UPC\"  am_compiler_list=],\n+       [$1], GCJ,  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n+                   [depcc=\"$$1\"   am_compiler_list=])\n+\n+AC_CACHE_CHECK([dependency style of $depcc],\n+               [am_cv_$1_dependencies_compiler_type],\n+[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n+  # We make a subdir and do the tests there.  Otherwise we can end up\n+  # making bogus files that we don't know about and never remove.  For\n+  # instance it was reported that on HP-UX the gcc test will end up\n+  # making a dummy file named `D' -- because `-MD' means `put the output\n+  # in D'.\n+  mkdir conftest.dir\n+  # Copy depcomp to subdir because otherwise we won't find it if we're\n+  # using a relative directory.\n+  cp \"$am_depcomp\" conftest.dir\n+  cd conftest.dir\n+  # We will build objects and dependencies in a subdirectory because\n+  # it helps to detect inapplicable dependency modes.  For instance\n+  # both Tru64's cc and ICC support -MD to output dependencies as a\n+  # side effect of compilation, but ICC will put the dependencies in\n+  # the current directory while Tru64 will put them in the object\n+  # directory.\n+  mkdir sub\n+\n+  am_cv_$1_dependencies_compiler_type=none\n+  if test \"$am_compiler_list\" = \"\"; then\n+     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n+  fi\n+  am__universal=false\n+  m4_case([$1], [CC],\n+    [case \" $depcc \" in #(\n+     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n+     esac],\n+    [CXX],\n+    [case \" $depcc \" in #(\n+     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n+     esac])\n+\n+  for depmode in $am_compiler_list; do\n+    # Setup a source with many dependencies, because some compilers\n+    # like to wrap large dependency lists on column 80 (with \\), and\n+    # we should not choose a depcomp mode which is confused by this.\n+    #\n+    # We need to recreate these files for each test, as the compiler may\n+    # overwrite some of them when testing with obscure command lines.\n+    # This happens at least with the AIX C compiler.\n+    : > sub/conftest.c\n+    for i in 1 2 3 4 5 6; do\n+      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n+      # Solaris 8's {/usr,}/bin/sh.\n+      touch sub/conftst$i.h\n+    done\n+    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n+\n+    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n+    # mode.  It turns out that the SunPro C++ compiler does not properly\n+    # handle `-M -o', and we need to detect this.  Also, some Intel\n+    # versions had trouble with output in subdirs\n+    am__obj=sub/conftest.${OBJEXT-o}\n+    am__minus_obj=\"-o $am__obj\"\n+    case $depmode in\n+    gcc)\n+      # This depmode causes a compiler race in universal mode.\n+      test \"$am__universal\" = false || continue\n+      ;;\n+    nosideeffect)\n+      # after this tag, mechanisms are not by side-effect, so they'll\n+      # only be used when explicitly requested\n+      if test \"x$enable_dependency_tracking\" = xyes; then\n+\tcontinue\n+      else\n+\tbreak\n+      fi\n+      ;;\n+    msvisualcpp | msvcmsys)\n+      # This compiler won't grok `-c -o', but also, the minuso test has\n+      # not run yet.  These depmodes are late enough in the game, and\n+      # so weak that their functioning should not be impacted.\n+      am__obj=conftest.${OBJEXT-o}\n+      am__minus_obj=\n+      ;;\n+    none) break ;;\n+    esac\n+    if depmode=$depmode \\\n+       source=sub/conftest.c object=$am__obj \\\n+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n+         >/dev/null 2>conftest.err &&\n+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n+      # icc doesn't choke on unknown options, it will just issue warnings\n+      # or remarks (even with -Werror).  So we grep stderr for any message\n+      # that says an option was ignored or not supported.\n+      # When given -MP, icc 7.0 and 7.1 complain thusly:\n+      #   icc: Command line warning: ignoring option '-M'; no argument required\n+      # The diagnosis changed in icc 8.0:\n+      #   icc: Command line remark: option '-MP' not supported\n+      if (grep 'ignoring option' conftest.err ||\n+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n+        am_cv_$1_dependencies_compiler_type=$depmode\n+        break\n+      fi\n+    fi\n+  done\n+\n+  cd ..\n+  rm -rf conftest.dir\n+else\n+  am_cv_$1_dependencies_compiler_type=none\n+fi\n+])\n+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\n+AM_CONDITIONAL([am__fastdep$1], [\n+  test \"x$enable_dependency_tracking\" != xno \\\n+  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n+])\n+\n+\n+# AM_SET_DEPDIR\n+# -------------\n+# Choose a directory name for dependency files.\n+# This macro is AC_REQUIREd in _AM_DEPENDENCIES\n+AC_DEFUN([AM_SET_DEPDIR],\n+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n+])\n+\n+\n+# AM_DEP_TRACK\n+# ------------\n+AC_DEFUN([AM_DEP_TRACK],\n+[AC_ARG_ENABLE(dependency-tracking,\n+[  --disable-dependency-tracking  speeds up one-time build\n+  --enable-dependency-tracking   do not reject slow dependency extractors])\n+if test \"x$enable_dependency_tracking\" != xno; then\n+  am_depcomp=\"$ac_aux_dir/depcomp\"\n+  AMDEPBACKSLASH='\\'\n+fi\n+AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n+AC_SUBST([AMDEPBACKSLASH])dnl\n+_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\n+])\n+\n+# Generate code to set up dependency tracking.              -*- Autoconf -*-\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+#serial 5\n+\n+# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+# ------------------------------\n+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[{\n+  # Autoconf 2.62 quotes --file arguments for eval, but not when files\n+  # are listed without --file.  Let's play safe and only enable the eval\n+  # if we detect the quoting.\n+  case $CONFIG_FILES in\n+  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n+  *)   set x $CONFIG_FILES ;;\n+  esac\n+  shift\n+  for mf\n+  do\n+    # Strip MF so we end up with the name of the file.\n+    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n+    # Check whether this is an Automake generated Makefile or not.\n+    # We used to match only the files named `Makefile.in', but\n+    # some people rename them; so instead we look at the file content.\n+    # Grep'ing the first line is not enough: some people post-process\n+    # each Makefile.in and add a new line on top of each file to say so.\n+    # Grep'ing the whole file is not good either: AIX grep has a line\n+    # limit of 2048, but all sed's we know have understand at least 4000.\n+    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n+      dirpart=`AS_DIRNAME(\"$mf\")`\n+    else\n+      continue\n+    fi\n+    # Extract the definition of DEPDIR, am__include, and am__quote\n+    # from the Makefile without running `make'.\n+    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n+    test -z \"$DEPDIR\" && continue\n+    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n+    test -z \"am__include\" && continue\n+    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n+    # When using ansi2knr, U may be empty or an underscore; expand it\n+    U=`sed -n 's/^U = //p' < \"$mf\"`\n+    # Find all dependency output files, they are included files with\n+    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n+    # simplest approach to changing $(DEPDIR) to its actual value in the\n+    # expansion.\n+    for file in `sed -n \"\n+      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n+\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n+      # Make sure the directory exists.\n+      test -f \"$dirpart/$file\" && continue\n+      fdir=`AS_DIRNAME([\"$file\"])`\n+      AS_MKDIR_P([$dirpart/$fdir])\n+      # echo \"creating $dirpart/$file\"\n+      echo '# dummy' > \"$dirpart/$file\"\n+    done\n+  done\n+}\n+])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+\n+\n+# AM_OUTPUT_DEPENDENCY_COMMANDS\n+# -----------------------------\n+# This macro should only be invoked once -- use via AC_REQUIRE.\n+#\n+# This code is only required when automatic dependency tracking\n+# is enabled.  FIXME.  This creates each `.P' file that we will\n+# need in order to bootstrap the dependency handling code.\n+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[AC_CONFIG_COMMANDS([depfiles],\n+     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n+     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n+])\n+\n+# Do all the work for Automake.                             -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 16\n+\n+# This macro actually does too much.  Some checks are only needed if\n+# your package does certain things.  But this isn't really a big deal.\n+\n+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n+# AM_INIT_AUTOMAKE([OPTIONS])\n+# -----------------------------------------------\n+# The call with PACKAGE and VERSION arguments is the old style\n+# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n+# and VERSION should now be passed to AC_INIT and removed from\n+# the call to AM_INIT_AUTOMAKE.\n+# We support both call styles for the transition.  After\n+# the next Automake release, Autoconf can make the AC_INIT\n+# arguments mandatory, and then we can depend on a new Autoconf\n+# release and drop the old call support.\n+AC_DEFUN([AM_INIT_AUTOMAKE],\n+[AC_PREREQ([2.62])dnl\n+dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n+dnl the ones we care about.\n+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n+AC_REQUIRE([AC_PROG_INSTALL])dnl\n+if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n+  # is not polluted with repeated \"-I.\"\n+  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n+  # test to see if srcdir already configured\n+  if test -f $srcdir/config.status; then\n+    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n+  fi\n+fi\n+\n+# test whether we have cygpath\n+if test -z \"$CYGPATH_W\"; then\n+  if (cygpath --version) >/dev/null 2>/dev/null; then\n+    CYGPATH_W='cygpath -w'\n+  else\n+    CYGPATH_W=echo\n+  fi\n+fi\n+AC_SUBST([CYGPATH_W])\n+\n+# Define the identity of the package.\n+dnl Distinguish between old-style and new-style calls.\n+m4_ifval([$2],\n+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n+ AC_SUBST([PACKAGE], [$1])dnl\n+ AC_SUBST([VERSION], [$2])],\n+[_AM_SET_OPTIONS([$1])dnl\n+dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n+m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n+  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n+\n+_AM_IF_OPTION([no-define],,\n+[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n+ AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n+\n+# Some tools Automake needs.\n+AC_REQUIRE([AM_SANITY_CHECK])dnl\n+AC_REQUIRE([AC_ARG_PROGRAM])dnl\n+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\n+AM_MISSING_PROG(AUTOCONF, autoconf)\n+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n+AM_MISSING_PROG(AUTOHEADER, autoheader)\n+AM_MISSING_PROG(MAKEINFO, makeinfo)\n+AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n+AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n+# We need awk for the \"check\" target.  The system \"awk\" is bad on\n+# some platforms.\n+AC_REQUIRE([AC_PROG_AWK])dnl\n+AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n+AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n+\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n+\t\t\t     [_AM_PROG_TAR([v7])])])\n+_AM_IF_OPTION([no-dependencies],,\n+[AC_PROVIDE_IFELSE([AC_PROG_CC],\n+\t\t  [_AM_DEPENDENCIES(CC)],\n+\t\t  [define([AC_PROG_CC],\n+\t\t\t  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_CXX],\n+\t\t  [_AM_DEPENDENCIES(CXX)],\n+\t\t  [define([AC_PROG_CXX],\n+\t\t\t  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n+\t\t  [_AM_DEPENDENCIES(OBJC)],\n+\t\t  [define([AC_PROG_OBJC],\n+\t\t\t  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n+])\n+_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl\n+dnl The `parallel-tests' driver may need to know about EXEEXT, so add the\n+dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro\n+dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.\n+AC_CONFIG_COMMANDS_PRE(dnl\n+[m4_provide_if([_AM_COMPILER_EXEEXT],\n+  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n+])\n+\n+dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n+dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n+dnl mangled by Autoconf and run in a shell conditional statement.\n+m4_define([_AC_COMPILER_EXEEXT],\n+m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n+\n+\n+# When config.status generates a header, we must update the stamp-h file.\n+# This file resides in the same directory as the config header\n+# that is generated.  The stamp files are numbered to have different names.\n+\n+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n+# loop where config.status creates the headers, so we can generate\n+# our stamp files there.\n+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n+[# Compute $1's index in $config_headers.\n+_am_arg=$1\n+_am_stamp_count=1\n+for _am_header in $config_headers :; do\n+  case $_am_header in\n+    $_am_arg | $_am_arg:* )\n+      break ;;\n+    * )\n+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n+  esac\n+done\n+echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n+\n+# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_SH\n+# ------------------\n+# Define $install_sh.\n+AC_DEFUN([AM_PROG_INSTALL_SH],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+if test x\"${install_sh}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n+  *)\n+    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n+  esac\n+fi\n+AC_SUBST(install_sh)])\n+\n+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n+# From Jim Meyering\n+\n+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_MAINTAINER_MODE([DEFAULT-MODE])\n+# ----------------------------------\n+# Control maintainer-specific portions of Makefiles.\n+# Default is to disable them, unless `enable' is passed literally.\n+# For symmetry, `disable' may be passed as well.  Anyway, the user\n+# can override the default with the --enable/--disable switch.\n+AC_DEFUN([AM_MAINTAINER_MODE],\n+[m4_case(m4_default([$1], [disable]),\n+       [enable], [m4_define([am_maintainer_other], [disable])],\n+       [disable], [m4_define([am_maintainer_other], [enable])],\n+       [m4_define([am_maintainer_other], [enable])\n+        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n+AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])\n+  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n+  AC_ARG_ENABLE([maintainer-mode],\n+[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful\n+\t\t\t  (and sometimes confusing) to the casual installer],\n+      [USE_MAINTAINER_MODE=$enableval],\n+      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n+  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n+  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n+  MAINT=$MAINTAINER_MODE_TRUE\n+  AC_SUBST([MAINT])dnl\n+]\n+)\n+\n+AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])\n+\n+# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# AM_MAKE_INCLUDE()\n+# -----------------\n+# Check to see how make treats includes.\n+AC_DEFUN([AM_MAKE_INCLUDE],\n+[am_make=${MAKE-make}\n+cat > confinc << 'END'\n+am__doit:\n+\t@echo this is the am__doit target\n+.PHONY: am__doit\n+END\n+# If we don't find an include directive, just comment out the code.\n+AC_MSG_CHECKING([for style of include used by $am_make])\n+am__include=\"#\"\n+am__quote=\n+_am_result=none\n+# First try GNU make style include.\n+echo \"include confinc\" > confmf\n+# Ignore all kinds of additional output from `make'.\n+case `$am_make -s -f confmf 2> /dev/null` in #(\n+*the\\ am__doit\\ target*)\n+  am__include=include\n+  am__quote=\n+  _am_result=GNU\n+  ;;\n+esac\n+# Now try BSD make style include.\n+if test \"$am__include\" = \"#\"; then\n+   echo '.include \"confinc\"' > confmf\n+   case `$am_make -s -f confmf 2> /dev/null` in #(\n+   *the\\ am__doit\\ target*)\n+     am__include=.include\n+     am__quote=\"\\\"\"\n+     _am_result=BSD\n+     ;;\n+   esac\n+fi\n+AC_SUBST([am__include])\n+AC_SUBST([am__quote])\n+AC_MSG_RESULT([$_am_result])\n+rm -f confinc confmf\n+])\n+\n+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 6\n+\n+# AM_MISSING_PROG(NAME, PROGRAM)\n+# ------------------------------\n+AC_DEFUN([AM_MISSING_PROG],\n+[AC_REQUIRE([AM_MISSING_HAS_RUN])\n+$1=${$1-\"${am_missing_run}$2\"}\n+AC_SUBST($1)])\n+\n+\n+# AM_MISSING_HAS_RUN\n+# ------------------\n+# Define MISSING if not defined so far and test if it supports --run.\n+# If it does, set am_missing_run to use it, otherwise, to nothing.\n+AC_DEFUN([AM_MISSING_HAS_RUN],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+AC_REQUIRE_AUX_FILE([missing])dnl\n+if test x\"${MISSING+set}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n+  *)\n+    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n+  esac\n+fi\n+# Use eval to expand $SHELL\n+if eval \"$MISSING --run true\"; then\n+  am_missing_run=\"$MISSING --run \"\n+else\n+  am_missing_run=\n+  AC_MSG_WARN([`missing' script is too old or missing])\n+fi\n+])\n+\n+# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_MKDIR_P\n+# ---------------\n+# Check for `mkdir -p'.\n+AC_DEFUN([AM_PROG_MKDIR_P],\n+[AC_PREREQ([2.60])dnl\n+AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n+dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\n+dnl while keeping a definition of mkdir_p for backward compatibility.\n+dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\n+dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\n+dnl Makefile.ins that do not define MKDIR_P, so we do our own\n+dnl adjustment using top_builddir (which is defined more often than\n+dnl MKDIR_P).\n+AC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\n+case $mkdir_p in\n+  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n+  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\n+esac\n+])\n+\n+# Helper functions for option handling.                     -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# _AM_MANGLE_OPTION(NAME)\n+# -----------------------\n+AC_DEFUN([_AM_MANGLE_OPTION],\n+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n+\n+# _AM_SET_OPTION(NAME)\n+# ------------------------------\n+# Set option NAME.  Presently that only means defining a flag for this option.\n+AC_DEFUN([_AM_SET_OPTION],\n+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n+\n+# _AM_SET_OPTIONS(OPTIONS)\n+# ----------------------------------\n+# OPTIONS is a space-separated list of Automake options.\n+AC_DEFUN([_AM_SET_OPTIONS],\n+[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n+\n+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n+# -------------------------------------------\n+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n+AC_DEFUN([_AM_IF_OPTION],\n+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n+\n+# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_SANITY_CHECK\n+# ---------------\n+AC_DEFUN([AM_SANITY_CHECK],\n+[AC_MSG_CHECKING([whether build environment is sane])\n+# Just in case\n+sleep 1\n+echo timestamp > conftest.file\n+# Reject unsafe characters in $srcdir or the absolute working directory\n+# name.  Accept space and tab only in the latter.\n+am_lf='\n+'\n+case `pwd` in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n+    AC_MSG_ERROR([unsafe absolute working directory name]);;\n+esac\n+case $srcdir in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n+    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;\n+esac\n+\n+# Do `set' in a subshell so we don't clobber the current shell's\n+# arguments.  Must try -L first in case configure is actually a\n+# symlink; some systems play weird games with the mod time of symlinks\n+# (eg FreeBSD returns the mod time of the symlink's containing\n+# directory).\n+if (\n+   set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n+   if test \"$[*]\" = \"X\"; then\n+      # -L didn't work.\n+      set X `ls -t \"$srcdir/configure\" conftest.file`\n+   fi\n+   rm -f conftest.file\n+   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n+      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n+\n+      # If neither matched, then we have a broken ls.  This can happen\n+      # if, for instance, CONFIG_SHELL is bash and it inherits a\n+      # broken ls alias from the environment.  This has actually\n+      # happened.  Such a system could not be considered \"sane\".\n+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n+alias in your environment])\n+   fi\n+\n+   test \"$[2]\" = conftest.file\n+   )\n+then\n+   # Ok.\n+   :\n+else\n+   AC_MSG_ERROR([newly created file is older than distributed files!\n+Check your system clock])\n+fi\n+AC_MSG_RESULT(yes)])\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_STRIP\n+# ---------------------\n+# One issue with vendor `install' (even GNU) is that you can't\n+# specify the program used to strip binaries.  This is especially\n+# annoying in cross-compiling environments, where the build's strip\n+# is unlikely to handle the host's binaries.\n+# Fortunately install-sh will honor a STRIPPROG variable, so we\n+# always use install-sh in `make install-strip', and initialize\n+# STRIPPROG with the value of the STRIP variable (set by the user).\n+AC_DEFUN([AM_PROG_INSTALL_STRIP],\n+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+# Installed binaries are usually stripped using `strip' when the user\n+# run `make install-strip'.  However `strip' might not be the right\n+# tool to use in cross-compilation environments, therefore Automake\n+# will honor the `STRIP' environment variable to overrule this program.\n+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.\n+if test \"$cross_compiling\" != no; then\n+  AC_CHECK_TOOL([STRIP], [strip], :)\n+fi\n+INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n+AC_SUBST([INSTALL_STRIP_PROGRAM])])\n+\n+# Copyright (C) 2006, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n+# This macro is traced by Automake.\n+AC_DEFUN([_AM_SUBST_NOTMAKE])\n+\n+# AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Public sister of _AM_SUBST_NOTMAKE.\n+AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n+\n+# Check how to create a tarball.                            -*- Autoconf -*-\n+\n+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_PROG_TAR(FORMAT)\n+# --------------------\n+# Check how to create a tarball in format FORMAT.\n+# FORMAT should be one of `v7', `ustar', or `pax'.\n+#\n+# Substitute a variable $(am__tar) that is a command\n+# writing to stdout a FORMAT-tarball containing the directory\n+# $tardir.\n+#     tardir=directory && $(am__tar) > result.tar\n+#\n+# Substitute a variable $(am__untar) that extract such\n+# a tarball read from stdin.\n+#     $(am__untar) < result.tar\n+AC_DEFUN([_AM_PROG_TAR],\n+[# Always define AMTAR for backward compatibility.\n+AM_MISSING_PROG([AMTAR], [tar])\n+m4_if([$1], [v7],\n+     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n+     [m4_case([$1], [ustar],, [pax],,\n+              [m4_fatal([Unknown tar format])])\n+AC_MSG_CHECKING([how to create a $1 tar archive])\n+# Loop over all known methods to create a tar archive until one works.\n+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n+_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n+# Do not fold the above two line into one, because Tru64 sh and\n+# Solaris sh will not grok spaces in the rhs of `-'.\n+for _am_tool in $_am_tools\n+do\n+  case $_am_tool in\n+  gnutar)\n+    for _am_tar in tar gnutar gtar;\n+    do\n+      AM_RUN_LOG([$_am_tar --version]) && break\n+    done\n+    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n+    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n+    am__untar=\"$_am_tar -xf -\"\n+    ;;\n+  plaintar)\n+    # Must skip GNU tar: if it does not support --format= it doesn't create\n+    # ustar tarball either.\n+    (tar --version) >/dev/null 2>&1 && continue\n+    am__tar='tar chf - \"$$tardir\"'\n+    am__tar_='tar chf - \"$tardir\"'\n+    am__untar='tar xf -'\n+    ;;\n+  pax)\n+    am__tar='pax -L -x $1 -w \"$$tardir\"'\n+    am__tar_='pax -L -x $1 -w \"$tardir\"'\n+    am__untar='pax -r'\n+    ;;\n+  cpio)\n+    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n+    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n+    am__untar='cpio -i -H $1 -d'\n+    ;;\n+  none)\n+    am__tar=false\n+    am__tar_=false\n+    am__untar=false\n+    ;;\n+  esac\n+\n+  # If the value was cached, stop now.  We just wanted to have am__tar\n+  # and am__untar set.\n+  test -n \"${am_cv_prog_tar_$1}\" && break\n+\n+  # tar/untar a dummy directory, and stop if the command works\n+  rm -rf conftest.dir\n+  mkdir conftest.dir\n+  echo GrepMe > conftest.dir/file\n+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n+  rm -rf conftest.dir\n+  if test -s conftest.tar; then\n+    AM_RUN_LOG([$am__untar <conftest.tar])\n+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n+  fi\n+done\n+rm -rf conftest.dir\n+\n+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n+AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n+AC_SUBST([am__tar])\n+AC_SUBST([am__untar])\n+]) # _AM_PROG_TAR\n+\n+m4_include([../config/depstand.m4])\n+m4_include([../config/lead-dot.m4])\n+m4_include([../config/multi.m4])\n+m4_include([../libtool.m4])\n+m4_include([../ltoptions.m4])\n+m4_include([../ltsugar.m4])\n+m4_include([../ltversion.m4])\n+m4_include([../lt~obsolete.m4])"}, {"sha": "9dd4110809e6a6ab7c31e280d4713230000c1931", "filename": "libhsail-rt/config.h.in", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Fconfig.h.in?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,217 @@\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define if building universal (internal helper macro) */\n+#undef AC_APPLE_UNIVERSAL_BUILD\n+\n+/* Define to 1 if you have the `acosl' function. */\n+#undef HAVE_ACOSL\n+\n+/* Define to 1 if you have the `asinl' function. */\n+#undef HAVE_ASINL\n+\n+/* Define to 1 if you have the `atan2l' function. */\n+#undef HAVE_ATAN2L\n+\n+/* Define to 1 if you have the `atanl' function. */\n+#undef HAVE_ATANL\n+\n+/* Define to 1 if you have the `cosl' function. */\n+#undef HAVE_COSL\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#undef HAVE_DLFCN_H\n+\n+/* Define to 1 if you have the `expl' function. */\n+#undef HAVE_EXPL\n+\n+/* Define to 1 if you have the `expm1l' function. */\n+#undef HAVE_EXPM1L\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#undef HAVE_INTTYPES_H\n+\n+/* Define to 1 if you have the `ldexpl' function. */\n+#undef HAVE_LDEXPL\n+\n+/* Define to 1 if you have the <linux/ether.h> header file. */\n+#undef HAVE_LINUX_ETHER_H\n+\n+/* Define to 1 if you have the <linux/fs.h> header file. */\n+#undef HAVE_LINUX_FS_H\n+\n+/* Define to 1 if you have the <linux/reboot.h> header file. */\n+#undef HAVE_LINUX_REBOOT_H\n+\n+/* Define to 1 if you have the `log10l' function. */\n+#undef HAVE_LOG10L\n+\n+/* Define to 1 if you have the `log1pl' function. */\n+#undef HAVE_LOG1PL\n+\n+/* Define to 1 if you have the `logl' function. */\n+#undef HAVE_LOGL\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#undef HAVE_MEMORY_H\n+\n+/* Define to 1 if you have the <netinet/icmp6.h> header file. */\n+#undef HAVE_NETINET_ICMP6_H\n+\n+/* Define to 1 if you have the <netinet/if_ether.h> header file. */\n+#undef HAVE_NETINET_IF_ETHER_H\n+\n+/* Define to 1 if you have the <netinet/in_syst.h> header file. */\n+#undef HAVE_NETINET_IN_SYST_H\n+\n+/* Define to 1 if you have the <netinet/ip.h> header file. */\n+#undef HAVE_NETINET_IP_H\n+\n+/* Define to 1 if you have the <netinet/ip_mroute.h> header file. */\n+#undef HAVE_NETINET_IP_MROUTE_H\n+\n+/* Define to 1 if you have the <netpacket/packet.h> header file. */\n+#undef HAVE_NETPACKET_PACKET_H\n+\n+/* Define to 1 if you have the <net/if_arp.h> header file. */\n+#undef HAVE_NET_IF_ARP_H\n+\n+/* Define to 1 if you have the <net/if.h> header file. */\n+#undef HAVE_NET_IF_H\n+\n+/* Define to 1 if you have the <net/route.h> header file. */\n+#undef HAVE_NET_ROUTE_H\n+\n+/* Define to 1 if you have the <sched.h> header file. */\n+#undef HAVE_SCHED_H\n+\n+/* Define to 1 if you have the `sinl' function. */\n+#undef HAVE_SINL\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#undef HAVE_STDINT_H\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#undef HAVE_STDLIB_H\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#undef HAVE_STRINGS_H\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#undef HAVE_STRING_H\n+\n+/* Define to 1 if the compiler provides the __sync_bool_compare_and_swap\n+   function for uint32 */\n+#undef HAVE_SYNC_BOOL_COMPARE_AND_SWAP_4\n+\n+/* Define to 1 if the compiler provides the __sync_bool_compare_and_swap\n+   function for uint64 */\n+#undef HAVE_SYNC_BOOL_COMPARE_AND_SWAP_8\n+\n+/* Define to 1 if you have the <syscall.h> header file. */\n+#undef HAVE_SYSCALL_H\n+\n+/* Define to 1 if you have the <sys/epoll.h> header file. */\n+#undef HAVE_SYS_EPOLL_H\n+\n+/* Define to 1 if you have the <sys/file.h> header file. */\n+#undef HAVE_SYS_FILE_H\n+\n+/* Define to 1 if you have the <sys/inotify.h> header file. */\n+#undef HAVE_SYS_INOTIFY_H\n+\n+/* Define to 1 if you have the <sys/mman.h> header file. */\n+#undef HAVE_SYS_MMAN_H\n+\n+/* Define to 1 if you have the <sys/mount.h> header file. */\n+#undef HAVE_SYS_MOUNT_H\n+\n+/* Define to 1 if you have the <sys/prctl.h> header file. */\n+#undef HAVE_SYS_PRCTL_H\n+\n+/* Define to 1 if you have the <sys/ptrace.h> header file. */\n+#undef HAVE_SYS_PTRACE_H\n+\n+/* Define to 1 if you have the <sys/select.h> header file. */\n+#undef HAVE_SYS_SELECT_H\n+\n+/* Define to 1 if you have the <sys/socket.h> header file. */\n+#undef HAVE_SYS_SOCKET_H\n+\n+/* Define to 1 if you have the <sys/statfs.h> header file. */\n+#undef HAVE_SYS_STATFS_H\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#undef HAVE_SYS_STAT_H\n+\n+/* Define to 1 if you have the <sys/syscall.h> header file. */\n+#undef HAVE_SYS_SYSCALL_H\n+\n+/* Define to 1 if you have the <sys/sysinfo.h> header file. */\n+#undef HAVE_SYS_SYSINFO_H\n+\n+/* Define to 1 if you have the <sys/timex.h> header file. */\n+#undef HAVE_SYS_TIMEX_H\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#undef HAVE_SYS_TYPES_H\n+\n+/* Define to 1 if you have the <sys/user.h> header file. */\n+#undef HAVE_SYS_USER_H\n+\n+/* Define to 1 if you have the <sys/utsname.h> header file. */\n+#undef HAVE_SYS_UTSNAME_H\n+\n+/* Define to 1 if you have the <sys/vfs.h> header file. */\n+#undef HAVE_SYS_VFS_H\n+\n+/* Define to 1 if you have the `tanl' function. */\n+#undef HAVE_TANL\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#undef HAVE_UNISTD_H\n+\n+/* Define to 1 if you have the <utime.h> header file. */\n+#undef HAVE_UTIME_H\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#undef LT_OBJDIR\n+\n+/* Name of package */\n+#undef PACKAGE\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#undef PACKAGE_BUGREPORT\n+\n+/* Define to the full name of this package. */\n+#undef PACKAGE_NAME\n+\n+/* Define to the full name and version of this package. */\n+#undef PACKAGE_STRING\n+\n+/* Define to the one symbol short name of this package. */\n+#undef PACKAGE_TARNAME\n+\n+/* Define to the home page for this package. */\n+#undef PACKAGE_URL\n+\n+/* Define to the version of this package. */\n+#undef PACKAGE_VERSION\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#undef STDC_HEADERS\n+\n+/* Version number of package */\n+#undef VERSION\n+\n+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n+   significant byte first (like Motorola and SPARC, unlike Intel). */\n+#if defined AC_APPLE_UNIVERSAL_BUILD\n+# if defined __BIG_ENDIAN__\n+#  define WORDS_BIGENDIAN 1\n+# endif\n+#else\n+# ifndef WORDS_BIGENDIAN\n+#  undef WORDS_BIGENDIAN\n+# endif\n+#endif"}, {"sha": "0c10830bf3e64d67c47993a1a458c1ec4e071f40", "filename": "libhsail-rt/configure", "status": "added", "additions": 17016, "deletions": 0, "changes": 17016, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Fconfigure?ref=5fd1486ce58297190c2b924e96e716087139a8b5"}, {"sha": "796e1096df3b0f1334f192827d85e0af5fd2f09a", "filename": "libhsail-rt/configure.ac", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Fconfigure.ac?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,151 @@\n+# Starting point copied from libcilkrts:\n+#\n+#  @copyright\n+#  Copyright (C) 2011-2013, Intel Corporation\n+#  All rights reserved.\n+#\n+#  @copyright\n+#  Redistribution and use in source and binary forms, with or without\n+#  modification, are permitted provided that the following conditions\n+#  are met:\n+#\n+#    * Redistributions of source code must retain the above copyright\n+#      notice, this list of conditions and the following disclaimer.\n+#    * Redistributions in binary form must reproduce the above copyright\n+#      notice, this list of conditions and the following disclaimer in\n+#      the documentation and/or other materials provided with the\n+#      distribution.\n+#    * Neither the name of Intel Corporation nor the names of its\n+#      contributors may be used to endorse or promote products derived\n+#      from this software without specific prior written permission.\n+#\n+#  @copyright\n+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+#  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+#  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+#  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+#  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+#  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+#  POSSIBILITY OF SUCH DAMAGE.\n+\n+AC_INIT([phsa HSAIL runtime library], [1.0], [pekka.jaaskelainen@parmance.com])\n+AC_CONFIG_MACRO_DIR([m4])\n+\n+AC_PREREQ([2.64])\n+\n+# Needed to define ${target}.  Needs to be very early to avoid annoying\n+# warning about calling AC_ARG_PROGRAM before AC_CANONICAL_SYSTEM\n+AC_CANONICAL_SYSTEM\n+target_alias=${target_alias-$host_alias}\n+AC_SUBST(target_alias)\n+AM_INIT_AUTOMAKE([1.11.6 foreign no-dist])\n+\n+AM_MAINTAINER_MODE\n+\n+AC_PROG_CC\n+AC_PROG_CXX\n+# AC_PROG_LIBTOOL\n+AC_CONFIG_FILES([Makefile])\n+\n+if test \"${multilib}\" = \"yes\"; then\n+  multilib_arg=\"--enable-multilib\"\n+else\n+  multilib_arg=\n+fi\n+\n+AC_MSG_CHECKING([for --enable-version-specific-runtime-libs])\n+AC_ARG_ENABLE([version-specific-runtime-libs],\n+  AC_HELP_STRING([--enable-version-specific-runtime-libs],\n+                 [Specify that runtime libraries should be installed in a compi\n+ler-specific directory]),\n+  [case \"$enableval\" in\n+    yes) enable_version_specific_runtime_libs=yes ;;\n+    no)  enable_version_specific_runtime_libs=no ;;\n+    *)   AC_MSG_ERROR([Unknown argument to enable/disable version-specific libs\n+]);;\n+   esac],\n+  [enable_version_specific_runtime_libs=no])\n+AC_MSG_RESULT($enable_version_specific_runtime_libs)\n+\n+# Calculate toolexeclibdir\n+# Also toolexecdir, though it's only used in toolexeclibdir\n+case ${enable_version_specific_runtime_libs} in\n+  yes)\n+    # Need the gcc compiler version to know where to install libraries\n+    # and header files if --enable-version-specific-runtime-libs option\n+    # is selected.\n+    toolexecdir='$(libdir)/gcc/$(target_alias)'\n+    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'\n+    ;;\n+  no)\n+    if test -n \"$with_cross_host\" &&\n+       test x\"$with_cross_host\" != x\"no\"; then\n+      # Install a library built with a cross compiler in tooldir, not libdir.\n+      toolexecdir='$(exec_prefix)/$(target_alias)'\n+      toolexeclibdir='$(toolexecdir)/lib'\n+    else\n+      toolexecdir='$(libdir)/gcc-lib/$(target_alias)'\n+      toolexeclibdir='$(libdir)'\n+    fi\n+    multi_os_directory=`$CC -print-multi-os-directory`\n+    case $multi_os_directory in\n+      .) ;; # Avoid trailing /.\n+      *) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;\n+    esac\n+    ;;\n+esac\n+\n+# Set config_dir based on the target.  config_dir specifies where to get\n+# target-specific files.  The generic implementation is incomplete, but\n+# contains information on what's needed\n+case \"${target}\" in\n+\n+  x86_64-*-*)\n+    config_dir=\"x86\"\n+    ;;\n+\n+  i?86-*-*)\n+    config_dir=\"x86\"\n+    ;;\n+\n+  *)\n+    config_dir=\"generic\"\n+    ;;\n+\n+esac\n+AC_SUBST(config_dir)\n+\n+# We have linker scripts for appropriate operating systems\n+linux_linker_script=no\n+case \"${host}\" in\n+    *-*-linux*)\n+        linux_linker_script=yes\n+        ;;\n+esac\n+AM_CONDITIONAL(LINUX_LINKER_SCRIPT, test \"$linux_linker_script\" = \"yes\")\n+\n+mac_linker_script=no\n+case \"${host}\" in\n+    *-*-apple*)\n+        mac_linker_script=yes\n+        ;;\n+esac\n+AM_CONDITIONAL(MAC_LINKER_SCRIPT, test \"$mac_linker_script\" = \"yes\")\n+\n+AC_LIBTOOL_DLOPEN\n+AM_PROG_LIBTOOL\n+AC_SUBST(toolexecdir)\n+AC_SUBST(toolexeclibdir)\n+\n+AC_CONFIG_HEADER(target-config.h)\n+\n+AC_CHECK_SIZEOF([int])\n+AC_CHECK_SIZEOF([void*])\n+\n+# Must be last\n+AC_OUTPUT"}, {"sha": "033146c7b1cc63b9f19a4b5129bedc0571ddb433", "filename": "libhsail-rt/include/internal/fibers.h", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Finclude%2Finternal%2Ffibers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Finclude%2Finternal%2Ffibers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Finclude%2Finternal%2Ffibers.h?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,99 @@\n+/* fibers.h -- an extremely simple lightweight thread (fiber) implementation\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining a\n+   copy of this software and associated documentation files\n+   (the \"Software\"), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+   USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#ifndef PHSA_RT_FIBERS_H\n+#define PHSA_RT_FIBERS_H\n+\n+#include <ucontext.h>\n+\n+typedef enum\n+{\n+  /* Ready to run.  */\n+  FIBER_STATUS_READY,\n+  /* Exited by calling fiber_thread_exit.  */\n+  FIBER_STATUS_EXITED,\n+  /* Joined by the main thread.  */\n+  FIBER_STATUS_JOINED\n+} fiber_status_t;\n+\n+/* A light weight thread (fiber).  */\n+struct fiber_s\n+{\n+  ucontext_t context;\n+  volatile fiber_status_t status;\n+  struct fiber_s *next;\n+  struct fiber_s *prev;\n+};\n+\n+typedef struct fiber_s fiber_t;\n+\n+typedef void (*fiber_function_t)(int, int);\n+\n+/* Initializes the fiber with the start function given as the first\n+   argument, and the argument to pass to the start function,\n+   as the second.  The allocated stack size is given as the last argument.  */\n+void\n+fiber_init (fiber_t *fiber, fiber_function_t start_function, void *arg,\n+\t    size_t stack_size, size_t stack_align);\n+\n+/* Terminates the fiber execution from within the fiber itself.  */\n+void\n+fiber_exit ();\n+\n+/* Blocks until the given fiber returns.  Frees the resources allocated\n+   for the fiber.  After join returns, the fiber itself can be deleted.  */\n+void\n+fiber_join (fiber_t *fiber);\n+\n+/* Co-operatively transfer execution turn to other fibers.  */\n+void\n+fiber_yield ();\n+\n+/* A multi-entry barrier.  After the last fiber has reached the\n+   barrier, it is automatically re-initialized to the threshold.  */\n+typedef struct\n+{\n+  /* The barrier participant count.  */\n+  volatile size_t threshold;\n+  /* Number of fibers that have reached the barrier.  */\n+  volatile size_t reached;\n+  /* Number of fibers that are waiting at the barrier.  */\n+  volatile size_t waiting_count;\n+} fiber_barrier_t;\n+\n+/* Reach the given barrier.  Blocks (co-operatively switches the execution\n+   fibers) until all other parties have reached it.  Returns 0 only in case\n+   the calling fiber was the first one to return from the barrier.  */\n+size_t\n+fiber_barrier_reach (fiber_barrier_t *barrier);\n+\n+/* Initializes the given barrier.  */\n+void\n+fiber_barrier_init (fiber_barrier_t *barrier, size_t threshold);\n+\n+void *\n+fiber_int_args_to_ptr (int arg0, int arg1);\n+\n+#endif"}, {"sha": "646cee4eb55fef9143d6b2d2be860fc73c376811", "filename": "libhsail-rt/include/internal/phsa-queue-interface.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Finclude%2Finternal%2Fphsa-queue-interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Finclude%2Finternal%2Fphsa-queue-interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Finclude%2Finternal%2Fphsa-queue-interface.h?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,60 @@\n+/* phsa_queue_interface.h -- Definition for a minimalistic generic in-memory\n+   representation of a user mode queue to be used with the phsa/gccbrig\n+   implementation.\n+\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining a\n+   copy of this software and associated documentation files\n+   (the \"Software\"), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+   USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#ifndef PHSA_QUEUE_INTERFACE_H\n+#define PHSA_QUEUE_INTERFACE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include \"hsa.h\"\n+\n+typedef __attribute__ ((aligned (64))) struct phsa_queue_s\n+{\n+  /* An HSA Architectured Queue object.  Must be in the beginning\n+     of the struct to enable direct pointer casting between hsa_queue_\n+     and phsa_queue_t.  */\n+  hsa_queue_t hsa_queue;\n+\n+  volatile uint64_t write_index;\n+  volatile uint64_t read_index;\n+\n+  /* True if global mem addresses are 64b.  */\n+  uint64_t is_ptr64 : 1;\n+\n+} phsa_queue_t;\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"}, {"sha": "40813cb9c239804c817bad82fabe00e97b6a695b", "filename": "libhsail-rt/include/internal/phsa-rt.h", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Finclude%2Finternal%2Fphsa-rt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Finclude%2Finternal%2Fphsa-rt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Finclude%2Finternal%2Fphsa-rt.h?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,94 @@\n+/* phsa-rt.h -- Data structures and functions of the PHSA device side runtime\n+   scheduler, and HSAIL built-ins.\n+\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining a\n+   copy of this software and associated documentation files\n+   (the \"Software\"), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+   USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#ifndef PHSA_RT_H\n+#define PHSA_RT_H\n+\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include \"hsa.h\"\n+\n+#define PHSA_MAX_WG_SIZE 1024 * 10\n+\n+/* Pointer type for the public facing kernel launcher function generated\n+   by gccbrig.  This launches the actual kernel for all work groups and\n+   work items in the grid.  */\n+typedef void (*gccbrigKernelLauncherFunc) (void *context, void *);\n+\n+/* Pointer type for kernel functions produced by gccbrig from the HSAIL.\n+   This is private from outside the device binary and only called by\n+   the launcher.  */\n+typedef void (*gccbrigKernelFunc) (unsigned char *, void *, void *, void *);\n+\n+/* Context data that is passed to the kernel function, initialized\n+   by the runtime to the current launch information.  The data is\n+   used by different id functions etc.\n+\n+   The struct is used by both the launcher and the targeted device,\n+   thus the fields must have the same alignment/padding in both sides.\n+*/\n+typedef struct\n+{\n+\n+  /* Data set by the HSA Runtime's kernel launcher.  */\n+  hsa_kernel_dispatch_packet_t *dp;\n+\n+  size_t packet_id;\n+\n+  /* Data set by the device-side launcher.  */\n+  gccbrigKernelFunc kernel;\n+\n+  /* The range of a work groups this dispatch should execute.  */\n+  size_t wg_min_x;\n+  size_t wg_min_y;\n+  size_t wg_min_z;\n+\n+  size_t wg_max_x;\n+  size_t wg_max_y;\n+  size_t wg_max_z;\n+\n+  /* The barrier used to synch the work-items before executing a new WG.  */\n+  void *wg_start_barrier;\n+\n+  /* The barrier to wait at after executing a work-group.  */\n+  void *wg_completion_barrier;\n+\n+  /* The barrier used to synchronize WIs in case of the 'barrier' HSAIL\n+     instruction.  */\n+  void *wg_sync_barrier;\n+\n+  /* This should be set to the flat address of the beginning of the group\n+     segment.  */\n+  size_t group_segment_start_addr;\n+\n+  /* This must be set to the correct aligned flat address space location from\n+     where the kernel can actually read its arguments.  Might point to the\n+     original global kernarg space.  */\n+  void *kernarg_addr;\n+} PHSAKernelLaunchData;\n+\n+#endif"}, {"sha": "6c96b2e4d26aa9ba7391346a2762663e486fa2c3", "filename": "libhsail-rt/include/internal/workitems.h", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Finclude%2Finternal%2Fworkitems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Finclude%2Finternal%2Fworkitems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Finclude%2Finternal%2Fworkitems.h?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,107 @@\n+/* workitems.h -- Types for context data passed as hidden parameters to special\n+   built-ins.\n+\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining a\n+   copy of this software and associated documentation files\n+   (the \"Software\"), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+   USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#ifndef PHSA_RT_WORKITEMS_H\n+#define PHSA_RT_WORKITEMS_H\n+\n+/* As the simple fibers implementation relies only on ucontext, we can\n+   assume is found by default as it is part of glibc.  However, for partial\n+   HSAIL support on platforms without having it available, the following define\n+   can be undefined.  */\n+#define HAVE_FIBERS\n+\n+#ifdef HAVE_FIBERS\n+#include \"fibers.h\"\n+#endif\n+\n+#include <stdint.h>\n+#include \"phsa-rt.h\"\n+\n+/* Data identifying a single work-group instance.  */\n+\n+typedef struct\n+{\n+  /* The group id of the currently executed WG.  */\n+  size_t x;\n+  size_t y;\n+  size_t z;\n+\n+  /* This is 1 in case there are more work groups to execute.\n+     If 0, the work-item threads should finish themselves.  */\n+  int more_wgs;\n+\n+  /* If the local size does not evenly divide the grid size, will have\n+     leftover WIs in the last execution.  */\n+  int leftover_wg;\n+  int last_wg;\n+\n+  /* (Flat) pointer to the beginning of the group segment allocated\n+     to the work-group.  */\n+  void *group_base_ptr;\n+\n+  /* Similarly to the private segment that gets space allocated for all\n+     WIs in the work-group.  */\n+  void *private_base_ptr;\n+  uint32_t private_segment_total_size;\n+\n+  /* The first flat address of the group segment allocated for\n+     the given work group.  */\n+  uint64_t group_segment_base_addr;\n+\n+  /* Offset from the beginning of the private segment to the start of\n+     the previously allocated chunk of dynamic work-item memory (alloca)\n+     by any WI in the WG.\n+\n+     Initially set to private_segment_total_size to denote no dynamic\n+     allocations have been made.  The dynamic allocations are done downwards\n+     from the private segment end.  */\n+  uint32_t alloca_stack_p;\n+  /* The position of the first word in the current function's alloca\n+     stack frame.  Initialized to point outside the private segment.  */\n+  uint32_t alloca_frame_p;\n+\n+} PHSAWorkGroup;\n+\n+/* Data identifying a single work-item, passed to the work-item thread in case\n+   of a fiber based work-group execution.  */\n+\n+typedef struct\n+{\n+  PHSAKernelLaunchData *launch_data;\n+  /* Identifies and keeps book of the currently executed WG of the WI swarm.  */\n+  volatile PHSAWorkGroup *wg;\n+  /* The local id of the current WI.  */\n+  size_t x;\n+  size_t y;\n+  size_t z;\n+#ifdef HAVE_FIBERS\n+  fiber_t fiber;\n+#endif\n+} PHSAWorkItem;\n+\n+\n+#endif"}, {"sha": "6749752e6e9a85a00dc39ac5f0ffe00eab594487", "filename": "libhsail-rt/rt/arithmetic.c", "status": "added", "additions": 475, "deletions": 0, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Farithmetic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Farithmetic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Frt%2Farithmetic.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,475 @@\n+/* arithmetic.c -- Builtins for HSAIL arithmetic instructions for which\n+   there is no feasible direct gcc GENERIC expression.\n+\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining a\n+   copy of this software and associated documentation files\n+   (the \"Software\"), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+   USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#include <stdio.h>\n+#include <stdint.h>\n+#include <limits.h>\n+#include <math.h>\n+#include <float.h>\n+\n+/* HSAIL defines INT_MIN % -1 to be 0 while with C it's undefined,\n+   and causes an overflow exception at least with gcc and C on IA-32.  */\n+\n+int32_t\n+__hsail_rem_s32 (int32_t dividend, int32_t divisor)\n+{\n+  if (dividend == INT_MIN && divisor == -1)\n+    return 0;\n+  else\n+    return dividend % divisor;\n+}\n+\n+int64_t\n+__hsail_rem_s64 (int64_t dividend, int64_t divisor)\n+{\n+  if (dividend == INT64_MIN && divisor == -1)\n+    return 0;\n+  else\n+    return dividend % divisor;\n+}\n+\n+/* HSAIL has defined behavior for min and max when one of the operands is\n+   NaN: in that case the other operand is returned.  In C and with gcc's\n+   MIN_EXPR/MAX_EXPR, the returned operand is undefined.  */\n+\n+float\n+__hsail_min_f32 (float a, float b)\n+{\n+  if (isnan (a))\n+    return b;\n+  else if (isnan (b))\n+    return a;\n+  else if (a == 0.0f && b == 0.0f)\n+    return signbit (a) ? a : b;\n+  else if (a > b)\n+    return b;\n+  else\n+    return a;\n+}\n+\n+double\n+__hsail_min_f64 (double a, double b)\n+{\n+  if (isnan (a))\n+    return b;\n+  else if (isnan (b))\n+    return a;\n+  else if (a > b)\n+    return b;\n+  else\n+    return a;\n+}\n+\n+float\n+__hsail_max_f32 (float a, float b)\n+{\n+  if (isnan (a))\n+    return b;\n+  else if (isnan (b))\n+    return a;\n+  else if (a == 0.0f && b == 0.0f && signbit (a))\n+    return b;\n+  else if (a < b)\n+    return b;\n+  else\n+    return a;\n+}\n+\n+double\n+__hsail_max_f64 (double a, double b)\n+{\n+  if (isnan (a))\n+    return b;\n+  else if (isnan (b))\n+    return a;\n+  else if (a == 0.0 && b == 0.0 && signbit (a))\n+    return b;\n+  else if (a < b)\n+    return b;\n+  else\n+    return a;\n+}\n+\n+uint8_t\n+__hsail_cvt_zeroi_sat_u8_f32 (float a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (float) UINT8_MAX)\n+    return UINT8_MAX;\n+  else if (a <= 0.0f)\n+    return 0;\n+  return (uint8_t) a;\n+}\n+\n+int8_t\n+__hsail_cvt_zeroi_sat_s8_f32 (float a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (float) INT8_MAX)\n+    return INT8_MAX;\n+  if (a <= (float) INT8_MIN)\n+    return INT8_MIN;\n+  return (int8_t) a;\n+}\n+\n+uint16_t\n+__hsail_cvt_zeroi_sat_u16_f32 (float a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (float) UINT16_MAX)\n+    return UINT16_MAX;\n+  else if (a <= 0.0f)\n+    return 0;\n+  return (uint16_t) a;\n+}\n+\n+int16_t\n+__hsail_cvt_zeroi_sat_s16_f32 (float a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (float) INT16_MAX)\n+    return INT16_MAX;\n+  if (a <= (float) INT16_MIN)\n+    return INT16_MIN;\n+  return (int16_t) a;\n+}\n+\n+uint32_t\n+__hsail_cvt_zeroi_sat_u32_f32 (float a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (float) UINT32_MAX)\n+    return UINT32_MAX;\n+  else if (a <= 0.0f)\n+    return 0;\n+  return (uint32_t) a;\n+}\n+\n+int32_t\n+__hsail_cvt_zeroi_sat_s32_f32 (float a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (float) INT32_MAX)\n+    return INT32_MAX;\n+  if (a <= (float) INT32_MIN)\n+    return INT32_MIN;\n+  return (int32_t) a;\n+}\n+\n+uint64_t\n+__hsail_cvt_zeroi_sat_u64_f32 (float a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (float) UINT64_MAX)\n+    return UINT64_MAX;\n+  else if (a <= 0.0f)\n+    return 0;\n+  return (uint64_t) a;\n+}\n+\n+int64_t\n+__hsail_cvt_zeroi_sat_s64_f32 (float a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (float) INT64_MAX)\n+    return INT64_MAX;\n+  if (a <= (float) INT64_MIN)\n+    return INT64_MIN;\n+  return (int64_t) a;\n+}\n+\n+uint8_t\n+__hsail_cvt_zeroi_sat_u8_f64 (double a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (double) UINT8_MAX)\n+    return UINT8_MAX;\n+  else if (a <= 0.0f)\n+    return 0;\n+  return (uint8_t) a;\n+}\n+\n+int8_t\n+__hsail_cvt_zeroi_sat_s8_f64 (double a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (double) INT8_MAX)\n+    return INT8_MAX;\n+  if (a <= (double) INT8_MIN)\n+    return INT8_MIN;\n+  return (int8_t) a;\n+}\n+\n+uint16_t\n+__hsail_cvt_zeroi_sat_u16_f64 (double a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (double) UINT16_MAX)\n+    return UINT16_MAX;\n+  else if (a <= 0.0f)\n+    return 0;\n+  return (uint16_t) a;\n+}\n+\n+int16_t\n+__hsail_cvt_zeroi_sat_s16_f64 (double a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (double) INT16_MAX)\n+    return INT16_MAX;\n+  if (a <= (double) INT16_MIN)\n+    return INT16_MIN;\n+  return (int16_t) a;\n+}\n+\n+uint32_t\n+__hsail_cvt_zeroi_sat_u32_f64 (double a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (double) UINT32_MAX)\n+    return UINT32_MAX;\n+  else if (a <= 0.0f)\n+    return 0;\n+  return (uint32_t) a;\n+}\n+\n+int32_t\n+__hsail_cvt_zeroi_sat_s32_f64 (double a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (double) INT32_MAX)\n+    return INT32_MAX;\n+  if (a <= (double) INT32_MIN)\n+    return INT32_MIN;\n+  return (int32_t) a;\n+}\n+\n+uint64_t\n+__hsail_cvt_zeroi_sat_u64_f64 (double a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (double) UINT64_MAX)\n+    return UINT64_MAX;\n+  else if (a <= 0.0f)\n+    return 0;\n+  return (uint64_t) a;\n+}\n+\n+int64_t\n+__hsail_cvt_zeroi_sat_s64_f64 (double a)\n+{\n+  if (isnan (a))\n+    return 0;\n+  if (a >= (double) INT64_MAX)\n+    return INT64_MAX;\n+  if (a <= (double) INT64_MIN)\n+    return INT64_MIN;\n+  return (int64_t) a;\n+}\n+\n+\n+/* Flush the operand to zero in case it's a denormalized number.\n+   Do not cause any exceptions in case of NaNs.  */\n+\n+float\n+__hsail_ftz_f32 (float a)\n+{\n+  if (isnan (a) || isinf (a) || a == 0.0f)\n+    return a;\n+\n+  if (a < 0.0f)\n+    {\n+      if (-a < FLT_MIN)\n+\treturn -0.0f;\n+    }\n+  else\n+    {\n+      if (a < FLT_MIN)\n+\treturn 0.0f;\n+    }\n+  return a;\n+}\n+\n+#define F16_MIN (6.10e-5)\n+\n+/* Flush the single precision operand to zero in case it's considered\n+   a denormalized number in case it was a f16.  Do not cause any exceptions\n+   in case of NaNs.  */\n+\n+float\n+__hsail_ftz_f32_f16 (float a)\n+{\n+  if (isnan (a) || isinf (a) || a == 0.0f)\n+    return a;\n+\n+  if (a < 0.0f)\n+    {\n+      if (-a < F16_MIN)\n+\treturn -0.0f;\n+    }\n+  else\n+    {\n+      if (a < F16_MIN)\n+\treturn 0.0f;\n+    }\n+  return a;\n+}\n+\n+double\n+__hsail_ftz_f64 (double a)\n+{\n+  if (isnan (a) || isinf (a) || a == 0.0d)\n+    return a;\n+\n+  if (a < 0.0d)\n+    {\n+      if (-a < DBL_MIN)\n+\treturn -0.0d;\n+    }\n+  else\n+    {\n+      if (a < DBL_MIN)\n+\treturn 0.0d;\n+    }\n+  return a;\n+}\n+\n+uint32_t\n+__hsail_borrow_u32 (uint32_t a, uint32_t b)\n+{\n+  uint64_t c = (uint64_t) a - (uint64_t) b;\n+  if (c > UINT32_MAX)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+uint64_t\n+__hsail_borrow_u64 (uint64_t a, uint64_t b)\n+{\n+  __uint128_t c = (__uint128_t) a - (__uint128_t) b;\n+  if (c > UINT64_MAX)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+uint32_t\n+__hsail_carry_u32 (uint32_t a, uint32_t b)\n+{\n+  uint64_t c = (uint64_t) a + (uint64_t) b;\n+  if (c > UINT32_MAX)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+uint64_t\n+__hsail_carry_u64 (uint64_t a, uint64_t b)\n+{\n+  __uint128_t c = (__uint128_t) a + (__uint128_t) b;\n+  if (c > UINT64_MAX)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+float\n+__hsail_fract_f32 (float a)\n+{\n+  int exp;\n+  if (isinf (a))\n+    return signbit (a) == 0 ? 0.0f : -0.0f;\n+  if (isnan (a) || a == 0.0f)\n+    return a;\n+  else\n+    return fminf (a - floorf (a), 0x1.fffffep-1f);\n+}\n+\n+double\n+__hsail_fract_f64 (double a)\n+{\n+  int exp;\n+  if (isinf (a))\n+    return 0.0f * isinf (a);\n+  if (isnan (a) || a == 0.0f)\n+    return a;\n+  else\n+    return fmin (a - floor (a), 0x1.fffffffffffffp-1d);\n+}\n+\n+uint32_t\n+__hsail_class_f32 (float a, uint32_t flags)\n+{\n+  return (flags & 0x0001 && isnan (a) && !(*(uint32_t *) &a & 0x40000000))\n+\t || (flags & 0x0002 && isnan (a) && (*(uint32_t *) &a & 0x40000000))\n+\t || (flags & 0x0004 && isinf (a) && a < 0.0f)\n+\t || (flags & 0x0008 && isnormal (a) && signbit (a))\n+\t || (flags & 0x0010 && a < 0.0f && a > -FLT_MIN)\n+\t || (flags & 0x0020 && a == 0.0f && signbit (a))\n+\t || (flags & 0x0040 && a == 0.0f && !signbit (a))\n+\t || (flags & 0x0080 && a > 0.0f && a < FLT_MIN)\n+\t || (flags & 0x0100 && isnormal (a) && !signbit (a))\n+\t || (flags & 0x0200 && isinf (a) && a >= 0.0f);\n+}\n+\n+/* 'class' for a f32-converted f16 which should otherwise be treated like f32\n+ except for its limits.  */\n+\n+uint32_t\n+__hsail_class_f32_f16 (float a, uint32_t flags)\n+{\n+  return (flags & 0x0001 && isnan (a) && !(*(uint32_t *) &a & 0x40000000))\n+\t || (flags & 0x0002 && isnan (a) && (*(uint32_t *) &a & 0x40000000))\n+\t || (flags & 0x0004 && isinf (a) && a < 0.0f)\n+\t || (flags & 0x0008 && a != 0.0f && !isinf (a) && !isnan (a)\n+\t     && a <= -F16_MIN)\n+\t || (flags & 0x0010 && a != 0.0f && !isinf (a) && !isnan (a) && a < 0.0f\n+\t     && a > -F16_MIN)\n+\t || (flags & 0x0020 && a == 0.0f && signbit (a))\n+\t || (flags & 0x0040 && a == 0.0f && !signbit (a))\n+\t || (flags & 0x0080 && a != 0.0f && !isinf (a) && !isnan (a) && a > 0.0f\n+\t     && a < F16_MIN)\n+\t || (flags & 0x0100 && a != 0.0f && !isinf (a) && !isnan (a)\n+\t     && a >= F16_MIN)\n+\t || (flags & 0x0200 && isinf (a) && a >= 0.0f);\n+}"}, {"sha": "04f02f06aff927de33ce8dbf5bc5154351578354", "filename": "libhsail-rt/rt/atomics.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fatomics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fatomics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Frt%2Fatomics.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,115 @@\n+/* atomic.c -- Builtins for HSAIL atomic instructions for which\n+   there is no feasible direct gcc GENERIC expression.\n+\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining a\n+   copy of this software and associated documentation files\n+   (the \"Software\"), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+   USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#include <stdint.h>\n+#include <stdio.h>\n+\n+#define DO_ATOMICALLY(T, OPERATION)\t\t\t\t\t\\\n+  int done = 0;\t\t\t\t\t\t\t\t\\\n+  T old_value;\t\t\t\t\t\t\t\t\\\n+  T new_value;\t\t\t\t\t\t\t\t\\\n+  while (!done)\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      old_value = *ptr;\t\t\t\t\t\t\t\\\n+      new_value = OPERATION;\t\t\t\t\t\t\\\n+      done = __sync_bool_compare_and_swap (ptr, old_value, new_value);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  return old_value\n+\n+int32_t\n+__hsail_atomic_min_s32 (int32_t *ptr, int32_t a)\n+{\n+  DO_ATOMICALLY (int32_t, (old_value < a) ? old_value : a);\n+}\n+\n+int64_t\n+__hsail_atomic_min_s64 (int64_t *ptr, int64_t a)\n+{\n+  DO_ATOMICALLY (int64_t, (old_value < a) ? old_value : a);\n+}\n+\n+uint32_t\n+__hsail_atomic_min_u32 (uint32_t *ptr, uint32_t a)\n+{\n+  DO_ATOMICALLY (uint32_t, (old_value < a) ? old_value : a);\n+}\n+\n+uint64_t\n+__hsail_atomic_min_u64 (uint64_t *ptr, uint64_t a)\n+{\n+  DO_ATOMICALLY (uint64_t, (old_value < a) ? old_value : a);\n+}\n+\n+uint32_t\n+__hsail_atomic_max_u32 (uint32_t *ptr, uint32_t a)\n+{\n+  DO_ATOMICALLY (uint32_t, (old_value > a) ? old_value : a);\n+}\n+\n+int32_t\n+__hsail_atomic_max_s32 (int32_t *ptr, int32_t a)\n+{\n+  DO_ATOMICALLY (int32_t, (old_value > a) ? old_value : a);\n+}\n+\n+uint64_t\n+__hsail_atomic_max_u64 (uint64_t *ptr, uint64_t a)\n+{\n+  DO_ATOMICALLY (uint64_t, (old_value > a) ? old_value : a);\n+}\n+\n+int64_t\n+__hsail_atomic_max_s64 (int64_t *ptr, int64_t a)\n+{\n+  DO_ATOMICALLY (int64_t, (old_value > a) ? old_value : a);\n+}\n+\n+uint32_t\n+__hsail_atomic_wrapinc_u32 (uint32_t *ptr, uint32_t a)\n+{\n+  DO_ATOMICALLY (uint32_t, (old_value >= a) ? 0 : (old_value + 1));\n+}\n+\n+uint64_t\n+__hsail_atomic_wrapinc_u64 (uint64_t *ptr, uint64_t a)\n+{\n+  DO_ATOMICALLY (uint64_t, (old_value >= a) ? 0 : (old_value + 1));\n+}\n+\n+uint32_t\n+__hsail_atomic_wrapdec_u32 (uint32_t *ptr, uint32_t a)\n+{\n+  DO_ATOMICALLY (uint32_t,\n+\t\t ((old_value == 0) || (old_value > a)) ? a : (old_value - 1));\n+}\n+\n+uint64_t\n+__hsail_atomic_wrapdec_u64 (uint64_t *ptr, uint64_t a)\n+{\n+  DO_ATOMICALLY (uint64_t,\n+\t\t ((old_value == 0) || (old_value > a)) ? a : (old_value - 1));\n+}"}, {"sha": "44d9b0a776b3e40b8698ede975d06f2a3b8b78e9", "filename": "libhsail-rt/rt/bitstring.c", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fbitstring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fbitstring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Frt%2Fbitstring.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,190 @@\n+/* bitstring.c -- Builtins for HSAIL bitstring instructions.\n+\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining a\n+   copy of this software and associated documentation files\n+   (the \"Software\"), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+   USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#include <stdint.h>\n+#include <limits.h>\n+\n+#define BITEXTRACT(DEST_TYPE, SRC0, SRC1, SRC2)\t\t\t\t\\\n+  uint32_t offset = SRC1 & (sizeof (DEST_TYPE) * 8 - 1);\t\t\\\n+  uint32_t width = SRC2 & (sizeof (DEST_TYPE) * 8 - 1);\t\t\t\\\n+  if (width == 0)\t\t\t\t\t\t\t\\\n+    return 0;\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    return (SRC0 << (sizeof (DEST_TYPE) * 8 - width - offset))\t\t\\\n+      >> (sizeof (DEST_TYPE) * 8 - width)\n+\n+uint32_t\n+__hsail_bitextract_u32 (uint32_t src0, uint32_t src1, uint32_t src2)\n+{\n+  BITEXTRACT (uint32_t, src0, src1, src2);\n+}\n+\n+int32_t\n+__hsail_bitextract_s32 (int32_t src0, uint32_t src1, uint32_t src2)\n+{\n+  BITEXTRACT (int32_t, src0, src1, src2);\n+}\n+\n+uint64_t\n+__hsail_bitextract_u64 (uint64_t src0, uint32_t src1, uint32_t src2)\n+{\n+  BITEXTRACT (uint64_t, src0, src1, src2);\n+}\n+\n+int64_t\n+__hsail_bitextract_s64 (int64_t src0, uint32_t src1, uint32_t src2)\n+{\n+  BITEXTRACT (int64_t, src0, src1, src2);\n+}\n+\n+#define BITINSERT(DEST_TYPE, SRC0, SRC1, SRC2, SRC3)\t\t\t\\\n+  uint32_t offset = SRC2 & (sizeof (DEST_TYPE) * 8 - 1);\t\t\\\n+  uint32_t width = SRC3 & (sizeof (DEST_TYPE) * 8 - 1);\t\t\t\\\n+  DEST_TYPE mask = ((DEST_TYPE) 1 << width) - 1;\t\t\t\\\n+  return (SRC0 & ~(mask << offset)) | ((SRC1 & mask) << offset)\n+\n+uint32_t\n+__hsail_bitinsert_u32 (uint32_t src0, uint32_t src1, uint32_t src2,\n+\t\t\t      uint32_t src3)\n+{\n+  BITINSERT (uint32_t, src0, src1, src2, src3);\n+}\n+\n+int64_t\n+__hsail_bitinsert_u64 (uint64_t src0, uint64_t src1, uint32_t src2,\n+\t\t\t      uint32_t src3)\n+{\n+  BITINSERT (uint64_t, src0, src1, src2, src3);\n+}\n+\n+#define BITMASK(DEST_TYPE, SRC0, SRC1)\t\t\t\t\t\\\n+  uint32_t offset = SRC0 & (sizeof (DEST_TYPE) * 8 - 1);\t\t\\\n+  uint32_t width = SRC1 & (sizeof (DEST_TYPE) * 8 - 1);\t\t\t\\\n+  DEST_TYPE mask = ((DEST_TYPE) 1 << width) - 1;\t\t\t\\\n+  return mask << offset\n+\n+uint32_t\n+__hsail_bitmask_u32 (uint32_t src0, uint32_t src1)\n+{\n+  BITMASK (uint32_t, src0, src1);\n+}\n+\n+uint64_t\n+__hsail_bitmask_u64 (uint32_t src0, uint32_t src1)\n+{\n+  BITMASK (uint64_t, src0, src1);\n+}\n+\n+/* The dummy, but readable version from\n+   http://graphics.stanford.edu/~seander/bithacks.html#BitReverseObvious\n+   This (also) often maps to a single instruction in DSPs.  */\n+\n+#define BITREV(DEST_TYPE, SRC)\t\t\t\t\t\t\\\n+  DEST_TYPE v = SRC;\t\t\t\t\t\t\t\\\n+  DEST_TYPE r = v;\t\t\t\t\t\t\t\\\n+  int s = sizeof (SRC) * CHAR_BIT - 1;\t\t\t\t\t\\\n+  \t\t\t\t\t\t\t\t\t\\\n+  for (v >>= 1; v; v >>= 1)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      r <<= 1;\t\t\t\t\t\t\t\t\\\n+      r |= v & 1;\t\t\t\t\t\t\t\\\n+      s--;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  return r << s\n+\n+uint32_t\n+__hsail_bitrev_u32 (uint32_t src0)\n+{\n+  BITREV (uint32_t, src0);\n+}\n+\n+uint64_t\n+__hsail_bitrev_u64 (uint64_t src0)\n+{\n+  BITREV (uint64_t, src0);\n+}\n+\n+uint32_t\n+__hsail_bitselect_u32 (uint32_t src0, uint32_t src1, uint32_t src2)\n+{\n+  return (src1 & src0) | (src2 & ~src0);\n+}\n+\n+uint64_t\n+__hsail_bitselect_u64 (uint64_t src0, uint64_t src1, uint64_t src2)\n+{\n+  return (src1 & src0) | (src2 & ~src0);\n+}\n+\n+/* Due to the defined behavior with 0, we cannot use the gcc builtin\n+   __builtin_clz* () directly. __builtin_ffs () has defined behavior, but\n+   returns 0 while HSAIL requires to return -1.  */\n+\n+uint32_t\n+__hsail_firstbit_u32 (uint32_t src0)\n+{\n+  if (src0 == 0)\n+    return -1;\n+  return __builtin_clz (src0);\n+}\n+\n+uint32_t\n+__hsail_firstbit_s32 (int32_t src0)\n+{\n+  uint32_t converted = src0 >= 0 ? src0 : ~src0;\n+  return __hsail_firstbit_u32 (converted);\n+}\n+\n+uint32_t\n+__hsail_firstbit_u64 (uint64_t src0)\n+{\n+  if (src0 == 0)\n+    return -1;\n+  return __builtin_clzl (src0);\n+}\n+\n+uint32_t\n+__hsail_firstbit_s64 (int64_t src0)\n+{\n+  uint64_t converted = src0 >= 0 ? src0 : ~src0;\n+  return __hsail_firstbit_u64 (converted);\n+}\n+\n+uint32_t\n+__hsail_lastbit_u32 (uint32_t src0)\n+{\n+  if (src0 == 0)\n+    return -1;\n+  return __builtin_ctz (src0);\n+}\n+\n+uint32_t\n+__hsail_lastbit_u64 (uint64_t src0)\n+{\n+  if (src0 == 0)\n+    return -1;\n+  return __builtin_ctzl (src0);\n+}"}, {"sha": "608cec9227c5513a0aa5cd630976adc204566322", "filename": "libhsail-rt/rt/fbarrier.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Ffbarrier.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Ffbarrier.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Frt%2Ffbarrier.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,87 @@\n+/* fbarrier.c -- HSAIL fbarrier built-ins.\n+\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining a\n+   copy of this software and associated documentation files\n+   (the \"Software\"), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+   USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#include <stdlib.h>\n+#include <signal.h>\n+\n+#include \"workitems.h\"\n+#include \"phsa-rt.h\"\n+\n+#ifdef HAVE_FIBERS\n+#include \"fibers.h\"\n+\n+typedef fiber_barrier_t fbarrier;\n+\n+void\n+__hsail_initfbar (uint32_t addr, PHSAWorkItem *wi)\n+{\n+  fbarrier *fbar = (fbarrier *) (wi->wg->group_base_ptr + addr);\n+  fbar->threshold = 0;\n+  fbar->reached = 0;\n+  fbar->waiting_count = 0;\n+}\n+\n+void\n+__hsail_releasefbar (uint32_t addr, PHSAWorkItem *wi)\n+{\n+  fbarrier *fbar = (fbarrier *) (wi->wg->group_base_ptr + addr);\n+  fbar->threshold = 0;\n+  fbar->reached = 0;\n+  fbar->waiting_count = 0;\n+}\n+\n+void\n+__hsail_joinfbar (uint32_t addr, PHSAWorkItem *wi)\n+{\n+  fbarrier *fbar = (fbarrier *) (wi->wg->group_base_ptr + addr);\n+  ++fbar->threshold;\n+}\n+\n+void\n+__hsail_leavefbar (uint32_t addr, PHSAWorkItem *wi)\n+{\n+  fbarrier *fbar = (fbarrier *) (wi->wg->group_base_ptr + addr);\n+  --fbar->threshold;\n+}\n+\n+void\n+__hsail_waitfbar (uint32_t addr, PHSAWorkItem *wi)\n+{\n+  fbarrier *fbar = (fbarrier *) (wi->wg->group_base_ptr + addr);\n+  fiber_barrier_reach (fbar);\n+}\n+\n+void\n+__hsail_arrivefbar (uint32_t addr, PHSAWorkItem *wi)\n+{\n+  fbarrier *fbar = (fbarrier *) (wi->wg->group_base_ptr + addr);\n+  ++fbar->reached;\n+  if (fbar->reached == fbar->threshold)\n+    fbar->reached = 0;\n+}\n+\n+#endif\n+"}, {"sha": "a3056a92cde250bbdb9f38fcf68a97061142556a", "filename": "libhsail-rt/rt/fibers.c", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Ffibers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Ffibers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Frt%2Ffibers.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,220 @@\n+/* fibers.c -- extremely simple lightweight thread (fiber) implementation\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining a\n+   copy of this software and associated documentation files\n+   (the \"Software\"), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+   USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <stdint.h>\n+\n+#include \"target-config.h\"\n+\n+#include \"fibers.h\"\n+\n+void\n+phsa_fatal_error (int code);\n+\n+ucontext_t main_context;\n+\n+/* The last fiber in the linked list.  */\n+static fiber_t *tail_fiber = NULL;\n+/* The first fiber in the linked list.  */\n+static fiber_t *head_fiber = NULL;\n+/* The fiber currently being executed.  */\n+static fiber_t *current_fiber = NULL;\n+\n+/* Makecontext accepts only integer arguments.  We need to split the\n+   pointer argument in case pointer does not fit into int.  This helper\n+   function can be used to restore the pointer from the arguments.  */\n+\n+void *\n+fiber_int_args_to_ptr (int arg0, int arg1)\n+{\n+  void *ptr = NULL;\n+#if SIZEOF_VOIDP == 8 && SIZEOF_INT == 4\n+  ptr = (void*)(((uint64_t) arg0 & (uint64_t) 0xFFFFFFFF)\n+\t\t| ((uint64_t) arg1 << 32));\n+#elif SIZEOF_VOIDP == 4 && SIZEOF_INT == 4\n+  ptr = (void*)arg0;\n+#else\n+# error Unsupported pointer/int size.\n+#endif\n+  return ptr;\n+}\n+\n+void\n+fiber_init (fiber_t *fiber, fiber_function_t start_function, void *arg,\n+\t    size_t stack_size, size_t stack_align)\n+{\n+  int arg0, arg1;\n+  if (getcontext (&fiber->context) != 0)\n+    phsa_fatal_error (3);\n+  if (posix_memalign (&fiber->context.uc_stack.ss_sp, stack_align, stack_size)\n+      != 0)\n+    phsa_fatal_error (4);\n+  fiber->context.uc_stack.ss_size = stack_size;\n+  fiber->context.uc_link = &main_context;\n+\n+  /* makecontext () accepts only integer arguments.  Split the\n+     pointer argument to two args in the case pointer does not fit\n+     into one int.  */\n+#if SIZEOF_VOIDP == 8 && SIZEOF_INT == 4\n+  arg0 = (int32_t) 0xFFFFFFFF & (uint64_t)arg;\n+  arg1 = (int32_t) 0xFFFFFFFF & ((uint64_t)arg >> 32);\n+#elif SIZEOF_VOIDP == 4 && SIZEOF_INT == 4\n+  arg0 = (int)arg;\n+  arg1 = 0;\n+#else\n+# error Unsupported pointer/int size.\n+#endif\n+\n+  makecontext (&fiber->context, (void*)start_function, 2, arg0, arg1);\n+\n+  fiber->status = FIBER_STATUS_READY;\n+  fiber->next = NULL;\n+  fiber->prev = NULL;\n+\n+  /* Create a linked list of the created fibers.  Append the new one at\n+     the end.  */\n+  if (tail_fiber == NULL)\n+    tail_fiber = fiber;\n+  else\n+    {\n+      tail_fiber->next = fiber;\n+      fiber->prev = tail_fiber;\n+      tail_fiber = fiber;\n+    }\n+\n+  if (head_fiber == NULL)\n+    head_fiber = fiber;\n+}\n+\n+void\n+fiber_exit ()\n+{\n+  fiber_status_t old_status = current_fiber->status;\n+  current_fiber->status = FIBER_STATUS_EXITED;\n+  if (old_status == FIBER_STATUS_JOINED)\n+    /* In case this thread has been joined, return back to the joiner.  */\n+    swapcontext (&current_fiber->context, &main_context);\n+  else\n+    /* In case the thread exited while being yielded from another thread,\n+       switch back to another fiber.  */\n+    fiber_yield ();\n+}\n+\n+void\n+fiber_join (fiber_t *fiber)\n+{\n+  fiber_t *next_ready_fiber = NULL;\n+  current_fiber = fiber;\n+  if (fiber->status != FIBER_STATUS_EXITED)\n+    {\n+      fiber->status = FIBER_STATUS_JOINED;\n+      while (fiber->status != FIBER_STATUS_EXITED)\n+\tswapcontext (&main_context, &fiber->context);\n+    }\n+\n+  /* Remove the successfully joined fiber from the linked list so we won't\n+     access it later (the fiber itself might be freed after the join).  */\n+  if (fiber->prev != NULL)\n+    fiber->prev->next = fiber->next;\n+\n+  if (fiber->next != NULL)\n+    fiber->next->prev = fiber->prev;\n+\n+  if (head_fiber == fiber)\n+    head_fiber = fiber->next;\n+\n+  if (tail_fiber == fiber)\n+    tail_fiber = fiber->prev;\n+\n+  free (fiber->context.uc_stack.ss_sp);\n+}\n+\n+void\n+fiber_yield ()\n+{\n+  fiber_t *next_ready_fiber = current_fiber;\n+\n+  if (current_fiber == head_fiber\n+      && current_fiber == tail_fiber)\n+    {\n+      /* If the last fiber exits independently, there is no\n+\t fiber to switch to.  Switch to the main context in that\n+\t case.  */\n+      if (current_fiber->status == FIBER_STATUS_EXITED)\n+\tswapcontext (&current_fiber->context, &main_context);\n+    }\n+\n+  do {\n+    next_ready_fiber = next_ready_fiber->next != NULL\n+      ? next_ready_fiber->next : head_fiber;\n+  } while (next_ready_fiber != current_fiber\n+\t   && next_ready_fiber->status == FIBER_STATUS_EXITED);\n+\n+  fiber_t *old_current_fiber = current_fiber;\n+  current_fiber = next_ready_fiber;\n+  swapcontext (&old_current_fiber->context, &next_ready_fiber->context);\n+}\n+\n+size_t\n+fiber_barrier_reach (fiber_barrier_t *barrier)\n+{\n+  /* Yield once to ensure that there are no fibers waiting for\n+     a previous triggering of the barrier in the waiting_count\n+     loop.  This should release them before we update the reached\n+     counter again.  */\n+  fiber_yield ();\n+\n+  barrier->reached++;\n+  ++barrier->waiting_count;\n+  while (barrier->reached < barrier->threshold)\n+    fiber_yield ();\n+  --barrier->waiting_count;\n+\n+  /* Wait until all the fibers have reached this point.  */\n+  while (barrier->waiting_count > 0)\n+    fiber_yield ();\n+\n+  /* Now all fibers have been released from the barrier waiting\n+     loop.  We can now safely reset the reach count for new triggering.  */\n+  if (barrier->reached > 0)\n+    {\n+      barrier->reached = 0;\n+      return 0;\n+    }\n+  return 1;\n+}\n+\n+void\n+fiber_barrier_init (fiber_barrier_t *barrier, size_t threshold)\n+{\n+  barrier->threshold = threshold;\n+  barrier->waiting_count = 0;\n+  barrier->reached = 0;\n+}"}, {"sha": "01cb1e05103d61104a9501573e20126bab507814", "filename": "libhsail-rt/rt/fp16.c", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Ffp16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Ffp16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Frt%2Ffp16.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,135 @@\n+/* Half-float conversion routines.  Code mostly borrowed from the ARM's\n+   builtin function.\n+\n+   Copyright (C) 2008-2015 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+static inline unsigned short\n+__gnu_f2h_internal (unsigned int a, int ieee)\n+{\n+  unsigned short sign = (a >> 16) & 0x8000;\n+  int aexp = (a >> 23) & 0xff;\n+  unsigned int mantissa = a & 0x007fffff;\n+  unsigned int mask;\n+  unsigned int increment;\n+\n+  if (aexp == 0xff)\n+    {\n+      if (!ieee)\n+\treturn sign;\n+      if (mantissa == 0)\n+\treturn sign | 0x7c00; /* Infinity.  */\n+      /* Remaining cases are NaNs.  Convert SNaN to QNaN.  */\n+      return sign | 0x7e00 | (mantissa >> 13);\n+    }\n+\n+  if (aexp == 0 && mantissa == 0)\n+    return sign;\n+\n+  aexp -= 127;\n+\n+  /* Decimal point between bits 22 and 23.  */\n+  mantissa |= 0x00800000;\n+  if (aexp < -14)\n+    {\n+      mask = 0x00ffffff;\n+      if (aexp >= -25)\n+\tmask >>= 25 + aexp;\n+    }\n+  else\n+    mask = 0x00001fff;\n+\n+  /* Round.  */\n+  if (mantissa & mask)\n+    {\n+      increment = (mask + 1) >> 1;\n+      if ((mantissa & mask) == increment)\n+\tincrement = mantissa & (increment << 1);\n+      mantissa += increment;\n+      if (mantissa >= 0x01000000)\n+\t{\n+\t  mantissa >>= 1;\n+\t  aexp++;\n+\t}\n+    }\n+\n+  if (ieee)\n+    {\n+      if (aexp > 15)\n+\treturn sign | 0x7c00;\n+    }\n+  else\n+    {\n+      if (aexp > 16)\n+\treturn sign | 0x7fff;\n+    }\n+\n+  if (aexp < -24)\n+    return sign;\n+\n+  if (aexp < -14)\n+    {\n+      mantissa >>= -14 - aexp;\n+      aexp = -14;\n+    }\n+\n+  /* We leave the leading 1 in the mantissa, and subtract one\n+     from the exponent bias to compensate.  */\n+  return sign | (((aexp + 14) << 10) + (mantissa >> 13));\n+}\n+\n+static unsigned int\n+__gnu_h2f_internal (unsigned short a, int ieee)\n+{\n+  unsigned int sign = (unsigned int) (a & 0x8000) << 16;\n+  int aexp = (a >> 10) & 0x1f;\n+  unsigned int mantissa = a & 0x3ff;\n+\n+  if (aexp == 0x1f && ieee)\n+    return sign | 0x7f800000 | (mantissa << 13);\n+\n+  if (aexp == 0)\n+    {\n+      int shift;\n+\n+      if (mantissa == 0)\n+\treturn sign;\n+\n+      shift = __builtin_clz (mantissa) - 21;\n+      mantissa <<= shift;\n+      aexp = -shift;\n+    }\n+\n+  return sign | (((aexp + 0x70) << 23) + (mantissa << 13));\n+}\n+\n+unsigned short\n+__hsail_f32_to_f16 (unsigned int a)\n+{\n+  return __gnu_f2h_internal (a, 1);\n+}\n+\n+unsigned int\n+__hsail_f16_to_f32 (unsigned short a)\n+{\n+  return __gnu_h2f_internal (a, 1);\n+}"}, {"sha": "547734e3e61ba481431b4a5eb8d1807faa10f572", "filename": "libhsail-rt/rt/misc.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Frt%2Fmisc.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,89 @@\n+/* misc.c -- Builtins for HSAIL misc instructions.\n+\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining a\n+   copy of this software and associated documentation files\n+   (the \"Software\"), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+   USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#include <stdint.h>\n+#include <time.h>\n+\n+#include \"workitems.h\"\n+\n+/* Return the monotonic clock as nanoseconds.  */\n+\n+uint64_t\n+__hsail_clock ()\n+{\n+  struct timespec t;\n+  clock_gettime (CLOCK_MONOTONIC, &t);\n+  return (uint64_t) t.tv_sec * 1000000000 + (uint64_t) t.tv_nsec;\n+}\n+\n+uint32_t\n+__hsail_cuid (PHSAWorkItem *wi)\n+{\n+  /* All WIs are executed with a single compute unit (core/thread)\n+     for now.  */\n+  return 0;\n+}\n+\n+uint32_t\n+__hsail_maxcuid (PHSAWorkItem *wi)\n+{\n+  /* All WIs are executed with a single compute unit (core/thread)\n+     for now.  */\n+  return 0;\n+}\n+\n+void\n+__hsail_debugtrap (uint32_t src, PHSAWorkItem *wi)\n+{\n+  /* Could we produce a SIGTRAP signal here to drop to gdb\n+     console, or similar?  In any case, the execution of the\n+     kernel should halt.\n+  */\n+  return;\n+}\n+\n+uint32_t\n+__hsail_groupbaseptr (PHSAWorkItem *wi)\n+{\n+  return (uint32_t) (uint64_t) (wi->wg->group_base_ptr\n+\t\t\t\t- wi->launch_data->group_segment_start_addr);\n+}\n+\n+uint64_t\n+__hsail_kernargbaseptr_u64 (PHSAWorkItem *wi)\n+{\n+  /* For now assume only a single kernarg allocation at a time.\n+     Proper kernarg memory management to do.  */\n+  return (uint64_t) wi->launch_data->kernarg_addr;\n+}\n+\n+uint32_t\n+__hsail_kernargbaseptr_u32 (PHSAWorkItem *wi)\n+{\n+  /* For now assume only a single kernarg allocation at a time.\n+     Proper kernarg memory management to do.  */\n+  return 0;\n+}"}, {"sha": "31125ed2933f0cf492df383d995f0acf21d65478", "filename": "libhsail-rt/rt/multimedia.c", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fmultimedia.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fmultimedia.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Frt%2Fmultimedia.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,135 @@\n+/* multimedia.c -- Builtins for HSAIL multimedia instructions.\n+\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining a\n+   copy of this software and associated documentation files\n+   (the \"Software\"), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+   USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#include <math.h>\n+#include <stdint.h>\n+\n+uint32_t\n+__hsail_bitalign (uint64_t lower, uint64_t upper, uint32_t shift_amount)\n+{\n+  shift_amount = shift_amount & 31;\n+  uint64_t packed_value = (upper << 32) | lower;\n+  return (packed_value >> shift_amount) & 0xFFFFFFFF;\n+}\n+\n+uint32_t\n+__hsail_bytealign (uint64_t lower, uint64_t upper, uint32_t shift_amount)\n+{\n+  shift_amount = (shift_amount & 3) * 8;\n+  uint64_t packed_value = (upper << 32) | lower;\n+  return (packed_value >> shift_amount) & 0xFFFFFFFF;\n+}\n+\n+uint32_t\n+__hsail_lerp (uint32_t a, uint32_t b, uint32_t c)\n+{\n+  uint32_t e3\n+    = (((((a >> 24) & 0xff) + ((b >> 24) & 0xff) + ((c >> 24) & 0x1)) / 2)\n+       & 0xff)\n+      << 24;\n+  uint32_t e2\n+    = (((((a >> 16) & 0xff) + ((b >> 16) & 0xff) + ((c >> 16) & 0x1)) / 2)\n+       & 0xff)\n+      << 16;\n+  uint32_t e1\n+    = (((((a >> 8) & 0xff) + ((b >> 8) & 0xff) + ((c >> 8) & 0x1)) / 2) & 0xff)\n+      << 8;\n+  uint32_t e0 = (((a & 0xff) + (b & 0xff) + (c & 0x1)) / 2) & 0xff;\n+\n+  return e3 | e2 | e1 | e0;\n+}\n+\n+static uint8_t\n+cvt_neari_sat_u8_f32 (float a)\n+{\n+  if (isinf (a))\n+    {\n+      if (signbit (a)) return 0;\n+      else return 255;\n+    }\n+  else if (isnan (a)) return 0;\n+  else if (a < 0.0)\n+    return 0;\n+  else if (a > 255.0)\n+    return 255;\n+  else\n+    return (uint8_t) a;\n+}\n+\n+uint32_t\n+__hsail_packcvt (float a, float b, float c, float d)\n+{\n+  return (uint32_t) cvt_neari_sat_u8_f32 (a)\n+\t | (uint32_t) cvt_neari_sat_u8_f32 (b) << 8\n+\t | (uint32_t) cvt_neari_sat_u8_f32 (c) << 16\n+\t | (uint32_t) cvt_neari_sat_u8_f32 (d) << 24;\n+}\n+\n+float\n+__hsail_unpackcvt (uint32_t val, uint32_t index)\n+{\n+  return (float) ((val >> (index * 8)) & 0xff);\n+}\n+\n+static uint32_t\n+abs_diff (uint32_t a, uint32_t b)\n+{\n+  if (a < b)\n+    return b - a;\n+  else\n+    return a - b;\n+}\n+\n+uint32_t\n+__hsail_sad_u8x4 (uint32_t a, uint32_t b, uint32_t add)\n+{\n+  return abs_diff ((a >> 24) & 0xff, (b >> 24) & 0xff)\n+\t + abs_diff ((a >> 16) & 0xff, (b >> 16) & 0xff)\n+\t + abs_diff ((a >> 8) & 0xff, (b >> 8) & 0xff)\n+\t + abs_diff ((a >> 0) & 0xff, (b >> 0) & 0xff) + add;\n+}\n+\n+uint32_t\n+__hsail_sad_u16x2 (uint32_t a, uint32_t b, uint32_t add)\n+{\n+  return abs_diff ((a >> 16) & 0xffff, (b >> 16) & 0xffff)\n+\t + abs_diff ((a >> 0) & 0xffff, (b >> 0) & 0xffff) + add;\n+}\n+\n+uint32_t\n+__hsail_sad_u32 (uint32_t a, uint32_t b, uint32_t add)\n+{\n+  return abs_diff (a, b) + add;\n+}\n+\n+uint32_t\n+__hsail_sadhi_u16x2_u8x4 (uint32_t a, uint32_t b, uint32_t add)\n+{\n+  return (abs_diff ((a >> 24) & 0xff, (b >> 24) & 0xff) << 16)\n+\t + (abs_diff ((a >> 16) & 0xff, (b >> 16) & 0xff) << 16)\n+\t + (abs_diff ((a >> 8) & 0xff, (b >> 8) & 0xff) << 16)\n+\t + (abs_diff ((a >> 0) & 0xff, (b >> 0) & 0xff) << 16) + add;\n+}"}, {"sha": "3d7ff7616b30635125c4ba31e3ca5f94d4baa2bc", "filename": "libhsail-rt/rt/queue.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fqueue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fqueue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Frt%2Fqueue.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,71 @@\n+/* queue.c -- Builtins for HSAIL queue related instructions.\n+\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining a\n+   copy of this software and associated documentation files\n+   (the \"Software\"), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+   USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#include \"phsa-queue-interface.h\"\n+\n+uint64_t\n+__hsail_ldqueuereadindex (uint64_t queue_addr)\n+{\n+  phsa_queue_t *queue = (phsa_queue_t *) queue_addr;\n+  return queue->read_index;\n+}\n+\n+uint64_t\n+__hsail_ldqueuewriteindex (uint64_t queue_addr)\n+{\n+  phsa_queue_t *queue = (phsa_queue_t *) queue_addr;\n+  return queue->write_index;\n+}\n+\n+uint64_t\n+__hsail_addqueuewriteindex (uint64_t queue_addr, uint64_t value)\n+{\n+  phsa_queue_t *queue = (phsa_queue_t *) queue_addr;\n+  return __sync_fetch_and_add (&queue->write_index, value);\n+}\n+\n+uint64_t\n+__hsail_casqueuewriteindex (uint64_t queue_addr, uint64_t cmp_value,\n+\t\t\t\t   uint64_t new_value)\n+{\n+  phsa_queue_t *queue = (phsa_queue_t *) queue_addr;\n+  return __sync_val_compare_and_swap (&queue->write_index, cmp_value,\n+\t\t\t\t      new_value);\n+}\n+\n+void\n+__hsail_stqueuereadindex (uint64_t queue_addr, uint64_t value)\n+{\n+  phsa_queue_t *queue = (phsa_queue_t *) queue_addr;\n+  queue->read_index = value;\n+}\n+\n+void\n+__hsail_stqueuewriteindex (uint64_t queue_addr, uint64_t value)\n+{\n+  phsa_queue_t *queue = (phsa_queue_t *) queue_addr;\n+  queue->write_index = value;\n+}"}, {"sha": "3e4024591ae77e49f32103b7047d226cdedaeab3", "filename": "libhsail-rt/rt/sat_arithmetic.c", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fsat_arithmetic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fsat_arithmetic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Frt%2Fsat_arithmetic.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,299 @@\n+/* sat_arithmetic.c -- Builtins for HSAIL saturating arithmetic instructions.\n+\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining a\n+   copy of this software and associated documentation files\n+   (the \"Software\"), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+   USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#include <stdint.h>\n+\n+uint8_t\n+__hsail_sat_add_u8 (uint8_t a, uint8_t b)\n+{\n+  uint16_t c = (uint16_t) a + (uint16_t) b;\n+  if (c > UINT8_MAX)\n+    return UINT8_MAX;\n+  else\n+    return c;\n+}\n+\n+uint16_t\n+__hsail_sat_add_u16 (uint16_t a, uint16_t b)\n+{\n+  uint32_t c = (uint32_t) a + (uint32_t) b;\n+  if (c > UINT16_MAX)\n+    return UINT16_MAX;\n+  else\n+    return c;\n+}\n+\n+uint32_t\n+__hsail_sat_add_u32 (uint32_t a, uint32_t b)\n+{\n+  uint64_t c = (uint64_t) a + (uint64_t) b;\n+  if (c > UINT32_MAX)\n+    return UINT32_MAX;\n+  else\n+    return c;\n+}\n+\n+uint64_t\n+__hsail_sat_add_u64 (uint64_t a, uint64_t b)\n+{\n+  __uint128_t c = (__uint128_t) a + (__uint128_t) b;\n+  if (c > UINT64_MAX)\n+    return UINT64_MAX;\n+  else\n+    return c;\n+}\n+\n+int8_t\n+__hsail_sat_add_s8 (int8_t a, int8_t b)\n+{\n+  int16_t c = (int16_t) a + (int16_t) b;\n+  if (c > INT8_MAX)\n+    return INT8_MAX;\n+  else if (c < INT8_MIN)\n+    return INT8_MIN;\n+  else\n+    return c;\n+}\n+\n+int16_t\n+__hsail_sat_add_s16 (int16_t a, int16_t b)\n+{\n+  int32_t c = (int32_t) a + (int32_t) b;\n+  if (c > INT16_MAX)\n+    return INT16_MAX;\n+  else if (c < INT16_MIN)\n+    return INT16_MIN;\n+  else\n+    return c;\n+}\n+\n+int32_t\n+__hsail_sat_add_s32 (int32_t a, int32_t b)\n+{\n+  int64_t c = (int64_t) a + (int64_t) b;\n+  if (c > INT32_MAX)\n+    return INT32_MAX;\n+  else if (c < INT32_MIN)\n+    return INT32_MIN;\n+  else\n+    return c;\n+}\n+\n+int64_t\n+__hsail_sat_add_s64 (int64_t a, int64_t b)\n+{\n+  __int128_t c = (__int128_t) a + (__int128_t) b;\n+  if (c > INT64_MAX)\n+    return INT64_MAX;\n+  else if (c < INT64_MIN)\n+    return INT64_MIN;\n+  else\n+    return c;\n+}\n+\n+uint8_t\n+__hsail_sat_sub_u8 (uint8_t a, uint8_t b)\n+{\n+  int16_t c = (uint16_t) a - (uint16_t) b;\n+  if (c < 0)\n+    return 0;\n+  else if (c > UINT8_MAX)\n+    return UINT8_MAX;\n+  else\n+    return c;\n+}\n+\n+uint16_t\n+__hsail_sat_sub_u16 (uint16_t a, uint16_t b)\n+{\n+  int32_t c = (uint32_t) a - (uint32_t) b;\n+  if (c < 0)\n+    return 0;\n+  else if (c > UINT16_MAX)\n+    return UINT16_MAX;\n+  else\n+    return c;\n+}\n+\n+uint32_t\n+__hsail_sat_sub_u32 (uint32_t a, uint32_t b)\n+{\n+  int64_t c = (uint64_t) a - (uint64_t) b;\n+  if (c < 0)\n+    return 0;\n+  else if (c > UINT32_MAX)\n+    return UINT32_MAX;\n+  else\n+    return c;\n+}\n+\n+uint64_t\n+__hsail_sat_sub_u64 (uint64_t a, uint64_t b)\n+{\n+  __int128_t c = (__uint128_t) a - (__uint128_t) b;\n+  if (c < 0)\n+    return 0;\n+  else if (c > UINT64_MAX)\n+    return UINT64_MAX;\n+  else\n+    return c;\n+}\n+\n+int8_t\n+__hsail_sat_sub_s8 (int8_t a, int8_t b)\n+{\n+  int16_t c = (int16_t) a - (int16_t) b;\n+  if (c > INT8_MAX)\n+    return INT8_MAX;\n+  else if (c < INT8_MIN)\n+    return INT8_MIN;\n+  else\n+    return c;\n+}\n+\n+int16_t\n+__hsail_sat_sub_s16 (int16_t a, int16_t b)\n+{\n+  int32_t c = (int32_t) a - (int32_t) b;\n+  if (c > INT16_MAX)\n+    return INT16_MAX;\n+  else if (c < INT16_MIN)\n+    return INT16_MIN;\n+  else\n+    return c;\n+}\n+\n+int32_t\n+__hsail_sat_sub_s32 (int32_t a, int32_t b)\n+{\n+  int64_t c = (int64_t) a - (int64_t) b;\n+  if (c > INT32_MAX)\n+    return INT32_MAX;\n+  else if (c < INT32_MIN)\n+    return INT32_MIN;\n+  else\n+    return c;\n+}\n+\n+int64_t\n+__hsail_sat_sub_s64 (int64_t a, int64_t b)\n+{\n+  __int128_t c = (__int128_t) a - (__int128_t) b;\n+  if (c > INT64_MAX)\n+    return INT64_MAX;\n+  else if (c < INT64_MIN)\n+    return INT64_MIN;\n+  else\n+    return c;\n+}\n+\n+uint8_t\n+__hsail_sat_mul_u8 (uint8_t a, uint8_t b)\n+{\n+  uint16_t c = (uint16_t) a * (uint16_t) b;\n+  if (c > UINT8_MAX)\n+    return UINT8_MAX;\n+  else\n+    return c;\n+}\n+\n+uint16_t\n+__hsail_sat_mul_u16 (uint16_t a, uint16_t b)\n+{\n+  uint32_t c = (uint32_t) a * (uint32_t) b;\n+  if (c > UINT16_MAX)\n+    return UINT16_MAX;\n+  else\n+    return c;\n+}\n+\n+uint32_t\n+__hsail_sat_mul_u32 (uint32_t a, uint32_t b)\n+{\n+  uint64_t c = (uint64_t) a * (uint64_t) b;\n+  if (c > UINT32_MAX)\n+    return UINT32_MAX;\n+  else\n+    return c;\n+}\n+\n+uint64_t\n+__hsail_sat_mul_u64 (uint64_t a, uint64_t b)\n+{\n+  __uint128_t c = (__uint128_t) a * (__uint128_t) b;\n+  if (c > UINT64_MAX)\n+    return UINT64_MAX;\n+  else\n+    return c;\n+}\n+\n+int8_t\n+__hsail_sat_mul_s8 (int8_t a, int8_t b)\n+{\n+  int16_t c = (int16_t) a * (int16_t) b;\n+  if (c > INT8_MAX)\n+    return INT8_MAX;\n+  else if (c < INT8_MIN)\n+    return INT8_MIN;\n+  else\n+    return c;\n+}\n+\n+int16_t\n+__hsail_sat_mul_s16 (int16_t a, int16_t b)\n+{\n+  int32_t c = (int32_t) a * (int32_t) b;\n+  if (c > INT16_MAX)\n+    return INT16_MAX;\n+  else if (c < INT16_MIN)\n+    return INT16_MIN;\n+  else\n+    return c;\n+}\n+\n+int32_t\n+__hsail_sat_mul_s32 (int32_t a, int32_t b)\n+{\n+  int64_t c = (int64_t) a * (int64_t) b;\n+  if (c > INT32_MAX)\n+    return INT32_MAX;\n+  else if (c < INT32_MIN)\n+    return INT32_MIN;\n+  else\n+    return c;\n+}\n+\n+int64_t\n+__hsail_sat_mul_s64 (int64_t a, int64_t b)\n+{\n+  __int128_t c = (__int128_t) a * (__int128_t) b;\n+  if (c > INT64_MAX)\n+    return INT64_MAX;\n+  else if (c < INT64_MIN)\n+    return INT64_MIN;\n+  else\n+    return c;\n+}"}, {"sha": "a1d2c843b814bae9f3335a79f2becdebd3896ac3", "filename": "libhsail-rt/rt/segment.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fsegment.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fsegment.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Frt%2Fsegment.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,57 @@\n+/* segment.c -- Builtins for HSAIL segment related instructions.\n+\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining a\n+   copy of this software and associated documentation files\n+   (the \"Software\"), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+   USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#include \"workitems.h\"\n+\n+uint32_t\n+__hsail_segmentp_private (uint64_t flat_addr, PHSAWorkItem *wi)\n+{\n+  if (flat_addr == 0)\n+    return 1;\n+  else\n+    return (void *) flat_addr >= wi->wg->private_base_ptr\n+\t   && (void *) flat_addr\n+\t\t< wi->wg->private_base_ptr + wi->wg->private_segment_total_size;\n+}\n+\n+uint32_t\n+__hsail_segmentp_group (uint64_t flat_addr, PHSAWorkItem *wi)\n+{\n+  if (flat_addr == 0)\n+    return 1;\n+  else\n+    return (void *) flat_addr >= wi->wg->group_base_ptr\n+\t   && (void *) flat_addr < wi->wg->group_base_ptr\n+\t\t\t\t     + wi->launch_data->dp->group_segment_size;\n+}\n+\n+uint32_t\n+__hsail_segmentp_global (uint64_t flat_addr, PHSAWorkItem *wi)\n+{\n+  return (flat_addr == 0\n+\t  || (!__hsail_segmentp_private (flat_addr, wi)\n+\t      && !__hsail_segmentp_group (flat_addr, wi)));\n+}"}, {"sha": "80bcaddd007452ef149b517ac17b9109f6ad1ffe", "filename": "libhsail-rt/rt/workitems.c", "status": "added", "additions": 952, "deletions": 0, "changes": 952, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fworkitems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Frt%2Fworkitems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Frt%2Fworkitems.c?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,952 @@\n+/* workitems.c -- The main runtime entry that performs work-item execution in\n+   various ways and the builtin functions closely related to the\n+   implementation.\n+\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+   Contributed by Pekka Jaaskelainen <pekka.jaaskelainen@parmance.com>\n+   for General Processor Tech.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining a\n+   copy of this software and associated documentation files\n+   (the \"Software\"), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+   USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+\n+/* The fiber based multiple work-item work-group execution uses ucontext\n+   based user mode threading.  However, if gccbrig is able to optimize the\n+   kernel to a much faster work-group function that implements the multiple\n+   WI execution using loops instead of fibers requiring slow context switches,\n+   the fiber-based implementation won't be called.\n+ */\n+\n+#include <stdlib.h>\n+#include <signal.h>\n+#include <string.h>\n+\n+#include \"workitems.h\"\n+#include \"phsa-rt.h\"\n+\n+#ifdef HAVE_FIBERS\n+#include \"fibers.h\"\n+#endif\n+\n+#ifdef BENCHMARK_PHSA_RT\n+#include <stdio.h>\n+#include <time.h>\n+\n+static uint64_t wi_count = 0;\n+static uint64_t wis_skipped = 0;\n+static uint64_t wi_total = 0;\n+static clock_t start_time;\n+\n+#endif\n+\n+#ifdef DEBUG_PHSA_RT\n+#include <stdio.h>\n+#endif\n+\n+#define PRIVATE_SEGMENT_ALIGN 256\n+#define FIBER_STACK_SIZE (64*1024)\n+#define GROUP_SEGMENT_ALIGN 256\n+\n+/* HSA requires WGs to be executed in flat work-group id order.  Enabling\n+   the following macro can reveal test cases that rely on the ordering,\n+   but is not useful for much else.  */\n+\n+uint32_t __hsail_workitemabsid (uint32_t dim, PHSAWorkItem *context);\n+\n+uint32_t __hsail_workitemid (uint32_t dim, PHSAWorkItem *context);\n+\n+uint32_t __hsail_gridgroups (uint32_t dim, PHSAWorkItem *context);\n+\n+uint32_t __hsail_currentworkgroupsize (uint32_t dim, PHSAWorkItem *wi);\n+\n+uint32_t __hsail_workgroupsize (uint32_t dim, PHSAWorkItem *wi);\n+\n+void\n+phsa_fatal_error (int code)\n+{\n+  exit (code);\n+}\n+\n+#ifdef HAVE_FIBERS\n+/* ucontext-based work-item thread implementation.  Runs all work-items in\n+   separate fibers.  */\n+\n+static void\n+phsa_work_item_thread (int arg0, int arg1)\n+{\n+  void *arg = fiber_int_args_to_ptr (arg0, arg1);\n+\n+  PHSAWorkItem *wi = (PHSAWorkItem *) arg;\n+  volatile PHSAWorkGroup *wg = wi->wg;\n+  PHSAKernelLaunchData *l_data = wi->launch_data;\n+\n+  do\n+    {\n+      int retcode\n+\t= fiber_barrier_reach ((fiber_barrier_t *) l_data->wg_start_barrier);\n+\n+      /* At this point the threads can assume that either more_wgs is 0 or\n+\t the current_work_group_* is set to point to the WG executed next.  */\n+      if (!wi->wg->more_wgs)\n+\tbreak;\n+#ifdef DEBUG_PHSA_RT\n+      printf (\n+\t\"Running work-item %lu/%lu/%lu for wg %lu/%lu/%lu / %lu/%lu/%lu...\\n\",\n+\twi->x, wi->y, wi->z, wg->x, wg->y, wg->z, l_data->wg_max_x,\n+\tl_data->wg_max_y, l_data->wg_max_z);\n+#endif\n+\n+      if (wi->x < __hsail_currentworkgroupsize (0, wi)\n+\t  && wi->y < __hsail_currentworkgroupsize (1, wi)\n+\t  && wi->z < __hsail_currentworkgroupsize (2, wi))\n+\t{\n+\t  l_data->kernel (l_data->kernarg_addr, wi, wg->group_base_ptr,\n+\t\t\t  wg->private_base_ptr);\n+#ifdef DEBUG_PHSA_RT\n+\t  printf (\"done.\\n\");\n+#endif\n+#ifdef BENCHMARK_PHSA_RT\n+\t  wi_count++;\n+#endif\n+\t}\n+      else\n+\t{\n+#ifdef DEBUG_PHSA_RT\n+\t  printf (\"skipped (partial WG).\\n\");\n+#endif\n+#ifdef BENCHMARK_PHSA_RT\n+\t  wis_skipped++;\n+#endif\n+\t}\n+\n+      retcode\n+\t= fiber_barrier_reach ((fiber_barrier_t *)\n+\t\t\t       l_data->wg_completion_barrier);\n+\n+      /* The first thread updates the WG to execute next etc.  */\n+\n+      if (retcode == 0)\n+\t{\n+#ifdef EXECUTE_WGS_BACKWARDS\n+\t  if (wg->x == l_data->wg_min_x)\n+\t    {\n+\t      wg->x = l_data->wg_max_x - 1;\n+\t      if (wg->y == l_data->wg_min_y)\n+\t\t{\n+\t\t  wg->y = l_data->wg_max_y - 1;\n+\t\t  if (wg->z == l_data->wg_min_z)\n+\t\t    wg->more_wgs = 0;\n+\t\t  else\n+\t\t    wg->z--;\n+\t\t}\n+\t      else\n+\t\twg->y--;\n+\t    }\n+\t  else\n+\t    wg->x--;\n+#else\n+\t  if (wg->x + 1 >= l_data->wg_max_x)\n+\t    {\n+\t      wg->x = l_data->wg_min_x;\n+\t      if (wg->y + 1 >= l_data->wg_max_y)\n+\t\t{\n+\t\t  wg->y = l_data->wg_min_y;\n+\t\t  if (wg->z + 1 >= l_data->wg_max_z)\n+\t\t    wg->more_wgs = 0;\n+\t\t  else\n+\t\t    wg->z++;\n+\t\t}\n+\t      else\n+\t\twg->y++;\n+\t    }\n+\t  else\n+\t    wg->x++;\n+#endif\n+\n+\t  /* Reinitialize the work-group barrier according to the new WG's\n+\t     size, which might not be the same as the previous ones, due\n+\t     to \"partial WGs\".  */\n+\t  size_t wg_size = __hsail_currentworkgroupsize (0, wi)\n+\t\t\t   * __hsail_currentworkgroupsize (1, wi)\n+\t\t\t   * __hsail_currentworkgroupsize (2, wi);\n+\n+#ifdef DEBUG_PHSA_RT\n+\t  printf (\"Reinitializing the WG barrier to %lu.\\n\", wg_size);\n+#endif\n+\t  fiber_barrier_init ((fiber_barrier_t *)\n+\t\t\t      wi->launch_data->wg_sync_barrier,\n+\t\t\t      wg_size);\n+\n+#ifdef BENCHMARK_PHSA_RT\n+\t  if (wi_count % 1000 == 0)\n+\t    {\n+\t      clock_t spent_time = clock () - start_time;\n+\t      double spent_time_sec = (double) spent_time / CLOCKS_PER_SEC;\n+\t      double wis_per_sec = wi_count / spent_time_sec;\n+\t      uint64_t eta_sec\n+\t\t= (wi_total - wi_count - wis_skipped) / wis_per_sec;\n+\n+\t      printf (\"%lu WIs executed %lu skipped in %lus (%lu WIs/s, ETA in \"\n+\t\t      \"%lu s)\\n\",\n+\t\t      wi_count, wis_skipped, (uint64_t) spent_time_sec,\n+\t\t      (uint64_t) wis_per_sec, (uint64_t) eta_sec);\n+\t    }\n+#endif\n+\t}\n+    }\n+  while (1);\n+\n+  fiber_exit ();\n+}\n+#endif\n+\n+#define MIN(a, b) ((a < b) ? a : b)\n+#define MAX(a, b) ((a > b) ? a : b)\n+\n+#ifdef HAVE_FIBERS\n+/* Spawns a given number of work-items to execute a set of work-groups,\n+   blocks until their completion.  */\n+\n+static void\n+phsa_execute_wi_gang (PHSAKernelLaunchData *context, void *group_base_ptr,\n+\t\t      size_t wg_size_x, size_t wg_size_y, size_t wg_size_z)\n+{\n+  PHSAWorkItem *wi_threads = NULL;\n+  PHSAWorkGroup wg;\n+  size_t flat_wi_id = 0, x, y, z, max_x, max_y, max_z;\n+  fiber_barrier_t wg_start_barrier;\n+  fiber_barrier_t wg_completion_barrier;\n+  fiber_barrier_t wg_sync_barrier;\n+\n+  max_x = wg_size_x == 0 ? 1 : wg_size_x;\n+  max_y = wg_size_y == 0 ? 1 : wg_size_y;\n+  max_z = wg_size_z == 0 ? 1 : wg_size_z;\n+\n+  size_t wg_size = max_x * max_y * max_z;\n+  if (wg_size > PHSA_MAX_WG_SIZE)\n+    phsa_fatal_error (2);\n+\n+  wg.private_segment_total_size = context->dp->private_segment_size * wg_size;\n+  if (wg.private_segment_total_size > 0\n+      && posix_memalign (&wg.private_base_ptr, PRIVATE_SEGMENT_ALIGN,\n+\t\t\t wg.private_segment_total_size)\n+\t   != 0)\n+    phsa_fatal_error (3);\n+\n+  wg.alloca_stack_p = wg.private_segment_total_size;\n+  wg.alloca_frame_p = wg.alloca_stack_p;\n+\n+#ifdef EXECUTE_WGS_BACKWARDS\n+  wg.x = context->wg_max_x - 1;\n+  wg.y = context->wg_max_y - 1;\n+  wg.z = context->wg_max_z - 1;\n+#else\n+  wg.x = context->wg_min_x;\n+  wg.y = context->wg_min_y;\n+  wg.z = context->wg_min_z;\n+#endif\n+\n+  fiber_barrier_init (&wg_sync_barrier, wg_size);\n+  fiber_barrier_init (&wg_start_barrier, wg_size);\n+  fiber_barrier_init (&wg_completion_barrier, wg_size);\n+\n+  context->wg_start_barrier = &wg_start_barrier;\n+  context->wg_sync_barrier = &wg_sync_barrier;\n+  context->wg_completion_barrier = &wg_completion_barrier;\n+\n+  wg.more_wgs = 1;\n+  wg.group_base_ptr = group_base_ptr;\n+\n+#ifdef BENCHMARK_PHSA_RT\n+  wi_count = 0;\n+  wis_skipped = 0;\n+  start_time = clock ();\n+#endif\n+  wi_threads = malloc (sizeof (PHSAWorkItem) * max_x * max_y * max_z);\n+  for (x = 0; x < max_x; ++x)\n+    for (y = 0; y < max_y; ++y)\n+      for (z = 0; z < max_z; ++z)\n+\t{\n+\t  PHSAWorkItem *wi = &wi_threads[flat_wi_id];\n+\t  wi->launch_data = context;\n+\t  wi->wg = &wg;\n+\t  wi->x = x;\n+\t  wi->y = y;\n+\t  wi->z = z;\n+\n+\t  /* TODO: set the stack size according to the private\n+\t\t   segment size.  Too big stack consumes huge amount of\n+\t\t   memory in case of huge number of WIs and a too small stack\n+\t\t   will fail in mysterious and potentially dangerous ways.  */\n+\n+\t  fiber_init (&wi->fiber, phsa_work_item_thread, wi,\n+\t\t      FIBER_STACK_SIZE, PRIVATE_SEGMENT_ALIGN);\n+\t  ++flat_wi_id;\n+\t}\n+\n+  do\n+    {\n+      --flat_wi_id;\n+      fiber_join (&wi_threads[flat_wi_id].fiber);\n+    }\n+  while (flat_wi_id > 0);\n+\n+  if (wg.private_segment_total_size > 0)\n+    free (wg.private_base_ptr);\n+\n+  free (wi_threads);\n+}\n+\n+/* Spawn the work-item threads to execute work-groups and let\n+   them execute all the WGs, including a potential partial WG.  */\n+\n+static void\n+phsa_spawn_work_items (PHSAKernelLaunchData *context, void *group_base_ptr)\n+{\n+  hsa_kernel_dispatch_packet_t *dp = context->dp;\n+  size_t x, y, z;\n+\n+  /* TO DO: host-side memory management of group and private segment\n+     memory.  Agents in general are less likely to support efficient dynamic mem\n+     allocation.  */\n+  if (dp->group_segment_size > 0\n+      && posix_memalign (&group_base_ptr, PRIVATE_SEGMENT_ALIGN,\n+\t\t\t dp->group_segment_size) != 0)\n+    phsa_fatal_error (3);\n+\n+  context->group_segment_start_addr = (size_t) group_base_ptr;\n+\n+  /* HSA seems to allow the WG size to be larger than the grid size.  We need to\n+     saturate the effective WG size to the grid size to prevent the extra WIs\n+     from executing.  */\n+  size_t sat_wg_size_x, sat_wg_size_y, sat_wg_size_z, sat_wg_size;\n+  sat_wg_size_x = MIN (dp->workgroup_size_x, dp->grid_size_x);\n+  sat_wg_size_y = MIN (dp->workgroup_size_y, dp->grid_size_y);\n+  sat_wg_size_z = MIN (dp->workgroup_size_z, dp->grid_size_z);\n+  sat_wg_size = sat_wg_size_x * sat_wg_size_y * sat_wg_size_z;\n+\n+#ifdef BENCHMARK_PHSA_RT\n+  wi_total = (uint64_t) dp->grid_size_x\n+\t     * (dp->grid_size_y > 0 ? dp->grid_size_y : 1)\n+\t     * (dp->grid_size_z > 0 ? dp->grid_size_z : 1);\n+#endif\n+\n+  /* For now execute all work groups in a single coarse thread (does not utilize\n+     multicore/multithread).  */\n+  context->wg_min_x = context->wg_min_y = context->wg_min_z = 0;\n+\n+  int dims = dp->setup & 0x3;\n+\n+  context->wg_max_x = ((uint64_t) dp->grid_size_x + dp->workgroup_size_x - 1)\n+\t\t      / dp->workgroup_size_x;\n+\n+  context->wg_max_y\n+    = dims < 2 ? 1 : ((uint64_t) dp->grid_size_y + dp->workgroup_size_y - 1)\n+\t\t       / dp->workgroup_size_y;\n+\n+  context->wg_max_z\n+    = dims < 3 ? 1 : ((uint64_t) dp->grid_size_z + dp->workgroup_size_z - 1)\n+\t\t       / dp->workgroup_size_z;\n+\n+#ifdef DEBUG_PHSA_RT\n+  printf (\"### launching work-groups %lu/%lu/%lu to %lu/%lu/%lu with \"\n+\t  \"wg size %lu/%lu/%lu grid size %u/%u/%u\\n\",\n+\t  context->wg_min_x, context->wg_min_y, context->wg_min_z,\n+\t  context->wg_max_x, context->wg_max_y, context->wg_max_z,\n+\t  sat_wg_size_x, sat_wg_size_y, sat_wg_size_z, dp->grid_size_x,\n+\t  dp->grid_size_y, dp->grid_size_z);\n+#endif\n+\n+  phsa_execute_wi_gang (context, group_base_ptr, sat_wg_size_x, sat_wg_size_y,\n+\t\t\tsat_wg_size_z);\n+\n+  if (dp->group_segment_size > 0)\n+    free (group_base_ptr);\n+}\n+#endif\n+\n+/* Executes the given work-group function for all work groups in the grid.\n+\n+   A work-group function is a version of the original kernel which executes\n+   the kernel for all work-items in a work-group.  It is produced by gccbrig\n+   if it can handle the kernel's barrier usage and is much faster way to\n+   execute massive numbers of work-items in a non-SPMD machine than fibers\n+   (easily 100x faster).  */\n+static void\n+phsa_execute_work_groups (PHSAKernelLaunchData *context, void *group_base_ptr)\n+{\n+  hsa_kernel_dispatch_packet_t *dp = context->dp;\n+  size_t x, y, z, wg_x, wg_y, wg_z;\n+\n+  /* TODO: host-side memory management of group and private segment\n+     memory.  Agents in general are less likely to support efficient dynamic mem\n+     allocation.  */\n+  if (dp->group_segment_size > 0\n+      && posix_memalign (&group_base_ptr, GROUP_SEGMENT_ALIGN,\n+\t\t\t dp->group_segment_size) != 0)\n+    phsa_fatal_error (3);\n+\n+  context->group_segment_start_addr = (size_t) group_base_ptr;\n+\n+  /* HSA seems to allow the WG size to be larger than the grid size.  We need\n+     to saturate the effective WG size to the grid size to prevent the extra WIs\n+     from executing.  */\n+  size_t sat_wg_size_x, sat_wg_size_y, sat_wg_size_z, sat_wg_size;\n+  sat_wg_size_x = MIN (dp->workgroup_size_x, dp->grid_size_x);\n+  sat_wg_size_y = MIN (dp->workgroup_size_y, dp->grid_size_y);\n+  sat_wg_size_z = MIN (dp->workgroup_size_z, dp->grid_size_z);\n+  sat_wg_size = sat_wg_size_x * sat_wg_size_y * sat_wg_size_z;\n+\n+#ifdef BENCHMARK_PHSA_RT\n+  wi_total = (uint64_t) dp->grid_size_x\n+\t     * (dp->grid_size_y > 0 ? dp->grid_size_y : 1)\n+\t     * (dp->grid_size_z > 0 ? dp->grid_size_z : 1);\n+#endif\n+\n+  context->wg_min_x = context->wg_min_y = context->wg_min_z = 0;\n+\n+  int dims = dp->setup & 0x3;\n+\n+  context->wg_max_x = ((uint64_t) dp->grid_size_x + dp->workgroup_size_x - 1)\n+\t\t      / dp->workgroup_size_x;\n+\n+  context->wg_max_y\n+    = dims < 2 ? 1 : ((uint64_t) dp->grid_size_y + dp->workgroup_size_y - 1)\n+\t\t       / dp->workgroup_size_y;\n+\n+  context->wg_max_z\n+    = dims < 3 ? 1 : ((uint64_t) dp->grid_size_z + dp->workgroup_size_z - 1)\n+\t\t       / dp->workgroup_size_z;\n+\n+#ifdef DEBUG_PHSA_RT\n+  printf (\"### launching work-groups %lu/%lu/%lu to %lu/%lu/%lu with \"\n+\t  \"wg size %lu/%lu/%lu grid size %u/%u/%u\\n\",\n+\t  context->wg_min_x, context->wg_min_y, context->wg_min_z,\n+\t  context->wg_max_x, context->wg_max_y, context->wg_max_z,\n+\t  sat_wg_size_x, sat_wg_size_y, sat_wg_size_z, dp->grid_size_x,\n+\t  dp->grid_size_y, dp->grid_size_z);\n+#endif\n+\n+  PHSAWorkItem wi;\n+  PHSAWorkGroup wg;\n+  wi.wg = &wg;\n+  wi.x = wi.y = wi.z = 0;\n+  wi.launch_data = context;\n+\n+#ifdef BENCHMARK_PHSA_RT\n+  start_time = clock ();\n+  uint64_t wg_count = 0;\n+#endif\n+\n+  size_t wg_size = __hsail_workgroupsize (0, &wi)\n+\t\t   * __hsail_workgroupsize (1, &wi)\n+\t\t   * __hsail_workgroupsize (2, &wi);\n+\n+  void *private_base_ptr = NULL;\n+  if (dp->private_segment_size > 0\n+      && posix_memalign (&private_base_ptr, PRIVATE_SEGMENT_ALIGN,\n+\t\t\t dp->private_segment_size * wg_size)\n+\t   != 0)\n+    phsa_fatal_error (3);\n+\n+  wg.alloca_stack_p = dp->private_segment_size * wg_size;\n+  wg.alloca_frame_p = wg.alloca_stack_p;\n+\n+  wg.private_base_ptr = private_base_ptr;\n+  wg.group_base_ptr = group_base_ptr;\n+\n+#ifdef DEBUG_PHSA_RT\n+  printf (\"priv seg size %u wg_size %lu @ %p\\n\", dp->private_segment_size,\n+\t  wg_size, private_base_ptr);\n+#endif\n+\n+  for (wg_z = context->wg_min_z; wg_z < context->wg_max_z; ++wg_z)\n+    for (wg_y = context->wg_min_y; wg_y < context->wg_max_y; ++wg_y)\n+      for (wg_x = context->wg_min_x; wg_x < context->wg_max_x; ++wg_x)\n+\t{\n+\t  wi.wg->x = wg_x;\n+\t  wi.wg->y = wg_y;\n+\t  wi.wg->z = wg_z;\n+\n+\t  context->kernel (context->kernarg_addr, &wi, group_base_ptr,\n+\t\t\t   private_base_ptr);\n+\n+#if defined (BENCHMARK_PHSA_RT)\n+\t  wg_count++;\n+\t  if (wg_count % 1000000 == 0)\n+\t    {\n+\t      clock_t spent_time = clock () - start_time;\n+\t      uint64_t wi_count = wg_x * sat_wg_size_x + wg_y * sat_wg_size_y\n+\t\t\t\t  + wg_z * sat_wg_size_z;\n+\t      double spent_time_sec = (double) spent_time / CLOCKS_PER_SEC;\n+\t      double wis_per_sec = wi_count / spent_time_sec;\n+\t      uint64_t eta_sec = (wi_total - wi_count) / wis_per_sec;\n+\n+\t      printf (\"%lu WIs executed in %lus (%lu WIs/s, ETA in %lu s)\\n\",\n+\t\t      wi_count, (uint64_t) spent_time_sec,\n+\t\t      (uint64_t) wis_per_sec, (uint64_t) eta_sec);\n+\t    }\n+#endif\n+\t}\n+\n+#ifdef BENCHMARK_PHSA_RT\n+  clock_t spent_time = clock () - start_time;\n+  double spent_time_sec = (double) spent_time / CLOCKS_PER_SEC;\n+  double wis_per_sec = wi_total / spent_time_sec;\n+\n+  printf (\"### %lu WIs executed in %lu s (%lu WIs / s)\\n\", wi_total,\n+\t  (uint64_t) spent_time_sec, (uint64_t) wis_per_sec);\n+#endif\n+\n+  if (dp->group_segment_size > 0)\n+    free (group_base_ptr);\n+\n+  free (private_base_ptr);\n+  private_base_ptr = NULL;\n+}\n+\n+/* gccbrig generates the following from each HSAIL kernel:\n+\n+   1) The actual kernel function (a single work-item kernel or a work-group\n+      function) generated from HSAIL (BRIG).\n+\n+\t static void _Kernel (void* args, void* context, void* group_base_ptr)\n+\t {\n+\t   ...\n+\t }\n+\n+  2) A public facing kernel function that is called from the PHSA runtime:\n+\n+   a) A single work-item function (that requires fibers for multi-WI):\n+\n+      void Kernel (void* context)\n+      {\n+\t __launch_launch_kernel (_Kernel, context);\n+      }\n+\n+      or\n+\n+    b) a when gccbrig could generate a work-group function:\n+\n+      void Kernel (void* context)\n+      {\n+\t\t__hsail_launch_wg_function (_Kernel, context);\n+      }\n+*/\n+\n+#ifdef HAVE_FIBERS\n+\n+void\n+__hsail_launch_kernel (gccbrigKernelFunc kernel, PHSAKernelLaunchData *context,\n+\t\t       void *group_base_ptr)\n+{\n+  context->kernel = kernel;\n+  phsa_spawn_work_items (context, group_base_ptr);\n+}\n+#endif\n+\n+void\n+__hsail_launch_wg_function (gccbrigKernelFunc kernel,\n+\t\t\t    PHSAKernelLaunchData *context, void *group_base_ptr)\n+{\n+  context->kernel = kernel;\n+  phsa_execute_work_groups (context, group_base_ptr);\n+}\n+\n+uint32_t\n+__hsail_workitemabsid (uint32_t dim, PHSAWorkItem *context)\n+{\n+  hsa_kernel_dispatch_packet_t *dp = context->launch_data->dp;\n+\n+  uint32_t id;\n+  switch (dim)\n+    {\n+    default:\n+    case 0:\n+      /* Overflow semantics in the case of WG dim > grid dim.  */\n+      id = ((uint64_t) context->wg->x * dp->workgroup_size_x + context->x)\n+\t   % dp->grid_size_x;\n+      break;\n+    case 1:\n+      id = ((uint64_t) context->wg->y * dp->workgroup_size_y + context->y)\n+\t   % dp->grid_size_y;\n+      break;\n+    case 2:\n+      id = ((uint64_t) context->wg->z * dp->workgroup_size_z + context->z)\n+\t   % dp->grid_size_z;\n+      break;\n+    }\n+  return id;\n+}\n+\n+uint64_t\n+__hsail_workitemabsid_u64 (uint32_t dim, PHSAWorkItem *context)\n+{\n+  hsa_kernel_dispatch_packet_t *dp = context->launch_data->dp;\n+\n+  uint64_t id;\n+  switch (dim)\n+    {\n+    default:\n+    case 0:\n+      /* Overflow semantics in the case of WG dim > grid dim.  */\n+      id = ((uint64_t) context->wg->x * dp->workgroup_size_x + context->x)\n+\t   % dp->grid_size_x;\n+      break;\n+    case 1:\n+      id = ((uint64_t) context->wg->y * dp->workgroup_size_y + context->y)\n+\t   % dp->grid_size_y;\n+      break;\n+    case 2:\n+      id = ((uint64_t) context->wg->z * dp->workgroup_size_z + context->z)\n+\t   % dp->grid_size_z;\n+      break;\n+    }\n+  return id;\n+}\n+\n+\n+uint32_t\n+__hsail_workitemid (uint32_t dim, PHSAWorkItem *context)\n+{\n+  PHSAWorkItem *c = (PHSAWorkItem *) context;\n+  hsa_kernel_dispatch_packet_t *dp = context->launch_data->dp;\n+\n+  /* The number of dimensions is in the two least significant bits.  */\n+  int dims = dp->setup & 0x3;\n+\n+  uint32_t id;\n+  switch (dim)\n+    {\n+    default:\n+    case 0:\n+      id = c->x;\n+      break;\n+    case 1:\n+      id = dims < 2 ? 0 : c->y;\n+      break;\n+    case 2:\n+      id = dims < 3 ? 0 : c->z;\n+      break;\n+    }\n+  return id;\n+}\n+\n+uint32_t\n+__hsail_gridgroups (uint32_t dim, PHSAWorkItem *context)\n+{\n+  hsa_kernel_dispatch_packet_t *dp = context->launch_data->dp;\n+  int dims = dp->setup & 0x3;\n+\n+  uint32_t id;\n+  switch (dim)\n+    {\n+    default:\n+    case 0:\n+      id = (dp->grid_size_x + dp->workgroup_size_x - 1) / dp->workgroup_size_x;\n+      break;\n+    case 1:\n+      id = dims < 2 ? 1 : (dp->grid_size_y + dp->workgroup_size_y - 1)\n+\t\t\t    / dp->workgroup_size_y;\n+      break;\n+    case 2:\n+      id = dims < 3 ? 1 : (dp->grid_size_z + dp->workgroup_size_z - 1)\n+\t\t\t    / dp->workgroup_size_z;\n+      break;\n+    }\n+  return id;\n+}\n+\n+uint32_t\n+__hsail_workitemflatid (PHSAWorkItem *c)\n+{\n+  hsa_kernel_dispatch_packet_t *dp = c->launch_data->dp;\n+\n+  return c->x + c->y * dp->workgroup_size_x\n+\t + c->z * dp->workgroup_size_x * dp->workgroup_size_y;\n+}\n+\n+uint32_t\n+__hsail_currentworkitemflatid (PHSAWorkItem *c)\n+{\n+  hsa_kernel_dispatch_packet_t *dp = c->launch_data->dp;\n+\n+  return c->x + c->y * __hsail_currentworkgroupsize (0, c)\n+\t + c->z * __hsail_currentworkgroupsize (0, c)\n+\t     * __hsail_currentworkgroupsize (1, c);\n+}\n+\n+void\n+__hsail_setworkitemid (uint32_t dim, uint32_t id, PHSAWorkItem *context)\n+{\n+  switch (dim)\n+    {\n+    default:\n+    case 0:\n+      context->x = id;\n+      break;\n+    case 1:\n+      context->y = id;\n+      break;\n+    case 2:\n+      context->z = id;\n+      break;\n+    }\n+}\n+\n+uint64_t\n+__hsail_workitemflatabsid_u64 (PHSAWorkItem *context)\n+{\n+  PHSAWorkItem *c = (PHSAWorkItem *) context;\n+  hsa_kernel_dispatch_packet_t *dp = context->launch_data->dp;\n+\n+  /* Work-item flattened absolute ID = ID0 + ID1 * max0 + ID2 * max0 * max1.  */\n+  uint64_t id0 = __hsail_workitemabsid (0, context);\n+  uint64_t id1 = __hsail_workitemabsid (1, context);\n+  uint64_t id2 = __hsail_workitemabsid (2, context);\n+\n+  uint64_t max0 = dp->grid_size_x;\n+  uint64_t max1 = dp->grid_size_y;\n+  uint64_t id = id0 + id1 * max0 + id2 * max0 * max1;\n+\n+  return id;\n+}\n+\n+uint32_t\n+__hsail_workitemflatabsid_u32 (PHSAWorkItem *context)\n+{\n+  PHSAWorkItem *c = (PHSAWorkItem *) context;\n+  hsa_kernel_dispatch_packet_t *dp = context->launch_data->dp;\n+\n+  /* work-item flattened absolute ID = ID0 + ID1 * max0 + ID2 * max0 * max1.  */\n+  uint64_t id0 = __hsail_workitemabsid (0, context);\n+  uint64_t id1 = __hsail_workitemabsid (1, context);\n+  uint64_t id2 = __hsail_workitemabsid (2, context);\n+\n+  uint64_t max0 = dp->grid_size_x;\n+  uint64_t max1 = dp->grid_size_y;\n+  uint64_t id = id0 + id1 * max0 + id2 * max0 * max1;\n+  return (uint32_t) id;\n+}\n+\n+uint32_t\n+__hsail_currentworkgroupsize (uint32_t dim, PHSAWorkItem *wi)\n+{\n+  hsa_kernel_dispatch_packet_t *dp = wi->launch_data->dp;\n+  uint32_t wg_size = 0;\n+  switch (dim)\n+    {\n+    default:\n+    case 0:\n+      if ((uint64_t) wi->wg->x < dp->grid_size_x / dp->workgroup_size_x)\n+\twg_size = dp->workgroup_size_x; /* Full WG.  */\n+      else\n+\twg_size = dp->grid_size_x % dp->workgroup_size_x; /* Partial WG.  */\n+      break;\n+    case 1:\n+      if ((uint64_t) wi->wg->y < dp->grid_size_y / dp->workgroup_size_y)\n+\twg_size = dp->workgroup_size_y; /* Full WG.  */\n+      else\n+\twg_size = dp->grid_size_y % dp->workgroup_size_y; /* Partial WG.  */\n+      break;\n+    case 2:\n+      if ((uint64_t) wi->wg->z < dp->grid_size_z / dp->workgroup_size_z)\n+\twg_size = dp->workgroup_size_z; /* Full WG.  */\n+      else\n+\twg_size = dp->grid_size_z % dp->workgroup_size_z; /* Partial WG.  */\n+      break;\n+    }\n+  return wg_size;\n+}\n+\n+uint32_t\n+__hsail_workgroupsize (uint32_t dim, PHSAWorkItem *wi)\n+{\n+  hsa_kernel_dispatch_packet_t *dp = wi->launch_data->dp;\n+  switch (dim)\n+    {\n+    default:\n+    case 0:\n+      return dp->workgroup_size_x;\n+    case 1:\n+      return dp->workgroup_size_y;\n+    case 2:\n+      return dp->workgroup_size_z;\n+    }\n+}\n+\n+uint32_t\n+__hsail_gridsize (uint32_t dim, PHSAWorkItem *wi)\n+{\n+  hsa_kernel_dispatch_packet_t *dp = wi->launch_data->dp;\n+  switch (dim)\n+    {\n+    default:\n+    case 0:\n+      return dp->grid_size_x;\n+    case 1:\n+      return dp->grid_size_y;\n+    case 2:\n+      return dp->grid_size_z;\n+    }\n+}\n+\n+uint32_t\n+__hsail_workgroupid (uint32_t dim, PHSAWorkItem *wi)\n+{\n+  switch (dim)\n+    {\n+    default:\n+    case 0:\n+      return wi->wg->x;\n+    case 1:\n+      return wi->wg->y;\n+    case 2:\n+      return wi->wg->z;\n+    }\n+}\n+\n+uint32_t\n+__hsail_dim (PHSAWorkItem *wi)\n+{\n+  hsa_kernel_dispatch_packet_t *dp = wi->launch_data->dp;\n+  return dp->setup & 0x3;\n+}\n+\n+uint64_t\n+__hsail_packetid (PHSAWorkItem *wi)\n+{\n+  return wi->launch_data->packet_id;\n+}\n+\n+uint32_t\n+__hsail_packetcompletionsig_sig32 (PHSAWorkItem *wi)\n+{\n+  return (uint32_t) wi->launch_data->dp->completion_signal.handle;\n+}\n+\n+uint64_t\n+__hsail_packetcompletionsig_sig64 (PHSAWorkItem *wi)\n+{\n+  return (uint64_t) (wi->launch_data->dp->completion_signal.handle);\n+}\n+\n+#ifdef HAVE_FIBERS\n+void\n+__hsail_barrier (PHSAWorkItem *wi)\n+{\n+  fiber_barrier_reach ((fiber_barrier_t *) wi->launch_data->wg_sync_barrier);\n+}\n+#endif\n+\n+/* Return a 32b private segment address that points to a dynamically\n+   allocated chunk of 'size' with 'align'.\n+\n+   Allocates the space from the end of the private segment allocated\n+   for the whole work group.  In implementations with separate private\n+   memories per WI, we will need to have a stack pointer per WI.  But in\n+   the current implementation, the segment is shared, so we possibly\n+   save some space in case all WIs do not call the alloca.\n+\n+   The \"alloca frames\" are organized as follows:\n+\n+   wg->alloca_stack_p points to the last allocated data (initially\n+   outside the private segment)\n+   wg->alloca_frame_p points to the first address _outside_ the current\n+   function's allocations (initially to the same as alloca_stack_p)\n+\n+   The data is allocated downwards from the end of the private segment.\n+\n+   In the beginning of a new function which has allocas, a new alloca\n+   frame is pushed which adds the current alloca_frame_p (the current\n+   function's frame starting point) to the top of the alloca stack and\n+   alloca_frame_p is set to the current stack position.\n+\n+   At the exit points of a function with allocas, the alloca frame\n+   is popped before returning.  This involves popping the alloca_frame_p\n+   to the one of the previous function in the call stack, and alloca_stack_p\n+   similarly, to the position of the last word alloca'd by the previous\n+   function.\n+ */\n+\n+uint32_t\n+__hsail_alloca (uint32_t size, uint32_t align, PHSAWorkItem *wi)\n+{\n+  volatile PHSAWorkGroup *wg = wi->wg;\n+  uint32_t new_pos = wg->alloca_stack_p - size;\n+  while (new_pos % align != 0)\n+    new_pos--;\n+  wg->alloca_stack_p = new_pos;\n+\n+#ifdef DEBUG_ALLOCA\n+  printf (\"--- alloca (%u, %u) sp @%u fp @%u\\n\", size, align,\n+\t  wg->alloca_stack_p, wg->alloca_frame_p);\n+#endif\n+  return new_pos;\n+}\n+\n+/* Initializes a new \"alloca frame\" in the private segment.\n+   This should be called at all the function entry points in case\n+   the function contains at least one call to alloca.  */\n+\n+void\n+__hsail_alloca_push_frame (PHSAWorkItem *wi)\n+{\n+  volatile PHSAWorkGroup *wg = wi->wg;\n+\n+  /* Store the alloca_frame_p without any alignment padding so\n+     we know exactly where the previous frame ended after popping\n+     it.  */\n+#ifdef DEBUG_ALLOCA\n+  printf (\"--- push frame \");\n+#endif\n+  uint32_t last_word_offs = __hsail_alloca (4, 1, wi);\n+  memcpy (wg->private_base_ptr + last_word_offs,\n+\t  (const void *) &wg->alloca_frame_p, 4);\n+  wg->alloca_frame_p = last_word_offs;\n+\n+#ifdef DEBUG_ALLOCA\n+  printf (\"--- sp @%u fp @%u\\n\", wg->alloca_stack_p, wg->alloca_frame_p);\n+#endif\n+}\n+\n+/* Frees the current \"alloca frame\" and restores the frame\n+   pointer.\n+   This should be called at all the function return points in case\n+   the function contains at least one call to alloca.  Restores the\n+   alloca stack to the condition it was before pushing the frame\n+   the last time.  */\n+void\n+__hsail_alloca_pop_frame (PHSAWorkItem *wi)\n+{\n+  volatile PHSAWorkGroup *wg = wi->wg;\n+\n+  wg->alloca_stack_p = wg->alloca_frame_p;\n+  memcpy (&wg->alloca_frame_p,\n+\t  (const void *) (wg->private_base_ptr + wg->alloca_frame_p), 4);\n+  /* Now frame_p points to the beginning of the previous function's\n+     frame and stack_p to its end.  */\n+\n+  wg->alloca_stack_p += 4;\n+\n+#ifdef DEBUG_ALLOCA\n+  printf (\"--- pop frame sp @%u fp @%u\\n\", wg->alloca_stack_p,\n+\t  wg->alloca_frame_p);\n+#endif\n+}"}, {"sha": "28aeaf3a3e29b17b9ac3e53a1f83fedfd133a91d", "filename": "libhsail-rt/target-config.h.in", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Ftarget-config.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd1486ce58297190c2b924e96e716087139a8b5/libhsail-rt%2Ftarget-config.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Ftarget-config.h.in?ref=5fd1486ce58297190c2b924e96e716087139a8b5", "patch": "@@ -0,0 +1,68 @@\n+/* target-config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#undef HAVE_DLFCN_H\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#undef HAVE_INTTYPES_H\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#undef HAVE_MEMORY_H\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#undef HAVE_STDINT_H\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#undef HAVE_STDLIB_H\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#undef HAVE_STRINGS_H\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#undef HAVE_STRING_H\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#undef HAVE_SYS_STAT_H\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#undef HAVE_SYS_TYPES_H\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#undef HAVE_UNISTD_H\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#undef LT_OBJDIR\n+\n+/* Name of package */\n+#undef PACKAGE\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#undef PACKAGE_BUGREPORT\n+\n+/* Define to the full name of this package. */\n+#undef PACKAGE_NAME\n+\n+/* Define to the full name and version of this package. */\n+#undef PACKAGE_STRING\n+\n+/* Define to the one symbol short name of this package. */\n+#undef PACKAGE_TARNAME\n+\n+/* Define to the home page for this package. */\n+#undef PACKAGE_URL\n+\n+/* Define to the version of this package. */\n+#undef PACKAGE_VERSION\n+\n+/* The size of `int', as computed by sizeof. */\n+#undef SIZEOF_INT\n+\n+/* The size of `void*', as computed by sizeof. */\n+#undef SIZEOF_VOIDP\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#undef STDC_HEADERS\n+\n+/* Version number of package */\n+#undef VERSION"}]}