{"sha": "f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcxNWE1YmQzZmI2YmI3MGMxMWIyOWRjMmI1NGYyNDU5ZWQzNmJmYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-03-16T18:28:47Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-11T09:53:42Z"}, "message": "[Ada] Consolidate handling of implicit dereferences into semantic analysis\n\n2020-06-11  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* checks.adb (Build_Discriminant_Checks): Build an explicit\n\tdereference when the type is an access type.\n\t* exp_atag.adb (Build_CW_Membership): Add explicit dereferences.\n\t(Build_Get_Access_Level): Likewise.\n\t(Build_Get_Alignment): Likewise.\n\t(Build_Inherit_Prims): Likewise.\n\t(Build_Get_Transportable): Likewise.\n\t(Build_Set_Size_Function): Likewise.\n\t* exp_ch3.adb (Build_Offset_To_Top_Function): Likewise.\n\t* exp_ch4.adb (Expand_Allocator_Expression): Likewise.\n\t(Expand_N_Indexed_Component ): Remove code dealing with implicit\n\tdereferences.\n\t(Expand_N_Selected_Component): Likewise.\n\t(Expand_N_Slice): Likewise.\n\t* exp_ch9.adb (Add_Formal_Renamings): Add explicit dereference.\n\t(Expand_Accept_Declarations): Likewise.\n\t(Build_Simple_Entry_Call): Remove code dealing with implicit\n\tdereferences.\n\t(Expand_N_Requeue_Statement): Likewise.\n\t* exp_disp.adb (Expand_Dispatching_Call): Build an explicit\n\tdereference when the controlling type is an access type.\n\t* exp_spark.adb (Expand_SPARK_N_Selected_Component): Delete.\n\t(Expand_SPARK_N_Slice_Or_Indexed_Component): Likewise.\n\t(Expand_SPARK): Do not call them.\n\t* sem_ch4.adb (Process_Implicit_Dereference_Prefix): Delete.\n\t(Process_Indexed_Component): Call Implicitly_Designated_Type\n\tto get the designated type for an implicit dereference.\n\t(Analyze_Overloaded_Selected_Component): Do not insert an\n\texplicit dereference here.\n\t(Analyze_Selected_Component): Likewise.\n\t(Analyze_Slice): Call Implicitly_Designated_Type to get the\n\tdesignated type for an implicit dereference.\n\t* sem_ch8.adb (Has_Components): New predicate extracted from...\n\t(Is_Appropriate_For_Record): ...this.  Delete.\n\t(Is_Appropriate_For_Entry_Prefix): Likewise.\n\t(Analyze_Renamed_Entry): Deal with implicit dereferences.\n\t(Find_Selected_Component): Do not insert an explicit dereference\n\there.  Call Implicitly_Designated_Type to get the designated type\n\tfor an implicit dereference.  Call Has_Components, Is_Task_Type\n\tand Is_Protected_Type directly.  Adjust test for error.\n\t* sem_res.adb (Resolve_Implicit_Dereference): New procedure.\n\t(Resolve_Call): Call Resolve_Indexed_Component last.\n\t(Resolve_Entry): Call Resolve_Implicit_Dereference on the prefix.\n\t(Resolve_Indexed_Component): Call Implicitly_Designated_Type to\n\tget the designated type for an implicit dereference and\n\tResolve_Implicit_Dereference on the prefix at the end.\n\t(Resolve_Selected_Component): Likewise.\n\t(Resolve_Slice): Likewise.  Do not apply access checks here.\n\t* sem_util.ads (Implicitly_Designated_Type): Declare.\n\t* sem_util.adb (Copy_And_Maybe_Dereference): Simplify.\n\t(Implicitly_Designated_Type): New function.\n\t(Object_Access_Level): Fix typo.\n\t* sem_warn.adb (Check_Unset_Reference): Test Comes_From_Source\n\ton the original node.", "tree": {"sha": "eec29227b0603a20d1cec4cf885710cc93b7b374", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eec29227b0603a20d1cec4cf885710cc93b7b374"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7cb99f885d2d6d520ef8ff0ff35e0158f2c6264", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7cb99f885d2d6d520ef8ff0ff35e0158f2c6264", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7cb99f885d2d6d520ef8ff0ff35e0158f2c6264"}], "stats": {"total": 540, "additions": 174, "deletions": 366}, "files": [{"sha": "641a5b28174caba348de06b04be9d3f8a5e6e5ef", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "patch": "@@ -3964,6 +3964,15 @@ package body Checks is\n                Duplicate_Subexpr_No_Checks\n                  (Aggregate_Discriminant_Val (Disc_Ent));\n \n+         elsif Is_Access_Type (Etype (N)) then\n+            Dref :=\n+              Make_Selected_Component (Loc,\n+                Prefix        =>\n+                  Make_Explicit_Dereference (Loc,\n+                    Duplicate_Subexpr_No_Checks (N, Name_Req => True)),\n+                Selector_Name => Make_Identifier (Loc, Chars (Disc_Ent)));\n+\n+            Set_Is_In_Discriminant_Check (Dref);\n          else\n             Dref :=\n               Make_Selected_Component (Loc,"}, {"sha": "bdd3f055f81f32394e88a0479109ec3f87fbc903", "filename": "gcc/ada/exp_atag.adb", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fexp_atag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fexp_atag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.adb?ref=f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "patch": "@@ -229,14 +229,18 @@ package body Exp_Atag is\n             Make_Op_Subtract (Loc,\n               Left_Opnd =>\n                 Make_Selected_Component (Loc,\n-                  Prefix        => New_Occurrence_Of (Obj_TSD, Loc),\n+                  Prefix        =>\n+                    Make_Explicit_Dereference (Loc,\n+                      New_Occurrence_Of (Obj_TSD, Loc)),\n                   Selector_Name =>\n                      New_Occurrence_Of\n                        (RTE_Record_Component (RE_Idepth), Loc)),\n \n                Right_Opnd =>\n                  Make_Selected_Component (Loc,\n-                   Prefix        => New_Occurrence_Of (Typ_TSD, Loc),\n+                   Prefix        =>\n+                     Make_Explicit_Dereference (Loc,\n+                       New_Occurrence_Of (Typ_TSD, Loc)),\n                    Selector_Name =>\n                      New_Occurrence_Of\n                        (RTE_Record_Component (RE_Idepth), Loc)))),\n@@ -255,7 +259,9 @@ package body Exp_Atag is\n                 Make_Indexed_Component (Loc,\n                   Prefix      =>\n                     Make_Selected_Component (Loc,\n-                      Prefix        => New_Occurrence_Of (Obj_TSD, Loc),\n+                      Prefix        =>\n+                        Make_Explicit_Dereference (Loc,\n+                          New_Occurrence_Of (Obj_TSD, Loc)),\n                       Selector_Name =>\n                         New_Occurrence_Of\n                           (RTE_Record_Component (RE_Tags_Table), Loc)),\n@@ -293,8 +299,9 @@ package body Exp_Atag is\n       return\n         Make_Selected_Component (Loc,\n           Prefix =>\n-            Build_TSD (Loc,\n-              Unchecked_Convert_To (RTE (RE_Address), Tag_Node)),\n+            Make_Explicit_Dereference (Loc,\n+              Build_TSD (Loc,\n+                Unchecked_Convert_To (RTE (RE_Address), Tag_Node))),\n           Selector_Name =>\n             New_Occurrence_Of\n               (RTE_Record_Component (RE_Access_Level), Loc));\n@@ -311,8 +318,10 @@ package body Exp_Atag is\n    begin\n       return\n         Make_Selected_Component (Loc,\n-          Prefix        =>\n-            Build_TSD (Loc, Unchecked_Convert_To (RTE (RE_Address), Tag_Node)),\n+          Prefix =>\n+            Make_Explicit_Dereference (Loc,\n+              Build_TSD (Loc,\n+                Unchecked_Convert_To (RTE (RE_Address), Tag_Node))),\n           Selector_Name =>\n             New_Occurrence_Of (RTE_Record_Component (RE_Alignment), Loc));\n    end Build_Get_Alignment;\n@@ -639,7 +648,8 @@ package body Exp_Atag is\n                  Prefix =>\n                    Make_Selected_Component (Loc,\n                      Prefix =>\n-                       Build_DT (Loc, New_Tag_Node),\n+                       Make_Explicit_Dereference (Loc,\n+                         Build_DT (Loc, New_Tag_Node)),\n                      Selector_Name =>\n                        New_Occurrence_Of\n                          (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n@@ -651,7 +661,8 @@ package body Exp_Atag is\n                  Prefix =>\n                    Make_Selected_Component (Loc,\n                      Prefix =>\n-                       Build_DT (Loc, Old_Tag_Node),\n+                       Make_Explicit_Dereference (Loc,\n+                         Build_DT (Loc, Old_Tag_Node)),\n                      Selector_Name =>\n                        New_Occurrence_Of\n                          (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n@@ -728,8 +739,9 @@ package body Exp_Atag is\n       return\n         Make_Selected_Component (Loc,\n           Prefix =>\n-            Build_TSD (Loc,\n-              Unchecked_Convert_To (RTE (RE_Address), Tag_Node)),\n+            Make_Explicit_Dereference (Loc,\n+              Build_TSD (Loc,\n+                Unchecked_Convert_To (RTE (RE_Address), Tag_Node))),\n           Selector_Name =>\n             New_Occurrence_Of\n               (RTE_Record_Component (RE_Transportable), Loc));\n@@ -884,8 +896,9 @@ package body Exp_Atag is\n           Name =>\n             Make_Selected_Component (Loc,\n               Prefix =>\n-                Build_TSD (Loc,\n-                  Unchecked_Convert_To (RTE (RE_Address), Tag_Node)),\n+                Make_Explicit_Dereference (Loc,\n+                  Build_TSD (Loc,\n+                    Unchecked_Convert_To (RTE (RE_Address), Tag_Node))),\n               Selector_Name =>\n                 New_Occurrence_Of\n                   (RTE_Record_Component (RE_Size_Func), Loc)),"}, {"sha": "7d13cd6cd2ba62aa7557e54841ac7cdba9cef71d", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "patch": "@@ -2257,8 +2257,9 @@ package body Exp_Ch3 is\n                           Prefix         =>\n                             Make_Selected_Component (Loc,\n                               Prefix        =>\n-                                Unchecked_Convert_To (Acc_Type,\n-                                  Make_Identifier (Loc, Name_uO)),\n+                                Make_Explicit_Dereference (Loc,\n+                                  Unchecked_Convert_To (Acc_Type,\n+                                    Make_Identifier (Loc, Name_uO))),\n                               Selector_Name =>\n                                 New_Occurrence_Of (Iface_Comp, Loc)),\n                           Attribute_Name => Name_Position))))));"}, {"sha": "7a84215366f0e3df848b185db5601c1d0db792ab", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 6, "deletions": 47, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "patch": "@@ -1073,7 +1073,9 @@ package body Exp_Ch4 is\n \n          elsif Is_Tagged_Type (T) and then not Is_Class_Wide_Type (T) then\n             TagT := T;\n-            TagR := New_Occurrence_Of (Temp, Loc);\n+            TagR :=\n+              Make_Explicit_Dereference (Loc,\n+                Prefix => New_Occurrence_Of (Temp, Loc));\n \n          elsif Is_Private_Type (T)\n            and then Is_Tagged_Type (Underlying_Type (T))\n@@ -6868,7 +6870,6 @@ package body Exp_Ch4 is\n       Typ : constant Entity_Id  := Etype (N);\n       P   : constant Node_Id    := Prefix (N);\n       T   : constant Entity_Id  := Etype (P);\n-      Atp : Entity_Id;\n \n    begin\n       --  A special optimization, if we have an indexed component that is\n@@ -6917,20 +6918,6 @@ package body Exp_Ch4 is\n          Make_Build_In_Place_Iface_Call_In_Anonymous_Context (P);\n       end if;\n \n-      --  If the prefix is an access type, then we unconditionally rewrite if\n-      --  as an explicit dereference. This simplifies processing for several\n-      --  cases, including packed array cases and certain cases in which checks\n-      --  must be generated. We used to try to do this only when it was\n-      --  necessary, but it cleans up the code to do it all the time.\n-\n-      if Is_Access_Type (T) then\n-         Insert_Explicit_Dereference (P);\n-         Analyze_And_Resolve (P, Designated_Type (T));\n-         Atp := Designated_Type (T);\n-      else\n-         Atp := T;\n-      end if;\n-\n       --  Generate index and validity checks\n \n       Generate_Index_Checks (N);\n@@ -6942,8 +6929,8 @@ package body Exp_Ch4 is\n       --  If selecting from an array with atomic components, and atomic sync\n       --  is not suppressed for this array type, set atomic sync flag.\n \n-      if (Has_Atomic_Components (Atp)\n-           and then not Atomic_Synchronization_Disabled (Atp))\n+      if (Has_Atomic_Components (T)\n+           and then not Atomic_Synchronization_Disabled (T))\n         or else (Is_Atomic (Typ)\n                   and then not Atomic_Synchronization_Disabled (Typ))\n         or else (Is_Entity_Name (P)\n@@ -10580,7 +10567,7 @@ package body Exp_Ch4 is\n       Par   : constant Node_Id    := Parent (N);\n       P     : constant Node_Id    := Prefix (N);\n       S     : constant Node_Id    := Selector_Name (N);\n-      Ptyp  : Entity_Id           := Underlying_Type (Etype (P));\n+      Ptyp  : constant Entity_Id  := Underlying_Type (Etype (P));\n       Disc  : Entity_Id;\n       New_N : Node_Id;\n       Dcon  : Elmt_Id;\n@@ -10631,21 +10618,6 @@ package body Exp_Ch4 is\n    --  Start of processing for Expand_N_Selected_Component\n \n    begin\n-      --  Insert explicit dereference if required\n-\n-      if Is_Access_Type (Ptyp) then\n-\n-         --  First set prefix type to proper access type, in case it currently\n-         --  has a private (non-access) view of this type.\n-\n-         Set_Etype (P, Ptyp);\n-\n-         Insert_Explicit_Dereference (P);\n-         Analyze_And_Resolve (P, Designated_Type (Ptyp));\n-\n-         Ptyp := Etype (P);\n-      end if;\n-\n       --  Deal with discriminant check required\n \n       if Do_Discriminant_Check (N) then\n@@ -11018,23 +10990,10 @@ package body Exp_Ch4 is\n       --  Local variables\n \n       Pref     : constant Node_Id := Prefix (N);\n-      Pref_Typ : Entity_Id        := Etype (Pref);\n \n    --  Start of processing for Expand_N_Slice\n \n    begin\n-      --  Special handling for access types\n-\n-      if Is_Access_Type (Pref_Typ) then\n-         Pref_Typ := Designated_Type (Pref_Typ);\n-\n-         Rewrite (Pref,\n-           Make_Explicit_Dereference (Sloc (N),\n-            Prefix => Relocate_Node (Pref)));\n-\n-         Analyze_And_Resolve (Pref, Pref_Typ);\n-      end if;\n-\n       --  Ada 2005 (AI-318-02): If the prefix is a call to a build-in-place\n       --  function, then additional actuals must be passed.\n "}, {"sha": "3d417ff995cd45dafdee9d717efc3f7614b5104f", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "patch": "@@ -737,8 +737,9 @@ package body Exp_Ch9 is\n          Renamed_Formal :=\n            Make_Selected_Component (Loc,\n              Prefix        =>\n-               Unchecked_Convert_To (Entry_Parameters_Type (Ent),\n-                 Make_Identifier (Loc, Chars (Ptr))),\n+               Make_Explicit_Dereference (Loc,\n+                 Unchecked_Convert_To (Entry_Parameters_Type (Ent),\n+                   Make_Identifier (Loc, Chars (Ptr)))),\n              Selector_Name => New_Occurrence_Of (Comp, Loc));\n \n          Decl :=\n@@ -4523,12 +4524,6 @@ package body Exp_Ch9 is\n          Ent_Acc := Entry_Parameters_Type (Ent);\n          Conctyp := Etype (Concval);\n \n-         --  If prefix is an access type, dereference to obtain the task type\n-\n-         if Is_Access_Type (Conctyp) then\n-            Conctyp := Designated_Type (Conctyp);\n-         end if;\n-\n          --  Special case for protected subprogram calls\n \n          if Is_Protected_Type (Conctyp)\n@@ -6015,9 +6010,10 @@ package body Exp_Ch9 is\n                   Renamed_Formal :=\n                      Make_Selected_Component (Loc,\n                        Prefix        =>\n-                         Unchecked_Convert_To (\n-                           Entry_Parameters_Type (Ent),\n-                           New_Occurrence_Of (Ann, Loc)),\n+                         Make_Explicit_Dereference (Loc,\n+                           Unchecked_Convert_To (\n+                             Entry_Parameters_Type (Ent),\n+                             New_Occurrence_Of (Ann, Loc))),\n                        Selector_Name =>\n                          New_Occurrence_Of (Comp, Loc));\n \n@@ -10533,16 +10529,6 @@ package body Exp_Ch9 is\n       Extract_Entry (N, Concval, Ename, Index);\n       Conc_Typ := Etype (Concval);\n \n-      --  If the prefix is an access to class-wide type, dereference to get\n-      --  object and entry type.\n-\n-      if Is_Access_Type (Conc_Typ) then\n-         Conc_Typ := Designated_Type (Conc_Typ);\n-         Rewrite (Concval,\n-           Make_Explicit_Dereference (Loc, Relocate_Node (Concval)));\n-         Analyze_And_Resolve (Concval, Conc_Typ);\n-      end if;\n-\n       --  Examine the scope stack in order to find nearest enclosing protected\n       --  or task type. This will constitute our invocation source.\n "}, {"sha": "b57ba586062d3454fb9ada80b5bf1e78bd889b0f", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "patch": "@@ -1114,6 +1114,14 @@ package body Exp_Disp is\n       then\n          Controlling_Tag := Duplicate_Subexpr (Ctrl_Arg);\n \n+      elsif Is_Access_Type (Ctrl_Typ) then\n+         Controlling_Tag :=\n+           Make_Selected_Component (Loc,\n+             Prefix        =>\n+               Make_Explicit_Dereference (Loc,\n+                 Duplicate_Subexpr_Move_Checks (Ctrl_Arg)),\n+             Selector_Name => New_Occurrence_Of (DTC_Entity (Subp), Loc));\n+\n       else\n          Controlling_Tag :=\n            Make_Selected_Component (Loc,"}, {"sha": "b8b303c1f3a44a32f90e72d4bb914c212fff61da", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "patch": "@@ -69,12 +69,6 @@ package body Exp_SPARK is\n    procedure Expand_SPARK_N_Op_Ne (N : Node_Id);\n    --  Rewrite operator /= based on operator = when defined explicitly\n \n-   procedure Expand_SPARK_N_Selected_Component (N : Node_Id);\n-   --  Insert explicit dereference if required\n-\n-   procedure Expand_SPARK_N_Slice_Or_Indexed_Component (N : Node_Id);\n-   --  Insert explicit dereference if required\n-\n    ------------------\n    -- Expand_SPARK --\n    ------------------\n@@ -136,14 +130,6 @@ package body Exp_SPARK is\n                Expand_SPARK_N_Freeze_Type (Entity (N));\n             end if;\n \n-         when N_Indexed_Component\n-            | N_Slice\n-         =>\n-            Expand_SPARK_N_Slice_Or_Indexed_Component (N);\n-\n-         when N_Selected_Component =>\n-            Expand_SPARK_N_Selected_Component (N);\n-\n          --  In SPARK mode, no other constructs require expansion\n \n          when others =>\n@@ -481,40 +467,4 @@ package body Exp_SPARK is\n       end if;\n    end Expand_SPARK_Potential_Renaming;\n \n-   ---------------------------------------\n-   -- Expand_SPARK_N_Selected_Component --\n-   ---------------------------------------\n-\n-   procedure Expand_SPARK_N_Selected_Component (N : Node_Id) is\n-      Pref : constant Node_Id   := Prefix (N);\n-      Typ  : constant Entity_Id := Underlying_Type (Etype (Pref));\n-\n-   begin\n-      if Present (Typ) and then Is_Access_Type (Typ) then\n-\n-         --  First set prefix type to proper access type, in case it currently\n-         --  has a private (non-access) view of this type.\n-\n-         Set_Etype (Pref, Typ);\n-\n-         Insert_Explicit_Dereference (Pref);\n-         Analyze_And_Resolve (Pref, Designated_Type (Typ));\n-      end if;\n-   end Expand_SPARK_N_Selected_Component;\n-\n-   -----------------------------------------------\n-   -- Expand_SPARK_N_Slice_Or_Indexed_Component --\n-   -----------------------------------------------\n-\n-   procedure Expand_SPARK_N_Slice_Or_Indexed_Component (N : Node_Id) is\n-      Pref : constant Node_Id   := Prefix (N);\n-      Typ  : constant Entity_Id := Etype (Pref);\n-\n-   begin\n-      if Is_Access_Type (Typ) then\n-         Insert_Explicit_Dereference (Pref);\n-         Analyze_And_Resolve (Pref, Designated_Type (Typ));\n-      end if;\n-   end Expand_SPARK_N_Slice_Or_Indexed_Component;\n-\n end Exp_SPARK;"}, {"sha": "a710ba23f6d17434cd94c75371144ff1db5df033", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 10, "deletions": 101, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "patch": "@@ -171,6 +171,7 @@ package body Sem_Ch4 is\n    --  being called. The caller will have verified that the object is legal\n    --  for the call. If the remaining parameters match, the first parameter\n    --  will rewritten as a dereference if needed, prior to completing analysis.\n+\n    procedure Check_Misspelled_Selector\n      (Prefix : Entity_Id;\n       Sel    : Node_Id);\n@@ -276,20 +277,6 @@ package body Sem_Ch4 is\n    --  type is not directly visible. The routine uses this type to emit a more\n    --  informative message.\n \n-   function Process_Implicit_Dereference_Prefix\n-     (E : Entity_Id;\n-      P : Node_Id) return Entity_Id;\n-   --  Called when P is the prefix of an implicit dereference, denoting an\n-   --  object E. The function returns the designated type of the prefix, taking\n-   --  into account that the designated type of an anonymous access type may be\n-   --  a limited view, when the nonlimited view is visible.\n-   --\n-   --  If in semantics only mode (-gnatc or generic), the function also records\n-   --  that the prefix is a reference to E, if any. Normally, such a reference\n-   --  is generated only when the implicit dereference is expanded into an\n-   --  explicit one, but for consistency we must generate the reference when\n-   --  expansion is disabled as well.\n-\n    procedure Remove_Abstract_Operations (N : Node_Id);\n    --  Ada 2005: implementation of AI-310. An abstract non-dispatching\n    --  operation is not a candidate interpretation.\n@@ -2351,7 +2338,10 @@ package body Sem_Ch4 is\n \n       procedure Process_Function_Call;\n       --  Prefix in indexed component form is an overloadable entity, so the\n-      --  node is a function call. Reformat it as such.\n+      --  node is very likely a function call; reformat it as such. The only\n+      --  exception is a call to a parameterless function that returns an\n+      --  array type, or an access type thereof, in which case this will be\n+      --  undone later by Resolve_Call or Resolve_Entry_Call.\n \n       procedure Process_Indexed_Component;\n       --  Prefix in indexed component form is actually an indexed component.\n@@ -2462,7 +2452,7 @@ package body Sem_Ch4 is\n             if Is_Access_Type (Array_Type) then\n                Error_Msg_NW\n                  (Warn_On_Dereference, \"?d?implicit dereference\", N);\n-               Array_Type := Process_Implicit_Dereference_Prefix (Pent, P);\n+               Array_Type := Implicitly_Designated_Type (Array_Type);\n             end if;\n \n             if Is_Array_Type (Array_Type) then\n@@ -3898,18 +3888,6 @@ package body Sem_Ch4 is\n                   Set_Etype (Sel, Etype (Comp));\n                   Set_Etype (N,   Etype (Comp));\n                   Set_Etype (Nam, It.Typ);\n-\n-                  --  For access type case, introduce explicit dereference for\n-                  --  more uniform treatment of entry calls. Do this only once\n-                  --  if several interpretations yield an access type.\n-\n-                  if Is_Access_Type (Etype (Nam))\n-                    and then Nkind (Nam) /= N_Explicit_Dereference\n-                  then\n-                     Insert_Explicit_Dereference (Nam);\n-                     Error_Msg_NW\n-                       (Warn_On_Dereference, \"?d?implicit dereference\", N);\n-                  end if;\n                end if;\n \n                Next_Entity (Comp);\n@@ -4379,7 +4357,6 @@ package body Sem_Ch4 is\n       In_Scope      : Boolean;\n       Is_Private_Op : Boolean;\n       Parent_N      : Node_Id;\n-      Pent          : Entity_Id := Empty;\n       Prefix_Type   : Entity_Id;\n \n       Type_To_Use : Entity_Id;\n@@ -4408,7 +4385,8 @@ package body Sem_Ch4 is\n       --  indexed component rather than a function call.\n \n       function Has_Dereference (Nod : Node_Id) return Boolean;\n-      --  Check whether prefix includes a dereference at any level.\n+      --  Check whether prefix includes a dereference, explicit or implicit,\n+      --  at any recursive level.\n \n       --------------------------------\n       -- Find_Component_In_Instance --\n@@ -4520,10 +4498,6 @@ package body Sem_Ch4 is\n          if Nkind (Nod) = N_Explicit_Dereference then\n             return True;\n \n-         --  When expansion is disabled an explicit dereference may not have\n-         --  been inserted, but if this is an access type the indirection makes\n-         --  the call safe.\n-\n          elsif Is_Access_Type (Etype (Nod)) then\n             return True;\n \n@@ -4576,16 +4550,7 @@ package body Sem_Ch4 is\n \n          else\n             Error_Msg_NW (Warn_On_Dereference, \"?d?implicit dereference\", N);\n-\n-            if Is_Entity_Name (Name) then\n-               Pent := Entity (Name);\n-            elsif Nkind (Name) = N_Selected_Component\n-              and then Is_Entity_Name (Selector_Name (Name))\n-            then\n-               Pent := Entity (Selector_Name (Name));\n-            end if;\n-\n-            Prefix_Type := Process_Implicit_Dereference_Prefix (Pent, Name);\n+            Prefix_Type := Implicitly_Designated_Type (Prefix_Type);\n          end if;\n \n       --  If we have an explicit dereference of a remote access-to-class-wide\n@@ -4673,11 +4638,6 @@ package body Sem_Ch4 is\n          Set_Etype (N, Etype (Comp));\n          Check_Implicit_Dereference (N, Etype (Comp));\n \n-         if Is_Access_Type (Etype (Name)) then\n-            Insert_Explicit_Dereference (Name);\n-            Error_Msg_NW (Warn_On_Dereference, \"?d?implicit dereference\", N);\n-         end if;\n-\n       elsif Is_Record_Type (Prefix_Type) then\n \n          --  Find component with given name. In an instance, if the node is\n@@ -4978,15 +4938,6 @@ package body Sem_Ch4 is\n                if Ekind (Comp) = E_Discriminant then\n                   Set_Original_Discriminant (Sel, Comp);\n                end if;\n-\n-               --  For access type case, introduce explicit dereference for\n-               --  more uniform treatment of entry calls.\n-\n-               if Is_Access_Type (Etype (Name)) then\n-                  Insert_Explicit_Dereference (Name);\n-                  Error_Msg_NW\n-                    (Warn_On_Dereference, \"?d?implicit dereference\", N);\n-               end if;\n             end if;\n \n             <<Next_Comp>>\n@@ -5455,8 +5406,8 @@ package body Sem_Ch4 is\n          Set_Etype (N, Any_Type);\n \n          if Is_Access_Type (Array_Type) then\n-            Array_Type := Designated_Type (Array_Type);\n             Error_Msg_NW (Warn_On_Dereference, \"?d?implicit dereference\", N);\n+            Array_Type := Implicitly_Designated_Type (Array_Type);\n          end if;\n \n          if not Is_Array_Type (Array_Type) then\n@@ -7401,48 +7352,6 @@ package body Sem_Ch4 is\n       end if;\n    end Operator_Check;\n \n-   -----------------------------------------\n-   -- Process_Implicit_Dereference_Prefix --\n-   -----------------------------------------\n-\n-   function Process_Implicit_Dereference_Prefix\n-     (E : Entity_Id;\n-      P : Entity_Id) return Entity_Id\n-   is\n-      Ref : Node_Id;\n-      Typ : constant Entity_Id := Designated_Type (Etype (P));\n-\n-   begin\n-      if Present (E)\n-        and then (Operating_Mode = Check_Semantics or else not Expander_Active)\n-      then\n-         --  We create a dummy reference to E to ensure that the reference is\n-         --  not considered as part of an assignment (an implicit dereference\n-         --  can never assign to its prefix). The Comes_From_Source attribute\n-         --  needs to be propagated for accurate warnings.\n-\n-         Ref := New_Occurrence_Of (E, Sloc (P));\n-         Set_Comes_From_Source (Ref, Comes_From_Source (P));\n-         Generate_Reference (E, Ref);\n-      end if;\n-\n-      --  An implicit dereference is a legal occurrence of an incomplete type\n-      --  imported through a limited_with clause, if the full view is visible.\n-\n-      if From_Limited_With (Typ)\n-        and then not From_Limited_With (Scope (Typ))\n-        and then\n-          (Is_Immediately_Visible (Scope (Typ))\n-            or else\n-              (Is_Child_Unit (Scope (Typ))\n-                and then Is_Visible_Lib_Unit (Scope (Typ))))\n-      then\n-         return Available_View (Typ);\n-      else\n-         return Typ;\n-      end if;\n-   end Process_Implicit_Dereference_Prefix;\n-\n    --------------------------------\n    -- Remove_Abstract_Operations --\n    --------------------------------"}, {"sha": "e8d5a90c23ef92e3bc0bb01d6603a7a95aaeff8e", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 27, "deletions": 113, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "patch": "@@ -501,6 +501,10 @@ package body Sem_Ch8 is\n    --  Ada 2005 (AI-262): Determines if the current compilation unit has a\n    --  private with on E.\n \n+   function Has_Components (Typ : Entity_Id) return Boolean;\n+   --  Determine if given type has components, i.e. is either a record type or\n+   --  type or a type that has discriminants.\n+\n    function Has_Implicit_Operator (N : Node_Id) return Boolean;\n    --  N is an expanded name whose selector is an operator name (e.g. P.\"+\").\n    --  declarative part contains an implicit declaration of an operator if it\n@@ -515,14 +519,6 @@ package body Sem_Ch8 is\n    --  specification are discarded and replaced with those of the renamed\n    --  subprogram, which are then used to recheck the default values.\n \n-   function Is_Appropriate_For_Entry_Prefix (T : Entity_Id) return Boolean;\n-   --  True if it is of a task type, a protected type, or else an access to one\n-   --  of these types.\n-\n-   function Is_Appropriate_For_Record (T : Entity_Id) return Boolean;\n-   --  Prefix is appropriate for record if it is of a record type, or an access\n-   --  to such.\n-\n    function Most_Descendant_Use_Clause\n      (Clause1 : Entity_Id;\n       Clause2 : Entity_Id) return Entity_Id;\n@@ -1736,6 +1732,9 @@ package body Sem_Ch8 is\n          --  The prefix can be an arbitrary expression that yields a task or\n          --  protected object, so it must be resolved.\n \n+         if Is_Access_Type (Etype (Prefix (Nam))) then\n+            Insert_Explicit_Dereference (Prefix (Nam));\n+         end if;\n          Resolve (Prefix (Nam), Scope (Old_S));\n       end if;\n \n@@ -7333,23 +7332,6 @@ package body Sem_Ch8 is\n                Set_Etype (N, C_Etype);\n             end;\n \n-            --  If this is the name of an entry or protected operation, and\n-            --  the prefix is an access type, insert an explicit dereference,\n-            --  so that entry calls are treated uniformly.\n-\n-            if Is_Access_Type (Etype (P))\n-              and then Is_Concurrent_Type (Designated_Type (Etype (P)))\n-            then\n-               declare\n-                  New_P : constant Node_Id :=\n-                            Make_Explicit_Dereference (Sloc (P),\n-                              Prefix => Relocate_Node (P));\n-               begin\n-                  Rewrite (P, New_P);\n-                  Set_Etype (P, Designated_Type (Etype (Prefix (P))));\n-               end;\n-            end if;\n-\n          --  If the selected component appears within a default expression\n          --  and it has an actual subtype, the preanalysis has not yet\n          --  completed its analysis, because Insert_Actions is disabled in\n@@ -7393,37 +7375,16 @@ package body Sem_Ch8 is\n             Write_Entity_Info (P_Type, \"      \"); Write_Eol;\n          end if;\n \n-         --  The designated type may be a limited view with no components.\n-         --  Check whether the non-limited view is available, because in some\n-         --  cases this will not be set when installing the context. Rewrite\n-         --  the node by introducing an explicit dereference at once, and\n-         --  setting the type of the rewritten prefix to the non-limited view\n-         --  of the original designated type.\n+         --  If the prefix's type is an access type, get to the record type\n \n          if Is_Access_Type (P_Type) then\n-            declare\n-               Desig_Typ : constant Entity_Id :=\n-                             Directly_Designated_Type (P_Type);\n-\n-            begin\n-               if Is_Incomplete_Type (Desig_Typ)\n-                 and then From_Limited_With (Desig_Typ)\n-                 and then Present (Non_Limited_View (Desig_Typ))\n-               then\n-                  Rewrite (P,\n-                    Make_Explicit_Dereference (Sloc (P),\n-                      Prefix => Relocate_Node (P)));\n-\n-                  Set_Etype (P, Get_Full_View (Non_Limited_View (Desig_Typ)));\n-                  P_Type := Etype (P);\n-               end if;\n-            end;\n+            P_Type := Implicitly_Designated_Type (P_Type);\n          end if;\n \n          --  First check for components of a record object (not the\n          --  result of a call, which is handled below).\n \n-         if Is_Appropriate_For_Record (P_Type)\n+         if Has_Components (P_Type)\n            and then not Is_Overloadable (P_Name)\n            and then not Is_Type (P_Name)\n          then\n@@ -7437,7 +7398,7 @@ package body Sem_Ch8 is\n \n          --  Reference to type name in predicate/invariant expression\n \n-         elsif Is_Appropriate_For_Entry_Prefix (P_Type)\n+         elsif (Is_Task_Type (P_Type) or else Is_Protected_Type (P_Type))\n            and then not In_Open_Scopes (P_Name)\n            and then (not Is_Concurrent_Type (Etype (P_Name))\n                       or else not In_Open_Scopes (Etype (P_Name)))\n@@ -7616,16 +7577,6 @@ package body Sem_Ch8 is\n          else\n             --  Format node as expanded name, to avoid cascaded errors\n \n-            --  If the limited_with transformation was applied earlier, restore\n-            --  source for proper error reporting.\n-\n-            if not Comes_From_Source (P)\n-              and then Nkind (P) = N_Explicit_Dereference\n-            then\n-               Rewrite (P, Prefix (P));\n-               P_Type := Etype (P);\n-            end if;\n-\n             Change_Selected_Component_To_Expanded_Name (N);\n             Set_Entity (N, Any_Id);\n             Set_Etype  (N, Any_Type);\n@@ -7687,8 +7638,8 @@ package body Sem_Ch8 is\n \n                Error_Msg_N (\"invalid prefix in selected component&\", P);\n \n-               if Is_Access_Type (P_Type)\n-                 and then Ekind (Designated_Type (P_Type)) = E_Incomplete_Type\n+               if Is_Incomplete_Type (P_Type)\n+                 and then Is_Access_Type (Etype (P))\n                then\n                   Error_Msg_N\n                     (\"\\dereference must not be of an incomplete type \"\n@@ -8042,6 +7993,20 @@ package body Sem_Ch8 is\n       end if;\n    end Find_Type;\n \n+   --------------------\n+   -- Has_Components --\n+   --------------------\n+\n+   function Has_Components (Typ : Entity_Id) return Boolean is\n+   begin\n+      return Is_Record_Type (Typ)\n+        or else (Is_Private_Type (Typ) and then Has_Discriminants (Typ))\n+        or else (Is_Task_Type (Typ) and then Has_Discriminants (Typ))\n+        or else (Is_Incomplete_Type (Typ)\n+                  and then From_Limited_With (Typ)\n+                  and then Is_Record_Type (Available_View (Typ)));\n+   end Has_Components;\n+\n    ------------------------------------\n    -- Has_Implicit_Character_Literal --\n    ------------------------------------\n@@ -8485,57 +8450,6 @@ package body Sem_Ch8 is\n       end loop;\n    end Install_Use_Clauses;\n \n-   -------------------------------------\n-   -- Is_Appropriate_For_Entry_Prefix --\n-   -------------------------------------\n-\n-   function Is_Appropriate_For_Entry_Prefix (T : Entity_Id) return Boolean is\n-      P_Type : Entity_Id := T;\n-\n-   begin\n-      if Is_Access_Type (P_Type) then\n-         P_Type := Designated_Type (P_Type);\n-      end if;\n-\n-      return Is_Task_Type (P_Type) or else Is_Protected_Type (P_Type);\n-   end Is_Appropriate_For_Entry_Prefix;\n-\n-   -------------------------------\n-   -- Is_Appropriate_For_Record --\n-   -------------------------------\n-\n-   function Is_Appropriate_For_Record (T : Entity_Id) return Boolean is\n-\n-      function Has_Components (T1 : Entity_Id) return Boolean;\n-      --  Determine if given type has components (i.e. is either a record\n-      --  type or a type that has discriminants).\n-\n-      --------------------\n-      -- Has_Components --\n-      --------------------\n-\n-      function Has_Components (T1 : Entity_Id) return Boolean is\n-      begin\n-         return Is_Record_Type (T1)\n-           or else (Is_Private_Type (T1) and then Has_Discriminants (T1))\n-           or else (Is_Task_Type (T1) and then Has_Discriminants (T1))\n-           or else (Is_Incomplete_Type (T1)\n-                     and then From_Limited_With (T1)\n-                     and then Present (Non_Limited_View (T1))\n-                     and then Is_Record_Type\n-                                (Get_Full_View (Non_Limited_View (T1))));\n-      end Has_Components;\n-\n-   --  Start of processing for Is_Appropriate_For_Record\n-\n-   begin\n-      return\n-        Present (T)\n-          and then (Has_Components (T)\n-                     or else (Is_Access_Type (T)\n-                               and then Has_Components (Designated_Type (T))));\n-   end Is_Appropriate_For_Record;\n-\n    ----------------------\n    -- Mark_Use_Clauses --\n    ----------------------"}, {"sha": "6c244dbbfe441205c80275592e44d8a121c68aad", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "patch": "@@ -226,6 +226,12 @@ package body Sem_Res is\n    --  is the context type, which is used when the operation is a protected\n    --  function with no arguments, and the return value is indexed.\n \n+   procedure Resolve_Implicit_Dereference (P : Node_Id);\n+   --  Called when P is the prefix of an indexed component, or of a selected\n+   --  component, or of a slice. If P is of an access type, we unconditionally\n+   --  rewrite it as an explicit dereference. This ensures that the expander\n+   --  and the code generator have a fully explicit tree to work with.\n+\n    procedure Resolve_Intrinsic_Operator (N : Node_Id; Typ : Entity_Id);\n    --  A call to a user-defined intrinsic operator is rewritten as a call to\n    --  the corresponding predefined operator, with suitable conversions. Note\n@@ -6369,7 +6375,6 @@ package body Sem_Res is\n \n                   Set_Etype (Prefix (N), Ret_Type);\n                   Set_Etype (N, Typ);\n-                  Resolve_Indexed_Component (N, Typ);\n \n                   if Legacy_Elaboration_Checks then\n                      Check_Elab_Call (Prefix (N));\n@@ -6381,6 +6386,8 @@ package body Sem_Res is\n                   --  the ABE Processing phase.\n \n                   Build_Call_Marker (Prefix (N));\n+\n+                  Resolve_Indexed_Component (N, Typ);\n                end if;\n             end if;\n \n@@ -7783,10 +7790,12 @@ package body Sem_Res is\n \n       if Nkind (Entry_Name) = N_Selected_Component then\n          Resolve (Prefix (Entry_Name));\n+         Resolve_Implicit_Dereference (Prefix (Entry_Name));\n \n       else pragma Assert (Nkind (Entry_Name) = N_Indexed_Component);\n          Nam := Entity (Selector_Name (Prefix (Entry_Name)));\n          Resolve (Prefix (Prefix (Entry_Name)));\n+         Resolve_Implicit_Dereference (Prefix (Prefix (Entry_Name)));\n          Index := First (Expressions (Entry_Name));\n          Resolve (Index, Entry_Index_Type (Nam));\n \n@@ -8723,6 +8732,21 @@ package body Sem_Res is\n       Analyze_Dimension (N);\n    end Resolve_If_Expression;\n \n+   ----------------------------------\n+   -- Resolve_Implicit_Dereference --\n+   ----------------------------------\n+\n+   procedure Resolve_Implicit_Dereference (P : Node_Id) is\n+      Desig_Typ : Entity_Id;\n+\n+   begin\n+      if Is_Access_Type (Etype (P)) then\n+         Desig_Typ := Implicitly_Designated_Type (Etype (P));\n+         Insert_Explicit_Dereference (P);\n+         Analyze_And_Resolve (P, Desig_Typ);\n+      end if;\n+   end Resolve_Implicit_Dereference;\n+\n    -------------------------------\n    -- Resolve_Indexed_Component --\n    -------------------------------\n@@ -8795,12 +8819,12 @@ package body Sem_Res is\n       Resolve (Name, Array_Type);\n       Array_Type := Get_Actual_Subtype_If_Available (Name);\n \n-      --  If prefix is access type, dereference to get real array type.\n-      --  Note: we do not apply an access check because the expander always\n-      --  introduces an explicit dereference, and the check will happen there.\n+      --  If the prefix's type is an access type, get to the real array type.\n+      --  Note: we do not apply an access check because an explicit dereference\n+      --  will be introduced later, and the check will happen there.\n \n       if Is_Access_Type (Array_Type) then\n-         Array_Type := Designated_Type (Array_Type);\n+         Array_Type := Implicitly_Designated_Type (Array_Type);\n       end if;\n \n       --  If name was overloaded, set component type correctly now\n@@ -8840,6 +8864,7 @@ package body Sem_Res is\n          end loop;\n       end if;\n \n+      Resolve_Implicit_Dereference (Prefix (N));\n       Analyze_Dimension (N);\n \n       --  Do not generate the warning on suspicious index if we are analyzing\n@@ -10402,12 +10427,12 @@ package body Sem_Res is\n          Generate_Reference (Entity (S), S, 'r');\n       end if;\n \n-      --  If prefix is an access type, the node will be transformed into an\n-      --  explicit dereference during expansion. The type of the node is the\n-      --  designated type of that of the prefix.\n+      --  If the prefix's type is an access type, get to the real record type.\n+      --  Note: we do not apply an access check because an explicit dereference\n+      --  will be introduced later, and the check will happen there.\n \n       if Is_Access_Type (Etype (P)) then\n-         T := Designated_Type (Etype (P));\n+         T := Implicitly_Designated_Type (Etype (P));\n          Check_Fully_Declared_Prefix (T, P);\n \n       else\n@@ -10482,6 +10507,7 @@ package body Sem_Res is\n             Prefix (N));\n       end if;\n \n+      Resolve_Implicit_Dereference (Prefix (N));\n       Analyze_Dimension (N);\n    end Resolve_Selected_Component;\n \n@@ -10712,9 +10738,12 @@ package body Sem_Res is\n \n       Resolve (Name, Array_Type);\n \n+      --  If the prefix's type is an access type, get to the real array type.\n+      --  Note: we do not apply an access check because an explicit dereference\n+      --  will be introduced later, and the check will happen there.\n+\n       if Is_Access_Type (Array_Type) then\n-         Apply_Access_Check (N);\n-         Array_Type := Designated_Type (Array_Type);\n+         Array_Type := Implicitly_Designated_Type (Array_Type);\n \n          --  If the prefix is an access to an unconstrained array, we must use\n          --  the actual subtype of the object to perform the index checks. The\n@@ -10858,6 +10887,7 @@ package body Sem_Res is\n          Warn_On_Suspicious_Index (Name, High_Bound (Drange));\n       end if;\n \n+      Resolve_Implicit_Dereference (Prefix (N));\n       Analyze_Dimension (N);\n       Eval_Slice (N);\n    end Resolve_Slice;"}, {"sha": "c6c8d10c7964ed678986d9409e4348b41c181885", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "patch": "@@ -1354,14 +1354,12 @@ package body Sem_Util is\n          New_N : constant Node_Id := New_Copy_Tree (N);\n \n       begin\n-         if Is_Access_Type (Etype (New_N)) then\n-            --  Copy the parent to have a proper Sloc on the dereference\n+         if Is_Access_Type (Etype (N)) then\n+            return Make_Explicit_Dereference (Sloc (Parent (N)), New_N);\n \n-            Set_Parent (New_N, Parent (N));\n-            Insert_Explicit_Dereference (New_N);\n+         else\n+            return New_N;\n          end if;\n-\n-         return New_N;\n       end Copy_And_Maybe_Dereference;\n \n    --  Start of processing for Build_Actual_Subtype_Of_Component\n@@ -12515,6 +12513,32 @@ package body Sem_Util is\n       return False;\n    end Implements_Interface;\n \n+   --------------------------------\n+   -- Implicitly_Designated_Type --\n+   --------------------------------\n+\n+   function Implicitly_Designated_Type (Typ : Entity_Id) return Entity_Id is\n+      Desig : constant Entity_Id := Designated_Type (Typ);\n+\n+   begin\n+      --  An implicit dereference is a legal occurrence of an incomplete type\n+      --  imported through a limited_with clause, if the full view is visible.\n+\n+      if Is_Incomplete_Type (Desig)\n+        and then From_Limited_With (Desig)\n+        and then not From_Limited_With (Scope (Desig))\n+        and then\n+          (Is_Immediately_Visible (Scope (Desig))\n+            or else\n+              (Is_Child_Unit (Scope (Desig))\n+                and then Is_Visible_Lib_Unit (Scope (Desig))))\n+      then\n+         return Available_View (Desig);\n+      else\n+         return Desig;\n+      end if;\n+   end Implicitly_Designated_Type;\n+\n    ------------------------------------\n    -- In_Assertion_Expression_Pragma --\n    ------------------------------------\n@@ -23402,7 +23426,7 @@ package body Sem_Util is\n          Orig_Pre := Original_Node (Prefix (Orig_Obj));\n \n          if Is_Access_Type (Etype (Orig_Pre)) then\n-            return Type_Access_Level (Etype (Prefix (Orig_Obj)));\n+            return Type_Access_Level (Etype (Orig_Pre));\n          else\n             return Object_Access_Level (Prefix (Orig_Obj));\n          end if;"}, {"sha": "253184412703943d6c554a75c4191ed4ffc1de63", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "patch": "@@ -1391,6 +1391,11 @@ package Sem_Util is\n       Exclude_Parents : Boolean := False) return Boolean;\n    --  Returns true if the Typ_Ent implements interface Iface_Ent\n \n+   function Implicitly_Designated_Type (Typ : Entity_Id) return Entity_Id;\n+   --  Called when Typ is the type of the prefix of an implicit dereference.\n+   --  Return the designated type of Typ, taking into account that this type\n+   --  may be a limited view, when the nonlimited view is visible.\n+\n    function In_Assertion_Expression_Pragma (N : Node_Id) return Boolean;\n    --  Returns True if node N appears within a pragma that acts as an assertion\n    --  expression. See Sem_Prag for the list of qualifying pragmas."}, {"sha": "3fe77b077bcfa747afc536a40cc3f35217694828", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=f715a5bd3fb6bb70c11b29dc2b54f2459ed36bfb", "patch": "@@ -1872,7 +1872,7 @@ package body Sem_Warn is\n       --  have a reference from generated code, it is bogus (e.g. calls to init\n       --  procs to set default discriminant values).\n \n-      if not Comes_From_Source (N) then\n+      if not Comes_From_Source (Original_Node (N)) then\n          return;\n       end if;\n "}]}