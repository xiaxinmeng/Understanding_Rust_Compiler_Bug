{"sha": "b3ecff82d7f193033d98d04124114aa57c2adba3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNlY2ZmODJkN2YxOTMwMzNkOThkMDQxMjQxMTRhYTU3YzJhZGJhMw==", "commit": {"author": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2013-11-27T16:33:01Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2013-11-27T16:33:01Z"}, "message": "2013-11-27  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n\treverted r205398 on request: Remove parameter keep_aligning from\n\tget_inner_reference.\n\nFrom-SVN: r205452", "tree": {"sha": "57109bd0c5a05fb6134524e9eba3e9890ae43804", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57109bd0c5a05fb6134524e9eba3e9890ae43804"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3ecff82d7f193033d98d04124114aa57c2adba3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ecff82d7f193033d98d04124114aa57c2adba3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3ecff82d7f193033d98d04124114aa57c2adba3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ecff82d7f193033d98d04124114aa57c2adba3/comments", "author": null, "committer": null, "parents": [{"sha": "36db5f30004bdf03cde1fbd0e1355ff50e1b91cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36db5f30004bdf03cde1fbd0e1355ff50e1b91cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36db5f30004bdf03cde1fbd0e1355ff50e1b91cc"}], "stats": {"total": 145, "additions": 69, "deletions": 76}, "files": [{"sha": "39a4f1e71926f645ea6f6df9713ea2b9cb774999", "filename": "gcc/ChangeLog", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -337,37 +337,6 @@\n \tfor the inner loop if collapse_bb is non-NULL.\n \t(expand_omp_simd): Use cont_bb rather than e->dest as latch.\n \n-2013-11-26  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n-\n-\tRemove parameter keep_aligning from get_inner_reference.\n-\t* tree.h (get_inner_reference): Adjust header.\n-\t* expr.c (get_inner_reference): Remove parameter keep_aligning.\n-\t(get_bit_range, expand_assignment,\n-\texpand_expr_addr_expr_1, expand_expr_real_1): Adjust.\n-\t* asan.c (instrument_derefs): Adjust.\n-\t* builtins.c (get_object_alignment_2): Adjust. Remove handling of\n-\tVIEW_CONVERT_EXPR.\n-\t* cfgexpand.c (expand_debug_expr): Adjust.\n-\t* dbxout.c (dbxout_expand_expr): Adjust.\n-\t* dwarf2out.c (loc_list_for_address_of_addr_expr_of_indirect_ref,\n-\tloc_list_from_tree, fortran_common): Adjust.\n-\t* fold-const.c (optimize_bit_field_compare,\n-\tdecode_field_reference, fold_unary_loc, fold_comparison,\n-\tsplit_address_to_core_and_offset): Adjust.\n-\t* gimple-ssa-strength-reduction.c (slsr_process_ref): Adjust.\n-\t* simplifx-rtx.c (delegitimize_mem_from_attrs): Adjust.\n-\t* tree-affine.c (tree_to_aff_combination,\n-\tget_inner_reference_aff): Adjust.\n-\t* tree-data-ref.c (split_constant_offset_1,\n-\tdr_analyze_innermost): Adjust.\n-\t* tree-vect-data-refs.c (vect_check_gather,\n-\tvect_analyze_data_refs): Adjust.\n-\t* tree-scalar-evolution.c (interpret_rhs_expr): Adjust.\n-\t* tree-ssa-loop-ivopts.c (may_be_unaligned_p,\n-\tsplit_address_cost): Adjust.\n-\t* tsan.c (instrument_expr): Adjust.\n-\t* config/mips/mips.c (r10k_safe_mem_expr_p): Adjust.\n-\n 2013-11-26  Yufeng Zhang  <yufeng.zhang@arm.com>\n \n \t* config/arm/arm.c (arm_legitimize_address): Check xop1 is not"}, {"sha": "8bb3462bc5a51aadf7c1b9b5997308c0b4e08098", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -1,10 +1,3 @@\n-2013-11-26  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n-\n-\tRemove parameter keep_aligning from get_inner_reference.\n-\t* gcc-interface/decl.c (elaborate_expression_1): Adjust.\n-\t* gcc-interface/trans.c (Attribute_to_gnu): Adjust.\n-\t* gcc-interface/utils2.c (build_unary_op): Adjust.\n-\n 2013-11-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Loop_Statement_to_gnu): Set TREE_SIDE_EFFECTS"}, {"sha": "ee76a9d160f38737015ecdc1f74056f70c0ad704", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -6269,7 +6269,7 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, tree gnu_name,\n \t  int unsignedp, volatilep;\n \n \t  inner = get_inner_reference (inner, &bitsize, &bitpos, &offset,\n-\t\t\t\t       &mode, &unsignedp, &volatilep);\n+\t\t\t\t       &mode, &unsignedp, &volatilep, false);\n \t  /* If the offset is variable, err on the side of caution.  */\n \t  if (offset)\n \t    inner = NULL_TREE;"}, {"sha": "e533de6dcbf7a33caabf4cdcbb859704fe4d12df", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -2060,7 +2060,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t\t\t  && TREE_CODE (gnu_prefix) == FIELD_DECL));\n \n \tget_inner_reference (gnu_prefix, &bitsize, &bitpos, &gnu_offset,\n-\t\t\t     &mode, &unsignedp, &volatilep);\n+\t\t\t     &mode, &unsignedp, &volatilep, false);\n \n \tif (TREE_CODE (gnu_prefix) == COMPONENT_REF)\n \t  {"}, {"sha": "224a87d87774071749a8855254c74ec7d82f4f67", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -1312,7 +1312,8 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t      int unsignedp, volatilep;\n \n \t      inner = get_inner_reference (operand, &bitsize, &bitpos, &offset,\n-\t\t\t\t\t   &mode, &unsignedp, &volatilep);\n+\t\t\t\t\t   &mode, &unsignedp, &volatilep,\n+\t\t\t\t\t   false);\n \n \t      /* If INNER is a padding type whose field has a self-referential\n \t\t size, convert to that inner type.  We know the offset is zero"}, {"sha": "677435e05aed34cdfc96749f4e20046174da9b81", "filename": "gcc/asan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -1488,7 +1488,7 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n   enum machine_mode mode;\n   int volatilep = 0, unsignedp = 0;\n   tree inner = get_inner_reference (t, &bitsize, &bitpos, &offset,\n-\t\t\t\t    &mode, &unsignedp, &volatilep);\n+\t\t\t\t    &mode, &unsignedp, &volatilep, false);\n   if (bitpos % (size_in_bytes * BITS_PER_UNIT)\n       || bitsize != size_in_bytes * BITS_PER_UNIT)\n     {"}, {"sha": "d2248ea5ec617094e0aab6e969e3c9ff1fd627c1", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -329,7 +329,7 @@ get_object_alignment_2 (tree exp, unsigned int *alignp,\n   /* Get the innermost object and the constant (bitpos) and possibly\n      variable (offset) offset of the access.  */\n   exp = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n-\t\t\t     &mode, &unsignedp, &volatilep);\n+\t\t\t     &mode, &unsignedp, &volatilep, true);\n \n   /* Extract alignment information from the innermost object and\n      possibly adjust bitpos and offset.  */\n@@ -360,6 +360,10 @@ get_object_alignment_2 (tree exp, unsigned int *alignp,\n       align = DECL_ALIGN (exp);\n       known_alignment = true;\n     }\n+  else if (TREE_CODE (exp) == VIEW_CONVERT_EXPR)\n+    {\n+      align = TYPE_ALIGN (TREE_TYPE (exp));\n+    }\n   else if (TREE_CODE (exp) == INDIRECT_REF\n \t   || TREE_CODE (exp) == MEM_REF\n \t   || TREE_CODE (exp) == TARGET_MEM_REF)"}, {"sha": "207f8767573f2cfff65414e54f4794b2b8ed5f0e", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -3941,7 +3941,7 @@ expand_debug_expr (tree exp)\n \ttree offset;\n \tint volatilep = 0;\n \ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n-\t\t\t\t\t&mode1, &unsignedp, &volatilep);\n+\t\t\t\t\t&mode1, &unsignedp, &volatilep, false);\n \trtx orig_op0;\n \n \tif (bitsize == 0)"}, {"sha": "36ba6df7a4cfdd7e0c87f78ef44601b3baf035df", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -14948,7 +14948,7 @@ r10k_safe_mem_expr_p (tree expr, unsigned HOST_WIDE_INT offset)\n   int unsigned_p, volatile_p;\n \n   inner = get_inner_reference (expr, &bitsize, &bitoffset, &var_offset, &mode,\n-\t\t\t       &unsigned_p, &volatile_p);\n+\t\t\t       &unsigned_p, &volatile_p, false);\n   if (!DECL_P (inner) || !DECL_SIZE_UNIT (inner) || var_offset)\n     return false;\n "}, {"sha": "bc6a3af0f96e52c4430541c2e49158b30e0f12b8", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -2515,7 +2515,7 @@ dbxout_expand_expr (tree expr)\n \trtx x;\n \n \ttem = get_inner_reference (expr, &bitsize, &bitpos, &offset,\n-\t\t\t\t   &mode, &unsignedp, &volatilep);\n+\t\t\t\t   &mode, &unsignedp, &volatilep, true);\n \n \tx = dbxout_expand_expr (tem);\n \tif (x == NULL || !MEM_P (x))"}, {"sha": "3448ec4a98c7f8a3b118952b5f3c680ad0badd5f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -13934,7 +13934,7 @@ loc_list_for_address_of_addr_expr_of_indirect_ref (tree loc, bool toplev)\n \n   obj = get_inner_reference (TREE_OPERAND (loc, 0),\n \t\t\t     &bitsize, &bitpos, &offset, &mode,\n-\t\t\t     &unsignedp, &volatilep);\n+\t\t\t     &unsignedp, &volatilep, false);\n   STRIP_NOPS (obj);\n   if (bitpos % BITS_PER_UNIT)\n     {\n@@ -14211,7 +14211,7 @@ loc_list_from_tree (tree loc, int want_address)\n \tint unsignedp, volatilep = 0;\n \n \tobj = get_inner_reference (loc, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t\t   &unsignedp, &volatilep);\n+\t\t\t\t   &unsignedp, &volatilep, false);\n \n \tgcc_assert (obj != loc);\n \n@@ -15521,7 +15521,7 @@ fortran_common (tree decl, HOST_WIDE_INT *value)\n     return NULL_TREE;\n \n   cvar = get_inner_reference (val_expr, &bitsize, &bitpos, &offset,\n-\t\t\t      &mode, &unsignedp, &volatilep);\n+\t\t\t      &mode, &unsignedp, &volatilep, true);\n \n   if (cvar == NULL_TREE\n       || TREE_CODE (cvar) != VAR_DECL"}, {"sha": "4815c886f773889997962abe08393b29ea4fea4d", "filename": "gcc/expr.c", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -4657,7 +4657,7 @@ get_bit_range (unsigned HOST_WIDE_INT *bitstart,\n       int unsignedp;\n       int volatilep = 0;\n       get_inner_reference (TREE_OPERAND (exp, 0), &rbitsize, &rbitpos,\n-\t\t\t   &roffset, &rmode, &unsignedp, &volatilep);\n+\t\t\t   &roffset, &rmode, &unsignedp, &volatilep, false);\n       if ((rbitpos % BITS_PER_UNIT) != 0)\n \t{\n \t  *bitstart = *bitend = 0;\n@@ -4810,7 +4810,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \n       push_temp_slots ();\n       tem = get_inner_reference (to, &bitsize, &bitpos, &offset, &mode1,\n-\t\t\t\t &unsignedp, &volatilep);\n+\t\t\t\t &unsignedp, &volatilep, true);\n \n       /* Make sure bitpos is not negative, it can wreak havoc later.  */\n       if (bitpos < 0)\n@@ -6652,13 +6652,27 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \n    If the field describes a variable-sized object, *PMODE is set to\n    BLKmode and *PBITSIZE is set to -1.  An access cannot be made in\n-   this case, but the address of the object can be found.  */\n+   this case, but the address of the object can be found.\n+\n+   If KEEP_ALIGNING is true and the target is STRICT_ALIGNMENT, we don't\n+   look through nodes that serve as markers of a greater alignment than\n+   the one that can be deduced from the expression.  These nodes make it\n+   possible for front-ends to prevent temporaries from being created by\n+   the middle-end on alignment considerations.  For that purpose, the\n+   normal operating mode at high-level is to always pass FALSE so that\n+   the ultimate containing object is really returned; moreover, the\n+   associated predicate handled_component_p will always return TRUE\n+   on these nodes, thus indicating that they are essentially handled\n+   by get_inner_reference.  TRUE should only be passed when the caller\n+   is scanning the expression in order to build another representation\n+   and specifically knows how to handle these nodes; as such, this is\n+   the normal operating mode in the RTL expanders.  */\n \n tree\n get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \t\t     HOST_WIDE_INT *pbitpos, tree *poffset,\n \t\t     enum machine_mode *pmode, int *punsignedp,\n-\t\t     int *pvolatilep)\n+\t\t     int *pvolatilep, bool keep_aligning)\n {\n   tree size_tree = 0;\n   enum machine_mode mode = VOIDmode;\n@@ -6778,6 +6792,14 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \t  break;\n \n \tcase VIEW_CONVERT_EXPR:\n+\t  if (keep_aligning && STRICT_ALIGNMENT\n+\t      && (TYPE_ALIGN (TREE_TYPE (exp))\n+\t       > TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+\t      && (TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (exp, 0)))\n+\t\t  < BIGGEST_ALIGNMENT)\n+\t      && (TYPE_ALIGN_OK (TREE_TYPE (exp))\n+\t\t  || TYPE_ALIGN_OK (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n+\t    goto done;\n \t  break;\n \n \tcase MEM_REF:\n@@ -7642,7 +7664,7 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n \t they won't change the final object whose address will be returned\n \t (they actually exist only for that purpose).  */\n       inner = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n-\t\t\t\t   &mode1, &unsignedp, &volatilep);\n+\t\t\t\t   &mode1, &unsignedp, &volatilep, false);\n       break;\n     }\n \n@@ -9919,7 +9941,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \ttree offset;\n \tint volatilep = 0, must_force_mem;\n \ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n-\t\t\t\t\t&mode1, &unsignedp, &volatilep);\n+\t\t\t\t\t&mode1, &unsignedp, &volatilep, true);\n \trtx orig_op0, memloc;\n \tbool mem_attrs_from_type = false;\n \n@@ -10280,7 +10302,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \tint volatilep = 0;\n \ttree tem\n \t  = get_inner_reference (treeop0, &bitsize, &bitpos,\n-\t\t\t\t &offset, &mode1, &unsignedp, &volatilep);\n+\t\t\t\t &offset, &mode1, &unsignedp, &volatilep,\n+\t\t\t\t true);\n \trtx orig_op0;\n \n \t/* ??? We should work harder and deal with non-zero offsets.  */"}, {"sha": "5cf8ed196d75098bf7645051966c59cb3164216b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -3503,7 +3503,7 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n      do anything if the inner expression is a PLACEHOLDER_EXPR since we\n      then will no longer be able to replace it.  */\n   linner = get_inner_reference (lhs, &lbitsize, &lbitpos, &offset, &lmode,\n-\t\t\t\t&lunsignedp, &lvolatilep);\n+\t\t\t\t&lunsignedp, &lvolatilep, false);\n   if (linner == lhs || lbitsize == GET_MODE_BITSIZE (lmode) || lbitsize < 0\n       || offset != 0 || TREE_CODE (linner) == PLACEHOLDER_EXPR || lvolatilep)\n     return 0;\n@@ -3513,7 +3513,7 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n      /* If this is not a constant, we can only do something if bit positions,\n \tsizes, and signedness are the same.  */\n      rinner = get_inner_reference (rhs, &rbitsize, &rbitpos, &offset, &rmode,\n-\t\t\t\t   &runsignedp, &rvolatilep);\n+\t\t\t\t   &runsignedp, &rvolatilep, false);\n \n      if (rinner == rhs || lbitpos != rbitpos || lbitsize != rbitsize\n \t || lunsignedp != runsignedp || offset != 0\n@@ -3687,7 +3687,7 @@ decode_field_reference (location_t loc, tree exp, HOST_WIDE_INT *pbitsize,\n     }\n \n   inner = get_inner_reference (exp, pbitsize, pbitpos, &offset, pmode,\n-\t\t\t       punsignedp, pvolatilep);\n+\t\t\t       punsignedp, pvolatilep, false);\n   if ((inner == exp && and_mask == 0)\n       || *pbitsize < 0 || offset != 0\n       || TREE_CODE (inner) == PLACEHOLDER_EXPR)\n@@ -8071,7 +8071,7 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t  int unsignedp, volatilep;\n           tree base = TREE_OPERAND (op0, 0);\n \t  base = get_inner_reference (base, &bitsize, &bitpos, &offset,\n-\t\t\t\t      &mode, &unsignedp, &volatilep);\n+\t\t\t\t      &mode, &unsignedp, &volatilep, false);\n \t  /* If the reference was to a (constant) zero offset, we can use\n \t     the address of the base if it has the same base type\n \t     as the result type and the pointer type is unqualified.  */\n@@ -9096,7 +9096,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t{\n \t  base0 = get_inner_reference (TREE_OPERAND (arg0, 0),\n \t\t\t\t       &bitsize, &bitpos0, &offset0, &mode,\n-\t\t\t\t       &unsignedp, &volatilep);\n+\t\t\t\t       &unsignedp, &volatilep, false);\n \t  if (TREE_CODE (base0) == INDIRECT_REF)\n \t    base0 = TREE_OPERAND (base0, 0);\n \t  else\n@@ -9130,7 +9130,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t{\n \t  base1 = get_inner_reference (TREE_OPERAND (arg1, 0),\n \t\t\t\t       &bitsize, &bitpos1, &offset1, &mode,\n-\t\t\t\t       &unsignedp, &volatilep);\n+\t\t\t\t       &unsignedp, &volatilep, false);\n \t  if (TREE_CODE (base1) == INDIRECT_REF)\n \t    base1 = TREE_OPERAND (base1, 0);\n \t  else\n@@ -16997,7 +16997,8 @@ split_address_to_core_and_offset (tree exp,\n   if (TREE_CODE (exp) == ADDR_EXPR)\n     {\n       core = get_inner_reference (TREE_OPERAND (exp, 0), &bitsize, pbitpos,\n-\t\t\t\t  poffset, &mode, &unsignedp, &volatilep);\n+\t\t\t\t  poffset, &mode, &unsignedp, &volatilep,\n+\t\t\t\t  false);\n       core = build_fold_addr_expr_loc (loc, core);\n     }\n   else"}, {"sha": "bc2484b5b1338344ed3d88be4073a58afb4927a3", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -940,7 +940,7 @@ slsr_process_ref (gimple gs)\n     return;\n \n   base = get_inner_reference (ref_expr, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t      &unsignedp, &volatilep);\n+\t\t\t      &unsignedp, &volatilep, false);\n   index = double_int::from_uhwi (bitpos);\n \n   if (!restructure_reference (&base, &offset, &index, &type))"}, {"sha": "ec138584c385ed3562e8e02d43925290cb218a44", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -296,7 +296,7 @@ delegitimize_mem_from_attrs (rtx x)\n \t    int unsignedp, volatilep = 0;\n \n \t    decl = get_inner_reference (decl, &bitsize, &bitpos, &toffset,\n-\t\t\t\t\t&mode, &unsignedp, &volatilep);\n+\t\t\t\t\t&mode, &unsignedp, &volatilep, false);\n \t    if (bitsize != GET_MODE_BITSIZE (mode)\n \t\t|| (bitpos % BITS_PER_UNIT)\n \t\t|| (toffset && !tree_fits_shwi_p (toffset)))"}, {"sha": "f93f186a761cfa84d950570281a2dcb9cf64aa14", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -325,7 +325,8 @@ tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n \t  return;\n \t}\n       core = get_inner_reference (TREE_OPERAND (expr, 0), &bitsize, &bitpos,\n-\t\t\t\t  &toffset, &mode, &unsignedp, &volatilep);\n+\t\t\t\t  &toffset, &mode, &unsignedp, &volatilep,\n+\t\t\t\t  false);\n       if (bitpos % BITS_PER_UNIT != 0)\n \tbreak;\n       aff_combination_const (comb, type,\n@@ -894,7 +895,7 @@ get_inner_reference_aff (tree ref, aff_tree *addr, double_int *size)\n   int uns, vol;\n   aff_tree tmp;\n   tree base = get_inner_reference (ref, &bitsize, &bitpos, &toff, &mode,\n-\t\t\t\t   &uns, &vol);\n+\t\t\t\t   &uns, &vol, false);\n   tree base_addr = build_fold_addr_expr (base);\n \n   /* ADDR = &BASE + TOFF + BITPOS / BITS_PER_UNIT.  */"}, {"sha": "fef6a716b7a02829f0cd76ef63bdae32813c9a8f", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -619,7 +619,7 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \n \top0 = TREE_OPERAND (op0, 0);\n \tbase = get_inner_reference (op0, &pbitsize, &pbitpos, &poffset,\n-\t\t\t\t    &pmode, &punsignedp, &pvolatilep);\n+\t\t\t\t    &pmode, &punsignedp, &pvolatilep, false);\n \n \tif (pbitpos % BITS_PER_UNIT != 0)\n \t  return false;\n@@ -769,7 +769,7 @@ dr_analyze_innermost (struct data_reference *dr, struct loop *nest)\n     fprintf (dump_file, \"analyze_innermost: \");\n \n   base = get_inner_reference (ref, &pbitsize, &pbitpos, &poffset,\n-\t\t\t      &pmode, &punsignedp, &pvolatilep);\n+\t\t\t      &pmode, &punsignedp, &pvolatilep, false);\n   gcc_assert (base != NULL_TREE);\n \n   if (pbitpos % BITS_PER_UNIT != 0)"}, {"sha": "ada942df389b8d5855b5b2658dc297ba8fe8e219", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -1658,7 +1658,7 @@ interpret_rhs_expr (struct loop *loop, gimple at_stmt,\n \n \t  base = get_inner_reference (TREE_OPERAND (rhs1, 0),\n \t\t\t\t      &bitsize, &bitpos, &offset,\n-\t\t\t\t      &mode, &unsignedp, &volatilep);\n+\t\t\t\t      &mode, &unsignedp, &volatilep, false);\n \n \t  if (TREE_CODE (base) == MEM_REF)\n \t    {"}, {"sha": "1f5590a7ac262357e5192b837babd08792a9217f", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -1684,7 +1684,7 @@ may_be_unaligned_p (tree ref, tree step)\n      does to check whether the object must be loaded by parts when\n      STRICT_ALIGNMENT is true.  */\n   base = get_inner_reference (ref, &bitsize, &bitpos, &toffset, &mode,\n-\t\t\t      &unsignedp, &volatilep);\n+\t\t\t      &unsignedp, &volatilep, true);\n   base_type = TREE_TYPE (base);\n   base_align = get_object_alignment (base);\n   base_align = MAX (base_align, TYPE_ALIGN (base_type));\n@@ -3781,7 +3781,7 @@ split_address_cost (struct ivopts_data *data,\n   int unsignedp, volatilep;\n \n   core = get_inner_reference (addr, &bitsize, &bitpos, &toffset, &mode,\n-\t\t\t      &unsignedp, &volatilep);\n+\t\t\t      &unsignedp, &volatilep, false);\n \n   if (toffset != 0\n       || bitpos % BITS_PER_UNIT != 0"}, {"sha": "76a3563f397dc43d02707963d6f386b37bbb075b", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -2971,7 +2971,7 @@ vect_check_gather (gimple stmt, loop_vec_info loop_vinfo, tree *basep,\n      SSA_NAME OFF and put the loop invariants into a tree BASE\n      that can be gimplified before the loop.  */\n   base = get_inner_reference (DR_REF (dr), &pbitsize, &pbitpos, &off,\n-\t\t\t      &pmode, &punsignedp, &pvolatilep);\n+\t\t\t      &pmode, &punsignedp, &pvolatilep, false);\n   gcc_assert (base != NULL_TREE && (pbitpos % BITS_PER_UNIT) == 0);\n \n   if (TREE_CODE (base) == MEM_REF)\n@@ -3518,7 +3518,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t    }\n \n \t  outer_base = get_inner_reference (inner_base, &pbitsize, &pbitpos,\n-\t\t          &poffset, &pmode, &punsignedp, &pvolatilep);\n+\t\t          &poffset, &pmode, &punsignedp, &pvolatilep, false);\n \t  gcc_assert (outer_base != NULL_TREE);\n \n \t  if (pbitpos % BITS_PER_UNIT != 0)"}, {"sha": "11ab1ce3eb09385bae8f5c03a1b46af04239c291", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -4515,7 +4515,8 @@ extern tree build_personality_function (const char *);\n    look for the ultimate containing object, which is returned and specify\n    the access position and size.  */\n extern tree get_inner_reference (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n-\t\t\t\t tree *, enum machine_mode *, int *, int *);\n+\t\t\t\t tree *, enum machine_mode *, int *, int *,\n+\t\t\t\t bool);\n \n /* Return a tree representing the lower bound of the array mentioned in\n    EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */"}, {"sha": "4efcfe565aa0c2ec3b3c6be59148fe2bb2d53e6a", "filename": "gcc/tsan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ecff82d7f193033d98d04124114aa57c2adba3/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=b3ecff82d7f193033d98d04124114aa57c2adba3", "patch": "@@ -121,7 +121,7 @@ instrument_expr (gimple_stmt_iterator gsi, tree expr, bool is_write)\n   enum machine_mode mode;\n   int volatilep = 0, unsignedp = 0;\n   base = get_inner_reference (expr, &bitsize, &bitpos, &offset,\n-\t\t\t      &mode, &unsignedp, &volatilep);\n+\t\t\t      &mode, &unsignedp, &volatilep, false);\n \n   /* No need to instrument accesses to decls that don't escape,\n      they can't escape to other threads then.  */"}]}