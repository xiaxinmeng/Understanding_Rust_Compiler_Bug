{"sha": "7922a3bb6ba14d5933fc414f6c345e96acd33833", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkyMmEzYmI2YmExNGQ1OTMzZmM0MTRmNmMzNDVlOTZhY2QzMzgzMw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-10-05T22:55:59Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-05T22:55:59Z"}, "message": "basic-block.h: Remove the prototype for flow_preorder_transversal_compute.\n\n\t* basic-block.h: Remove the prototype for\n\tflow_preorder_transversal_compute.\n\t* cfganal.c (dfst_node): Remove.\n\t(flow_preorder_transversal_compute): Likewise.\n\t* rtl.h: Remove the prototype for get_jump_table_offset.\n\t* rtlanal.c (get_jump_table_offset): Remove.\n\nFrom-SVN: r88580", "tree": {"sha": "2c31b3c3692d04f0b6880985575103f2307a0b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c31b3c3692d04f0b6880985575103f2307a0b76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7922a3bb6ba14d5933fc414f6c345e96acd33833", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7922a3bb6ba14d5933fc414f6c345e96acd33833", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7922a3bb6ba14d5933fc414f6c345e96acd33833", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7922a3bb6ba14d5933fc414f6c345e96acd33833/comments", "author": null, "committer": null, "parents": [{"sha": "9ec9d82b6d6a8b4349f80313f1d980124efe2e00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ec9d82b6d6a8b4349f80313f1d980124efe2e00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ec9d82b6d6a8b4349f80313f1d980124efe2e00"}], "stats": {"total": 263, "additions": 9, "deletions": 254}, "files": [{"sha": "24da20f69a2ae05dde8070bfc1e383ffd4789038", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7922a3bb6ba14d5933fc414f6c345e96acd33833/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7922a3bb6ba14d5933fc414f6c345e96acd33833/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7922a3bb6ba14d5933fc414f6c345e96acd33833", "patch": "@@ -1,3 +1,12 @@\n+2004-10-05  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* basic-block.h: Remove the prototype for\n+\tflow_preorder_transversal_compute.\n+\t* cfganal.c (dfst_node): Remove.\n+\t(flow_preorder_transversal_compute): Likewise.\n+\t* rtl.h: Remove the prototype for get_jump_table_offset.\n+\t* rtlanal.c (get_jump_table_offset): Remove.\n+\n 2004-10-05  Richard Henderson  <rth@redhat.com>\n \n \tPR 17756"}, {"sha": "7a75d688d001645b32af1ac265595fe60a345e58", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7922a3bb6ba14d5933fc414f6c345e96acd33833/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7922a3bb6ba14d5933fc414f6c345e96acd33833/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=7922a3bb6ba14d5933fc414f6c345e96acd33833", "patch": "@@ -473,7 +473,6 @@ extern basic_block create_basic_block_structure (rtx, rtx, rtx, basic_block);\n extern void clear_bb_flags (void);\n extern void flow_reverse_top_sort_order_compute (int *);\n extern int flow_depth_first_order_compute (int *, int *);\n-extern void flow_preorder_transversal_compute (int *);\n extern int dfs_enumerate_from (basic_block, int,\n \t\t\t       bool (*)(basic_block, void *),\n \t\t\t       basic_block *, int, void *);"}, {"sha": "c76da55296c545bb3a0fe0163909297b730a5c7b", "filename": "gcc/cfganal.c", "status": "modified", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7922a3bb6ba14d5933fc414f6c345e96acd33833/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7922a3bb6ba14d5933fc414f6c345e96acd33833/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=7922a3bb6ba14d5933fc414f6c345e96acd33833", "patch": "@@ -774,126 +774,6 @@ flow_depth_first_order_compute (int *dfs_order, int *rc_order)\n   return dfsnum;\n }\n \n-struct dfst_node\n-{\n-    unsigned nnodes;\n-    struct dfst_node **node;\n-    struct dfst_node *up;\n-};\n-\n-/* Compute a preorder transversal ordering such that a sub-tree which\n-   is the source of a cross edge appears before the sub-tree which is\n-   the destination of the cross edge.  This allows for easy detection\n-   of all the entry blocks for a loop.\n-\n-   The ordering is compute by:\n-\n-     1) Generating a depth first spanning tree.\n-\n-     2) Walking the resulting tree from right to left.  */\n-\n-void\n-flow_preorder_transversal_compute (int *pot_order)\n-{\n-  edge_iterator *stack, ei;\n-  int i;\n-  int max_successors;\n-  int sp;\n-  sbitmap visited;\n-  struct dfst_node *node;\n-  struct dfst_node *dfst;\n-  basic_block bb;\n-\n-  /* Allocate stack for back-tracking up CFG.  */\n-  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n-  sp = 0;\n-\n-  /* Allocate the tree.  */\n-  dfst = xcalloc (last_basic_block, sizeof (struct dfst_node));\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      max_successors = EDGE_COUNT (bb->succs);\n-      dfst[bb->index].node\n-\t= (max_successors\n-\t   ? xcalloc (max_successors, sizeof (struct dfst_node *)) : NULL);\n-    }\n-\n-  /* Allocate bitmap to track nodes that have been visited.  */\n-  visited = sbitmap_alloc (last_basic_block);\n-\n-  /* None of the nodes in the CFG have been visited yet.  */\n-  sbitmap_zero (visited);\n-\n-  /* Push the first edge on to the stack.  */\n-  stack[sp++] = ei_start (ENTRY_BLOCK_PTR->succs);\n-\n-  while (sp)\n-    {\n-      basic_block src;\n-      basic_block dest;\n-\n-      /* Look at the edge on the top of the stack.  */\n-      ei = stack[sp - 1];\n-      src = ei_edge (ei)->src;\n-      dest = ei_edge (ei)->dest;\n-\n-      /* Check if the edge destination has been visited yet.  */\n-      if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index))\n-\t{\n-\t  /* Mark that we have visited the destination.  */\n-\t  SET_BIT (visited, dest->index);\n-\n-\t  /* Add the destination to the preorder tree.  */\n-\t  if (src != ENTRY_BLOCK_PTR)\n-\t    {\n-\t      dfst[src->index].node[dfst[src->index].nnodes++]\n-\t\t= &dfst[dest->index];\n-\t      dfst[dest->index].up = &dfst[src->index];\n-\t    }\n-\n-\t  if (EDGE_COUNT (dest->succs) > 0)\n-\t    /* Since the DEST node has been visited for the first\n-\t       time, check its successors.  */\n-\t    stack[sp++] = ei_start (dest->succs);\n-\t}\n-\n-      else if (! ei_one_before_end_p (ei))\n-\tei_next (&stack[sp - 1]);\n-      else\n-\tsp--;\n-    }\n-\n-  free (stack);\n-  sbitmap_free (visited);\n-\n-  /* Record the preorder transversal order by\n-     walking the tree from right to left.  */\n-\n-  i = 0;\n-  node = &dfst[ENTRY_BLOCK_PTR->next_bb->index];\n-  pot_order[i++] = 0;\n-\n-  while (node)\n-    {\n-      if (node->nnodes)\n-\t{\n-\t  node = node->node[--node->nnodes];\n-\t  pot_order[i++] = node - dfst;\n-\t}\n-      else\n-\tnode = node->up;\n-    }\n-\n-  /* Free the tree.  */\n-\n-  for (i = 0; i < last_basic_block; i++)\n-    if (dfst[i].node)\n-      free (dfst[i].node);\n-\n-  free (dfst);\n-}\n-\n /* Compute the depth first search order on the _reverse_ graph and\n    store in the array DFS_ORDER, marking the nodes visited in VISITED.\n    Returns the number of nodes visited."}, {"sha": "ac2419b41e2fb30fdc4c82f1f62091d98f8338ab", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7922a3bb6ba14d5933fc414f6c345e96acd33833/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7922a3bb6ba14d5933fc414f6c345e96acd33833/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=7922a3bb6ba14d5933fc414f6c345e96acd33833", "patch": "@@ -1598,7 +1598,6 @@ extern int rtx_varies_p (rtx, int);\n extern int rtx_addr_varies_p (rtx, int);\n extern HOST_WIDE_INT get_integer_term (rtx);\n extern rtx get_related_value (rtx);\n-extern rtx get_jump_table_offset (rtx, rtx *);\n extern int global_reg_mentioned_p (rtx);\n extern int reg_mentioned_p (rtx, rtx);\n extern int count_occurrences (rtx, rtx, int);"}, {"sha": "7e79a8abeec2df08bde5e99b1c77395244e94f17", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7922a3bb6ba14d5933fc414f6c345e96acd33833/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7922a3bb6ba14d5933fc414f6c345e96acd33833/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=7922a3bb6ba14d5933fc414f6c345e96acd33833", "patch": "@@ -435,138 +435,6 @@ get_related_value (rtx x)\n   return 0;\n }\n \f\n-/* Given a tablejump insn INSN, return the RTL expression for the offset\n-   into the jump table.  If the offset cannot be determined, then return\n-   NULL_RTX.\n-\n-   If EARLIEST is nonzero, it is a pointer to a place where the earliest\n-   insn used in locating the offset was found.  */\n-\n-rtx\n-get_jump_table_offset (rtx insn, rtx *earliest)\n-{\n-  rtx label = NULL;\n-  rtx table = NULL;\n-  rtx set;\n-  rtx old_insn;\n-  rtx x;\n-  rtx old_x;\n-  rtx y;\n-  rtx old_y;\n-  int i;\n-\n-  if (!tablejump_p (insn, &label, &table) || !(set = single_set (insn)))\n-    return NULL_RTX;\n-\n-  x = SET_SRC (set);\n-\n-  /* Some targets (eg, ARM) emit a tablejump that also\n-     contains the out-of-range target.  */\n-  if (GET_CODE (x) == IF_THEN_ELSE\n-      && GET_CODE (XEXP (x, 2)) == LABEL_REF)\n-    x = XEXP (x, 1);\n-\n-  /* Search backwards and locate the expression stored in X.  */\n-  for (old_x = NULL_RTX; REG_P (x) && x != old_x;\n-       old_x = x, x = find_last_value (x, &insn, NULL_RTX, 0))\n-    ;\n-\n-  /* If X is an expression using a relative address then strip\n-     off the addition / subtraction of PC, PIC_OFFSET_TABLE_REGNUM,\n-     or the jump table label.  */\n-  if (GET_CODE (PATTERN (table)) == ADDR_DIFF_VEC\n-      && (GET_CODE (x) == PLUS || GET_CODE (x) == MINUS))\n-    {\n-      for (i = 0; i < 2; i++)\n-\t{\n-\t  old_insn = insn;\n-\t  y = XEXP (x, i);\n-\n-\t  if (y == pc_rtx || y == pic_offset_table_rtx)\n-\t    break;\n-\n-\t  for (old_y = NULL_RTX; REG_P (y) && y != old_y;\n-\t       old_y = y, y = find_last_value (y, &old_insn, NULL_RTX, 0))\n-\t    ;\n-\n-\t  if ((GET_CODE (y) == LABEL_REF && XEXP (y, 0) == label))\n-\t    break;\n-\t}\n-\n-      if (i >= 2)\n-\treturn NULL_RTX;\n-\n-      x = XEXP (x, 1 - i);\n-\n-      for (old_x = NULL_RTX; REG_P (x) && x != old_x;\n-\t   old_x = x, x = find_last_value (x, &insn, NULL_RTX, 0))\n-\t;\n-    }\n-\n-  /* Strip off any sign or zero extension.  */\n-  if (GET_CODE (x) == SIGN_EXTEND || GET_CODE (x) == ZERO_EXTEND)\n-    {\n-      x = XEXP (x, 0);\n-\n-      for (old_x = NULL_RTX; REG_P (x) && x != old_x;\n-\t   old_x = x, x = find_last_value (x, &insn, NULL_RTX, 0))\n-\t;\n-    }\n-\n-  /* If X isn't a MEM then this isn't a tablejump we understand.  */\n-  if (!MEM_P (x))\n-    return NULL_RTX;\n-\n-  /* Strip off the MEM.  */\n-  x = XEXP (x, 0);\n-\n-  for (old_x = NULL_RTX; REG_P (x) && x != old_x;\n-       old_x = x, x = find_last_value (x, &insn, NULL_RTX, 0))\n-    ;\n-\n-  /* If X isn't a PLUS than this isn't a tablejump we understand.  */\n-  if (GET_CODE (x) != PLUS)\n-    return NULL_RTX;\n-\n-  /* At this point we should have an expression representing the jump table\n-     plus an offset.  Examine each operand in order to determine which one\n-     represents the jump table.  Knowing that tells us that the other operand\n-     must represent the offset.  */\n-  for (i = 0; i < 2; i++)\n-    {\n-      old_insn = insn;\n-      y = XEXP (x, i);\n-\n-      for (old_y = NULL_RTX; REG_P (y) && y != old_y;\n-\t   old_y = y, y = find_last_value (y, &old_insn, NULL_RTX, 0))\n-\t;\n-\n-      if ((GET_CODE (y) == CONST || GET_CODE (y) == LABEL_REF)\n-\t  && reg_mentioned_p (label, y))\n-\tbreak;\n-    }\n-\n-  if (i >= 2)\n-    return NULL_RTX;\n-\n-  x = XEXP (x, 1 - i);\n-\n-  /* Strip off the addition / subtraction of PIC_OFFSET_TABLE_REGNUM.  */\n-  if (GET_CODE (x) == PLUS || GET_CODE (x) == MINUS)\n-    for (i = 0; i < 2; i++)\n-      if (XEXP (x, i) == pic_offset_table_rtx)\n-\t{\n-\t  x = XEXP (x, 1 - i);\n-\t  break;\n-\t}\n-\n-  if (earliest)\n-    *earliest = insn;\n-\n-  /* Return the RTL expression representing the offset.  */\n-  return x;\n-}\n-\f\n /* A subroutine of global_reg_mentioned_p, returns 1 if *LOC mentions\n    a global register.  */\n "}]}