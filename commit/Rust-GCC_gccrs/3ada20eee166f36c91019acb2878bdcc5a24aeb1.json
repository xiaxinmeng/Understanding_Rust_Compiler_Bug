{"sha": "3ada20eee166f36c91019acb2878bdcc5a24aeb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FkYTIwZWVlMTY2ZjM2YzkxMDE5YWNiMjg3OGJkY2M1YTI0YWViMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-12-31T23:16:08Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-12-31T23:16:08Z"}, "message": "regrename.c (build_def_use): Don't rename asm operands that were originally hard registers.\n\n        * regrename.c (build_def_use): Don't rename asm operands that\n        were originally hard registers.\n        (copyprop_hardreg_forward_1): Likewise.\n        (find_oldest_value_reg): Copy ORIGINAL_REGNO from source.\n        * varasm.c (make_decl_rtl): Use gen_rtx_raw_REG.  Set ORIGINAL_REGNO.\n\n        * gcc.dg/asm-5.c: New.\n\nFrom-SVN: r48435", "tree": {"sha": "7d850bce20a5f26a1ae39d2f9c74b5c8ed4ace75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d850bce20a5f26a1ae39d2f9c74b5c8ed4ace75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ada20eee166f36c91019acb2878bdcc5a24aeb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ada20eee166f36c91019acb2878bdcc5a24aeb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ada20eee166f36c91019acb2878bdcc5a24aeb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ada20eee166f36c91019acb2878bdcc5a24aeb1/comments", "author": null, "committer": null, "parents": [{"sha": "5a598cccec409566d2f6905c843b3218aefc8beb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a598cccec409566d2f6905c843b3218aefc8beb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a598cccec409566d2f6905c843b3218aefc8beb"}], "stats": {"total": 182, "additions": 160, "deletions": 22}, "files": [{"sha": "5253f248391875a713be61026e24c82f1e33fcd7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ada20eee166f36c91019acb2878bdcc5a24aeb1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ada20eee166f36c91019acb2878bdcc5a24aeb1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ada20eee166f36c91019acb2878bdcc5a24aeb1", "patch": "@@ -1,3 +1,11 @@\n+2001-12-31  Richard Henderson  <rth@redhat.com>\n+\n+\t* regrename.c (build_def_use): Don't rename asm operands that\n+\twere originally hard registers. \n+\t(copyprop_hardreg_forward_1): Likewise.\n+\t(find_oldest_value_reg): Copy ORIGINAL_REGNO from source.\n+\t* varasm.c (make_decl_rtl): Use gen_rtx_raw_REG.  Set ORIGINAL_REGNO.\n+\n 2001-12-31  Douglas B Rupp  <rupp@gnat.com>\n \n \t* config/alpha/vms.h (HAS_INIT_SECTION, NEED_ATEXIT): Remove."}, {"sha": "720e0cf46c9b705451603b0524183a372a494eaf", "filename": "gcc/regrename.c", "status": "modified", "additions": 61, "deletions": 14, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ada20eee166f36c91019acb2878bdcc5a24aeb1/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ada20eee166f36c91019acb2878bdcc5a24aeb1/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=3ada20eee166f36c91019acb2878bdcc5a24aeb1", "patch": "@@ -838,6 +838,21 @@ build_def_use (bb)\n \t    scan_rtx (insn, &CALL_INSN_FUNCTION_USAGE (insn),\n \t\t      NO_REGS, terminate_all_read, OP_IN, 0);\n \n+\t  /* Step 2C: Can't rename asm operands that were originally\n+\t     hard registers.  */\n+\t  if (asm_noperands (PATTERN (insn)) > 0)\n+\t    for (i = 0; i < n_ops; i++)\n+\t      {\n+\t\trtx *loc = recog_data.operand_loc[i];\n+\t\trtx op = *loc;\n+\n+\t\tif (GET_CODE (op) == REG\n+\t\t    && REGNO (op) == ORIGINAL_REGNO (op)\n+\t\t    && (recog_data.operand_type[i] == OP_IN\n+\t\t\t|| recog_data.operand_type[i] == OP_INOUT))\n+\t\t  scan_rtx (insn, loc, NO_REGS, terminate_all_read, OP_IN, 0);\n+\t      }\n+\n \t  /* Step 3: Append to chains for reads inside operands.  */\n \t  for (i = 0; i < n_ops + recog_data.n_dups; i++)\n \t    {\n@@ -909,8 +924,27 @@ build_def_use (bb)\n \t  /* Step 6: Begin new chains for writes inside operands.  */\n \t  /* ??? Many targets have output constraints on the SET_DEST\n \t     of a call insn, which is stupid, since these are certainly\n-\t     ABI defined hard registers.  Don't change calls at all.  */\n-\t  if (GET_CODE (insn) != CALL_INSN)\n+\t     ABI defined hard registers.  Don't change calls at all.\n+\t     Similarly take special care for asm statement that originally\n+\t     referenced hard registers.  */\n+\t  if (asm_noperands (PATTERN (insn)) > 0)\n+\t    {\n+\t      for (i = 0; i < n_ops; i++)\n+\t\tif (recog_data.operand_type[i] == OP_OUT)\n+\t\t  {\n+\t\t    rtx *loc = recog_data.operand_loc[i];\n+\t\t    rtx op = *loc;\n+\t\t    enum reg_class class = recog_op_alt[i][alt].class;\n+\n+\t\t    if (GET_CODE (op) == REG\n+\t\t        && REGNO (op) == ORIGINAL_REGNO (op))\n+\t\t      continue;\n+\n+\t\t    scan_rtx (insn, loc, class, mark_write, OP_OUT,\n+\t\t\t      recog_op_alt[i][alt].earlyclobber);\n+\t\t  }\n+\t    }\n+\t  else if (GET_CODE (insn) != CALL_INSN)\n \t    for (i = 0; i < n_ops + recog_data.n_dups; i++)\n \t      {\n \t\tint opn = i < n_ops ? i : recog_data.dup_num[i - n_ops];\n@@ -1000,9 +1034,8 @@ static int kill_autoinc_value PARAMS ((rtx *, void *));\n static void copy_value PARAMS ((rtx, rtx, struct value_data *));\n static bool mode_change_ok PARAMS ((enum machine_mode, enum machine_mode,\n \t\t\t\t    unsigned int));\n-static rtx find_oldest_value_reg PARAMS ((enum reg_class, unsigned int,\n-\t\t\t\t\t    enum machine_mode,\n-\t\t\t\t\t    struct value_data *));\n+static rtx find_oldest_value_reg PARAMS ((enum reg_class, rtx,\n+\t\t\t\t\t  struct value_data *));\n static bool replace_oldest_value_reg PARAMS ((rtx *, enum reg_class, rtx,\n \t\t\t\t\t      struct value_data *));\n static bool replace_oldest_value_addr PARAMS ((rtx *, enum reg_class,\n@@ -1240,19 +1273,24 @@ mode_change_ok (orig_mode, new_mode, regno)\n    of that oldest register, otherwise return NULL.  */\n \n static rtx\n-find_oldest_value_reg (class, regno, mode, vd)\n+find_oldest_value_reg (class, reg, vd)\n      enum reg_class class;\n-     unsigned int regno;\n-     enum machine_mode mode;\n+     rtx reg;\n      struct value_data *vd;\n {\n+  unsigned int regno = REGNO (reg);\n+  enum machine_mode mode = GET_MODE (reg);\n   unsigned int i;\n \n   for (i = vd->e[regno].oldest_regno; i != regno; i = vd->e[i].next_regno)\n     if (TEST_HARD_REG_BIT (reg_class_contents[class], i)\n \t&& (vd->e[i].mode == mode\n \t    || mode_change_ok (vd->e[i].mode, mode, regno)))\n-      return gen_rtx_REG (mode, i);\n+      {\n+\trtx new = gen_rtx_REG (mode, i);\n+\tORIGINAL_REGNO (new) = ORIGINAL_REGNO (reg);\n+\treturn new;\n+      }\n \n   return NULL_RTX;\n }\n@@ -1267,7 +1305,7 @@ replace_oldest_value_reg (loc, class, insn, vd)\n      rtx insn;\n      struct value_data *vd;\n {\n-  rtx new = find_oldest_value_reg (class, REGNO (*loc), GET_MODE (*loc), vd);\n+  rtx new = find_oldest_value_reg (class, *loc, vd);\n   if (new)\n     {\n       if (rtl_dump_file)\n@@ -1443,6 +1481,7 @@ copyprop_hardreg_forward_1 (bb, vd)\n   for (insn = bb->head; ; insn = NEXT_INSN (insn))\n     {\n       int n_ops, i, alt, predicated;\n+      bool is_asm;\n       rtx set;\n \n       if (! INSN_P (insn))\n@@ -1459,6 +1498,7 @@ copyprop_hardreg_forward_1 (bb, vd)\n       preprocess_constraints ();\n       alt = which_alternative;\n       n_ops = recog_data.n_operands;\n+      is_asm = asm_noperands (PATTERN (insn)) >= 0;\n \n       /* Simplify the code below by rewriting things to reflect\n \t matching constraints.  Also promote OP_OUT to OP_INOUT\n@@ -1498,17 +1538,17 @@ copyprop_hardreg_forward_1 (bb, vd)\n \t be able to do the move from a different register class.  */\n       if (set && REG_P (SET_SRC (set)))\n \t{\n-\t  unsigned int regno = REGNO (SET_SRC (set));\n-\t  enum machine_mode mode = GET_MODE (SET_SRC (set));\n+\t  rtx src = SET_SRC (set);\n+\t  unsigned int regno = REGNO (src);\n+\t  enum machine_mode mode = GET_MODE (src);\n \t  unsigned int i;\n \t  rtx new;\n \n \t  /* If the destination is also a register, try to find a source\n \t     register in the same class.  */\n \t  if (REG_P (SET_DEST (set)))\n \t    {\n-\t      new = find_oldest_value_reg (REGNO_REG_CLASS (regno),\n-\t\t\t\t\t   regno, mode, vd);\n+\t      new = find_oldest_value_reg (REGNO_REG_CLASS (regno), src, vd);\n \t      if (new && validate_change (insn, &SET_SRC (set), new, 0))\n \t\t{\n \t\t  if (rtl_dump_file)\n@@ -1528,6 +1568,7 @@ copyprop_hardreg_forward_1 (bb, vd)\n \t\tnew = gen_rtx_REG (mode, i);\n \t\tif (validate_change (insn, &SET_SRC (set), new, 0))\n \t\t  {\n+\t\t    ORIGINAL_REGNO (new) = ORIGINAL_REGNO (src);\n \t\t    if (rtl_dump_file)\n \t\t      fprintf (rtl_dump_file,\n \t\t\t       \"insn %u: replaced reg %u with %u\\n\",\n@@ -1550,6 +1591,12 @@ copyprop_hardreg_forward_1 (bb, vd)\n \t  if (recog_data.constraints[i][0] == '\\0')\n \t    continue;\n \n+\t  /* Don't replace in asms intentionally referencing hard regs.  */\n+\t  if (is_asm && GET_CODE (recog_data.operand[i]) == REG\n+\t      && (REGNO (recog_data.operand[i])\n+\t\t  == ORIGINAL_REGNO (recog_data.operand[i])))\n+\t    continue;\n+\n \t  if (recog_data.operand_type[i] == OP_IN)\n \t    {\n \t      if (recog_op_alt[i][alt].is_address)"}, {"sha": "d97cc967a6f6add52d3db8fcad5e81f86a10f04b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ada20eee166f36c91019acb2878bdcc5a24aeb1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ada20eee166f36c91019acb2878bdcc5a24aeb1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3ada20eee166f36c91019acb2878bdcc5a24aeb1", "patch": "@@ -1,3 +1,7 @@\n+2001-12-31  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.dg/asm-5.c: New.\n+\n 2001-12-31  Paolo Carlini  <pcarlini@unitus.it>\n \n \t* g++.old-deja/g++.robertl/eb130.C: hash_set is now"}, {"sha": "7b8d0f2f6c526dea87064e1af54ac0f686962e9a", "filename": "gcc/testsuite/gcc.dg/asm-5.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ada20eee166f36c91019acb2878bdcc5a24aeb1/gcc%2Ftestsuite%2Fgcc.dg%2Fasm-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ada20eee166f36c91019acb2878bdcc5a24aeb1/gcc%2Ftestsuite%2Fgcc.dg%2Fasm-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fasm-5.c?ref=3ada20eee166f36c91019acb2878bdcc5a24aeb1", "patch": "@@ -0,0 +1,82 @@\n+/* Asm operands that are given as hard registers must keep the same\n+   hard register all the way through compilation.  Example derived\n+   from glibc source.  */\n+/* { dg-do compile { target alpha*-*-* } } */\n+/* { dg-options \"-O2 -frename-registers -fcprop-registers\" } */\n+/* { dg-final { scan-assembler \"callsys1 .0 .19 .0 .16 .17\" } } */\n+/* { dg-final { scan-assembler \"callsys2 .0 .19 .0 .16 .17\" } } */\n+\n+struct stat {\n+  int dummy;\n+};\n+\n+struct kernel_stat {\n+  int dummy;\n+};\n+\n+extern int xstat_conv (int vers, struct kernel_stat *kbuf, void *ubuf);\n+extern int *__errno_location (void) __attribute__ ((__const__));\n+\n+int\n+__fxstat (int vers, int fd, struct stat *buf)\n+{\n+  struct kernel_stat kbuf;\n+  int result;\n+\n+  if (vers == 0)\n+    return\n+      ({\n+\tlong _sc_ret, _sc_err;\n+\t{\n+\t  register long _sc_0 __asm__(\"$0\");\n+\t  register long _sc_16 __asm__(\"$16\");\n+\t  register long _sc_17 __asm__(\"$17\");\n+\t  register long _sc_19 __asm__(\"$19\");\n+\t  _sc_0 = 91;\n+\t  _sc_16 = (long) (fd);\n+\t  _sc_17 = (long) (((struct kernel_stat *) buf));\n+\t  __asm__(\"callsys1 %0 %1 %2 %3 %4\"\n+\t\t  : \"=r\"(_sc_0), \"=r\"(_sc_19)\n+\t\t  : \"0\"(_sc_0), \"r\"(_sc_16), \"r\"(_sc_17)\n+\t\t  : \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\",\n+\t\t    \"$22\", \"$23\", \"$24\", \"$25\", \"$27\", \"$28\", \"memory\");\n+\t  _sc_ret = _sc_0, _sc_err = _sc_19;\n+\t}\n+\tif (_sc_err)\n+\t  {\n+\t    (*__errno_location ()) = (_sc_ret);\n+\t    _sc_ret = -1L;\n+\t  }\n+\t_sc_ret;\n+      });\n+\n+  result =\n+      ({\n+\tlong _sc_ret, _sc_err;\n+\t{\n+\t  register long _sc_0 __asm__(\"$0\");\n+\t  register long _sc_16 __asm__(\"$16\");\n+\t  register long _sc_17 __asm__(\"$17\");\n+\t  register long _sc_19 __asm__(\"$19\");\n+\t  _sc_0 = 91;\n+\t  _sc_16 = (long) (fd);\n+\t  _sc_17 = (long) ((&kbuf));\n+\t  __asm__(\"callsys2 %0 %1 %2 %3 %4\"\n+\t\t  : \"=r\"(_sc_0), \"=r\"(_sc_19)\n+\t\t  : \"0\"(_sc_0), \"r\"(_sc_16), \"r\"(_sc_17)\n+\t\t  : \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\",\n+\t\t    \"$22\", \"$23\", \"$24\", \"$25\", \"$27\", \"$28\", \"memory\");\n+\t  _sc_ret = _sc_0, _sc_err = _sc_19;\n+\t}\n+\tif (_sc_err)\n+\t  {\n+\t    (*__errno_location ()) = (_sc_ret);\n+\t    _sc_ret = -1L;\n+\t  }\n+\t_sc_ret;\n+      });\n+  if (result == 0)\n+    result = xstat_conv (vers, &kbuf, buf);\n+\n+  return result;\n+}"}, {"sha": "b88615107e613207fe57febfacdc0883464260ec", "filename": "gcc/varasm.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ada20eee166f36c91019acb2878bdcc5a24aeb1/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ada20eee166f36c91019acb2878bdcc5a24aeb1/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=3ada20eee166f36c91019acb2878bdcc5a24aeb1", "patch": "@@ -898,14 +898,11 @@ make_decl_rtl (decl, asmspec)\n \n \t  /* If the user specified one of the eliminables registers here,\n \t     e.g., FRAME_POINTER_REGNUM, we don't want to get this variable\n-\t     confused with that register and be eliminated.  Although this\n-\t     usage is somewhat suspect, we nevertheless use the following\n-\t     kludge to avoid setting DECL_RTL to frame_pointer_rtx.  */\n-\n-\t  SET_DECL_RTL (decl,\n-\t\t\tgen_rtx_REG (DECL_MODE (decl),\n-\t\t\t\t     FIRST_PSEUDO_REGISTER));\n-\t  REGNO (DECL_RTL (decl)) = reg_number;\n+\t     confused with that register and be eliminated.  This usage is\n+\t     somewhat suspect...  */\n+\n+\t  SET_DECL_RTL (decl, gen_rtx_raw_REG (DECL_MODE (decl), reg_number));\n+\t  ORIGINAL_REGNO (DECL_RTL (decl)) = reg_number;\n \t  REG_USERVAR_P (DECL_RTL (decl)) = 1;\n \n \t  if (TREE_STATIC (decl))"}]}