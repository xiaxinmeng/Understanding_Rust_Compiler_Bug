{"sha": "4a444e581667f110bfa936aa8d364cd751237770", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE0NDRlNTgxNjY3ZjExMGJmYTkzNmFhOGQzNjRjZDc1MTIzNzc3MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-14T23:39:39Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-14T23:39:39Z"}, "message": "cgraph.h (ipa_discover_readonly_nonaddressable_vars): Declare.\n\n\t* cgraph.h (ipa_discover_readonly_nonaddressable_vars): Declare.\n\t(varpool_all_refs_explicit_p): New inline function.\n\t* ipa-reference.c: Update comment.\n\t(module_statics_written): Remove.\n\t(get_static_decl): Remove.\n\t(ipa_init): Do not initialize module_statics_written.\n\t(analyze_function): Likewise.\n\t(generate_summary): Likewise; do not compute module_statics_readonly\n\tand do not update variable flags.\n\t(propagate): Call ipa_discover_readonly_nonaddressable_vars.\n\t* ipa.c: Inlucde flags.h\n\t(cgraph_local_node_p): New.\n\t(cgraph_remove_unreachable_nodes): Return early when not optimizing;\n\tpromote functions to local.\n\t(ipa_discover_readonly_nonaddressable_vars): New function.\n\t(function_and_variable_visibility): Use cgraph_local_node_p.\n\t* varpool.c (varpool_finalize_decl): Set force_output for\n\tDECL_PRESERVE_P vars.\n\nFrom-SVN: r159421", "tree": {"sha": "8b66371ae30124b7de964c08882e02d1b3128842", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b66371ae30124b7de964c08882e02d1b3128842"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a444e581667f110bfa936aa8d364cd751237770", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a444e581667f110bfa936aa8d364cd751237770", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a444e581667f110bfa936aa8d364cd751237770", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a444e581667f110bfa936aa8d364cd751237770/comments", "author": null, "committer": null, "parents": [{"sha": "c13af44bcc9d9435b4a537d189e5d3b6edffe7fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13af44bcc9d9435b4a537d189e5d3b6edffe7fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c13af44bcc9d9435b4a537d189e5d3b6edffe7fe"}], "stats": {"total": 221, "additions": 140, "deletions": 81}, "files": [{"sha": "651b67d0b80098c2e589215bc9e4fe61e87928cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a444e581667f110bfa936aa8d364cd751237770/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a444e581667f110bfa936aa8d364cd751237770/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a444e581667f110bfa936aa8d364cd751237770", "patch": "@@ -1,3 +1,24 @@\n+2010-05-14  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (ipa_discover_readonly_nonaddressable_vars): Declare.\n+\t(varpool_all_refs_explicit_p): New inline function.\n+\t* ipa-reference.c: Update comment.\n+\t(module_statics_written): Remove.\n+\t(get_static_decl): Remove.\n+\t(ipa_init): Do not initialize module_statics_written.\n+\t(analyze_function): Likewise.\n+\t(generate_summary): Likewise; do not compute module_statics_readonly\n+\tand do not update variable flags.\n+\t(propagate): Call ipa_discover_readonly_nonaddressable_vars.\n+\t* ipa.c: Inlucde flags.h\n+\t(cgraph_local_node_p): New.\n+\t(cgraph_remove_unreachable_nodes): Return early when not optimizing;\n+\tpromote functions to local.\n+\t(ipa_discover_readonly_nonaddressable_vars): New function.\n+\t(function_and_variable_visibility): Use cgraph_local_node_p.\n+\t* varpool.c (varpool_finalize_decl): Set force_output for\n+\tDECL_PRESERVE_P vars.\n+\n 2010-05-14  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa.c (cgraph_remove_unreachable_nodes): Revert accidental commit."}, {"sha": "634803318dd5bf47ab6351011e602526d5bcdf7d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a444e581667f110bfa936aa8d364cd751237770/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a444e581667f110bfa936aa8d364cd751237770/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=4a444e581667f110bfa936aa8d364cd751237770", "patch": "@@ -644,6 +644,7 @@ void varpool_node_set_add (varpool_node_set, struct varpool_node *);\n void varpool_node_set_remove (varpool_node_set, struct varpool_node *);\n void dump_varpool_node_set (FILE *, varpool_node_set);\n void debug_varpool_node_set (varpool_node_set);\n+void ipa_discover_readonly_nonaddressable_vars (void);\n \n /* In predict.c  */\n bool cgraph_maybe_hot_edge_p (struct cgraph_edge *e);\n@@ -878,6 +879,19 @@ cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node)\n   return !node->address_taken && cgraph_can_remove_if_no_direct_calls_and_refs_p (node);\n }\n \n+/* Return true when all references to VNODE must be visible in ipa_ref_list.\n+   i.e. if the variable is not externally visible or not used in some magic\n+   way (asm statement or such).\n+   The magic uses are all sumarized in force_output flag.  */\n+\n+static inline bool\n+varpool_all_refs_explicit_p (struct varpool_node *vnode)\n+{\n+  return (!vnode->externally_visible\n+\t  && !vnode->used_from_other_partition\n+\t  && !vnode->force_output);\n+}\n+\n /* Constant pool accessor function.  */\n htab_t constant_pool_htab (void);\n "}, {"sha": "3180a9d0209986fb2139d7929dc740ee1201b755", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 3, "deletions": 71, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a444e581667f110bfa936aa8d364cd751237770/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a444e581667f110bfa936aa8d364cd751237770/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=4a444e581667f110bfa936aa8d364cd751237770", "patch": "@@ -22,13 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n /* This file gathers information about how variables whose scope is\n    confined to the compilation unit are used.\n \n-   There are two categories of information produced by this pass:\n-\n-   1) The addressable (TREE_ADDRESSABLE) bit and readonly\n-   (TREE_READONLY) bit associated with these variables is properly set\n-   based on scanning all of the code withing the compilation unit.\n-\n-   2) The transitive call site specific clobber effects are computed\n+   The transitive call site specific clobber effects are computed\n    for the variables whose scope is contained within this compilation\n    unit.\n \n@@ -41,12 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n    side effects of each call.  In later parts of the compiler, these\n    local and global sets are examined to make the call clobbering less\n    traumatic, promote some statics to registers, and improve aliasing\n-   information.\n-\n-   Currently must be run after inlining decisions have been made since\n-   otherwise, the local sets will not contain information that is\n-   consistent with post inlined state.  The global sets are not prone\n-   to this problem since they are by definition transitive.  */\n+   information.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -136,10 +125,6 @@ static GTY((param1_is(int), param2_is(tree)))\n    addresses have been taken and passed around.  */\n static bitmap module_statics_escape;\n \n-/* This bitmap is used to knock out the module static variables that\n-   are not readonly.  */\n-static bitmap module_statics_written;\n-\n /* A bit is set for every module static we are considering.  This is\n    ored into the local info when asm code is found that clobbers all\n    memory. */\n@@ -308,17 +293,6 @@ is_proper_for_analysis (tree t)\n   return true;\n }\n \n-/* Lookup the tree node for the static variable that has UID.  */\n-static tree\n-get_static_decl (int index)\n-{\n-  splay_tree_node stn =\n-    splay_tree_lookup (reference_vars_to_consider, index);\n-  if (stn)\n-    return (tree)stn->value;\n-  return NULL;\n-}\n-\n /* Lookup the tree node for the static variable that has UID and\n    convert the name to a string for debugging.  */\n \n@@ -419,7 +393,6 @@ ipa_init (void)\n   bitmap_obstack_initialize (&local_info_obstack);\n   bitmap_obstack_initialize (&global_info_obstack);\n   module_statics_escape = BITMAP_ALLOC (&local_info_obstack);\n-  module_statics_written = BITMAP_ALLOC (&local_info_obstack);\n   all_module_statics = BITMAP_ALLOC (&global_info_obstack);\n \n   node_removal_hook_holder =\n@@ -524,7 +497,6 @@ analyze_function (struct cgraph_node *fn)\n \t  break;\n \tcase IPA_REF_STORE:\n           bitmap_set_bit (local->statics_written, DECL_UID (var));\n-\t  bitmap_set_bit (module_statics_written, DECL_UID (var));\n \t  break;\n \tcase IPA_REF_ADDR:\n \t  bitmap_set_bit (module_statics_escape, DECL_UID (var));\n@@ -656,11 +628,9 @@ generate_summary (void)\n   struct varpool_node *vnode;\n   unsigned int index;\n   bitmap_iterator bi;\n-  bitmap module_statics_readonly;\n   bitmap bm_temp;\n \n   ipa_init ();\n-  module_statics_readonly = BITMAP_ALLOC (&local_info_obstack);\n   bm_temp = BITMAP_ALLOC (&local_info_obstack);\n \n   /* Process all of the variables first.  */\n@@ -682,46 +652,8 @@ generate_summary (void)\n   bitmap_and_compl_into (all_module_statics,\n \t\t\t module_statics_escape);\n \n-  bitmap_and_compl (module_statics_readonly, all_module_statics,\n-\t\t    module_statics_written);\n-\n-  /* If the address is not taken, we can unset the addressable bit\n-     on this variable.  */\n-  EXECUTE_IF_SET_IN_BITMAP (all_module_statics, 0, index, bi)\n-    {\n-      tree var = get_static_decl (index);\n-      TREE_ADDRESSABLE (var) = 0;\n-      if (dump_file)\n-\tfprintf (dump_file, \"Not TREE_ADDRESSABLE var %s\\n\",\n-\t\t get_static_name (index));\n-    }\n-\n-  /* If the variable is never written, we can set the TREE_READONLY\n-     flag.  Additionally if it has a DECL_INITIAL that is made up of\n-     constants we can treat the entire global as a constant.  */\n-\n-  bitmap_and_compl (module_statics_readonly, all_module_statics,\n-\t\t    module_statics_written);\n-  EXECUTE_IF_SET_IN_BITMAP (module_statics_readonly, 0, index, bi)\n-    {\n-      tree var = get_static_decl (index);\n-\n-      /* Ignore variables in named sections - changing TREE_READONLY\n-\t changes the section flags, potentially causing conflicts with\n-\t other variables in the same named section.  */\n-      if (DECL_SECTION_NAME (var) == NULL_TREE)\n-\t{\n-\t  TREE_READONLY (var) = 1;\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"read-only var %s\\n\",\n-\t\t     get_static_name (index));\n-\t}\n-    }\n-\n   BITMAP_FREE(module_statics_escape);\n-  BITMAP_FREE(module_statics_written);\n   module_statics_escape = NULL;\n-  module_statics_written = NULL;\n \n   if (dump_file)\n     EXECUTE_IF_SET_IN_BITMAP (all_module_statics, 0, index, bi)\n@@ -748,7 +680,6 @@ generate_summary (void)\n \t\t\t   all_module_statics);\n       }\n \n-  BITMAP_FREE(module_statics_readonly);\n   BITMAP_FREE(bm_temp);\n \n   if (dump_file)\n@@ -1093,6 +1024,7 @@ propagate (void)\n \tclean_function_local_data (node);\n     }\n   bitmap_obstack_release (&local_info_obstack);\n+  ipa_discover_readonly_nonaddressable_vars ();\n   return 0;\n }\n "}, {"sha": "9d2b023a5b0a666244add1c4e644dda612d066df", "filename": "gcc/ipa.c", "status": "modified", "additions": 101, "deletions": 9, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a444e581667f110bfa936aa8d364cd751237770/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a444e581667f110bfa936aa8d364cd751237770/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=4a444e581667f110bfa936aa8d364cd751237770", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"gimple.h\"\n #include \"ggc.h\"\n+#include \"flags.h\"\n \n /* Fill array order with all nodes with output flag set in the reverse\n    topological order.  */\n@@ -194,6 +195,19 @@ varpool_can_remove_if_no_refs (struct varpool_node *node)\n   \t  && (DECL_COMDAT (node->decl) || !node->externally_visible));\n }\n \n+/* Return true when function can be marked local.  */\n+\n+static bool\n+cgraph_local_node_p (struct cgraph_node *node)\n+{\n+   return (cgraph_only_called_directly_p (node)\n+\t   && node->analyzed\n+\t   && !DECL_EXTERNAL (node->decl)\n+\t   && !node->local.externally_visible\n+\t   && !node->reachable_from_other_partition\n+\t   && !node->in_other_partition);\n+}\n+\n /* Perform reachability analysis and reclaim all unreachable nodes.\n    If BEFORE_INLINING_P is true this function is called before inlining\n    decisions has been made.  If BEFORE_INLINING_P is false this function also\n@@ -408,18 +422,31 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t}\n       node->aux = NULL;\n     }\n+\n   if (file)\n-    fprintf (file, \"\\nReclaiming variables:\");\n+    fprintf (file, \"\\n\");\n+\n+  /* We must release unused extern inlines or sanity checking will fail.  Rest of transformations\n+     are undesirable at -O0 since we do not want to remove anything.  */\n+  if (!optimize)\n+    return changed;\n+\n+  if (file)\n+    fprintf (file, \"Reclaiming variables:\");\n   for (vnode = varpool_nodes; vnode; vnode = vnext)\n     {\n       vnext = vnode->next;\n       if (!vnode->needed)\n         {\n-\t   if (file)\n-\t     fprintf (file, \" %s\", varpool_node_name (vnode));\n-\t   varpool_remove_node (vnode);\n+\t  if (file)\n+\t    fprintf (file, \" %s\", varpool_node_name (vnode));\n+\t  varpool_remove_node (vnode);\n+\t  changed = true;\n \t}\n     }\n+\n+  /* Now update address_taken flags and try to promote functions to be local.  */\n+\n   if (file)\n     fprintf (file, \"\\nClearing address taken flags:\");\n   for (node = cgraph_nodes; node; node = node->next)\n@@ -431,12 +458,22 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \tbool found = false;\n         for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref)\n \t\t    && !found; i++)\n-\t  found = true;\n+\t  {\n+\t    gcc_assert (ref->use == IPA_REF_ADDR);\n+\t    found = true;\n+\t  }\n \tif (!found)\n \t  {\n \t    if (file)\n \t      fprintf (file, \" %s\", cgraph_node_name (node));\n \t    node->address_taken = false;\n+\t    changed = true;\n+\t    if (cgraph_local_node_p (node))\n+\t      {\n+\t\tnode->local.local = true;\n+\t\tif (file)\n+\t\t  fprintf (file, \" (local)\");\n+\t      }\n \t  }\n       }\n \n@@ -451,6 +488,64 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   return changed;\n }\n \n+/* Discover variables that have no longer address taken or that are read only\n+   and update their flags.\n+\n+   FIXME: This can not be done in between gimplify and omp_expand since\n+   readonly flag plays role on what is shared and what is not.  Currently we do\n+   this transformation as part of ipa-reference pass, but it would make sense\n+   to do it before early optimizations.  */\n+\n+void\n+ipa_discover_readonly_nonaddressable_vars (void)\n+{\n+  struct varpool_node *vnode;\n+  if (dump_file)\n+    fprintf (dump_file, \"Clearing variable flags:\");\n+  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+    if (vnode->finalized && varpool_all_refs_explicit_p (vnode)\n+\t&& (TREE_ADDRESSABLE (vnode->decl) || !TREE_READONLY (vnode->decl)))\n+      {\n+\tbool written = false;\n+\tbool address_taken = false;\n+\tint i;\n+        struct ipa_ref *ref;\n+        for (i = 0; ipa_ref_list_refering_iterate (&vnode->ref_list, i, ref)\n+\t\t    && (!written || !address_taken); i++)\n+\t  switch (ref->use)\n+\t    {\n+\t    case IPA_REF_ADDR:\n+\t      address_taken = true;\n+\t      break;\n+\t    case IPA_REF_LOAD:\n+\t      break;\n+\t    case IPA_REF_STORE:\n+\t      written = true;\n+\t      break;\n+\t    }\n+\tif (TREE_ADDRESSABLE (vnode->decl) && !address_taken)\n+\t  {\n+\t    if (dump_file)\n+\t      fprintf (dump_file, \" %s (addressable)\", varpool_node_name (vnode));\n+\t    TREE_ADDRESSABLE (vnode->decl) = 0;\n+\t  }\n+\tif (!TREE_READONLY (vnode->decl) && !address_taken && !written\n+\t    /* Making variable in explicit section readonly can cause section\n+\t       type conflict. \n+\t       See e.g. gcc.c-torture/compile/pr23237.c */\n+\t    && DECL_SECTION_NAME (vnode->decl) == NULL)\n+\t  {\n+\t    if (dump_file)\n+\t      fprintf (dump_file, \" %s (read-only)\", varpool_node_name (vnode));\n+\t    TREE_READONLY (vnode->decl) = 1;\n+\t  }\n+      }\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n\");\n+}\n+\n+/* Return true when function NODE should be considered externally visible.  */\n+\n static bool\n cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program)\n {\n@@ -569,10 +664,7 @@ function_and_variable_visibility (bool whole_program)\n \t       segfault though. */\n \t    dissolve_same_comdat_group_list (node);\n \t}\n-      node->local.local = (cgraph_only_called_directly_p (node)\n-\t\t\t   && node->analyzed\n-\t\t\t   && !DECL_EXTERNAL (node->decl)\n-\t\t\t   && !node->local.externally_visible);\n+      node->local.local = cgraph_local_node_p (node);\n     }\n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n     {"}, {"sha": "c713a7705f6eb7bfa0083824d30f902d5ae9bdaf", "filename": "gcc/varpool.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a444e581667f110bfa936aa8d364cd751237770/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a444e581667f110bfa936aa8d364cd751237770/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=4a444e581667f110bfa936aa8d364cd751237770", "patch": "@@ -374,7 +374,7 @@ varpool_finalize_decl (tree decl)\n   if (node->needed)\n     varpool_enqueue_needed_node (node);\n   node->finalized = true;\n-  if (TREE_THIS_VOLATILE (decl))\n+  if (TREE_THIS_VOLATILE (decl) || DECL_PRESERVE_P (decl))\n     node->force_output = true;\n \n   if (decide_is_variable_needed (node, decl))"}]}