{"sha": "37af03cba8d6cd7b1fd7830748e3d9d6e47f3009", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdhZjAzY2JhOGQ2Y2Q3YjFmZDc4MzA3NDhlM2Q5ZDZlNDdmMzAwOQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-09-16T17:08:50Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-09-16T17:08:50Z"}, "message": "fold-const.c (tree_swap_operands_p): New function to determine the prefered ordering of operands.\n\n\n\t* fold-const.c (tree_swap_operands_p): New function to determine\n\tthe prefered ordering of operands.\n\t(fold): Numerous clean-ups.  Use tree_swap_operands_p when swapping\n\toperands to commutative, comparison or ternary operators.  Replace\n\tuses of TREE_SET_CODE with recursive call to fold.  Remove duplicate\n\ttransformation of A ? B : C into !A ? C : B.\n\nFrom-SVN: r71438", "tree": {"sha": "6e5d15370ebc93fe3fe8a8b8f79e3514f5367460", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e5d15370ebc93fe3fe8a8b8f79e3514f5367460"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37af03cba8d6cd7b1fd7830748e3d9d6e47f3009", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37af03cba8d6cd7b1fd7830748e3d9d6e47f3009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37af03cba8d6cd7b1fd7830748e3d9d6e47f3009", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37af03cba8d6cd7b1fd7830748e3d9d6e47f3009/comments", "author": null, "committer": null, "parents": [{"sha": "ae8803a8e1d21a5813775816ae915f4ccd92d6c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae8803a8e1d21a5813775816ae915f4ccd92d6c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae8803a8e1d21a5813775816ae915f4ccd92d6c5"}], "stats": {"total": 211, "additions": 85, "deletions": 126}, "files": [{"sha": "cce3c91bff5abe8a53336877749836e57d43debe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37af03cba8d6cd7b1fd7830748e3d9d6e47f3009/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37af03cba8d6cd7b1fd7830748e3d9d6e47f3009/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=37af03cba8d6cd7b1fd7830748e3d9d6e47f3009", "patch": "@@ -1,3 +1,12 @@\n+2003-09-16  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (tree_swap_operands_p): New function to determine\n+\tthe prefered ordering of operands.\n+\t(fold): Numerous clean-ups.  Use tree_swap_operands_p when swapping\n+\toperands to commutative, comparison or ternary operators.  Replace\n+\tuses of TREE_SET_CODE with recursive call to fold.  Remove duplicate\n+\ttransformation of A ? B : C into !A ? C : B.\n+\n 2003-09-16  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/linux.h (LINK_GCC_C_SEQUENCE_SPEC): Define."}, {"sha": "07143bcb9855b80c618e4677e187662ff80adb50", "filename": "gcc/fold-const.c", "status": "modified", "additions": 76, "deletions": 126, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37af03cba8d6cd7b1fd7830748e3d9d6e47f3009/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37af03cba8d6cd7b1fd7830748e3d9d6e47f3009/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=37af03cba8d6cd7b1fd7830748e3d9d6e47f3009", "patch": "@@ -108,6 +108,7 @@ static bool fold_real_zero_addition_p (tree, tree, int);\n static tree fold_mathfn_compare (enum built_in_function, enum tree_code,\n \t\t\t\t tree, tree, tree);\n static tree fold_inf_compare (enum tree_code, tree, tree, tree);\n+static bool tree_swap_operands_p (tree, tree);\n \n /* The following constants represent a bit based encoding of GCC's\n    comparison operators.  This encoding simplifies transformations\n@@ -4976,6 +4977,49 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n   return NULL_TREE;\n }\n \n+/* Test whether it is preferable two swap two operands, ARG0 and\n+   ARG1, for example because ARG0 is an integer constant and ARG1\n+   isn't.  */\n+\n+static bool\n+tree_swap_operands_p (tree arg0, tree arg1)\n+{\n+  STRIP_SIGN_NOPS (arg0);\n+  STRIP_SIGN_NOPS (arg1);\n+\n+  if (TREE_CODE (arg1) == INTEGER_CST)\n+    return 0;\n+  if (TREE_CODE (arg0) == INTEGER_CST)\n+    return 1;\n+\n+  if (TREE_CODE (arg1) == REAL_CST)\n+    return 0;\n+  if (TREE_CODE (arg0) == REAL_CST)\n+    return 1;\n+\n+  if (TREE_CODE (arg1) == COMPLEX_CST)\n+    return 0;\n+  if (TREE_CODE (arg0) == COMPLEX_CST)\n+    return 1;\n+\n+  if (TREE_CONSTANT (arg1))\n+    return 0;\n+  if (TREE_CONSTANT (arg0))\n+    return 1;\n+\n+  if (DECL_P (arg1))\n+    return 0;\n+  if (DECL_P (arg0))\n+    return 1;\n+\n+  if (TREE_CODE (arg1) == SAVE_EXPR)\n+    return 0;\n+  if (TREE_CODE (arg0) == SAVE_EXPR)\n+    return 1;\n+\n+  return 0;\n+}\n+\n /* Perform constant folding and related simplification of EXPR.\n    The related simplifications include x*1 => x, x*0 => 0, etc.,\n    and application of the associative law.\n@@ -5035,8 +5079,7 @@ fold (tree expr)\n \tsubop = arg0;\n \n       if (subop != 0 && TREE_CODE (subop) != INTEGER_CST\n-\t  && TREE_CODE (subop) != REAL_CST\n-\t  )\n+\t  && TREE_CODE (subop) != REAL_CST)\n \t/* Note that TREE_CONSTANT isn't enough:\n \t   static var addresses are constant but we can't\n \t   do arithmetic on them.  */\n@@ -5088,16 +5131,8 @@ fold (tree expr)\n   if ((code == PLUS_EXPR || code == MULT_EXPR || code == MIN_EXPR\n        || code == MAX_EXPR || code == BIT_IOR_EXPR || code == BIT_XOR_EXPR\n        || code == BIT_AND_EXPR)\n-      && ((TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) != INTEGER_CST)\n-\t  || (TREE_CODE (arg0) == REAL_CST && TREE_CODE (arg1) != REAL_CST)))\n-    {\n-      tem = arg0; arg0 = arg1; arg1 = tem;\n-\n-      if (t == orig_t)\n-\tt = copy_node (t);\n-      TREE_OPERAND (t, 0) = arg0;\n-      TREE_OPERAND (t, 1) = arg1;\n-    }\n+      && tree_swap_operands_p (arg0, arg1))\n+    return fold (build (code, type, arg1, arg0));\n \n   /* Now WINS is set as described above,\n      ARG0 is the first operand of EXPR,\n@@ -6645,18 +6680,10 @@ fold (tree expr)\n \t RROTATE_EXPR by a new constant.  */\n       if (code == LROTATE_EXPR && TREE_CODE (arg1) == INTEGER_CST)\n \t{\n-\t  if (t == orig_t)\n-\t    t = copy_node (t);\n-\t  TREE_SET_CODE (t, RROTATE_EXPR);\n-\t  code = RROTATE_EXPR;\n-\t  TREE_OPERAND (t, 1) = arg1\n-\t    = const_binop\n-\t      (MINUS_EXPR,\n-\t       convert (TREE_TYPE (arg1),\n-\t\t\tbuild_int_2 (GET_MODE_BITSIZE (TYPE_MODE (type)), 0)),\n-\t       arg1, 0);\n-\t  if (tree_int_cst_sgn (arg1) < 0)\n-\t    return t;\n+\t  tree tem = build_int_2 (GET_MODE_BITSIZE (TYPE_MODE (type)), 0);\n+\t  tem = convert (TREE_TYPE (arg1), tem);\n+\t  tem = const_binop (MINUS_EXPR, tem, arg1, 0);\n+\t  return fold (build (RROTATE_EXPR, type, arg0, tem));\n \t}\n \n       /* If we have a rotate of a bit operation with the rotate count and\n@@ -6853,20 +6880,8 @@ fold (tree expr)\n     case LE_EXPR:\n     case GE_EXPR:\n       /* If one arg is a real or integer constant, put it last.  */\n-      if ((TREE_CODE (arg0) == INTEGER_CST\n-\t   && TREE_CODE (arg1) != INTEGER_CST)\n-\t  || (TREE_CODE (arg0) == REAL_CST\n-\t      && TREE_CODE (arg0) != REAL_CST))\n-\t{\n-\t  if (t == orig_t)\n-\t    t = copy_node (t);\n-\t  TREE_OPERAND (t, 0) = arg1;\n-\t  TREE_OPERAND (t, 1) = arg0;\n-\t  arg0 = TREE_OPERAND (t, 0);\n-\t  arg1 = TREE_OPERAND (t, 1);\n-\t  code = swap_tree_comparison (code);\n-\t  TREE_SET_CODE (t, code);\n-\t}\n+      if (tree_swap_operands_p (arg0, arg1))\n+\treturn fold (build (swap_tree_comparison (code), type, arg1, arg0));\n \n       if (FLOAT_TYPE_P (TREE_TYPE (arg0)))\n \t{\n@@ -7123,16 +7138,12 @@ fold (tree expr)\n \t  switch (code)\n \t    {\n \t    case GE_EXPR:\n-\t      code = GT_EXPR;\n \t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t      t = build (code, type, TREE_OPERAND (t, 0), arg1);\n-\t      break;\n+\t      return fold (build (GT_EXPR, type, arg0, arg1));\n \n \t    case LT_EXPR:\n-\t      code = LE_EXPR;\n \t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t      t = build (code, type, TREE_OPERAND (t, 0), arg1);\n-\t      break;\n+\t      return fold (build (LE_EXPR, type, arg0, arg1));\n \n \t    default:\n \t      break;\n@@ -7175,24 +7186,17 @@ fold (tree expr)\n \t\t\t\t\t   convert (type, integer_zero_node),\n \t\t\t\t\t   arg0);\n \t\tcase GE_EXPR:\n-\t\t  code = EQ_EXPR;\n-\t\t  if (t == orig_t)\n-\t\t    t = copy_node (t);\n-\t\t  TREE_SET_CODE (t, EQ_EXPR);\n-\t\t  break;\n+\t\t  return fold (build (EQ_EXPR, type, arg0, arg1));\n+\n \t\tcase LE_EXPR:\n \t\t  return omit_one_operand (type,\n \t\t\t\t\t   convert (type, integer_one_node),\n \t\t\t\t\t   arg0);\n \t\tcase LT_EXPR:\n-\t\t  code = NE_EXPR;\n-\t\t  if (t == orig_t)\n-\t\t    t = copy_node (t);\n-\t\t  TREE_SET_CODE (t, NE_EXPR);\n-\t\t  break;\n+\t\t  return fold (build (NE_EXPR, type, arg0, arg1));\n \n \t\t/* The GE_EXPR and LT_EXPR cases above are not normally\n-\t\t   reached because of  previous transformations.  */\n+\t\t   reached because of previous transformations.  */\n \n \t\tdefault:\n \t\t  break;\n@@ -7202,15 +7206,11 @@ fold (tree expr)\n \t      switch (code)\n \t\t{\n \t\tcase GT_EXPR:\n-\t\t  code = EQ_EXPR;\n \t\t  arg1 = const_binop (PLUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  t = build (code, type, TREE_OPERAND (t, 0), arg1);\n-\t\t  break;\n+\t\t  return fold (build (EQ_EXPR, type, arg0, arg1));\n \t\tcase LE_EXPR:\n-\t\t  code = NE_EXPR;\n \t\t  arg1 = const_binop (PLUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  t = build (code, type, TREE_OPERAND (t, 0), arg1);\n-\t\t  break;\n+\t\t  return fold (build (NE_EXPR, type, arg0, arg1));\n \t\tdefault:\n \t\t  break;\n \t\t}\n@@ -7223,22 +7223,14 @@ fold (tree expr)\n \t\t\t\t\t   convert (type, integer_zero_node),\n \t\t\t\t\t   arg0);\n \t\tcase LE_EXPR:\n-\t\t  code = EQ_EXPR;\n-\t\t  if (t == orig_t)\n-\t\t    t = copy_node (t);\n-\t\t  TREE_SET_CODE (t, EQ_EXPR);\n-\t\t  break;\n+\t\t  return fold (build (EQ_EXPR, type, arg0, arg1));\n \n \t\tcase GE_EXPR:\n \t\t  return omit_one_operand (type,\n \t\t\t\t\t   convert (type, integer_one_node),\n \t\t\t\t\t   arg0);\n \t\tcase GT_EXPR:\n-\t\t  code = NE_EXPR;\n-\t\t  if (t == orig_t)\n-\t\t    t = copy_node (t);\n-\t\t  TREE_SET_CODE (t, NE_EXPR);\n-\t\t  break;\n+\t\t  return fold (build (NE_EXPR, type, arg0, arg1));\n \n \t\tdefault:\n \t\t  break;\n@@ -7248,15 +7240,11 @@ fold (tree expr)\n \t      switch (code)\n \t\t{\n \t\tcase GE_EXPR:\n-\t\t  code = NE_EXPR;\n \t\t  arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  t = build (code, type, TREE_OPERAND (t, 0), arg1);\n-\t\t  break;\n+\t\t  return fold (build (NE_EXPR, type, arg0, arg1));\n \t\tcase LT_EXPR:\n-\t\t  code = EQ_EXPR;\n \t\t  arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  t = build (code, type, TREE_OPERAND (t, 0), arg1);\n-\t\t  break;\n+\t\t  return fold (build (EQ_EXPR, type, arg0, arg1));\n \t\tdefault:\n \t\t  break;\n \t\t}\n@@ -7489,16 +7477,17 @@ fold (tree expr)\n \t  switch (code)\n \t    {\n \t    case EQ_EXPR:\n+\t      if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n+\t\t  || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n+\t\treturn constant_boolean_node (1, type);\n+\t      break;\n+\n \t    case GE_EXPR:\n \t    case LE_EXPR:\n \t      if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n \t\t  || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n \t\treturn constant_boolean_node (1, type);\n-\t      code = EQ_EXPR;\n-\t      if (t == orig_t)\n-\t\tt = copy_node (t);\n-\t      TREE_SET_CODE (t, code);\n-\t      break;\n+\t      return fold (build (EQ_EXPR, type, arg0, arg1));\n \n \t    case NE_EXPR:\n \t      /* For NE, we can only do this simplification if integer\n@@ -7779,34 +7768,6 @@ fold (tree expr)\n       else if (operand_equal_p (arg1, TREE_OPERAND (expr, 2), 0))\n \treturn pedantic_omit_one_operand (type, arg1, arg0);\n \n-      /* If the second operand is zero, invert the comparison and swap\n-\t the second and third operands.  Likewise if the second operand\n-\t is constant and the third is not or if the third operand is\n-\t equivalent to the first operand of the comparison.  */\n-\n-      if (integer_zerop (arg1)\n-\t  || (TREE_CONSTANT (arg1) && ! TREE_CONSTANT (TREE_OPERAND (t, 2)))\n-\t  || (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<'\n-\t      && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t\t\t TREE_OPERAND (t, 2),\n-\t\t\t\t\t\t TREE_OPERAND (arg0, 1))))\n-\t{\n-\t  /* See if this can be inverted.  If it can't, possibly because\n-\t     it was a floating-point inequality comparison, don't do\n-\t     anything.  */\n-\t  tem = invert_truthvalue (arg0);\n-\n-\t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n-\t    {\n-\t      t = build (code, type, tem,\n-\t\t\t TREE_OPERAND (t, 2), TREE_OPERAND (t, 1));\n-\t      arg0 = tem;\n-\t      /* arg1 should be the first argument of the new T.  */\n-\t      arg1 = TREE_OPERAND (t, 1);\n-\t      STRIP_NOPS (arg1);\n-\t    }\n-\t}\n-\n       /* If we have A op B ? A : C, we may be able to convert this to a\n \t simpler expression, depending on the operation and the values\n \t of B and C.  Signed zeros prevent all of these transformations,\n@@ -7982,9 +7943,8 @@ fold (tree expr)\n \t      case EQ_EXPR:\n \t\t/* We can replace A with C1 in this case.  */\n \t\targ1 = convert (type, TREE_OPERAND (arg0, 1));\n-\t\tt = build (code, type, TREE_OPERAND (t, 0), arg1,\n-\t\t\t   TREE_OPERAND (t, 2));\n-\t\tbreak;\n+\t\treturn fold (build (code, type, TREE_OPERAND (t, 0), arg1,\n+\t\t\t\t    TREE_OPERAND (t, 2)));\n \n \t      case LT_EXPR:\n \t\t/* If C1 is C2 + 1, this is min(A, C2).  */\n@@ -8034,26 +7994,16 @@ fold (tree expr)\n \n       /* If the second operand is simpler than the third, swap them\n \t since that produces better jump optimization results.  */\n-      if ((TREE_CONSTANT (arg1) || DECL_P (arg1)\n-\t   || TREE_CODE (arg1) == SAVE_EXPR)\n-\t  && ! (TREE_CONSTANT (TREE_OPERAND (t, 2))\n-\t\t|| DECL_P (TREE_OPERAND (t, 2))\n-\t\t|| TREE_CODE (TREE_OPERAND (t, 2)) == SAVE_EXPR))\n+      if (tree_swap_operands_p (TREE_OPERAND (t, 1), TREE_OPERAND (t, 2)))\n \t{\n \t  /* See if this can be inverted.  If it can't, possibly because\n \t     it was a floating-point inequality comparison, don't do\n \t     anything.  */\n \t  tem = invert_truthvalue (arg0);\n \n \t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n-\t    {\n-\t      t = build (code, type, tem,\n-\t\t\t TREE_OPERAND (t, 2), TREE_OPERAND (t, 1));\n-\t      arg0 = tem;\n-\t      /* arg1 should be the first argument of the new T.  */\n-\t      arg1 = TREE_OPERAND (t, 1);\n-\t      STRIP_NOPS (arg1);\n-\t    }\n+\t    return fold (build (code, type, tem,\n+\t\t\t TREE_OPERAND (t, 2), TREE_OPERAND (t, 1)));\n \t}\n \n       /* Convert A ? 1 : 0 to simply A.  */"}]}