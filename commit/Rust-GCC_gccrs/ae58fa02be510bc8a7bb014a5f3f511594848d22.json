{"sha": "ae58fa02be510bc8a7bb014a5f3f511594848d22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU1OGZhMDJiZTUxMGJjOGE3YmIwMTRhNWYzZjUxMTU5NDg0OGQyMg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-08-07T16:33:34Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-08-07T16:33:34Z"}, "message": "typeck.c (require_complete_type): Use complete_type_or_else.\n\n\t* typeck.c (require_complete_type): Use complete_type_or_else.\n\t(complete_type_or_else): Always return NULL_TREE on failure, as\n\tdocumented.\n\t* pt.c (tsubst_aggr_type): Prototype.\n\t(tsubst_decl): New function, split out from tsubst.  Set\n\tinput_filename and lineno as appropriate.\n\t(pop_tinst_level): Restore the file and line number saved in\n\tpush_tinst_level.\n\t(instantiate_class_template): Set input_filename and lineno as\n\tappropriate.\n\t(tsubst): Move _DECL processing to tsubst_decl.  Make sure the\n\tcontext for a TYPENAME_TYPE is complete.\n\t* decl2.c (grokbitfield): Issue errors on bitfields declared with\n\tfunction type.\n\t(do_dtors): As in do_ctors, pretend to be a member of the same\n\tclass as a static data member while generating a call to its\n\tdestructor.\n\nFrom-SVN: r21627", "tree": {"sha": "d092a56e00a569bdd8d9357a8f77fb52cca950e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d092a56e00a569bdd8d9357a8f77fb52cca950e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae58fa02be510bc8a7bb014a5f3f511594848d22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae58fa02be510bc8a7bb014a5f3f511594848d22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae58fa02be510bc8a7bb014a5f3f511594848d22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae58fa02be510bc8a7bb014a5f3f511594848d22/comments", "author": null, "committer": null, "parents": [{"sha": "523633872ac859b97c453f3c7356201f934e3478", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/523633872ac859b97c453f3c7356201f934e3478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/523633872ac859b97c453f3c7356201f934e3478"}], "stats": {"total": 678, "additions": 423, "deletions": 255}, "files": [{"sha": "4a1c42ab060cee068c743e058c57123b90db7891", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ae58fa02be510bc8a7bb014a5f3f511594848d22", "patch": "@@ -1,6 +1,26 @@\n 1998-08-07  Mark Mitchell  <mark@markmitchell.com>\n \n-\t* cvt.c (cp_convert_to_pointer): Handle a NULL pointer\n+\t* typeck.c (require_complete_type): Use complete_type_or_else.\n+\t(complete_type_or_else): Always return NULL_TREE on failure, as\n+\tdocumented.\n+\n+\t* pt.c (tsubst_aggr_type): Prototype.\n+\t(tsubst_decl): New function, split out from tsubst.  Set\n+\tinput_filename and lineno as appropriate.\n+\t(pop_tinst_level): Restore the file and line number saved in\n+\tpush_tinst_level.\n+\t(instantiate_class_template): Set input_filename and lineno as\n+\tappropriate.\n+\t(tsubst): Move _DECL processing to tsubst_decl.  Make sure the\n+\tcontext for a TYPENAME_TYPE is complete.\n+\n+\t* decl2.c (grokbitfield): Issue errors on bitfields declared with\n+\tfunction type.\n+\t(do_dtors): As in do_ctors, pretend to be a member of the same\n+\tclass as a static data member while generating a call to its\n+\tdestructor.\n+\n+\t* cvt.c (cp_convert_to_pointer): Handle NULL pointer\n \tconversions, even in complex virtual base class hierarchies.\n \n 1998-08-06  Mark Mitchell  <mark@markmitchell.com>"}, {"sha": "d8bc74f4779cb22eee7223901d135783d3c5b891", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ae58fa02be510bc8a7bb014a5f3f511594848d22", "patch": "@@ -1845,6 +1845,17 @@ grokbitfield (declarator, declspecs, width)\n       return NULL_TREE;\n     }\n \n+  /* Usually, finish_struct_1 catches bitifields with invalid types.\n+     But, in the case of bitfields with function type, we confuse\n+     ourselves into thinking they are member functions, so we must\n+     check here.  */\n+  if (TREE_CODE (value) == FUNCTION_DECL)\n+    {\n+      cp_error (\"cannot declare bitfield `%D' with funcion type\",\n+\t\tDECL_NAME (value));\n+      return NULL_TREE;\n+    }\n+\n   if (IS_SIGNATURE (current_class_type))\n     {\n       error (\"field declaration not allowed in signature\");\n@@ -3001,6 +3012,25 @@ do_dtors ()\n \t  if (! current_function_decl)\n \t    start_objects ('D');\n \n+\t  /* Because of:\n+\n+\t       [class.access.spec]\n+\n+\t       Access control for implicit calls to the constructors,\n+\t       the conversion functions, or the destructor called to\n+\t       create and destroy a static data member is per- formed as\n+\t       if these calls appeared in the scope of the member's\n+\t       class.  \n+\n+\t     we must convince enforce_access to let us access the\n+\t     DECL.  */\n+\t  if (member_p (decl))\n+\t    {\n+\t      DECL_CLASS_CONTEXT (current_function_decl)\n+\t\t= DECL_CONTEXT (decl);\n+\t      DECL_STATIC_FUNCTION_P (current_function_decl) = 1;\n+\t    }\n+\n \t  temp = build_cleanup (decl);\n \n \t  if (protect)\n@@ -3015,6 +3045,11 @@ do_dtors ()\n \n \t  if (protect)\n \t    expand_end_cond ();\n+\t  \n+\t  /* Now that we're done with DECL we don't need to pretend to\n+\t     be a member of its class any longer.  */\n+\t  DECL_CLASS_CONTEXT (current_function_decl) = NULL_TREE;\n+\t  DECL_STATIC_FUNCTION_P (current_function_decl) = 0;\n \t}\n     }\n "}, {"sha": "f664caa9bc60fbbaec26c2de05ce466849da2219", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 306, "deletions": 235, "changes": 541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ae58fa02be510bc8a7bb014a5f3f511594848d22", "patch": "@@ -122,6 +122,8 @@ static tree most_specialized_class PROTO((tree, tree));\n static tree most_general_template PROTO((tree));\n static void set_mangled_name_for_template_decl PROTO((tree));\n static int template_class_depth_real PROTO((tree, int));\n+static tree tsubst_aggr_type PROTO((tree, tree, tree, int));\n+static tree tsubst_decl PROTO((tree, tree, tree, tree));\n \n /* We use TREE_VECs to hold template arguments.  If there is only one\n    level of template arguments, then the TREE_VEC contains the\n@@ -3779,6 +3781,11 @@ pop_tinst_level ()\n {\n   struct tinst_level *old = current_tinst_level;\n \n+  /* Restore the filename and line number stashed away when we started\n+     this instantiation.  */\n+  lineno = old->line;\n+  input_filename = old->file;\n+  \n   current_tinst_level = old->next;\n   old->next = free_tinst_level;\n   free_tinst_level = old;\n@@ -4291,7 +4298,15 @@ instantiate_class_template (type)\n   for (t = TYPE_FIELDS (pattern); t; t = TREE_CHAIN (t))\n     if (TREE_CODE (t) != CONST_DECL)\n       {\n-\ttree r = tsubst (t, args, NULL_TREE);\n+\ttree r;\n+\n+\t/* The the file and line for this declaration, to assist in\n+\t   error message reporting.  Since we called push_tinst_level\n+\t   above, we don't need to restore these.  */\n+\tlineno = DECL_SOURCE_LINE (t);\n+\tinput_filename = DECL_SOURCE_FILE (t);\n+\n+\tr = tsubst (t, args, NULL_TREE);\n \tif (TREE_CODE (r) == VAR_DECL)\n \t  {\n \t    pending_statics = perm_tree_cons (NULL_TREE, r, pending_statics);\n@@ -4619,204 +4634,34 @@ tsubst_aggr_type (t, args, in_decl, entering_scope)\n     }\n }\n \n-/* Take the tree structure T and replace template parameters used therein\n-   with the argument vector ARGS.  IN_DECL is an associated decl for\n-   diagnostics.\n-\n-   tsubst is used for dealing with types, decls and the like; for\n-   expressions, use tsubst_expr or tsubst_copy.  */\n+/* Substitute the ARGS into the T, which is a _DECL.  TYPE is the\n+   (already computed) substitution of ARGS into TREE_TYPE (T), if\n+   appropriate.  Return the result of the substitution.  IN_DECL is as\n+   for tsubst.  */\n \n tree\n-tsubst (t, args, in_decl)\n-     tree t, args;\n+tsubst_decl (t, args, type, in_decl)\n+     tree t;\n+     tree args;\n+     tree type;\n      tree in_decl;\n {\n-  tree type;\n-\n-  if (t == NULL_TREE || t == error_mark_node\n-      || t == integer_type_node\n-      || t == void_type_node\n-      || t == char_type_node\n-      || TREE_CODE (t) == NAMESPACE_DECL)\n-    return t;\n-\n-  if (TREE_CODE (t) == IDENTIFIER_NODE)\n-    type = IDENTIFIER_TYPE_VALUE (t);\n-  else\n-    type = TREE_TYPE (t);\n-  if (type == unknown_type_node)\n-    my_friendly_abort (42);\n+  int saved_lineno;\n+  char* saved_filename;\n+  tree r;\n \n-  if (type && TREE_CODE (t) != FUNCTION_DECL\n-      && TREE_CODE (t) != TYPENAME_TYPE\n-      && TREE_CODE (t) != TEMPLATE_DECL\n-      && TREE_CODE (t) != IDENTIFIER_NODE)\n-    type = tsubst (type, args, in_decl);\n+  /* Set the filename and linenumber to improve error-reporting.  */\n+  saved_lineno = lineno;\n+  saved_filename = input_filename;\n+  lineno = DECL_SOURCE_LINE (t);\n+  input_filename = DECL_SOURCE_FILE (t);\n \n   switch (TREE_CODE (t))\n     {\n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-    case ENUMERAL_TYPE:\n-      return tsubst_aggr_type (t, args, in_decl, /*entering_scope=*/0);\n-\n-    case ERROR_MARK:\n-    case IDENTIFIER_NODE:\n-    case OP_IDENTIFIER:\n-    case VOID_TYPE:\n-    case REAL_TYPE:\n-    case COMPLEX_TYPE:\n-    case BOOLEAN_TYPE:\n-    case INTEGER_CST:\n-    case REAL_CST:\n-    case STRING_CST:\n-    case NAMESPACE_DECL:\n-      return t;\n-\n-    case INTEGER_TYPE:\n-      if (t == integer_type_node)\n-\treturn t;\n-\n-      if (TREE_CODE (TYPE_MIN_VALUE (t)) == INTEGER_CST\n-\t  && TREE_CODE (TYPE_MAX_VALUE (t)) == INTEGER_CST)\n-\treturn t;\n-\n-      {\n-\ttree max = TREE_OPERAND (TYPE_MAX_VALUE (t), 0);\n-\tmax = tsubst_expr (max, args, in_decl);\n-\tif (processing_template_decl)\n-\t  {\n-\t    tree itype = make_node (INTEGER_TYPE);\n-\t    TYPE_MIN_VALUE (itype) = size_zero_node;\n-\t    TYPE_MAX_VALUE (itype) = build_min (MINUS_EXPR, sizetype, max,\n-\t\t\t\t\t\tinteger_one_node);\n-\t    return itype;\n-\t  }\n-\n-\tmax = fold (build_binary_op (MINUS_EXPR, max, integer_one_node, 1));\n-\treturn build_index_2_type (size_zero_node, max);\n-      }\n-\n-    case TEMPLATE_TYPE_PARM:\n-    case TEMPLATE_TEMPLATE_PARM:\n-    case TEMPLATE_PARM_INDEX:\n-      {\n-\tint idx;\n-\tint level;\n-\tint levels;\n-\ttree r = NULL_TREE;\n-\n-\tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n-\t    || TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n-\t  {\n-\t    idx = TEMPLATE_TYPE_IDX (t);\n-\t    level = TEMPLATE_TYPE_LEVEL (t);\n-\t  }\n-\telse\n-\t  {\n-\t    idx = TEMPLATE_PARM_IDX (t);\n-\t    level = TEMPLATE_PARM_LEVEL (t);\n-\t  }\n-\n-\tif (TREE_VEC_LENGTH (args) > 0)\n-\t  {\n-\t    tree arg = NULL_TREE;\n-\n-\t    levels = TMPL_ARGS_DEPTH (args);\n-\t    if (level <= levels)\n-\t      arg = TMPL_ARG (args, level, idx);\n-\n-\t    if (arg != NULL_TREE)\n-\t      {\n-\t\tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n-\t\t  {\n-\t\t    my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (arg))\n-\t\t\t\t\t== 't', 0);\n-\t\t    return cp_build_type_variant\n-\t\t      (arg, TYPE_READONLY (arg) || TYPE_READONLY (t),\n-\t\t       TYPE_VOLATILE (arg) || TYPE_VOLATILE (t));\n-\t\t  }\n-\t\telse if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n-\t\t  {\n-\t\t    if (CLASSTYPE_TEMPLATE_INFO (t))\n-\t\t      {\n-\t\t\t/* We are processing a type constructed from\n-\t\t\t   a template template parameter */\n-\t\t\ttree argvec = tsubst (CLASSTYPE_TI_ARGS (t),\n-\t\t\t\t\t      args, in_decl);\n-\t\t\ttree r;\n-\n-\t\t\t/* We can get a TEMPLATE_TEMPLATE_PARM here when \n-\t\t\t   we are resolving nested-types in the signature of \n-\t\t\t   a member function templates.\n-\t\t\t   Otherwise ARG is a TEMPLATE_DECL and is the real \n-\t\t\t   template to be instantiated.  */\n-\t\t\tif (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n-\t\t\t  arg = TYPE_NAME (arg);\n-\n-\t\t\tr = lookup_template_class (DECL_NAME (arg), \n-\t\t\t\t\t\t   argvec, in_decl, \n-\t\t\t\t\t\t   DECL_CONTEXT (arg),\n-\t\t\t\t\t\t   /*entering_scope=*/0);\n-\t\t\treturn cp_build_type_variant (r, TYPE_READONLY (t),\n-\t\t\t\t\t\t      TYPE_VOLATILE (t));\n-\t\t      }\n-\t\t    else\n-\t\t      /* We are processing a template argument list.  */ \n-\t\t      return arg;\n-\t\t  }\n-\t\telse\n-\t\t  return arg;\n-\t      }\n-\t  }\n-\n-\tif (level == 1)\n-\t  /* This can happen during the attempted tsubst'ing in\n-\t     unify.  This means that we don't yet have any information\n-\t     about the template parameter in question.  */\n-\t  return t;\n-\n-\t/* If we get here, we must have been looking at a parm for a\n-\t   more deeply nested template.  Make a new version of this\n-\t   template parameter, but with a lower level.  */\n-\tswitch (TREE_CODE (t))\n-\t  {\n-\t  case TEMPLATE_TYPE_PARM:\n-\t  case TEMPLATE_TEMPLATE_PARM:\n-\t    r = copy_node (t);\n-\t    TEMPLATE_TYPE_PARM_INDEX (r)\n-\t      = reduce_template_parm_level (TEMPLATE_TYPE_PARM_INDEX (t),\n-\t\t\t\t\t    r, levels);\n-\t    TYPE_STUB_DECL (r) = TYPE_NAME (r) = TEMPLATE_TYPE_DECL (r);\n-\t    TYPE_MAIN_VARIANT (r) = r;\n-\t    TYPE_POINTER_TO (r) = NULL_TREE;\n-\t    TYPE_REFERENCE_TO (r) = NULL_TREE;\n-\n-\t    if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM\n-\t\t&& CLASSTYPE_TEMPLATE_INFO (t))\n-\t      {\n-\t\ttree argvec = tsubst (CLASSTYPE_TI_ARGS (t), args, in_decl);\n-\t\tCLASSTYPE_TEMPLATE_INFO (r)\n-\t\t  = perm_tree_cons (TYPE_NAME (t), argvec, NULL_TREE);\n-\t      }\n-\t    break;\n-\n-\t  case TEMPLATE_PARM_INDEX:\n-\t    r = reduce_template_parm_level (t, type, levels);\n-\t    break;\n-\t   \n-\t  default:\n-\t    my_friendly_abort (0);\n-\t  }\n-\n-\treturn r;\n-      }\n-\n     case TEMPLATE_DECL:\n       {\n \t/* We can get here when processing a member template function\n \t   of a template class.  */\n-\ttree tmpl;\n \ttree decl = DECL_TEMPLATE_RESULT (t);\n \ttree parms;\n \ttree* new_parms;\n@@ -4841,68 +4686,71 @@ tsubst (t, args, in_decl)\n \n \t    spec = retrieve_specialization (t, full_args);\n \t    if (spec != NULL_TREE)\n-\t      return spec;\n+\t      {\n+\t\tr = spec;\n+\t\tbreak;\n+\t      }\n \t  }\n \n \t/* Make a new template decl.  It will be similar to the\n \t   original, but will record the current template arguments. \n \t   We also create a new function declaration, which is just\n \t   like the old one, but points to this new template, rather\n \t   than the old one.  */\n-\ttmpl = copy_node (t);\n-\tcopy_lang_decl (tmpl);\n-\tmy_friendly_assert (DECL_LANG_SPECIFIC (tmpl) != 0, 0);\n-\tTREE_CHAIN (tmpl) = NULL_TREE;\n+\tr = copy_node (t);\n+\tcopy_lang_decl (r);\n+\tmy_friendly_assert (DECL_LANG_SPECIFIC (r) != 0, 0);\n+\tTREE_CHAIN (r) = NULL_TREE;\n \n \tif (is_template_template_parm)\n \t  {\n \t    tree new_decl = tsubst (decl, args, in_decl);\n-\t    DECL_RESULT (tmpl) = new_decl;\n-\t    TREE_TYPE (tmpl) = TREE_TYPE (new_decl);\n-\t    return tmpl;\n+\t    DECL_RESULT (r) = new_decl;\n+\t    TREE_TYPE (r) = TREE_TYPE (new_decl);\n+\t    break;\n \t  }\n \n-\tDECL_CONTEXT (tmpl) \n+\tDECL_CONTEXT (r) \n \t  = tsubst_aggr_type (DECL_CONTEXT (t), args, in_decl,\n \t\t\t      /*entering_scope=*/1);\n-\tDECL_CLASS_CONTEXT (tmpl) \n+\tDECL_CLASS_CONTEXT (r) \n \t  = tsubst_aggr_type (DECL_CLASS_CONTEXT (t), args, in_decl,\n \t\t\t      /*entering_scope=*/1);\n-\tDECL_TEMPLATE_INFO (tmpl) = build_tree_list (t, args);\n+\tDECL_TEMPLATE_INFO (r) = build_tree_list (t, args);\n \n \tif (TREE_CODE (decl) == TYPE_DECL)\n \t  {\n \t    tree new_type = tsubst (TREE_TYPE (t), args, in_decl);\n-\t    TREE_TYPE (tmpl) = new_type;\n-\t    CLASSTYPE_TI_TEMPLATE (new_type) = tmpl;\n-\t    DECL_RESULT (tmpl) = TYPE_MAIN_DECL (new_type);\n-\t    DECL_TI_ARGS (tmpl) = CLASSTYPE_TI_ARGS (new_type);\n+\t    TREE_TYPE (r) = new_type;\n+\t    CLASSTYPE_TI_TEMPLATE (new_type) = r;\n+\t    DECL_RESULT (r) = TYPE_MAIN_DECL (new_type);\n+\t    DECL_TI_ARGS (r) = CLASSTYPE_TI_ARGS (new_type);\n \t  }\n \telse\n \t  {\n \t    tree new_decl = tsubst (decl, args, in_decl);\n-\t    DECL_RESULT (tmpl) = new_decl;\n-\t    DECL_TI_TEMPLATE (new_decl) = tmpl;\n-\t    TREE_TYPE (tmpl) = TREE_TYPE (new_decl);\n-\t    DECL_TI_ARGS (tmpl) = DECL_TI_ARGS (new_decl);\n+\t    DECL_RESULT (r) = new_decl;\n+\t    DECL_TI_TEMPLATE (new_decl) = r;\n+\t    TREE_TYPE (r) = TREE_TYPE (new_decl);\n+\t    DECL_TI_ARGS (r) = DECL_TI_ARGS (new_decl);\n \t  }\n \n-\tSET_DECL_IMPLICIT_INSTANTIATION (tmpl);\n-\tDECL_TEMPLATE_INSTANTIATIONS (tmpl) = NULL_TREE;\n-\tDECL_TEMPLATE_SPECIALIZATIONS (tmpl) = NULL_TREE;\n+\tSET_DECL_IMPLICIT_INSTANTIATION (r);\n+\tDECL_TEMPLATE_INSTANTIATIONS (r) = NULL_TREE;\n+\tDECL_TEMPLATE_SPECIALIZATIONS (r) = NULL_TREE;\n \n \t/* The template parameters for this new template are all the\n \t   template parameters for the old template, except the\n \t   outermost level of parameters. */\n-\tDECL_TEMPLATE_PARMS (tmpl) \n+\tDECL_TEMPLATE_PARMS (r) \n \t  = tsubst_template_parms (DECL_TEMPLATE_PARMS (t), args);\n \n \tif (PRIMARY_TEMPLATE_P (t))\n-\t  DECL_PRIMARY_TEMPLATE (tmpl) = tmpl;\n+\t  DECL_PRIMARY_TEMPLATE (r) = r;\n \n \t/* We don't partially instantiate partial specializations.  */\n \tif (TREE_CODE (decl) == TYPE_DECL)\n-\t  return tmpl;\n+\t  break;\n \n \tfor (spec = DECL_TEMPLATE_SPECIALIZATIONS (t);\n \t     spec != NULL_TREE;\n@@ -4953,20 +4801,19 @@ tsubst (t, args, in_decl)\n \t    new_fn = tsubst (DECL_RESULT (most_general_template (fn)), \n \t\t\t     spec_args, in_decl); \n \t    DECL_TI_TEMPLATE (new_fn) = fn;\n-\t    register_specialization (new_fn, tmpl, \n+\t    register_specialization (new_fn, r, \n \t\t\t\t     innermost_args (spec_args));\n \t  }\n \n \t/* Record this partial instantiation.  */\n-\tregister_specialization (tmpl, t, \n-\t\t\t\t DECL_TI_ARGS (DECL_RESULT (tmpl)));\n+\tregister_specialization (r, t, \n+\t\t\t\t DECL_TI_ARGS (DECL_RESULT (r)));\n \n-\treturn tmpl;\n       }\n+      break;\n \n     case FUNCTION_DECL:\n       {\n-\ttree r = NULL_TREE;\n \ttree ctx;\n \ttree argvec;\n \ttree gen_tmpl;\n@@ -4988,7 +4835,10 @@ tsubst (t, args, in_decl)\n \t    /* Check to see if we already have this specialization.  */\n \t    spec = retrieve_specialization (gen_tmpl, argvec);\n \t    if (spec)\n-\t      return spec;\n+\t      {\n+\t\tr = spec;\n+\t\tbreak;\n+\t      }\n \t  }\n \telse\n \t  {\n@@ -5113,13 +4963,12 @@ tsubst (t, args, in_decl)\n \t\t    == NULL_TREE))\n \t      SET_IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (r), r);\n \t  }\n-\n-\treturn r;\n       }\n+      break;\n \n     case PARM_DECL:\n       {\n-\ttree r = copy_node (t);\n+\tr = copy_node (t);\n \tTREE_TYPE (r) = type;\n \tif (TREE_CODE (DECL_INITIAL (r)) != TEMPLATE_PARM_INDEX)\n \t  DECL_INITIAL (r) = TREE_TYPE (r);\n@@ -5135,12 +4984,12 @@ tsubst (t, args, in_decl)\n #endif\n \tif (TREE_CHAIN (t))\n \t  TREE_CHAIN (r) = tsubst (TREE_CHAIN (t), args, TREE_CHAIN (t));\n-\treturn r;\n       }\n+      break;\n \n     case FIELD_DECL:\n       {\n-\ttree r = copy_node (t);\n+\tr = copy_node (t);\n \tTREE_TYPE (r) = type;\n \tcopy_lang_decl (r);\n #if 0\n@@ -5150,21 +4999,20 @@ tsubst (t, args, in_decl)\n \tTREE_CHAIN (r) = NULL_TREE;\n \tif (TREE_CODE (type) == VOID_TYPE)\n \t  cp_error_at (\"instantiation of `%D' as type void\", r);\n-\treturn r;\n       }\n+      break;\n \n     case USING_DECL:\n       {\n-\ttree r = copy_node (t);\n+\tr = copy_node (t);\n \tDECL_INITIAL (r)\n \t  = tsubst_copy (DECL_INITIAL (t), args, in_decl);\n \tTREE_CHAIN (r) = NULL_TREE;\n-\treturn r;\n       }\n+      break;\n \n     case VAR_DECL:\n       {\n-\ttree r;\n \ttree argvec;\n \ttree gen_tmpl;\n \ttree spec;\n@@ -5183,7 +5031,10 @@ tsubst (t, args, in_decl)\n \tspec = retrieve_specialization (gen_tmpl, argvec);\n \t\n \tif (spec)\n-\t  return spec;\n+\t  {\n+\t    r = spec;\n+\t    break;\n+\t  }\n \n \tr = copy_node (t);\n \tTREE_TYPE (r) = type;\n@@ -5207,20 +5058,227 @@ tsubst (t, args, in_decl)\n \tTREE_CHAIN (r) = NULL_TREE;\n \tif (TREE_CODE (type) == VOID_TYPE)\n \t  cp_error_at (\"instantiation of `%D' as type void\", r);\n-\treturn r;\n       }\n+      break;\n \n     case TYPE_DECL:\n       if (t == TYPE_NAME (TREE_TYPE (t)))\n-\treturn TYPE_NAME (type);\n+\tr = TYPE_NAME (type);\n+      else\n+\t{\n+\t  r = copy_node (t);\n+\t  TREE_TYPE (r) = type;\n+\t  DECL_CONTEXT (r) = current_class_type;\n+\t  TREE_CHAIN (r) = NULL_TREE;\n+\t}\n+      break;\n+\n+    default:\n+      my_friendly_abort (0);\n+    } \n+\n+  /* Restore the file and line information.  */\n+  lineno = saved_lineno;\n+  input_filename = saved_filename;\n+\n+  return r;\n+}\n+\n+\n+/* Take the tree structure T and replace template parameters used therein\n+   with the argument vector ARGS.  IN_DECL is an associated decl for\n+   diagnostics.\n+\n+   tsubst is used for dealing with types, decls and the like; for\n+   expressions, use tsubst_expr or tsubst_copy.  */\n+\n+tree\n+tsubst (t, args, in_decl)\n+     tree t, args;\n+     tree in_decl;\n+{\n+  tree type;\n+\n+  if (t == NULL_TREE || t == error_mark_node\n+      || t == integer_type_node\n+      || t == void_type_node\n+      || t == char_type_node\n+      || TREE_CODE (t) == NAMESPACE_DECL)\n+    return t;\n+\n+  if (TREE_CODE (t) == IDENTIFIER_NODE)\n+    type = IDENTIFIER_TYPE_VALUE (t);\n+  else\n+    type = TREE_TYPE (t);\n+  if (type == unknown_type_node)\n+    my_friendly_abort (42);\n+\n+  if (type && TREE_CODE (t) != FUNCTION_DECL\n+      && TREE_CODE (t) != TYPENAME_TYPE\n+      && TREE_CODE (t) != TEMPLATE_DECL\n+      && TREE_CODE (t) != IDENTIFIER_NODE)\n+    type = tsubst (type, args, in_decl);\n+\n+  if (TREE_CODE_CLASS (TREE_CODE (t)) == 'd')\n+    return tsubst_decl (t, args, type, in_decl);\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+      return tsubst_aggr_type (t, args, in_decl, /*entering_scope=*/0);\n+\n+    case ERROR_MARK:\n+    case IDENTIFIER_NODE:\n+    case OP_IDENTIFIER:\n+    case VOID_TYPE:\n+    case REAL_TYPE:\n+    case COMPLEX_TYPE:\n+    case BOOLEAN_TYPE:\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case STRING_CST:\n+      return t;\n+\n+    case INTEGER_TYPE:\n+      if (t == integer_type_node)\n+\treturn t;\n+\n+      if (TREE_CODE (TYPE_MIN_VALUE (t)) == INTEGER_CST\n+\t  && TREE_CODE (TYPE_MAX_VALUE (t)) == INTEGER_CST)\n+\treturn t;\n \n       {\n-\ttree r = copy_node (t);\n-\tTREE_TYPE (r) = type;\n-\tDECL_CONTEXT (r) = current_class_type;\n-\tTREE_CHAIN (r) = NULL_TREE;\n+\ttree max = TREE_OPERAND (TYPE_MAX_VALUE (t), 0);\n+\tmax = tsubst_expr (max, args, in_decl);\n+\tif (processing_template_decl)\n+\t  {\n+\t    tree itype = make_node (INTEGER_TYPE);\n+\t    TYPE_MIN_VALUE (itype) = size_zero_node;\n+\t    TYPE_MAX_VALUE (itype) = build_min (MINUS_EXPR, sizetype, max,\n+\t\t\t\t\t\tinteger_one_node);\n+\t    return itype;\n+\t  }\n+\n+\tmax = fold (build_binary_op (MINUS_EXPR, max, integer_one_node, 1));\n+\treturn build_index_2_type (size_zero_node, max);\n+      }\n+\n+    case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_TEMPLATE_PARM:\n+    case TEMPLATE_PARM_INDEX:\n+      {\n+\tint idx;\n+\tint level;\n+\tint levels;\n+\ttree r = NULL_TREE;\n+\n+\tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n+\t    || TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n+\t  {\n+\t    idx = TEMPLATE_TYPE_IDX (t);\n+\t    level = TEMPLATE_TYPE_LEVEL (t);\n+\t  }\n+\telse\n+\t  {\n+\t    idx = TEMPLATE_PARM_IDX (t);\n+\t    level = TEMPLATE_PARM_LEVEL (t);\n+\t  }\n+\n+\tif (TREE_VEC_LENGTH (args) > 0)\n+\t  {\n+\t    tree arg = NULL_TREE;\n+\n+\t    levels = TMPL_ARGS_DEPTH (args);\n+\t    if (level <= levels)\n+\t      arg = TMPL_ARG (args, level, idx);\n+\n+\t    if (arg != NULL_TREE)\n+\t      {\n+\t\tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n+\t\t  {\n+\t\t    my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (arg))\n+\t\t\t\t\t== 't', 0);\n+\t\t    return cp_build_type_variant\n+\t\t      (arg, TYPE_READONLY (arg) || TYPE_READONLY (t),\n+\t\t       TYPE_VOLATILE (arg) || TYPE_VOLATILE (t));\n+\t\t  }\n+\t\telse if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n+\t\t  {\n+\t\t    if (CLASSTYPE_TEMPLATE_INFO (t))\n+\t\t      {\n+\t\t\t/* We are processing a type constructed from\n+\t\t\t   a template template parameter */\n+\t\t\ttree argvec = tsubst (CLASSTYPE_TI_ARGS (t),\n+\t\t\t\t\t      args, in_decl);\n+\t\t\ttree r;\n+\n+\t\t\t/* We can get a TEMPLATE_TEMPLATE_PARM here when \n+\t\t\t   we are resolving nested-types in the signature of \n+\t\t\t   a member function templates.\n+\t\t\t   Otherwise ARG is a TEMPLATE_DECL and is the real \n+\t\t\t   template to be instantiated.  */\n+\t\t\tif (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n+\t\t\t  arg = TYPE_NAME (arg);\n+\n+\t\t\tr = lookup_template_class (DECL_NAME (arg), \n+\t\t\t\t\t\t   argvec, in_decl, \n+\t\t\t\t\t\t   DECL_CONTEXT (arg),\n+\t\t\t\t\t\t   /*entering_scope=*/0);\n+\t\t\treturn cp_build_type_variant (r, TYPE_READONLY (t),\n+\t\t\t\t\t\t      TYPE_VOLATILE (t));\n+\t\t      }\n+\t\t    else\n+\t\t      /* We are processing a template argument list.  */ \n+\t\t      return arg;\n+\t\t  }\n+\t\telse\n+\t\t  return arg;\n+\t      }\n+\t  }\n+\n+\tif (level == 1)\n+\t  /* This can happen during the attempted tsubst'ing in\n+\t     unify.  This means that we don't yet have any information\n+\t     about the template parameter in question.  */\n+\t  return t;\n+\n+\t/* If we get here, we must have been looking at a parm for a\n+\t   more deeply nested template.  Make a new version of this\n+\t   template parameter, but with a lower level.  */\n+\tswitch (TREE_CODE (t))\n+\t  {\n+\t  case TEMPLATE_TYPE_PARM:\n+\t  case TEMPLATE_TEMPLATE_PARM:\n+\t    r = copy_node (t);\n+\t    TEMPLATE_TYPE_PARM_INDEX (r)\n+\t      = reduce_template_parm_level (TEMPLATE_TYPE_PARM_INDEX (t),\n+\t\t\t\t\t    r, levels);\n+\t    TYPE_STUB_DECL (r) = TYPE_NAME (r) = TEMPLATE_TYPE_DECL (r);\n+\t    TYPE_MAIN_VARIANT (r) = r;\n+\t    TYPE_POINTER_TO (r) = NULL_TREE;\n+\t    TYPE_REFERENCE_TO (r) = NULL_TREE;\n+\n+\t    if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM\n+\t\t&& CLASSTYPE_TEMPLATE_INFO (t))\n+\t      {\n+\t\ttree argvec = tsubst (CLASSTYPE_TI_ARGS (t), args, in_decl);\n+\t\tCLASSTYPE_TEMPLATE_INFO (r)\n+\t\t  = perm_tree_cons (TYPE_NAME (t), argvec, NULL_TREE);\n+\t      }\n+\t    break;\n+\n+\t  case TEMPLATE_PARM_INDEX:\n+\t    r = reduce_template_parm_level (t, type, levels);\n+\t    break;\n+\t   \n+\t  default:\n+\t    my_friendly_abort (0);\n+\t  }\n+\n \treturn r;\n-      }\t  \n+      }\n \n     case TREE_LIST:\n       {\n@@ -5439,6 +5497,19 @@ tsubst (t, args, in_decl)\n \ttree ctx = tsubst_aggr_type (TYPE_CONTEXT (t), args, in_decl,\n \t\t\t\t     /*entering_scope=*/1);\n \ttree f = tsubst_copy (TYPENAME_TYPE_FULLNAME (t), args, in_decl);\n+\n+\t/* Normally, make_typename_type does not require that the CTX\n+\t   have complete type in order to allow things like:\n+\t     \n+             template <class T> struct S { typename S<T>::X Y; };\n+\n+\t   But, such constructs have already been resolved by this\n+\t   point, so here CTX really should have complete type, unless\n+\t   it's a partial instantiation.  */\n+\tif (!uses_template_parms (ctx) \n+\t    && !complete_type_or_else (ctx))\n+\t  return error_mark_node;\n+\n \tf = make_typename_type (ctx, f);\n \treturn cp_build_type_variant\n \t  (f, TYPE_READONLY (f) || TYPE_READONLY (t),"}, {"sha": "008a3157a522b323938c0084f5cd695fc03fe053", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ae58fa02be510bc8a7bb014a5f3f511594848d22", "patch": "@@ -80,7 +80,9 @@ target_type (type)\n }\n \n /* Do `exp = require_complete_type (exp);' to make sure exp\n-   does not have an incomplete type.  (That includes void types.)  */\n+   does not have an incomplete type.  (That includes void types.)\n+   Returns the error_mark_node if the VALUE does not have\n+   complete type when this function returns.  */\n \n tree\n require_complete_type (value)\n@@ -120,13 +122,10 @@ require_complete_type (value)\n       return require_complete_type (value);\n     }\n \n-  if (TYPE_SIZE (complete_type (type)))\n+  if (complete_type_or_else (type))\n     return value;\n   else\n-    {\n-      incomplete_type_error (value, type);\n-      return error_mark_node;\n-    }\n+    return error_mark_node;\n }\n \n /* Try to complete TYPE, if it is incomplete.  For example, if TYPE is\n@@ -170,7 +169,10 @@ complete_type_or_else (type)\n      tree type;\n {\n   type = complete_type (type);\n-  if (type != error_mark_node && !TYPE_SIZE (type))\n+  if (type == error_mark_node)\n+    /* We already issued an error.  */\n+    return NULL_TREE;\n+  else if (!TYPE_SIZE (type))\n     {\n       incomplete_type_error (NULL_TREE, type);\n       return NULL_TREE;"}, {"sha": "946e6d1e0d31b540903588bf0ed34c84325e49c5", "filename": "gcc/testsuite/g++.old-deja/g++.bugs/900402_01.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900402_01.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900402_01.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900402_01.C?ref=ae58fa02be510bc8a7bb014a5f3f511594848d22", "patch": "@@ -9,7 +9,7 @@\n typedef void (func_type) ();\n \n struct s {\n-  func_type f:32;\t// ERROR - XFAIL *-*-*\n+  func_type f:32;\t// ERROR - bitified with function type\n };\n \n int main () { return 0; }"}, {"sha": "8bd6a851b71bfd2a6eb819f5a8aba231d6050160", "filename": "gcc/testsuite/g++.old-deja/g++.law/visibility13.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility13.C?ref=ae58fa02be510bc8a7bb014a5f3f511594848d22", "patch": "@@ -14,7 +14,7 @@\n const int ArraySize = 12;\n \n template <class Type>\n-class Array {\n+class Array { // ERROR - .struct Array_RC redecl.*\n friend class Array_RC;\n public:\n     Array(const Type *ar, int sz) { init(ar,sz); }\n@@ -97,7 +97,7 @@ try_array( Array_RC<Type> &rc )\n main()\n {\n     static int ia[10] = { 12, 7, 14, 9, 128, 17, 6, 3, 27, 5 };\n-    Array_RC<int> iA(ia, 10);// ERROR - .struct Array_RC redecl.*\n+    Array_RC<int> iA(ia, 10);// ERROR - instantiated from here\n \n     cout << \"template Array_RC class\" << endl;\n     try_array(iA);"}, {"sha": "201068c415bc38396c6ce2d1b3677659eca5854f", "filename": "gcc/testsuite/g++.old-deja/g++.other/dtor2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor2.C?ref=ae58fa02be510bc8a7bb014a5f3f511594848d22", "patch": "@@ -0,0 +1,13 @@\n+// Build don't link:\n+\n+class K {\n+public:\n+  friend class C;\n+\n+private:\n+  static K qwe;\n+  K();\n+  ~K();\n+}; \n+\n+K K::qwe;"}, {"sha": "21065f1cac109dca677a01f253cb578aa24496d0", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend23.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend23.C?ref=ae58fa02be510bc8a7bb014a5f3f511594848d22", "patch": "@@ -2,9 +2,9 @@\n \n template <class T = int> // ERROR - original definition\n struct S\n-{\n+{ // ERROR - redefinition of default arg\n   template <class U = int>\n   friend class S;\n };\n \n-template struct S<int>; // ERROR - redefinition of default arg\n+template struct S<int>; // ERROR - instantiated from here"}, {"sha": "6dab744b357ee66c6ade1e99ad81a66b8728cebc", "filename": "gcc/testsuite/g++.old-deja/g++.pt/t05.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ft05.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ft05.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ft05.C?ref=ae58fa02be510bc8a7bb014a5f3f511594848d22", "patch": "@@ -1,9 +1,9 @@\n // Build don't link: \n \n-template <class A> class B {\n-  A a;\n+template <class A> class B {    // ERROR - candidates\n+  A a;                          \n  public:\n-  B(A&aa);\t\t\t// ERROR - \n+  B(A&aa);\t\t\t// ERROR - near match\n   ~B();\n };\n-static B<int> b_int (3);\t// ERROR - \n+static B<int> b_int (3);\t// ERROR - no matching function"}, {"sha": "d2eb4cede91524a0f645e83b55e6cac55963731a", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename8.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename8.C?ref=ae58fa02be510bc8a7bb014a5f3f511594848d22", "patch": "@@ -0,0 +1,27 @@\n+// Build don't link:\n+\n+template < class T > class A\n+{\n+public:\n+  typedef typename T::myT anotherT; // ERROR - undefined type\n+\n+  anotherT t; // ERROR - undefined type \n+\n+  A(anotherT _t) { // ERROR - undefined type\n+    t=_t;\n+  }\n+\n+  anotherT getT() {\n+    return t;\n+  }\n+};\n+\n+class B : public A< B >\n+{\n+public:\n+  typedef int myT;\n+};\n+\n+int main() {\n+  B b;\n+}"}, {"sha": "94141548687e7db2526546566b86a7c171bbe799", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb109.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb109.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb109.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb109.C?ref=ae58fa02be510bc8a7bb014a5f3f511594848d22", "patch": "@@ -17,7 +17,7 @@ inline istream& operator>>(istream& is, Empty& ) { return is;}\n \n template<class VertexType, class EdgeType>\n class Graph\n-{\n+{ // ERROR - candidates\n   public:\n     // public type interface\n     typedef map<int, EdgeType > Successor;"}, {"sha": "d056e39012e9bbda0a2073c08b30c874fb61124e", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb128.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb128.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae58fa02be510bc8a7bb014a5f3f511594848d22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb128.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb128.C?ref=ae58fa02be510bc8a7bb014a5f3f511594848d22", "patch": "@@ -1,11 +1,11 @@\n template<class T>\n struct A {\n-  typedef T* iterator;\n+  typedef T* iterator; // ERROR - pointer to reference\n public:\n   A(){}\n };\n \n void f()\n {\n-  A<int&> a;  // ERROR - pointer to reference\n+  A<int&> a; // ERROR - instantiated from here\n }"}]}