{"sha": "48c6cac9caea1dc7c5f50ad3a736f6693e74a11b", "node_id": "C_kwDOANBUbNoAKDQ4YzZjYWM5Y2FlYTFkYzdjNWY1MGFkM2E3MzZmNjY5M2U3NGExMWI", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-11-12T16:58:21Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-11-12T16:58:21Z"}, "message": "Fortran/openmp: Fix '!$omp end'\n\ngcc/fortran/ChangeLog:\n\n\t* parse.c (decode_omp_directive): Fix permitting 'nowait' for some\n\tcombined directives, add missing 'omp end ... loop'.\n\t(gfc_ascii_statement): Fix ST_OMP_END_TEAMS_LOOP result.\n\t* openmp.c (resolve_omp_clauses): Add missing combined loop constructs\n\tcase values to the 'if(directive-name: ...)' check.\n\t* trans-openmp.c (gfc_split_omp_clauses): Put nowait on target if\n\tfirst leaf construct accepting it.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/gomp/unexpected-end.f90: Update dg-error.\n\t* gfortran.dg/gomp/clauses-1.f90: New test.\n\t* gfortran.dg/gomp/nowait-2.f90: New test.\n\t* gfortran.dg/gomp/nowait-3.f90: New test.", "tree": {"sha": "02647c63a8ab3cf80e11a645a15ca6b5376cb8fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02647c63a8ab3cf80e11a645a15ca6b5376cb8fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82de09ab17cd3876134d46ad7a6d2c32235bf8f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82de09ab17cd3876134d46ad7a6d2c32235bf8f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82de09ab17cd3876134d46ad7a6d2c32235bf8f5"}], "stats": {"total": 1148, "additions": 1131, "deletions": 17}, "files": [{"sha": "2893ab2befb3301b16c8e3f4a02af09f3abeda42", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=48c6cac9caea1dc7c5f50ad3a736f6693e74a11b", "patch": "@@ -6232,6 +6232,7 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \n \t    case EXEC_OMP_PARALLEL:\n \t    case EXEC_OMP_PARALLEL_DO:\n+\t    case EXEC_OMP_PARALLEL_LOOP:\n \t    case EXEC_OMP_PARALLEL_MASKED:\n \t    case EXEC_OMP_PARALLEL_MASTER:\n \t    case EXEC_OMP_PARALLEL_SECTIONS:\n@@ -6285,6 +6286,7 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t    case EXEC_OMP_TARGET:\n \t    case EXEC_OMP_TARGET_TEAMS:\n \t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE:\n+\t    case EXEC_OMP_TARGET_TEAMS_LOOP:\n \t      ok = ifc == OMP_IF_TARGET;\n \t      break;\n \n@@ -6312,6 +6314,7 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t    case EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO:\n \t    case EXEC_OMP_TARGET_PARALLEL:\n \t    case EXEC_OMP_TARGET_PARALLEL_DO:\n+\t    case EXEC_OMP_TARGET_PARALLEL_LOOP:\n \t      ok = ifc == OMP_IF_TARGET || ifc == OMP_IF_PARALLEL;\n \t      break;\n "}, {"sha": "94b677f2a7087d5e049adb194a256564a5eb0e1c", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=48c6cac9caea1dc7c5f50ad3a736f6693e74a11b", "patch": "@@ -924,6 +924,7 @@ decode_omp_directive (void)\n       matcho (\"end distribute\", gfc_match_omp_eos_error, ST_OMP_END_DISTRIBUTE);\n       matchs (\"end do simd\", gfc_match_omp_end_nowait, ST_OMP_END_DO_SIMD);\n       matcho (\"end do\", gfc_match_omp_end_nowait, ST_OMP_END_DO);\n+      matcho (\"end loop\", gfc_match_omp_eos_error, ST_OMP_END_LOOP);\n       matchs (\"end simd\", gfc_match_omp_eos_error, ST_OMP_END_SIMD);\n       matcho (\"end masked taskloop simd\", gfc_match_omp_eos_error,\n \t      ST_OMP_END_MASKED_TASKLOOP_SIMD);\n@@ -939,6 +940,8 @@ decode_omp_directive (void)\n       matchs (\"end parallel do simd\", gfc_match_omp_eos_error,\n \t      ST_OMP_END_PARALLEL_DO_SIMD);\n       matcho (\"end parallel do\", gfc_match_omp_eos_error, ST_OMP_END_PARALLEL_DO);\n+      matcho (\"end parallel loop\", gfc_match_omp_eos_error,\n+\t      ST_OMP_END_PARALLEL_LOOP);\n       matcho (\"end parallel masked taskloop simd\", gfc_match_omp_eos_error,\n \t      ST_OMP_END_PARALLEL_MASKED_TASKLOOP_SIMD);\n       matcho (\"end parallel masked taskloop\", gfc_match_omp_eos_error,\n@@ -960,24 +963,29 @@ decode_omp_directive (void)\n       matcho (\"end sections\", gfc_match_omp_end_nowait, ST_OMP_END_SECTIONS);\n       matcho (\"end single\", gfc_match_omp_end_single, ST_OMP_END_SINGLE);\n       matcho (\"end target data\", gfc_match_omp_eos_error, ST_OMP_END_TARGET_DATA);\n-      matchs (\"end target parallel do simd\", gfc_match_omp_eos_error,\n+      matchs (\"end target parallel do simd\", gfc_match_omp_end_nowait,\n \t      ST_OMP_END_TARGET_PARALLEL_DO_SIMD);\n-      matcho (\"end target parallel do\", gfc_match_omp_eos_error,\n+      matcho (\"end target parallel do\", gfc_match_omp_end_nowait,\n \t      ST_OMP_END_TARGET_PARALLEL_DO);\n-      matcho (\"end target parallel\", gfc_match_omp_eos_error,\n+      matcho (\"end target parallel loop\", gfc_match_omp_end_nowait,\n+\t      ST_OMP_END_TARGET_PARALLEL_LOOP);\n+      matcho (\"end target parallel\", gfc_match_omp_end_nowait,\n \t      ST_OMP_END_TARGET_PARALLEL);\n-      matchs (\"end target simd\", gfc_match_omp_eos_error, ST_OMP_END_TARGET_SIMD);\n+      matchs (\"end target simd\", gfc_match_omp_end_nowait, ST_OMP_END_TARGET_SIMD);\n       matchs (\"end target teams distribute parallel do simd\",\n-\t      gfc_match_omp_eos_error,\n+\t      gfc_match_omp_end_nowait,\n \t      ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD);\n-      matcho (\"end target teams distribute parallel do\", gfc_match_omp_eos_error,\n+      matcho (\"end target teams distribute parallel do\", gfc_match_omp_end_nowait,\n \t      ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO);\n-      matchs (\"end target teams distribute simd\", gfc_match_omp_eos_error,\n+      matchs (\"end target teams distribute simd\", gfc_match_omp_end_nowait,\n \t      ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_SIMD);\n-      matcho (\"end target teams distribute\", gfc_match_omp_eos_error,\n+      matcho (\"end target teams distribute\", gfc_match_omp_end_nowait,\n \t      ST_OMP_END_TARGET_TEAMS_DISTRIBUTE);\n-      matcho (\"end target teams\", gfc_match_omp_eos_error, ST_OMP_END_TARGET_TEAMS);\n-      matcho (\"end target\", gfc_match_omp_eos_error, ST_OMP_END_TARGET);\n+      matcho (\"end target teams loop\", gfc_match_omp_end_nowait,\n+\t      ST_OMP_END_TARGET_TEAMS_LOOP);\n+      matcho (\"end target teams\", gfc_match_omp_end_nowait,\n+\t      ST_OMP_END_TARGET_TEAMS);\n+      matcho (\"end target\", gfc_match_omp_end_nowait, ST_OMP_END_TARGET);\n       matcho (\"end taskgroup\", gfc_match_omp_eos_error, ST_OMP_END_TASKGROUP);\n       matchs (\"end taskloop simd\", gfc_match_omp_eos_error,\n \t      ST_OMP_END_TASKLOOP_SIMD);\n@@ -991,6 +999,7 @@ decode_omp_directive (void)\n \t      ST_OMP_END_TEAMS_DISTRIBUTE_SIMD);\n       matcho (\"end teams distribute\", gfc_match_omp_eos_error,\n \t      ST_OMP_END_TEAMS_DISTRIBUTE);\n+      matcho (\"end teams loop\", gfc_match_omp_eos_error, ST_OMP_END_TEAMS_LOOP);\n       matcho (\"end teams\", gfc_match_omp_eos_error, ST_OMP_END_TEAMS);\n       matcho (\"end workshare\", gfc_match_omp_end_nowait,\n \t      ST_OMP_END_WORKSHARE);\n@@ -2553,7 +2562,7 @@ gfc_ascii_statement (gfc_statement st)\n       p = \"!$OMP END TEAMS DISTRIBUTE SIMD\";\n       break;\n     case ST_OMP_END_TEAMS_LOOP:\n-      p = \"!$OMP END TEAMS LOP\";\n+      p = \"!$OMP END TEAMS LOOP\";\n       break;\n     case ST_OMP_END_WORKSHARE:\n       p = \"!$OMP END WORKSHARE\";"}, {"sha": "b86c7cf98330ac2484095432230ba71696eb4c7a", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=48c6cac9caea1dc7c5f50ad3a736f6693e74a11b", "patch": "@@ -5878,6 +5878,8 @@ gfc_split_omp_clauses (gfc_code *code,\n \t  /* And this is copied to all.  */\n \t  clausesa[GFC_OMP_SPLIT_TARGET].if_expr\n \t    = code->ext.omp_clauses->if_expr;\n+\t  clausesa[GFC_OMP_SPLIT_TARGET].nowait\n+\t    = code->ext.omp_clauses->nowait;\n \t}\n       if (mask & GFC_OMP_MASK_TEAMS)\n \t{"}, {"sha": "639f5d19bdb6ac92880e094d96d15cf39bbfed00", "filename": "gcc/testsuite/gfortran.dg/gomp/clauses-1.f90", "status": "added", "additions": 667, "deletions": 0, "changes": 667, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclauses-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclauses-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclauses-1.f90?ref=48c6cac9caea1dc7c5f50ad3a736f6693e74a11b", "patch": "@@ -0,0 +1,667 @@\n+! { dg-do compile }\n+\n+module m\n+  use iso_c_binding, only: c_intptr_t\n+  implicit none (external, type)\n+\n+  integer(c_intptr_t), parameter :: &\n+    omp_null_allocator = 0,         &\n+    omp_default_mem_alloc = 1,      &\n+    omp_large_cap_mem_alloc = 2,    &\n+    omp_const_mem_alloc = 3,        &\n+    omp_high_bw_mem_alloc = 4,      &\n+    omp_low_lat_mem_alloc = 5,      &\n+    omp_cgroup_mem_alloc = 6,       &\n+    omp_pteam_mem_alloc = 7,        &\n+    omp_thread_mem_alloc = 8\n+\n+  integer, parameter :: &\n+    omp_allocator_handle_kind = c_intptr_t\n+\n+  integer :: t\n+  !$omp threadprivate (t)\n+\n+  integer :: f, l, ll, r, r2\n+  !$omp declare target (f, l, ll, r, r2)\n+\n+contains\n+\n+subroutine foo (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd, ntm)\n+  !$omp declare target (foo)\n+  integer :: d, m, p, idp, s, nte, tl, nth, g, nta, pp, q, dd, ntm\n+  logical :: i1, i2, i3, fi\n+  pointer :: q\n+  integer :: i\n+\n+  !$omp distribute parallel do &\n+  !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n+  !$omp&  if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) schedule(static, 4) order(concurrent)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp distribute parallel do simd &\n+  !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n+  !$omp&  if (parallel: i2) if(simd: i1) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) schedule(static, 4) nontemporal(ntm) &\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) order(concurrent)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp distribute simd &\n+  !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) reduction(+:r) if(i1) nontemporal(ntm) &\n+  !$omp&  order(concurrent)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+end\n+\n+subroutine qux (p)\n+  !$omp declare target (qux)\n+  integer, value :: p\n+\n+  !$omp loop bind(teams) order(concurrent) &\n+  !$omp&  private (p) lastprivate (l) collapse(1) reduction(+:r)\n+  do l = 1, 64\n+    ll = ll + 1\n+  end do\n+end\n+\n+subroutine baz (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd, ntm)\n+  integer :: d, m, p, idp, s, nte, tl, nth, g, nta, pp, q, dd, ntm\n+  logical :: i1, i2, i3, fi\n+  pointer :: q\n+  integer :: i\n+  !$omp distribute parallel do &\n+  !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n+  !$omp&  if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) schedule(static, 4) copyin(t)\n+  ! FIXME/TODO: allocate (p)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp distribute parallel do &\n+  !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n+  !$omp&  if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) schedule(static, 4) order(concurrent)\n+  ! FIXME/TODO: allocate (p)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp distribute parallel do simd &\n+  !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n+  !$omp&  if (parallel: i2) if(simd: i1) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) schedule(static, 4) nontemporal(ntm) &\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) copyin(t)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+\n+  !$omp distribute parallel do simd &\n+  !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n+  !$omp&  if (parallel: i2) if(simd: i1) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) schedule(static, 4) nontemporal(ntm) &\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) order(concurrent)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+\n+  !$omp distribute simd &\n+  !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) reduction(+:r) if(i1) nontemporal(ntm) &\n+  !$omp&  order(concurrent)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+\n+  !$omp loop bind(parallel) order(concurrent) &\n+  !$omp&  private (p) lastprivate (l) collapse(1) reduction(+:r)\n+  do l = 1, 64\n+    ll = ll + 1\n+  end do\n+end\n+\n+subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd, ntm)\n+  integer :: d, m, p, idp, s, nte, tl, nth, g, nta, pp, q, dd(0:5), ntm\n+  logical :: i1, i2, i3, fi\n+  pointer :: q\n+  integer :: i\n+\n+  !$omp do simd &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) linear (ll:1) reduction(+:r) schedule(static, 4) collapse(1) &\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) if(i1) order(concurrent)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+  !$omp end do simd nowait\n+\n+  !$omp parallel do &\n+  !$omp&  private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) &\n+  !$omp&  proc_bind(spread) lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+\n+  !$omp parallel do &\n+  !$omp&  private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) &\n+  !$omp&  proc_bind(spread) lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) order(concurrent)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+\n+  !$omp parallel do simd &\n+  !$omp&  private (p) firstprivate (f) if (i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) &\n+  !$omp&  proc_bind(spread) lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) &\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) order(concurrent)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+\n+  !$omp parallel sections &\n+  !$omp&  private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) &\n+  !$omp&  proc_bind(spread) lastprivate (l)\n+  ! FIXME/TODO: allocate (f)\n+    !$omp section\n+      block; end block\n+    !$omp section\n+      block; end block\n+  !$omp end parallel sections\n+\n+  !$omp target parallel &\n+  !$omp&  device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n+  !$omp&  if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n+  !$omp&  depend(inout: dd(0)) in_reduction(+:r2)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  !$omp end target parallel nowait\n+\n+  !$omp target parallel do &\n+  !$omp&  device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n+  !$omp&  if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1) depend(inout: dd(0)) &\n+  !$omp&  in_reduction(+:r2)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+  !$omp end target parallel do nowait\n+\n+  !$omp target parallel do &\n+  !$omp&  device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n+  !$omp&  if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) depend(inout: dd(0)) order(concurrent) &\n+  !$omp&  in_reduction(+:r2)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+  !$omp end target parallel do nowait\n+\n+  !$omp target parallel do simd &\n+  !$omp&  device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n+  !$omp&  if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) &\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) depend(inout: dd(0)) nontemporal(ntm) if (simd: i3) order(concurrent) &\n+  !$omp&  in_reduction(+:r2)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+  !$omp end target parallel do simd nowait\n+\n+  !$omp target teams &\n+  !$omp&  device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n+  !$omp&  shared(s) default(shared) reduction(+:r) num_teams(nte - 1:nte) thread_limit(tl) depend(inout: dd(0)) &\n+  !$omp&  in_reduction(+:r2)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  !$omp end target teams nowait\n+\n+  !$omp target teams distribute &\n+  !$omp&  device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n+  !$omp&  shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) order(concurrent) &\n+  !$omp&  collapse(1) dist_schedule(static, 16) depend(inout: dd(0)) in_reduction(+:r2)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  do i = 1, 64\n+  end do\n+  !$omp end target teams distribute nowait\n+\n+  !$omp target teams distribute parallel do &\n+  !$omp&  device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n+  !$omp&  shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) &\n+  !$omp&  collapse(1) dist_schedule(static, 16) &\n+  !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) schedule(static, 4) depend(inout: dd(0)) order(concurrent) &\n+  !$omp&  in_reduction(+:r2)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+  !$omp end target teams distribute parallel do nowait\n+\n+  !$omp target teams distribute parallel do simd &\n+  !$omp&  device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n+  !$omp&  shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) &\n+  !$omp&  collapse(1) dist_schedule(static, 16) &\n+  !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) schedule(static, 4) order(concurrent) &\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) depend(inout: dd(0)) nontemporal(ntm) if (simd: i3) &\n+  !$omp&  in_reduction(+:r2)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+  !$omp end target teams distribute parallel do simd nowait\n+\n+  !$omp target teams distribute simd &\n+  !$omp&  device(d) map (tofrom: m) if (i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n+  !$omp&  shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) &\n+  !$omp&  collapse(1) dist_schedule(static, 16) order(concurrent) &\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) depend(inout: dd(0)) nontemporal(ntm) &\n+  !$omp&  in_reduction(+:r2)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+  !$omp end target teams distribute simd nowait\n+\n+  !$omp target simd &\n+  !$omp&  device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n+  !$omp&  safelen(8) simdlen(4) lastprivate (l) linear(ll: 1) aligned(q: 32) reduction(+:r) &\n+  !$omp&  depend(inout: dd(0)) nontemporal(ntm) if(simd:i3) order(concurrent) &\n+  !$omp&  in_reduction(+:r2)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+  !$omp end target simd nowait\n+\n+  !$omp taskgroup task_reduction(+:r2)\n+  ! FIXME/TODO: allocate (r2)\n+  !$omp taskloop simd &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n+  !$omp&  if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) &\n+  !$omp&  safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) &\n+  !$omp&  order(concurrent)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+  !$omp end taskgroup\n+\n+  !$omp taskgroup task_reduction(+:r)\n+  ! FIXME/TODO: allocate (r)\n+  !$omp taskloop simd &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(i1) &\n+  !$omp&  final(fi) mergeable nogroup priority (pp) &\n+  !$omp&  safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) in_reduction(+:r) nontemporal(ntm) &\n+  !$omp&  order(concurrent)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+  !$omp end taskgroup\n+\n+  !$omp taskwait\n+  !$omp taskloop simd &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) if(taskloop: i1) &\n+  !$omp&  final(fi) priority (pp) safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(+:r) if (simd: i3) nontemporal(ntm) &\n+  !$omp&  order(concurrent)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll + 1\n+  end do\n+\n+  !$omp target depend(inout: dd(0)) in_reduction(+:r2)\n+  !$omp teams distribute &\n+  !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) &\n+  !$omp&  collapse(1) dist_schedule(static, 16) order(concurrent)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc: f)\n+  do i = 1, 64\n+  end do\n+  !$omp end target nowait\n+\n+  !$omp target\n+  !$omp teams distribute parallel do &\n+  !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) &\n+  !$omp&  collapse(1) dist_schedule(static, 16) &\n+  !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) schedule(static, 4) order(concurrent)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc: f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+  !$omp end target\n+\n+  !$omp target\n+  !$omp teams distribute parallel do simd &\n+  !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) &\n+  !$omp&  collapse(1) dist_schedule(static, 16) &\n+  !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) schedule(static, 4) order(concurrent) &\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc: f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+  !$omp end target\n+\n+  !$omp target\n+  !$omp teams distribute simd &\n+  !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) &\n+  !$omp&  collapse(1) dist_schedule(static, 16) order(concurrent) &\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc: f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+  !$omp end target\n+\n+  !$omp teams distribute parallel do &\n+  !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) &\n+  !$omp&  collapse(1) dist_schedule(static, 16) &\n+  !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) schedule(static, 4) copyin(t)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp teams distribute parallel do &\n+  !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) &\n+  !$omp&  collapse(1) dist_schedule(static, 16) order(concurrent) &\n+  !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) schedule(static, 4)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp teams distribute parallel do simd &\n+  !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) &\n+  !$omp&  collapse(1) dist_schedule(static, 16) &\n+  !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) schedule(static, 4) &\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm) copyin(t)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp teams distribute parallel do simd &\n+  !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) &\n+  !$omp&  collapse(1) dist_schedule(static, 16) &\n+  !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n+  !$omp&  lastprivate (l) schedule(static, 4) order(concurrent) &\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp teams distribute simd &\n+  !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) &\n+  !$omp&  collapse(1) dist_schedule(static, 16) order(concurrent) &\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm)\n+  ! FIXME/TODO: allocate(f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp parallel master &\n+  !$omp&  private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) reduction(+:r) &\n+  !$omp&  num_threads (nth) proc_bind(spread) copyin(t)\n+  ! FIXME/TODO: allocate (f)\n+  !$omp end parallel master\n+\n+  !$omp parallel masked &\n+  !$omp&  private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) reduction(+:r) &\n+  !$omp&  num_threads (nth) proc_bind(spread) copyin(t) filter (d)\n+  ! FIXME/TODO: allocate (f)\n+  !$omp end parallel masked\n+\n+  !$omp taskgroup task_reduction (+:r2)\n+  ! FIXME/TODO: allocate (r2)\n+  !$omp master taskloop &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n+  !$omp&  if(taskloop: i1) final(fi) mergeable priority (pp) &\n+  !$omp&  reduction(default, +:r) in_reduction(+:r2)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+  !$omp end taskgroup\n+\n+  !$omp taskgroup task_reduction (+:r2)\n+  ! FIXME/TODO: allocate (r2)\n+  !$omp masked taskloop &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n+  !$omp&  if(taskloop: i1) final(fi) mergeable priority (pp) reduction(default, +:r) in_reduction(+:r2) filter (d)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+  !$omp end taskgroup\n+\n+  !$omp taskgroup task_reduction (+:r2)\n+  ! FIXME/TODO: allocate (r2)\n+  !$omp master taskloop simd &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n+  !$omp&  if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) &\n+  !$omp&  safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) &\n+  !$omp&  order(concurrent)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+  !$omp end taskgroup\n+\n+  !$omp taskgroup task_reduction (+:r2)\n+  ! FIXME/TODO: allocate (r2)\n+  !$omp masked taskloop simd &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n+  !$omp&  if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) &\n+  !$omp&  safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) &\n+  !$omp&  order(concurrent) filter (d)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+  !$omp end taskgroup\n+\n+  !$omp parallel master taskloop &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n+  !$omp&  if(taskloop: i1) final(fi) mergeable priority (pp) &\n+  !$omp&  reduction(default, +:r) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp parallel masked taskloop &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n+  !$omp&  if(taskloop: i1) final(fi) mergeable priority (pp) &\n+  !$omp&  reduction(default, +:r) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t) filter (d)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp parallel master taskloop simd &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n+  !$omp&  if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) &\n+  !$omp&  safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) if (parallel: i2) &\n+  !$omp&  num_threads (nth) proc_bind(spread) copyin(t) order(concurrent)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp parallel masked taskloop simd &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n+  !$omp&  if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) &\n+  !$omp&  safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) if (parallel: i2) &\n+  !$omp&  num_threads (nth) proc_bind(spread) copyin(t) order(concurrent) filter (d)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp taskgroup task_reduction (+:r2)\n+  ! FIXME/TODO: allocate (r2)\n+  !$omp master taskloop &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) &\n+  !$omp&  untied if(i1) final(fi) mergeable priority (pp) reduction(default, +:r) in_reduction(+:r2)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+  !$omp end taskgroup\n+\n+  !$omp taskgroup task_reduction (+:r2)\n+  ! FIXME/TODO: allocate (r2)\n+  !$omp masked taskloop &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) &\n+  !$omp&  untied if(i1) final(fi) mergeable priority (pp) reduction(default, +:r) in_reduction(+:r2) filter (d)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+  !$omp end taskgroup\n+\n+  !$omp taskgroup task_reduction (+:r2)\n+  ! FIXME/TODO: allocate (r2)\n+  !$omp master taskloop simd &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) &\n+  !$omp&  final(fi) mergeable priority (pp) safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) &\n+  !$omp&  in_reduction(+:r2) nontemporal(ntm) order(concurrent)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+  !$omp end taskgroup\n+\n+  !$omp taskgroup task_reduction (+:r2)\n+  ! FIXME/TODO: allocate (r2)\n+  !$omp masked taskloop simd &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied &\n+  !$omp&  if(i1) final(fi) mergeable priority (pp) safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) &\n+  !$omp&  in_reduction(+:r2) nontemporal(ntm) order(concurrent) filter (d)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+  !$omp end taskgroup\n+\n+  !$omp parallel master taskloop &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied &\n+  !$omp&  if(i1) final(fi) mergeable priority (pp) reduction(default, +:r) num_threads (nth) proc_bind(spread) copyin(t)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp parallel masked taskloop &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied &\n+  !$omp&  if(i1) final(fi) mergeable priority (pp) reduction(default, +:r) num_threads (nth) proc_bind(spread) &\n+  !$omp&  copyin(t) filter (d)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp parallel master taskloop simd &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied &\n+  !$omp&  if(i1) final(fi) mergeable priority (pp) safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) &\n+  !$omp&  nontemporal(ntm) num_threads (nth) proc_bind(spread)copyin(t) order(concurrent)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp parallel masked taskloop simd &\n+  !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) &\n+  !$omp&  final(fi) mergeable priority (pp) safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) &\n+  !$omp&  nontemporal(ntm) num_threads (nth) proc_bind(spread) copyin(t) order(concurrent) filter (d)\n+  ! FIXME/TODO: allocate (f)\n+  do i = 1, 64\n+    ll = ll +1\n+  end do\n+\n+  !$omp loop bind(thread) order(concurrent) &\n+  !$omp&  private (p) lastprivate (l) collapse(1) reduction(+:r)\n+  do l = 1, 64\n+    ll = ll + 1\n+  end do\n+\n+  !$omp parallel loop &\n+  !$omp&  private (p) firstprivate (f) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) &\n+  !$omp&  proc_bind(spread) lastprivate (l) collapse(1) bind(parallel) order(concurrent) if (parallel: i2)\n+  ! FIXME/TODO: allocate (f)\n+  do l = 1, 64\n+    ll = ll + 1\n+  end do\n+\n+  !$omp parallel loop &\n+  !$omp&  private (p) firstprivate (f) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) &\n+  !$omp&  proc_bind(spread) lastprivate (l) collapse(1) if (parallel: i2)\n+  ! FIXME/TODO: allocate (f)\n+  do l = 1, 64\n+    ll = ll + 1\n+  end do\n+\n+  !$omp teams loop &\n+  !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) &\n+  !$omp&  collapse(1) lastprivate (l) bind(teams)\n+  ! FIXME/TODO: allocate (f)\n+  do l = 1, 64\n+  end do\n+\n+  !$omp teams loop &\n+  !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) &\n+  !$omp&  collapse(1) lastprivate (l) order(concurrent)\n+  ! FIXME/TODO: allocate (f)\n+  do l = 1, 64\n+  end do\n+\n+  !$omp target parallel loop &\n+  !$omp&  device(d) map (tofrom: m) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n+  !$omp&  default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n+  !$omp&  depend(inout: dd(0)) lastprivate (l) order(concurrent) collapse(1) in_reduction(+:r2) &\n+  !$omp&  if (target: i1) if (parallel: i2)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc: f)\n+  do l = 1, 64\n+  end do\n+  !$omp end target parallel loop nowait\n+\n+  !$omp target teams loop &\n+  !$omp&  device(d) map (tofrom: m) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n+  !$omp&  shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) depend(inout: dd(0)) &\n+  !$omp&  lastprivate (l) bind(teams) collapse(1) in_reduction(+:r2) if (target: i1)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc: f)\n+  do l = 1, 64\n+  end do\n+  !$omp end target teams loop nowait\n+\n+  !$omp target teams loop &\n+  !$omp&  device(d) map (tofrom: m) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n+  !$omp&  shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) depend(inout: dd(0)) &\n+  !$omp&  lastprivate (l) order(concurrent) collapse(1) in_reduction(+:r2) if (target: i1)\n+  ! FIXME/TODO: allocate (omp_default_mem_alloc: f)\n+  do l = 1, 64\n+  end do\n+  !$omp end target teams loop nowait\n+\n+end\n+end module"}, {"sha": "d18459bd3156c8fbd638a4c876a46fc179f53e56", "filename": "gcc/testsuite/gfortran.dg/gomp/nowait-2.f90", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fnowait-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fnowait-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fnowait-2.f90?ref=48c6cac9caea1dc7c5f50ad3a736f6693e74a11b", "patch": "@@ -0,0 +1,315 @@\n+! Cross check that it is accepted without nowait\n+subroutine bar()\n+implicit none\n+integer :: i, a(5)\n+!$omp atomic write\n+i = 5\n+!$omp end atomic\n+\n+!$omp critical\n+!$omp end critical\n+\n+!$omp distribute\n+do i = 1, 5\n+end do\n+!$omp end distribute\n+\n+!$omp distribute parallel do\n+do i = 1, 5\n+end do\n+!$omp end distribute parallel do\n+\n+!$omp distribute parallel do simd\n+do i = 1, 5\n+end do\n+!$omp end distribute parallel do simd\n+\n+!$omp distribute simd\n+do i = 1, 5\n+end do\n+!$omp end distribute simd\n+\n+!$omp masked\n+!$omp end masked\n+\n+!$omp masked taskloop\n+do i = 1, 5\n+end do\n+!$omp end masked taskloop\n+\n+!$omp masked taskloop simd\n+do i = 1, 5\n+end do\n+!$omp end masked taskloop simd\n+\n+!$omp master\n+!$omp end master\n+\n+!$omp master taskloop\n+do i = 1, 5\n+end do\n+!$omp end master taskloop\n+\n+!$omp master taskloop simd\n+do i = 1, 5\n+end do\n+!$omp end master taskloop simd\n+\n+!$omp ordered\n+!$omp end ordered\n+\n+!$omp parallel\n+!$omp end parallel\n+\n+!$omp parallel workshare\n+a(:) = 5\n+!$omp end parallel workshare\n+\n+!$omp parallel do\n+do i = 1, 5\n+end do\n+!$omp end parallel do\n+\n+!$omp parallel do simd\n+do i = 1, 5\n+end do\n+!$omp end parallel do simd\n+\n+!$omp parallel sections\n+  !$omp section\n+  block; end block\n+!$omp end parallel sections\n+\n+!$omp parallel masked\n+!$omp end parallel masked\n+\n+!$omp parallel masked taskloop\n+do i = 1, 5\n+end do\n+!$omp end parallel masked taskloop\n+\n+!$omp parallel masked taskloop simd\n+do i = 1, 5\n+end do\n+!$omp end parallel masked taskloop simd\n+\n+!$omp parallel master\n+!$omp end parallel master\n+\n+!$omp parallel master taskloop\n+do i = 1, 5\n+end do\n+!$omp end parallel master taskloop\n+\n+!$omp parallel master taskloop simd\n+do i = 1, 5\n+end do\n+!$omp end parallel master taskloop simd\n+\n+!$omp simd\n+do i = 1, 5\n+end do\n+!$omp end simd\n+\n+!$omp task\n+!$omp end task\n+\n+!$omp taskgroup\n+!$omp end taskgroup\n+\n+!$omp taskloop\n+do i = 1, 5\n+end do\n+!$omp end taskloop\n+\n+!$omp taskloop simd\n+do i = 1, 5\n+end do\n+!$omp end taskloop simd\n+\n+!$omp teams\n+!$omp end teams\n+\n+!$omp teams distribute\n+do i = 1, 5\n+end do\n+!$omp end teams distribute\n+\n+!$omp teams distribute parallel do\n+do i = 1, 5\n+end do\n+!$omp end teams distribute parallel do\n+\n+!$omp teams distribute parallel do simd\n+do i = 1, 5\n+end do\n+!$omp end teams distribute parallel do simd\n+\n+!$omp teams distribute simd\n+do i = 1, 5\n+end do\n+!$omp end teams distribute simd\n+\n+!$omp target data map(tofrom:i)\n+!$omp end target data\n+\n+end\n+\n+! invalid nowait\n+\n+subroutine foo\n+implicit none\n+integer :: i, a(5)\n+!$omp atomic write\n+i = 5\n+!$omp end atomic nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp critical\n+!$omp end critical nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp distribute\n+do i = 1, 5\n+end do\n+!$omp end distribute nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp distribute parallel do\n+do i = 1, 5\n+end do\n+!$omp end distribute parallel do nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp distribute parallel do simd\n+do i = 1, 5\n+end do\n+!$omp end distribute parallel do simd nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp parallel sections\n+  !$omp section\n+  block; end block\n+!$omp end parallel sections nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp distribute simd\n+do i = 1, 5\n+end do\n+!$omp end distribute simd nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp masked\n+!$omp end masked nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp masked taskloop\n+do i = 1, 5\n+end do\n+!$omp end masked taskloop nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp masked taskloop simd\n+do i = 1, 5\n+end do\n+!$omp end masked taskloop simd nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp master\n+!$omp end master nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp master taskloop\n+do i = 1, 5\n+end do\n+!$omp end master taskloop nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp master taskloop simd\n+do i = 1, 5\n+end do\n+!$omp end master taskloop simd nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp ordered\n+!$omp end ordered nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp parallel\n+!$omp end parallel nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp parallel workshare\n+a(:) = 5\n+!$omp end parallel workshare nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp parallel do\n+do i = 1, 5\n+end do\n+!$omp end parallel do nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp parallel do simd\n+do i = 1, 5\n+end do\n+!$omp end parallel do simd nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp parallel masked\n+!$omp end parallel masked nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp parallel masked taskloop\n+do i = 1, 5\n+end do\n+!$omp end parallel masked taskloop nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp parallel masked taskloop simd\n+do i = 1, 5\n+end do\n+!$omp end parallel masked taskloop simd nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp parallel master\n+!$omp end parallel master nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp parallel master taskloop\n+do i = 1, 5\n+end do\n+!$omp end parallel master taskloop nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp parallel master taskloop simd\n+do i = 1, 5\n+end do\n+!$omp end parallel master taskloop simd nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp simd\n+do i = 1, 5\n+end do\n+!$omp end simd nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp task\n+!$omp end task nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp taskgroup\n+!$omp end taskgroup nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp taskloop\n+do i = 1, 5\n+end do\n+!$omp end taskloop nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp taskloop simd\n+do i = 1, 5\n+end do\n+!$omp end taskloop simd nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp teams\n+!$omp end teams nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp teams distribute\n+do i = 1, 5\n+end do\n+!$omp end teams distribute nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp teams distribute parallel do\n+do i = 1, 5\n+end do\n+!$omp end teams distribute parallel do nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp teams distribute parallel do simd\n+do i = 1, 5\n+end do\n+!$omp end teams distribute parallel do simd nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp teams distribute simd\n+do i = 1, 5\n+end do\n+!$omp end teams distribute simd nowait  ! { dg-error \"Unexpected junk\" }\n+\n+!$omp target data map(tofrom:i)\n+!$omp end target data nowait  ! { dg-error \"Unexpected junk\" }\n+\n+end  ! { dg-error \"Unexpected END statement\" }\n+! { dg-prune-output \"Unexpected end of file\" }"}, {"sha": "a58b8fd33b1efb3e4a0229ebf7210200f3c47db5", "filename": "gcc/testsuite/gfortran.dg/gomp/nowait-3.f90", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fnowait-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fnowait-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fnowait-3.f90?ref=48c6cac9caea1dc7c5f50ad3a736f6693e74a11b", "patch": "@@ -0,0 +1,118 @@\n+! { dg-additional-options \"-fdump-tree-original\" }\n+\n+subroutine foo\n+implicit none\n+integer :: i, a(5)\n+\n+!$omp do\n+do i = 1, 5\n+end do\n+!$omp end do nowait\n+\n+!$omp do simd\n+do i = 1, 5\n+end do\n+!$omp end do simd nowait\n+\n+!$omp scope\n+!$omp end scope nowait\n+\n+!$omp sections\n+  !$omp section\n+  block; end block\n+!$omp end sections nowait\n+\n+!$omp single\n+!$omp end single nowait\n+\n+!$omp target\n+!$omp end target nowait\n+\n+!$omp target parallel\n+!$omp end target parallel nowait\n+\n+!$omp target parallel do\n+do i = 1, 5\n+end do\n+!$omp end target parallel do nowait\n+\n+!$omp target parallel do simd\n+do i = 1, 5\n+end do\n+!$omp end target parallel do simd nowait\n+\n+!$omp target parallel loop\n+do i = 1, 5\n+end do\n+!$omp end target parallel loop nowait\n+\n+!$omp target teams distribute parallel do\n+do i = 1, 5\n+end do\n+!$omp end target teams distribute parallel do nowait\n+\n+!$omp target teams distribute parallel do simd\n+do i = 1, 5\n+end do\n+!$omp end target teams distribute parallel do simd nowait\n+\n+!$omp target simd\n+do i = 1, 5\n+end do\n+!$omp end target simd nowait\n+\n+!$omp target teams\n+!$omp end target teams nowait\n+\n+!$omp target teams distribute\n+do i = 1, 5\n+end do\n+!$omp end target teams distribute nowait\n+\n+!$omp target teams distribute simd\n+do i = 1, 5\n+end do\n+!$omp end target teams distribute simd nowait\n+\n+!$omp target teams loop\n+do i = 1, 5\n+end do\n+!$omp end target teams loop nowait\n+\n+!$omp workshare\n+A(:) = 5\n+!$omp end workshare nowait\n+end\n+\n+! Note: internally, for '... parallel do ...', 'nowait' is always added\n+! such that for 'omp end target parallel do nowait', 'nowait' is on both\n+! 'target' as specified in the OpenMP spec and and on 'do' due to internal usage.\n+\n+! Expected with 'nowait'\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp for nowait\" 6 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp for schedule\\\\(static\\\\) nowait\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp sections nowait\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp single nowait\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp target nowait\" 12 \"original\" } }\n+\n+! Never:\n+\n+! { dg-final { scan-tree-dump-not \"#pragma omp distribute\\[^\\n\\r]*nowait\" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"#pragma omp loop\\[^\\n\\r]*nowait\" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"#pragma omp parallel\\[^\\n\\r]*nowait\" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"#pragma omp section\\[^s\\]\\[^\\n\\r]*nowait\" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"#pragma omp simd\\[^\\n\\r]*nowait\" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"#pragma omp teams\\[^\\n\\r]*nowait\" \"original\" } }\n+\n+! Sometimes or never with nowait:\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp distribute\\[\\n\\r]\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp loop\\[\\n\\r]\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp parallel\\[\\n\\r]\" 6 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp section\\[\\n\\r]\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp simd linear\\\\(i:1\\\\)\\[\\n\\r]\" 5 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp teams\\[\\n\\r]\" 6 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp target\\[\\n\\r]\" 0 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp for\\[\\n\\r]\" 0 \"original\" } }"}, {"sha": "70f54f9be5e584377c779af3660fab1bbeed7981", "filename": "gcc/testsuite/gfortran.dg/gomp/unexpected-end.f90", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Funexpected-end.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Funexpected-end.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Funexpected-end.f90?ref=48c6cac9caea1dc7c5f50ad3a736f6693e74a11b", "patch": "@@ -16,12 +16,12 @@\n \n !$omp end DO SIMD  ! { dg-error \"Unexpected !.OMP END DO SIMD\" }\n \n-!$omp end LOOP  ! { dg-error \"Unclassifiable OpenMP directive\" }\n+!$omp end LOOP  ! { dg-error \"Unexpected !.OMP END LOOP\" }\n \n !$omp parallel loop\n do i = 1, 5\n end do\n-!$omp end LOOP  ! { dg-error \"Unclassifiable OpenMP directive\" }\n+!$omp end LOOP  ! { dg-error \"Unexpected !.OMP END LOOP\" }\n \n !$omp end MASKED  ! { dg-error \"Unexpected !.OMP END MASKED\" }\n \n@@ -44,7 +44,7 @@\n !$omp end PARALLEL DO SIMD  ! { dg-error \"Unexpected !.OMP END PARALLEL DO SIMD\" }\n \n !$omp loop\n-!$omp end PARALLEL LOOP  ! { dg-error \"Unexpected junk\" }\n+!$omp end PARALLEL LOOP  ! { dg-error \"Unexpected !.OMP END PARALLEL LOOP\" }\n \n !$omp end PARALLEL MASKED  ! { dg-error \"Unexpected !.OMP END PARALLEL MASKED\" }\n \n@@ -80,7 +80,7 @@\n \n !$omp end TARGET PARALLEL DO SIMD  ! { dg-error \"Unexpected !.OMP END TARGET PARALLEL DO SIMD\" }\n \n-!$omp end TARGET PARALLEL LOOP  ! { dg-error \"Unexpected junk\" }\n+!$omp end TARGET PARALLEL LOOP  ! { dg-error \"Unexpected !.OMP END TARGET PARALLEL LOOP\" }\n \n !$omp end TARGET SIMD  ! { dg-error \"Unexpected !.OMP END TARGET SIMD\" }\n \n@@ -94,7 +94,7 @@\n \n !$omp end TARGET TEAMS DISTRIBUTE SIMD  ! { dg-error \"Unexpected !.OMP END TARGET TEAMS DISTRIBUTE SIMD\" }\n \n-!$omp end TARGET TEAMS LOOP  ! { dg-error \"Unexpected junk\" }\n+!$omp end TARGET TEAMS LOOP  ! { dg-error \"Unexpected !.OMP END TARGET TEAMS LOOP\" }\n \n !$omp end TASK  ! { dg-error \"Unexpected !.OMP END TASK\" }\n \n@@ -114,7 +114,7 @@\n \n !$omp end TEAMS DISTRIBUTE SIMD  ! { dg-error \"Unexpected !.OMP END TEAMS DISTRIBUTE SIMD\" }\n \n-!$omp end TEAMS LOOP  ! { dg-error \"Unexpected junk\" }\n+!$omp end TEAMS LOOP  ! { dg-error \"Unexpected !.OMP END TEAMS LOOP\" }\n \n !$omp end WORKSHARE  ! { dg-error \"Unexpected !.OMP END WORKSHARE\" }\n "}]}