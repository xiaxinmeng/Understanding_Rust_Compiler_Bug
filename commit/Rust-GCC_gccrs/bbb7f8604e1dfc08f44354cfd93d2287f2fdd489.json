{"sha": "bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "node_id": "C_kwDOANBUbNoAKGJiYjdmODYwNGUxZGZjMDhmNDQzNTRjZmQ5M2QyMjg3ZjJmZGQ0ODk", "commit": {"author": {"name": "Marcel Vollweiler", "email": "marcel@codesourcery.com", "date": "2022-02-10T07:47:12Z"}, "committer": {"name": "Marcel Vollweiler", "email": "marcel@codesourcery.com", "date": "2022-02-10T07:47:12Z"}, "message": "C, C++, Fortran, OpenMP: Add 'has_device_addr' clause to 'target' construct.\n\nThis patch adds the 'has_device_addr' clause to the OpenMP 'target' construct\nwhich was introduced in OpenMP 5.1 (OpenMP API 5.1 specification pp. 197ff):\n\n\thas_device_addr(list)\n\n\"The has_device_addr clause indicates that its list items already have device\naddresses and therefore they may be directly accessed from a target device.\nIf the device address of a list item is not for the device on which the target\nregion executes, accessing the list item inside the region results in\nunspecified behavior. The list items may include array sections.\" (p. 200)\n\n\"A list item may not be specified in both an is_device_ptr clause and a\nhas_device_addr clause on the directive.\" (p. 202)\n\n\"A list item that appears in an is_device_ptr or a has_device_addr clause must\nnot be specified in any data-sharing attribute clause on the same target\nconstruct.\" (p. 203)\n\ngcc/c-family/ChangeLog:\n\n\t* c-omp.cc (c_omp_split_clauses): Added OMP_CLAUSE_HAS_DEVICE_ADDR case.\n\t* c-pragma.h (enum pragma_kind): Added 5.1 in comment.\n\t(enum pragma_omp_clause): Added PRAGMA_OMP_CLAUSE_HAS_DEVICE_ADDR.\n\ngcc/c/ChangeLog:\n\n\t* c-parser.cc (c_parser_omp_clause_name): Parse 'has_device_addr'\n\tclause.\n\t(c_parser_omp_variable_list): Handle array sections.\n\t(c_parser_omp_clause_has_device_addr): Added.\n\t(c_parser_omp_all_clauses): Added PRAGMA_OMP_CLAUSE_HAS_DEVICE_ADDR\n\tcase.\n\t(c_parser_omp_target_exit_data): Added HAS_DEVICE_ADDR to\n\tOMP_CLAUSE_MASK.\n\t* c-typeck.cc (handle_omp_array_sections): Handle clause restrictions.\n\t(c_finish_omp_clauses): Handle array sections.\n\ngcc/cp/ChangeLog:\n\n\t* parser.cc (cp_parser_omp_clause_name): Parse 'has_device_addr' clause.\n\t(cp_parser_omp_var_list_no_open): Handle array sections.\n\t(cp_parser_omp_all_clauses): Added PRAGMA_OMP_CLAUSE_HAS_DEVICE_ADDR\n\tcase.\n\t(cp_parser_omp_target_update): Added HAS_DEVICE_ADDR to OMP_CLAUSE_MASK.\n\t* semantics.cc (handle_omp_array_sections): Handle clause restrictions.\n\t(finish_omp_clauses): Handle array sections.\n\ngcc/fortran/ChangeLog:\n\n\t* dump-parse-tree.cc (show_omp_clauses): Added OMP_LIST_HAS_DEVICE_ADDR\n\tcase.\n\t* gfortran.h: Added OMP_LIST_HAS_DEVICE_ADDR.\n\t* openmp.cc (enum omp_mask2): Added OMP_CLAUSE_HAS_DEVICE_ADDR.\n\t(gfc_match_omp_clauses): Parse HAS_DEVICE_ADDR clause.\n\t(resolve_omp_clauses): Same.\n\t* trans-openmp.cc (gfc_trans_omp_variable_list): Added\n\tOMP_LIST_HAS_DEVICE_ADDR case.\n\t(gfc_trans_omp_clauses): Firstprivatize of array descriptors.\n\ngcc/ChangeLog:\n\n\t* gimplify.cc (gimplify_scan_omp_clauses): Added cases for\n\tOMP_CLAUSE_HAS_DEVICE_ADDR\n\tand handle array sections.\n\t(gimplify_adjust_omp_clauses): Added OMP_CLAUSE_HAS_DEVICE_ADDR case.\n\t* omp-low.cc (scan_sharing_clauses): Handle OMP_CLAUSE_HAS_DEVICE_ADDR.\n\t(lower_omp_target): Same.\n\t* tree-core.h (enum omp_clause_code): Same.\n\t* tree-nested.cc (convert_nonlocal_omp_clauses): Same.\n\t(convert_local_omp_clauses): Same.\n\t* tree-pretty-print.cc (dump_omp_clause): Same.\n\t* tree.cc: Same.\n\nlibgomp/ChangeLog:\n\n\t* libgomp.texi: Updated entry for HAS_DEVICE_ADDR.\n\t* target.c (copy_firstprivate_data): Copy only if host address is not\n\tNULL.\n\t* testsuite/libgomp.c++/target-has-device-addr-2.C: New test.\n\t* testsuite/libgomp.c++/target-has-device-addr-4.C: New test.\n\t* testsuite/libgomp.c++/target-has-device-addr-5.C: New test.\n\t* testsuite/libgomp.c++/target-has-device-addr-6.C: New test.\n\t* testsuite/libgomp.c-c++-common/target-has-device-addr-1.c: New test.\n\t* testsuite/libgomp.c/target-has-device-addr-3.c: New test.\n\t* testsuite/libgomp.fortran/target-has-device-addr-1.f90: New test.\n\t* testsuite/libgomp.fortran/target-has-device-addr-2.f90: New test.\n\t* testsuite/libgomp.fortran/target-has-device-addr-3.f90: New test.\n\t* testsuite/libgomp.fortran/target-has-device-addr-4.f90: New test.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/gomp/clauses-1.c: Added has_device_addr to test cases.\n\t* g++.dg/gomp/attrs-1.C: Added has_device_addr to test cases.\n\t* g++.dg/gomp/attrs-2.C: Added has_device_addr to test cases.\n\t* c-c++-common/gomp/target-has-device-addr-1.c: New test.\n\t* c-c++-common/gomp/target-has-device-addr-2.c: New test.\n\t* c-c++-common/gomp/target-is-device-ptr-1.c: New test.\n\t* c-c++-common/gomp/target-is-device-ptr-2.c: New test.\n\t* gfortran.dg/gomp/is_device_ptr-3.f90: New test.\n\t* gfortran.dg/gomp/target-has-device-addr-1.f90: New test.\n\t* gfortran.dg/gomp/target-has-device-addr-2.f90: New test.", "tree": {"sha": "f26e68d3d60995cd92577d019d66d65571f52c50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f26e68d3d60995cd92577d019d66d65571f52c50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/comments", "author": null, "committer": null, "parents": [{"sha": "ba125745d9e9fe90a18a2af8701b3269c5fdd468", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba125745d9e9fe90a18a2af8701b3269c5fdd468", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba125745d9e9fe90a18a2af8701b3269c5fdd468"}], "stats": {"total": 1043, "additions": 961, "deletions": 82}, "files": [{"sha": "f5314d66f27e181c88840e55a8dc85dec6a1b854", "filename": "gcc/c-family/c-omp.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fc-family%2Fc-omp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fc-family%2Fc-omp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.cc?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -1862,6 +1862,7 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \tcase OMP_CLAUSE_DEVICE:\n \tcase OMP_CLAUSE_MAP:\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n+\tcase OMP_CLAUSE_HAS_DEVICE_ADDR:\n \tcase OMP_CLAUSE_DEFAULTMAP:\n \tcase OMP_CLAUSE_DEPEND:\n \t  s = C_OMP_CLAUSE_SPLIT_TARGET;"}, {"sha": "54864c2ec41217a7431e176d1a333040201a82c4", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -89,8 +89,8 @@ enum pragma_kind {\n };\n \n \n-/* All clauses defined by OpenACC 2.0, and OpenMP 2.5, 3.0, 3.1, 4.0, 4.5\n-   and 5.0.  Used internally by both C and C++ parsers.  */\n+/* All clauses defined by OpenACC 2.0, and OpenMP 2.5, 3.0, 3.1, 4.0, 4.5, 5.0,\n+   and 5.1.  Used internally by both C and C++ parsers.  */\n enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_NONE = 0,\n \n@@ -114,6 +114,7 @@ enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_FOR,\n   PRAGMA_OMP_CLAUSE_FROM,\n   PRAGMA_OMP_CLAUSE_GRAINSIZE,\n+  PRAGMA_OMP_CLAUSE_HAS_DEVICE_ADDR,\n   PRAGMA_OMP_CLAUSE_HINT,\n   PRAGMA_OMP_CLAUSE_IF,\n   PRAGMA_OMP_CLAUSE_IN_REDUCTION,"}, {"sha": "3b1d2d45addeae707ce21166cbc7127c712be23b", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -12771,7 +12771,9 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_GRAINSIZE;\n \t  break;\n \tcase 'h':\n-\t  if (!strcmp (\"hint\", p))\n+\t  if (!strcmp (\"has_device_addr\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_HAS_DEVICE_ADDR;\n+\t  else if (!strcmp (\"hint\", p))\n \t    result = PRAGMA_OMP_CLAUSE_HINT;\n \t  else if (!strcmp (\"host\", p))\n \t    result = PRAGMA_OACC_CLAUSE_HOST;\n@@ -13164,6 +13166,7 @@ c_parser_omp_variable_list (c_parser *parser,\n \t    case OMP_CLAUSE_REDUCTION:\n \t    case OMP_CLAUSE_IN_REDUCTION:\n \t    case OMP_CLAUSE_TASK_REDUCTION:\n+\t    case OMP_CLAUSE_HAS_DEVICE_ADDR:\n \t      array_section_p = false;\n \t      dims.truncate (0);\n \t      while (c_parser_next_token_is (parser, CPP_OPEN_SQUARE))\n@@ -14324,6 +14327,16 @@ c_parser_omp_clause_use_device_addr (c_parser *parser, tree list)\n \t\t\t\t       list);\n }\n \n+/* OpenMP 5.1:\n+   has_device_addr ( variable-list ) */\n+\n+static tree\n+c_parser_omp_clause_has_device_addr (c_parser *parser, tree list)\n+{\n+  return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_HAS_DEVICE_ADDR,\n+\t\t\t\t       list);\n+}\n+\n /* OpenMP 4.5:\n    is_device_ptr ( variable-list ) */\n \n@@ -17052,6 +17065,10 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  clauses = c_parser_omp_clause_use_device_addr (parser, clauses);\n \t  c_name = \"use_device_addr\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_HAS_DEVICE_ADDR:\n+\t  clauses = c_parser_omp_clause_has_device_addr (parser, clauses);\n+\t  c_name = \"has_device_addr\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR:\n \t  clauses = c_parser_omp_clause_is_device_ptr (parser, clauses);\n \t  c_name = \"is_device_ptr\";\n@@ -21034,7 +21051,8 @@ c_parser_omp_target_exit_data (location_t loc, c_parser *parser,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEFAULTMAP)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_THREAD_LIMIT)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR)\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_HAS_DEVICE_ADDR))\n \n static bool\n c_parser_omp_target (c_parser *parser, enum pragma_context context, bool *if_p)"}, {"sha": "3075c8835483251180977efad27a16881986addb", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -13804,6 +13804,8 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t}\n       first = c_fully_fold (first, false, NULL);\n       OMP_CLAUSE_DECL (c) = first;\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR)\n+\treturn false;\n       if (size)\n \tsize = c_fully_fold (size, false, NULL);\n       OMP_CLAUSE_SIZE (c) = size;\n@@ -14109,7 +14111,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n {\n   bitmap_head generic_head, firstprivate_head, lastprivate_head;\n   bitmap_head aligned_head, map_head, map_field_head, map_firstprivate_head;\n-  bitmap_head oacc_reduction_head;\n+  bitmap_head oacc_reduction_head, is_on_device_head;\n   tree c, t, type, *pc;\n   tree simdlen = NULL_TREE, safelen = NULL_TREE;\n   bool branch_seen = false;\n@@ -14145,6 +14147,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n   /* If ort == C_ORT_OMP used as nontemporal_head or use_device_xxx_head\n      instead and for ort == C_ORT_OMP_TARGET used as in_reduction_head.  */\n   bitmap_initialize (&oacc_reduction_head, &bitmap_default_obstack);\n+  bitmap_initialize (&is_on_device_head, &bitmap_default_obstack);\n \n   if (ort & C_ORT_ACC)\n     for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n@@ -14573,7 +14576,9 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t\"%qE appears more than once in data clauses\", t);\n \t      remove = true;\n \t    }\n-\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n+\t  else if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n+\t\t    || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR\n+\t\t    || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IS_DEVICE_PTR)\n \t\t   && bitmap_bit_p (&map_head, DECL_UID (t)))\n \t    {\n \t      if (ort == C_ORT_ACC)\n@@ -15187,7 +15192,8 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t\"%qD appears more than once in data clauses\", t);\n \t      remove = true;\n \t    }\n-\t  else if (bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n+\t  else if (bitmap_bit_p (&firstprivate_head, DECL_UID (t))\n+\t\t   || bitmap_bit_p (&is_on_device_head, DECL_UID (t)))\n \t    {\n \t      if (ort == C_ORT_ACC)\n \t\terror_at (OMP_CLAUSE_LOCATION (c),\n@@ -15272,6 +15278,8 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \t  t = OMP_CLAUSE_DECL (c);\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IS_DEVICE_PTR)\n+\t    bitmap_set_bit (&is_on_device_head, DECL_UID (t));\n \t  if (TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE)\n \t    {\n \t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_PTR\n@@ -15292,6 +15300,24 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  goto check_dup_generic;\n \n+\tcase OMP_CLAUSE_HAS_DEVICE_ADDR:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) == TREE_LIST)\n+\t    {\n+\t      if (handle_omp_array_sections (c, ort))\n+\t\tremove = true;\n+\t      else\n+\t\t{\n+\t\t  t = OMP_CLAUSE_DECL (c);\n+\t\t  while (TREE_CODE (t) == ARRAY_REF)\n+\t\t    t = TREE_OPERAND (t, 0);\n+\t\t}\n+\t    }\n+\t  bitmap_set_bit (&is_on_device_head, DECL_UID (t));\n+\t  if (VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n+\t    c_mark_addressable (t);\n+\t  goto check_dup_generic_t;\n+\n \tcase OMP_CLAUSE_USE_DEVICE_ADDR:\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (VAR_P (t) || TREE_CODE (t) == PARM_DECL)"}, {"sha": "03d99aba13e3c06241ff5c7e54ef3d0100a7fac2", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -36341,7 +36341,9 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_GRAINSIZE;\n \t  break;\n \tcase 'h':\n-\t  if (!strcmp (\"hint\", p))\n+\t  if (!strcmp (\"has_device_addr\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_HAS_DEVICE_ADDR;\n+\t  else if (!strcmp (\"hint\", p))\n \t    result = PRAGMA_OMP_CLAUSE_HINT;\n \t  else if (!strcmp (\"host\", p))\n \t    result = PRAGMA_OACC_CLAUSE_HOST;\n@@ -36644,6 +36646,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t    case OMP_CLAUSE_REDUCTION:\n \t    case OMP_CLAUSE_IN_REDUCTION:\n \t    case OMP_CLAUSE_TASK_REDUCTION:\n+\t    case OMP_CLAUSE_HAS_DEVICE_ADDR:\n \t      array_section_p = false;\n \t      dims.truncate (0);\n \t      while (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_SQUARE))\n@@ -40085,6 +40088,11 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t\t\t\t\t    clauses);\n \t  c_name = \"is_device_ptr\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_HAS_DEVICE_ADDR:\n+\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_HAS_DEVICE_ADDR,\n+\t\t\t\t\t    clauses);\n+\t  c_name = \"has_device_addr\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_IF:\n \t  clauses = cp_parser_omp_clause_if (parser, clauses, token->location,\n \t\t\t\t\t     true);\n@@ -44265,7 +44273,8 @@ cp_parser_omp_target_update (cp_parser *parser, cp_token *pragma_tok,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_THREAD_LIMIT)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR)\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_HAS_DEVICE_ADDR))\n \n static bool\n cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,"}, {"sha": "0cb17a6a8ab1c5c2cd7a29b13ecdc74bcc0dd4f6", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -5648,6 +5648,8 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t      return false;\n \t    }\n \t  OMP_CLAUSE_DECL (c) = first;\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR)\n+\t    return false;\n \t  OMP_CLAUSE_SIZE (c) = size;\n \t  if (TREE_CODE (t) == FIELD_DECL)\n \t    t = finish_non_static_data_member (t, NULL_TREE, NULL_TREE);\n@@ -6677,7 +6679,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n {\n   bitmap_head generic_head, firstprivate_head, lastprivate_head;\n   bitmap_head aligned_head, map_head, map_field_head, map_firstprivate_head;\n-  bitmap_head oacc_reduction_head;\n+  bitmap_head oacc_reduction_head, is_on_device_head;\n   tree c, t, *pc;\n   tree safelen = NULL_TREE;\n   bool branch_seen = false;\n@@ -6710,6 +6712,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n   /* If ort == C_ORT_OMP used as nontemporal_head or use_device_xxx_head\n      instead and for ort == C_ORT_OMP_TARGET used as in_reduction_head.  */\n   bitmap_initialize (&oacc_reduction_head, &bitmap_default_obstack);\n+  bitmap_initialize (&is_on_device_head, &bitmap_default_obstack);\n \n   if (ort & C_ORT_ACC)\n     for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n@@ -7008,7 +7011,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t\"%qD appears more than once in data clauses\", t);\n \t      remove = true;\n \t    }\n-\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n+\t  else if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n+\t\t    || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR\n+\t\t    || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IS_DEVICE_PTR)\n \t\t   && bitmap_bit_p (&map_head, DECL_UID (t)))\n \t    {\n \t      if (ort == C_ORT_ACC)\n@@ -8232,7 +8237,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t\"%qD appears more than once in data clauses\", t);\n \t      remove = true;\n \t    }\n-\t  else if (bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n+\t  else if (bitmap_bit_p (&firstprivate_head, DECL_UID (t))\n+\t\t   || bitmap_bit_p (&is_on_device_head, DECL_UID (t)))\n \t    {\n \t      if (ort == C_ORT_ACC)\n \t\terror_at (OMP_CLAUSE_LOCATION (c),\n@@ -8491,6 +8497,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \t  field_ok = (ort & C_ORT_OMP_DECLARE_SIMD) == C_ORT_OMP;\n \t  t = OMP_CLAUSE_DECL (c);\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IS_DEVICE_PTR)\n+\t    bitmap_set_bit (&is_on_device_head, DECL_UID (t));\n \t  if (!type_dependent_expression_p (t))\n \t    {\n \t      tree type = TREE_TYPE (t);\n@@ -8520,6 +8528,25 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  goto check_dup_generic;\n \n+\tcase OMP_CLAUSE_HAS_DEVICE_ADDR:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) == TREE_LIST)\n+\t    {\n+\t      if (handle_omp_array_sections (c, ort))\n+\t\tremove = true;\n+\t      else\n+\t\t{\n+\t\t  t = OMP_CLAUSE_DECL (c);\n+\t\t  while (TREE_CODE (t) == INDIRECT_REF\n+\t\t\t || TREE_CODE (t) == ARRAY_REF)\n+\t\t    t = TREE_OPERAND (t, 0);\n+\t\t}\n+\t    }\n+\t  bitmap_set_bit (&is_on_device_head, DECL_UID (t));\n+\t  if (VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n+\t    cxx_mark_addressable (t);\n+\t  goto check_dup_generic_t;\n+\n \tcase OMP_CLAUSE_USE_DEVICE_ADDR:\n \t  field_ok = true;\n \t  t = OMP_CLAUSE_DECL (c);"}, {"sha": "2a2f9901b085ee9a2f8439b1ce3701f47a4a9ae2", "filename": "gcc/fortran/dump-parse-tree.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ffortran%2Fdump-parse-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ffortran%2Fdump-parse-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.cc?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -1683,6 +1683,7 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n \t  case OMP_LIST_CACHE: type = \"CACHE\"; break;\n \t  case OMP_LIST_IS_DEVICE_PTR: type = \"IS_DEVICE_PTR\"; break;\n \t  case OMP_LIST_USE_DEVICE_PTR: type = \"USE_DEVICE_PTR\"; break;\n+\t  case OMP_LIST_HAS_DEVICE_ADDR: type = \"HAS_DEVICE_ADDR\"; break;\n \t  case OMP_LIST_USE_DEVICE_ADDR: type = \"USE_DEVICE_ADDR\"; break;\n \t  case OMP_LIST_NONTEMPORAL: type = \"NONTEMPORAL\"; break;\n \t  case OMP_LIST_ALLOCATE: type = \"ALLOCATE\"; break;"}, {"sha": "cb136f875f4a8a8596d7bca8c6a9bcd01ef873fd", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -1393,7 +1393,8 @@ enum\n   OMP_LIST_USE_DEVICE_ADDR,\n   OMP_LIST_NONTEMPORAL,\n   OMP_LIST_ALLOCATE,\n-  OMP_LIST_NUM\n+  OMP_LIST_HAS_DEVICE_ADDR,\n+  OMP_LIST_NUM /* Must be the last.  */\n };\n \n /* Because a symbol can belong to multiple namelists, they must be"}, {"sha": "33b372f3430624b88cff5a37ef83ac49010513a0", "filename": "gcc/fortran/openmp.cc", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ffortran%2Fopenmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ffortran%2Fopenmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.cc?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -926,7 +926,7 @@ enum omp_mask1\n   OMP_MASK1_LAST\n };\n \n-/* OpenACC 2.0+ specific clauses. */\n+/* More OpenMP clauses and OpenACC 2.0+ specific clauses. */\n enum omp_mask2\n {\n   OMP_CLAUSE_ASYNC,\n@@ -955,6 +955,7 @@ enum omp_mask2\n   OMP_CLAUSE_FINALIZE,\n   OMP_CLAUSE_ATTACH,\n   OMP_CLAUSE_NOHOST,\n+  OMP_CLAUSE_HAS_DEVICE_ADDR,  /* OpenMP 5.1  */\n   /* This must come last.  */\n   OMP_MASK2_LAST\n };\n@@ -2151,6 +2152,11 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t    }\n \t  break;\n \tcase 'h':\n+\t  if ((mask & OMP_CLAUSE_HAS_DEVICE_ADDR)\n+\t      && gfc_match_omp_variable_list\n+\t\t   (\"has_device_addr (\", &c->lists[OMP_LIST_HAS_DEVICE_ADDR],\n+\t\t    false, NULL, NULL, true) == MATCH_YES)\n+\t    continue;\n \t  if ((mask & OMP_CLAUSE_HINT)\n \t      && (m = gfc_match_dupl_check (!c->hint, \"hint\", true, &c->hint))\n \t\t != MATCH_NO)\n@@ -2923,8 +2929,8 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_USE_DEVICE_ADDR)\n \t      && gfc_match_omp_variable_list\n-\t\t   (\"use_device_addr (\",\n-\t\t    &c->lists[OMP_LIST_USE_DEVICE_ADDR], false) == MATCH_YES)\n+\t\t   (\"use_device_addr (\", &c->lists[OMP_LIST_USE_DEVICE_ADDR],\n+\t\t    false, NULL, NULL, true) == MATCH_YES)\n \t    continue;\n \t  break;\n \tcase 'v':\n@@ -3651,7 +3657,8 @@ gfc_match_oacc_routine (void)\n    | OMP_CLAUSE_DEPEND | OMP_CLAUSE_NOWAIT | OMP_CLAUSE_PRIVATE\t\t\\\n    | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_DEFAULTMAP\t\t\t\\\n    | OMP_CLAUSE_IS_DEVICE_PTR | OMP_CLAUSE_IN_REDUCTION\t\t\t\\\n-   | OMP_CLAUSE_THREAD_LIMIT | OMP_CLAUSE_ALLOCATE)\n+   | OMP_CLAUSE_THREAD_LIMIT | OMP_CLAUSE_ALLOCATE\t\t\t\\\n+   | OMP_CLAUSE_HAS_DEVICE_ADDR)\n #define OMP_TARGET_DATA_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_DEVICE) | OMP_CLAUSE_MAP | OMP_CLAUSE_IF\t\\\n    | OMP_CLAUSE_USE_DEVICE_PTR | OMP_CLAUSE_USE_DEVICE_ADDR)\n@@ -6283,7 +6290,7 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\"IN_REDUCTION\", \"TASK_REDUCTION\",\n \t\"DEVICE_RESIDENT\", \"LINK\", \"USE_DEVICE\",\n \t\"CACHE\", \"IS_DEVICE_PTR\", \"USE_DEVICE_PTR\", \"USE_DEVICE_ADDR\",\n-\t\"NONTEMPORAL\", \"ALLOCATE\" };\n+\t\"NONTEMPORAL\", \"ALLOCATE\", \"HAS_DEVICE_ADDR\" };\n   STATIC_ASSERT (ARRAY_SIZE (clause_names) == OMP_LIST_NUM);\n \n   if (omp_clauses == NULL)\n@@ -7132,6 +7139,7 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t\t     n->sym->name, name, &n->where);\n \t      }\n \t    break;\n+\t  case OMP_LIST_HAS_DEVICE_ADDR:\n \t  case OMP_LIST_USE_DEVICE_PTR:\n \t  case OMP_LIST_USE_DEVICE_ADDR:\n \t    /* FIXME: Handle OMP_LIST_USE_DEVICE_PTR.  */"}, {"sha": "0eba0b3c3e1971afd0cf1f33a8b1ec87d03b0317", "filename": "gcc/fortran/trans-openmp.cc", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ffortran%2Ftrans-openmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ffortran%2Ftrans-openmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.cc?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -1910,7 +1910,17 @@ gfc_trans_omp_variable_list (enum omp_clause_code code,\n \ttree t = gfc_trans_omp_variable (namelist->sym, declare_simd);\n \tif (t != error_mark_node)\n \t  {\n-\t    tree node = build_omp_clause (input_location, code);\n+\t    tree node;\n+\t    /* For HAS_DEVICE_ADDR of an array descriptor, firstprivatize the\n+\t       descriptor such that the bounds are available; its data component\n+\t       is unmodified; it is handled as device address inside target. */\n+\t    if (code == OMP_CLAUSE_HAS_DEVICE_ADDR\n+\t\t&& (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (t))\n+\t\t    || (POINTER_TYPE_P (TREE_TYPE (t))\n+\t\t\t&& GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (t))))))\n+\t      node = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n+\t    else\n+\t      node = build_omp_clause (input_location, code);\n \t    OMP_CLAUSE_DECL (node) = t;\n \t    list = gfc_trans_add_clause (node, list);\n \n@@ -2604,6 +2614,9 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \tcase OMP_LIST_IS_DEVICE_PTR:\n \t  clause_code = OMP_CLAUSE_IS_DEVICE_PTR;\n \t  goto add_clause;\n+\tcase OMP_LIST_HAS_DEVICE_ADDR:\n+\t  clause_code = OMP_CLAUSE_HAS_DEVICE_ADDR;\n+\t  goto add_clause;\n \tcase OMP_LIST_NONTEMPORAL:\n \t  clause_code = OMP_CLAUSE_NONTEMPORAL;\n \t  goto add_clause;"}, {"sha": "8d676fb96c898aa7bbbaa4a46d50894766b6685d", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -10278,6 +10278,14 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  flags = GOVD_EXPLICIT;\n \t  goto do_add;\n \n+\tcase OMP_CLAUSE_HAS_DEVICE_ADDR:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  while (TREE_CODE (decl) == INDIRECT_REF\n+\t\t || TREE_CODE (decl) == ARRAY_REF)\n+\t    decl = TREE_OPERAND (decl, 0);\n+\t  flags = GOVD_EXPLICIT;\n+\t  goto do_add_decl;\n+\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \t  flags = GOVD_FIRSTPRIVATE | GOVD_EXPLICIT;\n \t  goto do_add;\n@@ -11428,6 +11436,16 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \t    }\n \t  break;\n \n+\tcase OMP_CLAUSE_HAS_DEVICE_ADDR:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  while (TREE_CODE (decl) == INDIRECT_REF\n+\t\t || TREE_CODE (decl) == ARRAY_REF)\n+\t    decl = TREE_OPERAND (decl, 0);\n+\t  n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n+\t  remove = n == NULL || !(n->value & GOVD_SEEN);\n+\t  break;\n+\n+\tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \tcase OMP_CLAUSE_NONTEMPORAL:\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n@@ -11729,7 +11747,6 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \tcase OMP_CLAUSE_DETACH:\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \tcase OMP_CLAUSE_USE_DEVICE_ADDR:\n-\tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \tcase OMP_CLAUSE_ASYNC:\n \tcase OMP_CLAUSE_WAIT:\n \tcase OMP_CLAUSE_INDEPENDENT:"}, {"sha": "065208464b2c3c6c00c177bd2c357057e35eb1e3", "filename": "gcc/omp-low.cc", "status": "modified", "additions": 67, "deletions": 12, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fomp-low.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Fomp-low.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.cc?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -1375,16 +1375,23 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  decl = OMP_CLAUSE_DECL (c);\n \tdo_private:\n \t  if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n-\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IS_DEVICE_PTR)\n+\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IS_DEVICE_PTR\n+\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR)\n \t      && is_gimple_omp_offloaded (ctx->stmt))\n \t    {\n \t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE)\n \t\t{\n \t\t  by_ref = !omp_privatize_by_reference (decl);\n \t\t  install_var_field (decl, by_ref, 3, ctx);\n \t\t}\n+\t      else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR)\n+\t\t{\n+\t\t  if (TREE_CODE (decl) == INDIRECT_REF)\n+\t\t    decl = TREE_OPERAND (decl, 0);\n+\t\t  install_var_field (decl, true, 3, ctx);\n+\t\t}\n \t      else if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n-\t\tinstall_var_field (decl, true, 3, ctx);\n+\t\t  install_var_field (decl, true, 3, ctx);\n \t      else\n \t\tinstall_var_field (decl, false, 3, ctx);\n \t    }\n@@ -1452,6 +1459,13 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  install_var_local (decl, ctx);\n \t  break;\n \n+\tcase OMP_CLAUSE_HAS_DEVICE_ADDR:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  while (TREE_CODE (decl) == INDIRECT_REF\n+\t\t || TREE_CODE (decl) == ARRAY_REF)\n+\t    decl = TREE_OPERAND (decl, 0);\n+\t  goto do_private;\n+\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  goto do_private;\n@@ -1729,12 +1743,21 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n \tcase OMP_CLAUSE_PRIVATE:\n \tcase OMP_CLAUSE_LINEAR:\n+\tcase OMP_CLAUSE_HAS_DEVICE_ADDR:\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR)\n+\t    {\n+\t      while (TREE_CODE (decl) == INDIRECT_REF\n+\t\t     || TREE_CODE (decl) == ARRAY_REF)\n+\t\tdecl = TREE_OPERAND (decl, 0);\n+\t    }\n+\n \t  if (is_variable_sized (decl))\n \t    {\n \t      if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n-\t\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IS_DEVICE_PTR)\n+\t\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IS_DEVICE_PTR\n+\t\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR)\n \t\t  && is_gimple_omp_offloaded (ctx->stmt))\n \t\t{\n \t\t  tree decl2 = DECL_VALUE_EXPR (decl);\n@@ -12819,8 +12842,15 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n       case OMP_CLAUSE_USE_DEVICE_PTR:\n       case OMP_CLAUSE_USE_DEVICE_ADDR:\n+      case OMP_CLAUSE_HAS_DEVICE_ADDR:\n       case OMP_CLAUSE_IS_DEVICE_PTR:\n \tvar = OMP_CLAUSE_DECL (c);\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR)\n+\t  {\n+\t    while (TREE_CODE (var) == INDIRECT_REF\n+\t\t   || TREE_CODE (var) == ARRAY_REF)\n+\t      var = TREE_OPERAND (var, 0);\n+\t  }\n \tmap_cnt++;\n \tif (is_variable_sized (var))\n \t  {\n@@ -12835,7 +12865,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    SET_DECL_VALUE_EXPR (new_var, x);\n \t    DECL_HAS_VALUE_EXPR_P (new_var) = 1;\n \t  }\n-\telse if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n+\telse if (((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n+\t\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR)\n \t\t  && !omp_privatize_by_reference (var)\n \t\t  && !omp_is_allocatable_or_ptr (var)\n \t\t  && !lang_hooks.decls.omp_array_data (var, true))\n@@ -13301,17 +13332,26 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n \t  case OMP_CLAUSE_USE_DEVICE_PTR:\n \t  case OMP_CLAUSE_USE_DEVICE_ADDR:\n+\t  case OMP_CLAUSE_HAS_DEVICE_ADDR:\n \t  case OMP_CLAUSE_IS_DEVICE_PTR:\n \t    ovar = OMP_CLAUSE_DECL (c);\n+\t    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR)\n+\t      {\n+\t\twhile (TREE_CODE (ovar) == INDIRECT_REF\n+\t\t       || TREE_CODE (ovar) == ARRAY_REF)\n+\t\t  ovar = TREE_OPERAND (ovar, 0);\n+\t      }\n \t    var = lookup_decl_in_outer_ctx (ovar, ctx);\n \n \t    if (lang_hooks.decls.omp_array_data (ovar, true))\n \t      {\n-\t\ttkind = (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IS_DEVICE_PTR\n+\t\ttkind = ((OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IS_DEVICE_PTR\n+\t\t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_HAS_DEVICE_ADDR)\n \t\t\t ? GOMP_MAP_USE_DEVICE_PTR : GOMP_MAP_FIRSTPRIVATE_INT);\n \t\tx = build_sender_ref ((splay_tree_key) &DECL_NAME (ovar), ctx);\n \t      }\n-\t    else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IS_DEVICE_PTR)\n+\t    else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IS_DEVICE_PTR\n+\t\t     && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_HAS_DEVICE_ADDR)\n \t      {\n \t\ttkind = GOMP_MAP_USE_DEVICE_PTR;\n \t\tx = build_sender_ref ((splay_tree_key) &DECL_UID (ovar), ctx);\n@@ -13333,7 +13373,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    type = TREE_TYPE (ovar);\n \t    if (lang_hooks.decls.omp_array_data (ovar, true))\n \t      var = lang_hooks.decls.omp_array_data (ovar, false);\n-\t    else if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n+\t    else if (((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR)\n \t\t      && !omp_privatize_by_reference (ovar)\n \t\t      && !omp_is_allocatable_or_ptr (ovar))\n \t\t     || TREE_CODE (type) == ARRAY_TYPE)\n@@ -13348,6 +13389,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t    if (POINTER_TYPE_P (type)\n \t\t\t&& TREE_CODE (type) != ARRAY_TYPE\n \t\t\t&& ((OMP_CLAUSE_CODE (c) != OMP_CLAUSE_USE_DEVICE_ADDR\n+\t\t\t    && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_HAS_DEVICE_ADDR\n \t\t\t    && !omp_is_allocatable_or_ptr (ovar))\n \t\t\t   || (omp_privatize_by_reference (ovar)\n \t\t\t       && omp_is_allocatable_or_ptr (ovar))))\n@@ -13545,6 +13587,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    break;\n \t  case OMP_CLAUSE_USE_DEVICE_PTR:\n \t  case OMP_CLAUSE_USE_DEVICE_ADDR:\n+\t  case OMP_CLAUSE_HAS_DEVICE_ADDR:\n \t  case OMP_CLAUSE_IS_DEVICE_PTR:\n \t    tree new_var;\n \t    gimple_seq assign_body;\n@@ -13555,12 +13598,21 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    var = OMP_CLAUSE_DECL (c);\n \t    is_array_data = lang_hooks.decls.omp_array_data (var, true) != NULL;\n \n-\t    if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IS_DEVICE_PTR)\n+\t    if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IS_DEVICE_PTR\n+\t\t&& OMP_CLAUSE_CODE (c) != OMP_CLAUSE_HAS_DEVICE_ADDR)\n \t      x = build_sender_ref (is_array_data\n \t\t\t\t    ? (splay_tree_key) &DECL_NAME (var)\n \t\t\t\t    : (splay_tree_key) &DECL_UID (var), ctx);\n \t    else\n-\t      x = build_receiver_ref (var, false, ctx);\n+\t      {\n+\t\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR)\n+\t\t  {\n+\t\t    while (TREE_CODE (var) == INDIRECT_REF\n+\t\t\t   || TREE_CODE (var) == ARRAY_REF)\n+\t\t      var = TREE_OPERAND (var, 0);\n+\t\t  }\n+\t\tx = build_receiver_ref (var, false, ctx);\n+\t      }\n \n \t    if (is_array_data)\n \t      {\n@@ -13607,7 +13659,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\tgimple_seq_add_stmt (&assign_body,\n \t\t\t\t     gimple_build_assign (new_var, x));\n \t      }\n-\t    else if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n+\t    else if (((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR)\n \t\t      && !omp_privatize_by_reference (var)\n \t\t      && !omp_is_allocatable_or_ptr (var))\n \t\t     || TREE_CODE (TREE_TYPE (var)) == ARRAY_TYPE)\n@@ -13630,7 +13683,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t    type = TREE_TYPE (type);\n \t\t    if (POINTER_TYPE_P (type)\n \t\t\t&& TREE_CODE (type) != ARRAY_TYPE\n-\t\t\t&& (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_USE_DEVICE_ADDR\n+\t\t\t&& ((OMP_CLAUSE_CODE (c) != OMP_CLAUSE_USE_DEVICE_ADDR\n+\t\t\t    && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_HAS_DEVICE_ADDR)\n \t\t\t    || (omp_privatize_by_reference (var)\n \t\t\t\t&& omp_is_allocatable_or_ptr (var))))\n \t\t      {\n@@ -13653,7 +13707,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t\t     gimple_build_assign (new_var, x));\n \t      }\n \t    tree present;\n-\t    present = (do_optional_check\n+\t    present = ((do_optional_check\n+\t\t\t&& OMP_CLAUSE_CODE (c) != OMP_CLAUSE_HAS_DEVICE_ADDR)\n \t\t       ? omp_check_optional_argument (OMP_CLAUSE_DECL (c), true)\n \t\t       : NULL_TREE);\n \t    if (present)"}, {"sha": "71ca41c5804c4e64a601ca0f4efad1ac0430a436", "filename": "gcc/testsuite/c-c++-common/gomp/clauses-1.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -102,7 +102,7 @@ baz (int d, int m, int i1, int i2, int p, int *idp, int s,\n }\n \n void\n-bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n+bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int hda, int s,\n      int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int *dd, int ntm)\n {\n   #pragma omp for simd \\\n@@ -138,39 +138,40 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n   #pragma omp target parallel \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    nowait depend(inout: dd[0]) allocate (omp_default_mem_alloc:f) in_reduction(+:r2)\n+    nowait depend(inout: dd[0]) allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr(hda)\n     ;\n   #pragma omp target parallel for \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1) nowait depend(inout: dd[0]) \\\n-    allocate (omp_default_mem_alloc:f) in_reduction(+:r2)\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr(hda)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target parallel for \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) nowait depend(inout: dd[0]) order(concurrent) \\\n-    allocate (omp_default_mem_alloc:f) in_reduction(+:r2)\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr(hda)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target parallel for simd \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) \\\n     safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) if (simd: i3) order(concurrent) \\\n-    allocate (omp_default_mem_alloc:f) in_reduction(+:r2)\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr(hda)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target teams \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     shared(s) default(shared) reduction(+:r) num_teams(nte - 1:nte) thread_limit(tl) nowait depend(inout: dd[0]) \\\n-    allocate (omp_default_mem_alloc:f) in_reduction(+:r2)\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr(hda)\n     ;\n   #pragma omp target teams distribute \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) order(concurrent) \\\n-    collapse(1) dist_schedule(static, 16) nowait depend(inout: dd[0]) allocate (omp_default_mem_alloc:f) in_reduction(+:r2)\n+    collapse(1) dist_schedule(static, 16) nowait depend(inout: dd[0]) allocate (omp_default_mem_alloc:f) in_reduction(+:r2) \\\n+    has_device_addr(hda)\n   for (int i = 0; i < 64; i++)\n     ;\n   #pragma omp target teams distribute parallel for \\\n@@ -179,7 +180,7 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) schedule(static, 4) nowait depend(inout: dd[0]) order(concurrent) \\\n-     allocate (omp_default_mem_alloc:f) in_reduction(+:r2)\n+     allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr(hda)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target teams distribute parallel for simd \\\n@@ -189,22 +190,22 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) schedule(static, 4) order(concurrent) \\\n     safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) if (simd: i3) \\\n-    allocate (omp_default_mem_alloc:f) in_reduction(+:r2)\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr(hda)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target teams distribute simd \\\n     device(d) map (tofrom: m) if (i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) \\\n     collapse(1) dist_schedule(static, 16) order(concurrent) \\\n     safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) \\\n-    allocate (omp_default_mem_alloc:f) in_reduction(+:r2)\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr(hda)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target simd \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     safelen(8) simdlen(4) lastprivate (l) linear(ll: 1) aligned(q: 32) reduction(+:r) \\\n     nowait depend(inout: dd[0]) nontemporal(ntm) if(simd:i3) order(concurrent) \\\n-    allocate (omp_default_mem_alloc:f) in_reduction(+:r2)\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr(hda)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp taskgroup task_reduction(+:r2) allocate (r2)\n@@ -430,28 +431,28 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     nowait depend(inout: dd[0]) lastprivate (l) bind(parallel) order(concurrent) collapse(1) \\\n-    allocate (omp_default_mem_alloc: f) in_reduction(+:r2)\n+    allocate (omp_default_mem_alloc: f) in_reduction(+:r2) has_device_addr(hda)\n   for (l = 0; l < 64; ++l)\n     ;\n   #pragma omp target parallel loop \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     nowait depend(inout: dd[0]) lastprivate (l) order(concurrent) collapse(1) \\\n-    allocate (omp_default_mem_alloc: f) in_reduction(+:r2)\n+    allocate (omp_default_mem_alloc: f) in_reduction(+:r2) has_device_addr(hda)\n   for (l = 0; l < 64; ++l)\n     ;\n   #pragma omp target teams loop \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) nowait depend(inout: dd[0]) \\\n     lastprivate (l) bind(teams) collapse(1) \\\n-    allocate (omp_default_mem_alloc: f) in_reduction(+:r2)\n+    allocate (omp_default_mem_alloc: f) in_reduction(+:r2) has_device_addr(hda)\n   for (l = 0; l < 64; ++l)\n     ;\n   #pragma omp target teams loop \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) nowait depend(inout: dd[0]) \\\n     lastprivate (l) order(concurrent) collapse(1) \\\n-    allocate (omp_default_mem_alloc: f) in_reduction(+:r2)\n+    allocate (omp_default_mem_alloc: f) in_reduction(+:r2) has_device_addr(hda)\n   for (l = 0; l < 64; ++l)\n     ;\n }"}, {"sha": "ebf55eea70b6309ebd029cc6cdcbae00f0a4521b", "filename": "gcc/testsuite/c-c++-common/gomp/target-has-device-addr-1.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-has-device-addr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-has-device-addr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-has-device-addr-1.c?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do compile } */\n+\n+void\n+foo ()\n+{\n+  int * x;\n+  #pragma omp target is_device_ptr(x) has_device_addr(x) /*{ dg-error \"'x' appears more than once in data clauses\" } */\n+  ;\n+  #pragma omp target has_device_addr(x) is_device_ptr(x) /* { dg-error \"'x' appears more than once in data clauses\" } */\n+  ;\n+\n+  int y = 42;\n+  #pragma omp target has_device_addr(y) has_device_addr(y) /* { dg-error \"'y' appears more than once in data clauses\" } */\n+  ;\n+\n+  #pragma omp target private(y) has_device_addr(y) /*{ dg-error \"'y' appears more than once in data clauses\" } */\n+  ;\n+  #pragma omp target has_device_addr(y) private(y) /*{ dg-error \"'y' appears more than once in data clauses\" } */\n+  ;\n+  #pragma omp target firstprivate(y) has_device_addr(y) /*{ dg-error \"'y' appears more than once in data clauses\" } */\n+  ;\n+\n+  #pragma omp target has_device_addr(y) map(y) /* { dg-error \"'y' appears both in data and map clauses\" } */\n+  ;\n+  #pragma omp target map(y) has_device_addr(y) /* { dg-error \"'y' appears both in data and map clauses\" } */\n+  ;\n+\n+  int z[3] = { 2, 5, 7 };\n+  #pragma omp target data map(z[:3]) use_device_addr(z)\n+    #pragma omp target has_device_addr(z[1:])\n+    ;\n+\n+  #pragma omp target data map(z[:3]) use_device_addr(z)\n+    #pragma omp target has_device_addr(z[1])\n+    ;\n+\n+  #pragma omp target data map(z[:3]) use_device_addr(z)\n+    #pragma omp target has_device_addr(z[1:2])\n+    ;\n+\n+  #pragma omp target data map(z[:3]) use_device_addr(z)\n+    #pragma omp target has_device_addr(z[:2])\n+    ;\n+\n+  int w[3][4];\n+  #pragma omp target data map(w) use_device_addr(w)\n+    #pragma omp target has_device_addr(w[1][2])\n+    ;\n+\n+  #pragma omp target data map(w) use_device_addr(w)\n+    #pragma omp target has_device_addr(w[:1][2:])\n+    ;\n+\n+  int u[0];\n+  #pragma omp target data map(u) use_device_addr(u)\n+    #pragma omp target has_device_addr(u)\n+    ;\n+\n+  struct S { int m; } s;\n+  s.m = 42;\n+  #pragma omp target data map (s) use_device_addr (s)\n+    #pragma omp target has_device_addr (s)\n+      ++s.m;\n+\n+}"}, {"sha": "7378416964cb4a4427fa4c5439208d0ea2c44076", "filename": "gcc/testsuite/c-c++-common/gomp/target-has-device-addr-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-has-device-addr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-has-device-addr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-has-device-addr-2.c?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+void\n+foo ()\n+{\n+  int x, y;\n+\n+  #pragma omp target data map(x, y) use_device_addr(x, y)\n+    #pragma omp target has_device_addr(x, y)\n+      {\n+\tx = 42;\n+      }\n+}\n+\n+/* { dg-final { scan-tree-dump \"has_device_addr\\\\(x\\\\)\"  \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-not \"has_device_addr\\\\(y\\\\)\"  \"gimple\" } } */"}, {"sha": "ecf30ca65f7661766b0dfd8384fa42ca9ac3ef6c", "filename": "gcc/testsuite/c-c++-common/gomp/target-is-device-ptr-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-is-device-ptr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-is-device-ptr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-is-device-ptr-1.c?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+\n+void\n+foo ()\n+{\n+  int *x;\n+\n+  #pragma omp target is_device_ptr(x) is_device_ptr(x) /* { dg-error \"'x' appears more than once in data clauses\" } */\n+  ;\n+\n+  #pragma omp target private(x) is_device_ptr(x) /*{ dg-error \"'x' appears more than once in data clauses\" } */\n+  ;\n+  #pragma omp target is_device_ptr(x) private(x) /*{ dg-error \"'x' appears more than once in data clauses\" } */\n+  ;\n+  #pragma omp target firstprivate(x) is_device_ptr(x) /*{ dg-error \"'x' appears more than once in data clauses\" } */\n+  ;\n+\n+  #pragma omp target is_device_ptr(x) map(x) /* { dg-error \"'x' appears both in data and map clauses\" } */\n+  ;\n+  #pragma omp target map(x) is_device_ptr(x) /* { dg-error \"'x' appears both in data and map clauses\" } */\n+  ;\n+}"}, {"sha": "df743dda16631693515e4fd5e0841957dcc27a87", "filename": "gcc/testsuite/c-c++-common/gomp/target-is-device-ptr-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-is-device-ptr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-is-device-ptr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-is-device-ptr-2.c?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+void\n+foo ()\n+{\n+  int *x, *y;\n+\n+  #pragma omp target data map(x, y) use_device_ptr(x, y)\n+    #pragma omp target is_device_ptr(x, y)\n+      {\n+\t*x = 42;\n+      }\n+}\n+\n+/* { dg-final { scan-tree-dump \"is_device_ptr\\\\(x\\\\)\"  \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-not \"is_device_ptr\\\\(y\\\\)\"  \"gimple\" } } */"}, {"sha": "f64b078db4000bd1c9d9575e55ff4ab714b0df89", "filename": "gcc/testsuite/g++.dg/gomp/attrs-1.C", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -121,7 +121,7 @@ baz (int d, int m, int i1, int i2, int p, int *idp, int s,\n }\n \n void\n-bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n+bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int hda, int s,\n      int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int *dd, int ntm,\n      const char *msg)\n {\n@@ -185,43 +185,44 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n   [[omp::directive (target parallel\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n-    nowait depend(inout: dd[0]) allocate (omp_default_mem_alloc:f) in_reduction(+:r2))]]\n+    nowait depend(inout: dd[0]) allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr (hda))]]\n     ;\n   [[omp::directive (target parallel for\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n     lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1) nowait depend(inout: dd[0])\n-    allocate (omp_default_mem_alloc:f) in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr (hda))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n   [[omp::directive (target parallel for\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n     lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) nowait depend(inout: dd[0]) order(concurrent)\n-    allocate (omp_default_mem_alloc:f) in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr (hda))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n   [[omp::sequence (omp::directive (target parallel for simd\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n     lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1)\n     safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) if (simd: i3) order(concurrent)\n-    allocate (omp_default_mem_alloc:f) in_reduction(+:r2)))]]\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr (hda)))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n   [[omp::sequence (directive (target teams\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n     shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) nowait depend(inout: dd[0])\n-    allocate (omp_default_mem_alloc:f) in_reduction(+:r2)))]]\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr (hda)))]]\n     ;\n   [[omp::sequence (directive (target\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n-    nowait depend(inout: dd[0]) allocate (omp_default_mem_alloc:f) in_reduction(+:r2)))]]\n+    nowait depend(inout: dd[0]) allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr (hda)))]]\n     ;\n   [[omp::sequence (omp::directive (target teams distribute\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) order(concurrent)\n-    collapse(1) dist_schedule(static, 16) nowait depend(inout: dd[0]) allocate (omp_default_mem_alloc:f) in_reduction(+:r2)))]]\n+    collapse(1) dist_schedule(static, 16) nowait depend(inout: dd[0]) allocate (omp_default_mem_alloc:f) in_reduction(+:r2)\n+    has_device_addr (hda)))]]\n   for (int i = 0; i < 64; i++)\n     ;\n   [[omp::directive (target teams distribute parallel for\n@@ -230,7 +231,7 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     collapse(1) dist_schedule(static, 16)\n     if (parallel: i2) num_threads (nth) proc_bind(spread)\n     lastprivate (l) schedule(static, 4) nowait depend(inout: dd[0]) order(concurrent)\n-     allocate (omp_default_mem_alloc:f) in_reduction(+:r2))]]\n+     allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr (hda))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n   [[omp::directive (target teams distribute parallel for simd\n@@ -240,22 +241,22 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     if (parallel: i2) num_threads (nth) proc_bind(spread)\n     lastprivate (l) schedule(static, 4) order(concurrent)\n     safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) if (simd: i3)\n-    allocate (omp_default_mem_alloc:f) in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr (hda))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n   [[omp::directive (target teams distribute simd\n     device(d) map (tofrom: m) if (i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n     shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl)\n     collapse(1) dist_schedule(static, 16) order(concurrent)\n     safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm)\n-    allocate (omp_default_mem_alloc:f) in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr (hda))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n   [[omp::directive (target simd\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n     safelen(8) simdlen(4) lastprivate (l) linear(ll: 1) aligned(q: 32) reduction(+:r)\n     nowait depend(inout: dd[0]) nontemporal(ntm) if(simd:i3) order(concurrent)\n-    allocate (omp_default_mem_alloc:f) in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc:f) in_reduction(+:r2) has_device_addr (hda))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n   [[omp::sequence (directive (taskgroup task_reduction(+:r2) allocate (r2)),\n@@ -515,28 +516,28 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n     nowait depend(inout: dd[0]) lastprivate (l) bind(parallel) order(concurrent) collapse(1)\n-    allocate (omp_default_mem_alloc: f) in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc: f) in_reduction(+:r2) has_device_addr (hda))]]\n   for (l = 0; l < 64; ++l)\n     ;\n   [[omp::directive (target parallel loop\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread)\n     nowait depend(inout: dd[0]) lastprivate (l) order(concurrent) collapse(1)\n-    allocate (omp_default_mem_alloc: f) in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc: f) in_reduction(+:r2) has_device_addr (hda))]]\n   for (l = 0; l < 64; ++l)\n     ;\n   [[omp::directive (target teams loop\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) nowait depend(inout: dd[0])\n     lastprivate (l) bind(teams) collapse(1)\n-    allocate (omp_default_mem_alloc: f) in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc: f) in_reduction(+:r2) has_device_addr (hda))]]\n   for (l = 0; l < 64; ++l)\n     ;\n   [[omp::directive (target teams loop\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp)\n     shared(s) default(shared) reduction(+:r) num_teams(nte - 1 : nte) thread_limit(tl) nowait depend(inout: dd[0])\n     lastprivate (l) order(concurrent) collapse(1)\n-    allocate (omp_default_mem_alloc: f) in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc: f) in_reduction(+:r2) has_device_addr (hda))]]\n   for (l = 0; l < 64; ++l)\n     ;\n   [[omp::directive (critical)]] {"}, {"sha": "cc91fa2830714c9d66e2433f2c41a5e6aef9a528", "filename": "gcc/testsuite/g++.dg/gomp/attrs-2.C", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -121,7 +121,7 @@ baz (int d, int m, int i1, int i2, int p, int *idp, int s,\n }\n \n void\n-bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n+bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int hda, int s,\n      int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int *dd, int ntm,\n      const char *msg)\n {\n@@ -185,43 +185,44 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n   [[omp::directive (target parallel,\n     device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n     if (parallel: i2),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread)\n-    nowait depend(inout: dd[0]),allocate (omp_default_mem_alloc:f),in_reduction(+:r2))]]\n+    nowait depend(inout: dd[0]),allocate (omp_default_mem_alloc:f),in_reduction(+:r2),has_device_addr (hda))]]\n     ;\n   [[omp::directive (target parallel for,\n     device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n     if (parallel: i2),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread),\n     lastprivate (l),linear (ll:1),ordered schedule(static, 4),collapse(1),nowait depend(inout: dd[0]),\n-    allocate (omp_default_mem_alloc:f),in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc:f),in_reduction(+:r2),has_device_addr (hda))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n   [[using omp:directive (target parallel for,\n     device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n     if (parallel: i2),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread),\n     lastprivate (l),linear (ll:1),schedule(static, 4),collapse(1),nowait depend(inout: dd[0]),order(concurrent),\n-    allocate (omp_default_mem_alloc:f),in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc:f),in_reduction(+:r2),has_device_addr (hda))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n   [[omp::sequence (omp::directive (target parallel for simd,\n     device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n     if (parallel: i2),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread),\n     lastprivate (l),linear (ll:1),schedule(static, 4),collapse(1),\n     safelen(8),simdlen(4),aligned(q: 32),nowait depend(inout: dd[0]),nontemporal(ntm),if (simd: i3),order(concurrent),\n-    allocate (omp_default_mem_alloc:f),in_reduction(+:r2)))]]\n+    allocate (omp_default_mem_alloc:f),in_reduction(+:r2),has_device_addr (hda)))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n   [[using omp:sequence (directive (target teams,\n     device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n-    shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),nowait, depend(inout: dd[0]),\n-    allocate (omp_default_mem_alloc:f) in_reduction(+:r2)))]]\n+    shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),nowait,depend(inout: dd[0]),\n+    allocate (omp_default_mem_alloc:f),in_reduction(+:r2),has_device_addr (hda)))]]\n     ;\n   [[using omp:sequence (directive (target,\n     device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n-    nowait depend(inout: dd[0]),allocate (omp_default_mem_alloc:f),in_reduction(+:r2)))]]\n+    nowait depend(inout: dd[0]),allocate (omp_default_mem_alloc:f),in_reduction(+:r2),has_device_addr(hda)))]]\n     ;\n   [[omp::sequence (omp::directive (target teams distribute,\n     device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n     shared(s),default(shared),reduction(+:r),num_teams(nte-1:nte),thread_limit(tl),order(concurrent),\n-    collapse(1),dist_schedule(static, 16),nowait depend(inout: dd[0]),allocate (omp_default_mem_alloc:f),in_reduction(+:r2)))]]\n+    collapse(1),dist_schedule(static, 16),nowait depend(inout: dd[0]),allocate (omp_default_mem_alloc:f),in_reduction(+:r2),\n+    has_device_addr (hda)))]]\n   for (int i = 0; i < 64; i++)\n     ;\n   [[omp::directive (target teams distribute parallel for,\n@@ -230,7 +231,7 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     collapse(1),dist_schedule(static, 16),\n     if (parallel: i2),num_threads (nth),proc_bind(spread),\n     lastprivate (l),schedule(static, 4),nowait depend(inout: dd[0]),order(concurrent),\n-     allocate (omp_default_mem_alloc:f),in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc:f),in_reduction(+:r2),has_device_addr (hda))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n   [[omp::directive (target teams distribute parallel for simd,\n@@ -240,22 +241,22 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     if (parallel: i2),num_threads (nth),proc_bind(spread),\n     lastprivate (l),schedule(static, 4),order(concurrent),\n     safelen(8),simdlen(4),aligned(q: 32),nowait depend(inout: dd[0]),nontemporal(ntm),if (simd: i3),\n-    allocate (omp_default_mem_alloc:f),in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc:f),in_reduction(+:r2),has_device_addr (hda))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n   [[omp::directive (target teams distribute simd,\n     device(d),map (tofrom: m),if (i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n     shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),\n     collapse(1),dist_schedule(static, 16),order(concurrent),\n     safelen(8),simdlen(4),aligned(q: 32),nowait depend(inout: dd[0]),nontemporal(ntm),\n-    allocate (omp_default_mem_alloc:f),in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc:f),in_reduction(+:r2),has_device_addr (hda))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n   [[omp::directive (target simd,\n     device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n     safelen(8),simdlen(4),lastprivate (l),linear(ll: 1),aligned(q: 32),reduction(+:r),\n     nowait depend(inout: dd[0]),nontemporal(ntm),if(simd:i3),order(concurrent),\n-    allocate (omp_default_mem_alloc:f),in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc:f),in_reduction(+:r2),has_device_addr (hda))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n   [[omp::sequence (directive (taskgroup, task_reduction(+:r2), allocate (r2)),\n@@ -515,28 +516,28 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n     if (parallel: i2),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread),\n     nowait depend(inout: dd[0]),lastprivate (l),bind(parallel),order(concurrent),collapse(1),\n-    allocate (omp_default_mem_alloc: f),in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc: f),in_reduction(+:r2),has_device_addr (hda))]]\n   for (l = 0; l < 64; ++l)\n     ;\n   [[omp::directive (target parallel loop,\n     device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n     if (parallel: i2),default(shared),shared(s),reduction(+:r),num_threads (nth),proc_bind(spread),\n     nowait depend(inout: dd[0]),lastprivate (l),order(concurrent),collapse(1),\n-    allocate (omp_default_mem_alloc: f),in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc: f),in_reduction(+:r2),has_device_addr (hda))]]\n   for (l = 0; l < 64; ++l)\n     ;\n   [[omp::directive (target teams loop,\n     device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n     shared(s),default(shared),reduction(+:r),num_teams(nte-1:nte),thread_limit(tl),nowait,depend(inout: dd[0]),\n     lastprivate (l),bind(teams),collapse(1),\n-    allocate (omp_default_mem_alloc: f),in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc: f),in_reduction(+:r2),has_device_addr (hda))]]\n   for (l = 0; l < 64; ++l)\n     ;\n   [[omp::directive (target teams loop,\n     device(d),map (tofrom: m),if (target: i1),private (p),firstprivate (f),defaultmap(tofrom: scalar),is_device_ptr (idp),\n     shared(s),default(shared),reduction(+:r),num_teams(nte),thread_limit(tl),nowait,depend(inout: dd[0]),\n     lastprivate (l),order(concurrent),collapse(1)\n-    allocate (omp_default_mem_alloc: f),in_reduction(+:r2))]]\n+    allocate (omp_default_mem_alloc: f),in_reduction(+:r2),has_device_addr (hda))]]\n   for (l = 0; l < 64; ++l)\n     ;\n   [[omp::directive (critical)]] {"}, {"sha": "c3de7726e88c786078879cdb8afbede7aa51af80", "filename": "gcc/testsuite/gfortran.dg/gomp/is_device_ptr-3.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fis_device_ptr-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fis_device_ptr-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fis_device_ptr-3.f90?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,27 @@\n+! Test to ensure that IS_DEVICE_PTR is removed for non-used variables.\n+\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-gimple\" }\n+\n+program main\n+  use iso_c_binding\n+  implicit none\n+\n+  integer :: x, y\n+  call foo (x, y)\n+\n+contains\n+  subroutine foo (a, b)\n+    integer, target :: a, b\n+\n+    !$omp target data map(a, b) use_device_ptr(a, b)\n+      !$omp target is_device_ptr(a, b)\n+        a = 42\n+      !$omp end target\n+    !$omp end target data\n+  end subroutine foo\n+\n+end program main\n+\n+! { dg-final { scan-tree-dump \"is_device_ptr\\\\(a\\\\)\"  \"gimple\" } }\n+! { dg-final { scan-tree-dump-not \"is_device_ptr\\\\(b\\\\)\"  \"gimple\" } }"}, {"sha": "db3fa46b4a103943959a47efe92af2faccd6e95b", "filename": "gcc/testsuite/gfortran.dg/gomp/target-has-device-addr-1.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-has-device-addr-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-has-device-addr-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-has-device-addr-1.f90?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+\n+implicit none\n+\n+integer, target :: x\n+integer, pointer :: ptr\n+integer :: a(5)\n+\n+!$omp target has_device_addr(x)\n+!$omp end target\n+!$omp target has_device_addr(ptr)\n+!$omp end target\n+!$omp target has_device_addr(a)\n+!$omp end target\n+!$omp target has_device_addr(a(2:3))\n+!$omp end target\n+!$omp target has_device_addr(a(:3))\n+!$omp end target\n+!$omp target has_device_addr(a(2:))\n+!$omp end target\n+!$omp target has_device_addr(a(2))\n+!$omp end target\n+\n+!$omp target has_device_addr(x) has_device_addr(x)  ! { dg-error \"'x' present on multiple clauses\" }\n+!$omp end target\n+\n+!$omp target private(x) has_device_addr(x)  ! { dg-error \"'x' present on multiple clauses\" }\n+!$omp end target\n+!$omp target has_device_addr(x) private(x)  ! { dg-error \"'x' present on multiple clauses\" }\n+!$omp end target\n+!$omp target firstprivate(x) has_device_addr(x)  ! { dg-error \"'x' present on multiple clauses\" }\n+!$omp end target\n+!$omp target has_device_addr(x) firstprivate(x)  ! { dg-error \"'x' present on multiple clauses\" }\n+!$omp end target\n+\n+end\n\\ No newline at end of file"}, {"sha": "7fc92b3cb6e44c3860d2c124cca325f00395e913", "filename": "gcc/testsuite/gfortran.dg/gomp/target-has-device-addr-2.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-has-device-addr-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-has-device-addr-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-has-device-addr-2.f90?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,27 @@\n+! Test to ensure that HAS_DEVICE_ADDR is removed for non-used variables.\n+\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-gimple\" }\n+\n+program main\n+  use iso_c_binding\n+  implicit none\n+\n+  integer :: x, y\n+  call foo (x, y)\n+\n+contains\n+  subroutine foo (a, b)\n+    integer :: a, b\n+\n+    !$omp target data map(a) use_device_addr(a)\n+      !$omp target has_device_addr(a)\n+        a = 42\n+      !$omp end target\n+    !$omp end target data\n+  end subroutine foo\n+\n+end program main\n+\n+! { dg-final { scan-tree-dump \"has_device_addr\\\\(a\\\\)\"  \"gimple\" } }\n+! { dg-final { scan-tree-dump-not \"has_device_addr\\\\(b\\\\)\"  \"gimple\" } }"}, {"sha": "01a1ce499daad90c06c5a11d1e83d30592d591f8", "filename": "gcc/tree-core.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -342,6 +342,9 @@ enum omp_clause_code {\n      OpenMP clause: map ({alloc:,to:,from:,tofrom:,}variable-list).  */\n   OMP_CLAUSE_MAP,\n \n+  /* OpenMP clause: has_device_addr (variable-list).  */\n+  OMP_CLAUSE_HAS_DEVICE_ADDR,\n+\n   /* Internal structure to hold OpenACC cache directive's variable-list.\n      #pragma acc cache (variable-list).  */\n   OMP_CLAUSE__CACHE_,"}, {"sha": "078ceab3ca3ae0ed44ff87dddc21f41c8a38d2ef", "filename": "gcc/tree-nested.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftree-nested.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftree-nested.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.cc?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -1339,6 +1339,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_LINK:\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \tcase OMP_CLAUSE_USE_DEVICE_ADDR:\n+\tcase OMP_CLAUSE_HAS_DEVICE_ADDR:\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \tcase OMP_CLAUSE_DETACH:\n \tdo_decl_clause:\n@@ -2123,6 +2124,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_LINK:\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \tcase OMP_CLAUSE_USE_DEVICE_ADDR:\n+\tcase OMP_CLAUSE_HAS_DEVICE_ADDR:\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \tcase OMP_CLAUSE_DETACH:\n \tdo_decl_clause:"}, {"sha": "99af977979d5891e6e8345276af794f421ecfaac", "filename": "gcc/tree-pretty-print.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftree-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftree-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.cc?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -493,6 +493,9 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n     case OMP_CLAUSE_USE_DEVICE_ADDR:\n       name = \"use_device_addr\";\n       goto print_remap;\n+    case OMP_CLAUSE_HAS_DEVICE_ADDR:\n+      name = \"has_device_addr\";\n+      goto print_remap;\n     case OMP_CLAUSE_IS_DEVICE_PTR:\n       name = \"is_device_ptr\";\n       goto print_remap;"}, {"sha": "aeb3b4cebcfcb8ea37cb72f640c8720a4f23fc0c", "filename": "gcc/tree.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/gcc%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.cc?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -289,6 +289,7 @@ unsigned const char omp_clause_num_ops[] =\n   2, /* OMP_CLAUSE_FROM  */\n   2, /* OMP_CLAUSE_TO  */\n   2, /* OMP_CLAUSE_MAP  */\n+  1, /* OMP_CLAUSE_HAS_DEVICE_ADDR  */\n   2, /* OMP_CLAUSE__CACHE_  */\n   2, /* OMP_CLAUSE_GANG  */\n   1, /* OMP_CLAUSE_ASYNC  */\n@@ -378,6 +379,7 @@ const char * const omp_clause_code_name[] =\n   \"from\",\n   \"to\",\n   \"map\",\n+  \"has_device_addr\",\n   \"_cache_\",\n   \"gang\",\n   \"async\","}, {"sha": "161a423ac7c6bee62480184ceead581584362304", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -294,7 +294,7 @@ The OpenMP 4.5 specification is fully supported.\n @item @code{align} clause/modifier in @code{allocate} directive/clause\n       and @code{allocator} directive @tab P @tab C/C++ on clause only\n @item @code{thread_limit} clause to @code{target} construct @tab Y @tab\n-@item @code{has_device_addr} clause to @code{target} construct @tab N @tab\n+@item @code{has_device_addr} clause to @code{target} construct @tab Y @tab\n @item iterators in @code{target update} motion clauses and @code{map}\n       clauses @tab N @tab\n @item indirect calls to the device version of a procedure or function in"}, {"sha": "9017458885e9e9fbed0d16b0e41409fd361697a4", "filename": "libgomp/target.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -2510,7 +2510,7 @@ copy_firstprivate_data (char *tgt, size_t mapnum, void **hostaddrs,\n   tgt_size = 0;\n   size_t i;\n   for (i = 0; i < mapnum; i++)\n-    if ((kinds[i] & 0xff) == GOMP_MAP_FIRSTPRIVATE)\n+    if ((kinds[i] & 0xff) == GOMP_MAP_FIRSTPRIVATE && hostaddrs[i] != NULL)\n       {\n \tsize_t align = (size_t) 1 << (kinds[i] >> 8);\n \ttgt_size = (tgt_size + align - 1) & ~(align - 1);"}, {"sha": "d9a309d7af4e001e5618ebd09849efd07aa04e3b", "filename": "libgomp/testsuite/libgomp.c++/target-has-device-addr-2.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-has-device-addr-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-has-device-addr-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-has-device-addr-2.C?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,23 @@\n+/* Testing 'has_device_addr' clause on the target construct with reference. */\n+\n+#include <omp.h>\n+\n+int\n+main ()\n+{\n+  int *dp = (int*)omp_target_alloc (sizeof(int), 0);\n+\n+  #pragma omp target is_device_ptr(dp)\n+    *dp = 42;\n+\n+  int &x = *dp;\n+\n+  #pragma omp target has_device_addr(x)\n+    x = 24;\n+\n+  #pragma omp target has_device_addr(x)\n+    if (x != 24)\n+      __builtin_abort ();\n+\n+  omp_target_free(dp, 0);\n+}"}, {"sha": "6468c6c8433bf020c5df8658e465fa3fd9db0122", "filename": "libgomp/testsuite/libgomp.c++/target-has-device-addr-4.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-has-device-addr-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-has-device-addr-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-has-device-addr-4.C?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,33 @@\n+#include <omp.h>\n+\n+int\n+main ()\n+{\n+  int *dp = (int*)omp_target_alloc (30*sizeof(int), 0);\n+\n+  #pragma omp target is_device_ptr(dp)\n+    for (int i = 0; i < 30; i++)\n+      dp[i] = i;\n+\n+  int (&x)[30] = *static_cast<int(*)[30]>(static_cast<void*>(dp));\n+\n+  #pragma omp target has_device_addr(x)\n+    for (int i = 0; i < 30; i++)\n+      x[i] = 2 * i;\n+\n+  #pragma omp target has_device_addr(x)\n+    for (int i = 0; i < 30; i++)\n+      if (x[i] != 2 * i)\n+\t__builtin_abort ();\n+\n+  #pragma omp target has_device_addr(x[1:5])\n+    for (int i = 1; i < 6; i++)\n+      x[i] = 3 * i;\n+\n+  #pragma omp target has_device_addr(x[1:5])\n+    for (int i = 1; i < 6; i++)\n+      if (x[i] != 3 * i)\n+\t__builtin_abort ();\n+\n+  omp_target_free (dp, 0);\n+}"}, {"sha": "e847cdceb441742e70da452f039b05c96ba68f04", "filename": "libgomp/testsuite/libgomp.c++/target-has-device-addr-5.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-has-device-addr-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-has-device-addr-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-has-device-addr-5.C?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,33 @@\n+/* Testing 'has_device_addr' clause on the target construct with reference. */\n+\n+#include <omp.h>\n+\n+int\n+main ()\n+{\n+  int *dpx = (int*)omp_target_alloc (sizeof(int), 0);\n+  int **dpy = (int**)omp_target_alloc (sizeof(int*), 0);\n+\n+  #pragma omp target is_device_ptr(dpx, dpy)\n+    {\n+      *dpx = 42;\n+      int z = 77;\n+      *dpy = &z;\n+    }\n+\n+  int& x = *dpx;\n+  int*& y = *dpy;\n+\n+  #pragma omp target has_device_addr(x, y)\n+    {\n+      x = 24;\n+      y = &x;\n+    }\n+\n+  #pragma omp target has_device_addr(x, y)\n+    if (x != 24 || y != &x)\n+      __builtin_abort ();\n+\n+  omp_target_free(dpx, 0);\n+  omp_target_free(dpy, 0);\n+}"}, {"sha": "141edb14dec7efc8bad490c3ce01fd1b75a4118f", "filename": "libgomp/testsuite/libgomp.c++/target-has-device-addr-6.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-has-device-addr-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-has-device-addr-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-has-device-addr-6.C?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,32 @@\n+/* Testing 'has_device_addr' clause on the target construct with reference. */\n+\n+#include <omp.h>\n+\n+int\n+main ()\n+{\n+  int *dpx = (int*)omp_target_alloc (sizeof(int), 0);\n+  double *dpy = (double*)omp_target_alloc (sizeof(double), 0);\n+\n+  #pragma omp target is_device_ptr(dpx, dpy)\n+    {\n+      *dpx = 42;\n+      *dpy = 43.5;\n+    }\n+\n+  int &x = *dpx;\n+  double &y = *dpy;\n+\n+  #pragma omp target has_device_addr(x, y)\n+    {\n+      x = 24;\n+      y = 25.7;\n+    }\n+\n+  #pragma omp target has_device_addr(y, x)\n+    if (x != 24 || y != 25.7)\n+      __builtin_abort ();\n+\n+  omp_target_free(dpx, 0);\n+  omp_target_free(dpy, 0);\n+}"}, {"sha": "fcc5c9e85534fb9d26b70c434acd52827c202529", "filename": "libgomp/testsuite/libgomp.c-c++-common/target-has-device-addr-1.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-has-device-addr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-has-device-addr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-has-device-addr-1.c?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,73 @@\n+/* Testing the 'has_device_addr' clause on the target construct with\n+   enclosing 'target data' construct. */\n+\n+#define N 40\n+\n+int\n+main ()\n+{\n+  int x = 24;\n+\n+  #pragma omp target data map(x) use_device_addr(x)\n+    #pragma omp target has_device_addr(x)\n+      x = 42;\n+  if (x != 42)\n+    __builtin_abort ();\n+\n+  int y[N];\n+\n+  for (int i = 0; i < N; i++)\n+    y[i] = 42;\n+  #pragma omp target data map(y) use_device_addr(y)\n+    #pragma omp target has_device_addr(y)\n+      for (int i = 0; i < N; i++)\n+\ty[i] = i;\n+  for (int i = 0; i < N; i++)\n+    if (y[i] != i)\n+      __builtin_abort ();\n+\n+  #pragma omp target data map(y[:N]) use_device_addr(y)\n+    #pragma omp target has_device_addr(y[:N])\n+      for (int i = 0; i < N; i++)\n+\ty[i] = i + 2;\n+  for (int i = 0; i < N; i++)\n+    if (y[i] != i + 2)\n+      __builtin_abort ();\n+\n+  #pragma omp target data map(y[:N]) use_device_addr(y)\n+    #pragma omp target has_device_addr(y[24])\n+\ty[24] = 42;\n+  if (y[24] != 42)\n+    __builtin_abort ();\n+\n+  #pragma omp target data map(y[:N]) use_device_addr(y)\n+    #pragma omp target has_device_addr(y[24:])\n+      for (int i = 24; i < N; i++)\n+\ty[i] = i + 3;\n+  for (int i = 24; i < N; i++)\n+    if (y[i] != i + 3)\n+      __builtin_abort ();\n+\n+  #pragma omp target data map(y[:N]) use_device_addr(y)\n+    #pragma omp target has_device_addr(y[12:24])\n+      for (int i = 12; i < 24; i++)\n+\ty[i] = i + 4;\n+  for (int i = 12; i < 24; i++)\n+    if (y[i] != i + 4)\n+      __builtin_abort ();\n+\n+  int u[0];\n+  #pragma omp target data map(u) use_device_addr(u)\n+    #pragma omp target has_device_addr(u)\n+  ;\n+\n+  struct S { int m; } s;\n+  s.m = 42;\n+  #pragma omp target data map (s) use_device_addr (s)\n+    #pragma omp target has_device_addr (s)\n+      ++s.m;\n+  if (s.m != 43)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "fd99a82f66a941d17aef06b61c1a57a3e22e67f4", "filename": "libgomp/testsuite/libgomp.c/target-has-device-addr-3.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-has-device-addr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-has-device-addr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-has-device-addr-3.c?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,33 @@\n+/* Testing 'has_device_addr' clause with variable sized array. */\n+\n+int\n+foo (int size)\n+{\n+  int x[size];\n+\n+  #pragma omp target data map(x[:size]) use_device_addr(x)\n+    #pragma omp target has_device_addr(x)\n+      for (int i = 0; i < size; i++)\n+\tx[i] = i;\n+  for (int i = 0; i < size; i++)\n+    if (x[i] != i)\n+      __builtin_abort ();\n+\n+  #pragma omp target data map(x) use_device_addr(x)\n+    #pragma omp target has_device_addr(x[2:3])\n+      for (int i = 0; i < size; i++)\n+\tx[i] = i;\n+  for (int i = 0; i < size; i++)\n+    if (x[i] != i)\n+      __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  foo (40);\n+\n+  return 0;\n+}"}, {"sha": "2945864fa5343afa85173c65c6ad20cae5e75a41", "filename": "libgomp/testsuite/libgomp.fortran/target-has-device-addr-1.f90", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-has-device-addr-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-has-device-addr-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-has-device-addr-1.f90?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,50 @@\n+program main\n+  use omp_lib\n+  use iso_c_binding\n+  implicit none\n+\n+  integer, parameter :: N = 40\n+  integer :: x, i\n+  integer :: y (N)\n+  integer :: u (0)\n+\n+  x = 24\n+  !$omp target data map(x) use_device_addr(x)\n+    !$omp target has_device_addr(x)\n+      x = 42;\n+    !$omp end target\n+  !$omp end target data\n+  if (x /= 42) stop 1\n+\n+  y = 42\n+  !$omp target data map(y) use_device_addr(y)\n+    !$omp target has_device_addr(y)\n+      y = [(i, i=1, N)]\n+    !$omp end target\n+  !$omp end target data\n+  if (any (y /= [(i, i = 1, N)])) stop 2\n+\n+  !$omp target data map(y(:N)) use_device_addr(y)\n+    !$omp target has_device_addr(y(:N))\n+      y = [(i+2, i=1, N)]\n+    !$omp end target\n+  !$omp end target data\n+  if (any (y /= [(i+2, i = 1, N)])) stop 3\n+\n+  !$omp target data map(y) use_device_addr(y)\n+    !$omp target has_device_addr(y(24:))\n+      do i = 24, N\n+        y(i) = i + 3\n+      end do\n+    !$omp end target\n+  !$omp end target data\n+  do i = 24, N\n+    if (y(i) /= i + 3) stop 5\n+  end do\n+\n+  !$omp target data map(u) use_device_addr(u)\n+    !$omp target has_device_addr(u)\n+    !$omp end target\n+  !$omp end target data\n+\n+end program main"}, {"sha": "a8d78a75af3afcb4a7c2ae5db05146ee821929de", "filename": "libgomp/testsuite/libgomp.fortran/target-has-device-addr-2.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-has-device-addr-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-has-device-addr-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-has-device-addr-2.f90?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,40 @@\n+program main\n+  use omp_lib\n+  use iso_c_binding\n+  implicit none\n+\n+  integer, parameter :: N = 5\n+  integer :: i, x(N), y(N), z(N:2*N-1)\n+  target :: z\n+\n+  x = 42\n+  y = 43\n+  z = 44\n+\n+  call foo (x, y, z)\n+  if (any (x /= [(i, i = 1, N)])) stop 1\n+  if (any (y /= [(2*i, i = 1, N)])) stop 2\n+  if (any (z /= [(3*i, i = 1, N)])) stop 3\n+\n+  contains\n+  subroutine foo(a, b, c)\n+    integer :: a(:)\n+    integer :: b(*)\n+    integer, pointer, intent(in) :: c(:)\n+\n+    !$omp target data map(a,b(:N),c) use_device_addr(a,b(:N),c)\n+      !$omp target has_device_addr(A,B(:N),C)\n+        if (lbound(a,dim=1) /= 1 .or. ubound(a,dim=1) /= N) stop 10\n+        if (lbound(b,dim=1) /= 1) stop 11\n+        if (lbound(c,dim=1) /= N .or. ubound(c,dim=1) /= 2*N-1) stop 12\n+        if (any (a /= 42)) stop 13\n+        if (any (b(:N) /= 43)) stop 14\n+        if (any (c /= 44)) stop 15\n+        a = [(i, i=1, N)]\n+        b(:N) = [(2*i, i = 1, N)]\n+        c = [(3*i, i = 1, N)]\n+      !$omp end target\n+    !$omp end target data\n+  end subroutine foo\n+\n+end program main"}, {"sha": "c6293b4de2e073e8477b98945e1889a66b665152", "filename": "libgomp/testsuite/libgomp.fortran/target-has-device-addr-3.f90", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-has-device-addr-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-has-device-addr-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-has-device-addr-3.f90?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,90 @@\n+! Test optional dummy arguments in HAS_DEVICE_ADDR.\n+\n+program main\n+  use omp_lib\n+  use iso_c_binding\n+  implicit none\n+\n+  integer, target :: x\n+  integer, pointer :: ptr\n+  integer, parameter :: N=7\n+  real :: y1(N), y2(N)\n+  integer, target :: y3(N:2*N-1)\n+  integer :: i\n+\n+  x = 24\n+  ptr => x\n+  y1 = 42.24\n+  y2 = 42.24\n+  y3 = 42\n+\n+  call optional_scalar (is_present=.false.)\n+  if (x /= 24) stop 1\n+\n+  call optional_scalar (x, is_present=.true.)\n+  if (x /= 42) stop 2\n+\n+  call optional_ptr (is_present=.false.)\n+  if (x /= 42) stop 3\n+  if (ptr /= 42) stop 4\n+\n+  call optional_ptr (ptr, is_present=.true.)\n+  if (x /= 84) stop 5\n+  if (ptr /= 84) stop 6\n+\n+  call optional_array (is_present=.false.)\n+  if (any (y1 /= [(42.24, i=1, N)])) stop 7\n+  if (any (y2 /= [(42.24, i=1, N)])) stop 8\n+  if (any (y3 /= [(42, i=1, N)])) stop 9\n+\n+  call optional_array (y1, y2, y3, is_present=.true.)\n+  if (any (y1 /= [(42.24+i, i=1, N)])) stop 10\n+  if (any (y2 /= [(42.24+2*i, i=1, N)])) stop 11\n+  if (any (y3 /= [(42+3*i, i=1, N)])) stop 12\n+\n+contains\n+  subroutine optional_scalar (a, is_present)\n+    integer, optional :: a\n+    logical, value :: is_present\n+\n+    !$omp target data map(a) use_device_addr(a)\n+      !$omp target has_device_addr(a)\n+        if (is_present) a = 42\n+      !$omp end target\n+    !$omp end target data\n+  end subroutine optional_scalar\n+\n+  subroutine optional_ptr (a, is_present)\n+    integer, pointer, optional :: a\n+    logical, value :: is_present\n+    !$omp target data map(a) use_device_addr(a)\n+      !$omp target has_device_addr(a)\n+        if (is_present) a = 84\n+      !$omp end target\n+    !$omp end target data\n+  end subroutine optional_ptr\n+\n+  subroutine optional_array (a, b, c, is_present)\n+    real, optional :: a(:), b(*)\n+    integer, optional, pointer, intent(in) :: c(:)\n+    logical, value :: is_present\n+    integer :: i\n+\n+    !$omp target data map(a, b(:N), c) use_device_addr(a, b, c)\n+      !$omp target has_device_addr(a, b, c)\n+        if (is_present) then\n+          if (lbound(a,dim=1) /= 1 .or. ubound(a,dim=1) /= N) stop 21\n+          if (lbound(b,dim=1) /= 1) stop 22\n+          if (lbound(c,dim=1) /= N .or. ubound(c,dim=1) /= 2*N-1) stop 23\n+          if (any (a /= [(42.24, i = 1, N)])) stop 24\n+          if (any (b(:N) /= [(42.24, i = 1, N)])) stop 25\n+          if (any (c /= [(42, i = 1, N)])) stop 26\n+          a = [(42.24+i, i=1, N)]\n+          b(:N) = [(42.24+2*i, i=1, N)]\n+          c = [(42+3*i, i=1, N)]\n+        end if\n+      !$omp end target\n+    !$omp end target data\n+  end subroutine optional_array\n+\n+end program main"}, {"sha": "59d3e3d31dd110fc26684edd21f9045be2f8dbe8", "filename": "libgomp/testsuite/libgomp.fortran/target-has-device-addr-4.f90", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-has-device-addr-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbb7f8604e1dfc08f44354cfd93d2287f2fdd489/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-has-device-addr-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-has-device-addr-4.f90?ref=bbb7f8604e1dfc08f44354cfd93d2287f2fdd489", "patch": "@@ -0,0 +1,71 @@\n+! Test allocatables in HAS_DEVICE_ADDR.\n+\n+program main\n+  use omp_lib\n+  use iso_c_binding\n+  implicit none\n+\n+  integer, parameter :: N = 5\n+  integer, allocatable :: x\n+  integer, allocatable :: y(:)\n+  call scalar_dummy (x)\n+  call array_dummy (y)\n+  call array_dummy_optional (y)\n+  call array_dummy_optional ()\n+\n+contains\n+  subroutine scalar_dummy (a)\n+    integer, allocatable :: a\n+\n+    allocate (a)\n+    a = 24\n+\n+    !$omp target data map(a) use_device_addr(a)\n+      !$omp target has_device_addr(a)\n+        a = 42\n+      !$omp end target\n+    !$omp end target data\n+    if (a /= 42) stop 1\n+\n+    deallocate (a)\n+  end subroutine scalar_dummy\n+\n+  subroutine array_dummy (a)\n+    integer, allocatable :: a(:)\n+    integer :: i\n+\n+    allocate (a(N))\n+    a = 42\n+\n+    !$omp target data map(a) use_device_addr(a)\n+      !$omp target has_device_addr(a)\n+        a = [(i, i=1, N)]\n+      !$omp end target\n+    !$omp end target data\n+    if (any (a /= [(i, i=1, N)])) stop 2\n+\n+    deallocate (a)\n+  end subroutine array_dummy\n+\n+  subroutine array_dummy_optional (a)\n+    integer, optional, allocatable :: a(:)\n+    integer :: i\n+\n+    if (present (a)) then\n+      allocate (a(N))\n+      a = 42\n+    end if\n+\n+    !$omp target data map(a) use_device_addr(a)\n+      !$omp target has_device_addr(a)\n+        if (present (a)) a = [(i, i=1, N)]\n+      !$omp end target\n+    !$omp end target data\n+\n+    if (present (a)) then\n+      if (any (a /= [(i, i=1, N)])) stop 2\n+      deallocate (a)\n+    end if\n+  end subroutine array_dummy_optional\n+\n+end program main"}]}