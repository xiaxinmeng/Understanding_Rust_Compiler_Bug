{"sha": "826a536d2a36698f109d48aadba2936ce80c7812", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI2YTUzNmQyYTM2Njk4ZjEwOWQ0OGFhZGJhMjkzNmNlODBjNzgxMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-10-02T13:46:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-10-02T13:46:32Z"}, "message": "tree-loop-distribution.c: Include tree-vectorizer.h for find_loop_location.\n\n2013-10-02  Richard Biener  <rguenther@suse.de>\n\n\t* tree-loop-distribution.c: Include tree-vectorizer.h for\n\tfind_loop_location.\n\t(enum partition_kind): Remove PKIND_REDUCTION.\n\t(struct partition_s): Remove has_writes member, add reduction_p\n\tmember.\n\t(partition_alloc): Adjust.\n\t(partition_builtin_p): Likewise.\n\t(partition_has_writes): Remove.\n\t(partition_reduction_p): New function.\n\t(partition_merge_into): Likewise.\n\t(generate_code_for_partition): Commonize builtin partition\n\thandling tail.\n\t(rdg_cannot_recompute_vertex_p): Remove.\n\t(already_processed_vertex_p): Likewise.\n\t(rdg_flag_vertex): Do not set has_writes.\n\t(classify_partition): Adjust.\n\t(rdg_build_partitions): Do not set has_writes, treat all\n\tpartitions as useful.\n\t(distribute_loop): Record number of library calls generated.\n\tAdjust.\n\t(tree_loop_distribution): Report number of loops and library\n\tcalls generated as opt-info.\n\n\t* gcc.dg/tree-ssa/ldist-11.c: Adjust.\n\t* gcc.dg/tree-ssa/ldist-17.c: Likewise.\n\t* gcc.dg/tree-ssa/ldist-23.c: Likewise.\n\t* gcc.dg/tree-ssa/ldist-pr45948.c: Likewise.\n\t* gfortran.dg/ldist-pr45199.f: Likewise.\n\nFrom-SVN: r203115", "tree": {"sha": "876913b5d63d059adb6094811eee923b79df3daf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/876913b5d63d059adb6094811eee923b79df3daf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/826a536d2a36698f109d48aadba2936ce80c7812", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/826a536d2a36698f109d48aadba2936ce80c7812", "html_url": "https://github.com/Rust-GCC/gccrs/commit/826a536d2a36698f109d48aadba2936ce80c7812", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/826a536d2a36698f109d48aadba2936ce80c7812/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4b403ece7c644ff45d279d368e26b41a7d8840bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b403ece7c644ff45d279d368e26b41a7d8840bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b403ece7c644ff45d279d368e26b41a7d8840bc"}], "stats": {"total": 195, "additions": 102, "deletions": 93}, "files": [{"sha": "87b789a067ff99bca9c9614558be2b2855824278", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=826a536d2a36698f109d48aadba2936ce80c7812", "patch": "@@ -1,3 +1,28 @@\n+2013-10-02  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-loop-distribution.c: Include tree-vectorizer.h for\n+\tfind_loop_location.\n+\t(enum partition_kind): Remove PKIND_REDUCTION.\n+\t(struct partition_s): Remove has_writes member, add reduction_p\n+\tmember.\n+\t(partition_alloc): Adjust.\n+\t(partition_builtin_p): Likewise.\n+\t(partition_has_writes): Remove.\n+\t(partition_reduction_p): New function.\n+\t(partition_merge_into): Likewise.\n+\t(generate_code_for_partition): Commonize builtin partition\n+\thandling tail.\n+\t(rdg_cannot_recompute_vertex_p): Remove.\n+\t(already_processed_vertex_p): Likewise.\n+\t(rdg_flag_vertex): Do not set has_writes.\n+\t(classify_partition): Adjust.\n+\t(rdg_build_partitions): Do not set has_writes, treat all\n+\tpartitions as useful.\n+\t(distribute_loop): Record number of library calls generated.\n+\tAdjust.\n+\t(tree_loop_distribution): Report number of loops and library\n+\tcalls generated as opt-info.\n+\n 2013-10-02  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* tree-flow.h: Include new .h files.  Move prototypes."}, {"sha": "754a6a2f2934effb2c11a0f6f442ee843c09ea1a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=826a536d2a36698f109d48aadba2936ce80c7812", "patch": "@@ -1,3 +1,11 @@\n+2013-10-02  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ldist-11.c: Adjust.\n+\t* gcc.dg/tree-ssa/ldist-17.c: Likewise.\n+\t* gcc.dg/tree-ssa/ldist-23.c: Likewise.\n+\t* gcc.dg/tree-ssa/ldist-pr45948.c: Likewise.\n+\t* gfortran.dg/ldist-pr45199.f: Likewise.\n+\n 2013-10-02  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/58565"}, {"sha": "902c25b1553083edda8e3be3b1930495b42f7b44", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-11.c?ref=826a536d2a36698f109d48aadba2936ce80c7812", "patch": "@@ -28,6 +28,6 @@ void foo (int * __restrict__ ia,\n   */\n }\n \n-/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 1 \"ldist\" } } */\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 1 loops and 1 library calls\" 1 \"ldist\" } } */\n /* { dg-final { scan-tree-dump-times \"generated memset zero\" 1 \"ldist\" } } */\n /* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "bbf54db2be913bc048bf5d3a7515a055402911a7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-17.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-17.c?ref=826a536d2a36698f109d48aadba2936ce80c7812", "patch": "@@ -45,6 +45,6 @@ mad_synth_mute (struct mad_synth *synth)\n   return;\n }\n \n-/* { dg-final { scan-tree-dump \"distributed: split to 4\" \"ldist\" } } */\n+/* { dg-final { scan-tree-dump \"distributed: split to 0 loops and 4 library calls\" \"ldist\" } } */\n /* { dg-final { scan-tree-dump-times \"generated memset zero\" 4 \"ldist\" } } */\n /* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "0e7609bdb5733a0d05fdf33bc46c701645007b04", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-23.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-23.c?ref=826a536d2a36698f109d48aadba2936ce80c7812", "patch": "@@ -29,6 +29,6 @@ int main()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"split to 2 loops\" \"ldist\" } } */\n+/* { dg-final { scan-tree-dump \"split to 1 loops and 1 library call\" \"ldist\" } } */\n /* { dg-final { scan-tree-dump \"generated memcpy\" \"ldist\" } } */\n /* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "f25a910643018c9585ec8deca439b28bd4c4b9ea", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-pr45948.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-pr45948.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-pr45948.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-pr45948.c?ref=826a536d2a36698f109d48aadba2936ce80c7812", "patch": "@@ -18,6 +18,6 @@ foo (int i, int n)\n \n /* We should apply loop distribution and generate 2 memset (0).  */\n \n-/* { dg-final { scan-tree-dump \"distributed: split to 2\" \"ldist\" } } */\n+/* { dg-final { scan-tree-dump \"distributed: split to 0 loops and 2 library calls\" \"ldist\" } } */\n /* { dg-final { scan-tree-dump-times \"generated memset zero\" 2 \"ldist\" } } */\n /* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "e01d32f2664b02ba847a91f72482b8c3f64b0a5a", "filename": "gcc/testsuite/gfortran.dg/ldist-pr45199.f", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-pr45199.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-pr45199.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-pr45199.f?ref=826a536d2a36698f109d48aadba2936ce80c7812", "patch": "@@ -22,6 +22,6 @@\n \n ! GCC should apply memset zero loop distribution and it should not ICE.\n \n-! { dg-final { scan-tree-dump \"distributed: split to 9 loops\" \"ldist\" } }\n+! { dg-final { scan-tree-dump \"distributed: split to 0 loops and 9 library calls\" \"ldist\" } }\n ! { dg-final { scan-tree-dump-times \"generated memset zero\" 9 \"ldist\" } }\n ! { dg-final { cleanup-tree-dump \"ldist\" } }"}, {"sha": "44be6cb18838da4125f1fd0f1883095fff1c7085", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 64, "deletions": 88, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/826a536d2a36698f109d48aadba2936ce80c7812/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=826a536d2a36698f109d48aadba2936ce80c7812", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"tree-pass.h\"\n #include \"gimple-pretty-print.h\"\n+#include \"tree-vectorizer.h\"\n \n \n /* A Reduced Dependence Graph (RDG) vertex representing a statement.  */\n@@ -557,14 +558,14 @@ build_rdg (vec<loop_p> loop_nest, control_dependences *cd)\n \n \n enum partition_kind {\n-    PKIND_NORMAL, PKIND_REDUCTION, PKIND_MEMSET, PKIND_MEMCPY\n+    PKIND_NORMAL, PKIND_MEMSET, PKIND_MEMCPY\n };\n \n typedef struct partition_s\n {\n   bitmap stmts;\n   bitmap loops;\n-  bool has_writes;\n+  bool reduction_p;\n   enum partition_kind kind;\n   /* data-references a kind != PKIND_NORMAL partition is about.  */\n   data_reference_p main_dr;\n@@ -581,7 +582,7 @@ partition_alloc (bitmap stmts, bitmap loops)\n   partition_t partition = XCNEW (struct partition_s);\n   partition->stmts = stmts ? stmts : BITMAP_ALLOC (NULL);\n   partition->loops = loops ? loops : BITMAP_ALLOC (NULL);\n-  partition->has_writes = false;\n+  partition->reduction_p = false;\n   partition->kind = PKIND_NORMAL;\n   return partition;\n }\n@@ -601,17 +602,29 @@ partition_free (partition_t partition)\n static bool\n partition_builtin_p (partition_t partition)\n {\n-  return partition->kind > PKIND_REDUCTION;\n+  return partition->kind != PKIND_NORMAL;\n }\n \n-/* Returns true if the partition has an writes.  */\n+/* Returns true if the partition contains a reduction.  */\n \n static bool\n-partition_has_writes (partition_t partition)\n+partition_reduction_p (partition_t partition)\n {\n-  return partition->has_writes;\n+  return partition->reduction_p;\n }\n \n+/* Merge PARTITION into the partition DEST.  */\n+\n+static void\n+partition_merge_into (partition_t dest, partition_t partition)\n+{\n+  dest->kind = PKIND_NORMAL;\n+  bitmap_ior_into (dest->stmts, partition->stmts);\n+  if (partition_reduction_p (partition))\n+    dest->reduction_p = true;\n+}\n+\n+\n /* Returns true when DEF is an SSA_NAME defined in LOOP and used after\n    the LOOP.  */\n \n@@ -998,58 +1011,31 @@ generate_code_for_partition (struct loop *loop,\n {\n   switch (partition->kind)\n     {\n+    case PKIND_NORMAL:\n+      /* Reductions all have to be in the last partition.  */\n+      gcc_assert (!partition_reduction_p (partition)\n+\t\t  || !copy_p);\n+      generate_loops_for_partition (loop, partition, copy_p);\n+      return;\n+\n     case PKIND_MEMSET:\n       generate_memset_builtin (loop, partition);\n-      /* If this is the last partition for which we generate code, we have\n-\t to destroy the loop.  */\n-      if (!copy_p)\n-\tdestroy_loop (loop);\n       break;\n \n     case PKIND_MEMCPY:\n       generate_memcpy_builtin (loop, partition);\n-      /* If this is the last partition for which we generate code, we have\n-\t to destroy the loop.  */\n-      if (!copy_p)\n-\tdestroy_loop (loop);\n-      break;\n-\n-    case PKIND_REDUCTION:\n-      /* Reductions all have to be in the last partition.  */\n-      gcc_assert (!copy_p);\n-    case PKIND_NORMAL:\n-      generate_loops_for_partition (loop, partition, copy_p);\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n-}\n-\n-\n-/* Returns true if the node V of RDG cannot be recomputed.  */\n-\n-static bool\n-rdg_cannot_recompute_vertex_p (struct graph *rdg, int v)\n-{\n-  if (RDG_MEM_WRITE_STMT (rdg, v))\n-    return true;\n \n-  return false;\n-}\n-\n-/* Returns true when the vertex V has already been generated in the\n-   current partition (V is in PROCESSED), or when V belongs to another\n-   partition and cannot be recomputed (V is not in REMAINING_STMTS).  */\n-\n-static inline bool\n-already_processed_vertex_p (bitmap processed, int v)\n-{\n-  return bitmap_bit_p (processed, v);\n+  /* Common tail for partitions we turn into a call.  If this was the last\n+     partition for which we generate code, we have to destroy the loop.  */\n+  if (!copy_p)\n+    destroy_loop (loop);\n }\n \n-static void rdg_flag_vertex_and_dependent (struct graph *, int, partition_t,\n-\t\t\t\t\t   bitmap);\n \n /* Flag V from RDG as part of PARTITION, and also flag its loop number\n    in LOOPS.  */\n@@ -1064,9 +1050,6 @@ rdg_flag_vertex (struct graph *rdg, int v, partition_t partition)\n \n   loop = loop_containing_stmt (RDG_STMT (rdg, v));\n   bitmap_set_bit (partition->loops, loop->num);\n-\n-  if (rdg_cannot_recompute_vertex_p (rdg, v))\n-    partition->has_writes = true;\n }\n \n /* Flag in the bitmap PARTITION the vertex V and all its predecessors.\n@@ -1127,15 +1110,10 @@ classify_partition (loop_p loop, struct graph *rdg, partition_t partition)\n       if (gimple_has_volatile_ops (stmt))\n \tvolatiles_p = true;\n \n-      /* If the stmt has uses outside of the loop fail.\n-\t ???  If the stmt is generated in another partition that\n-\t is not created as builtin we can ignore this.  */\n+      /* If the stmt has uses outside of the loop mark it as reduction.  */\n       if (stmt_has_scalar_dependences_outside_loop (loop, stmt))\n \t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"not generating builtin, partition has \"\n-\t\t     \"scalar uses outside of the loop\\n\");\n-\t  partition->kind = PKIND_REDUCTION;\n+\t  partition->reduction_p = true;\n \t  return;\n \t}\n     }\n@@ -1356,21 +1334,17 @@ rdg_build_partitions (struct graph *rdg,\n \n       np = build_rdg_partition_for_vertex (rdg, v);\n       bitmap_ior_into (partition->stmts, np->stmts);\n-      partition->has_writes = partition_has_writes (np);\n       bitmap_ior_into (processed, np->stmts);\n       partition_free (np);\n \n-      if (partition_has_writes (partition))\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"ldist useful partition:\\n\");\n-\t      dump_bitmap (dump_file, partition->stmts);\n-\t    }\n-\n-\t  partitions->safe_push (partition);\n-\t  partition = partition_alloc (NULL, NULL);\n+\t  fprintf (dump_file, \"ldist useful partition:\\n\");\n+\t  dump_bitmap (dump_file, partition->stmts);\n \t}\n+\n+      partitions->safe_push (partition);\n+      partition = partition_alloc (NULL, NULL);\n     }\n \n   /* All vertices should have been assigned to at least one partition now,\n@@ -1480,7 +1454,7 @@ partition_contains_all_rw (struct graph *rdg,\n \n static int\n distribute_loop (struct loop *loop, vec<gimple> stmts,\n-\t\t control_dependences *cd)\n+\t\t control_dependences *cd, int *nb_calls)\n {\n   struct graph *rdg;\n   vec<loop_p> loop_nest;\n@@ -1489,6 +1463,7 @@ distribute_loop (struct loop *loop, vec<gimple> stmts,\n   bool any_builtin;\n   int i, nbp;\n \n+  *nb_calls = 0;\n   loop_nest.create (3);\n   if (!find_loop_nest (loop, &loop_nest))\n     {\n@@ -1551,9 +1526,7 @@ distribute_loop (struct loop *loop, vec<gimple> stmts,\n \t\t  fprintf (dump_file, \"because they have similar \"\n \t\t\t   \"memory accesses\\n\");\n \t\t}\n-\t      bitmap_ior_into (into->stmts, partition->stmts);\n-\t      if (partition->kind == PKIND_REDUCTION)\n-\t\tinto->kind = PKIND_REDUCTION;\n+\t      partition_merge_into (into, partition);\n \t      partitions.ordered_remove (j);\n \t      partition_free (partition);\n \t      j--;\n@@ -1577,9 +1550,7 @@ distribute_loop (struct loop *loop, vec<gimple> stmts,\n \t  for (++i; partitions.iterate (i, &partition); ++i)\n \t    if (!partition_builtin_p (partition))\n \t      {\n-\t\tbitmap_ior_into (into->stmts, partition->stmts);\n-\t\tif (partition->kind == PKIND_REDUCTION)\n-\t\t  into->kind = PKIND_REDUCTION;\n+\t\tpartition_merge_into (into, partition);\n \t\tpartitions.ordered_remove (i);\n \t\tpartition_free (partition);\n \t\ti--;\n@@ -1597,7 +1568,7 @@ distribute_loop (struct loop *loop, vec<gimple> stmts,\n       for (i = partitions.length () - 2; i >= 0; --i)\n \t{\n \t  partition_t what = partitions[i];\n-\t  if (what->kind == PKIND_REDUCTION)\n+\t  if (partition_reduction_p (what))\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n@@ -1606,8 +1577,7 @@ distribute_loop (struct loop *loop, vec<gimple> stmts,\n \t\t  dump_bitmap (dump_file, what->stmts);\n \t\t  fprintf (dump_file, \"because the latter has reductions\\n\");\n \t\t}\n-\t      bitmap_ior_into (into->stmts, what->stmts);\n-\t      into->kind = PKIND_REDUCTION;\n+\t      partition_merge_into (into, what);\n \t      partitions.ordered_remove (i);\n \t      partition_free (what);\n \t    }\n@@ -1627,7 +1597,11 @@ distribute_loop (struct loop *loop, vec<gimple> stmts,\n     dump_rdg_partitions (dump_file, partitions);\n \n   FOR_EACH_VEC_ELT (partitions, i, partition)\n-    generate_code_for_partition (loop, partition, i < nbp - 1);\n+    {\n+      if (partition_builtin_p (partition))\n+\t(*nb_calls)++;\n+      generate_code_for_partition (loop, partition, i < nbp - 1);\n+    }\n \n  ldist_done:\n \n@@ -1637,7 +1611,7 @@ distribute_loop (struct loop *loop, vec<gimple> stmts,\n \n   free_rdg (rdg);\n   loop_nest.release ();\n-  return nbp;\n+  return nbp - *nb_calls;\n }\n \n /* Distribute all loops in the current function.  */\n@@ -1667,7 +1641,6 @@ tree_loop_distribution (void)\n       vec<gimple> work_list = vNULL;\n       basic_block *bbs;\n       int num = loop->num;\n-      int nb_generated_loops = 0;\n       unsigned int i;\n \n       /* If the loop doesn't have a single exit we will fail anyway,\n@@ -1722,6 +1695,9 @@ tree_loop_distribution (void)\n out:\n       free (bbs);\n \n+      int nb_generated_loops = 0;\n+      int nb_generated_calls = 0;\n+      location_t loc = find_loop_location (loop);\n       if (work_list.length () > 0)\n \t{\n \t  if (!cd)\n@@ -1731,20 +1707,20 @@ tree_loop_distribution (void)\n \t      cd = new control_dependences (create_edge_list ());\n \t      free_dominance_info (CDI_POST_DOMINATORS);\n \t    }\n-\t  nb_generated_loops = distribute_loop (loop, work_list, cd);\n+\t  nb_generated_loops = distribute_loop (loop, work_list, cd,\n+\t\t\t\t\t\t&nb_generated_calls);\n \t}\n \n-      if (nb_generated_loops > 0)\n-\tchanged = true;\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n+      if (nb_generated_loops + nb_generated_calls > 0)\n \t{\n-\t  if (nb_generated_loops > 1)\n-\t    fprintf (dump_file, \"Loop %d distributed: split to %d loops.\\n\",\n-\t\t     num, nb_generated_loops);\n-\t  else\n-\t    fprintf (dump_file, \"Loop %d is the same.\\n\", num);\n+\t  changed = true;\n+\t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS,\n+\t\t\t   loc, \"Loop %d distributed: split to %d loops \"\n+\t\t\t   \"and %d library calls.\\n\",\n+\t\t\t   num, nb_generated_loops, nb_generated_calls);\n \t}\n+      else if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Loop %d is the same.\\n\", num);\n \n       work_list.release ();\n     }"}]}