{"sha": "4bd2cdb74e26f68a4e9d51e74ace60326c9950d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJkMmNkYjc0ZTI2ZjY4YTRlOWQ1MWU3NGFjZTYwMzI2Yzk5NTBkMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-02T11:25:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-08T13:09:18Z"}, "message": "Make SLP root stmt a vector\n\nThis fixes a TODO noticed when adding vectorization of\nBIT_INSERT_EXPRs and what's now useful for vectorization of\nBB reductions.\n\n2021-06-08  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_slp_instance::root_stmt): Change to...\n\t(_slp_instance::root_stmts): ... a vector.\n\t(SLP_INSTANCE_ROOT_STMT): Rename to ...\n\t(SLP_INSTANCE_ROOT_STMTS): ... this.\n\t(slp_root::root): Change to...\n\t(slp_root::roots): ... a vector.\n\t(slp_root::slp_root): Adjust.\n\t* tree-vect-slp.c (_slp_instance::location): Adjust.\n\t(vect_free_slp_instance): Release the root stmt vector.\n\t(vect_build_slp_instance): Adjust.\n\t(vect_analyze_slp): Likewise.\n\t(_bb_vec_info::~_bb_vec_info): Likewise.\n\t(vect_slp_analyze_operations): Likewise.\n\t(vect_bb_vectorization_profitable_p): Likewise.  Adjust\n\tcosts for the root stmt.\n\t(vect_slp_check_for_constructors): Gather all BIT_INSERT_EXPRs\n\tas root stmts.\n\t(vect_slp_analyze_bb_1): Simplify by marking all root stmts\n\tas pure_slp.\n\t(vectorize_slp_instance_root_stmt): Adjust.\n\t(vect_schedule_slp): Likewise.", "tree": {"sha": "72560a71ebd054ae782a3f45c43571895f1e7124", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72560a71ebd054ae782a3f45c43571895f1e7124"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bd2cdb74e26f68a4e9d51e74ace60326c9950d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bd2cdb74e26f68a4e9d51e74ace60326c9950d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bd2cdb74e26f68a4e9d51e74ace60326c9950d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bd2cdb74e26f68a4e9d51e74ace60326c9950d1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ab8f20348676d209aa8da12baf5da07fa769788", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ab8f20348676d209aa8da12baf5da07fa769788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ab8f20348676d209aa8da12baf5da07fa769788"}], "stats": {"total": 162, "additions": 90, "deletions": 72}, "files": [{"sha": "cc734e065dfc6ad2e82541ebfa6d3e28f9ba2417", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 85, "deletions": 67, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bd2cdb74e26f68a4e9d51e74ace60326c9950d1/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bd2cdb74e26f68a4e9d51e74ace60326c9950d1/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=4bd2cdb74e26f68a4e9d51e74ace60326c9950d1", "patch": "@@ -164,8 +164,8 @@ vect_free_slp_tree (slp_tree node)\n dump_user_location_t\n _slp_instance::location () const\n {\n-  if (root_stmt)\n-    return root_stmt->stmt;\n+  if (!root_stmts.is_empty ())\n+    return root_stmts[0]->stmt;\n   else\n     return SLP_TREE_SCALAR_STMTS (root)[0]->stmt;\n }\n@@ -178,6 +178,7 @@ vect_free_slp_instance (slp_instance instance)\n {\n   vect_free_slp_tree (SLP_INSTANCE_TREE (instance));\n   SLP_INSTANCE_LOADS (instance).release ();\n+  SLP_INSTANCE_ROOT_STMTS (instance).release ();\n   instance->subgraph_entries.release ();\n   instance->cost_vec.release ();\n   free (instance);\n@@ -2503,7 +2504,7 @@ static bool\n vect_build_slp_instance (vec_info *vinfo,\n \t\t\t slp_instance_kind kind,\n \t\t\t vec<stmt_vec_info> &scalar_stmts,\n-\t\t\t stmt_vec_info root_stmt_info,\n+\t\t\t vec<stmt_vec_info> &root_stmt_infos,\n \t\t\t unsigned max_tree_size, unsigned *limit,\n \t\t\t scalar_stmts_to_slp_tree_map_t *bst_map,\n \t\t\t /* ???  We need stmt_info for group splitting.  */\n@@ -2564,7 +2565,7 @@ vect_build_slp_instance (vec_info *vinfo,\n \t  SLP_INSTANCE_TREE (new_instance) = node;\n \t  SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n \t  SLP_INSTANCE_LOADS (new_instance) = vNULL;\n-\t  SLP_INSTANCE_ROOT_STMT (new_instance) = root_stmt_info;\n+\t  SLP_INSTANCE_ROOT_STMTS (new_instance) = root_stmt_infos;\n \t  SLP_INSTANCE_KIND (new_instance) = kind;\n \t  new_instance->reduc_phis = NULL;\n \t  new_instance->cost_vec = vNULL;\n@@ -2836,13 +2837,20 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   else\n     gcc_unreachable ();\n \n+  vec<stmt_vec_info> roots = vNULL;\n+  if (kind == slp_inst_kind_ctor)\n+    {\n+      roots.create (1);\n+      roots.quick_push (stmt_info);\n+    }\n   /* Build the tree for the SLP instance.  */\n   bool res = vect_build_slp_instance (vinfo, kind, scalar_stmts,\n-\t\t\t\t      kind == slp_inst_kind_ctor\n-\t\t\t\t      ? stmt_info : NULL,\n+\t\t\t\t      roots,\n \t\t\t\t      max_tree_size, limit, bst_map,\n \t\t\t\t      kind == slp_inst_kind_store\n \t\t\t\t      ? stmt_info : NULL);\n+  if (!res)\n+    roots.release ();\n \n   /* ???  If this is slp_inst_kind_store and the above succeeded here's\n      where we should do store group splitting.  */\n@@ -2878,12 +2886,15 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n     {\n       for (unsigned i = 0; i < bb_vinfo->roots.length (); ++i)\n \t{\n-\t  vect_location = bb_vinfo->roots[i].root->stmt;\n+\t  vect_location = bb_vinfo->roots[i].roots[0]->stmt;\n \t  if (vect_build_slp_instance (bb_vinfo, bb_vinfo->roots[i].kind,\n \t\t\t\t       bb_vinfo->roots[i].stmts,\n-\t\t\t\t       bb_vinfo->roots[i].root,\n+\t\t\t\t       bb_vinfo->roots[i].roots,\n \t\t\t\t       max_tree_size, &limit, bst_map, NULL))\n-\t    bb_vinfo->roots[i].stmts = vNULL;\n+\t    {\n+\t      bb_vinfo->roots[i].stmts = vNULL;\n+\t      bb_vinfo->roots[i].roots = vNULL;\n+\t    }\n \t}\n     }\n \n@@ -3741,7 +3752,10 @@ _bb_vec_info::~_bb_vec_info ()\n     }\n \n   for (unsigned i = 0; i < roots.length (); ++i)\n-    roots[i].stmts.release ();\n+    {\n+      roots[i].stmts.release ();\n+      roots[i].roots.release ();\n+    }\n   roots.release ();\n }\n \n@@ -4154,7 +4168,8 @@ vect_slp_analyze_operations (vec_info *vinfo)\n \t\t\t\t\t     &cost_vec)\n \t  /* Instances with a root stmt require vectorized defs for the\n \t     SLP tree root.  */\n-\t  || (SLP_INSTANCE_ROOT_STMT (instance)\n+\t  /* ???  Do inst->kind check instead.  */\n+\t  || (!SLP_INSTANCE_ROOT_STMTS (instance).is_empty ()\n \t      && (SLP_TREE_DEF_TYPE (SLP_INSTANCE_TREE (instance))\n \t\t  != vect_internal_def)))\n         {\n@@ -4460,9 +4475,11 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo,\n       auto_vec<bool, 20> life;\n       life.safe_grow_cleared (SLP_TREE_LANES (SLP_INSTANCE_TREE (instance)),\n \t\t\t      true);\n-      if (SLP_INSTANCE_ROOT_STMT (instance))\n-\trecord_stmt_cost (&scalar_costs, 1, scalar_stmt,\n-\t\t\t  SLP_INSTANCE_ROOT_STMT (instance), 0, vect_body);\n+      if (!SLP_INSTANCE_ROOT_STMTS (instance).is_empty ())\n+\trecord_stmt_cost (&scalar_costs,\n+\t\t\t  SLP_INSTANCE_ROOT_STMTS (instance).length (),\n+\t\t\t  scalar_stmt,\n+\t\t\t  SLP_INSTANCE_ROOT_STMTS (instance)[0], 0, vect_body);\n       vect_bb_slp_scalar_cost (bb_vinfo,\n \t\t\t       SLP_INSTANCE_TREE (instance),\n \t\t\t       &life, &scalar_costs, visited);\n@@ -4691,6 +4708,8 @@ vect_slp_check_for_constructors (bb_vec_info bb_vinfo)\n \t  unsigned lanes_found = 1;\n \t  /* Start with the use chains, the last stmt will be the root.  */\n \t  stmt_vec_info last = bb_vinfo->lookup_stmt (assign);\n+\t  vec<stmt_vec_info> roots = vNULL;\n+\t  roots.safe_push (last);\n \t  do\n \t    {\n \t      use_operand_p use_p;\n@@ -4710,9 +4729,12 @@ vect_slp_check_for_constructors (bb_vec_info bb_vinfo)\n \t      lane_defs.quick_push (std::make_pair\n \t\t\t\t     (this_lane, gimple_assign_rhs2 (use_ass)));\n \t      last = bb_vinfo->lookup_stmt (use_ass);\n+\t      roots.safe_push (last);\n \t      def = gimple_assign_lhs (use_ass);\n \t    }\n \t  while (lanes_found < nlanes);\n+\t  if (roots.length () > 1)\n+\t    std::swap(roots[0], roots[roots.length () - 1]);\n \t  if (lanes_found < nlanes)\n \t    {\n \t      /* Now search the def chain.  */\n@@ -4736,6 +4758,7 @@ vect_slp_check_for_constructors (bb_vec_info bb_vinfo)\n \t\t  lane_defs.quick_push (std::make_pair\n \t\t\t\t\t  (this_lane,\n \t\t\t\t\t   gimple_assign_rhs2 (def_stmt)));\n+\t\t  roots.safe_push (bb_vinfo->lookup_stmt (def_stmt));\n \t\t  def = gimple_assign_rhs1 (def_stmt);\n \t\t}\n \t      while (lanes_found < nlanes);\n@@ -4749,8 +4772,10 @@ vect_slp_check_for_constructors (bb_vec_info bb_vinfo)\n \t      for (unsigned i = 0; i < nlanes; ++i)\n \t\tstmts.quick_push (bb_vinfo->lookup_def (lane_defs[i].second));\n \t      bb_vinfo->roots.safe_push (slp_root (slp_inst_kind_ctor,\n-\t\t\t\t\t\t   stmts, last));\n+\t\t\t\t\t\t   stmts, roots));\n \t    }\n+\t  else\n+\t    roots.release ();\n \t}\n     }\n }\n@@ -4905,22 +4930,11 @@ vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal,\n \t relevant.  */\n       vect_mark_slp_stmts (SLP_INSTANCE_TREE (instance));\n       vect_mark_slp_stmts_relevant (SLP_INSTANCE_TREE (instance));\n-      if (stmt_vec_info root = SLP_INSTANCE_ROOT_STMT (instance))\n-\t{\n-\t  STMT_SLP_TYPE (root) = pure_slp;\n-\t  if (is_gimple_assign (root->stmt)\n-\t      && gimple_assign_rhs_code (root->stmt) == BIT_INSERT_EXPR)\n-\t    {\n-\t      /* ???  We should probably record the whole vector of\n-\t\t root stmts so we do not have to back-track here...  */\n-\t      for (unsigned n = SLP_TREE_LANES (SLP_INSTANCE_TREE (instance));\n-\t\t   n != 1; --n)\n-\t\t{\n-\t\t  root = bb_vinfo->lookup_def (gimple_assign_rhs1 (root->stmt));\n-\t\t  STMT_SLP_TYPE (root) = pure_slp;\n-\t\t}\n-\t    }\n-\t}\n+      unsigned j;\n+      stmt_vec_info root;\n+      /* Likewise consider instance root stmts as vectorized.  */\n+      FOR_EACH_VEC_ELT (SLP_INSTANCE_ROOT_STMTS (instance), j, root)\n+\tSTMT_SLP_TYPE (root) = pure_slp;\n \n       i++;\n     }\n@@ -6357,47 +6371,50 @@ vectorize_slp_instance_root_stmt (slp_tree node, slp_instance instance)\n {\n   gassign *rstmt = NULL;\n \n-  if (SLP_TREE_NUMBER_OF_VEC_STMTS (node) == 1)\n+  if (instance->kind == slp_inst_kind_ctor)\n     {\n-      gimple *child_stmt;\n-      int j;\n-\n-      FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (node), j, child_stmt)\n+      if (SLP_TREE_NUMBER_OF_VEC_STMTS (node) == 1)\n \t{\n-\t  tree vect_lhs = gimple_get_lhs (child_stmt);\n-\t  tree root_lhs = gimple_get_lhs (instance->root_stmt->stmt);\n-\t  if (!useless_type_conversion_p (TREE_TYPE (root_lhs),\n-\t\t\t\t\t  TREE_TYPE (vect_lhs)))\n-\t    vect_lhs = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (root_lhs),\n-\t\t\t       vect_lhs);\n-\t  rstmt = gimple_build_assign (root_lhs, vect_lhs);\n-\t  break;\n-\t}\n-    }\n-  else if (SLP_TREE_NUMBER_OF_VEC_STMTS (node) > 1)\n-    {\n-      int nelts = SLP_TREE_NUMBER_OF_VEC_STMTS (node);\n-      gimple *child_stmt;\n-      int j;\n-      vec<constructor_elt, va_gc> *v;\n-      vec_alloc (v, nelts);\n+\t  gimple *child_stmt;\n+\t  int j;\n \n-      FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (node), j, child_stmt)\n+\t  FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (node), j, child_stmt)\n+\t    {\n+\t      tree vect_lhs = gimple_get_lhs (child_stmt);\n+\t      tree root_lhs = gimple_get_lhs (instance->root_stmts[0]->stmt);\n+\t      if (!useless_type_conversion_p (TREE_TYPE (root_lhs),\n+\t\t\t\t\t      TREE_TYPE (vect_lhs)))\n+\t\tvect_lhs = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (root_lhs),\n+\t\t\t\t   vect_lhs);\n+\t      rstmt = gimple_build_assign (root_lhs, vect_lhs);\n+\t      break;\n+\t    }\n+\t}\n+      else if (SLP_TREE_NUMBER_OF_VEC_STMTS (node) > 1)\n \t{\n-\t  CONSTRUCTOR_APPEND_ELT (v,\n-\t\t\t\t  NULL_TREE,\n-\t\t\t\t  gimple_get_lhs (child_stmt));\n+\t  int nelts = SLP_TREE_NUMBER_OF_VEC_STMTS (node);\n+\t  gimple *child_stmt;\n+\t  int j;\n+\t  vec<constructor_elt, va_gc> *v;\n+\t  vec_alloc (v, nelts);\n+\n+\t  FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (node), j, child_stmt)\n+\t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+\t\t\t\t    gimple_get_lhs (child_stmt));\n+\t  tree lhs = gimple_get_lhs (instance->root_stmts[0]->stmt);\n+\t  tree rtype\n+\t    = TREE_TYPE (gimple_assign_rhs1 (instance->root_stmts[0]->stmt));\n+\t  tree r_constructor = build_constructor (rtype, v);\n+\t  rstmt = gimple_build_assign (lhs, r_constructor);\n \t}\n-      tree lhs = gimple_get_lhs (instance->root_stmt->stmt);\n-      tree rtype = TREE_TYPE (gimple_assign_rhs1 (instance->root_stmt->stmt));\n-      tree r_constructor = build_constructor (rtype, v);\n-      rstmt = gimple_build_assign (lhs, r_constructor);\n     }\n+  else\n+    gcc_unreachable ();\n \n-    gcc_assert (rstmt);\n+  gcc_assert (rstmt);\n \n-    gimple_stmt_iterator rgsi = gsi_for_stmt (instance->root_stmt->stmt);\n-    gsi_replace (&rgsi, rstmt, true);\n+  gimple_stmt_iterator rgsi = gsi_for_stmt (instance->root_stmts[0]->stmt);\n+  gsi_replace (&rgsi, rstmt, true);\n }\n \n struct slp_scc_info\n@@ -6567,9 +6584,10 @@ vect_schedule_slp (vec_info *vinfo, vec<slp_instance> slp_instances)\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"Vectorizing SLP tree:\\n\");\n-\t  if (SLP_INSTANCE_ROOT_STMT (instance))\n+\t  /* ???  Dump all?  */\n+\t  if (!SLP_INSTANCE_ROOT_STMTS (instance).is_empty ())\n \t    dump_printf_loc (MSG_NOTE, vect_location, \"Root stmt: %G\",\n-\t\t\t SLP_INSTANCE_ROOT_STMT (instance)->stmt);\n+\t\t\t SLP_INSTANCE_ROOT_STMTS (instance)[0]->stmt);\n \t  vect_print_slp_graph (MSG_NOTE, vect_location,\n \t\t\t\tSLP_INSTANCE_TREE (instance));\n \t}\n@@ -6579,7 +6597,7 @@ vect_schedule_slp (vec_info *vinfo, vec<slp_instance> slp_instances)\n       if (!scc_info.get (node))\n \tvect_schedule_scc (vinfo, node, instance, scc_info, maxdfs, stack);\n \n-      if (SLP_INSTANCE_ROOT_STMT (instance))\n+      if (!SLP_INSTANCE_ROOT_STMTS (instance).is_empty ())\n \tvectorize_slp_instance_root_stmt (node, instance);\n \n       if (dump_enabled_p ())"}, {"sha": "06d20c775eebfd585d11d0b158add02be9808872", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bd2cdb74e26f68a4e9d51e74ace60326c9950d1/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bd2cdb74e26f68a4e9d51e74ace60326c9950d1/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=4bd2cdb74e26f68a4e9d51e74ace60326c9950d1", "patch": "@@ -197,7 +197,7 @@ typedef class _slp_instance {\n \n   /* For vector constructors, the constructor stmt that the SLP tree is built\n      from, NULL otherwise.  */\n-  stmt_vec_info root_stmt;\n+  vec<stmt_vec_info> root_stmts;\n \n   /* The unrolling factor required to vectorized this SLP instance.  */\n   poly_uint64 unrolling_factor;\n@@ -226,7 +226,7 @@ typedef class _slp_instance {\n #define SLP_INSTANCE_TREE(S)                     (S)->root\n #define SLP_INSTANCE_UNROLLING_FACTOR(S)         (S)->unrolling_factor\n #define SLP_INSTANCE_LOADS(S)                    (S)->loads\n-#define SLP_INSTANCE_ROOT_STMT(S)                (S)->root_stmt\n+#define SLP_INSTANCE_ROOT_STMTS(S)               (S)->root_stmts\n #define SLP_INSTANCE_KIND(S)                     (S)->kind\n \n #define SLP_TREE_CHILDREN(S)                     (S)->children\n@@ -861,11 +861,11 @@ loop_vec_info_for_loop (class loop *loop)\n struct slp_root\n {\n   slp_root (slp_instance_kind kind_, vec<stmt_vec_info> stmts_,\n-\t    stmt_vec_info root_)\n-    : kind(kind_), stmts(stmts_), root(root_) {}\n+\t    vec<stmt_vec_info> roots_)\n+    : kind(kind_), stmts(stmts_), roots(roots_) {}\n   slp_instance_kind kind;\n   vec<stmt_vec_info> stmts;\n-  stmt_vec_info root;\n+  vec<stmt_vec_info> roots;\n };\n \n typedef class _bb_vec_info : public vec_info"}]}