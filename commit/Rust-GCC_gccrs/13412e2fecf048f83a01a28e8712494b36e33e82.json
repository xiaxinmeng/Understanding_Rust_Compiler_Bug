{"sha": "13412e2fecf048f83a01a28e8712494b36e33e82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM0MTJlMmZlY2YwNDhmODNhMDFhMjhlODcxMjQ5NGIzNmUzM2U4Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-11-07T09:22:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-11-07T09:22:50Z"}, "message": "ipa-inline-analysis.c (true_predicate, [...]): Fix formatting.\n\n\t* ipa-inline-analysis.c (true_predicate, single_cond_predicate,\n\treset_inline_edge_summary): Fix\n\tformatting.\n\t(account_size_time): Bump up the limit on number of size/time entries to\n\t256.\n\t(estimate_function_body_sizes): Work in reverse postorder.\n\nFrom-SVN: r193285", "tree": {"sha": "6f11a77b72f936b5348f0ab354b8bff4f5899eb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f11a77b72f936b5348f0ab354b8bff4f5899eb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13412e2fecf048f83a01a28e8712494b36e33e82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13412e2fecf048f83a01a28e8712494b36e33e82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13412e2fecf048f83a01a28e8712494b36e33e82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13412e2fecf048f83a01a28e8712494b36e33e82/comments", "author": null, "committer": null, "parents": [{"sha": "d720a22b6e192786811365dc76824c6242e5f16d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d720a22b6e192786811365dc76824c6242e5f16d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d720a22b6e192786811365dc76824c6242e5f16d"}], "stats": {"total": 30, "additions": 24, "deletions": 6}, "files": [{"sha": "e1b7657e7e00b6394d22ca965e6bf4ad53611156", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13412e2fecf048f83a01a28e8712494b36e33e82/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13412e2fecf048f83a01a28e8712494b36e33e82/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=13412e2fecf048f83a01a28e8712494b36e33e82", "patch": "@@ -1,3 +1,12 @@\n+2012-11-07  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline-analysis.c (true_predicate, single_cond_predicate,\n+\treset_inline_edge_summary): Fix\n+\tformatting.\n+\t(account_size_time): Bump up the limit on number of size/time entries to\n+\t256.\n+\t(estimate_function_body_sizes): Work in reverse postorder.\n+\n 2012-11-07  David S. Miller  <davem@davemloft.net>\n \n \tPR bootstrap/55211"}, {"sha": "15c72ca7f3c3309a616d7aba258a2c11857ff229", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13412e2fecf048f83a01a28e8712494b36e33e82/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13412e2fecf048f83a01a28e8712494b36e33e82/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=13412e2fecf048f83a01a28e8712494b36e33e82", "patch": "@@ -149,7 +149,7 @@ static inline struct predicate\n true_predicate (void)\n {\n   struct predicate p;\n-  p.clause[0]=0;\n+  p.clause[0] = 0;\n   return p;\n }\n \n@@ -160,8 +160,8 @@ static inline struct predicate\n single_cond_predicate (int cond)\n {\n   struct predicate p;\n-  p.clause[0]=1 << cond;\n-  p.clause[1]=0;\n+  p.clause[0] = 1 << cond;\n+  p.clause[1] = 0;\n   return p;\n }\n \n@@ -692,12 +692,14 @@ account_size_time (struct inline_summary *summary, int size, int time,\n \tfound = true;\n         break;\n       }\n-  if (i == 32)\n+  if (i == 256)\n     {\n       i = 0;\n       found = true;\n       e = &VEC_index (size_time_entry, summary->entry, 0);\n       gcc_assert (!e->predicate.clause[0]);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"\\t\\tReached limit on number of entries, ignoring the predicate.\");\n     }\n   if (dump_file && (dump_flags & TDF_DETAILS) && (time || size))\n     {\n@@ -970,7 +972,7 @@ reset_inline_edge_summary (struct cgraph_edge *e)\n     {\n       struct inline_edge_summary *es = inline_edge_summary (e);\n \n-      es->call_stmt_size = es->call_stmt_time =0;\n+      es->call_stmt_size = es->call_stmt_time = 0;\n       if (es->predicate)\n \tpool_free (edge_predicate_pool, es->predicate);\n       es->predicate = NULL;\n@@ -2280,6 +2282,8 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   struct predicate bb_predicate;\n   struct ipa_node_params *parms_info = NULL;\n   VEC (predicate_t, heap) *nonconstant_names = NULL;\n+  int nblocks, n;\n+  int *order;\n \n   info->conds = 0;\n   info->entry = 0;\n@@ -2312,8 +2316,12 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   gcc_assert (my_function && my_function->cfg);\n   if (parms_info)\n     compute_bb_predicates (node, parms_info, info);\n-  FOR_EACH_BB_FN (bb, my_function)\n+  gcc_assert (cfun == my_function);\n+  order = XNEWVEC (int, n_basic_blocks);\n+  nblocks = pre_and_rev_post_order_compute (NULL, order, false);\n+  for (n = 0; n < nblocks; n++)\n     {\n+      bb = BASIC_BLOCK (order[n]);\n       freq = compute_call_stmt_bb_frequency (node->symbol.decl, bb);\n \n       /* TODO: Obviously predicates can be propagated down across CFG.  */\n@@ -2486,6 +2494,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   time = (time + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n   if (time > MAX_TIME)\n     time = MAX_TIME;\n+  free (order);\n \n   if (!early && nonconstant_names)\n     {"}]}