{"sha": "025d57f037ad13eb479818b677ef4be4d97b639c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI1ZDU3ZjAzN2FkMTNlYjQ3OTgxOGI2NzdlZjRiZTRkOTdiNjM5Yw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-11-10T16:35:26Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-11-10T16:35:26Z"}, "message": "PR c/81117 - Improve buffer overflow checking in strncpy\n\ngcc/ChangeLog:\n\n\tPR c/81117\n\t* builtins.c (compute_objsize): Handle arrays that\n\tcompute_builtin_object_size likes to fail for.  Make extern.\n\t* builtins.h (compute_objsize): Declare.\n\t(check_strncpy_sizes): New function.\n\t(expand_builtin_strncpy): Call check_strncpy_sizes.\n\t* gimple-fold.c (gimple_fold_builtin_strncpy): Implement\n\t-Wstringop-truncation.\n\t(gimple_fold_builtin_strncat): Same.\n\t* gimple.c (gimple_build_call_from_tree): Set call location.\n\t* tree-ssa-strlen.c (strlen_to_stridx): New global variable.\n\t(maybe_diag_bound_equal_length, is_strlen_related_p): New functions.\n\t(handle_builtin_stxncpy, handle_builtin_strncat): Same.\n\t(handle_builtin_strlen): Use strlen_to_stridx.\n\t(strlen_optimize_stmt): Handle flavors of strncat, strncpy, and\n\tstpncpy.\n\tUse strlen_to_stridx.\n\t(pass_strlen::execute): Release strlen_to_stridx.\n\t* doc/invoke.texi (-Wsizeof-pointer-memaccess): Document enhancement.\n\t(-Wstringop-truncation): Document new option.\n\ngcc/ada/ChangeLog:\n\n\tPR c/81117\n\t* ada/adadecode.c (__gnat_decode): Use memcpy instead of strncpy.\n\t* ada/argv.c (__gnat_fill_arg, __gnat_fill_env): Same.\n\ngcc/c-family/ChangeLog:\n\n\tPR c/81117\n\t* c-common.c (catenate_strings): Use memcpy instead of strncpy.\n\t* c-warn.c (sizeof_pointer_memaccess_warning): Handle arrays.\n\t* c.opt (-Wstringop-truncation): New option.\n\ngcc/fortran/ChangeLog:\n\n\tPR c/81117\n\t* gcc/fortran/decl.c (build_sym): Use strcpy instead of strncpy.\n\ngcc/objc/ChangeLog:\n\n\tPR c/81117\n\t* objc-encoding.c (encode_type): Use memcpy instead of strncpy.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c/81117\n\t* c-c++-common/Wsizeof-pointer-memaccess3.c: New test.\n\t* c-c++-common/Wstringop-overflow.c: Same.\n\t* c-c++-common/Wstringop-truncation.c: Same.\n\t* c-c++-common/Wsizeof-pointer-memaccess2.c: Adjust.\n\t* c-c++-common/attr-nonstring-2.c: New test.\n\t* g++.dg/torture/Wsizeof-pointer-memaccess1.C: Adjust.\n\t* g++.dg/torture/Wsizeof-pointer-memaccess2.C: Same.\n\t* gcc.dg/torture/pr63554.c: Same.\n\t* gcc.dg/Walloca-1.c: Disable macro tracking.\n\nFrom-SVN: r254630", "tree": {"sha": "28c279950fb42d8f67b86b9a2193b3acc6a669f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28c279950fb42d8f67b86b9a2193b3acc6a669f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/025d57f037ad13eb479818b677ef4be4d97b639c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/025d57f037ad13eb479818b677ef4be4d97b639c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/025d57f037ad13eb479818b677ef4be4d97b639c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/025d57f037ad13eb479818b677ef4be4d97b639c/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e89ce41dbab07a9acafd900a3ab57eeb5d499276", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89ce41dbab07a9acafd900a3ab57eeb5d499276", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e89ce41dbab07a9acafd900a3ab57eeb5d499276"}], "stats": {"total": 1802, "additions": 1726, "deletions": 76}, "files": [{"sha": "7e4093a41e744531e4350b4b8d4a3b5a9e47ff8e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -1,3 +1,26 @@\n+2017-11-10  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81117\n+\t* builtins.c (compute_objsize): Handle arrays that\n+\tcompute_builtin_object_size likes to fail for.  Make extern.\n+\t* builtins.h (compute_objsize): Declare.\n+\t(check_strncpy_sizes): New function.\n+\t(expand_builtin_strncpy): Call check_strncpy_sizes.\n+\t* gimple-fold.c (gimple_fold_builtin_strncpy): Implement\n+\t-Wstringop-truncation.\n+\t(gimple_fold_builtin_strncat): Same.\n+\t* gimple.c (gimple_build_call_from_tree): Set call location.\n+\t* tree-ssa-strlen.c (strlen_to_stridx): New global variable.\n+\t(maybe_diag_bound_equal_length, is_strlen_related_p): New functions.\n+\t(handle_builtin_stxncpy, handle_builtin_strncat): Same.\n+\t(handle_builtin_strlen): Use strlen_to_stridx.\n+\t(strlen_optimize_stmt): Handle flavors of strncat, strncpy, and\n+\tstpncpy.\n+\tUse strlen_to_stridx.\n+\t(pass_strlen::execute): Release strlen_to_stridx.\n+\t* doc/invoke.texi (-Wsizeof-pointer-memaccess): Document enhancement.\n+\t(-Wstringop-truncation): Document new option.\n+\n 2017-11-10  Martin Liska  <mliska@suse.cz>\n \n \tPR gcov-profile/82702"}, {"sha": "7806ad55ed00e8de4137fb7a862c548c07011c00", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -1,3 +1,9 @@\n+2017-11-10  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81117\n+\t* ada/adadecode.c (__gnat_decode): Use memcpy instead of strncpy.\n+\t* ada/argv.c (__gnat_fill_arg, __gnat_fill_env): Same.\n+\n 2017-11-10  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils.c (convert) <RECORD_TYPE>: Add comment and do"}, {"sha": "0cbef8123f98de7462eaafc16fdacfa61553deca", "filename": "gcc/ada/adadecode.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fada%2Fadadecode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fada%2Fadadecode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadadecode.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -330,7 +330,7 @@ __gnat_decode (const char *coded_name, char *ada_name, int verbose)\n \t      }\n \n \t    /* Write symbol in the space.  */\n-\t    strncpy (optoken, trans_table[k][1], oplen);\n+\t    memcpy (optoken, trans_table[k][1], oplen);\n \t  }\n \telse\n \t  k++;"}, {"sha": "aee0f8864430a78dc9d4617618a6810a7ab48b5e", "filename": "gcc/ada/argv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fada%2Fargv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fada%2Fargv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fargv.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -92,7 +92,7 @@ void\n __gnat_fill_arg (char *a, int i)\n {\n   if (gnat_argv != NULL)\n-    strncpy (a, gnat_argv[i], strlen(gnat_argv[i]));\n+    memcpy (a, gnat_argv[i], strlen (gnat_argv[i]));\n }\n \n int\n@@ -118,7 +118,7 @@ void\n __gnat_fill_env (char *a, int i)\n {\n   if (gnat_envp != NULL)\n-    strncpy (a, gnat_envp[i], strlen (gnat_envp[i]));\n+    memcpy (a, gnat_envp[i], strlen (gnat_envp[i]));\n }\n \n #ifdef __cplusplus"}, {"sha": "650de0d9aca71388b7a5cb5cc54bfda341956c21", "filename": "gcc/builtins.c", "status": "modified", "additions": 62, "deletions": 13, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -3260,18 +3260,60 @@ check_sizes (int opt, tree exp, tree size, tree maxlen, tree src, tree objsize)\n }\n \n /* Helper to compute the size of the object referenced by the DEST\n-   expression which must of of pointer type, using Object Size type\n+   expression which must have pointer type, using Object Size type\n    OSTYPE (only the least significant 2 bits are used).  Return\n    the size of the object if successful or NULL when the size cannot\n    be determined.  */\n \n-static inline tree\n+tree\n compute_objsize (tree dest, int ostype)\n {\n   unsigned HOST_WIDE_INT size;\n-  if (compute_builtin_object_size (dest, ostype & 3, &size))\n+\n+  /* Only the two least significant bits are meaningful.  */\n+  ostype &= 3;\n+\n+  if (compute_builtin_object_size (dest, ostype, &size))\n     return build_int_cst (sizetype, size);\n \n+  /* Unless computing the largest size (for memcpy and other raw memory\n+     functions), try to determine the size of the object from its type.  */\n+  if (!ostype)\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (dest) == SSA_NAME)\n+    {\n+      gimple *stmt = SSA_NAME_DEF_STMT (dest);\n+      if (!is_gimple_assign (stmt))\n+\treturn NULL_TREE;\n+\n+      tree_code code = gimple_assign_rhs_code (stmt);\n+      if (code != ADDR_EXPR && code != POINTER_PLUS_EXPR)\n+\treturn NULL_TREE;\n+\n+      dest = gimple_assign_rhs1 (stmt);\n+    }\n+\n+  if (TREE_CODE (dest) != ADDR_EXPR)\n+    return NULL_TREE;\n+\n+  tree type = TREE_TYPE (dest);\n+  if (TREE_CODE (type) == POINTER_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  type = TYPE_MAIN_VARIANT (type);\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      && !array_at_struct_end_p (dest))\n+    {\n+      /* Return the constant size unless it's zero (that's a zero-length\n+\t array likely at the end of a struct).  */\n+      tree size = TYPE_SIZE_UNIT (type);\n+      if (size && TREE_CODE (size) == INTEGER_CST\n+\t  && !integer_zerop (size))\n+\treturn size;\n+    }\n+\n   return NULL_TREE;\n }\n \n@@ -3923,6 +3965,22 @@ expand_builtin_strncat (tree exp, rtx)\n   return NULL_RTX;\n }\n \n+/* Helper to check the sizes of sequences and the destination of calls\n+   to __builtin_strncpy (DST, SRC, CNT) and __builtin___strncpy_chk.\n+   Returns true on success (no overflow warning), false otherwise.  */\n+\n+static bool\n+check_strncpy_sizes (tree exp, tree dst, tree src, tree cnt)\n+{\n+  tree dstsize = compute_objsize (dst, warn_stringop_overflow - 1);\n+\n+  if (!check_sizes (OPT_Wstringop_overflow_,\n+\t\t    exp, cnt, /*maxlen=*/NULL_TREE, src, dstsize))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Expand expression EXP, which is a call to the strncpy builtin.  Return\n    NULL_RTX if we failed the caller should emit a normal call.  */\n \n@@ -3941,16 +3999,7 @@ expand_builtin_strncpy (tree exp, rtx target)\n       /* The length of the source sequence.  */\n       tree slen = c_strlen (src, 1);\n \n-      if (warn_stringop_overflow)\n-\t{\n-\t  tree destsize = compute_objsize (dest,\n-\t\t\t\t\t   warn_stringop_overflow - 1);\n-\n-\t  /* The number of bytes to write is LEN but check_sizes will also\n-\t     check SLEN if LEN's value isn't known.  */\n-\t  check_sizes (OPT_Wstringop_overflow_,\n-\t\t       exp, len, /*maxlen=*/NULL_TREE, src, destsize);\n-\t}\n+      check_strncpy_sizes (exp, dest, src, len);\n \n       /* We must be passed a constant len and src parameter.  */\n       if (!tree_fits_uhwi_p (len) || !slen || !tree_fits_uhwi_p (slen))"}, {"sha": "cf3fc17ac08d7a6fd5e68fd0653b05c07cd1874b", "filename": "gcc/builtins.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -89,6 +89,7 @@ extern tree fold_call_stmt (gcall *, bool);\n extern void set_builtin_user_assembler_name (tree decl, const char *asmspec);\n extern bool is_simple_builtin (tree);\n extern bool is_inexpensive_builtin (tree);\n+extern tree compute_objsize (tree, int);\n \n extern bool readonly_data_expr (tree exp);\n extern bool init_target_chars (void);"}, {"sha": "7e47cb8cf496075cd428217043842b3ce597b460", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -1,3 +1,10 @@\n+2017-11-10  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81117\n+\t* c-common.c (catenate_strings): Use memcpy instead of strncpy.\n+\t* c-warn.c (sizeof_pointer_memaccess_warning): Handle arrays.\n+\t* c.opt (-Wstringop-truncation): New option.\n+\n 2017-11-06  Martin Liska  <mliska@suse.cz>\n \n \tPR middle-end/82404"}, {"sha": "a76fae7f8fc8710619e4a8667eba555f5f64aaf0", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -5890,10 +5890,10 @@ check_builtin_function_arguments (location_t loc, vec<location_t> arg_loc,\n static char *\n catenate_strings (const char *lhs, const char *rhs_start, int rhs_size)\n {\n-  const int lhs_size = strlen (lhs);\n+  const size_t lhs_size = strlen (lhs);\n   char *result = XNEWVEC (char, lhs_size + rhs_size);\n-  strncpy (result, lhs, lhs_size);\n-  strncpy (result + lhs_size, rhs_start, rhs_size);\n+  memcpy (result, lhs, lhs_size);\n+  memcpy (result + lhs_size, rhs_start, rhs_size);\n   return result;\n }\n "}, {"sha": "6cfded97e2454a89f404c6c41038310dbb70141c", "filename": "gcc/c-family/c-warn.c", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fc-family%2Fc-warn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fc-family%2Fc-warn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -693,7 +693,8 @@ sizeof_pointer_memaccess_warning (location_t *sizeof_arg_loc, tree callee,\n       || vec_safe_length (params) <= 1)\n     return;\n \n-  switch (DECL_FUNCTION_CODE (callee))\n+  enum built_in_function fncode = DECL_FUNCTION_CODE (callee);\n+  switch (fncode)\n     {\n     case BUILT_IN_STRNCMP:\n     case BUILT_IN_STRNCASECMP:\n@@ -775,8 +776,27 @@ sizeof_pointer_memaccess_warning (location_t *sizeof_arg_loc, tree callee,\n \n   type = TYPE_P (sizeof_arg[idx])\n \t ? sizeof_arg[idx] : TREE_TYPE (sizeof_arg[idx]);\n+\n   if (!POINTER_TYPE_P (type))\n-    return;\n+    {\n+      /* The argument type may be an array.  Diagnose bounded string\n+\t copy functions that specify the bound in terms of the source\n+\t argument rather than the destination.  */\n+      if (strop && !cmp && fncode != BUILT_IN_STRNDUP && src)\n+\t{\n+\t  tem = tree_strip_nop_conversions (src);\n+\t  if (TREE_CODE (tem) == ADDR_EXPR)\n+\t    tem = TREE_OPERAND (tem, 0);\n+\t  if (operand_equal_p (tem, sizeof_arg[idx], OEP_ADDRESS_OF))\n+\t    warning_at (sizeof_arg_loc[idx], OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the source; did you mean to use \"\n+\t\t\t\"the size of the destination?\",\n+\t\t\tcallee);\n+\t}\n+\n+      return;\n+    }\n \n   if (dest\n       && (tem = tree_strip_nop_conversions (dest))"}, {"sha": "479ae63bb0e1bf197532a5b63844cf016a2c2c1b", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -744,6 +744,10 @@ C ObjC C++ ObjC++ Joined RejectNegative UInteger Var(warn_stringop_overflow) Ini\n Under the control of Object Size type, warn about buffer overflow in string\n manipulation functions like memcpy and strcpy.\n \n+Wstringop-truncation\n+C ObjC C++ ObjC++ Var(warn_stringop_truncation) Warning Init (1) LangEnabledBy(C ObjC C++ ObjC++, Wall)\n+Warn about truncation in string manipulation functions like strncat and strncpy.\n+\n Wsuggest-attribute=format\n C ObjC C++ ObjC++ Var(warn_suggest_attribute_format) Warning\n Warn about functions which might be candidates for format attributes."}, {"sha": "44273284483e2595de557b20c3f068050a4b3a2c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 70, "deletions": 6, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -314,7 +314,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wsizeof-pointer-memaccess  -Wsizeof-array-argument @gol\n -Wstack-protector  -Wstack-usage=@var{len}  -Wstrict-aliasing @gol\n -Wstrict-aliasing=n  -Wstrict-overflow  -Wstrict-overflow=@var{n} @gol\n--Wstringop-overflow=@var{n} @gol\n+-Wstringop-overflow=@var{n} -Wstringop-truncation @gol\n -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{|}malloc@r{]} @gol\n -Wsuggest-final-types @gol  -Wsuggest-final-methods  -Wsuggest-override @gol\n -Wmissing-format-attribute  -Wsubobject-linkage @gol\n@@ -5214,6 +5214,55 @@ whether to issue a warning.  Similarly to @option{-Wstringop-overflow=3} this\n setting of the option may result in warnings for benign code.\n @end table\n \n+@item -Wstringop-truncation\n+@opindex Wstringop-truncation\n+@opindex Wno-stringop-truncation\n+Warn for calls to bounded string manipulation functions such as @code{strncat},\n+@code{strncpy}, and @code{stpncpy} that may either truncate the copied string\n+or leave the destination unchanged.\n+\n+In the following example, the call to @code{strncat} specifies a bound that\n+is less than the length of the source string.  As a result, the copy of\n+the source will be truncated and so the call is diagnosed.  To avoid the\n+warning use @code{bufsize - strlen (buf) - 1)} as the bound.\n+\n+@smallexample\n+void append (char *buf, size_t bufsize)\n+@{\n+  strncat (buf, \".txt\", 3);\n+@}\n+@end smallexample\n+\n+As another example, the following call to @code{strncpy} results in copying\n+to @code{d} just the characters preceding the terminating NUL, without\n+appending the NUL to the end.  Assuming the result of @code{strncpy} is\n+necessarily a NUL-terminated string is a common mistake, and so the call\n+is diagnosed.  To avoid the warning when the result is not expected to be\n+NUL-terminated, call @code{memcpy} instead.\n+\n+@smallexample\n+void copy (char *d, const char *s)\n+@{\n+  strncpy (d, s, strlen (s));\n+@}\n+@end smallexample\n+\n+In the following example, the call to @code{strncpy} specifies the size\n+of the destination buffer as the bound.  If the length of the source\n+string is equal to or greater than this size the result of the copy will\n+not be NUL-terminated.  Therefore, the call is also diagnosed.  To avoid\n+the warning, specify @code{sizeof buf - 1} as the bound and set the last\n+element of the buffer to @code{NUL}.\n+\n+@smallexample\n+void copy (const char *s)\n+@{\n+  char buf[80];\n+  strncpy (buf, s, sizeof buf);\n+  @dots{}\n+@}\n+@end smallexample\n+\n @item -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{|}cold@r{|}malloc@r{]}\n @opindex Wsuggest-attribute=\n @opindex Wno-suggest-attribute=\n@@ -6230,11 +6279,26 @@ not an array, but a pointer.  This warning is enabled by @option{-Wall}.\n @opindex Wsizeof-pointer-memaccess\n @opindex Wno-sizeof-pointer-memaccess\n Warn for suspicious length parameters to certain string and memory built-in\n-functions if the argument uses @code{sizeof}.  This warning warns e.g.@:\n-about @code{memset (ptr, 0, sizeof (ptr));} if @code{ptr} is not an array,\n-but a pointer, and suggests a possible fix, or about\n-@code{memcpy (&foo, ptr, sizeof (&foo));}.  This warning is enabled by\n-@option{-Wall}.\n+functions if the argument uses @code{sizeof}.  This warning triggers for\n+example for @code{memset (ptr, 0, sizeof (ptr));} if @code{ptr} is not\n+an array, but a pointer, and suggests a possible fix, or about\n+@code{memcpy (&foo, ptr, sizeof (&foo));}.  @option{-Wsizeof-pointer-memaccess}\n+also warns about calls to bounded string copy functions like @code{strncat}\n+or @code{strncpy} that specify as the bound a @code{sizeof} expression of\n+the source array.  For example, in the following function the call to\n+@code{strncat} specifies the size of the source string as the bound.  That\n+is almost certainly a mistake and so the call is diagnosed.\n+@smallexample\n+void make_file (const char *name)\n+@{\n+  char path[PATH_MAX];\n+  strncpy (path, name, sizeof path - 1);\n+  strncat (path, \".text\", sizeof \".text\");\n+  @dots{}\n+@}\n+@end smallexample\n+\n+The @option{-Wsizeof-pointer-memaccess} option is enabled by @option{-Wall}.\n \n @item -Wsizeof-array-argument\n @opindex Wsizeof-array-argument"}, {"sha": "6578f7d4197a63dc3a1ff8873c9cbe9c11fbf3c1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -1,3 +1,8 @@\n+2017-11-10  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81117\n+\t* gcc/fortran/decl.c (build_sym): Use strcpy instead of strncpy.\n+\n 2017-11-10  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/82934"}, {"sha": "11264e757e6b87c90db074d2b052de3875fdd4d6", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -1427,11 +1427,9 @@ build_sym (const char *name, gfc_charlen *cl, bool cl_deferred,\n     {\n       char u_name[GFC_MAX_SYMBOL_LEN + 1];\n       gfc_symtree *st;\n-      int nlen;\n \n-      nlen = strlen(name);\n-      gcc_assert (nlen <= GFC_MAX_SYMBOL_LEN);\n-      strncpy (u_name, name, nlen + 1);\n+      gcc_assert (strlen(name) <= GFC_MAX_SYMBOL_LEN);\n+      strcpy (u_name, name);\n       u_name[0] = upper;\n \n       st = gfc_find_symtree (gfc_current_ns->sym_root, u_name);"}, {"sha": "adb6f3baf933445d1a559e4b39014f355eb66402", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 135, "deletions": 18, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-iterator.h\"\n #include \"tree-into-ssa.h\"\n #include \"tree-dfa.h\"\n+#include \"tree-object-size.h\"\n #include \"tree-ssa.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"ipa-utils.h\"\n@@ -59,6 +60,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"asan.h\"\n+#include \"diagnostic-core.h\"\n+#include \"intl.h\"\n \n /* Return true when DECL can be referenced from current unit.\n    FROM_DECL (if non-null) specify constructor of variable DECL was taken from.\n@@ -1553,12 +1556,28 @@ static bool\n gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi,\n \t\t\t     tree dest, tree src, tree len)\n {\n-  location_t loc = gimple_location (gsi_stmt (*gsi));\n-  tree fn;\n+  gimple *stmt = gsi_stmt (*gsi);\n+  location_t loc = gimple_location (stmt);\n \n   /* If the LEN parameter is zero, return DEST.  */\n   if (integer_zerop (len))\n     {\n+      tree fndecl = gimple_call_fndecl (stmt);\n+      gcall *call = as_a <gcall *> (stmt);\n+\n+      /* Warn about the lack of nul termination: the result is not\n+\t a (nul-terminated) string.  */\n+      tree slen = get_maxval_strlen (src, 0);\n+      if (slen && !integer_zerop (slen))\n+\twarning_at (loc, OPT_Wstringop_truncation,\n+\t\t    \"%G%qD destination unchanged after copying no bytes \"\n+\t\t    \"from a string of length %E\",\n+\t\t    call, fndecl, slen);\n+      else\n+\twarning_at (loc, OPT_Wstringop_truncation,\n+\t\t    \"%G%qD destination unchanged after copying no bytes\",\n+\t\t    call, fndecl);\n+\n       replace_call_with_value (gsi, dest);\n       return true;\n     }\n@@ -1573,16 +1592,66 @@ gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi,\n   if (!slen || TREE_CODE (slen) != INTEGER_CST)\n     return false;\n \n-  slen = size_binop_loc (loc, PLUS_EXPR, slen, ssize_int (1));\n+  /* The size of the source string including the terminating nul.  */\n+  tree ssize = size_binop_loc (loc, PLUS_EXPR, slen, ssize_int (1));\n \n   /* We do not support simplification of this case, though we do\n      support it when expanding trees into RTL.  */\n   /* FIXME: generate a call to __builtin_memset.  */\n-  if (tree_int_cst_lt (slen, len))\n+  if (tree_int_cst_lt (ssize, len))\n     return false;\n \n+  if (tree_int_cst_lt (len, slen))\n+    {\n+      tree fndecl = gimple_call_fndecl (stmt);\n+      gcall *call = as_a <gcall *> (stmt);\n+\n+      warning_at (loc, OPT_Wstringop_truncation,\n+\t\t  (tree_int_cst_equal (size_one_node, len)\n+\t\t   ? G_(\"%G%qD output truncated copying %E byte \"\n+\t\t\t\"from a string of length %E\")\n+\t\t   : G_(\"%G%qD output truncated copying %E bytes \"\n+\t\t      \"from a string of length %E\")),\n+\t\t  call, fndecl, len, slen);\n+    }\n+  else if (tree_int_cst_equal (len, slen))\n+    {\n+      tree decl = dest;\n+      if (TREE_CODE (decl) == SSA_NAME)\n+\t{\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (decl);\n+\t  if (is_gimple_assign (def_stmt))\n+\t    {\n+\t      tree_code code = gimple_assign_rhs_code (def_stmt);\n+\t      if (code == ADDR_EXPR || code == VAR_DECL)\n+\t\tdecl = gimple_assign_rhs1 (def_stmt);\n+\t    }\n+\t}\n+\n+      if (TREE_CODE (decl) == ADDR_EXPR)\n+\tdecl = TREE_OPERAND (decl, 0);\n+\n+      if (TREE_CODE (decl) == COMPONENT_REF)\n+\tdecl = TREE_OPERAND (decl, 1);\n+\n+      tree fndecl = gimple_call_fndecl (stmt);\n+      gcall *call = as_a <gcall *> (stmt);\n+\n+      if (!DECL_P (decl)\n+\t  || !lookup_attribute (\"nonstring\", DECL_ATTRIBUTES (decl)))\n+\twarning_at (loc, OPT_Wstringop_truncation,\n+\t\t    (tree_int_cst_equal (size_one_node, len)\n+\t\t     ? G_(\"%G%qD output truncated before terminating nul \"\n+\t\t\t  \"copying %E byte from a string of the same \"\n+\t\t\t  \"length\")\n+\t\t     : G_(\"%G%qD output truncated before terminating nul \"\n+\t\t\t  \"copying %E bytes from a string of the same \"\n+\t\t\t  \"length\")),\n+\t\t    call, fndecl, len);\n+    }\n+\n   /* OK transform into builtin memcpy.  */\n-  fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n+  tree fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n   if (!fn)\n     return false;\n \n@@ -1591,6 +1660,7 @@ gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi,\n \t\t\t\t  NULL_TREE, true, GSI_SAME_STMT);\n   gimple *repl = gimple_build_call (fn, 3, dest, src, len);\n   replace_call_with_call_and_fold (gsi, repl);\n+\n   return true;\n }\n \n@@ -1887,24 +1957,71 @@ gimple_fold_builtin_strncat (gimple_stmt_iterator *gsi)\n       return true;\n     }\n \n-  /* If the requested len is greater than or equal to the string\n-     length, call strcat.  */\n-  if (TREE_CODE (len) == INTEGER_CST && p\n-      && compare_tree_int (len, strlen (p)) >= 0)\n+  if (TREE_CODE (len) != INTEGER_CST || !p)\n+    return false;\n+\n+  unsigned srclen = strlen (p);\n+\n+  int cmpsrc = compare_tree_int (len, srclen);\n+\n+  /* Return early if the requested len is less than the string length.\n+     Warnings will be issued elsewhere later.  */\n+  if (cmpsrc < 0)\n+    return false;\n+\n+  unsigned HOST_WIDE_INT dstsize;\n+\n+  bool nowarn = gimple_no_warning_p (stmt);\n+\n+  if (!nowarn && compute_builtin_object_size (dst, 1, &dstsize))\n     {\n-      tree fn = builtin_decl_implicit (BUILT_IN_STRCAT);\n+      int cmpdst = compare_tree_int (len, dstsize);\n \n-      /* If the replacement _DECL isn't initialized, don't do the\n-\t transformation.  */\n-      if (!fn)\n-\treturn false;\n+      if (cmpdst >= 0)\n+\t{\n+\t  tree fndecl = gimple_call_fndecl (stmt);\n+\n+\t  /* Strncat copies (at most) LEN bytes and always appends\n+\t     the terminating NUL so the specified bound should never\n+\t     be equal to (or greater than) the size of the destination.\n+\t     If it is, the copy could overflow.  */\n+\t  location_t loc = gimple_location (stmt);\n+\t  nowarn = warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t       cmpdst == 0\n+\t\t\t       ? G_(\"%G%qD specified bound %E equals \"\n+\t\t\t\t    \"destination size\")\n+\t\t\t       : G_(\"%G%qD specified bound %E exceeds \"\n+\t\t\t\t    \"destination size %wu\"),\n+\t\t\t       stmt, fndecl, len, dstsize);\n+\t  if (nowarn)\n+\t    gimple_set_no_warning (stmt, true);\n+\t}\n+    }\n \n-      gcall *repl = gimple_build_call (fn, 2, dst, src);\n-      replace_call_with_call_and_fold (gsi, repl);\n-      return true;\n+  if (!nowarn && cmpsrc == 0)\n+    {\n+      tree fndecl = gimple_call_fndecl (stmt);\n+\n+      /* To avoid certain truncation the specified bound should also\n+\t not be equal to (or less than) the length of the source.  */\n+      location_t loc = gimple_location (stmt);\n+      if (warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t      \"%G%qD specified bound %E equals source length\",\n+\t\t      stmt, fndecl, len))\n+\tgimple_set_no_warning (stmt, true);\n     }\n \n-  return false;\n+  tree fn = builtin_decl_implicit (BUILT_IN_STRCAT);\n+\n+  /* If the replacement _DECL isn't initialized, don't do the\n+     transformation.  */\n+  if (!fn)\n+    return false;\n+\n+  /* Otherwise, emit a call to strcat.  */\n+  gcall *repl = gimple_build_call (fn, 2, dst, src);\n+  replace_call_with_call_and_fold (gsi, repl);\n+  return true;\n }\n \n /* Fold a call to the __strncat_chk builtin with arguments DEST, SRC,"}, {"sha": "c986a73200461d183bffbfc892dc05a0573275ae", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -361,6 +361,7 @@ gimple_build_call_from_tree (tree t, tree fnptrtype)\n     gimple_call_set_arg (call, i, CALL_EXPR_ARG (t, i));\n \n   gimple_set_block (call, TREE_BLOCK (t));\n+  gimple_set_location (call, EXPR_LOCATION (t));\n \n   /* Carry all the CALL_EXPR flags to the new GIMPLE_CALL.  */\n   gimple_call_set_chain (call, CALL_EXPR_STATIC_CHAIN (t));"}, {"sha": "f87294be8f50abfc3cb09cd82b096e07edd2e604", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -1,3 +1,8 @@\n+2017-11-10  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81117\n+\t* objc-encoding.c (encode_type): Use memcpy instead of strncpy.\n+\n 2017-10-31  David Malcolm  <dmalcolm@redhat.com>\n \n \t* objc-gnu-runtime-abi-01.c (objc_gnu_runtime_abi_01_init): Use"}, {"sha": "f9d8d477d76909ac7997e311d5a311fadc64165b", "filename": "gcc/objc/objc-encoding.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fobjc%2Fobjc-encoding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Fobjc%2Fobjc-encoding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-encoding.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -734,7 +734,7 @@ encode_type (tree type, int curtype, int format)\n \n \t  /* Rewrite \"in const\" from \"nr\" to \"rn\".  */\n \t  if (curtype >= 1 && !strncmp (enc - 1, \"nr\", 2))\n-\t    strncpy (enc - 1, \"rn\", 2);\n+\t    memcpy (enc - 1, \"rn\", 2);\n \t}\n     }\n }"}, {"sha": "948c8b148a4620d3a2fd9c2ece4fd410292fcb4b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -1,3 +1,17 @@\n+2017-11-10  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81117\n+\t* c-c++-common/Wsizeof-pointer-memaccess3.c: New test.\n+\t* c-c++-common/Wstringop-overflow.c: Same.\n+\t* c-c++-common/Wstringop-truncation.c: Same.\n+\t* c-c++-common/Wsizeof-pointer-memaccess2.c: Adjust.\n+\t* c-c++-common/attr-nonstring-2.c: New test.\n+\t* gcc/testsuite/gcc.dg/builtin-stpncpy.c: Adjust.\n+\t* g++.dg/torture/Wsizeof-pointer-memaccess1.C: Same.\n+\t* g++.dg/torture/Wsizeof-pointer-memaccess2.C: Same.\n+\t* gcc.dg/torture/pr63554.c: Same.\n+\t* gcc.dg/Walloca-1.c: Disable macro tracking.\n+\n 2017-11-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/82929"}, {"sha": "f7bfa35913c492d6efcc7cbd40ee80c1d9fe04c0", "filename": "gcc/testsuite/c-c++-common/Wsizeof-pointer-memaccess2.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess2.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -1,7 +1,7 @@\n /* Test -Wsizeof-pointer-memaccess warnings.  */\n /* { dg-do compile } */\n-/* { dg-options \"-Wall -O2 -Wno-sizeof-array-argument -ftrack-macro-expansion=0\" } */\n-/* { dg-options \"-Wall -O2 -Wno-sizeof-array-argument -Wno-c++-compat -ftrack-macro-expansion=0\" {target c} } */\n+/* { dg-options \"-Wall -O2 -Wno-sizeof-array-argument -Wno-stringop-truncation -ftrack-macro-expansion=0\" } */\n+/* { dg-options \"-Wall -O2 -Wno-sizeof-array-argument -Wno-stringop-truncation -Wno-c++-compat -ftrack-macro-expansion=0\" {target c} } */\n /* { dg-require-effective-target alloca } */\n \n #define bos(ptr) __builtin_object_size (ptr, 1)\n@@ -473,12 +473,15 @@ f4 (char *x, char **y, int z, char w[64])\n   strncat (w, s2, sizeof (w));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n   stpncpy (w, s1, sizeof (w));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n \n-  /* These are correct, no warning.  */\n+  /* These are pointless when the destination is large enough, and\n+     cause overflow otherwise.  If the copies are guaranteed to be\n+     safe the calls might as well be replaced by strcat(), strcpy(),\n+     or memcpy().  */\n   const char s3[] = \"foobarbaz\";\n   const char s4[] = \"abcde12345678\";\n-  strncpy (x, s3, sizeof (s3));\n-  strncat (x, s4, sizeof (s4));\n-  stpncpy (x, s3, sizeof (s3));\n+  strncpy (x, s3, sizeof (s3));             /* { dg-warning \"call is the same expression as the source; did you mean to use the size of the destination?\" } */\n+  strncat (x, s4, sizeof (s4));             /* { dg-warning \"call is the same expression as the source; did you mean to use the size of the destination?\" } */\n+  stpncpy (x, s3, sizeof (s3));             /* { dg-warning \"call is the same expression as the source; did you mean to use the size of the destination?\" } */\n }\n \n /* { dg-prune-output \"\\[\\n\\r\\]*writing\\[\\n\\r\\]*\" } */"}, {"sha": "97598c423464bd89d86ac56d1f4a4c42e654aa76", "filename": "gcc/testsuite/c-c++-common/Wsizeof-pointer-memaccess3.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess3.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -0,0 +1,132 @@\n+/* Test -Wsizeof-pointer-memaccess warnings.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wsizeof-pointer-memaccess -Wno-stringop-overflow -Wno-stringop-truncation -ftrack-macro-expansion=0\" } */\n+\n+#define bos(ptr) __builtin_object_size (ptr, 1)\n+#define bos0(ptr) __builtin_object_size (ptr, 0)\n+\n+#define memset(dst, val, sz) \\\n+  (FUNC (memset, dst, val, sz, bos (dst)), sink ((dst)))\n+\n+#define memcpy(dst, src, sz) \\\n+  (FUNC (memcpy, dst, src, sz, bos (dst)), sink ((dst)))\n+\n+#define memmove(dst, src, sz) \\\n+  (FUNC (memmove, dst, src, sz, bos (dst)), sink ((dst)))\n+\n+#define mempcpy(dst, src, sz) \\\n+  (FUNC (mempcpy, dst, src, sz, bos (dst)), sink ((dst)))\n+\n+#define strncpy(dst, src, sz)\t\t\t\t\\\n+  (FUNC (strncpy, dst, src, sz, bos (dst)), sink (dst))\n+\n+#define strncat(dst, src, sz) \\\n+  (FUNC (strncat, dst, src, sz, bos (dst)), sink (dst))\n+\n+#define stpncpy(dst, src, sz) \\\n+  (FUNC (stpncpy, dst, src, sz, bos (dst)), sink (dst))\n+\n+void sink (void*);\n+\n+#define S10 \"123456789\"\n+extern char a10[10];\n+\n+void test_string_literal (char *dst)\n+{\n+#define FUNC(f, d, s, n, x) __builtin_ ## f (d, s, n)\n+\n+  /* It's common to call memcpy and other raw memory functions with\n+     size drerived from the source argument.  Verify that no warning\n+     is ussued for such calls.  */\n+  memcpy (dst, S10, sizeof S10);\n+  mempcpy (dst, S10, sizeof S10);\n+  memmove (dst, S10, sizeof S10);\n+\n+  memset (dst, 0, sizeof S10);\n+\n+  stpncpy (dst, S10, sizeof S10);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" } */\n+\n+  strncpy (dst, S10, sizeof S10);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" } */\n+\n+  strncat (dst, S10, sizeof S10);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" } */\n+\n+  /* Unlike in the cases above, even though the calls below are likely\n+     wrong, it's not easy to detect that  the expression (sizeof X - 1)\n+     involves sizeof of the source, so no warning is issued here, as\n+     helpful as one might be.  Whether -Wstringop-truncation is issued\n+     is tested elsewhere.  */\n+  stpncpy (dst, S10, sizeof S10 - 1);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" \"\" { xfail *-*-* } } */\n+\n+  strncpy (dst, S10, sizeof S10 - 1);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" \"\" { xfail *-*-* } } */\n+\n+  strncat (dst, S10, sizeof S10 - 1);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" \"\" { xfail *-*-* } } */\n+}\n+\n+\n+void test_char_array (char *dst)\n+{\n+  memcpy (dst, a10, sizeof a10);\n+  mempcpy (dst, a10, sizeof a10);\n+  memmove (dst, a10, sizeof a10);\n+\n+  memset (dst, 0, sizeof a10);\n+\n+  stpncpy (dst, a10, sizeof a10);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" } */\n+\n+  strncpy (dst, a10, sizeof a10);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" } */\n+\n+  strncat (dst, a10, sizeof a10);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" } */\n+\n+  stpncpy (dst, a10, sizeof a10 - 1);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" \"\" { xfail *-*-* } } */\n+\n+  strncpy (dst, a10, sizeof a10 - 1);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" \"\" { xfail *-*-* } } */\n+\n+  strncat (dst, a10, sizeof a10 - 1);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" \"\" { xfail *-*-* } } */\n+}\n+\n+\n+#undef FUNC\n+#define FUNC(f, d, s, n, os) __builtin___ ## f ## _chk (d, s, n, os)\n+\n+void test_char_array_chk (char *dst)\n+{\n+  memcpy (dst, S10, sizeof S10);\n+  mempcpy (dst, S10, sizeof S10);\n+  memmove (dst, S10, sizeof S10);\n+\n+  memset (dst, 0, sizeof S10);\n+\n+  stpncpy (dst, S10, sizeof S10);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" } */\n+\n+  strncpy (dst, S10, sizeof S10);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" } */\n+\n+  strncat (dst, S10, sizeof S10);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" } */\n+\n+  stpncpy (dst, S10, sizeof S10 - 1);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" \"\" { xfail *-*-* } } */\n+\n+  strncpy (dst, S10, sizeof S10 - 1);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" \"\" { xfail *-*-* } } */\n+\n+  strncat (dst, S10, sizeof S10 - 1);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" \"\" { xfail *-*-* } } */\n+}\n+\n+\n+void test_string_literal_chk (char *dst)\n+{\n+  memcpy (dst, a10, sizeof a10);\n+  mempcpy (dst, a10, sizeof a10);\n+  memmove (dst, a10, sizeof a10);\n+\n+  memset (dst, 0, sizeof a10);\n+\n+  stpncpy (dst, a10, sizeof a10);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" } */\n+\n+  strncpy (dst, a10, sizeof a10);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" } */\n+\n+  strncat (dst, a10, sizeof a10);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" } */\n+\n+  stpncpy (dst, a10, sizeof a10 - 1);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" \"\" { xfail *-*-* } } */\n+\n+  strncpy (dst, a10, sizeof a10 - 1);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" \"\" { xfail *-*-* } } */\n+\n+  strncat (dst, a10, sizeof a10 - 1);   /* { dg-warning \"\\\\\\[-Wsizeof-pointer-memaccess]\" \"\" { xfail *-*-* } } */\n+}"}, {"sha": "53f5166f30a7f6e94fa70b9d632b0d5e7539dd34", "filename": "gcc/testsuite/c-c++-common/Wstringop-overflow.c", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -0,0 +1,158 @@\n+/* PR middle-end/81117 - Improve buffer overflow checking in strncpy\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wstringop-overflow -Wno-stringop-truncation -ftrack-macro-expansion=0\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#if __cplusplus\n+extern \"C\" {\n+#endif\n+\n+size_t strlen (const char*);\n+char* strncat (char*, const char*, size_t);\n+char* strncpy (char*, const char*, size_t);\n+#if __cplusplus\n+}\n+#endif\n+\n+const char ar[] = \"123\";\n+\n+void test_strncat (char **d, const char* s, int i)\n+{\n+  /* Use a fresh pointer for each test to prevent the optimizer from\n+     eliminating redundant writes into the same destination.  Avoid\n+     calling functions like sink() on the result that would have to\n+     be assumed to change the source string by the alias oracle.  */\n+#define T(d, s, len) strncat (*d++, (s), (len))\n+\n+  T (d, \"\",    0);\n+  T (d, \"\",    1);\n+  T (d, \"\",    2);\n+  T (d, \"\",    3);\n+  T (d, \"123\", 0);\n+  /* The following two calls truncate the copy and are diagnosed\n+     by -Wstringop-truncation but there is evidence of overflow so\n+     they're not diagnosed by -Wstringop-overflow.  */\n+  T (d, \"123\", 1);\n+  T (d, \"123\", 2);\n+\n+  T (d, \"123\", 3);                /* { dg-warning \".strncat\\[^\\n\\r\\]* specified bound 3 equals source length\" } */\n+  T (d, \"123\", 4);\n+  T (d, \"123\", 9);\n+\n+  T (d, s, strlen (s));           /* { dg-warning \".strncat\\[^\\n\\r\\]* specified bound depends on the length of the source argument\" } */\n+  T (d, s, strlen (s) + 1);       /* { dg-warning \".strncat\\[^\\n\\r\\]* specified bound depends on the length of the source argument\" } */\n+  /* The following could also be diagnosed by -Wstringop-truncation\n+     (with some effort to distinguish the pattern from others like\n+     the one above.  */\n+  T (d, s, strlen (s) - 1);       /* { dg-warning \".strncat\\[^\\n\\r\\]* specified bound depends on the length of the source argument\" } */\n+  T (d, s, strlen (s) - i);       /* { dg-warning \".strncat\\[^\\n\\r\\]* specified bound depends on the length of the source argument\" } */\n+\n+  /* The following is dubious but not necessarily a smoking gun.  */\n+  T (d, s, strlen (s) - strlen (s));\n+\n+  {\n+    signed char n = strlen (s);   /* { dg-message \"length computed here\" } */\n+    T (d, s, n);                  /* { dg-warning \".strncat\\[^\\n\\r\\]* specified bound depends on the length of the source argument\" } */\n+  }\n+\n+  {\n+    short n = strlen (s);         /* { dg-message \"length computed here\" } */\n+    T (d, s, n);                  /* { dg-warning \".strncat\\[^\\n\\r\\]* specified bound depends on the length of the source argument\" } */\n+  }\n+\n+  {\n+    int n = strlen (s);           /* { dg-message \"length computed here\" } */\n+    T (d, s, n);                  /* { dg-warning \".strncat\\[^\\n\\r\\]* specified bound depends on the length of the source argument\" } */\n+  }\n+\n+  {\n+    unsigned n = strlen (s);      /* { dg-message \"length computed here\" } */\n+    T (d, s, n);                  /* { dg-warning \".strncat\\[^\\n\\r\\]* specified bound depends on the length of the source argument\" } */\n+  }\n+\n+  {\n+    size_t n;\n+    n = strlen (s);               /* { dg-message \"length computed here\" } */\n+    T (d, s, n);                  /* { dg-warning \".strncat\\[^\\n\\r\\]* specified bound depends on the length of the source argument\" } */\n+  }\n+\n+  {\n+    size_t n;\n+    n = strlen (s) - 1;           /* { dg-message \"length computed here\" } */\n+    T (d, s, n);                  /* { dg-message \".strncat\\[^\\n\\r\\]* specified bound depends on the length of the source argument\" } */\n+  }\n+\n+  {\n+    /* This doesn't overflow so iit should not be diagnosed.  */\n+    size_t n = strlen (s) - strlen (s);\n+    T (d, s, n);\n+  }\n+\n+  {\n+    size_t n = i < strlen (s) ? i : strlen (s);   /* { dg-message \"length computed here\" } */\n+    T (d, s, n);                  /* { dg-message \".strncat\\[^\\n\\r\\]* specified bound depends on the length of the source argument\" } */\n+  }\n+}\n+\n+\n+void test_strncpy (char **d, const char* s, int i)\n+{\n+#undef T\n+#define T(d, s, len) strncpy (*d++, (s), (len))\n+\n+  T (d, \"\",    0);\n+  T (d, \"\",    1);\n+  T (d, \"\",    2);\n+  T (d, \"\",    3);\n+  T (d, \"123\", 0);\n+  T (d, \"123\", 1);\n+  T (d, \"123\", 2);\n+  T (d, \"123\", 3);\n+  T (d, \"123\", 4);\n+  T (d, \"123\", 9);\n+\n+  T (d, \"123\", sizeof \"123\");\n+  T (d, ar, sizeof ar);\n+\n+  T (d, s, strlen (s));       /* { dg-warning \"\\\\\\[-Wstringop-overflow=]\" } */\n+\n+  {\n+    int n = strlen (s);       /* { dg-message \"length computed here\" } */\n+    T (d, s, n);              /* { dg-warning \"\\\\\\[-Wstringop-overflow=]\" } */\n+  }\n+\n+  {\n+    unsigned n = strlen (s);   /* { dg-message \"length computed here\" } */\n+    T (d, s, n);               /* { dg-warning \"\\\\\\[-Wstringop-overflow=]\" } */\n+  }\n+\n+  {\n+    size_t n;\n+    n = strlen (s);           /* { dg-message \"length computed here\" } */\n+    T (d, s, n);              /* { dg-warning \"\\\\\\[-Wstringop-overflow=]\" } */\n+  }\n+\n+  {\n+    size_t n;\n+    n = strlen (s) - 1;       /* { dg-message \"length computed here\" } */\n+    T (d, s, n);              /* { dg-warning \"\\\\\\[-Wstringop-overflow=]\" } */\n+  }\n+\n+  {\n+    /* This is diagnosed by -Wstringop-truncation.  Verify that it isn't\n+       also diagnosed by -Wstringop-overflow.  */\n+    size_t n = strlen (s) - strlen (s);\n+    T (d, s, n);\n+  }\n+\n+  {\n+    /* This use of strncpy is certainly dubious and it could well be\n+       diagnosed by -Wstringop-truncation but it isn't.  That it is\n+       diagnosed with -Wstringop-overflow is more by accident than\n+       by design.  -Wstringop-overflow considers any dependency of\n+       the bound on strlen(s) a potential bug.  */\n+    size_t n = i < strlen (s) ? i : strlen (s);   /* { dg-message \"length computed here\" } */\n+    T (d, s, n);                  /* { dg-message \".strncpy\\[^\\n\\r]* specified bound depends on the length of the source argument\" } */\n+  }\n+}"}, {"sha": "c536a13b78e10f9c46b83a8086d0d2a4e2f5e206", "filename": "gcc/testsuite/c-c++-common/Wstringop-truncation.c", "status": "added", "additions": 448, "deletions": 0, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -0,0 +1,448 @@\n+/* PR middle-end/81117 - Improve buffer overflow checking in strncpy\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wstringop-truncation -Wno-stringop-overflow -ftrack-macro-expansion=0\" } */\n+\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#if __cplusplus\n+extern \"C\" {\n+#endif\n+\n+size_t strlen (const char*);\n+char* strncat (char*, const char*, size_t);\n+char* strncpy (char*, const char*, size_t);\n+\n+#if __cplusplus\n+}\n+#endif\n+\n+extern size_t unsigned_value (void)\n+{\n+  extern volatile size_t unsigned_value_source;\n+  return unsigned_value_source;\n+}\n+\n+size_t unsigned_range (size_t min, size_t max)\n+{\n+  size_t val = unsigned_value ();\n+  return val < min || max < val ? min : val;\n+}\n+\n+#define UR(min, max) unsigned_range (min, max)\n+\n+void sink (void*);\n+\n+#define S4 \"123\"\n+const char a4[] = \"123\";\n+\n+#define CHOOSE(a, b) (unsigned_value () & 1 ? a : b)\n+\n+\n+typedef struct Dest\n+{\n+  char a5[5];\n+  char b7[7];\n+  char c3ns[3] __attribute__ ((nonstring));\n+} Dest;\n+\n+char dst7[7];\n+char dst2_5[2][5];\n+\n+/* Verify strncat warnings for arrays of known bounds.  */\n+\n+void test_strncat_array (Dest *pd)\n+{\n+#define CAT(d, s, len) (strncat ((d), (s), (len)), sink (d))\n+\n+  CAT (dst7, S4, 2);                /* { dg-warning \"output truncated copying 2 bytes from a string of length 3\" } */\n+\n+  CAT (dst7, a4, 1);                /* { dg-warning \"output truncated copying 1 byte from a string of length 3\" } */\n+\n+  /* There is no truncation here but possible overflow so these\n+     are diagnosed by -Wstringop-overflow:\n+     CAT (dst7, S4, 3);\n+     CAT (dst7, a4, 3);\n+  */\n+\n+  CAT (pd->a5, S4, 2);              /* { dg-warning \"output truncated copying 2 bytes from a string of length 3\" } */\n+  CAT (pd->a5, S4, 1);              /* { dg-warning \"output truncated copying 1 byte from a string of length 3\" } */\n+}\n+\n+/* Verify strncat warnings for arrays of known bounds and a non-const\n+   character count in some range.  */\n+\n+void test_strncat_array_range (Dest *pd)\n+{\n+  CAT (dst7, S4, UR (0, 1));        /* { dg-warning \"output truncated copying between 0 and 1 bytes from a string of length 3\" } */\n+  CAT (dst7, S4, UR (0, 2));        /* { dg-warning \"output truncated copying between 0 and 2 bytes from a string of length 3\" } */\n+  CAT (dst7, S4, UR (1, 3));        /* { dg-warning \"output truncated copying between 1 and 3 bytes from a string of length 3\" } */\n+  CAT (dst7, S4, UR (2, 4));        /* { dg-warning \"output may be truncated copying between 2 and 4 bytes from a string of length 3\" } */\n+\n+  CAT (dst7, S4, UR (0, 7));\n+  CAT (dst7, S4, UR (1, 7));\n+  CAT (dst7, S4, UR (6, 7));\n+\n+  CAT (dst7, S4, UR (0, 99));\n+\n+  CAT (dst7, S4, UR (0, 99));\n+}\n+\n+/* Verify strncat warnings for arrays of unknown bounds.  */\n+\n+void test_strncat_vla (char *d, unsigned n)\n+{\n+  CAT (d, S4, 2);                   /* { dg-warning \"output truncated copying 2 bytes from a string of length 3\" } */\n+  CAT (d, S4, 4);\n+\n+  CAT (d, a4, 2);                   /* { dg-warning \"output truncated copying 2 bytes from a string of length 3\" } */\n+\n+  /* There is no truncation here but possible overflow so these\n+     are diagnosed by -Wstringop-overflow:\n+     CAT (d, S4, 3);\n+     CAT (d, a4, 3);\n+  */\n+  CAT (d, a4, 4);\n+\n+  char vla[n];\n+\n+  CAT (vla, S4, 2);                 /* { dg-warning \"output truncated copying 2 bytes from a string of length 3\" } */\n+\n+  CAT (vla, S4, 4);\n+  CAT (vla, S4, n);\n+\n+  CAT (vla, a4, 2);                 /* { dg-warning \"output truncated copying 2 bytes from a string of length 3\" } */\n+\n+  CAT (vla, a4, 4);\n+  CAT (vla, a4, n);\n+\n+  CAT (d, vla, 1);\n+  CAT (d, vla, 3);\n+  CAT (d, vla, 4);\n+  CAT (d, vla, n);\n+\n+  /* There is no truncation here but possible overflow so these\n+     are diagnosed by -Wstringop-overflow:\n+  CAT (vla, S4, 3);\n+  CAT (vla, a4, 3);\n+  */\n+}\n+\n+/* Verify strncpy warnings with at least one pointer to an object\n+   or string of unknown size (destination) or length (source).  */\n+\n+void test_strncpy_ptr (char *d, const char* s, const char *t, int i)\n+{\n+#define CPY(d, s, len) (strncpy ((d), (s), (len)), sink (d))\n+\n+  /* Strncpy doesn't nul-terminate so the following is diagnosed.  */\n+  CPY (d, \"\",    0);                /* { dg-warning \".strncpy\\[^\\n\\r\\]* destination unchanged after copying no bytes\" } */\n+  CPY (d, s,     0);                /* { dg-warning \".strncpy\\[^\\n\\r\\]* destination unchanged after copying no bytes\" } */\n+\n+  /* This is safe.  */\n+  CPY (d, \"\",    1);\n+  CPY (d, \"\",    2);\n+\n+  /* This could be safe.  */\n+  CPY (d, s,     1);\n+  CPY (d, s,     2);\n+\n+  /* Truncation.  */\n+  CPY (d, \"123\", 1);                /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated copying 1 byte from a string of length 3\" } */\n+  CPY (d, \"123\", 2);                /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated copying 2 bytes from a string of length 3\" } */\n+  CPY (d, \"123\", 3);                /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying 3 bytes from a string of the same length\" } */\n+  CPY (d, \"123\", 4);\n+  CPY (d, \"123\", 9);\n+\n+  CPY (d, S4, sizeof S4);           /* Covered by -Wsizeof-pointer-memaccess.  */\n+  CPY (d, S4, sizeof S4 - 1);       /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying 3 bytes from a string of the same length\" } */\n+\n+  CPY (d, a4, sizeof a4);           /* Covered by -Wsizeof-pointer-memaccess.  */\n+  CPY (d, a4, sizeof a4 - 1);       /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying 3 bytes from a string of the same length\" } */\n+  CPY (d, a4, sizeof a4 - 3);       /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated copying 1 byte from a string of length 3\" } */\n+  CPY (d, a4, sizeof a4 - 4);       /* { dg-warning \".strncpy\\[^\\n\\r\\]* destination unchanged after copying no bytes from a string of length 3\" } */\n+\n+  CPY (d, S4, strlen (S4));         /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying 3 bytes from a string of the same length\" } */\n+  /* Likely buggy but no truncation.  Diagnosed by -Wstringop-overflow.  */\n+  CPY (d, a4, strlen (a4) + 1);\n+  CPY (d, S4, strlen (S4) + i);\n+\n+  CPY (d, a4, strlen (a4));         /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying 3 bytes from a string of the same length\" } */\n+  /* As above, buggy but no evidence of truncation.  */\n+  CPY (d, S4, strlen (S4) + 1);\n+\n+  CPY (d, CHOOSE (\"\", \"1\"), 0);     /* { dg-warning \".strncpy\\[^\\n\\r\\]* destination unchanged after copying no bytes\" } */\n+  CPY (d, CHOOSE (\"1\", \"12\"), 0);   /* { dg-warning \".strncpy\\[^\\n\\r\\]* destination unchanged after copying no bytes\" } */\n+\n+  CPY (d, CHOOSE (\"\", \"1\"), 1);     /* { dg-warning \".strncpy\\[^\\n\\r\\]* output may be truncated copying 1 byte from a string of length 1\" } */\n+  CPY (d, CHOOSE (\"1\", \"\"), 1);     /* { dg-warning \".strncpy\\[^\\n\\r\\]* output may be truncated copying 1 byte from a string of length 1\" } */\n+  CPY (d, CHOOSE (s, \"1\"), 1);      /* { dg-warning \".strncpy\\[^\\n\\r\\]* output may be truncated copying 1 byte from a string of length 1\" } */\n+  CPY (d, CHOOSE (s, t), 1);\n+\n+  CPY (d, CHOOSE (\"\", \"1\"), 2);\n+  CPY (d, CHOOSE (\"1\", \"\"), 2);\n+  CPY (d, CHOOSE (\"1\", \"2\"), 2);\n+  CPY (d, CHOOSE (\"1\", s), 2);\n+  CPY (d, CHOOSE (s, \"1\"), 2);\n+  CPY (d, CHOOSE (s, t), 2);\n+\n+  CPY (d, CHOOSE (\"\", \"123\"), 1);   /* { dg-warning \".strncpy\\[^\\n\\r\\]* output may be truncated copying 1 byte from a string of length 3\" } */\n+  CPY (d, CHOOSE (\"1\", \"123\"), 1);  /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated copying 1 byte from a string of length 1\" } */\n+  CPY (d, CHOOSE (\"12\", \"123\"), 1); /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated copying 1 byte from a string of length 2\" } */\n+  CPY (d, CHOOSE (\"123\", \"12\"), 1); /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated copying 1 byte from a string of length 2\" } */\n+\n+  {\n+    signed char n = strlen (s);   /* { dg-message \"length computed here\" } */\n+    CPY (d, s, n);                  /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying as many bytes from a string as its length\" } */\n+  }\n+\n+  {\n+    short n = strlen (s);         /* { dg-message \"length computed here\" } */\n+    CPY (d, s, n);                  /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying as many bytes from a string as its length\" } */\n+  }\n+\n+  {\n+    int n = strlen (s);           /* { dg-message \"length computed here\" } */\n+    CPY (d, s, n);                  /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying as many bytes from a string as its length\" } */\n+  }\n+\n+  {\n+    unsigned n = strlen (s);      /* { dg-message \"length computed here\" } */\n+    CPY (d, s, n);                  /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying as many bytes from a string as its length\" } */\n+  }\n+\n+  {\n+    size_t n;\n+    n = strlen (s);               /* { dg-message \"length computed here\" } */\n+    CPY (d, s, n);                  /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying as many bytes from a string as its length\" } */\n+  }\n+\n+  {\n+    size_t n;\n+    char *dp2 = d + 1;\n+    n = strlen (s);               /* { dg-message \"length computed here\" } */\n+    CPY (dp2, s, n);                /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying as many bytes from a string as its length\" } */\n+  }\n+\n+  {\n+    /* The following is likely buggy but there's no apparent truncation\n+       so it's not diagnosed by -Wstringop-truncation.  Instead, it is\n+       diagnosed by -Wstringop-overflow (tested elsewhere).  */\n+    int n;\n+    n = strlen (s) - 1;\n+    CPY (d, s, n);\n+  }\n+\n+  {\n+    /* Same as above.  */\n+    size_t n;\n+    n = strlen (s) - 1;\n+    CPY (d, s, n);\n+  }\n+\n+  {\n+    size_t n = strlen (s) - strlen (s);\n+    CPY (d, s, n);                  /* { dg-warning \".strncpy\\[^\\n\\r\\]* destination unchanged after copying no bytes\" } */\n+  }\n+\n+  {\n+    /* This use of strncpy is dubious but it's probably not worth\n+       worrying about (truncation may not actually take place when\n+       i is the result).  It is diagnosed with -Wstringop-overflow\n+       (although more by accident than by design).\n+\n+       size_t n = i < strlen (s) ? i : strlen (s);\n+       CPY (d, s, n);\n+    */\n+  }\n+}\n+\n+\n+/* Verify strncpy warnings for arrays of known bounds.  */\n+\n+void test_strncpy_array (Dest *pd, int i, const char* s)\n+{\n+#undef CPY\n+#define CPY(d, s, len) (strncpy ((d), (s), (len)), sink (d))\n+\n+  CPY (dst7, s, 7);                 /* { dg-warning \"specified bound 7 equals destination size\" } */\n+  CPY (dst7, s, sizeof dst7);       /* { dg-warning \"specified bound 7 equals destination size\" } */\n+\n+  CPY (dst2_5[0], s, sizeof dst2_5[0]); /* { dg-warning \"specified bound 5 equals destination size\" \"bug 77293\" { xfail *-*-* } } */\n+  CPY (dst2_5[1], s, sizeof dst2_5[1]); /* { dg-warning \"specified bound 5 equals destination size\" } */\n+\n+  /* Verify that copies that nul-terminate are not diagnosed.  */\n+  CPY (dst7,     \"\",       sizeof dst7);\n+  CPY (dst7 + 6, \"\",       sizeof dst7 - 6);\n+  CPY (dst7,     \"1\",      sizeof dst7);\n+  CPY (dst7 + 1, \"1\",      sizeof dst7 - 1);\n+  CPY (dst7,     \"123456\", sizeof dst7);\n+  CPY (dst7 + 1, \"12345\",  sizeof dst7 - 1);\n+\n+  CPY (dst7 + i, s,        6);\n+  CPY (dst7 + i, s,        7);      /* { dg-warning \"specified bound 7 equals destination size\" } */\n+  /* The following two calls are diagnosed by -Wstringop-overflow.  */\n+  CPY (dst7 + i, s,        8);\n+  CPY (dst7 + i, s,        UR (8, 9));\n+\n+  /* No nul-termination here.  */\n+  CPY (dst7 + 2, \"12345\",  sizeof dst7 - 2);    /* { dg-warning \"output truncated before terminating nul copying 5 bytes from a string of the same length\" } */\n+\n+  /* Because strnlen appends as many NULs as necessary to write the specified\n+     number of byts the following doesn't (necessarily) truncate but rather\n+     overflow, and so is diagnosed by -Wstringop-overflow.  */\n+  CPY (dst7, s, 8);\n+\n+  CPY (dst7 + 1, s, 6);             /* { dg-warning \"specified bound 6 equals destination size\" } */\n+  CPY (dst7 + 6, s, 1);             /* { dg-warning \"specified bound 1 equals destination size\" } */\n+\n+  CPY (pd->a5, s, 5);               /* { dg-warning \"specified bound 5 equals destination size\" } */\n+  CPY (pd->a5, s, sizeof pd->a5);   /* { dg-warning \"specified bound 5 equals destination size\" } */\n+\n+  /* The following is not yet handled.  */\n+  CPY (pd->a5 + i, s, sizeof pd->a5);   /* { dg-warning \"specified bound 5 equals destination size\" \"member array\" { xfail *-*-* } } */\n+\n+  /* Verify that a copy that nul-terminates is not diagnosed.  */\n+  CPY (pd->a5, \"1234\", sizeof pd->a5);\n+\n+  /* Same above, diagnosed by -Wstringop-overflow.  */\n+  CPY (pd->a5, s, 6);\n+\n+  /* Exercise destination with attribute \"nonstring\".  */\n+  CPY (pd->c3ns, \"\", 3);\n+  CPY (pd->c3ns, \"\", 1);\n+  /* Truncation is still diagnosed -- using strncpy in this case is\n+     pointless and should be replaced with memcpy.  */\n+  CPY (pd->c3ns, \"12\", 1);          /* { dg-warning \"output truncated copying 1 byte from a string of length 2\" } */\n+  CPY (pd->c3ns, \"12\", 2);\n+  CPY (pd->c3ns, \"12\", 3);\n+  CPY (pd->c3ns, \"123\", 3);\n+  CPY (pd->c3ns, s, 3);\n+  CPY (pd->c3ns, s, sizeof pd->c3ns);\n+\n+  /* Verify that the idiom of calling strncpy with a bound equal to\n+     the size of the destination (and thus potentially without NUL-\n+     terminating it) immediately followed by setting the last element\n+     of the array to NUL is not diagnosed.  */\n+  {\n+    /* This might be better written using memcpy() but it's safe so\n+       it probably shouldn't be diagnosed.  It currently triggers\n+       a warning because of bug 81704.  */\n+    strncpy (dst7, \"0123456\", sizeof dst7);   /* { dg-bogus \"truncated\" \"bug 81704\" { xfail *-*-* } } */\n+    dst7[sizeof dst7 - 1] = '\\0';\n+    sink (dst7);\n+  }\n+\n+  {\n+    const char a[] = \"0123456789\";\n+    strncpy (dst7, a, sizeof dst7);\n+    dst7[sizeof dst7 - 1] = '\\0';\n+    sink (dst7);\n+  }\n+\n+  {\n+    strncpy (dst7, s, sizeof dst7);\n+    dst7[sizeof dst7 - 1] = '\\0';\n+    sink (dst7);\n+  }\n+\n+  {\n+    strncpy (pd->a5, \"01234\", sizeof pd->a5);   /* { dg-bogus \"truncated\" \"bug 81704\" { xfail *-*-* } } */\n+    pd->a5[sizeof pd->a5 - 1] = '\\0';\n+    sink (pd);\n+  }\n+\n+  {\n+    strncpy (pd->a5, s, sizeof pd->a5);\n+    pd->a5[sizeof pd->a5 - 1] = '\\0';\n+    sink (pd);\n+  }\n+\n+  {\n+    unsigned n = 7;\n+    char *p = (char*)__builtin_malloc (n);\n+    strncpy (p, s, n);\n+    p[n - 1] = '\\0';\n+    sink (p);\n+  }\n+\n+  {\n+    /* This should be diagnosed because the NUL-termination doesn't\n+       immediately follow the strncpy call (sink may expect pd->a5\n+       to be NUL-terminated).  */\n+    strncpy (pd->a5, s, sizeof pd->a5); /* { dg-warning \"specified bound 5 equals destination size\" } */\n+    sink (pd);\n+    pd->a5[sizeof pd->a5] = '\\0';\n+    sink (pd);\n+  }\n+}\n+\n+typedef struct Flex\n+{\n+  size_t n;\n+  char a0[0];\n+  char ax[];\n+} Flex;\n+\n+extern char array[];\n+\n+/* Verify that no warning is issued for array of unknown bound, flexible\n+   array members, or zero-length arrays, except when the source is definitely\n+   truncated.  */\n+\n+void test_strncpy_flexarray (Flex *pf, const char* s)\n+{\n+#undef CPY\n+#define CPY(d, s, len) (strncpy ((d), (s), (len)), sink (d))\n+\n+  CPY (array, \"12345\", 7);\n+  CPY (array, \"12345\", 123);\n+\n+  CPY (array, s, 7);\n+  CPY (array, s, 123);\n+\n+  CPY (pf->a0, s, 1);\n+  CPY (pf->a0, s, 1234);\n+\n+  CPY (pf->a0, \"\",      1);\n+  CPY (pf->a0, \"12345\", 5);          /* { dg-warning \"output truncated before terminating nul copying 5 bytes from a string of the same length\" } */\n+  CPY (pf->a0, \"12345\", 1234);\n+\n+  CPY (pf->ax, s, 5);\n+  CPY (pf->ax, s, 12345);\n+\n+  CPY (pf->ax, \"1234\", 5);\n+  CPY (pf->ax, \"12345\", 5);         /* { dg-warning \"output truncated before terminating nul copying 5 bytes from a string of the same length\" } */\n+  CPY (pf->ax, \"12345\", 12345);\n+}\n+\n+/* Verify warnings for dynamically allocated objects.  */\n+\n+void test_strncpy_alloc (const char* s)\n+{\n+  size_t n = 7;\n+  char *d = (char *)__builtin_malloc (n);\n+\n+  CPY (d, s, n);                    /* { dg-warning \"specified bound 7 equals destination size\" \"bug 79016\" { xfail *-*-* } } */\n+\n+  Dest *pd = (Dest *)__builtin_malloc (sizeof *pd * n);\n+  CPY (pd->a5, s, 5);               /* { dg-warning \"specified bound 5 equals destination size\" } */\n+  CPY (pd->a5, s, sizeof pd->a5);   /* { dg-warning \"specified bound 5 equals destination size\" } */\n+}\n+\n+/* Verify warnings for VLAs.  */\n+\n+void test_strncpy_vla (unsigned n, const char* s)\n+{\n+  char vla[n];\n+  CPY (vla, s, 0);                  /* { dg-warning \".strncpy\\[^\\n\\r\\]* destination unchanged after copying no bytes\" } */\n+\n+  CPY (vla, s, 1);\n+  CPY (vla, s, 2);\n+  CPY (vla, s, n);\n+\n+  CPY (vla, \"\", 0);                 /* { dg-warning \".strncpy\\[^\\n\\r\\]* destination unchanged after copying no bytes\" } */\n+  CPY (vla, \"\", 1);\n+  CPY (vla, S4, 3);                 /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying 3 bytes from a string of the same length\" } */\n+  CPY (vla, S4, n);\n+}"}, {"sha": "10a66887fa2ddc78de8571723e19b660b5730994", "filename": "gcc/testsuite/c-c++-common/attr-nonstring-1.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-1.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -0,0 +1,60 @@\n+/* Test to exercise attribute \"nonstring\" syntax.\n+   { dg-do compile }\n+   { dg-options \"-Wattributes\" }  */\n+\n+#define ATTR(list) __attribute__ (list)\n+#define NONSTR     ATTR ((nonstring))\n+\n+/* Verify it's accepted on char arrays.  */\n+extern NONSTR char nsx_1[];\n+extern char NONSTR nsx_2[];\n+extern char nsx_3[] NONSTR;\n+\n+extern NONSTR char ns1[1];\n+extern char NONSTR ns3[3];\n+extern char ns5[5] NONSTR;\n+\n+/* Verify it's accepted on char pointers.  */\n+extern NONSTR char* pns_1;\n+extern char NONSTR* pns_2;\n+extern char* NONSTR pns_3;\n+\n+struct S\n+{\n+/* Verify it's accepted on char member pointers.  */\n+  NONSTR char* mpns_1;\n+  char NONSTR* mpns_2;\n+  char* NONSTR mpns_3;\n+\n+/* Verify it's accepted on char member arrays.  */\n+  NONSTR char mns1[1];\n+  char NONSTR mns3[3];\n+  char mns5[5] NONSTR;\n+\n+/* Verify it's accepted on char flexible array members.  */\n+  char mnsx[] NONSTR;\n+};\n+\n+/* Verify it's rejected on non-array and non-pointer objects.  */\n+extern NONSTR char c1;         /* { dg-warning \".nonstring. attribute ignored on objects of type .char.\" } */\n+\n+extern NONSTR int i1;         /* { dg-warning \".nonstring. attribute ignored on objects of type .int.\" } */\n+\n+extern NONSTR int ia1[];      /* { dg-warning \".nonstring. attribute ignored on objects of type .int *\\\\\\[\\\\\\].\" } */\n+\n+extern NONSTR int* pi1;       /* { dg-warning \".nonstring. attribute ignored on objects of type .int *\\\\*.\" } */\n+\n+extern NONSTR\n+void f (void);                /* { dg-warning \".nonstring. attribute does not apply to functions\" } */\n+\n+struct NONSTR\n+NonStrType { int i; };        /* { dg-warning \".nonstring. attribute does not apply to types\" } */\n+\n+typedef char NONSTR nschar_t; /* { dg-warning \".nonstring. attribute does not apply to types\" } */\n+\n+void func (NONSTR char *pns1, char NONSTR *pns2, char* NONSTR pns3)\n+{\n+  (void)pns1;\n+  (void)pns2;\n+  (void)pns3;\n+}"}, {"sha": "6e273e785a00fef95aaccf672d945e7c485f8fa3", "filename": "gcc/testsuite/c-c++-common/attr-nonstring-2.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-2.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -0,0 +1,123 @@\n+/* Test to exercise attribute \"nonstring\".\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wattributes -Wstringop-truncation -ftrack-macro-expansion=0\" }  */\n+\n+#define ATTR(list) __attribute__ (list)\n+#define NONSTR     ATTR ((nonstring))\n+#define strncpy(d, s, n) (__builtin_strncpy ((d), (s), (n)), sink (d))\n+\n+void sink (void*);\n+\n+/* Global string with an unknown bound.  */\n+extern char gsx[];\n+\n+/* Global string with an known bound.  */\n+extern char gs3[3];\n+\n+/* Global non-strings with an unknown bound.  */\n+extern NONSTR char gax_1[];\n+extern char NONSTR gax_2[];\n+extern char gax_3[] NONSTR;\n+\n+/* Global non-strings with a known bound.  */\n+NONSTR char gns3[3];\n+char NONSTR gns4[4];\n+char gns5[5] NONSTR;\n+\n+/* Global string pointer.  */\n+extern char *ps_1;\n+\n+/* Global non-string pointers.  */\n+extern NONSTR char *pns_1;\n+extern char* NONSTR pns_2;\n+extern char *pns_3 NONSTR;\n+\n+struct MemArrays\n+{\n+  NONSTR char ma3[3];\n+  char NONSTR ma4[4];\n+  char ma5[5] NONSTR;\n+  char max[] NONSTR;\n+};\n+\n+\n+void test_array (const char *s, unsigned n)\n+{\n+  const char s7[] = \"1234567\";\n+\n+  strncpy (gs3, \"\", 0);           /* { dg-warning \"destination unchanged after copying no bytes\" } */\n+  strncpy (gs3, \"a\", 1);          /* { dg-warning \"output truncated before terminating nul copying 1 byte from a string of the same length\" } */\n+  strncpy (gs3, \"a\", 2);\n+  strncpy (gs3, \"a\", 3);\n+  strncpy (gs3, \"ab\", 3);\n+  strncpy (gs3, \"abc\", 3);        /* { dg-warning \"output truncated before terminating nul copying 3 bytes from a string of the same length\" } */\n+\n+  /* It might perhaps be helpful to diagnose certain truncation even\n+     for non-strings.  Then again, since the destination has been\n+     explicitly annotated as non-string, it might be viewed as a false\n+     positive.  A valid use case seen in Glibc goes something like this:\n+\n+     #if FOO\n+     # define S \"1234\"\n+     #else\n+     # define S \"12345678\"\n+     #endif\n+\n+     strncpy (d, S, 8);\n+  */\n+  strncpy (gax_3, s7, 3);\n+\n+  strncpy (gax_1, \"a\", 1);\n+  strncpy (gax_2, \"ab\", 2);\n+  strncpy (gax_3, \"abc\", 3);\n+  strncpy (gax_3, s7, 3);\n+\n+  strncpy (gax_1, s, 1);\n+  strncpy (gax_2, s, 1);\n+  strncpy (gax_3, s, 1);\n+\n+  strncpy (gax_1, s, n);\n+  strncpy (gax_2, s, n);\n+  strncpy (gax_3, s, n);\n+}\n+\n+\n+void test_pointer (const char *s, unsigned n)\n+{\n+  const char s7[] = \"1234567\";\n+\n+  strncpy (pns_1, \"a\", 1);\n+  strncpy (pns_2, \"ab\", 2);\n+  strncpy (pns_3, \"abc\", 3);\n+  strncpy (pns_3, s7, 3);         /* { dg-warning \"output truncated copying 3 bytes from a string of length 7\" } */\n+\n+  strncpy (pns_1, s, 1);\n+  strncpy (pns_2, s, 1);\n+  strncpy (pns_3, s, 1);\n+\n+  strncpy (pns_1, s, n);\n+  strncpy (pns_2, s, n);\n+  strncpy (pns_3, s, n);\n+}\n+\n+\n+void test_member_array (struct MemArrays *p, const char *s, unsigned n)\n+{\n+  const char s7[] = \"1234567\";\n+\n+  strncpy (p->ma3, \"a\", 1);\n+  strncpy (p->ma4, \"ab\", 2);\n+  strncpy (p->ma5, \"abc\", 3);\n+  strncpy (p->max, \"abcd\", 4);\n+  strncpy (p->max, s7, 5);\n+\n+  strncpy (p->ma3, s, 1);\n+  strncpy (p->ma4, s, 1);\n+  strncpy (p->ma5, s, 1);\n+  strncpy (p->max, s, 1);\n+\n+  strncpy (p->ma3, s7, n);\n+  strncpy (p->ma4, s7, n);\n+  strncpy (p->ma5, s7, n);\n+  strncpy (p->max, s7, n);\n+}"}, {"sha": "5bc5c4ca8593415c2eb0b795bfec0b1e377145e1", "filename": "gcc/testsuite/g++.dg/torture/Wsizeof-pointer-memaccess1.C", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -1,6 +1,6 @@\n // Test -Wsizeof-pointer-memaccess warnings.\n // { dg-do compile }\n-// { dg-options \"-Wall -Wno-sizeof-array-argument -Wno-stringop-overflow\" }\n+// { dg-options \"-Wall -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-truncation\" }\n // Test just twice, once with -O0 non-fortified, once with -O2 fortified.\n // { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O2\" } }\n // { dg-skip-if \"\" { *-*-* }  { \"-flto\" } { \"\" } }\n@@ -698,12 +698,17 @@ f4 (char *x, char **y, int z, char w[64])\n   strncat (w, s2, sizeof (w));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n   stpncpy (w, s1, sizeof (w));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n \n-  // These are correct, no warning. \n   const char s3[] = \"foobarbaz\";\n   const char s4[] = \"abcde12345678\";\n-  strncpy (x, s3, sizeof (s3));\n-  strncat (x, s4, sizeof (s4));\n-  stpncpy (x, s3, sizeof (s3));\n+\n+  // These are pointless when the destination is large enough, and\n+  // cause overflow otherwise.  They might as well be replaced by\n+  // strcpy() or memcpy().\n+  strncpy (x, s3, sizeof (s3));             // { dg-warning \"call is the same expression as the source; did you mean to use the size of the destination?\" }\n+  strncat (x, s4, sizeof (s4));             // { dg-warning \"call is the same expression as the source; did you mean to use the size of the destination?\" }\n+  stpncpy (x, s3, sizeof (s3));             // { dg-warning \"call is the same expression as the source; did you mean to use the size of the destination?\" }\n+\n+  // These are safe, no warning.\n   y[1] = strndup (s3, sizeof (s3));\n   z += strncmp (s3, s4, sizeof (s3));\n   z += strncmp (s3, s4, sizeof (s4));"}, {"sha": "f2c864b0b24f37c6bd1e22d1f8e723fd357e018b", "filename": "gcc/testsuite/g++.dg/torture/Wsizeof-pointer-memaccess2.C", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -1,6 +1,6 @@\n // Test -Wsizeof-pointer-memaccess warnings.\n // { dg-do compile }\n-// { dg-options \"-Wall -Wno-sizeof-array-argument -Wno-stringop-overflow\" }\n+// { dg-options \"-Wall -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-truncation\" }\n // Test just twice, once with -O0 non-fortified, once with -O2 fortified,\n // suppressing buffer overflow warnings.\n // { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O2\" } }\n@@ -703,12 +703,13 @@ f4 (char *x, char **y, int z, char w[64])\n   strncat (w, s2, sizeof (w));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n   stpncpy (w, s1, sizeof (w));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n \n-  // These are correct, no warning. \n   const char s3[] = \"foobarbaz\";\n   const char s4[] = \"abcde12345678\";\n-  strncpy (x, s3, sizeof (s3));\n-  strncat (x, s4, sizeof (s4));\n-  stpncpy (x, s3, sizeof (s3));\n+  strncpy (x, s3, sizeof (s3));             // { dg-warning \"call is the same expression as the source; did you mean to use the size of the destination\" }\n+  strncat (x, s4, sizeof (s4));             // { dg-warning \"call is the same expression as the source; did you mean to use the size of the destination\" }\n+  stpncpy (x, s3, sizeof (s3));             // { dg-warning \"call is the same expression as the source; did you mean to use the size of the destination\" }\n+\n+  // These are safe, no warning.\n   y[1] = strndup (s3, sizeof (s3));\n   z += strncmp (s3, s4, sizeof (s3));\n   z += strncmp (s3, s4, sizeof (s4));"}, {"sha": "85e9160e8455e9bfd68d8bd0c4d9e83a87069249", "filename": "gcc/testsuite/gcc.dg/Walloca-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-1.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target alloca } */\n-/* { dg-options \"-Walloca-larger-than=2000 -O2\" } */\n+/* { dg-options \"-Walloca-larger-than=2000 -O2 -ftrack-macro-expansion=0\" } */\n \n #define alloca __builtin_alloca\n "}, {"sha": "920079892dd0927e7224e03715958fa6a0abc997", "filename": "gcc/testsuite/gcc.dg/builtin-stpncpy.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stpncpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stpncpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stpncpy.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -1,6 +1,6 @@\n /* PR tree-optimization/80669 - Bad -Wstringop-overflow warnings for stpncpy\n    { dg-do compile }\n-   { dg-options \"-O2 -Wall\" } */\n+   { dg-options \"-O2 -Wall -Wno-stringop-truncation\" } */\n \n #define SIZE_MAX __SIZE_MAX__\n \n@@ -18,7 +18,9 @@ size_t range (size_t min, size_t max)\n   return val < min || max < val ? min : val;\n }\n \n-/* Verify that no warning is issued for stpncpy with constant size.  */\n+/* Verify that no -Wstringop-overflow warning is issued for stpncpy\n+   with constant size.  (Some tests cause -Wstringop-truncation and\n+   that's expected).  */\n void test_cst (char *d)\n {\n   __builtin_stpncpy (d, \"123\", 0);\n@@ -37,7 +39,8 @@ void test_cst (char *d)\n }\n \n \n-/* Verify that no warning is issued for stpncpy with size in some range.  */\n+/* Verify that no -Wstringop-overflow warning is issued for stpncpy\n+   with size in some range.  */\n void test_rng (char *d)\n {\n #define R(min, max) range (min, max)"}, {"sha": "cd9dc72decb1dfb61a21701736a289578e96dfa7", "filename": "gcc/testsuite/gcc.dg/torture/Wsizeof-pointer-memaccess1.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -1,6 +1,6 @@\n /* Test -Wsizeof-pointer-memaccess warnings.  */\n /* { dg-do compile } */\n-/* { dg-options \"-Wall -Wno-sizeof-array-argument -Wno-stringop-overflow\" } */\n+/* { dg-options \"-Wall -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-truncation\" } */\n /* Test just twice, once with -O0 non-fortified, once with -O2 fortified.  */\n /* { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O2\" } } */\n /* { dg-skip-if \"\" { *-*-* }  { \"-flto\" } { \"\" } } */\n@@ -704,12 +704,17 @@ f4 (char *x, char **y, int z, char w[64])\n   strncat (w, s2, sizeof (w));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n   stpncpy (w, s1, sizeof (w));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n \n-  /* These are correct, no warning.  */\n+  /* These are pointless when the destination is large enough, and\n+     cause overflow otherwise.  If the copies are guaranteed to be\n+     safe the calls might as well be replaced by strcat(), strcpy(),\n+     or memcpy().  */\n   const char s3[] = \"foobarbaz\";\n   const char s4[] = \"abcde12345678\";\n-  strncpy (x, s3, sizeof (s3));\n-  strncat (x, s4, sizeof (s4));\n-  stpncpy (x, s3, sizeof (s3));\n+  strncpy (x, s3, sizeof (s3));             /* { dg-warning \"call is the same expression as the source; did you mean to use the size of the destination?\" } */\n+  strncat (x, s4, sizeof (s4));             /* { dg-warning \"call is the same expression as the source; did you mean to use the size of the destination?\" } */\n+  stpncpy (x, s3, sizeof (s3));             /* { dg-warning \"call is the same expression as the source; did you mean to use the size of the destination?\" } */\n+\n+  /* These are correct, no warning.  */\n   y[1] = strndup (s3, sizeof (s3));\n   z += strncmp (s3, s4, sizeof (s3));\n   z += strncmp (s3, s4, sizeof (s4));"}, {"sha": "9162266da2ce6436510518d2255632b34928fd74", "filename": "gcc/testsuite/gcc.dg/torture/pr63554.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr63554.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr63554.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr63554.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -1,4 +1,5 @@\n-/* { dg-do compile } */\n+/* PR c/63554 - ice in \"execute_todo, at passes.c:1797\" with -O3\n+   { dg-do compile } */\n \n char *a;\n void\n@@ -7,3 +8,5 @@ nssutil_ReadSecmodDB (void)\n   long b = __builtin_object_size (0, 0);\n   a = __builtin___strncat_chk (a, \" \", 1, b);\n }\n+\n+/* { dg-prune-output \"\\\\\\[-Wstringop-overflow=]\" } */"}, {"sha": "2efa18275fd915d14ba010ff7b1edc4927779631", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 395, "deletions": 0, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025d57f037ad13eb479818b677ef4be4d97b639c/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=025d57f037ad13eb479818b677ef4be4d97b639c", "patch": "@@ -40,12 +40,17 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"tree-dfa.h\"\n #include \"domwalk.h\"\n+#include \"tree-ssa-alias.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"params.h\"\n #include \"ipa-chkp.h\"\n #include \"tree-hash-traits.h\"\n #include \"builtins.h\"\n #include \"target.h\"\n+#include \"diagnostic-core.h\"\n+#include \"diagnostic.h\"\n+#include \"intl.h\"\n+#include \"attribs.h\"\n \n /* A vector indexed by SSA_NAME_VERSION.  0 means unknown, positive value\n    is an index into strinfo vector, negative value stands for\n@@ -147,6 +152,9 @@ struct decl_stridxlist_map\n    mappings.  */\n static hash_map<tree_decl_hash, stridxlist> *decl_to_stridxlist_htab;\n \n+typedef std::pair<int, location_t> stridx_strlenloc;\n+static hash_map<tree, stridx_strlenloc> strlen_to_stridx;\n+\n /* Obstack for struct stridxlist and struct decl_stridxlist_map.  */\n static struct obstack stridx_obstack;\n \n@@ -1198,6 +1206,9 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t      si->nonzero_chars = lhs;\n \t      gcc_assert (si->full_string_p);\n \t    }\n+\n+\t  location_t loc = gimple_location (stmt);\n+\t  strlen_to_stridx.put (lhs, stridx_strlenloc (idx, loc));\n \t  return;\n \t}\n     }\n@@ -1241,6 +1252,9 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n       strinfo *si = new_strinfo (src, idx, lhs, true);\n       set_strinfo (idx, si);\n       find_equal_ptrs (src, idx);\n+\n+      location_t loc = gimple_location (stmt);\n+      strlen_to_stridx.put (lhs, stridx_strlenloc (idx, loc));\n     }\n }\n \n@@ -1607,6 +1621,368 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n     fprintf (dump_file, \"not possible.\\n\");\n }\n \n+/* Return true if LEN depends on a call to strlen(SRC) in an interesting\n+   way.  LEN can either be an integer expression, or a pointer (to char).\n+   When it is the latter (such as in recursive calls to self) is is\n+   assumed to be the argument in some call to strlen() whose relationship\n+   to SRC is being ascertained.  */\n+\n+static bool\n+is_strlen_related_p (tree src, tree len)\n+{\n+  if (TREE_CODE (TREE_TYPE (len)) == POINTER_TYPE\n+      && operand_equal_p (src, len, 0))\n+    return true;\n+\n+  if (TREE_CODE (len) != SSA_NAME)\n+    return false;\n+\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (len);\n+  if (!def_stmt)\n+    return false;\n+\n+  if (is_gimple_call (def_stmt))\n+    {\n+      tree func = gimple_call_fndecl (def_stmt);\n+      if (!valid_builtin_call (def_stmt)\n+\t  || DECL_FUNCTION_CODE (func) != BUILT_IN_STRLEN)\n+\treturn false;\n+\n+      tree arg = gimple_call_arg (def_stmt, 0);\n+      return is_strlen_related_p (src, arg);\n+    }\n+\n+  if (!is_gimple_assign (def_stmt))\n+    return false;\n+\n+  tree_code code = gimple_assign_rhs_code (def_stmt);\n+  tree rhs1 = gimple_assign_rhs1 (def_stmt);\n+  tree rhstype = TREE_TYPE (rhs1);\n+\n+  if ((TREE_CODE (rhstype) == POINTER_TYPE && code == POINTER_PLUS_EXPR)\n+      || (INTEGRAL_TYPE_P (rhstype)\n+\t  && (code == BIT_AND_EXPR\n+\t      || code == NOP_EXPR)))\n+    {\n+      /* Pointer plus (an integer) and integer cast or truncation are\n+\t considered among the (potentially) related expressions to strlen.\n+\t Others are not.  */\n+      return is_strlen_related_p (src, rhs1);\n+    }\n+\n+  return false;\n+}\n+\n+/* A helper of handle_builtin_stxncpy.  Check to see if the specified\n+   bound is a) equal to the size of the destination DST and if so, b)\n+   if it's immediately followed by DST[CNT - 1] = '\\0'.  If a) holds\n+   and b) does not, warn.  Otherwise, do nothing.  Return true if\n+   diagnostic has been issued.\n+\n+   The purpose is to diagnose calls to strncpy and stpncpy that do\n+   not nul-terminate the copy while allowing for the idiom where\n+   such a call is immediately followed by setting the last element\n+   to nul, as in:\n+     char a[32];\n+     strncpy (a, s, sizeof a);\n+     a[sizeof a - 1] = '\\0';\n+*/\n+\n+static bool\n+maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n+{\n+  if (!warn_stringop_truncation)\n+    return false;\n+\n+  gimple *stmt = gsi_stmt (gsi);\n+\n+  wide_int cntrange[2];\n+\n+  if (TREE_CODE (cnt) == INTEGER_CST)\n+    cntrange[0] = cntrange[1] = wi::to_wide (cnt);\n+  else if (TREE_CODE (cnt) == SSA_NAME)\n+    {\n+      enum value_range_type rng = get_range_info (cnt, cntrange, cntrange + 1);\n+      if (rng == VR_RANGE)\n+\t;\n+      else if (rng == VR_ANTI_RANGE)\n+\t{\n+\t  wide_int maxobjsize = wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node));\n+\n+\t  if (wi::ltu_p (cntrange[1], maxobjsize))\n+\t    {\n+\t      cntrange[0] = cntrange[1] + 1;\n+\t      cntrange[1] = maxobjsize;\n+\t    }\n+\t  else\n+\t    {\n+\t      cntrange[1] = cntrange[0] - 1;\n+\t      cntrange[0] = wi::zero (TYPE_PRECISION (TREE_TYPE (cnt)));\n+\t    }\n+\t}\n+      else\n+\treturn false;\n+    }\n+  else\n+    return false;\n+\n+  /* Negative value is the constant string length.  If it's less than\n+     the lower bound there is no truncation.  */\n+  int sidx = get_stridx (src);\n+  if (sidx < 0 && wi::gtu_p (cntrange[0], ~sidx))\n+    return false;\n+\n+  tree dst = gimple_call_arg (stmt, 0);\n+\n+  /* See if the destination is declared with attribute \"nonstring\"\n+     and if so, avoid the truncation warning.  */\n+  if (TREE_CODE (dst) == SSA_NAME)\n+    {\n+      if (SSA_NAME_IS_DEFAULT_DEF (dst))\n+\tdst = SSA_NAME_VAR (dst);\n+      else\n+\t{\n+\t  gimple *def = SSA_NAME_DEF_STMT (dst);\n+\n+\t  if (is_gimple_assign (def)\n+\t      && gimple_assign_rhs_code (def) == ADDR_EXPR)\n+\t    dst = gimple_assign_rhs1 (def);\n+\t}\n+    }\n+\n+  tree dstdecl = dst;\n+  if (TREE_CODE (dstdecl) == ADDR_EXPR)\n+    dstdecl = TREE_OPERAND (dstdecl, 0);\n+\n+  {\n+    tree d = dstdecl;\n+    if (TREE_CODE (d) == COMPONENT_REF)\n+      d = TREE_OPERAND (d, 1);\n+\n+    if (DECL_P (d) && lookup_attribute (\"nonstring\", DECL_ATTRIBUTES (d)))\n+      return false;\n+  }\n+\n+  /* Look for dst[i] = '\\0'; after the stxncpy() call and if found\n+     avoid the truncation warning.  */\n+  gsi_next (&gsi);\n+  gimple *next_stmt = gsi_stmt (gsi);\n+\n+  if (!gsi_end_p (gsi) && is_gimple_assign (next_stmt))\n+    {\n+      HOST_WIDE_INT off;\n+      dstdecl = get_addr_base_and_unit_offset (dstdecl, &off);\n+\n+      tree lhs = gimple_assign_lhs (next_stmt);\n+      tree lhsbase = get_addr_base_and_unit_offset (lhs, &off);\n+      if (lhsbase && operand_equal_p (dstdecl, lhsbase, 0))\n+\treturn false;\n+    }\n+\n+  int prec = TYPE_PRECISION (TREE_TYPE (cnt));\n+  wide_int lenrange[2];\n+  if (strinfo *sisrc = sidx > 0 ? get_strinfo (sidx) : NULL)\n+    {\n+      lenrange[0] = (sisrc->nonzero_chars\n+\t\t     && TREE_CODE (sisrc->nonzero_chars) == INTEGER_CST\n+\t\t     ? wi::to_wide (sisrc->nonzero_chars)\n+\t\t     : wi::zero (prec));\n+      lenrange[1] = lenrange[0];\n+    }\n+  else if (sidx < 0)\n+    lenrange[0] = lenrange[1] = wi::shwi (~sidx, prec);\n+  else\n+    {\n+      tree range[2];\n+      get_range_strlen (src, range);\n+      if (range[0])\n+\t{\n+\t  lenrange[0] = wi::to_wide (range[0], prec);\n+\t  lenrange[1] = wi::to_wide (range[1], prec);\n+\t}\n+      else\n+\t{\n+\t  lenrange[0] = wi::shwi (0, prec);\n+\t  lenrange[1] = wi::shwi (-1, prec);\n+\t}\n+    }\n+\n+  location_t callloc = gimple_location (stmt);\n+  tree func = gimple_call_fndecl (stmt);\n+\n+  if (lenrange[0] != 0 || !wi::neg_p (lenrange[1]))\n+    {\n+      /* If the longest source string is shorter than the lower bound\n+\t of the specified count the copy is definitely nul-terminated.  */\n+      if (wi::ltu_p (lenrange[1], cntrange[0]))\n+\treturn false;\n+\n+      if (wi::neg_p (lenrange[1]))\n+\t{\n+\t  /* The length of one of the strings is unknown but at least\n+\t     one has non-zero length and that length is stored in\n+\t     LENRANGE[1].  Swap the bounds to force a \"may be truncated\"\n+\t     warning below.  */\n+\t  lenrange[1] = lenrange[0];\n+\t  lenrange[0] = wi::shwi (0, prec);\n+\t}\n+\n+      if (wi::geu_p (lenrange[0], cntrange[1]))\n+\t{\n+\t  /* The shortest string is longer than the upper bound of\n+\t     the count so the truncation is certain.  */\n+\t  if (cntrange[0] == cntrange[1])\n+\t    return warning_at (callloc, OPT_Wstringop_truncation,\n+\t\t\t       integer_onep (cnt)\n+\t\t\t       ? G_(\"%qD output truncated copying %E byte \"\n+\t\t\t\t    \"from a string of length %wu\")\n+\t\t\t       : G_(\"%qD output truncated copying %E bytes \"\n+\t\t\t\t    \"from a string of length %wu\"),\n+\t\t\t       func, cnt, lenrange[0].to_uhwi ());\n+\n+\t  return warning_at (callloc, OPT_Wstringop_truncation,\n+\t\t\t     \"%qD output truncated copying between %wu \"\n+\t\t\t     \"and %wu bytes from a string of length %wu\",\n+\t\t\t     func, cntrange[0].to_uhwi (),\n+\t\t\t     cntrange[1].to_uhwi (), lenrange[0].to_uhwi ());\n+\t}\n+      else if (wi::geu_p (lenrange[1], cntrange[1]))\n+\t{\n+\t  /* The longest string is longer than the upper bound of\n+\t     the count so the truncation is possible.  */\n+\t  if (cntrange[0] == cntrange[1])\n+\t    return warning_at (callloc, OPT_Wstringop_truncation,\n+\t\t\t       integer_onep (cnt)\n+\t\t\t       ? G_(\"%qD output may be truncated copying %E \"\n+\t\t\t\t    \"byte from a string of length %wu\")\n+\t\t\t       : G_(\"%qD output may be truncated copying %E \"\n+\t\t\t\t    \"bytes from a string of length %wu\"),\n+\t\t\t       func, cnt, lenrange[1].to_uhwi ());\n+\n+\t  return warning_at (callloc, OPT_Wstringop_truncation,\n+\t\t\t     \"%qD output may be truncated copying between %wu \"\n+\t\t\t     \"and %wu bytes from a string of length %wu\",\n+\t\t\t     func, cntrange[0].to_uhwi (),\n+\t\t\t     cntrange[1].to_uhwi (), lenrange[1].to_uhwi ());\n+\t}\n+\n+      if (cntrange[0] != cntrange[1]\n+\t  && wi::leu_p (cntrange[0], lenrange[0])\n+\t  && wi::leu_p (cntrange[1], lenrange[0] + 1))\n+\t{\n+\t  /* If the source (including the terminating nul) is longer than\n+\t     the lower bound of the specified count but shorter than the\n+\t     upper bound the copy may (but need not) be truncated.  */\n+\t  return warning_at (callloc, OPT_Wstringop_truncation,\n+\t\t\t     \"%qD output may be truncated copying between %wu \"\n+\t\t\t     \"and %wu bytes from a string of length %wu\",\n+\t\t\t     func, cntrange[0].to_uhwi (),\n+\t\t\t     cntrange[1].to_uhwi (), lenrange[0].to_uhwi ());\n+\t}\n+    }\n+\n+  if (tree dstsize = compute_objsize (dst, 1))\n+    {\n+      /* The source length is uknown.  Try to determine the destination\n+\t size and see if it matches the specified bound.  If not, bail.\n+\t Otherwise go on to see if it should be diagnosed for possible\n+\t truncation.  */\n+      if (!dstsize)\n+\treturn false;\n+\n+      if (wi::to_wide (dstsize) != cntrange[1])\n+\treturn false;\n+\n+      if (cntrange[0] == cntrange[1])\n+\treturn warning_at (callloc, OPT_Wstringop_truncation,\n+\t\t\t   \"%qD specified bound %E equals destination size\",\n+\t\t\t   func, cnt);\n+    }\n+\n+  return false;\n+}\n+\n+/* Check the size argument to the built-in forms of stpncpy and strncpy\n+   to see if it's derived from calling strlen() on the source argument\n+   and if so, issue a warning.  */\n+\n+static void\n+handle_builtin_stxncpy (built_in_function, gimple_stmt_iterator *gsi)\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+\n+  bool with_bounds = gimple_call_with_bounds_p (stmt);\n+\n+  tree src = gimple_call_arg (stmt, with_bounds ? 2 : 1);\n+  tree len = gimple_call_arg (stmt, with_bounds ? 3 : 2);\n+\n+  /* If the length argument was computed from strlen(S) for some string\n+     S retrieve the strinfo index for the string (PSS->FIRST) alonng with\n+     the location of the strlen() call (PSS->SECOND).  */\n+  stridx_strlenloc *pss = strlen_to_stridx.get (len);\n+  if (!pss || pss->first <= 0)\n+    {\n+      if (maybe_diag_stxncpy_trunc (*gsi, src, len))\n+\tgimple_set_no_warning (stmt, true);\n+\n+      return;\n+    }\n+\n+  int sidx = get_stridx (src);\n+  strinfo *sisrc = sidx > 0 ? get_strinfo (sidx) : NULL;\n+\n+  /* Strncpy() et al. cannot modify the source string.  Prevent the rest\n+     of the pass from invalidating the strinfo data.  */\n+  if (sisrc)\n+    sisrc->dont_invalidate = true;\n+\n+  /* Retrieve the strinfo data for the string S that LEN was computed\n+     from as some function F of strlen (S) (i.e., LEN need not be equal\n+     to strlen(S)).  */\n+  strinfo *silen = get_strinfo (pss->first);\n+\n+  location_t callloc = gimple_location (stmt);\n+\n+  tree func = gimple_call_fndecl (stmt);\n+\n+  bool warned = false;\n+\n+  /* When -Wstringop-truncation is set, try to determine truncation\n+     before diagnosing possible overflow.  Truncation is implied by\n+     the LEN argument being equal to strlen(SRC), regardless of\n+     whether its value is known.  Otherwise, issue the more generic\n+     -Wstringop-overflow which triggers for LEN arguments that in\n+     any meaningful way depend on strlen(SRC).  */\n+  if (warn_stringop_truncation\n+      && sisrc == silen\n+      && is_strlen_related_p (src, len))\n+    warned = warning_at (callloc, OPT_Wstringop_truncation,\n+\t\t\t \"%qD output truncated before terminating nul \"\n+\t\t\t \"copying as many bytes from a string as its length\",\n+\t\t\t func);\n+  else if (silen && is_strlen_related_p (src, silen->ptr))\n+    warned = warning_at (callloc, OPT_Wstringop_overflow_,\n+\t\t\t \"%qD specified bound depends on the length \"\n+\t\t\t \"of the source argument\", func);\n+  if (warned)\n+    {\n+      location_t strlenloc = pss->second;\n+      if (strlenloc != UNKNOWN_LOCATION && strlenloc != callloc)\n+\tinform (strlenloc, \"length computed here\");\n+    }\n+}\n+\n+/* Check the size argument to the built-in forms of strncat to see if\n+   it's derived from calling strlen() on the source argument and if so,\n+   issue a warning.  */\n+\n+static void\n+handle_builtin_strncat (built_in_function bcode, gimple_stmt_iterator *gsi)\n+{\n+  /* Same as stxncpy().  */\n+  handle_builtin_stxncpy (bcode, gsi);\n+}\n+\n /* Handle a memcpy-like ({mem{,p}cpy,__mem{,p}cpy_chk}) call.\n    If strlen of the second argument is known and length of the third argument\n    is that plus one, strlen of the first argument is the same after this\n@@ -2513,6 +2889,19 @@ strlen_optimize_stmt (gimple_stmt_iterator *gsi)\n \t  case BUILT_IN_STPCPY_CHK_CHKP:\n \t    handle_builtin_strcpy (DECL_FUNCTION_CODE (callee), gsi);\n \t    break;\n+\n+\t  case BUILT_IN_STRNCAT:\n+\t  case BUILT_IN_STRNCAT_CHK:\n+\t    handle_builtin_strncat (DECL_FUNCTION_CODE (callee), gsi);\n+\t    break;\n+\n+\t  case BUILT_IN_STPNCPY:\n+\t  case BUILT_IN_STPNCPY_CHK:\n+\t  case BUILT_IN_STRNCPY:\n+\t  case BUILT_IN_STRNCPY_CHK:\n+\t    handle_builtin_stxncpy (DECL_FUNCTION_CODE (callee), gsi);\n+\t    break;\n+\n \t  case BUILT_IN_MEMCPY:\n \t  case BUILT_IN_MEMCPY_CHK:\n \t  case BUILT_IN_MEMPCPY:\n@@ -2576,6 +2965,10 @@ strlen_optimize_stmt (gimple_stmt_iterator *gsi)\n \telse if (code == EQ_EXPR || code == NE_EXPR)\n \t  fold_strstr_to_strncmp (gimple_assign_rhs1 (stmt),\n \t\t\t\t  gimple_assign_rhs2 (stmt), stmt);\n+\n+\ttree rhs1 = gimple_assign_rhs1 (stmt);\n+\tif (stridx_strlenloc *ps = strlen_to_stridx.get (rhs1))\n+\t  strlen_to_stridx.put (lhs, *ps);\n       }\n     else if (TREE_CODE (lhs) != SSA_NAME && !TREE_SIDE_EFFECTS (lhs))\n \t{\n@@ -2827,6 +3220,8 @@ pass_strlen::execute (function *fun)\n   laststmt.len = NULL_TREE;\n   laststmt.stridx = 0;\n \n+  strlen_to_stridx.empty ();\n+\n   return 0;\n }\n "}]}