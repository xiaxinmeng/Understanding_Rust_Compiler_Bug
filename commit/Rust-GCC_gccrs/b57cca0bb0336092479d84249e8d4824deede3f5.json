{"sha": "b57cca0bb0336092479d84249e8d4824deede3f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU3Y2NhMGJiMDMzNjA5MjQ3OWQ4NDI0OWU4ZDQ4MjRkZWVkZTNmNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-01-23T09:25:52Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-01-23T09:25:52Z"}, "message": "re PR rtl-optimization/51933 (wrong code due to -free)\n\n\tPR rtl-optimization/51933\n\t* ree.c (transform_ifelse): Return true right away if dstreg is\n\talready wider or equal to cand->mode.\n\t(enum ext_modified_kind, struct ext_modified, ext_state): New types.\n\t(make_defs_and_copies_lists): Remove defs_list and copies_list\n\targuments, add state argument, just truncate state->work_list\n\tinstead of always allocating and freeing the vector.  Assert that\n\tget_defs succeeds instead of returning 2.  Changed return type to\n\tbool.\n\t(merge_def_and_ext): Add state argument.  If SET_DEST doesn't\n\thave ext_src_mode, see if it has been modified already with the\n\tright kind of extension and has been extended before from the\n\text_src_mode.  If SET_DEST is already wider or equal to cand->mode,\n\tjust return true.  Remember the original mode in state->modified\n\tarray.\n\t(combine_reaching_defs): Add state argument.  Don't allocate and\n\tfree here def_list, copied_list and vec vectors, instead just\n\tVEC_truncate the vectors in *state.  Don't handle outcome == 2\n\there.\n\t(find_and_remove_re): Set DF_DEFER_INSN_RESCAN df flag.\n\tAdd state variable, clear vectors in it, initialize state.modified\n\tif needed.  Free all the vectors at the end and state.modified too.\n\tDon't skip a candidate if the extension expression has been modified.\n\n\t* gcc.c-torture/execute/pr51933.c: New test.\n\nFrom-SVN: r183416", "tree": {"sha": "d52514dd33f5fb5fc05c9acbf852a7e2836de4aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d52514dd33f5fb5fc05c9acbf852a7e2836de4aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b57cca0bb0336092479d84249e8d4824deede3f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b57cca0bb0336092479d84249e8d4824deede3f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b57cca0bb0336092479d84249e8d4824deede3f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b57cca0bb0336092479d84249e8d4824deede3f5/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3aa0ca8345ecadca2f3482bc78074b634557164", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3aa0ca8345ecadca2f3482bc78074b634557164", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3aa0ca8345ecadca2f3482bc78074b634557164"}], "stats": {"total": 293, "additions": 210, "deletions": 83}, "files": [{"sha": "80f124a65deab63531ac37cfbfcb0e79a0276b54", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57cca0bb0336092479d84249e8d4824deede3f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57cca0bb0336092479d84249e8d4824deede3f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b57cca0bb0336092479d84249e8d4824deede3f5", "patch": "@@ -1,3 +1,29 @@\n+2012-01-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/51933\n+\t* ree.c (transform_ifelse): Return true right away if dstreg is\n+\talready wider or equal to cand->mode.\n+\t(enum ext_modified_kind, struct ext_modified, ext_state): New types.\n+\t(make_defs_and_copies_lists): Remove defs_list and copies_list\n+\targuments, add state argument, just truncate state->work_list\n+\tinstead of always allocating and freeing the vector.  Assert that\n+\tget_defs succeeds instead of returning 2.  Changed return type to\n+\tbool.\n+\t(merge_def_and_ext): Add state argument.  If SET_DEST doesn't\n+\thave ext_src_mode, see if it has been modified already with the\n+\tright kind of extension and has been extended before from the\n+\text_src_mode.  If SET_DEST is already wider or equal to cand->mode,\n+\tjust return true.  Remember the original mode in state->modified\n+\tarray.\n+\t(combine_reaching_defs): Add state argument.  Don't allocate and\n+\tfree here def_list, copied_list and vec vectors, instead just\n+\tVEC_truncate the vectors in *state.  Don't handle outcome == 2\n+\there.\n+\t(find_and_remove_re): Set DF_DEFER_INSN_RESCAN df flag.\n+\tAdd state variable, clear vectors in it, initialize state.modified\n+\tif needed.  Free all the vectors at the end and state.modified too.\n+\tDon't skip a candidate if the extension expression has been modified.\n+\n 2012-01-22  Douglas B Rupp  <rupp@gnat.com>\n \n \tPR target/47096"}, {"sha": "3f670911062a41112d7450495749e78197252bab", "filename": "gcc/ree.c", "status": "modified", "additions": 128, "deletions": 83, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57cca0bb0336092479d84249e8d4824deede3f5/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57cca0bb0336092479d84249e8d4824deede3f5/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=b57cca0bb0336092479d84249e8d4824deede3f5", "patch": "@@ -1,5 +1,5 @@\n /* Redundant Extension Elimination pass for the GNU compiler.\n-   Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n+   Copyright (C) 2010, 2011, 2012 Free Software Foundation, Inc.\n    Contributed by Ilya Enkovich (ilya.enkovich@intel.com)\n \n    Based on the Redundant Zero-extension elimination pass contributed by\n@@ -380,6 +380,11 @@ transform_ifelse (ext_cand *cand, rtx def_insn)\n   dstreg = SET_DEST (set_insn);\n   srcreg = XEXP (SET_SRC (set_insn), 1);\n   srcreg2 = XEXP (SET_SRC (set_insn), 2);\n+  /* If the conditional move already has the right or wider mode,\n+     there is nothing to do.  */\n+  if (GET_MODE_SIZE (GET_MODE (dstreg)) >= GET_MODE_SIZE (cand->mode))\n+    return true;\n+\n   map_srcreg = gen_rtx_REG (cand->mode, REGNO (srcreg));\n   map_srcreg2 = gen_rtx_REG (cand->mode, REGNO (srcreg2));\n   map_dstreg = gen_rtx_REG (cand->mode, REGNO (dstreg));\n@@ -466,43 +471,77 @@ is_cond_copy_insn (rtx insn, rtx *reg1, rtx *reg2)\n   return false;\n }\n \n+enum ext_modified_kind\n+{\n+  /* The insn hasn't been modified by ree pass yet.  */\n+  EXT_MODIFIED_NONE,\n+  /* Changed into zero extension.  */\n+  EXT_MODIFIED_ZEXT,\n+  /* Changed into sign extension.  */\n+  EXT_MODIFIED_SEXT\n+};\n+\n+struct ext_modified\n+{\n+  /* Mode from which ree has zero or sign extended the destination.  */\n+  ENUM_BITFIELD(machine_mode) mode : 8;\n+\n+  /* Kind of modification of the insn.  */\n+  ENUM_BITFIELD(ext_modified_kind) kind : 2;\n+\n+  /* True if the insn is scheduled to be deleted.  */\n+  unsigned int deleted : 1;\n+};\n+\n+/* Vectors used by combine_reaching_defs and its helpers.  */\n+typedef struct ext_state\n+{\n+  /* In order to avoid constant VEC_alloc/VEC_free, we keep these\n+     4 vectors live through the entire find_and_remove_re and just\n+     VEC_truncate them each time.  */\n+  VEC (rtx, heap) *defs_list;\n+  VEC (rtx, heap) *copies_list;\n+  VEC (rtx, heap) *modified_list;\n+  VEC (rtx, heap) *work_list;\n+\n+  /* For instructions that have been successfully modified, this is\n+     the original mode from which the insn is extending and\n+     kind of extension.  */\n+  struct ext_modified *modified;\n+} ext_state;\n+\n /* Reaching Definitions of the extended register could be conditional copies\n    or regular definitions.  This function separates the two types into two\n-   lists, DEFS_LIST and COPIES_LIST.  This is necessary because, if a reaching\n-   definition is a conditional copy, merging the extension with this definition\n-   is wrong.  Conditional copies are merged by transitively merging their\n-   definitions.  The defs_list is populated with all the reaching definitions\n-   of the extension instruction (EXTEND_INSN) which must be merged with an\n-   extension.  The copies_list contains all the conditional moves that will\n-   later be extended into a wider mode conditional move if all the merges are\n-   successful.  The function returns 0 upon failure, 1 upon success and 2 when\n-   all definitions of the EXTEND_INSN have been previously merged.  */\n-\n-static int\n+   lists, STATE->DEFS_LIST and STATE->COPIES_LIST.  This is necessary because,\n+   if a reaching definition is a conditional copy, merging the extension with\n+   this definition is wrong.  Conditional copies are merged by transitively\n+   merging their definitions.  The defs_list is populated with all the reaching\n+   definitions of the extension instruction (EXTEND_INSN) which must be merged\n+   with an extension.  The copies_list contains all the conditional moves that\n+   will later be extended into a wider mode conditional move if all the merges\n+   are successful.  The function returns false upon failure, true upon\n+   success.  */\n+\n+static bool\n make_defs_and_copies_lists (rtx extend_insn, rtx set_pat,\n-                            VEC (rtx,heap) **defs_list,\n-                            VEC (rtx,heap) **copies_list)\n+\t\t\t    ext_state *state)\n {\n-  VEC (rtx,heap) *work_list = VEC_alloc (rtx, heap, 8);\n   rtx src_reg = XEXP (SET_SRC (set_pat), 0);\n   bool *is_insn_visited;\n-  int ret = 1;\n+  bool ret = true;\n+\n+  VEC_truncate (rtx, state->work_list, 0);\n \n   /* Initialize the work list.  */\n-  if (!get_defs (extend_insn, src_reg, &work_list))\n-    {\n-      VEC_free (rtx, heap, work_list);\n-      /* The number of defs being equal to zero can only mean that all the\n-         definitions have been previously merged.  */\n-      return 2;\n-    }\n+  if (!get_defs (extend_insn, src_reg, &state->work_list))\n+    gcc_unreachable ();\n \n   is_insn_visited = XCNEWVEC (bool, max_insn_uid);\n \n   /* Perform transitive closure for conditional copies.  */\n-  while (!VEC_empty (rtx, work_list))\n+  while (!VEC_empty (rtx, state->work_list))\n     {\n-      rtx def_insn = VEC_pop (rtx, work_list);\n+      rtx def_insn = VEC_pop (rtx, state->work_list);\n       rtx reg1, reg2;\n \n       gcc_assert (INSN_UID (def_insn) < max_insn_uid);\n@@ -514,22 +553,21 @@ make_defs_and_copies_lists (rtx extend_insn, rtx set_pat,\n       if (is_cond_copy_insn (def_insn, &reg1, &reg2))\n \t{\n \t  /* Push it onto the copy list first.  */\n-\t  VEC_safe_push (rtx, heap, *copies_list, def_insn);\n+\t  VEC_safe_push (rtx, heap, state->copies_list, def_insn);\n \n \t  /* Now perform the transitive closure.  */\n-\t  if (!get_defs (def_insn, reg1, &work_list)\n-\t      || !get_defs (def_insn, reg2, &work_list))\n+\t  if (!get_defs (def_insn, reg1, &state->work_list)\n+\t      || !get_defs (def_insn, reg2, &state->work_list))\n \t    {\n-\t      ret = 0;\n+\t      ret = false;\n \t      break;\n \t    }\n         }\n       else\n-\tVEC_safe_push (rtx, heap, *defs_list, def_insn);\n+\tVEC_safe_push (rtx, heap, state->defs_list, def_insn);\n     }\n \n   XDELETEVEC (is_insn_visited);\n-  VEC_free (rtx, heap, work_list);\n \n   return ret;\n }\n@@ -538,7 +576,7 @@ make_defs_and_copies_lists (rtx extend_insn, rtx set_pat,\n    on the SET pattern.  */\n \n static bool\n-merge_def_and_ext (ext_cand *cand, rtx def_insn)\n+merge_def_and_ext (ext_cand *cand, rtx def_insn, ext_state *state)\n {\n   enum machine_mode ext_src_mode;\n   enum rtx_code code;\n@@ -577,10 +615,27 @@ merge_def_and_ext (ext_cand *cand, rtx def_insn)\n \n   gcc_assert (sub_rtx != NULL);\n \n-  if (GET_CODE (SET_DEST (*sub_rtx)) == REG\n-      && GET_MODE (SET_DEST (*sub_rtx)) == ext_src_mode)\n+  if (REG_P (SET_DEST (*sub_rtx))\n+      && (GET_MODE (SET_DEST (*sub_rtx)) == ext_src_mode\n+\t  || ((state->modified[INSN_UID (def_insn)].kind\n+\t       == (cand->code == ZERO_EXTEND\n+\t\t   ? EXT_MODIFIED_ZEXT : EXT_MODIFIED_SEXT))\n+\t      && state->modified[INSN_UID (def_insn)].mode\n+\t\t == ext_src_mode)))\n     {\n-      return combine_set_extension (cand, def_insn, sub_rtx);\n+      if (GET_MODE_SIZE (GET_MODE (SET_DEST (*sub_rtx)))\n+\t  >= GET_MODE_SIZE (cand->mode))\n+\treturn true;\n+      /* If def_insn is already scheduled to be deleted, don't attempt\n+\t to modify it.  */\n+      if (state->modified[INSN_UID (def_insn)].deleted)\n+\treturn false;\n+      if (combine_set_extension (cand, def_insn, sub_rtx))\n+\t{\n+\t  if (state->modified[INSN_UID (def_insn)].kind == EXT_MODIFIED_NONE)\n+\t    state->modified[INSN_UID (def_insn)].mode = ext_src_mode;\n+\t  return true;\n+\t}\n     }\n \n   return false;\n@@ -596,48 +651,31 @@ merge_def_and_ext (ext_cand *cand, rtx def_insn)\n    and false upon failure.  */\n \n static bool\n-combine_reaching_defs (ext_cand *cand, rtx set_pat)\n+combine_reaching_defs (ext_cand *cand, rtx set_pat, ext_state *state)\n {\n   rtx def_insn;\n   bool merge_successful = true;\n   int i;\n   int defs_ix;\n-  int outcome;\n-  VEC (rtx, heap) *defs_list, *copies_list, *vec;\n-\n-  defs_list = VEC_alloc (rtx, heap, 8);\n-  copies_list = VEC_alloc (rtx, heap, 8);\n+  bool outcome;\n \n-  outcome = make_defs_and_copies_lists (cand->insn,\n-                                        set_pat, &defs_list, &copies_list);\n+  VEC_truncate (rtx, state->defs_list, 0);\n+  VEC_truncate (rtx, state->copies_list, 0);\n \n-  /* outcome == 2 means that all the definitions for this extension have been\n-     previously merged when handling other extensions.  */\n-  if (outcome == 2)\n-    {\n-      VEC_free (rtx, heap, defs_list);\n-      VEC_free (rtx, heap, copies_list);\n-      if (dump_file)\n-        fprintf (dump_file, \"All definitions have been previously merged.\\n\");\n-      return true;\n-    }\n+  outcome = make_defs_and_copies_lists (cand->insn, set_pat, state);\n \n-  if (outcome == 0)\n-    {\n-      VEC_free (rtx, heap, defs_list);\n-      VEC_free (rtx, heap, copies_list);\n-      return false;\n-    }\n+  if (!outcome)\n+    return false;\n \n   merge_successful = true;\n \n   /* Go through the defs vector and try to merge all the definitions\n      in this vector.  */\n-  vec = VEC_alloc (rtx, heap, 8);\n-  FOR_EACH_VEC_ELT (rtx, defs_list, defs_ix, def_insn)\n+  VEC_truncate (rtx, state->modified_list, 0);\n+  FOR_EACH_VEC_ELT (rtx, state->defs_list, defs_ix, def_insn)\n     {\n-      if (merge_def_and_ext (cand, def_insn))\n-        VEC_safe_push (rtx, heap, vec, def_insn);\n+      if (merge_def_and_ext (cand, def_insn, state))\n+\tVEC_safe_push (rtx, heap, state->modified_list, def_insn);\n       else\n         {\n           merge_successful = false;\n@@ -649,12 +687,10 @@ combine_reaching_defs (ext_cand *cand, rtx set_pat)\n      the copies in this vector.  */\n   if (merge_successful)\n     {\n-      FOR_EACH_VEC_ELT (rtx, copies_list, i, def_insn)\n+      FOR_EACH_VEC_ELT (rtx, state->copies_list, i, def_insn)\n         {\n           if (transform_ifelse (cand, def_insn))\n-            {\n-              VEC_safe_push (rtx, heap, vec, def_insn);\n-            }\n+\t    VEC_safe_push (rtx, heap, state->modified_list, def_insn);\n           else\n             {\n               merge_successful = false;\n@@ -675,9 +711,12 @@ combine_reaching_defs (ext_cand *cand, rtx set_pat)\n           if (dump_file)\n             fprintf (dump_file, \"All merges were successful.\\n\");\n \n-          VEC_free (rtx, heap, vec);\n-          VEC_free (rtx, heap, defs_list);\n-          VEC_free (rtx, heap, copies_list);\n+\t  FOR_EACH_VEC_ELT (rtx, state->modified_list, i, def_insn)\n+\t    if (state->modified[INSN_UID (def_insn)].kind == EXT_MODIFIED_NONE)\n+\t      state->modified[INSN_UID (def_insn)].kind\n+\t\t= (cand->code == ZERO_EXTEND\n+\t\t   ? EXT_MODIFIED_ZEXT : EXT_MODIFIED_SEXT);\n+\n           return true;\n         }\n       else\n@@ -689,7 +728,7 @@ combine_reaching_defs (ext_cand *cand, rtx set_pat)\n             {\n \t      fprintf (dump_file,\n \t\t       \"Merge cancelled, non-mergeable definitions:\\n\");\n-\t      FOR_EACH_VEC_ELT (rtx, vec, i, def_insn)\n+\t      FOR_EACH_VEC_ELT (rtx, state->modified_list, i, def_insn)\n \t        print_rtl_single (dump_file, def_insn);\n             }\n         }\n@@ -700,10 +739,6 @@ combine_reaching_defs (ext_cand *cand, rtx set_pat)\n       cancel_changes (0);\n     }\n \n-  VEC_free (rtx, heap, vec);\n-  VEC_free (rtx, heap, defs_list);\n-  VEC_free (rtx, heap, copies_list);\n-\n   return false;\n }\n \n@@ -829,39 +864,44 @@ find_and_remove_re (void)\n   int num_re_opportunities = 0, num_realized = 0, i;\n   VEC (ext_cand, heap) *reinsn_list;\n   VEC (rtx, heap) *reinsn_del_list;\n+  ext_state state;\n \n   /* Construct DU chain to get all reaching definitions of each\n      extension instruction.  */\n   df_chain_add_problem (DF_UD_CHAIN + DF_DU_CHAIN);\n   df_analyze ();\n+  df_set_flags (DF_DEFER_INSN_RESCAN);\n \n   max_insn_uid = get_max_uid ();\n-  reinsn_del_list = VEC_alloc (rtx, heap, 4);\n+  reinsn_del_list = NULL;\n   reinsn_list = find_removable_extensions ();\n+  state.defs_list = NULL;\n+  state.copies_list = NULL;\n+  state.modified_list = NULL;\n+  state.work_list = NULL;\n+  if (VEC_empty (ext_cand, reinsn_list))\n+    state.modified = NULL;\n+  else\n+    state.modified = XCNEWVEC (struct ext_modified, max_insn_uid);\n \n   FOR_EACH_VEC_ELT (ext_cand, reinsn_list, i, curr_cand)\n     {\n       num_re_opportunities++;\n \n-      /* If the candidate insn is itself a definition insn for another\n-         candidate, it may have been modified and the UD chain broken.\n-         FIXME: the handling of successive extensions can be improved.  */\n-      if (!reg_mentioned_p (curr_cand->expr, PATTERN (curr_cand->insn)))\n-\tcontinue;\n-\n       /* Try to combine the extension with the definition.  */\n       if (dump_file)\n         {\n           fprintf (dump_file, \"Trying to eliminate extension:\\n\");\n           print_rtl_single (dump_file, curr_cand->insn);\n         }\n \n-      if (combine_reaching_defs (curr_cand, PATTERN (curr_cand->insn)))\n+      if (combine_reaching_defs (curr_cand, PATTERN (curr_cand->insn), &state))\n         {\n           if (dump_file)\n             fprintf (dump_file, \"Eliminated the extension.\\n\");\n           num_realized++;\n           VEC_safe_push (rtx, heap, reinsn_del_list, curr_cand->insn);\n+\t  state.modified[INSN_UID (curr_cand->insn)].deleted = 1;\n         }\n     }\n \n@@ -871,6 +911,11 @@ find_and_remove_re (void)\n \n   VEC_free (ext_cand, heap, reinsn_list);\n   VEC_free (rtx, heap, reinsn_del_list);\n+  VEC_free (rtx, heap, state.defs_list);\n+  VEC_free (rtx, heap, state.copies_list);\n+  VEC_free (rtx, heap, state.modified_list);\n+  VEC_free (rtx, heap, state.work_list);\n+  XDELETEVEC (state.modified);\n \n   if (dump_file && num_re_opportunities > 0)\n     fprintf (dump_file, \"Elimination opportunities = %d realized = %d\\n\","}, {"sha": "dee2c0d13b1f0eae487104e6d620c31f0eb270a8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57cca0bb0336092479d84249e8d4824deede3f5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57cca0bb0336092479d84249e8d4824deede3f5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b57cca0bb0336092479d84249e8d4824deede3f5", "patch": "@@ -1,3 +1,8 @@\n+2012-01-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/51933\n+\t* gcc.c-torture/execute/pr51933.c: New test.\n+\n 2012-01-22  Douglas B Rupp  <rupp@gnat.com>\n \n \t* gcc.dg/builtins-config.h (HAVE_C99_RUNTIME):"}, {"sha": "a6556c94c11acbaec08e1186edb72dc0a076ec1f", "filename": "gcc/testsuite/gcc.c-torture/execute/pr51933.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57cca0bb0336092479d84249e8d4824deede3f5/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr51933.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57cca0bb0336092479d84249e8d4824deede3f5/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr51933.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr51933.c?ref=b57cca0bb0336092479d84249e8d4824deede3f5", "patch": "@@ -0,0 +1,51 @@\n+/* PR rtl-optimization/51933 */\n+\n+static signed char v1;\n+static unsigned char v2[256], v3[256];\n+\n+__attribute__((noclone, noinline)) void\n+foo (void)\n+{\n+  asm volatile (\"\" : : \"g\" (&v1), \"g\" (&v2[0]), \"g\" (&v3[0]) : \"memory\");\n+}\n+\n+__attribute__((noclone, noinline)) int\n+bar (const int x, const unsigned short *y, char *z)\n+{\n+  int i;\n+  unsigned short u;\n+  if (!v1)\n+    foo ();\n+  for (i = 0; i < x; i++)\n+    {\n+      u = y[i];\n+      z[i] = u < 0x0100 ? v2[u] : v3[u & 0xff];\n+    }\n+  z[x] = '\\0';\n+  return x;\n+}\n+\n+int\n+main (void)\n+{\n+  char buf[18];\n+  unsigned short s[18];\n+  unsigned char c[18] = \"abcdefghijklmnopq\";\n+  int i;\n+  for (i = 0; i < 256; i++)\n+    {\n+      v2[i] = i;\n+      v3[i] = i + 1;\n+    }\n+  for (i = 0; i < 18; i++)\n+    s[i] = c[i];\n+  s[5] |= 0x600;\n+  s[6] |= 0x500;\n+  s[11] |= 0x2000;\n+  s[15] |= 0x500;\n+  foo ();\n+  if (bar (17, s, buf) != 17\n+      || __builtin_memcmp (buf, \"abcdeghhijkmmnoqq\", 18) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}