{"sha": "46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZlOGMwNzVkMDE4YjM2NWNlMmE3ZWJiYTM5NmViY2YzMjM1YzZkNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-25T20:32:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-25T20:32:04Z"}, "message": "Make-lang.in (CXX_SRCS): Add optimize.c.\n\n1999-11-25  Mark Mitchell  <mark@codesourcery.com>\n\n\t* Make-lang.in (CXX_SRCS): Add optimize.c.\n\t* Makefile.in (CXX_OBJS): Add optimize.o.\n\t(CXX_TREE_H): Add splay-tree.h, system.h, and $(CONFIG_H).\n\t(spew.o, lex.o, decl.o, decl2.o, typeck2.o, typeck.o): Adjust.\n\t(class.o, call.o, friend.o, init.o, method.o, cvt.o): Likewise.\n\t(search.o, tree.o, ptree.o, rtti.o, except.o, expr.o): Likewise.\n\t(xref.o, pt.o, error.o, errfn.o, repo.o, semantics.o): Likewise.\n\t(dump.o): Likewise.\n\t(optimize.o): New target.\n\t* class.c: Don't include splay-tree.h.\n\t* cp-tree.def (CTOR_COMPLETE): Rename to CTOR_STMT.\n\t* cp-tree.h: Include splay-tree.h.\n\t(DECL_UNINLINABLE): New macro.\n\t(CTOR_BEGIN_P, CTOR_END_P): New macros.\n\t(flag_inline_trees): New variable.\n\t(local_variable_p): New function.\n\t(nonstatic_local_decl_p): Likewise.\n\t(optimize_function): Likewise.\n\t(cplus_unsave_expr_now): Remove.\n\t(copy_tree_r): Declare.\n\t(remap_save_expr): Likewise.\n\t* decl.c (local_variable_p): Don't\n\tmake it static.\n\t(local_variable_p_walkfn): New function.\n\t(make_rtl_for_local_static): Remove code to try to avoid writing\n\tout static constants.\n\t(emit_local_var): Fix indentation.\n\t(nonstatic_local_decl_p): New function.\n\t(check_default_argument): Use local_variable_p_walkfn, not\n\tlocal_variable_p, when walking the tree.\n\t(start_function): Set the DECL_CONTEXT for automatically generated\n\tlabels.\n\t(finish_constructor_body): Use CTOR_STMT to mark the end of a\n\tconstructor.\n\t* decl2.c: Don't include splay-tree.h.\n\t(flag_inline_trees): Define.\n\t* dump.c: Don't include\n\tsplay-tree.h.\n\t* except.c (expand_end_catch_block): Fix comment formatting.\n\t(expand_end_eh_spec): Set DECL_CONTEXT on temporary variables.\n\t(expand_throw): Tidy comment.\n\t* init.c (build_vec_delete_1): Use create_temporary_var.\n\t* lex.c (cplus_tree_code_type): Make it static.\n\t(cplus_tree_code_length): Likewise.\n\t(cplus_tree_code_name): Likewise.\n\t* optimize.c: New file.\n\t* semantics.c (finish_goto_stmt): Set DECL_UNLINABLE for functions\n\twith computed gotos.\n\t(setup_vtbl_ptr): Mark the beginnings of constructors with\n\tCTOR_STMT.\n\t(expand_stmt): Handle CTOR_STMT, not CTOR_COMPLETE.\n\t(expand_body): Call optimize_function.  Save bodies if we're doing\n\tinlining on trees.\n\t* tree.c: Don't include splay-tree.h.  Include insn-config.h and\n\tintegrate.h.\n\t(copy_tree_r): Make it public.\n\t(statement_code_p): New function.\n\t(mark_local_for_remap_r): Likewise.\n\t(cp_usave_r): Likewise.\n\t(cp_unsave): Likewise.\n\t(build_cplus_new): Set DECL_CONTEXT for temporary variables.\n\t(walk_tree): Walk into `s' class nodes.  Walk statement chains.\n\t(copy_tree_r): Handle 's' class nodes.  Restore chains for\n\tstatements.  Nullify scopes.  Don't copy types.\n\t(init_tree): Set lang_unsave to cp_unsave.\n\t(remap_save_expr): Define.\n\t* ir.texi: Document CTOR_STMT.\n\nFrom-SVN: r30669", "tree": {"sha": "6a30aa313c71b882f0e7584378a69d423e4e3c9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a30aa313c71b882f0e7584378a69d423e4e3c9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/comments", "author": null, "committer": null, "parents": [{"sha": "82d26ad03d70cfdccf19a9f97bf9d58fcebaba95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82d26ad03d70cfdccf19a9f97bf9d58fcebaba95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82d26ad03d70cfdccf19a9f97bf9d58fcebaba95"}], "stats": {"total": 1121, "additions": 965, "deletions": 156}, "files": [{"sha": "c020d438e6f3fb7125355543f3fad32e71a727b0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -1,3 +1,73 @@\n+1999-11-25  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Make-lang.in (CXX_SRCS): Add optimize.c.  \n+\t* Makefile.in (CXX_OBJS): Add optimize.o.\n+\t(CXX_TREE_H): Add splay-tree.h, system.h, and $(CONFIG_H).\n+\t(spew.o, lex.o, decl.o, decl2.o, typeck2.o, typeck.o): Adjust.\n+\t(class.o, call.o, friend.o, init.o, method.o, cvt.o): Likewise.\n+\t(search.o, tree.o, ptree.o, rtti.o, except.o, expr.o): Likewise.\n+\t(xref.o, pt.o, error.o, errfn.o, repo.o, semantics.o): Likewise.\n+\t(dump.o): Likewise.\n+\t(optimize.o): New target.  \n+\t* class.c: Don't include splay-tree.h.\n+\t* cp-tree.def (CTOR_COMPLETE): Rename to CTOR_STMT.  \n+\t* cp-tree.h: Include splay-tree.h.\n+\t(DECL_UNINLINABLE): New macro.\n+\t(CTOR_BEGIN_P, CTOR_END_P): New macros.\n+\t(flag_inline_trees): New variable.\n+\t(local_variable_p): New function.\n+\t(nonstatic_local_decl_p): Likewise.\n+\t(optimize_function): Likewise.\n+\t(cplus_unsave_expr_now): Remove.\n+\t(copy_tree_r): Declare.\n+\t(remap_save_expr): Likewise.  \n+\t* decl.c (local_variable_p): Don't\n+\tmake it static.\n+\t(local_variable_p_walkfn): New function.\n+\t(make_rtl_for_local_static): Remove code to try to avoid writing\n+\tout static constants.\n+\t(emit_local_var): Fix indentation.\n+\t(nonstatic_local_decl_p): New function.\n+\t(check_default_argument): Use local_variable_p_walkfn, not\n+\tlocal_variable_p, when walking the tree.\n+\t(start_function): Set the DECL_CONTEXT for automatically generated\n+\tlabels.\n+\t(finish_constructor_body): Use CTOR_STMT to mark the end of a\n+\tconstructor.  \n+\t* decl2.c: Don't include splay-tree.h.\n+\t(flag_inline_trees): Define.  \n+\t* dump.c: Don't include\n+\tsplay-tree.h.  \n+\t* except.c (expand_end_catch_block): Fix comment formatting.\n+\t(expand_end_eh_spec): Set DECL_CONTEXT on temporary variables.\n+\t(expand_throw): Tidy comment.  \n+\t* init.c (build_vec_delete_1): Use create_temporary_var.  \n+\t* lex.c (cplus_tree_code_type): Make it static.\n+\t(cplus_tree_code_length): Likewise.\n+\t(cplus_tree_code_name): Likewise.  \n+\t* optimize.c: New file.  \n+\t* semantics.c (finish_goto_stmt): Set DECL_UNLINABLE for functions\n+\twith computed gotos.\n+\t(setup_vtbl_ptr): Mark the beginnings of constructors with\n+\tCTOR_STMT.\n+\t(expand_stmt): Handle CTOR_STMT, not CTOR_COMPLETE.\n+\t(expand_body): Call optimize_function.  Save bodies if we're doing\n+\tinlining on trees.\n+\t* tree.c: Don't include splay-tree.h.  Include insn-config.h and\n+\tintegrate.h.\n+\t(copy_tree_r): Make it public.\n+\t(statement_code_p): New function.\n+\t(mark_local_for_remap_r): Likewise.\n+\t(cp_usave_r): Likewise.\n+\t(cp_unsave): Likewise.\n+\t(build_cplus_new): Set DECL_CONTEXT for temporary variables.\n+\t(walk_tree): Walk into `s' class nodes.  Walk statement chains.\n+\t(copy_tree_r): Handle 's' class nodes.  Restore chains for\n+\tstatements.  Nullify scopes.  Don't copy types.\n+\t(init_tree): Set lang_unsave to cp_unsave.\n+\t(remap_save_expr): Define.\n+\t* ir.texi: Document CTOR_STMT.\n+\t\n 1999-11-24  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* search.c (note_debug_info_needed): Do perform this optimization"}, {"sha": "ffb1b0c6ab6a215cb581b1c44a6625cb4e2635fb", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -118,7 +118,7 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/decl2.c \\\n  $(srcdir)/cp/error.c $(srcdir)/cp/friend.c $(srcdir)/cp/init.c \\\n  $(srcdir)/cp/parse.y $(srcdir)/cp/typeck2.c \\\n  $(srcdir)/cp/repo.c $(srcdir)/cp/semantics.c \\\n- $(srcdir)/cp/dump.c\n+ $(srcdir)/cp/dump.c $(srcdir)/cp/optimize.c\n \n cc1plus$(exeext): $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o \\\n         c-pragma.o $(srcdir)/cp/cp-tree.h $(srcdir)/cp/cp-tree.def \\"}, {"sha": "900823c8e7f17934632c40c54161a27fd8f68ca5", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 54, "deletions": 50, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -175,7 +175,7 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config -I$(srcdir)\n CXX_OBJS = call.o decl.o errfn.o expr.o pt.o typeck2.o \\\n  class.o decl2.o error.o lex.o parse.o ptree.o rtti.o spew.o typeck.o cvt.o \\\n  except.o friend.o init.o method.o search.o semantics.o tree.o xref.o \\\n- repo.o dump.o @extra_cxx_objs@\n+ repo.o dump.o optimize.o @extra_cxx_objs@\n \n # Language-independent object files.\n OBJS = `cat ../stamp-objlist` ../c-common.o ../c-pragma.o\n@@ -202,12 +202,14 @@ RTL_H = $(srcdir)/../rtl.h $(srcdir)/../rtl.def \\\n TREE_H = $(srcdir)/../tree.h $(srcdir)/../real.h $(srcdir)/../tree.def \\\n \t$(srcdir)/../machmode.h $(srcdir)/../machmode.def\n CXX_TREE_H = $(TREE_H) cp-tree.h $(srcdir)/../c-common.h cp-tree.def \\\n-\t$(srcdir)/../function.h $(srcdir)/../varray.h\n+\t$(srcdir)/../function.h $(srcdir)/../varray.h \\\n+\t$(srcdir)/../../include/splay-tree.h \\\n+\t$(srcdir)/../system.h $(CONFIG_H)\n PARSE_H = $(srcdir)/parse.h\n PARSE_C = $(srcdir)/parse.c\n EXPR_H = $(srcdir)/../expr.h ../insn-codes.h\n \n-parse.o : $(PARSE_C) $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h \\\n+parse.o : $(PARSE_C) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h \\\n \t$(srcdir)/../except.h $(srcdir)/../output.h $(srcdir)/../system.h \\\n \t$(srcdir)/../toplev.h $(srcdir)/../ggc.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(BIG_SWITCHFLAG) \\\n@@ -239,64 +241,66 @@ $(srcdir)/hash.h: $(srcdir)/gxx.gperf\n \techo \"\tftp://sourceware.cygnus.com/pub/egcs/infrastructure/gperf*\" >&2 ; \\\n \texit 1 )\n \n-spew.o : spew.c $(CONFIG_H) $(CXX_TREE_H) $(PARSE_H) $(srcdir)/../flags.h \\\n-  lex.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n-lex.o : lex.c $(CONFIG_H) $(CXX_TREE_H) \\\n+spew.o : spew.c $(CXX_TREE_H) $(PARSE_H) $(srcdir)/../flags.h \\\n+  lex.h $(srcdir)/../toplev.h\n+lex.o : lex.c $(CXX_TREE_H) \\\n   $(PARSE_H) input.c $(srcdir)/../flags.h hash.h lex.h \\\n-  $(srcdir)/../c-pragma.h $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n+  $(srcdir)/../c-pragma.h $(srcdir)/../toplev.h \\\n   $(srcdir)/../output.h $(srcdir)/../mbchar.h $(srcdir)/../ggc.h\n-decl.o : decl.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n+decl.o : decl.c $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   lex.h decl.h $(srcdir)/../stack.h $(srcdir)/../output.h  \\\n-  $(srcdir)/../except.h $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n+  $(srcdir)/../except.h $(srcdir)/../toplev.h \\\n   $(srcdir)/../hash.h $(srcdir)/../ggc.h $(RTL_H)\n-decl2.o : decl2.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n-  lex.h decl.h $(EXPR_H) $(srcdir)/../except.h \\\n-  $(srcdir)/../output.h $(srcdir)/../except.h $(srcdir)/../system.h \\\n+decl2.o : decl2.c $(CXX_TREE_H) $(srcdir)/../flags.h \\\n+  lex.h decl.h $(EXPR_H) $(srcdir)/../output.h $(srcdir)/../except.h \\\n   $(srcdir)/../toplev.h $(srcdir)/../dwarf2out.h $(srcdir)/../dwarfout.h \\\n-  $(srcdir)/../../include/splay-tree.h $(srcdir)/../ggc.h $(RTL_H)\n-typeck2.o : typeck2.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../output.h\n-typeck.o : typeck.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n-  $(EXPR_H) $(srcdir)/../system.h $(srcdir)/../toplev.h \n-class.o : class.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n-  $(srcdir)/../../include/splay-tree.h $(RTL_H)\n-call.o : call.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h $(RTL_H)\n-friend.o : friend.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h\n-init.o : init.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n-  $(EXPR_H) $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../ggc.h\n-method.o : method.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\\n+  $(srcdir)/../ggc.h $(RTL_H)\n+typeck2.o : typeck2.c $(CXX_TREE_H) $(srcdir)/../flags.h \\\n+  $(srcdir)/../toplev.h $(srcdir)/../output.h\n+typeck.o : typeck.c $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n+  $(EXPR_H) $(srcdir)/../toplev.h \n+class.o : class.c $(CXX_TREE_H) $(srcdir)/../flags.h \\\n+  $(srcdir)/../toplev.h $(RTL_H)\n+call.o : call.c $(CXX_TREE_H) $(srcdir)/../flags.h \\\n+  $(srcdir)/../toplev.h $(RTL_H)\n+friend.o : friend.c $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n+  $(srcdir)/../toplev.h\n+init.o : init.c $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n+  $(EXPR_H) $(srcdir)/../toplev.h $(srcdir)/../ggc.h \\\n+  $(srcdir)/../except.h\n+method.o : method.c $(CXX_TREE_H) \\\n   $(srcdir)/../toplev.h $(srcdir)/../ggc.h $(RTL_H)\n-cvt.o : cvt.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h decl.h \\\n+cvt.o : cvt.c $(CXX_TREE_H) decl.h \\\n   $(srcdir)/../flags.h $(srcdir)/../toplev.h $(srcdir)/../convert.h\n-search.o : search.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../stack.h \\\n-  $(srcdir)/../flags.h $(srcdir)/../system.h $(srcdir)/../toplev.h $(RTL_H)\n-tree.o : tree.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../ggc.h $(RTL_H) \\\n-  $(srcdir)/../../include/splay-tree.h\n-ptree.o : ptree.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h\n-rtti.o : rtti.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h\n-except.o : except.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n-  $(srcdir)/../except.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n-expr.o : expr.c $(CONFIG_H) $(CXX_TREE_H) $(RTL_H) $(srcdir)/../flags.h \\\n-  $(EXPR_H) $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../except.h\n-xref.o : xref.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../input.h \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h\n-pt.o : pt.c $(CONFIG_H) $(CXX_TREE_H) decl.h $(PARSE_H) lex.h \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../ggc.h $(RTL_H)\n-error.o : error.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\\n+search.o : search.c $(CXX_TREE_H) $(srcdir)/../stack.h \\\n+  $(srcdir)/../flags.h $(srcdir)/../toplev.h $(RTL_H)\n+tree.o : tree.c $(CXX_TREE_H) $(srcdir)/../flags.h \\\n+  $(srcdir)/../toplev.h $(srcdir)/../ggc.h $(RTL_H) \\\n+  ../insn-config.h $(srcdir)/../integrate.h\n+ptree.o : ptree.c $(CXX_TREE_H) $(srcdir)/../system.h\n+rtti.o : rtti.c $(CXX_TREE_H) $(srcdir)/../flags.h \\\n+  $(srcdir)/../toplev.h\n+except.o : except.c $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n+  $(srcdir)/../except.h $(srcdir)/../toplev.h\n+expr.o : expr.c $(CXX_TREE_H) $(RTL_H) $(srcdir)/../flags.h \\\n+  $(EXPR_H) $(srcdir)/../toplev.h $(srcdir)/../except.h\n+xref.o : xref.c $(CXX_TREE_H) $(srcdir)/../input.h \\\n+  $(srcdir)/../toplev.h\n+pt.o : pt.c $(CXX_TREE_H) decl.h $(PARSE_H) lex.h \\\n+  $(srcdir)/../toplev.h $(srcdir)/../ggc.h $(RTL_H) \\\n+  $(srcdir)/../except.h\n+error.o : error.c $(CXX_TREE_H) \\\n   $(srcdir)/../toplev.h\n-errfn.o : errfn.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\\n+errfn.o : errfn.c $(CXX_TREE_H) \\\n   $(srcdir)/../toplev.h\n-repo.o : repo.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\\n+repo.o : repo.c $(CXX_TREE_H) \\\n   $(srcdir)/../toplev.h $(srcdir)/../ggc.h\n-semantics.o: semantics.c $(CONFIG_H) $(CXX_TREE_H) lex.h \\\n-  $(srcdir)/../except.h $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n+semantics.o: semantics.c $(CXX_TREE_H) lex.h \\\n+  $(srcdir)/../except.h $(srcdir)/../toplev.h \\\n   $(srcdir)/../flags.h $(srcdir)/../ggc.h\n-dump.o: dump.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h\n+dump.o: dump.c $(CXX_TREE_H)\n+optimize.o: optimize.c $(CXX_TREE_H) \\\n+  $(srcdir)/../rtl.h $(srcdir)/../integrate.h ../insn-config.h\n \n #\f\n # These exist for maintenance purposes."}, {"sha": "a916123ed9b1df5719d13610852335d0e1bbd489", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -30,7 +30,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n-#include \"splay-tree.h\"\n #include \"ggc.h\"\n #include \"lex.h\"\n "}, {"sha": "6ccc8745ed944b822f11653115b778a7f87cd3ae", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -237,9 +237,11 @@ DEFTREECODE (ASM_STMT, \"asm_stmt\", 'e', 5)\n    run if an exception is thrown before the end of the enclosing\n    function.  */\n DEFTREECODE (SUBOBJECT, \"subobject\", 'e', 1)\n-/* A CTOR_COMPLETE statements marks the end of the main body of the\n-   constructor, not including any function try blocks.  */\n-DEFTREECODE (CTOR_COMPLETE, \"ctor_complete\", 'e', 0)\n+/* An CTOR_STMT marks the beginning (if CTOR_BEGIN_P holds) or end of\n+   a contstructor (if CTOR_END_P) holds.  At the end of a constructor,\n+   the cleanups associated with any SUBOBJECT_CLEANUPS need no longer\n+   be run.  */\n+DEFTREECODE (CTOR_STMT, \"ctor_stmt\", 'e', 0)\n /* A CLEANUP_STMT marks the point at which a declaration is fully\n    constructed.  If, after this point, the CLEANUP_DECL goes out of\n    scope, the CLEANUP_EXPR must be run.  */"}, {"sha": "3b1f402d525587988b4e6206c39f93807e2dea84", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -21,6 +21,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"c-common.h\"\n #include \"function.h\"\n+#include \"splay-tree.h\"\n #include \"varray.h\"\n \n #ifndef _CP_TREE_H\n@@ -40,6 +41,7 @@ Boston, MA 02111-1307, USA.  */\n       CLEANUP_P (in TRY_BLOCK)\n       AGGR_INIT_VIA_CTOR_P (in AGGR_INIT_EXPR)\n       SCOPE_BEGIN_P (in SCOPE_STMT)\n+      CTOR_BEGIN_P (in CTOR_STMT)\n    1: IDENTIFIER_VIRTUAL_P.\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -2121,6 +2123,10 @@ extern int flag_new_for_scope;\n #define SET_DECL_C_BIT_FIELD(NODE) \\\n   (DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))->decl_flags.bitfield = 1)\n \n+/* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */\n+#define DECL_UNINLINABLE(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.bitfield)\n+\n #define INTEGRAL_CODE_P(CODE) \\\n   (CODE == INTEGER_TYPE || CODE == ENUMERAL_TYPE || CODE == BOOLEAN_TYPE)\n \n@@ -2691,6 +2697,14 @@ extern int flag_new_for_scope;\n #define SCOPE_END_P(NODE) \\\n   (!SCOPE_BEGIN_P (SCOPE_STMT_CHECK (NODE)))\n \n+/* Nonzero if this CTOR_STMT is for the beginning of a constructor.  */\n+#define CTOR_BEGIN_P(NODE) \\\n+  (TREE_LANG_FLAG_0 (CTOR_STMT_CHECK (NODE)))\n+\n+/* Nonzero if this CTOR_STMT is for the end of a constructor.  */\n+#define CTOR_END_P(NODE) \\\n+  (!CTOR_BEGIN_P (NODE))\n+\n /* Nonzero for a SCOPE_STMT if there were no variables in this scope.  */\n #define SCOPE_NULLIFIED_P(NODE) \\\n   (TREE_LANG_FLAG_3 (SCOPE_STMT_CHECK (NODE)))\n@@ -3107,6 +3121,11 @@ extern int flag_new_abi;\n \n extern int flag_honor_std;\n \n+/* Nonzero if we should expand functions calls inline at the tree\n+   level, rather than at the RTL level.  */\n+\n+extern int flag_inline_trees;\n+\n /* Nonzero if we're done parsing and into end-of-file activities.  */\n \n extern int at_eof;\n@@ -3532,6 +3551,8 @@ extern tree maybe_push_decl                     PROTO((tree));\n extern void emit_local_var                      PROTO((tree));\n extern tree build_target_expr_with_type         PROTO((tree, tree));\n extern void make_rtl_for_local_static           PROTO((tree));\n+extern int local_variable_p                     PROTO((tree));\n+extern int nonstatic_local_decl_p               PROTO((tree));\n \n /* in decl2.c */\n extern void init_decl2\t\t\t\tPROTO((void));\n@@ -3744,6 +3765,9 @@ extern void emit_thunk\t\t\t\tPROTO((tree));\n extern void synthesize_method\t\t\tPROTO((tree));\n extern tree get_id_2\t\t\t\tPROTO((const char *, tree));\n \n+/* In optimize.c */\n+extern void optimize_function                   PROTO((tree));\n+\n /* in pt.c */\n extern void init_pt                             PROTO ((void));\n extern void check_template_shadow\t\tPROTO ((tree));\n@@ -3960,7 +3984,6 @@ extern tree arbitrate_lookup\t\t\tPROTO((tree, tree, tree));\n \n /* in tree.c */\n extern void init_tree\t\t\t        PROTO((void));\n-extern void cplus_unsave_expr_now               PROTO((tree));\n extern int pod_type_p\t\t\t\tPROTO((tree));\n extern void unshare_base_binfos\t\t\tPROTO((tree));\n extern int member_p\t\t\t\tPROTO((tree));\n@@ -4028,9 +4051,11 @@ extern tree maybe_dummy_object\t\t\tPROTO((tree, tree *));\n extern int is_dummy_object\t\t\tPROTO((tree));\n typedef tree (*walk_tree_fn)                    PROTO((tree *, int *, void *));\n extern tree walk_tree                           PROTO((tree *, walk_tree_fn, void *));\n+extern tree copy_tree_r                         PROTO((tree *, int *, void *));\n extern int cp_valid_lang_attribute\t\tPROTO((tree, tree, tree, tree));\n extern tree make_ptrmem_cst                     PROTO((tree, tree));\n extern tree cp_build_qualified_type_real        PROTO((tree, int, int));\n+extern void remap_save_expr                     PROTO((tree *, splay_tree, tree));\n #define cp_build_qualified_type(TYPE, QUALS) \\\n   cp_build_qualified_type_real ((TYPE), (QUALS), /*complain=*/1)\n "}, {"sha": "0edcc258c6bb6ca242ebee5f407a82a99aa4f48c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 51, "deletions": 43, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -141,7 +141,7 @@ static boolean typename_compare PROTO((hash_table_key, hash_table_key));\n static void push_binding PROTO((tree, tree, struct binding_level*));\n static int add_binding PROTO((tree, tree));\n static void pop_binding PROTO((tree, tree));\n-static tree local_variable_p PROTO((tree *, int *, void *));\n+static tree local_variable_p_walkfn PROTO((tree *, int *, void *));\n static tree find_binding PROTO((tree, tree));\n static tree select_decl PROTO((tree, int));\n static int lookup_flags PROTO((int, int));\n@@ -7362,26 +7362,10 @@ make_rtl_for_local_static (decl)\n   tree type = TREE_TYPE (decl);\n   const char *asmspec = NULL;\n \n-  if (TREE_READONLY (decl)\n-      && DECL_INITIAL (decl) != NULL_TREE\n-      && DECL_INITIAL (decl) != error_mark_node\n-      && ! EMPTY_CONSTRUCTOR_P (DECL_INITIAL (decl))\n-      && ! TREE_SIDE_EFFECTS (decl)\n-      && ! TREE_PUBLIC (decl)\n-      && ! DECL_EXTERNAL (decl)\n-      && ! TYPE_NEEDS_DESTRUCTOR (type)\n-      && ! TREE_ADDRESSABLE (decl)\n-      && DECL_MODE (decl) != BLKmode)\n-    {\n-      /* As an optimization, we try to put register-sized static\n-\t constants in a register, rather than writing them out.  If we\n-\t take the address of the constant later, we'll make RTL for it\n-\t at that point.  */\n-      DECL_RTL (decl) = gen_reg_rtx (DECL_MODE (decl));\n-      store_expr (DECL_INITIAL (decl), DECL_RTL (decl), 0);\n-      TREE_ASM_WRITTEN (decl) = 1;\n-      return;\n-    }\n+  /* If we inlined this variable, we could see it's declaration\n+     again.  */\n+  if (DECL_RTL (decl))\n+    return;\n \n   if (DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl))\n     {\n@@ -7543,9 +7527,8 @@ emit_local_var (decl)\n {\n   /* Create RTL for this variable.  */\n   if (DECL_RTL (decl))\n-    /* Only a RESULT_DECL should have non-NULL RTL when\n-\t\t     arriving here.  All other local variables are\n-\t\t     assigned RTL in this function.  */\n+    /* Only a RESULT_DECL should have non-NULL RTL when arriving here.\n+       All other local variables are assigned RTL in this function.  */\n     my_friendly_assert (TREE_CODE (decl) == RESULT_DECL, \n \t\t\t19990828);\n   else\n@@ -11141,27 +11124,48 @@ require_complete_types_for_parms (parms)\n     }\n }\n \n-/* Returns *TP if *TP is a local variable (or parameter).  Returns\n-   NULL_TREE otherwise.  */\n+/* Returns non-zero if T is a local variable.  */\n \n-static tree\n-local_variable_p (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+int\n+local_variable_p (t)\n+     tree t;\n {\n-  tree t = *tp;\n-\n   if ((TREE_CODE (t) == VAR_DECL \n        /* A VAR_DECL with a context that is a _TYPE is a static data\n \t  member.  */\n        && !TYPE_P (CP_DECL_CONTEXT (t))\n        /* Any other non-local variable must be at namespace scope.  */\n-       && TREE_CODE (CP_DECL_CONTEXT (t)) != NAMESPACE_DECL)\n+       && !DECL_NAMESPACE_SCOPE_P (t))\n       || (TREE_CODE (t) == PARM_DECL))\n-    return t;\n+    return 1;\n \n-  return NULL_TREE;\n+  return 0;\n+}\n+\n+/* Returns non-zero if T is an automatic local variable or a label.\n+   (These are the declarations that need to be remapped when the code\n+   containing them is duplicated.)  */\n+\n+int\n+nonstatic_local_decl_p (t)\n+     tree t;\n+{\n+  return ((local_variable_p (t) && !TREE_STATIC (t))\n+\t  || TREE_CODE (t) == LABEL_DECL\n+\t  || TREE_CODE (t) == RESULT_DECL);\n+}\n+\n+/* Like local_variable_p, but suitable for use as a tree-walking\n+   function.  */\n+\n+static tree\n+local_variable_p_walkfn (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  return ((local_variable_p (*tp) && !DECL_ARTIFICIAL (*tp)) \n+\t  ? *tp : NULL_TREE);\n }\n \n /* Check that ARG, which is a default-argument expression for a\n@@ -11230,7 +11234,7 @@ check_default_argument (decl, arg)\n \n      The keyword `this' shall not be used in a default argument of a\n      member function.  */\n-  var = walk_tree (&arg, local_variable_p, NULL);\n+  var = walk_tree (&arg, local_variable_p_walkfn, NULL);\n   if (var)\n     {\n       cp_error (\"default argument `%E' uses local variable `%D'\",\n@@ -13067,9 +13071,15 @@ start_function (declspecs, declarator, attrs, flags)\n \n   if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl1))\n       && DECL_LANGUAGE (decl1) == lang_cplusplus)\n-    dtor_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+    {\n+      dtor_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+      DECL_CONTEXT (dtor_label) = current_function_decl;\n+    }\n   else if (DECL_CONSTRUCTOR_P (decl1))\n-    ctor_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+    {\n+      ctor_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+      DECL_CONTEXT (ctor_label) = current_function_decl;\n+    }\n \n   return 1;\n }\n@@ -13295,10 +13305,8 @@ finish_constructor_body ()\n   /* In check_return_expr we translate an empty return from a\n      constructor to a return of `this'.  */\n   finish_return_stmt (NULL_TREE);\n-\n-  /* Mark the end of the main constructor body.  */\n-  if (DECL_CONSTRUCTOR_P (current_function_decl))\n-    add_tree (build_min_nt (CTOR_COMPLETE));\n+  /* Mark the end of the constructor.  */\n+  add_tree (build_min_nt (CTOR_STMT));\n }\n \n /* At the end of every destructor we generate code to restore virtual"}, {"sha": "7759b0a0e3f44463c3ff721348ed1f3586ace64b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -42,7 +42,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"dwarf2out.h\"\n #include \"dwarfout.h\"\n-#include \"splay-tree.h\"\n #include \"ggc.h\"\n \n #if USE_CPPLIB\n@@ -444,6 +443,11 @@ int flag_new_abi;\n \n int flag_honor_std;\n \n+/* Nonzero if we should expand functions calls inline at the tree\n+   level, rather than at the RTL level.  */\n+\n+int flag_inline_trees = 0;\n+\n /* Maximum template instantiation depth. Must be at least 17 for ANSI\n    compliance. */\n "}, {"sha": "6e3fbcceab70e366a791a766cd4d89e6a360dbf4", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -23,7 +23,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"cp-tree.h\"\n-#include \"splay-tree.h\"\n \n /* Flags used with queue functions.  */\n #define DUMP_NONE     0"}, {"sha": "62cae27bf59019a5d7680df8e5dddec316ec6191", "filename": "gcc/cp/except.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -564,7 +564,7 @@ expand_end_catch_block (blocks)\n \n   /* Cleanup the EH parameter.  */\n   finish_compound_stmt (/*has_no_scope=*/0, compound_stmt_2);\n-    /* Cleanup the EH object.  */\n+  /* Cleanup the EH object.  */\n   finish_compound_stmt (/*has_no_scope=*/0, compound_stmt_1);\n }\n \n@@ -615,6 +615,7 @@ expand_end_eh_spec (raises, try_block)\n   decl = build_decl (VAR_DECL, NULL_TREE, tmp);\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_INITIAL (decl) = types;\n+  DECL_CONTEXT (decl) = current_function_decl;\n   cp_finish_decl (decl, types, NULL_TREE, 0);\n \n   decl = decay_conversion (decl);\n@@ -804,12 +805,10 @@ expand_throw (exp)\n \t  tree object, ptr;\n \n \t  /* OK, this is kind of wacky.  The WP says that we call\n-\t     terminate\n-\n-\t     when the exception handling mechanism, after completing\n-\t     evaluation of the expression to be thrown but before the\n-\t     exception is caught (_except.throw_), calls a user function\n-\t     that exits via an uncaught exception.\n+\t     terminate when the exception handling mechanism, after\n+\t     completing evaluation of the expression to be thrown but\n+\t     before the exception is caught (_except.throw_), calls a\n+\t     user function that exits via an uncaught exception.\n \n \t     So we have to protect the actual initialization of the\n \t     exception object with terminate(), but evaluate the expression"}, {"sha": "1361b9686ee6ea73050b0d8e4b4d5f39e3a44e41", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -2470,7 +2470,7 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, use_global_delete)\n   /* The below is short by BI_header_size */\n   virtual_size = fold (size_binop (MULT_EXPR, size_exp, maxindex));\n \n-  tbase = build_decl (VAR_DECL, NULL_TREE, ptype);\n+  tbase = create_temporary_var (ptype);\n   tbase_init = build_modify_expr (tbase, NOP_EXPR,\n \t\t\t\t  fold (build (PLUS_EXPR, ptype,\n \t\t\t\t\t       base,"}, {"sha": "b2e6a49727093a17073f2001b8cc1f90d864d26c", "filename": "gcc/cp/ir.texi", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fir.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fir.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fir.texi?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -1274,9 +1274,11 @@ following the @code{TREE_CHAIN} link from one substatement to the next.\n Used to represent a @code{continue} statement.  There are no additional\n fields.\n \n-@item CTOR_COMPLETE\n+@item CTOR_STMT\n \n-Used to mark the end of the main body of a constructor.\n+Used to mark the beginning (if @code{CTOR_BEGIN_P} holds) or end (if\n+@code{CTOR_END_P} holds of the main body of a constructor.  See also\n+@code{SUBOBJECT} for more information on how to use these nodes.\n \n @item DECL_STMT\n \n@@ -1387,9 +1389,9 @@ equalit) to @code{CATCH_ALL_TYPE} if this handler is for all types.\n \n In a constructor, these nodes are used to mark the point at which a\n subobject of @code{this} is fully constructed.  If, after this point, an\n-exception is thrown before a CTOR_COMPLETE statement is encountered, the\n-@code{SUBOBJECT_CLEANUP} must be executed.  The cleanups must be\n-executed in the reverse order in which they appear.\n+exception is thrown before a @code{CTOR_STMT} with @code{CTOR_END_P} set\n+is encountered, the @code{SUBOBJECT_CLEANUP} must be executed.  The\n+cleanups must be executed in the reverse order in which they appear.\n \n @item SWITCH_STMT\n "}, {"sha": "ae2783f4c1b6103568334d911486963af1aadecb", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -405,7 +405,7 @@ my_get_run_time ()\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n-char cplus_tree_code_type[] = {\n+static char cplus_tree_code_type[] = {\n   'x',\n #include \"cp-tree.def\"\n };\n@@ -417,7 +417,7 @@ char cplus_tree_code_type[] = {\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) LENGTH,\n \n-int cplus_tree_code_length[] = {\n+static int cplus_tree_code_length[] = {\n   0,\n #include \"cp-tree.def\"\n };\n@@ -427,7 +427,7 @@ int cplus_tree_code_length[] = {\n    Used for printing out the tree and error messages.  */\n #define DEFTREECODE(SYM, NAME, TYPE, LEN) NAME,\n \n-const char *cplus_tree_code_name[] = {\n+static const char *cplus_tree_code_name[] = {\n   \"@@dummy\",\n #include \"cp-tree.def\"\n };"}, {"sha": "d81f5448f1f1a91a04caa8ef4fc8038f666f7553", "filename": "gcc/cp/optimize.c", "status": "added", "additions": 497, "deletions": 0, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -0,0 +1,497 @@\n+/* Perform optimizations on tree structure.\n+\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Written by Mark Michell (mark@codesourcery.com).\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+   \n+   GNU CC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"cp-tree.h\"\n+#include \"rtl.h\"\n+#include \"insn-config.h\"\n+#include \"integrate.h\"\n+#include \"varray.h\"\n+\n+/* To Do:\n+\n+   o Provide debugging information for inlined function bodies.  \n+\n+   o In order to make inlining-on-trees work, we pessimized\n+     function-local static constants.  In particular, they are now\n+     always output, even when not addressed.  Fix this by treating\n+     function-local static constants just like global static\n+     constants; the back-end already knows not to output them if they\n+     are not needed.\n+     \n+   o Provide heuristics to clamp inlining of recursive template\n+     calls?  */\n+   \n+/* Data required for function inlining.  */\n+\n+typedef struct inline_data\n+{\n+  /* A stack of the functions we are inlining.  For example, if we are\n+     compiling `f', which calls `g', which calls `h', and we are\n+     inlining the body of `h', the stack will contain, `h', followed\n+     by `g', followed by `f'.  */\n+  varray_type fns;\n+  /* The top of the FNS stack.  */\n+  size_t fns_top;\n+  /* The label to jump to when a return statement is encountered.  */\n+  tree ret_label;\n+  /* The map from local declarations in the inlined function to\n+     equivalents in the function into which it is being inlined.  */\n+  splay_tree decl_map;\n+} inline_data;\n+\n+/* Prototypes.  */\n+\n+static tree initialize_inlined_parameters PROTO((inline_data *, tree));\n+static tree declare_return_variable PROTO((inline_data *, tree *));\n+static tree copy_body_r PROTO((tree *, int *, void *));\n+static tree copy_body PROTO((inline_data *));\n+static tree expand_call_inline PROTO((tree *, int *, void *));\n+static void expand_calls_inline PROTO((tree *, inline_data *));\n+static int inlinable_function_p PROTO((tree, inline_data *));\n+\n+/* Called from copy_body via walk_tree.  DATA is really an\n+   `inline_data *'.  */\n+\n+static tree\n+copy_body_r (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees;\n+     void *data;\n+{\n+  inline_data* id;\n+  tree fn;\n+\n+  /* Set up.  */\n+  id = (inline_data *) data;\n+  fn = VARRAY_TREE (id->fns, id->fns_top - 1);\n+\n+  /* All automatic variables should have a DECL_CONTEXT indicating\n+     what function they come from.  */\n+  if ((TREE_CODE (*tp) == VAR_DECL || TREE_CODE (*tp) == LABEL_DECL)\n+      && DECL_NAMESPACE_SCOPE_P (*tp))\n+    my_friendly_assert (DECL_EXTERNAL (*tp) || TREE_STATIC (*tp),\n+\t\t\t19991113);\n+\n+  /* If this is a RETURN_STMT, change it into an EXPR_STMT and a\n+     GOTO_STMT with the RET_LABEL as its target.  */\n+  if (TREE_CODE (*tp) == RETURN_STMT)\n+    {\n+      tree return_stmt = *tp;\n+      tree goto_stmt;\n+\n+      /* Build the GOTO_STMT.  */\n+      goto_stmt = build_min_nt (GOTO_STMT, id->ret_label);\n+      TREE_CHAIN (goto_stmt) = TREE_CHAIN (return_stmt);\n+\n+      /* If we're returning something, just turn that into an\n+\t assignment into the equivalent of the original \n+\t RESULT_DECL.  */\n+      if (RETURN_EXPR (return_stmt))\n+\t{\n+\t  *tp = build_min_nt (EXPR_STMT, \n+\t\t\t      RETURN_EXPR (return_stmt));\n+\t  /* And then jump to the end of the function.  */\n+\t  TREE_CHAIN (*tp) = goto_stmt;\n+\t}\n+      /* If we're not returning anything just do the jump.  */\n+      else\n+\t*tp = goto_stmt;\n+    }\n+  /* Local variables and labels need to be replaced by equivalent\n+     variables.  We don't want to copy static variables; there's only\n+     one of those, no matter how many times we inline the containing\n+     function.  */\n+  else if (nonstatic_local_decl_p (*tp) && DECL_CONTEXT (*tp) == fn)\n+    {\n+      splay_tree_node n;\n+\n+      /* Look up the declaration.  */\n+      n = splay_tree_lookup (id->decl_map, (splay_tree_key) *tp);\n+\n+      /* If we didn't already have an equivalent for this declaration,\n+\t create one now.  */\n+      if (!n)\n+\t{\n+\t  tree t;\n+\n+\t  /* Make a copy of the variable or label.  */\n+\t  t = copy_decl_for_inlining (*tp, fn, \n+\t\t\t\t      VARRAY_TREE (id->fns, 0));\n+\t  /* Remember it, so that if we encounter this local entity\n+\t     again we can reuse this copy.  */\n+\t  n = splay_tree_insert (id->decl_map, \n+\t\t\t\t (splay_tree_key) *tp, \n+\t\t\t\t (splay_tree_value) t);\n+\t}\n+\n+      /* Replace this variable with the copy.  */\n+      *tp = (tree) n->value;\n+    }\n+  else if (TREE_CODE (*tp) == SAVE_EXPR)\n+    remap_save_expr (tp, id->decl_map, VARRAY_TREE (id->fns, 0));\n+  else if (TREE_CODE (*tp) == UNSAVE_EXPR)\n+    my_friendly_abort (19991113);\n+  /* Otherwise, just copy the node.  Note that copy_tree_r already\n+     knows not to copy VAR_DECLs, etc., so this is safe.  */\n+  else\n+    {\n+      copy_tree_r (tp, walk_subtrees, NULL);\n+\n+      /* The copied TARGET_EXPR has never been expanded, even if the\n+\t original node was expanded already.  */\n+      if (TREE_CODE (*tp) == TARGET_EXPR && TREE_OPERAND (*tp, 3))\n+\tTREE_OPERAND (*tp, 1) = TREE_OPERAND (*tp, 3);\n+      /* Similarly, if we're copying a CALL_EXPR, the RTL for the\n+\t result is no longer valid.  */\n+      else if (TREE_CODE (*tp) == CALL_EXPR)\n+\tCALL_EXPR_RTL (*tp) = NULL_RTX;\n+    }\n+\n+  /* Keep iterating.  */\n+  return NULL_TREE;\n+}\n+\n+/* Make a copy of the body of FN so that it can be inserted inline in\n+   another function.  */\n+\n+static tree\n+copy_body (id)\n+     inline_data *id;\n+{\n+  tree body;\n+\n+  body = DECL_SAVED_TREE (VARRAY_TREE (id->fns, id->fns_top - 1));\n+  walk_tree (&body, copy_body_r, id);\n+\n+  return body;\n+}\n+\n+/* Generate code to initialize the parameters of the function at the\n+   top of the stack in ID from the ARGS (presented as a TREE_LIST).  */\n+\n+static tree\n+initialize_inlined_parameters (id, args)\n+     inline_data *id;\n+     tree args;\n+{\n+  tree fn;\n+  tree init_stmts;\n+  tree parms;\n+  tree a;\n+  tree p;\n+\n+  /* Figure out what the parameters are.  */\n+  fn = VARRAY_TREE (id->fns, id->fns_top - 1);\n+  parms = DECL_ARGUMENTS (fn);\n+\n+  /* Start with no initializations whatsoever.  */\n+  init_stmts = NULL_TREE;\n+\n+  /* Loop through the parameter declarations, replacing each with an\n+     equivalent VAR_DECL, appropriately initialized.  */\n+  for (p = parms, a = args; p; a = TREE_CHAIN (a), p = TREE_CHAIN (p))\n+    {\n+      tree init_stmt;\n+      tree var;\n+\n+      /* Make an equivalent VAR_DECL.  */\n+      var = copy_decl_for_inlining (p, fn, VARRAY_TREE (id->fns, 0));\n+      /* Register the VAR_DECL as the equivalent for the PARM_DECL;\n+\t that way, when the PARM_DECL is encountered, it will be\n+\t automatically replaced by the VAR_DECL.  */\n+      splay_tree_insert (id->decl_map, \n+\t\t\t (splay_tree_key) p,\n+\t\t\t (splay_tree_value) var);\n+      /* Initialize this VAR_DECL from the equivalent argument.  If\n+\t the argument is an object, created via a constructor or copy,\n+\t this will not result in an extra copy: the TARGET_EXPR\n+\t representing the argument will be bound to VAR, and the\n+\t object will be constructed in VAR.  */\n+      init_stmt = build_min_nt (EXPR_STMT,\n+\t\t\t\tbuild (INIT_EXPR, TREE_TYPE (p),\n+\t\t\t\t       var, TREE_VALUE (a)));\n+      /* Declare this new variable.  Note that we do this *after* the\n+\t initialization because we are going to reverse all the\n+\t initialization statements below.  */\n+      TREE_CHAIN (init_stmt) = build_min_nt (DECL_STMT, var);\n+      /* Add this initialization to the list.  */\n+      TREE_CHAIN (TREE_CHAIN (init_stmt)) = init_stmts;\n+      init_stmts = init_stmt;\n+    }\n+\n+  /* The initialization statements have been built up in reverse\n+     order.  Straighten them out now.  */\n+  return nreverse (init_stmts);\n+}\n+\n+/* Declare a return variable to replace the RESULT_DECL for the\n+   function we are calling.  An appropriate DECL_STMT is returned.\n+   The USE_STMT is filled in to contain a use of the declaration to\n+   indicate the return value of the function.  */\n+\n+static tree\n+declare_return_variable (id, use_stmt)\n+     struct inline_data *id;\n+     tree *use_stmt;\n+{\n+  tree fn = VARRAY_TREE (id->fns, id->fns_top - 1);\n+  tree result = DECL_RESULT (fn);\n+  tree var;\n+\n+  /* We don't need to do anything for functions that don't return\n+     anything.  */\n+  if (!result || same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (result)), \n+\t\t\t      void_type_node))\n+    {\n+      *use_stmt = NULL_TREE;\n+      return NULL_TREE;\n+    }\n+\n+  /* Make an appropriate copy.  */\n+  var = copy_decl_for_inlining (result, fn, VARRAY_TREE (id->fns, 0));\n+  /* Register the VAR_DECL as the equivalent for the RESULT_DECL; that\n+     way, when the RESULT_DECL is encountered, it will be\n+     automatically replaced by the VAR_DECL.  */\n+  splay_tree_insert (id->decl_map, \n+\t\t     (splay_tree_key) result,\n+\t\t     (splay_tree_value) var);\n+\n+  /* Build the USE_STMT.  */\n+  *use_stmt = build_min_nt (EXPR_STMT, var);\n+\n+  /* Build the declaration statement.  */\n+  return build_min_nt (DECL_STMT, var);\n+}\n+\n+/* Returns non-zero if FN is a function that can be inlined.  */\n+\n+static int\n+inlinable_function_p (fn, id)\n+     tree fn;\n+     inline_data *id;\n+{\n+  int inlinable;\n+\n+  /* If we've already decided this function shouldn't be inlined,\n+     there's no need to check again.  */\n+  if (DECL_UNINLINABLE (fn))\n+    return 0;\n+\n+  /* Assume it is not inlinable.  */\n+  inlinable = 0;\n+\n+  /* If the function was not declared `inline', then we don't inline\n+     it.  */\n+  if (!DECL_INLINE (fn))\n+    ;\n+  /* If we don't have the function body available, we can't inline\n+     it.  */\n+  else if (!DECL_SAVED_TREE (fn))\n+    ;\n+  /* We can't inline varargs functions.  */\n+  else if (varargs_function_p (fn))\n+    ;\n+  /* All is well.  We can inline this function.  Traditionally, GCC\n+     has refused to inline functions using setjmp or alloca, or\n+     functions whose values are returned in a PARALLEL, and a few\n+     other such obscure conditions.  We are not equally constrained at\n+     the tree level.  */\n+  else\n+    inlinable = 1;\n+\n+  /* Squirrel away the result so that we don't have to check again.  */\n+  DECL_UNINLINABLE (fn) = !inlinable;\n+\n+  /* Don't do recursive inlining, either.  We don't record this in\n+     DECL_UNLINABLE; we may be able to inline this function later.  */\n+  if (inlinable)\n+    {\n+      size_t i;\n+\n+      for (i = 0; i < id->fns_top; ++i)\n+\tif (VARRAY_TREE (id->fns, i) == fn)\n+\t  inlinable = 0;\n+    }\n+\n+  /* We can inline a template instantiation only if its fully\n+     instantiated.  */\n+  if (inlinable\n+      && DECL_TEMPLATE_INFO (fn) \n+      && TI_PENDING_TEMPLATE_FLAG (DECL_TEMPLATE_INFO (fn)))\n+    {\n+      fn = instantiate_decl (fn);\n+      inlinable = !TI_PENDING_TEMPLATE_FLAG (DECL_TEMPLATE_INFO (fn));\n+    }\n+\n+  /* Return the result.  */\n+  return inlinable;\n+}\n+\n+/* If *TP is CALL_EXPR, replace it with its inline expansion.  */\n+\n+static tree\n+expand_call_inline (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees;\n+     void *data;\n+{\n+  inline_data *id;\n+  tree t;\n+  tree expr;\n+  tree chain;\n+  tree fn;\n+  tree use_stmt;\n+  splay_tree st;\n+\n+  /* We're only interested in CALL_EXPRs.  */\n+  t = *tp;\n+  if (TREE_CODE (t) != CALL_EXPR)\n+    return NULL_TREE;\n+\n+  /* First, see if we can figure out what function is being called.\n+     If we cannot, then there is no hope of inlining the function.  */\n+  fn = get_callee_fndecl (t);\n+  if (!fn)\n+    return NULL_TREE;\n+\n+  /* Don't try to inline functions that are not well-suited to\n+     inlining.  */\n+  id = (inline_data *) data;\n+  if (!inlinable_function_p (fn, id))\n+    return NULL_TREE;\n+\n+  /* Return statements in the function body will be replaced by jumps\n+     to the RET_LABEL.  */\n+  id->ret_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+  DECL_CONTEXT (id->ret_label) = VARRAY_TREE (id->fns, 0);\n+\n+  /* Build a statement-expression containing code to initialize the\n+     arguments, the actual inline expansion of the body, and a label\n+     for the return statements within the function to jump to.  The\n+     type of the statement expression is the return type of the\n+     function call.  */\n+  expr = build_min (STMT_EXPR, TREE_TYPE (TREE_TYPE (fn)), NULL_TREE);\n+\n+  /* Record the function we are about to inline so that we can avoid\n+     recursing into it.  */\n+  if (id->fns_top > id->fns->num_elements)\n+    VARRAY_GROW (id->fns, 2 * id->fns->num_elements);\n+  VARRAY_TREE (id->fns, id->fns_top++) = fn;\n+\n+  /* Local declarations will be replaced by their equivalents in this\n+     map.  */\n+  st = id->decl_map;\n+  id->decl_map = splay_tree_new (splay_tree_compare_pointers,\n+\t\t\t\t NULL, NULL);\n+\n+  /* Initialize the parameters.  */\n+  STMT_EXPR_STMT (expr) \n+    = initialize_inlined_parameters (id, TREE_OPERAND (t, 1));\n+\n+  /* Declare the return variable for the function.  */\n+  STMT_EXPR_STMT (expr)\n+    = chainon (STMT_EXPR_STMT (expr), \n+\t       declare_return_variable (id, &use_stmt));\n+  \n+  /* After we've initialized the parameters, we insert the body of the\n+     function itself.  */\n+  STMT_EXPR_STMT (expr)\n+    = chainon (STMT_EXPR_STMT (expr), copy_body (id));\n+\n+  /* Finally, mention the returned value so that the value of the\n+     statement-expression is the returned value of the function.  */\n+  STMT_EXPR_STMT (expr) = chainon (STMT_EXPR_STMT (expr), use_stmt);\n+\n+  /* Clean up.  */\n+  splay_tree_delete (id->decl_map);\n+  id->decl_map = st;\n+\n+  /* After the body of the function comes the RET_LABEL.  */\n+  STMT_EXPR_STMT (expr)\n+    = chainon (STMT_EXPR_STMT (expr), \n+\t       build_min_nt (LABEL_STMT, id->ret_label));\n+\n+  /* The new expression has side-effects if the old one did.  */\n+  TREE_SIDE_EFFECTS (expr) = TREE_SIDE_EFFECTS (t);\n+  /* If the value of the new expression is ignored, that's OK.  We\n+     don't warn about this for CALL_EXPRs, so we shouldn't warn about\n+     the equivalent inlined version either.  */\n+  TREE_USED (expr) = 1;\n+\n+  /* Replace the call by the inlined body.  */\n+  chain = TREE_CHAIN (*tp);\n+  *tp = expr;\n+  TREE_CHAIN (expr) = chain;\n+\n+  /* Recurse into the body of the just inlined function.  */\n+  expand_calls_inline (tp, id);\n+  --id->fns_top;\n+\n+  /* Don't walk into subtrees.  We've already handled them above.  */\n+  *walk_subtrees = 0;\n+\n+  /* Keep iterating.  */\n+  return NULL_TREE;\n+}\n+\n+/* Walk over the entire tree *TP, replacing CALL_EXPRs with inline\n+   expansions as appropriate.  */\n+\n+static void\n+expand_calls_inline (tp, id)\n+     tree *tp;\n+     inline_data *id;\n+{\n+  /* Search through *TP, replacing all calls to inline functions by\n+     appropriate equivalents.  */\n+  walk_tree (tp, expand_call_inline, id);\n+}\n+\n+/* Optimize the body of FN.  */\n+\n+void\n+optimize_function (fn)\n+     tree fn;\n+{\n+  /* Expand calls to inline functions.  */\n+  if (flag_inline_trees)\n+    {\n+      inline_data id;\n+\n+      /* Clear out ID.  */\n+      bzero (&id, sizeof (id));\n+\n+      /* Don't allow recursion into FN.  */\n+      VARRAY_TREE_INIT (id.fns, 32, \"fns\");\n+      VARRAY_TREE (id.fns, id.fns_top++) = fn;\n+\n+      /* Replace all calls to inline functions with the bodies of those\n+\t functions.  */\n+      expand_calls_inline (&DECL_SAVED_TREE (fn), &id);\n+\n+      /* Clean up.  */\n+      VARRAY_FREE (id.fns);\n+    }\n+}"}, {"sha": "2d70cb9044e6b1932894c045444000d7c50dae50", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 48, "deletions": 10, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -658,7 +658,16 @@ finish_goto_stmt (destination)\n     TREE_USED (destination) = 1;\n     \n   if (building_stmt_tree ())\n-    add_tree (build_min_nt (GOTO_STMT, destination));\n+    {\n+      if (TREE_CODE (destination) != LABEL_DECL)\n+\t/* We don't inline calls to functions with computed gotos.\n+\t   Those functions are typically up to some funny business,\n+\t   and may be depending on the labels being at particular\n+\t   addresses, or some such.  */\n+\tDECL_UNINLINABLE (current_function_decl) = 1;\n+\n+      add_tree (build_min_nt (GOTO_STMT, destination));\n+    }\n   else\n     {\n       emit_line_note (input_filename, lineno);\n@@ -1183,7 +1192,17 @@ setup_vtbl_ptr ()\n \t\t  (CTOR_INITIALIZER,\n \t\t   current_member_init_list, current_base_init_list));\n       else\n-\tfinish_expr_stmt (emit_base_init (current_class_type));\n+\t{\n+\t  tree ctor_stmt;\n+\n+\t  /* Mark the beginning of the constructor.  */\n+\t  ctor_stmt = build_min_nt (CTOR_STMT);\n+\t  CTOR_BEGIN_P (ctor_stmt) = 1;\n+\t  add_tree (ctor_stmt);\n+\t  \n+\t  /* And actually initialize the base-classes and members.  */\n+\t  finish_expr_stmt (emit_base_init (current_class_type));\n+\t}\n     }\n   else if (DECL_DESTRUCTOR_P (current_function_decl)\n \t   && !processing_template_decl)\n@@ -1592,6 +1611,9 @@ finish_label_address_expr (label)\n       TREE_USED (label) = 1;\n       result = build1 (ADDR_EXPR, ptr_type_node, label);\n       TREE_CONSTANT (result) = 1;\n+      /* This function cannot be inlined.  All jumps to the addressed\n+\t label should wind up at the same point.  */\n+      DECL_UNINLINABLE (current_function_decl) = 1;\n     }\n \n   return result;\n@@ -2268,11 +2290,6 @@ expand_stmt (t)\n \t  finish_expr_stmt (EXPR_STMT_EXPR (t));\n \t  break;\n \n-\tcase CTOR_COMPLETE:\n-\t  /* All subobjects have been fully constructed at this point.  */\n-\t  end_protect_partials ();\n-\t  break;\n-\n \tcase DECL_STMT:\n \t  {\n \t    tree decl;\n@@ -2309,6 +2326,16 @@ expand_stmt (t)\n \t  begin_catch_block (TREE_TYPE (t));\n \t  break;\n \n+\tcase CTOR_STMT:\n+\t  if (CTOR_BEGIN_P (t))\n+\t    begin_protect_partials ();\n+\t  else\n+\t    /* After this point, any exceptions will cause the\n+\t       destructor to be executed, so we no longer need to worry\n+\t       about destroying the various subobjects ourselves.  */\n+\t    end_protect_partials ();\n+\t  break;\n+\n \tcase FOR_STMT:\n \t  {\n \t    tree tmp;\n@@ -2508,6 +2535,9 @@ expand_body (fn)\n   if (flag_syntax_only)\n     return;\n \n+  /* Optimize the body of the function before expanding it.  */\n+  optimize_function (fn);\n+\n   /* Save the current file name and line number.  When we expand the\n      body of the function, we'll set LINENO and INPUT_FILENAME so that\n      error-mesages come out in the right places.  */\n@@ -2538,9 +2568,17 @@ expand_body (fn)\n   /* Generate code for the function.  */\n   finish_function (lineno, 0);\n \n-  /* We don't need the body any more.  Allow it to be garbage\n-     collected.  We can't do this if we're going to dump everything.  */\n-  if (!flag_dump_translation_unit)\n+  /* If possible, obliterate the body of the function so that it can\n+     be garbage collected.  */\n+  if (flag_dump_translation_unit)\n+    /* Keep the body; we're going to dump it.  */\n+    ;\n+  else if (DECL_INLINE (fn) && flag_inline_trees)\n+    /* We might need the body of this function so that we can expand\n+       it inline somewhere else.  */\n+    ;\n+  else\n+    /* We don't need the body; blow it away.  */\n     DECL_SAVED_TREE (fn) = NULL_TREE;\n \n   /* And restore the current source position.  */"}, {"sha": "93893b3a048f2fdbc958e5d987dc360a407589a1", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 191, "deletions": 29, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e8c075d018b365ce2a7ebba396ebcf3235c6d5/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=46e8c075d018b365ce2a7ebba396ebcf3235c6d5", "patch": "@@ -28,7 +28,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n-#include \"splay-tree.h\"\n+#include \"insn-config.h\"\n+#include \"integrate.h\"\n \n static tree bot_manip PROTO((tree *, int *, void *));\n static tree bot_replace PROTO((tree *, int *, void *));\n@@ -42,7 +43,10 @@ static cp_lvalue_kind lvalue_p_1 PROTO((tree, int));\n static tree no_linkage_helper PROTO((tree *, int *, void *));\n static tree build_srcloc PROTO((char *, int));\n static void mark_list_hash PROTO ((void *));\n-static tree copy_tree_r PROTO ((tree *, int *, void *));\n+static int statement_code_p PROTO((enum tree_code));\n+static tree mark_local_for_remap_r PROTO((tree *, int *, void *));\n+static tree cp_unsave_r PROTO ((tree *, int *, void *));\n+static void cp_unsave PROTO((tree *));\n static tree build_target_expr PROTO((tree, tree));\n \n #define CEIL(x,y) (((x) + (y) - 1) / (y))\n@@ -259,6 +263,7 @@ build_cplus_new (type, init)\n \n   slot = build (VAR_DECL, type);\n   DECL_ARTIFICIAL (slot) = 1;\n+  DECL_CONTEXT (slot) = current_function_decl;\n   layout_decl (slot, 0);\n \n   /* We split the CALL_EXPR into its function and its arguments here.\n@@ -1456,6 +1461,45 @@ is_aggr_type_2 (t1, t2)\n     return 0;\n   return IS_AGGR_TYPE (t1) && IS_AGGR_TYPE (t2);\n }\n+\n+/* Returns non-zero if CODE is the code for a statement.  */\n+\n+static int\n+statement_code_p (code)\n+     enum tree_code code;\n+{\n+  switch (code)\n+    {\n+    case EXPR_STMT:\n+    case COMPOUND_STMT:\n+    case DECL_STMT:\n+    case IF_STMT:\n+    case FOR_STMT:\n+    case WHILE_STMT:\n+    case DO_STMT:\n+    case RETURN_STMT:\n+    case BREAK_STMT:\n+    case CONTINUE_STMT:\n+    case SWITCH_STMT:\n+    case GOTO_STMT:\n+    case LABEL_STMT:\n+    case ASM_STMT:\n+    case SUBOBJECT:\n+    case CLEANUP_STMT:\n+    case START_CATCH_STMT:\n+    case CTOR_STMT:\n+    case SCOPE_STMT:\n+    case CTOR_INITIALIZER:\n+    case CASE_LABEL:\n+    case RETURN_INIT:\n+    case TRY_BLOCK:\n+    case HANDLER:\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n+}\n \f\n #define PRINT_RING_SIZE 4\n \n@@ -1594,14 +1638,20 @@ walk_tree (tp, func, data)\n \n   /* Handle commmon cases up front.  */\n   if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code))\n-      || TREE_CODE_CLASS (code) == 'r')\n+      || TREE_CODE_CLASS (code) == 'r'\n+      || TREE_CODE_CLASS (code) == 's')\n     {\n       int i;\n \n       /* Walk over all the sub-trees of this operand.  */\n       for (i = first_rtl_op (code) - 1; i >= 0; --i)\n \tWALK_SUBTREE (TREE_OPERAND (*tp, i));\n \n+      /* For statements, we also walk the chain so that we cover the\n+\t entire statement tree.  */\n+      if (statement_code_p (code))\n+\tWALK_SUBTREE (TREE_CHAIN (*tp));\n+\n       /* We didn't find what we were looking for.  */\n       return NULL_TREE;\n     }\n@@ -1706,7 +1756,7 @@ walk_tree (tp, func, data)\n       if (TYPE_PTRMEMFUNC_P (*tp))\n \tWALK_SUBTREE (TYPE_PTRMEMFUNC_FN_TYPE (*tp));\n       break;\n-      \n+\n     default:\n       my_friendly_abort (19990803);\n     }\n@@ -1755,10 +1805,10 @@ no_linkage_check (t)\n \n /* Passed to walk_tree.  Copies the node pointed to, if appropriate.  */\n \n-static tree\n+tree\n copy_tree_r (tp, walk_subtrees, data)\n      tree *tp;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     int *walk_subtrees;\n      void *data ATTRIBUTE_UNUSED;\n {\n   enum tree_code code = TREE_CODE (*tp);\n@@ -1767,6 +1817,7 @@ copy_tree_r (tp, walk_subtrees, data)\n   if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code))\n       || TREE_CODE_CLASS (code) == 'r'\n       || TREE_CODE_CLASS (code) == 'c'\n+      || TREE_CODE_CLASS (code) == 's'\n       || code == PARM_DECL\n       || code == TREE_LIST\n       || code == TREE_VEC\n@@ -1781,12 +1832,21 @@ copy_tree_r (tp, walk_subtrees, data)\n \n       /* Now, restore the chain, if appropriate.  That will cause\n \t walk_tree to walk into the chain as well.  */\n-      if (code == PARM_DECL || code == TREE_LIST || code == OVERLOAD)\n+      if (code == PARM_DECL || code == TREE_LIST || code == OVERLOAD\n+\t  || statement_code_p (code))\n \tTREE_CHAIN (*tp) = chain;\n+\n+      /* For now, we don't update BLOCKs when we make copies.  So, we\n+\t have to nullify all scope-statements.  */\n+      if (TREE_CODE (*tp) == SCOPE_STMT)\n+\tSCOPE_NULLIFIED_P (*tp) = 1;\n     }\n   else if (code == TEMPLATE_TEMPLATE_PARM)\n     /* These must be copied specially.  */\n     *tp = copy_template_template_parm (*tp);\n+  else if (TREE_CODE_CLASS (code) == 't')\n+    /* There's no need to copy types, or anything beneath them.  */\n+    *walk_subtrees = 0;\n \n   return NULL_TREE;\n }\n@@ -2605,41 +2665,143 @@ void\n init_tree ()\n {\n   make_lang_type_fn = cp_make_lang_type;\n-  lang_unsave_expr_now = cplus_unsave_expr_now;\n+  lang_unsave = cp_unsave;\n   ggc_add_root (list_hash_table, \n \t\tsizeof (list_hash_table) / sizeof (struct list_hash *),\n \t\tsizeof (struct list_hash *),\n \t\tmark_list_hash);\n }\n \n-/* The C++ version of unsave_expr_now.\n-   See gcc/tree.c:unsave_expr_now for comments. */\n+/* The SAVE_EXPR pointed to by TP is being copied.  If ST contains\n+   information indicating to what new SAVE_EXPR this one should be\n+   mapped, use that one.  Otherwise, create a new node and enter it in\n+   ST.  FN is the function into which the copy will be placed.  */\n \n void\n-cplus_unsave_expr_now (expr)\n-     tree expr;\n+remap_save_expr (tp, st, fn)\n+     tree *tp;\n+     splay_tree st;\n+     tree fn;\n {\n-  if (expr == NULL)\n-    return;\n+  splay_tree_node n;\n \n-  else if (TREE_CODE (expr) == AGGR_INIT_EXPR)\n+  /* See if we already encountered this SAVE_EXPR.  */\n+  n = splay_tree_lookup (st, (splay_tree_key) *tp);\n+      \n+  /* If we didn't already remap this SAVE_EXPR, do so now.  */\n+  if (!n)\n     {\n-      unsave_expr_now (TREE_OPERAND (expr,0));\n-      if (TREE_OPERAND (expr, 1)\n-\t  && TREE_CODE (TREE_OPERAND (expr, 1)) == TREE_LIST)\n-\t{\n-\t  tree exp = TREE_OPERAND (expr, 1);\n-\t  while (exp)\n-\t    {\n-\t      unsave_expr_now (TREE_VALUE (exp));\n-\t      exp = TREE_CHAIN (exp);\n-\t    }\n-\t}\n-      unsave_expr_now (TREE_OPERAND (expr,2));\n-      return;\n+      tree t = copy_node (*tp);\n+\n+      /* The SAVE_EXPR is now part of the function into which we\n+\t are inlining this body.  */\n+      SAVE_EXPR_CONTEXT (t) = fn;\n+      /* And we haven't evaluated it yet.  */\n+      SAVE_EXPR_RTL (t) = NULL_RTX;\n+      /* Remember this SAVE_EXPR.  */\n+      n = splay_tree_insert (st,\n+\t\t\t     (splay_tree_key) *tp,\n+\t\t\t     (splay_tree_value) t);\n+    }\n+\n+  /* Replace this SAVE_EXPR with the copy.  */\n+  *tp = (tree) n->value;\n+}\n+\n+/* Called via walk_tree.  If *TP points to a DECL_STMT for a local\n+   declaration, copies the declaration and enters it in the splay_tree\n+   pointed to by DATA (which is really a `splay_tree *').  */\n+\n+static tree\n+mark_local_for_remap_r (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     void *data;\n+{\n+  tree t = *tp;\n+  splay_tree st = (splay_tree) data;\n+\n+  if ((TREE_CODE (t) == DECL_STMT\n+       && nonstatic_local_decl_p (DECL_STMT_DECL (t)))\n+      || TREE_CODE (t) == LABEL_STMT)\n+    {\n+      tree decl;\n+      tree copy;\n+\n+      /* Figure out what's being declared.  */\n+      decl = (TREE_CODE (t) == DECL_STMT\n+\t      ? DECL_STMT_DECL (t) : LABEL_STMT_LABEL (t));\n+      \n+      /* Make a copy.  */\n+      copy = copy_decl_for_inlining (decl, \n+\t\t\t\t     DECL_CONTEXT (decl), \n+\t\t\t\t     DECL_CONTEXT (decl));\n+\n+      /* Remember the copy.  */\n+      splay_tree_insert (st,\n+\t\t\t (splay_tree_key) decl, \n+\t\t\t (splay_tree_value) copy);\n     }\n \n+  return NULL_TREE;\n+}\n+\n+/* Called via walk_tree when an expression is unsaved.  Using the\n+   splay_tree pointed to by ST (which is really a `splay_tree *'),\n+   remaps all local declarations to appropriate replacements.  */\n+\n+static tree\n+cp_unsave_r (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees;\n+     void *data;\n+{\n+  splay_tree st = (splay_tree) data;\n+  splay_tree_node n;\n+\n+  /* Only a local declaration (variable or label).  */\n+  if (nonstatic_local_decl_p (*tp))\n+    {\n+      /* Lookup the declaration.  */\n+      n = splay_tree_lookup (st, (splay_tree_key) *tp);\n+      \n+      /* If it's there, remap it.  */\n+      if (n)\n+\t*tp = (tree) n->value;\n+    }\n+  else if (TREE_CODE (*tp) == SAVE_EXPR)\n+    remap_save_expr (tp, st, current_function_decl);\n   else\n-    return;\n+    {\n+      copy_tree_r (tp, walk_subtrees, NULL);\n+\n+      /* Do whatever unsaving is required.  */\n+      unsave_expr_1 (*tp);\n+    }\n+\n+  /* Keep iterating.  */\n+  return NULL_TREE;\n }\n \n+/* Called by unsave_expr_now whenever an expression (*TP) needs to be\n+   unsaved.  */\n+\n+static void\n+cp_unsave (tp)\n+     tree *tp;\n+{\n+  splay_tree st;\n+\n+  /* Create a splay-tree to map old local variable declarations to new\n+     ones.  */\n+  st = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n+\n+  /* Walk the tree once figuring out what needs to be remapped.  */\n+  walk_tree (tp, mark_local_for_remap_r, st);\n+\n+  /* Walk the tree again, copying, remapping, and unsaving.  */\n+  walk_tree (tp, cp_unsave_r, st);\n+\n+  /* Clean up.  */\n+  splay_tree_delete (st);\n+}"}]}