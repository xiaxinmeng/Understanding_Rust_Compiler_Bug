{"sha": "ec4be2f46d4d30d77d8bff19c947073d7e865928", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM0YmUyZjQ2ZDRkMzBkNzdkOGJmZjE5Yzk0NzA3M2Q3ZTg2NTkyOA==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2010-05-28T00:03:19Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2010-05-28T00:03:19Z"}, "message": "Revert \"Fix PR c++/44188\"\n\ngcc/ChangeLog:\n\trevert fix for PR c++/44188\n\t* c-common.c (is_typedef_decl): Revert the moving of  this\n\tdefinition ...\n\t* tree.c (is_typedef_decl): ... here.\n\t(typdef_variant_p): Revert the moving of this  definition\n\there from gcc/cp/tree.c.\n\t* c-common.h (is_typedef_decl): Revert the moving of this\n\tdeclaration ...\n\t* tree.h (is_typedef_decl): ... here.\n\t(typedef_variant_p): Revert the moving of this  declaration here\n\tfrom gcc/cp/cp-tree.h\n\t* dwarf2out.c (is_naming_typedef_decl): Revert this new function.\n\t(gen_tagged_type_die): Revert the splitting out of ...\n\t(gen_type_die_with_usage): ... this function. Revert the anonymous\n\ttagged type handling.\n\t(gen_typedef_die): Revert emitting DW_TAG_typedef  for\n\ttypedefs naming anonymous tagged types.\n\ngcc/cp/ChangeLog:\n\tRevert fix of PR c++/44188\n\t* cp-tree.h (typedef_variant_p): Revert moving this declaration to\n\tgcc/tree.h.\n\t* tree.c (typedef_variant_p): Revert moving this definition to\n\tgcc/tree.c.\n\t* decl.c (grokdeclarator): Revert naming typedef handling.\n\ngcc/testsuite/ChangeLog:\n\tRevert fix for PR c++/44188\n\t* g++.dg/debug/dwarf2/typedef3.C: Revert new test.\n\nFrom-SVN: r159955", "tree": {"sha": "2007fe5e79ce827d21fa16b507e36304ce7c8d33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2007fe5e79ce827d21fa16b507e36304ce7c8d33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec4be2f46d4d30d77d8bff19c947073d7e865928", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec4be2f46d4d30d77d8bff19c947073d7e865928", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec4be2f46d4d30d77d8bff19c947073d7e865928", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec4be2f46d4d30d77d8bff19c947073d7e865928/comments", "author": null, "committer": null, "parents": [{"sha": "3fe7b63c521d8a12dba549aef8fb6b724aff635b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fe7b63c521d8a12dba549aef8fb6b724aff635b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fe7b63c521d8a12dba549aef8fb6b724aff635b"}], "stats": {"total": 288, "additions": 113, "deletions": 175}, "files": [{"sha": "608f0ad6c2ef22e325b91eb828b65ba0fd819bc0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec4be2f46d4d30d77d8bff19c947073d7e865928", "patch": "@@ -1,3 +1,24 @@\n+2010-05-28  Dodji Seketeli  <dodji@redhat.com>\n+\n+\trevert fix for PR c++/44188\n+\t* c-common.c (is_typedef_decl): Revert the moving of  this\n+\tdefinition ...\n+\t* tree.c (is_typedef_decl): ... here.\n+\t(typdef_variant_p): Revert the moving of this  definition\n+\there from gcc/cp/tree.c.\n+\t* c-common.h (is_typedef_decl): Revert the moving of this\n+\tdeclaration ...\n+\t* tree.h (is_typedef_decl): ... here.\n+\t(typedef_variant_p): Revert the moving of this  declaration here\n+\tfrom gcc/cp/cp-tree.h\n+\t* dwarf2out.c (is_naming_typedef_decl): Revert this new function.\n+\t(gen_tagged_type_die): Revert the splitting out of ...\n+\t(gen_type_die_with_usage): ... this function. Revert the anonymous\n+\ttagged type handling.\n+\t(gen_typedef_die): Revert emitting DW_TAG_typedef  for\n+\ttypedefs naming anonymous tagged types.\n+\n+\n 2010-05-28  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/rs6000-modes.def (PSImode): Delete."}, {"sha": "1fd11c50c64f7aa53f987b91e32e1f4c3f1d735b", "filename": "gcc/c-common.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=ec4be2f46d4d30d77d8bff19c947073d7e865928", "patch": "@@ -9387,6 +9387,15 @@ set_underlying_type (tree x)\n     }\n }\n \n+/* Returns true if X is a typedef decl.  */\n+\n+bool\n+is_typedef_decl (tree x)\n+{\n+  return (x && TREE_CODE (x) == TYPE_DECL\n+          && DECL_ORIGINAL_TYPE (x) != NULL_TREE);\n+}\n+\n /* Record the types used by the current global variable declaration\n    being parsed, so that we can decide later to emit their debug info.\n    Those types are in types_used_by_cur_var_decl, and we are going to"}, {"sha": "039edbee97441ff899a06af09aef85f820382ab3", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=ec4be2f46d4d30d77d8bff19c947073d7e865928", "patch": "@@ -1055,6 +1055,7 @@ extern void warn_for_sign_compare (location_t,\n \t\t\t\t   tree result_type,\n \t\t\t\t   enum tree_code resultcode);\n extern void set_underlying_type (tree x);\n+extern bool is_typedef_decl (tree x);\n extern VEC(tree,gc) *make_tree_vector (void);\n extern void release_tree_vector (VEC(tree,gc) *);\n extern VEC(tree,gc) *make_tree_vector_single (tree);"}, {"sha": "cfab057a38f91d945933a5c452a572100323d177", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ec4be2f46d4d30d77d8bff19c947073d7e865928", "patch": "@@ -1,3 +1,12 @@\n+2010-05-28  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tRevert fix of PR c++/44188\n+\t* cp-tree.h (typedef_variant_p): Revert moving this declaration to\n+\tgcc/tree.h.\n+\t* tree.c (typedef_variant_p): Revert moving this definition to\n+\tgcc/tree.c.\n+\t* decl.c (grokdeclarator): Revert naming typedef handling.\n+\n 2010-05-27  Joseph Myers  <joseph@codesourcery.com>\n \n \t* call.c: Include diagnostic-core.h instead of diagnostic.h."}, {"sha": "37a0f1e50ea3762f2a3d05a4feb9227c931398b2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ec4be2f46d4d30d77d8bff19c947073d7e865928", "patch": "@@ -5256,6 +5256,7 @@ extern bool type_has_nontrivial_copy_init\t(const_tree);\n extern bool class_tmpl_impl_spec_p\t\t(const_tree);\n extern int zero_init_p\t\t\t\t(const_tree);\n extern tree strip_typedefs\t\t\t(tree);\n+extern bool typedef_variant_p\t\t\t(tree);\n extern void cp_set_underlying_type\t\t(tree);\n extern tree copy_binfo\t\t\t\t(tree, tree, tree,\n \t\t\t\t\t\t tree *, int);"}, {"sha": "0d30340358867d08c275b35c5d5462afadb35b2c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ec4be2f46d4d30d77d8bff19c947073d7e865928", "patch": "@@ -9081,12 +9081,10 @@ grokdeclarator (const cp_declarator *declarator,\n \t  for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n \t    {\n \t      if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n-\t\t/* We do not rename the debug info representing the\n-\t\t   anonymous tagged type because the standard says in\n-\t\t   [dcl.typedef] that the naming applies only for\n-\t\t   linkage purposes.  */\n-\t\t/*debug_hooks->set_name (t, decl);*/\n-\t\tTYPE_NAME (t) = decl;\n+\t\t{\n+\t\t  debug_hooks->set_name (t, decl);\n+\t\t  TYPE_NAME (t) = decl;\n+\t\t}\n   \t    }\n \n \t  if (TYPE_LANG_SPECIFIC (type))"}, {"sha": "d5ccd65a790031e9dbba9c743430ab5cafe04690", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=ec4be2f46d4d30d77d8bff19c947073d7e865928", "patch": "@@ -1055,6 +1055,14 @@ strip_typedefs (tree t)\n   return cp_build_qualified_type (result, cp_type_quals (t));\n }\n \n+/* Returns true iff TYPE is a type variant created for a typedef. */\n+\n+bool\n+typedef_variant_p (tree type)\n+{\n+  return is_typedef_decl (TYPE_NAME (type));\n+}\n+\n /* Setup a TYPE_DECL node as a typedef representation.\n    See comments of set_underlying_type in c-common.c.  */\n "}, {"sha": "521a25fdcdf9a37aada60692b6694a1b44886196", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 55, "deletions": 131, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ec4be2f46d4d30d77d8bff19c947073d7e865928", "patch": "@@ -6202,7 +6202,6 @@ static void gen_type_die (tree, dw_die_ref);\n static void gen_block_die (tree, dw_die_ref, int);\n static void decls_for_scope (tree, dw_die_ref, int);\n static int is_redundant_typedef (const_tree);\n-static bool is_naming_typedef_decl (const_tree);\n static inline dw_die_ref get_context_die (tree);\n static void gen_namespace_die (tree, dw_die_ref);\n static void gen_decl_die (tree, tree, dw_die_ref);\n@@ -6214,8 +6213,6 @@ static struct dwarf_file_data * lookup_filename (const char *);\n static void retry_incomplete_types (void);\n static void gen_type_die_for_member (tree, tree, dw_die_ref);\n static void gen_generic_params_dies (tree);\n-static void gen_tagged_type_die (tree, dw_die_ref, enum debug_info_usage);\n-static void gen_type_die_with_usage (tree, dw_die_ref, enum debug_info_usage);\n static void splice_child_die (dw_die_ref, dw_die_ref);\n static int file_info_cmp (const void *, const void *);\n static dw_loc_list_ref new_loc_list (dw_loc_descr_ref, const char *,\n@@ -19411,33 +19408,10 @@ gen_typedef_die (tree decl, dw_die_ref context_die)\n \t  equate_type_number_to_die (TREE_TYPE (decl), type_die);\n \t}\n       else\n-\t{\n-\t  /* Here, we are in the case of decl being a typedef naming\n-\t     an anonymous type, e.g:\n-\t        typedef struct {...} foo;\n-\t     In that case TREE_TYPE (decl) is not a typedef variant\n-\t     type and TYPE_NAME of the anonymous type is set to the\n-\t     TYPE_DECL of the typedef. This construct is emitted by\n-\t     the C++ FE.  */\n-\t  type = TREE_TYPE (decl);\n-\n-\t  /* TYPE is the anonymous struct named by the typedef\n-\t     DECL. As we need the DW_AT_type attribute of the\n-\t     DW_TAG_typedef to point to the DIE of TYPE, let's\n-\t     generate that DIE right away. add_type_attribute\n-\t     called below will then pick (via lookup_type_die) that\n-\t     anonymous struct DIE.  */\n-\t  gen_tagged_type_die (type, context_die, DINFO_USAGE_DIR_USE);\n-\t}\n+\ttype = TREE_TYPE (decl);\n \n       add_type_attribute (type_die, type, TREE_READONLY (decl),\n \t\t\t  TREE_THIS_VOLATILE (decl), context_die);\n-\n-      if (is_naming_typedef_decl (decl))\n-\t/* We want that all subsequent calls to lookup_type_die with\n-\t   TYPE in argument yield the DW_TAG_typedef we have just\n-\t   created.  */\n-\tequate_type_number_to_die (type, type_die);\n     }\n \n   if (DECL_ABSTRACT (decl))\n@@ -19447,82 +19421,22 @@ gen_typedef_die (tree decl, dw_die_ref context_die)\n     add_pubtype (decl, type_die);\n }\n \n-/* Generate a DIE for a struct, class, enum or union type.  */\n-\n-static void\n-gen_tagged_type_die (tree type,\n-\t\t     dw_die_ref context_die,\n-\t\t     enum debug_info_usage usage)\n-{\n-  int need_pop;\n-\n-  /* If this is a nested type whose containing class hasn't been written\n-     out yet, writing it out will cover this one, too.  This does not apply\n-     to instantiations of member class templates; they need to be added to\n-     the containing class as they are generated.  FIXME: This hurts the\n-     idea of combining type decls from multiple TUs, since we can't predict\n-     what set of template instantiations we'll get.  */\n-  if (TYPE_CONTEXT (type)\n-      && AGGREGATE_TYPE_P (TYPE_CONTEXT (type))\n-      && ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))\n-    {\n-      gen_type_die_with_usage (TYPE_CONTEXT (type), context_die, usage);\n-\n-      if (TREE_ASM_WRITTEN (type))\n-\treturn;\n-\n-      /* If that failed, attach ourselves to the stub.  */\n-      push_decl_scope (TYPE_CONTEXT (type));\n-      context_die = lookup_type_die (TYPE_CONTEXT (type));\n-      need_pop = 1;\n-    }\n-  else if (TYPE_CONTEXT (type) != NULL_TREE\n-\t   && (TREE_CODE (TYPE_CONTEXT (type)) == FUNCTION_DECL))\n-    {\n-      /* If this type is local to a function that hasn't been written\n-\t out yet, use a NULL context for now; it will be fixed up in\n-\t decls_for_scope.  */\n-      context_die = lookup_decl_die (TYPE_CONTEXT (type));\n-      need_pop = 0;\n-    }\n-  else\n-    {\n-      context_die = declare_in_namespace (type, context_die);\n-      need_pop = 0;\n-    }\n-\n-  if (TREE_CODE (type) == ENUMERAL_TYPE)\n-    {\n-      /* This might have been written out by the call to\n-\t declare_in_namespace.  */\n-      if (!TREE_ASM_WRITTEN (type))\n-\tgen_enumeration_type_die (type, context_die);\n-    }\n-  else\n-    gen_struct_or_union_type_die (type, context_die, usage);\n-\n-  if (need_pop)\n-    pop_decl_scope ();\n-\n-  /* Don't set TREE_ASM_WRITTEN on an incomplete struct; we want to fix\n-     it up if it is ever completed.  gen_*_type_die will set it for us\n-     when appropriate.  */\n-}\n-\n /* Generate a type description DIE.  */\n \n static void\n gen_type_die_with_usage (tree type, dw_die_ref context_die,\n \t\t\t\tenum debug_info_usage usage)\n {\n+  int need_pop;\n   struct array_descr_info info;\n \n   if (type == NULL_TREE || type == error_mark_node)\n     return;\n \n   /* If TYPE is a typedef type variant, let's generate debug info\n      for the parent typedef which TYPE is a type of.  */\n-  if (typedef_variant_p (type))\n+  if (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+      && DECL_ORIGINAL_TYPE (TYPE_NAME (type)))\n     {\n       if (TREE_ASM_WRITTEN (type))\n \treturn;\n@@ -19537,21 +19451,6 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n \tcontext_die = get_context_die (DECL_CONTEXT (TYPE_NAME (type)));\n \n       TREE_ASM_WRITTEN (type) = 1;\n-\n-      gen_decl_die (TYPE_NAME (type), NULL, context_die);\n-      return;\n-    }\n-\n-  /* If type is an anonymous tagged type named by a typedef, let's\n-     generate debug info for the typedef.  */\n-  if (is_naming_typedef_decl (TYPE_NAME (type)))\n-    {\n-      /* Use the DIE of the containing namespace as the parent DIE of\n-         the type description DIE we want to generate.  */\n-      if (DECL_CONTEXT (TYPE_NAME (type))\n-\t  && TREE_CODE (DECL_CONTEXT (TYPE_NAME (type))) == NAMESPACE_DECL)\n-\tcontext_die = get_context_die (DECL_CONTEXT (TYPE_NAME (type)));\n-      \n       gen_decl_die (TYPE_NAME (type), NULL, context_die);\n       return;\n     }\n@@ -19639,7 +19538,57 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n-      gen_tagged_type_die (type, context_die, usage);\n+      /* If this is a nested type whose containing class hasn't been written\n+\t out yet, writing it out will cover this one, too.  This does not apply\n+\t to instantiations of member class templates; they need to be added to\n+\t the containing class as they are generated.  FIXME: This hurts the\n+\t idea of combining type decls from multiple TUs, since we can't predict\n+\t what set of template instantiations we'll get.  */\n+      if (TYPE_CONTEXT (type)\n+\t  && AGGREGATE_TYPE_P (TYPE_CONTEXT (type))\n+\t  && ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))\n+\t{\n+\t  gen_type_die_with_usage (TYPE_CONTEXT (type), context_die, usage);\n+\n+\t  if (TREE_ASM_WRITTEN (type))\n+\t    return;\n+\n+\t  /* If that failed, attach ourselves to the stub.  */\n+\t  push_decl_scope (TYPE_CONTEXT (type));\n+\t  context_die = lookup_type_die (TYPE_CONTEXT (type));\n+\t  need_pop = 1;\n+\t}\n+      else if (TYPE_CONTEXT (type) != NULL_TREE\n+\t       && (TREE_CODE (TYPE_CONTEXT (type)) == FUNCTION_DECL))\n+\t{\n+\t  /* If this type is local to a function that hasn't been written\n+\t     out yet, use a NULL context for now; it will be fixed up in\n+\t     decls_for_scope.  */\n+\t  context_die = lookup_decl_die (TYPE_CONTEXT (type));\n+\t  need_pop = 0;\n+\t}\n+      else\n+\t{\n+\t  context_die = declare_in_namespace (type, context_die);\n+\t  need_pop = 0;\n+\t}\n+\n+      if (TREE_CODE (type) == ENUMERAL_TYPE)\n+\t{\n+\t  /* This might have been written out by the call to\n+\t     declare_in_namespace.  */\n+\t  if (!TREE_ASM_WRITTEN (type))\n+\t    gen_enumeration_type_die (type, context_die);\n+\t}\n+      else\n+\tgen_struct_or_union_type_die (type, context_die, usage);\n+\n+      if (need_pop)\n+\tpop_decl_scope ();\n+\n+      /* Don't set TREE_ASM_WRITTEN on an incomplete struct; we want to fix\n+\t it up if it is ever completed.  gen_*_type_die will set it for us\n+\t when appropriate.  */\n       return;\n \n     case VOID_TYPE:\n@@ -19847,31 +19796,6 @@ is_redundant_typedef (const_tree decl)\n   return 0;\n }\n \n-/* Return TRUE if TYPE is a typedef that names a type for linkage\n-   purposes. This kind of typedefs is produced by the C++ FE for\n-   constructs like:\n-\n-   typedef struct {...} foo;\n-\n-   In that case, there is no typedef variant type produced for foo.\n-   Rather, the TREE_TYPE of the TYPE_DECL of foo is the anonymous\n-   struct type.  */\n-\n-static bool\n-is_naming_typedef_decl (const_tree decl)\n-{\n-  if (decl == NULL_TREE\n-      || TREE_CODE (decl) != TYPE_DECL\n-      || !is_tagged_type (TREE_TYPE (decl))\n-      || is_redundant_typedef (decl))\n-    return FALSE;\n-\n-  return (DECL_ORIGINAL_TYPE (decl) == NULL_TREE\n-\t  && TYPE_NAME (TREE_TYPE (decl)) == decl\n-\t  && (TYPE_STUB_DECL (TREE_TYPE (decl))\n-\t      != TYPE_NAME (TREE_TYPE (decl))));\n-}\n-\n /* Returns the DIE for a context.  */\n \n static inline dw_die_ref"}, {"sha": "eb52c55e577f438d55bbf4eb9a77d0e9ceb9c138", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ec4be2f46d4d30d77d8bff19c947073d7e865928", "patch": "@@ -1,3 +1,8 @@\n+2010-05-28  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tRevert patch for PR c++/44188\n+\t* g++.dg/debug/dwarf2/typedef3.C: Revert new test.\n+\n 2010-05-25  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/44188"}, {"sha": "ca70d9cacfac7e38cd0aead1ee507dcbb9d46e99", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/typedef3.C", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe7b63c521d8a12dba549aef8fb6b724aff635b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Ftypedef3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe7b63c521d8a12dba549aef8fb6b724aff635b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Ftypedef3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Ftypedef3.C?ref=3fe7b63c521d8a12dba549aef8fb6b724aff635b", "patch": "@@ -1,19 +0,0 @@\n-// Origin: PR debug/44188\n-// { dg-options \"-g -dA\" }\n-// { dg-do compile }\n-\n-// { dg-final { scan-assembler-times \"\\[^\\n\\r\\]*\\\\(DIE\\[^\\n\\r\\]*DW_TAG_typedef\\\\)\" 1 } }\n-\n-// { dg-final { scan-assembler-times \"\\[^\\n\\r\\]*\\\\(DIE\\[^\\n\\r\\]*DW_TAG_structure_type\\\\)\" 1 } }\n-\n-typedef struct\n-{\n-  int i;\n-} AAA;\n-\n-int\n-main(void)\n-{\n-  AAA aa;\n-  return 0;\n-}"}, {"sha": "743293e288a55fa0e99632c7793c3120b87bd4f4", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ec4be2f46d4d30d77d8bff19c947073d7e865928", "patch": "@@ -10825,21 +10825,4 @@ get_binfo_at_offset (tree binfo, HOST_WIDE_INT offset, tree expected_type)\n   return binfo;\n }\n \n-/* Returns true if X is a typedef decl.  */\n-\n-bool\n-is_typedef_decl (tree x)\n-{\n-  return (x && TREE_CODE (x) == TYPE_DECL\n-          && DECL_ORIGINAL_TYPE (x) != NULL_TREE);\n-}\n-\n-/* Returns true iff TYPE is a type variant created for a typedef. */\n-\n-bool\n-typedef_variant_p (tree type)\n-{\n-  return is_typedef_decl (TYPE_NAME (type));\n-}\n-\n #include \"gt-tree.h\""}, {"sha": "5acadb499cb2a3d345e921c340c214b00ae56177", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4be2f46d4d30d77d8bff19c947073d7e865928/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ec4be2f46d4d30d77d8bff19c947073d7e865928", "patch": "@@ -4820,8 +4820,6 @@ extern tree create_artificial_label (location_t);\n extern const char *get_name (tree);\n extern bool stdarg_p (tree);\n extern bool prototype_p (tree);\n-extern bool is_typedef_decl (tree x);\n-extern bool typedef_variant_p (tree);\n extern bool auto_var_in_fn_p (const_tree, const_tree);\n extern tree build_low_bits_mask (tree, unsigned);\n extern tree tree_strip_nop_conversions (tree);"}]}