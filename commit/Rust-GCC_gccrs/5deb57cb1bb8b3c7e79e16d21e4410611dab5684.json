{"sha": "5deb57cb1bb8b3c7e79e16d21e4410611dab5684", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRlYjU3Y2IxYmI4YjNjN2U3OWUxNmQyMWU0NDEwNjExZGFiNTY4NA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-06-28T17:53:58Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-06-28T17:53:58Z"}, "message": "re PR tree-optimization/51581 (Integer division by constant is not vectorized)\n\n\tPR tree-optimization/51581\n\t* tree-vect-stmts.c (permute_vec_elements): Add forward decl.\n\t(vectorizable_operation): Handle vectorization of MULT_HIGHPART_EXPR\n\talso using VEC_WIDEN_MULT_*_EXPR or builtin_mul_widen_* plus\n\tVEC_PERM_EXPR if vector MULT_HIGHPART_EXPR isn't supported.\n\t* tree-vect-patterns.c (vect_recog_divmod_pattern): Use\n\tMULT_HIGHPART_EXPR instead of VEC_WIDEN_MULT_*_EXPR and shifts.\n\n\t* gcc.dg/vect/pr51581-4.c: New test.\n\nFrom-SVN: r189053", "tree": {"sha": "b21cfac4d2981d684a000a3ebe6facb7c95018b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b21cfac4d2981d684a000a3ebe6facb7c95018b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5deb57cb1bb8b3c7e79e16d21e4410611dab5684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5deb57cb1bb8b3c7e79e16d21e4410611dab5684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5deb57cb1bb8b3c7e79e16d21e4410611dab5684", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5deb57cb1bb8b3c7e79e16d21e4410611dab5684/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c9ba330781f41dd3e35d1c775a3a3eeaa0b4c61e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9ba330781f41dd3e35d1c775a3a3eeaa0b4c61e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9ba330781f41dd3e35d1c775a3a3eeaa0b4c61e"}], "stats": {"total": 542, "additions": 399, "deletions": 143}, "files": [{"sha": "4e327763ce82e590b7396bbc986328e80fe4b7cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5deb57cb1bb8b3c7e79e16d21e4410611dab5684/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5deb57cb1bb8b3c7e79e16d21e4410611dab5684/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5deb57cb1bb8b3c7e79e16d21e4410611dab5684", "patch": "@@ -1,5 +1,13 @@\n 2012-06-28  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/51581\n+\t* tree-vect-stmts.c (permute_vec_elements): Add forward decl.\n+\t(vectorizable_operation): Handle vectorization of MULT_HIGHPART_EXPR\n+\talso using VEC_WIDEN_MULT_*_EXPR or builtin_mul_widen_* plus\n+\tVEC_PERM_EXPR if vector MULT_HIGHPART_EXPR isn't supported.\n+\t* tree-vect-patterns.c (vect_recog_divmod_pattern): Use\n+\tMULT_HIGHPART_EXPR instead of VEC_WIDEN_MULT_*_EXPR and shifts.\n+\n \tPR tree-optimization/53645\n \t* tree-vect-generic.c (expand_vector_divmod): Use MULT_HIGHPART_EXPR\n \tinstead of VEC_WIDEN_MULT_{HI,LO}_EXPR followed by VEC_PERM_EXPR"}, {"sha": "d2ff7b93fe89619f40ffbec2007d7f29666e7271", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5deb57cb1bb8b3c7e79e16d21e4410611dab5684/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5deb57cb1bb8b3c7e79e16d21e4410611dab5684/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5deb57cb1bb8b3c7e79e16d21e4410611dab5684", "patch": "@@ -1,5 +1,8 @@\n 2012-06-28  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/51581\n+\t* gcc.dg/vect/pr51581-4.c: New test.\n+\n \tPR tree-optimization/53645\n \t* gcc.c-torture/execute/pr53645-2.c: New test.\n "}, {"sha": "f48ec6b59378ef426f71dd994c85eb99bf5d4650", "filename": "gcc/testsuite/gcc.dg/vect/pr51581-4.c", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5deb57cb1bb8b3c7e79e16d21e4410611dab5684/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr51581-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5deb57cb1bb8b3c7e79e16d21e4410611dab5684/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr51581-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr51581-4.c?ref=5deb57cb1bb8b3c7e79e16d21e4410611dab5684", "patch": "@@ -0,0 +1,166 @@\n+/* PR tree-optimization/51581 */\n+\n+#include \"tree-vect.h\"\n+\n+short int a[16], b[16];\n+unsigned short int c[16], d[16];\n+\n+void\n+f1 (void)\n+{\n+  a[0] = b[0] / 8;\n+  a[1] = b[1] / 8;\n+  a[2] = b[2] / 8;\n+  a[3] = b[3] / 8;\n+  a[4] = b[4] / 8;\n+  a[5] = b[5] / 8;\n+  a[6] = b[6] / 8;\n+  a[7] = b[7] / 8;\n+  a[8] = b[8] / 8;\n+  a[9] = b[9] / 8;\n+  a[10] = b[10] / 8;\n+  a[11] = b[11] / 8;\n+  a[12] = b[12] / 8;\n+  a[13] = b[13] / 8;\n+  a[14] = b[14] / 8;\n+  a[15] = b[15] / 8;\n+}\n+\n+void\n+f2 (void)\n+{\n+  c[0] = d[0] / 3;\n+  c[1] = d[1] / 3;\n+  c[2] = d[2] / 3;\n+  c[3] = d[3] / 3;\n+  c[4] = d[4] / 3;\n+  c[5] = d[5] / 3;\n+  c[6] = d[6] / 3;\n+  c[7] = d[7] / 3;\n+  c[8] = d[8] / 3;\n+  c[9] = d[9] / 3;\n+  c[10] = d[10] / 3;\n+  c[11] = d[11] / 3;\n+  c[12] = d[12] / 3;\n+  c[13] = d[13] / 3;\n+  c[14] = d[14] / 3;\n+  c[15] = d[15] / 3;\n+}\n+\n+void\n+f3 (void)\n+{\n+  a[0] = b[0] / 8;\n+  a[1] = b[1] / 4;\n+  a[2] = b[2] / 8;\n+  a[3] = b[3] / 4;\n+  a[4] = b[4] / 8;\n+  a[5] = b[5] / 4;\n+  a[6] = b[6] / 8;\n+  a[7] = b[7] / 4;\n+  a[8] = b[8] / 8;\n+  a[9] = b[9] / 4;\n+  a[10] = b[10] / 8;\n+  a[11] = b[11] / 4;\n+  a[12] = b[12] / 8;\n+  a[13] = b[13] / 4;\n+  a[14] = b[14] / 8;\n+  a[15] = b[15] / 4;\n+}\n+\n+void\n+f4 (void)\n+{\n+  c[0] = d[0] / 3;\n+  c[1] = d[1] / 5;\n+  c[2] = d[2] / 3;\n+  c[3] = d[3] / 5;\n+  c[4] = d[4] / 3;\n+  c[5] = d[5] / 5;\n+  c[6] = d[6] / 3;\n+  c[7] = d[7] / 5;\n+  c[8] = d[8] / 3;\n+  c[9] = d[9] / 5;\n+  c[10] = d[10] / 3;\n+  c[11] = d[11] / 5;\n+  c[12] = d[12] / 3;\n+  c[13] = d[13] / 5;\n+  c[14] = d[14] / 3;\n+  c[15] = d[15] / 5;\n+}\n+\n+void\n+f5 (void)\n+{\n+  a[0] = b[0] / 14;\n+  a[1] = b[1] / 15;\n+  a[2] = b[2] / 14;\n+  a[3] = b[3] / 15;\n+  a[4] = b[4] / 14;\n+  a[5] = b[5] / 15;\n+  a[6] = b[6] / 14;\n+  a[7] = b[7] / 15;\n+  a[8] = b[8] / 14;\n+  a[9] = b[9] / 15;\n+  a[10] = b[10] / 14;\n+  a[11] = b[11] / 15;\n+  a[12] = b[12] / 14;\n+  a[13] = b[13] / 15;\n+  a[14] = b[14] / 14;\n+  a[15] = b[15] / 15;\n+}\n+\n+void\n+f6 (void)\n+{\n+  c[0] = d[0] / 6;\n+  c[1] = d[1] / 5;\n+  c[2] = d[2] / 6;\n+  c[3] = d[3] / 5;\n+  c[4] = d[4] / 6;\n+  c[5] = d[5] / 5;\n+  c[6] = d[6] / 13;\n+  c[7] = d[7] / 5;\n+  c[8] = d[8] / 6;\n+  c[9] = d[9] / 5;\n+  c[10] = d[10] / 6;\n+  c[11] = d[11] / 5;\n+  c[12] = d[12] / 6;\n+  c[13] = d[13] / 5;\n+  c[14] = d[14] / 13;\n+  c[15] = d[15] / 5;\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  asm (\"\");\n+  for (i = 0; i < 16; i++)\n+    {\n+      asm (\"\");\n+      b[i] = i - 8;\n+      d[i] = i - 8;\n+    }\n+  f1 ();\n+  f2 ();\n+  for (i = 0; i < 16; i++)\n+    if (a[i] != b[i] / 8 || c[i] != d[i] / 3)\n+      abort ();\n+  f3 ();\n+  f4 ();\n+  for (i = 0; i < 16; i+= 2)\n+    if (a[i] != b[i] / 8 || a[i + 1] != b[i + 1] / 4\n+\t|| c[i] != d[i] / 3 || c[i + 1] != d[i + 1] / 5)\n+      abort ();\n+  f5 ();\n+  f6 ();\n+  for (i = 0; i < 16; i+= 2)\n+    if (a[i] != b[i] / 14 || a[i + 1] != b[i + 1] / 15\n+\t|| c[i] != d[i] / ((i & 7) == 6 ? 13 : 6) || c[i + 1] != d[i + 1] / 5)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "3f57e5dcf8b1e01b7c14b9bc1b4338cb090bee52", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 69, "deletions": 132, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5deb57cb1bb8b3c7e79e16d21e4410611dab5684/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5deb57cb1bb8b3c7e79e16d21e4410611dab5684/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=5deb57cb1bb8b3c7e79e16d21e4410611dab5684", "patch": "@@ -1635,7 +1635,7 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n \t\t\t   tree *type_in, tree *type_out)\n {\n   gimple last_stmt = VEC_pop (gimple, *stmts);\n-  tree oprnd0, oprnd1, vectype, itype, witype, vecwtype, cond;\n+  tree oprnd0, oprnd1, vectype, itype, cond;\n   gimple pattern_stmt, def_stmt;\n   enum tree_code rhs_code;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n@@ -1814,17 +1814,23 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n       || prec > HOST_BITS_PER_WIDE_INT)\n     return NULL;\n \n-  witype = build_nonstandard_integer_type (prec * 2,\n-\t\t\t\t\t   TYPE_UNSIGNED (itype));\n-  vecwtype = get_vectype_for_scalar_type (witype);\n-  if (vecwtype == NULL_TREE)\n-    return NULL;\n+  optab = optab_for_tree_code (MULT_HIGHPART_EXPR, vectype, optab_default);\n+  if (optab == NULL\n+      || optab_handler (optab, TYPE_MODE (vectype)) == CODE_FOR_nothing)\n+    {\n+      tree witype = build_nonstandard_integer_type (prec * 2,\n+\t\t\t\t\t\t    TYPE_UNSIGNED (itype));\n+      tree vecwtype = get_vectype_for_scalar_type (witype);\n \n-  if (!supportable_widening_operation (WIDEN_MULT_EXPR, last_stmt,\n-\t\t\t\t       vecwtype, vectype,\n-\t\t\t\t       &dummy, &dummy, &dummy_code,\n-\t\t\t\t       &dummy_code, &dummy_int, &dummy_vec))\n-    return NULL;\n+      if (vecwtype == NULL_TREE)\n+\treturn NULL;\n+      if (!supportable_widening_operation (WIDEN_MULT_EXPR, last_stmt,\n+\t\t\t\t\t   vecwtype, vectype,\n+\t\t\t\t\t   &dummy, &dummy, &dummy_code,\n+\t\t\t\t\t   &dummy_code, &dummy_int,\n+\t\t\t\t\t   &dummy_vec))\n+\treturn NULL;\n+    }\n \n   STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n \n@@ -1834,7 +1840,7 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n       int pre_shift, post_shift;\n       unsigned HOST_WIDE_INT d = tree_low_cst (oprnd1, 1)\n \t\t\t\t & GET_MODE_MASK (TYPE_MODE (itype));\n-      tree t1, t2, t3, t4, t5, t6;\n+      tree t1, t2, t3, t4;\n \n       if (d >= ((unsigned HOST_WIDE_INT) 1 << (prec - 1)))\n \t/* FIXME: Can transform this into oprnd0 >= oprnd1 ? 1 : 0.  */\n@@ -1861,65 +1867,46 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n \t  if (post_shift - 1 >= prec)\n \t    return NULL;\n \n-\t  /* t1 = oprnd0 w* ml;\n-\t     t2 = t1 >> prec;\n-\t     t3 = (type) t2;\n-\t     t4 = oprnd0 - t3;\n-\t     t5 = t4 >> 1;\n-\t     t6 = t3 + t5;\n-\t     q = t6 >> (post_shift - 1);  */\n-\t  t1 = vect_recog_temp_ssa_var (witype, NULL);\n+\t  /* t1 = oprnd0 h* ml;\n+\t     t2 = oprnd0 - t1;\n+\t     t3 = t2 >> 1;\n+\t     t4 = t1 + t3;\n+\t     q = t4 >> (post_shift - 1);  */\n+\t  t1 = vect_recog_temp_ssa_var (itype, NULL);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (WIDEN_MULT_EXPR, t1, oprnd0,\n+\t    = gimple_build_assign_with_ops (MULT_HIGHPART_EXPR, t1, oprnd0,\n \t\t\t\t\t    build_int_cst (itype, ml));\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n-\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n-\t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n-\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecwtype;\n \n-\t  t2 = vect_recog_temp_ssa_var (witype, NULL);\n+\t  t2 = vect_recog_temp_ssa_var (itype, NULL);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (RSHIFT_EXPR, t2, t1,\n-\t\t\t\t\t    build_int_cst (itype, prec));\n+\t    = gimple_build_assign_with_ops (MINUS_EXPR, t2, oprnd0, t1);\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n-\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n-\t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n-\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecwtype;\n \n \t  t3 = vect_recog_temp_ssa_var (itype, NULL);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (NOP_EXPR, t3, t2, NULL_TREE);\n-\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n-\n-\t  t4 = vect_recog_temp_ssa_var (itype, NULL);\n-\t  def_stmt\n-\t    = gimple_build_assign_with_ops (MINUS_EXPR, t4, oprnd0, t3);\n-\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n-\n-\t  t5 = vect_recog_temp_ssa_var (itype, NULL);\n-\t  def_stmt\n-\t    = gimple_build_assign_with_ops (RSHIFT_EXPR, t5, t4,\n+\t    = gimple_build_assign_with_ops (RSHIFT_EXPR, t3, t2,\n \t\t\t\t\t    integer_one_node);\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n-\t  t6 = vect_recog_temp_ssa_var (itype, NULL);\n+\t  t4 = vect_recog_temp_ssa_var (itype, NULL);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (PLUS_EXPR, t6, t3, t5);\n+\t    = gimple_build_assign_with_ops (PLUS_EXPR, t4, t1, t3);\n \n \t  if (post_shift != 1)\n \t    {\n \t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n-\t      q = vect_recog_temp_ssa_var (witype, NULL);\n+\t      q = vect_recog_temp_ssa_var (itype, NULL);\n \t      pattern_stmt\n-\t\t= gimple_build_assign_with_ops (RSHIFT_EXPR, q, t6,\n+\t\t= gimple_build_assign_with_ops (RSHIFT_EXPR, q, t4,\n \t\t\t\t\t\tbuild_int_cst (itype,\n \t\t\t\t\t\t\t       post_shift\n \t\t\t\t\t\t\t       - 1));\n \t    }\n \t  else\n \t    {\n-\t      q = t6;\n+\t      q = t4;\n \t      pattern_stmt = def_stmt;\n \t    }\n \t}\n@@ -1929,9 +1916,8 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n \t    return NULL;\n \n \t  /* t1 = oprnd0 >> pre_shift;\n-\t     t2 = t1 w* ml;\n-\t     t3 = t2 >> (prec + post_shift);\n-\t     q = (type) t3;  */\n+\t     t2 = t1 h* ml;\n+\t     q = t2 >> post_shift;  */\n \t  if (pre_shift)\n \t    {\n \t      t1 = vect_recog_temp_ssa_var (itype, NULL);\n@@ -1944,28 +1930,25 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n \t  else\n \t    t1 = oprnd0;\n \n-\t  t2 = vect_recog_temp_ssa_var (witype, NULL);\n+\t  t2 = vect_recog_temp_ssa_var (itype, NULL);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (WIDEN_MULT_EXPR, t2, t1,\n+\t    = gimple_build_assign_with_ops (MULT_HIGHPART_EXPR, t2, t1,\n \t\t\t\t\t    build_int_cst (itype, ml));\n-\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n-\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n-\t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n-\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecwtype;\n \n-\t  t3 = vect_recog_temp_ssa_var (witype, NULL);\n-\t  def_stmt\n-\t    = gimple_build_assign_with_ops (RSHIFT_EXPR, t3, t2,\n-\t\t\t\t\t    build_int_cst (itype, post_shift\n-\t\t\t\t\t\t\t\t  + prec));\n-\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n-\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n-\t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n-\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecwtype;\n+\t  if (post_shift)\n+\t    {\n+\t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n-\t  q = vect_recog_temp_ssa_var (itype, NULL);\n-\t  pattern_stmt\n-\t    = gimple_build_assign_with_ops (NOP_EXPR, q, t3, NULL_TREE);\n+\t      q = vect_recog_temp_ssa_var (itype, NULL);\n+\t      def_stmt\n+\t\t= gimple_build_assign_with_ops (RSHIFT_EXPR, q, t2,\n+\t\t\t\t\t\tbuild_int_cst (itype,\n+\t\t\t\t\t\t\t       post_shift));\n+\t    }\n+\t  else\n+\t    q = t2;\n+\n+\t  pattern_stmt = def_stmt;\n \t}\n     }\n   else\n@@ -1975,21 +1958,12 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n       HOST_WIDE_INT d = tree_low_cst (oprnd1, 0);\n       unsigned HOST_WIDE_INT abs_d;\n       bool add = false;\n-      tree uwitype = NULL, vecuwtype = NULL;\n-      tree t1, t2, t3, t4, t5, t6, t7;\n+      tree t1, t2, t3, t4;\n \n       /* Give up for -1.  */\n       if (d == -1)\n \treturn NULL;\n \n-      if (!vect_supportable_shift (RSHIFT_EXPR, witype))\n-\t{\n-\t  uwitype = build_nonstandard_integer_type (prec * 2, 1);\n-\t  vecuwtype = get_vectype_for_scalar_type (uwitype);\n-\t  if (vecuwtype == NULL_TREE)\n-\t    return NULL;\n-\t}\n-\n       /* Since d might be INT_MIN, we have to cast to\n \t unsigned HOST_WIDE_INT before negating to avoid\n \t undefined signed overflow.  */\n@@ -2017,85 +1991,48 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n       if (post_shift >= prec)\n \treturn NULL;\n \n-      /* t1 = oprnd1 w* ml;  */\n-      t1 = vect_recog_temp_ssa_var (witype, NULL);\n+      /* t1 = oprnd1 h* ml;  */\n+      t1 = vect_recog_temp_ssa_var (itype, NULL);\n       def_stmt\n-\t= gimple_build_assign_with_ops (WIDEN_MULT_EXPR, t1, oprnd0,\n+\t= gimple_build_assign_with_ops (MULT_HIGHPART_EXPR, t1, oprnd0,\n \t\t\t\t\tbuild_int_cst (itype, ml));\n       append_pattern_def_seq (stmt_vinfo, def_stmt);\n-      def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n-      set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n-      STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecwtype;\n-\n-      if (vecuwtype != NULL)\n-\t{\n-\t  /* t2 = (uwtype) t1;  */\n-\t  t2 = vect_recog_temp_ssa_var (uwitype, NULL);\n-\t  def_stmt\n-\t    = gimple_build_assign_with_ops (NOP_EXPR, t2, t1, NULL_TREE);\n-\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n-\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n-\t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n-\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecuwtype;\n-\t}\n-      else\n-\tt2 = t1;\n-\n-      /* t3 = t2 >> prec;  or t3 = t2 >> (prec + post_shift);  */\n-      t3 = vect_recog_temp_ssa_var (vecuwtype ? uwitype : witype, NULL);\n-      def_stmt\n-\t= gimple_build_assign_with_ops (RSHIFT_EXPR, t3, t2,\n-\t\t\t\t\tbuild_int_cst (itype,\n-\t\t\t\t\t\t       prec\n-\t\t\t\t\t\t       + (!add\n-\t\t\t\t\t\t\t  && vecuwtype == NULL\n-\t\t\t\t\t\t\t  ? post_shift : 0)));\n-      append_pattern_def_seq (stmt_vinfo, def_stmt);\n-      def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n-      set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n-      STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecuwtype ? vecuwtype : vecwtype;\n-\n-      /* t4 = (type) t3;  */\n-      t4 = vect_recog_temp_ssa_var (itype, NULL);\n-      def_stmt\n-\t= gimple_build_assign_with_ops (NOP_EXPR, t4, t3, NULL_TREE);\n-      append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n       if (add)\n \t{\n-\t  /* t5 = t4 + oprnd0;  */\n-\t  t5 = vect_recog_temp_ssa_var (itype, NULL);\n+\t  /* t2 = t1 + oprnd0;  */\n+\t  t2 = vect_recog_temp_ssa_var (itype, NULL);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (PLUS_EXPR, t5, t4, oprnd0);\n+\t    = gimple_build_assign_with_ops (PLUS_EXPR, t2, t1, oprnd0);\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n \t}\n       else\n-\tt5 = t4;\n+\tt2 = t1;\n \n-      if ((add || vecuwtype != NULL) && post_shift)\n+      if (post_shift)\n \t{\n-\t  /* t6 = t5 >> post_shift;  */\n-\t  t6 = vect_recog_temp_ssa_var (itype, NULL);\n+\t  /* t3 = t2 >> post_shift;  */\n+\t  t3 = vect_recog_temp_ssa_var (itype, NULL);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (RSHIFT_EXPR, t6, t5,\n+\t    = gimple_build_assign_with_ops (RSHIFT_EXPR, t3, t2,\n \t\t\t\t\t    build_int_cst (itype, post_shift));\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n \t}\n       else\n-\tt6 = t5;\n+\tt3 = t2;\n \n-      /* t7 = oprnd0 >> (prec - 1);  */\n-      t7 = vect_recog_temp_ssa_var (itype, NULL);\n+      /* t4 = oprnd0 >> (prec - 1);  */\n+      t4 = vect_recog_temp_ssa_var (itype, NULL);\n       def_stmt\n-\t= gimple_build_assign_with_ops (RSHIFT_EXPR, t7, oprnd0,\n+\t= gimple_build_assign_with_ops (RSHIFT_EXPR, t4, oprnd0,\n \t\t\t\t\tbuild_int_cst (itype, prec - 1));\n       append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n-      /* q = t6 - t7;  or q = t7 - t6;  */\n+      /* q = t3 - t4;  or q = t4 - t3;  */\n       q = vect_recog_temp_ssa_var (itype, NULL);\n       pattern_stmt\n-\t= gimple_build_assign_with_ops (MINUS_EXPR, q, d < 0 ? t7 : t6,\n-\t\t\t\t\td < 0 ? t6 : t7);\n+\t= gimple_build_assign_with_ops (MINUS_EXPR, q, d < 0 ? t4 : t3,\n+\t\t\t\t\td < 0 ? t3 : t4);\n     }\n \n   if (rhs_code == TRUNC_MOD_EXPR)"}, {"sha": "b40e68c4060fdd4300ee254ea8c8e0ad9f34579b", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 153, "deletions": 11, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5deb57cb1bb8b3c7e79e16d21e4410611dab5684/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5deb57cb1bb8b3c7e79e16d21e4410611dab5684/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=5deb57cb1bb8b3c7e79e16d21e4410611dab5684", "patch": "@@ -3288,6 +3288,10 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n }\n \n \n+static tree permute_vec_elements (tree, tree, tree, gimple,\n+\t\t\t\t  gimple_stmt_iterator *);\n+\n+\n /* Function vectorizable_operation.\n \n    Check if STMT performs a binary, unary or ternary operation that can\n@@ -3300,17 +3304,18 @@ static bool\n vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t\tgimple *vec_stmt, slp_tree slp_node)\n {\n-  tree vec_dest;\n+  tree vec_dest, vec_dest2 = NULL_TREE;\n+  tree vec_dest3 = NULL_TREE, vec_dest4 = NULL_TREE;\n   tree scalar_dest;\n   tree op0, op1 = NULL_TREE, op2 = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  tree vectype;\n+  tree vectype, wide_vectype = NULL_TREE;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   enum tree_code code;\n   enum machine_mode vec_mode;\n   tree new_temp;\n   int op_type;\n-  optab optab;\n+  optab optab, optab2 = NULL;\n   int icode;\n   tree def;\n   gimple def_stmt;\n@@ -3327,6 +3332,8 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   tree vop0, vop1, vop2;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   int vf;\n+  unsigned char *sel = NULL;\n+  tree decl1 = NULL_TREE, decl2 = NULL_TREE, perm_mask = NULL_TREE;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n@@ -3451,31 +3458,97 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   optab = optab_for_tree_code (code, vectype, optab_default);\n \n   /* Supportable by target?  */\n-  if (!optab)\n+  if (!optab && code != MULT_HIGHPART_EXPR)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"no optab.\");\n       return false;\n     }\n   vec_mode = TYPE_MODE (vectype);\n-  icode = (int) optab_handler (optab, vec_mode);\n+  icode = optab ? (int) optab_handler (optab, vec_mode) : CODE_FOR_nothing;\n+\n+  if (icode == CODE_FOR_nothing\n+      && code == MULT_HIGHPART_EXPR\n+      && VECTOR_MODE_P (vec_mode)\n+      && BYTES_BIG_ENDIAN == WORDS_BIG_ENDIAN)\n+    {\n+      /* If MULT_HIGHPART_EXPR isn't supported by the backend, see\n+\t if we can emit VEC_WIDEN_MULT_{LO,HI}_EXPR followed by VEC_PERM_EXPR\n+\t or builtin_mul_widen_{even,odd} followed by VEC_PERM_EXPR.  */\n+      unsigned int prec = TYPE_PRECISION (TREE_TYPE (scalar_dest));\n+      unsigned int unsignedp = TYPE_UNSIGNED (TREE_TYPE (scalar_dest));\n+      tree wide_type\n+\t= build_nonstandard_integer_type (prec * 2, unsignedp);\n+      wide_vectype\n+        = get_same_sized_vectype (wide_type, vectype);\n+\n+      sel = XALLOCAVEC (unsigned char, nunits_in);\n+      if (VECTOR_MODE_P (TYPE_MODE (wide_vectype))\n+\t  && GET_MODE_SIZE (TYPE_MODE (wide_vectype))\n+\t     == GET_MODE_SIZE (vec_mode))\n+\t{\n+\t  if (targetm.vectorize.builtin_mul_widen_even\n+\t      && (decl1 = targetm.vectorize.builtin_mul_widen_even (vectype))\n+\t      && targetm.vectorize.builtin_mul_widen_odd\n+\t      && (decl2 = targetm.vectorize.builtin_mul_widen_odd (vectype))\n+\t      && TYPE_MODE (TREE_TYPE (TREE_TYPE (decl1)))\n+\t\t == TYPE_MODE (wide_vectype))\n+\t    {\n+\t      for (i = 0; i < nunits_in; i++)\n+\t\tsel[i] = !BYTES_BIG_ENDIAN + (i & ~1)\n+\t\t\t + ((i & 1) ? nunits_in : 0);\n+\t      if (can_vec_perm_p (vec_mode, false, sel))\n+\t\ticode = 0;\n+\t    }\n+\t  if (icode == CODE_FOR_nothing)\n+\t    {\n+\t      decl1 = NULL_TREE;\n+\t      decl2 = NULL_TREE;\n+\t      optab = optab_for_tree_code (VEC_WIDEN_MULT_HI_EXPR,\n+\t\t\t\t\t   vectype, optab_default);\n+\t      optab2 = optab_for_tree_code (VEC_WIDEN_MULT_HI_EXPR,\n+\t\t\t\t\t    vectype, optab_default);\n+\t      if (optab != NULL\n+\t\t  && optab2 != NULL\n+\t\t  && optab_handler (optab, vec_mode) != CODE_FOR_nothing\n+\t\t  && optab_handler (optab2, vec_mode) != CODE_FOR_nothing)\n+\t\t{\n+\t\t  for (i = 0; i < nunits_in; i++)\n+\t\t    sel[i] = !BYTES_BIG_ENDIAN + 2 * i;\n+\t\t  if (can_vec_perm_p (vec_mode, false, sel))\n+\t\t    icode = optab_handler (optab, vec_mode);\n+\t\t}\n+\t    }\n+\t}\n+      if (icode == CODE_FOR_nothing)\n+\t{\n+\t  if (optab_for_tree_code (code, vectype, optab_default) == NULL)\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\tfprintf (vect_dump, \"no optab.\");\n+\t      return false;\n+\t    }\n+\t  wide_vectype = NULL_TREE;\n+\t  optab2 = NULL;\n+\t}\n+    }\n+\n   if (icode == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"op not supported by target.\");\n       /* Check only during analysis.  */\n       if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n-\t  || (vf < vect_min_worthwhile_factor (code)\n-              && !vec_stmt))\n+\t  || (!vec_stmt && vf < vect_min_worthwhile_factor (code)))\n         return false;\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"proceeding using word mode.\");\n     }\n \n   /* Worthwhile without SIMD support?  Check only during analysis.  */\n-  if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n-      && vf < vect_min_worthwhile_factor (code)\n-      && !vec_stmt)\n+  if (!VECTOR_MODE_P (vec_mode)\n+      && !vec_stmt\n+      && vf < vect_min_worthwhile_factor (code))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"not worthwhile without SIMD support.\");\n@@ -3497,7 +3570,16 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n     fprintf (vect_dump, \"transform binary/unary operation.\");\n \n   /* Handle def.  */\n-  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+  if (wide_vectype)\n+    {\n+      vec_dest = vect_create_destination_var (scalar_dest, wide_vectype);\n+      vec_dest2 = vect_create_destination_var (scalar_dest, wide_vectype);\n+      vec_dest3 = vect_create_destination_var (scalar_dest, vectype);\n+      vec_dest4 = vect_create_destination_var (scalar_dest, vectype);\n+      perm_mask = vect_gen_perm_mask (vectype, sel);\n+    }\n+  else\n+    vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n   /* Allocate VECs for vector operands.  In case of SLP, vector operands are\n      created in the previous stages of the recursion, so no allocation is\n@@ -3606,6 +3688,66 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t  ? VEC_index (tree, vec_oprnds1, i) : NULL_TREE);\n \t  vop2 = ((op_type == ternary_op)\n \t\t  ? VEC_index (tree, vec_oprnds2, i) : NULL_TREE);\n+\t  if (wide_vectype)\n+\t    {\n+\t      tree new_temp2, vce;\n+\n+\t      gcc_assert (code == MULT_HIGHPART_EXPR);\n+\t      if (decl1 != NULL_TREE)\n+\t\t{\n+\t\t  new_stmt = gimple_build_call (decl1, 2, vop0, vop1);\n+\t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t\t  gimple_call_set_lhs (new_stmt, new_temp);\n+\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\n+\t\t  new_stmt = gimple_build_call (decl2, 2, vop0, vop1);\n+\t\t  new_temp2 = make_ssa_name (vec_dest2, new_stmt);\n+\t\t  gimple_call_set_lhs (new_stmt, new_temp2);\n+\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  new_temp = make_ssa_name (vec_dest, NULL);\n+\t\t  new_stmt\n+\t\t    = gimple_build_assign_with_ops (BYTES_BIG_ENDIAN\n+\t\t\t\t\t\t    ? VEC_WIDEN_MULT_HI_EXPR\n+\t\t\t\t\t\t    : VEC_WIDEN_MULT_LO_EXPR,\n+\t\t\t\t\t\t    new_temp, vop0, vop1);\n+\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\n+\t\t  new_temp2 = make_ssa_name (vec_dest2, NULL);\n+\t\t  new_stmt\n+\t\t    = gimple_build_assign_with_ops (BYTES_BIG_ENDIAN\n+\t\t\t\t\t\t    ? VEC_WIDEN_MULT_LO_EXPR\n+\t\t\t\t\t\t    : VEC_WIDEN_MULT_HI_EXPR,\n+\t\t\t\t\t\t    new_temp2, vop0, vop1);\n+\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t}\n+\n+\t      vce = build1 (VIEW_CONVERT_EXPR, vectype, new_temp);\n+\t      new_stmt = gimple_build_assign_with_ops (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t       vec_dest3, vce,\n+\t\t\t\t\t\t       NULL_TREE);\n+\t      new_temp = make_ssa_name (vec_dest3, new_stmt);\n+\t      gimple_assign_set_lhs (new_stmt, new_temp);\n+\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\n+\t      vce = build1 (VIEW_CONVERT_EXPR, vectype, new_temp2);\n+\t      new_stmt = gimple_build_assign_with_ops (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t       vec_dest4, vce,\n+\t\t\t\t\t\t       NULL_TREE);\n+\t      new_temp2 = make_ssa_name (vec_dest4, new_stmt);\n+\t      gimple_assign_set_lhs (new_stmt, new_temp2);\n+\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\n+\t      new_temp = permute_vec_elements (new_temp, new_temp2,\n+\t\t\t\t\t       perm_mask, stmt, gsi);\n+\t      new_stmt = SSA_NAME_DEF_STMT (new_temp);\n+\t      if (slp_node)\n+\t\tVEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node),\n+\t\t\t\tnew_stmt);\n+\t      continue;\n+\t    }\n \t  new_stmt = gimple_build_assign_with_ops3 (code, vec_dest,\n \t\t\t\t\t\t    vop0, vop1, vop2);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);"}]}