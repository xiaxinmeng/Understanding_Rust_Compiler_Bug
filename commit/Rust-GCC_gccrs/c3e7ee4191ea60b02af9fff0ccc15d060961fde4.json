{"sha": "c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNlN2VlNDE5MWVhNjBiMDJhZjlmZmYwY2NjMTVkMDYwOTYxZmRlNA==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2012-07-13T11:12:33Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-07-13T11:12:33Z"}, "message": "tm.texi: Regenerate.\n\n2012-07-13  Bill Schmidt  <wschmidt@linux.ibm.com>\n\n\t* doc/tm.texi: Regenerate.\n\t* doc/tm.texi.in (TARGET_VECTORIZE_INIT_COST): New hook.\n\t(TARGET_VECTORIZE_ADD_STMT_COST): Likewise.\n\t(TARGET_VECTORIZE_FINISH_COST): Likewise.\n\t(TARGET_VECTORIZE_DESTROY_COST_DATA): Likewise.\n\t* targhooks.c (default_init_cost): New function.\n\t(default_add_stmt_cost): Likewise.\n\t(default_finish_cost): Likewise.\n\t(default_destroy_cost_data): Likewise.\n\t* targhooks.h (default_init_cost): New decl.\n\t(default_add_stmt_cost): Likewise.\n\t(default_finish_cost): Likewise.\n\t(default_destroy_cost_data): Likewise.\n\t* target.def (init_cost): New DEFHOOK.\n\t(add_stmt_cost): Likewise.\n\t(finish_cost): Likewise.\n\t(destroy_cost_data): Likewise.\n\t* target.h (struct _stmt_vec_info): New extern decl.\n\t(stmt_vectype): Likewise.\n\t(stmt_in_inner_loop_p): Likewise.\n\t* tree-vectorizer.h (stmt_info_for_cost): New struct/typedef.\n\t(stmt_vector_for_cost): New VEC/typedef.\n\t(add_stmt_info_to_vec): New function.\n\t(struct _slp_tree): Remove cost.inside_of_loop field.\n\t(struct _slp_instance): Remove cost.inside_of_loop field; add\n\tstmt_cost_vec field.\n\t(SLP_INSTANCE_INSIDE_OF_LOOP_COST): Remove macro.\n\t(SLP_INSTANCE_STMT_COST_VEC): New accessor macro.\n\t(SLP_TREE_INSIDE_OF_LOOP_COST): Remove macro.\n\t(struct _vect_peel_extended_info): Add stmt_cost_vec field.\n\t(struct _loop_vec_info): Add target_cost_data field.\n\t(LOOP_VINFO_TARGET_COST_DATA): New accessor macro.\n\t(struct _bb_vec_info): Add target_cost_data field.\n\t(BB_VINFO_TARGET_COST_DATA): New accessor macro.\n\t(struct _stmt_vec_info): Remove cost.inside_of_loop field.\n\t(STMT_VINFO_INSIDE_OF_LOOP_COST): Remove macro.\n\t(stmt_vinfo_set_inside_of_loop_cost): Remove function.\n\t(init_cost): New function.\n\t(add_stmt_cost): Likewise.\n\t(finish_cost): Likewise.\n\t(destroy_cost_data): Likewise.\n\t(vect_model_simple_cost): Change parameter list.\n\t(vect_model_store_cost): Likewise.\n\t(vect_model_load_cost): Likewise.\n\t(record_stmt_cost): New extern decl.\n\t(vect_get_load_cost): Change parameter list.\n\t(vect_get_store_cost): Likewise.\n\t* tree-vect-loop.c (new_loop_vec_info): Call init_cost.\n\t(destroy_loop_vec_info): Call destroy_cost_data.\n\t(vect_estimate_min_profitable_iters): Remove old calculation of\n\tinside costs; call finish_cost instead.\n\t(vect_model_reduction_cost): Call add_stmt_cost instead of old\n\tinside-costs calculation.\n\t(vect_model_induction_cost): Likewise.\n\t* tree-vect-data-refs.c (vect_get_data_access_cost): Change to\n\treturn a stmt_vector_for_cost; modify calls to vect_get_load_cost\n\tand vect_get_store_cost to obtain the value to return.\n\t(vect_peeling_hash_get_lowest_cost): Obtain a stmt_cost_vec from\n\tvect_get_data_access_cost and store it in the minimum peeling\n\tstructure.\n\t(vect_peeling_hash_choose_best_peeling): Change the parameter list\n\tto add a (stmt_vector_for_cost *) output parameter, and set its value.\n\t(vect_enhance_data_refs_alignment): Ignore the new return value from\n\tcalls to vect_get_data_access_cost; obtain stmt_cost_vec from\n\tvect_peeling_hash_choose_best_peeling and pass its contents to the\n\ttarget cost model.\n\t* tree-vect-stmts.c (stmt_vectype): New function.\n\t(stmt_in_inner_loop_p): Likewise.\n\t(record_stmt_cost): Likewise.\n\t(vect_model_simple_cost): Add stmt_cost_vec parameter; call\n\trecord_stmt_cost instead of old calculation; don't call\n\tstmt_vinfo_set_inside_of_loop_cost.\n\t(vect_model_promotion_demotion_cost): Call add_stmt_cost instead of\n\told calculation; don't call stmt_vinfo_set_inside_of_loop_cost.\n\t(vect_model_store_cost): Add stmt_cost_vec parameter; call\n\trecord_stmt_cost instead of old calculation; add stmt_cost_vec\n\tparameter to vect_get_store_cost call; don't call\n\tstmt_vinfo_set_inside_of_loop_cost.\n\t(vect_get_store_cost): Add stmt_cost_vec parameter; call\n\trecord_stmt_cost instead of old calculation.\n\t(vect_model_load_cost): Add stmt_cost_vec parameter; call\n\trecord_stmt_cost instead of old calculation; add stmt_cost_vec\n\tparameter to vect_get_load_cost call; don't call\n\tstmt_vinfo_set_inside_of_loop_cost.\n\t(vect_get_load_cost): Add stmt_cost_vec parameter; call\n\trecord_stmt_cost instead of old calculation.\n\t(vectorizable_call): Add NULL parameter to vect_model_simple_cost call.\n\t(vectorizable_conversion): Likewise.\n\t(vectorizable_assignment): Likewise.\n\t(vectorizable_shift): Likewise.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_store): Add NULL parameter to vect_model_store_cost call.\n\t(vectorizable_load): Add NULL parameter to vect_model_load_cost call.\n\t(new_stmt_vec_info): Don't set STMT_VINFO_INSIDE_OF_LOOP_COST.\n\t* config/spu/spu.c (TARGET_VECTORIZE_INIT_COST): New macro def.\n\t(TARGET_VECTORIZE_ADD_STMT_COST): Likewise.\n\t(TARGET_VECTORIZE_FINISH_COST): Likewise.\n\t(TARGET_VECTORIZE_DESTROY_COST_DATA): Likewise.\n\t(spu_init_cost): New function.\n\t(spu_add_stmt_cost): Likewise.\n\t(spu_finish_cost): Likewise.\n\t(spu_destroy_cost_data): Likewise.\n\t* config/i386/i386.c (ix86_init_cost): New function.\n\t(ix86_add_stmt_cost): Likewise.\n\t(ix86_finish_cost): Likewise.\n\t(ix86_destroy_cost_data): Likewise.\n\t(TARGET_VECTORIZE_INIT_COST): New macro def.\n\t(TARGET_VECTORIZE_ADD_STMT_COST): Likewise.\n\t(TARGET_VECTORIZE_FINISH_COST): Likewise.\n\t(TARGET_VECTORIZE_DESTROY_COST_DATA): Likewise.\n\t* config/rs6000/rs6000.c (TARGET_VECTORIZE_INIT_COST): New macro def.\n\t(TARGET_VECTORIZE_ADD_STMT_COST): Likewise.\n\t(TARGET_VECTORIZE_FINISH_COST): Likewise.\n\t(TARGET_VECTORIZE_DESTROY_COST_DATA): Likewise.\n\t(rs6000_init_cost): New function.\n\t(rs6000_add_stmt_cost): Likewise.\n\t(rs6000_finish_cost): Likewise.\n\t(rs6000_destroy_cost_data): Likewise.\n\t* tree-vect-slp.c (vect_free_slp_instance): Free stmt_cost_vec.\n\t(vect_create_new_slp_node): Don't set SLP_TREE_INSIDE_OF_LOOP_COST.\n\t(vect_get_and_check_slp_defs): Add stmt_cost_vec parameter; add\n\tstmt_cost_vec parameter to vect_model_store_cost and\n\tvect_model_simple_cost calls.\n\t(vect_build_slp_tree): Remove inside_cost parameter; add stmt_cost_vec\n\tparameter; add stmt_cost_vec parameter to vect_get_and_check_slp_defs,\n\tvect_model_load_cost, and recursive vect_build_slp_tree calls; prevent\n\tcalculating cost more than once for loads; remove inside_cost\n\tparameter from recursive vect_build_slp_tree calls; call\n\trecord_stmt_cost instead of old calculation.\n\t(vect_analyze_slp_instance): Allocate stmt_cost_vec and save it with\n\tthe instance; free it on premature exit; remove inside_cost parameter\n\tfrom vect_build_slp_tree call; add stmt_cost_vec parameter to\n\tvect_build_slp_tree call; don't set SLP_INSTANCE_INSIDE_OF_LOOP_COST.\n\t(new_bb_vec_info): Call init_cost.\n\t(destroy_bb_vec_info): Call destroy_cost_data.\n\t(vect_bb_vectorization_profitable_p): Call add_stmt_cost for each\n\tstatement recorded with an SLP instance; call finish_cost instead of\n\tthe old calculation.\n\t(vect_update_slp_costs_according_to_vf): Record statement costs from\n\tSLP instances, multiplying by the appropriate number of copies; don't\n\tupdate SLP_INSTANCE_INSIDE_OF_LOOP_COST.\n\nFrom-SVN: r189460", "tree": {"sha": "53ffe7a4bc3844bca9190acaf1ea9eee86512108", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53ffe7a4bc3844bca9190acaf1ea9eee86512108"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/comments", "author": null, "committer": null, "parents": [{"sha": "44fabee4e252d91ea09daf23f7dd1cce3f63abea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44fabee4e252d91ea09daf23f7dd1cce3f63abea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44fabee4e252d91ea09daf23f7dd1cce3f63abea"}], "stats": {"total": 986, "additions": 826, "deletions": 160}, "files": [{"sha": "e900a2acaae4eccb89ea919269c4278c05a34f81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "patch": "@@ -1,3 +1,147 @@\n+2012-07-13  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\t* doc/tm.texi: Regenerate.\n+\t* doc/tm.texi.in (TARGET_VECTORIZE_INIT_COST): New hook.\n+\t(TARGET_VECTORIZE_ADD_STMT_COST): Likewise.\n+\t(TARGET_VECTORIZE_FINISH_COST): Likewise.\n+\t(TARGET_VECTORIZE_DESTROY_COST_DATA): Likewise.\n+\t* targhooks.c (default_init_cost): New function.\n+\t(default_add_stmt_cost): Likewise.\n+\t(default_finish_cost): Likewise.\n+\t(default_destroy_cost_data): Likewise.\n+\t* targhooks.h (default_init_cost): New decl.\n+\t(default_add_stmt_cost): Likewise.\n+\t(default_finish_cost): Likewise.\n+\t(default_destroy_cost_data): Likewise.\n+\t* target.def (init_cost): New DEFHOOK.\n+\t(add_stmt_cost): Likewise.\n+\t(finish_cost): Likewise.\n+\t(destroy_cost_data): Likewise.\n+\t* target.h (struct _stmt_vec_info): New extern decl.\n+\t(stmt_vectype): Likewise.\n+\t(stmt_in_inner_loop_p): Likewise.\n+\t* tree-vectorizer.h (stmt_info_for_cost): New struct/typedef.\n+\t(stmt_vector_for_cost): New VEC/typedef.\n+\t(add_stmt_info_to_vec): New function.\n+\t(struct _slp_tree): Remove cost.inside_of_loop field.\n+\t(struct _slp_instance): Remove cost.inside_of_loop field; add\n+\tstmt_cost_vec field.\n+\t(SLP_INSTANCE_INSIDE_OF_LOOP_COST): Remove macro.\n+\t(SLP_INSTANCE_STMT_COST_VEC): New accessor macro.\n+\t(SLP_TREE_INSIDE_OF_LOOP_COST): Remove macro.\n+\t(struct _vect_peel_extended_info): Add stmt_cost_vec field.\n+\t(struct _loop_vec_info): Add target_cost_data field.\n+\t(LOOP_VINFO_TARGET_COST_DATA): New accessor macro.\n+\t(struct _bb_vec_info): Add target_cost_data field.\n+\t(BB_VINFO_TARGET_COST_DATA): New accessor macro.\n+\t(struct _stmt_vec_info): Remove cost.inside_of_loop field.\n+\t(STMT_VINFO_INSIDE_OF_LOOP_COST): Remove macro.\n+\t(stmt_vinfo_set_inside_of_loop_cost): Remove function.\n+\t(init_cost): New function.\n+\t(add_stmt_cost): Likewise.\n+\t(finish_cost): Likewise.\n+\t(destroy_cost_data): Likewise.\n+\t(vect_model_simple_cost): Change parameter list.\n+\t(vect_model_store_cost): Likewise.\n+\t(vect_model_load_cost): Likewise.\n+\t(record_stmt_cost): New extern decl.\n+\t(vect_get_load_cost): Change parameter list.\n+\t(vect_get_store_cost): Likewise.\n+\t* tree-vect-loop.c (new_loop_vec_info): Call init_cost.\n+\t(destroy_loop_vec_info): Call destroy_cost_data.\n+\t(vect_estimate_min_profitable_iters): Remove old calculation of\n+\tinside costs; call finish_cost instead.\n+\t(vect_model_reduction_cost): Call add_stmt_cost instead of old\n+\tinside-costs calculation.\n+\t(vect_model_induction_cost): Likewise.\n+\t* tree-vect-data-refs.c (vect_get_data_access_cost): Change to\n+\treturn a stmt_vector_for_cost; modify calls to vect_get_load_cost\n+\tand vect_get_store_cost to obtain the value to return.\n+\t(vect_peeling_hash_get_lowest_cost): Obtain a stmt_cost_vec from\n+\tvect_get_data_access_cost and store it in the minimum peeling\n+\tstructure.\n+\t(vect_peeling_hash_choose_best_peeling): Change the parameter list\n+\tto add a (stmt_vector_for_cost *) output parameter, and set its value.\n+\t(vect_enhance_data_refs_alignment): Ignore the new return value from\n+\tcalls to vect_get_data_access_cost; obtain stmt_cost_vec from\n+\tvect_peeling_hash_choose_best_peeling and pass its contents to the\n+\ttarget cost model.\n+\t* tree-vect-stmts.c (stmt_vectype): New function.\n+\t(stmt_in_inner_loop_p): Likewise.\n+\t(record_stmt_cost): Likewise.\n+\t(vect_model_simple_cost): Add stmt_cost_vec parameter; call\n+\trecord_stmt_cost instead of old calculation; don't call\n+\tstmt_vinfo_set_inside_of_loop_cost.\n+\t(vect_model_promotion_demotion_cost): Call add_stmt_cost instead of\n+\told calculation; don't call stmt_vinfo_set_inside_of_loop_cost.\n+\t(vect_model_store_cost): Add stmt_cost_vec parameter; call\n+\trecord_stmt_cost instead of old calculation; add stmt_cost_vec\n+\tparameter to vect_get_store_cost call; don't call\n+\tstmt_vinfo_set_inside_of_loop_cost.\n+\t(vect_get_store_cost): Add stmt_cost_vec parameter; call\n+\trecord_stmt_cost instead of old calculation.\n+\t(vect_model_load_cost): Add stmt_cost_vec parameter; call\n+\trecord_stmt_cost instead of old calculation; add stmt_cost_vec\n+\tparameter to vect_get_load_cost call; don't call\n+\tstmt_vinfo_set_inside_of_loop_cost.\n+\t(vect_get_load_cost): Add stmt_cost_vec parameter; call\n+\trecord_stmt_cost instead of old calculation.\n+\t(vectorizable_call): Add NULL parameter to vect_model_simple_cost call.\n+\t(vectorizable_conversion): Likewise.\n+\t(vectorizable_assignment): Likewise.\n+\t(vectorizable_shift): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_store): Add NULL parameter to vect_model_store_cost call.\n+\t(vectorizable_load): Add NULL parameter to vect_model_load_cost call.\n+\t(new_stmt_vec_info): Don't set STMT_VINFO_INSIDE_OF_LOOP_COST.\n+\t* config/spu/spu.c (TARGET_VECTORIZE_INIT_COST): New macro def.\n+\t(TARGET_VECTORIZE_ADD_STMT_COST): Likewise.\n+\t(TARGET_VECTORIZE_FINISH_COST): Likewise.\n+\t(TARGET_VECTORIZE_DESTROY_COST_DATA): Likewise.\n+\t(spu_init_cost): New function.\n+\t(spu_add_stmt_cost): Likewise.\n+\t(spu_finish_cost): Likewise.\n+\t(spu_destroy_cost_data): Likewise.\n+\t* config/i386/i386.c (ix86_init_cost): New function.\n+\t(ix86_add_stmt_cost): Likewise.\n+\t(ix86_finish_cost): Likewise.\n+\t(ix86_destroy_cost_data): Likewise.\n+\t(TARGET_VECTORIZE_INIT_COST): New macro def.\n+\t(TARGET_VECTORIZE_ADD_STMT_COST): Likewise.\n+\t(TARGET_VECTORIZE_FINISH_COST): Likewise.\n+\t(TARGET_VECTORIZE_DESTROY_COST_DATA): Likewise.\n+\t* config/rs6000/rs6000.c (TARGET_VECTORIZE_INIT_COST): New macro def.\n+\t(TARGET_VECTORIZE_ADD_STMT_COST): Likewise.\n+\t(TARGET_VECTORIZE_FINISH_COST): Likewise.\n+\t(TARGET_VECTORIZE_DESTROY_COST_DATA): Likewise.\n+\t(rs6000_init_cost): New function.\n+\t(rs6000_add_stmt_cost): Likewise.\n+\t(rs6000_finish_cost): Likewise.\n+\t(rs6000_destroy_cost_data): Likewise.\n+\t* tree-vect-slp.c (vect_free_slp_instance): Free stmt_cost_vec.\n+\t(vect_create_new_slp_node): Don't set SLP_TREE_INSIDE_OF_LOOP_COST.\n+\t(vect_get_and_check_slp_defs): Add stmt_cost_vec parameter; add\n+\tstmt_cost_vec parameter to vect_model_store_cost and\n+\tvect_model_simple_cost calls.\n+\t(vect_build_slp_tree): Remove inside_cost parameter; add stmt_cost_vec\n+\tparameter; add stmt_cost_vec parameter to vect_get_and_check_slp_defs,\n+\tvect_model_load_cost, and recursive vect_build_slp_tree calls; prevent\n+\tcalculating cost more than once for loads; remove inside_cost\n+\tparameter from recursive vect_build_slp_tree calls; call\n+\trecord_stmt_cost instead of old calculation.\n+\t(vect_analyze_slp_instance): Allocate stmt_cost_vec and save it with\n+\tthe instance; free it on premature exit; remove inside_cost parameter\n+\tfrom vect_build_slp_tree call; add stmt_cost_vec parameter to\n+\tvect_build_slp_tree call; don't set SLP_INSTANCE_INSIDE_OF_LOOP_COST.\n+\t(new_bb_vec_info): Call init_cost.\n+\t(destroy_bb_vec_info): Call destroy_cost_data.\n+\t(vect_bb_vectorization_profitable_p): Call add_stmt_cost for each\n+\tstatement recorded with an SLP instance; call finish_cost instead of\n+\tthe old calculation.\n+\t(vect_update_slp_costs_according_to_vf): Record statement costs from\n+\tSLP instances, multiplying by the appropriate number of copies; don't\n+\tupdate SLP_INSTANCE_INSIDE_OF_LOOP_COST.\n+\n 2012-07-13  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/53937"}, {"sha": "d8e88ab2f71a35706ce8fa69b626bdc8e2fd37de", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "patch": "@@ -40064,6 +40064,59 @@ ix86_autovectorize_vector_sizes (void)\n   return (TARGET_AVX && !TARGET_PREFER_AVX128) ? 32 | 16 : 0;\n }\n \n+/* Implement targetm.vectorize.init_cost.  */\n+\n+void *\n+ix86_init_cost (struct loop *loop_info ATTRIBUTE_UNUSED)\n+{\n+  unsigned *cost = XNEW (unsigned);\n+  *cost = 0;\n+  return cost;\n+}\n+\n+/* Implement targetm.vectorize.add_stmt_cost.  */\n+\n+unsigned\n+ix86_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n+\t\t    struct _stmt_vec_info *stmt_info, int misalign)\n+{\n+  unsigned *cost = (unsigned *) data;\n+  unsigned retval = 0;\n+\n+  if (flag_vect_cost_model)\n+    {\n+      tree vectype = stmt_vectype (stmt_info);\n+      int stmt_cost = ix86_builtin_vectorization_cost (kind, vectype, misalign);\n+\n+      /* Statements in an inner loop relative to the loop being\n+\t vectorized are weighted more heavily.  The value here is\n+\t arbitrary and could potentially be improved with analysis.  */\n+      if (stmt_in_inner_loop_p (stmt_info))\n+\tcount *= 50;  /* FIXME.  */\n+\n+      retval = (unsigned) (count * stmt_cost);\n+      *cost += retval;\n+    }\n+\n+  return retval;\n+}\n+\n+/* Implement targetm.vectorize.finish_cost.  */\n+\n+unsigned\n+ix86_finish_cost (void *data)\n+{\n+  return *((unsigned *) data);\n+}\n+\n+/* Implement targetm.vectorize.destroy_cost_data.  */\n+\n+void\n+ix86_destroy_cost_data (void *data)\n+{\n+  free (data);\n+}\n+\n /* Validate target specific memory model bits in VAL. */\n \n static unsigned HOST_WIDE_INT\n@@ -40369,6 +40422,14 @@ ix86_memmodel_check (unsigned HOST_WIDE_INT val)\n #undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES\n #define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES \\\n   ix86_autovectorize_vector_sizes\n+#undef TARGET_VECTORIZE_INIT_COST\n+#define TARGET_VECTORIZE_INIT_COST ix86_init_cost\n+#undef TARGET_VECTORIZE_ADD_STMT_COST\n+#define TARGET_VECTORIZE_ADD_STMT_COST ix86_add_stmt_cost\n+#undef TARGET_VECTORIZE_FINISH_COST\n+#define TARGET_VECTORIZE_FINISH_COST ix86_finish_cost\n+#undef TARGET_VECTORIZE_DESTROY_COST_DATA\n+#define TARGET_VECTORIZE_DESTROY_COST_DATA ix86_destroy_cost_data\n \n #undef TARGET_SET_CURRENT_FUNCTION\n #define TARGET_SET_CURRENT_FUNCTION ix86_set_current_function"}, {"sha": "f37972cdb73a0d648921987c7b12b09a687b7b06", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "patch": "@@ -1284,6 +1284,14 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_VECTORIZE_PREFERRED_SIMD_MODE\n #define TARGET_VECTORIZE_PREFERRED_SIMD_MODE \\\n   rs6000_preferred_simd_mode\n+#undef TARGET_VECTORIZE_INIT_COST\n+#define TARGET_VECTORIZE_INIT_COST rs6000_init_cost\n+#undef TARGET_VECTORIZE_ADD_STMT_COST\n+#define TARGET_VECTORIZE_ADD_STMT_COST rs6000_add_stmt_cost\n+#undef TARGET_VECTORIZE_FINISH_COST\n+#define TARGET_VECTORIZE_FINISH_COST rs6000_finish_cost\n+#undef TARGET_VECTORIZE_DESTROY_COST_DATA\n+#define TARGET_VECTORIZE_DESTROY_COST_DATA rs6000_destroy_cost_data\n \n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS rs6000_init_builtins\n@@ -3512,6 +3520,59 @@ rs6000_preferred_simd_mode (enum machine_mode mode)\n   return word_mode;\n }\n \n+/* Implement targetm.vectorize.init_cost.  */\n+\n+void *\n+rs6000_init_cost (struct loop *loop_info ATTRIBUTE_UNUSED)\n+{\n+  unsigned *cost = XNEW (unsigned);\n+  *cost = 0;\n+  return cost;\n+}\n+\n+/* Implement targetm.vectorize.add_stmt_cost.  */\n+\n+unsigned\n+rs6000_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n+\t\t      struct _stmt_vec_info *stmt_info, int misalign)\n+{\n+  unsigned *cost = (unsigned *) data;\n+  unsigned retval = 0;\n+\n+  if (flag_vect_cost_model)\n+    {\n+      tree vectype = stmt_vectype (stmt_info);\n+      int stmt_cost = rs6000_builtin_vectorization_cost (kind, vectype,\n+\t\t\t\t\t\t\t misalign);\n+      /* Statements in an inner loop relative to the loop being\n+\t vectorized are weighted more heavily.  The value here is\n+\t arbitrary and could potentially be improved with analysis.  */\n+      if (stmt_in_inner_loop_p (stmt_info))\n+\tcount *= 50;  /* FIXME.  */\n+\n+      retval = (unsigned) (count * stmt_cost);\n+      *cost += retval;\n+    }\n+\n+  return retval;\n+}\n+\n+/* Implement targetm.vectorize.finish_cost.  */\n+\n+unsigned\n+rs6000_finish_cost (void *data)\n+{\n+  return *((unsigned *) data);\n+}\n+\n+/* Implement targetm.vectorize.destroy_cost_data.  */\n+\n+void\n+rs6000_destroy_cost_data (void *data)\n+{\n+  free (data);\n+}\n+\n /* Handler for the Mathematical Acceleration Subsystem (mass) interface to a\n    library with vectorized intrinsics.  */\n "}, {"sha": "e10eb5faddd0f869bd786cc042b5e8184185bcdf", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "patch": "@@ -435,6 +435,18 @@ static void spu_setup_incoming_varargs (cumulative_args_t cum,\n #undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST spu_builtin_vectorization_cost\n \n+#undef TARGET_VECTORIZE_INIT_COST\n+#define TARGET_VECTORIZE_INIT_COST spu_init_cost\n+\n+#undef TARGET_VECTORIZE_ADD_STMT_COST\n+#define TARGET_VECTORIZE_ADD_STMT_COST spu_add_stmt_cost\n+\n+#undef TARGET_VECTORIZE_FINISH_COST\n+#define TARGET_VECTORIZE_FINISH_COST spu_finish_cost\n+\n+#undef TARGET_VECTORIZE_DESTROY_COST_DATA\n+#define TARGET_VECTORIZE_DESTROY_COST_DATA spu_destroy_cost_data\n+\n #undef TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE\n #define TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE spu_vector_alignment_reachable\n \n@@ -6905,6 +6917,59 @@ spu_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n     }\n }\n \n+/* Implement targetm.vectorize.init_cost.  */\n+\n+void *\n+spu_init_cost (struct loop *loop_info ATTRIBUTE_UNUSED)\n+{\n+  unsigned *cost = XNEW (unsigned);\n+  *cost = 0;\n+  return cost;\n+}\n+\n+/* Implement targetm.vectorize.add_stmt_cost.  */\n+\n+unsigned\n+spu_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n+\t\t   struct _stmt_vec_info *stmt_info, int misalign)\n+{\n+  unsigned *cost = (unsigned *) data;\n+  unsigned retval = 0;\n+\n+  if (flag_vect_cost_model)\n+    {\n+      tree vectype = stmt_vectype (stmt_info);\n+      int stmt_cost = spu_builtin_vectorization_cost (kind, vectype, misalign);\n+\n+      /* Statements in an inner loop relative to the loop being\n+\t vectorized are weighted more heavily.  The value here is\n+\t arbitrary and could potentially be improved with analysis.  */\n+      if (stmt_in_inner_loop_p (stmt_info))\n+\tcount *= 50;  /* FIXME.  */\n+\n+      retval = (unsigned) (count * stmt_cost);\n+      *cost += retval;\n+    }\n+\n+  return retval;\n+}\n+\n+/* Implement targetm.vectorize.finish_cost.  */\n+\n+unsigned\n+spu_finish_cost (void *data)\n+{\n+  return *((unsigned *) data);\n+}\n+\n+/* Implement targetm.vectorize.destroy_cost_data.  */\n+\n+void\n+spu_destroy_cost_data (void *data)\n+{\n+  free (data);\n+}\n+\n /* Return true iff, data reference of TYPE can reach vector alignment (16)\n    after applying N number of iterations.  This routine does not determine\n    how may iterations are required to reach desired alignment.  */"}, {"sha": "0208b02125ad7e27c171e36ab0f86dc2950556e3", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "patch": "@@ -5770,6 +5770,22 @@ mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}.\n The default is zero which means to not iterate over other vector sizes.\n @end deftypefn\n \n+@deftypefn {Target Hook} {void *} TARGET_VECTORIZE_INIT_COST (struct loop *@var{loop_info})\n+This hook should initialize target-specific data structures in preparation for modeling the costs of vectorizing a loop or basic block.  The default allocates an unsigned integer for accumulating a single cost.  If @var{loop_info} is non-NULL, it identifies the loop being vectorized; otherwise a single block is being vectorized.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} unsigned TARGET_VECTORIZE_ADD_STMT_COST (void *@var{data}, int @var{count}, enum vect_cost_for_stmt @var{kind}, struct _stmt_vec_info *@var{stmt_info}, int @var{misalign})\n+This hook should update the target-specific @var{data} in response to adding @var{count} copies of the given @var{kind} of statement to the body of a loop or basic block.  The default adds the builtin vectorizer cost for the copies of the statement to the accumulator, and returns the amount added.  The return value should be viewed as a tentative cost that may later be overridden.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} unsigned TARGET_VECTORIZE_FINISH_COST (void *@var{data})\n+This hook should complete calculations of the cost of vectorizing a loop or basic block based on @var{data}, and return that cost as an unsigned integer.  The default returns the value of the accumulator.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_VECTORIZE_DESTROY_COST_DATA (void *@var{data})\n+This hook should release @var{data} and any related data structures allocated by TARGET_VECTORIZE_INIT_COST.  The default releases the accumulator.\n+@end deftypefn\n+\n @deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_TM_LOAD (tree)\n This hook should return the built-in decl needed to load a vector of the given type within a transaction.\n @end deftypefn"}, {"sha": "044b416b332d922fd5efd245cf8f3c5d0c8ea884", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "patch": "@@ -5702,6 +5702,14 @@ mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}.\n The default is zero which means to not iterate over other vector sizes.\n @end deftypefn\n \n+@hook TARGET_VECTORIZE_INIT_COST\n+\n+@hook TARGET_VECTORIZE_ADD_STMT_COST\n+\n+@hook TARGET_VECTORIZE_FINISH_COST\n+\n+@hook TARGET_VECTORIZE_DESTROY_COST_DATA\n+\n @hook TARGET_VECTORIZE_BUILTIN_TM_LOAD\n \n @hook TARGET_VECTORIZE_BUILTIN_TM_STORE"}, {"sha": "349604ad9866a8cfc4f67af684edc77c87a5789c", "filename": "gcc/target.def", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "patch": "@@ -1049,6 +1049,55 @@ DEFHOOK\n  (const_tree mem_vectype, const_tree index_type, int scale),\n  NULL)\n \n+/* Target function to initialize the cost model for a loop or block.  */\n+DEFHOOK\n+(init_cost,\n+ \"This hook should initialize target-specific data structures in preparation \"\n+ \"for modeling the costs of vectorizing a loop or basic block.  The default \"\n+ \"allocates an unsigned integer for accumulating a single cost.  \"\n+ \"If @var{loop_info} is non-NULL, it identifies the loop being vectorized; \"\n+ \"otherwise a single block is being vectorized.\",\n+ void *,\n+ (struct loop *loop_info),\n+ default_init_cost)\n+\n+/* Target function to record N statements of the given kind using the\n+   given vector type within the cost model data for the current loop\n+   or block.  */\n+DEFHOOK\n+(add_stmt_cost,\n+ \"This hook should update the target-specific @var{data} in response to \"\n+ \"adding @var{count} copies of the given @var{kind} of statement to the \"\n+ \"body of a loop or basic block.  The default adds the builtin vectorizer \"\n+ \"cost for the copies of the statement to the accumulator, and returns \"\n+ \"the amount added.  The return value should be viewed as a tentative \"\n+ \"cost that may later be overridden.\",\n+ unsigned,\n+ (void *data, int count, enum vect_cost_for_stmt kind,\n+  struct _stmt_vec_info *stmt_info, int misalign),\n+ default_add_stmt_cost)\n+\n+/* Target function to calculate the total cost of the current vectorized\n+   loop or block.  */\n+DEFHOOK\n+(finish_cost,\n+ \"This hook should complete calculations of the cost of vectorizing a loop \"\n+ \"or basic block based on @var{data}, and return that cost as an unsigned \"\n+ \"integer.  The default returns the value of the accumulator.\",\n+ unsigned,\n+ (void *data),\n+ default_finish_cost)\n+\n+/* Function to delete target-specific cost modeling data.  */\n+DEFHOOK\n+(destroy_cost_data,\n+ \"This hook should release @var{data} and any related data structures \"\n+ \"allocated by TARGET_VECTORIZE_INIT_COST.  The default releases the \"\n+ \"accumulator.\",\n+ void,\n+ (void *data),\n+ default_destroy_cost_data)\n+\n HOOK_VECTOR_END (vectorize)\n \n #undef HOOK_PREFIX"}, {"sha": "6d93e3eebcaa26321eae4a6009b5cb97b701c14e", "filename": "gcc/target.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "patch": "@@ -120,6 +120,13 @@ struct loop;\n /* This is defined in tree-ssa-alias.h.  */\n struct ao_ref_s;\n \n+/* This is defined in tree-vectorizer.h.  */\n+struct _stmt_vec_info;\n+\n+/* These are defined in tree-vect-stmts.c.  */\n+extern tree stmt_vectype (struct _stmt_vec_info *);\n+extern bool stmt_in_inner_loop_p (struct _stmt_vec_info *);\n+\n /* Assembler instructions for creating various kinds of integer object.  */\n \n struct asm_int_op"}, {"sha": "7d48bca0d2d80ced20d2258384fe219de7b2ad91", "filename": "gcc/targhooks.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "patch": "@@ -996,6 +996,64 @@ default_autovectorize_vector_sizes (void)\n   return 0;\n }\n \n+/* By default, the cost model just accumulates the inside_loop costs for\n+   a vectorized loop or block.  So allocate an unsigned int, set it to\n+   zero, and return its address.  */\n+\n+void *\n+default_init_cost (struct loop *loop_info ATTRIBUTE_UNUSED)\n+{\n+  unsigned *cost = XNEW (unsigned);\n+  *cost = 0;\n+  return cost;\n+}\n+\n+/* By default, the cost model looks up the cost of the given statement\n+   kind and mode, multiplies it by the occurrence count, accumulates\n+   it into the cost, and returns the cost added.  */\n+\n+unsigned\n+default_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n+\t\t       struct _stmt_vec_info *stmt_info, int misalign)\n+{\n+  unsigned *cost = (unsigned *) data;\n+  unsigned retval = 0;\n+\n+  if (flag_vect_cost_model)\n+    {\n+      tree vectype = stmt_vectype (stmt_info);\n+      int stmt_cost = default_builtin_vectorization_cost (kind, vectype,\n+\t\t\t\t\t\t\t  misalign);\n+      /* Statements in an inner loop relative to the loop being\n+\t vectorized are weighted more heavily.  The value here is\n+\t arbitrary and could potentially be improved with analysis.  */\n+      if (stmt_in_inner_loop_p (stmt_info))\n+\tcount *= 50;  /* FIXME.  */\n+\n+      retval = (unsigned) (count * stmt_cost);\n+      *cost += retval;\n+    }\n+\n+  return retval;\n+}\n+\n+/* By default, the cost model just returns the accumulated\n+   inside_loop cost.  */\n+\n+unsigned\n+default_finish_cost (void *data)\n+{\n+  return *((unsigned *) data);\n+}\n+\n+/* Free the cost data.  */\n+\n+void\n+default_destroy_cost_data (void *data)\n+{\n+  free (data);\n+}\n+\n /* Determine whether or not a pointer mode is valid. Assume defaults\n    of ptr_mode or Pmode - can be overridden.  */\n bool"}, {"sha": "a21efd0a87e63b3360d8ddaf603e6e2bacc9ba0a", "filename": "gcc/targhooks.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "patch": "@@ -90,6 +90,11 @@ default_builtin_support_vector_misalignment (enum machine_mode mode,\n \t\t\t\t\t     int, bool);\n extern enum machine_mode default_preferred_simd_mode (enum machine_mode mode);\n extern unsigned int default_autovectorize_vector_sizes (void);\n+extern void *default_init_cost (struct loop *);\n+extern unsigned default_add_stmt_cost (void *, int, enum vect_cost_for_stmt,\n+\t\t\t\t       struct _stmt_vec_info *, int);\n+extern unsigned default_finish_cost (void *);\n+extern void default_destroy_cost_data (void *);\n \n /* These are here, and not in hooks.[ch], because not all users of\n    hooks.h include tm.h, and thus we don't have CUMULATIVE_ARGS.  */"}, {"sha": "6d64c7bb198cbdadeb603165ae4749789204e806", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "patch": "@@ -1205,7 +1205,7 @@ vector_alignment_reachable_p (struct data_reference *dr)\n \n /* Calculate the cost of the memory access represented by DR.  */\n \n-static void\n+static stmt_vector_for_cost\n vect_get_data_access_cost (struct data_reference *dr,\n                            unsigned int *inside_cost,\n                            unsigned int *outside_cost)\n@@ -1216,15 +1216,19 @@ vect_get_data_access_cost (struct data_reference *dr,\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   int ncopies = vf / nunits;\n+  stmt_vector_for_cost stmt_cost_vec = VEC_alloc (stmt_info_for_cost, heap, 2);\n \n   if (DR_IS_READ (dr))\n-    vect_get_load_cost (dr, ncopies, true, inside_cost, outside_cost);\n+    vect_get_load_cost (dr, ncopies, true, inside_cost,\n+\t\t\toutside_cost, &stmt_cost_vec);\n   else\n-    vect_get_store_cost (dr, ncopies, inside_cost);\n+    vect_get_store_cost (dr, ncopies, inside_cost, &stmt_cost_vec);\n \n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_get_data_access_cost: inside_cost = %d, \"\n              \"outside_cost = %d.\", *inside_cost, *outside_cost);\n+\n+  return stmt_cost_vec;\n }\n \n \n@@ -1317,6 +1321,7 @@ vect_peeling_hash_get_lowest_cost (void **slot, void *data)\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   VEC (data_reference_p, heap) *datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   struct data_reference *dr;\n+  stmt_vector_for_cost stmt_cost_vec = NULL;\n \n   FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     {\n@@ -1330,7 +1335,8 @@ vect_peeling_hash_get_lowest_cost (void **slot, void *data)\n \n       save_misalignment = DR_MISALIGNMENT (dr);\n       vect_update_misalignment_for_peel (dr, elem->dr, elem->npeel);\n-      vect_get_data_access_cost (dr, &inside_cost, &outside_cost);\n+      stmt_cost_vec = vect_get_data_access_cost (dr, &inside_cost,\n+\t\t\t\t\t\t &outside_cost);\n       SET_DR_MISALIGNMENT (dr, save_misalignment);\n     }\n \n@@ -1342,6 +1348,7 @@ vect_peeling_hash_get_lowest_cost (void **slot, void *data)\n     {\n       min->inside_cost = inside_cost;\n       min->outside_cost = outside_cost;\n+      min->stmt_cost_vec = stmt_cost_vec;\n       min->peel_info.dr = elem->dr;\n       min->peel_info.npeel = elem->npeel;\n     }\n@@ -1356,11 +1363,13 @@ vect_peeling_hash_get_lowest_cost (void **slot, void *data)\n \n static struct data_reference *\n vect_peeling_hash_choose_best_peeling (loop_vec_info loop_vinfo,\n-                                       unsigned int *npeel)\n+                                       unsigned int *npeel,\n+\t\t\t\t       stmt_vector_for_cost *stmt_cost_vec)\n {\n    struct _vect_peel_extended_info res;\n \n    res.peel_info.dr = NULL;\n+   res.stmt_cost_vec = NULL;\n \n    if (flag_vect_cost_model)\n      {\n@@ -1377,6 +1386,7 @@ vect_peeling_hash_choose_best_peeling (loop_vec_info loop_vinfo,\n      }\n \n    *npeel = res.peel_info.npeel;\n+   *stmt_cost_vec = res.stmt_cost_vec;\n    return res.peel_info.dr;\n }\n \n@@ -1493,6 +1503,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   unsigned possible_npeel_number = 1;\n   tree vectype;\n   unsigned int nelements, mis, same_align_drs_max = 0;\n+  stmt_vector_for_cost stmt_cost_vec = NULL;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_enhance_data_refs_alignment ===\");\n@@ -1697,10 +1708,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           unsigned int load_inside_penalty = 0, load_outside_penalty = 0;\n           unsigned int store_inside_penalty = 0, store_outside_penalty = 0;\n \n-          vect_get_data_access_cost (dr0, &load_inside_cost,\n-                                     &load_outside_cost);\n-          vect_get_data_access_cost (first_store, &store_inside_cost,\n-                                     &store_outside_cost);\n+          (void) vect_get_data_access_cost (dr0, &load_inside_cost,\n+\t\t\t\t\t    &load_outside_cost);\n+          (void) vect_get_data_access_cost (first_store, &store_inside_cost,\n+\t\t\t\t\t    &store_outside_cost);\n \n           /* Calculate the penalty for leaving FIRST_STORE unaligned (by\n              aligning the load DR0).  */\n@@ -1764,7 +1775,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       gcc_assert (!all_misalignments_unknown);\n \n       /* Choose the best peeling from the hash table.  */\n-      dr0 = vect_peeling_hash_choose_best_peeling (loop_vinfo, &npeel);\n+      dr0 = vect_peeling_hash_choose_best_peeling (loop_vinfo, &npeel,\n+\t\t\t\t\t\t   &stmt_cost_vec);\n       if (!dr0 || !npeel)\n         do_peeling = false;\n     }\n@@ -1848,6 +1860,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n       if (do_peeling)\n         {\n+\t  stmt_info_for_cost *si;\n+\n           /* (1.2) Update the DR_MISALIGNMENT of each data reference DR_i.\n              If the misalignment of DR_i is identical to that of dr0 then set\n              DR_MISALIGNMENT (DR_i) to zero.  If the misalignment of DR_i and\n@@ -1871,6 +1885,18 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"Peeling for alignment will be applied.\");\n \n+\t  /* We've delayed passing the inside-loop peeling costs to the\n+\t     target cost model until we were sure peeling would happen.\n+\t     Do so now.  */\n+\t  if (stmt_cost_vec)\n+\t    {\n+\t      FOR_EACH_VEC_ELT (stmt_info_for_cost, stmt_cost_vec, i, si)\n+\t\t(void) add_stmt_cost (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo),\n+\t\t\t\t      si->count, si->kind,\n+\t\t\t\t      vinfo_for_stmt (si->stmt), si->misalign);\n+\t      VEC_free (stmt_info_for_cost, heap, stmt_cost_vec);\n+\t    }\n+\n \t  stat = vect_verify_datarefs_alignment (loop_vinfo, NULL);\n \t  gcc_assert (stat);\n           return stat;"}, {"sha": "4ddc9fbfe98386438f5bbd52f90ab13b4ad6bd3a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "patch": "@@ -852,6 +852,7 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_SLP_INSTANCES (res) = VEC_alloc (slp_instance, heap, 10);\n   LOOP_VINFO_SLP_UNROLLING_FACTOR (res) = 1;\n   LOOP_VINFO_PEELING_HTAB (res) = NULL;\n+  LOOP_VINFO_TARGET_COST_DATA (res) = init_cost (loop);\n   LOOP_VINFO_PEELING_FOR_GAPS (res) = false;\n \n   return res;\n@@ -929,6 +930,8 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n   if (LOOP_VINFO_PEELING_HTAB (loop_vinfo))\n     htab_delete (LOOP_VINFO_PEELING_HTAB (loop_vinfo));\n \n+  destroy_cost_data (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n+\n   free (loop_vinfo);\n   loop->aux = NULL;\n }\n@@ -1362,7 +1365,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n                            \"not vectorized: relevant phi not supported: \");\n                   print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n                 }\n-              return false;\n+\t      return false;\n             }\n         }\n \n@@ -2498,7 +2501,6 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   int nbbs = loop->num_nodes;\n   int npeel = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n   int peel_guard_costs = 0;\n-  int innerloop_iters = 0, factor;\n   VEC (slp_instance, heap) *slp_instances;\n   slp_instance instance;\n \n@@ -2544,20 +2546,11 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n      TODO: Consider assigning different costs to different scalar\n      statements.  */\n \n-  /* FORNOW.  */\n-  if (loop->inner)\n-    innerloop_iters = 50; /* FIXME */\n-\n   for (i = 0; i < nbbs; i++)\n     {\n       gimple_stmt_iterator si;\n       basic_block bb = bbs[i];\n \n-      if (bb->loop_father == loop->inner)\n- \tfactor = innerloop_iters;\n-      else\n- \tfactor = 1;\n-\n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n \t{\n \t  gimple stmt = gsi_stmt (si);\n@@ -2575,7 +2568,6 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n                  || !VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_info))))\n \t    continue;\n \n-\t  vec_inside_cost += STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) * factor;\n \t  /* FIXME: for stmts in the inner-loop in outer-loop vectorization,\n \t     some of the \"outside\" costs are generated inside the outer-loop.  */\n \t  vec_outside_cost += STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info);\n@@ -2592,14 +2584,9 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \t\t    = vinfo_for_stmt (pattern_def_stmt);\n                   if (STMT_VINFO_RELEVANT_P (pattern_def_stmt_info)\n                       || STMT_VINFO_LIVE_P (pattern_def_stmt_info))\n-\t\t    {\n-                      vec_inside_cost\n-\t\t\t+= STMT_VINFO_INSIDE_OF_LOOP_COST\n-\t\t\t   (pattern_def_stmt_info) * factor;\n-                      vec_outside_cost\n-\t\t\t+= STMT_VINFO_OUTSIDE_OF_LOOP_COST\n-\t\t\t   (pattern_def_stmt_info);\n-                    }\n+\t\t    vec_outside_cost\n+\t\t      += STMT_VINFO_OUTSIDE_OF_LOOP_COST\n+\t\t        (pattern_def_stmt_info);\n \t\t}\n \t    }\n \t}\n@@ -2725,11 +2712,12 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   /* Add SLP costs.  */\n   slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n   FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n-    {\n-      vec_outside_cost += SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (instance);\n-      vec_inside_cost += SLP_INSTANCE_INSIDE_OF_LOOP_COST (instance);\n-    }\n+    vec_outside_cost += SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (instance);\n \n+  /* Complete the target-specific cost calculation for the inside-of-loop\n+     costs.  */\n+  vec_inside_cost = finish_cost (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n+  \n   /* Calculate number of iterations required to make the vector version\n      profitable, relative to the loop bodies only.  The following condition\n      must hold true:\n@@ -2826,10 +2814,10 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n-\n   /* Cost of reduction op inside loop.  */\n-  STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) \n-    += ncopies * vect_get_stmt_cost (vector_stmt);\n+  unsigned inside_cost\n+    = add_stmt_cost (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo),\n+\t\t     ncopies, vector_stmt, stmt_info, 0);\n \n   stmt = STMT_VINFO_STMT (stmt_info);\n \n@@ -2915,7 +2903,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_model_reduction_cost: inside_cost = %d, \"\n-             \"outside_cost = %d .\", STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info),\n+             \"outside_cost = %d .\", inside_cost,\n              STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info));\n \n   return true;\n@@ -2929,16 +2917,20 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n static void\n vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n {\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+\n   /* loop cost for vec_loop.  */\n-  STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) \n-    = ncopies * vect_get_stmt_cost (vector_stmt);\n+  unsigned inside_cost\n+    = add_stmt_cost (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo), ncopies,\n+\t\t     vector_stmt, stmt_info, 0);\n+\n   /* prologue cost for vec_init and vec_step.  */\n   STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info)  \n     = 2 * vect_get_stmt_cost (scalar_to_vec);\n \n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_model_induction_cost: inside_cost = %d, \"\n-             \"outside_cost = %d .\", STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info),\n+             \"outside_cost = %d .\", inside_cost,\n              STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info));\n }\n "}, {"sha": "478343e041af263f1427cd99ba2dc33d80e6e65b", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 68, "deletions": 32, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "patch": "@@ -94,6 +94,7 @@ vect_free_slp_instance (slp_instance instance)\n   vect_free_slp_tree (SLP_INSTANCE_TREE (instance));\n   VEC_free (int, heap, SLP_INSTANCE_LOAD_PERMUTATION (instance));\n   VEC_free (slp_tree, heap, SLP_INSTANCE_LOADS (instance));\n+  VEC_free (stmt_info_for_cost, heap, SLP_INSTANCE_STMT_COST_VEC (instance));\n }\n \n \n@@ -122,7 +123,6 @@ vect_create_new_slp_node (VEC (gimple, heap) *scalar_stmts)\n   SLP_TREE_VEC_STMTS (node) = NULL;\n   SLP_TREE_CHILDREN (node) = VEC_alloc (slp_void_p, heap, nops);\n   SLP_TREE_OUTSIDE_OF_LOOP_COST (node) = 0;\n-  SLP_TREE_INSIDE_OF_LOOP_COST (node) = 0;\n \n   return node;\n }\n@@ -179,7 +179,8 @@ static bool\n vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                              slp_tree slp_node, gimple stmt,\n \t\t\t     int ncopies_for_cost, bool first,\n-                             VEC (slp_oprnd_info, heap) **oprnds_info)\n+                             VEC (slp_oprnd_info, heap) **oprnds_info,\n+\t\t\t     stmt_vector_for_cost *stmt_cost_vec)\n {\n   tree oprnd;\n   unsigned int i, number_of_oprnds;\n@@ -320,7 +321,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t      if (REFERENCE_CLASS_P (lhs))\n \t\t/* Store.  */\n                 vect_model_store_cost (stmt_info, ncopies_for_cost, false,\n-                                        dt, slp_node);\n+\t\t\t\t       dt, slp_node, stmt_cost_vec);\n \t      else\n \t\t{\n \t\t  enum vect_def_type dts[2];\n@@ -329,7 +330,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t  /* Not memory operation (we don't call this function for\n \t\t     loads).  */\n \t\t  vect_model_simple_cost (stmt_info, ncopies_for_cost, dts,\n-\t\t\t\t\t  slp_node);\n+\t\t\t\t\t  slp_node, stmt_cost_vec);\n \t\t}\n \t    }\n \t}\n@@ -446,12 +447,12 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n static bool\n vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n-                     slp_tree *node, unsigned int group_size,\n-                     int *inside_cost, int *outside_cost,\n+                     slp_tree *node, unsigned int group_size, int *outside_cost,\n                      int ncopies_for_cost, unsigned int *max_nunits,\n                      VEC (int, heap) **load_permutation,\n                      VEC (slp_tree, heap) **loads,\n-                     unsigned int vectorization_factor, bool *loads_permuted)\n+                     unsigned int vectorization_factor, bool *loads_permuted,\n+\t\t     stmt_vector_for_cost *stmt_cost_vec)\n {\n   unsigned int i;\n   VEC (gimple, heap) *stmts = SLP_TREE_SCALAR_STMTS (*node);\n@@ -470,7 +471,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   HOST_WIDE_INT dummy;\n   bool permutation = false;\n   unsigned int load_place;\n-  gimple first_load, prev_first_load = NULL;\n+  gimple first_load = NULL, prev_first_load = NULL, old_first_load = NULL;\n   VEC (slp_oprnd_info, heap) *oprnds_info;\n   unsigned int nops;\n   slp_oprnd_info oprnd_info;\n@@ -711,7 +712,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t      /* Store.  */\n \t      if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo, *node,\n \t\t\t\t\t\tstmt, ncopies_for_cost,\n-\t\t\t\t\t\t(i == 0), &oprnds_info))\n+\t\t\t\t\t\t(i == 0), &oprnds_info,\n+\t\t\t\t\t\tstmt_cost_vec))\n \t\t{\n \t  \t  vect_free_oprnd_info (&oprnds_info);\n  \t\t  return false;\n@@ -754,6 +756,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                   return false;\n                 }\n \n+\t      old_first_load = first_load;\n               first_load = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt));\n               if (prev_first_load)\n                 {\n@@ -778,7 +781,9 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               else\n                 prev_first_load = first_load;\n \n-              if (first_load == stmt)\n+\t      /* In some cases a group of loads is just the same load\n+\t\t repeated N times.  Only analyze its cost once.  */\n+              if (first_load == stmt && old_first_load != first_load)\n                 {\n                   first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n                   if (vect_supportable_dr_alignment (first_dr, false)\n@@ -797,7 +802,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n                   /* Analyze costs (for the first stmt in the group).  */\n                   vect_model_load_cost (vinfo_for_stmt (stmt),\n-                                        ncopies_for_cost, false, *node);\n+                                        ncopies_for_cost, false, *node,\n+\t\t\t\t\tstmt_cost_vec);\n                 }\n \n               /* Store the place of this load in the interleaving chain.  In\n@@ -871,7 +877,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  /* Find the def-stmts.  */\n \t  if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo, *node, stmt,\n \t\t\t\t\t    ncopies_for_cost, (i == 0),\n-\t\t\t\t\t    &oprnds_info))\n+\t\t\t\t\t    &oprnds_info, stmt_cost_vec))\n \t    {\n \t      vect_free_oprnd_info (&oprnds_info);\n \t      return false;\n@@ -880,7 +886,6 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n     }\n \n   /* Add the costs of the node to the overall instance costs.  */\n-  *inside_cost += SLP_TREE_INSIDE_OF_LOOP_COST (*node);\n   *outside_cost += SLP_TREE_OUTSIDE_OF_LOOP_COST (*node);\n \n   /* Grouped loads were reached - stop the recursion.  */\n@@ -889,11 +894,10 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       VEC_safe_push (slp_tree, heap, *loads, *node);\n       if (permutation)\n         {\n-\n+\t  gimple first_stmt = VEC_index (gimple, stmts, 0);\n           *loads_permuted = true;\n-          *inside_cost \n-            += targetm.vectorize.builtin_vectorization_cost (vec_perm, NULL, 0) \n-               * group_size;\n+\t  (void) record_stmt_cost (stmt_cost_vec, group_size, vec_perm, \n+\t\t\t\t   vinfo_for_stmt (first_stmt), 0);\n         }\n       else\n         {\n@@ -919,9 +923,10 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       child = vect_create_new_slp_node (oprnd_info->def_stmts);\n       if (!child\n           || !vect_build_slp_tree (loop_vinfo, bb_vinfo, &child, group_size,\n-\t\t\t\tinside_cost, outside_cost, ncopies_for_cost,\n-\t\t\t\tmax_nunits, load_permutation, loads,\n-\t\t\t\tvectorization_factor, loads_permuted))\n+\t\t\t\t   outside_cost, ncopies_for_cost,\n+\t\t\t\t   max_nunits, load_permutation, loads,\n+\t\t\t\t   vectorization_factor, loads_permuted,\n+\t\t\t\t   stmt_cost_vec))\n         {\n \t  if (child)\n \t    oprnd_info->def_stmts = NULL;\n@@ -1459,13 +1464,14 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   tree vectype, scalar_type = NULL_TREE;\n   gimple next;\n   unsigned int vectorization_factor = 0;\n-  int inside_cost = 0, outside_cost = 0, ncopies_for_cost, i;\n+  int outside_cost = 0, ncopies_for_cost, i;\n   unsigned int max_nunits = 0;\n   VEC (int, heap) *load_permutation;\n   VEC (slp_tree, heap) *loads;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n   bool loads_permuted = false;\n   VEC (gimple, heap) *scalar_stmts;\n+  stmt_vector_for_cost stmt_cost_vec;\n \n   if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n@@ -1551,12 +1557,14 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n   load_permutation = VEC_alloc (int, heap, group_size * group_size);\n   loads = VEC_alloc (slp_tree, heap, group_size);\n+  stmt_cost_vec = VEC_alloc (stmt_info_for_cost, heap, 10);\n \n   /* Build the tree for the SLP instance.  */\n   if (vect_build_slp_tree (loop_vinfo, bb_vinfo, &node, group_size,\n-                           &inside_cost, &outside_cost, ncopies_for_cost,\n+                           &outside_cost, ncopies_for_cost,\n \t\t\t   &max_nunits, &load_permutation, &loads,\n-\t\t\t   vectorization_factor, &loads_permuted))\n+\t\t\t   vectorization_factor, &loads_permuted,\n+\t\t\t   &stmt_cost_vec))\n     {\n       /* Calculate the unrolling factor based on the smallest type.  */\n       if (max_nunits > nunits)\n@@ -1568,6 +1576,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n           if (vect_print_dump_info (REPORT_SLP))\n             fprintf (vect_dump, \"Build SLP failed: unrolling required in basic\"\n                                \" block SLP\");\n+\t  VEC_free (stmt_info_for_cost, heap, stmt_cost_vec);\n           return false;\n         }\n \n@@ -1577,7 +1586,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       SLP_INSTANCE_GROUP_SIZE (new_instance) = group_size;\n       SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n       SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (new_instance) = outside_cost;\n-      SLP_INSTANCE_INSIDE_OF_LOOP_COST (new_instance) = inside_cost;\n+      SLP_INSTANCE_STMT_COST_VEC (new_instance) = stmt_cost_vec;\n       SLP_INSTANCE_LOADS (new_instance) = loads;\n       SLP_INSTANCE_FIRST_LOAD_STMT (new_instance) = NULL;\n       SLP_INSTANCE_LOAD_PERMUTATION (new_instance) = load_permutation;\n@@ -1617,6 +1626,8 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n       return true;\n     }\n+  else\n+    VEC_free (stmt_info_for_cost, heap, stmt_cost_vec);\n \n   /* Failed to SLP.  */\n   /* Free the allocated memory.  */\n@@ -1812,6 +1823,7 @@ new_bb_vec_info (basic_block bb)\n \n   BB_VINFO_GROUPED_STORES (res) = VEC_alloc (gimple, heap, 10);\n   BB_VINFO_SLP_INSTANCES (res) = VEC_alloc (slp_instance, heap, 2);\n+  BB_VINFO_TARGET_COST_DATA (res) = init_cost (NULL);\n \n   bb->aux = res;\n   return res;\n@@ -1846,6 +1858,7 @@ destroy_bb_vec_info (bb_vec_info bb_vinfo)\n   free_dependence_relations (BB_VINFO_DDRS (bb_vinfo));\n   VEC_free (gimple, heap, BB_VINFO_GROUPED_STORES (bb_vinfo));\n   VEC_free (slp_instance, heap, BB_VINFO_SLP_INSTANCES (bb_vinfo));\n+  destroy_cost_data (BB_VINFO_TARGET_COST_DATA (bb_vinfo));\n   free (bb_vinfo);\n   bb->aux = NULL;\n }\n@@ -1918,21 +1931,28 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n {\n   VEC (slp_instance, heap) *slp_instances = BB_VINFO_SLP_INSTANCES (bb_vinfo);\n   slp_instance instance;\n-  int i;\n-  unsigned int vec_outside_cost = 0, vec_inside_cost = 0, scalar_cost = 0;\n+  int i, j;\n+  unsigned int vec_inside_cost = 0, vec_outside_cost = 0, scalar_cost = 0;\n   unsigned int stmt_cost;\n   gimple stmt;\n   gimple_stmt_iterator si;\n   basic_block bb = BB_VINFO_BB (bb_vinfo);\n   stmt_vec_info stmt_info = NULL;\n   tree dummy_type = NULL;\n   int dummy = 0;\n+  stmt_vector_for_cost stmt_cost_vec;\n+  stmt_info_for_cost *ci;\n \n   /* Calculate vector costs.  */\n   FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n     {\n       vec_outside_cost += SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (instance);\n-      vec_inside_cost += SLP_INSTANCE_INSIDE_OF_LOOP_COST (instance);\n+      stmt_cost_vec = SLP_INSTANCE_STMT_COST_VEC (instance);\n+\n+      FOR_EACH_VEC_ELT (stmt_info_for_cost, stmt_cost_vec, j, ci)\n+\t(void) add_stmt_cost (BB_VINFO_TARGET_COST_DATA (bb_vinfo),\n+\t\t\t      ci->count, ci->kind,\n+\t\t\t      vinfo_for_stmt (ci->stmt), ci->misalign);\n     }\n \n   /* Calculate scalar cost.  */\n@@ -1961,6 +1981,9 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n       scalar_cost += stmt_cost;\n     }\n \n+  /* Complete the target-specific cost calculation.  */\n+  vec_inside_cost = finish_cost (BB_VINFO_TARGET_COST_DATA (bb_vinfo));\n+\n   if (vect_print_dump_info (REPORT_COST))\n     {\n       fprintf (vect_dump, \"Cost model analysis: \\n\");\n@@ -2072,7 +2095,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n       vect_mark_slp_stmts_relevant (SLP_INSTANCE_TREE (instance));\n     }\n \n-   if (!vect_verify_datarefs_alignment (NULL, bb_vinfo))\n+  if (!vect_verify_datarefs_alignment (NULL, bb_vinfo))\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n         fprintf (vect_dump, \"not vectorized: unsupported alignment in basic \"\n@@ -2175,17 +2198,30 @@ vect_slp_analyze_bb (basic_block bb)\n void\n vect_update_slp_costs_according_to_vf (loop_vec_info loop_vinfo)\n {\n-  unsigned int i, vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  unsigned int i, j, vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   VEC (slp_instance, heap) *slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n   slp_instance instance;\n+  stmt_vector_for_cost stmt_cost_vec;\n+  stmt_info_for_cost *si;\n \n   if (vect_print_dump_info (REPORT_SLP))\n     fprintf (vect_dump, \"=== vect_update_slp_costs_according_to_vf ===\");\n \n   FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n-    /* We assume that costs are linear in ncopies.  */\n-    SLP_INSTANCE_INSIDE_OF_LOOP_COST (instance) *= vf\n-      / SLP_INSTANCE_UNROLLING_FACTOR (instance);\n+    {\n+      /* We assume that costs are linear in ncopies.  */\n+      int ncopies = vf / SLP_INSTANCE_UNROLLING_FACTOR (instance);\n+\n+      /* Record the instance's instructions in the target cost model.\n+\t This was delayed until here because the count of instructions\n+\t isn't known beforehand.  */\n+      stmt_cost_vec = SLP_INSTANCE_STMT_COST_VEC (instance);\n+\n+      FOR_EACH_VEC_ELT (stmt_info_for_cost, stmt_cost_vec, j, si)\n+\t(void) add_stmt_cost (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo),\n+\t\t\t      si->count * ncopies, si->kind,\n+\t\t\t      vinfo_for_stmt (si->stmt), si->misalign);\n+    }\n }\n \n "}, {"sha": "19e36e013228c26e197351410b11dbaf5cdce046", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 133, "deletions": 58, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "patch": "@@ -41,6 +41,66 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n \n \n+/* Return the vectorized type for the given statement.  */\n+\n+tree\n+stmt_vectype (struct _stmt_vec_info *stmt_info)\n+{\n+  return STMT_VINFO_VECTYPE (stmt_info);\n+}\n+\n+/* Return TRUE iff the given statement is in an inner loop relative to\n+   the loop being vectorized.  */\n+bool\n+stmt_in_inner_loop_p (struct _stmt_vec_info *stmt_info)\n+{\n+  gimple stmt = STMT_VINFO_STMT (stmt_info);\n+  basic_block bb = gimple_bb (stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop* loop;\n+\n+  if (!loop_vinfo)\n+    return false;\n+\n+  loop = LOOP_VINFO_LOOP (loop_vinfo);\n+\n+  return (bb->loop_father == loop->inner);\n+}\n+\n+/* Record the cost of a statement, either by directly informing the \n+   target model or by saving it in a vector for later processing.\n+   Return a preliminary estimate of the statement's cost.  */\n+\n+unsigned\n+record_stmt_cost (stmt_vector_for_cost *stmt_cost_vec, int count,\n+\t\t  enum vect_cost_for_stmt kind, stmt_vec_info stmt_info,\n+\t\t  int misalign)\n+{\n+  if (stmt_cost_vec)\n+    {\n+      tree vectype = stmt_vectype (stmt_info);\n+      add_stmt_info_to_vec (stmt_cost_vec, count, kind,\n+\t\t\t    STMT_VINFO_STMT (stmt_info), misalign);\n+      return (unsigned)\n+\t(targetm.vectorize.builtin_vectorization_cost (kind, vectype, misalign)\n+\t * count);\n+\t \n+    }\n+  else\n+    {\n+      loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+      bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+      void *target_cost_data;\n+\n+      if (loop_vinfo)\n+\ttarget_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n+      else\n+\ttarget_cost_data = BB_VINFO_TARGET_COST_DATA (bb_vinfo);\n+\n+      return add_stmt_cost (target_cost_data, count, kind, stmt_info, misalign);\n+    }\n+}\n+\n /* Return a variable of type ELEM_TYPE[NELEMS].  */\n \n static tree\n@@ -735,7 +795,8 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \n void\n vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n-\t\t\tenum vect_def_type *dt, slp_tree slp_node)\n+\t\t\tenum vect_def_type *dt, slp_tree slp_node,\n+\t\t\tstmt_vector_for_cost *stmt_cost_vec)\n {\n   int i;\n   int inside_cost = 0, outside_cost = 0;\n@@ -744,22 +805,23 @@ vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n   if (PURE_SLP_STMT (stmt_info))\n     return;\n \n-  inside_cost = ncopies * vect_get_stmt_cost (vector_stmt); \n-\n   /* FORNOW: Assuming maximum 2 args per stmts.  */\n   for (i = 0; i < 2; i++)\n     {\n       if (dt[i] == vect_constant_def || dt[i] == vect_external_def)\n \toutside_cost += vect_get_stmt_cost (vector_stmt); \n     }\n \n+  /* Set the costs either in STMT_INFO or SLP_NODE (if exists).  */\n+  stmt_vinfo_set_outside_of_loop_cost (stmt_info, slp_node, outside_cost);\n+\n+  /* Pass the inside-of-loop statements to the target-specific cost model.  */\n+  inside_cost = record_stmt_cost (stmt_cost_vec, ncopies, vector_stmt,\n+\t\t\t\t  stmt_info, 0);\n+\n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_model_simple_cost: inside_cost = %d, \"\n              \"outside_cost = %d .\", inside_cost, outside_cost);\n-\n-  /* Set the costs either in STMT_INFO or SLP_NODE (if exists).  */\n-  stmt_vinfo_set_inside_of_loop_cost (stmt_info, slp_node, inside_cost);\n-  stmt_vinfo_set_outside_of_loop_cost (stmt_info, slp_node, outside_cost);\n }\n \n \n@@ -773,18 +835,26 @@ vect_model_promotion_demotion_cost (stmt_vec_info stmt_info,\n \t\t\t\t    enum vect_def_type *dt, int pwr)\n {\n   int i, tmp;\n-  int inside_cost = 0, outside_cost = 0, single_stmt_cost;\n+  int inside_cost = 0, outside_cost = 0;\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  void *target_cost_data;\n \n   /* The SLP costs were already calculated during SLP tree build.  */\n   if (PURE_SLP_STMT (stmt_info))\n     return;\n \n-  single_stmt_cost = vect_get_stmt_cost (vec_promote_demote);\n+  if (loop_vinfo)\n+    target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n+  else\n+    target_cost_data = BB_VINFO_TARGET_COST_DATA (bb_vinfo);\n+\n   for (i = 0; i < pwr + 1; i++)\n     {\n       tmp = (STMT_VINFO_TYPE (stmt_info) == type_promotion_vec_info_type) ?\n \t(i + 1) : i;\n-      inside_cost += vect_pow2 (tmp) * single_stmt_cost;\n+      inside_cost += add_stmt_cost (target_cost_data, vect_pow2 (tmp),\n+\t\t\t\t    vec_promote_demote, stmt_info, 0);\n     }\n \n   /* FORNOW: Assuming maximum 2 args per stmts.  */\n@@ -799,7 +869,6 @@ vect_model_promotion_demotion_cost (stmt_vec_info stmt_info,\n              \"outside_cost = %d .\", inside_cost, outside_cost);\n \n   /* Set the costs in STMT_INFO.  */\n-  stmt_vinfo_set_inside_of_loop_cost (stmt_info, NULL, inside_cost);\n   stmt_vinfo_set_outside_of_loop_cost (stmt_info, NULL, outside_cost);\n }\n \n@@ -829,7 +898,7 @@ vect_cost_group_size (stmt_vec_info stmt_info)\n void\n vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t       bool store_lanes_p, enum vect_def_type dt,\n-\t\t       slp_tree slp_node)\n+\t\t       slp_tree slp_node, stmt_vector_for_cost *stmt_cost_vec)\n {\n   int group_size;\n   unsigned int inside_cost = 0, outside_cost = 0;\n@@ -873,39 +942,44 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n   if (!store_lanes_p && group_size > 1)\n     {\n       /* Uses a high and low interleave operation for each needed permute.  */\n-      inside_cost = ncopies * exact_log2(group_size) * group_size\n-        * vect_get_stmt_cost (vec_perm);\n+      \n+      int nstmts = ncopies * exact_log2 (group_size) * group_size;\n+      inside_cost = record_stmt_cost (stmt_cost_vec, nstmts, vec_perm,\n+\t\t\t\t      stmt_info, 0);\n \n       if (vect_print_dump_info (REPORT_COST))\n         fprintf (vect_dump, \"vect_model_store_cost: strided group_size = %d .\",\n                  group_size);\n     }\n \n   /* Costs of the stores.  */\n-  vect_get_store_cost (first_dr, ncopies, &inside_cost);\n+  vect_get_store_cost (first_dr, ncopies, &inside_cost, stmt_cost_vec);\n \n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_model_store_cost: inside_cost = %d, \"\n              \"outside_cost = %d .\", inside_cost, outside_cost);\n \n   /* Set the costs either in STMT_INFO or SLP_NODE (if exists).  */\n-  stmt_vinfo_set_inside_of_loop_cost (stmt_info, slp_node, inside_cost);\n   stmt_vinfo_set_outside_of_loop_cost (stmt_info, slp_node, outside_cost);\n }\n \n \n /* Calculate cost of DR's memory access.  */\n void\n vect_get_store_cost (struct data_reference *dr, int ncopies,\n-                     unsigned int *inside_cost)\n+\t\t     unsigned int *inside_cost,\n+\t\t     stmt_vector_for_cost *stmt_cost_vec)\n {\n   int alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n+  gimple stmt = DR_STMT (dr);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \n   switch (alignment_support_scheme)\n     {\n     case dr_aligned:\n       {\n-        *inside_cost += ncopies * vect_get_stmt_cost (vector_store);\n+\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies,\n+\t\t\t\t\t  vector_store, stmt_info, 0);\n \n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump, \"vect_model_store_cost: aligned.\");\n@@ -915,14 +989,10 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n \n     case dr_unaligned_supported:\n       {\n-        gimple stmt = DR_STMT (dr);\n-        stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-        tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-\n         /* Here, we assign an additional cost for the unaligned store.  */\n-        *inside_cost += ncopies\n-          * targetm.vectorize.builtin_vectorization_cost (unaligned_store,\n-                                 vectype, DR_MISALIGNMENT (dr));\n+\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies,\n+\t\t\t\t\t  unaligned_store, stmt_info,\n+\t\t\t\t\t  DR_MISALIGNMENT (dr));\n \n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump, \"vect_model_store_cost: unaligned supported by \"\n@@ -956,7 +1026,7 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n \n void\n vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, bool load_lanes_p,\n-\t\t      slp_tree slp_node)\n+\t\t      slp_tree slp_node, stmt_vector_for_cost *stmt_cost_vec)\n {\n   int group_size;\n   gimple first_stmt;\n@@ -988,8 +1058,9 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, bool load_lanes_p,\n   if (!load_lanes_p && group_size > 1)\n     {\n       /* Uses an even and odd extract operations for each needed permute.  */\n-      inside_cost = ncopies * exact_log2(group_size) * group_size\n-\t* vect_get_stmt_cost (vec_perm);\n+      int nstmts = ncopies * exact_log2 (group_size) * group_size;\n+      inside_cost += record_stmt_cost (stmt_cost_vec, nstmts, vec_perm,\n+\t\t\t\t       stmt_info, 0);\n \n       if (vect_print_dump_info (REPORT_COST))\n         fprintf (vect_dump, \"vect_model_load_cost: strided group_size = %d .\",\n@@ -1001,41 +1072,44 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, bool load_lanes_p,\n     {\n       /* N scalar loads plus gathering them into a vector.  */\n       tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-      inside_cost += (vect_get_stmt_cost (scalar_load) * ncopies\n-\t\t      * TYPE_VECTOR_SUBPARTS (vectype));\n-      inside_cost += ncopies\n-\t* targetm.vectorize.builtin_vectorization_cost (vec_construct,\n-\t\t\t\t\t\t\tvectype, 0);\n+      inside_cost += record_stmt_cost (stmt_cost_vec,\n+\t\t\t\t       ncopies * TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t\t\t       scalar_load, stmt_info, 0);\n+      inside_cost += record_stmt_cost (stmt_cost_vec, ncopies, vec_construct,\n+\t\t\t\t       stmt_info, 0);\n     }\n   else\n     vect_get_load_cost (first_dr, ncopies,\n \t\t\t((!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n \t\t\t || group_size > 1 || slp_node),\n-\t\t\t&inside_cost, &outside_cost);\n+\t\t\t&inside_cost, &outside_cost, stmt_cost_vec);\n \n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_model_load_cost: inside_cost = %d, \"\n              \"outside_cost = %d .\", inside_cost, outside_cost);\n \n   /* Set the costs either in STMT_INFO or SLP_NODE (if exists).  */\n-  stmt_vinfo_set_inside_of_loop_cost (stmt_info, slp_node, inside_cost);\n   stmt_vinfo_set_outside_of_loop_cost (stmt_info, slp_node, outside_cost);\n }\n \n \n /* Calculate cost of DR's memory access.  */\n void\n vect_get_load_cost (struct data_reference *dr, int ncopies,\n-                    bool add_realign_cost, unsigned int *inside_cost,\n-                    unsigned int *outside_cost)\n+\t\t    bool add_realign_cost, unsigned int *inside_cost,\n+\t\t    unsigned int *outside_cost,\n+\t\t    stmt_vector_for_cost *stmt_cost_vec)\n {\n   int alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n+  gimple stmt = DR_STMT (dr);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \n   switch (alignment_support_scheme)\n     {\n     case dr_aligned:\n       {\n-        *inside_cost += ncopies * vect_get_stmt_cost (vector_load); \n+\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies,\n+\t\t\t\t\t  vector_load, stmt_info, 0);\n \n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump, \"vect_model_load_cost: aligned.\");\n@@ -1044,14 +1118,11 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n       }\n     case dr_unaligned_supported:\n       {\n-        gimple stmt = DR_STMT (dr);\n-        stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-        tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-\n         /* Here, we assign an additional cost for the unaligned load.  */\n-        *inside_cost += ncopies\n-          * targetm.vectorize.builtin_vectorization_cost (unaligned_load,\n-                                           vectype, DR_MISALIGNMENT (dr));\n+\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies,\n+\t\t\t\t\t  unaligned_load, stmt_info,\n+\t\t\t\t\t  DR_MISALIGNMENT (dr));\n+\n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump, \"vect_model_load_cost: unaligned supported by \"\n                    \"hardware.\");\n@@ -1060,14 +1131,17 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n       }\n     case dr_explicit_realign:\n       {\n-        *inside_cost += ncopies * (2 * vect_get_stmt_cost (vector_load)\n-\t\t\t\t   + vect_get_stmt_cost (vec_perm));\n+\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies * 2,\n+\t\t\t\t\t  vector_load, stmt_info, 0);\n+\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies,\n+\t\t\t\t\t  vec_perm, stmt_info, 0);\n \n         /* FIXME: If the misalignment remains fixed across the iterations of\n            the containing loop, the following cost should be added to the\n            outside costs.  */\n         if (targetm.vectorize.builtin_mask_for_load)\n-          *inside_cost += vect_get_stmt_cost (vector_stmt);\n+\t  *inside_cost += record_stmt_cost (stmt_cost_vec, 1, vector_stmt,\n+\t\t\t\t\t    stmt_info, 0);\n \n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump, \"vect_model_load_cost: explicit realign\");\n@@ -1094,8 +1168,10 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n               *outside_cost += vect_get_stmt_cost (vector_stmt);\n           }\n \n-        *inside_cost += ncopies * (vect_get_stmt_cost (vector_load)\n-\t\t\t\t   + vect_get_stmt_cost (vec_perm));\n+\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies,\n+\t\t\t\t\t  vector_load, stmt_info, 0);\n+\t*inside_cost += record_stmt_cost (stmt_cost_vec, ncopies,\n+\t\t\t\t\t  vec_perm, stmt_info, 0);\n \n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump,\n@@ -1719,7 +1795,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       STMT_VINFO_TYPE (stmt_info) = call_vec_info_type;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"=== vectorizable_call ===\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt, NULL);\n+      vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n       return true;\n     }\n \n@@ -2433,7 +2509,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n       if (code == FIX_TRUNC_EXPR || code == FLOAT_EXPR)\n         {\n \t  STMT_VINFO_TYPE (stmt_info) = type_conversion_vec_info_type;\n-\t  vect_model_simple_cost (stmt_info, ncopies, dt, NULL);\n+\t  vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n \t}\n       else if (modifier == NARROW)\n \t{\n@@ -2841,7 +2917,7 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n       STMT_VINFO_TYPE (stmt_info) = assignment_vec_info_type;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"=== vectorizable_assignment ===\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt, NULL);\n+      vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n       return true;\n     }\n \n@@ -3187,7 +3263,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n       STMT_VINFO_TYPE (stmt_info) = shift_vec_info_type;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"=== vectorizable_shift ===\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt, NULL);\n+      vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n       return true;\n     }\n \n@@ -3501,7 +3577,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       STMT_VINFO_TYPE (stmt_info) = op_vec_info_type;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"=== vectorizable_operation ===\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt, NULL);\n+      vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n       return true;\n     }\n \n@@ -3805,7 +3881,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n-      vect_model_store_cost (stmt_info, ncopies, store_lanes_p, dt, NULL);\n+      vect_model_store_cost (stmt_info, ncopies, store_lanes_p, dt, NULL, NULL);\n       return true;\n     }\n \n@@ -4361,7 +4437,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = load_vec_info_type;\n-      vect_model_load_cost (stmt_info, ncopies, load_lanes_p, NULL);\n+      vect_model_load_cost (stmt_info, ncopies, load_lanes_p, NULL, NULL);\n       return true;\n     }\n \n@@ -5801,7 +5877,6 @@ new_stmt_vec_info (gimple stmt, loop_vec_info loop_vinfo,\n     STMT_VINFO_DEF_TYPE (res) = vect_internal_def;\n \n   STMT_VINFO_SAME_ALIGN_REFS (res) = VEC_alloc (dr_p, heap, 5);\n-  STMT_VINFO_INSIDE_OF_LOOP_COST (res) = 0;\n   STMT_VINFO_OUTSIDE_OF_LOOP_COST (res) = 0;\n   STMT_SLP_TYPE (res) = loop_vect;\n   GROUP_FIRST_ELEMENT (res) = NULL;"}, {"sha": "6b74bb41188c4c8b273af1519ed914e39fd47a5a", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 92, "deletions": 29, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e7ee4191ea60b02af9fff0ccc15d060961fde4/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c3e7ee4191ea60b02af9fff0ccc15d060961fde4", "patch": "@@ -71,6 +71,32 @@ enum vect_def_type {\n                                    || ((D) == vect_double_reduction_def) \\\n                                    || ((D) == vect_nested_cycle))\n \n+/* Structure to encapsulate information about a group of like\n+   instructions to be presented to the target cost model.  */\n+typedef struct _stmt_info_for_cost {\n+  int count;\n+  enum vect_cost_for_stmt kind;\n+  gimple stmt;\n+  int misalign;\n+} stmt_info_for_cost;\n+\n+DEF_VEC_O (stmt_info_for_cost);\n+DEF_VEC_ALLOC_O (stmt_info_for_cost, heap);\n+\n+typedef VEC(stmt_info_for_cost, heap) *stmt_vector_for_cost;\n+\n+static inline void\n+add_stmt_info_to_vec (stmt_vector_for_cost *stmt_cost_vec, int count,\n+\t\t      enum vect_cost_for_stmt kind, gimple stmt, int misalign)\n+{\n+  stmt_info_for_cost si;\n+  si.count = count;\n+  si.kind = kind;\n+  si.stmt = stmt;\n+  si.misalign = misalign;\n+  VEC_safe_push (stmt_info_for_cost, heap, *stmt_cost_vec, &si);\n+}\n+\n /************************************************************************\n   SLP\n  ************************************************************************/\n@@ -96,7 +122,6 @@ typedef struct _slp_tree {\n   struct\n   {\n     int outside_of_loop;     /* Statements generated outside loop.  */\n-    int inside_of_loop;      /* Statements generated inside loop.  */\n   } cost;\n } *slp_tree;\n \n@@ -119,9 +144,11 @@ typedef struct _slp_instance {\n   struct\n   {\n     int outside_of_loop;     /* Statements generated outside loop.  */\n-    int inside_of_loop;      /* Statements generated inside loop.  */\n   } cost;\n \n+  /* Inside-loop costs.  */\n+  stmt_vector_for_cost stmt_cost_vec;\n+\n   /* Loads permutation relatively to the stores, NULL if there is no\n      permutation.  */\n   VEC (int, heap) *load_permutation;\n@@ -142,7 +169,7 @@ DEF_VEC_ALLOC_P(slp_instance, heap);\n #define SLP_INSTANCE_GROUP_SIZE(S)               (S)->group_size\n #define SLP_INSTANCE_UNROLLING_FACTOR(S)         (S)->unrolling_factor\n #define SLP_INSTANCE_OUTSIDE_OF_LOOP_COST(S)     (S)->cost.outside_of_loop\n-#define SLP_INSTANCE_INSIDE_OF_LOOP_COST(S)      (S)->cost.inside_of_loop\n+#define SLP_INSTANCE_STMT_COST_VEC(S)            (S)->stmt_cost_vec\n #define SLP_INSTANCE_LOAD_PERMUTATION(S)         (S)->load_permutation\n #define SLP_INSTANCE_LOADS(S)                    (S)->loads\n #define SLP_INSTANCE_FIRST_LOAD_STMT(S)          (S)->first_load\n@@ -152,7 +179,6 @@ DEF_VEC_ALLOC_P(slp_instance, heap);\n #define SLP_TREE_VEC_STMTS(S)                    (S)->vec_stmts\n #define SLP_TREE_NUMBER_OF_VEC_STMTS(S)          (S)->vec_stmts_size\n #define SLP_TREE_OUTSIDE_OF_LOOP_COST(S)         (S)->cost.outside_of_loop\n-#define SLP_TREE_INSIDE_OF_LOOP_COST(S)          (S)->cost.inside_of_loop\n \n /* This structure is used in creation of an SLP tree.  Each instance\n    corresponds to the same operand in a group of scalar stmts in an SLP\n@@ -186,6 +212,7 @@ typedef struct _vect_peel_extended_info\n   struct _vect_peel_info peel_info;\n   unsigned int inside_cost;\n   unsigned int outside_cost;\n+  stmt_vector_for_cost stmt_cost_vec;\n } *vect_peel_extended_info;\n \n /*-----------------------------------------------------------------*/\n@@ -274,6 +301,9 @@ typedef struct _loop_vec_info {\n   /* Hash table used to choose the best peeling option.  */\n   htab_t peeling_htab;\n \n+  /* Cost data used by the target cost model.  */\n+  void *target_cost_data;\n+\n   /* When we have grouped data accesses with gaps, we may introduce invalid\n      memory accesses.  We peel the last iteration of the loop to prevent\n      this.  */\n@@ -307,6 +337,7 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_REDUCTIONS(L)           (L)->reductions\n #define LOOP_VINFO_REDUCTION_CHAINS(L)     (L)->reduction_chains\n #define LOOP_VINFO_PEELING_HTAB(L)         (L)->peeling_htab\n+#define LOOP_VINFO_TARGET_COST_DATA(L)     (L)->target_cost_data\n #define LOOP_VINFO_PEELING_FOR_GAPS(L)     (L)->peeling_for_gaps\n \n #define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L) \\\n@@ -350,13 +381,18 @@ typedef struct _bb_vec_info {\n \n   /* All data dependences in the basic block.  */\n   VEC (ddr_p, heap) *ddrs;\n+\n+  /* Cost data used by the target cost model.  */\n+  void *target_cost_data;\n+\n } *bb_vec_info;\n \n-#define BB_VINFO_BB(B)              (B)->bb\n-#define BB_VINFO_GROUPED_STORES(B)  (B)->grouped_stores\n-#define BB_VINFO_SLP_INSTANCES(B)   (B)->slp_instances\n-#define BB_VINFO_DATAREFS(B)        (B)->datarefs\n-#define BB_VINFO_DDRS(B)            (B)->ddrs\n+#define BB_VINFO_BB(B)               (B)->bb\n+#define BB_VINFO_GROUPED_STORES(B)   (B)->grouped_stores\n+#define BB_VINFO_SLP_INSTANCES(B)    (B)->slp_instances\n+#define BB_VINFO_DATAREFS(B)         (B)->datarefs\n+#define BB_VINFO_DDRS(B)             (B)->ddrs\n+#define BB_VINFO_TARGET_COST_DATA(B) (B)->target_cost_data\n \n static inline bb_vec_info\n vec_info_for_bb (basic_block bb)\n@@ -534,7 +570,6 @@ typedef struct _stmt_vec_info {\n   struct\n   {\n     int outside_of_loop;     /* Statements generated outside loop.  */\n-    int inside_of_loop;      /* Statements generated inside loop.  */\n   } cost;\n \n   /* The bb_vec_info with respect to which STMT is vectorized.  */\n@@ -594,7 +629,6 @@ typedef struct _stmt_vec_info {\n \n #define STMT_VINFO_RELEVANT_P(S)          ((S)->relevant != vect_unused_in_scope)\n #define STMT_VINFO_OUTSIDE_OF_LOOP_COST(S) (S)->cost.outside_of_loop\n-#define STMT_VINFO_INSIDE_OF_LOOP_COST(S)  (S)->cost.inside_of_loop\n \n #define HYBRID_SLP_STMT(S)                ((S)->slp_type == hybrid)\n #define PURE_SLP_STMT(S)                  ((S)->slp_type == pure_slp)\n@@ -733,19 +767,7 @@ is_loop_header_bb_p (basic_block bb)\n   return false;\n }\n \n-/* Set inside loop vectorization cost.  */\n-\n-static inline void\n-stmt_vinfo_set_inside_of_loop_cost (stmt_vec_info stmt_info, slp_tree slp_node,\n-\t\t\t\t    int cost)\n-{\n-  if (slp_node)\n-    SLP_TREE_INSIDE_OF_LOOP_COST (slp_node) = cost;\n-  else\n-    STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) = cost;\n-}\n-\n-/* Set inside loop vectorization cost.  */\n+/* Set outside loop vectorization cost.  */\n \n static inline void\n stmt_vinfo_set_outside_of_loop_cost (stmt_vec_info stmt_info, slp_tree slp_node,\n@@ -782,6 +804,41 @@ int vect_get_stmt_cost (enum vect_cost_for_stmt type_of_cost)\n                                                        dummy_type, dummy);\n }\n \n+/* Alias targetm.vectorize.init_cost.  */\n+\n+static inline void *\n+init_cost (struct loop *loop_info)\n+{\n+  return targetm.vectorize.init_cost (loop_info);\n+}\n+\n+/* Alias targetm.vectorize.add_stmt_cost.  */\n+\n+static inline unsigned\n+add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n+\t       stmt_vec_info stmt_info, int misalign)\n+{\n+  return targetm.vectorize.add_stmt_cost (data, count, kind,\n+\t\t\t\t\t  stmt_info, misalign);\n+}\n+\n+/* Alias targetm.vectorize.finish_cost.  */\n+\n+static inline unsigned\n+finish_cost (void *data)\n+{\n+  return targetm.vectorize.finish_cost (data);\n+}\n+\n+/* Alias targetm.vectorize.destroy_cost_data.  */\n+\n+static inline void\n+destroy_cost_data (void *data)\n+{\n+  targetm.vectorize.destroy_cost_data (data);\n+}\n+\n+\n /*-----------------------------------------------------------------*/\n /* Info on data references alignment.                              */\n /*-----------------------------------------------------------------*/\n@@ -849,10 +906,14 @@ extern stmt_vec_info new_stmt_vec_info (gimple stmt, loop_vec_info,\n extern void free_stmt_vec_info (gimple stmt);\n extern tree vectorizable_function (gimple, tree, tree);\n extern void vect_model_simple_cost (stmt_vec_info, int, enum vect_def_type *,\n-                                    slp_tree);\n+                                    slp_tree, stmt_vector_for_cost *);\n extern void vect_model_store_cost (stmt_vec_info, int, bool,\n-\t\t\t\t   enum vect_def_type, slp_tree);\n-extern void vect_model_load_cost (stmt_vec_info, int, bool, slp_tree);\n+\t\t\t\t   enum vect_def_type, slp_tree,\n+\t\t\t\t   stmt_vector_for_cost *);\n+extern void vect_model_load_cost (stmt_vec_info, int, bool, slp_tree,\n+\t\t\t\t  stmt_vector_for_cost *);\n+extern unsigned record_stmt_cost (stmt_vector_for_cost *, int,\n+\t\t\t\t  enum vect_cost_for_stmt, stmt_vec_info, int);\n extern void vect_finish_stmt_generation (gimple, gimple,\n                                          gimple_stmt_iterator *);\n extern bool vect_mark_stmts_to_be_vectorized (loop_vec_info);\n@@ -867,8 +928,10 @@ extern bool vect_analyze_stmt (gimple, bool *, slp_tree);\n extern bool vectorizable_condition (gimple, gimple_stmt_iterator *, gimple *,\n                                     tree, int, slp_tree);\n extern void vect_get_load_cost (struct data_reference *, int, bool,\n-                                unsigned int *, unsigned int *);\n-extern void vect_get_store_cost (struct data_reference *, int, unsigned int *);\n+\t\t\t\tunsigned int *, unsigned int *,\n+\t\t\t\tstmt_vector_for_cost *);\n+extern void vect_get_store_cost (struct data_reference *, int,\n+\t\t\t\t unsigned int *, stmt_vector_for_cost *);\n extern bool vect_supportable_shift (enum tree_code, tree);\n extern void vect_get_vec_defs (tree, tree, gimple, VEC (tree, heap) **,\n \t\t\t       VEC (tree, heap) **, slp_tree, int);"}]}