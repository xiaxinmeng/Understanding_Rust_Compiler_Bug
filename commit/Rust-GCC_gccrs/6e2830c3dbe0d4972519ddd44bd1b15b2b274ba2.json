{"sha": "6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUyODMwYzNkYmUwZDQ5NzI1MTlkZGQ0NGJkMWIxNWIyYjI3NGJhMg==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-08-02T11:23:49Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-08-02T11:23:49Z"}, "message": "add a hash_set based on hash_table\n\nThis allows us to replace the usage of pointer_set outside of\npointer_map with a nicer interface.\n\ngcc/ada/\n\n\t* gcc-interface/trans.c: Use hash_set instead of pointer_set.\n\ngcc/c-family/\n\n\t* c-gimplify.c: Use hash_set instead of pointer_set.\n\ngcc/c/\n\n\t* c-decl.c: Use hash_set instead of pointer_set.\n\ngcc/cp/\n\n\t* class.c, cp-gimplify.c, cp-tree.h, decl.c, decl2.c, error.c,\n\tmethod.c, name-lookup.c, pt.c, semantics.c, tree.c: Use hash_set\n\tinstead of pointer_set.\n\ngcc/fortran/\n\n\t* openmp.c, trans-decl.c: Use hash_set instead of pointer_set.\n\ngcc/\n\n\t* hash-set.h: new File.\n\t* cfgexpand.c, cfgloop.c, cgraph.c, cgraphbuild.c, cgraphunit.c,\n\tcprop.c, cse.c, gimple-walk.c, gimple-walk.h, gimplify.c, godump.c,\n\tipa-devirt.c, ipa-pure-const.c, ipa-visibility.c, ipa.c, lto-cgraph.c,\n\tlto-streamer-out.c, stmt.c, tree-cfg.c, tree-core.h, tree-eh.c,\n\ttree-inline.c, tree-inline.h, tree-nested.c, tree-pretty-print.c,\n\ttree-ssa-loop-niter.c, tree-ssa-phiopt.c, tree-ssa-threadedge.c,\n\ttree-ssa-uninit.c, tree.c, tree.h, value-prof.c, varasm.c,\n\tvarpool.c: Use hash_set instead of pointer_set.\n\ngcc/lto/\n\n\t* lto-partition.c, lto-partition.h: Use hash_set instead of\n\tpointer_set.\n\nFrom-SVN: r213516", "tree": {"sha": "f0fb192e856fa98b7d91e225ff958dfcc1f602df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0fb192e856fa98b7d91e225ff958dfcc1f602df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/comments", "author": null, "committer": null, "parents": [{"sha": "2df06cec0a2fe611c5487bf54c4ef8e3b2b30543", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2df06cec0a2fe611c5487bf54c4ef8e3b2b30543", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2df06cec0a2fe611c5487bf54c4ef8e3b2b30543"}], "stats": {"total": 1117, "additions": 631, "deletions": 486}, "files": [{"sha": "eff8b3a86e98cb0a12cddba0c683919af77ab4f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -1,3 +1,15 @@\n+2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* hash-set.h: new File.\n+\t* cfgexpand.c, cfgloop.c, cgraph.c, cgraphbuild.c, cgraphunit.c,\n+\tcprop.c, cse.c, gimple-walk.c, gimple-walk.h, gimplify.c, godump.c,\n+\tipa-devirt.c, ipa-pure-const.c, ipa-visibility.c, ipa.c, lto-cgraph.c,\n+\tlto-streamer-out.c, stmt.c, tree-cfg.c, tree-core.h, tree-eh.c,\n+\ttree-inline.c, tree-inline.h, tree-nested.c, tree-pretty-print.c,\n+\ttree-ssa-loop-niter.c, tree-ssa-phiopt.c, tree-ssa-threadedge.c,\n+\ttree-ssa-uninit.c, tree.c, tree.h, value-prof.c, varasm.c,\n+\tvarpool.c: Use hash_set instead of pointer_set.\n+\n 2014-08-01  Alan Lawrence  <alan.lawrence@arm.com>\n \n \t* config/aarch64/aarch64-simd-builtins.def (dup_lane, get_lane): Delete."}, {"sha": "452488a37f3cd000c399b13121ba7ead639adf1e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -1,3 +1,7 @@\n+2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* gcc-interface/trans.c: Use hash_set instead of pointer_set.\n+\n 2014-08-01  Ed Schonberg  <schonberg@adacore.com>\n \n \t* restrict.adb (Update_Restrictions): For restrictions with a"}, {"sha": "77a8f87f2d1a962c256aec334945efff074d3994", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -36,7 +36,7 @@\n #include \"output.h\"\n #include \"libfuncs.h\"\t/* For set_stack_check_libfunc.  */\n #include \"tree-iterator.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-set.h\"\n #include \"gimple-expr.h\"\n #include \"gimplify.h\"\n #include \"bitmap.h\"\n@@ -3008,7 +3008,7 @@ struct nrv_data\n   bitmap nrv;\n   tree result;\n   Node_Id gnat_ret;\n-  struct pointer_set_t *visited;\n+  hash_set<tree> *visited;\n };\n \n /* Return true if T is a Named Return Value.  */\n@@ -3142,7 +3142,7 @@ finalize_nrv_r (tree *tp, int *walk_subtrees, void *data)\n   /* Avoid walking into the same tree more than once.  Unfortunately, we\n      can't just use walk_tree_without_duplicates because it would only\n      call us for the first occurrence of NRVs in the function body.  */\n-  if (pointer_set_insert (dp->visited, *tp))\n+  if (dp->visited->add (*tp))\n     *walk_subtrees = 0;\n \n   return NULL_TREE;\n@@ -3282,7 +3282,7 @@ finalize_nrv_unc_r (tree *tp, int *walk_subtrees, void *data)\n   /* Avoid walking into the same tree more than once.  Unfortunately, we\n      can't just use walk_tree_without_duplicates because it would only\n      call us for the first occurrence of NRVs in the function body.  */\n-  if (pointer_set_insert (dp->visited, *tp))\n+  if (dp->visited->add (*tp))\n     *walk_subtrees = 0;\n \n   return NULL_TREE;\n@@ -3330,13 +3330,13 @@ finalize_nrv (tree fndecl, bitmap nrv, vec<tree, va_gc> *other, Node_Id gnat_ret\n   data.nrv = nrv;\n   data.result = DECL_RESULT (fndecl);\n   data.gnat_ret = gnat_ret;\n-  data.visited = pointer_set_create ();\n+  data.visited = new hash_set<tree>;\n   if (TYPE_RETURN_UNCONSTRAINED_P (TREE_TYPE (fndecl)))\n     func = finalize_nrv_unc_r;\n   else\n     func = finalize_nrv_r;\n   walk_tree (&DECL_SAVED_TREE (fndecl), func, &data, NULL);\n-  pointer_set_destroy (data.visited);\n+  delete data.visited;\n }\n \n /* Return true if RET_VAL can be used as a Named Return Value for the"}, {"sha": "5174b091826f10cfd663138bc9848153fcc99063", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -1,3 +1,7 @@\n+2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* c-gimplify.c: Use hash_set instead of pointer_set.\n+\n 2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>\n \n \tPR middle-end/61455"}, {"sha": "489821757edb263ffdcc6ef80be99dc3b340f9a9", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -74,7 +74,7 @@ along with GCC; see the file COPYING3.  If not see\n static tree\n ubsan_walk_array_refs_r (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct pointer_set_t *pset = (struct pointer_set_t *) data;\n+  hash_set<tree> *pset = (hash_set<tree> *) data;\n \n   /* Since walk_tree doesn't call the callback function on the decls\n      in BIND_EXPR_VARS, we have to walk them manually.  */\n@@ -116,10 +116,9 @@ c_genericize (tree fndecl)\n \n   if (flag_sanitize & SANITIZE_BOUNDS)\n     {\n-      struct pointer_set_t *pset = pointer_set_create ();\n-      walk_tree (&DECL_SAVED_TREE (fndecl), ubsan_walk_array_refs_r, pset,\n-\t\t pset);\n-      pointer_set_destroy (pset);\n+      hash_set<tree> pset;\n+      walk_tree (&DECL_SAVED_TREE (fndecl), ubsan_walk_array_refs_r, &pset,\n+\t\t &pset);\n     }\n \n   /* Dump the C-specific tree IR.  */"}, {"sha": "c8c957d7437366dfd37d6a9913bda814a2c40406", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -1,3 +1,7 @@\n+2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* c-decl.c: Use hash_set instead of pointer_set.\n+\n 2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>\n \n \tPR middle-end/61455"}, {"sha": "050ddffa3437d082bf56f88ada387cb009285b32", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -59,7 +59,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"hash-table.h\"\n #include \"langhooks-def.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-set.h\"\n #include \"plugin.h\"\n #include \"c-family/c-ada-spec.h\"\n #include \"cilk.h\"\n@@ -7221,17 +7221,17 @@ warn_cxx_compat_finish_struct (tree fieldlist)\n   if (!struct_parse_info->typedefs_seen.is_empty ()\n       && fieldlist != NULL_TREE)\n     {\n-      /* Use a pointer_set using the name of the typedef.  We can use\n-\t a pointer_set because identifiers are interned.  */\n-      struct pointer_set_t *tset = pointer_set_create ();\n+      /* Use a hash_set<tree> using the name of the typedef.  We can use\n+\t a hash_set<tree> because identifiers are interned.  */\n+      hash_set<tree> tset;\n \n       FOR_EACH_VEC_ELT (struct_parse_info->typedefs_seen, ix, x)\n-\tpointer_set_insert (tset, DECL_NAME (x));\n+\ttset.add (DECL_NAME (x));\n \n       for (x = fieldlist; x != NULL_TREE; x = DECL_CHAIN (x))\n \t{\n \t  if (DECL_NAME (x) != NULL_TREE\n-\t      && pointer_set_contains (tset, DECL_NAME (x)))\n+\t      && tset.contains (DECL_NAME (x)))\n \t    {\n \t      warning_at (DECL_SOURCE_LOCATION (x), OPT_Wc___compat,\n \t\t\t  (\"using %qD as both field and typedef name is \"\n@@ -7241,8 +7241,6 @@ warn_cxx_compat_finish_struct (tree fieldlist)\n \t\t the typedef name is used.  */\n \t    }\n \t}\n-\n-      pointer_set_destroy (tset);\n     }\n \n   /* For each field which has a binding and which was not defined in\n@@ -8189,7 +8187,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n   struct c_binding *b;\n   tree parm, decl, last;\n   tree parmids = arg_info->parms;\n-  struct pointer_set_t *seen_args = pointer_set_create ();\n+  hash_set<tree> seen_args;\n \n   if (!in_system_header_at (input_location))\n     warning_at (DECL_SOURCE_LOCATION (fndecl),\n@@ -8220,7 +8218,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t\t      \"%qD declared as a non-parameter\", decl);\n \t  /* If the declaration is already marked, we have a duplicate\n \t     name.  Complain and ignore the duplicate.  */\n-\t  else if (pointer_set_contains (seen_args, decl))\n+\t  else if (seen_args.contains (decl))\n \t    {\n \t      error_at (DECL_SOURCE_LOCATION (decl),\n \t\t\t\"multiple parameters named %qD\", decl);\n@@ -8269,7 +8267,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t}\n \n       TREE_PURPOSE (parm) = decl;\n-      pointer_set_insert (seen_args, decl);\n+      seen_args.add (decl);\n     }\n \n   /* Now examine the parms chain for incomplete declarations\n@@ -8289,7 +8287,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t  TREE_TYPE (parm) = error_mark_node;\n \t}\n \n-      if (!pointer_set_contains (seen_args, parm))\n+      if (!seen_args.contains (parm))\n \t{\n \t  error_at (DECL_SOURCE_LOCATION (parm),\n \t\t    \"declaration for parameter %qD but no such parameter\",\n@@ -8324,8 +8322,6 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n       DECL_CHAIN (last) = 0;\n     }\n \n-  pointer_set_destroy (seen_args);\n-\n   /* If there was a previous prototype,\n      set the DECL_ARG_TYPE of each argument according to\n      the type previously specified, and report any mismatches.  */"}, {"sha": "b20be1016bb8f083653fcaef127cbb8ab4059a77", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"langhooks.h\"\n #include \"bitmap.h\"\n+#include \"hash-set.h\"\n #include \"pointer-set.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n@@ -594,7 +595,7 @@ stack_var_cmp (const void *a, const void *b)\n static void\n add_partitioned_vars_to_ptset (struct pt_solution *pt,\n \t\t\t       struct pointer_map_t *decls_to_partitions,\n-\t\t\t       struct pointer_set_t *visited, bitmap temp)\n+\t\t\t       hash_set<bitmap> *visited, bitmap temp)\n {\n   bitmap_iterator bi;\n   unsigned i;\n@@ -604,7 +605,7 @@ add_partitioned_vars_to_ptset (struct pt_solution *pt,\n       || pt->vars == NULL\n       /* The pointed-to vars bitmap is shared, it is enough to\n \t visit it once.  */\n-      || pointer_set_insert (visited, pt->vars))\n+      || visited->add (pt->vars))\n     return;\n \n   bitmap_clear (temp);\n@@ -684,7 +685,7 @@ update_alias_info_with_stack_vars (void)\n   if (decls_to_partitions)\n     {\n       unsigned i;\n-      struct pointer_set_t *visited = pointer_set_create ();\n+      hash_set<bitmap> visited;\n       bitmap temp = BITMAP_ALLOC (&stack_var_bitmap_obstack);\n \n       for (i = 1; i < num_ssa_names; i++)\n@@ -696,13 +697,12 @@ update_alias_info_with_stack_vars (void)\n \t      && POINTER_TYPE_P (TREE_TYPE (name))\n \t      && ((pi = SSA_NAME_PTR_INFO (name)) != NULL))\n \t    add_partitioned_vars_to_ptset (&pi->pt, decls_to_partitions,\n-\t\t\t\t\t   visited, temp);\n+\t\t\t\t\t   &visited, temp);\n \t}\n \n       add_partitioned_vars_to_ptset (&cfun->gimple_df->escaped,\n-\t\t\t\t     decls_to_partitions, visited, temp);\n+\t\t\t\t     decls_to_partitions, &visited, temp);\n \n-      pointer_set_destroy (visited);\n       pointer_map_destroy (decls_to_partitions);\n       BITMAP_FREE (temp);\n     }"}, {"sha": "8f7e2658e4498d600dff89fdbd5e3d8e4da87d75", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -28,7 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"flags.h\"\n #include \"tree.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-set.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n #include \"gimple-expr.h\"\n@@ -650,11 +650,11 @@ find_subloop_latch_edge (struct loop *loop)\n /* Callback for make_forwarder_block.  Returns true if the edge E is marked\n    in the set MFB_REIS_SET.  */\n \n-static struct pointer_set_t *mfb_reis_set;\n+static hash_set<edge> *mfb_reis_set;\n static bool\n mfb_redirect_edges_in_set (edge e)\n {\n-  return pointer_set_contains (mfb_reis_set, e);\n+  return mfb_reis_set->contains (e);\n }\n \n /* Creates a subloop of LOOP with latch edge LATCH.  */\n@@ -666,15 +666,15 @@ form_subloop (struct loop *loop, edge latch)\n   edge e, new_entry;\n   struct loop *new_loop;\n \n-  mfb_reis_set = pointer_set_create ();\n+  mfb_reis_set = new hash_set<edge>;\n   FOR_EACH_EDGE (e, ei, loop->header->preds)\n     {\n       if (e != latch)\n-\tpointer_set_insert (mfb_reis_set, e);\n+\tmfb_reis_set->add (e);\n     }\n   new_entry = make_forwarder_block (loop->header, mfb_redirect_edges_in_set,\n \t\t\t\t    NULL);\n-  pointer_set_destroy (mfb_reis_set);\n+  delete mfb_reis_set;\n \n   loop->header = new_entry->src;\n \n@@ -705,12 +705,12 @@ merge_latch_edges (struct loop *loop)\n       if (dump_file)\n \tfprintf (dump_file, \"Merged latch edges of loop %d\\n\", loop->num);\n \n-      mfb_reis_set = pointer_set_create ();\n+      mfb_reis_set = new hash_set<edge>;\n       FOR_EACH_VEC_ELT (latches, i, e)\n-\tpointer_set_insert (mfb_reis_set, e);\n+\tmfb_reis_set->add (e);\n       latch = make_forwarder_block (loop->header, mfb_redirect_edges_in_set,\n \t\t\t\t    NULL);\n-      pointer_set_destroy (mfb_reis_set);\n+      delete mfb_reis_set;\n \n       loop->header = latch->dest;\n       loop->latch = latch->src;"}, {"sha": "5a0b9033c25e69e4b5f702bc4b34190fc70d6d40", "filename": "gcc/cgraph.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"langhooks.h\"\n #include \"hashtab.h\"\n+#include \"hash-set.h\"\n #include \"toplev.h\"\n #include \"flags.h\"\n #include \"debug.h\"\n@@ -2876,7 +2877,7 @@ cgraph_node::verify_node (void)\n     {\n       if (this_cfun->cfg)\n \t{\n-\t  pointer_set_t *stmts = pointer_set_create ();\n+\t  hash_set<gimple> stmts;\n \t  int i;\n \t  struct ipa_ref *ref = NULL;\n \n@@ -2886,13 +2887,13 @@ cgraph_node::verify_node (void)\n \t    {\n \t      for (gsi = gsi_start_phis (this_block);\n \t\t   !gsi_end_p (gsi); gsi_next (&gsi))\n-\t\tpointer_set_insert (stmts, gsi_stmt (gsi));\n+\t\tstmts.add (gsi_stmt (gsi));\n \t      for (gsi = gsi_start_bb (this_block);\n \t\t   !gsi_end_p (gsi);\n \t\t   gsi_next (&gsi))\n \t\t{\n \t\t  gimple stmt = gsi_stmt (gsi);\n-\t\t  pointer_set_insert (stmts, stmt);\n+\t\t  stmts.add (stmt);\n \t\t  if (is_gimple_call (stmt))\n \t\t    {\n \t\t      struct cgraph_edge *e = get_edge (stmt);\n@@ -2936,13 +2937,12 @@ cgraph_node::verify_node (void)\n \t\t}\n \t      }\n \t    for (i = 0; iterate_reference (i, ref); i++)\n-\t      if (ref->stmt && !pointer_set_contains (stmts, ref->stmt))\n+\t      if (ref->stmt && !stmts.contains (ref->stmt))\n \t\t{\n \t\t  error (\"reference to dead statement\");\n \t\t  cgraph_debug_gimple_stmt (this_cfun, ref->stmt);\n \t\t  error_found = true;\n \t\t}\n-\t    pointer_set_destroy (stmts);\n \t}\n       else\n \t/* No CFG available?!  */"}, {"sha": "a04958f4d8c0a17e89f86ad6506d912834e0c100", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -322,7 +322,6 @@ pass_build_cgraph_edges::execute (function *fun)\n {\n   basic_block bb;\n   struct cgraph_node *node = cgraph_node::get (current_function_decl);\n-  struct pointer_set_t *visited_nodes = pointer_set_create ();\n   gimple_stmt_iterator gsi;\n   tree decl;\n   unsigned ix;\n@@ -386,7 +385,6 @@ pass_build_cgraph_edges::execute (function *fun)\n       varpool_node::finalize_decl (decl);\n   record_eh_tables (node, fun);\n \n-  pointer_set_destroy (visited_nodes);\n   return 0;\n }\n \n@@ -405,15 +403,14 @@ make_pass_build_cgraph_edges (gcc::context *ctxt)\n void\n record_references_in_initializer (tree decl, bool only_vars)\n {\n-  struct pointer_set_t *visited_nodes = pointer_set_create ();\n   varpool_node *node = varpool_node::get_create (decl);\n+  hash_set<tree> visited_nodes;\n   struct record_reference_ctx ctx = {false, NULL};\n \n   ctx.varpool_node = node;\n   ctx.only_vars = only_vars;\n   walk_tree (&DECL_INITIAL (decl), record_reference,\n-             &ctx, visited_nodes);\n-  pointer_set_destroy (visited_nodes);\n+             &ctx, &visited_nodes);\n }\n \n /* Rebuild cgraph edges for current function node.  This needs to be run after"}, {"sha": "acc441c9ae87cb81c42f521cfb28fddc4d779f07", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -845,7 +845,7 @@ varpool_node::finalize_decl (tree decl)\n    avoid udplicate work.  */\n \n static void\n-walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n+walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \t\t\t       struct cgraph_edge *edge)\n {\n   unsigned int i;\n@@ -855,8 +855,7 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n     = possible_polymorphic_call_targets\n \t(edge, &final, &cache_token);\n \n-  if (!pointer_set_insert (reachable_call_targets,\n-\t\t\t   cache_token))\n+  if (!reachable_call_targets->add (cache_token))\n     {\n       if (cgraph_dump_file)\n \tdump_possible_polymorphic_call_targets \n@@ -936,7 +935,7 @@ analyze_functions (void)\n   struct cgraph_node *first_handled = first_analyzed;\n   static varpool_node *first_analyzed_var;\n   varpool_node *first_handled_var = first_analyzed_var;\n-  struct pointer_set_t *reachable_call_targets = pointer_set_create ();\n+  hash_set<void *> reachable_call_targets;\n \n   symtab_node *node;\n   symtab_node *next;\n@@ -1035,7 +1034,7 @@ analyze_functions (void)\n \t\t    {\n \t\t      next = edge->next_callee;\n \t\t      if (edge->indirect_info->polymorphic)\n-\t\t\twalk_polymorphic_call_targets (reachable_call_targets,\n+\t\t\twalk_polymorphic_call_targets (&reachable_call_targets,\n \t\t\t\t\t\t       edge);\n \t\t    }\n \t\t}\n@@ -1123,7 +1122,6 @@ analyze_functions (void)\n       symtab_node::dump_table (cgraph_dump_file);\n     }\n   bitmap_obstack_release (NULL);\n-  pointer_set_destroy (reachable_call_targets);\n   ggc_collect ();\n   /* Initialize assembler name hash, in particular we want to trigger C++\n      mangling and same body alias creation before we free DECL_ARGUMENTS"}, {"sha": "26cc9f593fc2ec2783cf5857ac25756f923fb0fc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -1,3 +1,9 @@\n+2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* class.c, cp-gimplify.c, cp-tree.h, decl.c, decl2.c, error.c,\n+\tmethod.c, name-lookup.c, pt.c, semantics.c, tree.c: Use hash_set\n+\tinstead of pointer_set.\n+\n 2014-08-01  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/60417"}, {"sha": "811b581cd5abfaa6234f54b50816370cbe99a1fb", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -5359,15 +5359,15 @@ finalize_literal_type_property (tree t)\n void\n explain_non_literal_class (tree t)\n {\n-  static struct pointer_set_t *diagnosed;\n+  static hash_set<tree> *diagnosed;\n \n   if (!CLASS_TYPE_P (t))\n     return;\n   t = TYPE_MAIN_VARIANT (t);\n \n   if (diagnosed == NULL)\n-    diagnosed = pointer_set_create ();\n-  if (pointer_set_insert (diagnosed, t) != 0)\n+    diagnosed = new hash_set<tree>;\n+  if (diagnosed->add (t))\n     /* Already explained.  */\n     return;\n "}, {"sha": "55d6c144dd67497819e3565b65eb0562f5457a67", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -871,7 +871,7 @@ omp_cxx_notice_variable (struct cp_genericize_omp_taskreg *omp_ctx, tree decl)\n \n struct cp_genericize_data\n {\n-  struct pointer_set_t *p_set;\n+  hash_set<tree> *p_set;\n   vec<tree> bind_expr_stack;\n   struct cp_genericize_omp_taskreg *omp_ctx;\n };\n@@ -884,7 +884,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n {\n   tree stmt = *stmt_p;\n   struct cp_genericize_data *wtd = (struct cp_genericize_data *) data;\n-  struct pointer_set_t *p_set = wtd->p_set;\n+  hash_set<tree> *p_set = wtd->p_set;\n \n   /* If in an OpenMP context, note var uses.  */\n   if (__builtin_expect (wtd->omp_ctx != NULL, 0)\n@@ -924,7 +924,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n     }\n \n   /* Other than invisiref parms, don't walk the same tree twice.  */\n-  if (pointer_set_contains (p_set, stmt))\n+  if (p_set->contains (stmt))\n     {\n       *walk_subtrees = 0;\n       return NULL_TREE;\n@@ -1220,7 +1220,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t}\n     }\n \n-  pointer_set_insert (p_set, *stmt_p);\n+  p_set->add (*stmt_p);\n \n   return NULL;\n }\n@@ -1232,11 +1232,11 @@ cp_genericize_tree (tree* t_p)\n {\n   struct cp_genericize_data wtd;\n \n-  wtd.p_set = pointer_set_create ();\n+  wtd.p_set = new hash_set<tree>;\n   wtd.bind_expr_stack.create (0);\n   wtd.omp_ctx = NULL;\n   cp_walk_tree (t_p, cp_genericize_r, &wtd, NULL);\n-  pointer_set_destroy (wtd.p_set);\n+  delete wtd.p_set;\n   wtd.bind_expr_stack.release ();\n }\n "}, {"sha": "622de9c42f426ea6d699caeda9e3d957cf822944", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -6028,7 +6028,7 @@ extern void verify_stmt_tree\t\t\t(tree);\n extern linkage_kind decl_linkage\t\t(tree);\n extern duration_kind decl_storage_duration\t(tree);\n extern tree cp_walk_subtrees (tree*, int*, walk_tree_fn,\n-\t\t\t      void*, struct pointer_set_t*);\n+\t\t\t      void*, hash_set<tree> *);\n #define cp_walk_tree(tp,func,data,pset) \\\n \twalk_tree_1 (tp, func, data, pset, cp_walk_subtrees)\n #define cp_walk_tree_without_duplicates(tp,func,data) \\"}, {"sha": "88152f0daf23ddcb2ebda37a2cae428d750bf06e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -8203,7 +8203,7 @@ check_static_variable_definition (tree decl, tree type)\n static tree\n stabilize_save_expr_r (tree *expr_p, int *walk_subtrees, void *data)\n {\n-  struct pointer_set_t *pset = (struct pointer_set_t *)data;\n+  hash_set<tree> *pset = (hash_set<tree> *)data;\n   tree expr = *expr_p;\n   if (TREE_CODE (expr) == SAVE_EXPR)\n     {\n@@ -8223,10 +8223,9 @@ stabilize_save_expr_r (tree *expr_p, int *walk_subtrees, void *data)\n static void\n stabilize_vla_size (tree size)\n {\n-  struct pointer_set_t *pset = pointer_set_create ();\n+  hash_set<tree> pset;\n   /* Break out any function calls into temporary variables.  */\n-  cp_walk_tree (&size, stabilize_save_expr_r, pset, pset);\n-  pointer_set_destroy (pset);\n+  cp_walk_tree (&size, stabilize_save_expr_r, &pset, &pset);\n }\n \n /* Helper function for compute_array_index_type.  Look for SIZEOF_EXPR"}, {"sha": "9ed763d97372722975eff96cb3d1ff2121fa8dc7", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -3920,11 +3920,11 @@ generate_ctor_and_dtor_functions_for_priority (splay_tree_node n, void * data)\n    supported, collect and return all the functions for which we should\n    emit a hidden alias.  */\n \n-static struct pointer_set_t *\n+static hash_set<tree> *\n collect_candidates_for_java_method_aliases (void)\n {\n   struct cgraph_node *node;\n-  struct pointer_set_t *candidates = NULL;\n+  hash_set<tree> *candidates = NULL;\n \n #ifndef HAVE_GAS_HIDDEN\n   return candidates;\n@@ -3939,8 +3939,8 @@ collect_candidates_for_java_method_aliases (void)\n \t  && TARGET_USE_LOCAL_THUNK_ALIAS_P (fndecl))\n \t{\n \t  if (candidates == NULL)\n-\t    candidates = pointer_set_create ();\n-\t  pointer_set_insert (candidates, fndecl);\n+\t    candidates = new hash_set<tree>;\n+\t  candidates->add (fndecl);\n \t}\n     }\n \n@@ -3955,7 +3955,7 @@ collect_candidates_for_java_method_aliases (void)\n    by collect_candidates_for_java_method_aliases.  */\n \n static void\n-build_java_method_aliases (struct pointer_set_t *candidates)\n+build_java_method_aliases (hash_set<tree> *candidates)\n {\n   struct cgraph_node *node;\n \n@@ -3968,7 +3968,7 @@ build_java_method_aliases (struct pointer_set_t *candidates)\n       tree fndecl = node->decl;\n \n       if (TREE_ASM_WRITTEN (fndecl)\n-\t  && pointer_set_contains (candidates, fndecl))\n+\t  && candidates->contains (fndecl))\n \t{\n \t  /* Mangle the name in a predictable way; we need to reference\n \t     this from a java compiled object file.  */\n@@ -4278,7 +4278,7 @@ cp_write_global_declarations (void)\n   unsigned ssdf_count = 0;\n   int retries = 0;\n   tree decl;\n-  struct pointer_set_t *candidates;\n+  hash_set<tree> *candidates;\n \n   locus = input_location;\n   at_eof = 1;\n@@ -4672,7 +4672,7 @@ cp_write_global_declarations (void)\n   if (candidates)\n     {\n       build_java_method_aliases (candidates);\n-      pointer_set_destroy (candidates);\n+      delete candidates;\n     }\n \n   finish_repo ();"}, {"sha": "c8987ee1d048a542fd6fd1b6791431b06ffbfab9", "filename": "gcc/cp/error.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -1325,7 +1325,7 @@ dump_template_decl (cxx_pretty_printer *pp, tree t, int flags)\n \n struct find_typenames_t\n {\n-  struct pointer_set_t *p_set;\n+  hash_set<tree> *p_set;\n   vec<tree, va_gc> *typenames;\n };\n \n@@ -1351,7 +1351,7 @@ find_typenames_r (tree *tp, int *walk_subtrees, void *data)\n       return NULL_TREE;\n     }\n \n-  if (mv && (mv == *tp || !pointer_set_insert (d->p_set, mv)))\n+  if (mv && (mv == *tp || !d->p_set->add (mv)))\n     vec_safe_push (d->typenames, mv);\n \n   /* Search into class template arguments, which cp_walk_subtrees\n@@ -1367,11 +1367,11 @@ static vec<tree, va_gc> *\n find_typenames (tree t)\n {\n   struct find_typenames_t ft;\n-  ft.p_set = pointer_set_create ();\n+  ft.p_set = new hash_set<tree>;\n   ft.typenames = NULL;\n   cp_walk_tree (&TREE_TYPE (DECL_TEMPLATE_RESULT (t)),\n \t\tfind_typenames_r, &ft, ft.p_set);\n-  pointer_set_destroy (ft.p_set);\n+  delete ft.p_set;\n   return ft.typenames;\n }\n "}, {"sha": "56f50e1e5da697658bfd019b3e458899df00c2da", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -1480,16 +1480,16 @@ maybe_explain_implicit_delete (tree decl)\n   if (DECL_DEFAULTED_FN (decl))\n     {\n       /* Not marked GTY; it doesn't need to be GC'd or written to PCH.  */\n-      static struct pointer_set_t *explained;\n+      static hash_set<tree> *explained;\n \n       special_function_kind sfk;\n       location_t loc;\n       bool informed;\n       tree ctype;\n \n       if (!explained)\n-\texplained = pointer_set_create ();\n-      if (pointer_set_insert (explained, decl))\n+\texplained = new hash_set<tree>;\n+      if (explained->add (decl))\n \treturn true;\n \n       sfk = special_function_p (decl);"}, {"sha": "6e779a614bea8c5581ce6cd89b95649301465a60", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -35,7 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"c-family/c-pragma.h\"\n #include \"params.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-set.h\"\n \n /* The bindings for a particular name in a particular scope.  */\n \n@@ -5152,7 +5152,7 @@ struct arg_lookup\n   vec<tree, va_gc> *namespaces;\n   vec<tree, va_gc> *classes;\n   tree functions;\n-  struct pointer_set_t *fn_set;\n+  hash_set<tree> *fn_set;\n };\n \n static bool arg_assoc (struct arg_lookup*, tree);\n@@ -5175,7 +5175,7 @@ add_function (struct arg_lookup *k, tree fn)\n   if (!is_overloaded_fn (fn))\n     /* All names except those of (possibly overloaded) functions and\n        function templates are ignored.  */;\n-  else if (k->fn_set && pointer_set_insert (k->fn_set, fn))\n+  else if (k->fn_set && k->fn_set->add (fn))\n     /* It's already in the list.  */;\n   else if (!k->functions)\n     k->functions = fn;\n@@ -5639,9 +5639,9 @@ lookup_arg_dependent_1 (tree name, tree fns, vec<tree, va_gc> *args)\n       /* We shouldn't be here if lookup found something other than\n \t namespace-scope functions.  */\n       gcc_assert (DECL_NAMESPACE_SCOPE_P (OVL_CURRENT (fns)));\n-      k.fn_set = pointer_set_create ();\n+      k.fn_set = new hash_set<tree>;\n       for (ovl = fns; ovl; ovl = OVL_NEXT (ovl))\n-\tpointer_set_insert (k.fn_set, OVL_CURRENT (ovl));\n+\tk.fn_set->add (OVL_CURRENT (ovl));\n     }\n   else\n     k.fn_set = NULL;\n@@ -5661,8 +5661,7 @@ lookup_arg_dependent_1 (tree name, tree fns, vec<tree, va_gc> *args)\n \n   release_tree_vector (k.classes);\n   release_tree_vector (k.namespaces);\n-  if (k.fn_set)\n-    pointer_set_destroy (k.fn_set);\n+  delete k.fn_set;\n     \n   return fns;\n }"}, {"sha": "f030f30e14aad9fcd91812db20acfd7f1f0c6093", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -147,7 +147,7 @@ static tree convert_nontype_argument (tree, tree, tsubst_flags_t);\n static tree convert_template_argument (tree, tree, tree,\n \t\t\t\t       tsubst_flags_t, int, tree);\n static int for_each_template_parm (tree, tree_fn_t, void*,\n-\t\t\t\t   struct pointer_set_t*, bool);\n+\t\t\t\t   hash_set<tree> *, bool);\n static tree expand_template_argument_pack (tree);\n static tree build_template_parm_index (int, int, int, tree, tree);\n static bool inline_needs_template_parms (tree, bool);\n@@ -3083,7 +3083,7 @@ struct find_parameter_pack_data\n   tree* parameter_packs;\n \n   /* Set of AST nodes that have been visited by the traversal.  */\n-  struct pointer_set_t *visited;\n+  hash_set<tree> *visited;\n };\n \n /* Identifies all of the argument packs that occur in a template\n@@ -3246,9 +3246,9 @@ uses_parameter_packs (tree t)\n   tree parameter_packs = NULL_TREE;\n   struct find_parameter_pack_data ppd;\n   ppd.parameter_packs = &parameter_packs;\n-  ppd.visited = pointer_set_create ();\n+  ppd.visited = new hash_set<tree>;\n   cp_walk_tree (&t, &find_parameter_packs_r, &ppd, ppd.visited);\n-  pointer_set_destroy (ppd.visited);\n+  delete ppd.visited;\n   return parameter_packs != NULL_TREE;\n }\n \n@@ -3295,15 +3295,15 @@ make_pack_expansion (tree arg)\n \n       /* Determine which parameter packs will be used by the base\n          class expansion.  */\n-      ppd.visited = pointer_set_create ();\n+      ppd.visited = new hash_set<tree>;\n       ppd.parameter_packs = &parameter_packs;\n       cp_walk_tree (&TREE_PURPOSE (arg), &find_parameter_packs_r, \n                     &ppd, ppd.visited);\n \n       if (parameter_packs == NULL_TREE)\n         {\n           error (\"base initializer expansion %<%T%> contains no parameter packs\", arg);\n-          pointer_set_destroy (ppd.visited);\n+          delete ppd.visited;\n           return error_mark_node;\n         }\n \n@@ -3320,7 +3320,7 @@ make_pack_expansion (tree arg)\n             }\n         }\n \n-      pointer_set_destroy (ppd.visited);\n+      delete ppd.visited;\n \n       /* Create the pack expansion type for the base type.  */\n       purpose = cxx_make_type (TYPE_PACK_EXPANSION);\n@@ -3355,9 +3355,9 @@ make_pack_expansion (tree arg)\n \n   /* Determine which parameter packs will be expanded.  */\n   ppd.parameter_packs = &parameter_packs;\n-  ppd.visited = pointer_set_create ();\n+  ppd.visited = new hash_set<tree>;\n   cp_walk_tree (&arg, &find_parameter_packs_r, &ppd, ppd.visited);\n-  pointer_set_destroy (ppd.visited);\n+  delete ppd.visited;\n \n   /* Make sure we found some parameter packs.  */\n   if (parameter_packs == NULL_TREE)\n@@ -3402,9 +3402,9 @@ check_for_bare_parameter_packs (tree t)\n     t = TREE_TYPE (t);\n \n   ppd.parameter_packs = &parameter_packs;\n-  ppd.visited = pointer_set_create ();\n+  ppd.visited = new hash_set<tree>;\n   cp_walk_tree (&t, &find_parameter_packs_r, &ppd, ppd.visited);\n-  pointer_set_destroy (ppd.visited);\n+  delete ppd.visited;\n \n   if (parameter_packs) \n     {\n@@ -4384,11 +4384,11 @@ fixed_parameter_pack_p (tree parm)\n   tree parameter_packs = NULL_TREE;\n   struct find_parameter_pack_data ppd;\n   ppd.parameter_packs = &parameter_packs;\n-  ppd.visited = pointer_set_create ();\n+  ppd.visited = new hash_set<tree>;\n \n   fixed_parameter_pack_p_1 (parm, &ppd);\n \n-  pointer_set_destroy (ppd.visited);\n+  delete ppd.visited;\n   return parameter_packs;\n }\n \n@@ -7925,7 +7925,7 @@ struct pair_fn_data\n   /* True when we should also visit template parameters that occur in\n      non-deduced contexts.  */\n   bool include_nondeduced_p;\n-  struct pointer_set_t *visited;\n+  hash_set<tree> *visited;\n };\n \n /* Called from for_each_template_parm via walk_tree.  */\n@@ -8125,7 +8125,7 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n \n static int\n for_each_template_parm (tree t, tree_fn_t fn, void* data,\n-\t\t\tstruct pointer_set_t *visited,\n+\t\t\thash_set<tree> *visited,\n \t\t\tbool include_nondeduced_p)\n {\n   struct pair_fn_data pfd;\n@@ -8144,7 +8144,7 @@ for_each_template_parm (tree t, tree_fn_t fn, void* data,\n   if (visited)\n     pfd.visited = visited;\n   else\n-    pfd.visited = pointer_set_create ();\n+    pfd.visited = new hash_set<tree>;\n   result = cp_walk_tree (&t,\n \t\t         for_each_template_parm_r,\n \t\t         &pfd,\n@@ -8153,7 +8153,7 @@ for_each_template_parm (tree t, tree_fn_t fn, void* data,\n   /* Clean up.  */\n   if (!visited)\n     {\n-      pointer_set_destroy (pfd.visited);\n+      delete pfd.visited;\n       pfd.visited = 0;\n     }\n "}, {"sha": "735284ec782509929fe0bb440c088fefc3759d27", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -8031,16 +8031,16 @@ register_constexpr_fundef (tree fun, tree body)\n void\n explain_invalid_constexpr_fn (tree fun)\n {\n-  static struct pointer_set_t *diagnosed;\n+  static hash_set<tree> *diagnosed;\n   tree body;\n   location_t save_loc;\n   /* Only diagnose defaulted functions or instantiations.  */\n   if (!DECL_DEFAULTED_FN (fun)\n       && !is_instantiation_of_constexpr (fun))\n     return;\n   if (diagnosed == NULL)\n-    diagnosed = pointer_set_create ();\n-  if (pointer_set_insert (diagnosed, fun) != 0)\n+    diagnosed = new hash_set<tree>;\n+  if (diagnosed->add (fun))\n     /* Already explained.  */\n     return;\n "}, {"sha": "3b53039cde3e1ae55e514e1635604b900065e294", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -3485,7 +3485,7 @@ cxx_type_hash_eq (const_tree typea, const_tree typeb)\n \n tree\n cp_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func,\n-\t\t  void *data, struct pointer_set_t *pset)\n+\t\t  void *data, hash_set<tree> *pset)\n {\n   enum tree_code code = TREE_CODE (*tp);\n   tree result;"}, {"sha": "4234afabe5e33aa07133cd36fc41e5832240af30", "filename": "gcc/cprop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -167,7 +167,7 @@ reg_available_p (const_rtx x, const_rtx insn ATTRIBUTE_UNUSED)\n    ??? May need to make things more elaborate.  Later, as necessary.  */\n \n static unsigned int\n-hash_set (int regno, int hash_table_size)\n+hash_mod (int regno, int hash_table_size)\n {\n   return (unsigned) regno % hash_table_size;\n }\n@@ -187,7 +187,7 @@ insert_set_in_table (rtx dest, rtx src, rtx insn, struct hash_table_d *table,\n   struct expr *cur_expr, *last_expr = NULL;\n   struct occr *cur_occr;\n \n-  hash = hash_set (REGNO (dest), table->size);\n+  hash = hash_mod (REGNO (dest), table->size);\n \n   for (cur_expr = table->table[hash]; cur_expr;\n        cur_expr = cur_expr->next_same_hash)\n@@ -483,7 +483,7 @@ compute_hash_table (struct hash_table_d *table)\n static struct expr *\n lookup_set (unsigned int regno, struct hash_table_d *table)\n {\n-  unsigned int hash = hash_set (regno, table->size);\n+  unsigned int hash = hash_mod (regno, table->size);\n   struct expr *expr;\n \n   expr = table->table[hash];"}, {"sha": "dd9a076fcfa42fba23f6444dd315fa05bda6292b", "filename": "gcc/cse.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -41,7 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"df.h\"\n #include \"dbgcnt.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-set.h\"\n \n /* The basic idea of common subexpression elimination is to go\n    through the code, keeping a record of expressions that would\n@@ -2906,7 +2906,7 @@ find_comparison_args (enum rtx_code code, rtx *parg1, rtx *parg2,\n \t\t      enum machine_mode *pmode1, enum machine_mode *pmode2)\n {\n   rtx arg1, arg2;\n-  struct pointer_set_t *visited = NULL;\n+  hash_set<rtx> *visited = NULL;\n   /* Set nonzero when we find something of interest.  */\n   rtx x = NULL;\n \n@@ -2923,8 +2923,8 @@ find_comparison_args (enum rtx_code code, rtx *parg1, rtx *parg2,\n       if (x)\n \t{\n \t  if (!visited)\n-\t    visited = pointer_set_create ();\n-\t  pointer_set_insert (visited, x);\n+\t    visited = new hash_set<rtx>;\n+\t  visited->add (x);\n \t  x = 0;\n \t}\n \n@@ -3005,7 +3005,7 @@ find_comparison_args (enum rtx_code code, rtx *parg1, rtx *parg2,\n \t    continue;\n \n \t  /* If it's a comparison we've used before, skip it.  */\n-\t  if (visited && pointer_set_contains (visited, p->exp))\n+\t  if (visited && visited->contains (p->exp))\n \t    continue;\n \n \t  if (GET_CODE (p->exp) == COMPARE\n@@ -3087,7 +3087,7 @@ find_comparison_args (enum rtx_code code, rtx *parg1, rtx *parg2,\n   *parg1 = fold_rtx (arg1, 0), *parg2 = fold_rtx (arg2, 0);\n \n   if (visited)\n-    pointer_set_destroy (visited);\n+    delete visited;\n   return code;\n }\n \f"}, {"sha": "baf8d5348ed2b9e4efe66667c7e1399557156e0a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -1,3 +1,7 @@\n+2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* openmp.c, trans-decl.c: Use hash_set instead of pointer_set.\n+\n 2014-07-26  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/61881"}, {"sha": "410efb11c49bce4f8309bbfb9b565f6098508d83", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -26,7 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"arith.h\"\n #include \"match.h\"\n #include \"parse.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-set.h\"\n \n /* Match an end of OpenMP directive.  End of OpenMP directive is optional\n    whitespace, followed by '\\n' or comment '!'.  */\n@@ -3013,8 +3013,8 @@ resolve_omp_atomic (gfc_code *code)\n struct omp_context\n {\n   gfc_code *code;\n-  struct pointer_set_t *sharing_clauses;\n-  struct pointer_set_t *private_iterators;\n+  hash_set<gfc_symbol *> *sharing_clauses;\n+  hash_set<gfc_symbol *> *private_iterators;\n   struct omp_context *previous;\n } *omp_current_ctx;\n static gfc_code *omp_current_do_code;\n@@ -3057,8 +3057,8 @@ gfc_resolve_omp_parallel_blocks (gfc_code *code, gfc_namespace *ns)\n   int list;\n \n   ctx.code = code;\n-  ctx.sharing_clauses = pointer_set_create ();\n-  ctx.private_iterators = pointer_set_create ();\n+  ctx.sharing_clauses = new hash_set<gfc_symbol *>;\n+  ctx.private_iterators = new hash_set<gfc_symbol *>;\n   ctx.previous = omp_current_ctx;\n   omp_current_ctx = &ctx;\n \n@@ -3072,7 +3072,7 @@ gfc_resolve_omp_parallel_blocks (gfc_code *code, gfc_namespace *ns)\n       case OMP_LIST_REDUCTION:\n       case OMP_LIST_LINEAR:\n \tfor (n = omp_clauses->lists[list]; n; n = n->next)\n-\t  pointer_set_insert (ctx.sharing_clauses, n->sym);\n+\t  ctx.sharing_clauses->add (n->sym);\n \tbreak;\n       default:\n \tbreak;\n@@ -3097,8 +3097,8 @@ gfc_resolve_omp_parallel_blocks (gfc_code *code, gfc_namespace *ns)\n     }\n \n   omp_current_ctx = ctx.previous;\n-  pointer_set_destroy (ctx.sharing_clauses);\n-  pointer_set_destroy (ctx.private_iterators);\n+  delete ctx.sharing_clauses;\n+  delete ctx.private_iterators;\n }\n \n \n@@ -3154,10 +3154,10 @@ gfc_resolve_do_iterator (gfc_code *code, gfc_symbol *sym)\n   if (omp_current_ctx == NULL)\n     return;\n \n-  if (pointer_set_contains (omp_current_ctx->sharing_clauses, sym))\n+  if (omp_current_ctx->sharing_clauses->contains (sym))\n     return;\n \n-  if (! pointer_set_insert (omp_current_ctx->private_iterators, sym))\n+  if (! omp_current_ctx->private_iterators->add (sym))\n     {\n       gfc_omp_clauses *omp_clauses = omp_current_ctx->code->ext.omp_clauses;\n       gfc_omp_namelist *p;"}, {"sha": "babe48f56a2b130046ef59d560585871e90f1317", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -40,7 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"debug.h\"\n #include \"gfortran.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-set.h\"\n #include \"constructor.h\"\n #include \"trans.h\"\n #include \"trans-types.h\"\n@@ -63,7 +63,7 @@ static GTY(()) tree parent_fake_result_decl;\n static GTY(()) tree saved_function_decls;\n static GTY(()) tree saved_parent_function_decls;\n \n-static struct pointer_set_t *nonlocal_dummy_decl_pset;\n+static hash_set<tree> *nonlocal_dummy_decl_pset;\n static GTY(()) tree nonlocal_dummy_decls;\n \n /* Holds the variable DECLs that are locals.  */\n@@ -1094,9 +1094,9 @@ gfc_nonlocal_dummy_array_decl (gfc_symbol *sym)\n   tree decl, dummy;\n \n   if (! nonlocal_dummy_decl_pset)\n-    nonlocal_dummy_decl_pset = pointer_set_create ();\n+    nonlocal_dummy_decl_pset = new hash_set<tree>;\n \n-  if (pointer_set_insert (nonlocal_dummy_decl_pset, sym->backend_decl))\n+  if (nonlocal_dummy_decl_pset->add (sym->backend_decl))\n     return;\n \n   dummy = GFC_DECL_SAVED_DESCRIPTOR (sym->backend_decl);\n@@ -5861,7 +5861,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n     {\n       BLOCK_VARS (DECL_INITIAL (fndecl))\n \t= chainon (BLOCK_VARS (DECL_INITIAL (fndecl)), nonlocal_dummy_decls);\n-      pointer_set_destroy (nonlocal_dummy_decl_pset);\n+      delete nonlocal_dummy_decl_pset;\n       nonlocal_dummy_decls = NULL;\n       nonlocal_dummy_decl_pset = NULL;\n     }"}, {"sha": "f4f67572c81b2bb7d54b2cc61aea605f28dc6600", "filename": "gcc/gimple-walk.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fgimple-walk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fgimple-walk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-walk.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -180,7 +180,7 @@ tree\n walk_gimple_op (gimple stmt, walk_tree_fn callback_op,\n \t\tstruct walk_stmt_info *wi)\n {\n-  struct pointer_set_t *pset = (wi) ? wi->pset : NULL;\n+  hash_set<tree> *pset = (wi) ? wi->pset : NULL;\n   unsigned i;\n   tree ret = NULL_TREE;\n "}, {"sha": "5b75fdc3f41c5c20acf9bf253ecada419865ceb9", "filename": "gcc/gimple-walk.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fgimple-walk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fgimple-walk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-walk.h?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -36,7 +36,7 @@ struct walk_stmt_info\n   /* Pointer map used to mark visited tree nodes when calling\n      walk_tree on each operand.  If set to NULL, duplicate tree nodes\n      will be visited more than once.  */\n-  struct pointer_set_t *pset;\n+  hash_set<tree> *pset;\n \n   /* Operand returned by the callbacks.  This is set when calling\n      walk_gimple_seq.  If the walk_stmt_fn or walk_tree_fn callback"}, {"sha": "c0ae7cc785117c5295ef171084687e29c3a3b309", "filename": "gcc/gimplify.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tree.h\"\n #include \"expr.h\"\n+#include \"hash-set.h\"\n #include \"pointer-set.h\"\n #include \"hash-table.h\"\n #include \"basic-block.h\"\n@@ -134,7 +135,7 @@ struct gimplify_omp_ctx\n {\n   struct gimplify_omp_ctx *outer_context;\n   splay_tree variables;\n-  struct pointer_set_t *privatized_types;\n+  hash_set<tree> *privatized_types;\n   location_t location;\n   enum omp_clause_default_kind default_kind;\n   enum omp_region_type region_type;\n@@ -352,7 +353,7 @@ new_omp_context (enum omp_region_type region_type)\n   c = XCNEW (struct gimplify_omp_ctx);\n   c->outer_context = gimplify_omp_ctxp;\n   c->variables = splay_tree_new (splay_tree_compare_decl_uid, 0, 0);\n-  c->privatized_types = pointer_set_create ();\n+  c->privatized_types = new hash_set<tree>;\n   c->location = input_location;\n   c->region_type = region_type;\n   if ((region_type & ORT_TASK) == 0)\n@@ -369,7 +370,7 @@ static void\n delete_omp_context (struct gimplify_omp_ctx *c)\n {\n   splay_tree_delete (c->variables);\n-  pointer_set_destroy (c->privatized_types);\n+  delete c->privatized_types;\n   XDELETE (c);\n }\n \n@@ -744,7 +745,7 @@ mostly_copy_tree_r (tree *tp, int *walk_subtrees, void *data)\n      copy their subtrees if we can make sure to do it only once.  */\n   if (code == SAVE_EXPR || code == TARGET_EXPR || code == BIND_EXPR)\n     {\n-      if (data && !pointer_set_insert ((struct pointer_set_t *)data, t))\n+      if (data && !((hash_set<tree> *)data)->add (t))\n \t;\n       else\n \t*walk_subtrees = 0;\n@@ -829,15 +830,14 @@ unshare_body (tree fndecl)\n   struct cgraph_node *cgn = cgraph_node::get (fndecl);\n   /* If the language requires deep unsharing, we need a pointer set to make\n      sure we don't repeatedly unshare subtrees of unshareable nodes.  */\n-  struct pointer_set_t *visited\n-    = lang_hooks.deep_unsharing ? pointer_set_create () : NULL;\n+  hash_set<tree> *visited\n+    = lang_hooks.deep_unsharing ? new hash_set<tree> : NULL;\n \n   copy_if_shared (&DECL_SAVED_TREE (fndecl), visited);\n   copy_if_shared (&DECL_SIZE (DECL_RESULT (fndecl)), visited);\n   copy_if_shared (&DECL_SIZE_UNIT (DECL_RESULT (fndecl)), visited);\n \n-  if (visited)\n-    pointer_set_destroy (visited);\n+  delete visited;\n \n   if (cgn)\n     for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n@@ -1733,7 +1733,7 @@ gimplify_conversion (tree *expr_p)\n }\n \n /* Nonlocal VLAs seen in the current function.  */\n-static struct pointer_set_t *nonlocal_vlas;\n+static hash_set<tree> *nonlocal_vlas;\n \n /* The VAR_DECLs created for nonlocal VLAs for debug info purposes.  */\n static tree nonlocal_vla_vars;\n@@ -1784,7 +1784,7 @@ gimplify_var_or_parm_decl (tree *expr_p)\n \t\t && (ctx->region_type == ORT_WORKSHARE\n \t\t     || ctx->region_type == ORT_SIMD))\n \t    ctx = ctx->outer_context;\n-\t  if (!ctx && !pointer_set_insert (nonlocal_vlas, decl))\n+\t  if (!ctx && !nonlocal_vlas->add (decl))\n \t    {\n \t      tree copy = copy_node (decl);\n \n@@ -5463,7 +5463,7 @@ omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *ctx, tree type)\n     return;\n   type = TYPE_MAIN_VARIANT (type);\n \n-  if (pointer_set_insert (ctx->privatized_types, type))\n+  if (ctx->privatized_types->add (type))\n     return;\n \n   switch (TREE_CODE (type))\n@@ -8766,7 +8766,7 @@ gimplify_body (tree fndecl, bool do_parms)\n \n   cgn = cgraph_node::get (fndecl);\n   if (cgn && cgn->origin)\n-    nonlocal_vlas = pointer_set_create ();\n+    nonlocal_vlas = new hash_set<tree>;\n \n   /* Make sure input_location isn't set to something weird.  */\n   input_location = DECL_SOURCE_LOCATION (fndecl);\n@@ -8830,7 +8830,7 @@ gimplify_body (tree fndecl, bool do_parms)\n \t\t\t nonlocal_vla_vars);\n \t  nonlocal_vla_vars = NULL_TREE;\n \t}\n-      pointer_set_destroy (nonlocal_vlas);\n+      delete nonlocal_vlas;\n       nonlocal_vlas = NULL;\n     }\n "}, {"sha": "7566f4d3effae89f779644e559aabcc80ba13ee4", "filename": "gcc/godump.c", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fgodump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fgodump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgodump.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -33,7 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"tree.h\"\n #include \"ggc.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-set.h\"\n #include \"obstack.h\"\n #include \"debug.h\"\n #include \"wide-int-print.h\"\n@@ -525,11 +525,11 @@ go_type_decl (tree decl, int local)\n struct godump_container\n {\n   /* DECLs that we have already seen.  */\n-  struct pointer_set_t *decls_seen;\n+  hash_set<tree> decls_seen;\n \n   /* Types which may potentially have to be defined as dummy\n      types.  */\n-  struct pointer_set_t *pot_dummy_types;\n+  hash_set<const char *> pot_dummy_types;\n \n   /* Go keywords.  */\n   htab_t keyword_hash;\n@@ -569,8 +569,8 @@ go_format_type (struct godump_container *container, tree type,\n   ob = &container->type_obstack;\n \n   if (TYPE_NAME (type) != NULL_TREE\n-      && (pointer_set_contains (container->decls_seen, type)\n-\t  || pointer_set_contains (container->decls_seen, TYPE_NAME (type)))\n+      && (container->decls_seen.contains (type)\n+\t  || container->decls_seen.contains (TYPE_NAME (type)))\n       && (AGGREGATE_TYPE_P (type)\n \t  || POINTER_TYPE_P (type)\n \t  || TREE_CODE (type) == FUNCTION_TYPE))\n@@ -590,7 +590,7 @@ go_format_type (struct godump_container *container, tree type,\n       return ret;\n     }\n \n-  pointer_set_insert (container->decls_seen, type);\n+  container->decls_seen.add (type);\n \n   switch (TREE_CODE (type))\n     {\n@@ -697,8 +697,7 @@ go_format_type (struct godump_container *container, tree type,\n \t     definition.  So this struct or union is a potential dummy\n \t     type.  */\n \t  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (type)))\n-\t    pointer_set_insert (container->pot_dummy_types,\n-\t\t\t\tIDENTIFIER_POINTER (name));\n+\t    container->pot_dummy_types.add (IDENTIFIER_POINTER (name));\n \n \t  return ret;\n         }\n@@ -948,10 +947,10 @@ go_output_typedef (struct godump_container *container, tree decl)\n      separately.  */\n   if (TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE\n       && TYPE_SIZE (TREE_TYPE (decl)) != 0\n-      && !pointer_set_contains (container->decls_seen, TREE_TYPE (decl))\n+      && !container->decls_seen.contains (TREE_TYPE (decl))\n       && (TYPE_CANONICAL (TREE_TYPE (decl)) == NULL_TREE\n-\t  || !pointer_set_contains (container->decls_seen,\n-\t\t\t\t    TYPE_CANONICAL (TREE_TYPE (decl)))))\n+\t  || !container->decls_seen.contains\n+\t\t\t\t    (TYPE_CANONICAL (TREE_TYPE (decl)))))\n     {\n       tree element;\n \n@@ -988,10 +987,9 @@ go_output_typedef (struct godump_container *container, tree decl)\n \t  mhval->value = xstrdup (buf);\n \t  *slot = mhval;\n \t}\n-      pointer_set_insert (container->decls_seen, TREE_TYPE (decl));\n+      container->decls_seen.add (TREE_TYPE (decl));\n       if (TYPE_CANONICAL (TREE_TYPE (decl)) != NULL_TREE)\n-\tpointer_set_insert (container->decls_seen,\n-\t\t\t    TYPE_CANONICAL (TREE_TYPE (decl)));\n+\tcontainer->decls_seen.add (TYPE_CANONICAL (TREE_TYPE (decl)));\n     }\n \n   if (DECL_NAME (decl) != NULL_TREE)\n@@ -1027,7 +1025,7 @@ go_output_typedef (struct godump_container *container, tree decl)\n \t\t     size);\n \t}\n \n-      pointer_set_insert (container->decls_seen, decl);\n+      container->decls_seen.add (decl);\n     }\n   else if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (decl)))\n     {\n@@ -1072,11 +1070,11 @@ go_output_var (struct godump_container *container, tree decl)\n {\n   bool is_valid;\n \n-  if (pointer_set_contains (container->decls_seen, decl)\n-      || pointer_set_contains (container->decls_seen, DECL_NAME (decl)))\n+  if (container->decls_seen.contains (decl)\n+      || container->decls_seen.contains (DECL_NAME (decl)))\n     return;\n-  pointer_set_insert (container->decls_seen, decl);\n-  pointer_set_insert (container->decls_seen, DECL_NAME (decl));\n+  container->decls_seen.add (decl);\n+  container->decls_seen.add (DECL_NAME (decl));\n \n   is_valid = go_format_type (container, TREE_TYPE (decl), true, false);\n   if (is_valid\n@@ -1103,11 +1101,10 @@ go_output_var (struct godump_container *container, tree decl)\n     {\n       tree type_name = TYPE_NAME (TREE_TYPE (decl));\n       if (TREE_CODE (type_name) == IDENTIFIER_NODE)\n-\tpointer_set_insert (container->pot_dummy_types,\n-\t\t\t    IDENTIFIER_POINTER (type_name));\n+\tcontainer->pot_dummy_types.add (IDENTIFIER_POINTER (type_name));\n       else if (TREE_CODE (type_name) == TYPE_DECL)\n-\tpointer_set_insert (container->pot_dummy_types,\n-\t\t\t    IDENTIFIER_POINTER (DECL_NAME (type_name)));\n+\tcontainer->pot_dummy_types.add\n+\t\t\t    (IDENTIFIER_POINTER (DECL_NAME (type_name)));\n     }\n }\n \n@@ -1147,10 +1144,10 @@ keyword_hash_init (struct godump_container *container)\n \n /* Traversing the pot_dummy_types and seeing which types are present\n    in the global types hash table and creating dummy definitions if\n-   not found.  This function is invoked by pointer_set_traverse.  */\n+   not found.  This function is invoked by hash_set::traverse.  */\n \n-static bool\n-find_dummy_types (const void *ptr, void *adata)\n+bool\n+find_dummy_types (const char *const &ptr, godump_container *adata)\n {\n   struct godump_container *data = (struct godump_container *) adata;\n   const char *type = (const char *) ptr;\n@@ -1175,8 +1172,6 @@ go_finish (const char *filename)\n \n   real_debug_hooks->finish (filename);\n \n-  container.decls_seen = pointer_set_create ();\n-  container.pot_dummy_types = pointer_set_create ();\n   container.type_hash = htab_create (100, htab_hash_string,\n                                      string_hash_eq, NULL);\n   container.invalid_hash = htab_create (10, htab_hash_string,\n@@ -1211,11 +1206,9 @@ go_finish (const char *filename)\n   htab_traverse_noresize (macro_hash, go_print_macro, NULL);\n \n   /* To emit dummy definitions.  */\n-  pointer_set_traverse (container.pot_dummy_types, find_dummy_types,\n-                        (void *) &container);\n+  container.pot_dummy_types.traverse<godump_container *, find_dummy_types>\n+                        (&container);\n \n-  pointer_set_destroy (container.decls_seen);\n-  pointer_set_destroy (container.pot_dummy_types);\n   htab_delete (container.type_hash);\n   htab_delete (container.invalid_hash);\n   htab_delete (container.keyword_hash);"}, {"sha": "47bae9ed77d4604c58cc8622e62693cd7335d1a2", "filename": "gcc/hash-set.h", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fhash-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fhash-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-set.h?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -0,0 +1,173 @@\n+/* A type-safe hash set.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#ifndef hash_set_h\n+#define hash_set_h\n+\n+#include \"hash-table.h\"\n+\n+/* implement default behavior for traits when types allow it.  */\n+\n+struct default_hashset_traits\n+{\n+  /* Hashes the passed in key.  */\n+\n+  template<typename T>\n+  static hashval_t\n+  hash (T *p)\n+    {\n+      return uintptr_t(p) >> 3;\n+    }\n+\n+  template<typename T> static hashval_t hash(const T &v) { return v; }\n+\n+  /* Return true if the two keys passed as arguments are equal.  */\n+\n+  template<typename T>\n+  static bool\n+  equal (const T &a, const T &b)\n+    {\n+      return a == b;\n+    }\n+\n+  /* Called to dispose of the key before marking the entry as deleted.  */\n+\n+  template<typename T> static void remove (T &v) { v.~T (); }\n+\n+  /* Mark the passed in entry as being deleted.  */\n+\n+  template<typename T>\n+  static void\n+  mark_deleted (T *&e)\n+    {\n+      e = reinterpret_cast<void *> (1);\n+    }\n+\n+  /* Mark the passed in entry as being empty.  */\n+\n+  template<typename T>\n+  static void\n+  mark_empty (T *&e)\n+    {\n+      e = NULL;\n+    }\n+\n+  /* Return true if the passed in entry is marked as deleted.  */\n+\n+  template<typename T>\n+  static bool\n+  is_deleted (T *e)\n+    {\n+      return e == reinterpret_cast<void *> (1);\n+    }\n+\n+  /* Return true if the passed in entry is marked as empty.  */\n+\n+  template<typename T> static bool is_empty (T *e) { return e == NULL; }\n+};\n+\n+template<typename Key, typename Traits = default_hashset_traits>\n+class hash_set\n+{\n+  struct hash_entry\n+  {\n+    Key m_key;\n+\n+    typedef hash_entry value_type;\n+    typedef Key compare_type;\n+    typedef int store_values_directly;\n+\n+    static hashval_t hash (const hash_entry &e)\n+      {\n+       \treturn Traits::hash (e.m_key);\n+      }\n+\n+    static bool equal (const hash_entry &a, const Key &b)\n+       \t{\n+\t  return Traits::equal (a.m_key, b);\n+       \t}\n+\n+    static void remove (hash_entry &e) { Traits::remove (e.m_key); }\n+\n+    static void\n+    mark_deleted (hash_entry &e)\n+      {\n+       \tTraits::mark_deleted (e.m_key);\n+      }\n+\n+    static bool is_deleted (const hash_entry &e)\n+      {\n+       \treturn Traits::is_deleted (e.m_key);\n+      }\n+\n+    static void\n+    mark_empty (hash_entry &e)\n+      {\n+\tTraits::mark_empty (e.m_key);\n+      }\n+\n+    static bool\n+    is_empty (const hash_entry &e)\n+      {\n+\treturn Traits::is_empty (e.m_key);\n+      }\n+  };\n+\n+public:\n+  explicit hash_set (size_t n = 13) : m_table (n) {}\n+\n+  /* If key k isn't already in the map add it to the map, and\n+     return false.  Otherwise return true.  */\n+\n+  bool add (const Key &k)\n+    {\n+      hash_entry *e = m_table.find_slot_with_hash (k, Traits::hash (k),\n+\t\t\t\t\t\t   INSERT);\n+      bool existed = !hash_entry::is_empty (*e);\n+      if (!existed)\n+\te->m_key = k;\n+\n+      return existed;\n+    }\n+\n+  /* if the passed in key is in the map return its value otherwise NULL.  */\n+\n+  bool contains (const Key &k)\n+    {\n+      hash_entry &e = m_table.find_with_hash (k, Traits::hash (k));\n+      return !Traits::is_empty (e.m_key);\n+    }\n+\n+  /* Call the call back on each pair of key and value with the passed in\n+     arg.  */\n+\n+  template<typename Arg, bool (*f)(const Key &, Arg)>\n+  void traverse (Arg a) const\n+    {\n+      for (typename hash_table<hash_entry>::iterator iter = m_table.begin ();\n+\t   iter != m_table.end (); ++iter)\n+\tf ((*iter).m_key, a);\n+    }\n+\n+private:\n+  hash_table<hash_entry> m_table;\n+};\n+\n+#endif"}, {"sha": "5484ccde4a6d9c6695a6e91d7560bedc7a7c7e27", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 46, "deletions": 53, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -115,7 +115,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"expr.h\"\n #include \"tree-pass.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-set.h\"\n #include \"target.h\"\n #include \"hash-table.h\"\n #include \"inchash.h\"\n@@ -134,7 +134,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stor-layout.h\"\n #include \"intl.h\"\n \n-static bool odr_types_equivalent_p (tree, tree, bool, bool *, pointer_set_t *);\n+static bool odr_types_equivalent_p (tree, tree, bool, bool *,\n+\t\t\t\t    hash_set<tree> *);\n \n static bool odr_violation_reported = false;\n \n@@ -144,7 +145,7 @@ const ipa_polymorphic_call_context ipa_dummy_polymorphic_call_context\n    = {0, 0, NULL, NULL, false, true, true};\n \n /* Pointer set of all call targets appearing in the cache.  */\n-static pointer_set_t *cached_polymorphic_call_targets;\n+static hash_set<cgraph_node *> *cached_polymorphic_call_targets;\n \n /* The node of type inheritance graph.  For each type unique in\n    One Defintion Rule (ODR) sense, we produce one node linking all \n@@ -163,7 +164,7 @@ struct GTY(()) odr_type_d\n   /* All equivalent types, if more than one.  */\n   vec<tree, va_gc> *types;\n   /* Set of all equivalent types, if NON-NULL.  */\n-  pointer_set_t * GTY((skip)) types_set;\n+  hash_set<tree> * GTY((skip)) types_set;\n \n   /* Unique ID indexing the type in odr_types array.  */\n   int id;\n@@ -411,7 +412,7 @@ odr_hasher::remove (value_type *v)\n   v->bases.release ();\n   v->derived_types.release ();\n   if (v->types_set)\n-    pointer_set_destroy (v->types_set);\n+    delete v->types_set;\n   ggc_free (v);\n }\n \n@@ -441,7 +442,7 @@ set_type_binfo (tree type, tree binfo)\n /* Compare T2 and T2 based on name or structure.  */\n \n static bool\n-odr_subtypes_equivalent_p (tree t1, tree t2, pointer_set_t *visited)\n+odr_subtypes_equivalent_p (tree t1, tree t2, hash_set<tree> *visited)\n {\n   bool an1, an2;\n \n@@ -475,7 +476,7 @@ odr_subtypes_equivalent_p (tree t1, tree t2, pointer_set_t *visited)\n       /* This should really be a pair hash, but for the moment we do not need\n \t 100% reliability and it would be better to compare all ODR types so\n \t recursion here is needed only for component types.  */\n-      if (pointer_set_insert (visited, t1))\n+      if (visited->add (t1))\n \treturn true;\n       return odr_types_equivalent_p (t1, t2, false, NULL, visited);\n     }\n@@ -564,7 +565,7 @@ warn_types_mismatch (tree t1, tree t2)\n    gimple_canonical_types_compatible_p.  */\n \n static bool\n-odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned, pointer_set_t *visited)\n+odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned, hash_set<tree> *visited)\n {\n   /* Check first for the obvious case of pointer identity.  */\n   if (t1 == t2)\n@@ -940,7 +941,7 @@ add_type_duplicate (odr_type val, tree type)\n {\n   bool build_bases = false;\n   if (!val->types_set)\n-    val->types_set = pointer_set_create ();\n+    val->types_set = new hash_set<tree>;\n \n   /* Always prefer complete type to be the leader.  */\n   if (!COMPLETE_TYPE_P (val->type)\n@@ -954,20 +955,20 @@ add_type_duplicate (odr_type val, tree type)\n     }\n \n   /* See if this duplicate is new.  */\n-  if (!pointer_set_insert (val->types_set, type))\n+  if (!val->types_set->add (type))\n     {\n       bool merge = true;\n       bool base_mismatch = false;\n       unsigned int i,j;\n       bool warned = false;\n-      pointer_set_t *visited = pointer_set_create ();\n+      hash_set<tree> visited;\n \n       gcc_assert (in_lto_p);\n       vec_safe_push (val->types, type);\n \n       /* First we compare memory layout.  */\n       if (!odr_types_equivalent_p (val->type, type, !flag_ltrans && !val->odr_violated,\n-\t\t\t\t   &warned, visited))\n+\t\t\t\t   &warned, &visited))\n \t{\n \t  merge = false;\n \t  odr_violation_reported = true;\n@@ -982,7 +983,6 @@ add_type_duplicate (odr_type val, tree type)\n \t      putc ('\\n',cgraph_dump_file);\n \t    }\n \t}\n-      pointer_set_destroy (visited);\n \n       /* Next sanity check that bases are the same.  If not, we will end\n \t up producing wrong answers.  */\n@@ -1358,7 +1358,7 @@ referenced_from_vtable_p (struct cgraph_node *node)\n \n static void\n maybe_record_node (vec <cgraph_node *> &nodes,\n-\t\t   tree target, pointer_set_t *inserted,\n+\t\t   tree target, hash_set<tree> *inserted,\n \t\t   bool can_refer,\n \t\t   bool *completep)\n {\n@@ -1424,10 +1424,9 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n     {\n       gcc_assert (!target_node->global.inlined_to);\n       gcc_assert (target_node->real_symbol_p ());\n-      if (!pointer_set_insert (inserted, target_node->decl))\n+      if (!inserted->add (target))\n \t{\n-\t  pointer_set_insert (cached_polymorphic_call_targets,\n-\t\t\t      target_node);\n+\t  cached_polymorphic_call_targets->add (target_node);\n \t  nodes.safe_push (target_node);\n \t}\n     }\n@@ -1467,8 +1466,8 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n \t\t\t  HOST_WIDE_INT otr_token,\n \t\t\t  tree outer_type,\n \t\t\t  HOST_WIDE_INT offset,\n-\t\t\t  pointer_set_t *inserted,\n-\t\t\t  pointer_set_t *matched_vtables,\n+\t\t\t  hash_set<tree> *inserted,\n+\t\t\t  hash_set<tree> *matched_vtables,\n \t\t\t  bool anonymous,\n \t\t\t  bool *completep)\n {\n@@ -1521,8 +1520,8 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n \t}\n       gcc_assert (inner_binfo);\n       if (bases_to_consider\n-\t  ? !pointer_set_contains (matched_vtables, BINFO_VTABLE (inner_binfo))\n-\t  : !pointer_set_insert (matched_vtables, BINFO_VTABLE (inner_binfo)))\n+\t  ? !matched_vtables->contains (BINFO_VTABLE (inner_binfo))\n+\t  : !matched_vtables->add (BINFO_VTABLE (inner_binfo)))\n \t{\n \t  bool can_refer;\n \t  tree target = gimple_get_virt_method_for_binfo (otr_token,\n@@ -1561,8 +1560,8 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n \n static void\n possible_polymorphic_call_targets_1 (vec <cgraph_node *> &nodes,\n-\t\t\t\t     pointer_set_t *inserted,\n-\t\t\t\t     pointer_set_t *matched_vtables,\n+\t\t\t\t     hash_set<tree> *inserted,\n+\t\t\t\t     hash_set<tree> *matched_vtables,\n \t\t\t\t     tree otr_type,\n \t\t\t\t     odr_type type,\n \t\t\t\t     HOST_WIDE_INT otr_token,\n@@ -1695,7 +1694,7 @@ free_polymorphic_call_targets_hash ()\n     {\n       delete polymorphic_call_target_hash;\n       polymorphic_call_target_hash = NULL;\n-      pointer_set_destroy (cached_polymorphic_call_targets);\n+      delete cached_polymorphic_call_targets;\n       cached_polymorphic_call_targets = NULL;\n     }\n }\n@@ -1706,7 +1705,7 @@ static void\n devirt_node_removal_hook (struct cgraph_node *n, void *d ATTRIBUTE_UNUSED)\n {\n   if (cached_polymorphic_call_targets\n-      && pointer_set_contains (cached_polymorphic_call_targets, n))\n+      && cached_polymorphic_call_targets->contains (n))\n     free_polymorphic_call_targets_hash ();\n }\n \n@@ -2436,8 +2435,8 @@ record_targets_from_bases (tree otr_type,\n \t\t\t   tree outer_type,\n \t\t\t   HOST_WIDE_INT offset,\n \t\t\t   vec <cgraph_node *> &nodes,\n-\t\t\t   pointer_set_t *inserted,\n-\t\t\t   pointer_set_t *matched_vtables,\n+\t\t\t   hash_set<tree> *inserted,\n+\t\t\t   hash_set<tree> *matched_vtables,\n \t\t\t   bool *completep)\n {\n   while (true)\n@@ -2478,15 +2477,15 @@ record_targets_from_bases (tree otr_type,\n \t  return;\n \t}\n       gcc_assert (base_binfo);\n-      if (!pointer_set_insert (matched_vtables, BINFO_VTABLE (base_binfo)))\n+      if (!matched_vtables->add (BINFO_VTABLE (base_binfo)))\n \t{\n \t  bool can_refer;\n \t  tree target = gimple_get_virt_method_for_binfo (otr_token,\n \t\t\t\t\t\t\t  base_binfo,\n \t\t\t\t\t\t\t  &can_refer);\n \t  if (!target || ! DECL_CXX_DESTRUCTOR_P (target))\n \t    maybe_record_node (nodes, target, inserted, can_refer, completep);\n-\t  pointer_set_insert (matched_vtables, BINFO_VTABLE (base_binfo));\n+\t  matched_vtables->add (BINFO_VTABLE (base_binfo));\n \t}\n     }\n }\n@@ -2537,8 +2536,6 @@ possible_polymorphic_call_targets (tree otr_type,\n \t\t\t\t   int *speculative_targetsp)\n {\n   static struct cgraph_node_hook_list *node_removal_hook_holder;\n-  pointer_set_t *inserted;\n-  pointer_set_t *matched_vtables;\n   vec <cgraph_node *> nodes = vNULL;\n   vec <tree> bases_to_consider = vNULL;\n   odr_type type, outer_type;\n@@ -2617,7 +2614,7 @@ possible_polymorphic_call_targets (tree otr_type,\n   /* Initialize query cache.  */\n   if (!cached_polymorphic_call_targets)\n     {\n-      cached_polymorphic_call_targets = pointer_set_create ();\n+      cached_polymorphic_call_targets = new hash_set<cgraph_node *>;\n       polymorphic_call_target_hash\n        \t= new polymorphic_call_target_hash_type (23);\n       if (!node_removal_hook_holder)\n@@ -2657,8 +2654,8 @@ possible_polymorphic_call_targets (tree otr_type,\n   (*slot)->context = context;\n   (*slot)->speculative_targets = 0;\n \n-  inserted = pointer_set_create ();\n-  matched_vtables = pointer_set_create ();\n+  hash_set<tree> inserted;\n+  hash_set<tree> matched_vtables;\n \n   if (context.speculative_outer_type)\n     {\n@@ -2682,9 +2679,9 @@ possible_polymorphic_call_targets (tree otr_type,\n \t    context.speculative_maybe_derived_type = false;\n \t}\n       if (type_possibly_instantiated_p (speculative_outer_type->type))\n-\tmaybe_record_node (nodes, target, inserted, can_refer, &complete);\n+\tmaybe_record_node (nodes, target, &inserted, can_refer, &complete);\n       if (binfo)\n-\tpointer_set_insert (matched_vtables, BINFO_VTABLE (binfo));\n+\tmatched_vtables.add (BINFO_VTABLE (binfo));\n       /* Next walk recursively all derived types.  */\n       if (context.speculative_maybe_derived_type)\n \t{\n@@ -2693,8 +2690,8 @@ possible_polymorphic_call_targets (tree otr_type,\n \t  if (!type->all_derivations_known)\n \t    complete = false;\n \t  for (i = 0; i < speculative_outer_type->derived_types.length(); i++)\n-\t    possible_polymorphic_call_targets_1 (nodes, inserted,\n-\t\t\t\t\t\t matched_vtables,\n+\t    possible_polymorphic_call_targets_1 (nodes, &inserted,\n+\t\t\t\t\t\t &matched_vtables,\n \t\t\t\t\t\t otr_type,\n \t\t\t\t\t\t speculative_outer_type->derived_types[i],\n \t\t\t\t\t\t otr_token, speculative_outer_type->type,\n@@ -2733,15 +2730,15 @@ possible_polymorphic_call_targets (tree otr_type,\n \n   /* If OUTER_TYPE is abstract, we know we are not seeing its instance.  */\n   if (type_possibly_instantiated_p (outer_type->type))\n-    maybe_record_node (nodes, target, inserted, can_refer, &complete);\n+    maybe_record_node (nodes, target, &inserted, can_refer, &complete);\n   else\n     {\n       skipped = true;\n       gcc_assert (in_lto_p || context.maybe_derived_type);\n     }\n \n   if (binfo)\n-    pointer_set_insert (matched_vtables, BINFO_VTABLE (binfo));\n+    matched_vtables.add (BINFO_VTABLE (binfo));\n \n   /* Next walk recursively all derived types.  */\n   if (context.maybe_derived_type)\n@@ -2751,8 +2748,8 @@ possible_polymorphic_call_targets (tree otr_type,\n       if (!type->all_derivations_known)\n \tcomplete = false;\n       for (i = 0; i < outer_type->derived_types.length(); i++)\n-\tpossible_polymorphic_call_targets_1 (nodes, inserted,\n-\t\t\t\t\t     matched_vtables,\n+\tpossible_polymorphic_call_targets_1 (nodes, &inserted,\n+\t\t\t\t\t     &matched_vtables,\n \t\t\t\t\t     otr_type,\n \t\t\t\t\t     outer_type->derived_types[i],\n \t\t\t\t\t     otr_token, outer_type->type,\n@@ -2779,12 +2776,12 @@ possible_polymorphic_call_targets (tree otr_type,\n \t      || (context.maybe_derived_type\n \t          && !type_all_derivations_known_p (outer_type->type))))\n \trecord_targets_from_bases (otr_type, otr_token, outer_type->type,\n-\t\t\t\t   context.offset, nodes, inserted,\n-\t\t\t\t   matched_vtables, &complete);\n+\t\t\t\t   context.offset, nodes, &inserted,\n+\t\t\t\t   &matched_vtables, &complete);\n       if (skipped)\n-        maybe_record_node (nodes, target, inserted, can_refer, &complete);\n+        maybe_record_node (nodes, target, &inserted, can_refer, &complete);\n       for (i = 0; i < bases_to_consider.length(); i++)\n-        maybe_record_node (nodes, bases_to_consider[i], inserted, can_refer, &complete);\n+        maybe_record_node (nodes, bases_to_consider[i], &inserted, can_refer, &complete);\n     }\n   bases_to_consider.release();\n \n@@ -2795,8 +2792,6 @@ possible_polymorphic_call_targets (tree otr_type,\n   if (speculative_targetsp)\n     *speculative_targetsp = (*slot)->speculative_targets;\n \n-  pointer_set_destroy (inserted);\n-  pointer_set_destroy (matched_vtables);\n   timevar_pop (TV_IPA_VIRTUAL_CALL);\n   return nodes;\n }\n@@ -2959,7 +2954,7 @@ static unsigned int\n ipa_devirt (void)\n {\n   struct cgraph_node *n;\n-  struct pointer_set_t *bad_call_targets = pointer_set_create ();\n+  hash_set<void *> bad_call_targets;\n   struct cgraph_edge *e;\n \n   int npolymorphic = 0, nspeculated = 0, nconverted = 0, ncold = 0;\n@@ -3007,8 +3002,7 @@ ipa_devirt (void)\n \t\tif (!dump_file)\n \t\t  continue;\n \t      }\n-\t    if (pointer_set_contains (bad_call_targets,\n-\t\t\t\t      cache_token))\n+\t    if (bad_call_targets.contains (cache_token))\n \t      {\n \t\tif (dump_file)\n \t\t  fprintf (dump_file, \"Target list is known to be useless\\n\\n\");\n@@ -3033,7 +3027,7 @@ ipa_devirt (void)\n \t\t}\n \t    if (!likely_target)\n \t      {\n-\t\tpointer_set_insert (bad_call_targets, cache_token);\n+\t\tbad_call_targets.add (cache_token);\n \t        continue;\n \t      }\n \t    /* This is reached only when dumping; check if we agree or disagree\n@@ -3120,7 +3114,6 @@ ipa_devirt (void)\n       if (update)\n \tinline_update_overall_summary (n);\n     }\n-  pointer_set_destroy (bad_call_targets);\n \n   if (dump_file)\n     fprintf (dump_file,"}, {"sha": "b9645022b59740b0d0b5b7d64b327244d434c04d", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -65,8 +65,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"intl.h\"\n #include \"opts.h\"\n-\n-static struct pointer_set_t *visited_nodes;\n+#include \"hash-set.h\"\n \n /* Lattice values for const and pure functions.  Everything starts out\n    being const, then may drop to pure and then neither depending on\n@@ -133,13 +132,13 @@ function_always_visible_to_compiler_p (tree decl)\n \n /* Emit suggestion about attribute ATTRIB_NAME for DECL.  KNOWN_FINITE\n    is true if the function is known to be finite.  The diagnostic is\n-   controlled by OPTION.  WARNED_ABOUT is a pointer_set unique for\n+   controlled by OPTION.  WARNED_ABOUT is a hash_set<tree> unique for\n    OPTION, this function may initialize it and it is always returned\n    by the function.  */\n \n-static struct pointer_set_t *\n+static hash_set<tree> *\n suggest_attribute (int option, tree decl, bool known_finite,\n-\t\t   struct pointer_set_t *warned_about,\n+\t\t   hash_set<tree> *warned_about,\n \t\t   const char * attrib_name)\n {\n   if (!option_enabled (option, &global_options))\n@@ -149,10 +148,10 @@ suggest_attribute (int option, tree decl, bool known_finite,\n     return warned_about;\n \n   if (!warned_about)\n-    warned_about = pointer_set_create (); \n-  if (pointer_set_contains (warned_about, decl))\n+    warned_about = new hash_set<tree>;\n+  if (warned_about->contains (decl))\n     return warned_about;\n-  pointer_set_insert (warned_about, decl);\n+  warned_about->add (decl);\n   warning_at (DECL_SOURCE_LOCATION (decl),\n \t      option,\n \t      known_finite\n@@ -168,7 +167,7 @@ suggest_attribute (int option, tree decl, bool known_finite,\n static void\n warn_function_pure (tree decl, bool known_finite)\n {\n-  static struct pointer_set_t *warned_about;\n+  static hash_set<tree> *warned_about;\n \n   warned_about \n     = suggest_attribute (OPT_Wsuggest_attribute_pure, decl,\n@@ -181,7 +180,7 @@ warn_function_pure (tree decl, bool known_finite)\n static void\n warn_function_const (tree decl, bool known_finite)\n {\n-  static struct pointer_set_t *warned_about;\n+  static hash_set<tree> *warned_about;\n   warned_about \n     = suggest_attribute (OPT_Wsuggest_attribute_const, decl,\n \t\t\t known_finite, warned_about, \"const\");\n@@ -190,7 +189,7 @@ warn_function_const (tree decl, bool known_finite)\n static void\n warn_function_noreturn (tree decl)\n {\n-  static struct pointer_set_t *warned_about;\n+  static hash_set<tree> *warned_about;\n   if (!lang_hooks.missing_noreturn_ok_p (decl)\n       && targetm.warn_func_return (decl))\n     warned_about \n@@ -846,11 +845,8 @@ add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n      static declarations.  We do not need to scan them more than once\n      since all we would be interested in are the addressof\n      operations.  */\n-  visited_nodes = pointer_set_create ();\n   if (node->get_availability () > AVAIL_INTERPOSABLE)\n     set_function_state (node, analyze_function (node, true));\n-  pointer_set_destroy (visited_nodes);\n-  visited_nodes = NULL;\n }\n \n /* Called when new clone is inserted to callgraph late.  */\n@@ -912,12 +908,6 @@ pure_const_generate_summary (void)\n \n   register_hooks ();\n \n-  /* There are some shared nodes, in particular the initializers on\n-     static declarations.  We do not need to scan them more than once\n-     since all we would be interested in are the addressof\n-     operations.  */\n-  visited_nodes = pointer_set_create ();\n-\n   /* Process all of the functions.\n \n      We process AVAIL_INTERPOSABLE functions.  We can not use the results\n@@ -927,9 +917,6 @@ pure_const_generate_summary (void)\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (node->get_availability () >= AVAIL_INTERPOSABLE)\n       set_function_state (node, analyze_function (node, true));\n-\n-  pointer_set_destroy (visited_nodes);\n-  visited_nodes = NULL;\n }\n \n "}, {"sha": "bca2bc7a0cfe2a35d719cb37883a9a1d0135e7df", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -687,12 +687,11 @@ function_and_variable_visibility (bool whole_program)\n \t      }\n \t  if (found)\n \t    {\n-\t      struct pointer_set_t *visited_nodes = pointer_set_create ();\n+\t      hash_set<tree> visited_nodes;\n \n \t      vnode->get_constructor ();\n \t      walk_tree (&DECL_INITIAL (vnode->decl),\n-\t\t\t update_vtable_references, NULL, visited_nodes);\n-\t      pointer_set_destroy (visited_nodes);\n+\t\t\t update_vtable_references, NULL, &visited_nodes);\n \t      vnode->remove_all_references ();\n \t      record_references_in_initializer (vnode->decl, false);\n \t    }"}, {"sha": "1081e89d94550f426a98ab4f1db2efee7d9cacd9", "filename": "gcc/ipa.c", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"tree-pass.h\"\n #include \"hash-map.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-set.h\"\n #include \"gimple-expr.h\"\n #include \"gimplify.h\"\n #include \"flags.h\"\n@@ -84,14 +84,14 @@ update_inlined_to_pointer (struct cgraph_node *node, struct cgraph_node *inlined\n \n static void\n enqueue_node (symtab_node *node, symtab_node **first,\n-\t      struct pointer_set_t *reachable)\n+\t      hash_set<symtab_node *> *reachable)\n {\n   /* Node is still in queue; do nothing.  */\n   if (node->aux && node->aux != (void *) 2)\n     return;\n   /* Node was already processed as unreachable, re-enqueue\n      only if it became reachable now.  */\n-  if (node->aux == (void *)2 && !pointer_set_contains (reachable, node))\n+  if (node->aux == (void *)2 && !reachable->contains (node))\n     return;\n   node->aux = *first;\n   *first = node;\n@@ -103,7 +103,7 @@ static void\n process_references (symtab_node *snode,\n \t\t    symtab_node **first,\n \t\t    bool before_inlining_p,\n-\t\t    struct pointer_set_t *reachable)\n+\t\t    hash_set<symtab_node *> *reachable)\n {\n   int i;\n   struct ipa_ref *ref = NULL;\n@@ -124,7 +124,7 @@ process_references (symtab_node *snode,\n \t\t      && flag_wpa\n \t\t      && ctor_for_folding (node->decl)\n \t\t         != error_mark_node))))\n-\tpointer_set_insert (reachable, node);\n+\treachable->add (node);\n       enqueue_node (node, first, reachable);\n     }\n }\n@@ -138,10 +138,11 @@ process_references (symtab_node *snode,\n    possible.  */\n \n static void\n-walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n+walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \t\t\t       struct cgraph_edge *edge,\n \t\t\t       symtab_node **first,\n-\t\t\t       pointer_set_t *reachable, bool before_inlining_p)\n+\t\t\t       hash_set<symtab_node *> *reachable,\n+\t\t\t       bool before_inlining_p)\n {\n   unsigned int i;\n   void *cache_token;\n@@ -150,8 +151,7 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n     = possible_polymorphic_call_targets\n \t(edge, &final, &cache_token);\n \n-  if (!pointer_set_insert (reachable_call_targets,\n-\t\t\t   cache_token))\n+  if (!reachable_call_targets->add (cache_token))\n     {\n       for (i = 0; i < targets.length (); i++)\n \t{\n@@ -172,7 +172,7 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n \t\t   && (cgraph_state < CGRAPH_STATE_IPA_SSA\n \t\t       || !lookup_attribute (\"always_inline\",\n \t\t\t\t\t     DECL_ATTRIBUTES (n->decl)))))\n-\t     pointer_set_insert (reachable, n);\n+\t     reachable->add (n);\n \n \t  /* Even after inlining we want to keep the possible targets in the\n \t     boundary, so late passes can still produce direct call even if\n@@ -276,9 +276,9 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   struct cgraph_node *node, *next;\n   varpool_node *vnode, *vnext;\n   bool changed = false;\n-  struct pointer_set_t *reachable = pointer_set_create ();\n-  struct pointer_set_t *body_needed_for_clonning = pointer_set_create ();\n-  struct pointer_set_t *reachable_call_targets = pointer_set_create ();\n+  hash_set<symtab_node *> reachable;\n+  hash_set<tree> body_needed_for_clonning;\n+  hash_set<void *> reachable_call_targets;\n \n   timevar_push (TV_IPA_UNREACHABLE);\n   if (optimize && flag_devirtualize)\n@@ -304,8 +304,8 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  && !node->can_remove_if_no_direct_calls_and_refs_p ())\n \t{\n \t  gcc_assert (!node->global.inlined_to);\n-\t  pointer_set_insert (reachable, node);\n-\t  enqueue_node (node, &first, reachable);\n+\t  reachable.add (node);\n+\t  enqueue_node (node, &first, &reachable);\n \t}\n       else\n \tgcc_assert (!node->aux);\n@@ -316,14 +316,14 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     if (!vnode->can_remove_if_no_refs_p()\n \t&& !vnode->in_other_partition)\n       {\n-\tpointer_set_insert (reachable, vnode);\n-\tenqueue_node (vnode, &first, reachable);\n+\treachable.add (vnode);\n+\tenqueue_node (vnode, &first, &reachable);\n       }\n \n   /* Perform reachability analysis.  */\n   while (first != (symtab_node *) (void *) 1)\n     {\n-      bool in_boundary_p = !pointer_set_contains (reachable, first);\n+      bool in_boundary_p = !reachable.contains (first);\n       symtab_node *node = first;\n \n       first = (symtab_node *)first->aux;\n@@ -340,7 +340,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t      struct cgraph_node *origin_node\n \t      = cgraph_node::get_create (DECL_ABSTRACT_ORIGIN (node->decl));\n \t      origin_node->used_as_abstract_origin = true;\n-\t      enqueue_node (origin_node, &first, reachable);\n+\t      enqueue_node (origin_node, &first, &reachable);\n \t    }\n \t  /* If any symbol in a comdat group is reachable, force\n \t     all externally visible symbols in the same comdat\n@@ -353,11 +353,11 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t   next != node;\n \t\t   next = next->same_comdat_group)\n \t\tif (!next->comdat_local_p ()\n-\t\t    && !pointer_set_insert (reachable, next))\n-\t\t  enqueue_node (next, &first, reachable);\n+\t\t    && !reachable.add (next))\n+\t\t  enqueue_node (next, &first, &reachable);\n \t    }\n \t  /* Mark references as reachable.  */\n-\t  process_references (node, &first, before_inlining_p, reachable);\n+\t  process_references (node, &first, before_inlining_p, &reachable);\n \t}\n \n       if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n@@ -375,8 +375,8 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t    {\n \t\t      next = e->next_callee;\n \t\t      if (e->indirect_info->polymorphic)\n-\t\t\twalk_polymorphic_call_targets (reachable_call_targets,\n-\t\t\t\t\t\t       e, &first, reachable,\n+\t\t\twalk_polymorphic_call_targets (&reachable_call_targets,\n+\t\t\t\t\t\t       e, &first, &reachable,\n \t\t\t\t\t\t       before_inlining_p);\n \t\t    }\n \t\t}\n@@ -394,17 +394,16 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t      if (DECL_EXTERNAL (e->callee->decl)\n \t\t\t  && e->callee->alias\n \t\t\t  && before_inlining_p)\n-\t\t\tpointer_set_insert (reachable,\n-\t\t\t\t\t    e->callee->function_symbol ());\n-\t\t      pointer_set_insert (reachable, e->callee);\n+\t\t\treachable.add (e->callee->function_symbol ());\n+\t\t      reachable.add (e->callee);\n \t\t    }\n-\t\t  enqueue_node (e->callee, &first, reachable);\n+\t\t  enqueue_node (e->callee, &first, &reachable);\n \t\t}\n \n \t      /* When inline clone exists, mark body to be preserved so when removing\n \t\t offline copy of the function we don't kill it.  */\n \t      if (cnode->global.inlined_to)\n-\t        pointer_set_insert (body_needed_for_clonning, cnode->decl);\n+\t        body_needed_for_clonning.add (cnode->decl);\n \n \t      /* For non-inline clones, force their origins to the boundary and ensure\n \t\t that body is not removed.  */\n@@ -414,8 +413,8 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t  cnode = cnode->clone_of;\n \t\t  if (noninline)\n \t\t    {\n-\t\t      pointer_set_insert (body_needed_for_clonning, cnode->decl);\n-\t\t      enqueue_node (cnode, &first, reachable);\n+\t\t      body_needed_for_clonning.add (cnode->decl);\n+\t\t      enqueue_node (cnode, &first, &reachable);\n \t\t    }\n \t\t}\n \n@@ -429,8 +428,8 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t   next;\n \t\t   next = next->simdclone->next_clone)\n \t\tif (in_boundary_p\n-\t\t    || !pointer_set_insert (reachable, next))\n-\t\t  enqueue_node (next, &first, reachable);\n+\t\t    || !reachable.add (next))\n+\t\t  enqueue_node (next, &first, &reachable);\n \t    }\n \t}\n       /* When we see constructor of external variable, keep referred nodes in the\n@@ -444,7 +443,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t{\n \t  struct ipa_ref *ref = NULL;\n \t  for (int i = 0; node->iterate_reference (i, ref); i++)\n-\t    enqueue_node (ref->referred, &first, reachable);\n+\t    enqueue_node (ref->referred, &first, &reachable);\n \t}\n     }\n \n@@ -462,9 +461,9 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  changed = true;\n \t}\n       /* If node is unreachable, remove its body.  */\n-      else if (!pointer_set_contains (reachable, node))\n+      else if (!reachable.contains (node))\n         {\n-\t  if (!pointer_set_contains (body_needed_for_clonning, node->decl))\n+\t  if (!body_needed_for_clonning.contains (node->decl))\n \t    node->release_body ();\n \t  else if (!node->clone_of)\n \t    gcc_assert (in_lto_p || DECL_RESULT (node->decl));\n@@ -530,7 +529,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  vnode->remove ();\n \t  changed = true;\n \t}\n-      else if (!pointer_set_contains (reachable, vnode))\n+      else if (!reachable.contains (vnode))\n         {\n \t  tree init;\n \t  if (vnode->definition)\n@@ -557,10 +556,6 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \tvnode->aux = NULL;\n     }\n \n-  pointer_set_destroy (reachable);\n-  pointer_set_destroy (body_needed_for_clonning);\n-  pointer_set_destroy (reachable_call_targets);\n-\n   /* Now update address_taken flags and try to promote functions to be local.  */\n   if (file)\n     fprintf (file, \"\\nClearing address taken flags:\");"}, {"sha": "b246b53e7848ad6974618417e7a8db739f9923f1", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"input.h\"\n #include \"hashtab.h\"\n+#include \"hash-set.h\"\n #include \"langhooks.h\"\n #include \"bitmap.h\"\n #include \"function.h\"\n@@ -819,7 +820,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n   int i;\n   lto_symtab_encoder_t encoder;\n   lto_symtab_encoder_iterator lsei;\n-  struct pointer_set_t *reachable_call_targets = pointer_set_create ();\n+  hash_set<void *> reachable_call_targets;\n \n   encoder = lto_symtab_encoder_new (false);\n \n@@ -902,8 +903,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \t      vec <cgraph_node *>targets\n \t\t= possible_polymorphic_call_targets\n \t\t    (edge, &final, &cache_token);\n-\t      if (!pointer_set_insert (reachable_call_targets,\n-\t\t\t\t       cache_token))\n+\t      if (!reachable_call_targets.add (cache_token))\n \t\t{\n \t\t  for (i = 0; i < targets.length (); i++)\n \t\t    {\n@@ -923,7 +923,6 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \t    }\n     }\n   lto_symtab_encoder_delete (in_encoder);\n-  pointer_set_destroy (reachable_call_targets);\n   return encoder;\n }\n "}, {"sha": "81a7b2339325766fa75d1603de0c0a29cc5c337a", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"input.h\"\n #include \"hashtab.h\"\n+#include \"hash-set.h\"\n #include \"basic-block.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n@@ -2421,7 +2422,7 @@ lto_out_decl_state_written_size (struct lto_out_decl_state *state)\n \n static void\n write_symbol (struct streamer_tree_cache_d *cache,\n-\t      tree t, struct pointer_set_t *seen, bool alias)\n+\t      tree t, hash_set<const char *> *seen, bool alias)\n {\n   const char *name;\n   enum gcc_plugin_symbol_kind kind;\n@@ -2449,9 +2450,8 @@ write_symbol (struct streamer_tree_cache_d *cache,\n      same name manipulations that ASM_OUTPUT_LABELREF does. */\n   name = IDENTIFIER_POINTER ((*targetm.asm_out.mangle_assembler_name) (name));\n \n-  if (pointer_set_contains (seen, name))\n+  if (seen->add (name))\n     return;\n-  pointer_set_insert (seen, name);\n \n   streamer_tree_cache_lookup (cache, t, &slot_num);\n   gcc_assert (slot_num != (unsigned)-1);\n@@ -2576,14 +2576,13 @@ produce_symtab (struct output_block *ob)\n {\n   struct streamer_tree_cache_d *cache = ob->writer_cache;\n   char *section_name = lto_get_section_name (LTO_section_symtab, NULL, NULL);\n-  struct pointer_set_t *seen;\n   lto_symtab_encoder_t encoder = ob->decl_state->symtab_node_encoder;\n   lto_symtab_encoder_iterator lsei;\n \n   lto_begin_section (section_name, false);\n   free (section_name);\n \n-  seen = pointer_set_create ();\n+  hash_set<const char *> seen;\n \n   /* Write the symbol table.\n      First write everything defined and then all declarations.\n@@ -2595,7 +2594,7 @@ produce_symtab (struct output_block *ob)\n \n       if (!output_symbol_p (node) || DECL_EXTERNAL (node->decl))\n \tcontinue;\n-      write_symbol (cache, node->decl, seen, false);\n+      write_symbol (cache, node->decl, &seen, false);\n     }\n   for (lsei = lsei_start (encoder);\n        !lsei_end_p (lsei); lsei_next (&lsei))\n@@ -2604,11 +2603,9 @@ produce_symtab (struct output_block *ob)\n \n       if (!output_symbol_p (node) || !DECL_EXTERNAL (node->decl))\n \tcontinue;\n-      write_symbol (cache, node->decl, seen, false);\n+      write_symbol (cache, node->decl, &seen, false);\n     }\n \n-  pointer_set_destroy (seen);\n-\n   lto_end_section ();\n }\n "}, {"sha": "2d0018ff42e211dabdaf5fcfdab59a4c99019c8b", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -1,3 +1,8 @@\n+2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* lto-partition.c, lto-partition.h: Use hash_set instead of\n+\tpointer_set.\n+\n 2014-07-31  Andi Kleen  <ak@linux.intel.com>\n \n \t* lto.c (hash_canonical_type): Use inchash::hash"}, {"sha": "a5bcf92a2feafb1af519954238180c140500a5f5", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -66,7 +66,7 @@ free_ltrans_partitions (void)\n   for (idx = 0; ltrans_partitions.iterate (idx, &part); idx++)\n     {\n       if (part->initializers_visited)\n-\tpointer_set_destroy (part->initializers_visited);\n+\tdelete part->initializers_visited;\n       /* Symtab encoder is freed after streaming.  */\n       free (part);\n     }\n@@ -101,8 +101,8 @@ add_references_to_partition (ltrans_partition part, symtab_node *node)\n \t     && !lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n       {\n \tif (!part->initializers_visited)\n-\t  part->initializers_visited = pointer_set_create ();\n-\tif (!pointer_set_insert (part->initializers_visited, ref->referred))\n+\t  part->initializers_visited = new hash_set<symtab_node *>;\n+\tif (!part->initializers_visited->add (ref->referred))\n \t  add_references_to_partition (part, ref->referred);\n       }\n }\n@@ -250,7 +250,7 @@ undo_partition (ltrans_partition partition, unsigned int n_nodes)\n \n       /* After UNDO we no longer know what was visited.  */\n       if (partition->initializers_visited)\n-\tpointer_set_destroy (partition->initializers_visited);\n+\tdelete partition->initializers_visited;\n       partition->initializers_visited = NULL;\n \n       if (!node->alias && (cnode = dyn_cast <cgraph_node *> (node)))"}, {"sha": "50ec2faffcf7ff7e3b0a2a15dc107d0aa3de3aa9", "filename": "gcc/lto/lto-partition.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Flto%2Flto-partition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Flto%2Flto-partition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.h?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -17,6 +17,7 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+#include \"hash-set.h\"\n \n /* Structure describing ltrans partitions.  */\n \n@@ -25,7 +26,7 @@ struct ltrans_partition_def\n   lto_symtab_encoder_t encoder;\n   const char * name;\n   int insns;\n-  pointer_set_t *initializers_visited;\n+  hash_set<symtab_node *> *initializers_visited;\n };\n \n typedef struct ltrans_partition_def *ltrans_partition;"}, {"sha": "55ec279776fd353707d5a64baaf989225b2ad8a5", "filename": "gcc/stmt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"predict.h\"\n #include \"optabs.h\"\n #include \"target.h\"\n+#include \"hash-set.h\"\n #include \"pointer-set.h\"\n #include \"basic-block.h\"\n #include \"tree-ssa-alias.h\"\n@@ -1183,7 +1184,7 @@ expand_case (gimple stmt)\n      how to expand this switch().  */\n   uniq = 0;\n   count = 0;\n-  struct pointer_set_t *seen_labels = pointer_set_create ();\n+  hash_set<tree> seen_labels;\n   compute_cases_per_edge (stmt);\n \n   for (i = ncases - 1; i >= 1; --i)\n@@ -1203,7 +1204,7 @@ expand_case (gimple stmt)\n \n       /* If we have not seen this label yet, then increase the\n \t number of unique case node targets seen.  */\n-      if (!pointer_set_insert (seen_labels, lab))\n+      if (!seen_labels.add (lab))\n \tuniq++;\n \n       /* The bounds on the case range, LOW and HIGH, have to be converted\n@@ -1231,7 +1232,6 @@ expand_case (gimple stmt)\n           case_edge->probability / (intptr_t)(case_edge->aux),\n           case_node_pool);\n     }\n-  pointer_set_destroy (seen_labels);\n   reset_out_edges_aux (bb);\n \n   /* cleanup_tree_cfg removes all SWITCH_EXPR with a single"}, {"sha": "e034762c6da9c1ff85747247ddef28373bf06b39", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -4691,15 +4691,15 @@ tree_node_can_be_shared (tree t)\n static tree\n verify_node_sharing_1 (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct pointer_set_t *visited = (struct pointer_set_t *) data;\n+  hash_set<void *> *visited = (hash_set<void *> *) data;\n \n   if (tree_node_can_be_shared (*tp))\n     {\n       *walk_subtrees = false;\n       return NULL;\n     }\n \n-  if (pointer_set_insert (visited, *tp))\n+  if (visited->add (*tp))\n     return *tp;\n \n   return NULL;\n@@ -4719,9 +4719,9 @@ static int\n verify_eh_throw_stmt_node (void **slot, void *data)\n {\n   struct throw_stmt_node *node = (struct throw_stmt_node *)*slot;\n-  struct pointer_set_t *visited = (struct pointer_set_t *) data;\n+  hash_set<void *> *visited = (hash_set<void *> *) data;\n \n-  if (!pointer_set_contains (visited, node->stmt))\n+  if (!visited->contains (node->stmt))\n     {\n       error (\"dead STMT in EH table\");\n       debug_gimple_stmt (node->stmt);\n@@ -4733,11 +4733,11 @@ verify_eh_throw_stmt_node (void **slot, void *data)\n /* Verify if the location LOCs block is in BLOCKS.  */\n \n static bool\n-verify_location (pointer_set_t *blocks, location_t loc)\n+verify_location (hash_set<tree> *blocks, location_t loc)\n {\n   tree block = LOCATION_BLOCK (loc);\n   if (block != NULL_TREE\n-      && !pointer_set_contains (blocks, block))\n+      && !blocks->contains (block))\n     {\n       error (\"location references block not in block tree\");\n       return true;\n@@ -4770,7 +4770,7 @@ verify_expr_no_block (tree *tp, int *walk_subtrees, void *)\n static tree\n verify_expr_location_1 (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct pointer_set_t *blocks = (struct pointer_set_t *) data;\n+  hash_set<tree> *blocks = (hash_set<tree> *) data;\n \n   if (TREE_CODE (*tp) == VAR_DECL\n       && DECL_HAS_DEBUG_EXPR_P (*tp))\n@@ -4816,12 +4816,12 @@ verify_expr_location (tree *tp, int *walk_subtrees, void *data)\n /* Insert all subblocks of BLOCK into BLOCKS and recurse.  */\n \n static void\n-collect_subblocks (pointer_set_t *blocks, tree block)\n+collect_subblocks (hash_set<tree> *blocks, tree block)\n {\n   tree t;\n   for (t = BLOCK_SUBBLOCKS (block); t; t = BLOCK_CHAIN (t))\n     {\n-      pointer_set_insert (blocks, t);\n+      blocks->add (t);\n       collect_subblocks (blocks, t);\n     }\n }\n@@ -4833,18 +4833,17 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n {\n   basic_block bb;\n   bool err = false;\n-  struct pointer_set_t *visited, *visited_stmts, *blocks;\n \n   timevar_push (TV_TREE_STMT_VERIFY);\n-  visited = pointer_set_create ();\n-  visited_stmts = pointer_set_create ();\n+  hash_set<void *> visited;\n+  hash_set<gimple> visited_stmts;\n \n   /* Collect all BLOCKs referenced by the BLOCK tree of FN.  */\n-  blocks = pointer_set_create ();\n+  hash_set<tree> blocks;\n   if (DECL_INITIAL (fn->decl))\n     {\n-      pointer_set_insert (blocks, DECL_INITIAL (fn->decl));\n-      collect_subblocks (blocks, DECL_INITIAL (fn->decl));\n+      blocks.add (DECL_INITIAL (fn->decl));\n+      collect_subblocks (&blocks, DECL_INITIAL (fn->decl));\n     }\n \n   FOR_EACH_BB_FN (bb, fn)\n@@ -4857,7 +4856,7 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n \t  bool err2 = false;\n \t  unsigned i;\n \n-\t  pointer_set_insert (visited_stmts, phi);\n+\t  visited_stmts.add (phi);\n \n \t  if (gimple_bb (phi) != bb)\n \t    {\n@@ -4878,7 +4877,7 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n \t    {\n \t      tree arg = gimple_phi_arg_def (phi, i);\n \t      tree addr = walk_tree (&arg, verify_node_sharing_1,\n-\t\t\t\t     visited, NULL);\n+\t\t\t\t     &visited, NULL);\n \t      if (addr)\n \t\t{\n \t\t  error (\"incorrect sharing of tree nodes\");\n@@ -4892,13 +4891,13 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n \t\t  error (\"virtual PHI with argument locations\");\n \t\t  err2 = true;\n \t\t}\n-\t      addr = walk_tree (&arg, verify_expr_location_1, blocks, NULL);\n+\t      addr = walk_tree (&arg, verify_expr_location_1, &blocks, NULL);\n \t      if (addr)\n \t\t{\n \t\t  debug_generic_expr (addr);\n \t\t  err2 = true;\n \t\t}\n-\t      err2 |= verify_location (blocks, loc);\n+\t      err2 |= verify_location (&blocks, loc);\n \t    }\n \n \t  if (err2)\n@@ -4914,7 +4913,7 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n \t  tree addr;\n \t  int lp_nr;\n \n-\t  pointer_set_insert (visited_stmts, stmt);\n+\t  visited_stmts.add (stmt);\n \n \t  if (gimple_bb (stmt) != bb)\n \t    {\n@@ -4923,10 +4922,10 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n \t    }\n \n \t  err2 |= verify_gimple_stmt (stmt);\n-\t  err2 |= verify_location (blocks, gimple_location (stmt));\n+\t  err2 |= verify_location (&blocks, gimple_location (stmt));\n \n \t  memset (&wi, 0, sizeof (wi));\n-\t  wi.info = (void *) visited;\n+\t  wi.info = (void *) &visited;\n \t  addr = walk_gimple_op (stmt, verify_node_sharing, &wi);\n \t  if (addr)\n \t    {\n@@ -4936,7 +4935,7 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n \t    }\n \n \t  memset (&wi, 0, sizeof (wi));\n-\t  wi.info = (void *) blocks;\n+\t  wi.info = (void *) &blocks;\n \t  addr = walk_gimple_op (stmt, verify_expr_location, &wi);\n \t  if (addr)\n \t    {\n@@ -4992,14 +4991,11 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n   if (get_eh_throw_stmt_table (cfun))\n     htab_traverse (get_eh_throw_stmt_table (cfun),\n \t\t   verify_eh_throw_stmt_node,\n-\t\t   visited_stmts);\n+\t\t   &visited_stmts);\n \n   if (err || eh_error_found)\n     internal_error (\"verify_gimple failed\");\n \n-  pointer_set_destroy (visited);\n-  pointer_set_destroy (visited_stmts);\n-  pointer_set_destroy (blocks);\n   verify_histograms ();\n   timevar_pop (TV_TREE_STMT_VERIFY);\n }"}, {"sha": "9d462d105b0dd7a7202a7c96e57b417155075a85", "filename": "gcc/tree-core.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_CORE_H\n \n #include \"hashtab.h\"\n+#include \"hash-set.h\"\n #include \"machmode.h\"\n #include \"input.h\"\n #include \"statistics.h\"\n@@ -45,7 +46,6 @@ struct fixed_value;\n struct ptr_info_def;\n struct range_info_def;\n struct die_struct;\n-struct pointer_set_t;\n \n \n /*---------------------------------------------------------------------------\n@@ -692,7 +692,7 @@ typedef tree (*walk_tree_fn) (tree *, int *, void *);\n \n /* The type of a callback function that represents a custom walk_tree.  */\n typedef tree (*walk_tree_lh) (tree *, int *, tree (*) (tree *, int *, void *),\n-\t\t\t      void *, struct pointer_set_t*);\n+\t\t\t      void *, hash_set<tree> *);\n \n \n /*---------------------------------------------------------------------------"}, {"sha": "38842e8541ac8e2fd9385bd5245006d49e7119d0", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"function.h\"\n #include \"except.h\"\n+#include \"hash-set.h\"\n #include \"pointer-set.h\"\n #include \"basic-block.h\"\n #include \"tree-ssa-alias.h\"\n@@ -3578,7 +3579,7 @@ lower_eh_dispatch (basic_block src, gimple stmt)\n \teh_catch c;\n \tedge_iterator ei;\n \tedge e;\n-\tstruct pointer_set_t *seen_values = pointer_set_create ();\n+\thash_set<tree> seen_values;\n \n \t/* Collect the labels for a switch.  Zero the post_landing_pad\n \t   field becase we'll no longer have anything keeping these labels\n@@ -3605,12 +3606,12 @@ lower_eh_dispatch (basic_block src, gimple stmt)\n \t\t   attached to the handler anymore, we remove \n \t\t   the corresponding edge and then we delete unreachable \n \t\t   blocks at the end of this pass.  */\n-\t\tif (! pointer_set_contains (seen_values, TREE_VALUE (flt_node)))\n+\t\tif (! seen_values.contains (TREE_VALUE (flt_node)))\n \t\t  {\n \t\t    tree t = build_case_label (TREE_VALUE (flt_node),\n \t\t\t\t\t       NULL, lab);\n \t\t    labels.safe_push (t);\n-\t\t    pointer_set_insert (seen_values, TREE_VALUE (flt_node));\n+\t\t    seen_values.add (TREE_VALUE (flt_node));\n \t\t    have_label = true;\n \t\t  }\n \n@@ -3662,7 +3663,6 @@ lower_eh_dispatch (basic_block src, gimple stmt)\n \t    x = gimple_build_switch (filter, default_label, labels);\n \t    gsi_insert_before (&gsi, x, GSI_SAME_STMT);\n \t  }\n-\tpointer_set_destroy (seen_values);\n       }\n       break;\n "}, {"sha": "6af4912822e8c4398bcaa20a4317876d5f437314", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -1788,7 +1788,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t     expensive, copy_body can be told to watch for nontrivial\n \t     changes.  */\n \t  if (id->statements_to_fold)\n-\t    pointer_set_insert (id->statements_to_fold, stmt);\n+\t    id->statements_to_fold->add (stmt);\n \n \t  /* We're duplicating a CALL_EXPR.  Find any corresponding\n \t     callgraph edges and update or duplicate them.  */\n@@ -3507,7 +3507,6 @@ inline_forbidden_p (tree fndecl)\n {\n   struct function *fun = DECL_STRUCT_FUNCTION (fndecl);\n   struct walk_stmt_info wi;\n-  struct pointer_set_t *visited_nodes;\n   basic_block bb;\n   bool forbidden_p = false;\n \n@@ -3518,10 +3517,10 @@ inline_forbidden_p (tree fndecl)\n \n   /* Next, walk the statements of the function looking for\n      constraucts we can't handle, or are non-optimal for inlining.  */\n-  visited_nodes = pointer_set_create ();\n+  hash_set<tree> visited_nodes;\n   memset (&wi, 0, sizeof (wi));\n   wi.info = (void *) fndecl;\n-  wi.pset = visited_nodes;\n+  wi.pset = &visited_nodes;\n \n   FOR_EACH_BB_FN (bb, fun)\n     {\n@@ -3533,7 +3532,6 @@ inline_forbidden_p (tree fndecl)\n \tbreak;\n     }\n \n-  pointer_set_destroy (visited_nodes);\n   return forbidden_p;\n }\n \f\n@@ -4531,7 +4529,7 @@ gimple_expand_calls_inline (basic_block bb, copy_body_data *id)\n    in the STATEMENTS pointer set.  */\n \n static void\n-fold_marked_statements (int first, struct pointer_set_t *statements)\n+fold_marked_statements (int first, hash_set<gimple> *statements)\n {\n   for (; first < n_basic_blocks_for_fn (cfun); first++)\n     if (BASIC_BLOCK_FOR_FN (cfun, first))\n@@ -4541,7 +4539,7 @@ fold_marked_statements (int first, struct pointer_set_t *statements)\n \tfor (gsi = gsi_start_bb (BASIC_BLOCK_FOR_FN (cfun, first));\n \t     !gsi_end_p (gsi);\n \t     gsi_next (&gsi))\n-\t  if (pointer_set_contains (statements, gsi_stmt (gsi)))\n+\t  if (statements->contains (gsi_stmt (gsi)))\n \t    {\n \t      gimple old_stmt = gsi_stmt (gsi);\n \t      tree old_decl = is_gimple_call (old_stmt) ? gimple_call_fndecl (old_stmt) : 0;\n@@ -4642,7 +4640,7 @@ optimize_inline_calls (tree fn)\n   id.transform_return_to_modify = true;\n   id.transform_parameter = true;\n   id.transform_lang_insert_block = NULL;\n-  id.statements_to_fold = pointer_set_create ();\n+  id.statements_to_fold = new hash_set<gimple>;\n \n   push_gimplify_context ();\n \n@@ -4678,7 +4676,7 @@ optimize_inline_calls (tree fn)\n \n   /* Fold queued statements.  */\n   fold_marked_statements (last, id.statements_to_fold);\n-  pointer_set_destroy (id.statements_to_fold);\n+  delete id.statements_to_fold;\n \n   gcc_assert (!id.debug_stmts.exists ());\n \n@@ -4920,7 +4918,6 @@ copy_gimple_seq_and_replace_locals (gimple_seq seq)\n {\n   copy_body_data id;\n   struct walk_stmt_info wi;\n-  struct pointer_set_t *visited;\n   gimple_seq copy;\n \n   /* There's nothing to do for NULL_TREE.  */\n@@ -4943,11 +4940,10 @@ copy_gimple_seq_and_replace_locals (gimple_seq seq)\n \n   /* Walk the tree once to find local labels.  */\n   memset (&wi, 0, sizeof (wi));\n-  visited = pointer_set_create ();\n+  hash_set<tree> visited;\n   wi.info = &id;\n-  wi.pset = visited;\n+  wi.pset = &visited;\n   walk_gimple_seq (seq, mark_local_labels_stmt, NULL, &wi);\n-  pointer_set_destroy (visited);\n \n   copy = gimple_seq_copy (seq);\n \n@@ -5370,7 +5366,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   memset (&id, 0, sizeof (id));\n \n   /* Generate a new name for the new version. */\n-  id.statements_to_fold = pointer_set_create ();\n+  id.statements_to_fold = new hash_set<gimple>;\n \n   id.decl_map = pointer_map_create ();\n   id.debug_map = NULL;\n@@ -5541,7 +5537,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   free_dominance_info (CDI_POST_DOMINATORS);\n \n   fold_marked_statements (0, id.statements_to_fold);\n-  pointer_set_destroy (id.statements_to_fold);\n+  delete id.statements_to_fold;\n   fold_cond_expr_cond ();\n   delete_unreachable_blocks_update_callgraph (&id);\n   if (id.dst_node->definition)"}, {"sha": "c13e6c75ad248f90d31380bdb0e0c0a61849d5f3", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -21,6 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_INLINE_H\n #define GCC_TREE_INLINE_H\n \n+#include \"hash-set.h\"\n+\n struct cgraph_edge;\n \n /* Indicate the desired behavior wrt call graph edges.  We can either\n@@ -114,7 +116,7 @@ struct copy_body_data\n   void (*transform_lang_insert_block) (tree);\n \n   /* Statements that might be possibly folded.  */\n-  struct pointer_set_t *statements_to_fold;\n+  hash_set<gimple> *statements_to_fold;\n \n   /* Entry basic block to currently copied body.  */\n   basic_block entry_bb;"}, {"sha": "45c5cf78651b26d36ce4faa4a8299caeeda5fcd5", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -95,7 +95,7 @@ struct nesting_info\n \n   struct pointer_map_t *field_map;\n   struct pointer_map_t *var_map;\n-  struct pointer_set_t *mem_refs;\n+  hash_set<tree *> *mem_refs;\n   bitmap suppress_expansion;\n \n   tree context;\n@@ -732,7 +732,7 @@ create_nesting_tree (struct cgraph_node *cgn)\n   struct nesting_info *info = XCNEW (struct nesting_info);\n   info->field_map = pointer_map_create ();\n   info->var_map = pointer_map_create ();\n-  info->mem_refs = pointer_set_create ();\n+  info->mem_refs = new hash_set<tree *>;\n   info->suppress_expansion = BITMAP_ALLOC (&nesting_info_bitmap_obstack);\n   info->context = cgn->decl;\n \n@@ -1651,7 +1651,7 @@ convert_local_reference_op (tree *tp, int *walk_subtrees, void *data)\n \t fold here, as the chain record type is not yet finalized.  */\n       if (TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR\n \t  && !DECL_P (TREE_OPERAND (TREE_OPERAND (t, 0), 0)))\n-\tpointer_set_insert (info->mem_refs, tp);\n+\tinfo->mem_refs->add (tp);\n       wi->val_only = save_val_only;\n       break;\n \n@@ -2655,8 +2655,8 @@ remap_vla_decls (tree block, struct nesting_info *root)\n }\n \n /* Fold the MEM_REF *E.  */\n-static bool\n-fold_mem_refs (const void *e, void *data ATTRIBUTE_UNUSED)\n+bool\n+fold_mem_refs (tree *const &e, void *data ATTRIBUTE_UNUSED)\n {\n   tree *ref_p = CONST_CAST2 (tree *, const tree *, (const tree *)e);\n   *ref_p = fold (*ref_p);\n@@ -2878,7 +2878,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n     }\n \n   /* Fold the rewritten MEM_REF trees.  */\n-  pointer_set_traverse (root->mem_refs, fold_mem_refs, NULL);\n+  root->mem_refs->traverse<void *, fold_mem_refs> (NULL);\n \n   /* Dump the translated tree function.  */\n   if (dump_file)\n@@ -2933,7 +2933,7 @@ free_nesting_tree (struct nesting_info *root)\n       next = iter_nestinfo_next (node);\n       pointer_map_destroy (node->var_map);\n       pointer_map_destroy (node->field_map);\n-      pointer_set_destroy (node->mem_refs);\n+      delete node->mem_refs;\n       free (node);\n       node = next;\n     }"}, {"sha": "aee03319cf0bb8fa06fb420d111461b036749164", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"tree-pretty-print.h\"\n #include \"hashtab.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-set.h\"\n #include \"gimple-expr.h\"\n #include \"cgraph.h\"\n #include \"langhooks.h\"\n@@ -103,14 +103,14 @@ debug_generic_stmt (tree t)\n DEBUG_FUNCTION void\n debug_tree_chain (tree t)\n {\n-  struct pointer_set_t *seen = pointer_set_create ();\n+  hash_set<tree> seen;\n \n   while (t)\n     {\n       print_generic_expr (stderr, t, TDF_VOPS|TDF_MEMSYMS|TDF_UID);\n       fprintf (stderr, \" \");\n       t = TREE_CHAIN (t);\n-      if (pointer_set_insert (seen, t))\n+      if (seen.add (t))\n \t{\n \t  fprintf (stderr, \"... [cycled back to \");\n \t  print_generic_expr (stderr, t, TDF_VOPS|TDF_MEMSYMS|TDF_UID);\n@@ -119,8 +119,6 @@ debug_tree_chain (tree t)\n \t}\n     }\n   fprintf (stderr, \"\\n\");\n-\n-  pointer_set_destroy (seen);\n }\n \n /* Prints declaration DECL to the FILE with details specified by FLAGS.  */"}, {"sha": "83c1b1958431937803dc9220fa5011a37ed78a61", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"gimple-pretty-print.h\"\n #include \"intl.h\"\n+#include \"hash-set.h\"\n #include \"pointer-set.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n@@ -3281,7 +3282,7 @@ discover_iteration_bound_by_body_walk (struct loop *loop)\n static void\n maybe_lower_iteration_bound (struct loop *loop)\n {\n-  pointer_set_t *not_executed_last_iteration = NULL;\n+  hash_set<gimple> *not_executed_last_iteration = NULL;\n   struct nb_iter_bound *elt;\n   bool found_exit = false;\n   vec<basic_block> queue = vNULL;\n@@ -3300,8 +3301,8 @@ maybe_lower_iteration_bound (struct loop *loop)\n \t  && wi::ltu_p (elt->bound, loop->nb_iterations_upper_bound))\n \t{\n \t  if (!not_executed_last_iteration)\n-\t    not_executed_last_iteration = pointer_set_create ();\n-\t  pointer_set_insert (not_executed_last_iteration, elt->stmt);\n+\t    not_executed_last_iteration = new hash_set<gimple>;\n+\t  not_executed_last_iteration->add (elt->stmt);\n \t}\n     }\n   if (!not_executed_last_iteration)\n@@ -3327,7 +3328,7 @@ maybe_lower_iteration_bound (struct loop *loop)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n-\t  if (pointer_set_contains (not_executed_last_iteration, stmt))\n+\t  if (not_executed_last_iteration->contains (stmt))\n \t    {\n \t      stmt_found = true;\n \t      break;\n@@ -3376,7 +3377,7 @@ maybe_lower_iteration_bound (struct loop *loop)\n     }\n   BITMAP_FREE (visited);\n   queue.release ();\n-  pointer_set_destroy (not_executed_last_iteration);\n+  delete not_executed_last_iteration;\n }\n \n /* Records estimates on numbers of iterations of LOOP.  If USE_UNDEFINED_P"}, {"sha": "3185d9a61531690f6a6c4d38a92b6895597253bd", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"tm_p.h\"\n #include \"basic-block.h\"\n+#include \"hash-set.h\"\n #include \"pointer-set.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n@@ -72,9 +73,9 @@ static bool abs_replacement (basic_block, basic_block,\n static bool neg_replacement (basic_block, basic_block,\n \t\t\t     edge, edge, gimple, tree, tree);\n static bool cond_store_replacement (basic_block, basic_block, edge, edge,\n-\t\t\t\t    struct pointer_set_t *);\n+\t\t\t\t    hash_set<tree> *);\n static bool cond_if_else_store_replacement (basic_block, basic_block, basic_block);\n-static struct pointer_set_t * get_non_trapping (void);\n+static hash_set<tree> * get_non_trapping ();\n static void replace_phi_edge_with_variable (basic_block, edge, gimple, tree);\n static void hoist_adjacent_loads (basic_block, basic_block,\n \t\t\t\t  basic_block, basic_block);\n@@ -176,7 +177,7 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n   basic_block *bb_order;\n   unsigned n, i;\n   bool cfgchanged = false;\n-  struct pointer_set_t *nontrap = 0;\n+  hash_set<tree> *nontrap = 0;\n \n   if (do_store_elim)\n     /* Calculate the set of non-trapping memory accesses.  */\n@@ -363,7 +364,7 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n   free (bb_order);\n \n   if (do_store_elim)\n-    pointer_set_destroy (nontrap);\n+    delete nontrap;\n   /* If the CFG has changed, we should cleanup the CFG.  */\n   if (cfgchanged && do_store_elim)\n     {\n@@ -1469,7 +1470,7 @@ ssa_names_hasher::equal (const value_type *n1, const compare_type *n2)\n class nontrapping_dom_walker : public dom_walker\n {\n public:\n-  nontrapping_dom_walker (cdi_direction direction, pointer_set_t *ps)\n+  nontrapping_dom_walker (cdi_direction direction, hash_set<tree> *ps)\n     : dom_walker (direction), m_nontrapping (ps), m_seen_ssa_names (128) {}\n \n   virtual void before_dom_children (basic_block);\n@@ -1484,7 +1485,7 @@ class nontrapping_dom_walker : public dom_walker\n      the RHS.  */\n   void add_or_mark_expr (basic_block, tree, bool);\n \n-  pointer_set_t *m_nontrapping;\n+  hash_set<tree> *m_nontrapping;\n \n   /* The hash table for remembering what we've seen.  */\n   hash_table<ssa_names_hasher> m_seen_ssa_names;\n@@ -1572,7 +1573,7 @@ nontrapping_dom_walker::add_or_mark_expr (basic_block bb, tree exp, bool store)\n \t then we can't trap.  */\n       if (found_bb && (((size_t)found_bb->aux) & 1) == 1)\n \t{\n-\t  pointer_set_insert (m_nontrapping, exp);\n+\t  m_nontrapping->add (exp);\n \t}\n       else\n         {\n@@ -1601,11 +1602,11 @@ nontrapping_dom_walker::add_or_mark_expr (basic_block bb, tree exp, bool store)\n    It will do a dominator walk over the whole function, and it will\n    make use of the bb->aux pointers.  It returns a set of trees\n    (the MEM_REFs itself) which can't trap.  */\n-static struct pointer_set_t *\n+static hash_set<tree> *\n get_non_trapping (void)\n {\n   nt_call_phase = 0;\n-  pointer_set_t *nontrap = pointer_set_create ();\n+  hash_set<tree> *nontrap = new hash_set<tree>;\n   /* We're going to do a dominator walk, so ensure that we have\n      dominance information.  */\n   calculate_dominance_info (CDI_DOMINATORS);\n@@ -1634,7 +1635,7 @@ get_non_trapping (void)\n \n static bool\n cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n-\t\t\tedge e0, edge e1, struct pointer_set_t *nontrap)\n+\t\t\tedge e0, edge e1, hash_set<tree> *nontrap)\n {\n   gimple assign = last_and_only_stmt (middle_bb);\n   tree lhs, rhs, name, name2;\n@@ -1659,7 +1660,7 @@ cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n   /* Prove that we can move the store down.  We could also check\n      TREE_THIS_NOTRAP here, but in that case we also could move stores,\n      whose value is not available readily, which we want to avoid.  */\n-  if (!pointer_set_contains (nontrap, lhs))\n+  if (!nontrap->contains (lhs))\n     return false;\n \n   /* Now we've checked the constraints, so do the transformation:"}, {"sha": "3dee5badf4f7a788341b6d6da9292b970b495d5c", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -30,7 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function.h\"\n #include \"timevar.h\"\n #include \"dumpfile.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-set.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n #include \"gimple-expr.h\"\n@@ -693,13 +693,13 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n     }\n \n   auto_vec<tree, alloc_count> fewvars;\n-  pointer_set_t *vars = NULL;\n+  hash_set<tree> *vars = NULL;\n \n   /* If we're already starting with 3/4 of alloc_count, go for a\n-     pointer_set, otherwise start with an unordered stack-allocated\n+     hash_set, otherwise start with an unordered stack-allocated\n      VEC.  */\n   if (i * 4 > alloc_count * 3)\n-    vars = pointer_set_create ();\n+    vars = new hash_set<tree>;\n \n   /* Now go through the initial debug stmts in DEST again, this time\n      actually inserting in VARS or FEWVARS.  Don't bother checking for\n@@ -720,7 +720,7 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n \tgcc_unreachable ();\n \n       if (vars)\n-\tpointer_set_insert (vars, var);\n+\tvars->add (var);\n       else\n \tfewvars.quick_push (var);\n     }\n@@ -754,7 +754,7 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n \t     or somesuch.  Adding `&& bb == src' to the condition\n \t     below will preserve all potentially relevant debug\n \t     notes.  */\n-\t  if (vars && pointer_set_insert (vars, var))\n+\t  if (vars && vars->add (var))\n \t    continue;\n \t  else if (!vars)\n \t    {\n@@ -769,11 +769,11 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n \t\tfewvars.quick_push (var);\n \t      else\n \t\t{\n-\t\t  vars = pointer_set_create ();\n+\t\t  vars = new hash_set<tree>;\n \t\t  for (i = 0; i < alloc_count; i++)\n-\t\t    pointer_set_insert (vars, fewvars[i]);\n+\t\t    vars->add (fewvars[i]);\n \t\t  fewvars.release ();\n-\t\t  pointer_set_insert (vars, var);\n+\t\t  vars->add (var);\n \t\t}\n \t    }\n \n@@ -786,7 +786,7 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n   while (bb != src && single_pred_p (bb));\n \n   if (vars)\n-    pointer_set_destroy (vars);\n+    delete vars;\n   else if (fewvars.exists ())\n     fewvars.release ();\n }"}, {"sha": "f2578b7e8f84c92ec7e403e1e767505c9f6a2b0d", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 33, "deletions": 45, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function.h\"\n #include \"gimple-pretty-print.h\"\n #include \"bitmap.h\"\n+#include \"hash-set.h\"\n #include \"pointer-set.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n@@ -60,7 +61,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Pointer set of potentially undefined ssa names, i.e.,\n    ssa names that are defined by phi with operands that\n    are not defined or potentially undefined.  */\n-static pointer_set_t *possibly_undefined_names = 0;\n+static hash_set<tree> *possibly_undefined_names = 0;\n \n /* Bit mask handling macros.  */\n #define MASK_SET_BIT(mask, pos) mask |= (1 << pos)\n@@ -89,7 +90,7 @@ has_undefined_value_p (tree t)\n {\n   return (ssa_undefined_value_p (t)\n           || (possibly_undefined_names\n-              && pointer_set_contains (possibly_undefined_names, t)));\n+              && possibly_undefined_names->contains (t)));\n }\n \n \n@@ -648,13 +649,13 @@ find_predicates (pred_chain_union *preds,\n static void\n collect_phi_def_edges (gimple phi, basic_block cd_root,\n                        vec<edge> *edges,\n-                       pointer_set_t *visited_phis)\n+                       hash_set<gimple> *visited_phis)\n {\n   size_t i, n;\n   edge opnd_edge;\n   tree opnd;\n \n-  if (pointer_set_insert (visited_phis, phi))\n+  if (visited_phis->add (phi))\n     return;\n \n   n = gimple_phi_num_args (phi);\n@@ -707,7 +708,6 @@ find_def_preds (pred_chain_union *preds, gimple phi)\n   vec<edge> def_edges = vNULL;\n   bool has_valid_pred = false;\n   basic_block phi_bb, cd_root = 0;\n-  pointer_set_t *visited_phis;\n \n   phi_bb = gimple_bb (phi);\n   /* First find the closest dominating bb to be\n@@ -716,9 +716,8 @@ find_def_preds (pred_chain_union *preds, gimple phi)\n   if (!cd_root)\n     return false;\n \n-  visited_phis = pointer_set_create ();\n-  collect_phi_def_edges (phi, cd_root, &def_edges, visited_phis);\n-  pointer_set_destroy (visited_phis);\n+  hash_set<gimple> visited_phis;\n+  collect_phi_def_edges (phi, cd_root, &def_edges, &visited_phis);\n \n   n = def_edges.length ();\n   if (n == 0)\n@@ -941,7 +940,7 @@ is_use_properly_guarded (gimple use_stmt,\n                          basic_block use_bb,\n                          gimple phi,\n                          unsigned uninit_opnds,\n-                         pointer_set_t *visited_phis);\n+                         hash_set<gimple> *visited_phis);\n \n /* Returns true if all uninitialized opnds are pruned. Returns false\n    otherwise. PHI is the phi node with uninitialized operands,\n@@ -983,7 +982,7 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gimple phi,\n \t\t\t\t\t      gimple flag_def,\n \t\t\t\t\t      tree boundary_cst,\n \t\t\t\t\t      enum tree_code cmp_code,\n-\t\t\t\t\t      pointer_set_t *visited_phis,\n+\t\t\t\t\t      hash_set<gimple> *visited_phis,\n \t\t\t\t\t      bitmap *visited_flag_phis)\n {\n   unsigned i;\n@@ -1153,7 +1152,7 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gimple phi,\n static bool\n use_pred_not_overlap_with_undef_path_pred (pred_chain_union preds,\n \t\t\t\t           gimple phi, unsigned uninit_opnds,\n-\t\t\t\t\t   pointer_set_t *visited_phis)\n+\t\t\t\t\t   hash_set<gimple> *visited_phis)\n {\n   unsigned int i, n;\n   gimple flag_def = 0;\n@@ -1818,11 +1817,11 @@ push_pred (pred_chain_union *norm_preds, pred_info pred)\n \n inline static void\n push_to_worklist (tree op, vec<pred_info, va_heap, vl_ptr> *work_list,\n-                  pointer_set_t *mark_set)\n+                  hash_set<tree> *mark_set)\n {\n-  if (pointer_set_contains (mark_set, op))\n+  if (mark_set->contains (op))\n     return;\n-  pointer_set_insert (mark_set, op);\n+  mark_set->add (op);\n \n   pred_info arg_pred;\n   arg_pred.pred_lhs = op;\n@@ -1907,7 +1906,7 @@ normalize_one_pred_1 (pred_chain_union *norm_preds,\n                       pred_info pred,\n                       enum tree_code and_or_code,\n                       vec<pred_info, va_heap, vl_ptr> *work_list,\n-\t\t      pointer_set_t *mark_set)\n+\t\t      hash_set<tree> *mark_set)\n {\n   if (!is_neq_zero_form_p (pred))\n     {\n@@ -1987,7 +1986,6 @@ normalize_one_pred (pred_chain_union *norm_preds,\n                     pred_info pred)\n {\n   vec<pred_info, va_heap, vl_ptr> work_list = vNULL;\n-  pointer_set_t *mark_set = NULL;\n   enum tree_code and_or_code = ERROR_MARK;\n   pred_chain norm_chain = vNULL;\n \n@@ -2015,46 +2013,44 @@ normalize_one_pred (pred_chain_union *norm_preds,\n     }\n \n   work_list.safe_push (pred);\n-  mark_set = pointer_set_create ();\n+  hash_set<tree> mark_set;\n \n   while (!work_list.is_empty ())\n     {\n       pred_info a_pred = work_list.pop ();\n       normalize_one_pred_1 (norm_preds, &norm_chain, a_pred,\n-                            and_or_code, &work_list, mark_set);\n+                            and_or_code, &work_list, &mark_set);\n     }\n   if (and_or_code == BIT_AND_EXPR)\n     norm_preds->safe_push (norm_chain);\n \n   work_list.release ();\n-  pointer_set_destroy (mark_set);\n }\n \n static void\n normalize_one_pred_chain (pred_chain_union *norm_preds,\n                           pred_chain one_chain)\n {\n   vec<pred_info, va_heap, vl_ptr> work_list = vNULL;\n-  pointer_set_t *mark_set = pointer_set_create ();\n+  hash_set<tree> mark_set;\n   pred_chain norm_chain = vNULL;\n   size_t i;\n \n   for (i = 0; i < one_chain.length (); i++)\n     {\n       work_list.safe_push (one_chain[i]);\n-      pointer_set_insert (mark_set, one_chain[i].pred_lhs);\n+      mark_set.add (one_chain[i].pred_lhs);\n     }\n \n   while (!work_list.is_empty ())\n     {\n       pred_info a_pred = work_list.pop ();\n       normalize_one_pred_1 (0, &norm_chain, a_pred,\n-                            BIT_AND_EXPR, &work_list, mark_set);\n+                            BIT_AND_EXPR, &work_list, &mark_set);\n     }\n \n   norm_preds->safe_push (norm_chain);\n   work_list.release ();\n-  pointer_set_destroy (mark_set);\n }\n \n /* Normalize predicate chains PREDS and returns the normalized one.  */\n@@ -2112,15 +2108,15 @@ is_use_properly_guarded (gimple use_stmt,\n                          basic_block use_bb,\n                          gimple phi,\n                          unsigned uninit_opnds,\n-                         pointer_set_t *visited_phis)\n+                         hash_set<gimple> *visited_phis)\n {\n   basic_block phi_bb;\n   pred_chain_union preds = vNULL;\n   pred_chain_union def_preds = vNULL;\n   bool has_valid_preds = false;\n   bool is_properly_guarded = false;\n \n-  if (pointer_set_insert (visited_phis, phi))\n+  if (visited_phis->add (phi))\n     return false;\n \n   phi_bb = gimple_bb (phi);\n@@ -2181,7 +2177,7 @@ is_use_properly_guarded (gimple use_stmt,\n static gimple\n find_uninit_use (gimple phi, unsigned uninit_opnds,\n                  vec<gimple> *worklist,\n-\t\t pointer_set_t *added_to_worklist)\n+\t\t hash_set<gimple> *added_to_worklist)\n {\n   tree phi_result;\n   use_operand_p use_p;\n@@ -2192,28 +2188,22 @@ find_uninit_use (gimple phi, unsigned uninit_opnds,\n \n   FOR_EACH_IMM_USE_FAST (use_p, iter, phi_result)\n     {\n-      pointer_set_t *visited_phis;\n       basic_block use_bb;\n \n       use_stmt = USE_STMT (use_p);\n       if (is_gimple_debug (use_stmt))\n \tcontinue;\n \n-      visited_phis = pointer_set_create ();\n-\n       if (gimple_code (use_stmt) == GIMPLE_PHI)\n \tuse_bb = gimple_phi_arg_edge (use_stmt,\n \t\t\t\t      PHI_ARG_INDEX_FROM_USE (use_p))->src;\n       else\n \tuse_bb = gimple_bb (use_stmt);\n \n+      hash_set<gimple> visited_phis;\n       if (is_use_properly_guarded (use_stmt, use_bb, phi, uninit_opnds,\n-                                   visited_phis))\n-        {\n-          pointer_set_destroy (visited_phis);\n-          continue;\n-        }\n-      pointer_set_destroy (visited_phis);\n+                                   &visited_phis))\n+\tcontinue;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n         {\n@@ -2226,7 +2216,7 @@ find_uninit_use (gimple phi, unsigned uninit_opnds,\n \n       /* Found a phi use that is not guarded,\n          add the phi to the worklist.  */\n-      if (!pointer_set_insert (added_to_worklist, use_stmt))\n+      if (!added_to_worklist->add (use_stmt))\n         {\n           if (dump_file && (dump_flags & TDF_DETAILS))\n             {\n@@ -2235,7 +2225,7 @@ find_uninit_use (gimple phi, unsigned uninit_opnds,\n             }\n \n           worklist->safe_push (use_stmt);\n-          pointer_set_insert (possibly_undefined_names, phi_result);\n+          possibly_undefined_names->add (phi_result);\n         }\n     }\n \n@@ -2252,7 +2242,7 @@ find_uninit_use (gimple phi, unsigned uninit_opnds,\n \n static void\n warn_uninitialized_phi (gimple phi, vec<gimple> *worklist,\n-                        pointer_set_t *added_to_worklist)\n+                        hash_set<gimple> *added_to_worklist)\n {\n   unsigned uninit_opnds;\n   gimple uninit_use_stmt = 0;\n@@ -2339,7 +2329,6 @@ pass_late_warn_uninitialized::execute (function *fun)\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n   vec<gimple> worklist = vNULL;\n-  pointer_set_t *added_to_worklist;\n \n   calculate_dominance_info (CDI_DOMINATORS);\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n@@ -2350,8 +2339,8 @@ pass_late_warn_uninitialized::execute (function *fun)\n \n   timevar_push (TV_TREE_UNINIT);\n \n-  possibly_undefined_names = pointer_set_create ();\n-  added_to_worklist = pointer_set_create ();\n+  possibly_undefined_names = new hash_set<tree>;\n+  hash_set<gimple> added_to_worklist;\n \n   /* Initialize worklist  */\n   FOR_EACH_BB_FN (bb, fun)\n@@ -2373,7 +2362,7 @@ pass_late_warn_uninitialized::execute (function *fun)\n \t\t&& uninit_undefined_value_p (op))\n \t      {\n \t\tworklist.safe_push (phi);\n-\t\tpointer_set_insert (added_to_worklist, phi);\n+\t\tadded_to_worklist.add (phi);\n \t\tif (dump_file && (dump_flags & TDF_DETAILS))\n \t\t  {\n \t\t    fprintf (dump_file, \"[WORKLIST]: add to initial list: \");\n@@ -2388,12 +2377,11 @@ pass_late_warn_uninitialized::execute (function *fun)\n     {\n       gimple cur_phi = 0;\n       cur_phi = worklist.pop ();\n-      warn_uninitialized_phi (cur_phi, &worklist, added_to_worklist);\n+      warn_uninitialized_phi (cur_phi, &worklist, &added_to_worklist);\n     }\n \n   worklist.release ();\n-  pointer_set_destroy (added_to_worklist);\n-  pointer_set_destroy (possibly_undefined_names);\n+  delete possibly_undefined_names;\n   possibly_undefined_names = NULL;\n   free_dominance_info (CDI_POST_DOMINATORS);\n   timevar_pop (TV_TREE_UNINIT);"}, {"sha": "d95cf78a56b19ea1c83e7817cb7c9f1401129828", "filename": "gcc/tree.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -5143,7 +5143,7 @@ struct free_lang_data_d\n   vec<tree> worklist;\n \n   /* Set of traversed objects.  Used to avoid duplicate visits.  */\n-  struct pointer_set_t *pset;\n+  hash_set<tree> *pset;\n \n   /* Array of symbols to process with free_lang_data_in_decl.  */\n   vec<tree> decls;\n@@ -5208,7 +5208,7 @@ add_tree_to_fld_list (tree t, struct free_lang_data_d *fld)\n static inline void\n fld_worklist_push (tree t, struct free_lang_data_d *fld)\n {\n-  if (t && !is_lang_specific (t) && !pointer_set_contains (fld->pset, t))\n+  if (t && !is_lang_specific (t) && !fld->pset->contains (t))\n     fld->worklist.safe_push ((t));\n }\n \n@@ -5374,7 +5374,7 @@ find_decls_types (tree t, struct free_lang_data_d *fld)\n {\n   while (1)\n     {\n-      if (!pointer_set_contains (fld->pset, t))\n+      if (!fld->pset->contains (t))\n \twalk_tree (&t, find_decls_types_r, fld, fld->pset);\n       if (fld->worklist.is_empty ())\n \tbreak;\n@@ -5584,7 +5584,7 @@ free_lang_data_in_cgraph (void)\n   alias_pair *p;\n \n   /* Initialize sets and arrays to store referenced decls and types.  */\n-  fld.pset = pointer_set_create ();\n+  fld.pset = new hash_set<tree>;\n   fld.worklist.create (0);\n   fld.decls.create (100);\n   fld.types.create (100);\n@@ -5614,7 +5614,7 @@ free_lang_data_in_cgraph (void)\n   FOR_EACH_VEC_ELT (fld.types, i, t)\n     free_lang_data_in_type (t);\n \n-  pointer_set_destroy (fld.pset);\n+  delete fld.pset;\n   fld.worklist.release ();\n   fld.decls.release ();\n   fld.types.release ();\n@@ -10824,7 +10824,7 @@ num_ending_zeros (const_tree x)\n \n static tree\n walk_type_fields (tree type, walk_tree_fn func, void *data,\n-\t\t  struct pointer_set_t *pset, walk_tree_lh lh)\n+\t\t  hash_set<tree> *pset, walk_tree_lh lh)\n {\n   tree result = NULL_TREE;\n \n@@ -10906,7 +10906,7 @@ walk_type_fields (tree type, walk_tree_fn func, void *data,\n \n tree\n walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n-\t     struct pointer_set_t *pset, walk_tree_lh lh)\n+\t     hash_set<tree> *pset, walk_tree_lh lh)\n {\n   enum tree_code code;\n   int walk_subtrees;\n@@ -10927,7 +10927,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \n   /* Don't walk the same tree twice, if the user has requested\n      that we avoid doing so.  */\n-  if (pset && pointer_set_insert (pset, *tp))\n+  if (pset && pset->add (*tp))\n     return NULL_TREE;\n \n   /* Call the function.  */\n@@ -11242,11 +11242,9 @@ walk_tree_without_duplicates_1 (tree *tp, walk_tree_fn func, void *data,\n \t\t\t\twalk_tree_lh lh)\n {\n   tree result;\n-  struct pointer_set_t *pset;\n \n-  pset = pointer_set_create ();\n-  result = walk_tree_1 (tp, func, data, pset, lh);\n-  pointer_set_destroy (pset);\n+  hash_set<tree> pset;\n+  result = walk_tree_1 (tp, func, data, &pset, lh);\n   return result;\n }\n "}, {"sha": "e000e4e26d338d0e2e927201c1b6435a5c385673", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_H\n \n #include \"tree-core.h\"\n+#include \"hash-set.h\"\n #include \"wide-int.h\"\n #include \"inchash.h\"\n \n@@ -4334,7 +4335,7 @@ extern void using_eh_for_cleanups (void);\n extern bool using_eh_for_cleanups_p (void);\n extern const char *get_tree_code_name (enum tree_code);\n extern void set_call_expr_flags (tree, int);\n-extern tree walk_tree_1 (tree*, walk_tree_fn, void*, struct pointer_set_t*,\n+extern tree walk_tree_1 (tree*, walk_tree_fn, void*, hash_set<tree>*,\n \t\t\t walk_tree_lh);\n extern tree walk_tree_without_duplicates_1 (tree*, walk_tree_fn, void*,\n \t\t\t\t\t    walk_tree_lh);"}, {"sha": "ffdee650f7eb398968c6d0639ee6fe6ab694da94", "filename": "gcc/value-prof.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -59,6 +59,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"data-streamer.h\"\n #include \"builtins.h\"\n #include \"tree-nested.h\"\n+#include \"hash-set.h\"\n \n /* In this file value profile based optimizations are placed.  Currently the\n    following optimizations are implemented (for more detailed descriptions\n@@ -515,10 +516,10 @@ static bool error_found = false;\n static int\n visit_hist (void **slot, void *data)\n {\n-  struct pointer_set_t *visited = (struct pointer_set_t *) data;\n+  hash_set<histogram_value> *visited = (hash_set<histogram_value> *) data;\n   histogram_value hist = *(histogram_value *) slot;\n \n-  if (!pointer_set_contains (visited, hist)\n+  if (!visited->contains (hist)\n       && hist->type != HIST_TYPE_TIME_PROFILE)\n     {\n       error (\"dead histogram\");\n@@ -538,10 +539,9 @@ verify_histograms (void)\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n   histogram_value hist;\n-  struct pointer_set_t *visited_hists;\n \n   error_found = false;\n-  visited_hists = pointer_set_create ();\n+  hash_set<histogram_value> visited_hists;\n   FOR_EACH_BB_FN (bb, cfun)\n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n@@ -558,12 +558,11 @@ verify_histograms (void)\n \t\tdump_histogram_value (stderr, hist);\n \t\terror_found = true;\n \t      }\n-            pointer_set_insert (visited_hists, hist);\n+            visited_hists.add (hist);\n \t  }\n       }\n   if (VALUE_HISTOGRAMS (cfun))\n-    htab_traverse (VALUE_HISTOGRAMS (cfun), visit_hist, visited_hists);\n-  pointer_set_destroy (visited_hists);\n+    htab_traverse (VALUE_HISTOGRAMS (cfun), visit_hist, &visited_hists);\n   if (error_found)\n     internal_error (\"verify_histograms failed\");\n }"}, {"sha": "9d8602bc7f61ccb1b49f4f3cb7801b9c9ef00d7c", "filename": "gcc/varasm.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -51,7 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"common/common-target.h\"\n #include \"targhooks.h\"\n #include \"cgraph.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-set.h\"\n #include \"asan.h\"\n #include \"basic-block.h\"\n \n@@ -2249,7 +2249,7 @@ static bool pending_assemble_externals_processed;\n \n /* Avoid O(external_decls**2) lookups in the pending_assemble_externals\n    TREE_LIST in assemble_external.  */\n-static struct pointer_set_t *pending_assemble_externals_set;\n+static hash_set<tree> *pending_assemble_externals_set;\n \n /* True if DECL is a function decl for which no out-of-line copy exists.\n    It is assumed that DECL's assembler name has been set.  */\n@@ -2303,7 +2303,7 @@ process_pending_assemble_externals (void)\n \n   pending_assemble_externals = 0;\n   pending_assemble_externals_processed = true;\n-  pointer_set_destroy (pending_assemble_externals_set);\n+  delete pending_assemble_externals_set;\n #endif\n }\n \n@@ -2361,7 +2361,7 @@ assemble_external (tree decl ATTRIBUTE_UNUSED)\n       return;\n     }\n \n-  if (! pointer_set_insert (pending_assemble_externals_set, decl))\n+  if (! pending_assemble_externals_set->add (decl))\n     pending_assemble_externals = tree_cons (NULL, decl,\n \t\t\t\t\t    pending_assemble_externals);\n #endif\n@@ -5991,7 +5991,7 @@ init_varasm_once (void)\n     readonly_data_section = text_section;\n \n #ifdef ASM_OUTPUT_EXTERNAL\n-  pending_assemble_externals_set = pointer_set_create ();\n+  pending_assemble_externals_set = new hash_set<tree>;\n #endif\n }\n "}, {"sha": "41b83d7599c629f1f428bfd286d3b16d6462aa70", "filename": "gcc/varpool.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-alias.h\"\n #include \"gimple.h\"\n #include \"lto-streamer.h\"\n+#include \"hash-set.h\"\n \n const char * const tls_model_names[]={\"none\", \"tls-emulated\", \"tls-real\",\n \t\t\t\t      \"tls-global-dynamic\", \"tls-local-dynamic\",\n@@ -577,7 +578,7 @@ varpool_remove_unreferenced_decls (void)\n   varpool_node *first = (varpool_node *)(void *)1;\n   int i;\n   struct ipa_ref *ref = NULL;\n-  struct pointer_set_t *referenced = pointer_set_create ();\n+  hash_set<varpool_node *> referenced;\n \n   if (seen_error ())\n     return;\n@@ -624,7 +625,7 @@ varpool_remove_unreferenced_decls (void)\n \t      && vnode->analyzed)\n \t    enqueue_node (vnode, &first);\n \t  else\n-\t    pointer_set_insert (referenced, node);\n+\t    referenced.add (node);\n \t}\n     }\n   if (cgraph_dump_file)\n@@ -636,13 +637,13 @@ varpool_remove_unreferenced_decls (void)\n \t{\n           if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \" %s\", node->asm_name ());\n-\t  if (pointer_set_contains (referenced, node))\n+\t  if (referenced.contains (node))\n \t    node->remove_initializer ();\n \t  else\n \t    node->remove ();\n \t}\n     }\n-  pointer_set_destroy (referenced);\n+\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"\\n\");\n }"}]}