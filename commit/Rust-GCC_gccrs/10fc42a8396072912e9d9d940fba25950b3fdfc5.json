{"sha": "10fc42a8396072912e9d9d940fba25950b3fdfc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBmYzQyYTgzOTYwNzI5MTJlOWQ5ZDk0MGZiYTI1OTUwYjNmZGZjNQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-08-24T19:17:10Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-09-09T20:57:03Z"}, "message": "analyzer: use objects for state_machine::state_t\n\nThis patch is preliminary work towards generalizing sm-malloc.cc so that\nit can check APIs other than just malloc/free (and e.g. detect\nmismatching alloc/dealloc pairs).\n\nGeneralize states in state machines so that, rather than state_t being\njust an \"unsigned\", it becomes a \"const state *\", where the underlying\nstate objects are immutable objects managed by the state machine in\nquestion, and can e.g. have vfuncs and extra fields.  The start state\nm_start becomes a member of the state_machine base_class.\n\ngcc/analyzer/ChangeLog:\n\t* checker-path.cc (state_change_event::get_desc): Update\n\tstate_machine::get_state_name calls to state::get_name.\n\t(warning_event::get_desc): Likewise.\n\t* diagnostic-manager.cc\n\t(null_assignment_sm_context::on_transition): Update comparison\n\tagainst 0 with comparison with m_sm.get_start_state.\n\t(diagnostic_manager::prune_for_sm_diagnostic): Update\n\tstate_machine::get_state_name calls to state::get_name.\n\t* engine.cc (impl_sm_context::on_transition): Likewise.\n\t(exploded_node::get_dot_fillcolor): Use get_id when summing\n\tthe sm states.\n\t* program-state.cc (sm_state_map::sm_state_map): Don't hardcode\n\t0 as the start state when initializing m_global_state.\n\t(sm_state_map::print): Use dump_to_pp rather than get_state_name\n\twhen dumping states.\n\t(sm_state_map::is_empty_p): Don't hardcode 0 as the start state\n\twhen examining m_global_state.\n\t(sm_state_map::hash): Use get_id when hashing states.\n\t(selftest::test_sm_state_map): Use state objects rather than\n\tarbitrary hardcoded integers.\n\t(selftest::test_program_state_merging): Likewise.\n\t(selftest::test_program_state_merging_2): Likewise.\n\t* sm-file.cc (fileptr_state_machine::m_start): Move to base class.\n\t(file_diagnostic::describe_state_change): Use get_start_state.\n\t(fileptr_state_machine::fileptr_state_machine): Drop m_start\n\tinitialization.\n\t* sm-malloc.cc (malloc_state_machine::m_start): Move to base\n\tclass.\n\t(malloc_diagnostic::describe_state_change): Use get_start_state.\n\t(possible_null::describe_state_change): Likewise.\n\t(malloc_state_machine::malloc_state_machine): Drop m_start\n\tinitialization.\n\t* sm-pattern-test.cc (pattern_test_state_machine::m_start): Move\n\tto base class.\n\t(pattern_test_state_machine::pattern_test_state_machine): Drop\n\tm_start initialization.\n\t* sm-sensitive.cc (sensitive_state_machine::m_start): Move to base\n\tclass.\n\t(sensitive_state_machine::sensitive_state_machine): Drop m_start\n\tinitialization.\n\t* sm-signal.cc (signal_state_machine::m_start): Move to base\n\tclass.\n\t(signal_state_machine::signal_state_machine): Drop m_start\n\tinitialization.\n\t* sm-taint.cc (taint_state_machine::m_start): Move to base class.\n\t(taint_state_machine::taint_state_machine): Drop m_start\n\tinitialization.\n\t* sm.cc (state_machine::state::dump_to_pp): New.\n\t(state_machine::state_machine): Move here from sm.h.  Initialize\n\tm_next_state_id and m_start.\n\t(state_machine::add_state): Reimplement in terms of state objects.\n\t(state_machine::get_state_name): Delete.\n\t(state_machine::get_state_by_name): Reimplement in terms of state\n\tobjects.  Make const.\n\t(state_machine::validate): Delete.\n\t(state_machine::dump_to_pp): Reimplement in terms of state\n\tobjects.\n\t* sm.h (state_machine::state): New class.\n\t(state_machine::state_t): Convert typedef from \"unsigned\" to\n\t\"const state_machine::state *\".\n\t(state_machine::state_machine): Move to sm.cc.\n\t(state_machine::get_default_state): Use m_start rather than\n\thardcoding 0.\n\t(state_machine::get_state_name): Delete.\n\t(state_machine::get_state_by_name): Make const.\n\t(state_machine::get_start_state): New accessor.\n\t(state_machine::alloc_state_id): New.\n\t(state_machine::m_state_names): Drop in favor of...\n\t(state_machine::m_states): New field\n\t(state_machine::m_start): New field\n\t(start_start_p): Delete.", "tree": {"sha": "5b8181d80fcc945a0f4a1a97cf974d62cff26bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b8181d80fcc945a0f4a1a97cf974d62cff26bec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10fc42a8396072912e9d9d940fba25950b3fdfc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10fc42a8396072912e9d9d940fba25950b3fdfc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10fc42a8396072912e9d9d940fba25950b3fdfc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10fc42a8396072912e9d9d940fba25950b3fdfc5/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "749476b4be1f8ddf482910f907a5b56eb5f3e138", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/749476b4be1f8ddf482910f907a5b56eb5f3e138", "html_url": "https://github.com/Rust-GCC/gccrs/commit/749476b4be1f8ddf482910f907a5b56eb5f3e138"}], "stats": {"total": 255, "additions": 136, "deletions": 119}, "files": [{"sha": "2503d024a830fd353c1bb4a8aacd4ef8542b8cba", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=10fc42a8396072912e9d9d940fba25950b3fdfc5", "patch": "@@ -265,17 +265,17 @@ state_change_event::get_desc (bool can_colorize) const\n \t\t   \"%s (state of %qE: %qs -> %qs, origin: %qE)\",\n \t\t   custom_desc.m_buffer,\n \t\t   var,\n-\t\t   m_sm.get_state_name (m_from),\n-\t\t   m_sm.get_state_name (m_to),\n+\t\t   m_from->get_name (),\n+\t\t   m_to->get_name (),\n \t\t   origin);\n \t      else\n \t\tresult = make_label_text\n \t\t  (can_colorize,\n \t\t   \"%s (state of %qE: %qs -> %qs, NULL origin)\",\n \t\t   custom_desc.m_buffer,\n \t\t   var,\n-\t\t   m_sm.get_state_name (m_from),\n-\t\t   m_sm.get_state_name (m_to));\n+\t\t   m_from->get_name (),\n+\t\t   m_to->get_name ());\n \t      custom_desc.maybe_free ();\n \t      return result;\n \t    }\n@@ -295,26 +295,26 @@ state_change_event::get_desc (bool can_colorize) const\n \t    (can_colorize,\n \t     \"state of %qs: %qs -> %qs (origin: %qs)\",\n \t     sval_desc.m_buffer,\n-\t     m_sm.get_state_name (m_from),\n-\t     m_sm.get_state_name (m_to),\n+\t     m_from->get_name (),\n+\t     m_to->get_name (),\n \t     origin_desc.m_buffer);\n \t}\n       else\n \treturn make_label_text\n \t  (can_colorize,\n \t   \"state of %qs: %qs -> %qs (NULL origin)\",\n \t   sval_desc.m_buffer,\n-\t   m_sm.get_state_name (m_from),\n-\t   m_sm.get_state_name (m_to));\n+\t   m_from->get_name (),\n+\t   m_to->get_name ());\n     }\n   else\n     {\n       gcc_assert (m_origin == NULL);\n       return make_label_text\n \t(can_colorize,\n \t \"global state: %qs -> %qs\",\n-\t m_sm.get_state_name (m_from),\n-\t m_sm.get_state_name (m_to));\n+\t m_from->get_name (),\n+\t m_to->get_name ());\n     }\n }\n \n@@ -876,7 +876,7 @@ warning_event::get_desc (bool can_colorize) const\n \t\t= make_label_text (can_colorize,\n \t\t\t\t   \"%s (%qE is in state %qs)\",\n \t\t\t\t   ev_desc.m_buffer,\n-\t\t\t\t   m_var,m_sm->get_state_name (m_state));\n+\t\t\t\t   m_var, m_state->get_name ());\n \t      ev_desc.maybe_free ();\n \t      return result;\n \t    }\n@@ -888,8 +888,7 @@ warning_event::get_desc (bool can_colorize) const\n   if (m_sm)\n     return make_label_text (can_colorize,\n \t\t\t    \"here (%qE is in state %qs)\",\n-\t\t\t    m_var,\n-\t\t\t    m_sm->get_state_name (m_state));\n+\t\t\t    m_var, m_state->get_name ());\n   else\n     return label_text::borrow (\"here\");\n }"}, {"sha": "04c7d2ac4d3f08d9793202147e4947b3ab8785d5", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=10fc42a8396072912e9d9d940fba25950b3fdfc5", "patch": "@@ -775,7 +775,7 @@ struct null_assignment_sm_context : public sm_context\n \t\t      state_machine::state_t to,\n \t\t      tree origin ATTRIBUTE_UNUSED) FINAL OVERRIDE\n   {\n-    if (from != 0)\n+    if (from != m_sm.get_start_state ())\n       return;\n \n     const svalue *var_new_sval\n@@ -1207,12 +1207,12 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t\t  label_text sval_desc = sval->get_desc ();\n \t\t  log (\"considering event %i (%s), with sval: %qs, state: %qs\",\n \t\t       idx, event_kind_to_string (base_event->m_kind),\n-\t\t       sval_desc.m_buffer, sm->get_state_name (state));\n+\t\t       sval_desc.m_buffer, state->get_name ());\n \t\t}\n \t      else\n \t\tlog (\"considering event %i (%s), with global state: %qs\",\n \t\t     idx, event_kind_to_string (base_event->m_kind),\n-\t\t     sm->get_state_name (state));\n+\t\t     state->get_name ());\n \t    }\n \t  else\n \t    log (\"considering event %i\", idx);\n@@ -1275,8 +1275,8 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t\t    sval = state_change->m_origin;\n \t\t  }\n \t\tlog (\"event %i: switching state of interest from %qs to %qs\",\n-\t\t     idx, sm->get_state_name (state_change->m_to),\n-\t\t     sm->get_state_name (state_change->m_from));\n+\t\t     idx, state_change->m_to->get_name (),\n+\t\t     state_change->m_from->get_name ());\n \t\tstate = state_change->m_from;\n \t      }\n \t    else if (m_verbosity < 4)"}, {"sha": "05121e34b37589c4898f419bd031fb95e40766b0", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=10fc42a8396072912e9d9d940fba25950b3fdfc5", "patch": "@@ -236,8 +236,8 @@ class impl_sm_context : public sm_context\n \t  logger->log (\"%s: state transition of %qE: %s -> %s\",\n \t\t       m_sm.get_name (),\n \t\t       var,\n-\t\t       m_sm.get_state_name (from),\n-\t\t       m_sm.get_state_name (to));\n+\t\t       from->get_name (),\n+\t\t       to->get_name ());\n \tm_new_smap->set_state (m_new_state->m_region_model, var_new_sval,\n \t\t\t       to, origin_new_sval, m_eg.get_ext_state ());\n       }\n@@ -815,8 +815,8 @@ exploded_node::get_dot_fillcolor () const\n       for (sm_state_map::iterator_t iter = smap->begin ();\n \t   iter != smap->end ();\n \t   ++iter)\n-\ttotal_sm_state += (*iter).second.m_state;\n-      total_sm_state += smap->get_global_state ();\n+\ttotal_sm_state += (*iter).second.m_state->get_id ();\n+      total_sm_state += smap->get_global_state ()->get_id ();\n     }\n \n   if (total_sm_state > 0)"}, {"sha": "71bb2864d6de0c9fdf0bf68379af8eaa055c8484", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 44, "deletions": 28, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=10fc42a8396072912e9d9d940fba25950b3fdfc5", "patch": "@@ -115,7 +115,7 @@ extrinsic_state::get_model_manager () const\n /* sm_state_map's ctor.  */\n \n sm_state_map::sm_state_map (const state_machine &sm, int sm_idx)\n-: m_sm (sm), m_sm_idx (sm_idx), m_map (), m_global_state (0)\n+: m_sm (sm), m_sm_idx (sm_idx), m_map (), m_global_state (sm.get_start_state ())\n {\n }\n \n@@ -143,7 +143,8 @@ sm_state_map::print (const region_model *model,\n     {\n       if (multiline)\n \tpp_string (pp, \"  \");\n-      pp_printf (pp, \"global: %s\", m_sm.get_state_name (m_global_state));\n+      pp_string (pp, \"global: \");\n+      m_global_state->dump_to_pp (pp);\n       if (multiline)\n \tpp_newline (pp);\n       first = false;\n@@ -163,7 +164,8 @@ sm_state_map::print (const region_model *model,\n       sval->dump_to_pp (pp, simple);\n \n       entry_t e = (*iter).second;\n-      pp_printf (pp, \": %s\", m_sm.get_state_name (e.m_state));\n+      pp_string (pp, \": \");\n+      e.m_state->dump_to_pp (pp);\n       if (model)\n \tif (tree rep = model->get_representative_tree (sval))\n \t  {\n@@ -212,7 +214,7 @@ sm_state_map::dump (bool simple) const\n bool\n sm_state_map::is_empty_p () const\n {\n-  return m_map.elements () == 0 && m_global_state == 0;\n+  return m_map.elements () == 0 && m_global_state == m_sm.get_start_state ();\n }\n \n /* Generate a hash value for this sm_state_map.  */\n@@ -232,11 +234,11 @@ sm_state_map::hash () const\n       inchash::hash hstate;\n       hstate.add_ptr ((*iter).first);\n       entry_t e = (*iter).second;\n-      hstate.add_int (e.m_state);\n+      hstate.add_int (e.m_state->get_id ());\n       hstate.add_ptr (e.m_origin);\n       result ^= hstate.end ();\n     }\n-  result ^= m_global_state;\n+  result ^= m_global_state->get_id ();\n \n   return result;\n }\n@@ -1054,9 +1056,12 @@ test_sm_state_map ()\n   auto_delete_vec <state_machine> checkers;\n   checkers.safe_push (sm);\n   extrinsic_state ext_state (checkers);\n+  state_machine::state_t start = sm->get_start_state ();\n \n   /* Test setting states on svalue_id instances directly.  */\n   {\n+    const state_machine::state test_state_42 (\"test state 42\", 42);\n+    const state_machine::state_t TEST_STATE_42 = &test_state_42;\n     region_model_manager mgr;\n     region_model model (&mgr);\n     const svalue *x_sval = model.get_rvalue (x, NULL);\n@@ -1065,22 +1070,25 @@ test_sm_state_map ()\n \n     sm_state_map map (*sm, 0);\n     ASSERT_TRUE (map.is_empty_p ());\n-    ASSERT_EQ (map.get_state (x_sval, ext_state), 0);\n+    ASSERT_EQ (map.get_state (x_sval, ext_state), start);\n \n-    map.impl_set_state (x_sval, 42, z_sval, ext_state);\n-    ASSERT_EQ (map.get_state (x_sval, ext_state), 42);\n+    map.impl_set_state (x_sval, TEST_STATE_42, z_sval, ext_state);\n+    ASSERT_EQ (map.get_state (x_sval, ext_state), TEST_STATE_42);\n     ASSERT_EQ (map.get_origin (x_sval, ext_state), z_sval);\n-    ASSERT_EQ (map.get_state (y_sval, ext_state), 0);\n+    ASSERT_EQ (map.get_state (y_sval, ext_state), start);\n     ASSERT_FALSE (map.is_empty_p ());\n \n     map.impl_set_state (y_sval, 0, z_sval, ext_state);\n-    ASSERT_EQ (map.get_state (y_sval, ext_state), 0);\n+    ASSERT_EQ (map.get_state (y_sval, ext_state), start);\n \n     map.impl_set_state (x_sval, 0, z_sval, ext_state);\n-    ASSERT_EQ (map.get_state (x_sval, ext_state), 0);\n+    ASSERT_EQ (map.get_state (x_sval, ext_state), start);\n     ASSERT_TRUE (map.is_empty_p ());\n   }\n \n+  const state_machine::state test_state_5 (\"test state 5\", 5);\n+  const state_machine::state_t TEST_STATE_5 = &test_state_5;\n+\n   /* Test setting states via equivalence classes.  */\n   {\n     region_model_manager mgr;\n@@ -1091,16 +1099,16 @@ test_sm_state_map ()\n \n     sm_state_map map (*sm, 0);\n     ASSERT_TRUE (map.is_empty_p ());\n-    ASSERT_EQ (map.get_state (x_sval, ext_state), 0);\n-    ASSERT_EQ (map.get_state (y_sval, ext_state), 0);\n+    ASSERT_EQ (map.get_state (x_sval, ext_state), start);\n+    ASSERT_EQ (map.get_state (y_sval, ext_state), start);\n \n     model.add_constraint (x, EQ_EXPR, y, NULL);\n \n     /* Setting x to a state should also update y, as they\n        are in the same equivalence class.  */\n-    map.set_state (&model, x_sval, 5, z_sval, ext_state);\n-    ASSERT_EQ (map.get_state (x_sval, ext_state), 5);\n-    ASSERT_EQ (map.get_state (y_sval, ext_state), 5);\n+    map.set_state (&model, x_sval, TEST_STATE_5, z_sval, ext_state);\n+    ASSERT_EQ (map.get_state (x_sval, ext_state), TEST_STATE_5);\n+    ASSERT_EQ (map.get_state (y_sval, ext_state), TEST_STATE_5);\n     ASSERT_EQ (map.get_origin (x_sval, ext_state), z_sval);\n     ASSERT_EQ (map.get_origin (y_sval, ext_state), z_sval);\n   }\n@@ -1119,18 +1127,22 @@ test_sm_state_map ()\n     ASSERT_EQ (map0.hash (), map1.hash ());\n     ASSERT_EQ (map0, map1);\n \n-    map1.impl_set_state (y_sval, 5, z_sval, ext_state);\n+    map1.impl_set_state (y_sval, TEST_STATE_5, z_sval, ext_state);\n     ASSERT_NE (map0.hash (), map1.hash ());\n     ASSERT_NE (map0, map1);\n \n     /* Make the same change to map2.  */\n-    map2.impl_set_state (y_sval, 5, z_sval, ext_state);\n+    map2.impl_set_state (y_sval, TEST_STATE_5, z_sval, ext_state);\n     ASSERT_EQ (map1.hash (), map2.hash ());\n     ASSERT_EQ (map1, map2);\n   }\n \n   /* Equality and hashing shouldn't depend on ordering.  */\n   {\n+    const state_machine::state test_state_2 (\"test state 2\", 2);\n+    const state_machine::state_t TEST_STATE_2 = &test_state_2;\n+    const state_machine::state test_state_3 (\"test state 3\", 3);\n+    const state_machine::state_t TEST_STATE_3 = &test_state_3;\n     sm_state_map map0 (*sm, 0);\n     sm_state_map map1 (*sm, 0);\n     sm_state_map map2 (*sm, 0);\n@@ -1144,13 +1156,13 @@ test_sm_state_map ()\n     const svalue *y_sval = model.get_rvalue (y, NULL);\n     const svalue *z_sval = model.get_rvalue (z, NULL);\n \n-    map1.impl_set_state (x_sval, 2, NULL, ext_state);\n-    map1.impl_set_state (y_sval, 3, NULL, ext_state);\n-    map1.impl_set_state (z_sval, 2, NULL, ext_state);\n+    map1.impl_set_state (x_sval, TEST_STATE_2, NULL, ext_state);\n+    map1.impl_set_state (y_sval, TEST_STATE_3, NULL, ext_state);\n+    map1.impl_set_state (z_sval, TEST_STATE_2, NULL, ext_state);\n \n-    map2.impl_set_state (z_sval, 2, NULL, ext_state);\n-    map2.impl_set_state (y_sval, 3, NULL, ext_state);\n-    map2.impl_set_state (x_sval, 2, NULL, ext_state);\n+    map2.impl_set_state (z_sval, TEST_STATE_2, NULL, ext_state);\n+    map2.impl_set_state (y_sval, TEST_STATE_3, NULL, ext_state);\n+    map2.impl_set_state (x_sval, TEST_STATE_2, NULL, ext_state);\n \n     ASSERT_EQ (map1.hash (), map2.hash ());\n     ASSERT_EQ (map1, map2);\n@@ -1241,7 +1253,8 @@ test_program_state_merging ()\n   model0->set_value (model0->get_lvalue (p, &ctxt),\n \t\t     ptr_sval, &ctxt);\n   sm_state_map *smap = s0.m_checker_states[0];\n-  const state_machine::state_t TEST_STATE = 3;\n+  const state_machine::state test_state (\"test state\", 0);\n+  const state_machine::state_t TEST_STATE = &test_state;\n   smap->impl_set_state (ptr_sval, TEST_STATE, NULL, ext_state);\n   ASSERT_EQ (smap->get_state (ptr_sval, ext_state), TEST_STATE);\n \n@@ -1293,18 +1306,21 @@ test_program_state_merging_2 ()\n   checkers.safe_push (make_signal_state_machine (NULL));\n   extrinsic_state ext_state (checkers);\n \n+  const state_machine::state test_state_0 (\"test state 0\", 0);\n+  const state_machine::state test_state_1 (\"test state 1\", 1);\n+  const state_machine::state_t TEST_STATE_0 = &test_state_0;\n+  const state_machine::state_t TEST_STATE_1 = &test_state_1;\n+\n   program_state s0 (ext_state);\n   {\n     sm_state_map *smap0 = s0.m_checker_states[0];\n-    const state_machine::state_t TEST_STATE_0 = 0;\n     smap0->set_global_state (TEST_STATE_0);\n     ASSERT_EQ (smap0->get_global_state (), TEST_STATE_0);\n   }\n \n   program_state s1 (ext_state);\n   {\n     sm_state_map *smap1 = s1.m_checker_states[0];\n-    const state_machine::state_t TEST_STATE_1 = 1;\n     smap1->set_global_state (TEST_STATE_1);\n     ASSERT_EQ (smap1->get_global_state (), TEST_STATE_1);\n   }"}, {"sha": "33b445195d55a8dfce35173f4124db027ba1681b", "filename": "gcc/analyzer/sm-file.cc", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm-file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm-file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-file.cc?ref=10fc42a8396072912e9d9d940fba25950b3fdfc5", "patch": "@@ -83,9 +83,6 @@ class fileptr_state_machine : public state_machine\n   bool can_purge_p (state_t s) const FINAL OVERRIDE;\n   pending_diagnostic *on_leak (tree var) const FINAL OVERRIDE;\n \n-  /* Start state.  */\n-  state_t m_start;\n-\n   /* State for a FILE * returned from fopen that hasn't been checked for\n      NULL.\n      It could be an open stream, or could be NULL.  */\n@@ -121,7 +118,7 @@ class file_diagnostic : public pending_diagnostic\n   label_text describe_state_change (const evdesc::state_change &change)\n     OVERRIDE\n   {\n-    if (change.m_old_state == m_sm.m_start\n+    if (change.m_old_state == m_sm.get_start_state ()\n \t&& change.m_new_state == m_sm.m_unchecked)\n       // TODO: verify that it's the fopen stmt, not a copy\n       return label_text::borrow (\"opened here\");\n@@ -229,7 +226,6 @@ class file_leak : public file_diagnostic\n fileptr_state_machine::fileptr_state_machine (logger *logger)\n : state_machine (\"file\", logger)\n {\n-  m_start = add_state (\"start\");\n   m_unchecked = add_state (\"unchecked\");\n   m_null = add_state (\"null\");\n   m_nonnull = add_state (\"nonnull\");"}, {"sha": "19afff4951963c7df3eedc91b0fabdafa3b9362b", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=10fc42a8396072912e9d9d940fba25950b3fdfc5", "patch": "@@ -98,9 +98,6 @@ class malloc_state_machine : public state_machine\n   bool reset_when_passed_to_unknown_fn_p (state_t s,\n \t\t\t\t\t  bool is_mutable) const FINAL OVERRIDE;\n \n-  /* Start state.  */\n-  state_t m_start;\n-\n   /* State for a pointer returned from malloc that hasn't been checked for\n      NULL.\n      It could be a pointer to heap-allocated memory, or could be NULL.  */\n@@ -147,7 +144,7 @@ class malloc_diagnostic : public pending_diagnostic\n   label_text describe_state_change (const evdesc::state_change &change)\n     OVERRIDE\n   {\n-    if (change.m_old_state == m_sm.m_start\n+    if (change.m_old_state == m_sm.get_start_state ()\n \t&& change.m_new_state == m_sm.m_unchecked)\n       // TODO: verify that it's the allocation stmt, not a copy\n       return label_text::borrow (\"allocated here\");\n@@ -258,7 +255,7 @@ class possible_null : public malloc_diagnostic\n   label_text describe_state_change (const evdesc::state_change &change)\n     FINAL OVERRIDE\n   {\n-    if (change.m_old_state == m_sm.m_start\n+    if (change.m_old_state == m_sm.get_start_state ()\n \t&& change.m_new_state == m_sm.m_unchecked)\n       {\n \tm_origin_of_unchecked_event = change.m_event_id;\n@@ -659,7 +656,6 @@ class free_of_non_heap : public malloc_diagnostic\n malloc_state_machine::malloc_state_machine (logger *logger)\n : state_machine (\"malloc\", logger)\n {\n-  m_start = add_state (\"start\");\n   m_unchecked = add_state (\"unchecked\");\n   m_null = add_state (\"null\");\n   m_nonnull = add_state (\"nonnull\");"}, {"sha": "6a59e8fff83fb4b48324862fd3fb98fd0ed1102a", "filename": "gcc/analyzer/sm-pattern-test.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-pattern-test.cc?ref=10fc42a8396072912e9d9d940fba25950b3fdfc5", "patch": "@@ -65,9 +65,6 @@ class pattern_test_state_machine : public state_machine\n \t\t     tree rhs) const FINAL OVERRIDE;\n \n   bool can_purge_p (state_t s) const FINAL OVERRIDE;\n-\n-private:\n-  state_t m_start;\n };\n \n class pattern_match : public pending_diagnostic_subclass<pattern_match>\n@@ -100,7 +97,6 @@ class pattern_match : public pending_diagnostic_subclass<pattern_match>\n pattern_test_state_machine::pattern_test_state_machine (logger *logger)\n : state_machine (\"pattern-test\", logger)\n {\n-  m_start = add_state (\"start\");\n }\n \n bool"}, {"sha": "f10008307af8609c463d3343857ba38814b5afb3", "filename": "gcc/analyzer/sm-sensitive.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm-sensitive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm-sensitive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-sensitive.cc?ref=10fc42a8396072912e9d9d940fba25950b3fdfc5", "patch": "@@ -66,9 +66,6 @@ class sensitive_state_machine : public state_machine\n \n   bool can_purge_p (state_t s) const FINAL OVERRIDE;\n \n-  /* Start state.  */\n-  state_t m_start;\n-\n   /* State for \"sensitive\" data, such as a password.  */\n   state_t m_sensitive;\n \n@@ -163,7 +160,6 @@ class exposure_through_output_file\n sensitive_state_machine::sensitive_state_machine (logger *logger)\n : state_machine (\"sensitive\", logger)\n {\n-  m_start = add_state (\"start\");\n   m_sensitive = add_state (\"sensitive\");\n   m_stop = add_state (\"stop\");\n }"}, {"sha": "21c9d58f6deff2bd2d3f4049adde39c838425a4d", "filename": "gcc/analyzer/sm-signal.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm-signal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm-signal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-signal.cc?ref=10fc42a8396072912e9d9d940fba25950b3fdfc5", "patch": "@@ -91,9 +91,6 @@ class signal_state_machine : public state_machine\n \n   /* These states are \"global\", rather than per-expression.  */\n \n-  /* Start state.  */\n-  state_t m_start;\n-\n   /* State for when we're in a signal handler.  */\n   state_t m_in_signal_handler;\n \n@@ -196,7 +193,6 @@ class signal_unsafe_call\n signal_state_machine::signal_state_machine (logger *logger)\n : state_machine (\"signal\", logger)\n {\n-  m_start = add_state (\"start\");\n   m_in_signal_handler = add_state (\"in_signal_handler\");\n   m_stop = add_state (\"stop\");\n }"}, {"sha": "385909ce26c17152cb14ceff0ab7c05583560989", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=10fc42a8396072912e9d9d940fba25950b3fdfc5", "patch": "@@ -66,9 +66,6 @@ class taint_state_machine : public state_machine\n \n   bool can_purge_p (state_t s) const FINAL OVERRIDE;\n \n-  /* Start state.  */\n-  state_t m_start;\n-\n   /* State for a \"tainted\" value: unsanitized data potentially under an\n      attacker's control.  */\n   state_t m_tainted;\n@@ -188,7 +185,6 @@ class tainted_array_index\n taint_state_machine::taint_state_machine (logger *logger)\n : state_machine (\"taint\", logger)\n {\n-  m_start = add_state (\"start\");\n   m_tainted = add_state (\"tainted\");\n   m_has_lb = add_state (\"has_lb\");\n   m_has_ub = add_state (\"has_ub\");"}, {"sha": "a333063c65ef31c03828e2cf82daeab75df38aed", "filename": "gcc/analyzer/sm.cc", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.cc?ref=10fc42a8396072912e9d9d940fba25950b3fdfc5", "patch": "@@ -45,6 +45,27 @@ any_pointer_p (tree var)\n   return POINTER_TYPE_P (TREE_TYPE (var));\n }\n \n+\n+/* class state_machine::state.  */\n+\n+/* Base implementation of dump_to_pp vfunc.  */\n+\n+void\n+state_machine::state::dump_to_pp (pretty_printer *pp) const\n+{\n+  pp_string (pp, m_name);\n+}\n+\n+/* class state_machine.  */\n+\n+/* state_machine's ctor.  */\n+\n+state_machine::state_machine (const char *name, logger *logger)\n+: log_user (logger), m_name (name), m_next_state_id (0),\n+  m_start (add_state (\"start\"))\n+{\n+}\n+\n /* Add a state with name NAME to this state_machine.\n    The string is required to outlive the state_machine.\n \n@@ -53,50 +74,39 @@ any_pointer_p (tree var)\n state_machine::state_t\n state_machine::add_state (const char *name)\n {\n-  m_state_names.safe_push (name);\n-  return m_state_names.length () - 1;\n-}\n-\n-/* Get the name of state S within this state_machine.  */\n-\n-const char *\n-state_machine::get_state_name (state_t s) const\n-{\n-  return m_state_names[s];\n+  state *s = new state (name, alloc_state_id ());\n+  m_states.safe_push (s);\n+  return s;\n }\n \n /* Get the state with name NAME, which must exist.\n    This is purely intended for use in selftests.  */\n \n state_machine::state_t\n-state_machine::get_state_by_name (const char *name)\n+state_machine::get_state_by_name (const char *name) const\n {\n   unsigned i;\n-  const char *iter_name;\n-  FOR_EACH_VEC_ELT (m_state_names, i, iter_name)\n-    if (!strcmp (name, iter_name))\n-      return i;\n+  state *s;\n+  FOR_EACH_VEC_ELT (m_states, i, s)\n+    if (!strcmp (name, s->get_name ()))\n+      return s;\n   /* Name not found.  */\n   gcc_unreachable ();\n }\n \n-/* Assert that S is a valid state for this state_machine.  */\n-\n-void\n-state_machine::validate (state_t s) const\n-{\n-  gcc_assert (s < m_state_names.length ());\n-}\n-\n /* Dump a multiline representation of this state machine to PP.  */\n \n void\n state_machine::dump_to_pp (pretty_printer *pp) const\n {\n   unsigned i;\n-  const char *name;\n-  FOR_EACH_VEC_ELT (m_state_names, i, name)\n-    pp_printf (pp, \"  state %i: %qs\\n\", i, name);\n+  state *s;\n+  FOR_EACH_VEC_ELT (m_states, i, s)\n+    {\n+      pp_printf (pp, \"  state %i: \", i);\n+      s->dump_to_pp (pp);\n+      pp_newline (pp);\n+    }\n }\n \n /* Create instances of the various state machines, each using LOGGER,"}, {"sha": "769d2a46767a151f77fead87441d794b64353eed", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fc42a8396072912e9d9d940fba25950b3fdfc5/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=10fc42a8396072912e9d9d940fba25950b3fdfc5", "patch": "@@ -32,17 +32,32 @@ class pending_diagnostic;\n extern bool any_pointer_p (tree var);\n \n /* An abstract base class for a state machine describing an API.\n-   A mapping from state IDs to names, and various virtual functions\n+   Manages a set of state objects, and has various virtual functions\n    for pattern-matching on statements.  */\n \n class state_machine : public log_user\n {\n public:\n-  typedef unsigned state_t;\n+  /* States are represented by immutable objects, owned by the state\n+     machine.  */\n+  class state\n+  {\n+  public:\n+    state (const char *name, unsigned id) : m_name (name), m_id (id) {}\n+    virtual ~state () {}\n+\n+    const char *get_name () const { return m_name; }\n+    virtual void dump_to_pp (pretty_printer *pp) const;\n+\n+    unsigned get_id () const { return m_id; }\n \n-  state_machine (const char *name, logger *logger)\n-  : log_user (logger), m_name (name) {}\n+  private:\n+    const char *m_name;\n+    unsigned m_id;\n+  };\n+  typedef const state_machine::state *state_t;\n \n+  state_machine (const char *name, logger *logger);\n   virtual ~state_machine () {}\n \n   /* Should states be inherited from a parent region to a child region,\n@@ -54,14 +69,12 @@ class state_machine : public log_user\n \n   virtual state_machine::state_t get_default_state (const svalue *) const\n   {\n-    return 0;\n+    return m_start;\n   }\n \n   const char *get_name () const { return m_name; }\n \n-  const char *get_state_name (state_t s) const;\n-\n-  state_t get_state_by_name (const char *name);\n+  state_t get_state_by_name (const char *name) const;\n \n   /* Return true if STMT is a function call recognized by this sm.  */\n   virtual bool on_stmt (sm_context *sm_ctxt,\n@@ -108,23 +121,26 @@ class state_machine : public log_user\n \n   void dump_to_pp (pretty_printer *pp) const;\n \n+  state_t get_start_state () const { return m_start; }\n+\n protected:\n   state_t add_state (const char *name);\n+  unsigned alloc_state_id () { return m_next_state_id++; }\n \n private:\n   DISABLE_COPY_AND_ASSIGN (state_machine);\n \n   const char *m_name;\n-  auto_vec<const char *> m_state_names;\n-};\n \n-/* Is STATE the start state?  (zero is hardcoded as the start state).  */\n+  /* States are owned by the state_machine.  */\n+  auto_delete_vec<state> m_states;\n \n-static inline bool\n-start_start_p (state_machine::state_t state)\n-{\n-  return state == 0;\n-}\n+  unsigned m_next_state_id;\n+\n+protected:\n+  /* Must be inited after m_next_state_id.  */\n+  state_t m_start;\n+};\n \n /* Abstract base class for state machines to pass to\n    sm_context::on_custom_transition for handling non-standard transitions"}]}