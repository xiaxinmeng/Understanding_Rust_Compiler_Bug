{"sha": "494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8", "node_id": "C_kwDOANBUbNoAKDQ5NGViZmE3YzlhYWNhZWI2ZWMxZmNjYzQ3YTBlNDlmMzFlYjJiYjg", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-12-13T11:37:40Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-12-13T11:38:26Z"}, "message": "Fortran: Handle compare in OpenMP atomic\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/103576\n\t* openmp.c (is_scalar_intrinsic_expr): Fix condition.\n\t(resolve_omp_atomic): Fix/update checks, accept compare.\n\t* trans-openmp.c (gfc_trans_omp_atomic): Handle compare.\n\nlibgomp/ChangeLog:\n\n\t* libgomp.texi (OpenMP 5.1): Set Fortran support for atomic to 'Y'.\n\t* testsuite/libgomp.fortran/atomic-19.f90: New test.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/gomp/atomic-25.f90: Remove sorry, fix + add checks.\n\t* gfortran.dg/gomp/atomic-26.f90: Likewise.\n\t* gfortran.dg/gomp/atomic-21.f90: New test.", "tree": {"sha": "5dc15dee821fcd7a99345a776365c4f89baa4c03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dc15dee821fcd7a99345a776365c4f89baa4c03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55823c5a0ba50022d7fcc95e74ec293143810ef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55823c5a0ba50022d7fcc95e74ec293143810ef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55823c5a0ba50022d7fcc95e74ec293143810ef6"}], "stats": {"total": 745, "additions": 650, "deletions": 95}, "files": [{"sha": "2036bc1349f5869f29e49d62afbeec45c506bc02", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 48, "deletions": 33, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8", "patch": "@@ -7552,10 +7552,10 @@ is_scalar_intrinsic_expr (gfc_expr *expr, bool must_be_var, bool conv_ok)\n     return false;\n   return (expr->rank == 0\n \t  && !gfc_is_coindexed (expr)\n-\t  && (expr->ts.type != BT_INTEGER\n-\t      || expr->ts.type != BT_REAL\n-\t      || expr->ts.type != BT_COMPLEX\n-\t      || expr->ts.type != BT_LOGICAL));\n+\t  && (expr->ts.type == BT_INTEGER\n+\t      || expr->ts.type == BT_REAL\n+\t      || expr->ts.type == BT_COMPLEX\n+\t      || expr->ts.type == BT_LOGICAL));\n }\n \n static void\n@@ -7574,12 +7574,9 @@ resolve_omp_atomic (gfc_code *code)\n   code = code->block->next;\n   /* resolve_blocks asserts this is initially EXEC_ASSIGN or EXEC_IF\n      If it changed to EXEC_NOP, assume an error has been emitted already.  */\n-  if (code->op == EXEC_NOP /* FIXME: || (code->next && code->next->op == EXEC_NOP)*/)\n+  if (code->op == EXEC_NOP)\n     return;\n \n-  if (code->op == EXEC_IF && code->block->op == EXEC_IF)\n-    comp_cond = code->block->expr1;\n-\n   if (atomic_code->ext.omp_clauses->compare\n       && atomic_code->ext.omp_clauses->capture)\n     {\n@@ -7597,18 +7594,28 @@ resolve_omp_atomic (gfc_code *code)\n \t  && next->block->op == EXEC_IF\n \t  && next->block->next->op == EXEC_ASSIGN)\n \t{\n+\t  comp_cond = next->block->expr1;\n \t  stmt = next->block->next;\n \t  if (stmt->next)\n \t    {\n \t      loc = &stmt->loc;\n \t      goto unexpected;\n \t    }\n \t}\n+      else if (capture_stmt)\n+\t{\n+\t  gfc_error (\"Expected IF at %L in atomic compare capture\",\n+\t\t     &next->loc);\n+\t  return;\n+\t}\n       if (stmt && !capture_stmt && next->block->block)\n \t{\n \t  if (next->block->block->expr1)\n-\t    gfc_error (\"Expected ELSE at %L in atomic compare capture\",\n-\t\t       &next->block->block->expr1->where);\n+\t    {\n+\t      gfc_error (\"Expected ELSE at %L in atomic compare capture\",\n+\t\t\t &next->block->block->expr1->where);\n+\t      return;\n+\t    }\n \t  if (!code->block->block->next\n \t      || code->block->block->next->op != EXEC_ASSIGN)\n \t    {\n@@ -7623,10 +7630,8 @@ resolve_omp_atomic (gfc_code *code)\n \t      goto unexpected;\n \t    }\n \t}\n-      if (stmt && !capture_stmt && code->op == EXEC_ASSIGN)\n-\t{\n-\t  capture_stmt = code;\n-\t}\n+      if (stmt && !capture_stmt && next->next->op == EXEC_ASSIGN)\n+\tcapture_stmt = next->next;\n       else if (!capture_stmt)\n \t{\n \t  loc = &code->loc;\n@@ -7641,6 +7646,7 @@ resolve_omp_atomic (gfc_code *code)\n \t  && code->block->op == EXEC_IF\n \t  && code->block->next->op == EXEC_ASSIGN)\n \t{\n+\t  comp_cond = code->block->expr1;\n \t  stmt = code->block->next;\n \t  if (stmt->next || code->block->block)\n \t    {\n@@ -7703,8 +7709,7 @@ resolve_omp_atomic (gfc_code *code)\n     {\n       /* x = ... */\n       stmt = code;\n-      if ((!atomic_code->ext.omp_clauses->compare && stmt->op != EXEC_ASSIGN)\n-\t  || (atomic_code->ext.omp_clauses->compare && stmt->op != EXEC_IF))\n+      if (!atomic_code->ext.omp_clauses->compare && stmt->op != EXEC_ASSIGN)\n \tgoto unexpected;\n       gcc_assert (!code->next);\n     }\n@@ -7720,7 +7725,7 @@ resolve_omp_atomic (gfc_code *code)\n \t\t     \"expression at %L\", &comp_cond->where);\n \t  return;\n \t}\n-      if (!is_scalar_intrinsic_expr (comp_cond->value.op.op1, true, false))\n+      if (!is_scalar_intrinsic_expr (comp_cond->value.op.op1, true, true))\n \t{\n \t  gfc_error (\"Expected scalar intrinsic variable at %L in atomic \"\n \t\t     \"comparison\", &comp_cond->value.op.op1->where);\n@@ -7781,14 +7786,6 @@ resolve_omp_atomic (gfc_code *code)\n       break;\n     }\n \n-  if (atomic_code->ext.omp_clauses->compare\n-      && !atomic_code->ext.omp_clauses->capture)\n-    {\n-      gfc_error (\"Sorry, COMPARE clause in ATOMIC at %L is not yet \"\n-\t\t \"supported\", &atomic_code->loc);\n-      return;\n-    }\n-\n   if (atomic_code->ext.omp_clauses->capture)\n     {\n       if (!is_scalar_intrinsic_expr (capture_stmt->expr1, true, false))\n@@ -7818,8 +7815,31 @@ resolve_omp_atomic (gfc_code *code)\n \t}\n     }\n \n-  if (atomic_code->ext.omp_clauses->capture\n-      && !expr_references_sym (stmt_expr2, var, NULL))\n+  if (atomic_code->ext.omp_clauses->compare)\n+    {\n+      gfc_expr *var_expr;\n+      if (comp_cond->value.op.op1->expr_type == EXPR_VARIABLE)\n+\tvar_expr = comp_cond->value.op.op1;\n+      else\n+\tvar_expr = comp_cond->value.op.op1->value.function.actual->expr;\n+      if (var_expr->symtree->n.sym != var)\n+\t{\n+\t  gfc_error (\"For !$OMP ATOMIC COMPARE, the first operand in comparison\"\n+\t\t     \" at %L must be the variable %qs that the update statement\"\n+\t\t     \" writes into at %L\", &var_expr->where, var->name,\n+\t\t     &stmt->expr1->where);\n+\t  return;\n+\t}\n+      if (stmt_expr2->rank != 0 || expr_references_sym (stmt_expr2, var, NULL))\n+\t{\n+\t  gfc_error (\"expr in !$OMP ATOMIC COMPARE assignment var = expr \"\n+\t\t     \"must be scalar and cannot reference var at %L\",\n+\t\t     &stmt_expr2->where);\n+\t  return;\n+\t}\n+    }\n+  else if (atomic_code->ext.omp_clauses->capture\n+\t   && !expr_references_sym (stmt_expr2, var, NULL))\n     atomic_code->ext.omp_clauses->atomic_op\n       = (gfc_omp_atomic_op) (atomic_code->ext.omp_clauses->atomic_op\n \t\t\t     | GFC_OMP_ATOMIC_SWAP);\n@@ -7829,8 +7849,7 @@ resolve_omp_atomic (gfc_code *code)\n       gfc_intrinsic_op op = stmt_expr2->value.op.op;\n       gfc_intrinsic_op alt_op = INTRINSIC_NONE;\n \n-      if (atomic_code->ext.omp_clauses->fail != OMP_MEMORDER_UNSET\n-\t  && !atomic_code->ext.omp_clauses->compare)\n+      if (atomic_code->ext.omp_clauses->fail != OMP_MEMORDER_UNSET)\n \tgfc_error (\"!$OMP ATOMIC UPDATE at %L with FAIL clause requiries either\"\n \t\t   \" the COMPARE clause or using the intrinsic MIN/MAX \"\n \t\t   \"procedure\", &atomic_code->loc);\n@@ -8042,10 +8061,6 @@ resolve_omp_atomic (gfc_code *code)\n   else\n     gfc_error (\"!$OMP ATOMIC assignment must have an operator or \"\n \t       \"intrinsic on right hand side at %L\", &stmt_expr2->where);\n-\n-  if (atomic_code->ext.omp_clauses->compare)\n-    gfc_error (\"Sorry, COMPARE clause in ATOMIC at %L is not yet \"\n-\t       \"supported\", &atomic_code->loc);\n   return;\n \n unexpected:"}, {"sha": "aa0b0a5af73b881fd57435133f281db611a55857", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 161, "deletions": 50, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8", "patch": "@@ -4488,13 +4488,13 @@ gfc_trans_omp_atomic (gfc_code *code)\n   gfc_se lse;\n   gfc_se rse;\n   gfc_se vse;\n-  gfc_expr *expr2, *e;\n+  gfc_expr *expr1, *expr2, *e, *capture_expr1 = NULL, *capture_expr2 = NULL;\n   gfc_symbol *var;\n   stmtblock_t block;\n-  tree lhsaddr, type, rhs, x;\n+  tree lhsaddr, type, rhs, x, compare = NULL_TREE, comp_tgt = NULL_TREE;\n   enum tree_code op = ERROR_MARK;\n   enum tree_code aop = OMP_ATOMIC;\n-  bool var_on_left = false;\n+  bool var_on_left = false, else_branch = false;\n   enum omp_memory_order mo, fail_mo;\n   switch (atomic_code->ext.omp_clauses->memorder)\n     {\n@@ -4514,18 +4514,86 @@ gfc_trans_omp_atomic (gfc_code *code)\n     case OMP_MEMORDER_SEQ_CST: fail_mo = OMP_FAIL_MEMORY_ORDER_SEQ_CST; break;\n     default: gcc_unreachable ();\n     }\n-   mo = (omp_memory_order) (mo | fail_mo);\n+  mo = (omp_memory_order) (mo | fail_mo);\n \n   code = code->block->next;\n-  gcc_assert (code->op == EXEC_ASSIGN);\n-  var = code->expr1->symtree->n.sym;\n+  if (atomic_code->ext.omp_clauses->compare)\n+    {\n+      gfc_expr *comp_expr;\n+      if (code->op == EXEC_IF)\n+\t{\n+\t  comp_expr = code->block->expr1;\n+\t  gcc_assert (code->block->next->op == EXEC_ASSIGN);\n+\t  expr1 = code->block->next->expr1;\n+\t  expr2 = code->block->next->expr2;\n+\t  if (code->block->block)\n+\t    {\n+\t      gcc_assert (atomic_code->ext.omp_clauses->capture\n+\t\t\t  && code->block->block->next->op == EXEC_ASSIGN);\n+\t      else_branch = true;\n+\t      aop = OMP_ATOMIC_CAPTURE_OLD;\n+\t      capture_expr1 = code->block->block->next->expr1;\n+\t      capture_expr2 = code->block->block->next->expr2;\n+\t    }\n+\t  else if (atomic_code->ext.omp_clauses->capture)\n+\t    {\n+\t      gcc_assert (code->next->op == EXEC_ASSIGN);\n+\t      aop = OMP_ATOMIC_CAPTURE_NEW;\n+\t      capture_expr1 = code->next->expr1;\n+\t      capture_expr2 = code->next->expr2;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (atomic_code->ext.omp_clauses->capture\n+\t\t      && code->op == EXEC_ASSIGN\n+\t\t      && code->next->op == EXEC_IF);\n+\t  aop = OMP_ATOMIC_CAPTURE_OLD;\n+\t  capture_expr1 = code->expr1;\n+\t  capture_expr2 = code->expr2;\n+\t  expr1 = code->next->block->next->expr1;\n+\t  expr2 = code->next->block->next->expr2;\n+\t  comp_expr = code->next->block->expr1;\n+\t}\n+      gfc_init_se (&lse, NULL);\n+      gfc_conv_expr (&lse, comp_expr->value.op.op2);\n+      gfc_add_block_to_block (&block, &lse.pre);\n+      compare = lse.expr;\n+      var = expr1->symtree->n.sym;\n+    }\n+  else\n+    {\n+      gcc_assert (code->op == EXEC_ASSIGN);\n+      expr1 = code->expr1;\n+      expr2 = code->expr2;\n+      if (atomic_code->ext.omp_clauses->capture\n+\t  && (expr2->expr_type == EXPR_VARIABLE\n+\t      || (expr2->expr_type == EXPR_FUNCTION\n+\t\t  && expr2->value.function.isym\n+\t\t  && expr2->value.function.isym->id == GFC_ISYM_CONVERSION\n+\t\t  && (expr2->value.function.actual->expr->expr_type\n+\t\t      == EXPR_VARIABLE))))\n+\t{\n+\t  capture_expr1 = expr1;\n+\t  capture_expr2 = expr2;\n+\t  expr1 = code->next->expr1;\n+\t  expr2 = code->next->expr2;\n+\t  aop = OMP_ATOMIC_CAPTURE_OLD;\n+\t}\n+      else if (atomic_code->ext.omp_clauses->capture)\n+\t{\n+\t  aop = OMP_ATOMIC_CAPTURE_NEW;\n+\t  capture_expr1 = code->next->expr1;\n+\t  capture_expr2 = code->next->expr2;\n+\t}\n+      var = expr1->symtree->n.sym;\n+    }\n \n   gfc_init_se (&lse, NULL);\n   gfc_init_se (&rse, NULL);\n   gfc_init_se (&vse, NULL);\n   gfc_start_block (&block);\n \n-  expr2 = code->expr2;\n   if (((atomic_code->ext.omp_clauses->atomic_op & GFC_OMP_ATOMIC_MASK)\n        != GFC_OMP_ATOMIC_WRITE)\n       && expr2->expr_type == EXPR_FUNCTION\n@@ -4536,7 +4604,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n   if ((atomic_code->ext.omp_clauses->atomic_op & GFC_OMP_ATOMIC_MASK)\n       == GFC_OMP_ATOMIC_READ)\n     {\n-      gfc_conv_expr (&vse, code->expr1);\n+      gfc_conv_expr (&vse, expr1);\n       gfc_add_block_to_block (&block, &vse.pre);\n \n       gfc_conv_expr (&lse, expr2);\n@@ -4554,36 +4622,32 @@ gfc_trans_omp_atomic (gfc_code *code)\n \n       return gfc_finish_block (&block);\n     }\n-  if (atomic_code->ext.omp_clauses->capture)\n+\n+  if (capture_expr2\n+      && capture_expr2->expr_type == EXPR_FUNCTION\n+      && capture_expr2->value.function.isym\n+      && capture_expr2->value.function.isym->id == GFC_ISYM_CONVERSION)\n+    capture_expr2 = capture_expr2->value.function.actual->expr;\n+  gcc_assert (!capture_expr2 || capture_expr2->expr_type == EXPR_VARIABLE);\n+\n+  if (aop == OMP_ATOMIC_CAPTURE_OLD)\n     {\n-      aop = OMP_ATOMIC_CAPTURE_NEW;\n-      if (expr2->expr_type == EXPR_VARIABLE)\n-\t{\n-\t  aop = OMP_ATOMIC_CAPTURE_OLD;\n-\t  gfc_conv_expr (&vse, code->expr1);\n-\t  gfc_add_block_to_block (&block, &vse.pre);\n-\n-\t  gfc_conv_expr (&lse, expr2);\n-\t  gfc_add_block_to_block (&block, &lse.pre);\n-\t  gfc_init_se (&lse, NULL);\n-\t  code = code->next;\n-\t  var = code->expr1->symtree->n.sym;\n-\t  expr2 = code->expr2;\n-\t  if (expr2->expr_type == EXPR_FUNCTION\n-\t      && expr2->value.function.isym\n-\t      && expr2->value.function.isym->id == GFC_ISYM_CONVERSION)\n-\t    expr2 = expr2->value.function.actual->expr;\n-\t}\n+      gfc_conv_expr (&vse, capture_expr1);\n+      gfc_add_block_to_block (&block, &vse.pre);\n+      gfc_conv_expr (&lse, capture_expr2);\n+      gfc_add_block_to_block (&block, &lse.pre);\n+      gfc_init_se (&lse, NULL);\n     }\n \n-  gfc_conv_expr (&lse, code->expr1);\n+  gfc_conv_expr (&lse, expr1);\n   gfc_add_block_to_block (&block, &lse.pre);\n   type = TREE_TYPE (lse.expr);\n   lhsaddr = gfc_build_addr_expr (NULL, lse.expr);\n \n   if (((atomic_code->ext.omp_clauses->atomic_op & GFC_OMP_ATOMIC_MASK)\n        == GFC_OMP_ATOMIC_WRITE)\n-      || (atomic_code->ext.omp_clauses->atomic_op & GFC_OMP_ATOMIC_SWAP))\n+      || (atomic_code->ext.omp_clauses->atomic_op & GFC_OMP_ATOMIC_SWAP)\n+      || compare)\n     {\n       gfc_conv_expr (&rse, expr2);\n       gfc_add_block_to_block (&block, &rse.pre);\n@@ -4675,6 +4739,10 @@ gfc_trans_omp_atomic (gfc_code *code)\n \t  gcc_unreachable ();\n \t}\n       e = expr2->value.function.actual->expr;\n+      if (e->expr_type == EXPR_FUNCTION\n+\t  && e->value.function.isym\n+\t  && e->value.function.isym->id == GFC_ISYM_CONVERSION)\n+\te = e->value.function.actual->expr;\n       gcc_assert (e->expr_type == EXPR_VARIABLE\n \t\t  && e->symtree != NULL\n \t\t  && e->symtree->n.sym == var);\n@@ -4717,11 +4785,27 @@ gfc_trans_omp_atomic (gfc_code *code)\n \t\t\tNULL_TREE, NULL_TREE);\n     }\n \n-  rhs = gfc_evaluate_now (rse.expr, &block);\n+  if (compare)\n+    {\n+      tree var = create_tmp_var_raw (TREE_TYPE (lhsaddr));\n+      DECL_CONTEXT (var) = current_function_decl;\n+      lhsaddr = build4 (TARGET_EXPR, TREE_TYPE (lhsaddr), var, lhsaddr, NULL,\n+\t\t\tNULL);\n+      lse.expr = build_fold_indirect_ref_loc (input_location, lhsaddr);\n+      compare = convert (TREE_TYPE (lse.expr), compare);\n+      compare = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t lse.expr, compare);\n+    }\n+\n+  if (expr2->expr_type == EXPR_VARIABLE || compare)\n+    rhs = rse.expr;\n+  else\n+    rhs = gfc_evaluate_now (rse.expr, &block);\n \n   if (((atomic_code->ext.omp_clauses->atomic_op & GFC_OMP_ATOMIC_MASK)\n        == GFC_OMP_ATOMIC_WRITE)\n-      || (atomic_code->ext.omp_clauses->atomic_op & GFC_OMP_ATOMIC_SWAP))\n+      || (atomic_code->ext.omp_clauses->atomic_op & GFC_OMP_ATOMIC_SWAP)\n+      || compare)\n     x = rhs;\n   else\n     {\n@@ -4741,6 +4825,30 @@ gfc_trans_omp_atomic (gfc_code *code)\n   gfc_add_block_to_block (&block, &lse.pre);\n   gfc_add_block_to_block (&block, &rse.pre);\n \n+  if (aop == OMP_ATOMIC_CAPTURE_NEW)\n+    {\n+      gfc_conv_expr (&vse, capture_expr1);\n+      gfc_add_block_to_block (&block, &vse.pre);\n+      gfc_add_block_to_block (&block, &lse.pre);\n+    }\n+\n+  if (compare && else_branch)\n+    {\n+      tree var2 = create_tmp_var_raw (boolean_type_node);\n+      DECL_CONTEXT (var2) = current_function_decl;\n+      comp_tgt = build4 (TARGET_EXPR, boolean_type_node, var2,\n+\t\t\t boolean_false_node, NULL, NULL);\n+      compare = fold_build2_loc (input_location, MODIFY_EXPR, TREE_TYPE (var2),\n+\t\t\t\t var2, compare);\n+      TREE_OPERAND (compare, 0) = comp_tgt;\n+      compare = omit_one_operand_loc (input_location, boolean_type_node,\n+\t\t\t\t      compare, comp_tgt);\n+    }\n+\n+  if (compare)\n+    x = build3_loc (input_location, COND_EXPR, type, compare,\n+\t\t    convert (type, x), lse.expr);\n+\n   if (aop == OMP_ATOMIC)\n     {\n       x = build2_v (OMP_ATOMIC, lhsaddr, convert (type, x));\n@@ -4750,28 +4858,31 @@ gfc_trans_omp_atomic (gfc_code *code)\n     }\n   else\n     {\n-      if (aop == OMP_ATOMIC_CAPTURE_NEW)\n-\t{\n-\t  code = code->next;\n-\t  expr2 = code->expr2;\n-\t  if (expr2->expr_type == EXPR_FUNCTION\n-\t      && expr2->value.function.isym\n-\t      && expr2->value.function.isym->id == GFC_ISYM_CONVERSION)\n-\t    expr2 = expr2->value.function.actual->expr;\n-\n-\t  gcc_assert (expr2->expr_type == EXPR_VARIABLE);\n-\t  gfc_conv_expr (&vse, code->expr1);\n-\t  gfc_add_block_to_block (&block, &vse.pre);\n-\n-\t  gfc_init_se (&lse, NULL);\n-\t  gfc_conv_expr (&lse, expr2);\n-\t  gfc_add_block_to_block (&block, &lse.pre);\n-\t}\n       x = build2 (aop, type, lhsaddr, convert (type, x));\n       OMP_ATOMIC_MEMORY_ORDER (x) = mo;\n       OMP_ATOMIC_WEAK (x) = atomic_code->ext.omp_clauses->weak;\n-      x = convert (TREE_TYPE (vse.expr), x);\n-      gfc_add_modify (&block, vse.expr, x);\n+      if (compare && else_branch)\n+\t{\n+\t  tree vtmp = create_tmp_var_raw (TREE_TYPE (x));\n+\t  DECL_CONTEXT (vtmp) = current_function_decl;\n+\t  x = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t       TREE_TYPE (vtmp), vtmp, x);\n+\t  vtmp = build4 (TARGET_EXPR, TREE_TYPE (vtmp), vtmp,\n+\t\t\t build_zero_cst (TREE_TYPE (vtmp)), NULL, NULL);\n+\t  TREE_OPERAND (x, 0) = vtmp;\n+\t  tree x2 = convert (TREE_TYPE (vse.expr), vtmp);\n+\t  x2 = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t       TREE_TYPE (vse.expr), vse.expr, x2);\n+\t  x2 = build3_loc (input_location, COND_EXPR, void_type_node, comp_tgt,\n+\t\t\t   void_node, x2);\n+\t  x = omit_one_operand_loc (input_location, TREE_TYPE (x2), x2, x);\n+\t  gfc_add_expr_to_block (&block, x);\n+\t}\n+      else\n+\t{\n+\t  x = convert (TREE_TYPE (vse.expr), x);\n+\t  gfc_add_modify (&block, vse.expr, x);\n+\t}\n     }\n \n   return gfc_finish_block (&block);"}, {"sha": "febcdbbacfb333ce5f6799442741e82c60daa5fe", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-21.f90", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-21.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-21.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-21.f90?ref=494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8", "patch": "@@ -0,0 +1,93 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+\n+module mod\n+implicit none\n+\n+integer i, j, k, l, m, n\n+contains\n+\n+subroutine foo ()\n+  !$omp atomic release\n+  i = i + 1\n+end\n+end module\n+\n+module m2\n+use mod\n+implicit none\n+!$omp requires atomic_default_mem_order (acq_rel)\n+\n+contains\n+subroutine bar ()\n+  integer v\n+  !$omp atomic\n+  j = j + 1\n+  !$omp atomic update\n+  k = k + 1\n+  !$omp atomic read\n+  v = l\n+  !$omp atomic write\n+  m = v\n+  !$omp atomic capture\n+  n = n + 1; v = n\n+end\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp atomic release\" 5 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"v = #pragma omp atomic capture acq_rel\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"v = #pragma omp atomic read acquire\" 1 \"original\" } }\n+\n+subroutine foobar()\n+  integer :: aa, bb, cc, dd, ee, ff, gg, hh, ii, jj, kk, nn, oo, pp, qq\n+\n+  !$omp atomic compare\n+    if (ii == jj) ii = kk\n+\n+!  #pragma omp atomic release\n+!    TARGET_EXPR <D.4241, &ii> = *TARGET_EXPR <D.4241, &ii> == jj \\\\? kk : *TARGET_EXPR <D.4241, &ii>;\n+!\n+! { dg-final { scan-tree-dump-times \"TARGET_EXPR <D.\\[0-9\\]+, &ii> = \\\\*TARGET_EXPR <D.\\[0-9\\]+, &ii> == jj \\\\? kk : \\\\*TARGET_EXPR <D.\\[0-9\\]+, &ii>;\" 1 \"original\" } }\n+\n+  !$omp atomic compare, capture\n+    if (nn == oo) then\n+      nn = pp\n+    else\n+      qq = nn\n+    endif\n+\n+!  TARGET_EXPR <D.4244, 0> = #pragma omp atomic capture acq_rel\n+!    TARGET_EXPR <D.4242, &nn> = NON_LVALUE_EXPR <TARGET_EXPR <D.4243, 0> = *TARGET_EXPR <D.4242, &nn> == oo> ? pp : *TARGET_EXPR <D.4242, &nn>;, if (TARGET_EXPR <D.4243, 0>)\n+!    {\n+!      <<< Unknown tree: void_cst >>>\n+!    }\n+!  else\n+!    {\n+!      qq = TARGET_EXPR <D.4244, 0>;\n+!    };\n+!\n+! { dg-final { scan-tree-dump-times \"TARGET_EXPR <D.\\[0-9\\]+, 0> = #pragma omp atomic capture acq_rel\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"TARGET_EXPR <D.\\[0-9\\]+, &nn> = NON_LVALUE_EXPR <TARGET_EXPR <D.\\[0-9\\]+, 0> = \\\\*TARGET_EXPR <D.\\[0-9\\]+, &nn> == oo> \\\\? pp : \\\\*TARGET_EXPR <D.\\[0-9\\]+, &nn>;, if \\\\(TARGET_EXPR <D.\\[0-9\\]+, 0>\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"<<< Unknown tree: void_cst >>>\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"qq = TARGET_EXPR <D.\\[0-9\\]+, 0>;\" 1 \"original\" } }\n+\n+  !$omp atomic capture compare\n+    aa = bb\n+    if (bb == cc) bb = dd\n+\n+!  aa = #pragma omp atomic capture acq_rel\n+!    TARGET_EXPR <D.4245, &bb> = *TARGET_EXPR <D.4245, &bb> == cc ? dd : *TARGET_EXPR <D.4245, &bb>;\n+!\n+! { dg-final { scan-tree-dump-times \"aa = #pragma omp atomic capture acq_rel\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"TARGET_EXPR <D.\\[0-9\\]+, &bb> = \\\\*TARGET_EXPR <D.\\[0-9\\]+, &bb> == cc \\\\? dd : \\\\*TARGET_EXPR <D.\\[0-9\\]+, &bb>;\" 1 \"original\" } }\n+\n+  !$omp atomic capture compare\n+    if (ee == ff) ee = gg\n+    hh = ee\n+\n+!  hh = #pragma omp atomic capture acq_rel\n+!    TARGET_EXPR <D.4246, &ee> = *TARGET_EXPR <D.4246, &ee> == ff ? gg : *TARGET_EXPR <D.4246, &ee>;\n+!\n+! { dg-final { scan-tree-dump-times \"hh = #pragma omp atomic capture acq_rel\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"TARGET_EXPR <D.\\[0-9\\]+, &ee> = \\\\*TARGET_EXPR <D.\\[0-9\\]+, &ee> == ff \\\\? gg : \\\\*TARGET_EXPR <D.\\[0-9\\]+, &ee>;\" 1 \"original\" } }\n+end\n+end module"}, {"sha": "a501c1f7b04cd2413dd0334a0b64bd2d7e03db2d", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-25.f90", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-25.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-25.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-25.f90?ref=494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8", "patch": "@@ -19,31 +19,31 @@ subroutine foo (y, e, f)\n   d = max (e, d)\n   !$omp atomic fail(SEQ_CST)\n   d = min (d, f)\n-  !$omp atomic seq_cst compare fail(relaxed)  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n+  !$omp atomic seq_cst compare fail(relaxed)\n   if (x == 7) x = 24\n-  !$omp atomic compare  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n+  !$omp atomic compare\n   if (x == 7) x = 24\n-  !$omp atomic compare  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n+  !$omp atomic compare\n   if (x == 123) x = 256\n-  !$omp atomic compare  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n-  if (ld == f)  ld = f + 5.0_mrk\n-  !$omp atomic compare  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n+  !$omp atomic compare\n+  if (ld == f)  ld = 5.0_mrk\n+  !$omp atomic compare\n   if (x == 9) then\n     x = 5\n   endif\n-  !$omp atomic compare update capture seq_cst fail(acquire)  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n+  !$omp atomic compare update capture seq_cst fail(acquire)\n   if (x == 42) then\n     x = f\n   else\n     v = x\n   endif\n-  !$omp atomic capture compare weak  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n+  !$omp atomic capture compare weak\n   if (x == 42) then\n     x = f\n   else\n     v = x\n   endif\n-  !$omp atomic capture compare fail(seq_cst)  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n+  !$omp atomic capture compare fail(seq_cst)\n   if (d == 8.0) then\n     d = 16.0\n   else"}, {"sha": "6448bd9b8bb36999c3464d35c015d41b97849d95", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-26.f90", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-26.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-26.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-26.f90?ref=494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8", "patch": "@@ -59,7 +59,7 @@ real function bar (y, e, f)\n   !$omp atomic compare fail\t! { dg-error \"Expected '\\\\\\(' after 'fail'\" }\n   if (x == y) x = d\n   !$omp atomic compare fail(\t! { dg-error \"Expected SEQ_CST, ACQUIRE or RELAXED\" }\n-  if (x == y) x = d             ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" \"\" { target *-*-* } .-1 }\n+  if (x == y) x = d\n   !$omp atomic compare fail()\t! { dg-error \"Expected SEQ_CST, ACQUIRE or RELAXED\" }\n   if (x == y) x = d\n   !$omp atomic compare fail(foobar)\t! { dg-error \"Expected SEQ_CST, ACQUIRE or RELAXED\" }\n@@ -72,4 +72,28 @@ real function bar (y, e, f)\n   if (x == y) x = d\n   bar = v\n end\n+\n+subroutine foobar\n+  implicit none\n+  integer :: i, j, k\n+\n+  !$omp atomic compare write  ! { dg-error \"COMPARE clause is incompatible with READ or WRITE\" }\n+    if (i == 1) i = 5\n+\n+  !$omp atomic compare\n+    if (k == 5) i = 7 ! { dg-error \"For !.OMP ATOMIC COMPARE, the first operand in comparison at .1. must be the variable 'i' that the update statement writes into at .2.\" }\n+\n+  !$omp atomic compare\n+    if (j == i) i = 8 ! { dg-error \"For !.OMP ATOMIC COMPARE, the first operand in comparison at .1. must be the variable 'i' that the update statement writes into at .2.\" }\n+\n+  !$omp atomic compare\n+    if (i == 5) i = 8\n+\n+  !$omp atomic compare\n+    if (5 == i) i = 8 ! { dg-error \"Expected scalar intrinsic variable at .1. in atomic comparison\" }\n+\n+  !$omp atomic compare\n+    if (i == 5) i = i + 8 ! { dg-error \"20: expr in !.OMP ATOMIC COMPARE assignment var = expr must be scalar and cannot reference var\" }\n+\n+end subroutine\n end module"}, {"sha": "33b9e4cab55bf982fbb6d8de9c8fd79291416aad", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8", "patch": "@@ -301,8 +301,7 @@ The OpenMP 4.5 specification is fully supported.\n @item @code{interop} directive @tab N @tab\n @item @code{omp_interop_t} object support in runtime routines @tab N @tab\n @item @code{nowait} clause in @code{taskwait} directive @tab N @tab\n-@item Extensions to the @code{atomic} directive @tab P\n-      @tab @code{compare} unsupported in Fortran\n+@item Extensions to the @code{atomic} directive @tab Y @tab\n @item @code{seq_cst} clause on a @code{flush} construct @tab Y @tab\n @item @code{inoutset} argument to the @code{depend} clause @tab N @tab\n @item @code{private} and @code{firstprivate} argument to @code{default}"}, {"sha": "e5f675f87d9e2ba66091d5b6d1278b6ee8581232", "filename": "libgomp/testsuite/libgomp.fortran/atomic-19.f90", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fatomic-19.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fatomic-19.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fatomic-19.f90?ref=494ebfa7c9aacaeb6ec1fccc47a0e49f31eb2bb8", "patch": "@@ -0,0 +1,313 @@\n+! { dg-do run }\n+\n+module m\n+  integer :: x = 6\n+  integer :: w, y\n+  target :: y\n+\n+contains\n+  function foo ()\n+    integer, pointer :: foo\n+    if (w /= 0) &\n+      error stop\n+    foo => y\n+  end\n+end module \n+\n+program main\n+  use m\n+  implicit none\n+  integer :: v, r\n+  !$omp atomic\n+  x = min (8, x)\n+  !$omp atomic read\n+  v = x\n+  if (v /= 6) &\n+    error stop\n+\n+  !$omp atomic compare\n+  if (x == 6) x = 7\n+  !$omp atomic read\n+  v = x\n+  if (v /= 7) &\n+    error stop\n+\n+  !$omp atomic\n+  x = min (x, 4)\n+  !$omp atomic read\n+  v = x\n+  if (v /= 4) &\n+    error stop\n+  !$omp atomic capture\n+  x = max(x, 8)\n+  v = x\n+  if (v /= 8) &\n+    error stop\n+\n+  !$omp atomic read\n+  v = x\n+  if (x /= 8) &\n+    error stop\n+  !$omp atomic capture\n+  v = x\n+  x = max (12, x)\n+  if (v /= 8) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 12) &\n+    error stop\n+  !$omp atomic capture\n+    v = x\n+    x = max(4, x)\n+  if (v /= 12) &\n+    error stop\n+  !$omp atomic read\n+    v = x\n+  if (v /= 12) &\n+    error stop\n+  !$omp atomic capture compare\n+  if (x == 4) then\n+    x = 4\n+  else\n+    v = x\n+  endif\n+  if (v /= 12) &\n+    error stop\n+  !$omp atomic write\n+  x = -32\n+  !$omp atomic capture seq_cst fail(relaxed)\n+    x = max(x, 12_8)\n+    v = x\n+  if (v /= 12) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 12) &\n+    error stop\n+  !$omp atomic compare\n+  if (x == 12) x = 16\n+  !$omp atomic read\n+  v = x\n+  if (v /= 16) &\n+    error stop\n+  r = 57\n+  !$omp atomic compare capture\n+  if (x == 16) then\n+    x = r + 7\n+  else\n+    v = x\n+  endif\n+  if (v /= 16) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 64) &\n+    error stop\n+  !$omp atomic compare capture\n+  v = x\n+  if (x == 64) x = 16\n+  if (v /= 64) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 16) &\n+    error stop\n+  \n+  !$omp atomic capture, update, compare seq_cst fail(acquire)\n+    v = x\n+    if (x == 73_8 - r) x = 12_2\n+  if (v /= 16) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 12) &\n+    error stop\n+  !$omp atomic update, compare, capture\n+    if (x == 69_2 - r) x = 6_8\n+    v = x\n+  if (v /= 6) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 6) &\n+    error stop\n+  !$omp atomic\n+    x = min(x, 8)\n+  !$omp atomic read\n+  v = x\n+  if (v /= 6) &\n+    error stop\n+  !$omp atomic compare\n+  if (x == 6) x = 8\n+  !$omp atomic read\n+  v = x\n+  if (v /= 8) &\n+    error stop\n+  !$omp atomic\n+  x = min(4,x)\n+  !$omp atomic read\n+  v = x\n+  if (v /= 4) &\n+    error stop\n+  !$omp atomic capture\n+  x = max(8_2, x)\n+  v = x\n+  if (v /= 8) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 8) &\n+    error stop\n+  !$omp atomic capture\n+  v = x\n+  x = max(12_1, x)\n+  if (v /= 8) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 12) &\n+    error stop\n+  !$omp atomic capture\n+  v = x\n+  x = max(x, 4_1)\n+  if (v /= 12) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 12) &\n+    error stop\n+  !$omp atomic write\n+  x = -32\n+  !$omp atomic capture ,seq_cst fail ( relaxed )\n+  x = max(10_1 + 2_8, x)\n+  v = x\n+  !$omp end atomic\n+  if (v /= 12) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 12) &\n+    error stop\n+  !$omp atomic compare\n+  if (x == 12) x = 16\n+  !$omp atomic read\n+  v = x\n+  if (v /= 16) &\n+    error stop\n+  r = 57\n+  !$omp atomic compare capture\n+  if (x == 15) x = r + 7; v = x\n+  if (v /= 16) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 16) &\n+    error stop\n+  !$omp atomic capture, update, compare seq_cst fail(acquire)\n+  v = x; if (x == 73_8 - r) x = 12_8\n+  !$omp end atomic\n+  if (v /= 16) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 12) &\n+    error stop\n+  !$omp atomic update, compare, capture\n+  if (x == 69_2 - r) x = 6_1; v = x\n+  if (v /= 6) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 6) &\n+    error stop\n+  v = 24\n+  !$omp atomic compare capture\n+  if (x == 12) then; x = 16; else; v = x; endif\n+  if (v /= 6) &\n+    error stop\n+  v = 32\n+  !$omp atomic read\n+  v = x\n+  if (v /= 6) &\n+    error stop\n+  v = 147\n+  !$omp atomic capture compare\n+  if (x == 6) then; x = 57; else; v = x; endif\n+  if (v /= 147) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 57) &\n+    error stop\n+  !$omp atomic update, compare, weak, seq_cst, fail (relaxed)\n+  if (x == 137) x = 174\n+  !$omp atomic read\n+  v = x\n+  if (v /= 57) &\n+    error stop\n+  !$omp atomic compare fail (relaxed)\n+  if (x == 57_2) x = 6_8\n+  !$omp atomic read\n+  v = x\n+  if (v /= 6) &\n+    error stop\n+  v = -5\n+  !$omp atomic capture compare\n+  if (x == 17) then; x = 25; else; v = x; endif\n+  if (v /= 6) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 6) &\n+    error stop\n+  v = 15\n+  !$omp atomic capture compare\n+  if (x == 6) then; x = 23; else; v = x; endif\n+  if (v /= 15) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 23) &\n+    error stop\n+  w = 1\n+  !$omp atomic compare capture\n+  ! if (x == 23) then; x = 57; else; foo () = x; endif  ! OpenMP 6\n+  if (x == 23) then; x = 57; else; y = x; endif\n+  !$omp atomic read\n+  v = x\n+  if (v /= 57) &\n+    error stop\n+  !$omp atomic capture update compare\n+  ! if (x == 57) then; x = 23; else; foo () = x; endif  ! OpenMP 6\n+  if (x == 57) then; x = 23; else; y = x; endif\n+  !$omp atomic read\n+  v = x\n+  if (v /= 23) &\n+    error stop\n+  w = 0\n+  !$omp atomic compare capture\n+  ! if (x == 24) then; x = 57; else; foo () = x; endif  ! OpenMP 6\n+  if (x == 24) then; x = 57; else; y = x; endif\n+  if (y /= 23) &\n+    error stop\n+  !$omp atomic read\n+  v = x\n+  if (v /= 23) &\n+    error stop\n+  y = -5\n+  !$omp atomic capture update compare\n+    if (x == 57) then\n+      x = 27\n+    else\n+      ! foo () = x  ! OpenMP 6\n+      y = x\n+    end if\n+  !$omp end atomic\n+  if (y /= 23) &\n+    error stop \n+  !$omp atomic read\n+  v = x\n+  if (v /= 23) &\n+    error stop\n+end"}]}