{"sha": "31af83671c566af8a0c434d3bb1aabb58d7d7ac3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFhZjgzNjcxYzU2NmFmOGEwYzQzNGQzYmIxYWFiYjU4ZDdkN2FjMw==", "commit": {"author": {"name": "Hariharan Sandanagobalane", "email": "hariharan@picochip.com", "date": "2010-08-04T09:02:48Z"}, "committer": {"name": "Hariharan Sandanagobalane", "email": "hariharans@gcc.gnu.org", "date": "2010-08-04T09:02:48Z"}, "message": "picochip.c (TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE): Define.\n\n        * config/picochip/picochip.c (TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE):\n          Define.\n          picochip_expand_movmemhi : Expand movmem pattern.\n        * config/picochip/picochip-protos.h (picochip_expand_movmemhi) :\n          Declare.\n        * config/picochip/picochip.md (movmemhi) : New pattern.\n\nFrom-SVN: r162858", "tree": {"sha": "683da181aabc5eab7c3b24521abba6d35cc859d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/683da181aabc5eab7c3b24521abba6d35cc859d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31af83671c566af8a0c434d3bb1aabb58d7d7ac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31af83671c566af8a0c434d3bb1aabb58d7d7ac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31af83671c566af8a0c434d3bb1aabb58d7d7ac3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31af83671c566af8a0c434d3bb1aabb58d7d7ac3/comments", "author": null, "committer": null, "parents": [{"sha": "a19d2b955ab5283ce3f92462d517fa0a123bdb98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a19d2b955ab5283ce3f92462d517fa0a123bdb98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a19d2b955ab5283ce3f92462d517fa0a123bdb98"}], "stats": {"total": 181, "additions": 141, "deletions": 40}, "files": [{"sha": "7b338e42ac5d75f7b4adc1d835354607f407fa13", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31af83671c566af8a0c434d3bb1aabb58d7d7ac3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31af83671c566af8a0c434d3bb1aabb58d7d7ac3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31af83671c566af8a0c434d3bb1aabb58d7d7ac3", "patch": "@@ -1,3 +1,12 @@\n+2010-08-04  Hariharan Sandanagobalane <hariharan@picochip.com>\n+\n+\t* config/picochip/picochip.c (TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE):\n+\tDefine.\n+\tpicochip_expand_movmemhi : Expand movmem pattern.\n+\t* config/picochip/picochip-protos.h (picochip_expand_movmemhi) :\n+\tDeclare.\n+\t* config/picochip/picochip.md (movmemhi) : New pattern.\n+\n 2010-08-03  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/unix.h (GLOBAL_ASM_OPS): Add tabs around .globl."}, {"sha": "268b80595e0d22e3135f65c7f2e3f4de07508d20", "filename": "gcc/config/picochip/picochip-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31af83671c566af8a0c434d3bb1aabb58d7d7ac3/gcc%2Fconfig%2Fpicochip%2Fpicochip-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31af83671c566af8a0c434d3bb1aabb58d7d7ac3/gcc%2Fconfig%2Fpicochip%2Fpicochip-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip-protos.h?ref=31af83671c566af8a0c434d3bb1aabb58d7d7ac3", "patch": "@@ -46,6 +46,8 @@ extern const char *picochip_output_get_array (int alternative,\n extern const char *picochip_output_testport_array (int alternative,\n \t\t\t\t\t\t   rtx operands[]);\n \n+extern int picochip_expand_movmemhi (rtx *operands);\n+\n extern rtx gen_SImode_mem(rtx opnd1,rtx opnd2);\n extern bool ok_to_peephole_stw(rtx opnd0, rtx opnd1, rtx opnd2, rtx opnd3);\n extern bool ok_to_peephole_ldw(rtx opnd0, rtx opnd1, rtx opnd2, rtx opnd3);"}, {"sha": "30c49224a67530d80477aaefb24b3f06ffbec3b7", "filename": "gcc/config/picochip/picochip.c", "status": "modified", "additions": 96, "deletions": 20, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31af83671c566af8a0c434d3bb1aabb58d7d7ac3/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31af83671c566af8a0c434d3bb1aabb58d7d7ac3/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.c?ref=31af83671c566af8a0c434d3bb1aabb58d7d7ac3", "patch": "@@ -301,6 +301,9 @@ static char picochip_get_vliw_alu_id (void);\n #undef TARGET_STATIC_CHAIN\n #define TARGET_STATIC_CHAIN picochip_static_chain\n \n+#undef TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE\n+#define TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE picochip_override_options\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n \n@@ -359,15 +362,13 @@ picochip_override_options (void)\n   flag_schedule_insns_after_reload = 0;\n   if (picochip_flag_schedule_insns2)\n     {\n-\n       if (optimize_size)\n \tpicochip_schedule_type = DFA_TYPE_SPACE;\n       else\n \t{\n \t  picochip_schedule_type = DFA_TYPE_SPEED;\n \t  flag_delayed_branch = 0;\n \t}\n-\n     }\n   else\n     picochip_schedule_type = DFA_TYPE_NONE;\n@@ -449,6 +450,73 @@ picochip_init_libfuncs (void)\n   set_optab_libfunc (add_optab, DImode, \"_adddi3\");\n   set_optab_libfunc (sub_optab, DImode, \"_subdi3\");\n }\n+\n+/* Memcpy function */\n+int\n+picochip_expand_movmemhi (rtx *operands)\n+{\n+  rtx src_addr_reg, dst_addr_reg, count_reg, src_mem, dst_mem, tmp_reg;\n+  rtx start_label;\n+  int align, size;\n+  src_addr_reg = gen_reg_rtx(HImode);\n+  dst_addr_reg = gen_reg_rtx(HImode);\n+  count_reg = gen_reg_rtx(HImode);\n+  emit_insn (gen_movhi (count_reg, operands[2]));\n+  emit_insn (gen_movqi (src_addr_reg, XEXP(operands[1], 0)));\n+  emit_insn (gen_movqi (dst_addr_reg, XEXP(operands[0], 0)));\n+  gcc_assert (GET_CODE(count_reg) == REG);\n+  start_label = gen_label_rtx ();\n+  emit_label (start_label);\n+\n+  /* We can specialise the code for different alignments */\n+  align = INTVAL(operands[3]);\n+  size = INTVAL(operands[2]);\n+  gcc_assert(align >= 0 && size >= 0);\n+  if (size != 0)\n+    {\n+      if (size % 4 == 0 && align % 4 == 0)\n+        {\n+          src_mem = gen_rtx_MEM(SImode, src_addr_reg);\n+          dst_mem = gen_rtx_MEM(SImode, dst_addr_reg);\n+          tmp_reg = gen_reg_rtx(SImode);\n+          emit_insn (gen_movsi (tmp_reg, src_mem));\n+          emit_insn (gen_movsi (dst_mem, tmp_reg));\n+          emit_insn (gen_addhi3 (dst_addr_reg, dst_addr_reg, GEN_INT(4)));\n+          emit_insn (gen_addhi3 (src_addr_reg, src_addr_reg, GEN_INT(4)));\n+          emit_insn (gen_addhi3 (count_reg, count_reg, GEN_INT(-4)));\n+          /* The sub instruction above generates cc, but we cannot just emit the branch.*/\n+          emit_cmp_and_jump_insns (count_reg, const0_rtx, GT, 0, HImode, 0, start_label);\n+        }\n+      else if (size % 2 == 0 && align % 2 == 0)\n+        {\n+          src_mem = gen_rtx_MEM(HImode, src_addr_reg);\n+          dst_mem = gen_rtx_MEM(HImode, dst_addr_reg);\n+          tmp_reg = gen_reg_rtx(HImode);\n+          emit_insn (gen_movhi (tmp_reg, src_mem));\n+          emit_insn (gen_movhi (dst_mem, tmp_reg));\n+          emit_insn (gen_addhi3 (dst_addr_reg, dst_addr_reg, const2_rtx));\n+          emit_insn (gen_addhi3 (src_addr_reg, src_addr_reg, const2_rtx));\n+          emit_insn (gen_addhi3 (count_reg, count_reg, GEN_INT(-2)));\n+          /* The sub instruction above generates cc, but we cannot just emit the branch.*/\n+          emit_cmp_and_jump_insns (count_reg, const0_rtx, GT, 0, HImode, 0, start_label);\n+        }\n+      else\n+        {\n+          src_mem = gen_rtx_MEM(QImode, src_addr_reg);\n+          dst_mem = gen_rtx_MEM(QImode, dst_addr_reg);\n+          tmp_reg = gen_reg_rtx(QImode);\n+          emit_insn (gen_movqi (tmp_reg, src_mem));\n+          emit_insn (gen_movqi (dst_mem, tmp_reg));\n+          emit_insn (gen_addhi3 (dst_addr_reg, dst_addr_reg, const1_rtx));\n+          emit_insn (gen_addhi3 (src_addr_reg, src_addr_reg, const1_rtx));\n+          emit_insn (gen_addhi3 (count_reg, count_reg, GEN_INT(-1)));\n+          /* The sub instruction above generates cc, but we cannot just emit the branch.*/\n+          emit_cmp_and_jump_insns (count_reg, const0_rtx, GT, 0, HImode, 0, start_label);\n+        }\n+    }\n+  return 1;\n+}\n+\n \f\n /* Return the register class for letter C.  */\n enum reg_class\n@@ -523,9 +591,9 @@ rtx\n picochip_return_addr_rtx(int count, rtx frameaddr ATTRIBUTE_UNUSED)\n {\n    if (count==0)\n-      return gen_rtx_REG (Pmode, LINK_REGNUM);\n+     return gen_rtx_REG (Pmode, LINK_REGNUM);\n    else\n-      return NULL_RTX;\n+     return NULL_RTX;\n }\n \n \n@@ -1150,11 +1218,11 @@ picochip_regno_nregs (int regno ATTRIBUTE_UNUSED, int mode)\n }\n \n int\n-picochip_class_max_nregs (int class, int mode)\n+picochip_class_max_nregs (int reg_class, int mode)\n {\n   int size = ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n \n-  if (class == ACC_REGS)\n+  if (reg_class == ACC_REGS)\n     return 1;\n \n   if (GET_MODE_CLASS (mode) == MODE_CC)\n@@ -1339,11 +1407,12 @@ rtx\n picochip_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n                              enum machine_mode mode)\n {\n+  unsigned mask_val;\n+\n   if (!optimize)\n     return x;\n \n-  unsigned mask_val;\n-  // Depending on mode, the offsets allowed are either 16/32/64.\n+  /* Depending on mode, the offsets allowed are either 16/32/64.*/\n   switch (mode)\n     {\n       case QImode:\n@@ -1363,12 +1432,13 @@ picochip_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       && GET_CODE (XEXP (x, 0)) == REG\n       && GET_CODE (XEXP (x, 1)) == CONST_INT)\n     {\n-      int offset = INTVAL (XEXP (x, 1));\n+      int high_val, low_val, offset;\n+      offset = INTVAL (XEXP (x, 1));\n       // Ignore cases with negative offsets.\n       if (offset < 0)\n         return x;\n-      int high_val = offset & mask_val;\n-      int low_val = offset - high_val;\n+      high_val = offset & mask_val;\n+      low_val = offset - high_val;\n       if (high_val != 0)\n         {\n           rtx temp_reg = force_reg (Pmode, gen_rtx_PLUS (Pmode, XEXP (x, 0), GEN_INT(high_val)));\n@@ -1398,6 +1468,8 @@ picochip_legitimize_reload_address (rtx *x,\n                                     int opnum, int type,\n                                     int ind_levels ATTRIBUTE_UNUSED)\n {\n+  unsigned mask_val;\n+\n   if (picochip_symbol_offset(*x))\n     {\n       *x = gen_rtx_CONST(mode, *x);\n@@ -1419,7 +1491,6 @@ picochip_legitimize_reload_address (rtx *x,\n       return 1;\n     }\n \n-  unsigned mask_val;\n   // Depending on mode, the offsets allowed are either 16/32/64.\n   switch (mode)\n     {\n@@ -1440,12 +1511,13 @@ picochip_legitimize_reload_address (rtx *x,\n       && GET_CODE (XEXP (*x, 0)) == REG\n       && GET_CODE (XEXP (*x, 1)) == CONST_INT)\n     {\n-      int offset = INTVAL (XEXP (*x, 1));\n+      int high_val, low_val, offset;\n+      offset = INTVAL (XEXP (*x, 1));\n       // Ignore cases with negative offsets.\n       if (offset < 0)\n         return 0;\n-      int high_val = offset & mask_val;\n-      int low_val = offset - high_val;\n+      high_val = offset & mask_val;\n+      low_val = offset - high_val;\n       if (high_val != 0)\n         {\n           rtx temp_reg = gen_rtx_PLUS (Pmode, XEXP (*x, 0), GEN_INT(high_val));\n@@ -1637,7 +1709,7 @@ picochip_output_ascii (FILE * file, const char *str, int length)\n \n   for (i = 0; i < length; ++i)\n     {\n-      fprintf (file, \"16#%hhx# \", (char) (str[i]));\n+      fprintf (file, \"16#%x# \", (char) (str[i]));\n     }\n \n   fprintf (file, \"  ; \");\n@@ -2240,6 +2312,7 @@ picochip_output_cbranch (rtx operands[])\n const char *\n picochip_output_compare (rtx operands[])\n {\n+  int code;\n \n   if (HImode != GET_MODE (operands[1]) ||\n       (HImode != GET_MODE (operands[2]) &&\n@@ -2249,9 +2322,9 @@ picochip_output_compare (rtx operands[])\n \t\t      __FUNCTION__);\n     }\n \n+  code = GET_CODE (operands[0]);\n   /* Use the type of comparison to output the appropriate condition\n      test. */\n-  int code = GET_CODE (operands[0]);\n   switch (code)\n     {\n     case NE:\n@@ -3580,6 +3653,7 @@ gen_SImode_mem(rtx opnd1,rtx opnd2)\n {\n   int offset1=0,offset2=0;\n   rtx reg;\n+  rtx address;\n   if (GET_CODE(XEXP(opnd1,0)) == PLUS && GET_CODE(XEXP(XEXP(opnd1,0),1)) == CONST_INT)\n   {\n     offset1 = INTVAL(XEXP(XEXP(opnd1,0),1));\n@@ -3593,7 +3667,7 @@ gen_SImode_mem(rtx opnd1,rtx opnd2)\n   {\n     offset2 = INTVAL(XEXP(XEXP(opnd2,0),1));\n   }\n-  rtx address = gen_rtx_PLUS (HImode, reg, GEN_INT(minimum(offset1,offset2)));\n+  address = gen_rtx_PLUS (HImode, reg, GEN_INT(minimum(offset1,offset2)));\n   return gen_rtx_MEM(SImode,address);\n }\n \n@@ -4033,6 +4107,7 @@ static rtx\n picochip_generate_halt (void)\n {\n   static int currentId = 0;\n+  rtx insns;\n   rtx id = GEN_INT (currentId);\n   currentId += 1;\n \n@@ -4043,7 +4118,7 @@ picochip_generate_halt (void)\n      it has to continue execution after the HALT.*/\n   emit_barrier ();\n \n-  rtx insns = get_insns();\n+  insns = get_insns();\n   end_sequence();\n   emit_insn (insns);\n \n@@ -4056,6 +4131,7 @@ picochip_generate_halt (void)\n void\n picochip_init_builtins (void)\n {\n+  tree noreturn;\n   tree endlink = void_list_node;\n   tree int_endlink = tree_cons (NULL_TREE, integer_type_node, endlink);\n   tree unsigned_endlink = tree_cons (NULL_TREE, unsigned_type_node, endlink);\n@@ -4197,7 +4273,7 @@ picochip_init_builtins (void)\n   /* Halt instruction. Note that the builtin function is marked as\n      having the attribute `noreturn' so that the compiler realises\n      that the halt stops the program dead. */\n-  tree noreturn = tree_cons (get_identifier (\"noreturn\"), NULL, NULL);\n+  noreturn = tree_cons (get_identifier (\"noreturn\"), NULL, NULL);\n   add_builtin_function (\"__builtin_halt\", void_ftype_void,\n \t\t\t       PICOCHIP_BUILTIN_HALT, BUILT_IN_MD, NULL,\n \t\t\t       noreturn);"}, {"sha": "6186eaa880b7c8ab687eefdd7b643d37c4ba74f6", "filename": "gcc/config/picochip/picochip.md", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31af83671c566af8a0c434d3bb1aabb58d7d7ac3/gcc%2Fconfig%2Fpicochip%2Fpicochip.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31af83671c566af8a0c434d3bb1aabb58d7d7ac3/gcc%2Fconfig%2Fpicochip%2Fpicochip.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.md?ref=31af83671c566af8a0c434d3bb1aabb58d7d7ac3", "patch": "@@ -665,6 +665,9 @@\n        rtx shiftVal;\n        rtx loadedValue;\n        rtx addressMask;\n+       rtx topByteValue;\n+       rtx signExtendedValue;\n+\n \n        warn_of_byte_access();\n \n@@ -713,11 +716,11 @@\n          emit_insn(gen_rtx_SET(HImode, loadedValue, gen_rtx_MEM(HImode, wordAddress)));\n \n \t /* Shift the desired byte to the most significant byte. */\n-\t rtx topByteValue = gen_reg_rtx (HImode);\n+\t topByteValue = gen_reg_rtx (HImode);\n \t emit_insn (gen_ashlhi3 (topByteValue, loadedValue, shiftVal));\n \n          /* Sign extend the top-byte back into the bottom byte. */\n-\t rtx signExtendedValue = gen_reg_rtx(HImode);\n+\t signExtendedValue = gen_reg_rtx(HImode);\n          emit_insn(gen_ashrhi3(signExtendedValue, topByteValue, GEN_INT(8)));\n \n          /* Final extraction of QI mode register. */\n@@ -729,8 +732,8 @@\n        {\n          rtx zeroingByteMask;\n          rtx temp;\n-         rtx tempQiMode;\n          rtx tempHiMode;\n+         rtx lsbByteMask;\n \n          /* Get the address. */\n          address = gen_reg_rtx(HImode);\n@@ -764,19 +767,10 @@\n \t  * bits, instead of the original memory value which is being\n \t  * modified.\n   \t  */\n-         /*if (register_operand(operands[1],QImode))\n-         {\n-           tempHiMode = XEXP(operands[1], 0);\n-         }\n-         else\n-         {\n-           tempHiMode = operands[1];\n-         }*/\n-         //tempHiMode = force_reg(QImode, operands[1]);\n          tempHiMode = simplify_gen_subreg(HImode, operands[1], QImode, 0);\n          temp = gen_reg_rtx(HImode);\n \t emit_insn(gen_rtx_SET(HImode, temp, tempHiMode));\n-         rtx lsbByteMask = gen_reg_rtx (HImode);\n+         lsbByteMask = gen_reg_rtx (HImode);\n \t emit_insn (gen_rtx_SET (HImode, lsbByteMask, GEN_INT (0xFF)));\n \t emit_insn (gen_andhi3 (temp, temp, lsbByteMask));\n \n@@ -913,6 +907,20 @@\n     // %R0 := #%1 (SF)\\n\\tCOPY.%# %L1,%L0\\n\\tCOPY.%# %U1,%U0\n     STL %R1,%a0\\t\\t// Mem(%M0{byte}) :={SF} %R1\")\n \n+;; memcpy pattern\n+;; 0 = destination (mem:BLK ...)\n+;; 1 = source (mem:BLK ...)\n+;; 2 = count\n+;; 3 = alignment\n+(define_expand \"movmemhi\"\n+  [(match_operand 0 \"memory_operand\" \"\")\n+  (match_operand 1 \"memory_operand\" \"\")\n+  (match_operand:HI 2 \"immediate_operand\" \"\")\n+  (match_operand 3 \"\" \"\")]\n+  \"picochip_schedule_type != DFA_TYPE_NONE\"\n+  \"if (picochip_expand_movmemhi(operands)) DONE; FAIL;\"\n+)\n+\n ;;===========================================================================\n ;; NOP\n ;;===========================================================================\n@@ -1849,23 +1857,29 @@\n   {\n     /* Synthesise a variable shift. */\n \n+    rtx tmp1;\n+    rtx tmp2;\n+    rtx tmp3;\n+    rtx minus_one;\n+    rtx tmp4;\n+\n     /* Fill a temporary with the sign bits. */\n-    rtx tmp1 = gen_reg_rtx (HImode);\n+    tmp1 = gen_reg_rtx (HImode);\n     emit_insn (gen_builtin_asri (tmp1, operands[1], GEN_INT(15)));\n \n     /* Shift the unsigned value. */\n-    rtx tmp2 = gen_reg_rtx (HImode);\n+    tmp2 = gen_reg_rtx (HImode);\n     emit_insn (gen_lshrhi3 (tmp2, operands[1], operands[2]));\n \n     /* The word of sign bits must be shifted back to the left, to zero\n      * out the unwanted lower bits.  The amount to shift left by is (15 -\n      * count). Since the shifts are computed modulo 16 (i.e., only the\n      * lower 4 bits of the count are used), the shift amount (15 - count)\n      * is equivalent to !count. */\n-    rtx tmp3 = gen_reg_rtx (HImode);\n-    rtx tmp3_1 = GEN_INT (-1);\n-    emit_insn (gen_xorhi3 (tmp3, operands[2], tmp3_1));\n-    rtx tmp4 = gen_reg_rtx (HImode);\n+    tmp3 = gen_reg_rtx (HImode);\n+    minus_one = GEN_INT (-1);\n+    emit_insn (gen_xorhi3 (tmp3, operands[2], minus_one));\n+    tmp4 = gen_reg_rtx (HImode);\n     emit_insn (gen_ashlhi3 (tmp4, tmp1, tmp3));\n \n     /* Combine the sign bits with the shifted value. */\n@@ -2372,7 +2386,7 @@\n \t\t   UNSPEC_TESTPORT))\n    (clobber (reg:CC CC_REGNUM))]\n   \"\"\n-  \"// %0 := TestPort(%1)\\;COPY.1 0,%0 \\\\\\ TSTPORT %1\\;COPYEQ 1,%0\"\n+  \"// %0 := TestPort(%1)\\;COPY.1 0,%0 %| TSTPORT %1\\;COPYEQ 1,%0\"\n   [(set_attr \"length\" \"9\")])\n \n ; Entry point for array tstport (the actual port index is computed as the"}]}