{"sha": "f79c81b920e70f16e67fa0eabf35ade358e5d3da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc5YzgxYjkyMGU3MGYxNmU2N2ZhMGVhYmYzNWFkZTM1OGU1ZDNkYQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2015-06-09T05:05:12Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2015-06-09T05:05:12Z"}, "message": "Reset inlined debug variables at the end of the inlined function\n\nfor  gcc/ChangeLog\n\n\tPR debug/58315\n\t* tree-inline.c (reset_debug_binding): New.\n\t(reset_debug_bindings): Likewise.\n\t(expand_call_inline): Call it.\n\nFrom-SVN: r224261", "tree": {"sha": "ab4051301aab82b9f84a62a7932e4c89b683a7be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab4051301aab82b9f84a62a7932e4c89b683a7be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f79c81b920e70f16e67fa0eabf35ade358e5d3da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f79c81b920e70f16e67fa0eabf35ade358e5d3da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f79c81b920e70f16e67fa0eabf35ade358e5d3da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f79c81b920e70f16e67fa0eabf35ade358e5d3da/comments", "author": null, "committer": null, "parents": [{"sha": "04fb9539b76106df895e9b95c345ffd7dbff76cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04fb9539b76106df895e9b95c345ffd7dbff76cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04fb9539b76106df895e9b95c345ffd7dbff76cd"}], "stats": {"total": 63, "additions": 63, "deletions": 0}, "files": [{"sha": "af52a9e9db88c53a189abe87e7c6bb5fbb743d57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f79c81b920e70f16e67fa0eabf35ade358e5d3da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f79c81b920e70f16e67fa0eabf35ade358e5d3da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f79c81b920e70f16e67fa0eabf35ade358e5d3da", "patch": "@@ -1,3 +1,10 @@\n+2015-06-09  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR debug/58315\n+\t* tree-inline.c (reset_debug_binding): New.\n+\t(reset_debug_bindings): Likewise.\n+\t(expand_call_inline): Call it.\n+\n 2015-06-08  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* tree.c (gimple_canonical_types_compatible_p): Drop comparsion of"}, {"sha": "242026c86e4af39789e0833b9c9add79961b070e", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f79c81b920e70f16e67fa0eabf35ade358e5d3da/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f79c81b920e70f16e67fa0eabf35ade358e5d3da/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=f79c81b920e70f16e67fa0eabf35ade358e5d3da", "patch": "@@ -4335,6 +4335,60 @@ add_local_variables (struct function *callee, struct function *caller,\n       }\n }\n \n+/* Add to BINDINGS a debug stmt resetting SRCVAR if inlining might\n+   have brought in or introduced any debug stmts for SRCVAR.  */\n+\n+static inline void\n+reset_debug_binding (copy_body_data *id, tree srcvar, gimple_seq *bindings)\n+{\n+  tree *remappedvarp = id->decl_map->get (srcvar);\n+\n+  if (!remappedvarp)\n+    return;\n+\n+  if (TREE_CODE (*remappedvarp) != VAR_DECL)\n+    return;\n+\n+  if (*remappedvarp == id->retvar || *remappedvarp == id->retbnd)\n+    return;\n+\n+  tree tvar = target_for_debug_bind (*remappedvarp);\n+  if (!tvar)\n+    return;\n+\n+  gdebug *stmt = gimple_build_debug_bind (tvar, NULL_TREE,\n+\t\t\t\t\t  id->call_stmt);\n+  gimple_seq_add_stmt (bindings, stmt);\n+}\n+\n+/* For each inlined variable for which we may have debug bind stmts,\n+   add before GSI a final debug stmt resetting it, marking the end of\n+   its life, so that var-tracking knows it doesn't have to compute\n+   further locations for it.  */\n+\n+static inline void\n+reset_debug_bindings (copy_body_data *id, gimple_stmt_iterator gsi)\n+{\n+  tree var;\n+  unsigned ix;\n+  gimple_seq bindings = NULL;\n+\n+  if (!gimple_in_ssa_p (id->src_cfun))\n+    return;\n+\n+  if (!opt_for_fn (id->dst_fn, flag_var_tracking_assignments))\n+    return;\n+\n+  for (var = DECL_ARGUMENTS (id->src_fn);\n+       var; var = DECL_CHAIN (var))\n+    reset_debug_binding (id, var, &bindings);\n+\n+  FOR_EACH_LOCAL_DECL (id->src_cfun, ix, var)\n+    reset_debug_binding (id, var, &bindings);\n+\n+  gsi_insert_seq_before_without_update (&gsi, bindings, GSI_SAME_STMT);\n+}\n+\n /* If STMT is a GIMPLE_CALL, replace it with its inline expansion.  */\n \n static bool\n@@ -4648,6 +4702,8 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   \t     GCOV_COMPUTE_SCALE (cg_edge->frequency, CGRAPH_FREQ_BASE),\n \t     bb, return_block, NULL);\n \n+  reset_debug_bindings (id, stmt_gsi);\n+\n   /* Reset the escaped solution.  */\n   if (cfun->gimple_df)\n     pt_solution_reset (&cfun->gimple_df->escaped);"}]}