{"sha": "fabe8cc41e9b01913e2016861237d1d99d7567bf", "node_id": "C_kwDOANBUbNoAKGZhYmU4Y2M0MWU5YjAxOTEzZTIwMTY4NjEyMzdkMWQ5OWQ3NTY3YmY", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-11-04T09:37:14Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-11-15T19:48:56Z"}, "message": "IPA: Provide a mechanism to register static DTORs via cxa_atexit.\n\nFor at least one target (Darwin) the platform convention is to\nregister static destructors (i.e. __attribute__((destructor)))\nwith __cxa_atexit rather than placing them into a list that is\nrun by some other mechanism.\n\nThis patch provides a target hook that allows a target to opt\ninto this and handling for the process in ipa_cdtor_merge ().\n\nWhen the mode is enabled (dtors_from_cxa_atexit is set) we:\n\n * Generate new CTORs to register static destructors with\n   __cxa_atexit and add them to the existing list of CTORs;\n   we then process the revised CTORs list.\n\n * We sort the DTORs into priority and then TU order, this\n   means that they are registered in that order with\n   __cxa_atexit () and therefore will be run in the reverse\n   order.\n\n * Likewise, CTORs are sorted into priority and then TU order,\n   which means that they will run in that order.\n\nThis matches the behavior of using init/fini (or\nmod_init_func/mod_term_func) sections.\n\nThis also fixes a bug where Fortran needs a DTOR to be run to\nclose IO.\n\nSigned-off-by: Iain Sandoe <iain@sandoe.co.uk>\n\n\tPR fortran/102992\n\ngcc/ChangeLog:\n\n\t* config/darwin.h (TARGET_DTORS_FROM_CXA_ATEXIT): New.\n\t* doc/tm.texi: Regenerated.\n\t* doc/tm.texi.in: Add TARGET_DTORS_FROM_CXA_ATEXIT hook.\n\t* ipa.c (cgraph_build_static_cdtor_1): Return the built\n\tfunction decl.\n\t(build_cxa_atexit_decl): New.\n\t(build_dso_handle_decl): New.\n\t(build_cxa_dtor_registrations): New.\n\t(compare_cdtor_tu_order): New.\n\t(build_cxa_atexit_fns): New.\n\t(ipa_cdtor_merge): If dtors_from_cxa_atexit is set,\n\tprocess the DTORs/CTORs accordingly.\n\t(pass_ipa_cdtor_merge::gate): Also run if\n\tdtors_from_cxa_atexit is set.\n\t* target.def (dtors_from_cxa_atexit): New hook.", "tree": {"sha": "355d2b664bee14493cfe409407adb9d965446b45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/355d2b664bee14493cfe409407adb9d965446b45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fabe8cc41e9b01913e2016861237d1d99d7567bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabe8cc41e9b01913e2016861237d1d99d7567bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fabe8cc41e9b01913e2016861237d1d99d7567bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabe8cc41e9b01913e2016861237d1d99d7567bf/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3cc82dc9cc2d4f1021fc5d4c1463c3a14fc6795", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3cc82dc9cc2d4f1021fc5d4c1463c3a14fc6795", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3cc82dc9cc2d4f1021fc5d4c1463c3a14fc6795"}], "stats": {"total": 225, "additions": 221, "deletions": 4}, "files": [{"sha": "7ed01efa6944f48b7f3cea9e202b46235d68aa2b", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabe8cc41e9b01913e2016861237d1d99d7567bf/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabe8cc41e9b01913e2016861237d1d99d7567bf/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=fabe8cc41e9b01913e2016861237d1d99d7567bf", "patch": "@@ -54,6 +54,11 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #define DO_GLOBAL_DTORS_BODY\n \n+/* Register static destructors to run from __cxa_atexit instead of putting\n+   them into a .mod_term_funcs section.  */\n+\n+#define TARGET_DTORS_FROM_CXA_ATEXIT true\n+\n /* The string value for __SIZE_TYPE__.  */\n \n #ifndef SIZE_TYPE"}, {"sha": "6ec1d50b3e44c823cf242dbcc062a68245e291ef", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabe8cc41e9b01913e2016861237d1d99d7567bf/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabe8cc41e9b01913e2016861237d1d99d7567bf/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=fabe8cc41e9b01913e2016861237d1d99d7567bf", "patch": "@@ -9210,6 +9210,14 @@ collecting constructors and destructors to be run at startup and exit.\n It is false if we must use @command{collect2}.\n @end deftypevr\n \n+@deftypevr {Target Hook} bool TARGET_DTORS_FROM_CXA_ATEXIT\n+This value is true if the target wants destructors to be queued to be\n+run from __cxa_atexit.  If this is the case then, for each priority level,\n+a new constructor will be entered that registers the destructors for that\n+level with __cxa_atexit (and there will be no destructors emitted).\n+It is false the method implied by @code{have_ctors_dtors} is used.\n+@end deftypevr\n+\n @deftypefn {Target Hook} void TARGET_ASM_CONSTRUCTOR (rtx @var{symbol}, int @var{priority})\n If defined, a function that outputs assembler code to arrange to call\n the function referenced by @var{symbol} at initialization time."}, {"sha": "2b9960b73d70f89d129d2577a9d5446c77cac961", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabe8cc41e9b01913e2016861237d1d99d7567bf/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabe8cc41e9b01913e2016861237d1d99d7567bf/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=fabe8cc41e9b01913e2016861237d1d99d7567bf", "patch": "@@ -6015,6 +6015,8 @@ encountering an @code{init_priority} attribute.\n \n @hook TARGET_HAVE_CTORS_DTORS\n \n+@hook TARGET_DTORS_FROM_CXA_ATEXIT\n+\n @hook TARGET_ASM_CONSTRUCTOR\n \n @hook TARGET_ASM_DESTRUCTOR"}, {"sha": "325b658b55ee3e9a9f774146e1aeef5b5a810d3a", "filename": "gcc/ipa.c", "status": "modified", "additions": 196, "deletions": 4, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabe8cc41e9b01913e2016861237d1d99d7567bf/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabe8cc41e9b01913e2016861237d1d99d7567bf/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=fabe8cc41e9b01913e2016861237d1d99d7567bf", "patch": "@@ -837,7 +837,7 @@ ipa_discover_variable_flags (void)\n    FINAL specify whether the externally visible name for collect2 should\n    be produced. */\n \n-static void\n+static tree\n cgraph_build_static_cdtor_1 (char which, tree body, int priority, bool final,\n \t\t\t     tree optimization,\n \t\t\t     tree target)\n@@ -916,6 +916,7 @@ cgraph_build_static_cdtor_1 (char which, tree body, int priority, bool final,\n \n   set_cfun (NULL);\n   current_function_decl = NULL;\n+  return decl;\n }\n \n /* Generate and emit a static constructor or destructor.  WHICH must\n@@ -1022,6 +1023,124 @@ build_cdtor (bool ctor_p, const vec<tree> &cdtors)\n     }\n }\n \n+/* Helper functions for build_cxa_dtor_registrations ().\n+   Build a decl for __cxa_atexit ().  */\n+\n+static tree\n+build_cxa_atexit_decl ()\n+{\n+  /* The parameter to \"__cxa_atexit\" is \"void (*)(void *)\".  */\n+  tree fn_type = build_function_type_list (void_type_node,\n+\t\t\t\t\t   ptr_type_node, NULL_TREE);\n+  tree fn_ptr_type = build_pointer_type (fn_type);\n+  /* The declaration for `__cxa_atexit' is:\n+     int __cxa_atexit (void (*)(void *), void *, void *).  */\n+  const char *name = \"__cxa_atexit\";\n+  tree cxa_name = get_identifier (name);\n+  fn_type = build_function_type_list (integer_type_node, fn_ptr_type,\n+\t\t\t\t      ptr_type_node, ptr_type_node, NULL_TREE);\n+  tree atexit_fndecl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,\n+\t\t\t\t   cxa_name, fn_type);\n+  SET_DECL_ASSEMBLER_NAME (atexit_fndecl, cxa_name);\n+  DECL_VISIBILITY (atexit_fndecl) = VISIBILITY_DEFAULT;\n+  DECL_VISIBILITY_SPECIFIED (atexit_fndecl) = true;\n+  set_call_expr_flags (atexit_fndecl, ECF_LEAF | ECF_NOTHROW);\n+  TREE_PUBLIC (atexit_fndecl) = true;\n+  DECL_EXTERNAL (atexit_fndecl) = true;\n+  DECL_ARTIFICIAL (atexit_fndecl) = true;\n+  return atexit_fndecl;\n+}\n+\n+/* Build a decl for __dso_handle.  */\n+\n+static tree\n+build_dso_handle_decl ()\n+{\n+  /* Declare the __dso_handle variable.  */\n+  tree dso_handle_decl = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t\t\t     get_identifier (\"__dso_handle\"),\n+\t\t\t\t     ptr_type_node);\n+  TREE_PUBLIC (dso_handle_decl) = true;\n+  DECL_EXTERNAL (dso_handle_decl) = true;\n+  DECL_ARTIFICIAL (dso_handle_decl) = true;\n+#ifdef HAVE_GAS_HIDDEN\n+  if (dso_handle_decl != error_mark_node)\n+    {\n+      DECL_VISIBILITY (dso_handle_decl) = VISIBILITY_HIDDEN;\n+      DECL_VISIBILITY_SPECIFIED (dso_handle_decl) = true;\n+    }\n+#endif\n+  return dso_handle_decl;\n+}\n+\n+/*  This builds one or more constructor functions that register DTORs with\n+    __cxa_atexit ().  Within a priority level, DTORs are registered in TU\n+    order - which means that they will run in reverse TU order from cxa_atexit.\n+    This is the same behavior as using a .fini / .mod_term_funcs section.\n+    As the functions are built, they are appended to the CTORs vector.  */\n+\n+static void\n+build_cxa_dtor_registrations (const vec<tree> &dtors, vec<tree> *ctors)\n+{\n+  size_t i,j;\n+  size_t len = dtors.length ();\n+\n+  location_t sav_loc = input_location;\n+  input_location = UNKNOWN_LOCATION;\n+\n+  tree atexit_fndecl = build_cxa_atexit_decl ();\n+  tree dso_handle_decl = build_dso_handle_decl ();\n+\n+  /* We want &__dso_handle.  */\n+  tree dso_ptr = build1_loc (UNKNOWN_LOCATION, ADDR_EXPR,\n+\t\t\t     ptr_type_node, dso_handle_decl);\n+\n+  i = 0;\n+  while (i < len)\n+    {\n+      priority_type priority = 0;\n+      tree body = NULL_TREE;\n+      j = i;\n+      do\n+\t{\n+\t  priority_type p;\n+\t  tree fn = dtors[j];\n+\t  p = DECL_FINI_PRIORITY (fn);\n+\t  if (j == i)\n+\t    priority = p;\n+\t  else if (p != priority)\n+\t    break;\n+\t  j++;\n+\t}\n+      while (j < len);\n+\n+      /* Find the next batch of destructors with the same initialization\n+\t priority.  */\n+      for (;i < j; i++)\n+\t{\n+\t  tree fn = dtors[i];\n+\t  DECL_STATIC_DESTRUCTOR (fn) = 0;\n+\t  tree dtor_ptr = build1_loc (UNKNOWN_LOCATION, ADDR_EXPR,\n+\t\t\t\t      ptr_type_node, fn);\n+\t  tree call_cxa_atexit\n+\t    = build_call_expr_loc (UNKNOWN_LOCATION, atexit_fndecl, 3,\n+\t\t\t\t   dtor_ptr, null_pointer_node, dso_ptr);\n+\t  TREE_SIDE_EFFECTS (call_cxa_atexit) = 1;\n+\t  append_to_statement_list (call_cxa_atexit, &body);\n+\t}\n+\n+      gcc_assert (body != NULL_TREE);\n+      /* Generate a function to register the DTORs at this priority.  */\n+      tree new_ctor\n+\t= cgraph_build_static_cdtor_1 ('I', body, priority, true,\n+\t\t\t\t       DECL_FUNCTION_SPECIFIC_OPTIMIZATION (dtors[0]),\n+\t\t\t\t       DECL_FUNCTION_SPECIFIC_TARGET (dtors[0]));\n+      /* Add this to the list of ctors.  */\n+      ctors->safe_push (new_ctor);\n+    }\n+  input_location = sav_loc;\n+}\n+\n /* Comparison function for qsort.  P1 and P2 are actually of type\n    \"tree *\" and point to static constructors.  DECL_INIT_PRIORITY is\n    used to determine the sort order.  */\n@@ -1071,7 +1190,46 @@ compare_dtor (const void *p1, const void *p2)\n   else if (priority1 > priority2)\n     return 1;\n   else\n-    /* Ensure a stable sort.  */\n+    /* Ensure a stable sort - into TU order.  */\n+    return DECL_UID (f1) - DECL_UID (f2);\n+}\n+\n+/* Comparison function for qsort.  P1 and P2 are of type \"tree *\" and point to\n+   a pair of static constructors or destructors.  We first sort on the basis of\n+   priority and then into TU order (on the strict assumption that DECL_UIDs are\n+   ordered in the same way as the original functions).  ???: this seems quite\n+   fragile. */\n+\n+static int\n+compare_cdtor_tu_order (const void *p1, const void *p2)\n+{\n+  tree f1;\n+  tree f2;\n+  int priority1;\n+  int priority2;\n+\n+  f1 = *(const tree *)p1;\n+  f2 = *(const tree *)p2;\n+  /* We process the DTORs first, and then remove their flag, so this order\n+     allows for functions that are declared as both CTOR and DTOR.  */\n+  if (DECL_STATIC_DESTRUCTOR (f1))\n+    {\n+      gcc_checking_assert (DECL_STATIC_DESTRUCTOR (f2));\n+      priority1 = DECL_FINI_PRIORITY (f1);\n+      priority2 = DECL_FINI_PRIORITY (f2);\n+    }\n+  else\n+    {\n+      priority1 = DECL_INIT_PRIORITY (f1);\n+      priority2 = DECL_INIT_PRIORITY (f2);\n+    }\n+\n+  if (priority1 < priority2)\n+    return -1;\n+  else if (priority1 > priority2)\n+    return 1;\n+  else\n+    /* For equal priority, sort into the order of definition in the TU.  */\n     return DECL_UID (f1) - DECL_UID (f2);\n }\n \n@@ -1097,6 +1255,37 @@ build_cdtor_fns (vec<tree> *ctors, vec<tree> *dtors)\n     }\n }\n \n+/* Generate new CTORs to register static destructors with __cxa_atexit and add\n+   them to the existing list of CTORs; we then process the revised CTORs list.\n+\n+   We sort the DTORs into priority and then TU order, this means that they are\n+   registered in that order with __cxa_atexit () and therefore will be run in\n+   the reverse order.\n+\n+   Likewise, CTORs are sorted into priority and then TU order, which means that\n+   they will run in that order.\n+\n+   This matches the behavior of using init/fini or mod_init_func/mod_term_func\n+   sections.  */\n+\n+static void\n+build_cxa_atexit_fns (vec<tree> *ctors, vec<tree> *dtors)\n+{\n+  if (!dtors->is_empty ())\n+    {\n+      gcc_assert (targetm.dtors_from_cxa_atexit);\n+      dtors->qsort (compare_cdtor_tu_order);\n+      build_cxa_dtor_registrations (*dtors, ctors);\n+    }\n+\n+  if (!ctors->is_empty ())\n+    {\n+      gcc_assert (targetm.dtors_from_cxa_atexit);\n+      ctors->qsort (compare_cdtor_tu_order);\n+      build_cdtor (/*ctor_p=*/true, *ctors);\n+    }\n+}\n+\n /* Look for constructors and destructors and produce function calling them.\n    This is needed for targets not supporting ctors or dtors, but we perform the\n    transformation also at linktime to merge possibly numerous\n@@ -1115,7 +1304,10 @@ ipa_cdtor_merge (void)\n     if (DECL_STATIC_CONSTRUCTOR (node->decl)\n \t|| DECL_STATIC_DESTRUCTOR (node->decl))\n        record_cdtor_fn (node, &ctors, &dtors);\n-  build_cdtor_fns (&ctors, &dtors);\n+  if (targetm.dtors_from_cxa_atexit)\n+    build_cxa_atexit_fns (&ctors, &dtors);\n+  else\n+    build_cdtor_fns (&ctors, &dtors);\n   return 0;\n }\n \n@@ -1162,7 +1354,7 @@ pass_ipa_cdtor_merge::gate (function *)\n   /* Perform the pass when we have no ctors/dtors support\n      or at LTO time to merge multiple constructors into single\n      function.  */\n-  return !targetm.have_ctors_dtors || in_lto_p;\n+  return !targetm.have_ctors_dtors || in_lto_p || targetm.dtors_from_cxa_atexit;\n }\n \n } // anon namespace"}, {"sha": "b803c582f01cb50230556a93711c13c923d86ead", "filename": "gcc/target.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabe8cc41e9b01913e2016861237d1d99d7567bf/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabe8cc41e9b01913e2016861237d1d99d7567bf/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=fabe8cc41e9b01913e2016861237d1d99d7567bf", "patch": "@@ -6778,6 +6778,16 @@ collecting constructors and destructors to be run at startup and exit.\\n\\\n It is false if we must use @command{collect2}.\",\n  bool, false)\n \n+/* True if the target wants DTORs to be run from cxa_atexit.  */\n+DEFHOOKPOD\n+(dtors_from_cxa_atexit,\n+ \"This value is true if the target wants destructors to be queued to be\\n\\\n+run from __cxa_atexit.  If this is the case then, for each priority level,\\n\\\n+a new constructor will be entered that registers the destructors for that\\n\\\n+level with __cxa_atexit (and there will be no destructors emitted).\\n\\\n+It is false the method implied by @code{have_ctors_dtors} is used.\",\n+ bool, false)\n+\n /* True if thread-local storage is supported.  */\n DEFHOOKPOD\n (have_tls,"}]}