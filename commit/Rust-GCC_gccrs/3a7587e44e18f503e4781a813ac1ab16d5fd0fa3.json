{"sha": "3a7587e44e18f503e4781a813ac1ab16d5fd0fa3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E3NTg3ZTQ0ZTE4ZjUwM2U0NzgxYTgxM2FjMWFiMTZkNWZkMGZhMw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-03T03:45:10Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-03T03:45:10Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r669", "tree": {"sha": "ab228f73bf2f03cf96e039443b0cd5ef6945cea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab228f73bf2f03cf96e039443b0cd5ef6945cea5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a7587e44e18f503e4781a813ac1ab16d5fd0fa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a7587e44e18f503e4781a813ac1ab16d5fd0fa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a7587e44e18f503e4781a813ac1ab16d5fd0fa3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a7587e44e18f503e4781a813ac1ab16d5fd0fa3/comments", "author": null, "committer": null, "parents": [{"sha": "dca0b23fca9205f1b7d2c8fc6d2e9331bb5e18ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dca0b23fca9205f1b7d2c8fc6d2e9331bb5e18ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dca0b23fca9205f1b7d2c8fc6d2e9331bb5e18ff"}], "stats": {"total": 259, "additions": 103, "deletions": 156}, "files": [{"sha": "4d0276a1d11f761d1c5ccdd991a977c228958965", "filename": "gcc/dbxout.c", "status": "modified", "additions": 103, "deletions": 156, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a7587e44e18f503e4781a813ac1ab16d5fd0fa3/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a7587e44e18f503e4781a813ac1ab16d5fd0fa3/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=3a7587e44e18f503e4781a813ac1ab16d5fd0fa3", "patch": "@@ -557,9 +557,9 @@ dbxout_type_fields (type)\n \t      have_used_extensions = 1;\n \t      CHARS (3 + IDENTIFIER_LENGTH (DECL_NAME (TYPE_NAME (DECL_FCONTEXT (tem)))));\n \t      fputs (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (tem)), asmfile);\n-\t      dbxout_type (DECL_FCONTEXT (tem), 0);\n+\t      dbxout_type (DECL_FCONTEXT (tem), 0, 0);\n \t      fprintf (asmfile, \":\");\n-\t      dbxout_type (TREE_TYPE (tem), 0);\n+\t      dbxout_type (TREE_TYPE (tem), 0, 0);\n \t      fprintf (asmfile, \",%d;\",\n \t\t       TREE_INT_CST_LOW (DECL_FIELD_BITPOS (tem)));\n \t      continue;\n@@ -583,25 +583,14 @@ dbxout_type_fields (type)\n \t  dbxout_type ((TREE_CODE (tem) == FIELD_DECL\n \t\t\t&& DECL_BIT_FIELD_TYPE (tem))\n \t\t       ? DECL_BIT_FIELD_TYPE (tem)\n-\t\t       : TREE_TYPE (tem), 0);\n+\t\t       : TREE_TYPE (tem), 0, 0);\n \n \t  if (TREE_CODE (tem) == VAR_DECL)\n \t    {\n \t      if (TREE_STATIC (tem) && use_gdb_dbx_extensions)\n \t\t{\n \t\t  char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (tem));\n \t\t  have_used_extensions = 1;\n-\n-#if 0 /* ??? Comment below makes it clear this is unacceptable.  */\n-\t\t  /* Adding 1 here only works on systems\n-\t\t     which flush an initial underscore from\n-\t\t     the .stabs entry.  This loses for static names\n-\t\t     which have an initial leading '_' on systems which\n-\t\t     don't use leading underscores.  */\n-\t\t  if (name[0] == '_')\n-\t\t    name += 1;\n-#endif\n-\n \t\t  fprintf (asmfile, \":%s;\", name);\n \t\t  CHARS (strlen (name));\n \t\t}\n@@ -665,7 +654,7 @@ dbxout_type_method_1 (decl, debug_name)\n     {\n       fprintf (asmfile, \"%d;\",\n \t       TREE_INT_CST_LOW (DECL_VINDEX (decl)));\n-      dbxout_type (DECL_CONTEXT (decl), 0);\n+      dbxout_type (DECL_CONTEXT (decl), 0, 0);\n       fprintf (asmfile, \";\");\n       CHARS (8);\n     }\n@@ -679,7 +668,6 @@ dbxout_type_methods (type)\n      register tree type;\n {\n   /* C++: put out the method names and their parameter lists */\n-  tree ctor_name;\n   tree methods = TYPE_METHODS (type);\n   tree type_encoding;\n   register tree fndecl;\n@@ -689,13 +677,13 @@ dbxout_type_methods (type)\n   if (methods == NULL_TREE)\n     return;\n \n-  ctor_name = DECL_NAME (TYPE_NAME (type));\n+  type_encoding = DECL_NAME (TYPE_NAME (type));\n \n   /* C++: Template classes break some assumptions made by this code about\n      the class names, constructor names, and encodings for assembler\n      label names.  For now, disable output of dbx info for them.  */\n   {\n-    char *ptr = IDENTIFIER_POINTER (ctor_name);\n+    char *ptr = IDENTIFIER_POINTER (type_encoding);\n     /* Avoid strchr or index since those names aren't universal.  */\n     while (*ptr && *ptr != '<') ptr++;\n     if (*ptr != 0)\n@@ -710,125 +698,87 @@ dbxout_type_methods (type)\n       }\n   }\n \n-  type_identifier_length = IDENTIFIER_LENGTH (ctor_name);\n+  type_identifier_length = IDENTIFIER_LENGTH (type_encoding);\n \n   if (TREE_CODE (methods) == FUNCTION_DECL)\n     fndecl = methods;\n   else if (TREE_VEC_ELT (methods, 0) != NULL_TREE)\n     fndecl = TREE_VEC_ELT (methods, 0);\n   else fndecl = TREE_VEC_ELT (methods, 1);\n \n-  if (TREE_CODE (type) == RECORD_TYPE && DECL_NAME (fndecl) == ctor_name)\n-    {\n-      tree ctor = fndecl;\n-      tree dtor;\n-\n-      /* Destructors lie in a special place.\n-         n.b.  TYPE_HAS_DESTRUCTOR == TYPE_LANG_FLAG_2 */\n-      if (TYPE_LANG_FLAG_2 (type))\n-\t{\n-\t  dtor = fndecl;\n-\t  fndecl = ctor = TREE_CHAIN (dtor);\n-\t}\n-      else\n-\tdtor = NULL_TREE;\n-\n-      CHARS (2);\n-\n-      if (ctor)\n-\t{\n-\t  int need_prefix = 1;\n-\n-\t  while (ctor)\n-\t    {\n-\t      /* Output the name of the field (after overloading), as\n-\t\t well as the name of the field before overloading, along\n-\t\t with its parameter list.  */\n-\t      char *debug_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (ctor));\n-\t      int old_minimal_debug = flag_minimal_debug;\n-\n-\t      CONTIN;\n-\n-\t      if (DECL_NAME (ctor) == ctor_name && ! DECL_IGNORED_P (ctor))\n-\t\t{\n-\t\t  if (need_prefix)\n-\t\t    {\n-\t\t      fprintf (asmfile, \"%s::\", IDENTIFIER_POINTER (DECL_NAME (ctor)));\n-\t\t      CHARS (IDENTIFIER_LENGTH (DECL_NAME (ctor)) + 3);\n-\t\t      need_prefix = 0;\n-\t\t    }\n-\n-\t\t  if (ctor == dtor)\n-\t\t    /* Always output destructors with full information.  */\n-\t\t    flag_minimal_debug = 0;\n-\n-\t\t  dbxout_type (TREE_TYPE (ctor), 0);\n-\t\t  flag_minimal_debug = old_minimal_debug;\n-\n-\t\t  if (flag_minimal_debug && ctor != dtor)\n-\t\t    {\n-\t\t      /* Cut down on debugging information by not outputting\n-\t\t\t the parts of the name we can just as easily\n-\t\t\t have the debugger figure out.  */\n-\n-\t\t      /* Get past '__'.  */\n-\t\t      debug_name += 2;\n-\t\t      /* Get past const and volatile qualifiers.  */\n-\t\t      while (*debug_name == 'C' || *debug_name == 'V')\n-\t\t\tdebug_name++;\n-\t\t      /* Get past numeric type length prefix.  */\n-\t\t      while (*debug_name >= '0' && *debug_name <= '9')\n-\t\t\tdebug_name++;\n-\t\t      /* Get past type of `this'.  */\n-\t\t      debug_name += type_identifier_length;\n-\t\t    }\n-\t\t  dbxout_type_method_1 (ctor, debug_name);\n-\t\t}\n-\n-\t      if (ctor == dtor)\n-\t\tbreak;\n-\n-\t      ctor = TREE_CHAIN (ctor);\n-\t      if (ctor == NULL_TREE || DECL_NAME (ctor) != ctor_name)\n-\t\t{\n-\t\t  fndecl = ctor;\n-\t\t  ctor = dtor;\n-\t\t}\n-\t    }\n-\t  if (! need_prefix)\n-\t    putc (';', asmfile);\n-\t}\n-    }\n-\n   while (fndecl)\n     {\n       tree name = DECL_NAME (fndecl);\n-      fprintf (asmfile, \"%s::\", IDENTIFIER_POINTER (name));\n-      CHARS (IDENTIFIER_LENGTH (name) + 3);\n+      int need_prefix = 1;\n \n+      /* Group together all the methods for the same operation.\n+\t These differ in the types of the arguments.  */\n       for (last = NULL_TREE;\n \t   fndecl && (last == NULL_TREE || DECL_NAME (fndecl) == DECL_NAME (last));\n \t   fndecl = TREE_CHAIN (fndecl))\n \t/* Output the name of the field (after overloading), as\n \t   well as the name of the field before overloading, along\n \t   with its parameter list */\n \t{\n+\t  /* This is the \"mangled\" name of the method.\n+\t     It encodes the argument types.  */\n \t  char *debug_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl));\n+\t  int destructor = 0;\n \n \t  CONTIN;\n \n \t  last = fndecl;\n-\t  dbxout_type (TREE_TYPE (fndecl), 0);\n+\n+\t  if (DECL_IGNORED_P (fndecl))\n+\t    continue;\n+\n \t  if (flag_minimal_debug)\n \t    {\n-\t      debug_name += IDENTIFIER_LENGTH (DECL_NAME (fndecl)) + 2;\n-\t      /* Get past const and volatile qualifiers.  */\n-\t      while (*debug_name == 'C' || *debug_name == 'V')\n-\t\tdebug_name++;\n-\t      while (*debug_name >= '0' && *debug_name <= '9')\n-\t\tdebug_name++;\n-\t      debug_name += type_identifier_length;\n+\t      /* Detect ordinary methods because their mangled names\n+\t\t start with the operation name.  */\n+\t      if (!strncmp (IDENTIFIER_POINTER (name), debug_name,\n+\t\t\t    IDENTIFIER_LENGTH (name)))\n+\t\t{\n+\t\t  debug_name += IDENTIFIER_LENGTH (name);\n+\t\t  if (debug_name[0] == '_' && debug_name[1] == '_')\n+\t\t    {\n+\t\t      char *method_name = debug_name + 2;\n+\t\t      /* Get past const and volatile qualifiers.  */\n+\t\t      while (*method_name == 'C' || *method_name == 'V')\n+\t\t\tmethod_name++;\n+\t\t      if (! strncmp (method_name,\n+\t\t\t\t     IDENTIFIER_POINTER (type_encoding),\n+\t\t\t\t     type_identifier_length))\n+\t\t\tmethod_name += type_identifier_length;\n+\t\t      debug_name = method_name;\n+\t\t    }\n+\t\t}\n+\t      /* Detect constructors by their style of name mangling.  */\n+\t      else if (debug_name[0] == '_' && debug_name[1] == '_')\n+\t\t{\n+\t\t  char *ctor_name = debug_name + 2;\n+\t\t  while (*ctor_name == 'C' || *ctor_name == 'V')\n+\t\t    ctor_name++;\n+\t\t  if (!strncmp (IDENTIFIER_POINTER (type_encoding), ctor_name,\n+\t\t\t\ttype_identifier_length))\n+\t\t    debug_name = ctor_name + type_identifier_length;\n+\t\t}\n+\t      /* The other alternative is a destructor.  */\n+\t      else\n+\t\tdestructor = 1;\n+\n+\t      /* Output the operation name just once, for the first method\n+\t\t that we output.  */\n+\t      if (need_prefix)\n+\t\t{\n+\t\t  fprintf (asmfile, \"%s::\", IDENTIFIER_POINTER (name));\n+\t\t  CHARS (IDENTIFIER_LENGTH (name) + 2);\n+\t\t  need_prefix = 0;\n+\t\t}\n \t    }\n+\n+\t  dbxout_type (TREE_TYPE (fndecl), 0, destructor);\n+\n \t  dbxout_type_method_1 (fndecl, debug_name);\n \t}\n       putc (';', asmfile);\n@@ -844,12 +794,16 @@ dbxout_type_methods (type)\n    If FULL is nonzero, and the type has been described only with\n    a forward-reference, output the definition now.\n    If FULL is zero in this case, just refer to the forward-reference\n-   using the number previously allocated.  */\n+   using the number previously allocated.\n+\n+   If SHOW_ARG_TYPES is nonzero, we output a description of the argument\n+   types for a METHOD_TYPE.  */\n \n static void\n-dbxout_type (type, full)\n+dbxout_type (type, full, show_arg_types)\n      tree type;\n      int full;\n+     int show_arg_types;\n {\n   register tree tem;\n \n@@ -996,7 +950,7 @@ dbxout_type (type, full)\n \t\t? TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n \t        : -1));\n       CHARS (17);\n-      dbxout_type (TREE_TYPE (type), 0);\n+      dbxout_type (TREE_TYPE (type), 0, 0);\n       break;\n \n     case RECORD_TYPE:\n@@ -1015,7 +969,9 @@ dbxout_type (type, full)\n \t\t   && DECL_IGNORED_P (TYPE_NAME (type)))\n #endif\n \t     && !full)\n-\t    || TYPE_SIZE (type) == 0)\n+\t    || TYPE_SIZE (type) == 0\n+\t    /* No way in DBX fmt to describe a variable size.  */\n+\t    || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n \t  {\n \t    /* If the type is just a cross reference, output one\n \t       and mark the type as partially described.\n@@ -1040,10 +996,6 @@ dbxout_type (type, full)\n \t  }\n \ttem = size_in_bytes (type);\n \n-\t/* The code below assumes the size is an integer constant.  */\n-\tif (TREE_CODE (tem) != INTEGER_CST)\n-\t  abort ();\n-\n \t/* Identify record or union, and print its size.  */\n \tfprintf (asmfile, (TREE_CODE (type) == RECORD_TYPE) ? \"s%d\" : \"u%d\",\n \t\t TREE_INT_CST_LOW (tem));\n@@ -1072,7 +1024,7 @@ dbxout_type (type, full)\n \t\tfprintf (asmfile, \"%d,\",\n \t\t\t TREE_INT_CST_LOW (BINFO_OFFSET (child)) * BITS_PER_UNIT);\n \t\tCHARS (15);\n-\t\tdbxout_type (BINFO_TYPE (child), 0);\n+\t\tdbxout_type (BINFO_TYPE (child), 0, 0);\n \t\tputc (';', asmfile);\n \t      }\n \t    else\n@@ -1081,7 +1033,7 @@ dbxout_type (type, full)\n \t\t   which have the same names at the types they hold.  */\n \t\tdbxout_type_name (BINFO_TYPE (child));\n \t\tputc (':', asmfile);\n-\t\tdbxout_type (BINFO_TYPE (child), full);\n+\t\tdbxout_type (BINFO_TYPE (child), full, 0);\n \t\tfprintf (asmfile, \",%d,%d;\",\n \t\t\t TREE_INT_CST_LOW (BINFO_OFFSET (child)) * BITS_PER_UNIT,\n \t\t\t TREE_INT_CST_LOW (DECL_SIZE (TYPE_NAME (BINFO_TYPE (child)))) * BITS_PER_UNIT);\n@@ -1117,7 +1069,7 @@ dbxout_type (type, full)\n \t  if (TYPE_VFIELD (type))\n \t    {\n \t      putc ('%', asmfile);\n-\t      dbxout_type (DECL_FCONTEXT (TYPE_VFIELD (type)), 0);\n+\t      dbxout_type (DECL_FCONTEXT (TYPE_VFIELD (type)), 0, 0);\n \t    }\n \t  putc (';', asmfile);\n \t  CHARS (3);\n@@ -1154,7 +1106,7 @@ dbxout_type (type, full)\n     case POINTER_TYPE:\n       putc ('*', asmfile);\n       CHARS (1);\n-      dbxout_type (TREE_TYPE (type), 0);\n+      dbxout_type (TREE_TYPE (type), 0, 0);\n       break;\n \n     case METHOD_TYPE:\n@@ -1163,19 +1115,23 @@ dbxout_type (type, full)\n \t  have_used_extensions = 1;\n \t  putc ('#', asmfile);\n \t  CHARS (1);\n-\t  if (flag_minimal_debug)\n+\t  if (flag_minimal_debug && !show_arg_types)\n \t    {\n+\t      /* Normally, just output the return type.\n+\t\t The argument types are encoded in the method name.  */\n \t      putc ('#', asmfile);\n-\t      dbxout_type (TREE_TYPE (type), 0);\n+\t      dbxout_type (TREE_TYPE (type), 0, 0);\n \t      putc (';', asmfile);\n \t      CHARS (1);\n \t    }\n \t  else\n \t    {\n-\t      dbxout_type (TYPE_METHOD_BASETYPE (type), 0);\n+\t      /* When outputing destructors, we need to write\n+\t\t the argument types out longhand.  */\n+\t      dbxout_type (TYPE_METHOD_BASETYPE (type), 0, 0);\n \t      putc (',', asmfile);\n \t      CHARS (1);\n-\t      dbxout_type (TREE_TYPE (type), 0);\n+\t      dbxout_type (TREE_TYPE (type), 0, 0);\n \t      dbxout_args (TYPE_ARG_TYPES (type));\n \t      putc (';', asmfile);\n \t      CHARS (1);\n@@ -1184,7 +1140,7 @@ dbxout_type (type, full)\n       else\n \t{\n \t  /* Treat it as a function type.  */\n-\t  dbxout_type (TREE_TYPE (type), 0);\n+\t  dbxout_type (TREE_TYPE (type), 0, 0);\n \t}\n       break;\n \n@@ -1194,16 +1150,16 @@ dbxout_type (type, full)\n \t  have_used_extensions = 1;\n \t  putc ('@', asmfile);\n \t  CHARS (1);\n-\t  dbxout_type (TYPE_OFFSET_BASETYPE (type), 0);\n+\t  dbxout_type (TYPE_OFFSET_BASETYPE (type), 0, 0);\n \t  putc (',', asmfile);\n \t  CHARS (1);\n-\t  dbxout_type (TREE_TYPE (type), 0);\n+\t  dbxout_type (TREE_TYPE (type), 0, 0);\n \t}\n       else\n \t{\n \t  /* Should print as an int, because it is really\n \t     just an offset.  */\n-\t  dbxout_type (integer_type_node, 0);\n+\t  dbxout_type (integer_type_node, 0, 0);\n \t}\n       break;\n \n@@ -1212,13 +1168,13 @@ dbxout_type (type, full)\n \thave_used_extensions = 1;\n       putc (use_gdb_dbx_extensions ? '&' : '*', asmfile);\n       CHARS (1);\n-      dbxout_type (TREE_TYPE (type), 0);\n+      dbxout_type (TREE_TYPE (type), 0, 0);\n       break;\n \n     case FUNCTION_TYPE:\n       putc ('f', asmfile);\n       CHARS (1);\n-      dbxout_type (TREE_TYPE (type), 0);\n+      dbxout_type (TREE_TYPE (type), 0, 0);\n       break;\n \n     default:\n@@ -1355,9 +1311,9 @@ dbxout_symbol (decl, local)\n       current_sym_addr = XEXP (DECL_RTL (decl), 0);\n \n       if (TREE_TYPE (type))\n-\tdbxout_type (TREE_TYPE (type), 0);\n+\tdbxout_type (TREE_TYPE (type), 0, 0);\n       else\n-\tdbxout_type (void_type_node, 0);\n+\tdbxout_type (void_type_node, 0, 0);\n \n       /* For a nested function, when that function is compiled,\n \t mention the containing function name\n@@ -1409,7 +1365,7 @@ dbxout_symbol (decl, local)\n \t  putc ('t', asmfile);\n \t  current_sym_code = DBX_DECL_STABS_CODE;\n \n-\t  dbxout_type (type, 1);\n+\t  dbxout_type (type, 1, 0);\n \t  dbxout_finish_symbol (decl);\n \t}\n       else if (TYPE_NAME (type) != 0 && !TREE_ASM_WRITTEN (TYPE_NAME (type)))\n@@ -1429,7 +1385,7 @@ dbxout_symbol (decl, local)\n \n \t  fprintf (asmfile, \"%s \\\"%s:T\", ASM_STABS_OP,\n \t\t   IDENTIFIER_POINTER (name));\n-\t  dbxout_type (type, 1);\n+\t  dbxout_type (type, 1, 0);\n \t  dbxout_finish_symbol (0);\n \t}\n \n@@ -1673,22 +1629,13 @@ dbxout_symbol (decl, local)\n \t/* Note also that static member (variable) names DO NOT begin\n \t   with underscores in .stabs directives.  */\n \tif (DECL_LANG_SPECIFIC (decl))\n-\t  {\n-\t    name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-\n-#if 0 /* Tiemann says get rid of this.  */\n-\t    /* Adding 1 here only works on systems\n-\t       which flush an initial underscore.  */\n-\t    if (name[0] == '_')\n-\t      name += 1;\n-#endif\n-\t  }\n+\t  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n \telse\n \t  name = IDENTIFIER_POINTER (DECL_NAME (decl));\n \tfprintf (asmfile, \"%s \\\"%s:\", ASM_STABS_OP, name);\n       }\n       if (letter) putc (letter, asmfile);\n-      dbxout_type (type, 0);\n+      dbxout_type (type, 0, 0);\n       dbxout_finish_symbol (decl);\n \n #ifdef DBX_STATIC_BLOCK_END\n@@ -1812,7 +1759,7 @@ dbxout_parms (parms)\n \t    if (GET_CODE (DECL_RTL (parms)) == REG\n \t\t&& REGNO (DECL_RTL (parms)) >= 0\n \t\t&& REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)\n-\t      dbxout_type (DECL_ARG_TYPE (parms), 0);\n+\t      dbxout_type (DECL_ARG_TYPE (parms), 0, 0);\n \t    else\n \t      {\n \t\tint original_value = current_sym_value;\n@@ -1833,11 +1780,11 @@ dbxout_parms (parms)\n \t\t    && GET_CODE (XEXP (DECL_RTL (parms), 0)) == PLUS\n \t\t    && GET_CODE (XEXP (XEXP (DECL_RTL (parms), 0), 1)) == CONST_INT\n \t\t    && INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1)) == current_sym_value)\n-\t\t  dbxout_type (TREE_TYPE (parms), 0);\n+\t\t  dbxout_type (TREE_TYPE (parms), 0, 0);\n \t\telse\n \t\t  {\n \t\t    current_sym_value = original_value;\n-\t\t    dbxout_type (DECL_ARG_TYPE (parms), 0);\n+\t\t    dbxout_type (DECL_ARG_TYPE (parms), 0, 0);\n \t\t  }\n \t      }\n \t    current_sym_value = DEBUGGER_ARG_OFFSET (current_sym_value, addr);\n@@ -1881,7 +1828,7 @@ dbxout_parms (parms)\n \t\t\t regparm_letter);\n \t      }\n \n-\t    dbxout_type (DECL_ARG_TYPE (parms), 0);\n+\t    dbxout_type (DECL_ARG_TYPE (parms), 0, 0);\n \t    dbxout_finish_symbol (parms);\n \t  }\n \telse if (GET_CODE (DECL_RTL (parms)) == MEM\n@@ -1918,7 +1865,7 @@ dbxout_parms (parms)\n \t    current_sym_value\n \t      = DEBUGGER_ARG_OFFSET (current_sym_value,\n \t\t\t\t     XEXP (DECL_RTL (parms), 0));\n-\t    dbxout_type (TREE_TYPE (parms), 0);\n+\t    dbxout_type (TREE_TYPE (parms), 0, 0);\n \t    dbxout_finish_symbol (parms);\n \t  }\n       }\n@@ -1967,7 +1914,7 @@ dbxout_reg_parms (parms)\n \t\tcurrent_sym_nchars = 8;\n \t\tfprintf (asmfile, \"%s \\\"(anon):r\", ASM_STABS_OP);\n \t      }\n-\t    dbxout_type (TREE_TYPE (parms), 0);\n+\t    dbxout_type (TREE_TYPE (parms), 0, 0);\n \t    dbxout_finish_symbol (parms);\n \t  }\n \t/* Report parms that live in memory but not where they were passed.  */\n@@ -2004,7 +1951,7 @@ dbxout_reg_parms (parms)\n \t\tcurrent_sym_nchars = 8;\n \t\tfprintf (asmfile, \"%s \\\"(anon):\", ASM_STABS_OP);\n \t      }\n-\t    dbxout_type (TREE_TYPE (parms), 0);\n+\t    dbxout_type (TREE_TYPE (parms), 0, 0);\n \t    dbxout_finish_symbol (parms);\n \t  }\n       }\n@@ -2020,7 +1967,7 @@ dbxout_args (args)\n   while (args)\n     {\n       putc (',', asmfile);\n-      dbxout_type (TREE_VALUE (args), 0);\n+      dbxout_type (TREE_VALUE (args), 0, 0);\n       CHARS (1);\n       args = TREE_CHAIN (args);\n     }"}]}