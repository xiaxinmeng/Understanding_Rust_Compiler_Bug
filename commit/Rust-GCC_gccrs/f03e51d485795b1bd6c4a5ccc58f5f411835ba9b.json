{"sha": "f03e51d485795b1bd6c4a5ccc58f5f411835ba9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAzZTUxZDQ4NTc5NWIxYmQ2YzRhNWNjYzU4ZjVmNDExODM1YmE5Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-14T11:58:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-14T11:58:23Z"}, "message": "(fill_simple_delay_slots): When trying to take instruction from after the branch, don't continue past target label.\n\n(fill_simple_delay_slots): When trying to take instruction from after\nthe branch, don't continue past target label.  Local variables\npassed_label and target_uses are no longer necessary.\n\nFrom-SVN: r10121", "tree": {"sha": "130c2796878f8b6977ae42e7f8f64828ef8eebfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/130c2796878f8b6977ae42e7f8f64828ef8eebfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f03e51d485795b1bd6c4a5ccc58f5f411835ba9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f03e51d485795b1bd6c4a5ccc58f5f411835ba9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f03e51d485795b1bd6c4a5ccc58f5f411835ba9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f03e51d485795b1bd6c4a5ccc58f5f411835ba9b/comments", "author": null, "committer": null, "parents": [{"sha": "6dd0e0b2f024472e404bc93ca737d8341cbb1fed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd0e0b2f024472e404bc93ca737d8341cbb1fed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dd0e0b2f024472e404bc93ca737d8341cbb1fed"}], "stats": {"total": 48, "additions": 10, "deletions": 38}, "files": [{"sha": "733fe67a98e1f353a934373f8f558194dc4c5728", "filename": "gcc/reorg.c", "status": "modified", "additions": 10, "deletions": 38, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e51d485795b1bd6c4a5ccc58f5f411835ba9b/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e51d485795b1bd6c4a5ccc58f5f411835ba9b/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=f03e51d485795b1bd6c4a5ccc58f5f411835ba9b", "patch": "@@ -2962,14 +2962,12 @@ fill_simple_delay_slots (first, non_jumps_p)\n \t is a CALL_INSN (or a CALL_INSN is passed), cannot trap (because the\n \t call might not return).\n \n-\t If this is a conditional jump, see if it merges back to us early\n-\t enough for us to pick up insns from the merge point.  Don't do\n-\t this if there is another branch to our label unless we pass all of\n-\t them.\n-\n-\t Another similar merge is if we jump to the same place that a\n-\t later unconditional jump branches to.  In that case, we don't\n-\t care about the number of uses of our label.  */\n+\t There used to be code which continued past the target label if\n+\t we saw all uses of the target label.  This code did not work,\n+\t because it failed to account for some instructions which were\n+\t both annulled and marked as from the target.  This can happen as a\n+\t result of optimize_skip.  Since this code was redundant with\n+\t fill_eager_delay_slots anyways, it was just deleted.  */\n \n       if (slots_filled != slots_to_fill\n           && (GET_CODE (insn) != JUMP_INSN\n@@ -2979,8 +2977,6 @@ fill_simple_delay_slots (first, non_jumps_p)\n \t{\n \t  rtx target = 0;\n \t  int maybe_never = 0;\n-\t  int passed_label = 0;\n-\t  int target_uses;\n \t  struct resources needed_at_jump;\n \n \t  CLEAR_RESOURCE (&needed);\n@@ -2997,13 +2993,7 @@ fill_simple_delay_slots (first, non_jumps_p)\n \t      mark_set_resources (insn, &set, 0, 1);\n \t      mark_referenced_resources (insn, &needed, 1);\n \t      if (GET_CODE (insn) == JUMP_INSN)\n-\t\t{\n-\t\t  /* Get our target and show how many more uses we want to\n-\t\t     see before we hit the label.  */\n-\t\t  target = JUMP_LABEL (insn);\n-\t\t  target_uses = LABEL_NUSES (target) - 1;\n-\t\t}\n-\t\t\n+\t\ttarget = JUMP_LABEL (insn);\n \t    }\n \n \t  for (trial = next_nonnote_insn (insn); trial; trial = next_trial)\n@@ -3012,22 +3002,8 @@ fill_simple_delay_slots (first, non_jumps_p)\n \n \t      next_trial = next_nonnote_insn (trial);\n \n-\t      if (GET_CODE (trial) == CODE_LABEL)\n-\t\t{\n-\t\t  passed_label = 1;\n-\n-\t\t  /* If this is our target, see if we have seen all its uses.\n-\t\t     If so, indicate we have passed our target and ignore it.\n-\t\t     All other labels cause us to stop our search.  */\n-\t\t  if (trial == target && target_uses == 0)\n-\t\t    {\n-\t\t      target = 0;\n-\t\t      continue;\n-\t\t    }\n-\t\t  else\n-\t\t    break;\n-\t\t}\n-\t      else if (GET_CODE (trial) == BARRIER)\n+\t      if (GET_CODE (trial) == CODE_LABEL\n+\t\t  || GET_CODE (trial) == BARRIER)\n \t\tbreak;\n \n \t      /* We must have an INSN, JUMP_INSN, or CALL_INSN.  */\n@@ -3052,9 +3028,7 @@ fill_simple_delay_slots (first, non_jumps_p)\n \t\t{\n \t\t  if (target == 0)\n \t\t    break;\n-\t\t  else if (JUMP_LABEL (trial_delay) == target)\n-\t\t    target_uses--;\n-\t\t  else\n+\t\t  else if (JUMP_LABEL (trial_delay) != target)\n \t\t    {\n \t\t      mark_target_live_regs\n \t\t\t(next_active_insn (JUMP_LABEL (trial_delay)),\n@@ -3087,8 +3061,6 @@ fill_simple_delay_slots (first, non_jumps_p)\n \t\t    link_cc0_insns (trial);\n #endif\n \n-\t\t  if (passed_label)\n-\t\t    update_block (trial, trial);\n \t\t  delete_insn (trial);\n \t\t  if (slots_to_fill == ++slots_filled)\n \t\t    break;"}]}