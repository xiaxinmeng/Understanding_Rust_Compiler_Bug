{"sha": "92bf138207e0395910dbfb74740077b150d21f7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJiZjEzODIwN2UwMzk1OTEwZGJmYjc0NzQwMDc3YjE1MGQyMWY3ZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2014-01-10T14:30:21Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-01-10T14:30:21Z"}, "message": "re PR libstdc++/59698 (The type of NULL is described elsewhere)\n\n\tPR libstdc++/59698\n\t* doc/xml/manual/status_cxx1998.xml (iso.1998.specific): Markup\n\tand stylistic improvements.\n\t* doc/xml/manual/codecvt.xml (std.localization.facet.codecvt): Likewise\n\tand update for C++11.\n\t* doc/xml/manual/ctype.xml (std.localization.facet.ctype): Likewise.\n\nFrom-SVN: r206524", "tree": {"sha": "160df75bca49b9537af44dca01f8321a18487814", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/160df75bca49b9537af44dca01f8321a18487814"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92bf138207e0395910dbfb74740077b150d21f7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92bf138207e0395910dbfb74740077b150d21f7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92bf138207e0395910dbfb74740077b150d21f7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92bf138207e0395910dbfb74740077b150d21f7d/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e6667b25b02077d6c0a85dc7a60d3eafb005404", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e6667b25b02077d6c0a85dc7a60d3eafb005404", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e6667b25b02077d6c0a85dc7a60d3eafb005404"}], "stats": {"total": 179, "additions": 102, "deletions": 77}, "files": [{"sha": "847d7b9f9e1cf984a321ea8ee66eec0749c475c4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bf138207e0395910dbfb74740077b150d21f7d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bf138207e0395910dbfb74740077b150d21f7d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=92bf138207e0395910dbfb74740077b150d21f7d", "patch": "@@ -1,3 +1,12 @@\n+2014-01-10  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/59698\n+\t* doc/xml/manual/status_cxx1998.xml (iso.1998.specific): Markup\n+\tand stylistic improvements.\n+\t* doc/xml/manual/codecvt.xml (std.localization.facet.codecvt): Likewise\n+\tand update for C++11.\n+\t* doc/xml/manual/ctype.xml (std.localization.facet.ctype): Likewise.\n+\n 2014-01-09  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/59738"}, {"sha": "76120060e30e0dbb0f0540b4b52b8e7781f80c2f", "filename": "libstdc++-v3/doc/xml/manual/codecvt.xml", "status": "modified", "additions": 64, "deletions": 53, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bf138207e0395910dbfb74740077b150d21f7d/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fcodecvt.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bf138207e0395910dbfb74740077b150d21f7d/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fcodecvt.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fcodecvt.xml?ref=92bf138207e0395910dbfb74740077b150d21f7d", "patch": "@@ -15,11 +15,11 @@\n The standard class codecvt attempts to address conversions between\n different character encoding schemes. In particular, the standard\n attempts to detail conversions between the implementation-defined wide\n-characters (hereafter referred to as wchar_t) and the standard type\n-char that is so beloved in classic <quote>C</quote> (which can now be\n-referred to as narrow characters.)  This document attempts to describe\n-how the GNU libstdc++ implementation deals with the conversion between\n-wide and narrow characters, and also presents a framework for dealing\n+characters (hereafter referred to as <type>wchar_t</type>) and the standard\n+type <type>char</type> that is so beloved in classic <quote>C</quote>\n+(which can now be referred to as narrow characters.)  This document attempts\n+to describe how the GNU libstdc++ implementation deals with the conversion\n+between wide and narrow characters, and also presents a framework for dealing\n with the huge number of other encodings that iconv can convert,\n including Unicode and UTF8. Design issues and requirements are\n addressed, and examples of correct usage for both the required\n@@ -47,8 +47,8 @@ The text around the codecvt definition gives some clues:\n <blockquote>\n <para>\n <emphasis>\n--1- The class codecvt&lt;internT,externT,stateT&gt; is for use when\n-converting from one codeset to another, such as from wide characters\n+-1- The class <code>codecvt&lt;internT,externT,stateT&gt;</code> is for use\n+when converting from one codeset to another, such as from wide characters\n to multibyte characters, between wide character encodings such as\n Unicode and EUC.\n </emphasis>\n@@ -64,7 +64,7 @@ class.\n <blockquote>\n <para>\n <emphasis>\n--2- The stateT argument selects the pair of codesets being mapped between.\n+-2- The <type>stateT</type> argument selects the pair of codesets being mapped between.\n </emphasis>\n </para>\n </blockquote>\n@@ -76,17 +76,19 @@ Ah ha! Another clue...\n <blockquote>\n <para>\n <emphasis>\n--3- The instantiations required in the Table ??\n-(lib.locale.category), namely codecvt&lt;wchar_t,char,mbstate_t&gt; and\n-codecvt&lt;char,char,mbstate_t&gt;, convert the implementation-defined\n-native character set. codecvt&lt;char,char,mbstate_t&gt; implements a\n-degenerate conversion; it does not convert at\n-all. codecvt&lt;wchar_t,char,mbstate_t&gt; converts between the native\n-character sets for tiny and wide characters. Instantiations on\n-mbstate_t perform conversion between encodings known to the library\n+-3- The instantiations required in the Table 51 (lib.locale.category), namely\n+<classname>codecvt&lt;wchar_t,char,mbstate_t&gt;</classname> and\n+<classname>codecvt&lt;char,char,mbstate_t&gt;</classname>, convert the\n+implementation-defined native character set.\n+<classname>codecvt&lt;char,char,mbstate_t&gt;</classname> implements a\n+degenerate conversion; it does not convert at all.\n+<classname>codecvt&lt;wchar_t,char,mbstate_t&gt;</classname> converts between\n+the native character sets for tiny and wide characters. Instantiations on\n+<type>mbstate_t</type> perform conversion between encodings known to the library\n implementor.  Other encodings can be converted by specializing on a\n-user-defined stateT type. The stateT object can contain any state that\n-is useful to communicate to or from the specialized do_convert member.\n+user-defined <type>stateT</type> type. The <type>stateT</type> object can\n+contain any state that is useful to communicate to or from the specialized\n+<function>do_convert</function> member.\n </emphasis>\n </para>\n </blockquote>\n@@ -98,13 +100,14 @@ At this point, a couple points become clear:\n <para>\n One: The standard clearly implies that attempts to add non-required\n (yet useful and widely used) conversions need to do so through the\n-third template parameter, stateT.</para>\n+third template parameter, <type>stateT</type>.</para>\n \n <para>\n-Two: The required conversions, by specifying mbstate_t as the third\n-template parameter, imply an implementation strategy that is mostly\n+Two: The required conversions, by specifying <type>mbstate_t</type> as the\n+third template parameter, imply an implementation strategy that is mostly\n (or wholly) based on the underlying C library, and the functions\n-mcsrtombs and wcsrtombs in particular.</para>\n+<function>mcsrtombs</function> and <function>wcsrtombs</function> in\n+particular.</para>\n </section>\n \n <section xml:id=\"facet.codecvt.design\"><info><title>Design</title></info>\n@@ -114,15 +117,15 @@ mcsrtombs and wcsrtombs in particular.</para>\n     \n \n     <para>\n-      The simple implementation detail of wchar_t's size seems to\n+      The simple implementation detail of <type>wchar_t</type>'s size seems to\n       repeatedly confound people. Many systems use a two byte,\n       unsigned integral type to represent wide characters, and use an\n       internal encoding of Unicode or UCS2. (See AIX, Microsoft NT,\n       Java, others.) Other systems, use a four byte, unsigned integral\n       type to represent wide characters, and use an internal encoding\n       of UCS4. (GNU/Linux systems using glibc, in particular.) The C\n       programming language (and thus C++) does not specify a specific\n-      size for the type wchar_t.\n+      size for the type <type>wchar_t</type>.\n     </para>\n \n     <para>\n@@ -136,9 +139,12 @@ mcsrtombs and wcsrtombs in particular.</para>\n     Probably the most frequently asked question about code conversion\n     is: \"So dudes, what's the deal with Unicode strings?\"\n     The dude part is optional, but apparently the usefulness of\n-    Unicode strings is pretty widely appreciated. Sadly, this specific\n-    encoding (And other useful encodings like UTF8, UCS4, ISO 8859-10,\n-    etc etc etc) are not mentioned in the C++ standard.\n+    Unicode strings is pretty widely appreciated. The Unicode character\n+    set (and useful encodings like UTF-8, UCS-4, ISO 8859-10,\n+    etc etc etc) were not mentioned in the first C++ standard. (The 2011\n+    standard added support for string literals with different encodings\n+    and some library facilities for converting between encodings, but the\n+    notes below have not been updated to reflect that.)\n   </para>\n \n   <para>\n@@ -149,8 +155,8 @@ mcsrtombs and wcsrtombs in particular.</para>\n     The thought that all one needs to convert between two arbitrary\n     codesets is two types and some kind of state argument is\n     unfortunate. In particular, encodings may be stateless. The naming\n-    of the third parameter as stateT is unfortunate, as what is really\n-    needed is some kind of generalized type that accounts for the\n+    of the third parameter as <type>stateT</type> is unfortunate, as what is\n+    really needed is some kind of generalized type that accounts for the\n     issues that abstract encodings will need. The minimum information\n     that is required includes:\n   </para>\n@@ -240,7 +246,8 @@ mechanism may be required.\n <para>\n In addition, multi-threaded and multi-locale environments also impact\n the design and requirements for code conversions. In particular, they\n-affect the required specialization codecvt&lt;wchar_t, char, mbstate_t&gt;\n+affect the required specialization\n+<classname>codecvt&lt;wchar_t, char, mbstate_t&gt;</classname>\n when implemented using standard \"C\" functions.\n </para>\n \n@@ -249,7 +256,8 @@ Three problems arise, one big, one of medium importance, and one small.\n </para>\n \n <para>\n-First, the small: mcsrtombs and wcsrtombs may not be multithread-safe\n+First, the small: <function>mcsrtombs</function> and\n+<function>wcsrtombs</function> may not be multithread-safe\n on all systems required by the GNU tools. For GNU/Linux and glibc,\n this is not an issue.\n </para>\n@@ -275,7 +283,8 @@ option, a high-quality implementation, damn the additional complexity!\n </para>\n \n <para>\n-For the required specialization codecvt&lt;wchar_t, char, mbstate_t&gt; ,\n+For the required specialization\n+<classname>codecvt&lt;wchar_t, char, mbstate_t&gt;</classname>,\n conversions are made between the internal character set (always UCS4\n on GNU/Linux) and whatever the currently selected locale for the\n LC_CTYPE category implements.\n@@ -311,37 +320,39 @@ codecvt&lt;char, wchar_t, mbstate_t&gt;\n <para>\n This specialization, by specifying all the template parameters, pretty\n much ties the hands of implementors. As such, the implementation is\n-straightforward, involving mcsrtombs for the conversions between char\n-to wchar_t and wcsrtombs for conversions between wchar_t and char.\n+straightforward, involving <function>mcsrtombs</function> for the conversions\n+between <type>char</type> to <type>wchar_t</type> and\n+<function>wcsrtombs</function> for conversions between <type>wchar_t</type>\n+and <type>char</type>.\n </para>\n \n <para>\n Neither of these two required specializations deals with Unicode\n characters. As such, libstdc++ implements a partial specialization\n-of the codecvt class with and iconv wrapper class, encoding_state as the\n-third template parameter.\n+of the <type>codecvt</type> class with an iconv wrapper class,\n+<classname>encoding_state</classname> as the third template parameter.\n </para>\n \n <para>\n This implementation should be standards conformant. First of all, the\n standard explicitly points out that instantiations on the third\n-template parameter, stateT, are the proper way to implement\n+template parameter, <type>stateT</type>, are the proper way to implement\n non-required conversions. Second of all, the standard says (in Chapter\n-17) that partial specializations of required classes are a-ok. Third\n-of all, the requirements for the stateT type elsewhere in the standard\n-(see 21.1.2 traits typedefs) only indicate that this type be copy\n+17) that partial specializations of required classes are A-OK. Third\n+of all, the requirements for the <type>stateT</type> type elsewhere in the\n+standard (see 21.1.2 traits typedefs) only indicate that this type be copy\n constructible.\n </para>\n \n <para>\n-As such, the type encoding_state is defined as a non-templatized, POD\n-type to be used as the third type of a codecvt instantiation. This\n-type is just a wrapper class for iconv, and provides an easy interface\n+As such, the type <type>encoding_state</type> is defined as a non-templatized,\n+POD type to be used as the third type of a <type>codecvt</type> instantiation.\n+This type is just a wrapper class for iconv, and provides an easy interface\n to iconv functionality.\n </para>\n \n <para>\n-There are two constructors for encoding_state:\n+There are two constructors for <type>encoding_state</type>:\n </para>\n \n <para>\n@@ -352,7 +363,7 @@ encoding_state() : __in_desc(0), __out_desc(0)\n <para>\n This default constructor sets the internal encoding to some default\n (currently UCS4) and the external encoding to whatever is returned by\n-nl_langinfo(CODESET).\n+<code>nl_langinfo(CODESET)</code>.\n </para>\n \n <para>\n@@ -370,7 +381,7 @@ either argument.\n <para>\n One of the issues with iconv is that the string literals identifying\n conversions are not standardized. Because of this, the thought of\n-mandating and or enforcing some set of pre-determined valid\n+mandating and/or enforcing some set of pre-determined valid\n identifiers seems iffy: thus, a more practical (and non-migraine\n inducing) strategy was implemented: end-users can specify any string\n (subject to a pre-determined length qualifier, currently 32 bytes) for\n@@ -400,12 +411,12 @@ _M_good()\n </para>\n \n <para>\n-Provides a way to see if the given encoding_state object has been\n+Provides a way to see if the given <type>encoding_state</type> object has been\n properly initialized. If the string literals describing the desired\n internal and external encoding are not valid, initialization will\n fail, and this will return false. If the internal and external\n-encodings are valid, but iconv_open could not allocate conversion\n-descriptors, this will also return false. Otherwise, the object is\n+encodings are valid, but <function>iconv_open</function> could not allocate\n+conversion descriptors, this will also return false. Otherwise, the object is\n ready to convert and will return true.\n </para>\n \n@@ -424,16 +435,16 @@ themselves.\n \n <para>\n Definitions for all the required codecvt member functions are provided\n-for this specialization, and usage of codecvt&lt;internal character type,\n-external character type, encoding_state&gt; is consistent with other\n+for this specialization, and usage of <code>codecvt&lt;<replaceable>internal\n+character type</replaceable>, <replaceable>external character type</replaceable>, <replaceable>encoding_state</replaceable>&gt;</code> is consistent with other\n codecvt usage.\n </para>\n \n </section>\n \n <section xml:id=\"facet.codecvt.use\"><info><title>Use</title></info>\n \n-<para>A conversions involving string literal.</para>\n+<para>A conversion involving a string literal.</para>\n \n <programlisting>\n   typedef codecvt_base::result                  result;\n@@ -490,7 +501,7 @@ codecvt usage.\n \n <listitem>\n   <para>\n-   b. conversions involving std::string\n+   b. conversions involving <type>std::string</type>\n   </para>\n    <itemizedlist>\n       <listitem><para>"}, {"sha": "4e9777d78466831b2b3413d60820c579723aa9cb", "filename": "libstdc++-v3/doc/xml/manual/ctype.xml", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bf138207e0395910dbfb74740077b150d21f7d/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fctype.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bf138207e0395910dbfb74740077b150d21f7d/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fctype.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fctype.xml?ref=92bf138207e0395910dbfb74740077b150d21f7d", "patch": "@@ -18,10 +18,10 @@\n     \n \n <para>\n-For the required specialization codecvt&lt;wchar_t, char, mbstate_t&gt; ,\n+For the required specialization <classname>codecvt&lt;wchar_t, char, mbstate_t&gt;</classname>,\n conversions are made between the internal character set (always UCS4\n on GNU/Linux) and whatever the currently selected locale for the\n-LC_CTYPE category implements.\n+<code>LC_CTYPE</code> category implements.\n </para>\n \n <para>\n@@ -45,8 +45,10 @@ ctype&lt;wchar_t&gt;\n <para>\n This specialization, by specifying all the template parameters, pretty\n much ties the hands of implementors. As such, the implementation is\n-straightforward, involving mcsrtombs for the conversions between char\n-to wchar_t and wcsrtombs for conversions between wchar_t and char.\n+straightforward, involving <function>mcsrtombs</function> for the\n+conversions between <type>char</type> to <type>wchar_t</type> and\n+<function>wcsrtombs</function> for conversions between <type>wchar_t</type>\n+and <type>char</type>.\n </para>\n \n <para>\n@@ -69,16 +71,17 @@ characters.\n \n    <listitem>\n    <para>\n-   How to deal with different types than char, wchar_t? </para></listitem>\n+   How to deal with types other than <type>char</type>, <type>wchar_t</type>?\n+   </para></listitem>\n \n    <listitem><para>\n    Overlap between codecvt/ctype: narrow/widen\n    </para></listitem>\n \n    <listitem>\n      <para>\n-       Mask typedef in codecvt_base, argument types in codecvt.  what\n-       is know about this type?\n+       <type>mask</type> typedef in <classname>codecvt_base</classname>,\n+       argument types in <type>codecvt</type>.  what is know about this type?\n    </para></listitem>\n \n    <listitem>\n@@ -95,10 +98,11 @@ characters.\n \n    <listitem>\n      <para>\n-       Get the ctype&lt;wchar_t&gt;::mask stuff under control. Need to\n-       make some kind of static table, and not do lookup every time\n-       somebody hits the do_is... functions. Too bad we can't just\n-       redefine mask for ctype&lt;wchar_t&gt;\n+       Get the <type>ctype&lt;wchar_t&gt;::mask</type> stuff under control.\n+       Need to make some kind of static table, and not do lookup every time\n+       somebody hits the <code>do_is...</code> functions. Too bad we can't\n+       just redefine <type>mask</type> for\n+       <classname>ctype&lt;wchar_t&gt;</classname>\n    </para></listitem>\n \n    <listitem>"}, {"sha": "3bc6a16722b346f4918ad91d927866707afbb366", "filename": "libstdc++-v3/doc/xml/manual/status_cxx1998.xml", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bf138207e0395910dbfb74740077b150d21f7d/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx1998.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bf138207e0395910dbfb74740077b150d21f7d/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx1998.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx1998.xml?ref=92bf138207e0395910dbfb74740077b150d21f7d", "patch": "@@ -1075,7 +1075,7 @@ particular release.\n \tin the sections where the function itself occurs.\n    -->\n    <para><emphasis>[18.1]/4</emphasis> The type of <code>NULL</code> is described\n-      <link linkend=\"std.support.types.null\">here</link>.\n+      under <link linkend=\"std.support.types.null\">Support</link>.\n    </para>\n    <para><emphasis>[18.3]/8</emphasis> Even though it's listed in the library\n       sections, libstdc++ has zero control over what the cleanup code hands\n@@ -1107,9 +1107,10 @@ particular release.\n       implementations, any requirements imposed on allocators by containers\n       beyond those requirements that appear in Table 32, and the semantics\n       of containers and algorithms when allocator instances compare\n-      non-equal, are implementation-defined.\"</emphasis>  As yet we don't\n-      have any allocators which compare non-equal, so we can't describe how\n-      they behave.\n+      non-equal, are implementation-defined.\"</emphasis>  There is experimental\n+      support for non-equal allocators in the standard containers in C++98\n+      mode. There are no additional requirements on allocators. It is undefined\n+      behaviour to swap two containers if their allocators are not equal.\n    </para>\n    <para><emphasis>[21.1.3.1]/3,4</emphasis>,\n       <emphasis>[21.1.3.2]/2</emphasis>,\n@@ -1121,25 +1122,25 @@ particular release.\n       here would defeat the purpose.  :-)\n    </para>\n    <para><emphasis>[21.1.3.1]/5</emphasis> I don't really know about\n-      the mbstate_t stuff... see\n-      the <link linkend=\"std.localization.facet.codecvt\">chapter 22\n+      the <type>mbstate_t</type> stuff... see\n+      the <link linkend=\"std.localization.facet.codecvt\"><code>codecvt</code>\n       notes</link> for what does exist.\n    </para>\n    <para><emphasis>[22.*]</emphasis> Anything and everything we have on locale\n-      implementation will be described\n-      <link linkend=\"std.localization.locales.locale\">over here</link>.\n+      implementation will be described under\n+      <link linkend=\"std.localization.locales.locale\">Localization</link>.\n    </para>\n    <para><emphasis>[26.2.8]/9</emphasis> I have no idea what\n-      <code>complex&lt;T&gt;</code>'s pow(0,0) returns.\n+      <code>complex&lt;T&gt;</code>'s <code>pow(0,0)</code> returns.\n    </para>\n    <para><emphasis>[27.4.2.4]/2</emphasis> Calling\n       <code>std::ios_base::sync_with_stdio</code> after I/O has already been\n       performed on the standard stream objects will\n       flush the buffers, and <!-- this line might go away -->\n       destroy and recreate the underlying buffer instances.  Whether or not\n       the previously-written I/O is destroyed in this process depends mostly\n-      on the --enable-libio choice:  for stdio, if the written data is\n-      already in the stdio buffer, the data may be completely safe!\n+      on the <code>--enable-libio</code> choice:  for stdio, if the written\n+      data is already in the stdio buffer, the data may be completely safe!\n    </para>\n    <para><emphasis>[27.6.1.1.2]</emphasis>,\n       <emphasis>[27.6.2.3]</emphasis> The I/O sentry ctor and dtor can perform\n@@ -1148,8 +1149,8 @@ particular release.\n    </para>\n    <para><emphasis>[27.7.1.3]/16</emphasis>,\n       <emphasis>[27.8.1.4]/10</emphasis>\n-      The effects of <code>pubsetbuf/setbuf</code> are described\n-      <link linkend=\"std.io\">in this chapter</link>.\n+      The effects of <code>pubsetbuf/setbuf</code> are described in the\n+      <link linkend=\"std.io\">Input and Output</link> chapter.\n    </para>\n    <para><emphasis>[27.8.1.4]/16</emphasis> Calling <code>fstream::sync</code> when\n       a get area exists will... whatever <code>fflush()</code> does, I think."}]}