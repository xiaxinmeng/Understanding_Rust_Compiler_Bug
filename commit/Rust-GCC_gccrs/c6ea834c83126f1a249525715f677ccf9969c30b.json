{"sha": "c6ea834c83126f1a249525715f677ccf9969c30b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZlYTgzNGM4MzEyNmYxYTI0OTUyNTcxNWY2NzdjY2Y5OTY5YzMwYg==", "commit": {"author": {"name": "Bingfeng Mei", "email": "bmei@broadcom.com", "date": "2010-08-09T14:44:03Z"}, "committer": {"name": "Bingfeng Mei", "email": "meibf@gcc.gnu.org", "date": "2010-08-09T14:44:03Z"}, "message": "ddg.c (walk_mems_2): Moved from alias.c, use may_alias_p instead of alias_sets_conflict_p.\n\n2010-08-09  Bingfeng Mei  <bmei@broadcom.com>\n\n\t* ddg.c (walk_mems_2): Moved from alias.c, use may_alias_p instead of\n\talias_sets_conflict_p.\n\t(walk_mems_1): Moved from alias.c.\n\t(insns_may_alias_p): New function, originally insn_alias_sets_conflict_p\n\tin alias.c. \n        (add_inter_loop_mem_dep): Use insns_may_alias_p now.\n        * cse.c (cse_insn): New argument in calling nonoverlapping_memrefs_p.\n        * alias.c (walk_mems_2): Moved to ddg.c.\n\t(walk_mems_1): Ditto.\n\t(insn_alias_sets_conflict_p): Renamed to insns_may_alias_p and moved\n\tto ddg.c.\n\t(nonoverlapping_memrefs_p): Add flag to guard offset-based memory\n\tdisambiguation.\n\t*(may_alias_p): New function to check whether two memory expression\n\tmay alias or not. Currently used in buidling inter-iteration memory\n\tdependence.\n\t*alias.h (nonoverlapping_memrefs_p): New flag as third argument.\n\t(insn_alias_sets_conflict_p): Removed\n\t*rtl.h (may_alias_p): New function prototype.\n\nFrom-SVN: r163037", "tree": {"sha": "e1019cb9c50fe10a946e21114e247d48c6ccc78a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1019cb9c50fe10a946e21114e247d48c6ccc78a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6ea834c83126f1a249525715f677ccf9969c30b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6ea834c83126f1a249525715f677ccf9969c30b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6ea834c83126f1a249525715f677ccf9969c30b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6ea834c83126f1a249525715f677ccf9969c30b/comments", "author": null, "committer": null, "parents": [{"sha": "72ac05b04e2baf2ff9eebd42e6ff5f22fd3b1546", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72ac05b04e2baf2ff9eebd42e6ff5f22fd3b1546", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72ac05b04e2baf2ff9eebd42e6ff5f22fd3b1546"}], "stats": {"total": 187, "additions": 142, "deletions": 45}, "files": [{"sha": "ddae0798b46a48d9e7e295d6a6d9f1965b210357", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6ea834c83126f1a249525715f677ccf9969c30b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6ea834c83126f1a249525715f677ccf9969c30b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6ea834c83126f1a249525715f677ccf9969c30b", "patch": "@@ -1,3 +1,25 @@\n+2010-08-09  Bingfeng Mei  <bmei@broadcom.com>\n+\n+\t* ddg.c (walk_mems_2): Moved from alias.c, use may_alias_p instead of\n+\talias_sets_conflict_p.\n+\t(walk_mems_1): Moved from alias.c.\n+\t(insns_may_alias_p): New function, originally insn_alias_sets_conflict_p\n+\tin alias.c. \n+        (add_inter_loop_mem_dep): Use insns_may_alias_p now.\n+        * cse.c (cse_insn): New argument in calling nonoverlapping_memrefs_p.\n+        * alias.c (walk_mems_2): Moved to ddg.c.\n+\t(walk_mems_1): Ditto.\n+\t(insn_alias_sets_conflict_p): Renamed to insns_may_alias_p and moved\n+\tto ddg.c.\n+\t(nonoverlapping_memrefs_p): Add flag to guard offset-based memory\n+\tdisambiguation.\n+\t*(may_alias_p): New function to check whether two memory expression\n+\tmay alias or not. Currently used in buidling inter-iteration memory\n+\tdependence.\n+\t*alias.h (nonoverlapping_memrefs_p): New flag as third argument.\n+\t(insn_alias_sets_conflict_p): Removed\n+\t*rtl.h (may_alias_p): New function prototype.\n+        \n 2010-08-09  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* tree.c (nreverse): Assert that we don't have a BLOCK."}, {"sha": "3f5f47a009a3861918f096d9d5c8bc400f3dfb0c", "filename": "gcc/alias.c", "status": "modified", "additions": 79, "deletions": 41, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6ea834c83126f1a249525715f677ccf9969c30b/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6ea834c83126f1a249525715f677ccf9969c30b/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=c6ea834c83126f1a249525715f677ccf9969c30b", "patch": "@@ -452,43 +452,6 @@ alias_sets_conflict_p (alias_set_type set1, alias_set_type set2)\n   return 0;\n }\n \n-static int\n-walk_mems_2 (rtx *x, rtx mem)\n-{\n-  if (MEM_P (*x))\n-    {\n-      if (alias_sets_conflict_p (MEM_ALIAS_SET(*x), MEM_ALIAS_SET(mem)))\n-        return 1;\n-\n-      return -1;\n-    }\n-  return 0;\n-}\n-\n-static int\n-walk_mems_1 (rtx *x, rtx *pat)\n-{\n-  if (MEM_P (*x))\n-    {\n-      /* Visit all MEMs in *PAT and check indepedence.  */\n-      if (for_each_rtx (pat, (rtx_function) walk_mems_2, *x))\n-        /* Indicate that dependence was determined and stop traversal.  */\n-        return 1;\n-\n-      return -1;\n-    }\n-  return 0;\n-}\n-\n-/* Return 1 if two specified instructions have mem expr with conflict alias sets*/\n-bool\n-insn_alias_sets_conflict_p (rtx insn1, rtx insn2)\n-{\n-  /* For each pair of MEMs in INSN1 and INSN2 check their independence.  */\n-  return  for_each_rtx (&PATTERN (insn1), (rtx_function) walk_mems_1,\n-\t\t\t &PATTERN (insn2));\n-}\n-\n /* Return 1 if the two specified alias sets will always conflict.  */\n \n int\n@@ -2187,10 +2150,11 @@ adjust_offset_for_component_ref (tree x, rtx offset)\n }\n \n /* Return nonzero if we can determine the exprs corresponding to memrefs\n-   X and Y and they do not overlap.  */\n+   X and Y and they do not overlap. \n+   If LOOP_VARIANT is set, skip offset-based disambiguation */\n \n int\n-nonoverlapping_memrefs_p (const_rtx x, const_rtx y)\n+nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n {\n   tree exprx = MEM_EXPR (x), expry = MEM_EXPR (y);\n   rtx rtlx, rtly;\n@@ -2287,6 +2251,10 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y)\n \t    || (CONSTANT_P (basey) && REG_P (basex)\n \t\t&& REGNO_PTR_FRAME_P (REGNO (basex))));\n \n+  /* Offset based disambiguation not appropriate for loop invariant */\n+  if (loop_invariant)\n+    return 0;              \n+\n   sizex = (!MEM_P (rtlx) ? (int) GET_MODE_SIZE (GET_MODE (rtlx))\n \t   : MEM_SIZE (rtlx) ? INTVAL (MEM_SIZE (rtlx))\n \t   : -1);\n@@ -2413,7 +2381,7 @@ true_dependence_1 (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n   if (DIFFERENT_ALIAS_SETS_P (x, mem))\n     return 0;\n \n-  if (nonoverlapping_memrefs_p (mem, x))\n+  if (nonoverlapping_memrefs_p (mem, x, false))\n     return 0;\n \n   if (aliases_everything_p (x))\n@@ -2528,7 +2496,7 @@ write_dependence_p (const_rtx mem, const_rtx x, int writep)\n \t\t\t\t SIZE_FOR_MODE (x), x_addr, 0)) != -1)\n     return ret;\n \n-  if (nonoverlapping_memrefs_p (x, mem))\n+  if (nonoverlapping_memrefs_p (x, mem, false))\n     return 0;\n \n   fixed_scalar\n@@ -2559,6 +2527,76 @@ output_dependence (const_rtx mem, const_rtx x)\n }\n \f\n \n+\n+/* Check whether X may be aliased with MEM.  Don't do offset-based\n+  memory disambiguation & TBAA.  */\n+int\n+may_alias_p (const_rtx mem, const_rtx x)\n+{\n+  rtx x_addr, mem_addr;\n+  int ret;\n+\n+  if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n+    return 1;\n+\n+  /* ??? In true_dependence we also allow BLKmode to alias anything. */\n+  if (GET_MODE (mem) == BLKmode || GET_MODE (x) == BLKmode)\n+    return 1;\n+    \n+  if (MEM_ALIAS_SET (x) == ALIAS_SET_MEMORY_BARRIER\n+      || MEM_ALIAS_SET (mem) == ALIAS_SET_MEMORY_BARRIER)\n+    return 1;\n+\n+  /* Read-only memory is by definition never modified, and therefore can't\n+     conflict with anything.  We don't expect to find read-only set on MEM,\n+     but stupid user tricks can produce them, so don't die.  */\n+  if (MEM_READONLY_P (x))\n+    return 0;\n+\n+  /* If we have MEMs refering to different address spaces (which can\n+     potentially overlap), we cannot easily tell from the addresses\n+     whether the references overlap.  */\n+  if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))\n+    return 1;\n+\n+  x_addr = XEXP (x, 0);\n+  mem_addr = XEXP (mem, 0);\n+  if (!((GET_CODE (x_addr) == VALUE\n+\t && GET_CODE (mem_addr) != VALUE\n+\t && reg_mentioned_p (x_addr, mem_addr))\n+\t|| (GET_CODE (x_addr) != VALUE\n+\t    && GET_CODE (mem_addr) == VALUE\n+\t    && reg_mentioned_p (mem_addr, x_addr))))\n+    {\n+      x_addr = get_addr (x_addr);\n+      mem_addr = get_addr (mem_addr);\n+    }\n+\n+  if (! base_alias_check (x_addr, mem_addr, GET_MODE (x), GET_MODE (mem_addr)))\n+    return 0;\n+\n+  x_addr = canon_rtx (x_addr);\n+  mem_addr = canon_rtx (mem_addr);\n+\n+  if (nonoverlapping_memrefs_p (mem, x, true))\n+    return 0;\n+\n+  if (aliases_everything_p (x))\n+    return 1;\n+\n+  /* We cannot use aliases_everything_p to test MEM, since we must look\n+     at MEM_ADDR, rather than XEXP (mem, 0).  */\n+  if (GET_MODE (mem) == QImode || GET_CODE (mem_addr) == AND)\n+    return 1;\n+\n+  if (fixed_scalar_and_varying_struct_p (mem, x, mem_addr, x_addr,\n+                                         rtx_addr_varies_p))\n+    return 0;\n+\n+  /* TBAA not valid for loop_invarint */\n+  return rtx_refs_may_alias_p (x, mem, false);\n+}\n+\n void\n init_alias_target (void)\n {"}, {"sha": "58945524e9ac1f0480bf2513ec321deb444b9b85", "filename": "gcc/alias.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6ea834c83126f1a249525715f677ccf9969c30b/gcc%2Falias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6ea834c83126f1a249525715f677ccf9969c30b/gcc%2Falias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.h?ref=c6ea834c83126f1a249525715f677ccf9969c30b", "patch": "@@ -42,8 +42,7 @@ extern void record_component_aliases (tree);\n extern int alias_sets_conflict_p (alias_set_type, alias_set_type);\n extern int alias_sets_must_conflict_p (alias_set_type, alias_set_type);\n extern int objects_must_conflict_p (tree, tree);\n-extern int nonoverlapping_memrefs_p (const_rtx, const_rtx);\n-extern bool insn_alias_sets_conflict_p (rtx, rtx);\n+extern int nonoverlapping_memrefs_p (const_rtx, const_rtx, bool);\n \n /* This alias set can be used to force a memory to conflict with all\n    other memories, creating a barrier across which no memory reference"}, {"sha": "dcba6bc3bb35cf4f56b51bf3f2432239c65fe695", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6ea834c83126f1a249525715f677ccf9969c30b/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6ea834c83126f1a249525715f677ccf9969c30b/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=c6ea834c83126f1a249525715f677ccf9969c30b", "patch": "@@ -5015,7 +5015,7 @@ cse_insn (rtx insn)\n \t      dest = canon_rtx (SET_DEST (sets[i].rtl));\n \n \t      if (!MEM_P (src) || !MEM_P (dest)\n-\t\t  || !nonoverlapping_memrefs_p (src, dest))\n+\t\t  || !nonoverlapping_memrefs_p (src, dest, false))\n \t\tbreak;\n \t    }\n "}, {"sha": "88aaf9bb2e4e92c9f456831bfda68f7a21e9e46b", "filename": "gcc/ddg.c", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6ea834c83126f1a249525715f677ccf9969c30b/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6ea834c83126f1a249525715f677ccf9969c30b/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=c6ea834c83126f1a249525715f677ccf9969c30b", "patch": "@@ -348,12 +348,49 @@ build_inter_loop_deps (ddg_ptr g)\n }\n \n \n+static int\n+walk_mems_2 (rtx *x, rtx mem)\n+{\n+  if (MEM_P (*x))\n+    {\n+      if (may_alias_p (*x, mem))\n+        return 1;\n+\n+      return -1;\n+    }\n+  return 0;\n+}\n+\n+static int\n+walk_mems_1 (rtx *x, rtx *pat)\n+{\n+  if (MEM_P (*x))\n+    {\n+      /* Visit all MEMs in *PAT and check indepedence.  */\n+      if (for_each_rtx (pat, (rtx_function) walk_mems_2, *x))\n+        /* Indicate that dependence was determined and stop traversal.  */\n+        return 1;\n+\n+      return -1;\n+    }\n+  return 0;\n+}\n+\n+/* Return 1 if two specified instructions have mem expr with conflict alias sets*/\n+static int\n+insns_may_alias_p (rtx insn1, rtx insn2)\n+{\n+  /* For each pair of MEMs in INSN1 and INSN2 check their independence.  */\n+  return  for_each_rtx (&PATTERN (insn1), (rtx_function) walk_mems_1,\n+\t\t\t &PATTERN (insn2));\n+}\n+\n /* Given two nodes, analyze their RTL insns and add inter-loop mem deps\n    to ddg G.  */\n static void\n add_inter_loop_mem_dep (ddg_ptr g, ddg_node_ptr from, ddg_node_ptr to)\n {\n-  if (!insn_alias_sets_conflict_p (from->insn, to->insn))\n+  if (!insns_may_alias_p (from->insn, to->insn))\n     /* Do not create edge if memory references have disjoint alias sets.  */\n     return;\n "}, {"sha": "bb873584057492b7e7e25a610dd15ea70b655ad6", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6ea834c83126f1a249525715f677ccf9969c30b/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6ea834c83126f1a249525715f677ccf9969c30b/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=c6ea834c83126f1a249525715f677ccf9969c30b", "patch": "@@ -2424,6 +2424,7 @@ extern int canon_true_dependence (const_rtx, enum machine_mode, rtx, const_rtx,\n extern int read_dependence (const_rtx, const_rtx);\n extern int anti_dependence (const_rtx, const_rtx);\n extern int output_dependence (const_rtx, const_rtx);\n+extern int may_alias_p (const_rtx, const_rtx);\n extern void init_alias_target (void);\n extern void init_alias_analysis (void);\n extern void end_alias_analysis (void);"}]}