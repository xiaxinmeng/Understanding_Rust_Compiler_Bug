{"sha": "c011e2ad8adc191c6c38089cf05ae9f3daaf5a08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAxMWUyYWQ4YWRjMTkxYzZjMzgwODljZjA1YWU5ZjNkYWFmNWEwOA==", "commit": {"author": {"name": "Branko Cibej", "email": "branko.cibej@hermes.si", "date": "2000-06-29T21:07:04Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-06-29T21:07:04Z"}, "message": "std_memory.h (auto_ptr_ref): Reworked and defined only if _GLIBCPP_RESOLVE_LIB_DEFECTS.\n\n\n2000-06-29  Branko Cibej  <branko.cibej@hermes.si>\n\n        * bits/std_memory.h (auto_ptr_ref): Reworked and defined only if\n        _GLIBCPP_RESOLVE_LIB_DEFECTS.\n        (auto_ptr): _M_ptr changed to void*.\n        (suto_ptr::get): Cast _M_ptr to element type.\n        (auto_ptr::auto_ptr(auto_ptr<Tp1>)): Test implicit convetsion.\n        (auto_ptr::~auto_ptr): Use this->get() instead of _M_ptr.\n        (auto_ptr::operator*): Likewise.\n        (auto_ptr::operator->): Likewise.\n        (auto_ptr::release): Likewise.\n        (auto_ptr::reset): Likewise.\n        (auto_ptr::auto_ptr(auto_ptr_ref)): Initialize from __ref._M_release.\n        (auto_ptr::operator auto_ptr_rev<_Tp1>): Updated.\n        Define nested auto_ptr_ref unless _GLIBCPP_RESOLVE_LIB_DEFECTS.\n        Define operator=(auto_ptr_ref) if _GLIBCPP_RESOLVE_LIB_DEFECTS.\n\nFrom-SVN: r34792", "tree": {"sha": "52fa0cbca10dc902dd94856e2761fd6ad182347d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52fa0cbca10dc902dd94856e2761fd6ad182347d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c011e2ad8adc191c6c38089cf05ae9f3daaf5a08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c011e2ad8adc191c6c38089cf05ae9f3daaf5a08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c011e2ad8adc191c6c38089cf05ae9f3daaf5a08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c011e2ad8adc191c6c38089cf05ae9f3daaf5a08/comments", "author": null, "committer": null, "parents": [{"sha": "d1e43c8bf095960b34fc36a18150b81c300f05ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e43c8bf095960b34fc36a18150b81c300f05ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1e43c8bf095960b34fc36a18150b81c300f05ce"}], "stats": {"total": 101, "additions": 74, "deletions": 27}, "files": [{"sha": "4e2454cf89083e9976217a475fefb1f285e95500", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c011e2ad8adc191c6c38089cf05ae9f3daaf5a08/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c011e2ad8adc191c6c38089cf05ae9f3daaf5a08/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c011e2ad8adc191c6c38089cf05ae9f3daaf5a08", "patch": "@@ -1,3 +1,26 @@\n+2000-06-29    <bkoz@purist.soma.redhat.com>\n+\n+\t* bits/char_traits.h (char_traits::eos): Non standard member\n+\tfunction, uglify to __eos. Return char_type().\n+\t* bits/std_ostream.h: Change.\n+\t\n+2000-06-29  Branko Cibej  <branko.cibej@hermes.si>\n+\n+        * bits/std_memory.h (auto_ptr_ref): Reworked and defined only if\n+        _GLIBCPP_RESOLVE_LIB_DEFECTS.\n+        (auto_ptr): _M_ptr changed to void*.\n+        (suto_ptr::get): Cast _M_ptr to element type.\n+        (auto_ptr::auto_ptr(auto_ptr<Tp1>)): Test implicit convetsion.\n+        (auto_ptr::~auto_ptr): Use this->get() instead of _M_ptr.\n+        (auto_ptr::operator*): Likewise.\n+        (auto_ptr::operator->): Likewise.\n+        (auto_ptr::release): Likewise.\n+        (auto_ptr::reset): Likewise.\n+        (auto_ptr::auto_ptr(auto_ptr_ref)): Initialize from __ref._M_release.\n+        (auto_ptr::operator auto_ptr_rev<_Tp1>): Updated.\n+        Define nested auto_ptr_ref unless _GLIBCPP_RESOLVE_LIB_DEFECTS.\n+        Define operator=(auto_ptr_ref) if _GLIBCPP_RESOLVE_LIB_DEFECTS.\n+\n 2000-06-28  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n \n \t* testsuite/27_io/filebuf.cc: Tweak."}, {"sha": "e31634d31fcb2750b5598deb79ea7e9569562441", "filename": "libstdc++-v3/bits/std_memory.h", "status": "modified", "additions": 51, "deletions": 27, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c011e2ad8adc191c6c38089cf05ae9f3daaf5a08/libstdc%2B%2B-v3%2Fbits%2Fstd_memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c011e2ad8adc191c6c38089cf05ae9f3daaf5a08/libstdc%2B%2B-v3%2Fbits%2Fstd_memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_memory.h?ref=c011e2ad8adc191c6c38089cf05ae9f3daaf5a08", "patch": "@@ -25,19 +25,28 @@\n \n __STL_BEGIN_NAMESPACE\n \n-#if defined(__SGI_STL_USE_AUTO_PTR_CONVERSIONS) && \\\n-     defined(__STL_MEMBER_TEMPLATES)\n- \n- template<class _Tp1> struct auto_ptr_ref {\n-   _Tp1* _M_ptr;\n-   auto_ptr_ref(_Tp1* __p) : _M_ptr(__p) {}\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+# if defined(__SGI_STL_USE_AUTO_PTR_CONVERSIONS) && \\\n+       defined(__STL_MEMBER_TEMPLATES)\n+\n+template<typename _Tp> class auto_ptr_ref {\n+  template<typename _Tp1> friend class auto_ptr;\n+  _Tp* _M_ptr;\n+  void*& _M_ptr_ref;\n+  explicit auto_ptr_ref(_Tp* __p, void*& __r) __STL_NOTHROW\n+    : _M_ptr(__p), _M_ptr_ref(__r) {}\n+  _Tp* _M_release() const __STL_NOTHROW {\n+    _M_ptr_ref = 0;\n+    return _M_ptr;\n+  }\n };\n \n-#endif\n+# endif /* auto ptr conversions && member templates */\n+#endif /* _GLIBCPP_RESOLVE_LIB_DEFECTS */\n \n template <class _Tp> class auto_ptr {\n private:\n-  _Tp* _M_ptr;\n+  void* _M_ptr;\n \n public:\n   typedef _Tp element_type;\n@@ -46,8 +55,10 @@ template <class _Tp> class auto_ptr {\n   auto_ptr(auto_ptr& __a) __STL_NOTHROW : _M_ptr(__a.release()) {}\n \n #ifdef __STL_MEMBER_TEMPLATES\n-  template <class _Tp1> auto_ptr(auto_ptr<_Tp1>& __a) __STL_NOTHROW\n-    : _M_ptr(__a.release()) {}\n+  template <class _Tp1> auto_ptr(auto_ptr<_Tp1>& __a) __STL_NOTHROW {\n+    _Tp* const __tmp = __a.release(); // Must have implicit conversion\n+    _M_ptr = __tmp;\n+  }\n #endif /* __STL_MEMBER_TEMPLATES */\n \n   auto_ptr& operator=(auto_ptr& __a) __STL_NOTHROW {\n@@ -67,23 +78,24 @@ template <class _Tp> class auto_ptr {\n   // specification here, but omitting it is standard conforming.  Its \n   // presence can be detected only if _Tp::~_Tp() throws, but (17.4.3.6/2)\n   // this is prohibited.\n-  ~auto_ptr() { delete _M_ptr; }\n+  ~auto_ptr() { delete this->get(); }\n  \n   _Tp& operator*() const __STL_NOTHROW {\n-    return *_M_ptr;\n+    return  this->get();\n   }\n   _Tp* operator->() const __STL_NOTHROW {\n-    return _M_ptr;\n+    return static_cast<_Tp*>(_M_ptr);\n   }\n   _Tp* get() const __STL_NOTHROW {\n-    return _M_ptr;\n+    return static_cast<_Tp*>(_M_ptr);\n   }\n   _Tp* release() __STL_NOTHROW {\n-    _Tp* __tmp = _M_ptr;\n+    _Tp* const __tmp = this->get();\n     _M_ptr = 0;\n     return __tmp;\n   }\n   void reset(_Tp* __p = 0) __STL_NOTHROW {\n+    _Tp* const __tmp = this->get();\n     if (__p != _M_ptr) {\n       delete _M_ptr;\n       _M_ptr = __p;\n@@ -98,23 +110,35 @@ template <class _Tp> class auto_ptr {\n #if defined(__SGI_STL_USE_AUTO_PTR_CONVERSIONS) && \\\n     defined(__STL_MEMBER_TEMPLATES)\n \n+# ifndef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+private:\n+  template<typename _Tp1> struct auto_ptr_ref {\n+    _Tp1* _M_ptr;\n+    void*& _M_ptr_ref;\n+    explicit auto_ptr_ref(_Tp1* __p, void*& __r) __STL_NOTHROW\n+    : _M_ptr(__p), _M_ptr_ref(__r) {}\n+    _Tp1* _M_release() const __STL_NOTHROW {\n+      _M_ptr_ref = 0;\n+      return _M_ptr;\n+    }\n+  };\n+# endif /* !_GLIBCPP_RESOLVE_LIB_DEFECTS */\n+\n public:\n   auto_ptr(auto_ptr_ref<_Tp> __ref) __STL_NOTHROW\n-    : _M_ptr(__ref._M_ptr) {}\n-\n+  : _M_ptr(__ref._M_release()) {}\n+  \n+# ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n   auto_ptr& operator=(auto_ptr_ref<_Tp> __ref) __STL_NOTHROW {\n-    if (__ref._M_ptr != this->get()) {\n-      delete _M_ptr;\n-      _M_ptr = __ref._M_ptr;\n-    }\n-    return *this;\n+    reset(__ref._M_release());\n+    return *this; \n   }\n-\n-  template <class _Tp1> operator auto_ptr_ref<_Tp1>() __STL_NOTHROW \n-    { return auto_ptr_ref<_Tp>(this->release()); }\n+# endif /* _GLIBCPP_RESOLVE_LIB_DEFECTS */\n+  \n+  template <class _Tp1> operator auto_ptr_ref<_Tp1>() __STL_NOTHROW\n+  { return auto_ptr_ref<_Tp1>(this->get(), _M_ptr); }\n   template <class _Tp1> operator auto_ptr<_Tp1>() __STL_NOTHROW\n-    { return auto_ptr<_Tp1>(this->release()); }\n-\n+  { return auto_ptr<_Tp1>(this->release()); }\n #endif /* auto ptr conversions && member templates */\n };\n "}]}