{"sha": "19331b539d817eef4190b78ee779a445acf046c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkzMzFiNTM5ZDgxN2VlZjQxOTBiNzhlZTc3OWE0NDVhY2YwNDZjNw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-06-05T12:14:23Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-06-05T12:14:23Z"}, "message": "Update new-abi dynamic cast algorithm.\n\n\t* tinfo.cc (__class_type_info::__dyncast_result): Add\n\twhole_details. Adjust constructor.\n\t(__vmi_class_type_info::__do_dyncast): Adjust for vmi_flags.\n\tAvoid unnecessary searching.\n\t(__dynamic_cast): Adjust for __dyncast_result::whole_details.\n\nFrom-SVN: r34401", "tree": {"sha": "1f21e115e82b7b9f0e212e8c7b8be04f40bad03f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f21e115e82b7b9f0e212e8c7b8be04f40bad03f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19331b539d817eef4190b78ee779a445acf046c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19331b539d817eef4190b78ee779a445acf046c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19331b539d817eef4190b78ee779a445acf046c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19331b539d817eef4190b78ee779a445acf046c7/comments", "author": null, "committer": null, "parents": [{"sha": "806617595fdda9139fa496a55254c8c4baa7dc8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/806617595fdda9139fa496a55254c8c4baa7dc8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/806617595fdda9139fa496a55254c8c4baa7dc8d"}], "stats": {"total": 82, "additions": 58, "deletions": 24}, "files": [{"sha": "ae8756bc3634cbca068bf3f6d99610845a2d223f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19331b539d817eef4190b78ee779a445acf046c7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19331b539d817eef4190b78ee779a445acf046c7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=19331b539d817eef4190b78ee779a445acf046c7", "patch": "@@ -1,3 +1,12 @@\n+2000-06-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tUpdate new-abi dynamic cast algorithm.\n+\t* tinfo.cc (__class_type_info::__dyncast_result): Add\n+\twhole_details. Adjust constructor.\n+\t(__vmi_class_type_info::__do_dyncast): Adjust for vmi_flags.\n+\tAvoid unnecessary searching.\n+\t(__dynamic_cast): Adjust for __dyncast_result::whole_details.\n+\n Mon Jun  5 06:48:55 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* decl.c (init_decl_processing): Don't call record_component_aliases."}, {"sha": "5263af8b384085280c2a715659b62f19462499b3", "filename": "gcc/cp/tinfo.cc", "status": "modified", "additions": 49, "deletions": 24, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19331b539d817eef4190b78ee779a445acf046c7/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19331b539d817eef4190b78ee779a445acf046c7/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=19331b539d817eef4190b78ee779a445acf046c7", "patch": "@@ -685,11 +685,13 @@ struct __class_type_info::__dyncast_result\n   __sub_kind whole2dst;       // path from most derived object to target\n   __sub_kind whole2src;       // path from most derived object to sub object\n   __sub_kind dst2src;         // path from target to sub object\n+  int whole_details;          // details of the whole class heirarchy\n   \n   public:\n-  __dyncast_result ()\n+  __dyncast_result (int details_ = __vmi_class_type_info::__flags_unknown_mask)\n     :dst_ptr (NULL), whole2dst (__unknown),\n-     whole2src (__unknown), dst2src (__unknown)\n+     whole2src (__unknown), dst2src (__unknown),\n+     whole_details (details_)\n     {}\n };\n \n@@ -869,6 +871,9 @@ __do_dyncast (ptrdiff_t src2dst,\n               const void *src_ptr,\n               __dyncast_result &__restrict result) const\n {\n+  if (result.whole_details & __flags_unknown_mask)\n+    result.whole_details = vmi_flags;\n+  \n   if (obj_ptr == src_ptr && *this == *src_type)\n     {\n       // The src object we started from. Indicate how we are accessible from\n@@ -887,10 +892,11 @@ __do_dyncast (ptrdiff_t src2dst,\n         result.dst2src = __not_contained;\n       return false;\n     }\n+\n   bool result_ambig = false;\n   for (size_t i = vmi_base_count; i--;)\n     {\n-      __dyncast_result result2;\n+      __dyncast_result result2 (result.whole_details);\n       void const *base = obj_ptr;\n       __sub_kind base_access = access_path;\n       ptrdiff_t offset = vmi_bases[i].__offset ();\n@@ -901,7 +907,17 @@ __do_dyncast (ptrdiff_t src2dst,\n       base = convert_to_base (base, is_virtual, offset);\n \n       if (!vmi_bases[i].__is_public_p ())\n-        base_access = __sub_kind (base_access & ~__contained_public_mask);\n+        {\n+          if (src2dst == -2 &&\n+              !(result.whole_details\n+                & (non_diamond_repeat_mask | diamond_shaped_mask)))\n+            // The hierarchy has no duplicate bases (which might ambiguate\n+            // things) and where we started is not a public base of what we\n+            // want (so it cannot be a downcast). There is nothing of interest\n+            // hiding in a non-public base.\n+            continue;\n+          base_access = __sub_kind (base_access & ~__contained_public_mask);\n+        }\n       \n       bool result2_ambig\n           = vmi_bases[i].base->__do_dyncast (src2dst, base_access,\n@@ -925,6 +941,10 @@ __do_dyncast (ptrdiff_t src2dst,\n           result.dst_ptr = result2.dst_ptr;\n           result.whole2dst = result2.whole2dst;\n           result_ambig = result2_ambig;\n+          if (result.dst_ptr && result.whole2src != __unknown\n+              && !(vmi_flags & non_diamond_repeat_mask))\n+            // Found dst and src and we don't have repeated bases.\n+            return result_ambig;\n         }\n       else if (result.dst_ptr && result.dst_ptr == result2.dst_ptr)\n         {\n@@ -933,9 +953,8 @@ __do_dyncast (ptrdiff_t src2dst,\n           result.whole2dst =\n               __sub_kind (result.whole2dst | result2.whole2dst);\n         }\n-      else if ((result.dst_ptr && result2.dst_ptr)\n-               || (result_ambig && result2.dst_ptr)\n-               || (result2_ambig && result.dst_ptr))\n+      else if ((result.dst_ptr != 0 | result_ambig)\n+               && (result2.dst_ptr != 0 | result2_ambig))\n         {\n           // Found two different DST_TYPE bases, or a valid one and a set of\n           // ambiguous ones, must disambiguate. See whether SRC_PTR is\n@@ -948,11 +967,14 @@ __do_dyncast (ptrdiff_t src2dst,\n           __sub_kind new_sub_kind = result2.dst2src;\n           __sub_kind old_sub_kind = result.dst2src;\n           \n-          if (contained_nonvirtual_p (result.whole2src))\n+          if (contained_p (result.whole2src)\n+              && (!virtual_p (result.whole2src)\n+                  || !(result.whole_details & diamond_shaped_mask)))\n             {\n-              // We already found SRC_PTR as a non-virtual base of most\n-              // derived. Therefore if it is in either choice, it can only be\n-              // in one of them, and we will already know.\n+              // We already found SRC_PTR as a base of most derived, and\n+              // either it was non-virtual, or the whole heirarchy is\n+              // not-diamond shaped. Therefore if it is in either choice, it\n+              // can only be in one of them, and we will already know.\n               if (old_sub_kind == __unknown)\n                 old_sub_kind = __not_contained;\n               if (new_sub_kind == __unknown)\n@@ -962,19 +984,23 @@ __do_dyncast (ptrdiff_t src2dst,\n             {\n               if (old_sub_kind >= __not_contained)\n                 ;// already calculated\n-              else if (contained_nonvirtual_p (new_sub_kind))\n-                // Already found non-virtually inside the other choice,\n-                // cannot be in this.\n+              else if (contained_p (new_sub_kind)\n+                       && (!virtual_p (new_sub_kind)\n+                           || !(vmi_flags & diamond_shaped_mask)))\n+                // Already found inside the other choice, and it was\n+                // non-virtual or we are not diamond shaped.\n                 old_sub_kind = __not_contained;\n               else\n                 old_sub_kind = dst_type->__find_public_src\n                                 (src2dst, result.dst_ptr, src_type, src_ptr);\n           \n               if (new_sub_kind >= __not_contained)\n                 ;// already calculated\n-              else if (contained_nonvirtual_p (old_sub_kind))\n-                // Already found non-virtually inside the other choice,\n-                // cannot be in this.\n+              else if (contained_p (old_sub_kind)\n+                       && (!virtual_p (old_sub_kind)\n+                           || !(vmi_flags & diamond_shaped_mask)))\n+                // Already found inside the other choice, and it was\n+                // non-virtual or we are not diamond shaped.\n                 new_sub_kind = __not_contained;\n               else\n                 new_sub_kind = dst_type->__find_public_src\n@@ -1159,18 +1185,17 @@ __dynamic_cast (const void *src_ptr,    // object started from\n   if (!result.dst_ptr)\n     return NULL;\n   if (contained_public_p (result.dst2src))\n+    // Src is known to be a public base of dst.\n     return const_cast <void *> (result.dst_ptr);\n   if (contained_public_p (__class_type_info::__sub_kind (result.whole2src & result.whole2dst)))\n-    // Found a valid cross cast\n+    // Both src and dst are known to be public bases of whole. Found a valid\n+    // cross cast.\n     return const_cast <void *> (result.dst_ptr);\n   if (contained_nonvirtual_p (result.whole2src))\n-    // Found an invalid cross cast, which cannot also be a down cast\n+    // Src is known to be a non-public nonvirtual base of whole, and not a\n+    // base of dst. Found an invalid cross cast, which cannot also be a down\n+    // cast\n     return NULL;\n-  #if 0 // FIXME: we need to discover this lazily\n-  if (!(whole_type->details & __class_type_info::private_base_mask))\n-    // whole type has no private bases\n-    return const_cast <void *> (result.dst_ptr);\n-  #endif\n   if (result.dst2src == __class_type_info::__unknown)\n     result.dst2src = dst_type->__find_public_src (src2dst, result.dst_ptr,\n                                                   src_type, src_ptr);"}]}