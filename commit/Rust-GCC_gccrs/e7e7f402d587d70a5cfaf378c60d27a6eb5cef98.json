{"sha": "e7e7f402d587d70a5cfaf378c60d27a6eb5cef98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdlN2Y0MDJkNTg3ZDcwYTVjZmFmMzc4YzYwZDI3YTZlYjVjZWY5OA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-11-22T07:48:21Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-11-22T07:48:21Z"}, "message": "tree-ssa-threadupdate.c: Include tree-cfg.h and tree-pass.h\n\n\t* tree-ssa-threadupdate.c: Include tree-cfg.h and tree-pass.h\n\t(thread_block_1): Do not cancel jump threads which go from\n\tinside a loop, through the header, then back inside the loop.\n\t(bb_ends_with_multiway_branch): New function.\n\t(thread_through_all_blocks): Handle threading cases which start\n\tin a loop through the loop header to a point in the loop.\n\nFrom-SVN: r205246", "tree": {"sha": "0ee43ec475a0ff9b689d9f55913fdc476de9a30d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ee43ec475a0ff9b689d9f55913fdc476de9a30d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7e7f402d587d70a5cfaf378c60d27a6eb5cef98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7e7f402d587d70a5cfaf378c60d27a6eb5cef98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7e7f402d587d70a5cfaf378c60d27a6eb5cef98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7e7f402d587d70a5cfaf378c60d27a6eb5cef98/comments", "author": null, "committer": null, "parents": [{"sha": "e44a45c610269bab661aa4ebce9ccd25262d6802", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e44a45c610269bab661aa4ebce9ccd25262d6802", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e44a45c610269bab661aa4ebce9ccd25262d6802"}], "stats": {"total": 155, "additions": 117, "deletions": 38}, "files": [{"sha": "8f4bdca41a46b8feec8ad4b55485b0294c74f581", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7e7f402d587d70a5cfaf378c60d27a6eb5cef98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7e7f402d587d70a5cfaf378c60d27a6eb5cef98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7e7f402d587d70a5cfaf378c60d27a6eb5cef98", "patch": "@@ -1,5 +1,12 @@\n 2013-11-22  Jeff Law  <law@redhat.com>\n \n+\t* tree-ssa-threadupdate.c: Include tree-cfg.h and tree-pass.h\n+\t(thread_block_1): Do not cancel jump threads which go from\n+\tinside a loop, through the header, then back inside the loop.\n+\t(bb_ends_with_multiway_branch): New function.\n+\t(thread_through_all_blocks): Handle threading cases which start\n+\tin a loop through the loop header to a point in the loop.\n+\n \t* tree-ssa-threadedge.c (thread_across_edge): Mark the start of the\n \tjump thread path properly.\n "}, {"sha": "60c1815d529649faeb83828ec2eedc0524067bab", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 110, "deletions": 38, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7e7f402d587d70a5cfaf378c60d27a6eb5cef98/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7e7f402d587d70a5cfaf378c60d27a6eb5cef98/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=e7e7f402d587d70a5cfaf378c60d27a6eb5cef98", "patch": "@@ -35,6 +35,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"hash-table.h\"\n #include \"dbgcnt.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-pass.h\"\n \n /* Given a block B, update the CFG and SSA graph to reflect redirecting\n    one or more in-edges to B to instead reach the destination of an\n@@ -815,29 +817,15 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n \t    }\n \n \t  /* Another case occurs when trying to thread through our\n-\t     own loop header, possibly from inside the loop.\n-\n-\t     If our loop header is buried in the path, then go ahead\n-\t     and cancel the jump threading request here.  This likely\n-\t     will need updating for the FSA/FSM coremark case.\n-\n-\t     Other cases (BB is the loop header) are handled elsewhere.  */\n+\t     own loop header, possibly from inside the loop.  We will\n+\t     thread these later.  */\n \t  unsigned int i;\n \t  for (i = 1; i < path->length (); i++)\n \t    {\n \t      if ((*path)[i]->e->src == bb->loop_father->header\n \t\t  && (!loop_exit_edge_p (bb->loop_father, e2)\n \t\t      || (*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK))\n-\t\t{\n-\t\t  /* If i != 1, then it's a buried header that will not\n-\t\t     be handled elsehwere.  */\n-\t\t  if (i != 1)\n-\t\t    {\n-\t\t      delete_jump_thread_path (path);\n-\t\t      e->aux = NULL;\n-\t\t    }\n-\t\t  break;\n-\t\t}\n+\t\tbreak;\n \t    }\n \n \t  if (i != path->length ())\n@@ -1554,6 +1542,20 @@ mark_threaded_blocks (bitmap threaded_blocks)\n }\n \n \n+/* Return TRUE if BB ends with a switch statement or a computed goto.\n+   Otherwise return false.  */\n+static bool\n+bb_ends_with_multiway_branch (basic_block bb ATTRIBUTE_UNUSED)\n+{\n+  gimple stmt = last_stmt (bb);\n+  if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)\n+    return true;\n+  if (stmt && gimple_code (stmt) == GIMPLE_GOTO\n+      && TREE_CODE (gimple_goto_dest (stmt)) == SSA_NAME)\n+    return true;\n+  return false;\n+}\n+\n /* Walk through all blocks and thread incoming edges to the appropriate\n    outgoing edge for each edge pair recorded in THREADED_EDGES.\n \n@@ -1573,6 +1575,7 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n   bitmap_iterator bi;\n   bitmap threaded_blocks;\n   struct loop *loop;\n+  bool totally_clobbered_loops = false;\n \n   /* We must know about loops in order to preserve them.  */\n   gcc_assert (current_loops != NULL);\n@@ -1609,35 +1612,79 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n       retval |= thread_through_loop_header (loop, may_peel_loop_headers);\n     }\n \n-  /* Assume we had a jump thread path which went from the latch to the exit\n-     and a path which goes from outside to inside the same loop.\n-\n-     If the latch to exit was handled first, we will thread it and clear\n-     loop->header.\n-\n-     The second path will be ignored by thread_block because we're going\n-     through a loop header.  It will also be ignored by the loop above\n-     because loop->header is NULL.\n-\n-     This results in the second path never being threaded.  The failure\n-     mode is a dangling AUX field.\n-\n-     This is inherently a bit of a pain to fix, so we just walk all the\n-     blocks and all the incoming edges to those blocks and clear their\n-     AUX fields.  */\n+  /* Any jump threading paths that are still attached to edges at this\n+     point must be one of two cases.\n+\n+     First, we could have a jump threading path which went from outside\n+     a loop to inside a loop that was ignored because a prior jump thread\n+     across a backedge was realized (which indirectly causes the loop\n+     above to ignore the latter thread).  We can detect these because the\n+     loop structures will be different and we do not currently try to\n+     optimize this case.\n+\n+     Second, we could be threading across a backedge to a point within the\n+     same loop.  This occurrs for the FSA/FSM optimization and we would\n+     like to optimize it.  However, we have to be very careful as this\n+     may completely scramble the loop structures, with the result being\n+     irreducible loops causing us to throw away our loop structure.\n+\n+     As a compromise for the latter case, if the thread path ends in\n+     a block where the last statement is a multiway branch, then go\n+     ahead and thread it, else ignore it.  */\n   basic_block bb;\n-  edge_iterator ei;\n   edge e;\n   FOR_EACH_BB (bb)\n     {\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n+      /* If we do end up threading here, we can remove elements from\n+\t BB->preds.  Thus we can not use the FOR_EACH_EDGE iterator.  */\n+      for (edge_iterator ei = ei_start (bb->preds);\n+\t   (e = ei_safe_edge (ei));)\n \tif (e->aux)\n \t  {\n \t    vec<jump_thread_edge *> *path = THREAD_PATH (e);\n \n-\t    delete_jump_thread_path (path);\n-\t    e->aux = NULL;\n+\t    /* Case 1, threading from outside to inside the loop\n+\t       after we'd already threaded through the header.  */\n+\t    if ((*path)[0]->e->dest->loop_father\n+\t\t!= path->last ()->e->src->loop_father)\n+\t      {\n+\t\tdelete_jump_thread_path (path);\n+\t\te->aux = NULL;\n+\t\tei_next (&ei);\n+\t      }\n+\t   else if (bb_ends_with_multiway_branch (path->last ()->e->src))\n+\t      {\n+\t\t/* The code to thread through loop headers may have\n+\t\t   split a block with jump threads attached to it.\n+\n+\t\t   We can identify this with a disjoint jump threading\n+\t\t   path.  If found, just remove it.  */\n+\t\tfor (unsigned int i = 0; i < path->length () - 1; i++)\n+\t\t  if ((*path)[i]->e->dest != (*path)[i + 1]->e->src)\n+\t\t    {\n+\t\t      delete_jump_thread_path (path);\n+\t\t      e->aux = NULL;\n+\t\t      ei_next (&ei);\n+\t\t      break;\n+\t\t    }\n+\n+\t\t/* Our path is still valid, thread it.  */\n+\t        if (e->aux)\n+\t\t  {\n+\t\t    totally_clobbered_loops\n+\t\t      |= thread_block ((*path)[0]->e->dest, false);\n+\t\t    e->aux = NULL;\n+\t\t  }\n+\t      }\n+\t   else\n+\t      {\n+\t\tdelete_jump_thread_path (path);\n+\t\te->aux = NULL;\n+\t\tei_next (&ei);\n+\t      }\n  \t  }\n+\telse\n+\t  ei_next (&ei);\n     }\n \n   statistics_counter_event (cfun, \"Jumps threaded\",\n@@ -1649,7 +1696,32 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n   threaded_blocks = NULL;\n   paths.release ();\n \n-  if (retval)\n+  /* If we made changes to the CFG that might have totally messed\n+     up the loop structure, then drop the old loop structure and\n+     rebuild.  */\n+  if (totally_clobbered_loops)\n+    {\n+      /* Release the current loop structures, they are totally\n+\t clobbered at this point.  */\n+      loop_optimizer_finalize ();\n+      current_loops = NULL;\n+\n+      /* Similarly for dominance information.  */\n+      free_dominance_info (CDI_DOMINATORS);\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+\n+      /* Before we can rebuild the loop structures, we need dominators,\n+\t which requires no unreachable code.  So remove unreachable code.  */\n+      delete_unreachable_blocks ();\n+\n+      /* Now rebuild the loop structures.  */\n+      cfun->curr_properties &= ~PROP_loops;\n+      loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n+      cfun->curr_properties |= PROP_loops;\n+      retval = 1;\n+    }\n+\n+  if (retval && current_loops)\n     loops_state_set (LOOPS_NEED_FIXUP);\n \n   return retval;"}]}