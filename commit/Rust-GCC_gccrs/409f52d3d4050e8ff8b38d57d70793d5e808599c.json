{"sha": "409f52d3d4050e8ff8b38d57d70793d5e808599c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA5ZjUyZDNkNDA1MGU4ZmY4YjM4ZDU3ZDcwNzkzZDVlODA4NTk5Yw==", "commit": {"author": {"name": "Falk Hueffner", "email": "falk.hueffner@student.uni-tuebingen.de", "date": "2003-05-02T01:05:43Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-05-02T01:05:43Z"}, "message": "re PR target/8257 ([Alpha] frame pointer computation wrong on alpha (cross-compiler))\n\n        PR target/8257\n        * config/alpha/alpha.c (alpha_sa_mask, alpha_expand_prologue,\n        alpha_start_function, alpha_expand_epilogue, unicosmk_gen_dsib):\n        Avoid undefined shifts by making the shift operand unsigned.\n\nFrom-SVN: r66367", "tree": {"sha": "6daf95e2fafbea122ff4c0313b561a38aed578ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6daf95e2fafbea122ff4c0313b561a38aed578ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/409f52d3d4050e8ff8b38d57d70793d5e808599c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/409f52d3d4050e8ff8b38d57d70793d5e808599c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/409f52d3d4050e8ff8b38d57d70793d5e808599c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/409f52d3d4050e8ff8b38d57d70793d5e808599c/comments", "author": null, "committer": null, "parents": [{"sha": "57458e8a15785a1989e379403cfdf6b3624701dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57458e8a15785a1989e379403cfdf6b3624701dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57458e8a15785a1989e379403cfdf6b3624701dc"}], "stats": {"total": 55, "additions": 31, "deletions": 24}, "files": [{"sha": "34fd97ec0c1c83d815b7fd0cc932f539d473ce8c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409f52d3d4050e8ff8b38d57d70793d5e808599c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409f52d3d4050e8ff8b38d57d70793d5e808599c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=409f52d3d4050e8ff8b38d57d70793d5e808599c", "patch": "@@ -1,3 +1,10 @@\n+2003-05-01  Falk Hueffner  <falk.hueffner@student.uni-tuebingen.de>\n+ \n+        PR target/8257\n+        * config/alpha/alpha.c (alpha_sa_mask, alpha_expand_prologue,\n+        alpha_start_function, alpha_expand_epilogue, unicosmk_gen_dsib):\n+        Avoid undefined shifts by making the shift operand unsigned.\n+ \n 2003-05-01  DJ Delorie  <dj@redhat.com>\n \n \t* reload.c (find_reloads): Also check that all of a multi-reg"}, {"sha": "b6538e67f9c5e3124bae102a52d7bea0b1cb2057", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409f52d3d4050e8ff8b38d57d70793d5e808599c/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409f52d3d4050e8ff8b38d57d70793d5e808599c/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=409f52d3d4050e8ff8b38d57d70793d5e808599c", "patch": "@@ -6938,7 +6938,7 @@ alpha_sa_mask (imaskP, fmaskP)\n     }\n \n   if (TARGET_ABI_OPEN_VMS && alpha_procedure_type == PT_STACK)\n-    imask |= (1L << HARD_FRAME_POINTER_REGNUM);\n+    imask |= (1UL << HARD_FRAME_POINTER_REGNUM);\n \n   /* One for every register we have to save.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -6947,9 +6947,9 @@ alpha_sa_mask (imaskP, fmaskP)\n \t&& (!TARGET_ABI_UNICOSMK || i != HARD_FRAME_POINTER_REGNUM))\n       {\n \tif (i < 32)\n-\t  imask |= (1L << i);\n+\t  imask |= (1UL << i);\n \telse\n-\t  fmask |= (1L << (i - 32));\n+\t  fmask |= (1UL << (i - 32));\n       }\n \n   /* We need to restore these for the handler.  */\n@@ -6959,14 +6959,14 @@ alpha_sa_mask (imaskP, fmaskP)\n \tunsigned regno = EH_RETURN_DATA_REGNO (i);\n \tif (regno == INVALID_REGNUM)\n \t  break;\n-\timask |= 1L << regno;\n+\timask |= 1UL << regno;\n       }\n      \n   /* If any register spilled, then spill the return address also.  */\n   /* ??? This is required by the Digital stack unwind specification\n      and isn't needed if we're doing Dwarf2 unwinding.  */\n   if (imask || fmask || alpha_ra_ever_killed ())\n-    imask |= (1L << REG_RA);\n+    imask |= (1UL << REG_RA);\n \n   *imaskP = imask;\n   *fmaskP = fmask;\n@@ -7430,18 +7430,18 @@ alpha_expand_prologue ()\n \t}\n \n       /* Save register RA next.  */\n-      if (imask & (1L << REG_RA))\n+      if (imask & (1UL << REG_RA))\n \t{\n \t  mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n \t  set_mem_alias_set (mem, alpha_sr_alias_set);\n \t  FRP (emit_move_insn (mem, gen_rtx_REG (DImode, REG_RA)));\n-\t  imask &= ~(1L << REG_RA);\n+\t  imask &= ~(1UL << REG_RA);\n \t  reg_offset += 8;\n \t}\n \n       /* Now save any other registers required to be saved.  */\n       for (i = 0; i < 32; i++)\n-\tif (imask & (1L << i))\n+\tif (imask & (1UL << i))\n \t  {\n \t    mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n \t    set_mem_alias_set (mem, alpha_sr_alias_set);\n@@ -7450,7 +7450,7 @@ alpha_expand_prologue ()\n \t  }\n \n       for (i = 0; i < 32; i++)\n-\tif (fmask & (1L << i))\n+\tif (fmask & (1UL << i))\n \t  {\n \t    mem = gen_rtx_MEM (DFmode, plus_constant (sa_reg, reg_offset));\n \t    set_mem_alias_set (mem, alpha_sr_alias_set);\n@@ -7466,7 +7466,7 @@ alpha_expand_prologue ()\n \n       reg_offset = -56;\n       for (i = 9; i < 15; i++)\n-\tif (imask & (1L << i))\n+\tif (imask & (1UL << i))\n \t  {\n \t    mem = gen_rtx_MEM (DImode, plus_constant(hard_frame_pointer_rtx,\n \t\t\t\t\t\t     reg_offset));\n@@ -7475,7 +7475,7 @@ alpha_expand_prologue ()\n \t    reg_offset -= 8;\n \t  }\n       for (i = 2; i < 10; i++)\n-\tif (fmask & (1L << i))\n+\tif (fmask & (1UL << i))\n \t  {\n \t    mem = gen_rtx_MEM (DFmode, plus_constant (hard_frame_pointer_rtx,\n \t\t\t\t\t\t      reg_offset));\n@@ -7690,7 +7690,7 @@ alpha_start_function (file, fnname, decl)\n     {\n       fprintf (file, \"\\t.frame $%d,\", vms_unwind_regno);\n       fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n-\t       frame_size >= ((HOST_WIDE_INT) 1 << 31) ? 0 : frame_size);\n+\t       frame_size >= (1UL << 31) ? 0 : frame_size);\n       fputs (\",$26,\", file);\n       fprintf (file, HOST_WIDE_INT_PRINT_DEC, reg_offset);\n       fputs (\"\\n\", file);\n@@ -7701,7 +7701,7 @@ alpha_start_function (file, fnname, decl)\n \t       (frame_pointer_needed\n \t\t? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM));\n       fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n-\t       frame_size >= (1l << 31) ? 0 : frame_size);\n+\t       frame_size >= (1UL << 31) ? 0 : frame_size);\n       fprintf (file, \",$26,%d\\n\", current_function_pretend_args_size);\n     }\n \n@@ -7713,7 +7713,7 @@ alpha_start_function (file, fnname, decl)\n       if (imask)\n         /* ??? Does VMS care if mask contains ra?  The old code didn't\n            set it, so I don't here.  */\n-\tfprintf (file, \"\\t.mask 0x%lx,0\\n\", imask & ~(1L << REG_RA));\n+\tfprintf (file, \"\\t.mask 0x%lx,0\\n\", imask & ~(1UL << REG_RA));\n       if (fmask)\n \tfprintf (file, \"\\t.fmask 0x%lx,0\\n\", fmask);\n       if (alpha_procedure_type == PT_REGISTER)\n@@ -7725,19 +7725,19 @@ alpha_start_function (file, fnname, decl)\n \t{\n \t  fprintf (file, \"\\t.mask 0x%lx,\", imask);\n \t  fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n-\t\t   frame_size >= (1l << 31) ? 0 : reg_offset - frame_size);\n+\t\t   frame_size >= (1UL << 31) ? 0 : reg_offset - frame_size);\n \t  putc ('\\n', file);\n \n \t  for (i = 0; i < 32; ++i)\n-\t    if (imask & (1L << i))\n+\t    if (imask & (1UL << i))\n \t      reg_offset += 8;\n \t}\n \n       if (fmask)\n \t{\n \t  fprintf (file, \"\\t.fmask 0x%lx,\", fmask);\n \t  fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n-\t\t   frame_size >= (1l << 31) ? 0 : reg_offset - frame_size);\n+\t\t   frame_size >= (1UL << 31) ? 0 : reg_offset - frame_size);\n \t  putc ('\\n', file);\n \t}\n     }\n@@ -7873,10 +7873,10 @@ alpha_expand_epilogue ()\n       FRP (emit_move_insn (gen_rtx_REG (DImode, REG_RA), mem));\n \n       reg_offset += 8;\n-      imask &= ~(1L << REG_RA);\n+      imask &= ~(1UL << REG_RA);\n \n       for (i = 0; i < 32; ++i)\n-\tif (imask & (1L << i))\n+\tif (imask & (1UL << i))\n \t  {\n \t    if (i == HARD_FRAME_POINTER_REGNUM && fp_is_frame_pointer)\n \t      fp_offset = reg_offset;\n@@ -7890,7 +7890,7 @@ alpha_expand_epilogue ()\n \t  }\n \n       for (i = 0; i < 32; ++i)\n-\tif (fmask & (1L << i))\n+\tif (fmask & (1UL << i))\n \t  {\n \t    mem = gen_rtx_MEM (DFmode, plus_constant(sa_reg, reg_offset));\n \t    set_mem_alias_set (mem, alpha_sr_alias_set);\n@@ -7905,7 +7905,7 @@ alpha_expand_epilogue ()\n       reg_offset = -56;\n \n       for (i = 9; i < 15; i++)\n-\tif (imask & (1L << i))\n+\tif (imask & (1UL << i))\n \t  {\n \t    mem = gen_rtx_MEM (DImode, plus_constant(hard_frame_pointer_rtx,\n \t\t\t\t\t\t     reg_offset));\n@@ -7915,7 +7915,7 @@ alpha_expand_epilogue ()\n \t  }\n \n       for (i = 2; i < 10; i++)\n-\tif (fmask & (1L << i))\n+\tif (fmask & (1UL << i))\n \t  {\n \t    mem = gen_rtx_MEM (DFmode, plus_constant(hard_frame_pointer_rtx,\n \t\t\t\t\t\t     reg_offset));\n@@ -9931,14 +9931,14 @@ unicosmk_gen_dsib (imaskP)\n       mem = gen_rtx_MEM (DImode, plus_constant (stack_pointer_rtx, 56));\n       set_mem_alias_set (mem, alpha_sr_alias_set);\n       FRP (emit_move_insn (mem, gen_rtx_REG (DImode, REG_RA)));\n-      (*imaskP) &= ~(1L << REG_RA);\n+      (*imaskP) &= ~(1UL << REG_RA);\n \n       /* Save the old frame pointer.  */\n \n       mem = gen_rtx_MEM (DImode, plus_constant (stack_pointer_rtx, 48));\n       set_mem_alias_set (mem, alpha_sr_alias_set);\n       FRP (emit_move_insn (mem, hard_frame_pointer_rtx));\n-      (*imaskP) &= ~(1L << HARD_FRAME_POINTER_REGNUM);\n+      (*imaskP) &= ~(1UL << HARD_FRAME_POINTER_REGNUM);\n \n       emit_insn (gen_blockage ());\n "}]}