{"sha": "5f261ba970a894543b1c8c30f71c7eb2a234ba93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYyNjFiYTk3MGE4OTQ1NDNiMWM4YzMwZjcxYzdlYjJhMjM0YmE5Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-06-24T19:18:43Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-06-24T19:18:43Z"}, "message": "cp-tree.h (SCALAR_TYPE_P): New macro.\n\n\t* cp-tree.h (SCALAR_TYPE_P): New macro.\n\t(check_for_out_of_scope_variable): New function.\n\t(at_class_scope_p): Likewise.\n\t(finish_fname): Likewise.\n\t* class.c (finish_struct): Use at_function_scope_p.\n\t* decl.c (check_for_out_of_scope_variable): New function, split\n\tout from do_identifier.\n\t(finish_enum): Use at_function_scope_p.\n\t* lex.c (do_identifier): Use check_for_out_of_scope_variable.\n\t* parse.y (VAR_FUNC_NAME): Give it <ttype>.  Use finish_fname.\n\t(primary): Use at_function_scope_p.\n\t* search.c (at_class_scope_p): New function.\n\t* semantics.c (finish_fname): Likewise.\n\t(check_multiple_declarators): Use at_function_scope_p.\n\nFrom-SVN: r54962", "tree": {"sha": "be46d82b47945fa6f5b787b66f752af4d7711a6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be46d82b47945fa6f5b787b66f752af4d7711a6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f261ba970a894543b1c8c30f71c7eb2a234ba93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f261ba970a894543b1c8c30f71c7eb2a234ba93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f261ba970a894543b1c8c30f71c7eb2a234ba93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f261ba970a894543b1c8c30f71c7eb2a234ba93/comments", "author": null, "committer": null, "parents": [{"sha": "87912be720118115eded3786b807a34cfb0f0a81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87912be720118115eded3786b807a34cfb0f0a81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87912be720118115eded3786b807a34cfb0f0a81"}], "stats": {"total": 182, "additions": 122, "deletions": 60}, "files": [{"sha": "869c2554c087fd065af95f486eddf34092d99ae8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5f261ba970a894543b1c8c30f71c7eb2a234ba93", "patch": "@@ -1,3 +1,20 @@\n+2002-06-24  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (SCALAR_TYPE_P): New macro.\n+\t(check_for_out_of_scope_variable): New function.\n+\t(at_class_scope_p): Likewise.\n+\t(finish_fname): Likewise.\n+\t* class.c (finish_struct): Use at_function_scope_p.\n+\t* decl.c (check_for_out_of_scope_variable): New function, split\n+\tout from do_identifier.\n+\t(finish_enum): Use at_function_scope_p.\n+\t* lex.c (do_identifier): Use check_for_out_of_scope_variable.\n+\t* parse.y (VAR_FUNC_NAME): Give it <ttype>.  Use finish_fname.\n+\t(primary): Use at_function_scope_p.\n+\t* search.c (at_class_scope_p): New function.\n+\t* semantics.c (finish_fname): Likewise.\n+\t(check_multiple_declarators): Use at_function_scope_p.\n+\t\n 2002-06-23  Mark Mitchell  <mark@codesourcery.com>\n \n \t* parse.y (parse_scoped_id): New function."}, {"sha": "0577c76cd2a3dface92a9c96621bb91e5167470a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=5f261ba970a894543b1c8c30f71c7eb2a234ba93", "patch": "@@ -5310,12 +5310,8 @@ finish_struct (t, attributes)\n   else\n     error (\"trying to finish struct, but kicked out due to previous parse errors\");\n \n-  if (processing_template_decl)\n-    {\n-      tree scope = current_scope ();\n-      if (scope && TREE_CODE (scope) == FUNCTION_DECL)\n-\tadd_stmt (build_min (TAG_DEFN, t));\n-    }\n+  if (processing_template_decl && at_function_scope_p ())\n+    add_stmt (build_min (TAG_DEFN, t));\n \n   return t;\n }"}, {"sha": "32b241267112199f4d2e9770886a8c37b7329c5c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5f261ba970a894543b1c8c30f71c7eb2a234ba93", "patch": "@@ -2546,6 +2546,17 @@ extern int flag_new_for_scope;\n #define ARITHMETIC_TYPE_P(TYPE) \\\n   (CP_INTEGRAL_TYPE_P (TYPE) || TREE_CODE (TYPE) == REAL_TYPE)\n \n+/* [basic.types]\n+\n+   Arithmetic types, enumeration types, pointer types, and\n+   pointer-to-member types, are collectively called scalar types.  */\n+#define SCALAR_TYPE_P(TYPE)\t\t\t\\\n+  (ARITHMETIC_TYPE_P (TYPE)\t\t\t\\\n+   || TREE_CODE (TYPE) == ENUMERAL_TYPE\t\t\\\n+   || TYPE_PTR_P (TYPE)\t\t\t\t\\\n+   || TYPE_PTRMEM_P (TYPE)\t\t\t\\\n+   || TYPE_PTRMEMFUNC_P (TYPE))\n+\n /* Nonzero for _TYPE means that the _TYPE defines\n    at least one constructor.  */\n #define TYPE_HAS_CONSTRUCTOR(NODE) (TYPE_LANG_FLAG_1 (NODE))\n@@ -3812,6 +3823,7 @@ extern void begin_only_namespace_names          PARAMS ((void));\n extern void end_only_namespace_names            PARAMS ((void));\n extern tree namespace_ancestor\t\t\tPARAMS ((tree, tree));\n extern tree unqualified_namespace_lookup\tPARAMS ((tree, int, tree *));\n+extern tree check_for_out_of_scope_variable     (tree);\n extern int  lookup_using_namespace              PARAMS ((tree, tree, tree, tree, int, tree *));\n extern int  qualified_lookup_using_namespace    PARAMS ((tree, tree, tree, int));\n extern tree build_library_fn\t\t\tPARAMS ((tree, tree));\n@@ -4174,6 +4186,7 @@ extern void init_search_processing\t\tPARAMS ((void));\n extern void reinit_search_statistics\t\tPARAMS ((void));\n extern tree current_scope\t\t\tPARAMS ((void));\n extern int at_function_scope_p                  PARAMS ((void));\n+extern bool at_class_scope_p                    (void);\n extern tree context_for_name_lookup\t\tPARAMS ((tree));\n extern tree lookup_conversions\t\t\tPARAMS ((tree));\n extern tree binfo_for_vtable\t\t\tPARAMS ((tree));\n@@ -4261,6 +4274,7 @@ extern tree finish_pseudo_destructor_call_expr  PARAMS ((tree, tree, tree));\n extern tree finish_qualified_call_expr          PARAMS ((tree, tree));\n extern tree finish_unary_op_expr                PARAMS ((enum tree_code, tree));\n extern tree finish_id_expr                      PARAMS ((tree));\n+extern tree finish_fname                        (tree);\n extern void save_type_access_control\t\tPARAMS ((tree));\n extern void reset_type_access_control           PARAMS ((void));\n extern void decl_type_access_control\t\tPARAMS ((tree));"}, {"sha": "3a6e7a1f27312eb2a3d22a610fdc7b161d713edf", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5f261ba970a894543b1c8c30f71c7eb2a234ba93", "patch": "@@ -5921,6 +5921,65 @@ warn_about_implicit_typename_lookup (typename, binding)\n     }\n }\n \n+/* Check to see whether or not DECL is a variable that would have been\n+   in scope under the ARM, but is not in scope under the ANSI/ISO\n+   standard.  If so, issue an error message.  If name lookup would\n+   work in both cases, but return a different result, this function\n+   returns the result of ANSI/ISO lookup.  Otherwise, it returns\n+   DECL.  */\n+\n+tree\n+check_for_out_of_scope_variable (tree decl)\n+{\n+  tree shadowed;\n+\n+  /* We only care about out of scope variables.  */\n+  if (!(TREE_CODE (decl) == VAR_DECL && DECL_DEAD_FOR_LOCAL (decl)))\n+    return decl;\n+\n+  shadowed = DECL_SHADOWED_FOR_VAR (decl);\n+  while (shadowed != NULL_TREE && TREE_CODE (shadowed) == VAR_DECL\n+\t && DECL_DEAD_FOR_LOCAL (shadowed))\n+    shadowed = DECL_SHADOWED_FOR_VAR (shadowed);\n+  if (!shadowed)\n+    shadowed = IDENTIFIER_NAMESPACE_VALUE (DECL_NAME (decl));\n+  if (shadowed)\n+    {\n+      if (!DECL_ERROR_REPORTED (decl))\n+\t{\n+\t  warning (\"name lookup of `%D' changed\",\n+\t\t      DECL_NAME (decl));\n+\t  cp_warning_at (\"  matches this `%D' under ISO standard rules\",\n+\t\t\t shadowed);\n+\t  cp_warning_at (\"  matches this `%D' under old rules\", decl);\n+\t  DECL_ERROR_REPORTED (decl) = 1;\n+\t}\n+      return shadowed;\n+    }\n+\n+  /* If we have already complained about this declaration, there's no\n+     need to do it again.  */\n+  if (DECL_ERROR_REPORTED (decl))\n+    return decl;\n+\n+  DECL_ERROR_REPORTED (decl) = 1;\n+  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n+    {\n+      error (\"name lookup of `%D' changed for new ISO `for' scoping\",\n+\t     DECL_NAME (decl));\n+      cp_error_at (\"  cannot use obsolete binding at `%D' because it has a destructor\", decl);\n+      return error_mark_node;\n+    }\n+  else\n+    {\n+      pedwarn (\"name lookup of `%D' changed for new ISO `for' scoping\",\n+\t       DECL_NAME (decl));\n+      cp_pedwarn_at (\"  using obsolete binding at `%D'\", decl);\n+    }\n+\n+  return decl;\n+}\n+\n /* Look up NAME in the current binding level and its superiors in the\n    namespace of variables, functions and typedefs.  Return a ..._DECL\n    node of some kind representing its definition if there is only one\n@@ -13171,11 +13230,8 @@ finish_enum (enumtype)\n      postponed until the template is instantiated.  */\n   if (processing_template_decl)\n     {\n-      tree scope = current_scope ();\n-      if (scope && TREE_CODE (scope) == FUNCTION_DECL)\n+      if (at_function_scope_p ())\n \tadd_stmt (build_min (TAG_DEFN, enumtype));\n-\n-\n       return;\n     }\n "}, {"sha": "feadd6918fe79945f189a82cc6beed5d3824628e", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 39, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=5f261ba970a894543b1c8c30f71c7eb2a234ba93", "patch": "@@ -1208,45 +1208,8 @@ do_identifier (token, parsing, args)\n \t}\n     }\n \n-  if (TREE_CODE (id) == VAR_DECL && DECL_DEAD_FOR_LOCAL (id))\n-    {\n-      tree shadowed = DECL_SHADOWED_FOR_VAR (id);\n-      while (shadowed != NULL_TREE && TREE_CODE (shadowed) == VAR_DECL\n-\t     && DECL_DEAD_FOR_LOCAL (shadowed))\n-\tshadowed = DECL_SHADOWED_FOR_VAR (shadowed);\n-      if (!shadowed)\n-\tshadowed = IDENTIFIER_NAMESPACE_VALUE (DECL_NAME (id));\n-      if (shadowed)\n-\t{\n-\t  if (!DECL_ERROR_REPORTED (id))\n-\t    {\n-\t      warning (\"name lookup of `%s' changed\",\n-\t\t       IDENTIFIER_POINTER (token));\n-\t      cp_warning_at (\"  matches this `%D' under ISO standard rules\",\n-\t\t\t     shadowed);\n-\t      cp_warning_at (\"  matches this `%D' under old rules\", id);\n-\t      DECL_ERROR_REPORTED (id) = 1;\n-\t    }\n-\t  id = shadowed;\n-\t}\n-      else if (!DECL_ERROR_REPORTED (id))\n-\t{\n-\t  DECL_ERROR_REPORTED (id) = 1;\n-\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (id)))\n-\t    {\n-\t      error (\"name lookup of `%s' changed for new ISO `for' scoping\",\n-\t\t     IDENTIFIER_POINTER (token));\n-\t      cp_error_at (\"  cannot use obsolete binding at `%D' because it has a destructor\", id);\n-\t      id = error_mark_node;\n-\t    }\n-\t  else\n-\t    {\n-\t      pedwarn (\"name lookup of `%s' changed for new ISO `for' scoping\",\n-\t\t       IDENTIFIER_POINTER (token));\n-\t      cp_pedwarn_at (\"  using obsolete binding at `%D'\", id);\n-\t    }\n-\t}\n-    }\n+  id = check_for_out_of_scope_variable (id);\n+\n   /* TREE_USED is set in `hack_identifier'.  */\n   if (TREE_CODE (id) == CONST_DECL)\n     {"}, {"sha": "acb45abbb81a517cedf5ddb8dfa6f1eaa07b7072", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=5f261ba970a894543b1c8c30f71c7eb2a234ba93", "patch": "@@ -308,7 +308,7 @@ check_class_key (key, aggr)\n \n /* __func__, __FUNCTION__ or __PRETTY_FUNCTION__.\n    yylval contains an IDENTIFIER_NODE which indicates which one.  */\n-%token VAR_FUNC_NAME\n+%token <ttype> VAR_FUNC_NAME\n \n /* String constants in raw form.\n    yylval is a STRING_CST node.  */\n@@ -1624,11 +1624,7 @@ primary:\n \t\t       TYPE_DOMAIN (TREE_TYPE ($$)));\n \t\t}\n \t| VAR_FUNC_NAME\n-\t\t{\n-\t\t  $$ = fname_decl (C_RID_CODE ($$), $$);\n-\t\t  if (processing_template_decl)\n-\t\t    $$ = build_min_nt (LOOKUP_EXPR, DECL_NAME ($$));\n-\t\t}\n+               { $$ = finish_fname ($1); }\n \t| '(' expr ')'\n \t\t{ $$ = finish_parenthesized_expr ($2); }\n \t| '(' expr_or_declarator_intern ')'\n@@ -1637,8 +1633,7 @@ primary:\n \t| '(' error ')'\n \t\t{ $$ = error_mark_node; }\n \t| '('\n-\t\t{ tree scope = current_scope ();\n-\t\t  if (!scope || TREE_CODE (scope) != FUNCTION_DECL)\n+\t\t{ if (!at_function_scope_p ())\n \t\t    {\n \t\t      error (\"braced-group within expression allowed only inside a function\");\n \t\t      YYERROR;"}, {"sha": "b7ba0bc4daec234144508a0530b61fd8ef23e927", "filename": "gcc/cp/search.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=5f261ba970a894543b1c8c30f71c7eb2a234ba93", "patch": "@@ -581,6 +581,15 @@ at_function_scope_p ()\n   return cs && TREE_CODE (cs) == FUNCTION_DECL;\n }\n \n+/* Returns true if the innermost active scope is a class scope.  */\n+\n+bool\n+at_class_scope_p ()\n+{\n+  tree cs = current_scope ();\n+  return cs && TYPE_P (cs);\n+}\n+\n /* Return the scope of DECL, as appropriate when doing name-lookup.  */\n \n tree"}, {"sha": "0f671aee2de025e18543e074a06d5e21c58290ac", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f261ba970a894543b1c8c30f71c7eb2a234ba93/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=5f261ba970a894543b1c8c30f71c7eb2a234ba93", "patch": "@@ -1437,6 +1437,20 @@ finish_id_expr (expr)\n   return expr;\n }\n \n+/* Return the declaration for the function-name variable indicated by\n+   ID.  */\n+\n+tree\n+finish_fname (tree id)\n+{\n+  tree decl;\n+  \n+  decl = fname_decl (C_RID_CODE (id), id);\n+  if (processing_template_decl)\n+    decl = build_min_nt (LOOKUP_EXPR, DECL_NAME (decl));\n+  return decl;\n+}\n+\n static tree current_type_lookups;\n \n /* Perform deferred access control for types used in the type of a\n@@ -2025,9 +2039,7 @@ check_multiple_declarators ()\n      We don't just use PROCESSING_TEMPLATE_DECL for the first\n      condition since that would disallow the perfectly legal code, \n      like `template <class T> struct S { int i, j; };'.  */\n-  tree scope = current_scope ();\n-\n-  if (scope && TREE_CODE (scope) == FUNCTION_DECL)\n+  if (at_function_scope_p ())\n     /* It's OK to write `template <class T> void f() { int i, j;}'.  */\n     return;\n      "}]}