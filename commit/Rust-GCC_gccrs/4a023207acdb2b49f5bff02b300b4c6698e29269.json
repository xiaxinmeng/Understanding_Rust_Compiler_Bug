{"sha": "4a023207acdb2b49f5bff02b300b4c6698e29269", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGEwMjMyMDdhY2RiMmI0OWY1YmZmMDJiMzAwYjRjNjY5OGUyOTI2OQ==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-06-29T18:34:38Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-06-29T18:34:38Z"}, "message": "target-def.h: Remove usage of OBJECT_FORMAT_ROSE.\n\n\t* target-def.h: Remove usage of OBJECT_FORMAT_ROSE.\n\t* system.h: Poison OBJ_FORMAT_ROSE.\n\t* doc/tm.texi (Macros for Initialization): Remove documentatin of\n\tOBJECT_FORMAT_ROSE.\n\t* config/rs6000/lynx.h: Remove undef of OBJECT_FORMAT_ROSE.\n\t* collect2.c: Remove usage of OBJECT_FORMAT_ROSE.\n\nFrom-SVN: r68678", "tree": {"sha": "3eef0fd07deb961c930b02dad74a2b2bbbcf3bee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3eef0fd07deb961c930b02dad74a2b2bbbcf3bee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a023207acdb2b49f5bff02b300b4c6698e29269", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a023207acdb2b49f5bff02b300b4c6698e29269", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a023207acdb2b49f5bff02b300b4c6698e29269", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a023207acdb2b49f5bff02b300b4c6698e29269/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5fad1c24dba769d854f9c3a7d37c359ec84c39eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fad1c24dba769d854f9c3a7d37c359ec84c39eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fad1c24dba769d854f9c3a7d37c359ec84c39eb"}], "stats": {"total": 701, "additions": 14, "deletions": 687}, "files": [{"sha": "5318c9a4dfb4bd763aec7da3fa18dd9c631ee211", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a023207acdb2b49f5bff02b300b4c6698e29269/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a023207acdb2b49f5bff02b300b4c6698e29269/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a023207acdb2b49f5bff02b300b4c6698e29269", "patch": "@@ -1,3 +1,11 @@\n+2003-06-29  Andreas Jaeger  <aj@suse.de>\n+\n+\t* target-def.h: Remove usage of OBJECT_FORMAT_ROSE.\n+\t* system.h: Poison OBJ_FORMAT_ROSE.\n+\t* doc/tm.texi (Macros for Initialization): Remove documentatin of\n+\tOBJECT_FORMAT_ROSE.\n+\t* config/rs6000/lynx.h: Remove undef of OBJECT_FORMAT_ROSE.\n+\t* collect2.c: Remove usage of OBJECT_FORMAT_ROSE.\n \n 2003-06-29  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n "}, {"sha": "866b0c1aa6117d947ce837e04e88784fadf907d8", "filename": "gcc/collect2.c", "status": "modified", "additions": 1, "deletions": 675, "changes": 676, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a023207acdb2b49f5bff02b300b4c6698e29269/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a023207acdb2b49f5bff02b300b4c6698e29269/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=4a023207acdb2b49f5bff02b300b4c6698e29269", "patch": "@@ -69,7 +69,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifdef CROSS_COMPILE\n #undef SUNOS4_SHARED_LIBRARIES\n #undef OBJECT_FORMAT_COFF\n-#undef OBJECT_FORMAT_ROSE\n #undef MD_EXEC_PREFIX\n #undef REAL_LD_FILE_NAME\n #undef REAL_NM_FILE_NAME\n@@ -81,7 +80,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    In a cross-compiler, this means you need a cross nm,\n    but that is not quite as unpleasant as special headers.  */\n \n-#if !defined (OBJECT_FORMAT_COFF) && !defined (OBJECT_FORMAT_ROSE)\n+#if !defined (OBJECT_FORMAT_COFF)\n #define OBJECT_FORMAT_NONE\n #endif\n \n@@ -113,24 +112,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #endif /* OBJECT_FORMAT_COFF */\n \n-#ifdef OBJECT_FORMAT_ROSE\n-\n-#ifdef _OSF_SOURCE\n-#define USE_MMAP\n-#endif\n-\n-#ifdef USE_MMAP\n-#include <sys/mman.h>\n-#endif\n-\n-#include <unistd.h>\n-#include <mach_o_format.h>\n-#include <mach_o_header.h>\n-#include <mach_o_vals.h>\n-#include <mach_o_types.h>\n-\n-#endif /* OBJECT_FORMAT_ROSE */\n-\n #ifdef OBJECT_FORMAT_NONE\n \n /* Default flags to pass to nm.  */\n@@ -2856,658 +2837,3 @@ if (debug) fprintf (stderr, \"found: %s\\n\", lib_buf);\n   return (NULL);\n }\n #endif /* COLLECT_EXPORT_LIST */\n-\n-\f\n-/*\n- * OSF/rose specific stuff.\n- */\n-\n-#ifdef OBJECT_FORMAT_ROSE\n-\n-/* Union of the various load commands */\n-\n-typedef union load_union\n-{\n-  ldc_header_t\t\t\thdr;\t/* common header */\n-  load_cmd_map_command_t\tmap;\t/* map indexing other load cmds */\n-  interpreter_command_t\t\tiprtr;\t/* interpreter pathname */\n-  strings_command_t\t\tstr;\t/* load commands strings section */\n-  region_command_t\t\tregion;\t/* region load command */\n-  reloc_command_t\t\treloc;\t/* relocation section */\n-  package_command_t\t\tpkg;\t/* package load command */\n-  symbols_command_t\t\tsym;\t/* symbol sections */\n-  entry_command_t\t\tent;\t/* program start section */\n-  gen_info_command_t\t\tinfo;\t/* object information */\n-  func_table_command_t\t\tfunc;\t/* function constructors/destructors */\n-} load_union_t;\n-\n-/* Structure to point to load command and data section in memory.  */\n-\n-typedef struct load_all\n-{\n-  load_union_t *load;\t\t\t/* load command */\n-  char *section;\t\t\t/* pointer to section */\n-} load_all_t;\n-\n-/* Structure to contain information about a file mapped into memory.  */\n-\n-struct file_info\n-{\n-  char *start;\t\t\t\t/* start of map */\n-  char *name;\t\t\t\t/* filename */\n-  long\tsize;\t\t\t\t/* size of the file */\n-  long  rounded_size;\t\t\t/* size rounded to page boundary */\n-  int\tfd;\t\t\t\t/* file descriptor */\n-  int\trw;\t\t\t\t/* != 0 if opened read/write */\n-  int\tuse_mmap;\t\t\t/* != 0 if mmap'ed */\n-};\n-\n-extern int decode_mach_o_hdr (void);\n-extern int encode_mach_o_hdr (void);\n-\n-static void add_func_table (mo_header_t *, load_all_t *, symbol_info_t *,\n-\t\t\t    int);\n-static void print_header (mo_header_t *);\n-static void print_load_command (load_union_t *, size_t, int);\n-static void bad_header (int);\n-static struct file_info\t*read_file (const char *, int, int);\n-static void end_file (struct file_info *);\n-\f\n-/* OSF/rose specific version to scan the name list of the loaded\n-   program for the symbols g++ uses for static constructors and\n-   destructors.\n-\n-   The constructor table begins at __CTOR_LIST__ and contains a count\n-   of the number of pointers (or -1 if the constructors are built in a\n-   separate section by the linker), followed by the pointers to the\n-   constructor functions, terminated with a null pointer.  The\n-   destructor table has the same format, and begins at __DTOR_LIST__.  */\n-\n-static void\n-scan_prog_file (const char *prog_name, enum pass which_pass)\n-{\n-  char *obj;\n-  mo_header_t hdr;\n-  load_all_t *load_array;\n-  load_all_t *load_end;\n-  load_all_t *load_cmd;\n-  int symbol_load_cmds;\n-  off_t offset;\n-  int i;\n-  int num_syms;\n-  int status;\n-  char *str_sect;\n-  struct file_info *obj_file;\n-  int prog_fd;\n-  mo_lcid_t cmd_strings\t  = -1;\n-  symbol_info_t *main_sym = 0;\n-  int rw\t\t  = (which_pass != PASS_FIRST);\n-\n-  prog_fd = open (prog_name, (rw) ? O_RDWR : O_RDONLY);\n-  if (prog_fd < 0)\n-    fatal_perror (\"open %s\", prog_name);\n-\n-  obj_file = read_file (prog_name, prog_fd, rw);\n-  obj = obj_file->start;\n-\n-  status = decode_mach_o_hdr (obj, MO_SIZEOF_RAW_HDR, MOH_HEADER_VERSION, &hdr);\n-  if (status != MO_HDR_CONV_SUCCESS)\n-    bad_header (status);\n-\n-\n-  /* Do some basic sanity checks.  Note we explicitly use the big endian magic number,\n-     since the hardware will automatically swap bytes for us on loading little endian\n-     integers.  */\n-\n-#ifndef CROSS_COMPILE\n-  if (hdr.moh_magic != MOH_MAGIC_MSB\n-      || hdr.moh_header_version != MOH_HEADER_VERSION\n-      || hdr.moh_byte_order != OUR_BYTE_ORDER\n-      || hdr.moh_data_rep_id != OUR_DATA_REP_ID\n-      || hdr.moh_cpu_type != OUR_CPU_TYPE\n-      || hdr.moh_cpu_subtype != OUR_CPU_SUBTYPE\n-      || hdr.moh_vendor_type != OUR_VENDOR_TYPE)\n-    {\n-      fatal (\"incompatibilities between object file & expected values\");\n-    }\n-#endif\n-\n-  if (debug)\n-    print_header (&hdr);\n-\n-  offset = hdr.moh_first_cmd_off;\n-  load_end = load_array\n-    = (load_all_t *) xcalloc (sizeof (load_all_t), hdr.moh_n_load_cmds + 2);\n-\n-  /* Build array of load commands, calculating the offsets */\n-  for (i = 0; i < hdr.moh_n_load_cmds; i++)\n-    {\n-      load_union_t *load_hdr;\t\t/* load command header */\n-\n-      load_cmd = load_end++;\n-      load_hdr = (load_union_t *) (obj + offset);\n-\n-      /* If modifying the program file, copy the header.  */\n-      if (rw)\n-\t{\n-\t  load_union_t *ptr = (load_union_t *) xmalloc (load_hdr->hdr.ldci_cmd_size);\n-\t  memcpy ((char *)ptr, (char *)load_hdr, load_hdr->hdr.ldci_cmd_size);\n-\t  load_hdr = ptr;\n-\n-\t  /* null out old command map, because we will rewrite at the end.  */\n-\t  if (ptr->hdr.ldci_cmd_type == LDC_CMD_MAP)\n-\t    {\n-\t      cmd_strings = ptr->map.lcm_ld_cmd_strings;\n-\t      ptr->hdr.ldci_cmd_type = LDC_UNDEFINED;\n-\t    }\n-\t}\n-\n-      load_cmd->load = load_hdr;\n-      if (load_hdr->hdr.ldci_section_off > 0)\n-\tload_cmd->section = obj + load_hdr->hdr.ldci_section_off;\n-\n-      if (debug)\n-\tprint_load_command (load_hdr, offset, i);\n-\n-      offset += load_hdr->hdr.ldci_cmd_size;\n-    }\n-\n-  /* If the last command is the load command map and is not undefined,\n-     decrement the count of load commands.  */\n-  if (rw && load_end[-1].load->hdr.ldci_cmd_type == LDC_UNDEFINED)\n-    {\n-      load_end--;\n-      hdr.moh_n_load_cmds--;\n-    }\n-\n-  /* Go through and process each symbol table section.  */\n-  symbol_load_cmds = 0;\n-  for (load_cmd = load_array; load_cmd < load_end; load_cmd++)\n-    {\n-      load_union_t *load_hdr = load_cmd->load;\n-\n-      if (load_hdr->hdr.ldci_cmd_type == LDC_SYMBOLS)\n-\t{\n-\t  symbol_load_cmds++;\n-\n-\t  if (debug)\n-\t    {\n-\t      const char *kind = \"unknown\";\n-\n-\t      switch (load_hdr->sym.symc_kind)\n-\t\t{\n-\t\tcase SYMC_IMPORTS:\t   kind = \"imports\"; break;\n-\t\tcase SYMC_DEFINED_SYMBOLS: kind = \"defined\"; break;\n-\t\tcase SYMC_STABS:\t   kind = \"stabs\";   break;\n-\t\t}\n-\n-\t      notice (\"\\nProcessing symbol table #%d, offset = 0x%.8lx, kind = %s\\n\",\n-\t\t      symbol_load_cmds, load_hdr->hdr.ldci_section_off, kind);\n-\t    }\n-\n-\t  if (load_hdr->sym.symc_kind != SYMC_DEFINED_SYMBOLS)\n-\t    continue;\n-\n-\t  str_sect = load_array[load_hdr->sym.symc_strings_section].section;\n-\t  if (str_sect == (char *) 0)\n-\t    fatal (\"string section missing\");\n-\n-\t  if (load_cmd->section == (char *) 0)\n-\t    fatal (\"section pointer missing\");\n-\n-\t  num_syms = load_hdr->sym.symc_nentries;\n-\t  for (i = 0; i < num_syms; i++)\n-\t    {\n-\t      symbol_info_t *sym = ((symbol_info_t *) load_cmd->section) + i;\n-\t      char *name = sym->si_name.symbol_name + str_sect;\n-\n-\t      if (name[0] != '_')\n-\t\tcontinue;\n-\n-\t      if (rw)\n-\t\t{\n-\t\t  char *n = name + strlen (name) - strlen (NAME__MAIN);\n-\n-\t\t  if ((n - name) < 0 || strcmp (n, NAME__MAIN))\n-\t\t    continue;\n-\t\t  while (n != name)\n-\t\t    if (*--n != '_')\n-\t\t      continue;\n-\n-\t\t  main_sym = sym;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  switch (is_ctor_dtor (name))\n-\t\t    {\n-\t\t    case 1:\n-\t\t      add_to_list (&constructors, name);\n-\t\t      break;\n-\n-\t\t    case 2:\n-\t\t      add_to_list (&destructors, name);\n-\t\t      break;\n-\n-\t\t    default:\t/* not a constructor or destructor */\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\n-\t      if (debug)\n-\t\tfprintf (stderr, \"\\ttype = 0x%.4x, sc = 0x%.2x, flags = 0x%.8x, name = %.30s\\n\",\n-\t\t\t sym->si_type, sym->si_sc_type, sym->si_flags, name);\n-\t    }\n-\t}\n-    }\n-\n-  if (symbol_load_cmds == 0)\n-    fatal (\"no symbol table found\");\n-\n-  /* Update the program file now, rewrite header and load commands.  At present,\n-     we assume that there is enough space after the last load command to insert\n-     one more.  Since the first section written out is page aligned, and the\n-     number of load commands is small, this is ok for the present.  */\n-\n-  if (rw)\n-    {\n-      load_union_t *load_map;\n-      size_t size;\n-\n-      if (cmd_strings == -1)\n-\tfatal (\"no cmd_strings found\");\n-\n-      /* Add __main to initializer list.\n-\t If we are building a program instead of a shared library, do not\n-\t do anything, since in the current version, you cannot do mallocs\n-\t and such in the constructors.  */\n-\n-      if (main_sym != (symbol_info_t *) 0\n-\t  && ((hdr.moh_flags & MOH_EXECABLE_F) == 0))\n-\tadd_func_table (&hdr, load_array, main_sym, FNTC_INITIALIZATION);\n-\n-      if (debug)\n-\tnotice (\"\\nUpdating header and load commands.\\n\\n\");\n-\n-      hdr.moh_n_load_cmds++;\n-      size = sizeof (load_cmd_map_command_t) + (sizeof (mo_offset_t) * (hdr.moh_n_load_cmds - 1));\n-\n-      /* Create new load command map.  */\n-      if (debug)\n-\tnotice (\"load command map, %d cmds, new size %ld.\\n\",\n-\t\t(int) hdr.moh_n_load_cmds, (long) size);\n-\n-      load_map = (load_union_t *) xcalloc (1, size);\n-      load_map->map.ldc_header.ldci_cmd_type = LDC_CMD_MAP;\n-      load_map->map.ldc_header.ldci_cmd_size = size;\n-      load_map->map.lcm_ld_cmd_strings = cmd_strings;\n-      load_map->map.lcm_nentries = hdr.moh_n_load_cmds;\n-      load_array[hdr.moh_n_load_cmds-1].load = load_map;\n-\n-      offset = hdr.moh_first_cmd_off;\n-      for (i = 0; i < hdr.moh_n_load_cmds; i++)\n-\t{\n-\t  load_map->map.lcm_map[i] = offset;\n-\t  if (load_array[i].load->hdr.ldci_cmd_type == LDC_CMD_MAP)\n-\t    hdr.moh_load_map_cmd_off = offset;\n-\n-\t  offset += load_array[i].load->hdr.ldci_cmd_size;\n-\t}\n-\n-      hdr.moh_sizeofcmds = offset - MO_SIZEOF_RAW_HDR;\n-\n-      if (debug)\n-\tprint_header (&hdr);\n-\n-      /* Write header.  */\n-      status = encode_mach_o_hdr (&hdr, obj, MO_SIZEOF_RAW_HDR);\n-      if (status != MO_HDR_CONV_SUCCESS)\n-\tbad_header (status);\n-\n-      if (debug)\n-\tnotice (\"writing load commands.\\n\\n\");\n-\n-      /* Write load commands.  */\n-      offset = hdr.moh_first_cmd_off;\n-      for (i = 0; i < hdr.moh_n_load_cmds; i++)\n-\t{\n-\t  load_union_t *load_hdr = load_array[i].load;\n-\t  size_t size = load_hdr->hdr.ldci_cmd_size;\n-\n-\t  if (debug)\n-\t    print_load_command (load_hdr, offset, i);\n-\n-\t  bcopy ((char *) load_hdr, (char *) (obj + offset), size);\n-\t  offset += size;\n-\t}\n-    }\n-\n-  end_file (obj_file);\n-\n-  if (close (prog_fd))\n-    fatal_perror (\"close %s\", prog_name);\n-\n-  if (debug)\n-    fprintf (stderr, \"\\n\");\n-}\n-\n-\f\n-/* Add a function table to the load commands to call a function on\n-   initiation or termination of the process.  The function takes HDR_P\n-   as pointer to the global header, LOAD_ARRAY as array of pointers to\n-   load commands, SYM as pointer to symbol entry and the fntc_type\n-   value TYPE.  */\n-\n-static void\n-add_func_table (mo_header_t *hdr_p, load_all_t *load_array,\n-\t\tsymbol_info_t *sym, int type)\n-{\n-  /* Add a new load command.  */\n-  int num_cmds = ++hdr_p->moh_n_load_cmds;\n-  int load_index = num_cmds - 1;\n-  size_t size = sizeof (func_table_command_t) + sizeof (mo_addr_t);\n-  load_union_t *ptr = xcalloc (1, size);\n-  load_all_t *load_cmd;\n-  int i;\n-\n-  /* Set the unresolved address bit in the header to force the loader to be\n-     used, since kernel exec does not call the initialization functions.  */\n-  hdr_p->moh_flags |= MOH_UNRESOLVED_F;\n-\n-  load_cmd = &load_array[load_index];\n-  load_cmd->load = ptr;\n-  load_cmd->section = (char *) 0;\n-\n-  /* Fill in func table load command.  */\n-  ptr->func.ldc_header.ldci_cmd_type = LDC_FUNC_TABLE;\n-  ptr->func.ldc_header.ldci_cmd_size = size;\n-  ptr->func.ldc_header.ldci_section_off = 0;\n-  ptr->func.ldc_header.ldci_section_len = 0;\n-  ptr->func.fntc_type = type;\n-  ptr->func.fntc_nentries = 1;\n-\n-  /* copy address, turn it from abs. address to (region,offset) if necessary.  */\n-  /* Is the symbol already expressed as (region, offset)?  */\n-  if ((sym->si_flags & SI_ABSOLUTE_VALUE_F) == 0)\n-    {\n-      ptr->func.fntc_entry_loc[i].adr_lcid = sym->si_value.def_val.adr_lcid;\n-      ptr->func.fntc_entry_loc[i].adr_sctoff = sym->si_value.def_val.adr_sctoff;\n-    }\n-\n-  /* If not, figure out which region it's in.  */\n-  else\n-    {\n-      mo_vm_addr_t addr = sym->si_value.abs_val;\n-      int found = 0;\n-\n-      for (i = 0; i < load_index; i++)\n-\t{\n-\t  if (load_array[i].load->hdr.ldci_cmd_type == LDC_REGION)\n-\t    {\n-\t      region_command_t *region_ptr = &load_array[i].load->region;\n-\n-\t      if ((region_ptr->regc_flags & REG_ABS_ADDR_F) != 0\n-\t\t  && addr >= region_ptr->regc_addr.vm_addr\n-\t\t  && addr <= region_ptr->regc_addr.vm_addr + region_ptr->regc_vm_size)\n-\t\t{\n-\t\t  ptr->func.fntc_entry_loc[0].adr_lcid = i;\n-\t\t  ptr->func.fntc_entry_loc[0].adr_sctoff = addr - region_ptr->regc_addr.vm_addr;\n-\t\t  found++;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (!found)\n-\tfatal (\"could not convert 0x%l.8x into a region\", addr);\n-    }\n-\n-  if (debug)\n-    notice (\"%s function, region %d, offset = %ld (0x%.8lx)\\n\",\n-\t    type == FNTC_INITIALIZATION ? \"init\" : \"term\",\n-\t    (int) ptr->func.fntc_entry_loc[i].adr_lcid,\n-\t    (long) ptr->func.fntc_entry_loc[i].adr_sctoff,\n-\t    (long) ptr->func.fntc_entry_loc[i].adr_sctoff);\n-\n-}\n-\n-\f\n-/* Print the global header for an OSF/rose object.  */\n-\n-static void\n-print_header (mo_header_t *hdr_ptr)\n-{\n-  fprintf (stderr, \"\\nglobal header:\\n\");\n-  fprintf (stderr, \"\\tmoh_magic            = 0x%.8lx\\n\", hdr_ptr->moh_magic);\n-  fprintf (stderr, \"\\tmoh_major_version    = %d\\n\", (int)hdr_ptr->moh_major_version);\n-  fprintf (stderr, \"\\tmoh_minor_version    = %d\\n\", (int)hdr_ptr->moh_minor_version);\n-  fprintf (stderr, \"\\tmoh_header_version   = %d\\n\", (int)hdr_ptr->moh_header_version);\n-  fprintf (stderr, \"\\tmoh_max_page_size    = %d\\n\", (int)hdr_ptr->moh_max_page_size);\n-  fprintf (stderr, \"\\tmoh_byte_order       = %d\\n\", (int)hdr_ptr->moh_byte_order);\n-  fprintf (stderr, \"\\tmoh_data_rep_id      = %d\\n\", (int)hdr_ptr->moh_data_rep_id);\n-  fprintf (stderr, \"\\tmoh_cpu_type         = %d\\n\", (int)hdr_ptr->moh_cpu_type);\n-  fprintf (stderr, \"\\tmoh_cpu_subtype      = %d\\n\", (int)hdr_ptr->moh_cpu_subtype);\n-  fprintf (stderr, \"\\tmoh_vendor_type      = %d\\n\", (int)hdr_ptr->moh_vendor_type);\n-  fprintf (stderr, \"\\tmoh_load_map_cmd_off = %d\\n\", (int)hdr_ptr->moh_load_map_cmd_off);\n-  fprintf (stderr, \"\\tmoh_first_cmd_off    = %d\\n\", (int)hdr_ptr->moh_first_cmd_off);\n-  fprintf (stderr, \"\\tmoh_sizeofcmds       = %d\\n\", (int)hdr_ptr->moh_sizeofcmds);\n-  fprintf (stderr, \"\\tmon_n_load_cmds      = %d\\n\", (int)hdr_ptr->moh_n_load_cmds);\n-  fprintf (stderr, \"\\tmoh_flags            = 0x%.8lx\", (long)hdr_ptr->moh_flags);\n-\n-  if (hdr_ptr->moh_flags & MOH_RELOCATABLE_F)\n-    fprintf (stderr, \", relocatable\");\n-\n-  if (hdr_ptr->moh_flags & MOH_LINKABLE_F)\n-    fprintf (stderr, \", linkable\");\n-\n-  if (hdr_ptr->moh_flags & MOH_EXECABLE_F)\n-    fprintf (stderr, \", execable\");\n-\n-  if (hdr_ptr->moh_flags & MOH_EXECUTABLE_F)\n-    fprintf (stderr, \", executable\");\n-\n-  if (hdr_ptr->moh_flags & MOH_UNRESOLVED_F)\n-    fprintf (stderr, \", unresolved\");\n-\n-  fprintf (stderr, \"\\n\\n\");\n-  return;\n-}\n-\n-\f\n-/* Print a short summary of a load command.  */\n-\n-static void\n-print_load_command (load_union_t *load_hdr, size_t offset, int number)\n-{\n-  mo_long_t type = load_hdr->hdr.ldci_cmd_type;\n-  const char *type_str = (char *) 0;\n-\n-  switch (type)\n-    {\n-    case LDC_UNDEFINED:   type_str = \"UNDEFINED\";\tbreak;\n-    case LDC_CMD_MAP:\t  type_str = \"CMD_MAP\";\t\tbreak;\n-    case LDC_INTERPRETER: type_str = \"INTERPRETER\";\tbreak;\n-    case LDC_STRINGS:\t  type_str = \"STRINGS\";\t\tbreak;\n-    case LDC_REGION:\t  type_str = \"REGION\";\t\tbreak;\n-    case LDC_RELOC:\t  type_str = \"RELOC\";\t\tbreak;\n-    case LDC_PACKAGE:\t  type_str = \"PACKAGE\";\t\tbreak;\n-    case LDC_SYMBOLS:\t  type_str = \"SYMBOLS\";\t\tbreak;\n-    case LDC_ENTRY:\t  type_str = \"ENTRY\";\t\tbreak;\n-    case LDC_FUNC_TABLE:  type_str = \"FUNC_TABLE\";\tbreak;\n-    case LDC_GEN_INFO:\t  type_str = \"GEN_INFO\";\tbreak;\n-    }\n-\n-  fprintf (stderr,\n-\t   \"cmd %2d, sz: 0x%.2lx, coff: 0x%.3lx, doff: 0x%.6lx, dlen: 0x%.6lx\",\n-\t   number,\n-\t   (long) load_hdr->hdr.ldci_cmd_size,\n-\t   (long) offset,\n-\t   (long) load_hdr->hdr.ldci_section_off,\n-\t   (long) load_hdr->hdr.ldci_section_len);\n-\n-  if (type_str == (char *) 0)\n-    fprintf (stderr, \", ty: unknown (%ld)\\n\", (long) type);\n-\n-  else if (type != LDC_REGION)\n-    fprintf (stderr, \", ty: %s\\n\", type_str);\n-\n-  else\n-    {\n-      const char *region = \"\";\n-      switch (load_hdr->region.regc_usage_type)\n-\t{\n-\tcase REG_TEXT_T:\tregion = \", .text\";\tbreak;\n-\tcase REG_DATA_T:\tregion = \", .data\";\tbreak;\n-\tcase REG_BSS_T:\t\tregion = \", .bss\";\tbreak;\n-\tcase REG_GLUE_T:\tregion = \", .glue\";\tbreak;\n-#if defined (REG_RDATA_T) && defined (REG_SDATA_T) && defined (REG_SBSS_T) /*mips*/\n-\tcase REG_RDATA_T:\tregion = \", .rdata\";\tbreak;\n-\tcase REG_SDATA_T:\tregion = \", .sdata\";\tbreak;\n-\tcase REG_SBSS_T:\tregion = \", .sbss\";\tbreak;\n-#endif\n-\t}\n-\n-      fprintf (stderr, \", ty: %s, vaddr: 0x%.8lx, vlen: 0x%.6lx%s\\n\",\n-\t       type_str,\n-\t       (long) load_hdr->region.regc_vm_addr,\n-\t       (long) load_hdr->region.regc_vm_size,\n-\t       region);\n-    }\n-\n-  return;\n-}\n-\n-\f\n-/* Fatal error when {en,de}code_mach_o_header fails.  */\n-\n-static void\n-bad_header (int status)\n-{\n-  switch (status)\n-    {\n-    case MO_ERROR_BAD_MAGIC:\t\tfatal (\"bad magic number\");\n-    case MO_ERROR_BAD_HDR_VERS:\t\tfatal (\"bad header version\");\n-    case MO_ERROR_BAD_RAW_HDR_VERS:\tfatal (\"bad raw header version\");\n-    case MO_ERROR_BUF2SML:\t\tfatal (\"raw header buffer too small\");\n-    case MO_ERROR_OLD_RAW_HDR_FILE:\tfatal (\"old raw header file\");\n-    case MO_ERROR_UNSUPPORTED_VERS:\tfatal (\"unsupported version\");\n-    default:\n-      fatal (\"unknown {de,en}code_mach_o_hdr return value %d\", status);\n-    }\n-}\n-\n-\f\n-/* Read a file into a memory buffer. The file has filename NAME and is\n-   opened with the file descriptor FD for read or write according to\n-   RW.  */\n-\n-static struct file_info *\n-read_file (const char *name, int fd, int rw)\n-{\n-  struct stat stat_pkt;\n-  struct file_info *p = (struct file_info *) xcalloc (sizeof (struct file_info), 1);\n-#ifdef USE_MMAP\n-  static int page_size;\n-#endif\n-\n-  if (fstat (fd, &stat_pkt) < 0)\n-    fatal_perror (\"fstat %s\", name);\n-\n-  p->name\t  = name;\n-  p->size\t  = stat_pkt.st_size;\n-  p->rounded_size = stat_pkt.st_size;\n-  p->fd\t\t  = fd;\n-  p->rw\t\t  = rw;\n-\n-#ifdef USE_MMAP\n-  if (debug)\n-    fprintf (stderr, \"mmap %s, %s\\n\", name, (rw) ? \"read/write\" : \"read-only\");\n-\n-  if (page_size == 0)\n-    page_size = sysconf (_SC_PAGE_SIZE);\n-\n-  p->rounded_size = ((p->size + page_size - 1) / page_size) * page_size;\n-  p->start = mmap ((caddr_t) 0,\n-\t\t   (rw) ? p->rounded_size : p->size,\n-\t\t   (rw) ? (PROT_READ | PROT_WRITE) : PROT_READ,\n-\t\t   MAP_FILE | MAP_VARIABLE | MAP_SHARED,\n-\t\t   fd,\n-\t\t   0L);\n-\n-  if (p->start != (char *) 0 && p->start != (char *) -1)\n-    p->use_mmap = 1;\n-\n-  else\n-#endif /* USE_MMAP */\n-    {\n-      long len;\n-\n-      if (debug)\n-\tfprintf (stderr, \"read %s\\n\", name);\n-\n-      p->use_mmap = 0;\n-      p->start = xmalloc (p->size);\n-      if (lseek (fd, 0L, SEEK_SET) < 0)\n-\tfatal_perror (\"lseek %s 0\", name);\n-\n-      len = read (fd, p->start, p->size);\n-      if (len < 0)\n-\tfatal_perror (\"read %s\", name);\n-\n-      if (len != p->size)\n-\tfatal (\"read %ld bytes, expected %ld, from %s\", len, p->size, name);\n-    }\n-\n-  return p;\n-}\n-\f\n-/* Do anything necessary to write a file back from memory.  */\n-\n-static void\n-end_file (struct file_info *pt)\n-{\n-#ifdef USE_MMAP\n-  if (ptr->use_mmap)\n-    {\n-      if (ptr->rw)\n-\t{\n-\t  if (debug)\n-\t    fprintf (stderr, \"msync %s\\n\", ptr->name);\n-\n-\t  if (msync (ptr->start, ptr->rounded_size, MS_ASYNC))\n-\t    fatal_perror (\"msync %s\", ptr->name);\n-\t}\n-\n-      if (debug)\n-\tfprintf (stderr, \"munmap %s\\n\", ptr->name);\n-\n-      if (munmap (ptr->start, ptr->size))\n-\tfatal_perror (\"munmap %s\", ptr->name);\n-    }\n-  else\n-#endif /* USE_MMAP */\n-    {\n-      if (ptr->rw)\n-\t{\n-\t  long len;\n-\n-\t  if (debug)\n-\t    fprintf (stderr, \"write %s\\n\", ptr->name);\n-\n-\t  if (lseek (ptr->fd, 0L, SEEK_SET) < 0)\n-\t    fatal_perror (\"lseek %s 0\", ptr->name);\n-\n-\t  len = write (ptr->fd, ptr->start, ptr->size);\n-\t  if (len < 0)\n-\t    fatal_perror (\"write %s\", ptr->name);\n-\n-\t  if (len != ptr->size)\n-\t    fatal (\"wrote %ld bytes, expected %ld, to %s\", len, ptr->size, ptr->name);\n-\t}\n-\n-      free (ptr->start);\n-    }\n-\n-  free (ptr);\n-}\n-\n-#endif /* OBJECT_FORMAT_ROSE */"}, {"sha": "04ed1219aab23c38ecf0769ad4ec7f64d20098cf", "filename": "gcc/config/rs6000/lynx.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a023207acdb2b49f5bff02b300b4c6698e29269/gcc%2Fconfig%2Frs6000%2Flynx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a023207acdb2b49f5bff02b300b4c6698e29269/gcc%2Fconfig%2Frs6000%2Flynx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flynx.h?ref=4a023207acdb2b49f5bff02b300b4c6698e29269", "patch": "@@ -103,7 +103,6 @@ do {\t\t\t\t\t\t\t\t\\\n /* For collect2 */\n #define OBJECT_FORMAT_NONE\n #undef OBJECT_FORMAT_COFF\n-#undef OBJECT_FORMAT_ROSE\n #undef MD_EXEC_PREFIX\n #undef REAL_LD_FILE_NAME\n #undef REAL_STRIP_FILE_NAME"}, {"sha": "1f52fcbd89d6c6e78dea24858149a4e440a5e02a", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a023207acdb2b49f5bff02b300b4c6698e29269/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a023207acdb2b49f5bff02b300b4c6698e29269/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=4a023207acdb2b49f5bff02b300b4c6698e29269", "patch": "@@ -7118,21 +7118,15 @@ If your system uses @command{collect2} as the means of processing\n constructors, then that program normally uses @command{nm} to scan\n an object file for constructor functions to be called.\n \n-On certain kinds of systems, you can define these macros to make\n+On certain kinds of systems, you can define this macro to make\n @command{collect2} work faster (and, in some cases, make it work at all):\n \n @defmac OBJECT_FORMAT_COFF\n Define this macro if the system uses COFF (Common Object File Format)\n object files, so that @command{collect2} can assume this format and scan\n object files directly for dynamic constructor/destructor functions.\n-@end defmac\n-\n-@defmac OBJECT_FORMAT_ROSE\n-Define this macro if the system uses ROSE format object files, so that\n-@command{collect2} can assume this format and scan object files directly\n-for dynamic constructor/destructor functions.\n \n-These macros are effective only in a native compiler; @command{collect2} as\n+This macro is effective only in a native compiler; @command{collect2} as\n part of a cross compiler always uses @command{nm} for the target machine.\n @end defmac\n "}, {"sha": "369f5660d5f2f969b6c77330aea019d366d1b090", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a023207acdb2b49f5bff02b300b4c6698e29269/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a023207acdb2b49f5bff02b300b4c6698e29269/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=4a023207acdb2b49f5bff02b300b4c6698e29269", "patch": "@@ -621,7 +621,7 @@ typedef char _Bool;\n \tDBX_LBRAC_FIRST DBX_OUTPUT_ENUM DBX_OUTPUT_SOURCE_FILENAME\t   \\\n \tDBX_WORKING_DIRECTORY INSN_CACHE_DEPTH INSN_CACHE_SIZE\t\t   \\\n \tINSN_CACHE_LINE_WIDTH INIT_SECTION_PREAMBLE NEED_ATEXIT ON_EXIT\t   \\\n-\tEXIT_BODY\n+\tEXIT_BODY OBJECT_FORMAT_ROSE\n \n /* Hooks that are no longer used.  */\n  #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE\t\\"}, {"sha": "e3c4df1d670670274e853e01ac25d2e7e0039c65", "filename": "gcc/target-def.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a023207acdb2b49f5bff02b300b4c6698e29269/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a023207acdb2b49f5bff02b300b4c6698e29269/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=4a023207acdb2b49f5bff02b300b4c6698e29269", "patch": "@@ -40,7 +40,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_ASM_ALIGNED_TI_OP NULL\n \n /* GAS and SYSV4 assemblers accept these.  */\n-#if defined (OBJECT_FORMAT_ELF) || defined (OBJECT_FORMAT_ROSE)\n+#if defined (OBJECT_FORMAT_ELF)\n #define TARGET_ASM_UNALIGNED_HI_OP \"\\t.2byte\\t\"\n #define TARGET_ASM_UNALIGNED_SI_OP \"\\t.4byte\\t\"\n #define TARGET_ASM_UNALIGNED_DI_OP \"\\t.8byte\\t\"\n@@ -50,7 +50,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_ASM_UNALIGNED_SI_OP NULL\n #define TARGET_ASM_UNALIGNED_DI_OP NULL\n #define TARGET_ASM_UNALIGNED_TI_OP NULL\n-#endif /* OBJECT_FORMAT_ELF || OBJECT_FORMAT_ROSE */\n+#endif /* OBJECT_FORMAT_ELF */\n \n #define TARGET_ASM_INTEGER default_assemble_integer\n "}]}