{"sha": "1923d2d6716bf5c1c45dbe285e0774f05611be05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkyM2QyZDY3MTZiZjVjMWM0NWRiZTI4NWUwNzc0ZjA1NjExYmUwNQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2008-03-26T07:39:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-03-26T07:39:17Z"}, "message": "exp_disp.adb (Make_DT, [...]): Set attribute Is_Static_Dispatch_Table\n\n2008-03-26  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.adb (Make_DT, Make_Secondary_DT): Set attribute\n\tIs_Static_Dispatch_Table\n\t(Build_Dispatch_Tables): Replace calls to Exchange_Entities() by calls\n\tto Exchange_Declarations to exchange the private and full-view. Bug\n\tfound working in this issue.\n\t(Expand_Dispatching_Call): Propagate the convention of the subprogram\n\tto the subprogram pointer type.\n\t(Make_Secondary_DT): Replace generation of Prim'Address by\n\tAddress (Prim'Unrestricted_Access)\n\t(Make_DT): Replace generation of Prim'Address by\n\tAddress (Prim'Unrestricted_Access)\n\t(Make_Disp_*_Bodies): When compiling for a restricted profile, use\n\tsimple call form for single entry.\n\t(Make_DT): Handle new contents of Access_Disp_Table (access to dispatch\n\ttables of predefined primitives).\n\t(Make_Secondary_DT): Add support to handle access to dispatch tables of\n\tpredefined primitives.\n\t(Make_Tags): Add entities to Access_Dispatch_Table associated with\n\taccess to dispatch tables containing predefined primitives.\n\n\t* exp_ch6.adb (N_Pragma): Chars field removed, use Chars\n\t(Pragma_Identifier (..  instead, adjustments throughout to accomodate\n\tthis change.\n\t(Register_Predefined_DT_Entry): Updated to handle the new contents\n\tof attribute Access_Disp_Table (pointers to dispatch tables containing\n\tpredefined primitives).\n\n\t* exp_util.ads, exp_util.adb (Corresponding_Runtime_Package): New\n\tsubprogram.\n\t(Find_Interface_ADT): Updated to skip the new contents of attribute\n\tAccess_Dispatch_Table (pointers to dispatch tables containing predefined\n\tprimitives).\n\n\t* sem_util.adb (Has_Abstract_Interfaces): Add missing support for\n\tconcurrent types.\n\t(Set_Convention): Use new function Is_Access_Subprogram_Type\n\t(Collect_Interfaces_Info): Updated to skip the new contents of attribute\n\tAccess_Dispatch_Table (pointers to dispatch tables containing predefined\n\tprimitives).\n\n\t* exp_atag.ads, exp_atag.adb (Build_Inherit_Predefined_Prims): Improve\n\texpanded code avoiding calls to Build_Predef_Prims.\n\t(Build_Set_Predefined_Prim_Op_Address): Improve expanded code avoiding\n\tcall to Build_Get_Predefined_Prim_Op_Address.\n\nFrom-SVN: r133564", "tree": {"sha": "535fe9f7a2bfeba1b8bafd9aa970c714dda36fad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/535fe9f7a2bfeba1b8bafd9aa970c714dda36fad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1923d2d6716bf5c1c45dbe285e0774f05611be05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1923d2d6716bf5c1c45dbe285e0774f05611be05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1923d2d6716bf5c1c45dbe285e0774f05611be05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1923d2d6716bf5c1c45dbe285e0774f05611be05/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "50cff36721cc8783eb7ac2b350dc200688f8e0da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50cff36721cc8783eb7ac2b350dc200688f8e0da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50cff36721cc8783eb7ac2b350dc200688f8e0da"}], "stats": {"total": 1273, "additions": 849, "deletions": 424}, "files": [{"sha": "c2c37a7eb30a0aa1534c111f80854f7c271e6faa", "filename": "gcc/ada/exp_atag.adb", "status": "modified", "additions": 34, "deletions": 59, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1923d2d6716bf5c1c45dbe285e0774f05611be05/gcc%2Fada%2Fexp_atag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1923d2d6716bf5c1c45dbe285e0774f05611be05/gcc%2Fada%2Fexp_atag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.adb?ref=1923d2d6716bf5c1c45dbe285e0774f05611be05", "patch": "@@ -369,64 +369,32 @@ package body Exp_Atag is\n       New_Tag_Node : Node_Id) return Node_Id\n    is\n    begin\n-      if RTE_Available (RE_DT) then\n-         return\n-           Make_Assignment_Statement (Loc,\n-             Name =>\n-               Make_Slice (Loc,\n-                 Prefix =>\n-                   Make_Explicit_Dereference (Loc,\n-                     Unchecked_Convert_To (RTE (RE_Predef_Prims_Table_Ptr),\n-                       Make_Selected_Component (Loc,\n-                         Prefix =>\n-                           Build_DT (Loc, New_Tag_Node),\n-                         Selector_Name =>\n-                           New_Reference_To\n-                             (RTE_Record_Component (RE_Predef_Prims), Loc)))),\n-                 Discrete_Range => Make_Range (Loc,\n-                   Make_Integer_Literal (Loc, Uint_1),\n-                   New_Reference_To (RTE (RE_Max_Predef_Prims), Loc))),\n-\n-             Expression =>\n-               Make_Slice (Loc,\n-                 Prefix =>\n-                   Make_Explicit_Dereference (Loc,\n-                     Unchecked_Convert_To (RTE (RE_Predef_Prims_Table_Ptr),\n-                       Make_Selected_Component (Loc,\n-                         Prefix =>\n-                           Build_DT (Loc, Old_Tag_Node),\n-                         Selector_Name =>\n-                           New_Reference_To\n-                             (RTE_Record_Component (RE_Predef_Prims), Loc)))),\n-\n-                 Discrete_Range =>\n-                   Make_Range (Loc,\n-                     Low_Bound  => Make_Integer_Literal (Loc, 1),\n-                     High_Bound =>\n-                       New_Reference_To (RTE (RE_Max_Predef_Prims), Loc))));\n-      else\n-         return\n-           Make_Assignment_Statement (Loc,\n-             Name =>\n-               Make_Slice (Loc,\n-                 Prefix =>\n-                   Make_Explicit_Dereference (Loc,\n-                     Build_Predef_Prims (Loc, New_Tag_Node)),\n-                 Discrete_Range => Make_Range (Loc,\n-                   Make_Integer_Literal (Loc, Uint_1),\n-                   New_Reference_To (RTE (RE_Max_Predef_Prims), Loc))),\n+      return\n+        Make_Assignment_Statement (Loc,\n+          Name =>\n+            Make_Slice (Loc,\n+              Prefix =>\n+                Make_Explicit_Dereference (Loc,\n+                  Unchecked_Convert_To (RTE (RE_Predef_Prims_Table_Ptr),\n+                    Make_Explicit_Dereference (Loc,\n+                      Unchecked_Convert_To (RTE (RE_Addr_Ptr),\n+                        New_Tag_Node)))),\n+              Discrete_Range => Make_Range (Loc,\n+                Make_Integer_Literal (Loc, Uint_1),\n+                New_Reference_To (RTE (RE_Max_Predef_Prims), Loc))),\n \n-             Expression =>\n-               Make_Slice (Loc,\n-                 Prefix =>\n-                   Make_Explicit_Dereference (Loc,\n-                     Build_Predef_Prims (Loc, Old_Tag_Node)),\n-                 Discrete_Range =>\n-                   Make_Range (Loc,\n-                     Low_Bound  => Make_Integer_Literal (Loc, 1),\n-                     High_Bound =>\n-                       New_Reference_To (RTE (RE_Max_Predef_Prims), Loc))));\n-      end if;\n+          Expression =>\n+            Make_Slice (Loc,\n+              Prefix =>\n+                Make_Explicit_Dereference (Loc,\n+                  Unchecked_Convert_To (RTE (RE_Predef_Prims_Table_Ptr),\n+                    Make_Explicit_Dereference (Loc,\n+                      Unchecked_Convert_To (RTE (RE_Addr_Ptr),\n+                        Old_Tag_Node)))),\n+              Discrete_Range =>\n+                Make_Range (Loc,\n+                  Make_Integer_Literal (Loc, 1),\n+                  New_Reference_To (RTE (RE_Max_Predef_Prims), Loc))));\n    end Build_Inherit_Predefined_Prims;\n \n    ------------------------\n@@ -472,8 +440,15 @@ package body Exp_Atag is\n    begin\n       return\n          Make_Assignment_Statement (Loc,\n-           Name       => Build_Get_Predefined_Prim_Op_Address (Loc,\n-                           Tag_Node, Position),\n+           Name =>\n+             Make_Indexed_Component (Loc,\n+               Prefix =>\n+                 Unchecked_Convert_To (RTE (RE_Predef_Prims_Table_Ptr),\n+                   Make_Explicit_Dereference (Loc,\n+                     Unchecked_Convert_To (RTE (RE_Addr_Ptr), Tag_Node))),\n+               Expressions =>\n+                 New_List (Make_Integer_Literal (Loc, Position))),\n+\n            Expression => Address_Node);\n    end Build_Set_Predefined_Prim_Op_Address;\n "}, {"sha": "9d724f291407e9687c8e00b7655dd8df18ce8a0b", "filename": "gcc/ada/exp_atag.ads", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1923d2d6716bf5c1c45dbe285e0774f05611be05/gcc%2Fada%2Fexp_atag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1923d2d6716bf5c1c45dbe285e0774f05611be05/gcc%2Fada%2Fexp_atag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.ads?ref=1923d2d6716bf5c1c45dbe285e0774f05611be05", "patch": "@@ -90,15 +90,16 @@ package Exp_Atag is\n    --  Generates: TSD (Tag).Transportable;\n \n    function Build_Inherit_Predefined_Prims\n-     (Loc              : Source_Ptr;\n-      Old_Tag_Node     : Node_Id;\n-      New_Tag_Node     : Node_Id) return Node_Id;\n+     (Loc          : Source_Ptr;\n+      Old_Tag_Node : Node_Id;\n+      New_Tag_Node : Node_Id) return Node_Id;\n    --  Build code that inherits the predefined primitives of the parent.\n    --\n    --  Generates: Predefined_DT (New_T).D (All_Predefined_Prims) :=\n    --               Predefined_DT (Old_T).D (All_Predefined_Prims);\n    --\n-   --  Required to build the dispatch tables with the 3.4 backend.\n+   --  Required to build non-library level dispatch tables. Also required\n+   --  when compiling without static dispatch tables support.\n \n    function Build_Inherit_Prims\n      (Loc          : Source_Ptr;"}, {"sha": "c5f88c7a8987e0733b29084cf8382c923ae575c6", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1923d2d6716bf5c1c45dbe285e0774f05611be05/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1923d2d6716bf5c1c45dbe285e0774f05611be05/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=1923d2d6716bf5c1c45dbe285e0774f05611be05", "patch": "@@ -3388,7 +3388,7 @@ package body Exp_Ch6 is\n          --  not be posting warnings on the inlined body so it is unneeded.\n \n          elsif Nkind (N) = N_Pragma\n-           and then Chars (N) = Name_Unreferenced\n+           and then Pragma_Name (N) = Name_Unreferenced\n          then\n             Rewrite (N, Make_Null_Statement (Sloc (N)));\n             return OK;\n@@ -4756,14 +4756,14 @@ package body Exp_Ch6 is\n             return;\n          end if;\n \n-         --  Skip the first access-to-dispatch-table pointer since it leads\n-         --  to the primary dispatch table. We are only concerned with the\n-         --  secondary dispatch table pointers. Note that the access-to-\n-         --  dispatch-table pointer corresponds to the first implemented\n-         --  interface retrieved below.\n+         --  Skip the first two access-to-dispatch-table pointers since they\n+         --  leads to the primary dispatch table (predefined DT and user\n+         --  defined DT). We are only concerned with the secondary dispatch\n+         --  table pointers. Note that the access-to- dispatch-table pointer\n+         --  corresponds to the first implemented interface retrieved below.\n \n          Iface_DT_Ptr :=\n-           Next_Elmt (First_Elmt (Access_Disp_Table (Tagged_Typ)));\n+           Next_Elmt (Next_Elmt (First_Elmt (Access_Disp_Table (Tagged_Typ))));\n \n          while Present (Iface_DT_Ptr)\n             and then Ekind (Node (Iface_DT_Ptr)) = E_Constant\n@@ -4776,23 +4776,41 @@ package body Exp_Ch6 is\n                  Thunk_Code,\n \n                  Build_Set_Predefined_Prim_Op_Address (Loc,\n-                   Tag_Node => New_Reference_To (Node (Iface_DT_Ptr), Loc),\n+                   Tag_Node =>\n+                     New_Reference_To (Node (Next_Elmt (Iface_DT_Ptr)), Loc),\n                    Position => DT_Position (Prim),\n                    Address_Node =>\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix         => New_Reference_To (Thunk_Id, Loc),\n-                       Attribute_Name => Name_Address)),\n+                     Unchecked_Convert_To (RTE (RE_Address),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix         => New_Reference_To (Thunk_Id, Loc),\n+                         Attribute_Name => Name_Unrestricted_Access))),\n \n                  Build_Set_Predefined_Prim_Op_Address (Loc,\n-                   Tag_Node => New_Reference_To\n-                                 (Node (Next_Elmt (Iface_DT_Ptr)), Loc),\n+                   Tag_Node =>\n+                     New_Reference_To\n+                      (Node (Next_Elmt (Next_Elmt (Next_Elmt (Iface_DT_Ptr)))),\n+                       Loc),\n                    Position => DT_Position (Prim),\n                    Address_Node =>\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix         => New_Reference_To (Prim, Loc),\n-                       Attribute_Name => Name_Address))));\n+                     Unchecked_Convert_To (RTE (RE_Address),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix         => New_Reference_To (Prim, Loc),\n+                         Attribute_Name => Name_Unrestricted_Access)))));\n             end if;\n \n+            --  Skip the tag of the predefined primitives dispatch table\n+\n+            Next_Elmt (Iface_DT_Ptr);\n+            pragma Assert (Has_Thunks (Node (Iface_DT_Ptr)));\n+\n+            --  Skip the tag of the no-thunks dispatch table\n+\n+            Next_Elmt (Iface_DT_Ptr);\n+            pragma Assert (not Has_Thunks (Node (Iface_DT_Ptr)));\n+\n+            --  Skip the tag of the predefined primitives no-thunks dispatch\n+            --  table\n+\n             Next_Elmt (Iface_DT_Ptr);\n             pragma Assert (not Has_Thunks (Node (Iface_DT_Ptr)));\n "}, {"sha": "c14c7348dea2ed1180f7f28c758c18222782a081", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 577, "deletions": 306, "changes": 883, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1923d2d6716bf5c1c45dbe285e0774f05611be05/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1923d2d6716bf5c1c45dbe285e0774f05611be05/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=1923d2d6716bf5c1c45dbe285e0774f05611be05", "patch": "@@ -46,6 +46,7 @@ with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch6;  use Sem_Ch6;\n+with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n@@ -175,14 +176,14 @@ package body Exp_Disp is\n                           /= E_Record_Subtype\n             then\n                declare\n-                  E1, E2 : Entity_Id;\n+                  E1 : constant Entity_Id := Defining_Entity (D);\n+                  E2 : constant Entity_Id := Full_View (Defining_Entity (D));\n+\n                begin\n-                  E1 := Defining_Entity (D);\n-                  E2 := Full_View (Defining_Entity (D));\n-                  Exchange_Entities (E1, E2);\n+                  Exchange_Declarations (E1);\n                   Insert_List_After_And_Analyze (Last (Target_List),\n                     Make_DT (E1));\n-                  Exchange_Entities (E1, E2);\n+                  Exchange_Declarations (E2);\n                end;\n             end if;\n \n@@ -612,6 +613,7 @@ package body Exp_Disp is\n \n       Set_Etype (Subp_Ptr_Typ, Subp_Ptr_Typ);\n       Set_Directly_Designated_Type (Subp_Ptr_Typ, Subp_Typ);\n+      Set_Convention (Subp_Ptr_Typ, Convention (Subp_Typ));\n \n       --  If the controlling argument is a value of type Ada.Tag or an abstract\n       --  interface class-wide type then use it directly. Otherwise, the tag\n@@ -1531,6 +1533,7 @@ package body Exp_Disp is\n       Decls     : constant List_Id    := New_List;\n       DT_Ptr    : Entity_Id;\n       Loc       : constant Source_Ptr := Sloc (Typ);\n+      Obj_Ref   : Node_Id;\n       Stmts     : constant List_Id    := New_List;\n \n    begin\n@@ -1593,46 +1596,78 @@ package body Exp_Disp is\n                 Object_Definition =>\n                   New_Reference_To (RTE (RE_Communication_Block), Loc)));\n \n-            --  Generate:\n-            --    Protected_Entry_Call\n-            --      (T._object'Access,            --  Object\n-            --       Protected_Entry_Index! (I),  --  E\n-            --       P,                           --  Uninterpreted_Data\n-            --       Asynchronous_Call,           --  Mode\n-            --       Bnn);                        --  Communication_Block\n+            --  Build T._object'Access for calls below\n \n-            --  where T is the protected object, I is the entry index, P are\n-            --  the wrapped parameters and B is the name of the communication\n-            --  block.\n+            Obj_Ref :=\n+               Make_Attribute_Reference (Loc,\n+                 Attribute_Name => Name_Unchecked_Access,\n+                 Prefix         =>\n+                   Make_Selected_Component (Loc,\n+                     Prefix        => Make_Identifier (Loc, Name_uT),\n+                     Selector_Name => Make_Identifier (Loc, Name_uObject)));\n \n-            Append_To (Stmts,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name =>\n-                  New_Reference_To (RTE (RE_Protected_Entry_Call), Loc),\n-                Parameter_Associations =>\n-                  New_List (\n+            case Corresponding_Runtime_Package (Conc_Typ) is\n+               when System_Tasking_Protected_Objects_Entries =>\n \n-                    Make_Attribute_Reference (Loc,        -- T._object'Access\n-                      Attribute_Name =>\n-                        Name_Unchecked_Access,\n-                      Prefix =>\n-                        Make_Selected_Component (Loc,\n-                          Prefix =>\n-                            Make_Identifier (Loc, Name_uT),\n-                          Selector_Name =>\n-                            Make_Identifier (Loc, Name_uObject))),\n+                  --  Generate:\n+                  --    Protected_Entry_Call\n+                  --      (T._object'Access,            --  Object\n+                  --       Protected_Entry_Index! (I),  --  E\n+                  --       P,                           --  Uninterpreted_Data\n+                  --       Asynchronous_Call,           --  Mode\n+                  --       Bnn);                        --  Communication_Block\n+\n+                  --  where T is the protected object, I is the entry index, P\n+                  --  is the wrapped parameters and B is the name of the\n+                  --  communication block.\n+\n+                  Append_To (Stmts,\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name =>\n+                        New_Reference_To (RTE (RE_Protected_Entry_Call), Loc),\n+                      Parameter_Associations =>\n+                        New_List (\n+                          Obj_Ref,\n \n-                    Make_Unchecked_Type_Conversion (Loc,  --  entry index\n-                      Subtype_Mark =>\n-                        New_Reference_To (RTE (RE_Protected_Entry_Index), Loc),\n-                      Expression =>\n-                        Make_Identifier (Loc, Name_uI)),\n+                          Make_Unchecked_Type_Conversion (Loc,  --  entry index\n+                            Subtype_Mark =>\n+                              New_Reference_To\n+                                 (RTE (RE_Protected_Entry_Index), Loc),\n+                            Expression => Make_Identifier (Loc, Name_uI)),\n \n-                    Make_Identifier (Loc, Name_uP),       --  parameter block\n-                    New_Reference_To (                    --  Asynchronous_Call\n-                      RTE (RE_Asynchronous_Call), Loc),\n+                          Make_Identifier (Loc, Name_uP), --  parameter block\n+                          New_Reference_To (              --  Asynchronous_Call\n+                            RTE (RE_Asynchronous_Call), Loc),\n+\n+                          New_Reference_To (Com_Block, Loc)))); -- comm block\n+\n+               when System_Tasking_Protected_Objects_Single_Entry =>\n+\n+                  --  Generate:\n+                  --    procedure Protected_Single_Entry_Call\n+                  --      (Object              : Protection_Entry_Access;\n+                  --       Uninterpreted_Data  : System.Address;\n+                  --       Mode                : Call_Modes);\n \n-                    New_Reference_To (Com_Block, Loc)))); -- comm block\n+                  Append_To (Stmts,\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name =>\n+                        New_Reference_To\n+                          (RTE (RE_Protected_Single_Entry_Call), Loc),\n+                      Parameter_Associations =>\n+                        New_List (\n+                          Obj_Ref,\n+\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix => Make_Identifier (Loc, Name_uP),\n+                            Attribute_Name => Name_Address),\n+\n+                            New_Reference_To\n+                             (RTE (RE_Asynchronous_Call), Loc))));\n+\n+               when others =>\n+                  raise Program_Error;\n+            end case;\n \n             --  Generate:\n             --    B := Dummy_Communication_Block (Bnn);\n@@ -1660,7 +1695,7 @@ package body Exp_Disp is\n             --       Asynchronous_Call,      --  Mode\n             --       F);                     --  Rendezvous_Successful\n \n-            --  where T is the task object, I is the entry index, P are the\n+            --  where T is the task object, I is the entry index, P is the\n             --  wrapped parameters and F is the status flag.\n \n             Append_To (Stmts,\n@@ -1669,7 +1704,6 @@ package body Exp_Disp is\n                   New_Reference_To (RTE (RE_Task_Entry_Call), Loc),\n                 Parameter_Associations =>\n                   New_List (\n-\n                     Make_Selected_Component (Loc,         -- T._task_id\n                       Prefix =>\n                         Make_Identifier (Loc, Name_uT),\n@@ -1843,6 +1877,7 @@ package body Exp_Disp is\n       Conc_Typ : Entity_Id           := Empty;\n       Decls    : constant List_Id    := New_List;\n       DT_Ptr   : Entity_Id;\n+      Obj_Ref  : Node_Id;\n       Stmts    : constant List_Id    := New_List;\n \n    begin\n@@ -1929,46 +1964,73 @@ package body Exp_Disp is\n \n          if Ekind (Conc_Typ) = E_Protected_Type then\n \n-            --  Generate:\n-            --    Protected_Entry_Call\n-            --      (T._object'Access,            --  Object\n-            --       Protected_Entry_Index! (I),  --  E\n-            --       P,                           --  Uninterpreted_Data\n-            --       Conditional_Call,            --  Mode\n-            --       Bnn);                        --  Block\n+            Obj_Ref :=                                  -- T._object'Access\n+               Make_Attribute_Reference (Loc,\n+                 Attribute_Name => Name_Unchecked_Access,\n+                 Prefix         =>\n+                   Make_Selected_Component (Loc,\n+                     Prefix        => Make_Identifier (Loc, Name_uT),\n+                     Selector_Name => Make_Identifier (Loc, Name_uObject)));\n \n-            --  where T is the protected object, I is the entry index, P are\n-            --  the wrapped parameters and Bnn is the name of the communication\n-            --  block.\n+            case Corresponding_Runtime_Package (Conc_Typ) is\n+               when System_Tasking_Protected_Objects_Entries =>\n+                  --  Generate:\n \n-            Append_To (Stmts,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name =>\n-                  New_Reference_To (RTE (RE_Protected_Entry_Call), Loc),\n-                Parameter_Associations =>\n-                  New_List (\n+                  --    Protected_Entry_Call\n+                  --      (T._object'Access,            --  Object\n+                  --       Protected_Entry_Index! (I),  --  E\n+                  --       P,                           --  Uninterpreted_Data\n+                  --       Conditional_Call,            --  Mode\n+                  --       Bnn);                        --  Block\n \n-                    Make_Attribute_Reference (Loc,        -- T._object'Access\n-                      Attribute_Name =>\n-                        Name_Unchecked_Access,\n-                      Prefix =>\n-                        Make_Selected_Component (Loc,\n-                          Prefix =>\n-                            Make_Identifier (Loc, Name_uT),\n-                          Selector_Name =>\n-                            Make_Identifier (Loc, Name_uObject))),\n+                  --  where T is the protected object, I is the entry index, P\n+                  --  are the wrapped parameters and Bnn is the name of the\n+                  --  communication block.\n \n-                    Make_Unchecked_Type_Conversion (Loc,  --  entry index\n-                      Subtype_Mark =>\n-                        New_Reference_To (RTE (RE_Protected_Entry_Index), Loc),\n-                      Expression =>\n-                        Make_Identifier (Loc, Name_uI)),\n+                  Append_To (Stmts,\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name =>\n+                        New_Reference_To (RTE (RE_Protected_Entry_Call), Loc),\n+                      Parameter_Associations =>\n+                        New_List (\n+                          Obj_Ref,\n \n-                    Make_Identifier (Loc, Name_uP),       --  parameter block\n-                    New_Reference_To (                    --  Conditional_Call\n-                      RTE (RE_Conditional_Call), Loc),\n-                    New_Reference_To (                    --  Bnn\n-                      Blk_Nam, Loc))));\n+                          Make_Unchecked_Type_Conversion (Loc,  --  entry index\n+                            Subtype_Mark =>\n+                              New_Reference_To\n+                                 (RTE (RE_Protected_Entry_Index), Loc),\n+                            Expression => Make_Identifier (Loc, Name_uI)),\n+\n+                          Make_Identifier (Loc, Name_uP),  --  parameter block\n+\n+                          New_Reference_To (               --  Conditional_Call\n+                            RTE (RE_Conditional_Call), Loc),\n+                          New_Reference_To (               --  Bnn\n+                            Blk_Nam, Loc))));\n+\n+               when System_Tasking_Protected_Objects_Single_Entry =>\n+\n+                  --    If we are compiling for a restricted run-time, the call\n+                  --    uses the simpler form.\n+\n+                  Append_To (Stmts,\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name =>\n+                        New_Reference_To\n+                          (RTE (RE_Protected_Single_Entry_Call), Loc),\n+                      Parameter_Associations =>\n+                        New_List (\n+                          Obj_Ref,\n+\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix => Make_Identifier (Loc, Name_uP),\n+                            Attribute_Name => Name_Address),\n+\n+                            New_Reference_To\n+                             (RTE (RE_Conditional_Call), Loc))));\n+               when others =>\n+                  raise Program_Error;\n+            end case;\n \n             --  Generate:\n             --    F := not Cancelled (Bnn);\n@@ -2339,79 +2401,83 @@ package body Exp_Disp is\n          --            A);\n          --    end if;\n \n-         Append_To (Stmts,\n-           Make_If_Statement (Loc,\n-             Condition =>\n-               Make_Identifier (Loc, Name_uF),\n-\n-             Then_Statements =>\n-               New_List (\n-\n-                  --  Call to Requeue_Protected_Entry\n-\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name =>\n-                     New_Reference_To (\n-                       RTE (RE_Requeue_Protected_Entry), Loc),\n-                   Parameter_Associations =>\n-                     New_List (\n-\n-                       Make_Unchecked_Type_Conversion (Loc,  -- PEA (P)\n-                         Subtype_Mark =>\n-                           New_Reference_To (\n-                             RTE (RE_Protection_Entries_Access), Loc),\n-                         Expression =>\n-                           Make_Identifier (Loc, Name_uP)),\n-\n-                       Make_Attribute_Reference (Loc,        -- O._object'Acc\n-                         Attribute_Name =>\n-                           Name_Unchecked_Access,\n-                         Prefix =>\n-                           Make_Selected_Component (Loc,\n-                             Prefix =>\n-                               Make_Identifier (Loc, Name_uO),\n-                             Selector_Name =>\n-                               Make_Identifier (Loc, Name_uObject))),\n+         if Restriction_Active (No_Entry_Queue) then\n+            Append_To (Stmts, Make_Null_Statement (Loc));\n+         else\n+            Append_To (Stmts,\n+              Make_If_Statement (Loc,\n+                Condition =>\n+                  Make_Identifier (Loc, Name_uF),\n \n-                       Make_Unchecked_Type_Conversion (Loc,  -- entry index\n-                         Subtype_Mark =>\n-                           New_Reference_To (\n-                             RTE (RE_Protected_Entry_Index), Loc),\n-                         Expression =>\n-                           Make_Identifier (Loc, Name_uI)),\n+                Then_Statements =>\n+                  New_List (\n \n-                       Make_Identifier (Loc, Name_uA)))),    -- abort status\n+                     --  Call to Requeue_Protected_Entry\n \n-             Else_Statements =>\n-               New_List (\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name =>\n+                        New_Reference_To (\n+                          RTE (RE_Requeue_Protected_Entry), Loc),\n+                      Parameter_Associations =>\n+                        New_List (\n+\n+                          Make_Unchecked_Type_Conversion (Loc,  -- PEA (P)\n+                            Subtype_Mark =>\n+                              New_Reference_To (\n+                                RTE (RE_Protection_Entries_Access), Loc),\n+                            Expression =>\n+                              Make_Identifier (Loc, Name_uP)),\n+\n+                          Make_Attribute_Reference (Loc,      -- O._object'Acc\n+                            Attribute_Name =>\n+                              Name_Unchecked_Access,\n+                            Prefix =>\n+                              Make_Selected_Component (Loc,\n+                                Prefix =>\n+                                  Make_Identifier (Loc, Name_uO),\n+                                Selector_Name =>\n+                                  Make_Identifier (Loc, Name_uObject))),\n+\n+                          Make_Unchecked_Type_Conversion (Loc,  -- entry index\n+                            Subtype_Mark =>\n+                              New_Reference_To (\n+                                RTE (RE_Protected_Entry_Index), Loc),\n+                            Expression =>\n+                              Make_Identifier (Loc, Name_uI)),\n \n-                  --  Call to Requeue_Task_To_Protected_Entry\n+                          Make_Identifier (Loc, Name_uA)))),   -- abort status\n \n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name =>\n-                     New_Reference_To (\n-                       RTE (RE_Requeue_Task_To_Protected_Entry), Loc),\n-                   Parameter_Associations =>\n-                     New_List (\n+                Else_Statements =>\n+                  New_List (\n \n-                       Make_Attribute_Reference (Loc,        -- O._object'Acc\n-                         Attribute_Name =>\n-                           Name_Unchecked_Access,\n-                         Prefix =>\n-                           Make_Selected_Component (Loc,\n-                             Prefix =>\n-                               Make_Identifier (Loc, Name_uO),\n-                             Selector_Name =>\n-                               Make_Identifier (Loc, Name_uObject))),\n+                     --  Call to Requeue_Task_To_Protected_Entry\n \n-                       Make_Unchecked_Type_Conversion (Loc,  -- entry index\n-                         Subtype_Mark =>\n-                           New_Reference_To (\n-                             RTE (RE_Protected_Entry_Index), Loc),\n-                         Expression =>\n-                           Make_Identifier (Loc, Name_uI)),\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name =>\n+                        New_Reference_To (\n+                          RTE (RE_Requeue_Task_To_Protected_Entry), Loc),\n+                      Parameter_Associations =>\n+                        New_List (\n+\n+                          Make_Attribute_Reference (Loc,     -- O._object'Acc\n+                            Attribute_Name =>\n+                              Name_Unchecked_Access,\n+                            Prefix =>\n+                              Make_Selected_Component (Loc,\n+                                Prefix =>\n+                                  Make_Identifier (Loc, Name_uO),\n+                                Selector_Name =>\n+                                  Make_Identifier (Loc, Name_uObject))),\n+\n+                          Make_Unchecked_Type_Conversion (Loc, -- entry index\n+                            Subtype_Mark =>\n+                              New_Reference_To (\n+                                RTE (RE_Protected_Entry_Index), Loc),\n+                            Expression =>\n+                              Make_Identifier (Loc, Name_uI)),\n \n-                       Make_Identifier (Loc, Name_uA))))));  -- abort status\n+                          Make_Identifier (Loc, Name_uA)))))); -- abort status\n+         end if;\n       else\n          pragma Assert (Is_Task_Type (Conc_Typ));\n \n@@ -2658,6 +2724,7 @@ package body Exp_Disp is\n       Conc_Typ : Entity_Id           := Empty;\n       Decls    : constant List_Id    := New_List;\n       DT_Ptr   : Entity_Id;\n+      Obj_Ref  : Node_Id;\n       Stmts    : constant List_Id    := New_List;\n \n    begin\n@@ -2727,48 +2794,83 @@ package body Exp_Disp is\n                        New_Reference_To (DT_Ptr, Loc)),\n                      Make_Identifier (Loc, Name_uS)))));\n \n+         --  Protected case\n+\n          if Ekind (Conc_Typ) = E_Protected_Type then\n \n-            --  Generate:\n-            --    Timed_Protected_Entry_Call (\n-            --      T._object'access,\n+            --  Build T._object'Access\n+\n+            Obj_Ref :=\n+               Make_Attribute_Reference (Loc,\n+                  Attribute_Name => Name_Unchecked_Access,\n+                  Prefix         =>\n+                    Make_Selected_Component (Loc,\n+                      Prefix        => Make_Identifier (Loc, Name_uT),\n+                      Selector_Name => Make_Identifier (Loc, Name_uObject)));\n+\n+            --  Normal case, No_Entry_Queue restriction not active. In this\n+            --  case we generate:\n+\n+            --   Timed_Protected_Entry_Call\n+            --     (T._object'access,\n             --      Protected_Entry_Index! (I),\n-            --      P,\n-            --      D,\n-            --      M,\n-            --      F);\n+            --      P, D, M, F);\n \n             --  where T is the protected object, I is the entry index, P are\n             --  the wrapped parameters, D is the delay amount, M is the delay\n             --  mode and F is the status flag.\n \n-            Append_To (Stmts,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name =>\n-                  New_Reference_To (RTE (RE_Timed_Protected_Entry_Call), Loc),\n-                Parameter_Associations =>\n-                  New_List (\n+            case Corresponding_Runtime_Package (Conc_Typ) is\n+               when System_Tasking_Protected_Objects_Entries =>\n+                  Append_To (Stmts,\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name =>\n+                        New_Reference_To\n+                          (RTE (RE_Timed_Protected_Entry_Call), Loc),\n+                      Parameter_Associations =>\n+                        New_List (\n+                          Obj_Ref,\n+\n+                          Make_Unchecked_Type_Conversion (Loc,  --  entry index\n+                            Subtype_Mark =>\n+                              New_Reference_To\n+                                (RTE (RE_Protected_Entry_Index), Loc),\n+                            Expression =>\n+                              Make_Identifier (Loc, Name_uI)),\n \n-                    Make_Attribute_Reference (Loc,        -- T._object'access\n-                      Attribute_Name =>\n-                        Name_Unchecked_Access,\n-                      Prefix =>\n-                        Make_Selected_Component (Loc,\n-                          Prefix =>\n-                            Make_Identifier (Loc, Name_uT),\n-                          Selector_Name =>\n-                            Make_Identifier (Loc, Name_uObject))),\n+                          Make_Identifier (Loc, Name_uP),   --  parameter block\n+                          Make_Identifier (Loc, Name_uD),   --  delay\n+                          Make_Identifier (Loc, Name_uM),   --  delay mode\n+                          Make_Identifier (Loc, Name_uF)))); --  status flag\n \n-                    Make_Unchecked_Type_Conversion (Loc,  --  entry index\n-                      Subtype_Mark =>\n-                        New_Reference_To (RTE (RE_Protected_Entry_Index), Loc),\n-                      Expression =>\n-                        Make_Identifier (Loc, Name_uI)),\n+               when System_Tasking_Protected_Objects_Single_Entry =>\n+                  --  Generate:\n \n-                    Make_Identifier (Loc, Name_uP),       --  parameter block\n-                    Make_Identifier (Loc, Name_uD),       --  delay\n-                    Make_Identifier (Loc, Name_uM),       --  delay mode\n-                    Make_Identifier (Loc, Name_uF))));    --  status flag\n+                  --   Timed_Protected_Single_Entry_Call\n+                  --     (T._object'access, P, D, M, F);\n+\n+                  --  where T is the protected object, P is the wrapped\n+                  --  parameters, D is the delay amount, M is the delay mode, F\n+                  --  is the status flag.\n+\n+                  Append_To (Stmts,\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name =>\n+                        New_Reference_To\n+                          (RTE (RE_Timed_Protected_Single_Entry_Call), Loc),\n+                      Parameter_Associations =>\n+                        New_List (\n+                          Obj_Ref,\n+                          Make_Identifier (Loc, Name_uP),   --  parameter block\n+                          Make_Identifier (Loc, Name_uD),   --  delay\n+                          Make_Identifier (Loc, Name_uM),   --  delay mode\n+                          Make_Identifier (Loc, Name_uF)))); --  status flag\n+\n+               when others =>\n+                  raise Program_Error;\n+            end case;\n+\n+         --  Task case\n \n          else\n             pragma Assert (Ekind (Conc_Typ) = E_Task_Type);\n@@ -2957,12 +3059,13 @@ package body Exp_Disp is\n       --  generate forward references and statically allocate the table.\n \n       procedure Make_Secondary_DT\n-        (Typ             : Entity_Id;\n-         Iface           : Entity_Id;\n-         Num_Iface_Prims : Nat;\n-         Iface_DT_Ptr    : Entity_Id;\n-         Build_Thunks    : Boolean;\n-         Result          : List_Id);\n+        (Typ              : Entity_Id;\n+         Iface            : Entity_Id;\n+         Num_Iface_Prims  : Nat;\n+         Iface_DT_Ptr     : Entity_Id;\n+         Predef_Prims_Ptr : Entity_Id;\n+         Build_Thunks     : Boolean;\n+         Result           : List_Id);\n       --  Ada 2005 (AI-251): Expand the declarations for a Secondary Dispatch\n       --  Table of Typ associated with Iface. Each abstract interface of Typ\n       --  has two secondary dispatch tables: one containing pointers to thunks\n@@ -3024,12 +3127,13 @@ package body Exp_Disp is\n       -----------------------\n \n       procedure Make_Secondary_DT\n-        (Typ             : Entity_Id;\n-         Iface           : Entity_Id;\n-         Num_Iface_Prims : Nat;\n-         Iface_DT_Ptr    : Entity_Id;\n-         Build_Thunks    : Boolean;\n-         Result          : List_Id)\n+        (Typ              : Entity_Id;\n+         Iface            : Entity_Id;\n+         Num_Iface_Prims  : Nat;\n+         Iface_DT_Ptr     : Entity_Id;\n+         Predef_Prims_Ptr : Entity_Id;\n+         Build_Thunks     : Boolean;\n+         Result           : List_Id)\n       is\n          Loc                : constant Source_Ptr := Sloc (Typ);\n          Name_DT            : constant Name_Id := New_Internal_Name ('T');\n@@ -3168,9 +3272,10 @@ package body Exp_Disp is\n             for J in Prim_Table'Range loop\n                if Present (Prim_Table (J)) then\n                   New_Node :=\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix => New_Reference_To (Prim_Table (J), Loc),\n-                      Attribute_Name => Name_Address);\n+                    Unchecked_Convert_To (RTE (RE_Address),\n+                      Make_Attribute_Reference (Loc,\n+                        Prefix => New_Reference_To (Prim_Table (J), Loc),\n+                        Attribute_Name => Name_Unrestricted_Access));\n                else\n                   New_Node :=\n                     New_Reference_To (RTE (RE_Null_Address), Loc);\n@@ -3451,9 +3556,10 @@ package body Exp_Disp is\n                for J in Prim_Table'Range loop\n                   if Present (Prim_Table (J)) then\n                      New_Node :=\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix => New_Reference_To (Prim_Table (J), Loc),\n-                         Attribute_Name => Name_Address);\n+                       Unchecked_Convert_To (RTE (RE_Address),\n+                         Make_Attribute_Reference (Loc,\n+                           Prefix => New_Reference_To (Prim_Table (J), Loc),\n+                           Attribute_Name => Name_Unrestricted_Access));\n                   else\n                      New_Node :=\n                        New_Reference_To (RTE (RE_Null_Address), Loc);\n@@ -3513,6 +3619,30 @@ package body Exp_Disp is\n                          (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n                    Attribute_Name => Name_Address))));\n \n+         Append_To (Result,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Predef_Prims_Ptr,\n+             Constant_Present    => True,\n+             Object_Definition =>\n+               New_Reference_To (RTE (RE_Address), Loc),\n+             Expression =>\n+               Make_Attribute_Reference (Loc,\n+                 Prefix =>\n+                   Make_Selected_Component (Loc,\n+                     Prefix => New_Reference_To (Iface_DT, Loc),\n+                   Selector_Name =>\n+                     New_Occurrence_Of\n+                       (RTE_Record_Component (RE_Predef_Prims), Loc)),\n+                 Attribute_Name => Name_Address)));\n+\n+         --  Mark entities containing library level static dispatch tables.\n+         --  This attribute is later propagated to all the access-to-subprogram\n+         --  itypes generated to fill the dispatch table slots (see exp_attr).\n+\n+         if Building_Static_DT (Typ) then\n+            Set_Is_Static_Dispatch_Table_Entity (Predef_Prims);\n+            Set_Is_Static_Dispatch_Table_Entity (Iface_DT);\n+         end if;\n       end Make_Secondary_DT;\n \n       --  Local variables\n@@ -3535,10 +3665,7 @@ package body Exp_Disp is\n       Nb_Prim            : Nat := 0;\n       New_Node           : Node_Id;\n       No_Reg             : Node_Id;\n-      Null_Parent_Tag    : Boolean := False;\n       Num_Ifaces         : Nat := 0;\n-      Old_Tag1           : Node_Id;\n-      Old_Tag2           : Node_Id;\n       Prim               : Entity_Id;\n       Prim_Elmt          : Elmt_Id;\n       Prim_Ops_Aggr_List : List_Id;\n@@ -3686,7 +3813,8 @@ package body Exp_Disp is\n          Collect_Interface_Components (Typ, Typ_Comps);\n \n          Suffix_Index := 0;\n-         AI_Tag_Elmt  := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n+         AI_Tag_Elmt  :=\n+           Next_Elmt (Next_Elmt (First_Elmt (Access_Disp_Table (Typ))));\n \n          AI_Tag_Comp := First_Elmt (Typ_Comps);\n          while Present (AI_Tag_Comp) loop\n@@ -3699,10 +3827,15 @@ package body Exp_Disp is\n               Num_Iface_Prims => UI_To_Int\n                                    (DT_Entry_Count (Node (AI_Tag_Comp))),\n               Iface_DT_Ptr    => Node (AI_Tag_Elmt),\n+              Predef_Prims_Ptr => Node (Next_Elmt (AI_Tag_Elmt)),\n               Build_Thunks    => True,\n               Result          => Result);\n             Next_Elmt (AI_Tag_Elmt);\n \n+            --  Skip the secondary dispatch table of predefined primitives\n+\n+            Next_Elmt (AI_Tag_Elmt);\n+\n             --  Build the secondary table containing pointers to primitives\n             --  (used to give support to Generic Dispatching Constructors).\n \n@@ -3712,10 +3845,15 @@ package body Exp_Disp is\n               Num_Iface_Prims =>  UI_To_Int\n                                    (DT_Entry_Count (Node (AI_Tag_Comp))),\n               Iface_DT_Ptr    => Node (AI_Tag_Elmt),\n+              Predef_Prims_Ptr => Node (Next_Elmt (AI_Tag_Elmt)),\n               Build_Thunks    => False,\n               Result          => Result);\n             Next_Elmt (AI_Tag_Elmt);\n \n+            --  Skip the secondary dispatch table of predefined primitives\n+\n+            Next_Elmt (AI_Tag_Elmt);\n+\n             Suffix_Index := Suffix_Index + 1;\n             Next_Elmt (AI_Tag_Comp);\n          end loop;\n@@ -3850,6 +3988,23 @@ package body Exp_Disp is\n                           New_Occurrence_Of\n                             (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n                       Attribute_Name => Name_Address))));\n+\n+            Append_To (Result,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier =>\n+                  Node (Next_Elmt (First_Elmt (Access_Disp_Table (Typ)))),\n+                Constant_Present    => True,\n+                Object_Definition   => New_Reference_To\n+                                            (RTE (RE_Address), Loc),\n+                Expression =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix =>\n+                      Make_Selected_Component (Loc,\n+                        Prefix => New_Reference_To (DT, Loc),\n+                      Selector_Name =>\n+                        New_Occurrence_Of\n+                          (RTE_Record_Component (RE_Predef_Prims), Loc)),\n+                    Attribute_Name => Name_Address)));\n          end if;\n       end if;\n \n@@ -4245,7 +4400,9 @@ package body Exp_Disp is\n                      Sec_DT_Tag :=\n                        New_Reference_To (DT_Ptr, Loc);\n                   else\n-                     Elmt := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n+                     Elmt :=\n+                       Next_Elmt\n+                        (Next_Elmt (First_Elmt (Access_Disp_Table (Typ))));\n                      pragma Assert (Has_Thunks (Node (Elmt)));\n \n                      while Ekind (Node (Elmt)) = E_Constant\n@@ -4254,14 +4411,20 @@ package body Exp_Disp is\n                      loop\n                         pragma Assert (Has_Thunks (Node (Elmt)));\n                         Next_Elmt (Elmt);\n+                        pragma Assert (Has_Thunks (Node (Elmt)));\n+                        Next_Elmt (Elmt);\n+                        pragma Assert (not Has_Thunks (Node (Elmt)));\n+                        Next_Elmt (Elmt);\n                         pragma Assert (not Has_Thunks (Node (Elmt)));\n                         Next_Elmt (Elmt);\n                      end loop;\n \n                      pragma Assert (Ekind (Node (Elmt)) = E_Constant\n-                       and then not Has_Thunks (Node (Next_Elmt (Elmt))));\n+                       and then not\n+                         Has_Thunks (Node (Next_Elmt (Next_Elmt (Elmt)))));\n                      Sec_DT_Tag :=\n-                       New_Reference_To (Node (Next_Elmt (Elmt)), Loc);\n+                       New_Reference_To (Node (Next_Elmt (Next_Elmt (Elmt))),\n+                                         Loc);\n                   end if;\n \n                   Append_To (TSD_Ifaces_List,\n@@ -4645,9 +4808,10 @@ package body Exp_Disp is\n                for J in Prim_Table'Range loop\n                   if Present (Prim_Table (J)) then\n                      New_Node :=\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix => New_Reference_To (Prim_Table (J), Loc),\n-                         Attribute_Name => Name_Address);\n+                       Unchecked_Convert_To (RTE (RE_Address),\n+                         Make_Attribute_Reference (Loc,\n+                           Prefix => New_Reference_To (Prim_Table (J), Loc),\n+                           Attribute_Name => Name_Unrestricted_Access));\n                   else\n                      New_Node := New_Reference_To (RTE (RE_Null_Address), Loc);\n                   end if;\n@@ -4787,9 +4951,10 @@ package body Exp_Disp is\n                for J in Prim_Table'Range loop\n                   if Present (Prim_Table (J)) then\n                      New_Node :=\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix => New_Reference_To (Prim_Table (J), Loc),\n-                         Attribute_Name => Name_Address);\n+                       Unchecked_Convert_To (RTE (RE_Address),\n+                         Make_Attribute_Reference (Loc,\n+                           Prefix => New_Reference_To (Prim_Table (J), Loc),\n+                           Attribute_Name => Name_Unrestricted_Access));\n                   else\n                      New_Node := New_Reference_To (RTE (RE_Null_Address), Loc);\n                   end if;\n@@ -4871,6 +5036,12 @@ package body Exp_Disp is\n                  (Node (First_Elmt (Access_Disp_Table (Typ))), Loc)));\n       end if;\n \n+      --  Inherit the dispatch tables of the parent\n+\n+      --  There is no need to inherit anything from the parent when building\n+      --  static dispatch tables because the whole dispatch table (including\n+      --  inherited primitives) has been already built.\n+\n       if Building_Static_DT (Typ) then\n          null;\n \n@@ -4880,60 +5051,52 @@ package body Exp_Disp is\n       elsif Is_CPP_Class (Etype (Typ)) then\n          null;\n \n-         --  Otherwise we fill in the dispatch tables here\n+      --  Otherwise we fill in the dispatch tables here\n \n       else\n-         if Typ = Etype (Typ)\n-           or else Is_CPP_Class (Etype (Typ))\n-           or else Is_Interface (Typ)\n-         then\n-            Null_Parent_Tag := True;\n-\n-            Old_Tag1 :=\n-              Unchecked_Convert_To (RTE (RE_Tag),\n-                Make_Integer_Literal (Loc, 0));\n-            Old_Tag2 :=\n-              Unchecked_Convert_To (RTE (RE_Tag),\n-                Make_Integer_Literal (Loc, 0));\n-\n-         else\n-            Old_Tag1 :=\n-              New_Reference_To\n-                (Node (First_Elmt (Access_Disp_Table (Etype (Typ)))), Loc);\n-            Old_Tag2 :=\n-              New_Reference_To\n-                (Node (First_Elmt (Access_Disp_Table (Etype (Typ)))), Loc);\n-         end if;\n-\n          if Typ /= Etype (Typ)\n            and then not Is_Interface (Typ)\n            and then not Restriction_Active (No_Dispatching_Calls)\n          then\n             --  Inherit the dispatch table\n \n-            if not Is_Interface (Etype (Typ)) then\n-               if not Null_Parent_Tag then\n-                  declare\n-                     Nb_Prims : constant Int :=\n-                                  UI_To_Int (DT_Entry_Count\n-                                    (First_Tag_Component (Etype (Typ))));\n-                  begin\n+            if not Is_Interface (Typ)\n+              and then not Is_Interface (Etype (Typ))\n+              and then not Is_CPP_Class (Etype (Typ))\n+            then\n+               declare\n+                  Nb_Prims : constant Int :=\n+                               UI_To_Int (DT_Entry_Count\n+                                 (First_Tag_Component (Etype (Typ))));\n+               begin\n+                  Append_To (Elab_Code,\n+                    Build_Inherit_Predefined_Prims (Loc,\n+                      Old_Tag_Node =>\n+                        New_Reference_To\n+                          (Node\n+                           (Next_Elmt\n+                            (First_Elmt\n+                             (Access_Disp_Table (Etype (Typ))))), Loc),\n+                      New_Tag_Node =>\n+                        New_Reference_To\n+                          (Node\n+                           (Next_Elmt\n+                            (First_Elmt\n+                             (Access_Disp_Table (Typ)))), Loc)));\n+\n+                  if Nb_Prims /= 0 then\n                      Append_To (Elab_Code,\n-                       Build_Inherit_Predefined_Prims (Loc,\n-                         Old_Tag_Node => Old_Tag1,\n-                         New_Tag_Node =>\n-                           New_Reference_To (DT_Ptr, Loc)));\n-\n-                     if Nb_Prims /= 0 then\n-                        Append_To (Elab_Code,\n-                          Build_Inherit_Prims (Loc,\n-                            Typ          => Typ,\n-                            Old_Tag_Node => Old_Tag2,\n-                            New_Tag_Node => New_Reference_To (DT_Ptr, Loc),\n-                            Num_Prims    => Nb_Prims));\n-                     end if;\n-                  end;\n-               end if;\n+                       Build_Inherit_Prims (Loc,\n+                         Typ          => Typ,\n+                         Old_Tag_Node =>\n+                           New_Reference_To\n+                             (Node\n+                              (First_Elmt\n+                               (Access_Disp_Table (Etype (Typ)))), Loc),\n+                         New_Tag_Node => New_Reference_To (DT_Ptr, Loc),\n+                         Num_Prims    => Nb_Prims));\n+                  end if;\n+               end;\n             end if;\n \n             --  Inherit the secondary dispatch tables of the ancestor\n@@ -4942,12 +5105,14 @@ package body Exp_Disp is\n                declare\n                   Sec_DT_Ancestor : Elmt_Id :=\n                                       Next_Elmt\n+                                       (Next_Elmt\n                                         (First_Elmt\n-                                           (Access_Disp_Table (Etype (Typ))));\n+                                          (Access_Disp_Table (Etype (Typ)))));\n                   Sec_DT_Typ      : Elmt_Id :=\n                                       Next_Elmt\n-                                        (First_Elmt\n-                                           (Access_Disp_Table (Typ)));\n+                                       (Next_Elmt\n+                                         (First_Elmt\n+                                           (Access_Disp_Table (Typ))));\n \n                   procedure Copy_Secondary_DTs (Typ : Entity_Id);\n                   --  Local procedure required to climb through the ancestors\n@@ -4998,12 +5163,15 @@ package body Exp_Disp is\n                                       Build_Inherit_Predefined_Prims (Loc,\n                                         Old_Tag_Node =>\n                                           Unchecked_Convert_To (RTE (RE_Tag),\n-                                             New_Reference_To\n-                                               (Node (Sec_DT_Ancestor), Loc)),\n+                                            New_Reference_To\n+                                              (Node\n+                                                (Next_Elmt (Sec_DT_Ancestor)),\n+                                               Loc)),\n                                         New_Tag_Node =>\n                                           Unchecked_Convert_To (RTE (RE_Tag),\n                                             New_Reference_To\n-                                              (Node (Sec_DT_Typ), Loc))));\n+                                              (Node (Next_Elmt (Sec_DT_Typ)),\n+                                               Loc))));\n \n                                     if Num_Prims /= 0 then\n                                        Append_To (Elab_Code,\n@@ -5027,6 +5195,12 @@ package body Exp_Disp is\n                                  Next_Elmt (Sec_DT_Ancestor);\n                                  Next_Elmt (Sec_DT_Typ);\n \n+                                 --  Skip the secondary dispatch table of\n+                                 --  predefined primitives\n+\n+                                 Next_Elmt (Sec_DT_Ancestor);\n+                                 Next_Elmt (Sec_DT_Typ);\n+\n                                  if not Is_Interface (Etype (Typ)) then\n \n                                     --  Inherit second secondary dispatch table\n@@ -5036,11 +5210,14 @@ package body Exp_Disp is\n                                         Old_Tag_Node =>\n                                           Unchecked_Convert_To (RTE (RE_Tag),\n                                              New_Reference_To\n-                                               (Node (Sec_DT_Ancestor), Loc)),\n+                                               (Node\n+                                                 (Next_Elmt (Sec_DT_Ancestor)),\n+                                                Loc)),\n                                         New_Tag_Node =>\n                                           Unchecked_Convert_To (RTE (RE_Tag),\n                                             New_Reference_To\n-                                              (Node (Sec_DT_Typ), Loc))));\n+                                              (Node (Next_Elmt (Sec_DT_Typ)),\n+                                               Loc))));\n \n                                     if Num_Prims /= 0 then\n                                        Append_To (Elab_Code,\n@@ -5064,6 +5241,13 @@ package body Exp_Disp is\n \n                               Next_Elmt (Sec_DT_Ancestor);\n                               Next_Elmt (Sec_DT_Typ);\n+\n+                              --  Skip the secondary dispatch table of\n+                              --  predefined primitives\n+\n+                              Next_Elmt (Sec_DT_Ancestor);\n+                              Next_Elmt (Sec_DT_Typ);\n+\n                               Next_Elmt (Iface);\n                            end if;\n \n@@ -5143,6 +5327,15 @@ package body Exp_Disp is\n            Make_Select_Specific_Data_Table (Typ));\n       end if;\n \n+      --  Mark entities containing library level static dispatch tables. This\n+      --  attribute is later propagated to all the access-to-subprogram itypes\n+      --  generated to fill the dispatch table slots (see exp_attr).\n+\n+      if Building_Static_DT (Typ) then\n+         Set_Is_Static_Dispatch_Table_Entity (Predef_Prims);\n+         Set_Is_Static_Dispatch_Table_Entity (DT);\n+      end if;\n+\n       Analyze_List (Result, Suppress => All_Checks);\n       Set_Has_Dispatch_Table (Typ);\n \n@@ -5312,18 +5505,19 @@ package body Exp_Disp is\n    ---------------\n \n    function Make_Tags (Typ : Entity_Id) return List_Id is\n-      Loc             : constant Source_Ptr := Sloc (Typ);\n-      Tname           : constant Name_Id := Chars (Typ);\n-      Result          : constant List_Id := New_List;\n-      AI_Tag_Comp     : Elmt_Id;\n-      DT              : Node_Id;\n-      DT_Constr_List  : List_Id;\n-      DT_Ptr          : Node_Id;\n-      Iface_DT_Ptr    : Node_Id;\n-      Nb_Prim         : Nat;\n-      Suffix_Index    : Int;\n-      Typ_Name        : Name_Id;\n-      Typ_Comps       : Elist_Id;\n+      Loc              : constant Source_Ptr := Sloc (Typ);\n+      Tname            : constant Name_Id := Chars (Typ);\n+      Result           : constant List_Id := New_List;\n+      AI_Tag_Comp      : Elmt_Id;\n+      DT               : Node_Id;\n+      DT_Constr_List   : List_Id;\n+      DT_Ptr           : Node_Id;\n+      Predef_Prims_Ptr : Node_Id;\n+      Iface_DT_Ptr     : Node_Id;\n+      Nb_Prim          : Nat;\n+      Suffix_Index     : Int;\n+      Typ_Name         : Name_Id;\n+      Typ_Comps        : Elist_Id;\n \n    begin\n       --  1) Generate the primary and secondary tag entities\n@@ -5334,18 +5528,28 @@ package body Exp_Disp is\n          Collect_Interface_Components (Typ, Typ_Comps);\n       end if;\n \n-      --  1) Generate the primary tag entity\n+      --  1) Generate the primary tag entities\n+\n+      --  Primary dispatch table containing user-defined primitives\n \n       DT_Ptr := Make_Defining_Identifier (Loc,\n                   New_External_Name (Tname, 'P'));\n       Set_Etype (DT_Ptr, RTE (RE_Tag));\n \n+      --  Primary dispatch table containing predefined primitives\n+\n+      Predef_Prims_Ptr :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_External_Name (Tname, 'Y'));\n+      Set_Etype (Predef_Prims_Ptr, RTE (RE_Address));\n+\n       --  Import the forward declaration of the Dispatch Table wrapper record\n       --  (Make_DT will take care of its exportation)\n \n       if Building_Static_DT (Typ) then\n-         DT := Make_Defining_Identifier (Loc,\n-                 New_External_Name (Tname, 'T'));\n+         DT :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Tname, 'T'));\n \n          --  Generate:\n          --    DT : static aliased constant Dispatch_Table_Wrapper (Nb_Prim);\n@@ -5371,6 +5575,7 @@ package body Exp_Disp is\n          Set_Dispatch_Table_Wrapper (Typ, DT);\n \n          if Has_DT (Typ) then\n+\n             --  Calculate the number of primitives of the dispatch table and\n             --  the size of the Type_Specific_Data record.\n \n@@ -5415,6 +5620,22 @@ package body Exp_Disp is\n                             (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n                       Attribute_Name => Name_Address))));\n \n+            Append_To (Result,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Predef_Prims_Ptr,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Reference_To\n+                                            (RTE (RE_Address), Loc),\n+                Expression =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix =>\n+                      Make_Selected_Component (Loc,\n+                        Prefix => New_Reference_To (DT, Loc),\n+                      Selector_Name =>\n+                        New_Occurrence_Of\n+                          (RTE_Record_Component (RE_Predef_Prims), Loc)),\n+                    Attribute_Name => Name_Address)));\n+\n          --  No dispatch table required\n \n          else\n@@ -5450,6 +5671,7 @@ package body Exp_Disp is\n       pragma Assert (No (Access_Disp_Table (Typ)));\n       Set_Access_Disp_Table (Typ, New_Elmt_List);\n       Append_Elmt (DT_Ptr, Access_Disp_Table (Typ));\n+      Append_Elmt (Predef_Prims_Ptr, Access_Disp_Table (Typ));\n \n       --  2) Generate the secondary tag entities\n \n@@ -5471,6 +5693,9 @@ package body Exp_Disp is\n \n             Typ_Name := Name_Find;\n \n+            --  Secondary dispatch table referencing thunks to user-defined\n+            --  primitives covered by this interface.\n+\n             Iface_DT_Ptr :=\n               Make_Defining_Identifier (Loc,\n                 Chars => New_External_Name (Typ_Name, 'P'));\n@@ -5484,6 +5709,25 @@ package body Exp_Disp is\n               (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n             Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n \n+            --  Secondary dispatch table referencing thunks to predefined\n+            --  primitives.\n+\n+            Iface_DT_Ptr :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_External_Name (Typ_Name, 'Y'));\n+            Set_Etype (Iface_DT_Ptr, RTE (RE_Address));\n+            Set_Ekind (Iface_DT_Ptr, E_Constant);\n+            Set_Is_Tag (Iface_DT_Ptr);\n+            Set_Has_Thunks (Iface_DT_Ptr);\n+            Set_Is_Statically_Allocated (Iface_DT_Ptr);\n+            Set_Is_True_Constant (Iface_DT_Ptr);\n+            Set_Related_Type\n+              (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n+            Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n+\n+            --  Secondary dispatch table referencing user-defined primitives\n+            --  covered by this interface.\n+\n             Iface_DT_Ptr :=\n               Make_Defining_Identifier (Loc,\n                 Chars => New_External_Name (Typ_Name, 'D'));\n@@ -5496,6 +5740,20 @@ package body Exp_Disp is\n               (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n             Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n \n+            --  Secondary dispatch table referencing predefined primitives\n+\n+            Iface_DT_Ptr :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_External_Name (Typ_Name, 'Z'));\n+            Set_Etype (Iface_DT_Ptr, RTE (RE_Address));\n+            Set_Ekind (Iface_DT_Ptr, E_Constant);\n+            Set_Is_Tag (Iface_DT_Ptr);\n+            Set_Is_Statically_Allocated (Iface_DT_Ptr);\n+            Set_Is_True_Constant (Iface_DT_Ptr);\n+            Set_Related_Type\n+              (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n+            Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n+\n             Next_Elmt (AI_Tag_Comp);\n          end loop;\n       end if;\n@@ -5703,33 +5961,38 @@ package body Exp_Disp is\n       end if;\n \n       if not Present (Abstract_Interface_Alias (Prim)) then\n-         Typ          := Scope (DTC_Entity (Prim));\n-         DT_Ptr       := Node (First_Elmt (Access_Disp_Table (Typ)));\n-         Pos          := DT_Position (Prim);\n-         Tag          := First_Tag_Component (Typ);\n+         Typ := Scope (DTC_Entity (Prim));\n+         Pos := DT_Position (Prim);\n+         Tag := First_Tag_Component (Typ);\n \n          if Is_Predefined_Dispatching_Operation (Prim)\n            or else Is_Predefined_Dispatching_Alias (Prim)\n          then\n+            DT_Ptr := Node (Next_Elmt (First_Elmt (Access_Disp_Table (Typ))));\n             Insert_After (Ins_Nod,\n               Build_Set_Predefined_Prim_Op_Address (Loc,\n                 Tag_Node     => New_Reference_To (DT_Ptr, Loc),\n                 Position     => Pos,\n-                Address_Node => Make_Attribute_Reference (Loc,\n-                                   Prefix => New_Reference_To (Prim, Loc),\n-                                   Attribute_Name => Name_Address)));\n+                Address_Node =>\n+                  Unchecked_Convert_To (RTE (RE_Address),\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix => New_Reference_To (Prim, Loc),\n+                      Attribute_Name => Name_Unrestricted_Access))));\n \n          else\n             pragma Assert (Pos /= Uint_0 and then Pos <= DT_Entry_Count (Tag));\n \n+            DT_Ptr := Node (First_Elmt (Access_Disp_Table (Typ)));\n             Insert_After (Ins_Nod,\n               Build_Set_Prim_Op_Address (Loc,\n                 Typ          => Typ,\n                 Tag_Node     => New_Reference_To (DT_Ptr, Loc),\n                 Position     => Pos,\n-                Address_Node => Make_Attribute_Reference (Loc,\n-                                  Prefix => New_Reference_To (Prim, Loc),\n-                                  Attribute_Name => Name_Address)));\n+                Address_Node =>\n+                  Unchecked_Convert_To (RTE (RE_Address),\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix => New_Reference_To (Prim, Loc),\n+                      Attribute_Name => Name_Unrestricted_Access))));\n          end if;\n \n       --  Ada 2005 (AI-251): Primitive associated with an interface type\n@@ -5763,35 +6026,40 @@ package body Exp_Disp is\n             Iface_DT_Ptr  := Node (Iface_DT_Elmt);\n             pragma Assert (Has_Thunks (Iface_DT_Ptr));\n \n-            Iface_Prim    := Abstract_Interface_Alias (Prim);\n-            Pos           := DT_Position (Iface_Prim);\n-            Tag           := First_Tag_Component (Iface_Typ);\n-            L             := New_List;\n+            Iface_Prim := Abstract_Interface_Alias (Prim);\n+            Pos        := DT_Position (Iface_Prim);\n+            Tag        := First_Tag_Component (Iface_Typ);\n+            L          := New_List;\n \n             if Is_Predefined_Dispatching_Operation (Prim)\n               or else Is_Predefined_Dispatching_Alias (Prim)\n             then\n                Append_To (L,\n                  Build_Set_Predefined_Prim_Op_Address (Loc,\n-                   Tag_Node => New_Reference_To (Iface_DT_Ptr, Loc),\n+                   Tag_Node =>\n+                     New_Reference_To (Node (Next_Elmt (Iface_DT_Elmt)), Loc),\n                    Position => Pos,\n                    Address_Node =>\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix          => New_Reference_To (Thunk_Id, Loc),\n-                       Attribute_Name  => Name_Address)));\n+                     Unchecked_Convert_To (RTE (RE_Address),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix          => New_Reference_To (Thunk_Id, Loc),\n+                         Attribute_Name  => Name_Unrestricted_Access))));\n \n+               Next_Elmt (Iface_DT_Elmt);\n                Next_Elmt (Iface_DT_Elmt);\n                Iface_DT_Ptr := Node (Iface_DT_Elmt);\n                pragma Assert (not Has_Thunks (Iface_DT_Ptr));\n \n                Append_To (L,\n                  Build_Set_Predefined_Prim_Op_Address (Loc,\n-                   Tag_Node => New_Reference_To (Iface_DT_Ptr, Loc),\n+                   Tag_Node =>\n+                     New_Reference_To (Node (Next_Elmt (Iface_DT_Elmt)), Loc),\n                    Position => Pos,\n                    Address_Node =>\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix          => New_Reference_To (Alias (Prim), Loc),\n-                       Attribute_Name  => Name_Address)));\n+                     Unchecked_Convert_To (RTE (RE_Address),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix => New_Reference_To (Alias (Prim), Loc),\n+                         Attribute_Name  => Name_Unrestricted_Access))));\n \n                Insert_Actions_After (Ins_Nod, L);\n \n@@ -5804,11 +6072,13 @@ package body Exp_Disp is\n                    Typ          => Iface_Typ,\n                    Tag_Node     => New_Reference_To (Iface_DT_Ptr, Loc),\n                    Position     => Pos,\n-                   Address_Node => Make_Attribute_Reference (Loc,\n-                                     Prefix =>\n-                                       New_Reference_To (Thunk_Id, Loc),\n-                                     Attribute_Name => Name_Address)));\n+                   Address_Node =>\n+                     Unchecked_Convert_To (RTE (RE_Address),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix => New_Reference_To (Thunk_Id, Loc),\n+                         Attribute_Name => Name_Unrestricted_Access))));\n \n+               Next_Elmt (Iface_DT_Elmt);\n                Next_Elmt (Iface_DT_Elmt);\n                Iface_DT_Ptr := Node (Iface_DT_Elmt);\n                pragma Assert (not Has_Thunks (Iface_DT_Ptr));\n@@ -5818,10 +6088,11 @@ package body Exp_Disp is\n                    Typ          => Iface_Typ,\n                    Tag_Node     => New_Reference_To (Iface_DT_Ptr, Loc),\n                    Position     => Pos,\n-                   Address_Node => Make_Attribute_Reference (Loc,\n-                                     Prefix =>\n-                                       New_Reference_To (Alias (Prim), Loc),\n-                                     Attribute_Name => Name_Address)));\n+                   Address_Node =>\n+                     Unchecked_Convert_To (RTE (RE_Address),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix => New_Reference_To (Alias (Prim), Loc),\n+                         Attribute_Name => Name_Unrestricted_Access))));\n \n                Insert_Actions_After (Ins_Nod, L);\n             end if;\n@@ -5980,8 +6251,9 @@ package body Exp_Disp is\n       end loop;\n \n       declare\n-         Fixed_Prim : array (Int range 0 .. Count_Prim) of Boolean\n-                        := (others => False);\n+         Fixed_Prim : array (Int range 0 .. Count_Prim) of Boolean :=\n+                        (others => False);\n+\n          E : Entity_Id;\n \n          procedure Handle_Inherited_Private_Subprograms (Typ : Entity_Id);\n@@ -6231,7 +6503,7 @@ package body Exp_Disp is\n          Prim := Node (Prim_Elmt);\n \n          --  At this point all the primitives MUST have a position\n-         --  in the dispatch table\n+         --  in the dispatch table.\n \n          if DT_Position (Prim) = No_Uint then\n             raise Program_Error;\n@@ -6322,8 +6594,7 @@ package body Exp_Disp is\n       Set_DT_Entry_Count (The_Tag, UI_From_Int (DT_Length));\n \n       --  The derived type must have at least as many components as its parent\n-      --  (for root types, the Etype points back to itself and the test cannot\n-      --   fail)\n+      --  (for root types Etype points to itself and the test cannot fail).\n \n       if DT_Entry_Count (The_Tag) <\n            DT_Entry_Count (First_Tag_Component (Parent_Typ))"}, {"sha": "28f6d6e0d9fcb538f2d759988730c1761e9cb7a4", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1923d2d6716bf5c1c45dbe285e0774f05611be05/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1923d2d6716bf5c1c45dbe285e0774f05611be05/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=1923d2d6716bf5c1c45dbe285e0774f05611be05", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -948,6 +948,43 @@ package body Exp_Util is\n       end if;\n    end Component_May_Be_Bit_Aligned;\n \n+   -----------------------------------\n+   -- Corresponding_Runtime_Package --\n+   -----------------------------------\n+\n+   function Corresponding_Runtime_Package (Typ : Entity_Id) return RTU_Id is\n+      Pkg_Id : RTU_Id := RTU_Null;\n+\n+   begin\n+      pragma Assert (Is_Concurrent_Type (Typ));\n+\n+      if Ekind (Typ) in Protected_Kind then\n+         if Has_Entries (Typ)\n+           or else Has_Interrupt_Handler (Typ)\n+           or else (Has_Attach_Handler (Typ)\n+                     and then not Restricted_Profile)\n+           or else (Ada_Version >= Ada_05\n+                     and then Present (Interface_List (Parent (Typ))))\n+         then\n+            if Abort_Allowed\n+              or else Restriction_Active (No_Entry_Queue) = False\n+              or else Number_Entries (Typ) > 1\n+              or else (Has_Attach_Handler (Typ)\n+                         and then not Restricted_Profile)\n+            then\n+               Pkg_Id := System_Tasking_Protected_Objects_Entries;\n+            else\n+               Pkg_Id := System_Tasking_Protected_Objects_Single_Entry;\n+            end if;\n+\n+         else\n+            Pkg_Id := System_Tasking_Protected_Objects;\n+         end if;\n+      end if;\n+\n+      return Pkg_Id;\n+   end Corresponding_Runtime_Package;\n+\n    -------------------------------\n    -- Convert_To_Actual_Subtype --\n    -------------------------------\n@@ -1384,6 +1421,10 @@ package body Exp_Util is\n                   return;\n                end if;\n \n+               --  Document what is going on here, why four Next's???\n+\n+               Next_Elmt (ADT);\n+               Next_Elmt (ADT);\n                Next_Elmt (ADT);\n                Next_Elmt (ADT);\n                Next_Elmt (AI_Elmt);\n@@ -1420,7 +1461,7 @@ package body Exp_Util is\n         (not Is_Class_Wide_Type (Typ)\n           and then Ekind (Typ) /= E_Incomplete_Type);\n \n-      ADT := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n+      ADT := Next_Elmt (Next_Elmt (First_Elmt (Access_Disp_Table (Typ))));\n       pragma Assert (Present (Node (ADT)));\n       Find_Secondary_Table (Typ);\n       pragma Assert (Found);"}, {"sha": "737b39728ee4992795805739158a8c2b9e55f38f", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1923d2d6716bf5c1c45dbe285e0774f05611be05/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1923d2d6716bf5c1c45dbe285e0774f05611be05/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=1923d2d6716bf5c1c45dbe285e0774f05611be05", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -212,43 +212,51 @@ package Exp_Util is\n    --  function itself must do its own cleanups.\n \n    function Component_May_Be_Bit_Aligned (Comp : Entity_Id) return Boolean;\n-   --  This function is in charge of detecting record components that may cause\n-   --  trouble in the back end if an attempt is made to assign the component.\n-   --  The back end can handle such assignments with no problem if the\n-   --  components involved are small (64-bits or less) records or scalar items\n-   --  (including bit-packed arrays represented with modular types) or are both\n-   --  aligned on a byte boundary (starting on a byte boundary, and occupying\n-   --  an integral number of bytes).\n+   --  This function is in charge of detecting record components that may\n+   --  cause trouble in the back end if an attempt is made to assign the\n+   --  component. The back end can handle such assignments with no problem if\n+   --  the components involved are small (64-bits or less) records or scalar\n+   --  items (including bit-packed arrays represented with modular types) or\n+   --  are both aligned on a byte boundary (starting on a byte boundary, and\n+   --  occupying an integral number of bytes).\n    --\n    --  However, problems arise for records larger than 64 bits, or for arrays\n    --  (other than bit-packed arrays represented with a modular type) if the\n    --  component starts on a non-byte boundary, or does not occupy an integral\n-   --  number of bytes (i.e. there are some bits possibly shared with fields at\n-   --  the start or beginning of the component). The back end cannot handle\n+   --  number of bytes (i.e. there are some bits possibly shared with fields\n+   --  at the start or beginning of the component). The back end cannot handle\n    --  loading and storing such components in a single operation.\n    --\n    --  This function is used to detect the troublesome situation. it is\n-   --  conservative in the sense that it produces True unless it knows for sure\n-   --  that the component is safe (as outlined in the first paragraph above).\n-   --  The code generation for record and array assignment checks for trouble\n-   --  using this function, and if so the assignment is generated\n+   --  conservative in the sense that it produces True unless it knows for\n+   --  sure that the component is safe (as outlined in the first paragraph\n+   --  above). The code generation for record and array assignment checks for\n+   --  trouble using this function, and if so the assignment is generated\n    --  component-wise, which the back end is required to handle correctly.\n    --\n-   --  Note that in GNAT 3, the back end will reject such components anyway, so\n-   --  the hard work in checking for this case is wasted in GNAT 3, but it's\n-   --  harmless, so it is easier to do it in all cases, rather than\n+   --  Note that in GNAT 3, the back end will reject such components anyway,\n+   --  so the hard work in checking for this case is wasted in GNAT 3, but\n+   --  it is harmless, so it is easier to do it in all cases, rather than\n    --  conditionalize it in GNAT 5 or beyond.\n \n    procedure Convert_To_Actual_Subtype (Exp : Node_Id);\n-   --  The Etype of an expression is the nominal type of the expression, not\n-   --  the actual subtype. Often these are the same, but not always. For\n-   --  example, a reference to a formal of unconstrained type has the\n+   --  The Etype of an expression is the nominal type of the expression,\n+   --  not the actual subtype. Often these are the same, but not always.\n+   --  For example, a reference to a formal of unconstrained type has the\n    --  unconstrained type as its Etype, but the actual subtype is obtained by\n    --  applying the actual bounds. This routine is given an expression, Exp,\n-   --  and (if necessary), replaces it using Rewrite, with a conversion to the\n-   --  actual subtype, building the actual subtype if necessary. If the\n+   --  and (if necessary), replaces it using Rewrite, with a conversion to\n+   --  the actual subtype, building the actual subtype if necessary. If the\n    --  expression is already of the requested type, then it is unchanged.\n \n+   function Corresponding_Runtime_Package (Typ : Entity_Id) return RTU_Id;\n+   --  Return the id of the runtime package that will provide support for\n+   --  concurrent type Typ. Currently only protected types are supported,\n+   --  and the returned value is one of the following:\n+   --    System_Tasking_Protected_Objects\n+   --    System_Tasking_Protected_Objects_Entries\n+   --    System_Tasking_Protected_Objects_Single_Entry\n+\n    function Current_Sem_Unit_Declarations return List_Id;\n    --  Return the a place where it is fine to insert declarations for the\n    --  current semantic unit. If the unit is a package body, return the"}, {"sha": "c36805838e636e001d9a657826d5d562cc1f7a5e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 126, "deletions": 15, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1923d2d6716bf5c1c45dbe285e0774f05611be05/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1923d2d6716bf5c1c45dbe285e0774f05611be05/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=1923d2d6716bf5c1c45dbe285e0774f05611be05", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1386,12 +1386,15 @@ package body Sem_Util is\n          ADT : Elmt_Id;\n \n       begin\n-         ADT := Next_Elmt (First_Elmt (Access_Disp_Table (T)));\n+         ADT := Next_Elmt (Next_Elmt (First_Elmt (Access_Disp_Table (T))));\n          while Present (ADT)\n             and then Ekind (Node (ADT)) = E_Constant\n             and then Related_Type (Node (ADT)) /= Iface\n          loop\n-            --  Skip the two secondary dispatch tables of Iface\n+            --  Skip the secondary dispatch tables of Iface\n+\n+            Next_Elmt (ADT);\n+            Next_Elmt (ADT);\n             Next_Elmt (ADT);\n             Next_Elmt (ADT);\n          end loop;\n@@ -3769,6 +3772,15 @@ package body Sem_Util is\n       return Entity_Id (Get_Name_Table_Info (Id));\n    end Get_Name_Entity_Id;\n \n+   -------------------\n+   -- Get_Pragma_Id --\n+   -------------------\n+\n+   function Get_Pragma_Id (N : Node_Id) return Pragma_Id is\n+   begin\n+      return Get_Pragma_Id (Pragma_Name (N));\n+   end Get_Pragma_Id;\n+\n    ---------------------------\n    -- Get_Referenced_Object --\n    ---------------------------\n@@ -3906,31 +3918,42 @@ package body Sem_Util is\n    -----------------------------\n \n    function Has_Abstract_Interfaces\n-     (Tagged_Type   : Entity_Id;\n+     (T             : Entity_Id;\n       Use_Full_View : Boolean := True) return Boolean\n    is\n       Typ : Entity_Id;\n \n    begin\n-      pragma Assert (Is_Record_Type (Tagged_Type)\n-         and then Is_Tagged_Type (Tagged_Type));\n+      --  Handle concurrent types\n \n-      --  Handle concurrent record types\n+      if Is_Concurrent_Type (T) then\n+         Typ := Corresponding_Record_Type (T);\n+      else\n+         Typ := T;\n+      end if;\n \n-      if Is_Concurrent_Record_Type (Tagged_Type)\n-        and then Is_Non_Empty_List (Abstract_Interface_List (Tagged_Type))\n+      if not Present (Typ)\n+        or else not Is_Tagged_Type (Typ)\n       then\n-         return True;\n+         return False;\n       end if;\n \n-      Typ := Tagged_Type;\n+      pragma Assert (Is_Record_Type (Typ));\n \n       --  Handle private types\n \n       if Use_Full_View\n-        and then Present (Full_View (Tagged_Type))\n+        and then Present (Full_View (Typ))\n+      then\n+         Typ := Full_View (Typ);\n+      end if;\n+\n+      --  Handle concurrent record types\n+\n+      if Is_Concurrent_Record_Type (Typ)\n+        and then Is_Non_Empty_List (Abstract_Interface_List (Typ))\n       then\n-         Typ := Full_View (Tagged_Type);\n+         return True;\n       end if;\n \n       loop\n@@ -3953,7 +3976,7 @@ package body Sem_Util is\n             --  Protect the frontend against wrong source with cyclic\n             --  derivations\n \n-            or else Etype (Typ) = Tagged_Type;\n+            or else Etype (Typ) = T;\n \n          --  Climb to the ancestor type handling private types\n \n@@ -8910,8 +8933,9 @@ package body Sem_Util is\n    procedure Set_Convention (E : Entity_Id; Val : Snames.Convention_Id) is\n    begin\n       Basic_Set_Convention (E, Val);\n+\n       if Is_Type (E)\n-        and then Ekind (Base_Type (E)) in Access_Subprogram_Type_Kind\n+        and then Is_Access_Subprogram_Type (Base_Type (E))\n         and then Has_Foreign_Convention (E)\n       then\n          Set_Can_Use_Internal_Rep (E, False);\n@@ -8932,6 +8956,93 @@ package body Sem_Util is\n       Set_Name_Entity_Id (Chars (E), E);\n    end Set_Current_Entity;\n \n+   ---------------------------\n+   -- Set_Debug_Info_Needed --\n+   ---------------------------\n+\n+   procedure Set_Debug_Info_Needed (T : Entity_Id) is\n+\n+      procedure Set_Debug_Info_Needed_If_Not_Set (E : Entity_Id);\n+      pragma Inline (Set_Debug_Info_Needed_If_Not_Set);\n+      --  Used to set debug info in a related node if not set already\n+\n+      --------------------------------------\n+      -- Set_Debug_Info_Needed_If_Not_Set --\n+      --------------------------------------\n+\n+      procedure Set_Debug_Info_Needed_If_Not_Set (E : Entity_Id) is\n+      begin\n+         if Present (E)\n+           and then not Needs_Debug_Info (E)\n+         then\n+            Set_Debug_Info_Needed (E);\n+         end if;\n+      end Set_Debug_Info_Needed_If_Not_Set;\n+\n+   --  Start of processing for Set_Debug_Info_Needed\n+\n+   begin\n+      --  Nothing to do if argument is Empty or has Debug_Info_Off set, which\n+      --  indicates that Debug_Info_Needed is never required for the entity.\n+\n+      if No (T)\n+        or else Debug_Info_Off (T)\n+      then\n+         return;\n+      end if;\n+\n+      --  Set flag in entity itself. Note that we will go through the following\n+      --  circuitry even if the flag is already set on T. That's intentional,\n+      --  it makes sure that the flag will be set in subsidiary entities.\n+\n+      Set_Needs_Debug_Info (T);\n+\n+      --  Set flag on subsidiary entities if not set already\n+\n+      if Is_Object (T) then\n+         Set_Debug_Info_Needed_If_Not_Set (Etype (T));\n+\n+      elsif Is_Type (T) then\n+         Set_Debug_Info_Needed_If_Not_Set (Etype (T));\n+\n+         if Is_Record_Type (T) then\n+            declare\n+               Ent : Entity_Id := First_Entity (T);\n+            begin\n+               while Present (Ent) loop\n+                  Set_Debug_Info_Needed_If_Not_Set (Ent);\n+                  Next_Entity (Ent);\n+               end loop;\n+            end;\n+\n+         elsif Is_Array_Type (T) then\n+            Set_Debug_Info_Needed_If_Not_Set (Component_Type (T));\n+\n+            declare\n+               Indx : Node_Id := First_Index (T);\n+            begin\n+               while Present (Indx) loop\n+                  Set_Debug_Info_Needed_If_Not_Set (Etype (Indx));\n+                  Indx := Next_Index (Indx);\n+               end loop;\n+            end;\n+\n+            if Is_Packed (T) then\n+               Set_Debug_Info_Needed_If_Not_Set (Packed_Array_Type (T));\n+            end if;\n+\n+         elsif Is_Access_Type (T) then\n+            Set_Debug_Info_Needed_If_Not_Set (Directly_Designated_Type (T));\n+\n+         elsif Is_Private_Type (T) then\n+            Set_Debug_Info_Needed_If_Not_Set (Full_View (T));\n+\n+         elsif Is_Protected_Type (T) then\n+            Set_Debug_Info_Needed_If_Not_Set (Corresponding_Record_Type (T));\n+         end if;\n+      end if;\n+   end Set_Debug_Info_Needed;\n+\n    ---------------------------------\n    -- Set_Entity_With_Style_Check --\n    ---------------------------------"}]}