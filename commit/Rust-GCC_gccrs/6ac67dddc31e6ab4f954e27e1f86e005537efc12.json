{"sha": "6ac67dddc31e6ab4f954e27e1f86e005537efc12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFjNjdkZGRjMzFlNmFiNGY5NTRlMjdlMWY4NmUwMDU1MzdlZmMxMg==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-11-26T10:15:32Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-11-27T20:27:13Z"}, "message": "libphobos: Merge upstream phobos 38873fe6e.\n\nAdds support for FreeBSD/x86 53-bit precision reals, and removes all\nsupport code and tests for the extern(Pascal) calling convention.\n\nReviewed-on: https://github.com/dlang/phobos/pull/7704\n\t     https://github.com/dlang/phobos/pull/7705\n\nlibphobos/ChangeLog:\n\n\t* src/MERGE: Merge upstream phobos 38873fe6e.", "tree": {"sha": "c666cde37bcbe432eded6aa61a54abf9b2367e15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c666cde37bcbe432eded6aa61a54abf9b2367e15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ac67dddc31e6ab4f954e27e1f86e005537efc12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ac67dddc31e6ab4f954e27e1f86e005537efc12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ac67dddc31e6ab4f954e27e1f86e005537efc12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ac67dddc31e6ab4f954e27e1f86e005537efc12/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9285e0f694969dc2d1d9257378ddf6c8ef42de3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9285e0f694969dc2d1d9257378ddf6c8ef42de3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9285e0f694969dc2d1d9257378ddf6c8ef42de3c"}], "stats": {"total": 133, "additions": 92, "deletions": 41}, "files": [{"sha": "cd620c9c3628f9771dbc865772d67ab3621e2a78", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac67dddc31e6ab4f954e27e1f86e005537efc12/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac67dddc31e6ab4f954e27e1f86e005537efc12/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=6ac67dddc31e6ab4f954e27e1f86e005537efc12", "patch": "@@ -1,4 +1,4 @@\n-7948e096735adbc093333da789fc28feadce24b0\n+38873fe6ee70fe8e2b7a41b7c3663e090e27d61b\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "8e488db4162b39677abd5e8e53d20746c1f1ad4a", "filename": "libphobos/src/std/complex.d", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac67dddc31e6ab4f954e27e1f86e005537efc12/libphobos%2Fsrc%2Fstd%2Fcomplex.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac67dddc31e6ab4f954e27e1f86e005537efc12/libphobos%2Fsrc%2Fstd%2Fcomplex.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcomplex.d?ref=6ac67dddc31e6ab4f954e27e1f86e005537efc12", "patch": "@@ -832,8 +832,13 @@ Complex!T sin(T)(Complex!T z)  @safe pure nothrow @nogc\n @safe pure nothrow unittest\n {\n     static import std.math;\n+    import std.math : feqrel;\n     assert(sin(complex(0.0)) == 0.0);\n-    assert(sin(complex(2.0L, 0)) == std.math.sin(2.0L));\n+    assert(sin(complex(2.0, 0)) == std.math.sin(2.0));\n+    auto c1 = sin(complex(2.0L, 0));\n+    auto c2 = complex(std.math.sin(2.0L), 0);\n+    assert(feqrel(c1.re, c2.re) >= real.mant_dig - 1 &&\n+        feqrel(c1.im, c2.im) >= real.mant_dig - 1);\n }\n \n \n@@ -849,17 +854,20 @@ Complex!T cos(T)(Complex!T z)  @safe pure nothrow @nogc\n ///\n @safe pure nothrow unittest\n {\n-    import std.complex;\n-    import std.math;\n+    static import std.math;\n+    import std.math : feqrel;\n     assert(cos(complex(0.0)) == 1.0);\n-    assert(cos(complex(1.3L)) == std.math.cos(1.3L));\n+    assert(cos(complex(1.3)) == std.math.cos(1.3));\n     auto c1 = cos(complex(0, 5.2L));\n-    auto c2 = cosh(5.2L);\n+    auto c2 = complex(std.math.cosh(5.2L), 0.0L);\n     assert(feqrel(c1.re, c2.re) >= real.mant_dig - 1 &&\n         feqrel(c1.im, c2.im) >= real.mant_dig - 1);\n+    auto c3 = cos(complex(1.3L));\n+    auto c4 = complex(std.math.cos(1.3L), 0.0L);\n+    assert(feqrel(c3.re, c4.re) >= real.mant_dig - 1 &&\n+        feqrel(c3.im, c4.im) >= real.mant_dig - 1);\n }\n \n-\n /**\n     Params: y = A real number.\n     Returns: The value of cos(y) + i sin(y)."}, {"sha": "743d203b2bbe494995d55aa522c89dc5a7beb1be", "filename": "libphobos/src/std/conv.d", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac67dddc31e6ab4f954e27e1f86e005537efc12/libphobos%2Fsrc%2Fstd%2Fconv.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac67dddc31e6ab4f954e27e1f86e005537efc12/libphobos%2Fsrc%2Fstd%2Fconv.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fconv.d?ref=6ac67dddc31e6ab4f954e27e1f86e005537efc12", "patch": "@@ -1629,6 +1629,8 @@ private void testIntegralToFloating(Integral, Floating)()\n \n private void testFloatingToIntegral(Floating, Integral)()\n {\n+    import std.math : floatTraits, RealFormat;\n+\n     bool convFails(Source, Target, E)(Source src)\n     {\n         try\n@@ -1660,18 +1662,23 @@ private void testFloatingToIntegral(Floating, Integral)()\n     {\n         a = -a; // -Integral.min not representable as an Integral\n         assert(convFails!(Floating, Integral, ConvOverflowException)(a)\n-                || Floating.sizeof <= Integral.sizeof);\n+                || Floating.sizeof <= Integral.sizeof\n+                || floatTraits!Floating.realFormat == RealFormat.ieeeExtended53);\n     }\n     a = 0.0 + Integral.min;\n     assert(to!Integral(a) == Integral.min);\n     --a; // no more representable as an Integral\n     assert(convFails!(Floating, Integral, ConvOverflowException)(a)\n-            || Floating.sizeof <= Integral.sizeof);\n+            || Floating.sizeof <= Integral.sizeof\n+            || floatTraits!Floating.realFormat == RealFormat.ieeeExtended53);\n     a = 0.0 + Integral.max;\n-    assert(to!Integral(a) == Integral.max || Floating.sizeof <= Integral.sizeof);\n+    assert(to!Integral(a) == Integral.max\n+            || Floating.sizeof <= Integral.sizeof\n+            || floatTraits!Floating.realFormat == RealFormat.ieeeExtended53);\n     ++a; // no more representable as an Integral\n     assert(convFails!(Floating, Integral, ConvOverflowException)(a)\n-            || Floating.sizeof <= Integral.sizeof);\n+            || Floating.sizeof <= Integral.sizeof\n+            || floatTraits!Floating.realFormat == RealFormat.ieeeExtended53);\n     // convert a value with a fractional part\n     a = 3.14;\n     assert(to!Integral(a) == 3);\n@@ -3016,7 +3023,9 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n @system unittest\n {\n     // @system because strtod is not @safe.\n-    static if (real.mant_dig == 53)\n+    import std.math : floatTraits, RealFormat;\n+\n+    static if (floatTraits!real.realFormat == RealFormat.ieeeDouble)\n     {\n         import core.stdc.stdlib, std.exception, std.math;\n \n@@ -3099,7 +3108,8 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n         {\n             ushort[8] value;\n         }\n-        else static if (floatTraits!real.realFormat == RealFormat.ieeeExtended)\n+        else static if (floatTraits!real.realFormat == RealFormat.ieeeExtended ||\n+                        floatTraits!real.realFormat == RealFormat.ieeeExtended53)\n         {\n             ushort[5] value;\n         }\n@@ -3122,6 +3132,8 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n         enum s = \"0x1.FFFFFFFFFFFFFFFEp-16382\";\n     else static if (floatTraits!real.realFormat == RealFormat.ieeeExtended)\n         enum s = \"0x1.FFFFFFFFFFFFFFFEp-16382\";\n+    else static if (floatTraits!real.realFormat == RealFormat.ieeeExtended53)\n+        enum s = \"0x1.FFFFFFFFFFFFFFFEp-16382\";\n     else static if (floatTraits!real.realFormat == RealFormat.ieeeDouble)\n         enum s = \"0x1.FFFFFFFFFFFFFFFEp-1000\";\n     else\n@@ -3141,6 +3153,8 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n         else\n             ld1 = strtold(s.ptr, null);\n     }\n+    else static if (floatTraits!real.realFormat == RealFormat.ieeeExtended53)\n+        ld1 = 0x1.FFFFFFFFFFFFFFFEp-16382L; // strtold rounds to 53 bits.\n     else\n         ld1 = strtold(s.ptr, null);\n "}, {"sha": "c9677c724633df4036bd8bcfb655dad5cd2b162f", "filename": "libphobos/src/std/internal/math/gammafunction.d", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac67dddc31e6ab4f954e27e1f86e005537efc12/libphobos%2Fsrc%2Fstd%2Finternal%2Fmath%2Fgammafunction.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac67dddc31e6ab4f954e27e1f86e005537efc12/libphobos%2Fsrc%2Fstd%2Finternal%2Fmath%2Fgammafunction.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Finternal%2Fmath%2Fgammafunction.d?ref=6ac67dddc31e6ab4f954e27e1f86e005537efc12", "patch": "@@ -253,6 +253,8 @@ static if (floatTraits!(real).realFormat == RealFormat.ieeeQuadruple)\n     enum real MAXGAMMA = 1755.5483429L;\n else static if (floatTraits!(real).realFormat == RealFormat.ieeeExtended)\n     enum real MAXGAMMA = 1755.5483429L;\n+else static if (floatTraits!(real).realFormat == RealFormat.ieeeExtended53)\n+    enum real MAXGAMMA = 1755.5483429L;\n else static if (floatTraits!(real).realFormat == RealFormat.ieeeDouble)\n     enum real MAXGAMMA = 171.6243769L;\n else\n@@ -603,6 +605,11 @@ else static if (floatTraits!(real).realFormat == RealFormat.ieeeExtended)\n     enum real MAXLOG = 0x1.62e42fefa39ef358p+13L;  // log(real.max)\n     enum real MINLOG = -0x1.6436716d5406e6d8p+13L; // log(real.min_normal*real.epsilon) = log(smallest denormal)\n }\n+else static if (floatTraits!(real).realFormat == RealFormat.ieeeExtended53)\n+{\n+    enum real MAXLOG = 0x1.62e42fefa39ef358p+13L;  // log(real.max)\n+    enum real MINLOG = -0x1.6436716d5406e6d8p+13L; // log(real.min_normal*real.epsilon) = log(smallest denormal)\n+}\n else static if (floatTraits!(real).realFormat == RealFormat.ieeeDouble)\n {\n     enum real MAXLOG = 0x1.62e42fefa39efp+9L;  // log(real.max)"}, {"sha": "3d18cfa528b923603b21ed06bcce4fb7832d0f8a", "filename": "libphobos/src/std/math.d", "status": "modified", "additions": 47, "deletions": 25, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac67dddc31e6ab4f954e27e1f86e005537efc12/libphobos%2Fsrc%2Fstd%2Fmath.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac67dddc31e6ab4f954e27e1f86e005537efc12/libphobos%2Fsrc%2Fstd%2Fmath.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fmath.d?ref=6ac67dddc31e6ab4f954e27e1f86e005537efc12", "patch": "@@ -495,7 +495,8 @@ T floorImpl(T)(const T x) @trusted pure nothrow @nogc\n         else\n             int pos = 3;\n     }\n-    else static if (F.realFormat == RealFormat.ieeeExtended)\n+    else static if (F.realFormat == RealFormat.ieeeExtended ||\n+                    F.realFormat == RealFormat.ieeeExtended53)\n     {\n         int exp = (y.vu[F.EXPPOS_SHORT] & 0x7fff) - 0x3fff;\n \n@@ -542,7 +543,10 @@ T floorImpl(T)(const T x) @trusted pure nothrow @nogc\n     }\n     else\n     {\n-        exp = (T.mant_dig - 1) - exp;\n+        static if (F.realFormat == RealFormat.ieeeExtended53)\n+            exp = (T.mant_dig + 11 - 1) - exp; // mant_dig is really 64\n+        else\n+            exp = (T.mant_dig - 1) - exp;\n \n         // Zero 16 bits at a time.\n         while (exp >= 16)\n@@ -1079,13 +1083,13 @@ Lret: {}\n         real t = tan(x);\n \n         //printf(\"tan(%Lg) = %Lg, should be %Lg\\n\", x, t, r);\n-        if (!isIdentical(r, t)) assert(fabs(r-t) <= .0000001);\n+        assert(approxEqual(r, t));\n \n         x = -x;\n         r = -r;\n         t = tan(x);\n         //printf(\"tan(%Lg) = %Lg, should be %Lg\\n\", x, t, r);\n-        if (!isIdentical(r, t) && !(r != r && t != t)) assert(fabs(r-t) <= .0000001);\n+        assert(approxEqual(r, t));\n     }\n     // overflow\n     assert(isNaN(tan(real.infinity)));\n@@ -1150,7 +1154,7 @@ float asin(float x) @safe pure nothrow @nogc  { return asin(cast(real) x); }\n \n @system unittest\n {\n-    assert(equalsDigit(asin(0.5), PI / 6, useDigits));\n+    assert(asin(0.5).approxEqual(PI / 6));\n }\n \n /***************\n@@ -1379,7 +1383,7 @@ float atan2(float y, float x) @safe pure nothrow @nogc\n \n @system unittest\n {\n-    assert(equalsDigit(atan2(1.0L, std.math.sqrt(3.0L)), PI / 6, useDigits));\n+    assert(atan2(1.0, sqrt(3.0)).approxEqual(PI / 6));\n }\n \n /***********************************\n@@ -1441,7 +1445,7 @@ float sinh(float x) @safe pure nothrow @nogc  { return sinh(cast(real) x); }\n \n @system unittest\n {\n-    assert(equalsDigit(sinh(1.0), (E - 1.0 / E) / 2, useDigits));\n+    assert(sinh(1.0).approxEqual((E - 1.0 / E) / 2));\n }\n \n /***********************************\n@@ -1791,7 +1795,8 @@ real exp(real x) @trusted pure nothrow @nogc\n             enum real OF =  7.09782712893383996732E2;  // ln((1-2^-53) * 2^1024)\n             enum real UF = -7.451332191019412076235E2; // ln(2^-1075)\n         }\n-        else static if (F.realFormat == RealFormat.ieeeExtended)\n+        else static if (F.realFormat == RealFormat.ieeeExtended ||\n+                        F.realFormat == RealFormat.ieeeExtended53)\n         {\n             // Coefficients for exp(x)\n             static immutable real[3] P = [\n@@ -1882,7 +1887,7 @@ float exp(float x)  @safe pure nothrow @nogc   { return exp(cast(real) x); }\n \n @system unittest\n {\n-    assert(equalsDigit(exp(3.0L), E * E * E, useDigits));\n+    assert(exp(3.0).feqrel(E * E * E) > 16);\n }\n \n /**\n@@ -2468,7 +2473,8 @@ private real exp2Impl(real x) @nogc @trusted pure nothrow\n         ctrl.rounding = FloatingPointControl.roundToNearest;\n     }\n \n-    static if (real.mant_dig == 113)\n+    enum realFormat = floatTraits!real.realFormat;\n+    static if (realFormat == RealFormat.ieeeQuadruple)\n     {\n         static immutable real[2][] exptestpoints =\n         [ //  x               exp(x)\n@@ -2487,7 +2493,8 @@ private real exp2Impl(real x) @nogc @trusted pure nothrow\n             [-0x1p+30L,       0                                        ], // far underflow\n         ];\n     }\n-    else static if (real.mant_dig == 64) // 80-bit reals\n+    else static if (realFormat == RealFormat.ieeeExtended ||\n+                    realFormat == RealFormat.ieeeExtended53)\n     {\n         static immutable real[2][] exptestpoints =\n         [ //  x               exp(x)\n@@ -2506,7 +2513,7 @@ private real exp2Impl(real x) @nogc @trusted pure nothrow\n             [-0x1p+30L,       0                            ], // far underflow\n         ];\n     }\n-    else static if (real.mant_dig == 53) // 64-bit reals\n+    else static if (realFormat == RealFormat.ieeeDouble)\n     {\n         static immutable real[2][] exptestpoints =\n         [ //  x,             exp(x)\n@@ -2527,14 +2534,14 @@ private real exp2Impl(real x) @nogc @trusted pure nothrow\n     else\n         static assert(0, \"No exp() tests for real type!\");\n \n-    const minEqualDecimalDigits = real.dig - 3;\n+    const minEqualMantissaBits = real.mant_dig - 13;\n     real x;\n     version (IeeeFlagsSupport) IeeeFlags f;\n     foreach (ref pair; exptestpoints)\n     {\n         version (IeeeFlagsSupport) resetIeeeFlags();\n         x = exp(pair[0]);\n-        assert(equalsDigit(x, pair[1], minEqualDecimalDigits));\n+        assert(feqrel(x, pair[1]) >= minEqualMantissaBits);\n     }\n \n     // Ideally, exp(0) would not set the inexact flag.\n@@ -2650,7 +2657,8 @@ if (isFloatingPoint!T)\n     alias F = floatTraits!T;\n \n     ex = vu[F.EXPPOS_SHORT] & F.EXPMASK;\n-    static if (F.realFormat == RealFormat.ieeeExtended)\n+    static if (F.realFormat == RealFormat.ieeeExtended ||\n+               F.realFormat == RealFormat.ieeeExtended53)\n     {\n         if (ex)\n         {   // If exponent is non-zero\n@@ -2938,7 +2946,8 @@ if (isFloatingPoint!T)\n     y.rv = x;\n \n     int ex = y.vu[F.EXPPOS_SHORT] & F.EXPMASK;\n-    static if (F.realFormat == RealFormat.ieeeExtended)\n+    static if (F.realFormat == RealFormat.ieeeExtended ||\n+               F.realFormat == RealFormat.ieeeExtended53)\n     {\n         if (ex)\n         {\n@@ -3184,6 +3193,7 @@ float ldexp(float n, int exp) @safe pure nothrow @nogc { return ldexp(cast(real)\n @safe pure nothrow @nogc unittest\n {\n     static if (floatTraits!(real).realFormat == RealFormat.ieeeExtended ||\n+               floatTraits!(real).realFormat == RealFormat.ieeeExtended53 ||\n                floatTraits!(real).realFormat == RealFormat.ieeeQuadruple)\n     {\n         assert(ldexp(1.0L, -16384) == 0x1p-16384L);\n@@ -4428,12 +4438,16 @@ long lrint(real x) @trusted pure nothrow @nogc\n \n             return sign ? -result : result;\n         }\n-        else static if (F.realFormat == RealFormat.ieeeExtended)\n+        else static if (F.realFormat == RealFormat.ieeeExtended ||\n+                        F.realFormat == RealFormat.ieeeExtended53)\n         {\n             long result;\n \n             // Rounding limit when casting from real(80-bit) to ulong.\n-            enum real OF = 9.22337203685477580800E18L;\n+            static if (F.realFormat == RealFormat.ieeeExtended)\n+                enum real OF = 9.22337203685477580800E18L;\n+            else\n+                enum real OF = 4.50359962737049600000E15L;\n \n             ushort* vu = cast(ushort*)(&x);\n             uint* vi = cast(uint*)(&x);\n@@ -5904,7 +5918,8 @@ bool isSubnormal(X)(X x) @trusted pure nothrow @nogc\n         return (e == 0 &&\n           ((ps[MANTISSA_LSB]|(ps[MANTISSA_MSB]& 0x0000_FFFF_FFFF_FFFF)) != 0));\n     }\n-    else static if (F.realFormat == RealFormat.ieeeExtended)\n+    else static if (F.realFormat == RealFormat.ieeeExtended ||\n+                    F.realFormat == RealFormat.ieeeExtended53)\n     {\n         ushort* pe = cast(ushort *)&x;\n         long*   ps = cast(long *)&x;\n@@ -5954,7 +5969,8 @@ if (isFloatingPoint!(X))\n         return ((*cast(ulong *)&x) & 0x7FFF_FFFF_FFFF_FFFF)\n             == 0x7FF0_0000_0000_0000;\n     }\n-    else static if (F.realFormat == RealFormat.ieeeExtended)\n+    else static if (F.realFormat == RealFormat.ieeeExtended ||\n+                    F.realFormat == RealFormat.ieeeExtended53)\n     {\n         const ushort e = cast(ushort)(F.EXPMASK & (cast(ushort *)&x)[F.EXPPOS_SHORT]);\n         const ulong ps = *cast(ulong *)&x;\n@@ -6217,7 +6233,8 @@ F sgn(F)(F x) @safe pure nothrow @nogc\n real NaN(ulong payload) @trusted pure nothrow @nogc\n {\n     alias F = floatTraits!(real);\n-    static if (F.realFormat == RealFormat.ieeeExtended)\n+    static if (F.realFormat == RealFormat.ieeeExtended ||\n+               F.realFormat == RealFormat.ieeeExtended53)\n     {\n         // real80 (in x86 real format, the implied bit is actually\n         // not implied but a real bit which is stored in the real)\n@@ -6423,11 +6440,14 @@ real nextUp(real x) @trusted pure nothrow @nogc\n         }\n         return x;\n     }\n-    else static if (F.realFormat == RealFormat.ieeeExtended)\n+    else static if (F.realFormat == RealFormat.ieeeExtended ||\n+                    F.realFormat == RealFormat.ieeeExtended53)\n     {\n         // For 80-bit reals, the \"implied bit\" is a nuisance...\n         ushort *pe = cast(ushort *)&x;\n         ulong  *ps = cast(ulong  *)&x;\n+        // EPSILON is 1 for 64-bit, and 2048 for 53-bit precision reals.\n+        enum ulong EPSILON = 2UL ^^ (64 - real.mant_dig);\n \n         if ((pe[F.EXPPOS_SHORT] & F.EXPMASK) == F.EXPMASK)\n         {\n@@ -6438,7 +6458,7 @@ real nextUp(real x) @trusted pure nothrow @nogc\n         if (pe[F.EXPPOS_SHORT] & 0x8000)\n         {\n             // Negative number -- need to decrease the significand\n-            --*ps;\n+            *ps -= EPSILON;\n             // Need to mask with 0x7FFF... so subnormals are treated correctly.\n             if ((*ps & 0x7FFF_FFFF_FFFF_FFFF) == 0x7FFF_FFFF_FFFF_FFFF)\n             {\n@@ -6463,7 +6483,7 @@ real nextUp(real x) @trusted pure nothrow @nogc\n         {\n             // Positive number -- need to increase the significand.\n             // Works automatically for positive zero.\n-            ++*ps;\n+            *ps += EPSILON;\n             if ((*ps & 0x7FFF_FFFF_FFFF_FFFF) == 0)\n             {\n                 // change in exponent\n@@ -7228,6 +7248,7 @@ if (isFloatingPoint!(X))\n         static assert(F.realFormat == RealFormat.ieeeSingle\n                     || F.realFormat == RealFormat.ieeeDouble\n                     || F.realFormat == RealFormat.ieeeExtended\n+                    || F.realFormat == RealFormat.ieeeExtended53\n                     || F.realFormat == RealFormat.ieeeQuadruple);\n \n         if (x == y)\n@@ -7367,7 +7388,8 @@ body\n \n     alias F = floatTraits!(T);\n     T u;\n-    static if (F.realFormat == RealFormat.ieeeExtended)\n+    static if (F.realFormat == RealFormat.ieeeExtended ||\n+               F.realFormat == RealFormat.ieeeExtended53)\n     {\n         // There's slight additional complexity because they are actually\n         // 79-bit reals..."}, {"sha": "7badab4280b7b30e1e01d6e6ad757a4c742f73cf", "filename": "libphobos/src/std/traits.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac67dddc31e6ab4f954e27e1f86e005537efc12/libphobos%2Fsrc%2Fstd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac67dddc31e6ab4f954e27e1f86e005537efc12/libphobos%2Fsrc%2Fstd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ftraits.d?ref=6ac67dddc31e6ab4f954e27e1f86e005537efc12", "patch": "@@ -1927,7 +1927,7 @@ Determine the linkage attribute of the function.\n Params:\n     func = the function symbol, or the type of a function, delegate, or pointer to function\n Returns:\n-    one of the strings \"D\", \"C\", \"Windows\", \"Pascal\", or \"Objective-C\"\n+    one of the strings \"D\", \"C\", \"Windows\", or \"Objective-C\"\n */\n template functionLinkage(func...)\n     if (func.length == 1 && isCallable!func)\n@@ -2148,7 +2148,7 @@ template SetFunctionAttributes(T, string linkage, uint attrs)\n             !(attrs & FunctionAttribute.safe),\n             \"Cannot have a function/delegate that is both trusted and safe.\");\n \n-        static immutable linkages = [\"D\", \"C\", \"Windows\", \"Pascal\", \"C++\", \"System\"];\n+        static immutable linkages = [\"D\", \"C\", \"Windows\", \"C++\", \"System\"];\n         static assert(canFind(linkages, linkage), \"Invalid linkage '\" ~\n             linkage ~ \"', must be one of \" ~ linkages.stringof ~ \".\");\n \n@@ -2263,7 +2263,7 @@ version (unittest)\n             // Check that all linkage types work (D-style variadics require D linkage).\n             static if (variadicFunctionStyle!T != Variadic.d)\n             {\n-                foreach (newLinkage; AliasSeq!(\"D\", \"C\", \"Windows\", \"Pascal\", \"C++\"))\n+                foreach (newLinkage; AliasSeq!(\"D\", \"C\", \"Windows\", \"C++\"))\n                 {\n                     alias New = SetFunctionAttributes!(T, newLinkage, attrs);\n                     static assert(functionLinkage!New == newLinkage,"}]}