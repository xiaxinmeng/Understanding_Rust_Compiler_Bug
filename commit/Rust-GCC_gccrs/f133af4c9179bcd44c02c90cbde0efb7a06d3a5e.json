{"sha": "f133af4c9179bcd44c02c90cbde0efb7a06d3a5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEzM2FmNGM5MTc5YmNkNDRjMDJjOTBjYmRlMGVmYjdhMDZkM2E1ZQ==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-01-17T15:50:34Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-01-17T15:50:34Z"}, "message": "(emit_move_sequence): Fix spacing.\n\n(compute_zdepi_operands): Fix header comment.\n(many functions): Use %%r register syntax.  Use canonical (0,%rN)\naddress format.\n(output_function_prologue): No need to test frame_pointer_needed\nin else clause of `if (frame_pointer_needed)'.\n(output_function_prologue): Test boolean merge_sp_adjust_with_store\nfor zeroness, not for equality with 1.\n(fmpyaddoperands): Use new variable mode for mode of operands[0].\n(fmpysuboperands): Likewise.\n\nFrom-SVN: r3258", "tree": {"sha": "d536212720b91992f9dc200329edd7e6f1bcf33b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d536212720b91992f9dc200329edd7e6f1bcf33b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f133af4c9179bcd44c02c90cbde0efb7a06d3a5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f133af4c9179bcd44c02c90cbde0efb7a06d3a5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f133af4c9179bcd44c02c90cbde0efb7a06d3a5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f133af4c9179bcd44c02c90cbde0efb7a06d3a5e/comments", "author": null, "committer": null, "parents": [{"sha": "c2264220583c0f09fd42619b06ca08a442e3bc57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2264220583c0f09fd42619b06ca08a442e3bc57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2264220583c0f09fd42619b06ca08a442e3bc57"}], "stats": {"total": 152, "additions": 61, "deletions": 91}, "files": [{"sha": "055653277d00dcee5137ad334d6739f7be743d22", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 61, "deletions": 91, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f133af4c9179bcd44c02c90cbde0efb7a06d3a5e/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f133af4c9179bcd44c02c90cbde0efb7a06d3a5e/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=f133af4c9179bcd44c02c90cbde0efb7a06d3a5e", "patch": "@@ -642,7 +642,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n       else if (GET_CODE (operand1) != CONST_INT\n \t       || (! INT_14_BITS (operand1)\n \t\t   && ! ((INTVAL (operand1) & 0x7ff) == 0)\n-\t\t   && !zdepi_cint_p (INTVAL (operand1))))\n+\t\t   && ! zdepi_cint_p (INTVAL (operand1))))\n \t{\n \t  rtx temp = reload_in_progress ? operand0 : gen_reg_rtx (mode);\n \t  emit_insn (gen_rtx (SET, VOIDmode, temp,\n@@ -655,7 +655,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n }\n \n /* Does operand (which is a symbolic_operand) live in text space? If\n-   so SYMBOL_REF_FLAG, which is set by ENCODE_SECTION_INFO, will be true.*/\n+   so SYMBOL_REF_FLAG, which is set by ENCODE_SECTION_INFO, will be true.  */\n \n int\n read_only_operand (operand)\n@@ -689,9 +689,9 @@ singlemove_string (operands)\n }\n \f\n \n-/* Compute position (in OP[2]) and width (in OP[3])\n-   useful for copying or or'ing IMM to a register using bit field\n-   instructions.  Store the immediate value to insert in OP[1].  */\n+/* Compute position (in OP[1]) and width (in OP[2])\n+   useful for copying IMM to a register using the zdepi\n+   instructions.  Store the immediate value to insert in OP[0].  */\n void\n compute_zdepi_operands (imm, op)\n      unsigned imm;\n@@ -1349,7 +1349,7 @@ output_ascii (file, p, size)\n   fprintf (file, \"\\\"\\n\");\n }\n \f\n-/* You may have trouble believing this, but this is the HP825 stack\n+/* You may have trouble believing this, but this is the HP-PA stack\n    layout.  Wow.\n \n    Offset\t\tContents\n@@ -1419,9 +1419,9 @@ print_stw (file, r, disp, base)\n      int r, disp, base;\n {\n   if (VAL_14_BITS_P (disp))\n-    fprintf (file, \"\\tstw %d,%d(0,%d)\\n\", r, disp, base);\n+    fprintf (file, \"\\tstw %%r%d,%d(0,%%r%d)\\n\", r, disp, base);\n   else\n-    fprintf (file, \"\\taddil L'%d,%d\\n\\tstw %d,R'%d(0,1)\\n\", disp, base,\n+    fprintf (file, \"\\taddil L'%d,%%r%d\\n\\tstw %%r%d,R'%d(0,%%r1)\\n\", disp, base,\n \t     r, disp);\n }\n \n@@ -1433,7 +1433,7 @@ print_ldw (file, r, disp, base)\n   if (VAL_14_BITS_P (disp))\n     fprintf (file, \"\\tldw %d(0,%d),%d\\n\", disp, base, r);\n   else\n-    fprintf (file, \"\\taddil L'%d,%d\\n\\tldw R'%d(0,1),%d\\n\", disp, base,\n+    fprintf (file, \"\\taddil L'%d,%d\\n\\tldw R'%d(0,%%r1),%d\\n\", disp, base,\n \t     disp, r);\n }\n \n@@ -1518,42 +1518,38 @@ output_function_prologue (file, size)\n      structure.  */\n \n   if (regs_ever_live[2] || profile_flag)\n-    fprintf (file, \"\\tstw 2,-20(0,30)\\n\");\n+    fprintf (file, \"\\tstw %%r2,-20(0,%%r30)\\n\");\n \n   /* Reserve space for local variables.  */\n   if (actual_fsize)\n     if (frame_pointer_needed)\n       {\n \tif (VAL_14_BITS_P (actual_fsize))\n-\t  fprintf (file, \"\\tcopy 4,1\\n\\tcopy 30,4\\n\\tstwm 1,%d(0,30)\\n\",\n+\t  fprintf (file, \"\\tcopy %%r4,%%r1\\n\\tcopy %%r30,%%r4\\n\\tstwm %%r1,%d(0,%%r30)\\n\",\n \t\t   actual_fsize);\n \telse\n \t  {\n-\t    fprintf (file, \"\\tcopy 4,1\\n\\tcopy 30,4\\n\\tstw 1,0(0,4)\\n\");\n-\t    fprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),30\\n\",\n+\t    fprintf (file, \"\\tcopy %%r4,%%r1\\n\\tcopy %%r30,%%r4\\n\\tstw %%r1,0(0,%%r4)\\n\");\n+\t    fprintf (file, \"\\taddil L'%d,%%r30\\n\\tldo R'%d(%%r1),%%r30\\n\",\n \t\t     actual_fsize, actual_fsize);\n \t  }\n       }\n     else\n-      /* Used to be abort ();  */\n       {\n-\tif (VAL_14_BITS_P (-actual_fsize) \n-\t    && local_fsize == 0\n-\t    && ! frame_pointer_needed\n-\t    && ! flag_pic\n-\t    && ! profile_flag)\n+\tif (VAL_14_BITS_P (-actual_fsize)\n+\t    && local_fsize == 0 && ! flag_pic && ! profile_flag)\n \t  merge_sp_adjust_with_store = 1;\n \telse if (VAL_14_BITS_P (actual_fsize))\n-\t  fprintf (file, \"\\tldo %d(30),30\\n\", actual_fsize);\n+\t  fprintf (file, \"\\tldo %d(%%r30),%%r30\\n\", actual_fsize);\n \telse\n-\t  fprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),30\\n\",\n+\t  fprintf (file, \"\\taddil L'%d,%%r30\\n\\tldo R'%d(%%r1),%%r30\\n\",\n \t\t   actual_fsize, actual_fsize);\n       }\n-  /* The hppa calling conventions say that that %r19, the pic offset \n+  /* The hppa calling conventions say that that %r19, the pic offset\n      register, is saved at sp - 32 (in this function's frame) */\n   if (flag_pic)\n     {\n-      fprintf (file, \"\\tstw %%r19,-32(%%r30)\\n\");\n+      fprintf (file, \"\\tstw %%r19,-32(0,%%r30)\\n\");\n     }\n   /* Instead of taking one argument, the counter label, as most normal\n      mcounts do, _mcount appears to behave differently on the HPPA. It\n@@ -1591,9 +1587,7 @@ output_function_prologue (file, size)\n \t    pc_offset += VAL_14_BITS_P (arg_offset) ? 4 : 8;\n \t  }\n       fprintf (file,\n-\t       \"\\tcopy %%r2,%%r26\\n\\taddil L'LP$%04d-$global$,%%r27\\n\\\n-\\tldo R'LP$%04d-$global$(%%r1),%%r24\\n\\tbl _mcount,%%r2\\n\\\n-\\tldo %d(%%r2),%%r25\\n\",\n+\t       \"\\tcopy %%r2,%%r26\\n\\taddil L'LP$%04d-$global$,%%r27\\n\\tldo R'LP$%04d-$global$(%%r1),%%r24\\n\\tbl _mcount,%%r2\\n\\tldo %d(%%r2),%%r25\\n\",\n \t       hp_profile_labelno, hp_profile_labelno, -pc_offset - 12 - 8);\n       for (i = 26, arg_offset = -36 - offsetadj; i >= 23; i--, arg_offset -= 4)\n \tif (regs_ever_live[i])\n@@ -1622,7 +1616,7 @@ output_function_prologue (file, size)\n \t  {\n \t    /* If merge_sp_adjust_with_store is nonzero, then we can \n \t       optimize the first GR save.  */\n-\t    if (merge_sp_adjust_with_store == 1)\n+\t    if (merge_sp_adjust_with_store)\n \t      {\n \t\tmerge_sp_adjust_with_store = 0;\n     \t\tfprintf (file, \"\\tstwm %d,%d(0,%d)\\n\", i, -offset, 30);\n@@ -1634,18 +1628,18 @@ output_function_prologue (file, size)\n \t{\n \t    /* If merge_sp_adjust_with_store is nonzero, then we can \n \t       optimize the first GR save.  */\n-\t  if (merge_sp_adjust_with_store == 1)\n+\t  if (merge_sp_adjust_with_store)\n \t    {\n \t      merge_sp_adjust_with_store = 0;\n-    \t      fprintf (file, \"\\tstwm %d,%d(0,%d)\\n\", 3, -offset, 30);\n+    \t      fprintf (file, \"\\tstwm %%r3,%d(0,%%r30)\\n\", -offset);\n \t    }\n \t  else\n \t    print_stw (file, 3, offset, 30);  offset += 4;\n \t}\n       /* If we wanted to merge the SP adjustment with a GR save, but we never\n \t did any GR saves, then just output the adjustment here.  */\n-      if (merge_sp_adjust_with_store == 1)\n-\tfprintf (file, \"\\tldo %d(30),30\\n\", actual_fsize);\n+      if (merge_sp_adjust_with_store)\n+\tfprintf (file, \"\\tldo %d(%%r30),%%r30\\n\", actual_fsize);\n     }\n       \n   /* Align pointer properly (doubleword boundary).  */\n@@ -1657,33 +1651,33 @@ output_function_prologue (file, size)\n       if (frame_pointer_needed)\n \t{\n \t  if (VAL_14_BITS_P (offset))\n-\t    fprintf (file, \"\\tldo %d(4),1\\n\", offset);\n+\t    fprintf (file, \"\\tldo %d(%%r4),%%r1\\n\", offset);\n \t  else\n-\t    fprintf (file, \"\\taddil L'%d,4\\n\\tldo R'%d(1),1\\n\",\n+\t    fprintf (file, \"\\taddil L'%d,%%r4\\n\\tldo R'%d(%%r1),%%r1\\n\",\n \t\t     offset, offset);\n \t}\n       else\n \t{\n \t  if (VAL_14_BITS_P (offset))\n-\t    fprintf (file, \"\\tldo %d(30),1\\n\", offset);\n+\t    fprintf (file, \"\\tldo %d(%%r30),%%r1\\n\", offset);\n \t  else\n-\t    fprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),1\\n\",\n+\t    fprintf (file, \"\\taddil L'%d,%%r30\\n\\tldo R'%d(%%r1),%%r1\\n\",\n \t\t     offset, offset);\n \t}\n       if (!TARGET_SNAKE)\n \t{\n \t  for (i = 47; i >= 44; i--)\n \t    {\n \t      if (regs_ever_live[i])\n-\t\tfprintf (file, \"\\tfstds,ma %s,8(0,1)\\n\", reg_names[i]);\n+\t\tfprintf (file, \"\\tfstds,ma %s,8(0,%%r1)\\n\", reg_names[i]);\n \t    }\n \t}\n       else\n \t{\n \t  for (i = 90; i >= 72; i -= 2)\n \t    if (regs_ever_live[i] || regs_ever_live[i + 1])\n \t      {\n-\t\tfprintf (file, \"\\tfstds,ma %s,8(0,1)\\n\", reg_names[i]);\n+\t\tfprintf (file, \"\\tfstds,ma %s,8(0,%%r1)\\n\", reg_names[i]);\n \t      }\n \t}\n     }\n@@ -1707,7 +1701,7 @@ output_function_epilogue (file, size)\n   else if (actual_fsize\n \t   && VAL_14_BITS_P (actual_fsize + 20)\n \t   && (regs_ever_live [2] || profile_flag))\n-    fprintf(file,\"\\tldw %d(30),2\\n\", - (actual_fsize + 20));\n+    fprintf(file,\"\\tldw %d(0,%%r30),%%r2\\n\", - (actual_fsize + 20));\n \n   if (frame_pointer_needed)\n     {\n@@ -1761,33 +1755,33 @@ output_function_epilogue (file, size)\n       if (frame_pointer_needed)\n \t{\n \t  if (VAL_14_BITS_P (offset))\n-\t    fprintf (file, \"\\tldo %d(4),1\\n\", offset);\n+\t    fprintf (file, \"\\tldo %d(%%r4),%%r1\\n\", offset);\n \t  else\n-\t    fprintf (file, \"\\taddil L'%d,4\\n\\tldo R'%d(1),1\\n\",\n+\t    fprintf (file, \"\\taddil L'%d,%%r4\\n\\tldo R'%d(%%r1),%%r1\\n\",\n \t\t     offset, offset);\n \t}\n       else\n \t{\n \t  if (VAL_14_BITS_P (offset))\n-\t    fprintf (file, \"\\tldo %d(30),1\\n\", offset);\n+\t    fprintf (file, \"\\tldo %d(%%r30),%%r1\\n\", offset);\n \t  else\n-\t    fprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),1\\n\",\n+\t    fprintf (file, \"\\taddil L'%d,%%r30\\n\\tldo R'%d(%%r1),%%r1\\n\",\n \t\t     offset, offset);\n \t}\n       if (!TARGET_SNAKE)\n \t{\n \t  for (i = 47; i >= 44; i--)\n \t    {\n \t      if (regs_ever_live[i])\n-\t\tfprintf (file, \"\\tfldds,ma 8(0,1),%s\\n\", reg_names[i]);\n+\t\tfprintf (file, \"\\tfldds,ma 8(0,%%r1),%s\\n\", reg_names[i]);\n \t    }\n \t}\n       else\n \t{\n \t  for (i = 90; i >= 72; i -= 2)\n \t    if (regs_ever_live[i] || regs_ever_live[i + 1])\n \t      {\n-\t\tfprintf (file, \"\\tfldds,ma 8(0,1),%s\\n\", reg_names[i]);\n+\t\tfprintf (file, \"\\tfldds,ma 8(0,%%r1),%s\\n\", reg_names[i]);\n \t      }\n \t}\n     }\n@@ -1798,7 +1792,7 @@ output_function_epilogue (file, size)\n     {\n       /* RP has already been restored in this case.  */\n       fprintf (file, \"\\tldo 64(%%r4),%%r30\\n\");\n-      fprintf (file, \"\\tbv 0(%%r2)\\n\\tldwm -64(%%r30),4\\n\");\n+      fprintf (file, \"\\tbv 0(%%r2)\\n\\tldwm -64(0,%%r30),%%r4\\n\");\n     }\n   else if (actual_fsize)\n     {\n@@ -1810,39 +1804,38 @@ output_function_epilogue (file, size)\n \t    {\n \t      /* Optimize load and sp adjustment.  */\n \t      if (merge_sp_adjust_with_load)\n-\t\tfprintf (file, \"\\tbv 0(2)\\n\\tldwm %d(30),%d\\n\",\n+\t\tfprintf (file, \"\\tbv 0(%%r2)\\n\\tldwm %d(0,%%r30),%d\\n\",\n \t\t\t -actual_fsize, merge_sp_adjust_with_load);\n \t      else\n-\t\tfprintf (file, \"\\tbv 0(2)\\n\\tldo %d(30),30\\n\", -actual_fsize);\n+\t\tfprintf (file, \"\\tbv 0(%%r2)\\n\\tldo %d(%%r30),%%r30\\n\", -actual_fsize);\n \t    }\n \t  /* Large frame.  Uncommon and not worth extra hair to avoid\n \t     load/use delay for RP.  */\n \t  else\n \t    fprintf (file,\n-\t\t     \"\\taddil L'%d,30\\n\\tldw %d(1),2\\n\\tbv 0(2)\\n\\\n-\\tldo R'%d(1),30\\n\",\n+\t\t     \"\\taddil L'%d,%%r30\\n\\tldw %d(0,%%r1),%%r2\\n\\tbv 0(%%r2)\\n\\tldo R'%d(%%r1),%%r30\\n\",\n \t\t     - actual_fsize,\n \t\t     - (actual_fsize + 20 + ((-actual_fsize) & ~0x7ff)),\n \t\t     - actual_fsize);\n \t}\n       /* Merge load with SP adjustment.  */\n       else if (merge_sp_adjust_with_load)\n-\tfprintf (file, \"\\tbv 0(2)\\n\\tldwm %d(0,30),%d\\n\", \n+\tfprintf (file, \"\\tbv 0(%%r2)\\n\\tldwm %d(0,%%r30),%d\\n\", \n \t\t - actual_fsize, merge_sp_adjust_with_load);\n       else if (VAL_14_BITS_P (actual_fsize))\n-\tfprintf (file, \"\\tbv 0(2)\\n\\tldo %d(30),30\\n\", - actual_fsize);\n+\tfprintf (file, \"\\tbv 0(%%r2)\\n\\tldo %d(%%r30),%%r30\\n\", - actual_fsize);\n       else\n-\tfprintf (file, \"\\taddil L'%d,30\\n\\tbv 0(2)\\n\\tldo R'%d(1),30\\n\",\n+\tfprintf (file, \"\\taddil L'%d,%%r30\\n\\tbv 0(%%r2)\\n\\tldo R'%d(%%r1),%%r30\\n\",\n \t\t - actual_fsize, - actual_fsize);\n     }\n   else if (current_function_epilogue_delay_list)\n     {\n-      fprintf (file, \"\\tbv 0(2)\\n\");\n+      fprintf (file, \"\\tbv 0(%%r2)\\n\");\n       final_scan_insn (XEXP (current_function_epilogue_delay_list, 0), file,\n \t\t       1, 0, 1);\n     }\n   else\n-    fprintf (file, \"\\tbv,n 0(2)\\n\");\n+    fprintf (file, \"\\tbv,n 0(%%r2)\\n\");\n   fprintf (file, \"\\t.EXIT\\n\\t.PROCEND\\n\");\n }\n \n@@ -1961,31 +1954,6 @@ print_operand (file, x, code)\n \t}\n       else\n \tbreak;\n-    case 'O':\n-      switch (GET_CODE (x))\n-\t{\n-\tcase PLUS:\n-\t  fprintf (file, \"add%s\",\n-\t\t   GET_CODE (XEXP (x, 1)) == CONST_INT ? \"i\" : \"\");  break;\n-\tcase MINUS:\n-\t  fprintf (file, \"sub%s\",\n-\t\t   GET_CODE (XEXP (x, 0)) == CONST_INT ? \"i\" : \"\");  break;\n-\tcase AND:\n-\t  fprintf (file, \"and%s\",\n-\t\t   GET_CODE (XEXP (x, 1)) == NOT ? \"cm\" : \"\");  break;\n-\tcase IOR:\n-\t  fprintf (file, \"or\");  break;\n-\tcase XOR:\n-\t  fprintf (file, \"xor\");  break;\n-\tcase ASHIFT:\n-\t  fprintf (file, \"sh%dadd\", INTVAL (XEXP (x, 1)));  break;\n-\t  /* Too lazy to handle bitfield conditions yet.  */\n-\tdefault:\n-\t  printf (\"Can't grok '%c' operator:\\n\", code);\n-\t  debug_rtx (x);\n-\t  abort ();\n-\t}\n-      return;\n     case 'C':\n     case 'X':\n       switch (GET_CODE (x))\n@@ -2579,18 +2547,19 @@ int\n fmpyaddoperands(operands)\n      rtx *operands;\n {\n+  enum machine_mode mode = GET_MODE (operands[0]);\n \n   /* All modes must be the same.  */\n-  if (! (GET_MODE (operands[0]) == GET_MODE (operands[1])\n-\t && GET_MODE (operands[0]) == GET_MODE (operands[2])\n-\t && GET_MODE (operands[0]) == GET_MODE (operands[3])\n-\t && GET_MODE (operands[0]) == GET_MODE (operands[4])\n-\t && GET_MODE (operands[0]) == GET_MODE (operands[5])))\n+  if (! (mode == GET_MODE (operands[1])\n+\t && mode == GET_MODE (operands[2])\n+\t && mode == GET_MODE (operands[3])\n+\t && mode == GET_MODE (operands[4])\n+\t && mode == GET_MODE (operands[5])))\n     return 0;\n \n   /* Both DFmode and SFmode should work.  But using SFmode makes the\n      assembler complain.  Just turn it off for now.  */\n-  if (GET_MODE (operands[0]) != DFmode)\n+  if (mode != DFmode)\n     return 0;\n \n   /* Only 2 real operands to the addition.  One of the input operands must\n@@ -2620,18 +2589,19 @@ int\n fmpysuboperands(operands)\n      rtx *operands;\n {\n+  enum machine_mode mode = GET_MODE (operands[0]);\n \n   /* All modes must be the same.  */\n-  if (! (GET_MODE (operands[0]) == GET_MODE (operands[1])\n-\t && GET_MODE (operands[0]) == GET_MODE (operands[2])\n-\t && GET_MODE (operands[0]) == GET_MODE (operands[3])\n-\t && GET_MODE (operands[0]) == GET_MODE (operands[4])\n-\t && GET_MODE (operands[0]) == GET_MODE (operands[5])))\n+  if (! (mode == GET_MODE (operands[1])\n+\t && mode == GET_MODE (operands[2])\n+\t && mode == GET_MODE (operands[3])\n+\t && mode == GET_MODE (operands[4])\n+\t && mode == GET_MODE (operands[5])))\n     return 0;\n \n   /* Both DFmode and SFmode should work.  But using SFmode makes the\n      assembler complain.  Just turn it off for now.  */\n-  if (GET_MODE (operands[0]) != DFmode)\n+  if (mode != DFmode)\n     return 0;\n \n   /* Only 2 real operands to the subtraction.  Subtraction is not a commutative"}]}