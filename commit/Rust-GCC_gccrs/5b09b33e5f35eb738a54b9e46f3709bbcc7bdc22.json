{"sha": "5b09b33e5f35eb738a54b9e46f3709bbcc7bdc22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIwOWIzM2U1ZjM1ZWI3MzhhNTRiOWU0NmYzNzA5YmJjYzdiZGMyMg==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-12-14T19:22:28Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-12-14T19:22:28Z"}, "message": "parse.y (fold_constant_for_init): New function.\n\nd\n\t* parse.y (fold_constant_for_init):  New function.\n\t(resolve_expression_name):  Don't replace static final\n \tconstant-initialized fields by its value.\n\t(java_complete_lhs):  New.  Same as java_complete_tree, except does\n\tnot replace static final constant-initialized fields by their values.\n\t(register_fields):  If there is an initializer, set DECL_INITIAL and\n\tMODIFY_EXPR_FROM_INITIALIZATION_P.\n\t(java_complete_tree):  For MODIFY_EXPR, use java_complete_lhs for lhs.\n\tOnly call patch_initialized_static_field if\n\tMODIFY_EXPR_FROM_INITIALIZATION_P.\n\t(patch_initialized_static_field):  If not valid constant, clear\n\tDECL_INITIAL.\n\t* parse.y (lookup_field_wrapper):  Fix thinko.\n\t* parse.y (java_complete_tree):  In EXPR_WITH_FILE_LOCATION,\n\tset and restore global lineno.\n\nFrom-SVN: r24316", "tree": {"sha": "c6057856f6d3fde57370b11c3d7273fb2361955d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6057856f6d3fde57370b11c3d7273fb2361955d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b09b33e5f35eb738a54b9e46f3709bbcc7bdc22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b09b33e5f35eb738a54b9e46f3709bbcc7bdc22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b09b33e5f35eb738a54b9e46f3709bbcc7bdc22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b09b33e5f35eb738a54b9e46f3709bbcc7bdc22/comments", "author": null, "committer": null, "parents": [{"sha": "c1c7db89c03daaed2fdfb1713b4857b56143f75f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1c7db89c03daaed2fdfb1713b4857b56143f75f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1c7db89c03daaed2fdfb1713b4857b56143f75f"}], "stats": {"total": 1240, "additions": 787, "deletions": 453}, "files": [{"sha": "1d0cca7d0283979d4d54214d36d1fe068bae0f71", "filename": "gcc/java/parse.c", "status": "modified", "additions": 604, "deletions": 437, "changes": 1041, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b09b33e5f35eb738a54b9e46f3709bbcc7bdc22/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b09b33e5f35eb738a54b9e46f3709bbcc7bdc22/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=5b09b33e5f35eb738a54b9e46f3709bbcc7bdc22", "patch": "@@ -204,6 +204,7 @@ static tree patch_invoke PROTO ((tree, tree, tree));\n static tree lookup_method_invoke PROTO ((int, tree, tree, tree, tree));\n static tree register_incomplete_type PROTO ((int, tree, tree, tree));\n static tree obtain_incomplete_type PROTO ((tree));\n+static tree java_complete_lhs PROTO ((tree));\n static tree java_complete_tree PROTO ((tree));\n static void java_complete_expand_method PROTO ((tree));\n static int  unresolved_type_p PROTO ((tree, tree *));\n@@ -315,6 +316,7 @@ static tree maybe_build_array_element_wfl PROTO ((tree));\n static int array_constructor_check_entry PROTO ((tree, tree));\n static char *purify_type_name PROTO ((char *));\n static tree patch_initialized_static_field PROTO ((tree));\n+static tree fold_constant_for_init PROTO ((tree, tree));\n \n /* Number of error found so far. */\n int java_error_count; \n@@ -360,7 +362,7 @@ static tree wfl_append = NULL_TREE;\n /* The \"toString\" identifier used for String `+' operator. */\n static tree wfl_to_string = NULL_TREE;\n \n-#line 288 \"./parse.y\"\n+#line 290 \"./parse.y\"\n typedef union {\n   tree node;\n   int sub_token;\n@@ -664,56 +666,56 @@ static const short yyrhs[] = {   123,\n \n #if YYDEBUG != 0\n static const short yyrline[] = { 0,\n-   438,   444,   446,   447,   448,   449,   450,   454,   456,   459,\n-   461,   462,   465,   467,   470,   474,   478,   482,   488,   490,\n-   492,   494,   499,   501,   504,   508,   513,   518,   520,   521,\n-   522,   523,   524,   525,   526,   529,   534,   540,   542,   545,\n-   548,   550,   554,   556,   559,   586,   588,   592,   601,   603,\n-   607,   614,   615,   617,   627,   632,   647,   651,   654,   657,\n-   660,   662,   664,   666,   670,   672,   674,   676,   680,   682,\n-   684,   691,   697,   702,   706,   709,   713,   715,   718,   720,\n-   721,   722,   726,   728,   729,   731,   736,   739,   749,   752,\n-   754,   758,   761,   768,   774,   782,   784,   786,   788,   790,\n-   794,   796,   800,   807,   808,   812,   815,   817,   819,   821,\n-   823,   825,   827,   829,   836,   839,   841,   850,   852,   856,\n-   861,   866,   870,   875,   877,   879,   886,   888,   890,   894,\n-   897,   899,   903,   905,   906,   911,   916,   922,   930,   937,\n-   940,   943,   947,   950,   954,   963,   965,   967,   972,   979,\n-   987,   989,   993,  1001,  1012,  1016,  1019,  1022,  1025,  1028,\n-  1031,  1034,  1037,  1039,  1043,  1049,  1054,  1056,  1060,  1063,\n-  1067,  1069,  1072,  1074,  1075,  1077,  1081,  1085,  1091,  1096,\n-  1099,  1101,  1105,  1111,  1115,  1120,  1123,  1127,  1132,  1140,\n-  1142,  1145,  1147,  1149,  1153,  1157,  1160,  1164,  1166,  1167,\n-  1168,  1169,  1170,  1180,  1182,  1183,  1184,  1185,  1188,  1190,\n-  1191,  1192,  1193,  1194,  1195,  1196,  1197,  1198,  1199,  1202,\n-  1207,  1218,  1225,  1229,  1240,  1250,  1256,  1262,  1268,  1270,\n-  1276,  1278,  1284,  1286,  1288,  1290,  1292,  1296,  1298,  1299,\n-  1300,  1301,  1302,  1303,  1306,  1309,  1311,  1313,  1317,  1322,\n-  1327,  1333,  1343,  1349,  1351,  1353,  1360,  1363,  1365,  1367,\n-  1371,  1373,  1376,  1380,  1382,  1385,  1392,  1398,  1400,  1402,\n-  1406,  1414,  1417,  1419,  1421,  1425,  1430,  1439,  1444,  1447,\n-  1454,  1456,  1458,  1462,  1465,  1474,  1481,  1483,  1487,  1500,\n-  1502,  1508,  1514,  1518,  1520,  1524,  1527,  1529,  1533,  1536,\n-  1538,  1540,  1544,  1547,  1549,  1551,  1555,  1558,  1560,  1562,\n-  1566,  1572,  1574,  1578,  1585,  1587,  1589,  1591,  1595,  1603,\n-  1606,  1608,  1610,  1614,  1616,  1623,  1631,  1648,  1650,  1652,\n-  1656,  1662,  1667,  1669,  1672,  1674,  1676,  1678,  1679,  1680,\n-  1681,  1685,  1687,  1689,  1694,  1696,  1698,  1700,  1702,  1706,\n-  1709,  1714,  1716,  1721,  1722,  1723,  1724,  1725,  1727,  1729,\n-  1731,  1733,  1735,  1739,  1741,  1744,  1750,  1755,  1759,  1762,\n-  1764,  1766,  1770,  1772,  1774,  1776,  1780,  1783,  1787,  1793,\n-  1795,  1803,  1806,  1808,  1812,  1817,  1825,  1829,  1832,  1834,\n-  1845,  1856,  1861,  1870,  1872,  1876,  1879,  1881,  1886,  1891,\n-  1896,  1903,  1905,  1906,  1907,  1910,  1915,  1920,  1922,  1923,\n-  1925,  1927,  1928,  1930,  1934,  1937,  1941,  1944,  1948,  1950,\n-  1952,  1954,  1955,  1957,  1961,  1969,  1971,  1973,  1985,  1987,\n-  1993,  1995,  1997,  2001,  2003,  2008,  2013,  2018,  2020,  2022,\n-  2026,  2028,  2033,  2038,  2040,  2044,  2046,  2051,  2056,  2061,\n-  2063,  2065,  2069,  2071,  2076,  2081,  2086,  2091,  2093,  2095,\n-  2097,  2099,  2101,  2105,  2107,  2112,  2117,  2119,  2123,  2125,\n-  2130,  2134,  2136,  2141,  2145,  2147,  2152,  2156,  2158,  2163,\n-  2167,  2169,  2174,  2178,  2180,  2185,  2191,  2193,  2197,  2199,\n-  2202,  2205,  2213,  2215,  2216,  2219,  2221,  2224,  2228\n+   440,   446,   448,   449,   450,   451,   452,   456,   458,   461,\n+   463,   464,   467,   469,   472,   476,   480,   484,   490,   492,\n+   494,   496,   501,   503,   506,   510,   515,   520,   522,   523,\n+   524,   525,   526,   527,   528,   531,   536,   542,   544,   547,\n+   550,   552,   556,   558,   561,   588,   590,   594,   603,   605,\n+   609,   616,   617,   619,   629,   634,   649,   653,   656,   659,\n+   662,   664,   666,   668,   672,   674,   676,   678,   682,   684,\n+   686,   693,   699,   704,   708,   711,   715,   717,   720,   722,\n+   723,   724,   728,   730,   731,   733,   738,   741,   751,   754,\n+   756,   760,   763,   770,   776,   784,   786,   788,   790,   792,\n+   796,   798,   802,   809,   810,   814,   817,   819,   821,   823,\n+   825,   827,   829,   831,   838,   841,   843,   852,   854,   858,\n+   863,   868,   872,   877,   879,   881,   888,   890,   892,   896,\n+   899,   901,   905,   907,   908,   913,   918,   924,   932,   939,\n+   942,   945,   949,   952,   956,   965,   967,   969,   974,   981,\n+   989,   991,   995,  1003,  1014,  1018,  1021,  1024,  1027,  1030,\n+  1033,  1036,  1039,  1041,  1045,  1051,  1056,  1058,  1062,  1065,\n+  1069,  1071,  1074,  1076,  1077,  1079,  1083,  1087,  1093,  1098,\n+  1101,  1103,  1107,  1113,  1117,  1122,  1125,  1129,  1134,  1142,\n+  1144,  1147,  1149,  1151,  1155,  1159,  1162,  1166,  1168,  1169,\n+  1170,  1171,  1172,  1182,  1184,  1185,  1186,  1187,  1190,  1192,\n+  1193,  1194,  1195,  1196,  1197,  1198,  1199,  1200,  1201,  1204,\n+  1209,  1220,  1227,  1231,  1242,  1252,  1258,  1264,  1270,  1272,\n+  1278,  1280,  1286,  1288,  1290,  1292,  1294,  1298,  1300,  1301,\n+  1302,  1303,  1304,  1305,  1308,  1311,  1313,  1315,  1319,  1324,\n+  1329,  1335,  1345,  1351,  1353,  1355,  1362,  1365,  1367,  1369,\n+  1373,  1375,  1378,  1382,  1384,  1387,  1394,  1400,  1402,  1404,\n+  1408,  1416,  1419,  1421,  1423,  1427,  1432,  1441,  1446,  1449,\n+  1456,  1458,  1460,  1464,  1467,  1476,  1483,  1485,  1489,  1502,\n+  1504,  1510,  1516,  1520,  1522,  1526,  1529,  1531,  1535,  1538,\n+  1540,  1542,  1546,  1549,  1551,  1553,  1557,  1560,  1562,  1564,\n+  1568,  1574,  1576,  1580,  1587,  1589,  1591,  1593,  1597,  1605,\n+  1608,  1610,  1612,  1616,  1618,  1625,  1633,  1650,  1652,  1654,\n+  1658,  1664,  1669,  1671,  1674,  1676,  1678,  1680,  1681,  1682,\n+  1683,  1687,  1689,  1691,  1696,  1698,  1700,  1702,  1704,  1708,\n+  1711,  1716,  1718,  1723,  1724,  1725,  1726,  1727,  1729,  1731,\n+  1733,  1735,  1737,  1741,  1743,  1746,  1752,  1757,  1761,  1764,\n+  1766,  1768,  1772,  1774,  1776,  1778,  1782,  1785,  1789,  1795,\n+  1797,  1805,  1808,  1810,  1814,  1819,  1827,  1831,  1834,  1836,\n+  1847,  1858,  1863,  1872,  1874,  1878,  1881,  1883,  1888,  1893,\n+  1898,  1905,  1907,  1908,  1909,  1912,  1917,  1922,  1924,  1925,\n+  1927,  1929,  1930,  1932,  1936,  1939,  1943,  1946,  1950,  1952,\n+  1954,  1956,  1957,  1959,  1963,  1971,  1973,  1975,  1987,  1989,\n+  1995,  1997,  1999,  2003,  2005,  2010,  2015,  2020,  2022,  2024,\n+  2028,  2030,  2035,  2040,  2042,  2046,  2048,  2053,  2058,  2063,\n+  2065,  2067,  2071,  2073,  2078,  2083,  2088,  2093,  2095,  2097,\n+  2099,  2101,  2103,  2107,  2109,  2114,  2119,  2121,  2125,  2127,\n+  2132,  2136,  2138,  2143,  2147,  2149,  2154,  2158,  2160,  2165,\n+  2169,  2171,  2176,  2180,  2182,  2187,  2193,  2195,  2199,  2201,\n+  2204,  2207,  2215,  2217,  2218,  2221,  2223,  2226,  2230\n };\n #endif\n \n@@ -2747,66 +2749,66 @@ yyparse(YYPARSE_PARAM_ARG)\n   switch (yyn) {\n \n case 1:\n-#line 440 \"./parse.y\"\n+#line 442 \"./parse.y\"\n {;\n     break;}\n case 18:\n-#line 484 \"./parse.y\"\n+#line 486 \"./parse.y\"\n { \n \t\t  yyval.node = build_java_array_type (yyvsp[-2].node, -1);\n \t\t  CLASS_LOADED_P (yyval.node) = 1;\n \t\t;\n     break;}\n case 19:\n-#line 489 \"./parse.y\"\n+#line 491 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 20:\n-#line 491 \"./parse.y\"\n+#line 493 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 21:\n-#line 493 \"./parse.y\"\n+#line 495 \"./parse.y\"\n {RULE (\"']' expected\"); RECOVER;;\n     break;}\n case 22:\n-#line 495 \"./parse.y\"\n+#line 497 \"./parse.y\"\n {RULE (\"']' expected\"); RECOVER;;\n     break;}\n case 26:\n-#line 510 \"./parse.y\"\n+#line 512 \"./parse.y\"\n { yyval.node = make_qualified_name (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;\n     break;}\n case 28:\n-#line 519 \"./parse.y\"\n+#line 521 \"./parse.y\"\n {yyval.node = NULL;;\n     break;}\n case 36:\n-#line 531 \"./parse.y\"\n+#line 533 \"./parse.y\"\n {\n \t\t  yyval.node = NULL;\n \t\t;\n     break;}\n case 37:\n-#line 535 \"./parse.y\"\n+#line 537 \"./parse.y\"\n {\n \t\t  yyval.node = NULL;\n \t\t;\n     break;}\n case 40:\n-#line 547 \"./parse.y\"\n+#line 549 \"./parse.y\"\n { ctxp->package = EXPR_WFL_NODE (yyvsp[-1].node); ;\n     break;}\n case 41:\n-#line 549 \"./parse.y\"\n+#line 551 \"./parse.y\"\n {yyerror (\"Missing name\"); RECOVER;;\n     break;}\n case 42:\n-#line 551 \"./parse.y\"\n+#line 553 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 45:\n-#line 561 \"./parse.y\"\n+#line 563 \"./parse.y\"\n {\n \t\t  tree name = EXPR_WFL_NODE (yyvsp[-1].node), node, last_name;\n \t\t  int   i = IDENTIFIER_LENGTH (name)-1;\n@@ -2834,15 +2836,15 @@ case 45:\n \t\t;\n     break;}\n case 46:\n-#line 587 \"./parse.y\"\n+#line 589 \"./parse.y\"\n {yyerror (\"Missing name\"); RECOVER;;\n     break;}\n case 47:\n-#line 589 \"./parse.y\"\n+#line 591 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 48:\n-#line 594 \"./parse.y\"\n+#line 596 \"./parse.y\"\n {\n \t\t  tree name = EXPR_WFL_NODE (yyvsp[-3].node);\n \t\t  tree node = build_tree_list (yyvsp[-3].node, NULL_TREE);\n@@ -2852,40 +2854,40 @@ case 48:\n \t\t;\n     break;}\n case 49:\n-#line 602 \"./parse.y\"\n+#line 604 \"./parse.y\"\n {yyerror (\"'*' expected\"); RECOVER;;\n     break;}\n case 50:\n-#line 604 \"./parse.y\"\n+#line 606 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 51:\n-#line 609 \"./parse.y\"\n+#line 611 \"./parse.y\"\n {\n \t\t  maybe_generate_finit ();\n \t\t  maybe_generate_clinit ();\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 53:\n-#line 616 \"./parse.y\"\n+#line 618 \"./parse.y\"\n { yyval.node = NULL; ;\n     break;}\n case 54:\n-#line 618 \"./parse.y\"\n+#line 620 \"./parse.y\"\n {\n \t\t  YYERROR_NOW;\n \t\t  yyerror (\"Class or interface declaration expected\");\n \t\t;\n     break;}\n case 55:\n-#line 629 \"./parse.y\"\n+#line 631 \"./parse.y\"\n {\n \t\t  yyval.value = (1 << yyvsp[0].value);\n \t\t;\n     break;}\n case 56:\n-#line 633 \"./parse.y\"\n+#line 635 \"./parse.y\"\n {\n \t\t  int acc = (1 << yyvsp[0].value);\n \t\t  if (yyval.value & acc)\n@@ -2899,116 +2901,116 @@ case 56:\n \t\t;\n     break;}\n case 57:\n-#line 649 \"./parse.y\"\n+#line 651 \"./parse.y\"\n { create_class (yyvsp[-4].value, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 58:\n-#line 651 \"./parse.y\"\n+#line 653 \"./parse.y\"\n { \n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 59:\n-#line 655 \"./parse.y\"\n+#line 657 \"./parse.y\"\n { create_class (0, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 60:\n-#line 657 \"./parse.y\"\n+#line 659 \"./parse.y\"\n { \t\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 61:\n-#line 661 \"./parse.y\"\n+#line 663 \"./parse.y\"\n {yyerror (\"Missing class name\"); RECOVER;;\n     break;}\n case 62:\n-#line 663 \"./parse.y\"\n+#line 665 \"./parse.y\"\n {yyerror (\"Missing class name\"); RECOVER;;\n     break;}\n case 63:\n-#line 665 \"./parse.y\"\n+#line 667 \"./parse.y\"\n {if (!ctxp->class_err) yyerror (\"'{' expected\"); DRECOVER(class1);;\n     break;}\n case 64:\n-#line 667 \"./parse.y\"\n+#line 669 \"./parse.y\"\n {if (!ctxp->class_err) yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 65:\n-#line 671 \"./parse.y\"\n+#line 673 \"./parse.y\"\n { yyval.node = NULL; ;\n     break;}\n case 66:\n-#line 673 \"./parse.y\"\n+#line 675 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 67:\n-#line 675 \"./parse.y\"\n+#line 677 \"./parse.y\"\n {yyerror (\"'{' expected\"); ctxp->class_err=1;;\n     break;}\n case 68:\n-#line 677 \"./parse.y\"\n+#line 679 \"./parse.y\"\n {yyerror (\"Missing super class name\"); ctxp->class_err=1;;\n     break;}\n case 69:\n-#line 681 \"./parse.y\"\n+#line 683 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 70:\n-#line 683 \"./parse.y\"\n+#line 685 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 71:\n-#line 685 \"./parse.y\"\n+#line 687 \"./parse.y\"\n {\n \t\t  ctxp->class_err=1;\n \t\t  yyerror (\"Missing interface name\"); \n \t\t;\n     break;}\n case 72:\n-#line 693 \"./parse.y\"\n+#line 695 \"./parse.y\"\n { \n \t\t  ctxp->interface_number = 1;\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 73:\n-#line 698 \"./parse.y\"\n+#line 700 \"./parse.y\"\n { \n \t\t  ctxp->interface_number++;\n \t\t  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));\n \t\t;\n     break;}\n case 74:\n-#line 703 \"./parse.y\"\n+#line 705 \"./parse.y\"\n {yyerror (\"Missing interface name\"); RECOVER;;\n     break;}\n case 75:\n-#line 708 \"./parse.y\"\n+#line 710 \"./parse.y\"\n { yyval.node = ctxp->current_parsed_class; ;\n     break;}\n case 76:\n-#line 710 \"./parse.y\"\n+#line 712 \"./parse.y\"\n { yyval.node = ctxp->current_parsed_class; ;\n     break;}\n case 82:\n-#line 723 \"./parse.y\"\n+#line 725 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"instance initializer\"); ;\n     break;}\n case 85:\n-#line 730 \"./parse.y\"\n+#line 732 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner classe declaration\"); ;\n     break;}\n case 86:\n-#line 732 \"./parse.y\"\n+#line 734 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner interface declaration\"); ;\n     break;}\n case 87:\n-#line 738 \"./parse.y\"\n+#line 740 \"./parse.y\"\n { register_fields (0, yyvsp[-2].node, yyvsp[-1].node); ;\n     break;}\n case 88:\n-#line 740 \"./parse.y\"\n+#line 742 \"./parse.y\"\n {\n \t\t  check_modifiers \n \t\t    (\"Illegal modifier `%s' for field declaration\",\n@@ -3018,19 +3020,19 @@ case 88:\n \t\t;\n     break;}\n case 90:\n-#line 753 \"./parse.y\"\n+#line 755 \"./parse.y\"\n { yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 91:\n-#line 755 \"./parse.y\"\n+#line 757 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 92:\n-#line 760 \"./parse.y\"\n+#line 762 \"./parse.y\"\n { yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 93:\n-#line 762 \"./parse.y\"\n+#line 764 \"./parse.y\"\n { \n \t\t  if (java_error_count)\n \t\t    yyvsp[0].node = NULL_TREE;\n@@ -3039,101 +3041,101 @@ case 93:\n \t\t;\n     break;}\n case 94:\n-#line 769 \"./parse.y\"\n+#line 771 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing variable initializer\");\n \t\t  yyval.node = build_tree_list (yyvsp[-2].node, NULL_TREE);\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 95:\n-#line 775 \"./parse.y\"\n+#line 777 \"./parse.y\"\n {\n \t\t  yyerror (\"';' expected\");\n \t\t  yyval.node = build_tree_list (yyvsp[-3].node, NULL_TREE);\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 97:\n-#line 785 \"./parse.y\"\n+#line 787 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 98:\n-#line 787 \"./parse.y\"\n+#line 789 \"./parse.y\"\n {yyerror (\"Invalid declaration\"); DRECOVER(vdi);;\n     break;}\n case 99:\n-#line 789 \"./parse.y\"\n+#line 791 \"./parse.y\"\n {yyerror (\"']' expected\"); DRECOVER(vdi);;\n     break;}\n case 100:\n-#line 791 \"./parse.y\"\n+#line 793 \"./parse.y\"\n {yyerror (\"Unbalanced ']'\"); DRECOVER(vdi);;\n     break;}\n case 103:\n-#line 802 \"./parse.y\"\n+#line 804 \"./parse.y\"\n {\n \t\t  current_function_decl = yyvsp[0].node;\n \t\t  source_start_java_method (current_function_decl);\n \t\t;\n     break;}\n case 104:\n-#line 807 \"./parse.y\"\n+#line 809 \"./parse.y\"\n { complete_method_declaration (yyvsp[0].node); ;\n     break;}\n case 105:\n-#line 809 \"./parse.y\"\n+#line 811 \"./parse.y\"\n {YYNOT_TWICE yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 106:\n-#line 814 \"./parse.y\"\n+#line 816 \"./parse.y\"\n { yyval.node = method_header (0, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 107:\n-#line 816 \"./parse.y\"\n+#line 818 \"./parse.y\"\n { yyval.node = method_header (0, void_type_node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 108:\n-#line 818 \"./parse.y\"\n+#line 820 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-3].value, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 109:\n-#line 820 \"./parse.y\"\n+#line 822 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-3].value, void_type_node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 110:\n-#line 822 \"./parse.y\"\n+#line 824 \"./parse.y\"\n {RECOVER;;\n     break;}\n case 111:\n-#line 824 \"./parse.y\"\n+#line 826 \"./parse.y\"\n {RECOVER;;\n     break;}\n case 112:\n-#line 826 \"./parse.y\"\n+#line 828 \"./parse.y\"\n {yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 113:\n-#line 828 \"./parse.y\"\n+#line 830 \"./parse.y\"\n {yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 114:\n-#line 830 \"./parse.y\"\n+#line 832 \"./parse.y\"\n {\n \t\t  yyerror (\"Invalid method declaration, return type required\");\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 115:\n-#line 838 \"./parse.y\"\n+#line 840 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 116:\n-#line 840 \"./parse.y\"\n+#line 842 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 117:\n-#line 842 \"./parse.y\"\n+#line 844 \"./parse.y\"\n {\n \t\t  EXPR_WFL_LINECOL (wfl_operator) = yyvsp[-1].operator.location;\n \t\t  TREE_PURPOSE (yyvsp[-2].node) = \n@@ -3144,169 +3146,169 @@ case 117:\n \t\t;\n     break;}\n case 118:\n-#line 851 \"./parse.y\"\n+#line 853 \"./parse.y\"\n {yyerror (\"')' expected\"); DRECOVER(method_declarator);;\n     break;}\n case 119:\n-#line 853 \"./parse.y\"\n+#line 855 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 120:\n-#line 858 \"./parse.y\"\n+#line 860 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number = 1;\n \t\t;\n     break;}\n case 121:\n-#line 862 \"./parse.y\"\n+#line 864 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number += 1;\n \t\t  yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node);\n \t\t;\n     break;}\n case 122:\n-#line 867 \"./parse.y\"\n+#line 869 \"./parse.y\"\n {yyerror (\"Missing formal parameter term\"); RECOVER;;\n     break;}\n case 123:\n-#line 872 \"./parse.y\"\n+#line 874 \"./parse.y\"\n {\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, yyvsp[-1].node);\n \t\t;\n     break;}\n case 124:\n-#line 876 \"./parse.y\"\n+#line 878 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"final parameters\"); ;\n     break;}\n case 125:\n-#line 878 \"./parse.y\"\n+#line 880 \"./parse.y\"\n {yyerror (\"Missing identifier\"); RECOVER;;\n     break;}\n case 126:\n-#line 880 \"./parse.y\"\n+#line 882 \"./parse.y\"\n {\n \t\t  SOURCE_FRONTEND_DEBUG ((\"Modifiers: %d\", yyvsp[-2].value));\n \t\t  yyerror (\"Missing identifier\"); RECOVER;\n \t\t;\n     break;}\n case 127:\n-#line 887 \"./parse.y\"\n+#line 889 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 128:\n-#line 889 \"./parse.y\"\n+#line 891 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 129:\n-#line 891 \"./parse.y\"\n+#line 893 \"./parse.y\"\n {yyerror (\"Missing class type term\"); RECOVER;;\n     break;}\n case 130:\n-#line 896 \"./parse.y\"\n+#line 898 \"./parse.y\"\n { yyval.node = build_tree_list (yyvsp[0].node, yyvsp[0].node); ;\n     break;}\n case 131:\n-#line 898 \"./parse.y\"\n+#line 900 \"./parse.y\"\n { yyval.node = tree_cons (yyvsp[0].node, yyvsp[0].node, yyvsp[-2].node); ;\n     break;}\n case 132:\n-#line 900 \"./parse.y\"\n+#line 902 \"./parse.y\"\n {yyerror (\"Missing class type term\"); RECOVER;;\n     break;}\n case 135:\n-#line 907 \"./parse.y\"\n+#line 909 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 136:\n-#line 913 \"./parse.y\"\n+#line 915 \"./parse.y\"\n {\n \t\t  RULE (\"STATIC_INITIALIZER\");\n \t\t;\n     break;}\n case 137:\n-#line 917 \"./parse.y\"\n+#line 919 \"./parse.y\"\n {\n \t\t  RULE (\"STATIC_INITIALIZER\");\n \t\t;\n     break;}\n case 138:\n-#line 924 \"./parse.y\"\n+#line 926 \"./parse.y\"\n {\n \t\t  SOURCE_FRONTEND_DEBUG ((\"Modifiers: %d\", yyvsp[0].value));\n \t\t;\n     break;}\n case 139:\n-#line 932 \"./parse.y\"\n+#line 934 \"./parse.y\"\n {\n \t\t  current_function_decl = yyvsp[0].node;\n \t\t  source_start_java_method (current_function_decl);\n \t\t;\n     break;}\n case 140:\n-#line 937 \"./parse.y\"\n+#line 939 \"./parse.y\"\n { complete_method_declaration (yyvsp[0].node); ;\n     break;}\n case 141:\n-#line 942 \"./parse.y\"\n+#line 944 \"./parse.y\"\n { yyval.node = method_header (0, NULL_TREE, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 142:\n-#line 944 \"./parse.y\"\n+#line 946 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-2].value, NULL_TREE, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 143:\n-#line 949 \"./parse.y\"\n+#line 951 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 144:\n-#line 951 \"./parse.y\"\n+#line 953 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 145:\n-#line 959 \"./parse.y\"\n+#line 961 \"./parse.y\"\n { \n \t\t  BLOCK_EXPR_BODY (yyvsp[0].node) = empty_stmt_node;\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 146:\n-#line 964 \"./parse.y\"\n+#line 966 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 147:\n-#line 966 \"./parse.y\"\n+#line 968 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 148:\n-#line 968 \"./parse.y\"\n+#line 970 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 149:\n-#line 974 \"./parse.y\"\n+#line 976 \"./parse.y\"\n { \n \t\t  yyval.node = build_method_invocation (yyvsp[-3].node, NULL_TREE); \n \t\t  yyval.node = build_debugable_stmt (EXPR_WFL_LINECOL (yyvsp[-3].node), yyval.node);\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyval.node);\n \t\t;\n     break;}\n case 150:\n-#line 980 \"./parse.y\"\n+#line 982 \"./parse.y\"\n { \n \t\t  yyval.node = build_method_invocation (yyvsp[-4].node, yyvsp[-2].node); \n \t\t  yyval.node = build_debugable_stmt (EXPR_WFL_LINECOL (yyvsp[-4].node), yyval.node);\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyval.node);\n \t\t;\n     break;}\n case 151:\n-#line 988 \"./parse.y\"\n+#line 990 \"./parse.y\"\n {yyval.node = parse_jdk1_1_error (\"explicit constructor invocation\"); ;\n     break;}\n case 152:\n-#line 990 \"./parse.y\"\n+#line 992 \"./parse.y\"\n {yyval.node = parse_jdk1_1_error (\"explicit constructor invocation\"); ;\n     break;}\n case 153:\n-#line 995 \"./parse.y\"\n+#line 997 \"./parse.y\"\n {\n \t\t  tree wfl = build_wfl_node (this_identifier_node, \n \t\t\t\t\t     input_filename, 0, 0);\n@@ -3315,7 +3317,7 @@ case 153:\n \t\t;\n     break;}\n case 154:\n-#line 1002 \"./parse.y\"\n+#line 1004 \"./parse.y\"\n {\n \t\t  tree wfl = build_wfl_node (super_identifier_node,\n \t\t\t\t\t     input_filename, 0, 0);\n@@ -3324,168 +3326,168 @@ case 154:\n \t\t;\n     break;}\n case 155:\n-#line 1014 \"./parse.y\"\n+#line 1016 \"./parse.y\"\n { create_interface (0, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 156:\n-#line 1016 \"./parse.y\"\n+#line 1018 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 157:\n-#line 1020 \"./parse.y\"\n+#line 1022 \"./parse.y\"\n { create_interface (yyvsp[-2].value, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 158:\n-#line 1022 \"./parse.y\"\n+#line 1024 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 159:\n-#line 1026 \"./parse.y\"\n+#line 1028 \"./parse.y\"\n { create_interface (0, yyvsp[-1].node, yyvsp[0].node);\t;\n     break;}\n case 160:\n-#line 1028 \"./parse.y\"\n+#line 1030 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 161:\n-#line 1032 \"./parse.y\"\n+#line 1034 \"./parse.y\"\n { create_interface (yyvsp[-3].value, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 162:\n-#line 1034 \"./parse.y\"\n+#line 1036 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 163:\n-#line 1038 \"./parse.y\"\n+#line 1040 \"./parse.y\"\n {yyerror (\"(here)'{' expected\"); RECOVER;;\n     break;}\n case 164:\n-#line 1040 \"./parse.y\"\n+#line 1042 \"./parse.y\"\n {yyerror (\"(there)'{' expected\"); RECOVER;;\n     break;}\n case 165:\n-#line 1045 \"./parse.y\"\n+#line 1047 \"./parse.y\"\n { \n \t\t  ctxp->interface_number = 1;\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 166:\n-#line 1050 \"./parse.y\"\n+#line 1052 \"./parse.y\"\n { \n \t\t  ctxp->interface_number++;\n \t\t  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));\n \t\t;\n     break;}\n case 167:\n-#line 1055 \"./parse.y\"\n+#line 1057 \"./parse.y\"\n {yyerror (\"Invalid interface type\"); RECOVER;;\n     break;}\n case 168:\n-#line 1057 \"./parse.y\"\n+#line 1059 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 169:\n-#line 1062 \"./parse.y\"\n+#line 1064 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 170:\n-#line 1064 \"./parse.y\"\n+#line 1066 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 175:\n-#line 1076 \"./parse.y\"\n+#line 1078 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class declaration\"); ;\n     break;}\n case 176:\n-#line 1078 \"./parse.y\"\n+#line 1080 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner interface declaration\"); ;\n     break;}\n case 178:\n-#line 1087 \"./parse.y\"\n+#line 1089 \"./parse.y\"\n { \n \t\t  check_abstract_method_header (yyvsp[-1].node);\n \t\t  current_function_decl = NULL_TREE; /* FIXME ? */\n \t\t;\n     break;}\n case 179:\n-#line 1092 \"./parse.y\"\n+#line 1094 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 180:\n-#line 1098 \"./parse.y\"\n+#line 1100 \"./parse.y\"\n { yyval.node = build_new_array_init (yyvsp[-1].operator.location, NULL_TREE); ;\n     break;}\n case 181:\n-#line 1100 \"./parse.y\"\n+#line 1102 \"./parse.y\"\n { yyval.node = build_new_array_init (yyvsp[-2].operator.location, yyvsp[-1].node); ;\n     break;}\n case 182:\n-#line 1102 \"./parse.y\"\n+#line 1104 \"./parse.y\"\n { yyval.node = build_new_array_init (yyvsp[-3].operator.location, yyvsp[-2].node); ;\n     break;}\n case 183:\n-#line 1107 \"./parse.y\"\n+#line 1109 \"./parse.y\"\n { \n \t\t  yyval.node = tree_cons (maybe_build_array_element_wfl (yyvsp[0].node), \n \t\t\t\t  yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 184:\n-#line 1112 \"./parse.y\"\n+#line 1114 \"./parse.y\"\n {\n \t\t  yyval.node = tree_cons (maybe_build_array_element_wfl (yyvsp[0].node), yyvsp[0].node, yyvsp[-2].node);\n \t\t;\n     break;}\n case 185:\n-#line 1116 \"./parse.y\"\n+#line 1118 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 186:\n-#line 1122 \"./parse.y\"\n+#line 1124 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 187:\n-#line 1124 \"./parse.y\"\n+#line 1126 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 188:\n-#line 1129 \"./parse.y\"\n+#line 1131 \"./parse.y\"\n { enter_block (); ;\n     break;}\n case 189:\n-#line 1134 \"./parse.y\"\n+#line 1136 \"./parse.y\"\n { \n \t\t  maybe_absorb_scoping_blocks ();\n \t\t  yyval.node = exit_block ();\n \t\t;\n     break;}\n case 193:\n-#line 1148 \"./parse.y\"\n+#line 1150 \"./parse.y\"\n { java_method_add_stmt (current_function_decl, yyvsp[0].node); ;\n     break;}\n case 194:\n-#line 1150 \"./parse.y\"\n+#line 1152 \"./parse.y\"\n { parse_jdk1_1_error (\"inner class declaration\"); ;\n     break;}\n case 196:\n-#line 1159 \"./parse.y\"\n+#line 1161 \"./parse.y\"\n { declare_local_variables (0, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 197:\n-#line 1161 \"./parse.y\"\n+#line 1163 \"./parse.y\"\n { declare_local_variables (yyvsp[-2].value, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 203:\n-#line 1171 \"./parse.y\"\n+#line 1173 \"./parse.y\"\n { \n \t\t  /* If the for loop is unlabeled, we must return the\n \t\t     block it was defined it. It our last chance to\n@@ -3495,11 +3497,11 @@ case 203:\n \t\t;\n     break;}\n case 220:\n-#line 1204 \"./parse.y\"\n+#line 1206 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 221:\n-#line 1209 \"./parse.y\"\n+#line 1211 \"./parse.y\"\n {\n \t\t  yyval.node = build_labeled_block (EXPR_WFL_LINECOL (yyvsp[-1].node), \n \t\t\t\t\t    EXPR_WFL_NODE (yyvsp[-1].node));\n@@ -3509,27 +3511,27 @@ case 221:\n \t\t;\n     break;}\n case 222:\n-#line 1220 \"./parse.y\"\n+#line 1222 \"./parse.y\"\n { \n \t\t  yyval.node = complete_labeled_statement (yyvsp[-1].node, yyvsp[0].node);\n \t\t  pop_labeled_block ();\n \t\t  POP_LABELED_BLOCK ();\n \t\t;\n     break;}\n case 223:\n-#line 1226 \"./parse.y\"\n+#line 1228 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 224:\n-#line 1231 \"./parse.y\"\n+#line 1233 \"./parse.y\"\n { \n \t\t  yyval.node = complete_labeled_statement (yyvsp[-1].node, yyvsp[0].node);\n \t\t  pop_labeled_block ();\n \t\t  POP_LABELED_BLOCK ();\n \t\t;\n     break;}\n case 225:\n-#line 1242 \"./parse.y\"\n+#line 1244 \"./parse.y\"\n {\n \t\t  /* We have a statement. Generate a WFL around it so\n \t\t     we can debug it */\n@@ -3540,105 +3542,105 @@ case 225:\n \t\t;\n     break;}\n case 226:\n-#line 1251 \"./parse.y\"\n+#line 1253 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 227:\n-#line 1257 \"./parse.y\"\n+#line 1259 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 228:\n-#line 1263 \"./parse.y\"\n+#line 1265 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 229:\n-#line 1269 \"./parse.y\"\n+#line 1271 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 230:\n-#line 1271 \"./parse.y\"\n+#line 1273 \"./parse.y\"\n {\n \t\t  yyerror (\"Constructor invocation must be first \"\n \t\t\t   \"thing in a constructor\"); \n \t\t  RECOVER;\n \t\t;\n     break;}\n case 231:\n-#line 1277 \"./parse.y\"\n+#line 1279 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 232:\n-#line 1279 \"./parse.y\"\n+#line 1281 \"./parse.y\"\n {\n \t\t  yyerror (\"Constructor invocation must be first \"\n \t\t\t   \"thing in a constructor\"); \n \t\t  RECOVER;\n \t\t;\n     break;}\n case 233:\n-#line 1285 \"./parse.y\"\n+#line 1287 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 234:\n-#line 1287 \"./parse.y\"\n+#line 1289 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 235:\n-#line 1289 \"./parse.y\"\n+#line 1291 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 236:\n-#line 1291 \"./parse.y\"\n+#line 1293 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 237:\n-#line 1293 \"./parse.y\"\n+#line 1295 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 245:\n-#line 1308 \"./parse.y\"\n+#line 1310 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 246:\n-#line 1310 \"./parse.y\"\n+#line 1312 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 247:\n-#line 1312 \"./parse.y\"\n+#line 1314 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 248:\n-#line 1314 \"./parse.y\"\n+#line 1316 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 249:\n-#line 1319 \"./parse.y\"\n+#line 1321 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 250:\n-#line 1324 \"./parse.y\"\n+#line 1326 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 251:\n-#line 1329 \"./parse.y\"\n+#line 1331 \"./parse.y\"\n {\n \t\t  enter_block ();\n \t\t;\n     break;}\n case 252:\n-#line 1333 \"./parse.y\"\n+#line 1335 \"./parse.y\"\n { \n \t\t  /* Make into \"proper list\" of COMPOUND_EXPRs.\n \t\t     I.e. make the last statment also have its own\n@@ -3649,112 +3651,112 @@ case 252:\n \t\t;\n     break;}\n case 253:\n-#line 1345 \"./parse.y\"\n+#line 1347 \"./parse.y\"\n { \n \t\t  yyval.node = build (SWITCH_EXPR, NULL_TREE, yyvsp[-1].node, NULL_TREE);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;\n \t\t;\n     break;}\n case 254:\n-#line 1350 \"./parse.y\"\n+#line 1352 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 255:\n-#line 1352 \"./parse.y\"\n+#line 1354 \"./parse.y\"\n {yyerror (\"Missing term or ')'\"); DRECOVER(switch_statement);;\n     break;}\n case 256:\n-#line 1354 \"./parse.y\"\n+#line 1356 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 257:\n-#line 1362 \"./parse.y\"\n+#line 1364 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 258:\n-#line 1364 \"./parse.y\"\n+#line 1366 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 259:\n-#line 1366 \"./parse.y\"\n+#line 1368 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 260:\n-#line 1368 \"./parse.y\"\n+#line 1370 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 266:\n-#line 1387 \"./parse.y\"\n+#line 1389 \"./parse.y\"\n { \n \t\t  tree lab = build1 (CASE_EXPR, NULL_TREE, yyvsp[-1].node);\n \t\t  EXPR_WFL_LINECOL (lab) = yyvsp[-2].operator.location;\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t;\n     break;}\n case 267:\n-#line 1393 \"./parse.y\"\n+#line 1395 \"./parse.y\"\n { \n \t\t  tree lab = build1 (DEFAULT_EXPR, NULL_TREE, NULL_TREE);\n \t\t  EXPR_WFL_LINECOL (lab) = yyvsp[-1].operator.location;\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t;\n     break;}\n case 268:\n-#line 1399 \"./parse.y\"\n+#line 1401 \"./parse.y\"\n {yyerror (\"Missing or invalid constant expression\"); RECOVER;;\n     break;}\n case 269:\n-#line 1401 \"./parse.y\"\n+#line 1403 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 270:\n-#line 1403 \"./parse.y\"\n+#line 1405 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 271:\n-#line 1408 \"./parse.y\"\n+#line 1410 \"./parse.y\"\n { \n \t\t  tree body = build_loop_body (yyvsp[-2].operator.location, yyvsp[-1].node, 0);\n \t\t  yyval.node = build_new_loop (body);\n \t\t;\n     break;}\n case 272:\n-#line 1416 \"./parse.y\"\n+#line 1418 \"./parse.y\"\n { yyval.node = complete_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;\n     break;}\n case 273:\n-#line 1418 \"./parse.y\"\n+#line 1420 \"./parse.y\"\n {YYERROR_NOW; yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 274:\n-#line 1420 \"./parse.y\"\n+#line 1422 \"./parse.y\"\n {yyerror (\"Missing term and ')' expected\"); RECOVER;;\n     break;}\n case 275:\n-#line 1422 \"./parse.y\"\n+#line 1424 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 276:\n-#line 1427 \"./parse.y\"\n+#line 1429 \"./parse.y\"\n { yyval.node = complete_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;\n     break;}\n case 277:\n-#line 1432 \"./parse.y\"\n+#line 1434 \"./parse.y\"\n { \n \t\t  tree body = build_loop_body (0, NULL_TREE, 1);\n \t\t  yyval.node = build_new_loop (body);\n \t\t;\n     break;}\n case 278:\n-#line 1441 \"./parse.y\"\n+#line 1443 \"./parse.y\"\n { yyval.node = complete_loop_body (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[-5].node, 1); ;\n     break;}\n case 279:\n-#line 1446 \"./parse.y\"\n+#line 1448 \"./parse.y\"\n { yyval.node = complete_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);;\n     break;}\n case 280:\n-#line 1448 \"./parse.y\"\n+#line 1450 \"./parse.y\"\n { \n \t\t  yyval.node = complete_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n@@ -3763,23 +3765,23 @@ case 280:\n \t\t;\n     break;}\n case 281:\n-#line 1455 \"./parse.y\"\n+#line 1457 \"./parse.y\"\n {yyerror (\"Invalid control expression\"); RECOVER;;\n     break;}\n case 282:\n-#line 1457 \"./parse.y\"\n+#line 1459 \"./parse.y\"\n {yyerror (\"Invalid update expression\"); RECOVER;;\n     break;}\n case 283:\n-#line 1459 \"./parse.y\"\n+#line 1461 \"./parse.y\"\n {yyerror (\"Invalid update expression\"); RECOVER;;\n     break;}\n case 284:\n-#line 1464 \"./parse.y\"\n+#line 1466 \"./parse.y\"\n { yyval.node = complete_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);;\n     break;}\n case 285:\n-#line 1466 \"./parse.y\"\n+#line 1468 \"./parse.y\"\n { \n \t\t  yyval.node = complete_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n@@ -3788,23 +3790,23 @@ case 285:\n \t\t;\n     break;}\n case 286:\n-#line 1476 \"./parse.y\"\n+#line 1478 \"./parse.y\"\n { \n \t\t  /* This scope defined for local variable that may be\n                      defined within the scope of the for loop */\n \t\t  enter_block (); \n \t\t;\n     break;}\n case 287:\n-#line 1482 \"./parse.y\"\n+#line 1484 \"./parse.y\"\n {yyerror (\"'(' expected\"); DRECOVER(for_1);;\n     break;}\n case 288:\n-#line 1484 \"./parse.y\"\n+#line 1486 \"./parse.y\"\n {yyerror (\"Invalid init statement\"); RECOVER;;\n     break;}\n case 289:\n-#line 1489 \"./parse.y\"\n+#line 1491 \"./parse.y\"\n { \n \t\t  /* We now declare the loop body. The loop is\n                      declared as a for loop. */\n@@ -3817,176 +3819,176 @@ case 289:\n \t\t;\n     break;}\n case 290:\n-#line 1501 \"./parse.y\"\n+#line 1503 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 291:\n-#line 1503 \"./parse.y\"\n+#line 1505 \"./parse.y\"\n { \n \t\t  /* Init statement recorded within the previously\n                      defined block scope */\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyvsp[0].node);\n \t\t;\n     break;}\n case 292:\n-#line 1509 \"./parse.y\"\n+#line 1511 \"./parse.y\"\n { \n \t\t  /* Local variable are recorded within the previously\n \t\t     defined block scope */\n \t\t  yyval.node = NULL_TREE;\n \t\t;\n     break;}\n case 293:\n-#line 1515 \"./parse.y\"\n+#line 1517 \"./parse.y\"\n {yyerror (\"';' expected\"); DRECOVER(for_init_1);;\n     break;}\n case 294:\n-#line 1519 \"./parse.y\"\n+#line 1521 \"./parse.y\"\n {yyval.node = empty_stmt_node;;\n     break;}\n case 295:\n-#line 1521 \"./parse.y\"\n+#line 1523 \"./parse.y\"\n { yyval.node = build_debugable_stmt (BUILD_LOCATION (), yyvsp[0].node); ;\n     break;}\n case 296:\n-#line 1526 \"./parse.y\"\n+#line 1528 \"./parse.y\"\n { yyval.node = add_stmt_to_compound (NULL_TREE, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 297:\n-#line 1528 \"./parse.y\"\n+#line 1530 \"./parse.y\"\n { yyval.node = add_stmt_to_compound (yyvsp[-2].node, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 298:\n-#line 1530 \"./parse.y\"\n+#line 1532 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 299:\n-#line 1535 \"./parse.y\"\n+#line 1537 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 1, NULL_TREE); ;\n     break;}\n case 300:\n-#line 1537 \"./parse.y\"\n+#line 1539 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 1, yyvsp[-1].node); ;\n     break;}\n case 301:\n-#line 1539 \"./parse.y\"\n+#line 1541 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 302:\n-#line 1541 \"./parse.y\"\n+#line 1543 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 303:\n-#line 1546 \"./parse.y\"\n+#line 1548 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 0, NULL_TREE); ;\n     break;}\n case 304:\n-#line 1548 \"./parse.y\"\n+#line 1550 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 0, yyvsp[-1].node); ;\n     break;}\n case 305:\n-#line 1550 \"./parse.y\"\n+#line 1552 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 306:\n-#line 1552 \"./parse.y\"\n+#line 1554 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 307:\n-#line 1557 \"./parse.y\"\n+#line 1559 \"./parse.y\"\n { yyval.node = build_return (yyvsp[-1].operator.location, NULL_TREE); ;\n     break;}\n case 308:\n-#line 1559 \"./parse.y\"\n+#line 1561 \"./parse.y\"\n { yyval.node = build_return (yyvsp[-2].operator.location, yyvsp[-1].node); ;\n     break;}\n case 309:\n-#line 1561 \"./parse.y\"\n+#line 1563 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 310:\n-#line 1563 \"./parse.y\"\n+#line 1565 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 311:\n-#line 1568 \"./parse.y\"\n+#line 1570 \"./parse.y\"\n { \n \t\t  yyval.node = build1 (THROW_EXPR, NULL_TREE, yyvsp[-1].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;\n \t\t;\n     break;}\n case 312:\n-#line 1573 \"./parse.y\"\n+#line 1575 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 313:\n-#line 1575 \"./parse.y\"\n+#line 1577 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 314:\n-#line 1580 \"./parse.y\"\n+#line 1582 \"./parse.y\"\n { \n \t\t  yyval.node = build (SYNCHRONIZED_EXPR, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = \n \t\t    EXPR_WFL_LINECOL (MODIFIER_WFL (SYNCHRONIZED_TK));\n \t\t;\n     break;}\n case 315:\n-#line 1586 \"./parse.y\"\n+#line 1588 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 316:\n-#line 1588 \"./parse.y\"\n+#line 1590 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 317:\n-#line 1590 \"./parse.y\"\n+#line 1592 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 318:\n-#line 1592 \"./parse.y\"\n+#line 1594 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 319:\n-#line 1597 \"./parse.y\"\n+#line 1599 \"./parse.y\"\n {\n \t\t  if ((1 << yyvsp[0].value) != ACC_SYNCHRONIZED)\n \t\t    fatal (\"synchronized was '%d' - yyparse\", (1 << yyvsp[0].value));\n \t\t;\n     break;}\n case 320:\n-#line 1605 \"./parse.y\"\n+#line 1607 \"./parse.y\"\n { yyval.node = build_try_statement (yyvsp[-2].operator.location, yyvsp[-1].node, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 321:\n-#line 1607 \"./parse.y\"\n+#line 1609 \"./parse.y\"\n { yyval.node = build_try_statement (yyvsp[-2].operator.location, yyvsp[-1].node, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 322:\n-#line 1609 \"./parse.y\"\n+#line 1611 \"./parse.y\"\n { yyval.node = build_try_statement (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 323:\n-#line 1611 \"./parse.y\"\n+#line 1613 \"./parse.y\"\n {yyerror (\"'{' expected\"); DRECOVER (try_statement);;\n     break;}\n case 325:\n-#line 1617 \"./parse.y\"\n+#line 1619 \"./parse.y\"\n { \n \t\t  TREE_CHAIN (yyvsp[0].node) = yyvsp[-1].node;\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 326:\n-#line 1625 \"./parse.y\"\n+#line 1627 \"./parse.y\"\n { \n \t\t  java_method_add_stmt (current_function_decl, yyvsp[0].node);\n \t\t  exit_block ();\n \t\t  yyval.node = yyvsp[-1].node;\n \t\t;\n     break;}\n case 327:\n-#line 1633 \"./parse.y\"\n+#line 1635 \"./parse.y\"\n { \n \t\t  /* We add a block to define a scope for\n \t\t     formal_parameter (CCBP). The formal parameter is\n@@ -4004,203 +4006,203 @@ case 327:\n \t\t;\n     break;}\n case 328:\n-#line 1649 \"./parse.y\"\n+#line 1651 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 329:\n-#line 1651 \"./parse.y\"\n+#line 1653 \"./parse.y\"\n {yyerror (\"Missing term or ')' expected\"); DRECOVER (2);;\n     break;}\n case 330:\n-#line 1653 \"./parse.y\"\n+#line 1655 \"./parse.y\"\n {yyerror (\"')' expected\"); DRECOVER (1);;\n     break;}\n case 331:\n-#line 1658 \"./parse.y\"\n+#line 1660 \"./parse.y\"\n { \n \t\t  yyval.node = build (FINALLY_EXPR, NULL_TREE,\n \t\t\t      create_label_decl (generate_name ()), yyvsp[0].node);\n \t\t;\n     break;}\n case 332:\n-#line 1663 \"./parse.y\"\n+#line 1665 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER; ;\n     break;}\n case 336:\n-#line 1675 \"./parse.y\"\n+#line 1677 \"./parse.y\"\n { yyval.node = build_this (yyvsp[0].operator.location); ;\n     break;}\n case 337:\n-#line 1677 \"./parse.y\"\n+#line 1679 \"./parse.y\"\n {yyval.node = yyvsp[-1].node;;\n     break;}\n case 342:\n-#line 1686 \"./parse.y\"\n+#line 1688 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"named class literals\"); ;\n     break;}\n case 343:\n-#line 1688 \"./parse.y\"\n+#line 1690 \"./parse.y\"\n { yyval.node = build_class_ref (yyvsp[-2].node); ;\n     break;}\n case 344:\n-#line 1690 \"./parse.y\"\n+#line 1692 \"./parse.y\"\n { yyval.node = build_class_ref (void_type_node); ;\n     break;}\n case 345:\n-#line 1695 \"./parse.y\"\n+#line 1697 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"class literals\"); ;\n     break;}\n case 346:\n-#line 1697 \"./parse.y\"\n+#line 1699 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 347:\n-#line 1699 \"./parse.y\"\n+#line 1701 \"./parse.y\"\n {yyerror (\"'class' or 'this' expected\" ); RECOVER;;\n     break;}\n case 348:\n-#line 1701 \"./parse.y\"\n+#line 1703 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 349:\n-#line 1703 \"./parse.y\"\n+#line 1705 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 350:\n-#line 1708 \"./parse.y\"\n+#line 1710 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 351:\n-#line 1710 \"./parse.y\"\n+#line 1712 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 352:\n-#line 1715 \"./parse.y\"\n+#line 1717 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class instance creation\"); ;\n     break;}\n case 353:\n-#line 1717 \"./parse.y\"\n+#line 1719 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class instance creation\"); ;\n     break;}\n case 358:\n-#line 1726 \"./parse.y\"\n+#line 1728 \"./parse.y\"\n {yyerror (\"'(' expected\"); DRECOVER(new_1);;\n     break;}\n case 359:\n-#line 1728 \"./parse.y\"\n+#line 1730 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 360:\n-#line 1730 \"./parse.y\"\n+#line 1732 \"./parse.y\"\n {yyerror (\"')' or term expected\"); RECOVER;;\n     break;}\n case 361:\n-#line 1732 \"./parse.y\"\n+#line 1734 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 362:\n-#line 1734 \"./parse.y\"\n+#line 1736 \"./parse.y\"\n {YYERROR_NOW; yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 363:\n-#line 1736 \"./parse.y\"\n+#line 1738 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 366:\n-#line 1746 \"./parse.y\"\n+#line 1748 \"./parse.y\"\n { \n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, NULL_TREE);\n \t\t  ctxp->formal_parameter_number = 1; \n \t\t;\n     break;}\n case 367:\n-#line 1751 \"./parse.y\"\n+#line 1753 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number += 1;\n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyvsp[-2].node);\n \t\t;\n     break;}\n case 368:\n-#line 1756 \"./parse.y\"\n+#line 1758 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 369:\n-#line 1761 \"./parse.y\"\n+#line 1763 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 370:\n-#line 1763 \"./parse.y\"\n+#line 1765 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 371:\n-#line 1765 \"./parse.y\"\n+#line 1767 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, ctxp->osb_number); ;\n     break;}\n case 372:\n-#line 1767 \"./parse.y\"\n+#line 1769 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, ctxp->osb_number); ;\n     break;}\n case 373:\n-#line 1771 \"./parse.y\"\n+#line 1773 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"anonymous array\"); ;\n     break;}\n case 374:\n-#line 1773 \"./parse.y\"\n+#line 1775 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"anonymous array\"); ;\n     break;}\n case 375:\n-#line 1775 \"./parse.y\"\n+#line 1777 \"./parse.y\"\n {yyerror (\"'[' expected\"); DRECOVER (\"]\");;\n     break;}\n case 376:\n-#line 1777 \"./parse.y\"\n+#line 1779 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 377:\n-#line 1782 \"./parse.y\"\n+#line 1784 \"./parse.y\"\n { yyval.node = build_tree_list (NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 378:\n-#line 1784 \"./parse.y\"\n+#line 1786 \"./parse.y\"\n { yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyval.node); ;\n     break;}\n case 379:\n-#line 1789 \"./parse.y\"\n+#line 1791 \"./parse.y\"\n { \n \t\t  EXPR_WFL_LINECOL (yyvsp[-1].node) = yyvsp[-2].operator.location;\n \t\t  yyval.node = yyvsp[-1].node;\n \t\t;\n     break;}\n case 380:\n-#line 1794 \"./parse.y\"\n+#line 1796 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 381:\n-#line 1796 \"./parse.y\"\n+#line 1798 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term\");\n \t\t  yyerror (\"']' expected\");\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 382:\n-#line 1805 \"./parse.y\"\n+#line 1807 \"./parse.y\"\n { ctxp->osb_number = 1; ;\n     break;}\n case 383:\n-#line 1807 \"./parse.y\"\n+#line 1809 \"./parse.y\"\n { ctxp->osb_number++; ;\n     break;}\n case 384:\n-#line 1809 \"./parse.y\"\n+#line 1811 \"./parse.y\"\n { yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 385:\n-#line 1814 \"./parse.y\"\n+#line 1816 \"./parse.y\"\n { yyval.node = make_qualified_primary (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;\n     break;}\n case 386:\n-#line 1818 \"./parse.y\"\n+#line 1820 \"./parse.y\"\n {\n \t\t  tree super_wfl = \n \t\t    build_wfl_node (super_identifier_node, \n@@ -4210,19 +4212,19 @@ case 386:\n \t\t;\n     break;}\n case 387:\n-#line 1826 \"./parse.y\"\n+#line 1828 \"./parse.y\"\n {yyerror (\"Field expected\"); DRECOVER (super_field_acces);;\n     break;}\n case 388:\n-#line 1831 \"./parse.y\"\n+#line 1833 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 389:\n-#line 1833 \"./parse.y\"\n+#line 1835 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 390:\n-#line 1835 \"./parse.y\"\n+#line 1837 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-4].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4235,7 +4237,7 @@ case 390:\n \t\t;\n     break;}\n case 391:\n-#line 1846 \"./parse.y\"\n+#line 1848 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-5].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4248,121 +4250,121 @@ case 391:\n \t\t;\n     break;}\n case 392:\n-#line 1857 \"./parse.y\"\n+#line 1859 \"./parse.y\"\n { \n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-2].node, NULL_TREE, yyvsp[-4].operator.location, yyvsp[-3].operator.location);\n \t\t;\n     break;}\n case 393:\n-#line 1862 \"./parse.y\"\n+#line 1864 \"./parse.y\"\n {\n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-3].node, yyvsp[-1].node, yyvsp[-5].operator.location, yyvsp[-4].operator.location);\n \t\t;\n     break;}\n case 394:\n-#line 1871 \"./parse.y\"\n+#line 1873 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 395:\n-#line 1873 \"./parse.y\"\n+#line 1875 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 396:\n-#line 1878 \"./parse.y\"\n+#line 1880 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 397:\n-#line 1880 \"./parse.y\"\n+#line 1882 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 398:\n-#line 1882 \"./parse.y\"\n+#line 1884 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 399:\n-#line 1887 \"./parse.y\"\n+#line 1889 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 400:\n-#line 1892 \"./parse.y\"\n+#line 1894 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 401:\n-#line 1897 \"./parse.y\"\n+#line 1899 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 406:\n-#line 1912 \"./parse.y\"\n+#line 1914 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 407:\n-#line 1917 \"./parse.y\"\n+#line 1919 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 410:\n-#line 1924 \"./parse.y\"\n+#line 1926 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 411:\n-#line 1926 \"./parse.y\"\n+#line 1928 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 413:\n-#line 1929 \"./parse.y\"\n+#line 1931 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 414:\n-#line 1931 \"./parse.y\"\n+#line 1933 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 415:\n-#line 1936 \"./parse.y\"\n+#line 1938 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 416:\n-#line 1938 \"./parse.y\"\n+#line 1940 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 417:\n-#line 1943 \"./parse.y\"\n+#line 1945 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 418:\n-#line 1945 \"./parse.y\"\n+#line 1947 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 420:\n-#line 1951 \"./parse.y\"\n+#line 1953 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 421:\n-#line 1953 \"./parse.y\"\n+#line 1955 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 423:\n-#line 1956 \"./parse.y\"\n+#line 1958 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 424:\n-#line 1958 \"./parse.y\"\n+#line 1960 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 425:\n-#line 1963 \"./parse.y\"\n+#line 1965 \"./parse.y\"\n { \n \t\t  tree type = yyvsp[-3].node;\n \t\t  while (ctxp->osb_number--)\n@@ -4371,15 +4373,15 @@ case 425:\n \t\t;\n     break;}\n case 426:\n-#line 1970 \"./parse.y\"\n+#line 1972 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 427:\n-#line 1972 \"./parse.y\"\n+#line 1974 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 428:\n-#line 1974 \"./parse.y\"\n+#line 1976 \"./parse.y\"\n { \n \t\t  char *ptr;\n \t\t  while (ctxp->osb_number--)\n@@ -4393,275 +4395,275 @@ case 428:\n \t\t;\n     break;}\n case 429:\n-#line 1986 \"./parse.y\"\n+#line 1988 \"./parse.y\"\n {yyerror (\"']' expected, invalid type expression\");;\n     break;}\n case 430:\n-#line 1988 \"./parse.y\"\n+#line 1990 \"./parse.y\"\n {\n \t          if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid type expression\"); RECOVER;\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 431:\n-#line 1994 \"./parse.y\"\n+#line 1996 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 432:\n-#line 1996 \"./parse.y\"\n+#line 1998 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 433:\n-#line 1998 \"./parse.y\"\n+#line 2000 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 435:\n-#line 2004 \"./parse.y\"\n+#line 2006 \"./parse.y\"\n { \n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), \n \t\t\t\t    yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node);\n \t\t;\n     break;}\n case 436:\n-#line 2009 \"./parse.y\"\n+#line 2011 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 437:\n-#line 2014 \"./parse.y\"\n+#line 2016 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 438:\n-#line 2019 \"./parse.y\"\n+#line 2021 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 439:\n-#line 2021 \"./parse.y\"\n+#line 2023 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 440:\n-#line 2023 \"./parse.y\"\n+#line 2025 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 442:\n-#line 2029 \"./parse.y\"\n+#line 2031 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 443:\n-#line 2034 \"./parse.y\"\n+#line 2036 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 444:\n-#line 2039 \"./parse.y\"\n+#line 2041 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 445:\n-#line 2041 \"./parse.y\"\n+#line 2043 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 447:\n-#line 2047 \"./parse.y\"\n+#line 2049 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 448:\n-#line 2052 \"./parse.y\"\n+#line 2054 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 449:\n-#line 2057 \"./parse.y\"\n+#line 2059 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 450:\n-#line 2062 \"./parse.y\"\n+#line 2064 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 451:\n-#line 2064 \"./parse.y\"\n+#line 2066 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 452:\n-#line 2066 \"./parse.y\"\n+#line 2068 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 454:\n-#line 2072 \"./parse.y\"\n+#line 2074 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 455:\n-#line 2077 \"./parse.y\"\n+#line 2079 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 456:\n-#line 2082 \"./parse.y\"\n+#line 2084 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 457:\n-#line 2087 \"./parse.y\"\n+#line 2089 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 458:\n-#line 2092 \"./parse.y\"\n+#line 2094 \"./parse.y\"\n { yyval.node = build_binop (INSTANCEOF_EXPR, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 459:\n-#line 2094 \"./parse.y\"\n+#line 2096 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 460:\n-#line 2096 \"./parse.y\"\n+#line 2098 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 461:\n-#line 2098 \"./parse.y\"\n+#line 2100 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 462:\n-#line 2100 \"./parse.y\"\n+#line 2102 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 463:\n-#line 2102 \"./parse.y\"\n+#line 2104 \"./parse.y\"\n {yyerror (\"Invalid reference type\"); RECOVER;;\n     break;}\n case 465:\n-#line 2108 \"./parse.y\"\n+#line 2110 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 466:\n-#line 2113 \"./parse.y\"\n+#line 2115 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 467:\n-#line 2118 \"./parse.y\"\n+#line 2120 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 468:\n-#line 2120 \"./parse.y\"\n+#line 2122 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 470:\n-#line 2126 \"./parse.y\"\n+#line 2128 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 471:\n-#line 2131 \"./parse.y\"\n+#line 2133 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 473:\n-#line 2137 \"./parse.y\"\n+#line 2139 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 474:\n-#line 2142 \"./parse.y\"\n+#line 2144 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 476:\n-#line 2148 \"./parse.y\"\n+#line 2150 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 477:\n-#line 2153 \"./parse.y\"\n+#line 2155 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 479:\n-#line 2159 \"./parse.y\"\n+#line 2161 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 480:\n-#line 2164 \"./parse.y\"\n+#line 2166 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 482:\n-#line 2170 \"./parse.y\"\n+#line 2172 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 483:\n-#line 2175 \"./parse.y\"\n+#line 2177 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 485:\n-#line 2181 \"./parse.y\"\n+#line 2183 \"./parse.y\"\n {\n \t\t  yyval.node = build (CONDITIONAL_EXPR, NULL_TREE, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-3].operator.location;\n \t\t;\n     break;}\n case 486:\n-#line 2186 \"./parse.y\"\n+#line 2188 \"./parse.y\"\n {\n \t\t  YYERROR_NOW;\n \t\t  yyerror (\"Missing term\");\n \t\t  DRECOVER (1);\n \t\t;\n     break;}\n case 487:\n-#line 2192 \"./parse.y\"\n+#line 2194 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (2);;\n     break;}\n case 488:\n-#line 2194 \"./parse.y\"\n+#line 2196 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (3);;\n     break;}\n case 491:\n-#line 2204 \"./parse.y\"\n+#line 2206 \"./parse.y\"\n { yyval.node = build_assignment (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 492:\n-#line 2206 \"./parse.y\"\n+#line 2208 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Missing term\");\n@@ -4866,7 +4868,7 @@ case 492:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 2232 \"./parse.y\"\n+#line 2234 \"./parse.y\"\n \n \f\n \n@@ -5640,9 +5642,11 @@ lookup_field_wrapper (class, name)\n      tree class, name;\n {\n   tree type = class;\n+  tree decl;\n   java_parser_context_save_global ();\n-  return lookup_field (&type, name);\n+  decl = lookup_field (&type, name);\n   java_parser_context_restore_global ();\n+  return decl;\n }\n \n /* Find duplicate field within the same class declarations and report\n@@ -5777,6 +5781,7 @@ register_fields (flags, type, variable_list)\n \t\t appropriately. */\n \t      TREE_CHAIN (init) = ctxp->static_initialized;\n \t      ctxp->static_initialized = init;\n+\t      DECL_INITIAL (field_decl) = TREE_OPERAND (init, 1);\n \t    }\n \t  /* A non-static field declared with an immediate initialization is\n \t     to be initialized in <init>, if any.  This field is remembered\n@@ -5787,6 +5792,7 @@ register_fields (flags, type, variable_list)\n \t      ctxp->non_static_initialized = init;\n \t    }\n \t  INITIALIZED_P (field_decl) = 1;\n+\t  MODIFY_EXPR_FROM_INITIALIZATION_P (init) = 1;\n \t}\n     }\n   lineno = saved_lineno;\n@@ -8581,7 +8587,6 @@ resolve_expression_name (id, orig)\n \t  decl = lookup_field_wrapper (current_class, name);\n \t  if (decl)\n \t    {\n-\t      tree value = NULL_TREE;\n \t      int fs = FIELD_STATIC (decl);\n \t      /* Instance variable (8.3.1.1) can't appear within\n \t\t static method, static initializer or initializer for\n@@ -8605,9 +8610,6 @@ resolve_expression_name (id, orig)\n \t\t     \"constructor has been called\", IDENTIFIER_POINTER (name));\n \t\t  return error_mark_node;\n \t\t}\n-\t      /* The field is final. We may use its value instead */\n-\t      if (fs && FIELD_FINAL (decl) && DECL_INITIAL (decl))\n-\t\tvalue = DECL_INITIAL (decl);\n \n \t      /* Otherwise build what it takes to access the field */\n \t      decl = build_field_ref ((fs ? NULL_TREE : current_this),\n@@ -8618,7 +8620,7 @@ resolve_expression_name (id, orig)\n \t      if (orig)\n \t\t*orig = decl;\n \t      /* And we return what we got */\n-\t      return (value ? value : decl);\n+\t      return decl;\n \t    }\n \t  /* Fall down to error report on undefined variable */\n \t}\n@@ -9994,11 +9996,34 @@ breakdown_qualified (left, right, source)\n }\n \n /* Patch tree nodes in a function body. When a BLOCK is found, push\n-   local variable decls if present.  */\n+   local variable decls if present.\n+   Same as java_complete_lhs, but does resolve static finals to values. */\n \n static tree\n java_complete_tree (node)\n      tree node;\n+{\n+  node = java_complete_lhs (node);\n+  if (TREE_CODE (node) == VAR_DECL && FIELD_STATIC (node)\n+      && FIELD_FINAL (node) && DECL_INITIAL (node) != NULL_TREE)\n+    {\n+      tree value = DECL_INITIAL (node);\n+      DECL_INITIAL (node) = NULL_TREE;\n+      value = fold_constant_for_init (value, node);\n+      DECL_INITIAL (node) = value;\n+      if (value != NULL_TREE)\n+\treturn value;\n+    }\n+  return node;\n+}\n+\n+/* Patch tree nodes in a function body. When a BLOCK is found, push\n+   local variable decls if present.\n+   Same as java_complete_tree, but does not resolve static finals to values. */\n+\n+static tree\n+java_complete_lhs (node)\n+     tree node;\n {\n   tree nn, cn, wfl_op1, wfl_op2, wfl_op3;\n   int flag;\n@@ -10272,7 +10297,11 @@ java_complete_tree (node)\n \t}\n       else\n \t{\n-\t  tree body = java_complete_tree (EXPR_WFL_NODE (node));\n+\t  tree body;\n+\t  int save_lineno = lineno;\n+\t  lineno = EXPR_WFL_LINENO (node);\n+\t  body = java_complete_tree (EXPR_WFL_NODE (node));\n+\t  lineno = save_lineno;\n \t  EXPR_WFL_NODE (node) = body;\n \t  TREE_SIDE_EFFECTS (node) = 1;\n \t  CAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (body);\n@@ -10345,7 +10374,7 @@ java_complete_tree (node)\n       /* Save potential wfls */\n       wfl_op1 = TREE_OPERAND (node, 0);\n       wfl_op2 = TREE_OPERAND (node, 1);\n-      TREE_OPERAND (node, 0) = java_complete_tree (wfl_op1);\n+      TREE_OPERAND (node, 0) = java_complete_lhs (wfl_op1);\n       if (TREE_OPERAND (node, 0) == error_mark_node)\n \treturn error_mark_node;\n \n@@ -10403,6 +10432,7 @@ java_complete_tree (node)\n          optimizations. (VAR_DECL means it's a static field. See\n          add_field. */\n       if (DECL_NAME (current_function_decl) == clinit_identifier_node\n+\t  && MODIFY_EXPR_FROM_INITIALIZATION_P (node)\n \t  && TREE_CODE (TREE_OPERAND (node, 0)) == VAR_DECL)\n \tnode = patch_initialized_static_field (node);\n \n@@ -10997,14 +11027,19 @@ patch_initialized_static_field (node)\n   tree field = TREE_OPERAND (node, 0);\n   tree value = TREE_OPERAND (node, 1);\n \n-  if (FIELD_FINAL (field) && TREE_CONSTANT (value)\n-      && JPRIMITIVE_TYPE_P (TREE_TYPE (value)))\n+  if (DECL_INITIAL (field) != NULL_TREE)\n     {\n-      if (DECL_LANG_SPECIFIC (field) == NULL)\n-\tDECL_LANG_SPECIFIC (field) = (struct lang_decl *)\n-\t  permalloc (sizeof (struct lang_decl_var));\n-      DECL_INITIAL (field) = value;\n-      return empty_stmt_node;\n+      tree type = TREE_TYPE (value);\n+      if (FIELD_FINAL (field) && TREE_CONSTANT (value)\n+\t  && (JPRIMITIVE_TYPE_P (type)\n+\t      || (flag_emit_class_files\n+\t\t  && TREE_CODE (type) == POINTER_TYPE\n+\t\t  && TREE_TYPE (type) == string_type_node)))\n+\t{\n+\t  DECL_INITIAL (field) = value;\n+\t  return empty_stmt_node;\n+\t}\n+      DECL_INITIAL (field) = NULL_TREE;\n     }\n   return node;\n }\n@@ -13668,3 +13703,135 @@ patch_conditional_expr (node, wfl_cond, wfl_op1)\n   return node;\n }\n \n+/* Try to constant fold NODE.\n+   If NODE is not a constant expression, return NULL_EXPR.\n+   CONTEXT is a static final VAR_DECL whose initializer we are folding. */\n+\n+static tree\n+fold_constant_for_init (node, context)\n+     tree node;\n+     tree context;\n+{\n+  tree op0, op1, val;\n+  enum tree_code code = TREE_CODE (node);\n+\n+  if (code == INTEGER_CST || code == REAL_CST || code == STRING_CST)\n+    return node;\n+  if (TREE_TYPE (node) != NULL_TREE)\n+    return NULL_TREE;\n+\n+  switch (code)\n+    {\n+    case MULT_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case URSHIFT_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_IOR_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case RDIV_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case EQ_EXPR: \n+    case NE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+      op0 = TREE_OPERAND (node, 0);\n+      op1 = TREE_OPERAND (node, 1);\n+      val = fold_constant_for_init (op0, context);\n+      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n+\treturn NULL_TREE;\n+      TREE_OPERAND (node, 0) = val;\n+      val = fold_constant_for_init (op1, context);\n+      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n+\treturn NULL_TREE;\n+      TREE_OPERAND (node, 1) = val;\n+      return patch_binop (node, op0, op1);\n+\n+    case UNARY_PLUS_EXPR:\n+    case NEGATE_EXPR:\n+    case TRUTH_NOT_EXPR:\n+    case BIT_NOT_EXPR:\n+    case CONVERT_EXPR:\n+      op0 = TREE_OPERAND (node, 0);\n+      val = fold_constant_for_init (op0, context);\n+      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n+\treturn NULL_TREE;\n+      TREE_OPERAND (node, 0) = val;\n+      node = patch_unaryop (node, op0);\n+      break;\n+\n+    case COND_EXPR:\n+      val = fold_constant_for_init (TREE_OPERAND (node, 0), context);\n+      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n+\treturn NULL_TREE;\n+      TREE_OPERAND (node, 0) = val;\n+      val = fold_constant_for_init (TREE_OPERAND (node, 1), context);\n+      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n+\treturn NULL_TREE;\n+      TREE_OPERAND (node, 1) = val;\n+      val = fold_constant_for_init (TREE_OPERAND (node, 2), context);\n+      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n+\treturn NULL_TREE;\n+      TREE_OPERAND (node, 2) = val;\n+      return integer_zerop (TREE_OPERAND (node, 0)) ? TREE_OPERAND (node, 1)\n+\t: TREE_OPERAND (node, 2);\n+\n+    case VAR_DECL:\n+      if (! FIELD_STATIC (node) || ! FIELD_FINAL (node)\n+\t  || DECL_INITIAL (node) == NULL_TREE)\n+\treturn NULL_TREE;\n+      val = DECL_INITIAL (node);\n+      /* Guard against infinite recursion. */\n+      DECL_INITIAL (node) = NULL_TREE;\n+      val = fold_constant_for_init (val, DECL_CONTEXT (node));\n+      DECL_INITIAL (node) = val;\n+      return val;\n+\n+    case EXPR_WITH_FILE_LOCATION:\n+      /* Compare java_complete_tree and resolve_expression_name. */\n+      if (!EXPR_WFL_NODE (node) /* Or a PRIMARY flag ? */\n+\t  || TREE_CODE (EXPR_WFL_NODE (node)) == IDENTIFIER_NODE)\n+\t{\n+\t  tree name = EXPR_WFL_NODE (node);\n+\t  tree decl;\n+\t  if (PRIMARY_P (node))\n+\t    return NULL_TREE;\n+\t  else if (! QUALIFIED_P (name))\n+\t    {\n+\t      decl = lookup_field_wrapper (DECL_CONTEXT (context), name);\n+\t      if (! FIELD_STATIC (decl))\n+\t\treturn NULL_TREE;\n+\t      return fold_constant_for_init (decl, decl);\n+\t    }\n+\t  else\n+\t    {\n+#if 0\n+\t      /* Wait until the USE_COMPONENT_REF re-write.  FIXME. */\n+\t      qualify_ambiguous_name (node);\n+\t      if (resolve_field_access (node, &decl, NULL)\n+\t\t  && decl != NULL_TREE)\n+\t\treturn fold_constant_for_init (decl, decl);\n+#endif\n+\t      return NULL_TREE;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  op0 = TREE_OPERAND (node, 0);\n+\t  val = fold_constant_for_init (op0, context);\n+\t  if (val == NULL_TREE || ! TREE_CONSTANT (val))\n+\t    return NULL_TREE;\n+\t  TREE_OPERAND (node, 0) = val;\n+\t  return val;\n+\t}\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+}"}, {"sha": "3f26eb094170320ea3afe2ca0a42e609245579ff", "filename": "gcc/java/parse.y", "status": "modified", "additions": 183, "deletions": 16, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b09b33e5f35eb738a54b9e46f3709bbcc7bdc22/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b09b33e5f35eb738a54b9e46f3709bbcc7bdc22/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=5b09b33e5f35eb738a54b9e46f3709bbcc7bdc22", "patch": "@@ -128,6 +128,7 @@ static tree patch_invoke PROTO ((tree, tree, tree));\n static tree lookup_method_invoke PROTO ((int, tree, tree, tree, tree));\n static tree register_incomplete_type PROTO ((int, tree, tree, tree));\n static tree obtain_incomplete_type PROTO ((tree));\n+static tree java_complete_lhs PROTO ((tree));\n static tree java_complete_tree PROTO ((tree));\n static void java_complete_expand_method PROTO ((tree));\n static int  unresolved_type_p PROTO ((tree, tree *));\n@@ -239,6 +240,7 @@ static tree maybe_build_array_element_wfl PROTO ((tree));\n static int array_constructor_check_entry PROTO ((tree, tree));\n static char *purify_type_name PROTO ((char *));\n static tree patch_initialized_static_field PROTO ((tree));\n+static tree fold_constant_for_init PROTO ((tree, tree));\n \n /* Number of error found so far. */\n int java_error_count; \n@@ -3002,9 +3004,11 @@ lookup_field_wrapper (class, name)\n      tree class, name;\n {\n   tree type = class;\n+  tree decl;\n   java_parser_context_save_global ();\n-  return lookup_field (&type, name);\n+  decl = lookup_field (&type, name);\n   java_parser_context_restore_global ();\n+  return decl;\n }\n \n /* Find duplicate field within the same class declarations and report\n@@ -3139,6 +3143,7 @@ register_fields (flags, type, variable_list)\n \t\t appropriately. */\n \t      TREE_CHAIN (init) = ctxp->static_initialized;\n \t      ctxp->static_initialized = init;\n+\t      DECL_INITIAL (field_decl) = TREE_OPERAND (init, 1);\n \t    }\n \t  /* A non-static field declared with an immediate initialization is\n \t     to be initialized in <init>, if any.  This field is remembered\n@@ -3149,6 +3154,7 @@ register_fields (flags, type, variable_list)\n \t      ctxp->non_static_initialized = init;\n \t    }\n \t  INITIALIZED_P (field_decl) = 1;\n+\t  MODIFY_EXPR_FROM_INITIALIZATION_P (init) = 1;\n \t}\n     }\n   lineno = saved_lineno;\n@@ -5943,7 +5949,6 @@ resolve_expression_name (id, orig)\n \t  decl = lookup_field_wrapper (current_class, name);\n \t  if (decl)\n \t    {\n-\t      tree value = NULL_TREE;\n \t      int fs = FIELD_STATIC (decl);\n \t      /* Instance variable (8.3.1.1) can't appear within\n \t\t static method, static initializer or initializer for\n@@ -5967,9 +5972,6 @@ resolve_expression_name (id, orig)\n \t\t     \"constructor has been called\", IDENTIFIER_POINTER (name));\n \t\t  return error_mark_node;\n \t\t}\n-\t      /* The field is final. We may use its value instead */\n-\t      if (fs && FIELD_FINAL (decl) && DECL_INITIAL (decl))\n-\t\tvalue = DECL_INITIAL (decl);\n \n \t      /* Otherwise build what it takes to access the field */\n \t      decl = build_field_ref ((fs ? NULL_TREE : current_this),\n@@ -5980,7 +5982,7 @@ resolve_expression_name (id, orig)\n \t      if (orig)\n \t\t*orig = decl;\n \t      /* And we return what we got */\n-\t      return (value ? value : decl);\n+\t      return decl;\n \t    }\n \t  /* Fall down to error report on undefined variable */\n \t}\n@@ -7356,11 +7358,34 @@ breakdown_qualified (left, right, source)\n }\n \n /* Patch tree nodes in a function body. When a BLOCK is found, push\n-   local variable decls if present.  */\n+   local variable decls if present.\n+   Same as java_complete_lhs, but does resolve static finals to values. */\n \n static tree\n java_complete_tree (node)\n      tree node;\n+{\n+  node = java_complete_lhs (node);\n+  if (TREE_CODE (node) == VAR_DECL && FIELD_STATIC (node)\n+      && FIELD_FINAL (node) && DECL_INITIAL (node) != NULL_TREE)\n+    {\n+      tree value = DECL_INITIAL (node);\n+      DECL_INITIAL (node) = NULL_TREE;\n+      value = fold_constant_for_init (value, node);\n+      DECL_INITIAL (node) = value;\n+      if (value != NULL_TREE)\n+\treturn value;\n+    }\n+  return node;\n+}\n+\n+/* Patch tree nodes in a function body. When a BLOCK is found, push\n+   local variable decls if present.\n+   Same as java_complete_tree, but does not resolve static finals to values. */\n+\n+static tree\n+java_complete_lhs (node)\n+     tree node;\n {\n   tree nn, cn, wfl_op1, wfl_op2, wfl_op3;\n   int flag;\n@@ -7634,7 +7659,11 @@ java_complete_tree (node)\n \t}\n       else\n \t{\n-\t  tree body = java_complete_tree (EXPR_WFL_NODE (node));\n+\t  tree body;\n+\t  int save_lineno = lineno;\n+\t  lineno = EXPR_WFL_LINENO (node);\n+\t  body = java_complete_tree (EXPR_WFL_NODE (node));\n+\t  lineno = save_lineno;\n \t  EXPR_WFL_NODE (node) = body;\n \t  TREE_SIDE_EFFECTS (node) = 1;\n \t  CAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (body);\n@@ -7707,7 +7736,7 @@ java_complete_tree (node)\n       /* Save potential wfls */\n       wfl_op1 = TREE_OPERAND (node, 0);\n       wfl_op2 = TREE_OPERAND (node, 1);\n-      TREE_OPERAND (node, 0) = java_complete_tree (wfl_op1);\n+      TREE_OPERAND (node, 0) = java_complete_lhs (wfl_op1);\n       if (TREE_OPERAND (node, 0) == error_mark_node)\n \treturn error_mark_node;\n \n@@ -7765,6 +7794,7 @@ java_complete_tree (node)\n          optimizations. (VAR_DECL means it's a static field. See\n          add_field. */\n       if (DECL_NAME (current_function_decl) == clinit_identifier_node\n+\t  && MODIFY_EXPR_FROM_INITIALIZATION_P (node)\n \t  && TREE_CODE (TREE_OPERAND (node, 0)) == VAR_DECL)\n \tnode = patch_initialized_static_field (node);\n \n@@ -8359,14 +8389,19 @@ patch_initialized_static_field (node)\n   tree field = TREE_OPERAND (node, 0);\n   tree value = TREE_OPERAND (node, 1);\n \n-  if (FIELD_FINAL (field) && TREE_CONSTANT (value)\n-      && JPRIMITIVE_TYPE_P (TREE_TYPE (value)))\n+  if (DECL_INITIAL (field) != NULL_TREE)\n     {\n-      if (DECL_LANG_SPECIFIC (field) == NULL)\n-\tDECL_LANG_SPECIFIC (field) = (struct lang_decl *)\n-\t  permalloc (sizeof (struct lang_decl_var));\n-      DECL_INITIAL (field) = value;\n-      return empty_stmt_node;\n+      tree type = TREE_TYPE (value);\n+      if (FIELD_FINAL (field) && TREE_CONSTANT (value)\n+\t  && (JPRIMITIVE_TYPE_P (type)\n+\t      || (flag_emit_class_files\n+\t\t  && TREE_CODE (type) == POINTER_TYPE\n+\t\t  && TREE_TYPE (type) == string_type_node)))\n+\t{\n+\t  DECL_INITIAL (field) = value;\n+\t  return empty_stmt_node;\n+\t}\n+      DECL_INITIAL (field) = NULL_TREE;\n     }\n   return node;\n }\n@@ -11030,3 +11065,135 @@ patch_conditional_expr (node, wfl_cond, wfl_op1)\n   return node;\n }\n \n+/* Try to constant fold NODE.\n+   If NODE is not a constant expression, return NULL_EXPR.\n+   CONTEXT is a static final VAR_DECL whose initializer we are folding. */\n+\n+static tree\n+fold_constant_for_init (node, context)\n+     tree node;\n+     tree context;\n+{\n+  tree op0, op1, val;\n+  enum tree_code code = TREE_CODE (node);\n+\n+  if (code == INTEGER_CST || code == REAL_CST || code == STRING_CST)\n+    return node;\n+  if (TREE_TYPE (node) != NULL_TREE)\n+    return NULL_TREE;\n+\n+  switch (code)\n+    {\n+    case MULT_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case URSHIFT_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_IOR_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case RDIV_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case EQ_EXPR: \n+    case NE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+      op0 = TREE_OPERAND (node, 0);\n+      op1 = TREE_OPERAND (node, 1);\n+      val = fold_constant_for_init (op0, context);\n+      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n+\treturn NULL_TREE;\n+      TREE_OPERAND (node, 0) = val;\n+      val = fold_constant_for_init (op1, context);\n+      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n+\treturn NULL_TREE;\n+      TREE_OPERAND (node, 1) = val;\n+      return patch_binop (node, op0, op1);\n+\n+    case UNARY_PLUS_EXPR:\n+    case NEGATE_EXPR:\n+    case TRUTH_NOT_EXPR:\n+    case BIT_NOT_EXPR:\n+    case CONVERT_EXPR:\n+      op0 = TREE_OPERAND (node, 0);\n+      val = fold_constant_for_init (op0, context);\n+      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n+\treturn NULL_TREE;\n+      TREE_OPERAND (node, 0) = val;\n+      node = patch_unaryop (node, op0);\n+      break;\n+\n+    case COND_EXPR:\n+      val = fold_constant_for_init (TREE_OPERAND (node, 0), context);\n+      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n+\treturn NULL_TREE;\n+      TREE_OPERAND (node, 0) = val;\n+      val = fold_constant_for_init (TREE_OPERAND (node, 1), context);\n+      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n+\treturn NULL_TREE;\n+      TREE_OPERAND (node, 1) = val;\n+      val = fold_constant_for_init (TREE_OPERAND (node, 2), context);\n+      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n+\treturn NULL_TREE;\n+      TREE_OPERAND (node, 2) = val;\n+      return integer_zerop (TREE_OPERAND (node, 0)) ? TREE_OPERAND (node, 1)\n+\t: TREE_OPERAND (node, 2);\n+\n+    case VAR_DECL:\n+      if (! FIELD_STATIC (node) || ! FIELD_FINAL (node)\n+\t  || DECL_INITIAL (node) == NULL_TREE)\n+\treturn NULL_TREE;\n+      val = DECL_INITIAL (node);\n+      /* Guard against infinite recursion. */\n+      DECL_INITIAL (node) = NULL_TREE;\n+      val = fold_constant_for_init (val, DECL_CONTEXT (node));\n+      DECL_INITIAL (node) = val;\n+      return val;\n+\n+    case EXPR_WITH_FILE_LOCATION:\n+      /* Compare java_complete_tree and resolve_expression_name. */\n+      if (!EXPR_WFL_NODE (node) /* Or a PRIMARY flag ? */\n+\t  || TREE_CODE (EXPR_WFL_NODE (node)) == IDENTIFIER_NODE)\n+\t{\n+\t  tree name = EXPR_WFL_NODE (node);\n+\t  tree decl;\n+\t  if (PRIMARY_P (node))\n+\t    return NULL_TREE;\n+\t  else if (! QUALIFIED_P (name))\n+\t    {\n+\t      decl = lookup_field_wrapper (DECL_CONTEXT (context), name);\n+\t      if (! FIELD_STATIC (decl))\n+\t\treturn NULL_TREE;\n+\t      return fold_constant_for_init (decl, decl);\n+\t    }\n+\t  else\n+\t    {\n+#if 0\n+\t      /* Wait until the USE_COMPONENT_REF re-write.  FIXME. */\n+\t      qualify_ambiguous_name (node);\n+\t      if (resolve_field_access (node, &decl, NULL)\n+\t\t  && decl != NULL_TREE)\n+\t\treturn fold_constant_for_init (decl, decl);\n+#endif\n+\t      return NULL_TREE;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  op0 = TREE_OPERAND (node, 0);\n+\t  val = fold_constant_for_init (op0, context);\n+\t  if (val == NULL_TREE || ! TREE_CONSTANT (val))\n+\t    return NULL_TREE;\n+\t  TREE_OPERAND (node, 0) = val;\n+\t  return val;\n+\t}\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+}"}]}