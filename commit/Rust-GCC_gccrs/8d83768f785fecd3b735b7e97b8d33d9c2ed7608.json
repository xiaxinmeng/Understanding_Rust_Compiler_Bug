{"sha": "8d83768f785fecd3b735b7e97b8d33d9c2ed7608", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ4Mzc2OGY3ODVmZWNkM2I3MzViN2U5N2I4ZDMzZDljMmVkNzYwOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-09-27T12:00:08Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-27T12:00:08Z"}, "message": "class.c (struct count_depth_data): Remove.\n\n\t* class.c (struct count_depth_data): Remove.\n\t(dfs_depth_post, dfs_depth_q): Remove.\n\t(find_final_overrider): Use number of vbase classes as depth\n\tbound.\n\n\t* cp-tree.h (types_overlap_p): Remove.\n\t* search.c (struct overlap_info): Remove.\n\t(dfs_check_overlap, dfs_no_overlap_yet, types_overlap_p): Remove.\n\n\t* pt.c (GTB_VIA_VIRTUAL, GTB_IGNORE_TYPE): Remove.\n\t(get_template_base_recursive): Remove. Replace with ...\n\t(get_template_base_r): ... this.\n\t(struct get_template_base_data_s): New.\n\t(get_template_base): Use get_template_base_r via dfs_walk.  Always\n\treturn NULL on failure.\n\t(unify): Remove error_mark_node check from get_template_base result.\n\nFrom-SVN: r88169", "tree": {"sha": "ecfec79fb69f49e8c3f8e058a7f40be3f9c62a96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecfec79fb69f49e8c3f8e058a7f40be3f9c62a96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d83768f785fecd3b735b7e97b8d33d9c2ed7608", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d83768f785fecd3b735b7e97b8d33d9c2ed7608", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d83768f785fecd3b735b7e97b8d33d9c2ed7608", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d83768f785fecd3b735b7e97b8d33d9c2ed7608/comments", "author": null, "committer": null, "parents": [{"sha": "75e50bd288af0eaa7342f8cb5e506985fd4067f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75e50bd288af0eaa7342f8cb5e506985fd4067f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75e50bd288af0eaa7342f8cb5e506985fd4067f8"}], "stats": {"total": 245, "additions": 72, "deletions": 173}, "files": [{"sha": "16533f75683a511c19cd60aadba51a05bfe903cd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d83768f785fecd3b735b7e97b8d33d9c2ed7608/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d83768f785fecd3b735b7e97b8d33d9c2ed7608/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8d83768f785fecd3b735b7e97b8d33d9c2ed7608", "patch": "@@ -1,3 +1,22 @@\n+2004-09-27  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* class.c (struct count_depth_data): Remove.\n+\t(dfs_depth_post, dfs_depth_q): Remove.\n+\t(find_final_overrider): Use number of vbase classes as depth\n+\tbound.\n+\t\n+\t* cp-tree.h (types_overlap_p): Remove.\n+\t* search.c (struct overlap_info): Remove.\n+\t(dfs_check_overlap, dfs_no_overlap_yet, types_overlap_p): Remove.\n+\t\n+\t* pt.c (GTB_VIA_VIRTUAL, GTB_IGNORE_TYPE): Remove.\n+\t(get_template_base_recursive): Remove. Replace with ...\n+\t(get_template_base_r): ... this.\n+\t(struct get_template_base_data_s): New.\n+\t(get_template_base): Use get_template_base_r via dfs_walk.  Always\n+\treturn NULL on failure.\n+\t(unify): Remove error_mark_node check from get_template_base result.\n+\n 2004-09-24  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* parser.c (cp_parser_expression_stack): Clarify why it is"}, {"sha": "f32f9ccfba9e8ec5357a322ab0951c3ab5cb5061", "filename": "gcc/cp/class.c", "status": "modified", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d83768f785fecd3b735b7e97b8d33d9c2ed7608/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d83768f785fecd3b735b7e97b8d33d9c2ed7608/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8d83768f785fecd3b735b7e97b8d33d9c2ed7608", "patch": "@@ -1801,36 +1801,6 @@ base_derived_from (tree derived, tree base)\n   return false;\n }\n \n-typedef struct count_depth_data {\n-  /* The depth of the current subobject, with \"1\" as the depth of the\n-     most derived object in the hierarchy.  */\n-  size_t depth;\n-  /* The maximum depth found so far.  */\n-  size_t max_depth;\n-} count_depth_data;\n-\n-/* Called from find_final_overrider via dfs_walk.  */\n-\n-static tree\n-dfs_depth_post (tree binfo ATTRIBUTE_UNUSED, void *data)\n-{\n-  count_depth_data *cd = (count_depth_data *) data;\n-  if (cd->depth > cd->max_depth)\n-    cd->max_depth = cd->depth;\n-  cd->depth--;\n-  return NULL_TREE;\n-}\n-\n-/* Called from find_final_overrider via dfs_walk.  */\n-\n-static tree\n-dfs_depth_q (tree derived, int i, void *data)\n-{\n-  count_depth_data *cd = (count_depth_data *) data;\n-  cd->depth++;\n-  return BINFO_BASE_BINFO (derived, i);\n-}\n-\n typedef struct find_final_overrider_data_s {\n   /* The function for which we are trying to find a final overrider.  */\n   tree fn;\n@@ -1943,7 +1913,6 @@ static tree\n find_final_overrider (tree derived, tree binfo, tree fn)\n {\n   find_final_overrider_data ffod;\n-  count_depth_data cd;\n \n   /* Getting this right is a little tricky.  This is valid:\n \n@@ -1967,15 +1936,15 @@ find_final_overrider (tree derived, tree binfo, tree fn)\n     fn = THUNK_TARGET (fn);\n \n   /* Determine the depth of the hierarchy.  */\n-  cd.depth = 0;\n-  cd.max_depth = 0;\n-  dfs_walk (derived, dfs_depth_post, dfs_depth_q, &cd);\n-\n   ffod.fn = fn;\n   ffod.declaring_base = binfo;\n   ffod.most_derived_type = BINFO_TYPE (derived);\n   ffod.candidates = NULL_TREE;\n-  ffod.vpath_list = (tree *) xcalloc (cd.max_depth, sizeof (tree));\n+  /* The virtual depth cannot be greater than the number of virtual\n+     bases.  */\n+  ffod.vpath_list = (tree *) xcalloc\n+    (VEC_length (tree, CLASSTYPE_VBASECLASSES (BINFO_TYPE (derived))),\n+     sizeof (tree));\n   ffod.vpath = ffod.vpath_list;\n \n   dfs_walk_real (derived,"}, {"sha": "4976894703ae061e53b369921c8f9ea2107a9d9b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d83768f785fecd3b735b7e97b8d33d9c2ed7608/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d83768f785fecd3b735b7e97b8d33d9c2ed7608/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8d83768f785fecd3b735b7e97b8d33d9c2ed7608", "patch": "@@ -3981,7 +3981,6 @@ extern bool emit_tinfo_decl (tree);\n /* in search.c */\n extern bool accessible_base_p (tree, tree);\n extern tree lookup_base (tree, tree, base_access, base_kind *);\n-extern int types_overlap_p\t\t\t(tree, tree);\n extern tree get_dynamic_cast_base_type          (tree, tree);\n extern int accessible_p                         (tree, tree);\n extern tree lookup_field_1                      (tree, tree, bool);"}, {"sha": "3125c83baff7644bf8e6292f742c50f545eaeb56", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 48, "deletions": 75, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d83768f785fecd3b735b7e97b8d33d9c2ed7608/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d83768f785fecd3b735b7e97b8d33d9c2ed7608/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8d83768f785fecd3b735b7e97b8d33d9c2ed7608", "patch": "@@ -87,12 +87,6 @@ static htab_t local_specializations;\n #define UNIFY_ALLOW_OUTER_LESS_CV_QUAL 64\n #define UNIFY_ALLOW_MAX_CORRECTION 128\n \n-#define GTB_VIA_VIRTUAL 1 /* The base class we are examining is\n-\t\t\t     virtual, or a base class of a virtual\n-\t\t\t     base.  */\n-#define GTB_IGNORE_TYPE 2 /* We don't need to try to unify the current\n-\t\t\t     type with the desired type.  */\n-\n static void push_access_scope (tree);\n static void pop_access_scope (tree);\n static int resolve_overloaded_unification (tree, tree, tree, tree,\n@@ -154,7 +148,7 @@ static tree process_partial_specialization (tree);\n static void set_current_access_from_decl (tree);\n static void check_default_tmpl_args (tree, tree, int, int);\n static tree tsubst_call_declarator_parms (tree, tree, tsubst_flags_t, tree);\n-static tree get_template_base_recursive (tree, tree, tree, tree, tree, int); \n+static tree get_template_base_r (tree, void *);\n static tree get_template_base (tree, tree, tree, tree);\n static int verify_class_unification (tree, tree, tree);\n static tree try_class_unification (tree, tree, tree, tree);\n@@ -9475,71 +9469,53 @@ try_class_unification (tree tparms, tree targs, tree parm, tree arg)\n   return arg;\n }\n \n-/* Subroutine of get_template_base.  RVAL, if non-NULL, is a base we\n-   have already discovered to be satisfactory.  ARG_BINFO is the binfo\n-   for the base class of ARG that we are currently examining.  */\n+typedef struct get_template_base_data_s \n+{\n+  /* Parameters for unification.  */\n+  tree tparms;\n+  tree targs;\n+  tree parm;\n+  /* Base we've found to be satisfactory.  */\n+  tree rval;\n+} get_template_base_data;\n+\n+/* Called from get_template_base via dfs_walk.  */\n \n static tree\n-get_template_base_recursive (tree tparms, \n-                             tree targs, \n-                             tree parm,\n-                             tree arg_binfo, \n-                             tree rval, \n-                             int flags)\n-{\n-  tree base_binfo;\n-  int i;\n-  tree arg = BINFO_TYPE (arg_binfo);\n+get_template_base_r (tree arg_binfo,\n+\t\t     void *data_)\n+{\n+  get_template_base_data *data = data_;\n \n-  if (!(flags & GTB_IGNORE_TYPE))\n+  /* Do not look at the most derived binfo -- that's not a proper\n+     base.  */\n+  if (BINFO_INHERITANCE_CHAIN (arg_binfo))\n     {\n-      tree r = try_class_unification (tparms, targs,\n-\t\t\t\t      parm, arg);\n-\n-      /* If there is more than one satisfactory baseclass, then:\n-\n-\t   [temp.deduct.call]\n-\n-\t   If they yield more than one possible deduced A, the type\n-\t   deduction fails.\n+      tree r = try_class_unification (data->tparms, data->targs,\n+\t\t\t\t      data->parm, BINFO_TYPE (arg_binfo));\n \n-\t   applies.  */\n-      if (r && rval && !same_type_p (r, rval))\n-\treturn error_mark_node;\n-      else if (r)\n-\trval = r;\n-    }\n+      if (r)\n+\t{\n+\t  /* If there is more than one satisfactory baseclass, then:\n \n-  /* Process base types.  */\n-  for (i = 0; BINFO_BASE_ITERATE (arg_binfo, i, base_binfo); i++)\n-    {\n-      int this_virtual;\n+\t       [temp.deduct.call]\n \n-      /* Skip this base, if we've already seen it.  */\n-      if (BINFO_MARKED (base_binfo))\n-\tcontinue;\n+\t      If they yield more than one possible deduced A, the type\n+\t      deduction fails.\n \n-      this_virtual = \n-\t(flags & GTB_VIA_VIRTUAL) || BINFO_VIRTUAL_P (base_binfo);\n-      \n-      /* When searching for a non-virtual, we cannot mark virtually\n-\t found binfos.  */\n-      if (! this_virtual)\n-\tBINFO_MARKED (base_binfo) = 1;\n-      \n-      rval = get_template_base_recursive (tparms, targs,\n-\t\t\t\t\t  parm,\n-\t\t\t\t\t  base_binfo, \n-\t\t\t\t\t  rval,\n-\t\t\t\t\t  GTB_VIA_VIRTUAL * this_virtual);\n-      \n-      /* If we discovered more than one matching base class, we can\n-\t stop now.  */\n-      if (rval == error_mark_node)\n-\treturn error_mark_node;\n+\t     applies.  */\n+\t  if (data->rval && !same_type_p (r, data->rval))\n+\t    {\n+\t      data->rval = NULL_TREE;\n+\t      /* Terminate the walk with any non-NULL value.  */\n+\t      return r;\n+\t    }\n+\t  \n+\t  data->rval = r;\n+\t}\n     }\n \n-  return rval;\n+  return NULL_TREE;\n }\n \n /* Given a template type PARM and a class type ARG, find the unique\n@@ -9552,7 +9528,7 @@ get_template_base_recursive (tree tparms,\n static tree\n get_template_base (tree tparms, tree targs, tree parm, tree arg)\n {\n-  tree rval;\n+  get_template_base_data data;\n   tree arg_binfo;\n \n   gcc_assert (IS_AGGR_TYPE_CODE (TREE_CODE (arg)));\n@@ -9561,17 +9537,15 @@ get_template_base (tree tparms, tree targs, tree parm, tree arg)\n   if (!arg_binfo)\n     /* The type could not be completed.  */\n     return NULL_TREE;\n-  \n-  rval = get_template_base_recursive (tparms, targs,\n-\t\t\t\t      parm, arg_binfo, \n-\t\t\t\t      NULL_TREE,\n-\t\t\t\t      GTB_IGNORE_TYPE);\n \n-  /* Since get_template_base_recursive marks the bases classes, we\n-     must unmark them here.  */\n-  dfs_walk (arg_binfo, dfs_unmark, markedp, 0);\n+  data.tparms = tparms;\n+  data.targs = targs;\n+  data.parm = parm;\n+  data.rval = NULL_TREE;\n+\n+  dfs_walk_real (arg_binfo, get_template_base_r, 0, 0, &data);\n \n-  return rval;\n+  return data.rval;\n }\n \n /* Returns the level of DECL, which declares a template parameter.  */\n@@ -10058,10 +10032,9 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t\t       a class of the form template-id, A can be a\n \t\t       pointer to a derived class pointed to by the\n \t\t       deduced A.  */\n-\t\t  t = get_template_base (tparms, targs,\n-\t\t\t\t\t parm, arg);\n+\t\t  t = get_template_base (tparms, targs, parm, arg);\n \n-\t\t  if (! t || t == error_mark_node)\n+\t\t  if (!t)\n \t\t    return 1;\n \t\t}\n \t    }"}, {"sha": "96d273be195c78ff947a5c10ffb5e293a1cd2cf1", "filename": "gcc/cp/search.c", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d83768f785fecd3b735b7e97b8d33d9c2ed7608/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d83768f785fecd3b735b7e97b8d33d9c2ed7608/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=8d83768f785fecd3b735b7e97b8d33d9c2ed7608", "patch": "@@ -46,8 +46,6 @@ struct vbase_info\n };\n \n static int is_subobject_of_p (tree, tree);\n-static tree dfs_check_overlap (tree, void *);\n-static tree dfs_no_overlap_yet (tree, int, void *);\n static base_kind lookup_base_r (tree, tree, base_access, bool, tree *);\n static int dynamic_cast_base_recurse (tree, tree, bool, tree *);\n static tree dfs_debug_unmarkedp (tree, int, void *);\n@@ -2272,65 +2270,6 @@ lookup_conversions (tree type)\n   return list;\n }\n \n-struct overlap_info \n-{\n-  tree compare_type;\n-  int found_overlap;\n-};\n-\n-/* Check whether the empty class indicated by EMPTY_BINFO is also present\n-   at offset 0 in COMPARE_TYPE, and set found_overlap if so.  */\n-\n-static tree\n-dfs_check_overlap (tree empty_binfo, void *data)\n-{\n-  struct overlap_info *oi = (struct overlap_info *) data;\n-  tree binfo;\n-  \n-  for (binfo = TYPE_BINFO (oi->compare_type); \n-       ; \n-       binfo = BINFO_BASE_BINFO (binfo, 0))\n-    {\n-      if (BINFO_TYPE (binfo) == BINFO_TYPE (empty_binfo))\n-\t{\n-\t  oi->found_overlap = 1;\n-\t  break;\n-\t}\n-      else if (!BINFO_N_BASE_BINFOS (binfo))\n-\tbreak;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Trivial function to stop base traversal when we find something.  */\n-\n-static tree\n-dfs_no_overlap_yet (tree derived, int ix, void *data)\n-{\n-  tree binfo = BINFO_BASE_BINFO (derived, ix);\n-  struct overlap_info *oi = (struct overlap_info *) data;\n-  \n-  return !oi->found_overlap ? binfo : NULL_TREE;\n-}\n-\n-/* Returns nonzero if EMPTY_TYPE or any of its bases can also be found at\n-   offset 0 in NEXT_TYPE.  Used in laying out empty base class subobjects.  */\n-\n-int\n-types_overlap_p (tree empty_type, tree next_type)\n-{\n-  struct overlap_info oi;\n-\n-  if (! IS_AGGR_TYPE (next_type))\n-    return 0;\n-  oi.compare_type = next_type;\n-  oi.found_overlap = 0;\n-  dfs_walk (TYPE_BINFO (empty_type), dfs_check_overlap,\n-\t    dfs_no_overlap_yet, &oi);\n-  return oi.found_overlap;\n-}\n-\n /* Returns the binfo of the first direct or indirect virtual base derived\n    from BINFO, or NULL if binfo is not via virtual.  */\n "}]}