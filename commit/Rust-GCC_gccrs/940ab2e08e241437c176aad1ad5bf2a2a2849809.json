{"sha": "940ab2e08e241437c176aad1ad5bf2a2a2849809", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQwYWIyZTA4ZTI0MTQzN2MxNzZhYWQxYWQ1YmYyYTJhMjg0OTgwOQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-09-06T13:19:49Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-09-06T13:19:49Z"}, "message": "class.c (warn_hidden): Don't barf on non-functions.\n\n\t* class.c (warn_hidden): Don't barf on non-functions.\n\t* decl2.c (check_classfn): Likewise.  Check template match earlier.\n\nFrom-SVN: r251795", "tree": {"sha": "e704b87567b5e67635158fea46dfe73c33885d68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e704b87567b5e67635158fea46dfe73c33885d68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/940ab2e08e241437c176aad1ad5bf2a2a2849809", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/940ab2e08e241437c176aad1ad5bf2a2a2849809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/940ab2e08e241437c176aad1ad5bf2a2a2849809", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/940ab2e08e241437c176aad1ad5bf2a2a2849809/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1887fb461b2c370aeeedaba95b503fde9b2c70f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1887fb461b2c370aeeedaba95b503fde9b2c70f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1887fb461b2c370aeeedaba95b503fde9b2c70f9"}], "stats": {"total": 120, "additions": 64, "deletions": 56}, "files": [{"sha": "a48237235ba5e79474ca7f6e6b9c1799ccd57ad2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/940ab2e08e241437c176aad1ad5bf2a2a2849809/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/940ab2e08e241437c176aad1ad5bf2a2a2849809/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=940ab2e08e241437c176aad1ad5bf2a2a2849809", "patch": "@@ -1,5 +1,8 @@\n 2017-09-06  Nathan Sidwell  <nathan@acm.org>\n \n+\t* class.c (warn_hidden): Don't barf on non-functions.\n+\t* decl2.c (check_classfn): Likewise.  Check template match earlier.\n+\n \t* name-lookup.c (count_fields): Rename to ...\n \t(count_class_fields): ... here.  Take a class, don't count\n \tNULL-named fields."}, {"sha": "1390dc39bef145a80c7842af3b8b368106c063aa", "filename": "gcc/cp/class.c", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/940ab2e08e241437c176aad1ad5bf2a2a2849809/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/940ab2e08e241437c176aad1ad5bf2a2a2849809/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=940ab2e08e241437c176aad1ad5bf2a2a2849809", "patch": "@@ -2818,63 +2818,64 @@ check_for_override (tree decl, tree ctype)\n static void\n warn_hidden (tree t)\n {\n-  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (t);\n-  tree fns;\n+  if (vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (t))\n+    for (unsigned ix = method_vec->length (); ix--;)\n+      {\n+\ttree fns = (*method_vec)[ix];\n \n-  /* We go through each separately named virtual function.  */\n-  for (int i = 0; vec_safe_iterate (method_vec, i, &fns); ++i)\n-    {\n-      tree name = OVL_NAME (fns);\n-      auto_vec<tree, 20> base_fndecls;\n-      tree base_binfo;\n-      tree binfo;\n-      int j;\n+\tif (!OVL_P (fns))\n+\t  continue;\n \n-      /* Iterate through all of the base classes looking for possibly\n-\t hidden functions.  */\n-      for (binfo = TYPE_BINFO (t), j = 0;\n-\t   BINFO_BASE_ITERATE (binfo, j, base_binfo); j++)\n-\t{\n-\t  tree basetype = BINFO_TYPE (base_binfo);\n-\t  get_basefndecls (name, basetype, &base_fndecls);\n-\t}\n+\ttree name = OVL_NAME (fns);\n+\tauto_vec<tree, 20> base_fndecls;\n+\ttree base_binfo;\n+\ttree binfo;\n+\tunsigned j;\n \n-      /* If there are no functions to hide, continue.  */\n-      if (base_fndecls.is_empty ())\n-\tcontinue;\n+\t/* Iterate through all of the base classes looking for possibly\n+\t   hidden functions.  */\n+\tfor (binfo = TYPE_BINFO (t), j = 0;\n+\t     BINFO_BASE_ITERATE (binfo, j, base_binfo); j++)\n+\t  {\n+\t    tree basetype = BINFO_TYPE (base_binfo);\n+\t    get_basefndecls (name, basetype, &base_fndecls);\n+\t  }\n \n-      /* Remove any overridden functions.  */\n-      for (ovl_iterator iter (fns); iter; ++iter)\n-\t{\n-\t  tree fndecl = *iter;\n-\t  if (TREE_CODE (fndecl) == FUNCTION_DECL\n-\t      && DECL_VINDEX (fndecl))\n-\t    {\n-\t      /* If the method from the base class has the same\n-\t\t signature as the method from the derived class, it\n-\t\t has been overridden.  */\n-\t      for (size_t k = 0; k < base_fndecls.length (); k++)\n-\t\tif (base_fndecls[k]\n-\t\t    && same_signature_p (fndecl, base_fndecls[k]))\n-\t\t  base_fndecls[k] = NULL_TREE;\n-\t    }\n-\t}\n+\t/* If there are no functions to hide, continue.  */\n+\tif (base_fndecls.is_empty ())\n+\t  continue;\n \n-      /* Now give a warning for all base functions without overriders,\n-\t as they are hidden.  */\n-      size_t k;\n-      tree base_fndecl;\n-      FOR_EACH_VEC_ELT (base_fndecls, k, base_fndecl)\n-\tif (base_fndecl)\n+\t/* Remove any overridden functions.  */\n+\tfor (ovl_iterator iter (fns); iter; ++iter)\n \t  {\n-\t    /* Here we know it is a hider, and no overrider exists.  */\n-\t    warning_at (location_of (base_fndecl),\n-\t\t\tOPT_Woverloaded_virtual,\n-\t\t\t\"%qD was hidden\", base_fndecl);\n-\t    warning_at (location_of (fns),\n-\t\t\tOPT_Woverloaded_virtual, \"  by %qD\", fns);\n+\t    tree fndecl = *iter;\n+\t    if (TREE_CODE (fndecl) == FUNCTION_DECL\n+\t\t&& DECL_VINDEX (fndecl))\n+\t      {\n+\t\t/* If the method from the base class has the same\n+\t\t   signature as the method from the derived class, it\n+\t\t   has been overridden.  */\n+\t\tfor (size_t k = 0; k < base_fndecls.length (); k++)\n+\t\t  if (base_fndecls[k]\n+\t\t      && same_signature_p (fndecl, base_fndecls[k]))\n+\t\t    base_fndecls[k] = NULL_TREE;\n+\t      }\n \t  }\n-    }\n+\n+\t/* Now give a warning for all base functions without overriders,\n+\t   as they are hidden.  */\n+\ttree base_fndecl;\n+\tFOR_EACH_VEC_ELT (base_fndecls, j, base_fndecl)\n+\t  if (base_fndecl)\n+\t    {\n+\t      /* Here we know it is a hider, and no overrider exists.  */\n+\t      warning_at (location_of (base_fndecl),\n+\t\t\t  OPT_Woverloaded_virtual,\n+\t\t\t  \"%qD was hidden\", base_fndecl);\n+\t      warning_at (location_of (fns),\n+\t\t\t  OPT_Woverloaded_virtual, \"  by %qD\", fns);\n+\t    }\n+      }\n }\n \n /* Recursive helper for finish_struct_anon.  */\n@@ -6981,7 +6982,7 @@ unreverse_member_declarations (tree t)\n \n   /* For the TYPE_FIELDS, only the non TYPE_DECLs are in reverse\n      order, so we can't just use nreverse.  Due to stat_hack\n-     chicanery in finish_member_declarations.  */\n+     chicanery in finish_member_declaration.  */\n   prev = NULL_TREE;\n   for (x = TYPE_FIELDS (t);\n        x && TREE_CODE (x) != TYPE_DECL;"}, {"sha": "2bde588847e9ed1a750e9165e181159bd049fc4c", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/940ab2e08e241437c176aad1ad5bf2a2a2849809/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/940ab2e08e241437c176aad1ad5bf2a2a2849809/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=940ab2e08e241437c176aad1ad5bf2a2a2849809", "patch": "@@ -611,6 +611,15 @@ check_classfn (tree ctype, tree function, tree template_parms)\n   for (ovl_iterator iter (fns); !matched && iter; ++iter)\n     {\n       tree fndecl = *iter;\n+\n+      /* A member template definition only matches a member template\n+\t declaration.  */\n+      if (is_template != (TREE_CODE (fndecl) == TEMPLATE_DECL))\n+\tcontinue;\n+\n+      if (!DECL_DECLARES_FUNCTION_P (fndecl))\n+\tcontinue;\n+\n       tree p1 = TYPE_ARG_TYPES (TREE_TYPE (function));\n       tree p2 = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n \n@@ -625,11 +634,6 @@ check_classfn (tree ctype, tree function, tree template_parms)\n \t  && TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE)\n \tp1 = TREE_CHAIN (p1);\n \n-      /* A member template definition only matches a member template\n-\t declaration.  */\n-      if (is_template != (TREE_CODE (fndecl) == TEMPLATE_DECL))\n-\tcontinue;\n-\n       /* ref-qualifier or absence of same must match.  */\n       if (type_memfn_rqual (TREE_TYPE (function))\n \t  != type_memfn_rqual (TREE_TYPE (fndecl)))"}]}