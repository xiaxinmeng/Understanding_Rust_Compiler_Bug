{"sha": "7b668576fc09c86a301087f464e195678cb0aea0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I2Njg1NzZmYzA5Yzg2YTMwMTA4N2Y0NjRlMTk1Njc4Y2IwYWVhMA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2018-04-11T13:30:53Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2018-04-11T13:30:53Z"}, "message": "Improve IPA-CP handling of self-recursive calls\n\n2018-04-11  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/84149\n\t* ipa-cp.c (propagate_vals_across_pass_through): Expand comment.\n\t(cgraph_edge_brings_value_p): New parameter dest_val, check if it is\n\tnot the same as the source val.\n\t(cgraph_edge_brings_value_p): New parameter.\n\t(gather_edges_for_value): Pass destination value to\n\tcgraph_edge_brings_value_p.\n\t(perhaps_add_new_callers): Likewise.\n\t(get_info_about_necessary_edges): Likewise and exclude values brought\n\tonly by self-recursive edges.\n\t(create_specialized_node): Redirect only clones of self-calling edges.\n\t(+self_recursive_pass_through_p): New function.\n\t(find_more_scalar_values_for_callers_subset): Use it.\n\t(find_aggregate_values_for_callers_subset): Likewise.\n\t(known_aggs_to_agg_replacement_list): Removed.\n\t(decide_whether_version_node): Re-calculate known constants for all\n\tremaining context clones.\n\nFrom-SVN: r259319", "tree": {"sha": "eeba5abe393b99f0ba5516eb12172c1f4fbe8de3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eeba5abe393b99f0ba5516eb12172c1f4fbe8de3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b668576fc09c86a301087f464e195678cb0aea0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b668576fc09c86a301087f464e195678cb0aea0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b668576fc09c86a301087f464e195678cb0aea0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b668576fc09c86a301087f464e195678cb0aea0/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fe0604d349c4d9eb18b17dd018383d591eed67c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe0604d349c4d9eb18b17dd018383d591eed67c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe0604d349c4d9eb18b17dd018383d591eed67c7"}], "stats": {"total": 141, "additions": 98, "deletions": 43}, "files": [{"sha": "7964b384d0b2422154788eab086ade778e132724", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b668576fc09c86a301087f464e195678cb0aea0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b668576fc09c86a301087f464e195678cb0aea0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b668576fc09c86a301087f464e195678cb0aea0", "patch": "@@ -1,3 +1,23 @@\n+2018-04-11  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/84149\n+\t* ipa-cp.c (propagate_vals_across_pass_through): Expand comment.\n+\t(cgraph_edge_brings_value_p): New parameter dest_val, check if it is\n+\tnot the same as the source val.\n+\t(cgraph_edge_brings_value_p): New parameter.\n+\t(gather_edges_for_value): Pass destination value to\n+\tcgraph_edge_brings_value_p.\n+\t(perhaps_add_new_callers): Likewise.\n+\t(get_info_about_necessary_edges): Likewise and exclude values brought\n+\tonly by self-recursive edges.\n+\t(create_specialized_node): Redirect only clones of self-calling edges.\n+\t(+self_recursive_pass_through_p): New function.\n+\t(find_more_scalar_values_for_callers_subset): Use it.\n+\t(find_aggregate_values_for_callers_subset): Likewise.\n+\t(known_aggs_to_agg_replacement_list): Removed.\n+\t(decide_whether_version_node): Re-calculate known constants for all\n+\tremaining context clones.\n+\n 2018-04-11  Richard Biener  <rguenther@suse.de>\n \n \tPR lto/85339"}, {"sha": "b2627ffd05fe19fe775bbf951de6bda285d0ef48", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 78, "deletions": 43, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b668576fc09c86a301087f464e195678cb0aea0/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b668576fc09c86a301087f464e195678cb0aea0/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=7b668576fc09c86a301087f464e195678cb0aea0", "patch": "@@ -1601,7 +1601,9 @@ propagate_vals_across_pass_through (cgraph_edge *cs, ipa_jump_func *jfunc,\n \n   /* Do not create new values when propagating within an SCC because if there\n      are arithmetic functions with circular dependencies, there is infinite\n-     number of them and we would just make lattices bottom.  */\n+     number of them and we would just make lattices bottom.  If this condition\n+     is ever relaxed we have to detect self-feeding recursive calls in\n+     cgraph_edge_brings_value_p in a smarter way.  */\n   if ((ipa_get_jf_pass_through_operation (jfunc) != NOP_EXPR)\n       && ipa_edge_within_scc (cs))\n     ret = dest_lat->set_contains_variable ();\n@@ -3472,12 +3474,12 @@ same_node_or_its_all_contexts_clone_p (cgraph_node *node, cgraph_node *dest)\n   return info->is_all_contexts_clone && info->ipcp_orig_node == dest;\n }\n \n-/* Return true if edge CS does bring about the value described by SRC to node\n-   DEST or its clone for all contexts.  */\n+/* Return true if edge CS does bring about the value described by SRC to\n+   DEST_VAL of node DEST or its clone for all contexts.  */\n \n static bool\n cgraph_edge_brings_value_p (cgraph_edge *cs, ipcp_value_source<tree> *src,\n-\t\t\t    cgraph_node *dest)\n+\t\t\t    cgraph_node *dest, ipcp_value<tree> *dest_val)\n {\n   struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n   enum availability availability;\n@@ -3487,7 +3489,9 @@ cgraph_edge_brings_value_p (cgraph_edge *cs, ipcp_value_source<tree> *src,\n       || availability <= AVAIL_INTERPOSABLE\n       || caller_info->node_dead)\n     return false;\n-  if (!src->val)\n+  /* At the moment we do not propagate over arithmetic jump functions in SCCs,\n+     so it is safe to detect self-feeding recursive calls in this way.  */\n+  if (!src->val || src->val == dest_val)\n     return true;\n \n   if (caller_info->ipcp_orig_node)\n@@ -3523,13 +3527,14 @@ cgraph_edge_brings_value_p (cgraph_edge *cs, ipcp_value_source<tree> *src,\n     }\n }\n \n-/* Return true if edge CS does bring about the value described by SRC to node\n-   DEST or its clone for all contexts.  */\n+/* Return true if edge CS does bring about the value described by SRC to\n+   DST_VAL of node DEST or its clone for all contexts.  */\n \n static bool\n cgraph_edge_brings_value_p (cgraph_edge *cs,\n \t\t\t    ipcp_value_source<ipa_polymorphic_call_context> *src,\n-\t\t\t    cgraph_node *dest)\n+\t\t\t    cgraph_node *dest,\n+\t\t\t    ipcp_value<ipa_polymorphic_call_context> *)\n {\n   struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n   cgraph_node *real_dest = cs->callee->function_symbol ();\n@@ -3560,9 +3565,10 @@ get_next_cgraph_edge_clone (struct cgraph_edge *cs)\n   return next_edge_clone[cs->uid];\n }\n \n-/* Given VAL that is intended for DEST, iterate over all its sources and if\n-   they still hold, add their edge frequency and their number into *FREQUENCY\n-   and *CALLER_COUNT respectively.  */\n+/* Given VAL that is intended for DEST, iterate over all its sources and if any\n+   of them is viable and hot, return true.  In that case, for those that still\n+   hold, add their edge frequency and their number into *FREQUENCY and\n+   *CALLER_COUNT respectively.  */\n \n template <typename valtype>\n static bool\n@@ -3574,24 +3580,32 @@ get_info_about_necessary_edges (ipcp_value<valtype> *val, cgraph_node *dest,\n   int freq = 0, count = 0;\n   profile_count cnt = profile_count::zero ();\n   bool hot = false;\n+  bool non_self_recursive = false;\n \n   for (src = val->sources; src; src = src->next)\n     {\n       struct cgraph_edge *cs = src->cs;\n       while (cs)\n \t{\n-\t  if (cgraph_edge_brings_value_p (cs, src, dest))\n+\t  if (cgraph_edge_brings_value_p (cs, src, dest, val))\n \t    {\n \t      count++;\n \t      freq += cs->frequency ();\n \t      if (cs->count.ipa ().initialized_p ())\n \t        cnt += cs->count.ipa ();\n \t      hot |= cs->maybe_hot_p ();\n+\t      if (cs->caller != dest)\n+\t\tnon_self_recursive = true;\n \t    }\n \t  cs = get_next_cgraph_edge_clone (cs);\n \t}\n     }\n \n+  /* If the only edges bringing a value are self-recursive ones, do not bother\n+     evaluating it.  */\n+  if (!non_self_recursive)\n+    return false;\n+\n   *freq_sum = freq;\n   *count_sum = cnt;\n   *caller_count = count;\n@@ -3615,7 +3629,7 @@ gather_edges_for_value (ipcp_value<valtype> *val, cgraph_node *dest,\n       struct cgraph_edge *cs = src->cs;\n       while (cs)\n \t{\n-\t  if (cgraph_edge_brings_value_p (cs, src, dest))\n+\t  if (cgraph_edge_brings_value_p (cs, src, dest, val))\n \t    ret.quick_push (cs);\n \t  cs = get_next_cgraph_edge_clone (cs);\n \t}\n@@ -3835,9 +3849,28 @@ create_specialized_node (struct cgraph_node *node,\n \t    vec_safe_push (replace_trees, replace_map);\n \t}\n     }\n+  auto_vec<cgraph_edge *, 2> self_recursive_calls;\n+  for (i = callers.length () - 1; i >= 0; i--)\n+    {\n+      cgraph_edge *cs = callers[i];\n+      if (cs->caller == node)\n+\t{\n+\t  self_recursive_calls.safe_push (cs);\n+\t  callers.unordered_remove (i);\n+\t}\n+    }\n \n   new_node = node->create_virtual_clone (callers, replace_trees,\n \t\t\t\t\t args_to_skip, \"constprop\");\n+\n+  for (unsigned j = 0; j < self_recursive_calls.length (); j++)\n+    {\n+      cgraph_edge *cs = next_edge_clone[self_recursive_calls[j]->uid];\n+      gcc_checking_assert (cs);\n+      gcc_assert (cs->caller == new_node);\n+      cs->redirect_callee_duplicating_thunks (new_node);\n+    }\n+\n   ipa_set_node_agg_value_chain (new_node, aggvals);\n   for (av = aggvals; av; av = av->next)\n     new_node->maybe_create_reference (av->value, NULL);\n@@ -3870,6 +3903,22 @@ create_specialized_node (struct cgraph_node *node,\n   return new_node;\n }\n \n+/* Return true, if JFUNC, which describes a i-th parameter of call CS, is a\n+   simple no-operation pass-through function to itself.  */\n+\n+static bool\n+self_recursive_pass_through_p (cgraph_edge *cs, ipa_jump_func *jfunc, int i)\n+{\n+  enum availability availability;\n+  if (cs->caller == cs->callee->function_symbol (&availability)\n+      && availability > AVAIL_INTERPOSABLE\n+      && jfunc->type == IPA_JF_PASS_THROUGH\n+      && ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR\n+      && ipa_get_jf_pass_through_formal_id (jfunc) == i)\n+    return true;\n+  return false;\n+}\n+\n /* Given a NODE, and a subset of its CALLERS, try to populate blanks slots in\n    KNOWN_CSTS with constants that are also known for all of the CALLERS.  */\n \n@@ -3897,6 +3946,9 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n \t  struct ipa_jump_func *jump_func;\n \t  tree t;\n \n+\t  if (IPA_NODE_REF (cs->caller)->node_dead)\n+\t    continue;\n+\n \t  if (i >= ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n \t      || (i == 0\n \t\t  && call_passes_through_thunk_p (cs))\n@@ -3907,6 +3959,9 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n \t      break;\n \t    }\n \t  jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n+\t  if (self_recursive_pass_through_p (cs, jump_func, i))\n+\t    continue;\n+\n \t  t = ipa_value_from_jfunc (IPA_NODE_REF (cs->caller), jump_func, type);\n \t  if (!t\n \t      || (newval\n@@ -4299,6 +4354,10 @@ find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n \n       FOR_EACH_VEC_ELT (callers, j, cs)\n \t{\n+\t  struct ipa_jump_func *jfunc\n+\t    = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n+\t  if (self_recursive_pass_through_p (cs, jfunc, i))\n+\t    continue;\n \t  inter = intersect_aggregates_with_edge (cs, i, inter);\n \n \t  if (!inter.exists ())\n@@ -4329,33 +4388,6 @@ find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n   return res;\n }\n \n-/* Turn KNOWN_AGGS into a list of aggregate replacement values.  */\n-\n-static struct ipa_agg_replacement_value *\n-known_aggs_to_agg_replacement_list (vec<ipa_agg_jump_function> known_aggs)\n-{\n-  struct ipa_agg_replacement_value *res;\n-  struct ipa_agg_replacement_value **tail = &res;\n-  struct ipa_agg_jump_function *aggjf;\n-  struct ipa_agg_jf_item *item;\n-  int i, j;\n-\n-  FOR_EACH_VEC_ELT (known_aggs, i, aggjf)\n-    FOR_EACH_VEC_SAFE_ELT (aggjf->items, j, item)\n-      {\n-\tstruct ipa_agg_replacement_value *v;\n-\tv = ggc_alloc<ipa_agg_replacement_value> ();\n-\tv->index = i;\n-\tv->offset = item->offset;\n-\tv->value = item->value;\n-\tv->by_ref = aggjf->by_ref;\n-\t*tail = v;\n-\ttail = &v->next;\n-      }\n-  *tail = NULL;\n-  return res;\n-}\n-\n /* Determine whether CS also brings all scalar values that the NODE is\n    specialized for.  */\n \n@@ -4481,7 +4513,7 @@ perhaps_add_new_callers (cgraph_node *node, ipcp_value<valtype> *val)\n       struct cgraph_edge *cs = src->cs;\n       while (cs)\n \t{\n-\t  if (cgraph_edge_brings_value_p (cs, src, node)\n+\t  if (cgraph_edge_brings_value_p (cs, src, node, val)\n \t      && cgraph_edge_brings_all_scalars_for_node (cs, val->spec_node)\n \t      && cgraph_edge_brings_all_agg_vals_for_node (cs, val->spec_node))\n \t    {\n@@ -4746,15 +4778,18 @@ decide_whether_version_node (struct cgraph_node *node)\n \t\t \"for all known contexts.\\n\", node->dump_name ());\n \n       callers = node->collect_callers ();\n+      find_more_scalar_values_for_callers_subset (node, known_csts, callers);\n+      find_more_contexts_for_caller_subset (node, &known_contexts, callers);\n+      ipa_agg_replacement_value *aggvals\n+\t= find_aggregate_values_for_callers_subset (node, callers);\n \n       if (!known_contexts_useful_p (known_contexts))\n \t{\n \t  known_contexts.release ();\n \t  known_contexts = vNULL;\n \t}\n       clone = create_specialized_node (node, known_csts, known_contexts,\n-\t\t\t       known_aggs_to_agg_replacement_list (known_aggs),\n-\t\t\t       callers);\n+\t\t\t\t       aggvals, callers);\n       info = IPA_NODE_REF (node);\n       info->do_clone_for_all_contexts = false;\n       IPA_NODE_REF (clone)->is_all_contexts_clone = true;"}]}