{"sha": "261cdd23195bc921737fd7a44e34a93aaaaccc44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYxY2RkMjMxOTViYzkyMTczN2ZkN2E0NGUzNGE5M2FhYWFjY2M0NA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-01-20T10:28:30Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-01-20T15:32:11Z"}, "message": "Handle overflow in dependence analysis lambda ops gracefully\n\nThe following tries to handle overflow in the integer computations\ndone by lambda ops of dependence analysis by failing instead of\nsilently continuing with overflowed values.\n\nIt also avoids treating large unsigned CHREC_RIGHT as negative\nunless the chrec is of pointer type and avoids the most negative\ninteger value to avoid excessive overflow checking (with this\nthe fix for PR98758 can be partly simplified as seen).\n\nI've added add_hwi and mul_hwi functions computing HOST_WIDE_INT\nsigned sum and product with indicating overflow, they hopefully\nget matched to the appropriate internal functions.\n\nI don't have any testcases triggering overflow in any of the\nguarded computations.\n\n2021-01-20  Richard Biener  <rguenther@suse.de>\n\n\t* hwint.h (add_hwi): New function.\n\t(mul_hwi): Likewise.\n\t* tree-data-ref.c (initialize_matrix_A): Properly translate\n\ttree constants and avoid HOST_WIDE_INT_MIN.\n\t(lambda_matrix_row_add): Avoid undefined integer overflow\n\tand return true on such overflow.\n\t(lambda_matrix_right_hermite): Handle overflow from\n\tlambda_matrix_row_add gracefully.  Simplify previous fix.\n\t(analyze_subscript_affine_affine): Likewise.", "tree": {"sha": "7f37b944a8f399454214be858ba4b5dad56c7252", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f37b944a8f399454214be858ba4b5dad56c7252"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/261cdd23195bc921737fd7a44e34a93aaaaccc44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261cdd23195bc921737fd7a44e34a93aaaaccc44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/261cdd23195bc921737fd7a44e34a93aaaaccc44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261cdd23195bc921737fd7a44e34a93aaaaccc44/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49e8c14ef6f1f968602a04c8499a672182590e87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49e8c14ef6f1f968602a04c8499a672182590e87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49e8c14ef6f1f968602a04c8499a672182590e87"}], "stats": {"total": 105, "additions": 91, "deletions": 14}, "files": [{"sha": "0e895f8646661801177f404bfeb761940e9aed72", "filename": "gcc/hwint.h", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261cdd23195bc921737fd7a44e34a93aaaaccc44/gcc%2Fhwint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261cdd23195bc921737fd7a44e34a93aaaaccc44/gcc%2Fhwint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.h?ref=261cdd23195bc921737fd7a44e34a93aaaaccc44", "patch": "@@ -333,4 +333,46 @@ absu_hwi (HOST_WIDE_INT x)\n   return x >= 0 ? (unsigned HOST_WIDE_INT)x : -(unsigned HOST_WIDE_INT)x;\n }\n \n+/* Compute the sum of signed A and B and indicate in *OVERFLOW whether\n+   that operation overflowed.  */\n+\n+inline HOST_WIDE_INT\n+add_hwi (HOST_WIDE_INT a, HOST_WIDE_INT b, bool *overflow)\n+{\n+#if GCC_VERSION < 11000\n+  unsigned HOST_WIDE_INT result = a + (unsigned HOST_WIDE_INT)b;\n+  if ((((result ^ a) & (result ^ b))\n+       >> (HOST_BITS_PER_WIDE_INT - 1)) & 1)\n+    *overflow = true;\n+  else\n+    *overflow = false;\n+  return result;\n+#else\n+  HOST_WIDE_INT result;\n+  *overflow = __builtin_add_overflow (a, b, &result);\n+  return result;\n+#endif\n+}\n+\n+/* Compute the product of signed A and B and indicate in *OVERFLOW whether\n+   that operation overflowed.  */\n+\n+inline HOST_WIDE_INT\n+mul_hwi (HOST_WIDE_INT a, HOST_WIDE_INT b, bool *overflow)\n+{\n+#if GCC_VERSION < 11000\n+  unsigned HOST_WIDE_INT result = a * (unsigned HOST_WIDE_INT)b;\n+  if ((a == -1 && b == HOST_WIDE_INT_MIN)\n+      || (a != 0 && (HOST_WIDE_INT)result / a != b))\n+    *overflow = true;\n+  else\n+    *overflow = false;\n+  return result;\n+#else\n+  HOST_WIDE_INT result;\n+  *overflow = __builtin_mul_overflow (a, b, &result);\n+  return result;\n+#endif\n+}\n+\n #endif /* ! GCC_HWINT_H */"}, {"sha": "d19c5eb51e490540b78440d1d3e3f6d34745249c", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 49, "deletions": 14, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261cdd23195bc921737fd7a44e34a93aaaaccc44/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261cdd23195bc921737fd7a44e34a93aaaaccc44/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=261cdd23195bc921737fd7a44e34a93aaaaccc44", "patch": "@@ -3924,9 +3924,25 @@ initialize_matrix_A (lambda_matrix A, tree chrec, unsigned index, int mult)\n   switch (TREE_CODE (chrec))\n     {\n     case POLYNOMIAL_CHREC:\n-      if (!cst_and_fits_in_hwi (CHREC_RIGHT (chrec)))\n+      /* CHREC_RIGHT and its negated value should fit in a lambda_int.\n+\t Pointer typed chrecs right are to be interpreted signed.  */\n+      HOST_WIDE_INT chrec_right;\n+      if (POINTER_TYPE_P (chrec_type (chrec)))\n+\t{\n+\t  if (!cst_and_fits_in_hwi (CHREC_RIGHT (chrec)))\n+\t    return chrec_dont_know;\n+\t  chrec_right = int_cst_value (CHREC_RIGHT (chrec));\n+\t}\n+      else\n+\t{\n+\t  if (!tree_fits_shwi_p (CHREC_RIGHT (chrec)))\n+\t    return chrec_dont_know;\n+\t  chrec_right = tree_to_shwi (CHREC_RIGHT (chrec));\n+\t}\n+      /* We want to be able to negate without overflow.  */\n+      if (chrec_right == HOST_WIDE_INT_MIN)\n \treturn chrec_dont_know;\n-      A[index][0] = mult * int_cst_value (CHREC_RIGHT (chrec));\n+      A[index][0] = mult * chrec_right;\n       return initialize_matrix_A (A, CHREC_LEFT (chrec), index + 1, mult);\n \n     case PLUS_EXPR:\n@@ -4193,17 +4209,28 @@ lambda_vector_first_nz (lambda_vector vec1, int n, int start)\n /* Add a multiple of row R1 of matrix MAT with N columns to row R2:\n    R2 = R2 + CONST1 * R1.  */\n \n-static void\n+static bool\n lambda_matrix_row_add (lambda_matrix mat, int n, int r1, int r2,\n \t\t       lambda_int const1)\n {\n   int i;\n \n   if (const1 == 0)\n-    return;\n+    return true;\n \n   for (i = 0; i < n; i++)\n-    mat[r2][i] += const1 * mat[r1][i];\n+    {\n+      bool ovf;\n+      lambda_int tem = mul_hwi (mat[r1][i], const1, &ovf);\n+      if (ovf)\n+\treturn false;\n+      lambda_int tem2 = add_hwi (mat[r2][i], tem, &ovf);\n+      if (ovf || tem2 == HOST_WIDE_INT_MIN)\n+\treturn false;\n+      mat[r2][i] = tem2;\n+    }\n+\n+  return true;\n }\n \n /* Multiply vector VEC1 of length SIZE by a constant CONST1,\n@@ -4258,7 +4285,7 @@ lambda_vector_equal (lambda_vector vec1, lambda_vector vec2, int size)\n    Ref: Algorithm 2.1 page 33 in \"Loop Transformations for\n    Restructuring Compilers\" Utpal Banerjee.  */\n \n-static void\n+static bool\n lambda_matrix_right_hermite (lambda_matrix A, int m, int n,\n \t\t\t     lambda_matrix S, lambda_matrix U)\n {\n@@ -4276,24 +4303,26 @@ lambda_matrix_right_hermite (lambda_matrix A, int m, int n,\n \t    {\n \t      while (S[i][j] != 0)\n \t\t{\n-\t\t  lambda_int sigma, factor, a, b;\n+\t\t  lambda_int factor, a, b;\n \n \t\t  a = S[i-1][j];\n \t\t  b = S[i][j];\n-\t\t  sigma = ((a < 0) ^ (b < 0)) ? -1: 1;\n-\t\t  unsigned HOST_WIDE_INT abs_a = absu_hwi (a);\n-\t\t  unsigned HOST_WIDE_INT abs_b = absu_hwi (b);\n-\t\t  factor = sigma * (lambda_int)(abs_a / abs_b);\n+\t\t  gcc_assert (a != HOST_WIDE_INT_MIN);\n+\t\t  factor = a / b;\n \n-\t\t  lambda_matrix_row_add (S, n, i, i-1, -factor);\n+\t\t  if (!lambda_matrix_row_add (S, n, i, i-1, -factor))\n+\t\t    return false;\n \t\t  std::swap (S[i], S[i-1]);\n \n-\t\t  lambda_matrix_row_add (U, m, i, i-1, -factor);\n+\t\t  if (!lambda_matrix_row_add (U, m, i, i-1, -factor))\n+\t\t    return false;\n \t\t  std::swap (U[i], U[i-1]);\n \t\t}\n \t    }\n \t}\n     }\n+\n+  return true;\n }\n \n /* Determines the overlapping elements due to accesses CHREC_A and\n@@ -4410,7 +4439,13 @@ analyze_subscript_affine_affine (tree chrec_a,\n     }\n \n   /* U.A = S */\n-  lambda_matrix_right_hermite (A, dim, 1, S, U);\n+  if (!lambda_matrix_right_hermite (A, dim, 1, S, U))\n+    {\n+      *overlaps_a = conflict_fn_not_known ();\n+      *overlaps_b = conflict_fn_not_known ();\n+      *last_conflicts = chrec_dont_know;\n+      goto end_analyze_subs_aa;\n+    }\n \n   if (S[0][0] < 0)\n     {"}]}