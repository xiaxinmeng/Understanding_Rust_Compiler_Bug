{"sha": "6d799f0aed18be25a5c908499b6411ab6d06b78c", "node_id": "C_kwDOANBUbNoAKDZkNzk5ZjBhZWQxOGJlMjVhNWM5MDg0OTliNjQxMWFiNmQwNmI3OGM", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-12-09T17:59:38Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-12-11T16:17:58Z"}, "message": "d: Merge upstream dmd, druntime c8ae4adb2e, phobos 792c8b7c1.\n\nD front-end changes:\n\n\t- Import dmd v2.101.0.\n\t- Deprecate the ability to call `__traits(getAttributes)' on\n\t  overload sets.\n\t- Deprecate non-empty `for' statement increment clause with no\n\t  effect.\n\t- Array literals assigned to `scope' array variables can now be\n\t  allocated on the stack.\n\nD runtime changes:\n\n\t- Import druntime v2.101.0.\n\nPhobos changes:\n\n\t- Import phobos v2.101.0.\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd c8ae4adb2e.\n\t* typeinfo.cc (check_typeinfo_type): Update for new front-end\n\tinterface.\n\t(TypeInfoVisitor::visit (TypeInfoStructDeclaration *)): Remove warning\n\tthat toHash() must be declared 'nothrow @safe`.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime c8ae4adb2e.\n\t* src/MERGE: Merge upstream phobos 792c8b7c1.", "tree": {"sha": "3e6a91048c7fe3e78bae9f75b24eb37c5504681b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e6a91048c7fe3e78bae9f75b24eb37c5504681b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d799f0aed18be25a5c908499b6411ab6d06b78c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d799f0aed18be25a5c908499b6411ab6d06b78c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d799f0aed18be25a5c908499b6411ab6d06b78c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d799f0aed18be25a5c908499b6411ab6d06b78c/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc7f509d3c0b3ab63891cf7ca2def0fdfb3642c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc7f509d3c0b3ab63891cf7ca2def0fdfb3642c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc7f509d3c0b3ab63891cf7ca2def0fdfb3642c4"}], "stats": {"total": 4003, "additions": 2457, "deletions": 1546}, "files": [{"sha": "5ee6f624836281760931fd3b4e203389f14d3c16", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1,4 +1,4 @@\n-e4f89195913be1dc638707b1abb24c4f3ae7e0bf\n+c8ae4adb2eda515b09b326948e3a4aa9f489af45\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "50fdc3b7da717ef1525bd833606933cc262df3e1", "filename": "gcc/d/dmd/aggregate.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Faggregate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Faggregate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -193,7 +193,7 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n      */\n     final size_t nonHiddenFields()\n     {\n-        return fields.dim - isNested() - (vthis2 !is null);\n+        return fields.length - isNested() - (vthis2 !is null);\n     }\n \n     /***************************************\n@@ -274,7 +274,7 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n     {\n         //printf(\"AggregateDeclaration::checkOverlappedFields() %s\\n\", toChars());\n         assert(sizeok == Sizeok.done);\n-        size_t nfields = fields.dim;\n+        size_t nfields = fields.length;\n         if (isNested())\n         {\n             auto cd = isClassDeclaration();\n@@ -362,7 +362,7 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n         const nfields = nonHiddenFields();\n         bool errors = false;\n \n-        size_t dim = elements.dim;\n+        size_t dim = elements.length;\n         elements.setDim(nfields);\n         foreach (size_t i; dim .. nfields)\n             elements[i] = null;\n@@ -774,7 +774,7 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n                 }\n             }\n \n-            for (size_t i = 0; i < members.dim; i++)\n+            for (size_t i = 0; i < members.length; i++)\n             {\n                 auto sm = (*members)[i];\n                 sm.apply(&SearchCtor.fp, null);"}, {"sha": "55d69b555f88b85bafd553ef8ee8febefaafa1a3", "filename": "gcc/d/dmd/attrib.d", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fattrib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fattrib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -781,7 +781,7 @@ extern (C++) final class AnonDeclaration : AttribDeclaration\n              * so in order to place that member we need to compute the member's\n              * size and alignment.\n              */\n-            size_t fieldstart = ad.fields.dim;\n+            size_t fieldstart = ad.fields.length;\n \n             /* Hackishly hijack ad's structsize and alignsize fields\n              * for use in our fake anon aggregate member.\n@@ -804,7 +804,7 @@ extern (C++) final class AnonDeclaration : AttribDeclaration\n              * added in ad.fields, just update *poffset for the subsequent\n              * field offset calculation.\n              */\n-            if (fieldstart == ad.fields.dim)\n+            if (fieldstart == ad.fields.length)\n             {\n                 ad.structsize = savestructsize;\n                 ad.alignsize = savealignsize;\n@@ -838,7 +838,7 @@ extern (C++) final class AnonDeclaration : AttribDeclaration\n \n             // Add to the anon fields the base offset of this anonymous aggregate\n             //printf(\"anon fields, anonoffset = %d\\n\", anonoffset);\n-            foreach (const i; fieldstart .. ad.fields.dim)\n+            foreach (const i; fieldstart .. ad.fields.length)\n             {\n                 VarDeclaration v = ad.fields[i];\n                 //printf(\"\\t[%d] %s %d\\n\", i, v.toChars(), v.offset);\n@@ -1349,7 +1349,7 @@ extern (C++) final class UserAttributeDeclaration : AttribDeclaration\n     override Scope* newScope(Scope* sc)\n     {\n         Scope* sc2 = sc;\n-        if (atts && atts.dim)\n+        if (atts && atts.length)\n         {\n             // create new one for changes\n             sc2 = sc.copy();\n@@ -1369,9 +1369,9 @@ extern (C++) final class UserAttributeDeclaration : AttribDeclaration\n     extern (D) static Expressions* concat(Expressions* udas1, Expressions* udas2)\n     {\n         Expressions* udas;\n-        if (!udas1 || udas1.dim == 0)\n+        if (!udas1 || udas1.length == 0)\n             udas = udas2;\n-        else if (!udas2 || udas2.dim == 0)\n+        else if (!udas2 || udas2.length == 0)\n             udas = udas1;\n         else\n         {\n@@ -1395,7 +1395,7 @@ extern (C++) final class UserAttributeDeclaration : AttribDeclaration\n         auto exps = new Expressions();\n         if (userAttribDecl && userAttribDecl !is this)\n             exps.push(new TupleExp(Loc.initial, userAttribDecl.getAttributes()));\n-        if (atts && atts.dim)\n+        if (atts && atts.length)\n             exps.push(new TupleExp(Loc.initial, atts));\n         return exps;\n     }"}, {"sha": "64568763a87e7ca6ad43d6aaa34556a17e87ca9b", "filename": "gcc/d/dmd/blockexit.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fblockexit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fblockexit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fblockexit.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -122,7 +122,7 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n \n         override void visit(CompoundStatement cs)\n         {\n-            //printf(\"CompoundStatement.blockExit(%p) %d result = x%X\\n\", cs, cs.statements.dim, result);\n+            //printf(\"CompoundStatement.blockExit(%p) %d result = x%X\\n\", cs, cs.statements.length, result);\n             result = BE.fallthru;\n             Statement slast = null;\n             foreach (s; *cs.statements)\n@@ -547,7 +547,7 @@ BE checkThrow(ref const Loc loc, Expression exp, const bool mustNotThrow)\n     ClassDeclaration cd = t.isClassHandle();\n     assert(cd);\n \n-    if (cd == ClassDeclaration.errorException || ClassDeclaration.errorException.isBaseOf(cd, null))\n+    if (cd.isErrorException())\n     {\n         return BE.errthrow;\n     }"}, {"sha": "cb9289fd773425d612bd0d5a48e5d7adc3a26b58", "filename": "gcc/d/dmd/canthrow.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fcanthrow.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fcanthrow.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcanthrow.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -102,7 +102,7 @@ extern (C++) /* CT */ BE canThrow(Expression e, FuncDeclaration func, bool mustN\n             if (global.errors && !ce.e1.type)\n                 return; // error recovery\n \n-            if (ce.f && ce.arguments.dim > 0)\n+            if (ce.f && ce.arguments.length > 0)\n             {\n                 Type tb = (*ce.arguments)[0].type.toBasetype();\n                 auto tbNext = tb.nextOf();"}, {"sha": "c030d353c182fe43d2b839bac8348229783a3c8b", "filename": "gcc/d/dmd/clone.d", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fclone.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fclone.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fclone.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -870,17 +870,17 @@ void buildDtors(AggregateDeclaration ad, Scope* sc)\n         return;                    // unions don't have destructors\n \n     StorageClass stc = STC.safe | STC.nothrow_ | STC.pure_ | STC.nogc;\n-    Loc declLoc = ad.userDtors.dim ? ad.userDtors[0].loc : ad.loc;\n+    Loc declLoc = ad.userDtors.length ? ad.userDtors[0].loc : ad.loc;\n     Loc loc; // internal code should have no loc to prevent coverage\n     FuncDeclaration xdtor_fwd = null;\n \n     // Build the field destructor (`ad.fieldDtor`), if needed.\n     // If the user dtor is an extern(C++) prototype, then we expect it performs a full-destruction and skip building.\n-    const bool dtorIsCppPrototype = ad.userDtors.dim && ad.userDtors[0]._linkage == LINK.cpp && !ad.userDtors[0].fbody;\n+    const bool dtorIsCppPrototype = ad.userDtors.length && ad.userDtors[0]._linkage == LINK.cpp && !ad.userDtors[0].fbody;\n     if (!dtorIsCppPrototype)\n     {\n         Expression e = null;\n-        for (size_t i = 0; i < ad.fields.dim; i++)\n+        for (size_t i = 0; i < ad.fields.length; i++)\n         {\n             auto v = ad.fields[i];\n             if (v.storage_class & STC.ref_)\n@@ -985,7 +985,7 @@ void buildDtors(AggregateDeclaration ad, Scope* sc)\n     }\n \n     // Set/build `ad.aggrDtor`\n-    switch (dtors.dim)\n+    switch (dtors.length)\n     {\n     case 0:\n         break;\n@@ -1168,7 +1168,7 @@ private DtorDeclaration buildExternDDtor(AggregateDeclaration ad, Scope* sc)\n  */\n FuncDeclaration buildInv(AggregateDeclaration ad, Scope* sc)\n {\n-    switch (ad.invs.dim)\n+    switch (ad.invs.length)\n     {\n     case 0:\n         return null;\n@@ -1225,11 +1225,11 @@ FuncDeclaration buildPostBlit(StructDeclaration sd, Scope* sc)\n     if (sd.isUnionDeclaration())\n         return null;\n \n-    const hasUserDefinedPosblit = sd.postblits.dim && !sd.postblits[0].isDisabled ? true : false;\n+    const hasUserDefinedPosblit = sd.postblits.length && !sd.postblits[0].isDisabled ? true : false;\n \n     // by default, the storage class of the created postblit\n     StorageClass stc = STC.safe | STC.nothrow_ | STC.pure_ | STC.nogc;\n-    Loc declLoc = sd.postblits.dim ? sd.postblits[0].loc : sd.loc;\n+    Loc declLoc = sd.postblits.length ? sd.postblits[0].loc : sd.loc;\n     Loc loc; // internal code should have no loc to prevent coverage\n \n     // if any of the postblits are disabled, then the generated postblit\n@@ -1240,7 +1240,7 @@ FuncDeclaration buildPostBlit(StructDeclaration sd, Scope* sc)\n     VarDeclaration[] fieldsToDestroy;\n     auto postblitCalls = new Statements();\n     // iterate through all the struct fields that are not disabled\n-    for (size_t i = 0; i < sd.fields.dim && !(stc & STC.disable); i++)\n+    for (size_t i = 0; i < sd.fields.length && !(stc & STC.disable); i++)\n     {\n         auto structField = sd.fields[i];\n         if (structField.storage_class & STC.ref_)\n@@ -1411,7 +1411,7 @@ FuncDeclaration buildPostBlit(StructDeclaration sd, Scope* sc)\n     }\n \n     // Build our own \"postblit\" which executes a, but only if needed.\n-    if (postblitCalls.dim || (stc & STC.disable))\n+    if (postblitCalls.length || (stc & STC.disable))\n     {\n         //printf(\"Building __fieldPostBlit()\\n\");\n         checkShared();\n@@ -1426,7 +1426,7 @@ FuncDeclaration buildPostBlit(StructDeclaration sd, Scope* sc)\n \n     // create __xpostblit, which is the generated postblit\n     FuncDeclaration xpostblit = null;\n-    switch (sd.postblits.dim)\n+    switch (sd.postblits.length)\n     {\n     case 0:\n         break;"}, {"sha": "c1e1e4d8d24234ba6e6a751318940fe90bb65ef1", "filename": "gcc/d/dmd/cond.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fcond.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fcond.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcond.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -222,7 +222,7 @@ extern (C++) final class StaticForeach : RootObject\n         }\n         else\n         {\n-            assert(rangefe && parameters.dim == 1);\n+            assert(rangefe && parameters.length == 1);\n             return new ForeachRangeStatement(loc, rangefe.op, (*parameters)[0], rangefe.lwr.syntaxCopy(), rangefe.upr.syntaxCopy(), s, loc);\n         }\n     }\n@@ -306,7 +306,7 @@ extern (C++) final class StaticForeach : RootObject\n \n     private void lowerNonArrayAggregate(Scope* sc)\n     {\n-        auto nvars = aggrfe ? aggrfe.parameters.dim : 1;\n+        auto nvars = aggrfe ? aggrfe.parameters.length : 1;\n         auto aloc = aggrfe ? aggrfe.aggr.loc : rangefe.lwr.loc;\n         // We need three sets of foreach loop variables because the\n         // lowering contains three foreach loops.\n@@ -332,7 +332,7 @@ extern (C++) final class StaticForeach : RootObject\n         {\n             foreach (i; 0 .. 2)\n             {\n-                auto e = new Expressions(pparams[0].dim);\n+                auto e = new Expressions(pparams[0].length);\n                 foreach (j, ref elem; *e)\n                 {\n                     auto p = (*pparams[i])[j];"}, {"sha": "ef684ba745ffd0e87de1e962fb87efa4aab2a7bf", "filename": "gcc/d/dmd/constfold.d", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fconstfold.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fconstfold.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -644,7 +644,7 @@ UnionExp Equal(EXP op, const ref Loc loc, Type type, Expression e1, Expression e\n         }\n         else if (ArrayLiteralExp es2 = e2.isArrayLiteralExp())\n         {\n-            cmp = !es2.elements || (0 == es2.elements.dim);\n+            cmp = !es2.elements || (0 == es2.elements.length);\n         }\n         else\n         {\n@@ -660,7 +660,7 @@ UnionExp Equal(EXP op, const ref Loc loc, Type type, Expression e1, Expression e\n         }\n         else if (ArrayLiteralExp es1 = e1.isArrayLiteralExp())\n         {\n-            cmp = !es1.elements || (0 == es1.elements.dim);\n+            cmp = !es1.elements || (0 == es1.elements.length);\n         }\n         else\n         {\n@@ -689,15 +689,15 @@ UnionExp Equal(EXP op, const ref Loc loc, Type type, Expression e1, Expression e\n     {\n         ArrayLiteralExp es1 = e1.isArrayLiteralExp();\n         ArrayLiteralExp es2 = e2.isArrayLiteralExp();\n-        if ((!es1.elements || !es1.elements.dim) && (!es2.elements || !es2.elements.dim))\n+        if ((!es1.elements || !es1.elements.length) && (!es2.elements || !es2.elements.length))\n             cmp = 1; // both arrays are empty\n         else if (!es1.elements || !es2.elements)\n             cmp = 0;\n-        else if (es1.elements.dim != es2.elements.dim)\n+        else if (es1.elements.length != es2.elements.length)\n             cmp = 0;\n         else\n         {\n-            for (size_t i = 0; i < es1.elements.dim; i++)\n+            for (size_t i = 0; i < es1.elements.length; i++)\n             {\n                 auto ee1 = es1[i];\n                 auto ee2 = es2[i];\n@@ -724,7 +724,7 @@ UnionExp Equal(EXP op, const ref Loc loc, Type type, Expression e1, Expression e\n         StringExp es1 = e1.isStringExp();\n         ArrayLiteralExp es2 = e2.isArrayLiteralExp();\n         size_t dim1 = es1.len;\n-        size_t dim2 = es2.elements ? es2.elements.dim : 0;\n+        size_t dim2 = es2.elements ? es2.elements.length : 0;\n         if (dim1 != dim2)\n             cmp = 0;\n         else\n@@ -751,16 +751,16 @@ UnionExp Equal(EXP op, const ref Loc loc, Type type, Expression e1, Expression e\n         StructLiteralExp es2 = e2.isStructLiteralExp();\n         if (es1.sd != es2.sd)\n             cmp = 0;\n-        else if ((!es1.elements || !es1.elements.dim) && (!es2.elements || !es2.elements.dim))\n+        else if ((!es1.elements || !es1.elements.length) && (!es2.elements || !es2.elements.length))\n             cmp = 1; // both arrays are empty\n         else if (!es1.elements || !es2.elements)\n             cmp = 0;\n-        else if (es1.elements.dim != es2.elements.dim)\n+        else if (es1.elements.length != es2.elements.length)\n             cmp = 0;\n         else\n         {\n             cmp = 1;\n-            for (size_t i = 0; i < es1.elements.dim; i++)\n+            for (size_t i = 0; i < es1.elements.length; i++)\n             {\n                 Expression ee1 = (*es1.elements)[i];\n                 Expression ee2 = (*es2.elements)[i];\n@@ -1074,7 +1074,7 @@ UnionExp Cast(const ref Loc loc, Type type, Type to, Expression e1)\n         StructDeclaration sd = tb.toDsymbol(null).isStructDeclaration();\n         assert(sd);\n         auto elements = new Expressions();\n-        for (size_t i = 0; i < sd.fields.dim; i++)\n+        for (size_t i = 0; i < sd.fields.length; i++)\n         {\n             VarDeclaration v = sd.fields[i];\n             UnionExp zero;\n@@ -1110,12 +1110,12 @@ UnionExp ArrayLength(Type type, Expression e1)\n     }\n     else if (ArrayLiteralExp ale = e1.isArrayLiteralExp())\n     {\n-        size_t dim = ale.elements ? ale.elements.dim : 0;\n+        size_t dim = ale.elements ? ale.elements.length : 0;\n         emplaceExp!(IntegerExp)(&ue, loc, dim, type);\n     }\n     else if (AssocArrayLiteralExp ale = e1.isAssocArrayLiteralExp)\n     {\n-        size_t dim = ale.keys.dim;\n+        size_t dim = ale.keys.length;\n         emplaceExp!(IntegerExp)(&ue, loc, dim, type);\n     }\n     else if (e1.type.toBasetype().ty == Tsarray)\n@@ -1183,9 +1183,9 @@ UnionExp Index(Type type, Expression e1, Expression e2, bool indexIsInBounds)\n         uinteger_t i = e2.toInteger();\n         if (ArrayLiteralExp ale = e1.isArrayLiteralExp())\n         {\n-            if (i >= ale.elements.dim)\n+            if (i >= ale.elements.length)\n             {\n-                e1.error(\"array index %llu is out of bounds `%s[0 .. %llu]`\", i, e1.toChars(), cast(ulong) ale.elements.dim);\n+                e1.error(\"array index %llu is out of bounds `%s[0 .. %llu]`\", i, e1.toChars(), cast(ulong) ale.elements.length);\n                 emplaceExp!(ErrorExp)(&ue);\n             }\n             else\n@@ -1206,7 +1206,7 @@ UnionExp Index(Type type, Expression e1, Expression e2, bool indexIsInBounds)\n     {\n         /* Search the keys backwards, in case there are duplicate keys\n          */\n-        for (size_t i = ae.keys.dim; i;)\n+        for (size_t i = ae.keys.length; i;)\n         {\n             i--;\n             Expression ekey = (*ae.keys)[i];\n@@ -1274,7 +1274,7 @@ UnionExp Slice(Type type, Expression e1, Expression lwr, Expression upr)\n         ArrayLiteralExp es1 = e1.isArrayLiteralExp();\n         const uinteger_t ilwr = lwr.toInteger();\n         const uinteger_t iupr = upr.toInteger();\n-        if (sliceBoundsCheck(0, es1.elements.dim, ilwr, iupr))\n+        if (sliceBoundsCheck(0, es1.elements.length, ilwr, iupr))\n             cantExp(ue);\n         else\n         {\n@@ -1318,7 +1318,7 @@ void sliceAssignArrayLiteralFromString(ArrayLiteralExp existingAE, const StringE\n void sliceAssignStringFromArrayLiteral(StringExp existingSE, ArrayLiteralExp newae, size_t firstIndex)\n {\n     assert(existingSE.ownedByCtfe != OwnedBy.code);\n-    foreach (j; 0 .. newae.elements.dim)\n+    foreach (j; 0 .. newae.elements.length)\n     {\n         existingSE.setCodeUnit(firstIndex + j, cast(dchar)newae[j].toInteger());\n     }\n@@ -1383,9 +1383,9 @@ private Expressions* copyElements(Expression e1, Expression e2 = null)\n     {\n         if (!ale.elements)\n             return;\n-        auto d = elems.dim;\n+        auto d = elems.length;\n         elems.append(ale.elements);\n-        foreach (ref el; (*elems)[d .. elems.dim])\n+        foreach (ref el; (*elems)[d .. elems.length])\n         {\n             if (!el)\n                 el = ale.basis;\n@@ -1524,15 +1524,15 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         // [chars] ~ string --> [chars]\n         StringExp es = e2.isStringExp();\n         ArrayLiteralExp ea = e1.isArrayLiteralExp();\n-        size_t len = es.len + ea.elements.dim;\n+        size_t len = es.len + ea.elements.length;\n         auto elems = new Expressions(len);\n-        for (size_t i = 0; i < ea.elements.dim; ++i)\n+        for (size_t i = 0; i < ea.elements.length; ++i)\n         {\n             (*elems)[i] = ea[i];\n         }\n         emplaceExp!(ArrayLiteralExp)(&ue, e1.loc, type, elems);\n         ArrayLiteralExp dest = ue.exp().isArrayLiteralExp();\n-        sliceAssignArrayLiteralFromString(dest, es, ea.elements.dim);\n+        sliceAssignArrayLiteralFromString(dest, es, ea.elements.length);\n         assert(ue.exp().type);\n         return ue;\n     }\n@@ -1541,9 +1541,9 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         // string ~ [chars] --> [chars]\n         StringExp es = e1.isStringExp();\n         ArrayLiteralExp ea = e2.isArrayLiteralExp();\n-        size_t len = es.len + ea.elements.dim;\n+        size_t len = es.len + ea.elements.length;\n         auto elems = new Expressions(len);\n-        for (size_t i = 0; i < ea.elements.dim; ++i)\n+        for (size_t i = 0; i < ea.elements.length; ++i)\n         {\n             (*elems)[es.len + i] = ea[i];\n         }\n@@ -1609,7 +1609,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         e = ue.exp();\n         if (type.toBasetype().ty == Tsarray)\n         {\n-            e.type = t1.nextOf().sarrayOf(elems.dim);\n+            e.type = t1.nextOf().sarrayOf(elems.length);\n         }\n         else\n             e.type = type;\n@@ -1633,7 +1633,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         e = ue.exp();\n         if (type.toBasetype().ty == Tsarray)\n         {\n-            e.type = t1.nextOf().sarrayOf(elems.dim);\n+            e.type = t1.nextOf().sarrayOf(elems.length);\n         }\n         else\n             e.type = type;\n@@ -1651,7 +1651,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         e = ue.exp();\n         if (type.toBasetype().ty == Tsarray)\n         {\n-            e.type = e2.type.sarrayOf(elems.dim);\n+            e.type = e2.type.sarrayOf(elems.length);\n         }\n         else\n             e.type = type;\n@@ -1667,7 +1667,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         e = ue.exp();\n         if (type.toBasetype().ty == Tsarray)\n         {\n-            e.type = e1.type.sarrayOf(elems.dim);\n+            e.type = e1.type.sarrayOf(elems.length);\n         }\n         else\n             e.type = type;"}, {"sha": "d4416abe09784c1d8e2e262c7338bf836e63570c", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -4816,7 +4816,13 @@ final class CParser(AST) : Parser!AST\n         else if (auto tt = t.isTypeTag())\n             tt.mod |= MODFlags.const_;\n         else\n-            t = t.addSTC(STC.const_);\n+        {\n+            /* Ignore const if the result would be const pointer to mutable\n+             */\n+            auto tn = t.nextOf();\n+            if (!tn || tn.isConst())\n+                t = t.addSTC(STC.const_);\n+        }\n         return t;\n     }\n "}, {"sha": "fbe9f0181d488f780401b838b9e1baad329efc71", "filename": "gcc/d/dmd/cppmangle.d", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fcppmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fcppmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -534,10 +534,10 @@ private final class CppMangleVisitor : Visitor\n     {\n         /* <template-args> ::= I <template-arg>+ E\n          */\n-        if (!ti || ti.tiargs.dim <= firstArg)   // could happen if std::basic_string is not a template\n+        if (!ti || ti.tiargs.length <= firstArg)   // could happen if std::basic_string is not a template\n             return false;\n         buf.writeByte('I');\n-        foreach (i; firstArg .. ti.tiargs.dim)\n+        foreach (i; firstArg .. ti.tiargs.length)\n         {\n             TemplateDeclaration td = ti.tempdecl.isTemplateDeclaration();\n             assert(td);\n@@ -556,7 +556,7 @@ private final class CppMangleVisitor : Visitor\n                 buf.writeByte('J');     // argument pack\n \n                 // mangle the rest of the arguments as types\n-                foreach (j; i .. (*ti.tiargs).dim)\n+                foreach (j; i .. (*ti.tiargs).length)\n                 {\n                     Type t = isType((*ti.tiargs)[j]);\n                     assert(t);\n@@ -760,7 +760,7 @@ private final class CppMangleVisitor : Visitor\n             return false;\n         Dsymbol q = getQualifier(ti);\n         const bool inStd = isStd(q) || isStd(this.getTiNamespace(ti));\n-        return inStd && ti.tiargs.dim == 1 && isChar((*ti.tiargs)[0]);\n+        return inStd && ti.tiargs.length == 1 && isChar((*ti.tiargs)[0]);\n     }\n \n     /***\n@@ -771,7 +771,7 @@ private final class CppMangleVisitor : Visitor\n      */\n     bool char_std_char_traits_char(TemplateInstance ti, string st)\n     {\n-        if (ti.tiargs.dim == 2 &&\n+        if (ti.tiargs.length == 2 &&\n             isChar((*ti.tiargs)[0]) &&\n             isChar_traits_char((*ti.tiargs)[1]))\n         {\n@@ -851,7 +851,7 @@ private final class CppMangleVisitor : Visitor\n         if (ti.name == Id.basic_string)\n         {\n             // ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>\n-            if (ti.tiargs.dim == 3 &&\n+            if (ti.tiargs.length == 3 &&\n                 isChar((*ti.tiargs)[0]) &&\n                 isChar_traits_char((*ti.tiargs)[1]) &&\n                 isAllocator_char((*ti.tiargs)[2]))\n@@ -933,7 +933,7 @@ private final class CppMangleVisitor : Visitor\n         else if (s.ident == Id.basic_string)\n         {\n             // ::std::basic_string<char, ::std::char_traits<char>, ::std::allocator<char>>\n-            if (ti.tiargs.dim == 3 &&\n+            if (ti.tiargs.length == 3 &&\n                 isChar((*ti.tiargs)[0]) &&\n                 isChar_traits_char((*ti.tiargs)[1]) &&\n                 isAllocator_char((*ti.tiargs)[2]))\n@@ -1224,7 +1224,7 @@ private final class CppMangleVisitor : Visitor\n         case CppOperator.OpAssign:\n             TemplateDeclaration td = ti.tempdecl.isTemplateDeclaration();\n             assert(td);\n-            assert(ti.tiargs.dim >= 1);\n+            assert(ti.tiargs.length >= 1);\n             TemplateParameter tp = (*td.parameters)[0];\n             TemplateValueParameter tv = tp.isTemplateValueParameter();\n             if (!tv || !tv.valType.isString())\n@@ -2005,14 +2005,14 @@ extern(C++):\n                 this.context.res = (*analyzed_ti.tiargs)[idx];\n                 o.visitObject(this);\n             }\n-            if (analyzed_ti.tiargs.dim > t.tiargs.dim)\n+            if (analyzed_ti.tiargs.length > t.tiargs.length)\n             {\n                 // If the resolved AST has more args than the parse one,\n                 // we have default arguments\n                 auto oparams = (cast(TemplateDeclaration)analyzed_ti.tempdecl).origParameters;\n-                foreach (idx, arg; (*oparams)[t.tiargs.dim .. $])\n+                foreach (idx, arg; (*oparams)[t.tiargs.length .. $])\n                 {\n-                    this.context.res = (*analyzed_ti.tiargs)[idx + t.tiargs.dim];\n+                    this.context.res = (*analyzed_ti.tiargs)[idx + t.tiargs.length];\n \n                     if (auto ttp = arg.isTemplateTypeParameter())\n                         ttp.defaultType.accept(this);"}, {"sha": "1dc1f7d178420337cba2a2b86fe956c1ada65ebd", "filename": "gcc/d/dmd/ctfeexpr.d", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfeexpr.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -62,17 +62,17 @@ extern (C++) final class ClassReferenceExp : Expression\n     {\n         ClassDeclaration cd = originalClass();\n         uint fieldsSoFar = 0;\n-        for (size_t j = 0; j < value.elements.dim; j++)\n+        for (size_t j = 0; j < value.elements.length; j++)\n         {\n-            while (j - fieldsSoFar >= cd.fields.dim)\n+            while (j - fieldsSoFar >= cd.fields.length)\n             {\n-                fieldsSoFar += cd.fields.dim;\n+                fieldsSoFar += cd.fields.length;\n                 cd = cd.baseClass;\n             }\n             VarDeclaration v2 = cd.fields[j - fieldsSoFar];\n             if (fieldoffset == v2.offset && fieldtype.size() == v2.type.size())\n             {\n-                return cast(int)(value.elements.dim - fieldsSoFar - cd.fields.dim + (j - fieldsSoFar));\n+                return cast(int)(value.elements.length - fieldsSoFar - cd.fields.length + (j - fieldsSoFar));\n             }\n         }\n         return -1;\n@@ -84,17 +84,17 @@ extern (C++) final class ClassReferenceExp : Expression\n     {\n         ClassDeclaration cd = originalClass();\n         size_t fieldsSoFar = 0;\n-        for (size_t j = 0; j < value.elements.dim; j++)\n+        for (size_t j = 0; j < value.elements.length; j++)\n         {\n-            while (j - fieldsSoFar >= cd.fields.dim)\n+            while (j - fieldsSoFar >= cd.fields.length)\n             {\n-                fieldsSoFar += cd.fields.dim;\n+                fieldsSoFar += cd.fields.length;\n                 cd = cd.baseClass;\n             }\n             VarDeclaration v2 = cd.fields[j - fieldsSoFar];\n             if (v == v2)\n             {\n-                return cast(int)(value.elements.dim - fieldsSoFar - cd.fields.dim + (j - fieldsSoFar));\n+                return cast(int)(value.elements.length - fieldsSoFar - cd.fields.length + (j - fieldsSoFar));\n             }\n         }\n         return -1;\n@@ -267,7 +267,7 @@ private Expressions* copyLiteralArray(Expressions* oldelems, Expression basis =\n     if (!oldelems)\n         return oldelems;\n     incArrayAllocs();\n-    auto newelems = new Expressions(oldelems.dim);\n+    auto newelems = new Expressions(oldelems.length);\n     foreach (i, el; *oldelems)\n     {\n         (*newelems)[i] = copyLiteral(el ? el : basis).copy();\n@@ -318,7 +318,7 @@ UnionExp copyLiteral(Expression e)\n          * an int[4] array can be initialized with a single int.\n          */\n         auto oldelems = sle.elements;\n-        auto newelems = new Expressions(oldelems.dim);\n+        auto newelems = new Expressions(oldelems.length);\n         foreach (i, ref el; *newelems)\n         {\n             // We need the struct definition to detect block assignment\n@@ -566,12 +566,12 @@ uinteger_t resolveArrayLength(Expression e)\n         case EXP.arrayLiteral:\n         {\n             const ale = e.isArrayLiteralExp();\n-            return ale.elements ? ale.elements.dim : 0;\n+            return ale.elements ? ale.elements.length : 0;\n         }\n \n         case EXP.assocArrayLiteral:\n         {\n-            return e.isAssocArrayLiteralExp().keys.dim;\n+            return e.isAssocArrayLiteralExp().keys.length;\n         }\n \n         default:\n@@ -1312,15 +1312,15 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n         // For structs, we only need to return 0 or 1 (< and > aren't legal).\n         if (es1.sd != es2.sd)\n             return 1;\n-        else if ((!es1.elements || !es1.elements.dim) && (!es2.elements || !es2.elements.dim))\n+        else if ((!es1.elements || !es1.elements.length) && (!es2.elements || !es2.elements.length))\n             return 0; // both arrays are empty\n         else if (!es1.elements || !es2.elements)\n             return 1;\n-        else if (es1.elements.dim != es2.elements.dim)\n+        else if (es1.elements.length != es2.elements.length)\n             return 1;\n         else\n         {\n-            foreach (size_t i; 0 .. es1.elements.dim)\n+            foreach (size_t i; 0 .. es1.elements.length)\n             {\n                 Expression ee1 = (*es1.elements)[i];\n                 Expression ee2 = (*es2.elements)[i];\n@@ -1344,8 +1344,8 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n     {\n         AssocArrayLiteralExp es1 = e1.isAssocArrayLiteralExp();\n         AssocArrayLiteralExp es2 = e2.isAssocArrayLiteralExp();\n-        size_t dim = es1.keys.dim;\n-        if (es2.keys.dim != dim)\n+        size_t dim = es1.keys.length;\n+        if (es2.keys.length != dim)\n             return 1;\n         bool* used = cast(bool*)mem.xmalloc(bool.sizeof * dim);\n         memset(used, 0, bool.sizeof * dim);\n@@ -1376,11 +1376,11 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n     }\n     else if (e1.op == EXP.assocArrayLiteral && e2.op == EXP.null_)\n     {\n-        return e1.isAssocArrayLiteralExp.keys.dim != 0;\n+        return e1.isAssocArrayLiteralExp.keys.length != 0;\n     }\n     else if (e1.op == EXP.null_ && e2.op == EXP.assocArrayLiteral)\n     {\n-        return e2.isAssocArrayLiteralExp.keys.dim != 0;\n+        return e2.isAssocArrayLiteralExp.keys.length != 0;\n     }\n \n     error(loc, \"CTFE internal error: bad compare of `%s` and `%s`\", e1.toChars(), e2.toChars());\n@@ -1461,12 +1461,12 @@ UnionExp ctfeCat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         // [chars] ~ string => string (only valid for CTFE)\n         StringExp es1 = e2.isStringExp();\n         ArrayLiteralExp es2 = e1.isArrayLiteralExp();\n-        const len = es1.len + es2.elements.dim;\n+        const len = es1.len + es2.elements.length;\n         const sz = es1.sz;\n         void* s = mem.xmalloc((len + 1) * sz);\n         const data1 = es1.peekData();\n-        memcpy(cast(char*)s + sz * es2.elements.dim, data1.ptr, data1.length);\n-        foreach (size_t i; 0 .. es2.elements.dim)\n+        memcpy(cast(char*)s + sz * es2.elements.length, data1.ptr, data1.length);\n+        foreach (size_t i; 0 .. es2.elements.length)\n         {\n             Expression es2e = (*es2.elements)[i];\n             if (es2e.op != EXP.int64)\n@@ -1491,12 +1491,12 @@ UnionExp ctfeCat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         // Concatenate the strings\n         StringExp es1 = e1.isStringExp();\n         ArrayLiteralExp es2 = e2.isArrayLiteralExp();\n-        const len = es1.len + es2.elements.dim;\n+        const len = es1.len + es2.elements.length;\n         const sz = es1.sz;\n         void* s = mem.xmalloc((len + 1) * sz);\n         auto slice = es1.peekData();\n         memcpy(s, slice.ptr, slice.length);\n-        foreach (size_t i; 0 .. es2.elements.dim)\n+        foreach (size_t i; 0 .. es2.elements.length)\n         {\n             Expression es2e = (*es2.elements)[i];\n             if (es2e.op != EXP.int64)\n@@ -1523,7 +1523,7 @@ UnionExp ctfeCat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         ArrayLiteralExp es2 = e2.isArrayLiteralExp();\n         emplaceExp!(ArrayLiteralExp)(&ue, es1.loc, type, copyLiteralArray(es1.elements));\n         es1 = ue.exp().isArrayLiteralExp();\n-        es1.elements.insert(es1.elements.dim, copyLiteralArray(es2.elements));\n+        es1.elements.insert(es1.elements.length, copyLiteralArray(es2.elements));\n         return ue;\n     }\n     if (e1.op == EXP.arrayLiteral && e2.op == EXP.null_ && t1.nextOf().equals(t2.nextOf()))\n@@ -1549,7 +1549,7 @@ Expression findKeyInAA(const ref Loc loc, AssocArrayLiteralExp ae, Expression e2\n {\n     /* Search the keys backwards, in case there are duplicate keys\n      */\n-    for (size_t i = ae.keys.dim; i;)\n+    for (size_t i = ae.keys.length; i;)\n     {\n         --i;\n         Expression ekey = (*ae.keys)[i];\n@@ -1583,9 +1583,9 @@ Expression ctfeIndex(UnionExp* pue, const ref Loc loc, Type type, Expression e1,\n \n     if (auto ale = e1.isArrayLiteralExp())\n     {\n-        if (indx >= ale.elements.dim)\n+        if (indx >= ale.elements.length)\n         {\n-            error(loc, \"array index %llu is out of bounds `%s[0 .. %llu]`\", indx, e1.toChars(), cast(ulong)ale.elements.dim);\n+            error(loc, \"array index %llu is out of bounds `%s[0 .. %llu]`\", indx, e1.toChars(), cast(ulong)ale.elements.length);\n             return CTFEExp.cantexp;\n         }\n         Expression e = (*ale.elements)[cast(size_t)indx];\n@@ -1685,9 +1685,9 @@ void assignInPlace(Expression dest, Expression src)\n         newelems = src.isStructLiteralExp().elements;\n         auto sd = dest.isStructLiteralExp().sd;\n         const nfields = sd.nonHiddenFields();\n-        const nvthis = sd.fields.dim - nfields;\n-        if (nvthis && oldelems.dim >= nfields && oldelems.dim < newelems.dim)\n-            foreach (_; 0 .. newelems.dim - oldelems.dim)\n+        const nvthis = sd.fields.length - nfields;\n+        if (nvthis && oldelems.length >= nfields && oldelems.length < newelems.length)\n+            foreach (_; 0 .. newelems.length - oldelems.length)\n                 oldelems.push(null);\n     }\n     else if (dest.op == EXP.arrayLiteral && src.op == EXP.arrayLiteral)\n@@ -1715,8 +1715,8 @@ void assignInPlace(Expression dest, Expression src)\n         printf(\"invalid op %d %d\\n\", src.op, dest.op);\n         assert(0);\n     }\n-    assert(oldelems.dim == newelems.dim);\n-    foreach (size_t i; 0 .. oldelems.dim)\n+    assert(oldelems.length == newelems.length);\n+    foreach (size_t i; 0 .. oldelems.length)\n     {\n         Expression e = (*newelems)[i];\n         Expression o = (*oldelems)[i];\n@@ -1744,7 +1744,7 @@ Expression assignAssocArrayElement(const ref Loc loc, AssocArrayLiteralExp aae,\n     Expressions* keysx = aae.keys;\n     Expressions* valuesx = aae.values;\n     int updated = 0;\n-    for (size_t j = valuesx.dim; j;)\n+    for (size_t j = valuesx.length; j;)\n     {\n         j--;\n         Expression ekey = (*aae.keys)[j];\n@@ -2029,13 +2029,13 @@ void showCtfeExpr(Expression e, int level = 0)\n     if (elements)\n     {\n         size_t fieldsSoFar = 0;\n-        for (size_t i = 0; i < elements.dim; i++)\n+        for (size_t i = 0; i < elements.length; i++)\n         {\n             Expression z = null;\n             VarDeclaration v = null;\n             if (i > 15)\n             {\n-                printf(\"...(total %d elements)\\n\", cast(int)elements.dim);\n+                printf(\"...(total %d elements)\\n\", cast(int)elements.length);\n                 return;\n             }\n             if (sd)\n@@ -2045,18 +2045,18 @@ void showCtfeExpr(Expression e, int level = 0)\n             }\n             else if (cd)\n             {\n-                while (i - fieldsSoFar >= cd.fields.dim)\n+                while (i - fieldsSoFar >= cd.fields.length)\n                 {\n-                    fieldsSoFar += cd.fields.dim;\n+                    fieldsSoFar += cd.fields.length;\n                     cd = cd.baseClass;\n                     for (int j = level; j > 0; --j)\n                         printf(\" \");\n                     printf(\" BASE CLASS: %s\\n\", cd.toChars());\n                 }\n                 v = cd.fields[i - fieldsSoFar];\n-                assert((elements.dim + i) >= (fieldsSoFar + cd.fields.dim));\n-                size_t indx = (elements.dim - fieldsSoFar) - cd.fields.dim + i;\n-                assert(indx < elements.dim);\n+                assert((elements.length + i) >= (fieldsSoFar + cd.fields.length));\n+                size_t indx = (elements.length - fieldsSoFar) - cd.fields.length + i;\n+                assert(indx < elements.length);\n                 z = (*elements)[indx];\n             }\n             if (!z)\n@@ -2108,8 +2108,8 @@ UnionExp voidInitLiteral(Type t, VarDeclaration var)\n     else if (t.ty == Tstruct)\n     {\n         TypeStruct ts = cast(TypeStruct)t;\n-        auto exps = new Expressions(ts.sym.fields.dim);\n-        foreach (size_t i;  0 .. ts.sym.fields.dim)\n+        auto exps = new Expressions(ts.sym.fields.length);\n+        foreach (size_t i;  0 .. ts.sym.fields.length)\n         {\n             (*exps)[i] = voidInitLiteral(ts.sym.fields[i].type, ts.sym.fields[i]).copy();\n         }"}, {"sha": "02bf6cf3495a6a4a5f09f2aca9dd47a036627b8e", "filename": "gcc/d/dmd/dcast.d", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -192,7 +192,7 @@ Expression implicitCastTo(Expression e, Scope* sc, Type t)\n             {\n                 Type tb = t.toBasetype();\n                 Type tx = (tb.ty == Tsarray)\n-                    ? tb.nextOf().sarrayOf(ale.elements ? ale.elements.dim : 0)\n+                    ? tb.nextOf().sarrayOf(ale.elements ? ale.elements.length : 0)\n                     : tb.nextOf().arrayOf();\n                 se.e1 = ale.implicitCastTo(sc, tx);\n             }\n@@ -333,7 +333,7 @@ MATCH implicitConvTo(Expression e, Type t)\n     {\n         const size_t nparams = tf.parameterList.length;\n         const size_t j = tf.isDstyleVariadic(); // if TypeInfoArray was prepended\n-        foreach (const i; j .. args.dim)\n+        foreach (const i; j .. args.length)\n         {\n             Expression earg = (*args)[i];\n             Type targ = earg.type.toBasetype();\n@@ -749,12 +749,12 @@ MATCH implicitConvTo(Expression e, Type t)\n \n             if (auto tsa = tb.isTypeSArray())\n             {\n-                if (e.elements.dim != tsa.dim.toInteger())\n+                if (e.elements.length != tsa.dim.toInteger())\n                     result = MATCH.nomatch;\n             }\n \n             Type telement = tb.nextOf();\n-            if (!e.elements.dim)\n+            if (!e.elements.length)\n             {\n                 if (typen.ty != Tvoid)\n                     result = typen.implicitConvTo(telement);\n@@ -767,7 +767,7 @@ MATCH implicitConvTo(Expression e, Type t)\n                     if (m < result)\n                         result = m;\n                 }\n-                for (size_t i = 0; i < e.elements.dim; i++)\n+                for (size_t i = 0; i < e.elements.length; i++)\n                 {\n                     Expression el = (*e.elements)[i];\n                     if (result == MATCH.nomatch)\n@@ -792,7 +792,7 @@ MATCH implicitConvTo(Expression e, Type t)\n             TypeVector tv = tb.isTypeVector();\n             TypeSArray tbase = tv.basetype.isTypeSArray();\n             assert(tbase);\n-            const edim = e.elements.dim;\n+            const edim = e.elements.length;\n             const tbasedim = tbase.dim.toInteger();\n             if (edim > tbasedim)\n             {\n@@ -1233,7 +1233,7 @@ MATCH implicitConvTo(Expression e, Type t)\n          */\n         if (!e.member && e.arguments)\n         {\n-            for (size_t i = 0; i < e.arguments.dim; ++i)\n+            for (size_t i = 0; i < e.arguments.length; ++i)\n             {\n                 Expression earg = (*e.arguments)[i];\n                 if (!earg) // https://issues.dlang.org/show_bug.cgi?id=14853\n@@ -1284,7 +1284,7 @@ MATCH implicitConvTo(Expression e, Type t)\n                 {\n                     extern (C++) static bool convertible(Expression e, ClassDeclaration cd, MOD mod)\n                     {\n-                        for (size_t i = 0; i < cd.fields.dim; i++)\n+                        for (size_t i = 0; i < cd.fields.length; i++)\n                         {\n                             VarDeclaration v = cd.fields[i];\n                             Initializer _init = v._init;\n@@ -2101,7 +2101,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n         {\n             OverExp eo = e.e1.isOverExp();\n             FuncDeclaration f = null;\n-            for (size_t i = 0; i < eo.vars.a.dim; i++)\n+            for (size_t i = 0; i < eo.vars.a.length; i++)\n             {\n                 auto s = eo.vars.a[i];\n                 auto f2 = s.isFuncDeclaration();\n@@ -2177,7 +2177,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n         TupleExp te = e.copy().isTupleExp();\n         te.e0 = e.e0 ? e.e0.copy() : null;\n         te.exps = e.exps.copy();\n-        for (size_t i = 0; i < te.exps.dim; i++)\n+        for (size_t i = 0; i < te.exps.length; i++)\n         {\n             Expression ex = (*te.exps)[i];\n             ex = ex.castTo(sc, totuple ? (*totuple.arguments)[i].type : t);\n@@ -2239,15 +2239,15 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n             {\n                 if (auto tsa = tb.isTypeSArray())\n                 {\n-                    if (e.elements.dim != tsa.dim.toInteger())\n+                    if (e.elements.length != tsa.dim.toInteger())\n                         goto L1;\n                 }\n \n                 ae = e.copy().isArrayLiteralExp();\n                 if (e.basis)\n                     ae.basis = e.basis.castTo(sc, tb.nextOf());\n                 ae.elements = e.elements.copy();\n-                for (size_t i = 0; i < e.elements.dim; i++)\n+                for (size_t i = 0; i < e.elements.length; i++)\n                 {\n                     Expression ex = (*e.elements)[i];\n                     if (!ex)\n@@ -2274,7 +2274,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n             TypeVector tv = tb.isTypeVector();\n             TypeSArray tbase = tv.basetype.isTypeSArray();\n             assert(tbase.ty == Tsarray);\n-            const edim = e.elements.dim;\n+            const edim = e.elements.length;\n             const tbasedim = tbase.dim.toInteger();\n             if (edim > tbasedim)\n                 goto L1;\n@@ -2322,8 +2322,8 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n             AssocArrayLiteralExp ae = e.copy().isAssocArrayLiteralExp();\n             ae.keys = e.keys.copy();\n             ae.values = e.values.copy();\n-            assert(e.keys.dim == e.values.dim);\n-            for (size_t i = 0; i < e.keys.dim; i++)\n+            assert(e.keys.length == e.values.length);\n+            for (size_t i = 0; i < e.keys.length; i++)\n             {\n                 Expression ex = (*e.values)[i];\n                 ex = ex.castTo(sc, tb.nextOf());\n@@ -2637,7 +2637,7 @@ Expression inferType(Expression e, Type t, int flag = 0)\n             Type tn = tb.nextOf();\n             if (ale.basis)\n                 ale.basis = inferType(ale.basis, tn, flag);\n-            for (size_t i = 0; i < ale.elements.dim; i++)\n+            for (size_t i = 0; i < ale.elements.length; i++)\n             {\n                 if (Expression e = (*ale.elements)[i])\n                 {\n@@ -2656,15 +2656,15 @@ Expression inferType(Expression e, Type t, int flag = 0)\n         {\n             Type ti = taa.index;\n             Type tv = taa.nextOf();\n-            for (size_t i = 0; i < aale.keys.dim; i++)\n+            for (size_t i = 0; i < aale.keys.length; i++)\n             {\n                 if (Expression e = (*aale.keys)[i])\n                 {\n                     e = inferType(e, ti, flag);\n                     (*aale.keys)[i] = e;\n                 }\n             }\n-            for (size_t i = 0; i < aale.values.dim; i++)\n+            for (size_t i = 0; i < aale.values.length; i++)\n             {\n                 if (Expression e = (*aale.values)[i])\n                 {\n@@ -2772,7 +2772,7 @@ Expression scaleFactor(BinExp be, Scope* sc)\n  */\n private bool isVoidArrayLiteral(Expression e, Type other)\n {\n-    while (e.op == EXP.arrayLiteral && e.type.ty == Tarray && (e.isArrayLiteralExp().elements.dim == 1))\n+    while (e.op == EXP.arrayLiteral && e.type.ty == Tarray && (e.isArrayLiteralExp().elements.length == 1))\n     {\n         auto ale = e.isArrayLiteralExp();\n         e = ale[0];\n@@ -2784,7 +2784,7 @@ private bool isVoidArrayLiteral(Expression e, Type other)\n     if (other.ty != Tsarray && other.ty != Tarray)\n         return false;\n     Type t = e.type;\n-    return (e.op == EXP.arrayLiteral && t.ty == Tarray && t.nextOf().ty == Tvoid && e.isArrayLiteralExp().elements.dim == 0);\n+    return (e.op == EXP.arrayLiteral && t.ty == Tarray && t.nextOf().ty == Tvoid && e.isArrayLiteralExp().elements.length == 0);\n }\n \n /**"}, {"sha": "fc49b21048001a33c42c58decadf7fe383cd5bc9", "filename": "gcc/d/dmd/dclass.d", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdclass.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdclass.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdclass.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -74,10 +74,10 @@ extern (C++) struct BaseClass\n \n         //printf(\"BaseClass.fillVtbl(this='%s', cd='%s')\\n\", sym.toChars(), cd.toChars());\n         if (vtbl)\n-            vtbl.setDim(sym.vtbl.dim);\n+            vtbl.setDim(sym.vtbl.length);\n \n         // first entry is ClassInfo reference\n-        for (size_t j = sym.vtblOffset(); j < sym.vtbl.dim; j++)\n+        for (size_t j = sym.vtblOffset(); j < sym.vtbl.length; j++)\n         {\n             FuncDeclaration ifd = sym.vtbl[j].isFuncDeclaration();\n \n@@ -113,7 +113,7 @@ extern (C++) struct BaseClass\n             BaseClass* b = &baseInterfaces[i];\n             BaseClass* b2 = sym.interfaces[i];\n \n-            assert(b2.vtbl.dim == 0); // should not be filled yet\n+            assert(b2.vtbl.length == 0); // should not be filled yet\n             memcpy(b, b2, BaseClass.sizeof);\n \n             if (i) // single inheritance is i==0\n@@ -217,7 +217,7 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n \n         this.members = members;\n \n-        //printf(\"ClassDeclaration(%s), dim = %d\\n\", ident.toChars(), this.baseclasses.dim);\n+        //printf(\"ClassDeclaration(%s), dim = %d\\n\", ident.toChars(), this.baseclasses.length);\n \n         // For forward references\n         type = new TypeClass(this);\n@@ -390,8 +390,8 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n \n         cd.storage_class |= storage_class;\n \n-        cd.baseclasses.setDim(this.baseclasses.dim);\n-        for (size_t i = 0; i < cd.baseclasses.dim; i++)\n+        cd.baseclasses.setDim(this.baseclasses.length);\n+        for (size_t i = 0; i < cd.baseclasses.length; i++)\n         {\n             BaseClass* b = (*this.baseclasses)[i];\n             auto b2 = new BaseClass(b.type.syntaxCopy());\n@@ -424,7 +424,7 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n         if (!cd)\n             return false;\n         //printf(\"ClassDeclaration.isBaseOf2(this = '%s', cd = '%s')\\n\", toChars(), cd.toChars());\n-        for (size_t i = 0; i < cd.baseclasses.dim; i++)\n+        for (size_t i = 0; i < cd.baseclasses.length; i++)\n         {\n             BaseClass* b = (*cd.baseclasses)[i];\n             if (b.sym == this || isBaseOf2(b.sym))\n@@ -610,7 +610,7 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n                 if (!b.sym.alignsize)\n                     b.sym.alignsize = target.ptrsize;\n                 alignmember(structalign_t(cast(ushort)b.sym.alignsize), b.sym.alignsize, &offset);\n-                assert(bi < vtblInterfaces.dim);\n+                assert(bi < vtblInterfaces.length);\n \n                 BaseClass* bv = (*vtblInterfaces)[bi];\n                 if (b.sym.interfaces.length == 0)\n@@ -879,7 +879,7 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n             return 0;\n         }\n \n-        for (size_t i = 0; i < members.dim; i++)\n+        for (size_t i = 0; i < members.length; i++)\n         {\n             auto s = (*members)[i];\n             if (s.apply(&func))\n@@ -917,7 +917,7 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n                 return 0;\n             }\n \n-            for (size_t i = 0; i < members.dim; i++)\n+            for (size_t i = 0; i < members.length; i++)\n             {\n                 auto s = (*members)[i];\n                 s.apply(&virtualSemantic);\n@@ -926,7 +926,7 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n \n         /* Finally, check the vtbl[]\n          */\n-        foreach (i; 1 .. vtbl.dim)\n+        foreach (i; 1 .. vtbl.length)\n         {\n             auto fd = vtbl[i].isFuncDeclaration();\n             //if (fd) printf(\"\\tvtbl[%d] = [%s] %s\\n\", i, fd.loc.toChars(), fd.toPrettyChars());\n@@ -980,7 +980,7 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n     {\n         if (!vtblsym)\n         {\n-            auto vtype = Type.tvoidptr.immutableOf().sarrayOf(vtbl.dim);\n+            auto vtype = Type.tvoidptr.immutableOf().sarrayOf(vtbl.length);\n             auto var = new VarDeclaration(loc, vtype, Identifier.idPool(\"__vtbl\"), null, STC.immutable_ | STC.static_);\n             var.addMember(null, this);\n             var.isdataseg = 1;\n@@ -991,6 +991,11 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n         return vtblsym;\n     }\n \n+    extern (D) final bool isErrorException()\n+    {\n+        return errorException && (this == errorException || errorException.isBaseOf(this, null));\n+    }\n+\n     override final inout(ClassDeclaration) isClassDeclaration() inout @nogc nothrow pure @safe\n     {\n         return this;"}, {"sha": "3d0752c1d8bf737fca1c11fb406b5048a7ee151b", "filename": "gcc/d/dmd/declaration.d", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -66,7 +66,7 @@ bool checkFrameAccess(Loc loc, Scope* sc, AggregateDeclaration ad, size_t iStart\n     }\n \n     bool result = false;\n-    for (size_t i = iStart; i < ad.fields.dim; i++)\n+    for (size_t i = iStart; i < ad.fields.length; i++)\n     {\n         VarDeclaration vd = ad.fields[i];\n         Type tb = vd.type.baseElemOf();\n@@ -297,7 +297,7 @@ extern (C++) abstract class Declaration : Dsymbol\n                 {\n                     auto sd = p.isStructDeclaration();\n                     assert(sd);\n-                    for (size_t i = 0; i < sd.fields.dim; i++)\n+                    for (size_t i = 0; i < sd.fields.length; i++)\n                     {\n                         auto structField = sd.fields[i];\n                         if (structField.overlapped)\n@@ -606,7 +606,7 @@ extern (C++) final class TupleDeclaration : Declaration\n         {\n             /* It's only a type tuple if all the Object's are types\n              */\n-            for (size_t i = 0; i < objects.dim; i++)\n+            for (size_t i = 0; i < objects.length; i++)\n             {\n                 RootObject o = (*objects)[i];\n                 if (o.dyncast() != DYNCAST.type)\n@@ -619,10 +619,10 @@ extern (C++) final class TupleDeclaration : Declaration\n             /* We know it's a type tuple, so build the TypeTuple\n              */\n             Types* types = cast(Types*)objects;\n-            auto args = new Parameters(objects.dim);\n+            auto args = new Parameters(objects.length);\n             OutBuffer buf;\n             int hasdeco = 1;\n-            for (size_t i = 0; i < types.dim; i++)\n+            for (size_t i = 0; i < types.length; i++)\n             {\n                 Type t = (*types)[i];\n                 //printf(\"type = %s\\n\", t.toChars());\n@@ -653,7 +653,7 @@ extern (C++) final class TupleDeclaration : Declaration\n     override Dsymbol toAlias2()\n     {\n         //printf(\"TupleDeclaration::toAlias2() '%s' objects = %s\\n\", toChars(), objects.toChars());\n-        for (size_t i = 0; i < objects.dim; i++)\n+        for (size_t i = 0; i < objects.length; i++)\n         {\n             RootObject o = (*objects)[i];\n             if (Dsymbol s = isDsymbol(o))\n@@ -1219,7 +1219,7 @@ extern (C++) class VarDeclaration : Declaration\n             fieldState.offset = ad.structsize; // https://issues.dlang.org/show_bug.cgi?id=13613\n             return;\n         }\n-        for (size_t i = 0; i < ad.fields.dim; i++)\n+        for (size_t i = 0; i < ad.fields.length; i++)\n         {\n             if (ad.fields[i] == this)\n             {"}, {"sha": "461f44131c3e45c87f76cb17b328211ea5188c44", "filename": "gcc/d/dmd/delegatize.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdelegatize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdelegatize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdelegatize.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -96,7 +96,7 @@ private void lambdaSetParent(Expression e, FuncDeclaration fd)\n             if (!vd || !pfd)\n                 return;\n             // move to fd's closure when applicable\n-            foreach (i; 0 .. pfd.closureVars.dim)\n+            foreach (i; 0 .. pfd.closureVars.length)\n             {\n                 if (vd == pfd.closureVars[i])\n                 {"}, {"sha": "926186bc4a8f04d01669c6eb48452e7279fc6574", "filename": "gcc/d/dmd/denum.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdenum.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdenum.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdenum.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -88,7 +88,7 @@ extern (C++) final class EnumDeclaration : ScopeDsymbol\n         version (none)\n         {\n             printf(\"EnumDeclaration::addMember() %s\\n\", toChars());\n-            for (size_t i = 0; i < members.dim; i++)\n+            for (size_t i = 0; i < members.length; i++)\n             {\n                 EnumMember em = (*members)[i].isEnumMember();\n                 printf(\"    member %s\\n\", em.toChars());\n@@ -191,7 +191,7 @@ extern (C++) final class EnumDeclaration : ScopeDsymbol\n             return handleErrors();\n         }\n \n-        foreach (const i; 0 .. members.dim)\n+        foreach (const i; 0 .. members.length)\n         {\n             EnumMember em = (*members)[i].isEnumMember();\n             if (em)"}, {"sha": "1104005b1acb4812e3cc7c4039b675757c2eab43", "filename": "gcc/d/dmd/dimport.d", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdimport.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdimport.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdimport.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -114,7 +114,7 @@ extern (C++) final class Import : Dsymbol\n         assert(!s);\n         auto si = new Import(loc, packages, id, aliasId, isstatic);\n         si.comment = comment;\n-        for (size_t i = 0; i < names.dim; i++)\n+        for (size_t i = 0; i < names.length; i++)\n         {\n             si.addAlias(names[i], aliases[i]);\n         }\n@@ -241,11 +241,11 @@ extern (C++) final class Import : Dsymbol\n         mod.checkImportDeprecation(loc, sc);\n         if (sc.explicitVisibility)\n             visibility = sc.visibility;\n-        if (!isstatic && !aliasId && !names.dim)\n+        if (!isstatic && !aliasId && !names.length)\n             sc.scopesym.importScope(mod, visibility);\n         // Enable access to pkgs/mod as soon as posible, because compiler\n         // can traverse them before the import gets semantic (Issue: 21501)\n-        if (!aliasId && !names.dim)\n+        if (!aliasId && !names.length)\n             addPackageAccess(sc.scopesym);\n     }\n \n@@ -296,14 +296,14 @@ extern (C++) final class Import : Dsymbol\n     override void addMember(Scope* sc, ScopeDsymbol sd)\n     {\n         //printf(\"Import.addMember(this=%s, sd=%s, sc=%p)\\n\", toChars(), sd.toChars(), sc);\n-        if (names.dim == 0)\n+        if (names.length == 0)\n             return Dsymbol.addMember(sc, sd);\n         if (aliasId)\n             Dsymbol.addMember(sc, sd);\n         /* Instead of adding the import to sd's symbol table,\n          * add each of the alias=name pairs\n          */\n-        for (size_t i = 0; i < names.dim; i++)\n+        for (size_t i = 0; i < names.length; i++)\n         {\n             Identifier name = names[i];\n             Identifier _alias = aliases[i];\n@@ -320,7 +320,7 @@ extern (C++) final class Import : Dsymbol\n     override void setScope(Scope* sc)\n     {\n         Dsymbol.setScope(sc);\n-        if (aliasdecls.dim)\n+        if (aliasdecls.length)\n         {\n             if (!mod)\n                 importAll(sc);"}, {"sha": "e504cb4879fdb70b630182264e68c42d17b3a671", "filename": "gcc/d/dmd/dinterpret.d", "status": "modified", "additions": 69, "deletions": 67, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdinterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdinterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -282,7 +282,7 @@ private:\n public:\n     extern (C++) size_t stackPointer()\n     {\n-        return values.dim;\n+        return values.length;\n     }\n \n     // The current value of 'this', or NULL if none\n@@ -308,12 +308,12 @@ public:\n \n     extern (C++) void endFrame()\n     {\n-        size_t oldframe = cast(size_t)frames[frames.dim - 1];\n-        localThis = savedThis[savedThis.dim - 1];\n+        size_t oldframe = cast(size_t)frames[frames.length - 1];\n+        localThis = savedThis[savedThis.length - 1];\n         popAll(framepointer);\n         framepointer = oldframe;\n-        frames.setDim(frames.dim - 1);\n-        savedThis.setDim(savedThis.dim - 1);\n+        frames.setDim(frames.length - 1);\n+        savedThis.setDim(savedThis.length - 1);\n     }\n \n     extern (C++) bool isInCurrentFrame(VarDeclaration v)\n@@ -328,7 +328,7 @@ public:\n         //printf(\"getValue() %s\\n\", v.toChars());\n         if ((v.isDataseg() || v.storage_class & STC.manifest) && !v.isCTFE())\n         {\n-            assert(v.ctfeAdrOnStack < globalValues.dim);\n+            assert(v.ctfeAdrOnStack < globalValues.length);\n             return globalValues[v.ctfeAdrOnStack];\n         }\n         assert(v.ctfeAdrOnStack < stackPointer());\n@@ -354,7 +354,7 @@ public:\n             return;\n         }\n         savedId.push(cast(void*)cast(size_t)v.ctfeAdrOnStack);\n-        v.ctfeAdrOnStack = cast(uint)values.dim;\n+        v.ctfeAdrOnStack = cast(uint)values.length;\n         vars.push(v);\n         values.push(null);\n     }\n@@ -365,7 +365,7 @@ public:\n         assert(!v.isReference());\n         const oldid = v.ctfeAdrOnStack;\n         v.ctfeAdrOnStack = cast(uint)cast(size_t)savedId[oldid];\n-        if (v.ctfeAdrOnStack == values.dim - 1)\n+        if (v.ctfeAdrOnStack == values.length - 1)\n         {\n             values.pop();\n             vars.pop();\n@@ -377,8 +377,8 @@ public:\n     {\n         if (stackPointer() > maxStackPointer)\n             maxStackPointer = stackPointer();\n-        assert(values.dim >= stackpointer);\n-        for (size_t i = stackpointer; i < values.dim; ++i)\n+        assert(values.length >= stackpointer);\n+        for (size_t i = stackpointer; i < values.length; ++i)\n         {\n             VarDeclaration v = vars[i];\n             v.ctfeAdrOnStack = cast(uint)cast(size_t)savedId[i];\n@@ -391,7 +391,7 @@ public:\n     extern (C++) void saveGlobalConstant(VarDeclaration v, Expression e)\n     {\n         assert(v._init && (v.isConst() || v.isImmutable() || v.storage_class & STC.manifest) && !v.isCTFE());\n-        v.ctfeAdrOnStack = cast(uint)globalValues.dim;\n+        v.ctfeAdrOnStack = cast(uint)globalValues.length;\n         globalValues.push(copyRegionExp(e));\n     }\n }\n@@ -444,7 +444,7 @@ private Expression interpretFunction(UnionExp* pue, FuncDeclaration fd, InterSta\n \n     auto tf = fd.type.toBasetype().isTypeFunction();\n     if (tf.parameterList.varargs != VarArg.none && arguments &&\n-        ((fd.parameters && arguments.dim != fd.parameters.dim) || (!fd.parameters && arguments.dim)))\n+        ((fd.parameters && arguments.length != fd.parameters.length) || (!fd.parameters && arguments.length)))\n     {\n         fd.error(\"C-style variadic functions are not yet implemented in CTFE\");\n         return CTFEExp.cantexp;\n@@ -467,8 +467,8 @@ private Expression interpretFunction(UnionExp* pue, FuncDeclaration fd, InterSta\n \n     // Place to hold all the arguments to the function while\n     // we are evaluating them.\n-    size_t dim = arguments ? arguments.dim : 0;\n-    assert((fd.parameters ? fd.parameters.dim : 0) == dim);\n+    size_t dim = arguments ? arguments.length : 0;\n+    assert((fd.parameters ? fd.parameters.length : 0) == dim);\n \n     /* Evaluate all the arguments to the function,\n      * store the results in eargs[]\n@@ -827,7 +827,7 @@ public:\n         if (istate.start == s)\n             istate.start = null;\n \n-        const dim = s.statements ? s.statements.dim : 0;\n+        const dim = s.statements ? s.statements.length : 0;\n         foreach (i; 0 .. dim)\n         {\n             Statement sx = (*s.statements)[i];\n@@ -850,7 +850,7 @@ public:\n         if (istate.start == s)\n             istate.start = null;\n \n-        const dim = s.statements ? s.statements.dim : 0;\n+        const dim = s.statements ? s.statements.length : 0;\n         foreach (i; 0 .. dim)\n         {\n             Statement sx = (*s.statements)[i];\n@@ -1034,7 +1034,7 @@ public:\n             result = interpret(pue, s.exp, istate, CTFEGoal.LValue);\n             return;\n         }\n-        if (tf.next && tf.next.ty == Tdelegate && istate.fd.closureVars.dim > 0)\n+        if (tf.next && tf.next.ty == Tdelegate && istate.fd.closureVars.length > 0)\n         {\n             // To support this, we need to copy all the closure vars\n             // into the delegate literal.\n@@ -1521,11 +1521,6 @@ public:\n         result = e;\n     }\n \n-    static bool isAnErrorException(ClassDeclaration cd)\n-    {\n-        return cd == ClassDeclaration.errorException || ClassDeclaration.errorException.isBaseOf(cd, null);\n-    }\n-\n     static ThrownExceptionExp chainExceptions(ThrownExceptionExp oldest, ThrownExceptionExp newest)\n     {\n         debug (LOG)\n@@ -1537,7 +1532,7 @@ public:\n         const next = 4;                         // index of Throwable.next\n         assert((*boss.value.elements)[next].type.ty == Tclass); // Throwable.next\n         ClassReferenceExp collateral = newest.thrown;\n-        if (isAnErrorException(collateral.originalClass()) && !isAnErrorException(boss.originalClass()))\n+        if (collateral.originalClass().isErrorException() && !boss.originalClass().isErrorException())\n         {\n             /* Find the index of the Error.bypassException field\n              */\n@@ -1647,8 +1642,15 @@ public:\n         if (exceptionOrCant(e))\n             return;\n \n-        assert(e.op == EXP.classReference);\n-        result = ctfeEmplaceExp!ThrownExceptionExp(loc, e.isClassReferenceExp());\n+        if (e.op == EXP.classReference)\n+        {\n+            result = ctfeEmplaceExp!ThrownExceptionExp(loc, e.isClassReferenceExp());\n+        }\n+        else\n+        {\n+            exp.error(\"to be thrown `%s` must be non-null\", exp.toChars());\n+            result = ErrorExp.get();\n+        }\n     }\n \n     override void visit(ScopeGuardStatement s)\n@@ -2296,7 +2298,7 @@ public:\n         while (s.isAttribDeclaration())\n         {\n             auto ad = cast(AttribDeclaration)s;\n-            assert(ad.decl && ad.decl.dim == 1); // Currently, only one allowed when parsing\n+            assert(ad.decl && ad.decl.length == 1); // Currently, only one allowed when parsing\n             s = (*ad.decl)[0];\n         }\n         if (VarDeclaration v = s.isVarDeclaration())\n@@ -2505,7 +2507,7 @@ public:\n             return;\n \n         auto expsx = e.elements;\n-        size_t dim = expsx ? expsx.dim : 0;\n+        size_t dim = expsx ? expsx.length : 0;\n         for (size_t i = 0; i < dim; i++)\n         {\n             Expression exp = (*expsx)[i];\n@@ -2544,7 +2546,7 @@ public:\n         {\n             // todo: all tuple expansions should go in semantic phase.\n             expandTuples(expsx);\n-            if (expsx.dim != dim)\n+            if (expsx.length != dim)\n             {\n                 e.error(\"CTFE internal error: invalid array literal\");\n                 result = CTFEExp.cantexp;\n@@ -2607,7 +2609,7 @@ public:\n             expandTuples(keysx);\n         if (valuesx !is e.values)\n             expandTuples(valuesx);\n-        if (keysx.dim != valuesx.dim)\n+        if (keysx.length != valuesx.length)\n         {\n             e.error(\"CTFE internal error: invalid AA\");\n             result = CTFEExp.cantexp;\n@@ -2616,10 +2618,10 @@ public:\n \n         /* Remove duplicate keys\n          */\n-        for (size_t i = 1; i < keysx.dim; i++)\n+        for (size_t i = 1; i < keysx.length; i++)\n         {\n             auto ekey = (*keysx)[i - 1];\n-            for (size_t j = i; j < keysx.dim; j++)\n+            for (size_t j = i; j < keysx.length; j++)\n             {\n                 auto ekey2 = (*keysx)[j];\n                 if (!ctfeEqual(e.loc, EXP.equal, ekey, ekey2))\n@@ -2665,14 +2667,14 @@ public:\n             return;\n         }\n \n-        size_t dim = e.elements ? e.elements.dim : 0;\n+        size_t dim = e.elements ? e.elements.length : 0;\n         auto expsx = e.elements;\n \n-        if (dim != e.sd.fields.dim)\n+        if (dim != e.sd.fields.length)\n         {\n             // guaranteed by AggregateDeclaration.fill and TypeStruct.defaultInitLiteral\n-            const nvthis = e.sd.fields.dim - e.sd.nonHiddenFields();\n-            assert(e.sd.fields.dim - dim == nvthis);\n+            const nvthis = e.sd.fields.length - e.sd.nonHiddenFields();\n+            assert(e.sd.fields.length - dim == nvthis);\n \n             /* If a nested struct has no initialized hidden pointer,\n              * set it to null to match the runtime behaviour.\n@@ -2688,7 +2690,7 @@ public:\n                 ++dim;\n             }\n         }\n-        assert(dim == e.sd.fields.dim);\n+        assert(dim == e.sd.fields.length);\n \n         foreach (i; 0 .. dim)\n         {\n@@ -2728,7 +2730,7 @@ public:\n         if (expsx !is e.elements)\n         {\n             expandTuples(expsx);\n-            if (expsx.dim != e.sd.fields.dim)\n+            if (expsx.length != e.sd.fields.length)\n             {\n                 e.error(\"CTFE internal error: invalid struct literal\");\n                 result = CTFEExp.cantexp;\n@@ -2757,7 +2759,7 @@ public:\n             return lenExpr;\n         size_t len = cast(size_t)lenExpr.toInteger();\n         Type elemType = (cast(TypeArray)newtype).next;\n-        if (elemType.ty == Tarray && argnum < arguments.dim - 1)\n+        if (elemType.ty == Tarray && argnum < arguments.length - 1)\n         {\n             Expression elem = recursivelyCreateArrayLiteral(pue, loc, elemType, istate, arguments, argnum + 1);\n             if (exceptionOrCantInterpret(elem))\n@@ -2771,7 +2773,7 @@ public:\n             ae.ownedByCtfe = OwnedBy.ctfe;\n             return ae;\n         }\n-        assert(argnum == arguments.dim - 1);\n+        assert(argnum == arguments.length - 1);\n         if (elemType.ty.isSomeChar)\n         {\n             const ch = cast(dchar)elemType.defaultInitLiteral(loc).toInteger();\n@@ -2818,10 +2820,10 @@ public:\n             {\n                 StructDeclaration sd = ts.sym;\n                 auto exps = new Expressions();\n-                exps.reserve(sd.fields.dim);\n+                exps.reserve(sd.fields.length);\n                 if (e.arguments)\n                 {\n-                    exps.setDim(e.arguments.dim);\n+                    exps.setDim(e.arguments.length);\n                     foreach (i, ex; *e.arguments)\n                     {\n                         ex = interpretRegion(ex, istate);\n@@ -2850,12 +2852,12 @@ public:\n             ClassDeclaration cd = tc.sym;\n             size_t totalFieldCount = 0;\n             for (ClassDeclaration c = cd; c; c = c.baseClass)\n-                totalFieldCount += c.fields.dim;\n+                totalFieldCount += c.fields.length;\n             auto elems = new Expressions(totalFieldCount);\n             size_t fieldsSoFar = totalFieldCount;\n             for (ClassDeclaration c = cd; c; c = c.baseClass)\n             {\n-                fieldsSoFar -= c.fields.dim;\n+                fieldsSoFar -= c.fields.length;\n                 foreach (i, v; c.fields)\n                 {\n                     if (v.inuse)\n@@ -2927,7 +2929,7 @@ public:\n         if (e.newtype.toBasetype().isscalar())\n         {\n             Expression newval;\n-            if (e.arguments && e.arguments.dim)\n+            if (e.arguments && e.arguments.length)\n                 newval = (*e.arguments)[0];\n             else\n                 newval = e.newtype.defaultInitLiteral(e.loc);\n@@ -3850,7 +3852,7 @@ public:\n                 e.error(\"CTFE internal error: cannot find field `%s` in `%s`\", v.toChars(), ex.toChars());\n                 return CTFEExp.cantexp;\n             }\n-            assert(0 <= fieldi && fieldi < sle.elements.dim);\n+            assert(0 <= fieldi && fieldi < sle.elements.length);\n \n             // If it's a union, set all other members of this union to void\n             stompOverlappedFields(sle, v);\n@@ -3958,7 +3960,7 @@ public:\n \n             Expressions* oldelems = oldval.isArrayLiteralExp().elements;\n             Expressions* newelems = newval.isArrayLiteralExp().elements;\n-            assert(oldelems.dim == newelems.dim);\n+            assert(oldelems.length == newelems.length);\n \n             Type elemtype = oldval.type.nextOf();\n             foreach (i, ref oldelem; *oldelems)\n@@ -4049,7 +4051,7 @@ public:\n             if (auto ale = e1.isArrayLiteralExp())\n             {\n                 lowerbound = 0;\n-                upperbound = ale.elements.dim;\n+                upperbound = ale.elements.length;\n             }\n             else if (auto se = e1.isStringExp())\n             {\n@@ -4287,7 +4289,7 @@ public:\n \n                 extern (C++) Expression assignTo(ArrayLiteralExp ae)\n                 {\n-                    return assignTo(ae, 0, ae.elements.dim);\n+                    return assignTo(ae, 0, ae.elements.length);\n                 }\n \n                 extern (C++) Expression assignTo(ArrayLiteralExp ae, size_t lwr, size_t upr)\n@@ -4786,7 +4788,7 @@ public:\n \n             if (fd.ident == Id.__ArrayPostblit || fd.ident == Id.__ArrayDtor)\n             {\n-                assert(e.arguments.dim == 1);\n+                assert(e.arguments.length == 1);\n                 Expression ea = (*e.arguments)[0];\n                 // printf(\"1 ea = %s %s\\n\", ea.type.toChars(), ea.toChars());\n                 if (auto se = ea.isSliceExp())\n@@ -4822,7 +4824,7 @@ public:\n             {\n                 // In expressionsem.d `ea.length = eb;` got lowered to `_d_arraysetlengthT(ea, eb);`.\n                 // The following code will rewrite it back to `ea.length = eb` and then interpret that expression.\n-                assert(e.arguments.dim == 2);\n+                assert(e.arguments.length == 2);\n \n                 Expression ea = (*e.arguments)[0];\n                 Expression eb = (*e.arguments)[1];\n@@ -4846,9 +4848,9 @@ public:\n                 // then interpret that expression.\n \n                 if (fd.ident == Id._d_arrayctor)\n-                    assert(e.arguments.dim == 3);\n+                    assert(e.arguments.length == 3);\n                 else\n-                    assert(e.arguments.dim == 2);\n+                    assert(e.arguments.length == 2);\n \n                 Expression ea = (*e.arguments)[0];\n                 if (ea.isCastExp)\n@@ -4877,13 +4879,13 @@ public:\n \n                 if (fd.ident == Id._d_arrayappendT)\n                 {\n-                    assert(e.arguments.dim == 2);\n+                    assert(e.arguments.length == 2);\n                     lhs = (*e.arguments)[0];\n                     rhs = (*e.arguments)[1];\n                 }\n                 else\n                 {\n-                    assert(e.arguments.dim == 5);\n+                    assert(e.arguments.length == 5);\n                     lhs = (*e.arguments)[3];\n                     rhs = (*e.arguments)[4];\n                 }\n@@ -5044,7 +5046,7 @@ public:\n             // `_d_arrayappendcTX(arr, elem), arr[arr.length - 1] = elem, elem;`.\n             // The following code will rewrite it back to `arr ~= elem`\n             // and then interpret that expression.\n-            assert(ce.arguments.dim == 2);\n+            assert(ce.arguments.length == 2);\n \n             auto arr = (*ce.arguments)[0];\n             auto elem = e.e2.isConstructExp().e2;\n@@ -5999,7 +6001,7 @@ public:\n                     {\n                         ArrayLiteralExp ale = ie.e1.isArrayLiteralExp();\n                         const indx = cast(size_t)ie.e2.toInteger();\n-                        if (indx < ale.elements.dim)\n+                        if (indx < ale.elements.length)\n                         {\n                             if (Expression xx = (*ale.elements)[indx])\n                             {\n@@ -6463,8 +6465,8 @@ public:\n                 (*valuesx)[j - removed] = evalue;\n             }\n         }\n-        valuesx.dim = valuesx.dim - removed;\n-        keysx.dim = keysx.dim - removed;\n+        valuesx.length = valuesx.length - removed;\n+        keysx.length = keysx.length - removed;\n         result = IntegerExp.createBool(removed != 0);\n     }\n \n@@ -6978,7 +6980,7 @@ private Expression interpret_length(UnionExp* pue, InterState* istate, Expressio\n         return earg;\n     dinteger_t len = 0;\n     if (auto aae = earg.isAssocArrayLiteralExp())\n-        len = aae.keys.dim;\n+        len = aae.keys.length;\n     else\n         assert(earg.op == EXP.null_);\n     emplaceExp!(IntegerExp)(pue, earg.loc, len, Type.tsize_t);\n@@ -7049,7 +7051,7 @@ private Expression interpret_dup(UnionExp* pue, InterState* istate, Expression e\n     if (earg.op != EXP.assocArrayLiteral && earg.type.toBasetype().ty != Taarray)\n         return null;\n     auto aae = copyLiteral(earg).copy().isAssocArrayLiteralExp();\n-    for (size_t i = 0; i < aae.keys.dim; i++)\n+    for (size_t i = 0; i < aae.keys.length; i++)\n     {\n         if (Expression e = evaluatePostblit(istate, (*aae.keys)[i]))\n             return e;\n@@ -7085,7 +7087,7 @@ private Expression interpret_aaApply(UnionExp* pue, InterState* istate, Expressi\n \n     assert(fd && fd.fbody);\n     assert(fd.parameters);\n-    size_t numParams = fd.parameters.dim;\n+    size_t numParams = fd.parameters.length;\n     assert(numParams == 1 || numParams == 2);\n \n     Parameter fparam = fd.type.isTypeFunction().parameterList[numParams - 1];\n@@ -7094,11 +7096,11 @@ private Expression interpret_aaApply(UnionExp* pue, InterState* istate, Expressi\n     Expressions args = Expressions(numParams);\n \n     AssocArrayLiteralExp ae = aa.isAssocArrayLiteralExp();\n-    if (!ae.keys || ae.keys.dim == 0)\n+    if (!ae.keys || ae.keys.length == 0)\n         return ctfeEmplaceExp!IntegerExp(deleg.loc, 0, Type.tsize_t);\n     Expression eresult;\n \n-    for (size_t i = 0; i < ae.keys.dim; ++i)\n+    for (size_t i = 0; i < ae.keys.length; ++i)\n     {\n         Expression ekey = (*ae.keys)[i];\n         Expression evalue = (*ae.values)[i];\n@@ -7146,7 +7148,7 @@ private Expression foreachApplyUtf(UnionExp* pue, InterState* istate, Expression\n \n     assert(fd && fd.fbody);\n     assert(fd.parameters);\n-    size_t numParams = fd.parameters.dim;\n+    size_t numParams = fd.parameters.length;\n     assert(numParams == 1 || numParams == 2);\n     Type charType = (*fd.parameters)[numParams - 1].type;\n     Type indexType = numParams == 2 ? (*fd.parameters)[0].type : Type.tsize_t;\n@@ -7389,7 +7391,7 @@ private Expression foreachApplyUtf(UnionExp* pue, InterState* istate, Expression\n private Expression evaluateIfBuiltin(UnionExp* pue, InterState* istate, const ref Loc loc, FuncDeclaration fd, Expressions* arguments, Expression pthis)\n {\n     Expression e = null;\n-    size_t nargs = arguments ? arguments.dim : 0;\n+    size_t nargs = arguments ? arguments.length : 0;\n     if (!pthis)\n     {\n         if (isBuiltin(fd) != BUILTIN.unimp)\n@@ -7453,7 +7455,7 @@ private Expression evaluateIfBuiltin(UnionExp* pue, InterState* istate, const re\n             // At present, the constructors just copy their arguments into the struct.\n             // But we might need some magic if stack tracing gets added to druntime.\n             StructLiteralExp se = pthis.isClassReferenceExp().value;\n-            assert(arguments.dim <= se.elements.dim);\n+            assert(arguments.length <= se.elements.length);\n             foreach (i, arg; *arguments)\n             {\n                 auto elem = interpret(arg, istate);\n@@ -7615,7 +7617,7 @@ private void removeHookTraceImpl(ref CallExp ce, ref FuncDeclaration fd)\n \n     // Remove the first three trace parameters\n     auto arguments = new Expressions();\n-    arguments.reserve(ce.arguments.dim - 3);\n+    arguments.reserve(ce.arguments.length - 3);\n     arguments.pushSlice((*ce.arguments)[3 .. $]);\n \n     ce = ctfeEmplaceExp!CallExp(ce.loc, ctfeEmplaceExp!VarExp(ce.loc, fd, false), arguments);"}, {"sha": "6ecaa5235f2c2444fff335cef4f4002aa9f221e2", "filename": "gcc/d/dmd/dmangle.d", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -721,8 +721,8 @@ public:\n         mangleIdentifier(tempdecl.ident, tempdecl);\n \n         auto args = ti.tiargs;\n-        size_t nparams = tempdecl.parameters.dim - (tempdecl.isVariadic() ? 1 : 0);\n-        for (size_t i = 0; i < args.dim; i++)\n+        size_t nparams = tempdecl.parameters.length - (tempdecl.isVariadic() ? 1 : 0);\n+        for (size_t i = 0; i < args.length; i++)\n         {\n             auto o = (*args)[i];\n             Type ta = isType(o);\n@@ -814,7 +814,7 @@ public:\n             }\n             else if (va)\n             {\n-                assert(i + 1 == args.dim); // must be last one\n+                assert(i + 1 == args.length); // must be last one\n                 args = &va.objects;\n                 i = -cast(size_t)1;\n             }\n@@ -960,7 +960,7 @@ public:\n \n     override void visit(ArrayLiteralExp e)\n     {\n-        const dim = e.elements ? e.elements.dim : 0;\n+        const dim = e.elements ? e.elements.length : 0;\n         buf.writeByte('A');\n         buf.print(dim);\n         foreach (i; 0 .. dim)\n@@ -971,7 +971,7 @@ public:\n \n     override void visit(AssocArrayLiteralExp e)\n     {\n-        const dim = e.keys.dim;\n+        const dim = e.keys.length;\n         buf.writeByte('A');\n         buf.print(dim);\n         foreach (i; 0 .. dim)\n@@ -983,7 +983,7 @@ public:\n \n     override void visit(StructLiteralExp e)\n     {\n-        const dim = e.elements ? e.elements.dim : 0;\n+        const dim = e.elements ? e.elements.length : 0;\n         buf.writeByte('S');\n         buf.print(dim);\n         foreach (i; 0 .. dim)"}, {"sha": "616080566d801a857e311496302a274c1368dc81", "filename": "gcc/d/dmd/dmodule.d", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -62,7 +62,7 @@ void semantic3OnDependencies(Module m)\n \n     m.semantic3(null);\n \n-    foreach (i; 1 .. m.aimports.dim)\n+    foreach (i; 1 .. m.aimports.length)\n         semantic3OnDependencies(m.aimports[i]);\n }\n \n@@ -132,7 +132,7 @@ private const(char)[] getFilename(Identifier[] packages, Identifier ident) nothr\n     {\n         const p = pid.toString();\n         buf.writestring(p);\n-        if (modAliases.dim)\n+        if (modAliases.length)\n             checkModFileAlias(p);\n         version (Windows)\n             enum FileSeparator = '\\\\';\n@@ -141,7 +141,7 @@ private const(char)[] getFilename(Identifier[] packages, Identifier ident) nothr\n         buf.writeByte(FileSeparator);\n     }\n     buf.writestring(filename);\n-    if (modAliases.dim)\n+    if (modAliases.length)\n         checkModFileAlias(filename);\n     buf.writeByte(0);\n     filename = buf.extractSlice()[0 .. $ - 1];\n@@ -499,7 +499,7 @@ extern (C++) final class Module : Package\n \n     extern (D) static const(char)[] find(const(char)[] filename)\n     {\n-        return FileManager.lookForSourceFile(filename, global.path ? (*global.path)[] : null);\n+        return global.fileManager.lookForSourceFile(filename, global.path ? (*global.path)[] : null);\n     }\n \n     extern (C++) static Module load(const ref Loc loc, Identifiers* packages, Identifier ident)\n@@ -942,7 +942,7 @@ extern (C++) final class Module : Package\n         //    classinst == classinst -> .object.opEquals(classinst, classinst)\n         // would fail inside object.d.\n         if (filetype != FileType.c &&\n-            (members.dim == 0 ||\n+            (members.length == 0 ||\n              (*members)[0].ident != Id.object ||\n              (*members)[0].isImport() is null))\n         {\n@@ -953,7 +953,7 @@ extern (C++) final class Module : Package\n         {\n             // Add all symbols into module's symbol table\n             symtab = new DsymbolTable();\n-            for (size_t i = 0; i < members.dim; i++)\n+            for (size_t i = 0; i < members.length; i++)\n             {\n                 Dsymbol s = (*members)[i];\n                 s.addMember(sc, sc.scopesym);\n@@ -966,12 +966,12 @@ extern (C++) final class Module : Package\n          * before any semantic() on any of them.\n          */\n         setScope(sc); // remember module scope for semantic\n-        for (size_t i = 0; i < members.dim; i++)\n+        for (size_t i = 0; i < members.length; i++)\n         {\n             Dsymbol s = (*members)[i];\n             s.setScope(sc);\n         }\n-        for (size_t i = 0; i < members.dim; i++)\n+        for (size_t i = 0; i < members.length; i++)\n         {\n             Dsymbol s = (*members)[i];\n             s.importAll(sc);\n@@ -1115,13 +1115,13 @@ extern (C++) final class Module : Package\n         __gshared int nested;\n         if (nested)\n             return;\n-        //if (deferred.dim) printf(\"+Module::runDeferredSemantic(), len = %ld\\n\", deferred.dim);\n+        //if (deferred.length) printf(\"+Module::runDeferredSemantic(), len = %ld\\n\", deferred.length);\n         nested++;\n \n         size_t len;\n         do\n         {\n-            len = deferred.dim;\n+            len = deferred.length;\n             if (!len)\n                 break;\n \n@@ -1146,21 +1146,21 @@ extern (C++) final class Module : Package\n                 s.dsymbolSemantic(null);\n                 //printf(\"deferred: %s, parent = %s\\n\", s.toChars(), s.parent.toChars());\n             }\n-            //printf(\"\\tdeferred.dim = %ld, len = %ld\\n\", deferred.dim, len);\n+            //printf(\"\\tdeferred.length = %ld, len = %ld\\n\", deferred.length, len);\n             if (todoalloc)\n                 free(todoalloc);\n         }\n-        while (deferred.dim != len); // while making progress\n+        while (deferred.length != len); // while making progress\n         nested--;\n-        //printf(\"-Module::runDeferredSemantic(), len = %ld\\n\", deferred.dim);\n+        //printf(\"-Module::runDeferredSemantic(), len = %ld\\n\", deferred.length);\n     }\n \n     static void runDeferredSemantic2()\n     {\n         Module.runDeferredSemantic();\n \n         Dsymbols* a = &Module.deferred2;\n-        for (size_t i = 0; i < a.dim; i++)\n+        for (size_t i = 0; i < a.length; i++)\n         {\n             Dsymbol s = (*a)[i];\n             //printf(\"[%d] %s semantic2a\\n\", i, s.toPrettyChars());\n@@ -1177,7 +1177,7 @@ extern (C++) final class Module : Package\n         Module.runDeferredSemantic2();\n \n         Dsymbols* a = &Module.deferred3;\n-        for (size_t i = 0; i < a.dim; i++)\n+        for (size_t i = 0; i < a.length; i++)\n         {\n             Dsymbol s = (*a)[i];\n             //printf(\"[%d] %s semantic3a\\n\", i, s.toPrettyChars());"}, {"sha": "c04409c4d3fa32860438d731b045c1e17a5c98f1", "filename": "gcc/d/dmd/doc.d", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdoc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdoc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdoc.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -106,7 +106,7 @@ private class Section\n \n     void write(Loc loc, DocComment* dc, Scope* sc, Dsymbols* a, OutBuffer* buf)\n     {\n-        assert(a.dim);\n+        assert(a.length);\n         if (name.length)\n         {\n             static immutable table =\n@@ -161,7 +161,7 @@ private final class ParamSection : Section\n {\n     override void write(Loc loc, DocComment* dc, Scope* sc, Dsymbols* a, OutBuffer* buf)\n     {\n-        assert(a.dim);\n+        assert(a.length);\n         Dsymbol s = (*a)[0]; // test\n         const(char)* p = body_.ptr;\n         size_t len = body_.length;\n@@ -295,10 +295,10 @@ private final class ParamSection : Section\n             goto L1;\n         // write out last one\n         buf.writestring(\")\");\n-        TypeFunction tf = a.dim == 1 ? isTypeFunction(s) : null;\n+        TypeFunction tf = a.length == 1 ? isTypeFunction(s) : null;\n         if (tf)\n         {\n-            size_t pcount = (tf.parameterList.parameters ? tf.parameterList.parameters.dim : 0) +\n+            size_t pcount = (tf.parameterList.parameters ? tf.parameterList.parameters.length : 0) +\n                             cast(int)(tf.parameterList.varargs == VarArg.variadic);\n             if (pcount != paramcount)\n             {\n@@ -386,7 +386,7 @@ extern(C++) void gendocfile(Module m)\n         if (p)\n             global.params.ddoc.files.shift(p);\n         // Override with the ddoc macro files from the command line\n-        for (size_t i = 0; i < global.params.ddoc.files.dim; i++)\n+        for (size_t i = 0; i < global.params.ddoc.files.length; i++)\n         {\n             auto buffer = readFile(m.loc, global.params.ddoc.files[i]);\n             // BUG: convert file contents to UTF-8 before use\n@@ -757,9 +757,9 @@ private void emitAnchor(ref OutBuffer buf, Dsymbol s, Scope* sc, bool forHeader\n     if (auto imp = s.isImport())\n     {\n         // For example: `public import core.stdc.string : memcpy, memcmp;`\n-        if (imp.aliases.dim > 0)\n+        if (imp.aliases.length > 0)\n         {\n-            for(int i = 0; i < imp.aliases.dim; i++)\n+            for(int i = 0; i < imp.aliases.length; i++)\n             {\n                 // Need to distinguish between\n                 // `public import core.stdc.string : memcpy, memcmp;` and\n@@ -866,7 +866,7 @@ private void expandTemplateMixinComments(TemplateMixin tm, ref OutBuffer buf, Sc\n     TemplateDeclaration td = (tm && tm.tempdecl) ? tm.tempdecl.isTemplateDeclaration() : null;\n     if (td && td.members)\n     {\n-        for (size_t i = 0; i < td.members.dim; i++)\n+        for (size_t i = 0; i < td.members.length; i++)\n         {\n             Dsymbol sm = (*td.members)[i];\n             TemplateMixin tmc = sm.isTemplateMixin();\n@@ -898,7 +898,7 @@ private void emitMemberComments(ScopeDsymbol sds, ref OutBuffer buf, Scope* sc)\n     buf.writestring(m);\n     size_t offset2 = buf.length; // to see if we write anything\n     sc = sc.push(sds);\n-    for (size_t i = 0; i < sds.members.dim; i++)\n+    for (size_t i = 0; i < sds.members.length; i++)\n     {\n         Dsymbol s = (*sds.members)[i];\n         //printf(\"\\ts = '%s'\\n\", s.toChars());\n@@ -998,7 +998,7 @@ private void emitComment(Dsymbol s, ref OutBuffer buf, Scope* sc)\n             // Put previous doc comment if exists\n             if (DocComment* dc = sc.lastdc)\n             {\n-                assert(dc.a.dim > 0, \"Expects at least one declaration for a\" ~\n+                assert(dc.a.length > 0, \"Expects at least one declaration for a\" ~\n                     \"documentation comment\");\n \n                 auto symbol = dc.a[0];\n@@ -1010,7 +1010,7 @@ private void emitComment(Dsymbol s, ref OutBuffer buf, Scope* sc)\n \n                 // Put the declaration signatures as the document 'title'\n                 buf.writestring(ddoc_decl_s);\n-                for (size_t i = 0; i < dc.a.dim; i++)\n+                for (size_t i = 0; i < dc.a.length; i++)\n                 {\n                     Dsymbol sx = dc.a[i];\n                     // the added linebreaks in here make looking at multiple\n@@ -1138,7 +1138,7 @@ private void emitComment(Dsymbol s, ref OutBuffer buf, Scope* sc)\n                 return;\n             if (ed.isAnonymous() && ed.members)\n             {\n-                for (size_t i = 0; i < ed.members.dim; i++)\n+                for (size_t i = 0; i < ed.members.length; i++)\n                 {\n                     Dsymbol s = (*ed.members)[i];\n                     emitComment(s, *buf, sc);\n@@ -1176,7 +1176,7 @@ private void emitComment(Dsymbol s, ref OutBuffer buf, Scope* sc)\n             Dsymbols* d = ad.include(null);\n             if (d)\n             {\n-                for (size_t i = 0; i < d.dim; i++)\n+                for (size_t i = 0; i < d.length; i++)\n                 {\n                     Dsymbol s = (*d)[i];\n                     //printf(\"AttribDeclaration::emitComment %s\\n\", s.toChars());\n@@ -1210,7 +1210,7 @@ private void emitComment(Dsymbol s, ref OutBuffer buf, Scope* sc)\n              * a template, then include(null) will fail.\n              */\n             Dsymbols* d = cd.decl ? cd.decl : cd.elsedecl;\n-            for (size_t i = 0; i < d.dim; i++)\n+            for (size_t i = 0; i < d.length; i++)\n             {\n                 Dsymbol s = (*d)[i];\n                 emitComment(s, *buf, sc);\n@@ -1324,9 +1324,9 @@ private void toDocBuffer(Dsymbol s, ref OutBuffer buf, Scope* sc)\n             if (d.isVarDeclaration() && td)\n             {\n                 buf.writeByte('(');\n-                if (td.origParameters && td.origParameters.dim)\n+                if (td.origParameters && td.origParameters.length)\n                 {\n-                    for (size_t i = 0; i < td.origParameters.dim; i++)\n+                    for (size_t i = 0; i < td.origParameters.length; i++)\n                     {\n                         if (i)\n                             buf.writestring(\", \");\n@@ -1484,7 +1484,7 @@ private void toDocBuffer(Dsymbol s, ref OutBuffer buf, Scope* sc)\n                 buf.printf(\"%s %s\", cd.kind(), cd.toChars());\n             }\n             int any = 0;\n-            for (size_t i = 0; i < cd.baseclasses.dim; i++)\n+            for (size_t i = 0; i < cd.baseclasses.length; i++)\n             {\n                 BaseClass* bc = (*cd.baseclasses)[i];\n                 if (bc.sym && bc.sym.ident == Id.Object)\n@@ -1557,7 +1557,7 @@ struct DocComment\n         if (!comment)\n             return dc;\n         dc.parseSections(comment);\n-        for (size_t i = 0; i < dc.sections.dim; i++)\n+        for (size_t i = 0; i < dc.sections.length; i++)\n         {\n             Section sec = dc.sections[i];\n             if (iequals(\"copyright\", sec.name))\n@@ -1873,7 +1873,7 @@ struct DocComment\n \n     void writeSections(Scope* sc, Dsymbols* a, OutBuffer* buf)\n     {\n-        assert(a.dim);\n+        assert(a.length);\n         //printf(\"DocComment::writeSections()\\n\");\n         Loc loc = (*a)[0].loc;\n         if (Module m = (*a)[0].isModule())\n@@ -1884,7 +1884,7 @@ struct DocComment\n         size_t offset1 = buf.length;\n         buf.writestring(\"$(DDOC_SECTIONS \");\n         size_t offset2 = buf.length;\n-        for (size_t i = 0; i < sections.dim; i++)\n+        for (size_t i = 0; i < sections.length; i++)\n         {\n             Section sec = sections[i];\n             if (sec.nooutput)\n@@ -1902,7 +1902,7 @@ struct DocComment\n             else\n                 sec.write(loc, &this, sc, a, buf);\n         }\n-        for (size_t i = 0; i < a.dim; i++)\n+        for (size_t i = 0; i < a.length; i++)\n         {\n             Dsymbol s = (*a)[i];\n             if (Dsymbol td = getEponymousParent(s))\n@@ -2719,7 +2719,7 @@ private Parameter isEponymousFunctionParameter(Dsymbols *a, const(char)[] p) @sa\n  */\n private TemplateParameter isTemplateParameter(Dsymbols* a, const(char)* p, size_t len)\n {\n-    for (size_t i = 0; i < a.dim; i++)\n+    for (size_t i = 0; i < a.length; i++)\n     {\n         TemplateDeclaration td = (*a)[i].isTemplateDeclaration();\n         // Check for the parent, if the current symbol is not a template declaration.\n@@ -5004,10 +5004,10 @@ private void highlightText(Scope* sc, Dsymbols* a, Loc loc, ref OutBuffer buf, s\n private void highlightCode(Scope* sc, Dsymbol s, ref OutBuffer buf, size_t offset)\n {\n     auto imp = s.isImport();\n-    if (imp && imp.aliases.dim > 0)\n+    if (imp && imp.aliases.length > 0)\n     {\n         // For example: `public import core.stdc.string : memcpy, memcmp;`\n-        for(int i = 0; i < imp.aliases.dim; i++)\n+        for(int i = 0; i < imp.aliases.length; i++)\n         {\n             // Need to distinguish between\n             // `public import core.stdc.string : memcpy, memcmp;` and\n@@ -5089,7 +5089,7 @@ private void highlightCode(Scope* sc, Dsymbols* a, ref OutBuffer buf, size_t off\n             size_t previ = i;\n \n             // hunt for template declarations:\n-            foreach (symi; 0 .. a.dim)\n+            foreach (symi; 0 .. a.length)\n             {\n                 FuncDeclaration fd = (*a)[symi].isFuncDeclaration();\n \n@@ -5102,14 +5102,14 @@ private void highlightCode(Scope* sc, Dsymbols* a, ref OutBuffer buf, size_t off\n \n                 // build the template parameters\n                 Array!(size_t) paramLens;\n-                paramLens.reserve(td.parameters.dim);\n+                paramLens.reserve(td.parameters.length);\n \n                 OutBuffer parametersBuf;\n                 HdrGenState hgs;\n \n                 parametersBuf.writeByte('(');\n \n-                foreach (parami; 0 .. td.parameters.dim)\n+                foreach (parami; 0 .. td.parameters.length)\n                 {\n                     TemplateParameter tp = (*td.parameters)[parami];\n "}, {"sha": "362e7f279937c57094d47d90debe41641bf737d9", "filename": "gcc/d/dmd/dscope.d", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdscope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdscope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdscope.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -71,13 +71,14 @@ private enum PersistentFlags =\n     SCOPE.noaccesscheck | SCOPE.ignoresymbolvisibility |\n     SCOPE.Cfile;\n \n-struct Scope\n+extern (C++) struct Scope\n {\n     Scope* enclosing;               /// enclosing Scope\n \n     Module _module;                 /// Root module\n     ScopeDsymbol scopesym;          /// current symbol\n     FuncDeclaration func;           /// function we are in\n+    VarDeclaration varDecl;         /// variable we are in during semantic2\n     Dsymbol parent;                 /// parent to use\n     LabelStatement slabel;          /// enclosing labelled statement\n     SwitchStatement sw;             /// enclosing switch statement\n@@ -177,7 +178,7 @@ struct Scope\n         return sc;\n     }\n \n-    extern (C++) Scope* copy()\n+    extern (D) Scope* copy()\n     {\n         Scope* sc = Scope.alloc();\n         *sc = this;\n@@ -188,7 +189,7 @@ struct Scope\n         return sc;\n     }\n \n-    extern (C++) Scope* push()\n+    extern (D) Scope* push()\n     {\n         Scope* s = copy();\n         //printf(\"Scope::push(this = %p) new = %p\\n\", this, s);\n@@ -214,15 +215,15 @@ struct Scope\n         return s;\n     }\n \n-    extern (C++) Scope* push(ScopeDsymbol ss)\n+    extern (D) Scope* push(ScopeDsymbol ss)\n     {\n         //printf(\"Scope::push(%s)\\n\", ss.toChars());\n         Scope* s = push();\n         s.scopesym = ss;\n         return s;\n     }\n \n-    extern (C++) Scope* pop()\n+    extern (D) Scope* pop()\n     {\n         //printf(\"Scope::pop() %p nofree = %d\\n\", this, nofree);\n         if (enclosing)\n@@ -252,7 +253,7 @@ struct Scope\n         pop();\n     }\n \n-    extern (C++) Scope* startCTFE()\n+    extern (D) Scope* startCTFE()\n     {\n         Scope* sc = this.push();\n         sc.flags = this.flags | SCOPE.ctfe;\n@@ -279,7 +280,7 @@ struct Scope\n         return sc;\n     }\n \n-    extern (C++) Scope* endCTFE()\n+    extern (D) Scope* endCTFE()\n     {\n         assert(flags & SCOPE.ctfe);\n         return pop();\n@@ -663,7 +664,7 @@ struct Scope\n     /********************************************\n      * Search enclosing scopes for ScopeDsymbol.\n      */\n-    ScopeDsymbol getScopesym()\n+    extern (D) ScopeDsymbol getScopesym()\n     {\n         for (Scope* sc = &this; sc; sc = sc.enclosing)\n         {\n@@ -676,7 +677,7 @@ struct Scope\n     /********************************************\n      * Search enclosing scopes for ClassDeclaration.\n      */\n-    extern (C++) ClassDeclaration getClassScope()\n+    extern (D) ClassDeclaration getClassScope()\n     {\n         for (Scope* sc = &this; sc; sc = sc.enclosing)\n         {\n@@ -691,7 +692,7 @@ struct Scope\n     /********************************************\n      * Search enclosing scopes for ClassDeclaration or StructDeclaration.\n      */\n-    extern (C++) AggregateDeclaration getStructClassScope()\n+    extern (D) AggregateDeclaration getStructClassScope()\n     {\n         for (Scope* sc = &this; sc; sc = sc.enclosing)\n         {\n@@ -713,7 +714,7 @@ struct Scope\n      *\n      * Returns: the function or null\n      */\n-    inout(FuncDeclaration) getEnclosingFunction() inout\n+    extern (D) inout(FuncDeclaration) getEnclosingFunction() inout\n     {\n         if (!this.func)\n             return null;\n@@ -752,7 +753,7 @@ struct Scope\n     }\n     /******************************\n      */\n-    structalign_t alignment()\n+    extern (D) structalign_t alignment()\n     {\n         if (aligndecl)\n         {\n@@ -772,7 +773,7 @@ struct Scope\n     *\n     * Returns: `true` if this or any parent scope is deprecated, `false` otherwise`\n     */\n-    extern(C++) bool isDeprecated()\n+    extern (D) bool isDeprecated()\n     {\n         for (const(Dsymbol)* sp = &(this.parent); *sp; sp = &(sp.parent))\n         {\n@@ -802,7 +803,7 @@ struct Scope\n      *\n      * Returns: `true` if this `Scope` is known to be from one of these speculative contexts\n      */\n-    extern(C++) bool isFromSpeculativeSemanticContext() scope\n+    extern (D) bool isFromSpeculativeSemanticContext() scope\n     {\n         return this.intypeof || this.flags & SCOPE.compile;\n     }"}, {"sha": "2115fda2f5522098952efef8aca4edc77c95557d", "filename": "gcc/d/dmd/dstruct.d", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdstruct.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdstruct.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdstruct.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -292,14 +292,14 @@ extern (C++) class StructDeclaration : AggregateDeclaration\n         }\n         sizeok = Sizeok.inProcess;\n \n-        //printf(\"+StructDeclaration::finalizeSize() %s, fields.dim = %d, sizeok = %d\\n\", toChars(), fields.dim, sizeok);\n+        //printf(\"+StructDeclaration::finalizeSize() %s, fields.length = %d, sizeok = %d\\n\", toChars(), fields.length, sizeok);\n \n         fields.setDim(0);   // workaround\n \n         // Set the offsets of the fields and determine the size of the struct\n         FieldState fieldState;\n         bool isunion = isUnionDeclaration() !is null;\n-        for (size_t i = 0; i < members.dim; i++)\n+        for (size_t i = 0; i < members.length; i++)\n         {\n             Dsymbol s = (*members)[i];\n             s.setFieldOffset(this, fieldState, isunion);\n@@ -353,7 +353,7 @@ extern (C++) class StructDeclaration : AggregateDeclaration\n \n         sizeok = Sizeok.done;\n \n-        //printf(\"-StructDeclaration::finalizeSize() %s, fields.dim = %d, structsize = %d\\n\", toChars(), fields.dim, structsize);\n+        //printf(\"-StructDeclaration::finalizeSize() %s, fields.length = %d, structsize = %d\\n\", toChars(), fields.length, structsize);\n \n         if (errors)\n             return;\n@@ -454,7 +454,7 @@ extern (C++) class StructDeclaration : AggregateDeclaration\n         }\n \n         // Recursively check all fields are POD.\n-        for (size_t i = 0; i < fields.dim; i++)\n+        for (size_t i = 0; i < fields.length; i++)\n         {\n             VarDeclaration v = fields[i];\n             if (v.storage_class & STC.ref_)\n@@ -491,7 +491,7 @@ extern (C++) class StructDeclaration : AggregateDeclaration\n \n     final uint numArgTypes() const\n     {\n-        return argTypes && argTypes.arguments ? cast(uint) argTypes.arguments.dim : 0;\n+        return argTypes && argTypes.arguments ? cast(uint) argTypes.arguments.length : 0;\n     }\n \n     final Type argType(uint index)\n@@ -570,7 +570,7 @@ private bool _isZeroInit(Expression exp)\n         case EXP.structLiteral:\n         {\n             auto sle = cast(StructLiteralExp) exp;\n-            foreach (i; 0 .. sle.sd.fields.dim)\n+            foreach (i; 0 .. sle.sd.fields.length)\n             {\n                 auto field = sle.sd.fields[i];\n                 if (field.type.size(field.loc))\n@@ -588,7 +588,7 @@ private bool _isZeroInit(Expression exp)\n         {\n             auto ale = cast(ArrayLiteralExp)exp;\n \n-            const dim = ale.elements ? ale.elements.dim : 0;\n+            const dim = ale.elements ? ale.elements.length : 0;\n \n             if (ale.type.toBasetype().ty == Tarray) // if initializing a dynamic array\n                 return dim == 0;"}, {"sha": "2cf5500bf5a2226ae0500a6609541373c369a783", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -73,7 +73,7 @@ int foreachDsymbol(Dsymbols* symbols, scope int delegate(Dsymbol) dg)\n     {\n         /* Do not use foreach, as the size of the array may expand during iteration\n          */\n-        for (size_t i = 0; i < symbols.dim; ++i)\n+        for (size_t i = 0; i < symbols.length; ++i)\n         {\n             Dsymbol s = (*symbols)[i];\n             const result = dg(s);\n@@ -99,7 +99,7 @@ void foreachDsymbol(Dsymbols* symbols, scope void delegate(Dsymbol) dg)\n     {\n         /* Do not use foreach, as the size of the array may expand during iteration\n          */\n-        for (size_t i = 0; i < symbols.dim; ++i)\n+        for (size_t i = 0; i < symbols.length; ++i)\n         {\n             Dsymbol s = (*symbols)[i];\n             dg(s);\n@@ -739,7 +739,7 @@ extern (C++) class Dsymbol : ASTNode\n         if (a)\n         {\n             b = a.copy();\n-            for (size_t i = 0; i < b.dim; i++)\n+            for (size_t i = 0; i < b.length; i++)\n             {\n                 (*b)[i] = (*b)[i].syntaxCopy(null);\n             }\n@@ -1164,15 +1164,15 @@ extern (C++) class Dsymbol : ASTNode\n      */\n     extern (D) static bool oneMembers(Dsymbols* members, Dsymbol* ps, Identifier ident)\n     {\n-        //printf(\"Dsymbol::oneMembers() %d\\n\", members ? members.dim : 0);\n+        //printf(\"Dsymbol::oneMembers() %d\\n\", members ? members.length : 0);\n         Dsymbol s = null;\n         if (!members)\n         {\n             *ps = null;\n             return true;\n         }\n \n-        for (size_t i = 0; i < members.dim; i++)\n+        for (size_t i = 0; i < members.length; i++)\n         {\n             Dsymbol sx = (*members)[i];\n             bool x = sx.oneMember(ps, ident);\n@@ -1489,7 +1489,7 @@ public:\n         Dsymbol s = null;\n         OverloadSet a = null;\n         // Look in imported modules\n-        for (size_t i = 0; i < importedScopes.dim; i++)\n+        for (size_t i = 0; i < importedScopes.length; i++)\n         {\n             // If private import, don't search it\n             if ((flags & IgnorePrivateImports) && visibilities[i] == Visibility.Kind.private_)\n@@ -1628,14 +1628,14 @@ public:\n         if (OverloadSet os2 = s.isOverloadSet())\n         {\n             // Merge the cross-module overload set 'os2' into 'os'\n-            if (os.a.dim == 0)\n+            if (os.a.length == 0)\n             {\n-                os.a.setDim(os2.a.dim);\n-                memcpy(os.a.tdata(), os2.a.tdata(), (os.a[0]).sizeof * os2.a.dim);\n+                os.a.setDim(os2.a.length);\n+                memcpy(os.a.tdata(), os2.a.tdata(), (os.a[0]).sizeof * os2.a.length);\n             }\n             else\n             {\n-                for (size_t i = 0; i < os2.a.dim; i++)\n+                for (size_t i = 0; i < os2.a.length; i++)\n                 {\n                     os = mergeOverloadSet(ident, os, os2.a[i]);\n                 }\n@@ -1646,7 +1646,7 @@ public:\n             assert(s.isOverloadable());\n             /* Don't add to os[] if s is alias of previous sym\n              */\n-            for (size_t j = 0; j < os.a.dim; j++)\n+            for (size_t j = 0; j < os.a.length; j++)\n             {\n                 Dsymbol s2 = os.a[j];\n                 if (s.toAlias() == s2.toAlias())\n@@ -1674,7 +1674,7 @@ public:\n                 importedScopes = new Dsymbols();\n             else\n             {\n-                for (size_t i = 0; i < importedScopes.dim; i++)\n+                for (size_t i = 0; i < importedScopes.length; i++)\n                 {\n                     Dsymbol ss = (*importedScopes)[i];\n                     if (ss == s) // if already imported\n@@ -1686,8 +1686,8 @@ public:\n                 }\n             }\n             importedScopes.push(s);\n-            visibilities = cast(Visibility.Kind*)mem.xrealloc(visibilities, importedScopes.dim * (visibilities[0]).sizeof);\n-            visibilities[importedScopes.dim - 1] = visibility.kind;\n+            visibilities = cast(Visibility.Kind*)mem.xrealloc(visibilities, importedScopes.length * (visibilities[0]).sizeof);\n+            visibilities[importedScopes.length - 1] = visibility.kind;\n         }\n     }\n \n@@ -1714,7 +1714,7 @@ public:\n         if (!importedScopes)\n             return null;\n \n-        return (() @trusted => visibilities[0 .. importedScopes.dim])();\n+        return (() @trusted => visibilities[0 .. importedScopes.length])();\n     }\n \n     extern (D) final void addAccessiblePackage(Package p, Visibility visibility) nothrow\n@@ -1755,9 +1755,9 @@ public:\n         }\n         if (loc.isValid())\n         {\n-            .error(loc, \"%s `%s` at %s conflicts with %s `%s` at %s\",\n-                s1.kind(), s1.toPrettyChars(), s1.locToChars(),\n-                s2.kind(), s2.toPrettyChars(), s2.locToChars());\n+            .error(loc, \"`%s` matches conflicting symbols:\", s1.ident.toChars());\n+            errorSupplemental(s1.loc, \"%s `%s`\", s1.kind(), s1.toPrettyChars());\n+            errorSupplemental(s2.loc, \"%s `%s`\", s2.kind(), s2.toPrettyChars());\n \n             static if (0)\n             {\n@@ -1854,7 +1854,7 @@ public:\n     {\n         if (members)\n         {\n-            for (size_t i = 0; i < members.dim; i++)\n+            for (size_t i = 0; i < members.length; i++)\n             {\n                 Dsymbol member = (*members)[i];\n                 if (member.hasStaticCtorOrDtor())\n@@ -1883,7 +1883,7 @@ public:\n             return 0;\n         size_t n = pn ? *pn : 0; // take over index\n         int result = 0;\n-        foreach (size_t i; 0 .. members.dim)\n+        foreach (size_t i; 0 .. members.length)\n         {\n             Dsymbol s = (*members)[i];\n             if (AttribDeclaration a = s.isAttribDeclaration())\n@@ -2020,7 +2020,7 @@ extern (C++) final class ArrayScopeSymbol : ScopeDsymbol\n             /* $ gives the number of type entries in the type tuple\n              */\n             auto v = new VarDeclaration(loc, Type.tsize_t, Id.dollar, null);\n-            Expression e = new IntegerExp(Loc.initial, tt.arguments.dim, Type.tsize_t);\n+            Expression e = new IntegerExp(Loc.initial, tt.arguments.length, Type.tsize_t);\n             v._init = new ExpInitializer(Loc.initial, e);\n             v.storage_class |= STC.temp | STC.static_ | STC.const_;\n             v.dsymbolSemantic(sc);\n@@ -2035,7 +2035,7 @@ extern (C++) final class ArrayScopeSymbol : ScopeDsymbol\n             /* $ gives the number of elements in the tuple\n              */\n             auto v = new VarDeclaration(loc, Type.tsize_t, Id.dollar, null);\n-            Expression e = new IntegerExp(Loc.initial, td.objects.dim, Type.tsize_t);\n+            Expression e = new IntegerExp(Loc.initial, td.objects.length, Type.tsize_t);\n             v._init = new ExpInitializer(Loc.initial, e);\n             v.storage_class |= STC.temp | STC.static_ | STC.const_;\n             v.dsymbolSemantic(sc);\n@@ -2098,7 +2098,7 @@ extern (C++) final class ArrayScopeSymbol : ScopeDsymbol\n                 /* It is for an expression tuple, so the\n                  * length will be a const.\n                  */\n-                Expression e = new IntegerExp(Loc.initial, tupexp.exps.dim, Type.tsize_t);\n+                Expression e = new IntegerExp(Loc.initial, tupexp.exps.length, Type.tsize_t);\n                 v = new VarDeclaration(loc, Type.tsize_t, Id.dollar, new ExpInitializer(Loc.initial, e));\n                 v.storage_class |= STC.temp | STC.static_ | STC.const_;\n             }\n@@ -2142,7 +2142,7 @@ extern (C++) final class ArrayScopeSymbol : ScopeDsymbol\n                      * Note that it's impossible to have both template & function opDollar,\n                      * because both take no arguments.\n                      */\n-                    if (exp.op == EXP.array && (cast(ArrayExp)exp).arguments.dim != 1)\n+                    if (exp.op == EXP.array && (cast(ArrayExp)exp).arguments.length != 1)\n                     {\n                         exp.error(\"`%s` only defines opDollar for one dimension\", ad.toChars());\n                         return null;"}, {"sha": "b842dc850d1aec9a060a2fa4949e79989a3d97b3", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 86, "deletions": 83, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -559,27 +559,27 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 auto iexps = new Expressions();\n                 iexps.push(ie);\n                 auto exps = new Expressions();\n-                for (size_t pos = 0; pos < iexps.dim; pos++)\n+                for (size_t pos = 0; pos < iexps.length; pos++)\n                 {\n                 Lexpand1:\n                     Expression e = (*iexps)[pos];\n                     Parameter arg = Parameter.getNth(tt.arguments, pos);\n                     arg.type = arg.type.typeSemantic(dsym.loc, sc);\n-                    //printf(\"[%d] iexps.dim = %d, \", pos, iexps.dim);\n+                    //printf(\"[%d] iexps.length = %d, \", pos, iexps.length);\n                     //printf(\"e = (%s %s, %s), \", Token.tochars[e.op], e.toChars(), e.type.toChars());\n                     //printf(\"arg = (%s, %s)\\n\", arg.toChars(), arg.type.toChars());\n \n                     if (e != ie)\n                     {\n-                        if (iexps.dim > nelems)\n+                        if (iexps.length > nelems)\n                             goto Lnomatch;\n                         if (e.type.implicitConvTo(arg.type))\n                             continue;\n                     }\n \n                     if (auto te = e.isTupleExp())\n                     {\n-                        if (iexps.dim - 1 + te.exps.dim > nelems)\n+                        if (iexps.length - 1 + te.exps.length > nelems)\n                             goto Lnomatch;\n \n                         iexps.remove(pos);\n@@ -598,17 +598,17 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                         (*exps)[0] = ve;\n                         expandAliasThisTuples(exps, 0);\n \n-                        for (size_t u = 0; u < exps.dim; u++)\n+                        for (size_t u = 0; u < exps.length; u++)\n                         {\n                         Lexpand2:\n                             Expression ee = (*exps)[u];\n                             arg = Parameter.getNth(tt.arguments, pos + u);\n                             arg.type = arg.type.typeSemantic(dsym.loc, sc);\n-                            //printf(\"[%d+%d] exps.dim = %d, \", pos, u, exps.dim);\n+                            //printf(\"[%d+%d] exps.length = %d, \", pos, u, exps.length);\n                             //printf(\"ee = (%s %s, %s), \", Token.tochars[ee.op], ee.toChars(), ee.type.toChars());\n                             //printf(\"arg = (%s, %s)\\n\", arg.toChars(), arg.type.toChars());\n \n-                            size_t iexps_dim = iexps.dim - 1 + exps.dim;\n+                            size_t iexps_dim = iexps.length - 1 + exps.length;\n                             if (iexps_dim > nelems)\n                                 goto Lnomatch;\n                             if (ee.type.implicitConvTo(arg.type))\n@@ -630,7 +630,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                         }\n                     }\n                 }\n-                if (iexps.dim < nelems)\n+                if (iexps.length < nelems)\n                     goto Lnomatch;\n \n                 ie = new TupleExp(dsym._init.loc, iexps);\n@@ -640,7 +640,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             if (ie && ie.op == EXP.tuple)\n             {\n                 auto te = ie.isTupleExp();\n-                size_t tedim = te.exps.dim;\n+                size_t tedim = te.exps.length;\n                 if (tedim != nelems)\n                 {\n                     error(dsym.loc, \"tuple of %d elements cannot be assigned to tuple of %d elements\", cast(int)tedim, cast(int)nelems);\n@@ -1065,7 +1065,8 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                         else if (auto ale = ex.isArrayLiteralExp())\n                         {\n                             // or an array literal assigned to a `scope` variable\n-                            if (!dsym.type.nextOf().needsDestruction())\n+                            if (global.params.useDIP1000 == FeatureState.enabled\n+                                && !dsym.type.nextOf().needsDestruction())\n                                 ale.onstack = true;\n                         }\n                     }\n@@ -1333,7 +1334,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             if (sc.explicitVisibility)\n                 imp.visibility = sc.visibility;\n \n-            if (!imp.aliasId && !imp.names.dim) // neither a selective nor a renamed import\n+            if (!imp.aliasId && !imp.names.length) // neither a selective nor a renamed import\n             {\n                 ScopeDsymbol scopesym = sc.getScopesym();\n \n@@ -1359,7 +1360,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n             sc = sc.push(imp.mod);\n             sc.visibility = imp.visibility;\n-            for (size_t i = 0; i < imp.aliasdecls.dim; i++)\n+            for (size_t i = 0; i < imp.aliasdecls.length; i++)\n             {\n                 AliasDeclaration ad = imp.aliasdecls[i];\n                 //printf(\"\\tImport %s alias %s = %s, scope = %p\\n\", toPrettyChars(), aliases[i].toChars(), names[i].toChars(), ad._scope);\n@@ -1471,7 +1472,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         {\n             Scope* sc2 = ad.newScope(sc);\n             bool errors;\n-            for (size_t i = 0; i < d.dim; i++)\n+            for (size_t i = 0; i < d.length; i++)\n             {\n                 Dsymbol s = (*d)[i];\n                 s.dsymbolSemantic(sc2);\n@@ -1509,7 +1510,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         sc.stc &= ~(STC.auto_ | STC.scope_ | STC.static_ | STC.gshared);\n         sc.inunion = scd.isunion ? scd : null;\n         sc.flags = 0;\n-        for (size_t i = 0; i < scd.decl.dim; i++)\n+        for (size_t i = 0; i < scd.decl.length; i++)\n         {\n             Dsymbol s = (*scd.decl)[i];\n             if (auto var = s.isVarDeclaration)\n@@ -1627,7 +1628,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     if (agg)\n                     {\n                         ad.pMangleOverride.agg = agg;\n-                        if (pd.args.dim == 2)\n+                        if (pd.args.length == 2)\n                         {\n                             setString((*pd.args)[1]);\n                         }\n@@ -1668,7 +1669,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         {\n             if (pd.ident == Id.linkerDirective)\n             {\n-                if (!pd.args || pd.args.dim != 1)\n+                if (!pd.args || pd.args.length != 1)\n                     pd.error(\"one string argument expected for pragma(linkerDirective)\");\n                 else\n                 {\n@@ -1694,7 +1695,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         }\n         else if (pd.ident == Id.lib)\n         {\n-            if (!pd.args || pd.args.dim != 1)\n+            if (!pd.args || pd.args.length != 1)\n                 pd.error(\"string expected for library name\");\n             else\n             {\n@@ -1737,9 +1738,9 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         {\n             if (!pd.args)\n                 pd.args = new Expressions();\n-            if (pd.args.dim == 0 || pd.args.dim > 2)\n+            if (pd.args.length == 0 || pd.args.length > 2)\n             {\n-                pd.error(pd.args.dim == 0 ? \"string expected for mangled name\"\n+                pd.error(pd.args.length == 0 ? \"string expected for mangled name\"\n                                           : \"expected 1 or 2 arguments\");\n                 pd.args.setDim(1);\n                 (*pd.args)[0] = ErrorExp.get(); // error recovery\n@@ -1748,7 +1749,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         }\n         else if (pd.ident == Id.crt_constructor || pd.ident == Id.crt_destructor)\n         {\n-            if (pd.args && pd.args.dim != 0)\n+            if (pd.args && pd.args.length != 0)\n                 pd.error(\"takes no argument\");\n             else\n             {\n@@ -1762,7 +1763,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                         auto decls = ad.include(null);\n                         if (decls)\n                         {\n-                            for (size_t i = 0; i < decls.dim; ++i)\n+                            for (size_t i = 0; i < decls.length; ++i)\n                                 nestedCount += recurse((*decls)[i], isCtor);\n                         }\n                         return nestedCount;\n@@ -1788,7 +1789,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         }\n         else if (pd.ident == Id.printf || pd.ident == Id.scanf)\n         {\n-            if (pd.args && pd.args.dim != 0)\n+            if (pd.args && pd.args.length != 0)\n                 pd.error(\"takes no argument\");\n             return declarations();\n         }\n@@ -1808,7 +1809,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         if (pd.args)\n         {\n             const errors_save = global.startGagging();\n-            for (size_t i = 0; i < pd.args.dim; i++)\n+            for (size_t i = 0; i < pd.args.length; i++)\n             {\n                 Expression e = (*pd.args)[i];\n                 sc = sc.startCTFE();\n@@ -1822,7 +1823,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     buf.writeByte(',');\n                 buf.writestring(e.toChars());\n             }\n-            if (pd.args.dim)\n+            if (pd.args.length)\n                 buf.writeByte(')');\n             global.endGagging(errors_save);\n         }\n@@ -1880,7 +1881,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n             if (cd._scope && cd.decl)\n             {\n-                for (size_t i = 0; i < cd.decl.dim; i++)\n+                for (size_t i = 0; i < cd.decl.length; i++)\n                 {\n                     Dsymbol s = (*cd.decl)[i];\n                     s.setScope(cd._scope);\n@@ -1919,11 +1920,11 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         {\n             expandTuples(te.exps);\n             CPPNamespaceDeclaration current = ns.cppnamespace;\n-            for (size_t d = 0; d < te.exps.dim; ++d)\n+            for (size_t d = 0; d < te.exps.length; ++d)\n             {\n                 auto exp = (*te.exps)[d];\n                 auto prev = d ? current : ns.cppnamespace;\n-                current = (d + 1) != te.exps.dim\n+                current = (d + 1) != te.exps.length\n                     ? new CPPNamespaceDeclaration(ns.loc, exp, null)\n                     : ns;\n                 current.exp = exp;\n@@ -2122,7 +2123,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             return;\n         }\n \n-        if (ed.members.dim == 0)\n+        if (ed.members.length == 0)\n         {\n             ed.error(\"enum `%s` must have at least one member\", ed.toChars());\n             ed.errors = true;\n@@ -2566,15 +2567,15 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         if (global.params.ddoc.doOutput)\n         {\n-            tempdecl.origParameters = new TemplateParameters(tempdecl.parameters.dim);\n-            for (size_t i = 0; i < tempdecl.parameters.dim; i++)\n+            tempdecl.origParameters = new TemplateParameters(tempdecl.parameters.length);\n+            for (size_t i = 0; i < tempdecl.parameters.length; i++)\n             {\n                 TemplateParameter tp = (*tempdecl.parameters)[i];\n                 (*tempdecl.origParameters)[i] = tp.syntaxCopy();\n             }\n         }\n \n-        for (size_t i = 0; i < tempdecl.parameters.dim; i++)\n+        for (size_t i = 0; i < tempdecl.parameters.length; i++)\n         {\n             TemplateParameter tp = (*tempdecl.parameters)[i];\n             if (!tp.declareParameter(paramscope))\n@@ -2586,7 +2587,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             {\n                 tempdecl.errors = true;\n             }\n-            if (i + 1 != tempdecl.parameters.dim && tp.isTemplateTupleParameter())\n+            if (i + 1 != tempdecl.parameters.length && tp.isTemplateTupleParameter())\n             {\n                 tempdecl.error(\"template tuple parameter must be last one\");\n                 tempdecl.errors = true;\n@@ -2596,12 +2597,12 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         /* Calculate TemplateParameter.dependent\n          */\n         TemplateParameters tparams = TemplateParameters(1);\n-        for (size_t i = 0; i < tempdecl.parameters.dim; i++)\n+        for (size_t i = 0; i < tempdecl.parameters.length; i++)\n         {\n             TemplateParameter tp = (*tempdecl.parameters)[i];\n             tparams[0] = tp;\n \n-            for (size_t j = 0; j < tempdecl.parameters.dim; j++)\n+            for (size_t j = 0; j < tempdecl.parameters.length; j++)\n             {\n                 // Skip cases like: X(T : T)\n                 if (i == j)\n@@ -2742,10 +2743,10 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n             /* Different argument list lengths happen with variadic args\n              */\n-            if (tm.tiargs.dim != tmix.tiargs.dim)\n+            if (tm.tiargs.length != tmix.tiargs.length)\n                 continue;\n \n-            for (size_t i = 0; i < tm.tiargs.dim; i++)\n+            for (size_t i = 0; i < tm.tiargs.length; i++)\n             {\n                 RootObject o = (*tm.tiargs)[i];\n                 Type ta = isType(o);\n@@ -2825,7 +2826,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             printf(\"\\tdo semantic() on template instance members '%s'\\n\", tm.toChars());\n         }\n         Scope* sc2 = argscope.push(tm);\n-        //size_t deferred_dim = Module.deferred.dim;\n+        //size_t deferred_dim = Module.deferred.length;\n \n         __gshared int nest;\n         //printf(\"%d\\n\", nest);\n@@ -2848,7 +2849,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n          * Because the members would already call Module.addDeferredSemantic() for themselves.\n          * See Struct, Class, Interface, and EnumDeclaration.dsymbolSemantic().\n          */\n-        //if (!sc.func && Module.deferred.dim > deferred_dim) {}\n+        //if (!sc.func && Module.deferred.length > deferred_dim) {}\n \n         AggregateDeclaration ad = tm.isMember();\n         if (sc.func && !ad)\n@@ -3275,6 +3276,8 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 funcdecl.error(\"must return `void` for `pragma(%s)`\", idStr.ptr);\n             if (funcdecl._linkage != LINK.c && f.parameterList.length != 0)\n                 funcdecl.error(\"must be `extern(C)` for `pragma(%s)` when taking parameters\", idStr.ptr);\n+            if (funcdecl.isThis())\n+                funcdecl.error(\"cannot be a non-static member function for `pragma(%s)`\", idStr.ptr);\n         }\n \n         if (funcdecl.overnext && funcdecl.isCsymbol())\n@@ -3344,7 +3347,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             {\n                 if (!funcdecl.isStatic() || funcdecl.type.nextOf().ty != Tvoid)\n                     funcdecl.error(\"static constructors / destructors must be `static void`\");\n-                if (f.arguments && f.arguments.dim)\n+                if (f.arguments && f.arguments.length)\n                     funcdecl.error(\"static constructors / destructors must have empty parameter list\");\n                 // BUG: check for invalid storage classes\n             }\n@@ -3451,13 +3454,13 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 goto Ldone;\n \n             bool may_override = false;\n-            for (size_t i = 0; i < cd.baseclasses.dim; i++)\n+            for (size_t i = 0; i < cd.baseclasses.length; i++)\n             {\n                 BaseClass* b = (*cd.baseclasses)[i];\n                 ClassDeclaration cbd = b.type.toBasetype().isClassHandle();\n                 if (!cbd)\n                     continue;\n-                for (size_t j = 0; j < cbd.vtbl.dim; j++)\n+                for (size_t j = 0; j < cbd.vtbl.length; j++)\n                 {\n                     FuncDeclaration f2 = cbd.vtbl[j].isFuncDeclaration();\n                     if (!f2 || f2.ident != funcdecl.ident)\n@@ -3481,7 +3484,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             /* Find index of existing function in base class's vtbl[] to override\n              * (the index will be the same as in cd's current vtbl[])\n              */\n-            int vi = cd.baseClass ? funcdecl.findVtblIndex(&cd.baseClass.vtbl, cast(int)cd.baseClass.vtbl.dim) : -1;\n+            int vi = cd.baseClass ? funcdecl.findVtblIndex(&cd.baseClass.vtbl, cast(int)cd.baseClass.vtbl.length) : -1;\n \n             bool doesoverride = false;\n             switch (vi)\n@@ -3513,7 +3516,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                    with offsets to each of the virtual bases.\n                  */\n                 if (target.cpp.splitVBasetable && cd.classKind == ClassKind.cpp &&\n-                    cd.baseClass && cd.baseClass.vtbl.dim)\n+                    cd.baseClass && cd.baseClass.vtbl.length)\n                 {\n                     /* if overriding an interface function, then this is not\n                      * introducing and don't put it in the class vtbl[]\n@@ -3544,7 +3547,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                          * Search for first function of overload group, and insert\n                          * funcdecl into vtbl[] immediately before it.\n                          */\n-                        funcdecl.vtblIndex = cast(int)cd.vtbl.dim;\n+                        funcdecl.vtblIndex = cast(int)cd.vtbl.length;\n                         bool found;\n                         foreach (const i, s; cd.vtbl)\n                         {\n@@ -3574,7 +3577,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     else\n                     {\n                         // Append to end of vtbl[]\n-                        vi = cast(int)cd.vtbl.dim;\n+                        vi = cast(int)cd.vtbl.length;\n                         cd.vtbl.push(funcdecl);\n                         funcdecl.vtblIndex = vi;\n                     }\n@@ -3672,7 +3675,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                              * will be updated at the end of the enclosing `if` block\n                              * to point to the current (non-mixined) function.\n                              */\n-                            auto vitmp = cast(int)cd.vtbl.dim;\n+                            auto vitmp = cast(int)cd.vtbl.length;\n                             cd.vtbl.push(fdc);\n                             fdc.vtblIndex = vitmp;\n                         }\n@@ -3683,7 +3686,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                              * vtbl, but keep the previous (non-mixined) function as\n                              * the overriding one.\n                              */\n-                            auto vitmp = cast(int)cd.vtbl.dim;\n+                            auto vitmp = cast(int)cd.vtbl.length;\n                             cd.vtbl.push(funcdecl);\n                             funcdecl.vtblIndex = vitmp;\n                             break;\n@@ -3743,7 +3746,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             {\n                 foreach (b; bcd.interfaces)\n                 {\n-                    vi = funcdecl.findVtblIndex(&b.sym.vtbl, cast(int)b.sym.vtbl.dim);\n+                    vi = funcdecl.findVtblIndex(&b.sym.vtbl, cast(int)b.sym.vtbl.length);\n                     switch (vi)\n                     {\n                     case -1:\n@@ -3811,7 +3814,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             {\n                 BaseClass* bc = null;\n                 Dsymbol s = null;\n-                for (size_t i = 0; i < cd.baseclasses.dim; i++)\n+                for (size_t i = 0; i < cd.baseclasses.length; i++)\n                 {\n                     bc = (*cd.baseclasses)[i];\n                     s = bc.sym.search_correct(funcdecl.ident);\n@@ -4207,7 +4210,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     else if (!dd.isFinal())\n                     {\n                         // reserve the dtor slot for the destructor (which we'll create later)\n-                        cldec.cppDtorVtblIndex = cast(int)cldec.vtbl.dim;\n+                        cldec.cppDtorVtblIndex = cast(int)cldec.vtbl.length;\n                         cldec.vtbl.push(dd);\n                         if (target.cpp.twoDtorInVtable)\n                             cldec.vtbl.push(dd); // deleting destructor uses a second slot\n@@ -4865,7 +4868,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             cldec.baseok = Baseok.start;\n \n             // Expand any tuples in baseclasses[]\n-            for (size_t i = 0; i < cldec.baseclasses.dim;)\n+            for (size_t i = 0; i < cldec.baseclasses.length;)\n             {\n                 auto b = (*cldec.baseclasses)[i];\n                 b.type = resolveBase(b.type.typeSemantic(cldec.loc, sc));\n@@ -4895,7 +4898,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             }\n \n             // See if there's a base class as first in baseclasses[]\n-            if (cldec.baseclasses.dim)\n+            if (cldec.baseclasses.length)\n             {\n                 BaseClass* b = (*cldec.baseclasses)[0];\n                 Type tb = b.type.toBasetype();\n@@ -4955,7 +4958,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             int multiClassError = cldec.baseClass is null ? 0 : 1;\n \n             BCLoop:\n-            for (size_t i = (cldec.baseClass ? 1 : 0); i < cldec.baseclasses.dim;)\n+            for (size_t i = (cldec.baseClass ? 1 : 0); i < cldec.baseclasses.length;)\n             {\n                 BaseClass* b = (*cldec.baseclasses)[i];\n                 Type tb = b.type.toBasetype();\n@@ -4978,7 +4981,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                                           \" Use multiple interface inheritance and/or composition.\", cldec.toPrettyChars());\n                                 multiClassError += 1;\n \n-                                if (tc.sym.fields.dim)\n+                                if (tc.sym.fields.length)\n                                     errorSupplemental(cldec.loc,\"`%s` has fields, consider making it a member of `%s`\",\n                                                       b.type.toChars(), cldec.type.toChars());\n                                 else\n@@ -5087,7 +5090,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 cldec.storage_class |= cldec.baseClass.storage_class & STC.TYPECTOR;\n             }\n \n-            cldec.interfaces = cldec.baseclasses.tdata()[(cldec.baseClass ? 1 : 0) .. cldec.baseclasses.dim];\n+            cldec.interfaces = cldec.baseclasses.tdata()[(cldec.baseClass ? 1 : 0) .. cldec.baseclasses.length];\n             foreach (b; cldec.interfaces)\n             {\n                 // If this is an interface, and it derives from a COM interface,\n@@ -5133,7 +5136,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             sc2.pop();\n         }\n \n-        for (size_t i = 0; i < cldec.baseclasses.dim; i++)\n+        for (size_t i = 0; i < cldec.baseclasses.length; i++)\n         {\n             BaseClass* b = (*cldec.baseclasses)[i];\n             Type tb = b.type.toBasetype();\n@@ -5156,14 +5159,14 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             // initialize vtbl\n             if (cldec.baseClass)\n             {\n-                if (cldec.classKind == ClassKind.cpp && cldec.baseClass.vtbl.dim == 0)\n+                if (cldec.classKind == ClassKind.cpp && cldec.baseClass.vtbl.length == 0)\n                 {\n                     cldec.error(\"C++ base class `%s` needs at least one virtual function\", cldec.baseClass.toChars());\n                 }\n \n                 // Copy vtbl[] from base class\n-                cldec.vtbl.setDim(cldec.baseClass.vtbl.dim);\n-                memcpy(cldec.vtbl.tdata(), cldec.baseClass.vtbl.tdata(), (void*).sizeof * cldec.vtbl.dim);\n+                cldec.vtbl.setDim(cldec.baseClass.vtbl.length);\n+                memcpy(cldec.vtbl.tdata(), cldec.baseClass.vtbl.tdata(), (void*).sizeof * cldec.vtbl.length);\n \n                 cldec.vthis = cldec.baseClass.vthis;\n                 cldec.vthis2 = cldec.baseClass.vthis2;\n@@ -5237,7 +5240,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         cldec.members.foreachDsymbol( s => s.importAll(sc2) );\n \n-        // Note that members.dim can grow due to tuple expansion during semantic()\n+        // Note that members.length can grow due to tuple expansion during semantic()\n         cldec.members.foreachDsymbol( s => s.dsymbolSemantic(sc2) );\n \n         if (!cldec.determineFields())\n@@ -5503,7 +5506,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             idec.baseok = Baseok.start;\n \n             // Expand any tuples in baseclasses[]\n-            for (size_t i = 0; i < idec.baseclasses.dim;)\n+            for (size_t i = 0; i < idec.baseclasses.length;)\n             {\n                 auto b = (*idec.baseclasses)[i];\n                 b.type = resolveBase(b.type.typeSemantic(idec.loc, sc));\n@@ -5532,7 +5535,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 goto Lancestorsdone;\n             }\n \n-            if (!idec.baseclasses.dim && sc.linkage == LINK.cpp)\n+            if (!idec.baseclasses.length && sc.linkage == LINK.cpp)\n                 idec.classKind = ClassKind.cpp;\n             idec.cppnamespace = sc.namespace;\n             UserAttributeDeclaration.checkGNUABITag(idec, sc.linkage);\n@@ -5543,7 +5546,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n             // Check for errors, handle forward references\n             BCLoop:\n-            for (size_t i = 0; i < idec.baseclasses.dim;)\n+            for (size_t i = 0; i < idec.baseclasses.length;)\n             {\n                 BaseClass* b = (*idec.baseclasses)[i];\n                 Type tb = b.type.toBasetype();\n@@ -5603,7 +5606,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             }\n             idec.baseok = Baseok.done;\n \n-            idec.interfaces = idec.baseclasses.tdata()[0 .. idec.baseclasses.dim];\n+            idec.interfaces = idec.baseclasses.tdata()[0 .. idec.baseclasses.length];\n             foreach (b; idec.interfaces)\n             {\n                 // If this is an interface, and it derives from a COM interface,\n@@ -5626,7 +5629,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         if (!idec.symtab)\n             idec.symtab = new DsymbolTable();\n \n-        for (size_t i = 0; i < idec.baseclasses.dim; i++)\n+        for (size_t i = 0; i < idec.baseclasses.length; i++)\n         {\n             BaseClass* b = (*idec.baseclasses)[i];\n             Type tb = b.type.toBasetype();\n@@ -5662,7 +5665,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 // Copy vtbl[] from base class\n                 if (b.sym.vtblOffset())\n                 {\n-                    size_t d = b.sym.vtbl.dim;\n+                    size_t d = b.sym.vtbl.length;\n                     if (d > 1)\n                     {\n                         idec.vtbl.pushSlice(b.sym.vtbl[1 .. d]);\n@@ -6055,13 +6058,13 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n     // Store the place we added it to in target_symbol_list(_idx) so we can\n     // remove it later if we encounter an error.\n     Dsymbols* target_symbol_list = tempinst.appendToModuleMember();\n-    size_t target_symbol_list_idx = target_symbol_list ? target_symbol_list.dim - 1 : 0;\n+    size_t target_symbol_list_idx = target_symbol_list ? target_symbol_list.length - 1 : 0;\n \n     // Copy the syntax trees from the TemplateDeclaration\n     tempinst.members = Dsymbol.arraySyntaxCopy(tempdecl.members);\n \n     // resolve TemplateThisParameter\n-    for (size_t i = 0; i < tempdecl.parameters.dim; i++)\n+    for (size_t i = 0; i < tempdecl.parameters.length; i++)\n     {\n         if ((*tempdecl.parameters)[i].isTemplateThisParameter() is null)\n             continue;\n@@ -6126,8 +6129,8 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n      * member has the same name as the template instance.\n      * If so, this template instance becomes an alias for that member.\n      */\n-    //printf(\"members.dim = %d\\n\", tempinst.members.dim);\n-    if (tempinst.members.dim)\n+    //printf(\"members.length = %d\\n\", tempinst.members.length);\n+    if (tempinst.members.length)\n     {\n         Dsymbol s;\n         if (Dsymbol.oneMembers(tempinst.members, &s, tempdecl.ident) && s)\n@@ -6172,7 +6175,7 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n     /* ConditionalDeclaration may introduce eponymous declaration,\n      * so we should find it once again after semantic.\n      */\n-    if (tempinst.members.dim)\n+    if (tempinst.members.length)\n     {\n         Dsymbol s;\n         if (Dsymbol.oneMembers(tempinst.members, &s, tempdecl.ident) && s)\n@@ -6195,7 +6198,7 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n      */\n     {\n         bool found_deferred_ad = false;\n-        for (size_t i = 0; i < Module.deferred.dim; i++)\n+        for (size_t i = 0; i < Module.deferred.length; i++)\n         {\n             Dsymbol sd = Module.deferred[i];\n             AggregateDeclaration ad = sd.isAggregateDeclaration();\n@@ -6211,7 +6214,7 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n                 }\n             }\n         }\n-        if (found_deferred_ad || Module.deferred.dim)\n+        if (found_deferred_ad || Module.deferred.length)\n             goto Laftersemantic;\n     }\n \n@@ -6245,7 +6248,7 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n         //printf(\"Run semantic3 on %s\\n\", toChars());\n         tempinst.trySemantic3(sc2);\n \n-        for (size_t i = 0; i < deferred.dim; i++)\n+        for (size_t i = 0; i < deferred.length; i++)\n         {\n             //printf(\"+ run deferred semantic3 on %s\\n\", deferred[i].toChars());\n             deferred[i].semantic3(null);\n@@ -6288,7 +6291,7 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n                 {\n                     if (!td.literal)\n                         continue;\n-                    assert(td.members && td.members.dim == 1);\n+                    assert(td.members && td.members.length == 1);\n                     s = (*td.members)[0];\n                 }\n                 if (auto fld = s.isFuncLiteralDeclaration())\n@@ -6322,7 +6325,7 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n             //printf(\"deferred semantic3 of %p %s, ti = %s, ti.deferred = %p\\n\", this, toChars(), ti.toChars());\n             for (size_t i = 0;; i++)\n             {\n-                if (i == ti.deferred.dim)\n+                if (i == ti.deferred.length)\n                 {\n                     ti.deferred.push(tempinst);\n                     break;\n@@ -6553,7 +6556,7 @@ void aliasSemantic(AliasDeclaration ds, Scope* sc)\n         // Selective imports are allowed to alias to the same name `import mod : sym=sym`.\n         if (!ds._import)\n         {\n-            if (tident.ident is ds.ident && !tident.idents.dim)\n+            if (tident.ident is ds.ident && !tident.idents.length)\n             {\n                 error(ds.loc, \"`alias %s = %s;` cannot alias itself, use a qualified name to create an overload set\",\n                     ds.ident.toChars(), tident.ident.toChars());\n@@ -6958,7 +6961,7 @@ private TupleDeclaration aliasAssignInPlace(Scope* sc, TemplateInstance tempinst\n private TemplateInstance isAliasSeq(Scope* sc, TypeInstance ti)\n {\n     auto tovers = ti.tempinst.tempdecl.isOverloadSet();\n-    foreach (size_t oi; 0 .. tovers ? tovers.a.dim : 1)\n+    foreach (size_t oi; 0 .. tovers ? tovers.a.length : 1)\n     {\n         Dsymbol dstart = tovers ? tovers.a[oi] : ti.tempinst.tempdecl;\n         int r = overloadApply(dstart, (Dsymbol s)\n@@ -6994,7 +6997,7 @@ bool determineFields(AggregateDeclaration ad)\n     if (ad.sizeok != Sizeok.none)\n         return true;\n \n-    //printf(\"determineFields() %s, fields.dim = %d\\n\", toChars(), fields.dim);\n+    //printf(\"determineFields() %s, fields.length = %d\\n\", toChars(), fields.length);\n     // determineFields can be called recursively from one of the fields's v.semantic\n     ad.fields.setDim(0);\n \n@@ -7046,7 +7049,7 @@ bool determineFields(AggregateDeclaration ad)\n \n     if (ad.members)\n     {\n-        for (size_t i = 0; i < ad.members.dim; i++)\n+        for (size_t i = 0; i < ad.members.length; i++)\n         {\n             auto s = (*ad.members)[i];\n             if (s.apply(&func, ad))\n@@ -7123,12 +7126,12 @@ private CallExp doAtomicOp (string op, Identifier var, Expression arg)\n  */\n PINLINE evalPragmaInline(Loc loc, Scope* sc, Expressions* args)\n {\n-    if (!args || args.dim == 0)\n+    if (!args || args.length == 0)\n         return PINLINE.default_;\n \n-    if (args && args.dim > 1)\n+    if (args && args.length > 1)\n     {\n-        .error(loc, \"one boolean expression expected for `pragma(inline)`, not %llu\", cast(ulong) args.dim);\n+        .error(loc, \"one boolean expression expected for `pragma(inline)`, not %llu\", cast(ulong) args.length);\n         args.setDim(1);\n         (*args)[0] = ErrorExp.get();\n     }"}, {"sha": "6095dcc9a1ea0607aa389e274cf7229bba2d14d2", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 149, "deletions": 139, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -362,9 +362,9 @@ private bool arrayObjectMatch(Objects* oa1, Objects* oa2)\n {\n     if (oa1 == oa2)\n         return true;\n-    if (oa1.dim != oa2.dim)\n+    if (oa1.length != oa2.length)\n         return false;\n-    immutable oa1dim = oa1.dim;\n+    immutable oa1dim = oa1.length;\n     auto oa1d = (*oa1)[].ptr;\n     auto oa2d = (*oa2)[].ptr;\n     foreach (j; 0 .. oa1dim)\n@@ -454,7 +454,7 @@ private size_t expressionHash(Expression e)\n     {\n         auto ae = e.isArrayLiteralExp();\n         size_t hash;\n-        foreach (i; 0 .. ae.elements.dim)\n+        foreach (i; 0 .. ae.elements.length)\n             hash = mixHash(hash, expressionHash(ae[i]));\n         return hash;\n     }\n@@ -463,7 +463,7 @@ private size_t expressionHash(Expression e)\n     {\n         auto ae = e.isAssocArrayLiteralExp();\n         size_t hash;\n-        foreach (i; 0 .. ae.keys.dim)\n+        foreach (i; 0 .. ae.keys.length)\n             // reduction needs associative op as keys are unsorted (use XOR)\n             hash ^= mixHash(expressionHash((*ae.keys)[i]), expressionHash((*ae.values)[i]));\n         return hash;\n@@ -586,7 +586,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n         version (none)\n         {\n             if (parameters)\n-                for (int i = 0; i < parameters.dim; i++)\n+                for (int i = 0; i < parameters.length; i++)\n                 {\n                     TemplateParameter tp = (*parameters)[i];\n                     //printf(\"\\tparameter[%d] = %p\\n\", i, tp);\n@@ -660,7 +660,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n         TemplateParameters* p = null;\n         if (parameters)\n         {\n-            p = new TemplateParameters(parameters.dim);\n+            p = new TemplateParameters(parameters.length);\n             foreach (i, ref param; *p)\n                 param = (*parameters)[i].syntaxCopy();\n         }\n@@ -1059,9 +1059,9 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n         }\n         version (none)\n         {\n-            printf(\"dedtypes.dim = %d, parameters.dim = %d\\n\", dedtypes.dim, parameters.dim);\n-            if (ti.tiargs.dim)\n-                printf(\"ti.tiargs.dim = %d, [0] = %p\\n\", ti.tiargs.dim, (*ti.tiargs)[0]);\n+            printf(\"dedtypes.length = %d, parameters.length = %d\\n\", dedtypes.length, parameters.length);\n+            if (ti.tiargs.length)\n+                printf(\"ti.tiargs.length = %d, [0] = %p\\n\", ti.tiargs.length, (*ti.tiargs)[0]);\n         }\n         MATCH nomatch()\n         {\n@@ -1072,18 +1072,18 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n             return MATCH.nomatch;\n         }\n         MATCH m;\n-        size_t dedtypes_dim = dedtypes.dim;\n+        size_t dedtypes_dim = dedtypes.length;\n \n         dedtypes.zero();\n \n         if (errors)\n             return MATCH.nomatch;\n \n-        size_t parameters_dim = parameters.dim;\n+        size_t parameters_dim = parameters.length;\n         int variadic = isVariadic() !is null;\n \n         // If more arguments than parameters, no match\n-        if (ti.tiargs.dim > parameters_dim && !variadic)\n+        if (ti.tiargs.length > parameters_dim && !variadic)\n         {\n             static if (LOGM)\n             {\n@@ -1093,7 +1093,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n         }\n \n         assert(dedtypes_dim == parameters_dim);\n-        assert(dedtypes_dim >= ti.tiargs.dim || variadic);\n+        assert(dedtypes_dim >= ti.tiargs.length || variadic);\n \n         assert(_scope);\n \n@@ -1152,7 +1152,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n             {\n                 if (!dedtype)\n                 {\n-                    assert(i < ti.tiargs.dim);\n+                    assert(i < ti.tiargs.length);\n                     dedtype = cast(Type)(*ti.tiargs)[i];\n                 }\n             }\n@@ -1210,7 +1210,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                     TemplateParameter tp = (*parameters)[i];\n                     RootObject oarg;\n                     printf(\" [%d]\", i);\n-                    if (i < ti.tiargs.dim)\n+                    if (i < ti.tiargs.length)\n                         oarg = (*ti.tiargs)[i];\n                     else\n                         oarg = null;\n@@ -1257,7 +1257,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n         // Set type arguments to dummy template instance to be types\n         // generated from the parameters to this template declaration\n         auto tiargs = new Objects();\n-        tiargs.reserve(parameters.dim);\n+        tiargs.reserve(parameters.length);\n         foreach (tp; *parameters)\n         {\n             if (tp.dependent)\n@@ -1271,7 +1271,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n         scope TemplateInstance ti = new TemplateInstance(Loc.initial, ident, tiargs); // create dummy template instance\n \n         // Temporary Array to hold deduced types\n-        Objects dedtypes = Objects(td2.parameters.dim);\n+        Objects dedtypes = Objects(td2.parameters.length);\n \n         // Attempt a type deduction\n         MATCH m = td2.matchWithInstance(sc, ti, &dedtypes, fargs, 1);\n@@ -1327,13 +1327,13 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n \n         Loc instLoc = ti.loc;\n         Objects* tiargs = ti.tiargs;\n-        auto dedargs = new Objects(parameters.dim);\n+        auto dedargs = new Objects(parameters.length);\n         Objects* dedtypes = &ti.tdtypes; // for T:T*, the dedargs is the T*, dedtypes is the T\n \n         version (none)\n         {\n             printf(\"\\nTemplateDeclaration.deduceFunctionTemplateMatch() %s\\n\", toChars());\n-            for (size_t i = 0; i < (fargs ? fargs.dim : 0); i++)\n+            for (size_t i = 0; i < (fargs ? fargs.length : 0); i++)\n             {\n                 Expression e = (*fargs)[i];\n                 printf(\"\\tfarg[%d] is %s, type is %s\\n\", i, e.toChars(), e.type.toChars());\n@@ -1348,7 +1348,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n \n         dedargs.zero();\n \n-        dedtypes.setDim(parameters.dim);\n+        dedtypes.setDim(parameters.length);\n         dedtypes.zero();\n \n         if (errors || fd.errors)\n@@ -1381,7 +1381,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n \n         version (none)\n         {\n-            for (size_t i = 0; i < dedargs.dim; i++)\n+            for (size_t i = 0; i < dedargs.length; i++)\n             {\n                 printf(\"\\tdedarg[%d] = \", i);\n                 RootObject oarg = (*dedargs)[i];\n@@ -1395,8 +1395,8 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n         if (tiargs)\n         {\n             // Set initial template arguments\n-            ntargs = tiargs.dim;\n-            size_t n = parameters.dim;\n+            ntargs = tiargs.length;\n+            size_t n = parameters.length;\n             if (tp)\n                 n--;\n             if (ntargs > n)\n@@ -1408,10 +1408,10 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                  * now form the tuple argument.\n                  */\n                 auto t = new Tuple(ntargs - n);\n-                assert(parameters.dim);\n-                (*dedargs)[parameters.dim - 1] = t;\n+                assert(parameters.length);\n+                (*dedargs)[parameters.length - 1] = t;\n \n-                for (size_t i = 0; i < t.objects.dim; i++)\n+                for (size_t i = 0; i < t.objects.length; i++)\n                 {\n                     t.objects[i] = (*tiargs)[n + i];\n                 }\n@@ -1425,7 +1425,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n \n             for (size_t i = 0; i < n; i++)\n             {\n-                assert(i < parameters.dim);\n+                assert(i < parameters.length);\n                 Declaration sparam = null;\n                 MATCH m = (*parameters)[i].matchArg(instLoc, paramscope, dedargs, i, parameters, dedtypes, &sparam);\n                 //printf(\"\\tdeduceType m = %d\\n\", m);\n@@ -1438,17 +1438,17 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                 if (!paramscope.insert(sparam))\n                     return nomatch();\n             }\n-            if (n < parameters.dim && !declaredTuple)\n+            if (n < parameters.length && !declaredTuple)\n             {\n                 inferStart = n;\n             }\n             else\n-                inferStart = parameters.dim;\n+                inferStart = parameters.length;\n             //printf(\"tiargs matchTiargs = %d\\n\", matchTiargs);\n         }\n         version (none)\n         {\n-            for (size_t i = 0; i < dedargs.dim; i++)\n+            for (size_t i = 0; i < dedargs.length; i++)\n             {\n                 printf(\"\\tdedarg[%d] = \", i);\n                 RootObject oarg = (*dedargs)[i];\n@@ -1460,7 +1460,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n \n         fparameters = fd.getParameterList();\n         nfparams = fparameters.length; // number of function parameters\n-        nfargs = fargs ? fargs.dim : 0; // number of function arguments\n+        nfargs = fargs ? fargs.length : 0; // number of function arguments\n \n         /* Check for match of function arguments with variadic template\n          * parameter, such as:\n@@ -1479,7 +1479,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                 {\n                     auto t = new Tuple();\n                     //printf(\"t = %p\\n\", t);\n-                    (*dedargs)[parameters.dim - 1] = t;\n+                    (*dedargs)[parameters.length - 1] = t;\n                     declareParameter(paramscope, tp, t);\n                     declaredTuple = t;\n                 }\n@@ -1497,7 +1497,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                     if (fparam.type.ty != Tident)\n                         continue;\n                     TypeIdentifier tid = cast(TypeIdentifier)fparam.type;\n-                    if (!tp.ident.equals(tid.ident) || tid.idents.dim)\n+                    if (!tp.ident.equals(tid.ident) || tid.idents.length)\n                         continue;\n \n                     if (fparameters.varargs != VarArg.none) // variadic function doesn't\n@@ -1570,7 +1570,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n \n         // Loop through the function parameters\n         {\n-            //printf(\"%s\\n\\tnfargs = %d, nfparams = %d, tuple_dim = %d\\n\", toChars(), nfargs, nfparams, declaredTuple ? declaredTuple.objects.dim : 0);\n+            //printf(\"%s\\n\\tnfargs = %d, nfparams = %d, tuple_dim = %d\\n\", toChars(), nfargs, nfparams, declaredTuple ? declaredTuple.objects.length : 0);\n             //printf(\"\\ttp = %p, fptupindex = %d, found = %d, declaredTuple = %s\\n\", tp, fptupindex, fptupindex != IDX_NOTFOUND, declaredTuple ? declaredTuple.toChars() : NULL);\n             size_t argi = 0;\n             size_t nfargs2 = nfargs; // nfargs + supplied defaultArgs\n@@ -1596,7 +1596,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                          * now form the tuple argument.\n                          */\n                         declaredTuple = new Tuple();\n-                        (*dedargs)[parameters.dim - 1] = declaredTuple;\n+                        (*dedargs)[parameters.length - 1] = declaredTuple;\n \n                         /* Count function parameters with no defaults following a tuple parameter.\n                          * void foo(U, T...)(int y, T, U, double, int bar = 0) {}  // rem == 2 (U, double)\n@@ -1609,10 +1609,10 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                             {\n                                break;\n                             }\n-                            if (!reliesOnTemplateParameters(p.type, (*parameters)[inferStart .. parameters.dim]))\n+                            if (!reliesOnTemplateParameters(p.type, (*parameters)[inferStart .. parameters.length]))\n                             {\n                                 Type pt = p.type.syntaxCopy().typeSemantic(fd.loc, paramscope);\n-                                rem += pt.ty == Ttuple ? (cast(TypeTuple)pt).arguments.dim : 1;\n+                                rem += pt.ty == Ttuple ? (cast(TypeTuple)pt).arguments.length : 1;\n                             }\n                             else\n                             {\n@@ -1623,7 +1623,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                         if (nfargs2 - argi < rem)\n                             return nomatch();\n                         declaredTuple.objects.setDim(nfargs2 - argi - rem);\n-                        for (size_t i = 0; i < declaredTuple.objects.dim; i++)\n+                        for (size_t i = 0; i < declaredTuple.objects.length; i++)\n                         {\n                             farg = (*fargs)[argi + i];\n \n@@ -1665,28 +1665,28 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                         // https://issues.dlang.org/show_bug.cgi?id=6810\n                         // If declared tuple is not a type tuple,\n                         // it cannot be function parameter types.\n-                        for (size_t i = 0; i < declaredTuple.objects.dim; i++)\n+                        for (size_t i = 0; i < declaredTuple.objects.length; i++)\n                         {\n                             if (!isType(declaredTuple.objects[i]))\n                                 return nomatch();\n                         }\n                     }\n                     assert(declaredTuple);\n-                    argi += declaredTuple.objects.dim;\n+                    argi += declaredTuple.objects.length;\n                     continue;\n                 }\n \n                 // If parameter type doesn't depend on inferred template parameters,\n                 // semantic it to get actual type.\n-                if (!reliesOnTemplateParameters(prmtype, (*parameters)[inferStart .. parameters.dim]))\n+                if (!reliesOnTemplateParameters(prmtype, (*parameters)[inferStart .. parameters.length]))\n                 {\n                     // should copy prmtype to avoid affecting semantic result\n                     prmtype = prmtype.syntaxCopy().typeSemantic(fd.loc, paramscope);\n \n                     if (prmtype.ty == Ttuple)\n                     {\n                         TypeTuple tt = cast(TypeTuple)prmtype;\n-                        size_t tt_dim = tt.arguments.dim;\n+                        size_t tt_dim = tt.arguments.length;\n                         for (size_t j = 0; j < tt_dim; j++, ++argi)\n                         {\n                             Parameter p = (*tt.arguments)[j];\n@@ -1748,7 +1748,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                                 dedtype = xt.tded; // 'unbox'\n                             }\n                         }\n-                        for (size_t i = ntargs; i < dedargs.dim; i++)\n+                        for (size_t i = ntargs; i < dedargs.length; i++)\n                         {\n                             TemplateParameter tparam = (*parameters)[i];\n \n@@ -1850,7 +1850,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                         /* Allow expressions that have CT-known boundaries and type [] to match with [dim]\n                          */\n                         Type taai;\n-                        if (argtype.ty == Tarray && (prmtype.ty == Tsarray || prmtype.ty == Taarray && (taai = (cast(TypeAArray)prmtype).index).ty == Tident && (cast(TypeIdentifier)taai).idents.dim == 0))\n+                        if (argtype.ty == Tarray && (prmtype.ty == Tsarray || prmtype.ty == Taarray && (taai = (cast(TypeAArray)prmtype).index).ty == Tident && (cast(TypeIdentifier)taai).idents.length == 0))\n                         {\n                             if (farg.op == EXP.string_)\n                             {\n@@ -1860,7 +1860,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                             else if (farg.op == EXP.arrayLiteral)\n                             {\n                                 ArrayLiteralExp ae = cast(ArrayLiteralExp)farg;\n-                                argtype = ae.type.nextOf().sarrayOf(ae.elements.dim);\n+                                argtype = ae.type.nextOf().sarrayOf(ae.elements.length);\n                             }\n                             else if (farg.op == EXP.slice)\n                             {\n@@ -1872,7 +1872,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n \n                         oarg = argtype;\n                     }\n-                    else if ((fparam.storageClass & STC.out_) == 0 && (argtype.ty == Tarray || argtype.ty == Tpointer) && templateParameterLookup(prmtype, parameters) != IDX_NOTFOUND && (cast(TypeIdentifier)prmtype).idents.dim == 0)\n+                    else if ((fparam.storageClass & STC.out_) == 0 && (argtype.ty == Tarray || argtype.ty == Tpointer) && templateParameterLookup(prmtype, parameters) != IDX_NOTFOUND && (cast(TypeIdentifier)prmtype).idents.length == 0)\n                     {\n                         /* The farg passing to the prmtype always make a copy. Therefore,\n                          * we can shrink the set of the deduced type arguments for prmtype\n@@ -2124,7 +2124,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                 dedtype = at.merge2();\n             }\n         }\n-        for (size_t i = ntargs; i < dedargs.dim; i++)\n+        for (size_t i = ntargs; i < dedargs.length; i++)\n         {\n             TemplateParameter tparam = (*parameters)[i];\n             //printf(\"tparam[%d] = %s\\n\", i, tparam.ident.toChars());\n@@ -2176,7 +2176,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                     // we're one or more arguments short (i.e. no tuple argument)\n                     if (tparam == tp &&\n                         fptupindex == IDX_NOTFOUND &&\n-                        ntargs <= dedargs.dim - 1)\n+                        ntargs <= dedargs.length - 1)\n                     {\n                         // make tuple argument an empty tuple\n                         oded = new Tuple();\n@@ -2215,7 +2215,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n          * As same as the code for 7469 in findBestMatch,\n          * expand a Tuple in dedargs to normalize template arguments.\n          */\n-        if (auto d = dedargs.dim)\n+        if (auto d = dedargs.length)\n         {\n             if (auto va = isTuple((*dedargs)[d - 1]))\n             {\n@@ -2253,7 +2253,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n \n         version (none)\n         {\n-            for (size_t i = 0; i < dedargs.dim; i++)\n+            for (size_t i = 0; i < dedargs.length; i++)\n             {\n                 RootObject o = (*dedargs)[i];\n                 printf(\"\\tdedargs[%d] = %d, %s\\n\", i, o.dyncast(), o.toChars());\n@@ -2515,7 +2515,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n      */\n     TemplateTupleParameter isVariadic()\n     {\n-        size_t dim = parameters.dim;\n+        size_t dim = parameters.length;\n         if (dim == 0)\n             return null;\n         return (*parameters)[dim - 1].isTemplateTupleParameter();\n@@ -2612,14 +2612,14 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n         printf(\"    tiargs:\\n\");\n         if (tiargs)\n         {\n-            for (size_t i = 0; i < tiargs.dim; i++)\n+            for (size_t i = 0; i < tiargs.length; i++)\n             {\n                 RootObject arg = (*tiargs)[i];\n                 printf(\"\\t%s\\n\", arg.toChars());\n             }\n         }\n         printf(\"    fargs:\\n\");\n-        for (size_t i = 0; i < (fargs ? fargs.dim : 0); i++)\n+        for (size_t i = 0; i < (fargs ? fargs.length : 0); i++)\n         {\n             Expression arg = (*fargs)[i];\n             printf(\"\\t%s %s\\n\", arg.type.toChars(), arg.toChars());\n@@ -2645,7 +2645,7 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n         if (fd == m.lastf)\n             return 0;\n         // explicitly specified tiargs never match to non template function\n-        if (tiargs && tiargs.dim > 0)\n+        if (tiargs && tiargs.length > 0)\n             return 0;\n \n         // constructors need a valid scope in order to detect semantic errors\n@@ -2847,7 +2847,7 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n             if (!tiargs)\n                 tiargs = new Objects();\n             auto ti = new TemplateInstance(loc, td, tiargs);\n-            Objects dedtypes = Objects(td.parameters.dim);\n+            Objects dedtypes = Objects(td.parameters.length);\n             assert(td.semanticRun != PASS.initial);\n             MATCH mta = td.matchWithInstance(sc, ti, &dedtypes, fargs, 0);\n             //printf(\"matchWithInstance = %d\\n\", mta);\n@@ -3154,7 +3154,7 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n  */\n private size_t templateIdentifierLookup(Identifier id, TemplateParameters* parameters)\n {\n-    for (size_t i = 0; i < parameters.dim; i++)\n+    for (size_t i = 0; i < parameters.length; i++)\n     {\n         TemplateParameter tp = (*parameters)[i];\n         if (tp.ident.equals(id))\n@@ -3536,7 +3536,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                     /* Need a loc to go with the semantic routine.\n                      */\n                     Loc loc;\n-                    if (parameters.dim)\n+                    if (parameters.length)\n                     {\n                         TemplateParameter tp = (*parameters)[0];\n                         loc = tp.loc;\n@@ -3554,11 +3554,11 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                 TemplateParameter tp = (*parameters)[i];\n \n                 TypeIdentifier tident = cast(TypeIdentifier)tparam;\n-                if (tident.idents.dim > 0)\n+                if (tident.idents.length > 0)\n                 {\n                     //printf(\"matching %s to %s\\n\", tparam.toChars(), t.toChars());\n                     Dsymbol s = t.toDsymbol(sc);\n-                    for (size_t j = tident.idents.dim; j-- > 0;)\n+                    for (size_t j = tident.idents.length; j-- > 0;)\n                     {\n                         RootObject id = tident.idents[j];\n                         if (id.dyncast() == DYNCAST.identifier)\n@@ -3707,7 +3707,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                 /* Need a loc to go with the semantic routine.\n                  */\n                 Loc loc;\n-                if (parameters.dim)\n+                if (parameters.length)\n                 {\n                     TemplateParameter tp = (*parameters)[0];\n                     loc = tp.loc;\n@@ -3845,7 +3845,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                         // The \"type\" (it hasn't been resolved yet) of the function parameter\n                         // does not have a location but the parameter it is related to does,\n                         // so we use that for the resolution (better error message).\n-                        if (inferStart < parameters.dim)\n+                        if (inferStart < parameters.length)\n                         {\n                             TemplateParameter loctp = (*parameters)[inferStart];\n                             loc = loctp.loc;\n@@ -3905,7 +3905,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n \n                     // https://issues.dlang.org/show_bug.cgi?id=15243\n                     // Resolve parameter type if it's not related with template parameters\n-                    if (!reliesOnTemplateParameters(fparam.type, (*parameters)[inferStart .. parameters.dim]))\n+                    if (!reliesOnTemplateParameters(fparam.type, (*parameters)[inferStart .. parameters.length]))\n                     {\n                         auto tx = fparam.type.typeSemantic(Loc.initial, sc);\n                         if (tx.ty == Terror)\n@@ -3933,15 +3933,15 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                     if (fparam.type.ty != Tident)\n                         goto L1;\n                     TypeIdentifier tid = cast(TypeIdentifier)fparam.type;\n-                    if (tid.idents.dim)\n+                    if (tid.idents.length)\n                         goto L1;\n \n                     /* Look through parameters to find tuple matching tid.ident\n                      */\n                     size_t tupi = 0;\n                     for (; 1; tupi++)\n                     {\n-                        if (tupi == parameters.dim)\n+                        if (tupi == parameters.length)\n                             goto L1;\n                         TemplateParameter tx = (*parameters)[tupi];\n                         TemplateTupleParameter tup = tx.isTemplateTupleParameter();\n@@ -3961,7 +3961,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                     {\n                         // Existing deduced argument must be a tuple, and must match\n                         Tuple tup = isTuple(o);\n-                        if (!tup || tup.objects.dim != tuple_dim)\n+                        if (!tup || tup.objects.length != tuple_dim)\n                         {\n                             result = MATCH.nomatch;\n                             return;\n@@ -4023,7 +4023,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n             if (tparam && tparam.ty == Tident)\n             {\n                 TypeIdentifier tp = cast(TypeIdentifier)tparam;\n-                for (size_t i = 0; i < t.idents.dim; i++)\n+                for (size_t i = 0; i < t.idents.length; i++)\n                 {\n                     RootObject id1 = t.idents[i];\n                     RootObject id2 = tp.idents[i];\n@@ -4112,19 +4112,19 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                 {\n                     //printf(\"\\ttest: tempinst.tiargs[%d]\\n\", i);\n                     RootObject o1 = null;\n-                    if (i < t.tempinst.tiargs.dim)\n+                    if (i < t.tempinst.tiargs.length)\n                         o1 = (*t.tempinst.tiargs)[i];\n-                    else if (i < t.tempinst.tdtypes.dim && i < tp.tempinst.tiargs.dim)\n+                    else if (i < t.tempinst.tdtypes.length && i < tp.tempinst.tiargs.length)\n                     {\n                         // Pick up default arg\n                         o1 = t.tempinst.tdtypes[i];\n                     }\n-                    else if (i >= tp.tempinst.tiargs.dim)\n+                    else if (i >= tp.tempinst.tiargs.length)\n                         break;\n \n-                    if (i >= tp.tempinst.tiargs.dim)\n+                    if (i >= tp.tempinst.tiargs.length)\n                     {\n-                        size_t dim = tempdecl.parameters.dim - (tempdecl.isVariadic() ? 1 : 0);\n+                        size_t dim = tempdecl.parameters.length - (tempdecl.isVariadic() ? 1 : 0);\n                         while (i < dim && ((*tempdecl.parameters)[i].dependent || (*tempdecl.parameters)[i].hasDefaultArg()))\n                         {\n                             i++;\n@@ -4137,9 +4137,9 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                     RootObject o2 = (*tp.tempinst.tiargs)[i];\n                     Type t2 = isType(o2);\n \n-                    size_t j = (t2 && t2.ty == Tident && i == tp.tempinst.tiargs.dim - 1)\n+                    size_t j = (t2 && t2.ty == Tident && i == tp.tempinst.tiargs.length - 1)\n                         ? templateParameterLookup(t2, parameters) : IDX_NOTFOUND;\n-                    if (j != IDX_NOTFOUND && j == parameters.dim - 1 &&\n+                    if (j != IDX_NOTFOUND && j == parameters.length - 1 &&\n                         (*parameters)[j].isTemplateTupleParameter())\n                     {\n                         /* Given:\n@@ -4151,12 +4151,12 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n \n                         /* Create tuple from remaining args\n                          */\n-                        size_t vtdim = (tempdecl.isVariadic() ? t.tempinst.tiargs.dim : t.tempinst.tdtypes.dim) - i;\n+                        size_t vtdim = (tempdecl.isVariadic() ? t.tempinst.tiargs.length : t.tempinst.tdtypes.length) - i;\n                         auto vt = new Tuple(vtdim);\n                         for (size_t k = 0; k < vtdim; k++)\n                         {\n                             RootObject o;\n-                            if (k < t.tempinst.tiargs.dim)\n+                            if (k < t.tempinst.tiargs.length)\n                                 o = (*t.tempinst.tiargs)[i + k];\n                             else // Pick up default arg\n                                 o = t.tempinst.tdtypes[i + k];\n@@ -4315,19 +4315,19 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                  *  S!(T).foo\n                  */\n                 TypeInstance tpi = cast(TypeInstance)tparam;\n-                if (tpi.idents.dim)\n+                if (tpi.idents.length)\n                 {\n-                    RootObject id = tpi.idents[tpi.idents.dim - 1];\n+                    RootObject id = tpi.idents[tpi.idents.length - 1];\n                     if (id.dyncast() == DYNCAST.identifier && t.sym.ident.equals(cast(Identifier)id))\n                     {\n                         Type tparent = t.sym.parent.getType();\n                         if (tparent)\n                         {\n                             /* Slice off the .foo in S!(T).foo\n                              */\n-                            tpi.idents.dim--;\n+                            tpi.idents.length--;\n                             result = deduceType(tparent, sc, tpi, parameters, dedtypes, wm);\n-                            tpi.idents.dim++;\n+                            tpi.idents.length++;\n                             return;\n                         }\n                     }\n@@ -4398,18 +4398,18 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n             if (parti)\n             {\n                 // Make a temporary copy of dedtypes so we don't destroy it\n-                auto tmpdedtypes = new Objects(dedtypes.dim);\n-                memcpy(tmpdedtypes.tdata(), dedtypes.tdata(), dedtypes.dim * (void*).sizeof);\n+                auto tmpdedtypes = new Objects(dedtypes.length);\n+                memcpy(tmpdedtypes.tdata(), dedtypes.tdata(), dedtypes.length * (void*).sizeof);\n \n                 auto t = new TypeInstance(Loc.initial, parti);\n                 MATCH m = deduceType(t, sc, tparam, parameters, tmpdedtypes);\n                 if (m > MATCH.nomatch)\n                 {\n                     // If this is the first ever match, it becomes our best estimate\n                     if (numBaseClassMatches == 0)\n-                        memcpy(best.tdata(), tmpdedtypes.tdata(), tmpdedtypes.dim * (void*).sizeof);\n+                        memcpy(best.tdata(), tmpdedtypes.tdata(), tmpdedtypes.length * (void*).sizeof);\n                     else\n-                        for (size_t k = 0; k < tmpdedtypes.dim; ++k)\n+                        for (size_t k = 0; k < tmpdedtypes.length; ++k)\n                         {\n                             // If we've found more than one possible type for a parameter,\n                             // mark it as unknown.\n@@ -4456,19 +4456,19 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                  *  S!(T).foo\n                  */\n                 TypeInstance tpi = cast(TypeInstance)tparam;\n-                if (tpi.idents.dim)\n+                if (tpi.idents.length)\n                 {\n-                    RootObject id = tpi.idents[tpi.idents.dim - 1];\n+                    RootObject id = tpi.idents[tpi.idents.length - 1];\n                     if (id.dyncast() == DYNCAST.identifier && t.sym.ident.equals(cast(Identifier)id))\n                     {\n                         Type tparent = t.sym.parent.getType();\n                         if (tparent)\n                         {\n                             /* Slice off the .foo in S!(T).foo\n                              */\n-                            tpi.idents.dim--;\n+                            tpi.idents.length--;\n                             result = deduceType(tparent, sc, tpi, parameters, dedtypes, wm);\n-                            tpi.idents.dim++;\n+                            tpi.idents.length++;\n                             return;\n                         }\n                     }\n@@ -4487,10 +4487,10 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                 int numBaseClassMatches = 0; // Have we found an interface match?\n \n                 // Our best guess at dedtypes\n-                auto best = new Objects(dedtypes.dim);\n+                auto best = new Objects(dedtypes.length);\n \n                 ClassDeclaration s = t.sym;\n-                while (s && s.baseclasses.dim > 0)\n+                while (s && s.baseclasses.length > 0)\n                 {\n                     // Test the base class\n                     deduceBaseClassParameters(*(*s.baseclasses)[0], sc, tparam, parameters, dedtypes, best, numBaseClassMatches);\n@@ -4510,7 +4510,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                 }\n \n                 // If we got at least one match, copy the known types into dedtypes\n-                memcpy(dedtypes.tdata(), best.tdata(), best.dim * (void*).sizeof);\n+                memcpy(dedtypes.tdata(), best.tdata(), best.length * (void*).sizeof);\n                 result = MATCH.convert;\n                 return;\n             }\n@@ -4536,7 +4536,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n         {\n             //printf(\"Expression.deduceType(e = %s)\\n\", e.toChars());\n             size_t i = templateParameterLookup(tparam, parameters);\n-            if (i == IDX_NOTFOUND || (cast(TypeIdentifier)tparam).idents.dim > 0)\n+            if (i == IDX_NOTFOUND || (cast(TypeIdentifier)tparam).idents.length > 0)\n             {\n                 if (e == emptyArrayElement && tparam.ty == Tarray)\n                 {\n@@ -4721,7 +4721,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n         override void visit(StringExp e)\n         {\n             Type taai;\n-            if (e.type.ty == Tarray && (tparam.ty == Tsarray || tparam.ty == Taarray && (taai = (cast(TypeAArray)tparam).index).ty == Tident && (cast(TypeIdentifier)taai).idents.dim == 0))\n+            if (e.type.ty == Tarray && (tparam.ty == Tsarray || tparam.ty == Taarray && (taai = (cast(TypeAArray)tparam).index).ty == Tident && (cast(TypeIdentifier)taai).idents.length == 0))\n             {\n                 // Consider compile-time known boundaries\n                 e.type.nextOf().sarrayOf(e.len).accept(this);\n@@ -4733,19 +4733,19 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n         override void visit(ArrayLiteralExp e)\n         {\n             // https://issues.dlang.org/show_bug.cgi?id=20092\n-            if (e.elements && e.elements.dim && e.type.toBasetype().nextOf().ty == Tvoid)\n+            if (e.elements && e.elements.length && e.type.toBasetype().nextOf().ty == Tvoid)\n             {\n                 result = deduceEmptyArrayElement();\n                 return;\n             }\n-            if ((!e.elements || !e.elements.dim) && e.type.toBasetype().nextOf().ty == Tvoid && tparam.ty == Tarray)\n+            if ((!e.elements || !e.elements.length) && e.type.toBasetype().nextOf().ty == Tvoid && tparam.ty == Tarray)\n             {\n                 // tparam:T[] <- e:[] (void[])\n                 result = deduceEmptyArrayElement();\n                 return;\n             }\n \n-            if (tparam.ty == Tarray && e.elements && e.elements.dim)\n+            if (tparam.ty == Tarray && e.elements && e.elements.length)\n             {\n                 Type tn = (cast(TypeDArray)tparam).next;\n                 result = MATCH.exact;\n@@ -4769,18 +4769,18 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n             }\n \n             Type taai;\n-            if (e.type.ty == Tarray && (tparam.ty == Tsarray || tparam.ty == Taarray && (taai = (cast(TypeAArray)tparam).index).ty == Tident && (cast(TypeIdentifier)taai).idents.dim == 0))\n+            if (e.type.ty == Tarray && (tparam.ty == Tsarray || tparam.ty == Taarray && (taai = (cast(TypeAArray)tparam).index).ty == Tident && (cast(TypeIdentifier)taai).idents.length == 0))\n             {\n                 // Consider compile-time known boundaries\n-                e.type.nextOf().sarrayOf(e.elements.dim).accept(this);\n+                e.type.nextOf().sarrayOf(e.elements.length).accept(this);\n                 return;\n             }\n             visit(cast(Expression)e);\n         }\n \n         override void visit(AssocArrayLiteralExp e)\n         {\n-            if (tparam.ty == Taarray && e.keys && e.keys.dim)\n+            if (tparam.ty == Taarray && e.keys && e.keys.length)\n             {\n                 TypeAArray taa = cast(TypeAArray)tparam;\n                 result = MATCH.exact;\n@@ -4825,7 +4825,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                     return;\n \n                 auto tiargs = new Objects();\n-                tiargs.reserve(e.td.parameters.dim);\n+                tiargs.reserve(e.td.parameters.length);\n \n                 foreach (tp; *e.td.parameters)\n                 {\n@@ -4841,7 +4841,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                     if (!pto)\n                         break;\n                     Type t = pto.type.syntaxCopy(); // https://issues.dlang.org/show_bug.cgi?id=11774\n-                    if (reliesOnTemplateParameters(t, (*parameters)[inferStart .. parameters.dim]))\n+                    if (reliesOnTemplateParameters(t, (*parameters)[inferStart .. parameters.length]))\n                         return;\n                     t = t.typeSemantic(e.loc, sc);\n                     if (t.ty == Terror)\n@@ -4885,7 +4885,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n         override void visit(SliceExp e)\n         {\n             Type taai;\n-            if (e.type.ty == Tarray && (tparam.ty == Tsarray || tparam.ty == Taarray && (taai = (cast(TypeAArray)tparam).index).ty == Tident && (cast(TypeIdentifier)taai).idents.dim == 0))\n+            if (e.type.ty == Tarray && (tparam.ty == Tsarray || tparam.ty == Taarray && (taai = (cast(TypeAArray)tparam).index).ty == Tident && (cast(TypeIdentifier)taai).idents.length == 0))\n             {\n                 // Consider compile-time known boundaries\n                 if (Type tsa = toStaticArrayType(e))\n@@ -4928,7 +4928,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n  */\n bool reliesOnTident(Type t, TemplateParameters* tparams, size_t iStart = 0)\n {\n-    return reliesOnTemplateParameters(t, (*tparams)[0 .. tparams.dim]);\n+    return reliesOnTemplateParameters(t, (*tparams)[0 .. tparams.length]);\n }\n \n /***********************************************************\n@@ -5739,7 +5739,7 @@ extern (C++) final class TemplateTupleParameter : TemplateParameter\n         Tuple v = isTuple(oded);\n         assert(v);\n \n-        //printf(\"|%d| \", v.objects.dim);\n+        //printf(\"|%d| \", v.objects.length);\n         foreach (i, o; v.objects)\n         {\n             if (i)\n@@ -5901,7 +5901,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n         Objects* a = null;\n         if (objs)\n         {\n-            a = new Objects(objs.dim);\n+            a = new Objects(objs.length);\n             foreach (i, o; *objs)\n                 (*a)[i] = objectSyntaxCopy(o);\n         }\n@@ -6094,7 +6094,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n     final bool equalsx(TemplateInstance ti)\n     {\n         //printf(\"this = %p, ti = %p\\n\", this, ti);\n-        assert(tdtypes.dim == ti.tdtypes.dim);\n+        assert(tdtypes.length == ti.tdtypes.length);\n \n         // Nesting must match\n         if (enclosing != ti.enclosing)\n@@ -6121,7 +6121,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                     Parameter fparam = fparameters[j];\n                     if (fparam.storageClass & STC.autoref)       // if \"auto ref\"\n                     {\n-                        Expression farg = fargs && j < fargs.dim ? (*fargs)[j] : fparam.defaultArg;\n+                        Expression farg = fargs && j < fargs.length ? (*fargs)[j] : fparam.defaultArg;\n                         if (!farg)\n                             goto Lnotequals;\n                         if (farg.isLvalue())\n@@ -6423,7 +6423,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n \n         // Look for forward references\n         auto tovers = tempdecl.isOverloadSet();\n-        foreach (size_t oi; 0 .. tovers ? tovers.a.dim : 1)\n+        foreach (size_t oi; 0 .. tovers ? tovers.a.length : 1)\n         {\n             Dsymbol dstart = tovers ? tovers.a[oi] : tempdecl;\n             int r = overloadApply(dstart, (Dsymbol s)\n@@ -6583,7 +6583,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n         if (!tiargs)\n             return true;\n         bool err = false;\n-        for (size_t j = 0; j < tiargs.dim; j++)\n+        for (size_t j = 0; j < tiargs.length; j++)\n         {\n             RootObject o = (*tiargs)[j];\n             Type ta = isType(o);\n@@ -6612,7 +6612,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                 {\n                     // Expand tuple\n                     TypeTuple tt = cast(TypeTuple)ta;\n-                    size_t dim = tt.arguments.dim;\n+                    size_t dim = tt.arguments.length;\n                     tiargs.remove(j);\n                     if (dim)\n                     {\n@@ -6688,7 +6688,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                 {\n                     // Expand tuple\n                     TupleExp te = cast(TupleExp)ea;\n-                    size_t dim = te.exps.dim;\n+                    size_t dim = te.exps.length;\n                     tiargs.remove(j);\n                     if (dim)\n                     {\n@@ -6820,7 +6820,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n         version (none)\n         {\n             printf(\"-TemplateInstance.semanticTiargs()\\n\");\n-            for (size_t j = 0; j < tiargs.dim; j++)\n+            for (size_t j = 0; j < tiargs.length; j++)\n             {\n                 RootObject o = (*tiargs)[j];\n                 Type ta = isType(o);\n@@ -6875,7 +6875,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n             assert(tempdecl);\n             assert(tempdecl._scope);\n             // Deduce tdtypes\n-            tdtypes.setDim(tempdecl.parameters.dim);\n+            tdtypes.setDim(tempdecl.parameters.length);\n             if (!tempdecl.matchWithInstance(sc, this, &tdtypes, fargs, 2))\n             {\n                 error(\"incompatible arguments for template instantiation\");\n@@ -6898,7 +6898,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n          * name, look for the best match.\n          */\n         auto tovers = tempdecl.isOverloadSet();\n-        foreach (size_t oi; 0 .. tovers ? tovers.a.dim : 1)\n+        foreach (size_t oi; 0 .. tovers ? tovers.a.length : 1)\n         {\n             TemplateDeclaration td_best;\n             TemplateDeclaration td_ambig;\n@@ -6921,13 +6921,13 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                 //printf(\"td = %s\\n\", td.toPrettyChars());\n                 // If more arguments than parameters,\n                 // then this is no match.\n-                if (td.parameters.dim < tiargs.dim)\n+                if (td.parameters.length < tiargs.length)\n                 {\n                     if (!td.isVariadic())\n                         return 0;\n                 }\n \n-                dedtypes.setDim(td.parameters.dim);\n+                dedtypes.setDim(td.parameters.length);\n                 dedtypes.zero();\n                 assert(td.semanticRun != PASS.initial);\n \n@@ -6960,8 +6960,8 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                 td_ambig = null;\n                 td_best = td;\n                 m_best = m;\n-                tdtypes.setDim(dedtypes.dim);\n-                memcpy(tdtypes.tdata(), dedtypes.tdata(), tdtypes.dim * (void*).sizeof);\n+                tdtypes.setDim(dedtypes.length);\n+                memcpy(tdtypes.tdata(), dedtypes.tdata(), tdtypes.length * (void*).sizeof);\n                 return 0;\n             });\n \n@@ -7000,12 +7000,12 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n              *    S!num s;             // S!1 is instantiated, not S!num\n              *  }\n              */\n-            size_t dim = td_last.parameters.dim - (td_last.isVariadic() ? 1 : 0);\n+            size_t dim = td_last.parameters.length - (td_last.isVariadic() ? 1 : 0);\n             for (size_t i = 0; i < dim; i++)\n             {\n-                if (tiargs.dim <= i)\n+                if (tiargs.length <= i)\n                     tiargs.push(tdtypes[i]);\n-                assert(i < tiargs.dim);\n+                assert(i < tiargs.length);\n \n                 auto tvp = (*td_last.parameters)[i].isTemplateValueParameter();\n                 if (!tvp)\n@@ -7015,7 +7015,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n \n                 (*tiargs)[i] = tdtypes[i];\n             }\n-            if (td_last.isVariadic() && tiargs.dim == dim && tdtypes[dim])\n+            if (td_last.isVariadic() && tiargs.length == dim && tdtypes[dim])\n             {\n                 Tuple va = isTuple(tdtypes[dim]);\n                 assert(va);\n@@ -7051,7 +7051,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                 {\n                     error(\"%s `%s`\", msg, tmsg);\n \n-                    if (tdecl.parameters.dim == tiargs.dim)\n+                    if (tdecl.parameters.length == tiargs.length)\n                     {\n                         // https://issues.dlang.org/show_bug.cgi?id=7352\n                         // print additional information, e.g. `foo` is not a type\n@@ -7081,7 +7081,17 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                 }\n             }\n             else\n-                .error(loc, \"%s `%s.%s` does not match any template declaration\", tempdecl.kind(), tempdecl.parent.toPrettyChars(), tempdecl.ident.toChars());\n+            {\n+                .error(loc, \"%s `%s` does not match any template declaration\", kind(), toPrettyChars());\n+                bool found;\n+                overloadApply(tempdecl, (s){\n+                    if (!found)\n+                        errorSupplemental(loc, \"Candidates are:\");\n+                    found = true;\n+                    errorSupplemental(s.loc, \"%s\", s.toChars());\n+                    return 0;\n+                });\n+            }\n             return false;\n         }\n \n@@ -7115,7 +7125,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n         size_t count = 0;\n \n         auto tovers = tempdecl.isOverloadSet();\n-        foreach (size_t oi; 0 .. tovers ? tovers.a.dim : 1)\n+        foreach (size_t oi; 0 .. tovers ? tovers.a.length : 1)\n         {\n             Dsymbol dstart = tovers ? tovers.a[oi] : tempdecl;\n             int r = overloadApply(dstart, (Dsymbol s)\n@@ -7138,7 +7148,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                 {\n                     if (!td2.onemember || !td2.onemember.isFuncDeclaration())\n                         return 0;\n-                    if (tiargs.dim >= td.parameters.dim - (td.isVariadic() ? 1 : 0))\n+                    if (tiargs.length >= td.parameters.length - (td.isVariadic() ? 1 : 0))\n                         return 0;\n                     return 1;\n                 }\n@@ -7155,18 +7165,18 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                 /* Determine if the instance arguments, tiargs, are all that is necessary\n                  * to instantiate the template.\n                  */\n-                //printf(\"tp = %p, td.parameters.dim = %d, tiargs.dim = %d\\n\", tp, td.parameters.dim, tiargs.dim);\n+                //printf(\"tp = %p, td.parameters.length = %d, tiargs.length = %d\\n\", tp, td.parameters.length, tiargs.length);\n                 auto tf = cast(TypeFunction)fd.type;\n                 if (tf.parameterList.length)\n                 {\n                     auto tp = td.isVariadic();\n-                    if (tp && td.parameters.dim > 1)\n+                    if (tp && td.parameters.length > 1)\n                         return 1;\n \n-                    if (!tp && tiargs.dim < td.parameters.dim)\n+                    if (!tp && tiargs.length < td.parameters.length)\n                     {\n                         // Can remain tiargs be filled by default arguments?\n-                        foreach (size_t i; tiargs.dim .. td.parameters.dim)\n+                        foreach (size_t i; tiargs.length .. td.parameters.length)\n                         {\n                             if (!(*td.parameters)[i].hasDefaultArg())\n                                 return 1;\n@@ -7186,7 +7196,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                     /* Calculate the need for overload resolution.\n                      * When only one template can match with tiargs, inference is not necessary.\n                      */\n-                    dedtypes.setDim(td.parameters.dim);\n+                    dedtypes.setDim(td.parameters.length);\n                     dedtypes.zero();\n                     if (td.semanticRun == PASS.initial)\n                     {\n@@ -7653,7 +7663,7 @@ extern (C++) final class TemplateMixin : TemplateInstance\n     extern (D) this(const ref Loc loc, Identifier ident, TypeQualified tqual, Objects* tiargs)\n     {\n         super(loc,\n-              tqual.idents.dim ? cast(Identifier)tqual.idents[tqual.idents.dim - 1] : (cast(TypeIdentifier)tqual).ident,\n+              tqual.idents.length ? cast(Identifier)tqual.idents[tqual.idents.length - 1] : (cast(TypeIdentifier)tqual).ident,\n               tiargs ? tiargs : new Objects());\n         //printf(\"TemplateMixin(ident = '%s')\\n\", ident ? ident.toChars() : \"\");\n         this.ident = ident;\n@@ -7745,7 +7755,7 @@ extern (C++) final class TemplateMixin : TemplateInstance\n \n         // Look for forward references\n         auto tovers = tempdecl.isOverloadSet();\n-        foreach (size_t oi; 0 .. tovers ? tovers.a.dim : 1)\n+        foreach (size_t oi; 0 .. tovers ? tovers.a.length : 1)\n         {\n             Dsymbol dstart = tovers ? tovers.a[oi] : tempdecl;\n             int r = overloadApply(dstart, (Dsymbol s)\n@@ -7865,15 +7875,15 @@ MATCH matchArg(TemplateParameter tp, Loc instLoc, Scope* sc, Objects* tiargs, si\n     {\n         RootObject oarg;\n \n-        if (i < tiargs.dim)\n+        if (i < tiargs.length)\n             oarg = (*tiargs)[i];\n         else\n         {\n             // Get default argument instead\n             oarg = tp.defaultArg(instLoc, sc);\n             if (!oarg)\n             {\n-                assert(i < dedtypes.dim);\n+                assert(i < dedtypes.length);\n                 // It might have already been deduced\n                 oarg = (*dedtypes)[i];\n                 if (!oarg)\n@@ -7888,24 +7898,24 @@ MATCH matchArg(TemplateParameter tp, Loc instLoc, Scope* sc, Objects* tiargs, si\n         /* The rest of the actual arguments (tiargs[]) form the match\n          * for the variadic parameter.\n          */\n-        assert(i + 1 == dedtypes.dim); // must be the last one\n+        assert(i + 1 == dedtypes.length); // must be the last one\n         Tuple ovar;\n \n         if (Tuple u = isTuple((*dedtypes)[i]))\n         {\n             // It has already been deduced\n             ovar = u;\n         }\n-        else if (i + 1 == tiargs.dim && isTuple((*tiargs)[i]))\n+        else if (i + 1 == tiargs.length && isTuple((*tiargs)[i]))\n             ovar = isTuple((*tiargs)[i]);\n         else\n         {\n             ovar = new Tuple();\n             //printf(\"ovar = %p\\n\", ovar);\n-            if (i < tiargs.dim)\n+            if (i < tiargs.length)\n             {\n-                //printf(\"i = %d, tiargs.dim = %d\\n\", i, tiargs.dim);\n-                ovar.objects.setDim(tiargs.dim - i);\n+                //printf(\"i = %d, tiargs.length = %d\\n\", i, tiargs.length);\n+                ovar.objects.setDim(tiargs.length - i);\n                 foreach (j, ref obj; ovar.objects)\n                     obj = (*tiargs)[i + j];\n             }"}, {"sha": "432e88da307459c1425e263ed0017851e4dc1a9f", "filename": "gcc/d/dmd/dtoh.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdtoh.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fdtoh.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtoh.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1945,7 +1945,7 @@ public:\n         }\n         if (tf.parameterList.varargs)\n         {\n-            if (tf.parameterList.parameters.dim && tf.parameterList.varargs == 1)\n+            if (tf.parameterList.parameters.length && tf.parameterList.varargs == 1)\n                 buf.writestring(\", \");\n             buf.writestring(\"...\");\n         }\n@@ -2280,7 +2280,7 @@ public:\n         }\n         if (tf.parameterList.varargs)\n         {\n-            if (tf.parameterList.parameters.dim && tf.parameterList.varargs == 1)\n+            if (tf.parameterList.parameters.length && tf.parameterList.varargs == 1)\n                 buf.writestring(\", \");\n             buf.writestring(\"...\");\n         }"}, {"sha": "24a428b6ce61773f5dc51136c5e3bdf5571e5ce2", "filename": "gcc/d/dmd/escape.d", "status": "modified", "additions": 31, "deletions": 42, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fescape.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fescape.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -328,7 +328,7 @@ void printScopeFailure(E)(E printFunc, VarDeclaration v, int recursionLimit)\n  * Params:\n  *      sc = used to determine current function and module\n  *      fdc = function being called, `null` if called indirectly\n- *      par = function parameter (`this` if null)\n+ *      parId = name of function parameter for error messages\n  *      vPar = `VarDeclaration` corresponding to `par`\n  *      parStc = storage classes of function parameter (may have added `scope` from `pure`)\n  *      arg = initializer for param\n@@ -337,12 +337,12 @@ void printScopeFailure(E)(E printFunc, VarDeclaration v, int recursionLimit)\n  * Returns:\n  *      `true` if pointers to the stack can escape via assignment\n  */\n-bool checkParamArgumentEscape(Scope* sc, FuncDeclaration fdc, Parameter par, VarDeclaration vPar, STC parStc, Expression arg, bool assertmsg, bool gag)\n+bool checkParamArgumentEscape(Scope* sc, FuncDeclaration fdc, Identifier parId, VarDeclaration vPar, STC parStc, Expression arg, bool assertmsg, bool gag)\n {\n     enum log = false;\n     if (log) printf(\"checkParamArgumentEscape(arg: %s par: %s)\\n\",\n         arg ? arg.toChars() : \"null\",\n-        par ? par.toChars() : \"this\");\n+        parId ? parId.toChars() : \"null\");\n     //printf(\"type = %s, %d\\n\", arg.type.toChars(), arg.type.hasPointers());\n \n     if (!arg.type.hasPointers())\n@@ -361,7 +361,7 @@ bool checkParamArgumentEscape(Scope* sc, FuncDeclaration fdc, Parameter par, Var\n         er.byexp.setDim(0);\n     }\n \n-    if (!er.byref.dim && !er.byvalue.dim && !er.byfunc.dim && !er.byexp.dim)\n+    if (!er.byref.length && !er.byvalue.length && !er.byfunc.length && !er.byexp.length)\n         return false;\n \n     bool result = false;\n@@ -374,24 +374,18 @@ bool checkParamArgumentEscape(Scope* sc, FuncDeclaration fdc, Parameter par, Var\n         {\n             result |= sc.setUnsafeDIP1000(gag, arg.loc,\n                 desc ~ \" `%s` assigned to non-scope parameter calling `assert()`\", v);\n+            return;\n         }\n-        else if (par)\n-        {\n-            if (sc.setUnsafeDIP1000(gag, arg.loc,\n-                desc ~ \" `%s` assigned to non-scope parameter `%s` calling `%s`\", v, par, fdc))\n-            {\n-                result = true;\n-                printScopeFailure(previewSupplementalFunc(sc.isDeprecated(), global.params.useDIP1000), vPar, 10);\n-            }\n-        }\n-        else\n+        const(char)* msg =\n+            (fdc &&  parId) ? (desc ~ \" `%s` assigned to non-scope parameter `%s` calling `%s`\") :\n+            (fdc && !parId) ? (desc ~ \" `%s` assigned to non-scope anonymous parameter calling `%s`\") :\n+            (!fdc && parId) ? (desc ~ \" `%s` assigned to non-scope parameter `%s`\") :\n+            (desc ~ \" `%s` assigned to non-scope anonymous parameter\");\n+\n+        if (sc.setUnsafeDIP1000(gag, arg.loc, msg, v, parId ? parId : fdc, fdc))\n         {\n-            if (sc.setUnsafeDIP1000(gag, arg.loc,\n-                desc ~ \" `%s` assigned to non-scope parameter `this` calling `%s`\", v, fdc))\n-            {\n-                result = true;\n-                printScopeFailure(previewSupplementalFunc(sc.isDeprecated(), global.params.useDIP1000), fdc.vthis, 10);\n-            }\n+            result = true;\n+            printScopeFailure(previewSupplementalFunc(sc.isDeprecated(), global.params.useDIP1000), vPar, 10);\n         }\n     }\n \n@@ -465,16 +459,11 @@ bool checkParamArgumentEscape(Scope* sc, FuncDeclaration fdc, Parameter par, Var\n \n     foreach (Expression ee; er.byexp)\n     {\n-        if (!par)\n-        {\n-            result |= sc.setUnsafeDIP1000(gag, ee.loc,\n-                \"reference to stack allocated value returned by `%s` assigned to non-scope parameter `this`\", ee);\n-        }\n-        else\n-        {\n-            result |= sc.setUnsafeDIP1000(gag, ee.loc,\n-                \"reference to stack allocated value returned by `%s` assigned to non-scope parameter `%s`\", ee, par);\n-        }\n+        const(char)* msg = parId ?\n+            \"reference to stack allocated value returned by `%s` assigned to non-scope parameter `%s`\" :\n+            \"reference to stack allocated value returned by `%s` assigned to non-scope anonymous parameter\";\n+\n+        result |= sc.setUnsafeDIP1000(gag, ee.loc, msg, ee, parId);\n     }\n \n     return result;\n@@ -537,15 +526,15 @@ bool checkConstructorEscape(Scope* sc, CallExp ce, bool gag)\n     if (!tthis.hasPointers())\n         return false;\n \n-    if (!ce.arguments && ce.arguments.dim)\n+    if (!ce.arguments && ce.arguments.length)\n         return false;\n \n     DotVarExp dve = ce.e1.isDotVarExp();\n     CtorDeclaration ctor = dve.var.isCtorDeclaration();\n     TypeFunction tf = ctor.type.isTypeFunction();\n \n     const nparams = tf.parameterList.length;\n-    const n = ce.arguments.dim;\n+    const n = ce.arguments.length;\n \n     // j=1 if _arguments[] is first argument\n     const j = tf.isDstyleVariadic();\n@@ -625,7 +614,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n     else\n         escapeByValue(e2, &er);\n \n-    if (!er.byref.dim && !er.byvalue.dim && !er.byfunc.dim && !er.byexp.dim)\n+    if (!er.byref.length && !er.byvalue.length && !er.byfunc.length && !er.byexp.length)\n         return false;\n \n     VarDeclaration va = expToVariable(e1);\n@@ -959,7 +948,7 @@ bool checkThrowEscape(Scope* sc, Expression e, bool gag)\n \n     escapeByValue(e, &er);\n \n-    if (!er.byref.dim && !er.byvalue.dim && !er.byexp.dim)\n+    if (!er.byref.length && !er.byvalue.length && !er.byexp.length)\n         return false;\n \n     bool result = false;\n@@ -1007,7 +996,7 @@ bool checkNewEscape(Scope* sc, Expression e, bool gag)\n \n     escapeByValue(e, &er);\n \n-    if (!er.byref.dim && !er.byvalue.dim && !er.byexp.dim)\n+    if (!er.byref.length && !er.byvalue.length && !er.byexp.length)\n         return false;\n \n     bool result = false;\n@@ -1187,7 +1176,7 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n     else\n         escapeByValue(e, &er);\n \n-    if (!er.byref.dim && !er.byvalue.dim && !er.byexp.dim)\n+    if (!er.byref.length && !er.byvalue.length && !er.byexp.length)\n         return false;\n \n     bool result = false;\n@@ -1739,13 +1728,13 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false, bool re\n         if (!e.type.hasPointers())\n             return;\n \n-        if (e.arguments && e.arguments.dim)\n+        if (e.arguments && e.arguments.length)\n         {\n             /* j=1 if _arguments[] is first argument,\n              * skip it because it is not passed by ref\n              */\n             int j = tf.isDstyleVariadic();\n-            for (size_t i = j; i < e.arguments.dim; ++i)\n+            for (size_t i = j; i < e.arguments.length; ++i)\n             {\n                 Expression arg = (*e.arguments)[i];\n                 size_t nparams = tf.parameterList.length;\n@@ -2048,13 +2037,13 @@ void escapeByRef(Expression e, EscapeByResults* er, bool live = false, bool retR\n             return;\n         if (tf.isref)\n         {\n-            if (e.arguments && e.arguments.dim)\n+            if (e.arguments && e.arguments.length)\n             {\n                 /* j=1 if _arguments[] is first argument,\n                  * skip it because it is not passed by ref\n                  */\n                 int j = tf.isDstyleVariadic();\n-                for (size_t i = j; i < e.arguments.dim; ++i)\n+                for (size_t i = j; i < e.arguments.length; ++i)\n                 {\n                     Expression arg = (*e.arguments)[i];\n                     size_t nparams = tf.parameterList.length;\n@@ -2323,7 +2312,7 @@ void finishScopeParamInference(FuncDeclaration funcdecl, ref TypeFunction f)\n     {\n         // Create and fill array[] with maybe candidates from the `this` and the parameters\n         VarDeclaration[10] tmp = void;\n-        size_t dim = (funcdecl.vthis !is null) + (funcdecl.parameters ? funcdecl.parameters.dim : 0);\n+        size_t dim = (funcdecl.vthis !is null) + (funcdecl.parameters ? funcdecl.parameters.length : 0);\n \n         import dmd.common.string : SmallBuffer;\n         auto sb = SmallBuffer!VarDeclaration(dim, tmp[]);\n@@ -2345,7 +2334,7 @@ void finishScopeParamInference(FuncDeclaration funcdecl, ref TypeFunction f)\n     // Infer STC.scope_\n     if (funcdecl.parameters && !funcdecl.errors)\n     {\n-        assert(f.parameterList.length == funcdecl.parameters.dim);\n+        assert(f.parameterList.length == funcdecl.parameters.length);\n         foreach (u, p; f.parameterList)\n         {\n             auto v = (*funcdecl.parameters)[u];"}, {"sha": "4f14d66d39f03482f37887efb71ae0109be92dbc", "filename": "gcc/d/dmd/expression.d", "status": "modified", "additions": 48, "deletions": 30, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -260,7 +260,7 @@ extern (C++) void expandTuples(Expressions* exps)\n     if (exps is null)\n         return;\n \n-    for (size_t i = 0; i < exps.dim; i++)\n+    for (size_t i = 0; i < exps.length; i++)\n     {\n         Expression arg = (*exps)[i];\n         if (!arg)\n@@ -271,10 +271,10 @@ extern (C++) void expandTuples(Expressions* exps)\n         {\n             if (auto tt = e.type.toBasetype().isTypeTuple())\n             {\n-                if (!tt.arguments || tt.arguments.dim == 0)\n+                if (!tt.arguments || tt.arguments.length == 0)\n                 {\n                     exps.remove(i);\n-                    if (i == exps.dim)\n+                    if (i == exps.length)\n                         return;\n                 }\n                 else // Expand a TypeTuple\n@@ -296,7 +296,7 @@ extern (C++) void expandTuples(Expressions* exps)\n             TupleExp te = cast(TupleExp)arg;\n             exps.remove(i); // remove arg\n             exps.insert(i, te.exps); // replace with tuple contents\n-            if (i == exps.dim)\n+            if (i == exps.length)\n                 return; // empty tuple, no more arguments\n             (*exps)[i] = Expression.combine(te.e0, (*exps)[i]);\n             arg = (*exps)[i];\n@@ -339,10 +339,10 @@ TupleDeclaration isAliasThisTuple(Expression e)\n \n int expandAliasThisTuples(Expressions* exps, size_t starti = 0)\n {\n-    if (!exps || exps.dim == 0)\n+    if (!exps || exps.length == 0)\n         return -1;\n \n-    for (size_t u = starti; u < exps.dim; u++)\n+    for (size_t u = starti; u < exps.length; u++)\n     {\n         Expression exp = (*exps)[u];\n         if (TupleDeclaration td = exp.isAliasThisTuple)\n@@ -924,7 +924,7 @@ extern (C++) abstract class Expression : ASTNode\n         Expressions* a = null;\n         if (exps)\n         {\n-            a = new Expressions(exps.dim);\n+            a = new Expressions(exps.length);\n             foreach (i, e; *exps)\n             {\n                 (*a)[i] = e ? e.syntaxCopy() : null;\n@@ -1214,7 +1214,7 @@ extern (C++) abstract class Expression : ASTNode\n         auto ad = cast(AggregateDeclaration) f.toParent2();\n         assert(ad);\n \n-        if (ad.userDtors.dim)\n+        if (ad.userDtors.length)\n         {\n             if (!check(ad.userDtors[0])) // doesn't match check (e.g. is impure as well)\n                 return;\n@@ -1401,14 +1401,32 @@ extern (C++) abstract class Expression : ASTNode\n      */\n     extern (D) final bool checkSafety(Scope* sc, FuncDeclaration f)\n     {\n-        if (!sc.func)\n-            return false;\n         if (sc.func == f)\n             return false;\n         if (sc.intypeof == 1)\n             return false;\n-        if (sc.flags & (SCOPE.ctfe | SCOPE.debug_))\n+        if (sc.flags & SCOPE.debug_)\n             return false;\n+        if ((sc.flags & SCOPE.ctfe) && sc.func)\n+            return false;\n+\n+        if (!sc.func)\n+        {\n+            if (sc.varDecl && !f.safetyInprocess && !f.isSafe() && !f.isTrusted())\n+            {\n+                if (sc.varDecl.storage_class & STC.safe)\n+                {\n+                    error(\"`@safe` variable `%s` cannot be initialized by calling `@system` function `%s`\",\n+                        sc.varDecl.toChars(), f.toChars());\n+                    return true;\n+                }\n+                else\n+                {\n+                    sc.varDecl.storage_class |= STC.system;\n+                }\n+            }\n+            return false;\n+        }\n \n         if (!f.isSafe() && !f.isTrusted())\n         {\n@@ -2867,7 +2885,7 @@ extern (C++) final class TupleExp : Expression\n         super(loc, EXP.tuple, __traits(classInstanceSize, TupleExp));\n         this.exps = new Expressions();\n \n-        this.exps.reserve(tup.objects.dim);\n+        this.exps.reserve(tup.objects.length);\n         foreach (o; *tup.objects)\n         {\n             if (Dsymbol s = getDsymbol(o))\n@@ -2913,7 +2931,7 @@ extern (C++) final class TupleExp : Expression\n         if (auto e = o.isExpression())\n             if (auto te = e.isTupleExp())\n             {\n-                if (exps.dim != te.exps.dim)\n+                if (exps.length != te.exps.length)\n                     return false;\n                 if (e0 && !e0.equals(te.e0) || !e0 && te.e0)\n                     return false;\n@@ -3002,9 +3020,9 @@ extern (C++) final class ArrayLiteralExp : Expression\n             return false;\n         if (auto ae = e.isArrayLiteralExp())\n         {\n-            if (elements.dim != ae.elements.dim)\n+            if (elements.length != ae.elements.length)\n                 return false;\n-            if (elements.dim == 0 && !type.equals(ae.type))\n+            if (elements.length == 0 && !type.equals(ae.type))\n             {\n                 return false;\n             }\n@@ -3036,14 +3054,14 @@ extern (C++) final class ArrayLiteralExp : Expression\n \n     override Optional!bool toBool()\n     {\n-        size_t dim = elements ? elements.dim : 0;\n+        size_t dim = elements ? elements.length : 0;\n         return typeof(return)(dim != 0);\n     }\n \n     override StringExp toStringExp()\n     {\n         TY telem = type.nextOf().toBasetype().ty;\n-        if (telem.isSomeChar || (telem == Tvoid && (!elements || elements.dim == 0)))\n+        if (telem.isSomeChar || (telem == Tvoid && (!elements || elements.length == 0)))\n         {\n             ubyte sz = 1;\n             if (telem == Twchar)\n@@ -3054,7 +3072,7 @@ extern (C++) final class ArrayLiteralExp : Expression\n             OutBuffer buf;\n             if (elements)\n             {\n-                foreach (i; 0 .. elements.dim)\n+                foreach (i; 0 .. elements.length)\n                 {\n                     auto ch = this[i];\n                     if (ch.op != EXP.int64)\n@@ -3114,7 +3132,7 @@ extern (C++) final class AssocArrayLiteralExp : Expression\n     extern (D) this(const ref Loc loc, Expressions* keys, Expressions* values)\n     {\n         super(loc, EXP.assocArrayLiteral, __traits(classInstanceSize, AssocArrayLiteralExp));\n-        assert(keys.dim == values.dim);\n+        assert(keys.length == values.length);\n         this.keys = keys;\n         this.values = values;\n     }\n@@ -3128,7 +3146,7 @@ extern (C++) final class AssocArrayLiteralExp : Expression\n             return false;\n         if (auto ae = e.isAssocArrayLiteralExp())\n         {\n-            if (keys.dim != ae.keys.dim)\n+            if (keys.length != ae.keys.length)\n                 return false;\n             size_t count = 0;\n             foreach (i, key; *keys)\n@@ -3143,7 +3161,7 @@ extern (C++) final class AssocArrayLiteralExp : Expression\n                     }\n                 }\n             }\n-            return count == keys.dim;\n+            return count == keys.length;\n         }\n         return false;\n     }\n@@ -3155,7 +3173,7 @@ extern (C++) final class AssocArrayLiteralExp : Expression\n \n     override Optional!bool toBool()\n     {\n-        size_t dim = keys.dim;\n+        size_t dim = keys.length;\n         return typeof(return)(dim != 0);\n     }\n \n@@ -3232,7 +3250,7 @@ extern (C++) final class StructLiteralExp : Expression\n         {\n             if (!type.equals(se.type))\n                 return false;\n-            if (elements.dim != se.elements.dim)\n+            if (elements.length != se.elements.length)\n                 return false;\n             foreach (i, e1; *elements)\n             {\n@@ -3269,7 +3287,7 @@ extern (C++) final class StructLiteralExp : Expression\n             if (i >= sd.nonHiddenFields())\n                 return null;\n \n-            assert(i < elements.dim);\n+            assert(i < elements.length);\n             e = (*elements)[i];\n             if (e)\n             {\n@@ -3310,7 +3328,7 @@ extern (C++) final class StructLiteralExp : Expression\n     {\n         /* Find which field offset is by looking at the field offsets\n          */\n-        if (elements.dim)\n+        if (elements.length)\n         {\n             const sz = type.size();\n             if (sz == SIZE_INVALID)\n@@ -3797,7 +3815,7 @@ extern (C++) final class FuncExp : Expression\n         if (td)\n         {\n             assert(td.literal);\n-            assert(td.members && td.members.dim == 1);\n+            assert(td.members && td.members.length == 1);\n             fd = (*td.members)[0].isFuncLiteralDeclaration();\n         }\n         tok = fd.tok; // save original kind of function/delegate/(infer)\n@@ -3928,7 +3946,7 @@ extern (C++) final class FuncExp : Expression\n                 return cannotInfer(this, to, flag);\n \n             auto tiargs = new Objects();\n-            tiargs.reserve(td.parameters.dim);\n+            tiargs.reserve(td.parameters.length);\n \n             foreach (tp; *td.parameters)\n             {\n@@ -4211,7 +4229,7 @@ extern (C++) final class IsExp : Expression\n         TemplateParameters* p = null;\n         if (parameters)\n         {\n-            p = new TemplateParameters(parameters.dim);\n+            p = new TemplateParameters(parameters.length);\n             foreach (i, el; *parameters)\n                 (*p)[i] = el.syntaxCopy();\n         }\n@@ -4655,7 +4673,7 @@ extern (C++) final class MixinExp : Expression\n             return false;\n         if (auto ce = e.isMixinExp())\n         {\n-            if (exps.dim != ce.exps.dim)\n+            if (exps.length != ce.exps.length)\n                 return false;\n             foreach (i, e1; *exps)\n             {\n@@ -4846,7 +4864,7 @@ extern (C++) final class DotVarExp : UnaExp\n             if (VarDeclaration vd = var.isVarDeclaration())\n             {\n                 auto ad = vd.isMember2();\n-                if (ad && ad.fields.dim == sc.ctorflow.fieldinit.length)\n+                if (ad && ad.fields.length == sc.ctorflow.fieldinit.length)\n                 {\n                     foreach (i, f; ad.fields)\n                     {"}, {"sha": "60b51cbc44e733ba8f185f88f2ae3e427bb1ddd4", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 100, "deletions": 92, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -220,7 +220,7 @@ Expression resolveOpDollar(Scope* sc, ArrayExp ae, Expression* pe0)\n         if (e.op == EXP.interval && !(slice && slice.isTemplateDeclaration()))\n         {\n         Lfallback:\n-            if (ae.arguments.dim == 1)\n+            if (ae.arguments.length == 1)\n                 return null;\n             ae.error(\"multi-dimensional slicing requires template `opSlice`\");\n             return ErrorExp.get();\n@@ -534,7 +534,7 @@ private Expression resolveUFCS(Scope* sc, CallExp ce)\n                 /* Transform:\n                  *  aa.remove(arg) into delete aa[arg]\n                  */\n-                if (!ce.arguments || ce.arguments.dim != 1)\n+                if (!ce.arguments || ce.arguments.length != 1)\n                 {\n                     ce.error(\"expected key as argument to `aa.remove()`\");\n                     return ErrorExp.get();\n@@ -1189,7 +1189,7 @@ private Expression resolvePropertiesX(Scope* sc, Expression e1, Expression e2 =\n             Expressions a;\n             a.push(e2);\n \n-            for (size_t i = 0; i < os.a.dim; i++)\n+            for (size_t i = 0; i < os.a.length; i++)\n             {\n                 if (FuncDeclaration f = resolveFuncCall(loc, sc, os.a[i], tiargs, tthis, &a, FuncResolveFlag.quiet))\n                 {\n@@ -1206,7 +1206,7 @@ private Expression resolvePropertiesX(Scope* sc, Expression e1, Expression e2 =\n             }\n         }\n         {\n-            for (size_t i = 0; i < os.a.dim; i++)\n+            for (size_t i = 0; i < os.a.length; i++)\n             {\n                 if (FuncDeclaration f = resolveFuncCall(loc, sc, os.a[i], tiargs, tthis, null, FuncResolveFlag.quiet))\n                 {\n@@ -1439,7 +1439,7 @@ private Type arrayExpressionToCommonType(Scope* sc, ref Expressions exps)\n     Expression e0 = null;\n     bool foundType;\n \n-    for (size_t i = 0; i < exps.dim; i++)\n+    for (size_t i = 0; i < exps.length; i++)\n     {\n         Expression e = exps[i];\n         if (!e)\n@@ -1506,7 +1506,7 @@ private Type arrayExpressionToCommonType(Scope* sc, ref Expressions exps)\n     if (t0.ty == Terror)\n         return null;\n \n-    for (size_t i = 0; i < exps.dim; i++)\n+    for (size_t i = 0; i < exps.length; i++)\n     {\n         Expression e = exps[i];\n         if (!e)\n@@ -1633,7 +1633,7 @@ private bool preFunctionParameters(Scope* sc, Expressions* exps, const bool repo\n     {\n         expandTuples(exps);\n \n-        for (size_t i = 0; i < exps.dim; i++)\n+        for (size_t i = 0; i < exps.length; i++)\n         {\n             Expression arg = (*exps)[i];\n             arg = resolveProperties(sc, arg);\n@@ -1721,7 +1721,7 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n     //printf(\"functionParameters() %s\\n\", fd ? fd.toChars() : \"\");\n     assert(arguments);\n     assert(fd || tf.next);\n-    size_t nargs = arguments ? arguments.dim : 0;\n+    size_t nargs = arguments ? arguments.length : 0;\n     const size_t nparams = tf.parameterList.length;\n     const olderrors = global.errors;\n     bool err = false;\n@@ -1843,7 +1843,7 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n                         Type tret = p.isLazyArray();\n \n                         auto elements = new Expressions(nargs - i);\n-                        foreach (u; 0 .. elements.dim)\n+                        foreach (u; 0 .. elements.length)\n                         {\n                             Expression a = (*arguments)[i + u];\n                             if (tret && a.implicitConvTo(tret))\n@@ -2085,7 +2085,7 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n                  * Check arg to see if it matters.\n                  */\n                 VarDeclaration vPar = fd ? (fd.parameters ? (*fd.parameters)[i] : null) : null;\n-                err |= checkParamArgumentEscape(sc, fd, p, vPar, cast(STC) pStc, arg, false, false);\n+                err |= checkParamArgumentEscape(sc, fd, p.ident, vPar, cast(STC) pStc, arg, false, false);\n             }\n \n             // Turning heap allocations into stack allocations is dangerous without dip1000, since `scope` inference\n@@ -2451,10 +2451,10 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n     // If D linkage and variadic, add _arguments[] as first argument\n     if (tf.isDstyleVariadic())\n     {\n-        assert(arguments.dim >= nparams);\n+        assert(arguments.length >= nparams);\n \n-        auto args = new Parameters(arguments.dim - nparams);\n-        for (size_t i = 0; i < arguments.dim - nparams; i++)\n+        auto args = new Parameters(arguments.length - nparams);\n+        for (size_t i = 0; i < arguments.length - nparams; i++)\n         {\n             auto arg = new Parameter(STC.in_, (*arguments)[nparams + i].type, null, null, null);\n             (*args)[i] = arg;\n@@ -3109,7 +3109,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n         // Run semantic() on each argument\n         bool err = false;\n-        for (size_t i = 0; i < exp.exps.dim; i++)\n+        for (size_t i = 0; i < exp.exps.length; i++)\n         {\n             Expression e = (*exp.exps)[i];\n             e = e.expressionSemantic(sc);\n@@ -3169,7 +3169,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n         /* Disallow array literals of type void being used.\n          */\n-        if (e.elements.dim > 0 && t0.ty == Tvoid)\n+        if (e.elements.length > 0 && t0.ty == Tvoid)\n         {\n             e.error(\"`%s` of type `%s` has no value\", e.toChars(), e.type.toChars());\n             return setError();\n@@ -3201,10 +3201,10 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n         expandTuples(e.keys);\n         expandTuples(e.values);\n-        if (e.keys.dim != e.values.dim)\n+        if (e.keys.length != e.values.length)\n         {\n             e.error(\"number of keys is %llu, must match number of values %llu\",\n-                        cast(ulong) e.keys.dim, cast(ulong) e.values.dim);\n+                        cast(ulong) e.keys.length, cast(ulong) e.values.length);\n             return setError();\n         }\n \n@@ -3263,7 +3263,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return setError();\n         }\n \n-        if (checkFrameAccess(e.loc, sc, e.sd, e.elements.dim))\n+        if (checkFrameAccess(e.loc, sc, e.sd, e.elements.length))\n             return setError();\n \n         e.type = e.stype ? e.stype : e.sd.type;\n@@ -3579,7 +3579,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return setError();\n         }\n \n-        const size_t nargs = exp.arguments ? exp.arguments.dim : 0;\n+        const size_t nargs = exp.arguments ? exp.arguments.length : 0;\n         Expression newprefix = null;\n \n         if (auto tc = tb.isTypeClass())\n@@ -3605,7 +3605,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             if (cd.isAbstract())\n             {\n                 exp.error(\"cannot create instance of abstract class `%s`\", cd.toChars());\n-                for (size_t i = 0; i < cd.vtbl.dim; i++)\n+                for (size_t i = 0; i < cd.vtbl.length; i++)\n                 {\n                     FuncDeclaration fd = cd.vtbl[i].isFuncDeclaration();\n                     if (fd && fd.isAbstract())\n@@ -3836,7 +3836,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 exp.member = f.isCtorDeclaration();\n                 assert(exp.member);\n \n-                if (checkFrameAccess(exp.loc, sc, sd, sd.fields.dim))\n+                if (checkFrameAccess(exp.loc, sc, sd, sd.fields.length))\n                     return setError();\n             }\n             else\n@@ -3850,7 +3850,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 if (!sd.fill(exp.loc, *exp.arguments, false))\n                     return setError();\n \n-                if (checkFrameAccess(exp.loc, sc, sd, exp.arguments ? exp.arguments.dim : 0))\n+                if (checkFrameAccess(exp.loc, sc, sd, exp.arguments ? exp.arguments.length : 0))\n                     return setError();\n \n                 /* Since a `new` allocation may escape, check each of the arguments for escaping\n@@ -4113,7 +4113,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         //printf(\"td = %p, treq = %p\\n\", td, fd.treq);\n         if (exp.td)\n         {\n-            assert(exp.td.parameters && exp.td.parameters.dim);\n+            assert(exp.td.parameters && exp.td.parameters.length);\n             exp.td.dsymbolSemantic(sc);\n             exp.type = Type.tvoid; // temporary type\n \n@@ -4199,9 +4199,9 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n      */\n     Expression callExpSemantic(FuncExp exp, Scope* sc, Expressions* arguments)\n     {\n-        if ((!exp.type || exp.type == Type.tvoid) && exp.td && arguments && arguments.dim)\n+        if ((!exp.type || exp.type == Type.tvoid) && exp.td && arguments && arguments.length)\n         {\n-            for (size_t k = 0; k < arguments.dim; k++)\n+            for (size_t k = 0; k < arguments.length; k++)\n             {\n                 Expression checkarg = (*arguments)[k];\n                 if (checkarg.op == EXP.error)\n@@ -4210,38 +4210,38 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n             exp.genIdent(sc);\n \n-            assert(exp.td.parameters && exp.td.parameters.dim);\n+            assert(exp.td.parameters && exp.td.parameters.length);\n             exp.td.dsymbolSemantic(sc);\n \n             TypeFunction tfl = cast(TypeFunction)exp.fd.type;\n             size_t dim = tfl.parameterList.length;\n-            if (arguments.dim < dim)\n+            if (arguments.length < dim)\n             {\n                 // Default arguments are always typed, so they don't need inference.\n-                Parameter p = tfl.parameterList[arguments.dim];\n+                Parameter p = tfl.parameterList[arguments.length];\n                 if (p.defaultArg)\n-                    dim = arguments.dim;\n+                    dim = arguments.length;\n             }\n \n-            if ((tfl.parameterList.varargs == VarArg.none && arguments.dim > dim) ||\n-                arguments.dim < dim)\n+            if ((tfl.parameterList.varargs == VarArg.none && arguments.length > dim) ||\n+                arguments.length < dim)\n             {\n                 OutBuffer buf;\n                 foreach (idx, ref arg; *arguments)\n                     buf.printf(\"%s%s\", (idx ? \", \".ptr : \"\".ptr), arg.type.toChars());\n                 exp.error(\"function literal `%s%s` is not callable using argument types `(%s)`\",\n                           exp.fd.toChars(), parametersTypeToChars(tfl.parameterList),\n                           buf.peekChars());\n-                exp.errorSupplemental(\"too %s arguments, expected `%d`, got `%d`\",\n-                                      arguments.dim < dim ? \"few\".ptr : \"many\".ptr,\n-                                      cast(int)dim, cast(int)arguments.dim);\n+                exp.errorSupplemental(\"too %s arguments, expected %d, got %d\",\n+                                      arguments.length < dim ? \"few\".ptr : \"many\".ptr,\n+                                      cast(int)dim, cast(int)arguments.length);\n                 return ErrorExp.get();\n             }\n \n             auto tiargs = new Objects();\n-            tiargs.reserve(exp.td.parameters.dim);\n+            tiargs.reserve(exp.td.parameters.length);\n \n-            for (size_t i = 0; i < exp.td.parameters.dim; i++)\n+            for (size_t i = 0; i < exp.td.parameters.length; i++)\n             {\n                 TemplateParameter tp = (*exp.td.parameters)[i];\n                 assert(dim <= tfl.parameterList.length);\n@@ -4571,7 +4571,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 // First look for constructor\n                 if (exp.e1.op == EXP.type && sd.ctor)\n                 {\n-                    if (!sd.noDefaultCtor && !(exp.arguments && exp.arguments.dim))\n+                    if (!sd.noDefaultCtor && !(exp.arguments && exp.arguments.length))\n                         goto Lx;\n \n                     /* https://issues.dlang.org/show_bug.cgi?id=20695\n@@ -4587,7 +4587,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     auto sle = new StructLiteralExp(exp.loc, sd, null, exp.e1.type);\n                     if (!sd.fill(exp.loc, *sle.elements, true))\n                         return setError();\n-                    if (checkFrameAccess(exp.loc, sc, sd, sle.elements.dim))\n+                    if (checkFrameAccess(exp.loc, sc, sd, sle.elements.length))\n                         return setError();\n \n                     // https://issues.dlang.org/show_bug.cgi?id=14556\n@@ -4664,11 +4664,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     t1 = exp.e1.type;\n                 }\n \n-                if (!exp.arguments || exp.arguments.dim == 0)\n+                if (!exp.arguments || exp.arguments.length == 0)\n                 {\n                     e = t1.defaultInitLiteral(exp.loc);\n                 }\n-                else if (exp.arguments.dim == 1)\n+                else if (exp.arguments.length == 1)\n                 {\n                     e = (*exp.arguments)[0];\n                     if (!e.type.isTypeNoreturn())\n@@ -4685,7 +4685,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             }\n         }\n \n-        static FuncDeclaration resolveOverloadSet(Loc loc, Scope* sc,\n+        FuncDeclaration resolveOverloadSet(Loc loc, Scope* sc,\n             OverloadSet os, Objects* tiargs, Type tthis, Expressions* arguments)\n         {\n             FuncDeclaration f = null;\n@@ -4709,7 +4709,21 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 }\n             }\n             if (!f)\n-                .error(loc, \"no overload matches for `%s`\", os.toChars());\n+            {\n+                .error(loc, \"no overload matches for `%s`\", exp.toChars());\n+                errorSupplemental(loc, \"Candidates are:\");\n+                foreach (s; os.a)\n+                {\n+                    overloadApply(s, (ds){\n+                        if (auto fd = ds.isFuncDeclaration())\n+                            .errorSupplemental(ds.loc, \"%s%s\", fd.toChars(),\n+                                fd.type.toTypeFunction().parameterList.parametersTypeToChars());\n+                        else\n+                            .errorSupplemental(ds.loc, \"%s\", ds.toChars());\n+                        return 0;\n+                    });\n+                }\n+            }\n             else if (f.errors)\n                 f = null;\n             return f;\n@@ -4751,7 +4765,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 auto ad2 = b.sym;\n                 ue.e1 = ue.e1.castTo(sc, ad2.type.addMod(ue.e1.type.mod));\n                 ue.e1 = ue.e1.expressionSemantic(sc);\n-                auto vi = exp.f.findVtblIndex(&ad2.vtbl, cast(int)ad2.vtbl.dim);\n+                auto vi = exp.f.findVtblIndex(&ad2.vtbl, cast(int)ad2.vtbl.length);\n                 assert(vi >= 0);\n                 exp.f = ad2.vtbl[vi].isFuncDeclaration();\n                 assert(exp.f);\n@@ -4769,7 +4783,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 tthis = ue.e1.type;\n                 if (!(exp.f.type.ty == Tfunction && (cast(TypeFunction)exp.f.type).isScopeQual))\n                 {\n-                    if (checkParamArgumentEscape(sc, exp.f, null, null, STC.undefined_, ethis, false, false))\n+                    if (checkParamArgumentEscape(sc, exp.f, Id.This, exp.f.vthis, STC.undefined_, ethis, false, false))\n                         return setError();\n                 }\n             }\n@@ -5283,7 +5297,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             AttribDeclaration ad = s.isAttribDeclaration();\n             if (ad)\n             {\n-                if (ad.decl && ad.decl.dim == 1)\n+                if (ad.decl && ad.decl.length == 1)\n                 {\n                     s = (*ad.decl)[0];\n                     continue;\n@@ -5683,10 +5697,10 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 {\n                     ClassDeclaration cd = (cast(TypeClass)e.targ).sym;\n                     auto args = new Parameters();\n-                    args.reserve(cd.baseclasses.dim);\n+                    args.reserve(cd.baseclasses.length);\n                     if (cd.semanticRun < PASS.semanticdone)\n                         cd.dsymbolSemantic(null);\n-                    for (size_t i = 0; i < cd.baseclasses.dim; i++)\n+                    for (size_t i = 0; i < cd.baseclasses.length; i++)\n                     {\n                         BaseClass* b = (*cd.baseclasses)[i];\n                         args.push(new Parameter(STC.in_, b.type, null, null, null));\n@@ -5775,7 +5789,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 return yes();\n             return no();\n         }\n-        else if (e.tspec && !e.id && !(e.parameters && e.parameters.dim))\n+        else if (e.tspec && !e.id && !(e.parameters && e.parameters.length))\n         {\n             /* Evaluate to true if targ matches tspec\n              * is(targ == tspec)\n@@ -5833,7 +5847,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             Identifier tid = e.id ? e.id : Identifier.generateId(\"__isexp_id\");\n             e.parameters.insert(0, new TemplateTypeParameter(e.loc, tid, null, null));\n \n-            Objects dedtypes = Objects(e.parameters.dim);\n+            Objects dedtypes = Objects(e.parameters.length);\n             dedtypes.zero();\n \n             MATCH m = deduceType(e.targ, sc, e.tspec, e.parameters, &dedtypes, null, 0, e.tok == TOK.equal);\n@@ -5853,7 +5867,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n                 /* Declare trailing parameters\n                  */\n-                for (size_t i = 1; i < e.parameters.dim; i++)\n+                for (size_t i = 1; i < e.parameters.length; i++)\n                 {\n                     TemplateParameter tp = (*e.parameters)[i];\n                     Declaration s = null;\n@@ -6502,13 +6516,10 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 result = expressionSemantic(e, sc);\n                 return;\n             }\n-        }\n \n-        if (exp.arrow) // ImportC only\n-            exp.e1 = exp.e1.expressionSemantic(sc).arrayFuncConv(sc);\n+            if (exp.arrow) // ImportC only\n+                exp.e1 = exp.e1.expressionSemantic(sc).arrayFuncConv(sc);\n \n-        if (sc.flags & SCOPE.Cfile)\n-        {\n             if (exp.ident == Id.__xalignof && exp.e1.isTypeExp())\n             {\n                 // C11 6.5.3 says _Alignof only applies to types\n@@ -6538,12 +6549,12 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     assert(0);\n                 return;\n             }\n-        }\n \n-        if (sc.flags & SCOPE.Cfile && exp.ident != Id.__sizeof)\n-        {\n-            result = fieldLookup(exp.e1, sc, exp.ident);\n-            return;\n+            if (exp.ident != Id.__sizeof)\n+            {\n+                result = fieldLookup(exp.e1, sc, exp.ident);\n+                return;\n+            }\n         }\n \n         Expression e = exp.semanticY(sc, 1);\n@@ -6618,8 +6629,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             Expression ev = sc.func ? extractSideEffect(sc, \"__tup\", e0, exp.e1) : exp.e1;\n \n             auto exps = new Expressions();\n-            exps.reserve(tup.objects.dim);\n-            for (size_t i = 0; i < tup.objects.dim; i++)\n+            exps.reserve(tup.objects.length);\n+            for (size_t i = 0; i < tup.objects.length; i++)\n             {\n                 RootObject o = (*tup.objects)[i];\n                 Expression e;\n@@ -7560,7 +7571,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 }\n             }\n             TupleExp te = exp.e1.isTupleExp();\n-            if (te.exps.dim == 1)\n+            if (te.exps.length == 1)\n                 exp.e1 = (*te.exps)[0];\n         }\n \n@@ -7646,14 +7657,6 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         // Check for unsafe casts\n         if (!isSafeCast(ex, t1b, tob))\n         {\n-            // This is an ad-hoc fix for https://issues.dlang.org/show_bug.cgi?id=19646\n-            // Should be replaced by a more general @system variables implementation\n-            if (!sc.func && sc.stc & STC.safe)\n-            {\n-                exp.error(\"cast from `%s` to `%s` not allowed in safe code\", exp.e1.type.toChars(), exp.to.toChars());\n-                return setError();\n-            }\n-\n             if (sc.setUnsafe(false, exp.loc, \"cast from `%s` to `%s` not allowed in safe code\", exp.e1.type, exp.to))\n             {\n                 return setError();\n@@ -8000,7 +8003,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             {\n                 te = cast(TupleExp)exp.e1;\n                 tup = null;\n-                length = te.exps.dim;\n+                length = te.exps.length;\n             }\n             else if (exp.e1.op == EXP.type) // slicing a type tuple\n             {\n@@ -8403,7 +8406,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         if (exp.e2.op == EXP.tuple)\n         {\n             TupleExp te = cast(TupleExp)exp.e2;\n-            if (te.exps && te.exps.dim == 1)\n+            if (te.exps && te.exps.length == 1)\n                 exp.e2 = Expression.combine(te.e0, (*te.exps)[0]); // bug 4444 fix\n         }\n         if (sc != scx)\n@@ -8467,6 +8470,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 }\n \n                 semanticTypeInfo(sc, taa);\n+                checkNewEscape(sc, exp.e2, false);\n \n                 exp.type = taa.next;\n                 break;\n@@ -8487,7 +8491,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 {\n                     te = cast(TupleExp)exp.e1;\n                     tup = null;\n-                    length = te.exps.dim;\n+                    length = te.exps.length;\n                 }\n                 else if (exp.e1.op == EXP.type)\n                 {\n@@ -8710,7 +8714,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             auto sle = new StructLiteralExp(loc, sd, null, t);\n             if (!sd.fill(loc, *sle.elements, true))\n                 return ErrorExp.get();\n-            if (checkFrameAccess(loc, sc, sd, sle.elements.dim))\n+            if (checkFrameAccess(loc, sc, sd, sle.elements.length))\n                 return ErrorExp.get();\n \n             sle.type = t;\n@@ -8769,11 +8773,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             Expression ae1old = ae.e1;\n \n             const(bool) maybeSlice =\n-                (ae.arguments.dim == 0 ||\n-                 ae.arguments.dim == 1 && (*ae.arguments)[0].op == EXP.interval);\n+                (ae.arguments.length == 0 ||\n+                 ae.arguments.length == 1 && (*ae.arguments)[0].op == EXP.interval);\n \n             IntervalExp ie = null;\n-            if (maybeSlice && ae.arguments.dim)\n+            if (maybeSlice && ae.arguments.length)\n             {\n                 assert((*ae.arguments)[0].op == EXP.interval);\n                 ie = cast(IntervalExp)(*ae.arguments)[0];\n@@ -8983,11 +8987,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             {\n                 TupleExp tup1 = cast(TupleExp)exp.e1;\n                 TupleExp tup2 = cast(TupleExp)e2x;\n-                size_t dim = tup1.exps.dim;\n+                size_t dim = tup1.exps.length;\n                 Expression e = null;\n-                if (dim != tup2.exps.dim)\n+                if (dim != tup2.exps.length)\n                 {\n-                    exp.error(\"mismatched tuple lengths, %d and %d\", cast(int)dim, cast(int)tup2.exps.dim);\n+                    exp.error(\"mismatched tuple lengths, %d and %d\", cast(int)dim, cast(int)tup2.exps.length);\n                     return setError();\n                 }\n                 if (dim == 0)\n@@ -9026,13 +9030,13 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n                 auto iexps = new Expressions();\n                 iexps.push(ev);\n-                for (size_t u = 0; u < iexps.dim; u++)\n+                for (size_t u = 0; u < iexps.length; u++)\n                 {\n                 Lexpand:\n                     Expression e = (*iexps)[u];\n \n                     Parameter arg = Parameter.getNth(tt.arguments, u);\n-                    //printf(\"[%d] iexps.dim = %d, \", u, iexps.dim);\n+                    //printf(\"[%d] iexps.length = %d, \", u, iexps.length);\n                     //printf(\"e = (%s %s, %s), \", Token.toChars[e.op], e.toChars(), e.type.toChars());\n                     //printf(\"arg = (%s, %s)\\n\", arg.toChars(), arg.type.toChars());\n \n@@ -9041,7 +9045,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                         // expand initializer to tuple\n                         if (expandAliasThisTuples(iexps, u) != -1)\n                         {\n-                            if (iexps.dim <= u)\n+                            if (iexps.length <= u)\n                                 break;\n                             goto Lexpand;\n                         }\n@@ -9527,7 +9531,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     uinteger_t dim2 = dim1;\n                     if (auto ale = e2x.isArrayLiteralExp())\n                     {\n-                        dim2 = ale.elements ? ale.elements.dim : 0;\n+                        dim2 = ale.elements ? ale.elements.length : 0;\n                     }\n                     else if (auto se = e2x.isSliceExp())\n                     {\n@@ -9752,7 +9756,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             TypeSArray tsa1 = cast(TypeSArray)toStaticArrayType(se1);\n             TypeSArray tsa2 = null;\n             if (auto ale = e2x.isArrayLiteralExp())\n-                tsa2 = cast(TypeSArray)t2.nextOf().sarrayOf(ale.elements.dim);\n+                tsa2 = cast(TypeSArray)t2.nextOf().sarrayOf(ale.elements.length);\n             else if (auto se = e2x.isSliceExp())\n                 tsa2 = cast(TypeSArray)toStaticArrayType(se);\n             else\n@@ -10359,9 +10363,13 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return setError();\n \n         exp.type = exp.e1.type;\n+        auto assignElem = exp.e2;\n         auto res = exp.reorderSettingAAElem(sc);\n-        if (exp.op == EXP.concatenateElemAssign || exp.op == EXP.concatenateDcharAssign)\n+        if (res != exp) // `AA[k] = v` rewrite was performed\n+            checkNewEscape(sc, assignElem, false);\n+        else if (exp.op == EXP.concatenateElemAssign || exp.op == EXP.concatenateDcharAssign)\n             checkAssignEscape(sc, res, false, false);\n+\n         result = res;\n \n         if ((exp.op == EXP.concatenateAssign || exp.op == EXP.concatenateElemAssign) &&\n@@ -11917,7 +11925,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             {\n                 static struct Result { bool ttEmpty; bool te; }\n                 auto tt = e.op == EXP.type ? e.isTypeExp().type.isTypeTuple() : null;\n-                return Result(tt && (!tt.arguments || !tt.arguments.dim), e.isTupleExp() !is null);\n+                return Result(tt && (!tt.arguments || !tt.arguments.length), e.isTupleExp() !is null);\n             }\n             auto tups1 = extractTypeTupAndExpTup(exp.e1);\n             auto tups2 = extractTypeTupAndExpTup(exp.e2);\n@@ -12599,7 +12607,7 @@ Expression semanticX(DotIdExp exp, Scope* sc)\n         {\n             /* 'distribute' the .offsetof to each of the tuple elements.\n              */\n-            auto exps = new Expressions(te.exps.dim);\n+            auto exps = new Expressions(te.exps.length);\n             foreach (i, e; (*te.exps)[])\n             {\n                 (*exps)[i] = new DotIdExp(e.loc, e, Id.offsetof);\n@@ -12612,7 +12620,7 @@ Expression semanticX(DotIdExp exp, Scope* sc)\n         if (exp.ident == Id.length)\n         {\n             // Don't evaluate te.e0 in runtime\n-            return new IntegerExp(exp.loc, te.exps.dim, Type.tsize_t);\n+            return new IntegerExp(exp.loc, te.exps.length, Type.tsize_t);\n         }\n     }\n \n@@ -13564,7 +13572,7 @@ private bool fit(StructDeclaration sd, const ref Loc loc, Scope* sc, Expressions\n \n     const nfields = sd.nonHiddenFields();\n     size_t offset = 0;\n-    for (size_t i = 0; i < elements.dim; i++)\n+    for (size_t i = 0; i < elements.length; i++)\n     {\n         Expression e = (*elements)[i];\n         if (!e)\n@@ -13573,7 +13581,7 @@ private bool fit(StructDeclaration sd, const ref Loc loc, Scope* sc, Expressions\n         e = resolveProperties(sc, e);\n         if (i >= nfields)\n         {\n-            if (i < sd.fields.dim && e.op == EXP.null_)\n+            if (i < sd.fields.length && e.op == EXP.null_)\n             {\n                 // CTFE sometimes creates null as hidden pointer; we'll allow this.\n                 continue;"}, {"sha": "a941115acc43485afed91531cfc01f595ec986ad", "filename": "gcc/d/dmd/file_manager.d", "status": "modified", "additions": 116, "deletions": 22, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Ffile_manager.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Ffile_manager.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffile_manager.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -12,7 +12,7 @@ module dmd.file_manager;\n \n import dmd.root.stringtable : StringTable;\n import dmd.root.file : File, Buffer;\n-import dmd.root.filename : FileName;\n+import dmd.root.filename : FileName, isDirSeparator;\n import dmd.root.string : toDString;\n import dmd.globals;\n import dmd.identifier;\n@@ -26,14 +26,86 @@ bool isPackageFileName(scope FileName fileName) nothrow\n     return FileName.equals(fileName.name, package_d) || FileName.equals(fileName.name, package_di);\n }\n \n+// A path stack that allows one to go up and down the path using directory\n+// separators. `cur` is the current path, `up` goes up one path, `down` goes\n+// down one path. if `up` or `down` return false, there are no further paths.\n+private struct PathStack\n+{\n+    private const(char)[] path;\n+    private size_t pos;\n+\n+    @safe @nogc nothrow pure:\n+\n+    this(const(char)[] p)\n+    {\n+        path = p;\n+        pos = p.length;\n+    }\n+\n+    const(char)[] cur()\n+    {\n+        return path[0 .. pos];\n+    }\n+\n+    bool up()\n+    {\n+        if (pos == 0)\n+            return false;\n+        while (--pos != 0)\n+            if (isDirSeparator(path[pos]))\n+                return true;\n+        return false;\n+    }\n+\n+    bool down()\n+    {\n+        if (pos == path.length)\n+            return false;\n+        while (++pos != path.length)\n+            if (isDirSeparator(path[pos]))\n+                return true;\n+        return false;\n+    }\n+}\n+\n final class FileManager\n {\n     private StringTable!(const(ubyte)[]) files;\n+    private StringTable!(bool) packageStatus;\n+\n+    // check if the package path of the given path exists. The input path is\n+    // expected to contain the full path to the module, so the parent\n+    // directories of that path are checked.\n+    private bool packageExists(const(char)[] p) nothrow\n+    {\n+        // step 1, look for the closest parent path that is cached\n+        bool exists = true;\n+        auto st = PathStack(p);\n+        while (st.up) {\n+            if (auto cached = packageStatus.lookup(st.cur)) {\n+                exists = cached.value;\n+                break;\n+            }\n+        }\n+        // found a parent that is cached (or reached the end of the stack).\n+        // step 2, traverse back up the stack storing either false if the\n+        // parent doesn't exist, or the result of the `exists` call if it does.\n+        while (st.down) {\n+            if (!exists)\n+                packageStatus.insert(st.cur, false);\n+            else\n+                exists = packageStatus.insert(st.cur, FileName.exists(st.cur) == 2).value;\n+        }\n+\n+        // at this point, exists should be the answer.\n+        return exists;\n+    }\n \n     ///\n     public this () nothrow\n     {\n         this.files._init();\n+        this.packageStatus._init();\n     }\n \n nothrow:\n@@ -48,50 +120,59 @@ nothrow:\n     *      the found file name or\n     *      `null` if it is not different from filename.\n     */\n-    static const(char)[] lookForSourceFile(const char[] filename, const char*[] path)\n+    const(char)[] lookForSourceFile(const char[] filename, const char*[] path)\n     {\n         //printf(\"lookForSourceFile(`%.*s`)\\n\", cast(int)filename.length, filename.ptr);\n         /* Search along path[] for .di file, then .d file, then .i file, then .c file.\n         */\n+        // see if we should check for the module locally.\n+        bool checkLocal = packageExists(filename);\n         const sdi = FileName.forceExt(filename, hdr_ext);\n-        if (FileName.exists(sdi) == 1)\n+        if (checkLocal && FileName.exists(sdi) == 1)\n             return sdi;\n         scope(exit) FileName.free(sdi.ptr);\n \n         const sd = FileName.forceExt(filename, mars_ext);\n         // Special file name representing `stdin`, always assume its presence\n         if (sd == \"__stdin.d\")\n             return sd;\n-        if (FileName.exists(sd) == 1)\n+        if (checkLocal && FileName.exists(sd) == 1)\n             return sd;\n         scope(exit) FileName.free(sd.ptr);\n \n         const si = FileName.forceExt(filename, i_ext);\n-        if (FileName.exists(si) == 1)\n+        if (checkLocal && FileName.exists(si) == 1)\n             return si;\n         scope(exit) FileName.free(si.ptr);\n \n         const sc = FileName.forceExt(filename, c_ext);\n-        if (FileName.exists(sc) == 1)\n+        if (checkLocal && FileName.exists(sc) == 1)\n             return sc;\n         scope(exit) FileName.free(sc.ptr);\n \n-        if (FileName.exists(filename) == 2)\n+        if (checkLocal)\n         {\n-            /* The filename exists and it's a directory.\n-            * Therefore, the result should be: filename/package.d\n-            * iff filename/package.d is a file\n-            */\n-            const ni = FileName.combine(filename, package_di);\n-            if (FileName.exists(ni) == 1)\n-                return ni;\n-            FileName.free(ni.ptr);\n-\n-            const n = FileName.combine(filename, package_d);\n-            if (FileName.exists(n) == 1)\n-                return n;\n-            FileName.free(n.ptr);\n+            auto cached = packageStatus.lookup(filename);\n+            if (!cached)\n+                cached = packageStatus.insert(filename, FileName.exists(filename) == 2);\n+            if (cached.value)\n+            {\n+                /* The filename exists and it's a directory.\n+                 * Therefore, the result should be: filename/package.d\n+                 * iff filename/package.d is a file\n+                 */\n+                const ni = FileName.combine(filename, package_di);\n+                if (FileName.exists(ni) == 1)\n+                    return ni;\n+                FileName.free(ni.ptr);\n+\n+                const n = FileName.combine(filename, package_d);\n+                if (FileName.exists(n) == 1)\n+                    return n;\n+                FileName.free(n.ptr);\n+            }\n         }\n+\n         if (FileName.absolute(filename))\n             return null;\n         if (!path.length)\n@@ -101,6 +182,11 @@ nothrow:\n             const p = entry.toDString();\n \n             const(char)[] n = FileName.combine(p, sdi);\n+\n+            if (!packageExists(n)) {\n+                FileName.free(n.ptr);\n+                continue; // no need to check for anything else.\n+            }\n             if (FileName.exists(n) == 1) {\n                 return n;\n             }\n@@ -127,7 +213,16 @@ nothrow:\n             const b = FileName.removeExt(filename);\n             n = FileName.combine(p, b);\n             FileName.free(b.ptr);\n-            if (FileName.exists(n) == 2)\n+\n+            scope(exit) FileName.free(n.ptr);\n+\n+            // also cache this if we are looking for package.d[i]\n+            auto cached = packageStatus.lookup(n);\n+            if (!cached) {\n+                cached = packageStatus.insert(n, FileName.exists(n) == 2);\n+            }\n+\n+            if (cached.value)\n             {\n                 const n2i = FileName.combine(n, package_di);\n                 if (FileName.exists(n2i) == 1)\n@@ -139,7 +234,6 @@ nothrow:\n                 }\n                 FileName.free(n2.ptr);\n             }\n-            FileName.free(n.ptr);\n         }\n         return null;\n     }"}, {"sha": "93e3634372171d7ecb1f4411292a8e5ea568822a", "filename": "gcc/d/dmd/func.d", "status": "modified", "additions": 67, "deletions": 51, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Ffunc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Ffunc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -640,7 +640,7 @@ extern (C++) class FuncDeclaration : Declaration\n     }\n \n     /*************************************************\n-     * Find index of function in vtbl[0..dim] that\n+     * Find index of function in vtbl[0..length] that\n      * this function overrides.\n      * Prefer an exact match to a covariant one.\n      * Params:\n@@ -777,7 +777,7 @@ extern (C++) class FuncDeclaration : Declaration\n         {\n             foreach (b; cd.interfaces)\n             {\n-                auto v = findVtblIndex(&b.sym.vtbl, cast(int)b.sym.vtbl.dim);\n+                auto v = findVtblIndex(&b.sym.vtbl, cast(int)b.sym.vtbl.length);\n                 if (v >= 0)\n                     return b;\n             }\n@@ -1810,7 +1810,7 @@ extern (C++) class FuncDeclaration : Declaration\n         if (!isVirtual())\n             return false;\n         // If it's a final method, and does not override anything, then it is not virtual\n-        if (isFinalFunc() && foverrides.dim == 0)\n+        if (isFinalFunc() && foverrides.length == 0)\n         {\n             return false;\n         }\n@@ -1967,7 +1967,7 @@ extern (C++) class FuncDeclaration : Declaration\n                 if (fdthis != this)\n                 {\n                     bool found = false;\n-                    for (size_t i = 0; i < siblingCallers.dim; ++i)\n+                    for (size_t i = 0; i < siblingCallers.length; ++i)\n                     {\n                         if (siblingCallers[i] == fdthis)\n                             found = true;\n@@ -2033,12 +2033,12 @@ extern (C++) class FuncDeclaration : Declaration\n         if (requiresClosure)\n             goto Lyes;\n \n-        for (size_t i = 0; i < closureVars.dim; i++)\n+        for (size_t i = 0; i < closureVars.length; i++)\n         {\n             VarDeclaration v = closureVars[i];\n             //printf(\"\\tv = %s\\n\", v.toChars());\n \n-            for (size_t j = 0; j < v.nestedrefs.dim; j++)\n+            for (size_t j = 0; j < v.nestedrefs.length; j++)\n             {\n                 FuncDeclaration f = v.nestedrefs[j];\n                 assert(f != this);\n@@ -2167,7 +2167,7 @@ extern (C++) class FuncDeclaration : Declaration\n      */\n     final bool hasNestedFrameRefs()\n     {\n-        if (closureVars.dim)\n+        if (closureVars.length)\n             return true;\n \n         /* If a virtual function has contracts, assume its variables are referenced\n@@ -2181,9 +2181,9 @@ extern (C++) class FuncDeclaration : Declaration\n         if (fdrequire || fdensure)\n             return true;\n \n-        if (foverrides.dim && isVirtualMethod())\n+        if (foverrides.length && isVirtualMethod())\n         {\n-            for (size_t i = 0; i < foverrides.dim; i++)\n+            for (size_t i = 0; i < foverrides.length; i++)\n             {\n                 FuncDeclaration fdv = foverrides[i];\n                 if (fdv.hasNestedFrameRefs())\n@@ -2406,7 +2406,7 @@ extern (C++) class FuncDeclaration : Declaration\n              * becomes:\n              *   in { { statements1... } { statements2... } ... }\n              */\n-            assert(frequires.dim);\n+            assert(frequires.length);\n             auto loc = (*frequires)[0].loc;\n             auto s = new Statements;\n             foreach (r; *frequires)\n@@ -2425,7 +2425,7 @@ extern (C++) class FuncDeclaration : Declaration\n              *   out(__result) { { ref id1 = __result; { statements1... } }\n              *                   { ref id2 = __result; { statements2... } } ... }\n              */\n-            assert(fensures.dim);\n+            assert(fensures.length);\n             auto loc = (*fensures)[0].ensure.loc;\n             auto s = new Statements;\n             foreach (r; *fensures)\n@@ -3133,7 +3133,7 @@ FuncDeclaration resolveFuncCall(const ref Loc loc, Scope* sc, Dsymbol s,\n             printf(\"\\tthis: %s\\n\", tthis.toChars());\n         if (fargs)\n         {\n-            for (size_t i = 0; i < fargs.dim; i++)\n+            for (size_t i = 0; i < fargs.length; i++)\n             {\n                 Expression arg = (*fargs)[i];\n                 assert(arg.type);\n@@ -3352,46 +3352,40 @@ if (is(Decl == TemplateDeclaration) || is(Decl == FuncDeclaration))\n {\n     // max num of overloads to print (-v overrides this).\n     enum int DisplayLimit = 5;\n-    int displayed;\n     const(char)* constraintsTip;\n-\n     // determine if the first candidate was printed\n-    bool printed = false;\n+    int printed;\n \n-    overloadApply(declaration, (Dsymbol s)\n+    bool matchSymbol(Dsymbol s, bool print, bool single_candidate = false)\n     {\n-        Dsymbol nextOverload;\n-\n         if (auto fd = s.isFuncDeclaration())\n         {\n             // Don't print overloads which have errors.\n             // Not that if the whole overload set has errors, we'll never reach\n             // this point so there's no risk of printing no candidate\n             if (fd.errors || fd.type.ty == Terror)\n-                return 0;\n+                return false;\n             // Don't print disabled functions, or `deprecated` outside of deprecated scope\n             if (fd.storage_class & STC.disable || (fd.isDeprecated() && !showDeprecated))\n-                return 0;\n-\n-            const single_candidate = fd.overnext is null;\n+                return false;\n+            if (!print)\n+                return true;\n             auto tf = cast(TypeFunction) fd.type;\n             .errorSupplemental(fd.loc,\n                     printed ? \"                `%s%s`\" :\n                     single_candidate ? \"Candidate is: `%s%s`\" : \"Candidates are: `%s%s`\",\n                     fd.toPrettyChars(),\n                 parametersTypeToChars(tf.parameterList));\n-            printed = true;\n-            nextOverload = fd.overnext;\n         }\n         else if (auto td = s.isTemplateDeclaration())\n         {\n             import dmd.staticcond;\n \n+            if (!print)\n+                return true;\n             const tmsg = td.toCharsNoConstraints();\n             const cmsg = td.getConstraintEvalError(constraintsTip);\n \n-            const single_candidate = td.overnext is null;\n-\n             // add blank space if there are multiple candidates\n             // the length of the blank space is `strlen(\"Candidates are: \")`\n \n@@ -3401,34 +3395,45 @@ if (is(Decl == TemplateDeclaration) || is(Decl == FuncDeclaration))\n                         printed ? \"                `%s`\\n%s\" :\n                         single_candidate ? \"Candidate is: `%s`\\n%s\" : \"Candidates are: `%s`\\n%s\",\n                         tmsg, cmsg);\n-                printed = true;\n             }\n             else\n             {\n                 .errorSupplemental(td.loc,\n                         printed ? \"                `%s`\" :\n                         single_candidate ? \"Candidate is: `%s`\" : \"Candidates are: `%s`\",\n                         tmsg);\n-                printed = true;\n             }\n-            nextOverload = td.overnext;\n         }\n-\n-        if (global.params.verbose || ++displayed < DisplayLimit)\n-            return 0;\n-\n-        // Too many overloads to sensibly display.\n-        // Just show count of remaining overloads.\n-        int num = 0;\n-        overloadApply(nextOverload, (s) { ++num; return 0; });\n-\n-        if (num > 0)\n-            .errorSupplemental(loc, \"... (%d more, -v to show) ...\", num);\n-        return 1;   // stop iterating\n+        return true;\n+    }\n+    // determine if there's > 1 candidate\n+    int count = 0;\n+    overloadApply(declaration, (s) {\n+        if (matchSymbol(s, false))\n+            count++;\n+        return count > 1;\n+    });\n+    int skipped = 0;\n+    overloadApply(declaration, (s) {\n+        if (global.params.verbose || printed < DisplayLimit)\n+        {\n+            if (matchSymbol(s, true, count == 1))\n+                printed++;\n+        }\n+        else\n+        {\n+            // Too many overloads to sensibly display.\n+            // Just show count of remaining overloads.\n+            if (matchSymbol(s, false))\n+                skipped++;\n+        }\n+        return 0;\n     });\n+    if (skipped > 0)\n+        .errorSupplemental(loc, \"... (%d more, -v to show) ...\", skipped);\n \n     // Nothing was displayed, all overloads are either disabled or deprecated\n-    if (!displayed)\n+    if (!printed)\n         .errorSupplemental(loc, \"All possible candidates are marked as `deprecated` or `@disable`\");\n     // should be only in verbose mode\n     if (constraintsTip)\n@@ -3570,7 +3575,7 @@ private void markAsNeedingClosure(Dsymbol f, FuncDeclaration outerFunc)\n     for (Dsymbol sx = f; sx && sx != outerFunc; sx = sx.toParentP(outerFunc))\n     {\n         FuncDeclaration fy = sx.isFuncDeclaration();\n-        if (fy && fy.closureVars.dim)\n+        if (fy && fy.closureVars.length)\n         {\n             /* fy needs a closure if it has closureVars[],\n              * because the frame pointer in the closure will be accessed.\n@@ -3608,7 +3613,7 @@ private bool checkEscapingSiblings(FuncDeclaration f, FuncDeclaration outerFunc,\n \n     //printf(\"checkEscapingSiblings(f = %s, outerfunc = %s)\\n\", f.toChars(), outerFunc.toChars());\n     bool bAnyClosures = false;\n-    for (size_t i = 0; i < f.siblingCallers.dim; ++i)\n+    for (size_t i = 0; i < f.siblingCallers.length; ++i)\n     {\n         FuncDeclaration g = f.siblingCallers[i];\n         if (g.isThis() || g.tookAddressOf)\n@@ -4351,19 +4356,30 @@ bool setUnsafe(Scope* sc,\n     bool gag = false, Loc loc = Loc.init, const(char)* fmt = null,\n     RootObject arg0 = null, RootObject arg1 = null, RootObject arg2 = null)\n {\n-    // TODO:\n-    // For @system variables, unsafe initializers at global scope should mark\n-    // the variable @system, see https://dlang.org/dips/1035\n-\n-    if (!sc.func)\n-        return false;\n-\n     if (sc.intypeof)\n         return false; // typeof(cast(int*)0) is safe\n \n     if (sc.flags & SCOPE.debug_) // debug {} scopes are permissive\n         return false;\n \n+    if (!sc.func)\n+    {\n+        if (sc.varDecl)\n+        {\n+            if (sc.varDecl.storage_class & STC.safe)\n+            {\n+                .error(loc, fmt, arg0 ? arg0.toChars() : \"\", arg1 ? arg1.toChars() : \"\", arg2 ? arg2.toChars() : \"\");\n+                return true;\n+            }\n+            else if (!(sc.varDecl.storage_class & STC.system))\n+            {\n+                sc.varDecl.storage_class |= STC.system;\n+            }\n+        }\n+        return false;\n+    }\n+\n+\n     if (sc.flags & SCOPE.compile) // __traits(compiles, x)\n     {\n         if (sc.func.isSafeBypassingInference())"}, {"sha": "6b51a81acc5ec577412f6470c5f8d901d8c4926b", "filename": "gcc/d/dmd/hdrgen.d", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fhdrgen.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fhdrgen.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -484,7 +484,7 @@ public:\n     {\n         buf.writestring(\"pragma (\");\n         buf.writestring(s.ident.toString());\n-        if (s.args && s.args.dim)\n+        if (s.args && s.args.length)\n         {\n             buf.writestring(\", \");\n             argsToBuffer(s.args, buf, hgs);\n@@ -883,7 +883,7 @@ public:\n             buf.printf(\"%s.\", pid.toChars());\n         }\n         buf.writestring(imp.id.toString());\n-        if (imp.names.dim)\n+        if (imp.names.length)\n         {\n             buf.writestring(\" : \");\n             foreach (const i, const name; imp.names)\n@@ -922,13 +922,13 @@ public:\n             buf.writenl();\n             return;\n         }\n-        if (d.decl.dim == 0 || (hgs.hdrgen && d.decl.dim == 1 && (*d.decl)[0].isUnitTestDeclaration()))\n+        if (d.decl.length == 0 || (hgs.hdrgen && d.decl.length == 1 && (*d.decl)[0].isUnitTestDeclaration()))\n         {\n             // hack for bugzilla 8081\n             if (hasSTC) buf.writeByte(' ');\n             buf.writestring(\"{}\");\n         }\n-        else if (d.decl.dim == 1)\n+        else if (d.decl.length == 1)\n         {\n             if (hasSTC) buf.writeByte(' ');\n             (*d.decl)[0].accept(this);\n@@ -993,9 +993,9 @@ public:\n     {\n         visibilityToBuffer(buf, d.visibility);\n         AttribDeclaration ad = cast(AttribDeclaration)d;\n-        if (ad.decl.dim <= 1)\n+        if (ad.decl.length <= 1)\n             buf.writeByte(' ');\n-        if (ad.decl.dim == 1 && (*ad.decl)[0].isVisibilityDeclaration)\n+        if (ad.decl.length == 1 && (*ad.decl)[0].isVisibilityDeclaration)\n             visit(cast(AttribDeclaration)(*ad.decl)[0]);\n         else\n             visit(cast(AttribDeclaration)d);\n@@ -1011,7 +1011,7 @@ public:\n                     buf.writeByte(' ');\n                 buf.printf(\"align (%s)\", exp.toChars());\n             }\n-            if (d.decl && d.decl.dim < 2)\n+            if (d.decl && d.decl.length < 2)\n                 buf.writeByte(' ');\n         }\n         else\n@@ -1041,7 +1041,7 @@ public:\n     {\n         buf.writestring(\"pragma (\");\n         buf.writestring(d.ident.toString());\n-        if (d.args && d.args.dim)\n+        if (d.args && d.args.length)\n         {\n             buf.writestring(\", \");\n             argsToBuffer(d.args, buf, hgs);\n@@ -1210,7 +1210,7 @@ public:\n \n     bool visitEponymousMember(TemplateDeclaration d)\n     {\n-        if (!d.members || d.members.dim != 1)\n+        if (!d.members || d.members.length != 1)\n             return false;\n         Dsymbol onemember = (*d.members)[0];\n         if (onemember.ident != d.ident)\n@@ -1286,7 +1286,7 @@ public:\n \n     void visitTemplateParameters(TemplateParameters* parameters)\n     {\n-        if (!parameters || !parameters.dim)\n+        if (!parameters || !parameters.length)\n             return;\n         foreach (i, p; *parameters)\n         {\n@@ -1437,7 +1437,7 @@ public:\n \n     void visitBaseClasses(ClassDeclaration d)\n     {\n-        if (!d || !d.baseclasses.dim)\n+        if (!d || !d.baseclasses.length)\n             return;\n         if (!d.isAnonymous())\n             buf.writestring(\" : \");\n@@ -1722,7 +1722,7 @@ public:\n         Statement s1;\n         if (f.semanticRun >= PASS.semantic3done && cs)\n         {\n-            s1 = (*cs.statements)[cs.statements.dim - 1];\n+            s1 = (*cs.statements)[cs.statements.length - 1];\n         }\n         else\n             s1 = !cs ? f.fbody : null;\n@@ -2130,7 +2130,7 @@ private void expressionPrettyPrint(Expression e, OutBuffer* buf, HdrGenState* hg\n         }\n         buf.writestring(\"new \");\n         typeToBuffer(e.newtype, null, buf, hgs);\n-        if (e.arguments && e.arguments.dim)\n+        if (e.arguments && e.arguments.length)\n         {\n             buf.writeByte('(');\n             argsToBuffer(e.arguments, buf, hgs);\n@@ -2147,7 +2147,7 @@ private void expressionPrettyPrint(Expression e, OutBuffer* buf, HdrGenState* hg\n         }\n         buf.writestring(\"new\");\n         buf.writestring(\" class \");\n-        if (e.arguments && e.arguments.dim)\n+        if (e.arguments && e.arguments.length)\n         {\n             buf.writeByte('(');\n             argsToBuffer(e.arguments, buf, hgs);\n@@ -2271,7 +2271,7 @@ private void expressionPrettyPrint(Expression e, OutBuffer* buf, HdrGenState* hg\n                 buf.writestring(\" == \");\n             typeToBuffer(e.tspec, null, buf, hgs);\n         }\n-        if (e.parameters && e.parameters.dim)\n+        if (e.parameters && e.parameters.length)\n         {\n             buf.writestring(\", \");\n             scope v = new DsymbolPrettyPrintVisitor(buf, hgs);\n@@ -3100,7 +3100,7 @@ void toCBuffer(const Expression e, OutBuffer* buf, HdrGenState* hgs)\n  */\n void argExpTypesToCBuffer(OutBuffer* buf, Expressions* arguments)\n {\n-    if (!arguments || !arguments.dim)\n+    if (!arguments || !arguments.length)\n         return;\n     HdrGenState hgs;\n     foreach (i, arg; *arguments)\n@@ -3119,7 +3119,7 @@ void toCBuffer(const TemplateParameter tp, OutBuffer* buf, HdrGenState* hgs)\n \n void arrayObjectsToBuffer(OutBuffer* buf, Objects* objects)\n {\n-    if (!objects || !objects.dim)\n+    if (!objects || !objects.length)\n         return;\n     HdrGenState hgs;\n     foreach (i, o; *objects)\n@@ -3160,7 +3160,7 @@ const(char)* parameterToChars(Parameter parameter, TypeFunction tf, bool fullQua\n \n     parameterToBuffer(parameter, &buf, &hgs);\n \n-    if (tf.parameterList.varargs == VarArg.typesafe && parameter == tf.parameterList[tf.parameterList.parameters.dim - 1])\n+    if (tf.parameterList.varargs == VarArg.typesafe && parameter == tf.parameterList[tf.parameterList.parameters.length - 1])\n     {\n         buf.writestring(\"...\");\n     }\n@@ -3219,7 +3219,7 @@ private void parameterToBuffer(Parameter p, OutBuffer* buf, HdrGenState* hgs)\n     {\n         buf.writeByte('@');\n \n-        bool isAnonymous = p.userAttribDecl.atts.dim > 0 && !(*p.userAttribDecl.atts)[0].isCallExp();\n+        bool isAnonymous = p.userAttribDecl.atts.length > 0 && !(*p.userAttribDecl.atts)[0].isCallExp();\n         if (isAnonymous)\n             buf.writeByte('(');\n \n@@ -3281,7 +3281,7 @@ private void parameterToBuffer(Parameter p, OutBuffer* buf, HdrGenState* hgs)\n  */\n private void argsToBuffer(Expressions* expressions, OutBuffer* buf, HdrGenState* hgs, Expression basis = null)\n {\n-    if (!expressions || !expressions.dim)\n+    if (!expressions || !expressions.length)\n         return;\n     version (all)\n     {\n@@ -3298,11 +3298,11 @@ private void argsToBuffer(Expressions* expressions, OutBuffer* buf, HdrGenState*\n     else\n     {\n         // Sparse style formatting, for debug use only\n-        //      [0..dim: basis, 1: e1, 5: e5]\n+        //      [0..length: basis, 1: e1, 5: e5]\n         if (basis)\n         {\n             buf.writestring(\"0..\");\n-            buf.print(expressions.dim);\n+            buf.print(expressions.length);\n             buf.writestring(\": \");\n             expToBuffer(basis, PREC.assign, buf, hgs);\n         }\n@@ -3483,12 +3483,12 @@ private void tiargsToBuffer(TemplateInstance ti, OutBuffer* buf, HdrGenState* hg\n         buf.writestring(\"()\");\n         return;\n     }\n-    if (ti.tiargs.dim == 1)\n+    if (ti.tiargs.length == 1)\n     {\n         RootObject oarg = (*ti.tiargs)[0];\n         if (Type t = isType(oarg))\n         {\n-            if (t.equals(Type.tstring) || t.equals(Type.twstring) || t.equals(Type.tdstring) || t.mod == 0 && (t.isTypeBasic() || t.ty == Tident && (cast(TypeIdentifier)t).idents.dim == 0))\n+            if (t.equals(Type.tstring) || t.equals(Type.twstring) || t.equals(Type.tdstring) || t.mod == 0 && (t.isTypeBasic() || t.ty == Tident && (cast(TypeIdentifier)t).idents.length == 0))\n             {\n                 buf.writestring(t.toChars());\n                 return;"}, {"sha": "f85e1ab2518ad84e0cc7bdfef926884e9e87f20e", "filename": "gcc/d/dmd/iasmgcc.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fiasmgcc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fiasmgcc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fiasmgcc.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -332,7 +332,7 @@ extern (C++) public Statement gccAsmSemantic(GccAsmStatement s, Scope *sc)\n     // Analyse all input and output operands.\n     if (s.args)\n     {\n-        foreach (i; 0 .. s.args.dim)\n+        foreach (i; 0 .. s.args.length)\n         {\n             Expression e = (*s.args)[i];\n             e = e.expressionSemantic(sc);\n@@ -353,7 +353,7 @@ extern (C++) public Statement gccAsmSemantic(GccAsmStatement s, Scope *sc)\n     // Analyse all clobbers.\n     if (s.clobbers)\n     {\n-        foreach (i; 0 .. s.clobbers.dim)\n+        foreach (i; 0 .. s.clobbers.length)\n         {\n             Expression e = (*s.clobbers)[i];\n             e = e.expressionSemantic(sc);\n@@ -365,7 +365,7 @@ extern (C++) public Statement gccAsmSemantic(GccAsmStatement s, Scope *sc)\n     // Analyse all goto labels.\n     if (s.labels)\n     {\n-        foreach (i; 0 .. s.labels.dim)\n+        foreach (i; 0 .. s.labels.length)\n         {\n             Identifier ident = (*s.labels)[i];\n             GotoStatement gs = new GotoStatement(s.loc, ident);"}, {"sha": "f57b4e644a390410597809b302acedbab6f9c4c7", "filename": "gcc/d/dmd/init.d", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Finit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Finit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -271,10 +271,10 @@ Initializer syntaxCopy(Initializer inx)\n     static Initializer copyStruct(StructInitializer vi)\n     {\n         auto si = new StructInitializer(vi.loc);\n-        assert(vi.field.dim == vi.value.dim);\n-        si.field.setDim(vi.field.dim);\n-        si.value.setDim(vi.value.dim);\n-        foreach (const i; 0 .. vi.field.dim)\n+        assert(vi.field.length == vi.value.length);\n+        si.field.setDim(vi.field.length);\n+        si.value.setDim(vi.value.length);\n+        foreach (const i; 0 .. vi.field.length)\n         {\n             si.field[i] = vi.field[i];\n             si.value[i] = vi.value[i].syntaxCopy();\n@@ -285,10 +285,10 @@ Initializer syntaxCopy(Initializer inx)\n     static Initializer copyArray(ArrayInitializer vi)\n     {\n         auto ai = new ArrayInitializer(vi.loc);\n-        assert(vi.index.dim == vi.value.dim);\n-        ai.index.setDim(vi.index.dim);\n-        ai.value.setDim(vi.value.dim);\n-        foreach (const i; 0 .. vi.value.dim)\n+        assert(vi.index.length == vi.value.length);\n+        ai.index.setDim(vi.index.length);\n+        ai.value.setDim(vi.value.length);\n+        foreach (const i; 0 .. vi.value.length)\n         {\n             ai.index[i] = vi.index[i] ? vi.index[i].syntaxCopy() : null;\n             ai.value[i] = vi.value[i].syntaxCopy();"}, {"sha": "ecaa5e8f710897396745196eaaf3f39581726c00", "filename": "gcc/d/dmd/initsem.d", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Finitsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Finitsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -55,7 +55,7 @@ Expression toAssocArrayLiteral(ArrayInitializer ai)\n     Expression e;\n     //printf(\"ArrayInitializer::toAssocArrayInitializer()\\n\");\n     //static int i; if (++i == 2) assert(0);\n-    const dim = ai.value.dim;\n+    const dim = ai.value.length;\n     auto keys = new Expressions(dim);\n     auto values = new Expressions(dim);\n     for (size_t i = 0; i < dim; i++)\n@@ -249,7 +249,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             auto ie = new ExpInitializer(i.loc, sle);\n             return ie.initializerSemantic(sc, t, needInterpret);\n         }\n-        else if ((t.ty == Tdelegate || t.isPtrToFunction()) && i.value.dim == 0)\n+        else if ((t.ty == Tdelegate || t.isPtrToFunction()) && i.value.length == 0)\n         {\n             const tok = (t.ty == Tdelegate) ? TOK.delegate_ : TOK.function_;\n             /* Rewrite as empty delegate literal { }\n@@ -315,7 +315,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         }\n         i.type = t;\n         length = 0;\n-        for (size_t j = 0; j < i.index.dim; j++)\n+        for (size_t j = 0; j < i.index.length; j++)\n         {\n             Expression idx = i.index[j];\n             if (idx)\n@@ -350,7 +350,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                 TupleExp te = ei.exp.isTupleExp();\n                 i.index.remove(j);\n                 i.value.remove(j);\n-                for (size_t k = 0; k < te.exps.dim; ++k)\n+                for (size_t k = 0; k < te.exps.length; ++k)\n                 {\n                     Expression e = (*te.exps)[k];\n                     i.index.insert(j + k, cast(Expression)null);\n@@ -475,7 +475,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         {\n             return i; // Failed, suppress duplicate error messages\n         }\n-        if (i.exp.type.isTypeTuple() && i.exp.type.isTypeTuple().arguments.dim == 0)\n+        if (i.exp.type.isTypeTuple() && i.exp.type.isTypeTuple().arguments.length == 0)\n         {\n             Type et = i.exp.type;\n             i.exp = new TupleExp(i.exp.loc, new Expressions());\n@@ -638,7 +638,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                 uinteger_t dim2 = dim1;\n                 if (auto ale = i.exp.isArrayLiteralExp())\n                 {\n-                    dim2 = ale.elements ? ale.elements.dim : 0;\n+                    dim2 = ale.elements ? ale.elements.length : 0;\n                 }\n                 else if (auto se = i.exp.isSliceExp())\n                 {\n@@ -1094,9 +1094,9 @@ Initializer inferType(Initializer init, Scope* sc)\n         Expressions* values;\n         if (init.isAssociativeArray())\n         {\n-            keys = new Expressions(init.value.dim);\n-            values = new Expressions(init.value.dim);\n-            for (size_t i = 0; i < init.value.dim; i++)\n+            keys = new Expressions(init.value.length);\n+            values = new Expressions(init.value.length);\n+            for (size_t i = 0; i < init.value.length; i++)\n             {\n                 Expression e = init.index[i];\n                 if (!e)\n@@ -1119,9 +1119,9 @@ Initializer inferType(Initializer init, Scope* sc)\n         }\n         else\n         {\n-            auto elements = new Expressions(init.value.dim);\n+            auto elements = new Expressions(init.value.length);\n             elements.zero();\n-            for (size_t i = 0; i < init.value.dim; i++)\n+            for (size_t i = 0; i < init.value.length; i++)\n             {\n                 assert(!init.index[i]); // already asserted by isAssociativeArray()\n                 Initializer iz = init.value[i];\n@@ -1300,9 +1300,9 @@ extern (C++) Expression initializerToExpression(Initializer init, Type itype = n\n         {\n             /* Calculate the length of the array literal\n              */\n-            edim = cast(uint)init.value.dim;\n+            edim = cast(uint)init.value.length;\n             size_t j = 0;\n-            foreach (i; 0 .. init.value.dim)\n+            foreach (i; 0 .. init.value.length)\n             {\n                 if (auto e = init.index[i])\n                 {\n@@ -1325,7 +1325,7 @@ extern (C++) Expression initializerToExpression(Initializer init, Type itype = n\n         auto elements = new Expressions(edim);\n         elements.zero();\n         size_t j = 0;\n-        foreach (i; 0 .. init.value.dim)\n+        foreach (i; 0 .. init.value.length)\n         {\n             if (auto e = init.index[i])\n                 j = cast(size_t)e.toInteger();"}, {"sha": "b7719d8439f01a606403b5f6681b74679fbd241b", "filename": "gcc/d/dmd/json.d", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fjson.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fjson.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fjson.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -386,13 +386,13 @@ public:\n \n     extern(D) void property(const char[] name, Parameters* parameters)\n     {\n-        if (parameters is null || parameters.dim == 0)\n+        if (parameters is null || parameters.length == 0)\n             return;\n         propertyStart(name);\n         arrayStart();\n         if (parameters)\n         {\n-            for (size_t i = 0; i < parameters.dim; i++)\n+            for (size_t i = 0; i < parameters.length; i++)\n             {\n                 Parameter p = (*parameters)[i];\n                 objectStart();\n@@ -491,7 +491,7 @@ public:\n         property(\"comment\", s.comment.toDString);\n         propertyStart(\"members\");\n         arrayStart();\n-        for (size_t i = 0; i < s.members.dim; i++)\n+        for (size_t i = 0; i < s.members.length; i++)\n         {\n             (*s.members)[i].accept(this);\n         }\n@@ -522,7 +522,7 @@ public:\n             property(\"alias\", s.aliasId.toString());\n         bool hasRenamed = false;\n         bool hasSelective = false;\n-        for (size_t i = 0; i < s.aliases.dim; i++)\n+        for (size_t i = 0; i < s.aliases.length; i++)\n         {\n             // avoid empty \"renamed\" and \"selective\" sections\n             if (hasRenamed && hasSelective)\n@@ -537,7 +537,7 @@ public:\n             // import foo : alias1 = target1;\n             propertyStart(\"renamed\");\n             objectStart();\n-            for (size_t i = 0; i < s.aliases.dim; i++)\n+            for (size_t i = 0; i < s.aliases.length; i++)\n             {\n                 const name = s.names[i];\n                 const _alias = s.aliases[i];\n@@ -566,7 +566,7 @@ public:\n         Dsymbols* ds = d.include(null);\n         if (ds)\n         {\n-            for (size_t i = 0; i < ds.dim; i++)\n+            for (size_t i = 0; i < ds.length; i++)\n             {\n                 Dsymbol s = (*ds)[i];\n                 s.accept(this);\n@@ -582,7 +582,7 @@ public:\n             return; // Don't visit the if/else bodies again below\n         }\n         Dsymbols* ds = d.decl ? d.decl : d.elsedecl;\n-        for (size_t i = 0; i < ds.dim; i++)\n+        for (size_t i = 0; i < ds.length; i++)\n         {\n             Dsymbol s = (*ds)[i];\n             s.accept(this);\n@@ -631,7 +631,7 @@ public:\n         {\n             propertyStart(\"members\");\n             arrayStart();\n-            for (size_t i = 0; i < d.members.dim; i++)\n+            for (size_t i = 0; i < d.members.length; i++)\n             {\n                 Dsymbol s = (*d.members)[i];\n                 s.accept(this);\n@@ -649,11 +649,11 @@ public:\n         if (tf && tf.ty == Tfunction)\n             property(\"parameters\", tf.parameterList.parameters);\n         property(\"endline\", \"endchar\", d.endloc);\n-        if (d.foverrides.dim)\n+        if (d.foverrides.length)\n         {\n             propertyStart(\"overrides\");\n             arrayStart();\n-            for (size_t i = 0; i < d.foverrides.dim; i++)\n+            for (size_t i = 0; i < d.foverrides.length; i++)\n             {\n                 FuncDeclaration fd = d.foverrides[i];\n                 item(fd.toPrettyChars().toDString);\n@@ -681,7 +681,7 @@ public:\n         jsonProperties(d);\n         propertyStart(\"parameters\");\n         arrayStart();\n-        for (size_t i = 0; i < d.parameters.dim; i++)\n+        for (size_t i = 0; i < d.parameters.length; i++)\n         {\n             TemplateParameter s = (*d.parameters)[i];\n             objectStart();\n@@ -732,7 +732,7 @@ public:\n         }\n         propertyStart(\"members\");\n         arrayStart();\n-        for (size_t i = 0; i < d.members.dim; i++)\n+        for (size_t i = 0; i < d.members.length; i++)\n         {\n             Dsymbol s = (*d.members)[i];\n             s.accept(this);\n@@ -747,7 +747,7 @@ public:\n         {\n             if (d.members)\n             {\n-                for (size_t i = 0; i < d.members.dim; i++)\n+                for (size_t i = 0; i < d.members.length; i++)\n                 {\n                     Dsymbol s = (*d.members)[i];\n                     s.accept(this);\n@@ -762,7 +762,7 @@ public:\n         {\n             propertyStart(\"members\");\n             arrayStart();\n-            for (size_t i = 0; i < d.members.dim; i++)\n+            for (size_t i = 0; i < d.members.length; i++)\n             {\n                 Dsymbol s = (*d.members)[i];\n                 s.accept(this);\n@@ -963,7 +963,7 @@ public:\n             requiredProperty(\"name\", m.md ? m.md.toString() : null);\n             requiredProperty(\"file\", m.srcfile.toString());\n             propertyBool(\"isRoot\", m.isRoot());\n-            if(m.contentImportedFiles.dim > 0)\n+            if(m.contentImportedFiles.length > 0)\n             {\n                 propertyStart(\"contentImports\");\n                 arrayStart();"}, {"sha": "e1ed717ab851122fc9e23cff2c3466b51cdcb39f", "filename": "gcc/d/dmd/lambdacomp.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Flambdacomp.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Flambdacomp.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flambdacomp.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -452,7 +452,7 @@ public:\n         if (ty)\n         {\n             writeMangledName(ty.sym);\n-            auto dim = e.elements.dim;\n+            auto dim = e.elements.length;\n             foreach (i; 0..dim)\n             {\n                 auto elem = (*e.elements)[i];"}, {"sha": "200d74f3aad1e8c76511ca2f9d66fd993e1ea089", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -126,18 +126,26 @@ class Lexer\n         if (p && p[0] == '#' && p[1] == '!')\n         {\n             p += 2;\n-            while (1)\n+            for (;;p++)\n             {\n-                char c = *p++;\n+                char c = *p;\n                 switch (c)\n                 {\n+                case '\\n':\n+                    p++;\n+                    goto case;\n                 case 0:\n                 case 0x1A:\n-                    p--;\n-                    goto case;\n-                case '\\n':\n                     break;\n+\n                 default:\n+                    // Note: We do allow malformed UTF-8 on shebang line.\n+                    // It could have a meaning if the native system\n+                    // encoding is not Unicode. See test compilable/test13512.d\n+                    // for example encoded in KOI-8.\n+                    // We also allow bidirectional control characters.\n+                    // We do not execute the shebang line, so it can't be used\n+                    // to conceal code. It is up to the shell to sanitize it.\n                     continue;\n                 }\n                 break;\n@@ -522,7 +530,7 @@ class Lexer\n                             const u = decodeUTF();\n                             if (isUniAlpha(u))\n                                 continue;\n-                            error(\"char 0x%04x not allowed in identifier\", u);\n+                            error(t.loc, \"char 0x%04x not allowed in identifier\", u);\n                             p = s;\n                         }\n                         break;\n@@ -620,7 +628,7 @@ class Lexer\n                                 continue;\n                             case 0:\n                             case 0x1A:\n-                                error(\"unterminated /* */ comment\");\n+                                error(t.loc, \"unterminated /* */ comment\");\n                                 p = end;\n                                 t.loc = loc();\n                                 t.value = TOK.endOfFile;\n@@ -756,7 +764,7 @@ class Lexer\n                                 continue;\n                             case 0:\n                             case 0x1A:\n-                                error(\"unterminated /+ +/ comment\");\n+                                error(t.loc, \"unterminated /+ +/ comment\");\n                                 p = end;\n                                 t.loc = loc();\n                                 t.value = TOK.endOfFile;\n@@ -1126,11 +1134,12 @@ class Lexer\n                         }\n                     }\n                     if (c < 0x80 && isprint(c))\n-                        error(\"character '%c' is not a valid token\", c);\n+                        error(t.loc, \"character '%c' is not a valid token\", c);\n                     else\n-                        error(\"character 0x%02x is not a valid token\", c);\n+                        error(t.loc, \"character 0x%02x is not a valid token\", c);\n                     p++;\n                     continue;\n+                    // assert(0);\n                 }\n             }\n         }\n@@ -1467,6 +1476,7 @@ class Lexer\n         stringbuffer.setsize(0);\n         while (1)\n         {\n+            const s = p;\n             dchar c = *p++;\n             //printf(\"c = '%c'\\n\", c);\n             switch (c)\n@@ -1526,7 +1536,7 @@ class Lexer\n                 {\n                     // Start of identifier; must be a heredoc\n                     Token tok;\n-                    p--;\n+                    p = s;\n                     scan(&tok); // read in heredoc identifier\n                     if (tok.value != TOK.identifier)\n                     {\n@@ -1574,7 +1584,7 @@ class Lexer\n                 {\n                     Token tok;\n                     auto psave = p;\n-                    p--;\n+                    p = s;\n                     scan(&tok); // read in possible heredoc identifier\n                     //printf(\"endid = '%s'\\n\", tok.ident.toChars());\n                     if (tok.value == TOK.identifier && tok.ident is hereid)\n@@ -2829,6 +2839,20 @@ class Lexer\n      * Return decoded character, advance p to last character in UTF sequence.\n      */\n     private uint decodeUTF()\n+    {\n+        string msg;\n+        auto result = decodeUTFpure(msg);\n+\n+        if (msg)\n+            error(\"%.*s\", cast(int)msg.length, msg.ptr);\n+        return result;\n+    }\n+\n+    /********************************************\n+     * Same as above, but the potential error message is stored to the\n+     * msg parameter instead of being issued.\n+     */\n+    private pure uint decodeUTFpure(out string msg)\n     {\n         const s = p;\n         assert(*s & 0x80);\n@@ -2839,12 +2863,10 @@ class Lexer\n         }\n         size_t idx = 0;\n         dchar u;\n-        const msg = utf_decodeChar(s[0 .. len], idx, u);\n+        msg = utf_decodeChar(s[0 .. len], idx, u);\n         p += idx - 1;\n-        if (msg)\n-        {\n-            error(\"%.*s\", cast(int)msg.length, msg.ptr);\n-        }\n+        if (!msg && isBidiControl(u))\n+            msg = \"Bidirectional control characters are disallowed for security reasons.\";\n         return u;\n     }\n "}, {"sha": "2c0a5718421db94df86c6051bd395d4aeeb2cc21", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -4556,7 +4556,7 @@ extern (C++) final class TypeFunction : TypeNext\n         Parameters* params = parameterList.parameters;\n         if (mod & MODFlags.wild)\n             params = parameterList.parameters.copy();\n-        for (size_t i = 0; i < params.dim; i++)\n+        for (size_t i = 0; i < params.length; i++)\n         {\n             Parameter p = (*params)[i];\n             Type t = p.type.substWildTo(m);\n@@ -4686,7 +4686,7 @@ extern (C++) final class TypeFunction : TypeNext\n         if (parameterList.varargs == VarArg.none && nparams > nargs && !parameterList[nargs].defaultArg)\n         {\n             OutBuffer buf;\n-            buf.printf(\"too few arguments, expected `%d`, got `%d`\", cast(int)nparams, cast(int)nargs);\n+            buf.printf(\"too few arguments, expected %d, got %d\", cast(int)nparams, cast(int)nargs);\n             if (pMessage)\n                 *pMessage = buf.extractChars();\n             return MATCH.nomatch;\n@@ -5108,8 +5108,8 @@ extern (C++) abstract class TypeQualified : Type\n     final void syntaxCopyHelper(TypeQualified t)\n     {\n         //printf(\"TypeQualified::syntaxCopyHelper(%s) %s\\n\", t.toChars(), toChars());\n-        idents.setDim(t.idents.dim);\n-        for (size_t i = 0; i < idents.dim; i++)\n+        idents.setDim(t.idents.length);\n+        for (size_t i = 0; i < idents.length; i++)\n         {\n             RootObject id = t.idents[i];\n             with (DYNCAST) final switch (id.dyncast())\n@@ -5251,7 +5251,7 @@ extern (C++) final class TypeInstance : TypeQualified\n \n     override TypeInstance syntaxCopy()\n     {\n-        //printf(\"TypeInstance::syntaxCopy() %s, %d\\n\", toChars(), idents.dim);\n+        //printf(\"TypeInstance::syntaxCopy() %s, %d\\n\", toChars(), idents.length);\n         auto t = new TypeInstance(loc, tempinst.syntaxCopy(null));\n         t.syntaxCopyHelper(this);\n         t.mod = mod;\n@@ -5432,7 +5432,7 @@ extern (C++) final class TypeStruct : Type\n \n         auto structelems = new Expressions(sym.nonHiddenFields());\n         uint offset = 0;\n-        foreach (j; 0 .. structelems.dim)\n+        foreach (j; 0 .. structelems.length)\n         {\n             VarDeclaration vd = sym.fields[j];\n             Expression e;\n@@ -5487,7 +5487,7 @@ extern (C++) final class TypeStruct : Type\n         /* If any of the fields are const or immutable,\n          * then one cannot assign this struct.\n          */\n-        for (size_t i = 0; i < sym.fields.dim; i++)\n+        for (size_t i = 0; i < sym.fields.length; i++)\n         {\n             VarDeclaration v = sym.fields[i];\n             //printf(\"%s [%d] v = (%s) %s, v.offset = %d, v.parent = %s\\n\", sym.toChars(), i, v.kind(), v.toChars(), v.offset, v.parent.kind());\n@@ -5541,7 +5541,7 @@ extern (C++) final class TypeStruct : Type\n         if (sym.isNested())\n             return true;\n \n-        for (size_t i = 0; i < sym.fields.dim; i++)\n+        for (size_t i = 0; i < sym.fields.length; i++)\n         {\n             VarDeclaration v = sym.fields[i];\n             if (!v.isDataseg() && v.type.needsNested())\n@@ -5599,7 +5599,7 @@ extern (C++) final class TypeStruct : Type\n                      * allow the conversion.\n                      */\n                     uint offset = ~0; // dead-store to prevent spurious warning\n-                    for (size_t i = 0; i < sym.fields.dim; i++)\n+                    for (size_t i = 0; i < sym.fields.length; i++)\n                     {\n                         VarDeclaration v = sym.fields[i];\n                         if (i == 0)\n@@ -6072,7 +6072,7 @@ extern (C++) final class TypeTuple : Type\n         {\n             if (arguments)\n             {\n-                for (size_t i = 0; i < arguments.dim; i++)\n+                for (size_t i = 0; i < arguments.length; i++)\n                 {\n                     Parameter arg = (*arguments)[i];\n                     assert(arg && arg.type);\n@@ -6088,10 +6088,10 @@ extern (C++) final class TypeTuple : Type\n     extern (D) this(Expressions* exps)\n     {\n         super(Ttuple);\n-        auto arguments = new Parameters(exps ? exps.dim : 0);\n+        auto arguments = new Parameters(exps ? exps.length : 0);\n         if (exps)\n         {\n-            for (size_t i = 0; i < exps.dim; i++)\n+            for (size_t i = 0; i < exps.length; i++)\n             {\n                 Expression e = (*exps)[i];\n                 if (e.type.ty == Ttuple)\n@@ -6169,9 +6169,9 @@ extern (C++) final class TypeTuple : Type\n             return true;\n         if (auto tt = t.isTypeTuple())\n         {\n-            if (arguments.dim == tt.arguments.dim)\n+            if (arguments.length == tt.arguments.length)\n             {\n-                for (size_t i = 0; i < tt.arguments.dim; i++)\n+                for (size_t i = 0; i < tt.arguments.length; i++)\n                 {\n                     const Parameter arg1 = (*arguments)[i];\n                     Parameter arg2 = (*tt.arguments)[i];\n@@ -6190,10 +6190,10 @@ extern (C++) final class TypeTuple : Type\n             return MATCH.exact;\n         if (auto tt = to.isTypeTuple())\n         {\n-            if (arguments.dim == tt.arguments.dim)\n+            if (arguments.length == tt.arguments.length)\n             {\n                 MATCH m = MATCH.exact;\n-                for (size_t i = 0; i < tt.arguments.dim; i++)\n+                for (size_t i = 0; i < tt.arguments.length; i++)\n                 {\n                     Parameter arg1 = (*arguments)[i];\n                     Parameter arg2 = (*tt.arguments)[i];\n@@ -6595,8 +6595,8 @@ extern (C++) final class Parameter : ASTNode\n         Parameters* params = null;\n         if (parameters)\n         {\n-            params = new Parameters(parameters.dim);\n-            for (size_t i = 0; i < params.dim; i++)\n+            params = new Parameters(parameters.length);\n+            for (size_t i = 0; i < params.length; i++)\n                 (*params)[i] = (*parameters)[i].syntaxCopy();\n         }\n         return params;"}, {"sha": "3329c14afbfa781d6f01420797bb53904b795e93", "filename": "gcc/d/dmd/nogc.d", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fnogc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fnogc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnogc.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -99,7 +99,7 @@ public:\n \n     override void visit(ArrayLiteralExp e)\n     {\n-        if (e.type.ty != Tarray || !e.elements || !e.elements.dim || e.onstack)\n+        if (e.type.ty != Tarray || !e.elements || !e.elements.length || e.onstack)\n             return;\n         if (f.setGC())\n         {\n@@ -113,7 +113,7 @@ public:\n \n     override void visit(AssocArrayLiteralExp e)\n     {\n-        if (!e.keys.dim)\n+        if (!e.keys.length)\n             return;\n         if (f.setGC())\n         {\n@@ -162,16 +162,16 @@ public:\n     override void visit(IndexExp e)\n     {\n         Type t1b = e.e1.type.toBasetype();\n-        if (t1b.ty == Taarray)\n+        if (e.modifiable && t1b.ty == Taarray)\n         {\n             if (f.setGC())\n             {\n-                e.error(\"indexing an associative array in `@nogc` %s `%s` may cause a GC allocation\",\n+                e.error(\"assigning an associative array element in `@nogc` %s `%s` may cause a GC allocation\",\n                     f.kind(), f.toPrettyChars());\n                 err = true;\n                 return;\n             }\n-            f.printGCUsage(e.loc, \"indexing an associative array may cause a GC allocation\");\n+            f.printGCUsage(e.loc, \"assigning an associative array element may cause a GC allocation\");\n         }\n     }\n "}, {"sha": "59f34e1c1de47a6371e3748ab4152b8e9d9659e8", "filename": "gcc/d/dmd/ob.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fob.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fob.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fob.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -565,7 +565,7 @@ void toObNodes(ref ObNodes obnodes, Statement s)\n              */\n             mystate.defaultBlock = s.sdefault ? newNode() : mystate.breakBlock;\n \n-            const numcases = s.cases ? s.cases.dim : 0;\n+            const numcases = s.cases ? s.cases.length : 0;\n \n             /* allocate a block for each case\n              */"}, {"sha": "2bb5eabe4eb1460a67861f841fdb52085d68c2b8", "filename": "gcc/d/dmd/objc.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fobjc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fobjc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fobjc.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -555,7 +555,7 @@ extern(C++) private final class Supported : Objc\n                 return 1;\n             }\n \n-            assert(literal.elements.dim == 1);\n+            assert(literal.elements.length == 1);\n             auto se = (*literal.elements)[0].toStringExp();\n             assert(se);\n \n@@ -570,7 +570,7 @@ extern(C++) private final class Supported : Objc\n         if (!fd.objc.selector)\n             return;\n         TypeFunction tf = cast(TypeFunction)fd.type;\n-        if (fd.objc.selector.paramCount != tf.parameterList.parameters.dim)\n+        if (fd.objc.selector.paramCount != tf.parameterList.parameters.length)\n             fd.error(\"number of colons in Objective-C selector must match number of parameters\");\n         if (fd.parent && fd.parent.isTemplateInstance())\n             fd.error(\"template cannot have an Objective-C selector attached\");"}, {"sha": "de417274a6615c953cfa7eecaa1b435de05d5b25", "filename": "gcc/d/dmd/opover.d", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fopover.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fopover.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -286,9 +286,9 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                 ae.e1 = ae.e1.expressionSemantic(sc);\n                 ae.e1 = resolveProperties(sc, ae.e1);\n                 Expression ae1old = ae.e1;\n-                const(bool) maybeSlice = (ae.arguments.dim == 0 || ae.arguments.dim == 1 && (*ae.arguments)[0].op == EXP.interval);\n+                const(bool) maybeSlice = (ae.arguments.length == 0 || ae.arguments.length == 1 && (*ae.arguments)[0].op == EXP.interval);\n                 IntervalExp ie = null;\n-                if (maybeSlice && ae.arguments.dim)\n+                if (maybeSlice && ae.arguments.length)\n                 {\n                     ie = (*ae.arguments)[0].isIntervalExp();\n                 }\n@@ -425,9 +425,9 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n             ae.e1 = ae.e1.expressionSemantic(sc);\n             ae.e1 = resolveProperties(sc, ae.e1);\n             Expression ae1old = ae.e1;\n-            const(bool) maybeSlice = (ae.arguments.dim == 0 || ae.arguments.dim == 1 && (*ae.arguments)[0].op == EXP.interval);\n+            const(bool) maybeSlice = (ae.arguments.length == 0 || ae.arguments.length == 1 && (*ae.arguments)[0].op == EXP.interval);\n             IntervalExp ie = null;\n-            if (maybeSlice && ae.arguments.dim)\n+            if (maybeSlice && ae.arguments.length)\n             {\n                 ie = (*ae.arguments)[0].isIntervalExp();\n             }\n@@ -457,7 +457,7 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                             return result;\n                         }\n                         // Convert to IndexExp\n-                        if (ae.arguments.dim == 1)\n+                        if (ae.arguments.length == 1)\n                         {\n                             result = new IndexExp(ae.loc, ae.e1, (*ae.arguments)[0]);\n                             result = result.expressionSemantic(sc);\n@@ -849,7 +849,7 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                      * the mentioned member, then alias this may be\n                      * used since the object will be fully initialised.\n                      * If the struct is nested, the context pointer is considered\n-                     * one of the members, hence the `ad1.fields.dim == 2 && ad1.vthis`\n+                     * one of the members, hence the `ad1.fields.length == 2 && ad1.vthis`\n                      * condition.\n                      */\n                     if (result.op != EXP.assign)\n@@ -864,7 +864,7 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                     {\n                         // i.e: Rewrote `e1 = e2` -> `e1.some.var = e2`\n                         // Ensure that `var` is the only field member in `ad`\n-                        if (ad.fields.dim == 1 || (ad.fields.dim == 2 && ad.vthis))\n+                        if (ad.fields.length == 1 || (ad.fields.length == 2 && ad.vthis))\n                         {\n                             if (dve.var == ad.aliasthis.sym)\n                                 return result;\n@@ -1043,11 +1043,11 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n             {\n                 auto tup1 = e.e1.isTupleExp();\n                 auto tup2 = e.e2.isTupleExp();\n-                size_t dim = tup1.exps.dim;\n-                if (dim != tup2.exps.dim)\n+                size_t dim = tup1.exps.length;\n+                if (dim != tup2.exps.length)\n                 {\n                     e.error(\"mismatched tuple lengths, `%d` and `%d`\",\n-                        cast(int)dim, cast(int)tup2.exps.dim);\n+                        cast(int)dim, cast(int)tup2.exps.length);\n                     return ErrorExp.get();\n                 }\n \n@@ -1101,9 +1101,9 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                 ae.e1 = ae.e1.expressionSemantic(sc);\n                 ae.e1 = resolveProperties(sc, ae.e1);\n                 Expression ae1old = ae.e1;\n-                const(bool) maybeSlice = (ae.arguments.dim == 0 || ae.arguments.dim == 1 && (*ae.arguments)[0].op == EXP.interval);\n+                const(bool) maybeSlice = (ae.arguments.length == 0 || ae.arguments.length == 1 && (*ae.arguments)[0].op == EXP.interval);\n                 IntervalExp ie = null;\n-                if (maybeSlice && ae.arguments.dim)\n+                if (maybeSlice && ae.arguments.length)\n                 {\n                     ie = (*ae.arguments)[0].isIntervalExp();\n                 }\n@@ -1553,7 +1553,7 @@ bool inferForeachAggregate(Scope* sc, bool isForeach, ref Expression feaggr, out\n  */\n bool inferApplyArgTypes(ForeachStatement fes, Scope* sc, ref Dsymbol sapply)\n {\n-    if (!fes.parameters || !fes.parameters.dim)\n+    if (!fes.parameters || !fes.parameters.length)\n         return false;\n     if (sapply) // prefer opApply\n     {\n@@ -1604,7 +1604,7 @@ bool inferApplyArgTypes(ForeachStatement fes, Scope* sc, ref Dsymbol sapply)\n     case Tarray:\n     case Tsarray:\n     case Ttuple:\n-        if (fes.parameters.dim == 2)\n+        if (fes.parameters.length == 2)\n         {\n             if (!p.type)\n             {\n@@ -1623,7 +1623,7 @@ bool inferApplyArgTypes(ForeachStatement fes, Scope* sc, ref Dsymbol sapply)\n     case Taarray:\n         {\n             TypeAArray taa = tab.isTypeAArray();\n-            if (fes.parameters.dim == 2)\n+            if (fes.parameters.length == 2)\n             {\n                 if (!p.type)\n                 {\n@@ -1647,7 +1647,7 @@ bool inferApplyArgTypes(ForeachStatement fes, Scope* sc, ref Dsymbol sapply)\n     {\n         AggregateDeclaration ad = (tab.ty == Tclass) ? tab.isTypeClass().sym\n                                                      : tab.isTypeStruct().sym;\n-        if (fes.parameters.dim == 1)\n+        if (fes.parameters.length == 1)\n         {\n             if (!p.type)\n             {\n@@ -1811,7 +1811,7 @@ private bool matchParamsToOpApply(TypeFunction tf, Parameters* parameters, bool\n      * Fill in missing types in parameters.\n      */\n     const nparams = tdg.parameterList.length;\n-    if (nparams == 0 || nparams != parameters.dim || tdg.parameterList.varargs != VarArg.none)\n+    if (nparams == 0 || nparams != parameters.length || tdg.parameterList.varargs != VarArg.none)\n         return nomatch; // parameter mismatch\n \n     foreach (u, p; *parameters)"}, {"sha": "a9c542579ada8b54eebb00be7137c81d94d2e3aa", "filename": "gcc/d/dmd/optimize.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Foptimize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Foptimize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -225,7 +225,7 @@ package void setLengthVarIfKnown(VarDeclaration lengthVar, Expression arr)\n     if (auto se = arr.isStringExp())\n         len = se.len;\n     else if (auto ale = arr.isArrayLiteralExp())\n-        len = ale.elements.dim;\n+        len = ale.elements.length;\n     else\n     {\n         auto tsa = arr.type.toBasetype().isTypeSArray();\n@@ -358,7 +358,7 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n \n     void visitAssocArrayLiteral(AssocArrayLiteralExp e)\n     {\n-        assert(e.keys.dim == e.values.dim);\n+        assert(e.keys.length == e.values.length);\n         foreach (i, ref ekey; (*e.keys)[])\n         {\n             expOptimize(ekey, result & WANTexpand);"}, {"sha": "93c7ea0eea0465f086fd5ff8490084db1683b0a5", "filename": "gcc/d/dmd/parse.d", "status": "modified", "additions": 50, "deletions": 28, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -425,8 +425,8 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             case TOK.traits:\n             Ldeclaration:\n                 a = parseDeclarations(false, pAttrs, pAttrs.comment);\n-                if (a && a.dim)\n-                    *pLastDecl = (*a)[a.dim - 1];\n+                if (a && a.length)\n+                    *pLastDecl = (*a)[a.length - 1];\n                 break;\n \n             case TOK.this_:\n@@ -491,6 +491,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                  */\n                 if (mod.isRoot() && (global.params.useUnitTests || global.params.ddoc.doOutput || global.params.dihdr.doOutput))\n                 {\n+                    linkage = LINK.d; // unittests have D linkage\n                     s = parseUnitTest(pAttrs);\n                     if (*pLastDecl)\n                         (*pLastDecl).ddocUnittest = cast(AST.UnitTestDeclaration)s;\n@@ -698,8 +699,8 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                 if (token.value == TOK.identifier && hasOptionalParensThen(peek(&token), TOK.assign))\n                 {\n                     a = parseAutoDeclarations(getStorageClass!AST(pAttrs), pAttrs.comment);\n-                    if (a && a.dim)\n-                        *pLastDecl = (*a)[a.dim - 1];\n+                    if (a && a.length)\n+                        *pLastDecl = (*a)[a.length - 1];\n                     if (pAttrs.udas)\n                     {\n                         s = new AST.UserAttributeDeclaration(pAttrs.udas, a);\n@@ -725,8 +726,8 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                         deprecation(\"usage of the `body` keyword is deprecated. Use `do` instead.\");\n \n                     a = parseDeclarations(true, pAttrs, pAttrs.comment);\n-                    if (a && a.dim)\n-                        *pLastDecl = (*a)[a.dim - 1];\n+                    if (a && a.length)\n+                        *pLastDecl = (*a)[a.length - 1];\n                     if (pAttrs.udas)\n                     {\n                         s = new AST.UserAttributeDeclaration(pAttrs.udas, a);\n@@ -817,8 +818,8 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                     if (res.idents)\n                     {\n                         assert(res.link == LINK.cpp);\n-                        assert(res.idents.dim);\n-                        for (size_t i = res.idents.dim; i;)\n+                        assert(res.idents.length);\n+                        for (size_t i = res.idents.length; i;)\n                         {\n                             Identifier id = (*res.idents)[--i];\n                             if (s)\n@@ -833,8 +834,8 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                     else if (res.identExps)\n                     {\n                         assert(res.link == LINK.cpp);\n-                        assert(res.identExps.dim);\n-                        for (size_t i = res.identExps.dim; i;)\n+                        assert(res.identExps.length);\n+                        for (size_t i = res.identExps.length; i;)\n                         {\n                             AST.Expression exp = (*res.identExps)[--i];\n                             if (s)\n@@ -1059,7 +1060,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                 decldefs.push(s);\n                 addComment(s, pAttrs.comment);\n             }\n-            else if (a && a.dim)\n+            else if (a && a.length)\n             {\n                 decldefs.append(a);\n             }\n@@ -3786,10 +3787,10 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                                 break;\n                             }\n                         }\n-                        assert(dimStack.dim > 0);\n+                        assert(dimStack.length > 0);\n                         // We're good. Replay indices in the reverse order.\n                         tid = cast(AST.TypeQualified)t;\n-                        while (dimStack.dim)\n+                        while (dimStack.length)\n                         {\n                             tid.addIndex(dimStack.pop());\n                         }\n@@ -4341,6 +4342,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         /* Declarations that start with `alias`\n          */\n         bool isAliasDeclaration = false;\n+        auto aliasLoc = token.loc;\n         if (token.value == TOK.alias_)\n         {\n             if (auto a = parseAliasDeclarations(comment))\n@@ -4488,7 +4490,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             if (ident)\n                 checkCstyleTypeSyntax(loc, t, alt, ident);\n             else if (!isThis && (t != AST.Type.terror))\n-                error(\"no identifier for declarator `%s`\", t.toChars());\n+                noIdentifierForDeclarator(t);\n \n             if (isAliasDeclaration)\n             {\n@@ -4517,7 +4519,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                     else\n                         error(\"alias cannot have initializer\");\n                 }\n-                v = new AST.AliasDeclaration(loc, ident, t);\n+                v = new AST.AliasDeclaration(aliasLoc, ident, t);\n \n                 v.storage_class = storage_class;\n                 if (pAttrs)\n@@ -4706,6 +4708,19 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         return a;\n     }\n \n+    /// Report an error that a declaration of type `t` is missing an identifier\n+    /// The parser is expected to sit on the next token after the type.\n+    private void noIdentifierForDeclarator(AST.Type t)\n+    {\n+        error(\"no identifier for declarator `%s`\", t.toChars());\n+        // A common mistake is to use a reserved keyword as an identifier, e.g. `in` or `out`\n+        if (token.isKeyword)\n+        {\n+            errorSupplemental(token.loc, \"`%s` is a keyword, perhaps append `_` to make it an identifier\", token.toChars());\n+            nextToken();\n+        }\n+    }\n+\n     /********************************\n      * Parse AliasReassignment:\n      *   identifier = type;\n@@ -4881,15 +4896,15 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                         // parseAttributes shouldn't have set these variables\n                         assert(link == linkage && !setAlignment && ealign is null);\n                         auto tpl_ = cast(AST.TemplateDeclaration) s;\n-                        if (tpl_ is null || tpl_.members.dim != 1)\n+                        if (tpl_ is null || tpl_.members.length != 1)\n                         {\n                             error(\"user-defined attributes are not allowed on `alias` declarations\");\n                         }\n                         else\n                         {\n                             auto fd = cast(AST.FuncLiteralDeclaration) (*tpl_.members)[0];\n                             auto tf = cast(AST.TypeFunction) fd.type;\n-                            assert(tf.parameterList.parameters.dim > 0);\n+                            assert(tf.parameterList.parameters.length > 0);\n                             auto as = new AST.Dsymbols();\n                             (*tf.parameterList.parameters)[0].userAttribDecl = new AST.UserAttributeDeclaration(udas, as);\n                         }\n@@ -5489,7 +5504,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             }\n             at = parseType(&ai);\n             if (!ai)\n-                error(\"no identifier for declarator `%s`\", at.toChars());\n+                noIdentifierForDeclarator(at);\n         Larg:\n             auto p = new AST.Parameter(storageClass, at, ai, null, null);\n             parameters.push(p);\n@@ -5513,7 +5528,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         nextToken();\n \n         AST.Expression aggr = parseExpression();\n-        if (token.value == TOK.slice && parameters.dim == 1)\n+        if (token.value == TOK.slice && parameters.length == 1)\n         {\n             AST.Parameter p = (*parameters)[0];\n             nextToken();\n@@ -5897,19 +5912,19 @@ LagainStc:\n         Ldeclaration:\n             {\n                 AST.Dsymbols* a = parseDeclarations(false, null, null);\n-                if (a.dim > 1)\n+                if (a.length > 1)\n                 {\n                     auto as = new AST.Statements();\n-                    as.reserve(a.dim);\n-                    foreach (i; 0 .. a.dim)\n+                    as.reserve(a.length);\n+                    foreach (i; 0 .. a.length)\n                     {\n                         AST.Dsymbol d = (*a)[i];\n                         s = new AST.ExpStatement(loc, d);\n                         as.push(s);\n                     }\n                     s = new AST.CompoundDeclarationStatement(loc, as);\n                 }\n-                else if (a.dim == 1)\n+                else if (a.length == 1)\n                 {\n                     AST.Dsymbol d = (*a)[0];\n                     s = new AST.ExpStatement(loc, d);\n@@ -6283,7 +6298,7 @@ LagainStc:\n                  */\n                 if (token.value == TOK.slice)\n                 {\n-                    if (cases.dim > 1)\n+                    if (cases.length > 1)\n                         error(\"only one `case` allowed for start of case range\");\n                     nextToken();\n                     check(TOK.case_);\n@@ -6322,7 +6337,7 @@ LagainStc:\n                 else\n                 {\n                     // Keep cases in order by building the case statements backwards\n-                    for (size_t i = cases.dim; i; i--)\n+                    for (size_t i = cases.length; i; i--)\n                     {\n                         exp = cases[i - 1];\n                         s = new AST.CaseStatement(loc, exp, s);\n@@ -6741,7 +6756,7 @@ LagainStc:\n         case TOK.leftBracket:\n             /* Scan ahead to see if it is an array initializer or\n              * an expression.\n-             * If it ends with a ';' ',' or '}', it is an array initializer.\n+             * If it ends with a ';' ',' or ']', it is an array initializer.\n              */\n             int brackets = 1;\n             for (auto t = peek(&token); 1; t = peek(t))\n@@ -8242,14 +8257,21 @@ LagainStc:\n             t = AST.Type.tdchar;\n             goto LabelX;\n         LabelX:\n+            const next = peekNext();\n+            if (next != TOK.leftParenthesis && next != TOK.dot)\n+            {\n+                // defer error for better diagnostics\n+                e = new AST.TypeExp(loc, parseType);\n+                break;\n+            }\n             nextToken();\n             if (token.value == TOK.leftParenthesis)\n             {\n                 e = new AST.TypeExp(loc, t);\n                 e = new AST.CallExp(loc, e, parseArguments());\n                 break;\n             }\n-            check(TOK.dot, t.toChars());\n+            check(TOK.dot);\n             if (token.value != TOK.identifier)\n             {\n                 error(\"found `%s` when expecting identifier following `%s`.\", token.toChars(), t.toChars());\n@@ -8477,7 +8499,7 @@ LagainStc:\n                 while (token.value != TOK.rightBracket && token.value != TOK.endOfFile)\n                 {\n                     e = parseAssignExp();\n-                    if (token.value == TOK.colon && (keys || values.dim == 0))\n+                    if (token.value == TOK.colon && (keys || values.length == 0))\n                     {\n                         nextToken();\n                         if (!keys)"}, {"sha": "5c01940dadb9fb6afeb441769e0b778dfc41319a", "filename": "gcc/d/dmd/root/array.d", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Froot%2Farray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Froot%2Farray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Farray.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -352,7 +352,9 @@ public:\n     }\n \n     alias opDollar = length;\n-    alias dim = length;\n+\n+    deprecated(\"use `.length` instead\")\n+    extern(D) size_t dim() const @nogc nothrow pure @safe { return length; }\n }\n \n unittest"}, {"sha": "f6a451596bb82edc924c3d964f06ca77bbc915cf", "filename": "gcc/d/dmd/root/filename.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Froot%2Ffilename.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Froot%2Ffilename.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffilename.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -55,7 +55,7 @@ alias Strings = Array!(const(char)*);\n \n \n // Check whether character is a directory separator\n-private bool isDirSeparator(char c) pure nothrow @nogc @safe\n+bool isDirSeparator(char c) pure nothrow @nogc @safe\n {\n     version (Windows)\n     {"}, {"sha": "0d230e764c30333d6f4623baa9cc5e8bfd3bc11b", "filename": "gcc/d/dmd/root/utf.d", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Froot%2Futf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Froot%2Futf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Futf.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -395,6 +395,26 @@ void utf_encode(int sz, void* s, dchar c)\n     }\n }\n \n+/********************************************\n+ * Checks whether an Unicode code point is a bidirectional\n+ * control character.\n+ */\n+@safe bool isBidiControl(dchar c)\n+{\n+    // Source: https://www.unicode.org/versions/Unicode15.0.0, table 23-3.\n+    switch(c)\n+    {\n+        case '\\u061C':\n+        case '\\u200E':\n+        case '\\u200F':\n+        case '\\u202A': .. case '\\u202E':\n+        case '\\u2066': .. case '\\u2069':\n+            return true;\n+        default:\n+            return false;\n+    }\n+}\n+\n /********************************************\n  * Decode a UTF-8 sequence as a single UTF-32 code point.\n  * Params:"}, {"sha": "adfae329e06e12d94e80afda7581d1933fe0ac6f", "filename": "gcc/d/dmd/sapply.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fsapply.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fsapply.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsapply.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -68,15 +68,15 @@ public:\n \n     override void visit(CompoundStatement s)\n     {\n-        for (size_t i = 0; i < s.statements.dim; i++)\n+        for (size_t i = 0; i < s.statements.length; i++)\n             if (doCond((*s.statements)[i]))\n                 return;\n         applyTo(s);\n     }\n \n     override void visit(UnrolledLoopStatement s)\n     {\n-        for (size_t i = 0; i < s.statements.dim; i++)\n+        for (size_t i = 0; i < s.statements.length; i++)\n             if (doCond((*s.statements)[i]))\n                 return;\n         applyTo(s);\n@@ -151,7 +151,7 @@ public:\n     {\n         if (doCond(s._body))\n             return;\n-        for (size_t i = 0; i < s.catches.dim; i++)\n+        for (size_t i = 0; i < s.catches.length; i++)\n             if (doCond((*s.catches)[i].handler))\n                 return;\n         applyTo(s);"}, {"sha": "8b9e59e3aae712f66df7936f9f5da8a69513955a", "filename": "gcc/d/dmd/scope.h", "status": "modified", "additions": 28, "deletions": 50, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fscope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fscope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fscope.h?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -28,43 +28,38 @@ class CPPNamespaceDeclaration;\n \n #include \"dsymbol.h\"\n \n-enum\n+enum class CSX : uint16_t\n {\n-    CSXthis_ctor  = 1,      // called this()\n-    CSXsuper_ctor = 2,      // called super()\n-    CSXthis       = 4,      // referenced this\n-    CSXsuper      = 8,      // referenced super\n-    CSXlabel      = 0x10,   // seen a label\n-    CSXreturn     = 0x20,   // seen a return statement\n-    CSXany_ctor   = 0x40,   // either this() or super() was called\n-    CSXhalt       = 0x80,   // assert(0)\n+    none       = 0,\n+    this_ctor  = 1,      // called this()\n+    super_ctor = 2,      // called super()\n+    label      = 4,      // seen a label\n+    return_    = 8,      // seen a return statement\n+    any_ctor   = 0x10,   // either this() or super() was called\n+    halt       = 0x20,   // assert(0)\n };\n \n-enum\n+enum class SCOPE\n {\n     // Flags that would not be inherited beyond scope nesting\n-    SCOPEctor          = 0x0001,  // constructor type\n-    SCOPEcondition     = 0x0004,  // inside static if/assert condition\n-    SCOPEdebug         = 0x0008,  // inside debug conditional\n+    ctor          = 0x0001,  // constructor type\n+    noaccesscheck = 0x0002,  // don't do access checks\n+    condition     = 0x0004,  // inside static if/assert condition\n+    debug_        = 0x0008,  // inside debug conditional\n \n     // Flags that would be inherited beyond scope nesting\n-    SCOPEnoaccesscheck = 0x0002,  // don't do access checks\n-    SCOPEconstraint    = 0x0010,  // inside template constraint\n-    SCOPEinvariant     = 0x0020,  // inside invariant code\n-    SCOPErequire       = 0x0040,  // inside in contract code\n-    SCOPEensure        = 0x0060,  // inside out contract code\n-    SCOPEcontract      = 0x0060,  // [mask] we're inside contract code\n-    SCOPEctfe          = 0x0080,  // inside a ctfe-only expression\n-    SCOPEcompile       = 0x0100,  // inside __traits(compile)\n-    SCOPEignoresymbolvisibility = 0x0200,  // ignore symbol visibility (Bugzilla 15907)\n-\n-    SCOPEfree          = 0x8000,  // is on free list\n-    SCOPEfullinst      = 0x10000, // fully instantiate templates\n-    SCOPEalias         = 0x20000, // inside alias declaration\n-\n-    // The following are mutually exclusive\n-    SCOPEprintf        = 0x40000, // printf-style function\n-    SCOPEscanf         = 0x80000, // scanf-style function\n+    constraint    = 0x0010,  // inside template constraint\n+    invariant_    = 0x0020,  // inside invariant code\n+    require       = 0x0040,  // inside in contract code\n+    ensure        = 0x0060,  // inside out contract code\n+    contract      = 0x0060,  // [mask] we're inside contract code\n+    ctfe          = 0x0080,  // inside a ctfe-only expression\n+    compile       = 0x0100,  // inside __traits(compile)\n+    ignoresymbolvisibility = 0x0200,  // ignore symbol visibility (Bugzilla 15907)\n+\n+    Cfile         = 0x0800,  // C semantics apply\n+    free          = 0x8000,  // is on free list\n+    fullinst      = 0x10000, // fully instantiate templates\n };\n \n struct Scope\n@@ -74,6 +69,7 @@ struct Scope\n     Module *_module;            // Root module\n     ScopeDsymbol *scopesym;     // current symbol\n     FuncDeclaration *func;      // function we are in\n+    VarDeclaration  *varDecl;   // variable we are in during semantic2\n     Dsymbol *parent;            // parent to use\n     LabelStatement *slabel;     // enclosing labelled statement\n     SwitchStatement *sw;        // enclosing switch statement\n@@ -98,8 +94,8 @@ struct Scope\n     Module *minst;              // root module where the instantiated templates should belong to\n     TemplateInstance *tinst;    // enclosing template instance\n \n-    unsigned char callSuper;    // primitive flow analysis for constructors\n-    unsigned char *fieldinit;\n+    CSX callSuper;              // primitive flow analysis for constructors\n+    CSX *fieldinit;\n     size_t fieldinit_dim;\n \n     AlignDeclaration *aligndecl;    // alignment for struct members\n@@ -128,24 +124,6 @@ struct Scope\n \n     AliasDeclaration *aliasAsg; // if set, then aliasAsg is being assigned a new value,\n                                 // do not set wasRead for it\n-    Scope();\n-\n-    Scope *copy();\n-\n-    Scope *push();\n-    Scope *push(ScopeDsymbol *ss);\n-    Scope *pop();\n-\n-    Scope *startCTFE();\n-    Scope *endCTFE();\n \n     Dsymbol *search(const Loc &loc, Identifier *ident, Dsymbol **pscopesym, int flags = IgnoreNone);\n-\n-    ClassDeclaration *getClassScope();\n-    AggregateDeclaration *getStructClassScope();\n-\n-    structalign_t alignment();\n-\n-    bool isDeprecated() const;\n-    bool isFromSpeculativeSemanticContext() const;\n };"}, {"sha": "4795bcfcf6d6c5d63de2b9eb63e8a89a815e1a46", "filename": "gcc/d/dmd/semantic2.d", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fsemantic2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fsemantic2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic2.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -163,7 +163,7 @@ private extern(C++) final class Semantic2Visitor : Visitor\n         if (needGagging)\n             oldGaggedErrors = global.startGagging();\n \n-        for (size_t i = 0; i < tempinst.members.dim; i++)\n+        for (size_t i = 0; i < tempinst.members.length; i++)\n         {\n             Dsymbol s = (*tempinst.members)[i];\n             static if (LOG)\n@@ -211,7 +211,7 @@ private extern(C++) final class Semantic2Visitor : Visitor\n         sc = sc.push(tmix);\n         sc.tinst = tmix;\n         sc.minst = tmix.minst;\n-        for (size_t i = 0; i < tmix.members.dim; i++)\n+        for (size_t i = 0; i < tmix.members.length; i++)\n         {\n             Dsymbol s = (*tmix.members)[i];\n             static if (LOG)\n@@ -230,6 +230,8 @@ private extern(C++) final class Semantic2Visitor : Visitor\n             return;\n \n         //printf(\"VarDeclaration::semantic2('%s')\\n\", toChars());\n+        sc.varDecl = vd;\n+        scope(exit) sc.varDecl = null;\n \n         if (vd.aliassym)        // if it's a tuple\n         {\n@@ -333,7 +335,7 @@ private extern(C++) final class Semantic2Visitor : Visitor\n         if (mod.members)\n         {\n             // Pass 2 semantic routines: do initializers and function bodies\n-            for (size_t i = 0; i < mod.members.dim; i++)\n+            for (size_t i = 0; i < mod.members.length; i++)\n             {\n                 Dsymbol s = (*mod.members)[i];\n                 s.semantic2(sc);\n@@ -520,7 +522,7 @@ private extern(C++) final class Semantic2Visitor : Visitor\n             return;\n \n         Scope* sc2 = ad.newScope(sc);\n-        for (size_t i = 0; i < d.dim; i++)\n+        for (size_t i = 0; i < d.length; i++)\n         {\n             Dsymbol s = (*d)[i];\n             s.semantic2(sc2);\n@@ -559,7 +561,7 @@ private extern(C++) final class Semantic2Visitor : Visitor\n \n     override void visit(UserAttributeDeclaration uad)\n     {\n-        if (!uad.decl || !uad.atts || !uad.atts.dim || !uad._scope)\n+        if (!uad.decl || !uad.atts || !uad.atts.length || !uad._scope)\n             return visit(cast(AttribDeclaration)uad);\n \n         Expression* lastTag;\n@@ -609,7 +611,7 @@ private extern(C++) final class Semantic2Visitor : Visitor\n \n         ad.determineSize(ad.loc);\n \n-        for (size_t i = 0; i < ad.members.dim; i++)\n+        for (size_t i = 0; i < ad.members.length; i++)\n         {\n             Dsymbol s = (*ad.members)[i];\n             //printf(\"\\t[%d] %s\\n\", i, s.toChars());"}, {"sha": "cc75aa51e5a9635846b2958baf705d43f57f58e9", "filename": "gcc/d/dmd/semantic3.d", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fsemantic3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fsemantic3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -127,7 +127,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n         if (needGagging)\n             oldGaggedErrors = global.startGagging();\n \n-        for (size_t i = 0; i < tempinst.members.dim; i++)\n+        for (size_t i = 0; i < tempinst.members.length; i++)\n         {\n             Dsymbol s = (*tempinst.members)[i];\n             s.semantic3(sc);\n@@ -170,7 +170,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n \n         uint olderrors = global.errors;\n \n-        for (size_t i = 0; i < tmix.members.dim; i++)\n+        for (size_t i = 0; i < tmix.members.length; i++)\n         {\n             Dsymbol s = (*tmix.members)[i];\n             s.semantic3(sc);\n@@ -197,7 +197,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n         if (mod.members)\n         {\n             // Pass 3 semantic routines: do initializers and function bodies\n-            for (size_t i = 0; i < mod.members.dim; i++)\n+            for (size_t i = 0; i < mod.members.length; i++)\n             {\n                 Dsymbol s = (*mod.members)[i];\n                 //printf(\"Module %s: %s.semantic3()\\n\", toChars(), s.toChars());\n@@ -586,7 +586,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                  */\n                 if (ad2 && funcdecl.isCtorDeclaration())\n                 {\n-                    sc2.ctorflow.allocFieldinit(ad2.fields.dim);\n+                    sc2.ctorflow.allocFieldinit(ad2.fields.length);\n                     foreach (v; ad2.fields)\n                     {\n                         v.ctorinit = 0;\n@@ -624,7 +624,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n \n                 if (funcdecl.returns && !funcdecl.fbody.isErrorStatement())\n                 {\n-                    for (size_t i = 0; i < funcdecl.returns.dim;)\n+                    for (size_t i = 0; i < funcdecl.returns.length;)\n                     {\n                         Expression exp = (*funcdecl.returns)[i].exp;\n                         if (exp.op == EXP.variable && (cast(VarExp)exp).var == funcdecl.vresult)\n@@ -661,7 +661,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                      * ctor consts were initialized.\n                      */\n                     ScopeDsymbol pd = funcdecl.toParent().isScopeDsymbol();\n-                    for (size_t i = 0; i < pd.members.dim; i++)\n+                    for (size_t i = 0; i < pd.members.length; i++)\n                     {\n                         Dsymbol s = (*pd.members)[i];\n                         s.checkCtorConstInit();\n@@ -829,7 +829,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                     /* Cannot move this loop into NrvoWalker, because\n                      * returns[i] may be in the nested delegate for foreach-body.\n                      */\n-                    for (size_t i = 0; i < funcdecl.returns.dim; i++)\n+                    for (size_t i = 0; i < funcdecl.returns.length; i++)\n                     {\n                         ReturnStatement rs = (*funcdecl.returns)[i];\n                         Expression exp = rs.exp;\n@@ -1068,7 +1068,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                 // Merge in initialization of 'out' parameters\n                 if (funcdecl.parameters)\n                 {\n-                    for (size_t i = 0; i < funcdecl.parameters.dim; i++)\n+                    for (size_t i = 0; i < funcdecl.parameters.length; i++)\n                     {\n                         VarDeclaration v = (*funcdecl.parameters)[i];\n                         if (v.storage_class & STC.out_)\n@@ -1253,7 +1253,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n             // Fix up forward-referenced gotos\n             if (funcdecl.gotos && !funcdecl.isCsymbol())\n             {\n-                for (size_t i = 0; i < funcdecl.gotos.dim; ++i)\n+                for (size_t i = 0; i < funcdecl.gotos.length; ++i)\n                 {\n                     (*funcdecl.gotos)[i].checkLabel();\n                 }\n@@ -1526,7 +1526,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n             return;\n \n         Scope* sc2 = ad.newScope(sc);\n-        for (size_t i = 0; i < d.dim; i++)\n+        for (size_t i = 0; i < d.length; i++)\n         {\n             Dsymbol s = (*d)[i];\n             s.semantic3(sc2);\n@@ -1551,7 +1551,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n \n         auto sc2 = ad.newScope(sc);\n \n-        for (size_t i = 0; i < ad.members.dim; i++)\n+        for (size_t i = 0; i < ad.members.length; i++)\n         {\n             Dsymbol s = (*ad.members)[i];\n             s.semantic3(sc2);\n@@ -1612,7 +1612,7 @@ private struct FuncDeclSem3\n     {\n         if (funcdecl.frequires)\n         {\n-            for (size_t i = 0; i < funcdecl.foverrides.dim; i++)\n+            for (size_t i = 0; i < funcdecl.foverrides.length; i++)\n             {\n                 FuncDeclaration fdv = funcdecl.foverrides[i];\n                 if (fdv.fbody && !fdv.frequires)"}, {"sha": "91a802ecdd76b1c44f19f87f2a3dd8eb6d48e61e", "filename": "gcc/d/dmd/statement.d", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fstatement.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fstatement.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -610,7 +610,7 @@ extern (C++) class CompoundStatement : Statement\n     override final inout(Statement) last() inout nothrow pure\n     {\n         Statement s = null;\n-        for (size_t i = statements.dim; i; --i)\n+        for (size_t i = statements.length; i; --i)\n         {\n             s = cast(Statement)(*statements)[i - 1];\n             if (s)\n@@ -640,7 +640,7 @@ extern (C++) final class CompoundDeclarationStatement : CompoundStatement\n \n     override CompoundDeclarationStatement syntaxCopy()\n     {\n-        auto a = new Statements(statements.dim);\n+        auto a = new Statements(statements.length);\n         foreach (i, s; *statements)\n         {\n             (*a)[i] = s ? s.syntaxCopy() : null;\n@@ -670,7 +670,7 @@ extern (C++) final class UnrolledLoopStatement : Statement\n \n     override UnrolledLoopStatement syntaxCopy()\n     {\n-        auto a = new Statements(statements.dim);\n+        auto a = new Statements(statements.length);\n         foreach (i, s; *statements)\n         {\n             (*a)[i] = s ? s.syntaxCopy() : null;\n@@ -1571,7 +1571,7 @@ extern (C++) final class TryCatchStatement : Statement\n \n     override TryCatchStatement syntaxCopy()\n     {\n-        auto a = new Catches(catches.dim);\n+        auto a = new Catches(catches.length);\n         foreach (i, c; *catches)\n         {\n             (*a)[i] = c.syntaxCopy();\n@@ -2019,7 +2019,7 @@ extern (C++) final class CompoundAsmStatement : CompoundStatement\n \n     override CompoundAsmStatement syntaxCopy()\n     {\n-        auto a = new Statements(statements.dim);\n+        auto a = new Statements(statements.length);\n         foreach (i, s; *statements)\n         {\n             (*a)[i] = s ? s.syntaxCopy() : null;\n@@ -2048,7 +2048,7 @@ extern (C++) final class ImportStatement : Statement\n \n     override ImportStatement syntaxCopy()\n     {\n-        auto m = new Dsymbols(imports.dim);\n+        auto m = new Dsymbols(imports.length);\n         foreach (i, s; *imports)\n         {\n             (*m)[i] = s.syntaxCopy(null);"}, {"sha": "7b3a13b40bc56dc577f91940205d12030c8f5915", "filename": "gcc/d/dmd/statement_rewrite_walker.d", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fstatement_rewrite_walker.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fstatement_rewrite_walker.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement_rewrite_walker.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -48,9 +48,9 @@ public:\n \n     override void visit(CompoundStatement s)\n     {\n-        if (s.statements && s.statements.dim)\n+        if (s.statements && s.statements.length)\n         {\n-            for (size_t i = 0; i < s.statements.dim; i++)\n+            for (size_t i = 0; i < s.statements.length; i++)\n             {\n                 if ((*s.statements)[i])\n                     visitStmt((*s.statements)[i]);\n@@ -65,9 +65,9 @@ public:\n \n     override void visit(UnrolledLoopStatement s)\n     {\n-        if (s.statements && s.statements.dim)\n+        if (s.statements && s.statements.length)\n         {\n-            for (size_t i = 0; i < s.statements.dim; i++)\n+            for (size_t i = 0; i < s.statements.length; i++)\n             {\n                 if ((*s.statements)[i])\n                     visitStmt((*s.statements)[i]);\n@@ -161,9 +161,9 @@ public:\n     {\n         if (s._body)\n             visitStmt(s._body);\n-        if (s.catches && s.catches.dim)\n+        if (s.catches && s.catches.length)\n         {\n-            for (size_t i = 0; i < s.catches.dim; i++)\n+            for (size_t i = 0; i < s.catches.length; i++)\n             {\n                 Catch c = (*s.catches)[i];\n                 if (c && c.handler)"}, {"sha": "b372fc2f5a96703747949f14eca059d726992af5", "filename": "gcc/d/dmd/statementsem.d", "status": "modified", "additions": 73, "deletions": 68, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fstatementsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Fstatementsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -249,7 +249,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             }\n         }\n \n-        for (size_t i = 0; i < cs.statements.dim;)\n+        for (size_t i = 0; i < cs.statements.length;)\n         {\n             Statement s = (*cs.statements)[i];\n             if (!s)\n@@ -312,7 +312,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                     return true;\n                 }\n \n-                if (!sfinally && isEmpty((*cs.statements)[i + 1 .. cs.statements.dim]))\n+                if (!sfinally && isEmpty((*cs.statements)[i + 1 .. cs.statements.length]))\n                 {\n                 }\n                 else\n@@ -358,7 +358,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             }\n             else if (sfinally)\n             {\n-                if (0 && i + 1 == cs.statements.dim)\n+                if (0 && i + 1 == cs.statements.length)\n                 {\n                     cs.statements.push(sfinally);\n                 }\n@@ -645,6 +645,13 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             CommaExp.allow(fs.increment);\n             fs.increment = fs.increment.expressionSemantic(sc);\n             fs.increment = resolveProperties(sc, fs.increment);\n+            // @@@DEPRECATED_2.112@@@\n+            // remove gagging and deprecation() to turn deprecation into an error when\n+            // deprecation cycle is over\n+            const olderrors = global.startGagging();\n+            discardValue(fs.increment);\n+            if (global.endGagging(olderrors))\n+                fs.increment.deprecation(\"`%s` has no effect\", fs.increment.toChars());\n             if (checkNonAssignmentArrayOp(fs.increment))\n                 fs.increment = ErrorExp.get();\n             fs.increment = fs.increment.optimize(WANTvalue);\n@@ -693,7 +700,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n         }\n \n         const loc = fs.loc;\n-        const dim = fs.parameters.dim;\n+        const dim = fs.parameters.length;\n \n         fs.func = sc.func;\n         if (fs.func.fes)\n@@ -791,7 +798,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                 }\n             }\n \n-            //printf(\"dim = %d, parameters.dim = %d\\n\", dim, parameters.dim);\n+            //printf(\"dim = %d, parameters.length = %d\\n\", dim, parameters.length);\n             if (foundMismatch && dim != foreachParamCount)\n             {\n                 const(char)* plural = foreachParamCount > 1 ? \"s\" : \"\";\n@@ -854,7 +861,6 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             result = s;\n         }\n \n-        TypeAArray taa = null;\n         Type tn = null;\n         Type tnv = null;\n         Statement apply()\n@@ -865,26 +871,25 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             TypeFunction tfld = null;\n             if (sapply)\n             {\n-                FuncDeclaration fdapply = sapply.isFuncDeclaration();\n-                if (fdapply)\n+                if (auto fdapply = sapply.isFuncDeclaration())\n                 {\n-                    assert(fdapply.type && fdapply.type.ty == Tfunction);\n-                    tfld = cast(TypeFunction)fdapply.type.typeSemantic(loc, sc2);\n+                    assert(fdapply.type && fdapply.type.isTypeFunction());\n+                    tfld = fdapply.type.typeSemantic(loc, sc2).isTypeFunction();\n                     goto Lget;\n                 }\n-                else if (tab.ty == Tdelegate)\n+                else if (tab.isTypeDelegate())\n                 {\n-                    tfld = cast(TypeFunction)tab.nextOf();\n+                    tfld = tab.nextOf().isTypeFunction();\n                 Lget:\n                     //printf(\"tfld = %s\\n\", tfld.toChars());\n-                    if (tfld.parameterList.parameters.dim == 1)\n+                    if (tfld.parameterList.parameters.length == 1)\n                     {\n                         Parameter p = tfld.parameterList[0];\n-                        if (p.type && p.type.ty == Tdelegate)\n+                        if (p.type && p.type.isTypeDelegate())\n                         {\n                             auto t = p.type.typeSemantic(loc, sc2);\n                             assert(t.ty == Tdelegate);\n-                            tfld = cast(TypeFunction)t.nextOf();\n+                            tfld = t.nextOf().isTypeFunction();\n                         }\n                     }\n                 }\n@@ -902,12 +907,11 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                 {\n                     // 'Promote' it to this scope, and replace with a return\n                     fs.cases.push(gs);\n-                    ss.statement = new ReturnStatement(Loc.initial, new IntegerExp(fs.cases.dim + 1));\n+                    ss.statement = new ReturnStatement(Loc.initial, new IntegerExp(fs.cases.length + 1));\n                 }\n             }\n \n             Expression e = null;\n-            Expression ec;\n             if (vinit)\n             {\n                 e = new DeclarationExp(loc, vinit);\n@@ -916,19 +920,22 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                     return null;\n             }\n \n-            if (taa)\n-                ec = applyAssocArray(fs, flde, taa);\n-            else if (tab.ty == Tarray || tab.ty == Tsarray)\n-                ec = applyArray(fs, flde, sc2, tn, tnv, tab.ty);\n-            else if (tab.ty == Tdelegate)\n-                ec = applyDelegate(fs, flde, sc2, tab);\n-            else\n-                ec = applyOpApply(fs, tab, sapply, sc2, flde);\n+            Expression ec;\n+            switch (tab.ty)\n+            {\n+                case Tarray:\n+                case Tsarray:   ec = applyArray     (fs, flde, tab, sc2, tn, tnv); break;\n+                case Tdelegate: ec = applyDelegate  (fs, flde, tab, sc2);          break;\n+                case Taarray:   ec = applyAssocArray(fs, flde, tab);               break;\n+                default:        ec = applyOpApply   (fs, flde, tab, sc2, sapply);  break;\n+            }\n             if (!ec)\n                 return null;\n+\n             e = Expression.combine(e, ec);\n             return loopReturn(e, fs.cases, loc);\n         }\n+\n         switch (tab.ty)\n         {\n         case Tarray:\n@@ -966,7 +973,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                      *  2. foreach body is lowered to _aApply (see special case below).\n                      */\n                     Type tv = (*fs.parameters)[1].type.toBasetype();\n-                    if ((tab.ty == Tarray ||\n+                    if ((tab.isTypeDArray() ||\n                          (tn.ty != tv.ty && tn.ty.isSomeChar && tv.ty.isSomeChar)) &&\n                         !Type.tsize_t.implicitConvTo(tindex))\n                     {\n@@ -1021,9 +1028,8 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                             return retError();\n                         }\n                     }\n-                    if (tab.ty == Tsarray)\n+                    if (auto ta = tab.isTypeSArray())\n                     {\n-                        TypeSArray ta = cast(TypeSArray)tab;\n                         IntRange dimrange = getIntRange(ta.dim);\n                         // https://issues.dlang.org/show_bug.cgi?id=12504\n                         dimrange.imax = SignExtendedNumber(dimrange.imax.value-1);\n@@ -1072,10 +1078,10 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                 auto ie = new ExpInitializer(loc, new SliceExp(loc, fs.aggr, null, null));\n                 const valueIsRef = (*fs.parameters)[$ - 1].isReference();\n                 VarDeclaration tmp;\n-                if (fs.aggr.op == EXP.arrayLiteral && !valueIsRef)\n+                if (fs.aggr.isArrayLiteralExp() && !valueIsRef)\n                 {\n-                    auto ale = cast(ArrayLiteralExp)fs.aggr;\n-                    size_t edim = ale.elements ? ale.elements.dim : 0;\n+                    auto ale = fs.aggr.isArrayLiteralExp();\n+                    size_t edim = ale.elements ? ale.elements.length : 0;\n                     auto telem = (*fs.parameters)[dim - 1].type;\n \n                     // https://issues.dlang.org/show_bug.cgi?id=12936\n@@ -1182,7 +1188,6 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             if (checkForArgTypes(fs))\n                 return retError();\n \n-            taa = cast(TypeAArray)tab;\n             if (dim < 1 || dim > 2)\n             {\n                 fs.error(\"only one or two arguments for associative array `foreach`\");\n@@ -1207,8 +1212,8 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                  *    }\n                  */\n                 auto ad = (tab.ty == Tclass) ?\n-                    cast(AggregateDeclaration)(cast(TypeClass)tab).sym :\n-                    cast(AggregateDeclaration)(cast(TypeStruct)tab).sym;\n+                    cast(AggregateDeclaration)tab.isTypeClass().sym :\n+                    cast(AggregateDeclaration)tab.isTypeStruct().sym;\n                 Identifier idfront;\n                 Identifier idpopFront;\n                 if (fs.op == TOK.foreach_)\n@@ -1229,7 +1234,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                  */\n                 VarDeclaration r;\n                 Statement _init;\n-                if (vinit && fs.aggr.op == EXP.variable && (cast(VarExp)fs.aggr).var == vinit)\n+                if (vinit && fs.aggr.isVarExp() && fs.aggr.isVarExp().var == vinit)\n                 {\n                     r = vinit;\n                     _init = new ExpStatement(loc, vinit);\n@@ -1279,9 +1284,8 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                 }\n                 if (!tfront || tfront.ty == Terror)\n                     return rangeError();\n-                if (tfront.toBasetype().ty == Tfunction)\n+                if (auto ftt = tfront.toBasetype().isTypeFunction())\n                 {\n-                    auto ftt = cast(TypeFunction)tfront.toBasetype();\n                     tfront = tfront.toBasetype().nextOf();\n                     if (!ftt.isref)\n                     {\n@@ -1323,17 +1327,17 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                     auto exps = new Expressions();\n                     exps.push(ve);\n                     int pos = 0;\n-                    while (exps.dim < dim)\n+                    while (exps.length < dim)\n                     {\n                         pos = expandAliasThisTuples(exps, pos);\n                         if (pos == -1)\n                             break;\n                     }\n-                    if (exps.dim != dim)\n+                    if (exps.length != dim)\n                     {\n-                        const(char)* plural = exps.dim > 1 ? \"s\" : \"\";\n+                        const(char)* plural = exps.length > 1 ? \"s\" : \"\";\n                         fs.error(\"cannot infer argument types, expected %llu argument%s, not %llu\",\n-                            cast(ulong) exps.dim, plural, cast(ulong) dim);\n+                            cast(ulong) exps.length, plural, cast(ulong) dim);\n                         return retError();\n                     }\n \n@@ -1389,8 +1393,8 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n         }\n     }\n \n-    private static extern(D) Expression applyOpApply(ForeachStatement fs, Type tab, Dsymbol sapply,\n-                                                     Scope* sc2, Expression flde)\n+    private static extern(D) Expression applyOpApply(ForeachStatement fs, Expression flde,\n+                Type tab, Scope* sc2, Dsymbol sapply)\n     {\n         version (none)\n         {\n@@ -1425,7 +1429,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n     }\n \n     private static extern(D) Expression applyDelegate(ForeachStatement fs, Expression flde,\n-                                                      Scope* sc2, Type tab)\n+                                                      Type tab, Scope* sc2)\n     {\n         Expression ec;\n         /* Call:\n@@ -1450,10 +1454,10 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n     }\n \n     private static extern(D) Expression applyArray(ForeachStatement fs, Expression flde,\n-                                                   Scope* sc2, Type tn, Type tnv, TY tabty)\n+                                                   Type tab, Scope* sc2, Type tn, Type tnv)\n     {\n         Expression ec;\n-        const dim = fs.parameters.dim;\n+        const dim = fs.parameters.length;\n         const loc = fs.loc;\n         /* Call:\n          *      _aApply(aggr, flde)\n@@ -1501,7 +1505,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n         params.push(new Parameter(0, dgty, null, null, null));\n         fdapply = FuncDeclaration.genCfunc(params, Type.tint32, fdname.ptr);\n \n-        if (tabty == Tsarray)\n+        if (tab.isTypeSArray())\n             fs.aggr = fs.aggr.castTo(sc2, tn.arrayOf());\n         // paint delegate argument to the type runtime expects\n         Expression fexp = flde;\n@@ -1516,10 +1520,11 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n         return ec;\n     }\n \n-    private static extern(D) Expression applyAssocArray(ForeachStatement fs, Expression flde, TypeAArray taa)\n+    private static extern(D) Expression applyAssocArray(ForeachStatement fs, Expression flde, Type tab)\n     {\n+        auto taa = tab.isTypeAArray();\n         Expression ec;\n-        const dim = fs.parameters.dim;\n+        const dim = fs.parameters.length;\n         // Check types\n         Parameter p = (*fs.parameters)[0];\n         bool isRef = (p.storageClass & STC.ref_) != 0;\n@@ -1593,7 +1598,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n \n     private static extern(D) Statement loopReturn(Expression e, Statements* cases, const ref Loc loc)\n     {\n-        if (!cases.dim)\n+        if (!cases.length)\n         {\n             // Easy case, a clean exit from the loop\n             e = new CastExp(loc, e, Type.tvoid); // https://issues.dlang.org/show_bug.cgi?id=13899\n@@ -2024,7 +2029,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             }\n             else\n             {\n-                if (!ps.args || ps.args.dim != 1)\n+                if (!ps.args || ps.args.length != 1)\n                 {\n                     ps.error(\"`string` expected for library name\");\n                     return setError();\n@@ -2338,7 +2343,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n \n         size_t numcases = 0;\n         if (ss.cases)\n-            numcases = ss.cases.dim;\n+            numcases = ss.cases.length;\n \n         for (size_t i = 0; i < numcases; i++)\n         {\n@@ -2501,7 +2506,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             sw.cases.push(cs);\n \n             // Resolve any goto case's with no exp to this case statement\n-            for (size_t i = 0; i < sw.gotoCases.dim;)\n+            for (size_t i = 0; i < sw.gotoCases.length;)\n             {\n                 GotoCaseStatement gcs = sw.gotoCases[i];\n                 if (!gcs.exp)\n@@ -2735,7 +2740,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             {\n                 assert(rs.caseDim == 0);\n                 sc.fes.cases.push(rs);\n-                result = new ReturnStatement(Loc.initial, new IntegerExp(sc.fes.cases.dim + 1));\n+                result = new ReturnStatement(Loc.initial, new IntegerExp(sc.fes.cases.length + 1));\n                 return;\n             }\n             if (fd.returnLabel)\n@@ -3053,8 +3058,8 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                 sc.fes.cases.push(s);\n \n                 // Immediately rewrite \"this\" return statement as:\n-                //  return cases.dim+1;\n-                rs.exp = new IntegerExp(sc.fes.cases.dim + 1);\n+                //  return cases.length+1;\n+                rs.exp = new IntegerExp(sc.fes.cases.length + 1);\n                 if (e0)\n                 {\n                     result = new CompoundStatement(rs.loc, new ExpStatement(rs.loc, e0), rs);\n@@ -3078,7 +3083,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                 //  return exp;\n                 // to:\n                 //  vresult = exp; retrun caseDim;\n-                rs.caseDim = sc.fes.cases.dim + 1;\n+                rs.caseDim = sc.fes.cases.length + 1;\n             }\n         }\n         if (rs.exp)\n@@ -3136,7 +3141,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                          * and 1 is break.\n                          */\n                         sc.fes.cases.push(bs);\n-                        result = new ReturnStatement(Loc.initial, new IntegerExp(sc.fes.cases.dim + 1));\n+                        result = new ReturnStatement(Loc.initial, new IntegerExp(sc.fes.cases.length + 1));\n                         return;\n                     }\n                     break; // can't break to it\n@@ -3224,7 +3229,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                          * and 1 is break.\n                          */\n                         sc.fes.cases.push(cs);\n-                        result = new ReturnStatement(Loc.initial, new IntegerExp(sc.fes.cases.dim + 1));\n+                        result = new ReturnStatement(Loc.initial, new IntegerExp(sc.fes.cases.length + 1));\n                         return;\n                     }\n                     break; // can't continue to it\n@@ -3589,7 +3594,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n          */\n         if (!(tcs._body.blockExit(sc.func, false) & BE.throw_) && ClassDeclaration.exception)\n         {\n-            foreach_reverse (i; 0 .. tcs.catches.dim)\n+            foreach_reverse (i; 0 .. tcs.catches.length)\n             {\n                 Catch c = (*tcs.catches)[i];\n \n@@ -3604,7 +3609,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             }\n         }\n \n-        if (tcs.catches.dim == 0)\n+        if (tcs.catches.length == 0)\n         {\n             result = tcs._body.hasCode() ? tcs._body : null;\n             return;\n@@ -3909,10 +3914,10 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n         /* https://dlang.org/spec/module.html#ImportDeclaration\n          */\n \n-        foreach (i; 0 .. imps.imports.dim)\n+        foreach (i; 0 .. imps.imports.length)\n         {\n             Import s = (*imps.imports)[i].isImport();\n-            assert(!s.aliasdecls.dim);\n+            assert(!s.aliasdecls.length);\n             foreach (j, name; s.names)\n             {\n                 Identifier _alias = s.aliases[j];\n@@ -4217,7 +4222,7 @@ public auto makeTupleForeach(Scope* sc, bool isStatic, bool isDecl, ForeachState\n     }\n \n     auto loc = fs.loc;\n-    size_t dim = fs.parameters.dim;\n+    size_t dim = fs.parameters.length;\n     const bool skipCheck = isStatic && needExpansion;\n     if (!skipCheck && (dim < 1 || dim > 2))\n     {\n@@ -4251,7 +4256,7 @@ public auto makeTupleForeach(Scope* sc, bool isStatic, bool isDecl, ForeachState\n     if (fs.aggr.op == EXP.tuple) // expression tuple\n     {\n         te = cast(TupleExp)fs.aggr;\n-        n = te.exps.dim;\n+        n = te.exps.length;\n     }\n     else if (fs.aggr.op == EXP.type) // type tuple\n     {\n@@ -4632,7 +4637,7 @@ private Statements* flatten(Statement statement, Scope* sc)\n             {\n                 return a;\n             }\n-            auto b = new Statements(a.dim);\n+            auto b = new Statements(a.length);\n             foreach (i, s; *a)\n             {\n                 (*b)[i] = s ? new ForwardingStatement(s.loc, fs.sym, s) : null;\n@@ -4702,7 +4707,7 @@ private Statements* flatten(Statement statement, Scope* sc)\n             if (!a)\n                 return null;\n \n-            if (!a.dim)\n+            if (!a.length)\n             {\n                 a.push(new ExpStatement(ls.loc, cast(Expression)null));\n             }\n@@ -4892,7 +4897,7 @@ bool pragmaMsgSemantic(Loc loc, Scope* sc, Expressions* args)\n  */\n bool pragmaStartAddressSemantic(Loc loc, Scope* sc, Expressions* args)\n {\n-    if (!args || args.dim != 1)\n+    if (!args || args.length != 1)\n     {\n         .error(loc, \"function name expected for start address\");\n         return false;"}, {"sha": "a6d2304c38acce82dd39b3b4f1f3bfe599f7384c", "filename": "gcc/d/dmd/traits.d", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -394,7 +394,7 @@ ulong getTypePointerBitmap(Loc loc, Type t, Array!(ulong)* data)\n  */\n private Expression pointerBitmap(TraitsExp e)\n {\n-    if (!e.args || e.args.dim != 1)\n+    if (!e.args || e.args.length != 1)\n     {\n         error(e.loc, \"a single type expected for trait pointerBitmap\");\n         return ErrorExp.get();\n@@ -412,12 +412,12 @@ private Expression pointerBitmap(TraitsExp e)\n     if (sz == ulong.max)\n         return ErrorExp.get();\n \n-    auto exps = new Expressions(data.dim + 1);\n+    auto exps = new Expressions(data.length + 1);\n     (*exps)[0] = new IntegerExp(e.loc, sz, Type.tsize_t);\n-    foreach (size_t i; 1 .. exps.dim)\n+    foreach (size_t i; 1 .. exps.length)\n         (*exps)[i] = new IntegerExp(e.loc, data[cast(size_t) (i - 1)], Type.tsize_t);\n \n-    auto ale = new ArrayLiteralExp(e.loc, Type.tsize_t.sarrayOf(data.dim + 1), exps);\n+    auto ale = new ArrayLiteralExp(e.loc, Type.tsize_t.sarrayOf(data.length + 1), exps);\n     return ale;\n }\n \n@@ -446,7 +446,7 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n         }\n         sc.stc = save;\n     }\n-    size_t dim = e.args ? e.args.dim : 0;\n+    size_t dim = e.args ? e.args.length : 0;\n \n     Expression dimError(int expected)\n     {\n@@ -1276,6 +1276,25 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n         }\n         else if (s)\n         {\n+            // @@@DEPRECATION 2.100.2\n+            if (auto fd = s.isFuncDeclaration())\n+            {\n+                if (fd.overnext)\n+                {\n+                    deprecation(e.loc, \"`__traits(getAttributes)` may only be used for individual functions, not overload sets such as: `%s`\", fd.toChars());\n+                    deprecationSupplemental(e.loc, \"the result of `__traits(getOverloads)` may be used to select the desired function to extract attributes from\");\n+                }\n+            }\n+\n+            // @@@DEPRECATION 2.100.2\n+            if (auto td = s.isTemplateDeclaration())\n+            {\n+                if (td.overnext || td.funcroot)\n+                {\n+                    deprecation(e.loc, \"`__traits(getAttributes)` may only be used for individual functions, not overload sets such as: `%s`\", td.ident.toChars());\n+                    deprecationSupplemental(e.loc, \"the result of `__traits(getOverloads)` may be used to select the desired function to extract attributes from\");\n+                }\n+            }\n             if (s.isImport())\n             {\n                 s = s.isImport().mod;\n@@ -1689,12 +1708,12 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n \n             void pushBaseMembersDg(ClassDeclaration cd)\n             {\n-                for (size_t i = 0; i < cd.baseclasses.dim; i++)\n+                for (size_t i = 0; i < cd.baseclasses.length; i++)\n                 {\n                     auto cb = (*cd.baseclasses)[i].sym;\n                     assert(cb);\n                     ScopeDsymbol._foreach(null, cb.members, &pushIdentsDg);\n-                    if (cb.baseclasses.dim)\n+                    if (cb.baseclasses.length)\n                         pushBaseMembersDg(cb);\n                 }\n             }\n@@ -1801,9 +1820,9 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n             return ErrorExp.get();\n         if (!TemplateInstance.semanticTiargs(e.loc, sc, &ob2, 0))\n             return ErrorExp.get();\n-        if (ob1.dim != ob2.dim)\n+        if (ob1.length != ob2.length)\n             return False();\n-        foreach (immutable i; 0 .. ob1.dim)\n+        foreach (immutable i; 0 .. ob1.length)\n             if (!ob1[i].isSame(ob2[i], sc))\n                 return False();\n         return True();\n@@ -1924,7 +1943,12 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n             return ErrorExp.get();\n         }\n \n-        Type tb = t.baseElemOf();\n+        // https://issues.dlang.org/show_bug.cgi?id=23534\n+        //\n+        // For enums, we need to get the enum initializer\n+        // (the first enum member), not the initializer of the\n+        // type of the enum members.\n+        Type tb = t.isTypeEnum ? t : t.baseElemOf();\n         return tb.isZeroInit(e.loc) ? True() : False();\n     }\n     if (e.ident == Id.getTargetInfo)\n@@ -2041,7 +2065,7 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n                 if (prependNamespaces(outer, pp.cppnamespace)) return ErrorExp.get();\n \n                 size_t i = 0;\n-                while(i < outer.dim && ((*inner)[i]) == (*outer)[i])\n+                while(i < outer.length && ((*inner)[i]) == (*outer)[i])\n                     i++;\n \n                 foreach_reverse (ns; (*inner)[][i .. $])\n@@ -2124,7 +2148,7 @@ private bool isSame(RootObject o1, RootObject o2, Scope* sc)\n         {\n             if (auto td = t.isTemplateDeclaration())\n             {\n-                if (td.members && td.members.dim == 1)\n+                if (td.members && td.members.length == 1)\n                 {\n                     if (auto fd = (*td.members)[0].isFuncLiteralDeclaration())\n                         return fd;\n@@ -2221,7 +2245,7 @@ private bool isSame(RootObject o1, RootObject o2, Scope* sc)\n     if (!overSet2)\n         return false;\n \n-    if (overSet1.a.dim != overSet2.a.dim)\n+    if (overSet1.a.length != overSet2.a.length)\n         return false;\n \n     // OverloadSets contain array of Dsymbols => O(n*n)"}, {"sha": "7aaf0b87268cf0faf907c0f2bc46e265c97033a3", "filename": "gcc/d/dmd/transitivevisitor.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -617,7 +617,7 @@ package mixin template ParseVisitMethods(AST)\n     void visitBaseClasses(AST.ClassDeclaration d)\n     {\n         //printf(\"Visiting ClassDeclaration\\n\");\n-        if (!d || !d.baseclasses.dim)\n+        if (!d || !d.baseclasses.length)\n             return;\n         foreach (b; *d.baseclasses)\n             visitType(b.type);\n@@ -626,7 +626,7 @@ package mixin template ParseVisitMethods(AST)\n     bool visitEponymousMember(AST.TemplateDeclaration d)\n     {\n         //printf(\"Visiting EponymousMember\\n\");\n-        if (!d.members || d.members.dim != 1)\n+        if (!d.members || d.members.length != 1)\n             return false;\n         AST.Dsymbol onemember = (*d.members)[0];\n         if (onemember.ident != d.ident)\n@@ -688,7 +688,7 @@ package mixin template ParseVisitMethods(AST)\n \n     void visitTemplateParameters(AST.TemplateParameters* parameters)\n     {\n-        if (!parameters || !parameters.dim)\n+        if (!parameters || !parameters.length)\n             return;\n         foreach (p; *parameters)\n             p.accept(this);\n@@ -1042,7 +1042,7 @@ package mixin template ParseVisitMethods(AST)\n         visitType(e.targ);\n         if (e.tspec)\n             visitType(e.tspec);\n-        if (e.parameters && e.parameters.dim)\n+        if (e.parameters && e.parameters.length)\n             visitTemplateParameters(e.parameters);\n     }\n "}, {"sha": "a75b4165cc304610116ceaf9ffaae61eb035f42a", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -117,9 +117,9 @@ private void resolveTupleIndex(const ref Loc loc, Scope* sc, Dsymbol s, out Expr\n         return;\n     }\n     const(uinteger_t) d = eindex.toUInteger();\n-    if (d >= tup.objects.dim)\n+    if (d >= tup.objects.length)\n     {\n-        .error(loc, \"tuple index `%llu` out of bounds `[0 .. %llu]`\", d, cast(ulong)tup.objects.dim);\n+        .error(loc, \"tuple index `%llu` out of bounds `[0 .. %llu]`\", d, cast(ulong)tup.objects.length);\n         pt = Type.terror;\n         return;\n     }\n@@ -194,7 +194,7 @@ private void resolveHelper(TypeQualified mt, const ref Loc loc, Scope* sc, Dsymb\n     }\n     s = s.toAlias();\n     //printf(\"\\t2: s = '%s' %p, kind = '%s'\\n\",s.toChars(), s, s.kind());\n-    for (size_t i = 0; i < mt.idents.dim; i++)\n+    for (size_t i = 0; i < mt.idents.length; i++)\n     {\n         RootObject id = mt.idents[i];\n         switch (id.dyncast()) with (DYNCAST)\n@@ -552,9 +552,9 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                 return error();\n \n             uinteger_t d = mtype.dim.toUInteger();\n-            if (d >= tup.objects.dim)\n+            if (d >= tup.objects.length)\n             {\n-                .error(loc, \"tuple index `%llu` out of bounds `[0 .. %llu]`\", cast(ulong)d, cast(ulong)tup.objects.dim);\n+                .error(loc, \"tuple index `%llu` out of bounds `[0 .. %llu]`\", cast(ulong)d, cast(ulong)tup.objects.length);\n                 return error();\n             }\n \n@@ -647,9 +647,9 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                 assert(mtype.dim);\n                 TypeTuple tt = tbn.isTypeTuple();\n                 uinteger_t d = mtype.dim.toUInteger();\n-                if (d >= tt.arguments.dim)\n+                if (d >= tt.arguments.length)\n                 {\n-                    .error(loc, \"tuple index `%llu` out of bounds `[0 .. %llu]`\", cast(ulong)d, cast(ulong)tt.arguments.dim);\n+                    .error(loc, \"tuple index `%llu` out of bounds `[0 .. %llu]`\", cast(ulong)d, cast(ulong)tt.arguments.length);\n                     return error();\n                 }\n                 Type telem = (*tt.arguments)[cast(size_t)d].type;\n@@ -875,11 +875,11 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                 fhash = search_function(ClassDeclaration.object, Id.tohash).isFuncDeclaration();\n             assert(fcmp && feq && fhash);\n \n-            if (feq.vtblIndex < cd.vtbl.dim && cd.vtbl[feq.vtblIndex] == feq)\n+            if (feq.vtblIndex < cd.vtbl.length && cd.vtbl[feq.vtblIndex] == feq)\n             {\n                 version (all)\n                 {\n-                    if (fcmp.vtblIndex < cd.vtbl.dim && cd.vtbl[fcmp.vtblIndex] != fcmp)\n+                    if (fcmp.vtblIndex < cd.vtbl.length && cd.vtbl[fcmp.vtblIndex] != fcmp)\n                     {\n                         const(char)* s = (mtype.index.toBasetype().ty != Tclass) ? \"bottom of \" : \"\";\n                         .error(loc, \"%sAA key type `%s` now requires equality rather than comparison\", s, cd.toChars());\n@@ -993,7 +993,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n         if (mtype.parameterList.parameters)\n         {\n             tf.parameterList.parameters = mtype.parameterList.parameters.copy();\n-            for (size_t i = 0; i < mtype.parameterList.parameters.dim; i++)\n+            for (size_t i = 0; i < mtype.parameterList.parameters.length; i++)\n             {\n                 Parameter p = cast(Parameter)mem.xmalloc(__traits(classInstanceSize, Parameter));\n                 memcpy(cast(void*)p, cast(void*)(*mtype.parameterList.parameters)[i], __traits(classInstanceSize, Parameter));\n@@ -1180,13 +1180,13 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                      * the elements of TypeTuple::arguments to avoid unintended\n                      * sharing of Parameter object among other functions.\n                      */\n-                    if (tt.arguments && tt.arguments.dim)\n+                    if (tt.arguments && tt.arguments.length)\n                     {\n                         /* Propagate additional storage class from tuple parameters to their\n                          * element-parameters.\n                          * Make a copy, as original may be referenced elsewhere.\n                          */\n-                        size_t tdim = tt.arguments.dim;\n+                        size_t tdim = tt.arguments.length;\n                         auto newparams = new Parameters(tdim);\n                         for (size_t j = 0; j < tdim; j++)\n                         {\n@@ -1437,7 +1437,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                  */\n                 if (eparam.storageClass & STC.auto_)\n                 {\n-                    Expression farg = mtype.fargs && eidx < mtype.fargs.dim ?\n+                    Expression farg = mtype.fargs && eidx < mtype.fargs.length ?\n                         (*mtype.fargs)[eidx] : eparam.defaultArg;\n                     if (farg && (eparam.storageClass & STC.ref_))\n                     {\n@@ -1756,10 +1756,10 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n \n         uinteger_t i1 = mtype.lwr.toUInteger();\n         uinteger_t i2 = mtype.upr.toUInteger();\n-        if (!(i1 <= i2 && i2 <= tt.arguments.dim))\n+        if (!(i1 <= i2 && i2 <= tt.arguments.length))\n         {\n             .error(loc, \"slice `[%llu..%llu]` is out of range of `[0..%llu]`\",\n-                cast(ulong)i1, cast(ulong)i2, cast(ulong)tt.arguments.dim);\n+                cast(ulong)i1, cast(ulong)i2, cast(ulong)tt.arguments.length);\n             return error();\n         }\n \n@@ -2477,7 +2477,7 @@ Expression getProperty(Type t, Scope* scope_, const ref Loc loc, Identifier iden\n         }\n         if (ident == Id.length)\n         {\n-            e = new IntegerExp(loc, mt.arguments.dim, Type.tsize_t);\n+            e = new IntegerExp(loc, mt.arguments.length, Type.tsize_t);\n         }\n         else if (ident == Id._init)\n         {\n@@ -2614,9 +2614,9 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n                     return returnError();\n \n                 const d = mt.dim.toUInteger();\n-                if (d >= tup.objects.dim)\n+                if (d >= tup.objects.length)\n                 {\n-                    error(loc, \"tuple index `%llu` out of bounds `[0 .. %llu]`\", d, cast(ulong) tup.objects.dim);\n+                    error(loc, \"tuple index `%llu` out of bounds `[0 .. %llu]`\", d, cast(ulong) tup.objects.length);\n                     return returnError();\n                 }\n \n@@ -2897,7 +2897,7 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n             error(loc, \"forward reference to `%s`\", mt.toChars());\n             goto Lerr;\n         }\n-        if (mt.idents.dim == 0)\n+        if (mt.idents.length == 0)\n         {\n             returnType(t.addMod(mt.mod));\n         }\n@@ -2937,7 +2937,7 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n                 return returnError();\n             }\n         }\n-        if (mt.idents.dim == 0)\n+        if (mt.idents.length == 0)\n         {\n             return returnType(t.addMod(mt.mod));\n         }\n@@ -2987,13 +2987,13 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n                 mt.upr = mt.upr.ctfeInterpret();\n                 const i1 = mt.lwr.toUInteger();\n                 const i2 = mt.upr.toUInteger();\n-                if (!(i1 <= i2 && i2 <= td.objects.dim))\n+                if (!(i1 <= i2 && i2 <= td.objects.length))\n                 {\n-                    error(loc, \"slice `[%llu..%llu]` is out of range of [0..%llu]\", i1, i2, cast(ulong) td.objects.dim);\n+                    error(loc, \"slice `[%llu..%llu]` is out of range of [0..%llu]\", i1, i2, cast(ulong) td.objects.length);\n                     return returnError();\n                 }\n \n-                if (i1 == 0 && i2 == td.objects.dim)\n+                if (i1 == 0 && i2 == td.objects.length)\n                 {\n                     return returnSymbol(td);\n                 }\n@@ -3002,7 +3002,7 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n                  * is a slice [i1..i2] out of the old one.\n                  */\n                 auto objects = new Objects(cast(size_t)(i2 - i1));\n-                for (size_t i = 0; i < objects.dim; i++)\n+                for (size_t i = 0; i < objects.length; i++)\n                 {\n                     (*objects)[i] = (*td.objects)[cast(size_t)i1 + i];\n                 }\n@@ -3096,8 +3096,8 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n                 break;\n             case EXP.tuple:\n                 TupleExp te = e.isTupleExp();\n-                Objects* elems = new Objects(te.exps.dim);\n-                foreach (i; 0 .. elems.dim)\n+                Objects* elems = new Objects(te.exps.length);\n+                foreach (i; 0 .. elems.length)\n                 {\n                     auto src = (*te.exps)[i];\n                     switch (src.op)\n@@ -3757,8 +3757,8 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n                 ev = extractSideEffect(sc, \"__tup\", e0, ev);\n \n             auto exps = new Expressions();\n-            exps.reserve(mt.sym.fields.dim);\n-            for (size_t i = 0; i < mt.sym.fields.dim; i++)\n+            exps.reserve(mt.sym.fields.length);\n+            for (size_t i = 0; i < mt.sym.fields.length; i++)\n             {\n                 VarDeclaration v = mt.sym.fields[i];\n                 Expression ex;\n@@ -4015,8 +4015,8 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n                 ev = extractSideEffect(sc, \"__tup\", e0, ev);\n \n             auto exps = new Expressions();\n-            exps.reserve(mt.sym.fields.dim);\n-            for (size_t i = 0; i < mt.sym.fields.dim; i++)\n+            exps.reserve(mt.sym.fields.length);\n+            for (size_t i = 0; i < mt.sym.fields.length; i++)\n             {\n                 VarDeclaration v = mt.sym.fields[i];\n                 // Don't include hidden 'this' pointer\n@@ -4589,8 +4589,8 @@ extern (C++) Expression defaultInit(Type mt, const ref Loc loc, const bool isCfi\n         {\n             printf(\"TypeTuple::defaultInit() '%s'\\n\", mt.toChars());\n         }\n-        auto exps = new Expressions(mt.arguments.dim);\n-        for (size_t i = 0; i < mt.arguments.dim; i++)\n+        auto exps = new Expressions(mt.arguments.length);\n+        for (size_t i = 0; i < mt.arguments.length; i++)\n         {\n             Parameter p = (*mt.arguments)[i];\n             assert(p.type);\n@@ -4655,7 +4655,7 @@ private:\n Expression typeToExpressionHelper(TypeQualified t, Expression e, size_t i = 0)\n {\n     //printf(\"toExpressionHelper(e = %s %s)\\n\", EXPtoString(e.op).ptr, e.toChars());\n-    foreach (id; t.idents[i .. t.idents.dim])\n+    foreach (id; t.idents[i .. t.idents.length])\n     {\n         //printf(\"\\t[%d] e: '%s', id: '%s'\\n\", i, e.toChars(), id.toChars());\n \n@@ -4770,7 +4770,7 @@ Type stripDefaultArgs(Type t)\n                 if (ps)\n                 {\n                     // Replace params with a copy we can modify\n-                    Parameters* nparams = new Parameters(parameters.dim);\n+                    Parameters* nparams = new Parameters(parameters.length);\n \n                     foreach (j, ref np; *nparams)\n                     {\n@@ -4898,7 +4898,7 @@ Expression getMaxMinValue(EnumDeclaration ed, const ref Loc loc, Identifier id)\n     }\n \n     bool first = true;\n-    for (size_t i = 0; i < ed.members.dim; i++)\n+    for (size_t i = 0; i < ed.members.length; i++)\n     {\n         EnumMember em = (*ed.members)[i].isEnumMember();\n         if (!em)"}, {"sha": "00fa2ba25a787b2b7b07a2b14634d90a830650bd", "filename": "gcc/d/typeinfo.cc", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Ftypeinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Fd%2Ftypeinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypeinfo.cc?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1064,17 +1064,6 @@ class TypeInfoVisitor : public Visitor\n       : null_pointer_node;\n     this->layout_field (xhash);\n \n-    if (sd->xhash)\n-      {\n-\tTypeFunction *tf = sd->xhash->type->toTypeFunction ();\n-\tif (!tf->isnothrow () || tf->trust == TRUST::system)\n-\t  {\n-\t    warning (sd->xhash->loc, \"toHash() must be declared as \"\n-\t\t     \"extern (D) size_t toHash() const nothrow @safe, \"\n-\t\t     \"not %s\", tf->toChars ());\n-\t  }\n-      }\n-\n     /* bool function(in void*, in void*) xopEquals;  */\n     tree xeq = (sd->xeq) ? build_address (get_symbol_decl (sd->xeq))\n       : null_pointer_node;\n@@ -1410,7 +1399,7 @@ check_typeinfo_type (const Loc &loc, Scope *sc, Expression *expr)\n     {\n       /* Even when compiling without RTTI we should still be able to evaluate\n \t TypeInfo at compile-time, just not at run-time.  */\n-      if (!sc || !(sc->flags & SCOPEctfe))\n+      if (!sc || !(sc->flags & unsigned(SCOPE::ctfe)))\n \t{\n \t  static int warned = 0;\n "}, {"sha": "88cf1229d4dabe4d3d3c9fa944b633d6ed126590", "filename": "gcc/testsuite/gdc.test/compilable/nogc.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnogc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnogc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnogc.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -40,7 +40,8 @@ void foo_compiles() {}\n     static assert(!__traits(compiles, delete p));\n \n     int[int] aa;\n-    static assert(!__traits(compiles, aa[0]));\n+    static assert( __traits(compiles, aa[0]));\n+    static assert(!__traits(compiles, (aa[0] = 10)));\n \n     int[] a;\n     static assert(!__traits(compiles, a.length = 1));"}, {"sha": "07321e5e0384721f7699457c554d21f5f1c1e65d", "filename": "gcc/testsuite/gdc.test/compilable/test15712.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15712.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15712.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15712.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,12 @@\n+// REQUIRED_ARGS: -unittest\n+\n+// https://issues.dlang.org/show_bug.cgi?id=15712\n+// extern(C) attribute inside extern(C) unittest is incorrectly ignored\n+\n+extern(C):\n+\n+unittest\n+{\n+\textern(C) static void foo() {}\n+\tstatic assert(__traits(getLinkage, foo) == \"C\");\n+}"}, {"sha": "8fafcb28a3959c363da128bfdba14d9d0fc33382", "filename": "gcc/testsuite/gdc.test/compilable/test23431.d", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23431.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23431.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23431.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,14 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23431\n+// REQUIRED_ARGS: -lowmem\n+void test23431()\n+{\n+    int a;\n+    try\n+    {\n+        throw new Exception(\"test1\");\n+        a++;\n+    }\n+    finally\n+    {\n+    }\n+}"}, {"sha": "0293f1272865573b8f944f520266550f30862e8e", "filename": "gcc/testsuite/gdc.test/compilable/test23431_minimal.d", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23431_minimal.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23431_minimal.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23431_minimal.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,28 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23431\n+// REQUIRED_ARGS: -lowmem\n+module object;\n+\n+alias string  = immutable(char)[];\n+class Throwable { }\n+class Exception : Throwable\n+{\n+    this(string )\n+    {\n+    }\n+}\n+\n+class Error { }\n+\n+void test23431()\n+{\n+    int a;\n+\n+    try\n+    {\n+        throw new Exception(\"test1\");\n+        a++;\n+    }\n+    finally\n+    {\n+    }\n+}"}, {"sha": "713267c0ecbc09e9897516f90f70a7f85bd8e5fd", "filename": "gcc/testsuite/gdc.test/compilable/test23433.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23433.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23433.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23433.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,16 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23433\n+module object;\n+\n+class Throwable { }\n+class Exception : Throwable { this(immutable(char)[]) { } }\n+\n+void test23433()\n+{\n+    try\n+    {\n+        throw new Exception(\"ice\");\n+    }\n+    finally\n+    {\n+    }\n+}"}, {"sha": "eba292ce19f33d51b42e015ad338821cc8e804a8", "filename": "gcc/testsuite/gdc.test/compilable/test23439.d", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23439.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23439.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23439.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,8 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23439\n+// PERMUTE_ARGS: -lowmem\n+class C23439\n+{\n+    noreturn f23439;\n+}\n+\n+__gshared ice23439 = new C23439();"}, {"sha": "f76a692b8b5a4b4ba842475dde742bc7517c5ce6", "filename": "gcc/testsuite/gdc.test/compilable/test23534.d", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23534.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23534.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23534.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,6 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23534\n+\n+enum E { a = 1, b = 2 }\n+\n+// `E.a` is not 0\n+static assert(!__traits(isZeroInit, E));"}, {"sha": "d7753cae546604e50cc51abfc89a6a29b3e01494", "filename": "gcc/testsuite/gdc.test/compilable/test4375.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest4375.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest4375.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest4375.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -202,7 +202,7 @@ label1:\n             assert(78);\n         else\n             assert(79);\n-        false; false\n+        false;\n     )\n         if (true)\n             assert(80);"}, {"sha": "eeba627dcd636a4ee436582290a1f6b1462728ac", "filename": "gcc/testsuite/gdc.test/compilable/vgc2.d", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fvgc2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fvgc2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fvgc2.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -93,8 +93,7 @@ void testAssocArray()\n /*\n TEST_OUTPUT:\n ---\n-compilable/vgc2.d(102): vgc: indexing an associative array may cause a GC allocation\n-compilable/vgc2.d(103): vgc: indexing an associative array may cause a GC allocation\n+compilable/vgc2.d(101): vgc: assigning an associative array element may cause a GC allocation\n ---\n */\n void testIndex(int[int] aa)"}, {"sha": "f9b535ab8d70a7401f9d30a92dcb0496457f8b73", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag14818.d", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14818.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14818.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14818.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1,11 +1,17 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag14818.d(34): Error: none of the overloads of `func` are callable using argument types `(string)`\n-fail_compilation/diag14818.d(12):        Candidate is: `diag14818.foo(int _param_0)`\n-fail_compilation/diag14818.d(13):                        `diag14818.bar(double _param_0)`\n-fail_compilation/diag14818.d(35): Error: overload alias `diag14818.X` does not match any template declaration\n-fail_compilation/diag14818.d(36): Error: overloadset `diag14818.M` does not match any template declaration\n+fail_compilation/diag14818.d(40): Error: none of the overloads of `func` are callable using argument types `(string)`\n+fail_compilation/diag14818.d(18):        Candidates are: `diag14818.foo(int _param_0)`\n+fail_compilation/diag14818.d(19):                        `diag14818.bar(double _param_0)`\n+fail_compilation/diag14818.d(41): Error: template instance `diag14818.X!string` does not match any template declaration\n+fail_compilation/diag14818.d(41):        Candidates are:\n+fail_compilation/diag14818.d(24):        Foo(T) if (is(T == int))\n+fail_compilation/diag14818.d(25):        Bar(T) if (is(T == double))\n+fail_compilation/diag14818.d(42): Error: template instance `diag14818.Y!string` does not match any template declaration\n+fail_compilation/diag14818.d(42):        Candidates are:\n+fail_compilation/diag14818.d(25):        Bar(T) if (is(T == double))\n+fail_compilation/diag14818.d(24):        Foo(T) if (is(T == int))\n ---\n */\n "}, {"sha": "9644fdd224209c5bcdc15fa06d53a19f780e673d", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag8101.d", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/diag8101.d(57): Error: function `diag8101.f_0(int)` is not callable using argument types `()`\n-fail_compilation/diag8101.d(57):        too few arguments, expected `1`, got `0`\n+fail_compilation/diag8101.d(57):        too few arguments, expected 1, got 0\n fail_compilation/diag8101.d(58): Error: none of the overloads of `f_1` are callable using argument types `()`\n fail_compilation/diag8101.d(33):        Candidates are: `diag8101.f_1(int)`\n fail_compilation/diag8101.d(34):                        `diag8101.f_1(int, int)`\n@@ -62,3 +62,6 @@ void main()\n     t_1();\n     t_2();\n }\n+\n+// ignored\n+deprecated void f_2(char);"}, {"sha": "f00f91a1fc81c3fc0799d01576a1c0112689411f", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag_funclit.d", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag_funclit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag_funclit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag_funclit.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -2,19 +2,19 @@\n TEST_OUTPUT:\n ---\n fail_compilation/diag_funclit.d(103): Error: function literal `__lambda1(x, y, z)` is not callable using argument types `()`\n-fail_compilation/diag_funclit.d(103):        too few arguments, expected `3`, got `0`\n+fail_compilation/diag_funclit.d(103):        too few arguments, expected 3, got 0\n fail_compilation/diag_funclit.d(106): Error: function literal `__lambda2(x, y, z)` is not callable using argument types `(int, string, int, int)`\n-fail_compilation/diag_funclit.d(106):        too many arguments, expected `3`, got `4`\n+fail_compilation/diag_funclit.d(106):        too many arguments, expected 3, got 4\n fail_compilation/diag_funclit.d(108): Error: function literal `__lambda3(x, y, string z = \"Hello\")` is not callable using argument types `(int, int, string, string)`\n-fail_compilation/diag_funclit.d(108):        too many arguments, expected `3`, got `4`\n+fail_compilation/diag_funclit.d(108):        too many arguments, expected 3, got 4\n fail_compilation/diag_funclit.d(110): Error: function literal `__lambda4(x, y, string z = \"Hello\")` is not callable using argument types `(int)`\n-fail_compilation/diag_funclit.d(110):        too few arguments, expected `3`, got `1`\n+fail_compilation/diag_funclit.d(110):        too few arguments, expected 3, got 1\n fail_compilation/diag_funclit.d(112): Error: function literal `__lambda5(x, y, z)` is not callable using argument types `(int)`\n-fail_compilation/diag_funclit.d(112):        too few arguments, expected `3`, got `1`\n+fail_compilation/diag_funclit.d(112):        too few arguments, expected 3, got 1\n fail_compilation/diag_funclit.d(115): Error: function literal `__lambda6(x, y, ...)` is not callable using argument types `(int)`\n-fail_compilation/diag_funclit.d(115):        too few arguments, expected `2`, got `1`\n+fail_compilation/diag_funclit.d(115):        too few arguments, expected 2, got 1\n fail_compilation/diag_funclit.d(117): Error: function literal `__lambda7(x, y, string z = \"Hey\", ...)` is not callable using argument types `(int)`\n-fail_compilation/diag_funclit.d(117):        too few arguments, expected `3`, got `1`\n+fail_compilation/diag_funclit.d(117):        too few arguments, expected 3, got 1\n ---\n  */\n "}, {"sha": "0d1f8f14fea24b19e4f3f4bdbeeeb15c4fb84c5b", "filename": "gcc/testsuite/gdc.test/fail_compilation/diagin.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiagin.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiagin.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiagin.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -3,7 +3,7 @@ PERMUTE_ARGS: -preview=in\n TEST_OUTPUT:\n ---\n fail_compilation/diagin.d(14): Error: function `diagin.foo(in int)` is not callable using argument types `()`\n-fail_compilation/diagin.d(14):        too few arguments, expected `1`, got `0`\n+fail_compilation/diagin.d(14):        too few arguments, expected 1, got 0\n fail_compilation/diagin.d(16): Error: none of the overloads of template `diagin.foo1` are callable using argument types `!()(bool[])`\n fail_compilation/diagin.d(20):        Candidate is: `foo1(T)(in T v, string)`\n ---"}, {"sha": "7b082aea4a76ddd69d833b3210afcf05632de39b", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail12.d", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail12.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail12.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail12.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1,7 +1,9 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail12.d(17): Error: function `fail12.main.Foo!(y).abc` at fail_compilation/fail12.d(9) conflicts with function `fail12.main.Foo!(y).abc` at fail_compilation/fail12.d(9)\n+fail_compilation/fail12.d(19): Error: `abc` matches conflicting symbols:\n+fail_compilation/fail12.d(11):        function `fail12.main.Foo!(y).abc`\n+fail_compilation/fail12.d(11):        function `fail12.main.Foo!(y).abc`\n ---\n */\n template Foo(alias b)"}, {"sha": "1fb6e23aedbb018510b2345f1364f677ea4de948", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail15414.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15414.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15414.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15414.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,21 @@\n+// https://issues.dlang.org/show_bug.cgi?id=15414\n+\n+// REQUIRED_ARGS: -de\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail15414.d(20): Deprecation: `__traits(getAttributes)` may only be used for individual functions, not overload sets such as: `fun`\n+fail_compilation/fail15414.d(20):        the result of `__traits(getOverloads)` may be used to select the desired function to extract attributes from\n+---\n+*/\n+\n+@(\"gigi\")\n+void fun() {}\n+@(\"mimi\")\n+void fun(int) {}\n+\n+void main()\n+{\n+    auto t =  __traits(getAttributes, fun);\n+}"}, {"sha": "4b209685ca4435811a3d75665c620867fffb17c8", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail15616b.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15616b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15616b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15616b.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -22,7 +22,6 @@ fail_compilation/fail15616b.d(26):                        `foo(T)(T a)`\n   `~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`\n `  > is(T == char)\n `  `~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`\n-fail_compilation/fail15616b.d(44):        All possible candidates are marked as `deprecated` or `@disable`\n   Tip: not satisfied constraints are marked with `>`\n ---\n */"}, {"sha": "edc463018db7f14a9ed04095ea9cdb066f9fb646", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail1900.d", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail1900.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail1900.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail1900.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -30,7 +30,9 @@ void test1900a()\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail1900.d(42): Error: template `imports.fail1900b.Bar(short n)` at fail_compilation/imports/fail1900b.d(2) conflicts with template `imports.fail1900a.Bar(int n)` at fail_compilation/imports/fail1900a.d(2)\n+fail_compilation/fail1900.d(44): Error: `Bar` matches conflicting symbols:\n+fail_compilation/imports/fail1900b.d(2):        template `imports.fail1900b.Bar(short n)`\n+fail_compilation/imports/fail1900a.d(2):        template `imports.fail1900a.Bar(int n)`\n ---\n */\n \n@@ -45,7 +47,9 @@ void test1900b()\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail1900.d(66): Error: template `fail1900.Mix2b!().Baz(int x)` at fail_compilation/fail1900.d(58) conflicts with template `fail1900.Mix2a!().Baz(byte x)` at fail_compilation/fail1900.d(54)\n+fail_compilation/fail1900.d(70): Error: `Baz` matches conflicting symbols:\n+fail_compilation/fail1900.d(62):        template `fail1900.Mix2b!().Baz(int x)`\n+fail_compilation/fail1900.d(58):        template `fail1900.Mix2a!().Baz(byte x)`\n ---\n */\n "}, {"sha": "675ba831ef6103a9f5f8a6710984cea00fd95291", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22366.d", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22366.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22366.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22366.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1,15 +1,33 @@\n-// REQUIRED_ARGS: -dip1000\n-\n /*\n+REQUIRED_ARGS: -preview=dip1000\n TEST_OUTPUT:\n ---\n-fail_compilation/fail22366.d(13): Error: scope variable `x` may not be copied into allocated memory\n+fail_compilation/fail22366.d(22): Error: scope variable `s` may not be copied into allocated memory\n+fail_compilation/fail22366.d(25): Error: scope variable `s` may not be copied into allocated memory\n+fail_compilation/fail22366.d(26): Error: scope variable `s` may not be copied into allocated memory\n+fail_compilation/fail22366.d(27): Error: scope variable `s` may not be copied into allocated memory\n+fail_compilation/fail22366.d(28): Error: scope variable `s` may not be copied into allocated memory\n+fail_compilation/fail22366.d(31): Error: scope variable `s` may not be copied into allocated memory\n+fail_compilation/fail22366.d(32): Error: scope variable `s` may not be copied into allocated memory\n ---\n */\n \n-int* fun(scope int* x) @safe\n+// Test escaping scope variables through AA keys / values\n+// https://issues.dlang.org/show_bug.cgi?id=22366\n+// https://issues.dlang.org/show_bug.cgi?id=23531\n+\n+void fun(scope string s) @safe\n {\n-    int*[int] aa;\n-    aa[0] = x; // should give an error\n-    return aa[0];\n+    int[string] aa;\n+    aa[s] ^^= 3;\n+\n+    string[string] saa;\n+    saa[\"\"] = s;\n+    saa[\"\"] ~= s;\n+    saa[s] = \"\";\n+    saa[s] ~= \"\";\n+\n+    string[string][string] snaa;\n+    snaa[s][\"\"] = \"\";\n+    snaa[\"\"][s] = \"\";\n }"}, {"sha": "b070e581a4a72c6c0bf6ef8befc1327bedccf6dc", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail23439.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23439.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23439.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23439.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,13 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23439\n+// PERMUTE_ARGS: -lowmem\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/fail23439.d(13): Error: variable `fail23439.ice23439` is a thread-local class and cannot have a static initializer. Use `static this()` to initialize instead.\n+---\n+*/\n+class C23439\n+{\n+    noreturn f23439;\n+}\n+\n+static ice23439 = new C23439();"}, {"sha": "31dd065268702f1fde2346ff6fb9bd689a1d3514", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail320.d", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail320.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail320.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail320.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -2,10 +2,15 @@\n EXTRA_FILES: imports/fail320a.d imports/fail320b.d\n TEST_OUTPUT:\n ---\n-fail_compilation/fail320.d(11): Error: no overload matches for `foo`\n+fail_compilation/fail320.d(16): Error: no overload matches for `foo(\"\")`\n+fail_compilation/fail320.d(16):        Candidates are:\n+fail_compilation/imports/fail320b.d(1):        foo(T)(string)\n+fail_compilation/imports/fail320b.d(2):        foo(alias a)()\n+fail_compilation/imports/fail320a.d(1):        foo(int)\n+fail_compilation/imports/fail320a.d(2):        foo(bool)\n ---\n */\n \n import imports.fail320a;\n import imports.fail320b;\n-void main() { foo(); }\n+void main() { foo(\"\"); }"}, {"sha": "e232523ed6511b3f2a864fdbba247c2ae94dae82", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail54.d", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail54.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail54.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail54.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1,7 +1,12 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail54.d(22): Error: incompatible types for `(0) == (Exception)`: cannot use `==` with types\n+fail_compilation/fail54.d(27): Error: incompatible types for `(0) == (Exception)`: cannot use `==` with types\n+fail_compilation/fail54.d(28): Error: incompatible types for `(\"\") == (int)`: cannot use `==` with types\n+fail_compilation/fail54.d(29): Error: incompatible types for `(true) == (int)`: cannot use `==` with types\n+fail_compilation/fail54.d(29):        while evaluating: `static assert(true == (int))`\n+fail_compilation/fail54.d(30): Error: incompatible types for `(true) == (int[string])`: cannot use `==` with types\n+fail_compilation/fail54.d(30):        while evaluating: `static assert(true == (int[string]))`\n ---\n */\n \n@@ -20,4 +25,7 @@ module dstress.nocompile.bug_mtype_507_C;\n void test()\n {\n     0 == Exception;\n+    \"\" == int;\n+    static assert(is(int) == int);\n+    static assert(is(int[string]) == int[string]);\n }"}, {"sha": "a12fa3f4cc6905decf9e8891588f18a23c3042a0", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail99.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail99.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail99.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail99.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/fail99.d(13): Error: delegate `dg(int)` is not callable using argument types `()`\n-fail_compilation/fail99.d(13):        too few arguments, expected `1`, got `0`\n+fail_compilation/fail99.d(13):        too few arguments, expected 1, got 0\n ---\n */\n "}, {"sha": "c3c735ed552f190e253c5d431874be7c66f814d5", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail_arrayop2.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_arrayop2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_arrayop2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_arrayop2.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -327,6 +327,7 @@ fail_compilation/fail_arrayop2.d(342): Error: array operation `[1] * 6` without\n fail_compilation/fail_arrayop2.d(345): Error: array operation `[1] * 6` without destination memory not allowed\n fail_compilation/fail_arrayop2.d(348): Error: array operation `[1] * 6` without destination memory not allowed\n fail_compilation/fail_arrayop2.d(349): Error: array operation `[1] * 6` without destination memory not allowed\n+fail_compilation/fail_arrayop2.d(350): Deprecation: `[1] * 6` has no effect\n fail_compilation/fail_arrayop2.d(350): Error: array operation `[1] * 6` without destination memory not allowed\n fail_compilation/fail_arrayop2.d(353): Error: array operation `[1] * 6` without destination memory not allowed\n fail_compilation/fail_arrayop2.d(356): Error: array operation `[1] * 6` without destination memory not allowed\n@@ -336,8 +337,7 @@ fail_compilation/fail_arrayop2.d(367): Error: `\"uvt\"[] - '\\x01'` cannot be inter\n ---\n */\n // Test all statements, which can take arrays as their operands.\n-void test15407stmt()\n-{\n+void test15407stmt() {\n     // ExpStatement - exp\n     [1] * 6;\n "}, {"sha": "e9533c04c698069db779068d10730afb0e53c8ea", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail_pretty_errors.d", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_pretty_errors.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_pretty_errors.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_pretty_errors.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -2,16 +2,20 @@\n REQUIRED_ARGS: -verrors=context\n TEST_OUTPUT:\n ---\n-fail_compilation/fail_pretty_errors.d(20): Error: undefined identifier `a`\n+fail_compilation/fail_pretty_errors.d(24): Error: undefined identifier `a`\n     a = 1;\n     ^\n-fail_compilation/fail_pretty_errors.d-mixin-25(25): Error: undefined identifier `b`\n-fail_compilation/fail_pretty_errors.d(30): Error: cannot implicitly convert expression `5` of type `int` to `string`\n+fail_compilation/fail_pretty_errors.d-mixin-29(29): Error: undefined identifier `b`\n+fail_compilation/fail_pretty_errors.d(34): Error: cannot implicitly convert expression `5` of type `int` to `string`\n     string x = 5;\n                ^\n-fail_compilation/fail_pretty_errors.d(35): Error: mixin `fail_pretty_errors.testMixin2.mixinTemplate!()` error instantiating\n+fail_compilation/fail_pretty_errors.d(39): Error: mixin `fail_pretty_errors.testMixin2.mixinTemplate!()` error instantiating\n     mixin mixinTemplate;\n     ^\n+fail_compilation/fail_pretty_errors.d(45): Error: invalid array operation `\"\" + \"\"` (possible missing [])\n+    auto x = \"\"+\"\";\n+             ^\n+fail_compilation/fail_pretty_errors.d(45):        did you mean to concatenate (`\"\" ~ \"\"`) instead ?\n ---\n */\n \n@@ -34,3 +38,9 @@ void testMixin2()\n {\n     mixin mixinTemplate;\n }\n+\n+void f()\n+{\n+    // check supplemental error doesn't show context\n+    auto x = \"\"+\"\";\n+}"}, {"sha": "e76d4ac050ddc11db9af868dc23cb163c91fbcc3", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice10922.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10922.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10922.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10922.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/ice10922.d(10): Error: function `ice10922.__lambda4(in uint n)` is not callable using argument types `()`\n-fail_compilation/ice10922.d(10):        too few arguments, expected `1`, got `0`\n+fail_compilation/ice10922.d(10):        too few arguments, expected 1, got 0\n ---\n */\n "}, {"sha": "d34fc60db6a49f71b0aeb07d5039bb22d9c125ea", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice13459.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice13459.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice13459.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice13459.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -3,7 +3,7 @@ TEST_OUTPUT:\n ---\n fail_compilation/ice13459.d(12): Error: undefined identifier `B`\n fail_compilation/ice13459.d(18): Error: none of the overloads of `opSlice` are callable using argument types `(int, int)`\n-fail_compilation/ice13459.d(11):        Candidates are: `ice13459.A.opSlice()`\n+fail_compilation/ice13459.d(11):        Candidate is: `ice13459.A.opSlice()`\n ---\n */\n struct A"}, {"sha": "5276e83c72294caedd840b170ae5989e3114060d", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice9540.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice9540.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice9540.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice9540.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/ice9540.d(35): Error: function `ice9540.A.test.AddFront!(this, f).AddFront.dg(int _param_0)` is not callable using argument types `()`\n-fail_compilation/ice9540.d(35):        too few arguments, expected `1`, got `0`\n+fail_compilation/ice9540.d(35):        too few arguments, expected 1, got 0\n fail_compilation/ice9540.d(26): Error: template instance `ice9540.A.test.AddFront!(this, f)` error instantiating\n ---\n */"}, {"sha": "d9e700d2e6a59f22922f670a495a2361938db8cc", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/fail320a.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ffail320a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ffail320a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ffail320a.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1 +1,2 @@\n void foo(int) { }\n+void foo(bool) { }"}, {"sha": "b65463fddd0406c3f818d5a2e828172b33b60aa2", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/fail320b.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ffail320b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ffail320b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ffail320b.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1 +1,2 @@\n-void foo(T)(){}\n+void foo(T)(string){}\n+void foo(alias a)(){}"}, {"sha": "526b7704c88afa2ecc3d3d840dab1edb13f8e591", "filename": "gcc/testsuite/gdc.test/fail_compilation/lexer23465.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Flexer23465.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Flexer23465.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Flexer23465.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,21 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/lexer23465.d(19): Error: char 0x1f37a not allowed in identifier\n+fail_compilation/lexer23465.d(19): Error: character 0x1f37a is not a valid token\n+fail_compilation/lexer23465.d(20): Error: character '\\' is not a valid token\n+fail_compilation/lexer23465.d(21): Error: unterminated /+ +/ comment\n+fail_compilation/lexer23465.d(22): Error: found `End of File` instead of array initializer\n+fail_compilation/lexer23465.d(22): Error: semicolon needed to end declaration of `arr`, instead of `End of File`\n+fail_compilation/lexer23465.d(17):        `arr` declared here\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23465\n+// Invalid token error points to wrong line\n+\n+int[] arr = [\n+\t0,\n+    x\ud83c\udf7a,\n+    3\\,\n+    5, /+"}, {"sha": "21d02cdae4492c1890bfc9c7b19f4672f958a6d8", "filename": "gcc/testsuite/gdc.test/fail_compilation/misc1.d", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmisc1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmisc1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmisc1.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -3,6 +3,11 @@ TEST_OUTPUT:\n ---\n fail_compilation/misc1.d(108): Error: `5` has no effect\n fail_compilation/misc1.d(109): Error: `1 + 2` has no effect\n+fail_compilation/misc1.d(115): Deprecation: `1 * 1` has no effect\n+fail_compilation/misc1.d(116): Deprecation: `__lambda3` has no effect\n+fail_compilation/misc1.d(122): Deprecation: `false` has no effect\n+fail_compilation/misc1.d(125): Deprecation: `*sp++` has no effect\n+fail_compilation/misc1.d(126): Deprecation: `j` has no effect\n ---\n */\n \n@@ -18,3 +23,20 @@ void issue12490()\n     5, hasSideEffect12490();\n     1 + 2, hasSideEffect12490();\n }\n+\n+void issue23480()\n+{\n+    int j;\n+    for({} j; 1*1) {}\n+    for({j=2; int d = 3;} j+d<7; {j++; d++;}) {}\n+    for (\n+        if (true)        // (o_O)\n+            assert(78);\n+        else\n+            assert(79);\n+        false; false\n+    ) {}\n+    // unnecessary deref\n+    for (ubyte* sp; 0; *sp++) {}\n+    for (;; j) {}\n+}"}, {"sha": "9016dd9e9696d6af4f8ae5228f4f30b37002e1b9", "filename": "gcc/testsuite/gdc.test/fail_compilation/nogc2.d", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnogc2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnogc2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnogc2.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -92,8 +92,7 @@ fail_compilation/nogc2.d(87): Error: associative array literal in `@nogc` functi\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/nogc2.d(101): Error: indexing an associative array in `@nogc` function `nogc2.testIndex` may cause a GC allocation\n-fail_compilation/nogc2.d(102): Error: indexing an associative array in `@nogc` function `nogc2.testIndex` may cause a GC allocation\n+fail_compilation/nogc2.d(100): Error: assigning an associative array element in `@nogc` function `nogc2.testIndex` may cause a GC allocation\n ---\n */\n @nogc void testIndex(int[int] aa)"}, {"sha": "7bc5e96bef81c673b0a9fae48fb7603cc00bbb37", "filename": "gcc/testsuite/gdc.test/fail_compilation/retscope.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -454,7 +454,7 @@ fail_compilation/retscope.d(1311): Error: scope variable `u2` assigned to `ek` w\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/retscope.d(1405): Error: reference to local variable `buf` assigned to non-scope parameter `__anonymous_param` calling `myprintf`\n+fail_compilation/retscope.d(1405): Error: reference to local variable `buf` assigned to non-scope anonymous parameter calling `myprintf`\n ---\n */\n \n@@ -472,7 +472,7 @@ fail_compilation/retscope.d(1405): Error: reference to local variable `buf` assi\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/retscope.d(1509): Error: reference to stack allocated value returned by `(*fp15)()` assigned to non-scope parameter `__anonymous_param`\n+fail_compilation/retscope.d(1509): Error: reference to stack allocated value returned by `(*fp15)()` assigned to non-scope anonymous parameter\n ---\n */\n "}, {"sha": "829fb6a19709a3ed8f4373cd9382c1aba53cc3f6", "filename": "gcc/testsuite/gdc.test/fail_compilation/retscope2.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope2.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -86,8 +86,8 @@ fail_compilation/retscope2.d(504): Error: scope variable `c` may not be returned\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/retscope2.d(604): Error: scope variable `_param_0` assigned to non-scope parameter `__anonymous_param` calling `foo600`\n-fail_compilation/retscope2.d(604): Error: scope variable `_param_1` assigned to non-scope parameter `__anonymous_param` calling `foo600`\n+fail_compilation/retscope2.d(604): Error: scope variable `_param_0` assigned to non-scope anonymous parameter calling `foo600`\n+fail_compilation/retscope2.d(604): Error: scope variable `_param_1` assigned to non-scope anonymous parameter calling `foo600`\n fail_compilation/retscope2.d(614): Error: template instance `retscope2.test600!(int*, int*)` error instantiating\n ---\n */"}, {"sha": "420e0b8b31f5c48430181a2e9f59ff0aa0066235", "filename": "gcc/testsuite/gdc.test/fail_compilation/templateoverload.d", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftemplateoverload.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftemplateoverload.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftemplateoverload.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,22 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/templateoverload.d(17): Error: template instance `T!1` does not match any template declaration\n+fail_compilation/templateoverload.d(17):        Candidates are:\n+fail_compilation/templateoverload.d(14):        T(X)\n+fail_compilation/templateoverload.d(15):        T()\n+fail_compilation/templateoverload.d(22): Error: template instance `V!int` does not match any template declaration\n+fail_compilation/templateoverload.d(22):        Candidates are:\n+fail_compilation/templateoverload.d(19):        V(int i)\n+fail_compilation/templateoverload.d(20):        V(T, alias a)\n+---\n+*/\n+template T(X) {}\n+template T() {}\n+\n+alias t = T!1;\n+\n+template V(int i) {}\n+template V(T, alias a) {}\n+\n+alias v = V!int;"}, {"sha": "c9d0e08f6e0e6f65fc63c304c68f8871f595f337", "filename": "gcc/testsuite/gdc.test/fail_compilation/test19646.d", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest19646.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest19646.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest19646.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1,11 +1,17 @@\n /* TEST_OUTPUT:\n ---\n fail_compilation/test19646.d(11): Error: cast from `const(int)*` to `int*` not allowed in safe code\n+fail_compilation/test19646.d(17): Error: `@safe` variable `z` cannot be initialized by calling `@system` function `f`\n ---\n https://issues.dlang.org/show_bug.cgi?id=19646\n  */\n \n @safe:\n-\n const x = 42;\n int* y = cast(int*)&x;\n+\n+@system:\n+\n+@system int* f() { return cast(int*) 0xDEADBEEF; };\n+\n+@safe int* z = f();"}, {"sha": "641c802c2546c261de0fce6c5457bd4308ea974b", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21008.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21008.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21008.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21008.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -5,12 +5,12 @@ fail_compilation/test21008.d(110): Error: function `test21008.C.after` circular\n fail_compilation/test21008.d(117): Error: need `this` for `toString` of type `string()`\n fail_compilation/test21008.d(117): Error: need `this` for `toHash` of type `nothrow @trusted $?:32=uint|64=ulong$()`\n fail_compilation/test21008.d(117): Error: function `object.Object.opCmp(Object o)` is not callable using argument types `()`\n-fail_compilation/test21008.d(117):        too few arguments, expected `1`, got `0`\n+fail_compilation/test21008.d(117):        too few arguments, expected 1, got 0\n fail_compilation/test21008.d(117): Error: function `object.Object.opEquals(Object o)` is not callable using argument types `()`\n-fail_compilation/test21008.d(117):        too few arguments, expected `1`, got `0`\n+fail_compilation/test21008.d(117):        too few arguments, expected 1, got 0\n fail_compilation/test21008.d(117): Error: `Monitor` has no effect\n fail_compilation/test21008.d(117): Error: function `object.Object.factory(string classname)` is not callable using argument types `()`\n-fail_compilation/test21008.d(117):        too few arguments, expected `1`, got `0`\n+fail_compilation/test21008.d(117):        too few arguments, expected 1, got 0\n fail_compilation/test21008.d(105):        called from here: `handleMiddlewareAnnotation()`\n fail_compilation/test21008.d(108): Error: class `test21008.C` no size because of forward reference\n ---"}, {"sha": "5ab530737339f25cff8840a4edb20cdc8d15c605", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21062.d", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21062.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21062.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21062.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,24 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test21062.d(16): Error: no identifier for declarator `bool`\n+fail_compilation/test21062.d(16):        `synchronized` is a keyword, perhaps append `_` to make it an identifier\n+fail_compilation/test21062.d(17): Error: no identifier for declarator `ubyte*`\n+fail_compilation/test21062.d(17):        `out` is a keyword, perhaps append `_` to make it an identifier\n+fail_compilation/test21062.d(21): Error: no identifier for declarator `uint`\n+fail_compilation/test21062.d(21):        `in` is a keyword, perhaps append `_` to make it an identifier\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=21062\n+// Confusing error when using a keyword as an identifier for a declaration\n+\n+bool synchronized;\n+ubyte* out;\n+\n+void main()\n+{\n+    foreach(uint in; [])\n+    {\n+    }\n+}"}, {"sha": "b66d8a860d0e2bcae736bdbbc04400da5a8a550c", "filename": "gcc/testsuite/gdc.test/fail_compilation/test23491.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23491.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23491.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23491.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,19 @@\n+/**\n+REQUIRED_ARGS: -preview=dip1000\n+TEST_OUTPUT:\n+---\n+fail_compilation/test23491.d(16): Error: reference to local variable `buffer` assigned to non-scope anonymous parameter\n+fail_compilation/test23491.d(17): Error: reference to local variable `buffer` assigned to non-scope anonymous parameter calling `sinkF`\n+fail_compilation/test23491.d(18): Error: reference to local variable `buffer` assigned to non-scope parameter `buf`\n+---\n+*/\n+\n+void sinkF(char[]) @safe;\n+\n+void toString(void delegate (char[]) @safe sink, void delegate(char[] buf) @safe sinkNamed) @safe\n+{\n+    char[20] buffer = void;\n+    sink(buffer[]);\n+\tsinkF(buffer[]);\n+\tsinkNamed(buffer[]);\n+}"}, {"sha": "fa1740bebad86c4edb4cc16484f75254bb999250", "filename": "gcc/testsuite/gdc.test/fail_compilation/test23536.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23536.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23536.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23536.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,19 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/test23536.d(104): Error: function `test23536.S.nonctor` cannot be a non-static member function for `pragma(crt_constructor)`\n+fail_compilation/test23536.d(106): Error: function `test23536.S.nondtor` cannot be a non-static member function for `pragma(crt_destructor)`\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23536\n+\n+#line 100\n+\n+struct S\n+{\n+    int x;\n+    extern (C) pragma(crt_constructor)        void nonctor() { } // should not compile\n+    extern (C) pragma(crt_constructor) static void stactor() { } // should compile\n+    extern (C) pragma(crt_destructor)         void nondtor() { } // should not compile\n+    extern (C) pragma(crt_destructor)  static void stadtor() { } // should compile\n+}"}, {"sha": "b1216ce682f9d8307eaa7f14f8f8502f5ddc894e", "filename": "gcc/testsuite/gdc.test/fail_compilation/throwexp.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fthrowexp.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fthrowexp.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fthrowexp.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,12 @@\n+/+ TEST_OUTPUT:\n+---\n+fail_compilation/throwexp.d(11): Error: to be thrown `ret()` must be non-null\n+fail_compilation/throwexp.d(12): Error: to be thrown `null` must be non-null\n+---\n++/\n+auto ret()\n+{\n+    return Exception.init;\n+}\n+enum y = throw ret();\n+enum x = throw Exception.init;"}, {"sha": "55520ba69c268a2eb905c8af78ded213cf4c206c", "filename": "gcc/testsuite/gdc.test/fail_compilation/warn14905.d", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f509d3c0b3ab63891cf7ca2def0fdfb3642c4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fwarn14905.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f509d3c0b3ab63891cf7ca2def0fdfb3642c4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fwarn14905.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fwarn14905.d?ref=cc7f509d3c0b3ab63891cf7ca2def0fdfb3642c4", "patch": "@@ -1,23 +0,0 @@\n-// REQUIRED_ARGS: -o- -w\n-\n-/*\n-TEST_OUTPUT:\n----\n-fail_compilation/warn14905.d(16): Warning: statement is not reachable in template instance warn14905.fun!\"a\".fun\n-fail_compilation/warn14905.d(16): Warning: statement is not reachable in template instance warn14905.fun!\"b\".fun\n-Error: warnings are treated as errors\n-       Use -wi if you wish to treat warnings only as informational.\n----\n-*/\n-\n-bool fun(string s)()\n-{\n-    return true;\n-    return false;\n-}\n-\n-void main()\n-{\n-    cast(void)fun!\"a\";\n-    cast(void)fun!\"b\";\n-}"}, {"sha": "c6ca550011bae05556353f2b153b05b6af5903b9", "filename": "gcc/testsuite/gdc.test/runnable/lexer.d", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flexer.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -2,8 +2,8 @@\n /*\n TEST_OUTPUT:\n ---\n-runnable/lexer.d(81): Deprecation: `version( <integer> )` is deprecated, use version identifiers instead\n-runnable/lexer.d(82): Deprecation: `debug( <integer> )` is deprecated, use debug identifiers instead\n+runnable/lexer.d(86): Deprecation: `version( <integer> )` is deprecated, use version identifiers instead\n+runnable/lexer.d(87): Deprecation: `debug( <integer> )` is deprecated, use debug identifiers instead\n ---\n */\n \n@@ -36,6 +36,11 @@ HERE\";\n     //writefln(\"'%s'\", s);\n     assert(s == \"foo\\n\");\n \n+    // https://issues.dlang.org/show_bug.cgi?id=19623\n+    s = q\"\u00fcbel\n+foo\n+\u00fcbel\";\n+    assert(s == \"foo\\n\");\n \n     s = q{ foo(xxx) };\n     assert(s ==\" foo(xxx) \");"}, {"sha": "073fd63c68acaefa54106cdc36322fe804c2231c", "filename": "gcc/testsuite/gdc.test/runnable/test21301.d", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21301.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21301.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21301.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,116 @@\n+/* RUN_OUTPUT:\n+---\n+int   AAAA0000\n+int   AAAA0001\n+int   AAAA0002\n+int   AAAA0003\n+float FFFF0004\n+float FFFF0005\n+float FFFF0006\n+float FFFF0007\n+float FFFF0008\n+float FFFF0009\n+float FFFF0010\n+float FFFF0011\n+float FFFF0012\n+float FFFF0013\n+float FFFF0014\n+float FFFF0015\n+int   AAAA0016\n+int   AAAA0017\n+int   AAAA0018\n+int   AAAA0019\n+int   AAAA0020\n+int   AAAA0021\n+---\n+ */\n+\n+// https://issues.dlang.org/show_bug.cgi?id=21301\n+\n+//extern (C)\n+void func(\n+    int p0, int[3] p1, float[3] p2, float p3, float p4, float p5, float p6, float p7,\n+    float p8, float p9, float p10, float p11, int p12, int[2] p13, int p14, int p15, int p16\n+) {\n+    print(p0);\n+\n+    print(p1[0]);\n+    print(p1[1]);\n+    print(p1[2]);\n+\n+    print(p2[0]);\n+    print(p2[1]);\n+    print(p2[2]);\n+\n+    print(p3);\n+    print(p4);\n+    print(p5);\n+    print(p6);\n+    print(p7);\n+    print(p8);\n+    print(p9);\n+    print(p10);\n+    print(p11);\n+    print(p12);\n+    print(p13[0]);\n+    print(p13[1]);\n+    print(p14);\n+    print(p15);\n+    print(p16);\n+}\n+\n+static if (0)\n+{\n+void print(int x);\n+void print(float x);\n+}\n+else\n+{\n+import core.stdc.stdio;\n+\n+union U\n+{\n+    int[22] i = [\n+        0xAAAA_0000,\n+        0xAAAA_0001,\n+        0xAAAA_0002,\n+        0xAAAA_0003,\n+        0xFFFF_0004,\n+        0xFFFF_0005,\n+        0xFFFF_0006,\n+        0xFFFF_0007,\n+        0xFFFF_0008,\n+        0xFFFF_0009,\n+        0xFFFF_0010,\n+        0xFFFF_0011,\n+        0xFFFF_0012,\n+        0xFFFF_0013,\n+        0xFFFF_0014,\n+        0xFFFF_0015,\n+        0xAAAA_0016,\n+        0xAAAA_0017,\n+        0xAAAA_0018,\n+        0xAAAA_0019,\n+        0xAAAA_0020,\n+        0xAAAA_0021,\n+    ];\n+\n+    float[22] f;\n+}\n+\n+void print(int x) { printf(\"int   %08X\\n\", x); }\n+void print(float x) { printf(\"float %08X\\n\", *(cast(int*) &x)); }\n+\n+int main()\n+{\n+    func(U.init.i[0],\n+         [U.init.i[1], U.init.i[2], U.init.i[3]],\n+         [U.init.f[4], U.init.f[5], U.init.f[6]],\n+         U.init.f[7], U.init.f[8], U.init.f[9], U.init.f[10], U.init.f[11], U.init.f[12], U.init.f[13],\n+         U.init.f[14], U.init.f[15], U.init.i[16],\n+         [U.init.i[17], U.init.i[18]],\n+         U.init.i[19], U.init.i[20], U.init.i[21]\n+    );\n+    return 0;\n+}\n+}"}, {"sha": "8f3394d6700503a17c515ebd9f806a24c94a0b4e", "filename": "gcc/testsuite/gdc.test/runnable/test21506.d", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21506.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21506.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21506.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -0,0 +1,40 @@\n+/* RUN_OUTPUT:\n+---\n+value: -5\n+value: -5\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=21506\n+\n+import core.stdc.stdio;\n+import core.stdc.stdarg;\n+\n+extern(C++)\n+{\n+\n+void print(long a, va_list args){\n+    vprintf(\"value: %d\\n\", args);\n+}\n+void proxy0(long a, long b, long c, long d, bool e, ...){\n+    va_list ap;\n+    va_start(ap, e);\n+    print(a, ap);\n+    va_end(ap);\n+//  print(a, _argptr);\n+}\n+void proxy1(long d, bool e, ...){\n+    va_list ap;\n+    va_start(ap, e);\n+    print(d, ap);\n+    va_end(ap);\n+//  print(d, _argptr);\n+}\n+\n+}\n+\n+void main(){\n+    int var = -5;\n+    proxy0(1, 2, 3, 4, true, var);\n+    proxy1(4, true, var);\n+}"}, {"sha": "5ee6f624836281760931fd3b4e203389f14d3c16", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1,4 +1,4 @@\n-e4f89195913be1dc638707b1abb24c4f3ae7e0bf\n+c8ae4adb2eda515b09b326948e3a4aa9f489af45\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "869ade6482153acfdfce703d7b7e853d85b09841", "filename": "libphobos/libdruntime/core/demangle.d", "status": "modified", "additions": 92, "deletions": 9, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -24,6 +24,11 @@ else version (WatchOS)\n debug(trace) import core.stdc.stdio : printf;\n debug(info) import core.stdc.stdio : printf;\n \n+extern (C) alias CXX_DEMANGLER = char* function (const char* mangled_name,\n+                                                char* output_buffer,\n+                                                size_t* length,\n+                                                int* status) nothrow pure @trusted;\n+\n private struct NoHooks\n {\n     // supported hooks\n@@ -2115,19 +2120,22 @@ pure @safe:\n \n \n /**\n- * Demangles D mangled names.  If it is not a D mangled name, it returns its\n- * argument name.\n+ * Demangles D/C++ mangled names.  If it is not a D/C++ mangled name, it\n+ * returns its argument name.\n  *\n  * Params:\n  *  buf = The string to demangle.\n  *  dst = An optional destination buffer.\n+ *  __cxa_demangle = optional C++ demangler\n  *\n  * Returns:\n- *  The demangled name or the original string if the name is not a mangled D\n- *  name.\n+ *  The demangled name or the original string if the name is not a mangled\n+ *  D/C++ name.\n  */\n-char[] demangle(return scope const(char)[] buf, return scope char[] dst = null ) nothrow pure @safe\n+char[] demangle(return scope const(char)[] buf, return scope char[] dst = null, CXX_DEMANGLER __cxa_demangle = null) nothrow pure @safe\n {\n+    if (buf.length > 2 && buf[0..2] == \"_Z\")\n+        return demangleCXX(buf, __cxa_demangle, dst);\n     auto d = Demangle!()(buf, dst);\n     // fast path (avoiding throwing & catching exception) for obvious\n     // non-D mangled names\n@@ -2210,7 +2218,7 @@ char[] reencodeMangled(return scope const(char)[] mangled) nothrow pure @safe\n             }\n         }\n \n-        bool parseLName(scope ref Remangle d) scope\n+        bool parseLName(scope ref Remangle d) scope @trusted\n         {\n             flushPosition(d);\n \n@@ -2261,7 +2269,7 @@ char[] reencodeMangled(return scope const(char)[] mangled) nothrow pure @safe\n                 }\n                 else\n                 {\n-                    idpos[id] = refpos;\n+                    idpos[id] = refpos; //! scope variable id used as AA key, makes this function @trusted\n                     result ~= d.buf[refpos .. d.pos];\n                 }\n             }\n@@ -2706,8 +2714,10 @@ unittest\n     {\n         char[] buf = new char[i];\n         auto ds = demangle(s, buf);\n-        assert(ds == \"pure nothrow @safe char[] core.demangle.demangle(scope return const(char)[], scope return char[])\" ||\n-               ds == \"pure nothrow @safe char[] core.demangle.demangle(return scope const(char)[], return scope char[])\");\n+        assert(ds == \"pure nothrow @safe char[] core.demangle.demangle(scope return const(char)[], scope return char[], extern (C) char* function(const(char*), char*, ulong*, int*) pure nothrow @trusted*)\" ||\n+               ds == \"pure nothrow @safe char[] core.demangle.demangle(return scope const(char)[], return scope char[], extern (C) char* function(const(char*), char*, ulong*, int*) pure nothrow @trusted*)\" ||\n+               ds == \"pure nothrow @safe char[] core.demangle.demangle(scope return const(char)[], scope return char[], extern (C) char* function(const(char*), char*, uint*, int*) pure nothrow @trusted*)\" ||\n+               ds == \"pure nothrow @safe char[] core.demangle.demangle(return scope const(char)[], return scope char[], extern (C) char* function(const(char*), char*, uint*, int*) pure nothrow @trusted*)\", ds);\n     }\n }\n \n@@ -2901,3 +2911,76 @@ private string toStringConsume (immutable ManglingFlagInfo[] infos, ref ushort b\n     }\n     return null;\n }\n+\n+private shared CXX_DEMANGLER __cxa_demangle;\n+\n+/**\n+ * Returns:\n+ *  a CXX_DEMANGLER if a C++ stdlib is loaded\n+ */\n+\n+CXX_DEMANGLER getCXXDemangler() nothrow @trusted\n+{\n+    if (__cxa_demangle is null)\n+    version (Posix)\n+    {\n+        import core.sys.posix.dlfcn : dlsym;\n+        version (DragonFlyBSD) import core.sys.dragonflybsd.dlfcn : RTLD_DEFAULT;\n+        version (FreeBSD) import core.sys.freebsd.dlfcn : RTLD_DEFAULT;\n+        version (linux) import core.sys.linux.dlfcn : RTLD_DEFAULT;\n+        version (NetBSD) import core.sys.netbsd.dlfcn : RTLD_DEFAULT;\n+        version (OSX) import core.sys.darwin.dlfcn : RTLD_DEFAULT;\n+        version (Solaris) import core.sys.solaris.dlfcn : RTLD_DEFAULT;\n+\n+        if (auto found = cast(CXX_DEMANGLER) dlsym(RTLD_DEFAULT, \"__cxa_demangle\"))\n+            __cxa_demangle = found;\n+    }\n+\n+    if (__cxa_demangle is null)\n+        __cxa_demangle = (const char* mangled_name, char* output_buffer,\n+                            size_t* length, int* status) nothrow pure @trusted {\n+                                *status = -1;\n+                                return null;\n+                            };\n+\n+    return __cxa_demangle;\n+}\n+\n+/**\n+ * Demangles C++ mangled names.  If it is not a C++ mangled name, it\n+ * returns its argument name.\n+ *\n+ * Params:\n+ *  buf = The string to demangle.\n+ *  __cxa_demangle = C++ demangler\n+ *  dst = An optional destination buffer.\n+ *\n+ * Returns:\n+ *  The demangled name or the original string if the name is not a mangled\n+ *  C++ name.\n+ */\n+private char[] demangleCXX(return scope const(char)[] buf, CXX_DEMANGLER __cxa_demangle, return scope char[] dst = null,) nothrow pure @trusted\n+{\n+    char[] c_string = dst; // temporarily use dst buffer if possible\n+    c_string.length = buf.length + 1;\n+    c_string[0 .. buf.length] = buf[0 .. buf.length];\n+    c_string[buf.length] = '\\0';\n+\n+    int status;\n+    size_t demangled_length;\n+    auto demangled = __cxa_demangle(&c_string[0], null, &demangled_length, &status);\n+    scope (exit) {\n+        import core.memory;\n+        pureFree(cast(void*) demangled);\n+    }\n+    if (status == 0)\n+    {\n+        dst.length = demangled_length;\n+        dst[] = demangled[0 .. demangled_length];\n+        return dst;\n+    }\n+\n+    dst.length = buf.length;\n+    dst[] = buf[];\n+    return dst;\n+}"}, {"sha": "62179fec58bd1d0d4903ff596493830f03063485", "filename": "libphobos/libdruntime/core/exception.d", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Fexception.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Fexception.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fexception.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -608,7 +608,7 @@ extern (C) void onUnittestErrorMsg( string file, size_t line, string msg ) nothr\n  * Throws:\n  *  $(LREF RangeError).\n  */\n-extern (C) void onRangeError( string file = __FILE__, size_t line = __LINE__ ) @trusted pure nothrow @nogc\n+extern (C) noreturn onRangeError( string file = __FILE__, size_t line = __LINE__ ) @trusted pure nothrow @nogc\n {\n     throw staticError!RangeError(file, line, null);\n }\n@@ -626,7 +626,7 @@ extern (C) void onRangeError( string file = __FILE__, size_t line = __LINE__ ) @\n  * Throws:\n  *  $(LREF ArraySliceError).\n  */\n-extern (C) void onArraySliceError( size_t lower = 0, size_t upper = 0, size_t length = 0,\n+extern (C) noreturn onArraySliceError( size_t lower = 0, size_t upper = 0, size_t length = 0,\n                               string file = __FILE__, size_t line = __LINE__ ) @trusted pure nothrow @nogc\n {\n     throw staticError!ArraySliceError(lower, upper, length, file, line, null);\n@@ -644,7 +644,7 @@ extern (C) void onArraySliceError( size_t lower = 0, size_t upper = 0, size_t le\n  * Throws:\n  *  $(LREF ArrayIndexError).\n  */\n-extern (C) void onArrayIndexError( size_t index = 0, size_t length = 0,\n+extern (C) noreturn onArrayIndexError( size_t index = 0, size_t length = 0,\n                               string file = __FILE__, size_t line = __LINE__ ) @trusted pure nothrow @nogc\n {\n     throw staticError!ArrayIndexError(index, length, file, line, null);\n@@ -662,7 +662,7 @@ extern (C) void onArrayIndexError( size_t index = 0, size_t length = 0,\n  * Throws:\n  *  $(LREF FinalizeError).\n  */\n-extern (C) void onFinalizeError( TypeInfo info, Throwable e, string file = __FILE__, size_t line = __LINE__ ) @trusted nothrow\n+extern (C) noreturn onFinalizeError( TypeInfo info, Throwable e, string file = __FILE__, size_t line = __LINE__ ) @trusted nothrow\n {\n     // This error is thrown during a garbage collection, so no allocation must occur while\n     //  generating this object. So we use a preallocated instance\n@@ -679,13 +679,13 @@ version (D_BetterC)\n     // templates even for ordinary builds instead of providing them as an\n     // extern(C) library.\n \n-    void onOutOfMemoryError()(void* pretend_sideffect = null) @nogc nothrow pure @trusted\n+    noreturn onOutOfMemoryError()(void* pretend_sideffect = null) @nogc nothrow pure @trusted\n     {\n         assert(0, \"Memory allocation failed\");\n     }\n     alias onOutOfMemoryErrorNoGC = onOutOfMemoryError;\n \n-    void onInvalidMemoryOperationError()(void* pretend_sideffect = null) @nogc nothrow pure @trusted\n+    noreturn onInvalidMemoryOperationError()(void* pretend_sideffect = null) @nogc nothrow pure @trusted\n     {\n         assert(0, \"Invalid memory operation\");\n     }\n@@ -699,14 +699,14 @@ else\n      * Throws:\n      *  $(LREF OutOfMemoryError).\n      */\n-    extern (C) void onOutOfMemoryError(void* pretend_sideffect = null) @trusted pure nothrow @nogc /* dmd @@@BUG11461@@@ */\n+    extern (C) noreturn onOutOfMemoryError(void* pretend_sideffect = null) @trusted pure nothrow @nogc /* dmd @@@BUG11461@@@ */\n     {\n         // NOTE: Since an out of memory condition exists, no allocation must occur\n         //       while generating this object.\n         throw staticError!OutOfMemoryError();\n     }\n \n-    extern (C) void onOutOfMemoryErrorNoGC() @trusted nothrow @nogc\n+    extern (C) noreturn onOutOfMemoryErrorNoGC() @trusted nothrow @nogc\n     {\n         // suppress stacktrace until they are @nogc\n         throw staticError!OutOfMemoryError(false);\n@@ -720,7 +720,7 @@ else\n  * Throws:\n  *  $(LREF InvalidMemoryOperationError).\n  */\n-extern (C) void onInvalidMemoryOperationError(void* pretend_sideffect = null) @trusted pure nothrow @nogc /* dmd @@@BUG11461@@@ */\n+extern (C) noreturn onInvalidMemoryOperationError(void* pretend_sideffect = null) @trusted pure nothrow @nogc /* dmd @@@BUG11461@@@ */\n {\n     // The same restriction applies as for onOutOfMemoryError. The GC is in an\n     // undefined state, thus no allocation must occur while generating this object.\n@@ -738,7 +738,7 @@ extern (C) void onInvalidMemoryOperationError(void* pretend_sideffect = null) @t\n  * Throws:\n  *  $(LREF ConfigurationError).\n  */\n-extern (C) void onForkError( string file = __FILE__, size_t line = __LINE__ ) @trusted pure nothrow @nogc\n+extern (C) noreturn onForkError( string file = __FILE__, size_t line = __LINE__ ) @trusted pure nothrow @nogc\n {\n     throw staticError!ForkError( file, line, null );\n }\n@@ -755,7 +755,7 @@ extern (C) void onForkError( string file = __FILE__, size_t line = __LINE__ ) @t\n  * Throws:\n  *  $(LREF UnicodeException).\n  */\n-extern (C) void onUnicodeError( string msg, size_t idx, string file = __FILE__, size_t line = __LINE__ ) @safe pure\n+extern (C) noreturn onUnicodeError( string msg, size_t idx, string file = __FILE__, size_t line = __LINE__ ) @safe pure\n {\n     throw new UnicodeException( msg, idx, file, line );\n }\n@@ -859,7 +859,7 @@ extern (C)\n private align(2 * size_t.sizeof) void[256] _store;\n \n // only Errors for now as those are rarely chained\n-private T staticError(T, Args...)(auto ref Args args)\n+package T staticError(T, Args...)(auto ref Args args)\n     if (is(T : Error))\n {\n     // pure hack, what we actually need is @noreturn and allow to call that in pure functions"}, {"sha": "38b60cbbcc40fa32d68bb424f120fd178eda015e", "filename": "libphobos/libdruntime/core/internal/gc/os.d", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fos.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fos.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fos.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -70,10 +70,7 @@ else version (Posix)\n         else if (errno ==  ECHILD)\n             return ChildStatus.done; // someone called posix.syswait\n         else if (waited_pid != pid || status != 0)\n-        {\n             onForkError();\n-            return ChildStatus.error;\n-        }\n         return ChildStatus.done;\n     }\n "}, {"sha": "799e525294169af712baae04d0fd5f338f090bd1", "filename": "libphobos/libdruntime/core/runtime.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Fruntime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Fruntime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fruntime.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -910,7 +910,7 @@ private:\n         {\n             fixbuf[0 .. symBeg] = buf[0 .. symBeg];\n \n-            auto sym = demangle(buf[symBeg .. symEnd], fixbuf[symBeg .. $]);\n+            auto sym = demangle(buf[symBeg .. symEnd], fixbuf[symBeg .. $], getCXXDemangler());\n \n             if (sym.ptr !is fixbuf.ptr + symBeg)\n             {"}, {"sha": "ddd04ae0576f24af9b56bb8adb3c754eb705ff11", "filename": "libphobos/libdruntime/core/sync/condition.d", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Fsync%2Fcondition.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Fsync%2Fcondition.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsync%2Fcondition.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -20,6 +20,9 @@ public import core.sync.exception;\n public import core.sync.mutex;\n public import core.time;\n \n+import core.exception : AssertError, staticError;\n+\n+\n version (Windows)\n {\n     import core.sync.semaphore;\n@@ -51,7 +54,6 @@ else\n // void notifyAll();\n ////////////////////////////////////////////////////////////////////////////////\n \n-\n /**\n  * This class represents a condition variable as conceived by C.A.R. Hoare.  As\n  * per Mesa type monitors however, \"signal\" has been replaced with \"notify\" to\n@@ -74,19 +76,19 @@ class Condition\n      * Throws:\n      *  SyncError on error.\n      */\n-    this( Mutex m ) nothrow @safe\n+    this( Mutex m ) nothrow @safe @nogc\n     {\n         this(m, true);\n     }\n \n     /// ditto\n-    this( shared Mutex m ) shared nothrow @safe\n+    this( shared Mutex m ) shared nothrow @safe @nogc\n     {\n         this(m, true);\n     }\n \n     //\n-    private this(this Q, M)( M m, bool _unused_ ) nothrow @trusted\n+    private this(this Q, M)( M m, bool _unused_ ) nothrow @trusted @nogc\n         if ((is(Q == Condition) && is(M == Mutex)) ||\n             (is(Q == shared Condition) && is(M == shared Mutex)))\n     {\n@@ -102,12 +104,12 @@ class Condition\n             }\n             m_blockLock = cast(HANDLE_TYPE) CreateSemaphoreA( null, 1, 1, null );\n             if ( m_blockLock == m_blockLock.init )\n-                throw new SyncError( \"Unable to initialize condition\" );\n+                throw staticError!AssertError(\"Unable to initialize condition\", __FILE__, __LINE__);\n             scope(failure) CloseHandle( cast(void*) m_blockLock );\n \n             m_blockQueue = cast(HANDLE_TYPE) CreateSemaphoreA( null, 0, int.max, null );\n             if ( m_blockQueue == m_blockQueue.init )\n-                throw new SyncError( \"Unable to initialize condition\" );\n+                throw staticError!AssertError(\"Unable to initialize condition\", __FILE__, __LINE__);\n             scope(failure) CloseHandle( cast(void*) m_blockQueue );\n \n             InitializeCriticalSection( cast(RTL_CRITICAL_SECTION*) &m_unblockLock );\n@@ -123,29 +125,28 @@ class Condition\n                     pthread_condattr_t attr = void;\n                     int rc  = pthread_condattr_init( &attr );\n                     if ( rc )\n-                        throw new SyncError( \"Unable to initialize condition\" );\n+                        throw staticError!AssertError(\"Unable to initialize condition\", __FILE__, __LINE__);\n                     rc = pthread_condattr_setclock( &attr, CLOCK_MONOTONIC );\n                     if ( rc )\n-                        throw new SyncError( \"Unable to initialize condition\" );\n+                        throw staticError!AssertError(\"Unable to initialize condition\", __FILE__, __LINE__);\n                     rc = pthread_cond_init( cast(pthread_cond_t*) &m_hndl, &attr );\n                     if ( rc )\n-                        throw new SyncError( \"Unable to initialize condition\" );\n+                        throw staticError!AssertError(\"Unable to initialize condition\", __FILE__, __LINE__);\n                     rc = pthread_condattr_destroy( &attr );\n                     if ( rc )\n-                        throw new SyncError( \"Unable to initialize condition\" );\n+                        throw staticError!AssertError(\"Unable to initialize condition\", __FILE__, __LINE__);\n                 } ();\n             }\n             else\n             {\n                 int rc = pthread_cond_init( cast(pthread_cond_t*) &m_hndl, null );\n                 if ( rc )\n-                    throw new SyncError( \"Unable to initialize condition\" );\n+                    throw staticError!AssertError(\"Unable to initialize condition\", __FILE__, __LINE__);\n             }\n         }\n     }\n \n-\n-    ~this()\n+    ~this() @nogc\n     {\n         version (Windows)\n         {\n@@ -231,7 +232,7 @@ class Condition\n         {\n             int rc = pthread_cond_wait( cast(pthread_cond_t*) &m_hndl, (cast(Mutex) m_assocMutex).handleAddr() );\n             if ( rc )\n-                throw new SyncError( \"Unable to wait for condition\" );\n+                throw staticError!AssertError(\"Unable to wait for condition\", __FILE__, __LINE__);\n         }\n     }\n \n@@ -296,7 +297,7 @@ class Condition\n                 return true;\n             if ( rc == ETIMEDOUT )\n                 return false;\n-            throw new SyncError( \"Unable to wait for condition\" );\n+            throw staticError!AssertError(\"Unable to wait for condition\", __FILE__, __LINE__);\n         }\n     }\n \n@@ -344,7 +345,7 @@ class Condition\n                 rc = pthread_cond_signal( cast(pthread_cond_t*) &m_hndl );\n             } while ( rc == EAGAIN );\n             if ( rc )\n-                throw new SyncError( \"Unable to notify condition\" );\n+                throw staticError!AssertError(\"Unable to notify condition\", __FILE__, __LINE__);\n         }\n     }\n \n@@ -392,7 +393,7 @@ class Condition\n                 rc = pthread_cond_broadcast( cast(pthread_cond_t*) &m_hndl );\n             } while ( rc == EAGAIN );\n             if ( rc )\n-                throw new SyncError( \"Unable to notify condition\" );\n+                throw staticError!AssertError(\"Unable to notify condition\", __FILE__, __LINE__);\n         }\n     }\n "}, {"sha": "e7380c467254a02295c9df6077388cb668f50400", "filename": "libphobos/libdruntime/core/sync/mutex.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Fsync%2Fmutex.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Fsync%2Fmutex.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsync%2Fmutex.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -292,7 +292,7 @@ private:\n package:\n     version (Posix)\n     {\n-        pthread_mutex_t* handleAddr()\n+        pthread_mutex_t* handleAddr() @nogc\n         {\n             return &m_hndl;\n         }"}, {"sha": "145149be5284bfa98155b9c85f76d2fb1eab796f", "filename": "libphobos/libdruntime/core/sys/posix/sys/wait.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fwait.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fwait.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fwait.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -451,6 +451,7 @@ else version (NetBSD)\n }\n else version (OpenBSD)\n {\n+    int waitid(idtype_t, id_t, siginfo_t*, int);\n }\n else version (DragonFlyBSD)\n {"}, {"sha": "b036df39dfe7963ce9025c6385461d5fd0cfe475", "filename": "libphobos/libdruntime/core/sys/windows/winsock2.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fwinsock2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fwinsock2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fwinsock2.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -63,11 +63,11 @@ int getsockopt(SOCKET s, int level, int optname, void* optval, socklen_t* optlen\n int setsockopt(SOCKET s, int level, int optname, const(void)* optval, socklen_t optlen);\n uint inet_addr(const char* cp);\n int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* errorfds, const(timeval)* timeout);\n-@trusted char* inet_ntoa(in_addr ina);\n+char* inet_ntoa(in_addr ina);\n hostent* gethostbyname(const char* name);\n hostent* gethostbyaddr(const(void)* addr, int len, int type);\n protoent* getprotobyname(const char* name);\n-@trusted protoent* getprotobynumber(int number);\n+protoent* getprotobynumber(int number);\n servent* getservbyname(const char* name, const char* proto);\n servent* getservbyport(int port, const char* proto);\n }"}, {"sha": "09da6a800bd805412b8f71c2dbcb0ad7d65dde59", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1,4 +1,4 @@\n-3ad507b5125573c5b47736a0913105bfb1249746\n+792c8b7c1d5957767e138f78d04bf175d4b92f10\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "9b1d9207b9ac55108668f90af6e90d21ef2d08a3", "filename": "libphobos/src/std/algorithm/mutation.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fmutation.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fmutation.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fmutation.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -573,7 +573,7 @@ $(LINK2 http://en.cppreference.com/w/cpp/algorithm/copy_backward, STL's `copy_ba\n Assigns `value` to each element of input range `range`.\n \n Alternatively, instead of using a single `value` to fill the `range`,\n-a `filter` $(REF_ALTTEXT forward range, isForwardRange, std,range,primitives)\n+a `filler` $(REF_ALTTEXT forward range, isForwardRange, std,range,primitives)\n can be provided. The length of `filler` and `range` do not need to match, but\n `filler` must not be empty.\n "}, {"sha": "ddb80b8fc68d08f1a06e2b7d9d6678e31e38e971", "filename": "libphobos/src/std/algorithm/sorting.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsorting.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsorting.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsorting.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -3946,7 +3946,7 @@ if (isRandomAccessRange!(Range1) && hasLength!Range1 &&\n     {\n         foreach (T2; ReferenceRanges)\n         {\n-            import std.array;\n+            import std.array : array;\n \n             T1 A;\n             T2 B;"}, {"sha": "daa103a9a420afc38283081f13c6e114d4aad6ab", "filename": "libphobos/src/std/array.d", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Farray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Farray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Farray.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -169,8 +169,8 @@ if (isIterable!Range && !isAutodecodableString!Range && !isInfinite!Range)\n }\n \n /// ditto\n-ForeachType!(PointerTarget!Range)[] array(Range)(Range r)\n-if (isPointer!Range && isIterable!(PointerTarget!Range) && !isAutodecodableString!Range && !isInfinite!Range)\n+ForeachType!(typeof((*Range).init))[] array(Range)(Range r)\n+if (is(Range : U*, U) && isIterable!U && !isAutodecodableString!Range && !isInfinite!Range)\n {\n     return array(*r);\n }\n@@ -3416,7 +3416,8 @@ do\n Implements an output range that appends data to an array. This is\n recommended over $(D array ~= data) when appending many elements because it is more\n efficient. `Appender` maintains its own array metadata locally, so it can avoid\n-global locking for each append where $(LREF capacity) is non-zero.\n+the $(DDSUBLINK spec/arrays, capacity-reserve, performance hit of looking up slice `capacity`)\n+for each append.\n \n Params:\n     A = the array type to simulate.\n@@ -3587,7 +3588,7 @@ if (isDynamicArray!A)\n     private template canPutItem(U)\n     {\n         enum bool canPutItem =\n-            isImplicitlyConvertible!(Unqual!U, Unqual!T) ||\n+            is(Unqual!U : Unqual!T) ||\n             isSomeChar!T && isSomeChar!U;\n     }\n     private template canPutConstRange(Range)"}, {"sha": "0fc92ac2b016293ea20cb1e55c8204ccb1194289", "filename": "libphobos/src/std/base64.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fbase64.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fbase64.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fbase64.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -639,7 +639,7 @@ template Base64Impl(char Map62th, char Map63th, char Padding = '=')\n          */\n         void popFront()\n         {\n-            enforce(!empty, new Base64Exception(\"Cannot call popFront on Encoder with no data remaining\"));\n+            assert(!empty, \"Cannot call popFront on Encoder with no data remaining\");\n \n             range_.popFront();\n \n@@ -757,7 +757,7 @@ template Base64Impl(char Map62th, char Map63th, char Padding = '=')\n          */\n         void popFront()\n         {\n-            enforce(!empty, new Base64Exception(\"Cannot call popFront on Encoder with no data remaining\"));\n+            assert(!empty, \"Cannot call popFront on Encoder with no data remaining\");\n \n             static if (Padding != NoPadding)\n                 if (padding)\n@@ -1414,7 +1414,7 @@ template Base64Impl(char Map62th, char Map63th, char Padding = '=')\n          */\n         void popFront()\n         {\n-            enforce(!empty, new Base64Exception(\"Cannot call popFront on Decoder with no data remaining.\"));\n+            assert(!empty, \"Cannot call popFront on Decoder with no data remaining.\");\n \n             range_.popFront();\n "}, {"sha": "559f8da5f3fc4d02a7fb644a48121eddead92da9", "filename": "libphobos/src/std/bitmanip.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fbitmanip.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fbitmanip.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fbitmanip.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1418,9 +1418,9 @@ public:\n     /**\n       Flips a single bit, specified by `pos`\n      */\n-    void flip(size_t i) @nogc pure nothrow\n+    void flip(size_t pos) @nogc pure nothrow\n     {\n-        bt(_ptr, i) ? btr(_ptr, i) : bts(_ptr, i);\n+        bt(_ptr, pos) ? btr(_ptr, pos) : bts(_ptr, pos);\n     }\n \n     ///"}, {"sha": "79597e8daccc47541f090dbb309573d077e93556", "filename": "libphobos/src/std/checkedint.d", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fcheckedint.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fcheckedint.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcheckedint.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -630,36 +630,36 @@ if (isIntegral!T || is(T == Checked!(U, H), U, H))\n         import core.atomic : atomicLoad, MemoryOrder;\n         static if (is(typeof(this.payload.atomicLoad!(MemoryOrder.acq)) P))\n         {\n-            auto payload = __ctfe ? cast(P) this.payload\n+            auto localPayload = __ctfe ? cast(P) this.payload\n                                   : this.payload.atomicLoad!(MemoryOrder.acq);\n         }\n         else\n         {\n-            alias payload = this.payload;\n+            alias localPayload = this.payload;\n         }\n \n         static if (hasMember!(Hook, \"hookToHash\"))\n         {\n-            return hook.hookToHash(payload);\n+            return hook.hookToHash(localPayload);\n         }\n         else static if (stateSize!Hook > 0)\n         {\n-            static if (hasMember!(typeof(payload), \"toHash\"))\n+            static if (hasMember!(typeof(localPayload), \"toHash\"))\n             {\n-                return payload.toHash() ^ hashOf(hook);\n+                return localPayload.toHash() ^ hashOf(hook);\n             }\n             else\n             {\n-                return hashOf(payload) ^ hashOf(hook);\n+                return hashOf(localPayload) ^ hashOf(hook);\n             }\n         }\n-        else static if (hasMember!(typeof(payload), \"toHash\"))\n+        else static if (hasMember!(typeof(localPayload), \"toHash\"))\n         {\n-            return payload.toHash();\n+            return localPayload.toHash();\n         }\n         else\n         {\n-            return .hashOf(payload);\n+            return .hashOf(localPayload);\n         }\n     }\n "}, {"sha": "323926a6aaed9eb797fa726b9e477836f076eff3", "filename": "libphobos/src/std/concurrency.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fconcurrency.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fconcurrency.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fconcurrency.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -480,7 +480,7 @@ private template isSpawnable(F, T...)\n             enum isParamsImplicitlyConvertible = false;\n         else static if (param1.length == i)\n             enum isParamsImplicitlyConvertible = true;\n-        else static if (isImplicitlyConvertible!(param2[i], param1[i]))\n+        else static if (is(param2[i] : param1[i]))\n             enum isParamsImplicitlyConvertible = isParamsImplicitlyConvertible!(F1,\n                     F2, i + 1);\n         else\n@@ -2129,7 +2129,7 @@ private\n \n             static assert(T.length, \"T must not be empty\");\n \n-            static if (isImplicitlyConvertible!(T[0], Duration))\n+            static if (is(T[0] : Duration))\n             {\n                 alias Ops = AliasSeq!(T[1 .. $]);\n                 alias ops = vals[1 .. $];"}, {"sha": "f5efe6d1f2af0cb05d4cbf76bc00cf44c0880ed3", "filename": "libphobos/src/std/container/array.d", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fcontainer%2Farray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fcontainer%2Farray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcontainer%2Farray.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -34,7 +34,7 @@ pure @system unittest\n         float[] a0;\n         {\n             import std.range : iota;\n-            import std.array;\n+            import std.array : array;\n             import std.algorithm.iteration : map;\n             a0 = iota (0, n).map!(i => i * 1.1f).array;\n         }\n@@ -991,7 +991,7 @@ if (!is(immutable T == immutable bool))\n      */\n     void removeBack()\n     {\n-        enforce(!empty);\n+        assert(!empty);\n         static if (hasElaborateDestructor!T)\n             .destroy(_data._payload[$ - 1]);\n \n@@ -1812,49 +1812,49 @@ if (is(immutable T == immutable bool))\n         /// Ditto\n         @property T front()\n         {\n-            enforce(!empty, \"Attempting to access the front of an empty Array\");\n+            assert(!empty, \"Attempting to access the front of an empty Array\");\n             return _outer[_a];\n         }\n         /// Ditto\n         @property void front(bool value)\n         {\n-            enforce(!empty, \"Attempting to set the front of an empty Array\");\n+            assert(!empty, \"Attempting to set the front of an empty Array\");\n             _outer[_a] = value;\n         }\n         /// Ditto\n         T moveFront()\n         {\n-            enforce(!empty, \"Attempting to move the front of an empty Array\");\n+            assert(!empty, \"Attempting to move the front of an empty Array\");\n             return _outer.moveAt(_a);\n         }\n         /// Ditto\n         void popFront()\n         {\n-            enforce(!empty, \"Attempting to popFront an empty Array\");\n+            assert(!empty, \"Attempting to popFront an empty Array\");\n             ++_a;\n         }\n         /// Ditto\n         @property T back()\n         {\n-            enforce(!empty, \"Attempting to access the back of an empty Array\");\n+            assert(!empty, \"Attempting to access the back of an empty Array\");\n             return _outer[_b - 1];\n         }\n         /// Ditto\n         @property void back(bool value)\n         {\n-            enforce(!empty, \"Attempting to set the back of an empty Array\");\n+            assert(!empty, \"Attempting to set the back of an empty Array\");\n             _outer[_b - 1] = value;\n         }\n         /// Ditto\n         T moveBack()\n         {\n-            enforce(!empty, \"Attempting to move the back of an empty Array\");\n+            assert(!empty, \"Attempting to move the back of an empty Array\");\n             return _outer.moveAt(_b - 1);\n         }\n         /// Ditto\n         void popBack()\n         {\n-            enforce(!empty, \"Attempting to popBack an empty Array\");\n+            assert(!empty, \"Attempting to popBack an empty Array\");\n             --_b;\n         }\n         /// Ditto\n@@ -2029,14 +2029,14 @@ if (is(immutable T == immutable bool))\n      */\n     @property bool front()\n     {\n-        enforce(!empty);\n+        assert(!empty);\n         return data.ptr[0] & 1;\n     }\n \n     /// Ditto\n     @property void front(bool value)\n     {\n-        enforce(!empty);\n+        assert(!empty);\n         if (value) data.ptr[0] |= 1;\n         else data.ptr[0] &= ~cast(size_t) 1;\n     }\n@@ -2052,14 +2052,14 @@ if (is(immutable T == immutable bool))\n      */\n     @property bool back()\n     {\n-        enforce(!empty);\n+        assert(!empty);\n         return cast(bool)(data.back & (cast(size_t) 1 << ((_store._length - 1) % bitsPerWord)));\n     }\n \n     /// Ditto\n     @property void back(bool value)\n     {\n-        enforce(!empty);\n+        assert(!empty);\n         if (value)\n         {\n             data.back |= (cast(size_t) 1 << ((_store._length - 1) % bitsPerWord));"}, {"sha": "7ff14fc3bad49cdc522bbafd3610587311715cf7", "filename": "libphobos/src/std/container/binaryheap.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fcontainer%2Fbinaryheap.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fcontainer%2Fbinaryheap.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcontainer%2Fbinaryheap.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -249,7 +249,7 @@ according to `less`.\n      */\n     @property ElementType!Store front()\n     {\n-        enforce(!empty, \"Cannot call front on an empty heap.\");\n+        assert(!empty, \"Cannot call front on an empty heap.\");\n         return _store.front;\n     }\n \n@@ -317,7 +317,7 @@ Removes the largest element from the heap.\n      */\n     void removeFront()\n     {\n-        enforce(!empty, \"Cannot call removeFront on an empty heap.\");\n+        assert(!empty, \"Cannot call removeFront on an empty heap.\");\n         if (_length > 1)\n         {\n             auto t1 = _store[].moveFront();"}, {"sha": "d1b64212e3929dcd5517884ff92d45d6aa600b53", "filename": "libphobos/src/std/conv.d", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fconv.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fconv.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fconv.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -162,12 +162,12 @@ private\n \n     template isEnumStrToStr(S, T)\n     {\n-        enum isEnumStrToStr = isImplicitlyConvertible!(S, T) &&\n+        enum isEnumStrToStr = is(S : T) &&\n                               is(S == enum) && isExactSomeString!T;\n     }\n     template isNullToStr(S, T)\n     {\n-        enum isNullToStr = isImplicitlyConvertible!(S, T) &&\n+        enum isNullToStr = is(S : T) &&\n                            (is(immutable S == immutable typeof(null))) && isExactSomeString!T;\n     }\n }\n@@ -542,7 +542,7 @@ If the source type is implicitly convertible to the target type, $(D\n to) simply performs the implicit conversion.\n  */\n private T toImpl(T, S)(S value)\n-if (isImplicitlyConvertible!(S, T) &&\n+if (is(S : T) &&\n     !isEnumStrToStr!(S, T) && !isNullToStr!(S, T))\n {\n     template isSignedInt(T)\n@@ -699,7 +699,7 @@ if (isStaticArray!S)\n When source type supports member template function opCast, it is used.\n */\n private T toImpl(T, S)(S value)\n-if (!isImplicitlyConvertible!(S, T) &&\n+if (!is(S : T) &&\n     is(typeof(S.init.opCast!T()) : T) &&\n     !isExactSomeString!T &&\n     !is(typeof(T(value))))\n@@ -750,7 +750,7 @@ $(UL $(LI If target type is struct, `T(value)` is used.)\n      $(LI If target type is class, $(D new T(value)) is used.))\n */\n private T toImpl(T, S)(S value)\n-if (!isImplicitlyConvertible!(S, T) &&\n+if (!is(S : T) &&\n     is(T == struct) && is(typeof(T(value))))\n {\n     return T(value);\n@@ -799,7 +799,7 @@ if (!isImplicitlyConvertible!(S, T) &&\n \n /// ditto\n private T toImpl(T, S)(S value)\n-if (!isImplicitlyConvertible!(S, T) &&\n+if (!is(S : T) &&\n     is(T == class) && is(typeof(new T(value))))\n {\n     return new T(value);\n@@ -872,7 +872,7 @@ Object-to-object conversions by dynamic casting throw exception when the source\n non-null and the target is null.\n  */\n private T toImpl(T, S)(S value)\n-if (!isImplicitlyConvertible!(S, T) &&\n+if (!is(S : T) &&\n     (is(S == class) || is(S == interface)) && !is(typeof(value.opCast!T()) : T) &&\n     (is(T == class) || is(T == interface)) && !is(typeof(new T(value))))\n {\n@@ -957,7 +957,7 @@ if (!isImplicitlyConvertible!(S, T) &&\n         alias tgtmod = AddModifier!m2;\n \n         // Compile time convertible equals to modifier convertible.\n-        static if (isImplicitlyConvertible!(srcmod!Object, tgtmod!Object))\n+        static if (is(srcmod!Object : tgtmod!Object))\n         {\n             // Test runtime conversions: class to class, class to interface,\n             // interface to class, and interface to interface\n@@ -993,7 +993,7 @@ if (!isImplicitlyConvertible!(S, T) &&\n Handles type _to string conversions\n */\n private T toImpl(T, S)(S value)\n-if (!(isImplicitlyConvertible!(S, T) &&\n+if (!(is(S : T) &&\n     !isEnumStrToStr!(S, T) && !isNullToStr!(S, T)) &&\n     !isInfinite!S && isExactSomeString!T)\n {\n@@ -1138,7 +1138,7 @@ if (!(isImplicitlyConvertible!(S, T) &&\n     To string conversion for non copy-able structs\n  */\n private T toImpl(T, S)(ref S value)\n-if (!(isImplicitlyConvertible!(S, T) &&\n+if (!(is(S : T) &&\n     !isEnumStrToStr!(S, T) && !isNullToStr!(S, T)) &&\n     !isInfinite!S && isExactSomeString!T && !isCopyable!S && !isStaticArray!S)\n {\n@@ -1528,7 +1528,7 @@ Narrowing numeric-numeric conversions throw when the value does not\n fit in the narrower type.\n  */\n private T toImpl(T, S)(S value)\n-if (!isImplicitlyConvertible!(S, T) &&\n+if (!is(S : T) &&\n     (isNumeric!S || isSomeChar!S || isBoolean!S) &&\n     (isNumeric!T || isSomeChar!T || isBoolean!T) && !is(T == enum))\n {\n@@ -1643,7 +1643,7 @@ Array-to-array conversion (except when target is a string type)\n converts each element in turn by using `to`.\n  */\n private T toImpl(T, S)(scope S value)\n-if (!isImplicitlyConvertible!(S, T) &&\n+if (!is(S : T) &&\n     !isSomeString!S && isDynamicArray!S &&\n     !isExactSomeString!T && isArray!T)\n {\n@@ -1725,7 +1725,7 @@ Associative array to associative array conversion converts each key\n and each value in turn.\n  */\n private T toImpl(T, S)(S value)\n-if (!isImplicitlyConvertible!(S, T) && isAssociativeArray!S &&\n+if (!is(S : T) && isAssociativeArray!S &&\n     isAssociativeArray!T && !is(T == enum))\n {\n     /* This code is potentially unsafe."}, {"sha": "6898934f809da0ab60bec7746f7811e029fdce14", "filename": "libphobos/src/std/datetime/systime.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fsystime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fsystime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fsystime.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -10095,7 +10095,7 @@ else version (Windows)\n \n         static void testScope(scope ref SysTime st) @safe\n         {\n-            auto result = SysTimeToSYSTEMTIME(st);\n+            auto localResult = SysTimeToSYSTEMTIME(st);\n         }\n     }\n \n@@ -10178,7 +10178,7 @@ else version (Windows)\n \n         static void testScope(scope ref SysTime st) @safe\n         {\n-            auto result = SysTimeToFILETIME(st);\n+            auto local_result = SysTimeToFILETIME(st);\n         }\n     }\n }"}, {"sha": "6688ba7451a7828769aff6cc413477dcc0a9947b", "filename": "libphobos/src/std/digest/hmac.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fdigest%2Fhmac.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fdigest%2Fhmac.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fdigest%2Fhmac.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -202,14 +202,14 @@ if (hashBlockSize % 8 == 0)\n         import std.string : representation;\n         string data1 = \"Hello, world\", data2 = \"Hola mundo\";\n         auto hmac = HMAC!SHA1(\"My s3cR3T keY\".representation);\n-        auto digest = hmac.put(data1.representation)\n+        auto testDigest = hmac.put(data1.representation)\n                           .put(data2.representation)\n                           .finish();\n         static immutable expected = [\n             197, 57, 52, 3, 13, 194, 13,\n             36, 117, 228, 8, 11, 111, 51,\n             165, 3, 123, 31, 251, 113];\n-        assert(digest == expected);\n+        assert(testDigest == expected);\n     }\n }\n "}, {"sha": "b699a8edea36a272bc197ff825ecde141846fbdc", "filename": "libphobos/src/std/exception.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fexception.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fexception.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexception.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1069,9 +1069,9 @@ as the language is free to assume objects don't have internal pointers\n */\n bool doesPointTo(S, T, Tdummy=void)(auto ref const S source, ref const T target) @nogc @trusted pure nothrow\n if (__traits(isRef, source) || isDynamicArray!S ||\n-    isPointer!S || is(S == class))\n+    is(S : U*, U) || is(S == class))\n {\n-    static if (isPointer!S || is(S == class) || is(S == interface))\n+    static if (is(S : U*, U) || is(S == class) || is(S == interface))\n     {\n         const m = *cast(void**) &source;\n         const b = cast(void*) &target;\n@@ -1115,9 +1115,9 @@ bool doesPointTo(S, T)(auto ref const shared S source, ref const shared T target\n /// ditto\n bool mayPointTo(S, T, Tdummy=void)(auto ref const S source, ref const T target) @trusted pure nothrow\n if (__traits(isRef, source) || isDynamicArray!S ||\n-    isPointer!S || is(S == class))\n+    is(S : U*, U) || is(S == class))\n {\n-    static if (isPointer!S || is(S == class) || is(S == interface))\n+    static if (is(S : U*, U) || is(S == class) || is(S == interface))\n     {\n         const m = *cast(void**) &source;\n         const b = cast(void*) &target;"}, {"sha": "6bc527d23748ba418a40803707801da16522f377", "filename": "libphobos/src/std/experimental/allocator/building_blocks/package.d", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fpackage.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -147,7 +147,11 @@ Sizes through 3584 bytes are handled via freelists of staggered sizes. Sizes\n from 3585 bytes through 4072 KB are handled by a `BitmappedBlock` with a\n block size of 4 KB. Sizes above that are passed direct to the `GCAllocator`.\n \n-----\n+$(RUNNABLE_EXAMPLE\n+    ----\n+    import std.experimental.allocator;\n+    import std.algorithm.comparison : max;\n+\n     alias FList = FreeList!(GCAllocator, 0, unbounded);\n     alias A = Segregator!(\n         8, FreeList!(GCAllocator, 0, 8),\n@@ -157,8 +161,7 @@ block size of 4 KB. Sizes above that are passed direct to the `GCAllocator`.\n         1024, Bucketizer!(FList, 513, 1024, 128),\n         2048, Bucketizer!(FList, 1025, 2048, 256),\n         3584, Bucketizer!(FList, 2049, 3584, 512),\n-        4072 * 1024, AllocatorList!(\n-            () => BitmappedBlock!(GCAllocator, 4096)(4072 * 1024)),\n+        4072 * 1024, AllocatorList!(n => Region!GCAllocator(max(n, 1024 * 4096))),\n         GCAllocator\n     );\n     A tuMalloc;\n@@ -169,7 +172,8 @@ block size of 4 KB. Sizes above that are passed direct to the `GCAllocator`.\n     assert(tuMalloc.expand(c, 14));\n     tuMalloc.deallocate(b);\n     tuMalloc.deallocate(c);\n-----\n+    ----\n+)\n \n $(H2 Allocating memory for sharing across threads)\n "}, {"sha": "7dbc47a6f02a19cce50b504041ba774d010e58fc", "filename": "libphobos/src/std/experimental/allocator/package.d", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fpackage.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -27,13 +27,22 @@ $(TR $(TD Global) $(TD\n     $(LREF theAllocator)\n ))\n $(TR $(TD Class interface) $(TD\n-    $(LREF allocatorObject)\n     $(LREF CAllocatorImpl)\n+    $(LREF CSharedAllocatorImpl)\n     $(LREF IAllocator)\n+    $(LREF ISharedAllocator)\n+))\n+$(TR $(TD Structs) $(TD\n+    $(LREF allocatorObject)\n+    $(LREF RCIAllocator)\n+    $(LREF RCISharedAllocator)\n+    $(LREF sharedAllocatorObject)\n+    $(LREF ThreadLocal)\n ))\n )\n \n Synopsis:\n+$(RUNNABLE_EXAMPLE\n ---\n // Allocate an int, initialize it with 42\n int* p = theAllocator.make!int(42);\n@@ -46,7 +55,10 @@ p = processAllocator.make!int(100);\n assert(*p == 100);\n // Destroy and deallocate\n processAllocator.dispose(p);\n-\n+---\n+)\n+$(RUNNABLE_EXAMPLE\n+---\n // Create an array of 50 doubles initialized to -1.0\n double[] arr = theAllocator.makeArray!double(50, -1.0);\n // Append two zeros to it\n@@ -56,6 +68,7 @@ theAllocator.shrinkArray(arr, 2);\n // Destroy and deallocate\n theAllocator.dispose(arr);\n ---\n+)\n \n $(H2 Layered Structure)\n "}, {"sha": "d031096678694baed435eec1029df9a56354e058", "filename": "libphobos/src/std/file.d", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ffile.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -4986,21 +4986,20 @@ auto dirEntries(bool useDIP1000 = dip1000Enabled)\n {\n     string[] listdir(string pathname)\n     {\n-        import std.algorithm;\n-        import std.array;\n-        import std.file;\n-        import std.path;\n+        import std.algorithm.iteration : map, filter;\n+        import std.array : array;\n+        import std.path : baseName;\n \n-        return std.file.dirEntries(pathname, SpanMode.shallow)\n+        return dirEntries(pathname, SpanMode.shallow)\n             .filter!(a => a.isFile)\n-            .map!((return a) => std.path.baseName(a.name))\n+            .map!((return a) => baseName(a.name))\n             .array;\n     }\n \n     // Can be safe only with -preview=dip1000\n     @safe void main(string[] args)\n     {\n-        import std.stdio;\n+        import std.stdio : writefln;\n \n         string[] files = listdir(args[1]);\n         writefln(\"%s\", files);"}, {"sha": "32c82995feeec682f7df84f6872a09628fd1c952", "filename": "libphobos/src/std/format/internal/write.d", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fformat%2Finternal%2Fwrite.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fformat%2Finternal%2Fwrite.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fformat%2Finternal%2Fwrite.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -3011,7 +3011,7 @@ void enforceValidFormatSpec(T, Char)(scope const ref FormatSpec!Char f)\n /*\n     `enum`s are formatted like their base value\n  */\n-void formatValueImpl(Writer, T, Char)(auto ref Writer w, const(T) val, scope const ref FormatSpec!Char f)\n+void formatValueImpl(Writer, T, Char)(auto ref Writer w, T val, scope const ref FormatSpec!Char f)\n if (is(T == enum))\n {\n     import std.array : appender;\n@@ -3020,21 +3020,15 @@ if (is(T == enum))\n     if (f.spec != 's')\n         return formatValueImpl(w, cast(OriginalType!T) val, f);\n \n-    static foreach (e; EnumMembers!T)\n-    {\n-        if (val == e)\n-        {\n-            formatValueImpl(w, __traits(identifier, e), f);\n-            return;\n-        }\n-    }\n+    foreach (immutable member; __traits(allMembers, T))\n+        if (val == __traits(getMember, T, member))\n+            return formatValueImpl(w, member, f);\n \n     auto w2 = appender!string();\n \n     // val is not a member of T, output cast(T) rawValue instead.\n-    put(w2, \"cast(\");\n-    put(w2, T.stringof);\n-    put(w2, \")\");\n+    enum prefix = \"cast(\" ~ T.stringof ~ \")\";\n+    put(w2, prefix);\n     static assert(!is(OriginalType!T == T), \"OriginalType!\" ~ T.stringof ~\n                   \"must not be equal to \" ~ T.stringof);\n \n@@ -3154,7 +3148,7 @@ if (isPointer!T && !is(T == enum) && !hasToString!(T, Char))\n \n     auto a = iota(0, 10);\n     auto b = iota(0, 10);\n-    auto p = () @trusted { auto p = &a; return p; }();\n+    auto p = () @trusted { auto result = &a; return result; }();\n \n     assert(format(\"%s\",p) != format(\"%s\",b));\n }"}, {"sha": "f1d470558360e7d4801504301ac0adbbf31c7211", "filename": "libphobos/src/std/format/package.d", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fformat%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fformat%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fformat%2Fpackage.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -212,17 +212,17 @@ There are several flags that affect the outcome of the formatting.\n $(BOOKTABLE ,\n    $(TR $(TH Flag) $(TH Semantics))\n    $(TR $(TD $(B '-'))\n-        $(TD When the formatted result is shorter then the value\n-             given by the width parameter, the output is right\n-             justified. With the $(B '-') flag this is changed\n-             to left justification.\n+        $(TD When the formatted result is shorter than the value\n+             given by the width parameter, the output is left\n+             justified. Without the $(B '-') flag, the output remains\n+             right justified.\n \n              There are two exceptions where the $(B '-') flag has a\n              different meaning: (1) with $(B 'r') it denotes to use little\n              endian and (2) in case of a compound indicator it means that\n              no special handling of the members is applied.))\n    $(TR $(TD $(B '='))\n-        $(TD When the formatted result is shorter then the value\n+        $(TD When the formatted result is shorter than the value\n              given by the width parameter, the output is centered.\n              If the central position is not possible it is moved slightly\n              to the right. In this case, if $(B '-') flag is present in\n@@ -1563,6 +1563,14 @@ char[] sformat(Char, Args...)(return scope char[] buf, scope const(Char)[] fmt,\n     {\n         char[] buf;\n         size_t i;\n+        void put(char c)\n+        {\n+            if (buf.length <= i)\n+                throw new RangeError(__FILE__, __LINE__);\n+\n+            buf[i] = c;\n+            i += 1;\n+        }\n         void put(dchar c)\n         {\n             char[4] enc;\n@@ -1687,6 +1695,19 @@ if (isSomeString!(typeof(fmt)))\n     assert(u == v);\n }\n \n+@safe unittest // https://issues.dlang.org/show_bug.cgi?id=23488\n+{\n+    static struct R\n+    {\n+        string s = \"\u00dc\";\n+        bool empty() { return s.length == 0; }\n+        char front() { return s[0]; }\n+        void popFront() { s = s[1 .. $]; }\n+    }\n+    char[2] buf;\n+    assert(sformat(buf, \"%s\", R()) == \"\u00dc\");\n+}\n+\n version (StdUnittest)\n private void formatReflectTest(T)(ref T val, string fmt, string formatted, string fn = __FILE__, size_t ln = __LINE__)\n {"}, {"sha": "2aa45d724b5b440403893cb34400775a801cab3e", "filename": "libphobos/src/std/format/write.d", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fformat%2Fwrite.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fformat%2Fwrite.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fformat%2Fwrite.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1310,3 +1310,23 @@ void formatValue(Writer, T, Char)(auto ref Writer w, auto ref T val, scope const\n     writer.formatValue(a, spec);\n     assert(writer.data == \"0\");\n }\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23400\n+@safe pure unittest\n+{\n+    import std.range : nullSink;\n+    import std.format.spec : singleSpec;\n+\n+    static struct S\n+    {\n+        // non-const opEquals method\n+        bool opEquals(S rhs) { return false; }\n+    }\n+\n+    enum E { a = S() }\n+\n+    E e;\n+    auto writer = nullSink;\n+    const spec = singleSpec(\"%s\");\n+    writer.formatValue(e, spec);\n+}"}, {"sha": "c85247f924ede10af4270c3e6f79bbe7a3f869f9", "filename": "libphobos/src/std/getopt.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fgetopt.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fgetopt.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fgetopt.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -558,7 +558,7 @@ private template optionValidator(A...)\n     import std.format : format;\n \n     enum fmt = \"getopt validator: %s (at position %d)\";\n-    enum isReceiver(T) = isPointer!T || (is(T == function)) || (is(T == delegate));\n+    enum isReceiver(T) = is(T : U*, U) || (is(T == function)) || (is(T == delegate));\n     enum isOptionStr(T) = isSomeString!T || isSomeChar!T;\n \n     auto validator()"}, {"sha": "81c7302b4c11eaea0b0026e747b3b8e406dd7e05", "filename": "libphobos/src/std/math/hardware.d", "status": "modified", "additions": 78, "deletions": 46, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fmath%2Fhardware.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fmath%2Fhardware.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fmath%2Fhardware.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -37,13 +37,6 @@ version (RISCV64)   version = RISCV_Any;\n version (D_InlineAsm_X86)    version = InlineAsm_X86_Any;\n version (D_InlineAsm_X86_64) version = InlineAsm_X86_Any;\n \n-version (InlineAsm_X86_Any) version = InlineAsm_X87;\n-version (InlineAsm_X87)\n-{\n-    static assert(real.mant_dig == 64);\n-    version (CRuntime_Microsoft) version = InlineAsm_X87_MSVC;\n-}\n-\n version (X86_64) version = StaticallyHaveSSE;\n version (X86) version (OSX) version = StaticallyHaveSSE;\n \n@@ -76,19 +69,6 @@ version (D_HardFloat)\n     version (IeeeFlagsSupport) version = FloatingPointControlSupport;\n }\n \n-version (GNU)\n-{\n-    // The compiler can unexpectedly rearrange floating point operations and\n-    // access to the floating point status flags when optimizing. This means\n-    // ieeeFlags tests cannot be reliably checked in optimized code.\n-    // See https://github.com/ldc-developers/ldc/issues/888\n-}\n-else\n-{\n-    version = IeeeFlagsUnittest;\n-    version = FloatingPointControlUnittest;\n-}\n-\n version (IeeeFlagsSupport)\n {\n \n@@ -368,25 +348,22 @@ public:\n }\n \n ///\n-version (IeeeFlagsUnittest)\n+version (StdDdoc)\n @safe unittest\n {\n     import std.math.traits : isNaN;\n \n     static void func() {\n         int a = 10 * 10;\n     }\n-    pragma(inline, false) static void blockopt(ref real x) {}\n     real a = 3.5;\n     // Set all the flags to zero\n     resetIeeeFlags();\n     assert(!ieeeFlags.divByZero);\n-    blockopt(a); // avoid constant propagation by the optimizer\n     // Perform a division by zero.\n     a /= 0.0L;\n     assert(a == real.infinity);\n     assert(ieeeFlags.divByZero);\n-    blockopt(a); // avoid constant propagation by the optimizer\n     // Create a NaN\n     a *= 0.0L;\n     assert(ieeeFlags.invalid);\n@@ -399,7 +376,33 @@ version (IeeeFlagsUnittest)\n     assert(ieeeFlags == f);\n }\n \n-version (IeeeFlagsUnittest)\n+@safe unittest\n+{\n+    import std.math.traits : isNaN;\n+\n+    static void func() {\n+        int a = 10 * 10;\n+    }\n+    real a = 3.5;\n+    // Set all the flags to zero\n+    resetIeeeFlags();\n+    assert(!ieeeFlags.divByZero);\n+    // Perform a division by zero.\n+    a = forceDivOp(a, 0.0L);\n+    assert(a == real.infinity);\n+    assert(ieeeFlags.divByZero);\n+    // Create a NaN\n+    a = forceMulOp(a, 0.0L);\n+    assert(ieeeFlags.invalid);\n+    assert(isNaN(a));\n+\n+    // Check that calling func() has no effect on the\n+    // status flags.\n+    IeeeFlags f = ieeeFlags;\n+    func();\n+    assert(ieeeFlags == f);\n+}\n+\n @safe unittest\n {\n     import std.meta : AliasSeq;\n@@ -412,27 +415,26 @@ version (IeeeFlagsUnittest)\n \n     static foreach (T; AliasSeq!(float, double, real))\n     {{\n-        T x; /* Needs to be here to trick -O. It would optimize away the\n-            calculations if x were local to the function literals. */\n+        T x; // Needs to be here to avoid `call without side effects` warning.\n         auto tests = [\n             Test(\n-                () { x = 1; x += 0.1L; },\n+                () { x = forceAddOp!T(1, 0.1L); },\n                 () => ieeeFlags.inexact\n             ),\n             Test(\n-                () { x = T.min_normal; x /= T.max; },\n+                () { x = forceDivOp!T(T.min_normal, T.max); },\n                 () => ieeeFlags.underflow\n             ),\n             Test(\n-                () { x = T.max; x += T.max; },\n+                () { x = forceAddOp!T(T.max, T.max); },\n                 () => ieeeFlags.overflow\n             ),\n             Test(\n-                () { x = 1; x /= 0; },\n+                () { x = forceDivOp!T(1, 0); },\n                 () => ieeeFlags.divByZero\n             ),\n             Test(\n-                () { x = 0; x /= 0; },\n+                () { x = forceDivOp!T(0, 0); },\n                 () => ieeeFlags.invalid\n             )\n         ];\n@@ -453,14 +455,24 @@ void resetIeeeFlags() @trusted nothrow @nogc\n }\n \n ///\n+version (StdDdoc)\n @safe unittest\n {\n-    pragma(inline, false) static void blockopt(ref real x) {}\n     resetIeeeFlags();\n     real a = 3.5;\n-    blockopt(a); // avoid constant propagation by the optimizer\n     a /= 0.0L;\n-    blockopt(a); // avoid constant propagation by the optimizer\n+    assert(a == real.infinity);\n+    assert(ieeeFlags.divByZero);\n+\n+    resetIeeeFlags();\n+    assert(!ieeeFlags.divByZero);\n+}\n+\n+@safe unittest\n+{\n+    resetIeeeFlags();\n+    real a = 3.5;\n+    a = forceDivOp(a, 0.0L);\n     assert(a == real.infinity);\n     assert(ieeeFlags.divByZero);\n \n@@ -475,25 +487,39 @@ void resetIeeeFlags() @trusted nothrow @nogc\n }\n \n ///\n+version (StdDdoc)\n @safe nothrow unittest\n {\n     import std.math.traits : isNaN;\n \n-    pragma(inline, false) static void blockopt(ref real x) {}\n     resetIeeeFlags();\n     real a = 3.5;\n-    blockopt(a); // avoid constant propagation by the optimizer\n \n     a /= 0.0L;\n     assert(a == real.infinity);\n     assert(ieeeFlags.divByZero);\n-    blockopt(a); // avoid constant propagation by the optimizer\n \n     a *= 0.0L;\n     assert(isNaN(a));\n     assert(ieeeFlags.invalid);\n }\n \n+@safe nothrow unittest\n+{\n+    import std.math.traits : isNaN;\n+\n+    resetIeeeFlags();\n+    real a = 3.5;\n+\n+    a = forceDivOp(a, 0.0L);\n+    assert(a == real.infinity);\n+    assert(ieeeFlags.divByZero);\n+\n+    a = forceMulOp(a, 0.0L);\n+    assert(isNaN(a));\n+    assert(ieeeFlags.invalid);\n+}\n+\n } // IeeeFlagsSupport\n \n \n@@ -1100,7 +1126,6 @@ private:\n }\n \n ///\n-version (FloatingPointControlUnittest)\n @safe unittest\n {\n     import std.math.rounding : lrint;\n@@ -1154,32 +1179,27 @@ version (FloatingPointControlUnittest)\n     ensureDefaults();\n }\n \n-version (FloatingPointControlUnittest)\n @safe unittest // rounding\n {\n     import std.meta : AliasSeq;\n \n     static T addRound(T)(uint rm)\n     {\n-        pragma(inline, false) static void blockopt(ref T x) {}\n         pragma(inline, false);\n         FloatingPointControl fpctrl;\n         fpctrl.rounding = rm;\n         T x = 1;\n-        blockopt(x); // avoid constant propagation by the optimizer\n-        x += 0.1L;\n+        x = forceAddOp(x, 0.1L);\n         return x;\n     }\n \n     static T subRound(T)(uint rm)\n     {\n-        pragma(inline, false) static void blockopt(ref T x) {}\n         pragma(inline, false);\n         FloatingPointControl fpctrl;\n         fpctrl.rounding = rm;\n         T x = -1;\n-        blockopt(x); // avoid constant propagation by the optimizer\n-        x -= 0.1L;\n+        x = forceSubOp(x, 0.1L);\n         return x;\n     }\n \n@@ -1210,4 +1230,16 @@ version (FloatingPointControlUnittest)\n     }}\n }\n \n+} // FloatingPointControlSupport\n+\n+version (StdUnittest)\n+{\n+    // These helpers are intended to avoid constant propagation by the optimizer.\n+    pragma(inline, false) private @safe\n+    {\n+        T forceAddOp(T)(T x, T y) { return x + y; }\n+        T forceSubOp(T)(T x, T y) { return x - y; }\n+        T forceMulOp(T)(T x, T y) { return x * y; }\n+        T forceDivOp(T)(T x, T y) { return x / y; }\n+    }\n }"}, {"sha": "3eaa2835249f38b8a4195807f8487d5db8dda82c", "filename": "libphobos/src/std/process.d", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fprocess.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fprocess.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fprocess.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1428,7 +1428,7 @@ version (Posix) @system unittest\n     for (; environ[i] != null; ++i)\n     {\n         assert(e2[i] != null);\n-        import core.stdc.string;\n+        import core.stdc.string : strcmp;\n         assert(strcmp(e2[i], environ[i]) == 0);\n     }\n     assert(e2[i] == null);\n@@ -1732,7 +1732,9 @@ version (Posix) @system unittest\n     // Pipes\n     void testPipes(Config config)\n     {\n-        import std.file, std.uuid, core.thread, std.exception;\n+        import std.file : tempDir, exists, remove;\n+        import std.uuid : randomUUID;\n+        import std.exception : collectException;\n         auto pipei = pipe();\n         auto pipeo = pipe();\n         auto pipee = pipe();\n@@ -1753,11 +1755,14 @@ version (Posix) @system unittest\n     // Files\n     void testFiles(Config config)\n     {\n-        import std.ascii, std.file, std.uuid, core.thread, std.exception;\n+        import std.ascii : newline;\n+        import std.file : tempDir, exists, remove, readText, write;\n+        import std.uuid : randomUUID;\n+        import std.exception : collectException;\n         auto pathi = buildPath(tempDir(), randomUUID().toString());\n         auto patho = buildPath(tempDir(), randomUUID().toString());\n         auto pathe = buildPath(tempDir(), randomUUID().toString());\n-        std.file.write(pathi, \"INPUT\"~std.ascii.newline);\n+        write(pathi, \"INPUT\" ~ newline);\n         auto filei = File(pathi, \"r\");\n         auto fileo = File(patho, \"w\");\n         auto filee = File(pathe, \"w\");"}, {"sha": "888ac1a5d86c97438b63ff689ba22266b6a68c3c", "filename": "libphobos/src/std/range/package.d", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Frange%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Frange%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Frange%2Fpackage.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -3774,10 +3774,17 @@ private:\n         alias fun = Fun[0];\n \n     enum returnByRef_ = (functionAttributes!fun & FunctionAttribute.ref_) ? true : false;\n+\n+    import std.traits : hasIndirections;\n+    static if (!hasIndirections!(ReturnType!fun))\n+        alias RetType = Unqual!(ReturnType!fun);\n+    else\n+        alias RetType = ReturnType!fun;\n+\n     static if (returnByRef_)\n-        ReturnType!fun *elem_;\n+        RetType *elem_;\n     else\n-        ReturnType!fun elem_;\n+        RetType elem_;\n public:\n     /// Range primitives\n     enum empty = false;\n@@ -3866,6 +3873,13 @@ public:\n     assert(g.front == f + 5);\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=23319\n+@safe pure nothrow unittest\n+{\n+    auto b = generate!(() => const(int)(42));\n+    assert(b.front == 42);\n+}\n+\n /**\n Repeats the given forward range ad infinitum. If the original range is\n infinite (fact that would make `Cycle` the identity application),\n@@ -6856,6 +6870,7 @@ if (!isIntegral!(CommonType!(B, E)) &&\n             assert(!empty);\n             ++current;\n         }\n+        @property auto save() { return this; }\n     }\n     return Result(begin, end);\n }\n@@ -6890,6 +6905,13 @@ if (!isIntegral!(CommonType!(B, E)) &&\n     assert(i2.equal([3, 4, 0, 1 ]));\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=23453\n+@safe unittest\n+{\n+    auto r = iota('a', 'z');\n+    static assert(isForwardRange!(typeof(r)));\n+}\n+\n /**\n    Options for the $(LREF FrontTransversal) and $(LREF Transversal) ranges\n    (below)."}, {"sha": "593052e5a822f6501361db9617a28020bc40a862", "filename": "libphobos/src/std/socket.d", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fsocket.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fsocket.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fsocket.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -2628,7 +2628,7 @@ private:\n     AddressFamily _family;\n \n     version (Windows)\n-        bool _blocking = false;         /// Property to get or set whether the socket is blocking or nonblocking.\n+        bool _blocking = true;         /// Property to get or set whether the socket is blocking or nonblocking.\n \n     // The WinSock timeouts seem to be effectively skewed by a constant\n     // offset of about half a second (value in milliseconds). This has\n@@ -2641,22 +2641,22 @@ private:\n     {\n         if (runSlowTests)\n         softUnittest({\n-            import std.datetime.stopwatch;\n-            import std.typecons;\n+            import std.datetime.stopwatch : StopWatch;\n+            import std.typecons : Yes;\n \n             enum msecs = 1000;\n             auto pair = socketPair();\n-            auto sock = pair[0];\n-            sock.setOption(SocketOptionLevel.SOCKET,\n+            auto testSock = pair[0];\n+            testSock.setOption(SocketOptionLevel.SOCKET,\n                 SocketOption.RCVTIMEO, dur!\"msecs\"(msecs));\n \n             auto sw = StopWatch(Yes.autoStart);\n             ubyte[1] buf;\n-            sock.receive(buf);\n+            testSock.receive(buf);\n             sw.stop();\n \n             Duration readBack = void;\n-            sock.getOption(SocketOptionLevel.SOCKET, SocketOption.RCVTIMEO, readBack);\n+            testSock.getOption(SocketOptionLevel.SOCKET, SocketOption.RCVTIMEO, readBack);\n \n             assert(readBack.total!\"msecs\" == msecs);\n             assert(sw.peek().total!\"msecs\" > msecs - 100 && sw.peek().total!\"msecs\" < msecs + 100);\n@@ -2750,6 +2750,21 @@ public:\n         return sock;\n     }\n \n+    /**\n+     * Releases the underlying socket handle from the Socket object. Once it\n+     * is released, you cannot use the Socket object's methods anymore. This\n+     * also means the Socket destructor will no longer close the socket - it\n+     * becomes your responsibility.\n+     *\n+     * To get the handle without releasing it, use the `handle` property.\n+     */\n+    @property socket_t release() pure nothrow @nogc\n+    {\n+        auto h = sock;\n+        this.sock = socket_t.init;\n+        return h;\n+    }\n+\n     /**\n      * Get/set socket's blocking flag.\n      *"}, {"sha": "802aa128c6e47b2ca407d54f117e3a3649a2f5c9", "filename": "libphobos/src/std/stdio.d", "status": "modified", "additions": 116, "deletions": 94, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fstdio.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fstdio.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fstdio.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -52,7 +52,7 @@ import std.algorithm.mutation : copy;\n import std.meta : allSatisfy;\n import std.range : ElementEncodingType, empty, front, isBidirectionalRange,\n     isInputRange, isSomeFiniteCharInputRange, put;\n-import std.traits : isSomeChar, isSomeString, Unqual, isPointer;\n+import std.traits : isSomeChar, isSomeString, Unqual;\n import std.typecons : Flag, No, Yes;\n \n /++\n@@ -768,7 +768,7 @@ Throws: `ErrnoException` in case of error.\n             _name = name;\n     }\n \n-    @system unittest // Test changing filename\n+    @safe unittest // Test changing filename\n     {\n         import std.exception : assertThrown, assertNotThrown;\n         static import std.file;\n@@ -790,7 +790,7 @@ Throws: `ErrnoException` in case of error.\n \n     version (CRuntime_DigitalMars) {} else // Not implemented\n     version (CRuntime_Microsoft) {} else // Not implemented\n-    @system unittest // Test changing mode\n+    @safe unittest // Test changing mode\n     {\n         import std.exception : assertThrown, assertNotThrown;\n         static import std.file;\n@@ -1853,15 +1853,15 @@ void main()\n }\n ---\n */\n-    S readln(S = string)(dchar terminator = '\\n')\n+    S readln(S = string)(dchar terminator = '\\n') @safe\n     if (isSomeString!S)\n     {\n         Unqual!(ElementEncodingType!S)[] buf;\n         readln(buf, terminator);\n-        return cast(S) buf;\n+        return (() @trusted => cast(S) buf)();\n     }\n \n-    @system unittest\n+    @safe unittest\n     {\n         import std.algorithm.comparison : equal;\n         static import std.file;\n@@ -1885,7 +1885,7 @@ void main()\n         }}\n     }\n \n-    @system unittest\n+    @safe unittest\n     {\n         static import std.file;\n         import std.typecons : Tuple;\n@@ -1984,7 +1984,7 @@ void main()\n This is actually what $(LREF byLine) does internally, so its usage\n is recommended if you want to process a complete file.\n */\n-    size_t readln(C)(ref C[] buf, dchar terminator = '\\n')\n+    size_t readln(C)(ref C[] buf, dchar terminator = '\\n') @safe\n     if (isSomeChar!C && is(Unqual!C == C) && !is(C == enum))\n     {\n         import std.exception : enforce;\n@@ -2020,9 +2020,8 @@ is recommended if you want to process a complete file.\n         }\n     }\n \n-    @system unittest\n+    @safe unittest\n     {\n-        // @system due to readln\n         static import std.file;\n         auto deleteme = testFilename();\n         std.file.write(deleteme, \"123\\n456789\");\n@@ -2039,7 +2038,7 @@ is recommended if you want to process a complete file.\n     }\n \n     // https://issues.dlang.org/show_bug.cgi?id=15293\n-    @system unittest\n+    @safe unittest\n     {\n         // @system due to readln\n         static import std.file;\n@@ -2063,7 +2062,7 @@ is recommended if you want to process a complete file.\n     }\n \n /** ditto */\n-    size_t readln(C, R)(ref C[] buf, R terminator)\n+    size_t readln(C, R)(ref C[] buf, R terminator) @safe\n     if (isSomeChar!C && is(Unqual!C == C) && !is(C == enum) &&\n         isBidirectionalRange!R && is(typeof(terminator.front == dchar.init)))\n     {\n@@ -2093,7 +2092,7 @@ is recommended if you want to process a complete file.\n         return buf.length;\n     }\n \n-    @system unittest\n+    @safe unittest\n     {\n         static import std.file;\n         import std.typecons : Tuple;\n@@ -3735,9 +3734,8 @@ void main()\n     assert(f.tell == 0);\n }\n \n-@system unittest\n+@safe unittest\n {\n-    // @system due to readln\n     static import std.file;\n     import std.range : chain, only, repeat;\n     import std.range.primitives : isOutputRange;\n@@ -5169,13 +5167,13 @@ Initialize with a message and an error code.\n     }\n \n /** Convenience functions that throw an `StdioException`. */\n-    static void opCall(string msg)\n+    static void opCall(string msg) @safe\n     {\n         throw new StdioException(msg);\n     }\n \n /// ditto\n-    static void opCall()\n+    static void opCall() @safe\n     {\n         throw new StdioException(null, core.stdc.errno.errno);\n     }\n@@ -5388,7 +5386,7 @@ private struct ReadlnAppender\n     size_t pos;\n     bool safeAppend = false;\n \n-    void initialize(char[] b)\n+    void initialize(char[] b) @safe\n     {\n         buf = b;\n         pos = 0;\n@@ -5445,7 +5443,7 @@ private struct ReadlnAppender\n         foreach (c; ubuf)\n             buf.ptr[pos++] = c;\n     }\n-    void putonly(char[] b) @trusted\n+    void putonly(const char[] b) @trusted\n     {\n         import core.stdc.string : memcpy;\n         assert(pos == 0);   // assume this is the only put call\n@@ -5457,28 +5455,60 @@ private struct ReadlnAppender\n     }\n }\n \n-// Private implementation of readln\n-private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orientation orientation)\n+private struct LockedFile\n {\n-    version (DIGITAL_MARS_STDIO)\n+    private @system _iobuf* fp;\n+\n+    this(FILE* fps) @trusted\n     {\n         _FLOCK(fps);\n-        scope(exit) _FUNLOCK(fps);\n+        // Since fps is now locked, we can cast away shared\n+        fp = cast(_iobuf*) fps;\n+    }\n+\n+    @disable this();\n+    @disable this(this);\n+    @disable void opAssign(LockedFile);\n \n-        /* Since fps is now locked, we can create an \"unshared\" version\n-         * of fp.\n-         */\n-        auto fp = cast(_iobuf*) fps;\n+    // these use unlocked fgetc calls\n+    @trusted fgetc() { return _FGETC(fp); }\n+    @trusted fgetwc() { return _FGETWC(fp); }\n \n+    ~this() @trusted\n+    {\n+        _FUNLOCK(cast(FILE*) fp);\n+    }\n+}\n+\n+@safe unittest\n+{\n+    void f() @safe\n+    {\n+        FILE* fps;\n+        auto lf = LockedFile(fps);\n+        static assert(!__traits(compiles, lf = LockedFile(fps)));\n+        version (ShouldFail)\n+        {\n+            lf.fps = null; // error with -preview=systemVariables\n+        }\n+    }\n+}\n+\n+// Private implementation of readln\n+private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orientation orientation) @safe\n+{\n+    version (DIGITAL_MARS_STDIO)\n+    return () @trusted {\n+        auto lf = LockedFile(fps);\n         ReadlnAppender app;\n         app.initialize(buf);\n \n-        if (__fhnd_info[fp._file] & FHND_WCHAR)\n+        if (__fhnd_info[lf.fp._file] & FHND_WCHAR)\n         {   /* Stream is in wide characters.\n              * Read them and convert to chars.\n              */\n             static assert(wchar_t.sizeof == 2);\n-            for (int c = void; (c = _FGETWC(fp)) != -1; )\n+            for (int c = void; (c = lf.fgetwc()) != -1; )\n             {\n                 if ((c & ~0x7F) == 0)\n                 {\n@@ -5491,7 +5521,7 @@ private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orie\n                     if (c >= 0xD800 && c <= 0xDBFF)\n                     {\n                         int c2 = void;\n-                        if ((c2 = _FGETWC(fp)) != -1 ||\n+                        if ((c2 = lf.fgetwc()) != -1 ||\n                                 c2 < 0xDC00 && c2 > 0xDFFF)\n                         {\n                             StdioException(\"unpaired UTF-16 surrogate\");\n@@ -5504,16 +5534,15 @@ private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orie\n             if (ferror(fps))\n                 StdioException();\n         }\n-\n-        else if (fp._flag & _IONBF)\n+        else if (lf.fp._flag & _IONBF)\n         {\n             /* Use this for unbuffered I/O, when running\n              * across buffer boundaries, or for any but the common\n              * cases.\n              */\n         L1:\n             int c;\n-            while ((c = _FGETC(fp)) != -1)\n+            while ((c = lf.fgetc()) != -1)\n             {\n                 app.putchar(cast(char) c);\n                 if (c == terminator)\n@@ -5529,10 +5558,10 @@ private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orie\n         }\n         else\n         {\n-            int u = fp._cnt;\n-            char* p = fp._ptr;\n+            int u = lf.fp._cnt;\n+            char* p = lf.fp._ptr;\n             int i;\n-            if (fp._flag & _IOTRAN)\n+            if (lf.fp._flag & _IOTRAN)\n             {   /* Translated mode ignores \\r and treats ^Z as end-of-file\n                  */\n                 char c;\n@@ -5574,28 +5603,22 @@ private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orie\n                 }\n                 app.putonly(p[0 .. i]);\n             }\n-            fp._cnt -= i;\n-            fp._ptr += i;\n+            lf.fp._cnt -= i;\n+            lf.fp._ptr += i;\n         }\n \n         buf = app.data;\n         return buf.length;\n-    }\n+    }();\n     else version (MICROSOFT_STDIO)\n     {\n-        _FLOCK(fps);\n-        scope(exit) _FUNLOCK(fps);\n-\n-        /* Since fps is now locked, we can create an \"unshared\" version\n-         * of fp.\n-         */\n-        auto fp = cast(_iobuf*) fps;\n+        auto lf = LockedFile(fps);\n \n         ReadlnAppender app;\n         app.initialize(buf);\n \n         int c;\n-        while ((c = _FGETC(fp)) != -1)\n+        while ((c = lf.fgetc()) != -1)\n         {\n             app.putchar(cast(char) c);\n             if (c == terminator)\n@@ -5613,21 +5636,18 @@ private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orie\n     }\n     else static if (__traits(compiles, core.sys.posix.stdio.getdelim))\n     {\n-        import core.stdc.stdlib : free;\n-        import core.stdc.wchar_ : fwide;\n-\n         if (orientation == File.Orientation.wide)\n         {\n+            import core.stdc.wchar_ : fwide;\n+\n+            auto lf = LockedFile(fps);\n             /* Stream is in wide characters.\n              * Read them and convert to chars.\n              */\n-            _FLOCK(fps);\n-            scope(exit) _FUNLOCK(fps);\n-            auto fp = cast(_iobuf*) fps;\n             version (Windows)\n             {\n                 buf.length = 0;\n-                for (int c = void; (c = _FGETWC(fp)) != -1; )\n+                for (int c = void; (c = lf.fgetwc()) != -1; )\n                 {\n                     if ((c & ~0x7F) == 0)\n                     {   buf ~= c;\n@@ -5639,7 +5659,7 @@ private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orie\n                         if (c >= 0xD800 && c <= 0xDBFF)\n                         {\n                             int c2 = void;\n-                            if ((c2 = _FGETWC(fp)) != -1 ||\n+                            if ((c2 = lf.fgetwc()) != -1 ||\n                                     c2 < 0xDC00 && c2 > 0xDFFF)\n                             {\n                                 StdioException(\"unpaired UTF-16 surrogate\");\n@@ -5650,14 +5670,14 @@ private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orie\n                         encode(buf, c);\n                     }\n                 }\n-                if (ferror(fp))\n+                if (ferror(fps))\n                     StdioException();\n                 return buf.length;\n             }\n             else version (Posix)\n             {\n                 buf.length = 0;\n-                for (int c; (c = _FGETWC(fp)) != -1; )\n+                for (int c; (c = lf.fgetwc()) != -1; )\n                 {\n                     import std.utf : encode;\n \n@@ -5677,47 +5697,49 @@ private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orie\n                 static assert(0);\n             }\n         }\n+        return () @trusted {\n+            import core.stdc.stdlib : free;\n \n-        static char *lineptr = null;\n-        static size_t n = 0;\n-        scope(exit)\n-        {\n-            if (n > 128 * 1024)\n+            static char *lineptr = null;\n+            static size_t n = 0;\n+            scope(exit)\n             {\n-                // Bound memory used by readln\n-                free(lineptr);\n-                lineptr = null;\n-                n = 0;\n+                if (n > 128 * 1024)\n+                {\n+                    // Bound memory used by readln\n+                    free(lineptr);\n+                    lineptr = null;\n+                    n = 0;\n+                }\n             }\n-        }\n \n-        auto s = core.sys.posix.stdio.getdelim(&lineptr, &n, terminator, fps);\n-        if (s < 0)\n-        {\n-            if (ferror(fps))\n-                StdioException();\n-            buf.length = 0;                // end of file\n-            return 0;\n-        }\n+            const s = core.sys.posix.stdio.getdelim(&lineptr, &n, terminator, fps);\n+            if (s < 0)\n+            {\n+                if (ferror(fps))\n+                    StdioException();\n+                buf.length = 0;                // end of file\n+                return 0;\n+            }\n \n-        if (s <= buf.length)\n-        {\n-            buf = buf[0 .. s];\n-            buf[] = lineptr[0 .. s];\n-        }\n-        else\n-        {\n-            buf = lineptr[0 .. s].dup;\n-        }\n-        return s;\n+            const line = lineptr[0 .. s];\n+            if (s <= buf.length)\n+            {\n+                buf = buf[0 .. s];\n+                buf[] = line;\n+            }\n+            else\n+            {\n+                buf = line.dup;\n+            }\n+            return s;\n+        }();\n     }\n     else // version (NO_GETDELIM)\n     {\n         import core.stdc.wchar_ : fwide;\n \n-        _FLOCK(fps);\n-        scope(exit) _FUNLOCK(fps);\n-        auto fp = cast(_iobuf*) fps;\n+        auto lf = LockedFile(fps);\n         if (orientation == File.Orientation.wide)\n         {\n             /* Stream is in wide characters.\n@@ -5726,7 +5748,7 @@ private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orie\n             version (Windows)\n             {\n                 buf.length = 0;\n-                for (int c; (c = _FGETWC(fp)) != -1; )\n+                for (int c; (c = lf.fgetwc()) != -1; )\n                 {\n                     if ((c & ~0x7F) == 0)\n                     {   buf ~= c;\n@@ -5738,7 +5760,7 @@ private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orie\n                         if (c >= 0xD800 && c <= 0xDBFF)\n                         {\n                             int c2 = void;\n-                            if ((c2 = _FGETWC(fp)) != -1 ||\n+                            if ((c2 = lf.fgetwc()) != -1 ||\n                                     c2 < 0xDC00 && c2 > 0xDFFF)\n                             {\n                                 StdioException(\"unpaired UTF-16 surrogate\");\n@@ -5749,15 +5771,15 @@ private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orie\n                         encode(buf, c);\n                     }\n                 }\n-                if (ferror(fp))\n+                if (ferror(fps))\n                     StdioException();\n                 return buf.length;\n             }\n             else version (Posix)\n             {\n                 import std.utf : encode;\n                 buf.length = 0;\n-                for (int c; (c = _FGETWC(fp)) != -1; )\n+                for (int c; (c = lf.fgetwc()) != -1; )\n                 {\n                     if ((c & ~0x7F) == 0)\n                         buf ~= cast(char) c;\n@@ -5780,7 +5802,7 @@ private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orie\n         // First, fill the existing buffer\n         for (size_t bufPos = 0; bufPos < buf.length; )\n         {\n-            immutable c = _FGETC(fp);\n+            immutable c = lf.fgetc();\n             if (c == -1)\n             {\n                 buf.length = bufPos;\n@@ -5795,7 +5817,7 @@ private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orie\n             }\n         }\n         // Then, append to it\n-        for (int c; (c = _FGETC(fp)) != -1; )\n+        for (int c; (c = lf.fgetc()) != -1; )\n         {\n             buf ~= cast(char) c;\n             if (c == terminator)"}, {"sha": "4e76156b1cbcaaffc9cce195f2bfa333bce04581", "filename": "libphobos/src/std/sumtype.d", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fsumtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fsumtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fsumtype.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1952,10 +1952,10 @@ private template matchImpl(Flag!\"exhaustive\" exhaustive, handlers...)\n         // An array that maps caseIds to handler indices (\"hids\").\n         enum matches = ()\n         {\n-            size_t[numCases] matches;\n+            size_t[numCases] result;\n \n             // Workaround for https://issues.dlang.org/show_bug.cgi?id=19561\n-            foreach (ref match; matches)\n+            foreach (ref match; result)\n             {\n                 match = noMatch;\n             }\n@@ -1966,15 +1966,15 @@ private template matchImpl(Flag!\"exhaustive\" exhaustive, handlers...)\n                 {\n                     static if (canMatch!(handler, valueTypes!caseId))\n                     {\n-                        if (matches[caseId] == noMatch)\n+                        if (result[caseId] == noMatch)\n                         {\n-                            matches[caseId] = hid;\n+                            result[caseId] = hid;\n                         }\n                     }\n                 }\n             }\n \n-            return matches;\n+            return result;\n         }();\n \n         import std.algorithm.searching : canFind;"}, {"sha": "e5f305bf83c7d0eefe4a9a200bd597499f34892c", "filename": "libphobos/src/std/traits.d", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ftraits.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -889,10 +889,10 @@ private template fqnType(T,\n             );\n         }\n     }\n-    else static if (isPointer!T)\n+    else static if (is(T : U*, U))\n     {\n         enum fqnType = chain!(\n-            fqnType!(PointerTarget!T, qualifiers) ~ \"*\"\n+            fqnType!(U, qualifiers) ~ \"*\"\n         );\n     }\n     else static if (is(T : __vector(V[N]), V, size_t N))\n@@ -3925,8 +3925,8 @@ template hasStaticMember(T, string member)\n {\n     static if (__traits(hasMember, T, member))\n     {\n-        static if (isPointer!T)\n-            alias U = PointerTarget!T;\n+        static if (is(T : V*, V))\n+            alias U = V;\n         else\n             alias U = T;\n \n@@ -5446,8 +5446,8 @@ private template isStorageClassImplicitlyConvertible(From, To)\n {\n     alias Pointify(T) = void*;\n \n-    enum isStorageClassImplicitlyConvertible = isImplicitlyConvertible!(\n-            ModifyTypePreservingTQ!(Pointify, From),\n+    enum isStorageClassImplicitlyConvertible = is(\n+            ModifyTypePreservingTQ!(Pointify, From) :\n             ModifyTypePreservingTQ!(Pointify,   To) );\n }\n \n@@ -7138,7 +7138,7 @@ enum bool isSIMDVector(T) = is(T : __vector(V[N]), V, size_t N);\n /**\n  * Detect whether type `T` is a pointer.\n  */\n-enum bool isPointer(T) = is(T == U*, U) && __traits(isScalar, T);\n+enum bool isPointer(T) = is(T == U*, U);\n \n ///\n @safe unittest\n@@ -8847,6 +8847,14 @@ version (StdUnittest)\n     static assert(__traits(compiles, getSymbolsByUDA!(mixin(__MODULE__), \"Issue20054\")));\n }\n \n+private template isAliasSeq(Args...)\n+{\n+    static if (Args.length != 1)\n+        enum isAliasSeq = true;\n+    else\n+        enum isAliasSeq = false;\n+}\n+\n private template getSymbolsByUDAImpl(alias symbol, alias attribute, names...)\n {\n     import std.meta : Alias, AliasSeq, Filter;\n@@ -8868,12 +8876,12 @@ private template getSymbolsByUDAImpl(alias symbol, alias attribute, names...)\n             alias member = __traits(getMember, symbol, names[0]);\n \n             // Filtering not compiled members such as alias of basic types.\n-            static if (!__traits(compiles, hasUDA!(member, attribute)))\n+            static if (isAliasSeq!member || isType!member)\n             {\n                 alias getSymbolsByUDAImpl = tail;\n             }\n-            // Get overloads for functions, in case different overloads have different sets of UDAs.\n-            else static if (isFunction!member)\n+            // If a symbol is overloaded, get UDAs for each overload (including templated overlaods).\n+            else static if (__traits(getOverloads, symbol, names[0], true).length > 0)\n             {\n                 enum hasSpecificUDA(alias member) = hasUDA!(member, attribute);\n                 alias overloadsWithUDA = Filter!(hasSpecificUDA, __traits(getOverloads, symbol, names[0]));"}, {"sha": "e83b6171334d6c266b7affddeab1eeedc335ff67", "filename": "libphobos/src/std/typecons.d", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ftypecons.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -5536,7 +5536,7 @@ private static:\n     }\n \n     // handle each overload set\n-    private string generateCodeForOverloadSet(alias oset)() @property\n+    string generateCodeForOverloadSet(alias oset)() @property\n     {\n         string code = \"\";\n \n@@ -5666,7 +5666,7 @@ private static:\n      * \"ref int a0, real a1, ...\"\n      */\n     static struct GenParams { string imports, params; }\n-    private GenParams generateParameters(string myFuncInfo, func...)()\n+    GenParams generateParameters(string myFuncInfo, func...)()\n     {\n         alias STC = ParameterStorageClass;\n         alias stcs = ParameterStorageClassTuple!(func);\n@@ -5716,7 +5716,7 @@ private static:\n \n     // Returns D code which enumerates n parameter variables using comma as the\n     // separator.  \"a0, a1, a2, a3\"\n-    private string enumerateParameters(size_t n)() @property\n+    string enumerateParameters(size_t n)() @property\n     {\n         string params = \"\";\n \n@@ -8782,7 +8782,7 @@ if (alignment > 0 && !((alignment - 1) & alignment))\n     {\n         void test(size_t size)\n         {\n-            import core.stdc.stdlib;\n+            import core.stdc.stdlib : alloca;\n             cast(void) alloca(size);\n             alignmentTest();\n         }\n@@ -9253,7 +9253,7 @@ public:\n     }\n \n     Base opCast(B)() const\n-        if (isImplicitlyConvertible!(Base, B))\n+        if (is(Base : B))\n     {\n         return mValue;\n     }"}, {"sha": "c31912a60d05da1596647e8da17392562b3353e5", "filename": "libphobos/src/std/uni/package.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Funi%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Funi%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Funi%2Fpackage.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -6271,8 +6271,8 @@ struct UnicodeSetParser(Range)\n         {\n             if (casefold_)\n             {\n-                auto range = simpleCaseFoldings(ch);\n-                foreach (v; range)\n+                auto foldings = simpleCaseFoldings(ch);\n+                foreach (v; foldings)\n                     set |= v;\n             }\n             else"}, {"sha": "7a0556de8227d3ee46f217f8b78a54eab27bcc34", "filename": "libphobos/src/std/utf.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Futf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Futf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Futf.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -66,7 +66,7 @@ import std.exception : basicExceptionCtors;\n import core.exception : UnicodeException;\n import std.meta : AliasSeq;\n import std.range;\n-import std.traits : isAutodecodableString, isConvertibleToString, isPointer,\n+import std.traits : isAutodecodableString, isConvertibleToString,\n     isSomeChar, isSomeString, isStaticArray, Unqual;\n import std.typecons : Flag, Yes, No;\n \n@@ -3136,7 +3136,7 @@ private T toUTFImpl(T, S)(scope S s)\n     collection cycle and cause a nasty bug when the C code tries to use it.\n   +/\n template toUTFz(P)\n-if (isPointer!P && isSomeChar!(typeof(*P.init)))\n+if (is(P : C*, C) && isSomeChar!C)\n {\n     P toUTFz(S)(S str) @safe pure\n     if (isSomeString!S)"}, {"sha": "7ee1f7afc9880a1025d4c0fd814771b046702d01", "filename": "libphobos/src/std/windows/registry.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fwindows%2Fregistry.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d799f0aed18be25a5c908499b6411ab6d06b78c/libphobos%2Fsrc%2Fstd%2Fwindows%2Fregistry.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fwindows%2Fregistry.d?ref=6d799f0aed18be25a5c908499b6411ab6d06b78c", "patch": "@@ -1856,7 +1856,7 @@ private:\n         if (i++ > 0)\n             break;\n \n-        import core.memory;\n+        import core.memory : GC;\n         GC.collect();\n     }\n     assert(i == 2);"}]}