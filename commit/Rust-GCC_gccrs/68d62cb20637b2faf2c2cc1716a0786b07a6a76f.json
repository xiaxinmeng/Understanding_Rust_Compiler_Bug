{"sha": "68d62cb20637b2faf2c2cc1716a0786b07a6a76f", "node_id": "C_kwDOANBUbNoAKDY4ZDYyY2IyMDYzN2IyZmFmMmMyY2MxNzE2YTA3ODZiMDdhNmE3NmY", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2021-11-07T13:39:18Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2021-11-12T12:10:55Z"}, "message": "fortran: Ignore unused args in scalarization [PR97896]\n\nThe KIND argument of the INDEX intrinsic is a compile time constant\nthat is used at compile time only to resolve to a kind-specific library\nfunction.  That argument is otherwise completely ignored at runtime, and there is\nno code generated for it as the library procedure has no kind argument.\nThis confuses the scalarizer which expects to see every argument\nof elemental functions used when calling a procedure.\nThis change removes the argument from the scalarization lists\nat the beginning of the scalarization process, so that the argument\nis completely ignored.\nThis also reverts the existing workaround\n(commit d09847357b965a2c2cda063827ce362d4c9c86f2 except for its testcase).\n\n\tPR fortran/97896\n\ngcc/fortran/ChangeLog:\n\t* intrinsic.c (add_sym_4ind): Remove.\n\t(add_functions): Use add_sym4 instead of add_sym4ind.\n\tDon\u2019t special case the index intrinsic.\n\t* iresolve.c (gfc_resolve_index_func): Use the individual arguments\n\tdirectly instead of the full argument list.\n\t* intrinsic.h (gfc_resolve_index_func): Update the declaration\n\taccordingly.\n\t* trans-decl.c (gfc_get_extern_function_decl): Don\u2019t modify the\n\tlist of arguments in the case of the index intrinsic.\n\t* trans-array.h (gfc_get_intrinsic_for_expr,\n\tgfc_get_proc_ifc_for_expr): New.\n\t* trans-array.c (gfc_get_intrinsic_for_expr,\n\targ_evaluated_for_scalarization): New.\n\t(gfc_walk_elemental_function_args): Add intrinsic procedure\n\tas argument.  Count arguments.  Check arg_evaluated_for_scalarization.\n\t* trans-intrinsic.c (gfc_walk_intrinsic_function): Update call.\n\t* trans-stmt.c (get_intrinsic_for_code): New.\n\t(gfc_trans_call): Update call.\n\ngcc/testsuite/ChangeLog:\n\t* gfortran.dg/index_5.f90: New.", "tree": {"sha": "2fe334a41d370b81f28b605b8c507b43310c69ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fe334a41d370b81f28b605b8c507b43310c69ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68d62cb20637b2faf2c2cc1716a0786b07a6a76f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68d62cb20637b2faf2c2cc1716a0786b07a6a76f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68d62cb20637b2faf2c2cc1716a0786b07a6a76f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/comments", "author": null, "committer": null, "parents": [{"sha": "7d6da11fce054b25b50d0dec7f8d49cf22852680", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d6da11fce054b25b50d0dec7f8d49cf22852680", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d6da11fce054b25b50d0dec7f8d49cf22852680"}], "stats": {"total": 204, "additions": 121, "deletions": 83}, "files": [{"sha": "2d7d2461fd0f6cb94fcec762de92f95ca387895c", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 7, "deletions": 41, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=68d62cb20637b2faf2c2cc1716a0786b07a6a76f", "patch": "@@ -889,39 +889,6 @@ add_sym_4 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt ty\n \t   (void *) 0);\n }\n \n-/* Add a symbol to the function list where the function takes 4\n-   arguments and resolution may need to change the number or\n-   arrangement of arguments. This is the case for INDEX, which needs\n-   its KIND argument removed.  */\n-\n-static void\n-add_sym_4ind (const char *name, gfc_isym_id id, enum klass cl, int actual_ok,\n-\t      bt type, int kind, int standard,\n-\t      bool (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n-\t      gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *,\n-\t\t\t\t     gfc_expr *),\n-\t      void (*resolve) (gfc_expr *, gfc_actual_arglist *),\n-\t      const char *a1, bt type1, int kind1, int optional1,\n-\t      const char *a2, bt type2, int kind2, int optional2,\n-\t      const char *a3, bt type3, int kind3, int optional3,\n-\t      const char *a4, bt type4, int kind4, int optional4 )\n-{\n-  gfc_check_f cf;\n-  gfc_simplify_f sf;\n-  gfc_resolve_f rf;\n-\n-  cf.f4 = check;\n-  sf.f4 = simplify;\n-  rf.f1m = resolve;\n-\n-  add_sym (name, id, cl, actual_ok, type, kind, standard, cf, sf, rf,\n-\t   a1, type1, kind1, optional1, INTENT_IN,\n-\t   a2, type2, kind2, optional2, INTENT_IN,\n-\t   a3, type3, kind3, optional3, INTENT_IN,\n-\t   a4, type4, kind4, optional4, INTENT_IN,\n-\t   (void *) 0);\n-}\n-\n \n /* Add a symbol to the subroutine list where the subroutine takes\n    4 arguments.  */\n@@ -2224,11 +2191,11 @@ add_functions (void)\n \n   /* The resolution function for INDEX is called gfc_resolve_index_func\n      because the name gfc_resolve_index is already used in resolve.c.  */\n-  add_sym_4ind (\"index\", GFC_ISYM_INDEX, CLASS_ELEMENTAL, ACTUAL_YES,\n-\t\tBT_INTEGER, di, GFC_STD_F77,\n-\t\tgfc_check_index, gfc_simplify_index, gfc_resolve_index_func,\n-\t\tstg, BT_CHARACTER, dc, REQUIRED, ssg, BT_CHARACTER, dc, REQUIRED,\n-\t\tbck, BT_LOGICAL, dl, OPTIONAL, kind, BT_INTEGER, di, OPTIONAL);\n+  add_sym_4 (\"index\", GFC_ISYM_INDEX, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_INTEGER, di, GFC_STD_F77,\n+\t     gfc_check_index, gfc_simplify_index, gfc_resolve_index_func,\n+\t     stg, BT_CHARACTER, dc, REQUIRED, ssg, BT_CHARACTER, dc, REQUIRED,\n+\t     bck, BT_LOGICAL, dl, OPTIONAL, kind, BT_INTEGER, di, OPTIONAL);\n \n   make_generic (\"index\", GFC_ISYM_INDEX, GFC_STD_F77);\n \n@@ -4531,10 +4498,9 @@ resolve_intrinsic (gfc_intrinsic_sym *specific, gfc_expr *e)\n \n   arg = e->value.function.actual;\n \n-  /* Special case hacks for MIN, MAX and INDEX.  */\n+  /* Special case hacks for MIN and MAX.  */\n   if (specific->resolve.f1m == gfc_resolve_max\n-      || specific->resolve.f1m == gfc_resolve_min\n-      || specific->resolve.f1m == gfc_resolve_index_func)\n+      || specific->resolve.f1m == gfc_resolve_min)\n     {\n       (*specific->resolve.f1m) (e, arg);\n       return;"}, {"sha": "fb655fb078ab4c1a02e0133dd09b665e34fd65ba", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=68d62cb20637b2faf2c2cc1716a0786b07a6a76f", "patch": "@@ -519,7 +519,8 @@ void gfc_resolve_ibits (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_ibset (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_image_index (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_image_status (gfc_expr *, gfc_expr *, gfc_expr *);\n-void gfc_resolve_index_func (gfc_expr *, gfc_actual_arglist *);\n+void gfc_resolve_index_func (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t     gfc_expr *);\n void gfc_resolve_ierrno (gfc_expr *);\n void gfc_resolve_ieor (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_ichar (gfc_expr *, gfc_expr *, gfc_expr *);"}, {"sha": "598c0409b66569793310911989460f2511fab082", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=68d62cb20637b2faf2c2cc1716a0786b07a6a76f", "patch": "@@ -1276,27 +1276,16 @@ gfc_resolve_ior (gfc_expr *f, gfc_expr *i, gfc_expr *j)\n \n \n void\n-gfc_resolve_index_func (gfc_expr *f, gfc_actual_arglist *a)\n+gfc_resolve_index_func (gfc_expr *f, gfc_expr *str,\n+\t\t\tgfc_expr *sub_str ATTRIBUTE_UNUSED, gfc_expr *back,\n+\t\t\tgfc_expr *kind)\n {\n   gfc_typespec ts;\n   gfc_clear_ts (&ts);\n-  gfc_expr *str, *back, *kind;\n-  gfc_actual_arglist *a_sub_str, *a_back, *a_kind;\n-\n-  if (f->do_not_resolve_again)\n-    return;\n-\n-  a_sub_str = a->next;\n-  a_back = a_sub_str->next;\n-  a_kind = a_back->next;\n-\n-  str = a->expr;\n-  back = a_back->expr;\n-  kind = a_kind->expr;\n \n   f->ts.type = BT_INTEGER;\n   if (kind)\n-    f->ts.kind = mpz_get_si ((kind)->value.integer);\n+    f->ts.kind = mpz_get_si (kind->value.integer);\n   else\n     f->ts.kind = gfc_default_integer_kind;\n \n@@ -1311,8 +1300,6 @@ gfc_resolve_index_func (gfc_expr *f, gfc_actual_arglist *a)\n \n   f->value.function.name\n     = gfc_get_string (\"__index_%d_i%d\", str->ts.kind, f->ts.kind);\n-\n-  f->do_not_resolve_again = 1;\n }\n \n "}, {"sha": "793218544980749a402c4147a77c838c7119297e", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=68d62cb20637b2faf2c2cc1716a0786b07a6a76f", "patch": "@@ -11460,13 +11460,67 @@ gfc_get_proc_ifc_for_expr (gfc_expr *procedure_ref)\n }\n \n \n+/* Given an expression referring to an intrinsic function call,\n+   return the intrinsic symbol.  */\n+\n+gfc_intrinsic_sym *\n+gfc_get_intrinsic_for_expr (gfc_expr *call)\n+{\n+  if (call == NULL)\n+    return NULL;\n+\n+  /* Normal procedure case.  */\n+  if (call->expr_type == EXPR_FUNCTION)\n+    return call->value.function.isym;\n+  else\n+    return NULL;\n+}\n+\n+\n+/* Indicates whether an argument to an intrinsic function should be used in\n+   scalarization.  It is usually the case, except for some intrinsics\n+   requiring the value to be constant, and using the value at compile time only.\n+   As the value is not used at runtime in those cases, we don\u2019t produce code\n+   for it, and it should not be visible to the scalarizer.\n+   FUNCTION is the intrinsic function being called, ACTUAL_ARG is the actual\n+   argument being examined in that call, and ARG_NUM the index number\n+   of ACTUAL_ARG in the list of arguments.\n+   The intrinsic procedure\u2019s dummy argument associated with ACTUAL_ARG is\n+   identified using the name in ACTUAL_ARG if it is present (that is: if it\u2019s\n+   a keyword argument), otherwise using ARG_NUM.  */\n+\n+static bool\n+arg_evaluated_for_scalarization (gfc_intrinsic_sym *function,\n+\t\t\t\t gfc_actual_arglist &actual_arg, int arg_num)\n+{\n+  if (function != NULL)\n+    {\n+      switch (function->id)\n+\t{\n+\t  case GFC_ISYM_INDEX:\n+\t    if ((actual_arg.name == NULL && arg_num == 3)\n+\t\t|| (actual_arg.name != NULL\n+\t\t    && strcmp (\"kind\", actual_arg.name) == 0))\n+\t      return false;\n+\t  /* Fallthrough.  */\n+\n+\t  default:\n+\t    break;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+\n /* Walk the arguments of an elemental function.\n    PROC_EXPR is used to check whether an argument is permitted to be absent.  If\n    it is NULL, we don't do the check and the argument is assumed to be present.\n */\n \n gfc_ss *\n gfc_walk_elemental_function_args (gfc_ss * ss, gfc_actual_arglist *arg,\n+\t\t\t\t  gfc_intrinsic_sym *intrinsic_sym,\n \t\t\t\t  gfc_symbol *proc_ifc, gfc_ss_type type)\n {\n   gfc_formal_arglist *dummy_arg;\n@@ -11483,10 +11537,13 @@ gfc_walk_elemental_function_args (gfc_ss * ss, gfc_actual_arglist *arg,\n   else\n     dummy_arg = NULL;\n \n+  int arg_num = 0;\n   scalar = 1;\n   for (; arg; arg = arg->next)\n     {\n-      if (!arg->expr || arg->expr->expr_type == EXPR_NULL)\n+      if (!arg->expr\n+\t  || arg->expr->expr_type == EXPR_NULL\n+\t  || !arg_evaluated_for_scalarization (intrinsic_sym, *arg, arg_num))\n \tgoto loop_continue;\n \n       newss = gfc_walk_subexpr (head, arg->expr);\n@@ -11519,6 +11576,7 @@ gfc_walk_elemental_function_args (gfc_ss * ss, gfc_actual_arglist *arg,\n         }\n \n loop_continue:\n+      arg_num++;\n       if (dummy_arg != NULL)\n \tdummy_arg = dummy_arg->next;\n     }\n@@ -11579,6 +11637,7 @@ gfc_walk_function_expr (gfc_ss * ss, gfc_expr * expr)\n \n       ss = gfc_walk_elemental_function_args (old_ss,\n \t\t\t\t\t     expr->value.function.actual,\n+\t\t\t\t\t     gfc_get_intrinsic_for_expr (expr),\n \t\t\t\t\t     gfc_get_proc_ifc_for_expr (expr),\n \t\t\t\t\t     GFC_SS_REFERENCE);\n       if (ss != old_ss"}, {"sha": "8f806c32f80b987c6bde9d36836f8d4ccaba4d0a", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=68d62cb20637b2faf2c2cc1716a0786b07a6a76f", "patch": "@@ -76,6 +76,8 @@ void gfc_trans_static_array_pointer (gfc_symbol *);\n \n /* Get the procedure interface for a function call.  */\n gfc_symbol *gfc_get_proc_ifc_for_expr (gfc_expr *);\n+/* Get the intrinsic symbol for an intrinsic function call.  */\n+gfc_intrinsic_sym *gfc_get_intrinsic_for_expr (gfc_expr *);\n /* Generate scalarization information for an expression.  */\n gfc_ss *gfc_walk_expr (gfc_expr *);\n /* Workhorse for gfc_walk_expr.  */\n@@ -84,6 +86,7 @@ gfc_ss *gfc_walk_subexpr (gfc_ss *, gfc_expr *);\n gfc_ss *gfc_walk_array_ref (gfc_ss *, gfc_expr *, gfc_ref * ref);\n /* Walk the arguments of an elemental function.  */\n gfc_ss *gfc_walk_elemental_function_args (gfc_ss *, gfc_actual_arglist *,\n+\t\t\t\t\t  gfc_intrinsic_sym *,\n \t\t\t\t\t  gfc_symbol *, gfc_ss_type);\n /* Walk an intrinsic function.  */\n gfc_ss *gfc_walk_intrinsic_function (gfc_ss *, gfc_expr *,"}, {"sha": "cb7f684d52cb9b4f26125a71678ef2cfaeefcfb8", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=68d62cb20637b2faf2c2cc1716a0786b07a6a76f", "patch": "@@ -42,7 +42,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans-types.h\"\n #include \"trans-array.h\"\n #include \"trans-const.h\"\n-#include \"intrinsic.h\" \t\t/* For gfc_resolve_index_func.  */\n /* Only for gfc_trans_code.  Shouldn't need to include this.  */\n #include \"trans-stmt.h\"\n #include \"gomp-constants.h\"\n@@ -2267,28 +2266,7 @@ gfc_get_extern_function_decl (gfc_symbol * sym, gfc_actual_arglist *actual_args,\n \t\t{\n \t\t  /* All specific intrinsics take less than 5 arguments.  */\n \t\t  gcc_assert (isym->formal->next->next->next->next == NULL);\n-\t\t  if (isym->resolve.f1m == gfc_resolve_index_func)\n-\t\t    {\n-\t\t      /* gfc_resolve_index_func is special because it takes a\n-\t\t\t gfc_actual_arglist instead of individual arguments.  */\n-\t\t      gfc_actual_arglist *a, *n;\n-\t\t      int i;\n-\t\t      a = gfc_get_actual_arglist();\n-\t\t      n = a;\n-\n-\t\t      for (i = 0; i < 4; i++)\n-\t\t\t{\n-\t\t\t  n->next = gfc_get_actual_arglist();\n-\t\t\t  n = n->next;\n-\t\t\t}\n-\n-\t\t      a->expr = &argexpr;\n-\t\t      isym->resolve.f1m (&e, a);\n-\t\t      a->expr = NULL;\n-\t\t      gfc_free_actual_arglist (a);\n-\t\t    }\n-\t\t  else\n-\t\t    isym->resolve.f4 (&e, &argexpr, NULL, NULL, NULL);\n+\t\t  isym->resolve.f4 (&e, &argexpr, NULL, NULL, NULL);\n \t\t}\n \t    }\n \t}"}, {"sha": "3f867911af58025bc6bdfb96fd2bac39a6be63b2", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=68d62cb20637b2faf2c2cc1716a0786b07a6a76f", "patch": "@@ -11084,6 +11084,7 @@ gfc_walk_intrinsic_function (gfc_ss * ss, gfc_expr * expr,\n \n   if (isym->elemental)\n     return gfc_walk_elemental_function_args (ss, expr->value.function.actual,\n+\t\t\t\t\t     expr->value.function.isym,\n \t\t\t\t\t     NULL, GFC_SS_SCALAR);\n \n   if (expr->rank == 0)"}, {"sha": "bdf7957c4a09fbee3f185e80d0f1d67983e10a48", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=68d62cb20637b2faf2c2cc1716a0786b07a6a76f", "patch": "@@ -356,6 +356,25 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n }\n \n \n+/* Given an executable statement referring to an intrinsic function call,\n+   returns the intrinsic symbol.  */\n+\n+static gfc_intrinsic_sym *\n+get_intrinsic_for_code (gfc_code *code)\n+{\n+  if (code->op == EXEC_CALL)\n+    {\n+      gfc_intrinsic_sym * const isym = code->resolved_isym;\n+      if (isym)\n+\treturn isym;\n+      else\n+\treturn gfc_get_intrinsic_for_expr (code->expr1);\n+    }\n+\n+  return NULL;\n+}\n+\n+\n /* Get the interface symbol for the procedure corresponding to the given call.\n    We can't get the procedure symbol directly as we have to handle the case\n    of (deferred) type-bound procedures.  */\n@@ -402,6 +421,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n   ss = gfc_ss_terminator;\n   if (code->resolved_sym->attr.elemental)\n     ss = gfc_walk_elemental_function_args (ss, code->ext.actual,\n+\t\t\t\t\t   get_intrinsic_for_code (code),\n \t\t\t\t\t   get_proc_ifc_for_call (code),\n \t\t\t\t\t   GFC_SS_REFERENCE);\n "}, {"sha": "e039455d1753c020942f420f365fcd55b78e096c", "filename": "gcc/testsuite/gfortran.dg/index_5.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ftestsuite%2Fgfortran.dg%2Findex_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d62cb20637b2faf2c2cc1716a0786b07a6a76f/gcc%2Ftestsuite%2Fgfortran.dg%2Findex_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Findex_5.f90?ref=68d62cb20637b2faf2c2cc1716a0786b07a6a76f", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+!\n+! PR fortran/97896\n+! An ICE occured with INDEX when the KIND argument was present\n+! because of a mismatch between the number of arguments expected\n+! during the scalarization process and the number of arguments actually\n+! used.\n+!\n+! Test contributed by Harald Anlauf <anlauf@gcc.gnu.org>, based on an initial\n+! submission by G. Steinmetz <gscfq@t-online.de>.\n+\n+program p\n+  implicit none\n+  logical    :: a(2)\n+  integer    :: b(2)\n+  integer(8) :: d(2)\n+  b = index ('xyxyz','yx', back=a)\n+  b = index ('xyxyz','yx', back=a, kind=4)\n+  d = index ('xyxyz','yx', back=a, kind=8)\n+  b = index ('xyxyz','yx', back=a, kind=8)\n+  d = index ('xyxyz','yx', back=a, kind=4)\n+end\n+"}]}