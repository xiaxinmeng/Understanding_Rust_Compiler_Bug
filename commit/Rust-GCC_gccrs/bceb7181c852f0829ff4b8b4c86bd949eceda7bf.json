{"sha": "bceb7181c852f0829ff4b8b4c86bd949eceda7bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNlYjcxODFjODUyZjA4MjlmZjRiOGI0Yzg2YmQ5NDllY2VkYTdiZg==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2019-11-25T05:15:30Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2019-11-25T05:15:30Z"}, "message": "[rs6000] Refactor FP vector comparison operators\n\nThis is a subsequent patch to refactor the existing float point\nvector comparison operator supports.  The patch to fix PR92132\nsupplemented vector float point comparison by exposing the names\nfor unordered/ordered/uneq/ltgt and adding ungt/unge/unlt/unle/\nne.  As Segher pointed out, some patterns can be refactored\ntogether.  The main link on this is:\nhttps://gcc.gnu.org/ml/gcc-patches/2019-11/msg00452.html\n\ngcc/ChangeLog\n\n2019-11-25 Kewen Lin  <linkw@gcc.gnu.org>\n\n    * config/rs6000/vector.md (vector_fp_comparison_simple): New code iterator.\n    (vector_fp_comparison_complex): Likewise.\n    (vector_<code><mode> for VEC_F and vector_fp_comparison_simple): New\n    define_and_split.\n    (vector_<code><mode> for VEC_F and vector_fp_comparison_complex): Likewise.\n    (vector_lt<mode> for VEC_F): Refactor with vector_fp_comparison_simple.\n    (vector_le<mode> for VEC_F): Likewise.\n    (vector_unge<mode> for VEC_F): Likewise.\n    (vector_unle<mode> for VEC_F): Likewise.\n    (vector_ne<mode> for VEC_F): Likewise.\n    (vector_ungt<mode> for VEC_F): Likewise.\n    (vector_unlt<mode> for VEC_F): Likewise.\n    (vector_ltgt<mode> for VEC_F): Refactor with vector_fp_comparison_complex.\n    (vector_ordered<mode> for VEC_F): Likewise.\n    (vector_uneq<mode> for VEC_F): Likewise.\n    (vector_unordered<mode> for VEC_F): Likewise.\n\nFrom-SVN: r278665", "tree": {"sha": "b9e36546d879d2c54793cd54e960a304272d67a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9e36546d879d2c54793cd54e960a304272d67a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bceb7181c852f0829ff4b8b4c86bd949eceda7bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bceb7181c852f0829ff4b8b4c86bd949eceda7bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bceb7181c852f0829ff4b8b4c86bd949eceda7bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bceb7181c852f0829ff4b8b4c86bd949eceda7bf/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee1bc59e9d1b95102fb7092409885b3dcce9ea2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee1bc59e9d1b95102fb7092409885b3dcce9ea2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee1bc59e9d1b95102fb7092409885b3dcce9ea2a"}], "stats": {"total": 288, "additions": 128, "deletions": 160}, "files": [{"sha": "f37b9866a8d98ae42f9b5b0d75c160f847ce3178", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bceb7181c852f0829ff4b8b4c86bd949eceda7bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bceb7181c852f0829ff4b8b4c86bd949eceda7bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bceb7181c852f0829ff4b8b4c86bd949eceda7bf", "patch": "@@ -1,3 +1,26 @@\n+2019-11-25 Kewen Lin  <linkw@gcc.gnu.org>\n+\n+\t* config/rs6000/vector.md (vector_fp_comparison_simple): New code\n+\titerator.\n+\t(vector_fp_comparison_complex): Likewise.\n+\t(vector_<code><mode> for VEC_F and vector_fp_comparison_simple): New\n+\tdefine_and_split.\n+\t(vector_<code><mode> for VEC_F and vector_fp_comparison_complex):\n+\tLikewise.\n+\t(vector_lt<mode> for VEC_F): Refactor with\n+\tvector_fp_comparison_simple.\n+\t(vector_le<mode> for VEC_F): Likewise.\n+\t(vector_unge<mode> for VEC_F): Likewise.\n+\t(vector_unle<mode> for VEC_F): Likewise.\n+\t(vector_ne<mode> for VEC_F): Likewise.\n+\t(vector_ungt<mode> for VEC_F): Likewise.\n+\t(vector_unlt<mode> for VEC_F): Likewise.\n+\t(vector_ltgt<mode> for VEC_F): Refactor with\n+\tvector_fp_comparison_complex.\n+\t(vector_ordered<mode> for VEC_F): Likewise.\n+\t(vector_uneq<mode> for VEC_F): Likewise.\n+\t(vector_unordered<mode> for VEC_F): Likewise.\n+\n 2019-11-24  Jerry DeLisle  <jvdelisle@gcc.ngu.org>\n \n \tPR fortran/92100"}, {"sha": "75c4a99e2a0738ec699a2a35dcdcb98c57c1892d", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 105, "deletions": 160, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bceb7181c852f0829ff4b8b4c86bd949eceda7bf/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bceb7181c852f0829ff4b8b4c86bd949eceda7bf/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=bceb7181c852f0829ff4b8b4c86bd949eceda7bf", "patch": "@@ -107,6 +107,12 @@\n \t\t\t\t (smin \"smin\")\n \t\t\t\t (smax \"smax\")])\n \n+;; code iterators and attributes for vector FP comparison operators:\n+(define_code_iterator\n+  vector_fp_comparison_simple [lt le ne ungt unge unlt unle])\n+(define_code_iterator\n+  vector_fp_comparison_complex [ltgt uneq unordered ordered])\n+\n \f\n ;; Vector move instructions.  Little-endian VSX loads and stores require\n ;; special handling to circumvent \"element endianness.\"\n@@ -665,88 +671,6 @@\n   DONE;\n })\n \n-; lt(a,b) = gt(b,a)\n-(define_expand \"vector_lt<mode>\"\n-  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n-\t(lt:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n-\t\t  (match_operand:VEC_F 2 \"vfloat_operand\")))]\n-  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-{\n-  emit_insn (gen_vector_gt<mode> (operands[0], operands[2], operands[1]));\n-  DONE;\n-})\n-\n-; le(a,b) = ge(b,a)\n-(define_expand \"vector_le<mode>\"\n-  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n-\t(le:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n-\t\t  (match_operand:VEC_F 2 \"vfloat_operand\")))]\n-  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-{\n-  emit_insn (gen_vector_ge<mode> (operands[0], operands[2], operands[1]));\n-  DONE;\n-})\n-\n-; ne(a,b) = ~eq(a,b)\n-(define_expand \"vector_ne<mode>\"\n-  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n-\t(ne:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n-\t\t  (match_operand:VEC_F 2 \"vfloat_operand\")))]\n-  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-{\n-  emit_insn (gen_vector_eq<mode> (operands[0], operands[1], operands[2]));\n-  emit_insn (gen_one_cmpl<mode>2 (operands[0], operands[0]));\n-  DONE;\n-})\n-\n-; unge(a,b) = ~gt(b,a)\n-(define_expand \"vector_unge<mode>\"\n-  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n-\t(unge:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n-\t\t    (match_operand:VEC_F 2 \"vfloat_operand\")))]\n-  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-{\n-  emit_insn (gen_vector_gt<mode> (operands[0], operands[2], operands[1]));\n-  emit_insn (gen_one_cmpl<mode>2 (operands[0], operands[0]));\n-  DONE;\n-})\n-\n-; ungt(a,b) = ~ge(b,a)\n-(define_expand \"vector_ungt<mode>\"\n-  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n-\t(ungt:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n-\t\t    (match_operand:VEC_F 2 \"vfloat_operand\")))]\n-  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-{\n-  emit_insn (gen_vector_ge<mode> (operands[0], operands[2], operands[1]));\n-  emit_insn (gen_one_cmpl<mode>2 (operands[0], operands[0]));\n-  DONE;\n-})\n-\n-; unle(a,b) = ~gt(a,b)\n-(define_expand \"vector_unle<mode>\"\n-  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n-\t(unle:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n-\t\t    (match_operand:VEC_F 2 \"vfloat_operand\")))]\n-  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-{\n-  emit_insn (gen_vector_gt<mode> (operands[0], operands[1], operands[2]));\n-  emit_insn (gen_one_cmpl<mode>2 (operands[0], operands[0]));\n-  DONE;\n-})\n-\n-; unlt(a,b) = ~ge(a,b)\n-(define_expand \"vector_unlt<mode>\"\n-  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n-\t(unlt:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n-\t\t    (match_operand:VEC_F 2 \"vfloat_operand\")))]\n-  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-{\n-  emit_insn (gen_vector_ge<mode> (operands[0], operands[1], operands[2]));\n-  emit_insn (gen_one_cmpl<mode>2 (operands[0], operands[0]));\n-  DONE;\n-})\n-\n (define_expand \"vector_eq<mode>\"\n   [(set (match_operand:VEC_C 0 \"vlogical_operand\")\n \t(eq:VEC_C (match_operand:VEC_C 1 \"vlogical_operand\")\n@@ -761,13 +685,6 @@\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\")\n \n-(define_expand \"vector_ge<mode>\"\n-  [(set (match_operand:VEC_F 0 \"vlogical_operand\")\n-\t(ge:VEC_F (match_operand:VEC_F 1 \"vlogical_operand\")\n-\t\t  (match_operand:VEC_F 2 \"vlogical_operand\")))]\n-  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"\")\n-\n ; >= for integer vectors: swap operands and apply not-greater-than\n (define_expand \"vector_nlt<mode>\"\n   [(set (match_operand:VEC_I 3 \"vlogical_operand\")\n@@ -829,88 +746,116 @@\n   operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n })\n \n-(define_insn_and_split \"vector_uneq<mode>\"\n-  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n-\t(uneq:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n-\t\t    (match_operand:VEC_F 2 \"vfloat_operand\")))]\n-  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"#\"\n-  \"\"\n-  [(set (match_dup 3)\n-\t(gt:VEC_F (match_dup 1)\n-\t\t  (match_dup 2)))\n-   (set (match_dup 4)\n-\t(gt:VEC_F (match_dup 2)\n-\t\t  (match_dup 1)))\n-   (set (match_dup 0)\n-\t(and:VEC_F (not:VEC_F (match_dup 3))\n-\t\t   (not:VEC_F (match_dup 4))))]\n-{\n-  operands[3] = gen_reg_rtx (<MODE>mode);\n-  operands[4] = gen_reg_rtx (<MODE>mode);\n-})\n+; There are 14 possible vector FP comparison operators, gt and eq of them have\n+; been expanded above, so just support 12 remaining operators here.\n \n-(define_insn_and_split \"vector_ltgt<mode>\"\n-  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n-\t(ltgt:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n-\t\t    (match_operand:VEC_F 2 \"vfloat_operand\")))]\n+; For ge:\n+(define_expand \"vector_ge<mode>\"\n+  [(set (match_operand:VEC_F 0 \"vlogical_operand\")\n+\t(ge:VEC_F (match_operand:VEC_F 1 \"vlogical_operand\")\n+\t\t  (match_operand:VEC_F 2 \"vlogical_operand\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n-  \"#\"\n-  \"\"\n-  [(set (match_dup 3)\n-\t(gt:VEC_F (match_dup 1)\n-\t\t  (match_dup 2)))\n-   (set (match_dup 4)\n-\t(gt:VEC_F (match_dup 2)\n-\t\t  (match_dup 1)))\n-   (set (match_dup 0)\n-\t(ior:VEC_F (match_dup 3)\n-\t\t   (match_dup 4)))]\n-{\n-  operands[3] = gen_reg_rtx (<MODE>mode);\n-  operands[4] = gen_reg_rtx (<MODE>mode);\n-})\n+  \"\")\n \n-(define_insn_and_split \"vector_ordered<mode>\"\n+; For lt/le/ne/ungt/unge/unlt/unle:\n+; lt(a,b)   = gt(b,a)\n+; le(a,b)   = ge(b,a)\n+; unge(a,b) = ~lt(a,b)\n+; unle(a,b) = ~gt(a,b)\n+; ne(a,b)   = ~eq(a,b)\n+; ungt(a,b) = ~le(a,b)\n+; unlt(a,b) = ~ge(a,b)\n+(define_insn_and_split \"vector_<code><mode>\"\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n-\t(ordered:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n-\t\t       (match_operand:VEC_F 2 \"vfloat_operand\")))]\n-  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+\t(vector_fp_comparison_simple:VEC_F\n+\t   (match_operand:VEC_F 1 \"vfloat_operand\")\n+\t   (match_operand:VEC_F 2 \"vfloat_operand\")))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode) && can_create_pseudo_p ()\"\n   \"#\"\n-  \"\"\n-  [(set (match_dup 3)\n-\t(ge:VEC_F (match_dup 1)\n-\t\t  (match_dup 2)))\n-   (set (match_dup 4)\n-\t(ge:VEC_F (match_dup 2)\n-\t\t  (match_dup 1)))\n-   (set (match_dup 0)\n-\t(ior:VEC_F (match_dup 3)\n-\t\t   (match_dup 4)))]\n+  \"&& can_create_pseudo_p ()\"\n+  [(pc)]\n {\n-  operands[3] = gen_reg_rtx (<MODE>mode);\n-  operands[4] = gen_reg_rtx (<MODE>mode);\n+  enum rtx_code cond = <CODE>;\n+  bool need_invert = false;\n+\n+  if (cond == UNLE || cond == UNLT || cond == NE || cond == UNGE\n+      || cond == UNGT)\n+    {\n+      cond = reverse_condition_maybe_unordered (cond);\n+      need_invert = true;\n+    }\n+\n+  if (cond == LT || cond == LE)\n+    {\n+      cond = swap_condition (cond);\n+      std::swap (operands[1], operands[2]);\n+    }\n+\n+  gcc_assert (cond == EQ || cond == GE || cond == GT);\n+\n+  rtx comp = gen_rtx_fmt_ee (cond, <MODE>mode, operands[1], operands[2]);\n+\n+  if (need_invert)\n+    {\n+      rtx res = gen_reg_rtx (<MODE>mode);\n+      emit_insn (gen_rtx_SET (res, comp));\n+      emit_insn (gen_one_cmpl<mode>2 (operands[0], res));\n+    }\n+  else\n+    emit_insn (gen_rtx_SET (operands[0], comp));\n+\n+  DONE;\n })\n \n-(define_insn_and_split \"vector_unordered<mode>\"\n+; For ltgt/uneq/ordered/unordered:\n+; ltgt: gt(a,b) | gt(b,a)\n+; uneq: ~(gt(a,b) | gt(b,a))\n+; ordered: ge(a,b) | ge(b,a)\n+; unordered: ~(ge(a,b) | ge(b,a))\n+(define_insn_and_split \"vector_<code><mode>\"\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n-\t(unordered:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n-\t\t\t (match_operand:VEC_F 2 \"vfloat_operand\")))]\n-  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+\t(vector_fp_comparison_complex:VEC_F\n+\t   (match_operand:VEC_F 1 \"vfloat_operand\")\n+\t   (match_operand:VEC_F 2 \"vfloat_operand\")))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode) && can_create_pseudo_p ()\"\n   \"#\"\n-  \"\"\n-  [(set (match_dup 3)\n-\t(ge:VEC_F (match_dup 1)\n-\t\t  (match_dup 2)))\n-   (set (match_dup 4)\n-\t(ge:VEC_F (match_dup 2)\n-\t\t  (match_dup 1)))\n-   (set (match_dup 0)\n-        (and:VEC_F (not:VEC_F (match_dup 3))\n-                   (not:VEC_F (match_dup 4))))]\n+  \"&& can_create_pseudo_p ()\"\n+  [(pc)]\n {\n-  operands[3] = gen_reg_rtx (<MODE>mode);\n-  operands[4] = gen_reg_rtx (<MODE>mode);\n+  enum rtx_code cond = <CODE>;\n+  bool need_invert = false;\n+\n+  if (cond == UNORDERED || cond == UNEQ)\n+    {\n+      cond = reverse_condition_maybe_unordered (cond);\n+      need_invert = true;\n+    }\n+\n+  if (cond == LTGT)\n+    cond = GT;\n+  else if (cond == ORDERED)\n+    cond = GE;\n+  else\n+    gcc_unreachable ();\n+\n+  rtx comp1 = gen_rtx_fmt_ee (cond, <MODE>mode, operands[1], operands[2]);\n+  rtx res1 = gen_reg_rtx (<MODE>mode);\n+  emit_insn (gen_rtx_SET (res1, comp1));\n+  rtx comp2 = gen_rtx_fmt_ee (cond, <MODE>mode, operands[2], operands[1]);\n+  rtx res2 = gen_reg_rtx (<MODE>mode);\n+  emit_insn (gen_rtx_SET (res2, comp2));\n+\n+  if (need_invert)\n+    {\n+      rtx not1 = gen_rtx_fmt_e (NOT, <MODE>mode, res1);\n+      rtx not2 = gen_rtx_fmt_e (NOT, <MODE>mode, res2);\n+      rtx comp3 = gen_rtx_fmt_ee (AND, <MODE>mode, not1, not2);\n+      emit_insn (gen_rtx_SET (operands[0], comp3));\n+    }\n+  else\n+    emit_insn (gen_ior<mode>3 (operands[0], res1, res2));\n+\n+  DONE;\n })\n \n ;; Note the arguments for __builtin_altivec_vsel are op2, op1, mask"}]}