{"sha": "0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGExYzIwZGNjNjIzMmQyZDlhYzUzNmMyZTc1MjE0YThiYzBiZGEwMg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2012-03-16T15:02:41Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2012-03-16T15:02:41Z"}, "message": "expr.c (expand_expr_real_1): handle misaligned scalar reads from memory through MEM_REFs by calling...\n\n2012-03-16  Martin Jambor  <mjambor@suse.cz>\n\n\t* expr.c (expand_expr_real_1): handle misaligned scalar reads from\n\tmemory through MEM_REFs by calling extract_bit_field.\n\n\t* testsuite/gcc.dg/misaligned-expand-1.c: New test.\n\t* testsuite/gcc.dg/misaligned-expand-3.c: Likewise.\n\nFrom-SVN: r185470", "tree": {"sha": "4d093dcc4ebf7a9aa21b87506419fae7a5811f9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d093dcc4ebf7a9aa21b87506419fae7a5811f9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6814f778d841cb75ff96eaeea78ddfbf7952f475", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6814f778d841cb75ff96eaeea78ddfbf7952f475", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6814f778d841cb75ff96eaeea78ddfbf7952f475"}], "stats": {"total": 128, "additions": 114, "deletions": 14}, "files": [{"sha": "d5178812921bfe06b5d0a698e0768c3d5619778b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02", "patch": "@@ -1,3 +1,8 @@\n+2012-03-16  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* expr.c (expand_expr_real_1): handle misaligned scalar reads from\n+\tmemory through MEM_REFs by calling extract_bit_field.\n+\n 2012-03-16  Richard Guenther  <rguenther@suse.de>\n \n \t* fold-const.c (native_interpret_expr): Also support POINTER_TYPE"}, {"sha": "2b0a17623ae128c0ee3827c97867ebdbba03d93e", "filename": "gcc/expr.c", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02", "patch": "@@ -9347,21 +9347,27 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  MEM_VOLATILE_P (temp) = 1;\n \tif (modifier != EXPAND_WRITE\n \t    && mode != BLKmode\n-\t    && align < GET_MODE_ALIGNMENT (mode)\n-\t    /* If the target does not have special handling for unaligned\n-\t       loads of mode then it can use regular moves for them.  */\n-\t    && ((icode = optab_handler (movmisalign_optab, mode))\n-\t\t!= CODE_FOR_nothing))\n+\t    && align < GET_MODE_ALIGNMENT (mode))\n \t  {\n-\t    struct expand_operand ops[2];\n-\n-\t    /* We've already validated the memory, and we're creating a\n-\t       new pseudo destination.  The predicates really can't fail,\n-\t       nor can the generator.  */\n-\t    create_output_operand (&ops[0], NULL_RTX, mode);\n-\t    create_fixed_operand (&ops[1], temp);\n-\t    expand_insn (icode, 2, ops);\n-\t    return ops[0].value;\n+\t    if ((icode = optab_handler (movmisalign_optab, mode))\n+\t\t!= CODE_FOR_nothing)\n+\t      {\n+\t\tstruct expand_operand ops[2];\n+\n+\t\t/* We've already validated the memory, and we're creating a\n+\t\t   new pseudo destination.  The predicates really can't fail,\n+\t\t   nor can the generator.  */\n+\t\tcreate_output_operand (&ops[0], NULL_RTX, mode);\n+\t\tcreate_fixed_operand (&ops[1], temp);\n+\t\texpand_insn (icode, 2, ops);\n+\t\treturn ops[0].value;\n+\t      }\n+\t    else if (SLOW_UNALIGNED_ACCESS (mode, align))\n+\t      temp = extract_bit_field (temp, GET_MODE_BITSIZE (mode),\n+\t\t\t\t\t0, TYPE_UNSIGNED (TREE_TYPE (exp)),\n+\t\t\t\t\ttrue, (modifier == EXPAND_STACK_PARM\n+\t\t\t\t\t       ? NULL_RTX : target),\n+\t\t\t\t\tmode, mode);\n \t  }\n \treturn temp;\n       }"}, {"sha": "ab3261e03b74e20013b0fb9aa09a1a184d7d8b33", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02", "patch": "@@ -1,3 +1,8 @@\n+2012-03-16  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc.dg/misaligned-expand-1.c: New test.\n+\t* gcc.dg/misaligned-expand-3.c: Likewise.\n+\n 2012-03-16  Richard Guenther  <rguenther@suse.de>\n \tKai Tietz  <ktietz@redhat.com>\n "}, {"sha": "38ac4d6221cc032aeb80723e89fb3c37fb7c7d6c", "filename": "gcc/testsuite/gcc.dg/misaligned-expand-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02/gcc%2Ftestsuite%2Fgcc.dg%2Fmisaligned-expand-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02/gcc%2Ftestsuite%2Fgcc.dg%2Fmisaligned-expand-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmisaligned-expand-1.c?ref=0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02", "patch": "@@ -0,0 +1,41 @@\n+/* Test that expand can generate correct loads of misaligned data even on\n+   strict alignment platforms.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-O0\" } */\n+\n+extern void abort ();\n+\n+typedef unsigned int myint __attribute__((aligned(1)));\n+\n+unsigned int\n+foo (myint *p)\n+{\n+  return *p;\n+}\n+\n+#define cst 0xdeadbeef\n+#define NUM 8\n+\n+struct blah\n+{\n+  char c;\n+  myint i[NUM];\n+};\n+\n+struct blah g;\n+\n+int\n+main (int argc, char **argv)\n+{\n+  int i, k;\n+  for (k = 0; k < NUM; k++)\n+    {\n+      g.i[k] = cst;\n+      i = foo (&g.i[k]);\n+\n+      if (i != cst)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "5b1c7e7e07112352f800ca484b25b5e76bb7f1f9", "filename": "gcc/testsuite/gcc.dg/misaligned-expand-3.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02/gcc%2Ftestsuite%2Fgcc.dg%2Fmisaligned-expand-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02/gcc%2Ftestsuite%2Fgcc.dg%2Fmisaligned-expand-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmisaligned-expand-3.c?ref=0a1c20dcc6232d2d9ac536c2e75214a8bc0bda02", "patch": "@@ -0,0 +1,43 @@\n+/* Test that expand can generate correct stores to misaligned data of complex\n+   type even on strict alignment platforms.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-O0\" } */\n+\n+extern void abort ();\n+\n+typedef _Complex float mycmplx __attribute__((aligned(1)));\n+\n+void\n+foo (mycmplx *p, float r, float i)\n+{\n+  __real__ *p = r;\n+  __imag__ *p = i;\n+}\n+\n+#define cvr 3.2f\n+#define cvi 2.5f\n+#define NUM 8\n+\n+struct blah\n+{\n+  char c;\n+  mycmplx x[NUM];\n+} __attribute__((packed));\n+\n+struct blah g;\n+\n+int\n+main (int argc, char **argv)\n+{\n+  int k;\n+\n+  for (k = 0; k < NUM; k++)\n+    {\n+      foo (&g.x[k], cvr, cvi);\n+      if (__real__ g.x[k] != cvr\n+\t  || __imag__ g.x[k] != cvi)\n+\tabort ();\n+    }\n+  return 0;\n+}"}]}