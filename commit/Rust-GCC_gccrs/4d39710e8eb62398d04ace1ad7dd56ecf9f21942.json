{"sha": "4d39710e8eb62398d04ace1ad7dd56ecf9f21942", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQzOTcxMGU4ZWI2MjM5OGQwNGFjZTFhZDdkZDU2ZWNmOWYyMTk0Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-21T12:03:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-21T12:03:23Z"}, "message": "([lr]rotate_double): Replace; old versions were bogus.\n\n(fold, shift and rotate): Don't call tree_int_cst_sgn on non-integer.\n(fold, case LROTATE_EXPR): If constant count, convert to RROTATE_EXPR.\n(fold, case RROTATE_EXPR): Sometimes commute logical op with rotate.\nDelete pair of counteracting shifts.\n\nFrom-SVN: r9425", "tree": {"sha": "528baab40a429606d54d09eb8fe262e9278864c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/528baab40a429606d54d09eb8fe262e9278864c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d39710e8eb62398d04ace1ad7dd56ecf9f21942", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d39710e8eb62398d04ace1ad7dd56ecf9f21942", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d39710e8eb62398d04ace1ad7dd56ecf9f21942", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d39710e8eb62398d04ace1ad7dd56ecf9f21942/comments", "author": null, "committer": null, "parents": [{"sha": "0e32506c6bec44d0259cc49277ffd9268508351e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e32506c6bec44d0259cc49277ffd9268508351e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e32506c6bec44d0259cc49277ffd9268508351e"}], "stats": {"total": 105, "additions": 59, "deletions": 46}, "files": [{"sha": "56f228cd76447dea59003e35e7a3ca82707f5dd3", "filename": "gcc/fold-const.c", "status": "modified", "additions": 59, "deletions": 46, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d39710e8eb62398d04ace1ad7dd56ecf9f21942/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d39710e8eb62398d04ace1ad7dd56ecf9f21942/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=4d39710e8eb62398d04ace1ad7dd56ecf9f21942", "patch": "@@ -399,34 +399,16 @@ lrotate_double (l1, h1, count, prec, lv, hv)\n      int prec;\n      HOST_WIDE_INT *lv, *hv;\n {\n-  HOST_WIDE_INT arg1[4];\n-  register int i;\n-  register int carry;\n+  HOST_WIDE_INT s1l, s1h, s2l, s2h;\n \n+  count %= prec;\n   if (count < 0)\n-    {\n-      rrotate_double (l1, h1, - count, prec, lv, hv);\n-      return;\n-    }\n+    count += prec;\n \n-  encode (arg1, l1, h1);\n-\n-  if (count > prec)\n-    count = prec;\n-\n-  carry = arg1[4 - 1] >> 16 - 1;\n-  while (count > 0)\n-    {\n-      for (i = 0; i < 4; i++)\n-\t{\n-\t  carry += arg1[i] << 1;\n-\t  arg1[i] = LOWPART (carry);\n-\t  carry = HIGHPART (carry);\n-\t}\n-      count--;\n-    }\n-\n-  decode (arg1, lv, hv);\n+  lshift_double (l1, h1, count, prec, &s1l, &s1h, 0);\n+  rshift_double (l1, h1, prec - count, prec, &s2l, &s2h, 0);\n+  *lv = s1l | s2l;\n+  *hv = s1h | s2h;\n }\n \n /* Rotate the doubleword integer in L1, H1 left by COUNT places\n@@ -439,28 +421,16 @@ rrotate_double (l1, h1, count, prec, lv, hv)\n      int prec;\n      HOST_WIDE_INT *lv, *hv;\n {\n-  HOST_WIDE_INT arg1[4];\n-  register int i;\n-  register int carry;\n-\n-  encode (arg1, l1, h1);\n-\n-  if (count > prec)\n-    count = prec;\n+  HOST_WIDE_INT s1l, s1h, s2l, s2h;\n \n-  carry = arg1[0] & 1;\n-  while (count > 0)\n-    {\n-      for (i = 4 - 1; i >= 0; i--)\n-\t{\n-\t  carry *= BASE;\n-\t  carry += arg1[i];\n-\t  arg1[i] = LOWPART (carry >> 1);\n-\t}\n-      count--;\n-    }\n+  count %= prec;\n+  if (count < 0)\n+    count += prec;\n \n-  decode (arg1, lv, hv);\n+  rshift_double (l1, h1, count, prec, &s1l, &s1h, 0);\n+  lshift_double (l1, h1, prec - count, prec, &s2l, &s2h, 0);\n+  *lv = s1l | s2l;\n+  *hv = s1h | s2h;\n }\n \f\n /* Divide doubleword integer LNUM, HNUM by doubleword integer LDEN, HDEN\n@@ -4158,8 +4128,51 @@ fold (expr)\n \treturn non_lvalue (convert (type, arg0));\n       /* Since negative shift count is not well-defined,\n \t don't try to compute it in the compiler.  */\n-      if (tree_int_cst_sgn (arg1) < 0)\n+      if (TREE_CODE (arg1) == INTEGER_CST && tree_int_cst_sgn (arg1) < 0)\n \treturn t;\n+      /* Rewrite an LROTATE_EXPR by a constant into an\n+\t RROTATE_EXPR by a new constant.  */\n+      if (code == LROTATE_EXPR && TREE_CODE (arg1) == INTEGER_CST)\n+\t{\n+\t  TREE_SET_CODE (t, RROTATE_EXPR);\n+\t  code = RROTATE_EXPR;\n+\t  TREE_OPERAND (t, 1) = arg1\n+\t    = const_binop\n+\t      (MINUS_EXPR,\n+\t       convert (TREE_TYPE (arg1),\n+\t\t\tbuild_int_2 (GET_MODE_BITSIZE (TYPE_MODE (type)), 0)),\n+\t       arg1, 0);\n+\t  if (tree_int_cst_sgn (arg1) < 0)\n+\t    return t;\n+\t}\n+\n+      /* If we have a rotate of a bit operation with the rotate count and\n+\t the second operand of the bit operation both constant,\n+\t permute the two operations.  */\n+      if (code == RROTATE_EXPR && TREE_CODE (arg1) == INTEGER_CST\n+\t  && (TREE_CODE (arg0) == BIT_AND_EXPR\n+\t      || TREE_CODE (arg0) == BIT_ANDTC_EXPR\n+\t      || TREE_CODE (arg0) == BIT_IOR_EXPR\n+\t      || TREE_CODE (arg0) == BIT_XOR_EXPR)\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n+\treturn fold (build (TREE_CODE (arg0), type,\n+\t\t\t    fold (build (code, type,\n+\t\t\t\t\t TREE_OPERAND (arg0, 0), arg1)),\n+\t\t\t    fold (build (code, type,\n+\t\t\t\t\t TREE_OPERAND (arg0, 1), arg1))));\n+\n+      /* Two consecutive rotates adding up to the width of the mode can\n+\t be ignored.  */\n+      if (code == RROTATE_EXPR && TREE_CODE (arg1) == INTEGER_CST\n+\t  && TREE_CODE (arg0) == RROTATE_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n+\t  && TREE_INT_CST_HIGH (arg1) == 0\n+\t  && TREE_INT_CST_HIGH (TREE_OPERAND (arg0, 1)) == 0\n+\t  && ((TREE_INT_CST_LOW (arg1)\n+\t       + TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1)))\n+\t      == GET_MODE_BITSIZE (TYPE_MODE (type))))\n+\treturn TREE_OPERAND (arg0, 0);\n+\n       goto binary;\n \n     case MIN_EXPR:"}]}