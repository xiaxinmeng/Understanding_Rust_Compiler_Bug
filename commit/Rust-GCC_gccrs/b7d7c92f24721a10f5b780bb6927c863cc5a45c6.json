{"sha": "b7d7c92f24721a10f5b780bb6927c863cc5a45c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdkN2M5MmYyNDcyMWExMGY1Yjc4MGJiNjkyN2M4NjNjYzVhNDVjNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-08-07T17:29:50Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-08-07T17:29:50Z"}, "message": "runtime: use poll rather than pollset for netpoll on AIX\n    \n    Updates golang/go#26634\n    \n    Reviewed-on: https://go-review.googlesource.com/126857\n\nFrom-SVN: r263364", "tree": {"sha": "edfda3fc9529f0bf8c8df910fd61c4c7741893e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edfda3fc9529f0bf8c8df910fd61c4c7741893e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7d7c92f24721a10f5b780bb6927c863cc5a45c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d7c92f24721a10f5b780bb6927c863cc5a45c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7d7c92f24721a10f5b780bb6927c863cc5a45c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d7c92f24721a10f5b780bb6927c863cc5a45c6/comments", "author": null, "committer": null, "parents": [{"sha": "9be4d77249fcba6baead6e27cdb2447d4e6039fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9be4d77249fcba6baead6e27cdb2447d4e6039fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9be4d77249fcba6baead6e27cdb2447d4e6039fa"}], "stats": {"total": 204, "additions": 95, "deletions": 109}, "files": [{"sha": "3aeb1f68df4db66870b5da4bc1fbfcc7bd984403", "filename": "libgo/go/runtime/netpoll.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d7c92f24721a10f5b780bb6927c863cc5a45c6/libgo%2Fgo%2Fruntime%2Fnetpoll.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d7c92f24721a10f5b780bb6927c863cc5a45c6/libgo%2Fgo%2Fruntime%2Fnetpoll.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll.go?ref=b7d7c92f24721a10f5b780bb6927c863cc5a45c6", "patch": "@@ -169,8 +169,8 @@ func poll_runtime_pollWait(pd *pollDesc, mode int) int {\n \tif err != 0 {\n \t\treturn err\n \t}\n-\t// As for now only Solaris uses level-triggered IO.\n-\tif GOOS == \"solaris\" {\n+\t// As for now only Solaris and AIX use level-triggered IO.\n+\tif GOOS == \"solaris\" || GOOS == \"aix\" {\n \t\tnetpollarm(pd, mode)\n \t}\n \tfor !netpollblock(pd, int32(mode), false) {"}, {"sha": "cbeb8c9ed18403ccf057607324b40645404a3429", "filename": "libgo/go/runtime/netpoll_aix.go", "status": "modified", "additions": 93, "deletions": 107, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d7c92f24721a10f5b780bb6927c863cc5a45c6/libgo%2Fgo%2Fruntime%2Fnetpoll_aix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d7c92f24721a10f5b780bb6927c863cc5a45c6/libgo%2Fgo%2Fruntime%2Fnetpoll_aix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll_aix.go?ref=b7d7c92f24721a10f5b780bb6927c863cc5a45c6", "patch": "@@ -7,9 +7,7 @@ package runtime\n import \"unsafe\"\n \n // This is based on the former libgo/runtime/netpoll_select.c implementation\n-// except that it uses AIX pollset_poll instead of select and is written in Go.\n-\n-type pollset_t int32\n+// except that it uses poll instead of select and is written in Go.\n \n type pollfd struct {\n \tfd      int32\n@@ -22,25 +20,9 @@ const _POLLOUT = 0x0002\n const _POLLHUP = 0x2000\n const _POLLERR = 0x4000\n \n-type poll_ctl struct {\n-\tcmd    int16\n-\tevents int16\n-\tfd     int32\n-}\n-\n-const _PS_ADD = 0x0\n-const _PS_DELETE = 0x2\n-\n-//extern pollset_create\n-func pollset_create(maxfd int32) pollset_t\n-\n-//go:noescape\n-//extern pollset_ctl\n-func pollset_ctl(ps pollset_t, pollctl_array *poll_ctl, array_length int32) int32\n-\n //go:noescape\n-//extern pollset_poll\n-func pollset_poll(ps pollset_t, polldata_array *pollfd, array_length int32, timeout int32) int32\n+//extern poll\n+func libc_poll(pfds *pollfd, npfds uintptr, timeout uintptr) int32\n \n //go:noescape\n //extern pipe\n@@ -55,9 +37,10 @@ func fcntl(fd, cmd int32, arg uintptr) uintptr {\n }\n \n var (\n-\tps          pollset_t = -1\n-\tmpfds       map[int32]*pollDesc\n-\tpmtx        mutex\n+\tpfds        []pollfd\n+\tpds         []*pollDesc\n+\tmtxpoll     mutex\n+\tmtxset      mutex\n \trdwake      int32\n \twrwake      int32\n \tneedsUpdate bool\n@@ -66,13 +49,7 @@ var (\n func netpollinit() {\n \tvar p [2]int32\n \n-\tif ps = pollset_create(-1); ps < 0 {\n-\t\tthrow(\"runtime: netpollinit failed to create pollset\")\n-\t}\n-\t// It is not possible to add or remove descriptors from\n-\t// the pollset while pollset_poll is active.\n-\t// We use a pipe to wakeup pollset_poll when the pollset\n-\t// needs to be updated.\n+\t// Create the pipe we use to wakeup poll.\n \tif err := libc_pipe(&p[0]); err < 0 {\n \t\tthrow(\"runtime: netpollinit failed to create pipe\")\n \t}\n@@ -84,127 +61,136 @@ func netpollinit() {\n \tfcntl(rdwake, _F_SETFD, _FD_CLOEXEC)\n \n \tfl = fcntl(wrwake, _F_GETFL, 0)\n-\tfcntl(wrwake, _F_SETFL, fl|_O_NONBLOCK)\n \tfcntl(wrwake, _F_SETFD, _FD_CLOEXEC)\n \n-\t// Add the read side of the pipe to the pollset.\n-\tvar pctl poll_ctl\n-\tpctl.cmd = _PS_ADD\n-\tpctl.fd = rdwake\n-\tpctl.events = _POLLIN\n-\tif pollset_ctl(ps, &pctl, 1) != 0 {\n-\t\tthrow(\"runtime: netpollinit failed to register pipe\")\n-\t}\n+\t// Pre-allocate array of pollfd structures for poll.\n+\tpfds = make([]pollfd, 1, 128)\n+\t// Poll the read side of the pipe.\n+\tpfds[0].fd = rdwake\n+\tpfds[0].events = _POLLIN\n \n-\tmpfds = make(map[int32]*pollDesc)\n+\t// Allocate index to pd array\n+\tpds = make([]*pollDesc, 1, 128)\n+\tpds[0] = nil\n }\n \n func netpolldescriptor() uintptr {\n-\t// ps is not a real file descriptor.\n \treturn ^uintptr(0)\n }\n \n-func netpollopen(fd uintptr, pd *pollDesc) int32 {\n-\t// pollset_ctl will block if pollset_poll is active\n-\t// so wakeup pollset_poll first.\n-\tlock(&pmtx)\n-\tneedsUpdate = true\n-\tunlock(&pmtx)\n-\tb := [1]byte{0}\n-\twrite(uintptr(wrwake), unsafe.Pointer(&b[0]), 1)\n-\n-\tvar pctl poll_ctl\n-\tpctl.cmd = _PS_ADD\n-\tpctl.fd = int32(fd)\n-\tpctl.events = _POLLIN | _POLLOUT\n-\tif pollset_ctl(ps, &pctl, 1) != 0 {\n-\t\treturn int32(errno())\n+func netpollwakeup() {\n+\tif !needsUpdate {\n+\t\tneedsUpdate = true\n+\t\tb := [1]byte{0}\n+\t\twrite(uintptr(wrwake), unsafe.Pointer(&b[0]), 1)\n \t}\n-\tlock(&pmtx)\n-\tmpfds[int32(fd)] = pd\n-\tneedsUpdate = false\n-\tunlock(&pmtx)\n+}\n \n+func netpollopen(fd uintptr, pd *pollDesc) int32 {\n+\tlock(&mtxpoll)\n+\tnetpollwakeup()\n+\n+\tlock(&mtxset)\n+\tunlock(&mtxpoll)\n+\n+\tpd.user = uint32(len(pfds))\n+\tvar pfd pollfd\n+\tpfd.fd = int32(fd)\n+\tpfds = append(pfds, pfd)\n+\tpds = append(pds, pd)\n+\tunlock(&mtxset)\n \treturn 0\n }\n \n func netpollclose(fd uintptr) int32 {\n-\t// pollset_ctl will block if pollset_poll is active\n-\t// so wakeup pollset_poll first.\n-\tlock(&pmtx)\n-\tneedsUpdate = true\n-\tunlock(&pmtx)\n-\tb := [1]byte{0}\n-\twrite(uintptr(wrwake), unsafe.Pointer(&b[0]), 1)\n-\n-\tvar pctl poll_ctl\n-\tpctl.cmd = _PS_DELETE\n-\tpctl.fd = int32(fd)\n-\tif pollset_ctl(ps, &pctl, 1) != 0 {\n-\t\treturn int32(errno())\n-\t}\n-\tlock(&pmtx)\n-\tdelete(mpfds, int32(fd))\n-\tneedsUpdate = false\n-\tunlock(&pmtx)\n+\tlock(&mtxpoll)\n+\tnetpollwakeup()\n+\n+\tlock(&mtxset)\n+\tunlock(&mtxpoll)\n \n+\tfor i := 0; i < len(pfds); i++ {\n+\t\tif pfds[i].fd == int32(fd) {\n+\t\t\tpfds[i] = pfds[len(pfds)-1]\n+\t\t\tpfds = pfds[:len(pfds)-1]\n+\n+\t\t\tpds[i] = pds[len(pds)-1]\n+\t\t\tpds[i].user = uint32(i)\n+\t\t\tpds = pds[:len(pds)-1]\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tunlock(&mtxset)\n \treturn 0\n }\n \n func netpollarm(pd *pollDesc, mode int) {\n-\tthrow(\"runtime: unused\")\n+\tlock(&mtxpoll)\n+\tnetpollwakeup()\n+\n+\tlock(&mtxset)\n+\tunlock(&mtxpoll)\n+\n+\tswitch mode {\n+\tcase 'r':\n+\t\tpfds[pd.user].events |= _POLLIN\n+\tcase 'w':\n+\t\tpfds[pd.user].events |= _POLLOUT\n+\t}\n+\tunlock(&mtxset)\n }\n \n+//go:nowritebarrierrec\n func netpoll(block bool) *g {\n-\tif ps == -1 {\n-\t\treturn nil\n-\t}\n-\ttimeout := int32(-1)\n+\ttimeout := ^uintptr(0)\n \tif !block {\n \t\ttimeout = 0\n+\t\treturn nil\n \t}\n-\tvar pfds [128]pollfd\n retry:\n-\tlock(&pmtx)\n-\tif needsUpdate {\n-\t\tunlock(&pmtx)\n-\t\tosyield()\n-\t\tgoto retry\n-\t}\n-\tunlock(&pmtx)\n-\tnfound := pollset_poll(ps, &pfds[0], int32(len(pfds)), timeout)\n-\tif nfound < 0 {\n+\tlock(&mtxpoll)\n+\tlock(&mtxset)\n+\tneedsUpdate = false\n+\tunlock(&mtxpoll)\n+\n+\tn := libc_poll(&pfds[0], uintptr(len(pfds)), timeout)\n+\tif n < 0 {\n \t\te := errno()\n \t\tif e != _EINTR {\n-\t\t\tthrow(\"runtime: pollset_poll failed\")\n+\t\t\tthrow(\"runtime: poll failed\")\n+\t\t}\n+\t\tunlock(&mtxset)\n+\t\tgoto retry\n+\t}\n+\t// Check if some descriptors need to be changed\n+\tif n != 0 && pfds[0].revents&(_POLLIN|_POLLHUP|_POLLERR) != 0 {\n+\t\tvar b [1]byte\n+\t\tfor read(rdwake, unsafe.Pointer(&b[0]), 1) == 1 {\n \t\t}\n+\t\t// Do not look at the other fds in this case as the mode may have changed\n+\t\t// XXX only additions of flags are made, so maybe it is ok\n+\t\tunlock(&mtxset)\n \t\tgoto retry\n \t}\n \tvar gp guintptr\n-\tfor i := int32(0); i < nfound; i++ {\n+\tfor i := 0; i < len(pfds) && n > 0; i++ {\n \t\tpfd := &pfds[i]\n \n \t\tvar mode int32\n \t\tif pfd.revents&(_POLLIN|_POLLHUP|_POLLERR) != 0 {\n-\t\t\tif pfd.fd == rdwake {\n-\t\t\t\tvar b [1]byte\n-\t\t\t\tread(pfd.fd, unsafe.Pointer(&b[0]), 1)\n-\t\t\t\tcontinue\n-\t\t\t}\n \t\t\tmode += 'r'\n+\t\t\tpfd.events &= ^_POLLIN\n \t\t}\n \t\tif pfd.revents&(_POLLOUT|_POLLHUP|_POLLERR) != 0 {\n \t\t\tmode += 'w'\n+\t\t\tpfd.events &= ^_POLLOUT\n \t\t}\n \t\tif mode != 0 {\n-\t\t\tlock(&pmtx)\n-\t\t\tpd := mpfds[pfd.fd]\n-\t\t\tunlock(&pmtx)\n-\t\t\tif pd != nil {\n-\t\t\t\tnetpollready(&gp, pd, mode)\n-\t\t\t}\n+\t\t\tnetpollready(&gp, pds[i], mode)\n+\t\t\tn--\n \t\t}\n \t}\n+\tunlock(&mtxset)\n \tif block && gp == 0 {\n \t\tgoto retry\n \t}"}]}