{"sha": "9a0c61875533558e047cb5ef140d9836ed475ab9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEwYzYxODc1NTMzNTU4ZTA0N2NiNWVmMTQwZDk4MzZlZDQ3NWFiOQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2009-05-10T14:27:32Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2009-05-10T14:27:32Z"}, "message": "c-lex.c (c_lex_with_flags): Expect cpp_hashnode in tok->val.node.node.\n\ngcc:\n\t* c-lex.c (c_lex_with_flags): Expect cpp_hashnode in\n\ttok->val.node.node.\n\nlibcpp:\n\t* include/cpplib.h (enum cpp_token_fld_kind): Add\n\tCPP_TOKEN_FLD_TOKEN_NO.\n\t(struct cpp_macro_arg, struct cpp_identifier): Define.\n\t(union cpp_token_u): Use struct cpp_identifier for identifiers.\n\tUse struct cpp_macro_arg for macro arguments.  Add token_no for\n\tCPP_PASTE token numbers.\n\t* directives.c (_cpp_handle_directive, lex_macro_node, do_pragma,\n\tdo_pragma_poison, parse_assertion): Use val.node.node in place of\n\tval.node.\n\t* expr.c (parse_defined, eval_token): Use val.node.node in place\n\tof val.node.\n\t* lex.c (cpp_ideq, _cpp_lex_direct, cpp_token_len,\n\tcpp_spell_token, cpp_output_token, _cpp_equiv_tokens,\n\tcpp_token_val_index): Use val.macro_arg.arg_no or val.token_no in\n\tplace of val.arg_no.  Use val.node.node in place of val.node.\n\t* macro.c (replace_args, cpp_get_token, parse_params,\n\tlex_expansion_token, create_iso_definition, cpp_macro_definition):\n\tUse val.macro_arg.arg_no or val.token_no in place of val.arg_no.\n\tUse val.node.node in place of val.node.\n\nFrom-SVN: r147341", "tree": {"sha": "c5f8e2e7ce183b106614d41e5e99dcd5c47f5581", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5f8e2e7ce183b106614d41e5e99dcd5c47f5581"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a0c61875533558e047cb5ef140d9836ed475ab9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0c61875533558e047cb5ef140d9836ed475ab9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a0c61875533558e047cb5ef140d9836ed475ab9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0c61875533558e047cb5ef140d9836ed475ab9/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb0be16980027e055bfc6094868090382a0a4086", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb0be16980027e055bfc6094868090382a0a4086", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb0be16980027e055bfc6094868090382a0a4086"}], "stats": {"total": 164, "additions": 104, "deletions": 60}, "files": [{"sha": "7ea088127acaa365fcc460e6c5bd2467a338d093", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0c61875533558e047cb5ef140d9836ed475ab9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0c61875533558e047cb5ef140d9836ed475ab9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a0c61875533558e047cb5ef140d9836ed475ab9", "patch": "@@ -1,3 +1,8 @@\n+2009-05-10  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-lex.c (c_lex_with_flags): Expect cpp_hashnode in\n+\ttok->val.node.node.\n+\n 2009-05-10  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/40084"}, {"sha": "66df4c40f7bd1fd0b8733f1a2ce76b6642586604", "filename": "gcc/c-lex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0c61875533558e047cb5ef140d9836ed475ab9/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0c61875533558e047cb5ef140d9836ed475ab9/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=9a0c61875533558e047cb5ef140d9836ed475ab9", "patch": "@@ -313,7 +313,7 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,\n       goto retry;\n \n     case CPP_NAME:\n-      *value = HT_IDENT_TO_GCC_IDENT (HT_NODE (tok->val.node));\n+      *value = HT_IDENT_TO_GCC_IDENT (HT_NODE (tok->val.node.node));\n       break;\n \n     case CPP_NUMBER:\n@@ -369,7 +369,7 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,\n \t      break;\n \n \t    case CPP_NAME:\n-\t      *value = HT_IDENT_TO_GCC_IDENT (HT_NODE (tok->val.node));\n+\t      *value = HT_IDENT_TO_GCC_IDENT (HT_NODE (tok->val.node.node));\n \t      if (objc_is_reserved_word (*value))\n \t\t{\n \t\t  type = CPP_AT_NAME;"}, {"sha": "4e21b5811215e6a246aee2ba5d16e4f21c7c0600", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0c61875533558e047cb5ef140d9836ed475ab9/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0c61875533558e047cb5ef140d9836ed475ab9/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=9a0c61875533558e047cb5ef140d9836ed475ab9", "patch": "@@ -1,3 +1,25 @@\n+2009-05-10  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* include/cpplib.h (enum cpp_token_fld_kind): Add\n+\tCPP_TOKEN_FLD_TOKEN_NO.\n+\t(struct cpp_macro_arg, struct cpp_identifier): Define.\n+\t(union cpp_token_u): Use struct cpp_identifier for identifiers.\n+\tUse struct cpp_macro_arg for macro arguments.  Add token_no for\n+\tCPP_PASTE token numbers.\n+\t* directives.c (_cpp_handle_directive, lex_macro_node, do_pragma,\n+\tdo_pragma_poison, parse_assertion): Use val.node.node in place of\n+\tval.node.\n+\t* expr.c (parse_defined, eval_token): Use val.node.node in place\n+\tof val.node.\n+\t* lex.c (cpp_ideq, _cpp_lex_direct, cpp_token_len,\n+\tcpp_spell_token, cpp_output_token, _cpp_equiv_tokens,\n+\tcpp_token_val_index): Use val.macro_arg.arg_no or val.token_no in\n+\tplace of val.arg_no.  Use val.node.node in place of val.node.\n+\t* macro.c (replace_args, cpp_get_token, parse_params,\n+\tlex_expansion_token, create_iso_definition, cpp_macro_definition):\n+\tUse val.macro_arg.arg_no or val.token_no in place of val.arg_no.\n+\tUse val.node.node in place of val.node.\n+\n 2009-05-03  Joseph Myers  <joseph@codesourcery.com>\n \n \t* charset.c (one_utf8_to_cppchar): Correct mask used for 5-byte"}, {"sha": "e71efb2bd94e08dc67b716ddd28fd1fff571ec9f", "filename": "libcpp/directives.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0c61875533558e047cb5ef140d9836ed475ab9/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0c61875533558e047cb5ef140d9836ed475ab9/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=9a0c61875533558e047cb5ef140d9836ed475ab9", "patch": "@@ -408,8 +408,8 @@ _cpp_handle_directive (cpp_reader *pfile, int indented)\n \n   if (dname->type == CPP_NAME)\n     {\n-      if (dname->val.node->is_directive)\n-\tdir = &dtable[dname->val.node->directive_index];\n+      if (dname->val.node.node->is_directive)\n+\tdir = &dtable[dname->val.node.node->directive_index];\n     }\n   /* We do not recognize the # followed by a number extension in\n      assembler code.  */\n@@ -538,7 +538,7 @@ lex_macro_node (cpp_reader *pfile, bool is_def_or_undef)\n \n   if (token->type == CPP_NAME)\n     {\n-      cpp_hashnode *node = token->val.node;\n+      cpp_hashnode *node = token->val.node.node;\n \n       if (is_def_or_undef && node == pfile->spec_nodes.n_defined)\n \tcpp_error (pfile, CPP_DL_ERROR,\n@@ -549,7 +549,7 @@ lex_macro_node (cpp_reader *pfile, bool is_def_or_undef)\n   else if (token->flags & NAMED_OP)\n     cpp_error (pfile, CPP_DL_ERROR,\n        \"\\\"%s\\\" cannot be used as a macro name as it is an operator in C++\",\n-\t       NODE_NAME (token->val.node));\n+\t       NODE_NAME (token->val.node.node));\n   else if (token->type == CPP_EOF)\n     cpp_error (pfile, CPP_DL_ERROR, \"no macro name given in #%s directive\",\n \t       pfile->directive->name);\n@@ -1329,15 +1329,15 @@ do_pragma (cpp_reader *pfile)\n   ns_token = *token;\n   if (token->type == CPP_NAME)\n     {\n-      p = lookup_pragma_entry (pfile->pragmas, token->val.node);\n+      p = lookup_pragma_entry (pfile->pragmas, token->val.node.node);\n       if (p && p->is_nspace)\n \t{\n \t  bool allow_name_expansion = p->allow_expansion;\n \t  if (allow_name_expansion)\n \t    pfile->state.prevent_expansion--;\n \t  token = cpp_get_token (pfile);\n \t  if (token->type == CPP_NAME)\n-\t    p = lookup_pragma_entry (p->u.space, token->val.node);\n+\t    p = lookup_pragma_entry (p->u.space, token->val.node.node);\n \t  else\n \t    p = NULL;\n \t  if (allow_name_expansion)\n@@ -1429,7 +1429,7 @@ do_pragma_poison (cpp_reader *pfile)\n \t  break;\n \t}\n \n-      hp = tok->val.node;\n+      hp = tok->val.node.node;\n       if (hp->flags & NODE_POISONED)\n \tcontinue;\n \n@@ -1986,12 +1986,12 @@ parse_assertion (cpp_reader *pfile, struct answer **answerp, int type)\n     cpp_error (pfile, CPP_DL_ERROR, \"predicate must be an identifier\");\n   else if (parse_answer (pfile, answerp, type) == 0)\n     {\n-      unsigned int len = NODE_LEN (predicate->val.node);\n+      unsigned int len = NODE_LEN (predicate->val.node.node);\n       unsigned char *sym = (unsigned char *) alloca (len + 1);\n \n       /* Prefix '#' to get it out of macro namespace.  */\n       sym[0] = '#';\n-      memcpy (sym + 1, NODE_NAME (predicate->val.node), len);\n+      memcpy (sym + 1, NODE_NAME (predicate->val.node.node), len);\n       result = cpp_lookup (pfile, sym, len + 1);\n     }\n "}, {"sha": "6887b1656904ace1fcd230ecd374d682743e7e13", "filename": "libcpp/expr.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0c61875533558e047cb5ef140d9836ed475ab9/libcpp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0c61875533558e047cb5ef140d9836ed475ab9/libcpp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.c?ref=9a0c61875533558e047cb5ef140d9836ed475ab9", "patch": "@@ -651,7 +651,7 @@ parse_defined (cpp_reader *pfile)\n \n   if (token->type == CPP_NAME)\n     {\n-      node = token->val.node;\n+      node = token->val.node.node;\n       if (paren && cpp_get_token (pfile)->type != CPP_CLOSE_PAREN)\n \t{\n \t  cpp_error (pfile, CPP_DL_ERROR, \"missing ')' after \\\"defined\\\"\");\n@@ -771,22 +771,22 @@ eval_token (cpp_reader *pfile, const cpp_token *token)\n       break;\n \n     case CPP_NAME:\n-      if (token->val.node == pfile->spec_nodes.n_defined)\n+      if (token->val.node.node == pfile->spec_nodes.n_defined)\n \treturn parse_defined (pfile);\n       else if (CPP_OPTION (pfile, cplusplus)\n-\t       && (token->val.node == pfile->spec_nodes.n_true\n-\t\t   || token->val.node == pfile->spec_nodes.n_false))\n+\t       && (token->val.node.node == pfile->spec_nodes.n_true\n+\t\t   || token->val.node.node == pfile->spec_nodes.n_false))\n \t{\n \t  result.high = 0;\n-\t  result.low = (token->val.node == pfile->spec_nodes.n_true);\n+\t  result.low = (token->val.node.node == pfile->spec_nodes.n_true);\n \t}\n       else\n \t{\n \t  result.high = 0;\n \t  result.low = 0;\n \t  if (CPP_OPTION (pfile, warn_undef) && !pfile->state.skip_eval)\n \t    cpp_error (pfile, CPP_DL_WARNING, \"\\\"%s\\\" is not defined\",\n-\t\t       NODE_NAME (token->val.node));\n+\t\t       NODE_NAME (token->val.node.node));\n \t}\n       break;\n "}, {"sha": "83439c7341f1853b5f0ea40740af8c0a956bde75", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0c61875533558e047cb5ef140d9836ed475ab9/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0c61875533558e047cb5ef140d9836ed475ab9/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=9a0c61875533558e047cb5ef140d9836ed475ab9", "patch": "@@ -189,10 +189,27 @@ enum cpp_token_fld_kind {\n   CPP_TOKEN_FLD_SOURCE,\n   CPP_TOKEN_FLD_STR,\n   CPP_TOKEN_FLD_ARG_NO,\n+  CPP_TOKEN_FLD_TOKEN_NO,\n   CPP_TOKEN_FLD_PRAGMA,\n   CPP_TOKEN_FLD_NONE\n };\n \n+/* A macro argument in the cpp_token union.  */\n+struct GTY(()) cpp_macro_arg {\n+  /* Argument number.  */\n+  unsigned int arg_no;\n+};\n+\n+/* An identifier in the cpp_token union.  */\n+struct GTY(()) cpp_identifier {\n+  /* The canonical (UTF-8) spelling of the identifier.  */\n+  cpp_hashnode *\n+    GTY ((nested_ptr (union tree_node,\n+\t\t\"%h ? CPP_HASHNODE (GCC_IDENT_TO_HT_IDENT (%h)) : NULL\",\n+\t\t\t\"%h ? HT_IDENT_TO_GCC_IDENT (HT_NODE (%h)) : NULL\")))\n+       node;\n+};\n+\n /* A preprocessing token.  This has been carefully packed and should\n    occupy 16 bytes on 32-bit hosts and 24 bytes on 64-bit hosts.  */\n struct GTY(()) cpp_token {\n@@ -203,12 +220,7 @@ struct GTY(()) cpp_token {\n   union cpp_token_u\n   {\n     /* An identifier.  */\n-    cpp_hashnode *\n-      GTY ((nested_ptr (union tree_node,\n-\t\t\"%h ? CPP_HASHNODE (GCC_IDENT_TO_HT_IDENT (%h)) : NULL\",\n-\t\t\t\"%h ? HT_IDENT_TO_GCC_IDENT (HT_NODE (%h)) : NULL\"),\n-\t    tag (\"CPP_TOKEN_FLD_NODE\")))\n-\t node;\n+    struct cpp_identifier GTY ((tag (\"CPP_TOKEN_FLD_NODE\"))) node;\n \t \n     /* Inherit padding from this token.  */\n     cpp_token * GTY ((tag (\"CPP_TOKEN_FLD_SOURCE\"))) source;\n@@ -217,7 +229,11 @@ struct GTY(()) cpp_token {\n     struct cpp_string GTY ((tag (\"CPP_TOKEN_FLD_STR\"))) str;\n \n     /* Argument no. for a CPP_MACRO_ARG.  */\n-    unsigned int GTY ((tag (\"CPP_TOKEN_FLD_ARG_NO\"))) arg_no;\n+    struct cpp_macro_arg GTY ((tag (\"CPP_TOKEN_FLD_ARG_NO\"))) macro_arg;\n+\n+    /* Original token no. for a CPP_PASTE (from a sequence of\n+       consecutive paste tokens in a macro expansion).  */\n+    unsigned int GTY ((tag (\"CPP_TOKEN_FLD_TOKEN_NO\"))) token_no;\n \n     /* Caller-supplied identifier for a CPP_PRAGMA.  */\n     unsigned int GTY ((tag (\"CPP_TOKEN_FLD_PRAGMA\"))) pragma;"}, {"sha": "ca2f2ca06f17d5ed7239e354bd0ff8e5ef053870", "filename": "libcpp/lex.c", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0c61875533558e047cb5ef140d9836ed475ab9/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0c61875533558e047cb5ef140d9836ed475ab9/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=9a0c61875533558e047cb5ef140d9836ed475ab9", "patch": "@@ -76,7 +76,7 @@ cpp_ideq (const cpp_token *token, const char *string)\n   if (token->type != CPP_NAME)\n     return 0;\n \n-  return !ustrcmp (NODE_NAME (token->val.node), (const uchar *) string);\n+  return !ustrcmp (NODE_NAME (token->val.node.node), (const uchar *) string);\n }\n \n /* Record a note TYPE at byte POS into the current cleaned logical\n@@ -1120,16 +1120,16 @@ _cpp_lex_direct (cpp_reader *pfile)\n       result->type = CPP_NAME;\n       {\n \tstruct normalize_state nst = INITIAL_NORMALIZE_STATE;\n-\tresult->val.node = lex_identifier (pfile, buffer->cur - 1, false,\n-\t\t\t\t\t   &nst);\n+\tresult->val.node.node = lex_identifier (pfile, buffer->cur - 1, false,\n+\t\t\t\t\t\t&nst);\n \twarn_about_normalization (pfile, result, &nst);\n       }\n \n       /* Convert named operators to their proper types.  */\n-      if (result->val.node->flags & NODE_OPERATOR)\n+      if (result->val.node.node->flags & NODE_OPERATOR)\n \t{\n \t  result->flags |= NAMED_OP;\n-\t  result->type = (enum cpp_ttype) result->val.node->directive_index;\n+\t  result->type = (enum cpp_ttype) result->val.node.node->directive_index;\n \t}\n       break;\n \n@@ -1244,7 +1244,7 @@ _cpp_lex_direct (cpp_reader *pfile)\n \t      result->flags |= DIGRAPH;\n \t      result->type = CPP_HASH;\n \t      if (*buffer->cur == '%' && buffer->cur[1] == ':')\n-\t\tbuffer->cur += 2, result->type = CPP_PASTE, result->val.arg_no = 0;\n+\t\tbuffer->cur += 2, result->type = CPP_PASTE, result->val.token_no = 0;\n \t    }\n \t  else if (*buffer->cur == '>')\n \t    {\n@@ -1325,7 +1325,7 @@ _cpp_lex_direct (cpp_reader *pfile)\n     case '=': IF_NEXT_IS ('=', CPP_EQ_EQ, CPP_EQ); break;\n     case '!': IF_NEXT_IS ('=', CPP_NOT_EQ, CPP_NOT); break;\n     case '^': IF_NEXT_IS ('=', CPP_XOR_EQ, CPP_XOR); break;\n-    case '#': IF_NEXT_IS ('#', CPP_PASTE, CPP_HASH); result->val.arg_no = 0; break;\n+    case '#': IF_NEXT_IS ('#', CPP_PASTE, CPP_HASH); result->val.token_no = 0; break;\n \n     case '?': result->type = CPP_QUERY; break;\n     case '~': result->type = CPP_COMPL; break;\n@@ -1350,7 +1350,7 @@ _cpp_lex_direct (cpp_reader *pfile)\n \tif (forms_identifier_p (pfile, true, &nst))\n \t  {\n \t    result->type = CPP_NAME;\n-\t    result->val.node = lex_identifier (pfile, base, true, &nst);\n+\t    result->val.node.node = lex_identifier (pfile, base, true, &nst);\n \t    warn_about_normalization (pfile, result, &nst);\n \t    break;\n \t  }\n@@ -1376,7 +1376,7 @@ cpp_token_len (const cpp_token *token)\n     {\n     default:\t\tlen = 6;\t\t\t\tbreak;\n     case SPELL_LITERAL:\tlen = token->val.str.len;\t\tbreak;\n-    case SPELL_IDENT:\tlen = NODE_LEN (token->val.node) * 10;\tbreak;\n+    case SPELL_IDENT:\tlen = NODE_LEN (token->val.node.node) * 10;\tbreak;\n     }\n \n   return len;\n@@ -1457,23 +1457,23 @@ cpp_spell_token (cpp_reader *pfile, const cpp_token *token,\n     case SPELL_IDENT:\n       if (forstring)\n \t{\n-\t  memcpy (buffer, NODE_NAME (token->val.node),\n-\t\t  NODE_LEN (token->val.node));\n-\t  buffer += NODE_LEN (token->val.node);\n+\t  memcpy (buffer, NODE_NAME (token->val.node.node),\n+\t\t  NODE_LEN (token->val.node.node));\n+\t  buffer += NODE_LEN (token->val.node.node);\n \t}\n       else\n \t{\n \t  size_t i;\n-\t  const unsigned char * name = NODE_NAME (token->val.node);\n+\t  const unsigned char * name = NODE_NAME (token->val.node.node);\n \t  \n-\t  for (i = 0; i < NODE_LEN (token->val.node); i++)\n+\t  for (i = 0; i < NODE_LEN (token->val.node.node); i++)\n \t    if (name[i] & ~0x7F)\n \t      {\n \t\ti += utf8_to_ucn (buffer, name + i) - 1;\n \t\tbuffer += 10;\n \t      }\n \t    else\n-\t      *buffer++ = NODE_NAME (token->val.node)[i];\n+\t      *buffer++ = NODE_NAME (token->val.node.node)[i];\n \t}\n       break;\n \n@@ -1550,17 +1550,17 @@ cpp_output_token (const cpp_token *token, FILE *fp)\n     case SPELL_IDENT:\n       {\n \tsize_t i;\n-\tconst unsigned char * name = NODE_NAME (token->val.node);\n+\tconst unsigned char * name = NODE_NAME (token->val.node.node);\n \t\n-\tfor (i = 0; i < NODE_LEN (token->val.node); i++)\n+\tfor (i = 0; i < NODE_LEN (token->val.node.node); i++)\n \t  if (name[i] & ~0x7F)\n \t    {\n \t      unsigned char buffer[10];\n \t      i += utf8_to_ucn (buffer, name + i) - 1;\n \t      fwrite (buffer, 1, 10, fp);\n \t    }\n \t  else\n-\t    fputc (NODE_NAME (token->val.node)[i], fp);\n+\t    fputc (NODE_NAME (token->val.node.node)[i], fp);\n       }\n       break;\n \n@@ -1583,13 +1583,14 @@ _cpp_equiv_tokens (const cpp_token *a, const cpp_token *b)\n       {\n       default:\t\t\t/* Keep compiler happy.  */\n       case SPELL_OPERATOR:\n-\t/* arg_no is used to track where multiple consecutive ##\n+\t/* token_no is used to track where multiple consecutive ##\n \t   tokens were originally located.  */\n-\treturn (a->type != CPP_PASTE || a->val.arg_no == b->val.arg_no);\n+\treturn (a->type != CPP_PASTE || a->val.token_no == b->val.token_no);\n       case SPELL_NONE:\n-\treturn (a->type != CPP_MACRO_ARG || a->val.arg_no == b->val.arg_no);\n+\treturn (a->type != CPP_MACRO_ARG\n+\t\t|| a->val.macro_arg.arg_no == b->val.macro_arg.arg_no);\n       case SPELL_IDENT:\n-\treturn a->val.node == b->val.node;\n+\treturn a->val.node.node == b->val.node.node;\n       case SPELL_LITERAL:\n \treturn (a->val.str.len == b->val.str.len\n \t\t&& !memcmp (a->val.str.text, b->val.str.text,\n@@ -1901,7 +1902,7 @@ cpp_token_val_index (cpp_token *tok)\n       return CPP_TOKEN_FLD_STR;\n     case SPELL_OPERATOR:\n       if (tok->type == CPP_PASTE)\n-\treturn CPP_TOKEN_FLD_ARG_NO;\n+\treturn CPP_TOKEN_FLD_TOKEN_NO;\n       else\n \treturn CPP_TOKEN_FLD_NONE;\n     case SPELL_NONE:"}, {"sha": "e051fbc7757b7e1d36bd11ed00c029c8e1e3a987", "filename": "libcpp/macro.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0c61875533558e047cb5ef140d9836ed475ab9/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0c61875533558e047cb5ef140d9836ed475ab9/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=9a0c61875533558e047cb5ef140d9836ed475ab9", "patch": "@@ -946,7 +946,7 @@ replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro, macro_arg\n \n \t/* We have an argument.  If it is not being stringified or\n \t   pasted it is macro-replaced before insertion.  */\n-\targ = &args[src->val.arg_no - 1];\n+\targ = &args[src->val.macro_arg.arg_no - 1];\n \n \tif (src->flags & STRINGIFY_ARG)\n \t  {\n@@ -982,7 +982,7 @@ replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro, macro_arg\n \t}\n \n       paste_flag = 0;\n-      arg = &args[src->val.arg_no - 1];\n+      arg = &args[src->val.macro_arg.arg_no - 1];\n       if (src->flags & STRINGIFY_ARG)\n \tcount = 1, from = &arg->stringified;\n       else if (src->flags & PASTE_LEFT)\n@@ -994,7 +994,7 @@ replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro, macro_arg\n \t    {\n \t      if (dest[-1]->type == CPP_COMMA\n \t\t  && macro->variadic\n-\t\t  && src->val.arg_no == macro->paramc)\n+\t\t  && src->val.macro_arg.arg_no == macro->paramc)\n \t\t{\n \t\t  /* Swallow a pasted comma if from == NULL, otherwise\n \t\t     drop the paste flag.  */\n@@ -1035,7 +1035,7 @@ replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro, macro_arg\n \t\t     \"empty macro arguments are undefined\"\n \t\t     \" in ISO C90 and ISO C++98\",\n \t\t     NODE_NAME (node),\n-\t\t     src->val.arg_no);\n+\t\t     src->val.macro_arg.arg_no);\n \t}\n \n       /* Avoid paste on RHS (even case count == 0).  */\n@@ -1261,7 +1261,7 @@ cpp_get_token (cpp_reader *pfile)\n       if (result->type != CPP_NAME)\n \tbreak;\n \n-      node = result->val.node;\n+      node = result->val.node.node;\n \n       if (node->type != NT_MACRO || (result->flags & NO_EXPAND))\n \tbreak;\n@@ -1553,7 +1553,7 @@ parse_params (cpp_reader *pfile, cpp_macro *macro)\n \t    }\n \t  prev_ident = 1;\n \n-\t  if (_cpp_save_parameter (pfile, macro, token->val.node))\n+\t  if (_cpp_save_parameter (pfile, macro, token->val.node.node))\n \t    return false;\n \t  continue;\n \n@@ -1626,10 +1626,10 @@ lex_expansion_token (cpp_reader *pfile, cpp_macro *macro)\n \n   /* Is this a parameter?  */\n   if (token->type == CPP_NAME\n-      && (token->val.node->flags & NODE_MACRO_ARG) != 0)\n+      && (token->val.node.node->flags & NODE_MACRO_ARG) != 0)\n     {\n       token->type = CPP_MACRO_ARG;\n-      token->val.arg_no = token->val.node->value.arg_index;\n+      token->val.macro_arg.arg_no = token->val.node.node->value.arg_index;\n     }\n   else if (CPP_WTRADITIONAL (pfile) && macro->paramc > 0\n \t   && (token->type == CPP_STRING || token->type == CPP_CHAR))\n@@ -1771,7 +1771,7 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n \t    {\n \t      macro->extra_tokens = 1;\n \t      num_extra_tokens++;\n-\t      token->val.arg_no = macro->count - 1;\n+\t      token->val.token_no = macro->count - 1;\n \t    }\n \t  else\n \t    {\n@@ -2007,7 +2007,7 @@ cpp_macro_definition (cpp_reader *pfile, const cpp_hashnode *node)\n \t  cpp_token *token = &macro->exp.tokens[i];\n \n \t  if (token->type == CPP_MACRO_ARG)\n-\t    len += NODE_LEN (macro->params[token->val.arg_no - 1]);\n+\t    len += NODE_LEN (macro->params[token->val.macro_arg.arg_no - 1]);\n \t  else\n \t    len += cpp_token_len (token);\n \n@@ -2079,9 +2079,9 @@ cpp_macro_definition (cpp_reader *pfile, const cpp_hashnode *node)\n \t  if (token->type == CPP_MACRO_ARG)\n \t    {\n \t      memcpy (buffer,\n-\t\t      NODE_NAME (macro->params[token->val.arg_no - 1]),\n-\t\t      NODE_LEN (macro->params[token->val.arg_no - 1]));\n-\t      buffer += NODE_LEN (macro->params[token->val.arg_no - 1]);\n+\t\t      NODE_NAME (macro->params[token->val.macro_arg.arg_no - 1]),\n+\t\t      NODE_LEN (macro->params[token->val.macro_arg.arg_no - 1]));\n+\t      buffer += NODE_LEN (macro->params[token->val.macro_arg.arg_no - 1]);\n \t    }\n \t  else\n \t    buffer = cpp_spell_token (pfile, token, buffer, false);"}]}