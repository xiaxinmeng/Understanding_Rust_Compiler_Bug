{"sha": "4956d07c7e28164b075454eddcd136dcf0b028c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk1NmQwN2M3ZTI4MTY0YjA3NTQ1NGVkZGNkMTM2ZGNmMGIwMjhjNg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-07-23T20:20:04Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-07-23T20:20:04Z"}, "message": "Initial revision\n\nFrom-SVN: r12551", "tree": {"sha": "fef312ead7dc5b8e7329c569f02a31f62b9fc268", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fef312ead7dc5b8e7329c569f02a31f62b9fc268"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4956d07c7e28164b075454eddcd136dcf0b028c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4956d07c7e28164b075454eddcd136dcf0b028c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4956d07c7e28164b075454eddcd136dcf0b028c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4956d07c7e28164b075454eddcd136dcf0b028c6/comments", "author": null, "committer": null, "parents": [{"sha": "1ef08c6373cde5339b3d4db95057ee148ea659cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ef08c6373cde5339b3d4db95057ee148ea659cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ef08c6373cde5339b3d4db95057ee148ea659cb"}], "stats": {"total": 1237, "additions": 1237, "deletions": 0}, "files": [{"sha": "aee437b6170f64c0d3787c8c138d651678b89c7a", "filename": "gcc/except.c", "status": "added", "additions": 1139, "deletions": 0, "changes": 1139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4956d07c7e28164b075454eddcd136dcf0b028c6/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4956d07c7e28164b075454eddcd136dcf0b028c6/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=4956d07c7e28164b075454eddcd136dcf0b028c6", "patch": "@@ -0,0 +1,1139 @@\n+/* Implements exceptiom handling.\n+   Copyright (C) 1989, 92-95, 1996 Free Software Foundation, Inc.\n+   Contributed by Mike Stump <mrs@cygnus.com>.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+/* This file contains the exception handling code for the compiler.\n+\n+   Exception handling is a mechanism by which complex flows of control\n+   can be designated.  The central concepts are the `exception region',\n+   the associated `exception handler' for that region and the concept of\n+   throwing an exception, and the context of the throw.\n+\n+   Restrictions are, the regions must be non-overlapping, they can be\n+   nested, and there can be zero or more per function.  For each\n+   region, there is one associated handler.  Regions only ever\n+   surround possible context points of throws.  Regions with no such\n+   context points can be optimized away, as they are trivial, and it\n+   is not possible for the associated handler to ever be used during a\n+   throw.\n+\n+   Semantics are, when an exception is thrown, control is transferred\n+   to a handler, and the code of the exception handler is executed.\n+   As control is transferred, the machine state (stack pointer, all\n+   callee saved registers and possibly the frame pointer) is restored.\n+\n+   The handler that is selected by a throw, is the handler associated\n+   with the smallest (most nested) region that contains the context of\n+   the throw, if such a region exists.  If no region exists, the\n+   search for a handler continues in the function that called the\n+   function that contains the current context of the throw, with the\n+   context of the throw then becoming that point in the code that\n+   contains the call instruction.\n+\n+\n+   One can add to the basic model the concepts of thrown exception\n+   type, and thrown exception value.  Semantics are as above, except a\n+   further check is done when finding a handler for the thrown\n+   exception to see if the given handler can handle the thrown\n+   exception based upon the exception object's type and possibly its\n+   value.  A common optimization is when two regions are identical,\n+   the handlers are combined into just one handler so the first check\n+   of the resulting handler is for the inner (nested) region's\n+   handler, and the second one is for the outer region's handler.  To\n+   separate these two notions of handlers, we can call the subhandlers\n+   `catch blocks', and use the name `handler' to refer to the\n+   combination of the two.  Currently, this layer of functionality is\n+   managed by the various front ends.\n+\n+\n+   To mark the start of a exception handling region,\n+   expand_eh_region_start () is called.  To mark the end, and\n+   associate a handler for the region expand_eh_region_end () is used.\n+   The front end can use this interface, if useful.  The back end\n+   creates exception regions with these routines.  Another interface\n+   the front end can use, is TARGET_EXPR.  TARGET_EXPR gives an\n+   unwind-protect style interface a la emacs.\n+\n+\n+   In this implementation, regions do not span more than one function.\n+\n+   In order to help with the task of finding the associated handler for\n+   a region, an exception table is built which associates handlers\n+   with regions.  A 3-tuple, containing a reference to the start, the\n+   end and the handler is sufficient for the exception table.\n+\n+   In order to help with the task of restoring callee saved registers\n+   and performing other associated function exit actions, function\n+   `unwinders' can be generated within those function for which a\n+   generic function unwinder called __unwind_function () cannot work.\n+   Whether the generic __unwind_function can work is machine dependent\n+   and possibly function dependent.  The macro DOESNT_NEEED_UNWINDER\n+   decides if the current function being compiled needs an unwinder or\n+   not.\n+\n+   The default is for unwinders to be used, as the default generic\n+   function unwinder only calls abort ().  The compiler-generated per\n+   function function unwinders simply modify the context of thrown\n+   exception to be that of the call site, and then arrange for control\n+   to be transferred to __throw instead of the function's caller on\n+   return, and then return.  */\n+\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"except.h\"\n+#include \"function.h\"\n+#include \"insn-flags.h\"\n+#include \"expr.h\"\n+#include \"insn-codes.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"output.h\"\n+\n+/* List of labels use for exception handlers.  Created by\n+   find_exception_handler_labels for the optimization passes.  */\n+\n+rtx exception_handler_labels;\n+\n+/* Nonzero means that throw was used.  Used for now, because __throw\n+   is emitted statically in each file.  */\n+\n+int throw_used;\n+\n+/* A stack used for keeping track of the currectly active exception\n+   handling region.  As exceptions regions are started, an entry\n+   describing the region is pushed onto this stack.  The current\n+   region can be found by looking at the top of the stack, and as we\n+   end regions, entries are poped.  */\n+\n+struct eh_stack ehstack;\n+\n+/* A queue used for tracking which exception regions have closed, but\n+   whose handlers have not yet been expanded.  As we end regions, we\n+   enqueue the entry onto this queue.  Entries are dequeue from the\n+   queue during expand_leftover_cleanups and expand_start_all_catch,\n+   and the handlers for regions are expanded in groups in an effort to\n+   group all the handlers together in the same region of program space\n+   to improve page performance.  We should redo things, so that we\n+   either take RTL for the handler, or we expand the handler expressed\n+   as a tree immediately at region end time.  */\n+\n+struct eh_queue ehqueue;\n+\n+/* Insns for the catch clauses.  */\n+\n+rtx catch_clauses;\n+\n+/* A list of actions for handlers for regions that are not yet\n+   closed.  */\n+\n+tree protect_list;\n+\n+/* Stacks to keep track of various labels.  */\n+\n+/* Keeps track of the label to resume to, should one want to resume\n+   the normal control flow out of a handler.  Also used to rethrow\n+   exceptions caught in handlers, as if they were physically emitted\n+   inline.  */\n+\n+struct label_node *caught_return_label_stack = NULL;\n+\n+/* A spare data area for the front end's own use.  */\n+\n+struct label_node *false_label_stack = NULL;\n+\n+/* The rtx for the saved PC value.  */\n+\n+rtx eh_saved_pc_rtx;\n+\n+rtx expand_builtin_return_addr\tPROTO((enum built_in_function, int, rtx));\n+\f\n+/* Various support routines to manipulate the various data structures\n+   used by the exception handling code.  */\n+\n+/* Push a label entry onto the given STACK.  */\n+\n+void\n+push_label_entry (stack, rlabel, tlabel)\n+     struct label_node **stack;\n+     rtx rlabel;\n+     tree tlabel;\n+{\n+  struct label_node *newnode\n+    = (struct label_node *) xmalloc (sizeof (struct label_node));\n+\n+  if (rlabel)\n+    newnode->u.rlabel = rlabel;\n+  else\n+    newnode->u.tlabel = tlabel;\n+  newnode->chain = *stack;\n+  *stack = newnode;\n+}\n+\n+/* Pop a label entry from the given STACK.  */\n+\n+rtx\n+pop_label_entry (stack)\n+     struct label_node **stack;\n+{\n+  rtx label;\n+  struct label_node *tempnode;\n+\n+  if (! *stack)\n+    return NULL_RTX;\n+\n+  tempnode = *stack;\n+  label = tempnode->u.rlabel;\n+  *stack = (*stack)->chain;\n+  free (tempnode);\n+\n+  return label;\n+}\n+\n+/* Return the top element of the given STACK.  */\n+\n+tree\n+top_label_entry (stack)\n+     struct label_node **stack;\n+{\n+  if (! *stack)\n+    return NULL_TREE;\n+\n+  return (*stack)->u.tlabel;\n+}\n+\n+/* Copy an entry.  */\n+\n+static struct eh_entry *\n+copy_eh_entry (entry)\n+     struct eh_entry *entry;\n+{\n+  struct eh_entry *newentry;\n+\n+  newentry = (struct eh_entry *) xmalloc (sizeof (struct eh_entry));\n+  bcopy ((char *) entry, (char *) newentry, sizeof (struct eh_entry));\n+\n+  return newentry;\n+}\n+\n+/* Push an entry onto the given STACK.  */\n+\n+static rtx\n+push_eh_entry (stack)\n+     struct eh_stack *stack;\n+{\n+  struct eh_node *node = (struct eh_node *) xmalloc (sizeof (struct eh_node));\n+  struct eh_entry *entry = (struct eh_entry *) xmalloc (sizeof (struct eh_entry));\n+\n+  entry->start_label = gen_label_rtx ();\n+  entry->end_label = gen_label_rtx ();\n+  entry->exception_handler_label = gen_label_rtx ();\n+  entry->finalization = NULL_TREE;\n+\n+  node->entry = entry;\n+  node->chain = stack->top;\n+  stack->top = node;\n+\n+  return entry->start_label;\n+}\n+\n+/* Pop an entry from the given STACK.  */\n+\n+static struct eh_entry *\n+pop_eh_entry (stack)\n+     struct eh_stack *stack;\n+{\n+  struct eh_node *tempnode;\n+  struct eh_entry *tempentry;\n+  \n+  tempnode = stack->top;\n+  tempentry = tempnode->entry;\n+  stack->top = stack->top->chain;\n+  free (tempnode);\n+\n+  return tempentry;\n+}\n+\n+/* Enqueue an ENTRY onto the given QUEUE.  */\n+\n+static void\n+enqueue_eh_entry (queue, entry)\n+     struct eh_queue *queue;\n+     struct eh_entry *entry;\n+{\n+  struct eh_node *node = (struct eh_node *) xmalloc (sizeof (struct eh_node));\n+\n+  node->entry = entry;\n+  node->chain = NULL;\n+\n+  if (queue->head == NULL)\n+    {\n+      queue->head = node;\n+    }\n+  else\n+    {\n+      queue->tail->chain = node;\n+    }\n+  queue->tail = node;\n+}\n+\n+/* Dequeue an entry from the given QUEUE.  */\n+\n+static struct eh_entry *\n+dequeue_eh_entry (queue)\n+     struct eh_queue *queue;\n+{\n+  struct eh_node *tempnode;\n+  struct eh_entry *tempentry;\n+\n+  if (queue->head == NULL)\n+    return NULL;\n+\n+  tempnode = queue->head;\n+  queue->head = queue->head->chain;\n+\n+  tempentry = tempnode->entry;\n+  free (tempnode);\n+\n+  return tempentry;\n+}\n+\f\n+/* Routine to see if exception exception handling is turned on.\n+   DO_WARN is non-zero if we want to inform the user that exception\n+   handling is turned off.  */\n+\n+int\n+doing_eh (do_warn)\n+     int do_warn;\n+{\n+  if (! flag_exceptions)\n+    {\n+      static int warned = 0;\n+      if (! warned && do_warn)\n+\t{\n+\t  error (\"exception handling disabled, use -fexceptions to enable\");\n+\t  warned = 1;\n+\t}\n+      return 0;\n+    }\n+  return 1;\n+}\n+\n+/* Given the return address in ADDR, compute the new pc to throw.\n+   This has to work for the current frame of the current function, and\n+   the one above it in the case of throw.  */\n+\n+rtx\n+eh_outer_context (addr)\n+     rtx addr;\n+{\n+  /* First mask out any unwanted bits.  */\n+#ifdef MASK_RETURN_ADDR\n+  emit_insn (gen_rtx (SET, Pmode,\n+\t\t      addr,\n+\t\t      gen_rtx (AND, Pmode,\n+\t\t\t       addr, MASK_RETURN_ADDR)));\n+#endif\n+\n+  /* Then subtract out enough to get into the prior region.  If this\n+     is defined, assume we don't need to subtract anything, as it is\n+     already within the region.  */\n+#if ! defined (RETURN_ADDR_OFFSET)\n+  addr = plus_constant (addr, -1);\n+#endif\n+\n+  return addr;\n+}\n+\n+/* Output a note marking the start of an exception handling region.  */\n+\n+void\n+expand_eh_region_start ()\n+{\n+  rtx note;\n+\n+  /* This is the old code.  */\n+  if (! doing_eh (0))\n+    return;\n+\n+#if 0\n+  /* Maybe do this to prevent jumping in and so on...  */\n+  pushlevel (0);\n+#endif\n+\n+  note = emit_note (NULL_PTR, NOTE_INSN_EH_REGION_BEG);\n+  emit_label (push_eh_entry (&ehstack));\n+  NOTE_BLOCK_NUMBER (note)\n+    = CODE_LABEL_NUMBER (ehstack.top->entry->exception_handler_label);\n+}\n+\n+/* Output a note marking the end of an exception handling region.\n+   HANDLER is the the handler for the exception region.  */\n+\n+void\n+expand_eh_region_end (handler)\n+     tree handler;\n+{\n+  rtx note;\n+\n+  struct eh_entry *entry;\n+\n+  if (! doing_eh (0))\n+    return;\n+\n+  entry = pop_eh_entry (&ehstack);\n+\n+  note = emit_note (NULL_PTR, NOTE_INSN_EH_REGION_END);\n+  NOTE_BLOCK_NUMBER (note) = CODE_LABEL_NUMBER (entry->exception_handler_label);\n+\n+  emit_label (entry->end_label);\n+\n+  /* Put in something that takes up space, as otherwise the end\n+     address for the EH region could have the exact same address as\n+     the outer region, causing us to miss the fact that resuming\n+     exception handling with this PC value would be inside the outer\n+     region.  */\n+  emit_insn (gen_nop ());\n+\n+  entry->finalization = handler;\n+\n+  enqueue_eh_entry (&ehqueue, entry);\n+\n+\n+#if 0\n+  /* Makebe do this to prevent jumping in and so on...  */\n+  poplevel (1, 0, 0);\n+#endif\n+}\n+\n+/* Emit a call to __throw and note that we threw something.  */\n+\n+static void\n+emit_throw ()\n+{\n+#ifdef JUMP_TO_THROW\n+  emit_indirect_jump (throw_libfunc);\n+#else\n+  emit_library_call (throw_libfunc, 0, VOIDmode, 0);\n+#endif\n+  throw_used = 1;\n+  emit_barrier ();\n+}\n+\n+/* An internal throw with an indirect CONTEXT we want to throw from.  */\n+\n+void\n+expand_internal_throw_indirect (context)\n+     rtx context;\n+{\n+  emit_move_insn (eh_saved_pc_rtx, context);\n+  emit_throw ();\n+}\n+\n+/* An internal throw with a direct CONTEXT we want to throw from.  The\n+   context should be a label.  */\n+\n+void\n+expand_internal_throw (context)\n+     rtx context;\n+{\n+  expand_internal_throw_indirect (gen_rtx (LABEL_REF, Pmode, context));\n+}\n+\n+/* Called from expand_exception_blocks and expand_end_catch_block to\n+   expand any pending handlers.  */\n+\n+void\n+expand_leftover_cleanups ()\n+{\n+  struct eh_entry *entry;\n+\n+  while ((entry = dequeue_eh_entry (&ehqueue)) != 0)\n+    {\n+      rtx prev;\n+\n+      emit_label (entry->exception_handler_label);\n+\n+      expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n+\n+      prev = get_last_insn ();\n+      if (! (prev && GET_CODE (prev) == BARRIER))\n+\t{\n+\t  /* The below can be optimized away, and we could just fall into the\n+\t     next EH handler, if we are certain they are nested.  */\n+\t  /* Code to throw out to outer context, if we fall off end of the\n+\t     handler.  */\n+\t  expand_internal_throw (entry->end_label);\n+\t}\n+\n+      /* leftover try block, opps.  */\n+      if (entry->finalization == integer_zero_node)\n+\tabort ();\n+\n+      free (entry);\n+    }\n+}\n+\n+/* Generate RTL for the start of all the catch blocks.  Used for\n+   arranging for the exception handling code to be placed farther out\n+   of line than normal.  */\n+\n+void\n+expand_start_all_catch ()\n+{\n+  struct eh_entry *entry;\n+  tree label;\n+\n+  if (! doing_eh (1))\n+    return;\n+\n+  emit_line_note (input_filename, lineno);\n+  label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+\n+  /* The label for the exception handling block we will save.  This is\n+     Lresume, in the documention.  */\n+  expand_label (label);\n+  \n+  /* Put in something that takes up space, as otherwise the end\n+     address for the EH region could have the exact same address as\n+     the outer region, causing us to miss the fact that resuming\n+     exception handling with this PC value would be inside the outer\n+     region.  */\n+  emit_insn (gen_nop ());\n+\n+  push_label_entry (&caught_return_label_stack, NULL_RTX, label);\n+\n+  /* Start a new sequence for all the catch blocks.  We will add this\n+     to the gloabl sequence catch_clauses, when we have completed all\n+     the handlers in this handler-seq.  */\n+  start_sequence ();\n+\n+  while (1)\n+    {\n+      rtx prev;\n+\n+      entry = dequeue_eh_entry (&ehqueue);\n+      emit_label (entry->exception_handler_label);\n+\n+      expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n+\n+      /* When we get down to the matching entry, stop.  */\n+      if (entry->finalization == integer_zero_node)\n+\tbreak;\n+\n+      prev = get_last_insn ();\n+      if (! (prev && GET_CODE (prev) == BARRIER))\n+\t{\n+\t  /* The below can be optimized away, and we could just fall into the\n+\t     next EH handler, if we are certain they are nested.  */\n+\t  /* Code to throw out to outer context, if we fall off end of the\n+\t     handler.  */\n+\t  expand_internal_throw (entry->end_label);\n+\t}\n+\n+      free (entry);\n+    }\n+}\n+\n+/* Generate RTL for the end of all the catch blocks.  */\n+\n+void\n+expand_end_all_catch ()\n+{\n+  rtx new_catch_clause;\n+\n+  if (! doing_eh (1))\n+    return;\n+\n+  /* Code to throw out to outer context, if we fall off end of catch\n+     handlers.  This is rethrow (Lresume, same id, same obj); in the\n+     documentation.  */\n+  expand_internal_throw (DECL_RTL (top_label_entry (&caught_return_label_stack)));\n+\n+  /* Now we have the complete catch sequence.  */\n+  new_catch_clause = get_insns ();\n+  end_sequence ();\n+  \n+  /* This level of catch blocks is done, so set up the successful\n+     catch jump label for the next layer of catch blocks.  */\n+  pop_label_entry (&caught_return_label_stack);\n+\n+  /* Add the new sequence of catches to the main one for this function.  */\n+  push_to_sequence (catch_clauses);\n+  emit_insns (new_catch_clause);\n+  catch_clauses = get_insns ();\n+  end_sequence ();\n+  \n+  /* Here we fall through into the continuation code.  */\n+}\n+\n+/* End all the pending exception regions from protect_list that have\n+   been started, but not yet completed.  */\n+\n+void\n+end_protect_partials ()\n+{\n+  while (protect_list)\n+    {\n+      expand_eh_region_end (TREE_VALUE (protect_list));\n+      protect_list = TREE_CHAIN (protect_list);\n+    }\n+}\n+\f\n+/* The exception table that we build that is used for looking up and\n+   dispatching exceptions, it's size, and it's maximum size before we\n+   have to extend it.  */\n+static int *eh_table;\n+static int eh_table_size;\n+static int eh_table_max_size;\n+\n+/* Note the need for an exception table entry for region N.  If we\n+   don't need to output an explicit exception table, avoid all the\n+   extra work.  Called during final_scan_insn time.  */\n+\n+void\n+add_eh_table_entry (n)\n+     int n;\n+{\n+#ifndef OMIT_EH_TABLE\n+  if (eh_table_size >= eh_table_max_size)\n+    {\n+      if (eh_table)\n+\t{\n+\t  eh_table_max_size += eh_table_max_size>>1;\n+\n+\t  if (eh_table_max_size < 0)\n+\t    abort ();\n+\n+\t  if ((eh_table = (int *) realloc (eh_table, eh_table_max_size))\n+\t      == 0)\n+\t    fatal (\"virtual memory exhausted\");\n+\t}\n+      else\n+\t{\n+\t  eh_table_max_size = 252;\n+\t  eh_table = (int *) xmalloc (eh_table_max_size * sizeof (int));\n+\t}\n+    }\n+  eh_table[eh_table_size++] = n;\n+#endif\n+}\n+\n+/* Conditional to test to see if we need to output an exception table.\n+   Note, on some platforms, we don't have to output a table\n+   explicitly.  This routine doesn't mean we don't have one.  */\n+\n+int\n+exception_table_p ()\n+{\n+  if (eh_table)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Output an entry N for the exception table to the specified FILE.  */\n+\n+static void\n+output_exception_table_entry (file, n)\n+     FILE *file;\n+     int n;\n+{\n+  char buf[256];\n+  rtx sym;\n+\n+  ASM_GENERATE_INTERNAL_LABEL (buf, \"LEHB\", n);\n+  sym = gen_rtx (SYMBOL_REF, Pmode, buf);\n+  assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n+\n+  ASM_GENERATE_INTERNAL_LABEL (buf, \"LEHE\", n);\n+  sym = gen_rtx (SYMBOL_REF, Pmode, buf);\n+  assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n+\n+  ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", n);\n+  sym = gen_rtx (SYMBOL_REF, Pmode, buf);\n+  assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n+\n+  putc ('\\n', file);\t\t/* blank line */\n+}\n+\n+/* Output the exception table if we have one and need one.  */\n+\n+void\n+output_exception_table ()\n+{\n+  int i;\n+  extern FILE *asm_out_file;\n+\n+  if (! doing_eh (0))\n+    return;\n+\n+  exception_section ();\n+\n+  /* Beginning marker for table.  */\n+  assemble_align (GET_MODE_ALIGNMENT (ptr_mode));\n+  assemble_label (\"__EXCEPTION_TABLE__\");\n+\n+  assemble_integer (const0_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n+  assemble_integer (const0_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n+  assemble_integer (const0_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n+  putc ('\\n', asm_out_file);\t\t/* blank line */\n+\n+  for (i = 0; i < eh_table_size; ++i)\n+    output_exception_table_entry (asm_out_file, eh_table[i]);\n+\n+  free (eh_table);\n+\n+  /* Ending marker for table.  */\n+  assemble_label (\"__EXCEPTION_END__\");\n+  assemble_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n+  assemble_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n+  assemble_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n+  putc ('\\n', asm_out_file);\t\t/* blank line */\n+}\n+\n+/* Generate code to initialize the exception table at program startup\n+   time.  */\n+\n+void\n+register_exception_table ()\n+{\n+  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__register_exceptions\"), 0,\n+\t\t     VOIDmode, 1,\n+\t\t     gen_rtx (SYMBOL_REF, Pmode, \"__EXCEPTION_TABLE__\"),\n+\t\t     Pmode);\n+}\n+\f\n+/* Emit the RTL for the start of the per function unwinder for the\n+   current function.  */\n+\n+void\n+start_eh_unwinder ()\n+{\n+#ifdef DOESNT_NEED_UNWINDER\n+  if (DOESNT_NEED_UNWINDER)\n+    return;\n+#endif\n+\n+  expand_eh_region_start ();\n+}\n+\n+/* Emit the RTL for the end of the per function unwinder for the\n+   current function.  */\n+\n+void\n+end_eh_unwinder ()\n+{\n+  tree expr;\n+  rtx return_val_rtx, ret_val, label, end, insns;\n+\n+  if (! doing_eh (0))\n+    return;\n+\n+#ifdef DOESNT_NEED_UNWINDER\n+  if (DOESNT_NEED_UNWINDER)\n+    return;\n+#endif\n+\n+  expr = make_node (RTL_EXPR);\n+  TREE_TYPE (expr) = void_type_node;\n+  RTL_EXPR_RTL (expr) = const0_rtx;\n+  TREE_SIDE_EFFECTS (expr) = 1;\n+  start_sequence_for_rtl_expr (expr);\n+\n+  ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n+\t\t\t\t\t0, hard_frame_pointer_rtx);\n+  return_val_rtx = copy_to_reg (ret_val);\n+\n+  return_val_rtx = eh_outer_context (return_val_rtx);\n+\n+  emit_move_insn (eh_saved_pc_rtx, return_val_rtx);\n+  \n+#ifdef JUMP_TO_THROW\n+  emit_move_insn (ret_val, throw_libfunc);\n+#else\n+  label = gen_label_rtx ();\n+  emit_move_insn (ret_val, gen_rtx (LABEL_REF, Pmode, label));\n+#endif\n+\n+#ifdef RETURN_ADDR_OFFSET\n+  return_val_rtx = plus_constant (ret_val, -RETURN_ADDR_OFFSET);\n+  if (return_val_rtx != ret_val)\n+    emit_move_insn (ret_val, return_val_rtx);\n+#endif\n+  \n+  end = gen_label_rtx ();\n+  emit_jump (end);  \n+\n+  RTL_EXPR_SEQUENCE (expr) = get_insns ();\n+  end_sequence ();\n+  expand_eh_region_end (expr);\n+\n+  emit_jump (end);\n+\n+#ifndef JUMP_TO_THROW\n+  emit_label (label);\n+  emit_throw ();\n+#endif\n+  \n+  expand_leftover_cleanups ();\n+\n+  emit_label (end);\n+}\n+\n+/* Emit the RTL for the per function unwinder for the current\n+   function, if needed.  Called after all the code that needs unwind\n+   protection is output.  */\n+\n+void\n+emit_unwinder ()\n+{\n+  rtx insns;\n+\n+  start_sequence ();\n+  start_eh_unwinder ();\n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  if (insns)\n+    emit_insns_after (insns, get_insns ());\n+\n+  end_eh_unwinder ();\n+}\n+\n+/* Scan the current insns and build a list of handler labels.  Called\n+   after the last exception handling region is added to the current\n+   function (when the rtl is almost all built for the current\n+   function) and before the jump optimization pass.  */\n+\n+void\n+find_exception_handler_labels ()\n+{\n+  rtx insn;\n+  int max_labelno = max_label_num ();\n+  int min_labelno = get_first_label_num ();\n+  rtx *labels;\n+\n+  exception_handler_labels = NULL_RTX;\n+\n+  /* If we aren't doing exception handling, there isn't much to check.  */\n+  if (! doing_eh (0))\n+    return;\n+\n+  /* First we generate a handy reference to each label.  */\n+\n+  labels = (rtx *) alloca ((max_labelno - min_labelno) * sizeof (rtx));\n+  labels -= min_labelno;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\tif (CODE_LABEL_NUMBER (insn) >= min_labelno\n+\t    && CODE_LABEL_NUMBER (insn) < max_labelno)\n+\t  labels[CODE_LABEL_NUMBER (insn)] = insn;\n+    }\n+\n+  /* Then for each start of a region, we add its label to the list.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n+\t{\n+\t  rtx label = NULL_RTX;\n+\n+\t  if (NOTE_BLOCK_NUMBER (insn) >= min_labelno\n+\t      && NOTE_BLOCK_NUMBER (insn) < max_labelno)\n+\t    {\n+\t      label = labels[NOTE_BLOCK_NUMBER (insn)];\n+\n+\t      if (label)\n+\t\texception_handler_labels\n+\t\t  = gen_rtx (EXPR_LIST, VOIDmode,\n+\t\t\t     label, exception_handler_labels);\n+\t      else\n+\t\twarning (\"didn't find handler for EH region %d\",\n+\t\t\t NOTE_BLOCK_NUMBER (insn));\n+\t    }\n+\t  else\n+\t    warning (\"mismatched EH region %d\", NOTE_BLOCK_NUMBER (insn));\n+\t}\n+    }\n+}\n+\n+/* Do some sanity checking on the exception_handler_labels list.  Can\n+   be called after find_exception_handler_labels is called to build\n+   the list of exception handlers for the current function, and before\n+   we finish processing the current function.  */\n+\n+void\n+check_exception_handler_labels ()\n+{\n+  rtx insn, handler;\n+\n+  /* If we aren't doing exception handling, there isn't much to check.  */\n+  if (! doing_eh (0))\n+    return;\n+\n+  for (handler = exception_handler_labels;\n+       handler;\n+       handler = XEXP (handler, 1))\n+    {\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (GET_CODE (insn) == CODE_LABEL)\n+\t    {\n+\t      if (CODE_LABEL_NUMBER (insn)\n+\t\t  == CODE_LABEL_NUMBER (XEXP (handler, 0)))\n+\t\t{\n+\t\t  if (insn != XEXP (handler, 0))\n+\t\t    warning (\"mismatched handler %d\",\n+\t\t\t     CODE_LABEL_NUMBER (insn));\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      if (insn == NULL_RTX)\n+\twarning (\"handler not found %d\",\n+\t\t CODE_LABEL_NUMBER (XEXP (handler, 0)));\n+    }\n+\n+  /* Now go through, and make sure that for each region we have, that we\n+     have the corresponding label.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == NOTE\n+\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG ||\n+\t      NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END))\n+\t{\n+\t  for (handler = exception_handler_labels;\n+\t       handler;\n+\t       handler = XEXP (handler, 1))\n+\t    {\n+\t      if (CODE_LABEL_NUMBER (XEXP (handler, 0))\n+\t\t  == NOTE_BLOCK_NUMBER (insn))\n+\t\tbreak;\n+\t    }\n+\t  if (handler == NULL_RTX)\n+\t    warning (\"region exists, no handler %d\",\n+\t\t     NOTE_BLOCK_NUMBER (insn));\n+\t}\n+    }\n+}\n+\f\n+/* This group of functions initializes the exception handling data\n+   structures at the start of the compilation, initializes the data\n+   structures at the start of a function, saves and restores the\n+   exception handling data structures for the start/end of a nested\n+   function.  */\n+\n+/* Toplevel initialization for EH things.  */ \n+\n+void\n+init_eh ()\n+{\n+  eh_saved_pc_rtx = gen_rtx (MEM, ptr_mode,\n+\t\t\t     gen_rtx (SYMBOL_REF, Pmode, \"__eh_pc\"));\n+}\n+\n+/* Initialize various EH things.  */\n+\n+void\n+init_eh_for_function ()\n+{\n+  ehstack.top = 0;\n+  ehqueue.head = ehqueue.tail = 0;\n+  catch_clauses = NULL_RTX;\n+  false_label_stack = 0;\n+  caught_return_label_stack = 0;\n+  protect_list = NULL_TREE;\n+}\n+\n+/* Save various EH things for the current function into the save area\n+   denoted by P.  */\n+\n+void\n+save_eh_status (p)\n+     struct function *p;\n+{\n+  p->ehstack = ehstack;\n+  p->ehqueue = ehqueue;\n+  p->catch_clauses = catch_clauses;\n+  p->false_label_stack = false_label_stack;\n+  p->caught_return_label_stack = caught_return_label_stack;\n+  p->protect_list = protect_list;\n+\n+  init_eh ();\n+}\n+\n+/* Restore various EH things for the current function from the save\n+   area denoted by P.  */\n+\n+void\n+restore_eh_status (p)\n+     struct function *p;\n+{\n+  protect_list = p->protect_list;\n+  caught_return_label_stack = p->caught_return_label_stack;\n+  false_label_stack = p->false_label_stack;\n+  catch_clauses\t= p->catch_clauses;\n+  ehqueue = p->ehqueue;\n+  ehstack = p->ehstack;\n+}\n+\f\n+/* This section is for the exception handling specific optimization\n+   pass.  First are the internal routines, and then the main\n+   optimization pass.  */\n+\n+/* Determine if the given INSN can throw an exception.  */\n+\n+static int\n+can_throw (insn)\n+     rtx insn;\n+{\n+  /* The only things that can possibly throw are calls.  */\n+  if (GET_CODE (insn) == CALL_INSN)\n+    return 1;\n+\n+#ifdef ASYNCH_EXCEPTIONS\n+  /* If we wanted asynchronous exceptions, then everything but NOTEs\n+     and CODE_LABELs could throw.  */\n+  if (GET_CODE (insn) != NOTE && GET_CODE (insn) != CODE_LABEL)\n+    return 1;\n+#endif\n+\n+  return 0;\n+}\n+\n+/* Scan a region, looking for a matching end, and decide if the region\n+   can be removed.  INSN is the start of the region, N is the region\n+   number, and DELETE_OUTER is to note if anything in this region can\n+   throw.  */\n+\n+static rtx\n+scan_region (insn, n, delete_outer)\n+     rtx insn;\n+     int n;\n+     int *delete_outer;\n+{\n+  rtx start = insn;\n+\n+  /* Assume we can delete the region.  */\n+  int delete = 1;\n+\n+  insn = NEXT_INSN (insn);\n+\n+  /* Look for the matching end.  */\n+  while (! (GET_CODE (insn) == NOTE\n+\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END))\n+    {\n+      /* If anything can throw, we can't remove the region.  */\n+      if (delete && can_throw (insn))\n+\t{\n+\t  delete = 0;\n+\t}\n+\n+      /* Watch out for and handle nested regions.  */\n+      if (GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n+\t{\n+\t  insn = scan_region (insn, NOTE_BLOCK_NUMBER (insn), &delete);\n+\t}\n+\n+      insn = NEXT_INSN (insn);\n+    }\n+\n+  /* The _BEG/_END NOTEs must match and nest.  */\n+  if (NOTE_BLOCK_NUMBER (insn) != n)\n+    abort ();\n+\n+  /* If anything can throw, we can throw.  */\n+  if (! delete)\n+    *delete_outer = 0;\n+  else\n+    {\n+      /* Delete the start and end of the region.  */\n+      delete_insn (start);\n+      delete_insn (insn);\n+\n+      /* Only do this part if we have built the exception handler\n+         labels.  */\n+      if (exception_handler_labels)\n+\t{\n+\t  rtx x, *prev = &exception_handler_labels;\n+\n+\t  /* Find it in the list of handlers.  */\n+\t  for (x = exception_handler_labels; x; x = XEXP (x, 1))\n+\t    {\n+\t      rtx label = XEXP (x, 0);\n+\t      if (CODE_LABEL_NUMBER (label) == n)\n+\t\t{\n+\t\t  /* If we are the last reference to the handler,\n+                     delete it.  */\n+\t\t  if (--LABEL_NUSES (label) == 0)\n+\t\t    delete_insn (label);\n+\n+\t\t  if (optimize)\n+\t\t    {\n+\t\t      /* Remove it from the list of exception handler\n+\t\t\t labels, if we are optimizing.  If we are not, then\n+\t\t\t leave it in the list, as we are not really going to\n+\t\t\t remove the region.  */\n+\t\t      *prev = XEXP (x, 1);\n+\t\t      XEXP (x, 1) = 0;\n+\t\t      XEXP (x, 0) = 0;\n+\t\t    }\n+\n+\t\t  break;\n+\t\t}\n+\t      prev = &XEXP (x, 1);\n+\t    }\n+\t}\n+    }\n+  return insn;\n+}\n+\n+/* Perform various interesting optimizations for exception handling\n+   code.\n+\n+   We find empty exception regions, and remove them.  The jump\n+   optimization code will remove the handler if nothing else uses it.  */\n+\n+void\n+exception_optimize ()\n+{\n+  rtx insn, regions = NULL_RTX;\n+  int n;\n+\n+  /* First remove empty regions.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n+\t{\n+\t  insn = scan_region (insn, NOTE_BLOCK_NUMBER (insn), &n);\n+\t}\n+    }\n+}"}, {"sha": "56be5203fdef950062da2c351f85a1e2be5aee79", "filename": "gcc/except.h", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4956d07c7e28164b075454eddcd136dcf0b028c6/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4956d07c7e28164b075454eddcd136dcf0b028c6/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=4956d07c7e28164b075454eddcd136dcf0b028c6", "patch": "@@ -0,0 +1,98 @@\n+/* Exception Handling interface routines.\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Contributed by Mike Stump <mrs@cygnus.com>.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+#ifndef GET_CODE\n+#define rtx int *\n+#endif\n+\n+#ifdef TREE_CODE\n+\n+struct label_node {\n+  union {\n+    rtx rlabel;\n+    tree tlabel;\n+  } u;\n+  struct label_node *chain;\n+};\n+\n+/* A entry for the exception handling stack EHSTACK or the exception\n+   handling queue EHQUEUE.  */\n+struct eh_entry {\n+  rtx start_label;\n+  rtx end_label;\n+  rtx exception_handler_label;\n+\n+  tree finalization;\n+};\n+\n+struct eh_node {\n+  struct eh_entry *entry;\n+  struct eh_node *chain;\n+};\n+\n+struct eh_stack {\n+  struct eh_node *top;\n+};\n+\n+struct eh_queue {\n+  struct eh_node *head;\n+  struct eh_node *tail;\n+};\n+\n+\n+extern void push_label_entry\t\t\tPROTO((struct label_node **labelstack, rtx rlabel, tree tlabel));\n+extern rtx pop_label_entry\t\t\tPROTO((struct label_node **labelstack));\n+extern tree top_label_entry\t\t\tPROTO((struct label_node **labelstack));\n+\n+extern struct eh_stack ehstack;\n+extern struct eh_queue ehqueue;\n+extern rtx catch_clauses;\n+extern tree protect_list;\n+\n+#endif\n+\n+struct function;\n+\n+extern void init_eh\t\t\t\tPROTO((void));\n+extern void init_eh_for_function\t\tPROTO((void));\n+extern void save_eh_status\t\t\tPROTO((struct function *p));\n+extern void restore_eh_status\t\t\tPROTO((struct function *p));\n+extern void add_eh_table_entry\t\t\tPROTO((int));\n+extern int exception_table_p\t\t\tPROTO((void));\n+extern void output_exception_table\t\tPROTO((void));\n+extern rtx eh_outer_context\t\t\tPROTO((rtx));\n+extern void emit_unwinder\t\t\tPROTO((void));\n+extern void end_eh_unwinder\t\t\tPROTO((void));\n+extern void find_handler_labels\t\t\tPROTO((void));\n+extern void check_handler_labels\t\tPROTO((void));\n+\n+\n+extern struct label_node *caught_return_label_stack;\n+extern struct label_node *false_label_stack;\n+\n+extern rtx exception_handler_labels;\n+\n+/* The rtx for the saved PC value.  */\n+\n+extern rtx eh_saved_pc_rtx;\n+\n+extern void exception_optimize\t\t\tPROTO((void));"}]}