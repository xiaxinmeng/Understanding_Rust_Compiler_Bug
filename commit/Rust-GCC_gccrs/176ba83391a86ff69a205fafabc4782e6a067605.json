{"sha": "176ba83391a86ff69a205fafabc4782e6a067605", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc2YmE4MzM5MWE4NmZmNjlhMjA1ZmFmYWJjNDc4MmU2YTA2NzYwNQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2004-10-11T17:44:11Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2004-10-11T17:44:11Z"}, "message": "Initial revision\n\nFrom-SVN: r88890", "tree": {"sha": "e055f73c7b0fda3dbab90b2325070a88433e9d53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e055f73c7b0fda3dbab90b2325070a88433e9d53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/176ba83391a86ff69a205fafabc4782e6a067605", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/176ba83391a86ff69a205fafabc4782e6a067605", "html_url": "https://github.com/Rust-GCC/gccrs/commit/176ba83391a86ff69a205fafabc4782e6a067605", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/176ba83391a86ff69a205fafabc4782e6a067605/comments", "author": null, "committer": null, "parents": [{"sha": "73826a39157b700044fc99e2bb966fcc4b68501a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73826a39157b700044fc99e2bb966fcc4b68501a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73826a39157b700044fc99e2bb966fcc4b68501a"}], "stats": {"total": 20355, "additions": 20355, "deletions": 0}, "files": [{"sha": "9cf94bb35673d67786957d0df87b67aaf622f29a", "filename": "zlib/as400/bndsrc", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fas400%2Fbndsrc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fas400%2Fbndsrc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fas400%2Fbndsrc?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,132 @@\n+STRPGMEXP PGMLVL(*CURRENT) SIGNATURE('ZLIB')\n+\n+/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n+/*   Version 1.1.3 entry points.                                    */\n+/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n+\n+/********************************************************************/\n+/*   *MODULE      ADLER32      ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"adler32\")\n+\n+/********************************************************************/\n+/*   *MODULE      COMPRESS     ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"compress\")\n+  EXPORT SYMBOL(\"compress2\")\n+\n+/********************************************************************/\n+/*   *MODULE      CRC32        ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"crc32\")\n+  EXPORT SYMBOL(\"get_crc_table\")\n+\n+/********************************************************************/\n+/*   *MODULE      DEFLATE      ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"deflate\")\n+  EXPORT SYMBOL(\"deflateEnd\")\n+  EXPORT SYMBOL(\"deflateSetDictionary\")\n+  EXPORT SYMBOL(\"deflateCopy\")\n+  EXPORT SYMBOL(\"deflateReset\")\n+  EXPORT SYMBOL(\"deflateParams\")\n+  EXPORT SYMBOL(\"deflatePrime\")\n+  EXPORT SYMBOL(\"deflateInit_\")\n+  EXPORT SYMBOL(\"deflateInit2_\")\n+\n+/********************************************************************/\n+/*   *MODULE      GZIO         ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"gzopen\")\n+  EXPORT SYMBOL(\"gzdopen\")\n+  EXPORT SYMBOL(\"gzsetparams\")\n+  EXPORT SYMBOL(\"gzread\")\n+  EXPORT SYMBOL(\"gzwrite\")\n+  EXPORT SYMBOL(\"gzprintf\")\n+  EXPORT SYMBOL(\"gzputs\")\n+  EXPORT SYMBOL(\"gzgets\")\n+  EXPORT SYMBOL(\"gzputc\")\n+  EXPORT SYMBOL(\"gzgetc\")\n+  EXPORT SYMBOL(\"gzflush\")\n+  EXPORT SYMBOL(\"gzseek\")\n+  EXPORT SYMBOL(\"gzrewind\")\n+  EXPORT SYMBOL(\"gztell\")\n+  EXPORT SYMBOL(\"gzeof\")\n+  EXPORT SYMBOL(\"gzclose\")\n+  EXPORT SYMBOL(\"gzerror\")\n+\n+/********************************************************************/\n+/*   *MODULE      INFLATE      ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"inflate\")\n+  EXPORT SYMBOL(\"inflateEnd\")\n+  EXPORT SYMBOL(\"inflateSetDictionary\")\n+  EXPORT SYMBOL(\"inflateSync\")\n+  EXPORT SYMBOL(\"inflateReset\")\n+  EXPORT SYMBOL(\"inflateInit_\")\n+  EXPORT SYMBOL(\"inflateInit2_\")\n+  EXPORT SYMBOL(\"inflateSyncPoint\")\n+\n+/********************************************************************/\n+/*   *MODULE      UNCOMPR      ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"uncompress\")\n+\n+/********************************************************************/\n+/*   *MODULE      ZUTIL        ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"zlibVersion\")\n+  EXPORT SYMBOL(\"zError\")\n+\n+/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n+/*   Version 1.2.1 additional entry points.                         */\n+/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n+\n+/********************************************************************/\n+/*   *MODULE      COMPRESS     ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"compressBound\")\n+\n+/********************************************************************/\n+/*   *MODULE      DEFLATE      ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"deflateBound\")\n+\n+/********************************************************************/\n+/*   *MODULE      GZIO         ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"gzungetc\")\n+  EXPORT SYMBOL(\"gzclearerr\")\n+\n+/********************************************************************/\n+/*   *MODULE      INFBACK      ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"inflateBack\")\n+  EXPORT SYMBOL(\"inflateBackEnd\")\n+  EXPORT SYMBOL(\"inflateBackInit_\")\n+\n+/********************************************************************/\n+/*   *MODULE      INFLATE      ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"inflateCopy\")\n+\n+/********************************************************************/\n+/*   *MODULE      ZUTIL        ZLIB         01/02/01  00:15:09      */\n+/********************************************************************/\n+\n+  EXPORT SYMBOL(\"zlibCompileFlags\")\n+\n+ENDPGMEXP"}, {"sha": "dcd24215d62fe0282c26f8281ed0214d0754f2dc", "filename": "zlib/as400/compile.clp", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fas400%2Fcompile.clp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fas400%2Fcompile.clp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fas400%2Fcompile.clp?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,123 @@\n+/******************************************************************************/\n+/*                                                                            */\n+/*  ZLIB                                                                      */\n+/*                                                                            */\n+/*    Compile sources into modules and link them into a service program.      */\n+/*                                                                            */\n+/******************************************************************************/\n+\n+             PGM\n+\n+/*      Configuration adjustable parameters.                                  */\n+\n+             DCL        VAR(&SRCLIB) TYPE(*CHAR) LEN(10) +\n+                          VALUE('ZLIB')                         /* Source library. */\n+             DCL        VAR(&SRCFILE) TYPE(*CHAR) LEN(10) +\n+                          VALUE('SOURCES')                      /* Source member file. */\n+             DCL        VAR(&CTLFILE) TYPE(*CHAR) LEN(10) +\n+                          VALUE('TOOLS')                        /* Control member file. */\n+\n+             DCL        VAR(&MODLIB) TYPE(*CHAR) LEN(10) +\n+                          VALUE('ZLIB')                         /* Module library. */\n+\n+             DCL        VAR(&SRVLIB) TYPE(*CHAR) LEN(10) +\n+                          VALUE('LGPL')                         /* Service program library. */\n+\n+             DCL        VAR(&CFLAGS) TYPE(*CHAR) +\n+                          VALUE('OPTIMIZE(40)')                 /* Compile options. */\n+\n+\n+/*      Working storage.                                                      */\n+\n+             DCL        VAR(&CMDLEN) TYPE(*DEC) LEN(15 5) VALUE(300)    /* Command length. */\n+             DCL        VAR(&CMD) TYPE(*CHAR) LEN(512)\n+\n+\n+/*      Compile sources into modules.                                         */\n+\n+             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n+                        '/ADLER32)               SRCFILE(' *TCAT               +\n+                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n+                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n+                        '/COMPRESS)              SRCFILE(' *TCAT               +\n+                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n+                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n+                        '/CRC32)                 SRCFILE(' *TCAT               +\n+                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n+                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n+                        '/DEFLATE)               SRCFILE(' *TCAT               +\n+                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n+                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n+                        '/GZIO)                  SRCFILE(' *TCAT               +\n+                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n+                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n+                        '/INFBACK)               SRCFILE(' *TCAT               +\n+                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n+                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n+                        '/INFFAST)               SRCFILE(' *TCAT               +\n+                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n+                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n+                        '/INFLATE)               SRCFILE(' *TCAT               +\n+                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n+                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n+                        '/INFTREES)              SRCFILE(' *TCAT               +\n+                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n+                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n+                        '/TREES)                 SRCFILE(' *TCAT               +\n+                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n+                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n+                        '/UNCOMPR)               SRCFILE(' *TCAT               +\n+                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n+                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +\n+                        '/ZUTIL)                 SRCFILE(' *TCAT               +\n+                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +\n+                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)\n+             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)\n+\n+\n+/*      Link modules into a service program.                                  */\n+\n+             CRTSRVPGM  SRVPGM(&SRVLIB/ZLIB) +\n+                          MODULE(&MODLIB/ADLER32     &MODLIB/COMPRESS    +\n+                                 &MODLIB/CRC32       &MODLIB/DEFLATE     +\n+                                 &MODLIB/GZIO        &MODLIB/INFBACK     +\n+                                 &MODLIB/INFFAST     &MODLIB/INFLATE     +\n+                                 &MODLIB/INFTREES    &MODLIB/TREES       +\n+                                 &MODLIB/UNCOMPR     &MODLIB/ZUTIL)      +\n+                          SRCFILE(&SRCLIB/&CTLFILE) SRCMBR(BNDSRC) +\n+                          TEXT('ZLIB 1.2.1') TGTRLS(V4R4M0)\n+\n+             ENDPGM"}, {"sha": "eef7cb2ec63d79de893a5eb2b0ac07224013b5ec", "filename": "zlib/as400/readme.txt", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fas400%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fas400%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fas400%2Freadme.txt?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,111 @@\n+        ZLIB version 1.2.1 for AS400 installation instructions\n+\n+I) From an AS400 *SAVF file:\n+\n+1)      Unpacking archive to an AS400 save file\n+\n+On the AS400:\n+\n+_       Create the ZLIB AS400 library:\n+\n+        CRTLIB LIB(ZLIB) TYPE(PROD) TEXT('ZLIB compression API library')\n+\n+_       Create a work save file, for example:\n+\n+                CRTSAVF FILE(ZLIB/ZLIBSAVF)\n+\n+On a PC connected to the target AS400:\n+\n+_       Unpack the save file image to a PC file \"ZLIBSAVF\"\n+_       Upload this file into the save file on the AS400, for example\n+                using ftp in BINARY mode.\n+\n+\n+2)      Populating the ZLIB AS400 source library\n+\n+On the AS400:\n+\n+_       Extract the saved objects into the ZLIB AS400 library using:\n+\n+RSTOBJ OBJ(*ALL) SAVLIB(ZLIB) DEV(*SAVF) SAVF(ZLIB/ZLIBSAVF) RSTLIB(ZLIB)\n+\n+\n+3)      Customize installation:\n+\n+_       Edit CL member ZLIB/TOOLS(COMPILE) and change parameters if needed,\n+                according to the comments.\n+\n+_       Compile this member with:\n+\n+        CRTCLPGM PGM(ZLIB/COMPILE) SRCFILE(ZLIB/TOOLS) SRCMBR(COMPILE)\n+\n+\n+4)      Compile and generate the service program:\n+\n+_       This can now be done by executing:\n+\n+        CALL PGM(ZLIB/COMPILE)\n+\n+\n+\n+II) From the original source distribution:\n+\n+1)      On the AS400, create the source library:\n+\n+        CRTLIB LIB(ZLIB) TYPE(PROD) TEXT('ZLIB compression API library')\n+\n+2)      Create the source files:\n+\n+        CRTSRCPF FILE(ZLIB/SOURCES) RCDLEN(112) TEXT('ZLIB library modules')\n+        CRTSRCPF FILE(ZLIB/H)       RCDLEN(112) TEXT('ZLIB library includes')\n+        CRTSRCPF FILE(ZLIB/TOOLS)   RCDLEN(112) TEXT('ZLIB library control utilities')\n+\n+3)      From the machine hosting the distribution files, upload them (with\n+                FTP in text mode, for example) according to the following table:\n+\n+    Original    AS400   AS400    AS400 AS400\n+    file        file    member   type  description\n+                SOURCES                Original ZLIB C subprogram sources\n+    adler32.c           ADLER32  C     ZLIB - Compute the Adler-32 checksum of a dta strm\n+    compress.c          COMPRESS C     ZLIB - Compress a memory buffer\n+    crc32.c             CRC32    C     ZLIB - Compute the CRC-32 of a data stream\n+    deflate.c           DEFLATE  C     ZLIB - Compress data using the deflation algorithm\n+    gzio.c              GZIO     C     ZLIB - IO on .gz files\n+    infback.c           INFBACK  C     ZLIB - Inflate using a callback interface\n+    inffast.c           INFFAST  C     ZLIB - Fast proc. literals & length/distance pairs\n+    inflate.c           INFLATE  C     ZLIB - Interface to inflate modules\n+    inftrees.c          INFTREES C     ZLIB - Generate Huffman trees for efficient decode\n+    trees.c             TREES    C     ZLIB - Output deflated data using Huffman coding\n+    uncompr.c           UNCOMPR  C     ZLIB - Decompress a memory buffer\n+    zutil.c             ZUTIL    C     ZLIB - Target dependent utility functions\n+                H                      Original ZLIB C and ILE/RPG include files\n+    crc32.h             CRC32    C     ZLIB - CRC32 tables\n+    deflate.h           DEFLATE  C     ZLIB - Internal compression state\n+    inffast.h           INFFAST  C     ZLIB - Header to use inffast.c\n+    inffixed.h          INFFIXED C     ZLIB - Table for decoding fixed codes\n+    inflate.h           INFLATE  C     ZLIB - Internal inflate state definitions\n+    inftrees.h          INFTREES C     ZLIB - Header to use inftrees.c\n+    trees.h             TREES    C     ZLIB - Created automatically with -DGEN_TREES_H\n+    zconf.h             ZCONF    C     ZLIB - Compression library configuration\n+    zlib.h              ZLIB     C     ZLIB - Compression library C user interface\n+    as400/zlib.inc      ZLIB.INC RPGLE ZLIB - Compression library ILE RPG user interface\n+    zutil.h             ZUTIL    C     ZLIB - Internal interface and configuration\n+                TOOLS                  Building source software & AS/400 README\n+    as400/bndsrc        BNDSRC         Entry point exportation list\n+    as400/compile.clp   COMPILE  CLP   Compile sources & generate service program\n+    as400/readme.txt    README   TXT   Installation instructions\n+\n+4)      Continue as in I)3).\n+\n+\n+\n+\n+Notes:  For AS400 ILE RPG programmers, a /copy member defining the ZLIB\n+                API prototypes for ILE RPG can be found in ZLIB/H(ZLIB.INC).\n+                Please read comments in this member for more information.\n+\n+        Remember that most foreign textual data are ASCII coded: this\n+                implementation does not handle conversion from/to ASCII, so\n+                text data code conversions must be done explicitely.\n+\n+        Always open zipped files in binary mode."}, {"sha": "03c6cf089bba25d9830e644c8763b6f709308460", "filename": "zlib/as400/zlib.inc", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fas400%2Fzlib.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fas400%2Fzlib.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fas400%2Fzlib.inc?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,327 @@\n+      *  ZLIB.INC - Interface to the general purpose compression library\n+      *\n+      *  ILE RPG400 version by Patrick Monnerat, DATASPHERE.\n+      *  Version 1.2.1\n+      *\n+      *\n+      *  WARNING:\n+      *     Procedures inflateInit(), inflateInit2(), deflateInit(),\n+      *         deflateInit2() and inflateBackInit() need to be called with\n+      *         two additional arguments:\n+      *         the package version string and the stream control structure.\n+      *         size. This is needed because RPG lacks some macro feature.\n+      *         Call these procedures as:\n+      *             inflateInit(...: ZLIB_VERSION: %size(z_stream))\n+      *\n+      /if not defined(ZLIB_H_)\n+      /define ZLIB_H_\n+      *\n+      **************************************************************************\n+      *                               Constants\n+      **************************************************************************\n+      *\n+     D ZLIB_VERSION    C                   '1.2.1'                            Header's version\n+     D ZLIB_VERNUM     C                   X'1210'\n+      *\n+     D Z_NO_FLUSH      C                   0\n+     D Z_SYNC_FLUSH    C                   2\n+     D Z_FULL_FLUSH    C                   3\n+     D Z_FINISH        C                   4\n+     D Z_BLOCK         C                   5\n+      *\n+     D Z_OK            C                   0\n+     D Z_STREAM_END    C                   1\n+     D Z_NEED_DICT     C                   2\n+     D Z_ERRNO         C                   -1\n+     D Z_STREAM_ERROR  C                   -2\n+     D Z_DATA_ERROR    C                   -3\n+     D Z_MEM_ERROR     C                   -4\n+     D Z_BUF_ERROR     C                   -5\n+     DZ_VERSION_ERROR  C                   -6\n+      *\n+     D Z_NO_COMPRESSION...\n+     D                 C                   0\n+     D Z_BEST_SPEED    C                   1\n+     D Z_BEST_COMPRESSION...\n+     D                 C                   9\n+     D Z_DEFAULT_COMPRESSION...\n+     D                 C                   -1\n+      *\n+     D Z_FILTERED      C                   1\n+     D Z_HUFFMAN_ONLY  C                   2\n+     D Z_RLE           C                   3\n+     D Z_DEFAULT_STRATEGY...\n+     D                 C                   0\n+      *\n+     D Z_BINARY        C                   0\n+     D Z_ASCII         C                   1\n+     D Z_UNKNOWN       C                   2\n+      *\n+     D Z_DEFLATED      C                   8\n+      *\n+     D Z_NULL          C                   0\n+      *\n+      **************************************************************************\n+      *                                 Types\n+      **************************************************************************\n+      *\n+     D z_streamp       S               *                                        Stream struct ptr\n+     D gzFile          S               *                                        File pointer\n+     D z_off_t         S             10i 0                                      Stream offsets\n+      *\n+      **************************************************************************\n+      *                               Structures\n+      **************************************************************************\n+      *\n+      *  The GZIP encode/decode stream support structure.\n+      *\n+     D z_stream        DS                  align based(z_streamp)\n+     D  zs_next_in                     *                                        Next input byte\n+     D  zs_avail_in                  10U 0                                      Byte cnt at next_in\n+     D  zs_total_in                  10U 0                                      Total bytes read\n+     D  zs_next_out                    *                                        Output buffer ptr\n+     D  zs_avail_out                 10U 0                                      Room left @ next_out\n+     D  zs_total_out                 10U 0                                      Total bytes written\n+     D  zs_msg                         *                                        Last errmsg or null\n+     D  zs_state                       *                                        Internal state\n+     D  zs_zalloc                      *   procptr                              Int. state allocator\n+     D  zs_free                        *   procptr                              Int. state dealloc.\n+     D  zs_opaque                      *                                        Private alloc. data\n+     D  zs_data_type                 10i 0                                      ASC/BIN best guess\n+     D  zs_adler                     10u 0                                      Uncompr. adler32 val\n+     D                               10U 0                                      Reserved\n+     D                               10U 0                                      Ptr. alignment\n+      *\n+      **************************************************************************\n+      *                     Utility function prototypes\n+      **************************************************************************\n+      *\n+     D compress        PR            10I 0 extproc('compress')\n+     D  dest                      32767    options(*varsize)                    Destination buffer\n+     D  destLen                      10U 0                                      Destination length\n+     D  source                    32767    const options(*varsize)              Source buffer\n+     D  sourceLen                    10u 0 value                                Source length\n+      *\n+     D compress2       PR            10I 0 extproc('compress2')\n+     D  dest                      32767    options(*varsize)                    Destination buffer\n+     D  destLen                      10U 0                                      Destination length\n+     D  source                    32767    const options(*varsize)              Source buffer\n+     D  sourceLen                    10U 0 value                                Source length\n+     D  level                        10I 0 value                                Compression level\n+      *\n+     D compressBound   PR            10U 0 extproc('compressBound')\n+     D  sourceLen                    10U 0 value\n+      *\n+     D uncompress      PR            10I 0 extproc('uncompress')\n+     D  dest                      32767    options(*varsize)                    Destination buffer\n+     D  destLen                      10U 0                                      Destination length\n+     D  source                    32767    const options(*varsize)              Source buffer\n+     D  sourceLen                    10U 0 value                                Source length\n+      *\n+     D gzopen          PR                  extproc('gzopen')\n+     D                                     like(gzFile)\n+     D  path                           *   value options(*string)               File pathname\n+     D  mode                           *   value options(*string)               Open mode\n+      *\n+     D gzdopen         PR                  extproc('gzdopen')\n+     D                                     like(gzFile)\n+     D  fd                           10i 0 value                                File descriptor\n+     D  mode                           *   value options(*string)               Open mode\n+      *\n+     D gzsetparams     PR            10I 0 extproc('gzsetparams')\n+     D  file                               value like(gzFile)                   File pointer\n+     D  level                        10I 0 value\n+     D  strategy                     10i 0 value\n+      *\n+     D gzread          PR            10I 0 extproc('gzread')\n+     D  file                               value like(gzFile)                   File pointer\n+     D  buf                       32767    options(*varsize)                    Buffer\n+     D  len                          10u 0 value                                Buffer length\n+      *\n+     D gzwrite         PR            10I 0 extproc('gzwrite')\n+     D  file                               value like(gzFile)                   File pointer\n+     D  buf                       32767    const options(*varsize)              Buffer\n+     D  len                          10u 0 value                                Buffer length\n+      *\n+     D gzputs          PR            10I 0 extproc('gzputs')\n+     D  file                               value like(gzFile)                   File pointer\n+     D  s                              *   value options(*string)               String to output\n+      *\n+     D gzgets          PR              *   extproc('gzgets')\n+     D  file                               value like(gzFile)                   File pointer\n+     D  buf                       32767    options(*varsize)                    Read buffer\n+     D  len                          10i 0 value                                Buffer length\n+      *\n+     D gzflush         PR            10i 0 extproc('gzflush')\n+     D  file                               value like(gzFile)                   File pointer\n+     D  flush                        10I 0 value                                Type of flush\n+      *\n+     D gzseek          PR                  extproc('gzseek')\n+     D                                     like(z_off_t)\n+     D  file                               value like(gzFile)                   File pointer\n+     D  offset                             value like(z_off_t)                  Offset\n+     D  whence                       10i 0 value                                Origin\n+      *\n+     D gzrewind        PR            10i 0 extproc('gzrewind')\n+     D  file                               value like(gzFile)                   File pointer\n+      *\n+     D gztell          PR                  extproc('gztell')\n+     D                                     like(z_off_t)\n+     D  file                               value like(gzFile)                   File pointer\n+      *\n+     D gzeof           PR            10i 0 extproc('gzeof')\n+     D  file                               value like(gzFile)                   File pointer\n+      *\n+     D gzclose         PR            10i 0 extproc('gzclose')\n+     D  file                               value like(gzFile)                   File pointer\n+      *\n+     D gzerror         PR              *   extproc('gzerror')                   Error string\n+     D  file                               value like(gzFile)                   File pointer\n+     D  errnum                       10I 0                                      Error code\n+      *\n+     D gzclearerr      PR                  extproc('gzclearerr')\n+     D  file                               value like(gzFile)                   File pointer\n+      *\n+      **************************************************************************\n+      *                        Basic function prototypes\n+      **************************************************************************\n+      *\n+     D zlibVersion     PR              *   extproc('zlibVersion')               Version string\n+      *\n+     D deflateInit     PR            10I 0 extproc('deflateInit_')              Init. compression\n+     D  strm                               like(z_stream)                       Compression stream\n+     D  level                        10I 0 value                                Compression level\n+     D  version                        *   value options(*string)               Version string\n+     D  stream_size                  10i 0 value                                Stream struct. size\n+      *\n+     D deflate         PR            10I 0 extproc('deflate')                   Compress data\n+     D  strm                               like(z_stream)                       Compression stream\n+     D  flush                        10I 0 value                                Flush type required\n+      *\n+     D deflateEnd      PR            10I 0 extproc('deflateEnd')                Termin. compression\n+     D  strm                               like(z_stream)                       Compression stream\n+      *\n+     D inflateInit     PR            10I 0 extproc('inflateInit_')              Init. expansion\n+     D  strm                               like(z_stream)                       Expansion stream\n+     D  version                        *   value options(*string)               Version string\n+     D  stream_size                  10i 0 value                                Stream struct. size\n+      *\n+     D inflate         PR            10I 0 extproc('inflate')                   Expand data\n+     D  strm                               like(z_stream)                       Expansion stream\n+     D  flush                        10I 0 value                                Flush type required\n+      *\n+     D inflateEnd      PR            10I 0 extproc('inflateEnd')                Termin. expansion\n+     D  strm                               like(z_stream)                       Expansion stream\n+      *\n+      **************************************************************************\n+      *                        Advanced function prototypes\n+      **************************************************************************\n+      *\n+     D deflateInit2    PR            10I 0 extproc('deflateInit2_')             Init. compression\n+     D  strm                               like(z_stream)                       Compression stream\n+     D  level                        10I 0 value                                Compression level\n+     D  method                       10I 0 value                                Compression method\n+     D  windowBits                   10I 0 value                                log2(window size)\n+     D  memLevel                     10I 0 value                                Mem/cmpress tradeoff\n+     D  strategy                     10I 0 value                                Compression stategy\n+     D  version                        *   value options(*string)               Version string\n+     D  stream_size                  10i 0 value                                Stream struct. size\n+      *\n+     D deflateSetDictionary...\n+     D                 PR            10I 0 extproc('deflateSetDictionary')      Init. dictionary\n+     D  strm                               like(z_stream)                       Compression stream\n+     D  dictionary                32767    const options(*varsize)              Dictionary bytes\n+     D  dictLength                   10U 0 value                                Dictionary length\n+      *\n+     D deflateCopy     PR            10I 0 extproc('deflateCopy')               Compress strm 2 strm\n+     D  dest                               like(z_stream)                       Destination stream\n+     D  source                             like(z_stream)                       Source stream\n+      *\n+     D deflateReset    PR            10I 0 extproc('deflateReset')              End and init. stream\n+     D  strm                               like(z_stream)                       Compression stream\n+      *\n+     D deflateParams   PR            10I 0 extproc('deflateParams')             Change level & strat\n+     D  strm                               like(z_stream)                       Compression stream\n+     D  level                        10I 0 value                                Compression level\n+     D  strategy                     10I 0 value                                Compression stategy\n+      *\n+     D deflateBound    PR            10U 0 extproc('deflateBound')              Change level & strat\n+     D  strm                               like(z_stream)                       Compression stream\n+     D  sourcelen                    10U 0 value                                Compression level\n+      *\n+     D deflatePrime    PR            10I 0 extproc('deflatePrime')              Change level & strat\n+     D  strm                               like(z_stream)                       Compression stream\n+     D  bits                         10I 0 value                                Number of bits to insert\n+     D  value                        10I 0 value                                Bits to insert\n+      *\n+     D inflateInit2    PR            10I 0 extproc('inflateInit2_')             Init. expansion\n+     D  strm                               like(z_stream)                       Expansion stream\n+     D  windowBits                   10I 0 value                                log2(window size)\n+     D  version                        *   value options(*string)               Version string\n+     D  stream_size                  10i 0 value                                Stream struct. size\n+      *\n+     D inflateSetDictionary...\n+     D                 PR            10I 0 extproc('inflateSetDictionary')      Init. dictionary\n+     D  strm                               like(z_stream)                       Expansion stream\n+     D  dictionary                32767    const options(*varsize)              Dictionary bytes\n+     D  dictLength                   10U 0 value                                Dictionary length\n+      *\n+     D inflateSync     PR            10I 0 extproc('inflateSync')               Sync. expansion\n+     D  strm                               like(z_stream)                       Expansion stream\n+      *\n+     D inflateCopy     PR            10I 0 extproc('inflateCopy')\n+     D  dest                               like(z_stream)                       Destination stream\n+     D  source                             like(z_stream)                       Source stream\n+      *\n+     D inflateReset    PR            10I 0 extproc('inflateReset')              End and init. stream\n+     D  strm                               like(z_stream)                       Expansion stream\n+      *\n+     D inflateBackInit...\n+     D                 PR            10I 0 extproc('inflateBackInit_')\n+     D  strm                               like(z_stream)                       Expansion stream\n+     D  windowBits                   10I 0 value                                Log2(buffer size)\n+     D  window                    32767    options(*varsize)                    Buffer\n+     D  version                        *   value options(*string)               Version string\n+     D  stream_size                  10i 0 value                                Stream struct. size\n+      *\n+     D inflateBack     PR            10I 0 extproc('inflateBack')\n+     D  strm                               like(z_stream)                       Expansion stream\n+     D  in                             *   value procptr                        Input function\n+     D  in_desc                        *   value                                Input descriptor\n+     D  out                            *   value procptr                        Output function\n+     D  out_desc                       *   value                                Output descriptor\n+      *\n+     D inflateBackEnd  PR            10I 0 extproc('inflateBackEnd')\n+     D  strm                               like(z_stream)                       Expansion stream\n+      *\n+     D zlibCompileFlags...\n+     D                 PR            10U 0 extproc('zlibCompileFlags')\n+      *\n+      **************************************************************************\n+      *                        Checksum function prototypes\n+      **************************************************************************\n+      *\n+     D adler32         PR            10U 0 extproc('adler32')                   New checksum\n+     D  adler                        10U 0 value                                Old checksum\n+     D  buf                       32767    const options(*varsize)              Bytes to accumulate\n+     D  len                          10U 0 value                                Buffer length\n+      *\n+     D crc32           PR            10U 0 extproc('crc32')                     New checksum\n+     D  crc                          10U 0 value                                Old checksum\n+     D  buf                       32767    const options(*varsize)              Bytes to accumulate\n+     D  len                          10U 0 value                                Buffer length\n+      *\n+      **************************************************************************\n+      *                     Miscellaneous function prototypes\n+      **************************************************************************\n+      *\n+     D zError          PR              *   extproc('zError')                    Error string\n+     D  err                          10I 0 value                                Error code\n+      *\n+     D inflateSyncPoint...\n+     D                 PR            10I 0 extproc('inflateSyncPoint')\n+     D  strm                               like(z_stream)                       Expansion stream\n+      *\n+     D get_crc_table   PR              *   extproc('get_crc_table')             Ptr to ulongs\n+      *\n+      /endif"}, {"sha": "91a96cd1e9cea4eaab60c976b4c73d66ed1c0fb9", "filename": "zlib/contrib/ada/mtest.adb", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fmtest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fmtest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fmtest.adb?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,153 @@\n+----------------------------------------------------------------\n+--  ZLib for Ada thick binding.                               --\n+--                                                            --\n+--  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --\n+--                                                            --\n+--  Open source license information is in the zlib.ads file.  --\n+----------------------------------------------------------------\n+--  Continuous test for ZLib multithreading. If the test is fail\n+--  Wou should provide thread safe allocation routines for the Z_Stream.\n+--\n+--  $Id: mtest.adb,v 1.2 2003/08/12 12:11:05 vagul Exp $\n+\n+with ZLib;\n+with Ada.Streams;\n+with Ada.Numerics.Discrete_Random;\n+with Ada.Text_IO;\n+with Ada.Exceptions;\n+with Ada.Task_Identification;\n+\n+procedure MTest is\n+   use Ada.Streams;\n+   use ZLib;\n+\n+   Stop : Boolean := False;\n+\n+   pragma Atomic (Stop);\n+\n+   subtype Visible_Symbols is Stream_Element range 16#20# .. 16#7E#;\n+\n+   package Random_Elements is\n+      new Ada.Numerics.Discrete_Random (Visible_Symbols);\n+\n+   task type Test_Task;\n+\n+   task body Test_Task is\n+      Buffer : Stream_Element_Array (1 .. 100_000);\n+      Gen : Random_Elements.Generator;\n+\n+      Buffer_First  : Stream_Element_Offset;\n+      Compare_First : Stream_Element_Offset;\n+\n+      Deflate : Filter_Type;\n+      Inflate : Filter_Type;\n+\n+      procedure Further (Item : in Stream_Element_Array);\n+\n+      procedure Read_Buffer\n+        (Item : out Ada.Streams.Stream_Element_Array;\n+         Last : out Ada.Streams.Stream_Element_Offset);\n+\n+      -------------\n+      -- Further --\n+      -------------\n+\n+      procedure Further (Item : in Stream_Element_Array) is\n+\n+         procedure Compare (Item : in Stream_Element_Array);\n+\n+         -------------\n+         -- Compare --\n+         -------------\n+\n+         procedure Compare (Item : in Stream_Element_Array) is\n+            Next_First : Stream_Element_Offset := Compare_First + Item'Length;\n+         begin\n+            if Buffer (Compare_First .. Next_First - 1) /= Item then\n+               raise Program_Error;\n+            end if;\n+\n+            Compare_First := Next_First;\n+         end Compare;\n+\n+         procedure Compare_Write is new ZLib.Write (Write => Compare);\n+      begin\n+         Compare_Write (Inflate, Item, No_Flush);\n+      end Further;\n+\n+      -----------------\n+      -- Read_Buffer --\n+      -----------------\n+\n+      procedure Read_Buffer\n+        (Item : out Ada.Streams.Stream_Element_Array;\n+         Last : out Ada.Streams.Stream_Element_Offset)\n+      is\n+         Buff_Diff   : Stream_Element_Offset := Buffer'Last - Buffer_First;\n+         Next_First : Stream_Element_Offset;\n+      begin\n+         if Item'Length <= Buff_Diff then\n+            Last := Item'Last;\n+\n+            Next_First := Buffer_First + Item'Length;\n+\n+            Item := Buffer (Buffer_First .. Next_First - 1);\n+\n+            Buffer_First := Next_First;\n+         else\n+            Last := Item'First + Buff_Diff;\n+            Item (Item'First .. Last) := Buffer (Buffer_First .. Buffer'Last);\n+            Buffer_First := Buffer'Last + 1;\n+         end if;\n+      end Read_Buffer;\n+\n+      procedure Translate is new Generic_Translate\n+                                   (Data_In  => Read_Buffer,\n+                                    Data_Out => Further);\n+\n+   begin\n+      Random_Elements.Reset (Gen);\n+\n+      Buffer := (others => 20);\n+\n+      Main : loop\n+         for J in Buffer'Range loop\n+            Buffer (J) := Random_Elements.Random (Gen);\n+\n+            Deflate_Init (Deflate);\n+            Inflate_Init (Inflate);\n+\n+            Buffer_First  := Buffer'First;\n+            Compare_First := Buffer'First;\n+\n+            Translate (Deflate);\n+\n+            if Compare_First /= Buffer'Last + 1 then\n+               raise Program_Error;\n+            end if;\n+\n+            Ada.Text_IO.Put_Line\n+              (Ada.Task_Identification.Image\n+                 (Ada.Task_Identification.Current_Task)\n+               & Stream_Element_Offset'Image (J)\n+               & ZLib.Count'Image (Total_Out (Deflate)));\n+\n+            Close (Deflate);\n+            Close (Inflate);\n+\n+            exit Main when Stop;\n+         end loop;\n+      end loop Main;\n+   exception\n+      when E : others =>\n+         Ada.Text_IO.Put_Line (Ada.Exceptions.Exception_Information (E));\n+         Stop := True;\n+   end Test_Task;\n+\n+   Test : array (1 .. 4) of Test_Task;\n+\n+   pragma Unreferenced (Test);\n+\n+begin\n+   null;\n+end MTest;"}, {"sha": "184ea00c31820d0e3fd65d1905f1d342e1a37f21", "filename": "zlib/contrib/ada/read.adb", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fread.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fread.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fread.adb?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,151 @@\n+----------------------------------------------------------------\n+--  ZLib for Ada thick binding.                               --\n+--                                                            --\n+--  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --\n+--                                                            --\n+--  Open source license information is in the zlib.ads file.  --\n+----------------------------------------------------------------\n+\n+--  $Id: read.adb,v 1.7 2003/08/12 12:12:35 vagul Exp $\n+\n+--  Test/demo program for the generic read interface.\n+\n+with Ada.Numerics.Discrete_Random;\n+with Ada.Streams;\n+with Ada.Text_IO;\n+\n+with ZLib;\n+\n+procedure Read is\n+\n+   use Ada.Streams;\n+\n+   ------------------------------------\n+   --  Test configuration parameters --\n+   ------------------------------------\n+\n+   File_Size   : Stream_Element_Offset := 100_000;\n+\n+   Continuous  : constant Boolean          := False;\n+   --  If this constant is True, the test would be repeated again and again,\n+   --  with increment File_Size for every iteration.\n+\n+   Header      : constant ZLib.Header_Type := ZLib.Default;\n+   --  Do not use Header other than Default in ZLib versions 1.1.4 and older.\n+\n+   Init_Random : constant := 8;\n+   --  We are using the same random sequence, in case of we catch bug,\n+   --  so we would be able to reproduce it.\n+\n+   -- End --\n+\n+   Pack_Size : Stream_Element_Offset;\n+   Offset    : Stream_Element_Offset;\n+\n+   Filter     : ZLib.Filter_Type;\n+\n+   subtype Visible_Symbols\n+      is Stream_Element range 16#20# .. 16#7E#;\n+\n+   package Random_Elements is new\n+      Ada.Numerics.Discrete_Random (Visible_Symbols);\n+\n+   Gen : Random_Elements.Generator;\n+   Period  : constant Stream_Element_Offset := 200;\n+   --  Period constant variable for random generator not to be very random.\n+   --  Bigger period, harder random.\n+\n+   Read_Buffer : Stream_Element_Array (1 .. 2048);\n+   Read_First  : Stream_Element_Offset;\n+   Read_Last   : Stream_Element_Offset;\n+\n+   procedure Reset;\n+\n+   procedure Read\n+     (Item : out Stream_Element_Array;\n+      Last : out Stream_Element_Offset);\n+   --  this procedure is for generic instantiation of\n+   --  ZLib.Read\n+   --  reading data from the File_In.\n+\n+   procedure Read is new ZLib.Read (Read, Read_Buffer, Read_First, Read_Last);\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Item : out Stream_Element_Array;\n+      Last : out Stream_Element_Offset) is\n+   begin\n+      Last := Stream_Element_Offset'Min\n+               (Item'Last,\n+                Item'First + File_Size - Offset);\n+\n+      for J in Item'First .. Last loop\n+         if J < Item'First + Period then\n+            Item (J) := Random_Elements.Random (Gen);\n+         else\n+            Item (J) := Item (J - Period);\n+         end if;\n+\n+         Offset   := Offset + 1;\n+      end loop;\n+   end Read;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   procedure Reset is\n+   begin\n+      Random_Elements.Reset (Gen, Init_Random);\n+      Pack_Size := 0;\n+      Offset := 1;\n+      Read_First := Read_Buffer'Last + 1;\n+   end Reset;\n+\n+begin\n+   Ada.Text_IO.Put_Line (\"ZLib \" & ZLib.Version);\n+\n+   loop\n+      for Level in ZLib.Compression_Level'Range loop\n+\n+         Ada.Text_IO.Put (\"Level =\"\n+            & ZLib.Compression_Level'Image (Level));\n+\n+         --  Deflate using generic instantiation.\n+\n+         ZLib.Deflate_Init\n+               (Filter,\n+                Level,\n+                Header => Header);\n+\n+         Reset;\n+\n+         Ada.Text_IO.Put\n+           (Stream_Element_Offset'Image (File_Size) & \" ->\");\n+\n+         loop\n+            declare\n+               Buffer : Stream_Element_Array (1 .. 1024);\n+               Last   : Stream_Element_Offset;\n+            begin\n+               Read (Filter, Buffer, Last);\n+\n+               Pack_Size := Pack_Size + Last - Buffer'First + 1;\n+\n+               exit when Last < Buffer'Last;\n+            end;\n+         end loop;\n+\n+         Ada.Text_IO.Put_Line (Stream_Element_Offset'Image (Pack_Size));\n+\n+         ZLib.Close (Filter);\n+      end loop;\n+\n+      exit when not Continuous;\n+\n+      File_Size := File_Size + 1;\n+   end loop;\n+end Read;"}, {"sha": "ad02c225ad0f11eb351450bfc41be20ada11d4bb", "filename": "zlib/contrib/ada/readme.txt", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Freadme.txt?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,52 @@\n+\n+\t\t\tZLib for Ada thick binding (ZLib.Ada)\n+\t\t\tRelease 1.2\n+\n+ZLib.Ada is a thick binding interface to the popular ZLib data\n+compression library, available at http://www.gzip.org/zlib/.\n+It provides Ada-style access to the ZLib C library.\n+\n+\n+\tHere are the main changes since ZLib.Ada 1.1:\n+\n+- The default header type has a name \"Default\" now. Auto is used only for\n+  automatic GZip/ZLib header detection.\n+\n+- Added test for multitasking mtest.adb.\n+\n+- Added GNAT project file zlib.gpr.\n+\n+\n+\tHow to build ZLib.Ada under GNAT\n+\n+You should have the ZLib library already build on your computer, before\n+building ZLib.Ada. Make the directory of ZLib.Ada sources current and\n+issue the command:\n+\n+  gnatmake test -largs -L<directory where libz.a is> -lz\n+\n+Or use the GNAT project file build for GNAT 3.15 or later:\n+\n+  gnatmake -Pzlib.gpr -L<directory where libz.a is>\n+\n+\n+\tHow to build ZLib.Ada under Aonix ObjectAda for Win32 7.2.2\n+\n+1. Make a project with all *.ads and *.adb files from the distribution.\n+2. Build the libz.a library from the ZLib C sources.\n+3. Rename libz.a to z.lib.\n+4. Add the library z.lib to the project.\n+5. Add the libc.lib library from the ObjectAda distribution to the project.\n+6. Build the executable using test.adb as a main procedure.\n+\n+\n+\tHow to use ZLib.Ada\n+\n+The source files test.adb and read.adb are small demo programs that show\n+the main functionality of ZLib.Ada.\n+\n+The routines from the package specifications are commented.\n+\n+\n+Homepage: http://zlib-ada.sourceforge.net/\n+Author: Dmitriy Anisimkov <anisimkov@yahoo.com>"}, {"sha": "90773acfa186694f1af39aad32b497d0368c895a", "filename": "zlib/contrib/ada/test.adb", "status": "added", "additions": 463, "deletions": 0, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Ftest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Ftest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Ftest.adb?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,463 @@\n+----------------------------------------------------------------\n+--  ZLib for Ada thick binding.                               --\n+--                                                            --\n+--  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --\n+--                                                            --\n+--  Open source license information is in the zlib.ads file.  --\n+----------------------------------------------------------------\n+\n+--  $Id: test.adb,v 1.17 2003/08/12 12:13:30 vagul Exp $\n+\n+--  The program has a few aims.\n+--  1. Test ZLib.Ada95 thick binding functionality.\n+--  2. Show the example of use main functionality of the ZLib.Ada95 binding.\n+--  3. Build this program automatically compile all ZLib.Ada95 packages under\n+--     GNAT Ada95 compiler.\n+\n+with ZLib.Streams;\n+with Ada.Streams.Stream_IO;\n+with Ada.Numerics.Discrete_Random;\n+\n+with Ada.Text_IO;\n+\n+with Ada.Calendar;\n+\n+procedure Test is\n+\n+   use Ada.Streams;\n+   use Stream_IO;\n+\n+   ------------------------------------\n+   --  Test configuration parameters --\n+   ------------------------------------\n+\n+   File_Size   : Count   := 100_000;\n+   Continuous  : constant Boolean := False;\n+\n+   Header      : constant ZLib.Header_Type := ZLib.Default;\n+                                              --  ZLib.None;\n+                                              --  ZLib.Auto;\n+                                              --  ZLib.GZip;\n+   --  Do not use Header other then Default in ZLib versions 1.1.4\n+   --  and older.\n+\n+   Strategy    : constant ZLib.Strategy_Type := ZLib.Default_Strategy;\n+   Init_Random : constant := 10;\n+\n+   -- End --\n+\n+   In_File_Name  : constant String := \"testzlib.in\";\n+   --  Name of the input file\n+\n+   Z_File_Name   : constant String := \"testzlib.zlb\";\n+   --  Name of the compressed file.\n+\n+   Out_File_Name : constant String := \"testzlib.out\";\n+   --  Name of the decompressed file.\n+\n+   File_In   : File_Type;\n+   File_Out  : File_Type;\n+   File_Back : File_Type;\n+   File_Z    : ZLib.Streams.Stream_Type;\n+\n+   Filter : ZLib.Filter_Type;\n+\n+   Time_Stamp : Ada.Calendar.Time;\n+\n+   procedure Generate_File;\n+   --  Generate file of spetsified size with some random data.\n+   --  The random data is repeatable, for the good compression.\n+\n+   procedure Compare_Streams\n+     (Left, Right : in out Root_Stream_Type'Class);\n+   --  The procedure compearing data in 2 streams.\n+   --  It is for compare data before and after compression/decompression.\n+\n+   procedure Compare_Files (Left, Right : String);\n+   --  Compare files. Based on the Compare_Streams.\n+\n+   procedure Copy_Streams\n+     (Source, Target : in out Root_Stream_Type'Class;\n+      Buffer_Size    : in     Stream_Element_Offset := 1024);\n+   --  Copying data from one stream to another. It is for test stream\n+   --  interface of the library.\n+\n+   procedure Data_In\n+     (Item : out Stream_Element_Array;\n+      Last : out Stream_Element_Offset);\n+   --  this procedure is for generic instantiation of\n+   --  ZLib.Generic_Translate.\n+   --  reading data from the File_In.\n+\n+   procedure Data_Out (Item : in Stream_Element_Array);\n+   --  this procedure is for generic instantiation of\n+   --  ZLib.Generic_Translate.\n+   --  writing data to the File_Out.\n+\n+   procedure Stamp;\n+   --  Store the timestamp to the local variable.\n+\n+   procedure Print_Statistic (Msg : String; Data_Size : ZLib.Count);\n+   --  Print the time statistic with the message.\n+\n+   procedure Translate is new ZLib.Generic_Translate\n+                                (Data_In  => Data_In,\n+                                 Data_Out => Data_Out);\n+   --  This procedure is moving data from File_In to File_Out\n+   --  with compression or decompression, depend on initialization of\n+   --  Filter parameter.\n+\n+   -------------------\n+   -- Compare_Files --\n+   -------------------\n+\n+   procedure Compare_Files (Left, Right : String) is\n+      Left_File, Right_File : File_Type;\n+   begin\n+      Open (Left_File, In_File, Left);\n+      Open (Right_File, In_File, Right);\n+      Compare_Streams (Stream (Left_File).all, Stream (Right_File).all);\n+      Close (Left_File);\n+      Close (Right_File);\n+   end Compare_Files;\n+\n+   ---------------------\n+   -- Compare_Streams --\n+   ---------------------\n+\n+   procedure Compare_Streams\n+     (Left, Right : in out Ada.Streams.Root_Stream_Type'Class)\n+   is\n+      Left_Buffer, Right_Buffer : Stream_Element_Array (0 .. 16#FFF#);\n+      Left_Last, Right_Last : Stream_Element_Offset;\n+   begin\n+      loop\n+         Read (Left, Left_Buffer, Left_Last);\n+         Read (Right, Right_Buffer, Right_Last);\n+\n+         if Left_Last /= Right_Last then\n+            Ada.Text_IO.Put_Line (\"Compare error :\"\n+              & Stream_Element_Offset'Image (Left_Last)\n+              & \" /= \"\n+              & Stream_Element_Offset'Image (Right_Last));\n+\n+            raise Constraint_Error;\n+\n+         elsif Left_Buffer (0 .. Left_Last)\n+               /= Right_Buffer (0 .. Right_Last)\n+         then\n+            Ada.Text_IO.Put_Line (\"ERROR: IN and OUT files is not equal.\");\n+            raise Constraint_Error;\n+\n+         end if;\n+\n+         exit when Left_Last < Left_Buffer'Last;\n+      end loop;\n+   end Compare_Streams;\n+\n+   ------------------\n+   -- Copy_Streams --\n+   ------------------\n+\n+   procedure Copy_Streams\n+     (Source, Target : in out Ada.Streams.Root_Stream_Type'Class;\n+      Buffer_Size    : in     Stream_Element_Offset := 1024)\n+   is\n+      Buffer : Stream_Element_Array (1 .. Buffer_Size);\n+      Last   : Stream_Element_Offset;\n+   begin\n+      loop\n+         Read  (Source, Buffer, Last);\n+         Write (Target, Buffer (1 .. Last));\n+\n+         exit when Last < Buffer'Last;\n+      end loop;\n+   end Copy_Streams;\n+\n+   -------------\n+   -- Data_In --\n+   -------------\n+\n+   procedure Data_In\n+     (Item : out Stream_Element_Array;\n+      Last : out Stream_Element_Offset) is\n+   begin\n+      Read (File_In, Item, Last);\n+   end Data_In;\n+\n+   --------------\n+   -- Data_Out --\n+   --------------\n+\n+   procedure Data_Out (Item : in Stream_Element_Array) is\n+   begin\n+      Write (File_Out, Item);\n+   end Data_Out;\n+\n+   -------------------\n+   -- Generate_File --\n+   -------------------\n+\n+   procedure Generate_File is\n+      subtype Visible_Symbols is Stream_Element range 16#20# .. 16#7E#;\n+\n+      package Random_Elements is\n+         new Ada.Numerics.Discrete_Random (Visible_Symbols);\n+\n+      Gen    : Random_Elements.Generator;\n+      Buffer : Stream_Element_Array := (1 .. 77 => 16#20#) & 10;\n+\n+      Buffer_Count : constant Count := File_Size / Buffer'Length;\n+      --  Number of same buffers in the packet.\n+\n+      Density : constant Count := 30; --  from 0 to Buffer'Length - 2;\n+\n+      procedure Fill_Buffer (J, D : in Count);\n+      --  Change the part of the buffer.\n+\n+      -----------------\n+      -- Fill_Buffer --\n+      -----------------\n+\n+      procedure Fill_Buffer (J, D : in Count) is\n+      begin\n+         for K in 0 .. D loop\n+            Buffer\n+              (Stream_Element_Offset ((J + K) mod (Buffer'Length - 1) + 1))\n+             := Random_Elements.Random (Gen);\n+\n+         end loop;\n+      end Fill_Buffer;\n+\n+   begin\n+      Random_Elements.Reset (Gen, Init_Random);\n+\n+      Create (File_In, Out_File, In_File_Name);\n+\n+      Fill_Buffer (1, Buffer'Length - 2);\n+\n+      for J in 1 .. Buffer_Count loop\n+         Write (File_In, Buffer);\n+\n+         Fill_Buffer (J, Density);\n+      end loop;\n+\n+      --  fill remain size.\n+\n+      Write\n+        (File_In,\n+         Buffer\n+           (1 .. Stream_Element_Offset\n+                   (File_Size - Buffer'Length * Buffer_Count)));\n+\n+      Flush (File_In);\n+      Close (File_In);\n+   end Generate_File;\n+\n+   ---------------------\n+   -- Print_Statistic --\n+   ---------------------\n+\n+   procedure Print_Statistic (Msg : String; Data_Size : ZLib.Count) is\n+      use Ada.Calendar;\n+      use Ada.Text_IO;\n+\n+      package Count_IO is new Integer_IO (ZLib.Count);\n+\n+      Curr_Dur : Duration := Clock - Time_Stamp;\n+   begin\n+      Put (Msg);\n+\n+      Set_Col (20);\n+      Ada.Text_IO.Put (\"size =\");\n+\n+      Count_IO.Put\n+        (Data_Size,\n+         Width => Stream_IO.Count'Image (File_Size)'Length);\n+\n+      Put_Line (\" duration =\" & Duration'Image (Curr_Dur));\n+   end Print_Statistic;\n+\n+   -----------\n+   -- Stamp --\n+   -----------\n+\n+   procedure Stamp is\n+   begin\n+      Time_Stamp := Ada.Calendar.Clock;\n+   end Stamp;\n+\n+begin\n+   Ada.Text_IO.Put_Line (\"ZLib \" & ZLib.Version);\n+\n+   loop\n+      Generate_File;\n+\n+      for Level in ZLib.Compression_Level'Range loop\n+\n+         Ada.Text_IO.Put_Line (\"Level =\"\n+            & ZLib.Compression_Level'Image (Level));\n+\n+         --  Test generic interface.\n+         Open   (File_In, In_File, In_File_Name);\n+         Create (File_Out, Out_File, Z_File_Name);\n+\n+         Stamp;\n+\n+         --  Deflate using generic instantiation.\n+\n+         ZLib.Deflate_Init\n+               (Filter   => Filter,\n+                Level    => Level,\n+                Strategy => Strategy,\n+                Header   => Header);\n+\n+         Translate (Filter);\n+         Print_Statistic (\"Generic compress\", ZLib.Total_Out (Filter));\n+         ZLib.Close (Filter);\n+\n+         Close (File_In);\n+         Close (File_Out);\n+\n+         Open   (File_In, In_File, Z_File_Name);\n+         Create (File_Out, Out_File, Out_File_Name);\n+\n+         Stamp;\n+\n+         --  Inflate using generic instantiation.\n+\n+         ZLib.Inflate_Init (Filter, Header => Header);\n+\n+         Translate (Filter);\n+         Print_Statistic (\"Generic decompress\", ZLib.Total_Out (Filter));\n+\n+         ZLib.Close (Filter);\n+\n+         Close (File_In);\n+         Close (File_Out);\n+\n+         Compare_Files (In_File_Name, Out_File_Name);\n+\n+         --  Test stream interface.\n+\n+         --  Compress to the back stream.\n+\n+         Open   (File_In, In_File, In_File_Name);\n+         Create (File_Back, Out_File, Z_File_Name);\n+\n+         Stamp;\n+\n+         ZLib.Streams.Create\n+           (Stream          => File_Z,\n+            Mode            => ZLib.Streams.Out_Stream,\n+            Back            => ZLib.Streams.Stream_Access\n+                                 (Stream (File_Back)),\n+            Back_Compressed => True,\n+            Level           => Level,\n+            Strategy        => Strategy,\n+            Header          => Header);\n+\n+         Copy_Streams\n+           (Source => Stream (File_In).all,\n+            Target => File_Z);\n+\n+         --  Flushing internal buffers to the back stream.\n+\n+         ZLib.Streams.Flush (File_Z, ZLib.Finish);\n+\n+         Print_Statistic (\"Write compress\",\n+                          ZLib.Streams.Write_Total_Out (File_Z));\n+\n+         ZLib.Streams.Close (File_Z);\n+\n+         Close (File_In);\n+         Close (File_Back);\n+\n+         --  Compare reading from original file and from\n+         --  decompression stream.\n+\n+         Open (File_In,   In_File, In_File_Name);\n+         Open (File_Back, In_File, Z_File_Name);\n+\n+         ZLib.Streams.Create\n+           (Stream          => File_Z,\n+            Mode            => ZLib.Streams.In_Stream,\n+            Back            => ZLib.Streams.Stream_Access\n+                                 (Stream (File_Back)),\n+            Back_Compressed => True,\n+            Header          => Header);\n+\n+         Stamp;\n+         Compare_Streams (Stream (File_In).all, File_Z);\n+\n+         Print_Statistic (\"Read decompress\",\n+                          ZLib.Streams.Read_Total_Out (File_Z));\n+\n+         ZLib.Streams.Close (File_Z);\n+         Close (File_In);\n+         Close (File_Back);\n+\n+         --  Compress by reading from compression stream.\n+\n+         Open (File_Back, In_File, In_File_Name);\n+         Create (File_Out, Out_File, Z_File_Name);\n+\n+         ZLib.Streams.Create\n+           (Stream          => File_Z,\n+            Mode            => ZLib.Streams.In_Stream,\n+            Back            => ZLib.Streams.Stream_Access\n+                                 (Stream (File_Back)),\n+            Back_Compressed => False,\n+            Level           => Level,\n+            Strategy        => Strategy,\n+            Header          => Header);\n+\n+         Stamp;\n+         Copy_Streams\n+           (Source => File_Z,\n+            Target => Stream (File_Out).all);\n+\n+         Print_Statistic (\"Read compress\",\n+                          ZLib.Streams.Read_Total_Out (File_Z));\n+\n+         ZLib.Streams.Close (File_Z);\n+\n+         Close (File_Out);\n+         Close (File_Back);\n+\n+         --  Decompress to decompression stream.\n+\n+         Open   (File_In,   In_File, Z_File_Name);\n+         Create (File_Back, Out_File, Out_File_Name);\n+\n+         ZLib.Streams.Create\n+           (Stream          => File_Z,\n+            Mode            => ZLib.Streams.Out_Stream,\n+            Back            => ZLib.Streams.Stream_Access\n+                                 (Stream (File_Back)),\n+            Back_Compressed => False,\n+            Header          => Header);\n+\n+         Stamp;\n+\n+         Copy_Streams\n+           (Source => Stream (File_In).all,\n+            Target => File_Z);\n+\n+         Print_Statistic (\"Write decompress\",\n+                          ZLib.Streams.Write_Total_Out (File_Z));\n+\n+         ZLib.Streams.Close (File_Z);\n+         Close (File_In);\n+         Close (File_Back);\n+\n+         Compare_Files (In_File_Name, Out_File_Name);\n+      end loop;\n+\n+      Ada.Text_IO.Put_Line (Count'Image (File_Size) & \" Ok.\");\n+\n+      exit when not Continuous;\n+\n+      File_Size := File_Size + 1;\n+   end loop;\n+end Test;"}, {"sha": "d213b5c17664ca39a242a464fc2591c1f05cf0dc", "filename": "zlib/contrib/ada/zlib-streams.adb", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fzlib-streams.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fzlib-streams.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fzlib-streams.adb?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,215 @@\n+----------------------------------------------------------------\n+--  ZLib for Ada thick binding.                               --\n+--                                                            --\n+--  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --\n+--                                                            --\n+--  Open source license information is in the zlib.ads file.  --\n+----------------------------------------------------------------\n+\n+--  $Id: zlib-streams.adb,v 1.9 2003/08/12 13:15:31 vagul Exp $\n+\n+with Ada.Unchecked_Deallocation;\n+\n+package body ZLib.Streams is\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (Stream : in out Stream_Type) is\n+      procedure Free is new Ada.Unchecked_Deallocation\n+         (Stream_Element_Array, Buffer_Access);\n+   begin\n+      if Stream.Mode = Out_Stream or Stream.Mode = Duplex then\n+         --  We should flush the data written by the writer.\n+\n+         Flush (Stream, Finish);\n+\n+         Close (Stream.Writer);\n+      end if;\n+\n+      if Stream.Mode = In_Stream or Stream.Mode = Duplex then\n+         Close (Stream.Reader);\n+         Free (Stream.Buffer);\n+      end if;\n+   end Close;\n+\n+   ------------\n+   -- Create --\n+   ------------\n+\n+   procedure Create\n+     (Stream            :    out Stream_Type;\n+      Mode              : in     Stream_Mode;\n+      Back              : in     Stream_Access;\n+      Back_Compressed   : in     Boolean;\n+      Level             : in     Compression_Level := Default_Compression;\n+      Strategy          : in     Strategy_Type     := Default_Strategy;\n+      Header            : in     Header_Type       := Default;\n+      Read_Buffer_Size  : in     Ada.Streams.Stream_Element_Offset\n+                                    := Default_Buffer_Size;\n+      Write_Buffer_Size : in     Ada.Streams.Stream_Element_Offset\n+                                    := Default_Buffer_Size)\n+   is\n+\n+      subtype Buffer_Subtype is Stream_Element_Array (1 .. Read_Buffer_Size);\n+\n+      procedure Init_Filter\n+         (Filter   : in out Filter_Type;\n+          Compress : in     Boolean);\n+\n+      -----------------\n+      -- Init_Filter --\n+      -----------------\n+\n+      procedure Init_Filter\n+         (Filter   : in out Filter_Type;\n+          Compress : in     Boolean) is\n+      begin\n+         if Compress then\n+            Deflate_Init\n+              (Filter, Level, Strategy, Header => Header);\n+         else\n+            Inflate_Init (Filter, Header => Header);\n+         end if;\n+      end Init_Filter;\n+\n+   begin\n+      Stream.Back := Back;\n+      Stream.Mode := Mode;\n+\n+      if Mode = Out_Stream or Mode = Duplex then\n+         Init_Filter (Stream.Writer, Back_Compressed);\n+         Stream.Buffer_Size := Write_Buffer_Size;\n+      else\n+         Stream.Buffer_Size := 0;\n+      end if;\n+\n+      if Mode = In_Stream or Mode = Duplex then\n+         Init_Filter (Stream.Reader, not Back_Compressed);\n+\n+         Stream.Buffer     := new Buffer_Subtype;\n+         Stream.Rest_First := Stream.Buffer'Last + 1;\n+      end if;\n+   end Create;\n+\n+   -----------\n+   -- Flush --\n+   -----------\n+\n+   procedure Flush\n+     (Stream : in out Stream_Type;\n+      Mode   : in     Flush_Mode := Sync_Flush)\n+   is\n+      Buffer : Stream_Element_Array (1 .. Stream.Buffer_Size);\n+      Last   : Stream_Element_Offset;\n+   begin\n+      loop\n+         Flush (Stream.Writer, Buffer, Last, Mode);\n+\n+         Ada.Streams.Write (Stream.Back.all, Buffer (1 .. Last));\n+\n+         exit when Last < Buffer'Last;\n+      end loop;\n+   end Flush;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream : in out Stream_Type;\n+      Item   :    out Stream_Element_Array;\n+      Last   :    out Stream_Element_Offset)\n+   is\n+\n+      procedure Read\n+        (Item : out Stream_Element_Array;\n+         Last : out Stream_Element_Offset);\n+\n+      ----------\n+      -- Read --\n+      ----------\n+\n+      procedure Read\n+        (Item : out Stream_Element_Array;\n+         Last : out Stream_Element_Offset) is\n+      begin\n+         Ada.Streams.Read (Stream.Back.all, Item, Last);\n+      end Read;\n+\n+      procedure Read is new ZLib.Read\n+         (Read       => Read,\n+          Buffer     => Stream.Buffer.all,\n+          Rest_First => Stream.Rest_First,\n+          Rest_Last  => Stream.Rest_Last);\n+\n+   begin\n+      Read (Stream.Reader, Item, Last);\n+   end Read;\n+\n+   -------------------\n+   -- Read_Total_In --\n+   -------------------\n+\n+   function Read_Total_In (Stream : in Stream_Type) return Count is\n+   begin\n+      return Total_In (Stream.Reader);\n+   end Read_Total_In;\n+\n+   --------------------\n+   -- Read_Total_Out --\n+   --------------------\n+\n+   function Read_Total_Out (Stream : in Stream_Type) return Count is\n+   begin\n+      return Total_Out (Stream.Reader);\n+   end Read_Total_Out;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream : in out Stream_Type;\n+      Item   : in     Stream_Element_Array)\n+   is\n+\n+      procedure Write (Item : in Stream_Element_Array);\n+\n+      -----------\n+      -- Write --\n+      -----------\n+\n+      procedure Write (Item : in Stream_Element_Array) is\n+      begin\n+         Ada.Streams.Write (Stream.Back.all, Item);\n+      end Write;\n+\n+      procedure Write is new ZLib.Write\n+         (Write       => Write,\n+          Buffer_Size => Stream.Buffer_Size);\n+\n+   begin\n+      Write (Stream.Writer, Item, No_Flush);\n+   end Write;\n+\n+   --------------------\n+   -- Write_Total_In --\n+   --------------------\n+\n+   function Write_Total_In (Stream : in Stream_Type) return Count is\n+   begin\n+      return Total_In (Stream.Writer);\n+   end Write_Total_In;\n+\n+   ---------------------\n+   -- Write_Total_Out --\n+   ---------------------\n+\n+   function Write_Total_Out (Stream : in Stream_Type) return Count is\n+   begin\n+      return Total_Out (Stream.Writer);\n+   end Write_Total_Out;\n+\n+end ZLib.Streams;"}, {"sha": "1d5e904899171b32e60e78f282c03e615c12c8bf", "filename": "zlib/contrib/ada/zlib-streams.ads", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fzlib-streams.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fzlib-streams.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fzlib-streams.ads?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,112 @@\n+----------------------------------------------------------------\n+--  ZLib for Ada thick binding.                               --\n+--                                                            --\n+--  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --\n+--                                                            --\n+--  Open source license information is in the zlib.ads file.  --\n+----------------------------------------------------------------\n+\n+--  $Id: zlib-streams.ads,v 1.11 2003/08/12 13:15:31 vagul Exp $\n+\n+package ZLib.Streams is\n+\n+   type Stream_Mode is (In_Stream, Out_Stream, Duplex);\n+\n+   type Stream_Access is access all Ada.Streams.Root_Stream_Type'Class;\n+\n+   type Stream_Type is\n+      new Ada.Streams.Root_Stream_Type with private;\n+\n+   procedure Read\n+     (Stream : in out Stream_Type;\n+      Item   :    out Ada.Streams.Stream_Element_Array;\n+      Last   :    out Ada.Streams.Stream_Element_Offset);\n+\n+   procedure Write\n+     (Stream : in out Stream_Type;\n+      Item   : in     Ada.Streams.Stream_Element_Array);\n+\n+   procedure Flush\n+     (Stream : in out Stream_Type;\n+      Mode   : in     Flush_Mode := Sync_Flush);\n+   --  Flush the written data to the back stream,\n+   --  all data placed to the compressor is flushing to the Back stream.\n+   --  Should not be used untill necessary, becouse it is decreasing\n+   --  compression.\n+\n+   function Read_Total_In (Stream : in Stream_Type) return Count;\n+   pragma Inline (Read_Total_In);\n+   --  Return total number of bytes read from back stream so far.\n+\n+   function Read_Total_Out (Stream : in Stream_Type) return Count;\n+   pragma Inline (Read_Total_Out);\n+   --  Return total number of bytes read so far.\n+\n+   function Write_Total_In (Stream : in Stream_Type) return Count;\n+   pragma Inline (Write_Total_In);\n+   --  Return total number of bytes written so far.\n+\n+   function Write_Total_Out (Stream : in Stream_Type) return Count;\n+   pragma Inline (Write_Total_Out);\n+   --  Return total number of bytes written to the back stream.\n+\n+   procedure Create\n+     (Stream            :    out Stream_Type;\n+      Mode              : in     Stream_Mode;\n+      Back              : in     Stream_Access;\n+      Back_Compressed   : in     Boolean;\n+      Level             : in     Compression_Level := Default_Compression;\n+      Strategy          : in     Strategy_Type     := Default_Strategy;\n+      Header            : in     Header_Type       := Default;\n+      Read_Buffer_Size  : in     Ada.Streams.Stream_Element_Offset\n+                                    := Default_Buffer_Size;\n+      Write_Buffer_Size : in     Ada.Streams.Stream_Element_Offset\n+                                    := Default_Buffer_Size);\n+   --  Create the Comression/Decompression stream.\n+   --  If mode is In_Stream then Write operation is disabled.\n+   --  If mode is Out_Stream then Read operation is disabled.\n+\n+   --  If Back_Compressed is true then\n+   --  Data written to the Stream is compressing to the Back stream\n+   --  and data read from the Stream is decompressed data from the Back stream.\n+\n+   --  If Back_Compressed is false then\n+   --  Data written to the Stream is decompressing to the Back stream\n+   --  and data read from the Stream is compressed data from the Back stream.\n+\n+   --  !!! When the Need_Header is False ZLib-Ada is using undocumented\n+   --  ZLib 1.1.4 functionality to do not create/wait for ZLib headers.\n+\n+   procedure Close (Stream : in out Stream_Type);\n+\n+private\n+\n+   use Ada.Streams;\n+\n+   type Buffer_Access is access all Stream_Element_Array;\n+\n+   type Stream_Type\n+     is new Root_Stream_Type with\n+   record\n+      Mode       : Stream_Mode;\n+\n+      Buffer     : Buffer_Access;\n+      Rest_First : Stream_Element_Offset;\n+      Rest_Last  : Stream_Element_Offset;\n+      --  Buffer for Read operation.\n+      --  We need to have this buffer in the record\n+      --  becouse not all read data from back stream\n+      --  could be processed during the read operation.\n+\n+      Buffer_Size : Stream_Element_Offset;\n+      --  Buffer size for write operation.\n+      --  We do not need to have this buffer\n+      --  in the record becouse all data could be\n+      --  processed in the write operation.\n+\n+      Back       : Stream_Access;\n+      Reader     : Filter_Type;\n+      Writer     : Filter_Type;\n+   end record;\n+\n+end ZLib.Streams;"}, {"sha": "163bd5b972fcd4334f0afa61019a4b75609a6486", "filename": "zlib/contrib/ada/zlib-thin.adb", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fzlib-thin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fzlib-thin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fzlib-thin.adb?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,185 @@\n+----------------------------------------------------------------\n+--  ZLib for Ada thick binding.                               --\n+--                                                            --\n+--  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --\n+--                                                            --\n+--  Open source license information is in the zlib.ads file.  --\n+----------------------------------------------------------------\n+\n+--  $Id: zlib-thin.adb,v 1.6 2003/01/21 15:26:37 vagul Exp $\n+\n+package body ZLib.Thin is\n+\n+   ZLIB_VERSION : constant Chars_Ptr :=\n+      Interfaces.C.Strings.New_String (\"1.1.4\");\n+\n+   Z_Stream_Size : constant Int := Z_Stream'Size / System.Storage_Unit;\n+\n+   --------------\n+   -- Avail_In --\n+   --------------\n+\n+   function Avail_In (Strm : in Z_Stream) return UInt is\n+   begin\n+      return Strm.Avail_In;\n+   end Avail_In;\n+\n+   ---------------\n+   -- Avail_Out --\n+   ---------------\n+\n+   function Avail_Out (Strm : in Z_Stream) return UInt is\n+   begin\n+      return Strm.Avail_Out;\n+   end Avail_Out;\n+\n+   ------------------\n+   -- Deflate_Init --\n+   ------------------\n+\n+   function Deflate_Init\n+     (strm  : in Z_Streamp;\n+      level : in Int := Z_DEFAULT_COMPRESSION)\n+      return  Int is\n+   begin\n+      return deflateInit (strm, level, ZLIB_VERSION, Z_Stream_Size);\n+   end Deflate_Init;\n+\n+   function Deflate_Init\n+     (strm       : Z_Streamp;\n+      level      : Int;\n+      method     : Int;\n+      windowBits : Int;\n+      memLevel   : Int;\n+      strategy   : Int)\n+      return       Int is\n+   begin\n+      return deflateInit2\n+               (strm,\n+                level,\n+                method,\n+                windowBits,\n+                memLevel,\n+                strategy,\n+                ZLIB_VERSION,\n+                Z_Stream_Size);\n+   end Deflate_Init;\n+\n+   ------------------\n+   -- Inflate_Init --\n+   ------------------\n+\n+   function Inflate_Init (strm : Z_Streamp) return Int is\n+   begin\n+      return inflateInit (strm, ZLIB_VERSION, Z_Stream_Size);\n+   end Inflate_Init;\n+\n+   function Inflate_Init (strm : Z_Streamp; windowBits : Int) return Int is\n+   begin\n+      return inflateInit2 (strm, windowBits, ZLIB_VERSION, Z_Stream_Size);\n+   end Inflate_Init;\n+\n+   function Last_Error_Message (Strm : in Z_Stream) return String is\n+      use Interfaces.C.Strings;\n+   begin\n+      if Strm.msg = Null_Ptr then\n+         return \"\";\n+      else\n+         return Value (Strm.msg);\n+      end if;\n+   end Last_Error_Message;\n+\n+   -------------\n+   -- Need_In --\n+   -------------\n+\n+   function Need_In (strm : Z_Stream) return Boolean is\n+   begin\n+      return strm.Avail_In = 0;\n+   end Need_In;\n+\n+   --------------\n+   -- Need_Out --\n+   --------------\n+\n+   function Need_Out (strm : Z_Stream) return Boolean is\n+   begin\n+      return strm.Avail_Out = 0;\n+   end Need_Out;\n+\n+   ------------\n+   -- Set_In --\n+   ------------\n+\n+   procedure Set_In\n+     (Strm   : in out Z_Stream;\n+      Buffer : in Byte_Access;\n+      Size   : in UInt) is\n+   begin\n+      Strm.Next_In  := Buffer;\n+      Strm.Avail_In := Size;\n+   end Set_In;\n+\n+   procedure Set_In\n+     (Strm   : in out Z_Stream;\n+      Buffer : in Voidp;\n+      Size   : in UInt) is\n+   begin\n+      Set_In (Strm, Bytes.To_Pointer (Buffer), Size);\n+   end Set_In;\n+\n+   ------------------\n+   -- Set_Mem_Func --\n+   ------------------\n+\n+   procedure Set_Mem_Func\n+     (Strm   : in out Z_Stream;\n+      Opaque : in Voidp;\n+      Alloc  : in alloc_func;\n+      Free   : in free_func) is\n+   begin\n+      Strm.opaque := Opaque;\n+      Strm.zalloc := Alloc;\n+      Strm.zfree  := Free;\n+   end Set_Mem_Func;\n+\n+   -------------\n+   -- Set_Out --\n+   -------------\n+\n+   procedure Set_Out\n+     (Strm   : in out Z_Stream;\n+      Buffer : in Byte_Access;\n+      Size   : in UInt) is\n+   begin\n+      Strm.Next_Out  := Buffer;\n+      Strm.Avail_Out := Size;\n+   end Set_Out;\n+\n+   procedure Set_Out\n+     (Strm   : in out Z_Stream;\n+      Buffer : in Voidp;\n+      Size   : in UInt) is\n+   begin\n+      Set_Out (Strm, Bytes.To_Pointer (Buffer), Size);\n+   end Set_Out;\n+\n+   --------------\n+   -- Total_In --\n+   --------------\n+\n+   function Total_In (Strm : in Z_Stream) return ULong is\n+   begin\n+      return Strm.Total_In;\n+   end Total_In;\n+\n+   ---------------\n+   -- Total_Out --\n+   ---------------\n+\n+   function Total_Out (Strm : in Z_Stream) return ULong is\n+   begin\n+      return Strm.Total_Out;\n+   end Total_Out;\n+\n+end ZLib.Thin;"}, {"sha": "c227374f64bcccee00e168b957a91d41f4c39188", "filename": "zlib/contrib/ada/zlib-thin.ads", "status": "added", "additions": 485, "deletions": 0, "changes": 485, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fzlib-thin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fzlib-thin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fzlib-thin.ads?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,485 @@\n+----------------------------------------------------------------\n+--  ZLib for Ada thick binding.                               --\n+--                                                            --\n+--  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --\n+--                                                            --\n+--  Open source license information is in the zlib.ads file.  --\n+----------------------------------------------------------------\n+\n+--  $Id: zlib-thin.ads,v 1.8 2003/08/12 13:16:51 vagul Exp $\n+\n+with Interfaces.C.Strings;\n+with System.Address_To_Access_Conversions;\n+\n+private package ZLib.Thin is\n+\n+   --  From zconf.h\n+\n+   MAX_MEM_LEVEL : constant := 9;         --  zconf.h:105\n+                                          --  zconf.h:105\n+   MAX_WBITS : constant := 15;      --  zconf.h:115\n+                                    --  32K LZ77 window\n+                                    --  zconf.h:115\n+   SEEK_SET : constant := 8#0000#;  --  zconf.h:244\n+                                    --  Seek from beginning of file.\n+                                    --  zconf.h:244\n+   SEEK_CUR : constant := 1;        --  zconf.h:245\n+                                    --  Seek from current position.\n+                                    --  zconf.h:245\n+   SEEK_END : constant := 2;        --  zconf.h:246\n+                                    --  Set file pointer to EOF plus \"offset\"\n+                                    --  zconf.h:246\n+\n+   type Byte is new Interfaces.C.unsigned_char; --  8 bits\n+                                                --  zconf.h:214\n+   type UInt is new Interfaces.C.unsigned;      --  16 bits or more\n+                                                --  zconf.h:216\n+   type Int is new Interfaces.C.int;\n+\n+   type ULong is new Interfaces.C.unsigned;     --  32 bits or more\n+                                                --  zconf.h:217\n+   subtype Chars_Ptr is Interfaces.C.Strings.chars_ptr;\n+\n+   type ULong_Access is access ULong;\n+   type Int_Access is access Int;\n+   subtype Voidp is System.Address;            --  zconf.h:232\n+\n+   package Bytes is new System.Address_To_Access_Conversions (Byte);\n+\n+   subtype Byte_Access is Bytes.Object_Pointer;\n+\n+   --  end from zconf\n+\n+   Z_NO_FLUSH : constant := 8#0000#;   --  zlib.h:125\n+                                       --  zlib.h:125\n+   Z_PARTIAL_FLUSH : constant := 1;       --  zlib.h:126\n+                                          --  will be removed, use\n+                                          --  Z_SYNC_FLUSH instead\n+                                          --  zlib.h:126\n+   Z_SYNC_FLUSH : constant := 2;       --  zlib.h:127\n+                                       --  zlib.h:127\n+   Z_FULL_FLUSH : constant := 3;       --  zlib.h:128\n+                                       --  zlib.h:128\n+   Z_FINISH : constant := 4;        --  zlib.h:129\n+                                    --  zlib.h:129\n+   Z_OK : constant := 8#0000#;   --  zlib.h:132\n+                                 --  zlib.h:132\n+   Z_STREAM_END : constant := 1;       --  zlib.h:133\n+                                       --  zlib.h:133\n+   Z_NEED_DICT : constant := 2;        --  zlib.h:134\n+                                       --  zlib.h:134\n+   Z_ERRNO : constant := -1;        --  zlib.h:135\n+                                    --  zlib.h:135\n+   Z_STREAM_ERROR : constant := -2;       --  zlib.h:136\n+                                          --  zlib.h:136\n+   Z_DATA_ERROR : constant := -3;      --  zlib.h:137\n+                                       --  zlib.h:137\n+   Z_MEM_ERROR : constant := -4;       --  zlib.h:138\n+                                       --  zlib.h:138\n+   Z_BUF_ERROR : constant := -5;       --  zlib.h:139\n+                                       --  zlib.h:139\n+   Z_VERSION_ERROR : constant := -6;      --  zlib.h:140\n+                                          --  zlib.h:140\n+   Z_NO_COMPRESSION : constant := 8#0000#;   --  zlib.h:145\n+                                             --  zlib.h:145\n+   Z_BEST_SPEED : constant := 1;       --  zlib.h:146\n+                                       --  zlib.h:146\n+   Z_BEST_COMPRESSION : constant := 9;       --  zlib.h:147\n+                                             --  zlib.h:147\n+   Z_DEFAULT_COMPRESSION : constant := -1;      --  zlib.h:148\n+                                                --  zlib.h:148\n+   Z_FILTERED : constant := 1;      --  zlib.h:151\n+                                    --  zlib.h:151\n+   Z_HUFFMAN_ONLY : constant := 2;        --  zlib.h:152\n+                                          --  zlib.h:152\n+   Z_DEFAULT_STRATEGY : constant := 8#0000#; --  zlib.h:153\n+                                             --  zlib.h:153\n+   Z_BINARY : constant := 8#0000#;  --  zlib.h:156\n+                                    --  zlib.h:156\n+   Z_ASCII : constant := 1;      --  zlib.h:157\n+                                 --  zlib.h:157\n+   Z_UNKNOWN : constant := 2;       --  zlib.h:158\n+                                    --  zlib.h:158\n+   Z_DEFLATED : constant := 8;      --  zlib.h:161\n+                                    --  zlib.h:161\n+   Z_NULL : constant := 8#0000#; --  zlib.h:164\n+                                 --  for initializing zalloc, zfree, opaque\n+                                 --  zlib.h:164\n+   type gzFile is new Voidp;                  --  zlib.h:646\n+\n+   type Z_Stream is private;\n+\n+   type Z_Streamp is access all Z_Stream;     --  zlib.h:89\n+\n+   type alloc_func is access function\n+     (Opaque : Voidp;\n+      Items  : UInt;\n+      Size   : UInt)\n+      return Voidp; --  zlib.h:63\n+\n+   type free_func is access procedure (opaque : Voidp; address : Voidp);\n+\n+   function zlibVersion return Chars_Ptr;\n+\n+   function Deflate (strm : Z_Streamp; flush : Int) return Int;\n+\n+   function DeflateEnd (strm : Z_Streamp) return Int;\n+\n+   function Inflate (strm : Z_Streamp; flush : Int) return Int;\n+\n+   function InflateEnd (strm : Z_Streamp) return Int;\n+\n+   function deflateSetDictionary\n+     (strm       : Z_Streamp;\n+      dictionary : Byte_Access;\n+      dictLength : UInt)\n+      return       Int;\n+\n+   function deflateCopy (dest : Z_Streamp; source : Z_Streamp) return Int;\n+   --  zlib.h:478\n+\n+   function deflateReset (strm : Z_Streamp) return Int; -- zlib.h:495\n+\n+   function deflateParams\n+     (strm     : Z_Streamp;\n+      level    : Int;\n+      strategy : Int)\n+      return     Int;       -- zlib.h:506\n+\n+   function inflateSetDictionary\n+     (strm       : Z_Streamp;\n+      dictionary : Byte_Access;\n+      dictLength : UInt)\n+      return       Int; --  zlib.h:548\n+\n+   function inflateSync (strm : Z_Streamp) return Int;  --  zlib.h:565\n+\n+   function inflateReset (strm : Z_Streamp) return Int; --  zlib.h:580\n+\n+   function compress\n+     (dest      : Byte_Access;\n+      destLen   : ULong_Access;\n+      source    : Byte_Access;\n+      sourceLen : ULong)\n+      return      Int;           -- zlib.h:601\n+\n+   function compress2\n+     (dest      : Byte_Access;\n+      destLen   : ULong_Access;\n+      source    : Byte_Access;\n+      sourceLen : ULong;\n+      level     : Int)\n+      return      Int;          -- zlib.h:615\n+\n+   function uncompress\n+     (dest      : Byte_Access;\n+      destLen   : ULong_Access;\n+      source    : Byte_Access;\n+      sourceLen : ULong)\n+      return      Int;\n+\n+   function gzopen (path : Chars_Ptr; mode : Chars_Ptr) return gzFile;\n+\n+   function gzdopen (fd : Int; mode : Chars_Ptr) return gzFile;\n+\n+   function gzsetparams\n+     (file     : gzFile;\n+      level    : Int;\n+      strategy : Int)\n+      return     Int;\n+\n+   function gzread\n+     (file : gzFile;\n+      buf  : Voidp;\n+      len  : UInt)\n+      return Int;\n+\n+   function gzwrite\n+     (file : in gzFile;\n+      buf  : in Voidp;\n+      len  : in UInt)\n+      return Int;\n+\n+   function gzprintf (file : in gzFile; format : in Chars_Ptr) return Int;\n+\n+   function gzputs (file : in gzFile; s : in Chars_Ptr) return Int;\n+\n+   function gzgets\n+     (file : gzFile;\n+      buf  : Chars_Ptr;\n+      len  : Int)\n+      return Chars_Ptr;\n+\n+   function gzputc (file : gzFile; char : Int) return Int;\n+\n+   function gzgetc (file : gzFile) return Int;\n+\n+   function gzflush (file : gzFile; flush : Int) return Int;\n+\n+   function gzseek\n+     (file   : gzFile;\n+      offset : Int;\n+      whence : Int)\n+      return   Int;\n+\n+   function gzrewind (file : gzFile) return Int;\n+\n+   function gztell (file : gzFile) return Int;\n+\n+   function gzeof (file : gzFile) return Int;\n+\n+   function gzclose (file : gzFile) return Int;\n+\n+   function gzerror (file : gzFile; errnum : Int_Access) return Chars_Ptr;\n+\n+   function adler32\n+     (adler : ULong;\n+      buf   : Byte_Access;\n+      len   : UInt)\n+      return  ULong;\n+\n+   function crc32\n+     (crc  : ULong;\n+      buf  : Byte_Access;\n+      len  : UInt)\n+      return ULong;\n+\n+   function deflateInit\n+     (strm        : Z_Streamp;\n+      level       : Int;\n+      version     : Chars_Ptr;\n+      stream_size : Int)\n+      return        Int;\n+\n+   function Deflate_Init\n+     (strm  : in Z_Streamp;\n+      level : in Int := Z_DEFAULT_COMPRESSION)\n+      return  Int;\n+   pragma Inline (Deflate_Init);\n+\n+   function deflateInit2\n+     (strm        : Z_Streamp;\n+      level       : Int;\n+      method      : Int;\n+      windowBits  : Int;\n+      memLevel    : Int;\n+      strategy    : Int;\n+      version     : Chars_Ptr;\n+      stream_size : Int)\n+      return        Int;\n+\n+   function Deflate_Init\n+     (strm       : Z_Streamp;\n+      level      : Int;\n+      method     : Int;\n+      windowBits : Int;\n+      memLevel   : Int;\n+      strategy   : Int)\n+      return       Int;\n+   pragma Inline (Deflate_Init);\n+\n+   function inflateInit\n+     (strm        : Z_Streamp;\n+      version     : Chars_Ptr;\n+      stream_size : Int)\n+      return        Int;\n+\n+   function Inflate_Init (strm : Z_Streamp) return Int;\n+   pragma Inline (Inflate_Init);\n+\n+   function inflateInit2\n+     (strm        : in Z_Streamp;\n+      windowBits  : in Int;\n+      version     : in Chars_Ptr;\n+      stream_size : in Int)\n+      return      Int;\n+\n+   function inflateBackInit\n+     (strm        : in Z_Streamp;\n+      windowBits  : in Int;\n+      window      : in Byte_Access;\n+      version     : in Chars_Ptr;\n+      stream_size : in Int)\n+      return      Int;\n+   --  Size of window have to be 2**windowBits.\n+\n+   function Inflate_Init (strm : Z_Streamp; windowBits : Int) return Int;\n+   pragma Inline (Inflate_Init);\n+\n+   function zError (err : Int) return Chars_Ptr;\n+\n+   function inflateSyncPoint (z : Z_Streamp) return Int;\n+\n+   function get_crc_table return ULong_Access;\n+\n+   --  Interface to the available fields of the z_stream structure.\n+   --  The application must update next_in and avail_in when avail_in has\n+   --  dropped to zero. It must update next_out and avail_out when avail_out\n+   --  has dropped to zero. The application must initialize zalloc, zfree and\n+   --  opaque before calling the init function.\n+\n+   function Need_In (strm : in Z_Stream) return Boolean;\n+   --  return true when we do not need to setup Next_In and Avail_In fields.\n+   pragma Inline (Need_In);\n+\n+   function Need_Out (strm : in Z_Stream) return Boolean;\n+   --  return true when we do not need to setup Next_Out and Avail_Out field.\n+   pragma Inline (Need_Out);\n+\n+   procedure Set_In\n+     (Strm   : in out Z_Stream;\n+      Buffer : in Byte_Access;\n+      Size   : in UInt);\n+   pragma Inline (Set_In);\n+\n+   procedure Set_In\n+     (Strm   : in out Z_Stream;\n+      Buffer : in Voidp;\n+      Size   : in UInt);\n+   pragma Inline (Set_In);\n+\n+   procedure Set_Out\n+     (Strm   : in out Z_Stream;\n+      Buffer : in Byte_Access;\n+      Size   : in UInt);\n+   pragma Inline (Set_Out);\n+\n+   procedure Set_Out\n+     (Strm   : in out Z_Stream;\n+      Buffer : in Voidp;\n+      Size   : in UInt);\n+   pragma Inline (Set_Out);\n+\n+   procedure Set_Mem_Func\n+     (Strm   : in out Z_Stream;\n+      Opaque : in Voidp;\n+      Alloc  : in alloc_func;\n+      Free   : in free_func);\n+   pragma Inline (Set_Mem_Func);\n+\n+   function Last_Error_Message (Strm : in Z_Stream) return String;\n+   pragma Inline (Last_Error_Message);\n+\n+   function Avail_Out (Strm : in Z_Stream) return UInt;\n+   pragma Inline (Avail_Out);\n+\n+   function Avail_In (Strm : in Z_Stream) return UInt;\n+   pragma Inline (Avail_In);\n+\n+   function Total_In (Strm : in Z_Stream) return ULong;\n+   pragma Inline (Total_In);\n+\n+   function Total_Out (Strm : in Z_Stream) return ULong;\n+   pragma Inline (Total_Out);\n+\n+   function inflateCopy\n+     (dest   : in Z_Streamp;\n+      Source : in Z_Streamp)\n+      return Int;\n+\n+   function compressBound (Source_Len : in ULong) return ULong;\n+\n+   function deflateBound\n+     (Strm       : in Z_Streamp;\n+      Source_Len : in ULong)\n+      return     ULong;\n+\n+   function gzungetc (C : in Int; File : in  gzFile) return Int;\n+\n+   function zlibCompileFlags return ULong;\n+\n+   function deflatePrime\n+     (strm     : Z_Streamp;\n+      bits     : Int;\n+      value    : Int)\n+      return     Int;\n+\n+private\n+\n+   type Z_Stream is record            -- zlib.h:68\n+      Next_In   : Byte_Access;        -- next input byte\n+      Avail_In  : UInt       := 0;    -- number of bytes available at next_in\n+      Total_In  : ULong      := 0;    -- total nb of input bytes read so far\n+      Next_Out  : Byte_Access;        -- next output byte should be put there\n+      Avail_Out : UInt       := 0;    -- remaining free space at next_out\n+      Total_Out : ULong      := 0;    -- total nb of bytes output so far\n+      msg       : Chars_Ptr;          -- last error message, NULL if no error\n+      state     : Voidp;              -- not visible by applications\n+      zalloc    : alloc_func := null; -- used to allocate the internal state\n+      zfree     : free_func  := null; -- used to free the internal state\n+      opaque    : Voidp;              -- private data object passed to\n+                                      --  zalloc and zfree\n+      data_type : Int;                -- best guess about the data type:\n+                                      --  ascii or binary\n+      adler     : ULong;              -- adler32 value of the uncompressed\n+                                      --  data\n+      reserved  : ULong;              -- reserved for future use\n+   end record;\n+\n+   pragma Convention (C, Z_Stream);\n+\n+   pragma Import (C, zlibVersion, \"zlibVersion\");\n+   pragma Import (C, Deflate, \"deflate\");\n+   pragma Import (C, DeflateEnd, \"deflateEnd\");\n+   pragma Import (C, Inflate, \"inflate\");\n+   pragma Import (C, InflateEnd, \"inflateEnd\");\n+   pragma Import (C, deflateSetDictionary, \"deflateSetDictionary\");\n+   pragma Import (C, deflateCopy, \"deflateCopy\");\n+   pragma Import (C, deflateReset, \"deflateReset\");\n+   pragma Import (C, deflateParams, \"deflateParams\");\n+   pragma Import (C, inflateSetDictionary, \"inflateSetDictionary\");\n+   pragma Import (C, inflateSync, \"inflateSync\");\n+   pragma Import (C, inflateReset, \"inflateReset\");\n+   pragma Import (C, compress, \"compress\");\n+   pragma Import (C, compress2, \"compress2\");\n+   pragma Import (C, uncompress, \"uncompress\");\n+   pragma Import (C, gzopen, \"gzopen\");\n+   pragma Import (C, gzdopen, \"gzdopen\");\n+   pragma Import (C, gzsetparams, \"gzsetparams\");\n+   pragma Import (C, gzread, \"gzread\");\n+   pragma Import (C, gzwrite, \"gzwrite\");\n+   pragma Import (C, gzprintf, \"gzprintf\");\n+   pragma Import (C, gzputs, \"gzputs\");\n+   pragma Import (C, gzgets, \"gzgets\");\n+   pragma Import (C, gzputc, \"gzputc\");\n+   pragma Import (C, gzgetc, \"gzgetc\");\n+   pragma Import (C, gzflush, \"gzflush\");\n+   pragma Import (C, gzseek, \"gzseek\");\n+   pragma Import (C, gzrewind, \"gzrewind\");\n+   pragma Import (C, gztell, \"gztell\");\n+   pragma Import (C, gzeof, \"gzeof\");\n+   pragma Import (C, gzclose, \"gzclose\");\n+   pragma Import (C, gzerror, \"gzerror\");\n+   pragma Import (C, adler32, \"adler32\");\n+   pragma Import (C, crc32, \"crc32\");\n+   pragma Import (C, deflateInit, \"deflateInit_\");\n+   pragma Import (C, inflateInit, \"inflateInit_\");\n+   pragma Import (C, deflateInit2, \"deflateInit2_\");\n+   pragma Import (C, inflateInit2, \"inflateInit2_\");\n+   pragma Import (C, zError, \"zError\");\n+   pragma Import (C, inflateSyncPoint, \"inflateSyncPoint\");\n+   pragma Import (C, get_crc_table, \"get_crc_table\");\n+\n+   --  added in zlib 1.2.1:\n+\n+   pragma Import (C, inflateCopy, \"inflateCopy\");\n+   pragma Import (C, compressBound, \"compressBound\");\n+   pragma Import (C, deflateBound, \"deflateBound\");\n+   pragma Import (C, gzungetc, \"gzungetc\");\n+   pragma Import (C, zlibCompileFlags, \"zlibCompileFlags\");\n+   pragma Import (C, deflatePrime, \"deflatePrime\");\n+\n+   pragma Import (C, inflateBackInit, \"inflateBackInit_\");\n+\n+   --  I stopped binding the inflateBack routines, becouse realize that\n+   --  it does not support zlib and gzip headers for now, and have no\n+   --  symmetric deflateBack routines.\n+   --  ZLib-Ada is symmetric regarding deflate/inflate data transformation\n+   --  and has a similar generic callback interface for the\n+   --  deflate/inflate transformation based on the regular Deflate/Inflate\n+   --  routines.\n+\n+   --  pragma Import (C, inflateBack, \"inflateBack\");\n+   --  pragma Import (C, inflateBackEnd, \"inflateBackEnd\");\n+\n+end ZLib.Thin;"}, {"sha": "93bf8852f72a8108992510e60b0348ddccaa81bf", "filename": "zlib/contrib/ada/zlib.adb", "status": "added", "additions": 674, "deletions": 0, "changes": 674, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fzlib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fzlib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fzlib.adb?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,674 @@\n+----------------------------------------------------------------\n+--  ZLib for Ada thick binding.                               --\n+--                                                            --\n+--  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --\n+--                                                            --\n+--  Open source license information is in the zlib.ads file.  --\n+----------------------------------------------------------------\n+\n+--  $Id: zlib.adb,v 1.19 2003/07/13 16:02:19 vagul Exp $\n+\n+with Ada.Exceptions;\n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n+\n+with Interfaces.C.Strings;\n+\n+with ZLib.Thin;\n+\n+package body ZLib is\n+\n+   use type Thin.Int;\n+\n+   type Z_Stream is new Thin.Z_Stream;\n+\n+   type Return_Code_Enum is\n+      (OK,\n+       STREAM_END,\n+       NEED_DICT,\n+       ERRNO,\n+       STREAM_ERROR,\n+       DATA_ERROR,\n+       MEM_ERROR,\n+       BUF_ERROR,\n+       VERSION_ERROR);\n+\n+   type Flate_Step_Function is access\n+     function (Strm : Thin.Z_Streamp; flush : Thin.Int) return Thin.Int;\n+   pragma Convention (C, Flate_Step_Function);\n+\n+   type Flate_End_Function is access\n+      function (Ctrm : in Thin.Z_Streamp) return Thin.Int;\n+   pragma Convention (C, Flate_End_Function);\n+\n+   type Flate_Type is record\n+      Step : Flate_Step_Function;\n+      Done : Flate_End_Function;\n+   end record;\n+\n+   subtype Footer_Array is Stream_Element_Array (1 .. 8);\n+\n+   Simple_GZip_Header : constant Stream_Element_Array (1 .. 10)\n+     := (16#1f#, 16#8b#,                 --  Magic header\n+         16#08#,                         --  Z_DEFLATED\n+         16#00#,                         --  Flags\n+         16#00#, 16#00#, 16#00#, 16#00#, --  Time\n+         16#00#,                         --  XFlags\n+         16#03#                          --  OS code\n+        );\n+   --  The simplest gzip header is not for informational, but just for\n+   --  gzip format compatibility.\n+   --  Note that some code below is using assumption\n+   --  Simple_GZip_Header'Last > Footer_Array'Last, so do not make\n+   --  Simple_GZip_Header'Last <= Footer_Array'Last.\n+\n+   Return_Code : constant array (Thin.Int range <>) of Return_Code_Enum\n+     := (0 => OK,\n+         1 => STREAM_END,\n+         2 => NEED_DICT,\n+        -1 => ERRNO,\n+        -2 => STREAM_ERROR,\n+        -3 => DATA_ERROR,\n+        -4 => MEM_ERROR,\n+        -5 => BUF_ERROR,\n+        -6 => VERSION_ERROR);\n+\n+   Flate : constant array (Boolean) of Flate_Type\n+     := (True  => (Step => Thin.Deflate'Access,\n+                   Done => Thin.DeflateEnd'Access),\n+         False => (Step => Thin.Inflate'Access,\n+                   Done => Thin.InflateEnd'Access));\n+\n+   Flush_Finish : constant array (Boolean) of Flush_Mode\n+     := (True => Finish, False => No_Flush);\n+\n+   procedure Raise_Error (Stream : Z_Stream);\n+   pragma Inline (Raise_Error);\n+\n+   procedure Raise_Error (Message : String);\n+   pragma Inline (Raise_Error);\n+\n+   procedure Check_Error (Stream : Z_Stream; Code : Thin.Int);\n+\n+   procedure Free is new Ada.Unchecked_Deallocation\n+      (Z_Stream, Z_Stream_Access);\n+\n+   function To_Thin_Access is new Ada.Unchecked_Conversion\n+     (Z_Stream_Access, Thin.Z_Streamp);\n+\n+   procedure Translate_GZip\n+     (Filter    : in out Filter_Type;\n+      In_Data   : in     Ada.Streams.Stream_Element_Array;\n+      In_Last   :    out Ada.Streams.Stream_Element_Offset;\n+      Out_Data  :    out Ada.Streams.Stream_Element_Array;\n+      Out_Last  :    out Ada.Streams.Stream_Element_Offset;\n+      Flush     : in     Flush_Mode);\n+   --  Separate translate routine for make gzip header.\n+\n+   procedure Translate_Auto\n+     (Filter    : in out Filter_Type;\n+      In_Data   : in     Ada.Streams.Stream_Element_Array;\n+      In_Last   :    out Ada.Streams.Stream_Element_Offset;\n+      Out_Data  :    out Ada.Streams.Stream_Element_Array;\n+      Out_Last  :    out Ada.Streams.Stream_Element_Offset;\n+      Flush     : in     Flush_Mode);\n+   --  translate routine without additional headers.\n+\n+   -----------------\n+   -- Check_Error --\n+   -----------------\n+\n+   procedure Check_Error (Stream : Z_Stream; Code : Thin.Int) is\n+      use type Thin.Int;\n+   begin\n+      if Code /= Thin.Z_OK then\n+         Raise_Error\n+            (Return_Code_Enum'Image (Return_Code (Code))\n+              & \": \" & Last_Error_Message (Stream));\n+      end if;\n+   end Check_Error;\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close\n+     (Filter       : in out Filter_Type;\n+      Ignore_Error : in     Boolean := False)\n+   is\n+      Code : Thin.Int;\n+   begin\n+      Code := Flate (Filter.Compression).Done\n+          (To_Thin_Access (Filter.Strm));\n+\n+      Filter.Opened := False;\n+\n+      if Ignore_Error or else Code = Thin.Z_OK then\n+         Free (Filter.Strm);\n+      else\n+         declare\n+            Error_Message : constant String\n+              := Last_Error_Message (Filter.Strm.all);\n+         begin\n+            Free (Filter.Strm);\n+            Ada.Exceptions.Raise_Exception\n+               (ZLib_Error'Identity,\n+                Return_Code_Enum'Image (Return_Code (Code))\n+                & \": \" & Error_Message);\n+         end;\n+      end if;\n+   end Close;\n+\n+   -----------\n+   -- CRC32 --\n+   -----------\n+\n+   function CRC32\n+     (CRC  : in Unsigned_32;\n+      Data : in Ada.Streams.Stream_Element_Array)\n+      return Unsigned_32\n+   is\n+      use Thin;\n+   begin\n+      return Unsigned_32 (crc32\n+        (ULong (CRC),\n+         Bytes.To_Pointer (Data'Address),\n+         Data'Length));\n+   end CRC32;\n+\n+   procedure CRC32\n+     (CRC  : in out Unsigned_32;\n+      Data : in     Ada.Streams.Stream_Element_Array) is\n+   begin\n+      CRC := CRC32 (CRC, Data);\n+   end CRC32;\n+\n+   ------------------\n+   -- Deflate_Init --\n+   ------------------\n+\n+   procedure Deflate_Init\n+     (Filter       : in out Filter_Type;\n+      Level        : in     Compression_Level  := Default_Compression;\n+      Strategy     : in     Strategy_Type      := Default_Strategy;\n+      Method       : in     Compression_Method := Deflated;\n+      Window_Bits  : in     Window_Bits_Type   := 15;\n+      Memory_Level : in     Memory_Level_Type  := 8;\n+      Header       : in     Header_Type        := Default)\n+   is\n+      use type Thin.Int;\n+      Win_Bits : Thin.Int := Thin.Int (Window_Bits);\n+   begin\n+      --  We allow ZLib to make header only in case of default header type.\n+      --  Otherwise we would either do header by ourselfs, or do not do\n+      --  header at all.\n+\n+      if Header = None or else Header = GZip then\n+         Win_Bits := -Win_Bits;\n+      end if;\n+\n+      --  For the GZip CRC calculation and make headers.\n+\n+      if Header = GZip then\n+         Filter.CRC    := 0;\n+         Filter.Offset := Simple_GZip_Header'First;\n+      else\n+         Filter.Offset := Simple_GZip_Header'Last + 1;\n+      end if;\n+\n+      Filter.Strm := new Z_Stream;\n+      Filter.Compression := True;\n+      Filter.Stream_End  := False;\n+      Filter.Opened      := True;\n+      Filter.Header      := Header;\n+\n+      if Thin.Deflate_Init\n+           (To_Thin_Access (Filter.Strm),\n+            Level      => Thin.Int (Level),\n+            method     => Thin.Int (Method),\n+            windowBits => Win_Bits,\n+            memLevel   => Thin.Int (Memory_Level),\n+            strategy   => Thin.Int (Strategy)) /= Thin.Z_OK\n+      then\n+         Raise_Error (Filter.Strm.all);\n+      end if;\n+   end Deflate_Init;\n+\n+   -----------\n+   -- Flush --\n+   -----------\n+\n+   procedure Flush\n+     (Filter    : in out Filter_Type;\n+      Out_Data  :    out Ada.Streams.Stream_Element_Array;\n+      Out_Last  :    out Ada.Streams.Stream_Element_Offset;\n+      Flush     : in     Flush_Mode)\n+   is\n+      No_Data : Stream_Element_Array := (1 .. 0 => 0);\n+      Last    : Stream_Element_Offset;\n+   begin\n+      Translate (Filter, No_Data, Last, Out_Data, Out_Last, Flush);\n+   end Flush;\n+\n+   -----------------------\n+   -- Generic_Translate --\n+   -----------------------\n+\n+   procedure Generic_Translate\n+     (Filter : in out ZLib.Filter_Type;\n+      In_Buffer_Size  : Integer := Default_Buffer_Size;\n+      Out_Buffer_Size : Integer := Default_Buffer_Size)\n+   is\n+      In_Buffer : Stream_Element_Array\n+         (1 .. Stream_Element_Offset (In_Buffer_Size));\n+      Out_Buffer : Stream_Element_Array\n+        (1 .. Stream_Element_Offset (Out_Buffer_Size));\n+      Last : Stream_Element_Offset;\n+      In_Last : Stream_Element_Offset;\n+      In_First : Stream_Element_Offset;\n+      Out_Last : Stream_Element_Offset;\n+   begin\n+      Main : loop\n+         Data_In (In_Buffer, Last);\n+\n+         In_First := In_Buffer'First;\n+\n+         loop\n+            Translate\n+              (Filter,\n+               In_Buffer (In_First .. Last),\n+               In_Last,\n+               Out_Buffer,\n+               Out_Last,\n+               Flush_Finish (Last < In_Buffer'First));\n+\n+            Data_Out (Out_Buffer (Out_Buffer'First .. Out_Last));\n+\n+            exit Main when Stream_End (Filter);\n+\n+            --  The end of in buffer.\n+            exit when In_Last = Last;\n+\n+            In_First := In_Last + 1;\n+         end loop;\n+      end loop Main;\n+\n+   end Generic_Translate;\n+\n+   ------------------\n+   -- Inflate_Init --\n+   ------------------\n+\n+   procedure Inflate_Init\n+     (Filter      : in out Filter_Type;\n+      Window_Bits : in     Window_Bits_Type := 15;\n+      Header      : in     Header_Type      := Default)\n+   is\n+      use type Thin.Int;\n+      Win_Bits : Thin.Int := Thin.Int (Window_Bits);\n+\n+      procedure Check_Version;\n+      --  Check the latest header types compatibility.\n+\n+      procedure Check_Version is\n+      begin\n+         if Version <= \"1.1.4\" then\n+            Raise_Error\n+              (\"Inflate header type \" & Header_Type'Image (Header)\n+               & \" incompatible with ZLib version \" & Version);\n+         end if;\n+      end Check_Version;\n+\n+   begin\n+      case Header is\n+         when None =>\n+            Check_Version;\n+\n+            --  Inflate data without headers determined\n+            --  by negative Win_Bits.\n+\n+            Win_Bits := -Win_Bits;\n+         when GZip =>\n+            Check_Version;\n+\n+            --  Inflate gzip data defined by flag 16.\n+\n+            Win_Bits := Win_Bits + 16;\n+         when Auto =>\n+            Check_Version;\n+\n+            --  Inflate with automatic detection\n+            --  of gzip or native header defined by flag 32.\n+\n+            Win_Bits := Win_Bits + 32;\n+         when Default => null;\n+      end case;\n+\n+      Filter.Strm := new Z_Stream;\n+      Filter.Compression := False;\n+      Filter.Stream_End  := False;\n+      Filter.Opened      := True;\n+      Filter.Header      := Header;\n+\n+      if Thin.Inflate_Init\n+         (To_Thin_Access (Filter.Strm), Win_Bits) /= Thin.Z_OK\n+      then\n+         Raise_Error (Filter.Strm.all);\n+      end if;\n+   end Inflate_Init;\n+\n+   -----------------\n+   -- Raise_Error --\n+   -----------------\n+\n+   procedure Raise_Error (Message : String) is\n+   begin\n+      Ada.Exceptions.Raise_Exception (ZLib_Error'Identity, Message);\n+   end Raise_Error;\n+\n+   procedure Raise_Error (Stream : Z_Stream) is\n+   begin\n+      Raise_Error (Last_Error_Message (Stream));\n+   end Raise_Error;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Filter : in out Filter_Type;\n+      Item   :    out Ada.Streams.Stream_Element_Array;\n+      Last   :    out Ada.Streams.Stream_Element_Offset)\n+   is\n+      In_Last    : Stream_Element_Offset;\n+      Item_First : Ada.Streams.Stream_Element_Offset := Item'First;\n+\n+   begin\n+      pragma Assert (Rest_First in Buffer'First .. Buffer'Last + 1);\n+\n+      loop\n+         if Rest_First > Buffer'Last then\n+            Read (Buffer, Rest_Last);\n+            Rest_First := Buffer'First;\n+         end if;\n+\n+         pragma Assert (Rest_Last in Buffer'First - 1 .. Buffer'Last);\n+\n+         Translate\n+           (Filter   => Filter,\n+            In_Data  => Buffer (Rest_First .. Rest_Last),\n+            In_Last  => In_Last,\n+            Out_Data => Item (Item_First .. Item'Last),\n+            Out_Last => Last,\n+            Flush    => Flush_Finish (Rest_Last < Rest_First));\n+\n+         Rest_First := In_Last + 1;\n+\n+         exit when Last = Item'Last or else Stream_End (Filter);\n+\n+         Item_First := Last + 1;\n+      end loop;\n+   end Read;\n+\n+   ----------------\n+   -- Stream_End --\n+   ----------------\n+\n+   function Stream_End (Filter : in Filter_Type) return Boolean is\n+   begin\n+      if Filter.Header = GZip and Filter.Compression then\n+         return Filter.Stream_End\n+            and then Filter.Offset = Footer_Array'Last + 1;\n+      else\n+         return Filter.Stream_End;\n+      end if;\n+   end Stream_End;\n+\n+   --------------\n+   -- Total_In --\n+   --------------\n+\n+   function Total_In (Filter : in Filter_Type) return Count is\n+   begin\n+      return Count (Thin.Total_In (To_Thin_Access (Filter.Strm).all));\n+   end Total_In;\n+\n+   ---------------\n+   -- Total_Out --\n+   ---------------\n+\n+   function Total_Out (Filter : in Filter_Type) return Count is\n+   begin\n+      return Count (Thin.Total_Out (To_Thin_Access (Filter.Strm).all));\n+   end Total_Out;\n+\n+   ---------------\n+   -- Translate --\n+   ---------------\n+\n+   procedure Translate\n+     (Filter    : in out Filter_Type;\n+      In_Data   : in     Ada.Streams.Stream_Element_Array;\n+      In_Last   :    out Ada.Streams.Stream_Element_Offset;\n+      Out_Data  :    out Ada.Streams.Stream_Element_Array;\n+      Out_Last  :    out Ada.Streams.Stream_Element_Offset;\n+      Flush     : in     Flush_Mode) is\n+   begin\n+      if Filter.Header = GZip and then Filter.Compression then\n+         Translate_GZip\n+           (Filter   => Filter,\n+            In_Data  => In_Data,\n+            In_Last  => In_Last,\n+            Out_Data => Out_Data,\n+            Out_Last => Out_Last,\n+            Flush    => Flush);\n+      else\n+         Translate_Auto\n+           (Filter   => Filter,\n+            In_Data  => In_Data,\n+            In_Last  => In_Last,\n+            Out_Data => Out_Data,\n+            Out_Last => Out_Last,\n+            Flush    => Flush);\n+      end if;\n+   end Translate;\n+\n+   --------------------\n+   -- Translate_Auto --\n+   --------------------\n+\n+   procedure Translate_Auto\n+     (Filter    : in out Filter_Type;\n+      In_Data   : in     Ada.Streams.Stream_Element_Array;\n+      In_Last   :    out Ada.Streams.Stream_Element_Offset;\n+      Out_Data  :    out Ada.Streams.Stream_Element_Array;\n+      Out_Last  :    out Ada.Streams.Stream_Element_Offset;\n+      Flush     : in     Flush_Mode)\n+   is\n+      use type Thin.Int;\n+      Code : Thin.Int;\n+\n+   begin\n+      if Filter.Opened = False then\n+         raise ZLib_Error;\n+      end if;\n+\n+      if Out_Data'Length = 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Set_Out (Filter.Strm.all, Out_Data'Address, Out_Data'Length);\n+      Set_In  (Filter.Strm.all, In_Data'Address, In_Data'Length);\n+\n+      Code := Flate (Filter.Compression).Step\n+        (To_Thin_Access (Filter.Strm),\n+         Thin.Int (Flush));\n+\n+      if Code = Thin.Z_STREAM_END then\n+         Filter.Stream_End := True;\n+      else\n+         Check_Error (Filter.Strm.all, Code);\n+      end if;\n+\n+      In_Last  := In_Data'Last\n+         - Stream_Element_Offset (Avail_In (Filter.Strm.all));\n+      Out_Last := Out_Data'Last\n+         - Stream_Element_Offset (Avail_Out (Filter.Strm.all));\n+\n+   end Translate_Auto;\n+\n+   --------------------\n+   -- Translate_GZip --\n+   --------------------\n+\n+   procedure Translate_GZip\n+     (Filter    : in out Filter_Type;\n+      In_Data   : in     Ada.Streams.Stream_Element_Array;\n+      In_Last   :    out Ada.Streams.Stream_Element_Offset;\n+      Out_Data  :    out Ada.Streams.Stream_Element_Array;\n+      Out_Last  :    out Ada.Streams.Stream_Element_Offset;\n+      Flush     : in     Flush_Mode)\n+   is\n+      Out_First  : Stream_Element_Offset;\n+\n+      procedure Add_Data (Data : in Stream_Element_Array);\n+      --  Add data to stream from the Filter.Offset till necessary,\n+      --  used for add gzip headr/footer.\n+\n+      procedure Put_32\n+        (Item : in out Stream_Element_Array;\n+         Data : in     Unsigned_32);\n+      pragma Inline (Put_32);\n+\n+      --------------\n+      -- Add_Data --\n+      --------------\n+\n+      procedure Add_Data (Data : in Stream_Element_Array) is\n+         Data_First : Stream_Element_Offset renames Filter.Offset;\n+         Data_Last  : Stream_Element_Offset;\n+         Data_Len   : Stream_Element_Offset; --  -1\n+         Out_Len    : Stream_Element_Offset; --  -1\n+      begin\n+         Out_First := Out_Last + 1;\n+\n+         if Data_First > Data'Last then\n+            return;\n+         end if;\n+\n+         Data_Len  := Data'Last     - Data_First;\n+         Out_Len   := Out_Data'Last - Out_First;\n+\n+         if Data_Len <= Out_Len then\n+            Out_Last  := Out_First  + Data_Len;\n+            Data_Last := Data'Last;\n+         else\n+            Out_Last  := Out_Data'Last;\n+            Data_Last := Data_First + Out_Len;\n+         end if;\n+\n+         Out_Data (Out_First .. Out_Last) := Data (Data_First .. Data_Last);\n+\n+         Data_First := Data_Last + 1;\n+         Out_First  := Out_Last + 1;\n+      end Add_Data;\n+\n+      ------------\n+      -- Put_32 --\n+      ------------\n+\n+      procedure Put_32\n+        (Item : in out Stream_Element_Array;\n+         Data : in     Unsigned_32)\n+      is\n+         D : Unsigned_32 := Data;\n+      begin\n+         for J in Item'First .. Item'First + 3 loop\n+            Item (J) := Stream_Element (D and 16#FF#);\n+            D := Shift_Right (D, 8);\n+         end loop;\n+      end Put_32;\n+\n+   begin\n+      Out_Last := Out_Data'First - 1;\n+\n+      if not Filter.Stream_End then\n+         Add_Data (Simple_GZip_Header);\n+\n+         Translate_Auto\n+           (Filter => Filter,\n+            In_Data  => In_Data,\n+            In_Last  => In_Last,\n+            Out_Data => Out_Data (Out_First .. Out_Data'Last),\n+            Out_Last => Out_Last,\n+            Flush    => Flush);\n+\n+         CRC32 (Filter.CRC, In_Data (In_Data'First .. In_Last));\n+\n+      end if;\n+\n+      if Filter.Stream_End and then Out_Last <= Out_Data'Last then\n+         --  This detection method would work only when\n+         --  Simple_GZip_Header'Last > Footer_Array'Last\n+\n+         if Filter.Offset = Simple_GZip_Header'Last + 1 then\n+            Filter.Offset := Footer_Array'First;\n+         end if;\n+\n+         declare\n+            Footer : Footer_Array;\n+         begin\n+            Put_32 (Footer, Filter.CRC);\n+            Put_32 (Footer (Footer'First + 4 .. Footer'Last),\n+                    Unsigned_32 (Total_In (Filter)));\n+            Add_Data (Footer);\n+         end;\n+      end if;\n+   end Translate_GZip;\n+\n+   -------------\n+   -- Version --\n+   -------------\n+\n+   function Version return String is\n+   begin\n+      return Interfaces.C.Strings.Value (Thin.zlibVersion);\n+   end Version;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Filter : in out Filter_Type;\n+      Item   : in     Ada.Streams.Stream_Element_Array;\n+      Flush  : in     Flush_Mode)\n+   is\n+      Buffer : Stream_Element_Array (1 .. Buffer_Size);\n+      In_Last, Out_Last : Stream_Element_Offset;\n+      In_First : Stream_Element_Offset := Item'First;\n+   begin\n+      if Item'Length = 0 and Flush = No_Flush then\n+         return;\n+      end if;\n+\n+      loop\n+         Translate\n+           (Filter => Filter,\n+            In_Data  => Item (In_First .. Item'Last),\n+            In_Last  => In_Last,\n+            Out_Data => Buffer,\n+            Out_Last => Out_Last,\n+            Flush    => Flush);\n+\n+         if Out_Last >= Buffer'First then\n+            Write (Buffer (1 .. Out_Last));\n+         end if;\n+\n+         exit when In_Last = Item'Last or Stream_End (Filter);\n+\n+         In_First := In_Last + 1;\n+      end loop;\n+   end Write;\n+\n+end ZLib;"}, {"sha": "b72e4d2d5d708f45d92482b6af666bb6bf1c16c9", "filename": "zlib/contrib/ada/zlib.ads", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fzlib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fzlib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fzlib.ads?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,311 @@\n+------------------------------------------------------------------------------\n+--                      ZLib for Ada thick binding.                         --\n+--                                                                          --\n+--              Copyright (C) 2002-2003 Dmitriy Anisimkov                   --\n+--                                                                          --\n+--  This library is free software; you can redistribute it and/or modify    --\n+--  it under the terms of the GNU General Public License as published by    --\n+--  the Free Software Foundation; either version 2 of the License, or (at   --\n+--  your option) any later version.                                         --\n+--                                                                          --\n+--  This library is distributed in the hope that it will be useful, but     --\n+--  WITHOUT ANY WARRANTY; without even the implied warranty of              --\n+--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       --\n+--  General Public License for more details.                                --\n+--                                                                          --\n+--  You should have received a copy of the GNU General Public License       --\n+--  along with this library; if not, write to the Free Software Foundation, --\n+--  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.          --\n+--                                                                          --\n+--  As a special exception, if other files instantiate generics from this   --\n+--  unit, or you link this unit with other files to produce an executable,  --\n+--  this  unit  does not  by itself cause  the resulting executable to be   --\n+--  covered by the GNU General Public License. This exception does not      --\n+--  however invalidate any other reasons why the executable file  might be  --\n+--  covered by the  GNU Public License.                                     --\n+------------------------------------------------------------------------------\n+\n+--  $Id: zlib.ads,v 1.17 2003/08/12 13:19:07 vagul Exp $\n+\n+with Ada.Streams;\n+\n+with Interfaces;\n+\n+package ZLib is\n+\n+   ZLib_Error : exception;\n+\n+   type Compression_Level is new Integer range -1 .. 9;\n+\n+   type Flush_Mode is private;\n+\n+   type Compression_Method is private;\n+\n+   type Window_Bits_Type is new Integer range 8 .. 15;\n+\n+   type Memory_Level_Type is new Integer range 1 .. 9;\n+\n+   type Unsigned_32 is new Interfaces.Unsigned_32;\n+\n+   type Strategy_Type is private;\n+\n+   type Header_Type is (None, Auto, Default, GZip);\n+   --  Header type usage have a some limitation for inflate.\n+   --  See comment for Inflate_Init.\n+\n+   subtype Count is Ada.Streams.Stream_Element_Count;\n+\n+   ----------------------------------\n+   -- Compression method constants --\n+   ----------------------------------\n+\n+   Deflated : constant Compression_Method;\n+   --  Only one method allowed in this ZLib version.\n+\n+   ---------------------------------\n+   -- Compression level constants --\n+   ---------------------------------\n+\n+   No_Compression      : constant Compression_Level := 0;\n+   Best_Speed          : constant Compression_Level := 1;\n+   Best_Compression    : constant Compression_Level := 9;\n+   Default_Compression : constant Compression_Level := -1;\n+\n+   --------------------------\n+   -- Flush mode constants --\n+   --------------------------\n+\n+   No_Flush      : constant Flush_Mode;\n+   --  Regular way for compression, no flush\n+\n+   Partial_Flush : constant Flush_Mode;\n+   --  will be removed, use Z_SYNC_FLUSH instead\n+\n+   Sync_Flush    : constant Flush_Mode;\n+   --  all pending output is flushed to the output buffer and the output\n+   --  is aligned on a byte boundary, so that the decompressor can get all\n+   --  input data available so far. (In particular avail_in is zero after the\n+   --  call if enough output space has been provided  before the call.)\n+   --  Flushing may degrade compression for some compression algorithms and so\n+   --  it should be used only when necessary.\n+\n+   Full_Flush    : constant Flush_Mode;\n+   --  all output is flushed as with SYNC_FLUSH, and the compression state\n+   --  is reset so that decompression can restart from this point if previous\n+   --  compressed data has been damaged or if random access is desired. Using\n+   --  FULL_FLUSH too often can seriously degrade the compression.\n+\n+   Finish        : constant Flush_Mode;\n+   --  Just for tell the compressor that input data is complete.\n+\n+   ------------------------------------\n+   -- Compression strategy constants --\n+   ------------------------------------\n+\n+   --  RLE stategy could be used only in version 1.2.0 and later.\n+\n+   Filtered         : constant Strategy_Type;\n+   Huffman_Only     : constant Strategy_Type;\n+   RLE              : constant Strategy_Type;\n+   Default_Strategy : constant Strategy_Type;\n+\n+   Default_Buffer_Size : constant := 4096;\n+\n+   type Filter_Type is limited private;\n+   --  The filter is for compression and for decompression.\n+   --  The usage of the type is depend of its initialization.\n+\n+   function Version return String;\n+   pragma Inline (Version);\n+   --  Return string representation of the ZLib version.\n+\n+   procedure Deflate_Init\n+     (Filter       : in out Filter_Type;\n+      Level        : in     Compression_Level  := Default_Compression;\n+      Strategy     : in     Strategy_Type      := Default_Strategy;\n+      Method       : in     Compression_Method := Deflated;\n+      Window_Bits  : in     Window_Bits_Type   := 15;\n+      Memory_Level : in     Memory_Level_Type  := 8;\n+      Header       : in     Header_Type        := Default);\n+   --  Compressor initialization.\n+   --  When Header parameter is Auto or Default, then default zlib header\n+   --  would be provided for compressed data.\n+   --  When Header is GZip, then gzip header would be set instead of\n+   --  default header.\n+   --  When Header is None, no header would be set for compressed data.\n+\n+   procedure Inflate_Init\n+     (Filter      : in out Filter_Type;\n+      Window_Bits : in     Window_Bits_Type := 15;\n+      Header      : in     Header_Type      := Default);\n+   --  Decompressor initialization.\n+   --  Default header type mean that ZLib default header is expecting in the\n+   --  input compressed stream.\n+   --  Header type None mean that no header is expecting in the input stream.\n+   --  GZip header type mean that GZip header is expecting in the\n+   --  input compressed stream.\n+   --  Auto header type mean that header type (GZip or Native) would be\n+   --  detected automatically in the input stream.\n+   --  Note that header types parameter values None, GZip and Auto is\n+   --  supporting for inflate routine only in ZLib versions 1.2.0.2 and later.\n+   --  Deflate_Init is supporting all header types.\n+\n+   procedure Close\n+     (Filter       : in out Filter_Type;\n+      Ignore_Error : in     Boolean := False);\n+   --  Closing the compression or decompressor.\n+   --  If stream is closing before the complete and Ignore_Error is False,\n+   --  The exception would be raised.\n+\n+   generic\n+      with procedure Data_In\n+        (Item : out Ada.Streams.Stream_Element_Array;\n+         Last : out Ada.Streams.Stream_Element_Offset);\n+      with procedure Data_Out\n+        (Item : in Ada.Streams.Stream_Element_Array);\n+   procedure Generic_Translate\n+     (Filter          : in out Filter_Type;\n+      In_Buffer_Size  : in     Integer := Default_Buffer_Size;\n+      Out_Buffer_Size : in     Integer := Default_Buffer_Size);\n+   --  Compressing/decompressing data arrived from Data_In routine\n+   --  to the Data_Out routine. User should provide Data_In and Data_Out\n+   --  for compression/decompression data flow.\n+   --  Compression or decompression depend on initialization of Filter.\n+\n+   function Total_In (Filter : in Filter_Type) return Count;\n+   pragma Inline (Total_In);\n+   --  Return total number of input bytes read so far.\n+\n+   function Total_Out (Filter : in Filter_Type) return Count;\n+   pragma Inline (Total_Out);\n+   --  Return total number of bytes output so far.\n+\n+   function CRC32\n+     (CRC    : in Unsigned_32;\n+      Data   : in Ada.Streams.Stream_Element_Array)\n+      return Unsigned_32;\n+   pragma Inline (CRC32);\n+   --  Calculate CRC32, it could be necessary for make gzip format.\n+\n+   procedure CRC32\n+     (CRC  : in out Unsigned_32;\n+      Data : in     Ada.Streams.Stream_Element_Array);\n+   pragma Inline (CRC32);\n+   --  Calculate CRC32, it could be necessary for make gzip format.\n+\n+   -------------------------------------------------\n+   --  Below is more complex low level routines.  --\n+   -------------------------------------------------\n+\n+   procedure Translate\n+     (Filter    : in out Filter_Type;\n+      In_Data   : in     Ada.Streams.Stream_Element_Array;\n+      In_Last   :    out Ada.Streams.Stream_Element_Offset;\n+      Out_Data  :    out Ada.Streams.Stream_Element_Array;\n+      Out_Last  :    out Ada.Streams.Stream_Element_Offset;\n+      Flush     : in     Flush_Mode);\n+   --  Compressing/decompressing the datas from In_Data buffer to the\n+   --  Out_Data buffer.\n+   --  In_Data is incoming data portion,\n+   --  In_Last is the index of last element from In_Data accepted by the\n+   --  Filter.\n+   --  Out_Data is the buffer for output data from the filter.\n+   --  Out_Last is the last element of the received data from Filter.\n+   --  To tell the filter that incoming data is complete put the\n+   --  Flush parameter to FINISH.\n+\n+   function Stream_End (Filter : in Filter_Type) return Boolean;\n+   pragma Inline (Stream_End);\n+   --  Return the true when the stream is complete.\n+\n+   procedure Flush\n+     (Filter    : in out Filter_Type;\n+      Out_Data  :    out Ada.Streams.Stream_Element_Array;\n+      Out_Last  :    out Ada.Streams.Stream_Element_Offset;\n+      Flush     : in     Flush_Mode);\n+   pragma Inline (Flush);\n+   --  Flushing the data from the compressor.\n+\n+   generic\n+      with procedure Write\n+        (Item : in Ada.Streams.Stream_Element_Array);\n+      --  User should provide this routine for accept\n+      --  compressed/decompressed data.\n+\n+      Buffer_Size : in Ada.Streams.Stream_Element_Offset\n+         := Default_Buffer_Size;\n+      --  Buffer size for Write user routine.\n+\n+   procedure Write\n+     (Filter  : in out Filter_Type;\n+      Item    : in     Ada.Streams.Stream_Element_Array;\n+      Flush   : in     Flush_Mode);\n+   --  Compressing/Decompressing data from Item to the\n+   --  generic parameter procedure Write.\n+   --  Output buffer size could be set in Buffer_Size generic parameter.\n+\n+   generic\n+      with procedure Read\n+        (Item : out Ada.Streams.Stream_Element_Array;\n+         Last : out Ada.Streams.Stream_Element_Offset);\n+      --  User should provide data for compression/decompression\n+      --  thru this routine.\n+\n+      Buffer : in out Ada.Streams.Stream_Element_Array;\n+      --  Buffer for keep remaining data from the previous\n+      --  back read.\n+\n+      Rest_First, Rest_Last : in out Ada.Streams.Stream_Element_Offset;\n+      --  Rest_First have to be initialized to Buffer'Last + 1\n+      --  before usage.\n+\n+   procedure Read\n+     (Filter : in out Filter_Type;\n+      Item   :    out Ada.Streams.Stream_Element_Array;\n+      Last   :    out Ada.Streams.Stream_Element_Offset);\n+   --  Compressing/Decompressing data from generic parameter\n+   --  procedure Read to the Item.\n+   --  User should provide Buffer for the operation\n+   --  and Rest_First variable first time initialized to the Buffer'Last + 1.\n+\n+private\n+\n+   use Ada.Streams;\n+\n+   type Flush_Mode is new Integer range 0 .. 4;\n+\n+   type Compression_Method is new Integer range 8 .. 8;\n+\n+   type Strategy_Type is new Integer range 0 .. 3;\n+\n+   No_Flush      : constant Flush_Mode := 0;\n+   Sync_Flush    : constant Flush_Mode := 2;\n+   Full_Flush    : constant Flush_Mode := 3;\n+   Finish        : constant Flush_Mode := 4;\n+   Partial_Flush : constant Flush_Mode := 1;\n+   --  will be removed, use Z_SYNC_FLUSH instead\n+\n+   Filtered         : constant Strategy_Type := 1;\n+   Huffman_Only     : constant Strategy_Type := 2;\n+   RLE              : constant Strategy_Type := 3;\n+   Default_Strategy : constant Strategy_Type := 0;\n+\n+   Deflated : constant Compression_Method := 8;\n+\n+   type Z_Stream;\n+\n+   type Z_Stream_Access is access all Z_Stream;\n+\n+   type Filter_Type is record\n+      Strm        : Z_Stream_Access;\n+      Compression : Boolean;\n+      Stream_End  : Boolean;\n+      Header      : Header_Type;\n+      CRC         : Unsigned_32;\n+      Offset      : Stream_Element_Offset;\n+      --  Offset for gzip header/footer output.\n+\n+      Opened      : Boolean := False;\n+   end record;\n+\n+end ZLib;"}, {"sha": "0f58985e30bf6ed03db3dc5178ef45884ab5f606", "filename": "zlib/contrib/ada/zlib.gpr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fzlib.gpr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fada%2Fzlib.gpr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fzlib.gpr?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,21 @@\n+project Zlib is\n+\n+   for Languages use (\"Ada\");\n+   for Source_Dirs use (\".\");\n+   for Object_Dir use \".\";\n+   for Main use (\"test.adb\", \"mtest.adb\", \"read.adb\");\n+\n+   package Compiler is\n+      for Default_Switches (\"ada\") use (\"-gnatwbcfilopru\", \"-gnatVcdfimorst\", \"-gnatyabcefhiklmnoprst\");\n+   end Compiler;\n+\n+   package Linker is\n+      for Default_Switches (\"ada\") use (\"-lz\");\n+   end Linker;\n+\n+   package Builder is\n+      for Default_Switches (\"ada\") use (\"-s\", \"-gnatQ\");\n+   end Builder;\n+\n+end Zlib;\n+"}, {"sha": "9be80bafe050eed57029ef2e690f36677a3003c0", "filename": "zlib/contrib/blast/Makefile", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fblast%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fblast%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fblast%2FMakefile?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,8 @@\n+blast: blast.c blast.h\n+\tcc -DTEST -o blast blast.c\n+\n+test: blast\n+\tblast < test.pk | cmp - test.txt\n+\n+clean:\n+\trm -f blast blast.o"}, {"sha": "e3a60b3f5cce7b307a1453f4e37eb634d4bc9b8d", "filename": "zlib/contrib/blast/README", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fblast%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fblast%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fblast%2FREADME?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,4 @@\n+Read blast.h for purpose and usage.\n+\n+Mark Adler\n+madler@alumni.caltech.edu"}, {"sha": "4ce697a41fb70f2806e4e14e0a6b643281c7d08d", "filename": "zlib/contrib/blast/blast.c", "status": "added", "additions": 444, "deletions": 0, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fblast%2Fblast.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fblast%2Fblast.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fblast%2Fblast.c?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,444 @@\n+/* blast.c\n+ * Copyright (C) 2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in blast.h\n+ * version 1.1, 16 Feb 2003\n+ *\n+ * blast.c decompresses data compressed by the PKWare Compression Library.\n+ * This function provides functionality similar to the explode() function of\n+ * the PKWare library, hence the name \"blast\".\n+ *\n+ * This decompressor is based on the excellent format description provided by\n+ * Ben Rudiak-Gould in comp.compression on August 13, 2001.  Interestingly, the\n+ * example Ben provided in the post is incorrect.  The distance 110001 should\n+ * instead be 111000.  When corrected, the example byte stream becomes:\n+ *\n+ *    00 04 82 24 25 8f 80 7f\n+ *\n+ * which decompresses to \"AIAIAIAIAIAIA\" (without the quotes).\n+ */\n+\n+/*\n+ * Change history:\n+ *\n+ * 1.0  12 Feb 2003     - First version\n+ * 1.1  16 Feb 2003     - Fixed distance check for > 4 GB uncompressed data\n+ */\n+\n+#include <setjmp.h>             /* for setjmp(), longjmp(), and jmp_buf */\n+#include \"blast.h\"              /* prototype for blast() */\n+\n+#define local static            /* for local function definitions */\n+#define MAXBITS 13              /* maximum code length */\n+#define MAXWIN 4096             /* maximum window size */\n+\n+/* input and output state */\n+struct state {\n+    /* input state */\n+    blast_in infun;             /* input function provided by user */\n+    void *inhow;                /* opaque information passed to infun() */\n+    unsigned char *in;          /* next input location */\n+    unsigned left;              /* available input at in */\n+    int bitbuf;                 /* bit buffer */\n+    int bitcnt;                 /* number of bits in bit buffer */\n+\n+    /* input limit error return state for bits() and decode() */\n+    jmp_buf env;\n+\n+    /* output state */\n+    blast_out outfun;           /* output function provided by user */\n+    void *outhow;               /* opaque information passed to outfun() */\n+    unsigned next;              /* index of next write location in out[] */\n+    int first;                  /* true to check distances (for first 4K) */\n+    unsigned char out[MAXWIN];  /* output buffer and sliding window */\n+};\n+\n+/*\n+ * Return need bits from the input stream.  This always leaves less than\n+ * eight bits in the buffer.  bits() works properly for need == 0.\n+ *\n+ * Format notes:\n+ *\n+ * - Bits are stored in bytes from the least significant bit to the most\n+ *   significant bit.  Therefore bits are dropped from the bottom of the bit\n+ *   buffer, using shift right, and new bytes are appended to the top of the\n+ *   bit buffer, using shift left.\n+ */\n+local int bits(struct state *s, int need)\n+{\n+    int val;            /* bit accumulator */\n+\n+    /* load at least need bits into val */\n+    val = s->bitbuf;\n+    while (s->bitcnt < need) {\n+        if (s->left == 0) {\n+            s->left = s->infun(s->inhow, &(s->in));\n+            if (s->left == 0) longjmp(s->env, 1);       /* out of input */\n+        }\n+        val |= (int)(*(s->in)++) << s->bitcnt;          /* load eight bits */\n+        s->left--;\n+        s->bitcnt += 8;\n+    }\n+\n+    /* drop need bits and update buffer, always zero to seven bits left */\n+    s->bitbuf = val >> need;\n+    s->bitcnt -= need;\n+\n+    /* return need bits, zeroing the bits above that */\n+    return val & ((1 << need) - 1);\n+}\n+\n+/*\n+ * Huffman code decoding tables.  count[1..MAXBITS] is the number of symbols of\n+ * each length, which for a canonical code are stepped through in order.\n+ * symbol[] are the symbol values in canonical order, where the number of\n+ * entries is the sum of the counts in count[].  The decoding process can be\n+ * seen in the function decode() below.\n+ */\n+struct huffman {\n+    short *count;       /* number of symbols of each length */\n+    short *symbol;      /* canonically ordered symbols */\n+};\n+\n+/*\n+ * Decode a code from the stream s using huffman table h.  Return the symbol or\n+ * a negative value if there is an error.  If all of the lengths are zero, i.e.\n+ * an empty code, or if the code is incomplete and an invalid code is received,\n+ * then -9 is returned after reading MAXBITS bits.\n+ *\n+ * Format notes:\n+ *\n+ * - The codes as stored in the compressed data are bit-reversed relative to\n+ *   a simple integer ordering of codes of the same lengths.  Hence below the\n+ *   bits are pulled from the compressed data one at a time and used to\n+ *   build the code value reversed from what is in the stream in order to\n+ *   permit simple integer comparisons for decoding.\n+ *\n+ * - The first code for the shortest length is all ones.  Subsequent codes of\n+ *   the same length are simply integer decrements of the previous code.  When\n+ *   moving up a length, a one bit is appended to the code.  For a complete\n+ *   code, the last code of the longest length will be all zeros.  To support\n+ *   this ordering, the bits pulled during decoding are inverted to apply the\n+ *   more \"natural\" ordering starting with all zeros and incrementing.\n+ */\n+local int decode(struct state *s, struct huffman *h)\n+{\n+    int len;            /* current number of bits in code */\n+    int code;           /* len bits being decoded */\n+    int first;          /* first code of length len */\n+    int count;          /* number of codes of length len */\n+    int index;          /* index of first code of length len in symbol table */\n+    int bitbuf;         /* bits from stream */\n+    int left;           /* bits left in next or left to process */\n+    short *next;        /* next number of codes */\n+\n+    bitbuf = s->bitbuf;\n+    left = s->bitcnt;\n+    code = first = index = 0;\n+    len = 1;\n+    next = h->count + 1;\n+    while (1) {\n+        while (left--) {\n+            code |= (bitbuf & 1) ^ 1;   /* invert code */\n+            bitbuf >>= 1;\n+            count = *next++;\n+            if (code < first + count) { /* if length len, return symbol */\n+                s->bitbuf = bitbuf;\n+                s->bitcnt = (s->bitcnt - len) & 7;\n+                return h->symbol[index + (code - first)];\n+            }\n+            index += count;             /* else update for next length */\n+            first += count;\n+            first <<= 1;\n+            code <<= 1;\n+            len++;\n+        }\n+        left = (MAXBITS+1) - len;\n+        if (left == 0) break;\n+        if (s->left == 0) {\n+            s->left = s->infun(s->inhow, &(s->in));\n+            if (s->left == 0) longjmp(s->env, 1);       /* out of input */\n+        }\n+        bitbuf = *(s->in)++;\n+        s->left--;\n+        if (left > 8) left = 8;\n+    }\n+    return -9;                          /* ran out of codes */\n+}\n+\n+/*\n+ * Given a list of repeated code lengths rep[0..n-1], where each byte is a\n+ * count (high four bits + 1) and a code length (low four bits), generate the\n+ * list of code lengths.  This compaction reduces the size of the object code.\n+ * Then given the list of code lengths length[0..n-1] representing a canonical\n+ * Huffman code for n symbols, construct the tables required to decode those\n+ * codes.  Those tables are the number of codes of each length, and the symbols\n+ * sorted by length, retaining their original order within each length.  The\n+ * return value is zero for a complete code set, negative for an over-\n+ * subscribed code set, and positive for an incomplete code set.  The tables\n+ * can be used if the return value is zero or positive, but they cannot be used\n+ * if the return value is negative.  If the return value is zero, it is not\n+ * possible for decode() using that table to return an error--any stream of\n+ * enough bits will resolve to a symbol.  If the return value is positive, then\n+ * it is possible for decode() using that table to return an error for received\n+ * codes past the end of the incomplete lengths.\n+ */\n+local int construct(struct huffman *h, const unsigned char *rep, int n)\n+{\n+    int symbol;         /* current symbol when stepping through length[] */\n+    int len;            /* current length when stepping through h->count[] */\n+    int left;           /* number of possible codes left of current length */\n+    short offs[MAXBITS+1];      /* offsets in symbol table for each length */\n+    short length[256];  /* code lengths */\n+\n+    /* convert compact repeat counts into symbol bit length list */\n+    symbol = 0;\n+    do {\n+        len = *rep++;\n+        left = (len >> 4) + 1;\n+        len &= 15;\n+        do {\n+            length[symbol++] = len;\n+        } while (--left);\n+    } while (--n);\n+    n = symbol;\n+\n+    /* count number of codes of each length */\n+    for (len = 0; len <= MAXBITS; len++)\n+        h->count[len] = 0;\n+    for (symbol = 0; symbol < n; symbol++)\n+        (h->count[length[symbol]])++;   /* assumes lengths are within bounds */\n+    if (h->count[0] == n)               /* no codes! */\n+        return 0;                       /* complete, but decode() will fail */\n+\n+    /* check for an over-subscribed or incomplete set of lengths */\n+    left = 1;                           /* one possible code of zero length */\n+    for (len = 1; len <= MAXBITS; len++) {\n+        left <<= 1;                     /* one more bit, double codes left */\n+        left -= h->count[len];          /* deduct count from possible codes */\n+        if (left < 0) return left;      /* over-subscribed--return negative */\n+    }                                   /* left > 0 means incomplete */\n+\n+    /* generate offsets into symbol table for each length for sorting */\n+    offs[1] = 0;\n+    for (len = 1; len < MAXBITS; len++)\n+        offs[len + 1] = offs[len] + h->count[len];\n+\n+    /*\n+     * put symbols in table sorted by length, by symbol order within each\n+     * length\n+     */\n+    for (symbol = 0; symbol < n; symbol++)\n+        if (length[symbol] != 0)\n+            h->symbol[offs[length[symbol]]++] = symbol;\n+\n+    /* return zero for complete set, positive for incomplete set */\n+    return left;\n+}\n+\n+/*\n+ * Decode PKWare Compression Library stream.\n+ *\n+ * Format notes:\n+ *\n+ * - First byte is 0 if literals are uncoded or 1 if they are coded.  Second\n+ *   byte is 4, 5, or 6 for the number of extra bits in the distance code.\n+ *   This is the base-2 logarithm of the dictionary size minus six.\n+ *\n+ * - Compressed data is a combination of literals and length/distance pairs\n+ *   terminated by an end code.  Literals are either Huffman coded or\n+ *   uncoded bytes.  A length/distance pair is a coded length followed by a\n+ *   coded distance to represent a string that occurs earlier in the\n+ *   uncompressed data that occurs again at the current location.\n+ *\n+ * - A bit preceding a literal or length/distance pair indicates which comes\n+ *   next, 0 for literals, 1 for length/distance.\n+ *\n+ * - If literals are uncoded, then the next eight bits are the literal, in the\n+ *   normal bit order in th stream, i.e. no bit-reversal is needed. Similarly,\n+ *   no bit reversal is needed for either the length extra bits or the distance\n+ *   extra bits.\n+ *\n+ * - Literal bytes are simply written to the output.  A length/distance pair is\n+ *   an instruction to copy previously uncompressed bytes to the output.  The\n+ *   copy is from distance bytes back in the output stream, copying for length\n+ *   bytes.\n+ *\n+ * - Distances pointing before the beginning of the output data are not\n+ *   permitted.\n+ *\n+ * - Overlapped copies, where the length is greater than the distance, are\n+ *   allowed and common.  For example, a distance of one and a length of 518\n+ *   simply copies the last byte 518 times.  A distance of four and a length of\n+ *   twelve copies the last four bytes three times.  A simple forward copy\n+ *   ignoring whether the length is greater than the distance or not implements\n+ *   this correctly.\n+ */\n+local int decomp(struct state *s)\n+{\n+    int lit;            /* true if literals are coded */\n+    int dict;           /* log2(dictionary size) - 6 */\n+    int symbol;         /* decoded symbol, extra bits for distance */\n+    int len;            /* length for copy */\n+    int dist;           /* distance for copy */\n+    int copy;           /* copy counter */\n+    unsigned char *from, *to;   /* copy pointers */\n+    static int virgin = 1;                              /* build tables once */\n+    static short litcnt[MAXBITS+1], litsym[256];        /* litcode memory */\n+    static short lencnt[MAXBITS+1], lensym[16];         /* lencode memory */\n+    static short distcnt[MAXBITS+1], distsym[64];       /* distcode memory */\n+    static struct huffman litcode = {litcnt, litsym};   /* length code */\n+    static struct huffman lencode = {lencnt, lensym};   /* length code */\n+    static struct huffman distcode = {distcnt, distsym};/* distance code */\n+        /* bit lengths of literal codes */\n+    static const unsigned char litlen[] = {\n+        11, 124, 8, 7, 28, 7, 188, 13, 76, 4, 10, 8, 12, 10, 12, 10, 8, 23, 8,\n+        9, 7, 6, 7, 8, 7, 6, 55, 8, 23, 24, 12, 11, 7, 9, 11, 12, 6, 7, 22, 5,\n+        7, 24, 6, 11, 9, 6, 7, 22, 7, 11, 38, 7, 9, 8, 25, 11, 8, 11, 9, 12,\n+        8, 12, 5, 38, 5, 38, 5, 11, 7, 5, 6, 21, 6, 10, 53, 8, 7, 24, 10, 27,\n+        44, 253, 253, 253, 252, 252, 252, 13, 12, 45, 12, 45, 12, 61, 12, 45,\n+        44, 173};\n+        /* bit lengths of length codes 0..15 */\n+    static const unsigned char lenlen[] = {2, 35, 36, 53, 38, 23};\n+        /* bit lengths of distance codes 0..63 */\n+    static const unsigned char distlen[] = {2, 20, 53, 230, 247, 151, 248};\n+    static const short base[16] = {     /* base for length codes */\n+        3, 2, 4, 5, 6, 7, 8, 9, 10, 12, 16, 24, 40, 72, 136, 264};\n+    static const char extra[16] = {     /* extra bits for length codes */\n+        0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8};\n+\n+    /* set up decoding tables (once--might not be thread-safe) */\n+    if (virgin) {\n+        construct(&litcode, litlen, sizeof(litlen));\n+        construct(&lencode, lenlen, sizeof(lenlen));\n+        construct(&distcode, distlen, sizeof(distlen));\n+        virgin = 0;\n+    }\n+\n+    /* read header */\n+    lit = bits(s, 8);\n+    if (lit > 1) return -1;\n+    dict = bits(s, 8);\n+    if (dict < 4 || dict > 6) return -2;\n+\n+    /* decode literals and length/distance pairs */\n+    do {\n+        if (bits(s, 1)) {\n+            /* get length */\n+            symbol = decode(s, &lencode);\n+            len = base[symbol] + bits(s, extra[symbol]);\n+            if (len == 519) break;              /* end code */\n+\n+            /* get distance */\n+            symbol = len == 2 ? 2 : dict;\n+            dist = decode(s, &distcode) << symbol;\n+            dist += bits(s, symbol);\n+            dist++;\n+            if (s->first && dist > s->next)\n+                return -3;              /* distance too far back */\n+\n+            /* copy length bytes from distance bytes back */\n+            do {\n+                to = s->out + s->next;\n+                from = to - dist;\n+                copy = MAXWIN;\n+                if (s->next < dist) {\n+                    from += copy;\n+                    copy = dist;\n+                }\n+                copy -= s->next;\n+                if (copy > len) copy = len;\n+                len -= copy;\n+                s->next += copy;\n+                do {\n+                    *to++ = *from++;\n+                } while (--copy);\n+                if (s->next == MAXWIN) {\n+                    if (s->outfun(s->outhow, s->out, s->next)) return 1;\n+                    s->next = 0;\n+                    s->first = 0;\n+                }\n+            } while (len != 0);\n+        }\n+        else {\n+            /* get literal and write it */\n+            symbol = lit ? decode(s, &litcode) : bits(s, 8);\n+            s->out[s->next++] = symbol;\n+            if (s->next == MAXWIN) {\n+                if (s->outfun(s->outhow, s->out, s->next)) return 1;\n+                s->next = 0;\n+                s->first = 0;\n+            }\n+        }\n+    } while (1);\n+    return 0;\n+}\n+\n+/* See comments in blast.h */\n+int blast(blast_in infun, void *inhow, blast_out outfun, void *outhow)\n+{\n+    struct state s;             /* input/output state */\n+    int err;                    /* return value */\n+\n+    /* initialize input state */\n+    s.infun = infun;\n+    s.inhow = inhow;\n+    s.left = 0;\n+    s.bitbuf = 0;\n+    s.bitcnt = 0;\n+\n+    /* initialize output state */\n+    s.outfun = outfun;\n+    s.outhow = outhow;\n+    s.next = 0;\n+    s.first = 1;\n+\n+    /* return if bits() or decode() tries to read past available input */\n+    if (setjmp(s.env) != 0)             /* if came back here via longjmp(), */\n+        err = 2;                        /*  then skip decomp(), return error */\n+    else\n+        err = decomp(&s);               /* decompress */\n+\n+    /* write any leftover output and update the error code if needed */\n+    if (err != 1 && s.next && s.outfun(s.outhow, s.out, s.next) && err == 0)\n+        err = 1;\n+    return err;\n+}\n+\n+#ifdef TEST\n+/* Example of how to use blast() */\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#define CHUNK 16384\n+\n+local unsigned inf(void *how, unsigned char **buf)\n+{\n+    static unsigned char hold[CHUNK];\n+\n+    *buf = hold;\n+    return fread(hold, 1, CHUNK, (FILE *)how);\n+}\n+\n+local int outf(void *how, unsigned char *buf, unsigned len)\n+{\n+    return fwrite(buf, 1, len, (FILE *)how) != len;\n+}\n+\n+/* Decompress a PKWare Compression Library stream from stdin to stdout */\n+int main(void)\n+{\n+    int ret, n;\n+\n+    /* decompress to stdout */\n+    ret = blast(inf, stdin, outf, stdout);\n+    if (ret != 0) fprintf(stderr, \"blast error: %d\\n\", ret);\n+\n+    /* see if there are any leftover bytes */\n+    n = 0;\n+    while (getchar() != EOF) n++;\n+    if (n) fprintf(stderr, \"blast warning: %d unused bytes of input\\n\", n);\n+\n+    /* return blast() error code */\n+    return ret;\n+}\n+#endif"}, {"sha": "ce9e5410f4912981767989863b9a09921bf7c03a", "filename": "zlib/contrib/blast/blast.h", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fblast%2Fblast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fblast%2Fblast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fblast%2Fblast.h?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,71 @@\n+/* blast.h -- interface for blast.c\n+  Copyright (C) 2003 Mark Adler\n+  version 1.1, 16 Feb 2003\n+\n+  This software is provided 'as-is', without any express or implied\n+  warranty.  In no event will the author be held liable for any damages\n+  arising from the use of this software.\n+\n+  Permission is granted to anyone to use this software for any purpose,\n+  including commercial applications, and to alter it and redistribute it\n+  freely, subject to the following restrictions:\n+\n+  1. The origin of this software must not be misrepresented; you must not\n+     claim that you wrote the original software. If you use this software\n+     in a product, an acknowledgment in the product documentation would be\n+     appreciated but is not required.\n+  2. Altered source versions must be plainly marked as such, and must not be\n+     misrepresented as being the original software.\n+  3. This notice may not be removed or altered from any source distribution.\n+\n+  Mark Adler    madler@alumni.caltech.edu\n+ */\n+\n+\n+/*\n+ * blast() decompresses the PKWare Data Compression Library (DCL) compressed\n+ * format.  It provides the same functionality as the explode() function in\n+ * that library.  (Note: PKWare overused the \"implode\" verb, and the format\n+ * used by their library implode() function is completely different and\n+ * incompatible with the implode compression method supported by PKZIP.)\n+ */\n+\n+\n+typedef unsigned (*blast_in)(void *how, unsigned char **buf);\n+typedef int (*blast_out)(void *how, unsigned char *buf, unsigned len);\n+/* Definitions for input/output functions passed to blast().  See below for\n+ * what the provided functions need to do.\n+ */\n+\n+\n+int blast(blast_in infun, void *inhow, blast_out outfun, void *outhow);\n+/* Decompress input to output using the provided infun() and outfun() calls.\n+ * On success, the return value of blast() is zero.  If there is an error in\n+ * the source data, i.e. it is not in the proper format, then a negative value\n+ * is returned.  If there is not enough input available or there is not enough\n+ * output space, then a positive error is returned.\n+ *\n+ * The input function is invoked: len = infun(how, &buf), where buf is set by\n+ * infun() to point to the input buffer, and infun() returns the number of\n+ * available bytes there.  If infun() returns zero, then blast() returns with\n+ * an input error.  (blast() only asks for input if it needs it.)  inhow is for\n+ * use by the application to pass an input descriptor to infun(), if desired.\n+ *\n+ * The output function is invoked: err = outfun(how, buf, len), where the bytes\n+ * to be written are buf[0..len-1].  If err is not zero, then blast() returns\n+ * with an output error.  outfun() is always called with len <= 4096.  outhow\n+ * is for use by the application to pass an output descriptor to outfun(), if\n+ * desired.\n+ *\n+ * The return codes are:\n+ *\n+ *   2:  ran out of input before completing decompression\n+ *   1:  output error before completing decompression\n+ *   0:  successful decompression\n+ *  -1:  literal flag not zero or one\n+ *  -2:  dictionary size not in 4..6\n+ *  -3:  distance is too far back\n+ *\n+ * At the bottom of blast.c is an example program that uses blast() that can be\n+ * compiled to produce a command-line decompression filter by defining TEST.\n+ */"}, {"sha": "be10b2bbb251759ffdf6da49fadd1a3f137a54c1", "filename": "zlib/contrib/blast/test.pk", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fblast%2Ftest.pk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fblast%2Ftest.pk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fblast%2Ftest.pk?ref=176ba83391a86ff69a205fafabc4782e6a067605"}, {"sha": "bfdf1c5dca0a66123a3afbf01f509a7b3667b4bb", "filename": "zlib/contrib/blast/test.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fblast%2Ftest.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fblast%2Ftest.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fblast%2Ftest.txt?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1 @@\n+AIAIAIAIAIAIA\n\\ No newline at end of file"}, {"sha": "61ffd08fd1a9f7d48368cdaf8be0a078e6786bb1", "filename": "zlib/contrib/delphi/ZLib.pas", "status": "added", "additions": 557, "deletions": 0, "changes": 557, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fdelphi%2FZLib.pas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fdelphi%2FZLib.pas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi%2FZLib.pas?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,557 @@\n+{*******************************************************}\n+{                                                       }\n+{       Borland Delphi Supplemental Components          }\n+{       ZLIB Data Compression Interface Unit            }\n+{                                                       }\n+{       Copyright (c) 1997,99 Borland Corporation       }\n+{                                                       }\n+{*******************************************************}\n+\n+{ Updated for zlib 1.2.x by Cosmin Truta <cosmint@cs.ubbcluj.ro> }\n+\n+unit ZLib;\n+\n+interface\n+\n+uses SysUtils, Classes;\n+\n+type\n+  TAlloc = function (AppData: Pointer; Items, Size: Integer): Pointer; cdecl;\n+  TFree = procedure (AppData, Block: Pointer); cdecl;\n+\n+  // Internal structure.  Ignore.\n+  TZStreamRec = packed record\n+    next_in: PChar;       // next input byte\n+    avail_in: Integer;    // number of bytes available at next_in\n+    total_in: Longint;    // total nb of input bytes read so far\n+\n+    next_out: PChar;      // next output byte should be put here\n+    avail_out: Integer;   // remaining free space at next_out\n+    total_out: Longint;   // total nb of bytes output so far\n+\n+    msg: PChar;           // last error message, NULL if no error\n+    internal: Pointer;    // not visible by applications\n+\n+    zalloc: TAlloc;       // used to allocate the internal state\n+    zfree: TFree;         // used to free the internal state\n+    AppData: Pointer;     // private data object passed to zalloc and zfree\n+\n+    data_type: Integer;   // best guess about the data type: ascii or binary\n+    adler: Longint;       // adler32 value of the uncompressed data\n+    reserved: Longint;    // reserved for future use\n+  end;\n+\n+  // Abstract ancestor class\n+  TCustomZlibStream = class(TStream)\n+  private\n+    FStrm: TStream;\n+    FStrmPos: Integer;\n+    FOnProgress: TNotifyEvent;\n+    FZRec: TZStreamRec;\n+    FBuffer: array [Word] of Char;\n+  protected\n+    procedure Progress(Sender: TObject); dynamic;\n+    property OnProgress: TNotifyEvent read FOnProgress write FOnProgress;\n+    constructor Create(Strm: TStream);\n+  end;\n+\n+{ TCompressionStream compresses data on the fly as data is written to it, and\n+  stores the compressed data to another stream.\n+\n+  TCompressionStream is write-only and strictly sequential. Reading from the\n+  stream will raise an exception. Using Seek to move the stream pointer\n+  will raise an exception.\n+\n+  Output data is cached internally, written to the output stream only when\n+  the internal output buffer is full.  All pending output data is flushed\n+  when the stream is destroyed.\n+\n+  The Position property returns the number of uncompressed bytes of\n+  data that have been written to the stream so far.\n+\n+  CompressionRate returns the on-the-fly percentage by which the original\n+  data has been compressed:  (1 - (CompressedBytes / UncompressedBytes)) * 100\n+  If raw data size = 100 and compressed data size = 25, the CompressionRate\n+  is 75%\n+\n+  The OnProgress event is called each time the output buffer is filled and\n+  written to the output stream.  This is useful for updating a progress\n+  indicator when you are writing a large chunk of data to the compression\n+  stream in a single call.}\n+\n+\n+  TCompressionLevel = (clNone, clFastest, clDefault, clMax);\n+\n+  TCompressionStream = class(TCustomZlibStream)\n+  private\n+    function GetCompressionRate: Single;\n+  public\n+    constructor Create(CompressionLevel: TCompressionLevel; Dest: TStream);\n+    destructor Destroy; override;\n+    function Read(var Buffer; Count: Longint): Longint; override;\n+    function Write(const Buffer; Count: Longint): Longint; override;\n+    function Seek(Offset: Longint; Origin: Word): Longint; override;\n+    property CompressionRate: Single read GetCompressionRate;\n+    property OnProgress;\n+  end;\n+\n+{ TDecompressionStream decompresses data on the fly as data is read from it.\n+\n+  Compressed data comes from a separate source stream.  TDecompressionStream\n+  is read-only and unidirectional; you can seek forward in the stream, but not\n+  backwards.  The special case of setting the stream position to zero is\n+  allowed.  Seeking forward decompresses data until the requested position in\n+  the uncompressed data has been reached.  Seeking backwards, seeking relative\n+  to the end of the stream, requesting the size of the stream, and writing to\n+  the stream will raise an exception.\n+\n+  The Position property returns the number of bytes of uncompressed data that\n+  have been read from the stream so far.\n+\n+  The OnProgress event is called each time the internal input buffer of\n+  compressed data is exhausted and the next block is read from the input stream.\n+  This is useful for updating a progress indicator when you are reading a\n+  large chunk of data from the decompression stream in a single call.}\n+\n+  TDecompressionStream = class(TCustomZlibStream)\n+  public\n+    constructor Create(Source: TStream);\n+    destructor Destroy; override;\n+    function Read(var Buffer; Count: Longint): Longint; override;\n+    function Write(const Buffer; Count: Longint): Longint; override;\n+    function Seek(Offset: Longint; Origin: Word): Longint; override;\n+    property OnProgress;\n+  end;\n+\n+\n+\n+{ CompressBuf compresses data, buffer to buffer, in one call.\n+   In: InBuf = ptr to compressed data\n+       InBytes = number of bytes in InBuf\n+  Out: OutBuf = ptr to newly allocated buffer containing decompressed data\n+       OutBytes = number of bytes in OutBuf   }\n+procedure CompressBuf(const InBuf: Pointer; InBytes: Integer;\n+                      out OutBuf: Pointer; out OutBytes: Integer);\n+\n+\n+{ DecompressBuf decompresses data, buffer to buffer, in one call.\n+   In: InBuf = ptr to compressed data\n+       InBytes = number of bytes in InBuf\n+       OutEstimate = zero, or est. size of the decompressed data\n+  Out: OutBuf = ptr to newly allocated buffer containing decompressed data\n+       OutBytes = number of bytes in OutBuf   }\n+procedure DecompressBuf(const InBuf: Pointer; InBytes: Integer;\n+ OutEstimate: Integer; out OutBuf: Pointer; out OutBytes: Integer);\n+\n+{ DecompressToUserBuf decompresses data, buffer to buffer, in one call.\n+   In: InBuf = ptr to compressed data\n+       InBytes = number of bytes in InBuf\n+  Out: OutBuf = ptr to user-allocated buffer to contain decompressed data\n+       BufSize = number of bytes in OutBuf   }\n+procedure DecompressToUserBuf(const InBuf: Pointer; InBytes: Integer;\n+  const OutBuf: Pointer; BufSize: Integer);\n+\n+const\n+  zlib_version = '1.2.1';\n+\n+type\n+  EZlibError = class(Exception);\n+  ECompressionError = class(EZlibError);\n+  EDecompressionError = class(EZlibError);\n+\n+implementation\n+\n+uses ZLibConst;\n+\n+const\n+  Z_NO_FLUSH      = 0;\n+  Z_PARTIAL_FLUSH = 1;\n+  Z_SYNC_FLUSH    = 2;\n+  Z_FULL_FLUSH    = 3;\n+  Z_FINISH        = 4;\n+\n+  Z_OK            = 0;\n+  Z_STREAM_END    = 1;\n+  Z_NEED_DICT     = 2;\n+  Z_ERRNO         = (-1);\n+  Z_STREAM_ERROR  = (-2);\n+  Z_DATA_ERROR    = (-3);\n+  Z_MEM_ERROR     = (-4);\n+  Z_BUF_ERROR     = (-5);\n+  Z_VERSION_ERROR = (-6);\n+\n+  Z_NO_COMPRESSION       =   0;\n+  Z_BEST_SPEED           =   1;\n+  Z_BEST_COMPRESSION     =   9;\n+  Z_DEFAULT_COMPRESSION  = (-1);\n+\n+  Z_FILTERED            = 1;\n+  Z_HUFFMAN_ONLY        = 2;\n+  Z_RLE                 = 3;\n+  Z_DEFAULT_STRATEGY    = 0;\n+\n+  Z_BINARY   = 0;\n+  Z_ASCII    = 1;\n+  Z_UNKNOWN  = 2;\n+\n+  Z_DEFLATED = 8;\n+\n+\n+{$L adler32.obj}\n+{$L compress.obj}\n+{$L crc32.obj}\n+{$L deflate.obj}\n+{$L infback.obj}\n+{$L inffast.obj}\n+{$L inflate.obj}\n+{$L inftrees.obj}\n+{$L trees.obj}\n+{$L uncompr.obj}\n+{$L zutil.obj}\n+\n+procedure adler32; external;\n+procedure compressBound; external;\n+procedure crc32; external;\n+procedure deflateInit2_; external;\n+procedure deflateParams; external;\n+\n+function _malloc(Size: Integer): Pointer; cdecl;\n+begin\n+  Result := AllocMem(Size);\n+end;\n+\n+procedure _free(Block: Pointer); cdecl;\n+begin\n+  FreeMem(Block);\n+end;\n+\n+procedure _memset(P: Pointer; B: Byte; count: Integer); cdecl;\n+begin\n+  FillChar(P^, count, B);\n+end;\n+\n+procedure _memcpy(dest, source: Pointer; count: Integer); cdecl;\n+begin\n+  Move(source^, dest^, count);\n+end;\n+\n+\n+\n+// deflate compresses data\n+function deflateInit_(var strm: TZStreamRec; level: Integer; version: PChar;\n+  recsize: Integer): Integer; external;\n+function deflate(var strm: TZStreamRec; flush: Integer): Integer; external;\n+function deflateEnd(var strm: TZStreamRec): Integer; external;\n+\n+// inflate decompresses data\n+function inflateInit_(var strm: TZStreamRec; version: PChar;\n+  recsize: Integer): Integer; external;\n+function inflate(var strm: TZStreamRec; flush: Integer): Integer; external;\n+function inflateEnd(var strm: TZStreamRec): Integer; external;\n+function inflateReset(var strm: TZStreamRec): Integer; external;\n+\n+\n+function zlibAllocMem(AppData: Pointer; Items, Size: Integer): Pointer; cdecl;\n+begin\n+//  GetMem(Result, Items*Size);\n+  Result := AllocMem(Items * Size);\n+end;\n+\n+procedure zlibFreeMem(AppData, Block: Pointer); cdecl;\n+begin\n+  FreeMem(Block);\n+end;\n+\n+{function zlibCheck(code: Integer): Integer;\n+begin\n+  Result := code;\n+  if code < 0 then\n+    raise EZlibError.Create('error');    //!!\n+end;}\n+\n+function CCheck(code: Integer): Integer;\n+begin\n+  Result := code;\n+  if code < 0 then\n+    raise ECompressionError.Create('error'); //!!\n+end;\n+\n+function DCheck(code: Integer): Integer;\n+begin\n+  Result := code;\n+  if code < 0 then\n+    raise EDecompressionError.Create('error');  //!!\n+end;\n+\n+procedure CompressBuf(const InBuf: Pointer; InBytes: Integer;\n+                      out OutBuf: Pointer; out OutBytes: Integer);\n+var\n+  strm: TZStreamRec;\n+  P: Pointer;\n+begin\n+  FillChar(strm, sizeof(strm), 0);\n+  strm.zalloc := zlibAllocMem;\n+  strm.zfree := zlibFreeMem;\n+  OutBytes := ((InBytes + (InBytes div 10) + 12) + 255) and not 255;\n+  GetMem(OutBuf, OutBytes);\n+  try\n+    strm.next_in := InBuf;\n+    strm.avail_in := InBytes;\n+    strm.next_out := OutBuf;\n+    strm.avail_out := OutBytes;\n+    CCheck(deflateInit_(strm, Z_BEST_COMPRESSION, zlib_version, sizeof(strm)));\n+    try\n+      while CCheck(deflate(strm, Z_FINISH)) <> Z_STREAM_END do\n+      begin\n+        P := OutBuf;\n+        Inc(OutBytes, 256);\n+        ReallocMem(OutBuf, OutBytes);\n+        strm.next_out := PChar(Integer(OutBuf) + (Integer(strm.next_out) - Integer(P)));\n+        strm.avail_out := 256;\n+      end;\n+    finally\n+      CCheck(deflateEnd(strm));\n+    end;\n+    ReallocMem(OutBuf, strm.total_out);\n+    OutBytes := strm.total_out;\n+  except\n+    FreeMem(OutBuf);\n+    raise\n+  end;\n+end;\n+\n+\n+procedure DecompressBuf(const InBuf: Pointer; InBytes: Integer;\n+  OutEstimate: Integer; out OutBuf: Pointer; out OutBytes: Integer);\n+var\n+  strm: TZStreamRec;\n+  P: Pointer;\n+  BufInc: Integer;\n+begin\n+  FillChar(strm, sizeof(strm), 0);\n+  strm.zalloc := zlibAllocMem;\n+  strm.zfree := zlibFreeMem;\n+  BufInc := (InBytes + 255) and not 255;\n+  if OutEstimate = 0 then\n+    OutBytes := BufInc\n+  else\n+    OutBytes := OutEstimate;\n+  GetMem(OutBuf, OutBytes);\n+  try\n+    strm.next_in := InBuf;\n+    strm.avail_in := InBytes;\n+    strm.next_out := OutBuf;\n+    strm.avail_out := OutBytes;\n+    DCheck(inflateInit_(strm, zlib_version, sizeof(strm)));\n+    try\n+      while DCheck(inflate(strm, Z_FINISH)) <> Z_STREAM_END do\n+      begin\n+        P := OutBuf;\n+        Inc(OutBytes, BufInc);\n+        ReallocMem(OutBuf, OutBytes);\n+        strm.next_out := PChar(Integer(OutBuf) + (Integer(strm.next_out) - Integer(P)));\n+        strm.avail_out := BufInc;\n+      end;\n+    finally\n+      DCheck(inflateEnd(strm));\n+    end;\n+    ReallocMem(OutBuf, strm.total_out);\n+    OutBytes := strm.total_out;\n+  except\n+    FreeMem(OutBuf);\n+    raise\n+  end;\n+end;\n+\n+procedure DecompressToUserBuf(const InBuf: Pointer; InBytes: Integer;\n+  const OutBuf: Pointer; BufSize: Integer);\n+var\n+  strm: TZStreamRec;\n+begin\n+  FillChar(strm, sizeof(strm), 0);\n+  strm.zalloc := zlibAllocMem;\n+  strm.zfree := zlibFreeMem;\n+  strm.next_in := InBuf;\n+  strm.avail_in := InBytes;\n+  strm.next_out := OutBuf;\n+  strm.avail_out := BufSize;\n+  DCheck(inflateInit_(strm, zlib_version, sizeof(strm)));\n+  try\n+    if DCheck(inflate(strm, Z_FINISH)) <> Z_STREAM_END then\n+      raise EZlibError.CreateRes(@sTargetBufferTooSmall);\n+  finally\n+    DCheck(inflateEnd(strm));\n+  end;\n+end;\n+\n+// TCustomZlibStream\n+\n+constructor TCustomZLibStream.Create(Strm: TStream);\n+begin\n+  inherited Create;\n+  FStrm := Strm;\n+  FStrmPos := Strm.Position;\n+  FZRec.zalloc := zlibAllocMem;\n+  FZRec.zfree := zlibFreeMem;\n+end;\n+\n+procedure TCustomZLibStream.Progress(Sender: TObject);\n+begin\n+  if Assigned(FOnProgress) then FOnProgress(Sender);\n+end;\n+\n+\n+// TCompressionStream\n+\n+constructor TCompressionStream.Create(CompressionLevel: TCompressionLevel;\n+  Dest: TStream);\n+const\n+  Levels: array [TCompressionLevel] of ShortInt =\n+    (Z_NO_COMPRESSION, Z_BEST_SPEED, Z_DEFAULT_COMPRESSION, Z_BEST_COMPRESSION);\n+begin\n+  inherited Create(Dest);\n+  FZRec.next_out := FBuffer;\n+  FZRec.avail_out := sizeof(FBuffer);\n+  CCheck(deflateInit_(FZRec, Levels[CompressionLevel], zlib_version, sizeof(FZRec)));\n+end;\n+\n+destructor TCompressionStream.Destroy;\n+begin\n+  FZRec.next_in := nil;\n+  FZRec.avail_in := 0;\n+  try\n+    if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;\n+    while (CCheck(deflate(FZRec, Z_FINISH)) <> Z_STREAM_END)\n+      and (FZRec.avail_out = 0) do\n+    begin\n+      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer));\n+      FZRec.next_out := FBuffer;\n+      FZRec.avail_out := sizeof(FBuffer);\n+    end;\n+    if FZRec.avail_out < sizeof(FBuffer) then\n+      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer) - FZRec.avail_out);\n+  finally\n+    deflateEnd(FZRec);\n+  end;\n+  inherited Destroy;\n+end;\n+\n+function TCompressionStream.Read(var Buffer; Count: Longint): Longint;\n+begin\n+  raise ECompressionError.CreateRes(@sInvalidStreamOp);\n+end;\n+\n+function TCompressionStream.Write(const Buffer; Count: Longint): Longint;\n+begin\n+  FZRec.next_in := @Buffer;\n+  FZRec.avail_in := Count;\n+  if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;\n+  while (FZRec.avail_in > 0) do\n+  begin\n+    CCheck(deflate(FZRec, 0));\n+    if FZRec.avail_out = 0 then\n+    begin\n+      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer));\n+      FZRec.next_out := FBuffer;\n+      FZRec.avail_out := sizeof(FBuffer);\n+      FStrmPos := FStrm.Position;\n+      Progress(Self);\n+    end;\n+  end;\n+  Result := Count;\n+end;\n+\n+function TCompressionStream.Seek(Offset: Longint; Origin: Word): Longint;\n+begin\n+  if (Offset = 0) and (Origin = soFromCurrent) then\n+    Result := FZRec.total_in\n+  else\n+    raise ECompressionError.CreateRes(@sInvalidStreamOp);\n+end;\n+\n+function TCompressionStream.GetCompressionRate: Single;\n+begin\n+  if FZRec.total_in = 0 then\n+    Result := 0\n+  else\n+    Result := (1.0 - (FZRec.total_out / FZRec.total_in)) * 100.0;\n+end;\n+\n+\n+// TDecompressionStream\n+\n+constructor TDecompressionStream.Create(Source: TStream);\n+begin\n+  inherited Create(Source);\n+  FZRec.next_in := FBuffer;\n+  FZRec.avail_in := 0;\n+  DCheck(inflateInit_(FZRec, zlib_version, sizeof(FZRec)));\n+end;\n+\n+destructor TDecompressionStream.Destroy;\n+begin\n+  FStrm.Seek(-FZRec.avail_in, 1);\n+  inflateEnd(FZRec);\n+  inherited Destroy;\n+end;\n+\n+function TDecompressionStream.Read(var Buffer; Count: Longint): Longint;\n+begin\n+  FZRec.next_out := @Buffer;\n+  FZRec.avail_out := Count;\n+  if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;\n+  while (FZRec.avail_out > 0) do\n+  begin\n+    if FZRec.avail_in = 0 then\n+    begin\n+      FZRec.avail_in := FStrm.Read(FBuffer, sizeof(FBuffer));\n+      if FZRec.avail_in = 0 then\n+      begin\n+        Result := Count - FZRec.avail_out;\n+        Exit;\n+      end;\n+          FZRec.next_in := FBuffer;\n+      FStrmPos := FStrm.Position;\n+      Progress(Self);\n+    end;\n+    CCheck(inflate(FZRec, 0));\n+  end;\n+  Result := Count;\n+end;\n+\n+function TDecompressionStream.Write(const Buffer; Count: Longint): Longint;\n+begin\n+  raise EDecompressionError.CreateRes(@sInvalidStreamOp);\n+end;\n+\n+function TDecompressionStream.Seek(Offset: Longint; Origin: Word): Longint;\n+var\n+  I: Integer;\n+  Buf: array [0..4095] of Char;\n+begin\n+  if (Offset = 0) and (Origin = soFromBeginning) then\n+  begin\n+    DCheck(inflateReset(FZRec));\n+    FZRec.next_in := FBuffer;\n+    FZRec.avail_in := 0;\n+    FStrm.Position := 0;\n+    FStrmPos := 0;\n+  end\n+  else if ( (Offset >= 0) and (Origin = soFromCurrent)) or\n+          ( ((Offset - FZRec.total_out) > 0) and (Origin = soFromBeginning)) then\n+  begin\n+    if Origin = soFromBeginning then Dec(Offset, FZRec.total_out);\n+    if Offset > 0 then\n+    begin\n+      for I := 1 to Offset div sizeof(Buf) do\n+        ReadBuffer(Buf, sizeof(Buf));\n+      ReadBuffer(Buf, Offset mod sizeof(Buf));\n+    end;\n+  end\n+  else\n+    raise EDecompressionError.CreateRes(@sInvalidStreamOp);\n+  Result := FZRec.total_out;\n+end;\n+\n+\n+end."}, {"sha": "cdfe13671d354465f5054630720a1d2b6c02ce79", "filename": "zlib/contrib/delphi/ZLibConst.pas", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fdelphi%2FZLibConst.pas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fdelphi%2FZLibConst.pas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi%2FZLibConst.pas?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,11 @@\n+unit ZLibConst;\n+\n+interface\n+\n+resourcestring\n+  sTargetBufferTooSmall = 'ZLib error: target buffer may be too small';\n+  sInvalidStreamOp = 'Invalid stream operation';\n+\n+implementation\n+\n+end."}, {"sha": "2dc9a8bba2f96e592a8dff7367fd6ca7cf8dcf2b", "filename": "zlib/contrib/delphi/readme.txt", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fdelphi%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fdelphi%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi%2Freadme.txt?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,76 @@\n+\n+Overview\n+========\n+\n+This directory contains an update to the ZLib interface unit,\n+distributed by Borland as a Delphi supplemental component.\n+\n+The original ZLib unit is Copyright (c) 1997,99 Borland Corp.,\n+and is based on zlib version 1.0.4.  There are a series of bugs\n+and security problems associated with that old zlib version, and\n+we recommend the users to update their ZLib unit.\n+\n+\n+Summary of modifications\n+========================\n+\n+- Improved makefile, adapted to zlib version 1.2.1.\n+\n+- Some field types from TZStreamRec are changed from Integer to\n+  Longint, for consistency with the zlib.h header, and for 64-bit\n+  readiness.\n+\n+- The zlib_version constant is updated.\n+\n+- The new Z_RLE strategy has its corresponding symbolic constant.\n+\n+- The allocation and deallocation functions and function types\n+  (TAlloc, TFree, zlibAllocMem and zlibFreeMem) are now cdecl,\n+  and _malloc and _free are added as C RTL stubs.  As a result,\n+  the original C sources of zlib can be compiled out of the box,\n+  and linked to the ZLib unit.\n+\n+\n+Suggestions for improvements\n+============================\n+\n+Currently, the ZLib unit provides only a limited wrapper around\n+the zlib library, and much of the original zlib functionality is\n+missing.  Handling compressed file formats like ZIP/GZIP or PNG\n+cannot be implemented without having this functionality.\n+Applications that handle these formats are either using their own,\n+duplicated code, or not using the ZLib unit at all.\n+\n+Here are a few suggestions:\n+\n+- Checksum class wrappers around adler32() and crc32(), similar\n+  to the Java classes that implement the java.util.zip.Checksum\n+  interface.\n+\n+- The ability to read and write raw deflate streams, without the\n+  zlib stream header and trailer.  Raw deflate streams are used\n+  in the ZIP file format.\n+\n+- The ability to read and write gzip streams, used in the GZIP\n+  file format, and normally produced by the gzip program.\n+\n+- The ability to select a different compression strategy, useful\n+  to PNG and MNG image compression, and to multimedia compression\n+  in general.  Besides the compression level\n+\n+    TCompressionLevel = (clNone, clFastest, clDefault, clMax);\n+\n+  which, in fact, could have used the 'z' prefix and avoided\n+  TColor-like symbols\n+\n+    TCompressionLevel = (zcNone, zcFastest, zcDefault, zcMax);\n+\n+  there could be a compression strategy\n+\n+    TCompressionStrategy = (zsDefault, zsFiltered, zsHuffmanOnly, zsRle);\n+\n+- ZIP and GZIP stream handling via TStreams.\n+\n+\n+--\n+Cosmin Truta <cosmint@cs.ubbcluj.ro>"}, {"sha": "88fafa0b14d123fb81ef34d387031d622a38e1d2", "filename": "zlib/contrib/delphi/zlibd32.mak", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fdelphi%2Fzlibd32.mak", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fdelphi%2Fzlibd32.mak", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi%2Fzlibd32.mak?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,93 @@\n+# Makefile for zlib\n+# For use with Delphi and C++ Builder under Win32\n+# Updated for zlib 1.2.x by Cosmin Truta\n+\n+# ------------ Borland C++ ------------\n+\n+# This project uses the Delphi (fastcall/register) calling convention:\n+LOC = -DZEXPORT=__fastcall -DZEXPORTVA=__cdecl\n+\n+CC = bcc32\n+LD = bcc32\n+AR = tlib\n+# do not use \"-pr\" in CFLAGS\n+CFLAGS = -a -d -k- -O2 $(LOC)\n+LDFLAGS =\n+\n+\n+# variables\n+ZLIB_LIB = zlib.lib\n+\n+OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infback.obj\n+OBJ2 = inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj\n+OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzio.obj+infback.obj\n+OBJP2 = +inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj\n+\n+\n+# targets\n+all: $(ZLIB_LIB) example.exe minigzip.exe\n+\n+.c.obj:\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+adler32.obj: adler32.c zlib.h zconf.h\n+\n+compress.obj: compress.c zlib.h zconf.h\n+\n+crc32.obj: crc32.c zlib.h zconf.h crc32.h\n+\n+deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h\n+\n+gzio.obj: gzio.c zutil.h zlib.h zconf.h\n+\n+infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \\\n+ inffast.h inffixed.h\n+\n+inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \\\n+ inffast.h\n+\n+inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \\\n+ inffast.h inffixed.h\n+\n+inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h\n+\n+trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h\n+\n+uncompr.obj: uncompr.c zlib.h zconf.h\n+\n+zutil.obj: zutil.c zutil.h zlib.h zconf.h\n+\n+example.obj: example.c zlib.h zconf.h\n+\n+minigzip.obj: minigzip.c zlib.h zconf.h\n+\n+\n+# For the sake of the old Borland make,\n+# the command line is cut to fit in the MS-DOS 128 byte limit:\n+$(ZLIB_LIB): $(OBJ1) $(OBJ2)\n+\t-del $(ZLIB_LIB)\n+\t$(AR) $(ZLIB_LIB) $(OBJP1)\n+\t$(AR) $(ZLIB_LIB) $(OBJP2)\n+\n+\n+# testing\n+test: example.exe minigzip.exe\n+\texample\n+\techo hello world | minigzip | minigzip -d\n+\n+example.exe: example.obj $(ZLIB_LIB)\n+\t$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)\n+\n+minigzip.exe: minigzip.obj $(ZLIB_LIB)\n+\t$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)\n+\n+\n+# cleanup\n+clean:\n+\t-del *.obj\n+\t-del *.exe\n+\t-del *.lib\n+\t-del *.tds\n+\t-del zlib.bak\n+\t-del foo.gz\n+"}, {"sha": "f2e9e4ffd522b39ed02e0f4430fff31c6475b356", "filename": "zlib/contrib/gzappend/gzappend.c", "status": "added", "additions": 500, "deletions": 0, "changes": 500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fgzappend%2Fgzappend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fgzappend%2Fgzappend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fgzappend%2Fgzappend.c?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,500 @@\n+/* gzappend -- command to append to a gzip file\n+\n+  Copyright (C) 2003 Mark Adler, all rights reserved\n+  version 1.1, 4 Nov 2003\n+\n+  This software is provided 'as-is', without any express or implied\n+  warranty.  In no event will the author be held liable for any damages\n+  arising from the use of this software.\n+\n+  Permission is granted to anyone to use this software for any purpose,\n+  including commercial applications, and to alter it and redistribute it\n+  freely, subject to the following restrictions:\n+\n+  1. The origin of this software must not be misrepresented; you must not\n+     claim that you wrote the original software. If you use this software\n+     in a product, an acknowledgment in the product documentation would be\n+     appreciated but is not required.\n+  2. Altered source versions must be plainly marked as such, and must not be\n+     misrepresented as being the original software.\n+  3. This notice may not be removed or altered from any source distribution.\n+\n+  Mark Adler    madler@alumni.caltech.edu\n+ */\n+\n+/*\n+ * Change history:\n+ *\n+ * 1.0  19 Oct 2003     - First version\n+ * 1.1   4 Nov 2003     - Expand and clarify some comments and notes\n+ *                      - Add version and copyright to help\n+ *                      - Send help to stdout instead of stderr\n+ *                      - Add some preemptive typecasts\n+ *                      - Add L to constants in lseek() calls\n+ *                      - Remove some debugging information in error messages\n+ *                      - Use new data_type definition for zlib 1.2.1\n+ *                      - Simplfy and unify file operations\n+ *                      - Finish off gzip file in gztack()\n+ *                      - Use deflatePrime() instead of adding empty blocks\n+ *                      - Keep gzip file clean on appended file read errors\n+ *                      - Use in-place rotate instead of auxiliary buffer\n+ *                        (Why you ask?  Because it was fun to write!)\n+ */\n+\n+/*\n+   gzappend takes a gzip file and appends to it, compressing files from the\n+   command line or data from stdin.  The gzip file is written to directly, to\n+   avoid copying that file, in case it's large.  Note that this results in the\n+   unfriendly behavior that if gzappend fails, the gzip file is corrupted.\n+\n+   This program was written to illustrate the use of the new Z_BLOCK option of\n+   zlib 1.2.1's inflate() function.  This option returns from inflate() at each\n+   block boundary to facilitate locating and modifying the last block bit at\n+   the start of the final deflate block.  Also whether using Z_BLOCK or not,\n+   another required feature of zlib 1.2.1 is that inflate() now provides the\n+   number of unusued bits in the last input byte used.  gzappend will not work\n+   with versions of zlib earlier than 1.2.1.\n+\n+   gzappend first decompresses the gzip file internally, discarding all but\n+   the last 32K of uncompressed data, and noting the location of the last block\n+   bit and the number of unused bits in the last byte of the compressed data.\n+   The gzip trailer containing the CRC-32 and length of the uncompressed data\n+   is verified.  This trailer will be later overwritten.\n+\n+   Then the last block bit is cleared by seeking back in the file and rewriting\n+   the byte that contains it.  Seeking forward, the last byte of the compressed\n+   data is saved along with the number of unused bits to initialize deflate.\n+\n+   A deflate process is initialized, using the last 32K of the uncompressed\n+   data from the gzip file to initialize the dictionary.  If the total\n+   uncompressed data was less than 32K, then all of it is used to initialize\n+   the dictionary.  The deflate output bit buffer is also initialized with the\n+   last bits from the original deflate stream.  From here on, the data to\n+   append is simply compressed using deflate, and written to the gzip file.\n+   When that is complete, the new CRC-32 and uncompressed length are written\n+   as the trailer of the gzip file.\n+ */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include \"zlib.h\"\n+\n+#define local static\n+#define LGCHUNK 14\n+#define CHUNK (1U << LGCHUNK)\n+#define DSIZE 32768U\n+\n+/* print an error message and terminate with extreme prejudice */\n+local void bye(char *msg1, char *msg2)\n+{\n+    fprintf(stderr, \"gzappend error: %s%s\\n\", msg1, msg2);\n+    exit(1);\n+}\n+\n+/* return the greatest common divisor of a and b using Euclid's algorithm,\n+   modified to be fast when one argument much greater than the other, and\n+   coded to avoid unnecessary swapping */\n+local unsigned gcd(unsigned a, unsigned b)\n+{\n+    unsigned c;\n+\n+    while (a && b)\n+        if (a > b) {\n+            c = b;\n+            while (a - c >= c)\n+                c <<= 1;\n+            a -= c;\n+        }\n+        else {\n+            c = a;\n+            while (b - c >= c)\n+                c <<= 1;\n+            b -= c;\n+        }\n+    return a + b;\n+}\n+\n+/* rotate list[0..len-1] left by rot positions, in place */\n+local void rotate(unsigned char *list, unsigned len, unsigned rot)\n+{\n+    unsigned char tmp;\n+    unsigned cycles;\n+    unsigned char *start, *last, *to, *from;\n+\n+    /* normalize rot and handle degenerate cases */\n+    if (len < 2) return;\n+    if (rot >= len) rot %= len;\n+    if (rot == 0) return;\n+\n+    /* pointer to last entry in list */\n+    last = list + (len - 1);\n+\n+    /* do simple left shift by one */\n+    if (rot == 1) {\n+        tmp = *list;\n+        memcpy(list, list + 1, len - 1);\n+        *last = tmp;\n+        return;\n+    }\n+\n+    /* do simple right shift by one */\n+    if (rot == len - 1) {\n+        tmp = *last;\n+        memmove(list + 1, list, len - 1);\n+        *list = tmp;\n+        return;\n+    }\n+\n+    /* otherwise do rotate as a set of cycles in place */\n+    cycles = gcd(len, rot);             /* number of cycles */\n+    do {\n+        start = from = list + cycles;   /* start index is arbitrary */\n+        tmp = *from;                    /* save entry to be overwritten */\n+        for (;;) {\n+            to = from;                  /* next step in cycle */\n+            from += rot;                /* go right rot positions */\n+            if (from > last) from -= len;   /* (pointer better not wrap) */\n+            if (from == start) break;   /* all but one shifted */\n+            *to = *from;                /* shift left */\n+        }\n+        *to = tmp;                      /* complete the circle */\n+    } while (--cycles);\n+}\n+\n+/* structure for gzip file read operations */\n+typedef struct {\n+    int fd;                     /* file descriptor */\n+    int size;                   /* 1 << size is bytes in buf */\n+    unsigned left;              /* bytes available at next */\n+    unsigned char *buf;         /* buffer */\n+    unsigned char *next;        /* next byte in buffer */\n+    char *name;                 /* file name for error messages */\n+} file;\n+\n+/* reload buffer */\n+local int readin(file *in)\n+{\n+    int len;\n+\n+    len = read(in->fd, in->buf, 1 << in->size);\n+    if (len == -1) bye(\"error reading \", in->name);\n+    in->left = (unsigned)len;\n+    in->next = in->buf;\n+    return len;\n+}\n+\n+/* read from file in, exit if end-of-file */\n+local int readmore(file *in)\n+{\n+    if (readin(in) == 0) bye(\"unexpected end of \", in->name);\n+    return 0;\n+}\n+\n+#define read1(in) (in->left == 0 ? readmore(in) : 0, \\\n+                   in->left--, *(in->next)++)\n+\n+/* skip over n bytes of in */\n+local void skip(file *in, unsigned n)\n+{\n+    unsigned bypass;\n+\n+    if (n > in->left) {\n+        n -= in->left;\n+        bypass = n & ~((1U << in->size) - 1);\n+        if (bypass) {\n+            if (lseek(in->fd, (off_t)bypass, SEEK_CUR) == -1)\n+                bye(\"seeking \", in->name);\n+            n -= bypass;\n+        }\n+        readmore(in);\n+        if (n > in->left)\n+            bye(\"unexpected end of \", in->name);\n+    }\n+    in->left -= n;\n+    in->next += n;\n+}\n+\n+/* read a four-byte unsigned integer, little-endian, from in */\n+unsigned long read4(file *in)\n+{\n+    unsigned long val;\n+\n+    val = read1(in);\n+    val += (unsigned)read1(in) << 8;\n+    val += (unsigned long)read1(in) << 16;\n+    val += (unsigned long)read1(in) << 24;\n+    return val;\n+}\n+\n+/* skip over gzip header */\n+local void gzheader(file *in)\n+{\n+    int flags;\n+    unsigned n;\n+\n+    if (read1(in) != 31 || read1(in) != 139) bye(in->name, \" not a gzip file\");\n+    if (read1(in) != 8) bye(\"unknown compression method in\", in->name);\n+    flags = read1(in);\n+    if (flags & 0xe0) bye(\"unknown header flags set in\", in->name);\n+    skip(in, 6);\n+    if (flags & 4) {\n+        n = read1(in);\n+        n += (unsigned)(read1(in)) << 8;\n+        skip(in, n);\n+    }\n+    if (flags & 8) while (read1(in) != 0) ;\n+    if (flags & 16) while (read1(in) != 0) ;\n+    if (flags & 2) skip(in, 2);\n+}\n+\n+/* decompress gzip file \"name\", return strm with a deflate stream ready to\n+   continue compression of the data in the gzip file, and return a file\n+   descriptor pointing to where to write the compressed data -- the deflate\n+   stream is initialized to compress using level \"level\" */\n+local int gzscan(char *name, z_stream *strm, int level)\n+{\n+    int ret, lastbit, left, full;\n+    unsigned have;\n+    unsigned long crc, tot;\n+    unsigned char *window;\n+    off_t lastoff, end;\n+    file gz;\n+\n+    /* open gzip file */\n+    gz.name = name;\n+    gz.fd = open(name, O_RDWR, 0);\n+    if (gz.fd == -1) bye(\"cannot open \", name);\n+    gz.buf = malloc(CHUNK);\n+    if (gz.buf == NULL) bye(\"out of memory\", \"\");\n+    gz.size = LGCHUNK;\n+    gz.left = 0;\n+\n+    /* skip gzip header */\n+    gzheader(&gz);\n+\n+    /* prepare to decompress */\n+    window = malloc(DSIZE);\n+    if (window == NULL) bye(\"out of memory\", \"\");\n+    strm->zalloc = Z_NULL;\n+    strm->zfree = Z_NULL;\n+    strm->opaque = Z_NULL;\n+    ret = inflateInit2(strm, -15);\n+    if (ret != Z_OK) bye(\"out of memory\", \" or library mismatch\");\n+\n+    /* decompress the deflate stream, saving append information */\n+    lastbit = 0;\n+    lastoff = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;\n+    left = 0;\n+    strm->avail_in = gz.left;\n+    strm->next_in = gz.next;\n+    crc = crc32(0L, Z_NULL, 0);\n+    have = full = 0;\n+    do {\n+        /* if needed, get more input */\n+        if (strm->avail_in == 0) {\n+            readmore(&gz);\n+            strm->avail_in = gz.left;\n+            strm->next_in = gz.next;\n+        }\n+\n+        /* set up output to next available section of sliding window */\n+        strm->avail_out = DSIZE - have;\n+        strm->next_out = window + have;\n+\n+        /* inflate and check for errors */\n+        ret = inflate(strm, Z_BLOCK);\n+        if (ret == Z_STREAM_ERROR) bye(\"internal stream error!\", \"\");\n+        if (ret == Z_MEM_ERROR) bye(\"out of memory\", \"\");\n+        if (ret == Z_DATA_ERROR)\n+            bye(\"invalid compressed data--format violated in\", name);\n+\n+        /* update crc and sliding window pointer */\n+        crc = crc32(crc, window + have, DSIZE - have - strm->avail_out);\n+        if (strm->avail_out)\n+            have = DSIZE - strm->avail_out;\n+        else {\n+            have = 0;\n+            full = 1;\n+        }\n+\n+        /* process end of block */\n+        if (strm->data_type & 128) {\n+            if (strm->data_type & 64)\n+                left = strm->data_type & 0x1f;\n+            else {\n+                lastbit = strm->data_type & 0x1f;\n+                lastoff = lseek(gz.fd, 0L, SEEK_CUR) - strm->avail_in;\n+            }\n+        }\n+    } while (ret != Z_STREAM_END);\n+    inflateEnd(strm);\n+    gz.left = strm->avail_in;\n+    gz.next = strm->next_in;\n+\n+    /* save the location of the end of the compressed data */\n+    end = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;\n+\n+    /* check gzip trailer and save total for deflate */\n+    if (crc != read4(&gz))\n+        bye(\"invalid compressed data--crc mismatch in \", name);\n+    tot = strm->total_out;\n+    if ((tot & 0xffffffffUL) != read4(&gz))\n+        bye(\"invalid compressed data--length mismatch in\", name);\n+\n+    /* if not at end of file, warn */\n+    if (gz.left || readin(&gz))\n+        fprintf(stderr,\n+            \"gzappend warning: junk at end of gzip file overwritten\\n\");\n+\n+    /* clear last block bit */\n+    lseek(gz.fd, lastoff - (lastbit != 0), SEEK_SET);\n+    if (read(gz.fd, gz.buf, 1) != 1) bye(\"reading after seek on \", name);\n+    *gz.buf = (unsigned char)(*gz.buf ^ (1 << ((8 - lastbit) & 7)));\n+    lseek(gz.fd, -1L, SEEK_CUR);\n+    if (write(gz.fd, gz.buf, 1) != 1) bye(\"writing after seek to \", name);\n+\n+    /* if window wrapped, build dictionary from window by rotating */\n+    if (full) {\n+        rotate(window, DSIZE, have);\n+        have = DSIZE;\n+    }\n+\n+    /* set up deflate stream with window, crc, total_in, and leftover bits */\n+    ret = deflateInit2(strm, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);\n+    if (ret != Z_OK) bye(\"out of memory\", \"\");\n+    deflateSetDictionary(strm, window, have);\n+    strm->adler = crc;\n+    strm->total_in = tot;\n+    if (left) {\n+        lseek(gz.fd, --end, SEEK_SET);\n+        if (read(gz.fd, gz.buf, 1) != 1) bye(\"reading after seek on \", name);\n+        deflatePrime(strm, 8 - left, *gz.buf);\n+    }\n+    lseek(gz.fd, end, SEEK_SET);\n+\n+    /* clean up and return */\n+    free(window);\n+    free(gz.buf);\n+    return gz.fd;\n+}\n+\n+/* append file \"name\" to gzip file gd using deflate stream strm -- if last\n+   is true, then finish off the deflate stream at the end */\n+local void gztack(char *name, int gd, z_stream *strm, int last)\n+{\n+    int fd, len, ret;\n+    unsigned left;\n+    unsigned char *in, *out;\n+\n+    /* open file to compress and append */\n+    fd = 0;\n+    if (name != NULL) {\n+        fd = open(name, O_RDONLY, 0);\n+        if (fd == -1)\n+            fprintf(stderr, \"gzappend warning: %s not found, skipping ...\\n\",\n+                    name);\n+    }\n+\n+    /* allocate buffers */\n+    in = fd == -1 ? NULL : malloc(CHUNK);\n+    out = malloc(CHUNK);\n+    if (out == NULL) bye(\"out of memory\", \"\");\n+\n+    /* compress input file and append to gzip file */\n+    do {\n+        /* get more input */\n+        len = fd == -1 ? 0 : read(fd, in, CHUNK);\n+        if (len == -1) {\n+            fprintf(stderr,\n+                    \"gzappend warning: error reading %s, skipping rest ...\\n\",\n+                    name);\n+            len = 0;\n+        }\n+        strm->avail_in = (unsigned)len;\n+        strm->next_in = in;\n+        if (len) strm->adler = crc32(strm->adler, in, (unsigned)len);\n+\n+        /* compress and write all available output */\n+        do {\n+            strm->avail_out = CHUNK;\n+            strm->next_out = out;\n+            ret = deflate(strm, last && len == 0 ? Z_FINISH : Z_NO_FLUSH);\n+            left = CHUNK - strm->avail_out;\n+            while (left) {\n+                len = write(gd, out + CHUNK - strm->avail_out - left, left);\n+                if (len == -1) bye(\"writing gzip file\", \"\");\n+                left -= (unsigned)len;\n+            }\n+        } while (strm->avail_out == 0 && ret != Z_STREAM_END);\n+    } while (len != 0);\n+\n+    /* write trailer after last entry */\n+    if (last) {\n+        deflateEnd(strm);\n+        out[0] = (unsigned char)(strm->adler);\n+        out[1] = (unsigned char)(strm->adler >> 8);\n+        out[2] = (unsigned char)(strm->adler >> 16);\n+        out[3] = (unsigned char)(strm->adler >> 24);\n+        out[4] = (unsigned char)(strm->total_in);\n+        out[5] = (unsigned char)(strm->total_in >> 8);\n+        out[6] = (unsigned char)(strm->total_in >> 16);\n+        out[7] = (unsigned char)(strm->total_in >> 24);\n+        len = 8;\n+        do {\n+            ret = write(gd, out + 8 - len, len);\n+            if (ret == -1) bye(\"writing gzip file\", \"\");\n+            len -= ret;\n+        } while (len);\n+        close(gd);\n+    }\n+\n+    /* clean up and return */\n+    free(out);\n+    if (in != NULL) free(in);\n+    if (fd > 0) close(fd);\n+}\n+\n+/* process the compression level option if present, scan the gzip file, and\n+   append the specified files, or append the data from stdin if no other file\n+   names are provided on the command line -- the gzip file must be writable\n+   and seekable */\n+int main(int argc, char **argv)\n+{\n+    int gd, level;\n+    z_stream strm;\n+\n+    /* ignore command name */\n+    argv++;\n+\n+    /* provide usage if no arguments */\n+    if (*argv == NULL) {\n+        printf(\"gzappend 1.1 (4 Nov 2003) Copyright (C) 2003 Mark Adler\\n\");\n+        printf(\n+            \"usage: gzappend [-level] file.gz [ addthis [ andthis ... ]]\\n\");\n+        return 0;\n+    }\n+\n+    /* set compression level */\n+    level = Z_DEFAULT_COMPRESSION;\n+    if (argv[0][0] == '-') {\n+        if (argv[0][1] < '0' || argv[0][1] > '9' || argv[0][2] != 0)\n+            bye(\"invalid compression level\", \"\");\n+        level = argv[0][1] - '0';\n+        if (*++argv == NULL) bye(\"no gzip file name after options\", \"\");\n+    }\n+\n+    /* prepare to append to gzip file */\n+    gd = gzscan(*argv++, &strm, level);\n+\n+    /* append files on command line, or from stdin if none */\n+    if (*argv == NULL)\n+        gztack(NULL, gd, &strm, 1);\n+    else\n+        do {\n+            gztack(*argv, gd, &strm, argv[1] == NULL);\n+        } while (*++argv != NULL);\n+    return 0;\n+}"}, {"sha": "e75ed132948f3b64f05f9d29c14fe8af726b221f", "filename": "zlib/contrib/infback9/README", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finfback9%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finfback9%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finfback9%2FREADME?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1 @@\n+See infback9.h for what this is and how to use it."}, {"sha": "34a95fc0dac452642c7676749c4f1884df547fec", "filename": "zlib/contrib/infback9/infback9.c", "status": "added", "additions": 605, "deletions": 0, "changes": 605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finfback9%2Finfback9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finfback9%2Finfback9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finfback9%2Finfback9.c?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,605 @@\n+/* infback9.c -- inflate deflate64 data using a call-back interface\n+ * Copyright (C) 1995-2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ */\n+\n+#include \"zutil.h\"\n+#include \"infback9.h\"\n+#include \"inftree9.h\"\n+#include \"inflate9.h\"\n+\n+#define WSIZE 65536UL\n+\n+/*\n+   strm provides memory allocation functions in zalloc and zfree, or\n+   Z_NULL to use the library memory allocation functions.\n+\n+   window is a user-supplied window and output buffer that is 64K bytes.\n+ */\n+int ZEXPORT inflateBack9Init_(strm, window, version, stream_size)\n+z_stream FAR *strm;\n+unsigned char FAR *window;\n+const char *version;\n+int stream_size;\n+{\n+    struct inflate_state FAR *state;\n+\n+    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||\n+        stream_size != (int)(sizeof(z_stream)))\n+        return Z_VERSION_ERROR;\n+    if (strm == Z_NULL || window == Z_NULL)\n+        return Z_STREAM_ERROR;\n+    strm->msg = Z_NULL;                 /* in case we return an error */\n+    if (strm->zalloc == (alloc_func)0) {\n+        strm->zalloc = zcalloc;\n+        strm->opaque = (voidpf)0;\n+    }\n+    if (strm->zfree == (free_func)0) strm->zfree = zcfree;\n+    state = (struct inflate_state FAR *)ZALLOC(strm, 1,\n+                                               sizeof(struct inflate_state));\n+    if (state == Z_NULL) return Z_MEM_ERROR;\n+    Tracev((stderr, \"inflate: allocated\\n\"));\n+    strm->state = (voidpf)state;\n+    state->window = window;\n+    return Z_OK;\n+}\n+\n+/*\n+   Build and output length and distance decoding tables for fixed code\n+   decoding.\n+ */\n+#ifdef MAKEFIXED\n+#include <stdio.h>\n+\n+void makefixed9(void)\n+{\n+    unsigned sym, bits, low, size;\n+    code *next, *lenfix, *distfix;\n+    struct inflate_state state;\n+    code fixed[544];\n+\n+    /* literal/length table */\n+    sym = 0;\n+    while (sym < 144) state.lens[sym++] = 8;\n+    while (sym < 256) state.lens[sym++] = 9;\n+    while (sym < 280) state.lens[sym++] = 7;\n+    while (sym < 288) state.lens[sym++] = 8;\n+    next = fixed;\n+    lenfix = next;\n+    bits = 9;\n+    inflate_table9(LENS, state.lens, 288, &(next), &(bits), state.work);\n+\n+    /* distance table */\n+    sym = 0;\n+    while (sym < 32) state.lens[sym++] = 5;\n+    distfix = next;\n+    bits = 5;\n+    inflate_table9(DISTS, state.lens, 32, &(next), &(bits), state.work);\n+\n+    /* write tables */\n+    puts(\"    /* inffix9.h -- table for decoding deflate64 fixed codes\");\n+    puts(\"     * Generated automatically by makefixed9().\");\n+    puts(\"     */\");\n+    puts(\"\");\n+    puts(\"    /* WARNING: this file should *not* be used by applications.\");\n+    puts(\"       It is part of the implementation of this library and is\");\n+    puts(\"       subject to change. Applications should only use zlib.h.\");\n+    puts(\"     */\");\n+    puts(\"\");\n+    size = 1U << 9;\n+    printf(\"    static const code lenfix[%u] = {\", size);\n+    low = 0;\n+    for (;;) {\n+        if ((low % 6) == 0) printf(\"\\n        \");\n+        printf(\"{%u,%u,%d}\", lenfix[low].op, lenfix[low].bits,\n+               lenfix[low].val);\n+        if (++low == size) break;\n+        putchar(',');\n+    }\n+    puts(\"\\n    };\");\n+    size = 1U << 5;\n+    printf(\"\\n    static const code distfix[%u] = {\", size);\n+    low = 0;\n+    for (;;) {\n+        if ((low % 5) == 0) printf(\"\\n        \");\n+        printf(\"{%u,%u,%d}\", distfix[low].op, distfix[low].bits,\n+               distfix[low].val);\n+        if (++low == size) break;\n+        putchar(',');\n+    }\n+    puts(\"\\n    };\");\n+}\n+#endif /* MAKEFIXED */\n+\n+/* Macros for inflateBack(): */\n+\n+/* Clear the input bit accumulator */\n+#define INITBITS() \\\n+    do { \\\n+        hold = 0; \\\n+        bits = 0; \\\n+    } while (0)\n+\n+/* Assure that some input is available.  If input is requested, but denied,\n+   then return a Z_BUF_ERROR from inflateBack(). */\n+#define PULL() \\\n+    do { \\\n+        if (have == 0) { \\\n+            have = in(in_desc, &next); \\\n+            if (have == 0) { \\\n+                next = Z_NULL; \\\n+                ret = Z_BUF_ERROR; \\\n+                goto inf_leave; \\\n+            } \\\n+        } \\\n+    } while (0)\n+\n+/* Get a byte of input into the bit accumulator, or return from inflateBack()\n+   with an error if there is no input available. */\n+#define PULLBYTE() \\\n+    do { \\\n+        PULL(); \\\n+        have--; \\\n+        hold += (unsigned long)(*next++) << bits; \\\n+        bits += 8; \\\n+    } while (0)\n+\n+/* Assure that there are at least n bits in the bit accumulator.  If there is\n+   not enough available input to do that, then return from inflateBack() with\n+   an error. */\n+#define NEEDBITS(n) \\\n+    do { \\\n+        while (bits < (unsigned)(n)) \\\n+            PULLBYTE(); \\\n+    } while (0)\n+\n+/* Return the low n bits of the bit accumulator (n <= 16) */\n+#define BITS(n) \\\n+    ((unsigned)hold & ((1U << (n)) - 1))\n+\n+/* Remove n bits from the bit accumulator */\n+#define DROPBITS(n) \\\n+    do { \\\n+        hold >>= (n); \\\n+        bits -= (unsigned)(n); \\\n+    } while (0)\n+\n+/* Remove zero to seven bits as needed to go to a byte boundary */\n+#define BYTEBITS() \\\n+    do { \\\n+        hold >>= bits & 7; \\\n+        bits -= bits & 7; \\\n+    } while (0)\n+\n+/* Assure that some output space is available, by writing out the window\n+   if it's full.  If the write fails, return from inflateBack() with a\n+   Z_BUF_ERROR. */\n+#define ROOM() \\\n+    do { \\\n+        if (left == 0) { \\\n+            put = window; \\\n+            left = WSIZE; \\\n+            wrap = 1; \\\n+            if (out(out_desc, put, (unsigned)left)) { \\\n+                ret = Z_BUF_ERROR; \\\n+                goto inf_leave; \\\n+            } \\\n+        } \\\n+    } while (0)\n+\n+/*\n+   strm provides the memory allocation functions and window buffer on input,\n+   and provides information on the unused input on return.  For Z_DATA_ERROR\n+   returns, strm will also provide an error message.\n+\n+   in() and out() are the call-back input and output functions.  When\n+   inflateBack() needs more input, it calls in().  When inflateBack() has\n+   filled the window with output, or when it completes with data in the\n+   window, it calls out() to write out the data.  The application must not\n+   change the provided input until in() is called again or inflateBack()\n+   returns.  The application must not change the window/output buffer until\n+   inflateBack() returns.\n+\n+   in() and out() are called with a descriptor parameter provided in the\n+   inflateBack() call.  This parameter can be a structure that provides the\n+   information required to do the read or write, as well as accumulated\n+   information on the input and output such as totals and check values.\n+\n+   in() should return zero on failure.  out() should return non-zero on\n+   failure.  If either in() or out() fails, than inflateBack() returns a\n+   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it\n+   was in() or out() that caused in the error.  Otherwise,  inflateBack()\n+   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format\n+   error, or Z_MEM_ERROR if it could not allocate memory for the state.\n+   inflateBack() can also return Z_STREAM_ERROR if the input parameters\n+   are not correct, i.e. strm is Z_NULL or the state was not initialized.\n+ */\n+int ZEXPORT inflateBack9(strm, in, in_desc, out, out_desc)\n+z_stream FAR *strm;\n+in_func in;\n+void FAR *in_desc;\n+out_func out;\n+void FAR *out_desc;\n+{\n+    struct inflate_state FAR *state;\n+    unsigned char FAR *next;    /* next input */\n+    unsigned char FAR *put;     /* next output */\n+    unsigned have;              /* available input */\n+    unsigned long left;         /* available output */\n+    inflate_mode mode;          /* current inflate mode */\n+    int lastblock;              /* true if processing last block */\n+    int wrap;                   /* true if the window has wrapped */\n+    unsigned long write;        /* window write index */\n+    unsigned char FAR *window;  /* allocated sliding window, if needed */\n+    unsigned long hold;         /* bit buffer */\n+    unsigned bits;              /* bits in bit buffer */\n+    unsigned extra;             /* extra bits needed */\n+    unsigned long length;       /* literal or length of data to copy */\n+    unsigned long offset;       /* distance back to copy string from */\n+    unsigned long copy;         /* number of stored or match bytes to copy */\n+    unsigned char FAR *from;    /* where to copy match bytes from */\n+    code const FAR *lencode;    /* starting table for length/literal codes */\n+    code const FAR *distcode;   /* starting table for distance codes */\n+    unsigned lenbits;           /* index bits for lencode */\n+    unsigned distbits;          /* index bits for distcode */\n+    code this;                  /* current decoding table entry */\n+    code last;                  /* parent table entry */\n+    unsigned len;               /* length to copy for repeats, bits to drop */\n+    int ret;                    /* return code */\n+    static const unsigned short order[19] = /* permutation of code lengths */\n+        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n+#include \"inffix9.h\"\n+\n+    /* Check that the strm exists and that the state was initialized */\n+    if (strm == Z_NULL || strm->state == Z_NULL)\n+        return Z_STREAM_ERROR;\n+    state = (struct inflate_state FAR *)strm->state;\n+\n+    /* Reset the state */\n+    strm->msg = Z_NULL;\n+    mode = TYPE;\n+    lastblock = 0;\n+    write = 0;\n+    wrap = 0;\n+    window = state->window;\n+    next = strm->next_in;\n+    have = next != Z_NULL ? strm->avail_in : 0;\n+    hold = 0;\n+    bits = 0;\n+    put = window;\n+    left = WSIZE;\n+    lencode = Z_NULL;\n+    distcode = Z_NULL;\n+\n+    /* Inflate until end of block marked as last */\n+    for (;;)\n+        switch (mode) {\n+        case TYPE:\n+            /* determine and dispatch block type */\n+            if (lastblock) {\n+                BYTEBITS();\n+                mode = DONE;\n+                break;\n+            }\n+            NEEDBITS(3);\n+            lastblock = BITS(1);\n+            DROPBITS(1);\n+            switch (BITS(2)) {\n+            case 0:                             /* stored block */\n+                Tracev((stderr, \"inflate:     stored block%s\\n\",\n+                        lastblock ? \" (last)\" : \"\"));\n+                mode = STORED;\n+                break;\n+            case 1:                             /* fixed block */\n+                lencode = lenfix;\n+                lenbits = 9;\n+                distcode = distfix;\n+                distbits = 5;\n+                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n+                        lastblock ? \" (last)\" : \"\"));\n+                mode = LEN;                     /* decode codes */\n+                break;\n+            case 2:                             /* dynamic block */\n+                Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n+                        lastblock ? \" (last)\" : \"\"));\n+                mode = TABLE;\n+                break;\n+            case 3:\n+                strm->msg = (char *)\"invalid block type\";\n+                mode = BAD;\n+            }\n+            DROPBITS(2);\n+            break;\n+\n+        case STORED:\n+            /* get and verify stored block length */\n+            BYTEBITS();                         /* go to byte boundary */\n+            NEEDBITS(32);\n+            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n+                strm->msg = (char *)\"invalid stored block lengths\";\n+                mode = BAD;\n+                break;\n+            }\n+            length = (unsigned)hold & 0xffff;\n+            Tracev((stderr, \"inflate:       stored length %lu\\n\",\n+                    length));\n+            INITBITS();\n+\n+            /* copy stored block from input to output */\n+            while (length != 0) {\n+                copy = length;\n+                PULL();\n+                ROOM();\n+                if (copy > have) copy = have;\n+                if (copy > left) copy = left;\n+                zmemcpy(put, next, copy);\n+                have -= copy;\n+                next += copy;\n+                left -= copy;\n+                put += copy;\n+                length -= copy;\n+            }\n+            Tracev((stderr, \"inflate:       stored end\\n\"));\n+            mode = TYPE;\n+            break;\n+\n+        case TABLE:\n+            /* get dynamic table entries descriptor */\n+            NEEDBITS(14);\n+            state->nlen = BITS(5) + 257;\n+            DROPBITS(5);\n+            state->ndist = BITS(5) + 1;\n+            DROPBITS(5);\n+            state->ncode = BITS(4) + 4;\n+            DROPBITS(4);\n+            if (state->nlen > 286) {\n+                strm->msg = (char *)\"too many length symbols\";\n+                mode = BAD;\n+                break;\n+            }\n+            Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n+\n+            /* get code length code lengths (not a typo) */\n+            state->have = 0;\n+            while (state->have < state->ncode) {\n+                NEEDBITS(3);\n+                state->lens[order[state->have++]] = (unsigned short)BITS(3);\n+                DROPBITS(3);\n+            }\n+            while (state->have < 19)\n+                state->lens[order[state->have++]] = 0;\n+            state->next = state->codes;\n+            lencode = (code const FAR *)(state->next);\n+            lenbits = 7;\n+            ret = inflate_table9(CODES, state->lens, 19, &(state->next),\n+                                &(lenbits), state->work);\n+            if (ret) {\n+                strm->msg = (char *)\"invalid code lengths set\";\n+                mode = BAD;\n+                break;\n+            }\n+            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n+\n+            /* get length and distance code code lengths */\n+            state->have = 0;\n+            while (state->have < state->nlen + state->ndist) {\n+                for (;;) {\n+                    this = lencode[BITS(lenbits)];\n+                    if ((unsigned)(this.bits) <= bits) break;\n+                    PULLBYTE();\n+                }\n+                if (this.val < 16) {\n+                    NEEDBITS(this.bits);\n+                    DROPBITS(this.bits);\n+                    state->lens[state->have++] = this.val;\n+                }\n+                else {\n+                    if (this.val == 16) {\n+                        NEEDBITS(this.bits + 2);\n+                        DROPBITS(this.bits);\n+                        if (state->have == 0) {\n+                            strm->msg = (char *)\"invalid bit length repeat\";\n+                            mode = BAD;\n+                            break;\n+                        }\n+                        len = (unsigned)(state->lens[state->have - 1]);\n+                        copy = 3 + BITS(2);\n+                        DROPBITS(2);\n+                    }\n+                    else if (this.val == 17) {\n+                        NEEDBITS(this.bits + 3);\n+                        DROPBITS(this.bits);\n+                        len = 0;\n+                        copy = 3 + BITS(3);\n+                        DROPBITS(3);\n+                    }\n+                    else {\n+                        NEEDBITS(this.bits + 7);\n+                        DROPBITS(this.bits);\n+                        len = 0;\n+                        copy = 11 + BITS(7);\n+                        DROPBITS(7);\n+                    }\n+                    if (state->have + copy > state->nlen + state->ndist) {\n+                        strm->msg = (char *)\"invalid bit length repeat\";\n+                        mode = BAD;\n+                        break;\n+                    }\n+                    while (copy--)\n+                        state->lens[state->have++] = (unsigned short)len;\n+                }\n+            }\n+\n+            /* build code tables */\n+            state->next = state->codes;\n+            lencode = (code const FAR *)(state->next);\n+            lenbits = 9;\n+            ret = inflate_table9(LENS, state->lens, state->nlen,\n+                            &(state->next), &(lenbits), state->work);\n+            if (ret) {\n+                strm->msg = (char *)\"invalid literal/lengths set\";\n+                mode = BAD;\n+                break;\n+            }\n+            distcode = (code const FAR *)(state->next);\n+            distbits = 6;\n+            ret = inflate_table9(DISTS, state->lens + state->nlen,\n+                            state->ndist, &(state->next), &(distbits),\n+                            state->work);\n+            if (ret) {\n+                strm->msg = (char *)\"invalid distances set\";\n+                mode = BAD;\n+                break;\n+            }\n+            Tracev((stderr, \"inflate:       codes ok\\n\"));\n+            mode = LEN;\n+\n+        case LEN:\n+            /* get a literal, length, or end-of-block code */\n+            for (;;) {\n+                this = lencode[BITS(lenbits)];\n+                if ((unsigned)(this.bits) <= bits) break;\n+                PULLBYTE();\n+            }\n+            if (this.op && (this.op & 0xf0) == 0) {\n+                last = this;\n+                for (;;) {\n+                    this = lencode[last.val +\n+                            (BITS(last.bits + last.op) >> last.bits)];\n+                    if ((unsigned)(last.bits + this.bits) <= bits) break;\n+                    PULLBYTE();\n+                }\n+                DROPBITS(last.bits);\n+            }\n+            DROPBITS(this.bits);\n+            length = (unsigned)this.val;\n+\n+            /* process literal */\n+            if (this.op == 0) {\n+                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?\n+                        \"inflate:         literal '%c'\\n\" :\n+                        \"inflate:         literal 0x%02x\\n\", this.val));\n+                ROOM();\n+                *put++ = (unsigned char)(length);\n+                left--;\n+                mode = LEN;\n+                break;\n+            }\n+\n+            /* process end of block */\n+            if (this.op & 32) {\n+                Tracevv((stderr, \"inflate:         end of block\\n\"));\n+                mode = TYPE;\n+                break;\n+            }\n+\n+            /* invalid code */\n+            if (this.op & 64) {\n+                strm->msg = (char *)\"invalid literal/length code\";\n+                mode = BAD;\n+                break;\n+            }\n+\n+            /* length code -- get extra bits, if any */\n+            extra = (unsigned)(this.op) & 31;\n+            if (extra != 0) {\n+                NEEDBITS(extra);\n+                length += BITS(extra);\n+                DROPBITS(extra);\n+            }\n+            Tracevv((stderr, \"inflate:         length %lu\\n\", length));\n+\n+            /* get distance code */\n+            for (;;) {\n+                this = distcode[BITS(distbits)];\n+                if ((unsigned)(this.bits) <= bits) break;\n+                PULLBYTE();\n+            }\n+            if ((this.op & 0xf0) == 0) {\n+                last = this;\n+                for (;;) {\n+                    this = distcode[last.val +\n+                            (BITS(last.bits + last.op) >> last.bits)];\n+                    if ((unsigned)(last.bits + this.bits) <= bits) break;\n+                    PULLBYTE();\n+                }\n+                DROPBITS(last.bits);\n+            }\n+            DROPBITS(this.bits);\n+            if (this.op & 64) {\n+                strm->msg = (char *)\"invalid distance code\";\n+                mode = BAD;\n+                break;\n+            }\n+            offset = (unsigned)this.val;\n+\n+            /* get distance extra bits, if any */\n+            extra = (unsigned)(this.op) & 15;\n+            if (extra != 0) {\n+                NEEDBITS(extra);\n+                offset += BITS(extra);\n+                DROPBITS(extra);\n+            }\n+            if (offset > WSIZE - (wrap ? 0: left)) {\n+                strm->msg = (char *)\"invalid distance too far back\";\n+                mode = BAD;\n+                break;\n+            }\n+            Tracevv((stderr, \"inflate:         distance %lu\\n\", offset));\n+\n+            /* copy match from window to output */\n+            do {\n+                ROOM();\n+                copy = WSIZE - offset;\n+                if (copy < left) {\n+                    from = put + copy;\n+                    copy = left - copy;\n+                }\n+                else {\n+                    from = put - offset;\n+                    copy = left;\n+                }\n+                if (copy > length) copy = length;\n+                length -= copy;\n+                left -= copy;\n+                do {\n+                    *put++ = *from++;\n+                } while (--copy);\n+            } while (length != 0);\n+            break;\n+\n+        case DONE:\n+            /* inflate stream terminated properly -- write leftover output */\n+            ret = Z_STREAM_END;\n+            if (left < WSIZE) {\n+                if (out(out_desc, window, (unsigned)(WSIZE - left)))\n+                    ret = Z_BUF_ERROR;\n+            }\n+            goto inf_leave;\n+\n+        case BAD:\n+            ret = Z_DATA_ERROR;\n+            goto inf_leave;\n+\n+        default:                /* can't happen, but makes compilers happy */\n+            ret = Z_STREAM_ERROR;\n+            goto inf_leave;\n+        }\n+\n+    /* Return unused input */\n+  inf_leave:\n+    strm->next_in = next;\n+    strm->avail_in = have;\n+    return ret;\n+}\n+\n+int ZEXPORT inflateBack9End(strm)\n+z_stream FAR *strm;\n+{\n+    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)\n+        return Z_STREAM_ERROR;\n+    ZFREE(strm, strm->state);\n+    strm->state = Z_NULL;\n+    Tracev((stderr, \"inflate: end\\n\"));\n+    return Z_OK;\n+}"}, {"sha": "10bf58c368e9230fc1e8203afae3805e69ebe54b", "filename": "zlib/contrib/infback9/infback9.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finfback9%2Finfback9.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finfback9%2Finfback9.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finfback9%2Finfback9.h?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,29 @@\n+/* infback9.h -- header for using inflateBack9 functions\n+ * Copyright (C) 2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ */\n+\n+/*\n+ * This header file and associated patches provide a decoder for PKWare's\n+ * undocumented deflate64 compression method (method 9).  Use with infback9.c,\n+ * inftree9.h, inftree9.c, and inffix9.h.  These patches are not supported.\n+ * This should be compiled with zlib, since it uses zutil.h and zutil.o.\n+ * This code has not yet been tested on 16-bit architectures.  See the\n+ * comments in zlib.h for inflateBack() usage.  These functions are used\n+ * identically, except that there is no windowBits parameter, and a 64K\n+ * window must be provided.  Also if int's are 16 bits, then a zero for\n+ * the third parameter of the \"out\" function actually means 65536UL.\n+ * zlib.h must be included before this header file.\n+ */\n+\n+ZEXTERN int ZEXPORT inflateBack9 OF((z_stream FAR *strm,\n+                                    in_func in, void FAR *in_desc,\n+                                    out_func out, void FAR *out_desc));\n+ZEXTERN int ZEXPORT inflateBack9End OF((z_stream FAR *strm));\n+ZEXTERN int ZEXPORT inflateBack9Init_ OF((z_stream FAR *strm,\n+                                         unsigned char FAR *window,\n+                                         const char *version,\n+                                         int stream_size));\n+#define inflateBack9Init(strm, window) \\\n+        inflateBack9Init_((strm), (window), \\\n+        ZLIB_VERSION, sizeof(z_stream))"}, {"sha": "ee5671d2df63f47fa93d1ac19c99b474050aff7d", "filename": "zlib/contrib/infback9/inffix9.h", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finfback9%2Finffix9.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finfback9%2Finffix9.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finfback9%2Finffix9.h?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,107 @@\n+    /* inffix9.h -- table for decoding deflate64 fixed codes\n+     * Generated automatically by makefixed9().\n+     */\n+\n+    /* WARNING: this file should *not* be used by applications.\n+       It is part of the implementation of this library and is\n+       subject to change. Applications should only use zlib.h.\n+     */\n+\n+    static const code lenfix[512] = {\n+        {96,7,0},{0,8,80},{0,8,16},{132,8,115},{130,7,31},{0,8,112},\n+        {0,8,48},{0,9,192},{128,7,10},{0,8,96},{0,8,32},{0,9,160},\n+        {0,8,0},{0,8,128},{0,8,64},{0,9,224},{128,7,6},{0,8,88},\n+        {0,8,24},{0,9,144},{131,7,59},{0,8,120},{0,8,56},{0,9,208},\n+        {129,7,17},{0,8,104},{0,8,40},{0,9,176},{0,8,8},{0,8,136},\n+        {0,8,72},{0,9,240},{128,7,4},{0,8,84},{0,8,20},{133,8,227},\n+        {131,7,43},{0,8,116},{0,8,52},{0,9,200},{129,7,13},{0,8,100},\n+        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},\n+        {128,7,8},{0,8,92},{0,8,28},{0,9,152},{132,7,83},{0,8,124},\n+        {0,8,60},{0,9,216},{130,7,23},{0,8,108},{0,8,44},{0,9,184},\n+        {0,8,12},{0,8,140},{0,8,76},{0,9,248},{128,7,3},{0,8,82},\n+        {0,8,18},{133,8,163},{131,7,35},{0,8,114},{0,8,50},{0,9,196},\n+        {129,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},{0,8,130},\n+        {0,8,66},{0,9,228},{128,7,7},{0,8,90},{0,8,26},{0,9,148},\n+        {132,7,67},{0,8,122},{0,8,58},{0,9,212},{130,7,19},{0,8,106},\n+        {0,8,42},{0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},\n+        {128,7,5},{0,8,86},{0,8,22},{65,8,0},{131,7,51},{0,8,118},\n+        {0,8,54},{0,9,204},{129,7,15},{0,8,102},{0,8,38},{0,9,172},\n+        {0,8,6},{0,8,134},{0,8,70},{0,9,236},{128,7,9},{0,8,94},\n+        {0,8,30},{0,9,156},{132,7,99},{0,8,126},{0,8,62},{0,9,220},\n+        {130,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},\n+        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{133,8,131},\n+        {130,7,31},{0,8,113},{0,8,49},{0,9,194},{128,7,10},{0,8,97},\n+        {0,8,33},{0,9,162},{0,8,1},{0,8,129},{0,8,65},{0,9,226},\n+        {128,7,6},{0,8,89},{0,8,25},{0,9,146},{131,7,59},{0,8,121},\n+        {0,8,57},{0,9,210},{129,7,17},{0,8,105},{0,8,41},{0,9,178},\n+        {0,8,9},{0,8,137},{0,8,73},{0,9,242},{128,7,4},{0,8,85},\n+        {0,8,21},{144,8,3},{131,7,43},{0,8,117},{0,8,53},{0,9,202},\n+        {129,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},\n+        {0,8,69},{0,9,234},{128,7,8},{0,8,93},{0,8,29},{0,9,154},\n+        {132,7,83},{0,8,125},{0,8,61},{0,9,218},{130,7,23},{0,8,109},\n+        {0,8,45},{0,9,186},{0,8,13},{0,8,141},{0,8,77},{0,9,250},\n+        {128,7,3},{0,8,83},{0,8,19},{133,8,195},{131,7,35},{0,8,115},\n+        {0,8,51},{0,9,198},{129,7,11},{0,8,99},{0,8,35},{0,9,166},\n+        {0,8,3},{0,8,131},{0,8,67},{0,9,230},{128,7,7},{0,8,91},\n+        {0,8,27},{0,9,150},{132,7,67},{0,8,123},{0,8,59},{0,9,214},\n+        {130,7,19},{0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},\n+        {0,8,75},{0,9,246},{128,7,5},{0,8,87},{0,8,23},{77,8,0},\n+        {131,7,51},{0,8,119},{0,8,55},{0,9,206},{129,7,15},{0,8,103},\n+        {0,8,39},{0,9,174},{0,8,7},{0,8,135},{0,8,71},{0,9,238},\n+        {128,7,9},{0,8,95},{0,8,31},{0,9,158},{132,7,99},{0,8,127},\n+        {0,8,63},{0,9,222},{130,7,27},{0,8,111},{0,8,47},{0,9,190},\n+        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},\n+        {0,8,16},{132,8,115},{130,7,31},{0,8,112},{0,8,48},{0,9,193},\n+        {128,7,10},{0,8,96},{0,8,32},{0,9,161},{0,8,0},{0,8,128},\n+        {0,8,64},{0,9,225},{128,7,6},{0,8,88},{0,8,24},{0,9,145},\n+        {131,7,59},{0,8,120},{0,8,56},{0,9,209},{129,7,17},{0,8,104},\n+        {0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},{0,9,241},\n+        {128,7,4},{0,8,84},{0,8,20},{133,8,227},{131,7,43},{0,8,116},\n+        {0,8,52},{0,9,201},{129,7,13},{0,8,100},{0,8,36},{0,9,169},\n+        {0,8,4},{0,8,132},{0,8,68},{0,9,233},{128,7,8},{0,8,92},\n+        {0,8,28},{0,9,153},{132,7,83},{0,8,124},{0,8,60},{0,9,217},\n+        {130,7,23},{0,8,108},{0,8,44},{0,9,185},{0,8,12},{0,8,140},\n+        {0,8,76},{0,9,249},{128,7,3},{0,8,82},{0,8,18},{133,8,163},\n+        {131,7,35},{0,8,114},{0,8,50},{0,9,197},{129,7,11},{0,8,98},\n+        {0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},\n+        {128,7,7},{0,8,90},{0,8,26},{0,9,149},{132,7,67},{0,8,122},\n+        {0,8,58},{0,9,213},{130,7,19},{0,8,106},{0,8,42},{0,9,181},\n+        {0,8,10},{0,8,138},{0,8,74},{0,9,245},{128,7,5},{0,8,86},\n+        {0,8,22},{65,8,0},{131,7,51},{0,8,118},{0,8,54},{0,9,205},\n+        {129,7,15},{0,8,102},{0,8,38},{0,9,173},{0,8,6},{0,8,134},\n+        {0,8,70},{0,9,237},{128,7,9},{0,8,94},{0,8,30},{0,9,157},\n+        {132,7,99},{0,8,126},{0,8,62},{0,9,221},{130,7,27},{0,8,110},\n+        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},\n+        {96,7,0},{0,8,81},{0,8,17},{133,8,131},{130,7,31},{0,8,113},\n+        {0,8,49},{0,9,195},{128,7,10},{0,8,97},{0,8,33},{0,9,163},\n+        {0,8,1},{0,8,129},{0,8,65},{0,9,227},{128,7,6},{0,8,89},\n+        {0,8,25},{0,9,147},{131,7,59},{0,8,121},{0,8,57},{0,9,211},\n+        {129,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},{0,8,137},\n+        {0,8,73},{0,9,243},{128,7,4},{0,8,85},{0,8,21},{144,8,3},\n+        {131,7,43},{0,8,117},{0,8,53},{0,9,203},{129,7,13},{0,8,101},\n+        {0,8,37},{0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},\n+        {128,7,8},{0,8,93},{0,8,29},{0,9,155},{132,7,83},{0,8,125},\n+        {0,8,61},{0,9,219},{130,7,23},{0,8,109},{0,8,45},{0,9,187},\n+        {0,8,13},{0,8,141},{0,8,77},{0,9,251},{128,7,3},{0,8,83},\n+        {0,8,19},{133,8,195},{131,7,35},{0,8,115},{0,8,51},{0,9,199},\n+        {129,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},\n+        {0,8,67},{0,9,231},{128,7,7},{0,8,91},{0,8,27},{0,9,151},\n+        {132,7,67},{0,8,123},{0,8,59},{0,9,215},{130,7,19},{0,8,107},\n+        {0,8,43},{0,9,183},{0,8,11},{0,8,139},{0,8,75},{0,9,247},\n+        {128,7,5},{0,8,87},{0,8,23},{77,8,0},{131,7,51},{0,8,119},\n+        {0,8,55},{0,9,207},{129,7,15},{0,8,103},{0,8,39},{0,9,175},\n+        {0,8,7},{0,8,135},{0,8,71},{0,9,239},{128,7,9},{0,8,95},\n+        {0,8,31},{0,9,159},{132,7,99},{0,8,127},{0,8,63},{0,9,223},\n+        {130,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},\n+        {0,8,79},{0,9,255}\n+    };\n+\n+    static const code distfix[32] = {\n+        {128,5,1},{135,5,257},{131,5,17},{139,5,4097},{129,5,5},\n+        {137,5,1025},{133,5,65},{141,5,16385},{128,5,3},{136,5,513},\n+        {132,5,33},{140,5,8193},{130,5,9},{138,5,2049},{134,5,129},\n+        {142,5,32769},{128,5,2},{135,5,385},{131,5,25},{139,5,6145},\n+        {129,5,7},{137,5,1537},{133,5,97},{141,5,24577},{128,5,4},\n+        {136,5,769},{132,5,49},{140,5,12289},{130,5,13},{138,5,3073},\n+        {134,5,193},{142,5,49153}\n+    };"}, {"sha": "ee9a79394b6dc9595c2f4d26e4b394d9656e3ecc", "filename": "zlib/contrib/infback9/inflate9.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finfback9%2Finflate9.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finfback9%2Finflate9.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finfback9%2Finflate9.h?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,47 @@\n+/* inflate9.h -- internal inflate state definition\n+ * Copyright (C) 1995-2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ */\n+\n+/* WARNING: this file should *not* be used by applications. It is\n+   part of the implementation of the compression library and is\n+   subject to change. Applications should only use zlib.h.\n+ */\n+\n+/* Possible inflate modes between inflate() calls */\n+typedef enum {\n+        TYPE,       /* i: waiting for type bits, including last-flag bit */\n+        STORED,     /* i: waiting for stored size (length and complement) */\n+        TABLE,      /* i: waiting for dynamic block table lengths */\n+            LEN,        /* i: waiting for length/lit code */\n+    DONE,       /* finished check, done -- remain here until reset */\n+    BAD         /* got a data error -- remain here until reset */\n+} inflate_mode;\n+\n+/*\n+    State transitions between above modes -\n+\n+    (most modes can go to the BAD mode -- not shown for clarity)\n+\n+    Read deflate blocks:\n+            TYPE -> STORED or TABLE or LEN or DONE\n+            STORED -> TYPE\n+            TABLE -> LENLENS -> CODELENS -> LEN\n+    Read deflate codes:\n+                LEN -> LEN or TYPE\n+ */\n+\n+/* state maintained between inflate() calls.  Approximately 7K bytes. */\n+struct inflate_state {\n+        /* sliding window */\n+    unsigned char FAR *window;  /* allocated sliding window, if needed */\n+        /* dynamic table building */\n+    unsigned ncode;             /* number of code length code lengths */\n+    unsigned nlen;              /* number of length code lengths */\n+    unsigned ndist;             /* number of distance code lengths */\n+    unsigned have;              /* number of code lengths in lens[] */\n+    code FAR *next;             /* next available space in codes[] */\n+    unsigned short lens[320];   /* temporary storage for code lengths */\n+    unsigned short work[288];   /* work area for code table building */\n+    code codes[ENOUGH];         /* space for code tables */\n+};"}, {"sha": "fe76a1b1cd87135329cf5cba4cc06fbb4f55fa4a", "filename": "zlib/contrib/infback9/inftree9.c", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finfback9%2Finftree9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finfback9%2Finftree9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finfback9%2Finftree9.c?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,323 @@\n+/* inftree9.c -- generate Huffman trees for efficient decoding\n+ * Copyright (C) 1995-2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ */\n+\n+#include \"zutil.h\"\n+#include \"inftree9.h\"\n+\n+#define MAXBITS 15\n+\n+const char inflate9_copyright[] =\n+   \" inflate9 1.2.1 Copyright 1995-2003 Mark Adler \";\n+/*\n+  If you use the zlib library in a product, an acknowledgment is welcome\n+  in the documentation of your product. If for some reason you cannot\n+  include such an acknowledgment, I would appreciate that you keep this\n+  copyright string in the executable of your product.\n+ */\n+\n+/*\n+   Build a set of tables to decode the provided canonical Huffman code.\n+   The code lengths are lens[0..codes-1].  The result starts at *table,\n+   whose indices are 0..2^bits-1.  work is a writable array of at least\n+   lens shorts, which is used as a work area.  type is the type of code\n+   to be generated, CODES, LENS, or DISTS.  On return, zero is success,\n+   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table\n+   on return points to the next available entry's address.  bits is the\n+   requested root table index bits, and on return it is the actual root\n+   table index bits.  It will differ if the request is greater than the\n+   longest code or if it is less than the shortest code.\n+ */\n+int inflate_table9(type, lens, codes, table, bits, work)\n+codetype type;\n+unsigned short FAR *lens;\n+unsigned codes;\n+code FAR * FAR *table;\n+unsigned FAR *bits;\n+unsigned short FAR *work;\n+{\n+    unsigned len;               /* a code's length in bits */\n+    unsigned sym;               /* index of code symbols */\n+    unsigned min, max;          /* minimum and maximum code lengths */\n+    unsigned root;              /* number of index bits for root table */\n+    unsigned curr;              /* number of index bits for current table */\n+    unsigned drop;              /* code bits to drop for sub-table */\n+    int left;                   /* number of prefix codes available */\n+    unsigned used;              /* code entries in table used */\n+    unsigned huff;              /* Huffman code */\n+    unsigned incr;              /* for incrementing code, index */\n+    unsigned fill;              /* index for replicating entries */\n+    unsigned low;               /* low bits for current root entry */\n+    unsigned mask;              /* mask for low root bits */\n+    code this;                  /* table entry for duplication */\n+    code FAR *next;             /* next available space in table */\n+    const unsigned short FAR *base;     /* base value table to use */\n+    const unsigned short FAR *extra;    /* extra bits table to use */\n+    int end;                    /* use base and extra for symbol > end */\n+    unsigned short count[MAXBITS+1];    /* number of codes of each length */\n+    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */\n+    static const unsigned short lbase[31] = { /* Length codes 257..285 base */\n+        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17,\n+        19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115,\n+        131, 163, 195, 227, 3, 0, 0};\n+    static const unsigned short lext[31] = { /* Length codes 257..285 extra */\n+        128, 128, 128, 128, 128, 128, 128, 128, 129, 129, 129, 129,\n+        130, 130, 130, 130, 131, 131, 131, 131, 132, 132, 132, 132,\n+        133, 133, 133, 133, 144, 76, 66};\n+    static const unsigned short dbase[32] = { /* Distance codes 0..31 base */\n+        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49,\n+        65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073,\n+        4097, 6145, 8193, 12289, 16385, 24577, 32769, 49153};\n+    static const unsigned short dext[32] = { /* Distance codes 0..31 extra */\n+        128, 128, 128, 128, 129, 129, 130, 130, 131, 131, 132, 132,\n+        133, 133, 134, 134, 135, 135, 136, 136, 137, 137, 138, 138,\n+        139, 139, 140, 140, 141, 141, 142, 142};\n+\n+    /*\n+       Process a set of code lengths to create a canonical Huffman code.  The\n+       code lengths are lens[0..codes-1].  Each length corresponds to the\n+       symbols 0..codes-1.  The Huffman code is generated by first sorting the\n+       symbols by length from short to long, and retaining the symbol order\n+       for codes with equal lengths.  Then the code starts with all zero bits\n+       for the first code of the shortest length, and the codes are integer\n+       increments for the same length, and zeros are appended as the length\n+       increases.  For the deflate format, these bits are stored backwards\n+       from their more natural integer increment ordering, and so when the\n+       decoding tables are built in the large loop below, the integer codes\n+       are incremented backwards.\n+\n+       This routine assumes, but does not check, that all of the entries in\n+       lens[] are in the range 0..MAXBITS.  The caller must assure this.\n+       1..MAXBITS is interpreted as that code length.  zero means that that\n+       symbol does not occur in this code.\n+\n+       The codes are sorted by computing a count of codes for each length,\n+       creating from that a table of starting indices for each length in the\n+       sorted table, and then entering the symbols in order in the sorted\n+       table.  The sorted table is work[], with that space being provided by\n+       the caller.\n+\n+       The length counts are used for other purposes as well, i.e. finding\n+       the minimum and maximum length codes, determining if there are any\n+       codes at all, checking for a valid set of lengths, and looking ahead\n+       at length counts to determine sub-table sizes when building the\n+       decoding tables.\n+     */\n+\n+    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n+    for (len = 0; len <= MAXBITS; len++)\n+        count[len] = 0;\n+    for (sym = 0; sym < codes; sym++)\n+        count[lens[sym]]++;\n+\n+    /* bound code lengths, force root to be within code lengths */\n+    root = *bits;\n+    for (max = MAXBITS; max >= 1; max--)\n+        if (count[max] != 0) break;\n+    if (root > max) root = max;\n+    if (max == 0) return -1;            /* no codes! */\n+    for (min = 1; min <= MAXBITS; min++)\n+        if (count[min] != 0) break;\n+    if (root < min) root = min;\n+\n+    /* check for an over-subscribed or incomplete set of lengths */\n+    left = 1;\n+    for (len = 1; len <= MAXBITS; len++) {\n+        left <<= 1;\n+        left -= count[len];\n+        if (left < 0) return -1;        /* over-subscribed */\n+    }\n+    if (left > 0 && (type == CODES || (codes - count[0] != 1)))\n+        return -1;                      /* incomplete set */\n+\n+    /* generate offsets into symbol table for each length for sorting */\n+    offs[1] = 0;\n+    for (len = 1; len < MAXBITS; len++)\n+        offs[len + 1] = offs[len] + count[len];\n+\n+    /* sort symbols by length, by symbol order within each length */\n+    for (sym = 0; sym < codes; sym++)\n+        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;\n+\n+    /*\n+       Create and fill in decoding tables.  In this loop, the table being\n+       filled is at next and has curr index bits.  The code being used is huff\n+       with length len.  That code is converted to an index by dropping drop\n+       bits off of the bottom.  For codes where len is less than drop + curr,\n+       those top drop + curr - len bits are incremented through all values to\n+       fill the table with replicated entries.\n+\n+       root is the number of index bits for the root table.  When len exceeds\n+       root, sub-tables are created pointed to by the root entry with an index\n+       of the low root bits of huff.  This is saved in low to check for when a\n+       new sub-table should be started.  drop is zero when the root table is\n+       being filled, and drop is root when sub-tables are being filled.\n+\n+       When a new sub-table is needed, it is necessary to look ahead in the\n+       code lengths to determine what size sub-table is needed.  The length\n+       counts are used for this, and so count[] is decremented as codes are\n+       entered in the tables.\n+\n+       used keeps track of how many table entries have been allocated from the\n+       provided *table space.  It is checked when a LENS table is being made\n+       against the space in *table, ENOUGH, minus the maximum space needed by\n+       the worst case distance code, MAXD.  This should never happen, but the\n+       sufficiency of ENOUGH has not been proven exhaustively, hence the check.\n+       This assumes that when type == LENS, bits == 9.\n+\n+       sym increments through all symbols, and the loop terminates when\n+       all codes of length max, i.e. all codes, have been processed.  This\n+       routine permits incomplete codes, so another loop after this one fills\n+       in the rest of the decoding tables with invalid code markers.\n+     */\n+\n+    /* set up for code type */\n+    switch (type) {\n+    case CODES:\n+        base = extra = work;    /* dummy value--not used */\n+        end = 19;\n+        break;\n+    case LENS:\n+        base = lbase;\n+        base -= 257;\n+        extra = lext;\n+        extra -= 257;\n+        end = 256;\n+        break;\n+    default:            /* DISTS */\n+        base = dbase;\n+        extra = dext;\n+        end = -1;\n+    }\n+\n+    /* initialize state for loop */\n+    huff = 0;                   /* starting code */\n+    sym = 0;                    /* starting code symbol */\n+    len = min;                  /* starting code length */\n+    next = *table;              /* current table to fill in */\n+    curr = root;                /* current table index bits */\n+    drop = 0;                   /* current bits to drop from code for index */\n+    low = (unsigned)(-1);       /* trigger new sub-table when len > root */\n+    used = 1U << root;          /* use root table entries */\n+    mask = used - 1;            /* mask for comparing low */\n+\n+    /* check available table space */\n+    if (type == LENS && used >= ENOUGH - MAXD)\n+        return 1;\n+\n+    /* process all codes and make table entries */\n+    for (;;) {\n+        /* create table entry */\n+        this.bits = (unsigned char)(len - drop);\n+        if ((int)(work[sym]) < end) {\n+            this.op = (unsigned char)0;\n+            this.val = work[sym];\n+        }\n+        else if ((int)(work[sym]) > end) {\n+            this.op = (unsigned char)(extra[work[sym]]);\n+            this.val = base[work[sym]];\n+        }\n+        else {\n+            this.op = (unsigned char)(32 + 64);         /* end of block */\n+            this.val = 0;\n+        }\n+\n+        /* replicate for those indices with low len bits equal to huff */\n+        incr = 1U << (len - drop);\n+        fill = 1U << curr;\n+        do {\n+            fill -= incr;\n+            next[(huff >> drop) + fill] = this;\n+        } while (fill != 0);\n+\n+        /* backwards increment the len-bit code huff */\n+        incr = 1U << (len - 1);\n+        while (huff & incr)\n+            incr >>= 1;\n+        if (incr != 0) {\n+            huff &= incr - 1;\n+            huff += incr;\n+        }\n+        else\n+            huff = 0;\n+\n+        /* go to next symbol, update count, len */\n+        sym++;\n+        if (--(count[len]) == 0) {\n+            if (len == max) break;\n+            len = lens[work[sym]];\n+        }\n+\n+        /* create new sub-table if needed */\n+        if (len > root && (huff & mask) != low) {\n+            /* if first time, transition to sub-tables */\n+            if (drop == 0)\n+                drop = root;\n+\n+            /* increment past last table */\n+            next += 1U << curr;\n+\n+            /* determine length of next table */\n+            curr = len - drop;\n+            left = (int)(1 << curr);\n+            while (curr + drop < max) {\n+                left -= count[curr + drop];\n+                if (left <= 0) break;\n+                curr++;\n+                left <<= 1;\n+            }\n+\n+            /* check for enough space */\n+            used += 1U << curr;\n+            if (type == LENS && used >= ENOUGH - MAXD)\n+                return 1;\n+\n+            /* point entry in root table to sub-table */\n+            low = huff & mask;\n+            (*table)[low].op = (unsigned char)curr;\n+            (*table)[low].bits = (unsigned char)root;\n+            (*table)[low].val = (unsigned short)(next - *table);\n+        }\n+    }\n+\n+    /*\n+       Fill in rest of table for incomplete codes.  This loop is similar to the\n+       loop above in incrementing huff for table indices.  It is assumed that\n+       len is equal to curr + drop, so there is no loop needed to increment\n+       through high index bits.  When the current sub-table is filled, the loop\n+       drops back to the root table to fill in any remaining entries there.\n+     */\n+    this.op = (unsigned char)64;                /* invalid code marker */\n+    this.bits = (unsigned char)(len - drop);\n+    this.val = (unsigned short)0;\n+    while (huff != 0) {\n+        /* when done with sub-table, drop back to root table */\n+        if (drop != 0 && (huff & mask) != low) {\n+            drop = 0;\n+            len = root;\n+            next = *table;\n+            curr = root;\n+            this.bits = (unsigned char)len;\n+        }\n+\n+        /* put invalid code marker in table */\n+        next[huff >> drop] = this;\n+\n+        /* backwards increment the len-bit code huff */\n+        incr = 1U << (len - 1);\n+        while (huff & incr)\n+            incr >>= 1;\n+        if (incr != 0) {\n+            huff &= incr - 1;\n+            huff += incr;\n+        }\n+        else\n+            huff = 0;\n+    }\n+\n+    /* set return parameters */\n+    *table += used;\n+    *bits = root;\n+    return 0;\n+}"}, {"sha": "6a699a798f5a80fc9716714013a8d98c0e659182", "filename": "zlib/contrib/infback9/inftree9.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finfback9%2Finftree9.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finfback9%2Finftree9.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finfback9%2Finftree9.h?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,55 @@\n+/* inftree9.h -- header to use inftree9.c\n+ * Copyright (C) 1995-2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ */\n+\n+/* WARNING: this file should *not* be used by applications. It is\n+   part of the implementation of the compression library and is\n+   subject to change. Applications should only use zlib.h.\n+ */\n+\n+/* Structure for decoding tables.  Each entry provides either the\n+   information needed to do the operation requested by the code that\n+   indexed that table entry, or it provides a pointer to another\n+   table that indexes more bits of the code.  op indicates whether\n+   the entry is a pointer to another table, a literal, a length or\n+   distance, an end-of-block, or an invalid code.  For a table\n+   pointer, the low four bits of op is the number of index bits of\n+   that table.  For a length or distance, the low four bits of op\n+   is the number of extra bits to get after the code.  bits is\n+   the number of bits in this code or part of the code to drop off\n+   of the bit buffer.  val is the actual byte to output in the case\n+   of a literal, the base length or distance, or the offset from\n+   the current table to the next table.  Each entry is four bytes. */\n+typedef struct {\n+    unsigned char op;           /* operation, extra bits, table bits */\n+    unsigned char bits;         /* bits in this part of the code */\n+    unsigned short val;         /* offset in table or code value */\n+} code;\n+\n+/* op values as set by inflate_table():\n+    00000000 - literal\n+    0000tttt - table link, tttt != 0 is the number of table index bits\n+    100eeeee - length or distance, eeee is the number of extra bits\n+    01100000 - end of block\n+    01000000 - invalid code\n+ */\n+\n+/* Maximum size of dynamic tree.  The maximum found in a long but non-\n+   exhaustive search was 1004 code structures (850 for length/literals\n+   and 154 for distances, the latter actually the result of an\n+   exhaustive search).  The true maximum is not known, but the value\n+   below is more than safe. */\n+#define ENOUGH 1440\n+#define MAXD 154\n+\n+/* Type of code to build for inftable() */\n+typedef enum {\n+    CODES,\n+    LENS,\n+    DISTS\n+} codetype;\n+\n+extern int inflate_table9 OF((codetype type, unsigned short FAR *lens,\n+                             unsigned codes, code FAR * FAR *table,\n+                             unsigned FAR *bits, unsigned short FAR *work));"}, {"sha": "4534693a47d23232f65fc200edb9c86aa4d1616c", "filename": "zlib/contrib/inflate86/inffas86.c", "status": "added", "additions": 783, "deletions": 0, "changes": 783, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finflate86%2Finffas86.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finflate86%2Finffas86.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finflate86%2Finffas86.c?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,783 @@\n+/* inffas86.c is a hand tuned assembler version of\n+ *\n+ * inffast.c -- fast decoding\n+ * Copyright (C) 1995-2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ *\n+ * Copyright (C) 2003 Chris Anderson <christop@charm.net>\n+ * Please use the copyright conditions above.\n+ *\n+ * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from\n+ * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at\n+ * the moment.  I have successfully compiled and tested this code with gcc2.96,\n+ * gcc3.2, icc5.0, msvc6.0.  It is very close to the speed of inffast.S\n+ * compiled with gcc -DNO_MMX, but inffast.S is still faster on the P3 with MMX\n+ * enabled.  I will attempt to merge the MMX code into this version.  Newer\n+ * versions of this and inffast.S can be found at\n+ * http://www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/\n+ */\n+\n+#include \"zutil.h\"\n+#include \"inftrees.h\"\n+#include \"inflate.h\"\n+#include \"inffast.h\"\n+\n+/* Mark Adler's comments from inffast.c: */\n+\n+/*\n+   Decode literal, length, and distance codes and write out the resulting\n+   literal and match bytes until either not enough input or output is\n+   available, an end-of-block is encountered, or a data error is encountered.\n+   When large enough input and output buffers are supplied to inflate(), for\n+   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n+   inflate execution time is spent in this routine.\n+\n+   Entry assumptions:\n+\n+        state->mode == LEN\n+        strm->avail_in >= 6\n+        strm->avail_out >= 258\n+        start >= strm->avail_out\n+        state->bits < 8\n+\n+   On return, state->mode is one of:\n+\n+        LEN -- ran out of enough output space or enough available input\n+        TYPE -- reached end of block code, inflate() to interpret next block\n+        BAD -- error in block data\n+\n+   Notes:\n+\n+    - The maximum input bits used by a length/distance pair is 15 bits for the\n+      length code, 5 bits for the length extra, 15 bits for the distance code,\n+      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n+      Therefore if strm->avail_in >= 6, then there is enough input to avoid\n+      checking for available input while decoding.\n+\n+    - The maximum bytes that a single length/distance pair can output is 258\n+      bytes, which is the maximum length that can be coded.  inflate_fast()\n+      requires strm->avail_out >= 258 for each loop to avoid checking for\n+      output space.\n+ */\n+void inflate_fast(strm, start)\n+z_streamp strm;\n+unsigned start;         /* inflate()'s starting value for strm->avail_out */\n+{\n+    struct inflate_state FAR *state;\n+    struct inffast_ar {\n+      void *esp;                  /* esp save */\n+      unsigned char FAR *in;      /* local strm->next_in */\n+      unsigned char FAR *last;    /* while in < last, enough input available */\n+      unsigned char FAR *out;     /* local strm->next_out */\n+      unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */\n+      unsigned char FAR *end;     /* while out < end, enough space available */\n+      unsigned wsize;             /* window size or zero if not using window */\n+      unsigned write;             /* window write index */\n+      unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */\n+      unsigned long hold;         /* local strm->hold */\n+      unsigned bits;              /* local strm->bits */\n+      code const FAR *lcode;      /* local strm->lencode */\n+      code const FAR *dcode;      /* local strm->distcode */\n+      unsigned lmask;             /* mask for first level of length codes */\n+      unsigned dmask;             /* mask for first level of distance codes */\n+      unsigned len;               /* match length, unused bytes */\n+      unsigned dist;              /* match distance */\n+      unsigned status;            /* this is set when state changes */\n+    } ar;\n+\n+    /* copy state to local variables */\n+    state = (struct inflate_state FAR *)strm->state;\n+    ar.in = strm->next_in;\n+    ar.last = ar.in + (strm->avail_in - 5);\n+    ar.out = strm->next_out;\n+    ar.beg = ar.out - (start - strm->avail_out);\n+    ar.end = ar.out + (strm->avail_out - 257);\n+    ar.wsize = state->wsize;\n+    ar.write = state->write;\n+    ar.window = state->window;\n+    ar.hold = state->hold;\n+    ar.bits = state->bits;\n+    ar.lcode = state->lencode;\n+    ar.dcode = state->distcode;\n+    ar.lmask = (1U << state->lenbits) - 1;\n+    ar.dmask = (1U << state->distbits) - 1;\n+\n+    /* decode literals and length/distances until end-of-block or not enough\n+       input data or output space */\n+\n+    /* align in on 2 byte boundary */\n+    if (((unsigned long)(void *)ar.in & 0x1) != 0) {\n+        ar.hold += (unsigned long)*ar.in++ << ar.bits;\n+        ar.bits += 8;\n+    }\n+\n+#if defined( __GNUC__ ) || defined( __ICC )\n+    __asm__ __volatile__ (\n+\"        leal    %0, %%eax\\n\"\n+\"        pushf\\n\"\n+\"        pushl   %%ebp\\n\"\n+\"        movl    %%esp, (%%eax)\\n\"\n+\"        movl    %%eax, %%esp\\n\"\n+\"        movl    4(%%esp), %%esi\\n\"       /* esi = in */\n+\"        movl    12(%%esp), %%edi\\n\"      /* edi = out */\n+\"        movl    36(%%esp), %%edx\\n\"      /* edx = hold */\n+\"        movl    40(%%esp), %%ebx\\n\"      /* ebx = bits */\n+\"        movl    44(%%esp), %%ebp\\n\"      /* ebp = lcode */\n+\n+\"        cld\\n\"\n+\"        jmp     .L_do_loop\\n\"\n+\n+\".L_while_test:\\n\"\n+\"        cmpl    %%edi, 20(%%esp)\\n\"\n+\"        jbe     .L_break_loop\\n\"\n+\"        cmpl    %%esi, 8(%%esp)\\n\"\n+\"        jbe     .L_break_loop\\n\"\n+\n+\".L_do_loop:\\n\"\n+\"        cmpb    $15, %%bl\\n\"\n+\"        ja      .L_get_length_code\\n\"    /* if (15 < bits) */\n+\n+\"        xorl    %%eax, %%eax\\n\"\n+\"        lodsw\\n\"                         /* al = *(ushort *)in++ */\n+\"        movb    %%bl, %%cl\\n\"            /* cl = bits, needs it for shifting */\n+\"        addb    $16, %%bl\\n\"             /* bits += 16 */\n+\"        shll    %%cl, %%eax\\n\"\n+\"        orl     %%eax, %%edx\\n\"        /* hold |= *((ushort *)in)++ << bits */\n+\n+\".L_get_length_code:\\n\"\n+\"        movl    52(%%esp), %%eax\\n\"      /* eax = lmask */\n+\"        andl    %%edx, %%eax\\n\"          /* eax &= hold */\n+\"        movl    (%%ebp,%%eax,4), %%eax\\n\" /* eax = lcode[hold & lmask] */\n+\n+\".L_dolen:\\n\"\n+\"        movb    %%ah, %%cl\\n\"            /* cl = this.bits */\n+\"        subb    %%ah, %%bl\\n\"            /* bits -= this.bits */\n+\"        shrl    %%cl, %%edx\\n\"           /* hold >>= this.bits */\n+\n+\"        testb   %%al, %%al\\n\"\n+\"        jnz     .L_test_for_length_base\\n\" /* if (op != 0) 45.7% */\n+\n+\"        shrl    $16, %%eax\\n\"            /* output this.val char */\n+\"        stosb\\n\"\n+\"        jmp     .L_while_test\\n\"\n+\n+\".L_test_for_length_base:\\n\"\n+\"        movl    %%eax, %%ecx\\n\"          /* len = this */\n+\"        shrl    $16, %%ecx\\n\"            /* len = this.val */\n+\"        movl    %%ecx, 60(%%esp)\\n\"      /* len = this */\n+\"        movb    %%al, %%cl\\n\"\n+\n+\"        testb   $16, %%al\\n\"\n+\"        jz      .L_test_for_second_level_length\\n\" /* if ((op & 16) == 0) 8% */\n+\"        andb    $15, %%cl\\n\"             /* op &= 15 */\n+\"        jz      .L_decode_distance\\n\"    /* if (!op) */\n+\"        cmpb    %%cl, %%bl\\n\"\n+\"        jae     .L_add_bits_to_len\\n\"    /* if (op <= bits) */\n+\n+\"        movb    %%cl, %%ch\\n\"            /* stash op in ch, freeing cl */\n+\"        xorl    %%eax, %%eax\\n\"\n+\"        lodsw\\n\"                         /* al = *(ushort *)in++ */\n+\"        movb    %%bl, %%cl\\n\"            /* cl = bits, needs it for shifting */\n+\"        addb    $16, %%bl\\n\"             /* bits += 16 */\n+\"        shll    %%cl, %%eax\\n\"\n+\"        orl     %%eax, %%edx\\n\"         /* hold |= *((ushort *)in)++ << bits */\n+\"        movb    %%ch, %%cl\\n\"            /* move op back to ecx */\n+\n+\".L_add_bits_to_len:\\n\"\n+\"        movl    $1, %%eax\\n\"\n+\"        shll    %%cl, %%eax\\n\"\n+\"        decl    %%eax\\n\"\n+\"        subb    %%cl, %%bl\\n\"\n+\"        andl    %%edx, %%eax\\n\"          /* eax &= hold */\n+\"        shrl    %%cl, %%edx\\n\"\n+\"        addl    %%eax, 60(%%esp)\\n\"      /* len += hold & mask[op] */\n+\n+\".L_decode_distance:\\n\"\n+\"        cmpb    $15, %%bl\\n\"\n+\"        ja      .L_get_distance_code\\n\"  /* if (15 < bits) */\n+\n+\"        xorl    %%eax, %%eax\\n\"\n+\"        lodsw\\n\"                         /* al = *(ushort *)in++ */\n+\"        movb    %%bl, %%cl\\n\"            /* cl = bits, needs it for shifting */\n+\"        addb    $16, %%bl\\n\"             /* bits += 16 */\n+\"        shll    %%cl, %%eax\\n\"\n+\"        orl     %%eax, %%edx\\n\"         /* hold |= *((ushort *)in)++ << bits */\n+\n+\".L_get_distance_code:\\n\"\n+\"        movl    56(%%esp), %%eax\\n\"      /* eax = dmask */\n+\"        movl    48(%%esp), %%ecx\\n\"      /* ecx = dcode */\n+\"        andl    %%edx, %%eax\\n\"          /* eax &= hold */\n+\"        movl    (%%ecx,%%eax,4), %%eax\\n\"/* eax = dcode[hold & dmask] */\n+\n+\".L_dodist:\\n\"\n+\"        movl    %%eax, %%ebp\\n\"          /* dist = this */\n+\"        shrl    $16, %%ebp\\n\"            /* dist = this.val */\n+\"        movb    %%ah, %%cl\\n\"\n+\"        subb    %%ah, %%bl\\n\"            /* bits -= this.bits */\n+\"        shrl    %%cl, %%edx\\n\"           /* hold >>= this.bits */\n+\"        movb    %%al, %%cl\\n\"            /* cl = this.op */\n+\n+\"        testb   $16, %%al\\n\"             /* if ((op & 16) == 0) */\n+\"        jz      .L_test_for_second_level_dist\\n\"\n+\"        andb    $15, %%cl\\n\"             /* op &= 15 */\n+\"        jz      .L_check_dist_one\\n\"\n+\"        cmpb    %%cl, %%bl\\n\"\n+\"        jae     .L_add_bits_to_dist\\n\"   /* if (op <= bits) 97.6% */\n+\n+\"        movb    %%cl, %%ch\\n\"            /* stash op in ch, freeing cl */\n+\"        xorl    %%eax, %%eax\\n\"\n+\"        lodsw\\n\"                         /* al = *(ushort *)in++ */\n+\"        movb    %%bl, %%cl\\n\"            /* cl = bits, needs it for shifting */\n+\"        addb    $16, %%bl\\n\"             /* bits += 16 */\n+\"        shll    %%cl, %%eax\\n\"\n+\"        orl     %%eax, %%edx\\n\"        /* hold |= *((ushort *)in)++ << bits */\n+\"        movb    %%ch, %%cl\\n\"            /* move op back to ecx */\n+\n+\".L_add_bits_to_dist:\\n\"\n+\"        movl    $1, %%eax\\n\"\n+\"        shll    %%cl, %%eax\\n\"\n+\"        decl    %%eax\\n\"                 /* (1 << op) - 1 */\n+\"        subb    %%cl, %%bl\\n\"\n+\"        andl    %%edx, %%eax\\n\"          /* eax &= hold */\n+\"        shrl    %%cl, %%edx\\n\"\n+\"        addl    %%eax, %%ebp\\n\"          /* dist += hold & ((1 << op) - 1) */\n+\n+\".L_check_window:\\n\"\n+\"        movl    %%esi, 4(%%esp)\\n\"       /* save in so from can use it's reg */\n+\"        movl    %%edi, %%eax\\n\"\n+\"        subl    16(%%esp), %%eax\\n\"      /* nbytes = out - beg */\n+\n+\"        cmpl    %%ebp, %%eax\\n\"\n+\"        jb      .L_clip_window\\n\"        /* if (dist > nbytes) 4.2% */\n+\n+\"        movl    60(%%esp), %%ecx\\n\"\n+\"        movl    %%edi, %%esi\\n\"\n+\"        subl    %%ebp, %%esi\\n\"          /* from = out - dist */\n+\n+\"        subl    $3, %%ecx\\n\"             /* copy from to out */\n+\"        movb    (%%esi), %%al\\n\"\n+\"        movb    %%al, (%%edi)\\n\"\n+\"        movb    1(%%esi), %%al\\n\"\n+\"        movb    2(%%esi), %%ah\\n\"\n+\"        addl    $3, %%esi\\n\"\n+\"        movb    %%al, 1(%%edi)\\n\"\n+\"        movb    %%ah, 2(%%edi)\\n\"\n+\"        addl    $3, %%edi\\n\"\n+\"        rep     movsb\\n\"\n+\n+\"        movl    4(%%esp), %%esi\\n\"      /* move in back to %esi, toss from */\n+\"        movl    44(%%esp), %%ebp\\n\"     /* ebp = lcode */\n+\"        jmp     .L_while_test\\n\"\n+\n+\".L_check_dist_one:\\n\"\n+\"        cmpl    $1, %%ebp\\n\"            /* if dist 1, is a memset */\n+\"        jne     .L_check_window\\n\"\n+\"        cmpl    %%edi, 16(%%esp)\\n\"\n+\"        je      .L_check_window\\n\"\n+\n+\"        decl    %%edi\\n\"\n+\"        movl    60(%%esp), %%ecx\\n\"\n+\"        movb    (%%edi), %%al\\n\"\n+\"        subl    $3, %%ecx\\n\"\n+\n+\"        movb    %%al, 1(%%edi)\\n\"       /* memset out with from[-1] */\n+\"        movb    %%al, 2(%%edi)\\n\"\n+\"        movb    %%al, 3(%%edi)\\n\"\n+\"        addl    $4, %%edi\\n\"\n+\"        rep     stosb\\n\"\n+\"        movl    44(%%esp), %%ebp\\n\"      /* ebp = lcode */\n+\"        jmp     .L_while_test\\n\"\n+\n+\".L_test_for_second_level_length:\\n\"\n+\"        testb   $64, %%al\\n\"\n+\"        jnz     .L_test_for_end_of_block\\n\" /* if ((op & 64) != 0) */\n+\n+\"        movl    $1, %%eax\\n\"\n+\"        shll    %%cl, %%eax\\n\"\n+\"        decl    %%eax\\n\"\n+\"        andl    %%edx, %%eax\\n\"         /* eax &= hold */\n+\"        addl    60(%%esp), %%eax\\n\"     /* eax += this.val */\n+\"        movl    (%%ebp,%%eax,4), %%eax\\n\" /* eax = lcode[val+(hold&mask[op])]*/\n+\"        jmp     .L_dolen\\n\"\n+\n+\".L_test_for_second_level_dist:\\n\"\n+\"        testb   $64, %%al\\n\"\n+\"        jnz     .L_invalid_distance_code\\n\" /* if ((op & 64) != 0) */\n+\n+\"        movl    $1, %%eax\\n\"\n+\"        shll    %%cl, %%eax\\n\"\n+\"        decl    %%eax\\n\"\n+\"        andl    %%edx, %%eax\\n\"         /* eax &= hold */\n+\"        addl    %%ebp, %%eax\\n\"         /* eax += this.val */\n+\"        movl    48(%%esp), %%ecx\\n\"     /* ecx = dcode */\n+\"        movl    (%%ecx,%%eax,4), %%eax\\n\" /* eax = dcode[val+(hold&mask[op])]*/\n+\"        jmp     .L_dodist\\n\"\n+\n+\".L_clip_window:\\n\"\n+\"        movl    %%eax, %%ecx\\n\"\n+\"        movl    24(%%esp), %%eax\\n\"     /* prepare for dist compare */\n+\"        negl    %%ecx\\n\"                /* nbytes = -nbytes */\n+\"        movl    32(%%esp), %%esi\\n\"     /* from = window */\n+\n+\"        cmpl    %%ebp, %%eax\\n\"\n+\"        jb      .L_invalid_distance_too_far\\n\" /* if (dist > wsize) */\n+\n+\"        addl    %%ebp, %%ecx\\n\"         /* nbytes = dist - nbytes */\n+\"        cmpl    $0, 28(%%esp)\\n\"\n+\"        jne     .L_wrap_around_window\\n\" /* if (write != 0) */\n+\n+\"        subl    %%ecx, %%eax\\n\"\n+\"        addl    %%eax, %%esi\\n\"         /* from += wsize - nbytes */\n+\n+\"        movl    60(%%esp), %%eax\\n\"\n+\"        cmpl    %%ecx, %%eax\\n\"\n+\"        jbe     .L_do_copy1\\n\"          /* if (nbytes >= len) */\n+\n+\"        subl    %%ecx, %%eax\\n\"         /* len -= nbytes */\n+\"        rep     movsb\\n\"\n+\"        movl    %%edi, %%esi\\n\"\n+\"        subl    %%ebp, %%esi\\n\"         /* from = out - dist */\n+\"        jmp     .L_do_copy1\\n\"\n+\n+\"        cmpl    %%ecx, %%eax\\n\"\n+\"        jbe     .L_do_copy1\\n\"          /* if (nbytes >= len) */\n+\n+\"        subl    %%ecx, %%eax\\n\"         /* len -= nbytes */\n+\"        rep     movsb\\n\"\n+\"        movl    %%edi, %%esi\\n\"\n+\"        subl    %%ebp, %%esi\\n\"         /* from = out - dist */\n+\"        jmp     .L_do_copy1\\n\"\n+\n+\".L_wrap_around_window:\\n\"\n+\"        movl    28(%%esp), %%eax\\n\"\n+\"        cmpl    %%eax, %%ecx\\n\"\n+\"        jbe     .L_contiguous_in_window\\n\" /* if (write >= nbytes) */\n+\n+\"        addl    24(%%esp), %%esi\\n\"\n+\"        addl    %%eax, %%esi\\n\"\n+\"        subl    %%ecx, %%esi\\n\"         /* from += wsize + write - nbytes */\n+\"        subl    %%eax, %%ecx\\n\"         /* nbytes -= write */\n+\n+\"        movl    60(%%esp), %%eax\\n\"\n+\"        cmpl    %%ecx, %%eax\\n\"\n+\"        jbe     .L_do_copy1\\n\"          /* if (nbytes >= len) */\n+\n+\"        subl    %%ecx, %%eax\\n\"         /* len -= nbytes */\n+\"        rep     movsb\\n\"\n+\"        movl    32(%%esp), %%esi\\n\"     /* from = window */\n+\"        movl    28(%%esp), %%ecx\\n\"     /* nbytes = write */\n+\"        cmpl    %%ecx, %%eax\\n\"\n+\"        jbe     .L_do_copy1\\n\"          /* if (nbytes >= len) */\n+\n+\"        subl    %%ecx, %%eax\\n\"         /* len -= nbytes */\n+\"        rep     movsb\\n\"\n+\"        movl    %%edi, %%esi\\n\"\n+\"        subl    %%ebp, %%esi\\n\"         /* from = out - dist */\n+\"        jmp     .L_do_copy1\\n\"\n+\n+\".L_contiguous_in_window:\\n\"\n+\"        addl    %%eax, %%esi\\n\"\n+\"        subl    %%ecx, %%esi\\n\"         /* from += write - nbytes */\n+\n+\"        movl    60(%%esp), %%eax\\n\"\n+\"        cmpl    %%ecx, %%eax\\n\"\n+\"        jbe     .L_do_copy1\\n\"          /* if (nbytes >= len) */\n+\n+\"        subl    %%ecx, %%eax\\n\"         /* len -= nbytes */\n+\"        rep     movsb\\n\"\n+\"        movl    %%edi, %%esi\\n\"\n+\"        subl    %%ebp, %%esi\\n\"         /* from = out - dist */\n+\n+\".L_do_copy1:\\n\"\n+\"        movl    %%eax, %%ecx\\n\"\n+\"        rep     movsb\\n\"\n+\n+\"        movl    4(%%esp), %%esi\\n\"      /* move in back to %esi, toss from */\n+\"        movl    44(%%esp), %%ebp\\n\"     /* ebp = lcode */\n+\"        jmp     .L_while_test\\n\"\n+\n+\".L_test_for_end_of_block:\\n\"\n+\"        testb   $32, %%al\\n\"\n+\"        jz      .L_invalid_literal_length_code\\n\"\n+\"        movl    $1, 68(%%esp)\\n\"\n+\"        jmp     .L_break_loop_with_status\\n\"\n+\n+\".L_invalid_literal_length_code:\\n\"\n+\"        movl    $2, 68(%%esp)\\n\"\n+\"        jmp     .L_break_loop_with_status\\n\"\n+\n+\".L_invalid_distance_code:\\n\"\n+\"        movl    $3, 68(%%esp)\\n\"\n+\"        jmp     .L_break_loop_with_status\\n\"\n+\n+\".L_invalid_distance_too_far:\\n\"\n+\"        movl    4(%%esp), %%esi\\n\"\n+\"        movl    $4, 68(%%esp)\\n\"\n+\"        jmp     .L_break_loop_with_status\\n\"\n+\n+\".L_break_loop:\\n\"\n+\"        movl    $0, 68(%%esp)\\n\"\n+\n+\".L_break_loop_with_status:\\n\"\n+/* put in, out, bits, and hold back into ar and pop esp */\n+\"        movl    %%esi, 4(%%esp)\\n\"\n+\"        movl    %%edi, 12(%%esp)\\n\"\n+\"        movl    %%ebx, 40(%%esp)\\n\"\n+\"        movl    %%edx, 36(%%esp)\\n\"\n+\"        movl    (%%esp), %%esp\\n\"\n+\"        popl    %%ebp\\n\"\n+\"        popf\\n\"\n+          :\n+          : \"m\" (ar)\n+          : \"memory\", \"%eax\", \"%ebx\", \"%ecx\", \"%edx\", \"%esi\", \"%edi\"\n+    );\n+#elif defined( _MSC_VER )\n+    __asm {\n+\tlea\teax, ar\n+\tpushfd\n+\tpush\tebp\n+\tmov\t[eax], esp\n+\tmov\tesp, eax\n+\tmov\tesi, [esp+4]       /* esi = in */\n+\tmov\tedi, [esp+12]      /* edi = out */\n+\tmov\tedx, [esp+36]      /* edx = hold */\n+\tmov\tebx, [esp+40]      /* ebx = bits */\n+\tmov\tebp, [esp+44]      /* ebp = lcode */\n+\n+\tcld\n+\tjmp\tL_do_loop\n+\n+L_while_test:\n+\tcmp\t[esp+20], edi\n+\tjbe\tL_break_loop\n+\tcmp\t[esp+8], esi\n+\tjbe\tL_break_loop\n+\n+L_do_loop:\n+\tcmp\tbl, 15\n+\tja\tL_get_length_code    /* if (15 < bits) */\n+\n+\txor\teax, eax\n+\tlodsw                         /* al = *(ushort *)in++ */\n+\tmov\tcl, bl            /* cl = bits, needs it for shifting */\n+\tadd\tbl, 16             /* bits += 16 */\n+\tshl\teax, cl\n+\tor\tedx, eax        /* hold |= *((ushort *)in)++ << bits */\n+\n+L_get_length_code:\n+\tmov\teax, [esp+52]      /* eax = lmask */\n+\tand\teax, edx          /* eax &= hold */\n+\tmov\teax, [ebp+eax*4] /* eax = lcode[hold & lmask] */\n+\n+L_dolen:\n+\tmov\tcl, ah            /* cl = this.bits */\n+\tsub\tbl, ah            /* bits -= this.bits */\n+\tshr\tedx, cl           /* hold >>= this.bits */\n+\n+\ttest\tal, al\n+\tjnz\tL_test_for_length_base /* if (op != 0) 45.7% */\n+\n+\tshr\teax, 16            /* output this.val char */\n+\tstosb\n+\tjmp\tL_while_test\n+\n+L_test_for_length_base:\n+\tmov\tecx, eax          /* len = this */\n+\tshr\tecx, 16            /* len = this.val */\n+\tmov\t[esp+60], ecx      /* len = this */\n+\tmov\tcl, al\n+\n+\ttest\tal, 16\n+\tjz\tL_test_for_second_level_length /* if ((op & 16) == 0) 8% */\n+\tand\tcl, 15             /* op &= 15 */\n+\tjz\tL_decode_distance    /* if (!op) */\n+\tcmp\tbl, cl\n+\tjae\tL_add_bits_to_len    /* if (op <= bits) */\n+\n+\tmov\tch, cl            /* stash op in ch, freeing cl */\n+\txor\teax, eax\n+\tlodsw                         /* al = *(ushort *)in++ */\n+\tmov\tcl, bl            /* cl = bits, needs it for shifting */\n+\tadd\tbl, 16             /* bits += 16 */\n+\tshl\teax, cl\n+\tor\tedx, eax         /* hold |= *((ushort *)in)++ << bits */\n+\tmov\tcl, ch            /* move op back to ecx */\n+\n+L_add_bits_to_len:\n+\tmov\teax, 1\n+\tshl\teax, cl\n+\tdec\teax\n+\tsub\tbl, cl\n+\tand\teax, edx          /* eax &= hold */\n+\tshr\tedx, cl\n+\tadd\t[esp+60], eax      /* len += hold & mask[op] */\n+\n+L_decode_distance:\n+\tcmp\tbl, 15\n+\tja\tL_get_distance_code  /* if (15 < bits) */\n+\n+\txor\teax, eax\n+\tlodsw                         /* al = *(ushort *)in++ */\n+\tmov\tcl, bl            /* cl = bits, needs it for shifting */\n+\tadd\tbl, 16             /* bits += 16 */\n+\tshl\teax, cl\n+\tor\tedx, eax         /* hold |= *((ushort *)in)++ << bits */\n+\n+L_get_distance_code:\n+\tmov\teax, [esp+56]      /* eax = dmask */\n+\tmov\tecx, [esp+48]      /* ecx = dcode */\n+\tand\teax, edx          /* eax &= hold */\n+\tmov\teax, [ecx+eax*4]/* eax = dcode[hold & dmask] */\n+\n+L_dodist:\n+\tmov\tebp, eax          /* dist = this */\n+\tshr\tebp, 16            /* dist = this.val */\n+\tmov\tcl, ah\n+\tsub\tbl, ah            /* bits -= this.bits */\n+\tshr\tedx, cl           /* hold >>= this.bits */\n+\tmov\tcl, al            /* cl = this.op */\n+\n+\ttest\tal, 16             /* if ((op & 16) == 0) */\n+\tjz\tL_test_for_second_level_dist\n+\tand\tcl, 15             /* op &= 15 */\n+\tjz\tL_check_dist_one\n+\tcmp\tbl, cl\n+\tjae\tL_add_bits_to_dist   /* if (op <= bits) 97.6% */\n+\n+\tmov\tch, cl            /* stash op in ch, freeing cl */\n+\txor\teax, eax\n+\tlodsw                         /* al = *(ushort *)in++ */\n+\tmov\tcl, bl            /* cl = bits, needs it for shifting */\n+\tadd\tbl, 16             /* bits += 16 */\n+\tshl\teax, cl\n+\tor\tedx, eax        /* hold |= *((ushort *)in)++ << bits */\n+\tmov\tcl, ch            /* move op back to ecx */\n+\n+L_add_bits_to_dist:\n+\tmov\teax, 1\n+\tshl\teax, cl\n+\tdec\teax                 /* (1 << op) - 1 */\n+\tsub\tbl, cl\n+\tand\teax, edx          /* eax &= hold */\n+\tshr\tedx, cl\n+\tadd\tebp, eax          /* dist += hold & ((1 << op) - 1) */\n+\n+L_check_window:\n+\tmov\t[esp+4], esi       /* save in so from can use it's reg */\n+\tmov\teax, edi\n+\tsub\teax, [esp+16]      /* nbytes = out - beg */\n+\n+\tcmp\teax, ebp\n+\tjb\tL_clip_window        /* if (dist > nbytes) 4.2% */\n+\n+\tmov\tecx, [esp+60]\n+\tmov\tesi, edi\n+\tsub\tesi, ebp          /* from = out - dist */\n+\n+\tsub\tecx, 3             /* copy from to out */\n+\tmov\tal, [esi]\n+\tmov\t[edi], al\n+\tmov\tal, [esi+1]\n+\tmov\tah, [esi+2]\n+\tadd\tesi, 3\n+\tmov\t[edi+1], al\n+\tmov\t[edi+2], ah\n+\tadd\tedi, 3\n+\trep     movsb\n+\n+\tmov\tesi, [esp+4]      /* move in back to %esi, toss from */\n+\tmov\tebp, [esp+44]     /* ebp = lcode */\n+\tjmp\tL_while_test\n+\n+L_check_dist_one:\n+\tcmp\tebp, 1            /* if dist 1, is a memset */\n+\tjne\tL_check_window\n+\tcmp\t[esp+16], edi\n+\tje\tL_check_window\n+\n+\tdec\tedi\n+\tmov\tecx, [esp+60]\n+\tmov\tal, [edi]\n+\tsub\tecx, 3\n+\n+\tmov\t[edi+1], al       /* memset out with from[-1] */\n+\tmov\t[edi+2], al\n+\tmov\t[edi+3], al\n+\tadd\tedi, 4\n+\trep     stosb\n+\tmov\tebp, [esp+44]      /* ebp = lcode */\n+\tjmp\tL_while_test\n+\n+L_test_for_second_level_length:\n+\ttest\tal, 64\n+\tjnz\tL_test_for_end_of_block /* if ((op & 64) != 0) */\n+\n+\tmov\teax, 1\n+\tshl\teax, cl\n+\tdec\teax\n+\tand\teax, edx         /* eax &= hold */\n+\tadd\teax, [esp+60]     /* eax += this.val */\n+\tmov\teax, [ebp+eax*4] /* eax = lcode[val+(hold&mask[op])]*/\n+\tjmp\tL_dolen\n+\n+L_test_for_second_level_dist:\n+\ttest\tal, 64\n+\tjnz\tL_invalid_distance_code /* if ((op & 64) != 0) */\n+\n+\tmov\teax, 1\n+\tshl\teax, cl\n+\tdec\teax\n+\tand\teax, edx         /* eax &= hold */\n+\tadd\teax, ebp         /* eax += this.val */\n+\tmov\tecx, [esp+48]     /* ecx = dcode */\n+\tmov\teax, [ecx+eax*4] /* eax = dcode[val+(hold&mask[op])]*/\n+\tjmp\tL_dodist\n+\n+L_clip_window:\n+\tmov\tecx, eax\n+\tmov\teax, [esp+24]     /* prepare for dist compare */\n+\tneg\tecx                /* nbytes = -nbytes */\n+\tmov\tesi, [esp+32]     /* from = window */\n+\n+\tcmp\teax, ebp\n+\tjb\tL_invalid_distance_too_far /* if (dist > wsize) */\n+\n+\tadd\tecx, ebp         /* nbytes = dist - nbytes */\n+\tcmp\tdword ptr [esp+28], 0\n+\tjne\tL_wrap_around_window /* if (write != 0) */\n+\n+\tsub\teax, ecx\n+\tadd\tesi, eax         /* from += wsize - nbytes */\n+\n+\tmov\teax, [esp+60]\n+\tcmp\teax, ecx\n+\tjbe\tL_do_copy1          /* if (nbytes >= len) */\n+\n+\tsub\teax, ecx         /* len -= nbytes */\n+\trep     movsb\n+\tmov\tesi, edi\n+\tsub\tesi, ebp         /* from = out - dist */\n+\tjmp\tL_do_copy1\n+\n+\tcmp\teax, ecx\n+\tjbe\tL_do_copy1          /* if (nbytes >= len) */\n+\n+\tsub\teax, ecx         /* len -= nbytes */\n+\trep     movsb\n+\tmov\tesi, edi\n+\tsub\tesi, ebp         /* from = out - dist */\n+\tjmp\tL_do_copy1\n+\n+L_wrap_around_window:\n+\tmov\teax, [esp+28]\n+\tcmp\tecx, eax\n+\tjbe\tL_contiguous_in_window /* if (write >= nbytes) */\n+\n+\tadd\tesi, [esp+24]\n+\tadd\tesi, eax\n+\tsub\tesi, ecx         /* from += wsize + write - nbytes */\n+\tsub\tecx, eax         /* nbytes -= write */\n+\n+\tmov\teax, [esp+60]\n+\tcmp\teax, ecx\n+\tjbe\tL_do_copy1          /* if (nbytes >= len) */\n+\n+\tsub\teax, ecx         /* len -= nbytes */\n+\trep     movsb\n+\tmov\tesi, [esp+32]     /* from = window */\n+\tmov\tecx, [esp+28]     /* nbytes = write */\n+\tcmp\teax, ecx\n+\tjbe\tL_do_copy1          /* if (nbytes >= len) */\n+\n+\tsub\teax, ecx         /* len -= nbytes */\n+\trep     movsb\n+\tmov\tesi, edi\n+\tsub\tesi, ebp         /* from = out - dist */\n+\tjmp\tL_do_copy1\n+\n+L_contiguous_in_window:\n+\tadd\tesi, eax\n+\tsub\tesi, ecx         /* from += write - nbytes */\n+\n+\tmov\teax, [esp+60]\n+\tcmp\teax, ecx\n+\tjbe\tL_do_copy1          /* if (nbytes >= len) */\n+\n+\tsub\teax, ecx         /* len -= nbytes */\n+\trep     movsb\n+\tmov\tesi, edi\n+\tsub\tesi, ebp         /* from = out - dist */\n+\n+L_do_copy1:\n+\tmov\tecx, eax\n+\trep     movsb\n+\n+\tmov\tesi, [esp+4]      /* move in back to %esi, toss from */\n+\tmov\tebp, [esp+44]     /* ebp = lcode */\n+\tjmp\tL_while_test\n+\n+L_test_for_end_of_block:\n+\ttest\tal, 32\n+\tjz\tL_invalid_literal_length_code\n+\tmov\tdword ptr [esp+68], 1\n+\tjmp\tL_break_loop_with_status\n+\n+L_invalid_literal_length_code:\n+\tmov\tdword ptr [esp+68], 2\n+\tjmp\tL_break_loop_with_status\n+\n+L_invalid_distance_code:\n+\tmov\tdword ptr [esp+68], 3\n+\tjmp\tL_break_loop_with_status\n+\n+L_invalid_distance_too_far:\n+\tmov\tesi, [esp+4]\n+\tmov\tdword ptr [esp+68], 4\n+\tjmp\tL_break_loop_with_status\n+\n+L_break_loop:\n+\tmov\tdword ptr [esp+68], 0\n+\n+L_break_loop_with_status:\n+/* put in, out, bits, and hold back into ar and pop esp */\n+\tmov\t[esp+4], esi\n+\tmov\t[esp+12], edi\n+\tmov\t[esp+40], ebx\n+\tmov\t[esp+36], edx\n+\tmov\tesp, [esp]\n+\tpop\tebp\n+\tpopfd\n+    }\n+#endif\n+\n+    if (ar.status > 1) {\n+        if (ar.status == 2)\n+            strm->msg = \"invalid literal/length code\";\n+        else if (ar.status == 3)\n+            strm->msg = \"invalid distance code\";\n+        else\n+            strm->msg = \"invalid distance too far back\";\n+        state->mode = BAD;\n+    }\n+    else if ( ar.status == 1 ) {\n+        state->mode = TYPE;\n+    }\n+\n+    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n+    ar.len = ar.bits >> 3;\n+    ar.in -= ar.len;\n+    ar.bits -= ar.len << 3;\n+    ar.hold &= (1U << ar.bits) - 1;\n+\n+    /* update state and return */\n+    strm->next_in = ar.in;\n+    strm->next_out = ar.out;\n+    strm->avail_in = (unsigned)(ar.in < ar.last ? 5 + (ar.last - ar.in) :\n+                                                  5 - (ar.in - ar.last));\n+    strm->avail_out = (unsigned)(ar.out < ar.end ? 257 + (ar.end - ar.out) :\n+                                                   257 - (ar.out - ar.end));\n+    state->hold = ar.hold;\n+    state->bits = ar.bits;\n+    return;\n+}\n+"}, {"sha": "f9bffd5eb9d1739dd1924fa0591a29b0ff0821b3", "filename": "zlib/contrib/inflate86/inffast.S", "status": "added", "additions": 1377, "deletions": 0, "changes": 1377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finflate86%2Finffast.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Finflate86%2Finffast.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Finflate86%2Finffast.S?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,1377 @@\n+/*\n+ * inffast.S is a hand tuned assembler version of:\n+ *\n+ * inffast.c -- fast decoding\n+ * Copyright (C) 1995-2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ *\n+ * Copyright (C) 2003 Chris Anderson <christop@charm.net>\n+ * Please use the copyright conditions above.\n+ *\n+ * This version (Jan-23-2003) of inflate_fast was coded and tested under\n+ * GNU/Linux on a pentium 3, using the gcc-3.2 compiler distribution.  On that\n+ * machine, I found that gzip style archives decompressed about 20% faster than\n+ * the gcc-3.2 -O3 -fomit-frame-pointer compiled version.  Your results will\n+ * depend on how large of a buffer is used for z_stream.next_in & next_out\n+ * (8K-32K worked best for my 256K cpu cache) and how much overhead there is in\n+ * stream processing I/O and crc32/addler32.  In my case, this routine used\n+ * 70% of the cpu time and crc32 used 20%.\n+ *\n+ * I am confident that this version will work in the general case, but I have\n+ * not tested a wide variety of datasets or a wide variety of platforms.\n+ *\n+ * Jan-24-2003 -- Added -DUSE_MMX define for slightly faster inflating.\n+ * It should be a runtime flag instead of compile time flag...\n+ *\n+ * Jan-26-2003 -- Added runtime check for MMX support with cpuid instruction.\n+ * With -DUSE_MMX, only MMX code is compiled.  With -DNO_MMX, only non-MMX code\n+ * is compiled.  Without either option, runtime detection is enabled.  Runtime\n+ * detection should work on all modern cpus and the recomended algorithm (flip\n+ * ID bit on eflags and then use the cpuid instruction) is used in many\n+ * multimedia applications.  Tested under win2k with gcc-2.95 and gas-2.12\n+ * distributed with cygwin3.  Compiling with gcc-2.95 -c inffast.S -o\n+ * inffast.obj generates a COFF object which can then be linked with MSVC++\n+ * compiled code.  Tested under FreeBSD 4.7 with gcc-2.95.\n+ *\n+ * Jan-28-2003 -- Tested Athlon XP... MMX mode is slower than no MMX (and\n+ * slower than compiler generated code).  Adjusted cpuid check to use the MMX\n+ * code only for Pentiums < P4 until I have more data on the P4.  Speed\n+ * improvment is only about 15% on the Athlon when compared with code generated\n+ * with MSVC++.  Not sure yet, but I think the P4 will also be slower using the\n+ * MMX mode because many of it's x86 ALU instructions execute in .5 cycles and\n+ * have less latency than MMX ops.  Added code to buffer the last 11 bytes of\n+ * the input stream since the MMX code grabs bits in chunks of 32, which\n+ * differs from the inffast.c algorithm.  I don't think there would have been\n+ * read overruns where a page boundary was crossed (a segfault), but there\n+ * could have been overruns when next_in ends on unaligned memory (unintialized\n+ * memory read).\n+ *\n+ * Mar-13-2003 -- P4 MMX is slightly slower than P4 NO_MMX.  I created a C\n+ * version of the non-MMX code so that it doesn't depend on zstrm and zstate\n+ * structure offsets which are hard coded in this file.  This was last tested\n+ * with zlib-1.2.0 which is currently in beta testing, newer versions of this\n+ * and inffas86.c can be found at http://www.eetbeetee.com/zlib/ and\n+ * http://www.charm.net/~christop/zlib/\n+ */\n+\n+\n+/*\n+ * if you have underscore linking problems (_inflate_fast undefined), try\n+ * using -DGAS_COFF\n+ */\n+#if ! defined( GAS_COFF ) && ! defined( GAS_ELF )\n+\n+#if defined( WIN32 ) || defined( __CYGWIN__ )\n+#define GAS_COFF /* windows object format */\n+#else\n+#define GAS_ELF\n+#endif\n+\n+#endif /* ! GAS_COFF && ! GAS_ELF */\n+\n+\n+#if defined( GAS_COFF )\n+\n+/* coff externals have underscores */\n+#define inflate_fast _inflate_fast\n+#define inflate_fast_use_mmx _inflate_fast_use_mmx\n+\n+#endif /* GAS_COFF */\n+\n+\n+.file \"inffast.S\"\n+\n+.globl inflate_fast\n+\n+.text\n+.align 4,0\n+.L_invalid_literal_length_code_msg:\n+.string \"invalid literal/length code\"\n+\n+.align 4,0\n+.L_invalid_distance_code_msg:\n+.string \"invalid distance code\"\n+\n+.align 4,0\n+.L_invalid_distance_too_far_msg:\n+.string \"invalid distance too far back\"\n+\n+#if ! defined( NO_MMX )\n+.align 4,0\n+.L_mask: /* mask[N] = ( 1 << N ) - 1 */\n+.long 0\n+.long 1\n+.long 3\n+.long 7\n+.long 15\n+.long 31\n+.long 63\n+.long 127\n+.long 255\n+.long 511\n+.long 1023\n+.long 2047\n+.long 4095\n+.long 8191\n+.long 16383\n+.long 32767\n+.long 65535\n+.long 131071\n+.long 262143\n+.long 524287\n+.long 1048575\n+.long 2097151\n+.long 4194303\n+.long 8388607\n+.long 16777215\n+.long 33554431\n+.long 67108863\n+.long 134217727\n+.long 268435455\n+.long 536870911\n+.long 1073741823\n+.long 2147483647\n+.long 4294967295\n+#endif /* NO_MMX */\n+\n+.text\n+\n+/*\n+ * struct z_stream offsets, in zlib.h\n+ */\n+#define next_in_strm   0   /* strm->next_in */\n+#define avail_in_strm  4   /* strm->avail_in */\n+#define next_out_strm  12  /* strm->next_out */\n+#define avail_out_strm 16  /* strm->avail_out */\n+#define msg_strm       24  /* strm->msg */\n+#define state_strm     28  /* strm->state */\n+\n+/*\n+ * struct inflate_state offsets, in inflate.h\n+ */\n+#define mode_state     0   /* state->mode */\n+#define wsize_state    32  /* state->wsize */\n+#define write_state    40  /* state->write */\n+#define window_state   44  /* state->window */\n+#define hold_state     48  /* state->hold */\n+#define bits_state     52  /* state->bits */\n+#define lencode_state  68  /* state->lencode */\n+#define distcode_state 72  /* state->distcode */\n+#define lenbits_state  76  /* state->lenbits */\n+#define distbits_state 80  /* state->distbits */\n+\n+/*\n+ * inflate_fast's activation record\n+ */\n+#define local_var_size 64 /* how much local space for vars */\n+#define strm_sp        88 /* first arg: z_stream * (local_var_size + 24) */\n+#define start_sp       92 /* second arg: unsigned int (local_var_size + 28) */\n+\n+/*\n+ * offsets for local vars on stack\n+ */\n+#define out            60  /* unsigned char* */\n+#define window         56  /* unsigned char* */\n+#define wsize          52  /* unsigned int */\n+#define write          48  /* unsigned int */\n+#define in             44  /* unsigned char* */\n+#define beg            40  /* unsigned char* */\n+#define buf            28  /* char[ 12 ] */\n+#define len            24  /* unsigned int */\n+#define last           20  /* unsigned char* */\n+#define end            16  /* unsigned char* */\n+#define dcode          12  /* code* */\n+#define lcode           8  /* code* */\n+#define dmask           4  /* unsigned int */\n+#define lmask           0  /* unsigned int */\n+\n+/*\n+ * typedef enum inflate_mode consts, in inflate.h\n+ */\n+#ifndef NO_GUNZIP\n+#define GUNZIP\n+#endif\n+\n+#ifdef GUNZIP\n+#define INFLATE_MODE_TYPE 11  /* state->mode flags enum-ed in inflate.h */\n+#define INFLATE_MODE_BAD  26\n+#else\n+#define INFLATE_MODE_TYPE 3\n+#define INFLATE_MODE_BAD  17\n+#endif\n+\n+\n+#if ! defined( USE_MMX ) && ! defined( NO_MMX )\n+\n+#define RUN_TIME_MMX\n+\n+#define CHECK_MMX    1\n+#define DO_USE_MMX   2\n+#define DONT_USE_MMX 3\n+\n+.globl inflate_fast_use_mmx\n+\n+.data\n+\n+.align 4,0\n+inflate_fast_use_mmx: /* integer flag for run time control 1=check,2=mmx,3=no */\n+.long CHECK_MMX\n+\n+#if defined( GAS_ELF )\n+/* elf info */\n+.type   inflate_fast_use_mmx,@object\n+.size   inflate_fast_use_mmx,4\n+#endif\n+\n+#endif /* RUN_TIME_MMX */\n+\n+#if defined( GAS_COFF )\n+/* coff info: scl 2 = extern, type 32 = function */\n+.def inflate_fast; .scl 2; .type 32; .endef\n+#endif\n+\n+.text\n+\n+.align 32,0x90\n+inflate_fast:\n+        pushl   %edi\n+        pushl   %esi\n+        pushl   %ebp\n+        pushl   %ebx\n+        pushf   /* save eflags (strm_sp, state_sp assumes this is 32 bits) */\n+        subl    $local_var_size, %esp\n+        cld\n+\n+#define strm_r  %esi\n+#define state_r %edi\n+\n+        movl    strm_sp(%esp), strm_r\n+        movl    state_strm(strm_r), state_r\n+\n+        /* in = strm->next_in;\n+         * out = strm->next_out;\n+         * last = in + strm->avail_in - 11;\n+         * beg = out - (start - strm->avail_out);\n+         * end = out + (strm->avail_out - 257);\n+         */\n+        movl    avail_in_strm(strm_r), %edx\n+        movl    next_in_strm(strm_r), %eax\n+\n+        addl    %eax, %edx      /* avail_in += next_in */\n+        subl    $11, %edx       /* avail_in -= 11 */\n+\n+        movl    %eax, in(%esp)\n+        movl    %edx, last(%esp)\n+\n+        movl    start_sp(%esp), %ebp\n+        movl    avail_out_strm(strm_r), %ecx\n+        movl    next_out_strm(strm_r), %ebx\n+\n+        subl    %ecx, %ebp      /* start -= avail_out */\n+        negl    %ebp            /* start = -start */\n+        addl    %ebx, %ebp      /* start += next_out */\n+\n+        subl    $257, %ecx      /* avail_out -= 257 */\n+        addl    %ebx, %ecx      /* avail_out += out */\n+\n+        movl    %ebx, out(%esp)\n+        movl    %ebp, beg(%esp)\n+        movl    %ecx, end(%esp)\n+\n+        /* wsize = state->wsize;\n+         * write = state->write;\n+         * window = state->window;\n+         * hold = state->hold;\n+         * bits = state->bits;\n+         * lcode = state->lencode;\n+         * dcode = state->distcode;\n+         * lmask = ( 1 << state->lenbits ) - 1;\n+         * dmask = ( 1 << state->distbits ) - 1;\n+         */\n+\n+        movl    lencode_state(state_r), %eax\n+        movl    distcode_state(state_r), %ecx\n+\n+        movl    %eax, lcode(%esp)\n+        movl    %ecx, dcode(%esp)\n+\n+        movl    $1, %eax\n+        movl    lenbits_state(state_r), %ecx\n+        shll    %cl, %eax\n+        decl    %eax\n+        movl    %eax, lmask(%esp)\n+\n+        movl    $1, %eax\n+        movl    distbits_state(state_r), %ecx\n+        shll    %cl, %eax\n+        decl    %eax\n+        movl    %eax, dmask(%esp)\n+\n+        movl    wsize_state(state_r), %eax\n+        movl    write_state(state_r), %ecx\n+        movl    window_state(state_r), %edx\n+\n+        movl    %eax, wsize(%esp)\n+        movl    %ecx, write(%esp)\n+        movl    %edx, window(%esp)\n+\n+        movl    hold_state(state_r), %ebp\n+        movl    bits_state(state_r), %ebx\n+\n+#undef strm_r\n+#undef state_r\n+\n+#define in_r       %esi\n+#define from_r     %esi\n+#define out_r      %edi\n+\n+        movl    in(%esp), in_r\n+        movl    last(%esp), %ecx\n+        cmpl    in_r, %ecx\n+        ja      .L_align_long           /* if in < last */\n+\n+        addl    $11, %ecx               /* ecx = &in[ avail_in ] */\n+        subl    in_r, %ecx              /* ecx = avail_in */\n+        movl    $12, %eax\n+        subl    %ecx, %eax              /* eax = 12 - avail_in */\n+        leal    buf(%esp), %edi\n+        rep     movsb                   /* memcpy( buf, in, avail_in ) */\n+        movl    %eax, %ecx\n+        xorl    %eax, %eax\n+        rep     stosb         /* memset( &buf[ avail_in ], 0, 12 - avail_in ) */\n+        leal    buf(%esp), in_r         /* in = buf */\n+        movl    in_r, last(%esp)        /* last = in, do just one iteration */\n+        jmp     .L_is_aligned\n+\n+        /* align in_r on long boundary */\n+.L_align_long:\n+        testl   $3, in_r\n+        jz      .L_is_aligned\n+        xorl    %eax, %eax\n+        movb    (in_r), %al\n+        incl    in_r\n+        movl    %ebx, %ecx\n+        addl    $8, %ebx\n+        shll    %cl, %eax\n+        orl     %eax, %ebp\n+        jmp     .L_align_long\n+\n+.L_is_aligned:\n+        movl    out(%esp), out_r\n+\n+#if defined( NO_MMX )\n+        jmp     .L_do_loop\n+#endif\n+\n+#if defined( USE_MMX )\n+        jmp     .L_init_mmx\n+#endif\n+\n+/*** Runtime MMX check ***/\n+\n+#if defined( RUN_TIME_MMX )\n+.L_check_mmx:\n+        cmpl    $DO_USE_MMX, inflate_fast_use_mmx\n+        je      .L_init_mmx\n+        ja      .L_do_loop /* > 2 */\n+\n+        pushl   %eax\n+        pushl   %ebx\n+        pushl   %ecx\n+        pushl   %edx\n+        pushf\n+        movl    (%esp), %eax      /* copy eflags to eax */\n+        xorl    $0x200000, (%esp) /* try toggling ID bit of eflags (bit 21)\n+                                   * to see if cpu supports cpuid...\n+                                   * ID bit method not supported by NexGen but\n+                                   * bios may load a cpuid instruction and\n+                                   * cpuid may be disabled on Cyrix 5-6x86 */\n+        popf\n+        pushf\n+        popl    %edx              /* copy new eflags to edx */\n+        xorl    %eax, %edx        /* test if ID bit is flipped */\n+        jz      .L_dont_use_mmx   /* not flipped if zero */\n+        xorl    %eax, %eax\n+        cpuid\n+        cmpl    $0x756e6547, %ebx /* check for GenuineIntel in ebx,ecx,edx */\n+        jne     .L_dont_use_mmx\n+        cmpl    $0x6c65746e, %ecx\n+        jne     .L_dont_use_mmx\n+        cmpl    $0x49656e69, %edx\n+        jne     .L_dont_use_mmx\n+        movl    $1, %eax\n+        cpuid                     /* get cpu features */\n+        shrl    $8, %eax\n+        andl    $15, %eax\n+        cmpl    $6, %eax          /* check for Pentium family, is 0xf for P4 */\n+        jne     .L_dont_use_mmx\n+        testl   $0x800000, %edx   /* test if MMX feature is set (bit 23) */\n+        jnz     .L_use_mmx\n+        jmp     .L_dont_use_mmx\n+.L_use_mmx:\n+        movl    $DO_USE_MMX, inflate_fast_use_mmx\n+        jmp     .L_check_mmx_pop\n+.L_dont_use_mmx:\n+        movl    $DONT_USE_MMX, inflate_fast_use_mmx\n+.L_check_mmx_pop:\n+        popl    %edx\n+        popl    %ecx\n+        popl    %ebx\n+        popl    %eax\n+        jmp     .L_check_mmx\n+#endif\n+\n+\n+/*** Non-MMX code ***/\n+\n+#if defined ( NO_MMX ) || defined( RUN_TIME_MMX )\n+\n+#define hold_r     %ebp\n+#define bits_r     %bl\n+#define bitslong_r %ebx\n+\n+.align 32,0x90\n+.L_while_test:\n+        /* while (in < last && out < end)\n+         */\n+        cmpl    out_r, end(%esp)\n+        jbe     .L_break_loop           /* if (out >= end) */\n+\n+        cmpl    in_r, last(%esp)\n+        jbe     .L_break_loop\n+\n+.L_do_loop:\n+        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out\n+         *\n+         * do {\n+         *   if (bits < 15) {\n+         *     hold |= *((unsigned short *)in)++ << bits;\n+         *     bits += 16\n+         *   }\n+         *   this = lcode[hold & lmask]\n+         */\n+        cmpb    $15, bits_r\n+        ja      .L_get_length_code      /* if (15 < bits) */\n+\n+        xorl    %eax, %eax\n+        lodsw                           /* al = *(ushort *)in++ */\n+        movb    bits_r, %cl             /* cl = bits, needs it for shifting */\n+        addb    $16, bits_r             /* bits += 16 */\n+        shll    %cl, %eax\n+        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */\n+\n+.L_get_length_code:\n+        movl    lmask(%esp), %edx       /* edx = lmask */\n+        movl    lcode(%esp), %ecx       /* ecx = lcode */\n+        andl    hold_r, %edx            /* edx &= hold */\n+        movl    (%ecx,%edx,4), %eax     /* eax = lcode[hold & lmask] */\n+\n+.L_dolen:\n+        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out\n+         *\n+         * dolen:\n+         *    bits -= this.bits;\n+         *    hold >>= this.bits\n+         */\n+        movb    %ah, %cl                /* cl = this.bits */\n+        subb    %ah, bits_r             /* bits -= this.bits */\n+        shrl    %cl, hold_r             /* hold >>= this.bits */\n+\n+        /* check if op is a literal\n+         * if (op == 0) {\n+         *    PUP(out) = this.val;\n+         *  }\n+         */\n+        testb   %al, %al\n+        jnz     .L_test_for_length_base /* if (op != 0) 45.7% */\n+\n+        shrl    $16, %eax               /* output this.val char */\n+        stosb\n+        jmp     .L_while_test\n+\n+.L_test_for_length_base:\n+        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out, %edx = len\n+         *\n+         * else if (op & 16) {\n+         *   len = this.val\n+         *   op &= 15\n+         *   if (op) {\n+         *     if (op > bits) {\n+         *       hold |= *((unsigned short *)in)++ << bits;\n+         *       bits += 16\n+         *     }\n+         *     len += hold & mask[op];\n+         *     bits -= op;\n+         *     hold >>= op;\n+         *   }\n+         */\n+#define len_r %edx\n+        movl    %eax, len_r             /* len = this */\n+        shrl    $16, len_r              /* len = this.val */\n+        movb    %al, %cl\n+\n+        testb   $16, %al\n+        jz      .L_test_for_second_level_length /* if ((op & 16) == 0) 8% */\n+        andb    $15, %cl                /* op &= 15 */\n+        jz      .L_save_len             /* if (!op) */\n+        cmpb    %cl, bits_r\n+        jae     .L_add_bits_to_len      /* if (op <= bits) */\n+\n+        movb    %cl, %ch                /* stash op in ch, freeing cl */\n+        xorl    %eax, %eax\n+        lodsw                           /* al = *(ushort *)in++ */\n+        movb    bits_r, %cl             /* cl = bits, needs it for shifting */\n+        addb    $16, bits_r             /* bits += 16 */\n+        shll    %cl, %eax\n+        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */\n+        movb    %ch, %cl                /* move op back to ecx */\n+\n+.L_add_bits_to_len:\n+        movl    $1, %eax\n+        shll    %cl, %eax\n+        decl    %eax\n+        subb    %cl, bits_r\n+        andl    hold_r, %eax            /* eax &= hold */\n+        shrl    %cl, hold_r\n+        addl    %eax, len_r             /* len += hold & mask[op] */\n+\n+.L_save_len:\n+        movl    len_r, len(%esp)        /* save len */\n+#undef  len_r\n+\n+.L_decode_distance:\n+        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out, %edx = dist\n+         *\n+         *   if (bits < 15) {\n+         *     hold |= *((unsigned short *)in)++ << bits;\n+         *     bits += 16\n+         *   }\n+         *   this = dcode[hold & dmask];\n+         * dodist:\n+         *   bits -= this.bits;\n+         *   hold >>= this.bits;\n+         *   op = this.op;\n+         */\n+\n+        cmpb    $15, bits_r\n+        ja      .L_get_distance_code    /* if (15 < bits) */\n+\n+        xorl    %eax, %eax\n+        lodsw                           /* al = *(ushort *)in++ */\n+        movb    bits_r, %cl             /* cl = bits, needs it for shifting */\n+        addb    $16, bits_r             /* bits += 16 */\n+        shll    %cl, %eax\n+        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */\n+\n+.L_get_distance_code:\n+        movl    dmask(%esp), %edx       /* edx = dmask */\n+        movl    dcode(%esp), %ecx       /* ecx = dcode */\n+        andl    hold_r, %edx            /* edx &= hold */\n+        movl    (%ecx,%edx,4), %eax     /* eax = dcode[hold & dmask] */\n+\n+#define dist_r %edx\n+.L_dodist:\n+        movl    %eax, dist_r            /* dist = this */\n+        shrl    $16, dist_r             /* dist = this.val */\n+        movb    %ah, %cl\n+        subb    %ah, bits_r             /* bits -= this.bits */\n+        shrl    %cl, hold_r             /* hold >>= this.bits */\n+\n+        /* if (op & 16) {\n+         *   dist = this.val\n+         *   op &= 15\n+         *   if (op > bits) {\n+         *     hold |= *((unsigned short *)in)++ << bits;\n+         *     bits += 16\n+         *   }\n+         *   dist += hold & mask[op];\n+         *   bits -= op;\n+         *   hold >>= op;\n+         */\n+        movb    %al, %cl                /* cl = this.op */\n+\n+        testb   $16, %al                /* if ((op & 16) == 0) */\n+        jz      .L_test_for_second_level_dist\n+        andb    $15, %cl                /* op &= 15 */\n+        jz      .L_check_dist_one\n+        cmpb    %cl, bits_r\n+        jae     .L_add_bits_to_dist     /* if (op <= bits) 97.6% */\n+\n+        movb    %cl, %ch                /* stash op in ch, freeing cl */\n+        xorl    %eax, %eax\n+        lodsw                           /* al = *(ushort *)in++ */\n+        movb    bits_r, %cl             /* cl = bits, needs it for shifting */\n+        addb    $16, bits_r             /* bits += 16 */\n+        shll    %cl, %eax\n+        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */\n+        movb    %ch, %cl                /* move op back to ecx */\n+\n+.L_add_bits_to_dist:\n+        movl    $1, %eax\n+        shll    %cl, %eax\n+        decl    %eax                    /* (1 << op) - 1 */\n+        subb    %cl, bits_r\n+        andl    hold_r, %eax            /* eax &= hold */\n+        shrl    %cl, hold_r\n+        addl    %eax, dist_r            /* dist += hold & ((1 << op) - 1) */\n+        jmp     .L_check_window\n+\n+.L_check_window:\n+        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist\n+         *       %ecx = nbytes\n+         *\n+         * nbytes = out - beg;\n+         * if (dist <= nbytes) {\n+         *   from = out - dist;\n+         *   do {\n+         *     PUP(out) = PUP(from);\n+         *   } while (--len > 0) {\n+         * }\n+         */\n+\n+        movl    in_r, in(%esp)          /* save in so from can use it's reg */\n+        movl    out_r, %eax\n+        subl    beg(%esp), %eax         /* nbytes = out - beg */\n+\n+        cmpl    dist_r, %eax\n+        jb      .L_clip_window          /* if (dist > nbytes) 4.2% */\n+\n+        movl    len(%esp), %ecx\n+        movl    out_r, from_r\n+        subl    dist_r, from_r          /* from = out - dist */\n+\n+        subl    $3, %ecx\n+        movb    (from_r), %al\n+        movb    %al, (out_r)\n+        movb    1(from_r), %al\n+        movb    2(from_r), %dl\n+        addl    $3, from_r\n+        movb    %al, 1(out_r)\n+        movb    %dl, 2(out_r)\n+        addl    $3, out_r\n+        rep     movsb\n+\n+        movl    in(%esp), in_r          /* move in back to %esi, toss from */\n+        jmp     .L_while_test\n+\n+.align 16,0x90\n+.L_check_dist_one:\n+        cmpl    $1, dist_r\n+        jne     .L_check_window\n+        cmpl    out_r, beg(%esp)\n+        je      .L_check_window\n+\n+        decl    out_r\n+        movl    len(%esp), %ecx\n+        movb    (out_r), %al\n+        subl    $3, %ecx\n+\n+        movb    %al, 1(out_r)\n+        movb    %al, 2(out_r)\n+        movb    %al, 3(out_r)\n+        addl    $4, out_r\n+        rep     stosb\n+\n+        jmp     .L_while_test\n+\n+.align 16,0x90\n+.L_test_for_second_level_length:\n+        /* else if ((op & 64) == 0) {\n+         *   this = lcode[this.val + (hold & mask[op])];\n+         * }\n+         */\n+        testb   $64, %al\n+        jnz     .L_test_for_end_of_block  /* if ((op & 64) != 0) */\n+\n+        movl    $1, %eax\n+        shll    %cl, %eax\n+        decl    %eax\n+        andl    hold_r, %eax            /* eax &= hold */\n+        addl    %edx, %eax              /* eax += this.val */\n+        movl    lcode(%esp), %edx       /* edx = lcode */\n+        movl    (%edx,%eax,4), %eax     /* eax = lcode[val + (hold&mask[op])] */\n+        jmp     .L_dolen\n+\n+.align 16,0x90\n+.L_test_for_second_level_dist:\n+        /* else if ((op & 64) == 0) {\n+         *   this = dcode[this.val + (hold & mask[op])];\n+         * }\n+         */\n+        testb   $64, %al\n+        jnz     .L_invalid_distance_code  /* if ((op & 64) != 0) */\n+\n+        movl    $1, %eax\n+        shll    %cl, %eax\n+        decl    %eax\n+        andl    hold_r, %eax            /* eax &= hold */\n+        addl    %edx, %eax              /* eax += this.val */\n+        movl    dcode(%esp), %edx       /* edx = dcode */\n+        movl    (%edx,%eax,4), %eax     /* eax = dcode[val + (hold&mask[op])] */\n+        jmp     .L_dodist\n+\n+.align 16,0x90\n+.L_clip_window:\n+        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist\n+         *       %ecx = nbytes\n+         *\n+         * else {\n+         *   if (dist > wsize) {\n+         *     invalid distance\n+         *   }\n+         *   from = window;\n+         *   nbytes = dist - nbytes;\n+         *   if (write == 0) {\n+         *     from += wsize - nbytes;\n+         */\n+#define nbytes_r %ecx\n+        movl    %eax, nbytes_r\n+        movl    wsize(%esp), %eax       /* prepare for dist compare */\n+        negl    nbytes_r                /* nbytes = -nbytes */\n+        movl    window(%esp), from_r    /* from = window */\n+\n+        cmpl    dist_r, %eax\n+        jb      .L_invalid_distance_too_far /* if (dist > wsize) */\n+\n+        addl    dist_r, nbytes_r        /* nbytes = dist - nbytes */\n+        cmpl    $0, write(%esp)\n+        jne     .L_wrap_around_window   /* if (write != 0) */\n+\n+        subl    nbytes_r, %eax\n+        addl    %eax, from_r            /* from += wsize - nbytes */\n+\n+        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist\n+         *       %ecx = nbytes, %eax = len\n+         *\n+         *     if (nbytes < len) {\n+         *       len -= nbytes;\n+         *       do {\n+         *         PUP(out) = PUP(from);\n+         *       } while (--nbytes);\n+         *       from = out - dist;\n+         *     }\n+         *   }\n+         */\n+#define len_r %eax\n+        movl    len(%esp), len_r\n+        cmpl    nbytes_r, len_r\n+        jbe     .L_do_copy1             /* if (nbytes >= len) */\n+\n+        subl    nbytes_r, len_r         /* len -= nbytes */\n+        rep     movsb\n+        movl    out_r, from_r\n+        subl    dist_r, from_r          /* from = out - dist */\n+        jmp     .L_do_copy1\n+\n+        cmpl    nbytes_r, len_r\n+        jbe     .L_do_copy1             /* if (nbytes >= len) */\n+\n+        subl    nbytes_r, len_r         /* len -= nbytes */\n+        rep     movsb\n+        movl    out_r, from_r\n+        subl    dist_r, from_r          /* from = out - dist */\n+        jmp     .L_do_copy1\n+\n+.L_wrap_around_window:\n+        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist\n+         *       %ecx = nbytes, %eax = write, %eax = len\n+         *\n+         *   else if (write < nbytes) {\n+         *     from += wsize + write - nbytes;\n+         *     nbytes -= write;\n+         *     if (nbytes < len) {\n+         *       len -= nbytes;\n+         *       do {\n+         *         PUP(out) = PUP(from);\n+         *       } while (--nbytes);\n+         *       from = window;\n+         *       nbytes = write;\n+         *       if (nbytes < len) {\n+         *         len -= nbytes;\n+         *         do {\n+         *           PUP(out) = PUP(from);\n+         *         } while(--nbytes);\n+         *         from = out - dist;\n+         *       }\n+         *     }\n+         *   }\n+         */\n+#define write_r %eax\n+        movl    write(%esp), write_r\n+        cmpl    write_r, nbytes_r\n+        jbe     .L_contiguous_in_window /* if (write >= nbytes) */\n+\n+        addl    wsize(%esp), from_r\n+        addl    write_r, from_r\n+        subl    nbytes_r, from_r        /* from += wsize + write - nbytes */\n+        subl    write_r, nbytes_r       /* nbytes -= write */\n+#undef write_r\n+\n+        movl    len(%esp), len_r\n+        cmpl    nbytes_r, len_r\n+        jbe     .L_do_copy1             /* if (nbytes >= len) */\n+\n+        subl    nbytes_r, len_r         /* len -= nbytes */\n+        rep     movsb\n+        movl    window(%esp), from_r    /* from = window */\n+        movl    write(%esp), nbytes_r   /* nbytes = write */\n+        cmpl    nbytes_r, len_r\n+        jbe     .L_do_copy1             /* if (nbytes >= len) */\n+\n+        subl    nbytes_r, len_r         /* len -= nbytes */\n+        rep     movsb\n+        movl    out_r, from_r\n+        subl    dist_r, from_r          /* from = out - dist */\n+        jmp     .L_do_copy1\n+\n+.L_contiguous_in_window:\n+        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist\n+         *       %ecx = nbytes, %eax = write, %eax = len\n+         *\n+         *   else {\n+         *     from += write - nbytes;\n+         *     if (nbytes < len) {\n+         *       len -= nbytes;\n+         *       do {\n+         *         PUP(out) = PUP(from);\n+         *       } while (--nbytes);\n+         *       from = out - dist;\n+         *     }\n+         *   }\n+         */\n+#define write_r %eax\n+        addl    write_r, from_r\n+        subl    nbytes_r, from_r        /* from += write - nbytes */\n+#undef write_r\n+\n+        movl    len(%esp), len_r\n+        cmpl    nbytes_r, len_r\n+        jbe     .L_do_copy1             /* if (nbytes >= len) */\n+\n+        subl    nbytes_r, len_r         /* len -= nbytes */\n+        rep     movsb\n+        movl    out_r, from_r\n+        subl    dist_r, from_r          /* from = out - dist */\n+\n+.L_do_copy1:\n+        /* regs: %esi = from, %esi = in, %ebp = hold, %bl = bits, %edi = out\n+         *       %eax = len\n+         *\n+         *     while (len > 0) {\n+         *       PUP(out) = PUP(from);\n+         *       len--;\n+         *     }\n+         *   }\n+         * } while (in < last && out < end);\n+         */\n+#undef nbytes_r\n+#define in_r %esi\n+        movl    len_r, %ecx\n+        rep     movsb\n+\n+        movl    in(%esp), in_r          /* move in back to %esi, toss from */\n+        jmp     .L_while_test\n+\n+#undef len_r\n+#undef dist_r\n+\n+#endif /* NO_MMX || RUN_TIME_MMX */\n+\n+\n+/*** MMX code ***/\n+\n+#if defined( USE_MMX ) || defined( RUN_TIME_MMX )\n+\n+.align 32,0x90\n+.L_init_mmx:\n+        emms\n+\n+#undef  bits_r\n+#undef  bitslong_r\n+#define bitslong_r %ebp\n+#define hold_mm    %mm0\n+        movd    %ebp, hold_mm\n+        movl    %ebx, bitslong_r\n+\n+#define used_mm   %mm1\n+#define dmask2_mm %mm2\n+#define lmask2_mm %mm3\n+#define lmask_mm  %mm4\n+#define dmask_mm  %mm5\n+#define tmp_mm    %mm6\n+\n+        movd    lmask(%esp), lmask_mm\n+        movq    lmask_mm, lmask2_mm\n+        movd    dmask(%esp), dmask_mm\n+        movq    dmask_mm, dmask2_mm\n+        pxor    used_mm, used_mm\n+        movl    lcode(%esp), %ebx       /* ebx = lcode */\n+        jmp     .L_do_loop_mmx\n+\n+.align 32,0x90\n+.L_while_test_mmx:\n+        /* while (in < last && out < end)\n+         */\n+        cmpl    out_r, end(%esp)\n+        jbe     .L_break_loop           /* if (out >= end) */\n+\n+        cmpl    in_r, last(%esp)\n+        jbe     .L_break_loop\n+\n+.L_do_loop_mmx:\n+        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */\n+\n+        cmpl    $32, bitslong_r\n+        ja      .L_get_length_code_mmx  /* if (32 < bits) */\n+\n+        movd    bitslong_r, tmp_mm\n+        movd    (in_r), %mm7\n+        addl    $4, in_r\n+        psllq   tmp_mm, %mm7\n+        addl    $32, bitslong_r\n+        por     %mm7, hold_mm           /* hold_mm |= *((uint *)in)++ << bits */\n+\n+.L_get_length_code_mmx:\n+        pand    hold_mm, lmask_mm\n+        movd    lmask_mm, %eax\n+        movq    lmask2_mm, lmask_mm\n+        movl    (%ebx,%eax,4), %eax     /* eax = lcode[hold & lmask] */\n+\n+.L_dolen_mmx:\n+        movzbl  %ah, %ecx               /* ecx = this.bits */\n+        movd    %ecx, used_mm\n+        subl    %ecx, bitslong_r        /* bits -= this.bits */\n+\n+        testb   %al, %al\n+        jnz     .L_test_for_length_base_mmx /* if (op != 0) 45.7% */\n+\n+        shrl    $16, %eax               /* output this.val char */\n+        stosb\n+        jmp     .L_while_test_mmx\n+\n+.L_test_for_length_base_mmx:\n+#define len_r  %edx\n+        movl    %eax, len_r             /* len = this */\n+        shrl    $16, len_r              /* len = this.val */\n+\n+        testb   $16, %al\n+        jz      .L_test_for_second_level_length_mmx /* if ((op & 16) == 0) 8% */\n+        andl    $15, %eax               /* op &= 15 */\n+        jz      .L_decode_distance_mmx  /* if (!op) */\n+\n+        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */\n+        movd    %eax, used_mm\n+        movd    hold_mm, %ecx\n+        subl    %eax, bitslong_r\n+        andl    .L_mask(,%eax,4), %ecx\n+        addl    %ecx, len_r             /* len += hold & mask[op] */\n+\n+.L_decode_distance_mmx:\n+        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */\n+\n+        cmpl    $32, bitslong_r\n+        ja      .L_get_dist_code_mmx    /* if (32 < bits) */\n+\n+        movd    bitslong_r, tmp_mm\n+        movd    (in_r), %mm7\n+        addl    $4, in_r\n+        psllq   tmp_mm, %mm7\n+        addl    $32, bitslong_r\n+        por     %mm7, hold_mm           /* hold_mm |= *((uint *)in)++ << bits */\n+\n+.L_get_dist_code_mmx:\n+        movl    dcode(%esp), %ebx       /* ebx = dcode */\n+        pand    hold_mm, dmask_mm\n+        movd    dmask_mm, %eax\n+        movq    dmask2_mm, dmask_mm\n+        movl    (%ebx,%eax,4), %eax     /* eax = dcode[hold & lmask] */\n+\n+.L_dodist_mmx:\n+#define dist_r %ebx\n+        movzbl  %ah, %ecx               /* ecx = this.bits */\n+        movl    %eax, dist_r\n+        shrl    $16, dist_r             /* dist  = this.val */\n+        subl    %ecx, bitslong_r        /* bits -= this.bits */\n+        movd    %ecx, used_mm\n+\n+        testb   $16, %al                /* if ((op & 16) == 0) */\n+        jz      .L_test_for_second_level_dist_mmx\n+        andl    $15, %eax               /* op &= 15 */\n+        jz      .L_check_dist_one_mmx\n+\n+.L_add_bits_to_dist_mmx:\n+        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */\n+        movd    %eax, used_mm           /* save bit length of current op */\n+        movd    hold_mm, %ecx           /* get the next bits on input stream */\n+        subl    %eax, bitslong_r        /* bits -= op bits */\n+        andl    .L_mask(,%eax,4), %ecx  /* ecx   = hold & mask[op] */\n+        addl    %ecx, dist_r            /* dist += hold & mask[op] */\n+\n+.L_check_window_mmx:\n+        movl    in_r, in(%esp)          /* save in so from can use it's reg */\n+        movl    out_r, %eax\n+        subl    beg(%esp), %eax         /* nbytes = out - beg */\n+\n+        cmpl    dist_r, %eax\n+        jb      .L_clip_window_mmx      /* if (dist > nbytes) 4.2% */\n+\n+        movl    len_r, %ecx\n+        movl    out_r, from_r\n+        subl    dist_r, from_r          /* from = out - dist */\n+\n+        subl    $3, %ecx\n+        movb    (from_r), %al\n+        movb    %al, (out_r)\n+        movb    1(from_r), %al\n+        movb    2(from_r), %dl\n+        addl    $3, from_r\n+        movb    %al, 1(out_r)\n+        movb    %dl, 2(out_r)\n+        addl    $3, out_r\n+        rep     movsb\n+\n+        movl    in(%esp), in_r          /* move in back to %esi, toss from */\n+        movl    lcode(%esp), %ebx       /* move lcode back to %ebx, toss dist */\n+        jmp     .L_while_test_mmx\n+\n+.align 16,0x90\n+.L_check_dist_one_mmx:\n+        cmpl    $1, dist_r\n+        jne     .L_check_window_mmx\n+        cmpl    out_r, beg(%esp)\n+        je      .L_check_window_mmx\n+\n+        decl    out_r\n+        movl    len_r, %ecx\n+        movb    (out_r), %al\n+        subl    $3, %ecx\n+\n+        movb    %al, 1(out_r)\n+        movb    %al, 2(out_r)\n+        movb    %al, 3(out_r)\n+        addl    $4, out_r\n+        rep     stosb\n+\n+        movl    lcode(%esp), %ebx       /* move lcode back to %ebx, toss dist */\n+        jmp     .L_while_test_mmx\n+\n+.align 16,0x90\n+.L_test_for_second_level_length_mmx:\n+        testb   $64, %al\n+        jnz     .L_test_for_end_of_block  /* if ((op & 64) != 0) */\n+\n+        andl    $15, %eax\n+        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */\n+        movd    hold_mm, %ecx\n+        andl    .L_mask(,%eax,4), %ecx\n+        addl    len_r, %ecx\n+        movl    (%ebx,%ecx,4), %eax     /* eax = lcode[hold & lmask] */\n+        jmp     .L_dolen_mmx\n+\n+.align 16,0x90\n+.L_test_for_second_level_dist_mmx:\n+        testb   $64, %al\n+        jnz     .L_invalid_distance_code  /* if ((op & 64) != 0) */\n+\n+        andl    $15, %eax\n+        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */\n+        movd    hold_mm, %ecx\n+        andl    .L_mask(,%eax,4), %ecx\n+        movl    dcode(%esp), %eax       /* ecx = dcode */\n+        addl    dist_r, %ecx\n+        movl    (%eax,%ecx,4), %eax     /* eax = lcode[hold & lmask] */\n+        jmp     .L_dodist_mmx\n+\n+.align 16,0x90\n+.L_clip_window_mmx:\n+#define nbytes_r %ecx\n+        movl    %eax, nbytes_r\n+        movl    wsize(%esp), %eax       /* prepare for dist compare */\n+        negl    nbytes_r                /* nbytes = -nbytes */\n+        movl    window(%esp), from_r    /* from = window */\n+\n+        cmpl    dist_r, %eax\n+        jb      .L_invalid_distance_too_far /* if (dist > wsize) */\n+\n+        addl    dist_r, nbytes_r        /* nbytes = dist - nbytes */\n+        cmpl    $0, write(%esp)\n+        jne     .L_wrap_around_window_mmx /* if (write != 0) */\n+\n+        subl    nbytes_r, %eax\n+        addl    %eax, from_r            /* from += wsize - nbytes */\n+\n+        cmpl    nbytes_r, len_r\n+        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */\n+\n+        subl    nbytes_r, len_r         /* len -= nbytes */\n+        rep     movsb\n+        movl    out_r, from_r\n+        subl    dist_r, from_r          /* from = out - dist */\n+        jmp     .L_do_copy1_mmx\n+\n+        cmpl    nbytes_r, len_r\n+        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */\n+\n+        subl    nbytes_r, len_r         /* len -= nbytes */\n+        rep     movsb\n+        movl    out_r, from_r\n+        subl    dist_r, from_r          /* from = out - dist */\n+        jmp     .L_do_copy1_mmx\n+\n+.L_wrap_around_window_mmx:\n+#define write_r %eax\n+        movl    write(%esp), write_r\n+        cmpl    write_r, nbytes_r\n+        jbe     .L_contiguous_in_window_mmx /* if (write >= nbytes) */\n+\n+        addl    wsize(%esp), from_r\n+        addl    write_r, from_r\n+        subl    nbytes_r, from_r        /* from += wsize + write - nbytes */\n+        subl    write_r, nbytes_r       /* nbytes -= write */\n+#undef write_r\n+\n+        cmpl    nbytes_r, len_r\n+        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */\n+\n+        subl    nbytes_r, len_r         /* len -= nbytes */\n+        rep     movsb\n+        movl    window(%esp), from_r    /* from = window */\n+        movl    write(%esp), nbytes_r   /* nbytes = write */\n+        cmpl    nbytes_r, len_r\n+        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */\n+\n+        subl    nbytes_r, len_r         /* len -= nbytes */\n+        rep     movsb\n+        movl    out_r, from_r\n+        subl    dist_r, from_r          /* from = out - dist */\n+        jmp     .L_do_copy1_mmx\n+\n+.L_contiguous_in_window_mmx:\n+#define write_r %eax\n+        addl    write_r, from_r\n+        subl    nbytes_r, from_r        /* from += write - nbytes */\n+#undef write_r\n+\n+        cmpl    nbytes_r, len_r\n+        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */\n+\n+        subl    nbytes_r, len_r         /* len -= nbytes */\n+        rep     movsb\n+        movl    out_r, from_r\n+        subl    dist_r, from_r          /* from = out - dist */\n+\n+.L_do_copy1_mmx:\n+#undef nbytes_r\n+#define in_r %esi\n+        movl    len_r, %ecx\n+        rep     movsb\n+\n+        movl    in(%esp), in_r          /* move in back to %esi, toss from */\n+        movl    lcode(%esp), %ebx       /* move lcode back to %ebx, toss dist */\n+        jmp     .L_while_test_mmx\n+\n+#undef hold_r\n+#undef bitslong_r\n+\n+#endif /* USE_MMX || RUN_TIME_MMX */\n+\n+\n+/*** USE_MMX, NO_MMX, and RUNTIME_MMX from here on ***/\n+\n+.L_invalid_distance_code:\n+        /* else {\n+         *   strm->msg = \"invalid distance code\";\n+         *   state->mode = BAD;\n+         * }\n+         */\n+        movl    $.L_invalid_distance_code_msg, %ecx\n+        movl    $INFLATE_MODE_BAD, %edx\n+        jmp     .L_update_stream_state\n+\n+.L_test_for_end_of_block:\n+        /* else if (op & 32) {\n+         *   state->mode = TYPE;\n+         *   break;\n+         * }\n+         */\n+        testb   $32, %al\n+        jz      .L_invalid_literal_length_code  /* if ((op & 32) == 0) */\n+\n+        movl    $0, %ecx\n+        movl    $INFLATE_MODE_TYPE, %edx\n+        jmp     .L_update_stream_state\n+\n+.L_invalid_literal_length_code:\n+        /* else {\n+         *   strm->msg = \"invalid literal/length code\";\n+         *   state->mode = BAD;\n+         * }\n+         */\n+        movl    $.L_invalid_literal_length_code_msg, %ecx\n+        movl    $INFLATE_MODE_BAD, %edx\n+        jmp     .L_update_stream_state\n+\n+.L_invalid_distance_too_far:\n+        /* strm->msg = \"invalid distance too far back\";\n+         * state->mode = BAD;\n+         */\n+        movl    in(%esp), in_r          /* from_r has in's reg, put in back */\n+        movl    $.L_invalid_distance_too_far_msg, %ecx\n+        movl    $INFLATE_MODE_BAD, %edx\n+        jmp     .L_update_stream_state\n+\n+.L_update_stream_state:\n+        /* set strm->msg = %ecx, strm->state->mode = %edx */\n+        movl    strm_sp(%esp), %eax\n+        testl   %ecx, %ecx              /* if (msg != NULL) */\n+        jz      .L_skip_msg\n+        movl    %ecx, msg_strm(%eax)    /* strm->msg = msg */\n+.L_skip_msg:\n+        movl    state_strm(%eax), %eax  /* state = strm->state */\n+        movl    %edx, mode_state(%eax)  /* state->mode = edx (BAD | TYPE) */\n+        jmp     .L_break_loop\n+\n+.align 32,0x90\n+.L_break_loop:\n+\n+/*\n+ * Regs:\n+ *\n+ * bits = %ebp when mmx, and in %ebx when non-mmx\n+ * hold = %hold_mm when mmx, and in %ebp when non-mmx\n+ * in   = %esi\n+ * out  = %edi\n+ */\n+\n+#if defined( USE_MMX ) || defined( RUN_TIME_MMX )\n+\n+#if defined( RUN_TIME_MMX )\n+\n+        cmpl    $DO_USE_MMX, inflate_fast_use_mmx\n+        jne     .L_update_next_in\n+\n+#endif /* RUN_TIME_MMX */\n+\n+        movl    %ebp, %ebx\n+\n+.L_update_next_in:\n+\n+#endif\n+\n+#define strm_r  %eax\n+#define state_r %edx\n+\n+        /* len = bits >> 3;\n+         * in -= len;\n+         * bits -= len << 3;\n+         * hold &= (1U << bits) - 1;\n+         * state->hold = hold;\n+         * state->bits = bits;\n+         * strm->next_in = in;\n+         * strm->next_out = out;\n+         */\n+        movl    strm_sp(%esp), strm_r\n+        movl    %ebx, %ecx\n+        movl    state_strm(strm_r), state_r\n+        shrl    $3, %ecx\n+        subl    %ecx, in_r\n+        shll    $3, %ecx\n+        subl    %ecx, %ebx\n+        movl    out_r, next_out_strm(strm_r)\n+        movl    %ebx, bits_state(state_r)\n+        movl    %ebx, %ecx\n+\n+        leal    buf(%esp), %ebx\n+        cmpl    %ebx, last(%esp)\n+        jne     .L_buf_not_used         /* if buf != last */\n+\n+        subl    %ebx, in_r              /* in -= buf */\n+        movl    next_in_strm(strm_r), %ebx\n+        movl    %ebx, last(%esp)        /* last = strm->next_in */\n+        addl    %ebx, in_r              /* in += strm->next_in */\n+        movl    avail_in_strm(strm_r), %ebx\n+        subl    $11, %ebx\n+        addl    %ebx, last(%esp)    /* last = &strm->next_in[ avail_in - 11 ] */\n+\n+.L_buf_not_used:\n+        movl    in_r, next_in_strm(strm_r)\n+\n+        movl    $1, %ebx\n+        shll    %cl, %ebx\n+        decl    %ebx\n+\n+#if defined( USE_MMX ) || defined( RUN_TIME_MMX )\n+\n+#if defined( RUN_TIME_MMX )\n+\n+        cmpl    $DO_USE_MMX, inflate_fast_use_mmx\n+        jne     .L_update_hold\n+\n+#endif /* RUN_TIME_MMX */\n+\n+        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */\n+        movd    hold_mm, %ebp\n+\n+        emms\n+\n+.L_update_hold:\n+\n+#endif /* USE_MMX || RUN_TIME_MMX */\n+\n+        andl    %ebx, %ebp\n+        movl    %ebp, hold_state(state_r)\n+\n+#define last_r %ebx\n+\n+        /* strm->avail_in = in < last ? 11 + (last - in) : 11 - (in - last) */\n+        movl    last(%esp), last_r\n+        cmpl    in_r, last_r\n+        jbe     .L_last_is_smaller     /* if (in >= last) */\n+\n+        subl    in_r, last_r           /* last -= in */\n+        addl    $11, last_r            /* last += 11 */\n+        movl    last_r, avail_in_strm(strm_r)\n+        jmp     .L_fixup_out\n+.L_last_is_smaller:\n+        subl    last_r, in_r           /* in -= last */\n+        negl    in_r                   /* in = -in */\n+        addl    $11, in_r              /* in += 11 */\n+        movl    in_r, avail_in_strm(strm_r)\n+\n+#undef last_r\n+#define end_r %ebx\n+\n+.L_fixup_out:\n+        /* strm->avail_out = out < end ? 257 + (end - out) : 257 - (out - end)*/\n+        movl    end(%esp), end_r\n+        cmpl    out_r, end_r\n+        jbe     .L_end_is_smaller      /* if (out >= end) */\n+\n+        subl    out_r, end_r           /* end -= out */\n+        addl    $257, end_r            /* end += 257 */\n+        movl    end_r, avail_out_strm(strm_r)\n+        jmp     .L_done\n+.L_end_is_smaller:\n+        subl    end_r, out_r           /* out -= end */\n+        negl    out_r                  /* out = -out */\n+        addl    $257, out_r            /* out += 257 */\n+        movl    out_r, avail_out_strm(strm_r)\n+\n+#undef end_r\n+#undef strm_r\n+#undef state_r\n+\n+.L_done:\n+        addl    $local_var_size, %esp\n+        popf\n+        popl    %ebx\n+        popl    %ebp\n+        popl    %esi\n+        popl    %edi\n+        ret\n+\n+#if defined( GAS_ELF )\n+/* elf info */\n+.type inflate_fast,@function\n+.size inflate_fast,.-inflate_fast\n+#endif"}, {"sha": "f7b319ab91a7c7922da02abb8e856d62545304a2", "filename": "zlib/contrib/iostream3/README", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fiostream3%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fiostream3%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fiostream3%2FREADME?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,35 @@\n+These classes provide a C++ stream interface to the zlib library. It allows you\n+to do things like:\n+\n+  gzofstream outf(\"blah.gz\");\n+  outf << \"These go into the gzip file \" << 123 << endl;\n+\n+It does this by deriving a specialized stream buffer for gzipped files, which is\n+the way Stroustrup would have done it. :->\n+\n+The gzifstream and gzofstream classes were originally written by Kevin Ruland\n+and made available in the zlib contrib/iostream directory. The older version still\n+compiles under gcc 2.xx, but not under gcc 3.xx, which sparked the development of\n+this version.\n+\n+The new classes are as standard-compliant as possible, closely following the\n+approach of the standard library's fstream classes. It compiles under gcc versions\n+3.2 and 3.3, but not under gcc 2.xx. This is mainly due to changes in the standard\n+library naming scheme. The new version of gzifstream/gzofstream/gzfilebuf differs\n+from the previous one in the following respects:\n+- added showmanyc\n+- added setbuf, with support for unbuffered output via setbuf(0,0)\n+- a few bug fixes of stream behavior\n+- gzipped output file opened with default compression level instead of maximum level\n+- setcompressionlevel()/strategy() members replaced by single setcompression()\n+\n+The code is provided \"as is\", with the permission to use, copy, modify, distribute\n+and sell it for any purpose without fee.\n+\n+Ludwig Schwardt\n+<schwardt@sun.ac.za>\n+\n+DSP Lab\n+Electrical & Electronic Engineering Department\n+University of Stellenbosch\n+South Africa"}, {"sha": "7032f97be0469e50397f8e88d256802568701378", "filename": "zlib/contrib/iostream3/TODO", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fiostream3%2FTODO", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fiostream3%2FTODO", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fiostream3%2FTODO?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,17 @@\n+Possible upgrades to gzfilebuf:\n+\n+- The ability to do putback (e.g. putbackfail)\n+\n+- The ability to seek (zlib supports this, but could be slow/tricky)\n+\n+- Simultaneous read/write access (does it make sense?)\n+\n+- Support for ios_base::ate open mode\n+\n+- Locale support?\n+\n+- Check public interface to see which calls give problems\n+  (due to dependence on library internals)\n+\n+- Override operator<<(ostream&, gzfilebuf*) to allow direct copying\n+  of stream buffer to stream ( i.e. os << is.rdbuf(); )"}, {"sha": "94235334f25cd5c5e2464d66f4c8ecf8ce161400", "filename": "zlib/contrib/iostream3/test.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fiostream3%2Ftest.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fiostream3%2Ftest.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fiostream3%2Ftest.cc?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,50 @@\n+/*\n+ * Test program for gzifstream and gzofstream\n+ *\n+ * by Ludwig Schwardt <schwardt@sun.ac.za>\n+ * original version by Kevin Ruland <kevin@rodin.wustl.edu>\n+ */\n+\n+#include \"zfstream.h\"\n+#include <iostream>      // for cout\n+\n+int main() {\n+\n+  gzofstream outf;\n+  gzifstream inf;\n+  char buf[80];\n+\n+  outf.open(\"test1.txt.gz\");\n+  outf << \"The quick brown fox sidestepped the lazy canine\\n\"\n+       << 1.3 << \"\\nPlan \" << 9 << std::endl;\n+  outf.close();\n+  std::cout << \"Wrote the following message to 'test1.txt.gz' (check with zcat or zless):\\n\"\n+            << \"The quick brown fox sidestepped the lazy canine\\n\"\n+            << 1.3 << \"\\nPlan \" << 9 << std::endl;\n+\n+  std::cout << \"\\nReading 'test1.txt.gz' (buffered) produces:\\n\";\n+  inf.open(\"test1.txt.gz\");\n+  while (inf.getline(buf,80,'\\n')) {\n+    std::cout << buf << \"\\t(\" << inf.rdbuf()->in_avail() << \" chars left in buffer)\\n\";\n+  }\n+  inf.close();\n+\n+  outf.rdbuf()->pubsetbuf(0,0);\n+  outf.open(\"test2.txt.gz\");\n+  outf << setcompression(Z_NO_COMPRESSION)\n+       << \"The quick brown fox sidestepped the lazy canine\\n\"\n+       << 1.3 << \"\\nPlan \" << 9 << std::endl;\n+  outf.close();\n+  std::cout << \"\\nWrote the same message to 'test2.txt.gz' in uncompressed form\";\n+\n+  std::cout << \"\\nReading 'test2.txt.gz' (unbuffered) produces:\\n\";\n+  inf.rdbuf()->pubsetbuf(0,0);\n+  inf.open(\"test2.txt.gz\");\n+  while (inf.getline(buf,80,'\\n')) {\n+    std::cout << buf << \"\\t(\" << inf.rdbuf()->in_avail() << \" chars left in buffer)\\n\";\n+  }\n+  inf.close();\n+\n+  return 0;\n+\n+}"}, {"sha": "94eb933444a967755a3aa81ee1d5dcb6435153b8", "filename": "zlib/contrib/iostream3/zfstream.cc", "status": "added", "additions": 479, "deletions": 0, "changes": 479, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fiostream3%2Fzfstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fiostream3%2Fzfstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fiostream3%2Fzfstream.cc?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,479 @@\n+/*\n+ * A C++ I/O streams interface to the zlib gz* functions\n+ *\n+ * by Ludwig Schwardt <schwardt@sun.ac.za>\n+ * original version by Kevin Ruland <kevin@rodin.wustl.edu>\n+ *\n+ * This version is standard-compliant and compatible with gcc 3.x.\n+ */\n+\n+#include \"zfstream.h\"\n+#include <cstring>          // for strcpy, strcat, strlen (mode strings)\n+#include <cstdio>           // for BUFSIZ\n+\n+// Internal buffer sizes (default and \"unbuffered\" versions)\n+#define BIGBUFSIZE BUFSIZ\n+#define SMALLBUFSIZE 1\n+\n+/*****************************************************************************/\n+\n+// Default constructor\n+gzfilebuf::gzfilebuf()\n+: file(NULL), io_mode(std::ios_base::openmode(0)), own_fd(false),\n+  buffer(NULL), buffer_size(BIGBUFSIZE), own_buffer(true)\n+{\n+  // No buffers to start with\n+  this->disable_buffer();\n+}\n+\n+// Destructor\n+gzfilebuf::~gzfilebuf()\n+{\n+  // Sync output buffer and close only if responsible for file\n+  // (i.e. attached streams should be left open at this stage)\n+  this->sync();\n+  if (own_fd)\n+    this->close();\n+  // Make sure internal buffer is deallocated\n+  this->disable_buffer();\n+}\n+\n+// Set compression level and strategy\n+int\n+gzfilebuf::setcompression(int comp_level,\n+                          int comp_strategy)\n+{\n+  return gzsetparams(file, comp_level, comp_strategy);\n+}\n+\n+// Open gzipped file\n+gzfilebuf*\n+gzfilebuf::open(const char *name,\n+                std::ios_base::openmode mode)\n+{\n+  // Fail if file already open\n+  if (this->is_open())\n+    return NULL;\n+  // Don't support simultaneous read/write access (yet)\n+  if ((mode & std::ios_base::in) && (mode & std::ios_base::out))\n+    return NULL;\n+\n+  // Build mode string for gzopen and check it [27.8.1.3.2]\n+  char char_mode[6] = \"\\0\\0\\0\\0\\0\";\n+  if (!this->open_mode(mode, char_mode))\n+    return NULL;\n+\n+  // Attempt to open file\n+  if ((file = gzopen(name, char_mode)) == NULL)\n+    return NULL;\n+\n+  // On success, allocate internal buffer and set flags\n+  this->enable_buffer();\n+  io_mode = mode;\n+  own_fd = true;\n+  return this;\n+}\n+\n+// Attach to gzipped file\n+gzfilebuf*\n+gzfilebuf::attach(int fd,\n+                  std::ios_base::openmode mode)\n+{\n+  // Fail if file already open\n+  if (this->is_open())\n+    return NULL;\n+  // Don't support simultaneous read/write access (yet)\n+  if ((mode & std::ios_base::in) && (mode & std::ios_base::out))\n+    return NULL;\n+\n+  // Build mode string for gzdopen and check it [27.8.1.3.2]\n+  char char_mode[6] = \"\\0\\0\\0\\0\\0\";\n+  if (!this->open_mode(mode, char_mode))\n+    return NULL;\n+\n+  // Attempt to attach to file\n+  if ((file = gzdopen(fd, char_mode)) == NULL)\n+    return NULL;\n+\n+  // On success, allocate internal buffer and set flags\n+  this->enable_buffer();\n+  io_mode = mode;\n+  own_fd = false;\n+  return this;\n+}\n+\n+// Close gzipped file\n+gzfilebuf*\n+gzfilebuf::close()\n+{\n+  // Fail immediately if no file is open\n+  if (!this->is_open())\n+    return NULL;\n+  // Assume success\n+  gzfilebuf* retval = this;\n+  // Attempt to sync and close gzipped file\n+  if (this->sync() == -1)\n+    retval = NULL;\n+  if (gzclose(file) < 0)\n+    retval = NULL;\n+  // File is now gone anyway (postcondition [27.8.1.3.8])\n+  file = NULL;\n+  own_fd = false;\n+  // Destroy internal buffer if it exists\n+  this->disable_buffer();\n+  return retval;\n+}\n+\n+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n+\n+// Convert int open mode to mode string\n+bool\n+gzfilebuf::open_mode(std::ios_base::openmode mode,\n+                     char* c_mode) const\n+{\n+  bool testb = mode & std::ios_base::binary;\n+  bool testi = mode & std::ios_base::in;\n+  bool testo = mode & std::ios_base::out;\n+  bool testt = mode & std::ios_base::trunc;\n+  bool testa = mode & std::ios_base::app;\n+\n+  // Check for valid flag combinations - see [27.8.1.3.2] (Table 92)\n+  // Original zfstream hardcoded the compression level to maximum here...\n+  // Double the time for less than 1% size improvement seems\n+  // excessive though - keeping it at the default level\n+  // To change back, just append \"9\" to the next three mode strings\n+  if (!testi && testo && !testt && !testa)\n+    strcpy(c_mode, \"w\");\n+  if (!testi && testo && !testt && testa)\n+    strcpy(c_mode, \"a\");\n+  if (!testi && testo && testt && !testa)\n+    strcpy(c_mode, \"w\");\n+  if (testi && !testo && !testt && !testa)\n+    strcpy(c_mode, \"r\");\n+  // No read/write mode yet\n+//  if (testi && testo && !testt && !testa)\n+//    strcpy(c_mode, \"r+\");\n+//  if (testi && testo && testt && !testa)\n+//    strcpy(c_mode, \"w+\");\n+\n+  // Mode string should be empty for invalid combination of flags\n+  if (strlen(c_mode) == 0)\n+    return false;\n+  if (testb)\n+    strcat(c_mode, \"b\");\n+  return true;\n+}\n+\n+// Determine number of characters in internal get buffer\n+std::streamsize\n+gzfilebuf::showmanyc()\n+{\n+  // Calls to underflow will fail if file not opened for reading\n+  if (!this->is_open() || !(io_mode & std::ios_base::in))\n+    return -1;\n+  // Make sure get area is in use\n+  if (this->gptr() && (this->gptr() < this->egptr()))\n+    return std::streamsize(this->egptr() - this->gptr());\n+  else\n+    return 0;\n+}\n+\n+// Fill get area from gzipped file\n+gzfilebuf::int_type\n+gzfilebuf::underflow()\n+{\n+  // If something is left in the get area by chance, return it\n+  // (this shouldn't normally happen, as underflow is only supposed\n+  // to be called when gptr >= egptr, but it serves as error check)\n+  if (this->gptr() && (this->gptr() < this->egptr()))\n+    return traits_type::to_int_type(*(this->gptr()));\n+\n+  // If the file hasn't been opened for reading, produce error\n+  if (!this->is_open() || !(io_mode & std::ios_base::in))\n+    return traits_type::eof();\n+\n+  // Attempt to fill internal buffer from gzipped file\n+  // (buffer must be guaranteed to exist...)\n+  int bytes_read = gzread(file, buffer, buffer_size);\n+  // Indicates error or EOF\n+  if (bytes_read <= 0)\n+  {\n+    // Reset get area\n+    this->setg(buffer, buffer, buffer);\n+    return traits_type::eof();\n+  }\n+  // Make all bytes read from file available as get area\n+  this->setg(buffer, buffer, buffer + bytes_read);\n+\n+  // Return next character in get area\n+  return traits_type::to_int_type(*(this->gptr()));\n+}\n+\n+// Write put area to gzipped file\n+gzfilebuf::int_type\n+gzfilebuf::overflow(int_type c)\n+{\n+  // Determine whether put area is in use\n+  if (this->pbase())\n+  {\n+    // Double-check pointer range\n+    if (this->pptr() > this->epptr() || this->pptr() < this->pbase())\n+      return traits_type::eof();\n+    // Add extra character to buffer if not EOF\n+    if (!traits_type::eq_int_type(c, traits_type::eof()))\n+    {\n+      *(this->pptr()) = traits_type::to_char_type(c);\n+      this->pbump(1);\n+    }\n+    // Number of characters to write to file\n+    int bytes_to_write = this->pptr() - this->pbase();\n+    // Overflow doesn't fail if nothing is to be written\n+    if (bytes_to_write > 0)\n+    {\n+      // If the file hasn't been opened for writing, produce error\n+      if (!this->is_open() || !(io_mode & std::ios_base::out))\n+        return traits_type::eof();\n+      // If gzipped file won't accept all bytes written to it, fail\n+      if (gzwrite(file, this->pbase(), bytes_to_write) != bytes_to_write)\n+        return traits_type::eof();\n+      // Reset next pointer to point to pbase on success\n+      this->pbump(-bytes_to_write);\n+    }\n+  }\n+  // Write extra character to file if not EOF\n+  else if (!traits_type::eq_int_type(c, traits_type::eof()))\n+  {\n+    // If the file hasn't been opened for writing, produce error\n+    if (!this->is_open() || !(io_mode & std::ios_base::out))\n+      return traits_type::eof();\n+    // Impromptu char buffer (allows \"unbuffered\" output)\n+    char_type last_char = traits_type::to_char_type(c);\n+    // If gzipped file won't accept this character, fail\n+    if (gzwrite(file, &last_char, 1) != 1)\n+      return traits_type::eof();\n+  }\n+\n+  // If you got here, you have succeeded (even if c was EOF)\n+  // The return value should therefore be non-EOF\n+  if (traits_type::eq_int_type(c, traits_type::eof()))\n+    return traits_type::not_eof(c);\n+  else\n+    return c;\n+}\n+\n+// Assign new buffer\n+std::streambuf*\n+gzfilebuf::setbuf(char_type* p,\n+                  std::streamsize n)\n+{\n+  // First make sure stuff is sync'ed, for safety\n+  if (this->sync() == -1)\n+    return NULL;\n+  // If buffering is turned off on purpose via setbuf(0,0), still allocate one...\n+  // \"Unbuffered\" only really refers to put [27.8.1.4.10], while get needs at\n+  // least a buffer of size 1 (very inefficient though, therefore make it bigger?)\n+  // This follows from [27.5.2.4.3]/12 (gptr needs to point at something, it seems)\n+  if (!p || !n)\n+  {\n+    // Replace existing buffer (if any) with small internal buffer\n+    this->disable_buffer();\n+    buffer = NULL;\n+    buffer_size = 0;\n+    own_buffer = true;\n+    this->enable_buffer();\n+  }\n+  else\n+  {\n+    // Replace existing buffer (if any) with external buffer\n+    this->disable_buffer();\n+    buffer = p;\n+    buffer_size = n;\n+    own_buffer = false;\n+    this->enable_buffer();\n+  }\n+  return this;\n+}\n+\n+// Write put area to gzipped file (i.e. ensures that put area is empty)\n+int\n+gzfilebuf::sync()\n+{\n+  return traits_type::eq_int_type(this->overflow(), traits_type::eof()) ? -1 : 0;\n+}\n+\n+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n+\n+// Allocate internal buffer\n+void\n+gzfilebuf::enable_buffer()\n+{\n+  // If internal buffer required, allocate one\n+  if (own_buffer && !buffer)\n+  {\n+    // Check for buffered vs. \"unbuffered\"\n+    if (buffer_size > 0)\n+    {\n+      // Allocate internal buffer\n+      buffer = new char_type[buffer_size];\n+      // Get area starts empty and will be expanded by underflow as need arises\n+      this->setg(buffer, buffer, buffer);\n+      // Setup entire internal buffer as put area.\n+      // The one-past-end pointer actually points to the last element of the buffer,\n+      // so that overflow(c) can safely add the extra character c to the sequence.\n+      // These pointers remain in place for the duration of the buffer\n+      this->setp(buffer, buffer + buffer_size - 1);\n+    }\n+    else\n+    {\n+      // Even in \"unbuffered\" case, (small?) get buffer is still required\n+      buffer_size = SMALLBUFSIZE;\n+      buffer = new char_type[buffer_size];\n+      this->setg(buffer, buffer, buffer);\n+      // \"Unbuffered\" means no put buffer\n+      this->setp(0, 0);\n+    }\n+  }\n+  else\n+  {\n+    // If buffer already allocated, reset buffer pointers just to make sure no\n+    // stale chars are lying around\n+    this->setg(buffer, buffer, buffer);\n+    this->setp(buffer, buffer + buffer_size - 1);\n+  }\n+}\n+\n+// Destroy internal buffer\n+void\n+gzfilebuf::disable_buffer()\n+{\n+  // If internal buffer exists, deallocate it\n+  if (own_buffer && buffer)\n+  {\n+    // Preserve unbuffered status by zeroing size\n+    if (!this->pbase())\n+      buffer_size = 0;\n+    delete[] buffer;\n+    buffer = NULL;\n+    this->setg(0, 0, 0);\n+    this->setp(0, 0);\n+  }\n+  else\n+  {\n+    // Reset buffer pointers to initial state if external buffer exists\n+    this->setg(buffer, buffer, buffer);\n+    if (buffer)\n+      this->setp(buffer, buffer + buffer_size - 1);\n+    else\n+      this->setp(0, 0);\n+  }\n+}\n+\n+/*****************************************************************************/\n+\n+// Default constructor initializes stream buffer\n+gzifstream::gzifstream()\n+: std::istream(NULL), sb()\n+{ this->init(&sb); }\n+\n+// Initialize stream buffer and open file\n+gzifstream::gzifstream(const char* name,\n+                       std::ios_base::openmode mode)\n+: std::istream(NULL), sb()\n+{\n+  this->init(&sb);\n+  this->open(name, mode);\n+}\n+\n+// Initialize stream buffer and attach to file\n+gzifstream::gzifstream(int fd,\n+                       std::ios_base::openmode mode)\n+: std::istream(NULL), sb()\n+{\n+  this->init(&sb);\n+  this->attach(fd, mode);\n+}\n+\n+// Open file and go into fail() state if unsuccessful\n+void\n+gzifstream::open(const char* name,\n+                 std::ios_base::openmode mode)\n+{\n+  if (!sb.open(name, mode | std::ios_base::in))\n+    this->setstate(std::ios_base::failbit);\n+  else\n+    this->clear();\n+}\n+\n+// Attach to file and go into fail() state if unsuccessful\n+void\n+gzifstream::attach(int fd,\n+                   std::ios_base::openmode mode)\n+{\n+  if (!sb.attach(fd, mode | std::ios_base::in))\n+    this->setstate(std::ios_base::failbit);\n+  else\n+    this->clear();\n+}\n+\n+// Close file\n+void\n+gzifstream::close()\n+{\n+  if (!sb.close())\n+    this->setstate(std::ios_base::failbit);\n+}\n+\n+/*****************************************************************************/\n+\n+// Default constructor initializes stream buffer\n+gzofstream::gzofstream()\n+: std::ostream(NULL), sb()\n+{ this->init(&sb); }\n+\n+// Initialize stream buffer and open file\n+gzofstream::gzofstream(const char* name,\n+                       std::ios_base::openmode mode)\n+: std::ostream(NULL), sb()\n+{\n+  this->init(&sb);\n+  this->open(name, mode);\n+}\n+\n+// Initialize stream buffer and attach to file\n+gzofstream::gzofstream(int fd,\n+                       std::ios_base::openmode mode)\n+: std::ostream(NULL), sb()\n+{\n+  this->init(&sb);\n+  this->attach(fd, mode);\n+}\n+\n+// Open file and go into fail() state if unsuccessful\n+void\n+gzofstream::open(const char* name,\n+                 std::ios_base::openmode mode)\n+{\n+  if (!sb.open(name, mode | std::ios_base::out))\n+    this->setstate(std::ios_base::failbit);\n+  else\n+    this->clear();\n+}\n+\n+// Attach to file and go into fail() state if unsuccessful\n+void\n+gzofstream::attach(int fd,\n+                   std::ios_base::openmode mode)\n+{\n+  if (!sb.attach(fd, mode | std::ios_base::out))\n+    this->setstate(std::ios_base::failbit);\n+  else\n+    this->clear();\n+}\n+\n+// Close file\n+void\n+gzofstream::close()\n+{\n+  if (!sb.close())\n+    this->setstate(std::ios_base::failbit);\n+}"}, {"sha": "8574479ae1e7cd01cc0b0aaed2f457f7b1669603", "filename": "zlib/contrib/iostream3/zfstream.h", "status": "added", "additions": 466, "deletions": 0, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fiostream3%2Fzfstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fiostream3%2Fzfstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fiostream3%2Fzfstream.h?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,466 @@\n+/*\n+ * A C++ I/O streams interface to the zlib gz* functions\n+ *\n+ * by Ludwig Schwardt <schwardt@sun.ac.za>\n+ * original version by Kevin Ruland <kevin@rodin.wustl.edu>\n+ *\n+ * This version is standard-compliant and compatible with gcc 3.x.\n+ */\n+\n+#ifndef ZFSTREAM_H\n+#define ZFSTREAM_H\n+\n+#include <istream>  // not iostream, since we don't need cin/cout\n+#include <ostream>\n+#include \"zlib.h\"\n+\n+/*****************************************************************************/\n+\n+/**\n+ *  @brief  Gzipped file stream buffer class.\n+ *\n+ *  This class implements basic_filebuf for gzipped files. It doesn't yet support\n+ *  seeking (allowed by zlib but slow/limited), putback and read/write access\n+ *  (tricky). Otherwise, it attempts to be a drop-in replacement for the standard\n+ *  file streambuf.\n+*/\n+class gzfilebuf : public std::streambuf\n+{\n+public:\n+  //  Default constructor.\n+  gzfilebuf();\n+\n+  //  Destructor.\n+  virtual\n+  ~gzfilebuf();\n+\n+  /**\n+   *  @brief  Set compression level and strategy on the fly.\n+   *  @param  comp_level  Compression level (see zlib.h for allowed values)\n+   *  @param  comp_strategy  Compression strategy (see zlib.h for allowed values)\n+   *  @return  Z_OK on success, Z_STREAM_ERROR otherwise.\n+   *\n+   *  Unfortunately, these parameters cannot be modified separately, as the\n+   *  previous zfstream version assumed. Since the strategy is seldom changed,\n+   *  it can default and setcompression(level) then becomes like the old\n+   *  setcompressionlevel(level).\n+  */\n+  int\n+  setcompression(int comp_level,\n+                 int comp_strategy = Z_DEFAULT_STRATEGY);\n+\n+  /**\n+   *  @brief  Check if file is open.\n+   *  @return  True if file is open.\n+  */\n+  bool\n+  is_open() const { return (file != NULL); }\n+\n+  /**\n+   *  @brief  Open gzipped file.\n+   *  @param  name  File name.\n+   *  @param  mode  Open mode flags.\n+   *  @return  @c this on success, NULL on failure.\n+  */\n+  gzfilebuf*\n+  open(const char* name,\n+       std::ios_base::openmode mode);\n+\n+  /**\n+   *  @brief  Attach to already open gzipped file.\n+   *  @param  fd  File descriptor.\n+   *  @param  mode  Open mode flags.\n+   *  @return  @c this on success, NULL on failure.\n+  */\n+  gzfilebuf*\n+  attach(int fd,\n+         std::ios_base::openmode mode);\n+\n+  /**\n+   *  @brief  Close gzipped file.\n+   *  @return  @c this on success, NULL on failure.\n+  */\n+  gzfilebuf*\n+  close();\n+\n+protected:\n+  /**\n+   *  @brief  Convert ios open mode int to mode string used by zlib.\n+   *  @return  True if valid mode flag combination.\n+  */\n+  bool\n+  open_mode(std::ios_base::openmode mode,\n+            char* c_mode) const;\n+\n+  /**\n+   *  @brief  Number of characters available in stream buffer.\n+   *  @return  Number of characters.\n+   *\n+   *  This indicates number of characters in get area of stream buffer.\n+   *  These characters can be read without accessing the gzipped file.\n+  */\n+  virtual std::streamsize\n+  showmanyc();\n+\n+  /**\n+   *  @brief  Fill get area from gzipped file.\n+   *  @return  First character in get area on success, EOF on error.\n+   *\n+   *  This actually reads characters from gzipped file to stream\n+   *  buffer. Always buffered.\n+  */\n+  virtual int_type\n+  underflow();\n+\n+  /**\n+   *  @brief  Write put area to gzipped file.\n+   *  @param  c  Extra character to add to buffer contents.\n+   *  @return  Non-EOF on success, EOF on error.\n+   *\n+   *  This actually writes characters in stream buffer to\n+   *  gzipped file. With unbuffered output this is done one\n+   *  character at a time.\n+  */\n+  virtual int_type\n+  overflow(int_type c = traits_type::eof());\n+\n+  /**\n+   *  @brief  Installs external stream buffer.\n+   *  @param  p  Pointer to char buffer.\n+   *  @param  n  Size of external buffer.\n+   *  @return  @c this on success, NULL on failure.\n+   *\n+   *  Call setbuf(0,0) to enable unbuffered output.\n+  */\n+  virtual std::streambuf*\n+  setbuf(char_type* p,\n+         std::streamsize n);\n+\n+  /**\n+   *  @brief  Flush stream buffer to file.\n+   *  @return  0 on success, -1 on error.\n+   *\n+   *  This calls underflow(EOF) to do the job.\n+  */\n+  virtual int\n+  sync();\n+\n+//\n+// Some future enhancements\n+//\n+//  virtual int_type uflow();\n+//  virtual int_type pbackfail(int_type c = traits_type::eof());\n+//  virtual pos_type\n+//  seekoff(off_type off,\n+//          std::ios_base::seekdir way,\n+//          std::ios_base::openmode mode = std::ios_base::in|std::ios_base::out);\n+//  virtual pos_type\n+//  seekpos(pos_type sp,\n+//          std::ios_base::openmode mode = std::ios_base::in|std::ios_base::out);\n+\n+private:\n+  /**\n+   *  @brief  Allocate internal buffer.\n+   *\n+   *  This function is safe to call multiple times. It will ensure\n+   *  that a proper internal buffer exists if it is required. If the\n+   *  buffer already exists or is external, the buffer pointers will be\n+   *  reset to their original state.\n+  */\n+  void\n+  enable_buffer();\n+\n+  /**\n+   *  @brief  Destroy internal buffer.\n+   *\n+   *  This function is safe to call multiple times. It will ensure\n+   *  that the internal buffer is deallocated if it exists. In any\n+   *  case, it will also reset the buffer pointers.\n+  */\n+  void\n+  disable_buffer();\n+\n+  /**\n+   *  Underlying file pointer.\n+  */\n+  gzFile file;\n+\n+  /**\n+   *  Mode in which file was opened.\n+  */\n+  std::ios_base::openmode io_mode;\n+\n+  /**\n+   *  @brief  True if this object owns file descriptor.\n+   *\n+   *  This makes the class responsible for closing the file\n+   *  upon destruction.\n+  */\n+  bool own_fd;\n+\n+  /**\n+   *  @brief  Stream buffer.\n+   *\n+   *  For simplicity this remains allocated on the free store for the\n+   *  entire life span of the gzfilebuf object, unless replaced by setbuf.\n+  */\n+  char_type* buffer;\n+\n+  /**\n+   *  @brief  Stream buffer size.\n+   *\n+   *  Defaults to system default buffer size (typically 8192 bytes).\n+   *  Modified by setbuf.\n+  */\n+  std::streamsize buffer_size;\n+\n+  /**\n+   *  @brief  True if this object owns stream buffer.\n+   *\n+   *  This makes the class responsible for deleting the buffer\n+   *  upon destruction.\n+  */\n+  bool own_buffer;\n+};\n+\n+/*****************************************************************************/\n+\n+/**\n+ *  @brief  Gzipped file input stream class.\n+ *\n+ *  This class implements ifstream for gzipped files. Seeking and putback\n+ *  is not supported yet.\n+*/\n+class gzifstream : public std::istream\n+{\n+public:\n+  //  Default constructor\n+  gzifstream();\n+\n+  /**\n+   *  @brief  Construct stream on gzipped file to be opened.\n+   *  @param  name  File name.\n+   *  @param  mode  Open mode flags (forced to contain ios::in).\n+  */\n+  explicit\n+  gzifstream(const char* name,\n+             std::ios_base::openmode mode = std::ios_base::in);\n+\n+  /**\n+   *  @brief  Construct stream on already open gzipped file.\n+   *  @param  fd    File descriptor.\n+   *  @param  mode  Open mode flags (forced to contain ios::in).\n+  */\n+  explicit\n+  gzifstream(int fd,\n+             std::ios_base::openmode mode = std::ios_base::in);\n+\n+  /**\n+   *  Obtain underlying stream buffer.\n+  */\n+  gzfilebuf*\n+  rdbuf() const\n+  { return const_cast<gzfilebuf*>(&sb); }\n+\n+  /**\n+   *  @brief  Check if file is open.\n+   *  @return  True if file is open.\n+  */\n+  bool\n+  is_open() { return sb.is_open(); }\n+\n+  /**\n+   *  @brief  Open gzipped file.\n+   *  @param  name  File name.\n+   *  @param  mode  Open mode flags (forced to contain ios::in).\n+   *\n+   *  Stream will be in state good() if file opens successfully;\n+   *  otherwise in state fail(). This differs from the behavior of\n+   *  ifstream, which never sets the state to good() and therefore\n+   *  won't allow you to reuse the stream for a second file unless\n+   *  you manually clear() the state. The choice is a matter of\n+   *  convenience.\n+  */\n+  void\n+  open(const char* name,\n+       std::ios_base::openmode mode = std::ios_base::in);\n+\n+  /**\n+   *  @brief  Attach to already open gzipped file.\n+   *  @param  fd  File descriptor.\n+   *  @param  mode  Open mode flags (forced to contain ios::in).\n+   *\n+   *  Stream will be in state good() if attach succeeded; otherwise\n+   *  in state fail().\n+  */\n+  void\n+  attach(int fd,\n+         std::ios_base::openmode mode = std::ios_base::in);\n+\n+  /**\n+   *  @brief  Close gzipped file.\n+   *\n+   *  Stream will be in state fail() if close failed.\n+  */\n+  void\n+  close();\n+\n+private:\n+  /**\n+   *  Underlying stream buffer.\n+  */\n+  gzfilebuf sb;\n+};\n+\n+/*****************************************************************************/\n+\n+/**\n+ *  @brief  Gzipped file output stream class.\n+ *\n+ *  This class implements ofstream for gzipped files. Seeking and putback\n+ *  is not supported yet.\n+*/\n+class gzofstream : public std::ostream\n+{\n+public:\n+  //  Default constructor\n+  gzofstream();\n+\n+  /**\n+   *  @brief  Construct stream on gzipped file to be opened.\n+   *  @param  name  File name.\n+   *  @param  mode  Open mode flags (forced to contain ios::out).\n+  */\n+  explicit\n+  gzofstream(const char* name,\n+             std::ios_base::openmode mode = std::ios_base::out);\n+\n+  /**\n+   *  @brief  Construct stream on already open gzipped file.\n+   *  @param  fd    File descriptor.\n+   *  @param  mode  Open mode flags (forced to contain ios::out).\n+  */\n+  explicit\n+  gzofstream(int fd,\n+             std::ios_base::openmode mode = std::ios_base::out);\n+\n+  /**\n+   *  Obtain underlying stream buffer.\n+  */\n+  gzfilebuf*\n+  rdbuf() const\n+  { return const_cast<gzfilebuf*>(&sb); }\n+\n+  /**\n+   *  @brief  Check if file is open.\n+   *  @return  True if file is open.\n+  */\n+  bool\n+  is_open() { return sb.is_open(); }\n+\n+  /**\n+   *  @brief  Open gzipped file.\n+   *  @param  name  File name.\n+   *  @param  mode  Open mode flags (forced to contain ios::out).\n+   *\n+   *  Stream will be in state good() if file opens successfully;\n+   *  otherwise in state fail(). This differs from the behavior of\n+   *  ofstream, which never sets the state to good() and therefore\n+   *  won't allow you to reuse the stream for a second file unless\n+   *  you manually clear() the state. The choice is a matter of\n+   *  convenience.\n+  */\n+  void\n+  open(const char* name,\n+       std::ios_base::openmode mode = std::ios_base::out);\n+\n+  /**\n+   *  @brief  Attach to already open gzipped file.\n+   *  @param  fd  File descriptor.\n+   *  @param  mode  Open mode flags (forced to contain ios::out).\n+   *\n+   *  Stream will be in state good() if attach succeeded; otherwise\n+   *  in state fail().\n+  */\n+  void\n+  attach(int fd,\n+         std::ios_base::openmode mode = std::ios_base::out);\n+\n+  /**\n+   *  @brief  Close gzipped file.\n+   *\n+   *  Stream will be in state fail() if close failed.\n+  */\n+  void\n+  close();\n+\n+private:\n+  /**\n+   *  Underlying stream buffer.\n+  */\n+  gzfilebuf sb;\n+};\n+\n+/*****************************************************************************/\n+\n+/**\n+ *  @brief  Gzipped file output stream manipulator class.\n+ *\n+ *  This class defines a two-argument manipulator for gzofstream. It is used\n+ *  as base for the setcompression(int,int) manipulator.\n+*/\n+template<typename T1, typename T2>\n+  class gzomanip2\n+  {\n+  public:\n+    // Allows insertor to peek at internals\n+    template <typename Ta, typename Tb>\n+      friend gzofstream&\n+      operator<<(gzofstream&,\n+                 const gzomanip2<Ta,Tb>&);\n+\n+    // Constructor\n+    gzomanip2(gzofstream& (*f)(gzofstream&, T1, T2),\n+              T1 v1,\n+              T2 v2);\n+  private:\n+    // Underlying manipulator function\n+    gzofstream&\n+    (*func)(gzofstream&, T1, T2);\n+\n+    // Arguments for manipulator function\n+    T1 val1;\n+    T2 val2;\n+  };\n+\n+/*****************************************************************************/\n+\n+// Manipulator function thunks through to stream buffer\n+inline gzofstream&\n+setcompression(gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)\n+{\n+  (gzs.rdbuf())->setcompression(l, s);\n+  return gzs;\n+}\n+\n+// Manipulator constructor stores arguments\n+template<typename T1, typename T2>\n+  inline\n+  gzomanip2<T1,T2>::gzomanip2(gzofstream &(*f)(gzofstream &, T1, T2),\n+                              T1 v1,\n+                              T2 v2)\n+  : func(f), val1(v1), val2(v2)\n+  { }\n+\n+// Insertor applies underlying manipulator function to stream\n+template<typename T1, typename T2>\n+  inline gzofstream&\n+  operator<<(gzofstream& s, const gzomanip2<T1,T2>& m)\n+  { return (*m.func)(s, m.val1, m.val2); }\n+\n+// Insert this onto stream to simplify setting of compression level\n+inline gzomanip2<int,int>\n+setcompression(int l, int s = Z_DEFAULT_STRATEGY)\n+{ return gzomanip2<int,int>(&setcompression, l, s); }\n+\n+#endif // ZFSTREAM_H"}, {"sha": "2287804d443c091d63b26be47bdd72a87492b1e9", "filename": "zlib/contrib/masm686/match.asm", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fmasm686%2Fmatch.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fmasm686%2Fmatch.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasm686%2Fmatch.asm?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,408 @@\n+\n+; match.asm -- Pentium-Pro optimized version of longest_match()\n+;\n+; Updated for zlib 1.1.3 and converted to MASM 6.1x\n+; Copyright (C) 2000 Dan Higdon <hdan@kinesoft.com>\n+;                    and Chuck Walbourn <chuckw@kinesoft.com>\n+; Corrections by Cosmin Truta <cosmint@cs.ubbcluj.ro>\n+;\n+; This is free software; you can redistribute it and/or modify it\n+; under the terms of the GNU General Public License.\n+\n+; Based on match.S\n+; Written for zlib 1.1.2\n+; Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>\n+\n+\t.686P\n+\t.MODEL\tFLAT\n+\n+;===========================================================================\n+; EQUATES\n+;===========================================================================\n+\n+MAX_MATCH\tEQU 258\n+MIN_MATCH\tEQU 3\n+MIN_LOOKAHEAD\tEQU (MAX_MATCH + MIN_MATCH + 1)\n+MAX_MATCH_8\tEQU ((MAX_MATCH + 7) AND (NOT 7))\n+\n+;===========================================================================\n+; STRUCTURES\n+;===========================================================================\n+\n+; This STRUCT assumes a 4-byte alignment\n+\n+DEFLATE_STATE\tSTRUCT\n+ds_strm\t\t\tdd ?\n+ds_status\t\tdd ?\n+ds_pending_buf\t\tdd ?\n+ds_pending_buf_size\tdd ?\n+ds_pending_out\t\tdd ?\n+ds_pending\t\tdd ?\n+ds_wrap\t\t\tdd ?\n+ds_data_type\t\tdb ?\n+ds_method\t\tdb ?\n+\t\t\tdb ?\t; padding\n+\t\t\tdb ?\t; padding\n+ds_last_flush\t\tdd ?\n+ds_w_size\t\tdd ?\t; used\n+ds_w_bits\t\tdd ?\n+ds_w_mask\t\tdd ?\t; used\n+ds_window\t\tdd ?\t; used\n+ds_window_size\t\tdd ?\n+ds_prev\t\t\tdd ?\t; used\n+ds_head\t\t\tdd ?\n+ds_ins_h\t\tdd ?\n+ds_hash_size\t\tdd ?\n+ds_hash_bits\t\tdd ?\n+ds_hash_mask\t\tdd ?\n+ds_hash_shift\t\tdd ?\n+ds_block_start\t\tdd ?\n+ds_match_length\t\tdd ?\t; used\n+ds_prev_match\t\tdd ?\t; used\n+ds_match_available\tdd ?\n+ds_strstart\t\tdd ?\t; used\n+ds_match_start\t\tdd ?\t; used\n+ds_lookahead\t\tdd ?\t; used\n+ds_prev_length\t\tdd ?\t; used\n+ds_max_chain_length\tdd ?\t; used\n+ds_max_laxy_match\tdd ?\n+ds_level\t\tdd ?\n+ds_strategy\t\tdd ?\n+ds_good_match\t\tdd ?\t; used\n+ds_nice_match\t\tdd ?\t; used\n+\n+; Don't need anymore of the struct for match\n+DEFLATE_STATE\tENDS\n+\n+;===========================================================================\n+; CODE\n+;===========================================================================\n+_TEXT\tSEGMENT\n+\n+;---------------------------------------------------------------------------\n+; match_init\n+;---------------------------------------------------------------------------\n+\tALIGN\t4\n+PUBLIC\t_match_init\n+_match_init\tPROC\n+\t; no initialization needed\n+\tret\n+_match_init\tENDP\n+\n+;---------------------------------------------------------------------------\n+; uInt longest_match(deflate_state *deflatestate, IPos curmatch)\n+;---------------------------------------------------------------------------\n+\tALIGN\t4\n+\n+PUBLIC\t_longest_match\n+_longest_match\tPROC\n+\n+; Since this code uses EBP for a scratch register, the stack frame must\n+; be manually constructed and referenced relative to the ESP register.\n+\n+; Stack image\n+; Variables\n+chainlenwmask\t=  0\t; high word: current chain len\n+\t\t\t; low word: s->wmask\n+window\t\t=  4\t; local copy of s->window\n+windowbestlen\t=  8\t; s->window + bestlen\n+scanend\t\t= 12\t; last two bytes of string\n+scanstart\t= 16\t; first two bytes of string\n+scanalign\t= 20\t; dword-misalignment of string\n+nicematch\t= 24\t; a good enough match size\n+bestlen\t\t= 28\t; size of best match so far\n+scan\t\t= 32\t; ptr to string wanting match\n+varsize\t\t= 36\t; number of bytes (also offset to last saved register)\n+\n+; Saved Registers (actually pushed into place)\n+ebx_save\t= 36\n+edi_save\t= 40\n+esi_save\t= 44\n+ebp_save\t= 48\n+\n+; Parameters\n+retaddr\t\t= 52\n+deflatestate\t= 56\n+curmatch\t= 60\n+\n+; Save registers that the compiler may be using\n+\tpush\tebp\n+\tpush\tedi\n+\tpush\tesi\n+\tpush\tebx\n+\n+; Allocate local variable space\n+\tsub\tesp,varsize\n+\n+; Retrieve the function arguments. ecx will hold cur_match\n+; throughout the entire function. edx will hold the pointer to the\n+; deflate_state structure during the function's setup (before\n+; entering the main loop).\n+\n+\tmov\tedx, [esp+deflatestate]\n+ASSUME\tedx:PTR DEFLATE_STATE\n+\n+\tmov\tecx, [esp+curmatch]\n+\n+; uInt wmask = s->w_mask;\n+; unsigned chain_length = s->max_chain_length;\n+; if (s->prev_length >= s->good_match) {\n+;     chain_length >>= 2;\n+; }\n+\n+\tmov\teax, [edx].ds_prev_length\n+\tmov\tebx, [edx].ds_good_match\n+\tcmp\teax, ebx\n+\tmov\teax, [edx].ds_w_mask\n+\tmov\tebx, [edx].ds_max_chain_length\n+\tjl\tSHORT LastMatchGood\n+\tshr\tebx, 2\n+LastMatchGood:\n+\n+; chainlen is decremented once beforehand so that the function can\n+; use the sign flag instead of the zero flag for the exit test.\n+; It is then shifted into the high word, to make room for the wmask\n+; value, which it will always accompany.\n+\n+\tdec\tebx\n+\tshl\tebx, 16\n+\tor\tebx, eax\n+\tmov\t[esp+chainlenwmask], ebx\n+\n+; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n+\n+\tmov\teax, [edx].ds_nice_match\n+\tmov\tebx, [edx].ds_lookahead\n+\tcmp\tebx, eax\n+\tjl\tSHORT LookaheadLess\n+\tmov\tebx, eax\n+LookaheadLess:\n+\tmov\t[esp+nicematch], ebx\n+\n+;/* register Bytef *scan = s->window + s->strstart;                     */\n+\n+\tmov\tesi, [edx].ds_window\n+\tmov\t[esp+window], esi\n+\tmov\tebp, [edx].ds_strstart\n+\tlea\tedi, [esi+ebp]\n+\tmov\t[esp+scan],edi\n+\n+;/* Determine how many bytes the scan ptr is off from being             */\n+;/* dword-aligned.                                                      */\n+\n+\tmov\teax, edi\n+\tneg\teax\n+\tand\teax, 3\n+\tmov\t[esp+scanalign], eax\n+\n+;/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?                      */\n+;/*     s->strstart - (IPos)MAX_DIST(s) : NIL;                          */\n+\n+\tmov\teax, [edx].ds_w_size\n+\tsub\teax, MIN_LOOKAHEAD\n+\tsub\tebp, eax\n+\tjg\tSHORT LimitPositive\n+\txor\tebp, ebp\n+LimitPositive:\n+\n+;/* int best_len = s->prev_length;                                      */\n+\n+\tmov\teax, [edx].ds_prev_length\n+\tmov\t[esp+bestlen], eax\n+\n+;/* Store the sum of s->window + best_len in %esi locally, and in %esi. */\n+\n+\tadd\tesi, eax\n+\tmov\t[esp+windowbestlen], esi\n+\n+;/* register ush scan_start = *(ushf*)scan;                             */\n+;/* register ush scan_end   = *(ushf*)(scan+best_len-1);                */\n+;/* Posf *prev = s->prev;                                               */\n+\n+\tmovzx\tebx, WORD PTR[edi]\n+\tmov\t[esp+scanstart], ebx\n+\tmovzx\tebx, WORD PTR[eax+edi-1]\n+\tmov\t[esp+scanend], ebx\n+\tmov\tedi, [edx].ds_prev\n+\n+;/* Jump into the main loop.                                            */\n+\n+\tmov\tedx, [esp+chainlenwmask]\n+\tjmp\tSHORT LoopEntry\n+\n+;/* do {\n+; *     match = s->window + cur_match;\n+; *     if (*(ushf*)(match+best_len-1) != scan_end ||\n+; *         *(ushf*)match != scan_start) continue;\n+; *     [...]\n+; * } while ((cur_match = prev[cur_match & wmask]) > limit\n+; *          && --chain_length != 0);\n+; *\n+; * Here is the inner loop of the function. The function will spend the\n+; * majority of its time in this loop, and majority of that time will\n+; * be spent in the first ten instructions.\n+; *\n+; * Within this loop:\n+; * %ebx = scanend\n+; * %ecx = curmatch\n+; * %edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)\n+; * %esi = windowbestlen - i.e., (window + bestlen)\n+; * %edi = prev\n+; * %ebp = limit\n+; */\n+\n+\tALIGN\t4\n+LookupLoop:\n+\tand\tecx, edx\n+\tmovzx\tecx, WORD PTR[edi+ecx*2]\n+\tcmp\tecx, ebp\n+\tjbe\tLeaveNow\n+\tsub\tedx, 000010000H\n+\tjs\tLeaveNow\n+\n+LoopEntry:\n+\tmovzx\teax, WORD PTR[esi+ecx-1]\n+\tcmp\teax, ebx\n+\tjnz\tSHORT LookupLoop\n+\n+\tmov\teax, [esp+window]\n+\tmovzx\teax, WORD PTR[eax+ecx]\n+\tcmp\teax, [esp+scanstart]\n+\tjnz\tSHORT LookupLoop\n+\n+;/* Store the current value of chainlen.                                */\n+\n+\tmov\t[esp+chainlenwmask], edx\n+\n+;/* Point %edi to the string under scrutiny, and %esi to the string we  */\n+;/* are hoping to match it up with. In actuality, %esi and %edi are     */\n+;/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is     */\n+;/* initialized to -(MAX_MATCH_8 - scanalign).                          */\n+\n+\tmov\tesi, [esp+window]\n+\tmov\tedi, [esp+scan]\n+\tadd\tesi, ecx\n+\tmov\teax, [esp+scanalign]\n+\tmov\tedx, -MAX_MATCH_8\n+\tlea\tedi, [edi+eax+MAX_MATCH_8]\n+\tlea\tesi, [esi+eax+MAX_MATCH_8]\n+\n+;/* Test the strings for equality, 8 bytes at a time. At the end,\n+; * adjust %edx so that it is offset to the exact byte that mismatched.\n+; *\n+; * We already know at this point that the first three bytes of the\n+; * strings match each other, and they can be safely passed over before\n+; * starting the compare loop. So what this code does is skip over 0-3\n+; * bytes, as much as necessary in order to dword-align the %edi\n+; * pointer. (%esi will still be misaligned three times out of four.)\n+; *\n+; * It should be confessed that this loop usually does not represent\n+; * much of the total running time. Replacing it with a more\n+; * straightforward \"rep cmpsb\" would not drastically degrade\n+; * performance.\n+; */\n+\n+LoopCmps:\n+\tmov\teax, DWORD PTR[esi+edx]\n+\txor\teax, DWORD PTR[edi+edx]\n+\tjnz\tSHORT LeaveLoopCmps\n+\n+\tmov\teax, DWORD PTR[esi+edx+4]\n+\txor\teax, DWORD PTR[edi+edx+4]\n+\tjnz\tSHORT LeaveLoopCmps4\n+\n+\tadd\tedx, 8\n+\tjnz\tSHORT LoopCmps\n+\tjmp\tLenMaximum\n+\tALIGN\t4\n+\n+LeaveLoopCmps4:\n+\tadd\tedx, 4\n+\n+LeaveLoopCmps:\n+\ttest\teax, 00000FFFFH\n+\tjnz\tSHORT LenLower\n+\n+\tadd\tedx, 2\n+\tshr\teax, 16\n+\n+LenLower:\n+\tsub\tal, 1\n+\tadc\tedx, 0\n+\n+;/* Calculate the length of the match. If it is longer than MAX_MATCH,  */\n+;/* then automatically accept it as the best possible match and leave.  */\n+\n+\tlea\teax, [edi+edx]\n+\tmov\tedi, [esp+scan]\n+\tsub\teax, edi\n+\tcmp\teax, MAX_MATCH\n+\tjge\tSHORT LenMaximum\n+\n+;/* If the length of the match is not longer than the best match we     */\n+;/* have so far, then forget it and return to the lookup loop.          */\n+\n+\tmov\tedx, [esp+deflatestate]\n+\tmov\tebx, [esp+bestlen]\n+\tcmp\teax, ebx\n+\tjg\tSHORT LongerMatch\n+\tmov\tesi, [esp+windowbestlen]\n+\tmov\tedi, [edx].ds_prev\n+\tmov\tebx, [esp+scanend]\n+\tmov\tedx, [esp+chainlenwmask]\n+\tjmp\tLookupLoop\n+\tALIGN\t4\n+\n+;/*         s->match_start = cur_match;                                 */\n+;/*         best_len = len;                                             */\n+;/*         if (len >= nice_match) break;                               */\n+;/*         scan_end = *(ushf*)(scan+best_len-1);                       */\n+\n+LongerMatch:\n+\tmov\tebx, [esp+nicematch]\n+\tmov\t[esp+bestlen], eax\n+\tmov\t[edx].ds_match_start, ecx\n+\tcmp\teax, ebx\n+\tjge\tSHORT LeaveNow\n+\tmov\tesi, [esp+window]\n+\tadd\tesi, eax\n+\tmov\t[esp+windowbestlen], esi\n+\tmovzx\tebx, WORD PTR[edi+eax-1]\n+\tmov\tedi, [edx].ds_prev\n+\tmov\t[esp+scanend], ebx\n+\tmov\tedx, [esp+chainlenwmask]\n+\tjmp\tLookupLoop\n+\tALIGN\t4\n+\n+;/* Accept the current string, with the maximum possible length.        */\n+\n+LenMaximum:\n+\tmov\tedx, [esp+deflatestate]\n+\tmov\tDWORD PTR[esp+bestlen], MAX_MATCH\n+\tmov\t[edx].ds_match_start, ecx\n+\n+;/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;          */\n+;/* return s->lookahead;                                                */\n+\n+LeaveNow:\n+\tmov\tedx, [esp+deflatestate]\n+\tmov\tebx, [esp+bestlen]\n+\tmov\teax, [edx].ds_lookahead\n+\tcmp\tebx, eax\n+\tjg\tSHORT LookaheadRet\n+\tmov\teax, ebx\n+LookaheadRet:\n+\n+; Restore the stack and return from whence we came.\n+\n+\tadd\tesp, varsize\n+\tpop\tebx\n+\tpop\tesi\n+\tpop\tedi\n+\tpop\tebp\n+\tret\n+\n+_longest_match\tENDP\n+\n+_TEXT\tENDS\n+END"}, {"sha": "ec360e67ada46dfbb827c061b1326c15e5249498", "filename": "zlib/contrib/masmx86/gvmat32.asm", "status": "added", "additions": 905, "deletions": 0, "changes": 905, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fmasmx86%2Fgvmat32.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fmasmx86%2Fgvmat32.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx86%2Fgvmat32.asm?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,905 @@\n+;\n+; gvmat32.asm -- Asm portion of the optimized longest_match for 32 bits x86\n+; Copyright (C) 1995-1996 Jean-loup Gailly and Gilles Vollant.\n+; File written by Gilles Vollant, by modifiying the longest_match\n+;  from Jean-loup Gailly in deflate.c\n+; It need wmask == 0x7fff\n+;     (assembly code is faster with a fixed wmask)\n+;\n+; For Visual C++ 4.2 and ML 6.11c (version in directory \\MASM611C of Win95 DDK)\n+;   I compile with : \"ml /coff /Zi /c gvmat32.asm\"\n+;\n+\n+;uInt longest_match_7fff(s, cur_match)\n+;    deflate_state *s;\n+;    IPos cur_match;                             /* current match */\n+\n+\tNbStack         equ     76\n+\tcur_match       equ     dword ptr[esp+NbStack-0]\n+\tstr_s           equ     dword ptr[esp+NbStack-4]\n+; 5 dword on top (ret,ebp,esi,edi,ebx)\n+\tadrret          equ     dword ptr[esp+NbStack-8]\n+\tpushebp         equ     dword ptr[esp+NbStack-12]\n+\tpushedi         equ     dword ptr[esp+NbStack-16]\n+\tpushesi         equ     dword ptr[esp+NbStack-20]\n+\tpushebx         equ     dword ptr[esp+NbStack-24]\n+\n+\tchain_length    equ     dword ptr [esp+NbStack-28]\n+\tlimit           equ     dword ptr [esp+NbStack-32]\n+\tbest_len        equ     dword ptr [esp+NbStack-36]\n+\twindow          equ     dword ptr [esp+NbStack-40]\n+\tprev            equ     dword ptr [esp+NbStack-44]\n+\tscan_start      equ      word ptr [esp+NbStack-48]\n+\twmask           equ     dword ptr [esp+NbStack-52]\n+\tmatch_start_ptr equ     dword ptr [esp+NbStack-56]\n+\tnice_match      equ     dword ptr [esp+NbStack-60]\n+\tscan            equ     dword ptr [esp+NbStack-64]\n+\n+\twindowlen       equ     dword ptr [esp+NbStack-68]\n+\tmatch_start     equ     dword ptr [esp+NbStack-72]\n+\tstrend          equ     dword ptr [esp+NbStack-76]\n+\tNbStackAdd      equ     (NbStack-24)\n+\n+    .386p\n+\n+    name    gvmatch\n+    .MODEL  FLAT\n+\n+\n+\n+;  all the +4 offsets are due to the addition of pending_buf_size (in zlib\n+;  in the deflate_state structure since the asm code was first written\n+;  (if you compile with zlib 1.0.4 or older, remove the +4).\n+;  Note : these value are good with a 8 bytes boundary pack structure\n+    dep_chain_length    equ     70h+4\n+    dep_window          equ     2ch+4\n+    dep_strstart        equ     60h+4\n+    dep_prev_length     equ     6ch+4\n+    dep_nice_match      equ     84h+4\n+    dep_w_size          equ     20h+4\n+    dep_prev            equ     34h+4\n+    dep_w_mask          equ     28h+4\n+    dep_good_match      equ     80h+4\n+    dep_match_start     equ     64h+4\n+    dep_lookahead       equ     68h+4\n+\n+\n+_TEXT                   segment\n+\n+IFDEF NOUNDERLINE\n+\t\t\tpublic  longest_match_7fff\n+\t\t\tpublic  longest_match_686\n+;                        public  match_init\n+ELSE\n+\t\t\tpublic  _longest_match_7fff\n+\t\t\tpublic  _longest_match_686\n+;                        public  _match_init\n+ENDIF\n+\n+    MAX_MATCH           equ     258\n+    MIN_MATCH           equ     3\n+    MIN_LOOKAHEAD       equ     (MAX_MATCH+MIN_MATCH+1)\n+\n+\n+\n+IFDEF NOUNDERLINE\n+;match_init      proc near\n+;                ret\n+;match_init      endp\n+ELSE\n+;_match_init     proc near\n+;                ret\n+;_match_init     endp\n+ENDIF\n+\n+\n+IFDEF NOUNDERLINE\n+longest_match_7fff   proc near\n+ELSE\n+_longest_match_7fff  proc near\n+ENDIF\n+\n+\tmov     edx,[esp+4]\n+\n+\n+\n+\tpush    ebp\n+\tpush    edi\n+\tpush    esi\n+\tpush    ebx\n+\n+\tsub     esp,NbStackAdd\n+\n+; initialize or check the variables used in match.asm.\n+\tmov     ebp,edx\n+\n+; chain_length = s->max_chain_length\n+; if (prev_length>=good_match) chain_length >>= 2\n+\tmov     edx,[ebp+dep_chain_length]\n+\tmov     ebx,[ebp+dep_prev_length]\n+\tcmp     [ebp+dep_good_match],ebx\n+\tja      noshr\n+\tshr     edx,2\n+noshr:\n+; we increment chain_length because in the asm, the --chain_lenght is in the beginning of the loop\n+\tinc     edx\n+\tmov     edi,[ebp+dep_nice_match]\n+\tmov     chain_length,edx\n+\tmov     eax,[ebp+dep_lookahead]\n+\tcmp     eax,edi\n+; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n+\tjae     nolookaheadnicematch\n+\tmov     edi,eax\n+nolookaheadnicematch:\n+; best_len = s->prev_length\n+\tmov     best_len,ebx\n+\n+; window = s->window\n+\tmov     esi,[ebp+dep_window]\n+\tmov     ecx,[ebp+dep_strstart]\n+\tmov     window,esi\n+\n+\tmov     nice_match,edi\n+; scan = window + strstart\n+\tadd     esi,ecx\n+\tmov     scan,esi\n+; dx = *window\n+\tmov     dx,word ptr [esi]\n+; bx = *(window+best_len-1)\n+\tmov     bx,word ptr [esi+ebx-1]\n+\tadd     esi,MAX_MATCH-1\n+; scan_start = *scan\n+\tmov     scan_start,dx\n+; strend = scan + MAX_MATCH-1\n+\tmov     strend,esi\n+; bx = scan_end = *(window+best_len-1)\n+\n+;    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n+;        s->strstart - (IPos)MAX_DIST(s) : NIL;\n+\n+\tmov     esi,[ebp+dep_w_size]\n+\tsub     esi,MIN_LOOKAHEAD\n+; here esi = MAX_DIST(s)\n+\tsub     ecx,esi\n+\tja      nodist\n+\txor     ecx,ecx\n+nodist:\n+\tmov     limit,ecx\n+\n+; prev = s->prev\n+\tmov     edx,[ebp+dep_prev]\n+\tmov     prev,edx\n+\n+;\n+\tmov     edx,dword ptr [ebp+dep_match_start]\n+\tmov     bp,scan_start\n+\tmov     eax,cur_match\n+\tmov     match_start,edx\n+\n+\tmov     edx,window\n+\tmov     edi,edx\n+\tadd     edi,best_len\n+\tmov     esi,prev\n+\tdec     edi\n+; windowlen = window + best_len -1\n+\tmov     windowlen,edi\n+\n+\tjmp     beginloop2\n+\talign   4\n+\n+; here, in the loop\n+;       eax = ax = cur_match\n+;       ecx = limit\n+;        bx = scan_end\n+;        bp = scan_start\n+;       edi = windowlen (window + best_len -1)\n+;       esi = prev\n+\n+\n+;// here; chain_length <=16\n+normalbeg0add16:\n+\tadd     chain_length,16\n+\tjz      exitloop\n+normalbeg0:\n+\tcmp     word ptr[edi+eax],bx\n+\tje      normalbeg2noroll\n+rcontlabnoroll:\n+; cur_match = prev[cur_match & wmask]\n+\tand     eax,7fffh\n+\tmov     ax,word ptr[esi+eax*2]\n+; if cur_match > limit, go to exitloop\n+\tcmp     ecx,eax\n+\tjnb     exitloop\n+; if --chain_length != 0, go to exitloop\n+\tdec     chain_length\n+\tjnz     normalbeg0\n+\tjmp     exitloop\n+\n+normalbeg2noroll:\n+; if (scan_start==*(cur_match+window)) goto normalbeg2\n+\tcmp     bp,word ptr[edx+eax]\n+\tjne     rcontlabnoroll\n+\tjmp     normalbeg2\n+\n+contloop3:\n+\tmov     edi,windowlen\n+\n+; cur_match = prev[cur_match & wmask]\n+\tand     eax,7fffh\n+\tmov     ax,word ptr[esi+eax*2]\n+; if cur_match > limit, go to exitloop\n+\tcmp     ecx,eax\n+jnbexitloopshort1:\n+\tjnb     exitloop\n+; if --chain_length != 0, go to exitloop\n+\n+\n+; begin the main loop\n+beginloop2:\n+\tsub     chain_length,16+1\n+; if chain_length <=16, don't use the unrolled loop\n+\tjna     normalbeg0add16\n+\n+do16:\n+\tcmp     word ptr[edi+eax],bx\n+\tje      normalbeg2dc0\n+\n+maccn   MACRO   lab\n+\tand     eax,7fffh\n+\tmov     ax,word ptr[esi+eax*2]\n+\tcmp     ecx,eax\n+\tjnb     exitloop\n+\tcmp     word ptr[edi+eax],bx\n+\tje      lab\n+\tENDM\n+\n+rcontloop0:\n+\tmaccn   normalbeg2dc1\n+\n+rcontloop1:\n+\tmaccn   normalbeg2dc2\n+\n+rcontloop2:\n+\tmaccn   normalbeg2dc3\n+\n+rcontloop3:\n+\tmaccn   normalbeg2dc4\n+\n+rcontloop4:\n+\tmaccn   normalbeg2dc5\n+\n+rcontloop5:\n+\tmaccn   normalbeg2dc6\n+\n+rcontloop6:\n+\tmaccn   normalbeg2dc7\n+\n+rcontloop7:\n+\tmaccn   normalbeg2dc8\n+\n+rcontloop8:\n+\tmaccn   normalbeg2dc9\n+\n+rcontloop9:\n+\tmaccn   normalbeg2dc10\n+\n+rcontloop10:\n+\tmaccn   short normalbeg2dc11\n+\n+rcontloop11:\n+\tmaccn   short normalbeg2dc12\n+\n+rcontloop12:\n+\tmaccn   short normalbeg2dc13\n+\n+rcontloop13:\n+\tmaccn   short normalbeg2dc14\n+\n+rcontloop14:\n+\tmaccn   short normalbeg2dc15\n+\n+rcontloop15:\n+\tand     eax,7fffh\n+\tmov     ax,word ptr[esi+eax*2]\n+\tcmp     ecx,eax\n+\tjnb     exitloop\n+\n+\tsub     chain_length,16\n+\tja      do16\n+\tjmp     normalbeg0add16\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+normbeg MACRO   rcontlab,valsub\n+; if we are here, we know that *(match+best_len-1) == scan_end\n+\tcmp     bp,word ptr[edx+eax]\n+; if (match != scan_start) goto rcontlab\n+\tjne     rcontlab\n+; calculate the good chain_length, and we'll compare scan and match string\n+\tadd     chain_length,16-valsub\n+\tjmp     iseq\n+\tENDM\n+\n+\n+normalbeg2dc11:\n+\tnormbeg rcontloop11,11\n+\n+normalbeg2dc12:\n+\tnormbeg short rcontloop12,12\n+\n+normalbeg2dc13:\n+\tnormbeg short rcontloop13,13\n+\n+normalbeg2dc14:\n+\tnormbeg short rcontloop14,14\n+\n+normalbeg2dc15:\n+\tnormbeg short rcontloop15,15\n+\n+normalbeg2dc10:\n+\tnormbeg rcontloop10,10\n+\n+normalbeg2dc9:\n+\tnormbeg rcontloop9,9\n+\n+normalbeg2dc8:\n+\tnormbeg rcontloop8,8\n+\n+normalbeg2dc7:\n+\tnormbeg rcontloop7,7\n+\n+normalbeg2dc6:\n+\tnormbeg rcontloop6,6\n+\n+normalbeg2dc5:\n+\tnormbeg rcontloop5,5\n+\n+normalbeg2dc4:\n+\tnormbeg rcontloop4,4\n+\n+normalbeg2dc3:\n+\tnormbeg rcontloop3,3\n+\n+normalbeg2dc2:\n+\tnormbeg rcontloop2,2\n+\n+normalbeg2dc1:\n+\tnormbeg rcontloop1,1\n+\n+normalbeg2dc0:\n+\tnormbeg rcontloop0,0\n+\n+\n+; we go in normalbeg2 because *(ushf*)(match+best_len-1) == scan_end\n+\n+normalbeg2:\n+\tmov     edi,window\n+\n+\tcmp     bp,word ptr[edi+eax]\n+\tjne     contloop3                   ; if *(ushf*)match != scan_start, continue\n+\n+iseq:\n+; if we are here, we know that *(match+best_len-1) == scan_end\n+; and (match == scan_start)\n+\n+\tmov     edi,edx\n+\tmov     esi,scan                    ; esi = scan\n+\tadd     edi,eax                     ; edi = window + cur_match = match\n+\n+\tmov     edx,[esi+3]                 ; compare manually dword at match+3\n+\txor     edx,[edi+3]                 ; and scan +3\n+\n+\tjz      begincompare                ; if equal, go to long compare\n+\n+; we will determine the unmatch byte and calculate len (in esi)\n+\tor      dl,dl\n+\tje      eq1rr\n+\tmov     esi,3\n+\tjmp     trfinval\n+eq1rr:\n+\tor      dx,dx\n+\tje      eq1\n+\n+\tmov     esi,4\n+\tjmp     trfinval\n+eq1:\n+\tand     edx,0ffffffh\n+\tjz      eq11\n+\tmov     esi,5\n+\tjmp     trfinval\n+eq11:\n+\tmov     esi,6\n+\tjmp     trfinval\n+\n+begincompare:\n+\t; here we now scan and match begin same\n+\tadd     edi,6\n+\tadd     esi,6\n+\tmov     ecx,(MAX_MATCH-(2+4))/4     ; scan for at most MAX_MATCH bytes\n+\trepe    cmpsd                       ; loop until mismatch\n+\n+\tje      trfin                       ; go to trfin if not unmatch\n+; we determine the unmatch byte\n+\tsub     esi,4\n+\tmov     edx,[edi-4]\n+\txor     edx,[esi]\n+\n+\tor      dl,dl\n+\tjnz     trfin\n+\tinc     esi\n+\n+\tor      dx,dx\n+\tjnz     trfin\n+\tinc     esi\n+\n+\tand     edx,0ffffffh\n+\tjnz     trfin\n+\tinc     esi\n+\n+trfin:\n+\tsub     esi,scan          ; esi = len\n+trfinval:\n+; here we have finised compare, and esi contain len of equal string\n+\tcmp     esi,best_len        ; if len > best_len, go newbestlen\n+\tja      short newbestlen\n+; now we restore edx, ecx and esi, for the big loop\n+\tmov     esi,prev\n+\tmov     ecx,limit\n+\tmov     edx,window\n+\tjmp     contloop3\n+\n+newbestlen:\n+\tmov     best_len,esi        ; len become best_len\n+\n+\tmov     match_start,eax     ; save new position as match_start\n+\tcmp     esi,nice_match      ; if best_len >= nice_match, exit\n+\tjae     exitloop\n+\tmov     ecx,scan\n+\tmov     edx,window          ; restore edx=window\n+\tadd     ecx,esi\n+\tadd     esi,edx\n+\n+\tdec     esi\n+\tmov     windowlen,esi       ; windowlen = window + best_len-1\n+\tmov     bx,[ecx-1]          ; bx = *(scan+best_len-1) = scan_end\n+\n+; now we restore ecx and esi, for the big loop :\n+\tmov     esi,prev\n+\tmov     ecx,limit\n+\tjmp     contloop3\n+\n+exitloop:\n+; exit : s->match_start=match_start\n+\tmov     ebx,match_start\n+\tmov     ebp,str_s\n+\tmov     ecx,best_len\n+\tmov     dword ptr [ebp+dep_match_start],ebx\n+\tmov     eax,dword ptr [ebp+dep_lookahead]\n+\tcmp     ecx,eax\n+\tja      minexlo\n+\tmov     eax,ecx\n+minexlo:\n+; return min(best_len,s->lookahead)\n+\n+; restore stack and register ebx,esi,edi,ebp\n+\tadd     esp,NbStackAdd\n+\n+\tpop     ebx\n+\tpop     esi\n+\tpop     edi\n+\tpop     ebp\n+\tret\n+InfoAuthor:\n+; please don't remove this string !\n+; Your are free use gvmat32 in any fre or commercial apps if you don't remove the string in the binary!\n+\tdb     0dh,0ah,\"GVMat32 optimised assembly code written 1996-98 by Gilles Vollant\",0dh,0ah\n+\n+\n+\n+IFDEF NOUNDERLINE\n+longest_match_7fff   endp\n+ELSE\n+_longest_match_7fff  endp\n+ENDIF\n+\n+\n+IFDEF NOUNDERLINE\n+cpudetect32     proc near\n+ELSE\n+_cpudetect32    proc near\n+ENDIF\n+\n+\tpush\tebx\n+\n+\tpushfd                  ; push original EFLAGS\n+\tpop     eax             ; get original EFLAGS\n+\tmov     ecx, eax        ; save original EFLAGS\n+\txor     eax, 40000h     ; flip AC bit in EFLAGS\n+\tpush    eax             ; save new EFLAGS value on stack\n+\tpopfd                   ; replace current EFLAGS value\n+\tpushfd                  ; get new EFLAGS\n+\tpop     eax             ; store new EFLAGS in EAX\n+\txor     eax, ecx        ; can\ufffdt toggle AC bit, processor=80386\n+\tjz      end_cpu_is_386  ; jump if 80386 processor\n+\tpush    ecx\n+\tpopfd                   ; restore AC bit in EFLAGS first\n+\n+\tpushfd\n+\tpushfd\n+\tpop     ecx\n+\n+\tmov     eax, ecx        ; get original EFLAGS\n+\txor     eax, 200000h    ; flip ID bit in EFLAGS\n+\tpush    eax             ; save new EFLAGS value on stack\n+\tpopfd                   ; replace current EFLAGS value\n+\tpushfd                  ; get new EFLAGS\n+\tpop\t\teax\t            ; store new EFLAGS in EAX\n+\tpopfd                   ; restore original EFLAGS\n+\txor\t\teax, ecx        ; can\ufffdt toggle ID bit,\n+\tje\t\tis_old_486\t\t; processor=old\n+\n+\tmov     eax,1\n+\tdb      0fh,0a2h        ;CPUID\n+\n+exitcpudetect:\n+\tpop\tebx\n+\tret\n+\n+end_cpu_is_386:\n+\tmov     eax,0300h\n+\tjmp     exitcpudetect\n+\n+is_old_486:\n+\tmov     eax,0400h\n+\tjmp     exitcpudetect\n+\n+IFDEF NOUNDERLINE\n+cpudetect32     endp\n+ELSE\n+_cpudetect32    endp\n+ENDIF\n+\n+\n+\n+\n+MAX_MATCH       equ     258\n+MIN_MATCH       equ     3\n+MIN_LOOKAHEAD   equ     (MAX_MATCH + MIN_MATCH + 1)\n+MAX_MATCH_8_     equ     ((MAX_MATCH + 7) AND 0FFF0h)\n+\n+\n+;;; stack frame offsets\n+\n+chainlenwmask\tequ  esp + 0\t; high word: current chain len\n+\t\t\t\t\t; low word: s->wmask\n+window\t\tequ  esp + 4\t; local copy of s->window\n+windowbestlen\tequ  esp + 8\t; s->window + bestlen\n+scanstart\tequ  esp + 16\t; first two bytes of string\n+scanend\t\tequ  esp + 12\t; last two bytes of string\n+scanalign\tequ  esp + 20\t; dword-misalignment of string\n+nicematch\tequ  esp + 24\t; a good enough match size\n+bestlen\t\tequ  esp + 28\t; size of best match so far\n+scan\t\tequ  esp + 32\t; ptr to string wanting match\n+\n+LocalVarsSize\tequ 36\n+;\tsaved ebx\tbyte esp + 36\n+;\tsaved edi\tbyte esp + 40\n+;\tsaved esi\tbyte esp + 44\n+;\tsaved ebp\tbyte esp + 48\n+;\treturn address\tbyte esp + 52\n+deflatestate\tequ  esp + 56\t; the function arguments\n+curmatch\tequ  esp + 60\n+\n+;;; Offsets for fields in the deflate_state structure. These numbers\n+;;; are calculated from the definition of deflate_state, with the\n+;;; assumption that the compiler will dword-align the fields. (Thus,\n+;;; changing the definition of deflate_state could easily cause this\n+;;; program to crash horribly, without so much as a warning at\n+;;; compile time. Sigh.)\n+\n+dsWSize\t\tequ 36\n+dsWMask\t\tequ 44\n+dsWindow\tequ 48\n+dsPrev\t\tequ 56\n+dsMatchLen\tequ 88\n+dsPrevMatch\tequ 92\n+dsStrStart\tequ 100\n+dsMatchStart\tequ 104\n+dsLookahead\tequ 108\n+dsPrevLen\tequ 112\n+dsMaxChainLen\tequ 116\n+dsGoodMatch\tequ 132\n+dsNiceMatch\tequ 136\n+\n+\n+;;; match.asm -- Pentium-Pro-optimized version of longest_match()\n+;;; Written for zlib 1.1.2\n+;;; Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>\n+;;; You can look at http://www.muppetlabs.com/~breadbox/software/assembly.html\n+;;;\n+;;; This is free software; you can redistribute it and/or modify it\n+;;; under the terms of the GNU General Public License.\n+\n+;GLOBAL\t_longest_match, _match_init\n+\n+\n+;SECTION\t.text\n+\n+;;; uInt longest_match(deflate_state *deflatestate, IPos curmatch)\n+\n+;_longest_match:\n+IFDEF NOUNDERLINE\n+longest_match_686   proc near\n+ELSE\n+_longest_match_686  proc near\n+ENDIF\n+\n+\n+;;; Save registers that the compiler may be using, and adjust esp to\n+;;; make room for our stack frame.\n+\n+\t\tpush\tebp\n+\t\tpush\tedi\n+\t\tpush\tesi\n+\t\tpush\tebx\n+\t\tsub\tesp, LocalVarsSize\n+\n+;;; Retrieve the function arguments. ecx will hold cur_match\n+;;; throughout the entire function. edx will hold the pointer to the\n+;;; deflate_state structure during the function's setup (before\n+;;; entering the main loop.\n+\n+\t\tmov\tedx, [deflatestate]\n+\t\tmov\tecx, [curmatch]\n+\n+;;; uInt wmask = s->w_mask;\n+;;; unsigned chain_length = s->max_chain_length;\n+;;; if (s->prev_length >= s->good_match) {\n+;;;     chain_length >>= 2;\n+;;; }\n+\n+\t\tmov\teax, [edx + dsPrevLen]\n+\t\tmov\tebx, [edx + dsGoodMatch]\n+\t\tcmp\teax, ebx\n+\t\tmov\teax, [edx + dsWMask]\n+\t\tmov\tebx, [edx + dsMaxChainLen]\n+\t\tjl\tLastMatchGood\n+\t\tshr\tebx, 2\n+LastMatchGood:\n+\n+;;; chainlen is decremented once beforehand so that the function can\n+;;; use the sign flag instead of the zero flag for the exit test.\n+;;; It is then shifted into the high word, to make room for the wmask\n+;;; value, which it will always accompany.\n+\n+\t\tdec\tebx\n+\t\tshl\tebx, 16\n+\t\tor\tebx, eax\n+\t\tmov\t[chainlenwmask], ebx\n+\n+;;; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n+\n+\t\tmov\teax, [edx + dsNiceMatch]\n+\t\tmov\tebx, [edx + dsLookahead]\n+\t\tcmp\tebx, eax\n+\t\tjl\tLookaheadLess\n+\t\tmov\tebx, eax\n+LookaheadLess:\tmov\t[nicematch], ebx\n+\n+;;; register Bytef *scan = s->window + s->strstart;\n+\n+\t\tmov\tesi, [edx + dsWindow]\n+\t\tmov\t[window], esi\n+\t\tmov\tebp, [edx + dsStrStart]\n+\t\tlea\tedi, [esi + ebp]\n+\t\tmov\t[scan], edi\n+\n+;;; Determine how many bytes the scan ptr is off from being\n+;;; dword-aligned.\n+\n+\t\tmov\teax, edi\n+\t\tneg\teax\n+\t\tand\teax, 3\n+\t\tmov\t[scanalign], eax\n+\n+;;; IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n+;;;     s->strstart - (IPos)MAX_DIST(s) : NIL;\n+\n+\t\tmov\teax, [edx + dsWSize]\n+\t\tsub\teax, MIN_LOOKAHEAD\n+\t\tsub\tebp, eax\n+\t\tjg\tLimitPositive\n+\t\txor\tebp, ebp\n+LimitPositive:\n+\n+;;; int best_len = s->prev_length;\n+\n+\t\tmov\teax, [edx + dsPrevLen]\n+\t\tmov\t[bestlen], eax\n+\n+;;; Store the sum of s->window + best_len in esi locally, and in esi.\n+\n+\t\tadd\tesi, eax\n+\t\tmov\t[windowbestlen], esi\n+\n+;;; register ush scan_start = *(ushf*)scan;\n+;;; register ush scan_end   = *(ushf*)(scan+best_len-1);\n+;;; Posf *prev = s->prev;\n+\n+\t\tmovzx\tebx, word ptr [edi]\n+\t\tmov\t[scanstart], ebx\n+\t\tmovzx\tebx, word ptr [edi + eax - 1]\n+\t\tmov\t[scanend], ebx\n+\t\tmov\tedi, [edx + dsPrev]\n+\n+;;; Jump into the main loop.\n+\n+\t\tmov\tedx, [chainlenwmask]\n+\t\tjmp\tshort LoopEntry\n+\n+align 4\n+\n+;;; do {\n+;;;     match = s->window + cur_match;\n+;;;     if (*(ushf*)(match+best_len-1) != scan_end ||\n+;;;         *(ushf*)match != scan_start) continue;\n+;;;     [...]\n+;;; } while ((cur_match = prev[cur_match & wmask]) > limit\n+;;;          && --chain_length != 0);\n+;;;\n+;;; Here is the inner loop of the function. The function will spend the\n+;;; majority of its time in this loop, and majority of that time will\n+;;; be spent in the first ten instructions.\n+;;;\n+;;; Within this loop:\n+;;; ebx = scanend\n+;;; ecx = curmatch\n+;;; edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)\n+;;; esi = windowbestlen - i.e., (window + bestlen)\n+;;; edi = prev\n+;;; ebp = limit\n+\n+LookupLoop:\n+\t\tand\tecx, edx\n+\t\tmovzx\tecx, word ptr [edi + ecx*2]\n+\t\tcmp\tecx, ebp\n+\t\tjbe\tLeaveNow\n+\t\tsub\tedx, 00010000h\n+\t\tjs\tLeaveNow\n+LoopEntry:\tmovzx\teax, word ptr [esi + ecx - 1]\n+\t\tcmp\teax, ebx\n+\t\tjnz\tLookupLoop\n+\t\tmov\teax, [window]\n+\t\tmovzx\teax, word ptr [eax + ecx]\n+\t\tcmp\teax, [scanstart]\n+\t\tjnz\tLookupLoop\n+\n+;;; Store the current value of chainlen.\n+\n+\t\tmov\t[chainlenwmask], edx\n+\n+;;; Point edi to the string under scrutiny, and esi to the string we\n+;;; are hoping to match it up with. In actuality, esi and edi are\n+;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is\n+;;; initialized to -(MAX_MATCH_8 - scanalign).\n+\n+\t\tmov\tesi, [window]\n+\t\tmov\tedi, [scan]\n+\t\tadd\tesi, ecx\n+\t\tmov\teax, [scanalign]\n+\t\tmov\tedx, 0fffffef8h; -(MAX_MATCH_8)\n+\t\tlea\tedi, [edi + eax + 0108h] ;MAX_MATCH_8]\n+\t\tlea\tesi, [esi + eax + 0108h] ;MAX_MATCH_8]\n+\n+;;; Test the strings for equality, 8 bytes at a time. At the end,\n+;;; adjust edx so that it is offset to the exact byte that mismatched.\n+;;;\n+;;; We already know at this point that the first three bytes of the\n+;;; strings match each other, and they can be safely passed over before\n+;;; starting the compare loop. So what this code does is skip over 0-3\n+;;; bytes, as much as necessary in order to dword-align the edi\n+;;; pointer. (esi will still be misaligned three times out of four.)\n+;;;\n+;;; It should be confessed that this loop usually does not represent\n+;;; much of the total running time. Replacing it with a more\n+;;; straightforward \"rep cmpsb\" would not drastically degrade\n+;;; performance.\n+\n+LoopCmps:\n+\t\tmov\teax, [esi + edx]\n+\t\txor\teax, [edi + edx]\n+\t\tjnz\tLeaveLoopCmps\n+\t\tmov\teax, [esi + edx + 4]\n+\t\txor\teax, [edi + edx + 4]\n+\t\tjnz\tLeaveLoopCmps4\n+\t\tadd\tedx, 8\n+\t\tjnz\tLoopCmps\n+\t\tjmp\tshort LenMaximum\n+LeaveLoopCmps4:\tadd\tedx, 4\n+LeaveLoopCmps:\ttest\teax, 0000FFFFh\n+\t\tjnz\tLenLower\n+\t\tadd\tedx,  2\n+\t\tshr\teax, 16\n+LenLower:\tsub\tal, 1\n+\t\tadc\tedx, 0\n+\n+;;; Calculate the length of the match. If it is longer than MAX_MATCH,\n+;;; then automatically accept it as the best possible match and leave.\n+\n+\t\tlea\teax, [edi + edx]\n+\t\tmov\tedi, [scan]\n+\t\tsub\teax, edi\n+\t\tcmp\teax, MAX_MATCH\n+\t\tjge\tLenMaximum\n+\n+;;; If the length of the match is not longer than the best match we\n+;;; have so far, then forget it and return to the lookup loop.\n+\n+\t\tmov\tedx, [deflatestate]\n+\t\tmov\tebx, [bestlen]\n+\t\tcmp\teax, ebx\n+\t\tjg\tLongerMatch\n+\t\tmov\tesi, [windowbestlen]\n+\t\tmov\tedi, [edx + dsPrev]\n+\t\tmov\tebx, [scanend]\n+\t\tmov\tedx, [chainlenwmask]\n+\t\tjmp\tLookupLoop\n+\n+;;;         s->match_start = cur_match;\n+;;;         best_len = len;\n+;;;         if (len >= nice_match) break;\n+;;;         scan_end = *(ushf*)(scan+best_len-1);\n+\n+LongerMatch:\tmov\tebx, [nicematch]\n+\t\tmov\t[bestlen], eax\n+\t\tmov\t[edx + dsMatchStart], ecx\n+\t\tcmp\teax, ebx\n+\t\tjge\tLeaveNow\n+\t\tmov\tesi, [window]\n+\t\tadd\tesi, eax\n+\t\tmov\t[windowbestlen], esi\n+\t\tmovzx\tebx, word ptr [edi + eax - 1]\n+\t\tmov\tedi, [edx + dsPrev]\n+\t\tmov\t[scanend], ebx\n+\t\tmov\tedx, [chainlenwmask]\n+\t\tjmp\tLookupLoop\n+\n+;;; Accept the current string, with the maximum possible length.\n+\n+LenMaximum:\tmov\tedx, [deflatestate]\n+\t\tmov\tdword ptr [bestlen], MAX_MATCH\n+\t\tmov\t[edx + dsMatchStart], ecx\n+\n+;;; if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\n+;;; return s->lookahead;\n+\n+LeaveNow:\n+\t\tmov\tedx, [deflatestate]\n+\t\tmov\tebx, [bestlen]\n+\t\tmov\teax, [edx + dsLookahead]\n+\t\tcmp\tebx, eax\n+\t\tjg\tLookaheadRet\n+\t\tmov\teax, ebx\n+LookaheadRet:\n+\n+;;; Restore the stack and return from whence we came.\n+\n+\t\tadd\tesp, LocalVarsSize\n+\t\tpop\tebx\n+\t\tpop\tesi\n+\t\tpop\tedi\n+\t\tpop\tebp\n+\n+\t\tret\n+; please don't remove this string !\n+; Your can freely use gvmat32 in any free or commercial app if you don't remove the string in the binary!\n+\tdb     0dh,0ah,\"asm686 with masm, optimised assembly code from Brian Raiter, written 1998\",0dh,0ah\n+\n+IFDEF NOUNDERLINE\n+longest_match_686   endp\n+ELSE\n+_longest_match_686  endp\n+ENDIF\n+\n+_TEXT   ends\n+end"}, {"sha": "9ed25f3432f3ef42ca534dccb6dcee657cd85639", "filename": "zlib/contrib/masmx86/gvmat32c.c", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fmasmx86%2Fgvmat32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fmasmx86%2Fgvmat32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx86%2Fgvmat32c.c?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,206 @@\n+/* gvmat32.c -- C portion of the optimized longest_match for 32 bits x86\n+ * Copyright (C) 1995-1996 Jean-loup Gailly and Gilles Vollant.\n+ * File written by Gilles Vollant, by modifiying the longest_match\n+ *  from Jean-loup Gailly in deflate.c\n+ *  it prepare all parameters and call the assembly longest_match_gvasm\n+ *  longest_match execute standard C code is wmask != 0x7fff\n+ *     (assembly code is faster with a fixed wmask)\n+ *\n+ */\n+\n+#include \"deflate.h\"\n+\n+#ifdef ASMV\n+#define NIL 0\n+\n+#define UNALIGNED_OK\n+\n+\n+/* if your C compiler don't add underline before function name,\n+        define ADD_UNDERLINE_ASMFUNC */\n+#ifdef ADD_UNDERLINE_ASMFUNC\n+#define longest_match_7fff _longest_match_7fff\n+#define longest_match_686  _longest_match_686\n+#define cpudetect32        _cpudetect32\n+#endif\n+\n+\n+\n+void match_init()\n+{\n+}\n+\n+unsigned long cpudetect32();\n+\n+uInt longest_match_c(\n+    deflate_state *s,\n+    IPos cur_match);                             /* current match */\n+\n+\n+uInt longest_match_7fff(\n+    deflate_state *s,\n+    IPos cur_match);                             /* current match */\n+\n+uInt longest_match_686(\n+    deflate_state *s,\n+    IPos cur_match);                             /* current match */\n+\n+uInt longest_match(\n+    deflate_state *s,\n+    IPos cur_match)                             /* current match */\n+{\n+    static uInt iIsPPro=2;\n+\n+    if ((s->w_mask == 0x7fff) && (iIsPPro==0))\n+        return longest_match_7fff(s,cur_match);\n+\n+    if (iIsPPro==1)\n+        return longest_match_686(s,cur_match);\n+\n+    if (iIsPPro==2)\n+        iIsPPro = (((cpudetect32()/0x100)&0xf)>=6) ? 1 : 0;\n+\n+    return longest_match_c(s,cur_match);\n+}\n+\n+\n+\n+uInt longest_match_c(s, cur_match)\n+    deflate_state *s;\n+    IPos cur_match;                             /* current match */\n+{\n+    unsigned chain_length = s->max_chain_length;/* max hash chain length */\n+    register Bytef *scan = s->window + s->strstart; /* current string */\n+    register Bytef *match;                       /* matched string */\n+    register int len;                           /* length of current match */\n+    int best_len = s->prev_length;              /* best match length so far */\n+    int nice_match = s->nice_match;             /* stop if match long enough */\n+    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n+        s->strstart - (IPos)MAX_DIST(s) : NIL;\n+    /* Stop when cur_match becomes <= limit. To simplify the code,\n+     * we prevent matches with the string of window index 0.\n+     */\n+    Posf *prev = s->prev;\n+    uInt wmask = s->w_mask;\n+\n+#ifdef UNALIGNED_OK\n+    /* Compare two bytes at a time. Note: this is not always beneficial.\n+     * Try with and without -DUNALIGNED_OK to check.\n+     */\n+    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;\n+    register ush scan_start = *(ushf*)scan;\n+    register ush scan_end   = *(ushf*)(scan+best_len-1);\n+#else\n+    register Bytef *strend = s->window + s->strstart + MAX_MATCH;\n+    register Byte scan_end1  = scan[best_len-1];\n+    register Byte scan_end   = scan[best_len];\n+#endif\n+\n+    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n+     * It is easy to get rid of this optimization if necessary.\n+     */\n+    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n+\n+    /* Do not waste too much time if we already have a good match: */\n+    if (s->prev_length >= s->good_match) {\n+        chain_length >>= 2;\n+    }\n+    /* Do not look for matches beyond the end of the input. This is necessary\n+     * to make deflate deterministic.\n+     */\n+    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n+\n+    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n+\n+    do {\n+        Assert(cur_match < s->strstart, \"no future\");\n+        match = s->window + cur_match;\n+\n+        /* Skip to next match if the match length cannot increase\n+         * or if the match length is less than 2:\n+         */\n+#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)\n+        /* This code assumes sizeof(unsigned short) == 2. Do not use\n+         * UNALIGNED_OK if your compiler uses a different size.\n+         */\n+        if (*(ushf*)(match+best_len-1) != scan_end ||\n+            *(ushf*)match != scan_start) continue;\n+\n+        /* It is not necessary to compare scan[2] and match[2] since they are\n+         * always equal when the other bytes match, given that the hash keys\n+         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at\n+         * strstart+3, +5, ... up to strstart+257. We check for insufficient\n+         * lookahead only every 4th comparison; the 128th check will be made\n+         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is\n+         * necessary to put more guard bytes at the end of the window, or\n+         * to check more often for insufficient lookahead.\n+         */\n+        Assert(scan[2] == match[2], \"scan[2]?\");\n+        scan++, match++;\n+        do {\n+        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n+                 scan < strend);\n+        /* The funny \"do {}\" generates better code on most compilers */\n+\n+        /* Here, scan <= window+strstart+257 */\n+        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n+        if (*scan == *match) scan++;\n+\n+        len = (MAX_MATCH - 1) - (int)(strend-scan);\n+        scan = strend - (MAX_MATCH-1);\n+\n+#else /* UNALIGNED_OK */\n+\n+        if (match[best_len]   != scan_end  ||\n+            match[best_len-1] != scan_end1 ||\n+            *match            != *scan     ||\n+            *++match          != scan[1])      continue;\n+\n+        /* The check at best_len-1 can be removed because it will be made\n+         * again later. (This heuristic is not always a win.)\n+         * It is not necessary to compare scan[2] and match[2] since they\n+         * are always equal when the other bytes match, given that\n+         * the hash keys are equal and that HASH_BITS >= 8.\n+         */\n+        scan += 2, match++;\n+        Assert(*scan == *match, \"match[2]?\");\n+\n+        /* We check for insufficient lookahead only every 8th comparison;\n+         * the 256th check will be made at strstart+258.\n+         */\n+        do {\n+        } while (*++scan == *++match && *++scan == *++match &&\n+                 *++scan == *++match && *++scan == *++match &&\n+                 *++scan == *++match && *++scan == *++match &&\n+                 *++scan == *++match && *++scan == *++match &&\n+                 scan < strend);\n+\n+        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n+\n+        len = MAX_MATCH - (int)(strend - scan);\n+        scan = strend - MAX_MATCH;\n+\n+#endif /* UNALIGNED_OK */\n+\n+        if (len > best_len) {\n+            s->match_start = cur_match;\n+            best_len = len;\n+            if (len >= nice_match) break;\n+#ifdef UNALIGNED_OK\n+            scan_end = *(ushf*)(scan+best_len-1);\n+#else\n+            scan_end1  = scan[best_len-1];\n+            scan_end   = scan[best_len];\n+#endif\n+        }\n+    } while ((cur_match = prev[cur_match & wmask]) > limit\n+             && --chain_length != 0);\n+\n+    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\n+    return s->lookahead;\n+}\n+\n+#endif /* ASMV */"}, {"sha": "7d76e1c6600dd9bd3282bf04c747fe27725a6567", "filename": "zlib/contrib/masmx86/inffas32.asm", "status": "added", "additions": 1033, "deletions": 0, "changes": 1033, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fmasmx86%2Finffas32.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fmasmx86%2Finffas32.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx86%2Finffas32.asm?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,1033 @@\n+; 75 \"inffast.S\"\n+;FILE \"inffast.S\"\n+\n+;;;GLOBAL _inflate_fast\n+\n+;;;SECTION .text\n+\n+\n+\n+\t.586p\n+\t.mmx\n+\n+\tname\tinflate_fast_x86\n+\t.MODEL\tFLAT\n+\n+_DATA\t\t\tsegment\n+inflate_fast_use_mmx:\n+\tdd\t1\n+\n+\n+_TEXT\t\t\tsegment\n+PUBLIC _inflate_fast\n+\n+ALIGN 4\n+_inflate_fast:\n+\tjmp inflate_fast_entry\n+\n+\n+\n+ALIGN 4\n+\tdb\t'Fast decoding Code from Chris Anderson'\n+\tdb\t0\n+\n+ALIGN 4\n+invalid_literal_length_code_msg:\n+\tdb\t'invalid literal/length code'\n+\tdb\t0\n+\n+ALIGN 4\n+invalid_distance_code_msg:\n+\tdb\t'invalid distance code'\n+\tdb\t0\n+\n+ALIGN 4\n+invalid_distance_too_far_msg:\n+\tdb\t'invalid distance too far back'\n+\tdb\t0\n+\n+\n+ALIGN 4\n+inflate_fast_mask:\n+dd\t0\n+dd\t1\n+dd\t3\n+dd\t7\n+dd\t15\n+dd\t31\n+dd\t63\n+dd\t127\n+dd\t255\n+dd\t511\n+dd\t1023\n+dd\t2047\n+dd\t4095\n+dd\t8191\n+dd\t16383\n+dd\t32767\n+dd\t65535\n+dd\t131071\n+dd\t262143\n+dd\t524287\n+dd\t1048575\n+dd\t2097151\n+dd\t4194303\n+dd\t8388607\n+dd\t16777215\n+dd\t33554431\n+dd\t67108863\n+dd\t134217727\n+dd\t268435455\n+dd\t536870911\n+dd\t1073741823\n+dd\t2147483647\n+dd\t4294967295\n+\n+\n+\n+mode_state\t equ\t0\t;/* state->mode\t*/\n+wsize_state\t equ\t32\t;/* state->wsize */\n+write_state\t equ\t(36+4)\t;/* state->write */\n+window_state\t equ\t(40+4)\t;/* state->window */\n+hold_state\t equ\t(44+4)\t;/* state->hold\t*/\n+bits_state\t equ\t(48+4)\t;/* state->bits\t*/\n+lencode_state\t equ\t(64+4)\t;/* state->lencode */\n+distcode_state\t equ\t(68+4)\t;/* state->distcode */\n+lenbits_state\t equ\t(72+4)\t;/* state->lenbits */\n+distbits_state\t equ\t(76+4)\t;/* state->distbits */\n+\n+\n+;;SECTION .text\n+; 205 \"inffast.S\"\n+;GLOBAL\tinflate_fast_use_mmx\n+\n+;SECTION .data\n+\n+\n+; GLOBAL inflate_fast_use_mmx:object\n+;.size inflate_fast_use_mmx, 4\n+; 226 \"inffast.S\"\n+;SECTION .text\n+\n+ALIGN 4\n+inflate_fast_entry:\n+\tpush  edi\n+\tpush  esi\n+\tpush  ebp\n+\tpush  ebx\n+\tpushfd\n+\tsub  esp,64\n+\tcld\n+\n+\n+\n+\n+\tmov  esi, [esp+88]\n+\tmov  edi, [esi+28]\n+\n+\n+\n+\n+\n+\n+\n+\tmov  edx, [esi+4]\n+\tmov  eax, [esi+0]\n+\n+\tadd  edx,eax\n+\tsub  edx,11\n+\n+\tmov  [esp+44],eax\n+\tmov  [esp+20],edx\n+\n+\tmov  ebp, [esp+92]\n+\tmov  ecx, [esi+16]\n+\tmov  ebx, [esi+12]\n+\n+\tsub  ebp,ecx\n+\tneg  ebp\n+\tadd  ebp,ebx\n+\n+\tsub  ecx,257\n+\tadd  ecx,ebx\n+\n+\tmov  [esp+60],ebx\n+\tmov  [esp+40],ebp\n+\tmov  [esp+16],ecx\n+; 285 \"inffast.S\"\n+\tmov  eax, [edi+lencode_state]\n+\tmov  ecx, [edi+distcode_state]\n+\n+\tmov  [esp+8],eax\n+\tmov  [esp+12],ecx\n+\n+\tmov  eax,1\n+\tmov  ecx, [edi+lenbits_state]\n+\tshl  eax,cl\n+\tdec  eax\n+\tmov  [esp+0],eax\n+\n+\tmov  eax,1\n+\tmov  ecx, [edi+distbits_state]\n+\tshl  eax,cl\n+\tdec  eax\n+\tmov  [esp+4],eax\n+\n+\tmov  eax, [edi+wsize_state]\n+\tmov  ecx, [edi+write_state]\n+\tmov  edx, [edi+window_state]\n+\n+\tmov  [esp+52],eax\n+\tmov  [esp+48],ecx\n+\tmov  [esp+56],edx\n+\n+\tmov  ebp, [edi+hold_state]\n+\tmov  ebx, [edi+bits_state]\n+; 321 \"inffast.S\"\n+\tmov  esi, [esp+44]\n+\tmov  ecx, [esp+20]\n+\tcmp  ecx,esi\n+\tja   L_align_long\n+\n+\tadd  ecx,11\n+\tsub  ecx,esi\n+\tmov  eax,12\n+\tsub  eax,ecx\n+\tlea  edi, [esp+28]\n+\trep movsb\n+\tmov  ecx,eax\n+\txor  eax,eax\n+\trep stosb\n+\tlea  esi, [esp+28]\n+\tmov  [esp+20],esi\n+\tjmp  L_is_aligned\n+\n+\n+L_align_long:\n+\ttest  esi,3\n+\tjz   L_is_aligned\n+\txor  eax,eax\n+\tmov  al, [esi]\n+\tinc  esi\n+\tmov  ecx,ebx\n+\tadd  ebx,8\n+\tshl  eax,cl\n+\tor  ebp,eax\n+\tjmp L_align_long\n+\n+L_is_aligned:\n+\tmov  edi, [esp+60]\n+; 366 \"inffast.S\"\n+L_check_mmx:\n+\tcmp  dword ptr [inflate_fast_use_mmx],2\n+\tje   L_init_mmx\n+\tja   L_do_loop\n+\n+\tpush  eax\n+\tpush  ebx\n+\tpush  ecx\n+\tpush  edx\n+\tpushfd\n+\tmov  eax, [esp]\n+\txor  dword ptr [esp],0200000h\n+\n+\n+\n+\n+\tpopfd\n+\tpushfd\n+\tpop  edx\n+\txor  edx,eax\n+\tjz   L_dont_use_mmx\n+\txor  eax,eax\n+\tcpuid\n+\tcmp  ebx,0756e6547h\n+\tjne  L_dont_use_mmx\n+\tcmp  ecx,06c65746eh\n+\tjne  L_dont_use_mmx\n+\tcmp  edx,049656e69h\n+\tjne  L_dont_use_mmx\n+\tmov  eax,1\n+\tcpuid\n+\tshr  eax,8\n+\tand  eax,15\n+\tcmp  eax,6\n+\tjne  L_dont_use_mmx\n+\ttest  edx,0800000h\n+\tjnz  L_use_mmx\n+\tjmp  L_dont_use_mmx\n+L_use_mmx:\n+\tmov  dword ptr [inflate_fast_use_mmx],2\n+\tjmp  L_check_mmx_pop\n+L_dont_use_mmx:\n+\tmov  dword ptr [inflate_fast_use_mmx],3\n+L_check_mmx_pop:\n+\tpop  edx\n+\tpop  ecx\n+\tpop  ebx\n+\tpop  eax\n+\tjmp  L_check_mmx\n+; 426 \"inffast.S\"\n+ALIGN 4\n+L_do_loop:\n+; 437 \"inffast.S\"\n+\tcmp  bl,15\n+\tja   L_get_length_code\n+\n+\txor  eax,eax\n+\tlodsw\n+\tmov  cl,bl\n+\tadd  bl,16\n+\tshl  eax,cl\n+\tor  ebp,eax\n+\n+L_get_length_code:\n+\tmov  edx, [esp+0]\n+\tmov  ecx, [esp+8]\n+\tand  edx,ebp\n+\tmov  eax, [ecx+edx*4]\n+\n+L_dolen:\n+\n+\n+\n+\n+\n+\n+\tmov  cl,ah\n+\tsub  bl,ah\n+\tshr  ebp,cl\n+\n+\n+\n+\n+\n+\n+\ttest  al,al\n+\tjnz   L_test_for_length_base\n+\n+\tshr  eax,16\n+\tstosb\n+\n+L_while_test:\n+\n+\n+\tcmp  [esp+16],edi\n+\tjbe  L_break_loop\n+\n+\tcmp  [esp+20],esi\n+\tja   L_do_loop\n+\tjmp  L_break_loop\n+\n+L_test_for_length_base:\n+; 502 \"inffast.S\"\n+\tmov  edx,eax\n+\tshr  edx,16\n+\tmov  cl,al\n+\n+\ttest  al,16\n+\tjz   L_test_for_second_level_length\n+\tand  cl,15\n+\tjz   L_save_len\n+\tcmp  bl,cl\n+\tjae  L_add_bits_to_len\n+\n+\tmov  ch,cl\n+\txor  eax,eax\n+\tlodsw\n+\tmov  cl,bl\n+\tadd  bl,16\n+\tshl  eax,cl\n+\tor  ebp,eax\n+\tmov  cl,ch\n+\n+L_add_bits_to_len:\n+\tmov  eax,1\n+\tshl  eax,cl\n+\tdec  eax\n+\tsub  bl,cl\n+\tand  eax,ebp\n+\tshr  ebp,cl\n+\tadd  edx,eax\n+\n+L_save_len:\n+\tmov  [esp+24],edx\n+\n+\n+L_decode_distance:\n+; 549 \"inffast.S\"\n+\tcmp  bl,15\n+\tja   L_get_distance_code\n+\n+\txor  eax,eax\n+\tlodsw\n+\tmov  cl,bl\n+\tadd  bl,16\n+\tshl  eax,cl\n+\tor  ebp,eax\n+\n+L_get_distance_code:\n+\tmov  edx, [esp+4]\n+\tmov  ecx, [esp+12]\n+\tand  edx,ebp\n+\tmov  eax, [ecx+edx*4]\n+\n+\n+L_dodist:\n+\tmov  edx,eax\n+\tshr  edx,16\n+\tmov  cl,ah\n+\tsub  bl,ah\n+\tshr  ebp,cl\n+; 584 \"inffast.S\"\n+\tmov  cl,al\n+\n+\ttest  al,16\n+\tjz  L_test_for_second_level_dist\n+\tand  cl,15\n+\tjz  L_check_dist_one\n+\tcmp  bl,cl\n+\tjae  L_add_bits_to_dist\n+\n+\tmov  ch,cl\n+\txor  eax,eax\n+\tlodsw\n+\tmov  cl,bl\n+\tadd  bl,16\n+\tshl  eax,cl\n+\tor  ebp,eax\n+\tmov  cl,ch\n+\n+L_add_bits_to_dist:\n+\tmov  eax,1\n+\tshl  eax,cl\n+\tdec  eax\n+\tsub  bl,cl\n+\tand  eax,ebp\n+\tshr  ebp,cl\n+\tadd  edx,eax\n+\tjmp  L_check_window\n+\n+L_check_window:\n+; 625 \"inffast.S\"\n+\tmov  [esp+44],esi\n+\tmov  eax,edi\n+\tsub  eax, [esp+40]\n+\n+\tcmp  eax,edx\n+\tjb   L_clip_window\n+\n+\tmov  ecx, [esp+24]\n+\tmov  esi,edi\n+\tsub  esi,edx\n+\n+\tsub  ecx,3\n+\tmov  al, [esi]\n+\tmov  [edi],al\n+\tmov  al, [esi+1]\n+\tmov  dl, [esi+2]\n+\tadd  esi,3\n+\tmov  [edi+1],al\n+\tmov  [edi+2],dl\n+\tadd  edi,3\n+\trep movsb\n+\n+\tmov  esi, [esp+44]\n+\tjmp  L_while_test\n+\n+ALIGN 4\n+L_check_dist_one:\n+\tcmp  edx,1\n+\tjne  L_check_window\n+\tcmp  [esp+40],edi\n+\tje  L_check_window\n+\n+\tdec  edi\n+\tmov  ecx, [esp+24]\n+\tmov  al, [edi]\n+\tsub  ecx,3\n+\n+\tmov  [edi+1],al\n+\tmov  [edi+2],al\n+\tmov  [edi+3],al\n+\tadd  edi,4\n+\trep stosb\n+\n+\tjmp  L_while_test\n+\n+ALIGN 4\n+L_test_for_second_level_length:\n+\n+\n+\n+\n+\ttest  al,64\n+\tjnz   L_test_for_end_of_block\n+\n+\tmov  eax,1\n+\tshl  eax,cl\n+\tdec  eax\n+\tand  eax,ebp\n+\tadd  eax,edx\n+\tmov  edx, [esp+8]\n+\tmov  eax, [edx+eax*4]\n+\tjmp  L_dolen\n+\n+ALIGN 4\n+L_test_for_second_level_dist:\n+\n+\n+\n+\n+\ttest  al,64\n+\tjnz   L_invalid_distance_code\n+\n+\tmov  eax,1\n+\tshl  eax,cl\n+\tdec  eax\n+\tand  eax,ebp\n+\tadd  eax,edx\n+\tmov  edx, [esp+12]\n+\tmov  eax, [edx+eax*4]\n+\tjmp  L_dodist\n+\n+ALIGN 4\n+L_clip_window:\n+; 721 \"inffast.S\"\n+\tmov  ecx,eax\n+\tmov  eax, [esp+52]\n+\tneg  ecx\n+\tmov  esi, [esp+56]\n+\n+\tcmp  eax,edx\n+\tjb   L_invalid_distance_too_far\n+\n+\tadd  ecx,edx\n+\tcmp  dword ptr [esp+48],0\n+\tjne  L_wrap_around_window\n+\n+\tsub  eax,ecx\n+\tadd  esi,eax\n+; 749 \"inffast.S\"\n+\tmov  eax, [esp+24]\n+\tcmp  eax,ecx\n+\tjbe  L_do_copy1\n+\n+\tsub  eax,ecx\n+\trep movsb\n+\tmov  esi,edi\n+\tsub  esi,edx\n+\tjmp  L_do_copy1\n+\n+\tcmp  eax,ecx\n+\tjbe  L_do_copy1\n+\n+\tsub  eax,ecx\n+\trep movsb\n+\tmov  esi,edi\n+\tsub  esi,edx\n+\tjmp  L_do_copy1\n+\n+L_wrap_around_window:\n+; 793 \"inffast.S\"\n+\tmov  eax, [esp+48]\n+\tcmp  ecx,eax\n+\tjbe  L_contiguous_in_window\n+\n+\tadd  esi, [esp+52]\n+\tadd  esi,eax\n+\tsub  esi,ecx\n+\tsub  ecx,eax\n+\n+\n+\tmov  eax, [esp+24]\n+\tcmp  eax,ecx\n+\tjbe  L_do_copy1\n+\n+\tsub  eax,ecx\n+\trep movsb\n+\tmov  esi, [esp+56]\n+\tmov  ecx, [esp+48]\n+\tcmp  eax,ecx\n+\tjbe  L_do_copy1\n+\n+\tsub  eax,ecx\n+\trep movsb\n+\tmov  esi,edi\n+\tsub  esi,edx\n+\tjmp  L_do_copy1\n+\n+L_contiguous_in_window:\n+; 836 \"inffast.S\"\n+\tadd  esi,eax\n+\tsub  esi,ecx\n+\n+\n+\tmov  eax, [esp+24]\n+\tcmp  eax,ecx\n+\tjbe  L_do_copy1\n+\n+\tsub  eax,ecx\n+\trep movsb\n+\tmov  esi,edi\n+\tsub  esi,edx\n+\n+L_do_copy1:\n+; 862 \"inffast.S\"\n+\tmov  ecx,eax\n+\trep movsb\n+\n+\tmov  esi, [esp+44]\n+\tjmp  L_while_test\n+; 878 \"inffast.S\"\n+ALIGN 4\n+L_init_mmx:\n+\temms\n+\n+\n+\n+\n+\n+\tmovd mm0,ebp\n+\tmov  ebp,ebx\n+; 896 \"inffast.S\"\n+\tmovd mm4,[esp+0]\n+\tmovq mm3,mm4\n+\tmovd mm5,[esp+4]\n+\tmovq mm2,mm5\n+\tpxor mm1,mm1\n+\tmov  ebx, [esp+8]\n+\tjmp  L_do_loop_mmx\n+\n+ALIGN 4\n+L_do_loop_mmx:\n+\tpsrlq mm0,mm1\n+\n+\tcmp  ebp,32\n+\tja  L_get_length_code_mmx\n+\n+\tmovd mm6,ebp\n+\tmovd mm7,[esi]\n+\tadd  esi,4\n+\tpsllq mm7,mm6\n+\tadd  ebp,32\n+\tpor mm0,mm7\n+\n+L_get_length_code_mmx:\n+\tpand mm4,mm0\n+\tmovd eax,mm4\n+\tmovq mm4,mm3\n+\tmov  eax, [ebx+eax*4]\n+\n+L_dolen_mmx:\n+\tmovzx  ecx,ah\n+\tmovd mm1,ecx\n+\tsub  ebp,ecx\n+\n+\ttest  al,al\n+\tjnz L_test_for_length_base_mmx\n+\n+\tshr  eax,16\n+\tstosb\n+\n+L_while_test_mmx:\n+\n+\n+\tcmp  [esp+16],edi\n+\tjbe L_break_loop\n+\n+\tcmp  [esp+20],esi\n+\tja L_do_loop_mmx\n+\tjmp L_break_loop\n+\n+L_test_for_length_base_mmx:\n+\n+\tmov  edx,eax\n+\tshr  edx,16\n+\n+\ttest  al,16\n+\tjz  L_test_for_second_level_length_mmx\n+\tand  eax,15\n+\tjz L_decode_distance_mmx\n+\n+\tpsrlq mm0,mm1\n+\tmovd mm1,eax\n+\tmovd ecx,mm0\n+\tsub  ebp,eax\n+\tand  ecx, [inflate_fast_mask+eax*4]\n+\tadd  edx,ecx\n+\n+L_decode_distance_mmx:\n+\tpsrlq mm0,mm1\n+\n+\tcmp  ebp,32\n+\tja L_get_dist_code_mmx\n+\n+\tmovd mm6,ebp\n+\tmovd mm7,[esi]\n+\tadd  esi,4\n+\tpsllq mm7,mm6\n+\tadd  ebp,32\n+\tpor mm0,mm7\n+\n+L_get_dist_code_mmx:\n+\tmov  ebx, [esp+12]\n+\tpand mm5,mm0\n+\tmovd eax,mm5\n+\tmovq mm5,mm2\n+\tmov  eax, [ebx+eax*4]\n+\n+L_dodist_mmx:\n+\n+\tmovzx  ecx,ah\n+\tmov  ebx,eax\n+\tshr  ebx,16\n+\tsub  ebp,ecx\n+\tmovd mm1,ecx\n+\n+\ttest  al,16\n+\tjz L_test_for_second_level_dist_mmx\n+\tand  eax,15\n+\tjz L_check_dist_one_mmx\n+\n+L_add_bits_to_dist_mmx:\n+\tpsrlq mm0,mm1\n+\tmovd mm1,eax\n+\tmovd ecx,mm0\n+\tsub  ebp,eax\n+\tand  ecx, [inflate_fast_mask+eax*4]\n+\tadd  ebx,ecx\n+\n+L_check_window_mmx:\n+\tmov  [esp+44],esi\n+\tmov  eax,edi\n+\tsub  eax, [esp+40]\n+\n+\tcmp  eax,ebx\n+\tjb L_clip_window_mmx\n+\n+\tmov  ecx,edx\n+\tmov  esi,edi\n+\tsub  esi,ebx\n+\n+\tsub  ecx,3\n+\tmov  al, [esi]\n+\tmov  [edi],al\n+\tmov  al, [esi+1]\n+\tmov  dl, [esi+2]\n+\tadd  esi,3\n+\tmov  [edi+1],al\n+\tmov  [edi+2],dl\n+\tadd  edi,3\n+\trep movsb\n+\n+\tmov  esi, [esp+44]\n+\tmov  ebx, [esp+8]\n+\tjmp  L_while_test_mmx\n+\n+ALIGN 4\n+L_check_dist_one_mmx:\n+\tcmp  ebx,1\n+\tjne  L_check_window_mmx\n+\tcmp  [esp+40],edi\n+\tje   L_check_window_mmx\n+\n+\tdec  edi\n+\tmov  ecx,edx\n+\tmov  al, [edi]\n+\tsub  ecx,3\n+\n+\tmov  [edi+1],al\n+\tmov  [edi+2],al\n+\tmov  [edi+3],al\n+\tadd  edi,4\n+\trep stosb\n+\n+\tmov  ebx, [esp+8]\n+\tjmp  L_while_test_mmx\n+\n+ALIGN 4\n+L_test_for_second_level_length_mmx:\n+\ttest  al,64\n+\tjnz L_test_for_end_of_block\n+\n+\tand  eax,15\n+\tpsrlq mm0,mm1\n+\tmovd ecx,mm0\n+\tand  ecx, [inflate_fast_mask+eax*4]\n+\tadd  ecx,edx\n+\tmov  eax, [ebx+ecx*4]\n+\tjmp L_dolen_mmx\n+\n+ALIGN 4\n+L_test_for_second_level_dist_mmx:\n+\ttest  al,64\n+\tjnz L_invalid_distance_code\n+\n+\tand  eax,15\n+\tpsrlq mm0,mm1\n+\tmovd ecx,mm0\n+\tand  ecx, [inflate_fast_mask+eax*4]\n+\tmov  eax, [esp+12]\n+\tadd  ecx,ebx\n+\tmov  eax, [eax+ecx*4]\n+\tjmp  L_dodist_mmx\n+\n+ALIGN 4\n+L_clip_window_mmx:\n+\n+\tmov  ecx,eax\n+\tmov  eax, [esp+52]\n+\tneg  ecx\n+\tmov  esi, [esp+56]\n+\n+\tcmp  eax,ebx\n+\tjb  L_invalid_distance_too_far\n+\n+\tadd  ecx,ebx\n+\tcmp  dword ptr [esp+48],0\n+\tjne  L_wrap_around_window_mmx\n+\n+\tsub  eax,ecx\n+\tadd  esi,eax\n+\n+\tcmp  edx,ecx\n+\tjbe  L_do_copy1_mmx\n+\n+\tsub  edx,ecx\n+\trep movsb\n+\tmov  esi,edi\n+\tsub  esi,ebx\n+\tjmp  L_do_copy1_mmx\n+\n+\tcmp  edx,ecx\n+\tjbe  L_do_copy1_mmx\n+\n+\tsub  edx,ecx\n+\trep movsb\n+\tmov  esi,edi\n+\tsub  esi,ebx\n+\tjmp  L_do_copy1_mmx\n+\n+L_wrap_around_window_mmx:\n+\n+\tmov  eax, [esp+48]\n+\tcmp  ecx,eax\n+\tjbe  L_contiguous_in_window_mmx\n+\n+\tadd  esi, [esp+52]\n+\tadd  esi,eax\n+\tsub  esi,ecx\n+\tsub  ecx,eax\n+\n+\n+\tcmp  edx,ecx\n+\tjbe  L_do_copy1_mmx\n+\n+\tsub  edx,ecx\n+\trep movsb\n+\tmov  esi, [esp+56]\n+\tmov  ecx, [esp+48]\n+\tcmp  edx,ecx\n+\tjbe  L_do_copy1_mmx\n+\n+\tsub  edx,ecx\n+\trep movsb\n+\tmov  esi,edi\n+\tsub  esi,ebx\n+\tjmp  L_do_copy1_mmx\n+\n+L_contiguous_in_window_mmx:\n+\n+\tadd  esi,eax\n+\tsub  esi,ecx\n+\n+\n+\tcmp  edx,ecx\n+\tjbe  L_do_copy1_mmx\n+\n+\tsub  edx,ecx\n+\trep movsb\n+\tmov  esi,edi\n+\tsub  esi,ebx\n+\n+L_do_copy1_mmx:\n+\n+\n+\tmov  ecx,edx\n+\trep movsb\n+\n+\tmov  esi, [esp+44]\n+\tmov  ebx, [esp+8]\n+\tjmp  L_while_test_mmx\n+; 1174 \"inffast.S\"\n+L_invalid_distance_code:\n+\n+\n+\n+\n+\n+\tmov  ecx, invalid_distance_code_msg\n+\tmov  edx,26\n+\tjmp  L_update_stream_state\n+\n+L_test_for_end_of_block:\n+\n+\n+\n+\n+\n+\ttest  al,32\n+\tjz  L_invalid_literal_length_code\n+\n+\tmov  ecx,0\n+\tmov  edx,11\n+\tjmp  L_update_stream_state\n+\n+L_invalid_literal_length_code:\n+\n+\n+\n+\n+\n+\tmov  ecx, invalid_literal_length_code_msg\n+\tmov  edx,26\n+\tjmp  L_update_stream_state\n+\n+L_invalid_distance_too_far:\n+\n+\n+\n+\tmov  esi, [esp+44]\n+\tmov  ecx, invalid_distance_too_far_msg\n+\tmov  edx,26\n+\tjmp  L_update_stream_state\n+\n+L_update_stream_state:\n+\n+\tmov  eax, [esp+88]\n+\ttest  ecx,ecx\n+\tjz  L_skip_msg\n+\tmov  [eax+24],ecx\n+L_skip_msg:\n+\tmov  eax, [eax+28]\n+\tmov  [eax+mode_state],edx\n+\tjmp  L_break_loop\n+\n+ALIGN 4\n+L_break_loop:\n+; 1243 \"inffast.S\"\n+\tcmp  dword ptr [inflate_fast_use_mmx],2\n+\tjne  L_update_next_in\n+\n+\n+\n+\tmov  ebx,ebp\n+\n+L_update_next_in:\n+; 1266 \"inffast.S\"\n+\tmov  eax, [esp+88]\n+\tmov  ecx,ebx\n+\tmov  edx, [eax+28]\n+\tshr  ecx,3\n+\tsub  esi,ecx\n+\tshl  ecx,3\n+\tsub  ebx,ecx\n+\tmov  [eax+12],edi\n+\tmov  [edx+bits_state],ebx\n+\tmov  ecx,ebx\n+\n+\tlea  ebx, [esp+28]\n+\tcmp  [esp+20],ebx\n+\tjne  L_buf_not_used\n+\n+\tsub  esi,ebx\n+\tmov  ebx, [eax+0]\n+\tmov  [esp+20],ebx\n+\tadd  esi,ebx\n+\tmov  ebx, [eax+4]\n+\tsub  ebx,11\n+\tadd  [esp+20],ebx\n+\n+L_buf_not_used:\n+\tmov  [eax+0],esi\n+\n+\tmov  ebx,1\n+\tshl  ebx,cl\n+\tdec  ebx\n+\n+\n+\n+\n+\n+\tcmp  dword ptr [inflate_fast_use_mmx],2\n+\tjne  L_update_hold\n+\n+\n+\n+\tpsrlq mm0,mm1\n+\tmovd ebp,mm0\n+\n+\temms\n+\n+L_update_hold:\n+\n+\n+\n+\tand  ebp,ebx\n+\tmov  [edx+hold_state],ebp\n+\n+\n+\n+\n+\tmov  ebx, [esp+20]\n+\tcmp  ebx,esi\n+\tjbe  L_last_is_smaller\n+\n+\tsub  ebx,esi\n+\tadd  ebx,11\n+\tmov  [eax+4],ebx\n+\tjmp  L_fixup_out\n+L_last_is_smaller:\n+\tsub  esi,ebx\n+\tneg  esi\n+\tadd  esi,11\n+\tmov  [eax+4],esi\n+\n+\n+\n+\n+L_fixup_out:\n+\n+\tmov  ebx, [esp+16]\n+\tcmp  ebx,edi\n+\tjbe  L_end_is_smaller\n+\n+\tsub  ebx,edi\n+\tadd  ebx,257\n+\tmov  [eax+16],ebx\n+\tjmp  L_done\n+L_end_is_smaller:\n+\tsub  edi,ebx\n+\tneg  edi\n+\tadd  edi,257\n+\tmov  [eax+16],edi\n+\n+\n+\n+\n+\n+L_done:\n+\tadd  esp,64\n+\tpopfd\n+\tpop  ebx\n+\tpop  ebp\n+\tpop  esi\n+\tpop  edi\n+\tret\n+\n+\n+\n+\n+_TEXT\tends\n+end"}, {"sha": "f3fa0a00f39d625e8e3f7a4ed4fd42b3537f72c5", "filename": "zlib/contrib/masmx86/mkasm.bat", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fmasmx86%2Fmkasm.bat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fmasmx86%2Fmkasm.bat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx86%2Fmkasm.bat?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,3 @@\n+cl /I..\\.. /O2 /c gvmat32c.c\r\n+ml /coff /Zi /c /Flgvmat32.lst gvmat32.asm\r\n+ml /coff /Zi /c /Flinffas32.lst inffas32.asm\r"}, {"sha": "7b57167b71caa09d6a74833b40dc2a8fb2004cbc", "filename": "zlib/contrib/masmx86/readme.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fmasmx86%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fmasmx86%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx86%2Freadme.txt?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,21 @@\n+\n+Summary\n+-------\n+This directory contains ASM implementations of the functions\n+longest_match() and inflate_fast().\n+\n+\n+Use instructions\n+----------------\n+Copy these files into the zlib source directory, then run the\n+appropriate makefile, as suggested below.\n+\n+\n+Build instructions\n+------------------\n+* With Microsoft C and MASM:\n+nmake -f win32/Makefile.msc LOC=\"-DASMV -DASMINF\" OBJA=\"gvmat32c.obj gvmat32.obj inffas32.obj\"\n+\n+* With Borland C and TASM:\n+make -f win32/Makefile.bor LOCAL_ZLIB=\"-DASMV -DASMINF\" OBJA=\"gvmat32c.obj gvmat32.obj inffas32.obj\" OBJPA=\"+gvmat32c.obj+gvmat32.obj+inffas32.obj\"\n+"}, {"sha": "9c7a89cbe823f9553e676947fb7512d890c01e0d", "filename": "zlib/contrib/minizip/crypt.h", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fminizip%2Fcrypt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fminizip%2Fcrypt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fcrypt.h?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,132 @@\n+/* crypt.h -- base code for crypt/uncrypt ZIPfile\n+\n+\n+   Version 1.00, September 10th, 2003\n+\n+   Copyright (C) 1998-2003 Gilles Vollant\n+\n+   This code is a modified version of crypting code in Infozip distribution\n+\n+   The encryption/decryption parts of this source code (as opposed to the\n+   non-echoing password parts) were originally written in Europe.  The\n+   whole source package can be freely distributed, including from the USA.\n+   (Prior to January 2000, re-export from the US was a violation of US law.)\n+\n+   This encryption code is a direct transcription of the algorithm from\n+   Roger Schlafly, described by Phil Katz in the file appnote.txt.  This\n+   file (appnote.txt) is distributed with the PKZIP program (even in the\n+   version without encryption capabilities).\n+\n+   If you don't need crypting in your application, just define symbols\n+   NOCRYPT and NOUNCRYPT.\n+\n+   This code support the \"Traditional PKWARE Encryption\".\n+\n+   The new AES encryption added on Zip format by Winzip (see the page\n+   http://www.winzip.com/aes_info.htm ) and PKWare PKZip 5.x Strong\n+   Encryption is not supported.\n+*/\n+\n+#define CRC32(c, b) ((*(pcrc_32_tab+(((int)(c) ^ (b)) & 0xff))) ^ ((c) >> 8))\n+\n+/***********************************************************************\n+ * Return the next byte in the pseudo-random sequence\n+ */\n+static int decrypt_byte(unsigned long* pkeys, const unsigned long* pcrc_32_tab)\n+{\n+    unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an\n+                     * unpredictable manner on 16-bit systems; not a problem\n+                     * with any known compiler so far, though */\n+\n+    temp = ((unsigned)(*(pkeys+2)) & 0xffff) | 2;\n+    return (int)(((temp * (temp ^ 1)) >> 8) & 0xff);\n+}\n+\n+/***********************************************************************\n+ * Update the encryption keys with the next byte of plain text\n+ */\n+static int update_keys(unsigned long* pkeys,const unsigned long* pcrc_32_tab,int c)\n+{\n+    (*(pkeys+0)) = CRC32((*(pkeys+0)), c);\n+    (*(pkeys+1)) += (*(pkeys+0)) & 0xff;\n+    (*(pkeys+1)) = (*(pkeys+1)) * 134775813L + 1;\n+    {\n+      register int keyshift = (int)((*(pkeys+1)) >> 24);\n+      (*(pkeys+2)) = CRC32((*(pkeys+2)), keyshift);\n+    }\n+    return c;\n+}\n+\n+\n+/***********************************************************************\n+ * Initialize the encryption keys and the random header according to\n+ * the given password.\n+ */\n+static void init_keys(const char* passwd,unsigned long* pkeys,const unsigned long* pcrc_32_tab)\n+{\n+    *(pkeys+0) = 305419896L;\n+    *(pkeys+1) = 591751049L;\n+    *(pkeys+2) = 878082192L;\n+    while (*passwd != '\\0') {\n+        update_keys(pkeys,pcrc_32_tab,(int)*passwd);\n+        passwd++;\n+    }\n+}\n+\n+#define zdecode(pkeys,pcrc_32_tab,c) \\\n+    (update_keys(pkeys,pcrc_32_tab,c ^= decrypt_byte(pkeys,pcrc_32_tab)))\n+\n+#define zencode(pkeys,pcrc_32_tab,c,t) \\\n+    (t=decrypt_byte(pkeys,pcrc_32_tab), update_keys(pkeys,pcrc_32_tab,c), t^(c))\n+\n+#ifdef INCLUDECRYPTINGCODE_IFCRYPTALLOWED\n+\n+#define RAND_HEAD_LEN  12\n+   /* \"last resort\" source for second part of crypt seed pattern */\n+#  ifndef ZCR_SEED2\n+#    define ZCR_SEED2 3141592654UL     /* use PI as default pattern */\n+#  endif\n+\n+static int crypthead(passwd, buf, bufSize, pkeys, pcrc_32_tab, crcForCrypting)\n+    const char *passwd;         /* password string */\n+    unsigned char *buf;         /* where to write header */\n+    int bufSize;\n+    unsigned long* pkeys;\n+    const unsigned long* pcrc_32_tab;\n+    unsigned long crcForCrypting;\n+{\n+    int n;                       /* index in random header */\n+    int t;                       /* temporary */\n+    int c;                       /* random byte */\n+    unsigned char header[RAND_HEAD_LEN-2]; /* random header */\n+    static unsigned calls = 0;   /* ensure different random header each time */\n+\n+    if (bufSize<RAND_HEAD_LEN)\n+      return 0;\n+\n+    /* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the\n+     * output of rand() to get less predictability, since rand() is\n+     * often poorly implemented.\n+     */\n+    if (++calls == 1)\n+    {\n+        srand((unsigned)(time(NULL) ^ ZCR_SEED2));\n+    }\n+    init_keys(passwd, pkeys, pcrc_32_tab);\n+    for (n = 0; n < RAND_HEAD_LEN-2; n++)\n+    {\n+        c = (rand() >> 7) & 0xff;\n+        header[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, c, t);\n+    }\n+    /* Encrypt random header (last two bytes is high word of crc) */\n+    init_keys(passwd, pkeys, pcrc_32_tab);\n+    for (n = 0; n < RAND_HEAD_LEN-2; n++)\n+    {\n+        buf[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, header[n], t);\n+    }\n+    buf[n++] = zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 16) & 0xff, t);\n+    buf[n++] = zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 24) & 0xff, t);\n+    return n;\n+}\n+\n+#endif"}, {"sha": "80443b761f357456c9a69034cad929c44fa0cb68", "filename": "zlib/contrib/minizip/ioapi.c", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fminizip%2Fioapi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fminizip%2Fioapi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fioapi.c?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,177 @@\n+/* ioapi.c -- IO base function header for compress/uncompress .zip\n+   files using zlib + zip or unzip API\n+\n+   Version 1.00, September 10th, 2003\n+\n+   Copyright (C) 1998-2003 Gilles Vollant\n+*/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"zlib.h\"\n+#include \"ioapi.h\"\n+\n+\n+\n+/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */\n+\n+#ifndef SEEK_CUR\n+#define SEEK_CUR    1\n+#endif\n+\n+#ifndef SEEK_END\n+#define SEEK_END    2\n+#endif\n+\n+#ifndef SEEK_SET\n+#define SEEK_SET    0\n+#endif\n+\n+voidpf ZCALLBACK fopen_file_func OF((\n+   voidpf opaque,\n+   const char* filename,\n+   int mode));\n+\n+uLong ZCALLBACK fread_file_func OF((\n+   voidpf opaque,\n+   voidpf stream,\n+   void* buf,\n+   uLong size));\n+\n+uLong ZCALLBACK fwrite_file_func OF((\n+   voidpf opaque,\n+   voidpf stream,\n+   const void* buf,\n+   uLong size));\n+\n+long ZCALLBACK ftell_file_func OF((\n+   voidpf opaque,\n+   voidpf stream));\n+\n+long ZCALLBACK fseek_file_func OF((\n+   voidpf opaque,\n+   voidpf stream,\n+   uLong offset,\n+   int origin));\n+\n+int ZCALLBACK fclose_file_func OF((\n+   voidpf opaque,\n+   voidpf stream));\n+\n+int ZCALLBACK ferror_file_func OF((\n+   voidpf opaque,\n+   voidpf stream));\n+\n+\n+voidpf ZCALLBACK fopen_file_func (opaque, filename, mode)\n+   voidpf opaque;\n+   const char* filename;\n+   int mode;\n+{\n+    FILE* file = NULL;\n+    const char* mode_fopen = NULL;\n+    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)\n+        mode_fopen = \"rb\";\n+    else\n+    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)\n+        mode_fopen = \"r+b\";\n+    else\n+    if (mode & ZLIB_FILEFUNC_MODE_CREATE)\n+        mode_fopen = \"wb\";\n+\n+    if ((filename!=NULL) && (mode_fopen != NULL))\n+        file = fopen(filename, mode_fopen);\n+    return file;\n+}\n+\n+\n+uLong ZCALLBACK fread_file_func (opaque, stream, buf, size)\n+   voidpf opaque;\n+   voidpf stream;\n+   void* buf;\n+   uLong size;\n+{\n+    uLong ret;\n+    ret = fread(buf, 1, (size_t)size, (FILE *)stream);\n+    return ret;\n+}\n+\n+\n+uLong ZCALLBACK fwrite_file_func (opaque, stream, buf, size)\n+   voidpf opaque;\n+   voidpf stream;\n+   const void* buf;\n+   uLong size;\n+{\n+    uLong ret;\n+    ret = fwrite(buf, 1, (size_t)size, (FILE *)stream);\n+    return ret;\n+}\n+\n+long ZCALLBACK ftell_file_func (opaque, stream)\n+   voidpf opaque;\n+   voidpf stream;\n+{\n+    long ret;\n+    ret = ftell((FILE *)stream);\n+    return ret;\n+}\n+\n+long ZCALLBACK fseek_file_func (opaque, stream, offset, origin)\n+   voidpf opaque;\n+   voidpf stream;\n+   uLong offset;\n+   int origin;\n+{\n+    int fseek_origin=0;\n+    long ret;\n+    switch (origin)\n+    {\n+    case ZLIB_FILEFUNC_SEEK_CUR :\n+        fseek_origin = SEEK_CUR;\n+        break;\n+    case ZLIB_FILEFUNC_SEEK_END :\n+        fseek_origin = SEEK_END;\n+        break;\n+    case ZLIB_FILEFUNC_SEEK_SET :\n+        fseek_origin = SEEK_SET;\n+        break;\n+    default: return -1;\n+    }\n+    ret = 0;\n+    fseek((FILE *)stream, offset, fseek_origin);\n+    return ret;\n+}\n+\n+int ZCALLBACK fclose_file_func (opaque, stream)\n+   voidpf opaque;\n+   voidpf stream;\n+{\n+    int ret;\n+    ret = fclose((FILE *)stream);\n+    return ret;\n+}\n+\n+int ZCALLBACK ferror_file_func (opaque, stream)\n+   voidpf opaque;\n+   voidpf stream;\n+{\n+    int ret;\n+    ret = ferror((FILE *)stream);\n+    return ret;\n+}\n+\n+void fill_fopen_filefunc (pzlib_filefunc_def)\n+  zlib_filefunc_def* pzlib_filefunc_def;\n+{\n+    pzlib_filefunc_def->zopen_file = fopen_file_func;\n+    pzlib_filefunc_def->zread_file = fread_file_func;\n+    pzlib_filefunc_def->zwrite_file = fwrite_file_func;\n+    pzlib_filefunc_def->ztell_file = ftell_file_func;\n+    pzlib_filefunc_def->zseek_file = fseek_file_func;\n+    pzlib_filefunc_def->zclose_file = fclose_file_func;\n+    pzlib_filefunc_def->zerror_file = ferror_file_func;\n+    pzlib_filefunc_def->opaque = NULL;\n+}"}, {"sha": "6bc2a2cc87227dd215136b8c2c0f81678fb28e62", "filename": "zlib/contrib/minizip/ioapi.h", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fminizip%2Fioapi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fminizip%2Fioapi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fioapi.h?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,75 @@\n+/* ioapi.h -- IO base function header for compress/uncompress .zip\n+   files using zlib + zip or unzip API\n+\n+   Version 1.00, September 10th, 2003\n+\n+   Copyright (C) 1998-2003 Gilles Vollant\n+*/\n+\n+#ifndef _ZLIBIOAPI_H\n+#define _ZLIBIOAPI_H\n+\n+\n+#define ZLIB_FILEFUNC_SEEK_CUR (1)\n+#define ZLIB_FILEFUNC_SEEK_END (2)\n+#define ZLIB_FILEFUNC_SEEK_SET (0)\n+\n+#define ZLIB_FILEFUNC_MODE_READ      (1)\n+#define ZLIB_FILEFUNC_MODE_WRITE     (2)\n+#define ZLIB_FILEFUNC_MODE_READWRITEFILTER (3)\n+\n+#define ZLIB_FILEFUNC_MODE_EXISTING (4)\n+#define ZLIB_FILEFUNC_MODE_CREATE   (8)\n+\n+\n+#ifndef ZCALLBACK\n+\n+#if (defined(WIN32) || defined (WINDOWS) || defined (_WINDOWS)) && defined(CALLBACK) && defined (USEWINDOWS_CALLBACK)\n+#define ZCALLBACK CALLBACK\n+#else\n+#define ZCALLBACK\n+#endif\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef voidpf (ZCALLBACK *open_file_func) OF((voidpf opaque, const char* filename, int mode));\n+typedef uLong  (ZCALLBACK *read_file_func) OF((voidpf opaque, voidpf stream, void* buf, uLong size));\n+typedef uLong  (ZCALLBACK *write_file_func) OF((voidpf opaque, voidpf stream, const void* buf, uLong size));\n+typedef long   (ZCALLBACK *tell_file_func) OF((voidpf opaque, voidpf stream));\n+typedef long   (ZCALLBACK *seek_file_func) OF((voidpf opaque, voidpf stream, uLong offset, int origin));\n+typedef int    (ZCALLBACK *close_file_func) OF((voidpf opaque, voidpf stream));\n+typedef int    (ZCALLBACK *testerror_file_func) OF((voidpf opaque, voidpf stream));\n+\n+typedef struct zlib_filefunc_def_s\n+{\n+    open_file_func      zopen_file;\n+    read_file_func      zread_file;\n+    write_file_func     zwrite_file;\n+    tell_file_func      ztell_file;\n+    seek_file_func      zseek_file;\n+    close_file_func     zclose_file;\n+    testerror_file_func zerror_file;\n+    voidpf              opaque;\n+} zlib_filefunc_def;\n+\n+\n+\n+void fill_fopen_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));\n+\n+#define ZREAD(filefunc,filestream,buf,size) ((*((filefunc).zread_file))((filefunc).opaque,filestream,buf,size))\n+#define ZWRITE(filefunc,filestream,buf,size) ((*((filefunc).zwrite_file))((filefunc).opaque,filestream,buf,size))\n+#define ZTELL(filefunc,filestream) ((*((filefunc).ztell_file))((filefunc).opaque,filestream))\n+#define ZSEEK(filefunc,filestream,pos,mode) ((*((filefunc).zseek_file))((filefunc).opaque,filestream,pos,mode))\n+#define ZCLOSE(filefunc,filestream) ((*((filefunc).zclose_file))((filefunc).opaque,filestream))\n+#define ZERROR(filefunc,filestream) ((*((filefunc).zerror_file))((filefunc).opaque,filestream))\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n+"}, {"sha": "02b27cb76148809c231caba54cb916de575f27d1", "filename": "zlib/contrib/minizip/iowin32.c", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fminizip%2Fiowin32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fminizip%2Fiowin32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fiowin32.c?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,270 @@\n+/* iowin32.c -- IO base function header for compress/uncompress .zip\n+   files using zlib + zip or unzip API\n+   This IO API version uses the Win32 API (for Microsoft Windows)\n+\n+   Version 1.00, September 10th, 2003\n+\n+   Copyright (C) 1998-2003 Gilles Vollant\n+*/\n+\n+#include <stdlib.h>\n+\n+#include \"zlib.h\"\n+#include \"ioapi.h\"\n+#include \"iowin32.h\"\n+\n+#ifndef INVALID_HANDLE_VALUE\n+#define INVALID_HANDLE_VALUE (0xFFFFFFFF)\n+#endif\n+\n+#ifndef INVALID_SET_FILE_POINTER\n+#define INVALID_SET_FILE_POINTER ((DWORD)-1)\n+#endif\n+\n+voidpf ZCALLBACK win32_open_file_func OF((\n+   voidpf opaque,\n+   const char* filename,\n+   int mode));\n+\n+uLong ZCALLBACK win32_read_file_func OF((\n+   voidpf opaque,\n+   voidpf stream,\n+   void* buf,\n+   uLong size));\n+\n+uLong ZCALLBACK win32_write_file_func OF((\n+   voidpf opaque,\n+   voidpf stream,\n+   const void* buf,\n+   uLong size));\n+\n+long ZCALLBACK win32_tell_file_func OF((\n+   voidpf opaque,\n+   voidpf stream));\n+\n+long ZCALLBACK win32_seek_file_func OF((\n+   voidpf opaque,\n+   voidpf stream,\n+   uLong offset,\n+   int origin));\n+\n+int ZCALLBACK win32_close_file_func OF((\n+   voidpf opaque,\n+   voidpf stream));\n+\n+int ZCALLBACK win32_error_file_func OF((\n+   voidpf opaque,\n+   voidpf stream));\n+\n+typedef struct\n+{\n+    HANDLE hf;\n+    int error;\n+} WIN32FILE_IOWIN;\n+\n+voidpf ZCALLBACK win32_open_file_func (opaque, filename, mode)\n+   voidpf opaque;\n+   const char* filename;\n+   int mode;\n+{\n+    const char* mode_fopen = NULL;\n+    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;\n+    HANDLE hFile = 0;\n+    voidpf ret=NULL;\n+\n+    dwDesiredAccess = dwShareMode = dwFlagsAndAttributes = 0;\n+\n+    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)\n+    {\n+        dwDesiredAccess = GENERIC_READ;\n+        dwCreationDisposition = OPEN_EXISTING;\n+        dwShareMode = FILE_SHARE_READ;\n+    }\n+    else\n+    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)\n+    {\n+        dwDesiredAccess = GENERIC_WRITE | GENERIC_READ;\n+        dwCreationDisposition = OPEN_EXISTING;\n+    }\n+    else\n+    if (mode & ZLIB_FILEFUNC_MODE_CREATE)\n+    {\n+        dwDesiredAccess = GENERIC_WRITE | GENERIC_READ;\n+        dwCreationDisposition = CREATE_ALWAYS;\n+    }\n+\n+    if ((filename!=NULL) && (dwDesiredAccess != 0))\n+        hFile = CreateFile((LPCTSTR)filename, dwDesiredAccess, dwShareMode, NULL,\n+                      dwCreationDisposition, dwFlagsAndAttributes, NULL);\n+\n+    if (hFile == INVALID_HANDLE_VALUE)\n+        hFile = NULL;\n+\n+    if (hFile != NULL)\n+    {\n+        WIN32FILE_IOWIN w32fiow;\n+        w32fiow.hf = hFile;\n+        w32fiow.error = 0;\n+        ret = malloc(sizeof(WIN32FILE_IOWIN));\n+        if (ret==NULL)\n+            CloseHandle(hFile);\n+        else *((WIN32FILE_IOWIN*)ret) = w32fiow;\n+    }\n+    return ret;\n+}\n+\n+\n+uLong ZCALLBACK win32_read_file_func (opaque, stream, buf, size)\n+   voidpf opaque;\n+   voidpf stream;\n+   void* buf;\n+   uLong size;\n+{\n+    uLong ret=0;\n+    HANDLE hFile = NULL;\n+    if (stream!=NULL)\n+        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n+    if (hFile != NULL)\n+        if (!ReadFile(hFile, buf, size, &ret, NULL))\n+        {\n+            DWORD dwErr = GetLastError();\n+            if (dwErr == ERROR_HANDLE_EOF)\n+                dwErr = 0;\n+            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n+        }\n+\n+    return ret;\n+}\n+\n+\n+uLong ZCALLBACK win32_write_file_func (opaque, stream, buf, size)\n+   voidpf opaque;\n+   voidpf stream;\n+   const void* buf;\n+   uLong size;\n+{\n+    uLong ret=0;\n+    HANDLE hFile = NULL;\n+    if (stream!=NULL)\n+        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n+\n+    if (hFile !=NULL)\n+        if (!WriteFile(hFile, buf, size, &ret, NULL))\n+        {\n+            DWORD dwErr = GetLastError();\n+            if (dwErr == ERROR_HANDLE_EOF)\n+                dwErr = 0;\n+            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n+        }\n+\n+    return ret;\n+}\n+\n+long ZCALLBACK win32_tell_file_func (opaque, stream)\n+   voidpf opaque;\n+   voidpf stream;\n+{\n+    long ret=-1;\n+    HANDLE hFile = NULL;\n+    if (stream!=NULL)\n+        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n+    if (hFile != NULL)\n+    {\n+        DWORD dwSet = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);\n+        if (dwSet == INVALID_SET_FILE_POINTER)\n+        {\n+            DWORD dwErr = GetLastError();\n+            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n+            ret = -1;\n+        }\n+        else\n+            ret=(long)dwSet;\n+    }\n+    return ret;\n+}\n+\n+long ZCALLBACK win32_seek_file_func (opaque, stream, offset, origin)\n+   voidpf opaque;\n+   voidpf stream;\n+   uLong offset;\n+   int origin;\n+{\n+    DWORD dwMoveMethod=0xFFFFFFFF;\n+    HANDLE hFile = NULL;\n+\n+    long ret=-1;\n+    if (stream!=NULL)\n+        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n+    switch (origin)\n+    {\n+    case ZLIB_FILEFUNC_SEEK_CUR :\n+        dwMoveMethod = FILE_CURRENT;\n+        break;\n+    case ZLIB_FILEFUNC_SEEK_END :\n+        dwMoveMethod = FILE_END;\n+        break;\n+    case ZLIB_FILEFUNC_SEEK_SET :\n+        dwMoveMethod = FILE_BEGIN;\n+        break;\n+    default: return -1;\n+    }\n+\n+    if (hFile != NULL)\n+    {\n+        DWORD dwSet = SetFilePointer(hFile, offset, NULL, dwMoveMethod);\n+        if (dwSet == INVALID_SET_FILE_POINTER)\n+        {\n+            DWORD dwErr = GetLastError();\n+            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n+            ret = -1;\n+        }\n+        else\n+            ret=0;\n+    }\n+    return ret;\n+}\n+\n+int ZCALLBACK win32_close_file_func (opaque, stream)\n+   voidpf opaque;\n+   voidpf stream;\n+{\n+    int ret=-1;\n+\n+    if (stream!=NULL)\n+    {\n+        HANDLE hFile;\n+        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n+        if (hFile != NULL)\n+        {\n+            CloseHandle(hFile);\n+            ret=0;\n+        }\n+        free(stream);\n+    }\n+    return ret;\n+}\n+\n+int ZCALLBACK win32_error_file_func (opaque, stream)\n+   voidpf opaque;\n+   voidpf stream;\n+{\n+    int ret=-1;\n+    if (stream!=NULL)\n+    {\n+        ret = ((WIN32FILE_IOWIN*)stream) -> error;\n+    }\n+    return ret;\n+}\n+\n+void fill_win32_filefunc (pzlib_filefunc_def)\n+  zlib_filefunc_def* pzlib_filefunc_def;\n+{\n+    pzlib_filefunc_def->zopen_file = win32_open_file_func;\n+    pzlib_filefunc_def->zread_file = win32_read_file_func;\n+    pzlib_filefunc_def->zwrite_file = win32_write_file_func;\n+    pzlib_filefunc_def->ztell_file = win32_tell_file_func;\n+    pzlib_filefunc_def->zseek_file = win32_seek_file_func;\n+    pzlib_filefunc_def->zclose_file = win32_close_file_func;\n+    pzlib_filefunc_def->zerror_file = win32_error_file_func;\n+    pzlib_filefunc_def->opaque=NULL;\n+}"}, {"sha": "c0ebd50738e4c24755c9751991b26616c48680b2", "filename": "zlib/contrib/minizip/iowin32.h", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fminizip%2Fiowin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fminizip%2Fiowin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fiowin32.h?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,21 @@\n+/* iowin32.h -- IO base function header for compress/uncompress .zip\n+   files using zlib + zip or unzip API\n+   This IO API version uses the Win32 API (for Microsoft Windows)\n+\n+   Version 1.00, September 10th, 2003\n+\n+   Copyright (C) 1998-2003 Gilles Vollant\n+*/\n+\n+#include <windows.h>\n+\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+void fill_win32_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));\n+\n+#ifdef __cplusplus\n+}\n+#endif"}, {"sha": "5518b36a7308551bfbf3ec7fc8591273990a59cd", "filename": "zlib/contrib/pascal/example.pas", "status": "added", "additions": 599, "deletions": 0, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpascal%2Fexample.pas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpascal%2Fexample.pas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpascal%2Fexample.pas?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,599 @@\n+(* example.c -- usage example of the zlib compression library\n+ * Copyright (C) 1995-2003 Jean-loup Gailly.\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ *\n+ * Pascal translation\n+ * Copyright (C) 1998 by Jacques Nomssi Nzali.\n+ * For conditions of distribution and use, see copyright notice in readme.txt\n+ *\n+ * Adaptation to the zlibpas interface\n+ * Copyright (C) 2003 by Cosmin Truta.\n+ * For conditions of distribution and use, see copyright notice in readme.txt\n+ *)\n+\n+program example;\n+\n+{$DEFINE TEST_COMPRESS}\n+{DO NOT $DEFINE TEST_GZIO}\n+{$DEFINE TEST_DEFLATE}\n+{$DEFINE TEST_INFLATE}\n+{$DEFINE TEST_FLUSH}\n+{$DEFINE TEST_SYNC}\n+{$DEFINE TEST_DICT}\n+\n+uses SysUtils, zlibpas;\n+\n+const TESTFILE = 'foo.gz';\n+\n+(* \"hello world\" would be more standard, but the repeated \"hello\"\n+ * stresses the compression code better, sorry...\n+ *)\n+const hello: PChar = 'hello, hello!';\n+\n+const dictionary: PChar = 'hello';\n+\n+var dictId: LongInt; (* Adler32 value of the dictionary *)\n+\n+procedure CHECK_ERR(err: Integer; msg: String);\n+begin\n+  if err <> Z_OK then\n+  begin\n+    WriteLn(msg, ' error: ', err);\n+    Halt(1);\n+  end;\n+end;\n+\n+procedure EXIT_ERR(const msg: String);\n+begin\n+  WriteLn('Error: ', msg);\n+  Halt(1);\n+end;\n+\n+(* ===========================================================================\n+ * Test compress and uncompress\n+ *)\n+{$IFDEF TEST_COMPRESS}\n+procedure test_compress(compr: Pointer; comprLen: LongInt;\n+                        uncompr: Pointer; uncomprLen: LongInt);\n+var err: Integer;\n+    len: LongInt;\n+begin\n+  len := StrLen(hello)+1;\n+\n+  err := compress(compr, comprLen, hello, len);\n+  CHECK_ERR(err, 'compress');\n+\n+  StrCopy(PChar(uncompr), 'garbage');\n+\n+  err := uncompress(uncompr, uncomprLen, compr, comprLen);\n+  CHECK_ERR(err, 'uncompress');\n+\n+  if StrComp(PChar(uncompr), hello) <> 0 then\n+    EXIT_ERR('bad uncompress')\n+  else\n+    WriteLn('uncompress(): ', PChar(uncompr));\n+end;\n+{$ENDIF}\n+\n+(* ===========================================================================\n+ * Test read/write of .gz files\n+ *)\n+{$IFDEF TEST_GZIO}\n+procedure test_gzio(const fname: PChar; (* compressed file name *)\n+                    uncompr: Pointer;\n+                    uncomprLen: LongInt);\n+var err: Integer;\n+    len: Integer;\n+    zfile: gzFile;\n+    pos: LongInt;\n+begin\n+  len := StrLen(hello)+1;\n+\n+  zfile := gzopen(fname, 'wb');\n+  if zfile = NIL then\n+  begin\n+    WriteLn('gzopen error');\n+    Halt(1);\n+  end;\n+  gzputc(zfile, 'h');\n+  if gzputs(zfile, 'ello') <> 4 then\n+  begin\n+    WriteLn('gzputs err: ', gzerror(zfile, err));\n+    Halt(1);\n+  end;\n+  {$IFDEF GZ_FORMAT_STRING}\n+  if gzprintf(zfile, ', %s!', 'hello') <> 8 then\n+  begin\n+    WriteLn('gzprintf err: ', gzerror(zfile, err));\n+    Halt(1);\n+  end;\n+  {$ELSE}\n+  if gzputs(zfile, ', hello!') <> 8 then\n+  begin\n+    WriteLn('gzputs err: ', gzerror(zfile, err));\n+    Halt(1);\n+  end;\n+  {$ENDIF}\n+  gzseek(zfile, 1, SEEK_CUR); (* add one zero byte *)\n+  gzclose(zfile);\n+\n+  zfile := gzopen(fname, 'rb');\n+  if zfile = NIL then\n+  begin\n+    WriteLn('gzopen error');\n+    Halt(1);\n+  end;\n+\n+  StrCopy(PChar(uncompr), 'garbage');\n+\n+  if gzread(zfile, uncompr, uncomprLen) <> len then\n+  begin\n+    WriteLn('gzread err: ', gzerror(zfile, err));\n+    Halt(1);\n+  end;\n+  if StrComp(PChar(uncompr), hello) <> 0 then\n+  begin\n+    WriteLn('bad gzread: ', PChar(uncompr));\n+    Halt(1);\n+  end\n+  else\n+    WriteLn('gzread(): ', PChar(uncompr));\n+\n+  pos := gzseek(zfile, -8, SEEK_CUR);\n+  if (pos <> 6) or (gztell(zfile) <> pos) then\n+  begin\n+    WriteLn('gzseek error, pos=', pos, ', gztell=', gztell(zfile));\n+    Halt(1);\n+  end;\n+\n+  if gzgetc(zfile) <> ' ' then\n+  begin\n+    WriteLn('gzgetc error');\n+    Halt(1);\n+  end;\n+\n+  if gzungetc(' ', zfile) <> ' ' then\n+  begin\n+    WriteLn('gzungetc error');\n+    Halt(1);\n+  end;\n+\n+  gzgets(zfile, PChar(uncompr), uncomprLen);\n+  uncomprLen := StrLen(PChar(uncompr));\n+  if uncomprLen <> 7 then (* \" hello!\" *)\n+  begin\n+    WriteLn('gzgets err after gzseek: ', gzerror(zfile, err));\n+    Halt(1);\n+  end;\n+  if StrComp(PChar(uncompr), hello + 6) <> 0 then\n+  begin\n+    WriteLn('bad gzgets after gzseek');\n+    Halt(1);\n+  end\n+  else\n+    WriteLn('gzgets() after gzseek: ', PChar(uncompr));\n+\n+  gzclose(zfile);\n+end;\n+{$ENDIF}\n+\n+(* ===========================================================================\n+ * Test deflate with small buffers\n+ *)\n+{$IFDEF TEST_DEFLATE}\n+procedure test_deflate(compr: Pointer; comprLen: LongInt);\n+var c_stream: z_stream; (* compression stream *)\n+    err: Integer;\n+    len: LongInt;\n+begin\n+  len := StrLen(hello)+1;\n+\n+  c_stream.zalloc := NIL;\n+  c_stream.zfree := NIL;\n+  c_stream.opaque := NIL;\n+\n+  err := deflateInit(c_stream, Z_DEFAULT_COMPRESSION);\n+  CHECK_ERR(err, 'deflateInit');\n+\n+  c_stream.next_in := hello;\n+  c_stream.next_out := compr;\n+\n+  while (c_stream.total_in <> len) and\n+        (c_stream.total_out < comprLen) do\n+  begin\n+    c_stream.avail_out := 1; { force small buffers }\n+    c_stream.avail_in := 1;\n+    err := deflate(c_stream, Z_NO_FLUSH);\n+    CHECK_ERR(err, 'deflate');\n+  end;\n+\n+  (* Finish the stream, still forcing small buffers: *)\n+  while TRUE do\n+  begin\n+    c_stream.avail_out := 1;\n+    err := deflate(c_stream, Z_FINISH);\n+    if err = Z_STREAM_END then\n+      break;\n+    CHECK_ERR(err, 'deflate');\n+  end;\n+\n+  err := deflateEnd(c_stream);\n+  CHECK_ERR(err, 'deflateEnd');\n+end;\n+{$ENDIF}\n+\n+(* ===========================================================================\n+ * Test inflate with small buffers\n+ *)\n+{$IFDEF TEST_INFLATE}\n+procedure test_inflate(compr: Pointer; comprLen : LongInt;\n+                       uncompr: Pointer; uncomprLen : LongInt);\n+var err: Integer;\n+    d_stream: z_stream; (* decompression stream *)\n+begin\n+  StrCopy(PChar(uncompr), 'garbage');\n+\n+  d_stream.zalloc := NIL;\n+  d_stream.zfree := NIL;\n+  d_stream.opaque := NIL;\n+\n+  d_stream.next_in := compr;\n+  d_stream.avail_in := 0;\n+  d_stream.next_out := uncompr;\n+\n+  err := inflateInit(d_stream);\n+  CHECK_ERR(err, 'inflateInit');\n+\n+  while (d_stream.total_out < uncomprLen) and\n+        (d_stream.total_in < comprLen) do\n+  begin\n+    d_stream.avail_out := 1; (* force small buffers *)\n+    d_stream.avail_in := 1;\n+    err := inflate(d_stream, Z_NO_FLUSH);\n+    if err = Z_STREAM_END then\n+      break;\n+    CHECK_ERR(err, 'inflate');\n+  end;\n+\n+  err := inflateEnd(d_stream);\n+  CHECK_ERR(err, 'inflateEnd');\n+\n+  if StrComp(PChar(uncompr), hello) <> 0 then\n+    EXIT_ERR('bad inflate')\n+  else\n+    WriteLn('inflate(): ', PChar(uncompr));\n+end;\n+{$ENDIF}\n+\n+(* ===========================================================================\n+ * Test deflate with large buffers and dynamic change of compression level\n+ *)\n+{$IFDEF TEST_DEFLATE}\n+procedure test_large_deflate(compr: Pointer; comprLen: LongInt;\n+                             uncompr: Pointer; uncomprLen: LongInt);\n+var c_stream: z_stream; (* compression stream *)\n+    err: Integer;\n+begin\n+  c_stream.zalloc := NIL;\n+  c_stream.zfree := NIL;\n+  c_stream.opaque := NIL;\n+\n+  err := deflateInit(c_stream, Z_BEST_SPEED);\n+  CHECK_ERR(err, 'deflateInit');\n+\n+  c_stream.next_out := compr;\n+  c_stream.avail_out := Integer(comprLen);\n+\n+  (* At this point, uncompr is still mostly zeroes, so it should compress\n+   * very well:\n+   *)\n+  c_stream.next_in := uncompr;\n+  c_stream.avail_in := Integer(uncomprLen);\n+  err := deflate(c_stream, Z_NO_FLUSH);\n+  CHECK_ERR(err, 'deflate');\n+  if c_stream.avail_in <> 0 then\n+    EXIT_ERR('deflate not greedy');\n+\n+  (* Feed in already compressed data and switch to no compression: *)\n+  deflateParams(c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);\n+  c_stream.next_in := compr;\n+  c_stream.avail_in := Integer(comprLen div 2);\n+  err := deflate(c_stream, Z_NO_FLUSH);\n+  CHECK_ERR(err, 'deflate');\n+\n+  (* Switch back to compressing mode: *)\n+  deflateParams(c_stream, Z_BEST_COMPRESSION, Z_FILTERED);\n+  c_stream.next_in := uncompr;\n+  c_stream.avail_in := Integer(uncomprLen);\n+  err := deflate(c_stream, Z_NO_FLUSH);\n+  CHECK_ERR(err, 'deflate');\n+\n+  err := deflate(c_stream, Z_FINISH);\n+  if err <> Z_STREAM_END then\n+    EXIT_ERR('deflate should report Z_STREAM_END');\n+\n+  err := deflateEnd(c_stream);\n+  CHECK_ERR(err, 'deflateEnd');\n+end;\n+{$ENDIF}\n+\n+(* ===========================================================================\n+ * Test inflate with large buffers\n+ *)\n+{$IFDEF TEST_INFLATE}\n+procedure test_large_inflate(compr: Pointer; comprLen: LongInt;\n+                             uncompr: Pointer; uncomprLen: LongInt);\n+var err: Integer;\n+    d_stream: z_stream; (* decompression stream *)\n+begin\n+  StrCopy(PChar(uncompr), 'garbage');\n+\n+  d_stream.zalloc := NIL;\n+  d_stream.zfree := NIL;\n+  d_stream.opaque := NIL;\n+\n+  d_stream.next_in := compr;\n+  d_stream.avail_in := Integer(comprLen);\n+\n+  err := inflateInit(d_stream);\n+  CHECK_ERR(err, 'inflateInit');\n+\n+  while TRUE do\n+  begin\n+    d_stream.next_out := uncompr;            (* discard the output *)\n+    d_stream.avail_out := Integer(uncomprLen);\n+    err := inflate(d_stream, Z_NO_FLUSH);\n+    if err = Z_STREAM_END then\n+      break;\n+    CHECK_ERR(err, 'large inflate');\n+  end;\n+\n+  err := inflateEnd(d_stream);\n+  CHECK_ERR(err, 'inflateEnd');\n+\n+  if d_stream.total_out <> 2 * uncomprLen + comprLen div 2 then\n+  begin\n+    WriteLn('bad large inflate: ', d_stream.total_out);\n+    Halt(1);\n+  end\n+  else\n+    WriteLn('large_inflate(): OK');\n+end;\n+{$ENDIF}\n+\n+(* ===========================================================================\n+ * Test deflate with full flush\n+ *)\n+{$IFDEF TEST_FLUSH}\n+procedure test_flush(compr: Pointer; var comprLen : LongInt);\n+var c_stream: z_stream; (* compression stream *)\n+    err: Integer;\n+    len: Integer;\n+begin\n+  len := StrLen(hello)+1;\n+\n+  c_stream.zalloc := NIL;\n+  c_stream.zfree := NIL;\n+  c_stream.opaque := NIL;\n+\n+  err := deflateInit(c_stream, Z_DEFAULT_COMPRESSION);\n+  CHECK_ERR(err, 'deflateInit');\n+\n+  c_stream.next_in := hello;\n+  c_stream.next_out := compr;\n+  c_stream.avail_in := 3;\n+  c_stream.avail_out := Integer(comprLen);\n+  err := deflate(c_stream, Z_FULL_FLUSH);\n+  CHECK_ERR(err, 'deflate');\n+\n+  Inc(PByteArray(compr)^[3]); (* force an error in first compressed block *)\n+  c_stream.avail_in := len - 3;\n+\n+  err := deflate(c_stream, Z_FINISH);\n+  if err <> Z_STREAM_END then\n+    CHECK_ERR(err, 'deflate');\n+\n+  err := deflateEnd(c_stream);\n+  CHECK_ERR(err, 'deflateEnd');\n+\n+  comprLen := c_stream.total_out;\n+end;\n+{$ENDIF}\n+\n+(* ===========================================================================\n+ * Test inflateSync()\n+ *)\n+{$IFDEF TEST_SYNC}\n+procedure test_sync(compr: Pointer; comprLen: LongInt;\n+                    uncompr: Pointer; uncomprLen : LongInt);\n+var err: Integer;\n+    d_stream: z_stream; (* decompression stream *)\n+begin\n+  StrCopy(PChar(uncompr), 'garbage');\n+\n+  d_stream.zalloc := NIL;\n+  d_stream.zfree := NIL;\n+  d_stream.opaque := NIL;\n+\n+  d_stream.next_in := compr;\n+  d_stream.avail_in := 2; (* just read the zlib header *)\n+\n+  err := inflateInit(d_stream);\n+  CHECK_ERR(err, 'inflateInit');\n+\n+  d_stream.next_out := uncompr;\n+  d_stream.avail_out := Integer(uncomprLen);\n+\n+  inflate(d_stream, Z_NO_FLUSH);\n+  CHECK_ERR(err, 'inflate');\n+\n+  d_stream.avail_in := Integer(comprLen-2);   (* read all compressed data *)\n+  err := inflateSync(d_stream);               (* but skip the damaged part *)\n+  CHECK_ERR(err, 'inflateSync');\n+\n+  err := inflate(d_stream, Z_FINISH);\n+  if err <> Z_DATA_ERROR then\n+    EXIT_ERR('inflate should report DATA_ERROR');\n+    (* Because of incorrect adler32 *)\n+\n+  err := inflateEnd(d_stream);\n+  CHECK_ERR(err, 'inflateEnd');\n+\n+  WriteLn('after inflateSync(): hel', PChar(uncompr));\n+end;\n+{$ENDIF}\n+\n+(* ===========================================================================\n+ * Test deflate with preset dictionary\n+ *)\n+{$IFDEF TEST_DICT}\n+procedure test_dict_deflate(compr: Pointer; comprLen: LongInt);\n+var c_stream: z_stream; (* compression stream *)\n+    err: Integer;\n+begin\n+  c_stream.zalloc := NIL;\n+  c_stream.zfree := NIL;\n+  c_stream.opaque := NIL;\n+\n+  err := deflateInit(c_stream, Z_BEST_COMPRESSION);\n+  CHECK_ERR(err, 'deflateInit');\n+\n+  err := deflateSetDictionary(c_stream, dictionary, StrLen(dictionary));\n+  CHECK_ERR(err, 'deflateSetDictionary');\n+\n+  dictId := c_stream.adler;\n+  c_stream.next_out := compr;\n+  c_stream.avail_out := Integer(comprLen);\n+\n+  c_stream.next_in := hello;\n+  c_stream.avail_in := StrLen(hello)+1;\n+\n+  err := deflate(c_stream, Z_FINISH);\n+  if err <> Z_STREAM_END then\n+    EXIT_ERR('deflate should report Z_STREAM_END');\n+\n+  err := deflateEnd(c_stream);\n+  CHECK_ERR(err, 'deflateEnd');\n+end;\n+{$ENDIF}\n+\n+(* ===========================================================================\n+ * Test inflate with a preset dictionary\n+ *)\n+{$IFDEF TEST_DICT}\n+procedure test_dict_inflate(compr: Pointer; comprLen: LongInt;\n+                            uncompr: Pointer; uncomprLen: LongInt);\n+var err: Integer;\n+    d_stream: z_stream; (* decompression stream *)\n+begin\n+  StrCopy(PChar(uncompr), 'garbage');\n+\n+  d_stream.zalloc := NIL;\n+  d_stream.zfree := NIL;\n+  d_stream.opaque := NIL;\n+\n+  d_stream.next_in := compr;\n+  d_stream.avail_in := Integer(comprLen);\n+\n+  err := inflateInit(d_stream);\n+  CHECK_ERR(err, 'inflateInit');\n+\n+  d_stream.next_out := uncompr;\n+  d_stream.avail_out := Integer(uncomprLen);\n+\n+  while TRUE do\n+  begin\n+    err := inflate(d_stream, Z_NO_FLUSH);\n+    if err = Z_STREAM_END then\n+      break;\n+    if err = Z_NEED_DICT then\n+    begin\n+      if d_stream.adler <> dictId then\n+        EXIT_ERR('unexpected dictionary');\n+      err := inflateSetDictionary(d_stream, dictionary, StrLen(dictionary));\n+    end;\n+    CHECK_ERR(err, 'inflate with dict');\n+  end;\n+\n+  err := inflateEnd(d_stream);\n+  CHECK_ERR(err, 'inflateEnd');\n+\n+  if StrComp(PChar(uncompr), hello) <> 0 then\n+    EXIT_ERR('bad inflate with dict')\n+  else\n+    WriteLn('inflate with dictionary: ', PChar(uncompr));\n+end;\n+{$ENDIF}\n+\n+var compr, uncompr: Pointer;\n+    comprLen, uncomprLen: LongInt;\n+\n+begin\n+  if zlibVersion^ <> ZLIB_VERSION[1] then\n+    EXIT_ERR('Incompatible zlib version');\n+\n+  WriteLn('zlib version: ', zlibVersion);\n+  WriteLn('zlib compile flags: ', Format('0x%x', [zlibCompileFlags]));\n+\n+  comprLen := 10000 * SizeOf(Integer); (* don't overflow on MSDOS *)\n+  uncomprLen := comprLen;\n+  GetMem(compr, comprLen);\n+  GetMem(uncompr, uncomprLen);\n+  if (compr = NIL) or (uncompr = NIL) then\n+    EXIT_ERR('Out of memory');\n+  (* compr and uncompr are cleared to avoid reading uninitialized\n+   * data and to ensure that uncompr compresses well.\n+   *)\n+  FillChar(compr^, comprLen, 0);\n+  FillChar(uncompr^, uncomprLen, 0);\n+\n+  {$IFDEF TEST_COMPRESS}\n+  WriteLn('** Testing compress');\n+  test_compress(compr, comprLen, uncompr, uncomprLen);\n+  {$ENDIF}\n+\n+  {$IFDEF TEST_GZIO}\n+  WriteLn('** Testing gzio');\n+  if ParamCount >= 1 then\n+    test_gzio(ParamStr(1), uncompr, uncomprLen)\n+  else\n+    test_gzio(TESTFILE, uncompr, uncomprLen);\n+  {$ENDIF}\n+\n+  {$IFDEF TEST_DEFLATE}\n+  WriteLn('** Testing deflate with small buffers');\n+  test_deflate(compr, comprLen);\n+  {$ENDIF}\n+  {$IFDEF TEST_INFLATE}\n+  WriteLn('** Testing inflate with small buffers');\n+  test_inflate(compr, comprLen, uncompr, uncomprLen);\n+  {$ENDIF}\n+\n+  {$IFDEF TEST_DEFLATE}\n+  WriteLn('** Testing deflate with large buffers');\n+  test_large_deflate(compr, comprLen, uncompr, uncomprLen);\n+  {$ENDIF}\n+  {$IFDEF TEST_INFLATE}\n+  WriteLn('** Testing inflate with large buffers');\n+  test_large_inflate(compr, comprLen, uncompr, uncomprLen);\n+  {$ENDIF}\n+\n+  {$IFDEF TEST_FLUSH}\n+  WriteLn('** Testing deflate with full flush');\n+  test_flush(compr, comprLen);\n+  {$ENDIF}\n+  {$IFDEF TEST_SYNC}\n+  WriteLn('** Testing inflateSync');\n+  test_sync(compr, comprLen, uncompr, uncomprLen);\n+  {$ENDIF}\n+  comprLen := uncomprLen;\n+\n+  {$IFDEF TEST_DICT}\n+  WriteLn('** Testing deflate and inflate with preset dictionary');\n+  test_dict_deflate(compr, comprLen);\n+  test_dict_inflate(compr, comprLen, uncompr, uncomprLen);\n+  {$ENDIF}\n+\n+  FreeMem(compr, comprLen);\n+  FreeMem(uncompr, uncomprLen);\n+end."}, {"sha": "60e87c8a331b5de9a998a9927c8eb31700d19a28", "filename": "zlib/contrib/pascal/readme.txt", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpascal%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpascal%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpascal%2Freadme.txt?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,76 @@\n+\n+This directory contains a Pascal (Delphi, Kylix) interface to the\n+zlib data compression library.\n+\n+\n+Directory listing\n+=================\n+\n+zlibd32.mak     makefile for Borland C++\n+example.pas     usage example of zlib\n+zlibpas.pas     the Pascal interface to zlib\n+readme.txt      this file\n+\n+\n+Compatibility notes\n+===================\n+\n+- Although the name \"zlib\" would have been more normal for the\n+  zlibpas unit, this name is already taken by Borland's ZLib unit.\n+  This is somehow unfortunate, because that unit is not a genuine\n+  interface to the full-fledged zlib functionality, but a suite of\n+  class wrappers around zlib streams.  Other essential features,\n+  such as checksums, are missing.\n+  It would have been more appropriate for that unit to have a name\n+  like \"ZStreams\", or something similar.\n+\n+- The C and zlib-supplied types int, uInt, long, uLong, etc. are\n+  translated directly into Pascal types of similar sizes (Integer,\n+  LongInt, etc.), to avoid namespace pollution.  In particular,\n+  there is no conversion of unsigned int into a Pascal unsigned\n+  integer.  The Word type is non-portable and has the same size\n+  (16 bits) both in a 16-bit and in a 32-bit environment, unlike\n+  Integer.  Even if there is a 32-bit Cardinal type, there is no\n+  real need for unsigned int in zlib under a 32-bit environment.\n+\n+- Except for the callbacks, the zlib function interfaces are\n+  assuming the calling convention normally used in Pascal\n+  (__pascal for DOS and Windows16, __fastcall for Windows32).\n+  Since the cdecl keyword is used, the old Turbo Pascal does\n+  not work with this interface.\n+\n+- The gz* function interfaces are not translated, to avoid\n+  interfacing problems with the C runtime library.  Besides,\n+    gzprintf(gzFile file, const char *format, ...)\n+  cannot be translated into Pascal.\n+\n+\n+Legal issues\n+============\n+\n+The zlibpas interface is:\n+  Copyright (C) 1995-2003 Jean-loup Gailly and Mark Adler.\n+  Copyright (C) 1998 by Bob Dellaca.\n+  Copyright (C) 2003 by Cosmin Truta.\n+\n+The example program is:\n+  Copyright (C) 1995-2003 by Jean-loup Gailly.\n+  Copyright (C) 1998,1999,2000 by Jacques Nomssi Nzali.\n+  Copyright (C) 2003 by Cosmin Truta.\n+\n+  This software is provided 'as-is', without any express or implied\n+  warranty.  In no event will the author be held liable for any damages\n+  arising from the use of this software.\n+\n+  Permission is granted to anyone to use this software for any purpose,\n+  including commercial applications, and to alter it and redistribute it\n+  freely, subject to the following restrictions:\n+\n+  1. The origin of this software must not be misrepresented; you must not\n+     claim that you wrote the original software. If you use this software\n+     in a product, an acknowledgment in the product documentation would be\n+     appreciated but is not required.\n+  2. Altered source versions must be plainly marked as such, and must not be\n+     misrepresented as being the original software.\n+  3. This notice may not be removed or altered from any source distribution.\n+"}, {"sha": "88fafa0b14d123fb81ef34d387031d622a38e1d2", "filename": "zlib/contrib/pascal/zlibd32.mak", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpascal%2Fzlibd32.mak", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpascal%2Fzlibd32.mak", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpascal%2Fzlibd32.mak?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,93 @@\n+# Makefile for zlib\n+# For use with Delphi and C++ Builder under Win32\n+# Updated for zlib 1.2.x by Cosmin Truta\n+\n+# ------------ Borland C++ ------------\n+\n+# This project uses the Delphi (fastcall/register) calling convention:\n+LOC = -DZEXPORT=__fastcall -DZEXPORTVA=__cdecl\n+\n+CC = bcc32\n+LD = bcc32\n+AR = tlib\n+# do not use \"-pr\" in CFLAGS\n+CFLAGS = -a -d -k- -O2 $(LOC)\n+LDFLAGS =\n+\n+\n+# variables\n+ZLIB_LIB = zlib.lib\n+\n+OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infback.obj\n+OBJ2 = inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj\n+OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzio.obj+infback.obj\n+OBJP2 = +inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj\n+\n+\n+# targets\n+all: $(ZLIB_LIB) example.exe minigzip.exe\n+\n+.c.obj:\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+adler32.obj: adler32.c zlib.h zconf.h\n+\n+compress.obj: compress.c zlib.h zconf.h\n+\n+crc32.obj: crc32.c zlib.h zconf.h crc32.h\n+\n+deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h\n+\n+gzio.obj: gzio.c zutil.h zlib.h zconf.h\n+\n+infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \\\n+ inffast.h inffixed.h\n+\n+inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \\\n+ inffast.h\n+\n+inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \\\n+ inffast.h inffixed.h\n+\n+inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h\n+\n+trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h\n+\n+uncompr.obj: uncompr.c zlib.h zconf.h\n+\n+zutil.obj: zutil.c zutil.h zlib.h zconf.h\n+\n+example.obj: example.c zlib.h zconf.h\n+\n+minigzip.obj: minigzip.c zlib.h zconf.h\n+\n+\n+# For the sake of the old Borland make,\n+# the command line is cut to fit in the MS-DOS 128 byte limit:\n+$(ZLIB_LIB): $(OBJ1) $(OBJ2)\n+\t-del $(ZLIB_LIB)\n+\t$(AR) $(ZLIB_LIB) $(OBJP1)\n+\t$(AR) $(ZLIB_LIB) $(OBJP2)\n+\n+\n+# testing\n+test: example.exe minigzip.exe\n+\texample\n+\techo hello world | minigzip | minigzip -d\n+\n+example.exe: example.obj $(ZLIB_LIB)\n+\t$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)\n+\n+minigzip.exe: minigzip.obj $(ZLIB_LIB)\n+\t$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)\n+\n+\n+# cleanup\n+clean:\n+\t-del *.obj\n+\t-del *.exe\n+\t-del *.lib\n+\t-del *.tds\n+\t-del zlib.bak\n+\t-del foo.gz\n+"}, {"sha": "6d5ebe0f30e9dc3fa9503c36c2c75b62b1f69fd1", "filename": "zlib/contrib/pascal/zlibpas.pas", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpascal%2Fzlibpas.pas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpascal%2Fzlibpas.pas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpascal%2Fzlibpas.pas?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,236 @@\n+(* zlibpas -- Pascal interface to the zlib data compression library\n+ *\n+ * Copyright (C) 2003 Cosmin Truta.\n+ * Derived from original sources by Bob Dellaca.\n+ * For conditions of distribution and use, see copyright notice in readme.txt\n+ *)\n+\n+unit zlibpas;\n+\n+interface\n+\n+const\n+  ZLIB_VERSION = '1.2.1';\n+\n+type\n+  alloc_func = function(opaque: Pointer; items, size: Integer): Pointer;\n+                 cdecl;\n+  free_func  = procedure(opaque, address: Pointer);\n+                 cdecl;\n+\n+  in_func    = function(opaque: Pointer; var buf: PByte): Integer;\n+                 cdecl;\n+  out_func   = function(opaque: Pointer; buf: PByte; size: Integer): Integer;\n+                 cdecl;\n+\n+  z_streamp = ^z_stream;\n+  z_stream = packed record\n+    next_in: PChar;       (* next input byte *)\n+    avail_in: Integer;    (* number of bytes available at next_in *)\n+    total_in: LongInt;    (* total nb of input bytes read so far *)\n+\n+    next_out: PChar;      (* next output byte should be put there *)\n+    avail_out: Integer;   (* remaining free space at next_out *)\n+    total_out: LongInt;   (* total nb of bytes output so far *)\n+\n+    msg: PChar;           (* last error message, NULL if no error *)\n+    state: Pointer;       (* not visible by applications *)\n+\n+    zalloc: alloc_func;   (* used to allocate the internal state *)\n+    zfree: free_func;     (* used to free the internal state *)\n+    opaque: Pointer;      (* private data object passed to zalloc and zfree *)\n+\n+    data_type: Integer;   (* best guess about the data type: ascii or binary *)\n+    adler: LongInt;       (* adler32 value of the uncompressed data *)\n+    reserved: LongInt;    (* reserved for future use *)\n+  end;\n+\n+(* constants *)\n+const\n+  Z_NO_FLUSH      = 0;\n+  Z_PARTIAL_FLUSH = 1;\n+  Z_SYNC_FLUSH    = 2;\n+  Z_FULL_FLUSH    = 3;\n+  Z_FINISH        = 4;\n+\n+  Z_OK            =  0;\n+  Z_STREAM_END    =  1;\n+  Z_NEED_DICT     =  2;\n+  Z_ERRNO         = -1;\n+  Z_STREAM_ERROR  = -2;\n+  Z_DATA_ERROR    = -3;\n+  Z_MEM_ERROR     = -4;\n+  Z_BUF_ERROR     = -5;\n+  Z_VERSION_ERROR = -6;\n+\n+  Z_NO_COMPRESSION       =  0;\n+  Z_BEST_SPEED           =  1;\n+  Z_BEST_COMPRESSION     =  9;\n+  Z_DEFAULT_COMPRESSION  = -1;\n+\n+  Z_FILTERED            = 1;\n+  Z_HUFFMAN_ONLY        = 2;\n+  Z_RLE                 = 3;\n+  Z_DEFAULT_STRATEGY    = 0;\n+\n+  Z_BINARY   = 0;\n+  Z_ASCII    = 1;\n+  Z_UNKNOWN  = 2;\n+\n+  Z_DEFLATED = 8;\n+\n+(* basic functions *)\n+function zlibVersion: PChar;\n+function deflateInit(var strm: z_stream; level: Integer): Integer;\n+function deflate(var strm: z_stream; flush: Integer): Integer;\n+function deflateEnd(var strm: z_stream): Integer;\n+function inflateInit(var strm: z_stream): Integer;\n+function inflate(var strm: z_stream; flush: Integer): Integer;\n+function inflateEnd(var strm: z_stream): Integer;\n+\n+(* advanced functions *)\n+function deflateInit2(var strm: z_stream; level, method, windowBits,\n+                      memLevel, strategy: Integer): Integer;\n+function deflateSetDictionary(var strm: z_stream; const dictionary: PChar;\n+                              dictLength: Integer): Integer;\n+function deflateCopy(var dest, source: z_stream): Integer;\n+function deflateReset(var strm: z_stream): Integer;\n+function deflateParams(var strm: z_stream; level, strategy: Integer): Integer;\n+function deflateBound(var strm: z_stream; sourceLen: LongInt): LongInt;\n+function deflatePrime(var strm: z_stream; bits, value: Integer): Integer;\n+function inflateInit2(var strm: z_stream; windowBits: Integer): Integer;\n+function inflateSetDictionary(var strm: z_stream; const dictionary: PChar;\n+                              dictLength: Integer): Integer;\n+function inflateSync(var strm: z_stream): Integer;\n+function inflateCopy(var dest, source: z_stream): Integer;\n+function inflateReset(var strm: z_stream): Integer;\n+function inflateBackInit(var strm: z_stream;\n+                         windowBits: Integer; window: PChar): Integer;\n+function inflateBack(var strm: z_stream; in_fn: in_func; in_desc: Pointer;\n+                     out_fn: out_func; out_desc: Pointer): Integer;\n+function inflateBackEnd(var strm: z_stream): Integer;\n+function zlibCompileFlags: LongInt;\n+\n+(* utility functions *)\n+function compress(dest: PChar; var destLen: LongInt;\n+                  const source: PChar; sourceLen: LongInt): Integer;\n+function compress2(dest: PChar; var destLen: LongInt;\n+                  const source: PChar; sourceLen: LongInt;\n+                  level: Integer): Integer;\n+function compressBound(sourceLen: LongInt): LongInt;\n+function uncompress(dest: PChar; var destLen: LongInt;\n+                    const source: PChar; sourceLen: LongInt): Integer;\n+\n+(* checksum functions *)\n+function adler32(adler: LongInt; const buf: PChar; len: Integer): LongInt;\n+function crc32(crc: LongInt; const buf: PChar; len: Integer): LongInt;\n+\n+(* various hacks, don't look :) *)\n+function deflateInit_(var strm: z_stream; level: Integer;\n+                      const version: PChar; stream_size: Integer): Integer;\n+function inflateInit_(var strm: z_stream; const version: PChar;\n+                      stream_size: Integer): Integer;\n+function deflateInit2_(var strm: z_stream;\n+                       level, method, windowBits, memLevel, strategy: Integer;\n+                       const version: PChar; stream_size: Integer): Integer;\n+function inflateInit2_(var strm: z_stream; windowBits: Integer;\n+                       const version: PChar; stream_size: Integer): Integer;\n+function inflateBackInit_(var strm: z_stream;\n+                          windowBits: Integer; window: PChar;\n+                          const version: PChar; stream_size: Integer): Integer;\n+\n+\n+implementation\n+\n+{$L adler32.obj}\n+{$L compress.obj}\n+{$L crc32.obj}\n+{$L deflate.obj}\n+{$L infback.obj}\n+{$L inffast.obj}\n+{$L inflate.obj}\n+{$L inftrees.obj}\n+{$L trees.obj}\n+{$L uncompr.obj}\n+{$L zutil.obj}\n+\n+function adler32; external;\n+function compress; external;\n+function compress2; external;\n+function compressBound; external;\n+function crc32; external;\n+function deflate; external;\n+function deflateBound; external;\n+function deflateCopy; external;\n+function deflateEnd; external;\n+function deflateInit_; external;\n+function deflateInit2_; external;\n+function deflateParams; external;\n+function deflatePrime; external;\n+function deflateReset; external;\n+function deflateSetDictionary; external;\n+function inflate; external;\n+function inflateBack; external;\n+function inflateBackEnd; external;\n+function inflateBackInit_; external;\n+function inflateCopy; external;\n+function inflateEnd; external;\n+function inflateInit_; external;\n+function inflateInit2_; external;\n+function inflateReset; external;\n+function inflateSetDictionary; external;\n+function inflateSync; external;\n+function uncompress; external;\n+function zlibCompileFlags; external;\n+function zlibVersion; external;\n+\n+function deflateInit(var strm: z_stream; level: Integer): Integer;\n+begin\n+  Result := deflateInit_(strm, level, ZLIB_VERSION, sizeof(z_stream));\n+end;\n+\n+function deflateInit2(var strm: z_stream; level, method, windowBits, memLevel,\n+                      strategy: Integer): Integer;\n+begin\n+  Result := deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n+                          ZLIB_VERSION, sizeof(z_stream));\n+end;\n+\n+function inflateInit(var strm: z_stream): Integer;\n+begin\n+  Result := inflateInit_(strm, ZLIB_VERSION, sizeof(z_stream));\n+end;\n+\n+function inflateInit2(var strm: z_stream; windowBits: Integer): Integer;\n+begin\n+  Result := inflateInit2_(strm, windowBits, ZLIB_VERSION, sizeof(z_stream));\n+end;\n+\n+function inflateBackInit(var strm: z_stream;\n+                         windowBits: Integer; window: PChar): Integer;\n+begin\n+  Result := inflateBackInit_(strm, windowBits, window,\n+                             ZLIB_VERSION, sizeof(z_stream));\n+end;\n+\n+function _malloc(Size: Integer): Pointer; cdecl;\n+begin\n+  GetMem(Result, Size);\n+end;\n+\n+procedure _free(Block: Pointer); cdecl;\n+begin\n+  FreeMem(Block);\n+end;\n+\n+procedure _memset(P: Pointer; B: Byte; count: Integer); cdecl;\n+begin\n+  FillChar(P^, count, B);\n+end;\n+\n+procedure _memcpy(dest, source: Pointer; count: Integer); cdecl;\n+begin\n+  Move(source^, dest^, count);\n+end;\n+\n+end."}, {"sha": "b6b69404c7453bd3707f1c258ac238fe93dac867", "filename": "zlib/contrib/puff/Makefile", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpuff%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpuff%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpuff%2FMakefile?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,8 @@\n+puff: puff.c puff.h\n+\tcc -DTEST -o puff puff.c\n+\n+test: puff\n+\tpuff zeros.raw\n+\n+clean:\n+\trm -f puff puff.o"}, {"sha": "bbc4cb595ec1a62283f097abf984732084c3f348", "filename": "zlib/contrib/puff/README", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpuff%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpuff%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpuff%2FREADME?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,63 @@\n+Puff -- A Simple Inflate\n+3 Mar 2003\n+Mark Adler\n+madler@alumni.caltech.edu\n+\n+What this is --\n+\n+puff.c provides the routine puff() to decompress the deflate data format.  It\n+does so more slowly than zlib, but the code is about one-fifth the size of the\n+inflate code in zlib, and written to be very easy to read.\n+\n+Why I wrote this --\n+\n+puff.c was written to document the deflate format unambiguously, by virtue of\n+being working C code.  It is meant to supplement RFC 1951, which formally\n+describes the deflate format.  I have received many questions on details of the\n+deflate format, and I hope that reading this code will answer those questions.\n+puff.c is heavily commented with details of the deflate format, especially\n+those little nooks and cranies of the format that might not be obvious from a\n+specification.\n+\n+puff.c may also be useful in applications where code size or memory usage is a\n+very limited resource, and speed is not as important.\n+\n+How to use it --\n+\n+Well, most likely you should just be reading puff.c and using zlib for actual\n+applications, but if you must ...\n+\n+Include puff.h in your code, which provides this prototype:\n+\n+int puff(unsigned char *dest,           /* pointer to destination pointer */\n+         unsigned long *destlen,        /* amount of output space */\n+         unsigned char *source,         /* pointer to source data pointer */\n+         unsigned long *sourcelen);     /* amount of input available */\n+\n+Then you can call puff() to decompress a deflate stream that is in memory in\n+its entirety at source, to a sufficiently sized block of memory for the\n+decompressed data at dest.  puff() is the only external symbol in puff.c  The\n+only C library functions that puff.c needs are setjmp() and longjmp(), which\n+are used to simplify error checking in the code to improve readabilty.  puff.c\n+does no memory allocation, and uses less than 2K bytes off of the stack.\n+\n+If destlen is not enough space for the uncompressed data, then inflate will\n+return an error without writing more than destlen bytes.  Note that this means\n+that in order to decompress the deflate data successfully, you need to know\n+the size of the uncompressed data ahead of time.\n+\n+If needed, puff() can determine the size of the uncompressed data with no\n+output space.  This is done by passing dest equal to (unsigned char *)0.  Then\n+the initial value of *destlen is ignored and *destlen is set to the length of\n+the uncompressed data.  So if the size of the uncompressed data is not known,\n+then two passes of puff() can be used--first to determine the size, and second\n+to do the actual inflation after allocating the appropriate memory.  Not\n+pretty, but it works.  (This is one of the reasons you should be using zlib.)\n+\n+The deflate format is self-terminating.  If the deflate stream does not end\n+in *sourcelen bytes, puff() will return an error without reading at or past\n+endsource.\n+\n+On return, *sourcelen is updated to the amount of input data consumed, and\n+*destlen is updated to the size of the uncompressed data.  See the comments\n+in puff.c for the possible return codes for puff()."}, {"sha": "7a8116b44806c581e72d2239257c5cf0f496c4ef", "filename": "zlib/contrib/puff/puff.c", "status": "added", "additions": 833, "deletions": 0, "changes": 833, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpuff%2Fpuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpuff%2Fpuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpuff%2Fpuff.c?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,833 @@\n+/*\n+ * puff.c\n+ * Copyright (C) 2002, 2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in puff.h\n+ * version 1.7, 3 Mar 2003\n+ *\n+ * puff.c is a simple inflate written to be an unambiguous way to specify the\n+ * deflate format.  It is not written for speed but rather simplicity.  As a\n+ * side benefit, this code might actually be useful when small code is more\n+ * important than speed, such as bootstrap applications.  For typical deflate\n+ * data, zlib's inflate() is about four times as fast as puff().  zlib's\n+ * inflate compiles to around 20K on my machine, whereas puff.c compiles to\n+ * around 4K on my machine (a PowerPC using GNU cc).  If the faster decode()\n+ * function here is used, then puff() is only twice as slow as zlib's\n+ * inflate().\n+ *\n+ * All dynamically allocated memory comes from the stack.  The stack required\n+ * is less than 2K bytes.  This code is compatible with 16-bit int's and\n+ * assumes that long's are at least 32 bits.  puff.c uses the short data type,\n+ * assumed to be 16 bits, for arrays in order to to conserve memory.  The code\n+ * works whether integers are stored big endian or little endian.\n+ *\n+ * In the comments below are \"Format notes\" that describe the inflate process\n+ * and document some of the less obvious aspects of the format.  This source\n+ * code is meant to supplement RFC 1951, which formally describes the deflate\n+ * format:\n+ *\n+ *    http://www.zlib.org/rfc-deflate.html\n+ */\n+\n+/*\n+ * Change history:\n+ *\n+ * 1.0  10 Feb 2002     - First version\n+ * 1.1  17 Feb 2002     - Clarifications of some comments and notes\n+ *                      - Update puff() dest and source pointers on negative\n+ *                        errors to facilitate debugging deflators\n+ *                      - Remove longest from struct huffman -- not needed\n+ *                      - Simplify offs[] index in construct()\n+ *                      - Add input size and checking, using longjmp() to\n+ *                        maintain easy readability\n+ *                      - Use short data type for large arrays\n+ *                      - Use pointers instead of long to specify source and\n+ *                        destination sizes to avoid arbitrary 4 GB limits\n+ * 1.2  17 Mar 2002     - Add faster version of decode(), doubles speed (!),\n+ *                        but leave simple version for readabilty\n+ *                      - Make sure invalid distances detected if pointers\n+ *                        are 16 bits\n+ *                      - Fix fixed codes table error\n+ *                      - Provide a scanning mode for determining size of\n+ *                        uncompressed data\n+ * 1.3  20 Mar 2002     - Go back to lengths for puff() parameters [Jean-loup]\n+ *                      - Add a puff.h file for the interface\n+ *                      - Add braces in puff() for else do [Jean-loup]\n+ *                      - Use indexes instead of pointers for readability\n+ * 1.4  31 Mar 2002     - Simplify construct() code set check\n+ *                      - Fix some comments\n+ *                      - Add FIXLCODES #define\n+ * 1.5   6 Apr 2002     - Minor comment fixes\n+ * 1.6   7 Aug 2002     - Minor format changes\n+ * 1.7   3 Mar 2003     - Added test code for distribution\n+ *                      - Added zlib-like license\n+ */\n+\n+#include <setjmp.h>             /* for setjmp(), longjmp(), and jmp_buf */\n+#include \"puff.h\"               /* prototype for puff() */\n+\n+#define local static            /* for local function definitions */\n+#define NIL ((unsigned char *)0)        /* for no output option */\n+\n+/*\n+ * Maximums for allocations and loops.  It is not useful to change these --\n+ * they are fixed by the deflate format.\n+ */\n+#define MAXBITS 15              /* maximum bits in a code */\n+#define MAXLCODES 286           /* maximum number of literal/length codes */\n+#define MAXDCODES 30            /* maximum number of distance codes */\n+#define MAXCODES (MAXLCODES+MAXDCODES)  /* maximum codes lengths to read */\n+#define FIXLCODES 288           /* number of fixed literal/length codes */\n+\n+/* input and output state */\n+struct state {\n+    /* output state */\n+    unsigned char *out;         /* output buffer */\n+    unsigned long outlen;       /* available space at out */\n+    unsigned long outcnt;       /* bytes written to out so far */\n+\n+    /* input state */\n+    unsigned char *in;          /* input buffer */\n+    unsigned long inlen;        /* available input at in */\n+    unsigned long incnt;        /* bytes read so far */\n+    int bitbuf;                 /* bit buffer */\n+    int bitcnt;                 /* number of bits in bit buffer */\n+\n+    /* input limit error return state for bits() and decode() */\n+    jmp_buf env;\n+};\n+\n+/*\n+ * Return need bits from the input stream.  This always leaves less than\n+ * eight bits in the buffer.  bits() works properly for need == 0.\n+ *\n+ * Format notes:\n+ *\n+ * - Bits are stored in bytes from the least significant bit to the most\n+ *   significant bit.  Therefore bits are dropped from the bottom of the bit\n+ *   buffer, using shift right, and new bytes are appended to the top of the\n+ *   bit buffer, using shift left.\n+ */\n+local int bits(struct state *s, int need)\n+{\n+    long val;           /* bit accumulator (can use up to 20 bits) */\n+\n+    /* load at least need bits into val */\n+    val = s->bitbuf;\n+    while (s->bitcnt < need) {\n+        if (s->incnt == s->inlen) longjmp(s->env, 1);   /* out of input */\n+        val |= (long)(s->in[s->incnt++]) << s->bitcnt;  /* load eight bits */\n+        s->bitcnt += 8;\n+    }\n+\n+    /* drop need bits and update buffer, always zero to seven bits left */\n+    s->bitbuf = (int)(val >> need);\n+    s->bitcnt -= need;\n+\n+    /* return need bits, zeroing the bits above that */\n+    return (int)(val & ((1L << need) - 1));\n+}\n+\n+/*\n+ * Process a stored block.\n+ *\n+ * Format notes:\n+ *\n+ * - After the two-bit stored block type (00), the stored block length and\n+ *   stored bytes are byte-aligned for fast copying.  Therefore any leftover\n+ *   bits in the byte that has the last bit of the type, as many as seven, are\n+ *   discarded.  The value of the discarded bits are not defined and should not\n+ *   be checked against any expectation.\n+ *\n+ * - The second inverted copy of the stored block length does not have to be\n+ *   checked, but it's probably a good idea to do so anyway.\n+ *\n+ * - A stored block can have zero length.  This is sometimes used to byte-align\n+ *   subsets of the compressed data for random access or partial recovery.\n+ */\n+local int stored(struct state *s)\n+{\n+    unsigned len;       /* length of stored block */\n+\n+    /* discard leftover bits from current byte (assumes s->bitcnt < 8) */\n+    s->bitbuf = 0;\n+    s->bitcnt = 0;\n+\n+    /* get length and check against its one's complement */\n+    if (s->incnt + 4 > s->inlen) return 2;      /* not enough input */\n+    len = s->in[s->incnt++];\n+    len |= s->in[s->incnt++] << 8;\n+    if (s->in[s->incnt++] != (~len & 0xff) ||\n+        s->in[s->incnt++] != ((~len >> 8) & 0xff))\n+        return -2;                              /* didn't match complement! */\n+\n+    /* copy len bytes from in to out */\n+    if (s->incnt + len > s->inlen) return 2;    /* not enough input */\n+    if (s->out != NIL) {\n+        if (s->outcnt + len > s->outlen)\n+            return 1;                           /* not enough output space */\n+        while (len--)\n+            s->out[s->outcnt++] = s->in[s->incnt++];\n+    }\n+    else {                                      /* just scanning */\n+        s->outcnt += len;\n+        s->incnt += len;\n+    }\n+\n+    /* done with a valid stored block */\n+    return 0;\n+}\n+\n+/*\n+ * Huffman code decoding tables.  count[1..MAXBITS] is the number of symbols of\n+ * each length, which for a canonical code are stepped through in order.\n+ * symbol[] are the symbol values in canonical order, where the number of\n+ * entries is the sum of the counts in count[].  The decoding process can be\n+ * seen in the function decode() below.\n+ */\n+struct huffman {\n+    short *count;       /* number of symbols of each length */\n+    short *symbol;      /* canonically ordered symbols */\n+};\n+\n+/*\n+ * Decode a code from the stream s using huffman table h.  Return the symbol or\n+ * a negative value if there is an error.  If all of the lengths are zero, i.e.\n+ * an empty code, or if the code is incomplete and an invalid code is received,\n+ * then -9 is returned after reading MAXBITS bits.\n+ *\n+ * Format notes:\n+ *\n+ * - The codes as stored in the compressed data are bit-reversed relative to\n+ *   a simple integer ordering of codes of the same lengths.  Hence below the\n+ *   bits are pulled from the compressed data one at a time and used to\n+ *   build the code value reversed from what is in the stream in order to\n+ *   permit simple integer comparisons for decoding.  A table-based decoding\n+ *   scheme (as used in zlib) does not need to do this reversal.\n+ *\n+ * - The first code for the shortest length is all zeros.  Subsequent codes of\n+ *   the same length are simply integer increments of the previous code.  When\n+ *   moving up a length, a zero bit is appended to the code.  For a complete\n+ *   code, the last code of the longest length will be all ones.\n+ *\n+ * - Incomplete codes are handled by this decoder, since they are permitted\n+ *   in the deflate format.  See the format notes for fixed() and dynamic().\n+ */\n+#ifdef SLOW\n+local int decode(struct state *s, struct huffman *h)\n+{\n+    int len;            /* current number of bits in code */\n+    int code;           /* len bits being decoded */\n+    int first;          /* first code of length len */\n+    int count;          /* number of codes of length len */\n+    int index;          /* index of first code of length len in symbol table */\n+\n+    code = first = index = 0;\n+    for (len = 1; len <= MAXBITS; len++) {\n+        code |= bits(s, 1);             /* get next bit */\n+        count = h->count[len];\n+        if (code < first + count)       /* if length len, return symbol */\n+            return h->symbol[index + (code - first)];\n+        index += count;                 /* else update for next length */\n+        first += count;\n+        first <<= 1;\n+        code <<= 1;\n+    }\n+    return -9;                          /* ran out of codes */\n+}\n+\n+/*\n+ * A faster version of decode() for real applications of this code.   It's not\n+ * as readable, but it makes puff() twice as fast.  And it only makes the code\n+ * a few percent larger.\n+ */\n+#else /* !SLOW */\n+local int decode(struct state *s, struct huffman *h)\n+{\n+    int len;            /* current number of bits in code */\n+    int code;           /* len bits being decoded */\n+    int first;          /* first code of length len */\n+    int count;          /* number of codes of length len */\n+    int index;          /* index of first code of length len in symbol table */\n+    int bitbuf;         /* bits from stream */\n+    int left;           /* bits left in next or left to process */\n+    short *next;        /* next number of codes */\n+\n+    bitbuf = s->bitbuf;\n+    left = s->bitcnt;\n+    code = first = index = 0;\n+    len = 1;\n+    next = h->count + 1;\n+    while (1) {\n+        while (left--) {\n+            code |= bitbuf & 1;\n+            bitbuf >>= 1;\n+            count = *next++;\n+            if (code < first + count) { /* if length len, return symbol */\n+                s->bitbuf = bitbuf;\n+                s->bitcnt = (s->bitcnt - len) & 7;\n+                return h->symbol[index + (code - first)];\n+            }\n+            index += count;             /* else update for next length */\n+            first += count;\n+            first <<= 1;\n+            code <<= 1;\n+            len++;\n+        }\n+        left = (MAXBITS+1) - len;\n+        if (left == 0) break;\n+        if (s->incnt == s->inlen) longjmp(s->env, 1);   /* out of input */\n+        bitbuf = s->in[s->incnt++];\n+        if (left > 8) left = 8;\n+    }\n+    return -9;                          /* ran out of codes */\n+}\n+#endif /* SLOW */\n+\n+/*\n+ * Given the list of code lengths length[0..n-1] representing a canonical\n+ * Huffman code for n symbols, construct the tables required to decode those\n+ * codes.  Those tables are the number of codes of each length, and the symbols\n+ * sorted by length, retaining their original order within each length.  The\n+ * return value is zero for a complete code set, negative for an over-\n+ * subscribed code set, and positive for an incomplete code set.  The tables\n+ * can be used if the return value is zero or positive, but they cannot be used\n+ * if the return value is negative.  If the return value is zero, it is not\n+ * possible for decode() using that table to return an error--any stream of\n+ * enough bits will resolve to a symbol.  If the return value is positive, then\n+ * it is possible for decode() using that table to return an error for received\n+ * codes past the end of the incomplete lengths.\n+ *\n+ * Not used by decode(), but used for error checking, h->count[0] is the number\n+ * of the n symbols not in the code.  So n - h->count[0] is the number of\n+ * codes.  This is useful for checking for incomplete codes that have more than\n+ * one symbol, which is an error in a dynamic block.\n+ *\n+ * Assumption: for all i in 0..n-1, 0 <= length[i] <= MAXBITS\n+ * This is assured by the construction of the length arrays in dynamic() and\n+ * fixed() and is not verified by construct().\n+ *\n+ * Format notes:\n+ *\n+ * - Permitted and expected examples of incomplete codes are one of the fixed\n+ *   codes and any code with a single symbol which in deflate is coded as one\n+ *   bit instead of zero bits.  See the format notes for fixed() and dynamic().\n+ *\n+ * - Within a given code length, the symbols are kept in ascending order for\n+ *   the code bits definition.\n+ */\n+local int construct(struct huffman *h, short *length, int n)\n+{\n+    int symbol;         /* current symbol when stepping through length[] */\n+    int len;            /* current length when stepping through h->count[] */\n+    int left;           /* number of possible codes left of current length */\n+    short offs[MAXBITS+1];      /* offsets in symbol table for each length */\n+\n+    /* count number of codes of each length */\n+    for (len = 0; len <= MAXBITS; len++)\n+        h->count[len] = 0;\n+    for (symbol = 0; symbol < n; symbol++)\n+        (h->count[length[symbol]])++;   /* assumes lengths are within bounds */\n+    if (h->count[0] == n)               /* no codes! */\n+        return 0;                       /* complete, but decode() will fail */\n+\n+    /* check for an over-subscribed or incomplete set of lengths */\n+    left = 1;                           /* one possible code of zero length */\n+    for (len = 1; len <= MAXBITS; len++) {\n+        left <<= 1;                     /* one more bit, double codes left */\n+        left -= h->count[len];          /* deduct count from possible codes */\n+        if (left < 0) return left;      /* over-subscribed--return negative */\n+    }                                   /* left > 0 means incomplete */\n+\n+    /* generate offsets into symbol table for each length for sorting */\n+    offs[1] = 0;\n+    for (len = 1; len < MAXBITS; len++)\n+        offs[len + 1] = offs[len] + h->count[len];\n+\n+    /*\n+     * put symbols in table sorted by length, by symbol order within each\n+     * length\n+     */\n+    for (symbol = 0; symbol < n; symbol++)\n+        if (length[symbol] != 0)\n+            h->symbol[offs[length[symbol]]++] = symbol;\n+\n+    /* return zero for complete set, positive for incomplete set */\n+    return left;\n+}\n+\n+/*\n+ * Decode literal/length and distance codes until an end-of-block code.\n+ *\n+ * Format notes:\n+ *\n+ * - Compressed data that is after the block type if fixed or after the code\n+ *   description if dynamic is a combination of literals and length/distance\n+ *   pairs terminated by and end-of-block code.  Literals are simply Huffman\n+ *   coded bytes.  A length/distance pair is a coded length followed by a\n+ *   coded distance to represent a string that occurs earlier in the\n+ *   uncompressed data that occurs again at the current location.\n+ *\n+ * - Literals, lengths, and the end-of-block code are combined into a single\n+ *   code of up to 286 symbols.  They are 256 literals (0..255), 29 length\n+ *   symbols (257..285), and the end-of-block symbol (256).\n+ *\n+ * - There are 256 possible lengths (3..258), and so 29 symbols are not enough\n+ *   to represent all of those.  Lengths 3..10 and 258 are in fact represented\n+ *   by just a length symbol.  Lengths 11..257 are represented as a symbol and\n+ *   some number of extra bits that are added as an integer to the base length\n+ *   of the length symbol.  The number of extra bits is determined by the base\n+ *   length symbol.  These are in the static arrays below, lens[] for the base\n+ *   lengths and lext[] for the corresponding number of extra bits.\n+ *\n+ * - The reason that 258 gets its own symbol is that the longest length is used\n+ *   often in highly redundant files.  Note that 258 can also be coded as the\n+ *   base value 227 plus the maximum extra value of 31.  While a good deflate\n+ *   should never do this, it is not an error, and should be decoded properly.\n+ *\n+ * - If a length is decoded, including its extra bits if any, then it is\n+ *   followed a distance code.  There are up to 30 distance symbols.  Again\n+ *   there are many more possible distances (1..32768), so extra bits are added\n+ *   to a base value represented by the symbol.  The distances 1..4 get their\n+ *   own symbol, but the rest require extra bits.  The base distances and\n+ *   corresponding number of extra bits are below in the static arrays dist[]\n+ *   and dext[].\n+ *\n+ * - Literal bytes are simply written to the output.  A length/distance pair is\n+ *   an instruction to copy previously uncompressed bytes to the output.  The\n+ *   copy is from distance bytes back in the output stream, copying for length\n+ *   bytes.\n+ *\n+ * - Distances pointing before the beginning of the output data are not\n+ *   permitted.\n+ *\n+ * - Overlapped copies, where the length is greater than the distance, are\n+ *   allowed and common.  For example, a distance of one and a length of 258\n+ *   simply copies the last byte 258 times.  A distance of four and a length of\n+ *   twelve copies the last four bytes three times.  A simple forward copy\n+ *   ignoring whether the length is greater than the distance or not implements\n+ *   this correctly.  You should not use memcpy() since its behavior is not\n+ *   defined for overlapped arrays.  You should not use memmove() or bcopy()\n+ *   since though their behavior -is- defined for overlapping arrays, it is\n+ *   defined to do the wrong thing in this case.\n+ */\n+local int codes(struct state *s,\n+                struct huffman *lencode,\n+                struct huffman *distcode)\n+{\n+    int symbol;         /* decoded symbol */\n+    int len;            /* length for copy */\n+    unsigned dist;      /* distance for copy */\n+    static const short lens[29] = { /* Size base for length codes 257..285 */\n+        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n+        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};\n+    static const short lext[29] = { /* Extra bits for length codes 257..285 */\n+        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n+        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n+    static const short dists[30] = { /* Offset base for distance codes 0..29 */\n+        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n+        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n+        8193, 12289, 16385, 24577};\n+    static const short dext[30] = { /* Extra bits for distance codes 0..29 */\n+        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n+        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n+        12, 12, 13, 13};\n+\n+    /* decode literals and length/distance pairs */\n+    do {\n+        symbol = decode(s, lencode);\n+        if (symbol < 0) return symbol;  /* invalid symbol */\n+        if (symbol < 256) {             /* literal: symbol is the byte */\n+            /* write out the literal */\n+            if (s->out != NIL) {\n+                if (s->outcnt == s->outlen) return 1;\n+                s->out[s->outcnt] = symbol;\n+            }\n+            s->outcnt++;\n+        }\n+        else if (symbol > 256) {        /* length */\n+            /* get and compute length */\n+            symbol -= 257;\n+            if (symbol >= 29) return -9;        /* invalid fixed code */\n+            len = lens[symbol] + bits(s, lext[symbol]);\n+\n+            /* get and check distance */\n+            symbol = decode(s, distcode);\n+            if (symbol < 0) return symbol;      /* invalid symbol */\n+            dist = dists[symbol] + bits(s, dext[symbol]);\n+            if (dist > s->outcnt)\n+                return -10;     /* distance too far back */\n+\n+            /* copy length bytes from distance bytes back */\n+            if (s->out != NIL) {\n+                if (s->outcnt + len > s->outlen) return 1;\n+                while (len--) {\n+                    s->out[s->outcnt] = s->out[s->outcnt - dist];\n+                    s->outcnt++;\n+                }\n+            }\n+            else\n+                s->outcnt += len;\n+        }\n+    } while (symbol != 256);            /* end of block symbol */\n+\n+    /* done with a valid fixed or dynamic block */\n+    return 0;\n+}\n+\n+/*\n+ * Process a fixed codes block.\n+ *\n+ * Format notes:\n+ *\n+ * - This block type can be useful for compressing small amounts of data for\n+ *   which the size of the code descriptions in a dynamic block exceeds the\n+ *   benefit of custom codes for that block.  For fixed codes, no bits are\n+ *   spent on code descriptions.  Instead the code lengths for literal/length\n+ *   codes and distance codes are fixed.  The specific lengths for each symbol\n+ *   can be seen in the \"for\" loops below.\n+ *\n+ * - The literal/length code is complete, but has two symbols that are invalid\n+ *   and should result in an error if received.  This cannot be implemented\n+ *   simply as an incomplete code since those two symbols are in the \"middle\"\n+ *   of the code.  They are eight bits long and the longest literal/length\\\n+ *   code is nine bits.  Therefore the code must be constructed with those\n+ *   symbols, and the invalid symbols must be detected after decoding.\n+ *\n+ * - The fixed distance codes also have two invalid symbols that should result\n+ *   in an error if received.  Since all of the distance codes are the same\n+ *   length, this can be implemented as an incomplete code.  Then the invalid\n+ *   codes are detected while decoding.\n+ */\n+local int fixed(struct state *s)\n+{\n+    static int virgin = 1;\n+    static short lencnt[MAXBITS+1], lensym[FIXLCODES];\n+    static short distcnt[MAXBITS+1], distsym[MAXDCODES];\n+    static struct huffman lencode = {lencnt, lensym};\n+    static struct huffman distcode = {distcnt, distsym};\n+\n+    /* build fixed huffman tables if first call (may not be thread safe) */\n+    if (virgin) {\n+        int symbol;\n+        short lengths[FIXLCODES];\n+\n+        /* literal/length table */\n+        for (symbol = 0; symbol < 144; symbol++)\n+            lengths[symbol] = 8;\n+        for (; symbol < 256; symbol++)\n+            lengths[symbol] = 9;\n+        for (; symbol < 280; symbol++)\n+            lengths[symbol] = 7;\n+        for (; symbol < FIXLCODES; symbol++)\n+            lengths[symbol] = 8;\n+        construct(&lencode, lengths, FIXLCODES);\n+\n+        /* distance table */\n+        for (symbol = 0; symbol < MAXDCODES; symbol++)\n+            lengths[symbol] = 5;\n+        construct(&distcode, lengths, MAXDCODES);\n+\n+        /* do this just once */\n+        virgin = 0;\n+    }\n+\n+    /* decode data until end-of-block code */\n+    return codes(s, &lencode, &distcode);\n+}\n+\n+/*\n+ * Process a dynamic codes block.\n+ *\n+ * Format notes:\n+ *\n+ * - A dynamic block starts with a description of the literal/length and\n+ *   distance codes for that block.  New dynamic blocks allow the compressor to\n+ *   rapidly adapt to changing data with new codes optimized for that data.\n+ *\n+ * - The codes used by the deflate format are \"canonical\", which means that\n+ *   the actual bits of the codes are generated in an unambiguous way simply\n+ *   from the number of bits in each code.  Therefore the code descriptions\n+ *   are simply a list of code lengths for each symbol.\n+ *\n+ * - The code lengths are stored in order for the symbols, so lengths are\n+ *   provided for each of the literal/length symbols, and for each of the\n+ *   distance symbols.\n+ *\n+ * - If a symbol is not used in the block, this is represented by a zero as\n+ *   as the code length.  This does not mean a zero-length code, but rather\n+ *   that no code should be created for this symbol.  There is no way in the\n+ *   deflate format to represent a zero-length code.\n+ *\n+ * - The maximum number of bits in a code is 15, so the possible lengths for\n+ *   any code are 1..15.\n+ *\n+ * - The fact that a length of zero is not permitted for a code has an\n+ *   interesting consequence.  Normally if only one symbol is used for a given\n+ *   code, then in fact that code could be represented with zero bits.  However\n+ *   in deflate, that code has to be at least one bit.  So for example, if\n+ *   only a single distance base symbol appears in a block, then it will be\n+ *   represented by a single code of length one, in particular one 0 bit.  This\n+ *   is an incomplete code, since if a 1 bit is received, it has no meaning,\n+ *   and should result in an error.  So incomplete distance codes of one symbol\n+ *   should be permitted, and the receipt of invalid codes should be handled.\n+ *\n+ * - It is also possible to have a single literal/length code, but that code\n+ *   must be the end-of-block code, since every dynamic block has one.  This\n+ *   is not the most efficient way to create an empty block (an empty fixed\n+ *   block is fewer bits), but it is allowed by the format.  So incomplete\n+ *   literal/length codes of one symbol should also be permitted.\n+ *\n+ * - The list of up to 286 length/literal lengths and up to 30 distance lengths\n+ *   are themselves compressed using Huffman codes and run-length encoding.  In\n+ *   the list of code lengths, a 0 symbol means no code, a 1..15 symbol means\n+ *   that length, and the symbols 16, 17, and 18 are run-length instructions.\n+ *   Each of 16, 17, and 18 are follwed by extra bits to define the length of\n+ *   the run.  16 copies the last length 3 to 6 times.  17 represents 3 to 10\n+ *   zero lengths, and 18 represents 11 to 138 zero lengths.  Unused symbols\n+ *   are common, hence the special coding for zero lengths.\n+ *\n+ * - The symbols for 0..18 are Huffman coded, and so that code must be\n+ *   described first.  This is simply a sequence of up to 19 three-bit values\n+ *   representing no code (0) or the code length for that symbol (1..7).\n+ *\n+ * - A dynamic block starts with three fixed-size counts from which is computed\n+ *   the number of literal/length code lengths, the number of distance code\n+ *   lengths, and the number of code length code lengths (ok, you come up with\n+ *   a better name!) in the code descriptions.  For the literal/length and\n+ *   distance codes, lengths after those provided are considered zero, i.e. no\n+ *   code.  The code length code lengths are received in a permuted order (see\n+ *   the order[] array below) to make a short code length code length list more\n+ *   likely.  As it turns out, very short and very long codes are less likely\n+ *   to be seen in a dynamic code description, hence what may appear initially\n+ *   to be a peculiar ordering.\n+ *\n+ * - Given the number of literal/length code lengths (nlen) and distance code\n+ *   lengths (ndist), then they are treated as one long list of nlen + ndist\n+ *   code lengths.  Therefore run-length coding can and often does cross the\n+ *   boundary between the two sets of lengths.\n+ *\n+ * - So to summarize, the code description at the start of a dynamic block is\n+ *   three counts for the number of code lengths for the literal/length codes,\n+ *   the distance codes, and the code length codes.  This is followed by the\n+ *   code length code lengths, three bits each.  This is used to construct the\n+ *   code length code which is used to read the remainder of the lengths.  Then\n+ *   the literal/length code lengths and distance lengths are read as a single\n+ *   set of lengths using the code length codes.  Codes are constructed from\n+ *   the resulting two sets of lengths, and then finally you can start\n+ *   decoding actual compressed data in the block.\n+ *\n+ * - For reference, a \"typical\" size for the code description in a dynamic\n+ *   block is around 80 bytes.\n+ */\n+local int dynamic(struct state *s)\n+{\n+    int nlen, ndist, ncode;             /* number of lengths in descriptor */\n+    int index;                          /* index of lengths[] */\n+    int err;                            /* construct() return value */\n+    short lengths[MAXCODES];            /* descriptor code lengths */\n+    short lencnt[MAXBITS+1], lensym[MAXLCODES];         /* lencode memory */\n+    short distcnt[MAXBITS+1], distsym[MAXDCODES];       /* distcode memory */\n+    struct huffman lencode = {lencnt, lensym};          /* length code */\n+    struct huffman distcode = {distcnt, distsym};       /* distance code */\n+    static const short order[19] =      /* permutation of code length codes */\n+        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n+\n+    /* get number of lengths in each table, check lengths */\n+    nlen = bits(s, 5) + 257;\n+    ndist = bits(s, 5) + 1;\n+    ncode = bits(s, 4) + 4;\n+    if (nlen > MAXLCODES || ndist > MAXDCODES)\n+        return -3;                      /* bad counts */\n+\n+    /* read code length code lengths (really), missing lengths are zero */\n+    for (index = 0; index < ncode; index++)\n+        lengths[order[index]] = bits(s, 3);\n+    for (; index < 19; index++)\n+        lengths[order[index]] = 0;\n+\n+    /* build huffman table for code lengths codes (use lencode temporarily) */\n+    err = construct(&lencode, lengths, 19);\n+    if (err != 0) return -4;            /* require complete code set here */\n+\n+    /* read length/literal and distance code length tables */\n+    index = 0;\n+    while (index < nlen + ndist) {\n+        int symbol;             /* decoded value */\n+        int len;                /* last length to repeat */\n+\n+        symbol = decode(s, &lencode);\n+        if (symbol < 16)                /* length in 0..15 */\n+            lengths[index++] = symbol;\n+        else {                          /* repeat instruction */\n+            len = 0;                    /* assume repeating zeros */\n+            if (symbol == 16) {         /* repeat last length 3..6 times */\n+                if (index == 0) return -5;      /* no last length! */\n+                len = lengths[index - 1];       /* last length */\n+                symbol = 3 + bits(s, 2);\n+            }\n+            else if (symbol == 17)      /* repeat zero 3..10 times */\n+                symbol = 3 + bits(s, 3);\n+            else                        /* == 18, repeat zero 11..138 times */\n+                symbol = 11 + bits(s, 7);\n+            if (index + symbol > nlen + ndist)\n+                return -6;              /* too many lengths! */\n+            while (symbol--)            /* repeat last or zero symbol times */\n+                lengths[index++] = len;\n+        }\n+    }\n+\n+    /* build huffman table for literal/length codes */\n+    err = construct(&lencode, lengths, nlen);\n+    if (err < 0 || (err > 0 && nlen - lencode.count[0] != 1))\n+        return -7;      /* only allow incomplete codes if just one code */\n+\n+    /* build huffman table for distance codes */\n+    err = construct(&distcode, lengths + nlen, ndist);\n+    if (err < 0 || (err > 0 && ndist - distcode.count[0] != 1))\n+        return -8;      /* only allow incomplete codes if just one code */\n+\n+    /* decode data until end-of-block code */\n+    return codes(s, &lencode, &distcode);\n+}\n+\n+/*\n+ * Inflate source to dest.  On return, destlen and sourcelen are updated to the\n+ * size of the uncompressed data and the size of the deflate data respectively.\n+ * On success, the return value of puff() is zero.  If there is an error in the\n+ * source data, i.e. it is not in the deflate format, then a negative value is\n+ * returned.  If there is not enough input available or there is not enough\n+ * output space, then a positive error is returned.  In that case, destlen and\n+ * sourcelen are not updated to facilitate retrying from the beginning with the\n+ * provision of more input data or more output space.  In the case of invalid\n+ * inflate data (a negative error), the dest and source pointers are updated to\n+ * facilitate the debugging of deflators.\n+ *\n+ * puff() also has a mode to determine the size of the uncompressed output with\n+ * no output written.  For this dest must be (unsigned char *)0.  In this case,\n+ * the input value of *destlen is ignored, and on return *destlen is set to the\n+ * size of the uncompressed output.\n+ *\n+ * The return codes are:\n+ *\n+ *   2:  available inflate data did not terminate\n+ *   1:  output space exhausted before completing inflate\n+ *   0:  successful inflate\n+ *  -1:  invalid block type (type == 3)\n+ *  -2:  stored block length did not match one's complement\n+ *  -3:  dynamic block code description: too many length or distance codes\n+ *  -4:  dynamic block code description: code lengths codes incomplete\n+ *  -5:  dynamic block code description: repeat lengths with no first length\n+ *  -6:  dynamic block code description: repeat more than specified lengths\n+ *  -7:  dynamic block code description: invalid literal/length code lengths\n+ *  -8:  dynamic block code description: invalid distance code lengths\n+ *  -9:  invalid literal/length or distance code in fixed or dynamic block\n+ * -10:  distance is too far back in fixed or dynamic block\n+ *\n+ * Format notes:\n+ *\n+ * - Three bits are read for each block to determine the kind of block and\n+ *   whether or not it is the last block.  Then the block is decoded and the\n+ *   process repeated if it was not the last block.\n+ *\n+ * - The leftover bits in the last byte of the deflate data after the last\n+ *   block (if it was a fixed or dynamic block) are undefined and have no\n+ *   expected values to check.\n+ */\n+int puff(unsigned char *dest,           /* pointer to destination pointer */\n+         unsigned long *destlen,        /* amount of output space */\n+         unsigned char *source,         /* pointer to source data pointer */\n+         unsigned long *sourcelen)      /* amount of input available */\n+{\n+    struct state s;             /* input/output state */\n+    int last, type;             /* block information */\n+    int err;                    /* return value */\n+\n+    /* initialize output state */\n+    s.out = dest;\n+    s.outlen = *destlen;                /* ignored if dest is NIL */\n+    s.outcnt = 0;\n+\n+    /* initialize input state */\n+    s.in = source;\n+    s.inlen = *sourcelen;\n+    s.incnt = 0;\n+    s.bitbuf = 0;\n+    s.bitcnt = 0;\n+\n+    /* return if bits() or decode() tries to read past available input */\n+    if (setjmp(s.env) != 0)             /* if came back here via longjmp() */\n+        err = 2;                        /* then skip do-loop, return error */\n+    else {\n+        /* process blocks until last block or error */\n+        do {\n+            last = bits(&s, 1);         /* one if last block */\n+            type = bits(&s, 2);         /* block type 0..3 */\n+            err = type == 0 ? stored(&s) :\n+                  (type == 1 ? fixed(&s) :\n+                   (type == 2 ? dynamic(&s) :\n+                    -1));               /* type == 3, invalid */\n+            if (err != 0) break;        /* return with error */\n+        } while (!last);\n+    }\n+\n+    /* update the lengths and return */\n+    if (err <= 0) {\n+        *destlen = s.outcnt;\n+        *sourcelen = s.incnt;\n+    }\n+    return err;\n+}\n+\n+#ifdef TEST\n+/* Example of how to use puff() */\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+local unsigned char *yank(char *name, unsigned long *len)\n+{\n+    unsigned long size;\n+    unsigned char *buf;\n+    FILE *in;\n+    struct stat s;\n+\n+    *len = 0;\n+    if (stat(name, &s)) return NULL;\n+    if ((s.st_mode & S_IFMT) != S_IFREG) return NULL;\n+    size = (unsigned long)(s.st_size);\n+    if (size == 0 || (off_t)size != s.st_size) return NULL;\n+    in = fopen(name, \"r\");\n+    if (in == NULL) return NULL;\n+    buf = malloc(size);\n+    if (buf != NULL && fread(buf, 1, size, in) != size) {\n+        free(buf);\n+        buf = NULL;\n+    }\n+    fclose(in);\n+    *len = size;\n+    return buf;\n+}\n+\n+int main(int argc, char **argv)\n+{\n+    int ret;\n+    unsigned char *source;\n+    unsigned long len, sourcelen, destlen;\n+\n+    if (argc < 2) return 2;\n+    source = yank(argv[1], &len);\n+    if (source == NULL) return 2;\n+    sourcelen = len;\n+    ret = puff(NIL, &destlen, source, &sourcelen);\n+    if (ret)\n+        printf(\"puff() failed with return code %d\\n\", ret);\n+    else {\n+        printf(\"puff() succeeded uncompressing %lu bytes\\n\", destlen);\n+        if (sourcelen < len) printf(\"%lu compressed bytes unused\\n\",\n+                                    len - sourcelen);\n+    }\n+    free(source);\n+    return ret;\n+}\n+#endif"}, {"sha": "ef612520b3b5f074514f9f1ff89f659883c448ff", "filename": "zlib/contrib/puff/puff.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpuff%2Fpuff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpuff%2Fpuff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpuff%2Fpuff.h?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,31 @@\n+/* puff.h\n+  Copyright (C) 2002, 2003 Mark Adler, all rights reserved\n+  version 1.7, 3 Mar 2002\n+\n+  This software is provided 'as-is', without any express or implied\n+  warranty.  In no event will the author be held liable for any damages\n+  arising from the use of this software.\n+\n+  Permission is granted to anyone to use this software for any purpose,\n+  including commercial applications, and to alter it and redistribute it\n+  freely, subject to the following restrictions:\n+\n+  1. The origin of this software must not be misrepresented; you must not\n+     claim that you wrote the original software. If you use this software\n+     in a product, an acknowledgment in the product documentation would be\n+     appreciated but is not required.\n+  2. Altered source versions must be plainly marked as such, and must not be\n+     misrepresented as being the original software.\n+  3. This notice may not be removed or altered from any source distribution.\n+\n+  Mark Adler    madler@alumni.caltech.edu\n+ */\n+\n+\n+/*\n+ * See puff.c for purpose and usage.\n+ */\n+int puff(unsigned char *dest,           /* pointer to destination pointer */\n+         unsigned long *destlen,        /* amount of output space */\n+         unsigned char *source,         /* pointer to source data pointer */\n+         unsigned long *sourcelen);     /* amount of input available */"}, {"sha": "637b7be6f5bfd577cec5537aaad160cc5fc0a7c7", "filename": "zlib/contrib/puff/zeros.raw", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpuff%2Fzeros.raw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fpuff%2Fzeros.raw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fpuff%2Fzeros.raw?ref=176ba83391a86ff69a205fafabc4782e6a067605"}, {"sha": "fdabc5c192fe95a09ecac7d00b0954f4f8cf2d73", "filename": "zlib/contrib/testzlib/testzlib.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.c?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,149 @@\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <windows.h>\n+#include \"zlib.h\"\n+\n+int ReadFileMemory(const char* filename,long* plFileSize,void** pFilePtr)\n+{\n+    FILE* stream;\n+    void* ptr;\n+    int retVal=1;\n+    stream=fopen(filename, \"rb\");\n+    if (stream==NULL)\n+        return 0;\n+\n+    fseek(stream,0,SEEK_END);\n+\n+    *plFileSize=ftell(stream);\n+    fseek(stream,0,SEEK_SET);\n+    ptr=malloc((*plFileSize)+1);\n+    if (ptr==NULL)\n+        retVal=0;\n+    else\n+    {\n+        if (fread(ptr, 1, *plFileSize,stream) != (*plFileSize))\n+            retVal=0;\n+    }\n+    fclose(stream);\n+    *pFilePtr=ptr;\n+    return retVal;\n+}\n+\n+int main(int argc, char *argv[])\n+{\n+    int BlockSizeCompress=0x8000;\n+    int BlockSizeUncompress=0x8000;\n+    int cprLevel=Z_DEFAULT_COMPRESSION ;\n+    long lFileSize;\n+    unsigned char* FilePtr;\n+    long lBufferSizeCpr;\n+    long lBufferSizeUncpr;\n+    long lCompressedSize=0;\n+    unsigned char* CprPtr;\n+    unsigned char* UncprPtr;\n+    long lSizeCpr,lSizeUncpr;\n+    DWORD dwGetTick;\n+\n+    if (argc<=1)\n+    {\n+        printf(\"run TestZlib <File> [BlockSizeCompress] [BlockSizeUncompress] [compres. level]\\n\");\n+        return 0;\n+    }\n+\n+    if (ReadFileMemory(argv[1],&lFileSize,&FilePtr)==0)\n+    {\n+        printf(\"error reading %s\\n\",argv[1]);\n+        return 1;\n+    }\n+    else printf(\"file %s read, %u bytes\\n\",argv[1],lFileSize);\n+\n+    if (argc>=3)\n+        BlockSizeCompress=atol(argv[2]);\n+\n+    if (argc>=4)\n+        BlockSizeUncompress=atol(argv[3]);\n+\n+    if (argc>=5)\n+        cprLevel=(int)atol(argv[4]);\n+\n+    lBufferSizeCpr = lFileSize + (lFileSize/0x10) + 0x200;\n+    lBufferSizeUncpr = lBufferSizeCpr;\n+\n+    CprPtr=(unsigned char*)malloc(lBufferSizeCpr + BlockSizeCompress);\n+    UncprPtr=(unsigned char*)malloc(lBufferSizeUncpr + BlockSizeUncompress);\n+\n+    dwGetTick=GetTickCount();\n+    {\n+        z_stream zcpr;\n+        int ret=Z_OK;\n+        long lOrigToDo = lFileSize;\n+        long lOrigDone = 0;\n+        int step=0;\n+        memset(&zcpr,0,sizeof(z_stream));\n+        deflateInit(&zcpr,cprLevel);\n+\n+        zcpr.next_in = FilePtr;\n+        zcpr.next_out = CprPtr;\n+\n+\n+        do\n+        {\n+            long all_read_before = zcpr.total_in;\n+            zcpr.avail_in = min(lOrigToDo,BlockSizeCompress);\n+            zcpr.avail_out = BlockSizeCompress;\n+            ret=deflate(&zcpr,(zcpr.avail_in==lOrigToDo) ? Z_FINISH : Z_SYNC_FLUSH);\n+            lOrigDone += (zcpr.total_in-all_read_before);\n+            lOrigToDo -= (zcpr.total_in-all_read_before);\n+            step++;\n+        } while (ret==Z_OK);\n+\n+        lSizeCpr=zcpr.total_out;\n+        deflateEnd(&zcpr);\n+        dwGetTick=GetTickCount()-dwGetTick;\n+        printf(\"total compress size = %u, in %u step\\n\",lSizeCpr,step);\n+        printf(\"time = %u msec = %f sec\\n\\n\",dwGetTick,dwGetTick/(double)1000.);\n+    }\n+\n+    dwGetTick=GetTickCount();\n+    {\n+        z_stream zcpr;\n+        int ret=Z_OK;\n+        long lOrigToDo = lSizeCpr;\n+        long lOrigDone = 0;\n+        int step=0;\n+        memset(&zcpr,0,sizeof(z_stream));\n+        inflateInit(&zcpr);\n+\n+        zcpr.next_in = CprPtr;\n+        zcpr.next_out = UncprPtr;\n+\n+\n+        do\n+        {\n+            long all_read_before = zcpr.total_in;\n+            zcpr.avail_in = min(lOrigToDo,BlockSizeUncompress);\n+            zcpr.avail_out = BlockSizeUncompress;\n+            ret=inflate(&zcpr,Z_SYNC_FLUSH);\n+            lOrigDone += (zcpr.total_in-all_read_before);\n+            lOrigToDo -= (zcpr.total_in-all_read_before);\n+            step++;\n+        } while (ret==Z_OK);\n+\n+        lSizeUncpr=zcpr.total_out;\n+        inflateEnd(&zcpr);\n+        dwGetTick=GetTickCount()-dwGetTick;\n+        printf(\"total uncompress size = %u, in %u step\\n\",lSizeUncpr,step);\n+        printf(\"time = %u msec = %f sec\\n\\n\",dwGetTick,dwGetTick/(double)1000.);\n+    }\n+\n+    if (lSizeUncpr==lFileSize)\n+    {\n+        if (memcmp(FilePtr,UncprPtr,lFileSize)==0)\n+            printf(\"compare ok\\n\");\n+\n+    }\n+\n+    return 0;\n+\n+}"}, {"sha": "86da7163d16ef033906f7ec22d14bf248a814af1", "filename": "zlib/contrib/testzlib/testzlib.sln", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.sln", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.sln", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.sln?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,21 @@\n+Microsoft Visual Studio Solution File, Format Version 7.00\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"testzlib\", \"testzlib.vcproj\", \"{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}\"\r\n+EndProject\r\n+Global\r\n+\tGlobalSection(SolutionConfiguration) = preSolution\r\n+\t\tConfigName.0 = Debug\r\n+\t\tConfigName.1 = Release\r\n+\tEndGlobalSection\r\n+\tGlobalSection(ProjectDependencies) = postSolution\r\n+\tEndGlobalSection\r\n+\tGlobalSection(ProjectConfiguration) = postSolution\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug.ActiveCfg = Debug|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug.Build.0 = Debug|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release.ActiveCfg = Release|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release.Build.0 = Release|Win32\r\n+\tEndGlobalSection\r\n+\tGlobalSection(ExtensibilityGlobals) = postSolution\r\n+\tEndGlobalSection\r\n+\tGlobalSection(ExtensibilityAddIns) = postSolution\r\n+\tEndGlobalSection\r\n+EndGlobal\r"}, {"sha": "bd9b39bb9d785e1252ba5a20e811832b68f5ee78", "filename": "zlib/contrib/testzlib/testzlib.vcproj", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.vcproj?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,124 @@\n+<?xml version=\"1.0\" encoding = \"Windows-1252\"?>\r\n+<VisualStudioProject\r\n+\tProjectType=\"Visual C++\"\r\n+\tVersion=\"7.00\"\r\n+\tName=\"testzlib\"\r\n+\tProjectGUID=\"{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}\"\r\n+\tKeyword=\"Win32Proj\">\r\n+\t<Platforms>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Win32\"/>\r\n+\t</Platforms>\r\n+\t<Configurations>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Win32\"\r\n+\t\t\tOutputDirectory=\"Debug\"\r\n+\t\t\tIntermediateDirectory=\"Debug\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tCharacterSet=\"2\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE\"\r\n+\t\t\t\tMinimalRebuild=\"TRUE\"\r\n+\t\t\t\tBasicRuntimeChecks=\"3\"\r\n+\t\t\t\tRuntimeLibrary=\"5\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"TRUE\"\r\n+\t\t\t\tDebugInformationFormat=\"4\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tGenerateDebugInformation=\"TRUE\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/testzlib.pdb\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Win32\"\r\n+\t\t\tOutputDirectory=\"Release\"\r\n+\t\t\tIntermediateDirectory=\"Release\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tCharacterSet=\"2\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"TRUE\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE\"\r\n+\t\t\t\tStringPooling=\"TRUE\"\r\n+\t\t\t\tRuntimeLibrary=\"4\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"TRUE\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"TRUE\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateDebugInformation=\"TRUE\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"/>\r\n+\t\t</Configuration>\r\n+\t</Configurations>\r\n+\t<Files>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Source Files\"\r\n+\t\t\tFilter=\"cpp;c;cxx;def;odl;idl;hpj;bat;asm\">\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"testzlib.c\">\r\n+\t\t\t</File>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Header Files\"\r\n+\t\t\tFilter=\"h;hpp;hxx;hm;inl;inc\">\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Resource Files\"\r\n+\t\t\tFilter=\"rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe\">\r\n+\t\t</Filter>\r\n+\t\t<File\r\n+\t\t\tRelativePath=\"zlibwapi.lib\">\r\n+\t\t</File>\r\n+\t</Files>\r\n+\t<Globals>\r\n+\t</Globals>\r\n+</VisualStudioProject>\r"}, {"sha": "77b86022137da79eb2e08a9a554863a8e2d53add", "filename": "zlib/contrib/untgz/Makefile.msc", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Funtgz%2FMakefile.msc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Funtgz%2FMakefile.msc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Funtgz%2FMakefile.msc?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,17 @@\n+CC=cl\n+CFLAGS=-MD\n+\n+untgz.exe: untgz.obj ..\\..\\zlib.lib\n+\t$(CC) $(CFLAGS) untgz.obj ..\\..\\zlib.lib\n+\n+untgz.obj: untgz.c ..\\..\\zlib.h\n+\t$(CC) $(CFLAGS) -c -I..\\.. untgz.c\n+\n+..\\..\\zlib.lib:\n+\tcd ..\\..\n+\t$(MAKE) -f win32\\makefile.msc\n+\tcd contrib\\untgz\n+\n+clean:\n+\t-del untgz.obj\n+\t-del untgz.exe"}, {"sha": "3a4b85c8ef47651d2c42f130e8af929edfbbad0d", "filename": "zlib/contrib/vstudio/readme.txt", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Freadme.txt?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,55 @@\n+Building instructions for the DLL versions of Zlib 1.21\r\n+=======================================================\r\n+\r\n+This directory contains projects that build zlib and minizip using\r\n+Microsoft Visual C++ 7.0/7.1.\r\n+\r\n+You don't need to build these projects yourself. You can download the\r\n+binaries from:\r\n+  http://www.winimage.com/zLibDll\r\n+\r\n+More information can be found at this site.\r\n+\r\n+\r\n+Build instructions\r\n+------------------\r\n+- Unzip zlib*.zip and copy the files from contrib\\vstudio\\vc7,\r\n+  from contrib\\vstudio\\masmx86 and from contrib\\minizip into the same\r\n+  directory.\r\n+- Download the crtdll library from\r\n+    http://www.winimage.com/zLibDll/crtdll.zip\r\n+  Unzip crtdll.zip to extract crtdll.lib.\r\n+- If you are using x86, use the Release target.\r\n+- Open zlibvc.sln with Microsoft Visual C++ 7.0 or 7.1\r\n+  (Visual Studio .Net 2002 or 2003).\r\n+\r\n+\r\n+Important\r\n+---------\r\n+- To use zlibwapi.dll in your application, you must define the\r\n+  macro ZLIB_WINAPI when compiling your application's source files.\r\n+\r\n+\r\n+Additional notes\r\n+----------------\r\n+- This DLL, named zlibwapi.dll, is compatible to the old zlib.dll built\r\n+  by Gilles Vollant from the zlib 1.1.x sources, and distributed at\r\n+    http://www.winimage.com/zLibDll\r\n+  It uses the WINAPI calling convention for the exported functions, and\r\n+  includes the minizip functionality. If your application needs that\r\n+  particular build of zlib.dll, you can rename zlibwapi.dll to zlib.dll.\r\n+\r\n+- The new DLL was renamed because there exist several incompatible\r\n+  versions of zlib.dll on the Internet.\r\n+\r\n+- There is also an official DLL build of zlib, named zlib1.dll. This one\r\n+  is exporting the functions using the CDECL convention. See the file\r\n+  win32\\DLL_FAQ.txt found in this zlib distribution.\r\n+\r\n+- There used to be a ZLIB_DLL macro in zlib 1.1.x, but now this symbol\r\n+  has a slightly different effect. To avoid compatibility problems, do\r\n+  not define it here.\r\n+\r\n+\r\n+Gilles Vollant\r\n+info@winimage.com\r"}, {"sha": "935c250e5f9e4cc9ea71df19a22ceb4e7bfd579a", "filename": "zlib/contrib/vstudio/vc7/miniunz.vcproj", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fminiunz.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fminiunz.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fminiunz.vcproj?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,124 @@\n+<?xml version=\"1.0\" encoding = \"Windows-1252\"?>\r\n+<VisualStudioProject\r\n+\tProjectType=\"Visual C++\"\r\n+\tVersion=\"7.00\"\r\n+\tName=\"miniunz\"\r\n+\tProjectGUID=\"{C52F9E7B-498A-42BE-8DB4-85A15694382A}\"\r\n+\tKeyword=\"Win32Proj\">\r\n+\t<Platforms>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Win32\"/>\r\n+\t</Platforms>\r\n+\t<Configurations>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Win32\"\r\n+\t\t\tOutputDirectory=\"Debug\"\r\n+\t\t\tIntermediateDirectory=\"Debug\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tCharacterSet=\"2\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE\"\r\n+\t\t\t\tMinimalRebuild=\"TRUE\"\r\n+\t\t\t\tBasicRuntimeChecks=\"3\"\r\n+\t\t\t\tRuntimeLibrary=\"5\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"TRUE\"\r\n+\t\t\t\tDebugInformationFormat=\"4\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/miniunz.exe\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tGenerateDebugInformation=\"TRUE\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/miniunz.pdb\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Win32\"\r\n+\t\t\tOutputDirectory=\"Release\"\r\n+\t\t\tIntermediateDirectory=\"Release\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tCharacterSet=\"2\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"TRUE\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE\"\r\n+\t\t\t\tStringPooling=\"TRUE\"\r\n+\t\t\t\tRuntimeLibrary=\"4\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"TRUE\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"TRUE\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/miniunz.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateDebugInformation=\"TRUE\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"/>\r\n+\t\t</Configuration>\r\n+\t</Configurations>\r\n+\t<Files>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Source Files\"\r\n+\t\t\tFilter=\"cpp;c;cxx;def;odl;idl;hpj;bat;asm\">\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"miniunz.c\">\r\n+\t\t\t</File>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Header Files\"\r\n+\t\t\tFilter=\"h;hpp;hxx;hm;inl;inc\">\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Resource Files\"\r\n+\t\t\tFilter=\"rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe\">\r\n+\t\t</Filter>\r\n+\t\t<File\r\n+\t\t\tRelativePath=\"zlibwapi.lib\">\r\n+\t\t</File>\r\n+\t</Files>\r\n+\t<Globals>\r\n+\t</Globals>\r\n+</VisualStudioProject>\r"}, {"sha": "e6f910742c1e2c62bc3fba35c93fd0460d957e0c", "filename": "zlib/contrib/vstudio/vc7/minizip.vcproj", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fminizip.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fminizip.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fminizip.vcproj?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,124 @@\n+<?xml version=\"1.0\" encoding = \"Windows-1252\"?>\r\n+<VisualStudioProject\r\n+\tProjectType=\"Visual C++\"\r\n+\tVersion=\"7.00\"\r\n+\tName=\"minizip\"\r\n+\tProjectGUID=\"{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}\"\r\n+\tKeyword=\"Win32Proj\">\r\n+\t<Platforms>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Win32\"/>\r\n+\t</Platforms>\r\n+\t<Configurations>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Win32\"\r\n+\t\t\tOutputDirectory=\"Debug\"\r\n+\t\t\tIntermediateDirectory=\"Debug\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tCharacterSet=\"2\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE\"\r\n+\t\t\t\tMinimalRebuild=\"TRUE\"\r\n+\t\t\t\tBasicRuntimeChecks=\"3\"\r\n+\t\t\t\tRuntimeLibrary=\"5\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"TRUE\"\r\n+\t\t\t\tDebugInformationFormat=\"4\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/minizip.exe\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tGenerateDebugInformation=\"TRUE\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/minizip.pdb\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Win32\"\r\n+\t\t\tOutputDirectory=\"Release\"\r\n+\t\t\tIntermediateDirectory=\"Release\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tCharacterSet=\"2\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"TRUE\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE\"\r\n+\t\t\t\tStringPooling=\"TRUE\"\r\n+\t\t\t\tRuntimeLibrary=\"4\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"TRUE\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"TRUE\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/minizip.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateDebugInformation=\"TRUE\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"/>\r\n+\t\t</Configuration>\r\n+\t</Configurations>\r\n+\t<Files>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Source Files\"\r\n+\t\t\tFilter=\"cpp;c;cxx;def;odl;idl;hpj;bat;asm\">\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"minizip.c\">\r\n+\t\t\t</File>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Header Files\"\r\n+\t\t\tFilter=\"h;hpp;hxx;hm;inl;inc\">\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Resource Files\"\r\n+\t\t\tFilter=\"rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe\">\r\n+\t\t</Filter>\r\n+\t\t<File\r\n+\t\t\tRelativePath=\"zlibwapi.lib\">\r\n+\t\t</File>\r\n+\t</Files>\r\n+\t<Globals>\r\n+\t</Globals>\r\n+</VisualStudioProject>\r"}, {"sha": "6c51679853b41409ab1c8e209d65d4900c13e9bc", "filename": "zlib/contrib/vstudio/vc7/zlib.rc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlib.rc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlib.rc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlib.rc?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,32 @@\n+#include <windows.h>\r\n+\r\n+#define IDR_VERSION1  1\r\n+IDR_VERSION1\tVERSIONINFO\tMOVEABLE IMPURE LOADONCALL DISCARDABLE\r\n+  FILEVERSION\t 1,2,1,0\r\n+  PRODUCTVERSION 1,2,1,0\r\n+  FILEFLAGSMASK\tVS_FFI_FILEFLAGSMASK\r\n+  FILEFLAGS\t0\r\n+  FILEOS\tVOS_DOS_WINDOWS32\r\n+  FILETYPE\tVFT_DLL\r\n+  FILESUBTYPE\t0\t// not used\r\n+BEGIN\r\n+  BLOCK \"StringFileInfo\"\r\n+  BEGIN\r\n+    BLOCK \"040904E4\"\r\n+    //language ID = U.S. English, char set = Windows, Multilingual\r\n+\r\n+    BEGIN\r\n+      VALUE \"FileDescription\", \"zlib data compression library\\0\"\r\n+      VALUE \"FileVersion\",\t\"1.2.1.0\\0\"\r\n+      VALUE \"InternalName\",\t\"zlib\\0\"\r\n+      VALUE \"OriginalFilename\",\t\"zlib.dll\\0\"\r\n+      VALUE \"ProductName\",\t\"ZLib.DLL\\0\"\r\n+      VALUE \"Comments\",\"DLL support by Alessandro Iacopetti & Gilles Vollant\\0\"\r\n+      VALUE \"LegalCopyright\", \"(C) 1995-2003 Jean-loup Gailly & Mark Adler\\0\"\r\n+    END\r\n+  END\r\n+  BLOCK \"VarFileInfo\"\r\n+  BEGIN\r\n+    VALUE \"Translation\", 0x0409, 1252\r\n+  END\r\n+END\r"}, {"sha": "eb182f7a884ca248edae563b9e3c7f772bcc50dd", "filename": "zlib/contrib/vstudio/vc7/zlibstat.vcproj", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibstat.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibstat.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibstat.vcproj?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,242 @@\n+<?xml version=\"1.0\" encoding = \"Windows-1252\"?>\r\n+<VisualStudioProject\r\n+\tProjectType=\"Visual C++\"\r\n+\tVersion=\"7.00\"\r\n+\tName=\"zlibstat\"\r\n+\tSccProjectName=\"\"\r\n+\tSccLocalPath=\"\">\r\n+\t<Platforms>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Win32\"/>\r\n+\t</Platforms>\r\n+\t<Configurations>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Win32\"\r\n+\t\t\tOutputDirectory=\".\\zlibstatDebug\"\r\n+\t\t\tIntermediateDirectory=\".\\zlibstatDebug\"\r\n+\t\t\tConfigurationType=\"4\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI\"\r\n+\t\t\t\tExceptionHandling=\"FALSE\"\r\n+\t\t\t\tRuntimeLibrary=\"5\"\r\n+\t\t\t\tPrecompiledHeaderFile=\".\\zlibstatDebug/zlibstat.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\".\\zlibstatDebug/\"\r\n+\t\t\t\tObjectFile=\".\\zlibstatDebug/\"\r\n+\t\t\t\tProgramDataBaseFileName=\".\\zlibstatDebug/\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"\r\n+\t\t\t\tDebugInformationFormat=\"1\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLibrarianTool\"\r\n+\t\t\t\tAdditionalOptions=\"/NODEFAULTLIB \"\r\n+\t\t\t\tOutputFile=\".\\zlibstatDebug\\zlibstat.lib\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tCulture=\"1036\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"ReleaseAxp|Win32\"\r\n+\t\t\tOutputDirectory=\".\\zlibsta0\"\r\n+\t\t\tIntermediateDirectory=\".\\zlibsta0\"\r\n+\t\t\tConfigurationType=\"4\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI\"\r\n+\t\t\t\tStringPooling=\"TRUE\"\r\n+\t\t\t\tExceptionHandling=\"FALSE\"\r\n+\t\t\t\tRuntimeLibrary=\"4\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"TRUE\"\r\n+\t\t\t\tPrecompiledHeaderFile=\".\\zlibsta0/zlibstat.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\".\\zlibsta0/\"\r\n+\t\t\t\tObjectFile=\".\\zlibsta0/\"\r\n+\t\t\t\tProgramDataBaseFileName=\".\\zlibsta0/\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLibrarianTool\"\r\n+\t\t\t\tAdditionalOptions=\"/NODEFAULTLIB \"\r\n+\t\t\t\tOutputFile=\".\\zlibsta0\\zlibstat.lib\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Win32\"\r\n+\t\t\tOutputDirectory=\".\\zlibstat\"\r\n+\t\t\tIntermediateDirectory=\".\\zlibstat\"\r\n+\t\t\tConfigurationType=\"4\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;ASMV;ASMINF\"\r\n+\t\t\t\tStringPooling=\"TRUE\"\r\n+\t\t\t\tExceptionHandling=\"FALSE\"\r\n+\t\t\t\tRuntimeLibrary=\"4\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"TRUE\"\r\n+\t\t\t\tPrecompiledHeaderFile=\".\\zlibstat/zlibstat.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\".\\zlibstat/\"\r\n+\t\t\t\tObjectFile=\".\\zlibstat/\"\r\n+\t\t\t\tProgramDataBaseFileName=\".\\zlibstat/\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLibrarianTool\"\r\n+\t\t\t\tAdditionalOptions=\"gvmat32.obj inffas32.obj /NODEFAULTLIB \"\r\n+\t\t\t\tOutputFile=\".\\zlibstat\\zlibstat.lib\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tCulture=\"1036\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"ReleaseWithoutAsm|Win32\"\r\n+\t\t\tOutputDirectory=\"zlibstatWithoutAsm\"\r\n+\t\t\tIntermediateDirectory=\"zlibstatWithoutAsm\"\r\n+\t\t\tConfigurationType=\"4\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI\"\r\n+\t\t\t\tStringPooling=\"TRUE\"\r\n+\t\t\t\tExceptionHandling=\"FALSE\"\r\n+\t\t\t\tRuntimeLibrary=\"4\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"TRUE\"\r\n+\t\t\t\tPrecompiledHeaderFile=\".\\zlibstat/zlibstat.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\".\\zlibstatWithoutAsm/\"\r\n+\t\t\t\tObjectFile=\".\\zlibstatWithoutAsm/\"\r\n+\t\t\t\tProgramDataBaseFileName=\".\\zlibstatWithoutAsm/\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLibrarianTool\"\r\n+\t\t\t\tAdditionalOptions=\" /NODEFAULTLIB \"\r\n+\t\t\t\tOutputFile=\".\\zlibstatWithoutAsm\\zlibstat.lib\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tCulture=\"1036\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t</Configuration>\r\n+\t</Configurations>\r\n+\t<Files>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Source Files\"\r\n+\t\t\tFilter=\"\">\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\adler32.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\compress.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\crc32.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\deflate.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\gvmat32c.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\gzio.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\infback.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\inffast.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\inflate.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\inftrees.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\ioapi.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\trees.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\uncompr.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\unzip.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\zip.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\zlib.rc\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\zlibvc.def\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\zutil.c\">\r\n+\t\t\t</File>\r\n+\t\t</Filter>\r\n+\t</Files>\r\n+\t<Globals>\r\n+\t</Globals>\r\n+</VisualStudioProject>\r"}, {"sha": "6bc26c4db4ffc2f85587f9e803757b7d52cf81ec", "filename": "zlib/contrib/vstudio/vc7/zlibvc.def", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.def?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,92 @@\n+\r\n+VERSION\t\t1.21\r\n+\r\n+HEAPSIZE\t1048576,8192\r\n+\r\n+EXPORTS\r\n+        adler32                                  @1\r\n+        compress                                 @2\r\n+        crc32                                    @3\r\n+        deflate                                  @4\r\n+        deflateCopy                              @5\r\n+        deflateEnd                               @6\r\n+        deflateInit2_                            @7\r\n+        deflateInit_                             @8\r\n+        deflateParams                            @9\r\n+        deflateReset                             @10\r\n+        deflateSetDictionary                     @11\r\n+        gzclose                                  @12\r\n+        gzdopen                                  @13\r\n+        gzerror                                  @14\r\n+        gzflush                                  @15\r\n+        gzopen                                   @16\r\n+        gzread                                   @17\r\n+        gzwrite                                  @18\r\n+        inflate                                  @19\r\n+        inflateEnd                               @20\r\n+        inflateInit2_                            @21\r\n+        inflateInit_                             @22\r\n+        inflateReset                             @23\r\n+        inflateSetDictionary                     @24\r\n+        inflateSync                              @25\r\n+        uncompress                               @26\r\n+        zlibVersion                              @27\r\n+        gzprintf                                 @28\r\n+        gzputc                                   @29\r\n+        gzgetc                                   @30\r\n+        gzseek                                   @31\r\n+        gzrewind                                 @32\r\n+        gztell                                   @33\r\n+        gzeof                                    @34\r\n+        gzsetparams                              @35\r\n+        zError                                   @36\r\n+        inflateSyncPoint                         @37\r\n+        get_crc_table                            @38\r\n+        compress2                                @39\r\n+        gzputs                                   @40\r\n+        gzgets                                   @41\r\n+        inflateCopy                              @42\r\n+        inflateBackInit_                         @43\r\n+        inflateBack                              @44\r\n+        inflateBackEnd                           @45\r\n+        compressBound                            @46\r\n+        deflateBound                             @47\r\n+        gzclearerr                               @48\r\n+        gzungetc                                 @49\r\n+        zlibCompileFlags                         @50\n+        deflatePrime                             @51\r\n+\r\n+        unzOpen                                  @61\r\n+        unzClose                                 @62\r\n+        unzGetGlobalInfo                         @63\r\n+        unzGetCurrentFileInfo                    @64\r\n+        unzGoToFirstFile                         @65\r\n+        unzGoToNextFile                          @66\r\n+        unzOpenCurrentFile                       @67\r\n+        unzReadCurrentFile                       @68\r\n+        unzOpenCurrentFile3                      @69\r\n+        unztell                                  @70\r\n+        unzeof                                   @71\r\n+        unzCloseCurrentFile                      @72\r\n+        unzGetGlobalComment                      @73\r\n+        unzStringFileNameCompare                 @74\r\n+        unzLocateFile                            @75\r\n+        unzGetLocalExtrafield                    @76\r\n+        unzOpen2                                 @77\r\n+        unzOpenCurrentFile2                      @78\r\n+        unzOpenCurrentFilePassword               @79\r\n+\r\n+        zipOpen                                  @80\r\n+        zipOpenNewFileInZip                      @81\r\n+        zipWriteInFileInZip                      @82\r\n+        zipCloseFileInZip                        @83\r\n+        zipClose                                 @84\r\n+        zipOpenNewFileInZip2                     @86\r\n+        zipCloseFileInZipRaw                     @87\r\n+        zipOpen2                                 @88\r\n+        zipOpenNewFileInZip3                     @89\r\n+\r\n+        unzGetFilePos                            @100\r\n+        unzGoToFilePos                           @101\r\n+\r\n+        fill_win32_filefunc                      @110\r"}, {"sha": "5a007ff697bd064ba0a6359be85e1484ca7cd6c6", "filename": "zlib/contrib/vstudio/vc7/zlibvc.sln", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.sln", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.sln", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.sln?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,66 @@\n+Microsoft Visual Studio Solution File, Format Version 7.00\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"zlibstat\", \"zlibstat.vcproj\", \"{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}\"\r\n+EndProject\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"zlibvc\", \"zlibvc.vcproj\", \"{8FD826F8-3739-44E6-8CC8-997122E53B8D}\"\r\n+EndProject\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"minizip\", \"minizip.vcproj\", \"{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}\"\r\n+EndProject\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"miniunz\", \"miniunz.vcproj\", \"{C52F9E7B-498A-42BE-8DB4-85A15694382A}\"\r\n+EndProject\r\n+Global\r\n+\tGlobalSection(SolutionConfiguration) = preSolution\r\n+\t\tConfigName.0 = Debug\r\n+\t\tConfigName.1 = Release\r\n+\t\tConfigName.2 = ReleaseAxp\r\n+\t\tConfigName.3 = ReleaseWithoutAsm\r\n+\t\tConfigName.4 = ReleaseWithoutCrtdll\r\n+\tEndGlobalSection\r\n+\tGlobalSection(ProjectDependencies) = postSolution\r\n+\tEndGlobalSection\r\n+\tGlobalSection(ProjectConfiguration) = postSolution\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug.ActiveCfg = Debug|Win32\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug.Build.0 = Debug|Win32\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release.ActiveCfg = Release|Win32\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release.Build.0 = Release|Win32\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseAxp.ActiveCfg = ReleaseAxp|Win32\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseAxp.Build.0 = ReleaseAxp|Win32\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm.ActiveCfg = ReleaseWithoutAsm|Win32\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm.Build.0 = ReleaseWithoutAsm|Win32\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutCrtdll.ActiveCfg = ReleaseAxp|Win32\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutCrtdll.Build.0 = ReleaseAxp|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug.ActiveCfg = Debug|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug.Build.0 = Debug|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release.ActiveCfg = Release|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release.Build.0 = Release|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseAxp.ActiveCfg = ReleaseAxp|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseAxp.Build.0 = ReleaseAxp|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm.ActiveCfg = ReleaseWithoutAsm|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm.Build.0 = ReleaseWithoutAsm|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutCrtdll.ActiveCfg = ReleaseWithoutCrtdll|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutCrtdll.Build.0 = ReleaseWithoutCrtdll|Win32\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug.ActiveCfg = Debug|Win32\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug.Build.0 = Debug|Win32\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release.ActiveCfg = Release|Win32\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release.Build.0 = Release|Win32\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseAxp.ActiveCfg = Release|Win32\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseAxp.Build.0 = Release|Win32\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm.ActiveCfg = Release|Win32\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm.Build.0 = Release|Win32\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutCrtdll.ActiveCfg = Release|Win32\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutCrtdll.Build.0 = Release|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug.ActiveCfg = Debug|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug.Build.0 = Debug|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release.ActiveCfg = Release|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release.Build.0 = Release|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseAxp.ActiveCfg = Release|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseAxp.Build.0 = Release|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm.ActiveCfg = Release|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm.Build.0 = Release|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutCrtdll.ActiveCfg = Release|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutCrtdll.Build.0 = Release|Win32\r\n+\tEndGlobalSection\r\n+\tGlobalSection(ExtensibilityGlobals) = postSolution\r\n+\tEndGlobalSection\r\n+\tGlobalSection(ExtensibilityAddIns) = postSolution\r\n+\tEndGlobalSection\r\n+EndGlobal\r"}, {"sha": "4e57bcdff6fbd1ea9e639bb8458adbf6ee7b07bb", "filename": "zlib/contrib/vstudio/vc7/zlibvc.vcproj", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Fzlibvc.vcproj?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,436 @@\n+<?xml version=\"1.0\" encoding = \"Windows-1252\"?>\r\n+<VisualStudioProject\r\n+\tProjectType=\"Visual C++\"\r\n+\tVersion=\"7.00\"\r\n+\tName=\"zlibvc\"\r\n+\tSccProjectName=\"\"\r\n+\tSccLocalPath=\"\">\r\n+\t<Platforms>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Win32\"/>\r\n+\t</Platforms>\r\n+\t<Configurations>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Win32\"\r\n+\t\t\tOutputDirectory=\".\\DebugDll\"\r\n+\t\t\tIntermediateDirectory=\".\\DebugDll\"\r\n+\t\t\tConfigurationType=\"2\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32,ZLIB_WINAPI,ASMV,ASMINF\"\r\n+\t\t\t\tExceptionHandling=\"FALSE\"\r\n+\t\t\t\tRuntimeLibrary=\"1\"\r\n+\t\t\t\tPrecompiledHeaderFile=\".\\DebugDll/zlibvc.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\".\\DebugDll/\"\r\n+\t\t\t\tObjectFile=\".\\DebugDll/\"\r\n+\t\t\t\tProgramDataBaseFileName=\".\\DebugDll/\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"\r\n+\t\t\t\tDebugInformationFormat=\"4\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:I386\"\r\n+\t\t\t\tAdditionalDependencies=\"gvmat32.obj inffas32.obj\"\r\n+\t\t\t\tOutputFile=\".\\DebugDll\\zlibwapi.dll\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"\r\n+\t\t\t\tModuleDefinitionFile=\".\\zlibvc.def\"\r\n+\t\t\t\tGenerateDebugInformation=\"TRUE\"\r\n+\t\t\t\tProgramDatabaseFile=\".\\DebugDll/zlibwapi.pdb\"\r\n+\t\t\t\tSubSystem=\"2\"\r\n+\t\t\t\tImportLibrary=\".\\DebugDll/zlibwapi.lib\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_DEBUG\"\r\n+\t\t\t\tMkTypLibCompatible=\"TRUE\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"\r\n+\t\t\t\tTargetEnvironment=\"1\"\r\n+\t\t\t\tTypeLibraryName=\".\\DebugDll/zlibvc.tlb\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_DEBUG\"\r\n+\t\t\t\tCulture=\"1036\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"ReleaseWithoutAsm|Win32\"\r\n+\t\t\tOutputDirectory=\".\\zlibDllWithoutAsm\"\r\n+\t\t\tIntermediateDirectory=\".\\zlibDllWithoutAsm\"\r\n+\t\t\tConfigurationType=\"2\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32,ZLIB_WINAPI\"\r\n+\t\t\t\tStringPooling=\"TRUE\"\r\n+\t\t\t\tExceptionHandling=\"FALSE\"\r\n+\t\t\t\tRuntimeLibrary=\"0\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"TRUE\"\r\n+\t\t\t\tPrecompiledHeaderFile=\".\\zlibDllWithoutAsm/zlibvc.pch\"\r\n+\t\t\t\tAssemblerOutput=\"2\"\r\n+\t\t\t\tAssemblerListingLocation=\".\\zlibDllWithoutAsm/\"\r\n+\t\t\t\tObjectFile=\".\\zlibDllWithoutAsm/\"\r\n+\t\t\t\tProgramDataBaseFileName=\".\\zlibDllWithoutAsm/\"\r\n+\t\t\t\tBrowseInformation=\"1\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:I386\"\r\n+\t\t\t\tAdditionalDependencies=\"crtdll.lib\"\r\n+\t\t\t\tOutputFile=\".\\zlibDllWithoutAsm\\zlibwapi.dll\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"\r\n+\t\t\t\tIgnoreAllDefaultLibraries=\"TRUE\"\r\n+\t\t\t\tModuleDefinitionFile=\".\\zlibvc.def\"\r\n+\t\t\t\tProgramDatabaseFile=\".\\zlibDllWithoutAsm/zlibwapi.pdb\"\r\n+\t\t\t\tGenerateMapFile=\"TRUE\"\r\n+\t\t\t\tMapFileName=\".\\zlibDllWithoutAsm/zlibwapi.map\"\r\n+\t\t\t\tSubSystem=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tImportLibrary=\".\\zlibDllWithoutAsm/zlibwapi.lib\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tMkTypLibCompatible=\"TRUE\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"\r\n+\t\t\t\tTargetEnvironment=\"1\"\r\n+\t\t\t\tTypeLibraryName=\".\\zlibDllWithoutAsm/zlibvc.tlb\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tCulture=\"1036\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"ReleaseWithoutCrtdll|Win32\"\r\n+\t\t\tOutputDirectory=\".\\zlibDllWithoutCrtDll\"\r\n+\t\t\tIntermediateDirectory=\".\\zlibDllWithoutCrtDll\"\r\n+\t\t\tConfigurationType=\"2\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32,ZLIB_WINAPI,ASMV,ASMINF\"\r\n+\t\t\t\tStringPooling=\"TRUE\"\r\n+\t\t\t\tExceptionHandling=\"FALSE\"\r\n+\t\t\t\tRuntimeLibrary=\"0\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"TRUE\"\r\n+\t\t\t\tPrecompiledHeaderFile=\".\\zlibDllWithoutCrtDll/zlibvc.pch\"\r\n+\t\t\t\tAssemblerOutput=\"2\"\r\n+\t\t\t\tAssemblerListingLocation=\".\\zlibDllWithoutCrtDll/\"\r\n+\t\t\t\tObjectFile=\".\\zlibDllWithoutCrtDll/\"\r\n+\t\t\t\tProgramDataBaseFileName=\".\\zlibDllWithoutCrtDll/\"\r\n+\t\t\t\tBrowseInformation=\"1\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:I386\"\r\n+\t\t\t\tAdditionalDependencies=\"gvmat32.obj inffas32.obj \"\r\n+\t\t\t\tOutputFile=\".\\zlibDllWithoutCrtDll\\zlibwapi.dll\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"\r\n+\t\t\t\tIgnoreAllDefaultLibraries=\"FALSE\"\r\n+\t\t\t\tModuleDefinitionFile=\".\\zlibvc.def\"\r\n+\t\t\t\tProgramDatabaseFile=\".\\zlibDllWithoutCrtDll/zlibwapi.pdb\"\r\n+\t\t\t\tGenerateMapFile=\"TRUE\"\r\n+\t\t\t\tMapFileName=\".\\zlibDllWithoutCrtDll/zlibwapi.map\"\r\n+\t\t\t\tSubSystem=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tImportLibrary=\".\\zlibDllWithoutCrtDll/zlibwapi.lib\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tMkTypLibCompatible=\"TRUE\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"\r\n+\t\t\t\tTargetEnvironment=\"1\"\r\n+\t\t\t\tTypeLibraryName=\".\\zlibDllWithoutCrtDll/zlibvc.tlb\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tCulture=\"1036\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"ReleaseAxp|Win32\"\r\n+\t\t\tOutputDirectory=\".\\zlibvc__\"\r\n+\t\t\tIntermediateDirectory=\".\\zlibvc__\"\r\n+\t\t\tConfigurationType=\"2\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32,ZLIB_WINAPI\"\r\n+\t\t\t\tStringPooling=\"TRUE\"\r\n+\t\t\t\tExceptionHandling=\"FALSE\"\r\n+\t\t\t\tRuntimeLibrary=\"0\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"TRUE\"\r\n+\t\t\t\tPrecompiledHeaderFile=\".\\zlibvc__/zlibvc.pch\"\r\n+\t\t\t\tAssemblerOutput=\"2\"\r\n+\t\t\t\tAssemblerListingLocation=\".\\zlibvc__/\"\r\n+\t\t\t\tObjectFile=\".\\zlibvc__/\"\r\n+\t\t\t\tProgramDataBaseFileName=\".\\zlibvc__/\"\r\n+\t\t\t\tBrowseInformation=\"1\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"crtdll.lib\"\r\n+\t\t\t\tOutputFile=\"zlibvc__\\zlibwapi.dll\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"\r\n+\t\t\t\tIgnoreAllDefaultLibraries=\"TRUE\"\r\n+\t\t\t\tModuleDefinitionFile=\".\\zlibvc.def\"\r\n+\t\t\t\tProgramDatabaseFile=\".\\zlibvc__/zlibwapi.pdb\"\r\n+\t\t\t\tGenerateMapFile=\"TRUE\"\r\n+\t\t\t\tMapFileName=\".\\zlibvc__/zlibwapi.map\"\r\n+\t\t\t\tSubSystem=\"2\"\r\n+\t\t\t\tImportLibrary=\".\\zlibvc__/zlibwapi.lib\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tMkTypLibCompatible=\"TRUE\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"\r\n+\t\t\t\tTargetEnvironment=\"1\"\r\n+\t\t\t\tTypeLibraryName=\".\\zlibvc__/zlibvc.tlb\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tCulture=\"1036\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Win32\"\r\n+\t\t\tOutputDirectory=\".\\ReleaseDll\"\r\n+\t\t\tIntermediateDirectory=\".\\ReleaseDll\"\r\n+\t\t\tConfigurationType=\"2\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"FALSE\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32,ZLIB_WINAPI,ASMV,ASMINF\"\r\n+\t\t\t\tStringPooling=\"TRUE\"\r\n+\t\t\t\tExceptionHandling=\"FALSE\"\r\n+\t\t\t\tRuntimeLibrary=\"0\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"TRUE\"\r\n+\t\t\t\tPrecompiledHeaderFile=\".\\ReleaseDll/zlibvc.pch\"\r\n+\t\t\t\tAssemblerOutput=\"2\"\r\n+\t\t\t\tAssemblerListingLocation=\".\\ReleaseDll/\"\r\n+\t\t\t\tObjectFile=\".\\ReleaseDll/\"\r\n+\t\t\t\tProgramDataBaseFileName=\".\\ReleaseDll/\"\r\n+\t\t\t\tBrowseInformation=\"1\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:I386\"\r\n+\t\t\t\tAdditionalDependencies=\"gvmat32.obj inffas32.obj crtdll.lib\"\r\n+\t\t\t\tOutputFile=\".\\ReleaseDll\\zlibwapi.dll\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"\r\n+\t\t\t\tIgnoreAllDefaultLibraries=\"TRUE\"\r\n+\t\t\t\tModuleDefinitionFile=\".\\zlibvc.def\"\r\n+\t\t\t\tProgramDatabaseFile=\".\\ReleaseDll/zlibwapi.pdb\"\r\n+\t\t\t\tGenerateMapFile=\"TRUE\"\r\n+\t\t\t\tMapFileName=\".\\ReleaseDll/zlibwapi.map\"\r\n+\t\t\t\tSubSystem=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tImportLibrary=\".\\ReleaseDll/zlibwapi.lib\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tMkTypLibCompatible=\"TRUE\"\r\n+\t\t\t\tSuppressStartupBanner=\"TRUE\"\r\n+\t\t\t\tTargetEnvironment=\"1\"\r\n+\t\t\t\tTypeLibraryName=\".\\Release/zlibvc.tlb\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tCulture=\"1036\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"/>\r\n+\t\t</Configuration>\r\n+\t</Configurations>\r\n+\t<Files>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Source Files\"\r\n+\t\t\tFilter=\"cpp;c;cxx;rc;def;r;odl;hpj;bat;for;f90\">\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\adler32.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\compress.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\crc32.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\deflate.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\gvmat32c.c\">\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"ReleaseWithoutAsm|Win32\"\r\n+\t\t\t\t\tExcludedFromBuild=\"TRUE\">\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\gzio.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\infback.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\inffast.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\inflate.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\inftrees.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\ioapi.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\iowin32.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\trees.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\uncompr.c\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\unzip.c\">\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Win32\">\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t\tAdditionalIncludeDirectories=\"\"\r\n+\t\t\t\t\t\tPreprocessorDefinitions=\"ZLIB_INTERNAL\"/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\zip.c\">\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Win32\">\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t\tAdditionalIncludeDirectories=\"\"\r\n+\t\t\t\t\t\tPreprocessorDefinitions=\"ZLIB_INTERNAL\"/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\zlib.rc\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\zlibvc.def\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\zutil.c\">\r\n+\t\t\t</File>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Header Files\"\r\n+\t\t\tFilter=\"h;hpp;hxx;hm;inl;fi;fd\">\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\deflate.h\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\infblock.h\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\infcodes.h\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\inffast.h\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\inftrees.h\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\infutil.h\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\zconf.h\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\zlib.h\">\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\zutil.h\">\r\n+\t\t\t</File>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Resource Files\"\r\n+\t\t\tFilter=\"ico;cur;bmp;dlg;rc2;rct;bin;cnt;rtf;gif;jpg;jpeg;jpe\">\r\n+\t\t</Filter>\r\n+\t</Files>\r\n+\t<Globals>\r\n+\t</Globals>\r\n+</VisualStudioProject>\r"}, {"sha": "8053b6117c023f64554ea783b23fa06985acff7b", "filename": "zlib/crc32.h", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcrc32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fcrc32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcrc32.h?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,441 @@\n+/* crc32.h -- tables for rapid CRC calculation\n+ * Generated automatically by crc32.c\n+ */\n+\n+local const unsigned long FAR crc_table[TBLS][256] =\n+{\n+  {\n+    0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,\n+    0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,\n+    0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,\n+    0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,\n+    0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,\n+    0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,\n+    0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,\n+    0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,\n+    0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,\n+    0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,\n+    0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,\n+    0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,\n+    0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,\n+    0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,\n+    0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,\n+    0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,\n+    0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,\n+    0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,\n+    0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,\n+    0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,\n+    0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,\n+    0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,\n+    0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,\n+    0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,\n+    0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,\n+    0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,\n+    0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,\n+    0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,\n+    0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,\n+    0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,\n+    0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,\n+    0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,\n+    0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,\n+    0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,\n+    0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,\n+    0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,\n+    0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,\n+    0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,\n+    0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,\n+    0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,\n+    0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,\n+    0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,\n+    0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,\n+    0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,\n+    0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,\n+    0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,\n+    0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,\n+    0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,\n+    0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,\n+    0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,\n+    0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,\n+    0x2d02ef8dUL\n+#ifdef BYFOUR\n+  },\n+  {\n+    0x00000000UL, 0x191b3141UL, 0x32366282UL, 0x2b2d53c3UL, 0x646cc504UL,\n+    0x7d77f445UL, 0x565aa786UL, 0x4f4196c7UL, 0xc8d98a08UL, 0xd1c2bb49UL,\n+    0xfaefe88aUL, 0xe3f4d9cbUL, 0xacb54f0cUL, 0xb5ae7e4dUL, 0x9e832d8eUL,\n+    0x87981ccfUL, 0x4ac21251UL, 0x53d92310UL, 0x78f470d3UL, 0x61ef4192UL,\n+    0x2eaed755UL, 0x37b5e614UL, 0x1c98b5d7UL, 0x05838496UL, 0x821b9859UL,\n+    0x9b00a918UL, 0xb02dfadbUL, 0xa936cb9aUL, 0xe6775d5dUL, 0xff6c6c1cUL,\n+    0xd4413fdfUL, 0xcd5a0e9eUL, 0x958424a2UL, 0x8c9f15e3UL, 0xa7b24620UL,\n+    0xbea97761UL, 0xf1e8e1a6UL, 0xe8f3d0e7UL, 0xc3de8324UL, 0xdac5b265UL,\n+    0x5d5daeaaUL, 0x44469febUL, 0x6f6bcc28UL, 0x7670fd69UL, 0x39316baeUL,\n+    0x202a5aefUL, 0x0b07092cUL, 0x121c386dUL, 0xdf4636f3UL, 0xc65d07b2UL,\n+    0xed705471UL, 0xf46b6530UL, 0xbb2af3f7UL, 0xa231c2b6UL, 0x891c9175UL,\n+    0x9007a034UL, 0x179fbcfbUL, 0x0e848dbaUL, 0x25a9de79UL, 0x3cb2ef38UL,\n+    0x73f379ffUL, 0x6ae848beUL, 0x41c51b7dUL, 0x58de2a3cUL, 0xf0794f05UL,\n+    0xe9627e44UL, 0xc24f2d87UL, 0xdb541cc6UL, 0x94158a01UL, 0x8d0ebb40UL,\n+    0xa623e883UL, 0xbf38d9c2UL, 0x38a0c50dUL, 0x21bbf44cUL, 0x0a96a78fUL,\n+    0x138d96ceUL, 0x5ccc0009UL, 0x45d73148UL, 0x6efa628bUL, 0x77e153caUL,\n+    0xbabb5d54UL, 0xa3a06c15UL, 0x888d3fd6UL, 0x91960e97UL, 0xded79850UL,\n+    0xc7cca911UL, 0xece1fad2UL, 0xf5facb93UL, 0x7262d75cUL, 0x6b79e61dUL,\n+    0x4054b5deUL, 0x594f849fUL, 0x160e1258UL, 0x0f152319UL, 0x243870daUL,\n+    0x3d23419bUL, 0x65fd6ba7UL, 0x7ce65ae6UL, 0x57cb0925UL, 0x4ed03864UL,\n+    0x0191aea3UL, 0x188a9fe2UL, 0x33a7cc21UL, 0x2abcfd60UL, 0xad24e1afUL,\n+    0xb43fd0eeUL, 0x9f12832dUL, 0x8609b26cUL, 0xc94824abUL, 0xd05315eaUL,\n+    0xfb7e4629UL, 0xe2657768UL, 0x2f3f79f6UL, 0x362448b7UL, 0x1d091b74UL,\n+    0x04122a35UL, 0x4b53bcf2UL, 0x52488db3UL, 0x7965de70UL, 0x607eef31UL,\n+    0xe7e6f3feUL, 0xfefdc2bfUL, 0xd5d0917cUL, 0xcccba03dUL, 0x838a36faUL,\n+    0x9a9107bbUL, 0xb1bc5478UL, 0xa8a76539UL, 0x3b83984bUL, 0x2298a90aUL,\n+    0x09b5fac9UL, 0x10aecb88UL, 0x5fef5d4fUL, 0x46f46c0eUL, 0x6dd93fcdUL,\n+    0x74c20e8cUL, 0xf35a1243UL, 0xea412302UL, 0xc16c70c1UL, 0xd8774180UL,\n+    0x9736d747UL, 0x8e2de606UL, 0xa500b5c5UL, 0xbc1b8484UL, 0x71418a1aUL,\n+    0x685abb5bUL, 0x4377e898UL, 0x5a6cd9d9UL, 0x152d4f1eUL, 0x0c367e5fUL,\n+    0x271b2d9cUL, 0x3e001cddUL, 0xb9980012UL, 0xa0833153UL, 0x8bae6290UL,\n+    0x92b553d1UL, 0xddf4c516UL, 0xc4eff457UL, 0xefc2a794UL, 0xf6d996d5UL,\n+    0xae07bce9UL, 0xb71c8da8UL, 0x9c31de6bUL, 0x852aef2aUL, 0xca6b79edUL,\n+    0xd37048acUL, 0xf85d1b6fUL, 0xe1462a2eUL, 0x66de36e1UL, 0x7fc507a0UL,\n+    0x54e85463UL, 0x4df36522UL, 0x02b2f3e5UL, 0x1ba9c2a4UL, 0x30849167UL,\n+    0x299fa026UL, 0xe4c5aeb8UL, 0xfdde9ff9UL, 0xd6f3cc3aUL, 0xcfe8fd7bUL,\n+    0x80a96bbcUL, 0x99b25afdUL, 0xb29f093eUL, 0xab84387fUL, 0x2c1c24b0UL,\n+    0x350715f1UL, 0x1e2a4632UL, 0x07317773UL, 0x4870e1b4UL, 0x516bd0f5UL,\n+    0x7a468336UL, 0x635db277UL, 0xcbfad74eUL, 0xd2e1e60fUL, 0xf9ccb5ccUL,\n+    0xe0d7848dUL, 0xaf96124aUL, 0xb68d230bUL, 0x9da070c8UL, 0x84bb4189UL,\n+    0x03235d46UL, 0x1a386c07UL, 0x31153fc4UL, 0x280e0e85UL, 0x674f9842UL,\n+    0x7e54a903UL, 0x5579fac0UL, 0x4c62cb81UL, 0x8138c51fUL, 0x9823f45eUL,\n+    0xb30ea79dUL, 0xaa1596dcUL, 0xe554001bUL, 0xfc4f315aUL, 0xd7626299UL,\n+    0xce7953d8UL, 0x49e14f17UL, 0x50fa7e56UL, 0x7bd72d95UL, 0x62cc1cd4UL,\n+    0x2d8d8a13UL, 0x3496bb52UL, 0x1fbbe891UL, 0x06a0d9d0UL, 0x5e7ef3ecUL,\n+    0x4765c2adUL, 0x6c48916eUL, 0x7553a02fUL, 0x3a1236e8UL, 0x230907a9UL,\n+    0x0824546aUL, 0x113f652bUL, 0x96a779e4UL, 0x8fbc48a5UL, 0xa4911b66UL,\n+    0xbd8a2a27UL, 0xf2cbbce0UL, 0xebd08da1UL, 0xc0fdde62UL, 0xd9e6ef23UL,\n+    0x14bce1bdUL, 0x0da7d0fcUL, 0x268a833fUL, 0x3f91b27eUL, 0x70d024b9UL,\n+    0x69cb15f8UL, 0x42e6463bUL, 0x5bfd777aUL, 0xdc656bb5UL, 0xc57e5af4UL,\n+    0xee530937UL, 0xf7483876UL, 0xb809aeb1UL, 0xa1129ff0UL, 0x8a3fcc33UL,\n+    0x9324fd72UL\n+  },\n+  {\n+    0x00000000UL, 0x01c26a37UL, 0x0384d46eUL, 0x0246be59UL, 0x0709a8dcUL,\n+    0x06cbc2ebUL, 0x048d7cb2UL, 0x054f1685UL, 0x0e1351b8UL, 0x0fd13b8fUL,\n+    0x0d9785d6UL, 0x0c55efe1UL, 0x091af964UL, 0x08d89353UL, 0x0a9e2d0aUL,\n+    0x0b5c473dUL, 0x1c26a370UL, 0x1de4c947UL, 0x1fa2771eUL, 0x1e601d29UL,\n+    0x1b2f0bacUL, 0x1aed619bUL, 0x18abdfc2UL, 0x1969b5f5UL, 0x1235f2c8UL,\n+    0x13f798ffUL, 0x11b126a6UL, 0x10734c91UL, 0x153c5a14UL, 0x14fe3023UL,\n+    0x16b88e7aUL, 0x177ae44dUL, 0x384d46e0UL, 0x398f2cd7UL, 0x3bc9928eUL,\n+    0x3a0bf8b9UL, 0x3f44ee3cUL, 0x3e86840bUL, 0x3cc03a52UL, 0x3d025065UL,\n+    0x365e1758UL, 0x379c7d6fUL, 0x35dac336UL, 0x3418a901UL, 0x3157bf84UL,\n+    0x3095d5b3UL, 0x32d36beaUL, 0x331101ddUL, 0x246be590UL, 0x25a98fa7UL,\n+    0x27ef31feUL, 0x262d5bc9UL, 0x23624d4cUL, 0x22a0277bUL, 0x20e69922UL,\n+    0x2124f315UL, 0x2a78b428UL, 0x2bbade1fUL, 0x29fc6046UL, 0x283e0a71UL,\n+    0x2d711cf4UL, 0x2cb376c3UL, 0x2ef5c89aUL, 0x2f37a2adUL, 0x709a8dc0UL,\n+    0x7158e7f7UL, 0x731e59aeUL, 0x72dc3399UL, 0x7793251cUL, 0x76514f2bUL,\n+    0x7417f172UL, 0x75d59b45UL, 0x7e89dc78UL, 0x7f4bb64fUL, 0x7d0d0816UL,\n+    0x7ccf6221UL, 0x798074a4UL, 0x78421e93UL, 0x7a04a0caUL, 0x7bc6cafdUL,\n+    0x6cbc2eb0UL, 0x6d7e4487UL, 0x6f38fadeUL, 0x6efa90e9UL, 0x6bb5866cUL,\n+    0x6a77ec5bUL, 0x68315202UL, 0x69f33835UL, 0x62af7f08UL, 0x636d153fUL,\n+    0x612bab66UL, 0x60e9c151UL, 0x65a6d7d4UL, 0x6464bde3UL, 0x662203baUL,\n+    0x67e0698dUL, 0x48d7cb20UL, 0x4915a117UL, 0x4b531f4eUL, 0x4a917579UL,\n+    0x4fde63fcUL, 0x4e1c09cbUL, 0x4c5ab792UL, 0x4d98dda5UL, 0x46c49a98UL,\n+    0x4706f0afUL, 0x45404ef6UL, 0x448224c1UL, 0x41cd3244UL, 0x400f5873UL,\n+    0x4249e62aUL, 0x438b8c1dUL, 0x54f16850UL, 0x55330267UL, 0x5775bc3eUL,\n+    0x56b7d609UL, 0x53f8c08cUL, 0x523aaabbUL, 0x507c14e2UL, 0x51be7ed5UL,\n+    0x5ae239e8UL, 0x5b2053dfUL, 0x5966ed86UL, 0x58a487b1UL, 0x5deb9134UL,\n+    0x5c29fb03UL, 0x5e6f455aUL, 0x5fad2f6dUL, 0xe1351b80UL, 0xe0f771b7UL,\n+    0xe2b1cfeeUL, 0xe373a5d9UL, 0xe63cb35cUL, 0xe7fed96bUL, 0xe5b86732UL,\n+    0xe47a0d05UL, 0xef264a38UL, 0xeee4200fUL, 0xeca29e56UL, 0xed60f461UL,\n+    0xe82fe2e4UL, 0xe9ed88d3UL, 0xebab368aUL, 0xea695cbdUL, 0xfd13b8f0UL,\n+    0xfcd1d2c7UL, 0xfe976c9eUL, 0xff5506a9UL, 0xfa1a102cUL, 0xfbd87a1bUL,\n+    0xf99ec442UL, 0xf85cae75UL, 0xf300e948UL, 0xf2c2837fUL, 0xf0843d26UL,\n+    0xf1465711UL, 0xf4094194UL, 0xf5cb2ba3UL, 0xf78d95faUL, 0xf64fffcdUL,\n+    0xd9785d60UL, 0xd8ba3757UL, 0xdafc890eUL, 0xdb3ee339UL, 0xde71f5bcUL,\n+    0xdfb39f8bUL, 0xddf521d2UL, 0xdc374be5UL, 0xd76b0cd8UL, 0xd6a966efUL,\n+    0xd4efd8b6UL, 0xd52db281UL, 0xd062a404UL, 0xd1a0ce33UL, 0xd3e6706aUL,\n+    0xd2241a5dUL, 0xc55efe10UL, 0xc49c9427UL, 0xc6da2a7eUL, 0xc7184049UL,\n+    0xc25756ccUL, 0xc3953cfbUL, 0xc1d382a2UL, 0xc011e895UL, 0xcb4dafa8UL,\n+    0xca8fc59fUL, 0xc8c97bc6UL, 0xc90b11f1UL, 0xcc440774UL, 0xcd866d43UL,\n+    0xcfc0d31aUL, 0xce02b92dUL, 0x91af9640UL, 0x906dfc77UL, 0x922b422eUL,\n+    0x93e92819UL, 0x96a63e9cUL, 0x976454abUL, 0x9522eaf2UL, 0x94e080c5UL,\n+    0x9fbcc7f8UL, 0x9e7eadcfUL, 0x9c381396UL, 0x9dfa79a1UL, 0x98b56f24UL,\n+    0x99770513UL, 0x9b31bb4aUL, 0x9af3d17dUL, 0x8d893530UL, 0x8c4b5f07UL,\n+    0x8e0de15eUL, 0x8fcf8b69UL, 0x8a809decUL, 0x8b42f7dbUL, 0x89044982UL,\n+    0x88c623b5UL, 0x839a6488UL, 0x82580ebfUL, 0x801eb0e6UL, 0x81dcdad1UL,\n+    0x8493cc54UL, 0x8551a663UL, 0x8717183aUL, 0x86d5720dUL, 0xa9e2d0a0UL,\n+    0xa820ba97UL, 0xaa6604ceUL, 0xaba46ef9UL, 0xaeeb787cUL, 0xaf29124bUL,\n+    0xad6fac12UL, 0xacadc625UL, 0xa7f18118UL, 0xa633eb2fUL, 0xa4755576UL,\n+    0xa5b73f41UL, 0xa0f829c4UL, 0xa13a43f3UL, 0xa37cfdaaUL, 0xa2be979dUL,\n+    0xb5c473d0UL, 0xb40619e7UL, 0xb640a7beUL, 0xb782cd89UL, 0xb2cddb0cUL,\n+    0xb30fb13bUL, 0xb1490f62UL, 0xb08b6555UL, 0xbbd72268UL, 0xba15485fUL,\n+    0xb853f606UL, 0xb9919c31UL, 0xbcde8ab4UL, 0xbd1ce083UL, 0xbf5a5edaUL,\n+    0xbe9834edUL\n+  },\n+  {\n+    0x00000000UL, 0xb8bc6765UL, 0xaa09c88bUL, 0x12b5afeeUL, 0x8f629757UL,\n+    0x37def032UL, 0x256b5fdcUL, 0x9dd738b9UL, 0xc5b428efUL, 0x7d084f8aUL,\n+    0x6fbde064UL, 0xd7018701UL, 0x4ad6bfb8UL, 0xf26ad8ddUL, 0xe0df7733UL,\n+    0x58631056UL, 0x5019579fUL, 0xe8a530faUL, 0xfa109f14UL, 0x42acf871UL,\n+    0xdf7bc0c8UL, 0x67c7a7adUL, 0x75720843UL, 0xcdce6f26UL, 0x95ad7f70UL,\n+    0x2d111815UL, 0x3fa4b7fbUL, 0x8718d09eUL, 0x1acfe827UL, 0xa2738f42UL,\n+    0xb0c620acUL, 0x087a47c9UL, 0xa032af3eUL, 0x188ec85bUL, 0x0a3b67b5UL,\n+    0xb28700d0UL, 0x2f503869UL, 0x97ec5f0cUL, 0x8559f0e2UL, 0x3de59787UL,\n+    0x658687d1UL, 0xdd3ae0b4UL, 0xcf8f4f5aUL, 0x7733283fUL, 0xeae41086UL,\n+    0x525877e3UL, 0x40edd80dUL, 0xf851bf68UL, 0xf02bf8a1UL, 0x48979fc4UL,\n+    0x5a22302aUL, 0xe29e574fUL, 0x7f496ff6UL, 0xc7f50893UL, 0xd540a77dUL,\n+    0x6dfcc018UL, 0x359fd04eUL, 0x8d23b72bUL, 0x9f9618c5UL, 0x272a7fa0UL,\n+    0xbafd4719UL, 0x0241207cUL, 0x10f48f92UL, 0xa848e8f7UL, 0x9b14583dUL,\n+    0x23a83f58UL, 0x311d90b6UL, 0x89a1f7d3UL, 0x1476cf6aUL, 0xaccaa80fUL,\n+    0xbe7f07e1UL, 0x06c36084UL, 0x5ea070d2UL, 0xe61c17b7UL, 0xf4a9b859UL,\n+    0x4c15df3cUL, 0xd1c2e785UL, 0x697e80e0UL, 0x7bcb2f0eUL, 0xc377486bUL,\n+    0xcb0d0fa2UL, 0x73b168c7UL, 0x6104c729UL, 0xd9b8a04cUL, 0x446f98f5UL,\n+    0xfcd3ff90UL, 0xee66507eUL, 0x56da371bUL, 0x0eb9274dUL, 0xb6054028UL,\n+    0xa4b0efc6UL, 0x1c0c88a3UL, 0x81dbb01aUL, 0x3967d77fUL, 0x2bd27891UL,\n+    0x936e1ff4UL, 0x3b26f703UL, 0x839a9066UL, 0x912f3f88UL, 0x299358edUL,\n+    0xb4446054UL, 0x0cf80731UL, 0x1e4da8dfUL, 0xa6f1cfbaUL, 0xfe92dfecUL,\n+    0x462eb889UL, 0x549b1767UL, 0xec277002UL, 0x71f048bbUL, 0xc94c2fdeUL,\n+    0xdbf98030UL, 0x6345e755UL, 0x6b3fa09cUL, 0xd383c7f9UL, 0xc1366817UL,\n+    0x798a0f72UL, 0xe45d37cbUL, 0x5ce150aeUL, 0x4e54ff40UL, 0xf6e89825UL,\n+    0xae8b8873UL, 0x1637ef16UL, 0x048240f8UL, 0xbc3e279dUL, 0x21e91f24UL,\n+    0x99557841UL, 0x8be0d7afUL, 0x335cb0caUL, 0xed59b63bUL, 0x55e5d15eUL,\n+    0x47507eb0UL, 0xffec19d5UL, 0x623b216cUL, 0xda874609UL, 0xc832e9e7UL,\n+    0x708e8e82UL, 0x28ed9ed4UL, 0x9051f9b1UL, 0x82e4565fUL, 0x3a58313aUL,\n+    0xa78f0983UL, 0x1f336ee6UL, 0x0d86c108UL, 0xb53aa66dUL, 0xbd40e1a4UL,\n+    0x05fc86c1UL, 0x1749292fUL, 0xaff54e4aUL, 0x322276f3UL, 0x8a9e1196UL,\n+    0x982bbe78UL, 0x2097d91dUL, 0x78f4c94bUL, 0xc048ae2eUL, 0xd2fd01c0UL,\n+    0x6a4166a5UL, 0xf7965e1cUL, 0x4f2a3979UL, 0x5d9f9697UL, 0xe523f1f2UL,\n+    0x4d6b1905UL, 0xf5d77e60UL, 0xe762d18eUL, 0x5fdeb6ebUL, 0xc2098e52UL,\n+    0x7ab5e937UL, 0x680046d9UL, 0xd0bc21bcUL, 0x88df31eaUL, 0x3063568fUL,\n+    0x22d6f961UL, 0x9a6a9e04UL, 0x07bda6bdUL, 0xbf01c1d8UL, 0xadb46e36UL,\n+    0x15080953UL, 0x1d724e9aUL, 0xa5ce29ffUL, 0xb77b8611UL, 0x0fc7e174UL,\n+    0x9210d9cdUL, 0x2aacbea8UL, 0x38191146UL, 0x80a57623UL, 0xd8c66675UL,\n+    0x607a0110UL, 0x72cfaefeUL, 0xca73c99bUL, 0x57a4f122UL, 0xef189647UL,\n+    0xfdad39a9UL, 0x45115eccUL, 0x764dee06UL, 0xcef18963UL, 0xdc44268dUL,\n+    0x64f841e8UL, 0xf92f7951UL, 0x41931e34UL, 0x5326b1daUL, 0xeb9ad6bfUL,\n+    0xb3f9c6e9UL, 0x0b45a18cUL, 0x19f00e62UL, 0xa14c6907UL, 0x3c9b51beUL,\n+    0x842736dbUL, 0x96929935UL, 0x2e2efe50UL, 0x2654b999UL, 0x9ee8defcUL,\n+    0x8c5d7112UL, 0x34e11677UL, 0xa9362eceUL, 0x118a49abUL, 0x033fe645UL,\n+    0xbb838120UL, 0xe3e09176UL, 0x5b5cf613UL, 0x49e959fdUL, 0xf1553e98UL,\n+    0x6c820621UL, 0xd43e6144UL, 0xc68bceaaUL, 0x7e37a9cfUL, 0xd67f4138UL,\n+    0x6ec3265dUL, 0x7c7689b3UL, 0xc4caeed6UL, 0x591dd66fUL, 0xe1a1b10aUL,\n+    0xf3141ee4UL, 0x4ba87981UL, 0x13cb69d7UL, 0xab770eb2UL, 0xb9c2a15cUL,\n+    0x017ec639UL, 0x9ca9fe80UL, 0x241599e5UL, 0x36a0360bUL, 0x8e1c516eUL,\n+    0x866616a7UL, 0x3eda71c2UL, 0x2c6fde2cUL, 0x94d3b949UL, 0x090481f0UL,\n+    0xb1b8e695UL, 0xa30d497bUL, 0x1bb12e1eUL, 0x43d23e48UL, 0xfb6e592dUL,\n+    0xe9dbf6c3UL, 0x516791a6UL, 0xccb0a91fUL, 0x740cce7aUL, 0x66b96194UL,\n+    0xde0506f1UL\n+  },\n+  {\n+    0x00000000UL, 0x96300777UL, 0x2c610eeeUL, 0xba510999UL, 0x19c46d07UL,\n+    0x8ff46a70UL, 0x35a563e9UL, 0xa395649eUL, 0x3288db0eUL, 0xa4b8dc79UL,\n+    0x1ee9d5e0UL, 0x88d9d297UL, 0x2b4cb609UL, 0xbd7cb17eUL, 0x072db8e7UL,\n+    0x911dbf90UL, 0x6410b71dUL, 0xf220b06aUL, 0x4871b9f3UL, 0xde41be84UL,\n+    0x7dd4da1aUL, 0xebe4dd6dUL, 0x51b5d4f4UL, 0xc785d383UL, 0x56986c13UL,\n+    0xc0a86b64UL, 0x7af962fdUL, 0xecc9658aUL, 0x4f5c0114UL, 0xd96c0663UL,\n+    0x633d0ffaUL, 0xf50d088dUL, 0xc8206e3bUL, 0x5e10694cUL, 0xe44160d5UL,\n+    0x727167a2UL, 0xd1e4033cUL, 0x47d4044bUL, 0xfd850dd2UL, 0x6bb50aa5UL,\n+    0xfaa8b535UL, 0x6c98b242UL, 0xd6c9bbdbUL, 0x40f9bcacUL, 0xe36cd832UL,\n+    0x755cdf45UL, 0xcf0dd6dcUL, 0x593dd1abUL, 0xac30d926UL, 0x3a00de51UL,\n+    0x8051d7c8UL, 0x1661d0bfUL, 0xb5f4b421UL, 0x23c4b356UL, 0x9995bacfUL,\n+    0x0fa5bdb8UL, 0x9eb80228UL, 0x0888055fUL, 0xb2d90cc6UL, 0x24e90bb1UL,\n+    0x877c6f2fUL, 0x114c6858UL, 0xab1d61c1UL, 0x3d2d66b6UL, 0x9041dc76UL,\n+    0x0671db01UL, 0xbc20d298UL, 0x2a10d5efUL, 0x8985b171UL, 0x1fb5b606UL,\n+    0xa5e4bf9fUL, 0x33d4b8e8UL, 0xa2c90778UL, 0x34f9000fUL, 0x8ea80996UL,\n+    0x18980ee1UL, 0xbb0d6a7fUL, 0x2d3d6d08UL, 0x976c6491UL, 0x015c63e6UL,\n+    0xf4516b6bUL, 0x62616c1cUL, 0xd8306585UL, 0x4e0062f2UL, 0xed95066cUL,\n+    0x7ba5011bUL, 0xc1f40882UL, 0x57c40ff5UL, 0xc6d9b065UL, 0x50e9b712UL,\n+    0xeab8be8bUL, 0x7c88b9fcUL, 0xdf1ddd62UL, 0x492dda15UL, 0xf37cd38cUL,\n+    0x654cd4fbUL, 0x5861b24dUL, 0xce51b53aUL, 0x7400bca3UL, 0xe230bbd4UL,\n+    0x41a5df4aUL, 0xd795d83dUL, 0x6dc4d1a4UL, 0xfbf4d6d3UL, 0x6ae96943UL,\n+    0xfcd96e34UL, 0x468867adUL, 0xd0b860daUL, 0x732d0444UL, 0xe51d0333UL,\n+    0x5f4c0aaaUL, 0xc97c0dddUL, 0x3c710550UL, 0xaa410227UL, 0x10100bbeUL,\n+    0x86200cc9UL, 0x25b56857UL, 0xb3856f20UL, 0x09d466b9UL, 0x9fe461ceUL,\n+    0x0ef9de5eUL, 0x98c9d929UL, 0x2298d0b0UL, 0xb4a8d7c7UL, 0x173db359UL,\n+    0x810db42eUL, 0x3b5cbdb7UL, 0xad6cbac0UL, 0x2083b8edUL, 0xb6b3bf9aUL,\n+    0x0ce2b603UL, 0x9ad2b174UL, 0x3947d5eaUL, 0xaf77d29dUL, 0x1526db04UL,\n+    0x8316dc73UL, 0x120b63e3UL, 0x843b6494UL, 0x3e6a6d0dUL, 0xa85a6a7aUL,\n+    0x0bcf0ee4UL, 0x9dff0993UL, 0x27ae000aUL, 0xb19e077dUL, 0x44930ff0UL,\n+    0xd2a30887UL, 0x68f2011eUL, 0xfec20669UL, 0x5d5762f7UL, 0xcb676580UL,\n+    0x71366c19UL, 0xe7066b6eUL, 0x761bd4feUL, 0xe02bd389UL, 0x5a7ada10UL,\n+    0xcc4add67UL, 0x6fdfb9f9UL, 0xf9efbe8eUL, 0x43beb717UL, 0xd58eb060UL,\n+    0xe8a3d6d6UL, 0x7e93d1a1UL, 0xc4c2d838UL, 0x52f2df4fUL, 0xf167bbd1UL,\n+    0x6757bca6UL, 0xdd06b53fUL, 0x4b36b248UL, 0xda2b0dd8UL, 0x4c1b0aafUL,\n+    0xf64a0336UL, 0x607a0441UL, 0xc3ef60dfUL, 0x55df67a8UL, 0xef8e6e31UL,\n+    0x79be6946UL, 0x8cb361cbUL, 0x1a8366bcUL, 0xa0d26f25UL, 0x36e26852UL,\n+    0x95770cccUL, 0x03470bbbUL, 0xb9160222UL, 0x2f260555UL, 0xbe3bbac5UL,\n+    0x280bbdb2UL, 0x925ab42bUL, 0x046ab35cUL, 0xa7ffd7c2UL, 0x31cfd0b5UL,\n+    0x8b9ed92cUL, 0x1daede5bUL, 0xb0c2649bUL, 0x26f263ecUL, 0x9ca36a75UL,\n+    0x0a936d02UL, 0xa906099cUL, 0x3f360eebUL, 0x85670772UL, 0x13570005UL,\n+    0x824abf95UL, 0x147ab8e2UL, 0xae2bb17bUL, 0x381bb60cUL, 0x9b8ed292UL,\n+    0x0dbed5e5UL, 0xb7efdc7cUL, 0x21dfdb0bUL, 0xd4d2d386UL, 0x42e2d4f1UL,\n+    0xf8b3dd68UL, 0x6e83da1fUL, 0xcd16be81UL, 0x5b26b9f6UL, 0xe177b06fUL,\n+    0x7747b718UL, 0xe65a0888UL, 0x706a0fffUL, 0xca3b0666UL, 0x5c0b0111UL,\n+    0xff9e658fUL, 0x69ae62f8UL, 0xd3ff6b61UL, 0x45cf6c16UL, 0x78e20aa0UL,\n+    0xeed20dd7UL, 0x5483044eUL, 0xc2b30339UL, 0x612667a7UL, 0xf71660d0UL,\n+    0x4d476949UL, 0xdb776e3eUL, 0x4a6ad1aeUL, 0xdc5ad6d9UL, 0x660bdf40UL,\n+    0xf03bd837UL, 0x53aebca9UL, 0xc59ebbdeUL, 0x7fcfb247UL, 0xe9ffb530UL,\n+    0x1cf2bdbdUL, 0x8ac2bacaUL, 0x3093b353UL, 0xa6a3b424UL, 0x0536d0baUL,\n+    0x9306d7cdUL, 0x2957de54UL, 0xbf67d923UL, 0x2e7a66b3UL, 0xb84a61c4UL,\n+    0x021b685dUL, 0x942b6f2aUL, 0x37be0bb4UL, 0xa18e0cc3UL, 0x1bdf055aUL,\n+    0x8def022dUL\n+  },\n+  {\n+    0x00000000UL, 0x41311b19UL, 0x82623632UL, 0xc3532d2bUL, 0x04c56c64UL,\n+    0x45f4777dUL, 0x86a75a56UL, 0xc796414fUL, 0x088ad9c8UL, 0x49bbc2d1UL,\n+    0x8ae8effaUL, 0xcbd9f4e3UL, 0x0c4fb5acUL, 0x4d7eaeb5UL, 0x8e2d839eUL,\n+    0xcf1c9887UL, 0x5112c24aUL, 0x1023d953UL, 0xd370f478UL, 0x9241ef61UL,\n+    0x55d7ae2eUL, 0x14e6b537UL, 0xd7b5981cUL, 0x96848305UL, 0x59981b82UL,\n+    0x18a9009bUL, 0xdbfa2db0UL, 0x9acb36a9UL, 0x5d5d77e6UL, 0x1c6c6cffUL,\n+    0xdf3f41d4UL, 0x9e0e5acdUL, 0xa2248495UL, 0xe3159f8cUL, 0x2046b2a7UL,\n+    0x6177a9beUL, 0xa6e1e8f1UL, 0xe7d0f3e8UL, 0x2483dec3UL, 0x65b2c5daUL,\n+    0xaaae5d5dUL, 0xeb9f4644UL, 0x28cc6b6fUL, 0x69fd7076UL, 0xae6b3139UL,\n+    0xef5a2a20UL, 0x2c09070bUL, 0x6d381c12UL, 0xf33646dfUL, 0xb2075dc6UL,\n+    0x715470edUL, 0x30656bf4UL, 0xf7f32abbUL, 0xb6c231a2UL, 0x75911c89UL,\n+    0x34a00790UL, 0xfbbc9f17UL, 0xba8d840eUL, 0x79dea925UL, 0x38efb23cUL,\n+    0xff79f373UL, 0xbe48e86aUL, 0x7d1bc541UL, 0x3c2ade58UL, 0x054f79f0UL,\n+    0x447e62e9UL, 0x872d4fc2UL, 0xc61c54dbUL, 0x018a1594UL, 0x40bb0e8dUL,\n+    0x83e823a6UL, 0xc2d938bfUL, 0x0dc5a038UL, 0x4cf4bb21UL, 0x8fa7960aUL,\n+    0xce968d13UL, 0x0900cc5cUL, 0x4831d745UL, 0x8b62fa6eUL, 0xca53e177UL,\n+    0x545dbbbaUL, 0x156ca0a3UL, 0xd63f8d88UL, 0x970e9691UL, 0x5098d7deUL,\n+    0x11a9ccc7UL, 0xd2fae1ecUL, 0x93cbfaf5UL, 0x5cd76272UL, 0x1de6796bUL,\n+    0xdeb55440UL, 0x9f844f59UL, 0x58120e16UL, 0x1923150fUL, 0xda703824UL,\n+    0x9b41233dUL, 0xa76bfd65UL, 0xe65ae67cUL, 0x2509cb57UL, 0x6438d04eUL,\n+    0xa3ae9101UL, 0xe29f8a18UL, 0x21cca733UL, 0x60fdbc2aUL, 0xafe124adUL,\n+    0xeed03fb4UL, 0x2d83129fUL, 0x6cb20986UL, 0xab2448c9UL, 0xea1553d0UL,\n+    0x29467efbUL, 0x687765e2UL, 0xf6793f2fUL, 0xb7482436UL, 0x741b091dUL,\n+    0x352a1204UL, 0xf2bc534bUL, 0xb38d4852UL, 0x70de6579UL, 0x31ef7e60UL,\n+    0xfef3e6e7UL, 0xbfc2fdfeUL, 0x7c91d0d5UL, 0x3da0cbccUL, 0xfa368a83UL,\n+    0xbb07919aUL, 0x7854bcb1UL, 0x3965a7a8UL, 0x4b98833bUL, 0x0aa99822UL,\n+    0xc9fab509UL, 0x88cbae10UL, 0x4f5def5fUL, 0x0e6cf446UL, 0xcd3fd96dUL,\n+    0x8c0ec274UL, 0x43125af3UL, 0x022341eaUL, 0xc1706cc1UL, 0x804177d8UL,\n+    0x47d73697UL, 0x06e62d8eUL, 0xc5b500a5UL, 0x84841bbcUL, 0x1a8a4171UL,\n+    0x5bbb5a68UL, 0x98e87743UL, 0xd9d96c5aUL, 0x1e4f2d15UL, 0x5f7e360cUL,\n+    0x9c2d1b27UL, 0xdd1c003eUL, 0x120098b9UL, 0x533183a0UL, 0x9062ae8bUL,\n+    0xd153b592UL, 0x16c5f4ddUL, 0x57f4efc4UL, 0x94a7c2efUL, 0xd596d9f6UL,\n+    0xe9bc07aeUL, 0xa88d1cb7UL, 0x6bde319cUL, 0x2aef2a85UL, 0xed796bcaUL,\n+    0xac4870d3UL, 0x6f1b5df8UL, 0x2e2a46e1UL, 0xe136de66UL, 0xa007c57fUL,\n+    0x6354e854UL, 0x2265f34dUL, 0xe5f3b202UL, 0xa4c2a91bUL, 0x67918430UL,\n+    0x26a09f29UL, 0xb8aec5e4UL, 0xf99fdefdUL, 0x3accf3d6UL, 0x7bfde8cfUL,\n+    0xbc6ba980UL, 0xfd5ab299UL, 0x3e099fb2UL, 0x7f3884abUL, 0xb0241c2cUL,\n+    0xf1150735UL, 0x32462a1eUL, 0x73773107UL, 0xb4e17048UL, 0xf5d06b51UL,\n+    0x3683467aUL, 0x77b25d63UL, 0x4ed7facbUL, 0x0fe6e1d2UL, 0xccb5ccf9UL,\n+    0x8d84d7e0UL, 0x4a1296afUL, 0x0b238db6UL, 0xc870a09dUL, 0x8941bb84UL,\n+    0x465d2303UL, 0x076c381aUL, 0xc43f1531UL, 0x850e0e28UL, 0x42984f67UL,\n+    0x03a9547eUL, 0xc0fa7955UL, 0x81cb624cUL, 0x1fc53881UL, 0x5ef42398UL,\n+    0x9da70eb3UL, 0xdc9615aaUL, 0x1b0054e5UL, 0x5a314ffcUL, 0x996262d7UL,\n+    0xd85379ceUL, 0x174fe149UL, 0x567efa50UL, 0x952dd77bUL, 0xd41ccc62UL,\n+    0x138a8d2dUL, 0x52bb9634UL, 0x91e8bb1fUL, 0xd0d9a006UL, 0xecf37e5eUL,\n+    0xadc26547UL, 0x6e91486cUL, 0x2fa05375UL, 0xe836123aUL, 0xa9070923UL,\n+    0x6a542408UL, 0x2b653f11UL, 0xe479a796UL, 0xa548bc8fUL, 0x661b91a4UL,\n+    0x272a8abdUL, 0xe0bccbf2UL, 0xa18dd0ebUL, 0x62defdc0UL, 0x23efe6d9UL,\n+    0xbde1bc14UL, 0xfcd0a70dUL, 0x3f838a26UL, 0x7eb2913fUL, 0xb924d070UL,\n+    0xf815cb69UL, 0x3b46e642UL, 0x7a77fd5bUL, 0xb56b65dcUL, 0xf45a7ec5UL,\n+    0x370953eeUL, 0x763848f7UL, 0xb1ae09b8UL, 0xf09f12a1UL, 0x33cc3f8aUL,\n+    0x72fd2493UL\n+  },\n+  {\n+    0x00000000UL, 0x376ac201UL, 0x6ed48403UL, 0x59be4602UL, 0xdca80907UL,\n+    0xebc2cb06UL, 0xb27c8d04UL, 0x85164f05UL, 0xb851130eUL, 0x8f3bd10fUL,\n+    0xd685970dUL, 0xe1ef550cUL, 0x64f91a09UL, 0x5393d808UL, 0x0a2d9e0aUL,\n+    0x3d475c0bUL, 0x70a3261cUL, 0x47c9e41dUL, 0x1e77a21fUL, 0x291d601eUL,\n+    0xac0b2f1bUL, 0x9b61ed1aUL, 0xc2dfab18UL, 0xf5b56919UL, 0xc8f23512UL,\n+    0xff98f713UL, 0xa626b111UL, 0x914c7310UL, 0x145a3c15UL, 0x2330fe14UL,\n+    0x7a8eb816UL, 0x4de47a17UL, 0xe0464d38UL, 0xd72c8f39UL, 0x8e92c93bUL,\n+    0xb9f80b3aUL, 0x3cee443fUL, 0x0b84863eUL, 0x523ac03cUL, 0x6550023dUL,\n+    0x58175e36UL, 0x6f7d9c37UL, 0x36c3da35UL, 0x01a91834UL, 0x84bf5731UL,\n+    0xb3d59530UL, 0xea6bd332UL, 0xdd011133UL, 0x90e56b24UL, 0xa78fa925UL,\n+    0xfe31ef27UL, 0xc95b2d26UL, 0x4c4d6223UL, 0x7b27a022UL, 0x2299e620UL,\n+    0x15f32421UL, 0x28b4782aUL, 0x1fdeba2bUL, 0x4660fc29UL, 0x710a3e28UL,\n+    0xf41c712dUL, 0xc376b32cUL, 0x9ac8f52eUL, 0xada2372fUL, 0xc08d9a70UL,\n+    0xf7e75871UL, 0xae591e73UL, 0x9933dc72UL, 0x1c259377UL, 0x2b4f5176UL,\n+    0x72f11774UL, 0x459bd575UL, 0x78dc897eUL, 0x4fb64b7fUL, 0x16080d7dUL,\n+    0x2162cf7cUL, 0xa4748079UL, 0x931e4278UL, 0xcaa0047aUL, 0xfdcac67bUL,\n+    0xb02ebc6cUL, 0x87447e6dUL, 0xdefa386fUL, 0xe990fa6eUL, 0x6c86b56bUL,\n+    0x5bec776aUL, 0x02523168UL, 0x3538f369UL, 0x087faf62UL, 0x3f156d63UL,\n+    0x66ab2b61UL, 0x51c1e960UL, 0xd4d7a665UL, 0xe3bd6464UL, 0xba032266UL,\n+    0x8d69e067UL, 0x20cbd748UL, 0x17a11549UL, 0x4e1f534bUL, 0x7975914aUL,\n+    0xfc63de4fUL, 0xcb091c4eUL, 0x92b75a4cUL, 0xa5dd984dUL, 0x989ac446UL,\n+    0xaff00647UL, 0xf64e4045UL, 0xc1248244UL, 0x4432cd41UL, 0x73580f40UL,\n+    0x2ae64942UL, 0x1d8c8b43UL, 0x5068f154UL, 0x67023355UL, 0x3ebc7557UL,\n+    0x09d6b756UL, 0x8cc0f853UL, 0xbbaa3a52UL, 0xe2147c50UL, 0xd57ebe51UL,\n+    0xe839e25aUL, 0xdf53205bUL, 0x86ed6659UL, 0xb187a458UL, 0x3491eb5dUL,\n+    0x03fb295cUL, 0x5a456f5eUL, 0x6d2fad5fUL, 0x801b35e1UL, 0xb771f7e0UL,\n+    0xeecfb1e2UL, 0xd9a573e3UL, 0x5cb33ce6UL, 0x6bd9fee7UL, 0x3267b8e5UL,\n+    0x050d7ae4UL, 0x384a26efUL, 0x0f20e4eeUL, 0x569ea2ecUL, 0x61f460edUL,\n+    0xe4e22fe8UL, 0xd388ede9UL, 0x8a36abebUL, 0xbd5c69eaUL, 0xf0b813fdUL,\n+    0xc7d2d1fcUL, 0x9e6c97feUL, 0xa90655ffUL, 0x2c101afaUL, 0x1b7ad8fbUL,\n+    0x42c49ef9UL, 0x75ae5cf8UL, 0x48e900f3UL, 0x7f83c2f2UL, 0x263d84f0UL,\n+    0x115746f1UL, 0x944109f4UL, 0xa32bcbf5UL, 0xfa958df7UL, 0xcdff4ff6UL,\n+    0x605d78d9UL, 0x5737bad8UL, 0x0e89fcdaUL, 0x39e33edbUL, 0xbcf571deUL,\n+    0x8b9fb3dfUL, 0xd221f5ddUL, 0xe54b37dcUL, 0xd80c6bd7UL, 0xef66a9d6UL,\n+    0xb6d8efd4UL, 0x81b22dd5UL, 0x04a462d0UL, 0x33cea0d1UL, 0x6a70e6d3UL,\n+    0x5d1a24d2UL, 0x10fe5ec5UL, 0x27949cc4UL, 0x7e2adac6UL, 0x494018c7UL,\n+    0xcc5657c2UL, 0xfb3c95c3UL, 0xa282d3c1UL, 0x95e811c0UL, 0xa8af4dcbUL,\n+    0x9fc58fcaUL, 0xc67bc9c8UL, 0xf1110bc9UL, 0x740744ccUL, 0x436d86cdUL,\n+    0x1ad3c0cfUL, 0x2db902ceUL, 0x4096af91UL, 0x77fc6d90UL, 0x2e422b92UL,\n+    0x1928e993UL, 0x9c3ea696UL, 0xab546497UL, 0xf2ea2295UL, 0xc580e094UL,\n+    0xf8c7bc9fUL, 0xcfad7e9eUL, 0x9613389cUL, 0xa179fa9dUL, 0x246fb598UL,\n+    0x13057799UL, 0x4abb319bUL, 0x7dd1f39aUL, 0x3035898dUL, 0x075f4b8cUL,\n+    0x5ee10d8eUL, 0x698bcf8fUL, 0xec9d808aUL, 0xdbf7428bUL, 0x82490489UL,\n+    0xb523c688UL, 0x88649a83UL, 0xbf0e5882UL, 0xe6b01e80UL, 0xd1dadc81UL,\n+    0x54cc9384UL, 0x63a65185UL, 0x3a181787UL, 0x0d72d586UL, 0xa0d0e2a9UL,\n+    0x97ba20a8UL, 0xce0466aaUL, 0xf96ea4abUL, 0x7c78ebaeUL, 0x4b1229afUL,\n+    0x12ac6fadUL, 0x25c6adacUL, 0x1881f1a7UL, 0x2feb33a6UL, 0x765575a4UL,\n+    0x413fb7a5UL, 0xc429f8a0UL, 0xf3433aa1UL, 0xaafd7ca3UL, 0x9d97bea2UL,\n+    0xd073c4b5UL, 0xe71906b4UL, 0xbea740b6UL, 0x89cd82b7UL, 0x0cdbcdb2UL,\n+    0x3bb10fb3UL, 0x620f49b1UL, 0x55658bb0UL, 0x6822d7bbUL, 0x5f4815baUL,\n+    0x06f653b8UL, 0x319c91b9UL, 0xb48adebcUL, 0x83e01cbdUL, 0xda5e5abfUL,\n+    0xed3498beUL\n+  },\n+  {\n+    0x00000000UL, 0x6567bcb8UL, 0x8bc809aaUL, 0xeeafb512UL, 0x5797628fUL,\n+    0x32f0de37UL, 0xdc5f6b25UL, 0xb938d79dUL, 0xef28b4c5UL, 0x8a4f087dUL,\n+    0x64e0bd6fUL, 0x018701d7UL, 0xb8bfd64aUL, 0xddd86af2UL, 0x3377dfe0UL,\n+    0x56106358UL, 0x9f571950UL, 0xfa30a5e8UL, 0x149f10faUL, 0x71f8ac42UL,\n+    0xc8c07bdfUL, 0xada7c767UL, 0x43087275UL, 0x266fcecdUL, 0x707fad95UL,\n+    0x1518112dUL, 0xfbb7a43fUL, 0x9ed01887UL, 0x27e8cf1aUL, 0x428f73a2UL,\n+    0xac20c6b0UL, 0xc9477a08UL, 0x3eaf32a0UL, 0x5bc88e18UL, 0xb5673b0aUL,\n+    0xd00087b2UL, 0x6938502fUL, 0x0c5fec97UL, 0xe2f05985UL, 0x8797e53dUL,\n+    0xd1878665UL, 0xb4e03addUL, 0x5a4f8fcfUL, 0x3f283377UL, 0x8610e4eaUL,\n+    0xe3775852UL, 0x0dd8ed40UL, 0x68bf51f8UL, 0xa1f82bf0UL, 0xc49f9748UL,\n+    0x2a30225aUL, 0x4f579ee2UL, 0xf66f497fUL, 0x9308f5c7UL, 0x7da740d5UL,\n+    0x18c0fc6dUL, 0x4ed09f35UL, 0x2bb7238dUL, 0xc518969fUL, 0xa07f2a27UL,\n+    0x1947fdbaUL, 0x7c204102UL, 0x928ff410UL, 0xf7e848a8UL, 0x3d58149bUL,\n+    0x583fa823UL, 0xb6901d31UL, 0xd3f7a189UL, 0x6acf7614UL, 0x0fa8caacUL,\n+    0xe1077fbeUL, 0x8460c306UL, 0xd270a05eUL, 0xb7171ce6UL, 0x59b8a9f4UL,\n+    0x3cdf154cUL, 0x85e7c2d1UL, 0xe0807e69UL, 0x0e2fcb7bUL, 0x6b4877c3UL,\n+    0xa20f0dcbUL, 0xc768b173UL, 0x29c70461UL, 0x4ca0b8d9UL, 0xf5986f44UL,\n+    0x90ffd3fcUL, 0x7e5066eeUL, 0x1b37da56UL, 0x4d27b90eUL, 0x284005b6UL,\n+    0xc6efb0a4UL, 0xa3880c1cUL, 0x1ab0db81UL, 0x7fd76739UL, 0x9178d22bUL,\n+    0xf41f6e93UL, 0x03f7263bUL, 0x66909a83UL, 0x883f2f91UL, 0xed589329UL,\n+    0x546044b4UL, 0x3107f80cUL, 0xdfa84d1eUL, 0xbacff1a6UL, 0xecdf92feUL,\n+    0x89b82e46UL, 0x67179b54UL, 0x027027ecUL, 0xbb48f071UL, 0xde2f4cc9UL,\n+    0x3080f9dbUL, 0x55e74563UL, 0x9ca03f6bUL, 0xf9c783d3UL, 0x176836c1UL,\n+    0x720f8a79UL, 0xcb375de4UL, 0xae50e15cUL, 0x40ff544eUL, 0x2598e8f6UL,\n+    0x73888baeUL, 0x16ef3716UL, 0xf8408204UL, 0x9d273ebcUL, 0x241fe921UL,\n+    0x41785599UL, 0xafd7e08bUL, 0xcab05c33UL, 0x3bb659edUL, 0x5ed1e555UL,\n+    0xb07e5047UL, 0xd519ecffUL, 0x6c213b62UL, 0x094687daUL, 0xe7e932c8UL,\n+    0x828e8e70UL, 0xd49eed28UL, 0xb1f95190UL, 0x5f56e482UL, 0x3a31583aUL,\n+    0x83098fa7UL, 0xe66e331fUL, 0x08c1860dUL, 0x6da63ab5UL, 0xa4e140bdUL,\n+    0xc186fc05UL, 0x2f294917UL, 0x4a4ef5afUL, 0xf3762232UL, 0x96119e8aUL,\n+    0x78be2b98UL, 0x1dd99720UL, 0x4bc9f478UL, 0x2eae48c0UL, 0xc001fdd2UL,\n+    0xa566416aUL, 0x1c5e96f7UL, 0x79392a4fUL, 0x97969f5dUL, 0xf2f123e5UL,\n+    0x05196b4dUL, 0x607ed7f5UL, 0x8ed162e7UL, 0xebb6de5fUL, 0x528e09c2UL,\n+    0x37e9b57aUL, 0xd9460068UL, 0xbc21bcd0UL, 0xea31df88UL, 0x8f566330UL,\n+    0x61f9d622UL, 0x049e6a9aUL, 0xbda6bd07UL, 0xd8c101bfUL, 0x366eb4adUL,\n+    0x53090815UL, 0x9a4e721dUL, 0xff29cea5UL, 0x11867bb7UL, 0x74e1c70fUL,\n+    0xcdd91092UL, 0xa8beac2aUL, 0x46111938UL, 0x2376a580UL, 0x7566c6d8UL,\n+    0x10017a60UL, 0xfeaecf72UL, 0x9bc973caUL, 0x22f1a457UL, 0x479618efUL,\n+    0xa939adfdUL, 0xcc5e1145UL, 0x06ee4d76UL, 0x6389f1ceUL, 0x8d2644dcUL,\n+    0xe841f864UL, 0x51792ff9UL, 0x341e9341UL, 0xdab12653UL, 0xbfd69aebUL,\n+    0xe9c6f9b3UL, 0x8ca1450bUL, 0x620ef019UL, 0x07694ca1UL, 0xbe519b3cUL,\n+    0xdb362784UL, 0x35999296UL, 0x50fe2e2eUL, 0x99b95426UL, 0xfcdee89eUL,\n+    0x12715d8cUL, 0x7716e134UL, 0xce2e36a9UL, 0xab498a11UL, 0x45e63f03UL,\n+    0x208183bbUL, 0x7691e0e3UL, 0x13f65c5bUL, 0xfd59e949UL, 0x983e55f1UL,\n+    0x2106826cUL, 0x44613ed4UL, 0xaace8bc6UL, 0xcfa9377eUL, 0x38417fd6UL,\n+    0x5d26c36eUL, 0xb389767cUL, 0xd6eecac4UL, 0x6fd61d59UL, 0x0ab1a1e1UL,\n+    0xe41e14f3UL, 0x8179a84bUL, 0xd769cb13UL, 0xb20e77abUL, 0x5ca1c2b9UL,\n+    0x39c67e01UL, 0x80fea99cUL, 0xe5991524UL, 0x0b36a036UL, 0x6e511c8eUL,\n+    0xa7166686UL, 0xc271da3eUL, 0x2cde6f2cUL, 0x49b9d394UL, 0xf0810409UL,\n+    0x95e6b8b1UL, 0x7b490da3UL, 0x1e2eb11bUL, 0x483ed243UL, 0x2d596efbUL,\n+    0xc3f6dbe9UL, 0xa6916751UL, 0x1fa9b0ccUL, 0x7ace0c74UL, 0x9461b966UL,\n+    0xf10605deUL\n+#endif\n+  }\n+};"}, {"sha": "110b03b857f26c3e76793a687ca6d8f55890a1a8", "filename": "zlib/infback.c", "status": "added", "additions": 619, "deletions": 0, "changes": 619, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Finfback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Finfback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finfback.c?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,619 @@\n+/* infback.c -- inflate using a call-back interface\n+ * Copyright (C) 1995-2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ */\n+\n+/*\n+   This code is largely copied from inflate.c.  Normally either infback.o or\n+   inflate.o would be linked into an application--not both.  The interface\n+   with inffast.c is retained so that optimized assembler-coded versions of\n+   inflate_fast() can be used with either inflate.c or infback.c.\n+ */\n+\n+#include \"zutil.h\"\n+#include \"inftrees.h\"\n+#include \"inflate.h\"\n+#include \"inffast.h\"\n+\n+/* function prototypes */\n+local void fixedtables OF((struct inflate_state FAR *state));\n+\n+/*\n+   strm provides memory allocation functions in zalloc and zfree, or\n+   Z_NULL to use the library memory allocation functions.\n+\n+   windowBits is in the range 8..15, and window is a user-supplied\n+   window and output buffer that is 2**windowBits bytes.\n+ */\n+int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)\n+z_stream FAR *strm;\n+int windowBits;\n+unsigned char FAR *window;\n+const char *version;\n+int stream_size;\n+{\n+    struct inflate_state FAR *state;\n+\n+    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||\n+        stream_size != (int)(sizeof(z_stream)))\n+        return Z_VERSION_ERROR;\n+    if (strm == Z_NULL || window == Z_NULL ||\n+        windowBits < 8 || windowBits > 15)\n+        return Z_STREAM_ERROR;\n+    strm->msg = Z_NULL;                 /* in case we return an error */\n+    if (strm->zalloc == (alloc_func)0) {\n+        strm->zalloc = zcalloc;\n+        strm->opaque = (voidpf)0;\n+    }\n+    if (strm->zfree == (free_func)0) strm->zfree = zcfree;\n+    state = (struct inflate_state FAR *)ZALLOC(strm, 1,\n+                                               sizeof(struct inflate_state));\n+    if (state == Z_NULL) return Z_MEM_ERROR;\n+    Tracev((stderr, \"inflate: allocated\\n\"));\n+    strm->state = (voidpf)state;\n+    state->wbits = windowBits;\n+    state->wsize = 1U << windowBits;\n+    state->window = window;\n+    state->write = 0;\n+    state->whave = 0;\n+    return Z_OK;\n+}\n+\n+/*\n+   Return state with length and distance decoding tables and index sizes set to\n+   fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n+   If BUILDFIXED is defined, then instead this routine builds the tables the\n+   first time it's called, and returns those tables the first time and\n+   thereafter.  This reduces the size of the code by about 2K bytes, in\n+   exchange for a little execution time.  However, BUILDFIXED should not be\n+   used for threaded applications, since the rewriting of the tables and virgin\n+   may not be thread-safe.\n+ */\n+local void fixedtables(state)\n+struct inflate_state FAR *state;\n+{\n+#ifdef BUILDFIXED\n+    static int virgin = 1;\n+    static code *lenfix, *distfix;\n+    static code fixed[544];\n+\n+    /* build fixed huffman tables if first call (may not be thread safe) */\n+    if (virgin) {\n+        unsigned sym, bits;\n+        static code *next;\n+\n+        /* literal/length table */\n+        sym = 0;\n+        while (sym < 144) state->lens[sym++] = 8;\n+        while (sym < 256) state->lens[sym++] = 9;\n+        while (sym < 280) state->lens[sym++] = 7;\n+        while (sym < 288) state->lens[sym++] = 8;\n+        next = fixed;\n+        lenfix = next;\n+        bits = 9;\n+        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);\n+\n+        /* distance table */\n+        sym = 0;\n+        while (sym < 32) state->lens[sym++] = 5;\n+        distfix = next;\n+        bits = 5;\n+        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);\n+\n+        /* do this just once */\n+        virgin = 0;\n+    }\n+#else /* !BUILDFIXED */\n+#   include \"inffixed.h\"\n+#endif /* BUILDFIXED */\n+    state->lencode = lenfix;\n+    state->lenbits = 9;\n+    state->distcode = distfix;\n+    state->distbits = 5;\n+}\n+\n+/* Macros for inflateBack(): */\n+\n+/* Load returned state from inflate_fast() */\n+#define LOAD() \\\n+    do { \\\n+        put = strm->next_out; \\\n+        left = strm->avail_out; \\\n+        next = strm->next_in; \\\n+        have = strm->avail_in; \\\n+        hold = state->hold; \\\n+        bits = state->bits; \\\n+    } while (0)\n+\n+/* Set state from registers for inflate_fast() */\n+#define RESTORE() \\\n+    do { \\\n+        strm->next_out = put; \\\n+        strm->avail_out = left; \\\n+        strm->next_in = next; \\\n+        strm->avail_in = have; \\\n+        state->hold = hold; \\\n+        state->bits = bits; \\\n+    } while (0)\n+\n+/* Clear the input bit accumulator */\n+#define INITBITS() \\\n+    do { \\\n+        hold = 0; \\\n+        bits = 0; \\\n+    } while (0)\n+\n+/* Assure that some input is available.  If input is requested, but denied,\n+   then return a Z_BUF_ERROR from inflateBack(). */\n+#define PULL() \\\n+    do { \\\n+        if (have == 0) { \\\n+            have = in(in_desc, &next); \\\n+            if (have == 0) { \\\n+                next = Z_NULL; \\\n+                ret = Z_BUF_ERROR; \\\n+                goto inf_leave; \\\n+            } \\\n+        } \\\n+    } while (0)\n+\n+/* Get a byte of input into the bit accumulator, or return from inflateBack()\n+   with an error if there is no input available. */\n+#define PULLBYTE() \\\n+    do { \\\n+        PULL(); \\\n+        have--; \\\n+        hold += (unsigned long)(*next++) << bits; \\\n+        bits += 8; \\\n+    } while (0)\n+\n+/* Assure that there are at least n bits in the bit accumulator.  If there is\n+   not enough available input to do that, then return from inflateBack() with\n+   an error. */\n+#define NEEDBITS(n) \\\n+    do { \\\n+        while (bits < (unsigned)(n)) \\\n+            PULLBYTE(); \\\n+    } while (0)\n+\n+/* Return the low n bits of the bit accumulator (n < 16) */\n+#define BITS(n) \\\n+    ((unsigned)hold & ((1U << (n)) - 1))\n+\n+/* Remove n bits from the bit accumulator */\n+#define DROPBITS(n) \\\n+    do { \\\n+        hold >>= (n); \\\n+        bits -= (unsigned)(n); \\\n+    } while (0)\n+\n+/* Remove zero to seven bits as needed to go to a byte boundary */\n+#define BYTEBITS() \\\n+    do { \\\n+        hold >>= bits & 7; \\\n+        bits -= bits & 7; \\\n+    } while (0)\n+\n+/* Assure that some output space is available, by writing out the window\n+   if it's full.  If the write fails, return from inflateBack() with a\n+   Z_BUF_ERROR. */\n+#define ROOM() \\\n+    do { \\\n+        if (left == 0) { \\\n+            put = state->window; \\\n+            left = state->wsize; \\\n+            state->whave = left; \\\n+            if (out(out_desc, put, left)) { \\\n+                ret = Z_BUF_ERROR; \\\n+                goto inf_leave; \\\n+            } \\\n+        } \\\n+    } while (0)\n+\n+/*\n+   strm provides the memory allocation functions and window buffer on input,\n+   and provides information on the unused input on return.  For Z_DATA_ERROR\n+   returns, strm will also provide an error message.\n+\n+   in() and out() are the call-back input and output functions.  When\n+   inflateBack() needs more input, it calls in().  When inflateBack() has\n+   filled the window with output, or when it completes with data in the\n+   window, it calls out() to write out the data.  The application must not\n+   change the provided input until in() is called again or inflateBack()\n+   returns.  The application must not change the window/output buffer until\n+   inflateBack() returns.\n+\n+   in() and out() are called with a descriptor parameter provided in the\n+   inflateBack() call.  This parameter can be a structure that provides the\n+   information required to do the read or write, as well as accumulated\n+   information on the input and output such as totals and check values.\n+\n+   in() should return zero on failure.  out() should return non-zero on\n+   failure.  If either in() or out() fails, than inflateBack() returns a\n+   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it\n+   was in() or out() that caused in the error.  Otherwise,  inflateBack()\n+   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format\n+   error, or Z_MEM_ERROR if it could not allocate memory for the state.\n+   inflateBack() can also return Z_STREAM_ERROR if the input parameters\n+   are not correct, i.e. strm is Z_NULL or the state was not initialized.\n+ */\n+int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)\n+z_stream FAR *strm;\n+in_func in;\n+void FAR *in_desc;\n+out_func out;\n+void FAR *out_desc;\n+{\n+    struct inflate_state FAR *state;\n+    unsigned char FAR *next;    /* next input */\n+    unsigned char FAR *put;     /* next output */\n+    unsigned have, left;        /* available input and output */\n+    unsigned long hold;         /* bit buffer */\n+    unsigned bits;              /* bits in bit buffer */\n+    unsigned copy;              /* number of stored or match bytes to copy */\n+    unsigned char FAR *from;    /* where to copy match bytes from */\n+    code this;                  /* current decoding table entry */\n+    code last;                  /* parent table entry */\n+    unsigned len;               /* length to copy for repeats, bits to drop */\n+    int ret;                    /* return code */\n+    static const unsigned short order[19] = /* permutation of code lengths */\n+        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n+\n+    /* Check that the strm exists and that the state was initialized */\n+    if (strm == Z_NULL || strm->state == Z_NULL)\n+        return Z_STREAM_ERROR;\n+    state = (struct inflate_state FAR *)strm->state;\n+\n+    /* Reset the state */\n+    strm->msg = Z_NULL;\n+    state->mode = TYPE;\n+    state->last = 0;\n+    state->whave = 0;\n+    next = strm->next_in;\n+    have = next != Z_NULL ? strm->avail_in : 0;\n+    hold = 0;\n+    bits = 0;\n+    put = state->window;\n+    left = state->wsize;\n+\n+    /* Inflate until end of block marked as last */\n+    for (;;)\n+        switch (state->mode) {\n+        case TYPE:\n+            /* determine and dispatch block type */\n+            if (state->last) {\n+                BYTEBITS();\n+                state->mode = DONE;\n+                break;\n+            }\n+            NEEDBITS(3);\n+            state->last = BITS(1);\n+            DROPBITS(1);\n+            switch (BITS(2)) {\n+            case 0:                             /* stored block */\n+                Tracev((stderr, \"inflate:     stored block%s\\n\",\n+                        state->last ? \" (last)\" : \"\"));\n+                state->mode = STORED;\n+                break;\n+            case 1:                             /* fixed block */\n+                fixedtables(state);\n+                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n+                        state->last ? \" (last)\" : \"\"));\n+                state->mode = LEN;              /* decode codes */\n+                break;\n+            case 2:                             /* dynamic block */\n+                Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n+                        state->last ? \" (last)\" : \"\"));\n+                state->mode = TABLE;\n+                break;\n+            case 3:\n+                strm->msg = (char *)\"invalid block type\";\n+                state->mode = BAD;\n+            }\n+            DROPBITS(2);\n+            break;\n+\n+        case STORED:\n+            /* get and verify stored block length */\n+            BYTEBITS();                         /* go to byte boundary */\n+            NEEDBITS(32);\n+            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n+                strm->msg = (char *)\"invalid stored block lengths\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            state->length = (unsigned)hold & 0xffff;\n+            Tracev((stderr, \"inflate:       stored length %u\\n\",\n+                    state->length));\n+            INITBITS();\n+\n+            /* copy stored block from input to output */\n+            while (state->length != 0) {\n+                copy = state->length;\n+                PULL();\n+                ROOM();\n+                if (copy > have) copy = have;\n+                if (copy > left) copy = left;\n+                zmemcpy(put, next, copy);\n+                have -= copy;\n+                next += copy;\n+                left -= copy;\n+                put += copy;\n+                state->length -= copy;\n+            }\n+            Tracev((stderr, \"inflate:       stored end\\n\"));\n+            state->mode = TYPE;\n+            break;\n+\n+        case TABLE:\n+            /* get dynamic table entries descriptor */\n+            NEEDBITS(14);\n+            state->nlen = BITS(5) + 257;\n+            DROPBITS(5);\n+            state->ndist = BITS(5) + 1;\n+            DROPBITS(5);\n+            state->ncode = BITS(4) + 4;\n+            DROPBITS(4);\n+#ifndef PKZIP_BUG_WORKAROUND\n+            if (state->nlen > 286 || state->ndist > 30) {\n+                strm->msg = (char *)\"too many length or distance symbols\";\n+                state->mode = BAD;\n+                break;\n+            }\n+#endif\n+            Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n+\n+            /* get code length code lengths (not a typo) */\n+            state->have = 0;\n+            while (state->have < state->ncode) {\n+                NEEDBITS(3);\n+                state->lens[order[state->have++]] = (unsigned short)BITS(3);\n+                DROPBITS(3);\n+            }\n+            while (state->have < 19)\n+                state->lens[order[state->have++]] = 0;\n+            state->next = state->codes;\n+            state->lencode = (code const FAR *)(state->next);\n+            state->lenbits = 7;\n+            ret = inflate_table(CODES, state->lens, 19, &(state->next),\n+                                &(state->lenbits), state->work);\n+            if (ret) {\n+                strm->msg = (char *)\"invalid code lengths set\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n+\n+            /* get length and distance code code lengths */\n+            state->have = 0;\n+            while (state->have < state->nlen + state->ndist) {\n+                for (;;) {\n+                    this = state->lencode[BITS(state->lenbits)];\n+                    if ((unsigned)(this.bits) <= bits) break;\n+                    PULLBYTE();\n+                }\n+                if (this.val < 16) {\n+                    NEEDBITS(this.bits);\n+                    DROPBITS(this.bits);\n+                    state->lens[state->have++] = this.val;\n+                }\n+                else {\n+                    if (this.val == 16) {\n+                        NEEDBITS(this.bits + 2);\n+                        DROPBITS(this.bits);\n+                        if (state->have == 0) {\n+                            strm->msg = (char *)\"invalid bit length repeat\";\n+                            state->mode = BAD;\n+                            break;\n+                        }\n+                        len = (unsigned)(state->lens[state->have - 1]);\n+                        copy = 3 + BITS(2);\n+                        DROPBITS(2);\n+                    }\n+                    else if (this.val == 17) {\n+                        NEEDBITS(this.bits + 3);\n+                        DROPBITS(this.bits);\n+                        len = 0;\n+                        copy = 3 + BITS(3);\n+                        DROPBITS(3);\n+                    }\n+                    else {\n+                        NEEDBITS(this.bits + 7);\n+                        DROPBITS(this.bits);\n+                        len = 0;\n+                        copy = 11 + BITS(7);\n+                        DROPBITS(7);\n+                    }\n+                    if (state->have + copy > state->nlen + state->ndist) {\n+                        strm->msg = (char *)\"invalid bit length repeat\";\n+                        state->mode = BAD;\n+                        break;\n+                    }\n+                    while (copy--)\n+                        state->lens[state->have++] = (unsigned short)len;\n+                }\n+            }\n+\n+            /* build code tables */\n+            state->next = state->codes;\n+            state->lencode = (code const FAR *)(state->next);\n+            state->lenbits = 9;\n+            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n+                                &(state->lenbits), state->work);\n+            if (ret) {\n+                strm->msg = (char *)\"invalid literal/lengths set\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            state->distcode = (code const FAR *)(state->next);\n+            state->distbits = 6;\n+            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n+                            &(state->next), &(state->distbits), state->work);\n+            if (ret) {\n+                strm->msg = (char *)\"invalid distances set\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            Tracev((stderr, \"inflate:       codes ok\\n\"));\n+            state->mode = LEN;\n+\n+        case LEN:\n+            /* use inflate_fast() if we have enough input and output */\n+            if (have >= 6 && left >= 258) {\n+                RESTORE();\n+                if (state->whave < state->wsize)\n+                    state->whave = state->wsize - left;\n+                inflate_fast(strm, state->wsize);\n+                LOAD();\n+                break;\n+            }\n+\n+            /* get a literal, length, or end-of-block code */\n+            for (;;) {\n+                this = state->lencode[BITS(state->lenbits)];\n+                if ((unsigned)(this.bits) <= bits) break;\n+                PULLBYTE();\n+            }\n+            if (this.op && (this.op & 0xf0) == 0) {\n+                last = this;\n+                for (;;) {\n+                    this = state->lencode[last.val +\n+                            (BITS(last.bits + last.op) >> last.bits)];\n+                    if ((unsigned)(last.bits + this.bits) <= bits) break;\n+                    PULLBYTE();\n+                }\n+                DROPBITS(last.bits);\n+            }\n+            DROPBITS(this.bits);\n+            state->length = (unsigned)this.val;\n+\n+            /* process literal */\n+            if (this.op == 0) {\n+                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?\n+                        \"inflate:         literal '%c'\\n\" :\n+                        \"inflate:         literal 0x%02x\\n\", this.val));\n+                ROOM();\n+                *put++ = (unsigned char)(state->length);\n+                left--;\n+                state->mode = LEN;\n+                break;\n+            }\n+\n+            /* process end of block */\n+            if (this.op & 32) {\n+                Tracevv((stderr, \"inflate:         end of block\\n\"));\n+                state->mode = TYPE;\n+                break;\n+            }\n+\n+            /* invalid code */\n+            if (this.op & 64) {\n+                strm->msg = (char *)\"invalid literal/length code\";\n+                state->mode = BAD;\n+                break;\n+            }\n+\n+            /* length code -- get extra bits, if any */\n+            state->extra = (unsigned)(this.op) & 15;\n+            if (state->extra != 0) {\n+                NEEDBITS(state->extra);\n+                state->length += BITS(state->extra);\n+                DROPBITS(state->extra);\n+            }\n+            Tracevv((stderr, \"inflate:         length %u\\n\", state->length));\n+\n+            /* get distance code */\n+            for (;;) {\n+                this = state->distcode[BITS(state->distbits)];\n+                if ((unsigned)(this.bits) <= bits) break;\n+                PULLBYTE();\n+            }\n+            if ((this.op & 0xf0) == 0) {\n+                last = this;\n+                for (;;) {\n+                    this = state->distcode[last.val +\n+                            (BITS(last.bits + last.op) >> last.bits)];\n+                    if ((unsigned)(last.bits + this.bits) <= bits) break;\n+                    PULLBYTE();\n+                }\n+                DROPBITS(last.bits);\n+            }\n+            DROPBITS(this.bits);\n+            if (this.op & 64) {\n+                strm->msg = (char *)\"invalid distance code\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            state->offset = (unsigned)this.val;\n+\n+            /* get distance extra bits, if any */\n+            state->extra = (unsigned)(this.op) & 15;\n+            if (state->extra != 0) {\n+                NEEDBITS(state->extra);\n+                state->offset += BITS(state->extra);\n+                DROPBITS(state->extra);\n+            }\n+            if (state->offset > state->wsize - (state->whave < state->wsize ?\n+                                                left : 0)) {\n+                strm->msg = (char *)\"invalid distance too far back\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            Tracevv((stderr, \"inflate:         distance %u\\n\", state->offset));\n+\n+            /* copy match from window to output */\n+            do {\n+                ROOM();\n+                copy = state->wsize - state->offset;\n+                if (copy < left) {\n+                    from = put + copy;\n+                    copy = left - copy;\n+                }\n+                else {\n+                    from = put - state->offset;\n+                    copy = left;\n+                }\n+                if (copy > state->length) copy = state->length;\n+                state->length -= copy;\n+                left -= copy;\n+                do {\n+                    *put++ = *from++;\n+                } while (--copy);\n+            } while (state->length != 0);\n+            break;\n+\n+        case DONE:\n+            /* inflate stream terminated properly -- write leftover output */\n+            ret = Z_STREAM_END;\n+            if (left < state->wsize) {\n+                if (out(out_desc, state->window, state->wsize - left))\n+                    ret = Z_BUF_ERROR;\n+            }\n+            goto inf_leave;\n+\n+        case BAD:\n+            ret = Z_DATA_ERROR;\n+            goto inf_leave;\n+\n+        default:                /* can't happen, but makes compilers happy */\n+            ret = Z_STREAM_ERROR;\n+            goto inf_leave;\n+        }\n+\n+    /* Return unused input */\n+  inf_leave:\n+    strm->next_in = next;\n+    strm->avail_in = have;\n+    return ret;\n+}\n+\n+int ZEXPORT inflateBackEnd(strm)\n+z_stream FAR *strm;\n+{\n+    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)\n+        return Z_STREAM_ERROR;\n+    ZFREE(strm, strm->state);\n+    strm->state = Z_NULL;\n+    Tracev((stderr, \"inflate: end\\n\"));\n+    return Z_OK;\n+}"}, {"sha": "9a12c8fd2963bfa45e884077679c706e1f6a2ab7", "filename": "zlib/inflate.h", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Finflate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Finflate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finflate.h?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,117 @@\n+/* inflate.h -- internal inflate state definition\n+ * Copyright (C) 1995-2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ */\n+\n+/* WARNING: this file should *not* be used by applications. It is\n+   part of the implementation of the compression library and is\n+   subject to change. Applications should only use zlib.h.\n+ */\n+\n+/* define NO_GZIP when compiling if you want to disable gzip header and\n+   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in\n+   the crc code when it is not needed.  For shared libraries, gzip decoding\n+   should be left enabled. */\n+#ifndef NO_GZIP\n+#  define GUNZIP\n+#endif\n+\n+/* Possible inflate modes between inflate() calls */\n+typedef enum {\n+    HEAD,       /* i: waiting for magic header */\n+#ifdef GUNZIP\n+    FLAGS,      /* i: waiting for method and flags (gzip) */\n+    TIME,       /* i: waiting for modification time (gzip) */\n+    OS,         /* i: waiting for extra flags and operating system (gzip) */\n+    EXLEN,      /* i: waiting for extra length (gzip) */\n+    EXTRA,      /* i: waiting for extra bytes (gzip) */\n+    NAME,       /* i: waiting for end of file name (gzip) */\n+    COMMENT,    /* i: waiting for end of comment (gzip) */\n+    HCRC,       /* i: waiting for header crc (gzip) */\n+#endif\n+    DICTID,     /* i: waiting for dictionary check value */\n+    DICT,       /* waiting for inflateSetDictionary() call */\n+        TYPE,       /* i: waiting for type bits, including last-flag bit */\n+        TYPEDO,     /* i: same, but skip check to exit inflate on new block */\n+        STORED,     /* i: waiting for stored size (length and complement) */\n+        COPY,       /* i/o: waiting for input or output to copy stored block */\n+        TABLE,      /* i: waiting for dynamic block table lengths */\n+        LENLENS,    /* i: waiting for code length code lengths */\n+        CODELENS,   /* i: waiting for length/lit and distance code lengths */\n+            LEN,        /* i: waiting for length/lit code */\n+            LENEXT,     /* i: waiting for length extra bits */\n+            DIST,       /* i: waiting for distance code */\n+            DISTEXT,    /* i: waiting for distance extra bits */\n+            MATCH,      /* o: waiting for output space to copy string */\n+            LIT,        /* o: waiting for output space to write literal */\n+    CHECK,      /* i: waiting for 32-bit check value */\n+#ifdef GUNZIP\n+    LENGTH,     /* i: waiting for 32-bit length (gzip) */\n+#endif\n+    DONE,       /* finished check, done -- remain here until reset */\n+    BAD,        /* got a data error -- remain here until reset */\n+    MEM,        /* got an inflate() memory error -- remain here until reset */\n+    SYNC        /* looking for synchronization bytes to restart inflate() */\n+} inflate_mode;\n+\n+/*\n+    State transitions between above modes -\n+\n+    (most modes can go to the BAD or MEM mode -- not shown for clarity)\n+\n+    Process header:\n+        HEAD -> (gzip) or (zlib)\n+        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME\n+        NAME -> COMMENT -> HCRC -> TYPE\n+        (zlib) -> DICTID or TYPE\n+        DICTID -> DICT -> TYPE\n+    Read deflate blocks:\n+            TYPE -> STORED or TABLE or LEN or CHECK\n+            STORED -> COPY -> TYPE\n+            TABLE -> LENLENS -> CODELENS -> LEN\n+    Read deflate codes:\n+                LEN -> LENEXT or LIT or TYPE\n+                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN\n+                LIT -> LEN\n+    Process trailer:\n+        CHECK -> LENGTH -> DONE\n+ */\n+\n+/* state maintained between inflate() calls.  Approximately 7K bytes. */\n+struct inflate_state {\n+    inflate_mode mode;          /* current inflate mode */\n+    int last;                   /* true if processing last block */\n+    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip */\n+    int havedict;               /* true if dictionary provided */\n+    int flags;                  /* gzip header method and flags (0 if zlib) */\n+    unsigned long check;        /* protected copy of check value */\n+    unsigned long total;        /* protected copy of output count */\n+        /* sliding window */\n+    unsigned wbits;             /* log base 2 of requested window size */\n+    unsigned wsize;             /* window size or zero if not using window */\n+    unsigned whave;             /* valid bytes in the window */\n+    unsigned write;             /* window write index */\n+    unsigned char FAR *window;  /* allocated sliding window, if needed */\n+        /* bit accumulator */\n+    unsigned long hold;         /* input bit accumulator */\n+    unsigned bits;              /* number of bits in \"in\" */\n+        /* for string and stored block copying */\n+    unsigned length;            /* literal or length of data to copy */\n+    unsigned offset;            /* distance back to copy string from */\n+        /* for table and code decoding */\n+    unsigned extra;             /* extra bits needed */\n+        /* fixed and dynamic code tables */\n+    code const FAR *lencode;    /* starting table for length/literal codes */\n+    code const FAR *distcode;   /* starting table for distance codes */\n+    unsigned lenbits;           /* index bits for lencode */\n+    unsigned distbits;          /* index bits for distcode */\n+        /* dynamic table building */\n+    unsigned ncode;             /* number of code length code lengths */\n+    unsigned nlen;              /* number of length code lengths */\n+    unsigned ndist;             /* number of distance code lengths */\n+    unsigned have;              /* number of code lengths in lens[] */\n+    code FAR *next;             /* next available space in codes[] */\n+    unsigned short lens[320];   /* temporary storage for code lengths */\n+    unsigned short work[288];   /* work area for code table building */\n+    code codes[ENOUGH];         /* space for code tables */\n+};"}, {"sha": "4fe301303f00db1b02e72b02d0473b0c7e4c4292", "filename": "zlib/old/Make_vms.com", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fold%2FMake_vms.com", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fold%2FMake_vms.com", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2FMake_vms.com?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,115 @@\n+$! make libz under VMS\n+$! written by Martin P.J. Zinser <m.zinser@gsi.de>\n+$!\n+$! Look for the compiler used\n+$!\n+$ ccopt = \"\"\n+$ if f$getsyi(\"HW_MODEL\").ge.1024\n+$ then\n+$  ccopt = \"/prefix=all\"+ccopt\n+$  comp  = \"__decc__=1\"\n+$  if f$trnlnm(\"SYS\").eqs.\"\" then define sys sys$library:\n+$ else\n+$  if f$search(\"SYS$SYSTEM:DECC$COMPILER.EXE\").eqs.\"\"\n+$   then\n+$    comp  = \"__vaxc__=1\"\n+$    if f$trnlnm(\"SYS\").eqs.\"\" then define sys sys$library:\n+$   else\n+$    if f$trnlnm(\"SYS\").eqs.\"\" then define sys decc$library_include:\n+$    ccopt = \"/decc/prefix=all\"+ccopt\n+$    comp  = \"__decc__=1\"\n+$  endif\n+$ endif\n+$!\n+$! Build the thing plain or with mms\n+$!\n+$ write sys$output \"Compiling Zlib sources ...\"\n+$ if f$search(\"SYS$SYSTEM:MMS.EXE\").eqs.\"\"\n+$  then\n+$   dele example.obj;*,minigzip.obj;*\n+$   CALL MAKE adler32.OBJ \"CC ''CCOPT' adler32\" -\n+                adler32.c zlib.h zconf.h\n+$   CALL MAKE compress.OBJ \"CC ''CCOPT' compress\" -\n+                compress.c zlib.h zconf.h\n+$   CALL MAKE crc32.OBJ \"CC ''CCOPT' crc32\" -\n+                crc32.c zlib.h zconf.h\n+$   CALL MAKE deflate.OBJ \"CC ''CCOPT' deflate\" -\n+                deflate.c deflate.h zutil.h zlib.h zconf.h\n+$   CALL MAKE gzio.OBJ \"CC ''CCOPT' gzio\" -\n+                gzio.c zutil.h zlib.h zconf.h\n+$   CALL MAKE infblock.OBJ \"CC ''CCOPT' infblock\" -\n+                infblock.c zutil.h zlib.h zconf.h infblock.h\n+$   CALL MAKE infcodes.OBJ \"CC ''CCOPT' infcodes\" -\n+                infcodes.c zutil.h zlib.h zconf.h inftrees.h\n+$   CALL MAKE inffast.OBJ \"CC ''CCOPT' inffast\" -\n+                inffast.c zutil.h zlib.h zconf.h inffast.h\n+$   CALL MAKE inflate.OBJ \"CC ''CCOPT' inflate\" -\n+                inflate.c zutil.h zlib.h zconf.h infblock.h\n+$   CALL MAKE inftrees.OBJ \"CC ''CCOPT' inftrees\" -\n+                inftrees.c zutil.h zlib.h zconf.h inftrees.h\n+$   CALL MAKE infutil.OBJ \"CC ''CCOPT' infutil\" -\n+                infutil.c zutil.h zlib.h zconf.h inftrees.h infutil.h\n+$   CALL MAKE trees.OBJ \"CC ''CCOPT' trees\" -\n+                trees.c deflate.h zutil.h zlib.h zconf.h\n+$   CALL MAKE uncompr.OBJ \"CC ''CCOPT' uncompr\" -\n+                uncompr.c zlib.h zconf.h\n+$   CALL MAKE zutil.OBJ \"CC ''CCOPT' zutil\" -\n+                zutil.c zutil.h zlib.h zconf.h\n+$   write sys$output \"Building Zlib ...\"\n+$   CALL MAKE libz.OLB \"lib/crea libz.olb *.obj\" *.OBJ\n+$   write sys$output \"Building example...\"\n+$   CALL MAKE example.OBJ \"CC ''CCOPT' example\" -\n+                example.c zlib.h zconf.h\n+$   call make example.exe \"LINK example,libz.olb/lib\" example.obj libz.olb\n+$   write sys$output \"Building minigzip...\"\n+$   CALL MAKE minigzip.OBJ \"CC ''CCOPT' minigzip\" -\n+                minigzip.c zlib.h zconf.h\n+$   call make minigzip.exe -\n+                \"LINK minigzip,libz.olb/lib,x11vms:xvmsutils.olb/lib\" -\n+                minigzip.obj libz.olb\n+$  else\n+$   mms/macro=('comp')\n+$  endif\n+$ write sys$output \"Zlib build completed\"\n+$ exit\n+$!\n+$!\n+$MAKE: SUBROUTINE   !SUBROUTINE TO CHECK DEPENDENCIES\n+$ V = 'F$Verify(0)\n+$! P1 = What we are trying to make\n+$! P2 = Command to make it\n+$! P3 - P8  What it depends on\n+$\n+$ If F$Search(P1) .Eqs. \"\" Then Goto Makeit\n+$ Time = F$CvTime(F$File(P1,\"RDT\"))\n+$arg=3\n+$Loop:\n+$       Argument = P'arg\n+$       If Argument .Eqs. \"\" Then Goto Exit\n+$       El=0\n+$Loop2:\n+$       File = F$Element(El,\" \",Argument)\n+$       If File .Eqs. \" \" Then Goto Endl\n+$       AFile = \"\"\n+$Loop3:\n+$       OFile = AFile\n+$       AFile = F$Search(File)\n+$       If AFile .Eqs. \"\" .Or. AFile .Eqs. OFile Then Goto NextEl\n+$       If F$CvTime(F$File(AFile,\"RDT\")) .Ges. Time Then Goto Makeit\n+$       Goto Loop3\n+$NextEL:\n+$       El = El + 1\n+$       Goto Loop2\n+$EndL:\n+$ arg=arg+1\n+$ If arg .Le. 8 Then Goto Loop\n+$ Goto Exit\n+$\n+$Makeit:\n+$ VV=F$VERIFY(0)\n+$ write sys$output P2\n+$ 'P2\n+$ VV='F$Verify(VV)\n+$Exit:\n+$ If V Then Set Verify\n+$ENDSUBROUTINE"}, {"sha": "d97f4492370f1be65002d26866c2312937730a67", "filename": "zlib/old/Makefile.riscos", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fold%2FMakefile.riscos", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fold%2FMakefile.riscos", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2FMakefile.riscos?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,151 @@\n+# Project:   zlib_1_03\n+# Patched for zlib 1.1.2 rw@shadow.org.uk 19980430\n+# test works out-of-the-box, installs `somewhere' on demand\n+\n+# Toolflags:\n+CCflags = -c -depend !Depend -IC: -g -throwback  -DRISCOS  -fah \n+C++flags = -c -depend !Depend -IC: -throwback\n+Linkflags = -aif -c++ -o $@ \n+ObjAsmflags = -throwback -NoCache -depend !Depend\n+CMHGflags = \n+LibFileflags = -c -l -o $@ \n+Squeezeflags = -o $@\n+\n+# change the line below to where _you_ want the library installed.\n+libdest = lib:zlib\n+\n+# Final targets:\n+@.lib:   @.o.adler32 @.o.compress @.o.crc32 @.o.deflate @.o.gzio \\\n+        @.o.infblock @.o.infcodes @.o.inffast @.o.inflate @.o.inftrees @.o.infutil @.o.trees \\\n+        @.o.uncompr @.o.zutil \n+        LibFile $(LibFileflags) @.o.adler32 @.o.compress @.o.crc32 @.o.deflate \\\n+        @.o.gzio @.o.infblock @.o.infcodes @.o.inffast @.o.inflate @.o.inftrees @.o.infutil \\\n+        @.o.trees @.o.uncompr @.o.zutil \n+test:   @.minigzip @.example @.lib\n+\t@copy @.lib @.libc  A~C~DF~L~N~P~Q~RS~TV\n+\t@echo running tests: hang on.\n+\t@/@.minigzip -f -9 libc\n+\t@/@.minigzip -d libc-gz\n+\t@/@.minigzip -f -1 libc\n+\t@/@.minigzip -d libc-gz\n+\t@/@.minigzip -h -9 libc\n+\t@/@.minigzip -d libc-gz\n+\t@/@.minigzip -h -1 libc\n+\t@/@.minigzip -d libc-gz\n+\t@/@.minigzip -9 libc\n+\t@/@.minigzip -d libc-gz\n+\t@/@.minigzip -1 libc\n+\t@/@.minigzip -d libc-gz\n+\t@diff @.lib @.libc\n+\t@echo that should have reported '@.lib and @.libc identical' if you have diff.\n+\t@/@.example @.fred @.fred\n+\t@echo that will have given lots of hello!'s.\n+\n+@.minigzip:   @.o.minigzip @.lib C:o.Stubs \n+        Link $(Linkflags) @.o.minigzip @.lib C:o.Stubs \n+@.example:   @.o.example @.lib C:o.Stubs \n+        Link $(Linkflags) @.o.example @.lib C:o.Stubs\n+\n+install: @.lib\n+\tcdir $(libdest)\n+\tcdir $(libdest).h\n+\t@copy @.h.zlib $(libdest).h.zlib A~C~DF~L~N~P~Q~RS~TV\n+\t@copy @.h.zconf $(libdest).h.zconf A~C~DF~L~N~P~Q~RS~TV\n+\t@copy @.lib $(libdest).lib  A~C~DF~L~N~P~Q~RS~TV\n+\t@echo okay, installed zlib in $(libdest)\n+\n+clean:; remove @.minigzip\n+\tremove @.example\n+\tremove @.libc\n+\t-wipe @.o.* F~r~cV\n+\tremove @.fred\n+\n+# User-editable dependencies:\n+.c.o:\n+        cc $(ccflags) -o $@ $<\n+\n+# Static dependencies:\n+\n+# Dynamic dependencies:\n+o.example:\tc.example\n+o.example:\th.zlib\n+o.example:\th.zconf\n+o.minigzip:\tc.minigzip\n+o.minigzip:\th.zlib\n+o.minigzip:\th.zconf\n+o.adler32:\tc.adler32\n+o.adler32:\th.zlib\n+o.adler32:\th.zconf\n+o.compress:\tc.compress\n+o.compress:\th.zlib\n+o.compress:\th.zconf\n+o.crc32:\tc.crc32\n+o.crc32:\th.zlib\n+o.crc32:\th.zconf\n+o.deflate:\tc.deflate\n+o.deflate:\th.deflate\n+o.deflate:\th.zutil\n+o.deflate:\th.zlib\n+o.deflate:\th.zconf\n+o.gzio:\tc.gzio\n+o.gzio:\th.zutil\n+o.gzio:\th.zlib\n+o.gzio:\th.zconf\n+o.infblock:\tc.infblock\n+o.infblock:\th.zutil\n+o.infblock:\th.zlib\n+o.infblock:\th.zconf\n+o.infblock:\th.infblock\n+o.infblock:\th.inftrees\n+o.infblock:\th.infcodes\n+o.infblock:\th.infutil\n+o.infcodes:\tc.infcodes\n+o.infcodes:\th.zutil\n+o.infcodes:\th.zlib\n+o.infcodes:\th.zconf\n+o.infcodes:\th.inftrees\n+o.infcodes:\th.infblock\n+o.infcodes:\th.infcodes\n+o.infcodes:\th.infutil\n+o.infcodes:\th.inffast\n+o.inffast:\tc.inffast\n+o.inffast:\th.zutil\n+o.inffast:\th.zlib\n+o.inffast:\th.zconf\n+o.inffast:\th.inftrees\n+o.inffast:\th.infblock\n+o.inffast:\th.infcodes\n+o.inffast:\th.infutil\n+o.inffast:\th.inffast\n+o.inflate:\tc.inflate\n+o.inflate:\th.zutil\n+o.inflate:\th.zlib\n+o.inflate:\th.zconf\n+o.inflate:\th.infblock\n+o.inftrees:\tc.inftrees\n+o.inftrees:\th.zutil\n+o.inftrees:\th.zlib\n+o.inftrees:\th.zconf\n+o.inftrees:\th.inftrees\n+o.inftrees:\th.inffixed\n+o.infutil:\tc.infutil\n+o.infutil:\th.zutil\n+o.infutil:\th.zlib\n+o.infutil:\th.zconf\n+o.infutil:\th.infblock\n+o.infutil:\th.inftrees\n+o.infutil:\th.infcodes\n+o.infutil:\th.infutil\n+o.trees:\tc.trees\n+o.trees:\th.deflate\n+o.trees:\th.zutil\n+o.trees:\th.zlib\n+o.trees:\th.zconf\n+o.trees:\th.trees\n+o.uncompr:\tc.uncompr\n+o.uncompr:\th.zlib\n+o.uncompr:\th.zconf\n+o.zutil:\tc.zutil\n+o.zutil:\th.zutil\n+o.zutil:\th.zlib\n+o.zutil:\th.zconf"}, {"sha": "06ebe3d13f82b2b2be09a39e72d0121b89306d4f", "filename": "zlib/old/README", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fold%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fold%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2FREADME?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,3 @@\n+This directory contains files that have not been updated for zlib 1.2.1\n+\n+(Volunteers are encouraged to help clean this up.  Thanks.)"}, {"sha": "7066da5b557e896d8a6c1285fb191af7bd7914bb", "filename": "zlib/old/descrip.mms", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fold%2Fdescrip.mms", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fold%2Fdescrip.mms", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2Fdescrip.mms?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,48 @@\n+# descrip.mms: MMS description file for building zlib on VMS\n+# written by Martin P.J. Zinser <m.zinser@gsi.de>\n+\n+cc_defs =\n+c_deb =\n+\n+.ifdef __DECC__\n+pref = /prefix=all\n+.endif\n+\n+OBJS = adler32.obj, compress.obj, crc32.obj, gzio.obj, uncompr.obj,\\\n+       deflate.obj, trees.obj, zutil.obj, inflate.obj, infblock.obj,\\\n+       inftrees.obj, infcodes.obj, infutil.obj, inffast.obj\n+\n+CFLAGS= $(C_DEB) $(CC_DEFS) $(PREF)\n+\n+all : example.exe minigzip.exe\n+        @ write sys$output \" Example applications available\"\n+libz.olb : libz.olb($(OBJS))\n+\t@ write sys$output \" libz available\"\n+\n+example.exe : example.obj libz.olb\n+              link example,libz.olb/lib\n+\n+minigzip.exe : minigzip.obj libz.olb\n+              link minigzip,libz.olb/lib,x11vms:xvmsutils.olb/lib\n+\n+clean :\n+\tdelete *.obj;*,libz.olb;*\n+\n+\n+# Other dependencies.\n+adler32.obj : zutil.h zlib.h zconf.h\n+compress.obj : zlib.h zconf.h\n+crc32.obj : zutil.h zlib.h zconf.h\n+deflate.obj : deflate.h zutil.h zlib.h zconf.h\n+example.obj : zlib.h zconf.h\n+gzio.obj : zutil.h zlib.h zconf.h\n+infblock.obj : zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h\n+infcodes.obj : zutil.h zlib.h zconf.h inftrees.h infutil.h infcodes.h inffast.h\n+inffast.obj : zutil.h zlib.h zconf.h inftrees.h infutil.h inffast.h\n+inflate.obj : zutil.h zlib.h zconf.h infblock.h\n+inftrees.obj : zutil.h zlib.h zconf.h inftrees.h\n+infutil.obj : zutil.h zlib.h zconf.h inftrees.h infutil.h\n+minigzip.obj : zlib.h zconf.h\n+trees.obj : deflate.h zutil.h zlib.h zconf.h\n+uncompr.obj : zlib.h zconf.h\n+zutil.obj : zutil.h zlib.h zconf.h"}, {"sha": "a105aaa5bbdb2663c5dd103534e750671754dc75", "filename": "zlib/old/os2/Makefile.os2", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fold%2Fos2%2FMakefile.os2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fold%2Fos2%2FMakefile.os2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2Fos2%2FMakefile.os2?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,136 @@\n+# Makefile for zlib under OS/2 using GCC (PGCC)\n+# For conditions of distribution and use, see copyright notice in zlib.h\n+\n+# To compile and test, type:\n+#   cp Makefile.os2 ..\n+#   cd ..\n+#   make -f Makefile.os2 test\n+\n+# This makefile will build a static library z.lib, a shared library\n+# z.dll and a import library zdll.lib. You can use either z.lib or\n+# zdll.lib by specifying either -lz or -lzdll on gcc's command line\n+\n+CC=gcc -Zomf -s\n+\n+CFLAGS=-O6 -Wall\n+#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\n+#CFLAGS=-g -DDEBUG\n+#CFLAGS=-O3 -Wall -Wwrite-strings -Wpointer-arith -Wconversion \\\n+#           -Wstrict-prototypes -Wmissing-prototypes\n+\n+#################### BUG WARNING: #####################\n+## infcodes.c hits a bug in pgcc-1.0, so you have to use either\n+## -O# where # <= 4 or one of (-fno-ommit-frame-pointer or -fno-force-mem)\n+## This bug is reportedly fixed in pgcc >1.0, but this was not tested\n+CFLAGS+=-fno-force-mem\n+\n+LDFLAGS=-s -L. -lzdll -Zcrtdll\n+LDSHARED=$(CC) -s -Zomf -Zdll -Zcrtdll\n+\n+VER=1.1.0\n+ZLIB=z.lib\n+SHAREDLIB=z.dll\n+SHAREDLIBIMP=zdll.lib\n+LIBS=$(ZLIB) $(SHAREDLIB) $(SHAREDLIBIMP)\n+\n+AR=emxomfar cr\n+IMPLIB=emximp\n+RANLIB=echo\n+TAR=tar\n+SHELL=bash\n+\n+prefix=/usr/local\n+exec_prefix = $(prefix)\n+\n+OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n+       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o\n+\n+TEST_OBJS = example.o minigzip.o\n+\n+DISTFILES = README INDEX ChangeLog configure Make*[a-z0-9] *.[ch] descrip.mms \\\n+  algorithm.txt zlib.3 msdos/Make*[a-z0-9] msdos/zlib.def msdos/zlib.rc \\\n+  nt/Makefile.nt nt/zlib.dnt  contrib/README.contrib contrib/*.txt \\\n+  contrib/asm386/*.asm contrib/asm386/*.c \\\n+  contrib/asm386/*.bat contrib/asm386/zlibvc.d?? contrib/iostream/*.cpp \\\n+  contrib/iostream/*.h  contrib/iostream2/*.h contrib/iostream2/*.cpp \\\n+  contrib/untgz/Makefile contrib/untgz/*.c contrib/untgz/*.w32\n+\n+all: example.exe minigzip.exe\n+\n+test: all\n+\t@LD_LIBRARY_PATH=.:$(LD_LIBRARY_PATH) ; export LD_LIBRARY_PATH; \\\n+\techo hello world | ./minigzip | ./minigzip -d || \\\n+\t  echo '\t\t*** minigzip test FAILED ***' ; \\\n+\tif ./example; then \\\n+\t  echo '\t\t*** zlib test OK ***'; \\\n+\telse \\\n+\t  echo '\t\t*** zlib test FAILED ***'; \\\n+\tfi\n+\n+$(ZLIB): $(OBJS)\n+\t$(AR) $@ $(OBJS)\n+\t-@ ($(RANLIB) $@ || true) >/dev/null 2>&1\n+\n+$(SHAREDLIB): $(OBJS) os2/z.def\n+\t$(LDSHARED) -o $@ $^\n+\n+$(SHAREDLIBIMP): os2/z.def\n+\t$(IMPLIB) -o $@ $^\n+\n+example.exe: example.o $(LIBS)\n+\t$(CC) $(CFLAGS) -o $@ example.o $(LDFLAGS)\n+\n+minigzip.exe: minigzip.o $(LIBS)\n+\t$(CC) $(CFLAGS) -o $@ minigzip.o $(LDFLAGS)\n+\n+clean:\n+\trm -f *.o *~ example minigzip libz.a libz.so* foo.gz\n+\n+distclean:\tclean\n+\n+zip:\n+\tmv Makefile Makefile~; cp -p Makefile.in Makefile\n+\trm -f test.c ztest*.c\n+\tv=`sed -n -e 's/\\.//g' -e '/VERSION \"/s/.*\"\\(.*\\)\".*/\\1/p' < zlib.h`;\\\n+\tzip -ul9 zlib$$v $(DISTFILES)\n+\tmv Makefile~ Makefile\n+\n+dist:\n+\tmv Makefile Makefile~; cp -p Makefile.in Makefile\n+\trm -f test.c ztest*.c\n+\td=zlib-`sed -n '/VERSION \"/s/.*\"\\(.*\\)\".*/\\1/p' < zlib.h`;\\\n+\trm -f $$d.tar.gz; \\\n+\tif test ! -d ../$$d; then rm -f ../$$d; ln -s `pwd` ../$$d; fi; \\\n+\tfiles=\"\"; \\\n+\tfor f in $(DISTFILES); do files=\"$$files $$d/$$f\"; done; \\\n+\tcd ..; \\\n+\tGZIP=-9 $(TAR) chofz $$d/$$d.tar.gz $$files; \\\n+\tif test ! -d $$d; then rm -f $$d; fi\n+\tmv Makefile~ Makefile\n+\n+tags:\n+\tetags *.[ch]\n+\n+depend:\n+\tmakedepend -- $(CFLAGS) -- *.[ch]\n+\n+# DO NOT DELETE THIS LINE -- make depend depends on it.\n+\n+adler32.o: zlib.h zconf.h\n+compress.o: zlib.h zconf.h\n+crc32.o: zlib.h zconf.h\n+deflate.o: deflate.h zutil.h zlib.h zconf.h\n+example.o: zlib.h zconf.h\n+gzio.o: zutil.h zlib.h zconf.h\n+infblock.o: infblock.h inftrees.h infcodes.h infutil.h zutil.h zlib.h zconf.h\n+infcodes.o: zutil.h zlib.h zconf.h\n+infcodes.o: inftrees.h infblock.h infcodes.h infutil.h inffast.h\n+inffast.o: zutil.h zlib.h zconf.h inftrees.h\n+inffast.o: infblock.h infcodes.h infutil.h inffast.h\n+inflate.o: zutil.h zlib.h zconf.h infblock.h\n+inftrees.o: zutil.h zlib.h zconf.h inftrees.h\n+infutil.o: zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h\n+minigzip.o: zlib.h zconf.h\n+trees.o: deflate.h zutil.h zlib.h zconf.h trees.h\n+uncompr.o: zlib.h zconf.h\n+zutil.o: zutil.h zlib.h zconf.h"}, {"sha": "4c753f1a3b993842030429bbdeccdb48f8a86ebe", "filename": "zlib/old/os2/zlib.def", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fold%2Fos2%2Fzlib.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fold%2Fos2%2Fzlib.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2Fos2%2Fzlib.def?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,51 @@\n+;\n+; Slightly modified version of ../nt/zlib.dnt :-)\n+;\n+\n+LIBRARY\t\tZ\n+DESCRIPTION\t\"Zlib compression library for OS/2\"\n+CODE\t\tPRELOAD MOVEABLE DISCARDABLE\n+DATA\t\tPRELOAD MOVEABLE MULTIPLE\n+\n+EXPORTS\n+    adler32\n+    compress\n+    crc32\n+    deflate\n+    deflateCopy\n+    deflateEnd\n+    deflateInit2_\n+    deflateInit_\n+    deflateParams\n+    deflateReset\n+    deflateSetDictionary\n+    gzclose\n+    gzdopen\n+    gzerror\n+    gzflush\n+    gzopen\n+    gzread\n+    gzwrite\n+    inflate\n+    inflateEnd\n+    inflateInit2_\n+    inflateInit_\n+    inflateReset\n+    inflateSetDictionary\n+    inflateSync\n+    uncompress\n+    zlibVersion\n+    gzprintf\n+    gzputc\n+    gzgetc\n+    gzseek\n+    gzrewind\n+    gztell\n+    gzeof\n+    gzsetparams\n+    zError\n+    inflateSyncPoint\n+    get_crc_table\n+    compress2\n+    gzputs\n+    gzgets"}, {"sha": "8c1b190c38b967709e2d39563b4393b41a294c89", "filename": "zlib/old/zlib.html", "status": "added", "additions": 971, "deletions": 0, "changes": 971, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fold%2Fzlib.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fold%2Fzlib.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2Fzlib.html?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,971 @@\n+<html>\n+<head>\n+ <title>\n+ zlib general purpose compression library version 1.1.4\n+ </title>\n+</head>\n+<body bgcolor=\"White\" text=\"Black\" vlink=\"Red\" alink=\"Navy\" link=\"Red\">\n+<!-- background=\"zlibbg.gif\" -->\n+\n+<h1> zlib 1.1.4 Manual </h1>\n+<hr>\n+<a name=\"Contents\"><h2>Contents</h2>\n+<ol type=\"I\">\n+<li> <a href=\"#Prologue\">Prologue</a>\n+<li> <a href=\"#Introduction\">Introduction</a>\n+<li> <a href=\"#Utility functions\">Utility functions</a>\n+<li> <a href=\"#Basic functions\">Basic functions</a>\n+<li> <a href=\"#Advanced functions\">Advanced functions</a>\n+<li> <a href=\"#Constants\">Constants</a>\n+<li> <a href=\"#struct z_stream_s\">struct z_stream_s</a>\n+<li> <a href=\"#Checksum functions\">Checksum functions</a>\n+<li> <a href=\"#Misc\">Misc</a>\n+</ol>\n+<hr>\n+<a name=\"Prologue\"><h2> Prologue </h2>\n+  'zlib' general purpose compression library version 1.1.4, March 11th, 2002\n+  <p>\n+  Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler\n+  <p>\n+  This software is provided 'as-is', without any express or implied\n+  warranty.  In no event will the authors be held liable for any damages\n+  arising from the use of this software.\n+  <p>\n+  Permission is granted to anyone to use this software for any purpose,\n+  including commercial applications, and to alter it and redistribute it\n+  freely, subject to the following restrictions:\n+  <ol>\n+   <li> The origin of this software must not be misrepresented ; you must not\n+     claim that you wrote the original software. If you use this software\n+     in a product, an acknowledgment in the product documentation would be\n+     appreciated but is not required.\n+   <li> Altered source versions must be plainly marked as such, and must not be\n+     misrepresented as being the original software.\n+   <li> This notice may not be removed or altered from any source distribution.\n+  </ol>\n+\n+  <dl>\n+  <dt>Jean-loup Gailly\n+  <dd><a href=\"mailto:jloup@gzip.org\">jloup@gzip.org</a>\n+  <dt>Mark Adler\n+  <dd><a href=\"mailto:madler@alumni.caltech.edu\">madler@alumni.caltech.edu</a>\n+  </dl>\n+\n+  The data format used by the zlib library is described by RFCs (Request for\n+  Comments) 1950 to 1952 in the files\n+  <a href=\"ftp://ds.internic.net/rfc/rfc1950.txt\">\n+  ftp://ds.internic.net/rfc/rfc1950.txt </a>\n+  (zlib format),\n+  <a href=\"ftp://ds.internic.net/rfc/rfc1951.txt\">\n+  rfc1951.txt </a>\n+  (<a href=\"#deflate\">deflate</a> format) and\n+  <a href=\"ftp://ds.internic.net/rfc/rfc1952.txt\">\n+  rfc1952.txt </a>\n+  (gzip format).\n+  <p>\n+  This manual is converted from zlib.h by\n+  <a href=\"mailto:piaip@csie.ntu.edu.tw\"> piaip </a>\n+  <p>\n+  Visit <a href=\"http://ftp.cdrom.com/pub/infozip/zlib/\">\n+  http://ftp.cdrom.com/pub/infozip/zlib/</a>\n+  for the official zlib web page.\n+  <p>\n+\n+<hr>\n+<a name=\"Introduction\"><h2> Introduction </h2>\n+     The 'zlib' compression library provides in-memory compression and\n+  decompression functions, including integrity checks of the uncompressed\n+  data.  This version of the library supports only one compression method\n+  (deflation) but other algorithms will be added later and will have the same\n+  stream interface.\n+  <p>\n+\n+     Compression can be done in a single step if the buffers are large\n+  enough (for example if an input file is mmap'ed), or can be done by\n+  repeated calls of the compression function.  In the latter case, the\n+  application must provide more input and/or consume the output\n+  (providing more output space) before each call.\n+  <p>\n+\n+     The library also supports reading and writing files in gzip (.gz) format\n+  with an interface similar to that of stdio.\n+  <p>\n+\n+     The library does not install any signal handler. The decoder checks\n+  the consistency of the compressed data, so the library should never\n+  crash even in case of corrupted input.\n+  <p>\n+\n+<hr>\n+<a name=\"Utility functions\"><h2> Utility functions </h2>\n+     The following utility functions are implemented on top of the\n+   <a href=\"#Basic functions\">basic stream-oriented functions</a>.\n+   To simplify the interface, some\n+   default options are assumed (compression level and memory usage,\n+   standard memory allocation functions). The source code of these\n+   utility functions can easily be modified if you need special options.\n+<h3> Function list </h3>\n+<ul>\n+<li> int  <a href=\"#compress\">compress</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen);\n+<li> int  <a href=\"#compress2\">compress2</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen, int level);\n+<li> int  <a href=\"#uncompress\">uncompress</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen);\n+<li> typedef voidp gzFile;\n+<li>  gzFile  <a href=\"#gzopen\">gzopen</a>  (const char *path, const char *mode);\n+<li> gzFile  <a href=\"#gzdopen\">gzdopen</a>  (int fd, const char *mode);\n+<li> int  <a href=\"#gzsetparams\">gzsetparams</a> (gzFile file, int level, int strategy);\n+<li> int     <a href=\"#gzread\">gzread</a>  (gzFile file, voidp buf, unsigned len);\n+<li> int     <a href=\"#gzwrite\">gzwrite</a> (gzFile file, const voidp buf, unsigned len);\n+<li> int VA   <a href=\"#gzprintf\">gzprintf</a> (gzFile file, const char *format, ...);\n+<li> int  <a href=\"#gzputs\">gzputs</a> (gzFile file, const char *s);\n+<li> char *  <a href=\"#gzgets\">gzgets</a> (gzFile file, char *buf, int len);\n+<li> int     <a href=\"#gzputc\">gzputc</a> (gzFile file, int c);\n+<li> int     <a href=\"#gzgetc\">gzgetc</a> (gzFile file);\n+<li> int     <a href=\"#gzflush\">gzflush</a> (gzFile file, int flush);\n+<li> z_off_t     <a href=\"#gzseek\">gzseek</a> (gzFile file, z_off_t offset, int whence);\n+<li> z_off_t     <a href=\"#gztell\">gztell</a> (gzFile file);\n+<li> int     <a href=\"#gzrewind\">gzrewind</a> (gzFile file);\n+<li> int  <a href=\"#gzeof\">gzeof</a> (gzFile file);\n+<li> int     <a href=\"#gzclose\">gzclose</a> (gzFile file);\n+<li> const char *  <a href=\"#gzerror\">gzerror</a> (gzFile file, int *errnum);\n+</ul>\n+<h3> Function description </h3>\n+<dl>\n+<font color=\"Blue\"><dt> int  <a name=\"compress\">compress</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen);</font>\n+<dd>\n+     Compresses the source buffer into the destination buffer.  sourceLen is\n+   the byte length of the source buffer. Upon entry, destLen is the total\n+   size of the destination buffer, which must be at least 0.1% larger than\n+   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the\n+   compressed buffer.<p>\n+     This function can be used to <a href=\"#compress\">compress</a> a whole file at once if the\n+   input file is mmap'ed.<p>\n+     <a href=\"#compress\">compress</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not\n+   enough memory, <a href=\"#Z_BUF_ERROR\">Z_BUF_ERROR</a> if there was not enough room in the output\n+   buffer.<p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"compress2\">compress2</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen, int level);</font>\n+<dd>\n+     Compresses the source buffer into the destination buffer. The level\n+   parameter has the same meaning as in <a href=\"#deflateInit\">deflateInit</a>.  sourceLen is the byte\n+   length of the source buffer. Upon entry, destLen is the total size of the\n+   destination buffer, which must be at least 0.1% larger than sourceLen plus\n+   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.\n+   <p>\n+\n+     <a href=\"#compress2\">compress2</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not enough\n+   memory, <a href=\"#Z_BUF_ERROR\">Z_BUF_ERROR</a> if there was not enough room in the output buffer,\n+   <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the level parameter is invalid.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"uncompress\">uncompress</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen);</font>\n+<dd>\n+     Decompresses the source buffer into the destination buffer.  sourceLen is\n+   the byte length of the source buffer. Upon entry, destLen is the total\n+   size of the destination buffer, which must be large enough to hold the\n+   entire uncompressed data. (The size of the uncompressed data must have\n+   been saved previously by the compressor and transmitted to the decompressor\n+   by some mechanism outside the scope of this compression library.)\n+   Upon exit, destLen is the actual size of the compressed buffer. <p>\n+     This function can be used to decompress a whole file at once if the\n+   input file is mmap'ed.\n+   <p>\n+\n+     <a href=\"#uncompress\">uncompress</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not\n+   enough memory, <a href=\"#Z_BUF_ERROR\">Z_BUF_ERROR</a> if there was not enough room in the output\n+   buffer, or <a href=\"#Z_DATA_ERROR\">Z_DATA_ERROR</a> if the input data was corrupted.\n+   <p>\n+\n+<dt> typedef voidp gzFile;\n+<dd> <p>\n+\n+<font color=\"Blue\"><dt>  gzFile  <a name=\"gzopen\">gzopen</a>  (const char *path, const char *mode);</font>\n+<dd>\n+     Opens a gzip (.gz) file for reading or writing. The mode parameter\n+   is as in fopen (\"rb\" or \"wb\") but can also include a compression level\n+   (\"wb9\") or a strategy: 'f' for filtered data as in \"wb6f\", 'h' for\n+   Huffman only compression as in \"wb1h\". (See the description\n+   of <a href=\"#deflateInit2\">deflateInit2</a> for more information about the strategy parameter.)\n+   <p>\n+\n+     <a href=\"#gzopen\">gzopen</a> can be used to read a file which is not in gzip format ; in this\n+   case <a href=\"#gzread\">gzread</a> will directly read from the file without decompression.\n+   <p>\n+\n+     <a href=\"#gzopen\">gzopen</a> returns NULL if the file could not be opened or if there was\n+   insufficient memory to allocate the (de)compression <a href=\"#state\">state</a> ; errno\n+   can be checked to distinguish the two cases (if errno is zero, the\n+   zlib error is <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a>).\n+   <p>\n+\n+<font color=\"Blue\"><dt> gzFile  <a name=\"gzdopen\">gzdopen</a>  (int fd, const char *mode);</font>\n+<dd>\n+     <a href=\"#gzdopen\">gzdopen</a>() associates a gzFile with the file descriptor fd.  File\n+   descriptors are obtained from calls like open, dup, creat, pipe or\n+   fileno (in the file has been previously opened with fopen).\n+   The mode parameter is as in <a href=\"#gzopen\">gzopen</a>.\n+   <p>\n+     The next call of <a href=\"#gzclose\">gzclose</a> on the returned gzFile will also close the\n+   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file\n+   descriptor fd. If you want to keep fd open, use <a href=\"#gzdopen\">gzdopen</a>(dup(fd), mode).\n+   <p>\n+     <a href=\"#gzdopen\">gzdopen</a> returns NULL if there was insufficient memory to allocate\n+   the (de)compression <a href=\"#state\">state</a>.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"gzsetparams\">gzsetparams</a> (gzFile file, int level, int strategy);</font>\n+<dd>\n+     Dynamically update the compression level or strategy. See the description\n+   of <a href=\"#deflateInit2\">deflateInit2</a> for the meaning of these parameters.\n+   <p>\n+     <a href=\"#gzsetparams\">gzsetparams</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, or <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the file was not\n+   opened for writing.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int     <a name=\"gzread\">gzread</a>  (gzFile file, voidp buf, unsigned len);</font>\n+<dd>\n+     Reads the given number of uncompressed bytes from the compressed file.\n+   If the input file was not in gzip format, <a href=\"#gzread\">gzread</a> copies the given number\n+   of bytes into the buffer.\n+   <p>\n+     <a href=\"#gzread\">gzread</a> returns the number of uncompressed bytes actually read (0 for\n+   end of file, -1 for error).\n+   <p>\n+\n+<font color=\"Blue\"><dt> int     <a name=\"gzwrite\">gzwrite</a> (gzFile file, const voidp buf, unsigned len);</font>\n+<dd>\n+     Writes the given number of uncompressed bytes into the compressed file.\n+   <a href=\"#gzwrite\">gzwrite</a> returns the number of uncompressed bytes actually written\n+   (0 in case of error).\n+   <p>\n+\n+<font color=\"Blue\"><dt> int VA   <a name=\"gzprintf\">gzprintf</a> (gzFile file, const char *format, ...);</font>\n+<dd>\n+     Converts, formats, and writes the args to the compressed file under\n+   control of the format string, as in fprintf. <a href=\"#gzprintf\">gzprintf</a> returns the number of\n+   uncompressed bytes actually written (0 in case of error).\n+   <p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"gzputs\">gzputs</a> (gzFile file, const char *s);</font>\n+<dd>\n+      Writes the given null-terminated string to the compressed file, excluding\n+   the terminating null character.\n+   <p>\n+      <a href=\"#gzputs\">gzputs</a> returns the number of characters written, or -1 in case of error.\n+      <p>\n+\n+<font color=\"Blue\"><dt> char *  <a name=\"gzgets\">gzgets</a> (gzFile file, char *buf, int len);</font>\n+<dd>\n+      Reads bytes from the compressed file until len-1 characters are read, or\n+   a newline character is read and transferred to buf, or an end-of-file\n+   condition is encountered.  The string is then terminated with a null\n+   character.\n+   <p>\n+      <a href=\"#gzgets\">gzgets</a> returns buf, or <a href=\"#Z_NULL\">Z_NULL</a> in case of error.\n+      <p>\n+\n+<font color=\"Blue\"><dt> int     <a name=\"gzputc\">gzputc</a> (gzFile file, int c);</font>\n+<dd>\n+      Writes c, converted to an unsigned char, into the compressed file.\n+   <a href=\"#gzputc\">gzputc</a> returns the value that was written, or -1 in case of error.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int     <a name=\"gzgetc\">gzgetc</a> (gzFile file);</font>\n+<dd>\n+      Reads one byte from the compressed file. <a href=\"#gzgetc\">gzgetc</a> returns this byte\n+   or -1 in case of end of file or error.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int     <a name=\"gzflush\">gzflush</a> (gzFile file, int flush);</font>\n+<dd>\n+     Flushes all pending output into the compressed file. The parameter\n+   flush is as in the <a href=\"#deflate\">deflate</a>() function. The return value is the zlib\n+   error number (see function <a href=\"#gzerror\">gzerror</a> below). <a href=\"#gzflush\">gzflush</a> returns <a href=\"#Z_OK\">Z_OK</a> if\n+   the flush parameter is <a href=\"#Z_FINISH\">Z_FINISH</a> and all output could be flushed.\n+   <p>\n+     <a href=\"#gzflush\">gzflush</a> should be called only when strictly necessary because it can\n+   degrade compression.\n+   <p>\n+\n+<font color=\"Blue\"><dt> z_off_t     <a name=\"gzseek\">gzseek</a> (gzFile file, z_off_t offset, int whence);</font>\n+<dd>\n+      Sets the starting position for the next <a href=\"#gzread\">gzread</a> or <a href=\"#gzwrite\">gzwrite</a> on the\n+   given compressed file. The offset represents a number of bytes in the\n+   uncompressed data stream. The whence parameter is defined as in lseek(2);\n+   the value SEEK_END is not supported.\n+   <p>\n+     If the file is opened for reading, this function is emulated but can be\n+   extremely slow. If the file is opened for writing, only forward seeks are\n+   supported ; <a href=\"#gzseek\">gzseek</a> then compresses a sequence of zeroes up to the new\n+   starting position.\n+   <p>\n+      <a href=\"#gzseek\">gzseek</a> returns the resulting offset location as measured in bytes from\n+   the beginning of the uncompressed stream, or -1 in case of error, in\n+   particular if the file is opened for writing and the new starting position\n+   would be before the current position.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int     <a name=\"gzrewind\">gzrewind</a> (gzFile file);</font>\n+<dd>\n+     Rewinds the given file. This function is supported only for reading.\n+     <p>\n+   <a href=\"#gzrewind\">gzrewind</a>(file) is equivalent to (int)<a href=\"#gzseek\">gzseek</a>(file, 0L, SEEK_SET)\n+   <p>\n+\n+<font color=\"Blue\"><dt> z_off_t     <a name=\"gztell\">gztell</a> (gzFile file);</font>\n+<dd>\n+     Returns the starting position for the next <a href=\"#gzread\">gzread</a> or <a href=\"#gzwrite\">gzwrite</a> on the\n+   given compressed file. This position represents a number of bytes in the\n+   uncompressed data stream.\n+   <p>\n+\n+   <a href=\"#gztell\">gztell</a>(file) is equivalent to <a href=\"#gzseek\">gzseek</a>(file, 0L, SEEK_CUR)\n+   <p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"gzeof\">gzeof</a> (gzFile file);</font>\n+<dd>\n+     Returns 1 when EOF has previously been detected reading the given\n+   input stream, otherwise zero.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int     <a name=\"gzclose\">gzclose</a> (gzFile file);</font>\n+<dd>\n+     Flushes all pending output if necessary, closes the compressed file\n+   and deallocates all the (de)compression <a href=\"#state\">state</a>. The return value is the zlib\n+   error number (see function <a href=\"#gzerror\">gzerror</a> below).\n+   <p>\n+\n+<font color=\"Blue\"><dt> const char *  <a name=\"gzerror\">gzerror</a> (gzFile file, int *errnum);</font>\n+<dd>\n+     Returns the error message for the last error which occurred on the\n+   given compressed file. errnum is set to zlib error number. If an\n+   error occurred in the file system and not in the compression library,\n+   errnum is set to <a href=\"#Z_ERRNO\">Z_ERRNO</a> and the application may consult errno\n+   to get the exact error code.\n+   <p>\n+</dl>\n+<hr>\n+<a name=\"Basic functions\"><h2> Basic functions </h2>\n+<h3> Function list </h3>\n+<ul>\n+<li>  const char *  <a href=\"#zlibVersion\">zlibVersion</a> (void);\n+<li>  int  <a href=\"#deflateInit\">deflateInit</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int level);\n+<li>  int  <a href=\"#deflate\">deflate</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int flush);\n+<li>  int  <a href=\"#deflateEnd\">deflateEnd</a> (<a href=\"#z_streamp\">z_streamp</a> strm);\n+<li>  int  <a href=\"#inflateInit\">inflateInit</a> (<a href=\"#z_streamp\">z_streamp</a> strm);\n+<li>  int  <a href=\"#inflate\">inflate</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int flush);\n+<li>  int  <a href=\"#inflateEnd\">inflateEnd</a> (<a href=\"#z_streamp\">z_streamp</a> strm);\n+</ul>\n+\n+<h3> Function description </h3>\n+<dl>\n+<font color=\"Blue\"><dt>  const char *  <a name=\"zlibVersion\">zlibVersion</a> (void);</font>\n+<dd> The application can compare <a href=\"#zlibVersion\">zlibVersion</a> and ZLIB_VERSION for consistency.\n+   If the first character differs, the library code actually used is\n+   not compatible with the zlib.h header file used by the application.\n+   This check is automatically made by <a href=\"#deflateInit\">deflateInit</a> and <a href=\"#inflateInit\">inflateInit</a>.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"deflateInit\">deflateInit</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int level);</font>\n+<dd>\n+     Initializes the internal stream <a href=\"#state\">state</a> for compression. The fields\n+   <a href=\"#zalloc\">zalloc</a>, <a href=\"#zfree\">zfree</a> and <a href=\"#opaque\">opaque</a> must be initialized before by the caller.\n+   If <a href=\"#zalloc\">zalloc</a> and <a href=\"#zfree\">zfree</a> are set to <a href=\"#Z_NULL\">Z_NULL</a>, <a href=\"#deflateInit\">deflateInit</a> updates them to\n+   use default allocation functions.\n+   <p>\n+\n+     The compression level must be <a href=\"#Z_DEFAULT_COMPRESSION\">Z_DEFAULT_COMPRESSION</a>, or between 0 and 9:\n+   1 gives best speed, 9 gives best compression, 0 gives no compression at\n+   all (the input data is simply copied a block at a time).\n+   <p>\n+\n+   <a href=\"#Z_DEFAULT_COMPRESSION\">Z_DEFAULT_COMPRESSION</a> requests a default compromise between speed and\n+   compression (currently equivalent to level 6).\n+   <p>\n+\n+     <a href=\"#deflateInit\">deflateInit</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not\n+   enough memory, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if level is not a valid compression level,\n+   <a href=\"#Z_VERSION_ERROR\">Z_VERSION_ERROR</a> if the zlib library version (<a href=\"#zlib_version\">zlib_version</a>) is incompatible\n+   with the version assumed by the caller (ZLIB_VERSION).\n+   <a href=\"#msg\">msg</a> is set to null if there is no error message.  <a href=\"#deflateInit\">deflateInit</a> does not\n+   perform any compression: this will be done by <a href=\"#deflate\">deflate</a>().\n+   <p>\n+\n+<font color=\"Blue\"><dt>  int  <a name=\"deflate\">deflate</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int flush);</font>\n+<dd>\n+    <a href=\"#deflate\">deflate</a> compresses as much data as possible, and stops when the input\n+  buffer becomes empty or the output buffer becomes full. It may introduce some\n+  output latency (reading input without producing any output) except when\n+  forced to flush.<p>\n+\n+    The detailed semantics are as follows. <a href=\"#deflate\">deflate</a> performs one or both of the\n+  following actions:\n+\n+  <ul>\n+  <li> Compress more input starting at <a href=\"#next_in\">next_in</a> and update <a href=\"#next_in\">next_in</a> and <a href=\"#avail_in\">avail_in</a>\n+    accordingly. If not all input can be processed (because there is not\n+    enough room in the output buffer), <a href=\"#next_in\">next_in</a> and <a href=\"#avail_in\">avail_in</a> are updated and\n+    processing will resume at this point for the next call of <a href=\"#deflate\">deflate</a>().\n+\n+  <li>\n+    Provide more output starting at <a href=\"#next_out\">next_out</a> and update <a href=\"#next_out\">next_out</a> and <a href=\"#avail_out\">avail_out</a>\n+    accordingly. This action is forced if the parameter flush is non zero.\n+    Forcing flush frequently degrades the compression ratio, so this parameter\n+    should be set only when necessary (in interactive applications).\n+    Some output may be provided even if flush is not set.\n+  </ul> <p>\n+\n+  Before the call of <a href=\"#deflate\">deflate</a>(), the application should ensure that at least\n+  one of the actions is possible, by providing more input and/or consuming\n+  more output, and updating <a href=\"#avail_in\">avail_in</a> or <a href=\"#avail_out\">avail_out</a> accordingly ; <a href=\"#avail_out\">avail_out</a>\n+  should never be zero before the call. The application can consume the\n+  compressed output when it wants, for example when the output buffer is full\n+  (<a href=\"#avail_out\">avail_out</a> == 0), or after each call of <a href=\"#deflate\">deflate</a>(). If <a href=\"#deflate\">deflate</a> returns <a href=\"#Z_OK\">Z_OK</a>\n+  and with zero <a href=\"#avail_out\">avail_out</a>, it must be called again after making room in the\n+  output buffer because there might be more output pending.\n+  <p>\n+\n+    If the parameter flush is set to <a href=\"#Z_SYNC_FLUSH\">Z_SYNC_FLUSH</a>, all pending output is\n+  flushed to the output buffer and the output is aligned on a byte boundary, so\n+  that the decompressor can get all input data available so far. (In particular\n+  <a href=\"#avail_in\">avail_in</a> is zero after the call if enough output space has been provided\n+  before the call.)  Flushing may degrade compression for some compression\n+  algorithms and so it should be used only when necessary.\n+  <p>\n+\n+    If flush is set to <a href=\"#Z_FULL_FLUSH\">Z_FULL_FLUSH</a>, all output is flushed as with\n+  <a href=\"#Z_SYNC_FLUSH\">Z_SYNC_FLUSH</a>, and the compression <a href=\"#state\">state</a> is reset so that decompression can\n+  restart from this point if previous compressed data has been damaged or if\n+  random access is desired. Using <a href=\"#Z_FULL_FLUSH\">Z_FULL_FLUSH</a> too often can seriously degrade\n+  the compression.\n+  <p>\n+\n+    If <a href=\"#deflate\">deflate</a> returns with <a href=\"#avail_out\">avail_out</a> == 0, this function must be called again\n+  with the same value of the flush parameter and more output space (updated\n+  <a href=\"#avail_out\">avail_out</a>), until the flush is complete (<a href=\"#deflate\">deflate</a> returns with non-zero\n+  <a href=\"#avail_out\">avail_out</a>).\n+  <p>\n+\n+    If the parameter flush is set to <a href=\"#Z_FINISH\">Z_FINISH</a>, pending input is processed,\n+  pending output is flushed and <a href=\"#deflate\">deflate</a> returns with <a href=\"#Z_STREAM_END\">Z_STREAM_END</a> if there\n+  was enough output space ; if <a href=\"#deflate\">deflate</a> returns with <a href=\"#Z_OK\">Z_OK</a>, this function must be\n+  called again with <a href=\"#Z_FINISH\">Z_FINISH</a> and more output space (updated <a href=\"#avail_out\">avail_out</a>) but no\n+  more input data, until it returns with <a href=\"#Z_STREAM_END\">Z_STREAM_END</a> or an error. After\n+  <a href=\"#deflate\">deflate</a> has returned <a href=\"#Z_STREAM_END\">Z_STREAM_END</a>, the only possible operations on the\n+  stream are <a href=\"#deflateReset\">deflateReset</a> or <a href=\"#deflateEnd\">deflateEnd</a>.\n+  <p>\n+\n+    <a href=\"#Z_FINISH\">Z_FINISH</a> can be used immediately after <a href=\"#deflateInit\">deflateInit</a> if all the compression\n+  is to be done in a single step. In this case, <a href=\"#avail_out\">avail_out</a> must be at least\n+  0.1% larger than <a href=\"#avail_in\">avail_in</a> plus 12 bytes.  If <a href=\"#deflate\">deflate</a> does not return\n+  <a href=\"#Z_STREAM_END\">Z_STREAM_END</a>, then it must be called again as described above.\n+  <p>\n+\n+    <a href=\"#deflate\">deflate</a>() sets strm-&gt <a href=\"#adler\">adler</a> to the <a href=\"#adler32\">adler32</a> checksum of all input read\n+  so far (that is, <a href=\"#total_in\">total_in</a> bytes).\n+  <p>\n+\n+    <a href=\"#deflate\">deflate</a>() may update <a href=\"#data_type\">data_type</a> if it can make a good guess about\n+  the input data type (<a href=\"#Z_ASCII\">Z_ASCII</a> or <a href=\"#Z_BINARY\">Z_BINARY</a>). In doubt, the data is considered\n+  binary. This field is only for information purposes and does not affect\n+  the compression algorithm in any manner.\n+  <p>\n+\n+    <a href=\"#deflate\">deflate</a>() returns <a href=\"#Z_OK\">Z_OK</a> if some progress has been made (more input\n+  processed or more output produced), <a href=\"#Z_STREAM_END\">Z_STREAM_END</a> if all input has been\n+  consumed and all output has been produced (only when flush is set to\n+  <a href=\"#Z_FINISH\">Z_FINISH</a>), <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the stream <a href=\"#state\">state</a> was inconsistent (for example\n+  if <a href=\"#next_in\">next_in</a> or <a href=\"#next_out\">next_out</a> was NULL), <a href=\"#Z_BUF_ERROR\">Z_BUF_ERROR</a> if no progress is possible\n+  (for example <a href=\"#avail_in\">avail_in</a> or <a href=\"#avail_out\">avail_out</a> was zero).\n+  <p>\n+\n+<font color=\"Blue\"><dt>  int  <a name=\"deflateEnd\">deflateEnd</a> (<a href=\"#z_streamp\">z_streamp</a> strm);</font>\n+<dd>\n+     All dynamically allocated data structures for this stream are freed.\n+   This function discards any unprocessed input and does not flush any\n+   pending output.\n+   <p>\n+\n+     <a href=\"#deflateEnd\">deflateEnd</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the\n+   stream <a href=\"#state\">state</a> was inconsistent, <a href=\"#Z_DATA_ERROR\">Z_DATA_ERROR</a> if the stream was freed\n+   prematurely (some input or output was discarded). In the error case,\n+   <a href=\"#msg\">msg</a> may be set but then points to a static string (which must not be\n+   deallocated).\n+   <p>\n+\n+<font color=\"Blue\"><dt>  int  <a name=\"inflateInit\">inflateInit</a> (<a href=\"#z_streamp\">z_streamp</a> strm);</font>\n+<dd>\n+\tInitializes the internal stream <a href=\"#state\">state</a> for decompression. The fields\n+   <a href=\"#next_in\">next_in</a>, <a href=\"#avail_in\">avail_in</a>, <a href=\"#zalloc\">zalloc</a>, <a href=\"#zfree\">zfree</a> and <a href=\"#opaque\">opaque</a> must be initialized before by\n+   the caller. If <a href=\"#next_in\">next_in</a> is not <a href=\"#Z_NULL\">Z_NULL</a> and <a href=\"#avail_in\">avail_in</a> is large enough (the exact\n+   value depends on the compression method), <a href=\"#inflateInit\">inflateInit</a> determines the\n+   compression method from the zlib header and allocates all data structures\n+   accordingly ; otherwise the allocation will be deferred to the first call of\n+   <a href=\"#inflate\">inflate</a>.  If <a href=\"#zalloc\">zalloc</a> and <a href=\"#zfree\">zfree</a> are set to <a href=\"#Z_NULL\">Z_NULL</a>, <a href=\"#inflateInit\">inflateInit</a> updates them to\n+   use default allocation functions.\n+   <p>\n+\n+     <a href=\"#inflateInit\">inflateInit</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not enough\n+   memory, <a href=\"#Z_VERSION_ERROR\">Z_VERSION_ERROR</a> if the zlib library version is incompatible with the\n+   version assumed by the caller.  <a href=\"#msg\">msg</a> is set to null if there is no error\n+   message. <a href=\"#inflateInit\">inflateInit</a> does not perform any decompression apart from reading\n+   the zlib header if present: this will be done by <a href=\"#inflate\">inflate</a>().  (So <a href=\"#next_in\">next_in</a> and\n+   <a href=\"#avail_in\">avail_in</a> may be modified, but <a href=\"#next_out\">next_out</a> and <a href=\"#avail_out\">avail_out</a> are unchanged.)\n+   <p>\n+\n+<font color=\"Blue\"><dt>  int  <a name=\"inflate\">inflate</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int flush);</font>\n+<dd>\n+    <a href=\"#inflate\">inflate</a> decompresses as much data as possible, and stops when the input\n+  buffer becomes empty or the output buffer becomes full. It may some\n+  introduce some output latency (reading input without producing any output)\n+  except when forced to flush.\n+  <p>\n+\n+  The detailed semantics are as follows. <a href=\"#inflate\">inflate</a> performs one or both of the\n+  following actions:\n+\n+  <ul>\n+  <li> Decompress more input starting at <a href=\"#next_in\">next_in</a> and update <a href=\"#next_in\">next_in</a> and <a href=\"#avail_in\">avail_in</a>\n+    accordingly. If not all input can be processed (because there is not\n+    enough room in the output buffer), <a href=\"#next_in\">next_in</a> is updated and processing\n+    will resume at this point for the next call of <a href=\"#inflate\">inflate</a>().\n+\n+  <li> Provide more output starting at <a href=\"#next_out\">next_out</a> and update <a href=\"#next_out\">next_out</a> and\n+    <a href=\"#avail_out\">avail_out</a> accordingly.  <a href=\"#inflate\">inflate</a>() provides as much output as possible,\n+    until there is no more input data or no more space in the output buffer\n+    (see below about the flush parameter).\n+  </ul> <p>\n+\n+  Before the call of <a href=\"#inflate\">inflate</a>(), the application should ensure that at least\n+  one of the actions is possible, by providing more input and/or consuming\n+  more output, and updating the next_* and avail_* values accordingly.\n+  The application can consume the uncompressed output when it wants, for\n+  example when the output buffer is full (<a href=\"#avail_out\">avail_out</a> == 0), or after each\n+  call of <a href=\"#inflate\">inflate</a>(). If <a href=\"#inflate\">inflate</a> returns <a href=\"#Z_OK\">Z_OK</a> and with zero <a href=\"#avail_out\">avail_out</a>, it\n+  must be called again after making room in the output buffer because there\n+  might be more output pending.\n+  <p>\n+\n+    If the parameter flush is set to <a href=\"#Z_SYNC_FLUSH\">Z_SYNC_FLUSH</a>, <a href=\"#inflate\">inflate</a> flushes as much\n+  output as possible to the output buffer. The flushing behavior of <a href=\"#inflate\">inflate</a> is\n+  not specified for values of the flush parameter other than <a href=\"#Z_SYNC_FLUSH\">Z_SYNC_FLUSH</a>\n+  and <a href=\"#Z_FINISH\">Z_FINISH</a>, but the current implementation actually flushes as much output\n+  as possible anyway.\n+  <p>\n+\n+    <a href=\"#inflate\">inflate</a>() should normally be called until it returns <a href=\"#Z_STREAM_END\">Z_STREAM_END</a> or an\n+  error. However if all decompression is to be performed in a single step\n+  (a single call of <a href=\"#inflate\">inflate</a>), the parameter flush should be set to\n+  <a href=\"#Z_FINISH\">Z_FINISH</a>. In this case all pending input is processed and all pending\n+  output is flushed ; <a href=\"#avail_out\">avail_out</a> must be large enough to hold all the\n+  uncompressed data. (The size of the uncompressed data may have been saved\n+  by the compressor for this purpose.) The next operation on this stream must\n+  be <a href=\"#inflateEnd\">inflateEnd</a> to deallocate the decompression <a href=\"#state\">state</a>. The use of <a href=\"#Z_FINISH\">Z_FINISH</a>\n+  is never required, but can be used to inform <a href=\"#inflate\">inflate</a> that a faster routine\n+  may be used for the single <a href=\"#inflate\">inflate</a>() call.\n+  <p>\n+\n+     If a preset dictionary is needed at this point (see <a href=\"#inflateSetDictionary\">inflateSetDictionary</a>\n+  below), <a href=\"#inflate\">inflate</a> sets strm-<a href=\"#adler\">adler</a> to the <a href=\"#adler32\">adler32</a> checksum of the\n+  dictionary chosen by the compressor and returns <a href=\"#Z_NEED_DICT\">Z_NEED_DICT</a> ; otherwise\n+  it sets strm-&gt <a href=\"#adler\">adler</a> to the <a href=\"#adler32\">adler32</a> checksum of all output produced\n+  so far (that is, <a href=\"#total_out\">total_out</a> bytes) and returns <a href=\"#Z_OK\">Z_OK</a>, <a href=\"#Z_STREAM_END\">Z_STREAM_END</a> or\n+  an error code as described below. At the end of the stream, <a href=\"#inflate\">inflate</a>()\n+  checks that its computed <a href=\"#adler32\">adler32</a> checksum is equal to that saved by the\n+  compressor and returns <a href=\"#Z_STREAM_END\">Z_STREAM_END</a> only if the checksum is correct.\n+  <p>\n+\n+    <a href=\"#inflate\">inflate</a>() returns <a href=\"#Z_OK\">Z_OK</a> if some progress has been made (more input processed\n+  or more output produced), <a href=\"#Z_STREAM_END\">Z_STREAM_END</a> if the end of the compressed data has\n+  been reached and all uncompressed output has been produced, <a href=\"#Z_NEED_DICT\">Z_NEED_DICT</a> if a\n+  preset dictionary is needed at this point, <a href=\"#Z_DATA_ERROR\">Z_DATA_ERROR</a> if the input data was\n+  corrupted (input stream not conforming to the zlib format or incorrect\n+  <a href=\"#adler32\">adler32</a> checksum), <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the stream structure was inconsistent\n+  (for example if <a href=\"#next_in\">next_in</a> or <a href=\"#next_out\">next_out</a> was NULL), <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not\n+  enough memory, <a href=\"#Z_BUF_ERROR\">Z_BUF_ERROR</a> if no progress is possible or if there was not\n+  enough room in the output buffer when <a href=\"#Z_FINISH\">Z_FINISH</a> is used. In the <a href=\"#Z_DATA_ERROR\">Z_DATA_ERROR</a>\n+  case, the application may then call <a href=\"#inflateSync\">inflateSync</a> to look for a good\n+  compression block.\n+  <p>\n+\n+<font color=\"Blue\"><dt>  int  <a name=\"inflateEnd\">inflateEnd</a> (<a href=\"#z_streamp\">z_streamp</a> strm);</font>\n+<dd>\n+     All dynamically allocated data structures for this stream are freed.\n+   This function discards any unprocessed input and does not flush any\n+   pending output.\n+   <p>\n+\n+     <a href=\"#inflateEnd\">inflateEnd</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the stream <a href=\"#state\">state</a>\n+   was inconsistent. In the error case, <a href=\"#msg\">msg</a> may be set but then points to a\n+   static string (which must not be deallocated).\n+</dl>\n+<hr>\n+<a name=\"Advanced functions\"><h2> Advanced functions </h2>\n+    The following functions are needed only in some special applications.\n+<h3> Function list </h3>\n+<ul>\n+<li>  int  <a href=\"#deflateInit2\">deflateInit2</a> (<a href=\"#z_streamp\">z_streamp</a> strm,\n+<li> int  <a href=\"#deflateSetDictionary\">deflateSetDictionary</a> (<a href=\"#z_streamp\">z_streamp</a> strm, const Bytef *dictionary, uInt  dictLength);\n+<li> int  <a href=\"#deflateCopy\">deflateCopy</a> (<a href=\"#z_streamp\">z_streamp</a> dest, <a href=\"#z_streamp\">z_streamp</a> source);\n+<li> int  <a href=\"#deflateReset\">deflateReset</a> (<a href=\"#z_streamp\">z_streamp</a> strm);\n+<li> int  <a href=\"#deflateParams\">deflateParams</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int level, int strategy);\n+<li> int  <a href=\"#inflateInit2\">inflateInit2</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int  windowBits);\n+<li>  int  <a href=\"#inflateSetDictionary\">inflateSetDictionary</a> (<a href=\"#z_streamp\">z_streamp</a> strm, const Bytef *dictionary, uInt  dictLength);\n+<li> int  <a href=\"#inflateSync\">inflateSync</a> (<a href=\"#z_streamp\">z_streamp</a> strm);\n+<li> int  <a href=\"#inflateReset\">inflateReset</a> (<a href=\"#z_streamp\">z_streamp</a> strm);\n+\n+</ul>\n+<h3> Function description </h3>\n+<dl>\n+<font color=\"Blue\"><dt>  int  <a name=\"deflateInit2\">deflateInit2</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int  level, int  method, int  windowBits, int  memLevel, int  strategy);</font>\n+\n+<dd> This is another version of <a href=\"#deflateInit\">deflateInit</a> with more compression options. The\n+   fields <a href=\"#next_in\">next_in</a>, <a href=\"#zalloc\">zalloc</a>, <a href=\"#zfree\">zfree</a> and <a href=\"#opaque\">opaque</a> must be initialized before by\n+   the caller.<p>\n+\n+     The method parameter is the compression method. It must be <a href=\"#Z_DEFLATED\">Z_DEFLATED</a> in\n+   this version of the library.<p>\n+\n+     The windowBits parameter is the base two logarithm of the window size\n+   (the size of the history buffer).  It should be in the range 8..15 for this\n+   version of the library. Larger values of this parameter result in better\n+   compression at the expense of memory usage. The default value is 15 if\n+   <a href=\"#deflateInit\">deflateInit</a> is used instead.<p>\n+\n+     The memLevel parameter specifies how much memory should be allocated\n+   for the internal compression <a href=\"#state\">state</a>. memLevel=1 uses minimum memory but\n+   is slow and reduces compression ratio ; memLevel=9 uses maximum memory\n+   for optimal speed. The default value is 8. See zconf.h for total memory\n+   usage as a function of windowBits and memLevel.<p>\n+\n+     The strategy parameter is used to tune the compression algorithm. Use the\n+   value <a href=\"#Z_DEFAULT_STRATEGY\">Z_DEFAULT_STRATEGY</a> for normal data, <a href=\"#Z_FILTERED\">Z_FILTERED</a> for data produced by a\n+   filter (or predictor), or <a href=\"#Z_HUFFMAN_ONLY\">Z_HUFFMAN_ONLY</a> to force Huffman encoding only (no\n+   string match).  Filtered data consists mostly of small values with a\n+   somewhat random distribution. In this case, the compression algorithm is\n+   tuned to <a href=\"#compress\">compress</a> them better. The effect of <a href=\"#Z_FILTERED\">Z_FILTERED</a> is to force more\n+   Huffman coding and less string matching ; it is somewhat intermediate\n+   between Z_DEFAULT and <a href=\"#Z_HUFFMAN_ONLY\">Z_HUFFMAN_ONLY</a>. The strategy parameter only affects\n+   the compression ratio but not the correctness of the compressed output even\n+   if it is not set appropriately.<p>\n+\n+      <a href=\"#deflateInit2\">deflateInit2</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not enough\n+   memory, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if a parameter is invalid (such as an invalid\n+   method). <a href=\"#msg\">msg</a> is set to null if there is no error message.  <a href=\"#deflateInit2\">deflateInit2</a> does\n+   not perform any compression: this will be done by <a href=\"#deflate\">deflate</a>().<p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"deflateSetDictionary\">deflateSetDictionary</a> (<a href=\"#z_streamp\">z_streamp</a> strm, const Bytef *dictionary, uInt  dictLength);</font>\n+<dd>\n+     Initializes the compression dictionary from the given byte sequence\n+   without producing any compressed output. This function must be called\n+   immediately after <a href=\"#deflateInit\">deflateInit</a>, <a href=\"#deflateInit2\">deflateInit2</a> or <a href=\"#deflateReset\">deflateReset</a>, before any\n+   call of <a href=\"#deflate\">deflate</a>. The compressor and decompressor must use exactly the same\n+   dictionary (see <a href=\"#inflateSetDictionary\">inflateSetDictionary</a>).<p>\n+\n+     The dictionary should consist of strings (byte sequences) that are likely\n+   to be encountered later in the data to be compressed, with the most commonly\n+   used strings preferably put towards the end of the dictionary. Using a\n+   dictionary is most useful when the data to be compressed is short and can be\n+   predicted with good accuracy ; the data can then be compressed better than\n+   with the default empty dictionary.<p>\n+\n+     Depending on the size of the compression data structures selected by\n+   <a href=\"#deflateInit\">deflateInit</a> or <a href=\"#deflateInit2\">deflateInit2</a>, a part of the dictionary may in effect be\n+   discarded, for example if the dictionary is larger than the window size in\n+   <a href=\"#deflate\">deflate</a> or deflate2. Thus the strings most likely to be useful should be\n+   put at the end of the dictionary, not at the front.<p>\n+\n+     Upon return of this function, strm-&gt <a href=\"#adler\">adler</a> is set to the Adler32 value\n+   of the dictionary ; the decompressor may later use this value to determine\n+   which dictionary has been used by the compressor. (The Adler32 value\n+   applies to the whole dictionary even if only a subset of the dictionary is\n+   actually used by the compressor.)<p>\n+\n+     <a href=\"#deflateSetDictionary\">deflateSetDictionary</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, or <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if a\n+   parameter is invalid (such as NULL dictionary) or the stream <a href=\"#state\">state</a> is\n+   inconsistent (for example if <a href=\"#deflate\">deflate</a> has already been called for this stream\n+   or if the compression method is bsort). <a href=\"#deflateSetDictionary\">deflateSetDictionary</a> does not\n+   perform any compression: this will be done by <a href=\"#deflate\">deflate</a>().<p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"deflateCopy\">deflateCopy</a> (<a href=\"#z_streamp\">z_streamp</a> dest, <a href=\"#z_streamp\">z_streamp</a> source);</font>\n+<dd>\n+     Sets the destination stream as a complete copy of the source stream.<p>\n+\n+     This function can be useful when several compression strategies will be\n+   tried, for example when there are several ways of pre-processing the input\n+   data with a filter. The streams that will be discarded should then be freed\n+   by calling <a href=\"#deflateEnd\">deflateEnd</a>.  Note that <a href=\"#deflateCopy\">deflateCopy</a> duplicates the internal\n+   compression <a href=\"#state\">state</a> which can be quite large, so this strategy is slow and\n+   can consume lots of memory.<p>\n+\n+     <a href=\"#deflateCopy\">deflateCopy</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not\n+   enough memory, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the source stream <a href=\"#state\">state</a> was inconsistent\n+   (such as <a href=\"#zalloc\">zalloc</a> being NULL). <a href=\"#msg\">msg</a> is left unchanged in both source and\n+   destination.<p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"deflateReset\">deflateReset</a> (<a href=\"#z_streamp\">z_streamp</a> strm);</font>\n+<dd>     This function is equivalent to <a href=\"#deflateEnd\">deflateEnd</a> followed by <a href=\"#deflateInit\">deflateInit</a>,\n+   but does not free and reallocate all the internal compression <a href=\"#state\">state</a>.\n+   The stream will keep the same compression level and any other attributes\n+   that may have been set by <a href=\"#deflateInit2\">deflateInit2</a>.<p>\n+\n+      <a href=\"#deflateReset\">deflateReset</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, or <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the source\n+   stream <a href=\"#state\">state</a> was inconsistent (such as <a href=\"#zalloc\">zalloc</a> or <a href=\"#state\">state</a> being NULL).<p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"deflateParams\">deflateParams</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int level, int strategy);</font>\n+<dd>\n+     Dynamically update the compression level and compression strategy.  The\n+   interpretation of level and strategy is as in <a href=\"#deflateInit2\">deflateInit2</a>.  This can be\n+   used to switch between compression and straight copy of the input data, or\n+   to switch to a different kind of input data requiring a different\n+   strategy. If the compression level is changed, the input available so far\n+   is compressed with the old level (and may be flushed); the new level will\n+   take effect only at the next call of <a href=\"#deflate\">deflate</a>().<p>\n+\n+     Before the call of <a href=\"#deflateParams\">deflateParams</a>, the stream <a href=\"#state\">state</a> must be set as for\n+   a call of <a href=\"#deflate\">deflate</a>(), since the currently available input may have to\n+   be compressed and flushed. In particular, strm-&gt <a href=\"#avail_out\">avail_out</a> must be\n+   non-zero.<p>\n+\n+     <a href=\"#deflateParams\">deflateParams</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the source\n+   stream <a href=\"#state\">state</a> was inconsistent or if a parameter was invalid, <a href=\"#Z_BUF_ERROR\">Z_BUF_ERROR</a>\n+   if strm-&gtavail_out was zero.<p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"inflateInit2\">inflateInit2</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int  windowBits);</font>\n+\n+<dd>     This is another version of <a href=\"#inflateInit\">inflateInit</a> with an extra parameter. The\n+   fields <a href=\"#next_in\">next_in</a>, <a href=\"#avail_in\">avail_in</a>, <a href=\"#zalloc\">zalloc</a>, <a href=\"#zfree\">zfree</a> and <a href=\"#opaque\">opaque</a> must be initialized\n+   before by the caller.<p>\n+\n+     The windowBits parameter is the base two logarithm of the maximum window\n+   size (the size of the history buffer).  It should be in the range 8..15 for\n+   this version of the library. The default value is 15 if <a href=\"#inflateInit\">inflateInit</a> is used\n+   instead. If a compressed stream with a larger window size is given as\n+   input, <a href=\"#inflate\">inflate</a>() will return with the error code <a href=\"#Z_DATA_ERROR\">Z_DATA_ERROR</a> instead of\n+   trying to allocate a larger window.<p>\n+\n+      <a href=\"#inflateInit2\">inflateInit2</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not enough\n+   memory, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if a parameter is invalid (such as a negative\n+   memLevel). <a href=\"#msg\">msg</a> is set to null if there is no error message.  <a href=\"#inflateInit2\">inflateInit2</a>\n+   does not perform any decompression apart from reading the zlib header if\n+   present: this will be done by <a href=\"#inflate\">inflate</a>(). (So <a href=\"#next_in\">next_in</a> and <a href=\"#avail_in\">avail_in</a> may be\n+   modified, but <a href=\"#next_out\">next_out</a> and <a href=\"#avail_out\">avail_out</a> are unchanged.)<p>\n+\n+<font color=\"Blue\"><dt>  int  <a name=\"inflateSetDictionary\">inflateSetDictionary</a> (<a href=\"#z_streamp\">z_streamp</a> strm, const Bytef *dictionary, uInt  dictLength);</font>\n+<dd>\n+     Initializes the decompression dictionary from the given uncompressed byte\n+   sequence. This function must be called immediately after a call of <a href=\"#inflate\">inflate</a>\n+   if this call returned <a href=\"#Z_NEED_DICT\">Z_NEED_DICT</a>. The dictionary chosen by the compressor\n+   can be determined from the Adler32 value returned by this call of\n+   <a href=\"#inflate\">inflate</a>. The compressor and decompressor must use exactly the same\n+   dictionary (see <a href=\"#deflateSetDictionary\">deflateSetDictionary</a>).<p>\n+\n+     <a href=\"#inflateSetDictionary\">inflateSetDictionary</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if a\n+   parameter is invalid (such as NULL dictionary) or the stream <a href=\"#state\">state</a> is\n+   inconsistent, <a href=\"#Z_DATA_ERROR\">Z_DATA_ERROR</a> if the given dictionary doesn't match the\n+   expected one (incorrect Adler32 value). <a href=\"#inflateSetDictionary\">inflateSetDictionary</a> does not\n+   perform any decompression: this will be done by subsequent calls of\n+   <a href=\"#inflate\">inflate</a>().<p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"inflateSync\">inflateSync</a> (<a href=\"#z_streamp\">z_streamp</a> strm);</font>\n+\n+<dd>    Skips invalid compressed data until a full flush point (see above the\n+  description of <a href=\"#deflate\">deflate</a> with <a href=\"#Z_FULL_FLUSH\">Z_FULL_FLUSH</a>) can be found, or until all\n+  available input is skipped. No output is provided.<p>\n+\n+    <a href=\"#inflateSync\">inflateSync</a> returns <a href=\"#Z_OK\">Z_OK</a> if a full flush point has been found, <a href=\"#Z_BUF_ERROR\">Z_BUF_ERROR</a>\n+  if no more input was provided, <a href=\"#Z_DATA_ERROR\">Z_DATA_ERROR</a> if no flush point has been found,\n+  or <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the stream structure was inconsistent. In the success\n+  case, the application may save the current current value of <a href=\"#total_in\">total_in</a> which\n+  indicates where valid compressed data was found. In the error case, the\n+  application may repeatedly call <a href=\"#inflateSync\">inflateSync</a>, providing more input each time,\n+  until success or end of the input data.<p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"inflateReset\">inflateReset</a> (<a href=\"#z_streamp\">z_streamp</a> strm);</font>\n+<dd>\n+     This function is equivalent to <a href=\"#inflateEnd\">inflateEnd</a> followed by <a href=\"#inflateInit\">inflateInit</a>,\n+   but does not free and reallocate all the internal decompression <a href=\"#state\">state</a>.\n+   The stream will keep attributes that may have been set by <a href=\"#inflateInit2\">inflateInit2</a>.\n+   <p>\n+\n+      <a href=\"#inflateReset\">inflateReset</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, or <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the source\n+   stream <a href=\"#state\">state</a> was inconsistent (such as <a href=\"#zalloc\">zalloc</a> or <a href=\"#state\">state</a> being NULL).\n+   <p>\n+</dl>\n+\n+<hr>\n+<a name=\"Checksum functions\"><h2> Checksum functions </h2>\n+     These functions are not related to compression but are exported\n+   anyway because they might be useful in applications using the\n+   compression library.\n+<h3> Function list </h3>\n+<ul>\n+<li> uLong  <a href=\"#adler32\">adler32</a> (uLong <a href=\"#adler\">adler</a>, const Bytef *buf, uInt len);\n+<li> uLong  <a href=\"#crc32\">crc32</a>   (uLong crc, const Bytef *buf, uInt len);\n+</ul>\n+<h3> Function description </h3>\n+<dl>\n+<font color=\"Blue\"><dt> uLong  <a name=\"adler32\">adler32</a> (uLong <a href=\"#adler\">adler</a>, const Bytef *buf, uInt len);</font>\n+<dd>\n+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and\n+   return the updated checksum. If buf is NULL, this function returns\n+   the required initial value for the checksum.\n+   <p>\n+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed\n+   much faster. Usage example:\n+   <pre>\n+\n+     uLong <a href=\"#adler\">adler</a> = <a href=\"#adler32\">adler32</a>(0L, <a href=\"#Z_NULL\">Z_NULL</a>, 0);\n+\n+     while (read_buffer(buffer, length) != EOF) {\n+       <a href=\"#adler\">adler</a> = <a href=\"#adler32\">adler32</a>(<a href=\"#adler\">adler</a>, buffer, length);\n+     }\n+     if (<a href=\"#adler\">adler</a> != original_adler) error();\n+   </pre>\n+\n+<font color=\"Blue\"><dt> uLong  <a name=\"crc32\">crc32</a>   (uLong crc, const Bytef *buf, uInt len);</font>\n+<dd>\n+     Update a running crc with the bytes buf[0..len-1] and return the updated\n+   crc. If buf is NULL, this function returns the required initial value\n+   for the crc. Pre- and post-conditioning (one's complement) is performed\n+   within this function so it shouldn't be done by the application.\n+   Usage example:\n+   <pre>\n+\n+     uLong crc = <a href=\"#crc32\">crc32</a>(0L, <a href=\"#Z_NULL\">Z_NULL</a>, 0);\n+\n+     while (read_buffer(buffer, length) != EOF) {\n+       crc = <a href=\"#crc32\">crc32</a>(crc, buffer, length);\n+     }\n+     if (crc != original_crc) error();\n+   </pre>\n+</dl>\n+<hr>\n+<a name=\"struct z_stream_s\"><h2> struct z_stream_s </h2>\n+<font color=\"Blue\">\n+<a name=\"z_stream_s\">\n+<pre>\n+typedef struct z_stream_s {\n+    Bytef    *<a name=\"next_in\">next_in</a>;  /* next input byte */\n+    uInt     <a name=\"avail_in\">avail_in</a>;  /* number of bytes available at <a href=\"#next_in\">next_in</a> */\n+    uLong    <a name=\"total_in\">total_in</a>;  /* total nb of input bytes read so far */\n+\n+    Bytef    *<a name=\"next_out\">next_out</a>; /* next output byte should be put there */\n+    uInt     <a name=\"avail_out\">avail_out</a>; /* remaining free space at <a href=\"#next_out\">next_out</a> */\n+    uLong    <a name=\"total_out\">total_out</a>; /* total nb of bytes output so far */\n+\n+    char     *<a name=\"msg\">msg</a>;      /* last error message, NULL if no error */\n+    struct internal_state FAR *<a name=\"state\">state</a>; /* not visible by applications */\n+\n+    alloc_func <a name=\"zalloc\">zalloc</a>;  /* used to allocate the internal <a href=\"#state\">state</a> */\n+    free_func  <a name=\"zfree\">zfree</a>;   /* used to free the internal <a href=\"#state\">state</a> */\n+    voidpf     <a name=\"opaque\">opaque</a>;  /* private data object passed to <a href=\"#zalloc\">zalloc</a> and <a href=\"#zfree\">zfree</a> */\n+\n+    int     <a name=\"data_type\">data_type</a>;  /* best guess about the data type: ascii or binary */\n+    uLong   <a name=\"adler\">adler</a>;      /* <a href=\"#adler32\">adler32</a> value of the uncompressed data */\n+    uLong   <a name=\"reserved\">reserved</a>;   /* <a href=\"#reserved\">reserved</a> for future use */\n+} <a href=\"#z_stream_s\">z_stream</a> ;\n+\n+typedef <a href=\"#z_stream_s\">z_stream</a> FAR * <a name=\"z_streamp\">z_streamp</a>;  \ufffd\n+</pre>\n+</font>\n+   The application must update <a href=\"#next_in\">next_in</a> and <a href=\"#avail_in\">avail_in</a> when <a href=\"#avail_in\">avail_in</a> has\n+   dropped to zero. It must update <a href=\"#next_out\">next_out</a> and <a href=\"#avail_out\">avail_out</a> when <a href=\"#avail_out\">avail_out</a>\n+   has dropped to zero. The application must initialize <a href=\"#zalloc\">zalloc</a>, <a href=\"#zfree\">zfree</a> and\n+   <a href=\"#opaque\">opaque</a> before calling the init function. All other fields are set by the\n+   compression library and must not be updated by the application. <p>\n+\n+   The <a href=\"#opaque\">opaque</a> value provided by the application will be passed as the first\n+   parameter for calls of <a href=\"#zalloc\">zalloc</a> and <a href=\"#zfree\">zfree</a>. This can be useful for custom\n+   memory management. The compression library attaches no meaning to the\n+   <a href=\"#opaque\">opaque</a> value. <p>\n+\n+   <a href=\"#zalloc\">zalloc</a> must return <a href=\"#Z_NULL\">Z_NULL</a> if there is not enough memory for the object.\n+   If zlib is used in a multi-threaded application, <a href=\"#zalloc\">zalloc</a> and <a href=\"#zfree\">zfree</a> must be\n+   thread safe. <p>\n+\n+   On 16-bit systems, the functions <a href=\"#zalloc\">zalloc</a> and <a href=\"#zfree\">zfree</a> must be able to allocate\n+   exactly 65536 bytes, but will not be required to allocate more than this\n+   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,\n+   pointers returned by <a href=\"#zalloc\">zalloc</a> for objects of exactly 65536 bytes *must*\n+   have their offset normalized to zero. The default allocation function\n+   provided by this library ensures this (see zutil.c). To reduce memory\n+   requirements and avoid any allocation of 64K objects, at the expense of\n+   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).\n+   <p>\n+\n+   The fields <a href=\"#total_in\">total_in</a> and <a href=\"#total_out\">total_out</a> can be used for statistics or\n+   progress reports. After compression, <a href=\"#total_in\">total_in</a> holds the total size of\n+   the uncompressed data and may be saved for use in the decompressor\n+   (particularly if the decompressor wants to decompress everything in\n+   a single step). <p>\n+\n+<hr>\n+<a name=\"Constants\"><h2> Constants </h2>\n+<font color=\"Blue\">\n+<pre>\n+#define <a name=\"Z_NO_FLUSH\">Z_NO_FLUSH</a>      0\n+#define <a name=\"Z_PARTIAL_FLUSH\">Z_PARTIAL_FLUSH</a> 1\n+\t/* will be removed, use <a href=\"#Z_SYNC_FLUSH\">Z_SYNC_FLUSH</a> instead */\n+#define <a name=\"Z_SYNC_FLUSH\">Z_SYNC_FLUSH</a>    2\n+#define <a name=\"Z_FULL_FLUSH\">Z_FULL_FLUSH</a>    3\n+#define <a name=\"Z_FINISH\">Z_FINISH</a>        4\n+/* Allowed flush values ; see <a href=\"#deflate\">deflate</a>() below for details */\n+\n+#define <a name=\"Z_OK\">Z_OK</a>            0\n+#define <a name=\"Z_STREAM_END\">Z_STREAM_END</a>    1\n+#define <a name=\"Z_NEED_DICT\">Z_NEED_DICT</a>     2\n+#define <a name=\"Z_ERRNO\">Z_ERRNO</a>        (-1)\n+#define <a name=\"Z_STREAM_ERROR\">Z_STREAM_ERROR</a> (-2)\n+#define <a name=\"Z_DATA_ERROR\">Z_DATA_ERROR</a>   (-3)\n+#define <a name=\"Z_MEM_ERROR\">Z_MEM_ERROR</a>    (-4)\n+#define <a name=\"Z_BUF_ERROR\">Z_BUF_ERROR</a>    (-5)\n+#define <a name=\"Z_VERSION_ERROR\">Z_VERSION_ERROR</a> (-6)\n+/* Return codes for the compression/decompression functions. Negative\n+ * values are errors, positive values are used for special but normal events.\n+ */\n+\n+#define <a name=\"Z_NO_COMPRESSION\">Z_NO_COMPRESSION</a>         0\n+#define <a name=\"Z_BEST_SPEED\">Z_BEST_SPEED</a>             1\n+#define <a name=\"Z_BEST_COMPRESSION\">Z_BEST_COMPRESSION</a>       9\n+#define <a name=\"Z_DEFAULT_COMPRESSION\">Z_DEFAULT_COMPRESSION</a>  (-1)\n+/* compression levels */\n+\n+#define <a name=\"Z_FILTERED\">Z_FILTERED</a>            1\n+#define <a name=\"Z_HUFFMAN_ONLY\">Z_HUFFMAN_ONLY</a>        2\n+#define <a name=\"Z_DEFAULT_STRATEGY\">Z_DEFAULT_STRATEGY</a>    0\n+/* compression strategy ; see <a href=\"#deflateInit2\">deflateInit2</a>() below for details */\n+\n+#define <a name=\"Z_BINARY\">Z_BINARY</a>   0\n+#define <a name=\"Z_ASCII\">Z_ASCII</a>    1\n+#define <a name=\"Z_UNKNOWN\">Z_UNKNOWN</a>  2\n+/* Possible values of the <a href=\"#data_type\">data_type</a> field */\n+\n+#define <a name=\"Z_DEFLATED\">Z_DEFLATED</a>   8\n+/* The <a href=\"#deflate\">deflate</a> compression method (the only one supported in this version) */\n+\n+#define <a name=\"Z_NULL\">Z_NULL</a>  0  /* for initializing <a href=\"#zalloc\">zalloc</a>, <a href=\"#zfree\">zfree</a>, <a href=\"#opaque\">opaque</a> */\n+\n+#define <a name=\"zlib_version\">zlib_version</a> <a href=\"#zlibVersion\">zlibVersion</a>()\n+/* for compatibility with versions less than 1.0.2 */\n+</pre>\n+</font>\n+\n+<hr>\n+<a name=\"Misc\"><h2> Misc </h2>\n+ <a href=\"#deflateInit\">deflateInit</a> and <a href=\"#inflateInit\">inflateInit</a> are macros to allow checking the zlib version\n+ and the compiler's view of <a href=\"#z_stream_s\">z_stream</a>.\n+ <p>\n+ Other functions:\n+ <dl>\n+ <font color=\"Blue\"><dt> const char   *  <a name=\"zError\">zError</a>           (int err);</font>\n+ <font color=\"Blue\"><dt> int             <a name=\"inflateSyncPoint\">inflateSyncPoint</a> (<a href=\"#z_streamp\">z_streamp</a> z);</font>\n+ <font color=\"Blue\"><dt> const uLongf *  <a name=\"get_crc_table\">get_crc_table</a>    (void);</font>\n+ </dl>\n+ <hr>\n+ <font size=\"-1\">\n+ Last update: Wed Oct 13 20:42:34 1999<br>\n+ piapi@csie.ntu.edu.tw\n+ </font>\n+\n+</body>\n+</html>"}, {"sha": "2b7d95198e764ee324c9e0e1fd05940b19ec044d", "filename": "zlib/qnx/package.qpg", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fqnx%2Fpackage.qpg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fqnx%2Fpackage.qpg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fqnx%2Fpackage.qpg?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,141 @@\n+<QPG:Generation>\n+   <QPG:Options>\n+      <QPG:User unattended=\"no\" verbosity=\"2\" listfiles=\"yes\"/>\n+      <QPG:Defaults type=\"qnx_package\"/>\n+      <QPG:Source></QPG:Source>\n+      <QPG:Release number=\"+\"/>\n+      <QPG:Build></QPG:Build>\n+      <QPG:FileSorting strip=\"yes\"/>\n+      <QPG:Package targets=\"combine\"/>\n+      <QPG:Repository generate=\"yes\"/>\n+      <QPG:FinalDir></QPG:FinalDir>\n+      <QPG:Cleanup></QPG:Cleanup>\n+   </QPG:Options>\n+\n+   <QPG:Responsible>\n+      <QPG:Company></QPG:Company>\n+      <QPG:Department></QPG:Department>\n+      <QPG:Group></QPG:Group>\n+      <QPG:Team></QPG:Team>\n+      <QPG:Employee></QPG:Employee>\n+      <QPG:EmailAddress></QPG:EmailAddress>\n+   </QPG:Responsible>\n+\n+   <QPG:Values>\n+      <QPG:Files>\n+         <QPG:Add file=\"../zconf.h\" install=\"/opt/include/\" user=\"root:sys\" permission=\"644\"/>\n+         <QPG:Add file=\"../zlib.h\" install=\"/opt/include/\" user=\"root:sys\" permission=\"644\"/>\n+         <QPG:Add file=\"../libz.so.1.2.1\" install=\"/opt/lib/\" user=\"root:bin\" permission=\"644\"/>\n+         <QPG:Add file=\"libz.so\" install=\"/opt/lib/\" component=\"dev\" filetype=\"symlink\" linkto=\"libz.so.1.2.1\"/>\n+         <QPG:Add file=\"libz.so.1\" install=\"/opt/lib/\" filetype=\"symlink\" linkto=\"libz.so.1.2.1\"/>\n+         <QPG:Add file=\"../libz.so.1.2.1\" install=\"/opt/lib/\" component=\"slib\"/>\n+      </QPG:Files>\n+\n+      <QPG:PackageFilter>\n+         <QPM:PackageManifest>\n+            <QPM:PackageDescription>\n+               <QPM:PackageType>Library</QPM:PackageType>\n+               <QPM:PackageReleaseNotes></QPM:PackageReleaseNotes>\n+               <QPM:PackageReleaseUrgency>Medium</QPM:PackageReleaseUrgency>\n+               <QPM:PackageRepository></QPM:PackageRepository>\n+               <QPM:FileVersion>2.0</QPM:FileVersion>\n+            </QPM:PackageDescription>\n+\n+            <QPM:ProductDescription>\n+               <QPM:ProductName>zlib</QPM:ProductName>\n+               <QPM:ProductIdentifier>zlib</QPM:ProductIdentifier>\n+               <QPM:ProductEmail>alain.bonnefoy@icbt.com</QPM:ProductEmail>\n+               <QPM:VendorName>Public</QPM:VendorName>\n+               <QPM:VendorInstallName>public</QPM:VendorInstallName>\n+               <QPM:VendorURL>www.gzip.org/zlib</QPM:VendorURL>\n+               <QPM:VendorEmbedURL></QPM:VendorEmbedURL>\n+               <QPM:VendorEmail></QPM:VendorEmail>\n+               <QPM:AuthorName>Jean-Loup Gailly,Mark Adler</QPM:AuthorName>\n+               <QPM:AuthorURL>www.gzip.org/zlib</QPM:AuthorURL>\n+               <QPM:AuthorEmbedURL></QPM:AuthorEmbedURL>\n+               <QPM:AuthorEmail>zlib@gzip.org</QPM:AuthorEmail>\n+               <QPM:ProductIconSmall></QPM:ProductIconSmall>\n+               <QPM:ProductIconLarge></QPM:ProductIconLarge>\n+               <QPM:ProductDescriptionShort>A massively spiffy yet delicately unobtrusive compression library.</QPM:ProductDescriptionShort>\n+               <QPM:ProductDescriptionLong>zlib is designed to be a free, general-purpose, legally unencumbered, lossless data compression library for use on virtually any computer hardware and operating system.</QPM:ProductDescriptionLong>\n+               <QPM:ProductDescriptionURL>http://www.gzip.org/zlib</QPM:ProductDescriptionURL>\n+               <QPM:ProductDescriptionEmbedURL></QPM:ProductDescriptionEmbedURL>\n+            </QPM:ProductDescription>\n+\n+            <QPM:ReleaseDescription>\n+               <QPM:ReleaseVersion>1.2.1</QPM:ReleaseVersion>\n+               <QPM:ReleaseUrgency>Medium</QPM:ReleaseUrgency>\n+               <QPM:ReleaseStability>Stable</QPM:ReleaseStability>\n+               <QPM:ReleaseNoteMinor></QPM:ReleaseNoteMinor>\n+               <QPM:ReleaseNoteMajor></QPM:ReleaseNoteMajor>\n+               <QPM:ExcludeCountries>\n+                  <QPM:Country></QPM:Country>\n+               </QPM:ExcludeCountries>\n+\n+               <QPM:ReleaseCopyright>No License</QPM:ReleaseCopyright>\n+            </QPM:ReleaseDescription>\n+\n+            <QPM:ContentDescription>\n+               <QPM:ContentTopic xmlmultiple=\"true\">Software Development/Libraries and Extensions/C Libraries</QPM:ContentTopic>\n+               <QPM:ContentKeyword>zlib,compression</QPM:ContentKeyword>\n+               <QPM:TargetOS>qnx6</QPM:TargetOS>\n+               <QPM:HostOS>qnx6</QPM:HostOS>\n+               <QPM:DisplayEnvironment xmlmultiple=\"true\">None</QPM:DisplayEnvironment>\n+               <QPM:TargetAudience xmlmultiple=\"true\">Developer</QPM:TargetAudience>\n+            </QPM:ContentDescription>\n+         </QPM:PackageManifest>\n+      </QPG:PackageFilter>\n+\n+      <QPG:PackageFilter proc=\"none\" target=\"none\">\n+         <QPM:PackageManifest>\n+            <QPM:ProductInstallationDependencies>\n+               <QPM:ProductRequirements></QPM:ProductRequirements>\n+            </QPM:ProductInstallationDependencies>\n+\n+            <QPM:ProductInstallationProcedure>\n+               <QPM:Script xmlmultiple=\"true\">\n+                  <QPM:ScriptName></QPM:ScriptName>\n+                  <QPM:ScriptType>Install</QPM:ScriptType>\n+                  <QPM:ScriptTiming>Post</QPM:ScriptTiming>\n+                  <QPM:ScriptBlocking>No</QPM:ScriptBlocking>\n+                  <QPM:ScriptResult>Ignore</QPM:ScriptResult>\n+                  <QPM:ShortDescription></QPM:ShortDescription>\n+                  <QPM:UseBinaries>No</QPM:UseBinaries>\n+                  <QPM:Priority>Optional</QPM:Priority>\n+               </QPM:Script>\n+            </QPM:ProductInstallationProcedure>\n+         </QPM:PackageManifest>\n+         \n+         <QPM:Launch>\n+         </QPM:Launch>\n+      </QPG:PackageFilter>\n+\n+      <QPG:PackageFilter type=\"core\" component=\"none\">\n+         <QPM:PackageManifest>\n+            <QPM:ProductInstallationProcedure>\n+\t       <QPM:OrderDependency xmlmultiple=\"true\">\n+\t          <QPM:Order>InstallOver</QPM:Order>\n+\t          <QPM:Product>zlib</QPM:Product>\n+\t       </QPM:OrderDependency>\n+            </QPM:ProductInstallationProcedure>\n+         </QPM:PackageManifest>\n+         \n+         <QPM:Launch>\n+         </QPM:Launch>\n+      </QPG:PackageFilter>\n+\n+      <QPG:PackageFilter type=\"core\" component=\"dev\">\n+         <QPM:PackageManifest>\n+            <QPM:ProductInstallationProcedure>\n+\t       <QPM:OrderDependency xmlmultiple=\"true\">\n+\t          <QPM:Order>InstallOver</QPM:Order>\n+\t          <QPM:Product>zlib-dev</QPM:Product>\n+\t       </QPM:OrderDependency>\n+            </QPM:ProductInstallationProcedure>\n+         </QPM:PackageManifest>\n+         \n+         <QPM:Launch>\n+         </QPM:Launch>\n+      </QPG:PackageFilter>\n+   </QPG:Values>\n+</QPG:Generation>"}, {"sha": "80b6b42568ba429bb531ff98e999cfb3914b8a9f", "filename": "zlib/win32/DLL_FAQ.txt", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fwin32%2FDLL_FAQ.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fwin32%2FDLL_FAQ.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fwin32%2FDLL_FAQ.txt?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,371 @@\n+\n+            Frequently Asked Questions about ZLIB1.DLL\n+\n+\n+This document describes the design, the rationale, and the usage\n+of the official DLL build of zlib, named ZLIB1.DLL.  If you have\n+general questions about zlib, you should see the file \"FAQ\" found\n+in the zlib distribution, or at the following location:\n+  http://www.gzip.org/zlib/zlib_faq.html\n+\n+\n+ 1. What is ZLIB1.DLL, and how can I get it?\n+\n+  - ZLIB1.DLL is the official build of zlib as a DLL.\n+    (Please remark the symbol '1' in the name.)\n+\n+    Pointers to a precompiled ZLIB1.DLL can be found in the zlib\n+    web site at:\n+      http://www.zlib.org/\n+\n+    Applications that link to ZLIB1.DLL can rely on the following\n+    specification:\n+\n+    * The exported symbols are exclusively defined in the source\n+      files \"zlib.h\" and \"zlib.def\", found in an official zlib\n+      source distribution.\n+    * The symbols are exported by name, not by ordinal.\n+    * The exported names are undecorated.\n+    * The calling convention of functions is \"C\" (CDECL).\n+    * The ZLIB1.DLL binary is linked to MSVCRT.DLL.\n+\n+    The archive in which ZLIB1.DLL is bundled contains compiled\n+    test programs that must run with a valid build of ZLIB1.DLL.\n+    It is recommended to download the prebuilt DLL from the zlib\n+    web site, instead of building it yourself, to avoid potential\n+    incompatibilities that could be introduced by your compiler\n+    and build settings.  If you do build the DLL yourself, please\n+    make sure that it complies with all the above requirements,\n+    and it runs with the precompiled test programs, bundled with\n+    the original ZLIB1.DLL distribution and available at the zlib\n+    web site.\n+\n+    If, for any reason, you need to build an incompatible DLL,\n+    please use a different name.\n+\n+\n+ 2. Why did you change the name of the DLL to ZLIB1.DLL?\n+    What happened to the old ZLIB.DLL?\n+\n+  - The old ZLIB.DLL, built from zlib-1.1.x and earlier, required\n+    compilation settings that were incompatible to those used by a\n+    static build.  The DLL settings were supposed to be enabled by\n+    defining the macro ZLIB_DLL, before including \"zlib.h\".\n+    Incorrect handling of this macro was silently accepted at\n+    build time, resulting in two major problems:\n+\n+    * ZLIB_DLL was missing from the old makefile.  When building\n+      the DLL, not all people added it to the build options.  In\n+      consequence, incompatible incarnations of ZLIB.DLL started\n+      to circulate around the net.\n+\n+    * When switching from using the static library to using the\n+      DLL, applications had to define the ZLIB_DLL macro and\n+      to recompile all the sources that contained calls to zlib\n+      functions.  Failure to do so resulted in creating binaries\n+      that were unable to run with the official ZLIB.DLL build.\n+\n+    The only possible solution that we could foresee was to make a\n+    binary-incompatible change in the DLL interfacing, in order to\n+    remove the dependency on the ZLIB_DLL macro, and to release\n+    the new DLL under a different name.\n+\n+    We chose the name ZLIB1.DLL, where '1' indicates the major\n+    zlib version number.  We hope that we will not have to break\n+    the binary compatibility again, at least not as long as the\n+    zlib-1.x series will last.\n+\n+    There is still a ZLIB_DLL macro, that can trigger a more\n+    efficient build and use of the DLL, but compatibility no\n+    longer dependents on it.\n+\n+\n+ 3. Can I build ZLIB.DLL from the new zlib sources, and replace\n+    an old ZLIB.DLL, that was built from zlib-1.1.4 or earlier?\n+\n+  - In principle, you can do it by assigning calling convention\n+    keywords to the macros ZEXPORT and ZEXPORTVA.  In practice,\n+    it depends on what you mean by \"an old ZLIB.DLL\", because\n+    the old DLL exists in several mutually-incompatible versions.\n+\n+    If you have a compiled application that works with a certain\n+    ZLIB.DLL without any known security issues, there is hardly\n+    a need to rebuild the DLL from new sources only to link it to\n+    the old app binary.  But if you really want to do it, you have\n+    to find out first what kind of calling convention uses your\n+    particular ZLIB.DLL build, and to use the same one in the new\n+    build.  If you don't know what this is all about, you might be\n+    better off if you would just forget it.\n+\n+\n+ 4. Can I compile my application using the new zlib interface, and\n+    link it to an old ZLIB.DLL, that was built from zlib-1.1.4 or\n+    earlier?\n+\n+  - The official answer is \"no\"; the real answer depends again on\n+    what kind of ZLIB.DLL you have.  Even if you are lucky, this\n+    course of action is unreliable.\n+\n+    If you rebuild your application and you intend to use a newer\n+    version of zlib (post- 1.1.4), it is strongly recommended to\n+    link it to the new ZLIB1.DLL.\n+\n+\n+ 5. Why are the zlib symbols exported by name, and not by ordinal?\n+\n+  - Although exporting symbols by ordinal is a little faster, it\n+    is risky.  Any single glitch in the maintenance or use of the\n+    DEF file that contains the ordinals can result in incompatible\n+    builds and frustrating crashes.  Simply put, the benefits of\n+    exporting symbols by ordinal do not justify the risks.\n+\n+    Technically, it should be possible to maintain ordinals in\n+    the DEF file, and still export the symbols by name.  Ordinals\n+    exist in every DLL, and even if the dynamic linking performed\n+    at the DLL startup is searching for names, ordinals serve as\n+    hints, for a faster name lookup.  However, if the DEF file\n+    contains ordinals, the Microsoft linker automatically builds\n+    an implib that will cause the executables linked to it to use\n+    those ordinals, and not the names.  It is interesting to\n+    notice that the GNU linker for Win32 does not suffer from this\n+    problem.\n+\n+    It is possible to avoid the DEF file if the exported symbols\n+    are accompanied by a \"__declspec(dllexport)\" attribute in the\n+    source files.  You can do this in zlib by predefining the\n+    ZLIB_DLL macro.\n+\n+\n+ 6. I see that the ZLIB1.DLL functions use the \"C\" (CDECL) calling\n+    convention.  Why not use the STDCALL convention?\n+    STDCALL is the standard convention in Win32, and I need it in\n+    my Visual Basic project!\n+\n+    (For readability, we use CDECL to refer to the convention\n+     triggered by the \"__cdecl\" keyword, STDCALL to refer to\n+     the convention triggered by \"__stdcall\", and FASTCALL to\n+     refer to the convention triggered by \"__fastcall\".)\n+\n+  - Most of the native Windows API functions (without varargs) use\n+    indeed the WINAPI convention (which translates to STDCALL in\n+    Win32), but the standard C functions use CDECL.  If a user\n+    application is intrinsically tied to the Windows API (e.g.\n+    it calls native Windows API functions such as CreateFile()),\n+    sometimes it makes sense to decorate its own functions with\n+    WINAPI.  But if ANSI C or POSIX portability is a goal (e.g.\n+    it calls standard C functions such as fopen()), it is not a\n+    sound decision to request the inclusion of <windows.h>, or to\n+    use non-ANSI constructs, for the sole purpose to make the user\n+    functions STDCALL-able.\n+\n+    The functionality offered by zlib is not in the category of\n+    \"Windows functionality\", but is more like \"C functionality\".\n+\n+    Technically, STDCALL is not bad; in fact, it is slightly\n+    faster than CDECL, and it works with variable-argument\n+    functions, just like CDECL.  It is unfortunate that, in spite\n+    of using STDCALL in the Windows API, it is not the default\n+    convention used by the C compilers that run under Windows.\n+    The roots of the problem reside deep inside the unsafety of\n+    the K&R-style function prototypes, where the argument types\n+    are not specified; but that is another story for another day.\n+\n+    The fact that remains is that CDECL is the default convention.\n+    Even if an explicit convention (such as STDCALL or FASTCALL)\n+    is hard-coded into the function prototypes inside C headers,\n+    problems may appear.  One problem, for example, deals with the\n+    necessity to expose the convention in users' callbacks.\n+\n+    The calling convention issues are also important when using\n+    zlib in other programming languages.  Some of them, like Ada\n+    (GNAT) and Fortran (GNU G77), have C bindings implemented\n+    initially on Unix, and relying on the C calling convention.\n+    On the other hand, the pre- .NET versions of Microsoft Visual\n+    Basic require STDCALL, while Borland Delphi prefers (although\n+    it does not require) FASTCALL.\n+\n+    In fairness to all possible uses of zlib outside the C\n+    programming language, we choose the default \"C\" convention.\n+    Anyone interested in different bindings or conventions is\n+    encouraged to maintain specialized projects.  The \"contrib/\"\n+    directory from the zlib distribution already holds a couple\n+    of foreign bindings, such as Ada, C++, and Delphi.\n+\n+\n+ 7. I need a DLL for my Visual Basic project.  What can I do?\n+\n+  - Define the ZLIB_WINAPI macro before including \"zlib.h\", when\n+    building both the DLL and the user application (except that\n+    you don't need to define anything when using the DLL in Visual\n+    Basic).  The ZLIB_WINAPI macro will switch on the WINAPI\n+    (STDCALL) convention.  The name of this DLL must be different\n+    than the official ZLIB1.DLL.\n+\n+    Gilles Vollant has contributed a build named ZLIBWAPI.DLL,\n+    with the ZLIB_WINAPI macro turned on, and with the minizip\n+    functionality built in.  For more information, please read\n+    the notes inside \"contrib/vstudio/readme.txt\", found in the\n+    zlib distribution.\n+\n+\n+ 8. If my application uses ZLIB1.DLL, should I link it to\n+    MSVCRT.DLL?  Why?\n+\n+  - It is not required, but it is recommended to link your\n+    application to MSVCRT.DLL, if it uses ZLIB1.DLL.\n+\n+    The executables (.EXE, .DLL, etc.) that are involved in the\n+    same process and are using the C run-time library (i.e. they\n+    are calling standard C functions), must link to the same\n+    library.  There are several libraries in the Win32 system:\n+    CRTDLL.DLL, MSVCRT.DLL, the static C libraries, etc.\n+    Since ZLIB1.DLL is linked to MSVCRT.DLL, the executables that\n+    depend on it should also be linked to MSVCRT.DLL.\n+\n+\n+ 9. Why are you saying that ZLIB1.DLL and my application must be\n+    linked to the same C run-time (CRT) library?  I linked my\n+    application and my DLLs to different C libraries (e.g. my\n+    application to a static library, and my DLLs to MSVCRT.DLL),\n+    and everything works fine.\n+\n+  - If a user library invokes only pure Win32 API (accessible via\n+    <windows.h> and the related headers), its DLL build will work\n+    in any context.  But if this library invokes standard C API,\n+    things get more complicated.\n+\n+    There is a single Win32 library in a Win32 system.  Every\n+    function in this library resides in a single DLL module, that\n+    is safe to call from anywhere.  On the other hand, there are\n+    multiple versions of the C library, and each of them has its\n+    own separate internal state.  Standalone executables and user\n+    DLLs that call standard C functions must link to a C run-time\n+    (CRT) library, be it static or shared (DLL).  Intermixing\n+    occurs when an executable (not necessarily standalone) and a\n+    DLL are linked to different CRTs, and both are running in the\n+    same process.\n+\n+    Intermixing multiple CRTs is possible, as long as their\n+    internal states are kept intact.  The Microsoft Knowledge Base\n+    articles KB94248 \"HOWTO: Use the C Run-Time\" and KB140584\n+    \"HOWTO: Link with the Correct C Run-Time (CRT) Library\"\n+    mention the potential problems raised by intermixing.\n+\n+    If intermixing works for you, it's because your application\n+    and DLLs are avoiding the corruption of each of the CRTs'\n+    internal states, maybe by careful design, or maybe by fortune.\n+\n+    Also note that linking ZLIB1.DLL to non-Microsoft CRTs (such\n+    as those provided by Borland) raises similar problems.\n+\n+\n+10. Why are you linking ZLIB1.DLL to MSVCRT.DLL?\n+\n+  - MSVCRT.DLL exists on every Windows 95 with a new service pack\n+    installed, or with Microsoft Internet Explorer 4 or later, and\n+    on all other Windows 4.x or later (Windows 98, Windows NT 4,\n+    or later).  It is freely distributable; if not present in the\n+    system, it can be downloaded from Microsoft or from other\n+    software provider for free.\n+\n+    The fact that MSVCRT.DLL does not exist on a virgin Windows 95\n+    is not so problematic.  The number of Windows 95 installations\n+    is rapidly decreasing, Microsoft stopped supporting it a long\n+    time ago, and many recent applications from various vendors,\n+    including Microsoft, do not even run on it.  Furthermore, no\n+    serious user should run Windows 95 without a proper update\n+    installed.\n+\n+    There is also the fact that the mainstream C compilers for\n+    Windows are Microsoft Visual C++ 6.0, and gcc/MinGW.  Both\n+    are producing executables that link to MSVCRT.DLL by default,\n+    without offering other dynamic CRTs as alternatives easy to\n+    select by users.\n+\n+\n+11. Why are you not linking ZLIB1.DLL to\n+    <<my favorite C run-time library>> ?\n+\n+  - We considered and abandoned the following alternatives:\n+\n+    * Linking ZLIB1.DLL to a static C library (LIBC.LIB, or\n+      LIBCMT.LIB) is not a good option.  People are using the DLL\n+      mainly to save disk space.  If you are linking your program\n+      to a static C library, you may as well consider linking zlib\n+      in statically, too.\n+\n+    * Linking ZLIB1.DLL to CRTDLL.DLL looks very appealing,\n+      because CRTDLL.DLL is present on every Win32 installation.\n+      Unfortunately, it has a series of problems: it raises\n+      difficulties when using it with C++ code, it does not work\n+      with 64-bit file offsets, (and so on...), and Microsoft\n+      discontinued its support a long time ago.\n+\n+    * Linking ZLIB1.DLL to MSVCR70.DLL, supplied with the\n+      Microsoft .NET platform and Visual C++ 7.0 or newer, is not\n+      a good option.  Although it is available for free download\n+      and distribution, its presence is scarce on today's Win32\n+      installations.  If it will ever become more popular than\n+      MSVCRT.DLL and will be pre-installed on the future Win32\n+      systems, we will probably think again about it.\n+\n+    * Linking ZLIB1.DLL to NTDLL.DLL is not possible.\n+      NTDLL.DLL exports only a part of the C library, and only on\n+      Windows NT systems.\n+\n+\n+12. I need to link my own DLL build to a CRT different than\n+    MSVCRT.DLL.  What can I do?\n+\n+  - Feel free to rebuild the DLL from the zlib sources, and link\n+    it the way you want.  You should, however, clearly state that\n+    your build is unofficial.  You should give it a different file\n+    name, and/or install it in a private directory that can be\n+    accessed by your application only, and is not visible to the\n+    others (e.g. it's not in the SYSTEM or the SYSTEM32 directory,\n+    and it's not in the PATH).  Otherwise, your build may clash\n+    with applications that link to the official build.\n+\n+    For example, in Cygwin, zlib is linked to the Cygwin runtime\n+    CYGWIN1.DLL, and it is distributed under the name CYGZ.DLL.\n+\n+\n+13. May I include additional pieces of code that I find useful,\n+    link them in ZLIB1.DLL, and export them?\n+\n+  - No.  A legitimate build of ZLIB1.DLL must not include code\n+    that does not originate from the official zlib source code.\n+    But you can make your own private DLL build, under a different\n+    file name, as suggested in the previous answer.\n+\n+    For example, in Borland Delphi and C++ Builder, zlib is a part\n+    of the standard VCL library.  If an application links to VCL\n+    dynamically, the name of the distributable binary (VCLxx.DLL)\n+    does not posess any danger of clashing with a legitimate but\n+    incompatible ZLIB1.DLL.\n+\n+\n+14. May I remove some functionality out of ZLIB1.DLL, by enabling\n+    macros like NO_GZCOMPRESS or NO_GZIP at compile time?\n+\n+  - No.  A legitimate build of ZLIB1.DLL must provide the complete\n+    zlib functionality, as implemented in the official zlib source\n+    code.  But you can make your own private DLL build, under a\n+    different file name, as suggested in the previous answer.\n+\n+\n+15. I made my own ZLIB1.DLL build.  Can I test it for compliance?\n+\n+  - We prefer that you download the official DLL from the zlib\n+    web site.  If you need something peculiar from this DLL, you\n+    can send your suggestion to the zlib mailing list.\n+\n+    However, in case you do rebuild the DLL yourself, you can run\n+    it with the test programs found in the DLL distribution.\n+    Running these test programs is not a guarantee of compliance,\n+    but a failure can imply a detected problem.\n+\n+**\n+\n+This document is written and maintained by\n+Cosmin Truta <cosmint@cs.ubbcluj.ro>"}, {"sha": "b802519ca352a16db5b20571cce4ef7d09fa590a", "filename": "zlib/win32/Makefile.bor", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fwin32%2FMakefile.bor", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fwin32%2FMakefile.bor", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fwin32%2FMakefile.bor?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,107 @@\n+# Makefile for zlib\n+# Borland C++ for Win32\n+#\n+# Updated for zlib 1.2.x by Cosmin Truta, 11-Mar-2003\n+# Last updated: 28-Aug-2003\n+#\n+# Usage:\n+#  make -f win32/Makefile.bor\n+#  make -f win32/Makefile.bor LOCAL_ZLIB=-DASMV OBJA=match.obj OBJPA=+match.obj\n+\n+# ------------ Borland C++ ------------\n+\n+# Optional nonstandard preprocessor flags (e.g. -DMAX_MEM_LEVEL=7)\n+# should be added to the environment via \"set LOCAL_ZLIB=-DFOO\" or\n+# added to the declaration of LOC here:\n+LOC = $(LOCAL_ZLIB)\n+\n+CC = bcc32\n+AS = bcc32\n+LD = bcc32\n+AR = tlib\n+CFLAGS  = -a -d -k- -O2 $(LOC)\n+ASFLAGS = $(LOC)\n+LDFLAGS = $(LOC)\n+\n+\n+# variables\n+ZLIB_LIB = zlib.lib\n+\n+OBJ1  = adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infback.obj\n+OBJ2  = inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj\n+#OBJA =\n+OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzio.obj+infback.obj\n+OBJP2 = +inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj\n+#OBJPA=\n+\n+\n+# targets\n+all: $(ZLIB_LIB) example.exe minigzip.exe\n+\n+.c.obj:\n+\t$(CC) -c $(CFLAGS) $<\n+\n+.asm.obj:\n+\t$(AS) -c $(ASFLAGS) $<\n+\n+adler32.obj: adler32.c zlib.h zconf.h\n+\n+compress.obj: compress.c zlib.h zconf.h\n+\n+crc32.obj: crc32.c zlib.h zconf.h crc32.h\n+\n+deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h\n+\n+gzio.obj: gzio.c zutil.h zlib.h zconf.h\n+\n+infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \\\n+ inffast.h inffixed.h\n+\n+inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \\\n+ inffast.h\n+\n+inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \\\n+ inffast.h inffixed.h\n+\n+inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h\n+\n+trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h\n+\n+uncompr.obj: uncompr.c zlib.h zconf.h\n+\n+zutil.obj: zutil.c zutil.h zlib.h zconf.h\n+\n+example.obj: example.c zlib.h zconf.h\n+\n+minigzip.obj: minigzip.c zlib.h zconf.h\n+\n+\n+# For the sake of the old Borland make,\n+# the command line is cut to fit in the MS-DOS 128 byte limit:\n+$(ZLIB_LIB): $(OBJ1) $(OBJ2) $(OBJA)\n+\t-del $(ZLIB_LIB)\n+\t$(AR) $(ZLIB_LIB) $(OBJP1)\n+\t$(AR) $(ZLIB_LIB) $(OBJP2)\n+\t$(AR) $(ZLIB_LIB) $(OBJPA)\n+\n+\n+# testing\n+test: example.exe minigzip.exe\n+\texample\n+\techo hello world | minigzip | minigzip -d\n+\n+example.exe: example.obj $(ZLIB_LIB)\n+\t$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)\n+\n+minigzip.exe: minigzip.obj $(ZLIB_LIB)\n+\t$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)\n+\n+\n+# cleanup\n+clean:\n+\t-del *.obj\n+\t-del *.lib\n+\t-del *.exe\n+\t-del *.tds\n+\t-del zlib.bak\n+\t-del foo.gz"}, {"sha": "7b08424cedf7107584d768293df66a35c02d7b46", "filename": "zlib/win32/Makefile.emx", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fwin32%2FMakefile.emx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fwin32%2FMakefile.emx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fwin32%2FMakefile.emx?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,69 @@\n+# Makefile for zlib.  Modified for emx/rsxnt by Chr. Spieler, 6/16/98.\n+# Copyright (C) 1995-1998 Jean-loup Gailly.\n+# For conditions of distribution and use, see copyright notice in zlib.h\n+\n+# To compile, or to compile and test, type:\n+#\n+#   make -fmakefile.emx;  make test -fmakefile.emx\n+#\n+\n+CC=gcc -Zwin32\n+\n+#CFLAGS=-MMD -O\n+#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\n+#CFLAGS=-MMD -g -DDEBUG\n+CFLAGS=-MMD -O3 $(BUTT) -Wall -Wwrite-strings -Wpointer-arith -Wconversion \\\n+             -Wstrict-prototypes -Wmissing-prototypes\n+\n+# If cp.exe is available, replace \"copy /Y\" with \"cp -fp\" .\n+CP=copy /Y\n+# If gnu install.exe is available, replace $(CP) with ginstall.\n+INSTALL=$(CP)\n+# The default value of RM is \"rm -f.\"  If \"rm.exe\" is found, comment out:\n+RM=del\n+LDLIBS=-L. -lzlib\n+LD=$(CC) -s -o\n+LDSHARED=$(CC)\n+\n+INCL=zlib.h zconf.h\n+LIBS=zlib.a\n+\n+AR=ar rcs\n+\n+prefix=/usr/local\n+exec_prefix = $(prefix)\n+\n+OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n+       zutil.o inflate.o infback.o inftrees.o inffast.o\n+\n+TEST_OBJS = example.o minigzip.o\n+\n+all: example.exe minigzip.exe\n+\n+test: all\n+\t./example\n+\techo hello world | .\\minigzip | .\\minigzip -d\n+\n+%.o : %.c\n+\t$(CC) $(CFLAGS) -c $< -o $@\n+\n+zlib.a: $(OBJS)\n+\t$(AR) $@ $(OBJS)\n+\n+%.exe : %.o $(LIBS)\n+\t$(LD) $@ $< $(LDLIBS)\n+\n+\n+.PHONY : clean\n+\n+clean:\n+\t$(RM) *.d\n+\t$(RM) *.o\n+\t$(RM) *.exe\n+\t$(RM) zlib.a\n+\t$(RM) foo.gz\n+\n+DEPS := $(wildcard *.d)\n+ifneq ($(DEPS),)\n+include $(DEPS)\n+endif"}, {"sha": "62a84301560203f80bbd36c1109d1e875c61624d", "filename": "zlib/win32/Makefile.gcc", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fwin32%2FMakefile.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fwin32%2FMakefile.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fwin32%2FMakefile.gcc?ref=176ba83391a86ff69a205fafabc4782e6a067605", "patch": "@@ -0,0 +1,141 @@\n+# Makefile for zlib, derived from Makefile.dj2.\n+# Modified for mingw32 by C. Spieler, 6/16/98.\n+# Updated for zlib 1.2.x by Christian Spieler and Cosmin Truta, Mar-2003.\n+# Last updated: 1-Aug-2003.\n+# Tested under Cygwin and MinGW.\n+\n+# Copyright (C) 1995-2003 Jean-loup Gailly.\n+# For conditions of distribution and use, see copyright notice in zlib.h\n+\n+# To compile, or to compile and test, type:\n+#\n+#   make -fmakefile.gcc;  make test testdll -fmakefile.gcc\n+#\n+# To use the asm code, type:\n+#   cp contrib/asm?86/match.S ./match.S\n+#   make LOC=-DASMV OBJA=match.o -fmakefile.gcc\n+#\n+# To install libz.a, zconf.h and zlib.h in the system directories, type:\n+#\n+#   make install -fmakefile.gcc\n+\n+# Note:\n+# If the platform is *not* MinGW (e.g. it is Cygwin or UWIN),\n+# the DLL name should be changed from \"zlib1.dll\".\n+\n+STATICLIB = libz.a\n+SHAREDLIB = zlib1.dll\n+IMPLIB    = libzdll.a\n+\n+#LOC = -DASMV\n+#LOC = -DDEBUG -g\n+\n+CC = gcc\n+CFLAGS = $(LOC) -O3 -Wall\n+\n+AS = $(CC)\n+ASFLAGS = $(LOC) -Wall\n+\n+LD = $(CC)\n+LDFLAGS = $(LOC) -s\n+\n+AR = ar\n+ARFLAGS = rcs\n+\n+RC = windres\n+RCFLAGS = --define GCC_WINDRES\n+\n+CP = cp -fp\n+# If GNU install is available, replace $(CP) with install.\n+INSTALL = $(CP)\n+RM = rm -f\n+\n+prefix = /usr/local\n+exec_prefix = $(prefix)\n+\n+OBJS = adler32.o compress.o crc32.o deflate.o gzio.o infback.o \\\n+       inffast.o inflate.o inftrees.o trees.o uncompr.o zutil.o\n+OBJA =\n+\n+all: $(STATICLIB) $(SHAREDLIB) $(IMPLIB) example minigzip example_d minigzip_d\n+\n+test: example minigzip\n+\t./example\n+\techo hello world | ./minigzip | ./minigzip -d\n+\n+testdll: example_d minigzip_d\n+\t./example_d\n+\techo hello world | ./minigzip_d | ./minigzip_d -d\n+\n+.c.o:\n+\t$(CC) $(CFLAGS) -c -o $@ $<\n+\n+.S.o:\n+\t$(AS) $(ASFLAGS) -c -o $@ $<\n+\n+$(STATICLIB): $(OBJS) $(OBJA)\n+\t$(AR) $(ARFLAGS) $@ $(OBJS) $(OBJA)\n+\n+$(IMPLIB): $(SHAREDLIB)\n+\n+$(SHAREDLIB): win32/zlib.def $(OBJS) $(OBJA) zlibrc.o\n+\tdllwrap --driver-name $(CC) --def win32/zlib.def \\\n+\t  --implib $(IMPLIB) -o $@ $(OBJS) $(OBJA) zlibrc.o\n+\tstrip $@\n+\n+example: example.o $(STATICLIB)\n+\t$(LD) $(LDFLAGS) -o $@ example.o $(STATICLIB)\n+\n+minigzip: minigzip.o $(STATICLIB)\n+\t$(LD) $(LDFLAGS) -o $@ minigzip.o $(STATICLIB)\n+\n+example_d: example.o $(IMPLIB)\n+\t$(LD) $(LDFLAGS) -o $@ example.o $(IMPLIB)\n+\n+minigzip_d: minigzip.o $(IMPLIB)\n+\t$(LD) $(LDFLAGS) -o $@ minigzip.o $(IMPLIB)\n+\n+zlibrc.o: win32/zlib1.rc\n+\t$(RC) $(RCFLAGS) -o $@ win32/zlib1.rc\n+\n+\n+# INCLUDE_PATH and LIBRARY_PATH must be set.\n+\n+.PHONY: install uninstall clean\n+\n+install: zlib.h zconf.h $(LIB)\n+\t-@if not exist $(INCLUDE_PATH)/nul mkdir $(INCLUDE_PATH)\n+\t-@if not exist $(LIBRARY_PATH)/nul mkdir $(LIBRARY_PATH)\n+\t-$(INSTALL) zlib.h $(INCLUDE_PATH)\n+\t-$(INSTALL) zconf.h $(INCLUDE_PATH)\n+\t-$(INSTALL) $(STATICLIB) $(LIBRARY_PATH)\n+\t-$(INSTALL) $(IMPLIB) $(LIBRARY_PATH)\n+\n+uninstall:\n+\t-$(RM) $(INCLUDE_PATH)/zlib.h\n+\t-$(RM) $(INCLUDE_PATH)/zconf.h\n+\t-$(RM) $(LIBRARY_PATH)/$(STATICLIB)\n+\t-$(RM) $(LIBRARY_PATH)/$(IMPLIB)\n+\n+clean:\n+\t-$(RM) $(STATICLIB)\n+\t-$(RM) $(SHAREDLIB)\n+\t-$(RM) $(IMPLIB)\n+\t-$(RM) *.o\n+\t-$(RM) *.exe\n+\t-$(RM) foo.gz\n+\n+adler32.o: zlib.h zconf.h\n+compress.o: zlib.h zconf.h\n+crc32.o: crc32.h zlib.h zconf.h\n+deflate.o: deflate.h zutil.h zlib.h zconf.h\n+example.o: zlib.h zconf.h\n+gzio.o: zutil.h zlib.h zconf.h\n+inffast.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h\n+inflate.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h\n+infback.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h\n+inftrees.o: zutil.h zlib.h zconf.h inftrees.h\n+minigzip.o: zlib.h zconf.h\n+trees.o: deflate.h zutil.h zlib.h zconf.h trees.h\n+uncompr.o: zlib.h zconf.h\n+zutil.o: zutil.h zlib.h zconf.h"}, {"sha": "528ecaaf24e75e5c039ade335f02b340b8dc3ee9", "filename": "zlib/win32/Makefile.msc", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fwin32%2FMakefile.msc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fwin32%2FMakefile.msc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fwin32%2FMakefile.msc?ref=176ba83391a86ff69a205fafabc4782e6a067605"}, {"sha": "a47cbc10caead22702bfbb166aae28a62fc00caf", "filename": "zlib/win32/zlib.def", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fwin32%2Fzlib.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fwin32%2Fzlib.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fwin32%2Fzlib.def?ref=176ba83391a86ff69a205fafabc4782e6a067605"}, {"sha": "326375d85c74896cab410fbf47cb442b0fffc7af", "filename": "zlib/win32/zlib1.rc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fwin32%2Fzlib1.rc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fwin32%2Fzlib1.rc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fwin32%2Fzlib1.rc?ref=176ba83391a86ff69a205fafabc4782e6a067605"}, {"sha": "3cea897eda7975b0bc82a97e01bbbde230def9d8", "filename": "zlib/zconf.in.h", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fzconf.in.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176ba83391a86ff69a205fafabc4782e6a067605/zlib%2Fzconf.in.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzconf.in.h?ref=176ba83391a86ff69a205fafabc4782e6a067605"}]}