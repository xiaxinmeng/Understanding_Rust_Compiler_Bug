{"sha": "f6f1984c3e483e7c00ef8822d310d98ea752d92a", "node_id": "C_kwDOANBUbNoAKGY2ZjE5ODRjM2U0ODNlN2MwMGVmODgyMmQzMTBkOThlYTc1MmQ5MmE", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-07-05T16:17:57Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:23Z"}, "message": "gccrs const folding port: continue porting potential_constant_expression_1()\n\nFollowing functions are ported in this changeset:\n - var_in_constexpr_fn\n - member_vec_linear_search\n - member_vec_binary_search\n - is_overloaded_fn\n - ovl_make\n - lookup_add\n - ovl_first\n - type_unknown_p\n\nFollowing structs, classes and enums are ported in this changeset:\n - tree_overload\n - ovl_iterator\n - tsubst_flags\n - cp_identifier_kind\n - tag_types", "tree": {"sha": "83d3ce53e2ab6db1b3535110d65f5579fd8eb20e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83d3ce53e2ab6db1b3535110d65f5579fd8eb20e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6f1984c3e483e7c00ef8822d310d98ea752d92a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6f1984c3e483e7c00ef8822d310d98ea752d92a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6f1984c3e483e7c00ef8822d310d98ea752d92a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6f1984c3e483e7c00ef8822d310d98ea752d92a/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bae115bfd2c10fc975547b0d4ef9e9a98d51fa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bae115bfd2c10fc975547b0d4ef9e9a98d51fa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bae115bfd2c10fc975547b0d4ef9e9a98d51fa4"}], "stats": {"total": 561, "additions": 561, "deletions": 0}, "files": [{"sha": "4b63499c8280b534f6e33c247ad541006427ca41", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f1984c3e483e7c00ef8822d310d98ea752d92a/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f1984c3e483e7c00ef8822d310d98ea752d92a/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=f6f1984c3e483e7c00ef8822d310d98ea752d92a", "patch": "@@ -1048,4 +1048,121 @@ init_modules ()\n     }\n }\n \n+// forked from gcc/cp/constexpr.cc var_in_constexpr_fn\n+\n+/* True if T was declared in a function declared to be constexpr, and\n+   therefore potentially constant in C++14.  */\n+\n+bool\n+var_in_constexpr_fn (tree t)\n+{\n+  tree ctx = DECL_CONTEXT (t);\n+  return (ctx && TREE_CODE (ctx) == FUNCTION_DECL\n+\t  && DECL_DECLARED_CONSTEXPR_P (ctx));\n+}\n+\n+// forked from gcc/cp/name-lookup.cc member_vec_linear_search\n+\n+/* Linear search of (unordered) MEMBER_VEC for NAME.  */\n+\n+static tree\n+member_vec_linear_search (vec<tree, va_gc> *member_vec, tree name)\n+{\n+  for (int ix = member_vec->length (); ix--;)\n+    if (tree binding = (*member_vec)[ix])\n+      if (OVL_NAME (binding) == name)\n+\treturn binding;\n+\n+  return NULL_TREE;\n+}\n+\n+// forked from gcc/cp/name-lookup.cc member_vec_binary_search\n+\n+/* Binary search of (ordered) MEMBER_VEC for NAME.  */\n+\n+static tree\n+member_vec_binary_search (vec<tree, va_gc> *member_vec, tree name)\n+{\n+  for (unsigned lo = 0, hi = member_vec->length (); lo < hi;)\n+    {\n+      unsigned mid = (lo + hi) / 2;\n+      tree binding = (*member_vec)[mid];\n+      tree binding_name = OVL_NAME (binding);\n+\n+      if (binding_name > name)\n+\thi = mid;\n+      else if (binding_name < name)\n+\tlo = mid + 1;\n+      else\n+\treturn binding;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+// forked from gcc/cp/tree.cc is_overloaded_fn\n+\n+/* Returns nonzero if X is an expression for a (possibly overloaded)\n+   function.  If \"f\" is a function or function template, \"f\", \"c->f\",\n+   \"c.f\", \"C::f\", and \"f<int>\" will all be considered possibly\n+   overloaded functions.  Returns 2 if the function is actually\n+   overloaded, i.e., if it is impossible to know the type of the\n+   function without performing overload resolution.  */\n+\n+int\n+is_overloaded_fn (tree x)\n+{\n+  STRIP_ANY_LOCATION_WRAPPER (x);\n+\n+  if (TREE_CODE (x) == COMPONENT_REF)\n+    x = TREE_OPERAND (x, 1);\n+\n+  if ((TREE_CODE (x) == OVERLOAD && !OVL_SINGLE_P (x)))\n+    return 2;\n+\n+  return OVL_P (x);\n+}\n+\n+// forked from gcc/cp/tree.cc ovl_make\n+\n+/* Make a raw overload node containing FN.  */\n+\n+tree\n+ovl_make (tree fn, tree next)\n+{\n+  tree result = make_node (OVERLOAD);\n+\n+  if (TREE_CODE (fn) == OVERLOAD)\n+    OVL_NESTED_P (result) = true;\n+\n+  TREE_TYPE (result)\n+    = (next || TREE_CODE (fn) == TEMPLATE_DECL ? unknown_type_node\n+\t\t\t\t\t       : TREE_TYPE (fn));\n+  if (next && TREE_CODE (next) == OVERLOAD && OVL_DEDUP_P (next))\n+    OVL_DEDUP_P (result) = true;\n+  OVL_FUNCTION (result) = fn;\n+  OVL_CHAIN (result) = next;\n+  return result;\n+}\n+\n+// forked from gcc/cp/name-lookup.cc lookup_add\n+\n+/* Add a set of new FNS into a lookup.  */\n+\n+tree\n+lookup_add (tree fns, tree lookup)\n+{\n+  if (fns == error_mark_node || lookup == error_mark_node)\n+    return error_mark_node;\n+\n+  if (lookup || TREE_CODE (fns) == TEMPLATE_DECL)\n+    {\n+      lookup = ovl_make (fns, lookup);\n+      OVL_LOOKUP_P (lookup) = true;\n+    }\n+  else\n+    lookup = fns;\n+\n+  return lookup;\n+}\n } // namespace Rust"}, {"sha": "8d9b9f0d9579d65ab0f7a6a8de9d3f5d33267387", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 444, "deletions": 0, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f1984c3e483e7c00ef8822d310d98ea752d92a/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f1984c3e483e7c00ef8822d310d98ea752d92a/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=f6f1984c3e483e7c00ef8822d310d98ea752d92a", "patch": "@@ -433,6 +433,237 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n /* std::source_location::__impl class.  */\n #define source_location_impl cp_global_trees[CPTI_SOURCE_LOCATION_IMPL]\n \n+/* These two accessors should only be used by OVL manipulators.\n+   Other users should use iterators and convenience functions.  */\n+#define OVL_FUNCTION(NODE)                                                     \\\n+  (((struct tree_overload *) OVERLOAD_CHECK (NODE))->function)\n+#define OVL_CHAIN(NODE)                                                        \\\n+  (((struct tree_overload *) OVERLOAD_CHECK (NODE))->common.chain)\n+\n+/* If set, this or a subsequent overload contains decls that need deduping.  */\n+#define OVL_DEDUP_P(NODE) TREE_LANG_FLAG_0 (OVERLOAD_CHECK (NODE))\n+/* If set, this was imported in a using declaration.   */\n+#define OVL_USING_P(NODE) TREE_LANG_FLAG_1 (OVERLOAD_CHECK (NODE))\n+/* If set, this overload is a hidden decl.  */\n+#define OVL_HIDDEN_P(NODE) TREE_LANG_FLAG_2 (OVERLOAD_CHECK (NODE))\n+/* If set, this overload contains a nested overload.  */\n+#define OVL_NESTED_P(NODE) TREE_LANG_FLAG_3 (OVERLOAD_CHECK (NODE))\n+/* If set, this overload was constructed during lookup.  */\n+#define OVL_LOOKUP_P(NODE) TREE_LANG_FLAG_4 (OVERLOAD_CHECK (NODE))\n+/* If set, this OVL_USING_P overload is exported.  */\n+#define OVL_EXPORT_P(NODE) TREE_LANG_FLAG_5 (OVERLOAD_CHECK (NODE))\n+\n+/* The first decl of an overload.  */\n+#define OVL_FIRST(NODE) ovl_first (NODE)\n+/* The name of the overload set.  */\n+#define OVL_NAME(NODE) DECL_NAME (OVL_FIRST (NODE))\n+\n+/* Whether this is a set of overloaded functions.  TEMPLATE_DECLS are\n+   always wrapped in an OVERLOAD, so we don't need to check them\n+   here.  */\n+#define OVL_P(NODE)                                                            \\\n+  (TREE_CODE (NODE) == FUNCTION_DECL || TREE_CODE (NODE) == OVERLOAD)\n+/* Whether this is a single member overload.  */\n+#define OVL_SINGLE_P(NODE) (TREE_CODE (NODE) != OVERLOAD || !OVL_CHAIN (NODE))\n+\n+/* Nonzero means that this type has an X() constructor.  */\n+#define TYPE_HAS_DEFAULT_CONSTRUCTOR(NODE)                                     \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->has_default_ctor)\n+\n+/* Nonzero means that NODE (a class type) has a default constructor --\n+   but that it has not yet been declared.  */\n+#define CLASSTYPE_LAZY_DEFAULT_CTOR(NODE)                                      \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->lazy_default_ctor)\n+\n+/* A FUNCTION_DECL or OVERLOAD for the constructors for NODE.  These\n+   are the constructors that take an in-charge parameter.  */\n+#define CLASSTYPE_CONSTRUCTORS(NODE)                                           \\\n+  (get_class_binding_direct (NODE, ctor_identifier))\n+\n+/* In a TREE_LIST in an attribute list, indicates that the attribute\n+   must be applied at instantiation time.  */\n+#define ATTR_IS_DEPENDENT(NODE) TREE_LANG_FLAG_0 (TREE_LIST_CHECK (NODE))\n+\n+/* In a TREE_LIST in the argument of attribute abi_tag, indicates that the tag\n+   was inherited from a template parameter, not explicitly indicated.  */\n+#define ABI_TAG_IMPLICIT(NODE) TREE_LANG_FLAG_0 (TREE_LIST_CHECK (NODE))\n+\n+/* In a TREE_LIST for a parameter-declaration-list, indicates that all the\n+   parameters in the list have declarators enclosed in ().  */\n+#define PARENTHESIZED_LIST_P(NODE) TREE_LANG_FLAG_0 (TREE_LIST_CHECK (NODE))\n+\n+/* Non zero if this is a using decl for a dependent scope. */\n+#define DECL_DEPENDENT_P(NODE) DECL_LANG_FLAG_0 (USING_DECL_CHECK (NODE))\n+\n+/* The scope named in a using decl.  */\n+#define USING_DECL_SCOPE(NODE) DECL_RESULT_FLD (USING_DECL_CHECK (NODE))\n+\n+/* The decls named by a using decl.  */\n+#define USING_DECL_DECLS(NODE) DECL_INITIAL (USING_DECL_CHECK (NODE))\n+\n+/* Non zero if the using decl refers to a dependent type.  */\n+#define USING_DECL_TYPENAME_P(NODE) DECL_LANG_FLAG_1 (USING_DECL_CHECK (NODE))\n+\n+/* True if member using decl NODE refers to a non-inherited NODE.  */\n+#define USING_DECL_UNRELATED_P(NODE) DECL_LANG_FLAG_2 (USING_DECL_CHECK (NODE))\n+\n+/* Nonzero if NODE declares a function.  */\n+#define DECL_DECLARES_FUNCTION_P(NODE) (TREE_CODE (NODE) == FUNCTION_DECL)\n+\n+/* Nonzero for a NODE which declares a type.  */\n+#define DECL_DECLARES_TYPE_P(NODE) (TREE_CODE (NODE) == TYPE_DECL)\n+\n+/* Kind bits.  */\n+#define IDENTIFIER_KIND_BIT_0(NODE)                                            \\\n+  TREE_LANG_FLAG_0 (IDENTIFIER_NODE_CHECK (NODE))\n+#define IDENTIFIER_KIND_BIT_1(NODE)                                            \\\n+  TREE_LANG_FLAG_1 (IDENTIFIER_NODE_CHECK (NODE))\n+#define IDENTIFIER_KIND_BIT_2(NODE)                                            \\\n+  TREE_LANG_FLAG_2 (IDENTIFIER_NODE_CHECK (NODE))\n+\n+/* Used by various search routines.  */\n+#define IDENTIFIER_MARKED(NODE) TREE_LANG_FLAG_4 (IDENTIFIER_NODE_CHECK (NODE))\n+\n+/* Nonzero if this identifier is used as a virtual function name somewhere\n+   (optimizes searches).  */\n+#define IDENTIFIER_VIRTUAL_P(NODE)                                             \\\n+  TREE_LANG_FLAG_5 (IDENTIFIER_NODE_CHECK (NODE))\n+\n+/* True if this identifier is a reserved word.  C_RID_CODE (node) is\n+   then the RID_* value of the keyword.  Value 1.  */\n+#define IDENTIFIER_KEYWORD_P(NODE)                                             \\\n+  ((!IDENTIFIER_KIND_BIT_2 (NODE)) & (!IDENTIFIER_KIND_BIT_1 (NODE))           \\\n+   & IDENTIFIER_KIND_BIT_0 (NODE))\n+\n+/* True if this identifier is the name of a constructor or\n+   destructor.  Value 2 or 3.  */\n+#define IDENTIFIER_CDTOR_P(NODE)                                               \\\n+  ((!IDENTIFIER_KIND_BIT_2 (NODE)) & IDENTIFIER_KIND_BIT_1 (NODE))\n+\n+/* True if this identifier is the name of a constructor.  Value 2.  */\n+#define IDENTIFIER_CTOR_P(NODE)                                                \\\n+  (IDENTIFIER_CDTOR_P (NODE) & (!IDENTIFIER_KIND_BIT_0 (NODE)))\n+\n+/* True if this identifier is the name of a destructor.  Value 3.  */\n+#define IDENTIFIER_DTOR_P(NODE)                                                \\\n+  (IDENTIFIER_CDTOR_P (NODE) & IDENTIFIER_KIND_BIT_0 (NODE))\n+\n+/* True if this identifier is for any operator name (including\n+   conversions).  Value 4, 5, 6 or 7.  */\n+#define IDENTIFIER_ANY_OP_P(NODE) (IDENTIFIER_KIND_BIT_2 (NODE))\n+\n+/* True if this identifier is for an overloaded operator. Values 4, 5.  */\n+#define IDENTIFIER_OVL_OP_P(NODE)                                              \\\n+  (IDENTIFIER_ANY_OP_P (NODE) & (!IDENTIFIER_KIND_BIT_1 (NODE)))\n+\n+/* True if this identifier is for any assignment. Values 5.  */\n+#define IDENTIFIER_ASSIGN_OP_P(NODE)                                           \\\n+  (IDENTIFIER_OVL_OP_P (NODE) & IDENTIFIER_KIND_BIT_0 (NODE))\n+\n+/* True if this identifier is the name of a type-conversion\n+   operator.  Value 7.  */\n+#define IDENTIFIER_CONV_OP_P(NODE)                                             \\\n+  (IDENTIFIER_ANY_OP_P (NODE) & IDENTIFIER_KIND_BIT_1 (NODE)                   \\\n+   & (!IDENTIFIER_KIND_BIT_0 (NODE)))\n+\n+/* True if this identifier is a new or delete operator.  */\n+#define IDENTIFIER_NEWDEL_OP_P(NODE)                                           \\\n+  (IDENTIFIER_OVL_OP_P (NODE)                                                  \\\n+   && IDENTIFIER_OVL_OP_FLAGS (NODE) & OVL_OP_FLAG_ALLOC)\n+\n+/* True if this identifier is a new operator.  */\n+#define IDENTIFIER_NEW_OP_P(NODE)                                              \\\n+  (IDENTIFIER_OVL_OP_P (NODE)                                                  \\\n+   && (IDENTIFIER_OVL_OP_FLAGS (NODE)                                          \\\n+       & (OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_DELETE))                             \\\n+\t== OVL_OP_FLAG_ALLOC)\n+\n+/* Nonzero if the class NODE has multiple paths to the same (virtual)\n+   base object.  */\n+#define CLASSTYPE_DIAMOND_SHAPED_P(NODE)                                       \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->diamond_shaped)\n+\n+/* Nonzero if the class NODE has multiple instances of the same base\n+   type.  */\n+#define CLASSTYPE_REPEATED_BASE_P(NODE)                                        \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->repeated_base)\n+\n+/* The member function with which the vtable will be emitted:\n+   the first noninline non-pure-virtual member function.  NULL_TREE\n+   if there is no key function or if this is a class template */\n+#define CLASSTYPE_KEY_METHOD(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->key_method)\n+\n+/* Vector of members.  During definition, it is unordered and only\n+   member functions are present.  After completion it is sorted and\n+   contains both member functions and non-functions.  STAT_HACK is\n+   involved to preserve oneslot per name invariant.  */\n+#define CLASSTYPE_MEMBER_VEC(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->members)\n+\n+/* For class templates, this is a TREE_LIST of all member data,\n+   functions, types, and friends in the order of declaration.\n+   The TREE_PURPOSE of each TREE_LIST is NULL_TREE for a friend,\n+   and the RECORD_TYPE for the class template otherwise.  */\n+#define CLASSTYPE_DECL_LIST(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->decl_list)\n+\n+/* A FUNCTION_DECL or OVERLOAD for the constructors for NODE.  These\n+   are the constructors that take an in-charge parameter.  */\n+#define CLASSTYPE_CONSTRUCTORS(NODE)                                           \\\n+  (get_class_binding_direct (NODE, ctor_identifier))\n+\n+/* A FUNCTION_DECL for the destructor for NODE.  This is the\n+   destructors that take an in-charge parameter.  If\n+   CLASSTYPE_LAZY_DESTRUCTOR is true, then this entry will be NULL\n+   until the destructor is created with lazily_declare_fn.  */\n+#define CLASSTYPE_DESTRUCTOR(NODE)                                             \\\n+  (get_class_binding_direct (NODE, dtor_identifier))\n+\n+/* Nonzero if NODE has a primary base class, i.e., a base class with\n+   which it shares the virtual function table pointer.  */\n+#define CLASSTYPE_HAS_PRIMARY_BASE_P(NODE)                                     \\\n+  (CLASSTYPE_PRIMARY_BINFO (NODE) != NULL_TREE)\n+\n+/* If non-NULL, this is the binfo for the primary base class, i.e.,\n+   the base class which contains the virtual function table pointer\n+   for this class.  */\n+#define CLASSTYPE_PRIMARY_BINFO(NODE)                                          \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->primary_base)\n+\n+/* A vector of BINFOs for the direct and indirect virtual base classes\n+   that this type uses in a post-order depth-first left-to-right\n+   order.  (In other words, these bases appear in the order that they\n+   should be initialized.)  */\n+#define CLASSTYPE_VBASECLASSES(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->vbases)\n+\n+/* The type corresponding to NODE when NODE is used as a base class,\n+   i.e., NODE without virtual base classes or tail padding.  */\n+#define CLASSTYPE_AS_BASE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->as_base)\n+\n+/* Nonzero if NODE is a user-defined conversion operator.  */\n+#define DECL_CONV_FN_P(NODE) IDENTIFIER_CONV_OP_P (DECL_NAME (NODE))\n+\n+/* The type to which conversion operator FN converts to.   */\n+#define DECL_CONV_FN_TYPE(FN)                                                  \\\n+  TREE_TYPE ((gcc_checking_assert (DECL_CONV_FN_P (FN)), DECL_NAME (FN)))\n+\n+/* Returns nonzero iff TYPE1 and TYPE2 are the same type, in the usual\n+   sense of `same'.  */\n+#define same_type_p(TYPE1, TYPE2) comptypes ((TYPE1), (TYPE2), COMPARE_STRICT)\n+\n+/* Nonzero if T is a type that could resolve to any kind of concrete type\n+   at instantiation time.  */\n+#define WILDCARD_TYPE_P(T)                                                     \\\n+  (TREE_CODE (T) == TEMPLATE_TYPE_PARM || TREE_CODE (T) == TYPENAME_TYPE       \\\n+   || TREE_CODE (T) == TYPEOF_TYPE                                             \\\n+   || TREE_CODE (T) == BOUND_TEMPLATE_TEMPLATE_PARM                            \\\n+   || TREE_CODE (T) == DECLTYPE_TYPE                                           \\\n+   || TREE_CODE (T) == DEPENDENT_OPERATOR_TYPE)\n+\n+/* Nonzero if T is a class (or struct or union) type.  Also nonzero\n+   for template type parameters, typename types, and instantiated\n+   template template parameters.  Keep these checks in ascending code\n+   order.  */\n+#define MAYBE_CLASS_TYPE_P(T) (WILDCARD_TYPE_P (T) || CLASS_TYPE_P (T))\n+\n // Below macros are copied from gcc/c-family/c-common.h\n \n /* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n@@ -481,6 +712,126 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n \n // Above macros are copied from gcc/c-family/c-common.h\n \n+// Below macros are copied from gcc/cp/name-lookup.cc\n+\n+/* Create an overload suitable for recording an artificial TYPE_DECL\n+   and another decl.  We use this machanism to implement the struct\n+   stat hack.  */\n+\n+#define STAT_HACK_P(N) ((N) && TREE_CODE (N) == OVERLOAD && OVL_LOOKUP_P (N))\n+#define STAT_TYPE_VISIBLE_P(N) TREE_USED (OVERLOAD_CHECK (N))\n+#define STAT_TYPE(N) TREE_TYPE (N)\n+#define STAT_DECL(N) OVL_FUNCTION (N)\n+#define STAT_VISIBLE(N) OVL_CHAIN (N)\n+#define MAYBE_STAT_DECL(N) (STAT_HACK_P (N) ? STAT_DECL (N) : N)\n+#define MAYBE_STAT_TYPE(N) (STAT_HACK_P (N) ? STAT_TYPE (N) : NULL_TREE)\n+\n+/* When a STAT_HACK_P is true, OVL_USING_P and OVL_EXPORT_P are valid\n+   and apply to the hacked type.  */\n+\n+/* For regular (maybe) overloaded functions, we have OVL_HIDDEN_P.\n+   But we also need to indicate hiddenness on implicit type decls\n+   (injected friend classes), and (coming soon) decls injected from\n+   block-scope externs.  It is too awkward to press the existing\n+   overload marking for that.  If we have a hidden non-function, we\n+   always create a STAT_HACK, and use these two markers as needed.  */\n+#define STAT_TYPE_HIDDEN_P(N) OVL_HIDDEN_P (N)\n+#define STAT_DECL_HIDDEN_P(N) OVL_DEDUP_P (N)\n+\n+// Above macros are copied from gcc/cp/name-lookup.cc\n+\n+// forked from gcc/cp/cp-tree.h tree_overload\n+\n+/* OVL_HIDDEN_P nodes come before other nodes.  */\n+\n+struct GTY (()) tree_overload\n+{\n+  struct tree_common common;\n+  tree function;\n+};\n+\n+// forked from gcc/cp/cp-tree.h ovl_iterator\n+\n+class ovl_iterator\n+{\n+  tree ovl;\n+  const bool allow_inner; /* Only used when checking.  */\n+\n+public:\n+  explicit ovl_iterator (tree o, bool allow = false)\n+    : ovl (o), allow_inner (allow)\n+  {}\n+\n+public:\n+  operator bool () const { return ovl; }\n+  ovl_iterator &operator++ ()\n+  {\n+    ovl = TREE_CODE (ovl) != OVERLOAD ? NULL_TREE : OVL_CHAIN (ovl);\n+    return *this;\n+  }\n+  tree operator* () const\n+  {\n+    tree fn = TREE_CODE (ovl) != OVERLOAD ? ovl : OVL_FUNCTION (ovl);\n+\n+    /* Check this is not an unexpected 2-dimensional overload.  */\n+    gcc_checking_assert (allow_inner || TREE_CODE (fn) != OVERLOAD);\n+\n+    return fn;\n+  }\n+  bool operator== (const ovl_iterator &o) const { return ovl == o.ovl; }\n+  tree get_using () const\n+  {\n+    gcc_checking_assert (using_p ());\n+    return ovl;\n+  }\n+\n+public:\n+  /* Whether this overload was introduced by a using decl.  */\n+  bool using_p () const\n+  {\n+    return (TREE_CODE (ovl) == USING_DECL\n+\t    || (TREE_CODE (ovl) == OVERLOAD && OVL_USING_P (ovl)));\n+  }\n+  /* Whether this using is being exported.  */\n+  bool exporting_p () const { return OVL_EXPORT_P (get_using ()); }\n+\n+  bool hidden_p () const\n+  {\n+    return TREE_CODE (ovl) == OVERLOAD && OVL_HIDDEN_P (ovl);\n+  }\n+\n+public:\n+  tree remove_node (tree head) { return remove_node (head, ovl); }\n+  tree reveal_node (tree head) { return reveal_node (head, ovl); }\n+\n+protected:\n+  /* If we have a nested overload, point at the inner overload and\n+     return the next link on the outer one.  */\n+  tree maybe_push ()\n+  {\n+    tree r = NULL_TREE;\n+\n+    if (ovl && TREE_CODE (ovl) == OVERLOAD && OVL_NESTED_P (ovl))\n+      {\n+\tr = OVL_CHAIN (ovl);\n+\tovl = OVL_FUNCTION (ovl);\n+      }\n+    return r;\n+  }\n+  /* Restore an outer nested overload.  */\n+  void pop (tree outer)\n+  {\n+    gcc_checking_assert (!ovl);\n+    ovl = outer;\n+  }\n+\n+private:\n+  /* We make these static functions to avoid the address of the\n+     iterator escaping the local context.  */\n+  static tree remove_node (tree head, tree node);\n+  static tree reveal_node (tree ovl, tree node);\n+};\n+\n // forked from gcc/cp/cp-tree.h treee_pair_s\n \n struct GTY (()) tree_pair_s\n@@ -602,6 +953,71 @@ struct GTY (()) lang_type\n \n namespace Rust {\n \n+// forked from gcc/cp/cp-tree.h tsubst_flags\n+\n+/* Bitmask flags to control type substitution.  */\n+enum tsubst_flags\n+{\n+  tf_none = 0,\t\t\t/* nothing special */\n+  tf_error = 1 << 0,\t\t/* give error messages  */\n+  tf_warning = 1 << 1,\t\t/* give warnings too  */\n+  tf_ignore_bad_quals = 1 << 2, /* ignore bad cvr qualifiers */\n+  tf_keep_type_decl = 1 << 3,\t/* retain typedef type decls\n+\t\t\t\t   (make_typename_type use) */\n+  tf_ptrmem_ok = 1 << 4,\t/* pointers to member ok (internal\n+\t\t\t\t   instantiate_type use) */\n+  tf_user = 1 << 5,\t\t/* found template must be a user template\n+\t\t\t\t   (lookup_template_class use) */\n+  tf_conv = 1 << 6,\t\t/* We are determining what kind of\n+\t\t\t\t   conversion might be permissible,\n+\t\t\t\t   not actually performing the\n+\t\t\t\t   conversion.  */\n+  tf_decltype = 1 << 7,\t\t/* We are the operand of decltype.\n+\t\t\t\t   Used to implement the special rules\n+\t\t\t\t   for calls in decltype (5.2.2/11).  */\n+  tf_partial = 1 << 8,\t\t/* Doing initial explicit argument\n+\t\t\t\t   substitution in fn_type_unification.  */\n+  tf_fndecl_type = 1 << 9,\t/* Substituting the type of a function\n+\t\t\t\t   declaration.  */\n+  tf_no_cleanup = 1 << 10,\t/* Do not build a cleanup\n+\t\t\t\t   (build_target_expr and friends) */\n+  tf_norm = 1 << 11,\t\t/* Build diagnostic information during\n+\t\t\t\t   constraint normalization.  */\n+  /* Convenient substitution flags combinations.  */\n+  tf_warning_or_error = tf_warning | tf_error\n+};\n+\n+// forked from gcc/cp/cp-tree.h cp_identifier_kind\n+\n+/* Kinds of identifiers.  Values are carefully chosen.  */\n+enum cp_identifier_kind\n+{\n+  cik_normal = 0,\t      /* Not a special identifier.  */\n+  cik_keyword = 1,\t      /* A keyword.  */\n+  cik_ctor = 2,\t\t      /* Constructor (in-chg, complete or base).  */\n+  cik_dtor = 3,\t\t      /* Destructor (in-chg, deleting, complete or\n+\t\t\t\t base).  */\n+  cik_simple_op = 4,\t      /* Non-assignment operator name.  */\n+  cik_assign_op = 5,\t      /* An assignment operator name.  */\n+  cik_conv_op = 6,\t      /* Conversion operator name.  */\n+  cik_reserved_for_udlit = 7, /* Not yet in use  */\n+  cik_max\n+};\n+\n+// forked from gcc/cp/cp-tree.h tag_types\n+\n+/* An enumeration of the kind of tags that C++ accepts.  */\n+enum tag_types\n+{\n+  none_type = 0, /* Not a tag type.  */\n+  record_type,\t /* \"struct\" types.  */\n+  class_type,\t /* \"class\" types.  */\n+  union_type,\t /* \"union\" types.  */\n+  enum_type,\t /* \"enum\" types.  */\n+  typename_type, /* \"typename\" types.  */\n+  scope_type\t /* namespace or tagged type name followed by :: */\n+};\n+\n // forked from gcc/cp/cp-tree.h tsubst_flags_t\n \n /* This type is used for parameters and variables which hold\n@@ -752,11 +1168,19 @@ extern bool var_in_maybe_constexpr_fn (tree);\n extern int\n rs_type_quals (const_tree type);\n \n+inline bool type_unknown_p (const_tree);\n+\n extern bool decl_maybe_constant_var_p (tree);\n \n extern void\n init_modules ();\n \n+extern bool var_in_constexpr_fn (tree);\n+\n+inline tree ovl_first (tree) ATTRIBUTE_PURE;\n+\n+inline bool type_unknown_p (const_tree);\n+\n extern tree\n rs_walk_subtrees (tree *, int *, walk_tree_fn, void *, hash_set<tree> *);\n #define rs_walk_tree(tp, func, data, pset)                                     \\\n@@ -783,6 +1207,26 @@ rs_expr_loc_or_input_loc (const_tree t)\n   return rs_expr_loc_or_loc (t, input_location);\n }\n \n+// forked from gcc/cp/cp-tree.h type_unknown_p\n+\n+inline bool\n+type_unknown_p (const_tree expr)\n+{\n+  return TREE_TYPE (expr) == unknown_type_node;\n+}\n+\n+// forked from gcc/cp/cp-tree.h ovl_first\n+\n+/* Inline bodies.  */\n+\n+inline tree\n+ovl_first (tree node)\n+{\n+  while (TREE_CODE (node) == OVERLOAD)\n+    node = OVL_FUNCTION (node);\n+  return node;\n+}\n+\n } // namespace Rust\n \n #endif // RUST_TREE"}]}