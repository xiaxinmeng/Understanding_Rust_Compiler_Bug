{"sha": "880a145176767b720c110f2a9a489c348e3c58c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgwYTE0NTE3Njc2N2I3MjBjMTEwZjJhOWE0ODljMzQ4ZTNjNThjMQ==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@google.com", "date": "2010-07-28T05:08:24Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2010-07-28T05:08:24Z"}, "message": "Fix to expose more LIM when creating mem_ref\n\nFrom-SVN: r162616", "tree": {"sha": "4aac93f0b4fa63b70f418feead28f5de88f862ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4aac93f0b4fa63b70f418feead28f5de88f862ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/880a145176767b720c110f2a9a489c348e3c58c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880a145176767b720c110f2a9a489c348e3c58c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/880a145176767b720c110f2a9a489c348e3c58c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880a145176767b720c110f2a9a489c348e3c58c1/comments", "author": {"login": "vns-mn", "id": 57157229, "node_id": "MDQ6VXNlcjU3MTU3MjI5", "avatar_url": "https://avatars.githubusercontent.com/u/57157229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vns-mn", "html_url": "https://github.com/vns-mn", "followers_url": "https://api.github.com/users/vns-mn/followers", "following_url": "https://api.github.com/users/vns-mn/following{/other_user}", "gists_url": "https://api.github.com/users/vns-mn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vns-mn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vns-mn/subscriptions", "organizations_url": "https://api.github.com/users/vns-mn/orgs", "repos_url": "https://api.github.com/users/vns-mn/repos", "events_url": "https://api.github.com/users/vns-mn/events{/privacy}", "received_events_url": "https://api.github.com/users/vns-mn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6fb58a378d9b05673bc77934e4e71baa981127fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fb58a378d9b05673bc77934e4e71baa981127fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fb58a378d9b05673bc77934e4e71baa981127fb"}], "stats": {"total": 71, "additions": 58, "deletions": 13}, "files": [{"sha": "1d0b5356c662b0f3a7f1b9ea8a7bafd1d4ccf435", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880a145176767b720c110f2a9a489c348e3c58c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880a145176767b720c110f2a9a489c348e3c58c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=880a145176767b720c110f2a9a489c348e3c58c1", "patch": "@@ -1,3 +1,10 @@\n+2010-07-27  Xinliang David Li <davidxl@google.com>\n+\t* tree-flow.h (create_mem_ref): Add one new parameter.\n+\t* tree-ssa-address.c (create_mem_ref): New parameter.\n+\t(addr_to_parts): Ditto.\n+\t(move_variant_to_index): New function.\n+\t* tree-ssa-loop-ivopts.c (rewrite_use_address): Pass new argument.\n+\n 2010-07-27  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* rtl.def (DEBUG_INSN, INSN, JUMP_INSN, CALL_INSN, NOTE): Swap operands"}, {"sha": "abbf9172a1ce65a6b1fa91be5300490612f1c3ff", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880a145176767b720c110f2a9a489c348e3c58c1/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880a145176767b720c110f2a9a489c348e3c58c1/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=880a145176767b720c110f2a9a489c348e3c58c1", "patch": "@@ -832,8 +832,8 @@ struct mem_address\n };\n \n struct affine_tree_combination;\n-tree create_mem_ref (gimple_stmt_iterator *, tree, tree,\n-\t\t     struct affine_tree_combination *, tree, bool);\n+tree create_mem_ref (gimple_stmt_iterator *, tree,\n+\t\t     struct affine_tree_combination *, tree, tree, tree, bool);\n rtx addr_for_mem_ref (struct mem_address *, addr_space_t, bool);\n void get_address_description (tree, struct mem_address *);\n tree maybe_fold_tmr (tree);"}, {"sha": "474a7986a232b7d6f627944c42db50369fefa624", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880a145176767b720c110f2a9a489c348e3c58c1/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880a145176767b720c110f2a9a489c348e3c58c1/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=880a145176767b720c110f2a9a489c348e3c58c1", "patch": "@@ -470,6 +470,31 @@ move_pointer_to_base (struct mem_address *parts, aff_tree *addr)\n   aff_combination_remove_elt (addr, i);\n }\n \n+/* Moves the loop variant part V in linear address ADDR to be the index\n+   of PARTS.  */\n+\n+static void\n+move_variant_to_index (struct mem_address *parts, aff_tree *addr, tree v)\n+{\n+  unsigned i;\n+  tree val = NULL_TREE;\n+\n+  gcc_assert (!parts->index);\n+  for (i = 0; i < addr->n; i++)\n+    {\n+      val = addr->elts[i].val;\n+      if (operand_equal_p (val, v, 0))\n+\tbreak;\n+    }\n+\n+  if (i == addr->n)\n+    return;\n+\n+  parts->index = fold_convert (sizetype, val);\n+  parts->step = double_int_to_tree (sizetype, addr->elts[i].coef);\n+  aff_combination_remove_elt (addr, i);\n+}\n+\n /* Adds ELT to PARTS.  */\n \n static void\n@@ -573,7 +598,8 @@ most_expensive_mult_to_index (tree type, struct mem_address *parts,\n \n /* Splits address ADDR for a memory access of type TYPE into PARTS.\n    If BASE_HINT is non-NULL, it specifies an SSA name to be used\n-   preferentially as base of the reference.\n+   preferentially as base of the reference, and IV_CAND is the selected\n+   iv candidate used in ADDR.\n \n    TODO -- be more clever about the distribution of the elements of ADDR\n    to PARTS.  Some architectures do not support anything but single\n@@ -583,8 +609,9 @@ most_expensive_mult_to_index (tree type, struct mem_address *parts,\n    addressing modes is useless.  */\n \n static void\n-addr_to_parts (tree type, aff_tree *addr, tree base_hint,\n-\t       struct mem_address *parts, bool speed)\n+addr_to_parts (tree type, aff_tree *addr, tree iv_cand,\n+\t       tree base_hint, struct mem_address *parts,\n+               bool speed)\n {\n   tree part;\n   unsigned i;\n@@ -602,9 +629,17 @@ addr_to_parts (tree type, aff_tree *addr, tree base_hint,\n   /* Try to find a symbol.  */\n   move_fixed_address_to_symbol (parts, addr);\n \n+  /* No need to do address parts reassociation if the number of parts\n+     is <= 2 -- in that case, no loop invariant code motion can be\n+     exposed.  */\n+\n+  if (!base_hint && (addr->n > 2))\n+    move_variant_to_index (parts, addr, iv_cand);\n+\n   /* First move the most expensive feasible multiplication\n      to index.  */\n-  most_expensive_mult_to_index (type, parts, addr, speed);\n+  if (!parts->index)\n+    most_expensive_mult_to_index (type, parts, addr, speed);\n \n   /* Try to find a base of the reference.  Since at the moment\n      there is no reliable way how to distinguish between pointer and its\n@@ -644,17 +679,19 @@ gimplify_mem_ref_parts (gimple_stmt_iterator *gsi, struct mem_address *parts)\n \n /* Creates and returns a TARGET_MEM_REF for address ADDR.  If necessary\n    computations are emitted in front of GSI.  TYPE is the mode\n-   of created memory reference.  */\n+   of created memory reference. IV_CAND is the selected iv candidate in ADDR,\n+   and BASE_HINT is non NULL if IV_CAND comes from a base address\n+   object.  */\n \n tree\n-create_mem_ref (gimple_stmt_iterator *gsi, tree type, tree alias_ptr_type,\n-\t\taff_tree *addr, tree base_hint, bool speed)\n+create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n+\t\ttree alias_ptr_type, tree iv_cand, tree base_hint, bool speed)\n {\n   tree mem_ref, tmp;\n   tree atype;\n   struct mem_address parts;\n \n-  addr_to_parts (type, addr, base_hint, &parts, speed);\n+  addr_to_parts (type, addr, iv_cand, base_hint, &parts, speed);\n   gimplify_mem_ref_parts (gsi, &parts);\n   mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts);\n   if (mem_ref)"}, {"sha": "478a01902500c9417da4c2ec622220256854827e", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880a145176767b720c110f2a9a489c348e3c58c1/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880a145176767b720c110f2a9a489c348e3c58c1/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=880a145176767b720c110f2a9a489c348e3c58c1", "patch": "@@ -5745,7 +5745,7 @@ rewrite_use_address (struct ivopts_data *data,\n   aff_tree aff;\n   gimple_stmt_iterator bsi = gsi_for_stmt (use->stmt);\n   tree base_hint = NULL_TREE;\n-  tree ref;\n+  tree ref, iv;\n   bool ok;\n \n   adjust_iv_update_pos (cand, use);\n@@ -5767,9 +5767,10 @@ rewrite_use_address (struct ivopts_data *data,\n   if (cand->iv->base_object)\n     base_hint = var_at_stmt (data->current_loop, cand, use->stmt);\n \n-  ref = create_mem_ref (&bsi, TREE_TYPE (*use->op_p),\n+  iv = var_at_stmt (data->current_loop, cand, use->stmt);\n+  ref = create_mem_ref (&bsi, TREE_TYPE (*use->op_p), &aff,\n \t\t\treference_alias_ptr_type (*use->op_p),\n-\t\t\t&aff, base_hint, data->speed);\n+\t\t\tiv, base_hint, data->speed);\n   copy_ref_info (ref, *use->op_p);\n   *use->op_p = ref;\n }"}]}