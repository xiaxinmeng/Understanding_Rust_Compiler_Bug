{"sha": "35b0708052ed3381ee58d4e6251e3e43da411a4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzViMDcwODA1MmVkMzM4MWVlNThkNGU2MjUxZTNlNDNkYTQxMWE0ZQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-03-05T22:05:18Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-03-05T22:05:18Z"}, "message": "basic-block.h (EDGE_IRREDUCIBLE_LOOP, [...]): New.\n\n\t* basic-block.h (EDGE_IRREDUCIBLE_LOOP, EDGE_ALL_FLAGS): New.\n\t* cfg.c (dump_edge_info): Add EDGE_IRREDUCIBLE_LOOP flag dump.\n\t* cfgloop.c (flow_loop_free): Made global.\n\t(establish_preds): New static function.\n\t(flow_loop_tree_node_add): Handle subloops of added loop correctly.\n\t(get_loop_exit_edges): New.\n\t(verify_loop_structure): Verify EDGE_IRREDUCIBLE_LOOP flags.\n\t* cfgloop.h (flow_loop_free, get_loop_exit_edges, unloop): Declare.\n\t* cfgloopanal.c (mark_irreducible_loops): Mark edges in irreducible\n\tloops.\n\t* cfgloopmanip.c (loop_delete_branch_edge): Allow to test for\n\tremovability of an edge.\n\t(fix_irreducible_loops): New static function.\n\t(find_path, remove_path): Add ability to remove enclosing loops.\n\t(unloop): New.\n\t(copy_bbs, duplicate_loop_to_header_edge): Use EDGE_IRREDUCIBLE_LOOP\n\tflags.\n\t* cfgrtl.c (verify_flow_info): Handle EDGE_IRREDUCIBLE_LOOP flag.\n\t* loop-unroll.c (peel_loops_completely): Do not duplicate loop if\n\tnot neccessary.\n\t(decide_peel_completely, peel_loops_completely): Allow complete peeling\n\tof non-duplicable once rolling loops.\n\t* loop-unswitch.c (unswitch_loop): Update EDGE_IRREDUCIBLE_LOOP flags.\n\nFrom-SVN: r63864", "tree": {"sha": "8650ebaed410b4e61e93edf3cebafec476c895b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8650ebaed410b4e61e93edf3cebafec476c895b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35b0708052ed3381ee58d4e6251e3e43da411a4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b0708052ed3381ee58d4e6251e3e43da411a4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35b0708052ed3381ee58d4e6251e3e43da411a4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b0708052ed3381ee58d4e6251e3e43da411a4e/comments", "author": null, "committer": null, "parents": [{"sha": "bb182d238a42a4f354734e89389561d0ff05db1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb182d238a42a4f354734e89389561d0ff05db1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb182d238a42a4f354734e89389561d0ff05db1a"}], "stats": {"total": 562, "additions": 426, "deletions": 136}, "files": [{"sha": "6b9031309e2d359156d6c3262f876fe670355573", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35b0708052ed3381ee58d4e6251e3e43da411a4e", "patch": "@@ -1,3 +1,29 @@\n+2003-03-05  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* basic-block.h (EDGE_IRREDUCIBLE_LOOP, EDGE_ALL_FLAGS): New.\n+\t* cfg.c (dump_edge_info): Add EDGE_IRREDUCIBLE_LOOP flag dump.\n+\t* cfgloop.c (flow_loop_free): Made global.\n+\t(establish_preds): New static function.\n+\t(flow_loop_tree_node_add): Handle subloops of added loop correctly.\n+\t(get_loop_exit_edges): New.\n+\t(verify_loop_structure): Verify EDGE_IRREDUCIBLE_LOOP flags.\n+\t* cfgloop.h (flow_loop_free, get_loop_exit_edges, unloop): Declare.\n+\t* cfgloopanal.c (mark_irreducible_loops): Mark edges in irreducible\n+\tloops.\n+\t* cfgloopmanip.c (loop_delete_branch_edge): Allow to test for\n+\tremovability of an edge.\n+\t(fix_irreducible_loops): New static function.\n+\t(find_path, remove_path): Add ability to remove enclosing loops.\n+\t(unloop): New.\n+\t(copy_bbs, duplicate_loop_to_header_edge): Use EDGE_IRREDUCIBLE_LOOP\n+\tflags.\n+\t* cfgrtl.c (verify_flow_info): Handle EDGE_IRREDUCIBLE_LOOP flag.\n+\t* loop-unroll.c (peel_loops_completely): Do not duplicate loop if\n+\tnot neccessary.\n+\t(decide_peel_completely, peel_loops_completely): Allow complete peeling\n+\tof non-duplicable once rolling loops.\n+\t* loop-unswitch.c (unswitch_loop): Update EDGE_IRREDUCIBLE_LOOP flags.\n+\n Wed Mar  5 21:40:57 2003  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* sh.h (OVERRIDE_OPTIONS): For TARGET_SHMEDIA, the minimum value"}, {"sha": "e62419fa8db9e57fcec8d7b7cd4df631c4b7d7ed", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=35b0708052ed3381ee58d4e6251e3e43da411a4e", "patch": "@@ -150,6 +150,8 @@ typedef struct edge_def {\n #define EDGE_DFS_BACK\t\t32\t/* A backwards edge */\n #define EDGE_CAN_FALLTHRU\t64\t/* Candidate for straight line\n \t\t\t\t\t   flow.  */\n+#define EDGE_IRREDUCIBLE_LOOP\t128\t/* Part of irreducible loop.  */\n+#define EDGE_ALL_FLAGS\t\t255\n \n #define EDGE_COMPLEX\t(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)\n \n@@ -540,7 +542,7 @@ extern void init_flow                   PARAMS ((void));\n extern void reorder_basic_blocks\tPARAMS ((void));\n extern void dump_bb\t\t\tPARAMS ((basic_block, FILE *));\n extern void debug_bb\t\t\tPARAMS ((basic_block));\n-extern void debug_bb_n\t\t\tPARAMS ((int));\n+extern basic_block debug_bb_n\t\tPARAMS ((int));\n extern void dump_regset\t\t\tPARAMS ((regset, FILE *));\n extern void debug_regset\t\tPARAMS ((regset));\n extern void allocate_reg_life_data      PARAMS ((void));"}, {"sha": "de7a21204bdc41813b2fe102dc89c474b1eaf09f", "filename": "gcc/cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=35b0708052ed3381ee58d4e6251e3e43da411a4e", "patch": "@@ -639,7 +639,7 @@ dump_edge_info (file, e, do_succ)\n   if (e->flags)\n     {\n       static const char * const bitnames[]\n-\t= {\"fallthru\", \"ab\", \"abcall\", \"eh\", \"fake\", \"dfs_back\", \"can_fallthru\"};\n+\t= {\"fallthru\", \"ab\", \"abcall\", \"eh\", \"fake\", \"dfs_back\", \"can_fallthru\",\"irreducible\"};\n       int comma = 0;\n       int i, flags = e->flags;\n "}, {"sha": "92d905569932d32713957fdd442c56a351f5dfd8", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 87, "deletions": 11, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=35b0708052ed3381ee58d4e6251e3e43da411a4e", "patch": "@@ -43,12 +43,12 @@ static basic_block flow_loop_pre_header_find PARAMS ((basic_block,\n \t\t\t\t\t\t      dominance_info));\n static int flow_loop_level_compute\tPARAMS ((struct loop *));\n static int flow_loops_level_compute\tPARAMS ((struct loops *));\n+static void establish_preds\t\tPARAMS ((struct loop *));\n static basic_block make_forwarder_block PARAMS ((basic_block, int, int,\n \t\t\t\t\t\t edge, int));\n static void canonicalize_loop_headers   PARAMS ((void));\n static bool glb_enum_p PARAMS ((basic_block, void *));\n static void redirect_edge_with_latch_update PARAMS ((edge, basic_block));\n-static void flow_loop_free PARAMS ((struct loop *));\n \f\n /* Dump loop related CFG information.  */\n \n@@ -185,7 +185,7 @@ flow_loops_dump (loops, file, loop_dump_aux, verbose)\n }\n \n /* Free data allocated for LOOP.  */\n-static void\n+void\n flow_loop_free (loop)\n      struct loop *loop;\n {\n@@ -447,8 +447,26 @@ flow_loop_pre_header_find (header, dom)\n   return pre_header;\n }\n \n+static void\n+establish_preds (loop)\n+     struct loop *loop;\n+{\n+  struct loop *ploop, *father = loop->outer;\n+\n+  loop->depth = father->depth + 1;\n+  if (loop->pred)\n+    free (loop->pred);\n+  loop->pred = xmalloc (sizeof (struct loop *) * loop->depth);\n+  memcpy (loop->pred, father->pred, sizeof (struct loop *) * father->depth);\n+  loop->pred[father->depth] = father;\n+\n+  for (ploop = loop->inner; ploop; ploop = ploop->next)\n+    establish_preds (ploop);\n+}\n+\n /* Add LOOP to the loop hierarchy tree where FATHER is father of the\n-   added loop.  */\n+   added loop.  If LOOP has some children, take care of that their\n+   pred field will be initialized correctly.  */\n \n void\n flow_loop_tree_node_add (father, loop)\n@@ -459,10 +477,7 @@ flow_loop_tree_node_add (father, loop)\n   father->inner = loop;\n   loop->outer = father;\n \n-  loop->depth = father->depth + 1;\n-  loop->pred = xmalloc (sizeof (struct loop *) * loop->depth);\n-  memcpy (loop->pred, father->pred, sizeof (struct loop *) * father->depth);\n-  loop->pred[father->depth] = father;\n+  establish_preds (loop);\n }\n \n /* Remove LOOP from the loop hierarchy tree.  */\n@@ -1029,6 +1044,37 @@ get_loop_body (loop)\n   return tovisit;\n }\n \n+/* Gets exit edges of a LOOP, returning their number in N_EDGES.  */\n+edge *\n+get_loop_exit_edges (loop, n_edges)\n+     const struct loop *loop;\n+     unsigned *n_edges;\n+{\n+  edge *edges, e;\n+  unsigned i, n;\n+  basic_block * body;\n+\n+  if (loop->latch == EXIT_BLOCK_PTR)\n+    abort ();\n+\n+  body = get_loop_body (loop);\n+  n = 0;\n+  for (i = 0; i < loop->num_nodes; i++)\n+    for (e = body[i]->succ; e; e = e->succ_next)\n+      if (!flow_bb_inside_loop_p (loop, e->dest))\n+\tn++;\n+  edges = xmalloc (n * sizeof (edge));\n+  *n_edges = n;\n+  n = 0;\n+  for (i = 0; i < loop->num_nodes; i++)\n+    for (e = body[i]->succ; e; e = e->succ_next)\n+      if (!flow_bb_inside_loop_p (loop, e->dest))\n+\tedges[n++] = e;\n+  free (body);\n+\n+  return edges;\n+}\n+\n /* Adds basic block BB to LOOP.  */\n void\n add_bb_to_loop (bb, loop)\n@@ -1135,6 +1181,7 @@ verify_loop_structure (loops)\n   basic_block *bbs, bb;\n   struct loop *loop;\n   int err = 0;\n+  edge e;\n \n   /* Check sizes.  */\n   sizes = xcalloc (loops->num, sizeof (int));\n@@ -1215,6 +1262,12 @@ verify_loop_structure (loops)\n \t  error (\"Loop %d's header does not belong directly to it.\", i);\n \t  err = 1;\n \t}\n+      if ((loops->state & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n+\t  && (loop_latch_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP))\n+\t{\n+\t  error (\"Loop %d's latch is marked as part of irreducible region.\", i);\n+\t  err = 1;\n+\t}\n     }\n \n   /* Check irreducible loops.  */\n@@ -1223,10 +1276,15 @@ verify_loop_structure (loops)\n       /* Record old info.  */\n       irreds = sbitmap_alloc (last_basic_block);\n       FOR_EACH_BB (bb)\n-\tif (bb->flags & BB_IRREDUCIBLE_LOOP)\n-\t  SET_BIT (irreds, bb->index);\n-\telse\n-\t  RESET_BIT (irreds, bb->index);\n+\t{\n+\t  if (bb->flags & BB_IRREDUCIBLE_LOOP)\n+\t    SET_BIT (irreds, bb->index);\n+\t  else\n+\t    RESET_BIT (irreds, bb->index);\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    if (e->flags & EDGE_IRREDUCIBLE_LOOP)\n+      \t      e->flags |= EDGE_ALL_FLAGS + 1;\n+\t}\n \n       /* Recount it.  */\n       mark_irreducible_loops (loops);\n@@ -1246,6 +1304,24 @@ verify_loop_structure (loops)\n \t      error (\"Basic block %d should not be marked irreducible.\", bb->index);\n \t      err = 1;\n \t    }\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    {\n+\t      if ((e->flags & EDGE_IRREDUCIBLE_LOOP)\n+\t\t  && !(e->flags & (EDGE_ALL_FLAGS + 1)))\n+\t\t{\n+\t\t  error (\"Edge from %d to %d should be marked irreducible.\",\n+\t\t\t e->src->index, e->dest->index);\n+\t\t  err = 1;\n+\t\t}\n+\t      else if (!(e->flags & EDGE_IRREDUCIBLE_LOOP)\n+\t\t       && (e->flags & (EDGE_ALL_FLAGS + 1)))\n+\t\t{\n+\t\t  error (\"Edge from %d to %d should not be marked irreducible.\",\n+\t\t\t e->src->index, e->dest->index);\n+\t\t  err = 1;\n+\t\t}\n+\t      e->flags &= ~(EDGE_ALL_FLAGS + 1);\n+\t    }\n \t}\n       free (irreds);\n     }"}, {"sha": "c5db9149c9d96e0d369e0b43f005901a8f080128", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=35b0708052ed3381ee58d4e6251e3e43da411a4e", "patch": "@@ -266,6 +266,7 @@ extern void flow_loop_dump\t\tPARAMS ((const struct loop *, FILE *,\n \t\t\t\t\t\tFILE *, int), int));\n extern int flow_loop_scan\t\tPARAMS ((struct loops *,\n \t\t\t\t\t\tstruct loop *, int));\n+extern void flow_loop_free\t\tPARAMS ((struct loop *));\n void mark_irreducible_loops\t\tPARAMS ((struct loops *));\n \n /* Loop datastructure manipulation/querying.  */\n@@ -282,6 +283,7 @@ extern int average_num_loop_insns\tPARAMS ((struct loop *));\n \n /* Loops & cfg manipulation.  */\n extern basic_block *get_loop_body\tPARAMS ((const struct loop *));\n+extern edge *get_loop_exit_edges\tPARAMS ((const struct loop *, unsigned *));\n \n extern edge loop_preheader_edge\t\tPARAMS ((const struct loop *));\n extern edge loop_latch_edge\t\tPARAMS ((const struct loop *));\n@@ -326,6 +328,7 @@ extern int duplicate_loop_to_header_edge PARAMS ((struct loop *, edge,\n \t\t\t\t\t\tunsigned *, int));\n extern struct loop *loopify\t\tPARAMS ((struct loops *, edge,\n \t\t\t\t\t\tedge, basic_block));\n+extern void unloop\t\t\tPARAMS ((struct loops *, struct loop *));\n extern bool remove_path\t\t\tPARAMS ((struct loops *, edge));\n extern edge split_loop_bb\t\tPARAMS ((struct loops *, basic_block,\n \t\t\t\t\t\trtx));"}, {"sha": "5e00d43259f38e72c19bfd99ac2bebbc3d1caf76", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=35b0708052ed3381ee58d4e6251e3e43da411a4e", "patch": "@@ -819,23 +819,32 @@ simple_loop_p (loops, loop, desc)\n   return any;\n }\n \n-/* Marks blocks that are part of non-recognized loops; i.e. we throw away\n-   all latch edges and mark blocks inside any remaining cycle.  Everything\n-   is a bit complicated due to fact we do not want to do this for parts of\n-   cycles that only \"pass\" through some loop -- i.e. for each cycle, we want\n-   to mark blocks that belong directly to innermost loop containing the whole\n-   cycle.  */\n+/* Marks blocks and edges that are part of non-recognized loops; i.e. we\n+   throw away all latch edges and mark blocks inside any remaining cycle.\n+   Everything is a bit complicated due to fact we do not want to do this\n+   for parts of cycles that only \"pass\" through some loop -- i.e. for\n+   each cycle, we want to mark blocks that belong directly to innermost\n+   loop containing the whole cycle.  */\n void\n mark_irreducible_loops (loops)\n      struct loops *loops;\n {\n   int *dfs_in, *closed, *mr, *mri, *n_edges, *stack;\n   unsigned i;\n   edge **edges, e;\n+  edge *estack;\n   basic_block act;\n   int stack_top, tick, depth;\n   struct loop *cloop;\n \n+  /* Reset the flags.  */\n+  FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+    {\n+      act->flags &= ~BB_IRREDUCIBLE_LOOP;\n+      for (e = act->succ; e; e = e->succ_next)\n+\te->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n+    }\n+\n   /* The first last_basic_block + 1 entries are for real blocks (including\n      entry); then we have loops->num - 1 fake blocks for loops to that we\n      assign edges leading from loops (fake loop 0 is not interesting).  */\n@@ -846,6 +855,7 @@ mark_irreducible_loops (loops)\n   n_edges = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n   edges = xmalloc ((last_basic_block + loops->num) * sizeof (edge *));\n   stack = xmalloc ((n_basic_blocks + loops->num) * sizeof (int));\n+  estack = xmalloc ((n_basic_blocks + loops->num) * sizeof (edge));\n \n   /* Create the edge lists.  */\n   for (i = 0; i < last_basic_block + loops->num; i++)\n@@ -923,7 +933,11 @@ mark_irreducible_loops (loops)\n   stack_top = 0;\n   for (i = 0; i < loops->num; i++)\n     if (loops->parray[i])\n-      stack[stack_top++] = loops->parray[i]->header->index + 1;\n+      {\n+\tstack[stack_top] = loops->parray[i]->header->index + 1;\n+\testack[stack_top] = NULL;\n+\tstack_top++;\n+      }\n \n   while (stack_top)\n     {\n@@ -941,29 +955,39 @@ mark_irreducible_loops (loops)\n \t           : e->dest->index + 1;\n           if (closed[sidx])\n \t    {\n-\t      if (mr[sidx] < mr[idx] && !closed[mri[sidx]])\n+\t      if (!closed[mri[sidx]])\n \t\t{\n-\t\t  mr[idx] = mr[sidx];\n-\t\t  mri[idx] = mri[sidx];\n+\t\t  if (mr[sidx] < mr[idx])\n+\t\t    {\n+\t\t      mr[idx] = mr[sidx];\n+\t\t      mri[idx] = mri[sidx];\n+\t\t    }\n+\n+\t\t  if (mr[sidx] <= dfs_in[idx])\n+\t\t    e->flags |= EDGE_IRREDUCIBLE_LOOP;\n \t\t}\n \t      continue;\n \t    }\n \t  if (dfs_in[sidx] < 0)\n \t    {\n-\t      stack[stack_top++] = sidx;\n+\t      stack[stack_top] = sidx;\n+\t      estack[stack_top] = e;\n+\t      stack_top++;\n \t      goto next;\n \t    }\n \t  if (dfs_in[sidx] < mr[idx])\n \t    {\n \t      mr[idx] = dfs_in[sidx];\n \t      mri[idx] = sidx;\n \t    }\n+\t  e->flags |= EDGE_IRREDUCIBLE_LOOP;\n \t}\n \n       /* Return back.  */\n       closed[idx] = 1;\n+      e = estack[stack_top - 1];\n       stack_top--;\n-      if (stack_top && dfs_in[stack[stack_top - 1]] >= 0)\n+      if (e)\n         {\n \t  /* Propagate information back.  */\n \t  sidx = stack[stack_top - 1];\n@@ -972,6 +996,8 @@ mark_irreducible_loops (loops)\n \t      mr[sidx] = mr[idx];\n \t      mri[sidx] = mri[idx];\n \t    }\n+\t  if (mr[idx] <= dfs_in[sidx])\n+\t    e->flags |= EDGE_IRREDUCIBLE_LOOP;\n \t}\n       /* Mark the block if relevant.  */\n       if (idx && idx <= last_basic_block && mr[idx] <= dfs_in[idx])\n@@ -980,6 +1006,7 @@ next:;\n     }\n \n   free (stack);\n+  free (estack);\n   free (dfs_in);\n   free (closed);\n   free (mr);"}, {"sha": "e2e039ba3ab1e65b2b0add6f00b464454d86371f", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 206, "deletions": 51, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=35b0708052ed3381ee58d4e6251e3e43da411a4e", "patch": "@@ -36,7 +36,7 @@ static void duplicate_subloops\t\tPARAMS ((struct loops *, struct loop *,\n static void copy_loops_to\t\tPARAMS ((struct loops *, struct loop **,\n \t\t\t\t\t\tint, struct loop *));\n static void loop_redirect_edge\t\tPARAMS ((edge, basic_block));\n-static bool loop_delete_branch_edge\tPARAMS ((edge));\n+static bool loop_delete_branch_edge\tPARAMS ((edge, int));\n static void copy_bbs\t\t\tPARAMS ((basic_block *, int, edge,\n \t\t\t\t\t\tedge, basic_block **,\n \t\t\t\t\t\tstruct loops *, edge *,\n@@ -58,6 +58,7 @@ static void record_exit_edges\t\tPARAMS ((edge, basic_block *, int,\n \t\t\t\t\t\tedge *, unsigned *, int));\n static basic_block create_preheader\tPARAMS ((struct loop *, dominance_info,\n \t\t\t\t\t\tint));\n+static void fix_irreducible_loops\tPARAMS ((basic_block));\n \n /* Splits basic block BB after INSN, returns created edge.  Updates loops\n    and dominators.  */\n@@ -128,28 +129,20 @@ remove_bbs (dom, bbs, nbbs)\n \n /* Find path -- i.e. the basic blocks dominated by edge E and put them\n    into array BBS, that will be allocated large enough to contain them.\n-   The number of basic blocks in the path is returned. */\n+   E->dest must have exactly one predecessor for this to work (it is\n+   easy to achieve and we do not put it here because we do not want to\n+   alter anything by this function).  The number of basic blocks in the\n+   path is returned.  */\n static int\n find_path (e, doms, bbs)\n      edge e;\n      dominance_info doms;\n      basic_block **bbs;\n {\n-  edge ae = NULL;\n   struct rpe_data rpe;\n \n   if (e->dest->pred->pred_next)\n-    {\n-      for (ae = e->dest->pred; ae; ae = ae->pred_next)\n-\tif (ae != e && !dominated_by_p (doms, ae->src, e->dest))\n-\t  break;\n-    }\n-  if (ae)\n-    {\n-      /* The path is formed just by the edge.  */\n-      *bbs = NULL;\n-      return 0;\n-    }\n+    abort ();\n \n   /* Find bbs in the path.  */\n   rpe.dom = e->dest;\n@@ -231,7 +224,7 @@ fix_bb_placements (loops, from)\n   /* Prevent us from going out of the base_loop.  */\n   SET_BIT (in_queue, base_loop->header->index);\n \n-  queue = xcalloc (base_loop->num_nodes + 1, sizeof (basic_block));\n+  queue = xmalloc ((base_loop->num_nodes + 1) * sizeof (basic_block));\n   qtop = queue + base_loop->num_nodes + 1;\n   qbeg = queue;\n   qend = queue + 1;\n@@ -296,6 +289,75 @@ fix_bb_placements (loops, from)\n   free (queue);\n }\n \n+/* Basic block from has lost one or more of its predecessors, so it might\n+   mo longer be part irreducible loop.  Fix it and proceed recursively\n+   for its successors if needed.  */\n+static void\n+fix_irreducible_loops (from)\n+     basic_block from;\n+{\n+  basic_block bb;\n+  basic_block *stack;\n+  int stack_top;\n+  sbitmap on_stack;\n+  edge *edges, e;\n+  unsigned n_edges, i;\n+\n+  if (!(from->flags & BB_IRREDUCIBLE_LOOP))\n+    return;\n+\n+  on_stack = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (on_stack);\n+  SET_BIT (on_stack, from->index);\n+  stack = xmalloc (from->loop_father->num_nodes * sizeof (basic_block));\n+  stack[0] = from;\n+  stack_top = 1;\n+\n+  while (stack_top)\n+    {\n+      bb = stack[--stack_top];\n+      RESET_BIT (on_stack, bb->index);\n+\n+      for (e = bb->pred; e; e = e->pred_next)\n+\tif (e->flags & EDGE_IRREDUCIBLE_LOOP)\n+\t  break;\n+      if (e)\n+\tcontinue;\n+\n+      bb->flags &= ~BB_IRREDUCIBLE_LOOP;\n+      if (bb->loop_father->header == bb)\n+\tedges = get_loop_exit_edges (bb->loop_father, &n_edges);\n+      else\n+\t{\n+\t  n_edges = 0;\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    n_edges++;\n+\t  edges = xmalloc (n_edges * sizeof (edge));\n+\t  n_edges = 0;\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    edges[n_edges++] = e;\n+\t}\n+\t\n+      for (i = 0; i < n_edges; i++)\n+\tif (e->flags & EDGE_IRREDUCIBLE_LOOP)\n+\t  {\n+\t    if (!flow_bb_inside_loop_p (from->loop_father, e->dest))\n+\t      continue;\n+\n+\t    e->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n+\t    if (TEST_BIT (on_stack, e->dest->index))\n+  \t      continue;\n+\n+\t    SET_BIT (on_stack, e->dest->index);\n+  \t    stack[stack_top++] = e->dest;\n+\t  }\n+      free (edges);\n+    }\n+\n+  free (on_stack);\n+  free (stack);\n+}\n+\n /* Removes path beginning at edge E, i.e. remove basic blocks dominated by E\n    and update loop structure stored in LOOPS and dominators.  Return true if\n    we were able to remove the path, false otherwise (and nothing is affected\n@@ -310,7 +372,26 @@ remove_path (loops, e)\n   int i, nrem, n_bord_bbs, n_dom_bbs;\n   sbitmap seen;\n \n-  /* First identify the path.  */\n+  if (!loop_delete_branch_edge (e, 0))\n+    return false;\n+\n+  /* We need to check whether basic blocks are dominated by the edge\n+     e, but we only have basic block dominators.  This is easy to\n+     fix -- when e->dest has exactly one predecessor, this corresponds\n+     to blocks dominated by e->dest, if not, split the edge.  */\n+  if (e->dest->pred->pred_next)\n+    e = loop_split_edge_with (e, NULL_RTX, loops)->pred;\n+\n+  /* It may happen that by removing path we remove one or more loops\n+     we belong to.  In this case first unloop the loops, then proceed\n+     normally.   We may assume that e->dest is not a header of any loop,\n+     as it now has exactly one predecessor.  */\n+  while (e->src->loop_father->outer\n+\t && dominated_by_p (loops->cfg.dom,\n+\t\t\t    e->src->loop_father->latch, e->dest))\n+    unloop (loops, e->src->loop_father);\n+  \n+  /* Identify the path.  */\n   nrem = find_path (e, loops->cfg.dom, &rem_bbs);\n \n   n_bord_bbs = 0;\n@@ -321,31 +402,21 @@ remove_path (loops, e)\n   /* Find \"border\" hexes -- i.e. those with predecessor in removed path.  */\n   for (i = 0; i < nrem; i++)\n     SET_BIT (seen, rem_bbs[i]->index);\n-  if (nrem)\n+  for (i = 0; i < nrem; i++)\n     {\n-      for (i = 0; i < nrem; i++)\n-\t{\n-\t  bb = rem_bbs[i];\n-\t  for (ae = rem_bbs[i]->succ; ae; ae = ae->succ_next)\n-\t    if (ae->dest != EXIT_BLOCK_PTR && !TEST_BIT (seen, ae->dest->index))\n-\t      {\n-\t\tSET_BIT (seen, ae->dest->index);\n-\t\tbord_bbs[n_bord_bbs++] = ae->dest;\n-\t      }\n-\t}\n+      bb = rem_bbs[i];\n+      for (ae = rem_bbs[i]->succ; ae; ae = ae->succ_next)\n+\tif (ae->dest != EXIT_BLOCK_PTR && !TEST_BIT (seen, ae->dest->index))\n+\t  {\n+\t    SET_BIT (seen, ae->dest->index);\n+\t    bord_bbs[n_bord_bbs++] = ae->dest;\n+\t  }\n     }\n-  else if (e->dest != EXIT_BLOCK_PTR)\n-    bord_bbs[n_bord_bbs++] = e->dest;\n \n   /* Remove the path.  */\n   from = e->src;\n-  if (!loop_delete_branch_edge (e))\n-    {\n-      free (rem_bbs);\n-      free (bord_bbs);\n-      free (seen);\n-      return false;\n-    }\n+  if (!loop_delete_branch_edge (e, 1))\n+    abort ();\n   dom_bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n \n   /* Cancel loops contained in the path.  */\n@@ -356,7 +427,7 @@ remove_path (loops, e)\n   remove_bbs (loops->cfg.dom, rem_bbs, nrem);\n   free (rem_bbs);\n \n-  /* Find blocks with whose dominators may be affected.  */\n+  /* Find blocks whose dominators may be affected.  */\n   n_dom_bbs = 0;\n   sbitmap_zero (seen);\n   for (i = 0; i < n_bord_bbs; i++)\n@@ -376,13 +447,18 @@ remove_path (loops, e)\n       free(ldom);\n     }\n \n-  free (bord_bbs);\n   free (seen);\n \n   /* Recount dominators.  */\n   iterate_fix_dominators (loops->cfg.dom, dom_bbs, n_dom_bbs);\n   free (dom_bbs);\n \n+  /* These blocks have lost some predecessor(s), thus their irreducible\n+     status could be changed.  */\n+  for (i = 0; i < n_bord_bbs; i++)\n+    fix_irreducible_loops (bord_bbs[i]);\n+  free (bord_bbs);\n+\n   /* Fix placements of basic blocks inside loops and the placement of\n      loops in the loop tree.  */\n   fix_bb_placements (loops, from);\n@@ -557,6 +633,65 @@ loopify (loops, latch_edge, header_edge, switch_bb)\n   return loop;\n }\n \n+/* Remove the latch edge of a LOOP and update LOOPS tree to indicate that\n+   the LOOP was removed.  After this function, original loop latch will\n+   have no successor, which caller is expected to fix somehow.  */\n+void\n+unloop (loops, loop)\n+     struct loops *loops;\n+     struct loop *loop;\n+{\n+  basic_block *body;\n+  struct loop *ploop;\n+  unsigned i, n;\n+  basic_block latch = loop->latch;\n+  edge *edges;\n+  unsigned n_edges;\n+\n+  /* This is relatively straigtforward.  The dominators are unchanged, as\n+     loop header dominates loop latch, so the only thing we have to care of\n+     is the placement of loops and basic blocks inside the loop tree.  We\n+     move them all to the loop->outer, and then let fix_bb_placements do\n+     its work.  */\n+\n+  body = get_loop_body (loop);\n+  edges = get_loop_exit_edges (loop, &n_edges);\n+  n = loop->num_nodes;\n+  for (i = 0; i < n; i++)\n+    if (body[i]->loop_father == loop)\n+      {\n+\tremove_bb_from_loops (body[i]);\n+\tadd_bb_to_loop (body[i], loop->outer);\n+      }\n+  free(body);\n+\n+  while (loop->inner)\n+    {\n+      ploop = loop->inner;\n+      flow_loop_tree_node_remove (ploop);\n+      flow_loop_tree_node_add (loop->outer, ploop);\n+    }\n+\n+  /* Remove the loop and free its data.  */\n+  flow_loop_tree_node_remove (loop);\n+  loops->parray[loop->num] = NULL;\n+  flow_loop_free (loop);\n+\n+  remove_edge (latch->succ);\n+  fix_bb_placements (loops, latch);\n+\n+  /* If the loop was inside an irreducible region, we would have to somehow\n+     update the irreducible marks inside its body.  While it is certainly\n+     possible to do, it is a bit complicated and this situation should be\n+     very rare, so we just remark all loops in this case.  */\n+  for (i = 0; i < n_edges; i++)\n+    if (edges[i]->flags & EDGE_IRREDUCIBLE_LOOP)\n+      break;\n+  if (i != n_edges)\n+    mark_irreducible_loops (loops);\n+  free (edges);\n+}\n+\n /* Fix placement of LOOP inside loop tree, i.e. find the innermost superloop\n    FATHER of LOOP such that all of the edges comming out of LOOP belong to\n    FATHER, and set it as outer loop of LOOP.  Return 1 if placement of\n@@ -696,29 +831,46 @@ loop_redirect_edge (e, dest)\n   cfg_layout_redirect_edge (e, dest);\n }\n \n-/* Deletes edge E from a branch if possible.  */\n+/* Deletes edge E from a branch if possible.  Unless REALLY_DELETE is set,\n+   just test whether it is possible to remove the edge.  */\n static bool\n-loop_delete_branch_edge (e)\n+loop_delete_branch_edge (e, really_delete)\n      edge e;\n+     int really_delete;\n {\n   basic_block src = e->src;\n+  int irr;\n+  edge snd;\n \n   if (src->succ->succ_next)\n     {\n       basic_block newdest;\n+\n       /* Cannot handle more than two exit edges.  */\n       if (src->succ->succ_next->succ_next)\n \treturn false;\n       /* And it must be just a simple branch.  */\n       if (!any_condjump_p (src->end))\n \treturn false;\n \n-      newdest = (e == src->succ\n-\t\t ? src->succ->succ_next->dest : src->succ->dest);\n+      snd = e == src->succ ? src->succ->succ_next : src->succ;\n+      newdest = snd->dest;\n       if (newdest == EXIT_BLOCK_PTR)\n \treturn false;\n \n-      return cfg_layout_redirect_edge (e, newdest);\n+      /* Hopefully the above conditions should suffice.  */\n+      if (!really_delete)\n+\treturn true;\n+\n+      /* Redirecting behaves wrongly wrto this flag.  */\n+      irr = snd->flags & EDGE_IRREDUCIBLE_LOOP;\n+      \n+      if (!cfg_layout_redirect_edge (e, newdest))\n+\treturn false;\n+      src->succ->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n+      src->succ->flags |= irr;\n+\n+      return true;\n     }\n   else\n     {\n@@ -833,6 +985,11 @@ copy_bbs (bbs, n, entry, latch_edge, new_bbs, loops, header_edge, copy_header_ed\n \t  /* Leads to copied loop and it is not latch edge, redirect it.  */\n \t  if (bb != header)\n \t    loop_redirect_edge (e, new_bb);\n+\n+\t  if (add_irreducible_flag\n+\t      && (bb->loop_father == header->loop_father\n+\t\t  || RBI (src)->original->loop_father == header->loop_father))\n+\t    e->flags |= EDGE_IRREDUCIBLE_LOOP;\n \t}\n     }\n \n@@ -1005,7 +1162,7 @@ duplicate_loop_to_header_edge (loop, e, loops, ndupl, wont_exit, orig,\n \t}\n     }\n \n-  add_irreducible_flag = !is_latch && (e->src->flags & BB_IRREDUCIBLE_LOOP);\n+  add_irreducible_flag = !is_latch && (e->flags & EDGE_IRREDUCIBLE_LOOP);\n \n   /* Find edge from latch.  */\n   latch_edge = loop_latch_edge (loop);\n@@ -1355,17 +1512,15 @@ loop_split_edge_with (e, insns, loops)\n   add_to_dominance_info (loops->cfg.dom, new_bb);\n   add_bb_to_loop (new_bb, loop_c);\n   new_bb->flags = insns ? BB_SUPERBLOCK : 0;\n-  if (src->flags & BB_IRREDUCIBLE_LOOP)\n-    {\n-      /* We expect simple preheaders here.  */\n-      if ((dest->flags & BB_IRREDUCIBLE_LOOP)\n-          || dest->loop_father->header == dest)\n-        new_bb->flags |= BB_IRREDUCIBLE_LOOP;\n-    }\n \n   new_e = make_edge (new_bb, dest, EDGE_FALLTHRU);\n   new_e->probability = REG_BR_PROB_BASE;\n   new_e->count = e->count;\n+  if (e->flags & EDGE_IRREDUCIBLE_LOOP)\n+    {\n+      new_bb->flags |= BB_IRREDUCIBLE_LOOP;\n+      new_e->flags |= EDGE_IRREDUCIBLE_LOOP;\n+    }\n \n   new_bb->count = e->count;\n   new_bb->frequency = EDGE_FREQUENCY (e);"}, {"sha": "31f71106251ed454074cc74b5518ab1f600c4c2e", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=35b0708052ed3381ee58d4e6251e3e43da411a4e", "patch": "@@ -1594,11 +1594,13 @@ debug_bb (bb)\n   dump_bb (bb, stderr);\n }\n \n-void\n+basic_block\n debug_bb_n (n)\n      int n;\n {\n-  dump_bb (BASIC_BLOCK (n), stderr);\n+  basic_block bb = BASIC_BLOCK (n);\n+  dump_bb (bb, stderr);\n+  return bb;\n }\n \f\n /* Like print_rtl, but also print out live information for the start of each\n@@ -1866,7 +1868,7 @@ verify_flow_info ()\n \t  if (e->flags & EDGE_FALLTHRU)\n \t    n_fallthru++;\n \n-\t  if ((e->flags & ~(EDGE_DFS_BACK | EDGE_CAN_FALLTHRU)) == 0)\n+\t  if ((e->flags & ~(EDGE_DFS_BACK | EDGE_CAN_FALLTHRU | EDGE_IRREDUCIBLE_LOOP)) == 0)\n \t    n_branch++;\n \n \t  if (e->flags & EDGE_ABNORMAL_CALL)"}, {"sha": "6f945a22a2daa3b6834a412610bc0419630b3562", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 40, "deletions": 47, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=35b0708052ed3381ee58d4e6251e3e43da411a4e", "patch": "@@ -180,25 +180,6 @@ peel_loops_completely (loops, flags)\n \tfprintf (rtl_dump_file, \";; Considering loop %d for complete peeling\\n\",\n \t\t loop->num);\n \n-      /* Do not peel cold areas.  */\n-      if (!maybe_hot_bb_p (loop->header))\n-\t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \";; Not considering loop, cold area\\n\");\n-\t  loop = next;\n-\t  continue;\n-\t}\n-\n-      /* Can the loop be manipulated?  */\n-      if (!can_duplicate_loop_p (loop))\n-\t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file,\n-\t\t     \";; Not considering loop, cannot duplicate\\n\");\n-\t  loop = next;\n-\t  continue;\n-\t}\n-\n       loop->ninsns = num_loop_insns (loop);\n \n       decide_peel_once_rolling (loops, loop, flags);\n@@ -348,6 +329,23 @@ decide_peel_completely (loops, loop, flags)\n       return;\n     }\n \n+  /* Do not peel cold areas.  */\n+  if (!maybe_hot_bb_p (loop->header))\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not considering loop, cold area\\n\");\n+      return;\n+    }\n+\n+  /* Can the loop be manipulated?  */\n+  if (!can_duplicate_loop_p (loop))\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file,\n+\t\t \";; Not considering loop, cannot duplicate\\n\");\n+      return;\n+    }\n+\n   /* npeel = number of iterations to peel. */\n   npeel = PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS) / loop->ninsns;\n   if (npeel > (unsigned) PARAM_VALUE (PARAM_MAX_COMPLETELY_PEEL_TIMES))\n@@ -411,45 +409,40 @@ peel_loop_completely (loops, loop)\n {\n   sbitmap wont_exit;\n   unsigned HOST_WIDE_INT npeel;\n-  edge e;\n   unsigned n_remove_edges, i;\n   edge *remove_edges;\n   struct loop_desc *desc = &loop->desc;\n   \n   npeel = desc->niter;\n \n-  wont_exit = sbitmap_alloc (npeel + 2);\n-  sbitmap_ones (wont_exit);\n-  RESET_BIT (wont_exit, 0);\n-  RESET_BIT (wont_exit, npeel + 1);\n-  if (desc->may_be_zero)\n-    RESET_BIT (wont_exit, 1);\n-\n-  remove_edges = xcalloc (npeel, sizeof (edge));\n-  n_remove_edges = 0;\n-\n-  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\tloops, npeel + 1,\n-\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n-\tDLTHE_FLAG_UPDATE_FREQ))\n-    abort ();\n+  if (npeel)\n+    {\n+      wont_exit = sbitmap_alloc (npeel + 1);\n+      sbitmap_ones (wont_exit);\n+      RESET_BIT (wont_exit, 0);\n+      if (desc->may_be_zero)\n+\tRESET_BIT (wont_exit, 1);\n \n-  free (wont_exit);\n+      remove_edges = xcalloc (npeel, sizeof (edge));\n+      n_remove_edges = 0;\n \n-  /* Remove the exit edges.  */\n-  for (i = 0; i < n_remove_edges; i++)\n-    remove_path (loops, remove_edges[i]);\n-  free (remove_edges);\n+      if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\tloops, npeel,\n+\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n+\t\tDLTHE_FLAG_UPDATE_FREQ))\n+\tabort ();\n \n-  /* Now remove the loop.  */\n-  for (e = RBI (desc->in_edge->src)->copy->succ;\n-       e && e->dest != RBI (desc->in_edge->dest)->copy;\n-       e = e->succ_next);\n+      free (wont_exit);\n \n-  if (!e)\n-    abort ();\n+      /* Remove the exit edges.  */\n+      for (i = 0; i < n_remove_edges; i++)\n+\tremove_path (loops, remove_edges[i]);\n+      free (remove_edges);\n+    }\n \n-  remove_path (loops, e);\n+  /* Now remove the unreachable part of the last iteration and cancel\n+     the loop.  */\n+  remove_path (loops, desc->in_edge);\n \n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \";; Peeled loop completely, %d times\\n\", (int) npeel);"}, {"sha": "fdce1ebff5140c089787a430c5718f21e96befdc", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b0708052ed3381ee58d4e6251e3e43da411a4e/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=35b0708052ed3381ee58d4e6251e3e43da411a4e", "patch": "@@ -335,7 +335,7 @@ unswitch_loop (loops, loop, unswitch_on)\n      struct loop *loop;\n      basic_block unswitch_on;\n {\n-  edge entry, e, latch_edge;\n+  edge entry, latch_edge;\n   basic_block switch_bb, unswitch_on_alt, src;\n   struct loop *nloop;\n   sbitmap zero_bitmap;\n@@ -366,24 +366,34 @@ unswitch_loop (loops, loop, unswitch_on)\n   \n   /* Make a copy.  */\n   src = entry->src;\n-  irred_flag = src->flags & BB_IRREDUCIBLE_LOOP;\n-  src->flags &= ~BB_IRREDUCIBLE_LOOP;\n+  irred_flag = entry->flags & EDGE_IRREDUCIBLE_LOOP;\n+  entry->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n   zero_bitmap = sbitmap_alloc (2);\n   sbitmap_zero (zero_bitmap);\n   if (!duplicate_loop_to_header_edge (loop, entry, loops, 1,\n \tzero_bitmap, NULL, NULL, NULL, 0))\n     return NULL;\n   free (zero_bitmap);\n-  src->flags |= irred_flag;\n+  entry->flags |= irred_flag;\n \n   /* Record the block with condition we unswitch on.  */\n   unswitch_on_alt = RBI (unswitch_on)->copy;\n \n   /* Make a copy of the block containing the condition; we will use\n      it as switch to decide which loop we want to use.  */\n   switch_bb = cfg_layout_duplicate_bb (unswitch_on, NULL);\n-  switch_bb->flags &= ~BB_IRREDUCIBLE_LOOP;\n-  switch_bb->flags |= irred_flag;\n+  if (irred_flag)\n+    {\n+      switch_bb->flags |= BB_IRREDUCIBLE_LOOP;\n+      switch_bb->succ->flags |= EDGE_IRREDUCIBLE_LOOP;\n+      switch_bb->succ->succ_next->flags |= EDGE_IRREDUCIBLE_LOOP;\n+    }\n+  else\n+    {\n+      switch_bb->flags &= ~BB_IRREDUCIBLE_LOOP;\n+      switch_bb->succ->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n+      switch_bb->succ->succ_next->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n+    }\n   add_to_dominance_info (loops->cfg.dom, switch_bb);\n   RBI (unswitch_on)->copy = unswitch_on_alt;\n \n@@ -396,10 +406,6 @@ unswitch_loop (loops, loop, unswitch_on)\n \n   /* Remove branches that are now unreachable in new loops.  We rely on the\n      fact that cfg_layout_duplicate_bb reverses list of edges.  */\n-  for (e = unswitch_on->succ->succ_next->dest->pred; e; e = e->pred_next)\n-    if (e->src != unswitch_on &&\n-\t!dominated_by_p (loops->cfg.dom, e->src, e->dest))\n-      break;\n   remove_path (loops, unswitch_on->succ);\n   remove_path (loops, unswitch_on_alt->succ);\n "}]}