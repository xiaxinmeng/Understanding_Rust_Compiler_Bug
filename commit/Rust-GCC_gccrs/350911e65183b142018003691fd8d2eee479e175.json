{"sha": "350911e65183b142018003691fd8d2eee479e175", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUwOTExZTY1MTgzYjE0MjAxODAwMzY5MWZkOGQyZWVlNDc5ZTE3NQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2015-06-23T01:05:04Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2015-06-23T01:05:04Z"}, "message": "rtlanal.c (commutative_operand_precedence): Correct comments.\n\n\t* rtlanal.c (commutative_operand_precedence): Correct comments.\n\t* simplify-rtx.c (simplify_plus_minus_op_data_cmp): Delete forward\n\tdeclaration.  Return an int.  Distinguish REG,REG return from\n\tothers.\n\t(struct simplify_plus_minus_op_data): Make local to function.\n\t(simplify_plus_minus): Don't set canonicalized if merely sorting\n\tregisters.  Avoid packing ops if nothing changes.  White space fixes.\n\nFrom-SVN: r224768", "tree": {"sha": "341df2ecb89793c16d2d555ad687094c7f9ded14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/341df2ecb89793c16d2d555ad687094c7f9ded14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/350911e65183b142018003691fd8d2eee479e175", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/350911e65183b142018003691fd8d2eee479e175", "html_url": "https://github.com/Rust-GCC/gccrs/commit/350911e65183b142018003691fd8d2eee479e175", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/350911e65183b142018003691fd8d2eee479e175/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6536a0a8759bed9fa7e3b47191c11a7c09254eae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6536a0a8759bed9fa7e3b47191c11a7c09254eae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6536a0a8759bed9fa7e3b47191c11a7c09254eae"}], "stats": {"total": 123, "additions": 77, "deletions": 46}, "files": [{"sha": "540685bc3765e98e9c2da588a35bdced163fca99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350911e65183b142018003691fd8d2eee479e175/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350911e65183b142018003691fd8d2eee479e175/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=350911e65183b142018003691fd8d2eee479e175", "patch": "@@ -1,3 +1,13 @@\n+2015-06-23  Alan Modra  <amodra@gmail.com>\n+\n+\t* rtlanal.c (commutative_operand_precedence): Correct comments.\n+\t* simplify-rtx.c (simplify_plus_minus_op_data_cmp): Delete forward\n+\tdeclaration.  Return an int.  Distinguish REG,REG return from\n+\tothers.\n+\t(struct simplify_plus_minus_op_data): Make local to function.\n+\t(simplify_plus_minus): Don't set canonicalized if merely sorting\n+\tregisters.  Avoid packing ops if nothing changes.  White space fixes.\n+\n 2015-06-22  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* gcc.c (default_compilers): Pass \"-o %g.s\" to cc1 for headers even if"}, {"sha": "86b3b622f89384afb3823b0215de9579da96d96b", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350911e65183b142018003691fd8d2eee479e175/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350911e65183b142018003691fd8d2eee479e175/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=350911e65183b142018003691fd8d2eee479e175", "patch": "@@ -3132,17 +3132,16 @@ regno_use_in (unsigned int regno, rtx x)\n }\n \n /* Return a value indicating whether OP, an operand of a commutative\n-   operation, is preferred as the first or second operand.  The higher\n-   the value, the stronger the preference for being the first operand.\n-   We use negative values to indicate a preference for the first operand\n-   and positive values for the second operand.  */\n+   operation, is preferred as the first or second operand.  The more\n+   positive the value, the stronger the preference for being the first\n+   operand.  */\n \n int\n commutative_operand_precedence (rtx op)\n {\n   enum rtx_code code = GET_CODE (op);\n \n-  /* Constants always come the second operand.  Prefer \"nice\" constants.  */\n+  /* Constants always become the second operand.  Prefer \"nice\" constants.  */\n   if (code == CONST_INT)\n     return -8;\n   if (code == CONST_WIDE_INT)"}, {"sha": "ca8310d15563a05be41957df933e302928ba29e6", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 63, "deletions": 41, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350911e65183b142018003691fd8d2eee479e175/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350911e65183b142018003691fd8d2eee479e175/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=350911e65183b142018003691fd8d2eee479e175", "patch": "@@ -59,7 +59,6 @@ along with GCC; see the file COPYING3.  If not see\n \n static rtx neg_const_int (machine_mode, const_rtx);\n static bool plus_minus_operand_p (const_rtx);\n-static bool simplify_plus_minus_op_data_cmp (rtx, rtx);\n static rtx simplify_plus_minus (enum rtx_code, machine_mode, rtx, rtx);\n static rtx simplify_immed_subreg (machine_mode, rtx, machine_mode,\n \t\t\t\t  unsigned int);\n@@ -4049,41 +4048,44 @@ simplify_const_binary_operation (enum rtx_code code, machine_mode mode,\n \n \n \f\n-/* Simplify a PLUS or MINUS, at least one of whose operands may be another\n-   PLUS or MINUS.\n+/* Return a positive integer if X should sort after Y.  The value\n+   returned is 1 if and only if X and Y are both regs.  */\n \n-   Rather than test for specific case, we do this by a brute-force method\n-   and do all possible simplifications until no more changes occur.  Then\n-   we rebuild the operation.  */\n-\n-struct simplify_plus_minus_op_data\n-{\n-  rtx op;\n-  short neg;\n-};\n-\n-static bool\n+static int\n simplify_plus_minus_op_data_cmp (rtx x, rtx y)\n {\n   int result;\n \n   result = (commutative_operand_precedence (y)\n \t    - commutative_operand_precedence (x));\n   if (result)\n-    return result > 0;\n+    return result + result;\n \n   /* Group together equal REGs to do more simplification.  */\n   if (REG_P (x) && REG_P (y))\n     return REGNO (x) > REGNO (y);\n-  else\n-    return false;\n+\n+  return 0;\n }\n \n+/* Simplify and canonicalize a PLUS or MINUS, at least one of whose\n+   operands may be another PLUS or MINUS.\n+\n+   Rather than test for specific case, we do this by a brute-force method\n+   and do all possible simplifications until no more changes occur.  Then\n+   we rebuild the operation.\n+\n+   May return NULL_RTX when no changes were made.  */\n+\n static rtx\n simplify_plus_minus (enum rtx_code code, machine_mode mode, rtx op0,\n \t\t     rtx op1)\n {\n-  struct simplify_plus_minus_op_data ops[16];\n+  struct simplify_plus_minus_op_data\n+  {\n+    rtx op;\n+    short neg;\n+  } ops[16];\n   rtx result, tem;\n   int n_ops = 2;\n   int changed, n_constants, canonicalized = 0;\n@@ -4124,7 +4126,18 @@ simplify_plus_minus (enum rtx_code code, machine_mode mode, rtx op0,\n \n \t      ops[i].op = XEXP (this_op, 0);\n \t      changed = 1;\n-\t      canonicalized |= this_neg || i != n_ops - 2;\n+\t      /* If this operand was negated then we will potentially\n+\t\t canonicalize the expression.  Similarly if we don't\n+\t\t place the operands adjacent we're re-ordering the\n+\t\t expression and thus might be performing a\n+\t\t canonicalization.  Ignore register re-ordering.\n+\t\t ??? It might be better to shuffle the ops array here,\n+\t\t but then (plus (plus (A, B), plus (C, D))) wouldn't\n+\t\t be seen as non-canonical.  */\n+\t      if (this_neg\n+\t\t  || (i != n_ops - 2\n+\t\t      && !(REG_P (ops[i].op) && REG_P (ops[n_ops - 1].op))))\n+\t\tcanonicalized = 1;\n \t      break;\n \n \t    case NEG:\n@@ -4145,7 +4158,7 @@ simplify_plus_minus (enum rtx_code code, machine_mode mode, rtx op0,\n \t\t  ops[n_ops].neg = this_neg;\n \t\t  n_ops++;\n \t\t  changed = 1;\n-\t          canonicalized = 1;\n+\t\t  canonicalized = 1;\n \t\t}\n \t      break;\n \n@@ -4158,7 +4171,7 @@ simplify_plus_minus (enum rtx_code code, machine_mode mode, rtx op0,\n \t\t  ops[i].op = XEXP (this_op, 0);\n \t\t  ops[i].neg = !this_neg;\n \t\t  changed = 1;\n-\t          canonicalized = 1;\n+\t\t  canonicalized = 1;\n \t\t}\n \t      break;\n \n@@ -4169,7 +4182,7 @@ simplify_plus_minus (enum rtx_code code, machine_mode mode, rtx op0,\n \t\t  ops[i].op = neg_const_int (mode, this_op);\n \t\t  ops[i].neg = 0;\n \t\t  changed = 1;\n-\t          canonicalized = 1;\n+\t\t  canonicalized = 1;\n \t\t}\n \t      break;\n \n@@ -4213,23 +4226,29 @@ simplify_plus_minus (enum rtx_code code, machine_mode mode, rtx op0,\n     }\n \n   /* Now simplify each pair of operands until nothing changes.  */\n-  do\n+  while (1)\n     {\n       /* Insertion sort is good enough for a small array.  */\n       for (i = 1; i < n_ops; i++)\n-        {\n-          struct simplify_plus_minus_op_data save;\n-          j = i - 1;\n-          if (!simplify_plus_minus_op_data_cmp (ops[j].op, ops[i].op))\n+\t{\n+\t  struct simplify_plus_minus_op_data save;\n+\t  int cmp;\n+\n+\t  j = i - 1;\n+\t  cmp = simplify_plus_minus_op_data_cmp (ops[j].op, ops[i].op);\n+\t  if (cmp <= 0)\n \t    continue;\n+\t  /* Just swapping registers doesn't count as canonicalization.  */\n+\t  if (cmp != 1)\n+\t    canonicalized = 1;\n \n-          canonicalized = 1;\n-          save = ops[i];\n-          do\n+\t  save = ops[i];\n+\t  do\n \t    ops[j + 1] = ops[j];\n-          while (j-- && simplify_plus_minus_op_data_cmp (ops[j].op, save.op));\n-          ops[j + 1] = save;\n-        }\n+\t  while (j--\n+\t\t && simplify_plus_minus_op_data_cmp (ops[j].op, save.op) > 0);\n+\t  ops[j + 1] = save;\n+\t}\n \n       changed = 0;\n       for (i = n_ops - 1; i > 0; i--)\n@@ -4258,7 +4277,8 @@ simplify_plus_minus (enum rtx_code code, machine_mode mode, rtx op0,\n \n \t\t    tem_lhs = GET_CODE (lhs) == CONST ? XEXP (lhs, 0) : lhs;\n \t\t    tem_rhs = GET_CODE (rhs) == CONST ? XEXP (rhs, 0) : rhs;\n-\t\t    tem = simplify_binary_operation (ncode, mode, tem_lhs, tem_rhs);\n+\t\t    tem = simplify_binary_operation (ncode, mode, tem_lhs,\n+\t\t\t\t\t\t     tem_rhs);\n \n \t\t    if (tem && !CONSTANT_P (tem))\n \t\t      tem = gen_rtx_CONST (GET_MODE (tem), tem);\n@@ -4296,20 +4316,22 @@ simplify_plus_minus (enum rtx_code code, machine_mode mode, rtx op0,\n \t      }\n \t  }\n \n-      /* If nothing changed, fail.  */\n-      if (!canonicalized)\n-        return NULL_RTX;\n+      if (!changed)\n+\tbreak;\n \n       /* Pack all the operands to the lower-numbered entries.  */\n       for (i = 0, j = 0; j < n_ops; j++)\n-        if (ops[j].op)\n-          {\n+\tif (ops[j].op)\n+\t  {\n \t    ops[i] = ops[j];\n \t    i++;\n-          }\n+\t  }\n       n_ops = i;\n     }\n-  while (changed);\n+\n+  /* If nothing changed, fail.  */\n+  if (!canonicalized)\n+    return NULL_RTX;\n \n   /* Create (minus -C X) instead of (neg (const (plus X C))).  */\n   if (n_ops == 2"}]}