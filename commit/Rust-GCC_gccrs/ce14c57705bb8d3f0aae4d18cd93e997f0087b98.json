{"sha": "ce14c57705bb8d3f0aae4d18cd93e997f0087b98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UxNGM1NzcwNWJiOGQzZjBhYWU0ZDE4Y2Q5M2U5OTdmMDA4N2I5OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-23T12:50:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-23T12:50:44Z"}, "message": "[multiple changes]\n\n2009-07-23  Sergey Rybin  <rybin@adacore.com>\n\n\t* gnat_ugn.texi (Misnamed_Controlling_Parameters gnatcheck rule): Fix\n\tmisprint in rule description.\n\n2009-07-23  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch6.adb (Make_Build_In_Place_Call_In_Object_Declaration): Replace\n\ttest that the object declaration is within an extended return statement\n\twith direct test of whether the declared object associated with the\n\tbuild-in-place call is a return object, since the enclosing function\n\tmight not even be a build-in-place function.\n\n2009-07-23  Robert Dewar  <dewar@adacore.com>\n\n\t* freeze.adb, prj-nmsc.adb, errout.adb: Minor reformatting\n\tMinor code reorganization\n\n2009-07-23  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma): Do not ignore pragma Pack on records\n\tfor static analysis, only packed arrays are causing troubles.\n\nFrom-SVN: r150007", "tree": {"sha": "a6c146cd1bf708864595a00f12b303f54f3a01f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6c146cd1bf708864595a00f12b303f54f3a01f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce14c57705bb8d3f0aae4d18cd93e997f0087b98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce14c57705bb8d3f0aae4d18cd93e997f0087b98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce14c57705bb8d3f0aae4d18cd93e997f0087b98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce14c57705bb8d3f0aae4d18cd93e997f0087b98/comments", "author": null, "committer": null, "parents": [{"sha": "c37845f84190677a661e7ea45f5cd2b2c096c028", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c37845f84190677a661e7ea45f5cd2b2c096c028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c37845f84190677a661e7ea45f5cd2b2c096c028"}], "stats": {"total": 211, "additions": 139, "deletions": 72}, "files": [{"sha": "3178b3e492acaa9952e3d639fa5ce0a23c0a6b58", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce14c57705bb8d3f0aae4d18cd93e997f0087b98/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce14c57705bb8d3f0aae4d18cd93e997f0087b98/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ce14c57705bb8d3f0aae4d18cd93e997f0087b98", "patch": "@@ -1,3 +1,26 @@\n+2009-07-23  Sergey Rybin  <rybin@adacore.com>\n+\n+\t* gnat_ugn.texi (Misnamed_Controlling_Parameters gnatcheck rule): Fix\n+\tmisprint in rule description.\n+\n+2009-07-23  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_ch6.adb (Make_Build_In_Place_Call_In_Object_Declaration): Replace\n+\ttest that the object declaration is within an extended return statement\n+\twith direct test of whether the declared object associated with the\n+\tbuild-in-place call is a return object, since the enclosing function\n+\tmight not even be a build-in-place function.\n+\n+2009-07-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* freeze.adb, prj-nmsc.adb, errout.adb: Minor reformatting\n+\tMinor code reorganization\n+\n+2009-07-23  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma): Do not ignore pragma Pack on records\n+\tfor static analysis, only packed arrays are causing troubles.\n+\n 2009-07-23  Gary Dismukes  <dismukes@adacore.com>\n \n \t* sem_aggr.adb (Resolve_Extension_Aggregate): Report an error when the"}, {"sha": "aa36a9ddaabf4c47e0f8d5140883212ff49988e4", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 68, "deletions": 57, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce14c57705bb8d3f0aae4d18cd93e997f0087b98/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce14c57705bb8d3f0aae4d18cd93e997f0087b98/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=ce14c57705bb8d3f0aae4d18cd93e997f0087b98", "patch": "@@ -2693,9 +2693,9 @@ package body Errout is\n \n          Set_Error_Posted (N);\n \n-         --  If it is a subexpression, then set Error_Posted on parents\n-         --  up to and including the first non-subexpression construct. This\n-         --  helps avoid cascaded error messages within a single expression.\n+         --  If it is a subexpression, then set Error_Posted on parents up to\n+         --  and including the first non-subexpression construct. This helps\n+         --  avoid cascaded error messages within a single expression.\n \n          P := N;\n          loop\n@@ -2735,6 +2735,8 @@ package body Errout is\n    -- Special_Msg_Delete --\n    ------------------------\n \n+   --  Is it really right to have all this specialized knowledge in errout?\n+\n    function Special_Msg_Delete\n      (Msg : String;\n       N   : Node_Or_Entity_Id;\n@@ -2746,51 +2748,61 @@ package body Errout is\n       if Debug_Flag_OO then\n          return False;\n \n-      --  When an atomic object refers to a non-atomic type in the same\n-      --  scope, we implicitly make the type atomic. In the non-error\n-      --  case this is surely safe (and in fact prevents an error from\n-      --  occurring if the type is not atomic by default). But if the\n-      --  object cannot be made atomic, then we introduce an extra junk\n-      --  message by this manipulation, which we get rid of here.\n+      --  Processing for \"atomic access cannot be guaranteed\"\n \n-      --  We identify this case by the fact that it references a type for\n-      --  which Is_Atomic is set, but there is no Atomic pragma setting it.\n+      elsif Msg = \"atomic access to & cannot be guaranteed\" then\n \n-      elsif Msg = \"atomic access to & cannot be guaranteed\"\n-        and then Is_Type (E)\n-        and then Is_Atomic (E)\n-        and then No (Get_Rep_Pragma (E, Name_Atomic))\n-      then\n-         return True;\n+         --  When an atomic object refers to a non-atomic type in the same\n+         --  scope, we implicitly make the type atomic. In the non-error case\n+         --  this is surely safe (and in fact prevents an error from occurring\n+         --  if the type is not atomic by default). But if the object cannot be\n+         --  made atomic, then we introduce an extra junk message by this\n+         --  manipulation, which we get rid of here.\n \n-      --  When a size is wrong for a frozen type there is no explicit\n-      --  size clause, and other errors have occurred, suppress the\n-      --  message, since it is likely that this size error is a cascaded\n-      --  result of other errors. The reason we eliminate unfrozen types\n-      --  is that messages issued before the freeze type are for sure OK.\n-      --  Also suppress \"size too small\" errors in CodePeer mode, since pragma\n-      --  Pack is also ignored in this configuration.\n-\n-      elsif Msg = \"size for& too small, minimum allowed is ^\"\n-        and then (CodePeer_Mode\n-          or else (Is_Frozen (E)\n-            and then Serious_Errors_Detected > 0\n-            and then Nkind (N) /= N_Component_Clause\n-            and then Nkind (Parent (N)) /= N_Component_Clause\n-            and then\n-              No (Get_Attribute_Definition_Clause (E, Attribute_Size))\n-            and then\n-              No (Get_Attribute_Definition_Clause (E, Attribute_Object_Size))\n-            and then\n-              No (Get_Attribute_Definition_Clause (E, Attribute_Value_Size))))\n-      then\n-         return True;\n+         --  We identify this case by the fact that it references a type for\n+         --  which Is_Atomic is set, but there is no Atomic pragma setting it.\n \n-      --  All special tests complete, so go ahead with message\n+         if Is_Type (E)\n+           and then Is_Atomic (E)\n+           and then No (Get_Rep_Pragma (E, Name_Atomic))\n+         then\n+            return True;\n+         end if;\n \n-      else\n-         return False;\n+      --  Processing for \"Size too small\" messages\n+\n+      elsif Msg = \"size for& too small, minimum allowed is ^\" then\n+\n+         --  Suppress \"size too small\" errors in CodePeer mode, since pragma\n+         --  Pack is also ignored in this configuration.\n+\n+         if CodePeer_Mode then\n+            return True;\n+\n+         --  When a size is wrong for a frozen type there is no explicit size\n+         --  clause, and other errors have occurred, suppress the message,\n+         --  since it is likely that this size error is a cascaded result of\n+         --  other errors. The reason we eliminate unfrozen types is that\n+         --  messages issued before the freeze type are for sure OK.\n+\n+         elsif Is_Frozen (E)\n+           and then Serious_Errors_Detected > 0\n+           and then Nkind (N) /= N_Component_Clause\n+           and then Nkind (Parent (N)) /= N_Component_Clause\n+           and then\n+             No (Get_Attribute_Definition_Clause (E, Attribute_Size))\n+           and then\n+             No (Get_Attribute_Definition_Clause (E, Attribute_Object_Size))\n+           and then\n+             No (Get_Attribute_Definition_Clause (E, Attribute_Value_Size))\n+         then\n+            return True;\n+         end if;\n       end if;\n+\n+      --  All special tests complete, so go ahead with message\n+\n+      return False;\n    end Special_Msg_Delete;\n \n    --------------------------\n@@ -2811,18 +2823,18 @@ package body Errout is\n          Msglen := Msglen - 1;\n       end if;\n \n-      --  The loop here deals with recursive types, we are trying to\n-      --  find a related entity that is not an implicit type. Note\n-      --  that the check with Old_Ent stops us from getting \"stuck\".\n-      --  Also, we don't output the \"type derived from\" message more\n-      --  than once in the case where we climb up multiple levels.\n+      --  The loop here deals with recursive types, we are trying to find a\n+      --  related entity that is not an implicit type. Note that the check with\n+      --  Old_Ent stops us from getting \"stuck\". Also, we don't output the\n+      --  \"type derived from\" message more than once in the case where we climb\n+      --  up multiple levels.\n \n       loop\n          Old_Ent := Ent;\n \n-         --  Implicit access type, use directly designated type\n-         --  In Ada 2005, the designated type may be an anonymous access to\n-         --  subprogram, in which case we can only point to its definition.\n+         --  Implicit access type, use directly designated type In Ada 2005,\n+         --  the designated type may be an anonymous access to subprogram, in\n+         --  which case we can only point to its definition.\n \n          if Is_Access_Type (Ent) then\n             if Ekind (Ent) = E_Access_Subprogram_Type\n@@ -2874,13 +2886,12 @@ package body Errout is\n \n             Ent := Base_Type (Ent);\n \n-         --  If this is a base type with a first named subtype, use the\n-         --  first named subtype instead. This is not quite accurate in\n-         --  all cases, but it makes too much noise to be accurate and\n-         --  add 'Base in all cases. Note that we only do this is the\n-         --  first named subtype is not itself an internal name. This\n-         --  avoids the obvious loop (subtype->basetype->subtype) which\n-         --  would otherwise occur!)\n+         --  If this is a base type with a first named subtype, use the first\n+         --  named subtype instead. This is not quite accurate in all cases,\n+         --  but it makes too much noise to be accurate and add 'Base in all\n+         --  cases. Note that we only do this is the first named subtype is not\n+         --  itself an internal name. This avoids the obvious loop (subtype ->\n+         --  basetype -> subtype) which would otherwise occur!)\n \n          elsif Present (Freeze_Node (Ent))\n            and then Present (First_Subtype_Link (Freeze_Node (Ent)))"}, {"sha": "83196ec9caf19e0b6f88fb35c79326b8bd0eae3e", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce14c57705bb8d3f0aae4d18cd93e997f0087b98/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce14c57705bb8d3f0aae4d18cd93e997f0087b98/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=ce14c57705bb8d3f0aae4d18cd93e997f0087b98", "patch": "@@ -5557,9 +5557,15 @@ package body Exp_Ch6 is\n       --  If the function's result subtype is unconstrained and the object is\n       --  a return object of an enclosing build-in-place function, then the\n       --  implicit build-in-place parameters of the enclosing function must be\n-      --  passed along to the called function.\n-\n-      elsif Nkind (Parent (Object_Decl)) = N_Extended_Return_Statement then\n+      --  passed along to the called function. (Unfortunately, this won't cover\n+      --  the case of extension aggregates where the ancestor part is a build-\n+      --  in-place unconstrained function call that should be passed along the\n+      --  caller's parameters. Currently those get mishandled by reassigning\n+      --  the result of the call to the aggregate return object, when the call\n+      --  result should really be directly built in place in the aggregate and\n+      --  not built in a temporary. ???)\n+\n+      elsif Is_Return_Object (Defining_Identifier (Object_Decl)) then\n          Pass_Caller_Acc := True;\n \n          Enclosing_Func := Enclosing_Subprogram (Obj_Def_Id);"}, {"sha": "14ba41c9956c12d13abc0301d02f3a2683906c1c", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce14c57705bb8d3f0aae4d18cd93e997f0087b98/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce14c57705bb8d3f0aae4d18cd93e997f0087b98/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=ce14c57705bb8d3f0aae4d18cd93e997f0087b98", "patch": "@@ -2280,15 +2280,38 @@ package body Freeze is\n             end;\n          end if;\n \n-         --  See if Implicit_Packing would work\n+         --  See if Size is too small as is (and implicit packing might help)\n \n          if not Is_Packed (Rec)\n+\n+           --  No implicit packing if even one component is explicitly placed\n+\n            and then not Placed_Component\n+\n+           --  Must have size clause and all scalar components\n+\n            and then Has_Size_Clause (Rec)\n            and then All_Scalar_Components\n+\n+           --  Do not try implicit packing on records with discriminants, too\n+           --  complicated, especially in the variant record case.\n+\n            and then not Has_Discriminants (Rec)\n+\n+           --  We can implicitly pack if the specified size of the record is\n+           --  less than the sum of the object sizes (no point in packing if\n+           --  this is not the case).\n+\n            and then Esize (Rec) < Scalar_Component_Total_Esize\n+\n+           --  And the total RM size cannot be greater than the specified size\n+           --  since otherwise packing will not get us where we have to be!\n+\n            and then Esize (Rec) >= Scalar_Component_Total_RM_Size\n+\n+           --  Never do implicit packing in CodePeer mode since we don't do\n+           --  any packing ever in this mode (why not???)\n+\n            and then not CodePeer_Mode\n          then\n             --  If implicit packing enabled, do it"}, {"sha": "c2bcfbefe49f1319657de5bd05e46d0beabe6d3a", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce14c57705bb8d3f0aae4d18cd93e997f0087b98/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce14c57705bb8d3f0aae4d18cd93e997f0087b98/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=ce14c57705bb8d3f0aae4d18cd93e997f0087b98", "patch": "@@ -1,4 +1,4 @@\n-\\input texinfo   @c -*-texinfo-*-\n+f\\input texinfo   @c -*-texinfo-*-\n @c %**start of header\n \n @c oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n@@ -21821,7 +21821,7 @@ not a controlling one and its name is not @code{This} (the check for\n parameter name is not case-sensitive). Declarations of dispatching functions\n with controlling result and no controlling parameter are never flagged.\n \n-A subprogram body declaration, subprogram renaming declaration of subprogram\n+A subprogram body declaration, subprogram renaming declaration or subprogram\n body stub is flagged only if it is not a completion of a prior subprogram\n declaration.\n "}, {"sha": "f0ded903ff9afd41e5f18e3336c7faee5eea7c2d", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce14c57705bb8d3f0aae4d18cd93e997f0087b98/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce14c57705bb8d3f0aae4d18cd93e997f0087b98/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=ce14c57705bb8d3f0aae4d18cd93e997f0087b98", "patch": "@@ -498,6 +498,7 @@ package body Prj.Nmsc is\n \n       begin\n          --  On non case-sensitive systems, use proper suffix casing\n+\n          Canonical_Case_File_Name (Suf);\n \n          --  The file name must end with the suffix (which is not an extension)"}, {"sha": "902cb30e8252481f396d2276d4415ea98bb7b96f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce14c57705bb8d3f0aae4d18cd93e997f0087b98/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce14c57705bb8d3f0aae4d18cd93e997f0087b98/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=ce14c57705bb8d3f0aae4d18cd93e997f0087b98", "patch": "@@ -9508,15 +9508,23 @@ package body Sem_Prag is\n \n                else\n                   if not Rep_Item_Too_Late (Typ, N) then\n+\n+                     --  In the context of static code analysis, we do not need\n+                     --  complex front-end expansions related to pragma Pack,\n+                     --  so disable handling of pragma Pack in this case.\n+\n                      if CodePeer_Mode then\n-                        --  Ignore pragma Pack and disable corresponding\n-                        --  complex expansions in CodePeer mode\n                         null;\n \n+                     --  For normal non-VM target, do the packing\n+\n                      elsif VM_Target = No_VM then\n                         Set_Is_Packed            (Base_Type (Typ));\n                         Set_Has_Pragma_Pack      (Base_Type (Typ));\n-                        Set_Has_Non_Standard_Rep (Base_Type (Typ));\n+                           Set_Has_Non_Standard_Rep (Base_Type (Typ));\n+\n+                     --  If we ignore the pack, then warn about this, except\n+                     --  that we suppress the warning in GNAT mode.\n \n                      elsif not GNAT_Mode then\n                         Error_Pragma\n@@ -9529,12 +9537,7 @@ package body Sem_Prag is\n \n             else pragma Assert (Is_Record_Type (Typ));\n                if not Rep_Item_Too_Late (Typ, N) then\n-                  if CodePeer_Mode then\n-                     --  Ignore pragma Pack and disable corresponding\n-                     --  complex expansions in CodePeer mode\n-                     null;\n-\n-                  elsif VM_Target = No_VM then\n+                  if VM_Target = No_VM then\n                      Set_Is_Packed            (Base_Type (Typ));\n                      Set_Has_Pragma_Pack      (Base_Type (Typ));\n                      Set_Has_Non_Standard_Rep (Base_Type (Typ));"}]}