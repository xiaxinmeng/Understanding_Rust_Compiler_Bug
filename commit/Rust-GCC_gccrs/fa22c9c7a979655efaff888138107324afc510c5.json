{"sha": "fa22c9c7a979655efaff888138107324afc510c5", "node_id": "C_kwDOANBUbNoAKGZhMjJjOWM3YTk3OTY1NWVmYWZmODg4MTM4MTA3MzI0YWZjNTEwYzU", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-10T13:02:51Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-30T12:46:14Z"}, "message": "Implement ggc_vrange_allocator.\n\nThis patch makes the vrange_allocator an abstract class, and uses it\nto implement the obstack allocator as well as a new GC allocator.\n\nThe GC bits will be used to implement the vrange storage class for\nglobal ranges, which will be contributed in the next week or so.\n\nTested and benchmarked on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* gimple-range-cache.cc (block_range_cache::block_range_cache):\n\tRename vrange_allocator to obstack_vrange_allocator.\n\t(ssa_global_cache::ssa_global_cache): Same.\n\t* gimple-range-edge.h (class gimple_outgoing_range): Same.\n\t* gimple-range-infer.h (class infer_range_manager): Same.\n\t* value-range.h (class vrange_allocator): Make abstract.\n\t(class obstack_vrange_allocator): Inherit from vrange_allocator.\n\t(class ggc_vrange_allocator): New.", "tree": {"sha": "5984ddb70b6a5a84d452bd97003c04bc711f6ac7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5984ddb70b6a5a84d452bd97003c04bc711f6ac7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa22c9c7a979655efaff888138107324afc510c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa22c9c7a979655efaff888138107324afc510c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa22c9c7a979655efaff888138107324afc510c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa22c9c7a979655efaff888138107324afc510c5/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47e36785cd2ba35a577b0678a2ac185288eb9e52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e36785cd2ba35a577b0678a2ac185288eb9e52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47e36785cd2ba35a577b0678a2ac185288eb9e52"}], "stats": {"total": 65, "additions": 40, "deletions": 25}, "files": [{"sha": "5bb52d5f70f4e544ad8e5cf4e6239e0dc30c6c49", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa22c9c7a979655efaff888138107324afc510c5/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa22c9c7a979655efaff888138107324afc510c5/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=fa22c9c7a979655efaff888138107324afc510c5", "patch": "@@ -320,7 +320,7 @@ block_range_cache::block_range_cache ()\n   bitmap_obstack_initialize (&m_bitmaps);\n   m_ssa_ranges.create (0);\n   m_ssa_ranges.safe_grow_cleared (num_ssa_names);\n-  m_range_allocator = new vrange_allocator;\n+  m_range_allocator = new obstack_vrange_allocator;\n }\n \n // Remove any m_block_caches which have been created.\n@@ -478,7 +478,7 @@ block_range_cache::dump (FILE *f, basic_block bb, bool print_varying)\n ssa_global_cache::ssa_global_cache ()\n {\n   m_tab.create (0);\n-  m_range_allocator = new vrange_allocator;\n+  m_range_allocator = new obstack_vrange_allocator;\n }\n \n // Deconstruct a global cache."}, {"sha": "c81b943dae6dc10a616f0a2c37a579c5fdd2bb64", "filename": "gcc/gimple-range-edge.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa22c9c7a979655efaff888138107324afc510c5/gcc%2Fgimple-range-edge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa22c9c7a979655efaff888138107324afc510c5/gcc%2Fgimple-range-edge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-edge.h?ref=fa22c9c7a979655efaff888138107324afc510c5", "patch": "@@ -47,7 +47,7 @@ class gimple_outgoing_range\n \n   int m_max_edges;\n   hash_map<edge, irange *> *m_edge_table;\n-  vrange_allocator m_range_allocator;\n+  obstack_vrange_allocator m_range_allocator;\n };\n \n // If there is a range control statement at the end of block BB, return it."}, {"sha": "bf27d0d3423a4571fc635d0a0c01740170711832", "filename": "gcc/gimple-range-infer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa22c9c7a979655efaff888138107324afc510c5/gcc%2Fgimple-range-infer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa22c9c7a979655efaff888138107324afc510c5/gcc%2Fgimple-range-infer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-infer.h?ref=fa22c9c7a979655efaff888138107324afc510c5", "patch": "@@ -78,7 +78,7 @@ class infer_range_manager\n   bitmap m_seen;\n   bitmap_obstack m_bitmaps;\n   struct obstack m_list_obstack;\n-  vrange_allocator m_range_allocator;\n+  obstack_vrange_allocator m_range_allocator;\n };\n \n #endif // GCC_GIMPLE_RANGE_SIDE_H"}, {"sha": "627d221fe0fd3445b5f671c5321b7c807dea759a", "filename": "gcc/value-range.h", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa22c9c7a979655efaff888138107324afc510c5/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa22c9c7a979655efaff888138107324afc510c5/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=fa22c9c7a979655efaff888138107324afc510c5", "patch": "@@ -903,39 +903,54 @@ vrp_val_min (const_tree type)\n class vrange_allocator\n {\n public:\n-  vrange_allocator ();\n-  ~vrange_allocator ();\n+  vrange_allocator () { }\n+  virtual ~vrange_allocator () { }\n   // Allocate a range of TYPE.\n   vrange *alloc_vrange (tree type);\n   // Allocate a memory block of BYTES.\n-  void *alloc (unsigned bytes);\n+  virtual void *alloc (unsigned bytes) = 0;\n+  virtual void free (void *p) = 0;\n   // Return a clone of SRC.\n   template <typename T> T *clone (const T &src);\n private:\n   irange *alloc_irange (unsigned pairs);\n-  DISABLE_COPY_AND_ASSIGN (vrange_allocator);\n-  struct obstack m_obstack;\n+  void operator= (const vrange_allocator &) = delete;\n };\n \n-inline\n-vrange_allocator::vrange_allocator ()\n+class obstack_vrange_allocator : public vrange_allocator\n {\n-  obstack_init (&m_obstack);\n-}\n-\n-inline\n-vrange_allocator::~vrange_allocator ()\n-{\n-  obstack_free (&m_obstack, NULL);\n-}\n-\n-// Provide a hunk of memory from the obstack.\n+public:\n+  obstack_vrange_allocator ()\n+  {\n+    obstack_init (&m_obstack);\n+  }\n+  virtual ~obstack_vrange_allocator () final override\n+  {\n+    obstack_free (&m_obstack, NULL);\n+  }\n+  virtual void *alloc (unsigned bytes) final override\n+  {\n+    return obstack_alloc (&m_obstack, bytes);\n+  }\n+  virtual void free (void *) final override { }\n+private:\n+  obstack m_obstack;\n+};\n \n-inline void *\n-vrange_allocator::alloc (unsigned bytes)\n+class ggc_vrange_allocator : public vrange_allocator\n {\n-  return obstack_alloc (&m_obstack, bytes);\n-}\n+public:\n+  ggc_vrange_allocator () { }\n+  virtual ~ggc_vrange_allocator () final override { }\n+  virtual void *alloc (unsigned bytes) final override\n+  {\n+    return ggc_internal_alloc (bytes);\n+  }\n+  virtual void free (void *p) final override\n+  {\n+    return ggc_free (p);\n+  }\n+};\n \n // Return a new range to hold ranges of TYPE.  The newly allocated\n // range is initialized to VR_UNDEFINED."}]}