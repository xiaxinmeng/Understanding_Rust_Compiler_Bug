{"sha": "ba4a3d54bac34bb261bacffd774d9810d679d971", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE0YTNkNTRiYWMzNGJiMjYxYmFjZmZkNzc0ZDk4MTBkNjc5ZDk3MQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2005-05-26T06:26:17Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2005-05-26T06:26:17Z"}, "message": "re PR fortran/17283 (UNPACK issues)\n\n2005-05-26  Thomas Koenig  <Thomas.Koenig@online.de>\n\n        PR libfortran/17283\n        * gfortran.fortran-torture/execute/intrinsic_unpack.f90:\n        Test callee-allocated memory with write statements.\n\n2005-05-26  Thomas Koenig  <Thomas.Koenig@online.de>\n\n        PR libfortran/17283\n        * intrinsics/unpack_generic.c:  Fix name of routine\n        on top.  Update copyright years.\n        (unpack1):  Remove const from return array descriptor.\n        rs:  New variable, for calculating return sizes.\n        Populate return array descriptor if ret->data is NULL.\n\nFrom-SVN: r100189", "tree": {"sha": "2dfb829db3fc4cd9eef650e2f573a400e0c914ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dfb829db3fc4cd9eef650e2f573a400e0c914ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba4a3d54bac34bb261bacffd774d9810d679d971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4a3d54bac34bb261bacffd774d9810d679d971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba4a3d54bac34bb261bacffd774d9810d679d971", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4a3d54bac34bb261bacffd774d9810d679d971/comments", "author": null, "committer": null, "parents": [{"sha": "c10166c437ce15a119b663ac153a6bbcddb1ce84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c10166c437ce15a119b663ac153a6bbcddb1ce84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c10166c437ce15a119b663ac153a6bbcddb1ce84"}], "stats": {"total": 70, "additions": 57, "deletions": 13}, "files": [{"sha": "aaff962c88f9421d16ee89fa3664b1dd5e80bc65", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4a3d54bac34bb261bacffd774d9810d679d971/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4a3d54bac34bb261bacffd774d9810d679d971/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ba4a3d54bac34bb261bacffd774d9810d679d971", "patch": "@@ -1,3 +1,9 @@\n+2005-05-26  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/17283\n+\t* gfortran.fortran-torture/execute/intrinsic_unpack.f90:\n+\tTest callee-allocated memory with write statements.\n+\n 2005-05-25  Roger Sayle  <roger@eyesopen.com>\n \n \tPR middle-end/21709"}, {"sha": "88f09c321b4d7c065dddd43bd755eccb87ec3060", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_unpack.f90", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4a3d54bac34bb261bacffd774d9810d679d971/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_unpack.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4a3d54bac34bb261bacffd774d9810d679d971/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_unpack.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_unpack.f90?ref=ba4a3d54bac34bb261bacffd774d9810d679d971", "patch": "@@ -2,6 +2,7 @@\n program intrinsic_unpack\n    integer, dimension(3, 3) :: a, b\n    logical, dimension(3, 3) :: mask;\n+   character(len=50) line1, line2\n    integer i\n \n    mask = reshape ((/.false.,.true.,.false.,.true.,.false.,.false.,&\n@@ -10,6 +11,9 @@ program intrinsic_unpack\n    b = unpack ((/2, 3, 4/), mask, a)\n    if (any (b .ne. reshape ((/1, 2, 0, 3, 1, 0, 0, 0, 4/), (/3, 3/)))) &\n       call abort\n+   write (line1,'(10I4)') b\n+   write (line2,'(10I4)') unpack((/2, 3, 4/), mask, a)\n+   if (line1 .ne. line2) call abort\n    b = -1\n    b = unpack ((/2, 3, 4/), mask, 0)\n    if (any (b .ne. reshape ((/0, 2, 0, 3, 0, 0, 0, 0, 4/), (/3, 3/)))) &"}, {"sha": "8f2e25d9d29f141fafbf25127c4396f11820d246", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4a3d54bac34bb261bacffd774d9810d679d971/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4a3d54bac34bb261bacffd774d9810d679d971/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=ba4a3d54bac34bb261bacffd774d9810d679d971", "patch": "@@ -1,3 +1,12 @@\n+2005-05-26  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/17283\n+\t* intrinsics/unpack_generic.c:  Fix name of routine\n+\ton top.  Update copyright years.\n+\t(unpack1):  Remove const from return array descriptor.\n+\trs:  New variable, for calculating return sizes.\n+\tPopulate return array descriptor if ret->data is NULL.\n+\n 2005-05-22  Peter Wainwright  <prw@ceiriog1.demon.co.uk>\n \n \tPR libfortran/21376"}, {"sha": "a5c098b0e819c89e862975a3a8a35ca12996c74b", "filename": "libgfortran/intrinsics/unpack_generic.c", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4a3d54bac34bb261bacffd774d9810d679d971/libgfortran%2Fintrinsics%2Funpack_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4a3d54bac34bb261bacffd774d9810d679d971/libgfortran%2Fintrinsics%2Funpack_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Funpack_generic.c?ref=ba4a3d54bac34bb261bacffd774d9810d679d971", "patch": "@@ -1,5 +1,5 @@\n-/* Generic implementation of the RESHAPE intrinsic\n-   Copyright 2002 Free Software Foundation, Inc.\n+/* Generic implementation of the UNPACK intrinsic\n+   Copyright 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -34,17 +34,18 @@ Boston, MA 02111-1307, USA.  */\n #include <string.h>\n #include \"libgfortran.h\"\n \n-extern void unpack1 (const gfc_array_char *, const gfc_array_char *,\n+extern void unpack1 (gfc_array_char *, const gfc_array_char *,\n \t\t     const gfc_array_l4 *, const gfc_array_char *);\n iexport_proto(unpack1);\n \n void\n-unpack1 (const gfc_array_char *ret, const gfc_array_char *vector,\n+unpack1 (gfc_array_char *ret, const gfc_array_char *vector,\n \t const gfc_array_l4 *mask, const gfc_array_char *field)\n {\n   /* r.* indicates the return array.  */\n   index_type rstride[GFC_MAX_DIMENSIONS];\n   index_type rstride0;\n+  index_type rs;\n   char *rptr;\n   /* v.* indicates the vector array.  */\n   index_type vstride0;\n@@ -68,17 +69,41 @@ unpack1 (const gfc_array_char *ret, const gfc_array_char *vector,\n   size = GFC_DESCRIPTOR_SIZE (ret);\n   /* A field element size of 0 actually means this is a scalar.  */\n   fsize = GFC_DESCRIPTOR_SIZE (field);\n-  dim = GFC_DESCRIPTOR_RANK (ret);\n-  for (n = 0; n < dim; n++)\n+  if (ret->data == NULL)\n     {\n-      count[n] = 0;\n-      extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n-      rstride[n] = ret->dim[n].stride * size;\n-      fstride[n] = field->dim[n].stride * fsize;\n-      mstride[n] = mask->dim[n].stride;\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  rstride[n] = ret->dim[n].stride * size;\n+\t  fstride[n] = field->dim[n].stride * fsize;\n+\t  mstride[n] = mask->dim[n].stride;\n+\t  rs *= extent[n];\n+\t}\n+      ret->base = 0;\n+      ret->data = internal_malloc_size (rs * size);\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  rstride[n] = ret->dim[n].stride * size;\n+\t  fstride[n] = field->dim[n].stride * fsize;\n+\t  mstride[n] = mask->dim[n].stride;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = size;\n     }\n-  if (rstride[0] == 0)\n-    rstride[0] = size;\n   if (fstride[0] == 0)\n     fstride[0] = fsize;\n   if (mstride[0] == 0)"}]}