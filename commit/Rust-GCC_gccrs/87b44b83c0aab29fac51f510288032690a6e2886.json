{"sha": "87b44b83c0aab29fac51f510288032690a6e2886", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdiNDRiODNjMGFhYjI5ZmFjNTFmNTEwMjg4MDMyNjkwYTZlMjg4Ng==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.vnet.ibm.com", "date": "2016-10-10T04:42:08Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2016-10-10T04:42:08Z"}, "message": "rs6000.h (TARGET_EFFICIENT_OVERLAPPING_UNALIGNED): Add macro to say we can efficiently handle overlapping unaligned loads.\n\n2016-10-09  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.h (TARGET_EFFICIENT_OVERLAPPING_UNALIGNED): \n\tAdd macro to say we can efficiently handle overlapping unaligned\n\tloads.\n\t* config/rs6000/rs6000.c (expand_block_compare): Avoid generating\n\tpoor code for processors older than p8.\n\nFrom-SVN: r240908", "tree": {"sha": "2507e346ef67a5a25f1c0562f4206555a723efe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2507e346ef67a5a25f1c0562f4206555a723efe1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87b44b83c0aab29fac51f510288032690a6e2886", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87b44b83c0aab29fac51f510288032690a6e2886", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87b44b83c0aab29fac51f510288032690a6e2886", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87b44b83c0aab29fac51f510288032690a6e2886/comments", "author": null, "committer": null, "parents": [{"sha": "4815e7d4056e321691cd2da79d20f3f9e5d13914", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4815e7d4056e321691cd2da79d20f3f9e5d13914", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4815e7d4056e321691cd2da79d20f3f9e5d13914"}], "stats": {"total": 37, "additions": 33, "deletions": 4}, "files": [{"sha": "7842655c79a2d1a160d2996697a03c68d97c80f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87b44b83c0aab29fac51f510288032690a6e2886/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87b44b83c0aab29fac51f510288032690a6e2886/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87b44b83c0aab29fac51f510288032690a6e2886", "patch": "@@ -1,3 +1,11 @@\n+2016-10-09  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.h (TARGET_EFFICIENT_OVERLAPPING_UNALIGNED): \n+\tAdd macro to say we can efficiently handle overlapping unaligned\n+\tloads.\n+\t* config/rs6000/rs6000.c (expand_block_compare): Avoid generating\n+\tpoor code for processors older than p8.\n+\n 2016-10-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gen-pass-instances.awk: Remove GNUism."}, {"sha": "8c7ab18224b928e8bf95543541af1b093ec14e2d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87b44b83c0aab29fac51f510288032690a6e2886/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87b44b83c0aab29fac51f510288032690a6e2886/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=87b44b83c0aab29fac51f510288032690a6e2886", "patch": "@@ -18771,6 +18771,14 @@ expand_block_compare (rtx operands[])\n   if (bytes <= 0)\n     return true;\n \n+  /* The code generated for p7 and older is not faster than glibc\n+     memcmp if alignment is small and length is not short, so bail\n+     out to avoid those conditions.  */\n+  if (!TARGET_EFFICIENT_OVERLAPPING_UNALIGNED\n+      && ((base_align == 1 && bytes > 16)\n+\t  || (base_align == 2 && bytes > 32)))\n+    return false;\n+\n   rtx tmp_reg_src1 = gen_reg_rtx (word_mode);\n   rtx tmp_reg_src2 = gen_reg_rtx (word_mode);\n \n@@ -18820,13 +18828,18 @@ expand_block_compare (rtx operands[])\n   while (bytes > 0)\n     {\n       int align = compute_current_alignment (base_align, offset);\n-      load_mode = select_block_compare_mode(offset, bytes, align, word_mode_ok);\n+      if (TARGET_EFFICIENT_OVERLAPPING_UNALIGNED)\n+\tload_mode = select_block_compare_mode (offset, bytes, align,\n+\t\t\t\t\t       word_mode_ok);\n+      else\n+\tload_mode = select_block_compare_mode (0, bytes, align, word_mode_ok);\n       load_mode_size = GET_MODE_SIZE (load_mode);\n       if (bytes >= load_mode_size)\n \tcmp_bytes = load_mode_size;\n-      else\n+      else if (TARGET_EFFICIENT_OVERLAPPING_UNALIGNED)\n \t{\n-\t  /* Move this load back so it doesn't go past the end.  */\n+\t  /* Move this load back so it doesn't go past the end.\n+\t     P8/P9 can do this efficiently.  */\n \t  int extra_bytes = load_mode_size - bytes;\n \t  cmp_bytes = bytes;\n \t  if (extra_bytes < offset)\n@@ -18836,7 +18849,12 @@ expand_block_compare (rtx operands[])\n \t      bytes = cmp_bytes;\n \t    }\n \t}\n-\n+      else\n+\t/* P7 and earlier can't do the overlapping load trick fast,\n+\t   so this forces a non-overlapping load and a shift to get\n+\t   rid of the extra bytes.  */\n+\tcmp_bytes = bytes;\n+      \n       src1 = adjust_address (orig_src1, load_mode, offset);\n       src2 = adjust_address (orig_src2, load_mode, offset);\n "}, {"sha": "f53da1551602d84d081a8a5a499b323b7835d200", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87b44b83c0aab29fac51f510288032690a6e2886/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87b44b83c0aab29fac51f510288032690a6e2886/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=87b44b83c0aab29fac51f510288032690a6e2886", "patch": "@@ -607,6 +607,9 @@ extern int rs6000_vector_align[];\n \t\t\t\t && TARGET_POWERPC64)\n #define TARGET_VEXTRACTUB\t(TARGET_P9_VECTOR && TARGET_DIRECT_MOVE \\\n \t\t\t\t && TARGET_UPPER_REGS_DI && TARGET_POWERPC64)\n+/* This wants to be set for p8 and newer.  On p7, overlapping unaligned\n+   loads are slow. */\n+#define TARGET_EFFICIENT_OVERLAPPING_UNALIGNED TARGET_EFFICIENT_UNALIGNED_VSX\n \n /* Byte/char syncs were added as phased in for ISA 2.06B, but are not present\n    in power7, so conditionalize them on p8 features.  TImode syncs need quad"}]}