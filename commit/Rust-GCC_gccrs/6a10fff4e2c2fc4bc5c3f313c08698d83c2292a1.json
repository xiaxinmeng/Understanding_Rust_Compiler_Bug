{"sha": "6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmExMGZmZjRlMmMyZmM0YmM1YzNmMzEzYzA4Njk4ZDgzYzIyOTJhMQ==", "commit": {"author": {"name": "Igor Tsimbalist", "email": "igor.v.tsimbalist@intel.com", "date": "2017-11-17T15:21:23Z"}, "committer": {"name": "Igor Tsimbalist", "email": "itsimbal@gcc.gnu.org", "date": "2017-11-17T15:21:23Z"}, "message": "Add Intel CET support for EH in libgcc.\n\nControl-flow Enforcement Technology (CET), published by Intel,\nintroduces the Shadow Stack feature, which ensures a return from a\nfunction is done to exactly the same location from where the function\nwas called. When EH is present the control-flow transfer may skip some\nstack frames and the shadow stack has to be adjusted not to signal a\nviolation of a control-flow transfer. It's done by counting a number\nof skiping frames and adjasting shadow stack pointer by this number.\n\nHaving new semantic of the 'ret' instruction if CET is supported in HW\nthe 'ret' instruction cannot be generated in ix86_expand_epilogue when\nwe are returning after EH is processed. Added a code in\nix86_expand_epilogue to adjust Shadow Stack pointer and to generate an\nindirect jump instead of 'ret'. As sp register is used during this\nadjustment thus the argument in pro_epilogue_adjust_stack is changed\nto update cfa_reg based on whether control-flow instrumentation is set.\nWithout updating the cfa_reg field there is an assert later in dwarf2\npass related to mismatch the stack register and cfa_reg value.\n\ngcc/\n\t* config/i386/i386.c (ix86_expand_epilogue): Change simple\n\treturn to indirect jump for EH return if control-flow protection\n\tis enabled. Change explicit 'false' argument in\n\tpro_epilogue_adjust_stack with a value of flag_cf_protection.\n\t* config/i386/i386.md (simple_return_indirect_internal): Remove\n\tSImode restriction to support 64-bit.\n\nlibgcc/\n\t* config/i386/linux-unwind.h: Include\n\tconfig/i386/shadow-stack-unwind.h.\n\t* config/i386/shadow-stack-unwind.h: New file.\n\t* unwind-dw2.c: (uw_install_context): Add a frame parameter and\n\tpass it to _Unwind_Frames_Extra.\n\t* unwind-generic.h (_Unwind_Frames_Extra): New.\n\t* unwind.inc (_Unwind_RaiseException_Phase2): Add frames_p\n\tparameter. Add local variable frames to count number of frames.\n\t(_Unwind_ForcedUnwind_Phase2): Likewise.\n\t(_Unwind_RaiseException): Add local variable frames to count\n\tnumber of frames, pass it to _Unwind_RaiseException_Phase2 and\n\tuw_install_context.\n\t(_Unwind_ForcedUnwind): Likewise.\n\t(_Unwind_Resume): Likewise.\n\t(_Unwind_Resume_or_Rethrow): Likewise.\n\nFrom-SVN: r254876", "tree": {"sha": "714437517f3bed4370e786ffd6a22ca4d11f139f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/714437517f3bed4370e786ffd6a22ca4d11f139f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/comments", "author": {"login": "itsimbal", "id": 29258612, "node_id": "MDQ6VXNlcjI5MjU4NjEy", "avatar_url": "https://avatars.githubusercontent.com/u/29258612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/itsimbal", "html_url": "https://github.com/itsimbal", "followers_url": "https://api.github.com/users/itsimbal/followers", "following_url": "https://api.github.com/users/itsimbal/following{/other_user}", "gists_url": "https://api.github.com/users/itsimbal/gists{/gist_id}", "starred_url": "https://api.github.com/users/itsimbal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/itsimbal/subscriptions", "organizations_url": "https://api.github.com/users/itsimbal/orgs", "repos_url": "https://api.github.com/users/itsimbal/repos", "events_url": "https://api.github.com/users/itsimbal/events{/privacy}", "received_events_url": "https://api.github.com/users/itsimbal/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f1b7bc164cb370b15c6e62d65120e6494729ac0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1b7bc164cb370b15c6e62d65120e6494729ac0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1b7bc164cb370b15c6e62d65120e6494729ac0c"}], "stats": {"total": 165, "additions": 148, "deletions": 17}, "files": [{"sha": "f706890ad37e3f2b528e56b09a39a56c3a668b30", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1", "patch": "@@ -1,3 +1,13 @@\n+2017-11-17  Igor Tsimbalist  <igor.v.tsimbalist@intel.com>\n+\n+\t* config/i386/i386.c (ix86_expand_epilogue): Change simple\n+\treturn to indirect jump for EH return if control-flow\n+\tprotection is enabled. Change explicit 'false' argument in\n+\tpro_epilogue_adjust_stack with a value of\n+\tflag_cf_protection.\n+\t* config/i386/i386.md (simple_return_indirect_internal):\n+\tRemove SImode restriction to support 64-bit.\n+\n 2017-11-17  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* combine.c (added_notes_insn): New."}, {"sha": "a53666966d6ca356269fdf62b870c5d3fca1281b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1", "patch": "@@ -13960,7 +13960,9 @@ ix86_expand_epilogue (int style)\n \t\t offset relative to SA, and after this insn we have no\n \t\t other reasonable register to use for the CFA.  We don't\n \t\t bother resetting the CFA to the SP for the duration of\n-\t\t the return insn.  */\n+\t\t the return insn, unless the control flow instrumentation\n+\t\t is done.  In this case the SP is used later and we have\n+\t\t to reset CFA to SP.  */\n \t      add_reg_note (insn, REG_CFA_DEF_CFA,\n \t\t\t    plus_constant (Pmode, sa, UNITS_PER_WORD));\n \t      ix86_add_queued_cfa_restore_notes (insn);\n@@ -13972,7 +13974,8 @@ ix86_expand_epilogue (int style)\n \t      m->fs.fp_valid = false;\n \n \t      pro_epilogue_adjust_stack (stack_pointer_rtx, sa,\n-\t\t\t\t\t const0_rtx, style, false);\n+\t\t\t\t\t const0_rtx, style,\n+\t\t\t\t\t flag_cf_protection);\n \t    }\n \t  else\n \t    {\n@@ -14156,7 +14159,32 @@ ix86_expand_epilogue (int style)\n \temit_jump_insn (gen_simple_return_pop_internal (popc));\n     }\n   else if (!m->call_ms2sysv || !restore_stub_is_tail)\n-    emit_jump_insn (gen_simple_return_internal ());\n+    {\n+      /* In case of return from EH a simple return cannot be used\n+\t as a return address will be compared with a shadow stack\n+\t return address.  Use indirect jump instead.  */\n+      if (style == 2 && flag_cf_protection)\n+\t{\n+\t  /* Register used in indirect jump must be in word_mode.  But\n+\t     Pmode may not be the same as word_mode for x32.  */\n+\t  rtx ecx = gen_rtx_REG (word_mode, CX_REG);\n+\t  rtx_insn *insn;\n+\n+\t  insn = emit_insn (gen_pop (ecx));\n+\t  m->fs.cfa_offset -= UNITS_PER_WORD;\n+\t  m->fs.sp_offset -= UNITS_PER_WORD;\n+\n+\t  rtx x = plus_constant (Pmode, stack_pointer_rtx, UNITS_PER_WORD);\n+\t  x = gen_rtx_SET (stack_pointer_rtx, x);\n+\t  add_reg_note (insn, REG_CFA_ADJUST_CFA, x);\n+\t  add_reg_note (insn, REG_CFA_REGISTER, gen_rtx_SET (ecx, pc_rtx));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t  emit_jump_insn (gen_simple_return_indirect_internal (ecx));\n+\t}\n+      else\n+\temit_jump_insn (gen_simple_return_internal ());\n+    }\n \n   /* Restore the state back to the state from the prologue,\n      so that it's correct for the next epilogue.  */"}, {"sha": "1e918233ddf744c48860e93e40ad512874b40161", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1", "patch": "@@ -13086,7 +13086,7 @@\n \n (define_insn \"simple_return_indirect_internal\"\n   [(simple_return)\n-   (use (match_operand:SI 0 \"register_operand\" \"r\"))]\n+   (use (match_operand 0 \"register_operand\" \"r\"))]\n   \"reload_completed\"\n   \"%!jmp\\t%A0\"\n   [(set_attr \"type\" \"ibr\")"}, {"sha": "234f0b274f6f6c23616d545c17a364dc41ff2930", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1", "patch": "@@ -1,3 +1,21 @@\n+2017-11-17  Igor Tsimbalist  <igor.v.tsimbalist@intel.com>\n+\n+\t* config/i386/linux-unwind.h: Include\n+\tconfig/i386/shadow-stack-unwind.h.\n+\t* config/i386/shadow-stack-unwind.h: New file.\n+\t* unwind-dw2.c: (uw_install_context): Add a frame parameter and\n+\tpass it to _Unwind_Frames_Extra.\n+\t* unwind-generic.h (_Unwind_Frames_Extra): New.\n+\t* unwind.inc (_Unwind_RaiseException_Phase2): Add frames_p\n+\tparameter. Add local variable frames to count number of frames.\n+\t(_Unwind_ForcedUnwind_Phase2): Likewise.\n+\t(_Unwind_RaiseException): Add local variable frames to count\n+\tnumber of frames, pass it to _Unwind_RaiseException_Phase2 and\n+\tuw_install_context.\n+\t(_Unwind_ForcedUnwind): Likewise.\n+\t(_Unwind_Resume): Likewise.\n+\t(_Unwind_Resume_or_Rethrow): Likewise.\n+\n 2017-11-17  Igor Tsimbalist  <igor.v.tsimbalist@intel.com>\n \n \t* Makefile.in (configure_deps): Add $(srcdir)/../config/cet.m4."}, {"sha": "c51b4d9087d08df58d51b28f55b6f6dcf886d2e0", "filename": "libgcc/config/i386/linux-unwind.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/libgcc%2Fconfig%2Fi386%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/libgcc%2Fconfig%2Fi386%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Flinux-unwind.h?ref=6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1", "patch": "@@ -22,6 +22,11 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n+/* Unwind shadow stack for -fcf-protection -mshstk.  */\n+#if defined __SHSTK__ && defined __CET__\n+# include \"config/i386/shadow-stack-unwind.h\"\n+#endif\n+\n /* Do code reading to identify a signal frame, and set the frame\n    state data appropriately.  See unwind-dw2.c for the structs.\n    Don't use this at all if inhibit_libc is used.  */"}, {"sha": "2789e894130a7a86aeb6f560f5a555219c8ae20d", "filename": "libgcc/config/i386/shadow-stack-unwind.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/libgcc%2Fconfig%2Fi386%2Fshadow-stack-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/libgcc%2Fconfig%2Fi386%2Fshadow-stack-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fshadow-stack-unwind.h?ref=6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1", "patch": "@@ -0,0 +1,51 @@\n+/* _Unwind_Frames_Extra with shadow stack for x86-64 and x86.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifdef __x86_64__\n+# define incssp(x) __builtin_ia32_incsspq ((x))\n+# define rdssp(x) __builtin_ia32_rdsspq (x)\n+#else\n+# define incssp(x) __builtin_ia32_incsspd ((x))\n+# define rdssp(x) __builtin_ia32_rdsspd (x)\n+#endif\n+\n+/* Unwind the shadow stack for EH.  */\n+#undef _Unwind_Frames_Extra\n+#define _Unwind_Frames_Extra(x)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      unsigned long ssp = 0;\t\t\t\\\n+      ssp = rdssp (ssp);\t\t\t\\\n+      if (ssp != 0)\t\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  unsigned long tmp = (x);\t\t\\\n+\t  while (tmp > 255)\t\t\t\\\n+\t    {\t\t\t\t\t\\\n+\t      incssp (tmp);\t\t\t\\\n+\t      tmp -= 255;\t\t\t\\\n+\t    }\t\t\t\t\t\\\n+\t  incssp (tmp);\t\t\t\t\\\n+\t}\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+    while (0)"}, {"sha": "e80ac7418f25a719b65c49c45cd21c1377e5aadc", "filename": "libgcc/unwind-dw2.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/libgcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/libgcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-dw2.c?ref=6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1", "patch": "@@ -1644,14 +1644,18 @@ uw_frob_return_addr (struct _Unwind_Context *current\n \n /* Install TARGET into CURRENT so that we can return to it.  This is a\n    macro because __builtin_eh_return must be invoked in the context of\n-   our caller.  */\n+   our caller.  FRAMES is a number of frames to be unwind.\n+   _Unwind_Frames_Extra is a macro to do additional work during unwinding\n+   if needed, for example shadow stack pointer adjustment for Intel CET\n+   technology.  */\n \n-#define uw_install_context(CURRENT, TARGET)\t\t\t\t\\\n+#define uw_install_context(CURRENT, TARGET, FRAMES)\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       long offset = uw_install_context_1 ((CURRENT), (TARGET));\t\t\\\n       void *handler = uw_frob_return_addr ((CURRENT), (TARGET));\t\\\n       _Unwind_DebugHook ((TARGET)->cfa, handler);\t\t\t\\\n+      _Unwind_Frames_Extra (FRAMES);\t\t\t\t\t\\\n       __builtin_eh_return (offset, handler);\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)"}, {"sha": "570ea50a5a6096bd40d8c1b3111fa29bf225e7f3", "filename": "libgcc/unwind-generic.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/libgcc%2Funwind-generic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/libgcc%2Funwind-generic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-generic.h?ref=6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1", "patch": "@@ -288,4 +288,7 @@ EXCEPTION_DISPOSITION _GCC_specific_handler (PEXCEPTION_RECORD, void *,\n #pragma GCC visibility pop\n #endif\n \n+/* Additional actions to unwind number of stack frames.  */\n+#define _Unwind_Frames_Extra(frames)\n+\n #endif /* unwind.h */"}, {"sha": "a98154b1b7207ebe9b2a90e5288a72eba42bfabe", "filename": "libgcc/unwind.inc", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/libgcc%2Funwind.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1/libgcc%2Funwind.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind.inc?ref=6a10fff4e2c2fc4bc5c3f313c08698d83c2292a1", "patch": "@@ -36,9 +36,11 @@\n \n static _Unwind_Reason_Code\n _Unwind_RaiseException_Phase2(struct _Unwind_Exception *exc,\n-\t\t\t      struct _Unwind_Context *context)\n+\t\t\t      struct _Unwind_Context *context,\n+\t\t\t      unsigned long *frames_p)\n {\n   _Unwind_Reason_Code code;\n+  unsigned long frames = 1;\n \n   while (1)\n     {\n@@ -71,8 +73,10 @@ _Unwind_RaiseException_Phase2(struct _Unwind_Exception *exc,\n       gcc_assert (!match_handler);\n \n       uw_update_context (context, &fs);\n+      frames++;\n     }\n \n+  *frames_p = frames;\n   return code;\n }\n \n@@ -83,6 +87,7 @@ _Unwind_RaiseException(struct _Unwind_Exception *exc)\n {\n   struct _Unwind_Context this_context, cur_context;\n   _Unwind_Reason_Code code;\n+  unsigned long frames;\n \n   /* Set up this_context to describe the current stack frame.  */\n   uw_init_context (&this_context);\n@@ -128,23 +133,25 @@ _Unwind_RaiseException(struct _Unwind_Exception *exc)\n   exc->private_2 = uw_identify_context (&cur_context);\n \n   cur_context = this_context;\n-  code = _Unwind_RaiseException_Phase2 (exc, &cur_context);\n+  code = _Unwind_RaiseException_Phase2 (exc, &cur_context, &frames);\n   if (code != _URC_INSTALL_CONTEXT)\n     return code;\n \n-  uw_install_context (&this_context, &cur_context);\n+  uw_install_context (&this_context, &cur_context, frames);\n }\n \n \n /* Subroutine of _Unwind_ForcedUnwind also invoked from _Unwind_Resume.  */\n \n static _Unwind_Reason_Code\n _Unwind_ForcedUnwind_Phase2 (struct _Unwind_Exception *exc,\n-\t\t\t     struct _Unwind_Context *context)\n+\t\t\t     struct _Unwind_Context *context,\n+\t\t\t     unsigned long *frames_p)\n {\n   _Unwind_Stop_Fn stop = (_Unwind_Stop_Fn) (_Unwind_Ptr) exc->private_1;\n   void *stop_argument = (void *) (_Unwind_Ptr) exc->private_2;\n   _Unwind_Reason_Code code, stop_code;\n+  unsigned long frames = 1;\n \n   while (1)\n     {\n@@ -183,8 +190,10 @@ _Unwind_ForcedUnwind_Phase2 (struct _Unwind_Exception *exc,\n       /* Update cur_context to describe the same frame as fs, and discard\n \t the previous context if necessary.  */\n       uw_advance_context (context, &fs);\n+      frames++;\n     }\n \n+  *frames_p = frames;\n   return code;\n }\n \n@@ -197,18 +206,19 @@ _Unwind_ForcedUnwind (struct _Unwind_Exception *exc,\n {\n   struct _Unwind_Context this_context, cur_context;\n   _Unwind_Reason_Code code;\n+  unsigned long frames;\n \n   uw_init_context (&this_context);\n   cur_context = this_context;\n \n   exc->private_1 = (_Unwind_Ptr) stop;\n   exc->private_2 = (_Unwind_Ptr) stop_argument;\n \n-  code = _Unwind_ForcedUnwind_Phase2 (exc, &cur_context);\n+  code = _Unwind_ForcedUnwind_Phase2 (exc, &cur_context, &frames);\n   if (code != _URC_INSTALL_CONTEXT)\n     return code;\n \n-  uw_install_context (&this_context, &cur_context);\n+  uw_install_context (&this_context, &cur_context, frames);\n }\n \n \n@@ -220,20 +230,21 @@ _Unwind_Resume (struct _Unwind_Exception *exc)\n {\n   struct _Unwind_Context this_context, cur_context;\n   _Unwind_Reason_Code code;\n+  unsigned long frames;\n \n   uw_init_context (&this_context);\n   cur_context = this_context;\n \n   /* Choose between continuing to process _Unwind_RaiseException\n      or _Unwind_ForcedUnwind.  */\n   if (exc->private_1 == 0)\n-    code = _Unwind_RaiseException_Phase2 (exc, &cur_context);\n+    code = _Unwind_RaiseException_Phase2 (exc, &cur_context, &frames);\n   else\n-    code = _Unwind_ForcedUnwind_Phase2 (exc, &cur_context);\n+    code = _Unwind_ForcedUnwind_Phase2 (exc, &cur_context, &frames);\n \n   gcc_assert (code == _URC_INSTALL_CONTEXT);\n \n-  uw_install_context (&this_context, &cur_context);\n+  uw_install_context (&this_context, &cur_context, frames);\n }\n \n \n@@ -245,6 +256,7 @@ _Unwind_Resume_or_Rethrow (struct _Unwind_Exception *exc)\n {\n   struct _Unwind_Context this_context, cur_context;\n   _Unwind_Reason_Code code;\n+  unsigned long frames;\n \n   /* Choose between continuing to process _Unwind_RaiseException\n      or _Unwind_ForcedUnwind.  */\n@@ -254,11 +266,11 @@ _Unwind_Resume_or_Rethrow (struct _Unwind_Exception *exc)\n   uw_init_context (&this_context);\n   cur_context = this_context;\n \n-  code = _Unwind_ForcedUnwind_Phase2 (exc, &cur_context);\n+  code = _Unwind_ForcedUnwind_Phase2 (exc, &cur_context, &frames);\n \n   gcc_assert (code == _URC_INSTALL_CONTEXT);\n \n-  uw_install_context (&this_context, &cur_context);\n+  uw_install_context (&this_context, &cur_context, frames);\n }\n \n "}]}