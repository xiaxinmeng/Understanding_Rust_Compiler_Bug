{"sha": "2635892a1c64fc7e5b8c1c13d53dd0468ffc757d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYzNTg5MmExYzY0ZmM3ZTViOGMxYzEzZDUzZGQwNDY4ZmZjNzU3ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-10-15T19:36:50Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-10-15T19:36:50Z"}, "message": "Use VEC_PERM_EXPR in the vectorizer.\n\n        * tree-vect-slp.c: Include langhooks.h.\n        (vect_create_mask_and_perm): Emit VEC_PERM_EXPR, not a builtin.\n        (vect_transform_slp_perm_load): Use can_vec_perm_expr_p.  Simplify\n        mask creation for VEC_PERM_EXPR.\n        * tree-vect-stmts.c (perm_mask_for_reverse): Return the mask,\n        not the builtin.\n        (reverse_vec_elements): Emit VEC_PERM_EXPR not a builtin.\n        * Makefile.in (tree-vect-slp.o): Update dependency.\n        * optabs.c (can_vec_perm_expr_p): Allow NULL as unknown constant.\n\nFrom-SVN: r180047", "tree": {"sha": "648ae2160b09141f65b345023049f5969eb8fc42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/648ae2160b09141f65b345023049f5969eb8fc42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2635892a1c64fc7e5b8c1c13d53dd0468ffc757d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2635892a1c64fc7e5b8c1c13d53dd0468ffc757d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2635892a1c64fc7e5b8c1c13d53dd0468ffc757d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2635892a1c64fc7e5b8c1c13d53dd0468ffc757d/comments", "author": null, "committer": null, "parents": [{"sha": "f3b3dc6a7e46c011a2b29e2baff19fcb55f16b79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3b3dc6a7e46c011a2b29e2baff19fcb55f16b79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3b3dc6a7e46c011a2b29e2baff19fcb55f16b79"}], "stats": {"total": 153, "additions": 65, "deletions": 88}, "files": [{"sha": "22e2f7766c377053f55d7a5820254a604131fd8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2635892a1c64fc7e5b8c1c13d53dd0468ffc757d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2635892a1c64fc7e5b8c1c13d53dd0468ffc757d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2635892a1c64fc7e5b8c1c13d53dd0468ffc757d", "patch": "@@ -1,3 +1,15 @@\n+2011-10-15  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-vect-slp.c: Include langhooks.h.\n+\t(vect_create_mask_and_perm): Emit VEC_PERM_EXPR, not a builtin.\n+\t(vect_transform_slp_perm_load): Use can_vec_perm_expr_p.  Simplify\n+\tmask creation for VEC_PERM_EXPR.\n+\t* tree-vect-stmts.c (perm_mask_for_reverse): Return the mask,\n+\tnot the builtin.\n+\t(reverse_vec_elements): Emit VEC_PERM_EXPR not a builtin.\n+\t* Makefile.in (tree-vect-slp.o): Update dependency.\n+\t* optabs.c (can_vec_perm_expr_p): Allow NULL as unknown constant.\n+\n 2011-10-15  Alan Modra  <amodra@gmail.com>\n \n \tPR bootstrap/50738"}, {"sha": "ce144893e203c327dde65f3a89991d3cbda010b3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2635892a1c64fc7e5b8c1c13d53dd0468ffc757d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2635892a1c64fc7e5b8c1c13d53dd0468ffc757d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2635892a1c64fc7e5b8c1c13d53dd0468ffc757d", "patch": "@@ -2753,7 +2753,7 @@ tree-vect-slp.o: tree-vect-slp.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(TARGET_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(CFGLAYOUT_H) \\\n    $(EXPR_H) $(RECOG_H) $(OPTABS_H) $(TREE_VECTORIZER_H) tree-pretty-print.h \\\n-   gimple-pretty-print.h $(TREE_DATA_REF_H)\n+   gimple-pretty-print.h $(TREE_DATA_REF_H) langhooks.h\n tree-vect-stmts.o: tree-vect-stmts.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(TARGET_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(CFGLAYOUT_H) \\"}, {"sha": "a373d7aeff47a78c08943581b87e179d4020ae90", "filename": "gcc/optabs.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2635892a1c64fc7e5b8c1c13d53dd0468ffc757d/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2635892a1c64fc7e5b8c1c13d53dd0468ffc757d/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=2635892a1c64fc7e5b8c1c13d53dd0468ffc757d", "patch": "@@ -6686,7 +6686,7 @@ vector_compare_rtx (tree cond, bool unsignedp, enum insn_code icode)\n }\n \n /* Return true if VEC_PERM_EXPR can be expanded using SIMD extensions\n-   of the CPU.  */\n+   of the CPU.  SEL may be NULL, which stands for an unknown constant.  */\n \n bool\n can_vec_perm_expr_p (tree type, tree sel)\n@@ -6699,10 +6699,10 @@ can_vec_perm_expr_p (tree type, tree sel)\n   if (!VECTOR_MODE_P (mode))\n     return false;\n \n-  if (TREE_CODE (sel) == VECTOR_CST)\n+  if (sel == NULL || TREE_CODE (sel) == VECTOR_CST)\n     {\n       if (direct_optab_handler (vec_perm_const_optab, mode) != CODE_FOR_nothing\n-\t  && targetm.vectorize.builtin_vec_perm_ok (type, sel))\n+\t  && (sel == NULL || targetm.vectorize.builtin_vec_perm_ok (type, sel)))\n \treturn true;\n     }\n \n@@ -6722,7 +6722,7 @@ can_vec_perm_expr_p (tree type, tree sel)\n \n   /* In order to support the lowering of non-constant permutations,\n      we need to support shifts and adds.  */\n-  if (TREE_CODE (sel) != VECTOR_CST)\n+  if (sel != NULL && TREE_CODE (sel) != VECTOR_CST)\n     {\n       if (GET_MODE_UNIT_SIZE (mode) > 2\n \t  && optab_handler (ashl_optab, mode) == CODE_FOR_nothing"}, {"sha": "852d94c543db178dfac28702f4aa1976f84d1f8d", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 30, "deletions": 46, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2635892a1c64fc7e5b8c1c13d53dd0468ffc757d/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2635892a1c64fc7e5b8c1c13d53dd0468ffc757d/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=2635892a1c64fc7e5b8c1c13d53dd0468ffc757d", "patch": "@@ -1,5 +1,5 @@\n /* SLP - Basic Block Vectorization\n-   Copyright (C) 2007, 2008, 2009, 2010\n+   Copyright (C) 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com>\n    and Ira Rosen <irar@il.ibm.com>\n@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"recog.h\"\n #include \"optabs.h\"\n #include \"tree-vectorizer.h\"\n+#include \"langhooks.h\"\n \n /* Extract the location of the basic block in the source code.\n    Return the basic block location if succeed and NULL if not.  */\n@@ -2226,8 +2227,7 @@ static inline void\n vect_create_mask_and_perm (gimple stmt, gimple next_scalar_stmt,\n                            tree mask, int first_vec_indx, int second_vec_indx,\n                            gimple_stmt_iterator *gsi, slp_tree node,\n-                           tree builtin_decl, tree vectype,\n-                           VEC(tree,heap) *dr_chain,\n+                           tree vectype, VEC(tree,heap) *dr_chain,\n                            int ncopies, int vect_stmts_counter)\n {\n   tree perm_dest;\n@@ -2251,10 +2251,10 @@ vect_create_mask_and_perm (gimple stmt, gimple next_scalar_stmt,\n       second_vec = VEC_index (tree, dr_chain, second_vec_indx);\n \n       /* Generate the permute statement.  */\n-      perm_stmt = gimple_build_call (builtin_decl,\n-\t\t\t\t     3, first_vec, second_vec, mask);\n+      perm_stmt = gimple_build_assign_with_ops3 (VEC_PERM_EXPR, perm_dest,\n+\t\t\t\t\t\t first_vec, second_vec, mask);\n       data_ref = make_ssa_name (perm_dest, perm_stmt);\n-      gimple_call_set_lhs (perm_stmt, data_ref);\n+      gimple_set_lhs (perm_stmt, data_ref);\n       vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \n       /* Store the vector statement in NODE.  */\n@@ -2361,9 +2361,9 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree mask_element_type = NULL_TREE, mask_type;\n-  int i, j, k, m, scale, mask_nunits, nunits, vec_index = 0, scalar_index;\n+  int i, j, k, nunits, vec_index = 0, scalar_index;\n   slp_tree node;\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_info), builtin_decl;\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   gimple next_scalar_stmt;\n   int group_size = SLP_INSTANCE_GROUP_SIZE (slp_node_instance);\n   int first_mask_element;\n@@ -2374,35 +2374,24 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n   bool mask_fixed = false;\n   bool needs_first_vector = false;\n \n-  if (!targetm.vectorize.builtin_vec_perm)\n+  if (!can_vec_perm_expr_p (vectype, NULL_TREE))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         {\n-          fprintf (vect_dump, \"no builtin for vect permute for \");\n+          fprintf (vect_dump, \"no vect permute for \");\n           print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n         }\n-\n-       return false;\n-    }\n-\n-  builtin_decl = targetm.vectorize.builtin_vec_perm (vectype,\n-                                                     &mask_element_type);\n-  if (!builtin_decl || !mask_element_type)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        {\n-          fprintf (vect_dump, \"no builtin for vect permute for \");\n-          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n-        }\n-\n-       return false;\n+      return false;\n     }\n \n+  /* The generic VEC_PERM_EXPR code always uses an integral type of the\n+     same size as the vector element being permuted.  */\n+  mask_element_type\n+    = lang_hooks.types.type_for_size\n+    (TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (vectype))), 1);\n   mask_type = get_vectype_for_scalar_type (mask_element_type);\n-  mask_nunits = TYPE_VECTOR_SUBPARTS (mask_type);\n-  mask = (int *) xmalloc (sizeof (int) * mask_nunits);\n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  scale = mask_nunits / nunits;\n+  mask = (int *) xmalloc (sizeof (int) * nunits);\n   unroll_factor = SLP_INSTANCE_UNROLLING_FACTOR (slp_node_instance);\n \n   /* The number of vector stmts to generate based only on SLP_NODE_INSTANCE\n@@ -2425,8 +2414,7 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n      for b's: b0b0b0b1 b1b1b2b2 b2b3b3b3\n      ...\n \n-     The masks for a's should be: {0,0,0,3} {3,3,6,6} {6,9,9,9} (in target\n-     scpecific type, e.g., in bytes for Altivec.\n+     The masks for a's should be: {0,0,0,3} {3,3,6,6} {6,9,9,9}.\n      The last mask is illegal since we assume two operands for permute\n      operation, and the mask element values can't be outside that range.\n      Hence, the last mask must be converted into {2,5,5,5}.\n@@ -2451,20 +2439,17 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n         {\n           for (k = 0; k < group_size; k++)\n             {\n-              first_mask_element = (i + j * group_size) * scale;\n-              for (m = 0; m < scale; m++)\n-                {\n-                  if (!vect_get_mask_element (stmt, first_mask_element, m,\n-                                   mask_nunits, only_one_vec, index, mask,\n-                                   &current_mask_element, &need_next_vector,\n-                                   &number_of_mask_fixes, &mask_fixed,\n-                                   &needs_first_vector))\n-                    return false;\n-\n-                  mask[index++] = current_mask_element;\n-                }\n+              first_mask_element = i + j * group_size;\n+              if (!vect_get_mask_element (stmt, first_mask_element, 0,\n+\t\t\t\t\t  nunits, only_one_vec, index,\n+\t\t\t\t\t  mask, &current_mask_element,\n+\t\t\t\t\t  &need_next_vector,\n+\t\t\t\t\t  &number_of_mask_fixes, &mask_fixed,\n+\t\t\t\t\t  &needs_first_vector))\n+\t\treturn false;\n+\t      mask[index++] = current_mask_element;\n \n-              if (index == mask_nunits)\n+              if (index == nunits)\n                 {\n \t\t  tree mask_vec = NULL;\n \n@@ -2476,8 +2461,7 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n \t\t  mask_vec = build_vector (mask_type, mask_vec);\n \t\t  index = 0;\n \n-\t\t  if (!targetm.vectorize.builtin_vec_perm_ok (vectype,\n-\t\t\t\t\t\t\t      mask_vec))\n+\t\t  if (!can_vec_perm_expr_p (vectype, mask_vec))\n \t\t    {\n \t\t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\t\t{\n@@ -2501,7 +2485,7 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n \n                       vect_create_mask_and_perm (stmt, next_scalar_stmt,\n                                mask_vec, first_vec_index, second_vec_index,\n-\t\t\t       gsi, node, builtin_decl, vectype, dr_chain,\n+\t\t\t       gsi, node, vectype, dr_chain,\n \t\t\t       ncopies, vect_stmts_counter++);\n                     }\n                 }"}, {"sha": "d986ff8a63c08b80cd9c62a8d18ed535f6fab4db", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 18, "deletions": 37, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2635892a1c64fc7e5b8c1c13d53dd0468ffc757d/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2635892a1c64fc7e5b8c1c13d53dd0468ffc757d/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=2635892a1c64fc7e5b8c1c13d53dd0468ffc757d", "patch": "@@ -3996,41 +3996,33 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n }\n \n /* Given a vector type VECTYPE returns a builtin DECL to be used\n-   for vector permutation and stores a mask into *MASK that implements\n-   reversal of the vector elements.  If that is impossible to do\n-   returns NULL (and *MASK is unchanged).  */\n+   for vector permutation and returns the mask that implements\n+   reversal of the vector elements.  If that is impossible to do,\n+   returns NULL.  */\n \n static tree\n-perm_mask_for_reverse (tree vectype, tree *mask)\n+perm_mask_for_reverse (tree vectype)\n {\n-  tree builtin_decl;\n-  tree mask_element_type, mask_type;\n-  tree mask_vec = NULL;\n-  int i;\n-  int nunits;\n-  if (!targetm.vectorize.builtin_vec_perm)\n-    return NULL;\n+  tree mask_element_type, mask_type, mask_vec = NULL;\n+  int i, nunits;\n \n-  builtin_decl = targetm.vectorize.builtin_vec_perm (vectype,\n-                                                     &mask_element_type);\n-  if (!builtin_decl || !mask_element_type)\n+  if (!can_vec_perm_expr_p (vectype, NULL_TREE))\n     return NULL;\n \n+  mask_element_type\n+    = lang_hooks.types.type_for_size\n+    (TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (vectype))), 1);\n   mask_type = get_vectype_for_scalar_type (mask_element_type);\n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  if (!mask_type\n-      || TYPE_VECTOR_SUBPARTS (vectype) != TYPE_VECTOR_SUBPARTS (mask_type))\n-    return NULL;\n \n   for (i = 0; i < nunits; i++)\n     mask_vec = tree_cons (NULL, build_int_cst (mask_element_type, i), mask_vec);\n   mask_vec = build_vector (mask_type, mask_vec);\n \n-  if (!targetm.vectorize.builtin_vec_perm_ok (vectype, mask_vec))\n+  if (!can_vec_perm_expr_p (vectype, mask_vec))\n     return NULL;\n-  if (mask)\n-    *mask = mask_vec;\n-  return builtin_decl;\n+\n+  return mask_vec;\n }\n \n /* Given a vector variable X, that was generated for the scalar LHS of\n@@ -4041,27 +4033,16 @@ static tree\n reverse_vec_elements (tree x, gimple stmt, gimple_stmt_iterator *gsi)\n {\n   tree vectype = TREE_TYPE (x);\n-  tree mask_vec, builtin_decl;\n-  tree perm_dest, data_ref;\n+  tree mask_vec, perm_dest, data_ref;\n   gimple perm_stmt;\n \n-  builtin_decl = perm_mask_for_reverse (vectype, &mask_vec);\n+  mask_vec = perm_mask_for_reverse (vectype);\n \n   perm_dest = vect_create_destination_var (gimple_assign_lhs (stmt), vectype);\n \n   /* Generate the permute statement.  */\n-  perm_stmt = gimple_build_call (builtin_decl, 3, x, x, mask_vec);\n-  if (!useless_type_conversion_p (vectype,\n-\t\t\t\t  TREE_TYPE (TREE_TYPE (builtin_decl))))\n-    {\n-      tree tem = create_tmp_reg (TREE_TYPE (TREE_TYPE (builtin_decl)), NULL);\n-      tem = make_ssa_name (tem, perm_stmt);\n-      gimple_call_set_lhs (perm_stmt, tem);\n-      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n-      perm_stmt = gimple_build_assign (NULL_TREE,\n-\t\t\t\t       build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t       vectype, tem));\n-    }\n+  perm_stmt = gimple_build_assign_with_ops3 (VEC_PERM_EXPR, perm_dest,\n+\t\t\t\t\t     x, x, mask_vec);\n   data_ref = make_ssa_name (perm_dest, perm_stmt);\n   gimple_set_lhs (perm_stmt, data_ref);\n   vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n@@ -4237,7 +4218,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t    fprintf (vect_dump, \"negative step but alignment required.\");\n \t  return false;\n \t}\n-      if (!perm_mask_for_reverse (vectype, NULL))\n+      if (!perm_mask_for_reverse (vectype))\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"negative step and reversing not supported.\");"}]}