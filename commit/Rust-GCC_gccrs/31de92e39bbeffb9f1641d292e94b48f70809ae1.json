{"sha": "31de92e39bbeffb9f1641d292e94b48f70809ae1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFkZTkyZTM5YmJlZmZiOWYxNjQxZDI5MmU5NGI0OGY3MDgwOWFlMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-09-18T18:07:06Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-09-18T18:07:06Z"}, "message": "tree-parloops.c (report_ploop_op): Copy from report_vect_op.\n\n2019-09-18  Richard Biener  <rguenther@suse.de>\n\n\t* tree-parloops.c (report_ploop_op): Copy from report_vect_op.\n\t(parloops_valid_reduction_input_p): Copy from\n\tvalid_reduction_input_p.\n\t(parloops_is_slp_reduction): Copy from vect_is_slp_reduction.\n\t(parloops_needs_fold_left_reduction_p): Copy from\n\tneeds_fold_left_reduction_p.\n\t(parloops_is_simple_reduction): Copy from\n\tvect_is_simple_reduction.\n\t(parloops_force_simple_reduction): Copy from\n\tvect_force_simple_reduction.\n\t(gather_scalar_reductions): Adjust.\n\t* tree-vect-loop.c (vect_force_simple_reduction): Make static.\n\t* tree-vectorizer.h (vect_force_simple_reduction): Remove.\n\nFrom-SVN: r275896", "tree": {"sha": "50bbd9871e7ec0734ae71667575f65b6f20e39be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50bbd9871e7ec0734ae71667575f65b6f20e39be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31de92e39bbeffb9f1641d292e94b48f70809ae1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31de92e39bbeffb9f1641d292e94b48f70809ae1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31de92e39bbeffb9f1641d292e94b48f70809ae1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31de92e39bbeffb9f1641d292e94b48f70809ae1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ba7c8cb5715a162ac41ca5241628e7e02ecd217f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba7c8cb5715a162ac41ca5241628e7e02ecd217f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba7c8cb5715a162ac41ca5241628e7e02ecd217f"}], "stats": {"total": 751, "additions": 739, "deletions": 12}, "files": [{"sha": "edf8028925c591d371ba155781ca171038dffe26", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de92e39bbeffb9f1641d292e94b48f70809ae1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de92e39bbeffb9f1641d292e94b48f70809ae1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31de92e39bbeffb9f1641d292e94b48f70809ae1", "patch": "@@ -1,3 +1,19 @@\n+2019-09-18  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-parloops.c (report_ploop_op): Copy from report_vect_op.\n+\t(parloops_valid_reduction_input_p): Copy from\n+\tvalid_reduction_input_p.\n+\t(parloops_is_slp_reduction): Copy from vect_is_slp_reduction.\n+\t(parloops_needs_fold_left_reduction_p): Copy from\n+\tneeds_fold_left_reduction_p.\n+\t(parloops_is_simple_reduction): Copy from\n+\tvect_is_simple_reduction.\n+\t(parloops_force_simple_reduction): Copy from\n+\tvect_force_simple_reduction.\n+\t(gather_scalar_reductions): Adjust.\n+\t* tree-vect-loop.c (vect_force_simple_reduction): Make static.\n+\t* tree-vectorizer.h (vect_force_simple_reduction): Remove.\n+\n 2019-09-18  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vectorizer.h (get_initial_def_for_reduction): Remove."}, {"sha": "b6bb49b2fa87dd770f97a384bd6847ef735bede8", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 719, "deletions": 7, "changes": 726, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de92e39bbeffb9f1641d292e94b48f70809ae1/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de92e39bbeffb9f1641d292e94b48f70809ae1/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=31de92e39bbeffb9f1641d292e94b48f70809ae1", "patch": "@@ -88,7 +88,8 @@ along with GCC; see the file COPYING3.  If not see\n    More info can also be found at http://gcc.gnu.org/wiki/AutoParInGCC  */\n /*\n   Reduction handling:\n-  currently we use vect_force_simple_reduction() to detect reduction patterns.\n+  currently we use code inspired by vect_force_simple_reduction to detect\n+  reduction patterns.\n   The code transformation will be introduced by an example.\n \n \n@@ -182,6 +183,717 @@ parloop\n \n */\n \n+/* Error reporting helper for parloops_is_simple_reduction below.  GIMPLE\n+   statement STMT is printed with a message MSG. */\n+\n+static void\n+report_ploop_op (dump_flags_t msg_type, gimple *stmt, const char *msg)\n+{\n+  dump_printf_loc (msg_type, vect_location, \"%s%G\", msg, stmt);\n+}\n+\n+/* DEF_STMT_INFO occurs in a loop that contains a potential reduction\n+   operation.  Return true if the results of DEF_STMT_INFO are something\n+   that can be accumulated by such a reduction.  */\n+\n+static bool\n+parloops_valid_reduction_input_p (stmt_vec_info def_stmt_info)\n+{\n+  return (is_gimple_assign (def_stmt_info->stmt)\n+\t  || is_gimple_call (def_stmt_info->stmt)\n+\t  || STMT_VINFO_DEF_TYPE (def_stmt_info) == vect_induction_def\n+\t  || (gimple_code (def_stmt_info->stmt) == GIMPLE_PHI\n+\t      && STMT_VINFO_DEF_TYPE (def_stmt_info) == vect_internal_def\n+\t      && !is_loop_header_bb_p (gimple_bb (def_stmt_info->stmt))));\n+}\n+\n+/* Detect SLP reduction of the form:\n+\n+   #a1 = phi <a5, a0>\n+   a2 = operation (a1)\n+   a3 = operation (a2)\n+   a4 = operation (a3)\n+   a5 = operation (a4)\n+\n+   #a = phi <a5>\n+\n+   PHI is the reduction phi node (#a1 = phi <a5, a0> above)\n+   FIRST_STMT is the first reduction stmt in the chain\n+   (a2 = operation (a1)).\n+\n+   Return TRUE if a reduction chain was detected.  */\n+\n+static bool\n+parloops_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n+\t\t\t   gimple *first_stmt)\n+{\n+  class loop *loop = (gimple_bb (phi))->loop_father;\n+  class loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n+  enum tree_code code;\n+  gimple *loop_use_stmt = NULL;\n+  stmt_vec_info use_stmt_info;\n+  tree lhs;\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+  int nloop_uses, size = 0, n_out_of_loop_uses;\n+  bool found = false;\n+\n+  if (loop != vect_loop)\n+    return false;\n+\n+  auto_vec<stmt_vec_info, 8> reduc_chain;\n+  lhs = PHI_RESULT (phi);\n+  code = gimple_assign_rhs_code (first_stmt);\n+  while (1)\n+    {\n+      nloop_uses = 0;\n+      n_out_of_loop_uses = 0;\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n+        {\n+\t  gimple *use_stmt = USE_STMT (use_p);\n+\t  if (is_gimple_debug (use_stmt))\n+\t    continue;\n+\n+          /* Check if we got back to the reduction phi.  */\n+\t  if (use_stmt == phi)\n+            {\n+\t      loop_use_stmt = use_stmt;\n+              found = true;\n+              break;\n+            }\n+\n+          if (flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n+            {\n+\t      loop_use_stmt = use_stmt;\n+\t      nloop_uses++;\n+            }\n+           else\n+             n_out_of_loop_uses++;\n+\n+           /* There are can be either a single use in the loop or two uses in\n+              phi nodes.  */\n+           if (nloop_uses > 1 || (n_out_of_loop_uses && nloop_uses))\n+             return false;\n+        }\n+\n+      if (found)\n+        break;\n+\n+      /* We reached a statement with no loop uses.  */\n+      if (nloop_uses == 0)\n+\treturn false;\n+\n+      /* This is a loop exit phi, and we haven't reached the reduction phi.  */\n+      if (gimple_code (loop_use_stmt) == GIMPLE_PHI)\n+        return false;\n+\n+      if (!is_gimple_assign (loop_use_stmt)\n+\t  || code != gimple_assign_rhs_code (loop_use_stmt)\n+\t  || !flow_bb_inside_loop_p (loop, gimple_bb (loop_use_stmt)))\n+        return false;\n+\n+      /* Insert USE_STMT into reduction chain.  */\n+      use_stmt_info = loop_info->lookup_stmt (loop_use_stmt);\n+      reduc_chain.safe_push (use_stmt_info);\n+\n+      lhs = gimple_assign_lhs (loop_use_stmt);\n+      size++;\n+   }\n+\n+  if (!found || loop_use_stmt != phi || size < 2)\n+    return false;\n+\n+  /* Swap the operands, if needed, to make the reduction operand be the second\n+     operand.  */\n+  lhs = PHI_RESULT (phi);\n+  for (unsigned i = 0; i < reduc_chain.length (); ++i)\n+    {\n+      gassign *next_stmt = as_a <gassign *> (reduc_chain[i]->stmt);\n+      if (gimple_assign_rhs2 (next_stmt) == lhs)\n+\t{\n+\t  tree op = gimple_assign_rhs1 (next_stmt);\n+\t  stmt_vec_info def_stmt_info = loop_info->lookup_def (op);\n+\n+\t  /* Check that the other def is either defined in the loop\n+\t     (\"vect_internal_def\"), or it's an induction (defined by a\n+\t     loop-header phi-node).  */\n+\t  if (def_stmt_info\n+\t      && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt_info->stmt))\n+\t      && parloops_valid_reduction_input_p (def_stmt_info))\n+\t    {\n+\t      lhs = gimple_assign_lhs (next_stmt);\n+\t      continue;\n+\t    }\n+\n+\t  return false;\n+\t}\n+      else\n+\t{\n+          tree op = gimple_assign_rhs2 (next_stmt);\n+\t  stmt_vec_info def_stmt_info = loop_info->lookup_def (op);\n+\n+          /* Check that the other def is either defined in the loop\n+            (\"vect_internal_def\"), or it's an induction (defined by a\n+            loop-header phi-node).  */\n+\t  if (def_stmt_info\n+\t      && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt_info->stmt))\n+\t      && parloops_valid_reduction_input_p (def_stmt_info))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location, \"swapping oprnds: %G\",\n+\t\t\t\t next_stmt);\n+\n+\t      swap_ssa_operands (next_stmt,\n+\t\t\t\t gimple_assign_rhs1_ptr (next_stmt),\n+                                 gimple_assign_rhs2_ptr (next_stmt));\n+\t      update_stmt (next_stmt);\n+\n+\t      if (CONSTANT_CLASS_P (gimple_assign_rhs1 (next_stmt)))\n+\t\tLOOP_VINFO_OPERANDS_SWAPPED (loop_info) = true;\n+\t    }\n+\t  else\n+\t    return false;\n+        }\n+\n+      lhs = gimple_assign_lhs (next_stmt);\n+    }\n+\n+  /* Build up the actual chain.  */\n+  for (unsigned i = 0; i < reduc_chain.length () - 1; ++i)\n+    {\n+      REDUC_GROUP_FIRST_ELEMENT (reduc_chain[i]) = reduc_chain[0];\n+      REDUC_GROUP_NEXT_ELEMENT (reduc_chain[i]) = reduc_chain[i+1];\n+    }\n+  REDUC_GROUP_FIRST_ELEMENT (reduc_chain.last ()) = reduc_chain[0];\n+  REDUC_GROUP_NEXT_ELEMENT (reduc_chain.last ()) = NULL;\n+\n+  /* Save the chain for further analysis in SLP detection.  */\n+  LOOP_VINFO_REDUCTION_CHAINS (loop_info).safe_push (reduc_chain[0]);\n+  REDUC_GROUP_SIZE (reduc_chain[0]) = size;\n+\n+  return true;\n+}\n+\n+/* Return true if we need an in-order reduction for operation CODE\n+   on type TYPE.  NEED_WRAPPING_INTEGRAL_OVERFLOW is true if integer\n+   overflow must wrap.  */\n+\n+static bool\n+parloops_needs_fold_left_reduction_p (tree type, tree_code code,\n+\t\t\t\t      bool need_wrapping_integral_overflow)\n+{\n+  /* CHECKME: check for !flag_finite_math_only too?  */\n+  if (SCALAR_FLOAT_TYPE_P (type))\n+    switch (code)\n+      {\n+      case MIN_EXPR:\n+      case MAX_EXPR:\n+\treturn false;\n+\n+      default:\n+\treturn !flag_associative_math;\n+      }\n+\n+  if (INTEGRAL_TYPE_P (type))\n+    {\n+      if (!operation_no_trapping_overflow (type, code))\n+\treturn true;\n+      if (need_wrapping_integral_overflow\n+\t  && !TYPE_OVERFLOW_WRAPS (type)\n+\t  && operation_can_overflow (code))\n+\treturn true;\n+      return false;\n+    }\n+\n+  if (SAT_FIXED_POINT_TYPE_P (type))\n+    return true;\n+\n+  return false;\n+}\n+\n+\n+/* Function parloops_is_simple_reduction\n+\n+   (1) Detect a cross-iteration def-use cycle that represents a simple\n+   reduction computation.  We look for the following pattern:\n+\n+   loop_header:\n+     a1 = phi < a0, a2 >\n+     a3 = ...\n+     a2 = operation (a3, a1)\n+\n+   or\n+\n+   a3 = ...\n+   loop_header:\n+     a1 = phi < a0, a2 >\n+     a2 = operation (a3, a1)\n+\n+   such that:\n+   1. operation is commutative and associative and it is safe to\n+      change the order of the computation\n+   2. no uses for a2 in the loop (a2 is used out of the loop)\n+   3. no uses of a1 in the loop besides the reduction operation\n+   4. no uses of a1 outside the loop.\n+\n+   Conditions 1,4 are tested here.\n+   Conditions 2,3 are tested in vect_mark_stmts_to_be_vectorized.\n+\n+   (2) Detect a cross-iteration def-use cycle in nested loops, i.e.,\n+   nested cycles.\n+\n+   (3) Detect cycles of phi nodes in outer-loop vectorization, i.e., double\n+   reductions:\n+\n+     a1 = phi < a0, a2 >\n+     inner loop (def of a3)\n+     a2 = phi < a3 >\n+\n+   (4) Detect condition expressions, ie:\n+     for (int i = 0; i < N; i++)\n+       if (a[i] < val)\n+\tret_val = a[i];\n+\n+*/\n+\n+static stmt_vec_info\n+parloops_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n+\t\t\t  bool *double_reduc,\n+\t\t\t  bool need_wrapping_integral_overflow,\n+\t\t\t  enum vect_reduction_type *v_reduc_type)\n+{\n+  gphi *phi = as_a <gphi *> (phi_info->stmt);\n+  class loop *loop = (gimple_bb (phi))->loop_father;\n+  class loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n+  bool nested_in_vect_loop = flow_loop_nested_p (vect_loop, loop);\n+  gimple *phi_use_stmt = NULL;\n+  enum tree_code orig_code, code;\n+  tree op1, op2, op3 = NULL_TREE, op4 = NULL_TREE;\n+  tree type;\n+  tree name;\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+  bool phi_def;\n+\n+  *double_reduc = false;\n+  *v_reduc_type = TREE_CODE_REDUCTION;\n+\n+  tree phi_name = PHI_RESULT (phi);\n+  /* ???  If there are no uses of the PHI result the inner loop reduction\n+     won't be detected as possibly double-reduction by vectorizable_reduction\n+     because that tries to walk the PHI arg from the preheader edge which\n+     can be constant.  See PR60382.  */\n+  if (has_zero_uses (phi_name))\n+    return NULL;\n+  unsigned nphi_def_loop_uses = 0;\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, phi_name)\n+    {\n+      gimple *use_stmt = USE_STMT (use_p);\n+      if (is_gimple_debug (use_stmt))\n+\tcontinue;\n+\n+      if (!flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n+        {\n+          if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"intermediate value used outside loop.\\n\");\n+\n+          return NULL;\n+        }\n+\n+      nphi_def_loop_uses++;\n+      phi_use_stmt = use_stmt;\n+    }\n+\n+  edge latch_e = loop_latch_edge (loop);\n+  tree loop_arg = PHI_ARG_DEF_FROM_EDGE (phi, latch_e);\n+  if (TREE_CODE (loop_arg) != SSA_NAME)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"reduction: not ssa_name: %T\\n\", loop_arg);\n+      return NULL;\n+    }\n+\n+  stmt_vec_info def_stmt_info = loop_info->lookup_def (loop_arg);\n+  if (!def_stmt_info\n+      || !flow_bb_inside_loop_p (loop, gimple_bb (def_stmt_info->stmt)))\n+    return NULL;\n+\n+  if (gassign *def_stmt = dyn_cast <gassign *> (def_stmt_info->stmt))\n+    {\n+      name = gimple_assign_lhs (def_stmt);\n+      phi_def = false;\n+    }\n+  else if (gphi *def_stmt = dyn_cast <gphi *> (def_stmt_info->stmt))\n+    {\n+      name = PHI_RESULT (def_stmt);\n+      phi_def = true;\n+    }\n+  else\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"reduction: unhandled reduction operation: %G\",\n+\t\t\t def_stmt_info->stmt);\n+      return NULL;\n+    }\n+\n+  unsigned nlatch_def_loop_uses = 0;\n+  auto_vec<gphi *, 3> lcphis;\n+  bool inner_loop_of_double_reduc = false;\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, name)\n+    {\n+      gimple *use_stmt = USE_STMT (use_p);\n+      if (is_gimple_debug (use_stmt))\n+\tcontinue;\n+      if (flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n+\tnlatch_def_loop_uses++;\n+      else\n+\t{\n+\t  /* We can have more than one loop-closed PHI.  */\n+\t  lcphis.safe_push (as_a <gphi *> (use_stmt));\n+\t  if (nested_in_vect_loop\n+\t      && (STMT_VINFO_DEF_TYPE (loop_info->lookup_stmt (use_stmt))\n+\t\t  == vect_double_reduction_def))\n+\t    inner_loop_of_double_reduc = true;\n+\t}\n+    }\n+\n+  /* If this isn't a nested cycle or if the nested cycle reduction value\n+     is used ouside of the inner loop we cannot handle uses of the reduction\n+     value.  */\n+  if ((!nested_in_vect_loop || inner_loop_of_double_reduc)\n+      && (nlatch_def_loop_uses > 1 || nphi_def_loop_uses > 1))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"reduction used in loop.\\n\");\n+      return NULL;\n+    }\n+\n+  /* If DEF_STMT is a phi node itself, we expect it to have a single argument\n+     defined in the inner loop.  */\n+  if (phi_def)\n+    {\n+      gphi *def_stmt = as_a <gphi *> (def_stmt_info->stmt);\n+      op1 = PHI_ARG_DEF (def_stmt, 0);\n+\n+      if (gimple_phi_num_args (def_stmt) != 1\n+          || TREE_CODE (op1) != SSA_NAME)\n+        {\n+          if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"unsupported phi node definition.\\n\");\n+\n+          return NULL;\n+        }\n+\n+      gimple *def1 = SSA_NAME_DEF_STMT (op1);\n+      if (gimple_bb (def1)\n+\t  && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt))\n+          && loop->inner\n+          && flow_bb_inside_loop_p (loop->inner, gimple_bb (def1))\n+          && is_gimple_assign (def1)\n+\t  && is_a <gphi *> (phi_use_stmt)\n+\t  && flow_bb_inside_loop_p (loop->inner, gimple_bb (phi_use_stmt)))\n+        {\n+          if (dump_enabled_p ())\n+            report_ploop_op (MSG_NOTE, def_stmt,\n+\t\t\t     \"detected double reduction: \");\n+\n+          *double_reduc = true;\n+\t  return def_stmt_info;\n+        }\n+\n+      return NULL;\n+    }\n+\n+  /* If we are vectorizing an inner reduction we are executing that\n+     in the original order only in case we are not dealing with a\n+     double reduction.  */\n+  bool check_reduction = true;\n+  if (flow_loop_nested_p (vect_loop, loop))\n+    {\n+      gphi *lcphi;\n+      unsigned i;\n+      check_reduction = false;\n+      FOR_EACH_VEC_ELT (lcphis, i, lcphi)\n+\tFOR_EACH_IMM_USE_FAST (use_p, imm_iter, gimple_phi_result (lcphi))\n+\t  {\n+\t    gimple *use_stmt = USE_STMT (use_p);\n+\t    if (is_gimple_debug (use_stmt))\n+\t      continue;\n+\t    if (! flow_bb_inside_loop_p (vect_loop, gimple_bb (use_stmt)))\n+\t      check_reduction = true;\n+\t  }\n+    }\n+\n+  gassign *def_stmt = as_a <gassign *> (def_stmt_info->stmt);\n+  code = orig_code = gimple_assign_rhs_code (def_stmt);\n+\n+  if (nested_in_vect_loop && !check_reduction)\n+    {\n+      /* FIXME: Even for non-reductions code generation is funneled\n+\t through vectorizable_reduction for the stmt defining the\n+\t PHI latch value.  So we have to artificially restrict ourselves\n+\t for the supported operations.  */\n+      switch (get_gimple_rhs_class (code))\n+\t{\n+\tcase GIMPLE_BINARY_RHS:\n+\tcase GIMPLE_TERNARY_RHS:\n+\t  break;\n+\tdefault:\n+\t  /* Not supported by vectorizable_reduction.  */\n+\t  if (dump_enabled_p ())\n+\t    report_ploop_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t     \"nested cycle: not handled operation: \");\n+\t  return NULL;\n+\t}\n+      if (dump_enabled_p ())\n+\treport_ploop_op (MSG_NOTE, def_stmt, \"detected nested cycle: \");\n+      return def_stmt_info;\n+    }\n+\n+  /* We can handle \"res -= x[i]\", which is non-associative by\n+     simply rewriting this into \"res += -x[i]\".  Avoid changing\n+     gimple instruction for the first simple tests and only do this\n+     if we're allowed to change code at all.  */\n+  if (code == MINUS_EXPR && gimple_assign_rhs2 (def_stmt) != phi_name)\n+    code = PLUS_EXPR;\n+\n+  if (code == COND_EXPR)\n+    {\n+      if (! nested_in_vect_loop)\n+\t*v_reduc_type = COND_REDUCTION;\n+\n+      op3 = gimple_assign_rhs1 (def_stmt);\n+      if (COMPARISON_CLASS_P (op3))\n+        {\n+          op4 = TREE_OPERAND (op3, 1);\n+          op3 = TREE_OPERAND (op3, 0);\n+        }\n+      if (op3 == phi_name || op4 == phi_name)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    report_ploop_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t     \"reduction: condition depends on previous\"\n+\t\t\t     \" iteration: \");\n+\t  return NULL;\n+\t}\n+\n+      op1 = gimple_assign_rhs2 (def_stmt);\n+      op2 = gimple_assign_rhs3 (def_stmt);\n+    }\n+  else if (!commutative_tree_code (code) || !associative_tree_code (code))\n+    {\n+      if (dump_enabled_p ())\n+\treport_ploop_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t \"reduction: not commutative/associative: \");\n+      return NULL;\n+    }\n+  else if (get_gimple_rhs_class (code) == GIMPLE_BINARY_RHS)\n+    {\n+      op1 = gimple_assign_rhs1 (def_stmt);\n+      op2 = gimple_assign_rhs2 (def_stmt);\n+    }\n+  else\n+    {\n+      if (dump_enabled_p ())\n+\treport_ploop_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t \"reduction: not handled operation: \");\n+      return NULL;\n+    }\n+\n+  if (TREE_CODE (op1) != SSA_NAME && TREE_CODE (op2) != SSA_NAME)\n+    {\n+      if (dump_enabled_p ())\n+\treport_ploop_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t \"reduction: both uses not ssa_names: \");\n+\n+      return NULL;\n+    }\n+\n+  type = TREE_TYPE (gimple_assign_lhs (def_stmt));\n+  if ((TREE_CODE (op1) == SSA_NAME\n+       && !types_compatible_p (type,TREE_TYPE (op1)))\n+      || (TREE_CODE (op2) == SSA_NAME\n+          && !types_compatible_p (type, TREE_TYPE (op2)))\n+      || (op3 && TREE_CODE (op3) == SSA_NAME\n+          && !types_compatible_p (type, TREE_TYPE (op3)))\n+      || (op4 && TREE_CODE (op4) == SSA_NAME\n+          && !types_compatible_p (type, TREE_TYPE (op4))))\n+    {\n+      if (dump_enabled_p ())\n+        {\n+          dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"reduction: multiple types: operation type: \"\n+\t\t\t   \"%T, operands types: %T,%T\",\n+\t\t\t   type,  TREE_TYPE (op1), TREE_TYPE (op2));\n+          if (op3)\n+\t    dump_printf (MSG_NOTE, \",%T\", TREE_TYPE (op3));\n+\n+          if (op4)\n+\t    dump_printf (MSG_NOTE, \",%T\", TREE_TYPE (op4));\n+          dump_printf (MSG_NOTE, \"\\n\");\n+        }\n+\n+      return NULL;\n+    }\n+\n+  /* Check whether it's ok to change the order of the computation.\n+     Generally, when vectorizing a reduction we change the order of the\n+     computation.  This may change the behavior of the program in some\n+     cases, so we need to check that this is ok.  One exception is when\n+     vectorizing an outer-loop: the inner-loop is executed sequentially,\n+     and therefore vectorizing reductions in the inner-loop during\n+     outer-loop vectorization is safe.  */\n+  if (check_reduction\n+      && *v_reduc_type == TREE_CODE_REDUCTION\n+      && parloops_needs_fold_left_reduction_p (type, code,\n+\t\t\t\t\t       need_wrapping_integral_overflow))\n+    *v_reduc_type = FOLD_LEFT_REDUCTION;\n+\n+  /* Reduction is safe. We're dealing with one of the following:\n+     1) integer arithmetic and no trapv\n+     2) floating point arithmetic, and special flags permit this optimization\n+     3) nested cycle (i.e., outer loop vectorization).  */\n+  stmt_vec_info def1_info = loop_info->lookup_def (op1);\n+  stmt_vec_info def2_info = loop_info->lookup_def (op2);\n+  if (code != COND_EXPR && !def1_info && !def2_info)\n+    {\n+      if (dump_enabled_p ())\n+\treport_ploop_op (MSG_NOTE, def_stmt,\n+\t\t\t \"reduction: no defs for operands: \");\n+      return NULL;\n+    }\n+\n+  /* Check that one def is the reduction def, defined by PHI,\n+     the other def is either defined in the loop (\"vect_internal_def\"),\n+     or it's an induction (defined by a loop-header phi-node).  */\n+\n+  if (def2_info\n+      && def2_info->stmt == phi\n+      && (code == COND_EXPR\n+\t  || !def1_info\n+\t  || !flow_bb_inside_loop_p (loop, gimple_bb (def1_info->stmt))\n+\t  || parloops_valid_reduction_input_p (def1_info)))\n+    {\n+      if (dump_enabled_p ())\n+\treport_ploop_op (MSG_NOTE, def_stmt, \"detected reduction: \");\n+      return def_stmt_info;\n+    }\n+\n+  if (def1_info\n+      && def1_info->stmt == phi\n+      && (code == COND_EXPR\n+\t  || !def2_info\n+\t  || !flow_bb_inside_loop_p (loop, gimple_bb (def2_info->stmt))\n+\t  || parloops_valid_reduction_input_p (def2_info)))\n+    {\n+      if (! nested_in_vect_loop && orig_code != MINUS_EXPR)\n+\t{\n+\t  /* Check if we can swap operands (just for simplicity - so that\n+\t     the rest of the code can assume that the reduction variable\n+\t     is always the last (second) argument).  */\n+\t  if (code == COND_EXPR)\n+\t    {\n+\t      /* Swap cond_expr by inverting the condition.  */\n+\t      tree cond_expr = gimple_assign_rhs1 (def_stmt);\n+\t      enum tree_code invert_code = ERROR_MARK;\n+\t      enum tree_code cond_code = TREE_CODE (cond_expr);\n+\n+\t      if (TREE_CODE_CLASS (cond_code) == tcc_comparison)\n+\t\t{\n+\t\t  bool honor_nans = HONOR_NANS (TREE_OPERAND (cond_expr, 0));\n+\t\t  invert_code = invert_tree_comparison (cond_code, honor_nans);\n+\t\t}\n+\t      if (invert_code != ERROR_MARK)\n+\t\t{\n+\t\t  TREE_SET_CODE (cond_expr, invert_code);\n+\t\t  swap_ssa_operands (def_stmt,\n+\t\t\t\t     gimple_assign_rhs2_ptr (def_stmt),\n+\t\t\t\t     gimple_assign_rhs3_ptr (def_stmt));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    report_ploop_op (MSG_NOTE, def_stmt,\n+\t\t\t\t     \"detected reduction: cannot swap operands \"\n+\t\t\t\t     \"for cond_expr\");\n+\t\t  return NULL;\n+\t\t}\n+\t    }\n+\t  else\n+\t    swap_ssa_operands (def_stmt, gimple_assign_rhs1_ptr (def_stmt),\n+\t\t\t       gimple_assign_rhs2_ptr (def_stmt));\n+\n+\t  if (dump_enabled_p ())\n+\t    report_ploop_op (MSG_NOTE, def_stmt,\n+\t\t\t     \"detected reduction: need to swap operands: \");\n+\n+\t  if (CONSTANT_CLASS_P (gimple_assign_rhs1 (def_stmt)))\n+\t    LOOP_VINFO_OPERANDS_SWAPPED (loop_info) = true;\n+        }\n+      else\n+        {\n+          if (dump_enabled_p ())\n+            report_ploop_op (MSG_NOTE, def_stmt, \"detected reduction: \");\n+        }\n+\n+      return def_stmt_info;\n+    }\n+\n+  /* Try to find SLP reduction chain.  */\n+  if (! nested_in_vect_loop\n+      && code != COND_EXPR\n+      && orig_code != MINUS_EXPR\n+      && parloops_is_slp_reduction (loop_info, phi, def_stmt))\n+    {\n+      if (dump_enabled_p ())\n+        report_ploop_op (MSG_NOTE, def_stmt,\n+\t\t\t \"reduction: detected reduction chain: \");\n+\n+      return def_stmt_info;\n+    }\n+\n+  /* Look for the expression computing loop_arg from loop PHI result.  */\n+  if (check_reduction_path (vect_location, loop, phi, loop_arg, code))\n+    return def_stmt_info;\n+\n+  if (dump_enabled_p ())\n+    {\n+      report_ploop_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t       \"reduction: unknown pattern: \");\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Wrapper around vect_is_simple_reduction, which will modify code\n+   in-place if it enables detection of more reductions.  Arguments\n+   as there.  */\n+\n+stmt_vec_info\n+parloops_force_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n+\t\t\t     bool *double_reduc,\n+\t\t\t     bool need_wrapping_integral_overflow)\n+{\n+  enum vect_reduction_type v_reduc_type;\n+  stmt_vec_info def_info\n+    = parloops_is_simple_reduction (loop_info, phi_info, double_reduc,\n+\t\t\t\tneed_wrapping_integral_overflow,\n+\t\t\t\t&v_reduc_type);\n+  if (def_info)\n+    {\n+      STMT_VINFO_REDUC_TYPE (phi_info) = v_reduc_type;\n+      STMT_VINFO_REDUC_DEF (phi_info) = def_info;\n+      STMT_VINFO_REDUC_TYPE (def_info) = v_reduc_type;\n+      STMT_VINFO_REDUC_DEF (def_info) = phi_info;\n+    }\n+  return def_info;\n+}\n+\n /* Minimal number of iterations of a loop that should be executed in each\n    thread.  */\n #define MIN_PER_THREAD PARAM_VALUE (PARAM_PARLOOPS_MIN_PER_THREAD)\n@@ -2615,9 +3327,9 @@ gather_scalar_reductions (loop_p loop, reduction_info_table_type *reduction_list\n \tcontinue;\n \n       stmt_vec_info reduc_stmt_info\n-\t= vect_force_simple_reduction (simple_loop_info,\n-\t\t\t\t       simple_loop_info->lookup_stmt (phi),\n-\t\t\t\t       &double_reduc, true);\n+\t= parloops_force_simple_reduction (simple_loop_info,\n+\t\t\t\t\t   simple_loop_info->lookup_stmt (phi),\n+\t\t\t\t\t   &double_reduc, true);\n       if (!reduc_stmt_info || !valid_reduction_p (reduc_stmt_info))\n \tcontinue;\n \n@@ -2664,9 +3376,9 @@ gather_scalar_reductions (loop_p loop, reduction_info_table_type *reduction_list\n \t      stmt_vec_info inner_phi_info\n \t\t= simple_loop_info->lookup_stmt (inner_phi);\n \t      stmt_vec_info inner_reduc_stmt_info\n-\t\t= vect_force_simple_reduction (simple_loop_info,\n-\t\t\t\t\t       inner_phi_info,\n-\t\t\t\t\t       &double_reduc, true);\n+\t\t= parloops_force_simple_reduction (simple_loop_info,\n+\t\t\t\t\t\t   inner_phi_info,\n+\t\t\t\t\t\t   &double_reduc, true);\n \t      gcc_assert (!double_reduc);\n \t      if (!inner_reduc_stmt_info\n \t\t  || !valid_reduction_p (inner_reduc_stmt_info))"}, {"sha": "daf3370a52bc3585f0d1f1deceefebaec36497aa", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de92e39bbeffb9f1641d292e94b48f70809ae1/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de92e39bbeffb9f1641d292e94b48f70809ae1/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=31de92e39bbeffb9f1641d292e94b48f70809ae1", "patch": "@@ -154,6 +154,8 @@ along with GCC; see the file COPYING3.  If not see\n */\n \n static void vect_estimate_min_profitable_iters (loop_vec_info, int *, int *);\n+static stmt_vec_info vect_force_simple_reduction (loop_vec_info, stmt_vec_info,\n+\t\t\t\t\t\t  bool *, bool);\n \n /* Subroutine of vect_determine_vf_for_stmt that handles only one\n    statement.  VECTYPE_MAYBE_SET_P is true if STMT_VINFO_VECTYPE\n@@ -3361,7 +3363,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n    in-place if it enables detection of more reductions.  Arguments\n    as there.  */\n \n-stmt_vec_info\n+static stmt_vec_info\n vect_force_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n \t\t\t     bool *double_reduc,\n \t\t\t     bool need_wrapping_integral_overflow)"}, {"sha": "ee6fe9af1b93d334ee639564738ae3aa3824bca6", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de92e39bbeffb9f1641d292e94b48f70809ae1/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de92e39bbeffb9f1641d292e94b48f70809ae1/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=31de92e39bbeffb9f1641d292e94b48f70809ae1", "patch": "@@ -1611,11 +1611,8 @@ extern tree vect_create_addr_base_for_vector_ref (stmt_vec_info, gimple_seq *,\n \t\t\t\t\t\t  tree, tree = NULL_TREE);\n \n /* In tree-vect-loop.c.  */\n-/* FORNOW: Used in tree-parloops.c.  */\n-extern stmt_vec_info vect_force_simple_reduction (loop_vec_info, stmt_vec_info,\n-\t\t\t\t\t\t  bool *, bool);\n extern widest_int vect_iv_limit_for_full_masking (loop_vec_info loop_vinfo);\n-/* Used in gimple-loop-interchange.c.  */\n+/* Used in gimple-loop-interchange.c and tree-parloops.c.  */\n extern bool check_reduction_path (dump_user_location_t, loop_p, gphi *, tree,\n \t\t\t\t  enum tree_code);\n /* Drive for loop analysis stage.  */"}]}