{"sha": "e165d9e5cda4121db20e321d5d6d28bd9e9275d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE2NWQ5ZTVjZGE0MTIxZGIyMGUzMjFkNWQ2ZDI4YmQ5ZTkyNzVkNg==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-03-23T12:50:44Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-03-23T12:50:44Z"}, "message": "(untyped_call, blockage): New patterns.\n\nFrom-SVN: r3839", "tree": {"sha": "b5a48992266a1dbdbe2c55a98e222bde9df68113", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5a48992266a1dbdbe2c55a98e222bde9df68113"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e165d9e5cda4121db20e321d5d6d28bd9e9275d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e165d9e5cda4121db20e321d5d6d28bd9e9275d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e165d9e5cda4121db20e321d5d6d28bd9e9275d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e165d9e5cda4121db20e321d5d6d28bd9e9275d6/comments", "author": null, "committer": null, "parents": [{"sha": "7972af82c6594d3db7a513d65a4540bef8bc6f87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7972af82c6594d3db7a513d65a4540bef8bc6f87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7972af82c6594d3db7a513d65a4540bef8bc6f87"}], "stats": {"total": 185, "additions": 185, "deletions": 0}, "files": [{"sha": "abadd8f3b10b7ed887443accf9ea8e3f2a853e07", "filename": "gcc/config/fx80/fx80.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e165d9e5cda4121db20e321d5d6d28bd9e9275d6/gcc%2Fconfig%2Ffx80%2Ffx80.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e165d9e5cda4121db20e321d5d6d28bd9e9275d6/gcc%2Fconfig%2Ffx80%2Ffx80.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffx80%2Ffx80.md?ref=e165d9e5cda4121db20e321d5d6d28bd9e9275d6", "patch": "@@ -2432,6 +2432,43 @@\n   return \\\"mov%.l a6@(-4),a0\\\";\n }\")\n \n+;; Call subroutine returning any type.\n+\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n+  \"\"\n+  \"\n+{\n+  int i;\n+\n+  emit_call_insn (gen_call (operands[0], const0_rtx, NULL, const0_rtx));\n+\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+    }\n+\n+  /* The optimizer does not know that the call sets the function value\n+     registers we stored in the result block.  We avoid problems by\n+     claiming that all hard registers are used and clobbered at this\n+     point.  */\n+  emit_insn (gen_blockage ());\n+\n+  DONE;\n+}\")\n+\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\")\n+\n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\""}, {"sha": "95b6f5d511f8aa819f393563cee4b7596dac5da0", "filename": "gcc/config/gmicro/gmicro.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e165d9e5cda4121db20e321d5d6d28bd9e9275d6/gcc%2Fconfig%2Fgmicro%2Fgmicro.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e165d9e5cda4121db20e321d5d6d28bd9e9275d6/gcc%2Fconfig%2Fgmicro%2Fgmicro.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgmicro%2Fgmicro.md?ref=e165d9e5cda4121db20e321d5d6d28bd9e9275d6", "patch": "@@ -2493,6 +2493,43 @@\n   return \\\"jsr %1\\\";\n }\")\n \n+;; Call subroutine returning any type.\n+\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n+  \"\"\n+  \"\n+{\n+  int i;\n+\n+  emit_call_insn (gen_call (operands[0], const0_rtx, NULL, const0_rtx));\n+\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+    }\n+\n+  /* The optimizer does not know that the call sets the function value\n+     registers we stored in the result block.  We avoid problems by\n+     claiming that all hard registers are used and clobbered at this\n+     point.  */\n+  emit_insn (gen_blockage ());\n+\n+  DONE;\n+}\")\n+\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\")\n+\n (define_insn \"nop\"\n   [(const_int 0)]\n     \"\""}, {"sha": "471b5b2a07946d550484ec542a55093524dfac92", "filename": "gcc/config/i860/i860.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e165d9e5cda4121db20e321d5d6d28bd9e9275d6/gcc%2Fconfig%2Fi860%2Fi860.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e165d9e5cda4121db20e321d5d6d28bd9e9275d6/gcc%2Fconfig%2Fi860%2Fi860.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.md?ref=e165d9e5cda4121db20e321d5d6d28bd9e9275d6", "patch": "@@ -2235,6 +2235,43 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n     return output_delayed_branch (\\\"calli %3\\\", operands, insn);\n   return output_delayed_branch (\\\"call %3\\\", operands, insn);\n }\")\n+\n+;; Call subroutine returning any type.\n+\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n+  \"\"\n+  \"\n+{\n+  int i;\n+\n+  emit_call_insn (gen_call (operands[0], const0_rtx, NULL, const0_rtx));\n+\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+    }\n+\n+  /* The optimizer does not know that the call sets the function value\n+     registers we stored in the result block.  We avoid problems by\n+     claiming that all hard registers are used and clobbered at this\n+     point.  */\n+  emit_insn (gen_blockage ());\n+\n+  DONE;\n+}\")\n+\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\")\n \f\n (define_insn \"nop\"\n   [(const_int 0)]"}, {"sha": "6217028fa79b3f68e81b3d9ccc45d3dbc3286e69", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e165d9e5cda4121db20e321d5d6d28bd9e9275d6/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e165d9e5cda4121db20e321d5d6d28bd9e9275d6/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=e165d9e5cda4121db20e321d5d6d28bd9e9275d6", "patch": "@@ -4780,6 +4780,43 @@\n   return \\\"jsr %1\\\";\n \")\n \n+;; Call subroutine returning any type.\n+\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n+  \"NEEDS_UNTYPED_CALL\"\n+  \"\n+{\n+  int i;\n+\n+  emit_call_insn (gen_call (operands[0], const0_rtx, NULL, const0_rtx));\n+\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+    }\n+\n+  /* The optimizer does not know that the call sets the function value\n+     registers we stored in the result block.  We avoid problems by\n+     claiming that all hard registers are used and clobbered at this\n+     point.  */\n+  emit_insn (gen_blockage ());\n+\n+  DONE;\n+}\")\n+\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\")\n+\n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\""}, {"sha": "dd0c21f07d4af3b62ce946687e9846b3f9362a39", "filename": "gcc/config/ns32k/ns32k.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e165d9e5cda4121db20e321d5d6d28bd9e9275d6/gcc%2Fconfig%2Fns32k%2Fns32k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e165d9e5cda4121db20e321d5d6d28bd9e9275d6/gcc%2Fconfig%2Fns32k%2Fns32k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.md?ref=e165d9e5cda4121db20e321d5d6d28bd9e9275d6", "patch": "@@ -2273,6 +2273,43 @@\n   return \\\"jsr %1\\\";\n }\")\n \n+;; Call subroutine returning any type.\n+\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n+  \"\"\n+  \"\n+{\n+  int i;\n+\n+  emit_call_insn (gen_call (operands[0], const0_rtx, NULL, const0_rtx));\n+\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+    }\n+\n+  /* The optimizer does not know that the call sets the function value\n+     registers we stored in the result block.  We avoid problems by\n+     claiming that all hard registers are used and clobbered at this\n+     point.  */\n+  emit_insn (gen_blockage ());\n+\n+  DONE;\n+}\")\n+\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\")\n+\n (define_insn \"return\"\n   [(return)]\n   \"0\""}]}