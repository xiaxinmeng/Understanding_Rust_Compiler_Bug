{"sha": "8fc541d3a5225284038d28ebe0b80cba2da3371b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZjNTQxZDNhNTIyNTI4NDAzOGQyOGViZTBiODBjYmEyZGEzMzcxYg==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "coudert@clipper.ens.fr", "date": "2008-05-06T18:28:32Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2008-05-06T18:28:32Z"}, "message": "openmp.c (gfc_match_omp_eos): Use gfc_next_ascii_char and gfc_peek_ascii_char.\n\n\t* openmp.c (gfc_match_omp_eos): Use gfc_next_ascii_char and\n\tgfc_peek_ascii_char.\n\t* decl.c (gfc_match_kind_spec, gfc_match_type_spec,\n\tgfc_match_implicit_none, match_implicit_range, gfc_match_implicit,\n\tmatch_string_p, match_attr_spec, gfc_match_suffix,\n\tmatch_procedure_decl, gfc_match_entry, gfc_match_subroutine):\n\tLikewise.\n\t* gfortran.h (gfc_char_t): New type.\n\t(gfc_linebuf): Make line member a gfc_char_t.\n\t(locus): Make nextc member a gfc_char_t.\n\t(gfc_wide_is_printable, gfc_wide_is_digit, gfc_wide_fits_in_byte,\n\tgfc_wide_tolower, gfc_wide_strlen, gfc_next_ascii_char,\n\tgfc_peek_ascii_char, gfc_check_digit): New prototypes.\n\t* error.c (print_wide_char): New function.\n\t(show_locus): Use print_wide_char and gfc_wide_strlen.\n\t* io.c (next_char): Use gfc_char_t type.\n\t(match_io): Use gfc_peek_ascii_char and gfc_next_ascii_char.\n\t* match.c (gfc_match_parens, gfc_match_eos,\n\tgfc_match_small_literal_int, gfc_match_name, gfc_match_name_C,\n\tgfc_match_intrinsic_op, gfc_match_char,  gfc_match_return,\n\tgfc_match_common): Likewise.\n\t* match.h (gfc_match_special_char): Change prototype.\n\t* parse.c (decode_specification_statement, decode_statement,\n\tdecode_omp_directive, next_free, next_fixed): Use\n\tgfc_peek_ascii_char and gfc_next_ascii_char.\n\t* primary.c (gfc_check_digit): Change name.\n\t(match_digits, match_hollerith_constant, match_boz_constant,\n\tmatch_real_constant, next_string_char, match_charkind_name,\n\tmatch_string_constant, match_logical_constant_string,\n\tmatch_complex_constant, match_actual_arg, match_varspec,\n\tgfc_match_rvalue, match_variable): Use gfc_peek_ascii_char and\n\tgfc_next_ascii_char.\n\t* scanner.c (gfc_wide_fits_in_byte, wide_is_ascii,\n\tgfc_wide_is_printable, gfc_wide_tolower, gfc_wide_is_digit,\n\tgfc_wide_is_digit, wide_atoi, gfc_wide_strlen, wide_strcpy,\n\twide_strchr, widechar_to_char, wide_strncmp, wide_strncasecmp,\n\tgfc_next_ascii_char, gfc_peek_ascii_char):\n\tNew functions.\n\t(next_char, gfc_define_undef_line, skip_free_comments,\n\tgfc_next_char_literal, gfc_next_char, gfc_peek_char,\n\tgfc_error_recovery, load_line, preprocessor_line, include_line,\n\tload_file, gfc_read_orig_filename): Use gfc_char_t for source\n\tcharacters and the {gfc_,}wide_* functions to manipulate wide\n\tstrings.\n\nFrom-SVN: r134992", "tree": {"sha": "d926f63d76077ffa46dd7c352606226f8d001250", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d926f63d76077ffa46dd7c352606226f8d001250"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fc541d3a5225284038d28ebe0b80cba2da3371b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fc541d3a5225284038d28ebe0b80cba2da3371b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fc541d3a5225284038d28ebe0b80cba2da3371b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fc541d3a5225284038d28ebe0b80cba2da3371b/comments", "author": null, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0b48c6701e4175beabeb6a9619646a7b16f2698", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0b48c6701e4175beabeb6a9619646a7b16f2698", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0b48c6701e4175beabeb6a9619646a7b16f2698"}], "stats": {"total": 959, "additions": 653, "deletions": 306}, "files": [{"sha": "3ce9b4e4b01e7419c88ed416c084b45b4d65496a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8fc541d3a5225284038d28ebe0b80cba2da3371b", "patch": "@@ -1,3 +1,50 @@\n+2008-05-06  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\t* openmp.c (gfc_match_omp_eos): Use gfc_next_ascii_char and\n+\tgfc_peek_ascii_char.\n+\t* decl.c (gfc_match_kind_spec, gfc_match_type_spec,\n+\tgfc_match_implicit_none, match_implicit_range, gfc_match_implicit,\n+\tmatch_string_p, match_attr_spec, gfc_match_suffix,\n+\tmatch_procedure_decl, gfc_match_entry, gfc_match_subroutine):\n+\tLikewise.\n+\t* gfortran.h (gfc_char_t): New type.\n+\t(gfc_linebuf): Make line member a gfc_char_t.\n+\t(locus): Make nextc member a gfc_char_t.\n+\t(gfc_wide_is_printable, gfc_wide_is_digit, gfc_wide_fits_in_byte,\n+\tgfc_wide_tolower, gfc_wide_strlen, gfc_next_ascii_char,\n+\tgfc_peek_ascii_char, gfc_check_digit): New prototypes.\n+\t* error.c (print_wide_char): New function.\n+\t(show_locus): Use print_wide_char and gfc_wide_strlen.\n+\t* io.c (next_char): Use gfc_char_t type.\n+\t(match_io): Use gfc_peek_ascii_char and gfc_next_ascii_char.\n+\t* match.c (gfc_match_parens, gfc_match_eos,\n+\tgfc_match_small_literal_int, gfc_match_name, gfc_match_name_C,\n+\tgfc_match_intrinsic_op, gfc_match_char,  gfc_match_return,\n+\tgfc_match_common): Likewise.\n+\t* match.h (gfc_match_special_char): Change prototype.\n+\t* parse.c (decode_specification_statement, decode_statement,\n+\tdecode_omp_directive, next_free, next_fixed): Use\n+\tgfc_peek_ascii_char and gfc_next_ascii_char.\n+\t* primary.c (gfc_check_digit): Change name.\n+\t(match_digits, match_hollerith_constant, match_boz_constant,\n+\tmatch_real_constant, next_string_char, match_charkind_name,\n+\tmatch_string_constant, match_logical_constant_string,\n+\tmatch_complex_constant, match_actual_arg, match_varspec,\n+\tgfc_match_rvalue, match_variable): Use gfc_peek_ascii_char and\n+\tgfc_next_ascii_char.\n+\t* scanner.c (gfc_wide_fits_in_byte, wide_is_ascii,\n+\tgfc_wide_is_printable, gfc_wide_tolower, gfc_wide_is_digit,\n+\tgfc_wide_is_digit, wide_atoi, gfc_wide_strlen, wide_strcpy,\n+\twide_strchr, widechar_to_char, wide_strncmp, wide_strncasecmp,\n+\tgfc_next_ascii_char, gfc_peek_ascii_char):\n+\tNew functions.\n+\t(next_char, gfc_define_undef_line, skip_free_comments,\n+\tgfc_next_char_literal, gfc_next_char, gfc_peek_char,\n+\tgfc_error_recovery, load_line, preprocessor_line, include_line,\n+\tload_file, gfc_read_orig_filename): Use gfc_char_t for source\n+\tcharacters and the {gfc_,}wide_* functions to manipulate wide\n+\tstrings.\n+\n 2008-05-06  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/36117"}, {"sha": "6b462f97bb64f9b8111dcf7b1ce571440f07652c", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=8fc541d3a5225284038d28ebe0b80cba2da3371b", "patch": "@@ -1940,7 +1940,8 @@ gfc_match_kind_spec (gfc_typespec *ts, bool kind_expr_only)\n     }\n \n   gfc_gobble_whitespace ();\n-  if ((c = gfc_next_char ()) != ')' && (ts->type != BT_CHARACTER || c != ','))\n+  if ((c = gfc_next_ascii_char ()) != ')'\n+      && (ts->type != BT_CHARACTER || c != ','))\n     {\n       if (ts->type == BT_CHARACTER)\n \tgfc_error (\"Missing right parenthesis or comma at %C\");\n@@ -2213,7 +2214,7 @@ gfc_match_type_spec (gfc_typespec *ts, int implicit_flag)\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *sym;\n   match m;\n-  int c;\n+  char c;\n   bool seen_deferred_kind;\n \n   /* A belt and braces check that the typespec is correctly being treated\n@@ -2360,7 +2361,7 @@ gfc_match_type_spec (gfc_typespec *ts, int implicit_flag)\n \n   if (gfc_current_form == FORM_FREE)\n     {\n-      c = gfc_peek_char();\n+      c = gfc_peek_ascii_char();\n       if (!gfc_is_whitespace(c) && c != '*' && c != '('\n \t  && c != ':' && c != ',')\n        return MATCH_NO;\n@@ -2400,13 +2401,14 @@ gfc_match_implicit_none (void)\n static match\n match_implicit_range (void)\n {\n-  int c, c1, c2, inner;\n+  char c, c1, c2;\n+  int inner;\n   locus cur_loc;\n \n   cur_loc = gfc_current_locus;\n \n   gfc_gobble_whitespace ();\n-  c = gfc_next_char ();\n+  c = gfc_next_ascii_char ();\n   if (c != '(')\n     {\n       gfc_error (\"Missing character range in IMPLICIT at %C\");\n@@ -2417,12 +2419,12 @@ match_implicit_range (void)\n   while (inner)\n     {\n       gfc_gobble_whitespace ();\n-      c1 = gfc_next_char ();\n+      c1 = gfc_next_ascii_char ();\n       if (!ISALPHA (c1))\n \tgoto bad;\n \n       gfc_gobble_whitespace ();\n-      c = gfc_next_char ();\n+      c = gfc_next_ascii_char ();\n \n       switch (c)\n \t{\n@@ -2435,12 +2437,12 @@ match_implicit_range (void)\n \n \tcase '-':\n \t  gfc_gobble_whitespace ();\n-\t  c2 = gfc_next_char ();\n+\t  c2 = gfc_next_ascii_char ();\n \t  if (!ISALPHA (c2))\n \t    goto bad;\n \n \t  gfc_gobble_whitespace ();\n-\t  c = gfc_next_char ();\n+\t  c = gfc_next_ascii_char ();\n \n \t  if ((c != ',') && (c != ')'))\n \t    goto bad;\n@@ -2503,7 +2505,7 @@ gfc_match_implicit (void)\n {\n   gfc_typespec ts;\n   locus cur_loc;\n-  int c;\n+  char c;\n   match m;\n \n   gfc_clear_ts (&ts);\n@@ -2534,7 +2536,7 @@ gfc_match_implicit (void)\n \t{\n \t  /* We may have <TYPE> (<RANGE>).  */\n \t  gfc_gobble_whitespace ();\n-\t  c = gfc_next_char ();\n+\t  c = gfc_next_ascii_char ();\n \t  if ((c == '\\n') || (c == ','))\n \t    {\n \t      /* Check for CHARACTER with no length parameter.  */\n@@ -2584,7 +2586,7 @@ gfc_match_implicit (void)\n \tgoto syntax;\n \n       gfc_gobble_whitespace ();\n-      c = gfc_next_char ();\n+      c = gfc_next_ascii_char ();\n       if ((c != '\\n') && (c != ','))\n \tgoto syntax;\n \n@@ -2713,7 +2715,7 @@ match_string_p (const char *target)\n   const char *p;\n \n   for (p = target; *p; p++)\n-    if (gfc_next_char () != *p)\n+    if ((char) gfc_next_ascii_char () != *p)\n       return false;\n   return true;\n }\n@@ -2765,22 +2767,22 @@ match_attr_spec (void)\n \n   for (;;)\n     {\n-      int ch;\n+      char ch;\n \n       d = DECL_NONE;\n       gfc_gobble_whitespace ();\n \n-      ch = gfc_next_char ();\n+      ch = gfc_next_ascii_char ();\n       if (ch == ':')\n \t{\n \t  /* This is the successful exit condition for the loop.  */\n-\t  if (gfc_next_char () == ':')\n+\t  if (gfc_next_ascii_char () == ':')\n \t    break;\n \t}\n       else if (ch == ',')\n \t{\n \t  gfc_gobble_whitespace ();\n-\t  switch (gfc_peek_char ())\n+\t  switch (gfc_peek_ascii_char ())\n \t    {\n \t    case 'a':\n \t      if (match_string_p (\"allocatable\"))\n@@ -2809,7 +2811,7 @@ match_attr_spec (void)\n \t    case 'i':\n \t      if (match_string_p (\"int\"))\n \t\t{\n-\t\t  ch = gfc_next_char ();\n+\t\t  ch = gfc_next_ascii_char ();\n \t\t  if (ch == 'e')\n \t\t    {\n \t\t      if (match_string_p (\"nt\"))\n@@ -2841,8 +2843,8 @@ match_attr_spec (void)\n \t      break;\n \n \t    case 'p':\n-\t      gfc_next_char ();\n-\t      switch (gfc_next_char ())\n+\t      gfc_next_ascii_char ();\n+\t      switch (gfc_next_ascii_char ())\n \t\t{\n \t\tcase 'a':\n \t\t  if (match_string_p (\"rameter\"))\n@@ -2861,7 +2863,7 @@ match_attr_spec (void)\n \t\t  break;\n \n \t\tcase 'r':\n-\t\t  ch = gfc_next_char ();\n+\t\t  ch = gfc_next_ascii_char ();\n \t\t  if (ch == 'i')\n \t\t    {\n \t\t      if (match_string_p (\"vate\"))\n@@ -2901,8 +2903,8 @@ match_attr_spec (void)\n \t      break;\n \n \t    case 'v':\n-\t      gfc_next_char ();\n-\t      ch = gfc_next_char ();\n+\t      gfc_next_ascii_char ();\n+\t      ch = gfc_next_ascii_char ();\n \t      if (ch == 'a')\n \t\t{\n \t\t  if (match_string_p (\"lue\"))\n@@ -3938,7 +3940,7 @@ gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n   match is_bind_c;   /* Found bind(c).  */\n   match is_result;   /* Found result clause.  */\n   match found_match; /* Status of whether we've found a good match.  */\n-  int peek_char;     /* Character we're going to peek at.  */\n+  char peek_char;    /* Character we're going to peek at.  */\n   bool allow_binding_name;\n \n   /* Initialize to having found nothing.  */\n@@ -3948,7 +3950,7 @@ gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n \n   /* Get the next char to narrow between result and bind(c).  */\n   gfc_gobble_whitespace ();\n-  peek_char = gfc_peek_char ();\n+  peek_char = gfc_peek_ascii_char ();\n \n   /* C binding names are not allowed for internal procedures.  */\n   if (gfc_current_state () == COMP_CONTAINS\n@@ -4037,7 +4039,7 @@ match_procedure_decl (void)\n   /* Get the type spec. for the procedure interface.  */\n   old_loc = gfc_current_locus;\n   m = gfc_match_type_spec (&current_ts, 0);\n-  if (m == MATCH_YES || (m == MATCH_NO && gfc_peek_char () == ')'))\n+  if (m == MATCH_YES || (m == MATCH_NO && gfc_peek_ascii_char () == ')'))\n     goto got_ts;\n \n   if (m == MATCH_ERROR)\n@@ -4530,7 +4532,7 @@ gfc_match_entry (void)\n   /* Check what next non-whitespace character is so we can tell if there\n      is the required parens if we have a BIND(C).  */\n   gfc_gobble_whitespace ();\n-  peek_char = gfc_peek_char ();\n+  peek_char = gfc_peek_ascii_char ();\n \n   if (state == COMP_SUBROUTINE)\n     {\n@@ -4686,7 +4688,7 @@ gfc_match_subroutine (void)\n   /* Check what next non-whitespace character is so we can tell if there\n      is the required parens if we have a BIND(C).  */\n   gfc_gobble_whitespace ();\n-  peek_char = gfc_peek_char ();\n+  peek_char = gfc_peek_ascii_char ();\n   \n   if (gfc_add_subroutine (&sym->attr, sym->name, NULL) == FAILURE)\n     return MATCH_ERROR;\n@@ -5486,7 +5488,7 @@ match\n gfc_match_pointer (void)\n {\n   gfc_gobble_whitespace ();\n-  if (gfc_peek_char () == '(')\n+  if (gfc_peek_ascii_char () == '(')\n     {\n       if (!gfc_option.flag_cray_pointer)\n \t{"}, {"sha": "c119bcadd7deeb3b7ea0a158e5f16cb4857b5a7d", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 65, "deletions": 21, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=8fc541d3a5225284038d28ebe0b80cba2da3371b", "patch": "@@ -156,15 +156,75 @@ error_integer (long int i)\n    locus.  Calls error_printf() recursively, but the recursion is at\n    most one level deep.  */\n \n+static void\n+print_wide_char (gfc_char_t c)\n+{\n+  static const char xdigit[16] = { '0', '1', '2', '3', '4', '5', '6',\n+    '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n+  char buf[9];\n+\n+  if (gfc_wide_is_printable (c))\n+    error_char (c);\n+  else if (c < ((gfc_char_t) 1 << 8))\n+    {\n+      buf[2] = '\\0';\n+      buf[1] = xdigit[c & 0x0F];\n+      c = c >> 4;\n+      buf[0] = xdigit[c & 0x0F];\n+\n+      error_char ('\\\\');\n+      error_char ('x');\n+      error_string (buf);\n+    }\n+  else if (c < ((gfc_char_t) 1 << 16))\n+    {\n+      buf[4] = '\\0';\n+      buf[3] = xdigit[c & 0x0F];\n+      c = c >> 4;\n+      buf[2] = xdigit[c & 0x0F];\n+      c = c >> 4;\n+      buf[1] = xdigit[c & 0x0F];\n+      c = c >> 4;\n+      buf[0] = xdigit[c & 0x0F];\n+\n+      error_char ('\\\\');\n+      error_char ('u');\n+      error_string (buf);\n+    }\n+  else\n+    {\n+      buf[8] = '\\0';\n+      buf[7] = xdigit[c & 0x0F];\n+      c = c >> 4;\n+      buf[6] = xdigit[c & 0x0F];\n+      c = c >> 4;\n+      buf[5] = xdigit[c & 0x0F];\n+      c = c >> 4;\n+      buf[4] = xdigit[c & 0x0F];\n+      c = c >> 4;\n+      buf[3] = xdigit[c & 0x0F];\n+      c = c >> 4;\n+      buf[2] = xdigit[c & 0x0F];\n+      c = c >> 4;\n+      buf[1] = xdigit[c & 0x0F];\n+      c = c >> 4;\n+      buf[0] = xdigit[c & 0x0F];\n+\n+      error_char ('\\\\');\n+      error_char ('U');\n+      error_string (buf);\n+    }\n+}\n+\n static void error_printf (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n \n static void\n show_locus (locus *loc, int c1, int c2)\n {\n   gfc_linebuf *lb;\n   gfc_file *f;\n-  char c, *p;\n-  int i, m, offset, cmax;\n+  gfc_char_t c, *p;\n+  int i, offset, cmax;\n \n   /* TODO: Either limit the total length and number of included files\n      displayed or add buffering of arbitrary number of characters in\n@@ -246,8 +306,8 @@ show_locus (locus *loc, int c1, int c2)\n      to work correctly when nonprintable characters exist.  A better \n      solution should be found.  */\n \n-  p = lb->line + offset;\n-  i = strlen (p);\n+  p = &(lb->line[offset]);\n+  i = gfc_wide_strlen (p);\n   if (i > terminal_width)\n     i = terminal_width - 1;\n \n@@ -257,23 +317,7 @@ show_locus (locus *loc, int c1, int c2)\n       if (c == '\\t')\n \tc = ' ';\n \n-      if (ISPRINT (c))\n-\terror_char (c);\n-      else\n-\t{\n-\t  error_char ('\\\\');\n-\t  error_char ('x');\n-\n-\t  m = ((c >> 4) & 0x0F) + '0';\n-\t  if (m > '9')\n-\t    m += 'A' - '9' - 1;\n-\t  error_char (m);\n-\n-\t  m = (c & 0x0F) + '0';\n-\t  if (m > '9')\n-\t    m += 'A' - '9' - 1;\n-\t  error_char (m);\n-\t}\n+      print_wide_char (c);\n     }\n \n   error_char ('\\n');"}, {"sha": "36c970ca0c85ec0f9eef10a0e7745ddc780d9b68", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=8fc541d3a5225284038d28ebe0b80cba2da3371b", "patch": "@@ -700,6 +700,21 @@ typedef struct\n symbol_attribute;\n \n \n+/* We need to store source lines as sequences of multibyte source\n+   characters. We define here a type wide enough to hold any multibyte\n+   source character, just like libcpp does.  A 32-bit type is enough.  */\n+\n+#if HOST_BITS_PER_INT >= 32\n+typedef unsigned int gfc_char_t;\n+#elif HOST_BITS_PER_LONG >= 32\n+typedef unsigned long gfc_char_t;\n+#elif defined(HAVE_LONG_LONG) && (HOST_BITS_PER_LONGLONG >= 32)\n+typedef unsigned long long gfc_char_t;\n+#else\n+# error \"Cannot find an integer type with at least 32 bits\"\n+#endif\n+\n+\n /* The following three structures are used to identify a location in\n    the sources.\n \n@@ -729,7 +744,7 @@ typedef struct gfc_linebuf\n   int truncated;\n   bool dbg_emitted;\n \n-  char line[1];\n+  gfc_char_t line[1];\n } gfc_linebuf;\n \n #define gfc_linebuf_header_size (offsetof (gfc_linebuf, line))\n@@ -738,7 +753,7 @@ typedef struct gfc_linebuf\n \n typedef struct\n {\n-  char *nextc;\n+  gfc_char_t *nextc;\n   gfc_linebuf *lb;\n } locus;\n \n@@ -1940,10 +1955,18 @@ void gfc_advance_line (void);\n int gfc_check_include (void);\n int gfc_define_undef_line (void);\n \n+int gfc_wide_is_printable (gfc_char_t);\n+int gfc_wide_is_digit (gfc_char_t);\n+int gfc_wide_fits_in_byte (gfc_char_t);\n+gfc_char_t gfc_wide_tolower (gfc_char_t);\n+size_t gfc_wide_strlen (const gfc_char_t *);\n+\n void gfc_skip_comments (void);\n-int gfc_next_char_literal (int);\n-int gfc_next_char (void);\n-int gfc_peek_char (void);\n+gfc_char_t gfc_next_char_literal (int);\n+gfc_char_t gfc_next_char (void);\n+char gfc_next_ascii_char (void);\n+gfc_char_t gfc_peek_char (void);\n+char gfc_peek_ascii_char (void);\n void gfc_error_recovery (void);\n void gfc_gobble_whitespace (void);\n try gfc_new_file (void);\n@@ -2354,6 +2377,7 @@ bool gfc_check_access (gfc_access, gfc_access);\n symbol_attribute gfc_variable_attr (gfc_expr *, gfc_typespec *);\n symbol_attribute gfc_expr_attr (gfc_expr *);\n match gfc_match_rvalue (gfc_expr **);\n+int gfc_check_digit (char, int);\n \n /* trans.c */\n void gfc_generate_code (gfc_namespace *);"}, {"sha": "88ede3b2a13ab0096baeb19a50dcf2c1cdd0b617", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=8fc541d3a5225284038d28ebe0b80cba2da3371b", "patch": "@@ -237,13 +237,17 @@ Allow @samp{$} as a valid character in a symbol name.\n @opindex @code{backslash}\n @cindex backslash\n @cindex escape characters\n-Change the interpretation of backslashes in string literals\n-from a single backslash character to ``C-style'' escape characters.\n-The following combinations are expanded \\a, \\b, \\f, \\n, \\r, \\t,\n-\\v, \\\\, and \\0 to the ASCII characters alert, backspace, form feed,\n-newline, carriage return, horizontal tab, vertical tab, backslash,\n-and NUL, respectively.  All other combinations of a character preceded\n-by \\ are unexpanded.\n+Change the interpretation of backslashes in string literals from a single\n+backslash character to ``C-style'' escape characters. The following\n+combinations are expanded @code{\\a}, @code{\\b}, @code{\\f}, @code{\\n},\n+@code{\\r}, @code{\\t}, @code{\\v}, @code{\\\\}, and @code{\\0} to the ASCII\n+characters alert, backspace, form feed, newline, carriage return,\n+horizontal tab, vertical tab, backslash, and NUL, respectively.\n+Additionally, @code{\\x}@var{nn}, @code{\\u}@var{nnnn} and\n+@code{\\U}@var{nnnnnnnn} (where each @var{n} is a hexadecimal digit) are\n+translated into the Unicode characters corresponding to the specified code\n+points. All other combinations of a character preceded by \\ are\n+unexpanded.\n \n @item -fmodule-private\n @opindex @code{fmodule-private}"}, {"sha": "07848a1cd6e76b54b030003c656253a08b40bda4", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=8fc541d3a5225284038d28ebe0b80cba2da3371b", "patch": "@@ -132,7 +132,7 @@ mode;\n static char\n next_char (int in_string)\n {\n-  static char c;\n+  static gfc_char_t c;\n \n   if (use_last_char)\n     {\n@@ -153,26 +153,19 @@ next_char (int in_string)\n \n   if (gfc_option.flag_backslash && c == '\\\\')\n     {\n-      int tmp;\n       locus old_locus = gfc_current_locus;\n \n-      /* Use a temp variable to avoid side effects from gfc_match_special_char\n-\t since it uses an int * for its argument.  */\n-      tmp = (int)c;\n-\n-      if (gfc_match_special_char (&tmp) == MATCH_NO)\n+      if (gfc_match_special_char (&c) == MATCH_NO)\n \tgfc_current_locus = old_locus;\n \n-      c = (char)tmp;\n-\n       if (!(gfc_option.allow_std & GFC_STD_GNU) && !inhibit_warnings)\n \tgfc_warning (\"Extension: backslash character at %C\");\n     }\n \n   if (mode == MODE_COPY)\n     *format_string++ = c;\n \n-  c = TOUPPER (c);\n+  c = TOUPPER ((unsigned char) c);\n   return c;\n }\n \n@@ -3185,7 +3178,7 @@ match_io (io_kind k)\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_code *io_code;\n   gfc_symbol *sym;\n-  int comma_flag, c;\n+  int comma_flag;\n   locus where;\n   locus spec_end;\n   gfc_dt *dt;\n@@ -3203,7 +3196,7 @@ match_io (io_kind k)\n       else if (k == M_PRINT)\n \t{\n \t  /* Treat the non-standard case of PRINT namelist.  */\n-\t  if ((gfc_current_form == FORM_FIXED || gfc_peek_char () == ' ')\n+\t  if ((gfc_current_form == FORM_FIXED || gfc_peek_ascii_char () == ' ')\n \t      && gfc_match_name (name) == MATCH_YES)\n \t    {\n \t      gfc_find_symbol (name, NULL, 1, &sym);\n@@ -3227,7 +3220,7 @@ match_io (io_kind k)\n \n       if (gfc_current_form == FORM_FREE)\n \t{\n-\t  c = gfc_peek_char();\n+\t  char c = gfc_peek_ascii_char ();\n \t  if (c != ' ' && c != '*' && c != '\\'' && c != '\"')\n \t    {\n \t      m = MATCH_NO;"}, {"sha": "8c83615195496fc240b54b9f8537c56bc8a16464", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 97, "deletions": 68, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=8fc541d3a5225284038d28ebe0b80cba2da3371b", "patch": "@@ -111,8 +111,8 @@ match\n gfc_match_parens (void)\n {\n   locus old_loc, where;\n-  int c, count, instring;\n-  char quote;\n+  int count, instring;\n+  gfc_char_t c, quote;\n \n   old_loc = gfc_current_locus;\n   count = 0;\n@@ -126,7 +126,7 @@ gfc_match_parens (void)\n \tbreak;\n       if (quote == ' ' && ((c == '\\'') || (c == '\"')))\n \t{\n-\t  quote = (char) c;\n+\t  quote = c;\n \t  instring = 1;\n \t  continue;\n \t}\n@@ -170,42 +170,66 @@ gfc_match_parens (void)\n    escaped by a \\ via the -fbackslash option.  */\n \n match\n-gfc_match_special_char (int *c)\n+gfc_match_special_char (gfc_char_t *res)\n {\n-\n+  int len, i;\n+  gfc_char_t c, n;\n   match m;\n \n   m = MATCH_YES;\n \n-  switch (gfc_next_char_literal (1))\n+  switch ((c = gfc_next_char_literal (1)))\n     {\n     case 'a':\n-      *c = '\\a';\n+      *res = '\\a';\n       break;\n     case 'b':\n-      *c = '\\b';\n+      *res = '\\b';\n       break;\n     case 't':\n-      *c = '\\t';\n+      *res = '\\t';\n       break;\n     case 'f':\n-      *c = '\\f';\n+      *res = '\\f';\n       break;\n     case 'n':\n-      *c = '\\n';\n+      *res = '\\n';\n       break;\n     case 'r':\n-      *c = '\\r';\n+      *res = '\\r';\n       break;\n     case 'v':\n-      *c = '\\v';\n+      *res = '\\v';\n       break;\n     case '\\\\':\n-      *c = '\\\\';\n+      *res = '\\\\';\n       break;\n     case '0':\n-      *c = '\\0';\n+      *res = '\\0';\n+      break;\n+\n+    case 'x':\n+    case 'u':\n+    case 'U':\n+      /* Hexadecimal form of wide characters.  */\n+      len = (c == 'x' ? 2 : (c == 'u' ? 4 : 8));\n+      n = 0;\n+      for (i = 0; i < len; i++)\n+\t{\n+\t  char buf[2] = { '\\0', '\\0' };\n+\n+\t  c = gfc_next_char_literal (1);\n+\t  if (!gfc_wide_fits_in_byte (c)\n+\t      || !gfc_check_digit ((unsigned char) c, 16))\n+\t    return MATCH_NO;\n+\n+\t  buf[0] = (unsigned char) c;\n+\t  n = n << 4;\n+\t  n += strtol (buf, NULL, 16);\n+\t}\n+      *res = n;\n       break;\n+\n     default:\n       /* Unknown backslash codes are simply not expanded.  */\n       m = MATCH_NO;\n@@ -223,14 +247,14 @@ match\n gfc_match_space (void)\n {\n   locus old_loc;\n-  int c;\n+  char c;\n \n   if (gfc_current_form == FORM_FIXED)\n     return MATCH_YES;\n \n   old_loc = gfc_current_locus;\n \n-  c = gfc_next_char ();\n+  c = gfc_next_ascii_char ();\n   if (!gfc_is_whitespace (c))\n     {\n       gfc_current_locus = old_loc;\n@@ -251,7 +275,8 @@ match\n gfc_match_eos (void)\n {\n   locus old_loc;\n-  int flag, c;\n+  int flag;\n+  char c;\n \n   flag = 0;\n \n@@ -260,13 +285,13 @@ gfc_match_eos (void)\n       old_loc = gfc_current_locus;\n       gfc_gobble_whitespace ();\n \n-      c = gfc_next_char ();\n+      c = gfc_next_ascii_char ();\n       switch (c)\n \t{\n \tcase '!':\n \t  do\n \t    {\n-\t      c = gfc_next_char ();\n+\t      c = gfc_next_ascii_char ();\n \t    }\n \t  while (c != '\\n');\n \n@@ -302,8 +327,9 @@ gfc_match_small_literal_int (int *value, int *cnt)\n \n   old_loc = gfc_current_locus;\n \n+  *value = -1;\n   gfc_gobble_whitespace ();\n-  c = gfc_next_char ();\n+  c = gfc_next_ascii_char ();\n   if (cnt)\n     *cnt = 0;\n \n@@ -319,7 +345,7 @@ gfc_match_small_literal_int (int *value, int *cnt)\n   for (;;)\n     {\n       old_loc = gfc_current_locus;\n-      c = gfc_next_char ();\n+      c = gfc_next_ascii_char ();\n \n       if (!ISDIGIT (c))\n \tbreak;\n@@ -488,12 +514,13 @@ match\n gfc_match_name (char *buffer)\n {\n   locus old_loc;\n-  int i, c;\n+  int i;\n+  char c;\n \n   old_loc = gfc_current_locus;\n   gfc_gobble_whitespace ();\n \n-  c = gfc_next_char ();\n+  c = gfc_next_ascii_char ();\n   if (!(ISALPHA (c) || (c == '_' && gfc_option.flag_allow_leading_underscore)))\n     {\n       if (gfc_error_flag_test() == 0 && c != '(')\n@@ -515,13 +542,14 @@ gfc_match_name (char *buffer)\n \t}\n \n       old_loc = gfc_current_locus;\n-      c = gfc_next_char ();\n+      c = gfc_next_ascii_char ();\n     }\n   while (ISALNUM (c) || c == '_' || (gfc_option.flag_dollar_ok && c == '$'));\n \n   if (c == '$' && !gfc_option.flag_dollar_ok)\n     {\n-      gfc_error (\"Invalid character '$' at %C. Use -fdollar-ok to allow it as an extension\");\n+      gfc_error (\"Invalid character '$' at %C. Use -fdollar-ok to allow it \"\n+\t\t \"as an extension\");\n       return MATCH_ERROR;\n     }\n \n@@ -551,7 +579,7 @@ gfc_match_name_C (char *buffer)\n {\n   locus old_loc;\n   int i = 0;\n-  int c;\n+  gfc_char_t c;\n \n   old_loc = gfc_current_locus;\n   gfc_gobble_whitespace ();\n@@ -579,7 +607,9 @@ gfc_match_name_C (char *buffer)\n   /* Continue to read valid variable name characters.  */\n   do\n     {\n-      buffer[i++] = c;\n+      gcc_assert (gfc_wide_fits_in_byte (c));\n+\n+      buffer[i++] = (unsigned char) c;\n       \n     /* C does not define a maximum length of variable names, to my\n        knowledge, but the compiler typically places a limit on them.\n@@ -606,7 +636,7 @@ gfc_match_name_C (char *buffer)\n   if (c == ' ')\n     {\n       gfc_gobble_whitespace ();\n-      c = gfc_peek_char ();\n+      c = gfc_peek_ascii_char ();\n       if (c != '\"' && c != '\\'')\n         {\n           gfc_error (\"Embedded space in NAME= specifier at %C\");\n@@ -679,10 +709,10 @@ match\n gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n {\n   locus orig_loc = gfc_current_locus;\n-  int ch;\n+  char ch;\n \n   gfc_gobble_whitespace ();\n-  ch = gfc_next_char ();\n+  ch = gfc_next_ascii_char ();\n   switch (ch)\n     {\n     case '+':\n@@ -696,7 +726,7 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n       return MATCH_YES;\n \n     case '=':\n-      if (gfc_next_char () == '=')\n+      if (gfc_next_ascii_char () == '=')\n \t{\n \t  /* Matched \"==\".  */\n \t  *result = INTRINSIC_EQ;\n@@ -705,10 +735,10 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n       break;\n \n     case '<':\n-      if (gfc_peek_char () == '=')\n+      if (gfc_peek_ascii_char () == '=')\n \t{\n \t  /* Matched \"<=\".  */\n-\t  gfc_next_char ();\n+\t  gfc_next_ascii_char ();\n \t  *result = INTRINSIC_LE;\n \t  return MATCH_YES;\n \t}\n@@ -717,10 +747,10 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n       return MATCH_YES;\n \n     case '>':\n-      if (gfc_peek_char () == '=')\n+      if (gfc_peek_ascii_char () == '=')\n \t{\n \t  /* Matched \">=\".  */\n-\t  gfc_next_char ();\n+\t  gfc_next_ascii_char ();\n \t  *result = INTRINSIC_GE;\n \t  return MATCH_YES;\n \t}\n@@ -729,10 +759,10 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n       return MATCH_YES;\n \n     case '*':\n-      if (gfc_peek_char () == '*')\n+      if (gfc_peek_ascii_char () == '*')\n \t{\n \t  /* Matched \"**\".  */\n-\t  gfc_next_char ();\n+\t  gfc_next_ascii_char ();\n \t  *result = INTRINSIC_POWER;\n \t  return MATCH_YES;\n \t}\n@@ -741,18 +771,18 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n       return MATCH_YES;\n \n     case '/':\n-      ch = gfc_peek_char ();\n+      ch = gfc_peek_ascii_char ();\n       if (ch == '=')\n \t{\n \t  /* Matched \"/=\".  */\n-\t  gfc_next_char ();\n+\t  gfc_next_ascii_char ();\n \t  *result = INTRINSIC_NE;\n \t  return MATCH_YES;\n \t}\n       else if (ch == '/')\n \t{\n \t  /* Matched \"//\".  */\n-\t  gfc_next_char ();\n+\t  gfc_next_ascii_char ();\n \t  *result = INTRINSIC_CONCAT;\n \t  return MATCH_YES;\n \t}\n@@ -761,13 +791,13 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n       return MATCH_YES;\n \n     case '.':\n-      ch = gfc_next_char ();\n+      ch = gfc_next_ascii_char ();\n       switch (ch)\n \t{\n \tcase 'a':\n-\t  if (gfc_next_char () == 'n'\n-\t      && gfc_next_char () == 'd'\n-\t      && gfc_next_char () == '.')\n+\t  if (gfc_next_ascii_char () == 'n'\n+\t      && gfc_next_ascii_char () == 'd'\n+\t      && gfc_next_ascii_char () == '.')\n \t    {\n \t      /* Matched \".and.\".  */\n \t      *result = INTRINSIC_AND;\n@@ -776,9 +806,9 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n \t  break;\n \n \tcase 'e':\n-\t  if (gfc_next_char () == 'q')\n+\t  if (gfc_next_ascii_char () == 'q')\n \t    {\n-\t      ch = gfc_next_char ();\n+\t      ch = gfc_next_ascii_char ();\n \t      if (ch == '.')\n \t\t{\n \t\t  /* Matched \".eq.\".  */\n@@ -787,7 +817,7 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n \t\t}\n \t      else if (ch == 'v')\n \t\t{\n-\t\t  if (gfc_next_char () == '.')\n+\t\t  if (gfc_next_ascii_char () == '.')\n \t\t    {\n \t\t      /* Matched \".eqv.\".  */\n \t\t      *result = INTRINSIC_EQV;\n@@ -798,10 +828,10 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n \t  break;\n \n \tcase 'g':\n-\t  ch = gfc_next_char ();\n+\t  ch = gfc_next_ascii_char ();\n \t  if (ch == 'e')\n \t    {\n-\t      if (gfc_next_char () == '.')\n+\t      if (gfc_next_ascii_char () == '.')\n \t\t{\n \t\t  /* Matched \".ge.\".  */\n \t\t  *result = INTRINSIC_GE_OS;\n@@ -810,7 +840,7 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n \t    }\n \t  else if (ch == 't')\n \t    {\n-\t      if (gfc_next_char () == '.')\n+\t      if (gfc_next_ascii_char () == '.')\n \t\t{\n \t\t  /* Matched \".gt.\".  */\n \t\t  *result = INTRINSIC_GT_OS;\n@@ -820,10 +850,10 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n \t  break;\n \n \tcase 'l':\n-\t  ch = gfc_next_char ();\n+\t  ch = gfc_next_ascii_char ();\n \t  if (ch == 'e')\n \t    {\n-\t      if (gfc_next_char () == '.')\n+\t      if (gfc_next_ascii_char () == '.')\n \t\t{\n \t\t  /* Matched \".le.\".  */\n \t\t  *result = INTRINSIC_LE_OS;\n@@ -832,7 +862,7 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n \t    }\n \t  else if (ch == 't')\n \t    {\n-\t      if (gfc_next_char () == '.')\n+\t      if (gfc_next_ascii_char () == '.')\n \t\t{\n \t\t  /* Matched \".lt.\".  */\n \t\t  *result = INTRINSIC_LT_OS;\n@@ -842,10 +872,10 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n \t  break;\n \n \tcase 'n':\n-\t  ch = gfc_next_char ();\n+\t  ch = gfc_next_ascii_char ();\n \t  if (ch == 'e')\n \t    {\n-\t      ch = gfc_next_char ();\n+\t      ch = gfc_next_ascii_char ();\n \t      if (ch == '.')\n \t\t{\n \t\t  /* Matched \".ne.\".  */\n@@ -854,8 +884,8 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n \t\t}\n \t      else if (ch == 'q')\n \t\t{\n-\t\t  if (gfc_next_char () == 'v'\n-\t\t      && gfc_next_char () == '.')\n+\t\t  if (gfc_next_ascii_char () == 'v'\n+\t\t      && gfc_next_ascii_char () == '.')\n \t\t    {\n \t\t      /* Matched \".neqv.\".  */\n \t\t      *result = INTRINSIC_NEQV;\n@@ -865,8 +895,8 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n \t    }\n \t  else if (ch == 'o')\n \t    {\n-\t      if (gfc_next_char () == 't'\n-\t\t  && gfc_next_char () == '.')\n+\t      if (gfc_next_ascii_char () == 't'\n+\t\t  && gfc_next_ascii_char () == '.')\n \t\t{\n \t\t  /* Matched \".not.\".  */\n \t\t  *result = INTRINSIC_NOT;\n@@ -876,8 +906,8 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n \t  break;\n \n \tcase 'o':\n-\t  if (gfc_next_char () == 'r'\n-\t      && gfc_next_char () == '.')\n+\t  if (gfc_next_ascii_char () == 'r'\n+\t      && gfc_next_ascii_char () == '.')\n \t    {\n \t      /* Matched \".or.\".  */\n \t      *result = INTRINSIC_OR;\n@@ -1007,7 +1037,7 @@ gfc_match_char (char c)\n   where = gfc_current_locus;\n   gfc_gobble_whitespace ();\n \n-  if (gfc_next_char () == c)\n+  if (gfc_next_ascii_char () == c)\n     return MATCH_YES;\n \n   gfc_current_locus = where;\n@@ -1157,7 +1187,7 @@ gfc_match (const char *target, ...)\n \t}\n \n     default:\n-      if (c == gfc_next_char ())\n+      if (c == gfc_next_ascii_char ())\n \tgoto loop;\n       break;\n     }\n@@ -2414,7 +2444,6 @@ gfc_match_return (void)\n   gfc_expr *e;\n   match m;\n   gfc_compile_state s;\n-  int c;\n \n   e = NULL;\n   if (gfc_match_eos () == MATCH_YES)\n@@ -2433,7 +2462,7 @@ gfc_match_return (void)\n \tRETURN keyword:\n \t  return+1\n \t  return(1)  */\n-      c = gfc_peek_char ();\n+      char c = gfc_peek_ascii_char ();\n       if (ISALPHA (c) || ISDIGIT (c))\n \treturn MATCH_NO;\n     }\n@@ -2868,12 +2897,12 @@ gfc_match_common (void)\n \t  gfc_gobble_whitespace ();\n \t  if (gfc_match_eos () == MATCH_YES)\n \t    goto done;\n-\t  if (gfc_peek_char () == '/')\n+\t  if (gfc_peek_ascii_char () == '/')\n \t    break;\n \t  if (gfc_match_char (',') != MATCH_YES)\n \t    goto syntax;\n \t  gfc_gobble_whitespace ();\n-\t  if (gfc_peek_char () == '/')\n+\t  if (gfc_peek_ascii_char () == '/')\n \t    break;\n \t}\n     }"}, {"sha": "d46e163013637d1927f7b6d2fdd18bd74049c439", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=8fc541d3a5225284038d28ebe0b80cba2da3371b", "patch": "@@ -38,7 +38,7 @@ extern gfc_st_label *gfc_statement_label;\n /* match.c.  */\n \n /* Generic match subroutines.  */\n-match gfc_match_special_char (int *);\n+match gfc_match_special_char (gfc_char_t *);\n match gfc_match_space (void);\n match gfc_match_eos (void);\n match gfc_match_small_literal_int (int *, int *);"}, {"sha": "9c0bae497bf92f59821091d17cfa215f7850f39e", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=8fc541d3a5225284038d28ebe0b80cba2da3371b", "patch": "@@ -36,17 +36,17 @@ match\n gfc_match_omp_eos (void)\n {\n   locus old_loc;\n-  int c;\n+  char c;\n \n   old_loc = gfc_current_locus;\n   gfc_gobble_whitespace ();\n \n-  c = gfc_next_char ();\n+  c = gfc_next_ascii_char ();\n   switch (c)\n     {\n     case '!':\n       do\n-\tc = gfc_next_char ();\n+\tc = gfc_next_ascii_char ();\n       while (c != '\\n');\n       /* Fall through */\n "}, {"sha": "dd072feb30e5b340eb3817c492e0863f8ecaa328", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=8fc541d3a5225284038d28ebe0b80cba2da3371b", "patch": "@@ -100,7 +100,7 @@ decode_specification_statement (void)\n {\n   gfc_statement st;\n   locus old_locus;\n-  int c;\n+  char c;\n \n   if (gfc_match_eos () == MATCH_YES)\n     return ST_NONE;\n@@ -121,7 +121,7 @@ decode_specification_statement (void)\n      statement, we eliminate most possibilities by peeking at the\n      first character.  */\n \n-  c = gfc_peek_char ();\n+  c = gfc_peek_ascii_char ();\n \n   switch (c)\n     {\n@@ -229,7 +229,7 @@ decode_statement (void)\n   gfc_statement st;\n   locus old_locus;\n   match m;\n-  int c;\n+  char c;\n \n #ifdef GFC_DEBUG\n   gfc_symbol_state ();\n@@ -315,7 +315,7 @@ decode_statement (void)\n      statement, we eliminate most possibilities by peeking at the\n      first character.  */\n \n-  c = gfc_peek_char ();\n+  c = gfc_peek_ascii_char ();\n \n   switch (c)\n     {\n@@ -462,7 +462,7 @@ static gfc_statement\n decode_omp_directive (void)\n {\n   locus old_locus;\n-  int c;\n+  char c;\n \n #ifdef GFC_DEBUG\n   gfc_symbol_state ();\n@@ -485,7 +485,7 @@ decode_omp_directive (void)\n      statement, we eliminate most possibilities by peeking at the\n      first character.  */\n \n-  c = gfc_peek_char ();\n+  c = gfc_peek_ascii_char ();\n \n   switch (c)\n     {\n@@ -569,31 +569,34 @@ static gfc_statement\n next_free (void)\n {\n   match m;\n-  int c, d, cnt, at_bol;\n+  int i, cnt, at_bol;\n+  char c;\n \n   at_bol = gfc_at_bol ();\n   gfc_gobble_whitespace ();\n \n-  c = gfc_peek_char ();\n+  c = gfc_peek_ascii_char ();\n \n   if (ISDIGIT (c))\n     {\n+      char d;\n+\n       /* Found a statement label?  */\n       m = gfc_match_st_label (&gfc_statement_label);\n \n-      d = gfc_peek_char ();\n+      d = gfc_peek_ascii_char ();\n       if (m != MATCH_YES || !gfc_is_whitespace (d))\n \t{\n-\t  gfc_match_small_literal_int (&c, &cnt);\n+\t  gfc_match_small_literal_int (&i, &cnt);\n \n \t  if (cnt > 5)\n \t    gfc_error_now (\"Too many digits in statement label at %C\");\n \n-\t  if (c == 0)\n+\t  if (i == 0)\n \t    gfc_error_now (\"Zero is not a valid statement label at %C\");\n \n \t  do\n-\t    c = gfc_next_char ();\n+\t    c = gfc_next_ascii_char ();\n \t  while (ISDIGIT(c));\n \n \t  if (!gfc_is_whitespace (c))\n@@ -607,11 +610,11 @@ next_free (void)\n \n \t  gfc_gobble_whitespace ();\n \n-\t  if (at_bol && gfc_peek_char () == ';')\n+\t  if (at_bol && gfc_peek_ascii_char () == ';')\n \t    {\n \t      gfc_error_now (\"Semicolon at %C needs to be preceded by \"\n \t\t\t     \"statement\");\n-\t      gfc_next_char (); /* Eat up the semicolon.  */\n+\t      gfc_next_ascii_char (); /* Eat up the semicolon.  */\n \t      return ST_NONE;\n \t    }\n \n@@ -633,8 +636,8 @@ next_free (void)\n \t{\n \t  int i;\n \n-\t  c = gfc_next_char ();\n-\t  for (i = 0; i < 5; i++, c = gfc_next_char ())\n+\t  c = gfc_next_ascii_char ();\n+\t  for (i = 0; i < 5; i++, c = gfc_next_ascii_char ())\n \t    gcc_assert (c == \"!$omp\"[i]);\n \n \t  gcc_assert (c == ' ');\n@@ -646,7 +649,7 @@ next_free (void)\n   if (at_bol && c == ';')\n     {\n       gfc_error_now (\"Semicolon at %C needs to be preceded by statement\");\n-      gfc_next_char (); /* Eat up the semicolon.  */\n+      gfc_next_ascii_char (); /* Eat up the semicolon.  */\n       return ST_NONE;\n     }\n \n@@ -661,7 +664,7 @@ next_fixed (void)\n {\n   int label, digit_flag, i;\n   locus loc;\n-  char c;\n+  gfc_char_t c;\n \n   if (!gfc_at_bol ())\n     return decode_statement ();\n@@ -694,7 +697,7 @@ next_fixed (void)\n \tcase '7':\n \tcase '8':\n \tcase '9':\n-\t  label = label * 10 + c - '0';\n+\t  label = label * 10 + ((unsigned char) c - '0');\n \t  label_locus = gfc_current_locus;\n \t  digit_flag = 1;\n \t  break;\n@@ -705,7 +708,7 @@ next_fixed (void)\n \t  if (gfc_option.flag_openmp)\n \t    {\n \t      for (i = 0; i < 5; i++, c = gfc_next_char_literal (0))\n-\t\tgcc_assert (TOLOWER (c) == \"*$omp\"[i]);\n+\t\tgcc_assert ((char) gfc_wide_tolower (c) == \"*$omp\"[i]);\n \n \t      if (c != ' ' && c != '0')\n \t\t{"}, {"sha": "d7491c1a110c024d77c7f59086b44837111727d1", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 98, "deletions": 75, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=8fc541d3a5225284038d28ebe0b80cba2da3371b", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"arith.h\"\n #include \"match.h\"\n #include \"parse.h\"\n+#include \"toplev.h\"\n \n /* Matches a kind-parameter expression, which is either a named\n    symbolic constant or a nonnegative integer constant.  If\n@@ -95,8 +96,8 @@ get_kind (void)\n /* Given a character and a radix, see if the character is a valid\n    digit in that radix.  */\n \n-static int\n-check_digit (int c, int radix)\n+int\n+gfc_check_digit (char c, int radix)\n {\n   int r;\n \n@@ -119,7 +120,7 @@ check_digit (int c, int radix)\n       break;\n \n     default:\n-      gfc_internal_error (\"check_digit(): bad radix\");\n+      gfc_internal_error (\"gfc_check_digit(): bad radix\");\n     }\n \n   return r;\n@@ -135,21 +136,22 @@ static int\n match_digits (int signflag, int radix, char *buffer)\n {\n   locus old_loc;\n-  int length, c;\n+  int length;\n+  char c;\n \n   length = 0;\n-  c = gfc_next_char ();\n+  c = gfc_next_ascii_char ();\n \n   if (signflag && (c == '+' || c == '-'))\n     {\n       if (buffer != NULL)\n \t*buffer++ = c;\n       gfc_gobble_whitespace ();\n-      c = gfc_next_char ();\n+      c = gfc_next_ascii_char ();\n       length++;\n     }\n \n-  if (!check_digit (c, radix))\n+  if (!gfc_check_digit (c, radix))\n     return -1;\n \n   length++;\n@@ -159,9 +161,9 @@ match_digits (int signflag, int radix, char *buffer)\n   for (;;)\n     {\n       old_loc = gfc_current_locus;\n-      c = gfc_next_char ();\n+      c = gfc_next_ascii_char ();\n \n-      if (!check_digit (c, radix))\n+      if (!gfc_check_digit (c, radix))\n \tbreak;\n \n       if (buffer != NULL)\n@@ -275,10 +277,13 @@ match_hollerith_constant (gfc_expr **result)\n \t\t\t\t   &gfc_current_locus);\n \n \t  e->representation.string = gfc_getmem (num + 1);\n+\n+\t  /* FIXME -- determine what should be done for wide character\n+\t     strings, and do it!  */\n \t  for (i = 0; i < num; i++)\n-\t    {\n-\t      e->representation.string[i] = gfc_next_char_literal (1);\n-\t    }\n+\t    e->representation.string[i]\n+\t      = (unsigned char) gfc_next_char_literal (1);\n+\n \t  e->representation.string[num] = '\\0';\n \t  e->representation.length = num;\n \n@@ -306,16 +311,16 @@ match_hollerith_constant (gfc_expr **result)\n static match\n match_boz_constant (gfc_expr **result)\n {\n-  int post, radix, delim, length, x_hex, kind;\n+  int radix, length, x_hex, kind;\n   locus old_loc, start_loc;\n-  char *buffer;\n+  char *buffer, post, delim;\n   gfc_expr *e;\n \n   start_loc = old_loc = gfc_current_locus;\n   gfc_gobble_whitespace ();\n \n   x_hex = 0;\n-  switch (post = gfc_next_char ())\n+  switch (post = gfc_next_ascii_char ())\n     {\n     case 'b':\n       radix = 2;\n@@ -346,7 +351,7 @@ match_boz_constant (gfc_expr **result)\n   /* No whitespace allowed here.  */\n \n   if (post == 0)\n-    delim = gfc_next_char ();\n+    delim = gfc_next_ascii_char ();\n \n   if (delim != '\\'' && delim != '\\\"')\n     goto backup;\n@@ -366,15 +371,15 @@ match_boz_constant (gfc_expr **result)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_next_char () != delim)\n+  if (gfc_next_ascii_char () != delim)\n     {\n       gfc_error (\"Illegal character in BOZ constant at %C\");\n       return MATCH_ERROR;\n     }\n \n   if (post == 1)\n     {\n-      switch (gfc_next_char ())\n+      switch (gfc_next_ascii_char ())\n \t{\n \tcase 'b':\n \t  radix = 2;\n@@ -403,9 +408,9 @@ match_boz_constant (gfc_expr **result)\n   memset (buffer, '\\0', length + 1);\n \n   match_digits (0, radix, buffer);\n-  gfc_next_char ();    /* Eat delimiter.  */\n+  gfc_next_ascii_char ();    /* Eat delimiter.  */\n   if (post == 1)\n-    gfc_next_char ();  /* Eat postfixed b, o, z, or x.  */\n+    gfc_next_ascii_char ();  /* Eat postfixed b, o, z, or x.  */\n \n   /* In section 5.2.5 and following C567 in the Fortran 2003 standard, we find\n      \"If a data-stmt-constant is a boz-literal-constant, the corresponding\n@@ -448,9 +453,9 @@ match_boz_constant (gfc_expr **result)\n static match\n match_real_constant (gfc_expr **result, int signflag)\n {\n-  int kind, c, count, seen_dp, seen_digits, exp_char;\n+  int kind, count, seen_dp, seen_digits;\n   locus old_loc, temp_loc;\n-  char *p, *buffer;\n+  char *p, *buffer, c, exp_char;\n   gfc_expr *e;\n   bool negate;\n \n@@ -465,18 +470,18 @@ match_real_constant (gfc_expr **result, int signflag)\n   exp_char = ' ';\n   negate = FALSE;\n \n-  c = gfc_next_char ();\n+  c = gfc_next_ascii_char ();\n   if (signflag && (c == '+' || c == '-'))\n     {\n       if (c == '-')\n \tnegate = TRUE;\n \n       gfc_gobble_whitespace ();\n-      c = gfc_next_char ();\n+      c = gfc_next_ascii_char ();\n     }\n \n   /* Scan significand.  */\n-  for (;; c = gfc_next_char (), count++)\n+  for (;; c = gfc_next_ascii_char (), count++)\n     {\n       if (c == '.')\n \t{\n@@ -486,11 +491,11 @@ match_real_constant (gfc_expr **result, int signflag)\n \t  /* Check to see if \".\" goes with a following operator like \n \t     \".eq.\".  */\n \t  temp_loc = gfc_current_locus;\n-\t  c = gfc_next_char ();\n+\t  c = gfc_next_ascii_char ();\n \n \t  if (c == 'e' || c == 'd' || c == 'q')\n \t    {\n-\t      c = gfc_next_char ();\n+\t      c = gfc_next_ascii_char ();\n \t      if (c == '.')\n \t\tgoto done;\t/* Operator named .e. or .d.  */\n \t    }\n@@ -517,12 +522,12 @@ match_real_constant (gfc_expr **result, int signflag)\n   exp_char = c;\n \n   /* Scan exponent.  */\n-  c = gfc_next_char ();\n+  c = gfc_next_ascii_char ();\n   count++;\n \n   if (c == '+' || c == '-')\n     {\t\t\t\t/* optional sign */\n-      c = gfc_next_char ();\n+      c = gfc_next_ascii_char ();\n       count++;\n     }\n \n@@ -534,7 +539,7 @@ match_real_constant (gfc_expr **result, int signflag)\n \n   while (ISDIGIT (c))\n     {\n-      c = gfc_next_char ();\n+      c = gfc_next_ascii_char ();\n       count++;\n     }\n \n@@ -554,11 +559,11 @@ match_real_constant (gfc_expr **result, int signflag)\n   memset (buffer, '\\0', count + 1);\n \n   p = buffer;\n-  c = gfc_next_char ();\n+  c = gfc_next_ascii_char ();\n   if (c == '+' || c == '-')\n     {\n       gfc_gobble_whitespace ();\n-      c = gfc_next_char ();\n+      c = gfc_next_ascii_char ();\n     }\n \n   /* Hack for mpfr_set_str().  */\n@@ -572,7 +577,7 @@ match_real_constant (gfc_expr **result, int signflag)\n       if (--count == 0)\n \tbreak;\n \n-      c = gfc_next_char ();\n+      c = gfc_next_ascii_char ();\n     }\n \n   kind = get_kind ();\n@@ -724,22 +729,26 @@ match_substring (gfc_charlen *cl, int init, gfc_ref **result)\n    return doubled delimiters on the input as a single instance of\n    the delimiter.\n \n-   Special return values are:\n+   Special return values for \"ret\" argument are:\n      -1   End of the string, as determined by the delimiter\n      -2   Unterminated string detected\n \n    Backslash codes are also expanded at this time.  */\n \n-static int\n-next_string_char (char delimiter)\n+static gfc_char_t\n+next_string_char (gfc_char_t delimiter, int *ret)\n {\n   locus old_locus;\n-  int c;\n+  gfc_char_t c;\n \n   c = gfc_next_char_literal (1);\n+  *ret = 0;\n \n   if (c == '\\n')\n-    return -2;\n+    {\n+      *ret = -2;\n+      return 0;\n+    }\n \n   if (gfc_option.flag_backslash && c == '\\\\')\n     {\n@@ -762,7 +771,8 @@ next_string_char (char delimiter)\n     return c;\n   gfc_current_locus = old_locus;\n \n-  return -1;\n+  *ret = -1;\n+  return 0;\n }\n \n \n@@ -786,7 +796,7 @@ match_charkind_name (char *name)\n   int len;\n \n   gfc_gobble_whitespace ();\n-  c = gfc_next_char ();\n+  c = gfc_next_ascii_char ();\n   if (!ISALPHA (c))\n     return MATCH_NO;\n \n@@ -796,11 +806,11 @@ match_charkind_name (char *name)\n   for (;;)\n     {\n       old_loc = gfc_current_locus;\n-      c = gfc_next_char ();\n+      c = gfc_next_ascii_char ();\n \n       if (c == '_')\n \t{\n-\t  peek = gfc_peek_char ();\n+\t  peek = gfc_peek_ascii_char ();\n \n \t  if (peek == '\\'' || peek == '\\\"')\n \t    {\n@@ -834,13 +844,14 @@ match_charkind_name (char *name)\n static match\n match_string_constant (gfc_expr **result)\n {\n-  char *p, name[GFC_MAX_SYMBOL_LEN + 1];\n-  int i, c, kind, length, delimiter, warn_ampersand;\n+  char *p, name[GFC_MAX_SYMBOL_LEN + 1], peek;\n+  int i, kind, length, warn_ampersand, ret;\n   locus old_locus, start_locus;\n   gfc_symbol *sym;\n   gfc_expr *e;\n   const char *q;\n   match m;\n+  gfc_char_t c, delimiter;\n \n   old_locus = gfc_current_locus;\n \n@@ -855,11 +866,11 @@ match_string_constant (gfc_expr **result)\n       goto got_delim;\n     }\n \n-  if (ISDIGIT (c))\n+  if (gfc_wide_is_digit (c))\n     {\n       kind = 0;\n \n-      while (ISDIGIT (c))\n+      while (gfc_wide_is_digit (c))\n \t{\n \t  kind = kind * 10 + c - '0';\n \t  if (kind > 9999999)\n@@ -929,10 +940,10 @@ match_string_constant (gfc_expr **result)\n \n   for (;;)\n     {\n-      c = next_string_char (delimiter);\n-      if (c == -1)\n+      c = next_string_char (delimiter, &ret);\n+      if (ret == -1)\n \tbreak;\n-      if (c == -2)\n+      if (ret == -2)\n \t{\n \t  gfc_current_locus = start_locus;\n \t  gfc_error (\"Unterminated character constant beginning at %C\");\n@@ -944,8 +955,8 @@ match_string_constant (gfc_expr **result)\n \n   /* Peek at the next character to see if it is a b, o, z, or x for the\n      postfixed BOZ literal constants.  */\n-  c = gfc_peek_char ();\n-  if (c == 'b' || c == 'o' || c =='z' || c == 'x')\n+  peek = gfc_peek_ascii_char ();\n+  if (peek == 'b' || peek == 'o' || peek =='z' || peek == 'x')\n     goto no_match;\n \n \n@@ -971,12 +982,24 @@ match_string_constant (gfc_expr **result)\n   gfc_option.warn_ampersand = 0;\n \n   for (i = 0; i < length; i++)\n-    *p++ = next_string_char (delimiter);\n+    {\n+      c = next_string_char (delimiter, &ret);\n+\n+      if (!gfc_wide_fits_in_byte (c))\n+\t{\n+\t  gfc_error (\"Unimplemented feature at %C: gfortran currently only \"\n+\t\t     \"supports character strings with one-byte characters\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      *p++ = (unsigned char) c;\n+    }\n \n   *p = '\\0';\t/* TODO: C-style string is for development/debug purposes.  */\n   gfc_option.warn_ampersand = warn_ampersand;\n \n-  if (next_string_char (delimiter) != -1)\n+  next_string_char (delimiter, &ret);\n+  if (ret != -1)\n     gfc_internal_error (\"match_string_constant(): Delimiter not found\");\n \n   if (match_substring (NULL, 0, &e->ref) != MATCH_NO)\n@@ -1000,25 +1023,25 @@ match_logical_constant_string (void)\n   locus orig_loc = gfc_current_locus;\n \n   gfc_gobble_whitespace ();\n-  if (gfc_next_char () == '.')\n+  if (gfc_next_ascii_char () == '.')\n     {\n-      int ch = gfc_next_char();\n+      char ch = gfc_next_ascii_char ();\n       if (ch == 'f')\n \t{\n-\t  if (gfc_next_char () == 'a'\n-\t      && gfc_next_char () == 'l'\n-\t      && gfc_next_char () == 's'\n-\t      && gfc_next_char () == 'e'\n-\t      && gfc_next_char () == '.')\n+\t  if (gfc_next_ascii_char () == 'a'\n+\t      && gfc_next_ascii_char () == 'l'\n+\t      && gfc_next_ascii_char () == 's'\n+\t      && gfc_next_ascii_char () == 'e'\n+\t      && gfc_next_ascii_char () == '.')\n \t    /* Matched \".false.\".  */\n \t    return 0;\n \t}\n       else if (ch == 't')\n \t{\n-\t  if (gfc_next_char () == 'r'\n-\t      && gfc_next_char () == 'u'\n-\t      && gfc_next_char () == 'e'\n-\t      && gfc_next_char () == '.')\n+\t  if (gfc_next_ascii_char () == 'r'\n+\t      && gfc_next_ascii_char () == 'u'\n+\t      && gfc_next_ascii_char () == 'e'\n+\t      && gfc_next_ascii_char () == '.')\n \t    /* Matched \".true.\".  */\n \t    return 1;\n \t}\n@@ -1214,7 +1237,7 @@ match_complex_constant (gfc_expr **result)\n     {\n       /* Give the matcher for implied do-loops a chance to run.  This\n \t yields a much saner error message for (/ (i, 4=i, 6) /).  */\n-      if (gfc_peek_char () == '=')\n+      if (gfc_peek_ascii_char () == '=')\n \t{\n \t  m = MATCH_ERROR;\n \t  goto cleanup;\n@@ -1328,7 +1351,7 @@ match_actual_arg (gfc_expr **result)\n   gfc_symtree *symtree;\n   locus where, w;\n   gfc_expr *e;\n-  int c;\n+  char c;\n \n   where = gfc_current_locus;\n \n@@ -1343,7 +1366,7 @@ match_actual_arg (gfc_expr **result)\n     case MATCH_YES:\n       w = gfc_current_locus;\n       gfc_gobble_whitespace ();\n-      c = gfc_next_char ();\n+      c = gfc_next_ascii_char ();\n       gfc_current_locus = w;\n \n       if (c != ',' && c != ')')\n@@ -1684,7 +1707,7 @@ match_varspec (gfc_expr *primary, int equiv_flag)\n   tail = NULL;\n \n   gfc_gobble_whitespace ();\n-  if ((equiv_flag && gfc_peek_char () == '(') || sym->attr.dimension)\n+  if ((equiv_flag && gfc_peek_ascii_char () == '(') || sym->attr.dimension)\n     {\n       /* In EQUIVALENCE, we don't know yet whether we are seeing\n \t an array, character variable or array of character\n@@ -1698,7 +1721,7 @@ match_varspec (gfc_expr *primary, int equiv_flag)\n \treturn m;\n \n       gfc_gobble_whitespace ();\n-      if (equiv_flag && gfc_peek_char () == '(')\n+      if (equiv_flag && gfc_peek_ascii_char () == '(')\n \t{\n \t  tail = extend_ref (primary, tail);\n \t  tail->type = REF_ARRAY;\n@@ -2101,7 +2124,7 @@ gfc_match_rvalue (gfc_expr **result)\n       /* See if this is a directly recursive function call.  */\n       gfc_gobble_whitespace ();\n       if (sym->attr.recursive\n-\t  && gfc_peek_char () == '('\n+\t  && gfc_peek_ascii_char () == '('\n \t  && gfc_current_ns->proc_name == sym\n \t  && !sym->attr.dimension)\n \t{\n@@ -2139,7 +2162,7 @@ gfc_match_rvalue (gfc_expr **result)\n     {\n     case FL_VARIABLE:\n     variable:\n-      if (sym->ts.type == BT_UNKNOWN && gfc_peek_char () == '%'\n+      if (sym->ts.type == BT_UNKNOWN && gfc_peek_ascii_char () == '%'\n \t  && gfc_get_default_type (sym, sym->ns)->type == BT_DERIVED)\n \tgfc_set_default_type (sym, 0, sym->ns);\n \n@@ -2304,7 +2327,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t via an IMPLICIT statement.  This can't wait for the\n \t resolution phase.  */\n \n-      if (gfc_peek_char () == '%'\n+      if (gfc_peek_ascii_char () == '%'\n \t  && sym->ts.type == BT_UNKNOWN\n \t  && gfc_get_default_type (sym, sym->ns)->type == BT_DERIVED)\n \tgfc_set_default_type (sym, 0, sym->ns);\n@@ -2333,7 +2356,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t variable is just a scalar.  */\n \n       gfc_gobble_whitespace ();\n-      if (gfc_peek_char () != '(')\n+      if (gfc_peek_ascii_char () != '(')\n \t{\n \t  /* Assume a scalar variable */\n \t  e = gfc_get_expr ();\n@@ -2545,7 +2568,7 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \t  break;\n \n \t/* These are definitive indicators that this is a variable.  */\n-\telse if (gfc_peek_char () != '(' || sym->ts.type != BT_UNKNOWN\n+\telse if (gfc_peek_ascii_char () != '(' || sym->ts.type != BT_UNKNOWN\n \t\t || sym->attr.pointer || sym->as != NULL)\n \t  flavor = FL_VARIABLE;\n \n@@ -2605,7 +2628,7 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n       else\n \timplicit_ns = sym->ns;\n \t\n-      if (gfc_peek_char () == '%'\n+      if (gfc_peek_ascii_char () == '%'\n \t  && sym->ts.type == BT_UNKNOWN\n \t  && gfc_get_default_type (sym, implicit_ns)->type == BT_DERIVED)\n \tgfc_set_default_type (sym, 0, implicit_ns);"}, {"sha": "871739c2c1e67c7f78db1335bfeba112c04e9ff4", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 242, "deletions": 64, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fc541d3a5225284038d28ebe0b80cba2da3371b/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=8fc541d3a5225284038d28ebe0b80cba2da3371b", "patch": "@@ -72,7 +72,7 @@ static gfc_linebuf *line_head, *line_tail;\n locus gfc_current_locus;\n const char *gfc_source_file;\n static FILE *gfc_src_file;\n-static char *gfc_src_preprocessor_lines[2];\n+static gfc_char_t *gfc_src_preprocessor_lines[2];\n \n extern int pedantic;\n \n@@ -85,6 +85,135 @@ static struct gfc_file_change\n size_t file_changes_cur, file_changes_count;\n size_t file_changes_allocated;\n \n+\n+/* Functions dealing with our wide characters (gfc_char_t) and\n+   sequences of such characters.  */\n+\n+int\n+gfc_wide_fits_in_byte (gfc_char_t c)\n+{\n+  return (c <= UCHAR_MAX);\n+}\n+\n+static inline int\n+wide_is_ascii (gfc_char_t c)\n+{\n+  return (gfc_wide_fits_in_byte (c) && ((unsigned char) c & ~0x7f) == 0);\n+}\n+\n+int\n+gfc_wide_is_printable (gfc_char_t c)\n+{\n+  return (gfc_wide_fits_in_byte (c) && ISPRINT ((unsigned char) c));\n+}\n+\n+gfc_char_t\n+gfc_wide_tolower (gfc_char_t c)\n+{\n+  return (wide_is_ascii (c) ? (gfc_char_t) TOLOWER((unsigned char) c) : c);\n+}\n+\n+int\n+gfc_wide_is_digit (gfc_char_t c)\n+{\n+  return (c >= '0' && c <= '9');\n+}\n+\n+static inline int\n+wide_atoi (gfc_char_t *c)\n+{\n+#define MAX_DIGITS 20\n+  char buf[MAX_DIGITS+1];\n+  int i = 0;\n+\n+  while (gfc_wide_is_digit(*c) && i < MAX_DIGITS)\n+    buf[i++] = *c++;\n+  buf[i] = '\\0';\n+  return atoi (buf);\n+}\n+\n+size_t\n+gfc_wide_strlen (const gfc_char_t *str)\n+{\n+  size_t i;\n+\n+  for (i = 0; str[i]; i++)\n+    ;\n+\n+  return i;\n+}\n+\n+static gfc_char_t *\n+wide_strcpy (gfc_char_t *dest, const gfc_char_t *src)\n+{\n+  gfc_char_t *d;\n+\n+  for (d = dest; (*d = *src) != '\\0'; ++src, ++d)\n+    ;\n+\n+  return dest;\n+}\n+\n+static gfc_char_t *\n+wide_strchr (gfc_char_t *s, gfc_char_t c)\n+{\n+  do {\n+    if (*s == c)\n+      {\n+        return (gfc_char_t *) s;\n+      }\n+  } while (*s++);\n+  return 0;\n+}\n+\n+static char *\n+widechar_to_char (gfc_char_t *s)\n+{\n+  size_t len = gfc_wide_strlen (s), i;\n+  char *res = gfc_getmem (len + 1);\n+\n+  for (i = 0; i < len; i++)\n+    res[i] = gfc_wide_fits_in_byte (s[i]) ? (unsigned char) s[i] : '?';\n+\n+  res[len] = '\\0';\n+  return res;\n+}\n+\n+static int\n+wide_strncmp (const gfc_char_t *s1, const char *s2, size_t n)\n+{\n+  gfc_char_t c1, c2;\n+\n+  while (n-- > 0)\n+    {\n+      c1 = *s1++;\n+      c2 = *s2++;\n+      if (c1 != c2)\n+\treturn (c1 > c2 ? 1 : -1);\n+      if (c1 == '\\0')\n+\treturn 0;\n+    }\n+  return 0;\n+}\n+\n+static int\n+wide_strncasecmp (const gfc_char_t *s1, const char *s2, size_t n)\n+{\n+  gfc_char_t c1, c2;\n+\n+  while (n-- > 0)\n+    {\n+      c1 = gfc_wide_tolower (*s1++);\n+      c2 = TOLOWER (*s2++);\n+      if (c1 != c2)\n+\treturn (c1 > c2 ? 1 : -1);\n+      if (c1 == '\\0')\n+\treturn 0;\n+    }\n+  return 0;\n+}\n+\n+\n /* Main scanner initialization.  */\n \n void\n@@ -406,15 +535,15 @@ gfc_advance_line (void)\n    pointer from being on the wrong line if the current statement ends\n    prematurely.  */\n \n-static int\n+static gfc_char_t\n next_char (void)\n {\n-  int c;\n+  gfc_char_t c;\n   \n   if (gfc_current_locus.nextc == NULL)\n     return '\\n';\n \n-  c = (unsigned char) *gfc_current_locus.nextc++;\n+  c = *gfc_current_locus.nextc++;\n   if (c == '\\0')\n     {\n       gfc_current_locus.nextc--; /* Remain on this line.  */\n@@ -433,7 +562,7 @@ next_char (void)\n static void\n skip_comment_line (void)\n {\n-  char c;\n+  gfc_char_t c;\n \n   do\n     {\n@@ -448,17 +577,27 @@ skip_comment_line (void)\n int\n gfc_define_undef_line (void)\n {\n+  char *tmp;\n+\n   /* All lines beginning with '#' are either #define or #undef.  */\n-  if (debug_info_level != DINFO_LEVEL_VERBOSE || gfc_peek_char () != '#')\n+  if (debug_info_level != DINFO_LEVEL_VERBOSE || gfc_peek_ascii_char () != '#')\n     return 0;\n \n-  if (strncmp (gfc_current_locus.nextc, \"#define \", 8) == 0)\n-    (*debug_hooks->define) (gfc_linebuf_linenum (gfc_current_locus.lb),\n-\t\t\t    &(gfc_current_locus.nextc[8]));\n+  if (wide_strncmp (gfc_current_locus.nextc, \"#define \", 8) == 0)\n+    {\n+      tmp = widechar_to_char (&gfc_current_locus.nextc[8]);\n+      (*debug_hooks->define) (gfc_linebuf_linenum (gfc_current_locus.lb),\n+\t\t\t      tmp);\n+      gfc_free (tmp);\n+    }\n \n-  if (strncmp (gfc_current_locus.nextc, \"#undef \", 7) == 0)\n-    (*debug_hooks->undef) (gfc_linebuf_linenum (gfc_current_locus.lb),\n-\t\t\t   &(gfc_current_locus.nextc[7]));\n+  if (wide_strncmp (gfc_current_locus.nextc, \"#undef \", 7) == 0)\n+    {\n+      tmp = widechar_to_char (&gfc_current_locus.nextc[7]);\n+      (*debug_hooks->undef) (gfc_linebuf_linenum (gfc_current_locus.lb),\n+\t\t\t     tmp);\n+      gfc_free (tmp);\n+    }\n \n   /* Skip the rest of the line.  */\n   skip_comment_line ();\n@@ -476,7 +615,7 @@ static bool\n skip_free_comments (void)\n {\n   locus start;\n-  char c;\n+  gfc_char_t c;\n   int at_bol;\n \n   for (;;)\n@@ -570,7 +709,7 @@ skip_fixed_comments (void)\n {\n   locus start;\n   int col;\n-  char c;\n+  gfc_char_t c;\n \n   if (! gfc_at_bol ())\n     {\n@@ -738,11 +877,12 @@ gfc_skip_comments (void)\n    line.  The in_string flag denotes whether we're inside a character\n    context or not.  */\n \n-int\n+gfc_char_t\n gfc_next_char_literal (int in_string)\n {\n   locus old_loc;\n-  int i, c, prev_openmp_flag;\n+  int i, prev_openmp_flag;\n+  gfc_char_t c;\n \n   continue_flag = 0;\n \n@@ -859,7 +999,7 @@ gfc_next_char_literal (int in_string)\n \t{\n \t  for (i = 0; i < 5; i++, c = next_char ())\n \t    {\n-\t      gcc_assert (TOLOWER (c) == \"!$omp\"[i]);\n+\t      gcc_assert (gfc_wide_tolower (c) == (unsigned char) \"!$omp\"[i]);\n \t      if (i == 4)\n \t\told_loc = gfc_current_locus;\n \t    }\n@@ -932,7 +1072,7 @@ gfc_next_char_literal (int in_string)\n \tfor (i = 0; i < 5; i++)\n \t  {\n \t    c = next_char ();\n-\t    if (TOLOWER (c) != \"*$omp\"[i])\n+\t    if (gfc_wide_tolower (c) != (unsigned char) \"*$omp\"[i])\n \t      goto not_continuation;\n \t  }\n \n@@ -980,26 +1120,35 @@ gfc_next_char_literal (int in_string)\n    parsing character literals, they have to call\n    gfc_next_char_literal().  */\n \n-int\n+gfc_char_t\n gfc_next_char (void)\n {\n-  int c;\n+  gfc_char_t c;\n \n   do\n     {\n       c = gfc_next_char_literal (0);\n     }\n   while (gfc_current_form == FORM_FIXED && gfc_is_whitespace (c));\n \n-  return TOLOWER (c);\n+  return gfc_wide_tolower (c);\n }\n \n+char\n+gfc_next_ascii_char (void)\n+{\n+  gfc_char_t c = gfc_next_char ();\n \n-int\n+  return (gfc_wide_fits_in_byte (c) ? (unsigned char) c\n+\t\t\t\t    : (unsigned char) UCHAR_MAX);\n+}\n+\n+\n+gfc_char_t\n gfc_peek_char (void)\n {\n   locus old_loc;\n-  int c;\n+  gfc_char_t c;\n \n   old_loc = gfc_current_locus;\n   c = gfc_next_char ();\n@@ -1009,6 +1158,16 @@ gfc_peek_char (void)\n }\n \n \n+char\n+gfc_peek_ascii_char (void)\n+{\n+  gfc_char_t c = gfc_peek_char ();\n+\n+  return (gfc_wide_fits_in_byte (c) ? (unsigned char) c\n+\t\t\t\t    : (unsigned char) UCHAR_MAX);\n+}\n+\n+\n /* Recover from an error.  We try to get past the current statement\n    and get lined up for the next.  The next statement follows a '\\n'\n    or a ';'.  We also assume that we are not within a character\n@@ -1017,7 +1176,7 @@ gfc_peek_char (void)\n void\n gfc_error_recovery (void)\n {\n-  char c, delim;\n+  gfc_char_t c, delim;\n \n   if (gfc_at_eof ())\n     return;\n@@ -1064,7 +1223,7 @@ gfc_gobble_whitespace (void)\n {\n   static int linenum = 0;\n   locus old_loc;\n-  int c;\n+  gfc_char_t c;\n \n   do\n     {\n@@ -1106,13 +1265,13 @@ gfc_gobble_whitespace (void)\n \t parts of gfortran.  */\n \n static int\n-load_line (FILE *input, char **pbuf, int *pbuflen)\n+load_line (FILE *input, gfc_char_t **pbuf, int *pbuflen)\n {\n   static int linenum = 0, current_line = 1;\n   int c, maxlen, i, preprocessor_flag, buflen = *pbuflen;\n   int trunc_flag = 0, seen_comment = 0;\n   int seen_printable = 0, seen_ampersand = 0;\n-  char *buffer;\n+  gfc_char_t *buffer;\n   bool found_tab = false;\n \n   /* Determine the maximum allowed line length.  */\n@@ -1135,7 +1294,7 @@ load_line (FILE *input, char **pbuf, int *pbuflen)\n       else\n \tbuflen = 132;\n \n-      *pbuf = gfc_getmem (buflen + 1);\n+      *pbuf = gfc_getmem ((buflen + 1) * sizeof (gfc_char_t));\n     }\n \n   i = 0;\n@@ -1234,7 +1393,7 @@ load_line (FILE *input, char **pbuf, int *pbuflen)\n \t      /* Reallocate line buffer to double size to hold the\n \t\toverlong line.  */\n \t      buflen = buflen * 2;\n-\t      *pbuf = xrealloc (*pbuf, buflen + 1);\n+\t      *pbuf = xrealloc (*pbuf, (buflen + 1) * sizeof (gfc_char_t));\n \t      buffer = (*pbuf) + i;\n \t    }\n \t}\n@@ -1297,17 +1456,19 @@ get_file (const char *name, enum lc_reason reason ATTRIBUTE_UNUSED)\n   return f;\n }\n \n+\n /* Deal with a line from the C preprocessor. The\n    initial octothorp has already been seen.  */\n \n static void\n-preprocessor_line (char *c)\n+preprocessor_line (gfc_char_t *c)\n {\n   bool flag[5];\n   int i, line;\n-  char *filename;\n+  gfc_char_t *wide_filename;\n   gfc_file *f;\n   int escaped, unescape;\n+  char *filename;\n \n   c++;\n   while (*c == ' ' || *c == '\\t')\n@@ -1316,9 +1477,9 @@ preprocessor_line (char *c)\n   if (*c < '0' || *c > '9')\n     goto bad_cpp_line;\n \n-  line = atoi (c);\n+  line = wide_atoi (c);\n \n-  c = strchr (c, ' ');\n+  c = wide_strchr (c, ' ');\n   if (c == NULL)\n     {\n       /* No file name given.  Set new line number.  */\n@@ -1335,7 +1496,7 @@ preprocessor_line (char *c)\n     goto bad_cpp_line;\n   ++c;\n \n-  filename = c;\n+  wide_filename = c;\n \n   /* Make filename end at quote.  */\n   unescape = 0;\n@@ -1361,10 +1522,10 @@ preprocessor_line (char *c)\n   /* Undo effects of cpp_quote_string.  */\n   if (unescape)\n     {\n-      char *s = filename;\n-      char *d = gfc_getmem (c - filename - unescape);\n+      gfc_char_t *s = wide_filename;\n+      gfc_char_t *d = gfc_getmem (c - wide_filename - unescape);\n \n-      filename = d;\n+      wide_filename = d;\n       while (*s)\n \t{\n \t  if (*s == '\\\\')\n@@ -1382,17 +1543,21 @@ preprocessor_line (char *c)\n \n   for (;;)\n     {\n-      c = strchr (c, ' ');\n+      c = wide_strchr (c, ' ');\n       if (c == NULL)\n \tbreak;\n \n       c++;\n-      i = atoi (c);\n+      i = wide_atoi (c);\n \n       if (1 <= i && i <= 4)\n \tflag[i] = true;\n     }\n \n+  /* Convert the filename in wide characters into a filename in narrow\n+     characters.  */\n+  filename = widechar_to_char (wide_filename);\n+\n   /* Interpret flags.  */\n \n   if (flag[1]) /* Starting new file.  */\n@@ -1411,7 +1576,8 @@ preprocessor_line (char *c)\n \t\t\t   current_file->filename, current_file->line,\n \t\t\t   filename);\n \t  if (unescape)\n-\t    gfc_free (filename);\n+\t    gfc_free (wide_filename);\n+\t  gfc_free (filename);\n \t  return;\n \t}\n \n@@ -1434,7 +1600,8 @@ preprocessor_line (char *c)\n   /* Set new line number.  */\n   current_file->line = line;\n   if (unescape)\n-    gfc_free (filename);\n+    gfc_free (wide_filename);\n+  gfc_free (filename);\n   return;\n \n  bad_cpp_line:\n@@ -1453,9 +1620,10 @@ static try load_file (const char *, bool);\n    processed or true if we matched an include.  */\n \n static bool\n-include_line (char *line)\n+include_line (gfc_char_t *line)\n {\n-  char quote, *c, *begin, *stop;\n+  gfc_char_t quote, *c, *begin, *stop;\n+  char *filename;\n \n   c = line;\n \n@@ -1479,8 +1647,8 @@ include_line (char *line)\n   while (*c == ' ' || *c == '\\t')\n     c++;\n \n-  if (strncasecmp (c, \"include\", 7))\n-      return false;\n+  if (wide_strncasecmp (c, \"include\", 7))\n+    return false;\n \n   c += 7;\n   while (*c == ' ' || *c == '\\t')\n@@ -1513,7 +1681,9 @@ include_line (char *line)\n   *stop = '\\0'; /* It's ok to trash the buffer, as this line won't be\n \t\t   read by anything else.  */\n \n-  load_file (begin, false);\n+  filename = widechar_to_char (begin);\n+  load_file (filename, false);\n+  gfc_free (filename);\n   return true;\n }\n \n@@ -1523,7 +1693,7 @@ include_line (char *line)\n static try\n load_file (const char *filename, bool initial)\n {\n-  char *line;\n+  gfc_char_t *line;\n   gfc_linebuf *b;\n   gfc_file *f;\n   FILE *input;\n@@ -1590,7 +1760,7 @@ load_file (const char *filename, bool initial)\n     {\n       int trunc = load_line (input, &line, &line_len);\n \n-      len = strlen (line);\n+      len = gfc_wide_strlen (line);\n       if (feof (input) && len == 0)\n \tbreak;\n \n@@ -1600,15 +1770,18 @@ load_file (const char *filename, bool initial)\n \t   FE FF is UTF-16 big endian,\n \t   EF BB BF is UTF-8.  */\n       if (first_line\n-\t  && ((line_len >= 2 && line[0] == '\\xFF' && line[1] == '\\xFE')\n-\t      || (line_len >= 2 && line[0] == '\\xFE' && line[1] == '\\xFF')\n-\t      || (line_len >= 3 && line[0] == '\\xEF' && line[1] == '\\xBB'\n-\t\t  && line[2] == '\\xBF')))\n+\t  && ((line_len >= 2 && line[0] == (unsigned char) '\\xFF'\n+\t\t\t     && line[1] == (unsigned char) '\\xFE')\n+\t      || (line_len >= 2 && line[0] == (unsigned char) '\\xFE'\n+\t\t\t        && line[1] == (unsigned char) '\\xFF')\n+\t      || (line_len >= 3 && line[0] == (unsigned char) '\\xEF'\n+\t\t\t\t&& line[1] == (unsigned char) '\\xBB'\n+\t\t\t\t&& line[2] == (unsigned char) '\\xBF')))\n \t{\n-\t  int n = line[1] == '\\xBB' ? 3 : 2;\n-\t  char * new = gfc_getmem (line_len);\n+\t  int n = line[1] == (unsigned char) '\\xBB' ? 3 : 2;\n+\t  gfc_char_t *new = gfc_getmem (line_len * sizeof (gfc_char_t));\n \n-\t  strcpy (new, line + n);\n+\t  wide_strcpy (new, &line[n]);\n \t  gfc_free (line);\n \t  line = new;\n \t  len -= n;\n@@ -1623,8 +1796,8 @@ load_file (const char *filename, bool initial)\n \t     and #undef lines, which we need to pass to the middle-end\n \t     so that it can emit correct debug info.  */\n \t  if (debug_info_level == DINFO_LEVEL_VERBOSE\n-\t      && (strncmp (line, \"#define \", 8) == 0\n-\t\t  || strncmp (line, \"#undef \", 7) == 0))\n+\t      && (wide_strncmp (line, \"#define \", 8) == 0\n+\t\t  || wide_strncmp (line, \"#undef \", 7) == 0))\n \t    ;\n \t  else\n \t    {\n@@ -1646,13 +1819,14 @@ load_file (const char *filename, bool initial)\n \n       /* Add line.  */\n \n-      b = gfc_getmem (gfc_linebuf_header_size + len + 1);\n+      b = gfc_getmem (gfc_linebuf_header_size\n+\t\t      + (len + 1) * sizeof (gfc_char_t));\n \n       b->location\n \t= linemap_line_start (line_table, current_file->line++, 120);\n       b->file = current_file;\n       b->truncated = trunc;\n-      strcpy (b->line, line);\n+      wide_strcpy (b->line, line);\n \n       if (line_head == NULL)\n \tline_head = b;\n@@ -1752,7 +1926,7 @@ const char *\n gfc_read_orig_filename (const char *filename, const char **canon_source_file)\n {\n   int c, len;\n-  char *dirname;\n+  char *dirname, *tmp;\n \n   gfc_src_file = gfc_open_file (filename);\n   if (gfc_src_file == NULL)\n@@ -1767,10 +1941,12 @@ gfc_read_orig_filename (const char *filename, const char **canon_source_file)\n   len = 0;\n   load_line (gfc_src_file, &gfc_src_preprocessor_lines[0], &len);\n \n-  if (strncmp (gfc_src_preprocessor_lines[0], \"# 1 \\\"\", 5) != 0)\n+  if (wide_strncmp (gfc_src_preprocessor_lines[0], \"# 1 \\\"\", 5) != 0)\n     return NULL;\n \n-  filename = unescape_filename (gfc_src_preprocessor_lines[0] + 5);\n+  tmp = widechar_to_char (&gfc_src_preprocessor_lines[0][5]);\n+  filename = unescape_filename (tmp);\n+  gfc_free (tmp);\n   if (filename == NULL)\n     return NULL;\n \n@@ -1783,10 +1959,12 @@ gfc_read_orig_filename (const char *filename, const char **canon_source_file)\n   len = 0;\n   load_line (gfc_src_file, &gfc_src_preprocessor_lines[1], &len);\n \n-  if (strncmp (gfc_src_preprocessor_lines[1], \"# 1 \\\"\", 5) != 0)\n+  if (wide_strncmp (gfc_src_preprocessor_lines[1], \"# 1 \\\"\", 5) != 0)\n     return filename;\n \n-  dirname = unescape_filename (gfc_src_preprocessor_lines[1] + 5);\n+  tmp = widechar_to_char (&gfc_src_preprocessor_lines[1][5]);\n+  dirname = unescape_filename (tmp);\n+  gfc_free (tmp);\n   if (dirname == NULL)\n     return filename;\n "}]}