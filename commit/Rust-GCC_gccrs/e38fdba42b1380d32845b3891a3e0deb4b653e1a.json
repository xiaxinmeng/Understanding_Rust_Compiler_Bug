{"sha": "e38fdba42b1380d32845b3891a3e0deb4b653e1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM4ZmRiYTQyYjEzODBkMzI4NDViMzg5MWEzZTBkZWI0YjY1M2UxYQ==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2015-05-06T16:45:49Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2015-05-06T16:45:49Z"}, "message": "oacc-init.c (acc_shutdown_1): Call gomp_mutex_unlock for goacc_thread_lock on error paths.\n\n\t* oacc-init.c (acc_shutdown_1): Call gomp_mutex_unlock for\n\tgoacc_thread_lock on error paths.\n\t* oacc-mem.c (lookup_host): Remove locking from function. Note\n\tlocking requirement for caller in function comment.\n\t(lookup_dev): Likewise.\n\t(acc_free, acc_deviceptr, acc_hostptr, acc_is_present)\n\t(acc_map_data, acc_unmap_data, present_create_copy, delete_copyout)\n\t(update_dev_host, gomp_acc_insert_pointer, gomp_acc_remove_pointer):\n\tAdd locking.\n\nFrom-SVN: r222860", "tree": {"sha": "28d8cb3a48d10ec0b8097a10ccfc88a1f46deba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28d8cb3a48d10ec0b8097a10ccfc88a1f46deba3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e38fdba42b1380d32845b3891a3e0deb4b653e1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e38fdba42b1380d32845b3891a3e0deb4b653e1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e38fdba42b1380d32845b3891a3e0deb4b653e1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e38fdba42b1380d32845b3891a3e0deb4b653e1a/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a0ff57c48cbaeedfac667d5e808baca8dbcb83c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a0ff57c48cbaeedfac667d5e808baca8dbcb83c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a0ff57c48cbaeedfac667d5e808baca8dbcb83c"}], "stats": {"total": 184, "additions": 141, "deletions": 43}, "files": [{"sha": "d943df20aa93136ce73cfbadcef620b399d0f7af", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38fdba42b1380d32845b3891a3e0deb4b653e1a/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38fdba42b1380d32845b3891a3e0deb4b653e1a/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=e38fdba42b1380d32845b3891a3e0deb4b653e1a", "patch": "@@ -1,3 +1,15 @@\n+2015-05-06  Julian Brown  <julian@codesourcery.com>\n+\n+\t* oacc-init.c (acc_shutdown_1): Call gomp_mutex_unlock for\n+\tgoacc_thread_lock on error paths.\n+\t* oacc-mem.c (lookup_host): Remove locking from function. Note\n+\tlocking requirement for caller in function comment.\n+\t(lookup_dev): Likewise.\n+\t(acc_free, acc_deviceptr, acc_hostptr, acc_is_present)\n+\t(acc_map_data, acc_unmap_data, present_create_copy, delete_copyout)\n+\t(update_dev_host, gomp_acc_insert_pointer, gomp_acc_remove_pointer):\n+\tAdd locking.\n+\n 2015-05-05  Thomas Schwinge  <thomas@codesourcery.com>\n \n \tPR testsuite/65205"}, {"sha": "10722980fe84f571086a30e8906ccecc6dc3b1ce", "filename": "libgomp/oacc-init.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38fdba42b1380d32845b3891a3e0deb4b653e1a/libgomp%2Foacc-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38fdba42b1380d32845b3891a3e0deb4b653e1a/libgomp%2Foacc-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-init.c?ref=e38fdba42b1380d32845b3891a3e0deb4b653e1a", "patch": "@@ -217,11 +217,17 @@ acc_shutdown_1 (acc_device_t d)\n       /* This would mean the user is shutting down OpenACC in the middle of an\n          \"acc data\" pragma.  Likely not intentional.  */\n       if (walk->mapped_data)\n-\tgomp_fatal (\"shutdown in 'acc data' region\");\n+\t{\n+\t  gomp_mutex_unlock (&goacc_thread_lock);\n+\t  gomp_fatal (\"shutdown in 'acc data' region\");\n+\t}\n \n       /* Similarly, if this happens then user code has done something weird.  */\n       if (walk->saved_bound_dev)\n-        gomp_fatal (\"shutdown during host fallback\");\n+\t{\n+\t  gomp_mutex_unlock (&goacc_thread_lock);\n+\t  gomp_fatal (\"shutdown during host fallback\");\n+\t}\n \n       if (walk->dev)\n \t{"}, {"sha": "90d43eb2b8a6d83476c25e934498d5f11ec49e31", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 121, "deletions": 41, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38fdba42b1380d32845b3891a3e0deb4b653e1a/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38fdba42b1380d32845b3891a3e0deb4b653e1a/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=e38fdba42b1380d32845b3891a3e0deb4b653e1a", "patch": "@@ -35,7 +35,8 @@\n #include <stdint.h>\n #include <assert.h>\n \n-/* Return block containing [H->S), or NULL if not contained.  */\n+/* Return block containing [H->S), or NULL if not contained.  The device lock\n+   for DEV must be locked on entry, and remains locked on exit.  */\n \n static splay_tree_key\n lookup_host (struct gomp_device_descr *dev, void *h, size_t s)\n@@ -46,17 +47,16 @@ lookup_host (struct gomp_device_descr *dev, void *h, size_t s)\n   node.host_start = (uintptr_t) h;\n   node.host_end = (uintptr_t) h + s;\n \n-  gomp_mutex_lock (&dev->lock);\n   key = splay_tree_lookup (&dev->mem_map, &node);\n-  gomp_mutex_unlock (&dev->lock);\n \n   return key;\n }\n \n /* Return block containing [D->S), or NULL if not contained.\n    The list isn't ordered by device address, so we have to iterate\n    over the whole array.  This is not expected to be a common\n-   operation.  */\n+   operation.  The device lock associated with TGT must be locked on entry, and\n+   remains locked on exit.  */\n \n static splay_tree_key\n lookup_dev (struct target_mem_desc *tgt, void *d, size_t s)\n@@ -67,16 +67,12 @@ lookup_dev (struct target_mem_desc *tgt, void *d, size_t s)\n   if (!tgt)\n     return NULL;\n \n-  gomp_mutex_lock (&tgt->device_descr->lock);\n-\n   for (t = tgt; t != NULL; t = t->prev)\n     {\n       if (t->tgt_start <= (uintptr_t) d && t->tgt_end >= (uintptr_t) d + s)\n         break;\n     }\n \n-  gomp_mutex_unlock (&tgt->device_descr->lock);\n-\n   if (!t)\n     return NULL;\n \n@@ -119,26 +115,35 @@ void\n acc_free (void *d)\n {\n   splay_tree_key k;\n-  struct goacc_thread *thr = goacc_thread ();\n \n   if (!d)\n     return;\n \n+  struct goacc_thread *thr = goacc_thread ();\n+\n   assert (thr && thr->dev);\n \n+  struct gomp_device_descr *acc_dev = thr->dev;\n+\n+  gomp_mutex_lock (&acc_dev->lock);\n+\n   /* We don't have to call lazy open here, as the ptr value must have\n      been returned by acc_malloc.  It's not permitted to pass NULL in\n      (unless you got that null from acc_malloc).  */\n-  if ((k = lookup_dev (thr->dev->openacc.data_environ, d, 1)))\n-   {\n-     void *offset;\n+  if ((k = lookup_dev (acc_dev->openacc.data_environ, d, 1)))\n+    {\n+      void *offset;\n \n-     offset = d - k->tgt->tgt_start + k->tgt_offset;\n+      offset = d - k->tgt->tgt_start + k->tgt_offset;\n \n-     acc_unmap_data ((void *)(k->host_start + offset));\n-   }\n+      gomp_mutex_unlock (&acc_dev->lock);\n \n-  thr->dev->free_func (thr->dev->target_id, d);\n+      acc_unmap_data ((void *)(k->host_start + offset));\n+    }\n+  else\n+    gomp_mutex_unlock (&acc_dev->lock);\n+\n+  acc_dev->free_func (acc_dev->target_id, d);\n }\n \n void\n@@ -178,16 +183,24 @@ acc_deviceptr (void *h)\n   goacc_lazy_initialize ();\n \n   struct goacc_thread *thr = goacc_thread ();\n+  struct gomp_device_descr *dev = thr->dev;\n+\n+  gomp_mutex_lock (&dev->lock);\n \n-  n = lookup_host (thr->dev, h, 1);\n+  n = lookup_host (dev, h, 1);\n \n   if (!n)\n-    return NULL;\n+    {\n+      gomp_mutex_unlock (&dev->lock);\n+      return NULL;\n+    }\n \n   offset = h - n->host_start;\n \n   d = n->tgt->tgt_start + n->tgt_offset + offset;\n \n+  gomp_mutex_unlock (&dev->lock);\n+\n   return d;\n }\n \n@@ -204,16 +217,24 @@ acc_hostptr (void *d)\n   goacc_lazy_initialize ();\n \n   struct goacc_thread *thr = goacc_thread ();\n+  struct gomp_device_descr *acc_dev = thr->dev;\n \n-  n = lookup_dev (thr->dev->openacc.data_environ, d, 1);\n+  gomp_mutex_lock (&acc_dev->lock);\n+\n+  n = lookup_dev (acc_dev->openacc.data_environ, d, 1);\n \n   if (!n)\n-    return NULL;\n+    {\n+      gomp_mutex_unlock (&acc_dev->lock);\n+      return NULL;\n+    }\n \n   offset = d - n->tgt->tgt_start + n->tgt_offset;\n \n   h = n->host_start + offset;\n \n+  gomp_mutex_unlock (&acc_dev->lock);\n+\n   return h;\n }\n \n@@ -232,13 +253,17 @@ acc_is_present (void *h, size_t s)\n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n \n+  gomp_mutex_lock (&acc_dev->lock);\n+\n   n = lookup_host (acc_dev, h, s);\n \n   if (n && ((uintptr_t)h < n->host_start\n \t    || (uintptr_t)h + s > n->host_end\n \t    || s > n->host_end - n->host_start))\n     n = NULL;\n \n+  gomp_mutex_unlock (&acc_dev->lock);\n+\n   return n != NULL;\n }\n \n@@ -274,20 +299,32 @@ acc_map_data (void *h, void *d, size_t s)\n \tgomp_fatal (\"[%p,+%d]->[%p,+%d] is a bad map\",\n                     (void *)h, (int)s, (void *)d, (int)s);\n \n+      gomp_mutex_lock (&acc_dev->lock);\n+\n       if (lookup_host (acc_dev, h, s))\n-\tgomp_fatal (\"host address [%p, +%d] is already mapped\", (void *)h,\n-\t\t    (int)s);\n+        {\n+\t  gomp_mutex_unlock (&acc_dev->lock);\n+\t  gomp_fatal (\"host address [%p, +%d] is already mapped\", (void *)h,\n+\t\t      (int)s);\n+\t}\n \n       if (lookup_dev (thr->dev->openacc.data_environ, d, s))\n-\tgomp_fatal (\"device address [%p, +%d] is already mapped\", (void *)d,\n-\t\t    (int)s);\n+        {\n+\t  gomp_mutex_unlock (&acc_dev->lock);\n+\t  gomp_fatal (\"device address [%p, +%d] is already mapped\", (void *)d,\n+\t\t      (int)s);\n+\t}\n+\n+      gomp_mutex_unlock (&acc_dev->lock);\n \n       tgt = gomp_map_vars (acc_dev, mapnum, &hostaddrs, &devaddrs, &sizes,\n \t\t\t   &kinds, true, false);\n     }\n \n+  gomp_mutex_lock (&acc_dev->lock);\n   tgt->prev = acc_dev->openacc.data_environ;\n   acc_dev->openacc.data_environ = tgt;\n+  gomp_mutex_unlock (&acc_dev->lock);\n }\n \n void\n@@ -299,17 +336,26 @@ acc_unmap_data (void *h)\n   /* No need to call lazy open, as the address must have been mapped.  */\n \n   size_t host_size;\n+\n+  gomp_mutex_lock (&acc_dev->lock);\n+\n   splay_tree_key n = lookup_host (acc_dev, h, 1);\n   struct target_mem_desc *t;\n \n   if (!n)\n-    gomp_fatal (\"%p is not a mapped block\", (void *)h);\n+    {\n+      gomp_mutex_unlock (&acc_dev->lock);\n+      gomp_fatal (\"%p is not a mapped block\", (void *)h);\n+    }\n \n   host_size = n->host_end - n->host_start;\n \n   if (n->host_start != (uintptr_t) h)\n-    gomp_fatal (\"[%p,%d] surrounds1 %p\",\n-\t\t(void *) n->host_start, (int) host_size, (void *) h);\n+    {\n+      gomp_mutex_unlock (&acc_dev->lock);\n+      gomp_fatal (\"[%p,%d] surrounds %p\",\n+\t\t  (void *) n->host_start, (int) host_size, (void *) h);\n+    }\n \n   t = n->tgt;\n \n@@ -323,8 +369,6 @@ acc_unmap_data (void *h)\n       t->tgt_end = 0;\n       t->to_free = 0;\n \n-      gomp_mutex_lock (&acc_dev->lock);\n-\n       for (tp = NULL, t = acc_dev->openacc.data_environ; t != NULL;\n \t   tp = t, t = t->prev)\n \tif (n->tgt == t)\n@@ -336,10 +380,10 @@ acc_unmap_data (void *h)\n \n \t    break;\n \t  }\n-\n-      gomp_mutex_unlock (&acc_dev->lock);\n     }\n \n+  gomp_mutex_unlock (&acc_dev->lock);\n+\n   gomp_unmap_vars (t, true);\n }\n \n@@ -361,20 +405,31 @@ present_create_copy (unsigned f, void *h, size_t s)\n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n \n+  gomp_mutex_lock (&acc_dev->lock);\n+\n   n = lookup_host (acc_dev, h, s);\n   if (n)\n     {\n       /* Present. */\n       d = (void *) (n->tgt->tgt_start + n->tgt_offset);\n \n       if (!(f & FLAG_PRESENT))\n-        gomp_fatal (\"[%p,+%d] already mapped to [%p,+%d]\",\n-            (void *)h, (int)s, (void *)d, (int)s);\n+        {\n+\t  gomp_mutex_unlock (&acc_dev->lock);\n+          gomp_fatal (\"[%p,+%d] already mapped to [%p,+%d]\",\n+        \t      (void *)h, (int)s, (void *)d, (int)s);\n+\t}\n       if ((h + s) > (void *)n->host_end)\n-        gomp_fatal (\"[%p,+%d] not mapped\", (void *)h, (int)s);\n+\t{\n+\t  gomp_mutex_unlock (&acc_dev->lock);\n+\t  gomp_fatal (\"[%p,+%d] not mapped\", (void *)h, (int)s);\n+\t}\n+\n+      gomp_mutex_unlock (&acc_dev->lock);\n     }\n   else if (!(f & FLAG_CREATE))\n     {\n+      gomp_mutex_unlock (&acc_dev->lock);\n       gomp_fatal (\"[%p,+%d] not mapped\", (void *)h, (int)s);\n     }\n   else\n@@ -389,6 +444,8 @@ present_create_copy (unsigned f, void *h, size_t s)\n       else\n \tkinds = GOMP_MAP_ALLOC;\n \n+      gomp_mutex_unlock (&acc_dev->lock);\n+\n       tgt = gomp_map_vars (acc_dev, mapnum, &hostaddrs, NULL, &s, &kinds, true,\n \t\t\t   false);\n \n@@ -439,21 +496,31 @@ delete_copyout (unsigned f, void *h, size_t s)\n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n \n+  gomp_mutex_lock (&acc_dev->lock);\n+\n   n = lookup_host (acc_dev, h, s);\n \n   /* No need to call lazy open, as the data must already have been\n      mapped.  */\n \n   if (!n)\n-    gomp_fatal (\"[%p,%d] is not mapped\", (void *)h, (int)s);\n+    {\n+      gomp_mutex_unlock (&acc_dev->lock);\n+      gomp_fatal (\"[%p,%d] is not mapped\", (void *)h, (int)s);\n+    }\n \n   d = (void *) (n->tgt->tgt_start + n->tgt_offset);\n \n   host_size = n->host_end - n->host_start;\n \n   if (n->host_start != (uintptr_t) h || host_size != s)\n-    gomp_fatal (\"[%p,%d] surrounds2 [%p,+%d]\",\n-\t\t(void *) n->host_start, (int) host_size, (void *) h, (int) s);\n+    {\n+      gomp_mutex_unlock (&acc_dev->lock);\n+      gomp_fatal (\"[%p,%d] surrounds2 [%p,+%d]\",\n+\t\t  (void *) n->host_start, (int) host_size, (void *) h, (int) s);\n+    }\n+\n+  gomp_mutex_unlock (&acc_dev->lock);\n \n   if (f & FLAG_COPYOUT)\n     acc_dev->dev2host_func (acc_dev->target_id, h, d, s);\n@@ -482,16 +549,23 @@ update_dev_host (int is_dev, void *h, size_t s)\n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n \n+  gomp_mutex_lock (&acc_dev->lock);\n+\n   n = lookup_host (acc_dev, h, s);\n \n   /* No need to call lazy open, as the data must already have been\n      mapped.  */\n \n   if (!n)\n-    gomp_fatal (\"[%p,%d] is not mapped\", h, (int)s);\n+    {\n+      gomp_mutex_unlock (&acc_dev->lock);\n+      gomp_fatal (\"[%p,%d] is not mapped\", h, (int)s);\n+    }\n \n   d = (void *) (n->tgt->tgt_start + n->tgt_offset);\n \n+  gomp_mutex_unlock (&acc_dev->lock);\n+\n   if (is_dev)\n     acc_dev->host2dev_func (acc_dev->target_id, d, h, s);\n   else\n@@ -522,8 +596,11 @@ gomp_acc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,\n   tgt = gomp_map_vars (acc_dev, mapnum, hostaddrs,\n \t\t       NULL, sizes, kinds, true, false);\n   gomp_debug (0, \"  %s: mappings prepared\\n\", __FUNCTION__);\n+\n+  gomp_mutex_lock (&acc_dev->lock);\n   tgt->prev = acc_dev->openacc.data_environ;\n   acc_dev->openacc.data_environ = tgt;\n+  gomp_mutex_unlock (&acc_dev->lock);\n }\n \n void\n@@ -535,19 +612,22 @@ gomp_acc_remove_pointer (void *h, bool force_copyfrom, int async, int mapnum)\n   struct target_mem_desc *t;\n   int minrefs = (mapnum == 1) ? 2 : 3;\n \n+  gomp_mutex_lock (&acc_dev->lock);\n+\n   n = lookup_host (acc_dev, h, 1);\n \n   if (!n)\n-    gomp_fatal (\"%p is not a mapped block\", (void *)h);\n+    {\n+      gomp_mutex_unlock (&acc_dev->lock);\n+      gomp_fatal (\"%p is not a mapped block\", (void *)h);\n+    }\n \n   gomp_debug (0, \"  %s: restore mappings\\n\", __FUNCTION__);\n \n   t = n->tgt;\n \n   struct target_mem_desc *tp;\n \n-  gomp_mutex_lock (&acc_dev->lock);\n-\n   if (t->refcount == minrefs)\n     {\n       /* This is the last reference, so pull the descriptor off the"}]}