{"sha": "56099f00a526f137d24bbf2ac6def05003ebe5c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYwOTlmMDBhNTI2ZjEzN2QyNGJiZjJhYzZkZWYwNTAwM2ViZTVjNQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-05-02T11:22:31Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-05-02T11:22:31Z"}, "message": "tree.c (valid_constant_size_p): New function.\n\n2012-05-02  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.c (valid_constant_size_p): New function.\n\t* tree.h (valid_constant_size_p): Declare.\n\t* cfgexpand.c (expand_one_var): Adjust check for too large\n\tvariables by using valid_constant_size_p.\n\t* varasm.c (assemble_variable): Likewise.\n\n\tc/\n\t* c-decl.c (grokdeclarator): Properly check for sizes that\n\tcover more than half of the address-space.\n\n\tcp/\n\t* decl.c (grokdeclarator): Properly check for sizes that\n\tcover more than half of the address-space.\n\n2012-05-02  Richard Guenther  <rguenther@suse.de>\n\n\t* fold-const.c (div_if_zero_remainder): sizetypes no longer\n\tsign-extend.\n\t(int_const_binop_1): New worker for int_const_binop with\n\toverflowable parameter.  Pass it through\n\tto force_fit_type_double.\n\t(int_const_binop): Wrap around int_const_binop_1 with overflowable\n\tequal to one.\n\t(size_binop_loc): Call int_const_binop_1 with overflowable equal\n\tto minus one, forcing overflow detection for even unsigned types.\n\t(extract_muldiv_1): Remove bogus TYPE_IS_SIZETYPE special-casing.\n\t(fold_binary_loc): Call try_move_mult_to_index with signed offset.\n\t* stor-layout.c (initialize_sizetypes): sizetypes no longer\n\tsign-extend.\n\t(layout_type): For zero-sized arrays ignore overflow on the\n\tsize calculations.\n\t* tree-ssa-ccp.c (bit_value_unop_1): Likewise.\n\t(bit_value_binop_1): Likewise.\n\t* tree.c (double_int_to_tree): Likewise.\n\t(double_int_fits_to_tree_p): Likewise.\n\t(force_fit_type_double): Likewise.\n\t(host_integerp): Likewise.\n\t(int_fits_type_p): Likewise.\n\t* varasm.c (output_constructor_regular_field): Sign-extend the\n\tfield-offset to cater for negative offsets produced by the Ada frontend.\n\t* omp-low.c (extract_omp_for_data): Convert the loop step to\n\tsigned for pointer adjustments.\n\n\t* g++.dg/tree-ssa/pr19807.C: Adjust.\n\nFrom-SVN: r187042", "tree": {"sha": "3260d223788c7f661eef298b55f74eb6033bc7f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3260d223788c7f661eef298b55f74eb6033bc7f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56099f00a526f137d24bbf2ac6def05003ebe5c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56099f00a526f137d24bbf2ac6def05003ebe5c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56099f00a526f137d24bbf2ac6def05003ebe5c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56099f00a526f137d24bbf2ac6def05003ebe5c5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "795e8869fd8be77f9221f1b3884b228601f7c7d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/795e8869fd8be77f9221f1b3884b228601f7c7d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/795e8869fd8be77f9221f1b3884b228601f7c7d6"}], "stats": {"total": 232, "additions": 140, "deletions": 92}, "files": [{"sha": "485395915600259e63c08a1e42af173003aa7bbe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56099f00a526f137d24bbf2ac6def05003ebe5c5", "patch": "@@ -1,3 +1,43 @@\n+2012-05-02  Richard Guenther  <rguenther@suse.de>\n+\n+\t* fold-const.c (div_if_zero_remainder): sizetypes no longer\n+\tsign-extend.\n+\t(int_const_binop_1): New worker for int_const_binop with\n+\toverflowable parameter.  Pass it through\n+\tto force_fit_type_double.\n+\t(int_const_binop): Wrap around int_const_binop_1 with overflowable\n+\tequal to one.\n+\t(size_binop_loc): Call int_const_binop_1 with overflowable equal\n+\tto minus one, forcing overflow detection for even unsigned types.\n+\t(extract_muldiv_1): Remove bogus TYPE_IS_SIZETYPE special-casing.\n+\t(fold_binary_loc): Call try_move_mult_to_index with signed offset.\n+\t* stor-layout.c (initialize_sizetypes): sizetypes no longer\n+\tsign-extend.\n+\t(layout_type): For zero-sized arrays ignore overflow on the\n+\tsize calculations.\n+\t* tree-ssa-ccp.c (bit_value_unop_1): Likewise.\n+\t(bit_value_binop_1): Likewise.\n+\t* tree.c (double_int_to_tree): Likewise.\n+\t(double_int_fits_to_tree_p): Likewise.\n+\t(force_fit_type_double): Likewise.\n+\t(host_integerp): Likewise.\n+\t(int_fits_type_p): Likewise.\n+\t* varasm.c (output_constructor_regular_field): Sign-extend the\n+\tfield-offset to cater for negative offsets produced by the Ada frontend.\n+\t* omp-low.c (extract_omp_for_data): Convert the loop step to\n+\tsigned for pointer adjustments.\n+\n+2012-05-02  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.c (valid_constant_size_p): New function.\n+\t* tree.h (valid_constant_size_p): Declare.\n+\t* cfgexpand.c (expand_one_var): Adjust check for too large\n+\tvariables by using valid_constant_size_p.\n+\t* varasm.c (assemble_variable): Likewise.\n+\n+\t* c-decl.c (grokdeclarator): Properly check for sizes that\n+\tcover more than half of the address-space.\n+\n 2012-05-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/53163"}, {"sha": "3153cf4e18364d8e55812c5b0aa0b5833402d7ec", "filename": "gcc/c-decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=56099f00a526f137d24bbf2ac6def05003ebe5c5", "patch": "@@ -5811,12 +5811,12 @@ grokdeclarator (const struct c_declarator *declarator,\n \t}\n     }\n \n-  /* Did array size calculations overflow?  */\n-\n+  /* Did array size calculations overflow or does the array cover more\n+     than half of the address-space?  */\n   if (TREE_CODE (type) == ARRAY_TYPE\n       && COMPLETE_TYPE_P (type)\n       && TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST\n-      && TREE_OVERFLOW (TYPE_SIZE_UNIT (type)))\n+      && ! valid_constant_size_p (TYPE_SIZE_UNIT (type)))\n     {\n       if (name)\n \terror_at (loc, \"size of array %qE is too large\", name);"}, {"sha": "4c27e762df5733ce658fe237b9ae57fde0f304b1", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=56099f00a526f137d24bbf2ac6def05003ebe5c5", "patch": "@@ -1241,8 +1241,9 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n       if (really_expand)\n         expand_one_register_var (origvar);\n     }\n-  else if (!host_integerp (DECL_SIZE_UNIT (var), 1))\n+  else if (! valid_constant_size_p (DECL_SIZE_UNIT (var)))\n     {\n+      /* Reject variables which cover more than half of the address-space.  */\n       if (really_expand)\n \t{\n \t  error (\"size of variable %q+D is too large\", var);"}, {"sha": "6b0e57cedb53add7b352f05e131afc43465197b6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=56099f00a526f137d24bbf2ac6def05003ebe5c5", "patch": "@@ -1,3 +1,8 @@\n+2012-05-02  Richard Guenther  <rguenther@suse.de>\n+\n+\t* decl.c (grokdeclarator): Properly check for sizes that\n+\tcover more than half of the address-space.\n+\n 2012-04-30  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR c++/51033"}, {"sha": "108b51531d4aafcbb1acbea2f694c5e1c7f5c0ec", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=56099f00a526f137d24bbf2ac6def05003ebe5c5", "patch": "@@ -9672,12 +9672,12 @@ grokdeclarator (const cp_declarator *declarator,\n         error (\"non-parameter %qs cannot be a parameter pack\", name);\n     }\n \n-  /* Did array size calculations overflow?  */\n-\n+  /* Did array size calculations overflow or does the array cover more\n+     than half of the address-space?  */\n   if (TREE_CODE (type) == ARRAY_TYPE\n       && COMPLETE_TYPE_P (type)\n       && TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST\n-      && TREE_OVERFLOW (TYPE_SIZE_UNIT (type)))\n+      && ! valid_constant_size_p (TYPE_SIZE_UNIT (type)))\n     {\n       error (\"size of array %qs is too large\", name);\n       /* If we proceed with the array type as it is, we'll eventually"}, {"sha": "fe12942d9811e13faf42c876a6d3b19c404b5ad5", "filename": "gcc/fold-const.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=56099f00a526f137d24bbf2ac6def05003ebe5c5", "patch": "@@ -191,9 +191,6 @@ div_if_zero_remainder (enum tree_code code, const_tree arg1, const_tree arg2)\n      does the correct thing for POINTER_PLUS_EXPR where we want\n      a signed division.  */\n   uns = TYPE_UNSIGNED (TREE_TYPE (arg2));\n-  if (TREE_CODE (TREE_TYPE (arg2)) == INTEGER_TYPE\n-      && TYPE_IS_SIZETYPE (TREE_TYPE (arg2)))\n-    uns = false;\n \n   quo = double_int_divmod (tree_to_double_int (arg1),\n \t\t\t   tree_to_double_int (arg2),\n@@ -935,8 +932,9 @@ int_binop_types_match_p (enum tree_code code, const_tree type1, const_tree type2\n    to produce a new constant.  Return NULL_TREE if we don't know how\n    to evaluate CODE at compile-time.  */\n \n-tree\n-int_const_binop (enum tree_code code, const_tree arg1, const_tree arg2)\n+static tree\n+int_const_binop_1 (enum tree_code code, const_tree arg1, const_tree arg2,\n+\t\t   int overflowable)\n {\n   double_int op1, op2, res, tmp;\n   tree t;\n@@ -1078,13 +1076,19 @@ int_const_binop (enum tree_code code, const_tree arg1, const_tree arg2)\n       return NULL_TREE;\n     }\n \n-  t = force_fit_type_double (TREE_TYPE (arg1), res, 1,\n+  t = force_fit_type_double (TREE_TYPE (arg1), res, overflowable,\n \t\t\t     ((!uns || is_sizetype) && overflow)\n \t\t\t     | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2));\n \n   return t;\n }\n \n+tree\n+int_const_binop (enum tree_code code, const_tree arg1, const_tree arg2)\n+{\n+  return int_const_binop_1 (code, arg1, arg2, 1);\n+}\n+\n /* Combine two constants ARG1 and ARG2 under operation CODE to produce a new\n    constant.  We assume ARG1 and ARG2 have the same data type, or at least\n    are the same kind of constant and the same machine mode.  Return zero if\n@@ -1423,8 +1427,10 @@ size_binop_loc (location_t loc, enum tree_code code, tree arg0, tree arg1)\n \t    return arg1;\n \t}\n \n-      /* Handle general case of two integer constants.  */\n-      return int_const_binop (code, arg0, arg1);\n+      /* Handle general case of two integer constants.  For sizetype\n+         constant calculations we always want to know about overflow,\n+\t even in the unsigned case.  */\n+      return int_const_binop_1 (code, arg0, arg1, -1);\n     }\n \n   return fold_build2_loc (loc, code, type, arg0, arg1);\n@@ -5908,11 +5914,9 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n \t multiple of the other, in which case we replace this with either an\n \t operation or CODE or TCODE.\n \n-\t If we have an unsigned type that is not a sizetype, we cannot do\n-\t this since it will change the result if the original computation\n-\t overflowed.  */\n-      if ((TYPE_OVERFLOW_UNDEFINED (ctype)\n-\t   || (TREE_CODE (ctype) == INTEGER_TYPE && TYPE_IS_SIZETYPE (ctype)))\n+\t If we have an unsigned type, we cannot do this since it will change\n+\t the result if the original computation overflowed.  */\n+      if (TYPE_OVERFLOW_UNDEFINED (ctype)\n \t  && ((code == MULT_EXPR && tcode == EXACT_DIV_EXPR)\n \t      || (tcode == MULT_EXPR\n \t\t  && code != TRUNC_MOD_EXPR && code != CEIL_MOD_EXPR\n@@ -9971,7 +9975,8 @@ fold_binary_loc (location_t loc,\n       if (TREE_CODE (arg0) == ADDR_EXPR)\n \t{\n \t  tem = try_move_mult_to_index (loc, arg0,\n-\t\t\t\t\tfold_convert_loc (loc, sizetype, arg1));\n+\t\t\t\t\tfold_convert_loc (loc,\n+\t\t\t\t\t\t\t  ssizetype, arg1));\n \t  if (tem)\n \t    return fold_convert_loc (loc, type, tem);\n \t}"}, {"sha": "f6b62438dcecebaf8ef2150c831826d95be51421", "filename": "gcc/omp-low.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=56099f00a526f137d24bbf2ac6def05003ebe5c5", "patch": "@@ -336,9 +336,11 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n       switch (TREE_CODE (t))\n \t{\n \tcase PLUS_EXPR:\n-\tcase POINTER_PLUS_EXPR:\n \t  loop->step = TREE_OPERAND (t, 1);\n \t  break;\n+\tcase POINTER_PLUS_EXPR:\n+\t  loop->step = fold_convert (ssizetype, TREE_OPERAND (t, 1));\n+\t  break;\n \tcase MINUS_EXPR:\n \t  loop->step = TREE_OPERAND (t, 1);\n \t  loop->step = fold_build1_loc (loc,"}, {"sha": "12a6c13a6b8d1bf71a57145e71c7beff0ec10b79", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=56099f00a526f137d24bbf2ac6def05003ebe5c5", "patch": "@@ -2182,11 +2182,37 @@ layout_type (tree type)\n \t       that (possible) negative values are handled appropriately\n \t       when determining overflow.  */\n \t    else\n-\t      length\n-\t\t= fold_convert (sizetype,\n-\t\t\t\tsize_binop (PLUS_EXPR,\n-\t\t\t\t\t    build_int_cst (TREE_TYPE (lb), 1),\n-\t\t\t\t\t    size_binop (MINUS_EXPR, ub, lb)));\n+\t      {\n+\t\t/* ???  When it is obvious that the range is signed\n+\t\t   represent it using ssizetype.  */\n+\t\tif (TREE_CODE (lb) == INTEGER_CST\n+\t\t    && TREE_CODE (ub) == INTEGER_CST\n+\t\t    && TYPE_UNSIGNED (TREE_TYPE (lb))\n+\t\t    && tree_int_cst_lt (ub, lb))\n+\t\t  {\n+\t\t    lb = double_int_to_tree\n+\t\t\t   (ssizetype,\n+\t\t\t    double_int_sext (tree_to_double_int (lb),\n+\t\t\t\t\t     TYPE_PRECISION (TREE_TYPE (lb))));\n+\t\t    ub = double_int_to_tree\n+\t\t\t   (ssizetype,\n+\t\t\t    double_int_sext (tree_to_double_int (ub),\n+\t\t\t\t\t     TYPE_PRECISION (TREE_TYPE (ub))));\n+\t\t  }\n+\t\tlength\n+\t\t  = fold_convert (sizetype,\n+\t\t\t\t  size_binop (PLUS_EXPR,\n+\t\t\t\t\t      build_int_cst (TREE_TYPE (lb), 1),\n+\t\t\t\t\t      size_binop (MINUS_EXPR, ub, lb)));\n+\t      }\n+\n+\t    /* If we arrived at a length of zero ignore any overflow\n+\t       that occured as part of the calculation.  There exists\n+\t       an association of the plus one where that overflow would\n+\t       not happen.  */\n+\t    if (integer_zerop (length)\n+\t\t&& TREE_OVERFLOW (length))\n+\t      length = size_zero_node;\n \n \t    TYPE_SIZE (type) = size_binop (MULT_EXPR, element_size,\n \t\t\t\t\t   fold_convert (bitsizetype,\n@@ -2453,11 +2479,6 @@ initialize_sizetypes (void)\n   TYPE_SIZE_UNIT (sizetype) = size_int (GET_MODE_SIZE (TYPE_MODE (sizetype)));\n   set_min_and_max_values_for_integral_type (sizetype, precision,\n \t\t\t\t\t    /*is_unsigned=*/true);\n-  /* sizetype is unsigned but we need to fix TYPE_MAX_VALUE so that it is\n-     sign-extended in a way consistent with force_fit_type.  */\n-  TYPE_MAX_VALUE (sizetype)\n-    = double_int_to_tree (sizetype,\n-\t\t\t  tree_to_double_int (TYPE_MAX_VALUE (sizetype)));\n \n   SET_TYPE_MODE (bitsizetype, smallest_mode_for_size (bprecision, MODE_INT));\n   TYPE_ALIGN (bitsizetype) = GET_MODE_ALIGNMENT (TYPE_MODE (bitsizetype));\n@@ -2466,11 +2487,6 @@ initialize_sizetypes (void)\n     = size_int (GET_MODE_SIZE (TYPE_MODE (bitsizetype)));\n   set_min_and_max_values_for_integral_type (bitsizetype, bprecision,\n \t\t\t\t\t    /*is_unsigned=*/true);\n-  /* bitsizetype is unsigned but we need to fix TYPE_MAX_VALUE so that it is\n-     sign-extended in a way consistent with force_fit_type.  */\n-  TYPE_MAX_VALUE (bitsizetype)\n-    = double_int_to_tree (bitsizetype,\n-\t\t\t  tree_to_double_int (TYPE_MAX_VALUE (bitsizetype)));\n \n   /* Create the signed variants of *sizetype.  */\n   ssizetype = make_signed_type (TYPE_PRECISION (sizetype));"}, {"sha": "95650152046199a584ae54c81c5845b700df439a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=56099f00a526f137d24bbf2ac6def05003ebe5c5", "patch": "@@ -1,3 +1,7 @@\n+2012-05-02  Richard Guenther  <rguenther@suse.de>\n+\n+\t* g++.dg/tree-ssa/pr19807.C: Adjust.\n+\n 2012-05-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/53163"}, {"sha": "0eeeb18abda5c85e3dee7fed90e52a954e11c2d1", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr19807.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr19807.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr19807.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr19807.C?ref=56099f00a526f137d24bbf2ac6def05003ebe5c5", "patch": "@@ -25,6 +25,6 @@ void bar(int i)\n    Simply test for the existence of +1 and -1 once, which also ensures\n    the above.  If the addition/subtraction would be applied to the\n    pointer we would instead see +-4 (or 8, depending on sizeof(int)).  */\n-/* { dg-final { scan-tree-dump-times \"\\\\\\+ -1;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"\\\\\\+ (0x0f*|18446744073709551615|4294967295|-1);\" \"optimized\" } } */\n /* { dg-final { scan-tree-dump-times \"\\\\\\+ 1;\" 1 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "1257b8bf7ba2680eab4fda060e0c86a7b78832aa", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=56099f00a526f137d24bbf2ac6def05003ebe5c5", "patch": "@@ -1101,14 +1101,12 @@ bit_value_unop_1 (enum tree_code code, tree type,\n \tbool uns;\n \n \t/* First extend mask and value according to the original type.  */\n-\tuns = (TREE_CODE (rtype) == INTEGER_TYPE && TYPE_IS_SIZETYPE (rtype)\n-\t       ? 0 : TYPE_UNSIGNED (rtype));\n+\tuns = TYPE_UNSIGNED (rtype);\n \t*mask = double_int_ext (rmask, TYPE_PRECISION (rtype), uns);\n \t*val = double_int_ext (rval, TYPE_PRECISION (rtype), uns);\n \n \t/* Then extend mask and value according to the target type.  */\n-\tuns = (TREE_CODE (type) == INTEGER_TYPE && TYPE_IS_SIZETYPE (type)\n-\t       ? 0 : TYPE_UNSIGNED (type));\n+\tuns = TYPE_UNSIGNED (type);\n \t*mask = double_int_ext (*mask, TYPE_PRECISION (type), uns);\n \t*val = double_int_ext (*val, TYPE_PRECISION (type), uns);\n \tbreak;\n@@ -1130,8 +1128,7 @@ bit_value_binop_1 (enum tree_code code, tree type,\n \t\t   tree r1type, double_int r1val, double_int r1mask,\n \t\t   tree r2type, double_int r2val, double_int r2mask)\n {\n-  bool uns = (TREE_CODE (type) == INTEGER_TYPE\n-\t      && TYPE_IS_SIZETYPE (type) ? 0 : TYPE_UNSIGNED (type));\n+  bool uns = TYPE_UNSIGNED (type);\n   /* Assume we'll get a constant result.  Use an initial varying value,\n      we fall back to varying in the end if necessary.  */\n   *mask = double_int_minus_one;\n@@ -1198,13 +1195,6 @@ bit_value_binop_1 (enum tree_code code, tree type,\n \t    }\n \t  else if (shift < 0)\n \t    {\n-\t      /* ???  We can have sizetype related inconsistencies in\n-\t\t the IL.  */\n-\t      if ((TREE_CODE (r1type) == INTEGER_TYPE\n-\t\t   && (TYPE_IS_SIZETYPE (r1type)\n-\t\t       ? 0 : TYPE_UNSIGNED (r1type))) != uns)\n-\t\tbreak;\n-\n \t      shift = -shift;\n \t      *mask = double_int_rshift (r1mask, shift,\n \t\t\t\t\t TYPE_PRECISION (type), !uns);\n@@ -1316,12 +1306,7 @@ bit_value_binop_1 (enum tree_code code, tree type,\n \t  break;\n \n \t/* For comparisons the signedness is in the comparison operands.  */\n-\tuns = (TREE_CODE (r1type) == INTEGER_TYPE\n-\t       && TYPE_IS_SIZETYPE (r1type) ? 0 : TYPE_UNSIGNED (r1type));\n-\t/* ???  We can have sizetype related inconsistencies in the IL.  */\n-\tif ((TREE_CODE (r2type) == INTEGER_TYPE\n-\t     && TYPE_IS_SIZETYPE (r2type) ? 0 : TYPE_UNSIGNED (r2type)) != uns)\n-\t  break;\n+\tuns = TYPE_UNSIGNED (r1type);\n \n \t/* If we know the most significant bits we know the values\n \t   value ranges by means of treating varying bits as zero"}, {"sha": "1ee3f1db51e4a7a67f60bc65b3750e3cb15486c9", "filename": "gcc/tree.c", "status": "modified", "additions": 18, "deletions": 33, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=56099f00a526f137d24bbf2ac6def05003ebe5c5", "patch": "@@ -1062,10 +1062,7 @@ build_int_cst_type (tree type, HOST_WIDE_INT low)\n tree\n double_int_to_tree (tree type, double_int cst)\n {\n-  /* Size types *are* sign extended.  */\n-  bool sign_extended_type = (!TYPE_UNSIGNED (type)\n-\t\t\t     || (TREE_CODE (type) == INTEGER_TYPE\n-\t\t\t\t && TYPE_IS_SIZETYPE (type)));\n+  bool sign_extended_type = !TYPE_UNSIGNED (type);\n \n   cst = double_int_ext (cst, TYPE_PRECISION (type), !sign_extended_type);\n \n@@ -1079,9 +1076,7 @@ bool\n double_int_fits_to_tree_p (const_tree type, double_int cst)\n {\n   /* Size types *are* sign extended.  */\n-  bool sign_extended_type = (!TYPE_UNSIGNED (type)\n-\t\t\t     || (TREE_CODE (type) == INTEGER_TYPE\n-\t\t\t\t && TYPE_IS_SIZETYPE (type)));\n+  bool sign_extended_type = !TYPE_UNSIGNED (type);\n \n   double_int ext\n     = double_int_ext (cst, TYPE_PRECISION (type), !sign_extended_type);\n@@ -1111,9 +1106,7 @@ force_fit_type_double (tree type, double_int cst, int overflowable,\n   bool sign_extended_type;\n \n   /* Size types *are* sign extended.  */\n-  sign_extended_type = (!TYPE_UNSIGNED (type)\n-                        || (TREE_CODE (type) == INTEGER_TYPE\n-                            && TYPE_IS_SIZETYPE (type)));\n+  sign_extended_type = !TYPE_UNSIGNED (type);\n \n   /* If we need to set overflow flags, return a new unshared node.  */\n   if (overflowed || !double_int_fits_to_tree_p(type, cst))\n@@ -6553,9 +6546,7 @@ host_integerp (const_tree t, int pos)\n \t       && (HOST_WIDE_INT) TREE_INT_CST_LOW (t) >= 0)\n \t      || (! pos && TREE_INT_CST_HIGH (t) == -1\n \t\t  && (HOST_WIDE_INT) TREE_INT_CST_LOW (t) < 0\n-\t\t  && (!TYPE_UNSIGNED (TREE_TYPE (t))\n-\t\t      || (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE\n-\t\t\t  && TYPE_IS_SIZETYPE (TREE_TYPE (t)))))\n+\t\t  && !TYPE_UNSIGNED (TREE_TYPE (t)))\n \t      || (pos && TREE_INT_CST_HIGH (t) == 0)));\n }\n \n@@ -6850,6 +6841,20 @@ compare_tree_int (const_tree t, unsigned HOST_WIDE_INT u)\n     return 1;\n }\n \n+/* Return true if SIZE represents a constant size that is in bounds of\n+   what the middle-end and the backend accepts (covering not more than\n+   half of the address-space).  */\n+\n+bool\n+valid_constant_size_p (const_tree size)\n+{\n+  if (! host_integerp (size, 1)\n+      || TREE_OVERFLOW (size)\n+      || tree_int_cst_sign_bit (size) != 0)\n+    return false;\n+  return true;\n+}\n+\n /* Return true if CODE represents an associative tree code.  Otherwise\n    return false.  */\n bool\n@@ -8276,18 +8281,6 @@ int_fits_type_p (const_tree c, const_tree type)\n   dc = tree_to_double_int (c);\n   unsc = TYPE_UNSIGNED (TREE_TYPE (c));\n \n-  if (TREE_CODE (TREE_TYPE (c)) == INTEGER_TYPE\n-      && TYPE_IS_SIZETYPE (TREE_TYPE (c))\n-      && unsc)\n-    /* So c is an unsigned integer whose type is sizetype and type is not.\n-       sizetype'd integers are sign extended even though they are\n-       unsigned. If the integer value fits in the lower end word of c,\n-       and if the higher end word has all its bits set to 1, that\n-       means the higher end bits are set to 1 only for sign extension.\n-       So let's convert c into an equivalent zero extended unsigned\n-       integer.  */\n-    dc = double_int_zext (dc, TYPE_PRECISION (TREE_TYPE (c)));\n-\n retry:\n   type_low_bound = TYPE_MIN_VALUE (type);\n   type_high_bound = TYPE_MAX_VALUE (type);\n@@ -8306,10 +8299,6 @@ int_fits_type_p (const_tree c, const_tree type)\n   if (type_low_bound && TREE_CODE (type_low_bound) == INTEGER_CST)\n     {\n       dd = tree_to_double_int (type_low_bound);\n-      if (TREE_CODE (type) == INTEGER_TYPE\n-\t  && TYPE_IS_SIZETYPE (type)\n-\t  && TYPE_UNSIGNED (type))\n-\tdd = double_int_zext (dd, TYPE_PRECISION (type));\n       if (unsc != TYPE_UNSIGNED (TREE_TYPE (type_low_bound)))\n \t{\n \t  int c_neg = (!unsc && double_int_negative_p (dc));\n@@ -8331,10 +8320,6 @@ int_fits_type_p (const_tree c, const_tree type)\n   if (type_high_bound && TREE_CODE (type_high_bound) == INTEGER_CST)\n     {\n       dd = tree_to_double_int (type_high_bound);\n-      if (TREE_CODE (type) == INTEGER_TYPE\n-\t  && TYPE_IS_SIZETYPE (type)\n-\t  && TYPE_UNSIGNED (type))\n-\tdd = double_int_zext (dd, TYPE_PRECISION (type));\n       if (unsc != TYPE_UNSIGNED (TREE_TYPE (type_high_bound)))\n \t{\n \t  int c_neg = (!unsc && double_int_negative_p (dc));"}, {"sha": "3d7fcabe142f0a975bac974585f6c1470601f6ef", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=56099f00a526f137d24bbf2ac6def05003ebe5c5", "patch": "@@ -4451,6 +4451,7 @@ extern bool tree_expr_nonnegative_warnv_p (tree, bool *);\n extern bool may_negate_without_overflow_p (const_tree);\n extern tree strip_array_types (tree);\n extern tree excess_precision_type (tree);\n+extern bool valid_constant_size_p (const_tree);\n \n /* Construct various nodes representing fract or accum data types.  */\n "}, {"sha": "ce9e328036492229c527cee4f17d404e772f5356", "filename": "gcc/varasm.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56099f00a526f137d24bbf2ac6def05003ebe5c5/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=56099f00a526f137d24bbf2ac6def05003ebe5c5", "patch": "@@ -1992,7 +1992,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n     return;\n \n   if (! dont_output_data\n-      && ! host_integerp (DECL_SIZE_UNIT (decl), 1))\n+      && ! valid_constant_size_p (DECL_SIZE_UNIT (decl)))\n     {\n       error (\"size of variable %q+D is too large\", decl);\n       return;\n@@ -4773,9 +4773,13 @@ output_constructor_regular_field (oc_local_state *local)\n \n   if (local->index != NULL_TREE)\n     {\n+      /* Perform the index calculation in modulo arithmetic but\n+\t sign-extend the result because Ada has negative DECL_FIELD_OFFSETs\n+\t but we are using an unsigned sizetype.  */\n+      unsigned prec = TYPE_PRECISION (sizetype);\n       double_int idx = double_int_sub (tree_to_double_int (local->index),\n \t\t\t\t       tree_to_double_int (local->min_index));\n-      gcc_assert (double_int_fits_in_shwi_p (idx));\n+      idx = double_int_sext (idx, prec);\n       fieldpos = (tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (local->val)), 1)\n \t\t  * idx.low);\n     }"}]}