{"sha": "7e4d78983814fad9db308ee7d2ee7d37b474a6aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U0ZDc4OTgzODE0ZmFkOWRiMzA4ZWU3ZDJlZTdkMzdiNDc0YTZhYQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@codesourcery.com", "date": "2000-01-19T11:34:03Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2000-01-19T11:34:03Z"}, "message": "decl2.c (lang_decode_option): Set default line-wrap length to 72.\n\n2000-01-19  Gabriel Dos Reis  <gdr@codesourcery>\n\n        * decl2.c (lang_decode_option): Set default line-wrap length to 72.\n\n        * typeck.c (composite_pointer_type, common_type,\n        comp_target_parms, c_sizeof, expr_sizeof, build_array_ref,\n        build_function_call_real, convert_arguments,\n        build_binary_op_nodefault, pointer_int_sum, pointer_diff,\n        build_unary_op, mark_addressable, build_compound_expr,\n        build_static_cast, build_reinterpret_cast, build_const_cast,\n        build_c_cast, build_modify_expr, get_delta_difference,\n        build_ptrmemfunc, check_return_expr): Replace 'ANSI C++' with\n        'ISO C++'.  Fusion consecutive calls to diagnotic message routines\n        into a single one.\n        * typeck2.c (readonly_error, abstract_virtuals_error,\n        process_init_constructor, check_for_new_type): Likewise.\n\nFrom-SVN: r31502", "tree": {"sha": "39d690fa49b58adbe5cc191ca1489e019ef30672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39d690fa49b58adbe5cc191ca1489e019ef30672"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e4d78983814fad9db308ee7d2ee7d37b474a6aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e4d78983814fad9db308ee7d2ee7d37b474a6aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e4d78983814fad9db308ee7d2ee7d37b474a6aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e4d78983814fad9db308ee7d2ee7d37b474a6aa/comments", "author": null, "committer": null, "parents": [{"sha": "cfef86e454ad355db3353810ae981bf6a646a04b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfef86e454ad355db3353810ae981bf6a646a04b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfef86e454ad355db3353810ae981bf6a646a04b"}], "stats": {"total": 205, "additions": 110, "deletions": 95}, "files": [{"sha": "10efd25acc4fdb1acdde7fe33bd6fde7f01a6af4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4d78983814fad9db308ee7d2ee7d37b474a6aa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4d78983814fad9db308ee7d2ee7d37b474a6aa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7e4d78983814fad9db308ee7d2ee7d37b474a6aa", "patch": "@@ -1,3 +1,20 @@\n+2000-01-19  Gabriel Dos Reis  <gdr@codesourcery>\n+\n+\t* decl2.c (lang_decode_option): Set default line-wrap length to 72.\n+\t\n+\t* typeck.c (composite_pointer_type, common_type,\n+\tcomp_target_parms, c_sizeof, expr_sizeof, build_array_ref,\n+\tbuild_function_call_real, convert_arguments,\n+\tbuild_binary_op_nodefault, pointer_int_sum, pointer_diff,\n+\tbuild_unary_op, mark_addressable, build_compound_expr,\n+\tbuild_static_cast, build_reinterpret_cast, build_const_cast,\n+\tbuild_c_cast, build_modify_expr, get_delta_difference,\n+\tbuild_ptrmemfunc, check_return_expr): Replace 'ANSI C++' with \n+\t'ISO C++'.  Fusion consecutive calls to diagnotic message routines\n+\tinto a single one.\n+\t* typeck2.c (readonly_error, abstract_virtuals_error,\n+\tprocess_init_constructor, check_for_new_type): Likewise.\n+\n 2000-01-19  Mark Mitchell  <mark@codesourcery.com>\n \n \t* tree.c (bot_manip): Set DECL_CONTEXT for newly created"}, {"sha": "69b302a3c26f160a31c56551a1bdaf9a0b6422f6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4d78983814fad9db308ee7d2ee7d37b474a6aa/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4d78983814fad9db308ee7d2ee7d37b474a6aa/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=7e4d78983814fad9db308ee7d2ee7d37b474a6aa", "patch": "@@ -633,7 +633,9 @@ lang_decode_option (argc, argv)\n \tname_mangling_version \n \t  = read_integral_parameter (p + 22, p - 2, name_mangling_version);\n       else if (!strncmp (p, \"message-length=\", 15))\n-          set_message_length (read_integral_parameter (p + 15, p -2, 0));\n+          set_message_length\n+              (read_integral_parameter (p + 15, p -2,\n+                                        /* default line-wrap length */ 72));\n       else if (!strncmp (p, \"dump-translation-unit-\", 22))\n \t{\n \t  if (p[22] == '\\0')"}, {"sha": "0acd391016cd1e8b1e0a8c03e42dffabd2a0a129", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 82, "deletions": 86, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4d78983814fad9db308ee7d2ee7d37b474a6aa/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4d78983814fad9db308ee7d2ee7d37b474a6aa/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=7e4d78983814fad9db308ee7d2ee7d37b474a6aa", "patch": "@@ -452,15 +452,15 @@ composite_pointer_type (t1, t2, arg1, arg2, location)\n   else if (TYPE_MAIN_VARIANT (TREE_TYPE (t1)) == void_type_node)\n     {\n       if (pedantic && TREE_CODE (t2) == FUNCTION_TYPE)\n-\tpedwarn (\"ANSI C++ forbids %s between `void *' and function pointer\",\n-\t\t location);\n+\tpedwarn (\"ISO C++ forbids %s between pointer of type `void *'\"\n+                 \" and pointer-to-function\", location);\n       result_type = qualify_type (t1, t2);\n     }\n   else if (TYPE_MAIN_VARIANT (TREE_TYPE (t2)) == void_type_node)\n     {\n       if (pedantic && TREE_CODE (t1) == FUNCTION_TYPE)\n-\tpedwarn (\"ANSI C++ forbids %s between `void *' and function pointer\",\n-\t\t location);\n+\tpedwarn (\"ISO C++ forbids %s between pointer of type `void *'\"\n+                 \" and pointer-to-function\", location);\n       result_type = qualify_type (t2, t1);\n     }\n   /* C++ */\n@@ -482,7 +482,7 @@ composite_pointer_type (t1, t2, arg1, arg2, location)\n \t  if (pedantic\n \t      && result_type != TREE_TYPE (t1)\n \t      && result_type != TREE_TYPE (t2))\n-\t    cp_pedwarn (\"`%T' and `%T' converted to `%T *' in %s\",\n+\t    cp_pedwarn (\"types `%T' and `%T' converted to `%T *' in %s\",\n \t\t\tt1, t2, result_type, location);\n \t  \n \t  result_type = build_pointer_type (result_type);\n@@ -583,7 +583,7 @@ common_type (t1, t2)\n       /* For two pointers, do this recursively on the target type,\n \t and combine the qualifiers of the two types' targets.  */\n       /* This code was turned off; I don't know why.\n- \t But ANSI C++ specifies doing this with the qualifiers.\n+ \t But ISO C++ specifies doing this with the qualifiers.\n  \t So I turned it on again.  */\n       {\n \ttree tt1 = TREE_TYPE (t1);\n@@ -1466,7 +1466,7 @@ comp_target_parms (parms1, parms2, strict)\n \t   declared to take (), which we fudged to (...).  Don't make the\n \t   user pay for our mistake.  */;\n       else\n-\tcp_pedwarn (\"ANSI C++ prohibits conversion from `%#T' to `(...)'\",\n+\tcp_pedwarn (\"ISO C++ prohibits conversion from `%#T' to `(...)'\",\n \t\t    parms2);\n       return self_promoting_args_p (t2);\n     }\n@@ -1548,19 +1548,20 @@ c_sizeof (type)\n   if (code == FUNCTION_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"ANSI C++ forbids taking the sizeof a function type\");\n+\tpedwarn (\"ISO C++ forbids applying `sizeof' to a function type\");\n       return size_int (1);\n     }\n   if (code == METHOD_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"ANSI C++ forbids taking the sizeof a method type\");\n+\tpedwarn (\"ISO C++ forbids applying `sizeof' to a member function\");\n       return size_int (1);\n     }\n   if (code == VOID_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"ANSI C++ forbids taking the sizeof a void type\");\n+\tpedwarn (\"ISO C++ forbids applying `sizeof' to type `void' which is\"\n+                 \" an incomplete type\");\n       return size_int (1);\n     }\n   if (code == ERROR_MARK)\n@@ -1605,7 +1606,8 @@ expr_sizeof (e)\n     error (\"sizeof applied to a bit-field\");\n   if (is_overloaded_fn (e))\n     {\n-      pedwarn (\"ANSI C++ forbids taking the sizeof a function type\");\n+      pedwarn (\"ISO C++ forbids applying `sizeof' to an expression\"\n+               \" of function type\");\n       return size_int (1);\n     }\n   else if (type_unknown_p (e))\n@@ -2458,7 +2460,7 @@ build_array_ref (array, idx)\n \t}\n \n       if (pedantic && !lvalue_p (array))\n-\tpedwarn (\"ANSI C++ forbids subscripting non-lvalue array\");\n+\tpedwarn (\"ISO C++ forbids subscripting non-lvalue array\");\n \n       /* Note in C++ it is valid to subscript a `register' array, since\n \t it is valid to take the address of something with that\n@@ -2947,7 +2949,7 @@ build_function_call_real (function, params, require_complete, flags)\n \n       /* Convert anything with function type to a pointer-to-function.  */\n       if (pedantic && DECL_MAIN_P (function))\n-\tpedwarn (\"ANSI C++ forbids calling `main' from within program\");\n+\tpedwarn (\"ISO C++ forbids calling `::main' from within program\");\n \n       /* Differs from default_conversion by not setting TREE_ADDRESSABLE\n \t (because calling an inline function does not mean the function\n@@ -3118,11 +3120,8 @@ convert_arguments (typelist, values, fndecl, flags)\n       if (type == void_type_node)\n \t{\n \t  if (fndecl)\n-\t    {\n-\t      cp_error_at (\"too many arguments to %s `%+#D'\", called_thing,\n-\t\t\t   fndecl);\n-\t      error (\"at this point in file\");\n-\t    }\n+            cp_error_at (\"too many arguments to %s `%+#D' at this point\",\n+                         called_thing, fndecl);\n \t  else\n \t    error (\"too many arguments to function\");\n \t  /* In case anybody wants to know if this argument\n@@ -3220,11 +3219,8 @@ convert_arguments (typelist, values, fndecl, flags)\n       else\n \t{\n \t  if (fndecl)\n-\t    {\n-\t      cp_error_at (\"too few arguments to %s `%+#D'\",\n-\t                   called_thing, fndecl);\n-\t      error (\"at this point in file\");\n-\t    }\n+            cp_error_at (\"too few arguments to %s `%+#D' at this point\",\n+                         called_thing, fndecl);\n \t  else\n \t    error (\"too few arguments to function\");\n \t  return error_mark_list;\n@@ -3353,7 +3349,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n       tree t = instantiate_type (TREE_TYPE (op1), op0, 0);\n       if (t != error_mark_node)\n \t{\n-\t  cp_pedwarn (\"assuming cast to `%T' from overloaded function\",\n+\t  cp_pedwarn (\"assuming cast to type `%T' from overloaded function\",\n \t\t      TREE_TYPE (t));\n \t  op0 = t;\n \t}\n@@ -3363,7 +3359,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n       tree t = instantiate_type (TREE_TYPE (op0), op1, 0);\n       if (t != error_mark_node)\n \t{\n-\t  cp_pedwarn (\"assuming cast to `%T' from overloaded function\",\n+\t  cp_pedwarn (\"assuming cast to type `%T' from overloaded function\",\n \t\t      TREE_TYPE (t));\n \t  op1 = t;\n \t}\n@@ -3604,15 +3600,15 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t    {\n \t      if (pedantic && TREE_CODE (tt1) == FUNCTION_TYPE\n \t\t  && tree_int_cst_lt (TYPE_SIZE (type0), TYPE_SIZE (type1)))\n-\t\tpedwarn (\"ANSI C++ forbids comparison of `void *' with function pointer\");\n+\t\tpedwarn (\"ISO C++ forbids comparison of `void *' with function pointer\");\n \t      else if (TREE_CODE (tt1) == OFFSET_TYPE)\n-\t\tpedwarn (\"ANSI C++ forbids conversion of a pointer to member to `void *'\");\n+\t\tpedwarn (\"ISO C++ forbids conversion of a pointer to member to `void *'\");\n \t    }\n \t  else if (tt1 == void_type_node)\n \t    {\n \t      if (pedantic && TREE_CODE (tt0) == FUNCTION_TYPE\n \t\t  && tree_int_cst_lt (TYPE_SIZE (type1), TYPE_SIZE (type0)))\n-\t\tpedwarn (\"ANSI C++ forbids comparison of `void *' with function pointer\");\n+\t\tpedwarn (\"ISO C++ forbids comparison of `void *' with function pointer\");\n \t    }\n \t  else\n \t    cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n@@ -3628,12 +3624,12 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  result_type = type0;\n-\t  error (\"ANSI C++ forbids comparison between pointer and integer\");\n+\t  error (\"ISO C++ forbids comparison between pointer and integer\");\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n-\t  error (\"ANSI C++ forbids comparison between pointer and integer\");\n+\t  error (\"ISO C++ forbids comparison between pointer and integer\");\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type0) && null_ptr_cst_p (op1))\n \t{\n@@ -3781,12 +3777,12 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  result_type = type0;\n-\t  pedwarn (\"ANSI C++ forbids comparison between pointer and integer\");\n+\t  pedwarn (\"ISO C++ forbids comparison between pointer and integer\");\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n-\t  pedwarn (\"ANSI C++ forbids comparison between pointer and integer\");\n+\t  pedwarn (\"ISO C++ forbids comparison between pointer and integer\");\n \t}\n       break;\n \n@@ -3950,7 +3946,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t      && TYPE_MAIN_VARIANT (TREE_TYPE (orig_op0))\n \t         != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1)))\n \t    {\n-\t      cp_warning (\"comparison between `%#T' and `%#T'\", \n+\t      cp_warning (\"comparison between types `%#T' and `%#T'\", \n \t\t\t  TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n \t    }\n \n@@ -3987,7 +3983,8 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t\t\t\t\t\tsigned_type (result_type)))))\n \t    /* OK */;\n \t  else\n-\t    warning (\"comparison between signed and unsigned\");\n+\t    warning (\"comparison between a signed and an unsigned\"\n+                     \" integer expressions\");\n \n \t  /* Warn if two unsigned values are being compared in a size\n \t     larger than their original size, and one (and only one) is the\n@@ -4053,7 +4050,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \n   if (!result_type)\n     {\n-      cp_error (\"invalid operands `%T' and `%T' to binary `%O'\",\n+      cp_error (\"invalid operands of types `%T' and `%T' to binary `%O'\",\n \t\tTREE_TYPE (orig_op0), TREE_TYPE (orig_op1), error_code);\n       return error_mark_node;\n     }\n@@ -4127,25 +4124,25 @@ pointer_int_sum (resultcode, ptrop, intop)\n   if (TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"ANSI C++ forbids using pointer of type `void *' in arithmetic\");\n+\tpedwarn (\"ISO C++ forbids using pointer of type `void *' in pointer arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == FUNCTION_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"ANSI C++ forbids using pointer to a function in arithmetic\");\n+\tpedwarn (\"ISO C++ forbids using a pointer-to-function in pointer arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == METHOD_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"ANSI C++ forbids using pointer to a method in arithmetic\");\n+\tpedwarn (\"ISO C++ forbids using a pointer to member function in pointer arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == OFFSET_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"ANSI C++ forbids using pointer to a member in arithmetic\");\n+\tpedwarn (\"ISO C++ forbids using pointer to a member in pointer arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else\n@@ -4218,13 +4215,13 @@ pointer_diff (op0, op1, ptrtype)\n   if (pedantic || warn_pointer_arith)\n     {\n       if (TREE_CODE (target_type) == VOID_TYPE)\n-\tpedwarn (\"ANSI C++ forbids using pointer of type `void *' in subtraction\");\n+\tpedwarn (\"ISO C++ forbids using pointer of type `void *' in subtraction\");\n       if (TREE_CODE (target_type) == FUNCTION_TYPE)\n-\tpedwarn (\"ANSI C++ forbids using pointer to a function in subtraction\");\n+\tpedwarn (\"ISO C++ forbids using pointer to a function in subtraction\");\n       if (TREE_CODE (target_type) == METHOD_TYPE)\n-\tpedwarn (\"ANSI C++ forbids using pointer to a method in subtraction\");\n+\tpedwarn (\"ISO C++ forbids using pointer to a method in subtraction\");\n       if (TREE_CODE (target_type) == OFFSET_TYPE)\n-\tpedwarn (\"ANSI C++ forbids using pointer to a member in subtraction\");\n+\tpedwarn (\"ISO C++ forbids using pointer to a member in subtraction\");\n     }\n \n   /* First do the subtraction as integers;\n@@ -4235,7 +4232,7 @@ pointer_diff (op0, op1, ptrtype)\n \n   /* This generates an error if op1 is a pointer to an incomplete type.  */\n   if (TYPE_SIZE (TREE_TYPE (TREE_TYPE (op1))) == 0)\n-    error (\"arithmetic on pointer to an incomplete type\");\n+    error (\"invalid use of a pointer to an incomplete type in pointer arithmetic\");\n \n   op1 = ((TREE_CODE (target_type) == VOID_TYPE\n \t  || TREE_CODE (target_type) == FUNCTION_TYPE\n@@ -4520,7 +4517,7 @@ build_unary_op (code, xarg, noconvert)\n \n \t/* ARM $5.2.5 last annotation says this should be forbidden.  */\n \tif (TREE_CODE (argtype) == ENUMERAL_TYPE)\n-\t  pedwarn (\"ANSI C++ forbids %sing an enum\",\n+\t  pedwarn (\"ISO C++ forbids %sing an enum\",\n \t\t   (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n \t\t   ? \"increment\" : \"decrement\");\n \t    \n@@ -4537,7 +4534,7 @@ build_unary_op (code, xarg, noconvert)\n \t    else if ((pedantic || warn_pointer_arith)\n \t\t     && (tmp == FUNCTION_TYPE || tmp == METHOD_TYPE\n \t\t\t || tmp == VOID_TYPE || tmp == OFFSET_TYPE))\n-\t      cp_pedwarn (\"ANSI C++ forbids %sing a pointer of type `%T'\",\n+\t      cp_pedwarn (\"ISO C++ forbids %sing a pointer of type `%T'\",\n \t\t\t  ((code == PREINCREMENT_EXPR\n \t\t\t    || code == POSTINCREMENT_EXPR)\n \t\t\t   ? \"increment\" : \"decrement\"), argtype);\n@@ -4640,7 +4637,7 @@ build_unary_op (code, xarg, noconvert)\n \t}\n       else if (pedantic && DECL_MAIN_P (arg))\n \t/* ARM $3.4 */\n-\tpedwarn (\"taking address of function `main'\");\n+\tpedwarn (\"ISO C++ forbids taking address of function `::main'\");\n \n       /* Let &* cancel out to simplify resulting code.  */\n       if (TREE_CODE (arg) == INDIRECT_REF)\n@@ -4704,13 +4701,13 @@ build_unary_op (code, xarg, noconvert)\n \t      if (current_class_type\n \t\t  && TREE_OPERAND (arg, 0) == current_class_ref)\n \t\t/* An expression like &memfn.  */\n-\t\tpedwarn (\"taking the address of a non-static member function\");\n+\t\tpedwarn (\"ISO C++ forbids taking the address of a\"\n+                         \" non-static member function to form a pointer\"\n+                         \" to member function.  Say `&%T::%D'\", base, name);\n \t      else\n-\t\tpedwarn (\"taking the address of a bound member function\");\n-\n-\t      cp_pedwarn\n-\t\t(\"  to form a pointer to member function, say `&%T::%D'\",\n-\t\t base, name);\n+\t\tpedwarn (\"ISO C++ forbids taking the address of a bound\"\n+                         \" member function to form a pointer to member\"\n+                         \" function\", base, name);\n \t    }\n \n \t  arg = build_offset_ref (base, name);\n@@ -4735,7 +4732,8 @@ build_unary_op (code, xarg, noconvert)\n \tcase FIX_ROUND_EXPR:\n \tcase FIX_CEIL_EXPR:\n \t  if (! lvalue_p (arg) && pedantic)\n-\t    pedwarn (\"taking the address of a cast to non-reference type\");\n+\t    pedwarn (\"ISO C++ forbids taking the address of a cast to a \"\n+                     \"non-lvalue expression\");\n \t  break;\n \t  \n \tdefault:\n@@ -4973,7 +4971,7 @@ mark_addressable (exp)\n \tif (x == current_class_ptr)\n \t  {\n \t    if (! flag_this_is_variable)\n-\t      error (\"address of `this' not available\");\n+\t      error (\"cannot take the address of `this', which is an ravlue expression\");\n \t    TREE_ADDRESSABLE (x) = 1; /* so compiler doesn't die later */\n \t    put_var_into_stack (x);\n \t    return 1;\n@@ -5121,7 +5119,7 @@ build_compound_expr (list)\n     }\n \n   first = TREE_VALUE (list);\n-  first = convert_to_void (first, \"lhs of comma\");\n+  first = convert_to_void (first, \"left-hand operand of comma\");\n   if (first == error_mark_node)\n     return error_mark_node;\n   \n@@ -5220,15 +5218,15 @@ build_static_cast (type, expr)\n      constness.  */\n   if (ok && casts_away_constness (intype, type))\n     {\n-      cp_error (\"static_cast from `%T' to `%T' casts away constness\",\n+      cp_error (\"static_cast from type `%T' to type `%T' casts away constness\",\n \t\tintype, type);\n       return error_mark_node;\n     }\n \n   if (ok)\n     return build_c_cast (type, expr);\n \n-  cp_error (\"static_cast from `%T' to `%T'\", intype, type);\n+  cp_error (\"invalid static_cast from type `%T' to type `%T'\", intype, type);\n   return error_mark_node;\n }\n \n@@ -5267,7 +5265,8 @@ build_reinterpret_cast (type, expr)\n     {\n       if (! real_lvalue_p (expr))\n \t{\n-\t  cp_error (\"reinterpret_cast from `%T' rvalue to `%T'\", intype, type);\n+\t  cp_error (\"invalid reinterpret_cast of an rvalue expression of type\"\n+                    \" `%T' to type `%T'\", intype, type);\n \t  return error_mark_node;\n \t}\n       expr = build_unary_op (ADDR_EXPR, expr, 0);\n@@ -5312,14 +5311,15 @@ build_reinterpret_cast (type, expr)\n   else if ((TYPE_PTRFN_P (type) && TYPE_PTROBV_P (intype))\n \t   || (TYPE_PTRFN_P (intype) && TYPE_PTROBV_P (type)))\n     {\n-      pedwarn (\"ANSI C++ forbids casting between pointers to functions and objects\");\n+      pedwarn (\"ISO C++ forbids casting between pointer-to-function and pointer-to-object\");\n       if (TREE_READONLY_DECL_P (expr))\n \texpr = decl_constant_value (expr);\n       return fold (build1 (NOP_EXPR, type, expr));\n     }\n   else\n     {\n-      cp_error (\"reinterpret_cast from `%T' to `%T'\", intype, type);\n+      cp_error (\"invalid reinterpret_cast from type `%T' to type `%T'\",\n+                intype, type);\n       return error_mark_node;\n     }\n       \n@@ -5345,16 +5345,12 @@ build_const_cast (type, expr)\n     }\n \n   if (!POINTER_TYPE_P (type))\n-    {\n-      cp_error (\"`%T' is not a pointer, reference, or pointer-to-data-member type\",\n-\t\ttype);\n-      cp_error (\"as required by const_cast\");\n-    }\n+    cp_error (\"invalid use of const_cast with type `%T', which is not a\"\n+              \" pointer, reference, nor a pointer-to-data-member type\", type);\n   else if (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n     {\n-      cp_error (\"`%T' is a pointer or reference to a function type\",\n-\t\ttype);\n-      cp_error (\"which is forbidden by const_cast\");\n+      cp_error (\"invalid use of const_cast with type `%T', which is a pointer\"\n+                \" or reference to a function type\", type);\n       return error_mark_node;\n     }\n \n@@ -5377,7 +5373,7 @@ build_const_cast (type, expr)\n     {\n       if (! real_lvalue_p (expr))\n \t{\n-\t  cp_error (\"const_cast from `%T' rvalue to `%T'\", intype, type);\n+\t  cp_error (\"invalid const_cast of an rvalue of type `%T' to type `%T'\", intype, type);\n \t  return error_mark_node;\n \t}\n \n@@ -5393,7 +5389,7 @@ build_const_cast (type, expr)\n \t   && comp_ptr_ttypes_const (TREE_TYPE (type), TREE_TYPE (intype)))\n     return cp_convert (type, expr);\n \n-  cp_error (\"const_cast from `%T' to `%T'\", intype, type);\n+  cp_error (\"invalid const_cast from type `%T' to type `%T'\", intype, type);\n   return error_mark_node;\n }\n \n@@ -5430,20 +5426,20 @@ build_c_cast (type, expr)\n       if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n \t{\n \t  if (pedantic)\n-\t    pedwarn (\"ANSI C++ forbids casting to an array type\");\n+\t    pedwarn (\"ISO C++ forbids casting to an array type\");\n \t  type = build_pointer_type (TREE_TYPE (type));\n \t}\n       else\n \t{\n-\t  error (\"ANSI C++ forbids casting to an array type\");\n+\t  error (\"ISO C++ forbids casting to an array type\");\n \t  return error_mark_node;\n \t}\n     }\n \n   if (TREE_CODE (type) == FUNCTION_TYPE\n       || TREE_CODE (type) == METHOD_TYPE)\n     {\n-      cp_error (\"casting to function type `%T'\", type);\n+      cp_error (\"invalid cast to function type `%T'\", type);\n       return error_mark_node;\n     }\n \n@@ -5768,7 +5764,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t/* WP 5.4.1:  The result is an lvalue if T is a reference type,\n \t   otherwise the result is an rvalue.   */\n \tif (! lvalue_p (lhs))\n-\t  pedwarn (\"ANSI C++ forbids cast to non-reference type used as lvalue\");\n+\t  pedwarn (\"ISO C++ forbids cast to non-reference type used as lvalue\");\n \n \tresult = build_modify_expr (inner_lhs, NOP_EXPR,\n \t\t\t\t    cp_convert (TREE_TYPE (inner_lhs),\n@@ -5874,7 +5870,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \n       /* Allow array assignment in compiler-generated code.  */\n       if (pedantic && ! DECL_ARTIFICIAL (current_function_decl))\n-\tpedwarn (\"ANSI C++ forbids assignment of arrays\");\n+\tpedwarn (\"ISO C++ forbids assignment of arrays\");\n \n       from_array = TREE_CODE (TREE_TYPE (newrhs)) == ARRAY_TYPE\n \t           ? 1 + (modifycode != INIT_EXPR): 0;\n@@ -6051,9 +6047,8 @@ get_delta_difference (from, to, force)\n       if (binfo_from_vbase (binfo))\n \t{\n \t  binfo = BINFO_FOR_VBASE (BINFO_TYPE (binfo), from);\n-\t  cp_warning (\"pointer to member cast to virtual base `%T'\",\n-\t\t      BINFO_TYPE (binfo));\n-\t  warning (\"  will only work if you are very careful\");\n+\t  cp_warning (\"pointer to member cast to virtual base `%T' will only\"\n+                      \" work if you are very careful\", BINFO_TYPE (binfo));\n \t}\n       delta = BINFO_OFFSET (binfo);\n       delta = cp_convert (ptrdiff_type_node, delta);\n@@ -6067,9 +6062,8 @@ get_delta_difference (from, to, force)\n     {\n       if (force)\n \t{\n-\t  cp_warning (\"pointer to member cast from virtual base `%T'\",\n-\t\t      BINFO_TYPE (binfo));\n-\t  warning (\"  will only work if you are very careful\");\n+\t  cp_warning (\"pointer to member cast from virtual base `%T' will \"\n+                      \"only wokr if you are very careful\", BINFO_TYPE (binfo));\n \t}\n       else\n \tcp_error (\"pointer to member conversion from virtual base `%T'\",\n@@ -6184,7 +6178,7 @@ build_ptrmemfunc (type, pfn, force)\n \n       if (!force \n \t  && !can_convert_arg (to_type, TREE_TYPE (pfn), pfn))\n-\tcp_error (\"conversion to `%T' from `%T'\", \n+\tcp_error (\"invalid conversion to type `%T' from type `%T'\", \n \t\t  to_type, pfn_type);\n \n       if (TREE_CODE (pfn) == PTRMEM_CST)\n@@ -6764,7 +6758,8 @@ check_return_expr (retval)\n      that's supposed to return a value.  */\n   if (!retval && fn_returns_value_p)\n     {\n-      pedwarn (\"`return' with no value, in function returning non-void\");\n+      pedwarn (\"return-statement with no value, in function declared with\"\n+               \" a non-void return type\");\n       /* Clear this, so finish_function won't say that we reach the\n \t end of a non-void function (which we don't, we gave a\n \t return!).  */\n@@ -6780,7 +6775,8 @@ check_return_expr (retval)\n \t   its side-effects.  */\n \t  finish_expr_stmt (retval);\n       else\n-\tpedwarn (\"`return' with a value, in function returning void\");\n+\tpedwarn (\"return-statement with a value, in function declared with\"\n+                 \" a void return type\");\n \n       current_function_returns_null = 1;\n \n@@ -6797,7 +6793,7 @@ check_return_expr (retval)\n        || DECL_NAME (current_function_decl) == ansi_opname[(int) VEC_NEW_EXPR])\n       && !TYPE_NOTHROW_P (TREE_TYPE (current_function_decl))\n       && null_ptr_cst_p (retval))\n-    cp_warning (\"operator new should throw an exception, not return NULL\");\n+    cp_warning (\"`operator new' should throw an exception, not return NULL\");\n \n   /* Effective C++ rule 15.  See also start_function.  */\n   if (warn_ecpp"}, {"sha": "a07e6584a0e0709f870b018e96d334490ec444a2", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4d78983814fad9db308ee7d2ee7d37b474a6aa/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4d78983814fad9db308ee7d2ee7d37b474a6aa/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=7e4d78983814fad9db308ee7d2ee7d37b474a6aa", "patch": "@@ -93,9 +93,9 @@ readonly_error (arg, string, soft)\n   if (TREE_CODE (arg) == COMPONENT_REF)\n     {\n       if (TYPE_READONLY (TREE_TYPE (TREE_OPERAND (arg, 0))))\n-        fmt = \"%s of member `%D' in read-only structure\";\n+        fmt = \"%s of data-member `%D' in read-only structure\";\n       else\n-        fmt = \"%s of read-only member `%D'\";\n+        fmt = \"%s of read-only data-member `%D'\";\n       (*fn) (fmt, string, TREE_OPERAND (arg, 1));\n     }\n   else if (TREE_CODE (arg) == VAR_DECL)\n@@ -156,7 +156,7 @@ abstract_virtuals_error (decl, type)\n \t\t    decl, type);\n       else if (TREE_CODE (decl) == FUNCTION_DECL\n \t       && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n-\tcp_error (\"invalid return type for method `%#D'\", decl);\n+\tcp_error (\"invalid return type for member function `%#D'\", decl);\n       else if (TREE_CODE (decl) == FUNCTION_DECL)\n \tcp_error (\"invalid return type for function `%#D'\", decl);\n     }\n@@ -199,8 +199,8 @@ incomplete_type_error (value, type)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n-      cp_error (\"invalid use of undefined type `%#T'\", type);\n-      cp_error_at (\"forward declaration of `%#T'\", type);\n+      cp_error_at\n+        (\"invalid use of a forward-declared, but not defined type `%#T'\", type);\n       break;\n \n     case VOID_TYPE:\n@@ -821,13 +821,13 @@ process_init_constructor (type, init, elts)\n \t{\n \t  if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n \t    {\n-\t      sorry (\"initializer list for object of class with virtual baseclasses\");\n+\t      sorry (\"initializer list for object of class with virtual base classes\");\n \t      return error_mark_node;\n \t    }\n \n \t  if (TYPE_BINFO_BASETYPES (type))\n \t    {\n-\t      sorry (\"initializer list for object of class with baseclasses\");\n+\t      sorry (\"initializer list for object of class with base classes\");\n \t      return error_mark_node;\n \t    }\n \n@@ -1462,7 +1462,7 @@ check_for_new_type (string, inptree)\n {\n   if (inptree.new_type_flag\n       && (pedantic || strcmp (string, \"cast\") != 0))\n-    pedwarn (\"ANSI C++ forbids defining types within %s\",string);\n+    pedwarn (\"ISO C++ forbids defining types within %s\",string);\n }\n \n /* Add new exception specifier SPEC, to the LIST we currently have."}]}