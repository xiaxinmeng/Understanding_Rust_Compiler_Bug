{"sha": "0ef38928667f16fbf49c8a422495a7791e4340c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVmMzg5Mjg2NjdmMTZmYmY0OWM4YTQyMjQ5NWE3NzkxZTQzNDBjOQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@cygnus.com", "date": "1998-11-15T14:12:42Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-11-15T14:12:42Z"}, "message": "jcf-parse.c (HANDLE_EXCEPTIONS_ATTRIBUTE): New macro.\n\n8\n\t* jcf-parse.c (HANDLE_EXCEPTIONS_ATTRIBUTE):  New macro.\n\t* jcf-io.c (find_class):  Simpler/cleaner structure fixes a bug.\n\nFrom-SVN: r23659", "tree": {"sha": "60f9d02b1b9c05fbbb80d07ea00e1cbb99a19cd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60f9d02b1b9c05fbbb80d07ea00e1cbb99a19cd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ef38928667f16fbf49c8a422495a7791e4340c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ef38928667f16fbf49c8a422495a7791e4340c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ef38928667f16fbf49c8a422495a7791e4340c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ef38928667f16fbf49c8a422495a7791e4340c9/comments", "author": null, "committer": null, "parents": [{"sha": "46689c0ba4807c2f85b4626972a9b6554b3bea13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46689c0ba4807c2f85b4626972a9b6554b3bea13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46689c0ba4807c2f85b4626972a9b6554b3bea13"}], "stats": {"total": 165, "additions": 87, "deletions": 78}, "files": [{"sha": "56639d603d0da4353f7579a549773820433bdd4b", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef38928667f16fbf49c8a422495a7791e4340c9/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef38928667f16fbf49c8a422495a7791e4340c9/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=0ef38928667f16fbf49c8a422495a7791e4340c9", "patch": "@@ -1,3 +1,9 @@\n+Sun Nov 15 14:10:56 1998  Per Bothner  <bothner@cygnus.com>\n+\n+\t* jcf-parse.c (HANDLE_EXCEPTIONS_ATTRIBUTE):  New macro.\n+\n+\t* jcf-io.c (find_class):  Simpler/cleaner structure fixes a bug.\n+\n Sat Nov 14 17:19:18 1998  Per Bothner  <bothner@cygnus.com>\n \n \tAllow uses of interface types to verify.  This is not really"}, {"sha": "259819bb3bcf0488a3936dfcb5094a76f3e26e7c", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 69, "deletions": 78, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef38928667f16fbf49c8a422495a7791e4340c9/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef38928667f16fbf49c8a422495a7791e4340c9/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=0ef38928667f16fbf49c8a422495a7791e4340c9", "patch": "@@ -259,7 +259,7 @@ DEFUN(find_class, (classname, classname_length, jcf, do_class_file),\n #else\n   int fd;\n #endif\n-  int i, k, java, class;\n+  int i, k, java, class = -1;\n   struct stat java_buf, class_buf;\n   char *dep_file;\n   void *entry, *java_entry;\n@@ -341,95 +341,86 @@ DEFUN(find_class, (classname, classname_length, jcf, do_class_file),\n \t}\n \n       class = stat (buffer, &class_buf);\n-      /* This is a little odd: if we didn't find the class file, we\n-\t can just skip to the next iteration.  However, if this is the\n-\t last iteration, then we want to search for the .java file as\n-\t well.  It was a little easier to implement this with two\n-\t loops, as opposed to checking for each type of file each time\n-\t through the loop.  */\n-      if (class && jcf_path_next (entry))\n-\tcontinue;\n+      if (class == 0)\n+\tbreak;\n+    }\n \n-      /* Check for out of synch .class/.java files.  */\n-      java = 1;\n-      for (java_entry = jcf_path_start ();\n-\t   java && java_entry != NULL;\n-\t   java_entry = jcf_path_next (java_entry))\n-\t{\n-\t  int m, l;\n+  /* Check for out of synch .class/.java files.  */\n+  java = 1;\n+  for (java_entry = jcf_path_start ();\n+       java && java_entry != NULL;\n+       java_entry = jcf_path_next (java_entry))\n+    {\n+      int m, l;\n \n-\t  if (jcf_path_is_zipfile (java_entry))\n-\t    continue;\n+      if (jcf_path_is_zipfile (java_entry))\n+\tcontinue;\n \n-\t  /* Compute name of .java file.  */\n-\t  strcpy (java_buffer, jcf_path_name (java_entry));\n-\t  l = strlen (java_buffer);\n-\t  for (m = 0; m < classname_length; ++m)\n-\t    {\n-\t      java_buffer[m + l] = (classname[m] == '.'\n-\t\t\t\t    ? '/'\n-\t\t\t\t    : classname[m]);\n-\t    }\n-\t  strcpy (java_buffer + m + l, \".java\");\n-\n-\t  /* FIXME: until the `.java' parser is fully working, we only\n-\t     look for a .java file when one was mentioned on the\n-\t     command line.  This lets us test the .java parser fairly\n-\t     easily, without compromising our ability to use the\n-\t     .class parser without fear.  */\n-\t  if (saw_java_source)\n-\t    java = stat (java_buffer, &java_buf);\n-\t}\n+      /* Compute name of .java file.  */\n+      strcpy (java_buffer, jcf_path_name (java_entry));\n+      l = strlen (java_buffer);\n+      for (m = 0; m < classname_length; ++m)\n+\tjava_buffer[m + l] = (classname[m] == '.' ? '/' : classname[m]);\n+      strcpy (java_buffer + m + l, \".java\");\n+\n+      /* FIXME: until the `.java' parser is fully working, we only\n+\t look for a .java file when one was mentioned on the\n+\t command line.  This lets us test the .java parser fairly\n+\t easily, without compromising our ability to use the\n+\t .class parser without fear.  */\n+      if (saw_java_source)\n+\tjava = stat (java_buffer, &java_buf);\n+    }\n \n-      if (! java && ! class && java_buf.st_mtime >= class_buf.st_mtime)\n-\tjcf->outofsynch = 1;\n+  if (! java && ! class && java_buf.st_mtime >= class_buf.st_mtime)\n+    jcf->outofsynch = 1;\n \n-      if (! java)\n-\tdep_file = java_buffer;\n-      else\n-\tdep_file = buffer;\n+  if (! java)\n+    dep_file = java_buffer;\n+  else\n+    dep_file = buffer;\n #if JCF_USE_STDIO\n-      if (!class)\n-\t{\n-\t  SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n-\t  stream = fopen (buffer, \"rb\");\n-\t  if (stream)\n-\t    goto found;\n-\t}\n-      /* Give .java a try, if necessary */\n-      if (!java)\n+  if (!class)\n+    {\n+      SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n+      stream = fopen (buffer, \"rb\");\n+      if (stream)\n+\tgoto found;\n+    }\n+  /* Give .java a try, if necessary */\n+  if (!java)\n+    {\n+      strcpy (buffer, java_buffer);\n+      SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n+      stream = fopen (buffer, \"r\");\n+      if (stream)\n \t{\n-\t  strcpy (buffer, java_buffer);\n-\t  SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n-\t  stream = fopen (buffer, \"r\");\n-\t  if (stream)\n-\t    {\n-\t      jcf->java_source = 1;\n-\t      goto found;\n-\t    }\n+\t  jcf->java_source = 1;\n+\t  goto found;\n \t}\n+    }\n #else\n-      if (!class)\n-\t{\n-\t  SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n-\t  fd = open (buffer, O_RDONLY | O_BINARY);\n-\t  if (fd >= 0)\n-\t    goto found;\n-\t}\n-      /* Give .java a try, if necessary */\n-      if (!java)\n+  if (!class)\n+    {\n+      SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n+      fd = open (buffer, O_RDONLY | O_BINARY);\n+      if (fd >= 0)\n+\tgoto found;\n+    }\n+  /* Give .java a try, if necessary */\n+  if (!java)\n+    {\n+      strcpy (buffer, java_buffer);\n+      SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n+      fd = open (buffer, O_RDONLY);\n+      if (fd >= 0)\n \t{\n-\t  strcpy (buffer, java_buffer);\n-\t  SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n-\t  fd = open (buffer, O_RDONLY);\n-\t  if (fd >= 0)\n-\t    {\n-\t      jcf->java_source = 1;\n-\t      goto found;\n-\t    }\n+\t  jcf->java_source = 1;\n+\t  goto found;\n \t}\n-#endif\n     }\n+#endif\n+\n   free (buffer);\n   return NULL;\n  found:"}, {"sha": "9e277dad36b5aa99a3f44f5d1bffea18f2a3440e", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef38928667f16fbf49c8a422495a7791e4340c9/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef38928667f16fbf49c8a422495a7791e4340c9/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=0ef38928667f16fbf49c8a422495a7791e4340c9", "patch": "@@ -155,6 +155,18 @@ set_source_filename (jcf, index)\n   DECL_LINENUMBERS_OFFSET (current_method) = JCF_TELL (jcf) - 2; \\\n   JCF_SKIP (jcf, n * 4); }\n \n+#define HANDLE_EXCEPTIONS_ATTRIBUTE(COUNT) \\\n+{ \\\n+  int n = COUNT; \\\n+  tree list = DECL_FUNCTION_THROWS (current_method); \\\n+  while (--n >= 0) \\\n+    { \\\n+      tree thrown_class = get_class_constant (jcf, JCF_readu2 (jcf)); \\\n+      list = tree_cons (NULL_TREE, thrown_class, list); \\\n+    } \\\n+  DECL_FUNCTION_THROWS (current_method) = nreverse (list); \\\n+}\n+\n #include \"jcf-reader.c\"\n \n static int yydebug;"}]}