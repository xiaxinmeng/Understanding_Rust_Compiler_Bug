{"sha": "3016ec8a616241f5672e9f0e826688295f60a99f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzAxNmVjOGE2MTYyNDFmNTY3MmU5ZjBlODI2Njg4Mjk1ZjYwYTk5Zg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-05-27T10:44:55Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-05-27T10:44:55Z"}, "message": "trans.c (Gigi_Types_Compatible): New predicate.\n\n\t* gcc-interface/trans.c (Gigi_Types_Compatible): New predicate.\n\t(Identifier_to_gnu): Use it to assert that the type of the identifier\n\tand that of its entity are compatible for gigi.  Rename a couple of\n\tlocal variables and separate the processing of the result type.\n\nFrom-SVN: r271650", "tree": {"sha": "155c2489d5abc75e88405b6368a1b418e1ed27cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/155c2489d5abc75e88405b6368a1b418e1ed27cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3016ec8a616241f5672e9f0e826688295f60a99f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3016ec8a616241f5672e9f0e826688295f60a99f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3016ec8a616241f5672e9f0e826688295f60a99f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3016ec8a616241f5672e9f0e826688295f60a99f/comments", "author": null, "committer": null, "parents": [{"sha": "7a0877c042afed1392a103d18e03b645f87392b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a0877c042afed1392a103d18e03b645f87392b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a0877c042afed1392a103d18e03b645f87392b8"}], "stats": {"total": 200, "additions": 126, "deletions": 74}, "files": [{"sha": "7b975bd7673594cfd8292e43f0cfdbb6d1581ae7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3016ec8a616241f5672e9f0e826688295f60a99f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3016ec8a616241f5672e9f0e826688295f60a99f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3016ec8a616241f5672e9f0e826688295f60a99f", "patch": "@@ -1,3 +1,10 @@\n+2019-05-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (Gigi_Types_Compatible): New predicate.\n+\t(Identifier_to_gnu): Use it to assert that the type of the identifier\n+\tand that of its entity are compatible for gigi.  Rename a couple of\n+\tlocal variables and separate the processing of the result type.\n+\n 2019-05-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Call_to_gnu): Use the unpadded type when"}, {"sha": "3af5eee9e91501e87b989e86163c5fc6887fc511", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 86, "deletions": 74, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3016ec8a616241f5672e9f0e826688295f60a99f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3016ec8a616241f5672e9f0e826688295f60a99f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=3016ec8a616241f5672e9f0e826688295f60a99f", "patch": "@@ -1021,62 +1021,74 @@ fold_constant_decl_in_expr (tree exp)\n   gcc_unreachable ();\n }\n \n+/* Return true if TYPE and DEF_TYPE are compatible GNAT types for Gigi.  */\n+\n+static bool\n+Gigi_Types_Compatible (Entity_Id type, Entity_Id def_type)\n+{\n+  /* The trivial case.  */\n+  if (type == def_type)\n+    return true;\n+\n+  /* A class-wide type is equivalent to a subtype of itself.  */\n+  if (Is_Class_Wide_Type (type))\n+    return true;\n+\n+  /* A packed array type is compatible with its implementation type.  */\n+  if (Is_Packed (def_type) && type == Packed_Array_Impl_Type (def_type))\n+    return true;\n+\n+  /* If both types are Itypes, one may be a copy of the other.  */\n+  if (Is_Itype (def_type) && Is_Itype (type))\n+    return true;\n+\n+  /* If the type is incomplete and comes from a limited context, then also\n+     consider its non-limited view.  */\n+  if (Is_Incomplete_Type (def_type)\n+      && From_Limited_With (def_type)\n+      && Present (Non_Limited_View (def_type)))\n+    return Gigi_Types_Compatible (type, Non_Limited_View (def_type));\n+\n+  /* If the type is incomplete/private, then also consider its full view.  */\n+  if (Is_Incomplete_Or_Private_Type (def_type)\n+      && Present (Full_View (def_type)))\n+    return Gigi_Types_Compatible (type, Full_View (def_type));\n+\n+  return false;\n+}\n+\n /* Subroutine of gnat_to_gnu to translate gnat_node, an N_Identifier,\n    to a GCC tree, which is returned.  GNU_RESULT_TYPE_P is a pointer\n    to where we should place the result type.  */\n \n static tree\n Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n {\n-  Node_Id gnat_temp, gnat_temp_type;\n-  tree gnu_result, gnu_result_type;\n-\n-  /* Whether we should require an lvalue for GNAT_NODE.  Needed in\n-     specific circumstances only, so evaluated lazily.  < 0 means\n-     unknown, > 0 means known true, 0 means known false.  */\n-  int require_lvalue = -1;\n-\n+  /* The entity of GNAT_NODE and its type.  */\n+  Node_Id gnat_entity = (Nkind (gnat_node) == N_Defining_Identifier\n+\t\t\t || Nkind (gnat_node) == N_Defining_Operator_Symbol)\n+\t\t\t? gnat_node : Entity (gnat_node);\n+  Node_Id gnat_entity_type = Etype (gnat_entity);\n   /* If GNAT_NODE is a constant, whether we should use the initialization\n      value instead of the constant entity, typically for scalars with an\n      address clause when the parent doesn't require an lvalue.  */\n   bool use_constant_initializer = false;\n+  /* Whether we should require an lvalue for GNAT_NODE.  Needed in\n+     specific circumstances only, so evaluated lazily.  < 0 means\n+     unknown, > 0 means known true, 0 means known false.  */\n+  int require_lvalue = -1;\n+  Node_Id gnat_result_type;\n+  tree gnu_result, gnu_result_type;\n \n   /* If the Etype of this node is not the same as that of the Entity, then\n      something went wrong, probably in generic instantiation.  However, this\n      does not apply to types.  Since we sometime have strange Ekind's, just\n-     do this test for objects.  Moreover, if the Etype of the Entity is private\n-     or incomplete coming from a limited context, the Etype of the N_Identifier\n-     is allowed to be the full/non-limited view and we also consider a packed\n-     array type to be the same as the original type.  Similarly, a CW type is\n-     equivalent to a subtype of itself.  Finally, if the types are Itypes, one\n-     may be a copy of the other, which is also legal.  */\n-  gnat_temp = ((Nkind (gnat_node) == N_Defining_Identifier\n-\t\t|| Nkind (gnat_node) == N_Defining_Operator_Symbol)\n-\t       ? gnat_node : Entity (gnat_node));\n-  gnat_temp_type = Etype (gnat_temp);\n-\n-  gcc_assert (Etype (gnat_node) == gnat_temp_type\n-\t      || (Is_Packed (gnat_temp_type)\n-\t\t  && (Etype (gnat_node)\n-\t\t      == Packed_Array_Impl_Type (gnat_temp_type)))\n-\t      || (Is_Class_Wide_Type (Etype (gnat_node)))\n-\t      || (Is_Incomplete_Or_Private_Type (gnat_temp_type)\n-\t\t  && Present (Full_View (gnat_temp_type))\n-\t\t  && ((Etype (gnat_node) == Full_View (gnat_temp_type))\n-\t\t      || (Is_Packed (Full_View (gnat_temp_type))\n-\t\t\t  && (Etype (gnat_node)\n-\t\t\t      == Packed_Array_Impl_Type\n-\t\t\t           (Full_View (gnat_temp_type))))))\n-\t      || (Is_Incomplete_Type (gnat_temp_type)\n-\t\t  && From_Limited_With (gnat_temp_type)\n-\t\t  && Present (Non_Limited_View (gnat_temp_type))\n-\t\t  && Etype (gnat_node) == Non_Limited_View (gnat_temp_type))\n-\t      || (Is_Itype (Etype (gnat_node)) && Is_Itype (gnat_temp_type))\n-\t      || !(Ekind (gnat_temp) == E_Variable\n-\t\t   || Ekind (gnat_temp) == E_Component\n-\t\t   || Ekind (gnat_temp) == E_Constant\n-\t\t   || Ekind (gnat_temp) == E_Loop_Parameter\n-\t\t   || Is_Formal (gnat_temp)));\n+     do this test for objects, except for discriminants because their type\n+     may have been changed to a subtype by Exp_Ch3.Adjust_Discriminants.  */\n+  gcc_assert (!Is_Object (gnat_entity)\n+\t      || Ekind (gnat_entity) == E_Discriminant\n+\t      || Etype (gnat_node) == gnat_entity_type\n+\t      || Gigi_Types_Compatible (Etype (gnat_node), gnat_entity_type));\n \n   /* If this is a reference to a deferred constant whose partial view is an\n      unconstrained private type, the proper type is on the full view of the\n@@ -1086,36 +1098,36 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n      attribute Position, generated for dispatching code (see Make_DT in\n      exp_disp,adb). In that case we need the type itself, not is parent,\n      in particular if it is a derived type  */\n-  if (Ekind (gnat_temp) == E_Constant\n-      && Is_Private_Type (gnat_temp_type)\n-      && (Has_Unknown_Discriminants (gnat_temp_type)\n-\t  || (Present (Full_View (gnat_temp_type))\n- \t      && Has_Discriminants (Full_View (gnat_temp_type))))\n-      && Present (Full_View (gnat_temp)))\n+  if (Ekind (gnat_entity) == E_Constant\n+      && Is_Private_Type (gnat_entity_type)\n+      && (Has_Unknown_Discriminants (gnat_entity_type)\n+\t  || (Present (Full_View (gnat_entity_type))\n+ \t      && Has_Discriminants (Full_View (gnat_entity_type))))\n+      && Present (Full_View (gnat_entity)))\n     {\n-      gnat_temp = Full_View (gnat_temp);\n-      gnat_temp_type = Etype (gnat_temp);\n+      gnat_entity = Full_View (gnat_entity);\n+      gnat_result_type = Etype (gnat_entity);\n     }\n   else\n     {\n       /* We want to use the Actual_Subtype if it has already been elaborated,\n \t otherwise the Etype.  Avoid using Actual_Subtype for packed arrays to\n \t simplify things.  */\n-      if ((Ekind (gnat_temp) == E_Constant\n-\t   || Ekind (gnat_temp) == E_Variable || Is_Formal (gnat_temp))\n-\t  && !(Is_Array_Type (Etype (gnat_temp))\n-\t       && Present (Packed_Array_Impl_Type (Etype (gnat_temp))))\n-\t  && Present (Actual_Subtype (gnat_temp))\n-\t  && present_gnu_tree (Actual_Subtype (gnat_temp)))\n-\tgnat_temp_type = Actual_Subtype (gnat_temp);\n+      if ((Ekind (gnat_entity) == E_Constant\n+\t   || Ekind (gnat_entity) == E_Variable || Is_Formal (gnat_entity))\n+\t  && !(Is_Array_Type (Etype (gnat_entity))\n+\t       && Present (Packed_Array_Impl_Type (Etype (gnat_entity))))\n+\t  && Present (Actual_Subtype (gnat_entity))\n+\t  && present_gnu_tree (Actual_Subtype (gnat_entity)))\n+\tgnat_result_type = Actual_Subtype (gnat_entity);\n       else\n-\tgnat_temp_type = Etype (gnat_node);\n+\tgnat_result_type = Etype (gnat_node);\n     }\n \n   /* Expand the type of this identifier first, in case it is an enumeral\n      literal, which only get made when the type is expanded.  There is no\n      order-of-elaboration issue here.  */\n-  gnu_result_type = get_unpadded_type (gnat_temp_type);\n+  gnu_result_type = get_unpadded_type (gnat_result_type);\n \n   /* If this is a non-imported elementary constant with an address clause,\n      retrieve the value instead of a pointer to be dereferenced unless\n@@ -1125,10 +1137,10 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n      statement alternative or a record discriminant.  There is no possible\n      volatile-ness short-circuit here since Volatile constants must be\n      imported per C.6.  */\n-  if (Ekind (gnat_temp) == E_Constant\n-      && Is_Elementary_Type (gnat_temp_type)\n-      && !Is_Imported (gnat_temp)\n-      && Present (Address_Clause (gnat_temp)))\n+  if (Ekind (gnat_entity) == E_Constant\n+      && Is_Elementary_Type (gnat_result_type)\n+      && !Is_Imported (gnat_entity)\n+      && Present (Address_Clause (gnat_entity)))\n     {\n       require_lvalue\n \t= lvalue_required_p (gnat_node, gnu_result_type, true, false);\n@@ -1139,13 +1151,13 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n     {\n       /* If this is a deferred constant, the initializer is attached to\n \t the full view.  */\n-      if (Present (Full_View (gnat_temp)))\n-\tgnat_temp = Full_View (gnat_temp);\n+      if (Present (Full_View (gnat_entity)))\n+\tgnat_entity = Full_View (gnat_entity);\n \n-      gnu_result = gnat_to_gnu (Expression (Declaration_Node (gnat_temp)));\n+      gnu_result = gnat_to_gnu (Expression (Declaration_Node (gnat_entity)));\n     }\n   else\n-    gnu_result = gnat_to_gnu_entity (gnat_temp, NULL_TREE, false);\n+    gnu_result = gnat_to_gnu_entity (gnat_entity, NULL_TREE, false);\n \n   /* Some objects (such as parameters passed by reference, globals of\n      variable size, and renamed objects) actually represent the address\n@@ -1184,7 +1196,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \n \t  if ((TREE_CODE (gnu_result) == INDIRECT_REF\n \t       || TREE_CODE (gnu_result) == UNCONSTRAINED_ARRAY_REF)\n-\t      && No (Address_Clause (gnat_temp)))\n+\t      && No (Address_Clause (gnat_entity)))\n \t    TREE_THIS_NOTRAP (gnu_result) = 1;\n \n \t  if (read_only)\n@@ -1218,9 +1230,9 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n   /* But for a constant renaming we couldn't do that incrementally for its\n      definition because of the need to return an lvalue so, if the present\n      context doesn't itself require an lvalue, we try again here.  */\n-  else if (Ekind (gnat_temp) == E_Constant\n-\t   && Is_Elementary_Type (gnat_temp_type)\n-\t   && Present (Renamed_Object (gnat_temp)))\n+  else if (Ekind (gnat_entity) == E_Constant\n+\t   && Is_Elementary_Type (gnat_result_type)\n+\t   && Present (Renamed_Object (gnat_entity)))\n     {\n       if (require_lvalue < 0)\n \trequire_lvalue\n@@ -1236,10 +1248,10 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n      avoid problematic conversions to the nominal subtype.  But remove any\n      padding from the resulting type.  */\n   if (FUNC_OR_METHOD_TYPE_P (TREE_TYPE (gnu_result))\n-      || Is_Constr_Subt_For_UN_Aliased (gnat_temp_type)\n-      || (Ekind (gnat_temp) == E_Constant\n-\t  && Present (Full_View (gnat_temp))\n-\t  && Has_Discriminants (gnat_temp_type)\n+      || Is_Constr_Subt_For_UN_Aliased (gnat_result_type)\n+      || (Ekind (gnat_entity) == E_Constant\n+\t  && Present (Full_View (gnat_entity))\n+\t  && Has_Discriminants (gnat_result_type)\n \t  && TREE_CODE (gnu_result) == CONSTRUCTOR))\n     {\n       gnu_result_type = TREE_TYPE (gnu_result);"}, {"sha": "a75cdb79eb223e861d7d97ef2ca5f97826a09eee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3016ec8a616241f5672e9f0e826688295f60a99f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3016ec8a616241f5672e9f0e826688295f60a99f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3016ec8a616241f5672e9f0e826688295f60a99f", "patch": "@@ -1,3 +1,8 @@\n+2019-05-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/limited_with7.ad[sb]: New test.\n+\t* gnat.dg/limited_with7_pkg.ads: New helper.\n+\n 2019-05-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/unchecked_convert13.adb: New test."}, {"sha": "13e35fe3d65545b3743a1d7a26ebb7a3ae0e60c1", "filename": "gcc/testsuite/gnat.dg/limited_with7.adb", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3016ec8a616241f5672e9f0e826688295f60a99f/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3016ec8a616241f5672e9f0e826688295f60a99f/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with7.adb?ref=3016ec8a616241f5672e9f0e826688295f60a99f", "patch": "@@ -0,0 +1,12 @@\n+-- { dg-do compile }\n+\n+with Limited_With7_Pkg; use Limited_With7_Pkg;\n+\n+package body Limited_With7 is\n+\n+   procedure Proc (R : out Limited_With7_Pkg.Rec) is\n+   begin\n+      R.I := 0;\n+   end;\n+\n+end Limited_With7;"}, {"sha": "2a2f86c2c991c8e31b63b4327ef5ae2a5ed6a726", "filename": "gcc/testsuite/gnat.dg/limited_with7.ads", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3016ec8a616241f5672e9f0e826688295f60a99f/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3016ec8a616241f5672e9f0e826688295f60a99f/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with7.ads?ref=3016ec8a616241f5672e9f0e826688295f60a99f", "patch": "@@ -0,0 +1,7 @@\n+limited with Limited_With7_Pkg;\n+\n+package Limited_With7 is\n+\n+   procedure Proc (R : out Limited_With7_Pkg.Rec);\n+\n+end Limited_With7;"}, {"sha": "7806eaa9acc0c815cfc0e06649b4a6d8ccc42515", "filename": "gcc/testsuite/gnat.dg/limited_with7_pkg.ads", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3016ec8a616241f5672e9f0e826688295f60a99f/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with7_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3016ec8a616241f5672e9f0e826688295f60a99f/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with7_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flimited_with7_pkg.ads?ref=3016ec8a616241f5672e9f0e826688295f60a99f", "patch": "@@ -0,0 +1,9 @@\n+package Limited_With7_Pkg is\n+\n+   type Rec;\n+\n+   type Rec is record\n+      I : Integer;\n+   end record;\n+\n+end Limited_With7_Pkg;"}]}