{"sha": "e192a2cd62f2ed824f93edab18d9a5aabf764784", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE5MmEyY2Q2MmYyZWQ4MjRmOTNlZGFiMThkOWE1YWFiZjc2NDc4NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-13T10:13:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-13T10:13:36Z"}, "message": "[multiple changes]\n\n2011-10-13  Thomas Quinot  <quinot@adacore.com>\n\n\t* par-ch2.adb, par.adb, par-util.adb, par-ch3.adb\n\t(Check_Future_Identifier): New subprogram,\n\tfactors duplicated code from Par.Ch2.P_Identifier and\n\tPar.Ch3.P_Defining_Identifier.\n\n2011-10-13  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-taprop-posix.adb (Initialize): Always raise Storage_Error\n\tif we fail to initialize CV attributes or CV.\n\n2011-10-13  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-tasren.adb (Timed_Selective_Wait, case\n\tAccept_Alternative_Selected): Use Defer_Abort_Nestable, since\n\twe know abortion is already deferred.\n\n2011-10-13  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch3.adb (Build_Class_Wide_Master): Moved to exp_ch9.\n\t(Build_Master_Renaming (function)): Removed.\n\t(Build_Master_Renaming (procedure)): Moved to exp_ch9.\n\t(Expand_Full_Type_Declaration): Alphabetize\n\tvariables. Reformatting of code and comments. Rewrite the\n\tsection on processing of anonymous access-to-task types in\n\trecord components.\n\t* exp_ch3.ads (Build_Class_Wide_Master): Moved to exp_ch9.\n\t(Build_Master_Renaming): Moved to exp_ch9.\n\t* exp_ch9.adb (Build_Class_Wide_Master): Moved from exp_ch3.\n\t(Build_Master_Entity): Add formal parameter\n\tUse_Current. Reformatting of code and comments.\n\t(Build_Master_Renaming): Moved from exp_ch3.\n\t* exp_ch9.ads (Build_Class_Wide_Master): Moved from\n\texp_ch3. Update comment on usage.\n\t(Build_Master_Entity):\n\tAdd formal parameter Use_Current. Update comment on usage.\n\t(Build_Master_Renaming): Moved from exp_ch3.\n\t* sem_ch3.adb (Access_Definition): Remove redundant code to\n\tcreate a _master and a renaming.\n\n2011-10-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* lib-xref.adb: Do no emit reference to overridden operation,\n\tif it is internally generated.\n\n2011-10-13  Vincent Celier  <celier@adacore.com>\n\n\t* bindgen.adb: Remove any processing related to g-trasym\n\t* Makefile.rtl: Add g-trasym.o to GNATRTL_NONTASKING_OBJS\n\t* mlib-prj.adb: Remove any processing related to g-trasym.\n\nFrom-SVN: r179898", "tree": {"sha": "731bb955325533b2b0c1662f3a2e9445eba13ef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/731bb955325533b2b0c1662f3a2e9445eba13ef4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e192a2cd62f2ed824f93edab18d9a5aabf764784", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e192a2cd62f2ed824f93edab18d9a5aabf764784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e192a2cd62f2ed824f93edab18d9a5aabf764784", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e192a2cd62f2ed824f93edab18d9a5aabf764784/comments", "author": null, "committer": null, "parents": [{"sha": "54c42edf79e7319010b7efa0a1e78acabb0205bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54c42edf79e7319010b7efa0a1e78acabb0205bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54c42edf79e7319010b7efa0a1e78acabb0205bd"}], "stats": {"total": 815, "additions": 365, "deletions": 450}, "files": [{"sha": "ffddae35d81b72c28cc79b521705b365d9a0f831", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -1,3 +1,55 @@\n+2011-10-13  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* par-ch2.adb, par.adb, par-util.adb, par-ch3.adb\n+\t(Check_Future_Identifier): New subprogram,\n+\tfactors duplicated code from Par.Ch2.P_Identifier and\n+\tPar.Ch3.P_Defining_Identifier.\n+\n+2011-10-13  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-taprop-posix.adb (Initialize): Always raise Storage_Error\n+\tif we fail to initialize CV attributes or CV.\n+\n+2011-10-13  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-tasren.adb (Timed_Selective_Wait, case\n+\tAccept_Alternative_Selected): Use Defer_Abort_Nestable, since\n+\twe know abortion is already deferred.\n+\n+2011-10-13  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Class_Wide_Master): Moved to exp_ch9.\n+\t(Build_Master_Renaming (function)): Removed.\n+\t(Build_Master_Renaming (procedure)): Moved to exp_ch9.\n+\t(Expand_Full_Type_Declaration): Alphabetize\n+\tvariables. Reformatting of code and comments. Rewrite the\n+\tsection on processing of anonymous access-to-task types in\n+\trecord components.\n+\t* exp_ch3.ads (Build_Class_Wide_Master): Moved to exp_ch9.\n+\t(Build_Master_Renaming): Moved to exp_ch9.\n+\t* exp_ch9.adb (Build_Class_Wide_Master): Moved from exp_ch3.\n+\t(Build_Master_Entity): Add formal parameter\n+\tUse_Current. Reformatting of code and comments.\n+\t(Build_Master_Renaming): Moved from exp_ch3.\n+\t* exp_ch9.ads (Build_Class_Wide_Master): Moved from\n+\texp_ch3. Update comment on usage.\n+\t(Build_Master_Entity):\n+\tAdd formal parameter Use_Current. Update comment on usage.\n+\t(Build_Master_Renaming): Moved from exp_ch3.\n+\t* sem_ch3.adb (Access_Definition): Remove redundant code to\n+\tcreate a _master and a renaming.\n+\n+2011-10-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* lib-xref.adb: Do no emit reference to overridden operation,\n+\tif it is internally generated.\n+\n+2011-10-13  Vincent Celier  <celier@adacore.com>\n+\n+\t* bindgen.adb: Remove any processing related to g-trasym\n+\t* Makefile.rtl: Add g-trasym.o to GNATRTL_NONTASKING_OBJS\n+\t* mlib-prj.adb: Remove any processing related to g-trasym.\n+\n 2011-10-12  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* sem_util.adb (Denotes_Same_Prefix): Fix fatal warning."}, {"sha": "88b37bc5b249a28acb2fda65911456ff5eb4b8df", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -435,6 +435,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-tasloc$(objext) \\\n   g-timsta$(objext) \\\n   g-traceb$(objext) \\\n+  g-trasym$(objext) \\\n   g-u3spch$(objext) \\\n   g-utf_32$(objext) \\\n   g-wispch$(objext) \\"}, {"sha": "d75fe06c51bfdb4fdde6bfdfc0825924f529dead", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -1893,25 +1893,6 @@ package body Bindgen is\n                   Write_Str (Name_Buffer (1 .. Name_Len));\n                   Write_Eol;\n                end if;\n-\n-               --  Don't link with the shared library on VMS if an internal\n-               --  filename object is seen. Multiply defined symbols will\n-               --  result.\n-\n-               if OpenVMS_On_Target\n-                 and then Is_Internal_File_Name\n-                  (ALIs.Table\n-                   (Units.Table (Elab_Order.Table (E)).My_ALI).Sfile)\n-               then\n-                  --  Special case for g-trasym.obj (not included in libgnat)\n-\n-                  Get_Name_String (ALIs.Table\n-                            (Units.Table (Elab_Order.Table (E)).My_ALI).Sfile);\n-\n-                  if Name_Buffer (1 .. 8) /= \"g-trasym\" then\n-                     Opt.Shared_Libgnat := False;\n-                  end if;\n-               end if;\n             end if;\n          end if;\n       end loop;"}, {"sha": "311b5d7b178f8486eb18c14b6141f66926b4c221", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 34, "deletions": 246, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -114,20 +114,6 @@ package body Exp_Ch3 is\n    --  removing the implicit call that would otherwise constitute elaboration\n    --  code.\n \n-   function Build_Master_Renaming\n-     (N : Node_Id;\n-      T : Entity_Id) return Entity_Id;\n-   --  If the designated type of an access type is a task type or contains\n-   --  tasks, we make sure that a _Master variable is declared in the current\n-   --  scope, and then declare a renaming for it:\n-   --\n-   --    atypeM : Master_Id renames _Master;\n-   --\n-   --  where atyp is the name of the access type. This declaration is used when\n-   --  an allocator for the access type is expanded. The node is the full\n-   --  declaration of the designated type that contains tasks. The renaming\n-   --  declaration is inserted before N, and after the Master declaration.\n-\n    procedure Build_Record_Init_Proc (N : Node_Id; Rec_Ent : Entity_Id);\n    --  Build record initialization procedure. N is the type declaration\n    --  node, and Rec_Ent is the corresponding entity for the record type.\n@@ -777,132 +763,6 @@ package body Exp_Ch3 is\n       end if;\n    end Build_Array_Init_Proc;\n \n-   -----------------------------\n-   -- Build_Class_Wide_Master --\n-   -----------------------------\n-\n-   procedure Build_Class_Wide_Master (T : Entity_Id) is\n-      Loc          : constant Source_Ptr := Sloc (T);\n-      Master_Id    : Entity_Id;\n-      Master_Scope : Entity_Id;\n-      Name_Id      : Node_Id;\n-      Related_Node : Node_Id;\n-      Ren_Decl     : Node_Id;\n-\n-   begin\n-      --  Nothing to do if there is no task hierarchy\n-\n-      if Restriction_Active (No_Task_Hierarchy) then\n-         return;\n-      end if;\n-\n-      --  Find the declaration that created the access type. It is either a\n-      --  type declaration, or an object declaration with an access definition,\n-      --  in which case the type is anonymous.\n-\n-      if Is_Itype (T) then\n-         Related_Node := Associated_Node_For_Itype (T);\n-      else\n-         Related_Node := Parent (T);\n-      end if;\n-\n-      Master_Scope := Find_Master_Scope (T);\n-\n-      --  Nothing to do if the master scope already contains a _master entity.\n-      --  The only exception to this is the following scenario:\n-\n-      --    Source_Scope\n-      --       Transient_Scope_1\n-      --          _master\n-\n-      --       Transient_Scope_2\n-      --          use of master\n-\n-      --  In this case the source scope is marked as having the master entity\n-      --  even though the actual declaration appears inside an inner scope. If\n-      --  the second transient scope requires a _master, it cannot use the one\n-      --  already declared because the entity is not visible.\n-\n-      Name_Id := Make_Identifier (Loc, Name_uMaster);\n-\n-      if not Has_Master_Entity (Master_Scope)\n-        or else No (Current_Entity_In_Scope (Name_Id))\n-      then\n-         declare\n-            Master_Decl : Node_Id;\n-\n-         begin\n-            Set_Has_Master_Entity (Master_Scope);\n-\n-            --  Generate:\n-            --    _master : constant Integer := Current_Master.all;\n-\n-            Master_Decl :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier =>\n-                  Make_Defining_Identifier (Loc, Name_uMaster),\n-                Constant_Present    => True,\n-                Object_Definition   =>\n-                  New_Reference_To (Standard_Integer, Loc),\n-                Expression          =>\n-                  Make_Explicit_Dereference (Loc,\n-                    New_Reference_To (RTE (RE_Current_Master), Loc)));\n-\n-            Insert_Action (Related_Node, Master_Decl);\n-            Analyze (Master_Decl);\n-\n-            --  Mark the containing scope as a task master. Masters associated\n-            --  with return statements are already marked at this stage (see\n-            --  Analyze_Subprogram_Body).\n-\n-            if Ekind (Current_Scope) /= E_Return_Statement then\n-               declare\n-                  Par : Node_Id := Related_Node;\n-\n-               begin\n-                  while Nkind (Par) /= N_Compilation_Unit loop\n-                     Par := Parent (Par);\n-\n-                     --  If we fall off the top, we are at the outer level, and\n-                     --  the environment task is our effective master, so\n-                     --  nothing to mark.\n-\n-                     if Nkind_In (Par, N_Block_Statement,\n-                                       N_Subprogram_Body,\n-                                       N_Task_Body)\n-                     then\n-                        Set_Is_Task_Master (Par);\n-                        exit;\n-                     end if;\n-                  end loop;\n-               end;\n-            end if;\n-         end;\n-      end if;\n-\n-      Master_Id :=\n-        Make_Defining_Identifier (Loc,\n-          New_External_Name (Chars (T), 'M'));\n-\n-      --  Generate:\n-      --    Mnn renames _master;\n-\n-      Ren_Decl :=\n-        Make_Object_Renaming_Declaration (Loc,\n-          Defining_Identifier => Master_Id,\n-          Subtype_Mark        => New_Reference_To (Standard_Integer, Loc),\n-          Name                => Name_Id);\n-\n-      Insert_Before (Related_Node, Ren_Decl);\n-      Analyze (Ren_Decl);\n-\n-      Set_Master_Id (T, Master_Id);\n-\n-   exception\n-      when RE_Not_Available =>\n-         return;\n-   end Build_Class_Wide_Master;\n-\n    --------------------------------\n    -- Build_Discr_Checking_Funcs --\n    --------------------------------\n@@ -1673,65 +1533,6 @@ package body Exp_Ch3 is\n          return Empty_List;\n    end Build_Initialization_Call;\n \n-   ---------------------------\n-   -- Build_Master_Renaming --\n-   ---------------------------\n-\n-   function Build_Master_Renaming\n-     (N : Node_Id;\n-      T : Entity_Id) return Entity_Id\n-   is\n-      Loc  : constant Source_Ptr := Sloc (N);\n-      M_Id : Entity_Id;\n-      Decl : Node_Id;\n-\n-   begin\n-      --  Nothing to do if there is no task hierarchy\n-\n-      if Restriction_Active (No_Task_Hierarchy) then\n-         return Empty;\n-      end if;\n-\n-      M_Id :=\n-        Make_Defining_Identifier (Loc,\n-          New_External_Name (Chars (T), 'M'));\n-\n-      Decl :=\n-        Make_Object_Renaming_Declaration (Loc,\n-          Defining_Identifier => M_Id,\n-          Subtype_Mark        => New_Reference_To (RTE (RE_Master_Id), Loc),\n-          Name                => Make_Identifier (Loc, Name_uMaster));\n-      Insert_Before (N, Decl);\n-      Analyze (Decl);\n-      return M_Id;\n-\n-   exception\n-      when RE_Not_Available =>\n-         return Empty;\n-   end Build_Master_Renaming;\n-\n-   ---------------------------\n-   -- Build_Master_Renaming --\n-   ---------------------------\n-\n-   procedure Build_Master_Renaming (N : Node_Id; T : Entity_Id) is\n-      M_Id : Entity_Id;\n-\n-   begin\n-      --  Nothing to do if there is no task hierarchy\n-\n-      if Restriction_Active (No_Task_Hierarchy) then\n-         return;\n-      end if;\n-\n-      M_Id := Build_Master_Renaming (N, T);\n-      Set_Master_Id (T, M_Id);\n-\n-   exception\n-      when RE_Not_Available =>\n-         return;\n-   end Build_Master_Renaming;\n-\n    ----------------------------\n    -- Build_Record_Init_Proc --\n    ----------------------------\n@@ -4325,8 +4126,8 @@ package body Exp_Ch3 is\n    procedure Expand_N_Full_Type_Declaration (N : Node_Id) is\n       Def_Id : constant Entity_Id := Defining_Identifier (N);\n       B_Id   : constant Entity_Id := Base_Type (Def_Id);\n-      Par_Id : Entity_Id;\n       FN     : Node_Id;\n+      Par_Id : Entity_Id;\n \n       procedure Build_Master (Def_Id : Entity_Id);\n       --  Create the master associated with Def_Id\n@@ -4390,6 +4191,8 @@ package body Exp_Ch3 is\n             Expand_Access_Protected_Subprogram_Type (N);\n          end if;\n \n+      --  Array of anonymous access-to-task pointers\n+\n       elsif Ada_Version >= Ada_2005\n         and then Is_Array_Type (Def_Id)\n         and then Is_Access_Type (Component_Type (Def_Id))\n@@ -4400,73 +4203,58 @@ package body Exp_Ch3 is\n       elsif Has_Task (Def_Id) then\n          Expand_Previous_Access_Type (Def_Id);\n \n+      --  Check the components of a record type or array of records for\n+      --  anonymous access-to-task pointers.\n+\n       elsif Ada_Version >= Ada_2005\n         and then\n-         (Is_Record_Type (Def_Id)\n-           or else (Is_Array_Type (Def_Id)\n-                      and then Is_Record_Type (Component_Type (Def_Id))))\n+          (Is_Record_Type (Def_Id)\n+             or else\n+               (Is_Array_Type (Def_Id)\n+                  and then Is_Record_Type (Component_Type (Def_Id))))\n       then\n          declare\n-            Comp : Entity_Id;\n-            Typ  : Entity_Id;\n-            M_Id : Entity_Id;\n+            Comp  : Entity_Id;\n+            First : Boolean;\n+            M_Id  : Entity_Id;\n+            Typ   : Entity_Id;\n \n          begin\n-            --  Look for the first anonymous access type component\n-\n             if Is_Array_Type (Def_Id) then\n                Comp := First_Entity (Component_Type (Def_Id));\n             else\n                Comp := First_Entity (Def_Id);\n             end if;\n \n+            --  Examine all components looking for anonymous access-to-task\n+            --  types.\n+\n+            First := True;\n             while Present (Comp) loop\n                Typ := Etype (Comp);\n \n-               exit when Is_Access_Type (Typ)\n-                 and then Ekind (Typ) = E_Anonymous_Access_Type;\n-\n-               Next_Entity (Comp);\n-            end loop;\n-\n-            --  If found we add a renaming declaration of master_id and we\n-            --  associate it to each anonymous access type component. Do\n-            --  nothing if the access type already has a master. This will be\n-            --  the case if the array type is the packed array created for a\n-            --  user-defined array type T, where the master_id is created when\n-            --  expanding the declaration for T.\n-\n-            if Present (Comp)\n-              and then Ekind (Typ) = E_Anonymous_Access_Type\n-              and then not Restriction_Active (No_Task_Hierarchy)\n-              and then No (Master_Id (Typ))\n+               if Ekind (Typ) = E_Anonymous_Access_Type\n+                 and then Has_Task (Available_View (Designated_Type (Typ)))\n+                 and then No (Master_Id (Typ))\n+               then\n+                  --  Ensure that the record or array type have a _master\n \n-               --  Do not consider run-times with no tasking support\n+                  if First then\n+                     Build_Master_Entity (Def_Id);\n+                     Build_Master_Renaming (N, Typ);\n+                     M_Id := Master_Id (Typ);\n \n-              and then RTE_Available (RE_Current_Master)\n-              and then Has_Task (Non_Limited_Designated_Type (Typ))\n-            then\n-               Build_Master_Entity (Def_Id);\n-               M_Id := Build_Master_Renaming (N, Def_Id);\n-\n-               if Is_Array_Type (Def_Id) then\n-                  Comp := First_Entity (Component_Type (Def_Id));\n-               else\n-                  Comp := First_Entity (Def_Id);\n-               end if;\n+                     First := False;\n \n-               while Present (Comp) loop\n-                  Typ := Etype (Comp);\n+                  --  Reuse the same master to service any additional types\n \n-                  if Is_Access_Type (Typ)\n-                    and then Ekind (Typ) = E_Anonymous_Access_Type\n-                  then\n+                  else\n                      Set_Master_Id (Typ, M_Id);\n                   end if;\n+               end if;\n \n-                  Next_Entity (Comp);\n-               end loop;\n-            end if;\n+               Next_Entity (Comp);\n+            end loop;\n          end;\n       end if;\n \n@@ -4482,7 +4270,7 @@ package body Exp_Ch3 is\n       end if;\n \n       if Nkind (Type_Definition (Original_Node (N))) =\n-                                                N_Derived_Type_Definition\n+           N_Derived_Type_Definition\n         and then not Is_Tagged_Type (Def_Id)\n         and then Present (Freeze_Node (Par_Id))\n         and then Present (TSS_Elist (Freeze_Node (Par_Id)))"}, {"sha": "8cedc0b05cd907726fa74a2b9a01c71518029fd1", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -46,15 +46,6 @@ package Exp_Ch3 is\n    procedure Expand_Record_Extension (T : Entity_Id; Def : Node_Id);\n    --  Add a field _parent in the extension part of the record\n \n-   procedure Build_Class_Wide_Master (T : Entity_Id);\n-   --  For access to class-wide limited types we must build a task master\n-   --  because some subsequent extension may add a task component. To avoid\n-   --  bringing in the tasking run-time whenever an access-to-class-wide\n-   --  limited type is used, we use the soft-link mechanism and add a level of\n-   --  indirection to calls to routines that manipulate Master_Ids. This must\n-   --  also be used for anonymous access types whose designated type is a task\n-   --  or synchronized interface.\n-\n    procedure Build_Discr_Checking_Funcs (N : Node_Id);\n    --  Builds function which checks whether the component name is consistent\n    --  with the current discriminants. N is the full type declaration node,\n@@ -93,19 +84,6 @@ package Exp_Ch3 is\n    --  Constructor_Ref is a call to a constructor subprogram. It is currently\n    --  used only to support C++ constructors.\n \n-   procedure Build_Master_Renaming (N : Node_Id; T : Entity_Id);\n-   --  If the designated type of an access type is a task type or contains\n-   --  tasks, we make sure that a _Master variable is declared in the current\n-   --  scope, and then declare a renaming for it:\n-   --\n-   --    atypeM : Master_Id renames _Master;\n-   --\n-   --  where atyp is the name of the access type. This declaration is\n-   --  used when an allocator for the access type is expanded. The node N\n-   --  is the full declaration of the designated type that contains tasks.\n-   --  The renaming declaration is inserted before N, and after the Master\n-   --  declaration.\n-\n    function Freeze_Type (N : Node_Id) return Boolean;\n    --  This function executes the freezing actions associated with the given\n    --  freeze type node N and returns True if the node is to be deleted. We"}, {"sha": "f6d6b1678085b6e224db87d08da862338c1cbcb6", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 196, "deletions": 27, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -1073,6 +1073,128 @@ package body Exp_Ch9 is\n           Parameter_Associations => New_List (Concurrent_Ref (N)));\n    end Build_Call_With_Task;\n \n+   -----------------------------\n+   -- Build_Class_Wide_Master --\n+   -----------------------------\n+\n+   procedure Build_Class_Wide_Master (Typ : Entity_Id) is\n+      Loc          : constant Source_Ptr := Sloc (Typ);\n+      Master_Id    : Entity_Id;\n+      Master_Scope : Entity_Id;\n+      Name_Id      : Node_Id;\n+      Related_Node : Node_Id;\n+      Ren_Decl     : Node_Id;\n+\n+   begin\n+      --  Nothing to do if there is no task hierarchy\n+\n+      if Restriction_Active (No_Task_Hierarchy) then\n+         return;\n+      end if;\n+\n+      --  Find the declaration that created the access type. It is either a\n+      --  type declaration, or an object declaration with an access definition,\n+      --  in which case the type is anonymous.\n+\n+      if Is_Itype (Typ) then\n+         Related_Node := Associated_Node_For_Itype (Typ);\n+      else\n+         Related_Node := Parent (Typ);\n+      end if;\n+\n+      Master_Scope := Find_Master_Scope (Typ);\n+\n+      --  Nothing to do if the master scope already contains a _master entity.\n+      --  The only exception to this is the following scenario:\n+\n+      --    Source_Scope\n+      --       Transient_Scope_1\n+      --          _master\n+\n+      --       Transient_Scope_2\n+      --          use of master\n+\n+      --  In this case the source scope is marked as having the master entity\n+      --  even though the actual declaration appears inside an inner scope. If\n+      --  the second transient scope requires a _master, it cannot use the one\n+      --  already declared because the entity is not visible.\n+\n+      Name_Id := Make_Identifier (Loc, Name_uMaster);\n+\n+      if not Has_Master_Entity (Master_Scope)\n+        or else No (Current_Entity_In_Scope (Name_Id))\n+      then\n+         declare\n+            Master_Decl : Node_Id;\n+\n+         begin\n+            Set_Has_Master_Entity (Master_Scope);\n+\n+            --  Generate:\n+            --    _master : constant Integer := Current_Master.all;\n+\n+            Master_Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc, Name_uMaster),\n+                Constant_Present    => True,\n+                Object_Definition   =>\n+                  New_Reference_To (Standard_Integer, Loc),\n+                Expression          =>\n+                  Make_Explicit_Dereference (Loc,\n+                    New_Reference_To (RTE (RE_Current_Master), Loc)));\n+\n+            Insert_Action (Related_Node, Master_Decl);\n+            Analyze (Master_Decl);\n+\n+            --  Mark the containing scope as a task master. Masters associated\n+            --  with return statements are already marked at this stage (see\n+            --  Analyze_Subprogram_Body).\n+\n+            if Ekind (Current_Scope) /= E_Return_Statement then\n+               declare\n+                  Par : Node_Id := Related_Node;\n+\n+               begin\n+                  while Nkind (Par) /= N_Compilation_Unit loop\n+                     Par := Parent (Par);\n+\n+                     --  If we fall off the top, we are at the outer level, and\n+                     --  the environment task is our effective master, so\n+                     --  nothing to mark.\n+\n+                     if Nkind_In (Par, N_Block_Statement,\n+                                       N_Subprogram_Body,\n+                                       N_Task_Body)\n+                     then\n+                        Set_Is_Task_Master (Par);\n+                        exit;\n+                     end if;\n+                  end loop;\n+               end;\n+            end if;\n+         end;\n+      end if;\n+\n+      Master_Id :=\n+        Make_Defining_Identifier (Loc,\n+          New_External_Name (Chars (Typ), 'M'));\n+\n+      --  Generate:\n+      --    Mnn renames _master;\n+\n+      Ren_Decl :=\n+        Make_Object_Renaming_Declaration (Loc,\n+          Defining_Identifier => Master_Id,\n+          Subtype_Mark        => New_Reference_To (Standard_Integer, Loc),\n+          Name                => Name_Id);\n+\n+      Insert_Before (Related_Node, Ren_Decl);\n+      Analyze (Ren_Decl);\n+\n+      Set_Master_Id (Typ, Master_Id);\n+   end Build_Class_Wide_Master;\n+\n    --------------------------------\n    -- Build_Corresponding_Record --\n    --------------------------------\n@@ -2763,64 +2885,111 @@ package body Exp_Ch9 is\n    -- Build_Master_Entity --\n    -------------------------\n \n-   procedure Build_Master_Entity (E : Entity_Id) is\n-      Loc  : constant Source_Ptr := Sloc (E);\n-      P    : Node_Id;\n-      Decl : Node_Id;\n-      S    : Entity_Id;\n+   procedure Build_Master_Entity\n+     (Id          : Entity_Id;\n+      Use_Current : Boolean := False)\n+   is\n+      Loc         : constant Source_Ptr := Sloc (Id);\n+      Context     : Node_Id;\n+      Master_Decl : Node_Id;\n+      Master_Scop : Entity_Id;\n \n    begin\n-      S := Find_Master_Scope (E);\n+      if Use_Current then\n+         Master_Scop := Current_Scope;\n+      else\n+         Master_Scop := Find_Master_Scope (Id);\n+      end if;\n \n-      --  Nothing to do if we already built a master entity for this scope\n-      --  or if there is no task hierarchy.\n+      --  Do not create a master if the enclosing scope already has one or if\n+      --  there is no task hierarchy.\n \n-      if Has_Master_Entity (S)\n+      if Has_Master_Entity (Master_Scop)\n         or else Restriction_Active (No_Task_Hierarchy)\n       then\n          return;\n       end if;\n \n-      --  Otherwise first build the master entity\n+      --  Determine the proper context to insert the master\n+\n+      if Is_Access_Type (Id) and then Is_Itype (Id) then\n+         Context := Associated_Node_For_Itype (Id);\n+      else\n+         Context := Parent (Id);\n+      end if;\n+\n+      --  Create a master, generate:\n       --    _Master : constant Master_Id := Current_Master.all;\n-      --  and insert it just before the current declaration\n \n-      Decl :=\n+      Master_Decl :=\n         Make_Object_Declaration (Loc,\n           Defining_Identifier =>\n             Make_Defining_Identifier (Loc, Name_uMaster),\n-          Constant_Present => True,\n-          Object_Definition => New_Reference_To (RTE (RE_Master_Id), Loc),\n-          Expression =>\n+          Constant_Present    => True,\n+          Object_Definition   => New_Reference_To (RTE (RE_Master_Id), Loc),\n+          Expression          =>\n             Make_Explicit_Dereference (Loc,\n               New_Reference_To (RTE (RE_Current_Master), Loc)));\n \n-      P := Parent (E);\n-      Insert_Before (P, Decl);\n-      Analyze (Decl);\n+      Insert_Before (Context, Master_Decl);\n+      Analyze (Master_Decl);\n \n-      Set_Has_Master_Entity (S);\n+      --  Mark the enclosing scope and its associated construct as being task\n+      --  masters.\n \n-      --  Now mark the containing scope as a task master\n+      Set_Has_Master_Entity (Master_Scop);\n \n-      while Nkind (P) /= N_Compilation_Unit loop\n-         P := Parent (P);\n+      while Nkind (Context) /= N_Compilation_Unit loop\n+         Context := Parent (Context);\n \n          --  If we fall off the top, we are at the outer level, and the\n          --  environment task is our effective master, so nothing to mark.\n \n-         if Nkind_In\n-              (P, N_Task_Body, N_Block_Statement, N_Subprogram_Body)\n+         if Nkind_In (Context, N_Block_Statement,\n+                               N_Subprogram_Body,\n+                               N_Task_Body)\n          then\n-            Set_Is_Task_Master (P, True);\n+            Set_Is_Task_Master (Context, True);\n             return;\n \n-         elsif Nkind (Parent (P)) = N_Subunit then\n-            P := Corresponding_Stub (Parent (P));\n+         elsif Nkind (Parent (Context)) = N_Subunit then\n+            Context := Corresponding_Stub (Parent (Context));\n          end if;\n       end loop;\n    end Build_Master_Entity;\n \n+   ---------------------------\n+   -- Build_Master_Renaming --\n+   ---------------------------\n+\n+   procedure Build_Master_Renaming (N : Node_Id; Typ : Entity_Id) is\n+      Loc         : constant Source_Ptr := Sloc (N);\n+      Master_Decl : Node_Id;\n+      Master_Id   : Entity_Id;\n+\n+   begin\n+      --  Nothing to do if there is no task hierarchy\n+\n+      if Restriction_Active (No_Task_Hierarchy) then\n+         return;\n+      end if;\n+\n+      Master_Id :=\n+        Make_Defining_Identifier (Loc,\n+          New_External_Name (Chars (Typ), 'M'));\n+\n+      Master_Decl :=\n+        Make_Object_Renaming_Declaration (Loc,\n+          Defining_Identifier => Master_Id,\n+          Subtype_Mark        => New_Reference_To (RTE (RE_Master_Id), Loc),\n+          Name                => Make_Identifier (Loc, Name_uMaster));\n+\n+      Insert_Before (N, Master_Decl);\n+      Analyze (Master_Decl);\n+\n+      Set_Master_Id (Typ, Master_Id);\n+   end Build_Master_Renaming;\n+\n    -----------------------------------------\n    -- Build_Private_Protected_Declaration --\n    -----------------------------------------"}, {"sha": "3f20c1c3df5a6486ef07b1bb756ad56f142e7d81", "filename": "gcc/ada/exp_ch9.ads", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -50,28 +50,34 @@ package Exp_Ch9 is\n    --  Task_Id of the associated task as the parameter. The caller is\n    --  responsible for analyzing and resolving the resulting tree.\n \n+   procedure Build_Class_Wide_Master (Typ : Entity_Id);\n+   --  Given an access-to-limited class-wide type or an access-to-limited\n+   --  interface, ensure that the designated type has a _master and generate\n+   --  a renaming of the said master to service the access type.\n+\n    function Build_Entry_Names (Conc_Typ : Entity_Id) return Node_Id;\n    --  Create the statements which populate the entry names array of a task or\n    --  protected type. The statements are wrapped inside a block due to a local\n    --  declaration.\n \n-   procedure Build_Master_Entity (E : Entity_Id);\n-   --  Given an entity E for the declaration of an object containing tasks\n-   --  or of a type declaration for an allocator whose designated type is a\n-   --  task or contains tasks, this routine marks the appropriate enclosing\n-   --  context as a master, and also declares a variable called _Master in\n-   --  the current declarative part which captures the value of Current_Master\n-   --  (if not already built by a prior call). We build this object (instead\n-   --  of just calling Current_Master) for two reasons. First it is clearly\n-   --  more efficient to call Current_Master only once for a bunch of tasks\n-   --  in the same declarative part, and second it makes things easier in\n-   --  generating the initialization routines, since they can just reference\n-   --  the object _Master by name, and they will get the proper Current_Master\n-   --  value at the outer level, and copy in the parameter value for the outer\n-   --  initialization call if the call is for a nested component). Note that\n-   --  in the case of nested packages, we only really need to make one such\n-   --  object at the outer level, but it is much easier to generate one per\n-   --  declarative part.\n+   procedure Build_Master_Entity\n+     (Id          : Entity_Id;\n+      Use_Current : Boolean := False);\n+   --  Given the name of an object or a type which is either a task, contains\n+   --  tasks or designates tasks, create a _master in the appropriate scope\n+   --  which captures the value of Current_Master. Mark the enclosing body as\n+   --  being a task master. A _master is built to avoid multiple expensive\n+   --  calls to Current_Master and to facilitate object initialization. Flag\n+   --  Use_Current ensures that the master scope is the current scope.\n+\n+   procedure Build_Master_Renaming (N : Node_Id; Typ : Entity_Id);\n+   --  Given an access type Typ and a declaration N of a designated type that\n+   --  is either a task or contains tasks, create a renaming of the form:\n+   --\n+   --     TypM : Master_Id renames _Master;\n+   --\n+   --  where _master denotes the task master of the enclosing context. The\n+   --  renaming declaration is inserted before N.\n \n    function Build_Private_Protected_Declaration (N : Node_Id) return Entity_Id;\n    --  A subprogram body without a previous spec that appears in a protected"}, {"sha": "d46e646ed4df3c651df8266b6662f521d771d90a", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -1911,13 +1911,16 @@ package body Lib.Xref is\n                      Op := Ultimate_Alias (Old_E);\n \n                   --  Normal case of no alias present\n+                  --  we omit generated primitives like tagged equality,\n+                  --  that have no source representation.\n \n                   else\n                      Op := Old_E;\n                   end if;\n \n                   if Present (Op)\n                     and then Sloc (Op) /= Standard_Location\n+                    and then Comes_From_Source (Op)\n                   then\n                      declare\n                         Loc      : constant Source_Ptr := Sloc (Op);"}, {"sha": "83c74b948429fae6f1f3fd62bb3c1fd116943e1d", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -70,9 +70,6 @@ package body MLib.Prj is\n    S_Dec_Ads : File_Name_Type := No_File;\n    --  Name_Id for \"dec.ads\"\n \n-   G_Trasym_Ads : File_Name_Type := No_File;\n-   --  Name_Id for \"g-trasym.ads\"\n-\n    Arguments : String_List_Access := No_Argument;\n    --  Used to accumulate arguments for the invocation of gnatbind and of the\n    --  compiler. Also used to collect the interface ALI when copying the ALI\n@@ -316,9 +313,6 @@ package body MLib.Prj is\n       Libdecgnat_Needed : Boolean := False;\n       --  On OpenVMS, set True if library needs to be linked with libdecgnat\n \n-      Gtrasymobj_Needed : Boolean := False;\n-      --  On OpenVMS, set rue if library needs to be linked with g-trasym.obj\n-\n       Object_Directory_Path : constant String :=\n                                 Get_Name_String\n                                   (For_Project.Object_Directory.Display_Name);\n@@ -375,8 +369,7 @@ package body MLib.Prj is\n       --  to link with -lgnarl (this is the case when there is a dependency\n       --  on s-osinte.ads). On OpenVMS, set Libdecgnat_Needed if the ALI file\n       --  indicates that there is a need to link with -ldecgnat (this is the\n-      --  case when there is a dependency on dec.ads). Set Gtrasymobj_Needed\n-      --  if there is a dependency on g-trasym.ads.\n+      --  case when there is a dependency on dec.ads).\n \n       procedure Process (The_ALI : File_Name_Type);\n       --  Check if the closure of a library unit which is or should be in the\n@@ -513,8 +506,7 @@ package body MLib.Prj is\n          if Libgnarl_Needed /= Yes\n            or else\n             (Main_Project\n-              and then OpenVMS_On_Target\n-              and then ((not Libdecgnat_Needed) or (not Gtrasymobj_Needed)))\n+              and then OpenVMS_On_Target)\n          then\n             --  Scan the ALI file\n \n@@ -548,9 +540,6 @@ package body MLib.Prj is\n                elsif OpenVMS_On_Target then\n                   if ALI.Sdep.Table (Index).Sfile = S_Dec_Ads then\n                      Libdecgnat_Needed := True;\n-\n-                  elsif ALI.Sdep.Table (Index).Sfile = G_Trasym_Ads then\n-                     Gtrasymobj_Needed := True;\n                   end if;\n                end if;\n             end loop;\n@@ -838,12 +827,6 @@ package body MLib.Prj is\n          S_Dec_Ads := Name_Find;\n       end if;\n \n-      if G_Trasym_Ads = No_File then\n-         Name_Len := 0;\n-         Add_Str_To_Name_Buffer (\"g-trasym.ads\");\n-         G_Trasym_Ads := Name_Find;\n-      end if;\n-\n       --  We work in the object directory\n \n       Change_Dir (Object_Directory_Path);\n@@ -1556,8 +1539,7 @@ package body MLib.Prj is\n                                           ALIs.Append (new String'(ALI_Path));\n \n                                           --  Find out if for this ALI file,\n-                                          --  libgnarl or libdecgnat or\n-                                          --  g-trasym.obj (on OpenVMS) is\n+                                          --  libgnarl or libdecgnat is\n                                           --  necessary.\n \n                                           Check_Libs (ALI_Path, True);\n@@ -1642,12 +1624,6 @@ package body MLib.Prj is\n             end if;\n          end if;\n \n-         if Gtrasymobj_Needed then\n-            Opts.Increment_Last;\n-            Opts.Table (Opts.Last) :=\n-              new String'(Lib_Directory & \"/g-trasym.obj\");\n-         end if;\n-\n          if Libdecgnat_Needed then\n             Opts.Increment_Last;\n "}, {"sha": "2cd54b7001c358ffa74e9503bdc711ebe110598e", "filename": "gcc/ada/par-ch2.adb", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fpar-ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fpar-ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch2.adb?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -62,34 +62,7 @@ package body Ch2 is\n       --  Code duplication, see Par_Ch3.P_Defining_Identifier???\n \n       if Token = Tok_Identifier then\n-\n-         --  Shouldn't the warnings below be emitted when in Ada 83 mode???\n-\n-         --  Ada 2005 (AI-284): If compiling in Ada 95 mode, we warn that\n-         --  INTERFACE, OVERRIDING, and SYNCHRONIZED are new reserved words.\n-\n-         if Ada_Version = Ada_95\n-           and then Warn_On_Ada_2005_Compatibility\n-         then\n-            if Token_Name = Name_Overriding\n-              or else Token_Name = Name_Synchronized\n-              or else (Token_Name = Name_Interface\n-                        and then Prev_Token /= Tok_Pragma)\n-            then\n-               Error_Msg_N (\"& is a reserved word in Ada 2005?\", Token_Node);\n-            end if;\n-         end if;\n-\n-         --  Similarly, warn about Ada 2012 reserved words\n-\n-         if Ada_Version in Ada_95 .. Ada_2005\n-           and then Warn_On_Ada_2012_Compatibility\n-         then\n-            if Token_Name = Name_Some then\n-               Error_Msg_N (\"& is a reserved word in Ada 2012?\", Token_Node);\n-            end if;\n-         end if;\n-\n+         Check_Future_Keyword;\n          Ident_Node := Token_Node;\n          Scan; -- past Identifier\n          return Ident_Node;"}, {"sha": "ef017f089601f41f9b39d67ea1e377492567be89", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -213,38 +213,7 @@ package body Ch3 is\n       --  Duplication should be removed, common code should be factored???\n \n       if Token = Tok_Identifier then\n-\n-         --  Shouldn't the warnings below be emitted when in Ada 83 mode???\n-\n-         --  Ada 2005 (AI-284): If compiling in Ada 95 mode, we warn that\n-         --  INTERFACE, OVERRIDING, and SYNCHRONIZED are new reserved words.\n-         --  Note that in the case where these keywords are misused in Ada 95\n-         --  mode, this routine will generally not be called at all.\n-\n-         --  What sort of misuse is this comment talking about??? These are\n-         --  perfectly legitimate defining identifiers in Ada 95???\n-\n-         if Ada_Version = Ada_95\n-           and then Warn_On_Ada_2005_Compatibility\n-         then\n-            if Token_Name = Name_Overriding\n-              or else Token_Name = Name_Synchronized\n-              or else (Token_Name = Name_Interface\n-                        and then Prev_Token /= Tok_Pragma)\n-            then\n-               Error_Msg_N (\"& is a reserved word in Ada 2005?\", Token_Node);\n-            end if;\n-         end if;\n-\n-         --  Similarly, warn about Ada 2012 reserved words\n-\n-         if Ada_Version in Ada_95 .. Ada_2005\n-           and then Warn_On_Ada_2012_Compatibility\n-         then\n-            if Token_Name = Name_Some then\n-               Error_Msg_N (\"& is a reserved word in Ada 2012?\", Token_Node);\n-            end if;\n-         end if;\n+         Check_Future_Keyword;\n \n       --  If we have a reserved identifier, manufacture an identifier with\n       --  a corresponding name after posting an appropriate error message"}, {"sha": "32a3a88e5567080ec05d0c4d82d670fc524e5d9c", "filename": "gcc/ada/par-util.adb", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fpar-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fpar-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-util.adb?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -168,6 +168,43 @@ package body Util is\n       end if;\n    end Check_Bad_Layout;\n \n+   --------------------------\n+   -- Check_Future_Keyword --\n+   --------------------------\n+\n+   procedure Check_Future_Keyword is\n+   begin\n+      --  Ada 2005 (AI-284): Compiling in Ada95 mode we warn that INTERFACE,\n+      --  OVERRIDING, and SYNCHRONIZED are new reserved words.\n+\n+      if Ada_Version = Ada_95\n+        and then Warn_On_Ada_2005_Compatibility\n+      then\n+         if Token_Name = Name_Overriding\n+           or else Token_Name = Name_Synchronized\n+           or else (Token_Name = Name_Interface\n+                     and then Prev_Token /= Tok_Pragma)\n+         then\n+            Error_Msg_N (\"& is a reserved word in Ada 2005?\", Token_Node);\n+         end if;\n+      end if;\n+\n+      --  Similarly, warn about Ada 2012 reserved words\n+\n+      if Ada_Version in Ada_95 .. Ada_2005\n+        and then Warn_On_Ada_2012_Compatibility\n+      then\n+         if Token_Name = Name_Some then\n+            Error_Msg_N (\"& is a reserved word in Ada 2012?\", Token_Node);\n+         end if;\n+      end if;\n+\n+      --  Note: we deliberately do not emit these warnings when operating in\n+      --  Ada 83 mode because in that case we assume the user is building\n+      --  legacy code anyway.\n+\n+   end Check_Future_Keyword;\n+\n    --------------------------\n    -- Check_Misspelling_Of --\n    --------------------------"}, {"sha": "ed2e72473e6a890b00309b141c4900d87251d5c5", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -1156,6 +1156,11 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  mode. The caller has typically checked that the current token,\n       --  an identifier, matches one of the 95 keywords.\n \n+      procedure Check_Future_Keyword;\n+      --  Emit a warning if the current token is a valid identifier in the\n+      --  language version in use, but is a reserved word in a later language\n+      --  version (unless the language version in use is Ada 83).\n+\n       procedure Check_Simple_Expression (E : Node_Id);\n       --  Given an expression E, that has just been scanned, so that Expr_Form\n       --  is still set, outputs an error if E is a non-simple expression. E is"}, {"sha": "dd99623f6c2068a6a540cdf1510400e57835c4cf", "filename": "gcc/ada/s-taprop-posix.adb", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fs-taprop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fs-taprop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-posix.adb?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -1089,9 +1089,7 @@ package body System.Task_Primitives.Operations is\n          Result := pthread_mutex_destroy (S.L'Access);\n          pragma Assert (Result = 0);\n \n-         if Result = ENOMEM then\n-            raise Storage_Error;\n-         end if;\n+         raise Storage_Error;\n       end if;\n \n       Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n@@ -1101,11 +1099,10 @@ package body System.Task_Primitives.Operations is\n          Result := pthread_mutex_destroy (S.L'Access);\n          pragma Assert (Result = 0);\n \n-         if Result = ENOMEM then\n-            Result := pthread_condattr_destroy (Cond_Attr'Access);\n-            pragma Assert (Result = 0);\n-            raise Storage_Error;\n-         end if;\n+         Result := pthread_condattr_destroy (Cond_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Storage_Error;\n       end if;\n \n       Result := pthread_condattr_destroy (Cond_Attr'Access);"}, {"sha": "e2541a106fdded8e9b354c15f6720f7a34429a94", "filename": "gcc/ada/s-tasren.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fs-tasren.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fs-tasren.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasren.adb?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -1502,7 +1502,7 @@ package body System.Tasking.Rendezvous is\n             --  Null_Body. Defer abort until it gets into the accept body.\n \n             Uninterpreted_Data := Self_Id.Common.Call.Uninterpreted_Data;\n-            Initialization.Defer_Abort (Self_Id);\n+            Initialization.Defer_Abort_Nestable (Self_Id);\n             STPO.Unlock (Self_Id);\n \n          when Accept_Alternative_Completed =>"}, {"sha": "5cc4cb5ad40d78957ffd485169e021026cb207b9", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e192a2cd62f2ed824f93edab18d9a5aabf764784/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=e192a2cd62f2ed824f93edab18d9a5aabf764784", "patch": "@@ -706,11 +706,9 @@ package body Sem_Ch3 is\n      (Related_Nod : Node_Id;\n       N           : Node_Id) return Entity_Id\n    is\n-      Loc                 : constant Source_Ptr := Sloc (Related_Nod);\n       Anon_Type           : Entity_Id;\n       Anon_Scope          : Entity_Id;\n       Desig_Type          : Entity_Id;\n-      Decl                : Entity_Id;\n       Enclosing_Prot_Type : Entity_Id := Empty;\n \n    begin\n@@ -903,26 +901,8 @@ package body Sem_Ch3 is\n            and then Comes_From_Source (Related_Nod)\n            and then not Restriction_Active (No_Task_Hierarchy)\n          then\n-            if not Has_Master_Entity (Current_Scope) then\n-               Decl :=\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier =>\n-                     Make_Defining_Identifier (Loc, Name_uMaster),\n-                   Constant_Present    => True,\n-                   Object_Definition   =>\n-                     New_Reference_To (RTE (RE_Master_Id), Loc),\n-                   Expression          =>\n-                     Make_Explicit_Dereference (Loc,\n-                       New_Reference_To (RTE (RE_Current_Master), Loc)));\n-\n-               Insert_Before (Related_Nod, Decl);\n-               Analyze (Decl);\n-\n-               Set_Master_Id (Anon_Type, Defining_Identifier (Decl));\n-               Set_Has_Master_Entity (Current_Scope);\n-            else\n-               Build_Master_Renaming (Related_Nod, Anon_Type);\n-            end if;\n+            Build_Master_Entity (Defining_Identifier (Related_Nod), True);\n+            Build_Master_Renaming (Related_Nod, Anon_Type);\n          end if;\n       end if;\n "}]}