{"sha": "2bb30de62f59caa9af1ec01aa1029795f4748842", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJiMzBkZTYyZjU5Y2FhOWFmMWVjMDFhYTEwMjk3OTVmNDc0ODg0Mg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-05-13T20:17:25Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-05-13T20:17:25Z"}, "message": "c++: Simplify typedef access checking\n\nI discovered that the template typedef access check was rather more\nexpensive than needed.  The call of get_types_needed_access_check in\nthe FOR_EACH_VEC_SAFE_ELT is the moral equivalent of 'for (size_t pos\n= 0; pos != strlen (string); pos++)'.  Let's not do that.\n\n\t* pt.c (perform_typedefs_access_check): Cache expensively\n\tcalculated object references.\n\t(check_auto_in_tmpl_args): Just assert we do not get unexpected\n\tnodes, rather than silently do nothing.\n\t(append_type_to_template_for_access): Likewise, cache expensie\n\tobject reference.", "tree": {"sha": "8c1e10dc8086a99eea0a7a8f0b1cfcd4f7f08bce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c1e10dc8086a99eea0a7a8f0b1cfcd4f7f08bce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bb30de62f59caa9af1ec01aa1029795f4748842", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bb30de62f59caa9af1ec01aa1029795f4748842", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bb30de62f59caa9af1ec01aa1029795f4748842", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bb30de62f59caa9af1ec01aa1029795f4748842/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "833c7b4b5ef071bc3c5c79108baff55f2bcaaac3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/833c7b4b5ef071bc3c5c79108baff55f2bcaaac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/833c7b4b5ef071bc3c5c79108baff55f2bcaaac3"}], "stats": {"total": 77, "additions": 38, "deletions": 39}, "files": [{"sha": "a63f04e1ccd41b76e49d8f95720a93a14dc62a7b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb30de62f59caa9af1ec01aa1029795f4748842/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb30de62f59caa9af1ec01aa1029795f4748842/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2bb30de62f59caa9af1ec01aa1029795f4748842", "patch": "@@ -1,5 +1,12 @@\n 2020-05-13  Nathan Sidwell  <nathan@acm.org>\n \n+\t* pt.c (perform_typedefs_access_check): Cache expensively\n+\tcalculated object references.\n+\t(check_auto_in_tmpl_args): Just assert we do not get unexpected\n+\tnodes, rather than silently do nothing.\n+\t(append_type_to_template_for_access): Likewise, cache expensie\n+\tobject reference.\n+\n \t* pt.c (canonical_type_parameter): Simplify.\n \n \tFormatting fixups & some simplifications."}, {"sha": "52ed462810ad1f3eae3db19015a981c2aada2a3f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 31, "deletions": 39, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb30de62f59caa9af1ec01aa1029795f4748842/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb30de62f59caa9af1ec01aa1029795f4748842/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2bb30de62f59caa9af1ec01aa1029795f4748842", "patch": "@@ -11513,26 +11513,28 @@ perform_typedefs_access_check (tree tmpl, tree targs)\n \t  && TREE_CODE (tmpl) != FUNCTION_DECL))\n     return;\n \n-  FOR_EACH_VEC_SAFE_ELT (get_types_needing_access_check (tmpl), i, iter)\n-    {\n-      tree type_decl = iter->typedef_decl;\n-      tree type_scope = iter->context;\n-\n-      if (!type_decl || !type_scope || !CLASS_TYPE_P (type_scope))\n-\tcontinue;\n+  if (vec<qualified_typedef_usage_t, va_gc> *tdefs\n+      = get_types_needing_access_check (tmpl))\n+    FOR_EACH_VEC_ELT (*tdefs, i, iter)\n+      {\n+\ttree type_decl = iter->typedef_decl;\n+\ttree type_scope = iter->context;\n \n-      if (uses_template_parms (type_decl))\n-\ttype_decl = tsubst (type_decl, targs, tf_error, NULL_TREE);\n-      if (uses_template_parms (type_scope))\n-\ttype_scope = tsubst (type_scope, targs, tf_error, NULL_TREE);\n+\tif (!type_decl || !type_scope || !CLASS_TYPE_P (type_scope))\n+\t  continue;\n \n-      /* Make access check error messages point to the location\n-         of the use of the typedef.  */\n-      iloc_sentinel ils (iter->locus);\n-      perform_or_defer_access_check (TYPE_BINFO (type_scope),\n-\t\t\t\t     type_decl, type_decl,\n-\t\t\t\t     tf_warning_or_error);\n-    }\n+\tif (uses_template_parms (type_decl))\n+\t  type_decl = tsubst (type_decl, targs, tf_error, NULL_TREE);\n+\tif (uses_template_parms (type_scope))\n+\t  type_scope = tsubst (type_scope, targs, tf_error, NULL_TREE);\n+\n+\t/* Make access check error messages point to the location\n+\t   of the use of the typedef.  */\n+\tiloc_sentinel ils (iter->locus);\n+\tperform_or_defer_access_check (TYPE_BINFO (type_scope),\n+\t\t\t\t       type_decl, type_decl,\n+\t\t\t\t       tf_warning_or_error);\n+      }\n }\n \n static tree\n@@ -29217,25 +29219,13 @@ check_auto_in_tmpl_args (tree tmpl, tree args)\n vec<qualified_typedef_usage_t, va_gc> *\n get_types_needing_access_check (tree t)\n {\n-  tree ti;\n-  vec<qualified_typedef_usage_t, va_gc> *result = NULL;\n-\n-  if (!t || t == error_mark_node)\n-    return NULL;\n+  gcc_checking_assert ((CLASS_TYPE_P (t) || TREE_CODE (t) == FUNCTION_DECL));\n+  \n+  if (tree ti = get_template_info (t))\n+    if (TI_TEMPLATE (ti))\n+      return TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (ti);\n \n-  if (!(ti = get_template_info (t)))\n-    return NULL;\n-\n-  if (CLASS_TYPE_P (t)\n-      || TREE_CODE (t) == FUNCTION_DECL)\n-    {\n-      if (!TI_TEMPLATE (ti))\n-\treturn NULL;\n-\n-      result = TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (ti);\n-    }\n-\n-  return result;\n+  return NULL;\n }\n \n /* Append the typedef TYPE_DECL used in template T to a list of typedefs\n@@ -29320,9 +29310,11 @@ append_type_to_template_for_access_check (tree templ,\n   gcc_assert (type_decl && (TREE_CODE (type_decl) == TYPE_DECL));\n \n   /* Make sure we don't append the type to the template twice.  */\n-  FOR_EACH_VEC_SAFE_ELT (get_types_needing_access_check (templ), i, iter)\n-    if (iter->typedef_decl == type_decl && scope == iter->context)\n-      return;\n+  if (vec<qualified_typedef_usage_t, va_gc> *tdefs\n+      = get_types_needing_access_check (templ))\n+    FOR_EACH_VEC_ELT (*tdefs, i, iter)\n+      if (iter->typedef_decl == type_decl && scope == iter->context)\n+\treturn;\n \n   append_type_to_template_for_access_check_1 (templ, type_decl,\n \t\t\t\t\t      scope, location);"}]}