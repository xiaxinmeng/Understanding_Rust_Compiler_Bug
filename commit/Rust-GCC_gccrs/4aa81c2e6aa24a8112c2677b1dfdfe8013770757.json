{"sha": "4aa81c2e6aa24a8112c2677b1dfdfe8013770757", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFhODFjMmU2YWEyNGE4MTEyYzI2NzdiMWRmZGZlODAxMzc3MDc1Nw==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2014-08-06T08:32:07Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2014-08-06T08:32:07Z"}, "message": "[AArch64] Use REG_P and CONST_INT_P instead of GET_CODE + comparison.\n\n\t* config/aarch64/aarch64.c (aarch64_classify_address): Use REG_P and\n\tCONST_INT_P instead of GET_CODE and compare.\n\t(aarch64_select_cc_mode): Likewise.\n\t(aarch64_print_operand): Likewise.\n\t(aarch64_rtx_costs): Likewise.\n\t(aarch64_simd_valid_immediate): Likewise.\n\t(aarch64_simd_check_vect_par_cnst_half): Likewise.\n\t(aarch64_simd_emit_pair_result_insn): Likewise.\n\nFrom-SVN: r213651", "tree": {"sha": "558750ac8aba917253ce5c95e8632bf04855a29a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/558750ac8aba917253ce5c95e8632bf04855a29a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4aa81c2e6aa24a8112c2677b1dfdfe8013770757", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aa81c2e6aa24a8112c2677b1dfdfe8013770757", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4aa81c2e6aa24a8112c2677b1dfdfe8013770757", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aa81c2e6aa24a8112c2677b1dfdfe8013770757/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0483b3636dbf8ebac4d3862e1bcede3cb309e2a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0483b3636dbf8ebac4d3862e1bcede3cb309e2a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0483b3636dbf8ebac4d3862e1bcede3cb309e2a9"}], "stats": {"total": 41, "additions": 26, "deletions": 15}, "files": [{"sha": "b0999838df7809bd21e7c2d20c3990486b1a22b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aa81c2e6aa24a8112c2677b1dfdfe8013770757/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aa81c2e6aa24a8112c2677b1dfdfe8013770757/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4aa81c2e6aa24a8112c2677b1dfdfe8013770757", "patch": "@@ -1,3 +1,14 @@\n+2014-08-06  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_classify_address): Use REG_P and\n+\tCONST_INT_P instead of GET_CODE and compare.\n+\t(aarch64_select_cc_mode): Likewise.\n+\t(aarch64_print_operand): Likewise.\n+\t(aarch64_rtx_costs): Likewise.\n+\t(aarch64_simd_valid_immediate): Likewise.\n+\t(aarch64_simd_check_vect_par_cnst_half): Likewise.\n+\t(aarch64_simd_emit_pair_result_insn): Likewise.\n+\n 2014-08-05  David Malcolm  <dmalcolm@redhat.com>\n \n         * gdbhooks.py (find_gcc_source_dir): New helper function."}, {"sha": "5ccd860e400573cbdcb3cdb9a30c1de403dab4ee", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aa81c2e6aa24a8112c2677b1dfdfe8013770757/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aa81c2e6aa24a8112c2677b1dfdfe8013770757/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=4aa81c2e6aa24a8112c2677b1dfdfe8013770757", "patch": "@@ -3250,11 +3250,11 @@ aarch64_classify_address (struct aarch64_address_info *info,\n       op1 = XEXP (x, 1);\n \n       if (! strict_p\n-\t  && GET_CODE (op0) == REG\n+\t  && REG_P (op0)\n \t  && (op0 == virtual_stack_vars_rtx\n \t      || op0 == frame_pointer_rtx\n \t      || op0 == arg_pointer_rtx)\n-\t  && GET_CODE (op1) == CONST_INT)\n+\t  && CONST_INT_P (op1))\n \t{\n \t  info->type = ADDRESS_REG_IMM;\n \t  info->base = op0;\n@@ -3542,7 +3542,7 @@ aarch64_select_cc_mode (RTX_CODE code, rtx x, rtx y)\n      the comparison will have to be swapped when we emit the assembly\n      code.  */\n   if ((GET_MODE (x) == SImode || GET_MODE (x) == DImode)\n-      && (GET_CODE (y) == REG || GET_CODE (y) == SUBREG)\n+      && (REG_P (y) || GET_CODE (y) == SUBREG)\n       && (GET_CODE (x) == ASHIFT || GET_CODE (x) == ASHIFTRT\n \t  || GET_CODE (x) == LSHIFTRT\n \t  || GET_CODE (x) == ZERO_EXTEND || GET_CODE (x) == SIGN_EXTEND))\n@@ -3551,7 +3551,7 @@ aarch64_select_cc_mode (RTX_CODE code, rtx x, rtx y)\n   /* Similarly for a negated operand, but we can only do this for\n      equalities.  */\n   if ((GET_MODE (x) == SImode || GET_MODE (x) == DImode)\n-      && (GET_CODE (y) == REG || GET_CODE (y) == SUBREG)\n+      && (REG_P (y) || GET_CODE (y) == SUBREG)\n       && (code == EQ || code == NE)\n       && GET_CODE (x) == NEG)\n     return CC_Zmode;\n@@ -3711,7 +3711,7 @@ aarch64_print_operand (FILE *f, rtx x, char code)\n       {\n \tint n;\n \n-\tif (GET_CODE (x) != CONST_INT\n+\tif (!CONST_INT_P (x)\n \t    || (n = exact_log2 (INTVAL (x) & ~7)) <= 0)\n \t  {\n \t    output_operand_lossage (\"invalid operand for '%%%c'\", code);\n@@ -3741,7 +3741,7 @@ aarch64_print_operand (FILE *f, rtx x, char code)\n \tint n;\n \n \t/* Print N such that 2^N == X.  */\n-\tif (GET_CODE (x) != CONST_INT || (n = exact_log2 (INTVAL (x))) < 0)\n+\tif (!CONST_INT_P (x) || (n = exact_log2 (INTVAL (x))) < 0)\n \t  {\n \t    output_operand_lossage (\"invalid operand for '%%%c'\", code);\n \t    return;\n@@ -3753,7 +3753,7 @@ aarch64_print_operand (FILE *f, rtx x, char code)\n \n     case 'P':\n       /* Print the number of non-zero bits in X (a const_int).  */\n-      if (GET_CODE (x) != CONST_INT)\n+      if (!CONST_INT_P (x))\n \t{\n \t  output_operand_lossage (\"invalid operand for '%%%c'\", code);\n \t  return;\n@@ -3764,7 +3764,7 @@ aarch64_print_operand (FILE *f, rtx x, char code)\n \n     case 'H':\n       /* Print the higher numbered register of a pair (TImode) of regs.  */\n-      if (GET_CODE (x) != REG || !GP_REGNUM_P (REGNO (x) + 1))\n+      if (!REG_P (x) || !GP_REGNUM_P (REGNO (x) + 1))\n \t{\n \t  output_operand_lossage (\"invalid operand for '%%%c'\", code);\n \t  return;\n@@ -3838,7 +3838,7 @@ aarch64_print_operand (FILE *f, rtx x, char code)\n \n     case 'X':\n       /* Print bottom 16 bits of integer constant in hex.  */\n-      if (GET_CODE (x) != CONST_INT)\n+      if (!CONST_INT_P (x))\n \t{\n \t  output_operand_lossage (\"invalid operand for '%%%c'\", code);\n \t  return;\n@@ -5108,7 +5108,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t    op1 = SUBREG_REG (op1);\n \t  if ((GET_CODE (op1) == ZERO_EXTEND\n \t       || GET_CODE (op1) == SIGN_EXTEND)\n-\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (op0, 1))\n \t      && (GET_MODE_BITSIZE (GET_MODE (XEXP (op1, 0)))\n \t\t  >= INTVAL (XEXP (op0, 1))))\n \t    op1 = XEXP (op1, 0);\n@@ -7677,7 +7677,7 @@ aarch64_simd_valid_immediate (rtx op, enum machine_mode mode, bool inverse,\n       unsigned HOST_WIDE_INT elpart;\n       unsigned int part, parts;\n \n-      if (GET_CODE (el) == CONST_INT)\n+      if (CONST_INT_P (el))\n         {\n           elpart = INTVAL (el);\n           parts = 1;\n@@ -7983,7 +7983,7 @@ aarch64_simd_check_vect_par_cnst_half (rtx op, enum machine_mode mode,\n       rtx elt_op = XVECEXP (op, 0, i);\n       rtx elt_ideal = XVECEXP (ideal, 0, i);\n \n-      if (GET_CODE (elt_op) != CONST_INT\n+      if (!CONST_INT_P (elt_op)\n \t  || INTVAL (elt_ideal) != INTVAL (elt_op))\n \treturn false;\n     }\n@@ -7996,7 +7996,7 @@ void\n aarch64_simd_lane_bounds (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high)\n {\n   HOST_WIDE_INT lane;\n-  gcc_assert (GET_CODE (operand) == CONST_INT);\n+  gcc_assert (CONST_INT_P (operand));\n   lane = INTVAL (operand);\n \n   if (lane < low || lane >= high)\n@@ -8006,7 +8006,7 @@ aarch64_simd_lane_bounds (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high)\n void\n aarch64_simd_const_bounds (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high)\n {\n-  gcc_assert (GET_CODE (operand) == CONST_INT);\n+  gcc_assert (CONST_INT_P (operand));\n   HOST_WIDE_INT lane = INTVAL (operand);\n \n   if (lane < low || lane >= high)\n@@ -8044,7 +8044,7 @@ bool\n aarch64_simd_mem_operand_p (rtx op)\n {\n   return MEM_P (op) && (GET_CODE (XEXP (op, 0)) == POST_INC\n-\t\t\t|| GET_CODE (XEXP (op, 0)) == REG);\n+\t\t\t|| REG_P (XEXP (op, 0)));\n }\n \n /* Set up OPERANDS for a register copy from SRC to DEST, taking care"}]}