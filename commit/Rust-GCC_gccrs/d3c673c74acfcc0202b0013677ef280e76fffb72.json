{"sha": "d3c673c74acfcc0202b0013677ef280e76fffb72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNjNjczYzc0YWNmY2MwMjAyYjAwMTM2NzdlZjI4MGU3NmZmZmI3Mg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2006-12-04T10:20:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2006-12-04T10:20:51Z"}, "message": "re PR middle-end/29965 (OpenMP vs always throw in a loop)\n\n\tPR middle-end/29965\n\t* omp-low.c (determine_parallel_type): Don't try to optimize combined\n\tparallels if region->exit or region->inner->exit is NULL.\n\t(expand_omp_parallel): Handle NULL region->exit even if cfg is already\n\tbuilt.\n\t(expand_omp_for_generic): Handle NULL region->cond and region->exit.\n\t(expand_omp_for): Use expand_omp_for_generic if either region->cond\n\tor region->exit is NULL.\n\t(expand_omp_sections): Handle NULL region->cond or region->exit.\n\t(expand_omp_synch): \n\n\t* gcc.dg/gomp/pr29965-1.c: New test.\n\t* gcc.dg/gomp/pr29965-2.c: New test.\n\t* gcc.dg/gomp/pr29965-3.c: New test.\n\t* gcc.dg/gomp/pr29965-4.c: New test.\n\t* gcc.dg/gomp/pr29965-5.c: New test.\n\t* gcc.dg/gomp/pr29965-6.c: New test.\n\t* g++.dg/gomp/pr29965-1.C: New test.\n\t* g++.dg/gomp/pr29965-2.C: New test.\n\t* g++.dg/gomp/pr29965-3.C: New test.\n\t* g++.dg/gomp/pr29965-4.C: New test.\n\t* g++.dg/gomp/pr29965-5.C: New test.\n\t* g++.dg/gomp/pr29965-6.C: New test.\n\t* g++.dg/gomp/pr29965-7.C: New test.\n\t* g++.dg/gomp/pr29965-8.C: New test.\n\t* g++.dg/gomp/pr29965-9.C: New test.\n\t* g++.dg/gomp/pr29965-10.C: New test.\n\nFrom-SVN: r119483", "tree": {"sha": "8a7fb7efd8062ba4c47caab5ee275060e1dd09a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a7fb7efd8062ba4c47caab5ee275060e1dd09a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3c673c74acfcc0202b0013677ef280e76fffb72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3c673c74acfcc0202b0013677ef280e76fffb72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3c673c74acfcc0202b0013677ef280e76fffb72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3c673c74acfcc0202b0013677ef280e76fffb72/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "94983d3065b546ec059d54421b82b3aa9b852ed7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94983d3065b546ec059d54421b82b3aa9b852ed7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94983d3065b546ec059d54421b82b3aa9b852ed7"}], "stats": {"total": 1041, "additions": 994, "deletions": 47}, "files": [{"sha": "d544736b87433c430f46fb1973749c63db769c83", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -1,3 +1,16 @@\n+2006-12-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/29965\n+\t* omp-low.c (determine_parallel_type): Don't try to optimize combined\n+\tparallels if region->exit or region->inner->exit is NULL.\n+\t(expand_omp_parallel): Handle NULL region->exit even if cfg is already\n+\tbuilt.\n+\t(expand_omp_for_generic): Handle NULL region->cond and region->exit.\n+\t(expand_omp_for): Use expand_omp_for_generic if either region->cond\n+\tor region->exit is NULL.\n+\t(expand_omp_sections): Handle NULL region->cond or region->exit.\n+\t(expand_omp_synch): \n+\n 2006-12-04  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* config/sparc/sp64-elf.h (JUMP_TABLES_IN_TEXT_SECTION): Delete."}, {"sha": "30dbc713e8dab9d4709127bd149b285ef724365c", "filename": "gcc/omp-low.c", "status": "modified", "additions": 103, "deletions": 47, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -365,7 +365,8 @@ determine_parallel_type (struct omp_region *region)\n   basic_block par_entry_bb, par_exit_bb;\n   basic_block ws_entry_bb, ws_exit_bb;\n \n-  if (region == NULL || region->inner == NULL)\n+  if (region == NULL || region->inner == NULL\n+      || region->exit == NULL || region->inner->exit == NULL)\n     return;\n \n   /* We only support parallel+for and parallel+sections.  */\n@@ -2443,15 +2444,18 @@ expand_omp_parallel (struct omp_region *region)\n       block_stmt_iterator si;\n \n       entry_succ_e = single_succ_edge (entry_bb);\n-      exit_succ_e = single_succ_edge (exit_bb);\n \n       si = bsi_last (entry_bb);\n       gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_PARALLEL);\n       bsi_remove (&si, true);\n \n       new_bb = entry_bb;\n       remove_edge (entry_succ_e);\n-      make_edge (new_bb, exit_succ_e->dest, EDGE_FALLTHRU);\n+      if (exit_bb)\n+\t{\n+\t  exit_succ_e = single_succ_edge (exit_bb);\n+\t  make_edge (new_bb, exit_succ_e->dest, EDGE_FALLTHRU);\n+\t}\n     }\n   else\n     {\n@@ -2574,10 +2578,11 @@ expand_omp_for_generic (struct omp_region *region,\n \t\t\tenum built_in_function start_fn,\n \t\t\tenum built_in_function next_fn)\n {\n-  tree l0, l1, l2, l3;\n+  tree l0, l1, l2 = NULL, l3 = NULL;\n   tree type, istart0, iend0, iend;\n   tree t, args, list;\n-  basic_block entry_bb, cont_bb, exit_bb, l0_bb, l1_bb, l2_bb, l3_bb;\n+  basic_block entry_bb, cont_bb, exit_bb, l0_bb, l1_bb;\n+  basic_block l2_bb = NULL, l3_bb = NULL;\n   block_stmt_iterator si;\n   bool in_combined_parallel = is_combined_parallel (region);\n \n@@ -2589,18 +2594,25 @@ expand_omp_for_generic (struct omp_region *region,\n   TREE_ADDRESSABLE (istart0) = 1;\n   TREE_ADDRESSABLE (iend0) = 1;\n \n+  gcc_assert ((region->cont != NULL) ^ (region->exit == NULL));\n+\n   entry_bb = region->entry;\n   l0_bb = create_empty_bb (entry_bb);\n   l1_bb = single_succ (entry_bb);\n-  cont_bb = region->cont;\n-  l2_bb = create_empty_bb (cont_bb);\n-  l3_bb = single_succ (cont_bb);\n-  exit_bb = region->exit;\n \n   l0 = tree_block_label (l0_bb);\n   l1 = tree_block_label (l1_bb);\n-  l2 = tree_block_label (l2_bb);\n-  l3 = tree_block_label (l3_bb);\n+\n+  cont_bb = region->cont;\n+  exit_bb = region->exit;\n+  if (cont_bb)\n+    {\n+      l2_bb = create_empty_bb (cont_bb);\n+      l3_bb = single_succ (cont_bb);\n+\n+      l2 = tree_block_label (l2_bb);\n+      l3 = tree_block_label (l3_bb);\n+    }\n \n   si = bsi_last (entry_bb);\n   gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_FOR);\n@@ -2626,9 +2638,12 @@ expand_omp_for_generic (struct omp_region *region,\n       args = tree_cons (NULL, t, args);\n       t = build_function_call_expr (built_in_decls[start_fn], args);\n       t = get_formal_tmp_var (t, &list);\n-      t = build3 (COND_EXPR, void_type_node, t, build_and_jump (&l0),\n-\t\t  build_and_jump (&l3));\n-      append_to_statement_list (t, &list);\n+      if (cont_bb)\n+\t{\n+\t  t = build3 (COND_EXPR, void_type_node, t, build_and_jump (&l0),\n+\t\t      build_and_jump (&l3));\n+\t  append_to_statement_list (t, &list);\n+\t}\n       bsi_insert_after (&si, list, BSI_SAME_STMT);\n     }\n   bsi_remove (&si, true);\n@@ -2646,6 +2661,15 @@ expand_omp_for_generic (struct omp_region *region,\n   si = bsi_start (l0_bb);\n   bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n \n+  /* Handle the rare case where BODY doesn't ever return.  */\n+  if (cont_bb == NULL)\n+    {\n+      remove_edge (single_succ_edge (entry_bb));\n+      make_edge (entry_bb, l0_bb, EDGE_FALLTHRU);\n+      make_edge (l0_bb, l1_bb, EDGE_FALLTHRU);\n+      return;\n+    }\n+\n   /* Code to control the increment and predicate for the sequential\n      loop goes in the first half of EXIT_BB (we split EXIT_BB so\n      that we can inherit all the edges going out of the loop\n@@ -3098,7 +3122,10 @@ expand_omp_for (struct omp_region *region)\n   extract_omp_for_data (last_stmt (region->entry), &fd);\n   region->sched_kind = fd.sched_kind;\n \n-  if (fd.sched_kind == OMP_CLAUSE_SCHEDULE_STATIC && !fd.have_ordered)\n+  if (fd.sched_kind == OMP_CLAUSE_SCHEDULE_STATIC\n+      && !fd.have_ordered\n+      && region->cont\n+      && region->exit)\n     {\n       if (fd.chunk_size == NULL)\n \texpand_omp_for_static_nochunk (region, &fd);\n@@ -3156,15 +3183,28 @@ expand_omp_sections (struct omp_region *region)\n \n   entry_bb = region->entry;\n   l0_bb = create_empty_bb (entry_bb);\n+  l0 = tree_block_label (l0_bb);\n+\n+  gcc_assert ((region->cont != NULL) ^ (region->exit == NULL));\n   l1_bb = region->cont;\n-  l2_bb = single_succ (l1_bb);\n-  default_bb = create_empty_bb (l1_bb->prev_bb);\n-  exit_bb = region->exit;\n+  if (l1_bb)\n+    {\n+      l2_bb = single_succ (l1_bb);\n+      default_bb = create_empty_bb (l1_bb->prev_bb);\n \n-  l0 = tree_block_label (l0_bb);\n-  l1 = tree_block_label (l1_bb);\n+      l1 = tree_block_label (l1_bb);\n+    }\n+  else\n+    {\n+      l2_bb = create_empty_bb (l0_bb);\n+      default_bb = l2_bb;\n+\n+      l1 = NULL;\n+    }\n   l2 = tree_block_label (l2_bb);\n \n+  exit_bb = region->exit;\n+\n   v = create_tmp_var (unsigned_type_node, \".section\");\n \n   /* We will build a switch() with enough cases for all the\n@@ -3201,7 +3241,7 @@ expand_omp_sections (struct omp_region *region)\n \t      build_int_cst (unsigned_type_node, 0), NULL, l2);\n   TREE_VEC_ELT (label_vec, 0) = t;\n   make_edge (l0_bb, l2_bb, 0);\n-  \n+\n   /* Convert each OMP_SECTION into a CASE_LABEL_EXPR.  */\n   for (inner = region->inner, i = 1; inner; inner = inner->next, ++i)\n     {\n@@ -3220,15 +3260,19 @@ expand_omp_sections (struct omp_region *region)\n       gcc_assert (i < len || OMP_SECTION_LAST (bsi_stmt (si)));\n       bsi_remove (&si, true);\n \n-      si = bsi_last (s_exit_bb);\n-      gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_RETURN);\n-      bsi_remove (&si, true);\n-\n       e = single_pred_edge (s_entry_bb);\n       e->flags = 0;\n       redirect_edge_pred (e, l0_bb);\n \n       single_succ_edge (s_entry_bb)->flags = EDGE_FALLTHRU;\n+\n+      if (s_exit_bb == NULL)\n+\tcontinue;\n+\n+      si = bsi_last (s_exit_bb);\n+      gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_RETURN);\n+      bsi_remove (&si, true);\n+\n       single_succ_edge (s_exit_bb)->flags = EDGE_FALLTHRU;\n     }\n \n@@ -3244,24 +3288,30 @@ expand_omp_sections (struct omp_region *region)\n   bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \n   /* Code to get the next section goes in L1_BB.  */\n-  si = bsi_last (l1_bb);\n-  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_CONTINUE);\n+  if (l1_bb)\n+    {\n+      si = bsi_last (l1_bb);\n+      gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_CONTINUE);\n \n-  t = built_in_decls[BUILT_IN_GOMP_SECTIONS_NEXT];\n-  t = build_function_call_expr (t, NULL);\n-  t = build2 (MODIFY_EXPR, void_type_node, v, t);\n-  bsi_insert_after (&si, t, BSI_SAME_STMT);\n-  bsi_remove (&si, true);\n+      t = built_in_decls[BUILT_IN_GOMP_SECTIONS_NEXT];\n+      t = build_function_call_expr (t, NULL);\n+      t = build2 (MODIFY_EXPR, void_type_node, v, t);\n+      bsi_insert_after (&si, t, BSI_SAME_STMT);\n+      bsi_remove (&si, true);\n+    }\n \n   /* Cleanup function replaces OMP_RETURN in EXIT_BB.  */\n-  si = bsi_last (exit_bb);\n-  if (OMP_RETURN_NOWAIT (bsi_stmt (si)))\n-    t = built_in_decls[BUILT_IN_GOMP_SECTIONS_END_NOWAIT];\n-  else\n-    t = built_in_decls[BUILT_IN_GOMP_SECTIONS_END];\n-  t = build_function_call_expr (t, NULL);\n-  bsi_insert_after (&si, t, BSI_SAME_STMT);\n-  bsi_remove (&si, true);\n+  if (exit_bb)\n+    {\n+      si = bsi_last (exit_bb);\n+      if (OMP_RETURN_NOWAIT (bsi_stmt (si)))\n+\tt = built_in_decls[BUILT_IN_GOMP_SECTIONS_END_NOWAIT];\n+      else\n+\tt = built_in_decls[BUILT_IN_GOMP_SECTIONS_END];\n+      t = build_function_call_expr (t, NULL);\n+      bsi_insert_after (&si, t, BSI_SAME_STMT);\n+      bsi_remove (&si, true);\n+    }\n \n   /* Connect the new blocks.  */\n   if (is_combined_parallel (region))\n@@ -3274,9 +3324,12 @@ expand_omp_sections (struct omp_region *region)\n   else\n     make_edge (entry_bb, l0_bb, EDGE_FALLTHRU);\n \n-  e = single_succ_edge (l1_bb);\n-  redirect_edge_succ (e, l0_bb);\n-  e->flags = EDGE_FALLTHRU;\n+  if (l1_bb)\n+    {\n+      e = single_succ_edge (l1_bb);\n+      redirect_edge_succ (e, l0_bb);\n+      e->flags = EDGE_FALLTHRU;\n+    }\n }\n \n \n@@ -3337,10 +3390,13 @@ expand_omp_synch (struct omp_region *region)\n   bsi_remove (&si, true);\n   single_succ_edge (entry_bb)->flags = EDGE_FALLTHRU;\n \n-  si = bsi_last (exit_bb);\n-  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_RETURN);\n-  bsi_remove (&si, true);\n-  single_succ_edge (exit_bb)->flags = EDGE_FALLTHRU;\n+  if (exit_bb)\n+    {\n+      si = bsi_last (exit_bb);\n+      gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_RETURN);\n+      bsi_remove (&si, true);\n+      single_succ_edge (exit_bb)->flags = EDGE_FALLTHRU;\n+    }\n }\n \n "}, {"sha": "fadccd7f266636b00afaa4cf61bcf2af82f693bc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -1,3 +1,23 @@\n+2006-12-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/29965\n+\t* gcc.dg/gomp/pr29965-1.c: New test.\n+\t* gcc.dg/gomp/pr29965-2.c: New test.\n+\t* gcc.dg/gomp/pr29965-3.c: New test.\n+\t* gcc.dg/gomp/pr29965-4.c: New test.\n+\t* gcc.dg/gomp/pr29965-5.c: New test.\n+\t* gcc.dg/gomp/pr29965-6.c: New test.\n+\t* g++.dg/gomp/pr29965-1.C: New test.\n+\t* g++.dg/gomp/pr29965-2.C: New test.\n+\t* g++.dg/gomp/pr29965-3.C: New test.\n+\t* g++.dg/gomp/pr29965-4.C: New test.\n+\t* g++.dg/gomp/pr29965-5.C: New test.\n+\t* g++.dg/gomp/pr29965-6.C: New test.\n+\t* g++.dg/gomp/pr29965-7.C: New test.\n+\t* g++.dg/gomp/pr29965-8.C: New test.\n+\t* g++.dg/gomp/pr29965-9.C: New test.\n+\t* g++.dg/gomp/pr29965-10.C: New test.\n+\n 2006-12-04  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/pointer_variable_bounds.adb: New test."}, {"sha": "efb89ffa60963f4401ef8a0e8842a6ff9433b275", "filename": "gcc/testsuite/g++.dg/gomp/pr29965-1.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-1.C?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,45 @@\n+// PR middle-end/29965\n+// Test that OpenMP construct bodies which never return don't cause ICEs.\n+// { dg-do compile }\n+// { dg-options \"-O2 -fopenmp\" }\n+\n+extern void baz () __attribute__ ((noreturn));\n+\n+static inline void\n+foo ()\n+{\n+#pragma omp parallel\n+  for (;;)\n+    ;\n+}\n+\n+static inline void\n+bar ()\n+{\n+#pragma omp parallel\n+  baz ();\n+}\n+\n+void\n+foo1 ()\n+{\n+  foo ();\n+}\n+\n+void\n+foo2 ()\n+{\n+  foo ();\n+}\n+\n+void\n+bar1 ()\n+{\n+  bar ();\n+}\n+\n+void\n+bar2 ()\n+{\n+  bar ();\n+}"}, {"sha": "2e816da7be214226229787cbd5021906972b9401", "filename": "gcc/testsuite/g++.dg/gomp/pr29965-10.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-10.C?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,24 @@\n+// PR middle-end/29965\n+// Test that OpenMP construct bodies which never return don't cause ICEs.\n+// This is invalid code, but we don't emit diagnostics for it, nevertheless\n+// we test that we don't ICE on it.\n+// { dg-do compile }\n+// { dg-options \"-O2 -fopenmp\" }\n+\n+void\n+foo1 ()\n+{\n+  int i;\n+#pragma omp for schedule (static)\n+  for (i = 0; i < 2834; i++)\n+    throw 0;\n+}\n+\n+void\n+foo2 ()\n+{\n+  int i;\n+#pragma omp parallel for schedule (static)\n+  for (i = 0; i < 2834; i++)\n+    throw 0;\n+}"}, {"sha": "0976ca762e11cf45a881eae1056c59f4ab6ee66e", "filename": "gcc/testsuite/g++.dg/gomp/pr29965-2.C", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-2.C?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,98 @@\n+// PR middle-end/29965\n+// Test that OpenMP construct bodies which never return don't cause ICEs.\n+// { dg-do compile }\n+// { dg-options \"-O2 -fopenmp\" }\n+\n+extern void baz () __attribute__ ((noreturn));\n+\n+void\n+foo1 ()\n+{\n+#pragma omp sections\n+  {\n+    for (;;)\n+      ;\n+  }\n+}\n+\n+void\n+bar1 ()\n+{\n+#pragma omp sections\n+  {\n+#pragma omp section\n+    baz ();\n+#pragma omp section\n+    baz ();\n+  }\n+}\n+\n+void\n+foo2 ()\n+{\n+#pragma omp sections\n+  {\n+    ;\n+#pragma omp section\n+    for (;;)\n+      ;    \n+  }\n+}\n+\n+void\n+bar2 ()\n+{\n+#pragma omp sections\n+  {\n+#pragma omp section\n+    baz ();\n+#pragma omp section\n+    ;\n+  }\n+}\n+\n+void\n+foo3 ()\n+{\n+#pragma omp parallel sections\n+  {\n+    for (;;)\n+      ;\n+  }\n+}\n+\n+void\n+bar3 ()\n+{\n+#pragma omp parallel sections\n+  {\n+#pragma omp section\n+    baz ();\n+#pragma omp section\n+    baz ();\n+  }\n+}\n+\n+void\n+foo4 ()\n+{\n+#pragma omp parallel sections\n+  {\n+    ;\n+#pragma omp section\n+    for (;;)\n+      ;    \n+  }\n+}\n+\n+void\n+bar4 ()\n+{\n+#pragma omp parallel sections\n+  {\n+#pragma omp section\n+    baz ();\n+#pragma omp section\n+    ;\n+  }\n+}"}, {"sha": "b98c24e5505cfa011cd7d73cd4836de9ad8c1b9f", "filename": "gcc/testsuite/g++.dg/gomp/pr29965-3.C", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-3.C?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,62 @@\n+// PR middle-end/29965\n+// Test that OpenMP construct bodies which never return don't cause ICEs.\n+// { dg-do compile }\n+// { dg-options \"-O2 -fopenmp\" }\n+\n+extern void baz () __attribute__ ((noreturn));\n+\n+void\n+foo1 ()\n+{\n+#pragma omp single\n+  for (;;);\n+}\n+\n+void\n+bar1 ()\n+{\n+#pragma omp single\n+  baz ();\n+}\n+\n+void\n+foo2 ()\n+{\n+#pragma omp master\n+  for (;;);\n+}\n+\n+void\n+bar2 ()\n+{\n+#pragma omp master\n+  baz ();\n+}\n+\n+void\n+foo3 ()\n+{\n+#pragma omp ordered\n+  for (;;);\n+}\n+\n+void\n+bar3 ()\n+{\n+#pragma omp ordered\n+  baz ();\n+}\n+\n+void\n+foo4 ()\n+{\n+#pragma omp critical\n+  for (;;);\n+}\n+\n+void\n+bar4 ()\n+{\n+#pragma omp critical\n+  baz ();\n+}"}, {"sha": "b044fdf70c7b015e52cf23a4470660d13be51f55", "filename": "gcc/testsuite/g++.dg/gomp/pr29965-4.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-4.C?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,44 @@\n+// PR middle-end/29965\n+// Test that OpenMP construct bodies which never return don't cause ICEs.\n+// { dg-do compile }\n+// { dg-options \"-O2 -fopenmp\" }\n+\n+extern void baz () __attribute__ ((noreturn));\n+\n+void\n+foo1 ()\n+{\n+  int i;\n+#pragma omp for schedule (dynamic)\n+  for (i = 0; i < 2834; i++)\n+    for (;;)\n+      ;\n+}\n+\n+void\n+bar1 ()\n+{\n+  int i;\n+#pragma omp for schedule (dynamic)\n+  for (i = 0; i < 2834; i++)\n+    baz ();\n+}\n+\n+void\n+foo2 ()\n+{\n+  int i;\n+#pragma omp parallel for schedule (dynamic)\n+  for (i = 0; i < 2834; i++)\n+    for (;;)\n+      ;\n+}\n+\n+void\n+bar2 ()\n+{\n+  int i;\n+#pragma omp parallel for schedule (dynamic)\n+  for (i = 0; i < 2834; i++)\n+    baz ();\n+}"}, {"sha": "cf91dd6dcf917b31d1c94cca94551f5038987cef", "filename": "gcc/testsuite/g++.dg/gomp/pr29965-5.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-5.C?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,44 @@\n+// PR middle-end/29965\n+// Test that OpenMP construct bodies which never return don't cause ICEs.\n+// { dg-do compile }\n+// { dg-options \"-O2 -fopenmp\" }\n+\n+extern void baz () __attribute__ ((noreturn));\n+\n+void\n+foo1 ()\n+{\n+  int i;\n+#pragma omp for schedule (static)\n+  for (i = 0; i < 2834; i++)\n+    for (;;)\n+      ;\n+}\n+\n+void\n+bar1 ()\n+{\n+  int i;\n+#pragma omp for schedule (static)\n+  for (i = 0; i < 2834; i++)\n+    baz ();\n+}\n+\n+void\n+foo2 ()\n+{\n+  int i;\n+#pragma omp parallel for schedule (static)\n+  for (i = 0; i < 2834; i++)\n+    for (;;)\n+      ;\n+}\n+\n+void\n+bar2 ()\n+{\n+  int i;\n+#pragma omp parallel for schedule (static)\n+  for (i = 0; i < 2834; i++)\n+    baz ();\n+}"}, {"sha": "6384d092817a28d12ec41d9e76fd9860d6f42107", "filename": "gcc/testsuite/g++.dg/gomp/pr29965-6.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-6.C?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,44 @@\n+// PR middle-end/29965\n+// Test that OpenMP construct bodies which never return don't cause ICEs.\n+// { dg-do compile }\n+// { dg-options \"-O2 -fopenmp\" }\n+\n+extern void baz () __attribute__ ((noreturn));\n+\n+void\n+foo1 ()\n+{\n+  int i;\n+#pragma omp for schedule (static, 16)\n+  for (i = 0; i < 2834; i++)\n+    for (;;)\n+      ;\n+}\n+\n+void\n+bar1 ()\n+{\n+  int i;\n+#pragma omp for schedule (static, 16)\n+  for (i = 0; i < 2834; i++)\n+    baz ();\n+}\n+\n+void\n+foo2 ()\n+{\n+  int i;\n+#pragma omp parallel for schedule (static, 16)\n+  for (i = 0; i < 2834; i++)\n+    for (;;)\n+      ;\n+}\n+\n+void\n+bar2 ()\n+{\n+  int i;\n+#pragma omp parallel for schedule (static, 16)\n+  for (i = 0; i < 2834; i++)\n+    baz ();\n+}"}, {"sha": "be7d6ae9dc2540ac90837e152c9f9db04d023619", "filename": "gcc/testsuite/g++.dg/gomp/pr29965-7.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-7.C?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,32 @@\n+// PR middle-end/29965\n+// Test that OpenMP construct bodies which never return don't cause ICEs.\n+// This is invalid code, but we don't emit diagnostics for it, nevertheless\n+// we test that we don't ICE on it.\n+// { dg-do compile }\n+// { dg-options \"-O2 -fopenmp\" }\n+\n+void\n+foo ()\n+{\n+#pragma omp parallel\n+  throw 0;\n+}\n+\n+static inline void\n+bar ()\n+{\n+#pragma omp parallel\n+  throw 0;\n+}\n+\n+void\n+bar1 ()\n+{\n+  bar ();\n+}\n+\n+void\n+bar2 ()\n+{\n+  bar ();\n+}"}, {"sha": "b2a35287d8a69edd9bfb712a8d8c3ef375ddcffd", "filename": "gcc/testsuite/g++.dg/gomp/pr29965-8.C", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-8.C?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,94 @@\n+// PR middle-end/29965\n+// Test that OpenMP construct bodies which never return don't cause ICEs.\n+// This is invalid code, but we don't emit diagnostics for it, nevertheless\n+// we test that we don't ICE on it.\n+// { dg-do compile }\n+// { dg-options \"-O2 -fopenmp\" }\n+\n+void\n+foo1 ()\n+{\n+#pragma omp sections\n+  {\n+    throw 0;\n+  }\n+}\n+\n+void\n+bar1 ()\n+{\n+#pragma omp sections\n+  {\n+#pragma omp section\n+    throw 0;\n+#pragma omp section\n+    throw 0;\n+  }\n+}\n+\n+void\n+foo2 ()\n+{\n+#pragma omp sections\n+  {\n+    ;\n+#pragma omp section\n+    throw 0;\n+  }\n+}\n+\n+void\n+bar2 ()\n+{\n+#pragma omp sections\n+  {\n+#pragma omp section\n+    throw 0;\n+#pragma omp section\n+    ;\n+  }\n+}\n+\n+void\n+foo3 ()\n+{\n+#pragma omp parallel sections\n+  {\n+    throw 0;\n+  }\n+}\n+\n+void\n+bar3 ()\n+{\n+#pragma omp parallel sections\n+  {\n+#pragma omp section\n+    throw 0;\n+#pragma omp section\n+    throw 0;\n+  }\n+}\n+\n+void\n+foo4 ()\n+{\n+#pragma omp parallel sections\n+  {\n+    ;\n+#pragma omp section\n+    throw 0;\n+  }\n+}\n+\n+void\n+bar4 ()\n+{\n+#pragma omp parallel sections\n+  {\n+#pragma omp section\n+    throw 0;\n+#pragma omp section\n+    ;\n+  }\n+}"}, {"sha": "b66a2472928013d15ed5060910baec86ad2599cd", "filename": "gcc/testsuite/g++.dg/gomp/pr29965-9.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr29965-9.C?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,34 @@\n+// PR middle-end/29965\n+// Test that OpenMP construct bodies which never return don't cause ICEs.\n+// This is invalid code, but we don't emit diagnostics for it, nevertheless\n+// we test that we don't ICE on it.\n+// { dg-do compile }\n+// { dg-options \"-O2 -fopenmp\" }\n+\n+void\n+foo1 ()\n+{\n+#pragma omp single\n+  throw 0;\n+}\n+\n+void\n+foo2 ()\n+{\n+#pragma omp master\n+  throw 0;\n+}\n+\n+void\n+foo3 ()\n+{\n+#pragma omp ordered\n+  throw 0;\n+}\n+\n+void\n+foo4 ()\n+{\n+#pragma omp critical\n+  throw 0;\n+}"}, {"sha": "b587d81e7603a7fb43a5718fe521c89057be19f0", "filename": "gcc/testsuite/gcc.dg/gomp/pr29965-1.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-1.c?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,45 @@\n+/* PR middle-end/29965 */\n+/* Test that OpenMP construct bodies which never return don't cause ICEs.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fopenmp\" } */\n+\n+extern void baz (void) __attribute__ ((noreturn));\n+\n+static inline void\n+foo (void)\n+{\n+#pragma omp parallel\n+  for (;;)\n+    ;\n+}\n+\n+static inline void\n+bar (void)\n+{\n+#pragma omp parallel\n+  baz ();\n+}\n+\n+void\n+foo1 (void)\n+{\n+  foo ();\n+}\n+\n+void\n+foo2 (void)\n+{\n+  foo ();\n+}\n+\n+void\n+bar1 (void)\n+{\n+  bar ();\n+}\n+\n+void\n+bar2 (void)\n+{\n+  bar ();\n+}"}, {"sha": "1bee4859d42523a8ef17d0c58c9ebf724929c549", "filename": "gcc/testsuite/gcc.dg/gomp/pr29965-2.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-2.c?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,98 @@\n+/* PR middle-end/29965 */\n+/* Test that OpenMP construct bodies which never return don't cause ICEs.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fopenmp\" } */\n+\n+extern void baz (void) __attribute__ ((noreturn));\n+\n+void\n+foo1 (void)\n+{\n+#pragma omp sections\n+  {\n+    for (;;)\n+      ;\n+  }\n+}\n+\n+void\n+bar1 (void)\n+{\n+#pragma omp sections\n+  {\n+#pragma omp section\n+    baz ();\n+#pragma omp section\n+    baz ();\n+  }\n+}\n+\n+void\n+foo2 (void)\n+{\n+#pragma omp sections\n+  {\n+    ;\n+#pragma omp section\n+    for (;;)\n+      ;    \n+  }\n+}\n+\n+void\n+bar2 (void)\n+{\n+#pragma omp sections\n+  {\n+#pragma omp section\n+    baz ();\n+#pragma omp section\n+    ;\n+  }\n+}\n+\n+void\n+foo3 (void)\n+{\n+#pragma omp parallel sections\n+  {\n+    for (;;)\n+      ;\n+  }\n+}\n+\n+void\n+bar3 (void)\n+{\n+#pragma omp parallel sections\n+  {\n+#pragma omp section\n+    baz ();\n+#pragma omp section\n+    baz ();\n+  }\n+}\n+\n+void\n+foo4 (void)\n+{\n+#pragma omp parallel sections\n+  {\n+    ;\n+#pragma omp section\n+    for (;;)\n+      ;    \n+  }\n+}\n+\n+void\n+bar4 (void)\n+{\n+#pragma omp parallel sections\n+  {\n+#pragma omp section\n+    baz ();\n+#pragma omp section\n+    ;\n+  }\n+}"}, {"sha": "5901f5f42c21aa2640d6e038c306ef3e6c181cbf", "filename": "gcc/testsuite/gcc.dg/gomp/pr29965-3.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-3.c?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,62 @@\n+/* PR middle-end/29965 */\n+/* Test that OpenMP construct bodies which never return don't cause ICEs.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fopenmp\" } */\n+\n+extern void baz (void) __attribute__ ((noreturn));\n+\n+void\n+foo1 (void)\n+{\n+#pragma omp single\n+  for (;;);\n+}\n+\n+void\n+bar1 (void)\n+{\n+#pragma omp single\n+  baz ();\n+}\n+\n+void\n+foo2 (void)\n+{\n+#pragma omp master\n+  for (;;);\n+}\n+\n+void\n+bar2 (void)\n+{\n+#pragma omp master\n+  baz ();\n+}\n+\n+void\n+foo3 (void)\n+{\n+#pragma omp ordered\n+  for (;;);\n+}\n+\n+void\n+bar3 (void)\n+{\n+#pragma omp ordered\n+  baz ();\n+}\n+\n+void\n+foo4 (void)\n+{\n+#pragma omp critical\n+  for (;;);\n+}\n+\n+void\n+bar4 (void)\n+{\n+#pragma omp critical\n+  baz ();\n+}"}, {"sha": "7416d8ec6752dd034c18f0cbf691ae804a11c57a", "filename": "gcc/testsuite/gcc.dg/gomp/pr29965-4.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-4.c?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,44 @@\n+/* PR middle-end/29965 */\n+/* Test that OpenMP construct bodies which never return don't cause ICEs.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fopenmp\" } */\n+\n+extern void baz (void) __attribute__ ((noreturn));\n+\n+void\n+foo1 (void)\n+{\n+  int i;\n+#pragma omp for schedule (dynamic)\n+  for (i = 0; i < 2834; i++)\n+    for (;;)\n+      ;\n+}\n+\n+void\n+bar1 (void)\n+{\n+  int i;\n+#pragma omp for schedule (dynamic)\n+  for (i = 0; i < 2834; i++)\n+    baz ();\n+}\n+\n+void\n+foo2 (void)\n+{\n+  int i;\n+#pragma omp parallel for schedule (dynamic)\n+  for (i = 0; i < 2834; i++)\n+    for (;;)\n+      ;\n+}\n+\n+void\n+bar2 (void)\n+{\n+  int i;\n+#pragma omp parallel for schedule (dynamic)\n+  for (i = 0; i < 2834; i++)\n+    baz ();\n+}"}, {"sha": "a948ec9dc2d16d8219f9037004224e1af9922031", "filename": "gcc/testsuite/gcc.dg/gomp/pr29965-5.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-5.c?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,44 @@\n+/* PR middle-end/29965 */\n+/* Test that OpenMP construct bodies which never return don't cause ICEs.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fopenmp\" } */\n+\n+extern void baz (void) __attribute__ ((noreturn));\n+\n+void\n+foo1 (void)\n+{\n+  int i;\n+#pragma omp for schedule (static)\n+  for (i = 0; i < 2834; i++)\n+    for (;;)\n+      ;\n+}\n+\n+void\n+bar1 (void)\n+{\n+  int i;\n+#pragma omp for schedule (static)\n+  for (i = 0; i < 2834; i++)\n+    baz ();\n+}\n+\n+void\n+foo2 (void)\n+{\n+  int i;\n+#pragma omp parallel for schedule (static)\n+  for (i = 0; i < 2834; i++)\n+    for (;;)\n+      ;\n+}\n+\n+void\n+bar2 (void)\n+{\n+  int i;\n+#pragma omp parallel for schedule (static)\n+  for (i = 0; i < 2834; i++)\n+    baz ();\n+}"}, {"sha": "6f6947836d6b3f3c5f8fc2c11090cf0e467454c1", "filename": "gcc/testsuite/gcc.dg/gomp/pr29965-6.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c673c74acfcc0202b0013677ef280e76fffb72/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr29965-6.c?ref=d3c673c74acfcc0202b0013677ef280e76fffb72", "patch": "@@ -0,0 +1,44 @@\n+/* PR middle-end/29965 */\n+/* Test that OpenMP construct bodies which never return don't cause ICEs.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fopenmp\" } */\n+\n+extern void baz (void) __attribute__ ((noreturn));\n+\n+void\n+foo1 (void)\n+{\n+  int i;\n+#pragma omp for schedule (static, 16)\n+  for (i = 0; i < 2834; i++)\n+    for (;;)\n+      ;\n+}\n+\n+void\n+bar1 (void)\n+{\n+  int i;\n+#pragma omp for schedule (static, 16)\n+  for (i = 0; i < 2834; i++)\n+    baz ();\n+}\n+\n+void\n+foo2 (void)\n+{\n+  int i;\n+#pragma omp parallel for schedule (static, 16)\n+  for (i = 0; i < 2834; i++)\n+    for (;;)\n+      ;\n+}\n+\n+void\n+bar2 (void)\n+{\n+  int i;\n+#pragma omp parallel for schedule (static, 16)\n+  for (i = 0; i < 2834; i++)\n+    baz ();\n+}"}]}