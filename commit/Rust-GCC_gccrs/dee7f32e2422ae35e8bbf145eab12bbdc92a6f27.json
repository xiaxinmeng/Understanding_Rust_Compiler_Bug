{"sha": "dee7f32e2422ae35e8bbf145eab12bbdc92a6f27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVlN2YzMmUyNDIyYWUzNWU4YmJmMTQ1ZWFiMTJiYmRjOTJhNmYyNw==", "commit": {"author": {"name": "Yuri Rumyantsev", "email": "ysrumyan@gmail.com", "date": "2012-10-04T08:13:18Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2012-10-04T08:13:18Z"}, "message": "i386.c (ix86_dep_by_shift_count_body): Add check on reload_completed since it can be invoked before register...\n\n         * config/i386/i386.c (ix86_dep_by_shift_count_body) : Add\n         check on reload_completed since it can be invoked before\n         register allocation phase in pre-reload schedule.\n         (ia32_multipass_dfa_lookahead) : Do not use dfa_lookahead for pre-reload\n         schedule to save compile time.\n         (ix86_sched_reorder) : Do not perform ready list reordering for pre-reload\n         schedule to save compile time.\n         (insn_is_function_arg) : New function. Returns true if lhs of insn is\n         HW function argument register.\n         (add_parameter_dependencies) : New function. Add output dependencies\n         for chain of function adjacent arguments if only there is a move to\n         likely spilled HW registers. Return first argument if at least one\n         dependence was added or NULL otherwise.\n         (avoid_func_arg_motion) : New function. Add output or anti dependency\n         from insn to first_arg to restrict code motion.\n         (add_dependee_for_func_arg) : New function. Avoid cross block motion of\n         function argument through adding dependency from the first non-jump\n         insn in bb.\n         (ix86_dependencies_evaluation_hook) : New function. Hook for pre-reload schedule:\n         avoid motion of function arguments passed in passed in likely spilled\n         HW registers.\n         (ix86_adjust_priority) : New function. Hook for pre-reload schedule: set priority\n         of moves from likely spilled HW registers to maximum to schedule them\n         as soon as possible.\n         (ix86_sched_init_global): Do not perform multipass scheduling for pre-reload\n         schedule to save compile time.\n\nFrom-SVN: r192065", "tree": {"sha": "175f9338bcb964d23f6ff8f1db1219d9b27b1aa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/175f9338bcb964d23f6ff8f1db1219d9b27b1aa0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dee7f32e2422ae35e8bbf145eab12bbdc92a6f27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee7f32e2422ae35e8bbf145eab12bbdc92a6f27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dee7f32e2422ae35e8bbf145eab12bbdc92a6f27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee7f32e2422ae35e8bbf145eab12bbdc92a6f27/comments", "author": {"login": "ysrumyan", "id": 44425612, "node_id": "MDQ6VXNlcjQ0NDI1NjEy", "avatar_url": "https://avatars.githubusercontent.com/u/44425612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysrumyan", "html_url": "https://github.com/ysrumyan", "followers_url": "https://api.github.com/users/ysrumyan/followers", "following_url": "https://api.github.com/users/ysrumyan/following{/other_user}", "gists_url": "https://api.github.com/users/ysrumyan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysrumyan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysrumyan/subscriptions", "organizations_url": "https://api.github.com/users/ysrumyan/orgs", "repos_url": "https://api.github.com/users/ysrumyan/repos", "events_url": "https://api.github.com/users/ysrumyan/events{/privacy}", "received_events_url": "https://api.github.com/users/ysrumyan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3d47a53a93fbe7cd466c194ecc0da6cc81ed4269", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d47a53a93fbe7cd466c194ecc0da6cc81ed4269", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d47a53a93fbe7cd466c194ecc0da6cc81ed4269"}], "stats": {"total": 294, "additions": 268, "deletions": 26}, "files": [{"sha": "e7006437fa62529a4d0fa4558ade082c3c870366", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee7f32e2422ae35e8bbf145eab12bbdc92a6f27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee7f32e2422ae35e8bbf145eab12bbdc92a6f27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dee7f32e2422ae35e8bbf145eab12bbdc92a6f27", "patch": "@@ -1,3 +1,32 @@\n+2012-10-04  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\t* config/i386/i386.c (ix86_dep_by_shift_count_body) : Add\n+\tcheck on reload_completed since it can be invoked before\n+\tregister allocation phase in pre-reload schedule.\n+\t(ia32_multipass_dfa_lookahead) : Do not use dfa_lookahead for pre-reload\n+\tschedule to save compile time.\n+\t(ix86_sched_reorder) : Do not perform ready list reordering for pre-reload\n+\tschedule to save compile time.\n+\t(insn_is_function_arg) : New function. Returns true if lhs of insn is\n+\tHW function argument register.\n+\t(add_parameter_dependencies) : New function. Add output dependencies\n+\tfor chain of function adjacent arguments if only there is a move to\n+\tlikely spilled HW registers. Return first argument if at least one\n+\tdependence was added or NULL otherwise.\n+\t(avoid_func_arg_motion) : New function. Add output or anti dependency\n+\tfrom insn to first_arg to restrict code motion.\n+\t(add_dependee_for_func_arg) : New function. Avoid cross block motion of\n+\tfunction argument through adding dependency from the first non-jump\n+\tinsn in bb.\n+\t(ix86_dependencies_evaluation_hook) : New function. Hook for pre-reload schedule:\n+\tavoid motion of function arguments passed in passed in likely spilled\n+\tHW registers.\n+\t(ix86_adjust_priority) : New function. Hook for pre-reload schedule: set priority\n+\tof moves from likely spilled HW registers to maximum to schedule them\n+\tas soon as possible.\n+\t(ix86_sched_init_global): Do not perform multipass scheduling for pre-reload\n+\tschedule to save compile time.\n+\n 2012-10-04  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* configure.ac (noexception_flags): Add -fasynchronous-unwind-tables."}, {"sha": "c10e49458f5af6f17c27abbb406c8bb665069454", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 239, "deletions": 26, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee7f32e2422ae35e8bbf145eab12bbdc92a6f27/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee7f32e2422ae35e8bbf145eab12bbdc92a6f27/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=dee7f32e2422ae35e8bbf145eab12bbdc92a6f27", "patch": "@@ -17520,9 +17520,16 @@ ix86_dep_by_shift_count_body (const_rtx set_body, const_rtx use_body)\n       rtx shift_count = XEXP (shift_rtx, 1);\n \n       /* Return true if shift count is dest of SET_BODY.  */\n-      if (REG_P (shift_count)\n-\t  && true_regnum (set_dest) == true_regnum (shift_count))\n-\treturn true;\n+      if (REG_P (shift_count))\n+\t{\n+\t  /* Add check since it can be invoked before register\n+\t     allocation in pre-reload schedule.  */\n+\t  if (reload_completed\n+\t      && true_regnum (set_dest) == true_regnum (shift_count))\n+\t    return true;\n+\t  else if (REGNO(set_dest) == REGNO(shift_count))\n+\t    return true;\n+\t}\n     }\n \n   return false;\n@@ -24278,7 +24285,10 @@ ia32_multipass_dfa_lookahead (void)\n       /* Generally, we want haifa-sched:max_issue() to look ahead as far\n \t as many instructions can be executed on a cycle, i.e.,\n \t issue_rate.  I wonder why tuning for many CPUs does not do this.  */\n-      return ix86_issue_rate ();\n+      if (reload_completed)\n+        return ix86_issue_rate ();\n+      /* Don't use lookahead for pre-reload schedule to save compile time.  */\n+      return 0;\n \n     default:\n       return 0;\n@@ -24311,6 +24321,9 @@ ix86_sched_reorder(FILE *dump, int sched_verbose, rtx *ready, int *pn_ready,\n   /* Do reodering for Atom only.  */\n   if (ix86_tune != PROCESSOR_ATOM)\n     return issue_rate;\n+  /* Do not perform ready list reodering for pre-reload schedule pass.  */\n+  if (!reload_completed)\n+    return issue_rate;\n   /* Nothing to do if ready list contains only 1 instruction.  */\n   if (n_ready <= 1)\n     return issue_rate;\n@@ -24393,7 +24406,198 @@ ix86_sched_reorder(FILE *dump, int sched_verbose, rtx *ready, int *pn_ready,\n   return issue_rate;\n }\n \n-\f\n+static bool\n+ix86_class_likely_spilled_p (reg_class_t);\n+\n+/* Returns true if lhs of insn is HW function argument register and set up\n+   is_spilled to true if it is likely spilled HW register.  */\n+static bool\n+insn_is_function_arg (rtx insn, bool* is_spilled)\n+{\n+  rtx dst;\n+\n+  if (!NONDEBUG_INSN_P (insn))\n+    return false;\n+  insn = PATTERN (insn);\n+  if (GET_CODE (insn) == PARALLEL)\n+    insn = XVECEXP (insn, 0, 0);\n+  if (GET_CODE (insn) != SET)\n+    return false;\n+  dst = SET_DEST (insn);\n+  if (REG_P (dst) && HARD_REGISTER_P (dst)\n+      && ix86_function_arg_regno_p (REGNO (dst)))\n+    {\n+      /* Is it likely spilled HW register?  */\n+      if (!TEST_HARD_REG_BIT (fixed_reg_set, REGNO (dst))\n+\t  && ix86_class_likely_spilled_p (REGNO_REG_CLASS (REGNO (dst))))\n+\t*is_spilled = true;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Add output dependencies for chain of function adjacent arguments if only\n+   there is a move to likely spilled HW register.  Return first argument\n+   if at least one dependence was added or NULL otherwise.  */\n+static rtx\n+add_parameter_dependencies (rtx call, rtx head)\n+{\n+  rtx insn;\n+  rtx last = call;\n+  rtx first_arg = NULL;\n+  bool is_spilled = false;\n+\n+  /* Find nearest to call argument passing instruction.  */\n+  while (true)\n+    {\n+      last = PREV_INSN (last);\n+      if (last == head)\n+\treturn NULL;\n+      if (!NONDEBUG_INSN_P (last))\n+\tcontinue;\n+      if (insn_is_function_arg (last, &is_spilled))\n+\tbreak;\n+      return NULL;\n+    }\n+\n+  first_arg = last;\n+  while (true)\n+    {\n+      insn = PREV_INSN (last);\n+      if (!INSN_P (insn))\n+\tbreak;\n+      if (insn == head)\n+\tbreak;\n+      if (!NONDEBUG_INSN_P (insn))\n+\t{\n+\t  last = insn;\n+\t  continue;\n+\t}\n+      if (insn_is_function_arg (insn, &is_spilled))\n+\t{\n+\t  /* Add output depdendence between two function arguments if chain\n+\t     of output arguments contains likely spilled HW registers.  */\n+\t  if (is_spilled)\n+\t    add_dependence (last, insn, REG_DEP_OUTPUT);\n+\t  first_arg = last = insn;\n+\t}\n+      else\n+\tbreak;\n+    }\n+  if (!is_spilled)\n+    return NULL;\n+  return first_arg;\n+}\n+\n+/* Add output or anti dependency from insn to first_arg to restrict its code\n+   motion.  */\n+static void\n+avoid_func_arg_motion (rtx first_arg, rtx insn)\n+{\n+  rtx set;\n+  rtx tmp;\n+\n+  set = single_set (insn);\n+  if (!set)\n+    return;\n+  tmp = SET_DEST (set);\n+  if (REG_P (tmp))\n+    {\n+      /* Add output dependency to the first function argument.  */\n+      add_dependence (first_arg, insn, REG_DEP_OUTPUT);\n+      return;\n+    }\n+  /* Add anti dependency.  */\n+  add_dependence (first_arg, insn, REG_DEP_ANTI);\n+}\n+\n+/* Avoid cross block motion of function argument through adding dependency\n+   from the first non-jump instruction in bb.  */\n+static void\n+add_dependee_for_func_arg (rtx arg, basic_block bb)\n+{\n+  rtx insn = BB_END (bb);\n+\n+  while (insn)\n+    {\n+      if (NONDEBUG_INSN_P (insn) && NONJUMP_INSN_P (insn))\n+\t{\n+\t  rtx set = single_set (insn);\n+\t  if (set)\n+\t    {\n+\t      avoid_func_arg_motion (arg, insn);\n+\t      return;\n+\t    }\n+\t}\n+      if (insn == BB_HEAD (bb))\n+\treturn;\n+      insn = PREV_INSN (insn);\n+    }\n+}\n+\n+/* Hook for pre-reload schedule - avoid motion of function arguments\n+   passed in likely spilled HW registers.  */\n+static void\n+ix86_dependencies_evaluation_hook (rtx head, rtx tail)\n+{\n+  rtx insn;\n+  rtx first_arg = NULL;\n+  if (reload_completed)\n+    return;\n+  for (insn = tail; insn != head; insn = PREV_INSN (insn))\n+    if (INSN_P (insn) && CALL_P (insn))\n+      {\n+\tfirst_arg = add_parameter_dependencies (insn, head);\n+\tif (first_arg)\n+\t  {\n+\t    /* Check if first argument has dependee out of its home block.  */\n+\t    sd_iterator_def sd_it1;\n+\t    dep_t dep1;\n+\t    FOR_EACH_DEP (first_arg, SD_LIST_BACK, sd_it1, dep1)\n+\t      {\n+\t\trtx dee;\n+\t\tdee = DEP_PRO (dep1);\n+\t\tif (!NONDEBUG_INSN_P (dee))\n+\t\t  continue;\n+\t\tif (BLOCK_FOR_INSN (dee) != BLOCK_FOR_INSN (first_arg))\n+\t\t  /* Must add dependee for first argument in dee's block.  */\n+\t\t  add_dependee_for_func_arg (first_arg, BLOCK_FOR_INSN (dee));\n+\t      }\n+\t    insn = first_arg;\n+\t  }\n+      }\n+    else if (first_arg)\n+      avoid_func_arg_motion (first_arg, insn);\n+}\n+\n+/* Hook for pre-reload schedule - set priority of moves from likely spilled\n+   HW registers to maximum, to schedule them at soon as possible. These are\n+   moves from function argument registers at the top of the function entry\n+   and moves from function return value registers after call.  */\n+static int\n+ix86_adjust_priority (rtx insn, int priority)\n+{\n+  rtx set;\n+\n+  if (reload_completed)\n+    return priority;\n+\n+  if (!NONDEBUG_INSN_P (insn))\n+    return priority;\n+\n+  set = single_set (insn);\n+  if (set)\n+    {\n+      rtx tmp = SET_SRC (set);\n+      if (REG_P (tmp)\n+          && HARD_REGISTER_P (tmp)\n+          && !TEST_HARD_REG_BIT (fixed_reg_set, REGNO (tmp))\n+          && ix86_class_likely_spilled_p (REGNO_REG_CLASS (REGNO (tmp))))\n+\treturn current_sched_info->sched_max_insns_priority;\n+    }\n+\n+  return priority;\n+}\n \n /* Model decoder of Core 2/i7.\n    Below hooks for multipass scheduling (see haifa-sched.c:max_issue)\n@@ -24606,27 +24810,32 @@ ix86_sched_init_global (FILE *dump ATTRIBUTE_UNUSED,\n     case PROCESSOR_CORE2_64:\n     case PROCESSOR_COREI7_32:\n     case PROCESSOR_COREI7_64:\n-      targetm.sched.dfa_post_advance_cycle\n-\t= core2i7_dfa_post_advance_cycle;\n-      targetm.sched.first_cycle_multipass_init\n-\t= core2i7_first_cycle_multipass_init;\n-      targetm.sched.first_cycle_multipass_begin\n-\t= core2i7_first_cycle_multipass_begin;\n-      targetm.sched.first_cycle_multipass_issue\n-\t= core2i7_first_cycle_multipass_issue;\n-      targetm.sched.first_cycle_multipass_backtrack\n-\t= core2i7_first_cycle_multipass_backtrack;\n-      targetm.sched.first_cycle_multipass_end\n-\t= core2i7_first_cycle_multipass_end;\n-      targetm.sched.first_cycle_multipass_fini\n-\t= core2i7_first_cycle_multipass_fini;\n-\n-      /* Set decoder parameters.  */\n-      core2i7_secondary_decoder_max_insn_size = 8;\n-      core2i7_ifetch_block_size = 16;\n-      core2i7_ifetch_block_max_insns = 6;\n-      break;\n-\n+      /* Do not perform multipass scheduling for pre-reload schedule\n+         to save compile time.  */\n+      if (reload_completed)\n+\t{\n+\t  targetm.sched.dfa_post_advance_cycle\n+\t    = core2i7_dfa_post_advance_cycle;\n+\t  targetm.sched.first_cycle_multipass_init\n+\t    = core2i7_first_cycle_multipass_init;\n+\t  targetm.sched.first_cycle_multipass_begin\n+\t    = core2i7_first_cycle_multipass_begin;\n+\t  targetm.sched.first_cycle_multipass_issue\n+\t    = core2i7_first_cycle_multipass_issue;\n+\t  targetm.sched.first_cycle_multipass_backtrack\n+\t    = core2i7_first_cycle_multipass_backtrack;\n+\t  targetm.sched.first_cycle_multipass_end\n+\t    = core2i7_first_cycle_multipass_end;\n+\t  targetm.sched.first_cycle_multipass_fini\n+\t    = core2i7_first_cycle_multipass_fini;\n+\n+\t  /* Set decoder parameters.  */\n+\t  core2i7_secondary_decoder_max_insn_size = 8;\n+\t  core2i7_ifetch_block_size = 16;\n+\t  core2i7_ifetch_block_max_insns = 6;\n+\t  break;\n+\t}\n+      /* ... Fall through ...  */\n     default:\n       targetm.sched.dfa_post_advance_cycle = NULL;\n       targetm.sched.first_cycle_multipass_init = NULL;\n@@ -39687,6 +39896,10 @@ ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n #define TARGET_SCHED_REASSOCIATION_WIDTH ix86_reassociation_width\n #undef TARGET_SCHED_REORDER\n #define TARGET_SCHED_REORDER ix86_sched_reorder\n+#undef TARGET_SCHED_ADJUST_PRIORITY\n+#define TARGET_SCHED_ADJUST_PRIORITY ix86_adjust_priority\n+#undef TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK\n+#define TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK ix86_dependencies_evaluation_hook\n \n /* The size of the dispatch window is the total number of bytes of\n    object code allowed in a window.  */"}]}