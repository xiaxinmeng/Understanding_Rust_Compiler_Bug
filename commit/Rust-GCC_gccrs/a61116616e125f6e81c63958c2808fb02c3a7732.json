{"sha": "a61116616e125f6e81c63958c2808fb02c3a7732", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYxMTE2NjE2ZTEyNWY2ZTgxYzYzOTU4YzI4MDhmYjAyYzNhNzczMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2003-11-17T19:39:46Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2003-11-17T19:39:46Z"}, "message": "init.c (build_new_1): Preevaluate placement args.\n\n        * init.c (build_new_1): Preevaluate placement args.\n        * call.c (build_op_delete_call): Don't expose placement args to\n        overload resolution.\n\nFrom-SVN: r73677", "tree": {"sha": "037654a20e1f76da2e82ffce707aa83688a138d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/037654a20e1f76da2e82ffce707aa83688a138d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a61116616e125f6e81c63958c2808fb02c3a7732", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61116616e125f6e81c63958c2808fb02c3a7732", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a61116616e125f6e81c63958c2808fb02c3a7732", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61116616e125f6e81c63958c2808fb02c3a7732/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47fcfa7bc18a4e8d9ee1897280dfda88d65d6c1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47fcfa7bc18a4e8d9ee1897280dfda88d65d6c1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47fcfa7bc18a4e8d9ee1897280dfda88d65d6c1b"}], "stats": {"total": 95, "additions": 71, "deletions": 24}, "files": [{"sha": "e143dea0ec936a3b7101b434b098143957b7d151", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61116616e125f6e81c63958c2808fb02c3a7732/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61116616e125f6e81c63958c2808fb02c3a7732/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a61116616e125f6e81c63958c2808fb02c3a7732", "patch": "@@ -1,3 +1,9 @@\n+2003-11-17  Jason Merrill  <jason@redhat.com>\n+\n+\t* init.c (build_new_1): Preevaluate placement args.\n+\t* call.c (build_op_delete_call): Don't expose placement args to\n+\toverload resolution.\n+\n 2003-11-16  Jason Merrill  <jason@redhat.com>\n \n \t* Make-lang.in (c++.tags): Create TAGS.sub files in each directory"}, {"sha": "354eb8bb71a51c58120932dacce06088c28db4fa", "filename": "gcc/cp/call.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61116616e125f6e81c63958c2808fb02c3a7732/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61116616e125f6e81c63958c2808fb02c3a7732/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a61116616e125f6e81c63958c2808fb02c3a7732", "patch": "@@ -3824,10 +3824,6 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \n       /* Find the allocation function that is being called.  */\n       call_expr = placement;\n-      /* Sometimes we have a COMPOUND_EXPR, rather than a simple\n-\t CALL_EXPR.  */\n-      while (TREE_CODE (call_expr) == COMPOUND_EXPR)\n-\tcall_expr = TREE_OPERAND (call_expr, 1);\n       /* Extract the function.  */\n       alloc_fn = get_callee_fndecl (call_expr);\n       my_friendly_assert (alloc_fn != NULL_TREE, 20020327);\n@@ -3910,7 +3906,15 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \targs = tree_cons (NULL_TREE, addr, \n \t\t\t  build_tree_list (NULL_TREE, size));\n \n-      return build_function_call (fn, args);\n+      if (placement)\n+\t{\n+\t  /* The placement args might not be suitable for overload\n+\t     resolution at this point, so build the call directly.  */\n+\t  mark_used (fn);\n+\t  return build_cxx_call (fn, args, args);\n+\t}\n+      else\n+\treturn build_function_call (fn, args);\n     }\n \n   /* If we are doing placement delete we do nothing if we don't find a"}, {"sha": "332c518c76c20872e3656dd6a8c312fabf3a9ac1", "filename": "gcc/cp/init.c", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61116616e125f6e81c63958c2808fb02c3a7732/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61116616e125f6e81c63958c2808fb02c3a7732/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a61116616e125f6e81c63958c2808fb02c3a7732", "patch": "@@ -2060,13 +2060,22 @@ build_new_1 (tree exp)\n   if (alloc_call == error_mark_node)\n     return error_mark_node;\n \n-  /* The ALLOC_CALL should be a CALL_EXPR -- or a COMPOUND_EXPR whose\n-     right-hand-side is ultimately a CALL_EXPR -- and the first\n-     operand should be the address of a known FUNCTION_DECL.  */\n-  t = alloc_call;\n-  while (TREE_CODE (t) == COMPOUND_EXPR) \n-    t = TREE_OPERAND (t, 1);\n-  alloc_fn = get_callee_fndecl (t);\n+  /* In the simple case, we can stop now.  */\n+  pointer_type = build_pointer_type (type);\n+  if (!cookie_size && !is_initialized)\n+    return build_nop (pointer_type, alloc_call);\n+\n+  /* While we're working, use a pointer to the type we've actually\n+     allocated. Store the result of the call in a variable so that we\n+     can use it more than once.  */\n+  full_pointer_type = build_pointer_type (full_type);\n+  alloc_expr = get_target_expr (build_nop (full_pointer_type, alloc_call));\n+  alloc_node = TARGET_EXPR_SLOT (alloc_expr);\n+\n+  /* Strip any COMPOUND_EXPRs from ALLOC_CALL.  */\n+  while (TREE_CODE (alloc_call) == COMPOUND_EXPR) \n+    alloc_call = TREE_OPERAND (alloc_call, 1);\n+  alloc_fn = get_callee_fndecl (alloc_call);\n   my_friendly_assert (alloc_fn != NULL_TREE, 20020325);\n \n   /* Now, check to see if this function is actually a placement\n@@ -2083,6 +2092,27 @@ build_new_1 (tree exp)\n     = (type_num_arguments (TREE_TYPE (alloc_fn)) > 1 \n        || varargs_function_p (alloc_fn));\n \n+  /* Preevaluate the placement args so that we don't reevaluate them for a\n+     placement delete.  */\n+  if (placement_allocation_fn_p)\n+    {\n+      tree inits = NULL_TREE;\n+      t = TREE_CHAIN (TREE_OPERAND (alloc_call, 1));\n+      for (; t; t = TREE_CHAIN (t))\n+\tif (TREE_SIDE_EFFECTS (TREE_VALUE (t)))\n+\t  {\n+\t    tree init;\n+\t    TREE_VALUE (t) = stabilize_expr (TREE_VALUE (t), &init);\n+\t    if (inits)\n+\t      inits = build (COMPOUND_EXPR, void_type_node, inits, init);\n+\t    else\n+\t      inits = init;\n+\t  }\n+      if (inits)\n+\talloc_expr = build (COMPOUND_EXPR, TREE_TYPE (alloc_expr), inits,\n+\t\t\t    alloc_expr);\n+    }\n+\n   /*        unless an allocation function is declared with an empty  excep-\n      tion-specification  (_except.spec_),  throw(), it indicates failure to\n      allocate storage by throwing a bad_alloc exception  (clause  _except_,\n@@ -2096,18 +2126,6 @@ build_new_1 (tree exp)\n   nothrow = TYPE_NOTHROW_P (TREE_TYPE (alloc_fn));\n   check_new = (flag_check_new || nothrow) && ! use_java_new;\n \n-  /* In the simple case, we can stop now.  */\n-  pointer_type = build_pointer_type (type);\n-  if (!cookie_size && !is_initialized)\n-    return build_nop (pointer_type, alloc_call);\n-\n-  /* While we're working, use a pointer to the type we've actually\n-     allocated. Store the result of the call in a variable so that we\n-     can use it more than once.  */\n-  full_pointer_type = build_pointer_type (full_type);\n-  alloc_expr = get_target_expr (build_nop (full_pointer_type, alloc_call));\n-  alloc_node = TARGET_EXPR_SLOT (alloc_expr);\n-\n   if (cookie_size)\n     {\n       tree cookie;"}, {"sha": "bca741575c8d5e4ac80110c81297032d49dbb520", "filename": "gcc/testsuite/g++.dg/init/placement2.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61116616e125f6e81c63958c2808fb02c3a7732/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fplacement2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61116616e125f6e81c63958c2808fb02c3a7732/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fplacement2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fplacement2.C?ref=a61116616e125f6e81c63958c2808fb02c3a7732", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do run }\n+\n+void* operator new    (unsigned int sz, void*) { return operator new (sz); }\n+void  operator delete (void* p, void*)         { operator delete (p); }\n+\n+struct A { A() { throw 1; } };\n+\n+int c;\n+void *f() { ++c; return 0; }\n+\n+int main()\n+{\n+  try\n+    {\n+      new (f()) A;\n+    }\n+  catch (...) {}\n+  return c != 1;\n+}"}]}