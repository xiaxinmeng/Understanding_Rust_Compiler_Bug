{"sha": "d2b1a6842c35c6e790a61291ca1a6aad3333a523", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJiMWE2ODQyYzM1YzZlNzkwYTYxMjkxY2ExYTZhYWQzMzMzYTUyMw==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-11-30T19:57:16Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2021-02-09T20:56:27Z"}, "message": "libstdc++: Add unordered containers heterogeneous lookup\n\nAdd unordered containers heterogeneous lookup member functions find, count, contains and\nequal_range in C++20. Those members are considered for overload resolution only if hash and\nequal functors used to instantiate the container have a nested is_transparent type.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/stl_tree.h\n\t(__has_is_transparent, __has_is_transparent_t): Move...\n\t* include/bits/stl_function.h: ...here.\n\t* include/bits/hashtable_policy.h (_Hash_code_base<>::_M_hash_code_tr): New..\n\t(_Hashtable_base<>::_M_equals_tr): New.\n\t* include/bits/hashtable.h (_Hashtable<>::_M_find_tr, _Hashtable<>::_M_count_tr,\n\t_Hashtable<>::_M_equal_range_tr): New member function templates to perform\n\theterogeneous lookup.\n\t(_Hashtable<>::_M_find_before_node_tr): New.\n\t(_Hashtable<>::_M_find_node_tr): New.\n\t* include/bits/unordered_map.h (unordered_map::find<>, unordered_map::count<>,\n\tunordered_map::contains<>, unordered_map::equal_range<>): New member function\n\ttemplates to perform heterogeneous lookup.\n\t(unordered_multimap::find<>, unordered_multimap::count<>,\n\tunordered_multimap::contains<>, unordered_multimap::equal_range<>): Likewise.\n\t* include/bits/unordered_set.h  (unordered_set::find<>, unordered_set::count<>,\n\tunordered_set::contains<>, unordered_set::equal_range<>): Likewise.\n\t(unordered_multiset::find<>, unordered_multiset::count<>,\n\tunordered_multiset::contains<>, unordered_multiset::equal_range<>): Likewise.\n\t* include/debug/unordered_map\n\t(unordered_map::find<>, unordered_map::equal_range<>): Likewise.\n\t(unordered_multimap::find<>, unordered_multimap::equal_range<>): Likewise.\n\t* include/debug/unordered_set\n\t(unordered_set::find<>, unordered_set::equal_range<>): Likewise.\n\t(unordered_multiset::find<>, unordered_multiset::equal_range<>): Likewise.\n\t* testsuite/23_containers/unordered_map/operations/1.cc: New test.\n\t* testsuite/23_containers/unordered_multimap/operations/1.cc: New test.\n\t* testsuite/23_containers/unordered_multiset/operations/1.cc: New test.\n\t* testsuite/23_containers/unordered_set/operations/1.cc: New test.", "tree": {"sha": "c77ed8895bc90acf1eaf667d9140811f2769ae37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c77ed8895bc90acf1eaf667d9140811f2769ae37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2b1a6842c35c6e790a61291ca1a6aad3333a523", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2b1a6842c35c6e790a61291ca1a6aad3333a523", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2b1a6842c35c6e790a61291ca1a6aad3333a523", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2b1a6842c35c6e790a61291ca1a6aad3333a523/comments", "author": null, "committer": null, "parents": [{"sha": "f6be5d6ee31b76838e242704782938bc9745659c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6be5d6ee31b76838e242704782938bc9745659c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6be5d6ee31b76838e242704782938bc9745659c"}], "stats": {"total": 1238, "additions": 1223, "deletions": 15}, "files": [{"sha": "fa80675ad91e72e9631164639d25f7970e34823f", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=d2b1a6842c35c6e790a61291ca1a6aad3333a523", "patch": "@@ -724,6 +724,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __k) const;\n \n+#if __cplusplus > 201702L\n+      template<typename _Kt,\n+\t       typename = __has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = __has_is_transparent_t<_Equal, _Kt>>\n+\titerator\n+\t_M_find_tr(const _Kt& __k);\n+\n+      template<typename _Kt,\n+\t       typename = __has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = __has_is_transparent_t<_Equal, _Kt>>\n+\tconst_iterator\n+\t_M_find_tr(const _Kt& __k) const;\n+\n+      template<typename _Kt,\n+\t       typename = __has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = __has_is_transparent_t<_Equal, _Kt>>\n+\tsize_type\n+\t_M_count_tr(const _Kt& __k) const;\n+\n+      template<typename _Kt,\n+\t       typename = __has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = __has_is_transparent_t<_Equal, _Kt>>\n+\tpair<iterator, iterator>\n+\t_M_equal_range_tr(const _Kt& __k);\n+\n+      template<typename _Kt,\n+\t       typename = __has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = __has_is_transparent_t<_Equal, _Kt>>\n+\tpair<const_iterator, const_iterator>\n+\t_M_equal_range_tr(const _Kt& __k) const;\n+#endif\n+\n     private:\n       // Bucket index computation helpers.\n       size_type\n@@ -739,6 +771,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __node_base_ptr\n       _M_find_before_node(size_type, const key_type&, __hash_code) const;\n \n+      template<typename _Kt>\n+\t__node_base_ptr\n+\t_M_find_before_node_tr(size_type, const _Kt&, __hash_code) const;\n+\n       __node_ptr\n       _M_find_node(size_type __bkt, const key_type& __key,\n \t\t   __hash_code __c) const\n@@ -749,6 +785,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn nullptr;\n       }\n \n+      template<typename _Kt>\n+\t__node_ptr\n+\t_M_find_node_tr(size_type __bkt, const _Kt& __key,\n+\t\t\t__hash_code __c) const\n+\t{\n+\t  auto __before_n = _M_find_before_node_tr(__bkt, __key, __c);\n+\t  if (__before_n)\n+\t    return static_cast<__node_ptr>(__before_n->_M_nxt);\n+\t  return nullptr;\n+\t}\n+\n       // Insert a node at the beginning of a bucket.\n       void\n       _M_insert_bucket_begin(size_type, __node_ptr);\n@@ -1532,6 +1579,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return const_iterator(_M_find_node(__bkt, __k, __code));\n     }\n \n+#if __cplusplus > 201703L\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n+    template<typename _Kt, typename, typename>\n+      auto\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+      _M_find_tr(const _Kt& __k)\n+      -> iterator\n+      {\n+\t__hash_code __code = this->_M_hash_code_tr(__k);\n+\tstd::size_t __bkt = _M_bucket_index(__code);\n+\treturn iterator(_M_find_node_tr(__bkt, __k, __code));\n+      }\n+\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n+    template<typename _Kt, typename, typename>\n+      auto\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+      _M_find_tr(const _Kt& __k) const\n+      -> const_iterator\n+      {\n+\t__hash_code __code = this->_M_hash_code_tr(__k);\n+\tstd::size_t __bkt = _M_bucket_index(__code);\n+\treturn const_iterator(_M_find_node_tr(__bkt, __k, __code));\n+      }\n+#endif\n+\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n \t   typename _Hash, typename _RangeHash, typename _Unused,\n@@ -1561,6 +1642,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __result;\n     }\n \n+#if __cplusplus > 201703L\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n+    template<typename _Kt, typename, typename>\n+      auto\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+      _M_count_tr(const _Kt& __k) const\n+      -> size_type\n+      {\n+\t__hash_code __code = this->_M_hash_code_tr(__k);\n+\tstd::size_t __bkt = _M_bucket_index(__code);\n+\tauto __n = _M_find_node_tr(__bkt, __k, __code);\n+\tif (!__n)\n+\t  return 0;\n+\n+\t// All equivalent values are next to each other, if we find a\n+\t// non-equivalent value after an equivalent one it means that we won't\n+\t// find any new equivalent value.\n+\titerator __it(__n);\n+\tsize_type __result = 1;\n+\tfor (++__it;\n+\t     __it._M_cur && this->_M_equals_tr(__k, __code, *__it._M_cur);\n+\t     ++__it)\n+\t  ++__result;\n+\n+\treturn __result;\n+      }\n+#endif\n+\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n \t   typename _Hash, typename _RangeHash, typename _Unused,\n@@ -1615,6 +1728,64 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return { __beg, __ite };\n     }\n \n+#if __cplusplus > 201703L\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n+    template<typename _Kt, typename, typename>\n+      auto\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+      _M_equal_range_tr(const _Kt& __k)\n+      -> pair<iterator, iterator>\n+      {\n+\t__hash_code __code = this->_M_hash_code_tr(__k);\n+\tstd::size_t __bkt = _M_bucket_index(__code);\n+\tauto __n = _M_find_node_tr(__bkt, __k, __code);\n+\titerator __ite(__n);\n+\tif (!__n)\n+\t  return { __ite, __ite };\n+\n+\t// All equivalent values are next to each other, if we find a\n+\t// non-equivalent value after an equivalent one it means that we won't\n+\t// find any new equivalent value.\n+\tauto __beg = __ite++;\n+\twhile (__ite._M_cur && this->_M_equals_tr(__k, __code, *__ite._M_cur))\n+\t  ++__ite;\n+\n+\treturn { __beg, __ite };\n+      }\n+\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n+    template<typename _Kt, typename, typename>\n+      auto\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+      _M_equal_range_tr(const _Kt& __k) const\n+      -> pair<const_iterator, const_iterator>\n+      {\n+\t__hash_code __code = this->_M_hash_code_tr(__k);\n+\tstd::size_t __bkt = _M_bucket_index(__code);\n+\tauto __n = _M_find_node_tr(__bkt, __k, __code);\n+\tconst_iterator __ite(__n);\n+\tif (!__n)\n+\t  return { __ite, __ite };\n+\n+\t// All equivalent values are next to each other, if we find a\n+\t// non-equivalent value after an equivalent one it means that we won't\n+\t// find any new equivalent value.\n+\tauto __beg = __ite++;\n+\twhile (__ite._M_cur && this->_M_equals_tr(__k, __code, *__ite._M_cur))\n+\t  ++__ite;\n+\n+\treturn { __beg, __ite };\n+      }\n+#endif\n+\n   // Find the node before the one whose key compares equal to k in the bucket\n   // bkt. Return nullptr if no node is found.\n   template<typename _Key, typename _Value, typename _Alloc,\n@@ -1646,6 +1817,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return nullptr;\n     }\n \n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n+    template<typename _Kt>\n+      auto\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+      _M_find_before_node_tr(size_type __bkt, const _Kt& __k,\n+\t\t\t     __hash_code __code) const\n+      -> __node_base_ptr\n+      {\n+\t__node_base_ptr __prev_p = _M_buckets[__bkt];\n+\tif (!__prev_p)\n+\t  return nullptr;\n+\n+\tfor (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;\n+\t     __p = __p->_M_next())\n+\t  {\n+\t    if (this->_M_equals_tr(__k, __code, *__p))\n+\t      return __prev_p;\n+\n+\t    if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)\n+\t      break;\n+\t    __prev_p = __p;\n+\t  }\n+\n+\treturn nullptr;\n+      }\n+\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n \t   typename _Hash, typename _RangeHash, typename _Unused,"}, {"sha": "90797f8dbda572169bcfab49f3a2753440461b4d", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=d2b1a6842c35c6e790a61291ca1a6aad3333a523", "patch": "@@ -1217,6 +1217,15 @@ namespace __detail\n \treturn _M_hash()(__k);\n       }\n \n+      template<typename _Kt>\n+\t__hash_code\n+\t_M_hash_code_tr(const _Kt& __k) const\n+\t{\n+\t  static_assert(__is_invocable<const _Hash&, const _Kt&>{},\n+\t    \"hash function must be invocable with an argument of key type\");\n+\t  return _M_hash()(__k);\n+\t}\n+\n       std::size_t\n       _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const\n       { return _RangeHash{}(__c, __bkt_count); }\n@@ -1605,6 +1614,19 @@ namespace __detail\n \treturn _S_equals(__c, __n) && _M_eq()(__k, _ExtractKey{}(__n._M_v()));\n       }\n \n+      template<typename _Kt>\n+\tbool\n+\t_M_equals_tr(const _Kt& __k, __hash_code __c,\n+\t\t     const _Hash_node_value<_Value,\n+\t\t\t\t\t    __hash_cached::value>& __n) const\n+\t{\n+\t  static_assert(\n+\t    __is_invocable<const _Equal&, const _Kt&, const _Key&>{},\n+\t    \"key equality predicate must be invocable with two arguments of \"\n+\t    \"key type\");\n+\t  return _S_equals(__c, __n) && _M_eq()(__k, _ExtractKey{}(__n._M_v()));\n+\t}\n+\n       bool\n       _M_node_equals(\n \tconst _Hash_node_value<_Value, __hash_cached::value>& __lhn,"}, {"sha": "073018d522d7d5f9f9bed3ac8381b7935ab5c72e", "filename": "libstdc++-v3/include/bits/stl_function.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h?ref=d2b1a6842c35c6e790a61291ca1a6aad3333a523", "patch": "@@ -1385,6 +1385,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /** @}  */\n \n+#if __cplusplus >= 201402L\n+  template<typename _Func, typename _SfinaeType, typename = __void_t<>>\n+    struct __has_is_transparent\n+    { };\n+\n+  template<typename _Func, typename _SfinaeType>\n+    struct __has_is_transparent<_Func, _SfinaeType,\n+\t\t\t\t__void_t<typename _Func::is_transparent>>\n+    { typedef void type; };\n+\n+  template<typename _Func, typename _SfinaeType>\n+    using __has_is_transparent_t\n+      = typename __has_is_transparent<_Func, _SfinaeType>::type;\n+#endif\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n "}, {"sha": "550195a2749d07b3cf04c3c409777f41967215c0", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=d2b1a6842c35c6e790a61291ca1a6aad3333a523", "patch": "@@ -415,21 +415,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,\n \t\t\t       _Rb_tree_node_base& __header) throw ();\n \n-#if __cplusplus >= 201402L\n-  template<typename _Cmp, typename _SfinaeType, typename = __void_t<>>\n-    struct __has_is_transparent\n-    { };\n-\n-  template<typename _Cmp, typename _SfinaeType>\n-    struct __has_is_transparent<_Cmp, _SfinaeType,\n-\t\t\t\t__void_t<typename _Cmp::is_transparent>>\n-    { typedef void type; };\n-\n-  template<typename _Cmp, typename _SfinaeType>\n-    using __has_is_transparent_t\n-      = typename __has_is_transparent<_Cmp, _SfinaeType>::type;\n-#endif\n-\n #if __cplusplus > 201402L\n   template<typename _Tree1, typename _Cmp2>\n     struct _Rb_tree_merge_helper { };"}, {"sha": "d617d2d923d8542f16856f4cb40700562dde1cc5", "filename": "libstdc++-v3/include/bits/unordered_map.h", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h?ref=d2b1a6842c35c6e790a61291ca1a6aad3333a523", "patch": "@@ -868,11 +868,26 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       find(const key_type& __x)\n       { return _M_h.find(__x); }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __x) -> decltype(_M_h._M_find_tr(__x))\n+\t{ return _M_h._M_find_tr(__x); }\n+#endif\n+\n       const_iterator\n       find(const key_type& __x) const\n       { return _M_h.find(__x); }\n+\n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __x) const -> decltype(_M_h._M_find_tr(__x))\n+\t{ return _M_h._M_find_tr(__x); }\n+#endif\n       //@}\n \n+      //@{\n       /**\n        *  @brief  Finds the number of elements.\n        *  @param  __x  Key to count.\n@@ -887,6 +902,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { return _M_h.count(__x); }\n \n #if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tcount(const _Kt& __x) const -> decltype(_M_h._M_count_tr(__x))\n+\t{ return _M_h._M_count_tr(__x); }\n+#endif\n+      //@}\n+\n+#if __cplusplus > 201703L\n+      //@{\n       /**\n        *  @brief  Finds whether an element with the given key exists.\n        *  @param  __x  Key of elements to be located.\n@@ -895,6 +919,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       bool\n       contains(const key_type& __x) const\n       { return _M_h.find(__x) != _M_h.end(); }\n+\n+      template<typename _Kt>\n+\tauto\n+\tcontains(const _Kt& __x) const\n+\t-> decltype(_M_h._M_find_tr(__x), void(), true)\n+\t{ return _M_h._M_find_tr(__x) != _M_h.end(); }\n+      //@}\n #endif\n \n       //@{\n@@ -910,9 +941,25 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       equal_range(const key_type& __x)\n       { return _M_h.equal_range(__x); }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __x)\n+\t-> decltype(_M_h._M_equal_range_tr(__x))\n+\t{ return _M_h._M_equal_range_tr(__x); }\n+#endif\n+\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __x) const\n       { return _M_h.equal_range(__x); }\n+\n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __x) const\n+\t-> decltype(_M_h._M_equal_range_tr(__x))\n+\t{ return _M_h._M_equal_range_tr(__x); }\n+#endif\n       //@}\n \n       //@{\n@@ -1764,11 +1811,26 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       find(const key_type& __x)\n       { return _M_h.find(__x); }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __x) -> decltype(_M_h._M_find_tr(__x))\n+\t{ return _M_h._M_find_tr(__x); }\n+#endif\n+\n       const_iterator\n       find(const key_type& __x) const\n       { return _M_h.find(__x); }\n+\n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __x) const -> decltype(_M_h._M_find_tr(__x))\n+\t{ return _M_h._M_find_tr(__x); }\n+#endif\n       //@}\n \n+      //@{\n       /**\n        *  @brief  Finds the number of elements.\n        *  @param  __x  Key to count.\n@@ -1779,6 +1841,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { return _M_h.count(__x); }\n \n #if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tcount(const _Kt& __x) const -> decltype(_M_h._M_count_tr(__x))\n+\t{ return _M_h._M_count_tr(__x); }\n+#endif\n+      //@}\n+\n+#if __cplusplus > 201703L\n+      //@{\n       /**\n        *  @brief  Finds whether an element with the given key exists.\n        *  @param  __x  Key of elements to be located.\n@@ -1787,6 +1858,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       bool\n       contains(const key_type& __x) const\n       { return _M_h.find(__x) != _M_h.end(); }\n+\n+      template<typename _Kt>\n+\tauto\n+\tcontains(const _Kt& __x) const\n+\t-> decltype(_M_h._M_find_tr(__x), void(), true)\n+\t{ return _M_h._M_find_tr(__x) != _M_h.end(); }\n+      //@}\n #endif\n \n       //@{\n@@ -1800,9 +1878,25 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       equal_range(const key_type& __x)\n       { return _M_h.equal_range(__x); }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __x)\n+\t-> decltype(_M_h._M_equal_range_tr(__x))\n+\t{ return _M_h._M_equal_range_tr(__x); }\n+#endif\n+\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __x) const\n       { return _M_h.equal_range(__x); }\n+\n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __x) const\n+\t-> decltype(_M_h._M_equal_range_tr(__x))\n+\t{ return _M_h._M_equal_range_tr(__x); }\n+#endif\n       //@}\n \n       // bucket interface."}, {"sha": "63c1a7efd8ad2499d934cd8c327c426d5ca16f39", "filename": "libstdc++-v3/include/bits/unordered_set.h", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h?ref=d2b1a6842c35c6e790a61291ca1a6aad3333a523", "patch": "@@ -650,11 +650,28 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       find(const key_type& __x)\n       { return _M_h.find(__x); }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __k)\n+\t-> decltype(_M_h._M_find_tr(__k))\n+\t{ return _M_h._M_find_tr(__k); }\n+#endif\n+\n       const_iterator\n       find(const key_type& __x) const\n       { return _M_h.find(__x); }\n+\n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __k) const\n+\t-> decltype(_M_h._M_find_tr(__k))\n+\t{ return _M_h._M_find_tr(__k); }\n+#endif\n       //@}\n \n+      //@{\n       /**\n        *  @brief  Finds the number of elements.\n        *  @param  __x  Element to located.\n@@ -669,6 +686,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { return _M_h.count(__x); }\n \n #if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tcount(const _Kt& __k) const\n+\t-> decltype(_M_h._M_count_tr(__k))\n+\t{ return _M_h._M_count_tr(__k); }\n+#endif\n+      //@}\n+\n+#if __cplusplus > 201703L\n+      //@{\n       /**\n        *  @brief  Finds whether an element with the given key exists.\n        *  @param  __x  Key of elements to be located.\n@@ -677,6 +704,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       bool\n       contains(const key_type& __x) const\n       { return _M_h.find(__x) != _M_h.end(); }\n+\n+      template<typename _Kt>\n+\tauto\n+\tcontains(const _Kt& __k) const\n+\t-> decltype(_M_h._M_find_tr(__k), void(), true)\n+\t{ return _M_h._M_find_tr(__k) != _M_h.end(); }\n+      //@}\n #endif\n \n       //@{\n@@ -692,9 +726,25 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       equal_range(const key_type& __x)\n       { return _M_h.equal_range(__x); }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __k)\n+\t-> decltype(_M_h._M_equal_range_tr(__k))\n+\t{ return _M_h._M_equal_range_tr(__k); }\n+#endif\n+\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __x) const\n       { return _M_h.equal_range(__x); }\n+\n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __k) const\n+\t-> decltype(_M_h._M_equal_range_tr(__k))\n+\t{ return _M_h._M_equal_range_tr(__k); }\n+#endif\n       //@}\n \n       // bucket interface.\n@@ -1450,11 +1500,28 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       find(const key_type& __x)\n       { return _M_h.find(__x); }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __x)\n+\t-> decltype(_M_h._M_find_tr(__x))\n+\t{ return _M_h._M_find_tr(__x); }\n+#endif\n+\n       const_iterator\n       find(const key_type& __x) const\n       { return _M_h.find(__x); }\n+\n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __x) const\n+\t-> decltype(_M_h._M_find_tr(__x))\n+\t{ return _M_h._M_find_tr(__x); }\n+#endif\n       //@}\n \n+      //@{\n       /**\n        *  @brief  Finds the number of elements.\n        *  @param  __x  Element to located.\n@@ -1465,6 +1532,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { return _M_h.count(__x); }\n \n #if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tcount(const _Kt& __x) const -> decltype(_M_h._M_count_tr(__x))\n+\t{ return _M_h._M_count_tr(__x); }\n+#endif\n+      //@}\n+\n+#if __cplusplus > 201703L\n+      //@{\n       /**\n        *  @brief  Finds whether an element with the given key exists.\n        *  @param  __x  Key of elements to be located.\n@@ -1473,6 +1549,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       bool\n       contains(const key_type& __x) const\n       { return _M_h.find(__x) != _M_h.end(); }\n+\n+      template<typename _Kt>\n+\tauto\n+\tcontains(const _Kt& __x) const\n+\t-> decltype(_M_h._M_find_tr(__x), void(), true)\n+\t{ return _M_h._M_find_tr(__x) != _M_h.end(); }\n+      //@}\n #endif\n \n       //@{\n@@ -1486,9 +1569,25 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       equal_range(const key_type& __x)\n       { return _M_h.equal_range(__x); }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __x)\n+\t-> decltype(_M_h._M_equal_range_tr(__x))\n+\t{ return _M_h._M_equal_range_tr(__x); }\n+#endif\n+\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __x) const\n       { return _M_h.equal_range(__x); }\n+\n+#if __cplusplus > 201703L\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __x) const\n+\t-> decltype(_M_h._M_equal_range_tr(__x))\n+\t{ return _M_h._M_equal_range_tr(__x); }\n+#endif\n       //@}\n \n       // bucket interface."}, {"sha": "bb697d364ea3336280659c7cf54ffd67046f8d39", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=d2b1a6842c35c6e790a61291ca1a6aad3333a523", "patch": "@@ -545,24 +545,66 @@ namespace __debug\n       find(const key_type& __key)\n       { return { _Base::find(__key), this }; }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\titerator\n+\tfind(const _Kt& __k)\n+\t{ return { _Base::find(__k), this }; }\n+#endif\n+\n       const_iterator\n       find(const key_type& __key) const\n       { return { _Base::find(__key), this }; }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\tconst_iterator\n+\tfind(const _Kt& __k) const\n+\t{ return { _Base::find(__k), this }; }\n+#endif\n+\n       std::pair<iterator, iterator>\n       equal_range(const key_type& __key)\n       {\n \tauto __res = _Base::equal_range(__key);\n \treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\tstd::pair<iterator, iterator>\n+\tequal_range(const _Kt& __k)\n+\t{\n+\t  auto __res = _Base::equal_range(__k);\n+\t  return { { __res.first, this }, { __res.second, this } };\n+\t}\n+#endif\n+\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __key) const\n       {\n \tauto __res = _Base::equal_range(__key);\n \treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\tstd::pair<const_iterator, const_iterator>\n+\tequal_range(const _Kt& __k) const\n+\t{\n+\t  auto __res = _Base::equal_range(__k);\n+\t  return { { __res.first, this }, { __res.second, this } };\n+\t}\n+#endif\n+\n       size_type\n       erase(const key_type& __key)\n       {\n@@ -1157,24 +1199,66 @@ namespace __debug\n       find(const key_type& __key)\n       { return { _Base::find(__key), this }; }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\titerator\n+\tfind(const _Kt& __k)\n+\t{ return { _Base::find(__k), this }; }\n+#endif\n+\n       const_iterator\n       find(const key_type& __key) const\n       { return { _Base::find(__key), this }; }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\tconst_iterator\n+\tfind(const _Kt& __k) const\n+\t{ return { _Base::find(__k), this }; }\n+#endif\n+\n       std::pair<iterator, iterator>\n       equal_range(const key_type& __key)\n       {\n \tauto __res = _Base::equal_range(__key);\n \treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\tstd::pair<iterator, iterator>\n+\tequal_range(const _Kt& __k)\n+\t{\n+\t  auto __res = _Base::equal_range(__k);\n+\t  return { { __res.first, this }, { __res.second, this } };\n+\t}\n+#endif\n+\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __key) const\n       {\n \tauto __res = _Base::equal_range(__key);\n \treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\tstd::pair<const_iterator, const_iterator>\n+\tequal_range(const _Kt& __k) const\n+\t{\n+\t  auto __res = _Base::equal_range(__k);\n+\t  return { { __res.first, this }, { __res.second, this } };\n+\t}\n+#endif\n+\n       size_type\n       erase(const key_type& __key)\n       {"}, {"sha": "c25910946b72dc08fd942d3260e017233ec29b3f", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=d2b1a6842c35c6e790a61291ca1a6aad3333a523", "patch": "@@ -430,24 +430,66 @@ namespace __debug\n       find(const key_type& __key)\n       { return { _Base::find(__key), this }; }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\titerator\n+\tfind(const _Kt& __k)\n+\t{ return { _Base::find(__k), this }; }\n+#endif\n+\n       const_iterator\n       find(const key_type& __key) const\n       { return { _Base::find(__key), this }; }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\tconst_iterator\n+\tfind(const _Kt& __k) const\n+\t{ return { _Base::find(__k), this }; }\n+#endif\n+\n       std::pair<iterator, iterator>\n       equal_range(const key_type& __key)\n       {\n \tauto __res = _Base::equal_range(__key);\n \treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\tstd::pair<iterator, iterator>\n+\tequal_range(const _Kt& __k)\n+\t{\n+\t  auto __res = _Base::equal_range(__k);\n+\t  return { { __res.first, this }, { __res.second, this } };\n+\t}\n+#endif\n+\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __key) const\n       {\n \tauto __res = _Base::equal_range(__key);\n \treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\tstd::pair<const_iterator, const_iterator>\n+\tequal_range(const _Kt& __k) const\n+\t{\n+\t  auto __res = _Base::equal_range(__k);\n+\t  return { { __res.first, this }, { __res.second, this } };\n+\t}\n+#endif\n+\n       size_type\n       erase(const key_type& __key)\n       {\n@@ -1002,24 +1044,66 @@ namespace __debug\n       find(const key_type& __key)\n       { return { _Base::find(__key), this }; }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\titerator\n+\tfind(const _Kt& __k)\n+\t{ return { _Base::find(__k), this }; }\n+#endif\n+\n       const_iterator\n       find(const key_type& __key) const\n       { return { _Base::find(__key), this }; }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\tconst_iterator\n+\tfind(const _Kt& __k) const\n+\t{ return { _Base::find(__k), this }; }\n+#endif\n+\n       std::pair<iterator, iterator>\n       equal_range(const key_type& __key)\n       {\n \tauto __res = _Base::equal_range(__key);\n \treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\tstd::pair<iterator, iterator>\n+\tequal_range(const _Kt& __k)\n+\t{\n+\t  auto __res = _Base::equal_range(__k);\n+\t  return { { __res.first, this }, { __res.second, this } };\n+\t}\n+#endif\n+\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __key) const\n       {\n \tauto __res = _Base::equal_range(__key);\n \treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n+#if __cplusplus > 201703L\n+      template<typename _Kt,\n+\t       typename = std::__has_is_transparent_t<_Hash, _Kt>,\n+\t       typename = std::__has_is_transparent_t<_Pred, _Kt>>\n+\tstd::pair<const_iterator, const_iterator>\n+\tequal_range(const _Kt& __k) const\n+\t{\n+\t  auto __res = _Base::equal_range(__k);\n+\t  return { { __res.first, this }, { __res.second, this } };\n+\t}\n+#endif\n+\n       size_type\n       erase(const key_type& __key)\n       {"}, {"sha": "4f2df728ebb4094a28ac45194119f51adbb9e341", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/operations/1.cc", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Foperations%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Foperations%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Foperations%2F1.cc?ref=d2b1a6842c35c6e790a61291ca1a6aad3333a523", "patch": "@@ -0,0 +1,168 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++20 } }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+struct Equal\n+{\n+  typedef void is_transparent;\n+\n+  bool operator()(int i, long l) const { return i == l; }\n+  bool operator()(long l, int i) const { return l == i; }\n+  bool operator()(int i, int j) const { ++count; return i == j; }\n+\n+  static int count;\n+};\n+\n+int Equal::count = 0;\n+\n+struct Hash\n+{\n+  typedef void is_transparent;\n+\n+  std::size_t operator()(int i) const { ++count; return i; }\n+  std::size_t operator()(long l) const { return l; }\n+\n+  static int count;\n+};\n+\n+int Hash::count = 0;\n+\n+using test_type = std::unordered_map<int, char, Hash, Equal>;\n+\n+test_type x{ { 1, '2' }, { 3, '4' } };\n+const test_type& cx = x;\n+\n+void\n+test01()\n+{\n+  Hash::count = 0;\n+  Equal::count = 0;\n+\n+  VERIFY( x.contains(1L) );\n+\n+  auto it = x.find(1L);\n+  VERIFY( it != x.end() && it->second == '2' );\n+  it = x.find(2L);\n+  VERIFY( it == x.end() );\n+\n+  auto cit = cx.find(3L);\n+  VERIFY( cit != cx.end() && cit->second == '4' );\n+  cit = cx.find(2L);\n+  VERIFY( cit == cx.end() );\n+\n+  VERIFY( Hash::count == 0 );\n+  VERIFY( Equal::count == 0 );\n+\n+  static_assert(std::is_same<decltype(it), test_type::iterator>::value,\n+      \"find returns iterator\");\n+  static_assert(std::is_same<decltype(cit), test_type::const_iterator>::value,\n+      \"const find returns const_iterator\");\n+}\n+\n+void\n+test02()\n+{\n+  Hash::count = 0;\n+  Equal::count = 0;\n+\n+  auto n = x.count(1L);\n+  VERIFY( n == 1 );\n+  n = x.count(2L);\n+  VERIFY( n == 0 );\n+\n+  auto cn = cx.count(3L);\n+  VERIFY( cn == 1 );\n+  cn = cx.count(2L);\n+  VERIFY( cn == 0 );\n+\n+  VERIFY( Hash::count == 0 );\n+  VERIFY( Equal::count == 0 );\n+}\n+\n+void\n+test03()\n+{\n+  Hash::count = 0;\n+  Equal::count = 0;\n+\n+  auto it = x.equal_range(1L);\n+  VERIFY( it.first != it.second && it.first->second == '2' );\n+  it = x.equal_range(2L);\n+  VERIFY( it.first == it.second && it.first == x.end() );\n+\n+  auto cit = cx.equal_range(1L);\n+  VERIFY( cit.first != cit.second && cit.first->second == '2' );\n+  cit = cx.equal_range(2L);\n+  VERIFY( cit.first == cit.second && cit.first == cx.end() );\n+\n+  VERIFY( Hash::count == 0 );\n+  VERIFY( Equal::count == 0 );\n+\n+  using pair = std::pair<test_type::iterator, test_type::iterator>;\n+  static_assert(std::is_same<decltype(it), pair>::value,\n+      \"equal_range returns pair<iterator, iterator>\");\n+  using cpair = std::pair<test_type::const_iterator, test_type::const_iterator>;\n+  static_assert(std::is_same<decltype(cit), cpair>::value,\n+      \"const equal_range returns pair<const_iterator, const_iterator>\");\n+}\n+\n+void\n+test04()\n+{\n+  struct E\n+  {\n+    bool operator()(int l, int r) const { return l == r; }\n+\n+    struct Partition { };\n+\n+    bool operator()(int l, Partition) const { return l < 6; }\n+    bool operator()(Partition, int r) const { return 3 < r; }\n+\n+    using is_transparent = void;\n+  };\n+\n+  struct H\n+  {\n+    size_t\n+    operator()(int x) const\n+    { return 0; }\n+\n+    size_t\n+    operator()(E::Partition) const\n+    { return 0; }\n+\n+    using is_transparent = void;\n+  };\n+\n+  std::unordered_map<int, int, H, E> m{ {1,0}, {2,0}, {3,0}, {4, 0}, {5, 0} };\n+\n+  auto n = m.count(E::Partition{});\n+  VERIFY( n == 2 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "16940db559d13cb5a28adaa61e78a4ac0fe2125a", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/operations/1.cc", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Foperations%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Foperations%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Foperations%2F1.cc?ref=d2b1a6842c35c6e790a61291ca1a6aad3333a523", "patch": "@@ -0,0 +1,135 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++20 } }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+struct Equal\n+{\n+  typedef void is_transparent;\n+\n+  bool operator()(int i, long l) const { return i == l; }\n+  bool operator()(long l, int i) const { return l == i; }\n+  bool operator()(int i, int j) const { ++count; return i == j; }\n+\n+  static int count;\n+};\n+\n+int Equal::count = 0;\n+\n+struct Hash\n+{\n+  typedef void is_transparent;\n+\n+  std::size_t operator()(int i) const { ++count; return i; }\n+  std::size_t operator()(long l) const { return l; }\n+\n+  static int count;\n+};\n+\n+int Hash::count = 0;\n+\n+using test_type = std::unordered_multimap<int, char, Hash, Equal>;\n+\n+test_type x{ { 1, '2' }, { 3, '4' }, { 3, '5' } };\n+const test_type& cx = x;\n+\n+void\n+test01()\n+{\n+  Hash::count = 0;\n+  Equal::count = 0;\n+\n+  VERIFY( x.contains(1L) );\n+\n+  auto it = x.find(1L);\n+  VERIFY( it != x.end() && it->second == '2' );\n+  it = x.find(2L);\n+  VERIFY( it == x.end() );\n+\n+  auto cit = cx.find(3L);\n+  VERIFY( cit != cx.end() && cit->second == '5' );\n+  cit = cx.find(2L);\n+  VERIFY( cit == cx.end() );\n+\n+  VERIFY( Hash::count == 0 );\n+  VERIFY( Equal::count == 0 );\n+\n+  static_assert(std::is_same<decltype(it), test_type::iterator>::value,\n+      \"find returns iterator\");\n+  static_assert(std::is_same<decltype(cit), test_type::const_iterator>::value,\n+      \"const find returns const_iterator\");\n+}\n+\n+void\n+test02()\n+{\n+  Hash::count = 0;\n+  Equal::count = 0;\n+\n+  auto n = x.count(1L);\n+  VERIFY( n == 1 );\n+  n = x.count(2L);\n+  VERIFY( n == 0 );\n+\n+  auto cn = cx.count(3L);\n+  VERIFY( cn == 2 );\n+  cn = cx.count(2L);\n+  VERIFY( cn == 0 );\n+\n+  VERIFY( Hash::count == 0 );\n+  VERIFY( Equal::count == 0 );\n+}\n+\n+void\n+test03()\n+{\n+  Hash::count = 0;\n+  Equal::count = 0;\n+\n+  auto it = x.equal_range(1L);\n+  VERIFY( it.first != it.second && it.first->second == '2' );\n+  it = x.equal_range(2L);\n+  VERIFY( it.first == it.second && it.first == x.end() );\n+\n+  auto cit = cx.equal_range(3L);\n+  VERIFY( cit.first != cit.second && cit.first->second == '5' );\n+  VERIFY( std::distance(cit.first, cit.second) == 2 );\n+  cit = cx.equal_range(2L);\n+  VERIFY( cit.first == cit.second && cit.first == cx.end() );\n+\n+  VERIFY( Hash::count == 0 );\n+  VERIFY( Equal::count == 0 );\n+\n+  using pair = std::pair<test_type::iterator, test_type::iterator>;\n+  static_assert(std::is_same<decltype(it), pair>::value,\n+      \"equal_range returns pair<iterator, iterator>\");\n+  using cpair = std::pair<test_type::const_iterator, test_type::const_iterator>;\n+  static_assert(std::is_same<decltype(cit), cpair>::value,\n+      \"const equal_range returns pair<const_iterator, const_iterator>\");\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "81b82fc13079924d0556effdab9a11554dc1074a", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/operations/1.cc", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Foperations%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Foperations%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Foperations%2F1.cc?ref=d2b1a6842c35c6e790a61291ca1a6aad3333a523", "patch": "@@ -0,0 +1,135 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++20 } }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+\n+struct Equal\n+{\n+  typedef void is_transparent;\n+\n+  bool operator()(int i, long l) const { return i == l; }\n+  bool operator()(long l, int i) const { return l == i; }\n+  bool operator()(int i, int j) const { ++count; return i == j; }\n+\n+  static int count;\n+};\n+\n+int Equal::count = 0;\n+\n+struct Hash\n+{\n+  typedef void is_transparent;\n+\n+  std::size_t operator()(int i) const { ++count; return i; }\n+  std::size_t operator()(long l) const { return l; }\n+\n+  static int count;\n+};\n+\n+int Hash::count = 0;\n+\n+using test_type = std::unordered_multiset<int, Hash, Equal>;\n+\n+test_type x{ 1, 3, 3, 5 };\n+const test_type& cx = x;\n+\n+void\n+test01()\n+{\n+  Hash::count = 0;\n+  Equal::count = 0;\n+\n+  VERIFY( x.contains(1L) );\n+\n+  auto it = x.find(1L);\n+  VERIFY( it != x.end() && *it == 1 );\n+  it = x.find(2L);\n+  VERIFY( it == x.end() );\n+\n+  auto cit = cx.find(3L);\n+  VERIFY( cit != cx.end() && *cit == 3 );\n+  cit = cx.find(2L);\n+  VERIFY( cit == cx.end() );\n+\n+  VERIFY( Hash::count == 0 );\n+  VERIFY( Equal::count == 0 );\n+\n+  static_assert(std::is_same<decltype(it), test_type::iterator>::value,\n+      \"find returns iterator\");\n+  static_assert(std::is_same<decltype(cit), test_type::const_iterator>::value,\n+      \"const find returns const_iterator\");\n+}\n+\n+void\n+test02()\n+{\n+  Hash::count = 0;\n+  Equal::count = 0;\n+\n+  auto n = x.count(1L);\n+  VERIFY( n == 1 );\n+  n = x.count(2L);\n+  VERIFY( n == 0 );\n+\n+  auto cn = cx.count(3L);\n+  VERIFY( cn == 2 );\n+  cn = cx.count(2L);\n+  VERIFY( cn == 0 );\n+\n+  VERIFY( Hash::count == 0 );\n+  VERIFY( Equal::count == 0 );\n+}\n+\n+void\n+test03()\n+{\n+  Hash::count = 0;\n+  Equal::count = 0;\n+\n+  auto it = x.equal_range(1L);\n+  VERIFY( it.first != it.second && *it.first == 1 );\n+  it = x.equal_range(2L);\n+  VERIFY( it.first == it.second && it.first == x.end() );\n+\n+  auto cit = cx.equal_range(3L);\n+  VERIFY( cit.first != cit.second && *cit.first == 3 );\n+  VERIFY( std::distance(cit.first, cit.second) == 2 );\n+  cit = cx.equal_range(2L);\n+  VERIFY( cit.first == cit.second && cit.first == cx.end() );\n+\n+  VERIFY( Hash::count == 0 );\n+  VERIFY( Equal::count == 0 );\n+\n+  using pair = std::pair<test_type::iterator, test_type::iterator>;\n+  static_assert(std::is_same<decltype(it), pair>::value,\n+      \"equal_range returns pair<iterator, iterator>\");\n+  using cpair = std::pair<test_type::const_iterator, test_type::const_iterator>;\n+  static_assert(std::is_same<decltype(cit), cpair>::value,\n+      \"const equal_range returns pair<const_iterator, const_iterator>\");\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "34414d2434a61dac98a2cdc797ab8025022312be", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/operations/1.cc", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Foperations%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b1a6842c35c6e790a61291ca1a6aad3333a523/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Foperations%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Foperations%2F1.cc?ref=d2b1a6842c35c6e790a61291ca1a6aad3333a523", "patch": "@@ -0,0 +1,186 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++20 } }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+\n+struct Equal\n+{\n+  typedef void is_transparent;\n+\n+  bool operator()(int i, long l) const { return i == l; }\n+  bool operator()(long l, int i) const { return l == i; }\n+  bool operator()(int i, int j) const { ++count; return i == j; }\n+\n+  static int count;\n+};\n+\n+int Equal::count = 0;\n+\n+struct Hash\n+{\n+  typedef void is_transparent;\n+\n+  std::size_t operator()(int i) const { ++count; return i; }\n+  std::size_t operator()(long l) const { return l; }\n+\n+  static int count;\n+};\n+\n+int Hash::count = 0;\n+\n+using test_type = std::unordered_set<int, Hash, Equal>;\n+\n+test_type x{ 1, 3, 5 };\n+const test_type& cx = x;\n+\n+void\n+test01()\n+{\n+  Hash::count = 0;\n+  Equal::count = 0;\n+\n+  VERIFY( x.contains(1L) );\n+\n+  auto it = x.find(1L);\n+  VERIFY( it != x.end() && *it == 1 );\n+  it = x.find(2L);\n+  VERIFY( it == x.end() );\n+\n+  auto cit = cx.find(3L);\n+  VERIFY( cit != cx.end() && *cit == 3 );\n+  cit = cx.find(2L);\n+  VERIFY( cit == cx.end() );\n+\n+  VERIFY( Hash::count == 0 );\n+  VERIFY( Equal::count == 0 );\n+\n+  static_assert(std::is_same<decltype(it), test_type::iterator>::value,\n+      \"find returns iterator\");\n+  static_assert(std::is_same<decltype(cit), test_type::const_iterator>::value,\n+      \"const find returns const_iterator\");\n+}\n+\n+void\n+test02()\n+{\n+  Hash::count = 0;\n+  Equal::count = 0;\n+\n+  auto n = x.count(1L);\n+  VERIFY( n == 1 );\n+  n = x.count(2L);\n+  VERIFY( n == 0 );\n+\n+  auto cn = cx.count(3L);\n+  VERIFY( cn == 1 );\n+  cn = cx.count(2L);\n+  VERIFY( cn == 0 );\n+\n+  VERIFY( Hash::count == 0 );\n+  VERIFY( Equal::count == 0 );\n+}\n+\n+void\n+test03()\n+{\n+  Hash::count = 0;\n+  Equal::count = 0;\n+\n+  auto it = x.equal_range(1L);\n+  VERIFY( it.first != it.second && *it.first == 1 );\n+  it = x.equal_range(2L);\n+  VERIFY( it.first == it.second && it.first == x.end() );\n+\n+  auto cit = cx.equal_range(1L);\n+  VERIFY( cit.first != cit.second && *cit.first == 1 );\n+  cit = cx.equal_range(2L);\n+  VERIFY( cit.first == cit.second && cit.first == cx.end() );\n+\n+  VERIFY( Hash::count == 0 );\n+  VERIFY( Equal::count == 0 );\n+\n+  using pair = std::pair<test_type::iterator, test_type::iterator>;\n+  static_assert(std::is_same<decltype(it), pair>::value,\n+      \"equal_range returns pair<iterator, iterator>\");\n+  using cpair = std::pair<test_type::const_iterator, test_type::const_iterator>;\n+  static_assert(std::is_same<decltype(cit), cpair>::value,\n+      \"const equal_range returns pair<const_iterator, const_iterator>\");\n+}\n+\n+void\n+test04()\n+{\n+  // https://gcc.gnu.org/ml/libstdc++/2015-01/msg00176.html\n+  // Verify the new function template overloads do not cause problems\n+  // when the comparison function is not transparent.\n+  struct I\n+  {\n+    int i;\n+    operator int() const { return i; }\n+  };\n+\n+  std::unordered_set<int> s;\n+  I i = { };\n+  s.find(i);\n+}\n+\n+void\n+test05()\n+{\n+  struct E\n+  {\n+    bool operator()(int l, int r) const { return l == r; }\n+\n+    struct Partition { };\n+\n+    bool operator()(int l, Partition) const { return l < 6; }\n+    bool operator()(Partition, int r) const { return r > 3; }\n+\n+    using is_transparent = void;\n+  };\n+\n+  struct H\n+  {\n+    size_t\n+    operator()(int x) const\n+    { return (size_t)(x / 10); }\n+\n+    size_t\n+    operator()(E::Partition) const\n+    { return 0; }\n+\n+    using is_transparent = void;\n+  };\n+\n+  std::unordered_set<int, H, E> s{ 1, 2, 3, 4, 5 };\n+\n+  auto n = s.count(E::Partition{});\n+  VERIFY( n == 2 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}]}