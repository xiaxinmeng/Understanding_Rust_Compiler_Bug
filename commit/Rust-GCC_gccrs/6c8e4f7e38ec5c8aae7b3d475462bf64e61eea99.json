{"sha": "6c8e4f7e38ec5c8aae7b3d475462bf64e61eea99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM4ZTRmN2UzOGVjNWM4YWFlN2IzZDQ3NTQ2MmJmNjRlNjFlZWE5OQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-04-24T20:50:50Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-18T09:08:36Z"}, "message": "[Ada] Narrow large arithmetic and comparison operations\n\n2020-06-18  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch4.adb (Narrow_Large_Operation): New procedure to try\n\tand narrow large arithmetic and comparison operations.\n\t(Expand_N_In): Call it.\n\t(Expand_N_Op_Abs): Likewise.\n\t(Expand_N_Op_Add): Likewise.\n\t(Expand_N_Op_Divide): Likewise.\n\t(Expand_N_Op_Eq): Likewise.\n\t(Expand_N_Op_Ge): Likewise.\n\t(Expand_N_Op_Gt): Likewise.\n\t(Expand_N_Op_Le): Likewise.\n\t(Expand_N_Op_Lt): Likewise.\n\t(Expand_N_Op_Minus): Likewise.\n\t(Expand_N_Op_Mod): Likewise.\n\t(Expand_N_Op_Multiply): Likewise.\n\t(Expand_N_Op_Ne): Likewise.\n\t(Expand_N_Op_Plus): Likewise.\n\t(Expand_N_Op_Rem): Likewise.\n\t(Expand_N_Op_Subtract): Likewise.\n\t(Expand_N_Type_Conversion): Use Convert_To procedure.\n\t* exp_ch9.adb (Is_Pure_Barrier) <N_Identifier>: Skip all\n\tnumeric types.\n\t<N_Type_Conversion>: Use explicit criterion.", "tree": {"sha": "ac26c1a66323d506f0cfcf402bea75ef3b06b7c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac26c1a66323d506f0cfcf402bea75ef3b06b7c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c8e4f7e38ec5c8aae7b3d475462bf64e61eea99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c8e4f7e38ec5c8aae7b3d475462bf64e61eea99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c8e4f7e38ec5c8aae7b3d475462bf64e61eea99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c8e4f7e38ec5c8aae7b3d475462bf64e61eea99/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bfab79a72afbe0f6232668fdfa4b56a6aaea2e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bfab79a72afbe0f6232668fdfa4b56a6aaea2e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bfab79a72afbe0f6232668fdfa4b56a6aaea2e6"}], "stats": {"total": 368, "additions": 350, "deletions": 18}, "files": [{"sha": "1302009fcdd1fc92aba718a1877360054887334e", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 343, "deletions": 13, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c8e4f7e38ec5c8aae7b3d475462bf64e61eea99/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c8e4f7e38ec5c8aae7b3d475462bf64e61eea99/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=6c8e4f7e38ec5c8aae7b3d475462bf64e61eea99", "patch": "@@ -224,6 +224,11 @@ package body Exp_Ch4 is\n    --  skipped if the operation is done in Bignum mode but that's fine, since\n    --  the Bignum call takes care of everything.\n \n+   procedure Narrow_Large_Operation (N : Node_Id);\n+   --  Try to compute the result of a large operation in a narrower type than\n+   --  its nominal type. This is mainly aimed to get rid of operations done in\n+   --  Universal_Integer that can be generated for attributes.\n+\n    procedure Optimize_Length_Comparison (N : Node_Id);\n    --  Given an expression, if it is of the form X'Length op N (or the other\n    --  way round), where N is known at compile time to be 0 or 1, or something\n@@ -6545,6 +6550,12 @@ package body Exp_Ch4 is\n             end if;\n          end;\n \n+         --  Try to narrow the operation\n+\n+         if Ltyp = Universal_Integer and then Nkind (N) = N_In then\n+            Narrow_Large_Operation (N);\n+         end if;\n+\n          --  For all other cases of an explicit range, nothing to be done\n \n          goto Leave;\n@@ -7224,6 +7235,7 @@ package body Exp_Ch4 is\n    procedure Expand_N_Op_Abs (N : Node_Id) is\n       Loc  : constant Source_Ptr := Sloc (N);\n       Expr : constant Node_Id    := Right_Opnd (N);\n+      Typ  : constant Entity_Id  := Etype (N);\n \n    begin\n       Unary_Op_Validity_Checks (N);\n@@ -7235,9 +7247,19 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n+      --  Try to narrow the operation\n+\n+      if Typ = Universal_Integer then\n+         Narrow_Large_Operation (N);\n+\n+         if Nkind (N) /= N_Op_Abs then\n+            return;\n+         end if;\n+      end if;\n+\n       --  Deal with software overflow checking\n \n-      if Is_Signed_Integer_Type (Etype (N))\n+      if Is_Signed_Integer_Type (Typ)\n         and then Do_Overflow_Check (N)\n       then\n          --  The only case to worry about is when the argument is equal to the\n@@ -7297,6 +7319,16 @@ package body Exp_Ch4 is\n          end if;\n       end if;\n \n+      --  Try to narrow the operation\n+\n+      if Typ = Universal_Integer then\n+         Narrow_Large_Operation (N);\n+\n+         if Nkind (N) /= N_Op_Add then\n+            return;\n+         end if;\n+      end if;\n+\n       --  Arithmetic overflow checks for signed integer/fixed point types\n \n       if Is_Signed_Integer_Type (Typ) or else Is_Fixed_Point_Type (Typ) then\n@@ -7474,6 +7506,16 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n+      --  Try to narrow the operation\n+\n+      if Typ = Universal_Integer then\n+         Narrow_Large_Operation (N);\n+\n+         if Nkind (N) /= N_Op_Divide then\n+            return;\n+         end if;\n+      end if;\n+\n       --  Convert x / 2 ** y to Shift_Right (x, y). Note that the fact that\n       --  Is_Power_Of_2_For_Shift is set means that we know that our left\n       --  operand is an unsigned integer, as required for this to work.\n@@ -8437,6 +8479,12 @@ package body Exp_Ch4 is\n \n       Rewrite_Comparison (N);\n \n+      --  Try to narrow the operation\n+\n+      if Typl = Universal_Integer and then Nkind (N) = N_Op_Eq then\n+         Narrow_Large_Operation (N);\n+      end if;\n+\n       --  Special optimization of length comparison\n \n       Optimize_Length_Comparison (N);\n@@ -9053,6 +9101,12 @@ package body Exp_Ch4 is\n \n       Rewrite_Comparison (N);\n \n+      --  Try to narrow the operation\n+\n+      if Typ1 = Universal_Integer and then Nkind (N) = N_Op_Ge then\n+         Narrow_Large_Operation (N);\n+      end if;\n+\n       Optimize_Length_Comparison (N);\n    end Expand_N_Op_Ge;\n \n@@ -9096,6 +9150,12 @@ package body Exp_Ch4 is\n \n       Rewrite_Comparison (N);\n \n+      --  Try to narrow the operation\n+\n+      if Typ1 = Universal_Integer and then Nkind (N) = N_Op_Gt then\n+         Narrow_Large_Operation (N);\n+      end if;\n+\n       Optimize_Length_Comparison (N);\n    end Expand_N_Op_Gt;\n \n@@ -9139,6 +9199,12 @@ package body Exp_Ch4 is\n \n       Rewrite_Comparison (N);\n \n+      --  Try to narrow the operation\n+\n+      if Typ1 = Universal_Integer and then Nkind (N) = N_Op_Le then\n+         Narrow_Large_Operation (N);\n+      end if;\n+\n       Optimize_Length_Comparison (N);\n    end Expand_N_Op_Le;\n \n@@ -9182,6 +9248,12 @@ package body Exp_Ch4 is\n \n       Rewrite_Comparison (N);\n \n+      --  Try to narrow the operation\n+\n+      if Typ1 = Universal_Integer and then Nkind (N) = N_Op_Lt then\n+         Narrow_Large_Operation (N);\n+      end if;\n+\n       Optimize_Length_Comparison (N);\n    end Expand_N_Op_Lt;\n \n@@ -9203,8 +9275,18 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n+      --  Try to narrow the operation\n+\n+      if Typ = Universal_Integer then\n+         Narrow_Large_Operation (N);\n+\n+         if Nkind (N) /= N_Op_Minus then\n+            return;\n+         end if;\n+      end if;\n+\n       if not Backend_Overflow_Checks_On_Target\n-         and then Is_Signed_Integer_Type (Etype (N))\n+         and then Is_Signed_Integer_Type (Typ)\n          and then Do_Overflow_Check (N)\n       then\n          --  Software overflow checking expands -expr into (0 - expr)\n@@ -9252,7 +9334,17 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n-      if Is_Integer_Type (Etype (N)) then\n+      --  Try to narrow the operation\n+\n+      if Typ = Universal_Integer then\n+         Narrow_Large_Operation (N);\n+\n+         if Nkind (N) /= N_Op_Mod then\n+            return;\n+         end if;\n+      end if;\n+\n+      if Is_Integer_Type (Typ) then\n          Apply_Divide_Checks (N);\n \n          --  All done if we don't have a MOD any more, which can happen as a\n@@ -9551,6 +9643,16 @@ package body Exp_Ch4 is\n          end if;\n       end if;\n \n+      --  Try to narrow the operation\n+\n+      if Typ = Universal_Integer then\n+         Narrow_Large_Operation (N);\n+\n+         if Nkind (N) /= N_Op_Multiply then\n+            return;\n+         end if;\n+      end if;\n+\n       --  Convert x * 2 ** y to Shift_Left (x, y). Note that the fact that\n       --  Is_Power_Of_2_For_Shift is set means that we know that our left\n       --  operand is an integer, as required for this to work.\n@@ -9734,6 +9836,12 @@ package body Exp_Ch4 is\n \n          Rewrite_Comparison (N);\n \n+         --  Try to narrow the operation\n+\n+         if Typ = Universal_Integer and then Nkind (N) = N_Op_Ne then\n+            Narrow_Large_Operation (N);\n+         end if;\n+\n       --  For all cases other than elementary types, we rewrite node as the\n       --  negation of an equality operation, and reanalyze. The equality to be\n       --  used is defined in the same scope and has the same signature. This\n@@ -10016,6 +10124,8 @@ package body Exp_Ch4 is\n    ----------------------\n \n    procedure Expand_N_Op_Plus (N : Node_Id) is\n+      Typ : constant Entity_Id := Etype (N);\n+\n    begin\n       Unary_Op_Validity_Checks (N);\n \n@@ -10025,6 +10135,12 @@ package body Exp_Ch4 is\n          Apply_Arithmetic_Overflow_Check (N);\n          return;\n       end if;\n+\n+      --  Try to narrow the operation\n+\n+      if Typ = Universal_Integer then\n+         Narrow_Large_Operation (N);\n+      end if;\n    end Expand_N_Op_Plus;\n \n    ---------------------\n@@ -10058,6 +10174,16 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n+      --  Try to narrow the operation\n+\n+      if Typ = Universal_Integer then\n+         Narrow_Large_Operation (N);\n+\n+         if Nkind (N) /= N_Op_Rem then\n+            return;\n+         end if;\n+      end if;\n+\n       if Is_Integer_Type (Etype (N)) then\n          Apply_Divide_Checks (N);\n \n@@ -10422,6 +10548,16 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n+      --  Try to narrow the operation\n+\n+      if Typ = Universal_Integer then\n+         Narrow_Large_Operation (N);\n+\n+         if Nkind (N) /= N_Op_Subtract then\n+            return;\n+         end if;\n+      end if;\n+\n       --  N - 0 = N for integer types\n \n       if Is_Integer_Type (Typ)\n@@ -11876,20 +12012,13 @@ package body Exp_Ch4 is\n             L, R : Node_Id;\n \n          begin\n-            R :=\n-              Make_Type_Conversion (Loc,\n-                Subtype_Mark => New_Occurrence_Of (Standard_Integer, Loc),\n-                Expression   => Relocate_Node (Right_Opnd (Operand)));\n-\n             Opnd := New_Op_Node (Nkind (Operand), Loc);\n+\n+            R := Convert_To (Standard_Integer, Right_Opnd (Operand));\n             Set_Right_Opnd (Opnd, R);\n \n             if Nkind (Operand) in N_Binary_Op then\n-               L :=\n-                 Make_Type_Conversion (Loc,\n-                   Subtype_Mark => New_Occurrence_Of (Standard_Integer, Loc),\n-                   Expression   => Relocate_Node (Left_Opnd (Operand)));\n-\n+               L := Convert_To (Standard_Integer, Left_Opnd (Operand));\n                Set_Left_Opnd  (Opnd, L);\n             end if;\n \n@@ -13777,6 +13906,207 @@ package body Exp_Ch4 is\n           and then Overflow_Check_Mode in Minimized_Or_Eliminated;\n    end Minimized_Eliminated_Overflow_Check;\n \n+   ----------------------------\n+   -- Narrow_Large_Operation --\n+   ----------------------------\n+\n+   procedure Narrow_Large_Operation (N : Node_Id) is\n+      Kind   : constant Node_Kind := Nkind (N);\n+      In_Rng : constant Boolean   := Kind = N_In;\n+      Binary : constant Boolean   := Kind in N_Binary_Op or else In_Rng;\n+      Compar : constant Boolean   := Kind in N_Op_Compare or else In_Rng;\n+      R      : constant Node_Id   := Right_Opnd (N);\n+      Typ    : constant Entity_Id := Etype (R);\n+\n+      function Get_Size_For_Range (Lo, Hi : Uint) return Nat;\n+      --  Return the size of the smallest signed integer type covering Lo .. Hi\n+\n+      ------------------------\n+      -- Get_Size_For_Range --\n+      ------------------------\n+\n+      function Get_Size_For_Range (Lo, Hi : Uint) return Nat is\n+         B : Uint;\n+         S : Nat;\n+\n+      begin\n+         S := 1;\n+         B := Uint_1;\n+\n+         --  S = size, B = 2 ** (size - 1) (can accommodate -B .. +(B - 1))\n+\n+         while Lo < -B or else Hi < -B or else Lo >= B or else Hi >= B loop\n+            B := Uint_2 ** S;\n+            S := S + 1;\n+         end loop;\n+\n+         return S;\n+      end Get_Size_For_Range;\n+\n+      --  Local variables\n+\n+      L          : Node_Id;\n+      Llo, Lhi   : Uint;\n+      Rlo, Rhi   : Uint;\n+      Lsiz, Rsiz : Nat;\n+      Nlo, Nhi   : Uint;\n+      Nsiz       : Nat;\n+      Ntyp       : Entity_Id;\n+      Nop        : Node_Id;\n+      OK         : Boolean;\n+\n+   --  Start of processing for Narrow_Large_Operation\n+\n+   begin\n+      --  First, determine the range of the left operand, if any\n+\n+      if Binary then\n+         L := Left_Opnd (N);\n+         Determine_Range (L, OK, Llo, Lhi, Assume_Valid => True);\n+         if not OK then\n+            return;\n+         end if;\n+\n+      else\n+         L   := Empty;\n+         Llo := Uint_0;\n+         Lhi := Uint_0;\n+      end if;\n+\n+      --  Second, determine the range of the right operand, which can itself\n+      --  be a range, in which case we take the lower bound of the low bound\n+      --  and the upper bound of the high bound.\n+\n+      if In_Rng then\n+         declare\n+            Zlo, Zhi : Uint;\n+\n+         begin\n+            Determine_Range\n+              (Low_Bound (R), OK, Rlo, Zhi, Assume_Valid => True);\n+            if not OK then\n+               return;\n+            end if;\n+\n+            Determine_Range\n+              (High_Bound (R), OK, Zlo, Rhi, Assume_Valid => True);\n+            if not OK then\n+               return;\n+            end if;\n+         end;\n+\n+      else\n+         Determine_Range (R, OK, Rlo, Rhi, Assume_Valid => True);\n+         if not OK then\n+            return;\n+         end if;\n+      end if;\n+\n+      --  Then compute a size suitable for each range\n+\n+      if Binary then\n+         Lsiz := Get_Size_For_Range (Llo, Lhi);\n+      else\n+         Lsiz := 0;\n+      end if;\n+\n+      Rsiz := Get_Size_For_Range (Rlo, Rhi);\n+\n+      --  Now compute the size of the narrower type\n+\n+      if Compar then\n+         --  The type must be able to accomodate the operands\n+\n+         Nsiz := Nat'Max (Lsiz, Rsiz);\n+\n+      else\n+         --  The type must be able to accomodate the operand(s) and the result.\n+\n+         --  Note that Determine_Range typically does not report the bounds of\n+         --  the value as being larger than those of the base type, which means\n+         --  that it does not report overflow (see also Enable_Overflow_Check).\n+\n+         Determine_Range (N, OK, Nlo, Nhi, Assume_Valid => True);\n+         if not OK then\n+            return;\n+         end if;\n+\n+         --  Therefore, if Nsiz is not lower than the size of the original type\n+         --  here, we cannot be sure that the operation does not overflow.\n+\n+         Nsiz := Get_Size_For_Range (Nlo, Nhi);\n+         Nsiz := Nat'Max (Nsiz, Lsiz);\n+         Nsiz := Nat'Max (Nsiz, Rsiz);\n+      end if;\n+\n+      --  If the size is not lower than the size of the original type, then\n+      --  there is no point in changing the type, except in the case where\n+      --  we can remove a conversion to the original type from an operand.\n+\n+      if Nsiz >= RM_Size (Typ)\n+        and then not (Binary\n+                       and then Nkind (L) = N_Type_Conversion\n+                       and then Entity (Subtype_Mark (L)) = Typ)\n+        and then not (Nkind (R) = N_Type_Conversion\n+                       and then Entity (Subtype_Mark (R)) = Typ)\n+      then\n+         return;\n+      end if;\n+\n+      --  Now pick the narrower type according to the size\n+\n+      if Nsiz <= RM_Size (Standard_Integer) then\n+         Ntyp := Standard_Integer;\n+\n+      elsif Nsiz <= RM_Size (Standard_Long_Long_Integer) then\n+         Ntyp := Standard_Long_Long_Integer;\n+\n+      else\n+         return;\n+      end if;\n+\n+      --  Finally rewrite the operation in the narrower type\n+\n+      Nop := New_Op_Node (Kind, Sloc (N));\n+\n+      if Binary then\n+         Set_Left_Opnd (Nop, Convert_To (Ntyp, L));\n+      end if;\n+\n+      if In_Rng then\n+         Set_Right_Opnd (Nop,\n+           Make_Range (Sloc (N),\n+             Convert_To (Ntyp, Low_Bound (R)),\n+             Convert_To (Ntyp, High_Bound (R))));\n+      else\n+         Set_Right_Opnd (Nop, Convert_To (Ntyp, R));\n+      end if;\n+\n+      Rewrite (N, Nop);\n+\n+      if Compar then\n+         --  Analyze it with the comparison type and checks suppressed since\n+         --  the conversions of the operands cannot overflow.\n+\n+         Analyze_And_Resolve\n+           (N, Etype (Original_Node (N)), Suppress => Overflow_Check);\n+\n+      else\n+         --  Analyze it with the narrower type and checks suppressed, but only\n+         --  when we are sure that the operation does not overflow, see above.\n+\n+         if Nsiz < RM_Size (Typ) then\n+            Analyze_And_Resolve (N, Ntyp, Suppress => Overflow_Check);\n+         else\n+            Analyze_And_Resolve (N, Ntyp);\n+         end if;\n+\n+         --  Put back a conversion to the original type\n+\n+         Convert_To_And_Rewrite (Typ, N);\n+      end if;\n+   end Narrow_Large_Operation;\n+\n    --------------------------------\n    -- Optimize_Length_Comparison --\n    --------------------------------"}, {"sha": "eaf743e58638f8503ed3b1baaab996d19fb4b41a", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c8e4f7e38ec5c8aae7b3d475462bf64e61eea99/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c8e4f7e38ec5c8aae7b3d475462bf64e61eea99/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=6c8e4f7e38ec5c8aae7b3d475462bf64e61eea99", "patch": "@@ -6185,7 +6185,7 @@ package body Exp_Ch9 is\n                if No (Entity (N)) then\n                   return Abandon;\n \n-               elsif Is_Universal_Numeric_Type (Entity (N)) then\n+               elsif Is_Numeric_Type (Entity (N)) then\n                   return Skip;\n                end if;\n \n@@ -6283,11 +6283,13 @@ package body Exp_Ch9 is\n \n             when N_Type_Conversion =>\n \n-               --  Conversions to Universal_Integer will not raise constraint\n-               --  errors.\n+               --  Conversions to Universal_Integer do not raise constraint\n+               --  errors. Likewise if the expression's type is statically\n+               --  compatible with the target's type.\n \n-               if Cannot_Raise_Constraint_Error (N)\n-                 or else Etype (N) = Universal_Integer\n+               if Etype (N) = Universal_Integer\n+                 or else Subtypes_Statically_Compatible\n+                           (Etype (Expression (N)), Etype (N))\n                then\n                   return OK;\n                end if;"}]}