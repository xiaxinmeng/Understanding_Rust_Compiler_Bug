{"sha": "41806d92af91cf26e52aa00a536cf3094ef2648b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE4MDZkOTJhZjkxY2YyNmU1MmFhMDBhNTM2Y2YzMDk0ZWYyNjQ4Yg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-21T15:47:33Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-21T15:47:33Z"}, "message": "alias.c (true_dependence): Remove 'abort' from comments.\n\n\t* alias.c (true_dependence): Remove 'abort' from comments. Use\n\tgcc_assert and gcc_unreachable as appropriate.\n\t(canon_true_dependence): Likewise.\n\t* bb-reorder.c (connect_traces): Likewise.\n\t* c-common.c (c_add_case_label): Likewise.\n\t* c-decl.c (finish_function): Likewise.\n\t* caller-save.c (insert_restore, insert_save): Likewise.\n\t* cfg.c (update_bb_profile_for_threading): Likewise.\n\t* cfganal.c (flow_active_insn_p): Likewise.\n\t* cfgexpand.c (add_reg_br_prob_note): Likewise.\n\t* cfgrtl.c (rtl_redirect_edge_and_branch_force, rtl_split_edge,\n\tcfg_layout_merge_blocks): Likewise.\n\t* ifcvt.c (cond_exec_process_insns, merge_if_block,\n\tfind_if_block): Likewise.\n\t* integrate.c (allocate_initial_values): Likewise.\n\t* jump.c (reverse_condition, reverse_condition_maybe_unordered,\n\tswap_condition, unsigned_condition, signed_condition,\n\tmark_jump_label, invert_jump_1, rtx_renumbered_equal_p,\n\treg_or_subregno): Likewise.\n\t* lambda-code.c (lambda_compute_auxillary_space,\n\tlambda_transform_legal_p): Likewise.\n\t* lambda-mat.c (lambda_matrix_inverse_hard): Likewise.\n\t* langhooks.c (lhd_set_decl_assembler_name, lhd_type_promotes_to,\n\tlhd_incomplete_type_error, lhd_expand_expr,\n\tlhd_types_compatible_p, lhd_tree_size): Likewise.\n\t* lcm.c (create_pre_exit, optimize_mode_switching): Likewise.\n\t* local-alloc.c (update_equiv_regs): Likewise.\n\t* loop-unroll.c (peel_loop_completely\n\tunroll_loop_constant_iterations, unroll_loop_runtime_iterations,\n\tpeel_loop_simple, unroll_loop_stupid,\n\tanalyze_iv_to_split_insn): Likewise.\n\t* loop.c (gen_prefetch, find_and_verify_loops,\n\tbasic_induction_var): Likewise.\n\t* modulo-sched.c (normalize_sched_times, check_nodes_order): Likewise.\n\t* value-prof.c (tree_find_values_to_profile): Likewise.\n\t* varasm.c (named_section, default_assemble_integer,\n\tdecode_addr_const): Likewise.\n\nFrom-SVN: r98508", "tree": {"sha": "d321c52c21dedb7b851a7e57b5ea7c445d44db56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d321c52c21dedb7b851a7e57b5ea7c445d44db56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41806d92af91cf26e52aa00a536cf3094ef2648b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41806d92af91cf26e52aa00a536cf3094ef2648b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41806d92af91cf26e52aa00a536cf3094ef2648b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41806d92af91cf26e52aa00a536cf3094ef2648b/comments", "author": null, "committer": null, "parents": [{"sha": "ac7e839c63bfb19d83e6c81aee68c4435c1915c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac7e839c63bfb19d83e6c81aee68c4435c1915c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac7e839c63bfb19d83e6c81aee68c4435c1915c2"}], "stats": {"total": 502, "additions": 272, "deletions": 230}, "files": [{"sha": "d148538224a8d2af5d6e17b63becebcb76d85d4d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -1,10 +1,50 @@\n+2005-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* alias.c (true_dependence): Remove 'abort' from comments. Use\n+\tgcc_assert and gcc_unreachable as appropriate.\n+\t(canon_true_dependence): Likewise.\n+\t* bb-reorder.c (connect_traces): Likewise.\n+\t* c-common.c (c_add_case_label): Likewise.\n+\t* c-decl.c (finish_function): Likewise.\n+\t* caller-save.c (insert_restore, insert_save): Likewise.\n+\t* cfg.c (update_bb_profile_for_threading): Likewise.\n+\t* cfganal.c (flow_active_insn_p): Likewise.\n+\t* cfgexpand.c (add_reg_br_prob_note): Likewise.\n+\t* cfgrtl.c (rtl_redirect_edge_and_branch_force, rtl_split_edge,\n+\tcfg_layout_merge_blocks): Likewise.\n+\t* ifcvt.c (cond_exec_process_insns, merge_if_block,\n+\tfind_if_block): Likewise.\n+\t* integrate.c (allocate_initial_values): Likewise.\n+\t* jump.c (reverse_condition, reverse_condition_maybe_unordered,\n+\tswap_condition, unsigned_condition, signed_condition,\n+\tmark_jump_label, invert_jump_1, rtx_renumbered_equal_p,\n+\treg_or_subregno): Likewise.\n+\t* lambda-code.c (lambda_compute_auxillary_space,\n+\tlambda_transform_legal_p): Likewise.\n+\t* lambda-mat.c (lambda_matrix_inverse_hard): Likewise.\n+\t* langhooks.c (lhd_set_decl_assembler_name, lhd_type_promotes_to,\n+\tlhd_incomplete_type_error, lhd_expand_expr,\n+\tlhd_types_compatible_p, lhd_tree_size): Likewise.\n+\t* lcm.c (create_pre_exit, optimize_mode_switching): Likewise.\n+\t* local-alloc.c (update_equiv_regs): Likewise.\n+\t* loop-unroll.c (peel_loop_completely\n+\tunroll_loop_constant_iterations, unroll_loop_runtime_iterations,\n+\tpeel_loop_simple, unroll_loop_stupid,\n+\tanalyze_iv_to_split_insn): Likewise.\n+\t* loop.c (gen_prefetch, find_and_verify_loops,\n+\tbasic_induction_var): Likewise.\n+\t* modulo-sched.c (normalize_sched_times, check_nodes_order): Likewise.\n+\t* value-prof.c (tree_find_values_to_profile): Likewise.\n+\t* varasm.c (named_section, default_assemble_integer,\n+\tdecode_addr_const): Likewise.\n+\n 2005-04-21 Alan Modra  <amodra@bigpond.net.au>\n            Fariborz Jahanian <fjahanian@apple.com>\n \n-        * config/rs6000/rs6000.c (rs6000_arg_partial_bytes): Fix size of\n-        portion of argument passed in fpr.\n-        *expr.c (emit_push_insn): Fix computation of 'offset' used to\n-        decide on partial argument save on stack.\n+\t* config/rs6000/rs6000.c (rs6000_arg_partial_bytes): Fix size of\n+\tportion of argument passed in fpr.\n+\t* expr.c (emit_push_insn): Fix computation of 'offset' used to\n+\tdecide on partial argument save on stack.\n \n 2005-04-21  Kazu Hirata  <kazu@cs.umass.edu>\n \n@@ -29,6 +69,8 @@\n \t(ipa_passes): Declare.\n \t* Makefile.in (cgraphunit.o): Add dependency on cgraphunit.h\n \n+2005-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n 2005-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config/i386/i386.c (type_natural_mode): Use gcc_unreachable and"}, {"sha": "a36e1d570287d628fccfa7d575911ec0483d28a8", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -2141,7 +2141,7 @@ true_dependence (rtx mem, enum machine_mode mem_mode, rtx x,\n \n   /* Read-only memory is by definition never modified, and therefore can't\n      conflict with anything.  We don't expect to find read-only set on MEM,\n-     but stupid user tricks can produce them, so don't abort.  */\n+     but stupid user tricks can produce them, so don't die.  */\n   if (MEM_READONLY_P (x))\n     return 0;\n \n@@ -2214,7 +2214,7 @@ canon_true_dependence (rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n \n   /* Read-only memory is by definition never modified, and therefore can't\n      conflict with anything.  We don't expect to find read-only set on MEM,\n-     but stupid user tricks can produce them, so don't abort.  */\n+     but stupid user tricks can produce them, so don't die.  */\n   if (MEM_READONLY_P (x))\n     return 0;\n "}, {"sha": "cc0844e92d5214f6c36fa75b314e4cfbad38f357", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -926,18 +926,14 @@ connect_traces (int n_traces, struct trace *traces)\n \n       if (i >= n_traces)\n \t{\n-\t  if (two_passes && current_pass == 1)\n-\t    {\n-\t      i = 0;\n-\t      t = i;\n-\t      current_pass = 2;\n-\t      if (current_partition == BB_HOT_PARTITION)\n-\t\tcurrent_partition = BB_COLD_PARTITION;\n-\t      else\n-\t\tcurrent_partition = BB_HOT_PARTITION;\n-\t    }\n+\t  gcc_assert (two_passes && current_pass == 1);\n+\t  i = 0;\n+\t  t = i;\n+\t  current_pass = 2;\n+\t  if (current_partition == BB_HOT_PARTITION)\n+\t    current_partition = BB_COLD_PARTITION;\n \t  else\n-\t    abort ();\n+\t    current_partition = BB_HOT_PARTITION;\n \t}\n       \n       if (connected[t])"}, {"sha": "ab23903f6eab29fa602999b587cbe5b5cd2c3765", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -3635,7 +3635,7 @@ c_add_case_label (splay_tree cases, tree cond, tree orig_type,\n  error_out:\n   /* Add a label so that the back-end doesn't think that the beginning of\n      the switch is unreachable.  Note that we do not add a case label, as\n-     that just leads to duplicates and thence to aborts later on.  */\n+     that just leads to duplicates and thence to failure later on.  */\n   if (!cases->root)\n     {\n       tree t = create_artificial_label ();"}, {"sha": "70b2d8364b584038fff88ceefe45f70ae25ef9c3", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -6323,7 +6323,7 @@ finish_function (void)\n   if (warn_return_type\n       && TREE_CODE (TREE_TYPE (TREE_TYPE (fndecl))) != VOID_TYPE\n       && !current_function_returns_value && !current_function_returns_null\n-      /* Don't complain if we abort.  */\n+      /* Don't complain if we are no-return.  */\n       && !current_function_returns_abnormally\n       /* Don't warn for main().  */\n       && !MAIN_NAME_P (DECL_NAME (fndecl))"}, {"sha": "5d8e649c1321e0af6fc14780c46a3159e9b37cff", "filename": "gcc/caller-save.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -637,12 +637,12 @@ insert_restore (struct insn_chain *chain, int before_p, int regno,\n   struct insn_chain *new;\n   rtx mem;\n \n-  /* A common failure mode if register status is not correct in the RTL\n-     is for this routine to be called with a REGNO we didn't expect to\n-     save.  That will cause us to write an insn with a (nil) SET_DEST\n-     or SET_SRC.  Instead of doing so and causing a crash later, check\n-     for this common case and abort here instead.  This will remove one\n-     step in debugging such problems.  */\n+  /* A common failure mode if register status is not correct in the\n+     RTL is for this routine to be called with a REGNO we didn't\n+     expect to save.  That will cause us to write an insn with a (nil)\n+     SET_DEST or SET_SRC.  Instead of doing so and causing a crash\n+     later, check for this common case here instead.  This will remove\n+     one step in debugging such problems.  */\n   gcc_assert (regno_save_mem[regno][1]);\n \n   /* Get the pattern to emit and update our status.\n@@ -710,11 +710,11 @@ insert_save (struct insn_chain *chain, int before_p, int regno,\n   struct insn_chain *new;\n   rtx mem;\n \n-  /* A common failure mode if register status is not correct in the RTL\n-     is for this routine to be called with a REGNO we didn't expect to\n-     save.  That will cause us to write an insn with a (nil) SET_DEST\n-     or SET_SRC.  Instead of doing so and causing a crash later, check\n-     for this common case and abort here instead.  This will remove one\n+  /* A common failure mode if register status is not correct in the\n+     RTL is for this routine to be called with a REGNO we didn't\n+     expect to save.  That will cause us to write an insn with a (nil)\n+     SET_DEST or SET_SRC.  Instead of doing so and causing a crash\n+     later, check for this common case here.  This will remove one\n      step in debugging such problems.  */\n   gcc_assert (regno_save_mem[regno][1]);\n "}, {"sha": "432cea5a1b4141e15f18b8c39bc3613e2bae8ecc", "filename": "gcc/cfg.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -895,8 +895,7 @@ update_bb_profile_for_threading (basic_block bb, int edge_frequency,\n \tc->probability *= scale / 65536;\n     }\n \n-  if (bb != taken_edge->src)\n-    abort ();\n+  gcc_assert (bb == taken_edge->src);\n   taken_edge->count -= count;\n   if (taken_edge->count < 0)\n     taken_edge->count = 0;"}, {"sha": "6c707729b70547dfd6f590f119863a2cfc6c988e", "filename": "gcc/cfganal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -69,7 +69,7 @@ flow_active_insn_p (rtx insn)\n      programs that fail to return a value.  Its effect is to\n      keep the return value from being live across the entire\n      function.  If we allow it to be skipped, we introduce the\n-     possibility for register livetime aborts.  */\n+     possibility for register lifetime confusion.  */\n   if (GET_CODE (PATTERN (insn)) == CLOBBER\n       && REG_P (XEXP (PATTERN (insn), 0))\n       && REG_FUNCTION_VALUE_P (XEXP (PATTERN (insn), 0)))"}, {"sha": "e894b7791160fc3e52950b81b65594f74b0877d5", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -60,18 +60,16 @@ add_reg_br_prob_note (FILE *dump_file, rtx last, int probability)\n \t    || GET_CODE (NEXT_INSN (NEXT_INSN (NEXT_INSN (last)))) != CODE_LABEL\n \t    || NEXT_INSN (NEXT_INSN (NEXT_INSN (NEXT_INSN (last)))))\n \t  goto failed;\n-\tif (find_reg_note (last, REG_BR_PROB, 0))\n-\t  abort ();\n+\tgcc_assert (!find_reg_note (last, REG_BR_PROB, 0));\n \tREG_NOTES (last)\n \t  = gen_rtx_EXPR_LIST (REG_BR_PROB,\n \t\t\t       GEN_INT (REG_BR_PROB_BASE - probability),\n \t\t\t       REG_NOTES (last));\n \treturn;\n       }\n   if (!last || GET_CODE (last) != JUMP_INSN || !any_condjump_p (last))\n-      goto failed;\n-  if (find_reg_note (last, REG_BR_PROB, 0))\n-    abort ();\n+    goto failed;\n+  gcc_assert (!find_reg_note (last, REG_BR_PROB, 0));\n   REG_NOTES (last)\n     = gen_rtx_EXPR_LIST (REG_BR_PROB,\n \t\t\t GEN_INT (probability), REG_NOTES (last));"}, {"sha": "c1bbb1a52aa4a3eb471d3098ac06faf26c56f0fc", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -1165,7 +1165,7 @@ force_nonfallthru (edge e)\n \n /* Redirect edge even at the expense of creating new jump insn or\n    basic block.  Return new basic block if created, NULL otherwise.\n-   Abort if conversion is impossible.  */\n+   Conversion must be possible.  */\n \n static basic_block\n rtl_redirect_edge_and_branch_force (edge e, basic_block target)\n@@ -1277,7 +1277,7 @@ rtl_move_block_after (basic_block bb ATTRIBUTE_UNUSED,\n }\n \n /* Split a (typically critical) edge.  Return the new block.\n-   Abort on abnormal edges.\n+   The edge must not be abnormal.\n \n    ??? The code generally expects to be called on critical edges.\n    The case of a block ending in an unconditional jump to a\n@@ -2695,7 +2695,8 @@ cfg_layout_can_merge_blocks_p (basic_block a, basic_block b)\n \t\t  ? simplejump_p (BB_END (a)) : onlyjump_p (BB_END (a)))));\n }\n \n-/* Merge block A and B, abort when it is not possible.  */\n+/* Merge block A and B.  The blocks must be mergeable.  */\n+\n static void\n cfg_layout_merge_blocks (basic_block a, basic_block b)\n {"}, {"sha": "8367316847f3c46a5e85c807d08d26a14f1862e8", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -269,8 +269,7 @@ cond_exec_process_insns (ce_if_block_t *ce_info ATTRIBUTE_UNUSED,\n       if (NOTE_P (insn))\n \tgoto insn_done;\n \n-      if (!NONJUMP_INSN_P (insn) && !CALL_P (insn))\n-\tabort ();\n+      gcc_assert(NONJUMP_INSN_P (insn) || CALL_P (insn));\n \n       /* Remove USE insns that get in the way.  */\n       if (reload_completed && GET_CODE (PATTERN (insn)) == USE)\n@@ -2228,38 +2227,29 @@ merge_if_block (struct ce_if_block * ce_info)\n       /* The outgoing edge for the current COMBO block should already\n \t be correct.  Verify this.  */\n       if (EDGE_COUNT (combo_bb->succs) == 0)\n-\t{\n-\t  if (find_reg_note (last, REG_NORETURN, NULL))\n-\t    ;\n-\t  else if (NONJUMP_INSN_P (last)\n-\t\t   && GET_CODE (PATTERN (last)) == TRAP_IF\n-\t\t   && TRAP_CONDITION (PATTERN (last)) == const_true_rtx)\n-\t    ;\n-\t  else\n-\t    abort ();\n-\t}\n+\tgcc_assert (find_reg_note (last, REG_NORETURN, NULL)\n+\t\t    || (NONJUMP_INSN_P (last)\n+\t\t\t&& GET_CODE (PATTERN (last)) == TRAP_IF\n+\t\t\t&& (TRAP_CONDITION (PATTERN (last))\n+\t\t\t    == const_true_rtx)));\n \n+      else\n       /* There should still be something at the end of the THEN or ELSE\n          blocks taking us to our final destination.  */\n-      else if (JUMP_P (last))\n-\t;\n-      else if (EDGE_SUCC (combo_bb, 0)->dest == EXIT_BLOCK_PTR\n-\t       && CALL_P (last)\n-\t       && SIBLING_CALL_P (last))\n-\t;\n-      else if ((EDGE_SUCC (combo_bb, 0)->flags & EDGE_EH)\n-\t       && can_throw_internal (last))\n-\t;\n-      else\n-\tabort ();\n+\tgcc_assert (JUMP_P (last)\n+\t\t    || (EDGE_SUCC (combo_bb, 0)->dest == EXIT_BLOCK_PTR\n+\t\t\t&& CALL_P (last)\n+\t\t\t&& SIBLING_CALL_P (last))\n+\t\t    || ((EDGE_SUCC (combo_bb, 0)->flags & EDGE_EH)\n+\t\t\t&& can_throw_internal (last)));\n     }\n \n   /* The JOIN block may have had quite a number of other predecessors too.\n      Since we've already merged the TEST, THEN and ELSE blocks, we should\n      have only one remaining edge from our if-then-else diamond.  If there\n      is more than one remaining edge, it must come from elsewhere.  There\n      may be zero incoming edges if the THEN block didn't actually join\n-     back up (as with a call to abort).  */\n+     back up (as with a call to a non-return function).  */\n   else if (EDGE_COUNT (join_bb->preds) < 2\n \t   && join_bb != EXIT_BLOCK_PTR)\n     {\n@@ -2626,7 +2616,7 @@ find_if_block (struct ce_if_block * ce_info)\n      we checked the FALLTHRU flag, those are already adjacent to the last IF\n      block.  */\n   /* ??? As an enhancement, move the ELSE block.  Have to deal with\n-     BLOCK notes, if by no other means than aborting the merge if they\n+     BLOCK notes, if by no other means than backing out the merge if they\n      exist.  Sticky enough I don't want to think about it now.  */\n   next = then_bb;\n   if (else_bb && (next = next->next_bb) != else_bb)"}, {"sha": "22a7c4021ce971fee43d65638944430b9d2e1882", "filename": "gcc/integrate.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -389,18 +389,19 @@ allocate_initial_values (rtx *reg_equiv_memory_loc ATTRIBUTE_UNUSED)\n       int regno = REGNO (ivs->entries[i].pseudo);\n       rtx x = ALLOCATE_INITIAL_VALUE (ivs->entries[i].hard_reg);\n \n-      if (x == NULL_RTX || REG_N_SETS (REGNO (ivs->entries[i].pseudo)) > 1)\n-\t; /* Do nothing.  */\n-      else if (MEM_P (x))\n-\treg_equiv_memory_loc[regno] = x;\n-      else if (REG_P (x))\n+      if (x && REG_N_SETS (REGNO (ivs->entries[i].pseudo)) <= 1)\n \t{\n-\t  reg_renumber[regno] = REGNO (x);\n-\t  /* Poke the regno right into regno_reg_rtx\n-\t     so that even fixed regs are accepted.  */\n-\t  REGNO (ivs->entries[i].pseudo) = REGNO (x);\n+\t  if (MEM_P (x))\n+\t    reg_equiv_memory_loc[regno] = x;\n+\t  else\n+\t    {\n+\t      gcc_assert (REG_P (x));\n+\t      reg_renumber[regno] = REGNO (x);\n+\t      /* Poke the regno right into regno_reg_rtx so that even\n+\t     \t fixed regs are accepted.  */\n+\t      REGNO (ivs->entries[i].pseudo) = REGNO (x);\n+\t    }\n \t}\n-      else abort ();\n     }\n #endif\n }"}, {"sha": "74a6c69b861220ea67a4deba66abf788456a91d9", "filename": "gcc/jump.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -511,7 +511,7 @@ reverse_condition (enum rtx_code code)\n       return UNKNOWN;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -554,7 +554,7 @@ reverse_condition_maybe_unordered (enum rtx_code code)\n       return LTGT;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -600,7 +600,7 @@ swap_condition (enum rtx_code code)\n       return UNLE;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -631,7 +631,7 @@ unsigned_condition (enum rtx_code code)\n       return LEU;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -660,7 +660,7 @@ signed_condition (enum rtx_code code)\n       return LE;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \f\n@@ -1109,8 +1109,7 @@ mark_jump_label (rtx x, rtx insn, int in_mem)\n \t    && NOTE_LINE_NUMBER (label) == NOTE_INSN_DELETED_LABEL)\n \t  break;\n \n-\tif (!LABEL_P (label))\n-\t  abort ();\n+\tgcc_assert (LABEL_P (label));\n \n \t/* Ignore references to labels of containing functions.  */\n \tif (LABEL_REF_NONLOCAL_P (x))\n@@ -1723,10 +1722,13 @@ invert_jump_1 (rtx jump, rtx nlabel)\n {\n   rtx x = pc_set (jump);\n   int ochanges;\n+  int ok;\n \n   ochanges = num_validated_changes ();\n-  if (!x || !invert_exp_1 (SET_SRC (x), jump))\n-    abort ();\n+  gcc_assert (x);\n+  ok = invert_exp_1 (SET_SRC (x), jump);\n+  gcc_assert (ok);\n+  \n   if (num_validated_changes () == ochanges)\n     return 0;\n \n@@ -1941,7 +1943,7 @@ rtx_renumbered_equal_p (rtx x, rtx y)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   return 1;\n@@ -1976,9 +1978,8 @@ true_regnum (rtx x)\n unsigned int\n reg_or_subregno (rtx reg)\n {\n-  if (REG_P (reg))\n-    return REGNO (reg);\n   if (GET_CODE (reg) == SUBREG)\n-    return REGNO (SUBREG_REG (reg));\n-  abort ();\n+    reg = SUBREG_REG (reg);\n+  gcc_assert (REG_P (reg));\n+  return REGNO (reg);\n }"}, {"sha": "fbfcdf9f8dc693a45ecd7ea9913355ca4ebefb93", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -687,7 +687,7 @@ lambda_compute_auxillary_space (lambda_loopnest nest,\n \n   /* Unfortunately, we can't know the number of constraints we'll have\n      ahead of time, but this should be enough even in ridiculous loop nest\n-     cases. We abort if we go over this limit.  */\n+     cases. We must not go over this limit.  */\n   A = lambda_matrix_new (128, depth);\n   B = lambda_matrix_new (128, invariants);\n   a = lambda_vector_new (128);\n@@ -2483,11 +2483,8 @@ lambda_transform_legal_p (lambda_trans_matrix trans,\n   lambda_vector distres;\n   struct data_dependence_relation *ddr;\n \n-#if defined ENABLE_CHECKING\n-  if (LTM_COLSIZE (trans) != nb_loops\n-      || LTM_ROWSIZE (trans) != nb_loops)\n-    abort ();\n-#endif\n+  gcc_assert (LTM_COLSIZE (trans) == nb_loops\n+\t      && LTM_ROWSIZE (trans) == nb_loops);\n \n   /* When there is an unknown relation in the dependence_relations, we\n      know that it is no worth looking at this loop nest: give up.  */"}, {"sha": "8de0e985dcce1b1aad2e0a602bbbd4b11f031e1c", "filename": "gcc/lambda-mat.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Flambda-mat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Flambda-mat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-mat.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -401,9 +401,8 @@ lambda_matrix_inverse_hard (lambda_matrix mat, lambda_matrix inv, int n)\n       row = temp[j];\n       diagonal = row[j];\n \n-      /* If the matrix is singular, abort.  */\n-      if (diagonal == 0)\n-\tabort ();\n+      /* The matrix must not be singular.  */\n+      gcc_assert (diagonal);\n \n       determinant = determinant * diagonal;\n "}, {"sha": "94e08e6f8cbeec57358bc7edccfc1dd67e22831b", "filename": "gcc/langhooks.c", "status": "modified", "additions": 32, "deletions": 41, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -158,37 +158,31 @@ lhd_set_decl_assembler_name (tree decl)\n      DECL_ASSEMBLER_NAME for lots of DECLs.  Only FUNCTION_DECLs and\n      VAR_DECLs for variables with static storage duration need a real\n      DECL_ASSEMBLER_NAME.  */\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      || (TREE_CODE (decl) == VAR_DECL\n-\t  && (TREE_STATIC (decl)\n-\t      || DECL_EXTERNAL (decl)\n-\t      || TREE_PUBLIC (decl))))\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n+\t      || (TREE_CODE (decl) == VAR_DECL\n+\t\t  && (TREE_STATIC (decl)\n+\t\t      || DECL_EXTERNAL (decl)\n+\t\t      || TREE_PUBLIC (decl))));\n+  \n+  /* By default, assume the name to use in assembly code is the same\n+     as that used in the source language.  (That's correct for C, and\n+     GCC used to set DECL_ASSEMBLER_NAME to the same value as\n+     DECL_NAME in build_decl, so this choice provides backwards\n+     compatibility with existing front-ends.\n+      \n+     Can't use just the variable's own name for a variable whose scope\n+     is less than the whole compilation.  Concatenate a distinguishing\n+     number - we use the DECL_UID.  */\n+  if (TREE_PUBLIC (decl) || DECL_CONTEXT (decl) == NULL_TREE)\n+    SET_DECL_ASSEMBLER_NAME (decl, DECL_NAME (decl));\n+  else\n     {\n-      /* By default, assume the name to use in assembly code is the\n-\t same as that used in the source language.  (That's correct\n-\t for C, and GCC used to set DECL_ASSEMBLER_NAME to the same\n-\t value as DECL_NAME in build_decl, so this choice provides\n-\t backwards compatibility with existing front-ends.\n-\n-         Can't use just the variable's own name for a variable whose\n-\t scope is less than the whole compilation.  Concatenate a\n-\t distinguishing number - we use the DECL_UID.  */\n-      if (TREE_PUBLIC (decl) || DECL_CONTEXT (decl) == NULL_TREE)\n-\tSET_DECL_ASSEMBLER_NAME (decl, DECL_NAME (decl));\n-      else\n-\t{\n-\t  const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));\n-\t  char *label;\n-\n-\t  ASM_FORMAT_PRIVATE_NAME (label, name, DECL_UID (decl));\n-\t  SET_DECL_ASSEMBLER_NAME (decl, get_identifier (label));\n-\t}\n+      const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));\n+      char *label;\n+      \n+      ASM_FORMAT_PRIVATE_NAME (label, name, DECL_UID (decl));\n+      SET_DECL_ASSEMBLER_NAME (decl, get_identifier (label));\n     }\n-  else\n-    /* Nobody should ever be asking for the DECL_ASSEMBLER_NAME of\n-       these DECLs -- unless they're in language-dependent code, in\n-       which case set_decl_assembler_name hook should handle things.  */\n-    abort ();\n }\n \n /* By default we always allow bit-field based optimizations.  */\n@@ -202,7 +196,7 @@ lhd_can_use_bit_fields_p (void)\n tree\n lhd_type_promotes_to (tree ARG_UNUSED (type))\n {\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Registration of machine- or os-specific builtin types.  */\n@@ -216,10 +210,8 @@ lhd_register_builtin_type (tree ARG_UNUSED (type),\n void\n lhd_incomplete_type_error (tree ARG_UNUSED (value), tree type)\n {\n-  if (TREE_CODE (type) == ERROR_MARK)\n-    return;\n-\n-  abort ();\n+  gcc_assert (TREE_CODE (type) == ERROR_MARK);\n+  return;\n }\n \n /* Provide a default routine for alias sets that always returns -1.  This\n@@ -248,7 +240,7 @@ lhd_expand_expr (tree ARG_UNUSED (t), rtx ARG_UNUSED (r),\n \t\t int ARG_UNUSED (em),\n \t\t rtx * ARG_UNUSED (a))\n {\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* The default language-specific function for expanding a decl.  After\n@@ -288,10 +280,10 @@ lhd_types_compatible_p (tree x, tree y)\n    handle language-specific tree codes, as well as language-specific\n    information associated to common tree codes.  If a tree node is\n    completely handled within this function, it should set *SUBTREES to\n-   0, so that generic handling isn't attempted.  For language-specific\n-   tree codes, generic handling would abort(), so make sure it is set\n-   properly.  Both SUBTREES and *SUBTREES is guaranteed to be nonzero\n-   when the function is called.  */\n+   0, so that generic handling isn't attempted.  The generic handling\n+   cannot deal with language-specific tree codes, so make sure it is\n+   set properly.  Both SUBTREES and *SUBTREES is guaranteed to be\n+   nonzero when the function is called.  */\n \n tree\n lhd_tree_inlining_walk_subtrees (tree *tp ATTRIBUTE_UNUSED,\n@@ -444,8 +436,7 @@ lhd_gimplify_expr (tree *expr_p ATTRIBUTE_UNUSED, tree *pre_p ATTRIBUTE_UNUSED,\n size_t\n lhd_tree_size (enum tree_code c ATTRIBUTE_UNUSED)\n {\n-  abort ();\n-  return 0;\n+  gcc_unreachable ();\n }\n \n /* Return true if decl, which is a function decl, may be called by a"}, {"sha": "d62bbb01a1228b9bfbee7b0bf588d3caeeee3ff1", "filename": "gcc/lcm.c", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -1101,23 +1101,27 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \t\tlast_insn = return_copy;\n \t      }\n \t    while (nregs);\n+\t    \n \t    /* If we didn't see a full return value copy, verify that there\n \t       is a plausible reason for this.  If some, but not all of the\n \t       return register is likely spilled, we can expect that there\n \t       is a copy for the likely spilled part.  */\n-\t    if (nregs\n-\t\t&& ! forced_late_switch\n-\t\t&& ! short_block\n-\t\t&& CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (ret_start))\n-\t\t&& nregs == hard_regno_nregs[ret_start][GET_MODE (ret_reg)]\n-\t\t/* For multi-hard-register floating point values,\n-\t\t   sometimes the likely-spilled part is ordinarily copied\n-\t\t   first, then the other part is set with an arithmetic\n-\t\t   operation.  This doesn't actually cause reload failures,\n-\t\t   so let it pass.  */\n-\t\t&& (GET_MODE_CLASS (GET_MODE (ret_reg)) == MODE_INT\n-\t\t    || nregs == 1))\n-\t      abort ();\n+\t    gcc_assert (!nregs\n+\t\t\t|| forced_late_switch\n+\t\t\t|| short_block\n+\t\t\t|| !(CLASS_LIKELY_SPILLED_P\n+\t\t\t     (REGNO_REG_CLASS (ret_start)))\n+\t\t\t|| (nregs\n+\t\t\t    != hard_regno_nregs[ret_start][GET_MODE (ret_reg)])\n+\t\t\t/* For multi-hard-register floating point\n+\t\t   \t   values, sometimes the likely-spilled part\n+\t\t   \t   is ordinarily copied first, then the other\n+\t\t   \t   part is set with an arithmetic operation.\n+\t\t   \t   This doesn't actually cause reload\n+\t\t   \t   failures, so let it pass.  */\n+\t\t\t|| (GET_MODE_CLASS (GET_MODE (ret_reg)) != MODE_INT\n+\t\t\t    && nregs != 1));\n+\t    \n \t    if (INSN_P (last_insn))\n \t      {\n \t\tbefore_return_copy\n@@ -1370,21 +1374,23 @@ optimize_mode_switching (FILE *file)\n \t\t  emited = true;\n \t\t  if (JUMP_P (BB_END (src_bb)))\n \t\t    emit_insn_before (mode_set, BB_END (src_bb));\n-\t\t  /* It doesn't make sense to switch to normal mode\n-\t\t     after a CALL_INSN, so we're going to abort if we\n-\t\t     find one.  The cases in which a CALL_INSN may\n-\t\t     have an abnormal edge are sibcalls and EH edges.\n-\t\t     In the case of sibcalls, the dest basic-block is\n-\t\t     the EXIT_BLOCK, that runs in normal mode; it is\n-\t\t     assumed that a sibcall insn requires normal mode\n-\t\t     itself, so no mode switch would be required after\n-\t\t     the call (it wouldn't make sense, anyway).  In\n-\t\t     the case of EH edges, EH entry points also start\n-\t\t     in normal mode, so a similar reasoning applies.  */\n-\t\t  else if (NONJUMP_INSN_P (BB_END (src_bb)))\n-\t\t    emit_insn_after (mode_set, BB_END (src_bb));\n \t\t  else\n-\t\t    abort ();\n+\t\t    {\n+\t\t      /* It doesn't make sense to switch to normal\n+\t\t         mode after a CALL_INSN.  The cases in which a\n+\t\t         CALL_INSN may have an abnormal edge are\n+\t\t         sibcalls and EH edges.  In the case of\n+\t\t         sibcalls, the dest basic-block is the\n+\t\t         EXIT_BLOCK, that runs in normal mode; it is\n+\t\t         assumed that a sibcall insn requires normal\n+\t\t         mode itself, so no mode switch would be\n+\t\t         required after the call (it wouldn't make\n+\t\t         sense, anyway).  In the case of EH edges, EH\n+\t\t         entry points also start in normal mode, so a\n+\t\t         similar reasoning applies.  */\n+\t\t      gcc_assert (NONJUMP_INSN_P (BB_END (src_bb)));\n+\t\t      emit_insn_after (mode_set, BB_END (src_bb));\n+\t\t    }\n \t\t  bb_info[j][src_bb->index].computing = mode;\n \t\t  RESET_BIT (transp[src_bb->index], j);\n \t\t}"}, {"sha": "2caeafcaa9c4e75f08dbdcf2ee03b32e9446e326", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -1088,8 +1088,9 @@ update_equiv_regs (void)\n \t\t      REG_NOTES (new_insn) = REG_NOTES (equiv_insn);\n \t\t      REG_NOTES (equiv_insn) = 0;\n \n-\t\t      /* Make sure this insn is recognized before reload begins,\n-\t\t\t otherwise eliminate_regs_in_insn will abort.  */\n+\t\t      /* Make sure this insn is recognized before\n+\t\t\t reload begins, otherwise\n+\t\t\t eliminate_regs_in_insn will die.  */\n \t\t      INSN_CODE (new_insn) = INSN_CODE (equiv_insn);\n \n \t\t      delete_insn (equiv_insn);"}, {"sha": "c93170c3bd0d2f69100ee9aa55614d499c4513e5", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 66, "deletions": 47, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -495,6 +495,8 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n \n   if (npeel)\n     {\n+      bool ok;\n+      \n       wont_exit = sbitmap_alloc (npeel + 1);\n       sbitmap_ones (wont_exit);\n       RESET_BIT (wont_exit, 0);\n@@ -508,11 +510,12 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n         opt_info = analyze_insns_in_loop (loop);\n       \n       opt_info_start_duplication (opt_info);\n-      if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\tloops, npeel,\n-\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-\tabort ();\n+      ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\t\t\t\t  loops, npeel,\n+\t\t\t\t\t  wont_exit, desc->out_edge,\n+\t\t\t\t\t  remove_edges, &n_remove_edges,\n+\t\t\t\t\t  DLTHE_FLAG_UPDATE_FREQ);\n+      gcc_assert (ok);\n \n       free (wont_exit);\n       \n@@ -670,6 +673,7 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n   bool exit_at_end = loop_exit_at_end_p (loop);\n   struct opt_info *opt_info = NULL;\n+  bool ok;\n   \n   niter = desc->niter;\n \n@@ -704,12 +708,12 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n       if (exit_mod)\n \t{\n \t  opt_info_start_duplication (opt_info);\n-          if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+          ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t\t      loops, exit_mod,\n \t\t\t\t\t      wont_exit, desc->out_edge,\n \t\t\t\t\t      remove_edges, &n_remove_edges,\n-\t\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ))\n-\t    abort ();\n+\t\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ);\n+\t  gcc_assert (ok);\n \n           if (opt_info && exit_mod > 1)\n  \t    apply_opt_in_copies (opt_info, exit_mod, false, false); \n@@ -740,11 +744,12 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n \t    RESET_BIT (wont_exit, 1);\n          \n           opt_info_start_duplication (opt_info);\n-\t  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\tloops, exit_mod + 1,\n-\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-\t    abort ();\n+\t  ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\t\t\t\t      loops, exit_mod + 1,\n+\t\t\t\t\t      wont_exit, desc->out_edge,\n+\t\t\t\t\t      remove_edges, &n_remove_edges,\n+\t\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ);\n+\t  gcc_assert (ok);\n  \n           if (opt_info && exit_mod > 0)\n   \t    apply_opt_in_copies (opt_info, exit_mod + 1, false, false);\n@@ -763,11 +768,12 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n   /* Now unroll the loop.  */\n   \n   opt_info_start_duplication (opt_info);\n-  if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n-\t\tloops, max_unroll,\n-\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-    abort ();\n+  ok = duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n+\t\t\t\t      loops, max_unroll,\n+\t\t\t\t      wont_exit, desc->out_edge,\n+\t\t\t\t      remove_edges, &n_remove_edges,\n+\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ);\n+  gcc_assert (ok);\n \n   if (opt_info)\n     {\n@@ -935,6 +941,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n   bool exit_at_end = loop_exit_at_end_p (loop);\n   struct opt_info *opt_info = NULL;\n+  bool ok;\n   \n   if (flag_split_ivs_in_unroller\n       || flag_variable_expansion_in_unroller)\n@@ -1013,11 +1020,12 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       && !desc->noloop_assumptions)\n     SET_BIT (wont_exit, 1);\n   ezc_swtch = loop_preheader_edge (loop)->src;\n-  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\tloops, 1,\n-\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-    abort ();\n+  ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\t\t\t      loops, 1,\n+\t\t\t\t      wont_exit, desc->out_edge,\n+\t\t\t\t      remove_edges, &n_remove_edges,\n+\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ);\n+  gcc_assert (ok);\n \n   /* Record the place where switch will be built for preconditioning.  */\n   swtch = loop_split_edge_with (loop_preheader_edge (loop),\n@@ -1029,19 +1037,21 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       sbitmap_zero (wont_exit);\n       if (i != n_peel - 1 || !last_may_exit)\n \tSET_BIT (wont_exit, 1);\n-      if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\tloops, 1,\n-\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-\tabort ();\n+      ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\t\t\t\t  loops, 1,\n+\t\t\t\t\t  wont_exit, desc->out_edge,\n+\t\t\t\t\t  remove_edges, &n_remove_edges,\n+\t\t\t\t\t  DLTHE_FLAG_UPDATE_FREQ);\n+      gcc_assert (ok);\n \n       /* Create item for switch.  */\n       j = n_peel - i - (extra_zero_check ? 0 : 1);\n       p = REG_BR_PROB_BASE / (i + 2);\n \n       preheader = loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n       branch_code = compare_and_jump_seq (copy_rtx (niter), GEN_INT (j), EQ,\n-\t\t\t\t\t  block_label (preheader), p, NULL_RTX);\n+\t\t\t\t\t  block_label (preheader), p,\n+\t\t\t\t\t  NULL_RTX);\n \n       swtch = loop_split_edge_with (single_pred_edge (swtch), branch_code);\n       set_immediate_dominator (CDI_DOMINATORS, preheader, swtch);\n@@ -1058,7 +1068,8 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       swtch = ezc_swtch;\n       preheader = loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n       branch_code = compare_and_jump_seq (copy_rtx (niter), const0_rtx, EQ,\n-\t\t\t\t\t  block_label (preheader), p, NULL_RTX);\n+\t\t\t\t\t  block_label (preheader), p,\n+\t\t\t\t\t  NULL_RTX);\n \n       swtch = loop_split_edge_with (single_succ_edge (swtch), branch_code);\n       set_immediate_dominator (CDI_DOMINATORS, preheader, swtch);\n@@ -1077,11 +1088,12 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n   RESET_BIT (wont_exit, may_exit_copy);\n   opt_info_start_duplication (opt_info);\n   \n-  if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n-\t\tloops, max_unroll,\n-\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-    abort ();\n+  ok = duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n+\t\t\t\t      loops, max_unroll,\n+\t\t\t\t      wont_exit, desc->out_edge,\n+\t\t\t\t      remove_edges, &n_remove_edges,\n+\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ);\n+  gcc_assert (ok);\n   \n   if (opt_info)\n     {\n@@ -1094,7 +1106,8 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n   if (exit_at_end)\n     {\n       basic_block exit_block = desc->in_edge->src->rbi->copy;\n-      /* Find a new in and out edge; they are in the last copy we have made.  */\n+      /* Find a new in and out edge; they are in the last copy we have\n+\t made.  */\n       \n       if (EDGE_SUCC (exit_block, 0)->dest == desc->out_edge->dest)\n \t{\n@@ -1119,7 +1132,8 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n      the correct new number of iterations is this:  */\n   gcc_assert (!desc->const_iter);\n   desc->niter_expr =\n-    simplify_gen_binary (UDIV, desc->mode, old_niter, GEN_INT (max_unroll + 1));\n+    simplify_gen_binary (UDIV, desc->mode, old_niter,\n+\t\t\t GEN_INT (max_unroll + 1));\n   desc->niter_max /= max_unroll + 1;\n   if (exit_at_end)\n     {\n@@ -1242,6 +1256,7 @@ peel_loop_simple (struct loops *loops, struct loop *loop)\n   unsigned npeel = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n   struct opt_info *opt_info = NULL;\n+  bool ok;\n   \n   if (flag_split_ivs_in_unroller && npeel > 1)\n     opt_info = analyze_insns_in_loop (loop);\n@@ -1251,10 +1266,11 @@ peel_loop_simple (struct loops *loops, struct loop *loop)\n   \n   opt_info_start_duplication (opt_info);\n   \n-  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\tloops, npeel, wont_exit, NULL, NULL, NULL,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-    abort ();\n+  ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\t\t\t      loops, npeel, wont_exit,\n+\t\t\t\t      NULL, NULL,\n+\t\t\t\t      NULL, DLTHE_FLAG_UPDATE_FREQ);\n+  gcc_assert (ok);\n \n   free (wont_exit);\n   \n@@ -1387,6 +1403,7 @@ unroll_loop_stupid (struct loops *loops, struct loop *loop)\n   unsigned nunroll = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n   struct opt_info *opt_info = NULL;\n+  bool ok;\n   \n   if (flag_split_ivs_in_unroller\n       || flag_variable_expansion_in_unroller)\n@@ -1397,10 +1414,11 @@ unroll_loop_stupid (struct loops *loops, struct loop *loop)\n   sbitmap_zero (wont_exit);\n   opt_info_start_duplication (opt_info);\n   \n-  if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n-\t\tloops, nunroll, wont_exit, NULL, NULL, NULL,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-    abort ();\n+  ok = duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n+\t\t\t\t      loops, nunroll, wont_exit,\n+\t\t\t\t      NULL, NULL, NULL,\n+\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ);\n+  gcc_assert (ok);\n   \n   if (opt_info)\n     {\n@@ -1599,6 +1617,7 @@ analyze_iv_to_split_insn (rtx insn)\n   rtx set, dest;\n   struct rtx_iv iv;\n   struct iv_to_split *ivts;\n+  bool ok;\n \n   /* For now we just split the basic induction variables.  Later this may be\n      extended for example by selecting also addresses of memory references.  */\n@@ -1613,8 +1632,8 @@ analyze_iv_to_split_insn (rtx insn)\n   if (!biv_p (insn, dest))\n     return NULL;\n \n-  if (!iv_analyze (insn, dest, &iv))\n-    abort ();\n+  ok = iv_analyze (insn, dest, &iv);\n+  gcc_assert (ok);\n \n   if (iv.step == const0_rtx\n       || iv.mode != iv.extend_mode)"}, {"sha": "a61c8dfbb5dcd5d0d998dd9ad9eca55ccc259331", "filename": "gcc/loop.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -424,7 +424,7 @@ struct loop_info\n #ifndef HAVE_prefetch\n #define HAVE_prefetch 0\n #define CODE_FOR_prefetch 0\n-#define gen_prefetch(a,b,c) (abort(), NULL_RTX)\n+#define gen_prefetch(a,b,c) (gcc_unreachable (), NULL_RTX)\n #endif\n \n /* Give up the prefetch optimizations once we exceed a given threshold.\n@@ -3280,6 +3280,7 @@ find_and_verify_loops (rtx f, struct loops *loops)\n \t\t    if (invert_jump (p, new_label, 1))\n \t\t      {\n \t\t\trtx q, r;\n+\t\t\tbool only_notes;\n \n \t\t\t/* If no suitable BARRIER was found, create a suitable\n \t\t\t   one before TARGET.  Since TARGET is a fall through\n@@ -3304,8 +3305,10 @@ find_and_verify_loops (rtx f, struct loops *loops)\n \n \t\t\t/* Include the BARRIER after INSN and copy the\n \t\t\t   block after LOC.  */\n-\t\t\tif (squeeze_notes (&new_label, &last_insn_to_move))\n-\t\t\t  abort ();\n+\t\t\tonly_notes = squeeze_notes (&new_label,\n+\t\t\t\t\t\t    &last_insn_to_move);\n+\t\t\tgcc_assert (!only_notes);\n+\t\t\t\n \t\t\treorder_insns (new_label, last_insn_to_move, loc);\n \n \t\t\t/* All those insns are now in TARGET_LOOP.  */\n@@ -7649,9 +7652,9 @@ basic_induction_var (const struct loop *loop, rtx x, enum machine_mode mode,\n     case CONST_INT:\n     case SYMBOL_REF:\n     case CONST:\n-      /* convert_modes aborts if we try to convert to or from CCmode, so just\n+      /* convert_modes dies if we try to convert to or from CCmode, so just\n          exclude that case.  It is very unlikely that a condition code value\n-\t would be a useful iterator anyways.  convert_modes aborts if we try to\n+\t would be a useful iterator anyways.  convert_modes dies if we try to\n \t convert a float mode to non-float or vice versa too.  */\n       if (loop->level == 1\n \t  && GET_MODE_CLASS (mode) == GET_MODE_CLASS (GET_MODE (dest_reg))"}, {"sha": "11cfdcb01ad1ff0a68b4d02c3d90afd09ccdaf74", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -638,8 +638,7 @@ normalize_sched_times (partial_schedule_ptr ps)\n       ddg_node_ptr u = &g->nodes[i];\n       int normalized_time = SCHED_TIME (u) - amount;\n \n-      if (normalized_time < 0)\n-\tabort ();\n+      gcc_assert (normalized_time >= 0);\n \n       SCHED_TIME (u) = normalized_time;\n       SCHED_ROW (u) = normalized_time % ii;\n@@ -1733,8 +1732,7 @@ check_nodes_order (int *node_order, int num_nodes)\n     {\n       int u = node_order[i];\n \n-      if (u >= num_nodes || u < 0 || TEST_BIT (tmp, u))\n-\tabort ();\n+      gcc_assert (u < num_nodes && u >= 0 && !TEST_BIT (tmp, u));\n \n       SET_BIT (tmp, u);\n     }"}, {"sha": "398fdfc0ad43cea6922027a3a80afe345d7961ed", "filename": "gcc/value-prof.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -1789,7 +1789,7 @@ tree_find_values_to_profile (histogram_values *values)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n }"}, {"sha": "832b55b1d1fef2dbcd95ea61bf2a84c21951b2f5", "filename": "gcc/varasm.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41806d92af91cf26e52aa00a536cf3094ef2648b/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=41806d92af91cf26e52aa00a536cf3094ef2648b", "patch": "@@ -470,7 +470,7 @@ named_section (tree decl, const char *name, int reloc)\n   flags = targetm.section_type_flags (decl, name, reloc);\n \n   /* Sanity check user variables for flag changes.  Non-user\n-     section flag changes will abort in named_section_flags.\n+     section flag changes will die in named_section_flags.\n      However, don't complain if SECTION_OVERRIDE is set.\n      We trust that the setter knows that it is safe to ignore\n      the default flags for this decl.  */\n@@ -2170,8 +2170,8 @@ default_assemble_integer (rtx x ATTRIBUTE_UNUSED,\n \n /* Assemble the integer constant X into an object of SIZE bytes.  ALIGN is\n    the alignment of the integer in bits.  Return 1 if we were able to output\n-   the constant, otherwise 0.  If FORCE is nonzero, abort if we can't output\n-   the constant.  */\n+   the constant, otherwise 0.  We must be able to output the constant,\n+   if FORCE is nonzero.  */\n \n bool\n assemble_integer (rtx x, unsigned int size, unsigned int align, int force)\n@@ -2259,7 +2259,7 @@ assemble_real (REAL_VALUE_TYPE d, enum machine_mode mode, unsigned int align)\n /* Given an expression EXP with a constant value,\n    reduce it to the sum of an assembler symbol and an integer.\n    Store them both in the structure *VALUE.\n-   Abort if EXP does not reduce.  */\n+   EXP must be reduceable.  */\n \n struct addr_const GTY(())\n {"}]}