{"sha": "b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhjNmE0NWFiN2EwYTZjOGM3YTYzMTVmMjU1MzEyYjMyYjVhODQwMw==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2014-05-28T09:43:52Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2014-05-28T09:43:52Z"}, "message": "-fuse-caller-save - Support in lra\n\n2014-05-28  Tom de Vries  <tom@codesourcery.com>\n\n\t* lra-int.h (struct lra_reg): Add field actual_call_used_reg_set.\n\t* lra.c (initialize_lra_reg_info_element): Add init of\n\tactual_call_used_reg_set field.\n\t(lra): Call lra_create_live_ranges before lra_inheritance for\n\t-fuse-caller-save.\n\t* lra-assigns.c (lra_assign): Allow call_used_regs to cross calls for\n\t-fuse-caller-save.\n\t* lra-constraints.c (need_for_call_save_p): Use actual_call_used_reg_set\n\tinstead of call_used_reg_set for -fuse-caller-save.\n\t* lra-lives.c (process_bb_lives): Calculate actual_call_used_reg_set.\n\nFrom-SVN: r211010", "tree": {"sha": "693caa7eb8b98cbb78ccdeb56f79134e22d8d581", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/693caa7eb8b98cbb78ccdeb56f79134e22d8d581"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403/comments", "author": null, "committer": null, "parents": [{"sha": "dbe7d9e3ffd9c5cdb879dd705ed86da5972773ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbe7d9e3ffd9c5cdb879dd705ed86da5972773ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbe7d9e3ffd9c5cdb879dd705ed86da5972773ac"}], "stats": {"total": 62, "additions": 57, "deletions": 5}, "files": [{"sha": "b0f47ae764291cf11757883219777f9eee6b72b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403", "patch": "@@ -1,3 +1,16 @@\n+2014-05-28  Tom de Vries  <tom@codesourcery.com>\n+\n+\t* lra-int.h (struct lra_reg): Add field actual_call_used_reg_set.\n+\t* lra.c (initialize_lra_reg_info_element): Add init of\n+\tactual_call_used_reg_set field.\n+\t(lra): Call lra_create_live_ranges before lra_inheritance for\n+\t-fuse-caller-save.\n+\t* lra-assigns.c (lra_assign): Allow call_used_regs to cross calls for\n+\t-fuse-caller-save.\n+\t* lra-constraints.c (need_for_call_save_p): Use actual_call_used_reg_set\n+\tinstead of call_used_reg_set for -fuse-caller-save.\n+\t* lra-lives.c (process_bb_lives): Calculate actual_call_used_reg_set.\n+\n 2014-05-28  Radovan Obradovic  <robradovic@mips.com>\n             Tom de Vries  <tom@codesourcery.com>\n "}, {"sha": "34b4a119667018d6876280e621ba4d0a963a40a0", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403", "patch": "@@ -1447,6 +1447,7 @@ lra_assign (void)\n   bitmap_head insns_to_process;\n   bool no_spills_p;\n   int max_regno = max_reg_num ();\n+  unsigned int call_used_reg_crosses_call = 0;\n \n   timevar_push (TV_LRA_ASSIGN);\n   init_lives ();\n@@ -1459,14 +1460,22 @@ lra_assign (void)\n   bitmap_initialize (&all_spilled_pseudos, &reg_obstack);\n   create_live_range_start_chains ();\n   setup_live_pseudos_and_spill_after_risky_transforms (&all_spilled_pseudos);\n-#ifdef ENABLE_CHECKING\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     if (lra_reg_info[i].nrefs != 0 && reg_renumber[i] >= 0\n \t&& lra_reg_info[i].call_p\n \t&& overlaps_hard_reg_set_p (call_used_reg_set,\n \t\t\t\t    PSEUDO_REGNO_MODE (i), reg_renumber[i]))\n-      gcc_unreachable ();\n-#endif\n+      {\n+\tif (!flag_use_caller_save)\n+\t  gcc_unreachable ();\n+\tcall_used_reg_crosses_call++;\n+      }\n+  if (lra_dump_file\n+      && call_used_reg_crosses_call > 0)\n+    fprintf (lra_dump_file,\n+\t     \"Found %u pseudo(s) with a call used reg crossing a call.\\n\"\n+\t     \"Allowing due to -fuse-caller-save\\n\",\n+\t     call_used_reg_crosses_call);    \n   /* Setup insns to process on the next constraint pass.  */\n   bitmap_initialize (&changed_pseudo_bitmap, &reg_obstack);\n   init_live_reload_and_inheritance_pseudos ();"}, {"sha": "7eb9dbc08b1cfec7e560817c82c1e120bef4ad2e", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403", "patch": "@@ -4605,7 +4605,10 @@ need_for_call_save_p (int regno)\n   lra_assert (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] >= 0);\n   return (usage_insns[regno].calls_num < calls_num\n \t  && (overlaps_hard_reg_set_p\n-\t      (call_used_reg_set,\n+\t      ((flag_use_caller_save &&\n+\t\t! hard_reg_set_empty_p (lra_reg_info[regno].actual_call_used_reg_set))\n+\t       ? lra_reg_info[regno].actual_call_used_reg_set\n+\t       : call_used_reg_set,\n \t       PSEUDO_REGNO_MODE (regno), reg_renumber[regno])\n \t      || HARD_REGNO_CALL_PART_CLOBBERED (reg_renumber[regno],\n \t\t\t\t\t\t PSEUDO_REGNO_MODE (regno))));"}, {"sha": "98a30183caadc67d789c9d038612c708bdaece15", "filename": "gcc/lra-int.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403", "patch": "@@ -77,6 +77,10 @@ struct lra_reg\n   /* The following fields are defined only for pseudos.\t */\n   /* Hard registers with which the pseudo conflicts.  */\n   HARD_REG_SET conflict_hard_regs;\n+  /* Call used registers with which the pseudo conflicts, taking into account\n+     the registers used by functions called from calls which cross the\n+     pseudo. */\n+  HARD_REG_SET actual_call_used_reg_set;\n   /* We assign hard registers to reload pseudos which can occur in few\n      places.  So two hard register preferences are enough for them.\n      The following fields define the preferred hard registers.\tIf"}, {"sha": "d0072158c031efc503ec35f0267b58b649f3d381", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403", "patch": "@@ -624,6 +624,17 @@ process_bb_lives (basic_block bb, int &curr_point)\n \n       if (call_p)\n \t{\n+\t  if (flag_use_caller_save)\n+\t    {\n+\t      HARD_REG_SET this_call_used_reg_set;\n+\t      get_call_reg_set_usage (curr_insn, &this_call_used_reg_set,\n+\t\t\t\t      call_used_reg_set);\n+\n+\t      EXECUTE_IF_SET_IN_SPARSESET (pseudos_live, j)\n+\t\tIOR_HARD_REG_SET (lra_reg_info[j].actual_call_used_reg_set,\n+\t\t\t\t  this_call_used_reg_set);\n+\t    }\n+ \n \t  sparseset_ior (pseudos_live_through_calls,\n \t\t\t pseudos_live_through_calls, pseudos_live);\n \t  if (cfun->has_nonlocal_label"}, {"sha": "d199a813fbea9c78c2f3742f6692014cf7768c28", "filename": "gcc/lra.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=b8c6a45ab7a0a6c8c7a6315f255312b32b5a8403", "patch": "@@ -1427,6 +1427,7 @@ initialize_lra_reg_info_element (int i)\n   lra_reg_info[i].no_stack_p = false;\n #endif\n   CLEAR_HARD_REG_SET (lra_reg_info[i].conflict_hard_regs);\n+  CLEAR_HARD_REG_SET (lra_reg_info[i].actual_call_used_reg_set);\n   lra_reg_info[i].preferred_hard_regno1 = -1;\n   lra_reg_info[i].preferred_hard_regno2 = -1;\n   lra_reg_info[i].preferred_hard_regno_profit1 = 0;\n@@ -2344,7 +2345,18 @@ lra (FILE *f)\n \t  lra_eliminate (false, false);\n \t  /* Do inheritance only for regular algorithms.  */\n \t  if (! lra_simple_p)\n-\t    lra_inheritance ();\n+\t    {\n+\t      if (flag_use_caller_save)\n+\t\t{\n+\t\t  if (live_p)\n+\t\t    lra_clear_live_ranges ();\n+\t\t  /* As a side-effect of lra_create_live_ranges, we calculate\n+\t\t     actual_call_used_reg_set,  which is needed during\n+\t\t     lra_inheritance.  */\n+\t\t  lra_create_live_ranges (true);\n+\t\t}\n+\t      lra_inheritance ();\n+\t    }\n \t  if (live_p)\n \t    lra_clear_live_ranges ();\n \t  /* We need live ranges for lra_assign -- so build them.  */"}]}