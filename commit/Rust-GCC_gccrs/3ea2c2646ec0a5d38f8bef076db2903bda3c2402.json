{"sha": "3ea2c2646ec0a5d38f8bef076db2903bda3c2402", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VhMmMyNjQ2ZWMwYTVkMzhmOGJlZjA3NmRiMjkwM2JkYTNjMjQwMg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-04T19:59:45Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-04T19:59:45Z"}, "message": "fold-const.c (fold_ternary): Unroll the \"for\" loop to extract operands.\n\n\t* fold-const.c (fold_ternary): Unroll the \"for\" loop to\n\textract operands.\n\nFrom-SVN: r95895", "tree": {"sha": "04bf0ca1f23f409f1ff6c6383484081c82ecf5a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04bf0ca1f23f409f1ff6c6383484081c82ecf5a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ea2c2646ec0a5d38f8bef076db2903bda3c2402", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ea2c2646ec0a5d38f8bef076db2903bda3c2402", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ea2c2646ec0a5d38f8bef076db2903bda3c2402", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ea2c2646ec0a5d38f8bef076db2903bda3c2402/comments", "author": null, "committer": null, "parents": [{"sha": "b120f3b75c5279d35d5ea1f22cd72eab8f23abf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b120f3b75c5279d35d5ea1f22cd72eab8f23abf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b120f3b75c5279d35d5ea1f22cd72eab8f23abf3"}], "stats": {"total": 111, "additions": 52, "deletions": 59}, "files": [{"sha": "1ed3dbd2c0cdec1b2c4dc771a345ff6592ec05b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea2c2646ec0a5d38f8bef076db2903bda3c2402/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea2c2646ec0a5d38f8bef076db2903bda3c2402/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ea2c2646ec0a5d38f8bef076db2903bda3c2402", "patch": "@@ -1,3 +1,8 @@\n+2005-03-04  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* fold-const.c (fold_ternary): Unroll the \"for\" loop to\n+\textract operands.  \n+\n 2005-03-04  Andrew Haley  <aph@redhat.com>\n \n \t* unwind-dw2-fde-glibc.c (struct"}, {"sha": "df9e8a26d221de26077ab703573565c2f2babb7f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 47, "deletions": 59, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea2c2646ec0a5d38f8bef076db2903bda3c2402/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea2c2646ec0a5d38f8bef076db2903bda3c2402/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3ea2c2646ec0a5d38f8bef076db2903bda3c2402", "patch": "@@ -7024,41 +7024,38 @@ fold_ternary (tree expr)\n   const tree t = expr;\n   const tree type = TREE_TYPE (expr);\n   tree tem;\n+  tree op0, op1, op2;\n   tree arg0 = NULL_TREE, arg1 = NULL_TREE;\n   enum tree_code code = TREE_CODE (t);\n   enum tree_code_class kind = TREE_CODE_CLASS (code);\n-  int i;\n \n   gcc_assert (IS_EXPR_CODE_CLASS (kind)\n \t      && TREE_CODE_LENGTH (code) == 3);\n \n-  /* For now, we iterate only twice even though we are handling\n-     ternary expressions.  This is because we haven't defined arg2\n-     yet.  */\n-  for (i = 0; i < 2; i++)\n-    {\n-      tree op = TREE_OPERAND (t, i);\n-\n-      if (op == 0)\n-\tcontinue;\t\t/* Valid for CALL_EXPR, at least.  */\n+  op0 = TREE_OPERAND (t, 0);\n+  op1 = TREE_OPERAND (t, 1);\n+  op2 = TREE_OPERAND (t, 2);\n \n-      /* Strip any conversions that don't change the mode.  This is\n-\t safe for every expression, except for a comparison expression\n-\t because its signedness is derived from its operands.  So, in\n-\t the latter case, only strip conversions that don't change the\n-\t signedness.\n+  /* Strip any conversions that don't change the mode.  This is safe\n+     for every expression, except for a comparison expression because\n+     its signedness is derived from its operands.  So, in the latter\n+     case, only strip conversions that don't change the signedness.\n \n-\t Note that this is done as an internal manipulation within the\n-\t constant folder, in order to find the simplest representation\n-\t of the arguments so that their form can be studied.  In any\n-\t cases, the appropriate type conversions should be put back in\n-\t the tree that will get out of the constant folder.  */\n-      STRIP_NOPS (op);\n+     Note that this is done as an internal manipulation within the\n+     constant folder, in order to find the simplest representation of\n+     the arguments so that their form can be studied.  In any cases,\n+     the appropriate type conversions should be put back in the tree\n+     that will get out of the constant folder.  */\n+  if (op0)\n+    {\n+      arg0 = op0;\n+      STRIP_NOPS (arg0);\n+    }\n \n-      if (i == 0)\n-\targ0 = op;\n-      else if (i == 1)\n-\targ1 = op;\n+  if (op1)\n+    {\n+      arg1 = op1;\n+      STRIP_NOPS (arg1);\n     }\n \n   switch (code)\n@@ -7078,7 +7075,7 @@ fold_ternary (tree expr)\n \t so all simple results must be passed through pedantic_non_lvalue.  */\n       if (TREE_CODE (arg0) == INTEGER_CST)\n \t{\n-\t  tem = TREE_OPERAND (t, (integer_zerop (arg0) ? 2 : 1));\n+\t  tem = integer_zerop (arg0) ? op2 : op1;\n \t  /* Only optimize constant conditions when the selected branch\n \t     has the same type as the COND_EXPR.  This avoids optimizing\n \t     away \"c ? x : throw\", where the throw has a void type.  */\n@@ -7087,7 +7084,7 @@ fold_ternary (tree expr)\n \t    return pedantic_non_lvalue (tem);\n \t  return t;\n \t}\n-      if (operand_equal_p (arg1, TREE_OPERAND (t, 2), 0))\n+      if (operand_equal_p (arg1, op2, 0))\n \treturn pedantic_omit_one_operand (type, arg1, arg0);\n \n       /* If we have A op B ? A : C, we may be able to convert this to a\n@@ -7101,49 +7098,43 @@ fold_ternary (tree expr)\n \t\t\t\t\t     arg1, TREE_OPERAND (arg0, 1))\n \t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n \t{\n-\t  tem = fold_cond_expr_with_comparison (type, arg0,\n-\t\t\t\t\t\tTREE_OPERAND (t, 1),\n-\t\t\t\t\t\tTREE_OPERAND (t, 2));\n+\t  tem = fold_cond_expr_with_comparison (type, arg0, op1, op2);\n \t  if (tem)\n \t    return tem;\n \t}\n \n       if (COMPARISON_CLASS_P (arg0)\n \t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t\t     TREE_OPERAND (t, 2),\n+\t\t\t\t\t     op2,\n \t\t\t\t\t     TREE_OPERAND (arg0, 1))\n-\t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (TREE_OPERAND (t, 2)))))\n+\t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (op2))))\n \t{\n \t  tem = invert_truthvalue (arg0);\n \t  if (COMPARISON_CLASS_P (tem))\n \t    {\n-\t      tem = fold_cond_expr_with_comparison (type, tem,\n-\t\t\t\t\t\t    TREE_OPERAND (t, 2),\n-\t\t\t\t\t\t    TREE_OPERAND (t, 1));\n+\t      tem = fold_cond_expr_with_comparison (type, tem, op2, op1);\n \t      if (tem)\n \t\treturn tem;\n \t    }\n \t}\n \n       /* If the second operand is simpler than the third, swap them\n \t since that produces better jump optimization results.  */\n-      if (tree_swap_operands_p (TREE_OPERAND (t, 1),\n-\t\t\t\tTREE_OPERAND (t, 2), false))\n+      if (tree_swap_operands_p (op1, op2, false))\n \t{\n \t  /* See if this can be inverted.  If it can't, possibly because\n \t     it was a floating-point inequality comparison, don't do\n \t     anything.  */\n \t  tem = invert_truthvalue (arg0);\n \n \t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n-\t    return fold (build3 (code, type, tem,\n-\t\t\t\t TREE_OPERAND (t, 2), TREE_OPERAND (t, 1)));\n+\t    return fold (build3 (code, type, tem, op2, op1));\n \t}\n \n       /* Convert A ? 1 : 0 to simply A.  */\n-      if (integer_onep (TREE_OPERAND (t, 1))\n-\t  && integer_zerop (TREE_OPERAND (t, 2))\n-\t  /* If we try to convert TREE_OPERAND (t, 0) to our type, the\n+      if (integer_onep (op1)\n+\t  && integer_zerop (op2)\n+\t  /* If we try to convert OP0 to our type, the\n \t     call to fold will try to move the conversion inside\n \t     a COND, which will recurse.  In that case, the COND_EXPR\n \t     is probably the best choice, so leave it alone.  */\n@@ -7152,16 +7143,16 @@ fold_ternary (tree expr)\n \n       /* Convert A ? 0 : 1 to !A.  This prefers the use of NOT_EXPR\n \t over COND_EXPR in cases such as floating point comparisons.  */\n-      if (integer_zerop (TREE_OPERAND (t, 1))\n-\t  && integer_onep (TREE_OPERAND (t, 2))\n+      if (integer_zerop (op1)\n+\t  && integer_onep (op2)\n \t  && truth_value_p (TREE_CODE (arg0)))\n \treturn pedantic_non_lvalue (fold_convert (type,\n \t\t\t\t\t\t  invert_truthvalue (arg0)));\n \n       /* A < 0 ? <sign bit of A> : 0 is simply (A & <sign bit of A>).  */\n       if (TREE_CODE (arg0) == LT_EXPR\n           && integer_zerop (TREE_OPERAND (arg0, 1))\n-          && integer_zerop (TREE_OPERAND (t, 2))\n+          && integer_zerop (op2)\n           && (tem = sign_bit_p (TREE_OPERAND (arg0, 0), arg1)))\n         return fold_convert (type, fold (build2 (BIT_AND_EXPR,\n \t\t\t\t\t\t TREE_TYPE (tem), tem, arg1)));\n@@ -7170,7 +7161,7 @@ fold_ternary (tree expr)\n \t already handled above.  */\n       if (TREE_CODE (arg0) == BIT_AND_EXPR\n \t  && integer_onep (TREE_OPERAND (arg0, 1))\n-\t  && integer_zerop (TREE_OPERAND (t, 2))\n+\t  && integer_zerop (op2)\n \t  && integer_pow2p (arg1))\n \t{\n \t  tree tem = TREE_OPERAND (arg0, 0);\n@@ -7187,7 +7178,7 @@ fold_ternary (tree expr)\n \t is probably obsolete because the first operand should be a\n \t truth value (that's why we have the two cases above), but let's\n \t leave it in until we can confirm this for all front-ends.  */\n-      if (integer_zerop (TREE_OPERAND (t, 2))\n+      if (integer_zerop (op2)\n \t  && TREE_CODE (arg0) == NE_EXPR\n \t  && integer_zerop (TREE_OPERAND (arg0, 1))\n \t  && integer_pow2p (arg1)\n@@ -7198,13 +7189,13 @@ fold_ternary (tree expr)\n \t\t\t\t\t\t  TREE_OPERAND (arg0, 0)));\n \n       /* Convert A ? B : 0 into A && B if A and B are truth values.  */\n-      if (integer_zerop (TREE_OPERAND (t, 2))\n+      if (integer_zerop (op2)\n \t  && truth_value_p (TREE_CODE (arg0))\n \t  && truth_value_p (TREE_CODE (arg1)))\n \treturn fold (build2 (TRUTH_ANDIF_EXPR, type, arg0, arg1));\n \n       /* Convert A ? B : 1 into !A || B if A and B are truth values.  */\n-      if (integer_onep (TREE_OPERAND (t, 2))\n+      if (integer_onep (op2)\n \t  && truth_value_p (TREE_CODE (arg0))\n \t  && truth_value_p (TREE_CODE (arg1)))\n \t{\n@@ -7217,30 +7208,27 @@ fold_ternary (tree expr)\n       /* Convert A ? 0 : B into !A && B if A and B are truth values.  */\n       if (integer_zerop (arg1)\n \t  && truth_value_p (TREE_CODE (arg0))\n-\t  && truth_value_p (TREE_CODE (TREE_OPERAND (t, 2))))\n+\t  && truth_value_p (TREE_CODE (op2)))\n \t{\n \t  /* Only perform transformation if ARG0 is easily inverted.  */\n \t  tem = invert_truthvalue (arg0);\n \t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n-\t    return fold (build2 (TRUTH_ANDIF_EXPR, type, tem,\n-\t\t\t\t TREE_OPERAND (t, 2)));\n+\t    return fold (build2 (TRUTH_ANDIF_EXPR, type, tem, op2));\n \t}\n \n       /* Convert A ? 1 : B into A || B if A and B are truth values.  */\n       if (integer_onep (arg1)\n \t  && truth_value_p (TREE_CODE (arg0))\n-\t  && truth_value_p (TREE_CODE (TREE_OPERAND (t, 2))))\n-\treturn fold (build2 (TRUTH_ORIF_EXPR, type, arg0,\n-\t\t\t     TREE_OPERAND (t, 2)));\n+\t  && truth_value_p (TREE_CODE (op2)))\n+\treturn fold (build2 (TRUTH_ORIF_EXPR, type, arg0, op2));\n \n       return t;\n \n     case CALL_EXPR:\n       /* Check for a built-in function.  */\n-      if (TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR\n-\t  && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (t, 0), 0))\n-\t      == FUNCTION_DECL)\n-\t  && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (t, 0), 0)))\n+      if (TREE_CODE (op0) == ADDR_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (op0, 0)) == FUNCTION_DECL\n+\t  && DECL_BUILT_IN (TREE_OPERAND (op0, 0)))\n \t{\n \t  tree tmp = fold_builtin (t, false);\n \t  if (tmp)"}]}