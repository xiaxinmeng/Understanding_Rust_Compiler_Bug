{"sha": "a9cc9cc69a8de25ba338b5021dc7667ad2610f7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTljYzljYzY5YThkZTI1YmEzMzhiNTAyMWRjNzY2N2FkMjYxMGY3Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-01-02T19:19:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-01-02T19:19:22Z"}, "message": "i386.c (*_cost): Add COSTS_N_INSNS.\n\n\t* i386.c (*_cost): Add COSTS_N_INSNS.\n\t(ix86_rtx_costs): Do not use COSTS_N_INSNS.\n\nFrom-SVN: r109242", "tree": {"sha": "ed3d229acfa6e52ed9263c363b44aade35b31cd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed3d229acfa6e52ed9263c363b44aade35b31cd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9cc9cc69a8de25ba338b5021dc7667ad2610f7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9cc9cc69a8de25ba338b5021dc7667ad2610f7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9cc9cc69a8de25ba338b5021dc7667ad2610f7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9cc9cc69a8de25ba338b5021dc7667ad2610f7f/comments", "author": null, "committer": null, "parents": [{"sha": "4c4b3eb0fcd841317cb4ccee76a1152a32e7be8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c4b3eb0fcd841317cb4ccee76a1152a32e7be8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c4b3eb0fcd841317cb4ccee76a1152a32e7be8d"}], "stats": {"total": 426, "additions": 256, "deletions": 170}, "files": [{"sha": "28340961b8f75d0dfed7c6ea829e3fdd341660bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9cc9cc69a8de25ba338b5021dc7667ad2610f7f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9cc9cc69a8de25ba338b5021dc7667ad2610f7f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9cc9cc69a8de25ba338b5021dc7667ad2610f7f", "patch": "@@ -1,3 +1,8 @@\n+2006-01-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (*_cost): Add COSTS_N_INSNS.\n+\t(ix86_rtx_costs): Do not use COSTS_N_INSNS.\n+\n 2006-01-02  Paolo Bonzini  <bonzini@gnu.org>\n \n         PR target/25259"}, {"sha": "c9886fd105a2a04021b0da49b301e9be3d8efed4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 251, "deletions": 170, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9cc9cc69a8de25ba338b5021dc7667ad2610f7f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9cc9cc69a8de25ba338b5021dc7667ad2610f7f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a9cc9cc69a8de25ba338b5021dc7667ad2610f7f", "patch": "@@ -65,15 +65,23 @@ Boston, MA 02110-1301, USA.  */\n /* Processor costs (relative to an add) */\n static const\n struct processor_costs size_cost = {\t/* costs for tunning for size */\n-  2,\t\t\t\t\t/* cost of an add instruction */\n-  3,\t\t\t\t\t/* cost of a lea instruction */\n-  2,\t\t\t\t\t/* variable shift costs */\n-  3,\t\t\t\t\t/* constant shift costs */\n-  {3, 3, 3, 3, 5},\t\t\t/* cost of starting a multiply */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (2),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (3),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (3),\t\t\t/*                               HI */\n+   COSTS_N_INSNS (3),\t\t\t/*                               SI */\n+   COSTS_N_INSNS (3),\t\t\t/*                               DI */\n+   COSTS_N_INSNS (5)},\t\t\t/*                               other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {3, 3, 3, 3, 5},\t\t\t/* cost of a divide/mod */\n-  3,\t\t\t\t\t/* cost of movsx */\n-  3,\t\t\t\t\t/* cost of movzx */\n+  {COSTS_N_INSNS (3),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (3),\t\t\t/*                          HI */\n+   COSTS_N_INSNS (3),\t\t\t/*                          SI */\n+   COSTS_N_INSNS (3),\t\t\t/*                          DI */\n+   COSTS_N_INSNS (5)},\t\t\t/*                          other */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of movzx */\n   0,\t\t\t\t\t/* \"large\" insn */\n   2,\t\t\t\t\t/* MOVE_RATIO */\n   2,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -99,26 +107,34 @@ struct processor_costs size_cost = {\t/* costs for tunning for size */\n   0,\t\t\t\t\t/* size of prefetch block */\n   0,\t\t\t\t\t/* number of parallel prefetches */\n   1,\t\t\t\t\t/* Branch cost */\n-  2,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n-  2,\t\t\t\t\t/* cost of FMUL instruction.  */\n-  2,\t\t\t\t\t/* cost of FDIV instruction.  */\n-  2,\t\t\t\t\t/* cost of FABS instruction.  */\n-  2,\t\t\t\t\t/* cost of FCHS instruction.  */\n-  2,\t\t\t\t\t/* cost of FSQRT instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FSQRT instruction.  */\n };\n \n /* Processor costs (relative to an add) */\n static const\n struct processor_costs i386_cost = {\t/* 386 specific costs */\n-  1,\t\t\t\t\t/* cost of an add instruction */\n-  1,\t\t\t\t\t/* cost of a lea instruction */\n-  3,\t\t\t\t\t/* variable shift costs */\n-  2,\t\t\t\t\t/* constant shift costs */\n-  {6, 6, 6, 6, 6},\t\t\t/* cost of starting a multiply */\n-  1,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {23, 23, 23, 23, 23},\t\t\t/* cost of a divide/mod */\n-  3,\t\t\t\t\t/* cost of movsx */\n-  2,\t\t\t\t\t/* cost of movzx */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (3),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (2),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (6),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (6),\t\t\t/*                               HI */\n+   COSTS_N_INSNS (6),\t\t\t/*                               SI */\n+   COSTS_N_INSNS (6),\t\t\t/*                               DI */\n+   COSTS_N_INSNS (6)},\t\t\t/*                               other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of multiply per each bit set */\n+  {COSTS_N_INSNS (23),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (23),\t\t\t/*                          HI */\n+   COSTS_N_INSNS (23),\t\t\t/*                          SI */\n+   COSTS_N_INSNS (23),\t\t\t/*                          DI */\n+   COSTS_N_INSNS (23)},\t\t\t/*                          other */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   15,\t\t\t\t\t/* \"large\" insn */\n   3,\t\t\t\t\t/* MOVE_RATIO */\n   4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -144,25 +160,33 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   0,\t\t\t\t\t/* size of prefetch block */\n   0,\t\t\t\t\t/* number of parallel prefetches */\n   1,\t\t\t\t\t/* Branch cost */\n-  23,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n-  27,\t\t\t\t\t/* cost of FMUL instruction.  */\n-  88,\t\t\t\t\t/* cost of FDIV instruction.  */\n-  22,\t\t\t\t\t/* cost of FABS instruction.  */\n-  24,\t\t\t\t\t/* cost of FCHS instruction.  */\n-  122,\t\t\t\t\t/* cost of FSQRT instruction.  */\n+  COSTS_N_INSNS (23),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (27),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (88),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (22),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (24),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (122),\t\t\t/* cost of FSQRT instruction.  */\n };\n \n static const\n struct processor_costs i486_cost = {\t/* 486 specific costs */\n-  1,\t\t\t\t\t/* cost of an add instruction */\n-  1,\t\t\t\t\t/* cost of a lea instruction */\n-  3,\t\t\t\t\t/* variable shift costs */\n-  2,\t\t\t\t\t/* constant shift costs */\n-  {12, 12, 12, 12, 12},\t\t\t/* cost of starting a multiply */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (3),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (2),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (12),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (12),\t\t\t/*                               HI */\n+   COSTS_N_INSNS (12),\t\t\t/*                               SI */\n+   COSTS_N_INSNS (12),\t\t\t/*                               DI */\n+   COSTS_N_INSNS (12)},\t\t\t/*                               other */\n   1,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {40, 40, 40, 40, 40},\t\t\t/* cost of a divide/mod */\n-  3,\t\t\t\t\t/* cost of movsx */\n-  2,\t\t\t\t\t/* cost of movzx */\n+  {COSTS_N_INSNS (40),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (40),\t\t\t/*                          HI */\n+   COSTS_N_INSNS (40),\t\t\t/*                          SI */\n+   COSTS_N_INSNS (40),\t\t\t/*                          DI */\n+   COSTS_N_INSNS (40)},\t\t\t/*                          other */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   15,\t\t\t\t\t/* \"large\" insn */\n   3,\t\t\t\t\t/* MOVE_RATIO */\n   4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -188,25 +212,33 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   0,\t\t\t\t\t/* size of prefetch block */\n   0,\t\t\t\t\t/* number of parallel prefetches */\n   1,\t\t\t\t\t/* Branch cost */\n-  8,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n-  16,\t\t\t\t\t/* cost of FMUL instruction.  */\n-  73,\t\t\t\t\t/* cost of FDIV instruction.  */\n-  3,\t\t\t\t\t/* cost of FABS instruction.  */\n-  3,\t\t\t\t\t/* cost of FCHS instruction.  */\n-  83,\t\t\t\t\t/* cost of FSQRT instruction.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (16),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (73),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (83),\t\t\t/* cost of FSQRT instruction.  */\n };\n \n static const\n struct processor_costs pentium_cost = {\n-  1,\t\t\t\t\t/* cost of an add instruction */\n-  1,\t\t\t\t\t/* cost of a lea instruction */\n-  4,\t\t\t\t\t/* variable shift costs */\n-  1,\t\t\t\t\t/* constant shift costs */\n-  {11, 11, 11, 11, 11},\t\t\t/* cost of starting a multiply */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (4),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (11),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (11),\t\t\t/*                               HI */\n+   COSTS_N_INSNS (11),\t\t\t/*                               SI */\n+   COSTS_N_INSNS (11),\t\t\t/*                               DI */\n+   COSTS_N_INSNS (11)},\t\t\t/*                               other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {25, 25, 25, 25, 25},\t\t\t/* cost of a divide/mod */\n-  3,\t\t\t\t\t/* cost of movsx */\n-  2,\t\t\t\t\t/* cost of movzx */\n+  {COSTS_N_INSNS (25),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (25),\t\t\t/*                          HI */\n+   COSTS_N_INSNS (25),\t\t\t/*                          SI */\n+   COSTS_N_INSNS (25),\t\t\t/*                          DI */\n+   COSTS_N_INSNS (25)},\t\t\t/*                          other */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   6,\t\t\t\t\t/* MOVE_RATIO */\n   6,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -232,25 +264,33 @@ struct processor_costs pentium_cost = {\n   0,\t\t\t\t\t/* size of prefetch block */\n   0,\t\t\t\t\t/* number of parallel prefetches */\n   2,\t\t\t\t\t/* Branch cost */\n-  3,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n-  3,\t\t\t\t\t/* cost of FMUL instruction.  */\n-  39,\t\t\t\t\t/* cost of FDIV instruction.  */\n-  1,\t\t\t\t\t/* cost of FABS instruction.  */\n-  1,\t\t\t\t\t/* cost of FCHS instruction.  */\n-  70,\t\t\t\t\t/* cost of FSQRT instruction.  */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (39),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (70),\t\t\t/* cost of FSQRT instruction.  */\n };\n \n static const\n struct processor_costs pentiumpro_cost = {\n-  1,\t\t\t\t\t/* cost of an add instruction */\n-  1,\t\t\t\t\t/* cost of a lea instruction */\n-  1,\t\t\t\t\t/* variable shift costs */\n-  1,\t\t\t\t\t/* constant shift costs */\n-  {4, 4, 4, 4, 4},\t\t\t/* cost of starting a multiply */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (4),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (4),\t\t\t/*                               HI */\n+   COSTS_N_INSNS (4),\t\t\t/*                               SI */\n+   COSTS_N_INSNS (4),\t\t\t/*                               DI */\n+   COSTS_N_INSNS (4)},\t\t\t/*                               other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {17, 17, 17, 17, 17},\t\t\t/* cost of a divide/mod */\n-  1,\t\t\t\t\t/* cost of movsx */\n-  1,\t\t\t\t\t/* cost of movzx */\n+  {COSTS_N_INSNS (17),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (17),\t\t\t/*                          HI */\n+   COSTS_N_INSNS (17),\t\t\t/*                          SI */\n+   COSTS_N_INSNS (17),\t\t\t/*                          DI */\n+   COSTS_N_INSNS (17)},\t\t\t/*                          other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   6,\t\t\t\t\t/* MOVE_RATIO */\n   2,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -276,25 +316,33 @@ struct processor_costs pentiumpro_cost = {\n   32,\t\t\t\t\t/* size of prefetch block */\n   6,\t\t\t\t\t/* number of parallel prefetches */\n   2,\t\t\t\t\t/* Branch cost */\n-  3,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n-  5,\t\t\t\t\t/* cost of FMUL instruction.  */\n-  56,\t\t\t\t\t/* cost of FDIV instruction.  */\n-  2,\t\t\t\t\t/* cost of FABS instruction.  */\n-  2,\t\t\t\t\t/* cost of FCHS instruction.  */\n-  56,\t\t\t\t\t/* cost of FSQRT instruction.  */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (5),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (56),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (56),\t\t\t/* cost of FSQRT instruction.  */\n };\n \n static const\n struct processor_costs k6_cost = {\n-  1,\t\t\t\t\t/* cost of an add instruction */\n-  2,\t\t\t\t\t/* cost of a lea instruction */\n-  1,\t\t\t\t\t/* variable shift costs */\n-  1,\t\t\t\t\t/* constant shift costs */\n-  {3, 3, 3, 3, 3},\t\t\t/* cost of starting a multiply */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (3),\t\t\t/*                               HI */\n+   COSTS_N_INSNS (3),\t\t\t/*                               SI */\n+   COSTS_N_INSNS (3),\t\t\t/*                               DI */\n+   COSTS_N_INSNS (3)},\t\t\t/*                               other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {18, 18, 18, 18, 18},\t\t\t/* cost of a divide/mod */\n-  2,\t\t\t\t\t/* cost of movsx */\n-  2,\t\t\t\t\t/* cost of movzx */\n+  {COSTS_N_INSNS (18),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (18),\t\t\t/*                          HI */\n+   COSTS_N_INSNS (18),\t\t\t/*                          SI */\n+   COSTS_N_INSNS (18),\t\t\t/*                          DI */\n+   COSTS_N_INSNS (18)},\t\t\t/*                          other */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   4,\t\t\t\t\t/* MOVE_RATIO */\n   3,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -320,25 +368,33 @@ struct processor_costs k6_cost = {\n   32,\t\t\t\t\t/* size of prefetch block */\n   1,\t\t\t\t\t/* number of parallel prefetches */\n   1,\t\t\t\t\t/* Branch cost */\n-  2,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n-  2,\t\t\t\t\t/* cost of FMUL instruction.  */\n-  56,\t\t\t\t\t/* cost of FDIV instruction.  */\n-  2,\t\t\t\t\t/* cost of FABS instruction.  */\n-  2,\t\t\t\t\t/* cost of FCHS instruction.  */\n-  56,\t\t\t\t\t/* cost of FSQRT instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (56),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (56),\t\t\t/* cost of FSQRT instruction.  */\n };\n \n static const\n struct processor_costs athlon_cost = {\n-  1,\t\t\t\t\t/* cost of an add instruction */\n-  2,\t\t\t\t\t/* cost of a lea instruction */\n-  1,\t\t\t\t\t/* variable shift costs */\n-  1,\t\t\t\t\t/* constant shift costs */\n-  {5, 5, 5, 5, 5},\t\t\t/* cost of starting a multiply */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (5),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (5),\t\t\t/*                               HI */\n+   COSTS_N_INSNS (5),\t\t\t/*                               SI */\n+   COSTS_N_INSNS (5),\t\t\t/*                               DI */\n+   COSTS_N_INSNS (5)},\t\t\t/*                               other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {18, 26, 42, 74, 74},\t\t\t/* cost of a divide/mod */\n-  1,\t\t\t\t\t/* cost of movsx */\n-  1,\t\t\t\t\t/* cost of movzx */\n+  {COSTS_N_INSNS (18),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (26),\t\t\t/*                          HI */\n+   COSTS_N_INSNS (42),\t\t\t/*                          SI */\n+   COSTS_N_INSNS (74),\t\t\t/*                          DI */\n+   COSTS_N_INSNS (74)},\t\t\t/*                          other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n   4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -364,25 +420,33 @@ struct processor_costs athlon_cost = {\n   64,\t\t\t\t\t/* size of prefetch block */\n   6,\t\t\t\t\t/* number of parallel prefetches */\n   5,\t\t\t\t\t/* Branch cost */\n-  4,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n-  4,\t\t\t\t\t/* cost of FMUL instruction.  */\n-  24,\t\t\t\t\t/* cost of FDIV instruction.  */\n-  2,\t\t\t\t\t/* cost of FABS instruction.  */\n-  2,\t\t\t\t\t/* cost of FCHS instruction.  */\n-  35,\t\t\t\t\t/* cost of FSQRT instruction.  */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (24),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n };\n \n static const\n struct processor_costs k8_cost = {\n-  1,\t\t\t\t\t/* cost of an add instruction */\n-  2,\t\t\t\t\t/* cost of a lea instruction */\n-  1,\t\t\t\t\t/* variable shift costs */\n-  1,\t\t\t\t\t/* constant shift costs */\n-  {3, 4, 3, 4, 5},\t\t\t/* cost of starting a multiply */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (4),\t\t\t/*                               HI */\n+   COSTS_N_INSNS (3),\t\t\t/*                               SI */\n+   COSTS_N_INSNS (4),\t\t\t/*                               DI */\n+   COSTS_N_INSNS (5)},\t\t\t/*                               other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {18, 26, 42, 74, 74},\t\t\t/* cost of a divide/mod */\n-  1,\t\t\t\t\t/* cost of movsx */\n-  1,\t\t\t\t\t/* cost of movzx */\n+  {COSTS_N_INSNS (18),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (26),\t\t\t/*                          HI */\n+   COSTS_N_INSNS (42),\t\t\t/*                          SI */\n+   COSTS_N_INSNS (74),\t\t\t/*                          DI */\n+   COSTS_N_INSNS (74)},\t\t\t/*                          other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n   4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -408,25 +472,33 @@ struct processor_costs k8_cost = {\n   64,\t\t\t\t\t/* size of prefetch block */\n   6,\t\t\t\t\t/* number of parallel prefetches */\n   5,\t\t\t\t\t/* Branch cost */\n-  4,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n-  4,\t\t\t\t\t/* cost of FMUL instruction.  */\n-  19,\t\t\t\t\t/* cost of FDIV instruction.  */\n-  2,\t\t\t\t\t/* cost of FABS instruction.  */\n-  2,\t\t\t\t\t/* cost of FCHS instruction.  */\n-  35,\t\t\t\t\t/* cost of FSQRT instruction.  */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (19),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n };\n \n static const\n struct processor_costs pentium4_cost = {\n-  1,\t\t\t\t\t/* cost of an add instruction */\n-  3,\t\t\t\t\t/* cost of a lea instruction */\n-  4,\t\t\t\t\t/* variable shift costs */\n-  4,\t\t\t\t\t/* constant shift costs */\n-  {15, 15, 15, 15, 15},\t\t\t/* cost of starting a multiply */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (4),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (4),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (15),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (15),\t\t\t/*                               HI */\n+   COSTS_N_INSNS (15),\t\t\t/*                               SI */\n+   COSTS_N_INSNS (15),\t\t\t/*                               DI */\n+   COSTS_N_INSNS (15)},\t\t\t/*                               other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {56, 56, 56, 56, 56},\t\t\t/* cost of a divide/mod */\n-  1,\t\t\t\t\t/* cost of movsx */\n-  1,\t\t\t\t\t/* cost of movzx */\n+  {COSTS_N_INSNS (56),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (56),\t\t\t/*                          HI */\n+   COSTS_N_INSNS (56),\t\t\t/*                          SI */\n+   COSTS_N_INSNS (56),\t\t\t/*                          DI */\n+   COSTS_N_INSNS (56)},\t\t\t/*                          other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   16,\t\t\t\t\t/* \"large\" insn */\n   6,\t\t\t\t\t/* MOVE_RATIO */\n   2,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -452,25 +524,33 @@ struct processor_costs pentium4_cost = {\n   64,\t\t\t\t\t/* size of prefetch block */\n   6,\t\t\t\t\t/* number of parallel prefetches */\n   2,\t\t\t\t\t/* Branch cost */\n-  5,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n-  7,\t\t\t\t\t/* cost of FMUL instruction.  */\n-  43,\t\t\t\t\t/* cost of FDIV instruction.  */\n-  2,\t\t\t\t\t/* cost of FABS instruction.  */\n-  2,\t\t\t\t\t/* cost of FCHS instruction.  */\n-  43,\t\t\t\t\t/* cost of FSQRT instruction.  */\n+  COSTS_N_INSNS (5),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (7),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (43),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (43),\t\t\t/* cost of FSQRT instruction.  */\n };\n \n static const\n struct processor_costs nocona_cost = {\n-  1,\t\t\t\t\t/* cost of an add instruction */\n-  1,\t\t\t\t\t/* cost of a lea instruction */\n-  1,\t\t\t\t\t/* variable shift costs */\n-  1,\t\t\t\t\t/* constant shift costs */\n-  {10, 10, 10, 10, 10},\t\t\t/* cost of starting a multiply */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (10),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (10),\t\t\t/*                               HI */\n+   COSTS_N_INSNS (10),\t\t\t/*                               SI */\n+   COSTS_N_INSNS (10),\t\t\t/*                               DI */\n+   COSTS_N_INSNS (10)},\t\t\t/*                               other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {66, 66, 66, 66, 66},\t\t\t/* cost of a divide/mod */\n-  1,\t\t\t\t\t/* cost of movsx */\n-  1,\t\t\t\t\t/* cost of movzx */\n+  {COSTS_N_INSNS (66),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (66),\t\t\t/*                          HI */\n+   COSTS_N_INSNS (66),\t\t\t/*                          SI */\n+   COSTS_N_INSNS (66),\t\t\t/*                          DI */\n+   COSTS_N_INSNS (66)},\t\t\t/*                          other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   16,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n   4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -496,12 +576,12 @@ struct processor_costs nocona_cost = {\n   128,\t\t\t\t\t/* size of prefetch block */\n   8,\t\t\t\t\t/* number of parallel prefetches */\n   1,\t\t\t\t\t/* Branch cost */\n-  6,\t\t\t\t\t/* cost of FADD and FSUB insns.  */\n-  8,\t\t\t\t\t/* cost of FMUL instruction.  */\n-  40,\t\t\t\t\t/* cost of FDIV instruction.  */\n-  3,\t\t\t\t\t/* cost of FABS instruction.  */\n-  3,\t\t\t\t\t/* cost of FCHS instruction.  */\n-  44,\t\t\t\t\t/* cost of FSQRT instruction.  */\n+  COSTS_N_INSNS (6),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (40),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (44),\t\t\t/* cost of FSQRT instruction.  */\n };\n \n const struct processor_costs *ix86_cost = &pentium_cost;\n@@ -16320,13 +16400,13 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t  && GET_MODE (XEXP (x, 0)) == SImode)\n \t*total = 1;\n       else if (TARGET_ZERO_EXTEND_WITH_AND)\n-\t*total = COSTS_N_INSNS (ix86_cost->add);\n+\t*total = ix86_cost->add;\n       else\n-\t*total = COSTS_N_INSNS (ix86_cost->movzx);\n+\t*total = ix86_cost->movzx;\n       return false;\n \n     case SIGN_EXTEND:\n-      *total = COSTS_N_INSNS (ix86_cost->movsx);\n+      *total = ix86_cost->movsx;\n       return false;\n \n     case ASHIFT:\n@@ -16336,13 +16416,14 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t  HOST_WIDE_INT value = INTVAL (XEXP (x, 1));\n \t  if (value == 1)\n \t    {\n-\t      *total = COSTS_N_INSNS (ix86_cost->add);\n+\t      *total = ix86_cost->add;\n \t      return false;\n \t    }\n \t  if ((value == 2 || value == 3)\n+\t      && !TARGET_DECOMPOSE_LEA\n \t      && ix86_cost->lea <= ix86_cost->shift_const)\n \t    {\n-\t      *total = COSTS_N_INSNS (ix86_cost->lea);\n+\t      *total = ix86_cost->lea;\n \t      return false;\n \t    }\n \t}\n@@ -16357,31 +16438,31 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t  if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n \t    {\n \t      if (INTVAL (XEXP (x, 1)) > 32)\n-\t\t*total = COSTS_N_INSNS(ix86_cost->shift_const + 2);\n+\t\t*total = ix86_cost->shift_const + COSTS_N_INSNS (2);\n \t      else\n-\t\t*total = COSTS_N_INSNS(ix86_cost->shift_const * 2);\n+\t\t*total = ix86_cost->shift_const * 2;\n \t    }\n \t  else\n \t    {\n \t      if (GET_CODE (XEXP (x, 1)) == AND)\n-\t\t*total = COSTS_N_INSNS(ix86_cost->shift_var * 2);\n+\t\t*total = ix86_cost->shift_var * 2;\n \t      else\n-\t\t*total = COSTS_N_INSNS(ix86_cost->shift_var * 6 + 2);\n+\t\t*total = ix86_cost->shift_var * 6 + COSTS_N_INSNS (2);\n \t    }\n \t}\n       else\n \t{\n \t  if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t    *total = COSTS_N_INSNS (ix86_cost->shift_const);\n+\t    *total = ix86_cost->shift_const;\n \t  else\n-\t    *total = COSTS_N_INSNS (ix86_cost->shift_var);\n+\t    *total = ix86_cost->shift_var;\n \t}\n       return false;\n \n     case MULT:\n       if (FLOAT_MODE_P (mode))\n \t{\n-\t  *total = COSTS_N_INSNS (ix86_cost->fmul);\n+\t  *total = ix86_cost->fmul;\n \t  return false;\n \t}\n       else\n@@ -16422,9 +16503,9 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t        op0 = XEXP (op0, 0), mode = GET_MODE (op0);\n \t    }\n \n-  \t  *total = COSTS_N_INSNS (ix86_cost->mult_init[MODE_INDEX (mode)]\n-\t\t\t          + nbits * ix86_cost->mult_bit)\n-\t           + rtx_cost (op0, outer_code) + rtx_cost (op1, outer_code);\n+  \t  *total = (ix86_cost->mult_init[MODE_INDEX (mode)]\n+\t\t    + nbits * ix86_cost->mult_bit\n+\t            + rtx_cost (op0, outer_code) + rtx_cost (op1, outer_code));\n \n           return true;\n \t}\n@@ -16434,14 +16515,14 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case MOD:\n     case UMOD:\n       if (FLOAT_MODE_P (mode))\n-\t*total = COSTS_N_INSNS (ix86_cost->fdiv);\n+\t*total = ix86_cost->fdiv;\n       else\n-\t*total = COSTS_N_INSNS (ix86_cost->divide[MODE_INDEX (mode)]);\n+\t*total = ix86_cost->divide[MODE_INDEX (mode)];\n       return false;\n \n     case PLUS:\n       if (FLOAT_MODE_P (mode))\n-\t*total = COSTS_N_INSNS (ix86_cost->fadd);\n+\t*total = ix86_cost->fadd;\n       else if (GET_MODE_CLASS (mode) == MODE_INT\n \t       && GET_MODE_BITSIZE (mode) <= GET_MODE_BITSIZE (Pmode))\n \t{\n@@ -16453,7 +16534,7 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t      HOST_WIDE_INT val = INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1));\n \t      if (val == 2 || val == 4 || val == 8)\n \t\t{\n-\t\t  *total = COSTS_N_INSNS (ix86_cost->lea);\n+\t\t  *total = ix86_cost->lea;\n \t\t  *total += rtx_cost (XEXP (XEXP (x, 0), 1), outer_code);\n \t\t  *total += rtx_cost (XEXP (XEXP (XEXP (x, 0), 0), 0),\n \t\t\t\t      outer_code);\n@@ -16467,15 +16548,15 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t      HOST_WIDE_INT val = INTVAL (XEXP (XEXP (x, 0), 1));\n \t      if (val == 2 || val == 4 || val == 8)\n \t\t{\n-\t\t  *total = COSTS_N_INSNS (ix86_cost->lea);\n+\t\t  *total = ix86_cost->lea;\n \t\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), outer_code);\n \t\t  *total += rtx_cost (XEXP (x, 1), outer_code);\n \t\t  return true;\n \t\t}\n \t    }\n \t  else if (GET_CODE (XEXP (x, 0)) == PLUS)\n \t    {\n-\t      *total = COSTS_N_INSNS (ix86_cost->lea);\n+\t      *total = ix86_cost->lea;\n \t      *total += rtx_cost (XEXP (XEXP (x, 0), 0), outer_code);\n \t      *total += rtx_cost (XEXP (XEXP (x, 0), 1), outer_code);\n \t      *total += rtx_cost (XEXP (x, 1), outer_code);\n@@ -16487,7 +16568,7 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case MINUS:\n       if (FLOAT_MODE_P (mode))\n \t{\n-\t  *total = COSTS_N_INSNS (ix86_cost->fadd);\n+\t  *total = ix86_cost->fadd;\n \t  return false;\n \t}\n       /* FALLTHRU */\n@@ -16497,7 +16578,7 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case XOR:\n       if (!TARGET_64BIT && mode == DImode)\n \t{\n-\t  *total = (COSTS_N_INSNS (ix86_cost->add) * 2\n+\t  *total = (ix86_cost->add * 2\n \t\t    + (rtx_cost (XEXP (x, 0), outer_code)\n \t\t       << (GET_MODE (XEXP (x, 0)) != DImode))\n \t\t    + (rtx_cost (XEXP (x, 1), outer_code)\n@@ -16509,16 +16590,16 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case NEG:\n       if (FLOAT_MODE_P (mode))\n \t{\n-\t  *total = COSTS_N_INSNS (ix86_cost->fchs);\n+\t  *total = ix86_cost->fchs;\n \t  return false;\n \t}\n       /* FALLTHRU */\n \n     case NOT:\n       if (!TARGET_64BIT && mode == DImode)\n-\t*total = COSTS_N_INSNS (ix86_cost->add * 2);\n+\t*total = ix86_cost->add * 2;\n       else\n-\t*total = COSTS_N_INSNS (ix86_cost->add);\n+\t*total = ix86_cost->add;\n       return false;\n \n     case COMPARE:\n@@ -16529,7 +16610,7 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t{\n \t  /* This kind of construct is implemented using test[bwl].\n \t     Treat it as if we had an AND.  */\n-\t  *total = (COSTS_N_INSNS (ix86_cost->add)\n+\t  *total = (ix86_cost->add\n \t\t    + rtx_cost (XEXP (XEXP (x, 0), 0), outer_code)\n \t\t    + rtx_cost (const1_rtx, outer_code));\n \t  return true;\n@@ -16545,12 +16626,12 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n \n     case ABS:\n       if (FLOAT_MODE_P (mode))\n-\t*total = COSTS_N_INSNS (ix86_cost->fabs);\n+\t*total = ix86_cost->fabs;\n       return false;\n \n     case SQRT:\n       if (FLOAT_MODE_P (mode))\n-\t*total = COSTS_N_INSNS (ix86_cost->fsqrt);\n+\t*total = ix86_cost->fsqrt;\n       return false;\n \n     case UNSPEC:"}]}