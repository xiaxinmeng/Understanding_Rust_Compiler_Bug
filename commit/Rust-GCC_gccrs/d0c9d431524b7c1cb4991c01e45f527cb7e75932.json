{"sha": "d0c9d431524b7c1cb4991c01e45f527cb7e75932", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBjOWQ0MzE1MjRiN2MxY2I0OTkxYzAxZTQ1ZjUyN2NiN2U3NTkzMg==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-07-21T21:45:06Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-07-21T21:45:06Z"}, "message": "optabs.h (enum optab_index): Add new OTI_signbit.\n\n        * optabs.h (enum optab_index): Add new OTI_signbit.\n        (signbit_optab): Define corresponding macro.\n        (enum insn_code signbit_optab[]): Remove array.\n        * optabs.c (init_optabs): Initialize signbit_optab using init_optab.\n        (expand_copysign_absneg): If back end provides signbit insn, use it\n        instead of bit operations on floating point argument.\n        * builtins.c (enum insn_code signbit_optab[]): Remove array.\n        (expand_builtin_signbit): Check signbit_optab->handlers[].insn_code for\n        availability of signbit insn.\n\n        * config/i386/i386.md (signbit<mode>2): New insn pattern to implement\n        signbitf, signbit and signbitl built-ins as inline x87 intrinsics when\n        SSE mode is not active.\n        (isinf<mode>2): Disable for mfpmath=sse,387.\n\nFrom-SVN: r126813", "tree": {"sha": "2e34198e0e1a0497de165774678adb850f5fdf36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e34198e0e1a0497de165774678adb850f5fdf36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0c9d431524b7c1cb4991c01e45f527cb7e75932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c9d431524b7c1cb4991c01e45f527cb7e75932", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0c9d431524b7c1cb4991c01e45f527cb7e75932", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c9d431524b7c1cb4991c01e45f527cb7e75932/comments", "author": null, "committer": null, "parents": [{"sha": "21a772278801d5143e385999c692da9457db5552", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21a772278801d5143e385999c692da9457db5552", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21a772278801d5143e385999c692da9457db5552"}], "stats": {"total": 154, "additions": 96, "deletions": 58}, "files": [{"sha": "5d4982d47b77902669cafa72eaade98ab8eb7062", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c9d431524b7c1cb4991c01e45f527cb7e75932/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c9d431524b7c1cb4991c01e45f527cb7e75932/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0c9d431524b7c1cb4991c01e45f527cb7e75932", "patch": "@@ -1,3 +1,20 @@\n+2007-07-21  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* optabs.h (enum optab_index): Add new OTI_signbit.\n+\t(signbit_optab): Define corresponding macro.\n+\t(enum insn_code signbit_optab[]): Remove array.\n+\t* optabs.c (init_optabs): Initialize signbit_optab using init_optab.\n+\t(expand_copysign_absneg): If back end provides signbit insn, use it\n+\tinstead of bit operations on floating point argument.\n+\t* builtins.c (enum insn_code signbit_optab[]): Remove array.\n+\t(expand_builtin_signbit): Check signbit_optab->handlers[].insn_code for\n+\tavailability of signbit insn.\n+\n+\t* config/i386/i386.md (signbit<mode>2): New insn pattern to implement\n+\tsignbitf, signbit and signbitl built-ins as inline x87 intrinsics when\n+\tSSE mode is not active.\n+\t(isinf<mode>2): Disable for mfpmath=sse,387.\n+\n 2007-07-22  Ben Elliston  <bje@au.ibm.com>\n \n \t* regclass.c (invalid_mode_change_p): Attach ATTRIBUTE_UNUSED to\n@@ -256,7 +273,6 @@\n 2007-07-16  Paul Brook  <paul@codesourcery.com>\n \n \tPR target/32753\n-\tgcc/\n \t* config/arm/cirrus.md (cirrus_arm_movsi_insn): Remove dead insn.\n \t(cirrus_thumb2_movsi_insn): Ditto.\n \n@@ -2753,7 +2769,7 @@\n \toffsets->locals_base to avoid negative stack size.\n \t(thumb1_expand_prologue): Assert on negative stack size.\n \n-2007-04-19  Sebastian Pop  <sebpop@gmail.com>\n+2007-06-19  Sebastian Pop  <sebpop@gmail.com>\n \n \tPR tree-optimization/32367\n \t* tree-chrec.h (build_polynomial_chrec): Verify that the left hand side \n@@ -6068,7 +6084,7 @@\n \tfloat constant.\n \t(_m_to_float): Use C89 compatible assignment.\n \n-2007-04-20  Martin Michlmayr  <tbm@cyrius.com>\n+2007-05-20  Martin Michlmayr  <tbm@cyrius.com>\n \n \tPR target/32007\n \t* config/arm/lib1funcs.asm: Define __ARM_ARCH__ on v2/v3 machines.\n@@ -7084,7 +7100,7 @@\n \tsize never inline functions increasing caller size.\n \t(cgraph_early_inlining): Inline for size when optimizing for size.\n \n-2007-04-18  Bernd Schmidt  <bernd.schmidt@analog.com>\n+2007-05-04  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/bfin.md (<optab>di3): Now a define_expand which expands\n \tlogical operations piecewise."}, {"sha": "a2e4be874ea8ae5f43e2de676a673fd95aa539d4", "filename": "gcc/builtins.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c9d431524b7c1cb4991c01e45f527cb7e75932/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c9d431524b7c1cb4991c01e45f527cb7e75932/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=d0c9d431524b7c1cb4991c01e45f527cb7e75932", "patch": "@@ -240,11 +240,6 @@ static tree do_mpfr_remquo (tree, tree, tree);\n static tree do_mpfr_lgamma_r (tree, tree, tree);\n #endif\n \n-/* This array records the insn_code of insns to imlement the signbit\n-   function.  */\n-enum insn_code signbit_optab[NUM_MACHINE_MODES];\n-\n-\n /* Return true if NODE should be considered for inline expansion regardless\n    of the optimization level.  This means whenever a function is invoked with\n    its \"internal\" name, which normally contains the prefix \"__builtin\".  */\n@@ -5725,7 +5720,7 @@ expand_builtin_signbit (tree exp, rtx target)\n   HOST_WIDE_INT hi, lo;\n   tree arg;\n   int word, bitpos;\n-  enum insn_code signbit_insn_code;\n+  enum insn_code icode;\n   rtx temp;\n \n   if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))\n@@ -5743,11 +5738,11 @@ expand_builtin_signbit (tree exp, rtx target)\n \n   /* Check if the back end provides an insn that handles signbit for the\n      argument's mode. */\n-  signbit_insn_code = signbit_optab [(int) fmode];\n-  if (signbit_insn_code != CODE_FOR_nothing)\n+  icode = signbit_optab->handlers [(int) fmode].insn_code;\n+  if (icode != CODE_FOR_nothing)\n     {\n       target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n-      emit_unop_insn (signbit_insn_code, target, temp, UNKNOWN);\n+      emit_unop_insn (icode, target, temp, UNKNOWN);\n       return target;\n     }\n "}, {"sha": "037773541b906bbfc17ad43c2a817823595beaa3", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c9d431524b7c1cb4991c01e45f527cb7e75932/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c9d431524b7c1cb4991c01e45f527cb7e75932/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d0c9d431524b7c1cb4991c01e45f527cb7e75932", "patch": "@@ -17990,8 +17990,7 @@\n    (use (match_operand:X87MODEF 1 \"register_operand\" \"\"))]\n   \"TARGET_USE_FANCY_MATH_387\n    && TARGET_C99_FUNCTIONS\n-   && (!(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n-       || TARGET_MIX_SSE_I387)\"\n+   && !(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n {\n   rtx mask = GEN_INT (0x45);\n   rtx val = GEN_INT (0x05);\n@@ -18012,6 +18011,20 @@\n   DONE;\n })\n \n+(define_expand \"signbit<mode>2\"\n+  [(use (match_operand:SI 0 \"register_operand\" \"\"))\n+   (use (match_operand:X87MODEF 1 \"register_operand\" \"\"))]\n+  \"TARGET_USE_FANCY_MATH_387\n+   && !(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n+{\n+  rtx mask = GEN_INT (0x0200);\n+\n+  rtx scratch = gen_reg_rtx (HImode);\n+\n+  emit_insn (gen_fxam<mode>2_i387 (scratch, operands[1]));\n+  emit_insn (gen_andsi3 (operands[0], gen_lowpart (SImode, scratch), mask));\n+  DONE;\n+})\n \f\n ;; Block operation instructions\n "}, {"sha": "c754544f10ffb6d5f0dcff84d94e8cf409d531ca", "filename": "gcc/optabs.c", "status": "modified", "additions": 54, "deletions": 38, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c9d431524b7c1cb4991c01e45f527cb7e75932/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c9d431524b7c1cb4991c01e45f527cb7e75932/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=d0c9d431524b7c1cb4991c01e45f527cb7e75932", "patch": "@@ -3112,63 +3112,79 @@ expand_copysign_absneg (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t\t        int bitpos, bool op0_is_abs)\n {\n   enum machine_mode imode;\n-  HOST_WIDE_INT hi, lo;\n-  int word;\n-  rtx label;\n+  int icode;\n+  rtx sign, label;\n \n   if (target == op1)\n     target = NULL_RTX;\n \n-  if (!op0_is_abs)\n+  /* Check if the back end provides an insn that handles signbit for the\n+     argument's mode. */\n+  icode = (int) signbit_optab->handlers [(int) mode].insn_code;\n+  if (icode != CODE_FOR_nothing)\n     {\n-      op0 = expand_unop (mode, abs_optab, op0, target, 0);\n-      if (op0 == NULL)\n-\treturn NULL_RTX;\n-      target = op0;\n+      imode = insn_data[icode].operand[0].mode;\n+      sign = gen_reg_rtx (imode);\n+      emit_unop_insn (icode, sign, op1, UNKNOWN);\n     }\n   else\n     {\n-      if (target == NULL_RTX)\n-        target = copy_to_reg (op0);\n+      HOST_WIDE_INT hi, lo;\n+\n+      if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n+\t{\n+\t  imode = int_mode_for_mode (mode);\n+\t  if (imode == BLKmode)\n+\t    return NULL_RTX;\n+\t  op1 = gen_lowpart (imode, op1);\n+\t}\n       else\n-\temit_move_insn (target, op0);\n-    }\n+\t{\n+\t  int word;\n \n-  if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n-    {\n-      imode = int_mode_for_mode (mode);\n-      if (imode == BLKmode)\n-\treturn NULL_RTX;\n-      op1 = gen_lowpart (imode, op1);\n-    }\n-  else\n-    {\n-      imode = word_mode;\n-      if (FLOAT_WORDS_BIG_ENDIAN)\n-\tword = (GET_MODE_BITSIZE (mode) - bitpos) / BITS_PER_WORD;\n+\t  imode = word_mode;\n+\t  if (FLOAT_WORDS_BIG_ENDIAN)\n+\t    word = (GET_MODE_BITSIZE (mode) - bitpos) / BITS_PER_WORD;\n+\t  else\n+\t    word = bitpos / BITS_PER_WORD;\n+\t  bitpos = bitpos % BITS_PER_WORD;\n+\t  op1 = operand_subword_force (op1, word, mode);\n+\t}\n+\n+      if (bitpos < HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  hi = 0;\n+\t  lo = (HOST_WIDE_INT) 1 << bitpos;\n+\t}\n       else\n-\tword = bitpos / BITS_PER_WORD;\n-      bitpos = bitpos % BITS_PER_WORD;\n-      op1 = operand_subword_force (op1, word, mode);\n+\t{\n+\t  hi = (HOST_WIDE_INT) 1 << (bitpos - HOST_BITS_PER_WIDE_INT);\n+\t  lo = 0;\n+\t}\n+\n+      sign = gen_reg_rtx (imode);\n+      sign = expand_binop (imode, and_optab, op1,\n+\t\t\t   immed_double_const (lo, hi, imode),\n+\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n     }\n \n-  if (bitpos < HOST_BITS_PER_WIDE_INT)\n+  if (!op0_is_abs)\n     {\n-      hi = 0;\n-      lo = (HOST_WIDE_INT) 1 << bitpos;\n+      op0 = expand_unop (mode, abs_optab, op0, target, 0);\n+      if (op0 == NULL)\n+\treturn NULL_RTX;\n+      target = op0;\n     }\n   else\n     {\n-      hi = (HOST_WIDE_INT) 1 << (bitpos - HOST_BITS_PER_WIDE_INT);\n-      lo = 0;\n+      if (target == NULL_RTX)\n+        target = copy_to_reg (op0);\n+      else\n+\temit_move_insn (target, op0);\n     }\n \n-  op1 = expand_binop (imode, and_optab, op1,\n-\t\t      immed_double_const (lo, hi, imode),\n-\t\t      NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-\n   label = gen_label_rtx ();\n-  emit_cmp_and_jump_insns (op1, const0_rtx, EQ, NULL_RTX, imode, 1, label);\n+  emit_cmp_and_jump_insns (sign, const0_rtx, EQ, NULL_RTX, imode, 1, label);\n \n   if (GET_CODE (op0) == CONST_DOUBLE)\n     op0 = simplify_unary_operation (NEG, mode, op0, mode);\n@@ -5585,6 +5601,7 @@ init_optabs (void)\n   tan_optab = init_optab (UNKNOWN);\n   atan_optab = init_optab (UNKNOWN);\n   copysign_optab = init_optab (UNKNOWN);\n+  signbit_optab = init_optab (UNKNOWN);\n \n   isinf_optab = init_optab (UNKNOWN);\n \n@@ -5655,7 +5672,6 @@ init_optabs (void)\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     {\n       movmem_optab[i] = CODE_FOR_nothing;\n-      signbit_optab[i] = CODE_FOR_nothing;\n       cmpstr_optab[i] = CODE_FOR_nothing;\n       cmpstrn_optab[i] = CODE_FOR_nothing;\n       cmpmem_optab[i] = CODE_FOR_nothing;"}, {"sha": "d8917ab57348eb667a4f6b6e675f0a5ee4132989", "filename": "gcc/optabs.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c9d431524b7c1cb4991c01e45f527cb7e75932/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c9d431524b7c1cb4991c01e45f527cb7e75932/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=d0c9d431524b7c1cb4991c01e45f527cb7e75932", "patch": "@@ -219,7 +219,8 @@ enum optab_index\n   OTI_atan,\n   /* Copy sign */\n   OTI_copysign,\n-\n+  /* Signbit */\n+  OTI_signbit,\n   /* Test for infinite value */\n   OTI_isinf,\n \n@@ -409,7 +410,7 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define tan_optab (optab_table[OTI_tan])\n #define atan_optab (optab_table[OTI_atan])\n #define copysign_optab (optab_table[OTI_copysign])\n-\n+#define signbit_optab (optab_table[OTI_signbit])\n #define isinf_optab (optab_table[OTI_isinf])\n \n #define cmp_optab (optab_table[OTI_cmp])\n@@ -553,9 +554,6 @@ extern enum insn_code vcondu_gen_code[NUM_MACHINE_MODES];\n /* This array records the insn_code of insns to perform block moves.  */\n extern enum insn_code movmem_optab[NUM_MACHINE_MODES];\n \n-/* This array records the insn_code of insns to implement the signbit function.  */\n-extern enum insn_code signbit_optab[NUM_MACHINE_MODES];\n-\n /* This array records the insn_code of insns to perform block sets.  */\n extern enum insn_code setmem_optab[NUM_MACHINE_MODES];\n "}]}