{"sha": "4a8ee1224175358105056d64a611443680257a2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE4ZWUxMjI0MTc1MzU4MTA1MDU2ZDY0YTYxMTQ0MzY4MDI1N2EyZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-09T20:30:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-09T20:30:07Z"}, "message": "dwarf2cfi: Simplify re-initialization for each function.\n\nThere's no point calling lookup_cfa to re-create the CFA\nwe initialized just a few lines above.\n\n        * dwarf2cfi.c (lookup_cfa): Remove.\n        (execute_dwarf2_frame): Assert queues are empty on entry.\n        Setup initial cfa directly, not via lookup_cfa.\n        Don't clear args_size state here.\n\nFrom-SVN: r176098", "tree": {"sha": "381c502b3860b7248674160affc1e1e46bc685c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/381c502b3860b7248674160affc1e1e46bc685c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a8ee1224175358105056d64a611443680257a2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8ee1224175358105056d64a611443680257a2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a8ee1224175358105056d64a611443680257a2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8ee1224175358105056d64a611443680257a2e/comments", "author": null, "committer": null, "parents": [{"sha": "3edb53aaaeae895cca4bbc644e6d37558d0cb664", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3edb53aaaeae895cca4bbc644e6d37558d0cb664", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3edb53aaaeae895cca4bbc644e6d37558d0cb664"}], "stats": {"total": 52, "additions": 20, "deletions": 32}, "files": [{"sha": "d5fd40a2cbb6796a9a236bcc16a72e226ba47896", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8ee1224175358105056d64a611443680257a2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8ee1224175358105056d64a611443680257a2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a8ee1224175358105056d64a611443680257a2e", "patch": "@@ -1,3 +1,10 @@\n+2011-07-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2cfi.c (lookup_cfa): Remove.\n+\t(execute_dwarf2_frame): Assert queues are empty on entry.\n+\tSetup initial cfa directly, not via lookup_cfa.\n+\tDon't clear args_size state here.\n+\n 2011-07-09  Richard Henderson  <rth@redhat.com>\n \n \t* dwarf2cfi.c (add_cfi_vec): New."}, {"sha": "b4b035ddd56c113d5c735b97951abadb17d9978d", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8ee1224175358105056d64a611443680257a2e/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8ee1224175358105056d64a611443680257a2e/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=4a8ee1224175358105056d64a611443680257a2e", "patch": "@@ -405,7 +405,9 @@ get_cfa_from_loc_descr (dw_cfa_location *cfa, struct dw_loc_descr_struct *loc)\n     }\n }\n \n-/* Subroutine of lookup_cfa.  */\n+/* Find the previous value for the CFA, iteratively.  CFI is the opcode\n+   to interpret, *LOC will be updated as necessary, *REMEMBER is used for\n+   one level of remember/restore state processing.  */\n \n void\n lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc, dw_cfa_location *remember)\n@@ -444,29 +446,6 @@ lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc, dw_cfa_location *remember)\n     }\n }\n \n-/* Find the previous value for the CFA.  */\n-\n-static void\n-lookup_cfa (dw_cfa_location *loc)\n-{\n-  int ix;\n-  dw_cfi_ref cfi;\n-  dw_fde_ref fde;\n-  dw_cfa_location remember;\n-\n-  memset (loc, 0, sizeof (*loc));\n-  loc->reg = INVALID_REGNUM;\n-  remember = *loc;\n-\n-  FOR_EACH_VEC_ELT (dw_cfi_ref, cie_cfi_vec, ix, cfi)\n-    lookup_cfa_1 (cfi, loc, &remember);\n-\n-  fde = cfun->fde;\n-  if (fde)\n-    FOR_EACH_VEC_ELT (dw_cfi_ref, fde->dw_fde_cfi, ix, cfi)\n-      lookup_cfa_1 (cfi, loc, &remember);\n-}\n-\n /* The current rule for calculating the DWARF2 canonical frame address.  */\n static dw_cfa_location cfa;\n \n@@ -2301,7 +2280,7 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n \n /* Examine CFI and return true if a cfi label and set_loc is needed\n    beforehand.  Even when generating CFI assembler instructions, we\n-   still have to add the cfi to the list so that lookup_cfa works\n+   still have to add the cfi to the list so that lookup_cfa_1 works\n    later on.  When -g2 and above we even need to force emitting of\n    CFI labels and add to list a DW_CFA_set_loc for convert_cfa_to_fb_loc_list\n    purposes.  If we're generating DWARF3 output we use DW_OP_call_frame_cfa\n@@ -2596,15 +2575,18 @@ execute_dwarf2_frame (void)\n     }\n \n   /* Set up state for generating call frame debug info.  */\n-  lookup_cfa (&cfa);\n-  gcc_assert (cfa.reg\n-\t      == (unsigned long)DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM));\n+  gcc_checking_assert (queued_reg_saves == NULL);\n+  gcc_checking_assert (regs_saved_in_regs == NULL);\n \n-  old_cfa = cfa;\n+  memset (&cfa, 0, sizeof(cfa));\n   cfa.reg = STACK_POINTER_REGNUM;\n+  cfa.offset = INCOMING_FRAME_SP_OFFSET;\n+\n+  old_cfa = cfa;\n   cfa_store = cfa;\n-  cfa_temp.reg = -1;\n-  cfa_temp.offset = 0;\n+\n+  memset (&cfa_temp, 0, sizeof(cfa_temp));\n+  cfa_temp.reg = INVALID_REGNUM;\n \n   dwarf2out_alloc_current_fde ();\n \n@@ -2617,7 +2599,6 @@ execute_dwarf2_frame (void)\n   barrier_args_size = NULL;\n   regs_saved_in_regs = NULL;\n   queued_reg_saves = NULL;\n-  args_size = old_args_size = 0;\n \n   return 0;\n }"}]}