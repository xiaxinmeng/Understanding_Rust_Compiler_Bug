{"sha": "be330ed46a4d923603f191dc1d2d8c87f345a5f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUzMzBlZDQ2YTRkOTIzNjAzZjE5MWRjMWQyZDhjODdmMzQ1YTVmOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-06-10T00:08:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-06-10T00:08:27Z"}, "message": "cgraph.h (cgraph_only_called_directly_or_aliased_p): Rename from ...\n\n\t* cgraph.h (cgraph_only_called_directly_or_aliased_p): Rename from ...\n\t(cgraph_only_called_directly_p): ... this one; bring offline.\n\t(resolution_used_from_other_file_p, cgraph_used_from_object_file_p,\n\tvarpool_used_from_object_file_p): Drop names from the declaratoin.\n\t(cgraph_for_node_thunks_and_aliases, cgraph_for_node_and_aliases,\n\tcollect_callers_of_node): New.\n\t(cgraph_function_node, cgraph_function_or_thunk_node): New functions.\n\t(cgraph_edge_recursive_p): Use cgraph_function_node.\n\t* cgraph.c (cgraph_add_thunk): Check that thunk is not already alias.\n\t(cgraph_node_cannot_be_local_p_1): Break out from ...\n\t(cgraph_node_can_be_local_p): ... here; walk aliases.\n\t(cgraph_for_node_thunks_and_aliases): New function.\n\t(cgraph_for_node_and_aliases): New function.\n\t(cgraph_make_node_local_1): Break out from ...\n\t(cgraph_make_node_local) ... here; use cgraph_for_node_thunks_and_aliases.\n\t(cgraph_set_nothrow_flag_1): Break out from ...\n\t(cgraph_set_nothrow_flag) ... here; use cgraph_for_node_thunks_and_aliases.\n\t(cgraph_set_const_flag_1): Break out from ...\n\t(cgraph_set_const_flag) ... here; use cgraph_for_node_thunks_and_aliases.\n\t(cgraph_set_pure_flag_1): Break out from ...\n\t(cgraph_set_pure_flag) ... here; use cgraph_for_node_thunks_and_aliases.\n\t(cgraph_propagate_frequency_1): Break out from ...\n\t(cgraph_propagate_frequency) ... here; use cgraph_for_node_thunks_and_aliases.\n\t(cgraph_used_from_object_file_p): Do not care about aliases.\n\t(cgraph_not_only_called_directly_p_1, cgraph_only_called_directly_p): New functions.\n\t(collect_callers_of_node_1, collect_callers_of_node): New functions.\n\nFrom-SVN: r174871", "tree": {"sha": "820064b091ef4a76fbad5ec50bb9cd882bc02a80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/820064b091ef4a76fbad5ec50bb9cd882bc02a80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be330ed46a4d923603f191dc1d2d8c87f345a5f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be330ed46a4d923603f191dc1d2d8c87f345a5f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be330ed46a4d923603f191dc1d2d8c87f345a5f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be330ed46a4d923603f191dc1d2d8c87f345a5f8/comments", "author": null, "committer": null, "parents": [{"sha": "2ea91d6bdab8088137e98fc8e853f7065890466b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ea91d6bdab8088137e98fc8e853f7065890466b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ea91d6bdab8088137e98fc8e853f7065890466b"}], "stats": {"total": 404, "additions": 316, "deletions": 88}, "files": [{"sha": "d064a898e29b86db13c28d3b25a1513648662207", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be330ed46a4d923603f191dc1d2d8c87f345a5f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be330ed46a4d923603f191dc1d2d8c87f345a5f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be330ed46a4d923603f191dc1d2d8c87f345a5f8", "patch": "@@ -1,3 +1,32 @@\n+2011-06-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (cgraph_only_called_directly_or_aliased_p): Rename from ...\n+\t(cgraph_only_called_directly_p): ... this one; bring offline.\n+\t(resolution_used_from_other_file_p, cgraph_used_from_object_file_p,\n+\tvarpool_used_from_object_file_p): Drop names from the declaratoin.\n+\t(cgraph_for_node_thunks_and_aliases, cgraph_for_node_and_aliases,\n+\tcollect_callers_of_node): New.\n+\t(cgraph_function_node, cgraph_function_or_thunk_node): New functions.\n+\t(cgraph_edge_recursive_p): Use cgraph_function_node.\n+\t* cgraph.c (cgraph_add_thunk): Check that thunk is not already alias.\n+\t(cgraph_node_cannot_be_local_p_1): Break out from ...\n+\t(cgraph_node_can_be_local_p): ... here; walk aliases.\n+\t(cgraph_for_node_thunks_and_aliases): New function.\n+\t(cgraph_for_node_and_aliases): New function.\n+\t(cgraph_make_node_local_1): Break out from ...\n+\t(cgraph_make_node_local) ... here; use cgraph_for_node_thunks_and_aliases.\n+\t(cgraph_set_nothrow_flag_1): Break out from ...\n+\t(cgraph_set_nothrow_flag) ... here; use cgraph_for_node_thunks_and_aliases.\n+\t(cgraph_set_const_flag_1): Break out from ...\n+\t(cgraph_set_const_flag) ... here; use cgraph_for_node_thunks_and_aliases.\n+\t(cgraph_set_pure_flag_1): Break out from ...\n+\t(cgraph_set_pure_flag) ... here; use cgraph_for_node_thunks_and_aliases.\n+\t(cgraph_propagate_frequency_1): Break out from ...\n+\t(cgraph_propagate_frequency) ... here; use cgraph_for_node_thunks_and_aliases.\n+\t(cgraph_used_from_object_file_p): Do not care about aliases.\n+\t(cgraph_not_only_called_directly_p_1, cgraph_only_called_directly_p): New functions.\n+\t(collect_callers_of_node_1, collect_callers_of_node): New functions.\n+\n 2011-06-10  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR rtl-optimization/49154"}, {"sha": "4dffdc4010a74b66b1cd84ad1b887e2a70d4411d", "filename": "gcc/cgraph.c", "status": "modified", "additions": 225, "deletions": 76, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be330ed46a4d923603f191dc1d2d8c87f345a5f8/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be330ed46a4d923603f191dc1d2d8c87f345a5f8/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=be330ed46a4d923603f191dc1d2d8c87f345a5f8", "patch": "@@ -608,7 +608,8 @@ cgraph_add_thunk (struct cgraph_node *decl_node ATTRIBUTE_UNUSED,\n   if (node)\n     {\n       gcc_assert (node->local.finalized);\n-      gcc_assert (!node->same_body);\n+      gcc_assert (!node->alias);\n+      gcc_assert (!node->thunk.thunk_p);\n       cgraph_remove_node (node);\n     }\n   \n@@ -2508,16 +2509,27 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n     DECL_FUNCTION_PERSONALITY (fndecl) = lang_hooks.eh_personality ();\n }\n \n+/* Worker for cgraph_node_can_be_local_p.  */\n+static bool\n+cgraph_node_cannot_be_local_p_1 (struct cgraph_node *node,\n+\t\t\t\t void *data ATTRIBUTE_UNUSED)\n+{\n+  return !(!node->needed\n+\t   && ((DECL_COMDAT (node->decl) && !node->same_comdat_group)\n+\t       || !node->local.externally_visible));\n+}\n+\n /* Return true if NODE can be made local for API change.\n    Extern inline functions and C++ COMDAT functions can be made local\n    at the expense of possible code size growth if function is used in multiple\n    compilation units.  */\n bool\n cgraph_node_can_be_local_p (struct cgraph_node *node)\n {\n-  return (!node->needed && !node->address_taken\n-\t  && ((DECL_COMDAT (node->decl) && !node->same_comdat_group)\n-\t      || !node->local.externally_visible));\n+  return (!node->address_taken\n+\t  && !cgraph_for_node_and_aliases (node,\n+\t\t\t\t\t   cgraph_node_cannot_be_local_p_1,\n+\t\t\t\t\t   NULL, true));\n }\n \n /* Make DECL local.  FIXME: We shouldn't need to mess with rtl this early,\n@@ -2591,119 +2603,191 @@ cgraph_make_decl_local (tree decl)\n   SYMBOL_REF_WEAK (symbol) = DECL_WEAK (decl);\n }\n \n-/* Bring NODE local.  */\n-void\n-cgraph_make_node_local (struct cgraph_node *node)\n+/* Call calback on NODE, thunks and aliases asociated to NODE. \n+   When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n+   skipped. */\n+\n+bool\n+cgraph_for_node_thunks_and_aliases (struct cgraph_node *node,\n+\t\t\t            bool (*callback) (struct cgraph_node *, void *),\n+\t\t\t            void *data,\n+\t\t\t\t    bool include_overwritable)\n+{\n+  struct cgraph_edge *e;\n+  struct cgraph_node *alias;\n+\n+  if (callback (node, data))\n+    return true;\n+  for (alias = node->same_body; alias; alias = alias->next)\n+    if (callback (alias, data))\n+      return true;\n+  for (e = node->callers; e; e = e->next_caller)\n+    if (e->caller->thunk.thunk_p\n+\t&& (include_overwritable\n+\t    || cgraph_function_body_availability (e->caller) > AVAIL_OVERWRITABLE))\n+      cgraph_for_node_thunks_and_aliases (e->caller, callback, data, include_overwritable);\n+  return false;\n+}\n+\n+/* Call calback on NODE and aliases asociated to NODE. \n+   When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n+   skipped. */\n+\n+bool\n+cgraph_for_node_and_aliases (struct cgraph_node *node,\n+\t\t\t     bool (*callback) (struct cgraph_node *, void *),\n+\t\t\t     void *data,\n+\t\t\t     bool include_overwritable ATTRIBUTE_UNUSED)\n {\n-  gcc_assert (cgraph_node_can_be_local_p (node));\n+  struct cgraph_node *alias;\n+\n+  if (callback (node, data))\n+    return true;\n+  for (alias = node->same_body; alias; alias = alias->next)\n+    if (callback (alias, data))\n+      return true;\n+  return false;\n+}\n+\n+/* Worker to bring NODE local.  */\n+\n+static bool\n+cgraph_make_node_local_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+{\n+  gcc_checking_assert (cgraph_node_can_be_local_p (node));\n   if (DECL_COMDAT (node->decl) || DECL_EXTERNAL (node->decl))\n     {\n-      struct cgraph_node *alias;\n       cgraph_make_decl_local (node->decl);\n \n-      for (alias = node->same_body; alias; alias = alias->next)\n-\tcgraph_make_decl_local (alias->decl);\n-\n       node->local.externally_visible = false;\n       node->local.local = true;\n       node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n       gcc_assert (cgraph_function_body_availability (node) == AVAIL_LOCAL);\n     }\n+  return false;\n }\n \n-/* Set TREE_NOTHROW on NODE's decl and on same_body aliases of NODE\n+/* Bring NODE local.  */\n+\n+void\n+cgraph_make_node_local (struct cgraph_node *node)\n+{\n+  cgraph_for_node_thunks_and_aliases (node, cgraph_make_node_local_1,\n+\t\t\t\t      NULL, true);\n+}\n+\n+/* Worker to set nothrow flag.  */\n+\n+static bool\n+cgraph_set_nothrow_flag_1 (struct cgraph_node *node, void *data)\n+{\n+  TREE_NOTHROW (node->decl) = data != NULL;\n+  return false;\n+}\n+\n+/* Set TREE_NOTHROW on NODE's decl and on aliases of NODE\n    if any to NOTHROW.  */\n \n void\n cgraph_set_nothrow_flag (struct cgraph_node *node, bool nothrow)\n {\n-  struct cgraph_node *alias;\n-  TREE_NOTHROW (node->decl) = nothrow;\n-  for (alias = node->same_body; alias; alias = alias->next)\n-    TREE_NOTHROW (alias->decl) = nothrow;\n+  cgraph_for_node_thunks_and_aliases (node, cgraph_set_nothrow_flag_1,\n+\t\t\t              (void *)(size_t)nothrow, false);\n }\n \n-/* Set TREE_READONLY on NODE's decl and on same_body aliases of NODE\n-   if any to READONLY.  */\n+/* Worker to set const flag.  */\n \n-void\n-cgraph_set_const_flag (struct cgraph_node *node, bool readonly, bool looping)\n+static bool\n+cgraph_set_const_flag_1 (struct cgraph_node *node, void *data)\n {\n-  struct cgraph_node *alias;\n   /* Static constructors and destructors without a side effect can be\n      optimized out.  */\n-  if (!looping && readonly)\n+  if (data && !((size_t)data & 2))\n     {\n       if (DECL_STATIC_CONSTRUCTOR (node->decl))\n \tDECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n       if (DECL_STATIC_DESTRUCTOR (node->decl))\n \tDECL_STATIC_DESTRUCTOR (node->decl) = 0;\n     }\n-  TREE_READONLY (node->decl) = readonly;\n-  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = looping;\n-  for (alias = node->same_body; alias; alias = alias->next)\n-    {\n-      TREE_READONLY (alias->decl) = readonly;\n-      DECL_LOOPING_CONST_OR_PURE_P (alias->decl) = looping;\n-    }\n+  TREE_READONLY (node->decl) = data != NULL;\n+  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = ((size_t)data & 2) != 0;\n+  return false;\n }\n \n-/* Set DECL_PURE_P on NODE's decl and on same_body aliases of NODE\n-   if any to PURE.  */\n+/* Set TREE_READONLY on NODE's decl and on aliases of NODE\n+   if any to READONLY.  */\n \n void\n-cgraph_set_pure_flag (struct cgraph_node *node, bool pure, bool looping)\n+cgraph_set_const_flag (struct cgraph_node *node, bool readonly, bool looping)\n {\n-  struct cgraph_node *alias;\n-  /* Static constructors and destructors without a side effect can be\n+  cgraph_for_node_thunks_and_aliases (node, cgraph_set_const_flag_1,\n+\t\t\t              (void *)(size_t)(readonly + (int)looping * 2),\n+\t\t\t\t      false);\n+}\n+\n+/* Worker to set pure flag.  */\n+\n+static bool\n+cgraph_set_pure_flag_1 (struct cgraph_node *node, void *data)\n+{\n+  /* Static pureructors and destructors without a side effect can be\n      optimized out.  */\n-  if (!looping && pure)\n+  if (data && !((size_t)data & 2))\n     {\n       if (DECL_STATIC_CONSTRUCTOR (node->decl))\n \tDECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n       if (DECL_STATIC_DESTRUCTOR (node->decl))\n \tDECL_STATIC_DESTRUCTOR (node->decl) = 0;\n     }\n-  DECL_PURE_P (node->decl) = pure;\n-  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = looping;\n-  for (alias = node->same_body; alias; alias = alias->next)\n-    {\n-      DECL_PURE_P (alias->decl) = pure;\n-      DECL_LOOPING_CONST_OR_PURE_P (alias->decl) = looping;\n-    }\n+  DECL_PURE_P (node->decl) = data != NULL;\n+  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = ((size_t)data & 2) != 0;\n+  return false;\n }\n \n-/* See if the frequency of NODE can be updated based on frequencies of its\n-   callers.  */\n-bool\n-cgraph_propagate_frequency (struct cgraph_node *node)\n+/* Set DECL_PURE_P on NODE's decl and on aliases of NODE\n+   if any to PURE.  */\n+\n+void\n+cgraph_set_pure_flag (struct cgraph_node *node, bool pure, bool looping)\n {\n-  bool maybe_unlikely_executed = true, maybe_executed_once = true;\n-  bool only_called_at_startup = true;\n-  bool only_called_at_exit = true;\n-  bool changed = false;\n-  struct cgraph_edge *edge;\n+  cgraph_for_node_thunks_and_aliases (node, cgraph_set_pure_flag_1,\n+\t\t\t              (void *)(size_t)(pure + (int)looping * 2),\n+\t\t\t\t      false);\n+}\n \n-  if (!node->local.local)\n-    return false;\n-  gcc_assert (node->analyzed);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Processing frequency %s\\n\", cgraph_node_name (node));\n+/* Data used by cgraph_propagate_frequency.  */\n \n+struct cgraph_propagate_frequency_data\n+{\n+  bool maybe_unlikely_executed;\n+  bool maybe_executed_once;\n+  bool only_called_at_startup;\n+  bool only_called_at_exit;\n+};\n+\n+/* Worker for cgraph_propagate_frequency_1.  */\n+\n+static bool\n+cgraph_propagate_frequency_1 (struct cgraph_node *node, void *data)\n+{\n+  struct cgraph_propagate_frequency_data *d;\n+  struct cgraph_edge *edge;\n+\n+  d = (struct cgraph_propagate_frequency_data *)data;\n   for (edge = node->callers;\n-       edge && (maybe_unlikely_executed || maybe_executed_once\n-\t        || only_called_at_startup || only_called_at_exit);\n+       edge && (d->maybe_unlikely_executed || d->maybe_executed_once\n+\t        || d->only_called_at_startup || d->only_called_at_exit);\n        edge = edge->next_caller)\n     {\n       if (edge->caller != node)\n \t{\n-          only_called_at_startup &= edge->caller->only_called_at_startup;\n+          d->only_called_at_startup &= edge->caller->only_called_at_startup;\n \t  /* It makes sense to put main() together with the static constructors.\n \t     It will be executed for sure, but rest of functions called from\n \t     main are definitely not at startup only.  */\n \t  if (MAIN_NAME_P (DECL_NAME (edge->caller->decl)))\n-\t    only_called_at_startup = 0;\n-          only_called_at_exit &= edge->caller->only_called_at_exit;\n+\t    d->only_called_at_startup = 0;\n+          d->only_called_at_exit &= edge->caller->only_called_at_exit;\n \t}\n       if (!edge->frequency)\n \tcontinue;\n@@ -2715,10 +2799,10 @@ cgraph_propagate_frequency (struct cgraph_node *node)\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  Called by %s that is executed once\\n\",\n \t\t     cgraph_node_name (edge->caller));\n-\t  maybe_unlikely_executed = false;\n+\t  d->maybe_unlikely_executed = false;\n \t  if (inline_edge_summary (edge)->loop_depth)\n \t    {\n-\t      maybe_executed_once = false;\n+\t      d->maybe_executed_once = false;\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t        fprintf (dump_file, \"  Called in loop\\n\");\n \t    }\n@@ -2728,12 +2812,31 @@ cgraph_propagate_frequency (struct cgraph_node *node)\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  Called by %s that is normal or hot\\n\",\n \t\t     cgraph_node_name (edge->caller));\n-\t  maybe_unlikely_executed = false;\n-\t  maybe_executed_once = false;\n+\t  d->maybe_unlikely_executed = false;\n+\t  d->maybe_executed_once = false;\n \t  break;\n \t}\n     }\n-  if ((only_called_at_startup && !only_called_at_exit)\n+  return edge != NULL;\n+}\n+\n+/* See if the frequency of NODE can be updated based on frequencies of its\n+   callers.  */\n+bool\n+cgraph_propagate_frequency (struct cgraph_node *node)\n+{\n+  struct cgraph_propagate_frequency_data d = {true, true, true, true};\n+  bool changed = false;\n+\n+  if (!node->local.local)\n+    return false;\n+  gcc_assert (node->analyzed);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Processing frequency %s\\n\", cgraph_node_name (node));\n+\n+  cgraph_for_node_and_aliases (node, cgraph_propagate_frequency_1, &d, true);\n+\n+  if ((d.only_called_at_startup && !d.only_called_at_exit)\n       && !node->only_called_at_startup)\n     {\n        node->only_called_at_startup = true;\n@@ -2742,7 +2845,7 @@ cgraph_propagate_frequency (struct cgraph_node *node)\n \t\t  cgraph_node_name (node));\n        changed = true;\n     }\n-  if ((only_called_at_exit && !only_called_at_startup)\n+  if ((d.only_called_at_exit && !d.only_called_at_startup)\n       && !node->only_called_at_exit)\n     {\n        node->only_called_at_exit = true;\n@@ -2755,15 +2858,15 @@ cgraph_propagate_frequency (struct cgraph_node *node)\n   if (node->frequency == NODE_FREQUENCY_HOT\n       || node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n     return changed;\n-  if (maybe_unlikely_executed)\n+  if (d.maybe_unlikely_executed)\n     {\n       node->frequency = NODE_FREQUENCY_UNLIKELY_EXECUTED;\n       if (dump_file)\n \tfprintf (dump_file, \"Node %s promoted to unlikely executed.\\n\",\n \t\t cgraph_node_name (node));\n       changed = true;\n     }\n-  else if (maybe_executed_once && node->frequency != NODE_FREQUENCY_EXECUTED_ONCE)\n+  else if (d.maybe_executed_once && node->frequency != NODE_FREQUENCY_EXECUTED_ONCE)\n     {\n       node->frequency = NODE_FREQUENCY_EXECUTED_ONCE;\n       if (dump_file)\n@@ -2877,24 +2980,70 @@ resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution resolution)\n           || resolution == LDPR_RESOLVED_DYN);\n }\n \n+\n /* Return true when NODE is known to be used from other (non-LTO) object file.\n    Known only when doing LTO via linker plugin.  */\n \n bool\n cgraph_used_from_object_file_p (struct cgraph_node *node)\n {\n-  struct cgraph_node *alias;\n-\n   gcc_assert (!node->global.inlined_to);\n   if (!TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl))\n     return false;\n   if (resolution_used_from_other_file_p (node->resolution))\n     return true;\n-  for (alias = node->same_body; alias; alias = alias->next)\n-    if (TREE_PUBLIC (alias->decl)\n-\t&& resolution_used_from_other_file_p (alias->resolution))\n-      return true;\n   return false;\n }\n \n+/* Worker for cgraph_only_called_directly_p.  */\n+\n+static bool\n+cgraph_not_only_called_directly_p_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+{\n+  return !cgraph_only_called_directly_or_aliased_p (node);\n+}\n+\n+/* Return true when function NODE and all its aliases are only called\n+   directly.\n+   i.e. it is not externally visible, address was not taken and\n+   it is not used in any other non-standard way.  */\n+\n+bool\n+cgraph_only_called_directly_p (struct cgraph_node *node)\n+{\n+  gcc_assert (cgraph_function_or_thunk_node (node, NULL) == node);\n+  return !cgraph_for_node_and_aliases (node, cgraph_not_only_called_directly_p_1,\n+\t\t\t\t       NULL, true);\n+}\n+\n+\n+/* Collect all callers of NODE.  Worker for collect_callers_of_node.  */\n+\n+static bool\n+collect_callers_of_node_1 (struct cgraph_node *node, void *data)\n+{\n+  VEC (cgraph_edge_p, heap) ** redirect_callers = (VEC (cgraph_edge_p, heap) **)data;\n+  struct cgraph_edge *cs;\n+  enum availability avail;\n+  cgraph_function_or_thunk_node (node, &avail);\n+\n+  if (avail > AVAIL_OVERWRITABLE)\n+    for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n+      if (!cs->indirect_inlining_edge)\n+        VEC_safe_push (cgraph_edge_p, heap, *redirect_callers, cs);\n+  return false;\n+}\n+\n+/* Collect all callers of NODE and its aliases that are known to lead to NODE\n+   (i.e. are not overwritable).  */\n+\n+VEC (cgraph_edge_p, heap) *\n+collect_callers_of_node (struct cgraph_node *node)\n+{\n+  VEC (cgraph_edge_p, heap) * redirect_callers = NULL;\n+  cgraph_for_node_and_aliases (node, collect_callers_of_node_1,\n+\t\t\t       &redirect_callers, false);\n+  return redirect_callers;\n+}\n+\n #include \"gt-cgraph.h\""}, {"sha": "055ab4884ef98e0d2d1fd99a058d2799f62154bf", "filename": "gcc/cgraph.h", "status": "modified", "additions": 62, "deletions": 12, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be330ed46a4d923603f191dc1d2d8c87f345a5f8/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be330ed46a4d923603f191dc1d2d8c87f345a5f8/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=be330ed46a4d923603f191dc1d2d8c87f345a5f8", "patch": "@@ -512,6 +512,7 @@ struct cgraph_node * cgraph_clone_node (struct cgraph_node *, tree, gcov_type,\n void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);\n void cgraph_make_edge_direct (struct cgraph_edge *, struct cgraph_node *,\n \t\t\t      HOST_WIDE_INT);\n+bool cgraph_only_called_directly_p (struct cgraph_node *);\n \n struct cgraph_asm_node *cgraph_add_asm_node (tree);\n \n@@ -537,9 +538,18 @@ bool cgraph_will_be_removed_from_program_if_no_direct_calls\n   (struct cgraph_node *node);\n bool cgraph_can_remove_if_no_direct_calls_and_refs_p\n   (struct cgraph_node *node);\n-bool resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution resolution);\n-bool cgraph_used_from_object_file_p (struct cgraph_node *node);\n-bool varpool_used_from_object_file_p (struct varpool_node *node);\n+bool resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution);\n+bool cgraph_used_from_object_file_p (struct cgraph_node *);\n+bool varpool_used_from_object_file_p (struct varpool_node *);\n+bool cgraph_for_node_thunks_and_aliases (struct cgraph_node *,\n+\t\t\t                 bool (*) (struct cgraph_node *, void *),\n+\t\t\t                 void *,\n+\t\t\t\t\t bool);\n+bool cgraph_for_node_and_aliases (struct cgraph_node *,\n+\t\t                  bool (*) (struct cgraph_node *, void *),\n+\t\t\t          void *, bool);\n+VEC (cgraph_edge_p, heap) * collect_callers_of_node (struct cgraph_node *node);\n+\n \n /* In cgraphunit.c  */\n extern FILE *cgraph_dump_file;\n@@ -899,12 +909,12 @@ varpool_node_set_nonempty_p (varpool_node_set set)\n   return !VEC_empty (varpool_node_ptr, set->nodes);\n }\n \n-/* Return true when function NODE is only called directly.\n+/* Return true when function NODE is only called directly or it has alias.\n    i.e. it is not externally visible, address was not taken and\n    it is not used in any other non-standard way.  */\n \n static inline bool\n-cgraph_only_called_directly_p (struct cgraph_node *node)\n+cgraph_only_called_directly_or_aliased_p (struct cgraph_node *node)\n {\n   gcc_assert (!node->global.inlined_to);\n   return (!node->needed && !node->address_taken\n@@ -923,7 +933,8 @@ cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node)\n   /* Extern inlines can always go, we will use the external definition.  */\n   if (DECL_EXTERNAL (node->decl))\n     return true;\n-  return !node->address_taken && cgraph_can_remove_if_no_direct_calls_and_refs_p (node);\n+  return (!node->address_taken\n+\t  && cgraph_can_remove_if_no_direct_calls_and_refs_p (node));\n }\n \n /* Return true when function NODE can be removed from callgraph\n@@ -954,17 +965,56 @@ varpool_all_refs_explicit_p (struct varpool_node *vnode)\n /* Constant pool accessor function.  */\n htab_t constant_pool_htab (void);\n \n+/* FIXME: inappropriate dependency of cgraph on IPA.  */\n+#include \"ipa-ref-inline.h\"\n+\n+/* Given NODE, walk the alias chain to return the function NODE is alias of.\n+   Walk through thunk, too.\n+   When AVAILABILITY is non-NULL, get minimal availablity in the chain.  */\n+\n+static inline struct cgraph_node *\n+cgraph_function_node (struct cgraph_node *node, enum availability *availability)\n+{\n+  if (availability)\n+    *availability = cgraph_function_body_availability (node);\n+  while (node)\n+    {\n+      if (node->thunk.thunk_p)\n+\tnode = node->callees->callee;\n+      else\n+\treturn node;\n+      if (availability)\n+\t{\n+\t  enum availability a;\n+\t  a = cgraph_function_body_availability (node);\n+\t  if (a < *availability)\n+\t    *availability = a;\n+\t}\n+    }\n+  return NULL;\n+}\n+\n+/* Given NODE, walk the alias chain to return the function NODE is alias of.\n+   Do not walk through thunks.\n+   When AVAILABILITY is non-NULL, get minimal availablity in the chain.  */\n+\n+static inline struct cgraph_node *\n+cgraph_function_or_thunk_node (struct cgraph_node *node, enum availability *availability)\n+{\n+  if (availability)\n+    *availability = cgraph_function_body_availability (node);\n+  return node;\n+  return NULL;\n+}\n+\n /* Return true when the edge E represents a direct recursion.  */\n static inline bool\n cgraph_edge_recursive_p (struct cgraph_edge *e)\n {\n+  struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n   if (e->caller->global.inlined_to)\n-    return e->caller->global.inlined_to->decl == e->callee->decl;\n+    return e->caller->global.inlined_to->decl == callee->decl;\n   else\n-    return e->caller->decl == e->callee->decl;\n+    return e->caller->decl == callee->decl;\n }\n-\n-/* FIXME: inappropriate dependency of cgraph on IPA.  */\n-#include \"ipa-ref-inline.h\"\n-\n #endif  /* GCC_CGRAPH_H  */"}]}