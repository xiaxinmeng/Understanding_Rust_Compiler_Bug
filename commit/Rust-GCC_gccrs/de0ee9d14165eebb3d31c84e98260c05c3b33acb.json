{"sha": "de0ee9d14165eebb3d31c84e98260c05c3b33acb", "node_id": "C_kwDOANBUbNoAKGRlMGVlOWQxNDE2NWVlYmIzZDMxYzg0ZTk4MjYwYzA1YzNiMzNhY2I", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-04-15T10:08:45Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-04-15T10:08:45Z"}, "message": "if-conv: Small improvement for expansion of complex PHIs [PR109154]\n\nThe following patch is just a dumb improvement, gets rid of 2 unnecessary\ninstructions on both the PR's original testcase and on the two reduced ones,\nboth on -mcpu=neoverse-v1 and -mavx512f.\n\nThe thing is, if we have args_len (args_len >= 2) unique PHI arguments,\nwe need only args_len - 1 COND_EXPRs to expand the PHI, because first\nCOND_EXPR can merge 2 unique arguments and all the following ones merge\nanother unique argument with the previously merged arguments,\nwhile the code for mysterious reasons was always emitting args_len\nCOND_EXPRs, where the first COND_EXPR merged the first and second unique\narguments, the second COND_EXPR merged the second unique argument with\nresult of merging the first and second unique arguments and the rest was\nalready expectable, nth COND_EXPR for n > 2 merged the nth unique argument\nwith result of merging the previous unique arguments.\nNow, in my understanding, the bb_predicate for bb's predecessor need to\nform a disjunct set which together creates the successor's bb_predicate,\nso I don't see why we'd need to check all the bb_predicates, if we check\nall but one then when all those other ones are false the last bb_predicate\nis necessarily true.  Given that the code attempts to sort argument with\nmost occurrences (so likely most complex combined predicate) last, I chose\nnot to test that last argument's predicate.\nSo e.g. on the testcase from comment 47 in the PR:\nvoid\nfoo (int *f, int d, int e)\n{\n  for (int i = 0; i < 1024; i++)\n    {\n      int a = f[i];\n      int t;\n      if (a < 0)\n        t = 1;\n      else if (a < e)\n        t = 1 - a * d;\n      else\n        t = 0;\n      f[i] = t;\n    }\n}\nwe used to emit:\n  _7 = a_10 < 0;\n  _21 = a_10 >= 0;\n  _22 = a_10 < e_11(D);\n  _23 = _21 & _22;\n  _26 = a_10 >= e_11(D);\n  _27 = _21 & _26;\n  _ifc__42 = _7 ? 1 : t_13;\n  _ifc__43 = _23 ? t_13 : _ifc__42;\n  t_6 = _27 ? 0 : _ifc__43;\nwhile the following patch changes it to:\n  _7 = a_10 < 0;\n  _21 = a_10 >= 0;\n  _22 = a_10 < e_11(D);\n  _23 = _21 & _22;\n  _ifc__42 = _23 ? t_13 : 0;\n  t_6 = _7 ? 1 : _ifc__42;\nwhich I believe should be sufficient for a PHI <1, t_13, 0>.\n\nI've gathered some statistics and on x86_64-linux and i686-linux\nbootstraps/regtests, this code triggers:\n     92 4 4\n    112 2 4\n    141 3 4\n   4046 3 3\n(where 2nd number is args_len and 3rd argument EDGE_COUNT (bb->preds)\nand first argument count of those from sort | uniq -c | sort -n).\nIn all these cases the patch should squeze one extra COND_EXPR and\nits associated predicate (the latter only if it wasn't used elsewhere).\n\nIncrementally, I think we should try to perform some analysis on which\npredicates depend on inverses of other predicates and if possible try\nto sort the arguments better and omit testing unnecessary predicates.\nSo essentially for the above testcase deconstruct it back to:\n  _7 = a_10 < 0;\n  _22 = a_10 < e_11(D);\n  _ifc__42 = _22 ? t_13 : 0;\n  t_6 = _7 ? 1 : _ifc__42;\nwhich is like what this patch produces, but with the & a_10 >= 0 part\nremoved, because the last predicate is a_10 < 0 and so testing a_10 >= 0\non what appears on the false branch doesn't make sense.\nBut I'm afraid that will take more work than is doable in stage4 right now.\n\n2023-04-15  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/109154\n\t* tree-if-conv.cc (predicate_scalar_phi): For complex PHIs, emit just\n\targs_len - 1 COND_EXPRs rather than args_len.  Formatting fix.", "tree": {"sha": "570a2cbf70a92a52456e3c12b58d3c097085bffb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/570a2cbf70a92a52456e3c12b58d3c097085bffb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de0ee9d14165eebb3d31c84e98260c05c3b33acb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de0ee9d14165eebb3d31c84e98260c05c3b33acb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de0ee9d14165eebb3d31c84e98260c05c3b33acb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de0ee9d14165eebb3d31c84e98260c05c3b33acb/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86b31d583a3657f11d930ff156c07b2e20ab05eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86b31d583a3657f11d930ff156c07b2e20ab05eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86b31d583a3657f11d930ff156c07b2e20ab05eb"}], "stats": {"total": 12, "additions": 6, "deletions": 6}, "files": [{"sha": "a19450f533dab0c6c5f7ff628ba1937d791b66a8", "filename": "gcc/tree-if-conv.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de0ee9d14165eebb3d31c84e98260c05c3b33acb/gcc%2Ftree-if-conv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de0ee9d14165eebb3d31c84e98260c05c3b33acb/gcc%2Ftree-if-conv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.cc?ref=de0ee9d14165eebb3d31c84e98260c05c3b33acb", "patch": "@@ -2071,7 +2071,7 @@ predicate_scalar_phi (gphi *phi, gimple_stmt_iterator *gsi)\n     }\n \n   /* Put element with max number of occurences to the end of ARGS.  */\n-  if (max_ind != -1 && max_ind +1 != (int) args_len)\n+  if (max_ind != -1 && max_ind + 1 != (int) args_len)\n     std::swap (args[args_len - 1], args[max_ind]);\n \n   /* Handle one special case when number of arguments with different values\n@@ -2116,12 +2116,12 @@ predicate_scalar_phi (gphi *phi, gimple_stmt_iterator *gsi)\n       vec<int> *indexes;\n       tree type = TREE_TYPE (gimple_phi_result (phi));\n       tree lhs;\n-      arg1 = args[1];\n-      for (i = 0; i < args_len; i++)\n+      arg1 = args[args_len - 1];\n+      for (i = args_len - 1; i > 0; i--)\n \t{\n-\t  arg0 = args[i];\n-\t  indexes = phi_arg_map.get (args[i]);\n-\t  if (i != args_len - 1)\n+\t  arg0 = args[i - 1];\n+\t  indexes = phi_arg_map.get (args[i - 1]);\n+\t  if (i != 1)\n \t    lhs = make_temp_ssa_name (type, NULL, \"_ifc_\");\n \t  else\n \t    lhs = res;"}]}