{"sha": "0c3ea6b3424ee4d32d97ca5d7453891b587b3132", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMzZWE2YjM0MjRlZTRkMzJkOTdjYTVkNzQ1Mzg5MWI1ODdiMzEzMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-29T14:47:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-29T14:47:39Z"}, "message": "Record the vector mask precision in stmt_vec_info\n\nsearch_type_for_mask uses a worklist to search a chain of boolean\noperations for a natural vector mask type.  This patch instead does\nthat in vect_determine_stmt_precisions, where we also look for\noverpromoted integer operations.  We then only need to compute\nthe precision once and can cache it in the stmt_vec_info.\n\nThe new function vect_determine_mask_precision is supposed\nto handle exactly the same cases as search_type_for_mask_1,\nand in the same way.  There's a lot we could improve here,\nbut that's not stage 3 material.\n\nI wondered about sharing mask_precision with other fields like\noperation_precision, but in the end that seemed too dangerous.\nWe have patterns to convert between boolean and non-boolean\noperations and it would be very easy to get mixed up about\nwhich case the fields are describing.\n\n2019-11-29  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (stmt_vec_info::mask_precision): New field.\n\t(vect_use_mask_type_p): New function.\n\t* tree-vect-patterns.c (vect_init_pattern_stmt): Copy the\n\tmask precision to the pattern statement.\n\t(append_pattern_def_seq): Add a scalar_type_for_mask parameter\n\tand use it to initialize the new stmt's mask precision.\n\t(search_type_for_mask_1): Delete.\n\t(search_type_for_mask): Replace with...\n\t(integer_type_for_mask): ...this new function.  Use the information\n\tcached in the stmt_vec_info.\n\t(vect_recog_bool_pattern): Update accordingly.\n\t(build_mask_conversion): Pass the scalar type associated with the\n\tmask type to append_pattern_def_seq.\n\t(vect_recog_mask_conversion_pattern): Likewise.  Call\n\tinteger_type_for_mask instead of search_type_for_mask.\n\t(vect_convert_mask_for_vectype): Call integer_type_for_mask instead\n\tof search_type_for_mask.\n\t(possible_vector_mask_operation_p): New function.\n\t(vect_determine_mask_precision): Likewise.\n\t(vect_determine_stmt_precisions): Call it.\n\nFrom-SVN: r278850", "tree": {"sha": "e0eaba8039e6126c11bac9e41ddc147af9c5a974", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0eaba8039e6126c11bac9e41ddc147af9c5a974"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c3ea6b3424ee4d32d97ca5d7453891b587b3132", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c3ea6b3424ee4d32d97ca5d7453891b587b3132", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c3ea6b3424ee4d32d97ca5d7453891b587b3132", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c3ea6b3424ee4d32d97ca5d7453891b587b3132/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c5d68a677b076262c5508e6d4fbdb765cba2d2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c5d68a677b076262c5508e6d4fbdb765cba2d2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c5d68a677b076262c5508e6d4fbdb765cba2d2f"}], "stats": {"total": 332, "additions": 226, "deletions": 106}, "files": [{"sha": "e1bd340e4bc9698899318f91d138bac93e38f5f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c3ea6b3424ee4d32d97ca5d7453891b587b3132/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c3ea6b3424ee4d32d97ca5d7453891b587b3132/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c3ea6b3424ee4d32d97ca5d7453891b587b3132", "patch": "@@ -1,3 +1,26 @@\n+2019-11-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (stmt_vec_info::mask_precision): New field.\n+\t(vect_use_mask_type_p): New function.\n+\t* tree-vect-patterns.c (vect_init_pattern_stmt): Copy the\n+\tmask precision to the pattern statement.\n+\t(append_pattern_def_seq): Add a scalar_type_for_mask parameter\n+\tand use it to initialize the new stmt's mask precision.\n+\t(search_type_for_mask_1): Delete.\n+\t(search_type_for_mask): Replace with...\n+\t(integer_type_for_mask): ...this new function.  Use the information\n+\tcached in the stmt_vec_info.\n+\t(vect_recog_bool_pattern): Update accordingly.\n+\t(build_mask_conversion): Pass the scalar type associated with the\n+\tmask type to append_pattern_def_seq.\n+\t(vect_recog_mask_conversion_pattern): Likewise.  Call\n+\tinteger_type_for_mask instead of search_type_for_mask.\n+\t(vect_convert_mask_for_vectype): Call integer_type_for_mask instead\n+\tof search_type_for_mask.\n+\t(possible_vector_mask_operation_p): New function.\n+\t(vect_determine_mask_precision): Likewise.\n+\t(vect_determine_stmt_precisions): Call it.\n+\n 2019-11-29  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (get_mask_type_for_scalar_type): Replace"}, {"sha": "2e021287b4efc120aa933e5404e07a22962a3e61", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 177, "deletions": 106, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c3ea6b3424ee4d32d97ca5d7453891b587b3132/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c3ea6b3424ee4d32d97ca5d7453891b587b3132/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=0c3ea6b3424ee4d32d97ca5d7453891b587b3132", "patch": "@@ -112,7 +112,12 @@ vect_init_pattern_stmt (gimple *pattern_stmt, stmt_vec_info orig_stmt_info,\n   STMT_VINFO_DEF_TYPE (pattern_stmt_info)\n     = STMT_VINFO_DEF_TYPE (orig_stmt_info);\n   if (!STMT_VINFO_VECTYPE (pattern_stmt_info))\n-    STMT_VINFO_VECTYPE (pattern_stmt_info) = vectype;\n+    {\n+      gcc_assert (VECTOR_BOOLEAN_TYPE_P (vectype)\n+\t\t  == vect_use_mask_type_p (orig_stmt_info));\n+      STMT_VINFO_VECTYPE (pattern_stmt_info) = vectype;\n+      pattern_stmt_info->mask_precision = orig_stmt_info->mask_precision;\n+    }\n   return pattern_stmt_info;\n }\n \n@@ -131,17 +136,25 @@ vect_set_pattern_stmt (gimple *pattern_stmt, stmt_vec_info orig_stmt_info,\n \n /* Add NEW_STMT to STMT_INFO's pattern definition statements.  If VECTYPE\n    is nonnull, record that NEW_STMT's vector type is VECTYPE, which might\n-   be different from the vector type of the final pattern statement.  */\n+   be different from the vector type of the final pattern statement.\n+   If VECTYPE is a mask type, SCALAR_TYPE_FOR_MASK is the scalar type\n+   from which it was derived.  */\n \n static inline void\n append_pattern_def_seq (stmt_vec_info stmt_info, gimple *new_stmt,\n-\t\t\ttree vectype = NULL_TREE)\n+\t\t\ttree vectype = NULL_TREE,\n+\t\t\ttree scalar_type_for_mask = NULL_TREE)\n {\n+  gcc_assert (!scalar_type_for_mask\n+\t      == (!vectype || !VECTOR_BOOLEAN_TYPE_P (vectype)));\n   vec_info *vinfo = stmt_info->vinfo;\n   if (vectype)\n     {\n       stmt_vec_info new_stmt_info = vinfo->add_stmt (new_stmt);\n       STMT_VINFO_VECTYPE (new_stmt_info) = vectype;\n+      if (scalar_type_for_mask)\n+\tnew_stmt_info->mask_precision\n+\t  = GET_MODE_BITSIZE (SCALAR_TYPE_MODE (scalar_type_for_mask));\n     }\n   gimple_seq_add_stmt_without_update (&STMT_VINFO_PATTERN_DEF_SEQ (stmt_info),\n \t\t\t\t      new_stmt);\n@@ -3886,108 +3899,22 @@ adjust_bool_stmts (hash_set <gimple *> &bool_stmt_set,\n   return gimple_assign_lhs (pattern_stmt);\n }\n \n-/* Helper for search_type_for_mask.  */\n+/* Return the proper type for converting bool VAR into\n+   an integer value or NULL_TREE if no such type exists.\n+   The type is chosen so that the converted value has the\n+   same number of elements as VAR's vector type.  */\n \n static tree\n-search_type_for_mask_1 (tree var, vec_info *vinfo,\n-\t\t\thash_map<gimple *, tree> &cache)\n+integer_type_for_mask (tree var, vec_info *vinfo)\n {\n-  tree rhs1;\n-  enum tree_code rhs_code;\n-  tree res = NULL_TREE, res2;\n-\n   if (!VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (var)))\n     return NULL_TREE;\n \n   stmt_vec_info def_stmt_info = vect_get_internal_def (vinfo, var);\n-  if (!def_stmt_info)\n+  if (!def_stmt_info || !vect_use_mask_type_p (def_stmt_info))\n     return NULL_TREE;\n \n-  gassign *def_stmt = dyn_cast <gassign *> (def_stmt_info->stmt);\n-  if (!def_stmt)\n-    return NULL_TREE;\n-\n-  tree *c = cache.get (def_stmt);\n-  if (c)\n-    return *c;\n-\n-  rhs_code = gimple_assign_rhs_code (def_stmt);\n-  rhs1 = gimple_assign_rhs1 (def_stmt);\n-\n-  switch (rhs_code)\n-    {\n-    case SSA_NAME:\n-    case BIT_NOT_EXPR:\n-    CASE_CONVERT:\n-      res = search_type_for_mask_1 (rhs1, vinfo, cache);\n-      break;\n-\n-    case BIT_AND_EXPR:\n-    case BIT_IOR_EXPR:\n-    case BIT_XOR_EXPR:\n-      res = search_type_for_mask_1 (rhs1, vinfo, cache);\n-      res2 = search_type_for_mask_1 (gimple_assign_rhs2 (def_stmt), vinfo,\n-\t\t\t\t     cache);\n-      if (!res || (res2 && TYPE_PRECISION (res) > TYPE_PRECISION (res2)))\n-\tres = res2;\n-      break;\n-\n-    default:\n-      if (TREE_CODE_CLASS (rhs_code) == tcc_comparison)\n-\t{\n-\t  tree comp_vectype, mask_type;\n-\n-\t  if (VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (rhs1)))\n-\t    {\n-\t      res = search_type_for_mask_1 (rhs1, vinfo, cache);\n-\t      res2 = search_type_for_mask_1 (gimple_assign_rhs2 (def_stmt),\n-\t\t\t\t\t     vinfo, cache);\n-\t      if (!res || (res2 && TYPE_PRECISION (res) > TYPE_PRECISION (res2)))\n-\t\tres = res2;\n-\t      if (res)\n-\t\tbreak;\n-\t    }\n-\n-\t  comp_vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (rhs1));\n-\t  if (comp_vectype == NULL_TREE)\n-\t    {\n-\t      res = NULL_TREE;\n-\t      break;\n-\t    }\n-\n-\t  mask_type = get_mask_type_for_scalar_type (vinfo, TREE_TYPE (rhs1));\n-\t  if (!mask_type\n-\t      || !expand_vec_cmp_expr_p (comp_vectype, mask_type, rhs_code))\n-\t    {\n-\t      res = NULL_TREE;\n-\t      break;\n-\t    }\n-\n-\t  if (TREE_CODE (TREE_TYPE (rhs1)) != INTEGER_TYPE\n-\t      || !TYPE_UNSIGNED (TREE_TYPE (rhs1)))\n-\t    {\n-\t      scalar_mode mode = SCALAR_TYPE_MODE (TREE_TYPE (rhs1));\n-\t      res = build_nonstandard_integer_type (GET_MODE_BITSIZE (mode), 1);\n-\t    }\n-\t  else\n-\t    res = TREE_TYPE (rhs1);\n-\t}\n-    }\n-\n-  cache.put (def_stmt, res);\n-  return res;\n-}\n-\n-/* Return the proper type for converting bool VAR into\n-   an integer value or NULL_TREE if no such type exists.\n-   The type is chosen so that converted value has the\n-   same number of elements as VAR's vector type.  */\n-\n-static tree\n-search_type_for_mask (tree var, vec_info *vinfo)\n-{\n-  hash_map<gimple *, tree> cache;\n-  return search_type_for_mask_1 (var, vinfo, cache);\n+  return build_nonstandard_integer_type (def_stmt_info->mask_precision, 1);\n }\n \n /* Function vect_recog_bool_pattern\n@@ -4079,7 +4006,7 @@ vect_recog_bool_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t}\n       else\n \t{\n-\t  tree type = search_type_for_mask (var, vinfo);\n+\t  tree type = integer_type_for_mask (var, vinfo);\n \t  tree cst0, cst1, tmp;\n \n \t  if (!type)\n@@ -4164,7 +4091,7 @@ vect_recog_bool_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \trhs = adjust_bool_stmts (bool_stmts, TREE_TYPE (vectype), stmt_vinfo);\n       else\n \t{\n-\t  tree type = search_type_for_mask (var, vinfo);\n+\t  tree type = integer_type_for_mask (var, vinfo);\n \t  tree cst0, cst1, new_vectype;\n \n \t  if (!type)\n@@ -4219,7 +4146,7 @@ build_mask_conversion (tree mask, tree vectype, stmt_vec_info stmt_vinfo)\n   masktype = truth_type_for (vectype);\n   tmp = vect_recog_temp_ssa_var (TREE_TYPE (masktype), NULL);\n   stmt = gimple_build_assign (tmp, CONVERT_EXPR, mask);\n-  append_pattern_def_seq (stmt_vinfo, stmt, masktype);\n+  append_pattern_def_seq (stmt_vinfo, stmt, masktype, TREE_TYPE (vectype));\n \n   return tmp;\n }\n@@ -4285,7 +4212,7 @@ vect_recog_mask_conversion_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t}\n \n       tree mask_arg = gimple_call_arg (last_stmt, mask_argno);\n-      tree mask_arg_type = search_type_for_mask (mask_arg, vinfo);\n+      tree mask_arg_type = integer_type_for_mask (mask_arg, vinfo);\n       if (!mask_arg_type)\n \treturn NULL;\n       vectype2 = get_mask_type_for_scalar_type (vinfo, mask_arg_type);\n@@ -4338,7 +4265,7 @@ vect_recog_mask_conversion_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \n       if (TREE_CODE (rhs1) == SSA_NAME)\n \t{\n-\t  rhs1_type = search_type_for_mask (rhs1, vinfo);\n+\t  rhs1_type = integer_type_for_mask (rhs1, vinfo);\n \t  if (!rhs1_type)\n \t    return NULL;\n \t}\n@@ -4358,7 +4285,7 @@ vect_recog_mask_conversion_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \n \t     it is better for b1 and b2 to use the mask type associated\n \t     with int elements rather bool (byte) elements.  */\n-\t  rhs1_type = search_type_for_mask (TREE_OPERAND (rhs1, 0), vinfo);\n+\t  rhs1_type = integer_type_for_mask (TREE_OPERAND (rhs1, 0), vinfo);\n \t  if (!rhs1_type)\n \t    rhs1_type = TREE_TYPE (TREE_OPERAND (rhs1, 0));\n \t}\n@@ -4414,7 +4341,8 @@ vect_recog_mask_conversion_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t  tmp = vect_recog_temp_ssa_var (TREE_TYPE (rhs1), NULL);\n \t  pattern_stmt = gimple_build_assign (tmp, rhs1);\n \t  rhs1 = tmp;\n-\t  append_pattern_def_seq (stmt_vinfo, pattern_stmt, vectype2);\n+\t  append_pattern_def_seq (stmt_vinfo, pattern_stmt, vectype2,\n+\t\t\t\t  rhs1_type);\n \t}\n \n       if (maybe_ne (TYPE_VECTOR_SUBPARTS (vectype1),\n@@ -4447,8 +4375,8 @@ vect_recog_mask_conversion_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \n   rhs2 = gimple_assign_rhs2 (last_stmt);\n \n-  rhs1_type = search_type_for_mask (rhs1, vinfo);\n-  rhs2_type = search_type_for_mask (rhs2, vinfo);\n+  rhs1_type = integer_type_for_mask (rhs1, vinfo);\n+  rhs2_type = integer_type_for_mask (rhs2, vinfo);\n \n   if (!rhs1_type || !rhs2_type\n       || TYPE_PRECISION (rhs1_type) == TYPE_PRECISION (rhs2_type))\n@@ -4509,7 +4437,7 @@ static tree\n vect_convert_mask_for_vectype (tree mask, tree vectype,\n \t\t\t       stmt_vec_info stmt_info, vec_info *vinfo)\n {\n-  tree mask_type = search_type_for_mask (mask, vinfo);\n+  tree mask_type = integer_type_for_mask (mask, vinfo);\n   if (mask_type)\n     {\n       tree mask_vectype = get_mask_type_for_scalar_type (vinfo, mask_type);\n@@ -4949,6 +4877,148 @@ vect_determine_precisions_from_users (stmt_vec_info stmt_info, gassign *stmt)\n   vect_set_min_input_precision (stmt_info, type, min_input_precision);\n }\n \n+/* Return true if the statement described by STMT_INFO sets a boolean\n+   SSA_NAME and if we know how to vectorize this kind of statement using\n+   vector mask types.  */\n+\n+static bool\n+possible_vector_mask_operation_p (stmt_vec_info stmt_info)\n+{\n+  tree lhs = gimple_get_lhs (stmt_info->stmt);\n+  if (!lhs\n+      || TREE_CODE (lhs) != SSA_NAME\n+      || !VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (lhs)))\n+    return false;\n+\n+  if (gassign *assign = dyn_cast <gassign *> (stmt_info->stmt))\n+    {\n+      tree_code rhs_code = gimple_assign_rhs_code (assign);\n+      switch (rhs_code)\n+\t{\n+\tCASE_CONVERT:\n+\tcase SSA_NAME:\n+\tcase BIT_NOT_EXPR:\n+\tcase BIT_IOR_EXPR:\n+\tcase BIT_XOR_EXPR:\n+\tcase BIT_AND_EXPR:\n+\t  return true;\n+\n+\tdefault:\n+\t  return TREE_CODE_CLASS (rhs_code) == tcc_comparison;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* If STMT_INFO sets a boolean SSA_NAME, see whether we should use\n+   a vector mask type instead of a normal vector type.  Record the\n+   result in STMT_INFO->mask_precision.  */\n+\n+static void\n+vect_determine_mask_precision (stmt_vec_info stmt_info)\n+{\n+  vec_info *vinfo = stmt_info->vinfo;\n+\n+  if (!possible_vector_mask_operation_p (stmt_info)\n+      || stmt_info->mask_precision)\n+    return;\n+\n+  auto_vec<stmt_vec_info, 32> worklist;\n+  worklist.quick_push (stmt_info);\n+  while (!worklist.is_empty ())\n+    {\n+      stmt_info = worklist.last ();\n+      unsigned int orig_length = worklist.length ();\n+\n+      /* If at least one boolean input uses a vector mask type,\n+\t pick the mask type with the narrowest elements.\n+\n+\t ??? This is the traditional behavior.  It should always produce\n+\t the smallest number of operations, but isn't necessarily the\n+\t optimal choice.  For example, if we have:\n+\n+\t   a = b & c\n+\n+\t where:\n+\n+\t - the user of a wants it to have a mask type for 16-bit elements (M16)\n+\t - b also uses M16\n+\t - c uses a mask type for 8-bit elements (M8)\n+\n+\t then picking M8 gives:\n+\n+\t - 1 M16->M8 pack for b\n+\t - 1 M8 AND for a\n+\t - 2 M8->M16 unpacks for the user of a\n+\n+\t whereas picking M16 would have given:\n+\n+\t - 2 M8->M16 unpacks for c\n+\t - 2 M16 ANDs for a\n+\n+\t The number of operations are equal, but M16 would have given\n+\t a shorter dependency chain and allowed more ILP.  */\n+      unsigned int precision = ~0U;\n+      gassign *assign = as_a <gassign *> (stmt_info->stmt);\n+      unsigned int nops = gimple_num_ops (assign);\n+      for (unsigned int i = 1; i < nops; ++i)\n+\t{\n+\t  tree rhs = gimple_op (assign, i);\n+\t  if (!VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (rhs)))\n+\t    continue;\n+\n+\t  stmt_vec_info def_stmt_info = vinfo->lookup_def (rhs);\n+\t  if (!def_stmt_info)\n+\t    /* Don't let external or constant operands influence the choice.\n+\t       We can convert them to whichever vector type we pick.  */\n+\t    continue;\n+\n+\t  if (def_stmt_info->mask_precision)\n+\t    {\n+\t      if (precision > def_stmt_info->mask_precision)\n+\t\tprecision = def_stmt_info->mask_precision;\n+\t    }\n+\t  else if (possible_vector_mask_operation_p (def_stmt_info))\n+\t    worklist.safe_push (def_stmt_info);\n+\t}\n+\n+      /* Defer the choice if we need to visit operands first.  */\n+      if (orig_length != worklist.length ())\n+\tcontinue;\n+\n+      /* If the statement compares two values that shouldn't use vector masks,\n+\t try comparing the values as normal scalars instead.  */\n+      tree_code rhs_code = gimple_assign_rhs_code (assign);\n+      if (precision == ~0U\n+\t  && TREE_CODE_CLASS (rhs_code) == tcc_comparison)\n+\t{\n+\t  tree rhs1_type = TREE_TYPE (gimple_assign_rhs1 (assign));\n+\t  scalar_mode mode;\n+\t  tree vectype, mask_type;\n+\t  if (is_a <scalar_mode> (TYPE_MODE (rhs1_type), &mode)\n+\t      && (vectype = get_vectype_for_scalar_type (vinfo, rhs1_type))\n+\t      && (mask_type = get_mask_type_for_scalar_type (vinfo, rhs1_type))\n+\t      && expand_vec_cmp_expr_p (vectype, mask_type, rhs_code))\n+\t    precision = GET_MODE_BITSIZE (mode);\n+\t}\n+\n+      if (dump_enabled_p ())\n+\t{\n+\t  if (precision == ~0U)\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"using normal nonmask vectors for %G\",\n+\t\t\t     stmt_info->stmt);\n+\t  else\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"using boolean precision %d for %G\",\n+\t\t\t     precision, stmt_info->stmt);\n+\t}\n+\n+      stmt_info->mask_precision = precision;\n+      worklist.pop ();\n+    }\n+}\n+\n /* Handle vect_determine_precisions for STMT_INFO, given that we\n    have already done so for the users of its result.  */\n \n@@ -4961,6 +5031,7 @@ vect_determine_stmt_precisions (stmt_vec_info stmt_info)\n       vect_determine_precisions_from_range (stmt_info, stmt);\n       vect_determine_precisions_from_users (stmt_info, stmt);\n     }\n+  vect_determine_mask_precision (stmt_info);\n }\n \n /* Walk backwards through the vectorizable region to determine the"}, {"sha": "51a13f1d20742d4b17811d2ab90900b730da5ea0", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c3ea6b3424ee4d32d97ca5d7453891b587b3132/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c3ea6b3424ee4d32d97ca5d7453891b587b3132/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=0c3ea6b3424ee4d32d97ca5d7453891b587b3132", "patch": "@@ -1089,6 +1089,23 @@ class _stmt_vec_info {\n   unsigned int operation_precision;\n   signop operation_sign;\n \n+  /* If the statement produces a boolean result, this value describes\n+     how we should choose the associated vector type.  The possible\n+     values are:\n+\n+     - an integer precision N if we should use the vector mask type\n+       associated with N-bit integers.  This is only used if all relevant\n+       input booleans also want the vector mask type for N-bit integers,\n+       or if we can convert them into that form by pattern-matching.\n+\n+     - ~0U if we considered choosing a vector mask type but decided\n+       to treat the boolean as a normal integer type instead.\n+\n+     - 0 otherwise.  This means either that the operation isn't one that\n+       could have a vector mask type (and so should have a normal vector\n+       type instead) or that we simply haven't made a choice either way.  */\n+  unsigned int mask_precision;\n+\n   /* True if this is only suitable for SLP vectorization.  */\n   bool slp_vect_only_p;\n };\n@@ -1245,6 +1262,15 @@ nested_in_vect_loop_p (class loop *loop, stmt_vec_info stmt_info)\n \t  && (loop->inner == (gimple_bb (stmt_info->stmt))->loop_father));\n }\n \n+/* Return true if STMT_INFO should produce a vector mask type rather than\n+   a normal nonmask type.  */\n+\n+static inline bool\n+vect_use_mask_type_p (stmt_vec_info stmt_info)\n+{\n+  return stmt_info->mask_precision && stmt_info->mask_precision != ~0U;\n+}\n+\n /* Return TRUE if a statement represented by STMT_INFO is a part of a\n    pattern.  */\n "}]}