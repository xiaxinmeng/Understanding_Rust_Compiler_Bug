{"sha": "d59171daa764fc59764a7538e48460ffcdae3f9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU5MTcxZGFhNzY0ZmM1OTc2NGE3NTM4ZTQ4NDYwZmZjZGFlM2Y5Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-11-05T14:00:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-11-05T14:00:46Z"}, "message": "ipa-inline.c (compute_uninlined_call_time, [...]): New functions.\n\n\n\t* ipa-inline.c (compute_uninlined_call_time,\n\tcompute_inlined_call_time): New functions.\n\t(RELATIVE_TIME_BENEFIT_RANGE): New macro.\n\t(relative_time_benefit): Rewrite.\n\t(edge_badness): Rewrite path with guessed profile and estimated profile.\n\t* ipa-inline.h (INLINE_HINT_declared_inline, INLINE_HINT_cross_module):\n\tNew hints.\n\t(struct inline_summary): Add GROWTH filed.\n\t* ipa-inline-analysis.c (dump_inline_hints): Update.\n\t(reset_inline_summary): Update.\n\t(dump_inline_summary): Update.\n\t(will_be_nonconstant_predicate): Cleanup to use gimple_store_p and\n\tgimple_assign_load_p predicates.\n\t(estimate_node_size_and_time): Drop INLINE_HINT_declared_inline hint.\n\t(simple_edge_hints): New function.\n\t(do_estimate_edge_time): Return time of invocation of callee rather\n\tthan the time scaled by edge frequency; update hints code.\n\t(do_estimate_edge_hints): Update.\n\t(do_estimate_growth): Cleanup.\n\nFrom-SVN: r193161", "tree": {"sha": "75c6f6529140bc6332176723a9911440e6cf9481", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75c6f6529140bc6332176723a9911440e6cf9481"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d59171daa764fc59764a7538e48460ffcdae3f9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d59171daa764fc59764a7538e48460ffcdae3f9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d59171daa764fc59764a7538e48460ffcdae3f9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d59171daa764fc59764a7538e48460ffcdae3f9b/comments", "author": null, "committer": null, "parents": [{"sha": "0450d718804aac79ea618dcdfc74bfbda0a7e66e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0450d718804aac79ea618dcdfc74bfbda0a7e66e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0450d718804aac79ea618dcdfc74bfbda0a7e66e"}], "stats": {"total": 275, "additions": 179, "deletions": 96}, "files": [{"sha": "50148685ef90b5d08ffc8b5d5fb23d8ab5d5d5a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d59171daa764fc59764a7538e48460ffcdae3f9b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d59171daa764fc59764a7538e48460ffcdae3f9b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d59171daa764fc59764a7538e48460ffcdae3f9b", "patch": "@@ -1,3 +1,25 @@\n+2012-11-05  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (compute_uninlined_call_time,\n+\tcompute_inlined_call_time): New functions.\n+\t(RELATIVE_TIME_BENEFIT_RANGE): New macro.\n+\t(relative_time_benefit): Rewrite.\n+\t(edge_badness): Rewrite path with guessed profile and estimated profile.\n+\t* ipa-inline.h (INLINE_HINT_declared_inline, INLINE_HINT_cross_module):\n+\tNew hints.\n+\t(struct inline_summary): Add GROWTH filed.\n+\t* ipa-inline-analysis.c (dump_inline_hints): Update.\n+\t(reset_inline_summary): Update.\n+\t(dump_inline_summary): Update.\n+\t(will_be_nonconstant_predicate): Cleanup to use gimple_store_p and\n+\tgimple_assign_load_p predicates.\n+\t(estimate_node_size_and_time): Drop INLINE_HINT_declared_inline hint.\n+\t(simple_edge_hints): New function.\n+\t(do_estimate_edge_time): Return time of invocation of callee rather\n+\tthan the time scaled by edge frequency; update hints code.\n+\t(do_estimate_edge_hints): Update.\n+\t(do_estimate_growth): Cleanup.\n+\n 2012-11-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/55194"}, {"sha": "595cb682a5b7445f1ca015da22c8eef0620143fe", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d59171daa764fc59764a7538e48460ffcdae3f9b/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d59171daa764fc59764a7538e48460ffcdae3f9b/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=d59171daa764fc59764a7538e48460ffcdae3f9b", "patch": "@@ -649,6 +649,16 @@ dump_inline_hints (FILE *f, inline_hints hints)\n       hints &= ~INLINE_HINT_in_scc;\n       fprintf (f, \" in_scc\");\n     }\n+  if (hints & INLINE_HINT_cross_module)\n+    {\n+      hints &= ~INLINE_HINT_cross_module;\n+      fprintf (f, \" cross_module\");\n+    }\n+  if (hints & INLINE_HINT_declared_inline)\n+    {\n+      hints &= ~INLINE_HINT_declared_inline;\n+      fprintf (f, \" declared_inline\");\n+    }\n   gcc_assert (!hints);\n }\n \n@@ -983,6 +993,7 @@ reset_inline_summary (struct cgraph_node *node)\n   info->stack_frame_offset = 0;\n   info->size = 0;\n   info->time = 0;\n+  info->growth = 0;\n   info->scc_no = 0;\n   if (info->loop_iterations)\n     {\n@@ -1375,6 +1386,9 @@ dump_inline_summary (FILE * f, struct cgraph_node *node)\n \t       (int) s->estimated_self_stack_size);\n       fprintf (f, \"  global stack:    %i\\n\",\n \t       (int) s->estimated_stack_size);\n+      if (s->growth)\n+        fprintf (f, \"  estimated growth:%i\\n\",\n+\t         (int) s->growth);\n       if (s->scc_no)\n         fprintf (f, \"  In SCC:          %i\\n\",\n \t         (int) s->scc_no);\n@@ -1977,10 +1991,11 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n     return p;\n \n   /* Stores will stay anyway.  */\n-  if (gimple_vdef (stmt))\n+  if (gimple_store_p (stmt))\n     return p;\n \n-  is_load = gimple_vuse (stmt) != NULL;\n+  is_load = gimple_assign_load_p (stmt);\n+\n   /* Loads can be optimized when the value is known.  */\n   if (is_load)\n     {\n@@ -2857,6 +2872,8 @@ estimate_node_size_and_time (struct cgraph_node *node,\n     hints |=INLINE_HINT_loop_stride;\n   if (info->scc_no)\n     hints |= INLINE_HINT_in_scc;\n+  if (DECL_DECLARED_INLINE_P (node->symbol.decl))\n+    hints |= INLINE_HINT_declared_inline;\n \n   estimate_calls_size_and_time (node, &size, &time, &hints, possible_truths,\n \t\t\t\tknown_vals, known_binfos, known_aggs);\n@@ -2865,7 +2882,6 @@ estimate_node_size_and_time (struct cgraph_node *node,\n   time = RDIV (time, INLINE_TIME_SCALE);\n   size = RDIV (size, INLINE_SIZE_SCALE);\n \n-\n   if (dump_file\n       && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n   size:%i time:%i\\n\", (int)size, (int)time);\n@@ -3315,6 +3331,26 @@ inline_update_overall_summary (struct cgraph_node *node)\n   info->size = (info->size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n }\n \n+/* Return hints derrived from EDGE.   */\n+int\n+simple_edge_hints (struct cgraph_edge *edge)\n+{\n+  int hints = 0;\n+  struct cgraph_node *to = (edge->caller->global.inlined_to\n+\t\t\t    ? edge->caller->global.inlined_to\n+\t\t\t    : edge->caller);\n+  if (inline_summary (to)->scc_no\n+      && inline_summary (to)->scc_no == inline_summary (edge->callee)->scc_no\n+      && !cgraph_edge_recursive_p (edge))\n+    hints |= INLINE_HINT_same_scc;\n+\n+  if (to->symbol.lto_file_data && edge->callee->symbol.lto_file_data\n+      && to->symbol.lto_file_data != edge->callee->symbol.lto_file_data)\n+    hints |= INLINE_HINT_cross_module;\n+\n+  return hints;\n+}\n+\n /* Estimate the time cost for the caller when inlining EDGE.\n    Only to be called via estimate_edge_time, that handles the\n    caching mechanism.\n@@ -3328,7 +3364,6 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   int time;\n   int size;\n   inline_hints hints;\n-  gcov_type ret;\n   struct cgraph_node *callee;\n   clause_t clause;\n   VEC (tree, heap) *known_vals;\n@@ -3347,33 +3382,26 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   VEC_free (tree, heap, known_vals);\n   VEC_free (tree, heap, known_binfos);\n   VEC_free (ipa_agg_jump_function_p, heap, known_aggs);\n-\n-  ret = RDIV ((gcov_type)time * edge->frequency,\n-\t      CGRAPH_FREQ_BASE);\n+  gcc_checking_assert (size >= 0);\n+  gcc_checking_assert (time >= 0);\n \n   /* When caching, update the cache entry.  */\n   if (edge_growth_cache)\n     {\n-      struct cgraph_node *to = (edge->caller->global.inlined_to\n-\t\t\t        ? edge->caller->global.inlined_to\n-\t\t\t\t: edge->caller);\n       if ((int)VEC_length (edge_growth_cache_entry, edge_growth_cache)\n \t  <= edge->uid)\n \tVEC_safe_grow_cleared (edge_growth_cache_entry, heap, edge_growth_cache,\n \t\t\t       cgraph_edge_max_uid);\n       VEC_index (edge_growth_cache_entry, edge_growth_cache, edge->uid).time\n-\t= ret + (ret >= 0);\n+\t= time + (time >= 0);\n \n       VEC_index (edge_growth_cache_entry, edge_growth_cache, edge->uid).size\n \t= size + (size >= 0);\n-      if (inline_summary (to)->scc_no\n-\t  && inline_summary (to)->scc_no == inline_summary (callee)->scc_no\n-\t  && !cgraph_edge_recursive_p (edge))\n-\thints |= INLINE_HINT_same_scc;\n+      hints |= simple_edge_hints (edge);\n       VEC_index (edge_growth_cache_entry, edge_growth_cache, edge->uid).hints\n \t= hints + 1;\n     }\n-  return ret;\n+  return time;\n }\n \n \n@@ -3430,9 +3458,6 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n   VEC (tree, heap) *known_vals;\n   VEC (tree, heap) *known_binfos;\n   VEC (ipa_agg_jump_function_p, heap) *known_aggs;\n-  struct cgraph_node *to = (edge->caller->global.inlined_to\n-\t\t            ? edge->caller->global.inlined_to\n-\t\t\t    : edge->caller);\n \n   /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n \n@@ -3458,10 +3483,7 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n   VEC_free (tree, heap, known_vals);\n   VEC_free (tree, heap, known_binfos);\n   VEC_free (ipa_agg_jump_function_p, heap, known_aggs);\n-  if (inline_summary (to)->scc_no\n-      && inline_summary (to)->scc_no == inline_summary (callee)->scc_no\n-      && !cgraph_edge_recursive_p (edge))\n-    hints |= INLINE_HINT_same_scc;\n+  hints |= simple_edge_hints (edge);\n   return hints;\n }\n \n@@ -3549,10 +3571,11 @@ do_estimate_growth (struct cgraph_node *node)\n      return zero or negative growths. */\n   if (d.self_recursive)\n     d.growth = d.growth < info->size ? info->size : d.growth;\n+  else if (DECL_EXTERNAL (node->symbol.decl))\n+    ;\n   else\n     {\n-      if (!DECL_EXTERNAL (node->symbol.decl)\n-\t  && cgraph_will_be_removed_from_program_if_no_direct_calls (node))\n+      if (cgraph_will_be_removed_from_program_if_no_direct_calls (node))\n \td.growth -= info->size;\n       /* COMDAT functions are very often not shared across multiple units\n \t since they come from various template instantiations."}, {"sha": "b6a69cbbc7c14bf886b2e63d5baebe4f89396a0d", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 100, "deletions": 70, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d59171daa764fc59764a7538e48460ffcdae3f9b/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d59171daa764fc59764a7538e48460ffcdae3f9b/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=d59171daa764fc59764a7538e48460ffcdae3f9b", "patch": "@@ -456,6 +456,42 @@ want_early_inline_function_p (struct cgraph_edge *e)\n   return want_inline;\n }\n \n+/* Compute time of the edge->caller + edge->callee execution when inlining\n+   does not happen.  */\n+\n+inline int\n+compute_uninlined_call_time (struct inline_summary *callee_info,\n+\t\t\t     struct cgraph_edge *edge)\n+{\n+  int uninlined_call_time =\n+    RDIV ((gcov_type)callee_info->time * MAX (edge->frequency, 1),\n+\t  CGRAPH_FREQ_BASE);\n+  int caller_time = inline_summary (edge->caller->global.inlined_to\n+\t\t\t\t    ? edge->caller->global.inlined_to\n+\t\t\t\t    : edge->caller)->time;\n+  return uninlined_call_time + caller_time;\n+}\n+\n+/* Same as compute_uinlined_call_time but compute time when inlining\n+   does happen.  */\n+\n+inline gcov_type\n+compute_inlined_call_time (struct cgraph_edge *edge,\n+\t\t\t   int edge_time)\n+{\n+  int caller_time = inline_summary (edge->caller->global.inlined_to\n+\t\t\t\t    ? edge->caller->global.inlined_to\n+\t\t\t\t    : edge->caller)->time;\n+  int time = caller_time + RDIV ((edge_time - inline_edge_summary (edge)->call_stmt_time)\n+\t\t\t         * MAX (edge->frequency, 1),\n+\t\t\t\t CGRAPH_FREQ_BASE);\n+  /* Possible one roundoff error, but watch for overflows.  */\n+  gcc_checking_assert (time >= INT_MIN / 2);\n+  if (time < 0)\n+    time = 0;\n+  return time;\n+}\n+\n /* Return true if we are interested in inlining small function.\n    When REPORT is true, report reason to dump file.  */\n \n@@ -724,31 +760,41 @@ want_inline_function_to_all_callers_p (struct cgraph_node *node, bool cold)\n    return true;\n }\n \n+#define RELATIVE_TIME_BENEFIT_RANGE (INT_MAX / 64)\n \n /* Return relative time improvement for inlining EDGE in range\n-   1...2^9.  */\n+   1...RELATIVE_TIME_BENEFIT_RANGE  */\n \n static inline int\n relative_time_benefit (struct inline_summary *callee_info,\n \t\t       struct cgraph_edge *edge,\n-\t\t       int time_growth)\n+\t\t       int edge_time)\n {\n   int relbenefit;\n-  gcov_type uninlined_call_time;\n+  int uninlined_call_time = compute_uninlined_call_time (callee_info, edge);\n+  int inlined_call_time = compute_inlined_call_time (edge, edge_time);\n+\n+  /* Inlining into extern inline function is not a win.  */\n+  if (DECL_EXTERNAL (edge->caller->global.inlined_to\n+\t\t     ? edge->caller->global.inlined_to->symbol.decl\n+\t\t     : edge->caller->symbol.decl))\n+    return 1;\n+\n+  /* Watch overflows.  */\n+  gcc_checking_assert (uninlined_call_time >= 0);\n+  gcc_checking_assert (inlined_call_time >= 0);\n+  gcc_checking_assert (uninlined_call_time >= inlined_call_time);\n \n-  uninlined_call_time =\n-    ((gcov_type)\n-     (callee_info->time\n-      + inline_edge_summary (edge)->call_stmt_time) * edge->frequency\n-     + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n   /* Compute relative time benefit, i.e. how much the call becomes faster.\n      ??? perhaps computing how much the caller+calle together become faster\n      would lead to more realistic results.  */\n   if (!uninlined_call_time)\n     uninlined_call_time = 1;\n   relbenefit =\n-    (uninlined_call_time - time_growth) * 256 / (uninlined_call_time);\n-  relbenefit = MIN (relbenefit, 512);\n+    RDIV (((gcov_type)uninlined_call_time - inlined_call_time) * RELATIVE_TIME_BENEFIT_RANGE,\n+\t  uninlined_call_time);\n+  relbenefit = MIN (relbenefit, RELATIVE_TIME_BENEFIT_RANGE);\n+  gcc_checking_assert (relbenefit >= 0);\n   relbenefit = MAX (relbenefit, 1);\n   return relbenefit;\n }\n@@ -764,7 +810,7 @@ static int\n edge_badness (struct cgraph_edge *edge, bool dump)\n {\n   gcov_type badness;\n-  int growth, time_growth;\n+  int growth, edge_time;\n   struct cgraph_node *callee = cgraph_function_or_thunk_node (edge->callee,\n \t\t\t\t\t\t\t      NULL);\n   struct inline_summary *callee_info = inline_summary (callee);\n@@ -774,17 +820,20 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n     return INT_MIN;\n \n   growth = estimate_edge_growth (edge);\n-  time_growth = estimate_edge_time (edge);\n+  edge_time = estimate_edge_time (edge);\n   hints = estimate_edge_hints (edge);\n+  gcc_checking_assert (edge_time >= 0);\n+  gcc_checking_assert (edge_time <= callee_info->time);\n+  gcc_checking_assert (growth <= callee_info->size);\n \n   if (dump)\n     {\n       fprintf (dump_file, \"    Badness calculation for %s -> %s\\n\",\n \t       xstrdup (cgraph_node_name (edge->caller)),\n \t       xstrdup (cgraph_node_name (callee)));\n-      fprintf (dump_file, \"      size growth %i, time growth %i \",\n+      fprintf (dump_file, \"      size growth %i, time %i \",\n \t       growth,\n-\t       time_growth);\n+\t       edge_time);\n       dump_inline_hints (dump_file, hints);\n       fprintf (dump_file, \"\\n\");\n     }\n@@ -802,19 +851,19 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \n \t        relative_edge_count * relative_time_benefit\n      goodness = -------------------------------------------\n-\t\tedge_growth\n+\t\tgrowth_f_caller\n      badness = -goodness  \n \n     The fraction is upside down, because on edge counts and time beneits\n     the bounds are known. Edge growth is essentially unlimited.  */\n \n   else if (max_count)\n     {\n-      int relbenefit = relative_time_benefit (callee_info, edge, time_growth);\n+      int relbenefit = relative_time_benefit (callee_info, edge, edge_time);\n       badness =\n \t((int)\n-\t ((double) edge->count * INT_MIN / 2 / max_count / 512) *\n-\t relative_time_benefit (callee_info, edge, time_growth)) / growth;\n+\t ((double) edge->count * INT_MIN / 2 / max_count / RELATIVE_TIME_BENEFIT_RANGE) *\n+\t relbenefit) / growth;\n       \n       /* Be sure that insanity of the profile won't lead to increasing counts\n \t in the scalling and thus to overflow in the computation above.  */\n@@ -826,73 +875,53 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t   \" * Relative benefit %f\\n\",\n \t\t   (int) badness, (double) badness / INT_MIN,\n \t\t   (double) edge->count / max_count,\n-\t\t   relbenefit * 100 / 256.0);\n+\t\t   relbenefit * 100.0 / RELATIVE_TIME_BENEFIT_RANGE);\n \t}\n     }\n \n   /* When function local profile is available. Compute badness as:\n-\n      \n-               growth_of_callee\n-     badness = -------------------------------------- + growth_for-all\n-\t       relative_time_benefit * edge_frequency\n+                 relative_time_benefit\n+     goodness =  ---------------------------------\n+\t         growth_of_caller * overall_growth\n \n+     badness = - goodness\n+\n+     compensated by the inline hints.\n   */\n   else if (flag_guess_branch_prob)\n     {\n-      int div = edge->frequency * (1<<10) / CGRAPH_FREQ_MAX;\n-\n-      div = MAX (div, 1);\n-      gcc_checking_assert (edge->frequency <= CGRAPH_FREQ_MAX);\n-      div *= relative_time_benefit (callee_info, edge, time_growth);\n-\n-      /* frequency is normalized in range 1...2^10.\n-         relbenefit in range 1...2^9\n-\t DIV should be in range 1....2^19.  */\n-      gcc_checking_assert (div >= 1 && div <= (1<<19));\n-\n-      /* Result must be integer in range 0...INT_MAX.\n-\t Set the base of fixed point calculation so we don't lose much of\n-\t precision for small bandesses (those are interesting) yet we don't\n-\t overflow for growths that are still in interesting range.\n-\n-\t Fixed point arithmetic with point at 6th bit. */\n-      badness = ((gcov_type)growth) * (1<<(19+6));\n-      badness = (badness + div / 2) / div;\n-\n-      /* Overall growth of inlining all calls of function matters: we want to\n-\t inline so offline copy of function is no longer needed.\n-\n-\t Additionally functions that can be fully inlined without much of\n-\t effort are better inline candidates than functions that can be fully\n-\t inlined only after noticeable overall unit growths. The latter\n-\t are better in a sense compressing of code size by factoring out common\n-\t code into separate function shared by multiple code paths.\n-\n-\t We might mix the valud into the fraction by taking into account\n-\t relative growth of the unit, but for now just add the number\n-\t into resulting fraction.  */\n-      if (badness > INT_MAX / 8)\n-\t{\n-\t  badness = INT_MAX / 8;\n-\t  if (dump)\n-\t    fprintf (dump_file, \"Badness overflow\\n\");\n-\t}\n-      if (hints & (INLINE_HINT_indirect_call\n-\t\t   | INLINE_HINT_loop_iterations\n-\t\t   | INLINE_HINT_loop_stride))\n-\tbadness /= 8;\n+      badness = (relative_time_benefit (callee_info, edge, edge_time)\n+\t\t * (INT_MIN / 16 / RELATIVE_TIME_BENEFIT_RANGE));\n+      badness /= (growth * MAX (1, callee_info->growth));\n+      gcc_checking_assert (badness <=0 && badness >= INT_MIN / 16);\n+      if ((hints & (INLINE_HINT_indirect_call\n+\t\t    | INLINE_HINT_loop_iterations\n+\t\t    | INLINE_HINT_loop_stride))\n+\t  || callee_info->growth <= 0)\n+\tbadness *= 8;\n       if (hints & (INLINE_HINT_same_scc))\n-\tbadness *= 4;\n-      if (hints & (INLINE_HINT_in_scc))\n-\tbadness *= 2;\n+\tbadness /= 16;\n+      else if (hints & (INLINE_HINT_in_scc))\n+\tbadness /= 8;\n+      else if (hints & (INLINE_HINT_cross_module))\n+\tbadness /= 2;\n+      gcc_checking_assert (badness <= 0 && badness >= INT_MIN / 2);\n+      if ((hints & INLINE_HINT_declared_inline) && badness >= INT_MIN / 32)\n+\tbadness *= 16;\n       if (dump)\n \t{\n \t  fprintf (dump_file,\n \t\t   \"      %i: guessed profile. frequency %f,\"\n-\t\t   \" benefit %f%%, divisor %i\\n\",\n+\t\t   \" benefit %f%%, time w/o inlining %i, time w inlining %i\"\n+\t\t   \" overall growth %i (current) %i (original)\\n\",\n \t\t   (int) badness, (double)edge->frequency / CGRAPH_FREQ_BASE,\n-\t\t   relative_time_benefit (callee_info, edge, time_growth) * 100 / 256.0, div);\n+\t\t   relative_time_benefit (callee_info, edge, edge_time) * 100.0\n+\t\t   / RELATIVE_TIME_BENEFIT_RANGE, \n+\t\t   compute_uninlined_call_time (callee_info, edge),\n+\t\t   (int)compute_inlined_call_time (edge, edge_time),\n+\t\t   estimate_growth (callee),\n+\t\t   callee_info->growth);\n \t}\n     }\n   /* When function local profile is not available or it does not give\n@@ -1371,6 +1400,7 @@ inline_small_functions (void)\n \n \t    if (!DECL_EXTERNAL (node->symbol.decl))\n \t      initial_size += info->size;\n+\t    info->growth = estimate_growth (node);\n \t    if (dfs && dfs->next_cycle)\n \t      {\n \t\tstruct cgraph_node *n2;"}, {"sha": "fb055c49c5fbb3138835d6b68af6c3c37d89a99a", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d59171daa764fc59764a7538e48460ffcdae3f9b/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d59171daa764fc59764a7538e48460ffcdae3f9b/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=d59171daa764fc59764a7538e48460ffcdae3f9b", "patch": "@@ -49,7 +49,9 @@ enum inline_hints_vals {\n   INLINE_HINT_loop_iterations = 2,\n   INLINE_HINT_loop_stride = 4,\n   INLINE_HINT_same_scc = 8,\n-  INLINE_HINT_in_scc = 16\n+  INLINE_HINT_in_scc = 16,\n+  INLINE_HINT_declared_inline = 32,\n+  INLINE_HINT_cross_module = 64\n };\n typedef int inline_hints;\n \n@@ -129,6 +131,12 @@ struct GTY(()) inline_summary\n   /* Predicate on when some loop in the function becomes to have known\n      stride.   */\n   struct predicate * GTY((skip)) loop_stride;\n+  /* Estimated growth for inlining all copies of the function before start\n+     of small functions inlining.\n+     This value will get out of date as the callers are duplicated, but\n+     using up-to-date value in the badness metric mean a lot of extra\n+     expenses.  */\n+  int growth;\n   /* Number of SCC on the beggining of inlining process.  */\n   int scc_no;\n };"}]}