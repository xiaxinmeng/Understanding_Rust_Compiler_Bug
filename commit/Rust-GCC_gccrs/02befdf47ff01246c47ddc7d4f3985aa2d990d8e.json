{"sha": "02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJiZWZkZjQ3ZmYwMTI0NmM0N2RkYzdkNGYzOTg1YWEyZDk5MGQ4ZQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-10-25T02:03:40Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-10-25T02:03:40Z"}, "message": "genmodes.c (struct mode_data): Add contained and next_cont fields.\n\n\t* genmodes.c (struct mode_data): Add contained and next_cont\n\tfields.\n\t(complete_mode): Maintain linked list of modes that have a\n\tgiven component.\n\t(emit_mode_unit_size): Delete.\n\t(emit_mode_nunits): New.\n\t(emit_insn_modes_c): Update to match.\n\t(emit_mode_adjustments): Propagate size and alignment\n\tadjustments from component modes to their containers.\n\t* machmode.h (mode_unit_size): Delete.\n\t(mode_nunits): New.\n\t(GET_MODE_NUNITS): Just return the value in the table.\n\t(GET_MODE_UNIT_SIZE): Compute using GET_MODE_INNER and\n\tGET_MODE_SIZE.\n\t* expmed.c (store_bit_field, extract_bit_field): Can use a\n\tplain move instruction if bitsize >= GET_MODE_BITSIZE of\n\tdestination/source mode, respectively.\n\t* varasm.c (assemble_real): Write out the full size of the\n\tconstant, not just its bitsize.\n\t(output_constant): Honor TYPE_MODE of TREE_REAL_CSTs.\n\n\t* config/ia64/ia64-modes.def: Define XFmode as well as TFmode.\n\tUse ADJUST_BYTESIZE and ADJUST_ALIGNMENT to set size and\n\talignment of XF and TF modes in compliance with ia64 ABIs.\n\tCan now hardwire the format of both modes.\n\t* config/ia64/ia64.c: Change TFmode to XFmode wherever appropriate.\n\t(general_tfmode_operand, destination_tfmode_operand)\n\t(tfreg_or_fp01_operand, spill_tfmode_operand): Rename to\n\tgeneral_xfmode_operand, destination_xfmode_operand,\n\txfreg_or_fp01_operand, spill_xfmode_operand respectively.\n\t(ia64_init_builtins): Make TYPE_PRECISION of fpreg_type\n\tand float80_type be 96 so they get XFmode.  Use !TARGET_HPUX,\n\tnot INTEL_EXTENDED_IEEE_FORMAT, to decide how to define\n\t__float128.\n\t* config/ia64/ia64.h: Default TARGET_HPUX to 0.\n\tChange TFmode to XFmode wherever appropriate.  Remove all\n\treferences to INTEL_EXTENDED_IEEE_FORMAT.\n\t(LONG_DOUBLE_TYPE_SIZE): Varies with TARGET_HPUX.\n\t(LIBGCC2_LONG_DOUBLE_TYPE_SIZE): Define (always 96).\n\t(PREDICATE_CODES): Update to match function renames.\n\t* config/ia64/ia64.md: Change TF to XF throughout; rename all\n\tpatterns to match.  Remove all references to\n\tINTEL_EXTENDED_IEEE_FORMAT.  Update predicate calls to match\n\tfunction renames.\n\t* config/ia64/ia64-protos.c: Update all prototypes to match\n\trenamed functions.\n\t* config/ia64/hpux.h: Redefine TARGET_HPUX to 1.\n\tRemove all references to INTEL_EXTENDED_IEEE_FORMAT.\n\t* config/ia64/lib1funcs.asm: Add __divxf3 as new name for\n\t__divtf3; keep old name for backward compatibility.\n\t(L__compat): New section providing forwarding stubs for\n\t__fixtfti, __fixunstfti, __floattitf.\n\t* config/ia64/t-ia64: Add __compat to LIB1ASMFUNCS.\n\nFrom-SVN: r72916", "tree": {"sha": "924272e8a87e09c7f5bd7aa5ee638d29f45b3b8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/924272e8a87e09c7f5bd7aa5ee638d29f45b3b8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/comments", "author": null, "committer": null, "parents": [{"sha": "569827c9b6b729159228cd3959c6a26ac6e391ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/569827c9b6b729159228cd3959c6a26ac6e391ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/569827c9b6b729159228cd3959c6a26ac6e391ed"}], "stats": {"total": 1353, "additions": 769, "deletions": 584}, "files": [{"sha": "71ce60db2d5855296ad40c4bd73c3077de85f8d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "patch": "@@ -1,3 +1,59 @@\n+2003-10-24  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* genmodes.c (struct mode_data): Add contained and next_cont\n+\tfields.\n+\t(complete_mode): Maintain linked list of modes that have a\n+\tgiven component.\n+\t(emit_mode_unit_size): Delete.\n+\t(emit_mode_nunits): New.\n+\t(emit_insn_modes_c): Update to match.\n+\t(emit_mode_adjustments): Propagate size and alignment\n+\tadjustments from component modes to their containers.\n+\t* machmode.h (mode_unit_size): Delete.\n+\t(mode_nunits): New.\n+\t(GET_MODE_NUNITS): Just return the value in the table.\n+\t(GET_MODE_UNIT_SIZE): Compute using GET_MODE_INNER and\n+\tGET_MODE_SIZE.\n+\t* expmed.c (store_bit_field, extract_bit_field): Can use a\n+\tplain move instruction if bitsize >= GET_MODE_BITSIZE of\n+\tdestination/source mode, respectively.\n+\t* varasm.c (assemble_real): Write out the full size of the\n+\tconstant, not just its bitsize.\n+\t(output_constant): Honor TYPE_MODE of TREE_REAL_CSTs.\n+\n+\t* config/ia64/ia64-modes.def: Define XFmode as well as TFmode.\n+\tUse ADJUST_BYTESIZE and ADJUST_ALIGNMENT to set size and\n+\talignment of XF and TF modes in compliance with ia64 ABIs.\n+\tCan now hardwire the format of both modes.\n+\t* config/ia64/ia64.c: Change TFmode to XFmode wherever appropriate.\n+\t(general_tfmode_operand, destination_tfmode_operand)\n+\t(tfreg_or_fp01_operand, spill_tfmode_operand): Rename to\n+\tgeneral_xfmode_operand, destination_xfmode_operand,\n+\txfreg_or_fp01_operand, spill_xfmode_operand respectively.\n+\t(ia64_init_builtins): Make TYPE_PRECISION of fpreg_type\n+\tand float80_type be 96 so they get XFmode.  Use !TARGET_HPUX,\n+\tnot INTEL_EXTENDED_IEEE_FORMAT, to decide how to define\n+\t__float128.\n+\t* config/ia64/ia64.h: Default TARGET_HPUX to 0.\n+\tChange TFmode to XFmode wherever appropriate.  Remove all\n+\treferences to INTEL_EXTENDED_IEEE_FORMAT.\n+\t(LONG_DOUBLE_TYPE_SIZE): Varies with TARGET_HPUX.\n+\t(LIBGCC2_LONG_DOUBLE_TYPE_SIZE): Define (always 96).\n+\t(PREDICATE_CODES): Update to match function renames.\n+\t* config/ia64/ia64.md: Change TF to XF throughout; rename all\n+\tpatterns to match.  Remove all references to\n+\tINTEL_EXTENDED_IEEE_FORMAT.  Update predicate calls to match\n+\tfunction renames.\n+\t* config/ia64/ia64-protos.c: Update all prototypes to match\n+\trenamed functions.\n+\t* config/ia64/hpux.h: Redefine TARGET_HPUX to 1.\n+\tRemove all references to INTEL_EXTENDED_IEEE_FORMAT.\n+\t* config/ia64/lib1funcs.asm: Add __divxf3 as new name for\n+\t__divtf3; keep old name for backward compatibility.\n+\t(L__compat): New section providing forwarding stubs for\n+\t__fixtfti, __fixunstfti, __floattitf.\n+\t* config/ia64/t-ia64: Add __compat to LIB1ASMFUNCS.\n+\n 2003-10-24  Geoffrey Keating  <geoffk@apple.com>\n \n \tPR 10757\n@@ -29,7 +85,7 @@\n \t($(docobjdir)/%.1): Depend on .pod instead of .texi.\n \t($(docobjdir)/%.7): Likewise.\n \t(%.pod): New implicit rule.\n-\t(cpp.pod): New dependency only rule.\t\n+\t(cpp.pod): New dependency only rule.\n \t(gcc.pod): New intermediate rule with dependencies and commands.\n \t(gfdl.pod): Likewise.\n \t(fsf-funding.pod): Likewise."}, {"sha": "382751a7c37d04ee15f186bd7fa622d8a4c99a80", "filename": "gcc/config/ia64/hpux.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Fhpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Fhpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fhpux.h?ref=02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "patch": "@@ -25,6 +25,10 @@ Boston, MA 02111-1307, USA.  */\n \n #define TARGET_VERSION fprintf (stderr, \" (IA-64) HP-UX\");\n \n+/* Enable HPUX ABI quirks.  */\n+#undef  TARGET_HPUX\n+#define TARGET_HPUX 1\n+\n /* Target OS builtins.  */\n #define TARGET_OS_CPP_BUILTINS()\t\t\t\\\n do {\t\t\t\t\t\t\t\\\n@@ -106,7 +110,8 @@ do {\t\t\t\t\t\t\t\\\n    returned just like a char variable and that is wrong on HP-UX\n    IA64.  */\n \n-#define MEMBER_TYPE_FORCES_BLK(FIELD, MODE) (TREE_CODE (TREE_TYPE (FIELD)) != REAL_TYPE || (MODE == TFmode && !INTEL_EXTENDED_IEEE_FORMAT))\n+#define MEMBER_TYPE_FORCES_BLK(FIELD, MODE) \\\n+  (TREE_CODE (TREE_TYPE (FIELD)) != REAL_TYPE || MODE == TFmode)\n \n /* ASM_OUTPUT_EXTERNAL_LIBCALL defaults to just a globalize_label call,\n    but that doesn't put out the @function type information which causes\n@@ -187,10 +192,6 @@ do {\t\t\t\t\t\t\t\t\\\n #undef TARGET_C99_FUNCTIONS\n #define TARGET_C99_FUNCTIONS  1\n \n-/* We are using IEEE quad precision, not a double-extended with padding.  */\n-#undef INTEL_EXTENDED_IEEE_FORMAT\n-#define INTEL_EXTENDED_IEEE_FORMAT 0\n-\n #define TARGET_INIT_LIBFUNCS ia64_hpux_init_libfuncs\n \n #define FLOAT_LIB_COMPARE_RETURNS_BOOL(MODE, COMPARISON) ((MODE) == TFmode)"}, {"sha": "17688bd9b85d839cf8d987c9e64b5bf03b594e1b", "filename": "gcc/config/ia64/ia64-modes.def", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Fia64-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Fia64-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-modes.def?ref=02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine GNU compiler.  IA-64 version.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n    Contributed by James E. Wilson <wilson@cygnus.com> and\n    \t\t  David Mosberger <davidm@hpl.hp.com>.\n \n@@ -20,8 +20,41 @@ along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* hpux will override this in ia64_override_options.  */\n-FLOAT_MODE (TF, 16, ieee_extended_intel_128_format);\n+/* IA64 requires both XF and TF modes.\n+   XFmode is __float80 is IEEE extended; TFmode is __float128\n+   is IEEE quad.\n+\n+   IEEE extended is 128 bits wide, except in ILP32 mode, but we\n+   have to say it's 12 bytes so that the bitsize and wider_mode\n+   tables are correctly set up.  We correct its size below.  */\n+\n+FLOAT_MODE (XF, 12, ieee_extended_intel_128_format);\n+FLOAT_MODE (TF, 16, ieee_quad_format);\n+\n+/* The above produces:\n+\n+   mode\t  ILP32 size/align\tLP64 size/align\n+   XF\t  12/4\t\t\t12/4\n+   TF\t  16/16\t\t\t16/16\n+\n+   psABI expectations:\n+\n+   mode   ILP32 size/align\tLP64 size/align\n+   XF\t  -\t\t\t16/16\n+   TF\t  -\t\t\t-\n+\n+   HPUX expectations:\n+\n+   mode\t  ILP32 size/align\tLP64 size/align\n+   XF\t  16/16\t\t\t16/16\n+   TF\t  16/8\t\t\t-\n+\n+   We fix this up here.  */\n+\n+ADJUST_BYTESIZE  (XF, (TARGET_ILP32 && !TARGET_HPUX) ? 12 : 16);\n+ADJUST_ALIGNMENT (XF, (TARGET_ILP32 && !TARGET_HPUX) ?  4 : 16);\n+\n+ADJUST_ALIGNMENT (TF, (TARGET_ILP32 &&  TARGET_HPUX) ?  8 : 16);\n \n /* 256-bit integer mode is needed for STACK_SAVEAREA_MODE.  */\n INT_MODE (OI, 32);"}, {"sha": "01d6115a0a699c636d95355bf0c893344767fe1b", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "patch": "@@ -70,9 +70,9 @@ extern int predicate_operator (rtx, enum machine_mode);\n extern int ar_lc_reg_operand (rtx, enum machine_mode);\n extern int ar_ccv_reg_operand (rtx, enum machine_mode);\n extern int ar_pfs_reg_operand (rtx, enum machine_mode);\n-extern int general_tfmode_operand (rtx, enum machine_mode);\n-extern int destination_tfmode_operand (rtx, enum machine_mode);\n-extern int tfreg_or_fp01_operand (rtx, enum machine_mode);\n+extern int general_xfmode_operand (rtx, enum machine_mode);\n+extern int destination_xfmode_operand (rtx, enum machine_mode);\n+extern int xfreg_or_fp01_operand (rtx, enum machine_mode);\n extern int basereg_operand (rtx, enum machine_mode);\n \n extern rtx ia64_expand_move (rtx, rtx);\n@@ -81,7 +81,7 @@ extern int addp4_optimize_ok (rtx, rtx);\n extern void ia64_emit_cond_move (rtx, rtx, rtx);\n extern int ia64_depz_field_mask (rtx, rtx);\n extern rtx ia64_split_timode (rtx[], rtx, rtx);\n-extern rtx spill_tfmode_operand (rtx, int);\n+extern rtx spill_xfmode_operand (rtx, int);\n extern rtx ia64_expand_compare (enum rtx_code, enum machine_mode);\n extern void ia64_expand_call (rtx, rtx, rtx, int);\n extern void ia64_split_call (rtx, rtx, rtx, rtx, rtx, int, int);"}, {"sha": "7b0069d7fb04de8cee0204d7165bf248f2d30c5c", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 27, "deletions": 37, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "patch": "@@ -923,7 +923,7 @@ ar_pfs_reg_operand (register rtx op, enum machine_mode mode)\n /* Like general_operand, but don't allow (mem (addressof)).  */\n \n int\n-general_tfmode_operand (rtx op, enum machine_mode mode)\n+general_xfmode_operand (rtx op, enum machine_mode mode)\n {\n   if (! general_operand (op, mode))\n     return 0;\n@@ -935,7 +935,7 @@ general_tfmode_operand (rtx op, enum machine_mode mode)\n /* Similarly.  */\n \n int\n-destination_tfmode_operand (rtx op, enum machine_mode mode)\n+destination_xfmode_operand (rtx op, enum machine_mode mode)\n {\n   if (! destination_operand (op, mode))\n     return 0;\n@@ -947,7 +947,7 @@ destination_tfmode_operand (rtx op, enum machine_mode mode)\n /* Similarly.  */\n \n int\n-tfreg_or_fp01_operand (rtx op, enum machine_mode mode)\n+xfreg_or_fp01_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == SUBREG)\n     return 0;\n@@ -1430,34 +1430,34 @@ ia64_split_timode (rtx out[2], rtx in, rtx scratch)\n     }\n }\n \n-/* ??? Fixing GR->FR TFmode moves during reload is hard.  You need to go\n+/* ??? Fixing GR->FR XFmode moves during reload is hard.  You need to go\n    through memory plus an extra GR scratch register.  Except that you can\n    either get the first from SECONDARY_MEMORY_NEEDED or the second from\n    SECONDARY_RELOAD_CLASS, but not both.\n \n    We got into problems in the first place by allowing a construct like\n-   (subreg:TF (reg:TI)), which we got from a union containing a long double.\n+   (subreg:XF (reg:TI)), which we got from a union containing a long double.\n    This solution attempts to prevent this situation from occurring.  When\n    we see something like the above, we spill the inner register to memory.  */\n \n rtx\n-spill_tfmode_operand (rtx in, int force)\n+spill_xfmode_operand (rtx in, int force)\n {\n   if (GET_CODE (in) == SUBREG\n       && GET_MODE (SUBREG_REG (in)) == TImode\n       && GET_CODE (SUBREG_REG (in)) == REG)\n     {\n       rtx mem = gen_mem_addressof (SUBREG_REG (in), NULL_TREE, /*rescan=*/true);\n-      return gen_rtx_MEM (TFmode, copy_to_reg (XEXP (mem, 0)));\n+      return gen_rtx_MEM (XFmode, copy_to_reg (XEXP (mem, 0)));\n     }\n   else if (force && GET_CODE (in) == REG)\n     {\n       rtx mem = gen_mem_addressof (in, NULL_TREE, /*rescan=*/true);\n-      return gen_rtx_MEM (TFmode, copy_to_reg (XEXP (mem, 0)));\n+      return gen_rtx_MEM (XFmode, copy_to_reg (XEXP (mem, 0)));\n     }\n   else if (GET_CODE (in) == MEM\n \t   && GET_CODE (XEXP (in, 0)) == ADDRESSOF)\n-    return change_address (in, TFmode, copy_to_reg (XEXP (in, 0)));\n+    return change_address (in, XFmode, copy_to_reg (XEXP (in, 0)));\n   else\n     return in;\n }\n@@ -2679,7 +2679,7 @@ ia64_expand_prologue (void)\n       {\n         if (cfa_off & 15)\n \t  abort ();\n-\treg = gen_rtx_REG (TFmode, regno);\n+\treg = gen_rtx_REG (XFmode, regno);\n \tdo_spill (gen_fr_spill_x, reg, cfa_off, reg);\n \tcfa_off -= 16;\n       }\n@@ -2849,7 +2849,7 @@ ia64_expand_epilogue (int sibcall_p)\n       {\n         if (cfa_off & 15)\n \t  abort ();\n-\treg = gen_rtx_REG (TFmode, regno);\n+\treg = gen_rtx_REG (XFmode, regno);\n \tdo_restore (gen_fr_restore_x, reg, cfa_off);\n \tcfa_off -= 16;\n       }\n@@ -3305,16 +3305,15 @@ hfa_element_mode (tree type, int nested)\n \t types though.  */\n     case COMPLEX_TYPE:\n       if (GET_MODE_CLASS (TYPE_MODE (type)) == MODE_COMPLEX_FLOAT\n-\t  && (TYPE_MODE (type) != TCmode || INTEL_EXTENDED_IEEE_FORMAT))\n-\treturn mode_for_size (GET_MODE_UNIT_SIZE (TYPE_MODE (type))\n-\t\t\t      * BITS_PER_UNIT, MODE_FLOAT, 0);\n+\t  && TYPE_MODE (type) != TCmode)\n+\treturn GET_MODE_INNER (TYPE_MODE (type));\n       else\n \treturn VOIDmode;\n \n     case REAL_TYPE:\n       /* We want to return VOIDmode for raw REAL_TYPEs, but the actual\n \t mode if this is contained within an aggregate.  */\n-      if (nested && (TYPE_MODE (type) != TFmode || INTEL_EXTENDED_IEEE_FORMAT))\n+      if (nested && TYPE_MODE (type) != TFmode)\n \treturn TYPE_MODE (type);\n       else\n \treturn VOIDmode;\n@@ -3482,8 +3481,8 @@ ia64_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n   /* Integral and aggregates go in general registers.  If we have run out of\n      FR registers, then FP values must also go in general registers.  This can\n      happen when we have a SFmode HFA.  */\n-  else if (((mode == TFmode) && ! INTEL_EXTENDED_IEEE_FORMAT)\n-          || (! FLOAT_MODE_P (mode) || cum->fp_regs == MAX_ARGUMENT_SLOTS))\n+  else if (mode == TFmode || mode == TCmode\n+\t   || (! FLOAT_MODE_P (mode) || cum->fp_regs == MAX_ARGUMENT_SLOTS))\n     {\n       int byte_size = ((mode == BLKmode)\n                        ? int_size_in_bytes (type) : GET_MODE_SIZE (mode));\n@@ -3784,8 +3783,7 @@ ia64_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n       else\n \treturn gen_rtx_PARALLEL (mode, gen_rtvec_v (i, loc));\n     }\n-  else if (FLOAT_TYPE_P (valtype) &&\n-           ((mode != TFmode) || INTEL_EXTENDED_IEEE_FORMAT))\n+  else if (FLOAT_TYPE_P (valtype) && mode != TFmode)\n     return gen_rtx_REG (mode, FR_ARG_FIRST);\n   else\n     {\n@@ -4188,11 +4186,11 @@ ia64_register_move_cost (enum machine_mode mode, enum reg_class from,\n       to = from, from = tmp;\n     }\n \n-  /* Moving from FR<->GR in TFmode must be more expensive than 2,\n+  /* Moving from FR<->GR in XFmode must be more expensive than 2,\n      so that we get secondary memory reloads.  Between FR_REGS,\n      we have to make this at least as expensive as MEMORY_MOVE_COST\n      to avoid spectacularly poor register class preferencing.  */\n-  if (mode == TFmode)\n+  if (mode == XFmode)\n     {\n       if (to != GR_REGS || from != GR_REGS)\n         return MEMORY_MOVE_COST (mode, to, 0);\n@@ -4521,10 +4519,6 @@ ia64_override_options (void)\n   ia64_section_threshold = g_switch_set ? g_switch_value : IA64_DEFAULT_GVALUE;\n \n   init_machine_status = ia64_init_machine_status;\n-\n-  /* Tell the compiler which flavor of TFmode we're using.  */\n-  if (!INTEL_EXTENDED_IEEE_FORMAT)\n-    REAL_MODE_FORMAT (TFmode) = &ieee_quad_format;\n }\n \f\n static enum attr_itanium_class ia64_safe_itanium_class (rtx);\n@@ -7717,34 +7711,28 @@ ia64_init_builtins (void)\n \n   /* The __fpreg type.  */\n   fpreg_type = make_node (REAL_TYPE);\n-  /* ??? Once the IA64 back end supports both 80-bit and 128-bit\n-     floating types, this type should have XFmode, not TFmode.\n-     TYPE_PRECISION should be 80 bits, not 128.  And, the back end\n-     should know to load/save __fpreg variables using the ldf.fill and\n-     stf.spill instructions.  */\n-  TYPE_PRECISION (fpreg_type) = 128;\n+  /* ??? The back end should know to load/save __fpreg variables using\n+     the ldf.fill and stf.spill instructions.  */\n+  TYPE_PRECISION (fpreg_type) = 96;\n   layout_type (fpreg_type);\n   (*lang_hooks.types.register_builtin_type) (fpreg_type, \"__fpreg\");\n \n   /* The __float80 type.  */\n   float80_type = make_node (REAL_TYPE);\n-  /* ??? Once the IA64 back end supports both 80-bit and 128-bit\n-     floating types, this type should have XFmode, not TFmode.\n-     TYPE_PRECISION should be 80 bits, not 128.  */\n-  TYPE_PRECISION (float80_type) = 128;\n+  TYPE_PRECISION (float80_type) = 96;\n   layout_type (float80_type);\n   (*lang_hooks.types.register_builtin_type) (float80_type, \"__float80\");\n \n   /* The __float128 type.  */\n-  if (INTEL_EXTENDED_IEEE_FORMAT)\n+  if (!TARGET_HPUX)\n     {\n       tree float128_type = make_node (REAL_TYPE);\n       TYPE_PRECISION (float128_type) = 128;\n       layout_type (float128_type);\n       (*lang_hooks.types.register_builtin_type) (float128_type, \"__float128\");\n     }\n   else\n-    /* This is a synonym for \"long double\".  */\n+    /* Under HPUX, this is a synonym for \"long double\".  */\n     (*lang_hooks.types.register_builtin_type) (long_double_type_node,\n \t\t\t\t\t       \"__float128\");\n \n@@ -8345,8 +8333,10 @@ ia64_hpux_init_libfuncs (void)\n \n   set_conv_libfunc (sext_optab,   TFmode, SFmode, \"_U_Qfcnvff_sgl_to_quad\");\n   set_conv_libfunc (sext_optab,   TFmode, DFmode, \"_U_Qfcnvff_dbl_to_quad\");\n+  set_conv_libfunc (sext_optab,   TFmode, XFmode, \"_U_Qfcnvff_f80_to_quad\");\n   set_conv_libfunc (trunc_optab,  SFmode, TFmode, \"_U_Qfcnvff_quad_to_sgl\");\n   set_conv_libfunc (trunc_optab,  DFmode, TFmode, \"_U_Qfcnvff_quad_to_dbl\");\n+  set_conv_libfunc (trunc_optab,  XFmode, TFmode, \"_U_Qfcnvff_quad_to_f80\");\n \n   set_conv_libfunc (sfix_optab,   SImode, TFmode, \"_U_Qfcnvfxt_quad_to_sgl\");\n   set_conv_libfunc (sfix_optab,   DImode, TFmode, \"_U_Qfcnvfxt_quad_to_dbl\");"}, {"sha": "8ccda53bd9bf1333ba842c3bf6a7c205c899ad11", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "patch": "@@ -135,6 +135,7 @@ extern int ia64_tls_size;\n #define TARGET_TLS64\t\t(ia64_tls_size == 64)\n #define TARGET_EARLY_STOP_BITS\t(target_flags & MASK_EARLY_STOP_BITS)\n \n+#define TARGET_HPUX\t\t0\n #define TARGET_HPUX_LD\t\t0\n \n #ifndef HAVE_AS_LTOFFX_LDXMOV_RELOCS\n@@ -417,11 +418,11 @@ while (0)\n \n #define DOUBLE_TYPE_SIZE 64\n \n-#define LONG_DOUBLE_TYPE_SIZE 128\n+/* long double is XFmode normally, TFmode for HPUX.  */\n+#define LONG_DOUBLE_TYPE_SIZE (TARGET_HPUX ? 128 : 96)\n \n-/* By default we use the 80-bit Intel extended float format packaged\n-   in a 128-bit entity.  */\n-#define INTEL_EXTENDED_IEEE_FORMAT 1\n+/* We always want the XFmode operations from libgcc2.c.  */\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 96\n \n #define DEFAULT_SIGNED_CHAR 1\n \n@@ -779,7 +780,7 @@ while (0)\n   ((REGNO) == PR_REG (0) && (MODE) == DImode ? 64\t\t\t\\\n    : PR_REGNO_P (REGNO) && (MODE) == BImode ? 2\t\t\t\t\\\n    : PR_REGNO_P (REGNO) && (MODE) == CCImode ? 1\t\t\t\\\n-   : FR_REGNO_P (REGNO) && (MODE) == TFmode && INTEL_EXTENDED_IEEE_FORMAT ? 1 \\\n+   : FR_REGNO_P (REGNO) && (MODE) == XFmode ? 1\t\t\t\t\\\n    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* A C expression that is nonzero if it is permissible to store a value of mode\n@@ -791,10 +792,10 @@ while (0)\n      GET_MODE_CLASS (MODE) != MODE_CC &&\t\t\t\\\n      (MODE) != TImode &&\t\t\t\t\t\\\n      (MODE) != BImode &&\t\t\t\t\t\\\n-     ((MODE) != TFmode || INTEL_EXTENDED_IEEE_FORMAT) \t\t\\\n+     (MODE) != TFmode \t\t\t\t\t\t\\\n    : PR_REGNO_P (REGNO) ?\t\t\t\t\t\\\n      (MODE) == BImode || GET_MODE_CLASS (MODE) == MODE_CC\t\\\n-   : GR_REGNO_P (REGNO) ? (MODE) != CCImode && (MODE) != TFmode\t\\\n+   : GR_REGNO_P (REGNO) ? (MODE) != CCImode && (MODE) != XFmode\t\\\n    : AR_REGNO_P (REGNO) ? (MODE) == DImode\t\t\t\\\n    : BR_REGNO_P (REGNO) ? (MODE) == DImode\t\t\t\\\n    : 0)\n@@ -807,11 +808,11 @@ while (0)\n    ever different for any R, then `MODES_TIEABLE_P (MODE1, MODE2)' must be\n    zero.  */\n /* Don't tie integer and FP modes, as that causes us to get integer registers\n-   allocated for FP instructions.  TFmode only supported in FP registers so\n+   allocated for FP instructions.  XFmode only supported in FP registers so\n    we can't tie it with any other modes.  */\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n   (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2)\t\\\n-   && (((MODE1) == TFmode) == ((MODE2) == TFmode))\t\\\n+   && (((MODE1) == XFmode) == ((MODE2) == XFmode))\t\\\n    && (((MODE1) == BImode) == ((MODE2) == BImode)))\n \f\n /* Handling Leaf Functions */\n@@ -1011,12 +1012,12 @@ enum reg_class\n    into a register of CLASS2.  */\n \n #if 0\n-/* ??? May need this, but since we've disallowed TFmode in GR_REGS,\n+/* ??? May need this, but since we've disallowed XFmode in GR_REGS,\n    I'm not quite sure how it could be invoked.  The normal problems\n    with unions should be solved with the addressof fiddling done by\n-   movtf and friends.  */\n+   movxf and friends.  */\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)\t\t\t\\\n-  ((MODE) == TFmode && (((CLASS1) == GR_REGS && (CLASS2) == FR_REGS)\t\\\n+  ((MODE) == XFmode && (((CLASS1) == GR_REGS && (CLASS2) == FR_REGS)\t\\\n \t\t\t|| ((CLASS1) == FR_REGS && (CLASS2) == GR_REGS)))\n #endif\n \n@@ -1026,7 +1027,7 @@ enum reg_class\n \n #define CLASS_MAX_NREGS(CLASS, MODE) \\\n   ((MODE) == BImode && (CLASS) == PR_REGS ? 2\t\t\t\\\n-   : ((CLASS) == FR_REGS && (MODE) == TFmode) ? 1\t\t\\\n+   : ((CLASS) == FR_REGS && (MODE) == XFmode) ? 1\t\t\\\n    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* In FP regs, we can't change FP values to integer values and vice\n@@ -1389,7 +1390,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   gen_rtx_REG (MODE,\t\t\t\t\t\t\t\\\n \t       (((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n \t\t || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT) &&\t\\\n-\t\t      ((MODE) != TFmode || INTEL_EXTENDED_IEEE_FORMAT))\t\\\n+\t\t      (MODE) != TFmode)\t\\\n \t\t? FR_RET_FIRST : GR_RET_FIRST))\n \n /* A C expression that is nonzero if REGNO is the number of a hard register in\n@@ -2214,9 +2215,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n { \"ar_lc_reg_operand\", {REG}},\t\t\t\t\t\t\\\n { \"ar_ccv_reg_operand\", {REG}},\t\t\t\t\t\t\\\n { \"ar_pfs_reg_operand\", {REG}},\t\t\t\t\t\t\\\n-{ \"general_tfmode_operand\", {SUBREG, REG, CONST_DOUBLE, MEM}},\t\t\\\n-{ \"destination_tfmode_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n-{ \"tfreg_or_fp01_operand\", {REG, CONST_DOUBLE}},\t\t\t\\\n+{ \"general_xfmode_operand\", {SUBREG, REG, CONST_DOUBLE, MEM}},\t\t\\\n+{ \"destination_xfmode_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n+{ \"xfreg_or_fp01_operand\", {REG, CONST_DOUBLE}},\t\t\t\\\n { \"basereg_operand\", {SUBREG, REG}},\n \n /* An alias for a machine mode name.  This is the machine mode that elements of"}, {"sha": "547b7979862aa1f4bc9967ad8268ad3b959694dd", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 452, "deletions": 469, "changes": 921, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "patch": "@@ -756,19 +756,19 @@\n \n ;; With no offsettable memory references, we've got to have a scratch\n ;; around to play with the second word if the variable winds up in GRs.\n-(define_expand \"movtf\"\n-  [(set (match_operand:TF 0 \"general_operand\" \"\")\n-\t(match_operand:TF 1 \"general_operand\" \"\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_expand \"movxf\"\n+  [(set (match_operand:XF 0 \"general_operand\" \"\")\n+\t(match_operand:XF 1 \"general_operand\" \"\"))]\n+  \"\"\n {\n-  /* We must support TFmode loads into general registers for stdarg/vararg\n+  /* We must support XFmode loads into general registers for stdarg/vararg\n      and unprototyped calls.  We split them into DImode loads for convenience.\n-     We don't need TFmode stores from general regs, because a stdarg/vararg\n+     We don't need XFmode stores from general regs, because a stdarg/vararg\n      routine does a block store to memory of unnamed arguments.  */\n   if (GET_CODE (operands[0]) == REG\n       && GR_REGNO_P (REGNO (operands[0])))\n     {\n-      /* We're hoping to transform everything that deals with TFmode\n+      /* We're hoping to transform everything that deals with XFmode\n \t quantities and GR registers early in the compiler.  */\n       if (no_new_pseudos)\n \tabort ();\n@@ -787,15 +787,15 @@\n       if (GET_CODE (operands[1]) == CONST_DOUBLE)\n \t{\n \t  emit_move_insn (gen_rtx_REG (DImode, REGNO (operands[0])),\n-\t\t\t  operand_subword (operands[1], 0, 0, TFmode));\n+\t\t\t  operand_subword (operands[1], 0, 0, XFmode));\n \t  emit_move_insn (gen_rtx_REG (DImode, REGNO (operands[0]) + 1),\n-\t\t\t  operand_subword (operands[1], 1, 0, TFmode));\n+\t\t\t  operand_subword (operands[1], 1, 0, XFmode));\n \t  DONE;\n \t}\n \n       /* If the quantity is in a register not known to be GR, spill it.  */\n-      if (register_operand (operands[1], TFmode))\n-\toperands[1] = spill_tfmode_operand (operands[1], 1);\n+      if (register_operand (operands[1], XFmode))\n+\toperands[1] = spill_xfmode_operand (operands[1], 1);\n \n       if (GET_CODE (operands[1]) == MEM)\n \t{\n@@ -814,20 +814,20 @@\n \n   if (! reload_in_progress && ! reload_completed)\n     {\n-      operands[0] = spill_tfmode_operand (operands[0], 0);\n-      operands[1] = spill_tfmode_operand (operands[1], 0);\n+      operands[0] = spill_xfmode_operand (operands[0], 0);\n+      operands[1] = spill_xfmode_operand (operands[1], 0);\n \n       if (! ia64_move_ok (operands[0], operands[1]))\n-\toperands[1] = force_reg (TFmode, operands[1]);\n+\toperands[1] = force_reg (XFmode, operands[1]);\n     }\n })\n \n ;; ??? There's no easy way to mind volatile acquire/release semantics.\n \n-(define_insn \"*movtf_internal\"\n-  [(set (match_operand:TF 0 \"destination_tfmode_operand\" \"=f,f, m\")\n-\t(match_operand:TF 1 \"general_tfmode_operand\"     \"fG,m,fG\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && ia64_move_ok (operands[0], operands[1])\"\n+(define_insn \"*movxf_internal\"\n+  [(set (match_operand:XF 0 \"destination_xfmode_operand\" \"=f,f, m\")\n+\t(match_operand:XF 1 \"general_xfmode_operand\"     \"fG,m,fG\"))]\n+  \"ia64_move_ok (operands[0], operands[1])\"\n   \"@\n    mov %0 = %F1\n    ldfe %0 = %1%P1\n@@ -919,17 +919,17 @@\n   \"fnorm.d %0 = %1\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"extendsftf2\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(float_extend:TF (match_operand:SF 1 \"fr_register_operand\" \"f\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"extendsfxf2\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(float_extend:XF (match_operand:SF 1 \"fr_register_operand\" \"f\")))]\n+  \"\"\n   \"fnorm %0 = %1\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"extenddftf2\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(float_extend:TF (match_operand:DF 1 \"fr_register_operand\" \"f\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"extenddfxf2\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(float_extend:XF (match_operand:DF 1 \"fr_register_operand\" \"f\")))]\n+  \"\"\n   \"fnorm %0 = %1\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n@@ -940,45 +940,29 @@\n   \"fnorm.s %0 = %1\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"trunctfsf2\"\n+(define_insn \"truncxfsf2\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n-\t(float_truncate:SF (match_operand:TF 1 \"fr_register_operand\" \"f\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t(float_truncate:SF (match_operand:XF 1 \"fr_register_operand\" \"f\")))]\n+  \"\"\n   \"fnorm.s %0 = %1\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"trunctfdf2\"\n+(define_insn \"truncxfdf2\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n-\t(float_truncate:DF (match_operand:TF 1 \"fr_register_operand\" \"f\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t(float_truncate:DF (match_operand:XF 1 \"fr_register_operand\" \"f\")))]\n+  \"\"\n   \"fnorm.d %0 = %1\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n ;; Convert between signed integer types and floating point.\n \n-(define_insn \"floatditf2\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(float:TF (match_operand:DI 1 \"fr_register_operand\" \"f\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"floatdixf2\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(float:XF (match_operand:DI 1 \"fr_register_operand\" \"f\")))]\n+  \"\"\n   \"fcvt.xf %0 = %1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n-;; ??? Suboptimal.  This should be split somehow.\n-(define_insn \"floatdidf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-        (float:DF (match_operand:DI 1 \"register_operand\" \"f\")))]\n-  \"!INTEL_EXTENDED_IEEE_FORMAT\"\n-  \"fcvt.xf %0 = %1\\;;;\\;%,fnorm.d %0 = %0\"\n-  [(set_attr \"itanium_class\" \"fcvtfx\")])\n-\n-;; ??? Suboptimal.  This should be split somehow.\n-(define_insn \"floatdisf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-        (float:SF (match_operand:DI 1 \"register_operand\" \"f\")))]\n-  \"!INTEL_EXTENDED_IEEE_FORMAT\"\n-  \"fcvt.xf %0 = %1\\;;;\\;%,fnorm.s %0 = %0\"\n-  [(set_attr \"itanium_class\" \"fcvtfx\")])\n-\n (define_insn \"fix_truncsfdi2\"\n   [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n \t(fix:DI (match_operand:SF 1 \"fr_register_operand\" \"f\")))]\n@@ -993,18 +977,18 @@\n   \"fcvt.fx.trunc %0 = %1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n-(define_insn \"fix_trunctfdi2\"\n+(define_insn \"fix_truncxfdi2\"\n   [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n-\t(fix:DI (match_operand:TF 1 \"fr_register_operand\" \"f\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t(fix:DI (match_operand:XF 1 \"fr_register_operand\" \"f\")))]\n+  \"\"\n   \"fcvt.fx.trunc %0 = %1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n-(define_insn \"fix_trunctfdi2_alts\"\n+(define_insn \"fix_truncxfdi2_alts\"\n   [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n-\t(fix:DI (match_operand:TF 1 \"fr_register_operand\" \"f\")))\n+\t(fix:DI (match_operand:XF 1 \"fr_register_operand\" \"f\")))\n    (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+  \"\"\n   \"fcvt.fx.trunc.s%2 %0 = %1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n@@ -1024,10 +1008,10 @@\n   \"fcvt.xuf.d %0 = %1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n-(define_insn \"floatunsditf2\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(unsigned_float:TF (match_operand:DI 1 \"fr_register_operand\" \"f\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"floatunsdixf2\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(unsigned_float:XF (match_operand:DI 1 \"fr_register_operand\" \"f\")))]\n+  \"\"\n   \"fcvt.xuf %0 = %1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n@@ -1045,18 +1029,18 @@\n   \"fcvt.fxu.trunc %0 = %1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n-(define_insn \"fixuns_trunctfdi2\"\n+(define_insn \"fixuns_truncxfdi2\"\n   [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n-\t(unsigned_fix:DI (match_operand:TF 1 \"fr_register_operand\" \"f\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t(unsigned_fix:DI (match_operand:XF 1 \"fr_register_operand\" \"f\")))]\n+  \"\"\n   \"fcvt.fxu.trunc %0 = %1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n-(define_insn \"fixuns_trunctfdi2_alts\"\n+(define_insn \"fixuns_truncxfdi2_alts\"\n   [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n-\t(unsigned_fix:DI (match_operand:TF 1 \"fr_register_operand\" \"f\")))\n+\t(unsigned_fix:DI (match_operand:XF 1 \"fr_register_operand\" \"f\")))\n    (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+  \"\"\n   \"fcvt.fxu.trunc.s%2 %0 = %1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \f\n@@ -1921,32 +1905,32 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(div:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_INT_DIV\"\n+  \"TARGET_INLINE_INT_DIV\"\n {\n-  rtx op1_tf, op2_tf, op0_tf, op0_di, twon34;\n+  rtx op1_xf, op2_xf, op0_xf, op0_di, twon34;\n   REAL_VALUE_TYPE twon34_r;\n \n-  op0_tf = gen_reg_rtx (TFmode);\n+  op0_xf = gen_reg_rtx (XFmode);\n   op0_di = gen_reg_rtx (DImode);\n \n   if (CONSTANT_P (operands[1]))\n     operands[1] = force_reg (SImode, operands[1]);\n-  op1_tf = gen_reg_rtx (TFmode);\n-  expand_float (op1_tf, operands[1], 0);\n+  op1_xf = gen_reg_rtx (XFmode);\n+  expand_float (op1_xf, operands[1], 0);\n \n   if (CONSTANT_P (operands[2]))\n     operands[2] = force_reg (SImode, operands[2]);\n-  op2_tf = gen_reg_rtx (TFmode);\n-  expand_float (op2_tf, operands[2], 0);\n+  op2_xf = gen_reg_rtx (XFmode);\n+  expand_float (op2_xf, operands[2], 0);\n \n   /* 2^-34 */\n   real_2expN (&twon34_r, -34);\n-  twon34 = CONST_DOUBLE_FROM_REAL_VALUE (twon34_r, TFmode);\n-  twon34 = force_reg (TFmode, twon34);\n+  twon34 = CONST_DOUBLE_FROM_REAL_VALUE (twon34_r, XFmode);\n+  twon34 = force_reg (XFmode, twon34);\n \n-  emit_insn (gen_divsi3_internal (op0_tf, op1_tf, op2_tf, twon34));\n+  emit_insn (gen_divsi3_internal (op0_xf, op1_xf, op2_xf, twon34));\n \n-  emit_insn (gen_fix_trunctfdi2_alts (op0_di, op0_tf, const1_rtx));\n+  emit_insn (gen_fix_truncxfdi2_alts (op0_di, op0_xf, const1_rtx));\n   emit_move_insn (operands[0], gen_lowpart (SImode, op0_di));\n   DONE;\n })\n@@ -1955,7 +1939,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(mod:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_INT_DIV\"\n+  \"TARGET_INLINE_INT_DIV\"\n {\n   rtx op2_neg, op1_di, div;\n \n@@ -1978,32 +1962,32 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(udiv:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_INT_DIV\"\n+  \"TARGET_INLINE_INT_DIV\"\n {\n-  rtx op1_tf, op2_tf, op0_tf, op0_di, twon34;\n+  rtx op1_xf, op2_xf, op0_xf, op0_di, twon34;\n   REAL_VALUE_TYPE twon34_r;\n \n-  op0_tf = gen_reg_rtx (TFmode);\n+  op0_xf = gen_reg_rtx (XFmode);\n   op0_di = gen_reg_rtx (DImode);\n \n   if (CONSTANT_P (operands[1]))\n     operands[1] = force_reg (SImode, operands[1]);\n-  op1_tf = gen_reg_rtx (TFmode);\n-  expand_float (op1_tf, operands[1], 1);\n+  op1_xf = gen_reg_rtx (XFmode);\n+  expand_float (op1_xf, operands[1], 1);\n \n   if (CONSTANT_P (operands[2]))\n     operands[2] = force_reg (SImode, operands[2]);\n-  op2_tf = gen_reg_rtx (TFmode);\n-  expand_float (op2_tf, operands[2], 1);\n+  op2_xf = gen_reg_rtx (XFmode);\n+  expand_float (op2_xf, operands[2], 1);\n \n   /* 2^-34 */\n   real_2expN (&twon34_r, -34);\n-  twon34 = CONST_DOUBLE_FROM_REAL_VALUE (twon34_r, TFmode);\n-  twon34 = force_reg (TFmode, twon34);\n+  twon34 = CONST_DOUBLE_FROM_REAL_VALUE (twon34_r, XFmode);\n+  twon34 = force_reg (XFmode, twon34);\n \n-  emit_insn (gen_divsi3_internal (op0_tf, op1_tf, op2_tf, twon34));\n+  emit_insn (gen_divsi3_internal (op0_xf, op1_xf, op2_xf, twon34));\n \n-  emit_insn (gen_fixuns_trunctfdi2_alts (op0_di, op0_tf, const1_rtx));\n+  emit_insn (gen_fixuns_truncxfdi2_alts (op0_di, op0_xf, const1_rtx));\n   emit_move_insn (operands[0], gen_lowpart (SImode, op0_di));\n   DONE;\n })\n@@ -2012,7 +1996,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(umod:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_INT_DIV\"\n+  \"TARGET_INLINE_INT_DIV\"\n {\n   rtx op2_neg, op1_di, div;\n \n@@ -2032,45 +2016,45 @@\n })\n \n (define_insn_and_split \"divsi3_internal\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=&f\")\n-\t(float:TF (div:SI (match_operand:TF 1 \"fr_register_operand\" \"f\")\n-\t\t\t  (match_operand:TF 2 \"fr_register_operand\" \"f\"))))\n-   (clobber (match_scratch:TF 4 \"=&f\"))\n-   (clobber (match_scratch:TF 5 \"=&f\"))\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=&f\")\n+\t(float:XF (div:SI (match_operand:XF 1 \"fr_register_operand\" \"f\")\n+\t\t\t  (match_operand:XF 2 \"fr_register_operand\" \"f\"))))\n+   (clobber (match_scratch:XF 4 \"=&f\"))\n+   (clobber (match_scratch:XF 5 \"=&f\"))\n    (clobber (match_scratch:BI 6 \"=c\"))\n-   (use (match_operand:TF 3 \"fr_register_operand\" \"f\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_INT_DIV\"\n+   (use (match_operand:XF 3 \"fr_register_operand\" \"f\"))]\n+  \"TARGET_INLINE_INT_DIV\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n+  [(parallel [(set (match_dup 0) (div:XF (const_int 1) (match_dup 2)))\n \t      (set (match_dup 6) (unspec:BI [(match_dup 1) (match_dup 2)]\n \t\t\t\t\t    UNSPEC_FR_RECIP_APPROX))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 4) (mult:TF (match_dup 1) (match_dup 0)))\n+     (parallel [(set (match_dup 4) (mult:XF (match_dup 1) (match_dup 0)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 5)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 2) (match_dup 0)))\n \t\t\t      (match_dup 7)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 4)\n-\t\t     (plus:TF (mult:TF (match_dup 5) (match_dup 4))\n+\t\t     (plus:XF (mult:XF (match_dup 5) (match_dup 4))\n \t\t\t      (match_dup 4)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 5)\n-\t\t     (plus:TF (mult:TF (match_dup 5) (match_dup 5))\n+\t\t     (plus:XF (mult:XF (match_dup 5) (match_dup 5))\n \t\t\t      (match_dup 3)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 0)\n-\t\t     (plus:TF (mult:TF (match_dup 5) (match_dup 4))\n+\t\t     (plus:XF (mult:XF (match_dup 5) (match_dup 4))\n \t\t\t      (match_dup 4)))\n \t\t(use (const_int 1))]))\n   ] \n-  \"operands[7] = CONST1_RTX (TFmode);\"\n+  \"operands[7] = CONST1_RTX (XFmode);\"\n   [(set_attr \"predicable\" \"no\")])\n \f\n ;; ::::::::::::::::::::\n@@ -2311,19 +2295,18 @@\n   operands[4] = gen_reg_rtx (DImode);\n })\n \n-;; ??? Ought to invent some unspecs for !INTEL_EXTENDED_IEEE_FORMAT.\n ;; Note the computation here is op0 = 63 - (exp - 0xffff).\n (define_expand \"clzdi2\"\n   [(set (match_dup 2)\n-\t(unsigned_float:TF (match_operand:DI 1 \"fr_register_operand\" \"\")))\n+\t(unsigned_float:XF (match_operand:DI 1 \"fr_register_operand\" \"\")))\n    (set (match_dup 3)\n \t(unspec:DI [(match_dup 2)] UNSPEC_GETF_EXP))\n    (set (match_dup 4) (const_int 65598))\n    (set (match_operand:DI 0 \"gr_register_operand\" \"\")\n \t(minus:DI (match_dup 4) (match_dup 3)))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+  \"\"\n {\n-  operands[2] = gen_reg_rtx (TFmode);\n+  operands[2] = gen_reg_rtx (XFmode);\n   operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_reg_rtx (DImode);\n })\n@@ -2335,48 +2318,48 @@\n   \"popcnt %0 = %1\"\n   [(set_attr \"itanium_class\" \"mmmul\")])\n \n-(define_insn \"*getf_exp_tf\"\n+(define_insn \"*getf_exp_xf\"\n   [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n-\t(unspec:DI [(match_operand:TF 1 \"fr_register_operand\" \"f\")]\n+\t(unspec:DI [(match_operand:XF 1 \"fr_register_operand\" \"f\")]\n \t\t   UNSPEC_GETF_EXP))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+  \"\"\n   \"getf.exp %0 = %1\"\n   [(set_attr \"itanium_class\" \"frfr\")])\n \n (define_expand \"divdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(div:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t(match_operand:DI 2 \"general_operand\" \"\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_INT_DIV\"\n+  \"TARGET_INLINE_INT_DIV\"\n {\n-  rtx op1_tf, op2_tf, op0_tf;\n+  rtx op1_xf, op2_xf, op0_xf;\n \n-  op0_tf = gen_reg_rtx (TFmode);\n+  op0_xf = gen_reg_rtx (XFmode);\n \n   if (CONSTANT_P (operands[1]))\n     operands[1] = force_reg (DImode, operands[1]);\n-  op1_tf = gen_reg_rtx (TFmode);\n-  expand_float (op1_tf, operands[1], 0);\n+  op1_xf = gen_reg_rtx (XFmode);\n+  expand_float (op1_xf, operands[1], 0);\n \n   if (CONSTANT_P (operands[2]))\n     operands[2] = force_reg (DImode, operands[2]);\n-  op2_tf = gen_reg_rtx (TFmode);\n-  expand_float (op2_tf, operands[2], 0);\n+  op2_xf = gen_reg_rtx (XFmode);\n+  expand_float (op2_xf, operands[2], 0);\n \n   if (TARGET_INLINE_INT_DIV_LAT)\n-    emit_insn (gen_divdi3_internal_lat (op0_tf, op1_tf, op2_tf));\n+    emit_insn (gen_divdi3_internal_lat (op0_xf, op1_xf, op2_xf));\n   else\n-    emit_insn (gen_divdi3_internal_thr (op0_tf, op1_tf, op2_tf));\n+    emit_insn (gen_divdi3_internal_thr (op0_xf, op1_xf, op2_xf));\n \n-  emit_insn (gen_fix_trunctfdi2_alts (operands[0], op0_tf, const1_rtx));\n+  emit_insn (gen_fix_truncxfdi2_alts (operands[0], op0_xf, const1_rtx));\n   DONE;\n })\n \n (define_expand \"moddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(mod:SI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t(match_operand:DI 2 \"general_operand\" \"\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_INT_DIV\"\n+  \"TARGET_INLINE_INT_DIV\"\n {\n   rtx op2_neg, div;\n \n@@ -2393,36 +2376,36 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(udiv:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t (match_operand:DI 2 \"general_operand\" \"\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_INT_DIV\"\n+  \"TARGET_INLINE_INT_DIV\"\n {\n-  rtx op1_tf, op2_tf, op0_tf;\n+  rtx op1_xf, op2_xf, op0_xf;\n \n-  op0_tf = gen_reg_rtx (TFmode);\n+  op0_xf = gen_reg_rtx (XFmode);\n \n   if (CONSTANT_P (operands[1]))\n     operands[1] = force_reg (DImode, operands[1]);\n-  op1_tf = gen_reg_rtx (TFmode);\n-  expand_float (op1_tf, operands[1], 1);\n+  op1_xf = gen_reg_rtx (XFmode);\n+  expand_float (op1_xf, operands[1], 1);\n \n   if (CONSTANT_P (operands[2]))\n     operands[2] = force_reg (DImode, operands[2]);\n-  op2_tf = gen_reg_rtx (TFmode);\n-  expand_float (op2_tf, operands[2], 1);\n+  op2_xf = gen_reg_rtx (XFmode);\n+  expand_float (op2_xf, operands[2], 1);\n \n   if (TARGET_INLINE_INT_DIV_LAT)\n-    emit_insn (gen_divdi3_internal_lat (op0_tf, op1_tf, op2_tf));\n+    emit_insn (gen_divdi3_internal_lat (op0_xf, op1_xf, op2_xf));\n   else\n-    emit_insn (gen_divdi3_internal_thr (op0_tf, op1_tf, op2_tf));\n+    emit_insn (gen_divdi3_internal_thr (op0_xf, op1_xf, op2_xf));\n \n-  emit_insn (gen_fixuns_trunctfdi2_alts (operands[0], op0_tf, const1_rtx));\n+  emit_insn (gen_fixuns_truncxfdi2_alts (operands[0], op0_xf, const1_rtx));\n   DONE;\n })\n \n (define_expand \"umoddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(umod:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t (match_operand:DI 2 \"general_operand\" \"\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_INT_DIV\"\n+  \"TARGET_INLINE_INT_DIV\"\n {\n   rtx op2_neg, div;\n \n@@ -2436,112 +2419,112 @@\n })\n \n (define_insn_and_split \"divdi3_internal_lat\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=&f\")\n-\t(float:TF (div:SI (match_operand:TF 1 \"fr_register_operand\" \"f\")\n-\t\t\t  (match_operand:TF 2 \"fr_register_operand\" \"f\"))))\n-   (clobber (match_scratch:TF 3 \"=&f\"))\n-   (clobber (match_scratch:TF 4 \"=&f\"))\n-   (clobber (match_scratch:TF 5 \"=&f\"))\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=&f\")\n+\t(float:XF (div:SI (match_operand:XF 1 \"fr_register_operand\" \"f\")\n+\t\t\t  (match_operand:XF 2 \"fr_register_operand\" \"f\"))))\n+   (clobber (match_scratch:XF 3 \"=&f\"))\n+   (clobber (match_scratch:XF 4 \"=&f\"))\n+   (clobber (match_scratch:XF 5 \"=&f\"))\n    (clobber (match_scratch:BI 6 \"=c\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_INT_DIV_LAT\"\n+  \"TARGET_INLINE_INT_DIV_LAT\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n+  [(parallel [(set (match_dup 0) (div:XF (const_int 1) (match_dup 2)))\n \t      (set (match_dup 6) (unspec:BI [(match_dup 1) (match_dup 2)]\n \t\t\t\t\t    UNSPEC_FR_RECIP_APPROX))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 2) (match_dup 0)))\n \t\t\t      (match_dup 7)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 4) (mult:TF (match_dup 1) (match_dup 0)))\n+     (parallel [(set (match_dup 4) (mult:XF (match_dup 1) (match_dup 0)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 5) (mult:TF (match_dup 3) (match_dup 3)))\n+     (parallel [(set (match_dup 5) (mult:XF (match_dup 3) (match_dup 3)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 4)\n-\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 4))\n+\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 4))\n \t\t\t      (match_dup 4)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 0)\n-\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 0))\n+\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 0))\n \t\t\t      (match_dup 0)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (mult:TF (match_dup 5) (match_dup 4))\n+\t\t     (plus:XF (mult:XF (match_dup 5) (match_dup 4))\n \t\t\t      (match_dup 4)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 0)\n-\t\t     (plus:TF (mult:TF (match_dup 5) (match_dup 0))\n+\t\t     (plus:XF (mult:XF (match_dup 5) (match_dup 0))\n \t\t\t      (match_dup 0)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 4)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 3)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 2) (match_dup 3)))\n \t\t\t      (match_dup 1)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 0)\n-\t\t     (plus:TF (mult:TF (match_dup 4) (match_dup 0))\n+\t\t     (plus:XF (mult:XF (match_dup 4) (match_dup 0))\n \t\t\t      (match_dup 3)))\n \t\t(use (const_int 1))]))\n   ] \n-  \"operands[7] = CONST1_RTX (TFmode);\"\n+  \"operands[7] = CONST1_RTX (XFmode);\"\n   [(set_attr \"predicable\" \"no\")])\n \n (define_insn_and_split \"divdi3_internal_thr\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=&f\")\n-\t(float:TF (div:SI (match_operand:TF 1 \"fr_register_operand\" \"f\")\n-\t\t\t  (match_operand:TF 2 \"fr_register_operand\" \"f\"))))\n-   (clobber (match_scratch:TF 3 \"=&f\"))\n-   (clobber (match_scratch:TF 4 \"=f\"))\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=&f\")\n+\t(float:XF (div:SI (match_operand:XF 1 \"fr_register_operand\" \"f\")\n+\t\t\t  (match_operand:XF 2 \"fr_register_operand\" \"f\"))))\n+   (clobber (match_scratch:XF 3 \"=&f\"))\n+   (clobber (match_scratch:XF 4 \"=f\"))\n    (clobber (match_scratch:BI 5 \"=c\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_INT_DIV_THR\"\n+  \"TARGET_INLINE_INT_DIV_THR\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n+  [(parallel [(set (match_dup 0) (div:XF (const_int 1) (match_dup 2)))\n \t      (set (match_dup 5) (unspec:BI [(match_dup 1) (match_dup 2)] \n \t\t\t\t\t    UNSPEC_FR_RECIP_APPROX))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 2) (match_dup 0)))\n \t\t\t      (match_dup 6)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 0)\n-\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 0))\n+\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 0))\n \t\t\t      (match_dup 0)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 3) (mult:TF (match_dup 3) (match_dup 3)))\n+     (parallel [(set (match_dup 3) (mult:XF (match_dup 3) (match_dup 3)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 0)\n-\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 0))\n+\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 0))\n \t\t\t      (match_dup 0)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 3) (mult:TF (match_dup 0) (match_dup 1)))\n+     (parallel [(set (match_dup 3) (mult:XF (match_dup 0) (match_dup 1)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 4)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 3)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 2) (match_dup 3)))\n \t\t\t      (match_dup 1)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 0)\n-\t\t     (plus:TF (mult:TF (match_dup 4) (match_dup 0))\n+\t\t     (plus:XF (mult:XF (match_dup 4) (match_dup 0))\n \t\t\t      (match_dup 3)))\n \t\t(use (const_int 1))]))\n   ] \n-  \"operands[6] = CONST1_RTX (TFmode);\"\n+  \"operands[6] = CONST1_RTX (XFmode);\"\n   [(set_attr \"predicable\" \"no\")])\n \f\n ;; ::::::::::::::::::::\n@@ -2653,7 +2636,7 @@\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"\")\n \t(div:SF (match_operand:SF 1 \"fr_register_operand\" \"\")\n \t\t(match_operand:SF 2 \"fr_register_operand\" \"\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_FLOAT_DIV\"\n+  \"TARGET_INLINE_FLOAT_DIV\"\n {\n   rtx insn;\n   if (TARGET_INLINE_FLOAT_DIV_LAT)\n@@ -2668,110 +2651,110 @@\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=&f\")\n \t(div:SF (match_operand:SF 1 \"fr_register_operand\" \"f\")\n \t\t(match_operand:SF 2 \"fr_register_operand\" \"f\")))\n-   (clobber (match_scratch:TF 3 \"=&f\"))\n-   (clobber (match_scratch:TF 4 \"=f\"))\n+   (clobber (match_scratch:XF 3 \"=&f\"))\n+   (clobber (match_scratch:XF 4 \"=f\"))\n    (clobber (match_scratch:BI 5 \"=c\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_FLOAT_DIV_LAT\"\n+  \"TARGET_INLINE_FLOAT_DIV_LAT\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel [(set (match_dup 6) (div:TF (const_int 1) (match_dup 8)))\n+  [(parallel [(set (match_dup 6) (div:XF (const_int 1) (match_dup 8)))\n \t      (set (match_dup 5) (unspec:BI [(match_dup 7) (match_dup 8)]\n \t\t\t\t\t    UNSPEC_FR_RECIP_APPROX))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 3) (mult:TF (match_dup 7) (match_dup 6)))\n+     (parallel [(set (match_dup 3) (mult:XF (match_dup 7) (match_dup 6)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 4)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 8) (match_dup 6)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 8) (match_dup 6)))\n \t\t\t      (match_dup 10)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (mult:TF (match_dup 4) (match_dup 3))\n+\t\t     (plus:XF (mult:XF (match_dup 4) (match_dup 3))\n \t\t\t      (match_dup 3)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 4) (mult:TF (match_dup 4) (match_dup 4)))\n+     (parallel [(set (match_dup 4) (mult:XF (match_dup 4) (match_dup 4)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (mult:TF (match_dup 4) (match_dup 3))\n+\t\t     (plus:XF (mult:XF (match_dup 4) (match_dup 3))\n \t\t\t      (match_dup 3)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 4) (mult:TF (match_dup 4) (match_dup 4)))\n+     (parallel [(set (match_dup 4) (mult:XF (match_dup 4) (match_dup 4)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 9)\n \t\t     (float_truncate:DF\n-\t\t       (plus:TF (mult:TF (match_dup 4) (match_dup 3))\n+\t\t       (plus:XF (mult:XF (match_dup 4) (match_dup 3))\n \t\t\t      (match_dup 3))))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (set (match_dup 0)\n \t  (float_truncate:SF (match_dup 6))))\n   ] \n {\n-  operands[6] = gen_rtx_REG (TFmode, REGNO (operands[0]));\n-  operands[7] = gen_rtx_REG (TFmode, REGNO (operands[1]));\n-  operands[8] = gen_rtx_REG (TFmode, REGNO (operands[2]));\n+  operands[6] = gen_rtx_REG (XFmode, REGNO (operands[0]));\n+  operands[7] = gen_rtx_REG (XFmode, REGNO (operands[1]));\n+  operands[8] = gen_rtx_REG (XFmode, REGNO (operands[2]));\n   operands[9] = gen_rtx_REG (DFmode, REGNO (operands[0]));\n-  operands[10] = CONST1_RTX (TFmode);\n+  operands[10] = CONST1_RTX (XFmode);\n }\n   [(set_attr \"predicable\" \"no\")])\n \n (define_insn_and_split \"divsf3_internal_thr\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=&f\")\n \t(div:SF (match_operand:SF 1 \"fr_register_operand\" \"f\")\n \t\t(match_operand:SF 2 \"fr_register_operand\" \"f\")))\n-   (clobber (match_scratch:TF 3 \"=&f\"))\n-   (clobber (match_scratch:TF 4 \"=f\"))\n+   (clobber (match_scratch:XF 3 \"=&f\"))\n+   (clobber (match_scratch:XF 4 \"=f\"))\n    (clobber (match_scratch:BI 5 \"=c\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_FLOAT_DIV_THR\"\n+  \"TARGET_INLINE_FLOAT_DIV_THR\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel [(set (match_dup 6) (div:TF (const_int 1) (match_dup 8)))\n+  [(parallel [(set (match_dup 6) (div:XF (const_int 1) (match_dup 8)))\n \t      (set (match_dup 5) (unspec:BI [(match_dup 7) (match_dup 8)]\n \t\t\t\t\t    UNSPEC_FR_RECIP_APPROX))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 8) (match_dup 6)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 8) (match_dup 6)))\n \t\t\t      (match_dup 10)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 3))\n+\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 3))\n \t\t\t      (match_dup 3)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 6)\n-\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 6))\n+\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 6))\n \t\t\t      (match_dup 6)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 9)\n \t\t     (float_truncate:SF\n-\t\t       (mult:TF (match_dup 7) (match_dup 6))))\n+\t\t       (mult:XF (match_dup 7) (match_dup 6))))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 4)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 8) (match_dup 3)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 8) (match_dup 3)))\n \t\t\t      (match_dup 7)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (set (match_dup 0)\n \t  (float_truncate:SF\n-\t    (plus:TF (mult:TF (match_dup 4) (match_dup 6))\n+\t    (plus:XF (mult:XF (match_dup 4) (match_dup 6))\n \t\t\t      (match_dup 3)))))\n   ] \n {\n-  operands[6] = gen_rtx_REG (TFmode, REGNO (operands[0]));\n-  operands[7] = gen_rtx_REG (TFmode, REGNO (operands[1]));\n-  operands[8] = gen_rtx_REG (TFmode, REGNO (operands[2]));\n+  operands[6] = gen_rtx_REG (XFmode, REGNO (operands[0]));\n+  operands[7] = gen_rtx_REG (XFmode, REGNO (operands[1]));\n+  operands[8] = gen_rtx_REG (XFmode, REGNO (operands[2]));\n   operands[9] = gen_rtx_REG (SFmode, REGNO (operands[3]));\n-  operands[10] = CONST1_RTX (TFmode);\n+  operands[10] = CONST1_RTX (XFmode);\n }\n   [(set_attr \"predicable\" \"no\")])\n \f\n@@ -2962,7 +2945,7 @@\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"\")\n \t(div:DF (match_operand:DF 1 \"fr_register_operand\" \"\")\n \t\t(match_operand:DF 2 \"fr_register_operand\" \"\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_FLOAT_DIV\"\n+  \"TARGET_INLINE_FLOAT_DIV\"\n {\n   rtx insn;\n   if (TARGET_INLINE_FLOAT_DIV_LAT)\n@@ -2977,129 +2960,129 @@\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=&f\")\n \t(div:DF (match_operand:DF 1 \"fr_register_operand\" \"f\")\n \t\t(match_operand:DF 2 \"fr_register_operand\" \"f\")))\n-   (clobber (match_scratch:TF 3 \"=&f\"))\n-   (clobber (match_scratch:TF 4 \"=&f\"))\n-   (clobber (match_scratch:TF 5 \"=&f\"))\n+   (clobber (match_scratch:XF 3 \"=&f\"))\n+   (clobber (match_scratch:XF 4 \"=&f\"))\n+   (clobber (match_scratch:XF 5 \"=&f\"))\n    (clobber (match_scratch:BI 6 \"=c\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_FLOAT_DIV_LAT\"\n+  \"TARGET_INLINE_FLOAT_DIV_LAT\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel [(set (match_dup 7) (div:TF (const_int 1) (match_dup 9)))\n+  [(parallel [(set (match_dup 7) (div:XF (const_int 1) (match_dup 9)))\n \t      (set (match_dup 6) (unspec:BI [(match_dup 8) (match_dup 9)]\n \t\t\t\t\t    UNSPEC_FR_RECIP_APPROX))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 3) (mult:TF (match_dup 8) (match_dup 7)))\n+     (parallel [(set (match_dup 3) (mult:XF (match_dup 8) (match_dup 7)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 4)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 9) (match_dup 7)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 9) (match_dup 7)))\n \t\t\t      (match_dup 12)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (mult:TF (match_dup 4) (match_dup 3))\n+\t\t     (plus:XF (mult:XF (match_dup 4) (match_dup 3))\n \t\t\t      (match_dup 3)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 5) (mult:TF (match_dup 4) (match_dup 4)))\n+     (parallel [(set (match_dup 5) (mult:XF (match_dup 4) (match_dup 4)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 7)\n-\t\t     (plus:TF (mult:TF (match_dup 4) (match_dup 7))\n+\t\t     (plus:XF (mult:XF (match_dup 4) (match_dup 7))\n \t\t\t      (match_dup 7)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (mult:TF (match_dup 5) (match_dup 3))\n+\t\t     (plus:XF (mult:XF (match_dup 5) (match_dup 3))\n \t\t\t      (match_dup 3)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 4) (mult:TF (match_dup 5) (match_dup 5)))\n+     (parallel [(set (match_dup 4) (mult:XF (match_dup 5) (match_dup 5)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 7)\n-\t\t     (plus:TF (mult:TF (match_dup 5) (match_dup 7))\n+\t\t     (plus:XF (mult:XF (match_dup 5) (match_dup 7))\n \t\t\t      (match_dup 7)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 10)\n \t\t     (float_truncate:DF\n-\t\t       (plus:TF (mult:TF (match_dup 4) (match_dup 3))\n+\t\t       (plus:XF (mult:XF (match_dup 4) (match_dup 3))\n \t\t\t      (match_dup 3))))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 7)\n-\t\t     (plus:TF (mult:TF (match_dup 4) (match_dup 7))\n+\t\t     (plus:XF (mult:XF (match_dup 4) (match_dup 7))\n \t\t\t      (match_dup 7)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (parallel [(set (match_dup 11)\n \t\t     (float_truncate:DF\n-\t\t       (plus:TF (neg:TF (mult:TF (match_dup 9) (match_dup 3)))\n+\t\t       (plus:XF (neg:XF (mult:XF (match_dup 9) (match_dup 3)))\n \t\t\t        (match_dup 8))))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 6) (const_int 0))\n      (set (match_dup 0)\n-\t  (float_truncate:DF (plus:TF (mult:TF (match_dup 5) (match_dup 7))\n+\t  (float_truncate:DF (plus:XF (mult:XF (match_dup 5) (match_dup 7))\n \t\t\t      (match_dup 3)))))\n   ] \n {\n-  operands[7] = gen_rtx_REG (TFmode, REGNO (operands[0]));\n-  operands[8] = gen_rtx_REG (TFmode, REGNO (operands[1]));\n-  operands[9] = gen_rtx_REG (TFmode, REGNO (operands[2]));\n+  operands[7] = gen_rtx_REG (XFmode, REGNO (operands[0]));\n+  operands[8] = gen_rtx_REG (XFmode, REGNO (operands[1]));\n+  operands[9] = gen_rtx_REG (XFmode, REGNO (operands[2]));\n   operands[10] = gen_rtx_REG (DFmode, REGNO (operands[3]));\n   operands[11] = gen_rtx_REG (DFmode, REGNO (operands[5]));\n-  operands[12] = CONST1_RTX (TFmode);\n+  operands[12] = CONST1_RTX (XFmode);\n }\n   [(set_attr \"predicable\" \"no\")])\n \n (define_insn_and_split \"divdf3_internal_thr\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=&f\")\n \t(div:DF (match_operand:DF 1 \"fr_register_operand\" \"f\")\n \t\t(match_operand:DF 2 \"fr_register_operand\" \"f\")))\n-   (clobber (match_scratch:TF 3 \"=&f\"))\n+   (clobber (match_scratch:XF 3 \"=&f\"))\n    (clobber (match_scratch:DF 4 \"=f\"))\n    (clobber (match_scratch:BI 5 \"=c\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_FLOAT_DIV_THR\"\n+  \"TARGET_INLINE_FLOAT_DIV_THR\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel [(set (match_dup 6) (div:TF (const_int 1) (match_dup 8)))\n+  [(parallel [(set (match_dup 6) (div:XF (const_int 1) (match_dup 8)))\n \t      (set (match_dup 5) (unspec:BI [(match_dup 7) (match_dup 8)]\n \t\t\t\t\t    UNSPEC_FR_RECIP_APPROX))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 8) (match_dup 6)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 8) (match_dup 6)))\n \t\t\t      (match_dup 10)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 6)\n-\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 6))\n+\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 6))\n \t\t\t      (match_dup 6)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (mult:TF (match_dup 3) (match_dup 3)))\n+\t\t     (mult:XF (match_dup 3) (match_dup 3)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 6)\n-\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 6))\n+\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 6))\n \t\t\t      (match_dup 6)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (mult:TF (match_dup 3) (match_dup 3)))\n+\t\t     (mult:XF (match_dup 3) (match_dup 3)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 6)\n-\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 6))\n+\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 6))\n \t\t\t      (match_dup 6)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 9)\n \t\t     (float_truncate:DF\n-\t\t       (mult:TF (match_dup 7) (match_dup 3))))\n+\t\t       (mult:XF (match_dup 7) (match_dup 3))))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 4)\n@@ -3112,11 +3095,11 @@\n \t\t\t    (match_dup 9))))\n   ] \n {\n-  operands[6] = gen_rtx_REG (TFmode, REGNO (operands[0]));\n-  operands[7] = gen_rtx_REG (TFmode, REGNO (operands[1]));\n-  operands[8] = gen_rtx_REG (TFmode, REGNO (operands[2]));\n+  operands[6] = gen_rtx_REG (XFmode, REGNO (operands[0]));\n+  operands[7] = gen_rtx_REG (XFmode, REGNO (operands[1]));\n+  operands[8] = gen_rtx_REG (XFmode, REGNO (operands[2]));\n   operands[9] = gen_rtx_REG (DFmode, REGNO (operands[3]));\n-  operands[10] = CONST1_RTX (TFmode);\n+  operands[10] = CONST1_RTX (XFmode);\n }\n   [(set_attr \"predicable\" \"no\")])\n \f\n@@ -3126,499 +3109,499 @@\n ;; ::\n ;; ::::::::::::::::::::\n \n-(define_insn \"addtf3\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(plus:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"addxf3\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(plus:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")))]\n+  \"\"\n   \"fadd %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*addtf3_truncsf\"\n+(define_insn \"*addxf3_truncsf\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:SF\n-\t  (plus:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t   (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t  (plus:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t   (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))))]\n+  \"\"\n   \"fadd.s %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*addtf3_truncdf\"\n+(define_insn \"*addxf3_truncdf\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:DF\n-\t  (plus:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t   (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t  (plus:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t   (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))))]\n+  \"\"\n   \"fadd.d %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"subtf3\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(minus:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t  (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"subxf3\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(minus:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t  (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")))]\n+  \"\"\n   \"fsub %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*subtf3_truncsf\"\n+(define_insn \"*subxf3_truncsf\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:SF\n-\t  (minus:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t  (minus:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t    (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))))]\n+  \"\"\n   \"fsub.s %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*subtf3_truncdf\"\n+(define_insn \"*subxf3_truncdf\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:DF\n-\t  (minus:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t  (minus:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t    (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))))]\n+  \"\"\n   \"fsub.d %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"multf3\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"mulxf3\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")))]\n+  \"\"\n   \"fmpy %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*multf3_truncsf\"\n+(define_insn \"*mulxf3_truncsf\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:SF\n-\t  (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t   (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t  (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t   (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))))]\n+  \"\"\n   \"fmpy.s %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*multf3_truncdf\"\n+(define_insn \"*mulxf3_truncdf\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:DF\n-\t  (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t   (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t  (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t   (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))))]\n+  \"\"\n   \"fmpy.d %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*multf3_alts\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))\n+(define_insn \"*mulxf3_alts\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")))\n    (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+  \"\"\n   \"fmpy.s%3 %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*multf3_truncsf_alts\"\n+(define_insn \"*mulxf3_truncsf_alts\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:SF\n-\t  (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t   (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))\n+\t  (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t   (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))))\n    (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+  \"\"\n   \"fmpy.s.s%3 %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*multf3_truncdf_alts\"\n+(define_insn \"*mulxf3_truncdf_alts\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:DF\n-\t  (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t   (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))\n+\t  (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t   (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))))\n    (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+  \"\"\n   \"fmpy.d.s%3 %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"abstf2\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(abs:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"absxf2\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(abs:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")))]\n+  \"\"\n   \"fabs %0 = %F1\"\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n-(define_insn \"negtf2\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(neg:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"negxf2\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(neg:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")))]\n+  \"\"\n   \"fneg %0 = %F1\"\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n-(define_insn \"*nabstf2\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(neg:TF (abs:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"*nabsxf2\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(neg:XF (abs:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\"))))]\n+  \"\"\n   \"fnegabs %0 = %F1\"\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n-(define_insn \"mintf3\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(smin:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"minxf3\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(smin:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")))]\n+  \"\"\n   \"fmin %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n-(define_insn \"maxtf3\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(smax:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"maxxf3\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(smax:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")))]\n+  \"\"\n   \"fmax %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n-(define_insn \"*maddtf4\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(plus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t\t  (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n-\t\t (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"*maddxf4\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(plus:XF (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t\t  (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))\n+\t\t (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\")))]\n+  \"\"\n   \"fma %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*maddtf4_truncsf\"\n+(define_insn \"*maddxf4_truncsf\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:SF\n-\t  (plus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n-\t\t   (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t  (plus:XF (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t\t    (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))\n+\t\t   (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\"))))]\n+  \"\"\n   \"fma.s %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*maddtf4_truncdf\"\n+(define_insn \"*maddxf4_truncdf\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:DF\n-\t  (plus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n-\t\t   (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t  (plus:XF (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t\t    (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))\n+\t\t   (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\"))))]\n+  \"\"\n   \"fma.d %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*maddtf4_alts\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(plus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t\t  (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n-\t\t (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\")))\n+(define_insn \"*maddxf4_alts\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(plus:XF (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t\t  (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))\n+\t\t (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\")))\n    (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+  \"\"\n   \"fma.s%4 %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*maddtf4_alts_truncdf\"\n+(define_insn \"*maddxf4_alts_truncdf\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:DF\n-\t  (plus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n-\t\t   (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))\n+\t  (plus:XF (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t\t    (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))\n+\t\t   (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\"))))\n    (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+  \"\"\n   \"fma.d.s%4 %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*msubtf4\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(minus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t\t   (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n-\t\t  (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"*msubxf4\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(minus:XF (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t\t   (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))\n+\t\t  (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\")))]\n+  \"\"\n   \"fms %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*msubtf4_truncsf\"\n+(define_insn \"*msubxf4_truncsf\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:SF\n-\t  (minus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t\t     (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n-\t\t    (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t  (minus:XF (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t\t     (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))\n+\t\t    (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\"))))]\n+  \"\"\n   \"fms.s %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*msubtf4_truncdf\"\n+(define_insn \"*msubxf4_truncdf\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:DF\n-\t  (minus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t\t     (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n-\t\t    (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t  (minus:XF (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t\t     (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))\n+\t\t    (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\"))))]\n+  \"\"\n   \"fms.d %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*nmultf3\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(neg:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t\t (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"*nmulxf3\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(neg:XF (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t\t (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))))]\n+  \"\"\n   \"fnmpy %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*nmultf3_truncsf\"\n+(define_insn \"*nmulxf3_truncsf\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:SF\n-\t  (neg:TF (mult:TF\n-\t\t    (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t  (neg:XF (mult:XF\n+\t\t    (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t    (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")))))]\n+  \"\"\n   \"fnmpy.s %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*nmultf3_truncdf\"\n+(define_insn \"*nmulxf3_truncdf\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:DF\n-\t  (neg:TF (mult:TF\n-\t\t    (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t  (neg:XF (mult:XF\n+\t\t    (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t    (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")))))]\n+  \"\"\n   \"fnmpy.d %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n ;; ??? Is it possible to canonicalize this as (minus (reg) (mult))?\n \n-(define_insn \"*nmaddtf4\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(plus:TF (neg:TF (mult:TF\n-\t\t\t  (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t\t  (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))\n-\t\t (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+(define_insn \"*nmaddxf4\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(plus:XF (neg:XF (mult:XF\n+\t\t\t  (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t\t  (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")))\n+\t\t (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\")))]\n+  \"\"\n   \"fnma %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*nmaddtf4_truncsf\"\n+(define_insn \"*nmaddxf4_truncsf\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:SF\n-\t  (plus:TF (neg:TF (mult:TF\n-\t\t\t    (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))\n-\t\t   (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t  (plus:XF (neg:XF (mult:XF\n+\t\t\t    (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t\t    (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")))\n+\t\t   (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\"))))]\n+  \"\"\n   \"fnma.s %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*nmaddtf4_truncdf\"\n+(define_insn \"*nmaddxf4_truncdf\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:DF\n-\t  (plus:TF (neg:TF (mult:TF\n-\t\t\t    (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t\t    (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))\n-\t\t   (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t  (plus:XF (neg:XF (mult:XF\n+\t\t\t    (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t\t    (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")))\n+\t\t   (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\"))))]\n+  \"\"\n   \"fnma.d %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*nmaddtf4_alts\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(plus:TF (neg:TF (mult:TF\n-\t\t\t  (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t\t  (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))\n-\t\t (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\")))\n+(define_insn \"*nmaddxf4_alts\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(plus:XF (neg:XF (mult:XF\n+\t\t\t  (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t\t  (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")))\n+\t\t (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\")))\n    (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+  \"\"\n   \"fnma.s%4 %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*nmaddtf4_truncdf_alts\"\n+(define_insn \"*nmaddxf4_truncdf_alts\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:DF\n-\t  (plus:TF (neg:TF\n-\t\t     (mult:TF\n-\t\t       (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t       (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))\n-\t\t (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\"))))\n+\t  (plus:XF (neg:XF\n+\t\t     (mult:XF\n+\t\t       (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t       (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")))\n+\t\t (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\"))))\n    (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+  \"\"\n   \"fnma.d.s%4 %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_expand \"divtf3\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"\")\n-\t(div:TF (match_operand:TF 1 \"fr_register_operand\" \"\")\n-\t\t(match_operand:TF 2 \"fr_register_operand\" \"\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_FLOAT_DIV\"\n+(define_expand \"divxf3\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"\")\n+\t(div:XF (match_operand:XF 1 \"fr_register_operand\" \"\")\n+\t\t(match_operand:XF 2 \"fr_register_operand\" \"\")))]\n+  \"TARGET_INLINE_FLOAT_DIV\"\n {\n   rtx insn;\n   if (TARGET_INLINE_FLOAT_DIV_LAT)\n-    insn = gen_divtf3_internal_lat (operands[0], operands[1], operands[2]);\n+    insn = gen_divxf3_internal_lat (operands[0], operands[1], operands[2]);\n   else\n-    insn = gen_divtf3_internal_thr (operands[0], operands[1], operands[2]);\n+    insn = gen_divxf3_internal_thr (operands[0], operands[1], operands[2]);\n   emit_insn (insn);\n   DONE;\n })\n \n-(define_insn_and_split \"divtf3_internal_lat\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=&f\")\n-\t(div:TF (match_operand:TF 1 \"fr_register_operand\" \"f\")\n-\t\t(match_operand:TF 2 \"fr_register_operand\" \"f\")))\n-   (clobber (match_scratch:TF 3 \"=&f\"))\n-   (clobber (match_scratch:TF 4 \"=&f\"))\n-   (clobber (match_scratch:TF 5 \"=&f\"))\n-   (clobber (match_scratch:TF 6 \"=&f\"))\n+(define_insn_and_split \"divxf3_internal_lat\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=&f\")\n+\t(div:XF (match_operand:XF 1 \"fr_register_operand\" \"f\")\n+\t\t(match_operand:XF 2 \"fr_register_operand\" \"f\")))\n+   (clobber (match_scratch:XF 3 \"=&f\"))\n+   (clobber (match_scratch:XF 4 \"=&f\"))\n+   (clobber (match_scratch:XF 5 \"=&f\"))\n+   (clobber (match_scratch:XF 6 \"=&f\"))\n    (clobber (match_scratch:BI 7 \"=c\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_FLOAT_DIV_LAT\"\n+  \"TARGET_INLINE_FLOAT_DIV_LAT\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n+  [(parallel [(set (match_dup 0) (div:XF (const_int 1) (match_dup 2)))\n \t      (set (match_dup 7) (unspec:BI [(match_dup 1) (match_dup 2)]\n \t\t\t\t\t    UNSPEC_FR_RECIP_APPROX))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 7) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 2) (match_dup 0)))\n \t\t\t      (match_dup 8)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 7) (const_int 0))\n-     (parallel [(set (match_dup 4) (mult:TF (match_dup 1) (match_dup 0)))\n+     (parallel [(set (match_dup 4) (mult:XF (match_dup 1) (match_dup 0)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 7) (const_int 0))\n-     (parallel [(set (match_dup 5) (mult:TF (match_dup 3) (match_dup 3)))\n+     (parallel [(set (match_dup 5) (mult:XF (match_dup 3) (match_dup 3)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 7) (const_int 0))\n      (parallel [(set (match_dup 6)\n-\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 3))\n+\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 3))\n \t\t\t      (match_dup 3)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 7) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (mult:TF (match_dup 5) (match_dup 5))\n+\t\t     (plus:XF (mult:XF (match_dup 5) (match_dup 5))\n \t\t\t      (match_dup 3)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 7) (const_int 0))\n      (parallel [(set (match_dup 5)\n-\t\t     (plus:TF (mult:TF (match_dup 6) (match_dup 0))\n+\t\t     (plus:XF (mult:XF (match_dup 6) (match_dup 0))\n \t\t\t      (match_dup 0)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 7) (const_int 0))\n      (parallel [(set (match_dup 0)\n-\t\t     (plus:TF (mult:TF (match_dup 5) (match_dup 3))\n+\t\t     (plus:XF (mult:XF (match_dup 5) (match_dup 3))\n \t\t\t      (match_dup 0)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 7) (const_int 0))\n      (parallel [(set (match_dup 4)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 4)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 2) (match_dup 4)))\n \t\t\t      (match_dup 1)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 7) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 0))\n+\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 0))\n \t\t\t      (match_dup 4)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 7) (const_int 0))\n      (parallel [(set (match_dup 5)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 2) (match_dup 0)))\n \t\t\t      (match_dup 8)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 7) (const_int 0))\n      (parallel [(set (match_dup 0)\n-\t\t     (plus:TF (mult:TF (match_dup 4) (match_dup 0))\n+\t\t     (plus:XF (mult:XF (match_dup 4) (match_dup 0))\n \t\t\t      (match_dup 0)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 7) (const_int 0))\n      (parallel [(set (match_dup 4)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 3)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 2) (match_dup 3)))\n \t\t\t      (match_dup 1)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 7) (const_int 0))\n      (set (match_dup 0)\n-\t  (plus:TF (mult:TF (match_dup 4) (match_dup 0))\n+\t  (plus:XF (mult:XF (match_dup 4) (match_dup 0))\n \t\t   (match_dup 3))))\n   ] \n-  \"operands[8] = CONST1_RTX (TFmode);\"\n+  \"operands[8] = CONST1_RTX (XFmode);\"\n   [(set_attr \"predicable\" \"no\")])\n \n-(define_insn_and_split \"divtf3_internal_thr\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=&f\")\n-\t(div:TF (match_operand:TF 1 \"fr_register_operand\" \"f\")\n-\t\t(match_operand:TF 2 \"fr_register_operand\" \"f\")))\n-   (clobber (match_scratch:TF 3 \"=&f\"))\n-   (clobber (match_scratch:TF 4 \"=&f\"))\n+(define_insn_and_split \"divxf3_internal_thr\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=&f\")\n+\t(div:XF (match_operand:XF 1 \"fr_register_operand\" \"f\")\n+\t\t(match_operand:XF 2 \"fr_register_operand\" \"f\")))\n+   (clobber (match_scratch:XF 3 \"=&f\"))\n+   (clobber (match_scratch:XF 4 \"=&f\"))\n    (clobber (match_scratch:BI 5 \"=c\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_FLOAT_DIV_THR\"\n+  \"TARGET_INLINE_FLOAT_DIV_THR\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n+  [(parallel [(set (match_dup 0) (div:XF (const_int 1) (match_dup 2)))\n \t      (set (match_dup 5) (unspec:BI [(match_dup 1) (match_dup 2)]\n \t\t\t\t\t    UNSPEC_FR_RECIP_APPROX))\n \t      (use (const_int 1))])\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 2) (match_dup 0)))\n \t\t\t      (match_dup 6)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 4)\n-\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 0))\n+\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 0))\n \t\t\t      (match_dup 0)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 3) (mult:TF (match_dup 3) (match_dup 3)))\n+     (parallel [(set (match_dup 3) (mult:XF (match_dup 3) (match_dup 3)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 4))\n+\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 4))\n \t\t\t      (match_dup 4)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 4) (mult:TF (match_dup 1) (match_dup 0)))\n+     (parallel [(set (match_dup 4) (mult:XF (match_dup 1) (match_dup 0)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 0)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 3)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 2) (match_dup 3)))\n \t\t\t      (match_dup 6)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 0)\n-\t\t     (plus:TF (mult:TF (match_dup 0) (match_dup 3))\n+\t\t     (plus:XF (mult:XF (match_dup 0) (match_dup 3))\n \t\t\t      (match_dup 3)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 4)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 2) (match_dup 4)))\n \t\t\t      (match_dup 1)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 3)\n-\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 0))\n+\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 0))\n \t\t\t      (match_dup 4)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 4)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 2) (match_dup 0)))\n \t\t\t      (match_dup 6)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 0)\n-\t\t     (plus:TF (mult:TF (match_dup 4) (match_dup 0))\n+\t\t     (plus:XF (mult:XF (match_dup 4) (match_dup 0))\n \t\t\t      (match_dup 0)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (parallel [(set (match_dup 4)\n-\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 3)))\n+\t\t     (plus:XF (neg:XF (mult:XF (match_dup 2) (match_dup 3)))\n \t\t\t      (match_dup 1)))\n \t\t(use (const_int 1))]))\n    (cond_exec (ne (match_dup 5) (const_int 0))\n      (set (match_dup 0)\n-\t  (plus:TF (mult:TF (match_dup 4) (match_dup 0))\n+\t  (plus:XF (mult:XF (match_dup 4) (match_dup 0))\n \t\t   (match_dup 3))))\n   ] \n-  \"operands[6] = CONST1_RTX (TFmode);\"\n+  \"operands[6] = CONST1_RTX (XFmode);\"\n   [(set_attr \"predicable\" \"no\")])\n \n ;; ??? frcpa works like cmp.foo.unc.\n \n (define_insn \"*recip_approx\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n-\t(div:TF (const_int 1)\n-\t\t(match_operand:TF 3 \"fr_register_operand\" \"f\")))\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n+\t(div:XF (const_int 1)\n+\t\t(match_operand:XF 3 \"fr_register_operand\" \"f\")))\n    (set (match_operand:BI 1 \"register_operand\" \"=c\")\n-\t(unspec:BI [(match_operand:TF 2 \"fr_register_operand\" \"f\")\n+\t(unspec:BI [(match_operand:XF 2 \"fr_register_operand\" \"f\")\n \t\t    (match_dup 3)] UNSPEC_FR_RECIP_APPROX))\n    (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+  \"\"\n   \"frcpa.s%4 %0, %1 = %2, %3\"\n   [(set_attr \"itanium_class\" \"fmisc\")\n    (set_attr \"predicable\" \"no\")])\n@@ -4015,11 +3998,11 @@\n   DONE;\n })\n \n-(define_expand \"cmptf\"\n+(define_expand \"cmpxf\"\n   [(set (cc0)\n-        (compare (match_operand:TF 0 \"tfreg_or_fp01_operand\" \"\")\n-  \t\t (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"\")))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+        (compare (match_operand:XF 0 \"xfreg_or_fp01_operand\" \"\")\n+  \t\t (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"\")))]\n+  \"\"\n {\n   ia64_compare_op0 = operands[0];\n   ia64_compare_op1 = operands[1];\n@@ -4086,12 +4069,12 @@\n   \"fcmp.%D1 %0, %I0 = %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fcmp\")])\n \n-(define_insn \"*cmptf_internal\"\n+(define_insn \"*cmpxf_internal\"\n   [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n \t(match_operator:BI 1 \"comparison_operator\"\n-\t\t   [(match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")\n-\t\t    (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\")]))]\n-  \"INTEL_EXTENDED_IEEE_FORMAT\"\n+\t\t   [(match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")\n+\t\t    (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\")]))]\n+  \"\"\n   \"fcmp.%D1 %0, %I0 = %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fcmp\")])\n \n@@ -5052,16 +5035,16 @@\n   [(set_attr \"itanium_class\" \"ld\")])\n \n (define_insn \"fr_spill\"\n-  [(set (match_operand:TF 0 \"memory_operand\" \"=m\")\n-\t(unspec:TF [(match_operand:TF 1 \"register_operand\" \"f\")]\n+  [(set (match_operand:XF 0 \"memory_operand\" \"=m\")\n+\t(unspec:XF [(match_operand:XF 1 \"register_operand\" \"f\")]\n \t\t   UNSPEC_FR_SPILL))]\n   \"\"\n   \"stf.spill %0 = %1%P0\"\n   [(set_attr \"itanium_class\" \"stf\")])\n \n (define_insn \"fr_restore\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n-\t(unspec:TF [(match_operand:TF 1 \"memory_operand\" \"m\")]\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(unspec:XF [(match_operand:XF 1 \"memory_operand\" \"m\")]\n \t\t   UNSPEC_FR_RESTORE))]\n   \"\"\n   \"ldf.fill %0 = %1%P1\""}, {"sha": "e3d348ba7227e3ab7b95ee66c450e4c50baf489d", "filename": "gcc/config/ia64/lib1funcs.asm", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Flib1funcs.asm?ref=02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "patch": "@@ -1,15 +1,19 @@\n-#ifdef L__divtf3\n+#ifdef L__divxf3\n // Compute a 80-bit IEEE double-extended quotient.\n //\n // From the Intel IA-64 Optimization Guide, choose the minimum latency\n // alternative.\n //\n // farg0 holds the dividend.  farg1 holds the divisor.\n+//\n+// __divtf3 is an alternate symbol name for backward compatibility.\n \n \t.text\n \t.align 16\n+\t.global __divxf3\n \t.global __divtf3\n-\t.proc __divtf3\n+\t.proc __divxf3\n+__divxf3:\n __divtf3:\n \tcmp.eq p7, p0 = r0, r0\n \tfrcpa.s0 f10, p6 = farg0, farg1\n@@ -37,7 +41,7 @@ __divtf3:\n (p6)\tfma.s0 fret0 = f12, f10, f11\n (p7)\tmov fret0 = f10\n \tbr.ret.sptk rp\n-\t.endp __divtf3\n+\t.endp __divxf3\n #endif\n \n #ifdef L__divdf3\n@@ -701,3 +705,39 @@ __ia64_trampoline:\n \t}\n \t.endp __ia64_trampoline\n #endif\n+\n+#ifdef L__compat\n+// Thunks for backward compatibility.\n+\n+\t.text\n+\t.align 16\n+\t.global __fixtfti\n+\t.proc __fixtfti\n+__fixtfti:\n+\t{ .bbb\n+\t  br.sptk.many __fixxfti\n+\t  ;;\n+\t}\n+\t.endp __fixtfti\n+\n+\t.align 16\n+\t.global __fixunstfti\n+\t.proc __fixunstfti\n+__fixunstfti:\n+\t{ .bbb\n+\t  br.sptk.many __fixunsxfti\n+\t  ;;\n+\t}\n+\t.endp __fixunstfti\n+\n+\t.align 16\n+\t.global __floattitf\n+\t.proc __floattitf\n+__floattitf:\n+\t{ .bbb\n+\t  br.sptk.many __floattixf\n+\t  ;;\n+\t}\n+\t.endp __floattitf\n+\n+#endif"}, {"sha": "04cfc21592d5d687b4096fcd231e76c0ecbdbbdf", "filename": "gcc/config/ia64/t-ia64", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Ft-ia64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fconfig%2Fia64%2Ft-ia64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ft-ia64?ref=02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "patch": "@@ -5,10 +5,10 @@ LIB1ASMSRC    = ia64/lib1funcs.asm\n # we use __ as the prefix.  Note that L_divdi3 in libgcc2.c actually defines\n # a TImode divide function, so there is no actual overlap here between\n # libgcc2.c and lib1funcs.asm.\n-LIB1ASMFUNCS  = __divtf3 __divdf3 __divsf3 \\\n+LIB1ASMFUNCS  = __divxf3 __divdf3 __divsf3 \\\n \t__divdi3 __moddi3 __udivdi3 __umoddi3 \\\n \t__divsi3 __modsi3 __udivsi3 __umodsi3 __save_stack_nonlocal \\\n-\t__nonlocal_goto __restore_stack_nonlocal __trampoline\n+\t__nonlocal_goto __restore_stack_nonlocal __trampoline __compat\n \n # ??? Hack to get -P option used when compiling lib1funcs.asm, because Intel\n # assembler does not accept # line number as a comment."}, {"sha": "da631c940d8a91eba50130566037e138edaff274", "filename": "gcc/expmed.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "patch": "@@ -326,13 +326,16 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n      If the target is memory, storing any naturally aligned field can be\n      done with a simple store.  For targets that support fast unaligned\n-     memory, any naturally sized, unit aligned field can be done directly.  */\n+     memory, any naturally sized, unit aligned field can be done directly.\n+\n+     It's okay if the requested bitsize is greater than fieldmode's\n+     bitsize; that just means the mode has padding bits.  */\n \n   byte_offset = (bitnum % BITS_PER_WORD) / BITS_PER_UNIT\n                 + (offset * UNITS_PER_WORD);\n \n   if (bitpos == 0\n-      && bitsize == GET_MODE_BITSIZE (fieldmode)\n+      && bitsize >= GET_MODE_BITSIZE (fieldmode)\n       && (GET_CODE (op0) != MEM\n \t  ? ((GET_MODE_SIZE (fieldmode) >= UNITS_PER_WORD\n \t     || GET_MODE_SIZE (GET_MODE (op0)) == GET_MODE_SIZE (fieldmode))\n@@ -1029,9 +1032,11 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (GET_CODE (op0) == REG\n       && mode == GET_MODE (op0)\n       && bitnum == 0\n-      && bitsize == GET_MODE_BITSIZE (GET_MODE (op0)))\n+      && bitsize >= GET_MODE_BITSIZE (GET_MODE (op0)))\n     {\n-      /* We're trying to extract a full register from itself.  */\n+      /* We're trying to extract a full register from itself.\n+         (If the requested bitsize is greater than the bitsize of op0,\n+         that just means op0's mode has padding bits.)  */\n       return op0;\n     }\n "}, {"sha": "13456555be6862a47258a920ef232c2730d44886", "filename": "gcc/genmodes.c", "status": "modified", "additions": 91, "deletions": 18, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "patch": "@@ -65,6 +65,10 @@ struct mode_data\n   struct mode_data *component;\t/* mode of components */\n   struct mode_data *wider;\t/* next wider mode */\n \n+  struct mode_data *contained;  /* Pointer to list of modes that have\n+\t\t\t\t   this mode as a component.  */\n+  struct mode_data *next_cont;  /* Next mode in that list.  */\n+\n   const char *file;\t\t/* file and line of definition, */\n   unsigned int line;\t\t/* for error reporting */\n };\n@@ -76,7 +80,7 @@ static struct mode_data *void_mode;\n static const struct mode_data blank_mode = {\n   0, \"<unknown>\", MAX_MODE_CLASS,\n   -1, -1, -1, -1,\n-  0, 0, 0,\n+  0, 0, 0, 0, 0,\n   \"<unknown>\", 0\n };\n \n@@ -372,6 +376,14 @@ complete_mode (struct mode_data *m)\n     alignment = m->bytesize;\n \n   m->alignment = alignment & (~alignment + 1);\n+\n+  /* If this mode has components, make the component mode point back\n+     to this mode, for the sake of adjustments.  */\n+  if (m->component)\n+    {\n+      m->next_cont = m->component->contained;\n+      m->component->contained = m;\n+    }\n }\n \n static void\n@@ -912,18 +924,15 @@ emit_mode_size (void)\n }\n \n static void\n-emit_mode_unit_size (void)\n+emit_mode_nunits (void)\n {\n   enum mode_class c;\n   struct mode_data *m;\n \n-  print_decl (\"unsigned char\", \"mode_unit_size\", \"NUM_MACHINE_MODES\");\n+  print_decl (\"unsigned char\", \"mode_nunits\", \"NUM_MACHINE_MODES\");\n \n   for_all_modes (c, m)\n-    tagged_printf (\"%u\",\n-\t\t   m->component\n-\t\t   ? m->component->bytesize : m->bytesize,\n-\t\t   m->name);\n+    tagged_printf (\"%u\", m->ncomponents, m->name);\n \n   print_closer ();\n }\n@@ -1055,23 +1064,87 @@ static void\n emit_mode_adjustments (void)\n {\n   struct mode_adjust *a;\n+  struct mode_data *m;\n \n-  puts (\"\\nvoid\\ninit_adjust_machine_modes (void)\\n{\");\n+  puts (\"\\\n+\\nvoid\\\n+\\ninit_adjust_machine_modes (void)\\\n+\\n{\\\n+\\n  size_t s ATTRIBUTE_UNUSED;\");\n \n+  /* Size adjustments must be propagated to all containing modes.\n+     A size adjustment forces us to recalculate the alignment too.  */\n   for (a = adj_bytesize; a; a = a->next)\n-    printf (\"  /* %s:%d */\\n  mode_size[%smode] = %s;\\n\",\n-\t    a->file, a->line, a->mode->name, a->adjustment);\n-  if (adj_bytesize && (adj_alignment || adj_format))\n-    putchar ('\\n');\n+    {\n+      printf (\"\\n  /* %s:%d */\\n  s = %s;\\n\",\n+\t      a->file, a->line, a->adjustment);\n+      printf (\"  mode_size[%smode] = s;\\n\", a->mode->name);\n+      printf (\"  mode_base_align[%smode] = s & (~s + 1);\\n\",\n+\t      a->mode->name);\n+\n+      for (m = a->mode->contained; m; m = m->next_cont)\n+\t{\n+\t  switch (m->class)\n+\t    {\n+\t    case MODE_COMPLEX_INT:\n+\t    case MODE_COMPLEX_FLOAT:\n+\t      printf (\"  mode_size[%smode] = 2*s;\\n\", m->name);\n+\t      printf (\"  mode_base_align[%smode] = s & (~s + 1);\\n\",\n+\t\t      m->name);\n+\t      break;\n+\n+\t    case MODE_VECTOR_INT:\n+\t    case MODE_VECTOR_FLOAT:\n+\t      printf (\"  mode_size[%smode] = %d*s;\\n\",\n+\t\t      m->name, m->ncomponents);\n+\t      printf (\"  mode_base_align[%smode] = (%d*s) & (~(%d*s)+1);\\n\",\n+\t\t      m->name, m->ncomponents, m->ncomponents);\n+\t      break;\n+\n+\t    default:\n+\t      internal_error (\n+\t      \"mode %s is neither vector nor complex but contains %s\",\n+\t      m->name, a->mode->name);\n+\t      /* NOTREACHED */\n+\t    }\n+\t}\n+    }\n \n+  /* Alignment adjustments propagate too.\n+     ??? This may not be the right thing for vector modes.  */\n   for (a = adj_alignment; a; a = a->next)\n-    printf (\"  /* %s:%d */\\n  mode_base_align[%smode] = %s;\\n\",\n-\t    a->file, a->line, a->mode->name, a->adjustment);\n-  if (adj_alignment && adj_format)\n-    putchar ('\\n');\n+    {\n+      printf (\"\\n  /* %s:%d */\\n  s = %s;\\n\",\n+\t      a->file, a->line, a->adjustment);\n+      printf (\"  mode_base_align[%smode] = s;\\n\", a->mode->name);\n \n+      for (m = a->mode->contained; m; m = m->next_cont)\n+\t{\n+\t  switch (m->class)\n+\t    {\n+\t    case MODE_COMPLEX_INT:\n+\t    case MODE_COMPLEX_FLOAT:\n+\t      printf (\"  mode_base_align[%smode] = s;\\n\", m->name);\n+\t      break;\n+\n+\t    case MODE_VECTOR_INT:\n+\t    case MODE_VECTOR_FLOAT:\n+\t      printf (\"  mode_base_align[%smode] = %d*s;\\n\",\n+\t\t      m->name, m->ncomponents);\n+\t      break;\n+\n+\t    default:\n+\t      internal_error (\n+\t      \"mode %s is neither vector nor complex but contains %s\",\n+\t      m->name, a->mode->name);\n+\t      /* NOTREACHED */\n+\t    }\n+\t}\n+    }\n+      \n+  /* Real mode formats don't have to propagate anywhere.  */\n   for (a = adj_format; a; a = a->next)\n-    printf (\"  /* %s:%d */\\n  REAL_MODE_FORMAT (%smode) = %s;\\n\",\n+    printf (\"\\n  /* %s:%d */\\n  REAL_MODE_FORMAT (%smode) = %s;\\n\",\n \t    a->file, a->line, a->mode->name, a->adjustment);\n \n   puts (\"}\");\n@@ -1085,7 +1158,7 @@ emit_insn_modes_c (void)\n   emit_mode_class ();\n   emit_mode_bitsize ();\n   emit_mode_size ();\n-  emit_mode_unit_size ();\n+  emit_mode_nunits ();\n   emit_mode_wider ();\n   emit_mode_mask ();\n   emit_mode_inner ();"}, {"sha": "16f979818c3727ad89386857a9cb66fbe4554a21", "filename": "gcc/machmode.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "patch": "@@ -81,17 +81,6 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n extern CONST_MODE_SIZE unsigned char mode_size[NUM_MACHINE_MODES];\n #define GET_MODE_SIZE(MODE)   mode_size[MODE]\n \n-/* Get the size in bytes of the basic parts of an object of mode MODE.  */\n-\n-extern const unsigned char mode_unit_size[NUM_MACHINE_MODES];\n-#define GET_MODE_UNIT_SIZE(MODE)  mode_unit_size[MODE]\n-\n-/* Get the number of units in the object.  */\n-\n-#define GET_MODE_NUNITS(MODE)  \\\n-  ((GET_MODE_UNIT_SIZE ((MODE)) == 0) ? 0 \\\n-   : (GET_MODE_SIZE ((MODE)) / GET_MODE_UNIT_SIZE ((MODE))))\n-\n /* Get the size in bits of an object of mode MODE.  */\n \n extern const unsigned short mode_bitsize[NUM_MACHINE_MODES];\n@@ -104,12 +93,23 @@ extern const unsigned HOST_WIDE_INT mode_mask_array[NUM_MACHINE_MODES];\n \n #define GET_MODE_MASK(MODE) mode_mask_array[MODE]\n \n-extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n-\n /* Return the mode of the inner elements in a vector.  */\n \n+extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n #define GET_MODE_INNER(MODE) mode_inner[MODE]\n \n+/* Get the size in bytes of the basic parts of an object of mode MODE.  */\n+\n+#define GET_MODE_UNIT_SIZE(MODE)\t\t\\\n+  (GET_MODE_INNER (MODE) == VOIDmode\t\t\\\n+   ? GET_MODE_SIZE (MODE)\t\t\t\\\n+   : GET_MODE_SIZE (GET_MODE_INNER (MODE)))\n+\n+/* Get the number of units in the object.  */\n+\n+extern const unsigned char mode_nunits[NUM_MACHINE_MODES];\n+#define GET_MODE_NUNITS(MODE)  mode_nunits[MODE]\n+\n /* Get the next wider natural mode (eg, QI -> HI -> SI -> DI -> TI).  */\n \n extern const unsigned char mode_wider[NUM_MACHINE_MODES];"}, {"sha": "791b8ad0a9f0460e2312bc350fbb27f464430a82", "filename": "gcc/varasm.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02befdf47ff01246c47ddc7d4f3985aa2d990d8e/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=02befdf47ff01246c47ddc7d4f3985aa2d990d8e", "patch": "@@ -1905,15 +1905,20 @@ assemble_real (REAL_VALUE_TYPE d, enum machine_mode mode, unsigned int align)\n   int i;\n   int bitsize, nelts, nunits, units_per;\n \n-  /* This is hairy.  We have a quantity of known bitsize.  real_to_target\n+  /* This is hairy.  We have a quantity of known size.  real_to_target\n      will put it into an array of *host* longs, 32 bits per element\n      (even if long is more than 32 bits).  We need to determine the\n      number of array elements that are occupied (nelts) and the number\n      of *target* min-addressable units that will be occupied in the\n-     object file (nunits).  We can assume that BITS_PER_UNIT divides\n-     the mode's bitsize evenly, but we can not assume that 32 does.  */\n-  bitsize = GET_MODE_BITSIZE (mode);\n-  nunits = bitsize / BITS_PER_UNIT;\n+     object file (nunits).  We cannot assume that 32 divides the\n+     mode's bitsize (size * BITS_PER_UNIT) evenly.\n+\n+     size * BITS_PER_UNIT is used here to make sure that padding bits\n+     (which might appear at either end of the value; real_to_target\n+     will include the padding bits in its output array) are included.  */\n+\n+  nunits = GET_MODE_SIZE (mode);\n+  bitsize = nunits * BITS_PER_UNIT;\n   nelts = CEIL (bitsize, 32);\n   units_per = 32 / BITS_PER_UNIT;\n \n@@ -3756,9 +3761,7 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n       if (TREE_CODE (exp) != REAL_CST)\n \terror (\"initializer for floating value is not a floating constant\");\n \n-      assemble_real (TREE_REAL_CST (exp),\n-\t\t     mode_for_size (size * BITS_PER_UNIT, MODE_FLOAT, 0),\n-\t\t     align);\n+      assemble_real (TREE_REAL_CST (exp), TYPE_MODE (TREE_TYPE (exp)), align);\n       break;\n \n     case COMPLEX_TYPE:"}]}