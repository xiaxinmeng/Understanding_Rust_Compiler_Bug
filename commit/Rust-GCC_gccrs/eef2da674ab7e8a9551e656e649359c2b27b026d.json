{"sha": "eef2da674ab7e8a9551e656e649359c2b27b026d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVmMmRhNjc0YWI3ZThhOTU1MWU2NTZlNjQ5MzU5YzJiMjdiMDI2ZA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-01-02T06:17:54Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2019-01-02T06:17:54Z"}, "message": "gimple-fold.c (get_range_strlen_tree): Record if the computed length is optimistic.\n\n\t* gimple-fold.c (get_range_strlen_tree): Record if the computed\n\tlength is optimistic.  If it is, then arrange to compute the\n\tconservative length as well.\n\n\t* gcc.dg/strlenopt-40.c: Update\n\t* gcc.dg/strlenopt-51.c: Likewise.\n\t* gcc.dg/tree-ssa/pr79376.c: Likewise.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r267505", "tree": {"sha": "f10d8250b17e84370021c55efc1683b25d2a446e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f10d8250b17e84370021c55efc1683b25d2a446e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eef2da674ab7e8a9551e656e649359c2b27b026d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eef2da674ab7e8a9551e656e649359c2b27b026d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eef2da674ab7e8a9551e656e649359c2b27b026d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eef2da674ab7e8a9551e656e649359c2b27b026d/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2667a5d04a4a34d901d592028d98aea694fca523", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2667a5d04a4a34d901d592028d98aea694fca523", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2667a5d04a4a34d901d592028d98aea694fca523"}], "stats": {"total": 359, "additions": 215, "deletions": 144}, "files": [{"sha": "8d243aa03c57cd840f9ae09c740d3d10e9615d9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef2da674ab7e8a9551e656e649359c2b27b026d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef2da674ab7e8a9551e656e649359c2b27b026d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eef2da674ab7e8a9551e656e649359c2b27b026d", "patch": "@@ -1,6 +1,10 @@\n 2019-01-01  Martin Sebor  <msebor@redhat.com>\n             Jeff Law  <law@redhat.com>\n \n+\t* gimple-fold.c (get_range_strlen_tree): Record if the computed\n+\tlength is optimistic.  If it is, then arrange to compute the\n+\tconservative length as well.\n+\n \t* gimple-fold.h (get_range_strlen): Update prototype.\n \t* builtins.c (check_access): Update call to get_range_strlen to use\n \tc_strlen_data pointer.   Change various variable accesses to instead"}, {"sha": "cf19db268ad06ca9b74dade6f3a39bd73d0d46fe", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 60, "deletions": 9, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef2da674ab7e8a9551e656e649359c2b27b026d/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef2da674ab7e8a9551e656e649359c2b27b026d/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=eef2da674ab7e8a9551e656e649359c2b27b026d", "patch": "@@ -1291,6 +1291,12 @@ get_range_strlen_tree (tree arg, bitmap *visited,\n   /* The length computed by this invocation of the function.  */\n   tree val = NULL_TREE;\n \n+  /* True if VAL is an optimistic (tight) bound determined from\n+     the size of the character array in which the string may be\n+     stored.  In that case, the computed VAL is used to set\n+     PDATA->MAXBOUND.  */\n+  bool tight_bound = false;\n+\n   /* We can end up with &(*iftmp_1)[0] here as well, so handle it.  */\n   if (TREE_CODE (arg) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (arg, 0)) == ARRAY_REF)\n@@ -1384,6 +1390,7 @@ get_range_strlen_tree (tree arg, bitmap *visited,\n \t      && optype == TREE_TYPE (TREE_OPERAND (arg, 0))\n \t      && array_at_struct_end_p (TREE_OPERAND (arg, 0)))\n \t    *flexp = true;\n+\t  tight_bound = true;\n \t}\n       else if (TREE_CODE (arg) == COMPONENT_REF\n \t       && (TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 1)))\n@@ -1419,17 +1426,24 @@ get_range_strlen_tree (tree arg, bitmap *visited,\n \t  /* Set the minimum size to zero since the string in\n \t     the array could have zero length.  */\n \t  pdata->minlen = ssize_int (0);\n-\t}\n \n-      if (VAR_P (arg))\n-\t{\n-\t  tree type = TREE_TYPE (arg);\n-\t  if (POINTER_TYPE_P (type))\n-\t    type = TREE_TYPE (type);\n-\n-\t  if (TREE_CODE (type) == ARRAY_TYPE)\n+\t  /* The array size determined above is an optimistic bound\n+\t     on the length.  If the array isn't nul-terminated the\n+\t     length computed by the library function would be greater.\n+\t     Even though using strlen to cross the subobject boundary\n+\t     is undefined, avoid drawing conclusions from the member\n+\t     type about the length here.  */\n+\t  tight_bound = true;\n+\t}\n+      else if (VAR_P (arg))\n+\t{\n+\t  /* Avoid handling pointers to arrays.  GCC might misuse\n+\t     a pointer to an array of one bound to point to an array\n+\t     object of a greater bound.  */\n+\t  tree argtype = TREE_TYPE (arg);\n+\t  if (TREE_CODE (argtype) == ARRAY_TYPE)\n \t    {\n-\t      val = TYPE_SIZE_UNIT (type);\n+\t      val = TYPE_SIZE_UNIT (argtype);\n \t      if (!val\n \t\t  || TREE_CODE (val) != INTEGER_CST\n \t\t  || integer_zerop (val))\n@@ -1476,6 +1490,43 @@ get_range_strlen_tree (tree arg, bitmap *visited,\n   else\n     pdata->maxbound = val;\n \n+  if (tight_bound)\n+    {\n+      /* VAL computed above represents an optimistically tight bound\n+\t on the length of the string based on the referenced object's\n+\t or subobject's type.  Determine the conservative upper bound\n+\t based on the enclosing object's size if possible.  */\n+      if (rkind == SRK_LENRANGE || rkind == SRK_LENRANGE_2)\n+\t{\n+\t  poly_int64 offset;\n+\t  tree base = get_addr_base_and_unit_offset (arg, &offset);\n+\t  if (!base)\n+\t    {\n+\t      /* When the call above fails due to a non-constant offset\n+\t\t assume the offset is zero and use the size of the whole\n+\t\t enclosing object instead.  */\n+\t      base = get_base_address (arg);\n+\t      offset = 0;\n+\t    }\n+\t  /* If the base object is a pointer no upper bound on the length\n+\t     can be determined.  Otherwise the maximum length is equal to\n+\t     the size of the enclosing object minus the offset of\n+\t     the referenced subobject minus 1 (for the terminating nul).  */\n+\t  tree type = TREE_TYPE (base);\n+\t  if (TREE_CODE (type) == POINTER_TYPE\n+\t      || !VAR_P (base) || !(val = DECL_SIZE_UNIT (base)))\n+\t    val = build_all_ones_cst (size_type_node);\n+\t  else\n+\t    {\n+\t      val = DECL_SIZE_UNIT (base);\n+\t      val = fold_build2 (MINUS_EXPR, TREE_TYPE (val), val,\n+\t\t\t\t size_int (offset + 1));\n+\t    }\n+\t}\n+      else\n+\treturn false;\n+    }\n+\n   if (pdata->maxlen)\n     {\n       /* Adjust the more conservative bound if possible/necessary"}, {"sha": "6f603209cc7c1cdb229e75ed9dd3154948803ebe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef2da674ab7e8a9551e656e649359c2b27b026d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef2da674ab7e8a9551e656e649359c2b27b026d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eef2da674ab7e8a9551e656e649359c2b27b026d", "patch": "@@ -1,6 +1,10 @@\n 2019-01-01  Martin Sebor  <msebor@redhat.com>\n             Jeff Law  <law@redhat.com>\n \n+\t* gcc.dg/strlenopt-40.c: Update \n+\t* gcc.dg/strlenopt-51.c: Likewise. \n+\t* gcc.dg/tree-ssa/pr79376.c: Likewise.\n+\n \t* gcc.dg/strlenopt-40.c: Disable a couple tests.\n \t* gcc.dg/strlenopt-48.c: Twiddle test slightly.\n \t* gcc.dg/strlenopt-59.c: New test."}, {"sha": "7a97ebb8fe5be4b9e9ebd2d81238e9b63a4fd6e2", "filename": "gcc/testsuite/gcc.dg/strlenopt-40.c", "status": "modified", "additions": 120, "deletions": 85, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef2da674ab7e8a9551e656e649359c2b27b026d/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef2da674ab7e8a9551e656e649359c2b27b026d/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-40.c?ref=eef2da674ab7e8a9551e656e649359c2b27b026d", "patch": "@@ -105,20 +105,23 @@ void elim_global_arrays (int i)\n   /* Verify that the expression involving the strlen call as well\n      as whatever depends on it is eliminated  from the test output.\n      All these expressions must be trivially true.  */\n-  ELIM_TRUE (strlen (a7_3[0]) < sizeof a7_3[0]);\n-  ELIM_TRUE (strlen (a7_3[1]) < sizeof a7_3[1]);\n-  ELIM_TRUE (strlen (a7_3[6]) < sizeof a7_3[6]);\n-  ELIM_TRUE (strlen (a7_3[i]) < sizeof a7_3[i]);\n-\n-  ELIM_TRUE (strlen (a5_7[0]) < sizeof a5_7[0]);\n-  ELIM_TRUE (strlen (a5_7[1]) < sizeof a5_7[1]);\n-  ELIM_TRUE (strlen (a5_7[4]) < sizeof a5_7[4]);\n-  ELIM_TRUE (strlen (a5_7[i]) < sizeof a5_7[0]);\n-\n-  ELIM_TRUE (strlen (ax_3[0]) < sizeof ax_3[0]);\n-  ELIM_TRUE (strlen (ax_3[1]) < sizeof ax_3[1]);\n-  ELIM_TRUE (strlen (ax_3[9]) < sizeof ax_3[9]);\n-  ELIM_TRUE (strlen (ax_3[i]) < sizeof ax_3[i]);\n+  ELIM_TRUE (strlen (a7_3[0]) < sizeof a7_3);\n+  ELIM_TRUE (strlen (a7_3[1]) < sizeof a7_3 - sizeof *a7_3);\n+  ELIM_TRUE (strlen (a7_3[6]) < sizeof a7_3 - 5 * sizeof *a7_3);\n+  ELIM_TRUE (strlen (a7_3[i]) < sizeof a7_3);\n+\n+  ELIM_TRUE (strlen (a5_7[0]) < sizeof a5_7);\n+  ELIM_TRUE (strlen (a5_7[1]) < sizeof a5_7 - sizeof *a5_7);\n+  ELIM_TRUE (strlen (a5_7[4]) < sizeof a5_7 - 3 * sizeof *a5_7);\n+  ELIM_TRUE (strlen (a5_7[i]) < sizeof a5_7);\n+\n+  /* Even when treating a multi-dimensional array as a single string\n+     the length must be less DIFF_MAX - (ax_3[i] - ax_3[0]) but GCC\n+     doesn't do that computation yet so avoid testing it.  */\n+  ELIM_TRUE (strlen (ax_3[0]) < DIFF_MAX);\n+  ELIM_TRUE (strlen (ax_3[1]) < DIFF_MAX);\n+  ELIM_TRUE (strlen (ax_3[9]) < DIFF_MAX);\n+  ELIM_TRUE (strlen (ax_3[i]) < DIFF_MAX);\n \n   ELIM_TRUE (strlen (a3) < sizeof a3);\n   ELIM_TRUE (strlen (a7) < sizeof a7);\n@@ -130,21 +133,25 @@ void elim_global_arrays (int i)\n \n void elim_pointer_to_arrays (void)\n {\n-  ELIM_TRUE (strlen (*pa7) < 7);\n-  ELIM_TRUE (strlen (*pa5) < 5);\n-  ELIM_TRUE (strlen (*pa3) < 3);\n-\n-  ELIM_TRUE (strlen ((*pa7_3)[0]) < 3);\n-  ELIM_TRUE (strlen ((*pa7_3)[1]) < 3);\n-  ELIM_TRUE (strlen ((*pa7_3)[6]) < 3);\n-\n-  ELIM_TRUE (strlen ((*pax_3)[0]) < 3);\n-  ELIM_TRUE (strlen ((*pax_3)[1]) < 3);\n-  ELIM_TRUE (strlen ((*pax_3)[9]) < 3);\n-\n-  ELIM_TRUE (strlen ((*pa5_7)[0]) < 7);\n-  ELIM_TRUE (strlen ((*pa5_7)[1]) < 7);\n-  ELIM_TRUE (strlen ((*pa5_7)[4]) < 7);\n+  /* Unfortunately, GCC cannot be trusted not to misuse a pointer\n+     to a smaller array to point to an object of a bigger type so\n+     the strlen range optimization must assume each array pointer\n+     points effectively to an array of an unknown bound.  */\n+  ELIM_TRUE (strlen (*pa7) < DIFF_MAX);\n+  ELIM_TRUE (strlen (*pa5) < DIFF_MAX);\n+  ELIM_TRUE (strlen (*pa3) < DIFF_MAX);\n+\n+  ELIM_TRUE (strlen ((*pa7_3)[0]) < DIFF_MAX);\n+  ELIM_TRUE (strlen ((*pa7_3)[1]) < DIFF_MAX);\n+  ELIM_TRUE (strlen ((*pa7_3)[6]) < DIFF_MAX);\n+\n+  ELIM_TRUE (strlen ((*pax_3)[0]) < DIFF_MAX);\n+  ELIM_TRUE (strlen ((*pax_3)[1]) < DIFF_MAX);\n+  ELIM_TRUE (strlen ((*pax_3)[9]) < DIFF_MAX);\n+\n+  ELIM_TRUE (strlen ((*pa5_7)[0]) < DIFF_MAX);\n+  ELIM_TRUE (strlen ((*pa5_7)[1]) < DIFF_MAX);\n+  ELIM_TRUE (strlen ((*pa5_7)[4]) < DIFF_MAX);\n }\n \n void elim_global_arrays_and_strings (int i)\n@@ -176,65 +183,33 @@ void elim_global_arrays_and_strings (int i)\n \n void elim_member_arrays_obj (int i)\n {\n-  ELIM_TRUE (strlen (ma0_3_5_7[0][0][0].a3) < 3);\n-  ELIM_TRUE (strlen (ma0_3_5_7[0][0][1].a3) < 3);\n-  ELIM_TRUE (strlen (ma0_3_5_7[0][0][2].a3) < 3);\n-  ELIM_TRUE (strlen (ma0_3_5_7[0][0][6].a3) < 3);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][0].a3) < sizeof ma0_3_5_7);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][1].a3) < sizeof ma0_3_5_7);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][2].a3) < sizeof ma0_3_5_7);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][6].a3) < sizeof ma0_3_5_7);\n \n-  ELIM_TRUE (strlen (ma0_3_5_7[1][0][0].a3) < 3);\n-  ELIM_TRUE (strlen (ma0_3_5_7[2][0][1].a3) < 3);\n+  ELIM_TRUE (strlen (ma0_3_5_7[1][0][0].a3) < sizeof ma0_3_5_7);\n+  ELIM_TRUE (strlen (ma0_3_5_7[2][0][1].a3) < sizeof ma0_3_5_7);\n \n-  ELIM_TRUE (strlen (ma0_3_5_7[1][1][0].a3) < 3);\n-  ELIM_TRUE (strlen (ma0_3_5_7[2][4][6].a3) < 3);\n+  ELIM_TRUE (strlen (ma0_3_5_7[1][1][0].a3) < sizeof ma0_3_5_7);\n+  ELIM_TRUE (strlen (ma0_3_5_7[2][4][6].a3) < sizeof ma0_3_5_7);\n \n-  ELIM_TRUE (strlen (ma0_3_5_7[0][0][0].a5) < 5);\n-  ELIM_TRUE (strlen (ma0_3_5_7[0][0][1].a5) < 5);\n-  ELIM_TRUE (strlen (ma0_3_5_7[0][0][2].a5) < 5);\n-  ELIM_TRUE (strlen (ma0_3_5_7[0][0][6].a5) < 5);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][0].a5) < sizeof ma0_3_5_7);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][1].a5) < sizeof ma0_3_5_7);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][2].a5) < sizeof ma0_3_5_7);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][6].a5) < sizeof ma0_3_5_7);\n \n-  ELIM_TRUE (strlen (ma0_3_5_7[1][0][0].a5) < 5);\n-  ELIM_TRUE (strlen (ma0_3_5_7[2][0][1].a5) < 5);\n+  ELIM_TRUE (strlen (ma0_3_5_7[1][0][0].a5) < sizeof ma0_3_5_7);\n+  ELIM_TRUE (strlen (ma0_3_5_7[2][0][1].a5) < sizeof ma0_3_5_7);\n \n-  ELIM_TRUE (strlen (ma0_3_5_7[1][1][0].a5) < 5);\n-  ELIM_TRUE (strlen (ma0_3_5_7[2][4][6].a5) < 5);\n+  ELIM_TRUE (strlen (ma0_3_5_7[1][1][0].a5) < sizeof ma0_3_5_7);\n+  ELIM_TRUE (strlen (ma0_3_5_7[2][4][6].a5) < sizeof ma0_3_5_7);\n \n-  ELIM_TRUE (strlen (ma0_3_5_7[0][0][0].a7_3[0]) < 3);\n-  ELIM_TRUE (strlen (ma0_3_5_7[2][4][6].a7_3[2]) < 3);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][0].a7_3[0]) < sizeof ma0_3_5_7);\n+  ELIM_TRUE (strlen (ma0_3_5_7[2][4][6].a7_3[2]) < sizeof ma0_3_5_7);\n \n-  ELIM_TRUE (strlen (ma0_3_5_7[0][0][0].a5_7[0]) < 7);\n-  ELIM_TRUE (strlen (ma0_3_5_7[2][4][6].a5_7[4]) < 7);\n-}\n-\n-void elim_member_arrays_ptr (struct MemArrays0 *ma0,\n-\t\t\t     struct MemArraysX *max,\n-\t\t\t     struct MemArrays7 *ma7,\n-\t\t\t     int i)\n-{\n-  ELIM_TRUE (strlen (ma0->a7_3[0]) < 3);\n-  ELIM_TRUE (strlen (ma0->a7_3[1]) < 3);\n-  ELIM_TRUE (strlen (ma0->a7_3[6]) < 3);\n-  ELIM_TRUE (strlen (ma0->a7_3[6]) < 3);\n-  ELIM_TRUE (strlen (ma0->a7_3[i]) < 3);\n-  ELIM_TRUE (strlen (ma0->a7_3[i]) < 3);\n-\n-  ELIM_TRUE (strlen (ma0->a5_7[0]) < 7);\n-  ELIM_TRUE (strlen (ma0[0].a5_7[0]) < 7);\n-  ELIM_TRUE (strlen (ma0[1].a5_7[0]) < 7);\n-  ELIM_TRUE (strlen (ma0[1].a5_7[4]) < 7);\n-  ELIM_TRUE (strlen (ma0[9].a5_7[0]) < 7);\n-  ELIM_TRUE (strlen (ma0[9].a5_7[4]) < 7);\n-\n-  ELIM_TRUE (strlen (ma0->a3) < sizeof ma0->a3);\n-  ELIM_TRUE (strlen (ma0->a5) < sizeof ma0->a5);\n-  ELIM_TRUE (strlen (ma0->a0) < DIFF_MAX - 1);\n-\n-  ELIM_TRUE (strlen (max->a3) < sizeof max->a3);\n-  ELIM_TRUE (strlen (max->a5) < sizeof max->a5);\n-  ELIM_TRUE (strlen (max->ax) < DIFF_MAX - 1);\n-\n-  ELIM_TRUE (strlen (ma7->a3) < sizeof max->a3);\n-  ELIM_TRUE (strlen (ma7->a5) < sizeof max->a5);\n-  ELIM_TRUE (strlen (ma7->a7) < DIFF_MAX - 1);\n+  ELIM_TRUE (strlen (ma0_3_5_7[0][0][0].a5_7[0]) < sizeof ma0_3_5_7);\n+  ELIM_TRUE (strlen (ma0_3_5_7[2][4][6].a5_7[4]) < sizeof ma0_3_5_7);\n }\n \n \n@@ -255,11 +230,27 @@ void keep_global_arrays (int i)\n   KEEP (strlen (a5_7[4]) < 6);\n   KEEP (strlen (a5_7[i]) < 6);\n \n+  /* Verify also that tests (and strlen calls) are not eliminated\n+     for results greater than what would the size of the innermost\n+     array suggest might be possible (in case the element array is\n+     not nul-terminated), even though such calls are undefined.  */\n+  KEEP (strlen (a5_7[0]) > sizeof a5_7 - 2);\n+  KEEP (strlen (a5_7[1]) > sizeof a5_7 - sizeof a5_7[1] - 2);\n+  KEEP (strlen (a5_7[i]) > sizeof a5_7 - 2);\n+\n   KEEP (strlen (ax_3[0]) < 2);\n   KEEP (strlen (ax_3[1]) < 2);\n   KEEP (strlen (ax_3[2]) < 2);\n   KEEP (strlen (ax_3[i]) < 2);\n \n+  /* Here again, verify that the ax_3 matrix is treated essentially\n+     as a flat array of unknown bound for the benefit of all the\n+     undefined code out there that might rely on it.  */\n+  KEEP (strlen (ax_3[0]) > 3);\n+  KEEP (strlen (ax_3[1]) > 9);\n+  KEEP (strlen (ax_3[2]) > 99);\n+  KEEP (strlen (ax_3[i]) > 999);\n+\n   KEEP (strlen (a3) < 2);\n   KEEP (strlen (a7) < 6);\n \n@@ -274,24 +265,48 @@ void keep_global_arrays (int i)\n   KEEP (strlen (ax) < 1);\n }\n \n-void keep_pointer_to_arrays (void)\n+void keep_pointer_to_arrays (int i)\n {\n   KEEP (strlen (*pa7) < 6);\n   KEEP (strlen (*pa5) < 4);\n   KEEP (strlen (*pa3) < 2);\n \n+  /* Since GCC cannot be trusted not to misuse a pointer to a smaller\n+     array to point to an object of a larger type verify that the bound\n+     in a pointer to an array of a known bound isn't relied on for\n+     the strlen range optimization.  If GCC is fixed to avoid these\n+     misuses these tests can be removed.  */\n+  KEEP (strlen (*pa7) > sizeof *pa7);\n+  KEEP (strlen (*pa5) > sizeof *pa5);\n+  KEEP (strlen (*pa3) > sizeof *pa3);\n+\n   KEEP (strlen ((*pa7_3)[0]) < 2);\n   KEEP (strlen ((*pa7_3)[1]) < 2);\n   KEEP (strlen ((*pa7_3)[6]) < 2);\n+  KEEP (strlen ((*pa7_3)[i]) < 2);\n+\n+  /* Same as above.  */\n+  KEEP (strlen ((*pa7_3)[0]) > sizeof *pa7_3);\n+  KEEP (strlen ((*pa7_3)[i]) > sizeof *pa7_3);\n \n   KEEP (strlen ((*pax_3)[0]) < 2);\n   KEEP (strlen ((*pax_3)[1]) < 2);\n   KEEP (strlen ((*pax_3)[9]) < 2);\n+  KEEP (strlen ((*pax_3)[i]) < 2);\n+\n+  /* Same as above.  */\n+  KEEP (strlen ((*pax_3)[0]) > 3);\n+  KEEP (strlen ((*pax_3)[i]) > 333);\n \n   KEEP (strlen ((*pa5_7)[0]) < 6);\n   KEEP (strlen ((*pa5_7)[1]) < 6);\n   KEEP (strlen ((*pa5_7)[4]) < 6);\n-}\n+  KEEP (strlen ((*pa5_7)[i]) < 6);\n+\n+  /* Same as above.  */\n+  KEEP (strlen ((*pa5_7)[0]) > sizeof *pa5_7);\n+  KEEP (strlen ((*pa5_7)[i]) > sizeof *pa5_7);\n+ }\n \n void keep_global_arrays_and_strings (int i)\n {\n@@ -306,6 +321,12 @@ void keep_global_arrays_and_strings (int i)\n   KEEP (strlen (i < 0 ? a7 : \"123\") < 5);\n   KEEP (strlen (i < 0 ? a7 : \"123456\") < 6);\n   KEEP (strlen (i < 0 ? a7 : \"1234567\") < 6);\n+\n+  /* Verify that a matrix is treated as a flat array even in a conditional\n+     expression (i.e., don't assume that a7_3[0] is nul-terminated, even\n+     though calling strlen() on such an array is undefined).  */\n+  KEEP (strlen (i < 0 ? a7_3[0] : \"\") > 7);\n+  KEEP (strlen (i < 0 ? a7_3[i] : \"\") > 7);\n }\n \n void keep_member_arrays_obj (int i)\n@@ -337,6 +358,12 @@ void keep_member_arrays_obj (int i)\n \n   KEEP (strlen (ma0_3_5_7[0][0][0].a5_7[0]) < 6);\n   KEEP (strlen (ma0_3_5_7[2][4][6].a5_7[4]) < 6);\n+\n+  /* Again, verify that the .a3 array isn't assumed to necessarily\n+     be nul-terminated.  */\n+  KEEP (strlen (ma0_3_5_7[0][0][0].a3) > 2);\n+  KEEP (strlen (ma0_3_5_7[0][0][6].a3) > 2);\n+  KEEP (strlen (ma0_3_5_7[0][0][i].a3) > 2);\n }\n \n void keep_member_arrays_ptr (struct MemArrays0 *ma0,\n@@ -353,6 +380,11 @@ void keep_member_arrays_ptr (struct MemArrays0 *ma0,\n   KEEP (strlen (ma0->a7_3[i]) < 2);\n   KEEP (strlen (ma0->a7_3[i]) < 2);\n \n+  /* Again, verify that the member array isn't assumed to necessarily\n+     be nul-terminated.  */\n+  KEEP (strlen (ma0->a7_3[0]) > sizeof ma0->a7_3);\n+  KEEP (strlen (ma0->a7_3[i]) > sizeof ma0->a7_3);\n+\n   KEEP (strlen (ma0->a5_7[0]) < 5);\n   KEEP (strlen (ma0[0].a5_7[0]) < 5);\n   KEEP (strlen (ma0[1].a5_7[0]) < 5);\n@@ -361,6 +393,9 @@ void keep_member_arrays_ptr (struct MemArrays0 *ma0,\n   KEEP (strlen (ma0[i].a5_7[4]) < 5);\n   KEEP (strlen (ma0[i].a5_7[i]) < 5);\n \n+  /* Same as above.  */\n+  KEEP (strlen (ma0[i].a5_7[i]) > sizeof ma0[i].a5_7);\n+\n   KEEP (strlen (ma0->a0) < DIFF_MAX - 2);\n   KEEP (strlen (ma0->a0) < 999);\n   KEEP (strlen (ma0->a0) < 1);\n@@ -389,5 +424,5 @@ void keep_pointers (const char *s)\n /* { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated_\" 0 \"optimized\" } }\n    { dg-final { scan-tree-dump-times \"call_in_false_branch_not_eliminated_\" 0 \"optimized\" } }\n \n-   { dg-final { scan-tree-dump-times \"call_made_in_true_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 92 \"optimized\" } }\n-   { dg-final { scan-tree-dump-times \"call_made_in_false_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 92 \"optimized\" } } */\n+   { dg-final { scan-tree-dump-times \"call_made_in_true_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 119 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"call_made_in_false_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 119 \"optimized\" } } */"}, {"sha": "3d879f1329ac946203d6f35d36976d10e0958519", "filename": "gcc/testsuite/gcc.dg/strlenopt-51.c", "status": "modified", "additions": 11, "deletions": 45, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef2da674ab7e8a9551e656e649359c2b27b026d/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-51.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef2da674ab7e8a9551e656e649359c2b27b026d/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-51.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-51.c?ref=eef2da674ab7e8a9551e656e649359c2b27b026d", "patch": "@@ -1,16 +1,17 @@\n /* PR tree-optimization/77357 - strlen of constant strings not folded\n    { dg-do compile }\n-   { dg-options \"-O2 -Wall -fdump-tree-gimple -fdump-tree-optimized\" } */\n+   { dg-options \"-O0 -Wall -fdump-tree-gimple\" } */\n \n #include \"strlenopt.h\"\n \n #define CONCAT(x, y) x ## y\n #define CAT(x, y) CONCAT (x, y)\n-#define FAILNAME(name) CAT (call_ ## name ##_on_line_, __LINE__)\n+#define FAILNAME(name, counter) \\\n+  CAT (CAT (CAT (call_ ## name ##_on_line_, __LINE__), _), counter)\n \n-#define FAIL(name) do {\t\t\t\t\\\n-    extern void FAILNAME (name) (void);\t\t\\\n-    FAILNAME (name)();\t\t\t\t\\\n+#define FAIL(name, counter) do {\t\t\t\\\n+    extern void FAILNAME (name, counter) (void);\t\\\n+    FAILNAME (name, counter)();\t\t\t\t\\\n   } while (0)\n \n /* Macro to emit a call to funcation named\n@@ -19,19 +20,7 @@\n    scan-tree-dump-time directive at the bottom of the test verifies\n    that no such call appears in output.  */\n #define ELIM(expr) \\\n-  if (!(expr)) FAIL (in_true_branch_not_eliminated); else (void)0\n-\n-/* Macro to emit a call to a function named\n-     call_made_in_{true,false}_branch_on_line_NNN()\n-   for each call that's expected to be retained.  The dg-final\n-   scan-tree-dump-time directive at the bottom of the test verifies\n-   that the expected number of both kinds of calls appears in output\n-   (a pair for each line with the invocation of the KEEP() macro.  */\n-#define KEEP(expr)\t\t\t\t\\\n-  if (expr)\t\t\t\t\t\\\n-    FAIL (made_in_true_branch);\t\t\t\\\n-  else\t\t\t\t\t\t\\\n-    FAIL (made_in_false_branch)\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated, __COUNTER__); else (void)0\n \n #define T(s, n) ELIM (strlen (s) == n)\n \n@@ -53,7 +42,7 @@ struct S\n \n const char a9[][9] = { S0, S1, S2, S3, S4, S5, S6, S7, S8 };\n \n-void test_elim_a9 (int i)\n+void test_elim_a9 (unsigned i)\n {\n   ELIM (strlen (&a9[0][i]) > 0);\n   ELIM (strlen (&a9[1][i]) > 1);\n@@ -75,10 +64,10 @@ const char a9_9[][9][9] = {\n   { S5, S6, S7, S8, S0, S1, S2, S3, S4 },\n   { S6, S7, S8, S0, S1, S2, S3, S4, S5 },\n   { S7, S8, S0, S1, S2, S3, S4, S5, S6 },\n-  { S8, S0, S2, S2, S3, S4, S5, S6, S7 }\n+  { S8, S0, S1, S2, S3, S4, S5, S6, S7 }\n };\n \n-void test_elim_a9_9 (int i)\n+void test_elim_a9_9 (unsigned i)\n {\n #undef T\n #define T(I)\t\t\t\t\t\\\n@@ -95,27 +84,4 @@ void test_elim_a9_9 (int i)\n   T (0); T (1); T (2); T (3); T (4); T (5); T (6); T (7); T (8);\n }\n \n-#line 1000\n-\n-void test_keep_a9_9 (int i)\n-{\n-#undef T\n-#define T(I)\t\t\t\t\t\\\n-  KEEP (strlen (&a9_9[i][I][0]) > (1 + I) % 9);\t\\\n-  KEEP (strlen (&a9_9[i][I][1]) > (1 + I) % 9);\t\\\n-  KEEP (strlen (&a9_9[i][I][2]) > (2 + I) % 9);\t\\\n-  KEEP (strlen (&a9_9[i][I][3]) > (3 + I) % 9);\t\\\n-  KEEP (strlen (&a9_9[i][I][4]) > (4 + I) % 9);\t\\\n-  KEEP (strlen (&a9_9[i][I][5]) > (5 + I) % 9);\t\\\n-  KEEP (strlen (&a9_9[i][I][6]) > (6 + I) % 9);\t\\\n-  KEEP (strlen (&a9_9[i][I][7]) > (7 + I) % 9);\t\\\n-  KEEP (strlen (&a9_9[i][I][8]) > (8 + I) % 9)\n-\n-  T (0); T (1); T (2); T (3); T (4); T (5); T (6); T (7); T (8);\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"strlen\" 72 \"gimple\" } }\n-   { dg-final { scan-tree-dump-times \"strlen\" 63 \"optimized\" } }\n-\n-   { dg-final { scan-tree-dump-times \"call_made_in_true_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 72 \"optimized\" } }\n-   { dg-final { scan-tree-dump-times \"call_made_in_false_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 81 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"gimple\" } } */"}, {"sha": "466dcde998a6678b3751c21ee9f75d5b98d0fb5f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr79376.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef2da674ab7e8a9551e656e649359c2b27b026d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79376.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef2da674ab7e8a9551e656e649359c2b27b026d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79376.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79376.c?ref=eef2da674ab7e8a9551e656e649359c2b27b026d", "patch": "@@ -40,7 +40,18 @@ void test_arrays (int i, struct Arrays *a)\n \n     int n = __builtin_snprintf (0, 0, \"%-s\", s);\n \n-    ASSERT (0 <= n && n < 3);\n+    /* Since it's undefined to pass an unterminated array to a %s\n+       directive it would be valid to assume that S above is not\n+       longer than sizeof (A->A3) but the optimization isn't done\n+       because the GIMPLE representation of the %s argument isn't\n+       suffficiently reliable not to confuse it for some other\n+       array.  The argument length is therefore assumed to be in\n+       the range [0, PTRDIFF_MAX - 2] and the sprintf result to be\n+       as big as INT_MAX and possibly even negative if the function\n+       were to fail due to a single directive resulting in more than\n+       the 4,095 byte maximum required to be supported.\n+       ASSERT (0 <= n && n < 3);\n+    */\n \n     ASSERT_MAYBE (0 == n);\n     ASSERT_MAYBE (1 == n);\n@@ -52,7 +63,7 @@ void test_arrays (int i, struct Arrays *a)\n \n     int n = __builtin_snprintf (0, 0, \"%-s\", s);\n \n-    ASSERT (0 <= n && n < 5);\n+    /* ASSERT (0 <= n && n < 5); */\n \n     ASSERT_MAYBE (0 == n);\n     ASSERT_MAYBE (1 == n);\n@@ -69,7 +80,7 @@ void test_string_and_array (int i, struct Arrays *a)\n \n     int n = __builtin_snprintf (0, 0, \"%-s\", s);\n \n-    ASSERT (0 <= n && n < 3);\n+    /* ASSERT (0 <= n && n < 3); */\n \n     ASSERT_MAYBE (0 == n);\n     ASSERT_MAYBE (1 == n);\n@@ -81,7 +92,7 @@ void test_string_and_array (int i, struct Arrays *a)\n \n     int n = __builtin_snprintf (0, 0, \"%-s\", s);\n \n-    ASSERT (0 <= n && n < 5);\n+    /* ASSERT (0 <= n && n < 5); */\n \n     ASSERT_MAYBE (0 == n);\n     ASSERT_MAYBE (1 == n);\n@@ -95,7 +106,7 @@ void test_string_and_array (int i, struct Arrays *a)\n \n     int n = __builtin_snprintf (0, 0, \"%-s\", s);\n \n-    ASSERT (0 <= n && n < 5);\n+    /* ASSERT (0 <= n && n < 5); */\n \n     ASSERT_MAYBE (0 == n);\n     ASSERT_MAYBE (1 == n);"}]}