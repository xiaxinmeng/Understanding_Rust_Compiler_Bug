{"sha": "f4f206f46f6946be3052e85e740d4ab5b5bae72e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRmMjA2ZjQ2ZjY5NDZiZTMwNTJlODVlNzQwZDRhYjViNWJhZTcyZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-12-21T21:07:32Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-12-21T21:07:32Z"}, "message": "call.c: Fix comment formatting.\n\n\t* call.c: Fix comment formatting.\n\t* class.c: Likewise.\n\t* cp-tree.h: Likewise.\n\t* cvt.c: Likewise.\n\t* cxx-pretty-print.c: Likewise.\n\t* decl.c: Likewise.\n\t* decl2.c: Likewise.\n\t* error.c: Likewise.\n\t* except.c: Likewise.\n\t* init.c: Likewise.\n\t* name-lookup.c: Likewise.\n\t* parser.c: Likewise.\n\t* pt.c: Likewise.\n\t* rtti.c: Likewise.\n\t* semantics.c: Likewise.\n\t* typeck.c: Likewise.\n\t* typeck2.c: Likewise.\n\nFrom-SVN: r74916", "tree": {"sha": "1b99bde9c925d59335b4bbe08a2be9ac1127bb4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b99bde9c925d59335b4bbe08a2be9ac1127bb4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4f206f46f6946be3052e85e740d4ab5b5bae72e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f206f46f6946be3052e85e740d4ab5b5bae72e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4f206f46f6946be3052e85e740d4ab5b5bae72e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f206f46f6946be3052e85e740d4ab5b5bae72e/comments", "author": null, "committer": null, "parents": [{"sha": "90f107de3bdc78e571790f6cebf089de648b38f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90f107de3bdc78e571790f6cebf089de648b38f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90f107de3bdc78e571790f6cebf089de648b38f9"}], "stats": {"total": 151, "additions": 86, "deletions": 65}, "files": [{"sha": "48758f6efbf444d8b0848cace96e3c6d184db1a7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -1,3 +1,23 @@\n+2003-12-21  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* call.c: Fix comment formatting.\n+\t* class.c: Likewise.\n+\t* cp-tree.h: Likewise.\n+\t* cvt.c: Likewise.\n+\t* cxx-pretty-print.c: Likewise.\n+\t* decl.c: Likewise.\n+\t* decl2.c: Likewise.\n+\t* error.c: Likewise.\n+\t* except.c: Likewise.\n+\t* init.c: Likewise.\n+\t* name-lookup.c: Likewise.\n+\t* parser.c: Likewise.\n+\t* pt.c: Likewise.\n+\t* rtti.c: Likewise.\n+\t* semantics.c: Likewise.\n+\t* typeck.c: Likewise.\n+\t* typeck2.c: Likewise.\n+\n 2003-12-19  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* cvt.c: Remove uses of \"register\" specifier in"}, {"sha": "2dc4f2240c640e0154b5efa43e93efcb3ff653be", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -1744,7 +1744,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t  type1 = type2;\n \t  break;\n \t}\n-      /* FALLTHROUGH */\n+      /* Fall through.  */\n     case LT_EXPR:\n     case GT_EXPR:\n     case LE_EXPR:\n@@ -2037,7 +2037,7 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n     case GT_EXPR:\n     case GE_EXPR:\n       enum_p = 1;\n-      /* FALLTHROUGH */\n+      /* Fall through.  */\n     \n     default:\n       ref1 = 0;\n@@ -4102,7 +4102,7 @@ convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner,\n     case RVALUE_CONV:\n       if (! IS_AGGR_TYPE (totype))\n \treturn expr;\n-      /* else fall through */\n+      /* Else fall through.  */\n     case BASE_CONV:\n       if (TREE_CODE (convs) == BASE_CONV && !NEED_TEMPORARY_P (convs))\n \t{"}, {"sha": "d11029567c426647083fb43de689c7363912758b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -1183,7 +1183,7 @@ handle_using_decl (tree using_decl, tree t)\n       return;\n     }\n   \n-  /* Make type T see field decl FDECL with access ACCESS.*/\n+  /* Make type T see field decl FDECL with access ACCESS.  */\n   if (flist)\n     for (; flist; flist = OVL_NEXT (flist))\n       {\n@@ -5039,7 +5039,7 @@ finish_struct_1 (tree t)\n      bases and members and add implicitly generated methods.  */\n   check_bases_and_members (t);\n \n-  /* Find the key method */\n+  /* Find the key method.  */\n   if (TYPE_CONTAINS_VPTR_P (t))\n     {\n       CLASSTYPE_KEY_METHOD (t) = key_method (t);"}, {"sha": "5c491f022338bf38c745e9bc568e4c08b2a89c47", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -1357,7 +1357,7 @@ struct lang_type GTY(())\n #define TYPE_HAS_DEFAULT_CONSTRUCTOR(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->h.has_default_ctor)\n \n-/* Nonzero means that this type contains a mutable member */\n+/* Nonzero means that this type contains a mutable member.  */\n #define CLASSTYPE_HAS_MUTABLE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_mutable)\n #define TYPE_HAS_MUTABLE_P(NODE) (cp_has_mutable_p (NODE))\n \n@@ -2894,7 +2894,7 @@ struct lang_decl GTY(())\n #define THUNK_VIRTUAL_OFFSET(DECL) \\\n   (LANG_DECL_U2_CHECK (FUNCTION_DECL_CHECK (DECL), 0)->virtual_offset)\n \n-/* A thunk which is equivalent to another thunk. */\n+/* A thunk which is equivalent to another thunk.  */\n #define THUNK_ALIAS(DECL) \\\n   (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->decl_flags.u.thunk_alias)\n \n@@ -2946,7 +2946,7 @@ typedef enum cp_lvalue_kind {\n   clk_ordinary = 1, /* An ordinary lvalue.  */\n   clk_class = 2,    /* An rvalue of class-type.  */\n   clk_bitfield = 4, /* An lvalue for a bit-field.  */\n-  clk_packed = 8    /* An lvalue for a packed field. */\n+  clk_packed = 8    /* An lvalue for a packed field.  */\n } cp_lvalue_kind;\n \n /* Various kinds of template specialization, instantiation, etc.  */"}, {"sha": "4672830ed60460d891222da11eca87150bb51cbd", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -835,7 +835,7 @@ convert_to_void (tree expr, const char *implicit)\n       /* These have already decayed to rvalue.  */\n       break;\n     \n-    case CALL_EXPR:   /* we have a special meaning for volatile void fn() */\n+    case CALL_EXPR:   /* We have a special meaning for volatile void fn().  */\n       break;\n     \n     case INDIRECT_REF:"}, {"sha": "53c677ab88aec046ac896fc0549659efb2a67cf6", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -619,7 +619,7 @@ pp_cxx_pm_expression (cxx_pretty_printer *pp, tree t)\n           pp_cxx_qualified_id (pp, t);\n           break;\n         }\n-      /* else fall through */\n+      /* Else fall through.  */\n     case MEMBER_REF:\n     case DOTSTAR_EXPR:\n       pp_cxx_pm_expression (pp, TREE_OPERAND (t, 0));"}, {"sha": "47ad1682d0cf579e93b1e23da205e05017f4d17c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -1856,7 +1856,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n   DECL_COMMON (newdecl) = DECL_COMMON (olddecl);\n   COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);\n \n-  /* If either declaration has a nondefault visibility, use it. */\n+  /* If either declaration has a nondefault visibility, use it.  */\n   if (DECL_VISIBILITY (olddecl) != VISIBILITY_DEFAULT)\n     {\n       if (DECL_VISIBILITY (newdecl) != VISIBILITY_DEFAULT\n@@ -3103,7 +3103,7 @@ cxx_init_decl_processing (void)\n \n /* Generate an initializer for a function naming variable from\n    NAME. NAME may be NULL, to indicate a dependent name.  TYPE_P is\n-   filled in with the type of the init. */\n+   filled in with the type of the init.  */\n \n tree\n cp_fname_init (const char* name, tree *type_p)\n@@ -3377,7 +3377,7 @@ fixup_anonymous_aggr (tree t)\n {\n   tree *q;\n \n-  /* Wipe out memory of synthesized methods */\n+  /* Wipe out memory of synthesized methods.  */\n   TYPE_HAS_CONSTRUCTOR (t) = 0;\n   TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 0;\n   TYPE_HAS_INIT_REF (t) = 0;\n@@ -4925,7 +4925,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n     mark_referenced (DECL_ASSEMBLER_NAME (decl));\n }\n \n-/* This is here for a midend callback from c-common.c */\n+/* This is here for a midend callback from c-common.c.  */\n \n void\n finish_decl (tree decl, tree init, tree asmspec_tree)\n@@ -6079,7 +6079,7 @@ compute_array_index_type (tree name, tree size)\n \t\t\t\t    cp_convert (ssizetype, size),\n \t\t\t\t    cp_convert (ssizetype, integer_one_node)));\n       if (!TREE_CONSTANT (itype))\n-\t/* A variable sized array. */\n+\t/* A variable sized array.  */\n \titype = variable_size (itype);\n       /* Make sure that there was no overflow when creating to a signed\n      \t index type.  (For example, on a 32-bit machine, an array with\n@@ -7088,7 +7088,7 @@ grokdeclarator (tree declarator,\n       else if (RIDBIT_SETP (RID_TYPEDEF, specbits))\n \t;\n       else if (decl_context == FIELD\n-\t       /* C++ allows static class elements  */\n+\t       /* C++ allows static class elements.  */\n \t       && RIDBIT_SETP (RID_STATIC, specbits))\n \t/* C++ also allows inlines and signed and unsigned elements,\n \t   but in those cases we don't come in here.  */\n@@ -8196,7 +8196,7 @@ grokdeclarator (tree declarator,\n \t      return void_type_node;\n \t  }\n \n-\t/* Structure field.  It may not be a function, except for C++ */\n+\t/* Structure field.  It may not be a function, except for C++.  */\n \n \tif (decl == NULL_TREE)\n \t  {\n@@ -8421,7 +8421,7 @@ require_complete_types_for_parms (tree parms)\n   for (; parms; parms = TREE_CHAIN (parms))\n     {\n       if (VOID_TYPE_P (TREE_TYPE (parms)))\n-        /* grokparms will have already issued an error */\n+        /* grokparms will have already issued an error.  */\n         TREE_TYPE (parms) = error_mark_node;\n       else if (complete_type_or_else (TREE_TYPE (parms), parms))\n \t{\n@@ -10938,7 +10938,7 @@ start_method (tree declspecs, tree declarator, tree attrlist)\n \n   cp_finish_decl (fndecl, NULL_TREE, NULL_TREE, 0);\n \n-  /* Make a place for the parms */\n+  /* Make a place for the parms.  */\n   begin_scope (sk_function_parms, fndecl);\n \n   DECL_IN_AGGR_P (fndecl) = 1;"}, {"sha": "726251f98fae05400db6f20bb958b882277d943b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -1306,12 +1306,12 @@ coerce_new_type (tree type)\n   {\n     case 2:\n       args = tree_cons (NULL_TREE, size_type_node, args);\n-      /* FALLTHROUGH */\n+      /* Fall through.  */\n     case 1:\n       type = build_exception_variant\n               (build_function_type (ptr_type_node, args),\n                TYPE_RAISES_EXCEPTIONS (type));\n-      /* FALLTHROUGH */\n+      /* Fall through.  */\n     default:;\n   }\n   return type;\n@@ -1340,12 +1340,12 @@ coerce_delete_type (tree type)\n   {\n     case 2:\n       args = tree_cons (NULL_TREE, ptr_type_node, args);\n-      /* FALLTHROUGH */\n+      /* Fall through.  */\n     case 1:\n       type = build_exception_variant\n               (build_function_type (void_type_node, args),\n                TYPE_RAISES_EXCEPTIONS (type));\n-      /* FALLTHROUGH */\n+      /* Fall through.  */\n     default:;\n   }\n "}, {"sha": "bb6ff341572f359a079357199e11ecb039704f64", "filename": "gcc/cp/error.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -331,7 +331,7 @@ dump_type (tree t, int flags)\n                      ? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t), flags);\n           break;\n         }\n-      /* else fallthrough */\n+      /* Else fall through.  */\n \n     case TEMPLATE_DECL:\n     case NAMESPACE_DECL:\n@@ -644,7 +644,7 @@ dump_type_suffix (tree t, int flags)\n       dump_type_suffix (TREE_TYPE (t), flags);\n       break;\n \n-      /* Can only be reached through function pointer */\n+      /* Can only be reached through function pointer.  */\n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n       {\n@@ -788,7 +788,7 @@ dump_decl (tree t, int flags)\n \t  dump_type (DECL_CONTEXT (t), flags);\n \t  break;\n \t}\n-      /* else fall through */\n+      /* Else fall through.  */\n     case FIELD_DECL:\n     case PARM_DECL:\n       dump_simple_decl (t, TREE_TYPE (t), flags);\n@@ -1050,7 +1050,7 @@ dump_function_decl (tree t, int flags)\n \n   if (DECL_CLASS_SCOPE_P (t))\n     cname = DECL_CONTEXT (t);\n-  /* this is for partially instantiated template methods */\n+  /* This is for partially instantiated template methods.  */\n   else if (TREE_CODE (fntype) == METHOD_TYPE)\n     cname = TREE_TYPE (TREE_VALUE (parmtypes));\n \n@@ -1269,7 +1269,7 @@ dump_template_parms (tree info, int primary, int flags)\n   pp_template_argument_list_end (cxx_pp);\n }\n \n-/* Print out a list of initializers (subr of dump_expr) */\n+/* Print out a list of initializers (subr of dump_expr).  */\n \n static void\n dump_expr_list (tree l, int flags)\n@@ -1596,7 +1596,7 @@ dump_expr (tree t, int flags)\n \t        pp_right_paren (cxx_pp);\n \t      break;\n \t    }\n-\t  /* else FALLTHRU */\n+\t  /* Else fall through.  */\n \t}\n       dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n       break;"}, {"sha": "03a3274e90a54af161e8f72cd2736e276a1c6d3d", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -296,7 +296,7 @@ choose_personality_routine (enum languages lang)\n       return;\n \n     case chose_none:\n-      ; /* proceed to language selection */\n+      ; /* Proceed to language selection.  */\n     }\n \n   switch (lang)\n@@ -892,7 +892,7 @@ can_convert_eh (tree to, tree from)\n       if (TREE_CODE (to) == VOID_TYPE)\n \treturn 1;\n \n-      /* else fall through */\n+      /* Else fall through.  */\n     }\n \n   if (CLASS_TYPE_P (to) && CLASS_TYPE_P (from)"}, {"sha": "0b1b66c496009f56886779be311338a19a52062b", "filename": "gcc/cp/init.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -1121,7 +1121,7 @@ build_aggr_init (tree exp, tree init, int flags)\n     }\n \n   if (TREE_CODE (exp) == VAR_DECL || TREE_CODE (exp) == PARM_DECL)\n-    /* just know that we've seen something for this node */\n+    /* Just know that we've seen something for this node.  */\n     TREE_USED (exp) = 1;\n \n   TREE_TYPE (exp) = TYPE_MAIN_VARIANT (type);\n@@ -1499,7 +1499,7 @@ build_offset_ref (tree type, tree name, bool address_p)\n \n       if (TREE_CODE (t) != TEMPLATE_ID_EXPR && !really_overloaded_fn (t))\n \t{\n-\t  /* Get rid of a potential OVERLOAD around it */\n+\t  /* Get rid of a potential OVERLOAD around it.  */\n \t  t = OVL_CURRENT (t);\n \n \t  /* Unique functions are handled easily.  */\n@@ -1687,7 +1687,7 @@ build_new (tree placement, tree decl, tree init, int use_global_new)\n \n       if (absdcl && TREE_CODE (absdcl) == ARRAY_REF)\n \t{\n-\t  /* probably meant to be a vec new */\n+\t  /* Probably meant to be a vec new.  */\n \t  tree this_nelts;\n \n \t  while (TREE_OPERAND (absdcl, 0)\n@@ -1842,7 +1842,7 @@ build_java_class_ref (tree type)\n       jclass_node = TREE_TYPE (jclass_node);\n     }\n \n-  /* Mangle the class$ field */\n+  /* Mangle the class$ field.  */\n   {\n     tree field;\n     for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n@@ -2855,7 +2855,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n       if (TREE_SIDE_EFFECTS (addr))\n \taddr = save_expr (addr);\n \n-      /* throw away const and volatile on target type of addr */\n+      /* Throw away const and volatile on target type of addr.  */\n       addr = convert_force (build_pointer_type (type), addr, 0);\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n@@ -3115,7 +3115,8 @@ build_vec_delete (tree base, tree maxindex,\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n-      /* get the total number of things in the array, maxindex is a bad name */\n+      /* Get the total number of things in the array, maxindex is a\n+\t bad name.  */\n       maxindex = array_type_nelts_total (type);\n       type = strip_array_types (type);\n       base = build_unary_op (ADDR_EXPR, base, 1);"}, {"sha": "f19987d055f8449b2e701bb49d9de028c9d5349b", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -525,7 +525,7 @@ add_decl_to_level (tree decl, cxx_scope *b)\n       b->names = decl;\n       b->names_size++;\n \n-      /* If appropriate, add decl to separate list of statics */\n+      /* If appropriate, add decl to separate list of statics.  */\n       if (b->kind == sk_namespace)\n \tif ((TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n \t    || (TREE_CODE (decl) == FUNCTION_DECL\n@@ -1269,7 +1269,7 @@ begin_scope (scope_kind kind, tree entity)\n     case sk_template_spec:\n       scope->explicit_spec_p = true;\n       kind = sk_template_parms;\n-      /* fall through */\n+      /* Fall through.  */\n     case sk_template_parms:\n     case sk_block:\n     case sk_try:"}, {"sha": "12c883e7bf2fdafa7d5081102c55ce80e642f878", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -2022,7 +2022,7 @@ cp_parser_skip_to_closing_parenthesis (cp_parser *parser,\n \n       token = cp_lexer_peek_token (parser->lexer);\n       \n-      /* This matches the processing in skip_to_end_of_statement */\n+      /* This matches the processing in skip_to_end_of_statement.  */\n       if (token->type == CPP_SEMICOLON && !brace_depth)\n \treturn 0;\n       if (token->type == CPP_OPEN_BRACE)"}, {"sha": "d8b953a468641b228affd2c0cdad159f49837f29", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -2223,7 +2223,7 @@ process_template_parm (tree list, tree next)\n       else\n \t{\n \t  t = make_aggr_type (TEMPLATE_TYPE_PARM);\n-\t  /* parm is either IDENTIFIER_NODE or NULL_TREE */\n+\t  /* parm is either IDENTIFIER_NODE or NULL_TREE.  */\n \t  decl = build_decl (TYPE_DECL, parm, t);\n \t}\n         \n@@ -3889,7 +3889,7 @@ mangle_class_name_for_template (const char* name, tree parms, tree arglist)\n \t      cat (IDENTIFIER_POINTER (DECL_NAME (arg)));\n \t    }\n \t  else\n-\t    /* Output the parameter declaration */\n+\t    /* Output the parameter declaration.  */\n \t    cat (type_as_string (arg, TFF_CHASE_TYPEDEF));\n \t  continue;\n \t}\n@@ -4630,7 +4630,7 @@ for_each_template_parm_r (tree* tp, int* walk_subtrees, void* d)\n       break;\n \n     case TEMPLATE_DECL:\n-      /* A template template parameter is encountered */\n+      /* A template template parameter is encountered.  */\n       if (DECL_TEMPLATE_TEMPLATE_PARM_P (t)\n \t  && for_each_template_parm (TREE_TYPE (t), fn, data, pfd->visited))\n \treturn error_mark_node;\n@@ -5755,7 +5755,7 @@ tsubst_aggr_type (tree t,\n       if (TYPE_PTRMEMFUNC_P (t))\n \treturn tsubst (TYPE_PTRMEMFUNC_FN_TYPE (t), args, complain, in_decl);\n \n-      /* else fall through */\n+      /* Else fall through.  */\n     case ENUMERAL_TYPE:\n     case UNION_TYPE:\n       if (TYPE_TEMPLATE_INFO (t))\n@@ -6692,7 +6692,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\telse if (TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t\t  {\n \t\t    /* We are processing a type constructed from\n-\t\t       a template template parameter */\n+\t\t       a template template parameter.  */\n \t\t    tree argvec = tsubst (TYPE_TI_ARGS (t),\n \t\t\t\t\t  args, complain, in_decl);\n \t\t    if (argvec == error_mark_node)\n@@ -8627,7 +8627,7 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n      deferring all checks until we have the FUNCTION_DECL.  */\n   push_deferring_access_checks (dk_deferred);\n \n-  /* substitute template parameters */\n+  /* Substitute template parameters.  */\n   fndecl = tsubst (DECL_TEMPLATE_RESULT (gen_tmpl),\n \t\t   targ_ptr, complain, gen_tmpl);\n \n@@ -9055,7 +9055,7 @@ type_unification_real (tree tparms,\n      are present, and the parm list isn't variadic.  */\n   if (args && args != void_list_node && parms == void_list_node)\n     return 1;\n-  /* Fail if parms are left and they don't have default values.\t */\n+  /* Fail if parms are left and they don't have default values.  */\n   if (parms\n       && parms != void_list_node\n       && TREE_PURPOSE (parms) == NULL_TREE)\n@@ -9993,7 +9993,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \n \t  return unify (tparms, targs, t1, t, strict);\n \t}\n-      /* else fall through */\n+      /* Else fall through.  */\n \n     default:\n       if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (parm))))"}, {"sha": "a965383ad4e3d5abae4da71a57895bdcb148dda7", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -1065,7 +1065,7 @@ get_pseudo_ti_init (tree type, tree var_desc, bool *non_public_p)\n \t      else\n \t\toffset = BINFO_OFFSET (base_binfo);\n               \n-              /* combine offset and flags into one field */\n+              /* Combine offset and flags into one field.  */\n               offset = cp_build_binary_op (LSHIFT_EXPR, offset,\n \t\t\t\t\t   build_int_2 (8, 0));\n               offset = cp_build_binary_op (BIT_IOR_EXPR, offset,"}, {"sha": "c9a4a68a40a0b127c5f7e3803ba8cf795e692dde", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -1232,7 +1232,7 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n \ttype = TREE_TYPE (type);\n       else\n \t{\n-\t  /* Set the cv qualifiers */\n+\t  /* Set the cv qualifiers.  */\n \t  int quals = cp_type_quals (TREE_TYPE (current_class_ref));\n \t  \n \t  if (DECL_MUTABLE_P (decl))"}, {"sha": "b76d5360e12a28d8582155f353f3bde64530f52c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -900,7 +900,7 @@ comptypes (tree t1, tree t2, int strict)\n   if (t1 == t2)\n     return true;\n \n-  /* Suppress errors caused by previously reported errors */\n+  /* Suppress errors caused by previously reported errors.  */\n   if (t1 == error_mark_node || t2 == error_mark_node)\n     return false;\n   \n@@ -974,7 +974,7 @@ comptypes (tree t1, tree t2, int strict)\n \treturn true;\n       /* Don't check inheritance.  */\n       strict = COMPARE_STRICT;\n-      /* fall through */\n+      /* Fall through.  */\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n@@ -995,7 +995,7 @@ comptypes (tree t1, tree t2, int strict)\n       if (!comptypes (TYPE_OFFSET_BASETYPE (t1), TYPE_OFFSET_BASETYPE (t2),\n \t\t      strict & ~COMPARE_REDECLARATION))\n \treturn false;\n-      /* FALLTHROUGH*/\n+      /* Fall through. */\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n@@ -2583,7 +2583,7 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n \n   if (typetail != 0 && typetail != void_list_node)\n     {\n-      /* See if there are default arguments that can be used */\n+      /* See if there are default arguments that can be used.  */\n       if (TREE_PURPOSE (typetail) \n \t  && TREE_CODE (TREE_PURPOSE (typetail)) != DEFAULT_ARG)\n \t{\n@@ -3501,7 +3501,7 @@ build_x_unary_op (enum tree_code code, tree xarg)\n       && ((IS_AGGR_TYPE_CODE (TREE_CODE (TREE_TYPE (xarg)))\n \t   && !COMPLETE_TYPE_P (TREE_TYPE (xarg)))\n \t  || (TREE_CODE (xarg) == OFFSET_REF)))\n-    /* don't look for a function */;\n+    /* Don't look for a function.  */;\n   else\n     exp = build_new_op (code, LOOKUP_NORMAL, xarg, NULL_TREE, NULL_TREE);\n   if (!exp && code == ADDR_EXPR)\n@@ -3907,7 +3907,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t  return arg;\n \t}\n \n-      /* For &x[y], return x+y */\n+      /* For &x[y], return x+y.  */\n       if (TREE_CODE (arg) == ARRAY_REF)\n \t{\n \t  if (!cxx_mark_addressable (TREE_OPERAND (arg, 0)))\n@@ -4230,10 +4230,10 @@ cxx_mark_addressable (tree exp)\n \tif (x == current_class_ptr)\n \t  {\n             error (\"cannot take the address of `this', which is an rvalue expression\");\n-\t    TREE_ADDRESSABLE (x) = 1; /* so compiler doesn't die later */\n+\t    TREE_ADDRESSABLE (x) = 1; /* so compiler doesn't die later.  */\n \t    return true;\n \t  }\n-\t/* FALLTHRU */\n+\t/* Fall through.  */\n \n       case VAR_DECL:\n \t/* Caller should not be trying to mark initialized\n@@ -4242,7 +4242,7 @@ cxx_mark_addressable (tree exp)\n \t\t\t    || DECL_IN_AGGR_P (x) == 0\n \t\t\t    || TREE_STATIC (x)\n \t\t\t    || DECL_EXTERNAL (x), 314);\n-\t/* FALLTHRU */\n+\t/* Fall through.  */\n \n       case CONST_DECL:\n       case RESULT_DECL:\n@@ -4927,7 +4927,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n   /* Handle control structure constructs used as \"lvalues\".  */\n   switch (TREE_CODE (lhs))\n     {\n-      /* Handle --foo = 5; as these are valid constructs in C++ */\n+      /* Handle --foo = 5; as these are valid constructs in C++.  */\n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n       if (TREE_SIDE_EFFECTS (TREE_OPERAND (lhs, 0)))\n@@ -5006,7 +5006,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t  return result;\n \t}\n       else if (! IS_AGGR_TYPE (lhstype))\n-\t/* Do the default thing */;\n+\t/* Do the default thing.  */;\n       else\n \t{\n \t  result = build_special_member_call (lhs, complete_ctor_identifier,\n@@ -5033,7 +5033,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t{\n \t  /* `operator=' is not an inheritable operator.  */\n \t  if (! IS_AGGR_TYPE (lhstype))\n-\t    /* Do the default thing */;\n+\t    /* Do the default thing.  */;\n \t  else\n \t    {\n \t      result = build_new_op (MODIFY_EXPR, LOOKUP_NORMAL,\n@@ -6186,7 +6186,7 @@ cp_type_quals (tree type)\n   return TYPE_QUALS (type);\n }\n \n-/* Returns nonzero if the TYPE contains a mutable member */\n+/* Returns nonzero if the TYPE contains a mutable member.  */\n \n bool\n cp_has_mutable_p (tree type)"}, {"sha": "f839dddb300b0e0f05e6301d90f2959b33fd3888", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f206f46f6946be3052e85e740d4ab5b5bae72e/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=f4f206f46f6946be3052e85e740d4ab5b5bae72e", "patch": "@@ -615,7 +615,7 @@ process_init_constructor (tree type, tree init, tree* elts)\n \t\t   - TREE_INT_CST_LOW (TYPE_MIN_VALUE (domain))\n \t\t   + 1);\n \t  else\n-\t    len = -1;  /* Take as many as there are */\n+\t    len = -1;  /* Take as many as there are.  */\n \t}\n       else\n \t{\n@@ -1131,7 +1131,7 @@ build_functional_cast (tree exp, tree parms)\n \n   if (! IS_AGGR_TYPE (type))\n     {\n-      /* this must build a C cast */\n+      /* This must build a C cast.  */\n       if (parms == NULL_TREE)\n \tparms = integer_zero_node;\n       else"}]}