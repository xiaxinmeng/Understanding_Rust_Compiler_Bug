{"sha": "b4ee5a7269b4712db5cbd8e71eefad7df5fbec54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRlZTVhNzI2OWI0NzEyZGI1Y2JkOGU3MWVlZmFkN2RmNWZiZWM1NA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-02-15T06:40:27Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-02-15T06:40:27Z"}, "message": "* expr.c (store_constructor):  Don't use get_set_constructor_words.\n\nFrom-SVN: r8954", "tree": {"sha": "96a3592e65006ae07dc65ef9ce3f396e976edff6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96a3592e65006ae07dc65ef9ce3f396e976edff6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4ee5a7269b4712db5cbd8e71eefad7df5fbec54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4ee5a7269b4712db5cbd8e71eefad7df5fbec54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4ee5a7269b4712db5cbd8e71eefad7df5fbec54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4ee5a7269b4712db5cbd8e71eefad7df5fbec54/comments", "author": null, "committer": null, "parents": [{"sha": "4aad31acda5e2dabbd65db4ff3d916fead3400fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aad31acda5e2dabbd65db4ff3d916fead3400fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4aad31acda5e2dabbd65db4ff3d916fead3400fd"}], "stats": {"total": 66, "additions": 37, "deletions": 29}, "files": [{"sha": "d46498e5f0f3a1984b903eb60feea63128b7ed21", "filename": "gcc/expr.c", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ee5a7269b4712db5cbd8e71eefad7df5fbec54/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ee5a7269b4712db5cbd8e71eefad7df5fbec54/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b4ee5a7269b4712db5cbd8e71eefad7df5fbec54", "patch": "@@ -188,7 +188,6 @@ static rtx compare\t\tPROTO((tree, enum rtx_code, enum rtx_code));\n static rtx do_store_flag\tPROTO((tree, rtx, enum machine_mode, int));\n static tree defer_cleanups_to\tPROTO((tree));\n extern void (*interim_eh_hook)\tPROTO((tree));\n-extern tree get_set_constructor_words PROTO((tree, HOST_WIDE_INT*, int));\n \n /* Record for each mode whether we can move a register directly to or\n    from an object of that mode in memory.  If we can't, we won't try\n@@ -3111,7 +3110,6 @@ store_constructor (exp, target)\n       rtx xtarget = XEXP (target, 0);\n       int set_word_size = TYPE_ALIGN (type);\n       int nbytes = int_size_in_bytes (type);\n-      int nwords;\n       tree non_const_elements;\n       int need_to_clear_first;\n       tree domain = TYPE_DOMAIN (type);\n@@ -3137,10 +3135,6 @@ store_constructor (exp, target)\n       if (nbytes < 0)\n \tabort();\n \n-      nwords = (nbytes * BITS_PER_UNIT) / set_word_size;\n-      if (nwords == 0)\n-\tnwords = 1;\n-\n       domain_min = convert (sizetype, TYPE_MIN_VALUE (domain));\n       domain_max = convert (sizetype, TYPE_MAX_VALUE (domain));\n       bitlength = size_binop (PLUS_EXPR,\n@@ -3157,32 +3151,46 @@ store_constructor (exp, target)\n \t}\n       else\n \t{\n-\t  HOST_WIDE_INT *buffer\n-\t    = (HOST_WIDE_INT*) alloca (sizeof (HOST_WIDE_INT) * nwords);\n-\t  non_const_elements = get_set_constructor_words (exp, buffer, nwords);\n-\n-\t  if (nbytes * BITS_PER_UNIT <= set_word_size)\n-\t    {\n-\t      if (BITS_BIG_ENDIAN)\n-\t\tbuffer[0] >>= set_word_size - nbytes * BITS_PER_UNIT;\n-\t      emit_move_insn (target, GEN_INT (buffer[0]));\n-\t    }\n-\t  else\n+\t  int nbits = nbytes * BITS_PER_UNIT;\n+\t  int set_word_size = TYPE_ALIGN (TREE_TYPE (exp));\n+\t  enum machine_mode mode = mode_for_size (set_word_size, MODE_INT, 1);\n+\t  char *bit_buffer = (char*) alloca (nbits);\n+\t  HOST_WIDE_INT word = 0;\n+\t  int bit_pos = 0;\n+\t  int ibit = 0;\n+\t  int offset = 0;  /* In bytes from beginning of set. */\n+\t  non_const_elements = get_set_constructor_bits (exp,\n+\t\t\t\t\t\t\t bit_buffer, nbits);\n+\t  for (;;)\n \t    {\n-\t      rtx addr = XEXP (target, 0);\n-\t      rtx to_rtx;\n-\t      register int i;\n-\t      enum machine_mode mode\n-\t\t= mode_for_size (set_word_size, MODE_INT, 1);\n-\n-\t      for (i = 0; i < nwords; i++)\n+\t      if (bit_buffer[ibit])\n+\t\t{\n+\t\t  if (BITS_BIG_ENDIAN)\n+\t\t    word |= (1 << (set_word_size - 1 - bit_pos));\n+\t\t  else\n+\t\t    word |= 1 << bit_pos;\n+\t\t}\n+\t      bit_pos++;  ibit++;\n+\t      if (bit_pos >= set_word_size || ibit == nbits)\n \t\t{\n-\t\t  int offset = i * set_word_size / BITS_PER_UNIT;\n-\t\t  rtx datum = GEN_INT (buffer[i]);\n-\t\t  rtx to_rtx = change_address (target, mode,\n-\t\t\t\t\t       plus_constant (addr, offset));\n-\t\t  MEM_IN_STRUCT_P (to_rtx) = 1;\n+\t\t  rtx datum = GEN_INT (word);\n+\t\t  rtx to_rtx;\n+\t\t  /* The assumption here is that it is safe to use XEXP if\n+\t\t     the set is multi-word, but not if it's single-word. */\n+\t\t  if (GET_CODE (target) == MEM)\n+\t\t    to_rtx = change_address (target, mode,\n+\t\t\t\t\t     plus_constant (XEXP (target, 0),\n+\t\t\t\t\t\t\t    offset));\n+\t\t  else if (offset == 0) \n+\t\t    to_rtx = target;\n+\t\t  else\n+\t\t    abort ();\n \t\t  emit_move_insn (to_rtx, datum);\n+\t\t  if (ibit == nbits)\n+\t\t    break;\n+\t\t  word = 0;\n+\t\t  bit_pos = 0;\n+\t\t  offset += set_word_size / BITS_PER_UNIT;\n \t\t}\n \t    }\n \t  need_to_clear_first = 0;"}]}