{"sha": "3234b52d0bc60cca2f726dc54364aeef9eb94840", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzIzNGI1MmQwYmM2MGNjYTJmNzI2ZGM1NDM2NGFlZWY5ZWI5NDg0MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-01-30T19:16:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-01-30T19:16:39Z"}, "message": "varasm.c (struct rtx_const, [...]): Remove.\n\n        * varasm.c (struct rtx_const, struct pool_constant): Remove.\n        (MAX_RTX_HASH_TABLE): Remove.\n        (const_rtx_hash_table, const_rtx_sym_hash_table): Remove.\n        (first_pool, last_pool, pool_offset): Remove.\n        (struct rtx_constant_pool): Split out from ...\n        (struct varasm_status): ... here.  Reference one via pointer.\n        (struct constant_descriptor_rtx): Merge struct pool_constant.\n        (SYMHASH): Remove.\n        (decode_rtx_const): Remove.\n        (const_hash_rtx, compare_constant_rtx): Remove.\n        (record_constant_rtx): Remove.\n        (const_desc_rtx_hash, const_desc_rtx_eq): New.\n        (const_desc_rtx_sym_hash, const_desc_rtx_sym_eq): New.\n        (const_rtx_hash_1, const_rtx_hash): New.\n        (init_varasm_status): Allocate a rtx_constant_pool, and its hashes.\n        (simplify_subtraction): Use simplify_rtx.\n        (force_const_mem): Rewrite to use new data structures.\n        (find_pool_constant): Likewise.\n        (get_pool_constant, get_pool_constant_mark,\n        get_pool_constant_for_function, get_pool_mode,\n        get_pool_mode_for_function, get_pool_offset, get_pool_size): Likewise.\n        (output_constant_pool_2): Split out from output_constant_pool.\n        (output_constant_pool_1): Likewise.  Use new pool datastructures.\n        (output_constant_pool): Zap entire pool datastructure.\n        (mark_constant): Use new pool datastructures.\n        (mark_constants): Use for_each_rtx.\n        (mark_constant_pool): Use new pool datastructures.\n\nFrom-SVN: r76985", "tree": {"sha": "9ca3f4aaeff79679a372cae3a8282159578b00eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ca3f4aaeff79679a372cae3a8282159578b00eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3234b52d0bc60cca2f726dc54364aeef9eb94840", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3234b52d0bc60cca2f726dc54364aeef9eb94840", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3234b52d0bc60cca2f726dc54364aeef9eb94840", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3234b52d0bc60cca2f726dc54364aeef9eb94840/comments", "author": null, "committer": null, "parents": [{"sha": "be77d9e73e5f42f129ddc03c91937d36b8a0286f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be77d9e73e5f42f129ddc03c91937d36b8a0286f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be77d9e73e5f42f129ddc03c91937d36b8a0286f"}], "stats": {"total": 1034, "additions": 408, "deletions": 626}, "files": [{"sha": "b566b7180abe6a0bee9533ff4b0464c060ff8f30", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3234b52d0bc60cca2f726dc54364aeef9eb94840/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3234b52d0bc60cca2f726dc54364aeef9eb94840/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3234b52d0bc60cca2f726dc54364aeef9eb94840", "patch": "@@ -1,3 +1,33 @@\n+2004-01-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* varasm.c (struct rtx_const, struct pool_constant): Remove.\n+\t(MAX_RTX_HASH_TABLE): Remove.\n+\t(const_rtx_hash_table, const_rtx_sym_hash_table): Remove.\n+\t(first_pool, last_pool, pool_offset): Remove.\n+\t(struct rtx_constant_pool): Split out from ...\n+\t(struct varasm_status): ... here.  Reference one via pointer.\n+\t(struct constant_descriptor_rtx): Merge struct pool_constant.\n+\t(SYMHASH): Remove.\n+\t(decode_rtx_const): Remove.\n+\t(const_hash_rtx, compare_constant_rtx): Remove.\n+\t(record_constant_rtx): Remove.\n+\t(const_desc_rtx_hash, const_desc_rtx_eq): New.\n+\t(const_desc_rtx_sym_hash, const_desc_rtx_sym_eq): New.\n+\t(const_rtx_hash_1, const_rtx_hash): New.\n+\t(init_varasm_status): Allocate a rtx_constant_pool, and its hashes.\n+\t(simplify_subtraction): Use simplify_rtx.\n+\t(force_const_mem): Rewrite to use new data structures.\n+\t(find_pool_constant): Likewise.\n+\t(get_pool_constant, get_pool_constant_mark,\n+\tget_pool_constant_for_function, get_pool_mode,\n+\tget_pool_mode_for_function, get_pool_offset, get_pool_size): Likewise.\n+\t(output_constant_pool_2): Split out from output_constant_pool.\n+\t(output_constant_pool_1): Likewise.  Use new pool datastructures.\n+\t(output_constant_pool): Zap entire pool datastructure.\n+\t(mark_constant): Use new pool datastructures.\n+\t(mark_constants): Use for_each_rtx.\n+\t(mark_constant_pool): Use new pool datastructures.\n+\n 2004-01-30  Fariborz Jahanian <fjahanian@apple.com>\n         \n         * config/rs6000/rs6000.c (rs6000_emit_move): Remove #if 0. "}, {"sha": "f9acb3895ab32831c657b83b766c7ae8e3ba3643", "filename": "gcc/varasm.c", "status": "modified", "additions": 378, "deletions": 626, "changes": 1004, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3234b52d0bc60cca2f726dc54364aeef9eb94840/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3234b52d0bc60cca2f726dc54364aeef9eb94840/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=3234b52d0bc60cca2f726dc54364aeef9eb94840", "patch": "@@ -69,44 +69,18 @@ const char *weak_global_object_name;\n \n struct addr_const;\n struct constant_descriptor_rtx;\n-struct rtx_const;\n-struct pool_constant;\n-\n-#define MAX_RTX_HASH_TABLE 61\n+struct rtx_constant_pool;\n \n struct varasm_status GTY(())\n {\n-  /* Hash facility for making memory-constants\n-     from constant rtl-expressions.  It is used on RISC machines\n-     where immediate integer arguments and constant addresses are restricted\n-     so that such constants must be stored in memory.\n-\n-     This pool of constants is reinitialized for each function\n-     so each function gets its own constants-pool that comes right before\n-     it.  */\n-  struct constant_descriptor_rtx ** GTY ((length (\"MAX_RTX_HASH_TABLE\")))\n-    x_const_rtx_hash_table;\n-  struct pool_constant ** GTY ((length (\"MAX_RTX_HASH_TABLE\")))\n-    x_const_rtx_sym_hash_table;\n-\n-  /* Pointers to first and last constant in pool.  */\n-  struct pool_constant *x_first_pool;\n-  struct pool_constant *x_last_pool;\n-\n-  /* Current offset in constant pool (does not include any machine-specific\n-     header).  */\n-  HOST_WIDE_INT x_pool_offset;\n+  /* If we're using a per-function constant pool, this is it.  */\n+  struct rtx_constant_pool *pool;\n \n   /* Number of tree-constants deferred during the expansion of this\n      function.  */\n   unsigned int deferred_constants;\n };\n \n-#define const_rtx_hash_table (cfun->varasm->x_const_rtx_hash_table)\n-#define const_rtx_sym_hash_table (cfun->varasm->x_const_rtx_sym_hash_table)\n-#define first_pool (cfun->varasm->x_first_pool)\n-#define last_pool (cfun->varasm->x_last_pool)\n-#define pool_offset (cfun->varasm->x_pool_offset)\n #define n_deferred_constants (cfun->varasm->deferred_constants)\n \n /* Number for making the label on the next\n@@ -147,16 +121,6 @@ static hashval_t const_hash_1 (const tree);\n static int compare_constant (const tree, const tree);\n static tree copy_constant (tree);\n static void output_constant_def_contents (rtx);\n-static void decode_rtx_const (enum machine_mode, rtx, struct rtx_const *);\n-static unsigned int const_hash_rtx (enum machine_mode, rtx);\n-static int compare_constant_rtx (enum machine_mode, rtx,\n-\t\t\t\t struct constant_descriptor_rtx *);\n-static struct constant_descriptor_rtx * record_constant_rtx\n-  (enum machine_mode, rtx);\n-static struct pool_constant *find_pool_constant (struct function *, rtx);\n-static void mark_constant_pool (void);\n-static void mark_constants (rtx);\n-static int mark_constant (rtx *current_rtx, void *data);\n static void output_addressed_constants (tree);\n static unsigned HOST_WIDE_INT array_size_for_constructor (tree);\n static unsigned min_align (unsigned, unsigned);\n@@ -2025,36 +1989,6 @@ decode_addr_const (tree exp, struct addr_const *value)\n   value->offset = offset;\n }\n \f\n-/* We do RTX_UNSPEC + XINT (blah), so nothing can go after RTX_UNSPEC.  */\n-enum kind { RTX_UNKNOWN, RTX_DOUBLE, RTX_VECTOR, RTX_INT, RTX_UNSPEC };\n-struct rtx_const GTY(())\n-{\n-  ENUM_BITFIELD(kind) kind : 16;\n-  ENUM_BITFIELD(machine_mode) mode : 16;\n-  union rtx_const_un {\n-    REAL_VALUE_TYPE GTY ((tag (\"4\"))) du;\n-    struct rtx_const_u_addr {\n-      rtx base;\n-      const char *symbol;\n-      HOST_WIDE_INT offset;\n-    } GTY ((tag (\"1\"))) addr;\n-    struct rtx_const_u_di {\n-      HOST_WIDE_INT high;\n-      HOST_WIDE_INT low;\n-    } GTY ((tag (\"0\"))) di;\n-\n-    /* The max vector size we have is 16 wide; two variants for\n-       integral and floating point vectors.  */\n-    struct rtx_const_int_vec {\n-      HOST_WIDE_INT high;\n-      HOST_WIDE_INT low;\n-    } GTY ((tag (\"2\"))) int_vec[16];\n-\n-    REAL_VALUE_TYPE GTY ((tag (\"3\"))) fp_vec[8];\n-\n-  } GTY ((desc (\"%1.kind >= RTX_INT\"), descbits (\"1\"))) un;\n-};\n-\n /* Uniquize all constants that appear in memory.\n    Each constant in memory thus far output is recorded\n    in `const_desc_table'.  */\n@@ -2612,314 +2546,189 @@ lookup_constant_def (tree exp)\n \f\n /* Used in the hash tables to avoid outputting the same constant\n    twice.  Unlike 'struct constant_descriptor_tree', RTX constants\n-   are output once per function, not once per file; there seems\n-   to be no reason for the difference.  */\n-\n-struct constant_descriptor_rtx GTY(())\n-{\n-  /* More constant_descriptors with the same hash code.  */\n-  struct constant_descriptor_rtx *next;\n-\n-  /* A MEM for the constant.  */\n-  rtx rtl;\n-\n-  /* The value of the constant.  */\n-  struct rtx_const value;\n+   are output once per function, not once per file.  */\n+/* ??? Only a few targets need per-function constant pools.  Most\n+   can use one per-file pool.  Should add a targetm bit to tell the\n+   difference.  */\n+\n+struct rtx_constant_pool GTY(())\n+{\n+  /* Pointers to first and last constant in pool, as ordered by offset.  */\n+  struct constant_descriptor_rtx *first;\n+  struct constant_descriptor_rtx *last;\n+\n+  /* Hash facility for making memory-constants from constant rtl-expressions.\n+     It is used on RISC machines where immediate integer arguments and\n+     constant addresses are restricted so that such constants must be stored\n+     in memory.  */\n+  htab_t GTY((param_is (struct constant_descriptor_rtx))) const_rtx_htab;\n+  htab_t GTY((param_is (struct constant_descriptor_rtx))) const_rtx_sym_htab;\n+\n+  /* Current offset in constant pool (does not include any\n+     machine-specific header).  */\n+  HOST_WIDE_INT offset;\n };\n \n-/* Structure to represent sufficient information about a constant so that\n-   it can be output when the constant pool is output, so that function\n-   integration can be done, and to simplify handling on machines that reference\n-   constant pool as base+displacement.  */\n-\n-struct pool_constant GTY(())\n+struct constant_descriptor_rtx GTY((chain_next (\"%h.next\")))\n {\n-  struct constant_descriptor_rtx *desc;\n-  struct pool_constant *next;\n-  struct pool_constant *next_sym;\n+  struct constant_descriptor_rtx *next;\n+  rtx mem;\n+  rtx sym;\n   rtx constant;\n+  HOST_WIDE_INT offset;\n+  hashval_t hash;\n   enum machine_mode mode;\n-  int labelno;\n   unsigned int align;\n-  HOST_WIDE_INT offset;\n+  int labelno;\n   int mark;\n };\n \n-/* Hash code for a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true.\n-   The argument is XSTR (... , 0)  */\n+/* Hash and compare functions for const_rtx_htab.  */\n \n-#define SYMHASH(LABEL)\t(((unsigned long) (LABEL)) % MAX_RTX_HASH_TABLE)\n-\f\n-/* Initialize constant pool hashing for a new function.  */\n+static hashval_t\n+const_desc_rtx_hash (const void *ptr)\n+{\n+  const struct constant_descriptor_rtx *desc = ptr;\n+  return desc->hash;\n+}\n \n-void\n-init_varasm_status (struct function *f)\n+static int\n+const_desc_rtx_eq (const void *a, const void *b)\n {\n-  struct varasm_status *p;\n-  p = ggc_alloc (sizeof (struct varasm_status));\n-  f->varasm = p;\n-  p->x_const_rtx_hash_table\n-    = ggc_alloc_cleared (MAX_RTX_HASH_TABLE\n-\t\t\t * sizeof (struct constant_descriptor_rtx *));\n-  p->x_const_rtx_sym_hash_table\n-    = ggc_alloc_cleared (MAX_RTX_HASH_TABLE\n-\t\t\t * sizeof (struct pool_constant *));\n-\n-  p->x_first_pool = p->x_last_pool = 0;\n-  p->x_pool_offset = 0;\n-  p->deferred_constants = 0;\n+  const struct constant_descriptor_rtx *x = a;\n+  const struct constant_descriptor_rtx *y = b;\n+\n+  if (x->mode != y->mode)\n+    return 0;\n+  return rtx_equal_p (x->constant, y->constant);\n }\n-\f\n \n-/* Express an rtx for a constant integer (perhaps symbolic)\n-   as the sum of a symbol or label plus an explicit integer.\n-   They are stored into VALUE.  */\n+/* Hash and compare functions for const_rtx_sym_htab.  */\n \n-static void\n-decode_rtx_const (enum machine_mode mode, rtx x, struct rtx_const *value)\n+static hashval_t\n+const_desc_rtx_sym_hash (const void *ptr)\n {\n-  /* Clear the whole structure, including any gaps.  */\n-  memset (value, 0, sizeof (struct rtx_const));\n+  const struct constant_descriptor_rtx *desc = ptr;\n+  return htab_hash_string (XSTR (desc->sym, 0));\n+}\n \n-  value->kind = RTX_INT;\t/* Most usual kind.  */\n-  value->mode = mode;\n+static int\n+const_desc_rtx_sym_eq (const void *a, const void *b)\n+{\n+  const struct constant_descriptor_rtx *x = a;\n+  const struct constant_descriptor_rtx *y = b;\n+  return x->sym == y->sym;\n+}\n \n-  switch (GET_CODE (x))\n-    {\n-    case CONST_DOUBLE:\n-      value->kind = RTX_DOUBLE;\n-      if (GET_MODE (x) != VOIDmode)\n-\t{\n-\t  const REAL_VALUE_TYPE *r = CONST_DOUBLE_REAL_VALUE (x);\n+/* This is the worker function for const_rtx_hash, called via for_each_rtx.  */\n \n-\t  value->mode = GET_MODE (x);\n+static int\n+const_rtx_hash_1 (rtx *xp, void *data)\n+{\n+  unsigned HOST_WIDE_INT hwi;\n+  enum machine_mode mode;\n+  enum rtx_code code;\n+  hashval_t h, *hp;\n+  rtx x;\n \n-\t  /* Copy the REAL_VALUE_TYPE by members so that we don't\n-\t     copy garbage from the original structure into our\n-\t     carefully cleaned hashing structure.  */\n-\t  value->un.du.class = r->class;\n-\t  value->un.du.sign = r->sign;\n-\t  switch (r->class)\n-\t    {\n-\t    case rvc_zero:\n-\t    case rvc_inf:\n-\t      break;\n-\t    case rvc_normal:\n-\t      value->un.du.exp = r->exp;\n-\t      /* Fall through.  */\n-\t    case rvc_nan:\n-\t      memcpy (value->un.du.sig, r->sig, sizeof (r->sig));\n-\t      break;\n-\t    default:\n-\t      abort ();\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  value->un.di.low = CONST_DOUBLE_LOW (x);\n-\t  value->un.di.high = CONST_DOUBLE_HIGH (x);\n-\t}\n-      break;\n+  x = *xp;\n+  code = GET_CODE (x);\n+  mode = GET_MODE (x);\n+  h = (hashval_t) code * 1048573 + mode;\n \n-    case CONST_VECTOR:\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      hwi = INTVAL (x);\n+    fold_hwi:\n       {\n-\tint units, i;\n+\tconst int shift = sizeof (hashval_t) * CHAR_BIT;\n+\tconst int n = sizeof (HOST_WIDE_INT) / sizeof (hashval_t);\n+\tint i;\n \n-\tunits = CONST_VECTOR_NUNITS (x);\n-\tvalue->kind = RTX_VECTOR;\n-\tvalue->mode = mode;\n-\n-\tif (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n-\t  {\n-\t    for (i = 0; i < units; ++i)\n-\t      {\n-\t        rtx elt = CONST_VECTOR_ELT (x, i);\n-\t        if (GET_CODE (elt) == CONST_INT)\n-\t          {\n-\t\t    value->un.int_vec[i].low = INTVAL (elt);\n-\t\t    value->un.int_vec[i].high = 0;\n-\t          }\n-\t\telse\n-\t          {\n-\t\t    value->un.int_vec[i].low = CONST_DOUBLE_LOW (elt);\n-\t\t    value->un.int_vec[i].high = CONST_DOUBLE_HIGH (elt);\n-\t\t  }\n-\t      }\n-\t  }\n-\telse if (GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+\th ^= (hashval_t) hwi;\n+\tfor (i = 1; i < n; ++i)\n \t  {\n-\t    for (i = 0; i < units; ++i)\n-\t      {\n-\t\tconst REAL_VALUE_TYPE *r\n-\t\t  = CONST_DOUBLE_REAL_VALUE (CONST_VECTOR_ELT (x, i));\n-\t\tREAL_VALUE_TYPE *d = &value->un.fp_vec[i];\n-\n-\t        /* Copy the REAL_VALUE_TYPE by members so that we don't\n-\t           copy garbage from the original structure into our\n-\t           carefully cleaned hashing structure.  */\n-\t        d->class = r->class;\n-\t        d->sign = r->sign;\n-\t        switch (r->class)\n-\t          {\n-\t          case rvc_zero:\n-\t          case rvc_inf:\n-\t            break;\n-\t          case rvc_normal:\n-\t            d->exp = r->exp;\n-\t            /* Fall through.  */\n-\t          case rvc_nan:\n-\t            memcpy (d->sig, r->sig, sizeof (r->sig));\n-\t            break;\n-\t          default:\n-\t            abort ();\n-\t          }\n-\t      }\n+\t    hwi >>= shift;\n+\t    h ^= (hashval_t) hwi;\n \t  }\n-\telse\n-\t  abort ();\n       }\n       break;\n \n-    case CONST_INT:\n-      value->un.addr.offset = INTVAL (x);\n+    case CONST_DOUBLE:\n+      if (mode == VOIDmode)\n+\t{\n+\t  hwi = CONST_DOUBLE_LOW (x) ^ CONST_DOUBLE_HIGH (x);\n+\t  goto fold_hwi;\n+\t}\n+      else\n+\th ^= real_hash (CONST_DOUBLE_REAL_VALUE (x));\n       break;\n \n     case SYMBOL_REF:\n+      h ^= htab_hash_string (XSTR (x, 0));\n+      break;\n+\n     case LABEL_REF:\n-    case PC:\n-      value->un.addr.base = x;\n+      h = h * 251 + CODE_LABEL_NUMBER (XEXP (x, 0));\n       break;\n \n-    case CONST:\n-      x = XEXP (x, 0);\n-      if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t{\n-\t  value->un.addr.base = XEXP (x, 0);\n-\t  value->un.addr.offset = INTVAL (XEXP (x, 1));\n-\t}\n-      else if (GET_CODE (x) == MINUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t{\n-\t  value->un.addr.base = XEXP (x, 0);\n-\t  value->un.addr.offset = - INTVAL (XEXP (x, 1));\n-\t}\n-      else\n-\t{\n-\t  value->un.addr.base = x;\n-\t  value->un.addr.offset = 0;\n-\t}\n+    case UNSPEC:\n+    case UNSPEC_VOLATILE:\n+      h = h * 251 + XINT (x, 1);\n       break;\n \n     default:\n-      value->kind = RTX_UNKNOWN;\n       break;\n     }\n \n-  if (value->kind == RTX_INT && value->un.addr.base != 0\n-      && GET_CODE (value->un.addr.base) == UNSPEC)\n-    {\n-      /* For a simple UNSPEC, the base is set to the\n-\t operand, the kind field is set to the index of\n-\t the unspec expression.\n-\t Together with the code below, in case that\n-\t the operand is a SYMBOL_REF or LABEL_REF,\n-\t the address of the string or the code_label\n-\t is taken as base.  */\n-      if (XVECLEN (value->un.addr.base, 0) == 1)\n-\t{\n-\t  value->kind = RTX_UNSPEC + XINT (value->un.addr.base, 1);\n-\t  value->un.addr.base = XVECEXP (value->un.addr.base, 0, 0);\n-\t}\n-    }\n-\n-  if (value->kind >= RTX_INT && value->un.addr.base != 0)\n-    switch (GET_CODE (value->un.addr.base))\n-      {\n-      case SYMBOL_REF:\n-\t/* Use the string's address, not the SYMBOL_REF's address,\n-\t   for the sake of addresses of library routines.  */\n-\tvalue->un.addr.symbol = XSTR (value->un.addr.base, 0);\n-\tvalue->un.addr.base = NULL_RTX;\n-\tbreak;\n-\n-      case LABEL_REF:\n-\t/* For a LABEL_REF, compare labels.  */\n-\tvalue->un.addr.base = XEXP (value->un.addr.base, 0);\n-\n-      default:\n-\tbreak;\n-      }\n+  hp = data;\n+  *hp = *hp * 509 + h;\n+  return 0;\n }\n \n-/* Given a MINUS expression, simplify it if both sides\n-   include the same symbol.  */\n+/* Compute a hash value for X, which should be a constant.  */\n \n-rtx\n-simplify_subtraction (rtx x)\n+static hashval_t\n+const_rtx_hash (rtx x)\n {\n-  struct rtx_const val0, val1;\n-\n-  decode_rtx_const (GET_MODE (x), XEXP (x, 0), &val0);\n-  decode_rtx_const (GET_MODE (x), XEXP (x, 1), &val1);\n-\n-  if (val0.kind >= RTX_INT\n-      && val0.kind == val1.kind\n-      && val0.un.addr.base == val1.un.addr.base\n-      && val0.un.addr.symbol == val1.un.addr.symbol)\n-    return GEN_INT (val0.un.addr.offset - val1.un.addr.offset);\n-\n-  return x;\n+  hashval_t h = 0;\n+  for_each_rtx (&x, const_rtx_hash_1, &h);\n+  return h;\n }\n \n-/* Compute a hash code for a constant RTL expression.  */\n+\f\n+/* Initialize constant pool hashing for a new function.  */\n \n-static unsigned int\n-const_hash_rtx (enum machine_mode mode, rtx x)\n+void\n+init_varasm_status (struct function *f)\n {\n-  union {\n-    struct rtx_const value;\n-    unsigned int data[sizeof(struct rtx_const) / sizeof (unsigned int)];\n-  } u;\n-\n-  unsigned int hi;\n-  size_t i;\n-\n-  decode_rtx_const (mode, x, &u.value);\n-\n-  /* Compute hashing function.  */\n-  hi = 0;\n-  for (i = 0; i < ARRAY_SIZE (u.data); i++)\n-    hi = hi * 613 + u.data[i];\n-\n-  return hi % MAX_RTX_HASH_TABLE;\n-}\n-\n-/* Compare a constant rtl object X with a constant-descriptor DESC.\n-   Return 1 if DESC describes a constant with the same value as X.  */\n+  struct varasm_status *p;\n+  struct rtx_constant_pool *pool;\n \n-static int\n-compare_constant_rtx (enum machine_mode mode, rtx x,\n-\t\t      struct constant_descriptor_rtx *desc)\n-{\n-  struct rtx_const value;\n+  p = ggc_alloc (sizeof (struct varasm_status));\n+  f->varasm = p;\n \n-  decode_rtx_const (mode, x, &value);\n+  pool = ggc_alloc (sizeof (struct rtx_constant_pool));\n+  p->pool = pool;\n+  p->deferred_constants = 0;\n \n-  /* Compare constant contents.  */\n-  return memcmp (&value, &desc->value, sizeof (struct rtx_const)) == 0;\n+  pool->const_rtx_htab = htab_create_ggc (31, const_desc_rtx_hash,\n+\t\t\t\t\t  const_desc_rtx_eq, NULL);\n+  pool->const_rtx_sym_htab = htab_create_ggc (31, const_desc_rtx_sym_hash,\n+\t\t\t\t\t      const_desc_rtx_sym_eq, NULL);\n+  pool->first = pool->last = NULL;\n+  pool->offset = 0;\n }\n+\f\n+/* Given a MINUS expression, simplify it if both sides\n+   include the same symbol.  */\n \n-/* Construct a constant descriptor for the rtl-expression X.\n-   It is up to the caller to enter the descriptor in the hash table.  */\n-\n-static struct constant_descriptor_rtx *\n-record_constant_rtx (enum machine_mode mode, rtx x)\n+rtx\n+simplify_subtraction (rtx x)\n {\n-  struct constant_descriptor_rtx *ptr;\n-\n-  ptr = ggc_alloc (sizeof (*ptr));\n-  decode_rtx_const (mode, x, &ptr->value);\n-\n-  return ptr;\n+  rtx r = simplify_rtx (x);\n+  return r ? r : x;\n }\n \f\n /* Given a constant rtx X, make (or find) a memory constant for its value\n@@ -2928,30 +2737,32 @@ record_constant_rtx (enum machine_mode mode, rtx x)\n rtx\n force_const_mem (enum machine_mode mode, rtx x)\n {\n-  int hash;\n-  struct constant_descriptor_rtx *desc;\n+  struct constant_descriptor_rtx *desc, tmp;\n+  struct rtx_constant_pool *pool = cfun->varasm->pool;\n   char label[256];\n   rtx def, symbol;\n-  struct pool_constant *pool;\n+  hashval_t hash;\n   unsigned int align;\n+  void **slot;\n \n   /* If we're not allowed to drop X into the constant pool, don't.  */\n   if ((*targetm.cannot_force_const_mem) (x))\n     return NULL_RTX;\n \n-  /* Compute hash code of X.  Search the descriptors for that hash code\n-     to see if any of them describes X.  If yes, we have an rtx to use.  */\n-  hash = const_hash_rtx (mode, x);\n-  for (desc = const_rtx_hash_table[hash]; desc; desc = desc->next)\n-    if (compare_constant_rtx (mode, x, desc))\n-      return copy_rtx (desc->rtl);\n-\n-  /* No constant equal to X is known to have been output.\n-     Make a constant descriptor to enter X in the hash table\n-     and make a MEM for it.  */\n-  desc = record_constant_rtx (mode, x);\n-  desc->next = const_rtx_hash_table[hash];\n-  const_rtx_hash_table[hash] = desc;\n+  /* Lookup the value in the hashtable.  */\n+  tmp.constant = x;\n+  tmp.mode = mode;\n+  hash = const_rtx_hash (x);\n+  slot = htab_find_slot_with_hash (pool->const_rtx_htab, &tmp, hash, INSERT);\n+  desc = *slot;\n+  \n+  /* If the constant was already present, return its memory.  */\n+  if (desc)\n+    return copy_rtx (desc->mem);\n+\n+  /* Otherwise, create a new descriptor.  */\n+  desc = ggc_alloc (sizeof (*desc));\n+  *slot = desc;\n \n   /* Align the location counter as required by EXP's data type.  */\n   align = GET_MODE_ALIGNMENT (mode == VOIDmode ? word_mode : mode);\n@@ -2963,81 +2774,72 @@ force_const_mem (enum machine_mode mode, rtx x)\n   }\n #endif\n \n-  pool_offset += (align / BITS_PER_UNIT) - 1;\n-  pool_offset &= ~ ((align / BITS_PER_UNIT) - 1);\n-\n-  if (GET_CODE (x) == LABEL_REF)\n-    LABEL_PRESERVE_P (XEXP (x, 0)) = 1;\n-\n-  /* Allocate a pool constant descriptor, fill it in, and chain it in.  */\n-  pool = ggc_alloc (sizeof (struct pool_constant));\n-  pool->desc = desc;\n-  pool->constant = x;\n-  pool->mode = mode;\n-  pool->labelno = const_labelno;\n-  pool->align = align;\n-  pool->offset = pool_offset;\n-  pool->mark = 1;\n-  pool->next = 0;\n-\n-  if (last_pool == 0)\n-    first_pool = pool;\n+  pool->offset += (align / BITS_PER_UNIT) - 1;\n+  pool->offset &= ~ ((align / BITS_PER_UNIT) - 1);\n+\n+  desc->next = NULL;\n+  desc->constant = tmp.constant;\n+  desc->offset = pool->offset;\n+  desc->hash = hash;\n+  desc->mode = mode;\n+  desc->align = align;\n+  desc->labelno = const_labelno;\n+  desc->mark = 0;\n+\n+  pool->offset += GET_MODE_SIZE (mode);\n+  if (pool->last)\n+    pool->last->next = desc;\n   else\n-    last_pool->next = pool;\n-\n-  last_pool = pool;\n-  pool_offset += GET_MODE_SIZE (mode);\n+    pool->first = pool->last = desc;\n+  pool->last = desc;\n \n   /* Create a string containing the label name, in LABEL.  */\n   ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", const_labelno);\n-\n   ++const_labelno;\n \n-  /* Construct the SYMBOL_REF and the MEM.  */\n-\n-  symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (label));\n+  /* Construct the SYMBOL_REF.  Make sure to mark it as belonging to\n+     the constants pool.  */\n+  desc->sym = symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (label));\n   SYMBOL_REF_FLAGS (symbol) = SYMBOL_FLAG_LOCAL;\n+  CONSTANT_POOL_ADDRESS_P (symbol) = 1;\n+  current_function_uses_const_pool = 1;\n+\n+  /* Insert the descriptor into the symbol cross-reference table too.  */\n+  slot = htab_find_slot (pool->const_rtx_sym_htab, desc, INSERT);\n+  if (*slot)\n+    abort ();\n+  *slot = desc;\n \n-  pool->desc->rtl = def = gen_rtx_MEM (mode, symbol);\n+  /* Construct the MEM.  */\n+  desc->mem = def = gen_rtx_MEM (mode, symbol);\n   set_mem_attributes (def, (*lang_hooks.types.type_for_mode) (mode, 0), 1);\n   RTX_UNCHANGING_P (def) = 1;\n \n-  /* Add label to symbol hash table.  */\n-  hash = SYMHASH (XSTR (symbol, 0));\n-  pool->next_sym = const_rtx_sym_hash_table[hash];\n-  const_rtx_sym_hash_table[hash] = pool;\n-\n-  /* Mark the symbol_ref as belonging to this constants pool.  */\n-  CONSTANT_POOL_ADDRESS_P (symbol) = 1;\n-  SYMBOL_REF_FLAGS (symbol) = SYMBOL_FLAG_LOCAL;\n-  current_function_uses_const_pool = 1;\n+  /* If we're dropping a label to the constant pool, make sure we\n+     don't delete it.  */\n+  if (GET_CODE (x) == LABEL_REF)\n+    LABEL_PRESERVE_P (XEXP (x, 0)) = 1;\n \n   return copy_rtx (def);\n }\n \f\n /* Given a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true, return a pointer to\n-   the corresponding pool_constant structure.  */\n+   the corresponding constant_descriptor_rtx structure.  */\n \n-static struct pool_constant *\n-find_pool_constant (struct function *f, rtx addr)\n+static struct constant_descriptor_rtx *\n+find_pool_constant (struct rtx_constant_pool *pool, rtx sym)\n {\n-  struct pool_constant *pool;\n-  const char *label = XSTR (addr, 0);\n-\n-  for (pool = f->varasm->x_const_rtx_sym_hash_table[SYMHASH (label)]; pool;\n-       pool = pool->next_sym)\n-    if (XSTR (XEXP (pool->desc->rtl, 0), 0) == label)\n-      return pool;\n-\n-  abort ();\n+  struct constant_descriptor_rtx tmp;\n+  tmp.sym = sym;\n+  return htab_find (pool->const_rtx_sym_htab, &tmp);\n }\n \n /* Given a constant pool SYMBOL_REF, return the corresponding constant.  */\n \n rtx\n get_pool_constant (rtx addr)\n {\n-  return (find_pool_constant (cfun, addr))->constant;\n+  return find_pool_constant (cfun->varasm->pool, addr)->constant;\n }\n \n /* Given a constant pool SYMBOL_REF, return the corresponding constant\n@@ -3046,335 +2848,285 @@ get_pool_constant (rtx addr)\n rtx\n get_pool_constant_mark (rtx addr, bool *pmarked)\n {\n-  struct pool_constant *pool = find_pool_constant (cfun, addr);\n-  *pmarked = (pool->mark != 0);\n-  return pool->constant;\n+  struct constant_descriptor_rtx *desc;\n+\n+  desc = find_pool_constant (cfun->varasm->pool, addr);\n+  *pmarked = (desc->mark != 0);\n+  return desc->constant;\n }\n \n /* Likewise, but for the constant pool of a specific function.  */\n \n rtx\n get_pool_constant_for_function (struct function *f, rtx addr)\n {\n-  return (find_pool_constant (f, addr))->constant;\n+  return find_pool_constant (f->varasm->pool, addr)->constant;\n }\n \n /* Similar, return the mode.  */\n \n enum machine_mode\n get_pool_mode (rtx addr)\n {\n-  return (find_pool_constant (cfun, addr))->mode;\n+  return find_pool_constant (cfun->varasm->pool, addr)->mode;\n }\n \n enum machine_mode\n get_pool_mode_for_function (struct function *f, rtx addr)\n {\n-  return (find_pool_constant (f, addr))->mode;\n+  return find_pool_constant (f->varasm->pool, addr)->mode;\n }\n \n /* Similar, return the offset in the constant pool.  */\n \n int\n get_pool_offset (rtx addr)\n {\n-  return (find_pool_constant (cfun, addr))->offset;\n+  return find_pool_constant (cfun->varasm->pool, addr)->offset;\n }\n \n /* Return the size of the constant pool.  */\n \n int\n get_pool_size (void)\n {\n-  return pool_offset;\n+  return cfun->varasm->pool->offset;\n }\n \f\n-/* Write all the constants in the constant pool.  */\n+/* Worker function for output_constant_pool_1.  Emit assembly for X\n+   in MODE with known alignment ALIGN.  */\n \n-void\n-output_constant_pool (const char *fnname ATTRIBUTE_UNUSED,\n-\t\t      tree fndecl ATTRIBUTE_UNUSED)\n+static void\n+output_constant_pool_2 (enum machine_mode mode, rtx x, unsigned int align)\n {\n-  struct pool_constant *pool;\n-  rtx x;\n-  REAL_VALUE_TYPE r;\n-\n-  /* It is possible for gcc to call force_const_mem and then to later\n-     discard the instructions which refer to the constant.  In such a\n-     case we do not need to output the constant.  */\n-  mark_constant_pool ();\n-\n-#ifdef ASM_OUTPUT_POOL_PROLOGUE\n-  ASM_OUTPUT_POOL_PROLOGUE (asm_out_file, fnname, fndecl, pool_offset);\n-#endif\n-\n-  for (pool = first_pool; pool; pool = pool->next)\n+  switch (GET_MODE_CLASS (mode))\n     {\n-      rtx tmp;\n-\n-      x = pool->constant;\n-\n-      if (! pool->mark)\n-\tcontinue;\n-\n-      /* See if X is a LABEL_REF (or a CONST referring to a LABEL_REF)\n-\t whose CODE_LABEL has been deleted.  This can occur if a jump table\n-\t is eliminated by optimization.  If so, write a constant of zero\n-\t instead.  Note that this can also happen by turning the\n-\t CODE_LABEL into a NOTE.  */\n-      /* ??? This seems completely and utterly wrong.  Certainly it's\n-\t not true for NOTE_INSN_DELETED_LABEL, but I disbelieve proper\n-\t functioning even with INSN_DELETED_P and friends.  */\n-\n-      tmp = x;\n-      switch (GET_CODE (x))\n+    case MODE_FLOAT:\n+      if (GET_CODE (x) != CONST_DOUBLE)\n+\tabort ();\n+      else\n \t{\n-\tcase CONST:\n-\t  if (GET_CODE (XEXP (x, 0)) != PLUS\n-\t      || GET_CODE (XEXP (XEXP (x, 0), 0)) != LABEL_REF)\n-\t    break;\n-\t  tmp = XEXP (XEXP (x, 0), 0);\n-\t  /* Fall through.  */\n-\n-\tcase LABEL_REF:\n-\t  tmp = XEXP (x, 0);\n-\t  if (INSN_DELETED_P (tmp)\n-\t      || (GET_CODE (tmp) == NOTE\n-\t\t  && NOTE_LINE_NUMBER (tmp) == NOTE_INSN_DELETED))\n-\t    {\n-\t      abort ();\n-\t      x = const0_rtx;\n-\t    }\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n+\t  REAL_VALUE_TYPE r;\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\t  assemble_real (r, mode, align);\n \t}\n+      break;\n \n-      /* First switch to correct section.  */\n-      (*targetm.asm_out.select_rtx_section) (pool->mode, x, pool->align);\n-\n-#ifdef ASM_OUTPUT_SPECIAL_POOL_ENTRY\n-      ASM_OUTPUT_SPECIAL_POOL_ENTRY (asm_out_file, x, pool->mode,\n-\t\t\t\t     pool->align, pool->labelno, done);\n-#endif\n-\n-      assemble_align (pool->align);\n-\n-      /* Output the label.  */\n-      (*targetm.asm_out.internal_label) (asm_out_file, \"LC\", pool->labelno);\n-\n-      /* Output the value of the constant itself.  */\n-      switch (GET_MODE_CLASS (pool->mode))\n-\t{\n-\tcase MODE_FLOAT:\n-\t  if (GET_CODE (x) != CONST_DOUBLE)\n-\t    abort ();\n+    case MODE_INT:\n+    case MODE_PARTIAL_INT:\n+      assemble_integer (x, GET_MODE_SIZE (mode), align, 1);\n+      break;\n \n-\t  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n-\t  assemble_real (r, pool->mode, pool->align);\n-\t  break;\n+    case MODE_VECTOR_FLOAT:\n+    case MODE_VECTOR_INT:\n+      {\n+\tint i, units;\n+        enum machine_mode submode = GET_MODE_INNER (mode);\n+\tunsigned int subalign = MIN (align, GET_MODE_BITSIZE (submode));\n \n-\tcase MODE_INT:\n-\tcase MODE_PARTIAL_INT:\n-\t  assemble_integer (x, GET_MODE_SIZE (pool->mode), pool->align, 1);\n-\t  break;\n+\tif (GET_CODE (x) != CONST_VECTOR)\n+\t  abort ();\n+\tunits = CONST_VECTOR_NUNITS (x);\n \n-\tcase MODE_VECTOR_FLOAT:\n+\tfor (i = 0; i < units; i++)\n \t  {\n-\t    int i, units;\n-\t    rtx elt;\n-\n-\t    if (GET_CODE (x) != CONST_VECTOR)\n-\t      abort ();\n-\n-\t    units = CONST_VECTOR_NUNITS (x);\n-\n-\t    for (i = 0; i < units; i++)\n-\t      {\n-\t\telt = CONST_VECTOR_ELT (x, i);\n-\t\tREAL_VALUE_FROM_CONST_DOUBLE (r, elt);\n-\t\tassemble_real (r, GET_MODE_INNER (pool->mode), pool->align);\n-\t      }\n+\t    rtx elt = CONST_VECTOR_ELT (x, i);\n+\t    output_constant_pool_2 (submode, elt, i ? subalign : align);\n \t  }\n-\t  break;\n+      }\n+      break;\n \n-\tcase MODE_VECTOR_INT:\n-\t  {\n-\t    int i, units;\n-\t    rtx elt;\n+    default:\n+      abort ();\n+    }\n+}\n \n-\t    if (GET_CODE (x) != CONST_VECTOR)\n-\t      abort ();\n+/* Worker function for output_constant_pool.  Emit POOL.  */\n \n-\t    units = CONST_VECTOR_NUNITS (x);\n+static void\n+output_constant_pool_1 (struct constant_descriptor_rtx *desc)\n+{\n+  rtx x, tmp;\n \n-\t    for (i = 0; i < units; i++)\n-\t      {\n-\t\telt = CONST_VECTOR_ELT (x, i);\n-\t\tassemble_integer (elt, GET_MODE_UNIT_SIZE (pool->mode),\n-\t\t\t\t  pool->align, 1);\n-\t      }\n-\t  }\n-\t  break;\n+  if (!desc->mark)\n+    return;\n+  x = desc->constant;\n+\n+  /* See if X is a LABEL_REF (or a CONST referring to a LABEL_REF)\n+     whose CODE_LABEL has been deleted.  This can occur if a jump table\n+     is eliminated by optimization.  If so, write a constant of zero\n+     instead.  Note that this can also happen by turning the\n+     CODE_LABEL into a NOTE.  */\n+  /* ??? This seems completely and utterly wrong.  Certainly it's\n+     not true for NOTE_INSN_DELETED_LABEL, but I disbelieve proper\n+     functioning even with INSN_DELETED_P and friends.  */\n+\n+  tmp = x;\n+  switch (GET_CODE (x))\n+    {\n+    case CONST:\n+      if (GET_CODE (XEXP (x, 0)) != PLUS\n+\t  || GET_CODE (XEXP (XEXP (x, 0), 0)) != LABEL_REF)\n+\tbreak;\n+      tmp = XEXP (XEXP (x, 0), 0);\n+      /* FALLTHRU  */\n \n-\tdefault:\n+    case LABEL_REF:\n+      tmp = XEXP (x, 0);\n+      if (INSN_DELETED_P (tmp)\n+\t  || (GET_CODE (tmp) == NOTE\n+\t      && NOTE_LINE_NUMBER (tmp) == NOTE_INSN_DELETED))\n+\t{\n \t  abort ();\n+\t  x = const0_rtx;\n \t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n \n-      /* Make sure all constants in SECTION_MERGE and not SECTION_STRINGS\n-\t sections have proper size.  */\n-      if (pool->align > GET_MODE_BITSIZE (pool->mode)\n-\t  && in_section == in_named\n-\t  && get_named_section_flags (in_named_name) & SECTION_MERGE)\n-\tassemble_align (pool->align);\n+  /* First switch to correct section.  */\n+  (*targetm.asm_out.select_rtx_section) (desc->mode, x, desc->align);\n \n #ifdef ASM_OUTPUT_SPECIAL_POOL_ENTRY\n-    done: ;\n+  ASM_OUTPUT_SPECIAL_POOL_ENTRY (asm_out_file, x, desc->mode,\n+\t\t\t\t desc->align, desc->labelno, done);\n #endif\n-    }\n \n-#ifdef ASM_OUTPUT_POOL_EPILOGUE\n-  ASM_OUTPUT_POOL_EPILOGUE (asm_out_file, fnname, fndecl, pool_offset);\n-#endif\n+  assemble_align (desc->align);\n \n-  /* Done with this pool.  */\n-  first_pool = last_pool = 0;\n-}\n+  /* Output the label.  */\n+  (*targetm.asm_out.internal_label) (asm_out_file, \"LC\", desc->labelno);\n \n-/* Look through the instructions for this function, and mark all the\n-   entries in the constant pool which are actually being used.  Emit\n-   deferred constants which have indeed been used.  */\n+  /* Output the data.  */\n+  output_constant_pool_2 (desc->mode, x, desc->align);\n \n-static void\n-mark_constant_pool (void)\n-{\n-  rtx insn;\n-  rtx link;\n-  struct pool_constant *pool;\n+  /* Make sure all constants in SECTION_MERGE and not SECTION_STRINGS\n+     sections have proper size.  */\n+  if (desc->align > GET_MODE_BITSIZE (desc->mode)\n+      && in_section == in_named\n+      && get_named_section_flags (in_named_name) & SECTION_MERGE)\n+    assemble_align (desc->align);\n \n-  if (first_pool == 0 && n_deferred_constants == 0)\n-    return;\n+#ifdef ASM_OUTPUT_SPECIAL_POOL_ENTRY\n+ done:\n+#endif\n+  return;\n+}\n \n-  for (pool = first_pool; pool; pool = pool->next)\n-    pool->mark = 0;\n+/* Given a SYMBOL_REF CURRENT_RTX, mark it and all constants it refers\n+   to as used.  Emit referenced deferred strings.  This function can\n+   be used with for_each_rtx to mark all SYMBOL_REFs in an rtx.  */\n \n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n-      mark_constants (PATTERN (insn));\n+static int\n+mark_constant (rtx *current_rtx, void *data)\n+{\n+  struct rtx_constant_pool *pool = data;\n+  rtx x = *current_rtx;\n \n-  for (link = current_function_epilogue_delay_list;\n-       link;\n-       link = XEXP (link, 1))\n-    {\n-      insn = XEXP (link, 0);\n+  if (x == NULL_RTX || GET_CODE (x) != SYMBOL_REF)\n+    return 0;\n \n-      if (INSN_P (insn))\n-\tmark_constants (PATTERN (insn));\n+  if (CONSTANT_POOL_ADDRESS_P (x))\n+    {\n+      struct constant_descriptor_rtx *desc = find_pool_constant (pool, x);\n+      if (desc->mark == 0)\n+\t{\n+\t  desc->mark = 1;\n+\t  for_each_rtx (&desc->constant, mark_constant, pool);\n+\t}\n     }\n-}\n+  else if (TREE_CONSTANT_POOL_ADDRESS_P (x))\n+    {\n+      tree exp = SYMBOL_REF_DECL (x);\n+      if (!TREE_ASM_WRITTEN (exp))\n+\t{\n+\t  n_deferred_constants--;\n+\t  output_constant_def_contents (x);\n+\t}\n+    }\n+\n+  return -1;\n+} \n \n-/* Look through appropriate parts of X, marking all entries in the\n+/* Look through appropriate parts of INSN, marking all entries in the\n    constant pool which are actually being used.  Entries that are only\n    referenced by other constants are also marked as used.  Emit\n    deferred strings that are used.  */\n \n static void\n-mark_constants (rtx x)\n+mark_constants (struct rtx_constant_pool *pool, rtx insn)\n {\n-  int i;\n-  const char *format_ptr;\n-\n-  if (x == 0)\n+  if (!INSN_P (insn))\n     return;\n \n-  if (GET_CODE (x) == SYMBOL_REF)\n-    {\n-      mark_constant (&x, NULL);\n-      return;\n-    }\n-\n   /* Insns may appear inside a SEQUENCE.  Only check the patterns of\n      insns, not any notes that may be attached.  We don't want to mark\n      a constant just because it happens to appear in a REG_EQUIV note.  */\n-  if (INSN_P (x))\n+  if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n     {\n-      mark_constants (PATTERN (x));\n-      return;\n+      rtx seq = PATTERN (insn);\n+      int i, n = XVECLEN (seq, 0);\n+      for (i = 0; i < n; ++i)\n+\t{\n+\t  rtx subinsn = XVECEXP (seq, 0, i);\n+\t  if (INSN_P (subinsn))\n+\t    for_each_rtx (&PATTERN (subinsn), mark_constant, pool);\n+\t}\n     }\n+  else\n+    for_each_rtx (&PATTERN (insn), mark_constant, pool);\n+}\n \n-  format_ptr = GET_RTX_FORMAT (GET_CODE (x));\n-\n-  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (x)); i++)\n-    {\n-      switch (*format_ptr++)\n-\t{\n-\tcase 'e':\n-\t  mark_constants (XEXP (x, i));\n-\t  break;\n+/* Look through the instructions for this function, and mark all the\n+   entries in POOL which are actually being used.  Emit deferred constants\n+   which have indeed been used.  */\n \n-\tcase 'E':\n-\t  if (XVEC (x, i) != 0)\n-\t    {\n-\t      int j;\n+static void\n+mark_constant_pool (struct rtx_constant_pool *pool)\n+{\n+  rtx insn, link;\n \n-\t      for (j = 0; j < XVECLEN (x, i); j++)\n-\t\tmark_constants (XVECEXP (x, i, j));\n-\t    }\n-\t  break;\n+  if (pool->first == 0 && n_deferred_constants == 0)\n+    return;\n \n-\tcase 'S':\n-\tcase 's':\n-\tcase '0':\n-\tcase 'i':\n-\tcase 'w':\n-\tcase 'n':\n-\tcase 'u':\n-\tcase 'B':\n-\t  break;\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    mark_constants (pool, insn);\n \n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n+  for (link = current_function_epilogue_delay_list;\n+       link;\n+       link = XEXP (link, 1))\n+    mark_constants (pool, XEXP (link, 0));\n }\n \n-/* Given a SYMBOL_REF CURRENT_RTX, mark it and all constants it refers\n-   to as used.  Emit referenced deferred strings.  This function can\n-   be used with for_each_rtx to mark all SYMBOL_REFs in an rtx.  */\n+/* Write all the constants in the constant pool.  */\n \n-static int\n-mark_constant (rtx *current_rtx, void *data ATTRIBUTE_UNUSED)\n+void\n+output_constant_pool (const char *fnname ATTRIBUTE_UNUSED,\n+\t\t      tree fndecl ATTRIBUTE_UNUSED)\n {\n-  rtx x = *current_rtx;\n+  struct rtx_constant_pool *pool = cfun->varasm->pool;\n+  struct constant_descriptor_rtx *desc;\n \n-  if (x == NULL_RTX)\n-    return 0;\n+  /* It is possible for gcc to call force_const_mem and then to later\n+     discard the instructions which refer to the constant.  In such a\n+     case we do not need to output the constant.  */\n+  mark_constant_pool (pool);\n \n-  else if (GET_CODE (x) == SYMBOL_REF)\n-    {\n-      if (CONSTANT_POOL_ADDRESS_P (x))\n-\t{\n-\t  struct pool_constant *pool = find_pool_constant (cfun, x);\n-\t  if (pool->mark == 0)\n-\t    {\n-\t      pool->mark = 1;\n-\t      for_each_rtx (&(pool->constant), &mark_constant, NULL);\n-\t    }\n-\t  else\n-\t    return -1;\n-\t}\n-      else if (TREE_CONSTANT_POOL_ADDRESS_P (x))\n-\t{\n-\t  tree exp = SYMBOL_REF_DECL (x);\n-\t  if (!TREE_ASM_WRITTEN (exp))\n-\t    {\n-\t      n_deferred_constants--;\n-\t      output_constant_def_contents (x);\n-\t    }\n-\t}\n-    }\n-  return 0;\n+#ifdef ASM_OUTPUT_POOL_PROLOGUE\n+  ASM_OUTPUT_POOL_PROLOGUE (asm_out_file, fnname, fndecl, pool->offset);\n+#endif\n+\n+  for (desc = pool->first; desc ; desc = desc->next)\n+    output_constant_pool_1 (desc);\n+\n+#ifdef ASM_OUTPUT_POOL_EPILOGUE\n+  ASM_OUTPUT_POOL_EPILOGUE (asm_out_file, fnname, fndecl, pool->offset);\n+#endif\n+\n+  /* Done with this pool.  */\n+  cfun->varasm->pool = NULL;\n }\n \f\n /* Determine what kind of relocations EXP may need.  */"}]}