{"sha": "77cac2f260a945339303f8e439c1c545b2d22f24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdjYWMyZjI2MGE5NDUzMzkzMDNmOGU0MzljMWM1NDViMmQyMmYyNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-06T21:46:44Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-06T21:46:44Z"}, "message": "(prepare_call_address, emit_call_1, expand_call): Change from USE and CLOBBER insns to using CALL_INSN_FUNCTION_USAGE.\n\n(prepare_call_address, emit_call_1, expand_call): Change from USE and CLOBBER\ninsns to using CALL_INSN_FUNCTION_USAGE.\n(emit_library_call{,_value}): Likewise.\n\nFrom-SVN: r7239", "tree": {"sha": "68b4fca928a09ccf2d587b6587bf76602050c7c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68b4fca928a09ccf2d587b6587bf76602050c7c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77cac2f260a945339303f8e439c1c545b2d22f24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77cac2f260a945339303f8e439c1c545b2d22f24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77cac2f260a945339303f8e439c1c545b2d22f24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77cac2f260a945339303f8e439c1c545b2d22f24/comments", "author": null, "committer": null, "parents": [{"sha": "aff507f439b0dcbeaf95354e95a391ea0f0e6a27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aff507f439b0dcbeaf95354e95a391ea0f0e6a27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aff507f439b0dcbeaf95354e95a391ea0f0e6a27"}], "stats": {"total": 84, "additions": 28, "deletions": 56}, "files": [{"sha": "4ca0483370307cb5e3d5261e3a69ed6c1e11b5c2", "filename": "gcc/calls.c", "status": "modified", "additions": 28, "deletions": 56, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77cac2f260a945339303f8e439c1c545b2d22f24/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77cac2f260a945339303f8e439c1c545b2d22f24/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=77cac2f260a945339303f8e439c1c545b2d22f24", "patch": "@@ -247,15 +247,14 @@ calls_function_1 (exp, which)\n    and return that as an rtx.  Also load the static chain register\n    if FNDECL is a nested function.\n \n-   USE_INSNS points to a variable holding a chain of USE insns\n-   to which a USE of the static chain\n-   register should be added, if required.  */\n+   CALL_FUSAGE points to a variable holding the prospective\n+   CALL_INSN_FUNCTION_USAGE information.  */\n \n rtx\n-prepare_call_address (funexp, fndecl, use_insns, reg_parm_seen)\n+prepare_call_address (funexp, fndecl, call_fusage, reg_parm_seen)\n      rtx funexp;\n      tree fndecl;\n-     rtx *use_insns;\n+     rtx *call_fusage;\n      int reg_parm_seen;\n {\n   rtx static_chain_value = 0;\n@@ -292,12 +291,7 @@ prepare_call_address (funexp, fndecl, use_insns, reg_parm_seen)\n     {\n       emit_move_insn (static_chain_rtx, static_chain_value);\n \n-      /* Put the USE insn in the chain we were passed.  It will later be\n-\t output immediately in front of the CALL insn.  */\n-      push_to_sequence (*use_insns);\n-      emit_insn (gen_rtx (USE, VOIDmode, static_chain_rtx));\n-      *use_insns = get_insns ();\n-      end_sequence ();\n+      use_reg (call_fusage, static_chain_rtx);\n     }\n \n   return funexp;\n@@ -341,15 +335,15 @@ prepare_call_address (funexp, fndecl, use_insns, reg_parm_seen)\n \n static void\n emit_call_1 (funexp, funtype, stack_size, struct_value_size, next_arg_reg,\n-\t     valreg, old_inhibit_defer_pop, use_insns, is_const)\n+\t     valreg, old_inhibit_defer_pop, call_fusage, is_const)\n      rtx funexp;\n      tree funtype;\n      int stack_size;\n      int struct_value_size;\n      rtx next_arg_reg;\n      rtx valreg;\n      int old_inhibit_defer_pop;\n-     rtx use_insns;\n+     rtx call_fusage;\n      int is_const;\n {\n   rtx stack_size_rtx = GEN_INT (stack_size);\n@@ -405,7 +399,7 @@ emit_call_1 (funexp, funtype, stack_size, struct_value_size, next_arg_reg,\n #endif\n     abort ();\n \n-  /* Find the CALL insn we just emitted and write the USE insns before it.  */\n+  /* Find the CALL insn we just emitted.  */\n   for (call_insn = get_last_insn ();\n        call_insn && GET_CODE (call_insn) != CALL_INSN;\n        call_insn = PREV_INSN (call_insn))\n@@ -414,8 +408,8 @@ emit_call_1 (funexp, funtype, stack_size, struct_value_size, next_arg_reg,\n   if (! call_insn)\n     abort ();\n \n-  /* Put the USE insns before the CALL.  */\n-  emit_insns_before (use_insns, call_insn);\n+  /* Put the register usage information on the CALL.  */\n+  CALL_INSN_FUNCTION_USAGE (call_insn) = call_fusage;\n \n   /* If this is a const call, then set the insn's unchanging bit.  */\n   if (is_const)\n@@ -436,7 +430,9 @@ emit_call_1 (funexp, funtype, stack_size, struct_value_size, next_arg_reg,\n   if (stack_size != 0 && RETURN_POPS_ARGS (funtype, stack_size) > 0)\n     {\n       if (!already_popped)\n-\temit_insn (gen_rtx (CLOBBER, VOIDmode, stack_pointer_rtx));\n+\tCALL_INSN_FUNCTION_USAGE (call_insn) =\n+\t   gen_rtx (EXPR_LIST, CLOBBER, stack_pointer_rtx,\n+\t\t    CALL_INSN_FUNCTION_USAGE (call_insn));\n       stack_size -= RETURN_POPS_ARGS (funtype, stack_size);\n       stack_size_rtx = GEN_INT (stack_size);\n     }\n@@ -573,7 +569,7 @@ expand_call (exp, target, ignore)\n   int old_stack_arg_under_construction;\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n   tree old_cleanups = cleanups_this_call;\n-  rtx use_insns = 0;\n+  rtx call_fusage = 0;\n   register tree p;\n   register int i, j;\n \n@@ -1773,22 +1769,17 @@ expand_call (exp, target, ignore)\n \t\t\t\t force_operand (structure_value_addr,\n \t\t\t\t\t\tNULL_RTX)));\n       if (GET_CODE (struct_value_rtx) == REG)\n-\t{\n-\t  push_to_sequence (use_insns);\n-\t  emit_insn (gen_rtx (USE, VOIDmode, struct_value_rtx));\n-\t  use_insns = get_insns ();\n-\t  end_sequence ();\n-\t}\n+\t  use_reg (&call_fusage, struct_value_rtx);\n     }\n \n-  funexp = prepare_call_address (funexp, fndecl, &use_insns, reg_parm_seen);\n+  funexp = prepare_call_address (funexp, fndecl, &call_fusage, reg_parm_seen);\n \n   /* Now do the register loads required for any wholly-register parms or any\n      parms which are passed both on the stack and in a register.  Their\n      expressions were already evaluated. \n \n      Mark all register-parms as living through the call, putting these USE\n-     insns in a list headed by USE_INSNS.  */\n+     insns in the CALL_INSN_FUNCTION_USAGE field.  */\n \n   for (i = 0; i < num_actuals; i++)\n     {\n@@ -1838,13 +1829,7 @@ expand_call (exp, target, ignore)\n \t\t\t       validize_mem (args[i].value), nregs,\n \t\t\t       args[i].mode);\n \t\n-\t  push_to_sequence (use_insns);\n-\t  if (nregs == -1)\n-\t    emit_insn (gen_rtx (USE, VOIDmode, reg));\n-\t  else\n-\t    use_regs (REGNO (reg), nregs);\n-\t  use_insns = get_insns ();\n-\t  end_sequence ();\n+\t  use_regs (&call_fusage, reg, REGNO (reg), nregs);\n \n \t  /* PARTIAL referred only to the first register, so clear it for the\n \t     next time.  */\n@@ -1860,7 +1845,7 @@ expand_call (exp, target, ignore)\n   /* Generate the actual call instruction.  */\n   emit_call_1 (funexp, funtype, args_size.constant, struct_value_size,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n-\t       valreg, old_inhibit_defer_pop, use_insns, is_const);\n+\t       valreg, old_inhibit_defer_pop, call_fusage, is_const);\n \n   /* If call is cse'able, make appropriate pair of reg-notes around it.\n      Test valreg so we don't crash; may safely ignore `const'\n@@ -2121,7 +2106,7 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \t       struct args_size offset; struct args_size size; };\n   struct arg *argvec;\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n-  rtx use_insns;\n+  rtx call_fusage = 0;\n   /* library calls are never indirect calls.  */\n   int current_call_is_indirect = 0;\n \n@@ -2317,7 +2302,7 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n   argnum = 0;\n #endif\n \n-  fun = prepare_call_address (fun, NULL_TREE, &use_insns, 0);\n+  fun = prepare_call_address (fun, NULL_TREE, &call_fusage, 0);\n \n   /* Now load any reg parms into their regs.  */\n \n@@ -2338,13 +2323,9 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n     emit_queue ();\n \n   /* Any regs containing parms remain in use through the call.  */\n-  start_sequence ();\n   for (count = 0; count < nargs; count++)\n     if (argvec[count].reg != 0)\n-      emit_insn (gen_rtx (USE, VOIDmode, argvec[count].reg));\n-\n-  use_insns = get_insns ();\n-  end_sequence ();\n+       use_reg (&call_fusage, argvec[count].reg);\n \n   /* Don't allow popping to be deferred, since then\n      cse'ing of library calls could delete a call and leave the pop.  */\n@@ -2356,7 +2337,7 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n   emit_call_1 (fun, get_identifier (XSTR (orgfun, 0)), args_size.constant, 0,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n \t       outmode != VOIDmode ? hard_libcall_value (outmode) : NULL_RTX,\n-\t       old_inhibit_defer_pop + 1, use_insns, no_queue);\n+\t       old_inhibit_defer_pop + 1, call_fusage, no_queue);\n \n   pop_temp_slots ();\n \n@@ -2398,7 +2379,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \t       struct args_size offset; struct args_size size; };\n   struct arg *argvec;\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n-  rtx use_insns;\n+  rtx call_fusage = 0;\n   rtx mem_value = 0;\n   int pcc_struct_value = 0;\n   int struct_value_size = 0;\n@@ -2668,7 +2649,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n   argnum = 0;\n #endif\n \n-  fun = prepare_call_address (fun, NULL_TREE, &use_insns, 0);\n+  fun = prepare_call_address (fun, NULL_TREE, &call_fusage, 0);\n \n   /* Now load any reg parms into their regs.  */\n \n@@ -2691,13 +2672,9 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n #endif\n \n   /* Any regs containing parms remain in use through the call.  */\n-  start_sequence ();\n   for (count = 0; count < nargs; count++)\n     if (argvec[count].reg != 0)\n-      emit_insn (gen_rtx (USE, VOIDmode, argvec[count].reg));\n-\n-  use_insns = get_insns ();\n-  end_sequence ();\n+       use_reg (&call_fusage, argvec[count].reg);\n \n   /* Pass the function the address in which to return a structure value.  */\n   if (mem_value != 0 && struct_value_rtx != 0 && ! pcc_struct_value)\n@@ -2707,12 +2684,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \t\t\t\t force_operand (XEXP (mem_value, 0),\n \t\t\t\t\t\tNULL_RTX)));\n       if (GET_CODE (struct_value_rtx) == REG)\n-\t{\n-\t  push_to_sequence (use_insns);\n-\t  emit_insn (gen_rtx (USE, VOIDmode, struct_value_rtx));\n-\t  use_insns = get_insns ();\n-\t  end_sequence ();\n-\t}\n+\t  use_reg (&call_fusage, struct_value_rtx);\n     }\n \n   /* Don't allow popping to be deferred, since then\n@@ -2727,7 +2699,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n \t       (outmode != VOIDmode && mem_value == 0\n \t\t? hard_libcall_value (outmode) : NULL_RTX),\n-\t       old_inhibit_defer_pop + 1, use_insns, is_const);\n+\t       old_inhibit_defer_pop + 1, call_fusage, is_const);\n \n   /* Now restore inhibit_defer_pop to its actual original value.  */\n   OK_DEFER_POP;"}]}