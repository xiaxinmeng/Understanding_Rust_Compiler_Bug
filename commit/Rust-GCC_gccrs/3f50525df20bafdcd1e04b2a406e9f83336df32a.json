{"sha": "3f50525df20bafdcd1e04b2a406e9f83336df32a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y1MDUyNWRmMjBiYWZkY2QxZTA0YjJhNDA2ZTlmODMzMzZkZjMyYQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2016-01-05T20:17:26Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2016-01-05T20:17:26Z"}, "message": "Add vector_memory_operand and \"Bm\" constraint\n\nSSE vector arithmetic and logic instructions only accept aligned memory\noperand.  This patch adds vector_memory_operand and \"Bm\" constraint for\naligned SSE memory operand.  They are applied to SSE plusminus and\nany_logic patterns.\n\ngcc/\n\n\tPR target/68991\n\t* config/i386/constraints.md (Bm): New constraint.\n\t* config/i386/predicates.md (vector_memory_operand): New\n\tpredicate.\n\t* config/i386/sse.md: Replace xm with xBm in plusminus and\n\tany_logic patterns.\n\ngcc/testsuite/\n\n\tPR target/68991\n\t* g++.dg/pr68991-1.C: New test.\n\t* g++.dg/pr68991-2.C: Likewise.\n\nFrom-SVN: r232087", "tree": {"sha": "0bec7b41fbd97e8a68bdfad816048f68a21849d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bec7b41fbd97e8a68bdfad816048f68a21849d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f50525df20bafdcd1e04b2a406e9f83336df32a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f50525df20bafdcd1e04b2a406e9f83336df32a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f50525df20bafdcd1e04b2a406e9f83336df32a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f50525df20bafdcd1e04b2a406e9f83336df32a/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ae120683c6a300fecd8b82ef2451faec3932688e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae120683c6a300fecd8b82ef2451faec3932688e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae120683c6a300fecd8b82ef2451faec3932688e"}], "stats": {"total": 427, "additions": 418, "deletions": 9}, "files": [{"sha": "264a7b6a4da6f5676d30f367b38a367fc1788820", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f50525df20bafdcd1e04b2a406e9f83336df32a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f50525df20bafdcd1e04b2a406e9f83336df32a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f50525df20bafdcd1e04b2a406e9f83336df32a", "patch": "@@ -1,3 +1,12 @@\n+2016-01-05  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/68991\n+\t* config/i386/constraints.md (Bm): New constraint.\n+\t* config/i386/predicates.md (vector_memory_operand): New\n+\tpredicate.\n+\t* config/i386/sse.md: Replace xm with xBm in plusminus and\n+\tany_logic patterns.\n+\n 2016-01-05  Sandra Loosemore <sandra@codesourcery.com>\n \n \tPR 1078"}, {"sha": "bac9d6668a8d09e25e3e715e82bd20e75fd07212", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f50525df20bafdcd1e04b2a406e9f83336df32a/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f50525df20bafdcd1e04b2a406e9f83336df32a/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=3f50525df20bafdcd1e04b2a406e9f83336df32a", "patch": "@@ -148,6 +148,7 @@\n ;; We use the B prefix to denote any number of internal operands:\n ;;  f  FLAGS_REG\n ;;  g  GOT memory operand.\n+;;  m  Vector memory operand\n ;;  s  Sibcall memory operand, not valid for TARGET_X32\n ;;  w  Call memory operand, not valid for TARGET_X32\n ;;  z  Constant call address operand.\n@@ -160,6 +161,10 @@\n   \"@internal GOT memory operand.\"\n   (match_operand 0 \"GOT_memory_operand\"))\n \n+(define_constraint \"Bm\"\n+  \"@internal Vector memory operand.\"\n+  (match_operand 0 \"vector_memory_operand\"))\n+\n (define_constraint \"Bs\"\n   \"@internal Sibcall memory operand.\"\n   (ior (and (not (match_test \"TARGET_X32\"))"}, {"sha": "33b35945092ea8ce030af5166bc859f2b2d63d73", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f50525df20bafdcd1e04b2a406e9f83336df32a/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f50525df20bafdcd1e04b2a406e9f83336df32a/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=3f50525df20bafdcd1e04b2a406e9f83336df32a", "patch": "@@ -951,6 +951,13 @@\n        (match_test \"INTEGRAL_MODE_P (GET_MODE (op))\")\n        (match_test \"op == CONSTM1_RTX (GET_MODE (op))\")))\n \n+; Return true when OP is operand acceptable for vector memory operand.\n+; Only AVX can have misaligned memory operand.\n+(define_predicate \"vector_memory_operand\"\n+  (and (match_operand 0 \"memory_operand\")\n+       (ior (match_test \"TARGET_AVX\")\n+\t    (match_test \"MEM_ALIGN (op) >= GET_MODE_ALIGNMENT (mode)\"))))\n+\n ; Return true when OP is operand acceptable for standard SSE move.\n (define_predicate \"vector_move_operand\"\n   (ior (match_operand 0 \"nonimmediate_operand\")"}, {"sha": "ca3a831184fd6e5c34e4d33624523bac7efbfc62", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f50525df20bafdcd1e04b2a406e9f83336df32a/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f50525df20bafdcd1e04b2a406e9f83336df32a/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=3f50525df20bafdcd1e04b2a406e9f83336df32a", "patch": "@@ -1676,7 +1676,7 @@\n   [(set (match_operand:VF 0 \"register_operand\" \"=x,v\")\n \t(plusminus:VF\n \t  (match_operand:VF 1 \"<round_nimm_predicate>\" \"<comm>0,v\")\n-\t  (match_operand:VF 2 \"<round_nimm_predicate>\" \"xm,<round_constraint>\")))]\n+\t  (match_operand:VF 2 \"<round_nimm_predicate>\" \"xBm,<round_constraint>\")))]\n   \"TARGET_SSE && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands) && <mask_mode512bit_condition> && <round_mode512bit_condition>\"\n   \"@\n    <plusminus_mnemonic><ssemodesuffix>\\t{%2, %0|%0, %2}\n@@ -1691,7 +1691,7 @@\n \t(vec_merge:VF_128\n \t  (plusminus:VF_128\n \t    (match_operand:VF_128 1 \"register_operand\" \"0,v\")\n-\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm,<round_constraint>\"))\n+\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xBm,<round_constraint>\"))\n \t  (match_dup 1)\n \t  (const_int 1)))]\n   \"TARGET_SSE\"\n@@ -2424,7 +2424,7 @@\n \t  (vec_concat:V2SF\n \t    (plusminus:SF\n \t      (vec_select:SF\n-\t\t(match_operand:V4SF 2 \"nonimmediate_operand\" \"xm,xm\")\n+\t\t(match_operand:V4SF 2 \"nonimmediate_operand\" \"xBm,xm\")\n \t\t(parallel [(const_int 0)]))\n \t      (vec_select:SF (match_dup 2) (parallel [(const_int 1)])))\n \t    (plusminus:SF\n@@ -3240,7 +3240,7 @@\n   [(set (match_operand:VF_128_256 0 \"register_operand\" \"=x,v\")\n \t(any_logic:VF_128_256\n \t  (match_operand:VF_128_256 1 \"nonimmediate_operand\" \"%0,v\")\n-\t  (match_operand:VF_128_256 2 \"nonimmediate_operand\" \"xm,vm\")))]\n+\t  (match_operand:VF_128_256 2 \"nonimmediate_operand\" \"xBm,vm\")))]\n   \"TARGET_SSE && <mask_avx512vl_condition>\n    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n {\n@@ -3489,7 +3489,7 @@\n   [(set (match_operand:TF 0 \"register_operand\" \"=x,x\")\n \t(any_logic:TF\n \t  (match_operand:TF 1 \"nonimmediate_operand\" \"%0,x\")\n-\t  (match_operand:TF 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+\t  (match_operand:TF 2 \"nonimmediate_operand\" \"xBm,xm\")))]\n   \"TARGET_SSE\n    && ix86_binary_operator_ok (<CODE>, TFmode, operands)\"\n {\n@@ -9653,7 +9653,7 @@\n   [(set (match_operand:VI_AVX2 0 \"register_operand\" \"=x,v\")\n \t(plusminus:VI_AVX2\n \t  (match_operand:VI_AVX2 1 \"nonimmediate_operand\" \"<comm>0,v\")\n-\t  (match_operand:VI_AVX2 2 \"nonimmediate_operand\" \"xm,vm\")))]\n+\t  (match_operand:VI_AVX2 2 \"nonimmediate_operand\" \"xBm,vm\")))]\n   \"TARGET_SSE2\n    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n   \"@\n@@ -9706,7 +9706,7 @@\n   [(set (match_operand:VI12_AVX2 0 \"register_operand\" \"=x,v\")\n \t(sat_plusminus:VI12_AVX2\n \t  (match_operand:VI12_AVX2 1 \"nonimmediate_operand\" \"<comm>0,v\")\n-\t  (match_operand:VI12_AVX2 2 \"nonimmediate_operand\" \"xm,vm\")))]\n+\t  (match_operand:VI12_AVX2 2 \"nonimmediate_operand\" \"xBm,vm\")))]\n   \"TARGET_SSE2 && <mask_mode512bit_condition> && <mask_avx512bw_condition>\n    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n   \"@\n@@ -11361,7 +11361,7 @@\n   [(set (match_operand:VI48_AVX_AVX512F 0 \"register_operand\" \"=x,v\")\n \t(any_logic:VI48_AVX_AVX512F\n \t  (match_operand:VI48_AVX_AVX512F 1 \"nonimmediate_operand\" \"%0,v\")\n-\t  (match_operand:VI48_AVX_AVX512F 2 \"nonimmediate_operand\" \"xm,vm\")))]\n+\t  (match_operand:VI48_AVX_AVX512F 2 \"nonimmediate_operand\" \"xBm,vm\")))]\n   \"TARGET_SSE && <mask_mode512bit_condition>\n    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n {\n@@ -11457,7 +11457,7 @@\n   [(set (match_operand:VI12_AVX_AVX512F 0 \"register_operand\" \"=x,v\")\n \t(any_logic: VI12_AVX_AVX512F\n \t  (match_operand:VI12_AVX_AVX512F 1 \"nonimmediate_operand\" \"%0,v\")\n-\t  (match_operand:VI12_AVX_AVX512F 2 \"nonimmediate_operand\" \"xm,vm\")))]\n+\t  (match_operand:VI12_AVX_AVX512F 2 \"nonimmediate_operand\" \"xBm,vm\")))]\n   \"TARGET_SSE && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n {\n   static char buf[64];"}, {"sha": "64e13d66318c44eb9f87a52a70cb3a94520dde7e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f50525df20bafdcd1e04b2a406e9f83336df32a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f50525df20bafdcd1e04b2a406e9f83336df32a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3f50525df20bafdcd1e04b2a406e9f83336df32a", "patch": "@@ -1,3 +1,9 @@\n+2016-01-05  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/68991\n+\t* g++.dg/pr68991-1.C: New test.\n+\t* g++.dg/pr68991-2.C: Likewise.\n+\n 2016-01-05  Sergei Trofimovich <siarheit@google.com>\n \n         PR other/60465"}, {"sha": "744d13c791512c550d2505335a11968cc2af2917", "filename": "gcc/testsuite/g++.dg/pr68991-1.C", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f50525df20bafdcd1e04b2a406e9f83336df32a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr68991-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f50525df20bafdcd1e04b2a406e9f83336df32a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr68991-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr68991-1.C?ref=3f50525df20bafdcd1e04b2a406e9f83336df32a", "patch": "@@ -0,0 +1,191 @@\n+// { dg-do compile { target i?86-*-* x86_64-*-* } }\n+// { dg-options \"-std=c++11 -O3 -msse2 -mno-avx -fno-exceptions -fno-rtti -fdump-rtl-final\" }\n+\n+typedef unsigned int size_type;\n+\n+#define _GLIBCXX_BITSET_BITS_PER_WORD  (__CHAR_BIT__ * __SIZEOF_INT__)\n+#define _GLIBCXX_BITSET_WORDS(__n) \\\n+  ((__n) / _GLIBCXX_BITSET_BITS_PER_WORD + \\\n+   ((__n) % _GLIBCXX_BITSET_BITS_PER_WORD == 0 ? 0 : 1))\n+\n+namespace std\n+{\n+  template<size_type _Nw>\n+    struct _Base_bitset\n+    {\n+      typedef unsigned int _WordT;\n+      _WordT \t\t_M_w[_Nw];\n+\n+      _WordT&\n+      _M_hiword()\n+      { return _M_w[_Nw - 1]; }\n+\n+      void\n+      _M_do_and(const _Base_bitset<_Nw>& __x)\n+      {\n+\tfor (size_type __i = 0; __i < _Nw; __i++)\n+\t  _M_w[__i] &= __x._M_w[__i];\n+      }\n+\n+      void\n+      _M_do_flip()\n+      {\n+\tfor (size_type __i = 0; __i < _Nw; __i++)\n+\t  _M_w[__i] = ~_M_w[__i];\n+      }\n+\n+      bool\n+      _M_is_equal(const _Base_bitset<_Nw>& __x) const\n+      {\n+\tfor (size_type __i = 0; __i < _Nw; ++__i)\n+\t  if (_M_w[__i] != __x._M_w[__i])\n+\t    return false;\n+\treturn true;\n+      }\n+\n+      bool\n+      _M_is_any() const\n+      {\n+\tfor (size_type __i = 0; __i < _Nw; __i++)\n+\t  if (_M_w[__i] != static_cast<_WordT>(0))\n+\t    return true;\n+\treturn false;\n+      }\n+    };\n+\n+  template<size_type _Extrabits>\n+    struct _Sanitize\n+    {\n+      typedef unsigned int _WordT;\n+\n+      static void\n+      _S_do_sanitize(_WordT& __val)\n+      { __val &= ~((~static_cast<_WordT>(0)) << _Extrabits); }\n+    };\n+\n+  template<size_type _Nb>\n+    class bitset\n+    : private _Base_bitset<_GLIBCXX_BITSET_WORDS(_Nb)>\n+    {\n+    private:\n+      typedef _Base_bitset<_GLIBCXX_BITSET_WORDS(_Nb)> _Base;\n+      typedef unsigned int _WordT;\n+\n+      void\n+      _M_do_sanitize()\n+      {\n+\ttypedef _Sanitize<_Nb % _GLIBCXX_BITSET_BITS_PER_WORD> __sanitize_type;\n+\t__sanitize_type::_S_do_sanitize(this->_M_hiword());\n+      }\n+\n+    public:\n+      class reference\n+      {\n+\tfriend class bitset;\n+\n+\t_WordT*\t_M_wp;\n+\tsize_type \t_M_bpos;\n+\n+      public:\n+\treference&\n+\tflip()\n+\t{\n+\t  *_M_wp ^= _Base::_S_maskbit(_M_bpos);\n+\t  return *this;\n+\t}\n+      };\n+\n+      bitset<_Nb>&\n+      operator&=(const bitset<_Nb>& __rhs)\n+      {\n+\tthis->_M_do_and(__rhs);\n+\treturn *this;\n+      }\n+\n+      bitset<_Nb>&\n+      flip()\n+      {\n+\tthis->_M_do_flip();\n+\tthis->_M_do_sanitize();\n+\treturn *this;\n+      }\n+\n+      bitset<_Nb>\n+      operator~() const\n+      { return bitset<_Nb>(*this).flip(); }\n+\n+      bool\n+      operator==(const bitset<_Nb>& __rhs) const\n+      { return this->_M_is_equal(__rhs); }\n+\n+      bool\n+      any() const\n+      { return this->_M_is_any(); }\n+    };\n+\n+  template<size_type _Nb>\n+    inline bitset<_Nb>\n+    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y)\n+    {\n+      bitset<_Nb> __result(__x);\n+      __result &= __y;\n+      return __result;\n+    }\n+}\n+template<typename T>\n+class ArrayRef {\n+public:\n+    typedef const T *iterator;\n+\n+private:\n+    const T *Data;\n+    size_type Length;\n+\n+public:\n+    iterator begin() const { return Data; }\n+    iterator end() const { return Data + Length; }\n+};\n+\n+const unsigned MAX_SUBTARGET_FEATURES = 128;\n+class FeatureBitset : public std::bitset<MAX_SUBTARGET_FEATURES> {\n+};\n+\n+struct SubtargetFeatureKV {\n+  FeatureBitset Value;\n+  FeatureBitset Implies;\n+};\n+\n+struct SubtargetInfoKV {\n+  const void *Value;\n+};\n+class SubtargetFeatures {\n+public:\n+    FeatureBitset ToggleFeature(FeatureBitset Bits,\n+\t\t\t\tconst SubtargetFeatureKV *,\n+\t\t\t\tArrayRef<SubtargetFeatureKV> FeatureTable);\n+};\n+\n+static\n+void ClearImpliedBits(FeatureBitset &Bits,\n+\t\t      const SubtargetFeatureKV *FeatureEntry,\n+\t\t      ArrayRef<SubtargetFeatureKV> FeatureTable) {\n+  for (auto &FE : FeatureTable) {\n+    if ((FE.Implies & FeatureEntry->Value).any()) {\n+      Bits &= ~FE.Value;\n+      ClearImpliedBits(Bits, &FE, FeatureTable);\n+    }\n+  }\n+}\n+\n+FeatureBitset\n+SubtargetFeatures::ToggleFeature(FeatureBitset Bits,\n+\t\t\t\t const SubtargetFeatureKV *FeatureEntry,\n+\t\t\t\t ArrayRef<SubtargetFeatureKV> FeatureTable) {\n+    if ((Bits & FeatureEntry->Value) == FeatureEntry->Value) {\n+      Bits &= ~FeatureEntry->Value;\n+      ClearImpliedBits(Bits, FeatureEntry, FeatureTable);\n+    }\n+  return Bits;\n+}\n+\n+// { dg-final { scan-rtl-dump-not \"S16 A32\\[^\\n\\]*\\\\\\*xorv4si3\" \"final\" } }"}, {"sha": "a3c59f02c57aaf438778d8a2295a6cc3157f3499", "filename": "gcc/testsuite/g++.dg/pr68991-2.C", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f50525df20bafdcd1e04b2a406e9f83336df32a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr68991-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f50525df20bafdcd1e04b2a406e9f83336df32a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr68991-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr68991-2.C?ref=3f50525df20bafdcd1e04b2a406e9f83336df32a", "patch": "@@ -0,0 +1,191 @@\n+// { dg-do compile { target i?86-*-* x86_64-*-* } }\n+// { dg-options \"-std=c++11 -O3 -msse2 -mno-avx -fno-exceptions -fno-rtti -fdump-rtl-final\" }\n+\n+typedef unsigned int size_type;\n+\n+#define _GLIBCXX_BITSET_BITS_PER_WORD  (__CHAR_BIT__ * __SIZEOF_INT__)\n+#define _GLIBCXX_BITSET_WORDS(__n) \\\n+  ((__n) / _GLIBCXX_BITSET_BITS_PER_WORD + \\\n+   ((__n) % _GLIBCXX_BITSET_BITS_PER_WORD == 0 ? 0 : 1))\n+\n+namespace std\n+{\n+  template<size_type _Nw>\n+    struct _Base_bitset\n+    {\n+      typedef unsigned int _WordT;\n+      _WordT \t\t_M_w[_Nw];\n+\n+      _WordT&\n+      _M_hiword()\n+      { return _M_w[_Nw - 1]; }\n+\n+      void\n+      _M_do_and(const _Base_bitset<_Nw>& __x)\n+      {\n+\tfor (size_type __i = 0; __i < _Nw; __i++)\n+\t  _M_w[__i] += __x._M_w[__i];\n+      }\n+\n+      void\n+      _M_do_flip()\n+      {\n+\tfor (size_type __i = 0; __i < _Nw; __i++)\n+\t  _M_w[__i] = ~_M_w[__i];\n+      }\n+\n+      bool\n+      _M_is_equal(const _Base_bitset<_Nw>& __x) const\n+      {\n+\tfor (size_type __i = 0; __i < _Nw; ++__i)\n+\t  if (_M_w[__i] != __x._M_w[__i])\n+\t    return false;\n+\treturn true;\n+      }\n+\n+      bool\n+      _M_is_any() const\n+      {\n+\tfor (size_type __i = 0; __i < _Nw; __i++)\n+\t  if (_M_w[__i] != static_cast<_WordT>(0))\n+\t    return true;\n+\treturn false;\n+      }\n+    };\n+\n+  template<size_type _Extrabits>\n+    struct _Sanitize\n+    {\n+      typedef unsigned int _WordT;\n+\n+      static void\n+      _S_do_sanitize(_WordT& __val)\n+      { __val &= ~((~static_cast<_WordT>(0)) << _Extrabits); }\n+    };\n+\n+  template<size_type _Nb>\n+    class bitset\n+    : private _Base_bitset<_GLIBCXX_BITSET_WORDS(_Nb)>\n+    {\n+    private:\n+      typedef _Base_bitset<_GLIBCXX_BITSET_WORDS(_Nb)> _Base;\n+      typedef unsigned int _WordT;\n+\n+      void\n+      _M_do_sanitize()\n+      {\n+\ttypedef _Sanitize<_Nb % _GLIBCXX_BITSET_BITS_PER_WORD> __sanitize_type;\n+\t__sanitize_type::_S_do_sanitize(this->_M_hiword());\n+      }\n+\n+    public:\n+      class reference\n+      {\n+\tfriend class bitset;\n+\n+\t_WordT*\t_M_wp;\n+\tsize_type \t_M_bpos;\n+\n+      public:\n+\treference&\n+\tflip()\n+\t{\n+\t  *_M_wp ^= _Base::_S_maskbit(_M_bpos);\n+\t  return *this;\n+\t}\n+      };\n+\n+      bitset<_Nb>&\n+      operator&=(const bitset<_Nb>& __rhs)\n+      {\n+\tthis->_M_do_and(__rhs);\n+\treturn *this;\n+      }\n+\n+      bitset<_Nb>&\n+      flip()\n+      {\n+\tthis->_M_do_flip();\n+\tthis->_M_do_sanitize();\n+\treturn *this;\n+      }\n+\n+      bitset<_Nb>\n+      operator~() const\n+      { return bitset<_Nb>(*this).flip(); }\n+\n+      bool\n+      operator==(const bitset<_Nb>& __rhs) const\n+      { return this->_M_is_equal(__rhs); }\n+\n+      bool\n+      any() const\n+      { return this->_M_is_any(); }\n+    };\n+\n+  template<size_type _Nb>\n+    inline bitset<_Nb>\n+    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y)\n+    {\n+      bitset<_Nb> __result(__x);\n+      __result &= __y;\n+      return __result;\n+    }\n+}\n+template<typename T>\n+class ArrayRef {\n+public:\n+    typedef const T *iterator;\n+\n+private:\n+    const T *Data;\n+    size_type Length;\n+\n+public:\n+    iterator begin() const { return Data; }\n+    iterator end() const { return Data + Length; }\n+};\n+\n+const unsigned MAX_SUBTARGET_FEATURES = 128;\n+class FeatureBitset : public std::bitset<MAX_SUBTARGET_FEATURES> {\n+};\n+\n+struct SubtargetFeatureKV {\n+  FeatureBitset Value;\n+  FeatureBitset Implies;\n+};\n+\n+struct SubtargetInfoKV {\n+  const void *Value;\n+};\n+class SubtargetFeatures {\n+public:\n+    FeatureBitset ToggleFeature(FeatureBitset Bits,\n+\t\t\t\tconst SubtargetFeatureKV *,\n+\t\t\t\tArrayRef<SubtargetFeatureKV> FeatureTable);\n+};\n+\n+static\n+void ClearImpliedBits(FeatureBitset &Bits,\n+\t\t      const SubtargetFeatureKV *FeatureEntry,\n+\t\t      ArrayRef<SubtargetFeatureKV> FeatureTable) {\n+  for (auto &FE : FeatureTable) {\n+    if ((FE.Implies & FeatureEntry->Value).any()) {\n+      Bits &= ~FE.Value;\n+      ClearImpliedBits(Bits, &FE, FeatureTable);\n+    }\n+  }\n+}\n+\n+FeatureBitset\n+SubtargetFeatures::ToggleFeature(FeatureBitset Bits,\n+\t\t\t\t const SubtargetFeatureKV *FeatureEntry,\n+\t\t\t\t ArrayRef<SubtargetFeatureKV> FeatureTable) {\n+    if ((Bits & FeatureEntry->Value) == FeatureEntry->Value) {\n+      Bits &= ~FeatureEntry->Value;\n+      ClearImpliedBits(Bits, FeatureEntry, FeatureTable);\n+    }\n+  return Bits;\n+}\n+\n+// { dg-final { scan-rtl-dump-not \"S16 A32\\[^\\n\\]*\\\\\\*addv4si3\" \"final\" } }"}]}