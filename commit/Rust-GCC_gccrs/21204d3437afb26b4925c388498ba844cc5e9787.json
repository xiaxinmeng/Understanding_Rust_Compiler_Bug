{"sha": "21204d3437afb26b4925c388498ba844cc5e9787", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjEyMDRkMzQzN2FmYjI2YjQ5MjVjMzg4NDk4YmE4NDRjYzVlOTc4Nw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-16T04:39:52Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-16T04:39:52Z"}, "message": "function.c (identify_blocks): Don't shadow a variable in an outer scope.\n\n\t* function.c (identify_blocks): Don't shadow a variable in an\n\touter scope.\n\t* integrate.c (integrate_decl_tree): Don't use pushlevel,\n\tpushdecl, or poplevel to build up the new BLOCK tree.\n\t(expand_inline_function): Likewise.\n\t(integrate_parm_decls): Likewise.\n\nFrom-SVN: r29453", "tree": {"sha": "9f1e32dcb6ee61b0b40d777e706ee53e82c17df2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f1e32dcb6ee61b0b40d777e706ee53e82c17df2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21204d3437afb26b4925c388498ba844cc5e9787", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21204d3437afb26b4925c388498ba844cc5e9787", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21204d3437afb26b4925c388498ba844cc5e9787", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21204d3437afb26b4925c388498ba844cc5e9787/comments", "author": null, "committer": null, "parents": [{"sha": "afbadaa70142eb2bd4aa91103d236c3b5b59945d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afbadaa70142eb2bd4aa91103d236c3b5b59945d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afbadaa70142eb2bd4aa91103d236c3b5b59945d"}], "stats": {"total": 92, "additions": 51, "deletions": 41}, "files": [{"sha": "40e358e463c767e8f4075ab26ff8a5a7212ab4eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21204d3437afb26b4925c388498ba844cc5e9787/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21204d3437afb26b4925c388498ba844cc5e9787/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21204d3437afb26b4925c388498ba844cc5e9787", "patch": "@@ -1,3 +1,12 @@\n+Wed Sep 15 21:37:06 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* function.c (identify_blocks): Don't shadow a variable in an \n+\touter scope.\n+\t* integrate.c (integrate_decl_tree): Don't use pushlevel,\n+\tpushdecl, or poplevel to build up the new BLOCK tree.\n+\t(expand_inline_function): Likewise.\n+\t(integrate_parm_decls): Likewise.\n+\n Wed Sep 15 21:20:38 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* c-typeck.c (qualify_type): Merge qualifiers from both types."}, {"sha": "81a1ef16170d9ec4b183e5a88dd0d868a9491808", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21204d3437afb26b4925c388498ba844cc5e9787/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21204d3437afb26b4925c388498ba844cc5e9787/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=21204d3437afb26b4925c388498ba844cc5e9787", "patch": "@@ -5421,11 +5421,11 @@ identify_blocks (block, insns)\n       {\n \tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n \t  {\n-\t    tree block;\n+\t    tree b;\n \n-\t    block = block_vector[current_block_number++];\n-\t    NOTE_BLOCK (insn) = block;\n-\t    block_stack[depth++] = block;\n+\t    b = block_vector[current_block_number++];\n+\t    NOTE_BLOCK (insn) = b;\n+\t    block_stack[depth++] = b;\n \t  }\n \tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n \t  NOTE_BLOCK (insn) = block_stack[--depth];"}, {"sha": "3c278767ce021719f2ea51e62819377499865fce", "filename": "gcc/integrate.c", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21204d3437afb26b4925c388498ba844cc5e9787/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21204d3437afb26b4925c388498ba844cc5e9787/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=21204d3437afb26b4925c388498ba844cc5e9787", "patch": "@@ -65,7 +65,7 @@ static void adjust_copied_decl_tree\tPROTO((tree));\n static void note_modified_parmregs\tPROTO((rtx, rtx));\n static void integrate_parm_decls\tPROTO((tree, struct inline_remap *,\n \t\t\t\t\t       rtvec));\n-static void integrate_decl_tree\t\tPROTO((tree, int,\n+static tree integrate_decl_tree\t\tPROTO((tree,\n \t\t\t\t\t       struct inline_remap *));\n static void subst_constants\t\tPROTO((rtx *, rtx,\n \t\t\t\t\t       struct inline_remap *));\n@@ -581,11 +581,6 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n     expand_expr (TREE_VALUE (actual), const0_rtx,\n \t\t TYPE_MODE (TREE_TYPE (TREE_VALUE (actual))), 0);\n \n-  /* Make a binding contour to keep inline cleanups called at\n-     outer function-scope level from looking like they are shadowing\n-     parameter declarations.  */\n-  pushlevel (0);\n-\n   /* Expand the function arguments.  Do this first so that any\n      new registers get created before we allocate the maps.  */\n \n@@ -985,7 +980,6 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n   /* Make a fresh binding contour that we can easily remove.  Do this after\n      expanding our arguments so cleanups are properly scoped.  */\n-  pushlevel (0);\n   expand_start_bindings (0);\n \n   /* Initialize label_map.  get_label_from_map will actually make\n@@ -1281,17 +1275,18 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n   inline_function_decl = fndecl;\n   integrate_parm_decls (DECL_ARGUMENTS (fndecl), map, arg_vector);\n-  integrate_decl_tree (inl_f->original_decl_initial, 0, map);\n+  block = integrate_decl_tree (inl_f->original_decl_initial, map);\n+  BLOCK_ABSTRACT_ORIGIN (block) = (DECL_ABSTRACT_ORIGIN (fndecl) == NULL\n+\t\t\t\t   ? fndecl : DECL_ABSTRACT_ORIGIN (fndecl));\n   inline_function_decl = 0;\n+  insert_block (block);\n \n   /* End the scope containing the copied formal parameter variables\n-     and copied LABEL_DECLs.  */\n-\n-  expand_end_bindings (getdecls (), 1, 1);\n-  block = poplevel (1, 1, 0);\n-  BLOCK_ABSTRACT_ORIGIN (block) = (DECL_ABSTRACT_ORIGIN (fndecl) == NULL\n-\t\t\t\t   ? fndecl : DECL_ABSTRACT_ORIGIN (fndecl));\n-  poplevel (0, 0, 0);\n+     and copied LABEL_DECLs.  We pass NULL_TREE for the variables list\n+     here so that expand_end_bindings will not check for unused\n+     variables.  That's already been checked for when the inlined\n+     function was defined.  */\n+  expand_end_bindings (NULL_TREE, 1, 1);\n \n   /* Must mark the line number note after inlined functions as a repeat, so\n      that the test coverage code can avoid counting the call twice.  This\n@@ -1355,7 +1350,7 @@ integrate_parm_decls (args, map, arg_vector)\n       TREE_USED (decl) = 1;\n       /* Prevent warning for shadowing with these.  */\n       DECL_ABSTRACT_ORIGIN (decl) = DECL_ORIGIN (tail);\n-      pushdecl (decl);\n+      DECL_CONTEXT (decl) = current_function_decl;\n       /* Fully instantiate the address with the equivalent form so that the\n \t debugging information contains the actual register, instead of the\n \t virtual register.   Do this by not passing an insn to\n@@ -1369,24 +1364,22 @@ integrate_parm_decls (args, map, arg_vector)\n /* Given a BLOCK node LET, push decls and levels so as to construct in the\n    current function a tree of contexts isomorphic to the one that is given.\n \n-   LEVEL indicates how far down into the BLOCK tree is the node we are\n-   currently traversing.  It is always zero except for recursive calls.\n-\n    MAP, if nonzero, is a pointer to an inline_remap map which indicates how\n    registers used in the DECL_RTL field should be remapped.  If it is zero,\n    no mapping is necessary.  */\n \n-static void\n-integrate_decl_tree (let, level, map)\n+static tree\n+integrate_decl_tree (let, map)\n      tree let;\n-     int level;\n      struct inline_remap *map;\n {\n-  tree t, node;\n+  tree t;\n+  tree new_block;\n+  tree *next;\n+\n+  new_block = make_node (BLOCK);\n+  next = &BLOCK_VARS (new_block);\n \n-  if (level > 0)\n-    pushlevel (0);\n-  \n   for (t = BLOCK_VARS (let); t; t = TREE_CHAIN (t))\n     {\n       tree d;\n@@ -1412,21 +1405,29 @@ integrate_decl_tree (let, level, map)\n       if (DECL_LANG_SPECIFIC (d))\n \tcopy_lang_decl (d);\n \n-      pushdecl (d);\n-    }\n+      /* This new declaration is now in the scope of the function into\n+\t which we are inlining the function, not the function being\n+\t inlined.  */\n+      DECL_CONTEXT (d) = current_function_decl;\n \n-  for (t = BLOCK_SUBBLOCKS (let); t; t = TREE_CHAIN (t))\n-    integrate_decl_tree (t, level + 1, map);\n+      /* Add this declaration to the list of variables in the new\n+\t block.  */\n+      *next = d;\n+      next = &TREE_CHAIN (d);\n+    }\n \n-  if (level > 0)\n+  next = &BLOCK_SUBBLOCKS (new_block);\n+  for (t = BLOCK_SUBBLOCKS (let); t; t = BLOCK_CHAIN (t))\n     {\n-      node = poplevel (1, 0, 0);\n-      if (node)\n-\t{\n-\t  TREE_USED (node) = TREE_USED (let);\n-\t  BLOCK_ABSTRACT_ORIGIN (node) = let;\n-\t}\n+      *next = integrate_decl_tree (t, map);\n+      BLOCK_SUPERCONTEXT (*next) = new_block;\n+      next = &BLOCK_CHAIN (*next);\n     }\n+\n+  TREE_USED (new_block) = TREE_USED (let);\n+  BLOCK_ABSTRACT_ORIGIN (new_block) = let;\n+  \n+  return new_block;\n }\n \f\n /* Create a new copy of an rtx."}]}