{"sha": "ca4cd906cb7f2e95a6c8c514d2a3902700bb774e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E0Y2Q5MDZjYjdmMmU5NWE2YzhjNTE0ZDJhMzkwMjcwMGJiNzc0ZQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-10-18T07:44:13Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-10-18T07:44:13Z"}, "message": "combine.c (get_last_value): If the last set of a register is after subst_low_cuid...\n\n        * combine.c (get_last_value): If the last set of a register\n        is after subst_low_cuid, then we can not use it to determine\n        the register's last value.\n\nFrom-SVN: r30062", "tree": {"sha": "e5e3da686d35692bf81574149a7ae8cbffbdbe24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5e3da686d35692bf81574149a7ae8cbffbdbe24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca4cd906cb7f2e95a6c8c514d2a3902700bb774e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca4cd906cb7f2e95a6c8c514d2a3902700bb774e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca4cd906cb7f2e95a6c8c514d2a3902700bb774e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca4cd906cb7f2e95a6c8c514d2a3902700bb774e/comments", "author": null, "committer": null, "parents": [{"sha": "d336e5046cf250cdf8a7a39cef1540287a07c8b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d336e5046cf250cdf8a7a39cef1540287a07c8b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d336e5046cf250cdf8a7a39cef1540287a07c8b9"}], "stats": {"total": 62, "additions": 8, "deletions": 54}, "files": [{"sha": "4bbe8e9b077d9104279f1604a6aadebc4c4d7900", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca4cd906cb7f2e95a6c8c514d2a3902700bb774e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca4cd906cb7f2e95a6c8c514d2a3902700bb774e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca4cd906cb7f2e95a6c8c514d2a3902700bb774e", "patch": "@@ -1,3 +1,9 @@\n+Mon Oct 18 01:41:35 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* combine.c (get_last_value): If the last set of a register\n+\tis after subst_low_cuid, then we can not use it to determine\n+\tthe register's last value.\n+\n Sun Oct 17 11:02:52 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Makefile.in: Back out previous change."}, {"sha": "4ed1124a3dcb5c318e297c7a268f027f8ca0717e", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 54, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca4cd906cb7f2e95a6c8c514d2a3902700bb774e/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca4cd906cb7f2e95a6c8c514d2a3902700bb774e/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ca4cd906cb7f2e95a6c8c514d2a3902700bb774e", "patch": "@@ -10952,61 +10952,9 @@ get_last_value (x)\n     return 0;\n \n   /* If the value was set in a later insn than the ones we are processing,\n-     we can't use it even if the register was only set once, but make a quick\n-     check to see if the previous insn set it to something.  This is commonly\n-     the case when the same pseudo is used by repeated insns.\n-\n-     This does not work if there exists an instruction which is temporarily\n-     not on the insn chain.  */\n-\n+     we can't use it even if the register was only set once.  */\n   if (INSN_CUID (reg_last_set[regno]) >= subst_low_cuid)\n-    {\n-      rtx insn, set;\n-\n-      /* We can't do anything if the value is set in between the insns we are\n-\t processing.  */\n-      if (INSN_CUID (reg_last_set[regno]) <= INSN_CUID (subst_insn))\n-\treturn 0;\n-\n-      /* We can not do anything useful in this case, because there is\n-\t an instruction which is not on the insn chain.  */\n-      if (subst_prev_insn)\n-\treturn 0;\n-\n-      /* Skip over USE insns.  They are not useful here, and they may have\n-\t been made by combine, in which case they do not have a INSN_CUID\n-\t value.  We can't use prev_real_insn, because that would incorrectly\n-\t take us backwards across labels.  Skip over BARRIERs also, since\n-\t they could have been made by combine.  If we see one, we must be\n-\t optimizing dead code, so it doesn't matter what we do.  */\n-      for (insn = prev_nonnote_insn (subst_insn);\n-\t   insn && ((GET_CODE (insn) == INSN\n-\t\t     && GET_CODE (PATTERN (insn)) == USE)\n-\t\t    || GET_CODE (insn) == BARRIER\n-\t\t    || INSN_CUID (insn) >= subst_low_cuid);\n-\t   insn = prev_nonnote_insn (insn))\n-\t;\n-\n-      if (insn\n-\t  && (set = single_set (insn)) != 0\n-\t  && rtx_equal_p (SET_DEST (set), x))\n-\t{\n-\t  value = SET_SRC (set);\n-\n-\t  /* Make sure that VALUE doesn't reference X.  Replace any\n-\t     explicit references with a CLOBBER.  If there are any remaining\n-\t     references (rare), don't use the value.  */\n-\n-\t  if (reg_mentioned_p (x, value))\n-\t    value = replace_rtx (copy_rtx (value), x,\n-\t\t\t\t gen_rtx_CLOBBER (GET_MODE (x), const0_rtx));\n-\n-\t  if (reg_overlap_mentioned_p (x, value))\n-\t    return 0;\n-\t}\n-      else\n-\treturn 0;\n-    }\n+    return 0;\n \n   /* If the value has all its registers valid, return it.  */\n   if (get_last_value_validate (&value, reg_last_set[regno],"}]}