{"sha": "ff4fa9934e4ebecfdca45f00efa9f523b11f717a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY0ZmE5OTM0ZTRlYmVjZmRjYTQ1ZjAwZWZhOWY1MjNiMTFmNzE3YQ==", "commit": {"author": {"name": "Yuri Rumyantsev", "email": "ysrumyan@gmail.com", "date": "2016-08-10T15:03:02Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2016-08-10T15:03:02Z"}, "message": "re PR middle-end/71734 (FAIL: libgomp.fortran/simd4.f90   -O3 -g  execution test)\n\nFix PR tree-optimization/71734\n\n2016-08-10  Yuri Rumyantsev  <ysrumyan@gmail.com>\n\n\tPR tree-optimization/71734\n\t* tree-ssa-loop-im.c (ref_indep_loop_p): Add new argument\n\tREF_LOOP, invoke ref_indep_loop_p_1.\n\t(outermost_indep_loop): Pass LOOP argumnet where REF was defined\n\tto ref_indep_loop_p.\n\t(ref_indep_loop_p_1): Fix commentary, add argument REF_LOOP,\n\tcombine it with ref_indep_lopp_p_2, update SAFELEN if only REF\n\tis inside LOOP, do not cache dpendence value for loops with\n\tnon-zero SAFELEN.\n\t(ref_indep_loop_p_2): Delete function.\n\t(can_sm_ref_p): Pass LOOP as additional argument to\n\tref_indep_loop_p.\n\nFrom-SVN: r239326", "tree": {"sha": "168fc62f9cd808b9e77cd1ef42fe162b6df8c7b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/168fc62f9cd808b9e77cd1ef42fe162b6df8c7b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff4fa9934e4ebecfdca45f00efa9f523b11f717a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff4fa9934e4ebecfdca45f00efa9f523b11f717a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff4fa9934e4ebecfdca45f00efa9f523b11f717a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff4fa9934e4ebecfdca45f00efa9f523b11f717a/comments", "author": {"login": "ysrumyan", "id": 44425612, "node_id": "MDQ6VXNlcjQ0NDI1NjEy", "avatar_url": "https://avatars.githubusercontent.com/u/44425612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysrumyan", "html_url": "https://github.com/ysrumyan", "followers_url": "https://api.github.com/users/ysrumyan/followers", "following_url": "https://api.github.com/users/ysrumyan/following{/other_user}", "gists_url": "https://api.github.com/users/ysrumyan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysrumyan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysrumyan/subscriptions", "organizations_url": "https://api.github.com/users/ysrumyan/orgs", "repos_url": "https://api.github.com/users/ysrumyan/repos", "events_url": "https://api.github.com/users/ysrumyan/events{/privacy}", "received_events_url": "https://api.github.com/users/ysrumyan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a0883b0800b7a63d8b68a418df694ff1da5b9381", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0883b0800b7a63d8b68a418df694ff1da5b9381", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0883b0800b7a63d8b68a418df694ff1da5b9381"}], "stats": {"total": 118, "additions": 68, "deletions": 50}, "files": [{"sha": "a0a3698601fb6a8776e9f945dcb9d980cd7da430", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4fa9934e4ebecfdca45f00efa9f523b11f717a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4fa9934e4ebecfdca45f00efa9f523b11f717a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff4fa9934e4ebecfdca45f00efa9f523b11f717a", "patch": "@@ -1,3 +1,18 @@\n+2016-08-10  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\tPR tree-optimization/71734\n+\t* tree-ssa-loop-im.c (ref_indep_loop_p): Add new argument\n+\tREF_LOOP, invoke ref_indep_loop_p_1.\n+\t(outermost_indep_loop): Pass LOOP argumnet where REF was defined\n+\tto ref_indep_loop_p.\n+\t(ref_indep_loop_p_1): Fix commentary, add argument REF_LOOP,\n+\tcombine it with ref_indep_lopp_p_2, update SAFELEN if only REF\n+\tis inside LOOP, do not cache dpendence value for loops with\n+\tnon-zero SAFELEN.\n+\t(ref_indep_loop_p_2): Delete function.\n+\t(can_sm_ref_p): Pass LOOP as additional argument to\n+\tref_indep_loop_p.\n+\n 2016-08-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/72853"}, {"sha": "463db048cb6468da476ba0e499bb31c0a6384c30", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 53, "deletions": 50, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4fa9934e4ebecfdca45f00efa9f523b11f717a/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4fa9934e4ebecfdca45f00efa9f523b11f717a/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=ff4fa9934e4ebecfdca45f00efa9f523b11f717a", "patch": "@@ -196,7 +196,7 @@ static struct\n static bitmap_obstack lim_bitmap_obstack;\n static obstack mem_ref_obstack;\n \n-static bool ref_indep_loop_p (struct loop *, im_mem_ref *);\n+static bool ref_indep_loop_p (struct loop *, im_mem_ref *, struct loop *);\n \n /* Minimum cost of an expensive expression.  */\n #define LIM_EXPENSIVE ((unsigned) PARAM_VALUE (PARAM_LIM_EXPENSIVE))\n@@ -544,10 +544,10 @@ outermost_indep_loop (struct loop *outer, struct loop *loop, im_mem_ref *ref)\n        aloop != loop;\n        aloop = superloop_at_depth (loop, loop_depth (aloop) + 1))\n     if ((!ref->stored || !bitmap_bit_p (ref->stored, aloop->num))\n-\t&& ref_indep_loop_p (aloop, ref))\n+\t&& ref_indep_loop_p (aloop, ref, loop))\n       return aloop;\n \n-  if (ref_indep_loop_p (loop, ref))\n+  if (ref_indep_loop_p (loop, ref, loop))\n     return loop;\n   else\n     return NULL;\n@@ -2109,27 +2109,32 @@ record_dep_loop (struct loop *loop, im_mem_ref *ref, bool stored_p)\n     loop = loop_outer (loop);\n }\n \n-/* Returns true if REF in REF_LOOP is independent on all other memory\n-   references in LOOP.  */\n+/* Returns true if REF is independent on all other memory\n+   references in LOOP.  REF_LOOP is where REF is accessed, SAFELEN is the\n+   safelen to apply.  */\n \n static bool\n-ref_indep_loop_p_1 (int safelen, struct loop *loop,\n-\t\t    im_mem_ref *ref, bool stored_p)\n+ref_indep_loop_p_1 (int safelen, struct loop *loop, im_mem_ref *ref,\n+\t\t    bool stored_p, struct loop *ref_loop)\n {\n+  stored_p |= (ref->stored && bitmap_bit_p (ref->stored, loop->num));\n+\n+  if (loop->safelen > safelen\n+      /* Check that REF is accessed inside LOOP.  */\n+      && (loop == ref_loop || flow_loop_nested_p (loop, ref_loop)))\n+    safelen = loop->safelen;\n+\n+  bool indep_p = true;\n   bitmap refs_to_check;\n-  unsigned i;\n-  bitmap_iterator bi;\n-  im_mem_ref *aref;\n \n   if (stored_p)\n     refs_to_check = &memory_accesses.refs_in_loop[loop->num];\n   else\n     refs_to_check = &memory_accesses.refs_stored_in_loop[loop->num];\n \n   if (bitmap_bit_p (refs_to_check, UNANALYZABLE_MEM_ID))\n-    return false;\n-\n-  if (safelen > 1)\n+    indep_p = false;\n+  else if (safelen > 1)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -2138,47 +2143,45 @@ ref_indep_loop_p_1 (int safelen, struct loop *loop,\n \t  print_generic_expr (dump_file, ref->mem.ref, TDF_SLIM);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n+\n+      /* Avoid caching here as safelen depends on context and refs\n+         are shared between different contexts.  */\n       return true;\n     }\n-\n-  EXECUTE_IF_SET_IN_BITMAP (refs_to_check, 0, i, bi)\n+  else\n     {\n-      aref = memory_accesses.refs_list[i];\n-      if (!refs_independent_p (ref, aref))\n+      if (bitmap_bit_p (&ref->indep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n+\treturn true;\n+      if (bitmap_bit_p (&ref->dep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n \treturn false;\n-    }\n-\n-  return true;\n-}\n-\n-/* Returns true if REF in REF_LOOP is independent on all other memory\n-   references in LOOP.  Wrapper over ref_indep_loop_p_1, caching its\n-   results.  */\n-\n-static bool\n-ref_indep_loop_p_2 (int safelen, struct loop *loop,\n-\t\t    im_mem_ref *ref, bool stored_p)\n-{\n-  stored_p |= (ref->stored && bitmap_bit_p (ref->stored, loop->num));\n \n-  if (bitmap_bit_p (&ref->indep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n-    return true;\n-  if (bitmap_bit_p (&ref->dep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n-    return false;\n-\n-  if (loop->safelen > safelen)\n-    safelen = loop->safelen;\n+      struct loop *inner = loop->inner;\n+      while (inner)\n+\t{\n+\t  if (!ref_indep_loop_p_1 (safelen, inner, ref, stored_p, ref_loop))\n+\t    {\n+\t      indep_p = false;\n+\t      break;\n+\t    }\n+\t  inner = inner->next;\n+\t}\n \n-  struct loop *inner = loop->inner;\n-  while (inner)\n-    {\n-      if (!ref_indep_loop_p_2 (safelen, inner, ref, stored_p))\n-\treturn false;\n-      inner = inner->next;\n+      if (indep_p)\n+\t{\n+\t  unsigned i;\n+\t  bitmap_iterator bi;\n+\t  EXECUTE_IF_SET_IN_BITMAP (refs_to_check, 0, i, bi)\n+\t    {\n+\t      im_mem_ref *aref = memory_accesses.refs_list[i];\n+\t      if (!refs_independent_p (ref, aref))\n+\t\t{\n+\t\t  indep_p = false;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n     }\n \n-  bool indep_p = ref_indep_loop_p_1 (safelen, loop, ref, stored_p);\n-\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Querying dependencies of ref %u in loop %d: %s\\n\",\n \t     ref->id, loop->num, indep_p ? \"independent\" : \"dependent\");\n@@ -2209,14 +2212,14 @@ ref_indep_loop_p_2 (int safelen, struct loop *loop,\n }\n \n /* Returns true if REF is independent on all other memory references in\n-   LOOP.  */\n+   LOOP.  REF_LOOP is the loop where REF is accessed.  */\n \n static bool\n-ref_indep_loop_p (struct loop *loop, im_mem_ref *ref)\n+ref_indep_loop_p (struct loop *loop, im_mem_ref *ref, struct loop *ref_loop)\n {\n   gcc_checking_assert (MEM_ANALYZABLE (ref));\n \n-  return ref_indep_loop_p_2 (0, loop, ref, false);\n+  return ref_indep_loop_p_1 (0, loop, ref, false, ref_loop);\n }\n \n /* Returns true if we can perform store motion of REF from LOOP.  */\n@@ -2252,7 +2255,7 @@ can_sm_ref_p (struct loop *loop, im_mem_ref *ref)\n \n   /* And it must be independent on all other memory references\n      in LOOP.  */\n-  if (!ref_indep_loop_p (loop, ref))\n+  if (!ref_indep_loop_p (loop, ref, loop))\n     return false;\n \n   return true;"}]}