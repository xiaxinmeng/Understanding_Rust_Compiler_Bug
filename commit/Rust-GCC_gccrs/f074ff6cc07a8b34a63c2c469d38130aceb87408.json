{"sha": "f074ff6cc07a8b34a63c2c469d38130aceb87408", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA3NGZmNmNjMDdhOGIzNGE2M2MyYzQ2OWQzODEzMGFjZWI4NzQwOA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-08-16T21:25:39Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-08-16T21:25:39Z"}, "message": "re PR middle-end/28071 (A file that can not be compiled in reasonable time/space)\n\n\tPR rtl-optimization/28071\n\t* basic-block.h (bb_dom_dfs_in, bb_dom_dfs_out): Declare.\n\t* dominance.c (bb_dom_dfs_in, bb_dom_dfs_out): New functions.\n\t* tree-into-ssa.c (struct dom_dfsnum): New.\n\t(cmp_dfsnum, find_dfsnum_interval, prune_unused_phi_nodes): New\n\tfunctions.\n\t(insert_phi_nodes_for): Use prune_unused_phi_nodes instead of\n\tcompute_global_livein.\n\t(prepare_block_for_update, prepare_use_sites_for): Mark the uses\n\tin phi nodes in the correct blocks.\n\nFrom-SVN: r116190", "tree": {"sha": "6f3474092c924d2afcf2cb8918768de6c4b76758", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f3474092c924d2afcf2cb8918768de6c4b76758"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f074ff6cc07a8b34a63c2c469d38130aceb87408", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f074ff6cc07a8b34a63c2c469d38130aceb87408", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f074ff6cc07a8b34a63c2c469d38130aceb87408", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f074ff6cc07a8b34a63c2c469d38130aceb87408/comments", "author": null, "committer": null, "parents": [{"sha": "b43a2366d696649472d8615dec3765fecc54477a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b43a2366d696649472d8615dec3765fecc54477a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b43a2366d696649472d8615dec3765fecc54477a"}], "stats": {"total": 308, "additions": 268, "deletions": 40}, "files": [{"sha": "bd98986eef44ff94961f7a708b95cbaafc725014", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f074ff6cc07a8b34a63c2c469d38130aceb87408/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f074ff6cc07a8b34a63c2c469d38130aceb87408/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f074ff6cc07a8b34a63c2c469d38130aceb87408", "patch": "@@ -1,3 +1,16 @@\n+2006-08-16  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR rtl-optimization/28071\n+\t* basic-block.h (bb_dom_dfs_in, bb_dom_dfs_out): Declare.\n+\t* dominance.c (bb_dom_dfs_in, bb_dom_dfs_out): New functions.\n+\t* tree-into-ssa.c (struct dom_dfsnum): New.\n+\t(cmp_dfsnum, find_dfsnum_interval, prune_unused_phi_nodes): New\n+\tfunctions.\n+\t(insert_phi_nodes_for): Use prune_unused_phi_nodes instead of\n+\tcompute_global_livein.\n+\t(prepare_block_for_update, prepare_use_sites_for): Mark the uses\n+\tin phi nodes in the correct blocks.\n+\n 2006-08-16  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR tree-optimization/28364"}, {"sha": "9be90975d46fdf8056b1fd4b76ed9ee5ffcb9e91", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f074ff6cc07a8b34a63c2c469d38130aceb87408/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f074ff6cc07a8b34a63c2c469d38130aceb87408/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=f074ff6cc07a8b34a63c2c469d38130aceb87408", "patch": "@@ -988,6 +988,9 @@ extern void iterate_fix_dominators (enum cdi_direction, basic_block *, int);\n extern void verify_dominators (enum cdi_direction);\n extern basic_block first_dom_son (enum cdi_direction, basic_block);\n extern basic_block next_dom_son (enum cdi_direction, basic_block);\n+unsigned bb_dom_dfs_in (enum cdi_direction, basic_block);\n+unsigned bb_dom_dfs_out (enum cdi_direction, basic_block);\n+\n extern edge try_redirect_by_replacing_jump (edge, basic_block, bool);\n extern void break_superblocks (void);\n extern void check_bb_profile (basic_block, FILE *);"}, {"sha": "819e7d450299d9214be7bc03cee85b5f777d6327", "filename": "gcc/dominance.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f074ff6cc07a8b34a63c2c469d38130aceb87408/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f074ff6cc07a8b34a63c2c469d38130aceb87408/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=f074ff6cc07a8b34a63c2c469d38130aceb87408", "patch": "@@ -909,6 +909,28 @@ dominated_by_p (enum cdi_direction dir, basic_block bb1, basic_block bb2)\n   return et_below (n1, n2);\n }\n \n+/* Returns the entry dfs number for basic block BB, in the direction DIR.  */\n+\n+unsigned\n+bb_dom_dfs_in (enum cdi_direction dir, basic_block bb)\n+{\n+  struct et_node *n = bb->dom[dir];\n+\n+  gcc_assert (dom_computed[dir] == DOM_OK);\n+  return n->dfs_num_in;\n+}\n+\n+/* Returns the exit dfs number for basic block BB, in the direction DIR.  */\n+\n+unsigned\n+bb_dom_dfs_out (enum cdi_direction dir, basic_block bb)\n+{\n+  struct et_node *n = bb->dom[dir];\n+\n+  gcc_assert (dom_computed[dir] == DOM_OK);\n+  return n->dfs_num_out;\n+}\n+\n /* Verify invariants of dominator structure.  */\n void\n verify_dominators (enum cdi_direction dir)"}, {"sha": "38f338a058b20f4d2f9ff29256a5ba8e656b6a07", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 230, "deletions": 40, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f074ff6cc07a8b34a63c2c469d38130aceb87408/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f074ff6cc07a8b34a63c2c469d38130aceb87408/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=f074ff6cc07a8b34a63c2c469d38130aceb87408", "patch": "@@ -779,6 +779,214 @@ mark_def_sites (struct dom_walk_data *walk_data,\n     SET_BIT (gd->interesting_blocks, bb->index);\n }\n \n+/* Structure used by prune_unused_phi_nodes to record bounds of the intervals\n+   in the dfs numbering of the dominance tree.  */\n+\n+struct dom_dfsnum\n+{\n+  /* Basic block whose index this entry corresponds to.  */\n+  unsigned bb_index;\n+\n+  /* The dfs number of this node.  */\n+  unsigned dfs_num;\n+};\n+\n+/* Compares two entries of type struct dom_dfsnum by dfs_num field.  Callback\n+   for qsort.  */\n+\n+static int\n+cmp_dfsnum (const void *a, const void *b)\n+{\n+  const struct dom_dfsnum *da = a;\n+  const struct dom_dfsnum *db = b;\n+\n+  return (int) da->dfs_num - (int) db->dfs_num;\n+}\n+\n+/* Among the intervals starting at the N points specified in DEFS, find\n+   the one that contains S, and return its bb_index.  */\n+\n+static unsigned\n+find_dfsnum_interval (struct dom_dfsnum *defs, unsigned n, unsigned s)\n+{\n+  unsigned f = 0, t = n, m;\n+\n+  while (t > f + 1)\n+    {\n+      m = (f + t) / 2;\n+      if (defs[m].dfs_num <= s)\n+\tf = m;\n+      else\n+\tt = m;\n+    }\n+\n+  return defs[f].bb_index;\n+}\n+\n+/* Clean bits from PHIS for phi nodes whose value cannot be used in USES.\n+   KILLS is a bitmap of blocks where the value is defined before any use.  */\n+\n+static void\n+prune_unused_phi_nodes (bitmap phis, bitmap kills, bitmap uses)\n+{\n+  VEC(int, heap) *worklist;\n+  bitmap_iterator bi;\n+  unsigned i, b, p, u, top;\n+  bitmap live_phis;\n+  basic_block def_bb, use_bb;\n+  edge e;\n+  edge_iterator ei;\n+  bitmap to_remove;\n+  struct dom_dfsnum *defs;\n+  unsigned n_defs, adef;\n+\n+  if (bitmap_empty_p (uses))\n+    {\n+      bitmap_clear (phis);\n+      return;\n+    }\n+\n+  /* The phi must dominate a use, or an argument of a live phi.  Also, we\n+     do not create any phi nodes in def blocks, unless they are also livein.  */\n+  to_remove = BITMAP_ALLOC (NULL);\n+  bitmap_and_compl (to_remove, kills, uses);\n+  bitmap_and_compl_into (phis, to_remove);\n+  if (bitmap_empty_p (phis))\n+    {\n+      BITMAP_FREE (to_remove);\n+      return;\n+    }\n+\n+  /* We want to remove the unnecessary phi nodes, but we do not want to compute\n+     liveness information, as that may be linear in the size of CFG, and if\n+     there are lot of different variables to rewrite, this may lead to quadratic\n+     behavior.\n+\n+     Instead, we basically emulate standard dce.  We put all uses to worklist,\n+     then for each of them find the nearest def that dominates them.  If this\n+     def is a phi node, we mark it live, and if it was not live before, we\n+     add the predecessors of its basic block to the worklist.\n+   \n+     To quickly locate the nearest def that dominates use, we use dfs numbering\n+     of the dominance tree (that is already available in order to speed up\n+     queries).  For each def, we have the interval given by the dfs number on\n+     entry to and on exit from the corresponding subtree in the dominance tree.\n+     The nearest dominator for a given use is the smallest of these intervals\n+     that contains entry and exit dfs numbers for the basic block with the use.\n+     If we store the bounds for all the uses to an array and sort it, we can\n+     locate the nearest dominating def in logarithmic time by binary search.*/\n+  bitmap_ior (to_remove, kills, phis);\n+  n_defs = bitmap_count_bits (to_remove);\n+  defs = XNEWVEC (struct dom_dfsnum, 2 * n_defs + 1);\n+  defs[0].bb_index = 1;\n+  defs[0].dfs_num = 0;\n+  adef = 1;\n+  EXECUTE_IF_SET_IN_BITMAP (to_remove, 0, i, bi)\n+    {\n+      def_bb = BASIC_BLOCK (i);\n+      defs[adef].bb_index = i;\n+      defs[adef].dfs_num = bb_dom_dfs_in (CDI_DOMINATORS, def_bb);\n+      defs[adef + 1].bb_index = i;\n+      defs[adef + 1].dfs_num = bb_dom_dfs_out (CDI_DOMINATORS, def_bb);\n+      adef += 2;\n+    }\n+  BITMAP_FREE (to_remove);\n+  gcc_assert (adef == 2 * n_defs + 1);\n+  qsort (defs, adef, sizeof (struct dom_dfsnum), cmp_dfsnum);\n+  gcc_assert (defs[0].bb_index == 1);\n+\n+  /* Now each DEFS entry contains the number of the basic block to that the\n+     dfs number corresponds.  Change them to the number of basic block that\n+     corresponds to the interval following the dfs number.  Also, for the\n+     dfs_out numbers, increase the dfs number by one (so that it corresponds\n+     to the start of the following interval, not to the end of the current\n+     one).  We use WORKLIST as a stack.  */\n+  worklist = VEC_alloc (int, heap, n_defs + 1);\n+  VEC_quick_push (int, worklist, 1);\n+  top = 1;\n+  n_defs = 1;\n+  for (i = 1; i < adef; i++)\n+    {\n+      b = defs[i].bb_index;\n+      if (b == top)\n+\t{\n+\t  /* This is a closing element.  Interval corresponding to the top\n+\t     of the stack after removing it follows.  */\n+\t  VEC_pop (int, worklist);\n+\t  top = VEC_index (int, worklist, VEC_length (int, worklist) - 1);\n+\t  defs[n_defs].bb_index = top;\n+\t  defs[n_defs].dfs_num = defs[i].dfs_num + 1;\n+\t}\n+      else\n+\t{\n+\t  /* Opening element.  Nothing to do, just push it to the stack and move\n+\t     it to the correct position.  */\n+\t  defs[n_defs].bb_index = defs[i].bb_index;\n+\t  defs[n_defs].dfs_num = defs[i].dfs_num;\n+\t  VEC_quick_push (int, worklist, b);\n+\t  top = b;\n+\t}\n+\n+      /* If this interval starts at the same point as the previous one, cancel\n+\t the previous one.  */\n+      if (defs[n_defs].dfs_num == defs[n_defs - 1].dfs_num)\n+\tdefs[n_defs - 1].bb_index = defs[n_defs].bb_index;\n+      else\n+\tn_defs++;\n+    }\n+  VEC_pop (int, worklist);\n+  gcc_assert (VEC_empty (int, worklist));\n+\n+  /* Now process the uses.  */\n+  live_phis = BITMAP_ALLOC (NULL);\n+  EXECUTE_IF_SET_IN_BITMAP (uses, 0, i, bi)\n+    {\n+      VEC_safe_push (int, heap, worklist, i);\n+    }\n+\n+  while (!VEC_empty (int, worklist))\n+    {\n+      b = VEC_pop (int, worklist);\n+      if (b == ENTRY_BLOCK)\n+\tcontinue;\n+\n+      /* If there is a phi node in USE_BB, it is made live.  Otherwise,\n+\t find the def that dominates the immediate dominator of USE_BB\n+\t (the kill in USE_BB does not dominate the use).  */\n+      if (bitmap_bit_p (phis, b))\n+\tp = b;\n+      else\n+\t{\n+\t  use_bb = get_immediate_dominator (CDI_DOMINATORS, BASIC_BLOCK (b));\n+\t  p = find_dfsnum_interval (defs, n_defs,\n+\t\t\t\t    bb_dom_dfs_in (CDI_DOMINATORS, use_bb));\n+\t  if (!bitmap_bit_p (phis, p))\n+\t    continue;\n+\t}\n+\n+      /* If the phi node is already live, there is nothing to do.  */\n+      if (bitmap_bit_p (live_phis, p))\n+\tcontinue;\n+\n+      /* Mark the phi as live, and add the new uses to the worklist.  */\n+      bitmap_set_bit (live_phis, p);\n+      def_bb = BASIC_BLOCK (p);\n+      FOR_EACH_EDGE (e, ei, def_bb->preds)\n+\t{\n+\t  u = e->src->index;\n+\t  if (bitmap_bit_p (uses, u))\n+\t    continue;\n+\n+\t  bitmap_set_bit (uses, u);\n+\t  VEC_safe_push (int, heap, worklist, u);\n+\t}\n+    }\n+\n+  VEC_free (int, heap, worklist);\n+  bitmap_copy (phis, live_phis);\n+  BITMAP_FREE (live_phis);\n+  free (defs);\n+}\n \n /* Given a set of blocks with variable definitions (DEF_BLOCKS),\n    return a bitmap with all the blocks in the iterated dominance\n@@ -926,13 +1134,12 @@ insert_phi_nodes_for (tree var, bitmap phi_insertion_points, bool update_p)\n   /* Remove the blocks where we already have PHI nodes for VAR.  */\n   bitmap_and_compl_into (phi_insertion_points, def_map->phi_blocks);\n \n-  /* Now compute global livein for this variable.  Note this modifies\n-     def_map->livein_blocks.  */\n-  compute_global_livein (def_map->livein_blocks, def_map->def_blocks);\n+  /* Remove obviously useless phi nodes.  */\n+  prune_unused_phi_nodes (phi_insertion_points, def_map->def_blocks,\n+\t\t\t  def_map->livein_blocks);\n \n   /* And insert the PHI nodes.  */\n-  EXECUTE_IF_AND_IN_BITMAP (phi_insertion_points, def_map->livein_blocks,\n-\t\t\t    0, bb_index, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (phi_insertion_points, 0, bb_index, bi)\n     {\n       bb = BASIC_BLOCK (bb_index);\n       if (update_p)\n@@ -2009,6 +2216,8 @@ prepare_block_for_update (basic_block bb, bool insert_phi_p)\n   basic_block son;\n   block_stmt_iterator si;\n   tree phi;\n+  edge e;\n+  edge_iterator ei;\n \n   mark_block_for_update (bb);\n \n@@ -2020,10 +2229,20 @@ prepare_block_for_update (basic_block bb, bool insert_phi_p)\n \n       lhs_sym = DECL_P (lhs) ? lhs : SSA_NAME_VAR (lhs);\n \n-      if (symbol_marked_for_renaming (lhs_sym))\n+      if (!symbol_marked_for_renaming (lhs_sym))\n+\tcontinue;\n+      mark_def_interesting (lhs_sym, phi, bb, insert_phi_p);\n+\n+      /* Mark the uses in phi nodes as interesting.  It would be more correct\n+\t to process the arguments of the phi nodes of the successor edges of\n+\t BB at the end of prepare_block_for_update, however, that turns out\n+\t to be significantly more expensive.  Doing it here is conservatively\n+\t correct -- it may only cause us to believe a value to be live in a\n+\t block that also contains its definition, and thus insert a few more\n+\t phi nodes for it.  */\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n-\t  mark_use_interesting (lhs_sym, phi, bb, insert_phi_p);\n-\t  mark_def_interesting (lhs_sym, phi, bb, insert_phi_p);\n+\t  mark_use_interesting (lhs_sym, phi, e->src, insert_phi_p);\n \t}\n     }\n \n@@ -2101,38 +2320,9 @@ prepare_use_sites_for (tree name, bool insert_phi_p)\n \n       if (TREE_CODE (stmt) == PHI_NODE)\n \t{\n-\t  /* Mark this use of NAME interesting for the renamer.\n-\t     Notice that we explicitly call mark_use_interesting with\n-\t     INSERT_PHI_P == false.\n-\n-\t     This is to avoid marking NAME as live-in in this block\n-\t     BB. If we were to mark NAME live-in to BB, then NAME\n-\t     would be considered live-in through ALL incoming edges to\n-\t     BB which is not what we want.  Since we are updating the\n-\t     SSA form for NAME, we don't really know what other names\n-\t     of NAME are coming in through other edges into BB.\n-\n-\t     If we considered NAME live-in at BB, then the PHI\n-\t     placement algorithm may try to insert PHI nodes in blocks\n-\t     that are not only unnecessary but also the renamer would\n-\t     not know how to fill in.  */\n-\t  mark_use_interesting (name, stmt, bb, false);\n-\n-\t  /* As discussed above, we only want to mark NAME live-in\n-\t     through the edge corresponding to its slot inside the PHI\n-\t     argument list.  So, we look for the block BB1 where NAME\n-\t     is flowing through.  If BB1 does not contain a definition\n-\t     of NAME, then consider NAME live-in at BB1.  */\n-\t  if (insert_phi_p)\n-\t    {\n-\t      int ix = PHI_ARG_INDEX_FROM_USE (use_p);\n-\t      edge e = PHI_ARG_EDGE (stmt, ix);\n-\t      basic_block bb1 = e->src;\n-\t      struct def_blocks_d *db = get_def_blocks_for (name);\n-\n-\t      if (!bitmap_bit_p (db->def_blocks, bb1->index))\n-\t\tset_livein_block (name, bb1);\n-\t    }\n+\t  int ix = PHI_ARG_INDEX_FROM_USE (use_p);\n+\t  edge e = PHI_ARG_EDGE (stmt, ix);\n+\t  mark_use_interesting (name, stmt, e->src, insert_phi_p);\n \t}\n       else\n \t{"}]}