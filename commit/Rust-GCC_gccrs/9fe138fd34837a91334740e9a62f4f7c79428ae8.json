{"sha": "9fe138fd34837a91334740e9a62f4f7c79428ae8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZlMTM4ZmQzNDgzN2E5MTMzNDc0MGU5YTYyZjRmN2M3OTQyOGFlOA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2018-08-15T21:07:08Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2018-08-15T21:07:08Z"}, "message": "i386.opt (mmitigate-rop): Mark as deprecated.\n\n\t* config/i386/i386.opt (mmitigate-rop): Mark as deprecated.\n\t* doc/invoke.texi (mmitigate-rop): Remove.\n\t* config/i386/i386.c: Do not include \"regrename.h\".\n\t(ix86_rop_should_change_byte_p, reg_encoded_number)\n\t(ix86_get_modrm_for_rop, set_rop_modrm_reg_bits, ix86_mitigate_rop):\n\tRemove.\n\t(ix86_reorg): Remove call to ix86_mitigate_rop.\n\t* config/i386/i386.md (attr \"modrm_class\"): Remove.\n\t(cmp<mode>_ccno_1, mov<mode>_xor, movstrict<mode>_xor)\n\t(x86_mov<mode>cc_0_m1. x86_mov<mode>cc_0_m1_se)\n\t(x86_mov<mode>cc_0_m1_neg): Remove modrm_class attribute override.\n\ntestsuite/Changelog:\n\n\t* gcc.target/i386/rop1.c: Remove.\n\t* gcc.target/i386/pr83554 (dg-options): Remove -mmitigate-rop.\n\nFrom-SVN: r263572", "tree": {"sha": "cadb6c44fa2f79a7de491f403881f245d7216b61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cadb6c44fa2f79a7de491f403881f245d7216b61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fe138fd34837a91334740e9a62f4f7c79428ae8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fe138fd34837a91334740e9a62f4f7c79428ae8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fe138fd34837a91334740e9a62f4f7c79428ae8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fe138fd34837a91334740e9a62f4f7c79428ae8/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "245fbaaadfb4af170b63056c0254e61201e8834f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/245fbaaadfb4af170b63056c0254e61201e8834f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/245fbaaadfb4af170b63056c0254e61201e8834f"}], "stats": {"total": 378, "additions": 24, "deletions": 354}, "files": [{"sha": "609d28b51532ea86c128718f8427df7b6e2b49e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fe138fd34837a91334740e9a62f4f7c79428ae8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fe138fd34837a91334740e9a62f4f7c79428ae8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fe138fd34837a91334740e9a62f4f7c79428ae8", "patch": "@@ -1,3 +1,17 @@\n+2018-08-15  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.opt (mmitigate-rop): Mark as deprecated.\n+\t* doc/invoke.texi (mmitigate-rop): Remove.\n+\t* config/i386/i386.c: Do not include \"regrename.h\".\n+\t(ix86_rop_should_change_byte_p, reg_encoded_number)\n+\t(ix86_get_modrm_for_rop, set_rop_modrm_reg_bits, ix86_mitigate_rop):\n+\tRemove.\n+\t(ix86_reorg): Remove call to ix86_mitigate_rop.\n+\t* config/i386/i386.md (attr \"modrm_class\"): Remove.\n+\t(cmp<mode>_ccno_1, mov<mode>_xor, movstrict<mode>_xor)\n+\t(x86_mov<mode>cc_0_m1. x86_mov<mode>cc_0_m1_se)\n+\t(x86_mov<mode>cc_0_m1_neg): Remove modrm_class attribute override.\n+\n 2018-08-15  Will Schmidt  <will_schmidt@vnet.ibm.com>\n \n \t* config/rs6000/rs600.c (rs6000_gimple_fold_builtin): Add entries to"}, {"sha": "3548de2169c2b947f132b01f6966ec38a0985218", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 314, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fe138fd34837a91334740e9a62f4f7c79428ae8/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fe138fd34837a91334740e9a62f4f7c79428ae8/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9fe138fd34837a91334740e9a62f4f7c79428ae8", "patch": "@@ -75,7 +75,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"dbgcnt.h\"\n #include \"case-cfn-macros.h\"\n-#include \"regrename.h\"\n #include \"dojump.h\"\n #include \"fold-const-call.h\"\n #include \"tree-vrp.h\"\n@@ -3135,15 +3134,6 @@ ix86_debug_options (void)\n   return;\n }\n \n-/* Return true if T is one of the bytes we should avoid with\n-   -mmitigate-rop.  */\n-\n-static bool\n-ix86_rop_should_change_byte_p (int t)\n-{\n-  return t == 0xc2 || t == 0xc3 || t == 0xca || t == 0xcb;\n-}\n-\n static const char *stringop_alg_names[] = {\n #define DEF_ENUM\n #define DEF_ALG(alg, name) #name,\n@@ -29110,98 +29100,6 @@ ix86_instantiate_decls (void)\n       instantiate_decl_rtl (s->rtl);\n }\n \f\n-/* Return the number used for encoding REG, in the range 0..7.  */\n-\n-static int\n-reg_encoded_number (rtx reg)\n-{\n-  unsigned regno = REGNO (reg);\n-  switch (regno)\n-    {\n-    case AX_REG:\n-      return 0;\n-    case CX_REG:\n-      return 1;\n-    case DX_REG:\n-      return 2;\n-    case BX_REG:\n-      return 3;\n-    case SP_REG:\n-      return 4;\n-    case BP_REG:\n-      return 5;\n-    case SI_REG:\n-      return 6;\n-    case DI_REG:\n-      return 7;\n-    default:\n-      break;\n-    }\n-  if (IN_RANGE (regno, FIRST_STACK_REG, LAST_STACK_REG))\n-    return regno - FIRST_STACK_REG;\n-  if (IN_RANGE (regno, FIRST_SSE_REG, LAST_SSE_REG))\n-    return regno - FIRST_SSE_REG;\n-  if (IN_RANGE (regno, FIRST_MMX_REG, LAST_MMX_REG))\n-    return regno - FIRST_MMX_REG;\n-  if (IN_RANGE (regno, FIRST_REX_SSE_REG, LAST_REX_SSE_REG))\n-    return regno - FIRST_REX_SSE_REG;\n-  if (IN_RANGE (regno, FIRST_REX_INT_REG, LAST_REX_INT_REG))\n-    return regno - FIRST_REX_INT_REG;\n-  if (IN_RANGE (regno, FIRST_MASK_REG, LAST_MASK_REG))\n-    return regno - FIRST_MASK_REG;\n-  return -1;\n-}\n-\n-/* Given an insn INSN with NOPERANDS OPERANDS, return the modr/m byte used\n-   in its encoding if it could be relevant for ROP mitigation, otherwise\n-   return -1.  If POPNO0 and POPNO1 are nonnull, store the operand numbers\n-   used for calculating it into them.  */\n-\n-static int\n-ix86_get_modrm_for_rop (rtx_insn *insn, rtx *operands, int noperands,\n-\t\t\tint *popno0 = 0, int *popno1 = 0)\n-{\n-  if (asm_noperands (PATTERN (insn)) >= 0)\n-    return -1;\n-  int has_modrm = get_attr_modrm (insn);\n-  if (!has_modrm)\n-    return -1;\n-  enum attr_modrm_class cls = get_attr_modrm_class (insn);\n-  rtx op0, op1;\n-  switch (cls)\n-    {\n-    case MODRM_CLASS_OP02:\n-      gcc_assert (noperands >= 3);\n-      if (popno0)\n-\t{\n-\t  *popno0 = 0;\n-\t  *popno1 = 2;\n-\t}\n-      op0 = operands[0];\n-      op1 = operands[2];\n-      break;\n-    case MODRM_CLASS_OP01:\n-      gcc_assert (noperands >= 2);\n-      if (popno0)\n-\t{\n-\t  *popno0 = 0;\n-\t  *popno1 = 1;\n-\t}\n-      op0 = operands[0];\n-      op1 = operands[1];\n-      break;\n-    default:\n-      return -1;\n-    }\n-  if (REG_P (op0) && REG_P (op1))\n-    {\n-      int enc0 = reg_encoded_number (op0);\n-      int enc1 = reg_encoded_number (op1);\n-      return 0xc0 + (enc1 << 3) + enc0;\n-    }\n-  return -1;\n-}\n-\n /* Check whether x86 address PARTS is a pc-relative address.  */\n \n bool\n@@ -42215,215 +42113,6 @@ ix86_seh_fixup_eh_fallthru (void)\n     }\n }\n \n-/* Given a register number BASE, the lowest of a group of registers, update\n-   regsets IN and OUT with the registers that should be avoided in input\n-   and output operands respectively when trying to avoid generating a modr/m\n-   byte for -mmitigate-rop.  */\n-\n-static void\n-set_rop_modrm_reg_bits (int base, HARD_REG_SET &in, HARD_REG_SET &out)\n-{\n-  SET_HARD_REG_BIT (out, base);\n-  SET_HARD_REG_BIT (out, base + 1);\n-  SET_HARD_REG_BIT (in, base + 2);\n-  SET_HARD_REG_BIT (in, base + 3);\n-}\n-\n-/* Called if -mmitigate-rop is in effect.  Try to rewrite instructions so\n-   that certain encodings of modr/m bytes do not occur.  */\n-static void\n-ix86_mitigate_rop (void)\n-{\n-  HARD_REG_SET input_risky;\n-  HARD_REG_SET output_risky;\n-  HARD_REG_SET inout_risky;\n-\n-  CLEAR_HARD_REG_SET (output_risky);\n-  CLEAR_HARD_REG_SET (input_risky);\n-  SET_HARD_REG_BIT (output_risky, AX_REG);\n-  SET_HARD_REG_BIT (output_risky, CX_REG);\n-  SET_HARD_REG_BIT (input_risky, BX_REG);\n-  SET_HARD_REG_BIT (input_risky, DX_REG);\n-  set_rop_modrm_reg_bits (FIRST_SSE_REG, input_risky, output_risky);\n-  set_rop_modrm_reg_bits (FIRST_REX_INT_REG, input_risky, output_risky);\n-  set_rop_modrm_reg_bits (FIRST_REX_SSE_REG, input_risky, output_risky);\n-  set_rop_modrm_reg_bits (FIRST_EXT_REX_SSE_REG, input_risky, output_risky);\n-  set_rop_modrm_reg_bits (FIRST_MASK_REG, input_risky, output_risky);\n-  COPY_HARD_REG_SET (inout_risky, input_risky);\n-  IOR_HARD_REG_SET (inout_risky, output_risky);\n-\n-  df_note_add_problem ();\n-  /* Fix up what stack-regs did.  */\n-  df_insn_rescan_all ();\n-  df_analyze ();\n-\n-  regrename_init (true);\n-  regrename_analyze (NULL);\n-\n-  auto_vec<du_head_p> cands;\n-  \n-  for (rtx_insn *insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    {\n-      if (!NONDEBUG_INSN_P (insn))\n-\tcontinue;\n-\n-      if (GET_CODE (PATTERN (insn)) == USE\n-\t  || GET_CODE (PATTERN (insn)) == CLOBBER)\n-\tcontinue;\n-\n-      extract_insn (insn);\n-\n-      int opno0, opno1;\n-      int modrm = ix86_get_modrm_for_rop (insn, recog_data.operand,\n-\t\t\t\t\t  recog_data.n_operands, &opno0,\n-\t\t\t\t\t  &opno1);\n-\n-      if (!ix86_rop_should_change_byte_p (modrm))\n-\tcontinue;\n-\n-      insn_rr_info *info = &insn_rr[INSN_UID (insn)];\n-\n-      /* This happens when regrename has to fail a block.  */\n-      if (!info->op_info)\n-\tcontinue;\n-\n-      if (info->op_info[opno0].n_chains != 0)\n-\t{\n-\t  gcc_assert (info->op_info[opno0].n_chains == 1);\n-\t  du_head_p op0c;\n-\t  op0c = regrename_chain_from_id (info->op_info[opno0].heads[0]->id);\n-\t  if (op0c->target_data_1 + op0c->target_data_2 == 0\n-\t      && !op0c->cannot_rename)\n-\t    cands.safe_push (op0c);\n-\n-\t  op0c->target_data_1++;\n-\t}\n-      if (info->op_info[opno1].n_chains != 0)\n-\t{\n-\t  gcc_assert (info->op_info[opno1].n_chains == 1);\n-\t  du_head_p op1c;\n-\t  op1c = regrename_chain_from_id (info->op_info[opno1].heads[0]->id);\n-\t  if (op1c->target_data_1 + op1c->target_data_2 == 0\n-\t      && !op1c->cannot_rename)\n-\t    cands.safe_push (op1c);\n-\n-\t  op1c->target_data_2++;\n-\t}\n-    }\n-\n-  int i;\n-  du_head_p head;\n-  FOR_EACH_VEC_ELT (cands, i, head)\n-    {\n-      int old_reg, best_reg;\n-      HARD_REG_SET unavailable;\n-\n-      CLEAR_HARD_REG_SET (unavailable);\n-      if (head->target_data_1)\n-\tIOR_HARD_REG_SET (unavailable, output_risky);\n-      if (head->target_data_2)\n-\tIOR_HARD_REG_SET (unavailable, input_risky);\n-\n-      int n_uses;\n-      reg_class superclass = regrename_find_superclass (head, &n_uses,\n-\t\t\t\t\t\t\t&unavailable);\n-      old_reg = head->regno;\n-      best_reg = find_rename_reg (head, superclass, &unavailable,\n-\t\t\t\t  old_reg, false);\n-      bool ok = regrename_do_replace (head, best_reg);\n-      gcc_assert (ok);\n-      if (dump_file)\n-\tfprintf (dump_file, \"Chain %d renamed as %s in %s\\n\", head->id,\n-\t\t reg_names[best_reg], reg_class_names[superclass]);\n-\n-    }\n-  \n-  regrename_finish ();\n-\n-  df_analyze ();\n-\n-  basic_block bb;\n-  regset_head live;\n-\n-  INIT_REG_SET (&live);\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      rtx_insn *insn;\n-\n-      COPY_REG_SET (&live, DF_LR_OUT (bb));\n-      df_simulate_initialize_backwards (bb, &live);\n-\n-      FOR_BB_INSNS_REVERSE (bb, insn)\n-\t{\n-\t  if (!NONDEBUG_INSN_P (insn))\n-\t    continue;\n-\n-\t  df_simulate_one_insn_backwards (bb, insn, &live);\n-\n-\t  if (GET_CODE (PATTERN (insn)) == USE\n-\t      || GET_CODE (PATTERN (insn)) == CLOBBER)\n-\t    continue;\n-\n-\t  extract_insn (insn);\n-\t  constrain_operands_cached (insn, reload_completed);\n-\t  int opno0, opno1;\n-\t  int modrm = ix86_get_modrm_for_rop (insn, recog_data.operand,\n-\t\t\t\t\t      recog_data.n_operands, &opno0,\n-\t\t\t\t\t      &opno1);\n-\t  if (modrm < 0\n-\t      || !ix86_rop_should_change_byte_p (modrm)\n-\t      || opno0 == opno1)\n-\t    continue;\n-\n-\t  rtx oldreg = recog_data.operand[opno1];\n-\t  preprocess_constraints (insn);\n-\t  const operand_alternative *alt = which_op_alt ();\n-\n-\t  int i;\n-\t  for (i = 0; i < recog_data.n_operands; i++)\n-\t    if (i != opno1\n-\t\t&& alt[i].earlyclobber\n-\t\t&& reg_overlap_mentioned_p (recog_data.operand[i],\n-\t\t\t\t\t    oldreg))\n-\t      break;\n-\n-\t  if (i < recog_data.n_operands)\n-\t    continue;\n-\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"attempting to fix modrm byte in insn %d:\"\n-\t\t     \" reg %d class %s\", INSN_UID (insn), REGNO (oldreg),\n-\t\t     reg_class_names[alt[opno1].cl]);\n-\n-\t  HARD_REG_SET unavailable;\n-\t  REG_SET_TO_HARD_REG_SET (unavailable, &live);\n-\t  SET_HARD_REG_BIT (unavailable, REGNO (oldreg));\n-\t  IOR_COMPL_HARD_REG_SET (unavailable, call_used_reg_set);\n-\t  IOR_HARD_REG_SET (unavailable, fixed_reg_set);\n-\t  IOR_HARD_REG_SET (unavailable, output_risky);\n-\t  IOR_COMPL_HARD_REG_SET (unavailable,\n-\t\t\t\t  reg_class_contents[alt[opno1].cl]);\n-\n-\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t      if (!TEST_HARD_REG_BIT (unavailable, i))\n-\t\tbreak;\n-\t  if (i == FIRST_PSEUDO_REGISTER)\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \", none available\\n\");\n-\t      continue;\n-\t    }\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \" -> %d\\n\", i);\n-\t  rtx newreg = gen_rtx_REG (recog_data.operand_mode[opno1], i);\n-\t  validate_change (insn, recog_data.operand_loc[opno1], newreg, false);\n-\t  insn = emit_insn_before (gen_move_insn (newreg, oldreg), insn);\n-\t}\n-    }\n-}\n-\n /* Implement machine specific optimizations.  We implement padding of returns\n    for K8 CPUs and pass to avoid 4 jumps in the single 16 byte window.  */\n static void\n@@ -42433,9 +42122,6 @@ ix86_reorg (void)\n      with old MDEP_REORGS that are not CFG based.  Recompute it now.  */\n   compute_bb_for_insn ();\n \n-  if (flag_mitigate_rop)\n-    ix86_mitigate_rop ();\n-  \n   if (TARGET_SEH && current_function_has_exception_handlers ())\n     ix86_seh_fixup_eh_fallthru ();\n "}, {"sha": "918241d953a656b063b827469671f0ba9e07a3bc", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fe138fd34837a91334740e9a62f4f7c79428ae8/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fe138fd34837a91334740e9a62f4f7c79428ae8/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=9fe138fd34837a91334740e9a62f4f7c79428ae8", "patch": "@@ -663,19 +663,6 @@\n \t ]\n \t (const_int 1)))\n \n-(define_attr \"modrm_class\" \"none,incdec,op0,op01,op02,pushpop,unknown\"\n-  (cond [(eq_attr \"modrm\" \"0\")\n-\t   (const_string \"none\")\n-\t (eq_attr \"type\" \"alu,imul,ishift\")\n-\t   (const_string \"op02\")\n-\t (eq_attr \"type\" \"imov,imovx,lea,alu1,icmp\")\n-\t   (const_string \"op01\")\n-\t (eq_attr \"type\" \"incdec\")\n-\t   (const_string \"incdec\")\n-\t (eq_attr \"type\" \"push,pop\")\n-\t   (const_string \"pushpop\")]\n-\t (const_string \"unknown\")))\n-\n ;; The (bounding maximum) length of an instruction in bytes.\n ;; ??? fistp and frndint are in fact fldcw/{fistp,frndint}/fldcw sequences.\n ;; Later we may want to split them and compute proper length as for\n@@ -1299,7 +1286,6 @@\n    ktest<mskmodesuffix>\\t%0, %0\"\n   [(set_attr \"type\" \"test,icmp,msklog\")\n    (set_attr \"length_immediate\" \"0,1,*\")\n-   (set_attr \"modrm_class\" \"op0,unknown,*\")\n    (set_attr \"prefix\" \"*,*,vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n@@ -1313,7 +1299,6 @@\n    cmp{<imodesuffix>}\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"test,icmp\")\n    (set_attr \"length_immediate\" \"0,1\")\n-   (set_attr \"modrm_class\" \"op0,unknown\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*cmp<mode>_1\"\n@@ -2028,7 +2013,6 @@\n   \"reload_completed\"\n   \"xor{l}\\t%k0, %k0\"\n   [(set_attr \"type\" \"alu1\")\n-   (set_attr \"modrm_class\" \"op0\")\n    (set_attr \"mode\" \"SI\")\n    (set_attr \"length_immediate\" \"0\")])\n \n@@ -2913,7 +2897,6 @@\n   \"reload_completed\"\n   \"xor{<imodesuffix>}\\t%0, %0\"\n   [(set_attr \"type\" \"alu1\")\n-   (set_attr \"modrm_class\" \"op0\")\n    (set_attr \"mode\" \"<MODE>\")\n    (set_attr \"length_immediate\" \"0\")])\n \n@@ -13585,7 +13568,6 @@\n   \"lea{q}\\t{_GLOBAL_OFFSET_TABLE_(%%rip), %0|%0, _GLOBAL_OFFSET_TABLE_[rip]}\"\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"length_address\" \"4\")\n-   (set_attr \"modrm_class\" \"unknown\")\n    (set_attr \"mode\" \"DI\")])\n \n (define_insn \"set_rip_rex64\"\n@@ -18214,7 +18196,6 @@\n   \"\"\n   \"sbb{<imodesuffix>}\\t%0, %0\"\n   [(set_attr \"type\" \"alu1\")\n-   (set_attr \"modrm_class\" \"op0\")\n    (set_attr \"use_carry\" \"1\")\n    (set_attr \"pent_pair\" \"pu\")\n    (set_attr \"mode\" \"<MODE>\")\n@@ -18230,7 +18211,6 @@\n   \"\"\n   \"sbb{<imodesuffix>}\\t%0, %0\"\n   [(set_attr \"type\" \"alu1\")\n-   (set_attr \"modrm_class\" \"op0\")\n    (set_attr \"use_carry\" \"1\")\n    (set_attr \"pent_pair\" \"pu\")\n    (set_attr \"mode\" \"<MODE>\")\n@@ -18244,7 +18224,6 @@\n   \"\"\n   \"sbb{<imodesuffix>}\\t%0, %0\"\n   [(set_attr \"type\" \"alu1\")\n-   (set_attr \"modrm_class\" \"op0\")\n    (set_attr \"use_carry\" \"1\")\n    (set_attr \"pent_pair\" \"pu\")\n    (set_attr \"mode\" \"<MODE>\")"}, {"sha": "3724994760db16d819900a2aa31b71a36cace648", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fe138fd34837a91334740e9a62f4f7c79428ae8/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fe138fd34837a91334740e9a62f4f7c79428ae8/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=9fe138fd34837a91334740e9a62f4f7c79428ae8", "patch": "@@ -842,7 +842,7 @@ Target Report Mask(ISA_CLWB) Var(ix86_isa_flags) Save\n Support CLWB instruction.\n \n mpcommit\n-Target Undocumented Warn(%<-mpcommit%> was deprecated)\n+Target Ignore Warn(%qs was deprecated)\n ;; Deprecated\n \n mfxsr\n@@ -999,8 +999,8 @@ Target RejectNegative Joined Integer Var(ix86_stack_protector_guard_symbol_str)\n Use the given symbol for addressing the stack-protector guard.\n \n mmitigate-rop\n-Target Var(flag_mitigate_rop)\n-Attempt to avoid generating instruction sequences containing ret bytes.\n+Target Ignore Warn(%qs was deprecated)\n+;; Deprecated\n \n mgeneral-regs-only\n Target Report RejectNegative Mask(GENERAL_REGS_ONLY) Var(ix86_target_flags) Save"}, {"sha": "d91e6c5e36d4fe3fbaf6817c05e5413a62f1a6dd", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fe138fd34837a91334740e9a62f4f7c79428ae8/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fe138fd34837a91334740e9a62f4f7c79428ae8/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=9fe138fd34837a91334740e9a62f4f7c79428ae8", "patch": "@@ -1292,7 +1292,7 @@ See RS/6000 and PowerPC Options.\n -malign-data=@var{type}  -mstack-protector-guard=@var{guard} @gol\n -mstack-protector-guard-reg=@var{reg} @gol\n -mstack-protector-guard-offset=@var{offset} @gol\n--mstack-protector-guard-symbol=@var{symbol} -mmitigate-rop @gol\n+-mstack-protector-guard-symbol=@var{symbol} @gol\n -mgeneral-regs-only -mcall-ms2sysv-xlogues @gol\n -mindirect-branch=@var{choice} -mfunction-return=@var{choice} @gol\n -mindirect-branch-register}\n@@ -28003,13 +28003,6 @@ which segment register (@code{%fs} or @code{%gs}) to use as base register\n for reading the canary, and from what offset from that base register.\n The default for those is as specified in the relevant ABI.\n \n-@item -mmitigate-rop\n-@opindex mmitigate-rop\n-Try to avoid generating code sequences that contain unintended return\n-opcodes, to mitigate against certain forms of attack. At the moment,\n-this option is limited in what it can do and should not be relied\n-on to provide serious protection.\n-\n @item -mgeneral-regs-only\n @opindex mgeneral-regs-only\n Generate code that uses only the general-purpose registers.  This"}, {"sha": "39ce2776578f6b341f69712f2daea4101d5c6a16", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fe138fd34837a91334740e9a62f4f7c79428ae8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fe138fd34837a91334740e9a62f4f7c79428ae8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9fe138fd34837a91334740e9a62f4f7c79428ae8", "patch": "@@ -1,3 +1,8 @@\n+2018-08-15  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* gcc.target/i386/rop1.c: Remove.\n+\t* gcc.target/i386/pr83554 (dg-options): Remove -mmitigate-rop.\n+\n 2018-08-15  Will Schmidt  <will_schmidt@vnet.ibm.com>\n \n \t* gcc.target/powerpc/fold-vec-splat-char.c: New."}, {"sha": "615971527f5992c4b9e78dc8ea6b7699bf6c8d84", "filename": "gcc/testsuite/gcc.target/i386/pr83554.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fe138fd34837a91334740e9a62f4f7c79428ae8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83554.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fe138fd34837a91334740e9a62f4f7c79428ae8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83554.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83554.c?ref=9fe138fd34837a91334740e9a62f4f7c79428ae8", "patch": "@@ -1,6 +1,6 @@\n /* PR target/83554 */\n /* { dg-do compile { target int128 } } */\n-/* { dg-options \"-Os -mmitigate-rop\" } */\n+/* { dg-options \"-Os\" } */\n \n unsigned a;\n unsigned __int128"}, {"sha": "0b37267678a5881e0606ab814161510ef90423df", "filename": "gcc/testsuite/gcc.target/i386/rop1.c", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245fbaaadfb4af170b63056c0254e61201e8834f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frop1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245fbaaadfb4af170b63056c0254e61201e8834f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frop1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frop1.c?ref=245fbaaadfb4af170b63056c0254e61201e8834f", "patch": "@@ -1,7 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-require-effective-target lp64 } */\n-/* { dg-options \"-mcmodel=medium -mmitigate-rop\" } */\n-void\n-foo (void)\n-{\n-}"}]}