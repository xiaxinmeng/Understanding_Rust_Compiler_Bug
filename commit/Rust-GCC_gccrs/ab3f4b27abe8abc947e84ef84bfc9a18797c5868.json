{"sha": "ab3f4b27abe8abc947e84ef84bfc9a18797c5868", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIzZjRiMjdhYmU4YWJjOTQ3ZTg0ZWY4NGJmYzlhMTg3OTdjNTg2OA==", "commit": {"author": {"name": "Tom de Vries", "email": "tdevries@suse.de", "date": "2020-09-22T14:38:07Z"}, "committer": {"name": "Tom de Vries", "email": "tdevries@suse.de", "date": "2020-10-05T06:53:11Z"}, "message": "[omp, ftracer] Don't duplicate blocks in SIMT region\n\nWhen running the libgomp testsuite on x86_64-linux with nvptx accelerator on\nthe test-case included in this patch, we run into:\n...\nFAIL: libgomp.fortran/pr95654.f90 -O3 -fomit-frame-pointer -funroll-loops \\\n  -fpeel-loops -ftracer -finline-functions  execution test\n...\n\nThe test-case is a minimal version of this FAIL:\n...\nFAIL: libgomp.fortran/pr66199-5.f90 -O3 -fomit-frame-pointer -funroll-loops \\\n  -fpeel-loops -ftracer -finline-functions  execution test\n...\nbut that one has stopped failing at commit c2ebf4f10de \"openmp: Add support\nfor non-rect simd and improve collapsed simd support\".\n\nThe problem is that ftracer duplicates a block containing GOMP_SIMT_VOTE_ANY.\n\nThat is, before ftracer we have (dropping the GOMP_SIMT_ prefix):\n...\nbb4(ENTER_ALLOC)\n*----------+\n|           \\\n|            \\\n|             v\n|             *\nv             bb8\n*<------------*\nbb5(VOTE_ANY)\n*-------------+\n|             |\n|             |\n|             |\n|             |\n|             v\n|             *\nv             bb7(XCHG_IDX)\n*<------------*\nbb6(EXIT)\n...\n\nThe XCHG_IDX internal-fn does inter-SIMT-lane communication, which for nvptx\nmaps onto shfl, an operator which has the requirement that the warp executing\nthe operator is convergent.  The warp diverges at bb4, and\nreconverges at bb5, and does not diverge by going to bb7, so the shfl is\nindeed executed by a convergent warp.\n\nAfter ftracer, we have:\n...\nbb4(ENTER_ALLOC)\n*----------+\n|           \\\n|            \\\n|             \\\n|              \\\nv               v\n*               *\nbb5(VOTE_ANY)   bb8(VOTE_ANY)\n*               *\n|\\             /|\n| \\  +--------+ |\n|  \\/           |\n|  /\\           |\n| /  +----------v\n|/              *\nv               bb7(XCHG_IDX)\n*<--------------*\nbb6(EXIT)\n...\n\nThe warp diverges again at bb5, but does not reconverge again before bb6, so\nthe shfl is executed by a divergent warp, which causes the FAIL.\n\nFix this by making ftracer ignore blocks containing ENTER_ALLOC, VOTE_ANY and\nEXIT, effectively treating the SIMT region conservatively.\n\nAn argument can be made that the test needs to be added in a more\ngeneric place, like gimple_can_duplicate_bb_p or some such, and that ftracer\nthen needs to use the generic test.  But that's a discussion with a much\nbroader scope, so I'm leaving that for another patch.\n\nBootstrapped and reg-tested on x86_64-linux.\n\nBuild on x86_64-linux with nvptx accelerator, tested with libgomp.\n\ngcc/ChangeLog:\n\n\tPR fortran/95654\n\t* tracer.c (ignore_bb_p): Ignore GOMP_SIMT_ENTER_ALLOC,\n\tGOMP_SIMT_VOTE_ANY and GOMP_SIMT_EXIT.\n\nlibgomp/ChangeLog:\n\n2020-10-05  Tom de Vries  <tdevries@suse.de>\n\n\tPR fortran/95654\n\t* testsuite/libgomp.fortran/pr95654.f90: New test.", "tree": {"sha": "fb97e9c578fe29054124c4db546c289101687455", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb97e9c578fe29054124c4db546c289101687455"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab3f4b27abe8abc947e84ef84bfc9a18797c5868", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab3f4b27abe8abc947e84ef84bfc9a18797c5868", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab3f4b27abe8abc947e84ef84bfc9a18797c5868", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab3f4b27abe8abc947e84ef84bfc9a18797c5868/comments", "author": {"login": "vries", "id": 4057235, "node_id": "MDQ6VXNlcjQwNTcyMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vries", "html_url": "https://github.com/vries", "followers_url": "https://api.github.com/users/vries/followers", "following_url": "https://api.github.com/users/vries/following{/other_user}", "gists_url": "https://api.github.com/users/vries/gists{/gist_id}", "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vries/subscriptions", "organizations_url": "https://api.github.com/users/vries/orgs", "repos_url": "https://api.github.com/users/vries/repos", "events_url": "https://api.github.com/users/vries/events{/privacy}", "received_events_url": "https://api.github.com/users/vries/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vries", "id": 4057235, "node_id": "MDQ6VXNlcjQwNTcyMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vries", "html_url": "https://github.com/vries", "followers_url": "https://api.github.com/users/vries/followers", "following_url": "https://api.github.com/users/vries/following{/other_user}", "gists_url": "https://api.github.com/users/vries/gists{/gist_id}", "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vries/subscriptions", "organizations_url": "https://api.github.com/users/vries/orgs", "repos_url": "https://api.github.com/users/vries/repos", "events_url": "https://api.github.com/users/vries/events{/privacy}", "received_events_url": "https://api.github.com/users/vries/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4347d36f934ac6eeb807f73d48c70b29fc3fd8fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4347d36f934ac6eeb807f73d48c70b29fc3fd8fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4347d36f934ac6eeb807f73d48c70b29fc3fd8fb"}], "stats": {"total": 29, "additions": 29, "deletions": 0}, "files": [{"sha": "5e51752d89fc9f433060cc2c0ea3b306c8bbea60", "filename": "gcc/tracer.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3f4b27abe8abc947e84ef84bfc9a18797c5868/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3f4b27abe8abc947e84ef84bfc9a18797c5868/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=ab3f4b27abe8abc947e84ef84bfc9a18797c5868", "patch": "@@ -108,6 +108,24 @@ ignore_bb_p (const_basic_block bb)\n \treturn true;\n     }\n \n+  for (gimple_stmt_iterator gsi = gsi_start_bb (CONST_CAST_BB (bb));\n+       !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *g = gsi_stmt (gsi);\n+\n+      /* An IFN_GOMP_SIMT_ENTER_ALLOC/IFN_GOMP_SIMT_EXIT call must be\n+\t duplicated as part of its group, or not at all.\n+\t The IFN_GOMP_SIMT_VOTE_ANY is currently part of such a group,\n+\t so the same holds there, but it could be argued that the\n+\t IFN_GOMP_SIMT_VOTE_ANY could be generated after that group,\n+\t in which case it could be duplicated.  */\n+      if (is_gimple_call (g)\n+\t  && (gimple_call_internal_p (g, IFN_GOMP_SIMT_ENTER_ALLOC)\n+\t      || gimple_call_internal_p (g, IFN_GOMP_SIMT_EXIT)\n+\t      || gimple_call_internal_p (g, IFN_GOMP_SIMT_VOTE_ANY)))\n+\treturn true;\n+    }\n+\n   return false;\n }\n "}, {"sha": "2dddd3df4fec91bf4e12a10be69c7c785f27687c", "filename": "libgomp/testsuite/libgomp.fortran/pr95654.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3f4b27abe8abc947e84ef84bfc9a18797c5868/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpr95654.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3f4b27abe8abc947e84ef84bfc9a18797c5868/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpr95654.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpr95654.f90?ref=ab3f4b27abe8abc947e84ef84bfc9a18797c5868", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do run }\n+program main\n+  implicit none\n+  integer :: d1\n+  !$omp target map(from: d1)\n+  !$omp teams distribute parallel do simd default(none) lastprivate(d1) num_teams (2) num_threads (1)\n+  do d1 = 0, 31\n+  end do\n+  !$omp end target\n+  if (d1 /= 32) stop 3\n+end program main"}]}