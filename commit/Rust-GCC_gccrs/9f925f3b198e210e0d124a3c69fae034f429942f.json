{"sha": "9f925f3b198e210e0d124a3c69fae034f429942f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY5MjVmM2IxOThlMjEwZTBkMTI0YTNjNjlmYWUwMzRmNDI5OTQyZg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-03T19:42:07Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-03T20:03:16Z"}, "message": "libstdc++: Refactor std::call_once internals\n\nThis separates the definition of std::__call_proxy into two funcions,\none for TLS and one for non-TLS, to make them easier to read. It also\nreplaces the __get_once_functor_lock_ptr() internal helper with a new\nset_lock_ptr(unique_lock<mutex>*) function so that __once_proxy doesn't\nneed to call it twice.\n\nlibstdc++-v3/ChangeLog:\n\n\t* src/c++11/mutex.cc [_GLIBCXX_HAVE_TLS] (__once_proxy): Define\n\tseparately for TLS targets.\n\t[!_GLIBCXX_HAVE_TLS] (__get_once_functor_lock_ptr): Replace with ...\n\t(set_lock_ptr): ... this. Set new value and return previous\n\tvalue.\n\t[!_GLIBCXX_HAVE_TLS] (__set_once_functor_lock_ptr): Adjust to\n\tuse set_lock_ptr.\n\t[!_GLIBCXX_HAVE_TLS] (__once_proxy): Likewise.", "tree": {"sha": "8663060c9f3a8a645958c05d730dcaa2702c089b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8663060c9f3a8a645958c05d730dcaa2702c089b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f925f3b198e210e0d124a3c69fae034f429942f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f925f3b198e210e0d124a3c69fae034f429942f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f925f3b198e210e0d124a3c69fae034f429942f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f925f3b198e210e0d124a3c69fae034f429942f/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed7f9957bbb5e899099e1ef0e5f6234c453ef7da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed7f9957bbb5e899099e1ef0e5f6234c453ef7da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed7f9957bbb5e899099e1ef0e5f6234c453ef7da"}], "stats": {"total": 68, "additions": 39, "deletions": 29}, "files": [{"sha": "4d42bed8ecc9017b483d11265a093b930e7f034d", "filename": "libstdc++-v3/src/c++11/mutex.cc", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f925f3b198e210e0d124a3c69fae034f429942f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fmutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f925f3b198e210e0d124a3c69fae034f429942f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fmutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fmutex.cc?ref=9f925f3b198e210e0d124a3c69fae034f429942f", "patch": "@@ -84,28 +84,26 @@ std::once_flag::_M_finish(bool returning) noexcept\n \n #endif // ! FUTEX\n \n-#ifndef _GLIBCXX_HAVE_TLS\n-namespace\n-{\n-  inline std::unique_lock<std::mutex>*&\n-  __get_once_functor_lock_ptr()\n-  {\n-    static std::unique_lock<std::mutex>* __once_functor_lock_ptr = 0;\n-    return __once_functor_lock_ptr;\n-  }\n-}\n-#endif\n-\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #ifdef _GLIBCXX_HAVE_TLS\n   __thread void* __once_callable;\n   __thread void (*__once_call)();\n-#else\n+\n+  extern \"C\" void __once_proxy()\n+  {\n+    // The caller stored a function pointer in __once_call. If it requires\n+    // any state, it gets it from __once_callable.\n+    __once_call();\n+  }\n+\n+#else // ! TLS\n+\n   // Explicit instantiation due to -fno-implicit-instantiation.\n   template class function<void()>;\n+\n   function<void()> __once_functor;\n \n   mutex&\n@@ -115,11 +113,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     return once_mutex;\n   }\n \n+namespace\n+{\n+  // Store ptr in a global variable and return the previous value.\n+  inline unique_lock<mutex>*\n+  set_lock_ptr(unique_lock<mutex>* ptr)\n+  {\n+    static unique_lock<mutex>* __once_functor_lock_ptr = nullptr;\n+    return std::__exchange(__once_functor_lock_ptr, ptr);\n+  }\n+}\n+\n   // code linked against ABI 3.4.12 and later uses this\n   void\n   __set_once_functor_lock_ptr(unique_lock<mutex>* __ptr)\n   {\n-    __get_once_functor_lock_ptr() = __ptr;\n+    (void) set_lock_ptr(__ptr);\n   }\n \n   // unsafe - retained for compatibility with ABI 3.4.11\n@@ -129,26 +138,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     static unique_lock<mutex> once_functor_lock(__get_once_mutex(), defer_lock);\n     return once_functor_lock;\n   }\n-#endif\n \n-  extern \"C\"\n+  // This is called via pthread_once while __get_once_mutex() is locked.\n+  extern \"C\" void\n+  __once_proxy()\n   {\n-    void __once_proxy()\n+    // Get the callable out of the global functor.\n+    function<void()> callable = std::move(__once_functor);\n+\n+    // Then unlock the global mutex\n+    if (unique_lock<mutex>* lock = set_lock_ptr(nullptr))\n     {\n-#ifndef _GLIBCXX_HAVE_TLS\n-      function<void()> __once_call = std::move(__once_functor);\n-      if (unique_lock<mutex>* __lock = __get_once_functor_lock_ptr())\n-      {\n-        // caller is using new ABI and provided lock ptr\n-        __get_once_functor_lock_ptr() = 0;\n-        __lock->unlock();\n-      }\n-      else\n-        __get_once_functor_lock().unlock();  // global lock\n-#endif\n-      __once_call();\n+      // Caller is using the new ABI and provided a pointer to its lock.\n+      lock->unlock();\n     }\n+    else\n+      __get_once_functor_lock().unlock();  // global lock\n+\n+    // Finally, invoke the callable.\n+    callable();\n   }\n+#endif // ! TLS\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std"}]}