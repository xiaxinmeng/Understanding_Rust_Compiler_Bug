{"sha": "4bf1d92ee071cd9e207fcf70c3fd78bf2f7dc2a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJmMWQ5MmVlMDcxY2Q5ZTIwN2ZjZjcwYzNmZDc4YmYyZjdkYzJhNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-10-17T15:13:10Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-10-17T15:13:10Z"}, "message": "re PR rtl-optimization/7630 (gcc 3.2 breaks on Mozilla 1.0's JS sources with -march=pentium4)\n\n\n\tPR opt/7630\n\t* reload.c (reload_inner_reg_of_subreg): New argument output;\n\t(push_reload): Update call.\n\nFrom-SVN: r58248", "tree": {"sha": "8f8c5246b0eb528c5257757713c9e674e267a314", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f8c5246b0eb528c5257757713c9e674e267a314"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bf1d92ee071cd9e207fcf70c3fd78bf2f7dc2a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bf1d92ee071cd9e207fcf70c3fd78bf2f7dc2a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bf1d92ee071cd9e207fcf70c3fd78bf2f7dc2a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bf1d92ee071cd9e207fcf70c3fd78bf2f7dc2a5/comments", "author": null, "committer": null, "parents": [{"sha": "ccc4bdea164b72e5bdd281f0ec1b9aff83edf75f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccc4bdea164b72e5bdd281f0ec1b9aff83edf75f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccc4bdea164b72e5bdd281f0ec1b9aff83edf75f"}], "stats": {"total": 13, "additions": 8, "deletions": 5}, "files": [{"sha": "9b779beeabcd22ffe95cbac1192ec793c1e67fdb", "filename": "gcc/reload.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf1d92ee071cd9e207fcf70c3fd78bf2f7dc2a5/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf1d92ee071cd9e207fcf70c3fd78bf2f7dc2a5/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=4bf1d92ee071cd9e207fcf70c3fd78bf2f7dc2a5", "patch": "@@ -242,7 +242,7 @@ static int push_secondary_reload PARAMS ((int, rtx, int, int, enum reg_class,\n #endif\n static enum reg_class find_valid_class PARAMS ((enum machine_mode, int,\n \t\t\t\t\t\tunsigned int));\n-static int reload_inner_reg_of_subreg PARAMS ((rtx, enum machine_mode));\n+static int reload_inner_reg_of_subreg PARAMS ((rtx, enum machine_mode, int));\n static void push_replacement\tPARAMS ((rtx *, int, enum machine_mode));\n static void dup_replacements\tPARAMS ((rtx *, rtx *));\n static void combine_reloads\tPARAMS ((void));\n@@ -795,9 +795,10 @@ find_reusable_reload (p_in, out, class, type, opnum, dont_share)\n    SUBREG_REG expression.  */\n \n static int\n-reload_inner_reg_of_subreg (x, mode)\n+reload_inner_reg_of_subreg (x, mode, output)\n      rtx x;\n      enum machine_mode mode;\n+     int output;\n {\n   rtx inner;\n \n@@ -825,6 +826,7 @@ reload_inner_reg_of_subreg (x, mode)\n      word and the number of regs for INNER is not the same as the\n      number of words in INNER, then INNER will need reloading.  */\n   return (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n+\t  && output\n \t  && GET_MODE_SIZE (GET_MODE (inner)) > UNITS_PER_WORD\n \t  && ((GET_MODE_SIZE (GET_MODE (inner)) / UNITS_PER_WORD)\n \t      != (int) HARD_REGNO_NREGS (REGNO (inner), GET_MODE (inner))));\n@@ -1048,7 +1050,7 @@ push_reload (in, out, inloc, outloc, class,\n   /* Similar issue for (SUBREG constant ...) if it was not handled by the\n      code above.  This can happen if SUBREG_BYTE != 0.  */\n \n-  if (in != 0 && reload_inner_reg_of_subreg (in, inmode))\n+  if (in != 0 && reload_inner_reg_of_subreg (in, inmode, 0))\n     {\n       enum reg_class in_class = class;\n \n@@ -1145,7 +1147,7 @@ push_reload (in, out, inloc, outloc, class,\n      However, we must reload the inner reg *as well as* the subreg in\n      that case.  In this case, the inner reg is an in-out reload.  */\n \n-  if (out != 0 && reload_inner_reg_of_subreg (out, outmode))\n+  if (out != 0 && reload_inner_reg_of_subreg (out, outmode, 1))\n     {\n       /* This relies on the fact that emit_reload_insns outputs the\n \t instructions for output reloads of type RELOAD_OTHER in reverse\n@@ -1733,7 +1735,8 @@ combine_reloads ()\n \t\t&& ! (GET_CODE (rld[i].in) == REG\n \t\t      && reg_overlap_mentioned_for_reload_p (rld[i].in,\n \t\t\t\t\t\t\t     rld[output_reload].out))))\n-\t&& ! reload_inner_reg_of_subreg (rld[i].in, rld[i].inmode)\n+\t&& ! reload_inner_reg_of_subreg (rld[i].in, rld[i].inmode,\n+\t\t\t\t\t rld[i].when_needed != RELOAD_FOR_INPUT)\n \t&& (reg_class_size[(int) rld[i].class]\n \t    || SMALL_REGISTER_CLASSES)\n \t/* We will allow making things slightly worse by combining an"}]}