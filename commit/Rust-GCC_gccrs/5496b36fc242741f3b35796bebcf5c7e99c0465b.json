{"sha": "5496b36fc242741f3b35796bebcf5c7e99c0465b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ5NmIzNmZjMjQyNzQxZjNiMzU3OTZiZWJjZjVjN2U5OWMwNDY1Yg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2004-10-01T07:43:03Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2004-10-01T07:43:03Z"}, "message": "revert: tree.h (enum tree_index): Add TI_VA_LIST_GPR_COUNTER_FIELD and TI_VA_LIST_FPR_COUNTER_FIELD.\n\n2004-10-01  Jakub Jelinek  <jakub@redhat.com>\n\n\tRevert\n\t2004-09-29  Jakub Jelinek  <jakub@redhat.com>\n\n\t* tree.h (enum tree_index): Add TI_VA_LIST_GPR_COUNTER_FIELD\n\tand TI_VA_LIST_FPR_COUNTER_FIELD.\n\t(va_list_gpr_counter_field, va_list_fpr_counter_field): Define.\n\t* tree-pass.h (pass_stdarg): Add.\n\t* tree-optimize.c (init_tree_optimization_passes): Add pass_stdarg.\n\t* tree-stdarg.c: New file.\n\t* Makefile.in (OBJS-common): Add tree-stdarg.o.\n\t(tree-stdarg.o): Add dependencies.\n\t* function.h (struct function): Add va_list_gpr_size and\n\tva_list_fpr_size fields.\n\t* function.c (allocate_struct_function): Initialize them.\n\n\t* config/i386/i386.c (ix86_build_builtin_va_list): Initialize\n\tva_list_{g,f}pr_counter_field.\n\t(ix86_setup_incoming_varargs): Don't do anything if reg_save\n\tarea will not be used.  Only save registers that tree-stdarg.c\n\tdetected they need saving.\n\t(ix86_va_start): Don't set up fields that won't be used.\n\n\t* config/rs6000/rs6000.c (rs6000_build_builtin_va_list): Initialize\n\tva_list_{g,f}pr_counter_field.\n\t(setup_incoming_varargs): Don't do anything if reg_save\n\tarea will not be used.  Only save registers that tree-stdarg.c\n\tdetected they need saving.\n\t(rs6000_va_start): Don't set up fields that won't be used.\n\n\t* gcc.dg/tree-ssa/stdarg-1.c: Removed.\n\t* gcc.dg/tree-ssa/stdarg-2.c: Removed.\n\t* gcc.dg/tree-ssa/stdarg-3.c: Removed.\n\t* gcc.dg/tree-ssa/stdarg-4.c: Removed.\n\t* gcc.dg/tree-ssa/stdarg-5.c: Removed.\n\nFrom-SVN: r88383", "tree": {"sha": "a582f845763856e5c9c0cdb2a1ee2ad60b0089d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a582f845763856e5c9c0cdb2a1ee2ad60b0089d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5496b36fc242741f3b35796bebcf5c7e99c0465b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5496b36fc242741f3b35796bebcf5c7e99c0465b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5496b36fc242741f3b35796bebcf5c7e99c0465b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5496b36fc242741f3b35796bebcf5c7e99c0465b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a1c496cb437080bd861ea5fed4220514e64c915e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c496cb437080bd861ea5fed4220514e64c915e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1c496cb437080bd861ea5fed4220514e64c915e"}], "stats": {"total": 1043, "additions": 72, "deletions": 971}, "files": [{"sha": "6e58b08d34d315881d4a8961458787b89b940f34", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5496b36fc242741f3b35796bebcf5c7e99c0465b", "patch": "@@ -1,3 +1,34 @@\n+2004-10-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tRevert\n+\t2004-09-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree.h (enum tree_index): Add TI_VA_LIST_GPR_COUNTER_FIELD\n+\tand TI_VA_LIST_FPR_COUNTER_FIELD.\n+\t(va_list_gpr_counter_field, va_list_fpr_counter_field): Define.\n+\t* tree-pass.h (pass_stdarg): Add.\n+\t* tree-optimize.c (init_tree_optimization_passes): Add pass_stdarg.\n+\t* tree-stdarg.c: New file.\n+\t* Makefile.in (OBJS-common): Add tree-stdarg.o.\n+\t(tree-stdarg.o): Add dependencies.\n+\t* function.h (struct function): Add va_list_gpr_size and\n+\tva_list_fpr_size fields.\n+\t* function.c (allocate_struct_function): Initialize them.\n+\n+\t* config/i386/i386.c (ix86_build_builtin_va_list): Initialize\n+\tva_list_{g,f}pr_counter_field.\n+\t(ix86_setup_incoming_varargs): Don't do anything if reg_save\n+\tarea will not be used.  Only save registers that tree-stdarg.c\n+\tdetected they need saving.\n+\t(ix86_va_start): Don't set up fields that won't be used.\n+\n+\t* config/rs6000/rs6000.c (rs6000_build_builtin_va_list): Initialize\n+\tva_list_{g,f}pr_counter_field.\n+\t(setup_incoming_varargs): Don't do anything if reg_save\n+\tarea will not be used.  Only save registers that tree-stdarg.c\n+\tdetected they need saving.\n+\t(rs6000_va_start): Don't set up fields that won't be used.\n+\n 2004-09-30  Eric Christopher  <echristo@redhat.com>\n \n \t* dwarf2.h (dwarf_calling_convention): Add enum for renesas"}, {"sha": "ec4af54889a40fc40d53ca97a947073680f64499", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5496b36fc242741f3b35796bebcf5c7e99c0465b", "patch": "@@ -925,7 +925,7 @@ OBJS-common = \\\n  varasm.o varray.o vec.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n  et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n  rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o          \\\n- lambda-trans.o\tlambda-code.o tree-loop-linear.o tree-stdarg.o\n+ lambda-trans.o\tlambda-code.o tree-loop-linear.o\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) tree-inline.o\t\t   \\\n@@ -1772,8 +1772,6 @@ tree-loop-linear.o: tree-loop-linear.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_\n    errors.h $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) diagnostic.h \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) cfgloop.h tree-pass.h \\\n    $(TREE_DATA_REF_H) $(SCEV_H)\n-tree-stdarg.o: tree-stdarg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(TREE_H) function.h diagnostic.h $(TREE_FLOW_H) tree-pass.h\n tree-gimple.o : tree-gimple.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(EXPR_H) \\\n \t$(RTL_H) $(TREE_GIMPLE_H) $(TM_H) coretypes.h bitmap.h $(GGC_H)\n tree-mudflap.o : $(CONFIG_H) errors.h $(SYSTEM_H) $(TREE_H) tree-inline.h \\"}, {"sha": "540d390d50cba2dae06387060005a91456e8ca70", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 34, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5496b36fc242741f3b35796bebcf5c7e99c0465b", "patch": "@@ -3097,9 +3097,6 @@ ix86_build_builtin_va_list (void)\n   f_sav = build_decl (FIELD_DECL, get_identifier (\"reg_save_area\"),\n \t\t      ptr_type_node);\n \n-  va_list_gpr_counter_field = f_gpr;\n-  va_list_fpr_counter_field = f_fpr;\n-\n   DECL_FIELD_CONTEXT (f_gpr) = record;\n   DECL_FIELD_CONTEXT (f_fpr) = record;\n   DECL_FIELD_CONTEXT (f_ovf) = record;\n@@ -3139,9 +3136,6 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (!TARGET_64BIT)\n     return;\n \n-  if (! cfun->va_list_gpr_size && ! cfun->va_list_fpr_size)\n-    return;\n-\n   /* Indicate to allocate space on the stack for varargs save area.  */\n   ix86_save_varrargs_registers = 1;\n \n@@ -3163,10 +3157,7 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   set = get_varargs_alias_set ();\n \n-  for (i = next_cum.regno;\n-       i < ix86_regparm\n-       && i < next_cum.regno + cfun->va_list_gpr_size / UNITS_PER_WORD;\n-       i++)\n+  for (i = next_cum.regno; i < ix86_regparm; i++)\n     {\n       mem = gen_rtx_MEM (Pmode,\n \t\t\t plus_constant (save_area, i * UNITS_PER_WORD));\n@@ -3175,7 +3166,7 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t\t\tx86_64_int_parameter_registers[i]));\n     }\n \n-  if (next_cum.sse_nregs && cfun->va_list_fpr_size)\n+  if (next_cum.sse_nregs)\n     {\n       /* Now emit code to save SSE registers.  The AX parameter contains number\n \t of SSE parameter registers used to call this function.  We use\n@@ -3258,21 +3249,15 @@ ix86_va_start (tree valist, rtx nextarg)\n     fprintf (stderr, \"va_start: words = %d, n_gpr = %d, n_fpr = %d\\n\",\n \t     (int) words, (int) n_gpr, (int) n_fpr);\n \n-  if (cfun->va_list_gpr_size)\n-    {\n-      t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n-\t\t build_int_cst (NULL_TREE, n_gpr * 8));\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-    }\n+  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n+\t     build_int_cst (NULL_TREE, n_gpr * 8));\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  if (cfun->va_list_fpr_size)\n-    {\n-      t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n-\t\t build_int_cst (NULL_TREE, n_fpr * 16 + 8*REGPARM_MAX));\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-    }\n+  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n+\t     build_int_cst (NULL_TREE, n_fpr * 16 + 8*REGPARM_MAX));\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   /* Find the overflow area.  */\n   t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n@@ -3283,15 +3268,12 @@ ix86_va_start (tree valist, rtx nextarg)\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  if (cfun->va_list_gpr_size || cfun->va_list_fpr_size)\n-    {\n-      /* Find the register save area.\n-\t Prologue of the function save it right above stack frame.  */\n-      t = make_tree (TREE_TYPE (sav), frame_pointer_rtx);\n-      t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-    }\n+  /* Find the register save area.\n+     Prologue of the function save it right above stack frame.  */\n+  t = make_tree (TREE_TYPE (sav), frame_pointer_rtx);\n+  t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n \n /* Implement va_arg.  */"}, {"sha": "f12f7b35941d058771558afcb40ade2882aa295f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 16, "deletions": 40, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5496b36fc242741f3b35796bebcf5c7e99c0465b", "patch": "@@ -5384,32 +5384,25 @@ setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     }\n \n   set = get_varargs_alias_set ();\n-  if (! no_rtl && first_reg_offset < GP_ARG_NUM_REG\n-      && cfun->va_list_gpr_size)\n+  if (! no_rtl && first_reg_offset < GP_ARG_NUM_REG)\n     {\n-      int nregs = GP_ARG_NUM_REG - first_reg_offset;\n-\n-      if (nregs > cfun->va_list_gpr_size)\n-        nregs = cfun->va_list_gpr_size;\n-\n       mem = gen_rtx_MEM (BLKmode,\n \t\t         plus_constant (save_area,\n \t\t\t\t\tfirst_reg_offset * reg_size)),\n       set_mem_alias_set (mem, set);\n       set_mem_align (mem, BITS_PER_WORD);\n \n       rs6000_move_block_from_reg (GP_ARG_MIN_REG + first_reg_offset, mem,\n-\t\t\t          nregs);\n+\t\t\t          GP_ARG_NUM_REG - first_reg_offset);\n     }\n \n   /* Save FP registers if needed.  */\n   if (DEFAULT_ABI == ABI_V4\n       && TARGET_HARD_FLOAT && TARGET_FPRS\n       && ! no_rtl\n-      && next_cum.fregno <= FP_ARG_V4_MAX_REG\n-      && cfun->va_list_fpr_size)\n+      && next_cum.fregno <= FP_ARG_V4_MAX_REG)\n     {\n-      int fregno = next_cum.fregno, nregs;\n+      int fregno = next_cum.fregno;\n       rtx cr1 = gen_rtx_REG (CCmode, CR1_REGNO);\n       rtx lab = gen_label_rtx ();\n       int off = (GP_ARG_NUM_REG * reg_size) + ((fregno - FP_ARG_MIN_REG) * 8);\n@@ -5422,14 +5415,13 @@ setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t\t\t    gen_rtx_LABEL_REF (VOIDmode, lab),\n \t\t\t\t\t    pc_rtx)));\n \n-      for (nregs = 0;\n-           fregno <= FP_ARG_V4_MAX_REG && nregs < cfun->va_list_fpr_size;\n-           fregno++, off += 8, nregs++)\n+      while (fregno <= FP_ARG_V4_MAX_REG)\n \t{\n-\t  mem = gen_rtx_MEM (DFmode,\n-\t                     plus_constant (save_area, off));\n+\t  mem = gen_rtx_MEM (DFmode, plus_constant (save_area, off));\n           set_mem_alias_set (mem, set);\n \t  emit_move_insn (mem, gen_rtx_REG (DFmode, fregno));\n+\t  fregno++;\n+\t  off += 8;\n \t}\n \n       emit_label (lab);\n@@ -5464,9 +5456,6 @@ rs6000_build_builtin_va_list (void)\n   f_sav = build_decl (FIELD_DECL, get_identifier (\"reg_save_area\"),\n \t\t      ptr_type_node);\n \n-  va_list_gpr_counter_field = f_gpr;\n-  va_list_fpr_counter_field = f_fpr;\n-\n   DECL_FIELD_CONTEXT (f_gpr) = record;\n   DECL_FIELD_CONTEXT (f_fpr) = record;\n   DECL_FIELD_CONTEXT (f_res) = record;\n@@ -5525,28 +5514,15 @@ rs6000_va_start (tree valist, rtx nextarg)\n \t     HOST_WIDE_INT_PRINT_DEC\", n_fpr = \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n \t     words, n_gpr, n_fpr);\n \n-  if (cfun->va_list_gpr_size)\n-    {\n-      t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n-                 build_int_cst (NULL_TREE, n_gpr));\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-    }\n-\n-  if (cfun->va_list_fpr_size)\n-    {\n-      t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n-\t         build_int_cst (NULL_TREE, n_fpr));\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-    }\n+  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n+\t     build_int_cst (NULL_TREE, n_gpr));\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  /* If there were no va_arg invocations, don't set up anything.  */\n-  if (!cfun->va_list_gpr_size\n-      && !cfun->va_list_fpr_size\n-      && n_gpr < GP_ARG_NUM_REG\n-      && n_fpr < FP_ARG_V4_MAX_REG)\n-    return;\n+  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n+\t     build_int_cst (NULL_TREE, n_fpr));\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   /* Find the overflow area.  */\n   t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);"}, {"sha": "0545b05a5cd8355eabafdd2e3dbd9bb10982344f", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=5496b36fc242741f3b35796bebcf5c7e99c0465b", "patch": "@@ -3798,10 +3798,6 @@ allocate_struct_function (tree fndecl)\n        && TYPE_ARG_TYPES (fntype) != 0\n        && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n \t   != void_type_node));\n-\n-  /* Assume all registers in stdarg functions need to be saved.  */\n-  cfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n-  cfun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n }\n \n /* Reset cfun, and other non-struct-function variables to defaults as"}, {"sha": "e38b5294dbb3216ef91f756830e019578f1575ad", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=5496b36fc242741f3b35796bebcf5c7e99c0465b", "patch": "@@ -428,22 +428,8 @@ struct function GTY(())\n \n   /* Nonzero if code to initialize arg_pointer_save_area has been emitted.  */\n   unsigned int arg_pointer_save_area_init : 1;\n-\n-  /* Number of units of general registers that need saving in stdarg\n-     function.  What unit is depends on the backend, either it is number\n-     of bytes, or it can be number of registers.  */\n-  unsigned int va_list_gpr_size : 8;\n-\n-  /* Number of units of floating point registers that need saving in stdarg\n-     function.  */\n-  unsigned int va_list_fpr_size : 8;\n };\n \n-/* If va_list_[gf]pr_size is set to this, it means we don't know how\n-   many units need to be saved.  */\n-#define VA_LIST_MAX_GPR_SIZE\t255\n-#define VA_LIST_MAX_FPR_SIZE\t255\n-\n /* The function currently being compiled.  */\n extern GTY(()) struct function *cfun;\n "}, {"sha": "6b3b270aa40dba9c6bfbe81b5df3b4f733e8f795", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5496b36fc242741f3b35796bebcf5c7e99c0465b", "patch": "@@ -1,3 +1,11 @@\n+2004-10-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/stdarg-1.c: Removed.\n+\t* gcc.dg/tree-ssa/stdarg-2.c: Removed.\n+\t* gcc.dg/tree-ssa/stdarg-3.c: Removed.\n+\t* gcc.dg/tree-ssa/stdarg-4.c: Removed.\n+\t* gcc.dg/tree-ssa/stdarg-5.c: Removed.\n+\n 2004-09-30  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* gcc.dg/lvalue-2.c: New test."}, {"sha": "39b61c9eb8df52d22029c5b202b27e35e667b396", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-1.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-1.c?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -1,12 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-stdarg\" } */\n-\n-#include <stdarg.h>\n-\n-/* This can be handled on all arches.  If there is no va_start, registers don't need\n-   to be saved.  */\n-void\n-f1 (int i, ...)\n-{\n-}\n-/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save 0 GPR units and 0 FPR units\" \"stdarg\" } } */"}, {"sha": "3a8c0394fe4f67f50ea108a431e932c62ac4cbdf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-2.c", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-2.c?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -1,131 +0,0 @@\n-/* This test is only for architectures that save general and floating point\n-   registers separately in stdarg functions.  */\n-/* { dg-do compile { target x86_64-*-* powerpc-*-* } } */\n-/* { dg-options \"-O2 -fdump-tree-stdarg\" } */\n-\n-#include <stdarg.h>\n-\n-extern void foo (int, va_list);\n-extern void bar (int);\n-long x;\n-double d;\n-va_list gap;\n-va_list *pap;\n-\n-void\n-f1 (int i, ...)\n-{\n-  va_list ap;\n-  va_start (ap, i);\n-  va_end (ap);\n-}\n-/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save 0 GPR units and 0 FPR units\" \"stdarg\" } } */\n-\n-void\n-f2 (int i, ...)\n-{\n-  va_list ap;\n-  va_start (ap, i);\n-  bar (d);\n-  x = va_arg (ap, long);\n-  bar (x);\n-  va_end (ap);\n-}\n-/* Assume the counters can be number of registers or bytes on 32-bit\n-   architecture or bytes on 64-bit architecture.  */\n-/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save \\[148\\] GPR units and 0 FPR units\" \"stdarg\" } } */\n-\n-void\n-f3 (int i, ...)\n-{\n-  va_list ap;\n-  va_start (ap, i);\n-  d = va_arg (ap, double);\n-  va_end (ap);\n-}\n-/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save 0 GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" } } */\n-\n-void\n-f4 (int i, ...)\n-{\n-  va_list ap;\n-  va_start (ap, i);\n-  x = va_arg (ap, double);\n-  foo (i, ap);\n-  va_end (ap);\n-}\n-/* { dg-final { scan-tree-dump \"f4: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-void\n-f5 (int i, ...)\n-{\n-  va_list ap;\n-  va_start (ap, i);\n-  va_copy (gap, ap);\n-  bar (i);\n-  va_end (ap);\n-  va_end (gap);\n-}\n-/* { dg-final { scan-tree-dump \"f5: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-void\n-f6 (int i, ...)\n-{\n-  va_list ap;\n-  va_start (ap, i);\n-  bar (d);\n-  va_arg (ap, long);\n-  va_arg (ap, long);\n-  x = va_arg (ap, long);\n-  bar (x);\n-  va_end (ap);\n-}\n-/* { dg-final { scan-tree-dump \"f6: va_list escapes 0, needs to save (3|12|24) GPR units and 0 FPR units\" \"stdarg\" } } */\n-\n-void\n-f7 (int i, ...)\n-{\n-  va_list ap;\n-  va_start (ap, i);\n-  pap = &ap;\n-  bar (6);\n-  va_end (ap);\n-}\n-/* { dg-final { scan-tree-dump \"f7: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-void\n-f8 (int i, ...)\n-{\n-  va_list ap;\n-  va_start (ap, i);\n-  pap = &ap;\n-  bar (d);\n-  x = va_arg (ap, long);\n-  bar (x);\n-  va_end (ap);\n-}\n-/* { dg-final { scan-tree-dump \"f8: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-void\n-f9 (int i, ...)\n-{\n-  va_list ap;\n-  va_start (ap, i);\n-  __asm __volatile (\"\" : \"=r\" (pap) : \"0\" (&ap));\n-  bar (6);\n-  va_end (ap);\n-}\n-/* { dg-final { scan-tree-dump \"f9: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-void\n-f10 (int i, ...)\n-{\n-  va_list ap;\n-  va_start (ap, i);\n-  __asm __volatile (\"\" : \"=r\" (pap) : \"0\" (&ap));\n-  bar (d);\n-  x = va_arg (ap, long);\n-  bar (x);\n-  va_end (ap);\n-}\n-/* { dg-final { scan-tree-dump \"f10: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */"}, {"sha": "cf68fe8dfc926b8372f5ff6794afc67097caa9ea", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-3.c", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-3.c?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -1,124 +0,0 @@\n-/* This test is only for architectures that save general and floating point\n-   registers separately in stdarg functions.  */\n-/* { dg-do compile { target x86_64-*-* powerpc-*-* } } */\n-/* { dg-options \"-O2 -fdump-tree-stdarg\" } */\n-\n-#include <stdarg.h>\n-\n-extern void foo (int, va_list);\n-extern void bar (int);\n-long x;\n-va_list gap;\n-\n-/* If va_list is not local variable, it escapes the function.  */\n-void\n-f1 (int i, ...)\n-{\n-  va_start (gap, i);\n-  x = va_arg (gap, long);\n-  va_end (gap);\n-}\n-/* { dg-final { scan-tree-dump \"f1: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-void\n-f2 (int i, ...)\n-{\n-  va_start (gap, i);\n-  bar (i);\n-  va_end (gap);\n-}\n-/* { dg-final { scan-tree-dump \"f2: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-/* tree-stdarg.c only handles va_list variables, not arrays of them or\n-   va_list fields embedded in structures.  */\n-void\n-f3 (int i, ...)\n-{\n-  va_list aps[10];\n-  va_start (aps[4], i);\n-  x = va_arg (aps[4], long);\n-  va_end (aps[4]);\n-}\n-/* { dg-final { scan-tree-dump \"f3: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-void\n-f4 (int i, ...)\n-{\n-  va_list aps[10];\n-  va_start (aps[4], i);\n-  bar (i);\n-  va_end (aps[4]);\n-}\n-/* { dg-final { scan-tree-dump \"f4: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-void\n-f5 (int i, ...)\n-{\n-  va_list aps[10];\n-  va_start (aps[4], i);\n-  foo (i, aps[4]);\n-  va_end (aps[4]);\n-}\n-/* { dg-final { scan-tree-dump \"f5: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-struct A { int i; va_list g; va_list h[2]; };\n-\n-void\n-f6 (int i, ...)\n-{\n-  struct A a;\n-  va_start (a.g, i);\n-  x = va_arg (a.g, long);\n-  va_end (a.g);\n-}\n-/* { dg-final { scan-tree-dump \"f6: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-void\n-f7 (int i, ...)\n-{\n-  struct A a;\n-  va_start (a.g, i);\n-  bar (i);\n-  va_end (a.g);\n-}\n-/* { dg-final { scan-tree-dump \"f7: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-void\n-f8 (int i, ...)\n-{\n-  struct A a;\n-  va_start (a.g, i);\n-  foo (i, a.g);\n-  va_end (a.g);\n-}\n-/* { dg-final { scan-tree-dump \"f8: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-void\n-f10 (int i, ...)\n-{\n-  struct A a;\n-  va_start (a.h[1], i);\n-  x = va_arg (a.h[1], long);\n-  va_end (a.h[1]);\n-}\n-/* { dg-final { scan-tree-dump \"f10: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-void\n-f11 (int i, ...)\n-{\n-  struct A a;\n-  va_start (a.h[1], i);\n-  bar (i);\n-  va_end (a.h[1]);\n-}\n-/* { dg-final { scan-tree-dump \"f11: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-void\n-f12 (int i, ...)\n-{\n-  struct A a;\n-  va_start (a.h[1], i);\n-  foo (i, a.h[1]);\n-  va_end (a.h[1]);\n-}\n-/* { dg-final { scan-tree-dump \"f12: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */"}, {"sha": "5b4b86896f38844f7ef6e40dab7d019f969ffb49", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-4.c", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-4.c?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -1,67 +0,0 @@\n-/* This test is only for architectures that save general and floating point\n-   registers separately in stdarg functions.  */\n-/* { dg-do compile { target x86_64-*-* powerpc-*-* } } */\n-/* { dg-options \"-O2 -fdump-tree-stdarg\" } */\n-\n-#include <stdarg.h>\n-\n-extern void foo (int, va_list);\n-extern void bar (int);\n-long x;\n-double d;\n-\n-/* Here va_arg can be executed more than once for one va_start.  All GPR\n-   registers needs to be saved.  */\n-void\n-f1 (int i, ...)\n-{\n-  va_list ap;\n-  va_start (ap, i);\n-  while (i-- > 0)\n-    x = va_arg (ap, long);\n-  va_end (ap);\n-}\n-/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save all GPR units and 0 FPR units\" \"stdarg\" } } */\n-\n-void\n-f2 (int i, ...)\n-{\n-  va_list ap;\n-  va_start (ap, i);\n-  while (i-- > 0)\n-    d = va_arg (ap, double);\n-  va_end (ap);\n-}\n-/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save 0 GPR units and all FPR units\" \"stdarg\" } } */\n-\n-/* Here va_arg can be executed at most as many times as va_start.\n-   Only one GPR needs to be saved.  */\n-void\n-f3 (int i, ...)\n-{\n-  va_list ap;\n-  int j = i;\n-  while (j-- > 0)\n-    {\n-      va_start (ap, i);\n-      x = va_arg (ap, long);\n-      va_end (ap);\n-      bar (x);\n-    }\n-}\n-/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save \\[148\\] GPR units and 0 FPR units\" \"stdarg\" } } */\n-\n-void\n-f4 (int i, ...)\n-{\n-  va_list ap;\n-  int j = i;\n-  while (j-- > 0)\n-    {\n-      va_start (ap, i);\n-      d = va_arg (ap, double);\n-      va_end (ap);\n-      bar (d + 2.5);\n-    }\n-}\n-/* { dg-final { scan-tree-dump \"f4: va_list escapes 0, needs to save 0 GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" } } */"}, {"sha": "33d00e6dbbb00684561c8b5d0353e431304e831d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-5.c", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-5.c?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -1,66 +0,0 @@\n-/* This test is specific to x86-64 function passing.  */\n-/* { dg-do compile { target x86_64-*-* } } */\n-/* { dg-options \"-O2 -fdump-tree-stdarg\" } */\n-\n-#include <stdarg.h>\n-\n-extern void foo (int, va_list);\n-extern void bar (int);\n-struct S1 { int i; double d; int j; double e; } s1;\n-struct S2 { double d; long i; } s2;\n-int y;\n-\n-/* Here va_arg can be executed more than once for one va_start.  */\n-void\n-f1 (int i, ...)\n-{\n-  va_list ap;\n-  va_start (ap, i);\n-  while (i-- > 0)\n-    s1 = va_arg (ap, struct S1);\n-  va_end (ap);\n-}\n-/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save 0 GPR units and 0 FPR units\" \"stdarg\" } } */\n-\n-void\n-f2 (int i, ...)\n-{\n-  va_list ap;\n-  va_start (ap, i);\n-  while (i-- > 0)\n-    s2 = va_arg (ap, struct S2);\n-  va_end (ap);\n-}\n-/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n-\n-/* Here va_arg can be executed at most as many times as va_start.  */\n-void\n-f3 (int i, ...)\n-{\n-  va_list ap;\n-  int j = i;\n-  while (j-- > 0)\n-    {\n-      va_start (ap, i);\n-      s1 = va_arg (ap, struct S1);\n-      va_end (ap);\n-      bar (s1.i);\n-    }\n-}\n-/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save 0 GPR units and 0 FPR units\" \"stdarg\" } } */\n-\n-void\n-f4 (int i, ...)\n-{\n-  va_list ap;\n-  int j = i;\n-  while (j-- > 0)\n-    {\n-      va_start (ap, i);\n-      s2 = va_arg (ap, struct S2);\n-      y = va_arg (ap, int);\n-      va_end (ap);\n-      bar (s2.i);\n-    }\n-}\n-/* { dg-final { scan-tree-dump \"f4: va_list escapes 0, needs to save 16 GPR units and 16 FPR units\" \"stdarg\" } } */"}, {"sha": "aa3df9e787c9a71be4bffed781508043c4b16007", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=5496b36fc242741f3b35796bebcf5c7e99c0465b", "patch": "@@ -371,7 +371,6 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_ccp);\n   NEXT_PASS (pass_redundant_phi);\n   NEXT_PASS (pass_fold_builtins);\n-  NEXT_PASS (pass_stdarg);\n   NEXT_PASS (pass_split_crit_edges);\n   NEXT_PASS (pass_pre);\n   NEXT_PASS (pass_loop);"}, {"sha": "6250ae6140bfa76ae29a628db366a25b2675b48e", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=5496b36fc242741f3b35796bebcf5c7e99c0465b", "patch": "@@ -147,7 +147,6 @@ extern struct tree_opt_pass pass_profile;\n extern struct tree_opt_pass pass_pre_expand;\n extern struct tree_opt_pass pass_lower_vector_ssa;\n extern struct tree_opt_pass pass_fold_builtins;\n-extern struct tree_opt_pass pass_stdarg;\n extern struct tree_opt_pass pass_early_warn_uninitialized;\n extern struct tree_opt_pass pass_late_warn_uninitialized;\n extern struct tree_opt_pass pass_warn_function_return;"}, {"sha": "926563793ca780b69fbf2c9a86eb7d38ec26e777", "filename": "gcc/tree-stdarg.c", "status": "removed", "additions": 0, "deletions": 470, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -1,470 +0,0 @@\n-/* Pass computing data for optimizing stdarg functions.\n-   Copyright (C) 2004 Free Software Foundation, Inc.\n-   Contributed by Jakub Jelinek <jakub@redhat.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"function.h\"\n-#include \"langhooks.h\"\n-#include \"diagnostic.h\"\n-#include \"tree-flow.h\"\n-#include \"tree-pass.h\"\n-\n-/* A simple pass that attempts to optimize stdarg functions on architectures\n-   that need to save register arguments to stack on entry to stdarg functions.\n-   If the function doesn't use any va_start macros, no registers need to\n-   be saved.  If va_start macros are used, the va_list variables don't escape\n-   the function, it is only necessary to save registers that will be used\n-   in va_arg macros.  E.g. if va_arg is only used with integral types\n-   in the function, floating point registers don't need to be saved, etc.  */\n-\n-struct stdarg_info\n-{\n-  bitmap va_list_vars;\n-  basic_block va_start_bb, bb;\n-  int compute_sizes, va_start_count;\n-};\n-\n-/* Return true if basic block VA_ARG_BB is dominated by VA_START_BB and\n-   is executed at most as many times as VA_START_BB.  */\n-\n-static bool\n-reachable_at_most_once (basic_block va_arg_bb, basic_block va_start_bb)\n-{\n-  edge *stack, e;\n-  edge_iterator ei;\n-  int sp;\n-  sbitmap visited;\n-  bool ret;\n-\n-  if (va_arg_bb == va_start_bb)\n-    return true;\n-\n-  if (! dominated_by_p (CDI_DOMINATORS, va_arg_bb, va_start_bb))\n-    return false;\n-\n-  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n-  sp = 0;\n-\n-  visited = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (visited);\n-  ret = true;\n-\n-  FOR_EACH_EDGE (e, ei, va_arg_bb->preds)\n-    stack[sp++] = e;\n-\n-  while (sp)\n-    {\n-      basic_block src;\n-\n-      --sp;\n-      e = stack[sp];\n-      src = e->src;\n-\n-      if (e->flags & EDGE_COMPLEX)\n-\t{\n-\t  ret = false;\n-\t  break;\n-\t}\n-\n-      if (src == va_start_bb)\n-\tcontinue;\n-\n-      /* va_arg_bb can be executed more times than va_start_bb.  */\n-      if (src == va_arg_bb)\n-\t{\n-\t  ret = false;\n-\t  break;\n-\t}\n-\n-      gcc_assert (src != ENTRY_BLOCK_PTR);\n-\n-      if (! TEST_BIT (visited, src->index))\n-\t{\n-\t  SET_BIT (visited, src->index);\n-\t  FOR_EACH_EDGE (e, ei, src->preds)\n-\t    stack[sp++] = e;\n-\t}\n-    }\n-\n-  free (stack);\n-  sbitmap_free (visited);\n-  return ret;\n-}\n-\n-\n-/* For statement COUNTER = RHS, if RHS is COUNTER + constant,\n-   return constant, otherwise return 0.  */\n-\n-static unsigned HOST_WIDE_INT\n-va_list_counter_bump (tree counter, tree rhs)\n-{\n-  tree plus_stmt = SSA_NAME_DEF_STMT (rhs);\n-  tree rhs1, addend, load_stmt, counter1;\n-\n-  if (TREE_CODE (plus_stmt) != MODIFY_EXPR\n-      || TREE_OPERAND (plus_stmt, 0) != rhs)\n-    return 0;\n-\n-  rhs1 = TREE_OPERAND (plus_stmt, 1);\n-\n-  if (TREE_CODE (rhs1) != PLUS_EXPR\n-      || TREE_CODE (TREE_OPERAND (rhs1, 0)) != SSA_NAME\n-      || TREE_CODE (TREE_OPERAND (rhs1, 1)) != INTEGER_CST\n-      || !host_integerp (TREE_OPERAND (rhs1, 1), 1))\n-    return 0;\n-\n-  addend = TREE_OPERAND (rhs1, 0);\n-  load_stmt = SSA_NAME_DEF_STMT (addend);\n-\n-  if (TREE_CODE (load_stmt) != MODIFY_EXPR\n-      || TREE_OPERAND (load_stmt, 0) != addend)\n-    return 0;\n-\n-  counter1 = TREE_OPERAND (load_stmt, 1);\n-  if (TREE_CODE (counter) != TREE_CODE (counter1))\n-    return 0;\n-\n-  if (TREE_CODE (counter) == COMPONENT_REF)\n-    {\n-      if (get_base_address (counter) != get_base_address (counter1)\n-\t  || TREE_CODE (TREE_OPERAND (counter1, 1)) != FIELD_DECL\n-\t  || TREE_OPERAND (counter, 1) != TREE_OPERAND (counter1, 1))\n-\treturn 0;\n-    }\n-  else\n-    return 0;\n-\n-  return tree_low_cst (TREE_OPERAND (rhs1, 1), 1);\n-}\n-\n-\n-/* Called by walk_tree to look for references to va_list variables.  */\n-\n-static tree\n-find_va_list_reference (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t\tvoid *data)\n-{\n-  bitmap va_list_vars = (bitmap) data;\n-  tree var = *tp;\n-\n-  if (TREE_CODE (var) == SSA_NAME)\n-    var = SSA_NAME_VAR (var);\n-\n-  if (TREE_CODE (var) == VAR_DECL\n-      && bitmap_bit_p (va_list_vars, var_ann (var)->uid))\n-    return var;\n-\n-  return NULL_TREE;\n-}\n-\n-\n-/* Helper function of va_list_counter_struct_op.  Compute\n-  cfun->va_list_{g,f}pr_size.  AP is a va_list GPR/FPR counter,\n-  if WRITE_P is true, seen in AP = VAR, otherwise seen in VAR = AP\n-  statement.  GPR_P is true if AP is a GPR counter, false if it is\n-  a FPR counter.  */\n-\n-static void\n-va_list_counter_op (struct stdarg_info *si, tree ap, tree var, bool gpr_p,\n-\t\t    bool write_p)\n-{\n-  unsigned HOST_WIDE_INT increment;\n-\n-  if (si->compute_sizes < 0)\n-    {\n-      si->compute_sizes = 0;\n-      if (si->va_start_count == 1\n-\t  && reachable_at_most_once (si->bb, si->va_start_bb))\n-\tsi->compute_sizes = 1;\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"bb%d will %sbe executed at most once for each va_start \"\n-\t\t \"in bb%d\\n\", si->bb->index, si->compute_sizes ? \"\" : \"not \",\n-\t\t si->va_start_bb->index);\n-    }\n-\n-  if (write_p\n-      && si->compute_sizes\n-      && (increment = va_list_counter_bump (ap, var)) != 0)\n-    {\n-      if (gpr_p && cfun->va_list_gpr_size + increment < VA_LIST_MAX_GPR_SIZE)\n-\t{\n-\t  cfun->va_list_gpr_size += increment;\n-\t  return;\n-\t}\n-\n-      if (!gpr_p && cfun->va_list_fpr_size + increment < VA_LIST_MAX_FPR_SIZE)\n-\t{\n-\t  cfun->va_list_fpr_size += increment;\n-\t  return;\n-\t}\n-    }\n-\n-  if (write_p || !si->compute_sizes)\n-    {\n-      if (gpr_p)\n-\tcfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n-      else\n-\tcfun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n-    }\n-}\n-\n-\n-/* If AP is a va_list GPR/FPR counter, compute cfun->va_list_{g,f}pr_size.\n-   If WRITE_P is true, AP has been seen in AP = VAR assignment, if WRITE_P\n-   is false, AP has been seen in VAR = AP assignment.\n-   Return true if the AP = VAR (resp. VAR = AP) statement is a recognized\n-   va_arg operation that doesn't cause the va_list variable to escape\n-   current function.  */\n-\n-static bool\n-va_list_counter_struct_op (struct stdarg_info *si, tree ap, tree var,\n-\t\t\t   bool write_p)\n-{\n-  tree base;\n-\n-  if (TREE_CODE (ap) != COMPONENT_REF\n-      || TREE_CODE (TREE_OPERAND (ap, 1)) != FIELD_DECL)\n-    return false;\n-\n-  if (TREE_CODE (var) != SSA_NAME\n-      || bitmap_bit_p (si->va_list_vars, var_ann (SSA_NAME_VAR (var))->uid))\n-    return false;\n-\n-  base = get_base_address (ap);\n-  if (TREE_CODE (base) != VAR_DECL\n-      || !bitmap_bit_p (si->va_list_vars, var_ann (base)->uid))\n-    return false;\n-\n-  if (TREE_OPERAND (ap, 1) == va_list_gpr_counter_field)\n-    va_list_counter_op (si, ap, var, true, write_p);\n-  else if (TREE_OPERAND (ap, 1) == va_list_fpr_counter_field)\n-    va_list_counter_op (si, ap, var, false, write_p);\n-\n-  return true;\n-}\n-\n-\n-/* Return true if this optimization pass should be done.\n-   It makes only sense for stdarg functions.  */\n-\n-static bool\n-gate_optimize_stdarg (void)\n-{\n-  /* This optimization is only for stdarg functions.  */\n-  return current_function_stdarg != 0;\n-}  \n-\n-\n-/* Entry point to the stdarg optimization pass.  */\n-\n-static void\n-execute_optimize_stdarg (void)\n-{\n-  basic_block bb;\n-  bool va_list_escapes = false;\n-  struct stdarg_info si;\n-  const char *funcname = NULL;\n-\n-  cfun->va_list_gpr_size = 0;\n-  cfun->va_list_fpr_size = 0;\n-  memset (&si, 0, sizeof (si));\n-  si.va_list_vars = BITMAP_XMALLOC ();\n-\n-  if (dump_file)\n-    funcname = lang_hooks.decl_printable_name (current_function_decl, 2);\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      block_stmt_iterator i;\n-\n-      for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n-\t{\n-\t  tree stmt = bsi_stmt (i);\n-\t  tree call = get_call_expr_in (stmt), callee;\n-\t  tree ap;\n-\n-\t  if (!call)\n-\t    continue;\n-\n-\t  callee = get_callee_fndecl (call);\n-\t  if (!callee\n-\t      || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL\n-\t      || DECL_FUNCTION_CODE (callee) != BUILT_IN_VA_START)\n-\t    continue;\n-\n-\t  si.va_start_count++;\n-\t  ap = TREE_VALUE (TREE_OPERAND (call, 1));\n-\t  if (TREE_CODE (ap) != ADDR_EXPR\n-\t      || TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (ap, 0)))\n-\t\t != TYPE_MAIN_VARIANT (va_list_type_node)\n-\t      || TREE_CODE (TREE_OPERAND (ap, 0)) != VAR_DECL)\n-\t    {\n-\t      va_list_escapes = true;\n-\t      break;\n-\t    }\n-\n-\t  ap = TREE_OPERAND (ap, 0);\t    \n-\t  if (is_global_var (ap))\n-\t    {\n-\t      va_list_escapes = true;\n-\t      break;\n-\t    }\n-\n-\t  bitmap_set_bit (si.va_list_vars, var_ann (ap)->uid);\n-\n-\t  /* VA_START_BB will be only used if there is just one\n-\t     va_start in the function.  */\n-\t  si.va_start_bb = bb;\n-\t}\n-\n-      if (va_list_escapes)\n-\tbreak;\n-    }\n-\n-  /* If there were no va_start uses in the function, there is no need to\n-     save anything.  */\n-  if (si.va_start_count == 0)\n-    goto finish;\n-\n-  /* If some va_list arguments weren't local, we can't optimize.  */\n-  if (va_list_escapes)\n-    goto finish;\n-\n-  /* If the backend didn't tell us what the counter fields are, there is\n-     nothing more we can do.  */\n-  if (va_list_gpr_counter_field == NULL_TREE\n-      && va_list_fpr_counter_field == NULL_TREE)\n-    {\n-      va_list_escapes = true;\n-      goto finish;\n-    }\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      block_stmt_iterator i;\n-\n-      si.compute_sizes = -1;\n-      si.bb = bb;\n-      for (i = bsi_start (bb);\n-\t   !bsi_end_p (i) && !va_list_escapes;\n-\t   bsi_next (&i))\n-\t{\n-\t  tree stmt = bsi_stmt (i);\n-\t  tree call;\n-\n-\t  /* Don't look at __builtin_va_{start,end}, they are ok.  */\n-\t  call = get_call_expr_in (stmt);\n-\t  if (call)\n-\t    {\n-\t      tree callee = get_callee_fndecl (call);\n-\n-\t      if (callee\n-\t\t  && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL\n-\t\t  && (DECL_FUNCTION_CODE (callee) == BUILT_IN_VA_START\n-\t\t      || DECL_FUNCTION_CODE (callee) == BUILT_IN_VA_END))\n-\t\tcontinue;\n-\t    }\n-\n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n-\t    {\n-\t      tree lhs = TREE_OPERAND (stmt, 0);\n-\t      tree rhs = TREE_OPERAND (stmt, 1);\n-\n-\t      if (TREE_CODE (rhs) == WITH_SIZE_EXPR)\n-\t\trhs = TREE_OPERAND (rhs, 0);\n-\n-\t      /* Check for ap[0].field = temp.  */\n-\t      if (va_list_counter_struct_op (&si, lhs, rhs, true))\n-\t\tcontinue;\n-\n-\t      /* Check for temp = ap[0].field.  */\n-\t      else if (va_list_counter_struct_op (&si, rhs, lhs, false))\n-\t\tcontinue;\n-\t    }\n-\n-\t  /* All other uses of va_list are either va_copy (that is not handled\n-\t     in this optimization), taking address of va_list variable or\n-\t     passing va_list to other functions (in that case va_list might\n-\t     escape the function and therefore va_start needs to set it up\n-\t     fully), or some unexpected use of va_list.  None of these should\n-\t     happen in a gimplified VA_ARG_EXPR.  */\n-\t  if (walk_tree (&stmt, find_va_list_reference, si.va_list_vars, NULL))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fputs (\"va_list escapes in \", dump_file);\n-\t\t  print_generic_expr (dump_file, stmt, dump_flags);\n-\t\t  fputc ('\\n', dump_file);\n-\t\t}\n-\t      va_list_escapes = true;\n-\t    }\n-\t}\n-\n-      if (va_list_escapes)\n-\tbreak;\n-    }\n-\n-finish:\n-  if (va_list_escapes)\n-    {\n-      cfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n-      cfun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n-    }\n-  BITMAP_XFREE (si.va_list_vars);\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"%s: va_list escapes %d, needs to save \",\n-\t       funcname, (int) va_list_escapes);\n-      if (cfun->va_list_gpr_size >= VA_LIST_MAX_GPR_SIZE)\n-\tfputs (\"all\", dump_file);\n-      else\n-\tfprintf (dump_file, \"%d\", cfun->va_list_gpr_size);\n-      fputs (\" GPR units and \", dump_file);\n-      if (cfun->va_list_fpr_size >= VA_LIST_MAX_FPR_SIZE)\n-\tfputs (\"all\", dump_file);\n-      else\n-\tfprintf (dump_file, \"%d\", cfun->va_list_fpr_size);\n-      fputs (\" FPR units.\\n\", dump_file);\n-    }\n-}\n-\n-\n-struct tree_opt_pass pass_stdarg =\n-{\n-  \"stdarg\",\t\t\t\t/* name */\n-  gate_optimize_stdarg,\t\t\t/* gate */\n-  execute_optimize_stdarg,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  0,\t\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func,\t\t\t/* todo_flags_finish */\n-  0\t\t\t\t\t/* letter */\n-};"}, {"sha": "637fab7e1f77b98d1cc905a899ea1a579ac115a7", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5496b36fc242741f3b35796bebcf5c7e99c0465b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5496b36fc242741f3b35796bebcf5c7e99c0465b", "patch": "@@ -2574,8 +2574,6 @@ enum tree_index\n   TI_PID_TYPE,\n   TI_PTRDIFF_TYPE,\n   TI_VA_LIST_TYPE,\n-  TI_VA_LIST_GPR_COUNTER_FIELD,\n-  TI_VA_LIST_FPR_COUNTER_FIELD,\n   TI_BOOLEAN_TYPE,\n   TI_FILEPTR_TYPE,\n \n@@ -2642,8 +2640,6 @@ extern GTY(()) tree global_trees[TI_MAX];\n #define pid_type_node                   global_trees[TI_PID_TYPE]\n #define ptrdiff_type_node\t\tglobal_trees[TI_PTRDIFF_TYPE]\n #define va_list_type_node\t\tglobal_trees[TI_VA_LIST_TYPE]\n-#define va_list_gpr_counter_field\tglobal_trees[TI_VA_LIST_GPR_COUNTER_FIELD]\n-#define va_list_fpr_counter_field\tglobal_trees[TI_VA_LIST_FPR_COUNTER_FIELD]\n /* The C type `FILE *'.  */\n #define fileptr_type_node\t\tglobal_trees[TI_FILEPTR_TYPE]\n "}]}