{"sha": "20c89ab7c5091ee48535392cae2177aa1a1c43eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBjODlhYjdjNTA5MWVlNDg1MzUzOTJjYWUyMTc3YWExYTFjNDNlYg==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2018-01-12T20:50:52Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2018-01-12T20:50:52Z"}, "message": "rs6000: Remove -mstring\n\n-mstring is only enabled by default on 601, and with -Os on some\nconfigurations.  It is almost always slower (than not using it) and\ndoes not very often lead to smaller code.\n\nThis patch disables it.  If a user uses -mstring he gets a warning\n(but not with -mno-string).  I left the target attribute in place, it\njust doesn't do anything anymore.\n\nThe patch also deletes a whole bunch of code.  The 'N' and 'O' output\nmodifiers are now unused, but now is not the time to delete them.\n\n\n\t* config/rs6000/predicates.md (load_multiple_operation): Delete.\n\t(store_multiple_operation): Delete.\n\t* config/rs6000/rs6000-cpus.def (601): Remove MASK_STRING.\n\t* config/rs6000/rs6000-protos.h (rs6000_output_load_multiple): Delete.\n\t* config/rs6000/rs6000-string.c (expand_block_move): Delete everything\n\tguarded by TARGET_STRING.\n\t(rs6000_output_load_multiple): Delete.\n\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Delete\n\tOPTION_MASK_STRING / TARGET_STRING handling.\n\t(print_operand) <'N', 'O'>: Add comment that these are unused now.\n\t(const rs6000_opt_masks) <\"string\">: Change mask to 0.\n\t* config/rs6000/rs6000.h (TARGET_DEFAULT): Remove MASK_STRING.\n\t(MASK_STRING): Delete.\n\t* config/rs6000/rs6000.md (*mov<mode>_string): Delete TARGET_STRING\n\tparts.  Simplify.\n\t(load_multiple): Delete.\n\t(*ldmsi8): Delete.\n\t(*ldmsi7): Delete.\n\t(*ldmsi6): Delete.\n\t(*ldmsi5): Delete.\n\t(*ldmsi4): Delete.\n\t(*ldmsi3): Delete.\n\t(store_multiple): Delete.\n\t(*stmsi8): Delete.\n\t(*stmsi7): Delete.\n\t(*stmsi6): Delete.\n\t(*stmsi5): Delete.\n\t(*stmsi4): Delete.\n\t(*stmsi3): Delete.\n\t(movmemsi_8reg): Delete.\n\t(corresponding unnamed define_insn): Delete.\n\t(movmemsi_6reg): Delete.\n\t(corresponding unnamed define_insn): Delete.\n\t(movmemsi_4reg): Delete.\n\t(corresponding unnamed define_insn): Delete.\n\t(movmemsi_2reg): Delete.\n\t(corresponding unnamed define_insn): Delete.\n\t(movmemsi_1reg): Delete.\n\t(corresponding unnamed define_insn): Delete.\n\t* config/rs6000/rs6000.opt (mno-string): New.\n\t(mstring): Replace by deprecation warning stub.\n\t* doc/invoke.texi (RS/6000 and PowerPC Options): Delete -mstring.\n\nFrom-SVN: r256598", "tree": {"sha": "3863c9e6a3452a1e318e533cddde1800dbdc4b94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3863c9e6a3452a1e318e533cddde1800dbdc4b94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20c89ab7c5091ee48535392cae2177aa1a1c43eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20c89ab7c5091ee48535392cae2177aa1a1c43eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20c89ab7c5091ee48535392cae2177aa1a1c43eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20c89ab7c5091ee48535392cae2177aa1a1c43eb/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "02147434d74c4e8ca7be39a0df0b9cd1d9024e19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02147434d74c4e8ca7be39a0df0b9cd1d9024e19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02147434d74c4e8ca7be39a0df0b9cd1d9024e19"}], "stats": {"total": 847, "additions": 72, "deletions": 775}, "files": [{"sha": "9316f568c91802f4992618ccea5e1ad8095506a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20c89ab7c5091ee48535392cae2177aa1a1c43eb", "patch": "@@ -1,3 +1,48 @@\n+2018-01-12  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/predicates.md (load_multiple_operation): Delete.\n+\t(store_multiple_operation): Delete.\n+\t* config/rs6000/rs6000-cpus.def (601): Remove MASK_STRING.\n+\t* config/rs6000/rs6000-protos.h (rs6000_output_load_multiple): Delete.\n+\t* config/rs6000/rs6000-string.c (expand_block_move): Delete everything\n+\tguarded by TARGET_STRING.\n+\t(rs6000_output_load_multiple): Delete.\n+\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Delete\n+\tOPTION_MASK_STRING / TARGET_STRING handling.\n+\t(print_operand) <'N', 'O'>: Add comment that these are unused now.\n+\t(const rs6000_opt_masks) <\"string\">: Change mask to 0.\n+\t* config/rs6000/rs6000.h (TARGET_DEFAULT): Remove MASK_STRING.\n+\t(MASK_STRING): Delete.\n+\t* config/rs6000/rs6000.md (*mov<mode>_string): Delete TARGET_STRING\n+\tparts.  Simplify.\n+\t(load_multiple): Delete.\n+\t(*ldmsi8): Delete.\n+\t(*ldmsi7): Delete.\n+\t(*ldmsi6): Delete.\n+\t(*ldmsi5): Delete.\n+\t(*ldmsi4): Delete.\n+\t(*ldmsi3): Delete.\n+\t(store_multiple): Delete.\n+\t(*stmsi8): Delete.\n+\t(*stmsi7): Delete.\n+\t(*stmsi6): Delete.\n+\t(*stmsi5): Delete.\n+\t(*stmsi4): Delete.\n+\t(*stmsi3): Delete.\n+\t(movmemsi_8reg): Delete.\n+\t(corresponding unnamed define_insn): Delete.\n+\t(movmemsi_6reg): Delete.\n+\t(corresponding unnamed define_insn): Delete.\n+\t(movmemsi_4reg): Delete.\n+\t(corresponding unnamed define_insn): Delete.\n+\t(movmemsi_2reg): Delete.\n+\t(corresponding unnamed define_insn): Delete.\n+\t(movmemsi_1reg): Delete.\n+\t(corresponding unnamed define_insn): Delete.\n+\t* config/rs6000/rs6000.opt (mno-string): New.\n+\t(mstring): Replace by deprecation warning stub.\n+\t* doc/invoke.texi (RS/6000 and PowerPC Options): Delete -mstring.\n+\n 2018-01-12  Jakub Jelinek  <jakub@redhat.com>\n \n \t* regrename.c (regrename_do_replace): If replacing the same"}, {"sha": "b6d18f31072963829e3f05f9d3693e9c8d7c87f3", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=20c89ab7c5091ee48535392cae2177aa1a1c43eb", "patch": "@@ -1220,85 +1220,6 @@\n   (and (match_operand 0 \"branch_comparison_operator\")\n        (match_code \"eq,lt,gt,ltu,gtu,unordered\")))\n \n-;; Return 1 if OP is a load multiple operation, known to be a PARALLEL.\n-(define_predicate \"load_multiple_operation\"\n-  (match_code \"parallel\")\n-{\n-  int count = XVECLEN (op, 0);\n-  unsigned int dest_regno;\n-  rtx src_addr;\n-  int i;\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n-    return 0;\n-\n-  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n-  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n-\n-  for (i = 1; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i);\n-\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n-\t  || GET_MODE (SET_DEST (elt)) != SImode\n-\t  || REGNO (SET_DEST (elt)) != dest_regno + i\n-\t  || GET_CODE (SET_SRC (elt)) != MEM\n-\t  || GET_MODE (SET_SRC (elt)) != SImode\n-\t  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n-\t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n-\t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n-\t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != i * 4)\n-\treturn 0;\n-    }\n-\n-  return 1;\n-})\n-\n-;; Return 1 if OP is a store multiple operation, known to be a PARALLEL.\n-;; The second vector element is a CLOBBER.\n-(define_predicate \"store_multiple_operation\"\n-  (match_code \"parallel\")\n-{\n-  int count = XVECLEN (op, 0) - 1;\n-  unsigned int src_regno;\n-  rtx dest_addr;\n-  int i;\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n-    return 0;\n-\n-  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n-  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n-\n-  for (i = 1; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i + 1);\n-\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_SRC (elt)) != REG\n-\t  || GET_MODE (SET_SRC (elt)) != SImode\n-\t  || REGNO (SET_SRC (elt)) != src_regno + i\n-\t  || GET_CODE (SET_DEST (elt)) != MEM\n-\t  || GET_MODE (SET_DEST (elt)) != SImode\n-\t  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n-\t  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n-\t  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n-\t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != i * 4)\n-\treturn 0;\n-    }\n-\n-  return 1;\n-})\n-\n ;; Return 1 if OP is valid for a save_world call in prologue, known to be\n ;; a PARLLEL.\n (define_predicate \"save_world_operation\""}, {"sha": "50e4c75e7f474c218b5d5dc823ab14bada096ed6", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=20c89ab7c5091ee48535392cae2177aa1a1c43eb", "patch": "@@ -169,7 +169,7 @@ RS6000_CPU (\"476fp\", PROCESSOR_PPC476,\n \t    MASK_PPC_GFXOPT | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND\n \t    | MASK_CMPB | MASK_MULHW | MASK_DLMZB)\n RS6000_CPU (\"505\", PROCESSOR_MPCCORE, 0)\n-RS6000_CPU (\"601\", PROCESSOR_PPC601, MASK_MULTIPLE | MASK_STRING)\n+RS6000_CPU (\"601\", PROCESSOR_PPC601, MASK_MULTIPLE)\n RS6000_CPU (\"602\", PROCESSOR_PPC603, MASK_PPC_GFXOPT)\n RS6000_CPU (\"603\", PROCESSOR_PPC603, MASK_PPC_GFXOPT)\n RS6000_CPU (\"603e\", PROCESSOR_PPC603, MASK_PPC_GFXOPT)"}, {"sha": "1f96005c0101ee56217a15e256de9c1706b7f98f", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=20c89ab7c5091ee48535392cae2177aa1a1c43eb", "patch": "@@ -77,7 +77,6 @@ extern int expand_block_clear (rtx[]);\n extern int expand_block_move (rtx[]);\n extern bool expand_block_compare (rtx[]);\n extern bool expand_strn_compare (rtx[], int);\n-extern const char * rs6000_output_load_multiple (rtx[]);\n extern bool rs6000_is_valid_mask (rtx, int *, int *, machine_mode);\n extern bool rs6000_is_valid_and_mask (rtx, machine_mode);\n extern bool rs6000_is_valid_shift_mask (rtx, rtx, machine_mode);"}, {"sha": "e817f3db20012556cf20f096d31c9d52e7ec6b6d", "filename": "gcc/config/rs6000/rs6000-string.c", "status": "modified", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-string.c?ref=20c89ab7c5091ee48535392cae2177aa1a1c43eb", "patch": "@@ -2234,42 +2234,6 @@ expand_block_move (rtx operands[])\n \t  mode = V4SImode;\n \t  gen_func.mov = gen_movv4si;\n \t}\n-      else if (TARGET_STRING\n-\t  && bytes > 24\t\t/* move up to 32 bytes at a time */\n-\t  && ! fixed_regs[5]\n-\t  && ! fixed_regs[6]\n-\t  && ! fixed_regs[7]\n-\t  && ! fixed_regs[8]\n-\t  && ! fixed_regs[9]\n-\t  && ! fixed_regs[10]\n-\t  && ! fixed_regs[11]\n-\t  && ! fixed_regs[12])\n-\t{\n-\t  move_bytes = (bytes > 32) ? 32 : bytes;\n-\t  gen_func.movmemsi = gen_movmemsi_8reg;\n-\t}\n-      else if (TARGET_STRING\n-\t       && bytes > 16\t/* move up to 24 bytes at a time */\n-\t       && ! fixed_regs[5]\n-\t       && ! fixed_regs[6]\n-\t       && ! fixed_regs[7]\n-\t       && ! fixed_regs[8]\n-\t       && ! fixed_regs[9]\n-\t       && ! fixed_regs[10])\n-\t{\n-\t  move_bytes = (bytes > 24) ? 24 : bytes;\n-\t  gen_func.movmemsi = gen_movmemsi_6reg;\n-\t}\n-      else if (TARGET_STRING\n-\t       && bytes > 8\t/* move up to 16 bytes at a time */\n-\t       && ! fixed_regs[5]\n-\t       && ! fixed_regs[6]\n-\t       && ! fixed_regs[7]\n-\t       && ! fixed_regs[8])\n-\t{\n-\t  move_bytes = (bytes > 16) ? 16 : bytes;\n-\t  gen_func.movmemsi = gen_movmemsi_4reg;\n-\t}\n       else if (bytes >= 8 && TARGET_POWERPC64\n \t       && (align >= 64 || !STRICT_ALIGNMENT))\n \t{\n@@ -2302,11 +2266,6 @@ expand_block_move (rtx operands[])\n \t\t}\n \t    }\n \t}\n-      else if (TARGET_STRING && bytes > 4 && !TARGET_POWERPC64)\n-\t{\t\t\t/* move up to 8 bytes at a time */\n-\t  move_bytes = (bytes > 8) ? 8 : bytes;\n-\t  gen_func.movmemsi = gen_movmemsi_2reg;\n-\t}\n       else if (bytes >= 4 && (align >= 32 || !STRICT_ALIGNMENT))\n \t{\t\t\t/* move 4 bytes */\n \t  move_bytes = 4;\n@@ -2319,11 +2278,6 @@ expand_block_move (rtx operands[])\n \t  mode = HImode;\n \t  gen_func.mov = gen_movhi;\n \t}\n-      else if (TARGET_STRING && bytes > 1)\n-\t{\t\t\t/* move up to 4 bytes at a time */\n-\t  move_bytes = (bytes > 4) ? 4 : bytes;\n-\t  gen_func.movmemsi = gen_movmemsi_1reg;\n-\t}\n       else /* move 1 byte at a time */\n \t{\n \t  move_bytes = 1;\n@@ -2376,61 +2330,3 @@ expand_block_move (rtx operands[])\n \n   return 1;\n }\n-\n-\f\n-/* Return a string to perform a load_multiple operation.\n-   operands[0] is the vector.\n-   operands[1] is the source address.\n-   operands[2] is the first destination register.  */\n-\n-const char *\n-rs6000_output_load_multiple (rtx operands[3])\n-{\n-  /* We have to handle the case where the pseudo used to contain the address\n-     is assigned to one of the output registers.  */\n-  int i, j;\n-  int words = XVECLEN (operands[0], 0);\n-  rtx xop[10];\n-\n-  if (XVECLEN (operands[0], 0) == 1)\n-    return \"lwz %2,0(%1)\";\n-\n-  for (i = 0; i < words; i++)\n-    if (refers_to_regno_p (REGNO (operands[2]) + i, operands[1]))\n-      {\n-\tif (i == words-1)\n-\t  {\n-\t    xop[0] = GEN_INT (4 * (words-1));\n-\t    xop[1] = operands[1];\n-\t    xop[2] = operands[2];\n-\t    output_asm_insn (\"lswi %2,%1,%0\\n\\tlwz %1,%0(%1)\", xop);\n-\t    return \"\";\n-\t  }\n-\telse if (i == 0)\n-\t  {\n-\t    xop[0] = GEN_INT (4 * (words-1));\n-\t    xop[1] = operands[1];\n-\t    xop[2] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n-\t    output_asm_insn (\"addi %1,%1,4\\n\\tlswi %2,%1,%0\\n\\tlwz %1,-4(%1)\", xop);\n-\t    return \"\";\n-\t  }\n-\telse\n-\t  {\n-\t    for (j = 0; j < words; j++)\n-\t      if (j != i)\n-\t\t{\n-\t\t  xop[0] = GEN_INT (j * 4);\n-\t\t  xop[1] = operands[1];\n-\t\t  xop[2] = gen_rtx_REG (SImode, REGNO (operands[2]) + j);\n-\t\t  output_asm_insn (\"lwz %2,%0(%1)\", xop);\n-\t\t}\n-\t    xop[0] = GEN_INT (i * 4);\n-\t    xop[1] = operands[1];\n-\t    output_asm_insn (\"lwz %1,%0(%1)\", xop);\n-\t    return \"\";\n-\t  }\n-      }\n-\n-  return \"lswi %2,%1,%N0\";\n-}\n-"}, {"sha": "09bb2d0c7bb52d4d22621ffaac6637e0ff3b0fed", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=20c89ab7c5091ee48535392cae2177aa1a1c43eb", "patch": "@@ -4204,34 +4204,21 @@ rs6000_option_override_internal (bool global_init_p)\n     }\n \n   /* If we are optimizing big endian systems for space, use the load/store\n-     multiple and string instructions.  */\n+     multiple instructions.  */\n   if (BYTES_BIG_ENDIAN && optimize_size)\n-    rs6000_isa_flags |= ~rs6000_isa_flags_explicit & (OPTION_MASK_MULTIPLE\n-\t\t\t\t\t\t      | OPTION_MASK_STRING);\n+    rs6000_isa_flags |= ~rs6000_isa_flags_explicit & OPTION_MASK_MULTIPLE;\n \n-  /* Don't allow -mmultiple or -mstring on little endian systems\n-     unless the cpu is a 750, because the hardware doesn't support the\n-     instructions used in little endian mode, and causes an alignment\n-     trap.  The 750 does not cause an alignment trap (except when the\n-     target is unaligned).  */\n+  /* Don't allow -mmultiple on little endian systems unless the cpu is a 750,\n+     because the hardware doesn't support the instructions used in little\n+     endian mode, and causes an alignment trap.  The 750 does not cause an\n+     alignment trap (except when the target is unaligned).  */\n \n-  if (!BYTES_BIG_ENDIAN && rs6000_cpu != PROCESSOR_PPC750)\n+  if (!BYTES_BIG_ENDIAN && rs6000_cpu != PROCESSOR_PPC750 && TARGET_MULTIPLE)\n     {\n-      if (TARGET_MULTIPLE)\n-\t{\n-\t  rs6000_isa_flags &= ~OPTION_MASK_MULTIPLE;\n-\t  if ((rs6000_isa_flags_explicit & OPTION_MASK_MULTIPLE) != 0)\n-\t    warning (0, \"%qs is not supported on little endian systems\",\n-\t\t     \"-mmultiple\");\n-\t}\n-\n-      if (TARGET_STRING)\n-\t{\n-\t  rs6000_isa_flags &= ~OPTION_MASK_STRING;\n-\t  if ((rs6000_isa_flags_explicit & OPTION_MASK_STRING) != 0)\n-\t    warning (0, \"%qs is not supported on little endian systems\",\n-\t\t     \"-mstring\");\n-\t}\n+      rs6000_isa_flags &= ~OPTION_MASK_MULTIPLE;\n+      if ((rs6000_isa_flags_explicit & OPTION_MASK_MULTIPLE) != 0)\n+\twarning (0, \"%qs is not supported on little endian systems\",\n+\t\t \"-mmultiple\");\n     }\n \n   /* If little-endian, default to -mstrict-align on older processors.\n@@ -4812,9 +4799,7 @@ rs6000_option_override_internal (bool global_init_p)\n     rs6000_print_isa_options (stderr, 0, \"after subtarget\", rs6000_isa_flags);\n \n   /* For the E500 family of cores, reset the single/double FP flags to let us\n-     check that they remain constant across attributes or pragmas.  Also,\n-     clear a possible request for string instructions, not supported and which\n-     we might have silently queried above for -Os.  */\n+     check that they remain constant across attributes or pragmas.  */\n \n   switch (rs6000_cpu)\n     {\n@@ -4826,7 +4811,6 @@ rs6000_option_override_internal (bool global_init_p)\n     case PROCESSOR_PPCE6500:\n       rs6000_single_float = 0;\n       rs6000_double_float = 0;\n-      rs6000_isa_flags &= ~OPTION_MASK_STRING;\n       break;\n \n     default:\n@@ -21371,15 +21355,15 @@ print_operand (FILE *file, rtx x, int code)\n \t}\n       return;\n \n-    case 'N':\n+    case 'N': /* Unused */\n       /* Write the number of elements in the vector times 4.  */\n       if (GET_CODE (x) != PARALLEL)\n \toutput_operand_lossage (\"invalid %%N value\");\n       else\n \tfprintf (file, \"%d\", XVECLEN (x, 0) * 4);\n       return;\n \n-    case 'O':\n+    case 'O': /* Unused */\n       /* Similar, but subtract 1 first.  */\n       if (GET_CODE (x) != PARALLEL)\n \toutput_operand_lossage (\"invalid %%O value\");\n@@ -36633,7 +36617,7 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"quad-memory-atomic\",\tOPTION_MASK_QUAD_MEMORY_ATOMIC,\tfalse, true  },\n   { \"recip-precision\",\t\tOPTION_MASK_RECIP_PRECISION,\tfalse, true  },\n   { \"save-toc-indirect\",\tOPTION_MASK_SAVE_TOC_INDIRECT,\tfalse, true  },\n-  { \"string\",\t\t\tOPTION_MASK_STRING,\t\tfalse, true  },\n+  { \"string\",\t\t\t0,\t\t\t\tfalse, true  },\n   { \"toc-fusion\",\t\tOPTION_MASK_TOC_FUSION,\t\tfalse, true  },\n   { \"update\",\t\t\tOPTION_MASK_NO_UPDATE,\t\ttrue , true  },\n   { \"vsx\",\t\t\tOPTION_MASK_VSX,\t\tfalse, true  },\n@@ -36660,7 +36644,7 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"strict-align\",\t\tOPTION_MASK_STRICT_ALIGN,\tfalse, false },\n #endif\n   { \"soft-float\",\t\tOPTION_MASK_SOFT_FLOAT,\t\tfalse, false },\n-  { \"string\",\t\t\tOPTION_MASK_STRING,\t\tfalse, false },\n+  { \"string\",\t\t\t0,\t\t\t\tfalse, false },\n };\n \n /* Builtin mask mapping for printing the flags.  */"}, {"sha": "77b75dd756c0c6a7b701dd7f4d7ae428a6d65c9f", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=20c89ab7c5091ee48535392cae2177aa1a1c43eb", "patch": "@@ -380,7 +380,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n     /* The option machinery will define this.  */\n #endif\n \n-#define TARGET_DEFAULT (MASK_MULTIPLE | MASK_STRING)\n+#define TARGET_DEFAULT (MASK_MULTIPLE)\n \n /* FPU operations supported. \n    Each use of TARGET_SINGLE_FLOAT or TARGET_DOUBLE_FLOAT must \n@@ -658,7 +658,6 @@ extern int rs6000_vector_align[];\n #define MASK_RECIP_PRECISION\t\tOPTION_MASK_RECIP_PRECISION\n #define MASK_SOFT_FLOAT\t\t\tOPTION_MASK_SOFT_FLOAT\n #define MASK_STRICT_ALIGN\t\tOPTION_MASK_STRICT_ALIGN\n-#define MASK_STRING\t\t\tOPTION_MASK_STRING\n #define MASK_UPDATE\t\t\tOPTION_MASK_UPDATE\n #define MASK_VSX\t\t\tOPTION_MASK_VSX\n "}, {"sha": "b2e4bad6c358cbcfd0ad99360eaef88b52411d2e", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 2, "deletions": 539, "changes": 541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=20c89ab7c5091ee48535392cae2177aa1a1c43eb", "patch": "@@ -8765,37 +8765,11 @@\n    && (<MODE>mode != TImode || VECTOR_MEM_NONE_P (TImode))\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    default:\n-      gcc_unreachable ();\n-    case 0:\n-      if (TARGET_STRING)\n-        return \\\"stswi %1,%P0,16\\\";\n-      /* FALLTHRU */\n-    case 1:\n-      return \\\"#\\\";\n-    case 2:\n-      /* If the address is not used in the output, we can use lsi.  Otherwise,\n-\t fall through to generating four loads.  */\n-      if (TARGET_STRING\n-          && ! reg_overlap_mentioned_p (operands[0], operands[1]))\n-\treturn \\\"lswi %0,%P1,16\\\";\n-      /* fall through */\n-    case 3:\n-    case 4:\n-    case 5:\n-      return \\\"#\\\";\n-    }\n-}\"\n+  \"#\"\n   [(set_attr \"type\" \"store,store,load,load,*,*\")\n    (set_attr \"update\" \"yes\")\n    (set_attr \"indexed\" \"yes\")\n-   (set (attr \"cell_micro\") (if_then_else (match_test \"TARGET_STRING\")\n-   \t\t\t                  (const_string \"always\")\n-\t\t\t\t\t  (const_string \"conditional\")))])\n+   (set_attr \"cell_micro\" \"conditional\")])\n \n (define_insn \"*mov<mode>_ppc64\"\n   [(set (match_operand:TI2 0 \"nonimmediate_operand\" \"=wQ,Y,r,r,r,r\")\n@@ -8847,337 +8821,6 @@\n   [(pc)]\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \f\n-(define_expand \"load_multiple\"\n-  [(match_par_dup 3 [(set (match_operand:SI 0 \"\" \"\")\n-\t\t\t  (match_operand:SI 1 \"\" \"\"))\n-\t\t     (use (match_operand:SI 2 \"\" \"\"))])]\n-  \"TARGET_STRING && !TARGET_POWERPC64\"\n-  \"\n-{\n-  int regno;\n-  int count;\n-  rtx op1;\n-  int i;\n-\n-  /* Support only loading a constant number of fixed-point registers from\n-     memory and only bother with this if more than two; the machine\n-     doesn't support more than eight.  */\n-  if (GET_CODE (operands[2]) != CONST_INT\n-      || INTVAL (operands[2]) <= 2\n-      || INTVAL (operands[2]) > 8\n-      || GET_CODE (operands[1]) != MEM\n-      || GET_CODE (operands[0]) != REG\n-      || REGNO (operands[0]) >= 32)\n-    FAIL;\n-\n-  count = INTVAL (operands[2]);\n-  regno = REGNO (operands[0]);\n-\n-  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n-  op1 = replace_equiv_address (operands[1],\n-\t\t\t       force_reg (SImode, XEXP (operands[1], 0)));\n-\n-  for (i = 0; i < count; i++)\n-    XVECEXP (operands[3], 0, i)\n-      = gen_rtx_SET (gen_rtx_REG (SImode, regno + i),\n-\t\t     adjust_address_nv (op1, SImode, i * 4));\n-}\")\n-\n-(define_insn \"*ldmsi8\"\n-  [(match_parallel 0 \"load_multiple_operation\"\n-    [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n-          (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n-     (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n-     (set (match_operand:SI 4 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 8))))\n-     (set (match_operand:SI 5 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 12))))\n-     (set (match_operand:SI 6 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 16))))\n-     (set (match_operand:SI 7 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 20))))\n-     (set (match_operand:SI 8 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 24))))\n-     (set (match_operand:SI 9 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 28))))])]\n-  \"TARGET_STRING && XVECLEN (operands[0], 0) == 8\"\n-  \"*\n-{ return rs6000_output_load_multiple (operands); }\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"length\" \"32\")])\n-\n-(define_insn \"*ldmsi7\"\n-  [(match_parallel 0 \"load_multiple_operation\"\n-    [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n-          (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n-     (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n-     (set (match_operand:SI 4 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 8))))\n-     (set (match_operand:SI 5 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 12))))\n-     (set (match_operand:SI 6 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 16))))\n-     (set (match_operand:SI 7 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 20))))\n-     (set (match_operand:SI 8 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 24))))])]\n-  \"TARGET_STRING && XVECLEN (operands[0], 0) == 7\"\n-  \"*\n-{ return rs6000_output_load_multiple (operands); }\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"length\" \"32\")])\n-\n-(define_insn \"*ldmsi6\"\n-  [(match_parallel 0 \"load_multiple_operation\"\n-    [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n-          (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n-     (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n-     (set (match_operand:SI 4 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 8))))\n-     (set (match_operand:SI 5 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 12))))\n-     (set (match_operand:SI 6 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 16))))\n-     (set (match_operand:SI 7 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 20))))])]\n-  \"TARGET_STRING && XVECLEN (operands[0], 0) == 6\"\n-  \"*\n-{ return rs6000_output_load_multiple (operands); }\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"length\" \"32\")])\n-\n-(define_insn \"*ldmsi5\"\n-  [(match_parallel 0 \"load_multiple_operation\"\n-    [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n-          (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n-     (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n-     (set (match_operand:SI 4 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 8))))\n-     (set (match_operand:SI 5 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 12))))\n-     (set (match_operand:SI 6 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 16))))])]\n-  \"TARGET_STRING && XVECLEN (operands[0], 0) == 5\"\n-  \"*\n-{ return rs6000_output_load_multiple (operands); }\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"length\" \"32\")])\n-\n-(define_insn \"*ldmsi4\"\n-  [(match_parallel 0 \"load_multiple_operation\"\n-    [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n-          (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n-     (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n-     (set (match_operand:SI 4 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 8))))\n-     (set (match_operand:SI 5 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 12))))])]\n-  \"TARGET_STRING && XVECLEN (operands[0], 0) == 4\"\n-  \"*\n-{ return rs6000_output_load_multiple (operands); }\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"length\" \"32\")])\n-\n-(define_insn \"*ldmsi3\"\n-  [(match_parallel 0 \"load_multiple_operation\"\n-    [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n-          (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n-     (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n-     (set (match_operand:SI 4 \"gpc_reg_operand\" \"\")\n-          (mem:SI (plus:SI (match_dup 1) (const_int 8))))])]\n-  \"TARGET_STRING && XVECLEN (operands[0], 0) == 3\"\n-  \"*\n-{ return rs6000_output_load_multiple (operands); }\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"length\" \"32\")])\n-\n-(define_expand \"store_multiple\"\n-  [(match_par_dup 3 [(set (match_operand:SI 0 \"\" \"\")\n-\t\t\t  (match_operand:SI 1 \"\" \"\"))\n-\t\t     (clobber (scratch:SI))\n-\t\t     (use (match_operand:SI 2 \"\" \"\"))])]\n-  \"TARGET_STRING && !TARGET_POWERPC64\"\n-  \"\n-{\n-  int regno;\n-  int count;\n-  rtx to;\n-  rtx op0;\n-  int i;\n-\n-  /* Support only storing a constant number of fixed-point registers to\n-     memory and only bother with this if more than two; the machine\n-     doesn't support more than eight.  */\n-  if (GET_CODE (operands[2]) != CONST_INT\n-      || INTVAL (operands[2]) <= 2\n-      || INTVAL (operands[2]) > 8\n-      || GET_CODE (operands[0]) != MEM\n-      || GET_CODE (operands[1]) != REG\n-      || REGNO (operands[1]) >= 32)\n-    FAIL;\n-\n-  count = INTVAL (operands[2]);\n-  regno = REGNO (operands[1]);\n-\n-  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 1));\n-  to = force_reg (SImode, XEXP (operands[0], 0));\n-  op0 = replace_equiv_address (operands[0], to);\n-\n-  XVECEXP (operands[3], 0, 0)\n-    = gen_rtx_SET (adjust_address_nv (op0, SImode, 0), operands[1]);\n-  XVECEXP (operands[3], 0, 1) = gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t gen_rtx_SCRATCH (SImode));\n-\n-  for (i = 1; i < count; i++)\n-    XVECEXP (operands[3], 0, i + 1)\n-      = gen_rtx_SET (adjust_address_nv (op0, SImode, i * 4),\n-\t\t     gen_rtx_REG (SImode, regno + i));\n-}\")\n-\n-(define_insn \"*stmsi8\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n-    [(set (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\"))\n-\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n-     (clobber (match_scratch:SI 3 \"=X\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 4)))\n-\t  (match_operand:SI 4 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 8)))\n-\t  (match_operand:SI 5 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 12)))\n-\t  (match_operand:SI 6 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 16)))\n-\t  (match_operand:SI 7 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 20)))\n-\t  (match_operand:SI 8 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 24)))\n-\t  (match_operand:SI 9 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 28)))\n-\t  (match_operand:SI 10 \"gpc_reg_operand\" \"r\"))])]\n-  \"TARGET_STRING && XVECLEN (operands[0], 0) == 9\"\n-  \"stswi %2,%1,%O0\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"cell_micro\" \"always\")])\n-\n-(define_insn \"*stmsi7\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n-    [(set (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\"))\n-\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n-     (clobber (match_scratch:SI 3 \"=X\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 4)))\n-\t  (match_operand:SI 4 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 8)))\n-\t  (match_operand:SI 5 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 12)))\n-\t  (match_operand:SI 6 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 16)))\n-\t  (match_operand:SI 7 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 20)))\n-\t  (match_operand:SI 8 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 24)))\n-\t  (match_operand:SI 9 \"gpc_reg_operand\" \"r\"))])]\n-  \"TARGET_STRING && XVECLEN (operands[0], 0) == 8\"\n-  \"stswi %2,%1,%O0\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"cell_micro\" \"always\")])\n-\n-(define_insn \"*stmsi6\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n-    [(set (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\"))\n-\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n-     (clobber (match_scratch:SI 3 \"=X\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 4)))\n-\t  (match_operand:SI 4 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 8)))\n-\t  (match_operand:SI 5 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 12)))\n-\t  (match_operand:SI 6 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 16)))\n-\t  (match_operand:SI 7 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 20)))\n-\t  (match_operand:SI 8 \"gpc_reg_operand\" \"r\"))])]\n-  \"TARGET_STRING && XVECLEN (operands[0], 0) == 7\"\n-  \"stswi %2,%1,%O0\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"cell_micro\" \"always\")])\n-\n-(define_insn \"*stmsi5\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n-    [(set (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\"))\n-\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n-     (clobber (match_scratch:SI 3 \"=X\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 4)))\n-\t  (match_operand:SI 4 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 8)))\n-\t  (match_operand:SI 5 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 12)))\n-\t  (match_operand:SI 6 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 16)))\n-\t  (match_operand:SI 7 \"gpc_reg_operand\" \"r\"))])]\n-  \"TARGET_STRING && XVECLEN (operands[0], 0) == 6\"\n-  \"stswi %2,%1,%O0\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"cell_micro\" \"always\")])\n-\n-(define_insn \"*stmsi4\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n-    [(set (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\"))\n-\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n-     (clobber (match_scratch:SI 3 \"=X\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 4)))\n-\t  (match_operand:SI 4 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 8)))\n-\t  (match_operand:SI 5 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 12)))\n-\t  (match_operand:SI 6 \"gpc_reg_operand\" \"r\"))])]\n-  \"TARGET_STRING && XVECLEN (operands[0], 0) == 5\"\n-  \"stswi %2,%1,%O0\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"cell_micro\" \"always\")])\n-\n-(define_insn \"*stmsi3\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n-    [(set (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\"))\n-\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n-     (clobber (match_scratch:SI 3 \"=X\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 4)))\n-\t  (match_operand:SI 4 \"gpc_reg_operand\" \"r\"))\n-     (set (mem:SI (plus:SI (match_dup 1) (const_int 8)))\n-\t  (match_operand:SI 5 \"gpc_reg_operand\" \"r\"))])]\n-  \"TARGET_STRING && XVECLEN (operands[0], 0) == 4\"\n-  \"stswi %2,%1,%O0\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"cell_micro\" \"always\")])\n-\f\n (define_expand \"setmemsi\"\n   [(parallel [(set (match_operand:BLK 0 \"\" \"\")\n \t\t   (match_operand 2 \"const_int_operand\" \"\"))\n@@ -9282,186 +8925,6 @@\n   else\n     FAIL;\n }\")\n-\n-;; Move up to 32 bytes at a time.  The fixed registers are needed because the\n-;; register allocator doesn't have a clue about allocating 8 word registers.\n-;; rD/rS = r5 is preferred, efficient form.\n-(define_expand \"movmemsi_8reg\"\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (match_operand 1 \"\" \"\"))\n-\t      (use (match_operand 2 \"\" \"\"))\n-\t      (use (match_operand 3 \"\" \"\"))\n-\t      (clobber (reg:SI  5))\n-\t      (clobber (reg:SI  6))\n-\t      (clobber (reg:SI  7))\n-\t      (clobber (reg:SI  8))\n-\t      (clobber (reg:SI  9))\n-\t      (clobber (reg:SI 10))\n-\t      (clobber (reg:SI 11))\n-\t      (clobber (reg:SI 12))\n-\t      (clobber (match_scratch:SI 4 \"\"))])]\n-  \"TARGET_STRING\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (mem:BLK (match_operand:P 0 \"gpc_reg_operand\" \"b\"))\n-\t(mem:BLK (match_operand:P 1 \"gpc_reg_operand\" \"b\")))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"i\"))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n-   (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=&r\"))\n-   (clobber (reg:SI  6))\n-   (clobber (reg:SI  7))\n-   (clobber (reg:SI  8))\n-   (clobber (reg:SI  9))\n-   (clobber (reg:SI 10))\n-   (clobber (reg:SI 11))\n-   (clobber (reg:SI 12))\n-   (clobber (match_scratch:SI 5 \"=X\"))]\n-  \"TARGET_STRING\n-   && ((INTVAL (operands[2]) > 24 && INTVAL (operands[2]) < 32)\n-       || INTVAL (operands[2]) == 0)\n-   && (REGNO (operands[0]) < 5 || REGNO (operands[0]) > 12)\n-   && (REGNO (operands[1]) < 5 || REGNO (operands[1]) > 12)\n-   && REGNO (operands[4]) == 5\"\n-  \"lswi %4,%1,%2\\;stswi %4,%0,%2\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"cell_micro\" \"always\")\n-   (set_attr \"length\" \"8\")])\n-\n-;; Move up to 24 bytes at a time.  The fixed registers are needed because the\n-;; register allocator doesn't have a clue about allocating 6 word registers.\n-;; rD/rS = r5 is preferred, efficient form.\n-(define_expand \"movmemsi_6reg\"\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (match_operand 1 \"\" \"\"))\n-\t      (use (match_operand 2 \"\" \"\"))\n-\t      (use (match_operand 3 \"\" \"\"))\n-\t      (clobber (reg:SI  5))\n-\t      (clobber (reg:SI  6))\n-\t      (clobber (reg:SI  7))\n-\t      (clobber (reg:SI  8))\n-\t      (clobber (reg:SI  9))\n-\t      (clobber (reg:SI 10))\n-\t      (clobber (match_scratch:SI 4 \"\"))])]\n-  \"TARGET_STRING\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (mem:BLK (match_operand:P 0 \"gpc_reg_operand\" \"b\"))\n-\t(mem:BLK (match_operand:P 1 \"gpc_reg_operand\" \"b\")))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"i\"))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n-   (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=&r\"))\n-   (clobber (reg:SI  6))\n-   (clobber (reg:SI  7))\n-   (clobber (reg:SI  8))\n-   (clobber (reg:SI  9))\n-   (clobber (reg:SI 10))\n-   (clobber (match_scratch:SI 5 \"=X\"))]\n-  \"TARGET_STRING\n-   && INTVAL (operands[2]) > 16 && INTVAL (operands[2]) <= 32\n-   && (REGNO (operands[0]) < 5 || REGNO (operands[0]) > 10)\n-   && (REGNO (operands[1]) < 5 || REGNO (operands[1]) > 10)\n-   && REGNO (operands[4]) == 5\"\n-  \"lswi %4,%1,%2\\;stswi %4,%0,%2\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"cell_micro\" \"always\")\n-   (set_attr \"length\" \"8\")])\n-\n-;; Move up to 16 bytes at a time, using 4 fixed registers to avoid spill\n-;; problems with TImode.\n-;; rD/rS = r5 is preferred, efficient form.\n-(define_expand \"movmemsi_4reg\"\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (match_operand 1 \"\" \"\"))\n-\t      (use (match_operand 2 \"\" \"\"))\n-\t      (use (match_operand 3 \"\" \"\"))\n-\t      (clobber (reg:SI 5))\n-\t      (clobber (reg:SI 6))\n-\t      (clobber (reg:SI 7))\n-\t      (clobber (reg:SI 8))\n-\t      (clobber (match_scratch:SI 4 \"\"))])]\n-  \"TARGET_STRING\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (mem:BLK (match_operand:P 0 \"gpc_reg_operand\" \"b\"))\n-\t(mem:BLK (match_operand:P 1 \"gpc_reg_operand\" \"b\")))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"i\"))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n-   (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=&r\"))\n-   (clobber (reg:SI 6))\n-   (clobber (reg:SI 7))\n-   (clobber (reg:SI 8))\n-   (clobber (match_scratch:SI 5 \"=X\"))]\n-  \"TARGET_STRING\n-   && INTVAL (operands[2]) > 8 && INTVAL (operands[2]) <= 16\n-   && (REGNO (operands[0]) < 5 || REGNO (operands[0]) > 8)\n-   && (REGNO (operands[1]) < 5 || REGNO (operands[1]) > 8)\n-   && REGNO (operands[4]) == 5\"\n-  \"lswi %4,%1,%2\\;stswi %4,%0,%2\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"cell_micro\" \"always\")\n-   (set_attr \"length\" \"8\")])\n-\n-;; Move up to 8 bytes at a time.\n-(define_expand \"movmemsi_2reg\"\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (match_operand 1 \"\" \"\"))\n-\t      (use (match_operand 2 \"\" \"\"))\n-\t      (use (match_operand 3 \"\" \"\"))\n-\t      (clobber (match_scratch:DI 4 \"\"))\n-\t      (clobber (match_scratch:SI 5 \"\"))])]\n-  \"TARGET_STRING && ! TARGET_POWERPC64\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (mem:BLK (match_operand:SI 0 \"gpc_reg_operand\" \"b\"))\n-\t(mem:BLK (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"i\"))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n-   (clobber (match_scratch:DI 4 \"=&r\"))\n-   (clobber (match_scratch:SI 5 \"=X\"))]\n-  \"TARGET_STRING && ! TARGET_POWERPC64\n-   && INTVAL (operands[2]) > 4 && INTVAL (operands[2]) <= 8\"\n-  \"lswi %4,%1,%2\\;stswi %4,%0,%2\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"cell_micro\" \"always\")\n-   (set_attr \"length\" \"8\")])\n-\n-;; Move up to 4 bytes at a time.\n-(define_expand \"movmemsi_1reg\"\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (match_operand 1 \"\" \"\"))\n-\t      (use (match_operand 2 \"\" \"\"))\n-\t      (use (match_operand 3 \"\" \"\"))\n-\t      (clobber (match_scratch:SI 4 \"\"))\n-\t      (clobber (match_scratch:SI 5 \"\"))])]\n-  \"TARGET_STRING\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (mem:BLK (match_operand:P 0 \"gpc_reg_operand\" \"b\"))\n-\t(mem:BLK (match_operand:P 1 \"gpc_reg_operand\" \"b\")))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"i\"))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n-   (clobber (match_scratch:SI 4 \"=&r\"))\n-   (clobber (match_scratch:SI 5 \"=X\"))]\n-  \"TARGET_STRING && INTVAL (operands[2]) > 0 && INTVAL (operands[2]) <= 4\"\n-  \"lswi %4,%1,%2\\;stswi %4,%0,%2\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"update\" \"yes\")\n-   (set_attr \"indexed\" \"yes\")\n-   (set_attr \"cell_micro\" \"always\")\n-   (set_attr \"length\" \"8\")])\n \f\n ;; Define insns that do load or store with update.  Some of these we can\n ;; get by using pre-decrement or pre-increment, but the hardware can also"}, {"sha": "54643802f8f9af194c2dde27cf0bd822a533ba3f", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=20c89ab7c5091ee48535392cae2177aa1a1c43eb", "patch": "@@ -180,9 +180,12 @@ mmultiple\n Target Report Mask(MULTIPLE) Var(rs6000_isa_flags)\n Generate load/store multiple instructions.\n \n+;; This option existed in the past, but now is always off.\n+mno-string\n+Target RejectNegative Undocumented Ignore\n+\n mstring\n-Target Report Mask(STRING) Var(rs6000_isa_flags)\n-Generate string instructions for block moves.\n+Target RejectNegative Undocumented Warn(%<-mstring%> is deprecated)\n \n msoft-float\n Target Report RejectNegative Mask(SOFT_FLOAT) Var(rs6000_isa_flags)"}, {"sha": "89a4727ecdff559f17578ea485e89f08a096a8bd", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c89ab7c5091ee48535392cae2177aa1a1c43eb/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=20c89ab7c5091ee48535392cae2177aa1a1c43eb", "patch": "@@ -1018,7 +1018,7 @@ See RS/6000 and PowerPC Options.\n -malign-power  -malign-natural @gol\n -msoft-float  -mhard-float  -mmultiple  -mno-multiple @gol\n -msingle-float  -mdouble-float  -msimple-fpu @gol\n--mstring  -mno-string  -mupdate  -mno-update @gol\n+-mupdate  -mno-update @gol\n -mavoid-indexed-addresses  -mno-avoid-indexed-addresses @gol\n -mfused-madd  -mno-fused-madd  -mbit-align  -mno-bit-align @gol\n -mstrict-align  -mno-strict-align  -mrelocatable @gol\n@@ -22292,7 +22292,7 @@ following options:\n @gccoptlist{-maltivec  -mfprnd  -mhard-float  -mmfcrf  -mmultiple @gol\n -mpopcntb -mpopcntd  -mpowerpc64 @gol\n -mpowerpc-gpopt  -mpowerpc-gfxopt  -msingle-float -mdouble-float @gol\n--msimple-fpu -mstring  -mmulhw  -mdlmzb  -mmfpgpr -mvsx @gol\n+-msimple-fpu  -mmulhw  -mdlmzb  -mmfpgpr -mvsx @gol\n -mcrypto -mdirect-move -mhtm -mpower8-fusion -mpower8-vector @gol\n -mquad-memory -mquad-memory-atomic -mfloat128 -mfloat128-hardware}\n \n@@ -22689,19 +22689,6 @@ PowerPC systems, since those instructions do not work when the\n processor is in little-endian mode.  The exceptions are PPC740 and\n PPC750 which permit these instructions in little-endian mode.\n \n-@item -mstring\n-@itemx -mno-string\n-@opindex mstring\n-@opindex mno-string\n-Generate code that uses (does not use) the load string instructions\n-and the store string word instructions to save multiple registers and\n-do small block moves.  These instructions are generated by default on\n-POWER systems, and not generated on PowerPC systems.  Do not use\n-@option{-mstring} on little-endian PowerPC systems, since those\n-instructions do not work when the processor is in little-endian mode.\n-The exceptions are PPC740 and PPC750 which permit these instructions\n-in little-endian mode.\n-\n @item -mupdate\n @itemx -mno-update\n @opindex mupdate"}]}