{"sha": "6cf9ac28580beb4c5ae891781250cf5d6744d676", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNmOWFjMjg1ODBiZWI0YzVhZTg5MTc4MTI1MGNmNWQ2NzQ0ZDY3Ng==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-07-01T05:00:18Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-07-01T05:00:18Z"}, "message": "final.c: Convert prototypes to ISO C90.\n\n\t* final.c: Convert prototypes to ISO C90.\n\t* flow.c: Likewise.\n\t* flags.h: Likewise.\n\nFrom-SVN: r68760", "tree": {"sha": "521bc581c2a29e8aa30a8787670777925bafaab4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/521bc581c2a29e8aa30a8787670777925bafaab4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cf9ac28580beb4c5ae891781250cf5d6744d676", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf9ac28580beb4c5ae891781250cf5d6744d676", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cf9ac28580beb4c5ae891781250cf5d6744d676", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf9ac28580beb4c5ae891781250cf5d6744d676/comments", "author": null, "committer": null, "parents": [{"sha": "4c20b2e76b5b12a2f4efdc62eec8fcfa650c6a80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c20b2e76b5b12a2f4efdc62eec8fcfa650c6a80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c20b2e76b5b12a2f4efdc62eec8fcfa650c6a80"}], "stats": {"total": 570, "additions": 207, "deletions": 363}, "files": [{"sha": "718067e69416caafddd32d824ddbfacb5daadace", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf9ac28580beb4c5ae891781250cf5d6744d676/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf9ac28580beb4c5ae891781250cf5d6744d676/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6cf9ac28580beb4c5ae891781250cf5d6744d676", "patch": "@@ -1,3 +1,11 @@\n+2003-07-01  Andreas Jaeger  <aj@suse.de>\n+\n+\t* final.c: Convert prototypes to ISO C90.\n+\t* flow.c: Likewise.\n+\t* flags.h: Likewise.\n+\t* gcov-io.c: Likewise.\n+\t* gcov-io.h: Likewise.\n+\n 2003-06-30  Bruno Haible  <bruno@clisp.org>\n \n \tPR middle-end/6578\n@@ -45,14 +53,14 @@\n \t* config/rs6000/spe.h (__ev_set_spefscr_frmc): Set the flag.\n \n 2003-06-30  Bob Wilson  <bob.wilson@acm.org>\n-\t\n+\n \t* config/xtensa/lib1funcs.asm: Use \"xtensa-config.h\" from\n \ttop-level include directory.\n \t* config/xtensa/lib2funcs.S: Likewise.\n \t* config/xtensa/xtensa.h: Likewise.\n \t* config/xtensa/xtensa-config.h: Remove.\n \t* doc/install.texi: Update location of \"xtensa-config.h\" header.\n-\t\n+\n 2003-06-30  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.c (s390_extra_constraint): New function.\n@@ -82,18 +90,18 @@\n \t\"*tstsi\", \"*tstsi_cconly\", \"*tsthiCCT\", \"*tsthiCCT_cconly\",\n \t\"*tsthi\", \"*tsthi_cconly\", \"*tstqiCCT\", \"*tstqiCCT_cconly\",\n \t\"*tstqi\", \"*tstqi_cconly\", \"*cmpsi_ccs_sign\", \"*cmpsi_ccs\",\n-\t\"*cmpsi_ccu\", \"*cmphi_ccu\", \"*cmpqi_ccu\", \"*cli\", \n+\t\"*cmpsi_ccu\", \"*cmphi_ccu\", \"*cmpqi_ccu\", \"*cli\",\n \t\"movti\", \"*movdi_64\", \"*movdi_31\", \"*movsi\", \"movhi\", \"movqi_64\",\n \t\"movqi\", \"*movstrictqi\", \"*movstricthi\", \"movstrictsi\",\n-\t\"*movdf_64\", \"*movdf_31\", \"*movsf\", \n+\t\"*movdf_64\", \"*movdf_31\", \"*movsf\",\n \t\"*load_multiple_si\", \"*store_multiple_di\",\n-\t\"*sethighqisi\", \"*sethighhisi\", \"*sethighqidi_31\", \"*extendhisi2\", \n-\t\"*la_64\", \"*la_31\", \"*la_31_and\", \"force_la_31\", \n+\t\"*sethighqisi\", \"*sethighhisi\", \"*sethighqidi_31\", \"*extendhisi2\",\n+\t\"*la_64\", \"*la_31\", \"*la_31_and\", \"force_la_31\",\n \t\"*addsi3_carry1_cc\", *addsi3_carry1_cconly\",\n \t\"*addsi3_carry2_cc\", *addsi3_carry2_cconly\",\n \t\"*addsi3_cc\", \"*addsi3_cconly\", \"*addsi3_cconly2\",\n-\t\"*addsi3_sign\", \"*addsi3_sub\", \"addsi3\", \n-\t\"*subsi3_borrow_cc\", \"*subsi3_borrow_cconly\", \"*subsi3_cc\", \n+\t\"*addsi3_sign\", \"*addsi3_sub\", \"addsi3\",\n+\t\"*subsi3_borrow_cc\", \"*subsi3_borrow_cconly\", \"*subsi3_cc\",\n \t\"*subsi3_cconly\", \"*subsi3_sign\", \"*subsi3_sub\", \"subsi3\",\n \t\"mulsi3\"\n \t\"*andsi3_cc\", \"*andsi3_cconly\", \"andsi3\",\n@@ -106,7 +114,7 @@\n \n \t(\"*cmpdf_ccs\", \"*cmpdf_ccs_ibm\", \"*cmpsf_ccs\", \"*cmpsf_ccs_ibm\",\n \t\"*load_multiple_di\", \"*store_multiple_di\",\n-\t\"*sethighqidi_64\", \"*zero_extendhisi2_31\", \n+\t\"*sethighqidi_64\", \"*zero_extendhisi2_31\",\n \t\"truncdfsf2_ibm\", \"extendsfdf2_ieee\", \"extendsfdf2_ibm\",\n \t\"adddf3\", \"*adddf3\", \"*adddf3_ibm\",\n \t\"addsf3\", \"*addsf3\", \"*addsf3_ibm\",\n@@ -117,11 +125,11 @@\n \t\"mulsf3\", \"*mulsf3\", \"*mulsf3_ibm\",\n \t\"divdf3\", \"*divdf3\", \"*divdf3_ibm\",\n \t\"divsf3\", \"div*sf3\", \"*divsf3_ibm\",\n-\t\"sqrtdf2\", \"sqrtsf2\", \n+\t\"sqrtdf2\", \"sqrtsf2\",\n \t\"*cjump_long\", \"*icjump_long\", \"indirect_jump\", \"casesi_jump\",\n \t\"*doloop_si_long\", \"*doloop_di_long\", \"bas_64\", \"bas_31\",\n-\t\"bas_r_64\", \"bas_r_31\", \"bas_tls_31\", \"bas_tls_64\"): Adapt memory \n-\tand address constraints for instructions that do not accept long \n+\t\"bas_r_64\", \"bas_r_31\", \"bas_tls_31\", \"bas_tls_64\"): Adapt memory\n+\tand address constraints for instructions that do not accept long\n \tdisplacements.\n \n 2003-06-30  Hartmut Penner  <hpenner@de.ibm.com>\n@@ -180,22 +188,22 @@ Mon Jun 30 23:47:33 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \tarchitecture to assembler.\n \t(LINK_SPEC): Merge 31-bit and 64-bit variants.\n \t(LINK_ARCH31_SPEC, LINK_ARCH64_SPEC, EXTRA_SPECS): Remove.\n-\t* config/s390/s390.c (override_options): New default rules for \n+\t* config/s390/s390.c (override_options): New default rules for\n \tarchitecture mode and cpu architecture selection.\n \t* doc/invoke.texi (-mesa, -mzarch, -march, -mtune): Document\n \tnew default rules.\n-\t\n+\n \t* config/s390/s390.h (enum processor_type): Add PROCESSOR_2084_Z990.\n \t* config/s390/s390.md (attr \"cpu\"): Add \"z990\" processor type.\n-\t* config/s390/s390.c (override_options): Add \"z990\" to \n+\t* config/s390/s390.c (override_options): Add \"z990\" to\n \tprocessor_alias_table.\n \t* doc/invoke.texi (-march): Document \"z990\" processor type.\n \n \t* config/s390/s390.c (s390_tune_flags, s390_arch_flags): New variables.\n \t* config/s390/s390.h (s390_tune_flags, s390_arch_flags): Declare.\n \t(enum processor_flags, TARGET_CPU_IEEE_FLOAT, TARGET_CPU_ZARCH,\n \tTARGET_CPU_LONG_DISPLACEMENT, TARGET_LONG_DISPLACEMENT): New.\n-\t* config/s390/s390.c (override_options): Replace enum pta_flags by \n+\t* config/s390/s390.c (override_options): Replace enum pta_flags by\n \tenum processor_flags.  Fill in s390_tune_flags and s390_arch_flags.\n \n \t* config/s390/s390.c (s390_cpu): Rename to ...\n@@ -263,7 +271,7 @@ Mon Jun 30 15:36:29 CEST 2003  Jan Hubicka  <jh@suse.cz>\n         * config/rs6000/rs6000.c (rs6000_split_altivec_in_gprs): New function.\n         (altivec_in_gprs_p): New function.\n \n-\t* config/rs6000/rs6000-protos (rs6000_split_altivec_in_gprs): New \n+\t* config/rs6000/rs6000-protos (rs6000_split_altivec_in_gprs): New\n \tprototype.\n \t(altivec_in_gprs_p): New prototype.\n \n@@ -370,7 +378,7 @@ Sun Jun 29 23:06:32 CEST 2003  Jan Hubicka  <jh@suse.cz>\n 2003-06-29  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* loop.c (count_one_set): Fix detection of registers set in more\n-\tthan one basic block.\t\n+\tthan one basic block.\n \n 2003-06-29  Andreas Jaeger  <aj@suse.de>\n "}, {"sha": "e3ded5db34a72388ba3400f3a75c3321d57a7bed", "filename": "gcc/final.c", "status": "modified", "additions": 73, "deletions": 124, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf9ac28580beb4c5ae891781250cf5d6744d676/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf9ac28580beb4c5ae891781250cf5d6744d676/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=6cf9ac28580beb4c5ae891781250cf5d6744d676", "patch": "@@ -1,6 +1,6 @@\n /* Convert RTL to assembler code and output it, for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n-   1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -205,35 +205,34 @@ rtx current_insn_predicate;\n #endif\n \n #ifdef HAVE_ATTR_length\n-static int asm_insn_count\tPARAMS ((rtx));\n-#endif\n-static void profile_function\tPARAMS ((FILE *));\n-static void profile_after_prologue PARAMS ((FILE *));\n-static bool notice_source_line\tPARAMS ((rtx));\n-static rtx walk_alter_subreg\tPARAMS ((rtx *));\n-static void output_asm_name\tPARAMS ((void));\n-static void output_alternate_entry_point PARAMS ((FILE *, rtx));\n-static tree get_mem_expr_from_op\tPARAMS ((rtx, int *));\n-static void output_asm_operand_names PARAMS ((rtx *, int *, int));\n-static void output_operand\tPARAMS ((rtx, int));\n+static int asm_insn_count (rtx);\n+#endif\n+static void profile_function (FILE *);\n+static void profile_after_prologue (FILE *);\n+static bool notice_source_line (rtx);\n+static rtx walk_alter_subreg (rtx *);\n+static void output_asm_name (void);\n+static void output_alternate_entry_point (FILE *, rtx);\n+static tree get_mem_expr_from_op (rtx, int *);\n+static void output_asm_operand_names (rtx *, int *, int);\n+static void output_operand (rtx, int);\n #ifdef LEAF_REGISTERS\n-static void leaf_renumber_regs\tPARAMS ((rtx));\n+static void leaf_renumber_regs (rtx);\n #endif\n #ifdef HAVE_cc0\n-static int alter_cond\t\tPARAMS ((rtx));\n+static int alter_cond (rtx);\n #endif\n #ifndef ADDR_VEC_ALIGN\n-static int final_addr_vec_align PARAMS ((rtx));\n+static int final_addr_vec_align (rtx);\n #endif\n #ifdef HAVE_ATTR_length\n-static int align_fuzz\t\tPARAMS ((rtx, rtx, int, unsigned));\n+static int align_fuzz (rtx, rtx, int, unsigned);\n #endif\n \f\n /* Initialize data in final at the beginning of a compilation.  */\n \n void\n-init_final (filename)\n-     const char *filename ATTRIBUTE_UNUSED;\n+init_final (const char *filename ATTRIBUTE_UNUSED)\n {\n   app_on = 0;\n   final_sequence = 0;\n@@ -248,24 +247,22 @@ init_final (filename)\n    If not overridden for epilogue code, then the function body itself\n    contains return instructions wherever needed.  */\n void\n-default_function_pro_epilogue (file, size)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+default_function_pro_epilogue (FILE *file ATTRIBUTE_UNUSED,\n+\t\t\t       HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n }\n \n /* Default target hook that outputs nothing to a stream.  */\n void\n-no_asm_to_stream (file)\n-     FILE *file ATTRIBUTE_UNUSED;\n+no_asm_to_stream (FILE *file ATTRIBUTE_UNUSED)\n {\n }\n \n /* Enable APP processing of subsequent output.\n    Used before the output from an `asm' statement.  */\n \n void\n-app_enable ()\n+app_enable (void)\n {\n   if (! app_on)\n     {\n@@ -278,7 +275,7 @@ app_enable ()\n    Called from varasm.c before most kinds of output.  */\n \n void\n-app_disable ()\n+app_disable (void)\n {\n   if (app_on)\n     {\n@@ -293,7 +290,7 @@ app_disable ()\n \n #ifdef DELAY_SLOTS\n int\n-dbr_sequence_length ()\n+dbr_sequence_length (void)\n {\n   if (final_sequence != 0)\n     return XVECLEN (final_sequence, 0) - 1;\n@@ -346,7 +343,7 @@ static struct label_alignment *label_align;\n /* Indicate that branch shortening hasn't yet been done.  */\n \n void\n-init_insn_lengths ()\n+init_insn_lengths (void)\n {\n   if (uid_shuid)\n     {\n@@ -373,8 +370,7 @@ init_insn_lengths ()\n    get its actual length.  Otherwise, get its maximum length.  */\n \n int\n-get_attr_length (insn)\n-     rtx insn ATTRIBUTE_UNUSED;\n+get_attr_length (rtx insn ATTRIBUTE_UNUSED)\n {\n #ifdef HAVE_ATTR_length\n   rtx body;\n@@ -508,8 +504,7 @@ get_attr_length (insn)\n \n #ifndef ADDR_VEC_ALIGN\n static int\n-final_addr_vec_align (addr_vec)\n-     rtx addr_vec;\n+final_addr_vec_align (rtx addr_vec)\n {\n   int align = GET_MODE_SIZE (GET_MODE (PATTERN (addr_vec)));\n \n@@ -539,8 +534,7 @@ static int min_labelno, max_labelno;\n /* For the benefit of port specific code do this also as a function.  */\n \n int\n-label_to_alignment (label)\n-     rtx label;\n+label_to_alignment (rtx label)\n {\n   return LABEL_TO_ALIGNMENT (label);\n }\n@@ -575,10 +569,7 @@ label_to_alignment (label)\n    The return value is undefined for any other value of GROWTH.  */\n \n static int\n-align_fuzz (start, end, known_align_log, growth)\n-     rtx start, end;\n-     int known_align_log;\n-     unsigned growth;\n+align_fuzz (rtx start, rtx end, int known_align_log, unsigned int growth)\n {\n   int uid = INSN_UID (start);\n   rtx align_label;\n@@ -617,8 +608,7 @@ align_fuzz (start, end, known_align_log, growth)\n    to exclude the branch size.  */\n \n int\n-insn_current_reference_address (branch)\n-     rtx branch;\n+insn_current_reference_address (rtx branch)\n {\n   rtx dest, seq;\n   int seq_uid;\n@@ -655,7 +645,7 @@ insn_current_reference_address (branch)\n #endif /* HAVE_ATTR_length */\n \f\n void\n-compute_alignments ()\n+compute_alignments (void)\n {\n   int log, max_skip, max_log;\n   basic_block bb;\n@@ -755,8 +745,7 @@ compute_alignments ()\n    slots.  */\n \n void\n-shorten_branches (first)\n-     rtx first ATTRIBUTE_UNUSED;\n+shorten_branches (rtx first ATTRIBUTE_UNUSED)\n {\n   rtx insn;\n   int max_uid;\n@@ -1311,8 +1300,7 @@ shorten_branches (first)\n    This is used to compute its length.  */\n \n static int\n-asm_insn_count (body)\n-     rtx body;\n+asm_insn_count (rtx body)\n {\n   const char *template;\n   int count = 1;\n@@ -1341,10 +1329,8 @@ asm_insn_count (body)\n      test and compare insns.  */\n \n void\n-final_start_function (first, file, optimize)\n-     rtx first ATTRIBUTE_UNUSED;\n-     FILE *file;\n-     int optimize ATTRIBUTE_UNUSED;\n+final_start_function (rtx first ATTRIBUTE_UNUSED, FILE *file,\n+\t\t      int optimize ATTRIBUTE_UNUSED)\n {\n   block_depth = 0;\n \n@@ -1416,8 +1402,7 @@ final_start_function (first, file, optimize)\n }\n \n static void\n-profile_after_prologue (file)\n-     FILE *file ATTRIBUTE_UNUSED;\n+profile_after_prologue (FILE *file ATTRIBUTE_UNUSED)\n {\n #ifndef PROFILE_BEFORE_PROLOGUE\n   if (current_function_profile)\n@@ -1426,8 +1411,7 @@ profile_after_prologue (file)\n }\n \n static void\n-profile_function (file)\n-     FILE *file ATTRIBUTE_UNUSED;\n+profile_function (FILE *file ATTRIBUTE_UNUSED)\n {\n #ifndef NO_PROFILE_COUNTERS\n # define NO_PROFILE_COUNTERS\t0\n@@ -1508,7 +1492,7 @@ profile_function (file)\n    even though not all of them are needed.  */\n \n void\n-final_end_function ()\n+final_end_function (void)\n {\n   app_disable ();\n \n@@ -1540,11 +1524,7 @@ final_end_function ()\n    Prescanning is done only on certain machines.  */\n \n void\n-final (first, file, optimize, prescan)\n-     rtx first;\n-     FILE *file;\n-     int optimize;\n-     int prescan;\n+final (rtx first, FILE *file, int optimize, int prescan)\n {\n   rtx insn;\n   int max_line = 0;\n@@ -1636,9 +1616,7 @@ final (first, file, optimize, prescan)\n }\n \f\n const char *\n-get_insn_template (code, insn)\n-     int code;\n-     rtx insn;\n+get_insn_template (int code, rtx insn)\n {\n   const void *output = insn_data[code].output;\n   switch (insn_data[code].output_format)\n@@ -1663,9 +1641,7 @@ get_insn_template (code, insn)\n \n    The case fall-through in this function is intentional.  */\n static void\n-output_alternate_entry_point (file, insn)\n-     FILE *file;\n-     rtx insn;\n+output_alternate_entry_point (FILE *file, rtx insn)\n {\n   const char *name = LABEL_NAME (insn);\n \n@@ -1699,12 +1675,8 @@ output_alternate_entry_point (file, insn)\n    used for within delayed branch sequence output).  */\n \n rtx\n-final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n-     rtx insn;\n-     FILE *file;\n-     int optimize ATTRIBUTE_UNUSED;\n-     int prescan;\n-     int nopeepholes ATTRIBUTE_UNUSED;\n+final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n+\t\t int prescan, int nopeepholes ATTRIBUTE_UNUSED)\n {\n #ifdef HAVE_cc0\n   rtx set;\n@@ -2527,8 +2499,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n    based on the NOTE-insn INSN, assumed to be a line number.  */\n \n static bool\n-notice_source_line (insn)\n-     rtx insn;\n+notice_source_line (rtx insn)\n {\n   const char *filename = insn_file (insn);\n   int linenum = insn_line (insn);\n@@ -2548,8 +2519,7 @@ notice_source_line (insn)\n    directly to the desired hard register.  */\n \n void\n-cleanup_subreg_operands (insn)\n-     rtx insn;\n+cleanup_subreg_operands (rtx insn)\n {\n   int i;\n   extract_insn_cached (insn);\n@@ -2583,8 +2553,7 @@ cleanup_subreg_operands (insn)\n    based on the thing it is a subreg of.  */\n \n rtx\n-alter_subreg (xp)\n-     rtx *xp;\n+alter_subreg (rtx *xp)\n {\n   rtx x = *xp;\n   rtx y = SUBREG_REG (x);\n@@ -2616,8 +2585,7 @@ alter_subreg (xp)\n /* Do alter_subreg on all the SUBREGs contained in X.  */\n \n static rtx\n-walk_alter_subreg (xp)\n-     rtx *xp;\n+walk_alter_subreg (rtx *xp)\n {\n   rtx x = *xp;\n   switch (GET_CODE (x))\n@@ -2654,8 +2622,7 @@ walk_alter_subreg (xp)\n    2 means that COND has been altered.  */\n \n static int\n-alter_cond (cond)\n-     rtx cond;\n+alter_cond (rtx cond)\n {\n   int value = 0;\n \n@@ -2814,7 +2781,7 @@ output_operand_lossage (const char *msgid, ...)\n   char *new_message;\n   const char *pfx_str;\n   va_list ap;\n-  \n+\n   va_start (ap, msgid);\n \n   pfx_str = this_is_asm_operands ? _(\"invalid `asm': \") : \"output_operand: \";\n@@ -2837,7 +2804,7 @@ output_operand_lossage (const char *msgid, ...)\n    alternative used.  */\n \n static void\n-output_asm_name ()\n+output_asm_name (void)\n {\n   if (debug_insn)\n     {\n@@ -2862,9 +2829,7 @@ output_asm_name ()\n    corresponds to the address of the object and 0 if to the object.  */\n \n static tree\n-get_mem_expr_from_op (op, paddressp)\n-     rtx op;\n-     int *paddressp;\n+get_mem_expr_from_op (rtx op, int *paddressp)\n {\n   tree expr;\n   int inner_addressp;\n@@ -2905,10 +2870,7 @@ get_mem_expr_from_op (op, paddressp)\n    is the number of operands to write.  */\n \n static void\n-output_asm_operand_names (operands, oporder, nops)\n-     rtx *operands;\n-     int *oporder;\n-     int nops;\n+output_asm_operand_names (rtx *operands, int *oporder, int nops)\n {\n   int wrote = 0;\n   int i;\n@@ -2952,9 +2914,7 @@ output_asm_operand_names (operands, oporder, nops)\n       of the operand, with no other punctuation.  */\n \n void\n-output_asm_insn (template, operands)\n-     const char *template;\n-     rtx *operands;\n+output_asm_insn (const char *template, rtx *operands)\n {\n   const char *p;\n   int c;\n@@ -3160,8 +3120,7 @@ output_asm_insn (template, operands)\n /* Output a LABEL_REF, or a bare CODE_LABEL, as an assembler symbol.  */\n \n void\n-output_asm_label (x)\n-     rtx x;\n+output_asm_label (rtx x)\n {\n   char buf[256];\n \n@@ -3188,9 +3147,7 @@ output_asm_label (x)\n    by PRINT_OPERAND.  */\n \n static void\n-output_operand (x, code)\n-     rtx x;\n-     int code ATTRIBUTE_UNUSED;\n+output_operand (rtx x, int code ATTRIBUTE_UNUSED)\n {\n   if (x && GET_CODE (x) == SUBREG)\n     x = alter_subreg (&x);\n@@ -3209,8 +3166,7 @@ output_operand (x, code)\n    The macro PRINT_OPERAND_ADDRESS exists just to control this function.  */\n \n void\n-output_address (x)\n-     rtx x;\n+output_address (rtx x)\n {\n   walk_alter_subreg (&x);\n   PRINT_OPERAND_ADDRESS (asm_out_file, x);\n@@ -3221,9 +3177,7 @@ output_address (x)\n    that may appear in these expressions.  */\n \n void\n-output_addr_const (file, x)\n-     FILE *file;\n-     rtx x;\n+output_addr_const (FILE *file, rtx x)\n {\n   char buf[256];\n \n@@ -3355,7 +3309,7 @@ asm_fprintf (FILE *file, const char *p, ...)\n   char buf[10];\n   char *q, c;\n   va_list argptr;\n-  \n+\n   va_start (argptr, p);\n \n   buf[0] = '%';\n@@ -3447,7 +3401,7 @@ asm_fprintf (FILE *file, const char *p, ...)\n \t\t*q = 0;\n \t\tfprintf (file, buf, va_arg (argptr, long));\n \t      }\n-\t    \n+\n \t    break;\n \n \t  case 's':\n@@ -3515,9 +3469,7 @@ asm_fprintf (FILE *file, const char *p, ...)\n    and in *SECOND the other.  */\n \n void\n-split_double (value, first, second)\n-     rtx value;\n-     rtx *first, *second;\n+split_double (rtx value, rtx *first, rtx *second)\n {\n   if (GET_CODE (value) == CONST_INT)\n     {\n@@ -3656,7 +3608,7 @@ split_double (value, first, second)\n /* Return nonzero if this function has no function calls.  */\n \n int\n-leaf_function_p ()\n+leaf_function_p (void)\n {\n   rtx insn;\n   rtx link;\n@@ -3699,8 +3651,7 @@ leaf_function_p ()\n    output templates to customary add branch prediction hints.\n  */\n int\n-final_forward_branch_p (insn)\n-     rtx insn;\n+final_forward_branch_p (rtx insn)\n {\n   int insn_id, label_id;\n   if (!uid_shuid)\n@@ -3728,7 +3679,7 @@ final_forward_branch_p (insn)\n    safely renumbered.  */\n \n int\n-only_leaf_regs_used ()\n+only_leaf_regs_used (void)\n {\n   int i;\n   const char *const permitted_reg_in_leaf_functions = LEAF_REGISTERS;\n@@ -3751,8 +3702,7 @@ only_leaf_regs_used ()\n    available in leaf functions.  */\n \n static void\n-leaf_renumber_regs (first)\n-     rtx first;\n+leaf_renumber_regs (rtx first)\n {\n   rtx insn;\n \n@@ -3773,8 +3723,7 @@ leaf_renumber_regs (first)\n    available in leaf functions.  */\n \n void\n-leaf_renumber_regs_insn (in_rtx)\n-     rtx in_rtx;\n+leaf_renumber_regs_insn (rtx in_rtx)\n {\n   int i, j;\n   const char *format_ptr;\n@@ -3872,15 +3821,15 @@ static int symbol_queue_size = 0;\n    the nesting depth goes to 0 is this routine called.  */\n \n void\n-debug_flush_symbol_queue ()\n+debug_flush_symbol_queue (void)\n {\n   int i;\n- \n+\n   /* Make sure that additionally queued items are not flushed\n      prematurely.  */\n-    \n+\n   ++debug_nesting;\n- \n+\n   for (i = 0; i < symbol_queue_index; ++i)\n     {\n       /* If we pushed queued symbols then such symbols are must be\n@@ -3902,29 +3851,29 @@ debug_flush_symbol_queue ()\n     }\n \n   symbol_queue_index = 0;\n-  --debug_nesting;       \n+  --debug_nesting;\n }\n \n /* Queue a type symbol needed as part of the definition of a decl\n    symbol.  These symbols are generated when debug_flush_symbol_queue()\n    is called.  */\n \n-void     \n+void\n debug_queue_symbol (tree decl)\n {\n-  if (symbol_queue_index >= symbol_queue_size)    \n+  if (symbol_queue_index >= symbol_queue_size)\n     {\n       symbol_queue_size += 10;\n       symbol_queue = (tree *) xrealloc (symbol_queue,\n                                         symbol_queue_size * sizeof (tree));\n     }\n \n   symbol_queue[symbol_queue_index++] = decl;\n-}     \n+}\n \n /* Free symbol queue.  */\n void\n-debug_free_queue ()\n+debug_free_queue (void)\n {\n   if (symbol_queue)\n     {"}, {"sha": "de7cc816bfb324d8461898eacb96f4772a3aa257", "filename": "gcc/flags.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf9ac28580beb4c5ae891781250cf5d6744d676/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf9ac28580beb4c5ae891781250cf5d6744d676/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=6cf9ac28580beb4c5ae891781250cf5d6744d676", "patch": "@@ -99,7 +99,7 @@ extern bool warnings_are_errors;\n    set_Wunused() to update the -Wunused-* flags that correspond to the\n    -Wunused option.  */\n \n-extern void set_Wunused PARAMS ((int setting));\n+extern void set_Wunused (int setting);\n \n extern bool warn_unused_function;\n extern bool warn_unused_label;"}, {"sha": "1086a562bd6fa6e73da5565d413f45add951ca41", "filename": "gcc/flow.c", "status": "modified", "additions": 107, "deletions": 220, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf9ac28580beb4c5ae891781250cf5d6744d676/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf9ac28580beb4c5ae891781250cf5d6744d676/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=6cf9ac28580beb4c5ae891781250cf5d6744d676", "patch": "@@ -206,7 +206,7 @@ rtx regs_may_share;\n \n /* Callback that determines if it's ok for a function to have no\n    noreturn attribute.  */\n-int (*lang_missing_noreturn_ok_p) PARAMS ((tree));\n+int (*lang_missing_noreturn_ok_p) (tree);\n \n /* Set of registers that may be eliminable.  These are handled specially\n    in updating regs_ever_live.  */\n@@ -286,64 +286,52 @@ static int ndead;\n #define MAX_MEM_SET_LIST_LEN\t100\n \n /* Forward declarations */\n-static int verify_wide_reg_1\t\tPARAMS ((rtx *, void *));\n-static void verify_wide_reg\t\tPARAMS ((int, basic_block));\n-static void verify_local_live_at_start\tPARAMS ((regset, basic_block));\n-static void notice_stack_pointer_modification_1 PARAMS ((rtx, rtx, void *));\n-static void notice_stack_pointer_modification PARAMS ((rtx));\n-static void mark_reg\t\t\tPARAMS ((rtx, void *));\n-static void mark_regs_live_at_end\tPARAMS ((regset));\n-static int set_phi_alternative_reg      PARAMS ((rtx, int, int, void *));\n-static void calculate_global_regs_live\tPARAMS ((sbitmap, sbitmap, int));\n-static void propagate_block_delete_insn PARAMS ((rtx));\n-static rtx propagate_block_delete_libcall PARAMS ((rtx, rtx));\n-static int insn_dead_p\t\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t rtx, int, rtx));\n-static int libcall_dead_p\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t rtx, rtx));\n-static void mark_set_regs\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t rtx, rtx));\n-static void mark_set_1\t\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t enum rtx_code, rtx, rtx,\n-\t\t\t\t\t\t rtx, int));\n-static int find_regno_partial\t\tPARAMS ((rtx *, void *));\n+static int verify_wide_reg_1 (rtx *, void *);\n+static void verify_wide_reg (int, basic_block);\n+static void verify_local_live_at_start (regset, basic_block);\n+static void notice_stack_pointer_modification_1 (rtx, rtx, void *);\n+static void notice_stack_pointer_modification (rtx);\n+static void mark_reg (rtx, void *);\n+static void mark_regs_live_at_end (regset);\n+static int set_phi_alternative_reg (rtx, int, int, void *);\n+static void calculate_global_regs_live (sbitmap, sbitmap, int);\n+static void propagate_block_delete_insn (rtx);\n+static rtx propagate_block_delete_libcall (rtx, rtx);\n+static int insn_dead_p (struct propagate_block_info *, rtx, int, rtx);\n+static int libcall_dead_p (struct propagate_block_info *, rtx, rtx);\n+static void mark_set_regs (struct propagate_block_info *, rtx, rtx);\n+static void mark_set_1 (struct propagate_block_info *, enum rtx_code, rtx,\n+\t\t\trtx, rtx, int);\n+static int find_regno_partial (rtx *, void *);\n \n #ifdef HAVE_conditional_execution\n-static int mark_regno_cond_dead\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t int, rtx));\n-static void free_reg_cond_life_info\tPARAMS ((splay_tree_value));\n-static int flush_reg_cond_reg_1\t\tPARAMS ((splay_tree_node, void *));\n-static void flush_reg_cond_reg\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t int));\n-static rtx elim_reg_cond\t\tPARAMS ((rtx, unsigned int));\n-static rtx ior_reg_cond\t\t\tPARAMS ((rtx, rtx, int));\n-static rtx not_reg_cond\t\t\tPARAMS ((rtx));\n-static rtx and_reg_cond\t\t\tPARAMS ((rtx, rtx, int));\n+static int mark_regno_cond_dead (struct propagate_block_info *, int, rtx);\n+static void free_reg_cond_life_info (splay_tree_value);\n+static int flush_reg_cond_reg_1 (splay_tree_node, void *);\n+static void flush_reg_cond_reg (struct propagate_block_info *, int);\n+static rtx elim_reg_cond (rtx, unsigned int);\n+static rtx ior_reg_cond (rtx, rtx, int);\n+static rtx not_reg_cond (rtx);\n+static rtx and_reg_cond (rtx, rtx, int);\n #endif\n #ifdef AUTO_INC_DEC\n-static void attempt_auto_inc\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t rtx, rtx, rtx, rtx, rtx));\n-static void find_auto_inc\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t rtx, rtx));\n-static int try_pre_increment_1\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t rtx));\n-static int try_pre_increment\t\tPARAMS ((rtx, rtx, HOST_WIDE_INT));\n+static void attempt_auto_inc (struct propagate_block_info *, rtx, rtx, rtx,\n+\t\t\t      rtx, rtx);\n+static void find_auto_inc (struct propagate_block_info *, rtx, rtx);\n+static int try_pre_increment_1 (struct propagate_block_info *, rtx);\n+static int try_pre_increment (rtx, rtx, HOST_WIDE_INT);\n #endif\n-static void mark_used_reg\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t rtx, rtx, rtx));\n-static void mark_used_regs\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t rtx, rtx, rtx));\n-void debug_flow_info\t\t\tPARAMS ((void));\n-static void add_to_mem_set_list\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t rtx));\n-static int invalidate_mems_from_autoinc PARAMS ((rtx *, void *));\n-static void invalidate_mems_from_set\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t rtx));\n-static void clear_log_links\t\tPARAMS ((sbitmap));\n+static void mark_used_reg (struct propagate_block_info *, rtx, rtx, rtx);\n+static void mark_used_regs (struct propagate_block_info *, rtx, rtx, rtx);\n+void debug_flow_info (void);\n+static void add_to_mem_set_list (struct propagate_block_info *, rtx);\n+static int invalidate_mems_from_autoinc (rtx *, void *);\n+static void invalidate_mems_from_set (struct propagate_block_info *, rtx);\n+static void clear_log_links (sbitmap);\n \f\n \n void\n-check_function_return_warnings ()\n+check_function_return_warnings (void)\n {\n   if (warn_missing_noreturn\n       && !TREE_THIS_VOLATILE (cfun->decl)\n@@ -387,8 +375,7 @@ check_function_return_warnings ()\n    note associated with the BLOCK.  */\n \n rtx\n-first_insn_after_basic_block_note (block)\n-     basic_block block;\n+first_insn_after_basic_block_note (basic_block block)\n {\n   rtx insn;\n \n@@ -410,10 +397,7 @@ first_insn_after_basic_block_note (block)\n    to be used in accumulating flow info.  */\n \n void\n-life_analysis (f, file, flags)\n-     rtx f;\n-     FILE *file;\n-     int flags;\n+life_analysis (rtx f, FILE *file, int flags)\n {\n #ifdef ELIMINABLE_REGS\n   int i;\n@@ -502,9 +486,7 @@ life_analysis (f, file, flags)\n    word_mode.  */\n \n static int\n-verify_wide_reg_1 (px, pregno)\n-     rtx *px;\n-     void *pregno;\n+verify_wide_reg_1 (rtx *px, void *pregno)\n {\n   rtx x = *px;\n   unsigned int regno = *(int *) pregno;\n@@ -522,9 +504,7 @@ verify_wide_reg_1 (px, pregno)\n    of BB looking for register REGNO.  */\n \n static void\n-verify_wide_reg (regno, bb)\n-     int regno;\n-     basic_block bb;\n+verify_wide_reg (int regno, basic_block bb)\n {\n   rtx head = bb->head, end = bb->end;\n \n@@ -555,9 +535,7 @@ verify_wide_reg (regno, bb)\n    changes in live_at_start during a local update.  */\n \n static void\n-verify_local_live_at_start (new_live_at_start, bb)\n-     regset new_live_at_start;\n-     basic_block bb;\n+verify_local_live_at_start (regset new_live_at_start, basic_block bb)\n {\n   if (reload_completed)\n     {\n@@ -622,10 +600,7 @@ verify_local_live_at_start (new_live_at_start, bb)\n    unless the caller resets it to zero.  */\n \n int\n-update_life_info (blocks, extent, prop_flags)\n-     sbitmap blocks;\n-     enum update_life_extent extent;\n-     int prop_flags;\n+update_life_info (sbitmap blocks, enum update_life_extent extent, int prop_flags)\n {\n   regset tmp;\n   regset_head tmp_head;\n@@ -689,7 +664,7 @@ update_life_info (blocks, extent, prop_flags)\n \t     Further improvement may be possible.  */\n \t  cleanup_cfg (CLEANUP_EXPENSIVE);\n \n-\t  /* Zap the life information from the last round.  If we don't \n+\t  /* Zap the life information from the last round.  If we don't\n \t     do this, we can wind up with registers that no longer appear\n \t     in the code being marked live at entry, which twiggs bogus\n \t     warnings from regno_uninitialized.  */\n@@ -775,9 +750,7 @@ update_life_info (blocks, extent, prop_flags)\n /* Update life information in all blocks where BB_DIRTY is set.  */\n \n int\n-update_life_info_in_dirty_blocks (extent, prop_flags)\n-     enum update_life_extent extent;\n-     int prop_flags;\n+update_life_info_in_dirty_blocks (enum update_life_extent extent, int prop_flags)\n {\n   sbitmap update_life_blocks = sbitmap_alloc (last_basic_block);\n   int n = 0;\n@@ -817,8 +790,7 @@ update_life_info_in_dirty_blocks (extent, prop_flags)\n    KEEP_HEAD_END_P is nonzero if basic_block_info is not to be freed.  */\n \n void\n-free_basic_block_vars (keep_head_end_p)\n-     int keep_head_end_p;\n+free_basic_block_vars (int keep_head_end_p)\n {\n   if (! keep_head_end_p)\n     {\n@@ -840,8 +812,7 @@ free_basic_block_vars (keep_head_end_p)\n /* Delete any insns that copy a register to itself.  */\n \n int\n-delete_noop_moves (f)\n-     rtx f ATTRIBUTE_UNUSED;\n+delete_noop_moves (rtx f ATTRIBUTE_UNUSED)\n {\n   rtx insn, next;\n   basic_block bb;\n@@ -886,7 +857,7 @@ delete_noop_moves (f)\n    insns computing the destination, so we delay deleting and garbagecollect\n    them once life information is computed.  */\n void\n-delete_dead_jumptables ()\n+delete_dead_jumptables (void)\n {\n   rtx insn, next;\n   for (insn = get_insns (); insn; insn = next)\n@@ -911,10 +882,8 @@ delete_dead_jumptables ()\n    Only useful before prologues have been emitted.  */\n \n static void\n-notice_stack_pointer_modification_1 (x, pat, data)\n-     rtx x;\n-     rtx pat ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+notice_stack_pointer_modification_1 (rtx x, rtx pat ATTRIBUTE_UNUSED,\n+\t\t\t\t     void *data ATTRIBUTE_UNUSED)\n {\n   if (x == stack_pointer_rtx\n       /* The stack pointer is only modified indirectly as the result\n@@ -927,8 +896,7 @@ notice_stack_pointer_modification_1 (x, pat, data)\n }\n \n static void\n-notice_stack_pointer_modification (f)\n-     rtx f;\n+notice_stack_pointer_modification (rtx f)\n {\n   rtx insn;\n \n@@ -955,9 +923,7 @@ notice_stack_pointer_modification (f)\n    of their component registers set as well.  */\n \n static void\n-mark_reg (reg, xset)\n-     rtx reg;\n-     void *xset;\n+mark_reg (rtx reg, void *xset)\n {\n   regset set = (regset) xset;\n   int regno = REGNO (reg);\n@@ -978,8 +944,7 @@ mark_reg (reg, xset)\n    at the end of the last basic block.  */\n \n static void\n-mark_regs_live_at_end (set)\n-     regset set;\n+mark_regs_live_at_end (regset set)\n {\n   unsigned int i;\n \n@@ -1073,11 +1038,9 @@ mark_regs_live_at_end (set)\n    INSN, in the regset.  */\n \n static int\n-set_phi_alternative_reg (insn, dest_regno, src_regno, data)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     int dest_regno ATTRIBUTE_UNUSED;\n-     int src_regno;\n-     void *data;\n+set_phi_alternative_reg (rtx insn ATTRIBUTE_UNUSED,\n+\t\t\t int dest_regno ATTRIBUTE_UNUSED, int src_regno,\n+\t\t\t void *data)\n {\n   regset live = (regset) data;\n   SET_REGNO_REG_SET (live, src_regno);\n@@ -1091,9 +1054,7 @@ set_phi_alternative_reg (insn, dest_regno, src_regno, data)\n    BLOCKS_OUT is set for every block that was changed.  */\n \n static void\n-calculate_global_regs_live (blocks_in, blocks_out, flags)\n-     sbitmap blocks_in, blocks_out;\n-     int flags;\n+calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n {\n   basic_block *queue, *qhead, *qtail, *qend, bb;\n   regset tmp, new_live_at_end, invalidated_by_call;\n@@ -1405,9 +1366,7 @@ typedef struct {\n    part of an expression which only uses part of the register.  Return\n    it in the structure passed in.  */\n static int\n-find_regno_partial (ptr, data)\n-     rtx *ptr;\n-     void *data;\n+find_regno_partial (rtx *ptr, void *data)\n {\n   find_regno_partial_param *param = (find_regno_partial_param *)data;\n   unsigned reg = param->regno_to_find;\n@@ -1452,7 +1411,7 @@ find_regno_partial (ptr, data)\n    bits we don't want.  */\n \n int\n-initialize_uninitialized_subregs ()\n+initialize_uninitialized_subregs (void)\n {\n   rtx insn;\n   edge e;\n@@ -1507,7 +1466,7 @@ initialize_uninitialized_subregs ()\n    of life analysis.  Not static since used also for stupid life analysis.  */\n \n void\n-allocate_bb_life_data ()\n+allocate_bb_life_data (void)\n {\n   basic_block bb;\n \n@@ -1521,7 +1480,7 @@ allocate_bb_life_data ()\n }\n \n void\n-allocate_reg_life_data ()\n+allocate_reg_life_data (void)\n {\n   int i;\n \n@@ -1548,8 +1507,7 @@ allocate_reg_life_data ()\n /* Delete dead instructions for propagate_block.  */\n \n static void\n-propagate_block_delete_insn (insn)\n-     rtx insn;\n+propagate_block_delete_insn (rtx insn)\n {\n   rtx inote = find_reg_note (insn, REG_LABEL, NULL_RTX);\n \n@@ -1598,8 +1556,7 @@ propagate_block_delete_insn (insn)\n    before the libcall.  */\n \n static rtx\n-propagate_block_delete_libcall ( insn, note)\n-     rtx insn, note;\n+propagate_block_delete_libcall (rtx insn, rtx note)\n {\n   rtx first = XEXP (note, 0);\n   rtx before = PREV_INSN (first);\n@@ -1612,9 +1569,7 @@ propagate_block_delete_libcall ( insn, note)\n /* Update the life-status of regs for one insn.  Return the previous insn.  */\n \n rtx\n-propagate_one_insn (pbi, insn)\n-     struct propagate_block_info *pbi;\n-     rtx insn;\n+propagate_one_insn (struct propagate_block_info *pbi, rtx insn)\n {\n   rtx prev = PREV_INSN (insn);\n   int flags = pbi->flags;\n@@ -1672,16 +1627,16 @@ propagate_one_insn (pbi, insn)\n \t   as a whole is not dead, then we want to remove INSN, but\n \t   not the whole libcall sequence.\n \n-\t   However, we need to also remove the dangling REG_LIBCALL\t\n+\t   However, we need to also remove the dangling REG_LIBCALL\n \t   note so that we do not have mis-matched LIBCALL/RETVAL\n \t   notes.  In theory we could find a new location for the\n-\t   REG_RETVAL note, but it hardly seems worth the effort. \n+\t   REG_RETVAL note, but it hardly seems worth the effort.\n \n \t   NOTE at this point will be the RETVAL note if it exists.  */\n \t  if (note)\n \t    {\n \t      rtx libcall_note;\n-\t \n+\n \t      libcall_note\n \t\t= find_reg_note (XEXP (note, 0), REG_LIBCALL, NULL_RTX);\n \t      remove_note (XEXP (note, 0), libcall_note);\n@@ -1880,10 +1835,8 @@ propagate_one_insn (pbi, insn)\n    the user can use the regsets provided here.  */\n \n struct propagate_block_info *\n-init_propagate_block_info (bb, live, local_set, cond_local_set, flags)\n-     basic_block bb;\n-     regset live, local_set, cond_local_set;\n-     int flags;\n+init_propagate_block_info (basic_block bb, regset live, regset local_set,\n+\t\t\t   regset cond_local_set, int flags)\n {\n   struct propagate_block_info *pbi = xmalloc (sizeof (*pbi));\n \n@@ -2042,8 +1995,7 @@ init_propagate_block_info (bb, live, local_set, cond_local_set, flags)\n /* Release a propagate_block_info struct.  */\n \n void\n-free_propagate_block_info (pbi)\n-     struct propagate_block_info *pbi;\n+free_propagate_block_info (struct propagate_block_info *pbi)\n {\n   free_EXPR_LIST_list (&pbi->mem_set_list);\n \n@@ -2079,12 +2031,8 @@ free_propagate_block_info (pbi)\n    Return nonzero if an INSN is deleted (i.e. by dead code removal).  */\n \n int\n-propagate_block (bb, live, local_set, cond_local_set, flags)\n-     basic_block bb;\n-     regset live;\n-     regset local_set;\n-     regset cond_local_set;\n-     int flags;\n+propagate_block (basic_block bb, regset live, regset local_set,\n+\t\t regset cond_local_set, int flags)\n {\n   struct propagate_block_info *pbi;\n   rtx insn, prev;\n@@ -2136,11 +2084,8 @@ propagate_block (bb, live, local_set, cond_local_set, flags)\n    pertaining to the insn.  */\n \n static int\n-insn_dead_p (pbi, x, call_ok, notes)\n-     struct propagate_block_info *pbi;\n-     rtx x;\n-     int call_ok;\n-     rtx notes ATTRIBUTE_UNUSED;\n+insn_dead_p (struct propagate_block_info *pbi, rtx x, int call_ok,\n+\t     rtx notes ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (x);\n \n@@ -2333,10 +2278,7 @@ insn_dead_p (pbi, x, call_ok, notes)\n    NOTE is the REG_RETVAL note of the insn.  */\n \n static int\n-libcall_dead_p (pbi, note, insn)\n-     struct propagate_block_info *pbi;\n-     rtx note;\n-     rtx insn;\n+libcall_dead_p (struct propagate_block_info *pbi, rtx note, rtx insn)\n {\n   rtx x = single_set (insn);\n \n@@ -2390,8 +2332,7 @@ libcall_dead_p (pbi, note, insn)\n    fixed hard registers.  */\n \n int\n-regno_uninitialized (regno)\n-     unsigned int regno;\n+regno_uninitialized (unsigned int regno)\n {\n   if (n_basic_blocks == 0\n       || (regno < FIRST_PSEUDO_REGISTER\n@@ -2408,8 +2349,7 @@ regno_uninitialized (regno)\n    Such regs may be clobbered by `longjmp'.  */\n \n int\n-regno_clobbered_at_setjmp (regno)\n-     int regno;\n+regno_clobbered_at_setjmp (int regno)\n {\n   if (n_basic_blocks == 0)\n     return 0;\n@@ -2422,9 +2362,7 @@ regno_clobbered_at_setjmp (regno)\n /* Add MEM to PBI->MEM_SET_LIST.  MEM should be canonical.  Respect the\n    maximal list size; look for overlaps in mode and select the largest.  */\n static void\n-add_to_mem_set_list (pbi, mem)\n-     struct propagate_block_info *pbi;\n-     rtx mem;\n+add_to_mem_set_list (struct propagate_block_info *pbi, rtx mem)\n {\n   rtx i;\n \n@@ -2471,9 +2409,7 @@ add_to_mem_set_list (pbi, mem)\n    to an address change.  */\n \n static int\n-invalidate_mems_from_autoinc (px, data)\n-     rtx *px;\n-     void *data;\n+invalidate_mems_from_autoinc (rtx *px, void *data)\n {\n   rtx x = *px;\n   struct propagate_block_info *pbi = data;\n@@ -2490,9 +2426,7 @@ invalidate_mems_from_autoinc (px, data)\n /* EXP is a REG.  Remove any dependent entries from pbi->mem_set_list.  */\n \n static void\n-invalidate_mems_from_set (pbi, exp)\n-     struct propagate_block_info *pbi;\n-     rtx exp;\n+invalidate_mems_from_set (struct propagate_block_info *pbi, rtx exp)\n {\n   rtx temp = pbi->mem_set_list;\n   rtx prev = NULL_RTX;\n@@ -2525,9 +2459,7 @@ invalidate_mems_from_set (pbi, exp)\n    FLAGS is the set of operations to perform.  */\n \n static void\n-mark_set_regs (pbi, x, insn)\n-     struct propagate_block_info *pbi;\n-     rtx x, insn;\n+mark_set_regs (struct propagate_block_info *pbi, rtx x, rtx insn)\n {\n   rtx cond = NULL_RTX;\n   rtx link;\n@@ -2598,11 +2530,7 @@ mark_set_regs (pbi, x, insn)\n    will be the condition.  */\n \n static void\n-mark_set_1 (pbi, code, reg, cond, insn, flags)\n-     struct propagate_block_info *pbi;\n-     enum rtx_code code;\n-     rtx reg, cond, insn;\n-     int flags;\n+mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx cond, rtx insn, int flags)\n {\n   int regno_first = -1, regno_last = -1;\n   unsigned long not_dead = 0;\n@@ -2906,10 +2834,7 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n    Return true if the register is now unconditionally dead.  */\n \n static int\n-mark_regno_cond_dead (pbi, regno, cond)\n-     struct propagate_block_info *pbi;\n-     int regno;\n-     rtx cond;\n+mark_regno_cond_dead (struct propagate_block_info *pbi, int regno, rtx cond)\n {\n   /* If this is a store to a predicate register, the value of the\n      predicate is changing, we don't know that the predicate as seen\n@@ -2992,8 +2917,7 @@ mark_regno_cond_dead (pbi, regno, cond)\n /* Called from splay_tree_delete for pbi->reg_cond_life.  */\n \n static void\n-free_reg_cond_life_info (value)\n-     splay_tree_value value;\n+free_reg_cond_life_info (splay_tree_value value)\n {\n   struct reg_cond_life_info *rcli = (struct reg_cond_life_info *) value;\n   free (rcli);\n@@ -3002,9 +2926,7 @@ free_reg_cond_life_info (value)\n /* Helper function for flush_reg_cond_reg.  */\n \n static int\n-flush_reg_cond_reg_1 (node, data)\n-     splay_tree_node node;\n-     void *data;\n+flush_reg_cond_reg_1 (splay_tree_node node, void *data)\n {\n   struct reg_cond_life_info *rcli;\n   int *xdata = (int *) data;\n@@ -3036,9 +2958,7 @@ flush_reg_cond_reg_1 (node, data)\n /* Flush all (sub) expressions referring to REGNO from REG_COND_LIVE.  */\n \n static void\n-flush_reg_cond_reg (pbi, regno)\n-     struct propagate_block_info *pbi;\n-     int regno;\n+flush_reg_cond_reg (struct propagate_block_info *pbi, int regno)\n {\n   int pair[2];\n \n@@ -3061,9 +2981,7 @@ flush_reg_cond_reg (pbi, regno)\n    ADD.  */\n \n static rtx\n-ior_reg_cond (old, x, add)\n-     rtx old, x;\n-     int add;\n+ior_reg_cond (rtx old, rtx x, int add)\n {\n   rtx op0, op1;\n \n@@ -3151,8 +3069,7 @@ ior_reg_cond (old, x, add)\n }\n \n static rtx\n-not_reg_cond (x)\n-     rtx x;\n+not_reg_cond (rtx x)\n {\n   enum rtx_code x_code;\n \n@@ -3176,9 +3093,7 @@ not_reg_cond (x)\n }\n \n static rtx\n-and_reg_cond (old, x, add)\n-     rtx old, x;\n-     int add;\n+and_reg_cond (rtx old, rtx x, int add)\n {\n   rtx op0, op1;\n \n@@ -3271,9 +3186,7 @@ and_reg_cond (old, x, add)\n    is used when the value of REGNO changes.  */\n \n static rtx\n-elim_reg_cond (x, regno)\n-     rtx x;\n-     unsigned int regno;\n+elim_reg_cond (rtx x, unsigned int regno)\n {\n   rtx op0, op1;\n \n@@ -3337,9 +3250,8 @@ elim_reg_cond (x, regno)\n    else.  */\n \n static void\n-attempt_auto_inc (pbi, inc, insn, mem, incr, incr_reg)\n-     struct propagate_block_info *pbi;\n-     rtx inc, insn, mem, incr, incr_reg;\n+attempt_auto_inc (struct propagate_block_info *pbi, rtx inc, rtx insn,\n+\t\t  rtx mem, rtx incr, rtx incr_reg)\n {\n   int regno = REGNO (incr_reg);\n   rtx set = single_set (incr);\n@@ -3481,10 +3393,7 @@ attempt_auto_inc (pbi, inc, insn, mem, incr, incr_reg)\n    reference.  */\n \n static void\n-find_auto_inc (pbi, x, insn)\n-     struct propagate_block_info *pbi;\n-     rtx x;\n-     rtx insn;\n+find_auto_inc (struct propagate_block_info *pbi, rtx x, rtx insn)\n {\n   rtx addr = XEXP (x, 0);\n   HOST_WIDE_INT offset = 0;\n@@ -3573,11 +3482,8 @@ find_auto_inc (pbi, x, insn)\n #endif /* AUTO_INC_DEC */\n \f\n static void\n-mark_used_reg (pbi, reg, cond, insn)\n-     struct propagate_block_info *pbi;\n-     rtx reg;\n-     rtx cond ATTRIBUTE_UNUSED;\n-     rtx insn;\n+mark_used_reg (struct propagate_block_info *pbi, rtx reg,\n+\t       rtx cond ATTRIBUTE_UNUSED, rtx insn)\n {\n   unsigned int regno_first, regno_last, i;\n   int some_was_live, some_was_dead, some_not_set;\n@@ -3765,9 +3671,7 @@ mark_used_reg (pbi, reg, cond, insn)\n    is not called.  */\n \n static void\n-mark_used_regs (pbi, x, cond, insn)\n-     struct propagate_block_info *pbi;\n-     rtx x, cond, insn;\n+mark_used_regs (struct propagate_block_info *pbi, rtx x, rtx cond, rtx insn)\n {\n   RTX_CODE code;\n   int regno;\n@@ -4046,9 +3950,7 @@ mark_used_regs (pbi, x, cond, insn)\n #ifdef AUTO_INC_DEC\n \n static int\n-try_pre_increment_1 (pbi, insn)\n-     struct propagate_block_info *pbi;\n-     rtx insn;\n+try_pre_increment_1 (struct propagate_block_info *pbi, rtx insn)\n {\n   /* Find the next use of this reg.  If in same basic block,\n      make it do pre-increment or pre-decrement if appropriate.  */\n@@ -4094,9 +3996,7 @@ try_pre_increment_1 (pbi, insn)\n    This checks all about the validity of the result of modifying INSN.  */\n \n static int\n-try_pre_increment (insn, reg, amount)\n-     rtx insn, reg;\n-     HOST_WIDE_INT amount;\n+try_pre_increment (rtx insn, rtx reg, HOST_WIDE_INT amount)\n {\n   rtx use;\n \n@@ -4174,10 +4074,7 @@ try_pre_increment (insn, reg, amount)\n    return (rtx) 1.  */\n \n rtx\n-find_use_as_address (x, reg, plusconst)\n-     rtx x;\n-     rtx reg;\n-     HOST_WIDE_INT plusconst;\n+find_use_as_address (rtx x, rtx reg, HOST_WIDE_INT plusconst)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char * const fmt = GET_RTX_FORMAT (code);\n@@ -4236,9 +4133,7 @@ find_use_as_address (x, reg, plusconst)\n    This is part of making a debugging dump.  */\n \n void\n-dump_regset (r, outf)\n-     regset r;\n-     FILE *outf;\n+dump_regset (regset r, FILE *outf)\n {\n   int i;\n   if (r == NULL)\n@@ -4261,8 +4156,7 @@ dump_regset (r, outf)\n    debugger.  */\n \n void\n-debug_regset (r)\n-     regset r;\n+debug_regset (regset r)\n {\n   dump_regset (r, stderr);\n   putc ('\\n', stderr);\n@@ -4288,9 +4182,7 @@ debug_regset (r)\n    possibly other information which is used by the register allocators.  */\n \n void\n-recompute_reg_usage (f, loop_step)\n-     rtx f ATTRIBUTE_UNUSED;\n-     int loop_step ATTRIBUTE_UNUSED;\n+recompute_reg_usage (rtx f ATTRIBUTE_UNUSED, int loop_step ATTRIBUTE_UNUSED)\n {\n   allocate_reg_life_data ();\n   update_life_info (NULL, UPDATE_LIFE_LOCAL, PROP_REG_INFO);\n@@ -4301,9 +4193,7 @@ recompute_reg_usage (f, loop_step)\n    of the number of registers that died.  */\n \n int\n-count_or_remove_death_notes (blocks, kill)\n-     sbitmap blocks;\n-     int kill;\n+count_or_remove_death_notes (sbitmap blocks, int kill)\n {\n   int count = 0;\n   basic_block bb;\n@@ -4369,8 +4259,7 @@ count_or_remove_death_notes (blocks, kill)\n    if blocks is NULL.  */\n \n static void\n-clear_log_links (blocks)\n-     sbitmap blocks;\n+clear_log_links (sbitmap blocks)\n {\n   rtx insn;\n   int i;\n@@ -4399,9 +4288,7 @@ clear_log_links (blocks)\n    with moving single words, but probably isn't worth the trouble.  */\n \n void\n-reg_set_to_hard_reg_set (to, from)\n-     HARD_REG_SET *to;\n-     bitmap from;\n+reg_set_to_hard_reg_set (HARD_REG_SET *to, bitmap from)\n {\n   int i;\n "}]}