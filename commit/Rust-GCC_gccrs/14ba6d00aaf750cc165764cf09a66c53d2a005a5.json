{"sha": "14ba6d00aaf750cc165764cf09a66c53d2a005a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRiYTZkMDBhYWY3NTBjYzE2NTc2NGNmMDlhNjZjNTNkMmEwMDVhNQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-06-14T13:03:45Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-06-14T13:03:45Z"}, "message": "slist: Trivial formatting fixes.\n\n2004-06-14  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/ext/slist: Trivial formatting fixes.\n\nFrom-SVN: r83098", "tree": {"sha": "01327b5b11bf659e9ce9c110c88d98d55a85e3b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01327b5b11bf659e9ce9c110c88d98d55a85e3b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14ba6d00aaf750cc165764cf09a66c53d2a005a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14ba6d00aaf750cc165764cf09a66c53d2a005a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14ba6d00aaf750cc165764cf09a66c53d2a005a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14ba6d00aaf750cc165764cf09a66c53d2a005a5/comments", "author": null, "committer": null, "parents": [{"sha": "63694b5ed20fd7c3bb05d1e42fc9d6e96770dbfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63694b5ed20fd7c3bb05d1e42fc9d6e96770dbfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63694b5ed20fd7c3bb05d1e42fc9d6e96770dbfc"}], "stats": {"total": 1739, "additions": 955, "deletions": 784}, "files": [{"sha": "adad6683d4dd4a7a7b88a2bb5ecff64fe0fdf1b0", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14ba6d00aaf750cc165764cf09a66c53d2a005a5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14ba6d00aaf750cc165764cf09a66c53d2a005a5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=14ba6d00aaf750cc165764cf09a66c53d2a005a5", "patch": "@@ -1,3 +1,7 @@\n+2004-06-14  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/ext/slist: Trivial formatting fixes.\n+\n 2004-06-14  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/locale_facets.tcc (time_get<>::_M_extract_name):"}, {"sha": "945a503e00e36b83fd62d6f67260e35bcbb012b0", "filename": "libstdc++-v3/include/ext/slist", "status": "modified", "additions": 951, "deletions": 784, "changes": 1735, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14ba6d00aaf750cc165764cf09a66c53d2a005a5/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14ba6d00aaf750cc165764cf09a66c53d2a005a5/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist?ref=14ba6d00aaf750cc165764cf09a66c53d2a005a5", "patch": "@@ -1,6 +1,6 @@\n // Singly-linked list implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -58,849 +58,1016 @@\n \n namespace __gnu_cxx\n {\n-using std::size_t;\n-using std::ptrdiff_t;\n-using std::_Construct;\n-using std::_Destroy;\n-using std::allocator;\n+  using std::size_t;\n+  using std::ptrdiff_t;\n+  using std::_Construct;\n+  using std::_Destroy;\n+  using std::allocator;\n \n-struct _Slist_node_base\n-{\n-  _Slist_node_base* _M_next;\n-};\n-\n-inline _Slist_node_base*\n-__slist_make_link(_Slist_node_base* __prev_node,\n-                  _Slist_node_base* __new_node)\n-{\n-  __new_node->_M_next = __prev_node->_M_next;\n-  __prev_node->_M_next = __new_node;\n-  return __new_node;\n-}\n-\n-inline _Slist_node_base*\n-__slist_previous(_Slist_node_base* __head,\n-                 const _Slist_node_base* __node)\n-{\n-  while (__head && __head->_M_next != __node)\n-    __head = __head->_M_next;\n-  return __head;\n-}\n-\n-inline const _Slist_node_base*\n-__slist_previous(const _Slist_node_base* __head,\n-                 const _Slist_node_base* __node)\n-{\n-  while (__head && __head->_M_next != __node)\n-    __head = __head->_M_next;\n-  return __head;\n-}\n-\n-inline void __slist_splice_after(_Slist_node_base* __pos,\n-                                 _Slist_node_base* __before_first,\n-                                 _Slist_node_base* __before_last)\n-{\n-  if (__pos != __before_first && __pos != __before_last) {\n-    _Slist_node_base* __first = __before_first->_M_next;\n-    _Slist_node_base* __after = __pos->_M_next;\n-    __before_first->_M_next = __before_last->_M_next;\n-    __pos->_M_next = __first;\n-    __before_last->_M_next = __after;\n-  }\n-}\n-\n-inline void\n-__slist_splice_after(_Slist_node_base* __pos, _Slist_node_base* __head)\n-{\n-  _Slist_node_base* __before_last = __slist_previous(__head, 0);\n-  if (__before_last != __head) {\n-    _Slist_node_base* __after = __pos->_M_next;\n-    __pos->_M_next = __head->_M_next;\n-    __head->_M_next = 0;\n-    __before_last->_M_next = __after;\n-  }\n-}\n-\n-inline _Slist_node_base* __slist_reverse(_Slist_node_base* __node)\n-{\n-  _Slist_node_base* __result = __node;\n-  __node = __node->_M_next;\n-  __result->_M_next = 0;\n-  while(__node) {\n-    _Slist_node_base* __next = __node->_M_next;\n-    __node->_M_next = __result;\n-    __result = __node;\n-    __node = __next;\n-  }\n-  return __result;\n-}\n-\n-inline size_t __slist_size(_Slist_node_base* __node)\n-{\n-  size_t __result = 0;\n-  for ( ; __node != 0; __node = __node->_M_next)\n-    ++__result;\n-  return __result;\n-}\n-\n-template <class _Tp>\n-struct _Slist_node : public _Slist_node_base\n-{\n-  _Tp _M_data;\n-};\n-\n-struct _Slist_iterator_base\n-{\n-  typedef size_t                    size_type;\n-  typedef ptrdiff_t                 difference_type;\n-  typedef std::forward_iterator_tag iterator_category;\n-\n-  _Slist_node_base* _M_node;\n-\n-  _Slist_iterator_base(_Slist_node_base* __x) : _M_node(__x) {}\n-  void _M_incr() { _M_node = _M_node->_M_next; }\n-\n-  bool operator==(const _Slist_iterator_base& __x) const {\n-    return _M_node == __x._M_node;\n-  }\n-  bool operator!=(const _Slist_iterator_base& __x) const {\n-    return _M_node != __x._M_node;\n-  }\n-};\n-\n-template <class _Tp, class _Ref, class _Ptr>\n-struct _Slist_iterator : public _Slist_iterator_base\n-{\n-  typedef _Slist_iterator<_Tp, _Tp&, _Tp*>             iterator;\n-  typedef _Slist_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n-  typedef _Slist_iterator<_Tp, _Ref, _Ptr>             _Self;\n-\n-  typedef _Tp              value_type;\n-  typedef _Ptr             pointer;\n-  typedef _Ref             reference;\n-  typedef _Slist_node<_Tp> _Node;\n-\n-  _Slist_iterator(_Node* __x) : _Slist_iterator_base(__x) {}\n-  _Slist_iterator() : _Slist_iterator_base(0) {}\n-  _Slist_iterator(const iterator& __x) : _Slist_iterator_base(__x._M_node) {}\n-\n-  reference operator*() const { return ((_Node*) _M_node)->_M_data; }\n-  pointer operator->() const { return &(operator*()); }\n-\n-  _Self& operator++()\n+  struct _Slist_node_base\n   {\n-    _M_incr();\n-    return *this;\n-  }\n-  _Self operator++(int)\n+    _Slist_node_base* _M_next;\n+  };\n+  \n+  inline _Slist_node_base*\n+  __slist_make_link(_Slist_node_base* __prev_node,\n+\t\t    _Slist_node_base* __new_node)\n   {\n-    _Self __tmp = *this;\n-    _M_incr();\n-    return __tmp;\n+    __new_node->_M_next = __prev_node->_M_next;\n+    __prev_node->_M_next = __new_node;\n+    return __new_node;\n   }\n-};\n \n-template <class _Tp, class _Alloc>\n-struct _Slist_base\n-  : public _Alloc::template rebind<_Slist_node<_Tp> >::other\n-{\n-  typedef typename _Alloc::template rebind<_Slist_node<_Tp> >::other _Node_alloc;\n-  typedef _Alloc allocator_type;\n-  allocator_type get_allocator() const {\n-    return *static_cast<const _Node_alloc*>(this);\n+  inline _Slist_node_base*\n+  __slist_previous(_Slist_node_base* __head,\n+\t\t   const _Slist_node_base* __node)\n+  {\n+    while (__head && __head->_M_next != __node)\n+      __head = __head->_M_next;\n+    return __head;\n   }\n \n-  _Slist_base(const allocator_type& __a)\n-    : _Node_alloc(__a) { this->_M_head._M_next = 0; }\n-  ~_Slist_base() { _M_erase_after(&this->_M_head, 0); }\n-\n-protected:\n-  _Slist_node_base _M_head;\n-\n-  _Slist_node<_Tp>* _M_get_node() { return _Node_alloc::allocate(1); }\n-  void _M_put_node(_Slist_node<_Tp>* __p) { _Node_alloc::deallocate(__p, 1); }\n-\n-protected:\n-  _Slist_node_base* _M_erase_after(_Slist_node_base* __pos)\n+  inline const _Slist_node_base*\n+  __slist_previous(const _Slist_node_base* __head,\n+\t\t   const _Slist_node_base* __node)\n   {\n-    _Slist_node<_Tp>* __next = (_Slist_node<_Tp>*) (__pos->_M_next);\n-    _Slist_node_base* __next_next = __next->_M_next;\n-    __pos->_M_next = __next_next;\n-    _Destroy(&__next->_M_data);\n-    _M_put_node(__next);\n-    return __next_next;\n+    while (__head && __head->_M_next != __node)\n+      __head = __head->_M_next;\n+    return __head;\n   }\n-  _Slist_node_base* _M_erase_after(_Slist_node_base*, _Slist_node_base*);\n-};\n \n-template <class _Tp, class _Alloc>\n-_Slist_node_base*\n-_Slist_base<_Tp,_Alloc>::_M_erase_after(_Slist_node_base* __before_first,\n-                                        _Slist_node_base* __last_node) {\n-  _Slist_node<_Tp>* __cur = (_Slist_node<_Tp>*) (__before_first->_M_next);\n-  while (__cur != __last_node) {\n-    _Slist_node<_Tp>* __tmp = __cur;\n-    __cur = (_Slist_node<_Tp>*) __cur->_M_next;\n-    _Destroy(&__tmp->_M_data);\n-    _M_put_node(__tmp);\n-  }\n-  __before_first->_M_next = __last_node;\n-  return __last_node;\n-}\n-\n-/**\n- *  This is an SGI extension.\n- *  @ingroup SGIextensions\n- *  @doctodo\n-*/\n-template <class _Tp, class _Alloc = allocator<_Tp> >\n-class slist : private _Slist_base<_Tp,_Alloc>\n-{\n-  // concept requirements\n-  __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-\n-private:\n-  typedef _Slist_base<_Tp,_Alloc> _Base;\n-public:\n-  typedef _Tp               value_type;\n-  typedef value_type*       pointer;\n-  typedef const value_type* const_pointer;\n-  typedef value_type&       reference;\n-  typedef const value_type& const_reference;\n-  typedef size_t            size_type;\n-  typedef ptrdiff_t         difference_type;\n-\n-  typedef _Slist_iterator<_Tp, _Tp&, _Tp*>             iterator;\n-  typedef _Slist_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n-\n-  typedef typename _Base::allocator_type allocator_type;\n-  allocator_type get_allocator() const { return _Base::get_allocator(); }\n-\n-private:\n-  typedef _Slist_node<_Tp>      _Node;\n-  typedef _Slist_node_base      _Node_base;\n-  typedef _Slist_iterator_base  _Iterator_base;\n-\n-  _Node* _M_create_node(const value_type& __x) {\n-    _Node* __node = this->_M_get_node();\n-    try {\n-      _Construct(&__node->_M_data, __x);\n-      __node->_M_next = 0;\n-    }\n-    catch(...)\n+  inline void\n+  __slist_splice_after(_Slist_node_base* __pos,\n+\t\t       _Slist_node_base* __before_first,\n+\t\t       _Slist_node_base* __before_last)\n+  {\n+    if (__pos != __before_first && __pos != __before_last)\n       {\n-\tthis->_M_put_node(__node);\n-\t__throw_exception_again;\n+\t_Slist_node_base* __first = __before_first->_M_next;\n+\t_Slist_node_base* __after = __pos->_M_next;\n+\t__before_first->_M_next = __before_last->_M_next;\n+\t__pos->_M_next = __first;\n+\t__before_last->_M_next = __after;\n       }\n-    return __node;\n   }\n \n-  _Node* _M_create_node() {\n-    _Node* __node = this->_M_get_node();\n-    try {\n-      _Construct(&__node->_M_data);\n-      __node->_M_next = 0;\n-    }\n-    catch(...)\n+  inline void\n+  __slist_splice_after(_Slist_node_base* __pos, _Slist_node_base* __head)\n+  {\n+    _Slist_node_base* __before_last = __slist_previous(__head, 0);\n+    if (__before_last != __head)\n       {\n-\tthis->_M_put_node(__node);\n-\t__throw_exception_again;\n+\t_Slist_node_base* __after = __pos->_M_next;\n+\t__pos->_M_next = __head->_M_next;\n+\t__head->_M_next = 0;\n+\t__before_last->_M_next = __after;\n       }\n-    return __node;\n-  }\n-\n-public:\n-  explicit slist(const allocator_type& __a = allocator_type()) : _Base(__a) {}\n-\n-  slist(size_type __n, const value_type& __x,\n-        const allocator_type& __a =  allocator_type()) : _Base(__a)\n-    { _M_insert_after_fill(&this->_M_head, __n, __x); }\n-\n-  explicit slist(size_type __n) : _Base(allocator_type())\n-    { _M_insert_after_fill(&this->_M_head, __n, value_type()); }\n-\n-  // We don't need any dispatching tricks here, because _M_insert_after_range\n-  // already does them.\n-  template <class _InputIterator>\n-  slist(_InputIterator __first, _InputIterator __last,\n-        const allocator_type& __a =  allocator_type()) : _Base(__a)\n-    { _M_insert_after_range(&this->_M_head, __first, __last); }\n-\n-  slist(const slist& __x) : _Base(__x.get_allocator())\n-    { _M_insert_after_range(&this->_M_head, __x.begin(), __x.end()); }\n-\n-  slist& operator= (const slist& __x);\n-\n-  ~slist() {}\n-\n-public:\n-  // assign(), a generalized assignment member function.  Two\n-  // versions: one that takes a count, and one that takes a range.\n-  // The range version is a member template, so we dispatch on whether\n-  // or not the type is an integer.\n-\n-  void assign(size_type __n, const _Tp& __val)\n-    { _M_fill_assign(__n, __val); }\n-\n-  void _M_fill_assign(size_type __n, const _Tp& __val);\n-\n-  template <class _InputIterator>\n-  void assign(_InputIterator __first, _InputIterator __last) {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_assign_dispatch(__first, __last, _Integral());\n-  }\n-\n-  template <class _Integer>\n-  void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-    { _M_fill_assign((size_type) __n, (_Tp) __val); }\n-\n-  template <class _InputIterator>\n-  void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n-                          __false_type);\n-\n-public:\n-\n-  iterator begin() { return iterator((_Node*)this->_M_head._M_next); }\n-  const_iterator begin() const\n-    { return const_iterator((_Node*)this->_M_head._M_next);}\n-\n-  iterator end() { return iterator(0); }\n-  const_iterator end() const { return const_iterator(0); }\n-\n-  // Experimental new feature: before_begin() returns a\n-  // non-dereferenceable iterator that, when incremented, yields\n-  // begin().  This iterator may be used as the argument to\n-  // insert_after, erase_after, etc.  Note that even for an empty\n-  // slist, before_begin() is not the same iterator as end().  It\n-  // is always necessary to increment before_begin() at least once to\n-  // obtain end().\n-  iterator before_begin() { return iterator((_Node*) &this->_M_head); }\n-  const_iterator before_begin() const\n-    { return const_iterator((_Node*) &this->_M_head); }\n-\n-  size_type size() const { return __slist_size(this->_M_head._M_next); }\n-\n-  size_type max_size() const { return size_type(-1); }\n-\n-  bool empty() const { return this->_M_head._M_next == 0; }\n-\n-  void swap(slist& __x)\n-    { std::swap(this->_M_head._M_next, __x._M_head._M_next); }\n-\n-public:\n-\n-  reference front() { return ((_Node*) this->_M_head._M_next)->_M_data; }\n-  const_reference front() const\n-    { return ((_Node*) this->_M_head._M_next)->_M_data; }\n-  void push_front(const value_type& __x)   {\n-    __slist_make_link(&this->_M_head, _M_create_node(__x));\n-  }\n-  void push_front() { __slist_make_link(&this->_M_head, _M_create_node()); }\n-  void pop_front() {\n-    _Node* __node = (_Node*) this->_M_head._M_next;\n-    this->_M_head._M_next = __node->_M_next;\n-    _Destroy(&__node->_M_data);\n-    this->_M_put_node(__node);\n-  }\n-\n-  iterator previous(const_iterator __pos) {\n-    return iterator((_Node*) __slist_previous(&this->_M_head, __pos._M_node));\n-  }\n-  const_iterator previous(const_iterator __pos) const {\n-    return const_iterator((_Node*) __slist_previous(&this->_M_head,\n-                                                    __pos._M_node));\n-  }\n-\n-private:\n-  _Node* _M_insert_after(_Node_base* __pos, const value_type& __x) {\n-    return (_Node*) (__slist_make_link(__pos, _M_create_node(__x)));\n-  }\n-\n-  _Node* _M_insert_after(_Node_base* __pos) {\n-    return (_Node*) (__slist_make_link(__pos, _M_create_node()));\n-  }\n-\n-  void _M_insert_after_fill(_Node_base* __pos,\n-                            size_type __n, const value_type& __x) {\n-    for (size_type __i = 0; __i < __n; ++__i)\n-      __pos = __slist_make_link(__pos, _M_create_node(__x));\n-  }\n-\n-  // Check whether it's an integral type.  If so, it's not an iterator.\n-  template <class _InIterator>\n-  void _M_insert_after_range(_Node_base* __pos,\n-                             _InIterator __first, _InIterator __last) {\n-    typedef typename _Is_integer<_InIterator>::_Integral _Integral;\n-    _M_insert_after_range(__pos, __first, __last, _Integral());\n-  }\n-\n-  template <class _Integer>\n-  void _M_insert_after_range(_Node_base* __pos, _Integer __n, _Integer __x,\n-                             __true_type) {\n-    _M_insert_after_fill(__pos, __n, __x);\n-  }\n-\n-  template <class _InIterator>\n-  void _M_insert_after_range(_Node_base* __pos,\n-                             _InIterator __first, _InIterator __last,\n-                             __false_type) {\n-    while (__first != __last) {\n-      __pos = __slist_make_link(__pos, _M_create_node(*__first));\n-      ++__first;\n-    }\n-  }\n-\n-public:\n-\n-  iterator insert_after(iterator __pos, const value_type& __x) {\n-    return iterator(_M_insert_after(__pos._M_node, __x));\n-  }\n-\n-  iterator insert_after(iterator __pos) {\n-    return insert_after(__pos, value_type());\n-  }\n-\n-  void insert_after(iterator __pos, size_type __n, const value_type& __x) {\n-    _M_insert_after_fill(__pos._M_node, __n, __x);\n-  }\n-\n-  // We don't need any dispatching tricks here, because _M_insert_after_range\n-  // already does them.\n-  template <class _InIterator>\n-  void insert_after(iterator __pos, _InIterator __first, _InIterator __last) {\n-    _M_insert_after_range(__pos._M_node, __first, __last);\n-  }\n-\n-  iterator insert(iterator __pos, const value_type& __x) {\n-    return iterator(_M_insert_after(__slist_previous(&this->_M_head,\n-                                                     __pos._M_node),\n-                    __x));\n-  }\n-\n-  iterator insert(iterator __pos) {\n-    return iterator(_M_insert_after(__slist_previous(&this->_M_head,\n-                                                     __pos._M_node),\n-                                    value_type()));\n   }\n \n-  void insert(iterator __pos, size_type __n, const value_type& __x) {\n-    _M_insert_after_fill(__slist_previous(&this->_M_head, __pos._M_node),\n-                         __n, __x);\n-  }\n-\n-  // We don't need any dispatching tricks here, because _M_insert_after_range\n-  // already does them.\n-  template <class _InIterator>\n-  void insert(iterator __pos, _InIterator __first, _InIterator __last) {\n-    _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node),\n-                          __first, __last);\n-  }\n-\n-public:\n-  iterator erase_after(iterator __pos) {\n-    return iterator((_Node*) this->_M_erase_after(__pos._M_node));\n-  }\n-  iterator erase_after(iterator __before_first, iterator __last) {\n-    return iterator((_Node*) this->_M_erase_after(__before_first._M_node,\n-                                                  __last._M_node));\n+  inline _Slist_node_base*\n+  __slist_reverse(_Slist_node_base* __node)\n+  {\n+    _Slist_node_base* __result = __node;\n+    __node = __node->_M_next;\n+    __result->_M_next = 0;\n+    while(__node)\n+      {\n+\t_Slist_node_base* __next = __node->_M_next;\n+\t__node->_M_next = __result;\n+\t__result = __node;\n+\t__node = __next;\n+      }\n+    return __result;\n   }\n \n-  iterator erase(iterator __pos) {\n-    return (_Node*) this->_M_erase_after(__slist_previous(&this->_M_head,\n-                                                          __pos._M_node));\n-  }\n-  iterator erase(iterator __first, iterator __last) {\n-    return (_Node*) this->_M_erase_after(\n-      __slist_previous(&this->_M_head, __first._M_node), __last._M_node);\n+  inline size_t\n+  __slist_size(_Slist_node_base* __node)\n+  {\n+    size_t __result = 0;\n+    for (; __node != 0; __node = __node->_M_next)\n+      ++__result;\n+    return __result;\n   }\n \n-  void resize(size_type new_size, const _Tp& __x);\n-  void resize(size_type new_size) { resize(new_size, _Tp()); }\n-  void clear() { this->_M_erase_after(&this->_M_head, 0); }\n+  template <class _Tp>\n+    struct _Slist_node : public _Slist_node_base\n+    {\n+      _Tp _M_data;\n+    };\n \n-public:\n-  // Moves the range [__before_first + 1, __before_last + 1) to *this,\n-  //  inserting it immediately after __pos.  This is constant time.\n-  void splice_after(iterator __pos,\n-                    iterator __before_first, iterator __before_last)\n+  struct _Slist_iterator_base\n   {\n-    if (__before_first != __before_last)\n-      __slist_splice_after(__pos._M_node, __before_first._M_node,\n-                           __before_last._M_node);\n-  }\n+    typedef size_t                    size_type;\n+    typedef ptrdiff_t                 difference_type;\n+    typedef std::forward_iterator_tag iterator_category;\n+\n+    _Slist_node_base* _M_node;\n+    \n+    _Slist_iterator_base(_Slist_node_base* __x)\n+    : _M_node(__x) {}\n+\n+    void\n+    _M_incr()\n+    { _M_node = _M_node->_M_next; }\n+\n+    bool\n+    operator==(const _Slist_iterator_base& __x) const\n+    { return _M_node == __x._M_node; }\n+\n+    bool\n+    operator!=(const _Slist_iterator_base& __x) const\n+    { return _M_node != __x._M_node; }\n+  };\n+\n+  template <class _Tp, class _Ref, class _Ptr>\n+    struct _Slist_iterator : public _Slist_iterator_base\n+    {\n+      typedef _Slist_iterator<_Tp, _Tp&, _Tp*>             iterator;\n+      typedef _Slist_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n+      typedef _Slist_iterator<_Tp, _Ref, _Ptr>             _Self;\n+\n+      typedef _Tp              value_type;\n+      typedef _Ptr             pointer;\n+      typedef _Ref             reference;\n+      typedef _Slist_node<_Tp> _Node;\n+\n+      _Slist_iterator(_Node* __x)\n+      : _Slist_iterator_base(__x) {}\n+\n+      _Slist_iterator()\n+      : _Slist_iterator_base(0) {}\n+\n+      _Slist_iterator(const iterator& __x)\n+      : _Slist_iterator_base(__x._M_node) {}\n+\n+      reference\n+      operator*() const\n+      { return ((_Node*) _M_node)->_M_data; }\n+\n+      pointer\n+      operator->() const\n+      { return &(operator*()); }\n+\n+      _Self&\n+      operator++()\n+      {\n+\t_M_incr();\n+\treturn *this;\n+      }\n \n-  // Moves the element that follows __prev to *this, inserting it immediately\n-  //  after __pos.  This is constant time.\n-  void splice_after(iterator __pos, iterator __prev)\n-  {\n-    __slist_splice_after(__pos._M_node,\n-                         __prev._M_node, __prev._M_node->_M_next);\n-  }\n+      _Self\n+      operator++(int)\n+      {\n+\t_Self __tmp = *this;\n+\t_M_incr();\n+\treturn __tmp;\n+      }\n+    };\n+\n+  template <class _Tp, class _Alloc>\n+    struct _Slist_base\n+    : public _Alloc::template rebind<_Slist_node<_Tp> >::other\n+    {\n+      typedef typename _Alloc::template rebind<_Slist_node<_Tp> >::other\n+        _Node_alloc;\n+      typedef _Alloc allocator_type;\n+\n+      allocator_type\n+      get_allocator() const\n+      { return *static_cast<const _Node_alloc*>(this); }\n+\n+      _Slist_base(const allocator_type& __a)\n+      : _Node_alloc(__a)\n+      { this->_M_head._M_next = 0; }\n+\n+      ~_Slist_base()\n+      { _M_erase_after(&this->_M_head, 0); }\n+\n+    protected:\n+      _Slist_node_base _M_head;\n+\n+      _Slist_node<_Tp>*\n+      _M_get_node()\n+      { return _Node_alloc::allocate(1); }\n+  \n+      void\n+      _M_put_node(_Slist_node<_Tp>* __p)\n+      { _Node_alloc::deallocate(__p, 1); }\n+\n+    protected:\n+      _Slist_node_base* _M_erase_after(_Slist_node_base* __pos)\n+      {\n+\t_Slist_node<_Tp>* __next = (_Slist_node<_Tp>*) (__pos->_M_next);\n+\t_Slist_node_base* __next_next = __next->_M_next;\n+\t__pos->_M_next = __next_next;\n+\t_Destroy(&__next->_M_data);\n+\t_M_put_node(__next);\n+\treturn __next_next;\n+      }\n+      _Slist_node_base* _M_erase_after(_Slist_node_base*, _Slist_node_base*);\n+    };\n+\n+  template <class _Tp, class _Alloc>\n+    _Slist_node_base*\n+    _Slist_base<_Tp,_Alloc>::_M_erase_after(_Slist_node_base* __before_first,\n+\t\t\t\t\t    _Slist_node_base* __last_node)\n+    {\n+      _Slist_node<_Tp>* __cur = (_Slist_node<_Tp>*) (__before_first->_M_next);\n+      while (__cur != __last_node)\n+\t{\n+\t  _Slist_node<_Tp>* __tmp = __cur;\n+\t  __cur = (_Slist_node<_Tp>*) __cur->_M_next;\n+\t  _Destroy(&__tmp->_M_data);\n+\t  _M_put_node(__tmp);\n+\t}\n+      __before_first->_M_next = __last_node;\n+      return __last_node;\n+    }\n \n+  /**\n+   *  This is an SGI extension.\n+   *  @ingroup SGIextensions\n+   *  @doctodo\n+   */\n+  template <class _Tp, class _Alloc = allocator<_Tp> >\n+    class slist : private _Slist_base<_Tp,_Alloc>\n+    {\n+      // concept requirements\n+      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+\t\n+    private:\n+      typedef _Slist_base<_Tp,_Alloc> _Base;\n+\n+    public:\n+      typedef _Tp               value_type;\n+      typedef value_type*       pointer;\n+      typedef const value_type* const_pointer;\n+      typedef value_type&       reference;\n+      typedef const value_type& const_reference;\n+      typedef size_t            size_type;\n+      typedef ptrdiff_t         difference_type;\n+      \n+      typedef _Slist_iterator<_Tp, _Tp&, _Tp*>             iterator;\n+      typedef _Slist_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n+      \n+      typedef typename _Base::allocator_type allocator_type;\n+\n+      allocator_type\n+      get_allocator() const\n+      { return _Base::get_allocator(); }\n+\n+    private:\n+      typedef _Slist_node<_Tp>      _Node;\n+      typedef _Slist_node_base      _Node_base;\n+      typedef _Slist_iterator_base  _Iterator_base;\n+      \n+      _Node*\n+      _M_create_node(const value_type& __x)\n+      {\n+\t_Node* __node = this->_M_get_node();\n+\ttry\n+\t  {\n+\t    _Construct(&__node->_M_data, __x);\n+\t    __node->_M_next = 0;\n+\t  }\n+\tcatch(...)\n+\t  {\n+\t    this->_M_put_node(__node);\n+\t    __throw_exception_again;\n+\t  }\n+\treturn __node;\n+      }\n \n-  // Removes all of the elements from the list __x to *this, inserting\n-  // them immediately after __pos.  __x must not be *this.  Complexity:\n-  // linear in __x.size().\n-  void splice_after(iterator __pos, slist& __x)\n-  {\n-    __slist_splice_after(__pos._M_node, &__x._M_head);\n-  }\n+      _Node*\n+      _M_create_node()\n+      {\n+\t_Node* __node = this->_M_get_node();\n+\ttry\n+\t  {\n+\t    _Construct(&__node->_M_data);\n+\t    __node->_M_next = 0;\n+\t  }\n+\tcatch(...)\n+\t  {\n+\t    this->_M_put_node(__node);\n+\t    __throw_exception_again;\n+\t  }\n+\treturn __node;\n+      }\n \n-  // Linear in distance(begin(), __pos), and linear in __x.size().\n-  void splice(iterator __pos, slist& __x) {\n-    if (__x._M_head._M_next)\n-      __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),\n-                           &__x._M_head, __slist_previous(&__x._M_head, 0));\n-  }\n+    public:\n+      explicit\n+      slist(const allocator_type& __a = allocator_type())\n+      : _Base(__a) {}\n+\n+      slist(size_type __n, const value_type& __x,\n+\t    const allocator_type& __a =  allocator_type())\n+      : _Base(__a)\n+      { _M_insert_after_fill(&this->_M_head, __n, __x); }\n+\n+      explicit\n+      slist(size_type __n)\n+      : _Base(allocator_type())\n+      { _M_insert_after_fill(&this->_M_head, __n, value_type()); }\n+\n+      // We don't need any dispatching tricks here, because\n+      // _M_insert_after_range already does them.\n+      template <class _InputIterator>\n+        slist(_InputIterator __first, _InputIterator __last,\n+\t      const allocator_type& __a =  allocator_type())\n+\t: _Base(__a)\n+        { _M_insert_after_range(&this->_M_head, __first, __last); }\n+\n+      slist(const slist& __x)\n+      : _Base(__x.get_allocator())\n+      { _M_insert_after_range(&this->_M_head, __x.begin(), __x.end()); }\n+\n+      slist&\n+      operator= (const slist& __x);\n+\n+      ~slist() {}\n+\n+    public:\n+      // assign(), a generalized assignment member function.  Two\n+      // versions: one that takes a count, and one that takes a range.\n+      // The range version is a member template, so we dispatch on whether\n+      // or not the type is an integer.\n+      \n+      void\n+      assign(size_type __n, const _Tp& __val)\n+      { _M_fill_assign(__n, __val); }\n+\n+      void\n+      _M_fill_assign(size_type __n, const _Tp& __val);\n+\n+      template <class _InputIterator>\n+        void\n+        assign(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+\t  _M_assign_dispatch(__first, __last, _Integral());\n+\t}\n+\n+      template <class _Integer>\n+      void\n+      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+      { _M_fill_assign((size_type) __n, (_Tp) __val); }\n+\n+      template <class _InputIterator>\n+      void\n+      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n+\t\t\t __false_type);\n+\n+    public:\n+\n+      iterator\n+      begin()\n+      { return iterator((_Node*)this->_M_head._M_next); }\n+\n+      const_iterator\n+      begin() const\n+      { return const_iterator((_Node*)this->_M_head._M_next);}\n+\n+      iterator\n+      end()\n+      { return iterator(0); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(0); }\n+\n+      // Experimental new feature: before_begin() returns a\n+      // non-dereferenceable iterator that, when incremented, yields\n+      // begin().  This iterator may be used as the argument to\n+      // insert_after, erase_after, etc.  Note that even for an empty\n+      // slist, before_begin() is not the same iterator as end().  It\n+      // is always necessary to increment before_begin() at least once to\n+      // obtain end().\n+      iterator\n+      before_begin()\n+      { return iterator((_Node*) &this->_M_head); }\n+\n+      const_iterator\n+      before_begin() const\n+      { return const_iterator((_Node*) &this->_M_head); }\n+\n+      size_type\n+      size() const\n+      { return __slist_size(this->_M_head._M_next); }\n+\n+      size_type\n+      max_size() const\n+      { return size_type(-1); }\n+\n+      bool\n+      empty() const\n+      { return this->_M_head._M_next == 0; }\n+\n+      void\n+      swap(slist& __x)\n+      { std::swap(this->_M_head._M_next, __x._M_head._M_next); }\n+\n+    public:\n+\n+      reference\n+      front()\n+      { return ((_Node*) this->_M_head._M_next)->_M_data; }\n+\n+      const_reference\n+      front() const\n+      { return ((_Node*) this->_M_head._M_next)->_M_data; }\n+\n+      void\n+      push_front(const value_type& __x)\n+      { __slist_make_link(&this->_M_head, _M_create_node(__x)); }\n+\n+      void\n+      push_front()\n+      { __slist_make_link(&this->_M_head, _M_create_node()); }\n+\n+      void\n+      pop_front()\n+      {\n+\t_Node* __node = (_Node*) this->_M_head._M_next;\n+\tthis->_M_head._M_next = __node->_M_next;\n+\t_Destroy(&__node->_M_data);\n+\tthis->_M_put_node(__node);\n+      }\n \n-  // Linear in distance(begin(), __pos), and in distance(__x.begin(), __i).\n-  void splice(iterator __pos, slist& __x, iterator __i) {\n-    __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),\n-                         __slist_previous(&__x._M_head, __i._M_node),\n-                         __i._M_node);\n-  }\n+      iterator\n+      previous(const_iterator __pos)\n+      { return iterator((_Node*) __slist_previous(&this->_M_head,\n+\t\t\t\t\t\t  __pos._M_node)); }\n \n-  // Linear in distance(begin(), __pos), in distance(__x.begin(), __first),\n-  // and in distance(__first, __last).\n-  void splice(iterator __pos, slist& __x, iterator __first, iterator __last)\n-  {\n-    if (__first != __last)\n-      __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),\n-                           __slist_previous(&__x._M_head, __first._M_node),\n-                           __slist_previous(__first._M_node, __last._M_node));\n-  }\n+      const_iterator\n+      previous(const_iterator __pos) const\n+      { return const_iterator((_Node*) __slist_previous(&this->_M_head,\n+\t\t\t\t\t\t\t__pos._M_node)); }\n \n-public:\n-  void reverse() {\n-    if (this->_M_head._M_next)\n-      this->_M_head._M_next = __slist_reverse(this->_M_head._M_next);\n-  }\n+    private:\n+      _Node*\n+      _M_insert_after(_Node_base* __pos, const value_type& __x)\n+      { return (_Node*) (__slist_make_link(__pos, _M_create_node(__x))); }\n \n-  void remove(const _Tp& __val);\n-  void unique();\n-  void merge(slist& __x);\n-  void sort();\n+      _Node*\n+      _M_insert_after(_Node_base* __pos)\n+      { return (_Node*) (__slist_make_link(__pos, _M_create_node())); }\n \n-  template <class _Predicate>\n-  void remove_if(_Predicate __pred);\n+      void\n+      _M_insert_after_fill(_Node_base* __pos,\n+\t\t\t   size_type __n, const value_type& __x)\n+      {\n+\tfor (size_type __i = 0; __i < __n; ++__i)\n+\t  __pos = __slist_make_link(__pos, _M_create_node(__x));\n+      }\n \n-  template <class _BinaryPredicate>\n-  void unique(_BinaryPredicate __pred);\n+      // Check whether it's an integral type.  If so, it's not an iterator.\n+      template <class _InIterator>\n+        void\n+        _M_insert_after_range(_Node_base* __pos,\n+\t\t\t      _InIterator __first, _InIterator __last)\n+        {\n+\t  typedef typename _Is_integer<_InIterator>::_Integral _Integral;\n+\t  _M_insert_after_range(__pos, __first, __last, _Integral());\n+\t}\n+\n+      template <class _Integer>\n+        void\n+        _M_insert_after_range(_Node_base* __pos, _Integer __n, _Integer __x,\n+\t\t\t      __true_type)\n+        { _M_insert_after_fill(__pos, __n, __x); }\n+\n+      template <class _InIterator>\n+        void\n+        _M_insert_after_range(_Node_base* __pos,\n+\t\t\t      _InIterator __first, _InIterator __last,\n+\t\t\t      __false_type)\n+        {\n+\t  while (__first != __last)\n+\t    {\n+\t      __pos = __slist_make_link(__pos, _M_create_node(*__first));\n+\t      ++__first;\n+\t    }\n+\t}\n+\n+    public:\n+      iterator\n+      insert_after(iterator __pos, const value_type& __x)\n+      { return iterator(_M_insert_after(__pos._M_node, __x)); }\n+\n+      iterator\n+      insert_after(iterator __pos)\n+      { return insert_after(__pos, value_type()); }\n+\n+      void\n+      insert_after(iterator __pos, size_type __n, const value_type& __x)\n+      { _M_insert_after_fill(__pos._M_node, __n, __x); }\n+\n+      // We don't need any dispatching tricks here, because\n+      // _M_insert_after_range already does them.\n+      template <class _InIterator>\n+        void\n+        insert_after(iterator __pos, _InIterator __first, _InIterator __last)\n+        { _M_insert_after_range(__pos._M_node, __first, __last); }\n+\n+      iterator\n+      insert(iterator __pos, const value_type& __x)\n+      { return iterator(_M_insert_after(__slist_previous(&this->_M_head,\n+\t\t\t\t\t\t\t __pos._M_node),\n+\t\t\t\t\t__x)); }\n+\n+      iterator\n+      insert(iterator __pos)\n+      { return iterator(_M_insert_after(__slist_previous(&this->_M_head,\n+\t\t\t\t\t\t\t __pos._M_node),\n+\t\t\t\t\tvalue_type())); }\n+\n+      void\n+      insert(iterator __pos, size_type __n, const value_type& __x)\n+      { _M_insert_after_fill(__slist_previous(&this->_M_head, __pos._M_node),\n+\t\t\t     __n, __x); }\n+\n+      // We don't need any dispatching tricks here, because\n+      // _M_insert_after_range already does them.\n+      template <class _InIterator>\n+        void\n+        insert(iterator __pos, _InIterator __first, _InIterator __last)\n+        { _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node),\n+\t\t\t\t__first, __last); }\n+\n+    public:\n+      iterator\n+      erase_after(iterator __pos)\n+      { return iterator((_Node*) this->_M_erase_after(__pos._M_node)); }\n+\n+      iterator\n+      erase_after(iterator __before_first, iterator __last)\n+      { return iterator((_Node*) this->_M_erase_after(__before_first._M_node,\n+\t\t\t\t\t\t      __last._M_node)); }\n+\n+      iterator\n+      erase(iterator __pos)\n+      { return (_Node*) this->_M_erase_after(__slist_previous(&this->_M_head,\n+\t\t\t\t\t\t\t      __pos._M_node)); }\n+\n+      iterator\n+      erase(iterator __first, iterator __last)\n+      { return (_Node*) this->_M_erase_after(__slist_previous(&this->_M_head,\n+\t\t\t\t\t\t\t      __first._M_node),\n+\t\t\t\t\t     __last._M_node); }\n+\n+      void\n+      resize(size_type new_size, const _Tp& __x);\n+\n+      void\n+      resize(size_type new_size)\n+      { resize(new_size, _Tp()); }\n+\n+      void\n+      clear()\n+      { this->_M_erase_after(&this->_M_head, 0); }\n+\n+    public:\n+      // Moves the range [__before_first + 1, __before_last + 1) to *this,\n+      //  inserting it immediately after __pos.  This is constant time.\n+      void\n+      splice_after(iterator __pos,\n+\t\t   iterator __before_first, iterator __before_last)\n+      {\n+\tif (__before_first != __before_last)\n+\t  __slist_splice_after(__pos._M_node, __before_first._M_node,\n+\t\t\t       __before_last._M_node);\n+      }\n \n-  template <class _StrictWeakOrdering>\n-  void merge(slist&, _StrictWeakOrdering);\n+      // Moves the element that follows __prev to *this, inserting it\n+      // immediately after __pos.  This is constant time.\n+      void\n+      splice_after(iterator __pos, iterator __prev)\n+      { __slist_splice_after(__pos._M_node,\n+\t\t\t     __prev._M_node, __prev._M_node->_M_next); }\n+\n+      // Removes all of the elements from the list __x to *this, inserting\n+      // them immediately after __pos.  __x must not be *this.  Complexity:\n+      // linear in __x.size().\n+      void\n+      splice_after(iterator __pos, slist& __x)\n+      { __slist_splice_after(__pos._M_node, &__x._M_head); }\n+\n+      // Linear in distance(begin(), __pos), and linear in __x.size().\n+      void\n+      splice(iterator __pos, slist& __x)\n+      {\n+\tif (__x._M_head._M_next)\n+\t  __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),\n+\t\t\t       &__x._M_head,\n+\t\t\t       __slist_previous(&__x._M_head, 0)); }\n+\n+      // Linear in distance(begin(), __pos), and in distance(__x.begin(), __i).\n+      void\n+      splice(iterator __pos, slist& __x, iterator __i)\n+      { __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),\n+\t\t\t     __slist_previous(&__x._M_head, __i._M_node),\n+\t\t\t     __i._M_node); }\n+\n+      // Linear in distance(begin(), __pos), in distance(__x.begin(), __first),\n+      // and in distance(__first, __last).\n+      void\n+      splice(iterator __pos, slist& __x, iterator __first, iterator __last)\n+      {\n+\tif (__first != __last)\n+\t  __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),\n+\t\t\t       __slist_previous(&__x._M_head, __first._M_node),\n+\t\t\t       __slist_previous(__first._M_node,\n+\t\t\t\t\t\t__last._M_node));\n+      }\n \n-  template <class _StrictWeakOrdering>\n-  void sort(_StrictWeakOrdering __comp);\n-};\n+    public:\n+      void\n+      reverse()\n+      {\n+\tif (this->_M_head._M_next)\n+\t  this->_M_head._M_next = __slist_reverse(this->_M_head._M_next);\n+      }\n \n-template <class _Tp, class _Alloc>\n-slist<_Tp,_Alloc>& slist<_Tp,_Alloc>::operator=(const slist<_Tp,_Alloc>& __x)\n-{\n-  if (&__x != this) {\n-    _Node_base* __p1 = &this->_M_head;\n-    _Node* __n1 = (_Node*) this->_M_head._M_next;\n-    const _Node* __n2 = (const _Node*) __x._M_head._M_next;\n-    while (__n1 && __n2) {\n-      __n1->_M_data = __n2->_M_data;\n-      __p1 = __n1;\n-      __n1 = (_Node*) __n1->_M_next;\n-      __n2 = (const _Node*) __n2->_M_next;\n-    }\n-    if (__n2 == 0)\n-      this->_M_erase_after(__p1, 0);\n-    else\n-      _M_insert_after_range(__p1, const_iterator((_Node*)__n2),\n+      void\n+      remove(const _Tp& __val);\n+\n+      void\n+      unique();\n+      \n+      void\n+      merge(slist& __x);\n+      \n+      void\n+      sort();\n+\n+      template <class _Predicate>\n+        void\n+        remove_if(_Predicate __pred);\n+\n+      template <class _BinaryPredicate>\n+        void\n+        unique(_BinaryPredicate __pred);\n+\n+      template <class _StrictWeakOrdering>\n+        void\n+        merge(slist&, _StrictWeakOrdering);\n+\n+      template <class _StrictWeakOrdering>\n+        void\n+        sort(_StrictWeakOrdering __comp);\n+    };\n+\n+  template <class _Tp, class _Alloc>\n+    slist<_Tp, _Alloc>&\n+    slist<_Tp, _Alloc>::operator=(const slist<_Tp, _Alloc>& __x)\n+    {\n+      if (&__x != this)\n+\t{\n+\t  _Node_base* __p1 = &this->_M_head;\n+\t  _Node* __n1 = (_Node*) this->_M_head._M_next;\n+\t  const _Node* __n2 = (const _Node*) __x._M_head._M_next;\n+\t  while (__n1 && __n2)\n+\t    {\n+\t      __n1->_M_data = __n2->_M_data;\n+\t      __p1 = __n1;\n+\t      __n1 = (_Node*) __n1->_M_next;\n+\t      __n2 = (const _Node*) __n2->_M_next;\n+\t    }\n+\t  if (__n2 == 0)\n+\t    this->_M_erase_after(__p1, 0);\n+\t  else\n+\t    _M_insert_after_range(__p1, const_iterator((_Node*)__n2),\n                                   const_iterator(0));\n-  }\n-  return *this;\n-}\n-\n-template <class _Tp, class _Alloc>\n-void slist<_Tp, _Alloc>::_M_fill_assign(size_type __n, const _Tp& __val) {\n-  _Node_base* __prev = &this->_M_head;\n-  _Node* __node = (_Node*) this->_M_head._M_next;\n-  for ( ; __node != 0 && __n > 0 ; --__n) {\n-    __node->_M_data = __val;\n-    __prev = __node;\n-    __node = (_Node*) __node->_M_next;\n-  }\n-  if (__n > 0)\n-    _M_insert_after_fill(__prev, __n, __val);\n-  else\n-    this->_M_erase_after(__prev, 0);\n-}\n-\n-template <class _Tp, class _Alloc> template <class _InputIterator>\n-void\n-slist<_Tp, _Alloc>::_M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n-                                       __false_type)\n-{\n-  _Node_base* __prev = &this->_M_head;\n-  _Node* __node = (_Node*) this->_M_head._M_next;\n-  while (__node != 0 && __first != __last) {\n-    __node->_M_data = *__first;\n-    __prev = __node;\n-    __node = (_Node*) __node->_M_next;\n-    ++__first;\n-  }\n-  if (__first != __last)\n-    _M_insert_after_range(__prev, __first, __last);\n-  else\n-    this->_M_erase_after(__prev, 0);\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline bool\n-operator==(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2)\n-{\n-  typedef typename slist<_Tp,_Alloc>::const_iterator const_iterator;\n-  const_iterator __end1 = _SL1.end();\n-  const_iterator __end2 = _SL2.end();\n-\n-  const_iterator __i1 = _SL1.begin();\n-  const_iterator __i2 = _SL2.begin();\n-  while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) {\n-    ++__i1;\n-    ++__i2;\n-  }\n-  return __i1 == __end1 && __i2 == __end2;\n-}\n+\t}\n+      return *this;\n+    }\n \n+  template <class _Tp, class _Alloc>\n+    void\n+    slist<_Tp, _Alloc>::_M_fill_assign(size_type __n, const _Tp& __val)\n+    {\n+      _Node_base* __prev = &this->_M_head;\n+      _Node* __node = (_Node*) this->_M_head._M_next;\n+      for (; __node != 0 && __n > 0; --__n)\n+\t{\n+\t  __node->_M_data = __val;\n+\t  __prev = __node;\n+\t  __node = (_Node*) __node->_M_next;\n+\t}\n+      if (__n > 0)\n+\t_M_insert_after_fill(__prev, __n, __val);\n+      else\n+\tthis->_M_erase_after(__prev, 0);\n+    }\n+  \n+  template <class _Tp, class _Alloc>\n+    template <class _InputIterator>\n+      void\n+      slist<_Tp, _Alloc>::_M_assign_dispatch(_InputIterator __first,\n+\t\t\t\t\t     _InputIterator __last,\n+\t\t\t\t\t     __false_type)\n+      {\n+\t_Node_base* __prev = &this->_M_head;\n+\t_Node* __node = (_Node*) this->_M_head._M_next;\n+\twhile (__node != 0 && __first != __last)\n+\t  {\n+\t    __node->_M_data = *__first;\n+\t    __prev = __node;\n+\t    __node = (_Node*) __node->_M_next;\n+\t    ++__first;\n+\t  }\n+\tif (__first != __last)\n+\t  _M_insert_after_range(__prev, __first, __last);\n+\telse\n+\t  this->_M_erase_after(__prev, 0);\n+      }\n+  \n+  template <class _Tp, class _Alloc>\n+    inline bool\n+    operator==(const slist<_Tp, _Alloc>& _SL1, const slist<_Tp, _Alloc>& _SL2)\n+    {\n+      typedef typename slist<_Tp,_Alloc>::const_iterator const_iterator;\n+      const_iterator __end1 = _SL1.end();\n+      const_iterator __end2 = _SL2.end();\n+      \n+      const_iterator __i1 = _SL1.begin();\n+      const_iterator __i2 = _SL2.begin();\n+      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)\n+\t{\n+\t  ++__i1;\n+\t  ++__i2;\n+\t}\n+      return __i1 == __end1 && __i2 == __end2;\n+    }\n \n-template <class _Tp, class _Alloc>\n-inline bool\n-operator<(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2)\n-{\n-  return std::lexicographical_compare(_SL1.begin(), _SL1.end(),\n-\t\t\t\t      _SL2.begin(), _SL2.end());\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline bool\n-operator!=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n-  return !(_SL1 == _SL2);\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline bool\n-operator>(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n-  return _SL2 < _SL1;\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline bool\n-operator<=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n-  return !(_SL2 < _SL1);\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline bool\n-operator>=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n-  return !(_SL1 < _SL2);\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline void swap(slist<_Tp,_Alloc>& __x, slist<_Tp,_Alloc>& __y) {\n-  __x.swap(__y);\n-}\n-\n-\n-template <class _Tp, class _Alloc>\n-void slist<_Tp,_Alloc>::resize(size_type __len, const _Tp& __x)\n-{\n-  _Node_base* __cur = &this->_M_head;\n-  while (__cur->_M_next != 0 && __len > 0) {\n-    --__len;\n-    __cur = __cur->_M_next;\n-  }\n-  if (__cur->_M_next)\n-    this->_M_erase_after(__cur, 0);\n-  else\n-    _M_insert_after_fill(__cur, __len, __x);\n-}\n-\n-template <class _Tp, class _Alloc>\n-void slist<_Tp,_Alloc>::remove(const _Tp& __val)\n-{\n-  _Node_base* __cur = &this->_M_head;\n-  while (__cur && __cur->_M_next) {\n-    if (((_Node*) __cur->_M_next)->_M_data == __val)\n-      this->_M_erase_after(__cur);\n-    else\n-      __cur = __cur->_M_next;\n-  }\n-}\n \n-template <class _Tp, class _Alloc>\n-void slist<_Tp,_Alloc>::unique()\n-{\n-  _Node_base* __cur = this->_M_head._M_next;\n-  if (__cur) {\n-    while (__cur->_M_next) {\n-      if (((_Node*)__cur)->_M_data ==\n-          ((_Node*)(__cur->_M_next))->_M_data)\n-        this->_M_erase_after(__cur);\n+  template <class _Tp, class _Alloc>\n+    inline bool\n+    operator<(const slist<_Tp, _Alloc>& _SL1, const slist<_Tp, _Alloc>& _SL2)\n+    { return std::lexicographical_compare(_SL1.begin(), _SL1.end(),\n+\t\t\t\t\t  _SL2.begin(), _SL2.end()); }\n+\n+  template <class _Tp, class _Alloc>\n+    inline bool\n+    operator!=(const slist<_Tp, _Alloc>& _SL1, const slist<_Tp, _Alloc>& _SL2)\n+    { return !(_SL1 == _SL2); }\n+\n+  template <class _Tp, class _Alloc>\n+    inline bool\n+    operator>(const slist<_Tp, _Alloc>& _SL1, const slist<_Tp, _Alloc>& _SL2)\n+    { return _SL2 < _SL1; }\n+\n+  template <class _Tp, class _Alloc>\n+    inline bool\n+    operator<=(const slist<_Tp, _Alloc>& _SL1, const slist<_Tp, _Alloc>& _SL2)\n+    { return !(_SL2 < _SL1); }\n+\n+  template <class _Tp, class _Alloc>\n+    inline bool\n+    operator>=(const slist<_Tp, _Alloc>& _SL1, const slist<_Tp, _Alloc>& _SL2)\n+    { return !(_SL1 < _SL2); }\n+\n+  template <class _Tp, class _Alloc>\n+    inline void\n+    swap(slist<_Tp, _Alloc>& __x, slist<_Tp, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template <class _Tp, class _Alloc>\n+    void\n+    slist<_Tp, _Alloc>::resize(size_type __len, const _Tp& __x)\n+    {\n+      _Node_base* __cur = &this->_M_head;\n+      while (__cur->_M_next != 0 && __len > 0)\n+\t{\n+\t  --__len;\n+\t  __cur = __cur->_M_next;\n+\t}\n+      if (__cur->_M_next)\n+\tthis->_M_erase_after(__cur, 0);\n       else\n-        __cur = __cur->_M_next;\n+\t_M_insert_after_fill(__cur, __len, __x);\n     }\n-  }\n-}\n \n-template <class _Tp, class _Alloc>\n-void slist<_Tp,_Alloc>::merge(slist<_Tp,_Alloc>& __x)\n-{\n-  _Node_base* __n1 = &this->_M_head;\n-  while (__n1->_M_next && __x._M_head._M_next) {\n-    if (((_Node*) __x._M_head._M_next)->_M_data <\n-        ((_Node*)       __n1->_M_next)->_M_data)\n-      __slist_splice_after(__n1, &__x._M_head, __x._M_head._M_next);\n-    __n1 = __n1->_M_next;\n-  }\n-  if (__x._M_head._M_next) {\n-    __n1->_M_next = __x._M_head._M_next;\n-    __x._M_head._M_next = 0;\n-  }\n-}\n-\n-template <class _Tp, class _Alloc>\n-void slist<_Tp,_Alloc>::sort()\n-{\n-  if (this->_M_head._M_next && this->_M_head._M_next->_M_next) {\n-    slist __carry;\n-    slist __counter[64];\n-    int __fill = 0;\n-    while (!empty()) {\n-      __slist_splice_after(&__carry._M_head,\n-                           &this->_M_head, this->_M_head._M_next);\n-      int __i = 0;\n-      while (__i < __fill && !__counter[__i].empty()) {\n-        __counter[__i].merge(__carry);\n-        __carry.swap(__counter[__i]);\n-        ++__i;\n-      }\n-      __carry.swap(__counter[__i]);\n-      if (__i == __fill)\n-        ++__fill;\n+  template <class _Tp, class _Alloc>\n+    void\n+    slist<_Tp, _Alloc>::remove(const _Tp& __val)\n+    { \n+      _Node_base* __cur = &this->_M_head;\n+      while (__cur && __cur->_M_next)\n+\t{\n+\t  if (((_Node*) __cur->_M_next)->_M_data == __val)\n+\t    this->_M_erase_after(__cur);\n+\t  else\n+\t    __cur = __cur->_M_next;\n+\t}\n     }\n \n-    for (int __i = 1; __i < __fill; ++__i)\n-      __counter[__i].merge(__counter[__i-1]);\n-    this->swap(__counter[__fill-1]);\n-  }\n-}\n+  template <class _Tp, class _Alloc>\n+    void\n+    slist<_Tp, _Alloc>::unique()\n+    {\n+      _Node_base* __cur = this->_M_head._M_next;\n+      if (__cur)\n+\t{\n+\t  while (__cur->_M_next)\n+\t    {\n+\t      if (((_Node*)__cur)->_M_data\n+\t\t  == ((_Node*)(__cur->_M_next))->_M_data)\n+\t\tthis->_M_erase_after(__cur);\n+\t      else\n+\t\t__cur = __cur->_M_next;\n+\t    }\n+\t}\n+    }\n \n-template <class _Tp, class _Alloc>\n-template <class _Predicate>\n-void slist<_Tp,_Alloc>::remove_if(_Predicate __pred)\n-{\n-  _Node_base* __cur = &this->_M_head;\n-  while (__cur->_M_next) {\n-    if (__pred(((_Node*) __cur->_M_next)->_M_data))\n-      this->_M_erase_after(__cur);\n-    else\n-      __cur = __cur->_M_next;\n-  }\n-}\n+  template <class _Tp, class _Alloc>\n+    void\n+    slist<_Tp, _Alloc>::merge(slist<_Tp, _Alloc>& __x)\n+    {\n+      _Node_base* __n1 = &this->_M_head;\n+      while (__n1->_M_next && __x._M_head._M_next)\n+\t{\n+\t  if (((_Node*) __x._M_head._M_next)->_M_data\n+\t      < ((_Node*) __n1->_M_next)->_M_data)\n+\t    __slist_splice_after(__n1, &__x._M_head, __x._M_head._M_next);\n+\t  __n1 = __n1->_M_next;\n+\t}\n+      if (__x._M_head._M_next)\n+\t{\n+\t  __n1->_M_next = __x._M_head._M_next;\n+\t  __x._M_head._M_next = 0;\n+\t}\n+    }\n \n-template <class _Tp, class _Alloc> template <class _BinaryPredicate>\n-void slist<_Tp,_Alloc>::unique(_BinaryPredicate __pred)\n-{\n-  _Node* __cur = (_Node*) this->_M_head._M_next;\n-  if (__cur) {\n-    while (__cur->_M_next) {\n-      if (__pred(((_Node*)__cur)->_M_data,\n-                 ((_Node*)(__cur->_M_next))->_M_data))\n-        this->_M_erase_after(__cur);\n-      else\n-        __cur = (_Node*) __cur->_M_next;\n+  template <class _Tp, class _Alloc>\n+    void\n+    slist<_Tp, _Alloc>::sort()\n+    {\n+      if (this->_M_head._M_next && this->_M_head._M_next->_M_next)\n+\t{\n+\t  slist __carry;\n+\t  slist __counter[64];\n+\t  int __fill = 0;\n+\t  while (!empty())\n+\t    {\n+\t      __slist_splice_after(&__carry._M_head,\n+\t\t\t\t   &this->_M_head, this->_M_head._M_next);\n+\t      int __i = 0;\n+\t      while (__i < __fill && !__counter[__i].empty())\n+\t\t{\n+\t\t  __counter[__i].merge(__carry);\n+\t\t  __carry.swap(__counter[__i]);\n+\t\t  ++__i;\n+\t\t}\n+\t      __carry.swap(__counter[__i]);\n+\t      if (__i == __fill)\n+\t\t++__fill;\n+\t    }\n+\t  \n+\t  for (int __i = 1; __i < __fill; ++__i)\n+\t    __counter[__i].merge(__counter[__i-1]);\n+\t  this->swap(__counter[__fill-1]);\n+\t}\n     }\n-  }\n-}\n \n-template <class _Tp, class _Alloc> template <class _StrictWeakOrdering>\n-void slist<_Tp,_Alloc>::merge(slist<_Tp,_Alloc>& __x,\n-                              _StrictWeakOrdering __comp)\n-{\n-  _Node_base* __n1 = &this->_M_head;\n-  while (__n1->_M_next && __x._M_head._M_next) {\n-    if (__comp(((_Node*) __x._M_head._M_next)->_M_data,\n-               ((_Node*)       __n1->_M_next)->_M_data))\n-      __slist_splice_after(__n1, &__x._M_head, __x._M_head._M_next);\n-    __n1 = __n1->_M_next;\n-  }\n-  if (__x._M_head._M_next) {\n-    __n1->_M_next = __x._M_head._M_next;\n-    __x._M_head._M_next = 0;\n-  }\n-}\n+  template <class _Tp, class _Alloc>\n+    template <class _Predicate>\n+      void slist<_Tp, _Alloc>::remove_if(_Predicate __pred)\n+      {\n+\t_Node_base* __cur = &this->_M_head;\n+\twhile (__cur->_M_next)\n+\t  {\n+\t    if (__pred(((_Node*) __cur->_M_next)->_M_data))\n+\t      this->_M_erase_after(__cur);\n+\t    else\n+\t      __cur = __cur->_M_next;\n+\t  }\n+      }\n \n-template <class _Tp, class _Alloc> template <class _StrictWeakOrdering>\n-void slist<_Tp,_Alloc>::sort(_StrictWeakOrdering __comp)\n-{\n-  if (this->_M_head._M_next && this->_M_head._M_next->_M_next) {\n-    slist __carry;\n-    slist __counter[64];\n-    int __fill = 0;\n-    while (!empty()) {\n-      __slist_splice_after(&__carry._M_head,\n-                           &this->_M_head, this->_M_head._M_next);\n-      int __i = 0;\n-      while (__i < __fill && !__counter[__i].empty()) {\n-        __counter[__i].merge(__carry, __comp);\n-        __carry.swap(__counter[__i]);\n-        ++__i;\n+  template <class _Tp, class _Alloc>\n+    template <class _BinaryPredicate>\n+      void\n+      slist<_Tp, _Alloc>::unique(_BinaryPredicate __pred)\n+      {\n+\t_Node* __cur = (_Node*) this->_M_head._M_next;\n+\tif (__cur)\n+\t  {\n+\t    while (__cur->_M_next)\n+\t      {\n+\t\tif (__pred(((_Node*)__cur)->_M_data,\n+\t\t\t   ((_Node*)(__cur->_M_next))->_M_data))\n+\t\t  this->_M_erase_after(__cur);\n+\t\telse\n+\t\t  __cur = (_Node*) __cur->_M_next;\n+\t      }\n+\t  }\n       }\n-      __carry.swap(__counter[__i]);\n-      if (__i == __fill)\n-        ++__fill;\n-    }\n \n-    for (int __i = 1; __i < __fill; ++__i)\n-      __counter[__i].merge(__counter[__i-1], __comp);\n-    this->swap(__counter[__fill-1]);\n-  }\n-}\n+  template <class _Tp, class _Alloc>\n+    template <class _StrictWeakOrdering>\n+      void\n+      slist<_Tp, _Alloc>::merge(slist<_Tp, _Alloc>& __x,\n+\t\t\t       _StrictWeakOrdering __comp)\n+      {\n+\t_Node_base* __n1 = &this->_M_head;\n+\twhile (__n1->_M_next && __x._M_head._M_next)\n+\t  {\n+\t    if (__comp(((_Node*) __x._M_head._M_next)->_M_data,\n+\t\t       ((_Node*) __n1->_M_next)->_M_data))\n+\t      __slist_splice_after(__n1, &__x._M_head, __x._M_head._M_next);\n+\t    __n1 = __n1->_M_next;\n+\t  }\n+\tif (__x._M_head._M_next)\n+\t  {\n+\t    __n1->_M_next = __x._M_head._M_next;\n+\t    __x._M_head._M_next = 0;\n+\t  }\n+      }\n+\n+  template <class _Tp, class _Alloc>\n+    template <class _StrictWeakOrdering>\n+      void\n+      slist<_Tp, _Alloc>::sort(_StrictWeakOrdering __comp)\n+      {\n+\tif (this->_M_head._M_next && this->_M_head._M_next->_M_next)\n+\t  {\n+\t    slist __carry;\n+\t    slist __counter[64];\n+\t    int __fill = 0;\n+\t    while (!empty())\n+\t      {\n+\t\t__slist_splice_after(&__carry._M_head,\n+\t\t\t\t     &this->_M_head, this->_M_head._M_next);\n+\t\tint __i = 0;\n+\t\twhile (__i < __fill && !__counter[__i].empty())\n+\t\t  {\n+\t\t    __counter[__i].merge(__carry, __comp);\n+\t\t    __carry.swap(__counter[__i]);\n+\t\t    ++__i;\n+\t\t  }\n+\t\t__carry.swap(__counter[__i]);\n+\t\tif (__i == __fill)\n+\t\t  ++__fill;\n+\t      }\n+\n+\t    for (int __i = 1; __i < __fill; ++__i)\n+\t      __counter[__i].merge(__counter[__i-1], __comp);\n+\t    this->swap(__counter[__fill-1]);\n+\t  }\n+      }\n \n } // namespace __gnu_cxx\n \n namespace std\n {\n-// Specialization of insert_iterator so that insertions will be constant\n-// time rather than linear time.\n-\n-template <class _Tp, class _Alloc>\n-class insert_iterator<__gnu_cxx::slist<_Tp, _Alloc> > {\n-protected:\n-  typedef __gnu_cxx::slist<_Tp, _Alloc> _Container;\n-  _Container* container;\n-  typename _Container::iterator iter;\n-public:\n-  typedef _Container          container_type;\n-  typedef output_iterator_tag iterator_category;\n-  typedef void                value_type;\n-  typedef void                difference_type;\n-  typedef void                pointer;\n-  typedef void                reference;\n-\n-  insert_iterator(_Container& __x, typename _Container::iterator __i)\n-    : container(&__x) {\n-    if (__i == __x.begin())\n-      iter = __x.before_begin();\n-    else\n-      iter = __x.previous(__i);\n-  }\n+  // Specialization of insert_iterator so that insertions will be constant\n+  // time rather than linear time.\n+\n+  template <class _Tp, class _Alloc>\n+    class insert_iterator<__gnu_cxx::slist<_Tp, _Alloc> >\n+    {\n+    protected:\n+      typedef __gnu_cxx::slist<_Tp, _Alloc> _Container;\n+      _Container* container;\n+      typename _Container::iterator iter;\n+\n+    public:\n+      typedef _Container          container_type;\n+      typedef output_iterator_tag iterator_category;\n+      typedef void                value_type;\n+      typedef void                difference_type;\n+      typedef void                pointer;\n+      typedef void                reference;\n+\n+      insert_iterator(_Container& __x, typename _Container::iterator __i)\n+      : container(&__x)\n+      {\n+\tif (__i == __x.begin())\n+\t  iter = __x.before_begin();\n+\telse\n+\t  iter = __x.previous(__i);\n+      }\n \n-  insert_iterator<_Container>&\n-  operator=(const typename _Container::value_type& __value) {\n-    iter = container->insert_after(iter, __value);\n-    return *this;\n-  }\n-  insert_iterator<_Container>& operator*() { return *this; }\n-  insert_iterator<_Container>& operator++() { return *this; }\n-  insert_iterator<_Container>& operator++(int) { return *this; }\n+      insert_iterator<_Container>&\n+      operator=(const typename _Container::value_type& __value)\n+      {\n+\titer = container->insert_after(iter, __value);\n+\treturn *this;\n+      }\n+\n+      insert_iterator<_Container>&\n+      operator*()\n+      { return *this; }\n+\n+      insert_iterator<_Container>&\n+      operator++()\n+      { return *this; }\n+\n+      insert_iterator<_Container>&\n+      operator++(int)\n+      { return *this; }\n };\n \n } // namespace std\n-\n #endif"}]}