{"sha": "ffe9aba81229acba2f9c9a96503dc08ae9a03bb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZlOWFiYTgxMjI5YWNiYTJmOWM5YTk2NTAzZGMwOGFlOWEwM2JiNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-11-19T10:57:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-11-19T10:57:20Z"}, "message": "exp_ch4.adb (Expand_N_Selected_Component): If the component is the discriminant of a constrained subtype...\n\n\t* exp_ch4.adb (Expand_N_Selected_Component): If the component is the\n\tdiscriminant of a constrained subtype, analyze the copy of the\n\tcorresponding constraint, because in some cases it may be only\n\tpartially analyzed.\n\tRemoves long-lived ??? comments.\n\n\t* exp_ch7.adb (Establish_Transient_Scope): Remove complex code that\n\thandled controlled or secondary-stack expressions within the\n\titeration_scheme of a loop.\n\n\t* sem_ch5.adb (Analyze_Iteration_Scheme): Build a block to evaluate\n\tbounds that may contain functions calls, to prevent memory leaks when\n\tthe bound contains a call to a function that uses the secondary stack.\n\t(Check_Complex_Bounds): Subsidiary of Analyze_Iteration_Scheme, to\n\tgenerate temporaries for loop bounds that might contain function calls\n\tthat require secondary stack and/or finalization actions.\n\n\t* sem_ch4.adb (Analyze_Indexed_Component_Form): If the prefix is a\n\tselected component and the selector is overloadable (not just a\n\tfunction) treat as function call, Analyze_Call will disambiguate if\n\tnecessary.\n\t(Analyze_Selected_Component): Do not generate an actual subtype for the\n\tselected component if expansion is disabled. The actual subtype is only\n\tneeded for constraint checks.\n\t(Analyze_Allocator): If restriction No_Streams is set, then do\n\tnot permit objects to be declared of a stream type, or of a\n\tcomposite type containing a stream.\n\n\t* restrict.ads: Remove the a-stream entry from Unit_Array, since\n\tNo_Streams no longer prohibits with'ing this package.\n\n\t* sem_ch3.adb (Build_Derived_Record_Type): If the parent type has\n\tdiscriminants, but the parent base has unknown discriminants, there is\n\tno discriminant constraint to inherit. Such a discrepancy can arise\n\twhen the actual for a formal type with unknown discriminants is a\n\tsimilar private type whose full view has discriminants.\n\t(Analyze_Object_Declaration): If restriction No_Streams is set, then\n\tdo not permit objects to be declared of a stream type, or of a\n\tcomposite type containing a stream.\n\nFrom-SVN: r90906", "tree": {"sha": "180c6c1639dfdeda66e9fb2b12980eae5f2ba409", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/180c6c1639dfdeda66e9fb2b12980eae5f2ba409"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5/comments", "author": null, "committer": null, "parents": [{"sha": "bc202b70061a5e8765d537d4222b25284b24361a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc202b70061a5e8765d537d4222b25284b24361a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc202b70061a5e8765d537d4222b25284b24361a"}], "stats": {"total": 320, "additions": 193, "deletions": 127}, "files": [{"sha": "be053b59ddd8506466c8cbcef5d1f592c4606345", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=ffe9aba81229acba2f9c9a96503dc08ae9a03bb5", "patch": "@@ -5900,22 +5900,13 @@ package body Exp_Ch4 is\n                      elsif Nkind (Parent (N)) = N_Case_Statement\n                        and then Etype (Node (Dcon)) /= Etype (Disc)\n                      then\n-                        --  RBKD is suspicious of the following code. The\n-                        --  call to New_Copy instead of New_Copy_Tree is\n-                        --  suspicious, and the call to Analyze instead\n-                        --  of Analyze_And_Resolve is also suspicious ???\n-\n-                        --  Wouldn't it be good enough to do a perfectly\n-                        --  normal Analyze_And_Resolve call using the\n-                        --  subtype of the discriminant here???\n-\n                         Rewrite (N,\n                           Make_Qualified_Expression (Loc,\n                             Subtype_Mark =>\n                               New_Occurrence_Of (Etype (Disc), Loc),\n                             Expression   =>\n-                              New_Copy (Node (Dcon))));\n-                        Analyze (N);\n+                              New_Copy_Tree (Node (Dcon))));\n+                        Analyze_And_Resolve (N, Etype (Disc));\n \n                         --  In case that comes out as a static expression,\n                         --  reset it (a selected component is never static).\n@@ -5924,13 +5915,15 @@ package body Exp_Ch4 is\n                         return;\n \n                      --  Otherwise we can just copy the constraint, but the\n-                     --  result is certainly not static!\n-\n-                     --  Again the New_Copy here and the failure to even\n-                     --  to an analyze call is uneasy ???\n+                     --  result is certainly not static! In some cases the\n+                     --  discriminant constraint has been analyzed in the\n+                     --  context of the original subtype indication, but for\n+                     --  itypes the constraint might not have been analyzed\n+                     --  yet, and this must be done now.\n \n                      else\n-                        Rewrite (N, New_Copy (Node (Dcon)));\n+                        Rewrite (N, New_Copy_Tree (Node (Dcon)));\n+                        Analyze_And_Resolve (N);\n                         Set_Is_Static_Expression (N, False);\n                         return;\n                      end if;"}, {"sha": "0339479b0e20b62e3fcd3a51d7f5128b87dfa275", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 6, "deletions": 70, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=ffe9aba81229acba2f9c9a96503dc08ae9a03bb5", "patch": "@@ -1050,77 +1050,13 @@ package body Exp_Ch7 is\n       if No (Wrap_Node) then\n          null;\n \n-      elsif Nkind (Wrap_Node) = N_Iteration_Scheme then\n-\n-         --  Create a declaration followed by an assignment, so that\n-         --  the assignment can have its own transient scope.\n-         --  We generate the equivalent of:\n-\n-         --  type Ptr is access all expr_type;\n-         --  Var : Ptr;\n-         --  begin\n-         --     Var := Expr'reference;\n-         --  end;\n-\n-         --  This closely resembles what is done in Remove_Side_Effect,\n-         --  but it has to be done here, before the analysis of the call\n-         --  is completed.\n-\n-         declare\n-            Ptr_Typ : constant Entity_Id :=\n-                        Make_Defining_Identifier (Loc,\n-                          Chars => New_Internal_Name ('A'));\n-            Ptr     : constant Entity_Id :=\n-                        Make_Defining_Identifier (Loc,\n-                          Chars => New_Internal_Name ('T'));\n-\n-            Expr_Type    : constant Entity_Id := Etype (N);\n-            New_Expr     : constant Node_Id := Relocate_Node (N);\n-            Decl         : Node_Id;\n-            Ptr_Typ_Decl : Node_Id;\n-            Stmt         : Node_Id;\n+      --  If the node to wrap is an iteration_scheme, the expression is\n+      --  one of the bounds, and the expansion will make an explicit\n+      --  declaration for it (see Analyze_Iteration_Scheme, sem_ch5.adb),\n+      --  so do not apply any transformations here.\n \n-         begin\n-            Ptr_Typ_Decl :=\n-              Make_Full_Type_Declaration (Loc,\n-                Defining_Identifier => Ptr_Typ,\n-                Type_Definition =>\n-                  Make_Access_To_Object_Definition (Loc,\n-                    All_Present => True,\n-                    Subtype_Indication =>\n-                      New_Reference_To (Expr_Type, Loc)));\n-\n-            Decl :=\n-              Make_Object_Declaration (Loc,\n-                 Defining_Identifier => Ptr,\n-                 Object_Definition => New_Occurrence_Of (Ptr_Typ, Loc));\n-\n-            Set_Etype (Ptr, Ptr_Typ);\n-            Stmt :=\n-               Make_Assignment_Statement (Loc,\n-                  Name => New_Occurrence_Of (Ptr, Loc),\n-                  Expression => Make_Reference (Loc, New_Expr));\n-\n-            Set_Analyzed (New_Expr, False);\n-\n-            Insert_List_Before_And_Analyze\n-              (Parent (Wrap_Node),\n-                 New_List (\n-                   Ptr_Typ_Decl,\n-                   Decl,\n-                   Make_Block_Statement (Loc,\n-                     Handled_Statement_Sequence =>\n-                       Make_Handled_Sequence_Of_Statements (Loc,\n-                         New_List (Stmt)))));\n-\n-            Rewrite (N,\n-              Make_Explicit_Dereference (Loc,\n-                Prefix => New_Reference_To (Ptr, Loc)));\n-            Analyze_And_Resolve (N, Expr_Type);\n-\n-         end;\n-\n-      --  Transient scope is required\n+      elsif Nkind (Wrap_Node) = N_Iteration_Scheme then\n+         null;\n \n       else\n          New_Scope (New_Internal_Entity (E_Block, Current_Scope, Loc, 'B'));"}, {"sha": "364b6507ad3330249750bc39861d718b32c6d122", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=ffe9aba81229acba2f9c9a96503dc08ae9a03bb5", "patch": "@@ -93,7 +93,6 @@ package Restrict is\n      (No_IO,                       \"text_io \"),\n      (No_IO,                       \"a-witeio\"),\n      (No_Task_Attributes_Package,  \"a-tasatt\"),\n-     (No_Streams,                  \"a-stream\"),\n      (No_Unchecked_Conversion,     \"a-unccon\"),\n      (No_Unchecked_Conversion,     \"unchconv\"),\n      (No_Unchecked_Deallocation,   \"a-uncdea\"),"}, {"sha": "78d714e848ed0e11a6c4b9323e4950c6c12ff953", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 44, "deletions": 32, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=ffe9aba81229acba2f9c9a96503dc08ae9a03bb5", "patch": "@@ -459,7 +459,7 @@ package body Sem_Ch3 is\n    --  build the associated Implicit type name.\n \n    procedure Constrain_Integer (Def_Id : Node_Id; S : Node_Id);\n-   --  Build subtype of a signed or modular integer type.\n+   --  Build subtype of a signed or modular integer type\n \n    procedure Constrain_Ordinary_Fixed (Def_Id : Node_Id; S : Node_Id);\n    --  Constrain an ordinary fixed point type with a range constraint, and\n@@ -1415,7 +1415,7 @@ package body Sem_Ch3 is\n                elsif It.Typ = Universal_Real\n                  or else It.Typ = Universal_Integer\n                then\n-                  --  Choose universal interpretation over any other.\n+                  --  Choose universal interpretation over any other\n \n                   T := It.Typ;\n                   exit;\n@@ -1806,6 +1806,18 @@ package body Sem_Ch3 is\n          Apply_Static_Length_Check (E, T);\n       end if;\n \n+      --  If the No_Streams restriction is set, check that the type of the\n+      --  object is not, and does not contain, any subtype derived from\n+      --  Ada.Streams.Root_Stream_Type. Note that we guard the call to\n+      --  Has_Stream just for efficiency reasons. There is no point in\n+      --  spending time on a Has_Stream check if the restriction is not set.\n+\n+      if Restrictions.Set (No_Streams) then\n+         if Has_Stream (T) then\n+            Check_Restriction (No_Streams, N);\n+         end if;\n+      end if;\n+\n       --  Abstract type is never permitted for a variable or constant.\n       --  Note: we inhibit this check for objects that do not come from\n       --  source because there is at least one case (the expansion of\n@@ -1917,7 +1929,7 @@ package body Sem_Ch3 is\n \n          elsif Nkind (E) = N_Raise_Constraint_Error then\n \n-            --  Aggregate is statically illegal. Place back in declaration.\n+            --  Aggregate is statically illegal. Place back in declaration\n \n             Set_Expression (N, E);\n             Set_No_Initialization (N, False);\n@@ -2759,7 +2771,7 @@ package body Sem_Ch3 is\n          when N_Derived_Type_Definition =>\n             null;\n \n-         --  For record types, discriminants are allowed.\n+         --  For record types, discriminants are allowed\n \n          when N_Record_Definition =>\n             null;\n@@ -2940,7 +2952,7 @@ package body Sem_Ch3 is\n            Process_Non_Static_Choice => Non_Static_Choice_Error,\n            Process_Associated_Node   => Process_Declarations);\n       use Variant_Choices_Processing;\n-      --  Instantiation of the generic choice processing package.\n+      --  Instantiation of the generic choice processing package\n \n       -----------------------------\n       -- Non_Static_Choice_Error --\n@@ -2967,7 +2979,7 @@ package body Sem_Ch3 is\n          end if;\n       end Process_Declarations;\n \n-      --  Variables local to Analyze_Case_Statement.\n+      --  Variables local to Analyze_Case_Statement\n \n       Discr_Name : Node_Id;\n       Discr_Type : Entity_Id;\n@@ -4180,7 +4192,7 @@ package body Sem_Ch3 is\n             end if;\n          end if;\n \n-         --  Build partial view of derived type from partial view of parent.\n+         --  Build partial view of derived type from partial view of parent\n \n          Build_Derived_Record_Type\n            (N, Parent_Type, Derived_Type, Derive_Subps);\n@@ -4388,7 +4400,7 @@ package body Sem_Ch3 is\n                Copy_And_Build;\n                Exchange_Declarations (Full_P);\n \n-            --  Otherwise it is a local derivation.\n+            --  Otherwise it is a local derivation\n \n             else\n                Copy_And_Build;\n@@ -4545,7 +4557,7 @@ package body Sem_Ch3 is\n    --  in the derived type definition, then the discriminant is said to be\n    --  \"specified\" by that derived type definition.\n \n-   --  3. DISCRIMINANTS IN DERIVED UNTAGGED RECORD TYPES.\n+   --  3. DISCRIMINANTS IN DERIVED UNTAGGED RECORD TYPES\n \n    --  We have spoken about stored discriminants in point 1 (introduction)\n    --  above. There are two sort of stored discriminants: implicit and\n@@ -4720,7 +4732,7 @@ package body Sem_Ch3 is\n    --  Discriminant_Constraint from Der so that when parameter conformance is\n    --  checked when P is overridden, no semantic errors are flagged.\n \n-   --  6. SECOND TRANSFORMATION FOR DERIVED RECORDS.\n+   --  6. SECOND TRANSFORMATION FOR DERIVED RECORDS\n \n    --  Regardless of whether we are dealing with a tagged or untagged type\n    --  we will transform all derived type declarations of the form\n@@ -4755,9 +4767,7 @@ package body Sem_Ch3 is\n    --      type T2 (X : positive) is new R (1, X) [with null record];\n \n    --  As explained in 6. above, T1 is rewritten as\n-\n    --      type T1 (D1, D2 : Positive) is new R (D1, D2) [with null record];\n-\n    --  which makes the treatment for T1 and T2 identical.\n \n    --  What we want when inheriting S, is that references to D1 and D2 in R are\n@@ -4877,7 +4887,7 @@ package body Sem_Ch3 is\n    --             subtype  T is BaseT (1);\n    --          end;\n \n-   --  (strictly speaking the above is incorrect Ada).\n+   --  (strictly speaking the above is incorrect Ada)\n \n    --  From the semantic standpoint the private view of private extension T\n    --  should be flagged as constrained since one can clearly have\n@@ -5037,7 +5047,7 @@ package body Sem_Ch3 is\n         and then not Discriminant_Specs\n         and then (Is_Constrained (Parent_Type) or else Constraint_Present)\n       then\n-         --  First, we must analyze the constraint (see comment in point 5.).\n+         --  First, we must analyze the constraint (see comment in point 5.)\n \n          if Constraint_Present then\n             New_Discrs := Build_Discriminant_Constraints (Parent_Type, Indic);\n@@ -5379,6 +5389,7 @@ package body Sem_Ch3 is\n          end if;\n \n          if not Has_Unknown_Discriminants (Derived_Type)\n+           and then not Has_Unknown_Discriminants (Parent_Base)\n            and then Has_Discriminants (Parent_Type)\n          then\n             Inherit_Discrims := True;\n@@ -5407,7 +5418,7 @@ package body Sem_Ch3 is\n                    or else Has_Unknown_Discriminants (Derived_Type)));\n       end if;\n \n-      --  STEP 3: initialize fields of derived type.\n+      --  STEP 3: initialize fields of derived type\n \n       Set_Is_Tagged_Type    (Derived_Type, Is_Tagged);\n       Set_Stored_Constraint (Derived_Type, No_Elist);\n@@ -5441,7 +5452,7 @@ package body Sem_Ch3 is\n            (Derived_Type, Finalize_Storage_Only (Parent_Type));\n       end if;\n \n-      --  Set fields for private derived types.\n+      --  Set fields for private derived types\n \n       if Is_Private_Type (Derived_Type) then\n          Set_Depends_On_Private (Derived_Type, True);\n@@ -5901,7 +5912,7 @@ package body Sem_Ch3 is\n \n       while Present (Constr) loop\n \n-         --  Positional association forbidden after a named association.\n+         --  Positional association forbidden after a named association\n \n          if Nkind (Constr) /= N_Discriminant_Association then\n             Error_Msg_N (\"positional association follows named one\", Constr);\n@@ -6025,7 +6036,7 @@ package body Sem_Ch3 is\n          end if;\n       end loop;\n \n-      --  Determine if there are discriminant expressions in the constraint.\n+      --  Determine if there are discriminant expressions in the constraint\n \n       for J in Discr_Expr'Range loop\n          if Denotes_Discriminant (Discr_Expr (J), Check_Protected => True) then\n@@ -6813,7 +6824,7 @@ package body Sem_Ch3 is\n    begin\n       if Has_Discriminants (T) then\n \n-         --  Make the discriminants visible to component declarations.\n+         --  Make the discriminants visible to component declarations\n \n          declare\n             D    : Entity_Id := First_Discriminant (T);\n@@ -7752,7 +7763,7 @@ package body Sem_Ch3 is\n \n          Set_Parent (Subtyp_Decl, Parent (Related_Node));\n \n-         --  Itypes must be analyzed with checks off (see itypes.ads).\n+         --  Itypes must be analyzed with checks off (see package Itypes)\n \n          Analyze (Subtyp_Decl, Suppress => All_Checks);\n \n@@ -7859,7 +7870,7 @@ package body Sem_Ch3 is\n             return True;\n          end if;\n \n-         --  In all other cases we have something wrong.\n+         --  In all other cases we have something wrong\n \n          return False;\n       end Is_Discriminant;\n@@ -8252,7 +8263,7 @@ package body Sem_Ch3 is\n           (Nkind (S) = N_Attribute_Reference\n             and then Attribute_Name (S) = Name_Range)\n       then\n-         --  A Range attribute will transformed into N_Range by Resolve.\n+         --  A Range attribute will transformed into N_Range by Resolve\n \n          Analyze (S);\n          Set_Etype (S, T);\n@@ -8488,7 +8499,7 @@ package body Sem_Ch3 is\n       then\n          return;\n \n-      --  Here we do the analysis of the range.\n+      --  Here we do the analysis of the range\n \n       --  Note: we do this manually, since if we do a normal Analyze and\n       --  Resolve call, there are problems with the conversions used for\n@@ -8642,7 +8653,7 @@ package body Sem_Ch3 is\n       --  Collect parent type components that do not appear in a variant part\n \n       procedure Create_All_Components;\n-      --  Iterate over Comp_List to create the components of the subtype.\n+      --  Iterate over Comp_List to create the components of the subtype\n \n       function Create_Component (Old_Compon : Entity_Id) return Entity_Id;\n       --  Creates a new component from Old_Compon, copying all the fields from\n@@ -9822,7 +9833,7 @@ package body Sem_Ch3 is\n       Discriminant : Entity_Id;\n \n       function Type_With_Explicit_Discrims (Id : Entity_Id) return Entity_Id;\n-      --  Find the nearest type that actually specifies discriminants.\n+      --  Find the nearest type that actually specifies discriminants\n \n       ---------------------------------\n       -- Type_With_Explicit_Discrims --\n@@ -10101,7 +10112,7 @@ package body Sem_Ch3 is\n          T := Empty;\n          Array_Type_Declaration (T, Obj_Def);\n \n-      --  Create an explicit subtype whenever possible.\n+      --  Create an explicit subtype whenever possible\n \n       elsif Nkind (P) /= N_Component_Declaration\n         and then Def_Kind = N_Subtype_Indication\n@@ -10337,7 +10348,7 @@ package body Sem_Ch3 is\n    -- Get_Discriminant_Value --\n    ----------------------------\n \n-   --  This is the situation...\n+   --  This is the situation:\n \n    --  There is a non-derived type\n \n@@ -10709,7 +10720,7 @@ package body Sem_Ch3 is\n             while Present (Discrim) loop\n                Corr_Discrim := Corresponding_Discriminant (Discrim);\n \n-               --  Corr_Discrimm could be missing in an error situation.\n+               --  Corr_Discrimm could be missing in an error situation\n \n                if Present (Corr_Discrim)\n                  and then Original_Record_Component (Corr_Discrim) = Old_C\n@@ -10746,7 +10757,7 @@ package body Sem_Ch3 is\n          Append_Elmt (Derived_Base, Assoc_List);\n       end if;\n \n-      --  Inherit parent discriminants if needed.\n+      --  Inherit parent discriminants if needed\n \n       if Inherit_Discr then\n          Parent_Discrim := First_Discriminant (Parent_Base);\n@@ -10756,7 +10767,7 @@ package body Sem_Ch3 is\n          end loop;\n       end if;\n \n-      --  Create explicit stored discrims for untagged types when necessary.\n+      --  Create explicit stored discrims for untagged types when necessary\n \n       if not Has_Unknown_Discriminants (Derived_Base)\n         and then Has_Discriminants (Parent_Base)\n@@ -11915,7 +11926,7 @@ package body Sem_Ch3 is\n \n          Set_Original_Record_Component (Id, Id);\n \n-         --  Create the discriminal for the discriminant.\n+         --  Create the discriminal for the discriminant\n \n          Build_Discriminal (Id);\n \n@@ -12852,7 +12863,8 @@ package body Sem_Ch3 is\n       --  expanded as part of the freezing actions if it is not a CPP_Class.\n \n       if Is_Tagged then\n-         --  Do not add the tag unless we are in expansion mode.\n+\n+         --  Do not add the tag unless we are in expansion mode\n \n          if Expander_Active then\n             Tag_Comp := Make_Defining_Identifier (Sloc (Def), Name_uTag);"}, {"sha": "2629396cf1b1c0836120e5cb97f465869dce8858", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=ffe9aba81229acba2f9c9a96503dc08ae9a03bb5", "patch": "@@ -324,7 +324,7 @@ package body Sem_Ch4 is\n    procedure Analyze_Allocator (N : Node_Id) is\n       Loc      : constant Source_Ptr := Sloc (N);\n       Sav_Errs : constant Nat        := Serious_Errors_Detected;\n-      E        : Node_Id             := Expression (N);\n+      E        : Node_Id            := Expression (N);\n       Acc_Type : Entity_Id;\n       Type_Id  : Entity_Id;\n \n@@ -498,6 +498,18 @@ package body Sem_Ch4 is\n          Check_Restriction (No_Task_Allocators, N);\n       end if;\n \n+      --  If the No_Streams restriction is set, check that the type of the\n+      --  object is not, and does not contain, any subtype derived from\n+      --  Ada.Streams.Root_Stream_Type. Note that we guard the call to\n+      --  Has_Stream just for efficiency reasons. There is no point in\n+      --  spending time on a Has_Stream check if the restriction is not set.\n+\n+      if Restrictions.Set (No_Streams) then\n+         if Has_Stream (Designated_Type (Acc_Type)) then\n+            Check_Restriction (No_Streams, N);\n+         end if;\n+      end if;\n+\n       Set_Etype (N, Acc_Type);\n \n       if not Is_Library_Level_Entity (Acc_Type) then\n@@ -1662,7 +1674,7 @@ package body Sem_Ch4 is\n             Process_Function_Call;\n \n          elsif Nkind (P) = N_Selected_Component\n-           and then Ekind (Entity (Selector_Name (P))) = E_Function\n+           and then Is_Overloadable (Entity (Selector_Name (P)))\n          then\n             Process_Function_Call;\n \n@@ -2614,11 +2626,11 @@ package body Sem_Ch4 is\n                      or else\n                       (Nkind (Parent_N) = N_Attribute_Reference\n                          and then (Attribute_Name (Parent_N) = Name_First\n-                                    or else\n+                                     or else\n                                    Attribute_Name (Parent_N) = Name_Last\n-                                    or else\n+                                     or else\n                                    Attribute_Name (Parent_N) = Name_Length\n-                                    or else\n+                                     or else\n                                    Attribute_Name (Parent_N) = Name_Range)))\n                then\n                   Set_Etype (N, Etype (Comp));\n@@ -2630,7 +2642,10 @@ package body Sem_Ch4 is\n                --  not make an actual subtype, we end up getting a direct\n                --  reference to a discriminant which will not do.\n \n-               else\n+               --  Comment needs revision, \"in all other cases\" does not\n+               --  reasonably describe the situation below with an elsif???\n+\n+               elsif Expander_Active then\n                   Act_Decl :=\n                     Build_Actual_Subtype_Of_Component (Etype (Comp), N);\n                   Insert_Action (N, Act_Decl);\n@@ -2652,6 +2667,9 @@ package body Sem_Ch4 is\n                         Set_Etype (N, Subt);\n                      end;\n                   end if;\n+\n+               else\n+                  Set_Etype (N, Etype (Comp));\n                end if;\n \n                return;"}, {"sha": "99e10d17b26f5d43676210132c7b0ed9adc95fd2", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 110, "deletions": 2, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe9aba81229acba2f9c9a96503dc08ae9a03bb5/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=ffe9aba81229acba2f9c9a96503dc08ae9a03bb5", "patch": "@@ -1105,12 +1105,111 @@ package body Sem_Ch5 is\n    ------------------------------\n \n    procedure Analyze_Iteration_Scheme (N : Node_Id) is\n+\n+      procedure Process_Bounds (R : Node_Id);\n+      --  If the iteration is given by a range, create temporaries and\n+      --  assignment statements block to capture the bounds and perform\n+      --  required finalization actions in case a bound includes a function\n+      --  call that uses the temporary stack.\n+\n       procedure Check_Controlled_Array_Attribute (DS : Node_Id);\n       --  If the bounds are given by a 'Range reference on a function call\n       --  that returns a controlled array, introduce an explicit declaration\n       --  to capture the bounds, so that the function result can be finalized\n       --  in timely fashion.\n \n+      --------------------\n+      -- Process_Bounds --\n+      --------------------\n+\n+      procedure Process_Bounds (R : Node_Id) is\n+         Loc          : constant Source_Ptr := Sloc (N);\n+         Lo           : constant Node_Id := Low_Bound  (R);\n+         Hi           : constant Node_Id := High_Bound (R);\n+         New_Lo_Bound : Node_Id := Empty;\n+         New_Hi_Bound : Node_Id := Empty;\n+         Typ          : constant Entity_Id := Etype (R);\n+\n+         function One_Bound (Bound : Node_Id) return Node_Id;\n+         --  Create one declaration followed by one assignment statement\n+         --  to capture the value of bound. We create a separate assignment\n+         --  in order to force the creation of a block in case the bound\n+         --  contains a call that uses the secondary stack.\n+\n+         ---------------\n+         -- One_Bound --\n+         ---------------\n+\n+         function One_Bound (Bound : Node_Id) return Node_Id is\n+            Assign : Node_Id;\n+            Id     : Entity_Id;\n+            Decl   : Node_Id;\n+\n+         begin\n+            --  If the bound is a constant or an object, no need for a\n+            --  separate declaration. If the bound is the result of previous\n+            --  expansion it is already analyzed and should not be modified.\n+\n+            if Nkind (Bound) = N_Integer_Literal\n+              or else Is_Entity_Name (Bound)\n+              or else Analyzed (Bound)\n+            then\n+               Resolve (Bound, Typ);\n+               return Bound;\n+            end if;\n+\n+            Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('S'));\n+\n+            Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Id,\n+                Object_Definition   => New_Occurrence_Of (Typ, Loc));\n+\n+            Insert_Before (Parent (N), Decl);\n+            Analyze (Decl);\n+\n+            Assign :=\n+              Make_Assignment_Statement (Loc,\n+                Name        => New_Occurrence_Of (Id, Loc),\n+                Expression  => Relocate_Node (Bound));\n+\n+            Save_Interps (Bound, Expression (Assign));\n+            Insert_Before (Parent (N), Assign);\n+            Analyze (Assign);\n+\n+            Rewrite (Bound, New_Occurrence_Of (Id, Loc));\n+\n+            if Nkind (Assign) = N_Assignment_Statement then\n+               return Expression (Assign);\n+            else\n+               return Bound;\n+            end if;\n+         end One_Bound;\n+\n+      --  Start of processing for Process_Bounds\n+\n+      begin\n+         New_Lo_Bound := One_Bound (Lo);\n+         New_Hi_Bound := One_Bound (Hi);\n+\n+         --  Propagate staticness to loop range itself, in case the\n+         --  corresponding subtype is static.\n+\n+         if New_Lo_Bound /= Lo\n+           and then Is_Static_Expression (New_Lo_Bound)\n+         then\n+            Rewrite  (Low_Bound (R), New_Copy (New_Lo_Bound));\n+         end if;\n+\n+         if New_Hi_Bound /= Hi\n+           and then Is_Static_Expression (New_Hi_Bound)\n+         then\n+            Rewrite (High_Bound (R), New_Copy (New_Hi_Bound));\n+         end if;\n+      end Process_Bounds;\n+\n       --------------------------------------\n       -- Check_Controlled_Array_Attribute --\n       --------------------------------------\n@@ -1212,9 +1311,17 @@ package body Sem_Ch5 is\n                      end if;\n                   end;\n \n-                  --  Now analyze the subtype definition\n+                  --  Now analyze the subtype definition. If it is\n+                  --  a range, create temporaries for bounds.\n \n-                  Analyze (DS);\n+                  if Nkind (DS) = N_Range\n+                    and then Expander_Active\n+                  then\n+                     Pre_Analyze_And_Resolve (DS);\n+                     Process_Bounds (DS);\n+                  else\n+                     Analyze (DS);\n+                  end if;\n \n                   if DS = Error then\n                      return;\n@@ -1238,6 +1345,7 @@ package body Sem_Ch5 is\n                   end if;\n \n                   Check_Controlled_Array_Attribute (DS);\n+\n                   Make_Index (DS, LP);\n \n                   Set_Ekind          (Id, E_Loop_Parameter);"}]}