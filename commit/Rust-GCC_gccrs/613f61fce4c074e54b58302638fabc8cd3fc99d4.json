{"sha": "613f61fce4c074e54b58302638fabc8cd3fc99d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEzZjYxZmNlNGMwNzRlNTRiNTgzMDI2MzhmYWJjOGNkM2ZjOTlkNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-01T09:36:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-01T09:36:21Z"}, "message": "tree-inline.c (estimate_num_insns): For stdarg functions look into call statement to count cost of argument passing.\n\n\t* tree-inline.c (estimate_num_insns): For stdarg functions look\n\tinto call statement to count cost of argument passing.\n\nFrom-SVN: r160094", "tree": {"sha": "704c0786f0c407ecce8fbb45e396f7870526a8bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/704c0786f0c407ecce8fbb45e396f7870526a8bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/613f61fce4c074e54b58302638fabc8cd3fc99d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/613f61fce4c074e54b58302638fabc8cd3fc99d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/613f61fce4c074e54b58302638fabc8cd3fc99d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/613f61fce4c074e54b58302638fabc8cd3fc99d4/comments", "author": null, "committer": null, "parents": [{"sha": "42ad7bc8a55944289250a2a6949df6c404806d66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42ad7bc8a55944289250a2a6949df6c404806d66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42ad7bc8a55944289250a2a6949df6c404806d66"}], "stats": {"total": 21, "additions": 18, "deletions": 3}, "files": [{"sha": "e5ae92ba2dbb796461b2c4dd055038721505e903", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613f61fce4c074e54b58302638fabc8cd3fc99d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613f61fce4c074e54b58302638fabc8cd3fc99d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=613f61fce4c074e54b58302638fabc8cd3fc99d4", "patch": "@@ -1,3 +1,8 @@\n+2010-06-01  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-inline.c (estimate_num_insns): For stdarg functions look\n+\tinto call statement to count cost of argument passing.\n+\n 2010-06-01  Kai Tietz\n \n         * config/i386.c (ix86_output_addr_vec_elt): Make LPREFIX"}, {"sha": "4ac1b3fb71d9d2e15083ffe7b1b5b549717f10cd", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613f61fce4c074e54b58302638fabc8cd3fc99d4/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613f61fce4c074e54b58302638fabc8cd3fc99d4/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=613f61fce4c074e54b58302638fabc8cd3fc99d4", "patch": "@@ -3367,6 +3367,7 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \ttree decl = gimple_call_fndecl (stmt);\n \ttree addr = gimple_call_fn (stmt);\n \ttree funtype = TREE_TYPE (addr);\n+\tbool stdarg = false;\n \n \tif (POINTER_TYPE_P (funtype))\n \t  funtype = TREE_TYPE (funtype);\n@@ -3475,17 +3476,26 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \n \tif (!VOID_TYPE_P (TREE_TYPE (funtype)))\n \t  cost += estimate_move_cost (TREE_TYPE (funtype));\n+\n+\tif (funtype)\n+\t  stdarg = stdarg_p (funtype);\n+\n \t/* Our cost must be kept in sync with\n \t   cgraph_estimate_size_after_inlining that does use function\n-\t   declaration to figure out the arguments.  */\n-\tif (decl && DECL_ARGUMENTS (decl))\n+\t   declaration to figure out the arguments.\n+\n+\t   For functions taking variable list of arguments we must\n+\t   look into call statement intself.  This is safe because\n+\t   we will get only higher costs and in most cases we will\n+\t   not inline these anyway.  */\n+\tif (decl && DECL_ARGUMENTS (decl) && !stdarg)\n \t  {\n \t    tree arg;\n \t    for (arg = DECL_ARGUMENTS (decl); arg; arg = TREE_CHAIN (arg))\n \t      if (!VOID_TYPE_P (TREE_TYPE (arg)))\n \t        cost += estimate_move_cost (TREE_TYPE (arg));\n \t  }\n-\telse if (funtype && prototype_p (funtype))\n+\telse if (funtype && prototype_p (funtype) && !stdarg)\n \t  {\n \t    tree t;\n \t    for (t = TYPE_ARG_TYPES (funtype); t && t != void_list_node;"}]}