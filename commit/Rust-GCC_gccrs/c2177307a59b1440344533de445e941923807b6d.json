{"sha": "c2177307a59b1440344533de445e941923807b6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIxNzczMDdhNTliMTQ0MDM0NDUzM2RlNDQ1ZTk0MTkyMzgwN2I2ZA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-10-08T20:07:04Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-10-08T20:07:04Z"}, "message": "Fix shared library in i386; correctly spell macro in mips.h.\n\nFrom-SVN: r2373", "tree": {"sha": "78c3d28c1b9235dba94807698e726eeaf85064d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78c3d28c1b9235dba94807698e726eeaf85064d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2177307a59b1440344533de445e941923807b6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2177307a59b1440344533de445e941923807b6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2177307a59b1440344533de445e941923807b6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2177307a59b1440344533de445e941923807b6d/comments", "author": null, "committer": null, "parents": [{"sha": "0cd4060d8074f769f4da52629619afc640245c8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cd4060d8074f769f4da52629619afc640245c8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cd4060d8074f769f4da52629619afc640245c8e"}], "stats": {"total": 202, "additions": 128, "deletions": 74}, "files": [{"sha": "dfd8fa6518c5be6b9761a49c26a724708c5c4eda", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2177307a59b1440344533de445e941923807b6d/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2177307a59b1440344533de445e941923807b6d/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=c2177307a59b1440344533de445e941923807b6d", "patch": "@@ -568,18 +568,6 @@\n \n   if (flag_pic && SYMBOLIC_CONST (operands[1]))\n     emit_pic_move (operands, SImode);\n-  else if (HALF_PIC_P()\n-\t   && GET_CODE (operands[0]) == REG\n-           && GET_CODE (operands[1]) == SYMBOL_REF\n-           && HALF_PIC_ADDRESS_P (operands[1]))\n-    {\n-      rtx ptr = HALF_PIC_PTR (operands[1]);\n-      if (XSTR (ptr, 0) != XSTR (operands[1], 0))\n-\t{\n-\t  emit_move_insn (operands[0], gen_rtx (MEM, Pmode, ptr));\n-\t  DONE;\n-\t}\n-    }\n }\")\n \n ;; On i486, incl reg is faster than movl $1,reg.\n@@ -3721,8 +3709,15 @@\n   \"\"\n   \"\n {\n+  rtx addr;\n+\n   if (flag_pic)\n     current_function_uses_pic_offset_table = 1;\n+\n+  /* With half-pic, force the address into a register.  */\n+  addr = XEXP (operands[0], 0);\n+  if (GET_CODE (addr) != REG && HALF_PIC_P () && !CONSTANT_ADDRESS_P (addr))\n+    XEXP (operands[0], 0) = force_reg (Pmode, addr);\n }\")\n \n (define_insn \"\"\n@@ -3748,7 +3743,7 @@\n \t (match_operand:SI 1 \"general_operand\" \"g\"))\n    (set (reg:SI 7) (plus:SI (reg:SI 7)\n \t\t\t    (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n-  \"\"\n+  \"!HALF_PIC_P ()\"\n   \"call %P0\")\n \n (define_expand \"call\"\n@@ -3758,8 +3753,15 @@\n   \"\"\n   \"\n {\n+  rtx addr;\n+\n   if (flag_pic)\n     current_function_uses_pic_offset_table = 1;\n+\n+  /* With half-pic, force the address into a register.  */\n+  addr = XEXP (operands[0], 0);\n+  if (GET_CODE (addr) != REG && HALF_PIC_P () && !CONSTANT_ADDRESS_P (addr))\n+    XEXP (operands[0], 0) = force_reg (Pmode, addr);\n }\")\n \n (define_insn \"\"\n@@ -3783,7 +3785,7 @@\n   [(call (mem:QI (match_operand:SI 0 \"symbolic_operand\" \"\"))\n \t (match_operand:SI 1 \"general_operand\" \"g\"))]\n   ;; Operand 1 not used on the i386.\n-  \"\"\n+  \"!HALF_PIC_P ()\"\n   \"call %P0\")\n \n ;; Call subroutine, returning value in operand 0\n@@ -3799,8 +3801,15 @@\n   \"\"\n   \"\n {\n+  rtx addr;\n+\n   if (flag_pic)\n     current_function_uses_pic_offset_table = 1;\n+\n+  /* With half-pic, force the address into a register.  */\n+  addr = XEXP (operands[1], 0);\n+  if (GET_CODE (addr) != REG && HALF_PIC_P () && !CONSTANT_ADDRESS_P (addr))\n+    XEXP (operands[1], 0) = force_reg (Pmode, addr);\n }\")\n \n (define_insn \"\"\n@@ -3830,7 +3839,7 @@\n \t      (match_operand:SI 2 \"general_operand\" \"g\")))\n    (set (reg:SI 7) (plus:SI (reg:SI 7)\n \t\t\t    (match_operand:SI 4 \"immediate_operand\" \"i\")))]\n-  \"\"\n+  \"!HALF_PIC_P ()\"\n   \"call %P1\")\n \n (define_expand \"call_value\"\n@@ -3841,8 +3850,15 @@\n   \"\"\n   \"\n {\n+  rtx addr;\n+\n   if (flag_pic)\n     current_function_uses_pic_offset_table = 1;\n+\n+  /* With half-pic, force the address into a register.  */\n+  addr = XEXP (operands[1], 0);\n+  if (GET_CODE (addr) != REG && HALF_PIC_P () && !CONSTANT_ADDRESS_P (addr))\n+    XEXP (operands[1], 0) = force_reg (Pmode, addr);\n }\")\n \n (define_insn \"\"\n@@ -3870,7 +3886,7 @@\n \t(call (mem:QI (match_operand:SI 1 \"symbolic_operand\" \"\"))\n \t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n   ;; Operand 2 not used on the i386.\n-  \"\"\n+  \"!HALF_PIC_P ()\"\n   \"call %P1\")\n \n ;; Insn emitted into the body of a function to return from a function."}, {"sha": "f1dbc7f67c4643920f74b4abe598e3029cd342d3", "filename": "gcc/config/i386/osfrose.h", "status": "modified", "additions": 95, "deletions": 57, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2177307a59b1440344533de445e941923807b6d/gcc%2Fconfig%2Fi386%2Fosfrose.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2177307a59b1440344533de445e941923807b6d/gcc%2Fconfig%2Fi386%2Fosfrose.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosfrose.h?ref=c2177307a59b1440344533de445e941923807b6d", "patch": "@@ -37,9 +37,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define TARGET_DEBUG\t(target_flags & MASK_HALF_PIC_DEBUG)\n #define HALF_PIC_DEBUG\tTARGET_DEBUG\n \n-#ifdef SUBTARGET_SWITCHES\n-#undef SUBTARGET_SWITCHES\n-#endif\n+#undef\tSUBTARGET_SWITCHES\n #define SUBTARGET_SWITCHES \\\n      { \"half-pic\",\t MASK_HALF_PIC},\t\t\t\t\\\n      { \"no-half-pic\",\t-MASK_HALF_PIC},\t\t\t\t\\\n@@ -56,14 +54,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define IDENTIFIER_SUFFIX \"\"\n \n /* Change default predefines.  */\n-#ifdef CPP_PREDEFINES\n-#undef CPP_PREDEFINES\n-#endif\n+#undef\tCPP_PREDEFINES\n #define CPP_PREDEFINES \"-DOSF -DOSF1 -Dunix -Di386\"\n \n-#ifdef  CPP_SPEC\n #undef  CPP_SPEC\n-#endif\n #define CPP_SPEC \"\\\n %{.S:\t-D__LANGUAGE_ASSEMBLY %{!ansi:-DLANGUAGE_ASSEMBLY}} \\\n %{.cc:\t-D__LANGUAGE_C_PLUS_PLUS} \\\n@@ -72,11 +66,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n %{.m:\t-D__LANGUAGE_OBJECTIVE_C} \\\n %{!.S:\t-D__LANGUAGE_C %{!ansi:-DLANGUAGE_C}}\"\n \n-#ifdef  CC1_SPEC\n-#undef  CC1_SPEC\n-#endif\n-\n /* Turn on -mpic-extern by default.  */\n+#undef  CC1_SPEC\n #define CC1_SPEC \"\\\n %{gline:%{!g:%{!g0:%{!g1:%{!g2: -g1}}}}} \\\n %{pic-none:   -mno-half-pic} \\\n@@ -85,32 +76,21 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n %{pic-calls:  -mhalf-pic} \\\n %{!pic-*:     -mhalf-pic}\"\n \n-#ifdef ASM_SPEC\n-#undef ASM_SPEC\n-#endif\n+#undef\tASM_SPEC\n #define ASM_SPEC       \"\"\n \n-#ifdef  LINK_SPEC\n #undef  LINK_SPEC\n-#endif\n #define LINK_SPEC      \"%{v*: -v}                           \\\n \t               %{!noshrlib: %{pic-none: -noshrlib} %{!pic-none: -warn_nopic}} \\\n \t               %{nostdlib} %{noshrlib} %{glue}\"\n \n-#ifdef  LIB_SPEC\n #undef  LIB_SPEC\n-#endif\n-\n #define LIB_SPEC \"-lc\"\n \n-#ifdef  LIBG_SPEC\n #undef  LIBG_SPEC\n-#endif\n-#define LIBG_SPEC      \"\"\n+#define LIBG_SPEC \"\"\n \n-#ifdef  STARTFILE_SPEC\n #undef  STARTFILE_SPEC\n-#endif\n #define STARTFILE_SPEC \"%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\"\n \n #undef TARGET_VERSION_INTERNAL\n@@ -121,14 +101,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define TARGET_VERSION_INTERNAL(STREAM) fputs (I386_VERSION, STREAM)\n #define TARGET_VERSION TARGET_VERSION_INTERNAL (stderr)\n \n-#ifdef  MD_EXEC_PREFIX\n #undef  MD_EXEC_PREFIX\n-#endif\n #define MD_EXEC_PREFIX\t\t\"/usr/ccs/gcc/\"\n \n-#ifdef  MD_STARTFILE_PREFIX\n #undef  MD_STARTFILE_PREFIX\n-#endif\n #define MD_STARTFILE_PREFIX\t\"/usr/ccs/lib/\"\n \n /* Tell final.c we don't need a label passed to mcount.  */\n@@ -165,18 +141,26 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    `high' expressions and `const' arithmetic expressions, in\n    addition to `const_int' and `const_double' expressions.  */\n \n-#ifdef CONSTANT_ADDRESS_P\n-#undef CONSTANT_ADDRESS_P\n-#endif\n+#undef\tCONSTANT_ADDRESS_P\n #define CONSTANT_ADDRESS_P(X)                                           \\\n   (CONSTANT_P (X) && (!HALF_PIC_P () || !HALF_PIC_ADDRESS_P (X)))\n \n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#undef\tLEGITIMATE_CONSTANT_P\n+#define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\t\\\n+  (!HALF_PIC_P ()\t\t\t\t\t\t\t\\\n+   || GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n+   || GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n+   || !HALF_PIC_ADDRESS_P (X))\n+\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.\n    The MODE argument is the machine mode for the MEM expression\n    that wants to use this address. */\n \n-#undef GO_IF_LEGITIMATE_ADDRESS\n+#undef\tGO_IF_LEGITIMATE_ADDRESS\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if (CONSTANT_P (X))\t\t\t\t\t\t\t\\\n@@ -240,9 +224,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    the definition of `GO_IF_LEGITIMATE_ADDRESS' or\n    `PRINT_OPERAND_ADDRESS'. */\n \n-#ifdef ENCODE_SECTION_INFO\n-#undef ENCODE_SECTION_INFO\n-#endif\n+#undef\tENCODE_SECTION_INFO\n #define ENCODE_SECTION_INFO(DECL)\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n@@ -252,6 +234,39 @@ do\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n \n+/* Given a decl node or constant node, choose the section to output it in\n+   and select that section.  */\n+\n+#undef\tSELECT_RTX_SECTION\n+#define SELECT_RTX_SECTION(MODE, RTX)\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (MODE == Pmode && HALF_PIC_P () && HALF_PIC_ADDRESS_P (RTX))\t\\\n+      data_section ();\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      readonly_data_section ();\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+#undef\tSELECT_SECTION\n+#define SELECT_SECTION(DECL,RELOC)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (flag_writable_strings)\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\treadonly_data_section ();\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (DECL) != VAR_DECL)\t\t\t\t\\\n+    readonly_data_section ();\t\t\t\t\t\t\\\n+  else if (!TREE_READONLY (DECL))\t\t\t\t\t\\\n+    data_section ();\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    readonly_data_section ();\t\t\t\t\t\t\\\n+}\n+\n+\n /* A C statement (sans semicolon) to output to the stdio stream\n    STREAM any text necessary for declaring the name NAME of an\n    initialized variable which is being defined.  This macro must\n@@ -262,9 +277,7 @@ while (0)\n    If this macro is not defined, then the variable name is defined\n    in the usual manner as a label (by means of `ASM_OUTPUT_LABEL').  */\n \n-#ifdef ASM_DECLARE_OBJECT_NAME\n-#undef ASM_DECLARE_OBJECT_NAME\n-#endif\n+#undef\tASM_DECLARE_OBJECT_NAME\n #define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL)\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n  {\t\t\t\t\t\t\t\t\t\\\n@@ -314,28 +327,46 @@ while (0)\n \n /* This is how to output an assembler line defining a `double' constant.  */\n \n-#ifdef ASM_OUTPUT_DOUBLE\n-#undef ASM_OUTPUT_DOUBLE\n+#undef\tASM_OUTPUT_DOUBLE\n+\n+#ifndef\tCROSS_COMPILE\n+#define\tASM_OUTPUT_DOUBLE(STREAM, VALUE)\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    long value_long[2];\t\t\t\t\t\t\t\\\n+    REAL_VALUE_TO_TARGET_DOUBLE (VALUE, value_long);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.long\\t0x%08lx\\t\\t# %.20g\\n\\t.long\\t0x%08lx\\n\",\t\\\n+\t   value_long[0], VALUE, value_long[1]);\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+#else\n+#define\tASM_OUTPUT_DOUBLE(STREAM, VALUE)\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.double\\t%.20g\\n\", VALUE)\n #endif\n-#define ASM_OUTPUT_DOUBLE(STREAM,VALUE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  union { double d; long l[2]; } u2;\t\t\t\t\t\\\n-  u2.d = VALUE;\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.long\\t0x%08lx\\t\\t# %.20g\\n\\t.long\\t0x%08lx\\n\",\t\\\n-\t   u2.l[0], u2.d, u2.l[1]);\t\t\t\t\t\\\n-}\n \n /* This is how to output an assembler line defining a `float' constant.  */\n \n-#ifdef ASM_OUTPUT_FLOAT\n-#undef ASM_OUTPUT_FLOAT\n+#undef\tASM_OUTPUT_FLOAT\n+\n+#ifndef\tCROSS_COMPILE\n+#define\tASM_OUTPUT_FLOAT(STREAM, VALUE)\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    long value_long;\t\t\t\t\t\t\t\\\n+    REAL_VALUE_TO_TARGET_SINGLE (VALUE, value_long);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.long\\t0x%08lx\\t\\t# %.12g (float)\\n\",\t\t\\\n+\t   value_long, VALUE);\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+#else\n+#define\tASM_OUTPUT_FLOAT(STREAM, VALUE)\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.float\\t%.12g\\n\", VALUE)\n #endif\n-#define ASM_OUTPUT_FLOAT(STREAM,VALUE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  union { float f; long l; } u2;\t\t\t\t\t\\\n-  u2.f = VALUE;\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.long\\t0x%08lx\\t\\t# %.12g\\n\", u2.l, u2.f);\t\\\n-}\n+\n \n /* Generate calls to memcpy, etc., not bcopy, etc. */\n #define TARGET_MEM_FUNCTIONS\n@@ -344,6 +375,10 @@ while (0)\n \f\n /* Defines to be able to build libgcc.a with GCC.  */\n \n+/* It might seem that these are not important, since gcc 2 will never\n+   call libgcc for these functions.  But programs might be linked with\n+   code compiled by gcc 1, and then these will be used.  */\n+\n #define perform_udivsi3(a,b)\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   register int dx asm(\"dx\");\t\t\t\t\t\t\\\n@@ -391,15 +426,18 @@ while (0)\n   auto unsigned short ostatus;\t\t\t\t\t\t\\\n   auto unsigned short nstatus;\t\t\t\t\t\t\\\n   auto int ret;\t\t\t\t\t\t\t\t\\\n+  auto double tmp;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   &ostatus;\t\t\t/* guarantee these land in memory */\t\\\n   &nstatus;\t\t\t\t\t\t\t\t\\\n   &ret;\t\t\t\t\t\t\t\t\t\\\n+  &tmp;\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   asm volatile (\"fnstcw %0\" : \"=m\" (ostatus));\t\t\t\t\\\n   nstatus = ostatus | 0x0c00;\t\t\t\t\t\t\\\n   asm volatile (\"fldcw %0\" : /* no outputs */ : \"m\" (nstatus));\t\t\\\n-  asm volatile (\"fldl %0\" : /* no outputs */ : \"m\" (a));\t\t\\\n+  tmp = a;\t\t\t\t\t\t\t\t\\\n+  asm volatile (\"fldl %0\" : /* no outputs */ : \"m\" (tmp));\t\t\\\n   asm volatile (\"fistpl %0\" : \"=m\" (ret));\t\t\t\t\\\n   asm volatile (\"fldcw %0\" : /* no outputs */ : \"m\" (ostatus));\t\t\\\n \t\t\t\t\t\t\t\t\t\\"}, {"sha": "7d3f1065e82e03e6a91e798ffc787a05292bf01b", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2177307a59b1440344533de445e941923807b6d/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2177307a59b1440344533de445e941923807b6d/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=c2177307a59b1440344533de445e941923807b6d", "patch": "@@ -3341,7 +3341,7 @@ rdata_section ()\t\t\t\t\t\t\t\\\n /* Given a decl node or constant node, choose the section to output it in\n    and select that section.  */\n \n-#define SELECT_SECTION_MODE(MODE,RTX)\t\t\t\t\t\\\n+#define SELECT_RTX_SECTION(MODE,RTX)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if ((GET_MODE_SIZE(MODE) / BITS_PER_UNIT) <= mips_section_threshold\t\\\n       && mips_section_threshold > 0)\t\t\t\t\t\\"}]}