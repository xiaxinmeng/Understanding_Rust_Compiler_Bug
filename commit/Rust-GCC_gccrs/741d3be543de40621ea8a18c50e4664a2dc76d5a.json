{"sha": "741d3be543de40621ea8a18c50e4664a2dc76d5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQxZDNiZTU0M2RlNDA2MjFlYThhMThjNTBlNDY2NGEyZGM3NmQ1YQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-07-11T16:02:20Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-07-11T16:02:20Z"}, "message": "input.c: add lexing selftests and a test matrix for line_table states\n\nThis patch adds explicit testing of lexing a source file,\ngeneralizing this (and the test of ordinary line maps) over\na 2-dimensional test matrix covering:\n\n  (1) line_table->default_range_bits: some frontends use a non-zero value\n  and others use zero\n\n  (2) the fallback modes within line-map.c: there are various threshold\n  values for source_location/location_t beyond line-map.c changes\n  behavior (disabling of the range-packing optimization, disabling\n  of column-tracking).  We exercise these by starting the line_table\n  at interesting values at or near these thresholds.\n\nThis helps ensures that location data works in all of these states,\nand that (I hope) we don't have lingering bugs relating to the\ntransition between line_table states.\n\ngcc/ChangeLog:\n\t* input.c: Include cpplib.h.\n\t(selftest::temp_source_file): New class.\n\t(selftest::temp_source_file::temp_source_file): New ctor.\n\t(selftest::temp_source_file::~temp_source_file): New dtor.\n\t(selftest::should_have_column_data_p): New function.\n\t(selftest::test_should_have_column_data_p): New function.\n\t(selftest::temp_line_table): New class.\n\t(selftest::temp_line_table::temp_line_table): New ctor.\n\t(selftest::temp_line_table::~temp_line_table): New dtor.\n\t(selftest::test_accessing_ordinary_linemaps): Add case_ param; use\n\tit to create a temp_line_table.\n\t(selftest::assert_loceq): Only verify LOCATION_COLUMN for\n\tlocations that are known to have column data.\n\t(selftest::line_table_case): New struct.\n\t(selftest::test_reading_source_line): Move tempfile handling\n\tto class temp_source_file.\n\t(ASSERT_TOKEN_AS_TEXT_EQ): New macro.\n\t(selftest::assert_token_loc_eq): New function.\n\t(ASSERT_TOKEN_LOC_EQ): New macro.\n\t(selftest::test_lexer): New function.\n\t(selftest::boundary_locations): New array.\n\t(selftest::input_c_tests): Call test_should_have_column_data_p.\n\tLoop over a test matrix of interesting values of location and\n\tdefault_range_bits, calling test_lexer on each case in the matrix.\n\tMove call to test_accessing_ordinary_linemaps into the matrix.\n\t* selftest.h (ASSERT_EQ): Reimplement in terms of...\n\t(ASSERT_EQ_AT): New macro.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/plugin/location_overflow_plugin.c (plugin_init): Avoid\n\thardcoding the values of LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES\n\tand LINE_MAP_MAX_LOCATION_WITH_COLS.\n\nlibcpp/ChangeLog:\n\t* include/line-map.h (LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES):\n\tMove here from line-map.c.\n\t(LINE_MAP_MAX_LOCATION_WITH_COLS): Likewise.\n\t* line-map.c (LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES): Move from\n\there to line-map.h.\n\t(LINE_MAP_MAX_LOCATION_WITH_COLS): Likewise.\n\nFrom-SVN: r238213", "tree": {"sha": "62b14ee9ae7d25092b5db8ab48c08fccc2eab016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62b14ee9ae7d25092b5db8ab48c08fccc2eab016"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/741d3be543de40621ea8a18c50e4664a2dc76d5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/741d3be543de40621ea8a18c50e4664a2dc76d5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/741d3be543de40621ea8a18c50e4664a2dc76d5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/741d3be543de40621ea8a18c50e4664a2dc76d5a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "92fa45b59861c0fc83ecece2b46c4bbb441c03c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92fa45b59861c0fc83ecece2b46c4bbb441c03c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92fa45b59861c0fc83ecece2b46c4bbb441c03c4"}], "stats": {"total": 407, "additions": 373, "deletions": 34}, "files": [{"sha": "c17f388437892bb6e44d0b761b2cff483e16c2fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/741d3be543de40621ea8a18c50e4664a2dc76d5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/741d3be543de40621ea8a18c50e4664a2dc76d5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=741d3be543de40621ea8a18c50e4664a2dc76d5a", "patch": "@@ -1,3 +1,33 @@\n+2016-07-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* input.c: Include cpplib.h.\n+\t(selftest::temp_source_file): New class.\n+\t(selftest::temp_source_file::temp_source_file): New ctor.\n+\t(selftest::temp_source_file::~temp_source_file): New dtor.\n+\t(selftest::should_have_column_data_p): New function.\n+\t(selftest::test_should_have_column_data_p): New function.\n+\t(selftest::temp_line_table): New class.\n+\t(selftest::temp_line_table::temp_line_table): New ctor.\n+\t(selftest::temp_line_table::~temp_line_table): New dtor.\n+\t(selftest::test_accessing_ordinary_linemaps): Add case_ param; use\n+\tit to create a temp_line_table.\n+\t(selftest::assert_loceq): Only verify LOCATION_COLUMN for\n+\tlocations that are known to have column data.\n+\t(selftest::line_table_case): New struct.\n+\t(selftest::test_reading_source_line): Move tempfile handling\n+\tto class temp_source_file.\n+\t(ASSERT_TOKEN_AS_TEXT_EQ): New macro.\n+\t(selftest::assert_token_loc_eq): New function.\n+\t(ASSERT_TOKEN_LOC_EQ): New macro.\n+\t(selftest::test_lexer): New function.\n+\t(selftest::boundary_locations): New array.\n+\t(selftest::input_c_tests): Call test_should_have_column_data_p.\n+\tLoop over a test matrix of interesting values of location and\n+\tdefault_range_bits, calling test_lexer on each case in the matrix.\n+\tMove call to test_accessing_ordinary_linemaps into the matrix.\n+\t* selftest.h (ASSERT_EQ): Reimplement in terms of...\n+\t(ASSERT_EQ_AT): New macro.\n+\n 2016-07-11  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/71801"}, {"sha": "a916597a78c35423f91074bf7133620ece455287", "filename": "gcc/input.c", "status": "modified", "additions": 307, "deletions": 17, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/741d3be543de40621ea8a18c50e4664a2dc76d5a/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/741d3be543de40621ea8a18c50e4664a2dc76d5a/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=741d3be543de40621ea8a18c50e4664a2dc76d5a", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"diagnostic-core.h\"\n #include \"selftest.h\"\n+#include \"cpplib.h\"\n \n /* This is a cache used by get_next_line to store the content of a\n    file to be searched for file lines.  */\n@@ -1144,6 +1145,74 @@ namespace selftest {\n \n /* Selftests of location handling.  */\n \n+/* A class for writing out a temporary sourcefile for use in selftests\n+   of input handling.  */\n+\n+class temp_source_file\n+{\n+ public:\n+  temp_source_file (const location &loc, const char *suffix,\n+\t\t    const char *content);\n+  ~temp_source_file ();\n+\n+  const char *get_filename () const { return m_filename; }\n+\n+ private:\n+  char *m_filename;\n+};\n+\n+/* Constructor.  Create a tempfile using SUFFIX, and write CONTENT to\n+   it.  Abort if anything goes wrong, using LOC as the effective\n+   location in the problem report.  */\n+\n+temp_source_file::temp_source_file (const location &loc, const char *suffix,\n+\t\t\t\t    const char *content)\n+{\n+  m_filename = make_temp_file (suffix);\n+  ASSERT_NE (m_filename, NULL);\n+\n+  FILE *out = fopen (m_filename, \"w\");\n+  if (!out)\n+    ::selftest::fail_formatted (loc, \"unable to open tempfile: %s\",\n+\t\t\t\tm_filename);\n+  fprintf (out, content);\n+  fclose (out);\n+}\n+\n+/* Destructor.  Delete the tempfile.  */\n+\n+temp_source_file::~temp_source_file ()\n+{\n+  unlink (m_filename);\n+  free (m_filename);\n+}\n+\n+/* Helper function for verifying location data: when location_t\n+   values are > LINE_MAP_MAX_LOCATION_WITH_COLS, they are treated\n+   as having column 0.  */\n+\n+static bool\n+should_have_column_data_p (location_t loc)\n+{\n+  if (IS_ADHOC_LOC (loc))\n+    loc = get_location_from_adhoc_loc (line_table, loc);\n+  if (loc > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return false;\n+  return true;\n+}\n+\n+/* Selftest for should_have_column_data_p.  */\n+\n+static void\n+test_should_have_column_data_p ()\n+{\n+  ASSERT_TRUE (should_have_column_data_p (RESERVED_LOCATION_COUNT));\n+  ASSERT_TRUE\n+    (should_have_column_data_p (LINE_MAP_MAX_LOCATION_WITH_COLS));\n+  ASSERT_FALSE\n+    (should_have_column_data_p (LINE_MAP_MAX_LOCATION_WITH_COLS + 1));\n+}\n+\n /* Verify the result of LOCATION_FILE/LOCATION_LINE/LOCATION_COLUMN\n    on LOC.  */\n \n@@ -1153,14 +1222,87 @@ assert_loceq (const char *exp_filename, int exp_linenum, int exp_colnum,\n {\n   ASSERT_STREQ (exp_filename, LOCATION_FILE (loc));\n   ASSERT_EQ (exp_linenum, LOCATION_LINE (loc));\n-  ASSERT_EQ (exp_colnum, LOCATION_COLUMN (loc));\n+  /* If location_t values are sufficiently high, then column numbers\n+     will be unavailable and LOCATION_COLUMN (loc) will be 0.\n+     When close to the threshold, column numbers *may* be present: if\n+     the final linemap before the threshold contains a line that straddles\n+     the threshold, locations in that line have column information.  */\n+  if (should_have_column_data_p (loc))\n+    ASSERT_EQ (exp_colnum, LOCATION_COLUMN (loc));\n+}\n+\n+/* Various selftests in this file involve constructing a line table\n+   and one or more line maps within it.\n+\n+   For maximum test coverage we want to run these tests with a variety\n+   of situations:\n+   - line_table->default_range_bits: some frontends use a non-zero value\n+   and others use zero\n+   - the fallback modes within line-map.c: there are various threshold\n+   values for source_location/location_t beyond line-map.c changes\n+   behavior (disabling of the range-packing optimization, disabling\n+   of column-tracking).  We can exercise these by starting the line_table\n+   at interesting values at or near these thresholds.\n+\n+   The following struct describes a particular case within our test\n+   matrix.  */\n+\n+struct line_table_case\n+{\n+  line_table_case (int default_range_bits, int base_location)\n+  : m_default_range_bits (default_range_bits),\n+    m_base_location (base_location)\n+  {}\n+\n+  int m_default_range_bits;\n+  int m_base_location;\n+};\n+\n+/* A class for overriding the global \"line_table\" within a selftest,\n+   restoring its value afterwards.  */\n+\n+class temp_line_table\n+{\n+ public:\n+  temp_line_table (const line_table_case &);\n+  ~temp_line_table ();\n+\n+ private:\n+  line_maps *m_old_line_table;\n+};\n+\n+/* Constructor.  Store the old value of line_table, and create a new\n+   one, using the sitation described in CASE_.  */\n+\n+temp_line_table::temp_line_table (const line_table_case &case_)\n+  : m_old_line_table (line_table)\n+{\n+  line_table = ggc_alloc<line_maps> ();\n+  linemap_init (line_table, BUILTINS_LOCATION);\n+  line_table->reallocator = m_old_line_table->reallocator;\n+  line_table->round_alloc_size = m_old_line_table->round_alloc_size;\n+  line_table->default_range_bits = case_.m_default_range_bits;\n+  if (case_.m_base_location)\n+    {\n+      line_table->highest_location = case_.m_base_location;\n+      line_table->highest_line = case_.m_base_location;\n+    }\n+}\n+\n+/* Destructor.  Restore the old value of line_table.  */\n+\n+temp_line_table::~temp_line_table ()\n+{\n+  line_table = m_old_line_table;\n }\n \n /* Verify basic operation of ordinary linemaps.  */\n \n static void\n-test_accessing_ordinary_linemaps ()\n+test_accessing_ordinary_linemaps (const line_table_case &case_)\n {\n+  temp_line_table tmp_lt (case_);\n+\n   /* Build a simple linemap describing some locations. */\n   linemap_add (line_table, LC_ENTER, false, \"foo.c\", 0);\n \n@@ -1220,21 +1362,15 @@ static void\n test_reading_source_line ()\n {\n   /* Create a tempfile and write some text to it.  */\n-  char *filename = make_temp_file (\".txt\");\n-  ASSERT_NE (filename, NULL);\n-  FILE *out = fopen (filename, \"w\");\n-  if (!out)\n-    ::selftest::fail_formatted (SELFTEST_LOCATION,\n-\t\t\t\t\"unable to open tempfile: %s\", filename);\n-  fprintf (out,\n-\t   \"01234567890123456789\\n\"\n-\t   \"This is the test text\\n\"\n-\t   \"This is the 3rd line\\n\");\n-  fclose (out);\n+  temp_source_file tmp (SELFTEST_LOCATION, \".txt\",\n+\t\t\t\"01234567890123456789\\n\"\n+\t\t\t\"This is the test text\\n\"\n+\t\t\t\"This is the 3rd line\\n\");\n \n   /* Read back a specific line from the tempfile.  */\n   int line_size;\n-  const char *source_line = location_get_source_line (filename, 2, &line_size);\n+  const char *source_line = location_get_source_line (tmp.get_filename (),\n+\t\t\t\t\t\t      2, &line_size);\n   ASSERT_TRUE (source_line != NULL);\n   ASSERT_EQ (21, line_size);\n   if (!strncmp (\"This is the test text\",\n@@ -1245,18 +1381,172 @@ test_reading_source_line ()\n     ::selftest::fail (SELFTEST_LOCATION,\n \t\t      \"source_line did not match expected value\");\n \n-  unlink (filename);\n-  free (filename);\n }\n \n+/* Tests of lexing.  */\n+\n+/* Verify that token TOK from PARSER has cpp_token_as_text\n+   equal to EXPECTED_TEXT.  */\n+\n+#define ASSERT_TOKEN_AS_TEXT_EQ(PARSER, TOK, EXPECTED_TEXT)\t\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    unsigned char *actual_txt = cpp_token_as_text ((PARSER), (TOK));\t\\\n+    ASSERT_STREQ ((EXPECTED_TEXT), (const char *)actual_txt);\t\t\\\n+  SELFTEST_END_STMT\n+\n+/* Verify that TOK's src_loc is within EXP_FILENAME at EXP_LINENUM,\n+   and ranges from EXP_START_COL to EXP_FINISH_COL.\n+   Use LOC as the effective location of the selftest.  */\n+\n+static void\n+assert_token_loc_eq (const location &loc,\n+\t\t     const cpp_token *tok,\n+\t\t     const char *exp_filename, int exp_linenum,\n+\t\t     int exp_start_col, int exp_finish_col)\n+{\n+  location_t tok_loc = tok->src_loc;\n+  ASSERT_STREQ_AT (loc, exp_filename, LOCATION_FILE (tok_loc));\n+  ASSERT_EQ_AT (loc, exp_linenum, LOCATION_LINE (tok_loc));\n+\n+  /* If location_t values are sufficiently high, then column numbers\n+     will be unavailable.  */\n+  if (!should_have_column_data_p (tok_loc))\n+    return;\n+\n+  ASSERT_EQ_AT (loc, exp_start_col, LOCATION_COLUMN (tok_loc));\n+  source_range tok_range = get_range_from_loc (line_table, tok_loc);\n+  ASSERT_EQ_AT (loc, exp_start_col, LOCATION_COLUMN (tok_range.m_start));\n+  ASSERT_EQ_AT (loc, exp_finish_col, LOCATION_COLUMN (tok_range.m_finish));\n+}\n+\n+/* Use assert_token_loc_eq to verify the TOK->src_loc, using\n+   SELFTEST_LOCATION as the effective location of the selftest.  */\n+\n+#define ASSERT_TOKEN_LOC_EQ(TOK, EXP_FILENAME, EXP_LINENUM, \\\n+\t\t\t    EXP_START_COL, EXP_FINISH_COL) \\\n+  assert_token_loc_eq (SELFTEST_LOCATION, (TOK), (EXP_FILENAME), \\\n+\t\t       (EXP_LINENUM), (EXP_START_COL), (EXP_FINISH_COL))\n+\n+/* Test of lexing a file using libcpp, verifying tokens and their\n+   location information.  */\n+\n+static void\n+test_lexer (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.  */\n+  const char *content =\n+    /*00000000011111111112222222222333333.3333444444444.455555555556\n+      12345678901234567890123456789012345.6789012345678.901234567890.  */\n+    (\"test_name /* c-style comment */\\n\"\n+     \"                                  \\\"test literal\\\"\\n\"\n+     \" // test c++-style comment\\n\"\n+     \"   42\\n\");\n+  temp_source_file tmp (SELFTEST_LOCATION, \".txt\", content);\n+\n+  temp_line_table tmp_lt (case_);\n+\n+  cpp_reader *parser = cpp_create_reader (CLK_GNUC89, NULL, line_table);\n+\n+  const char *fname = cpp_read_main_file (parser, tmp.get_filename ());\n+  ASSERT_NE (fname, NULL);\n+\n+  /* Verify that we get the expected tokens back, with the correct\n+     location information.  */\n+\n+  location_t loc;\n+  const cpp_token *tok;\n+  tok = cpp_get_token_with_location (parser, &loc);\n+  ASSERT_NE (tok, NULL);\n+  ASSERT_EQ (tok->type, CPP_NAME);\n+  ASSERT_TOKEN_AS_TEXT_EQ (parser, tok, \"test_name\");\n+  ASSERT_TOKEN_LOC_EQ (tok, tmp.get_filename (), 1, 1, 9);\n+\n+  tok = cpp_get_token_with_location (parser, &loc);\n+  ASSERT_NE (tok, NULL);\n+  ASSERT_EQ (tok->type, CPP_STRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ (parser, tok, \"\\\"test literal\\\"\");\n+  ASSERT_TOKEN_LOC_EQ (tok, tmp.get_filename (), 2, 35, 48);\n+\n+  tok = cpp_get_token_with_location (parser, &loc);\n+  ASSERT_NE (tok, NULL);\n+  ASSERT_EQ (tok->type, CPP_NUMBER);\n+  ASSERT_TOKEN_AS_TEXT_EQ (parser, tok, \"42\");\n+  ASSERT_TOKEN_LOC_EQ (tok, tmp.get_filename (), 4, 4, 5);\n+\n+  tok = cpp_get_token_with_location (parser, &loc);\n+  ASSERT_NE (tok, NULL);\n+  ASSERT_EQ (tok->type, CPP_EOF);\n+\n+  cpp_finish (parser, NULL);\n+  cpp_destroy (parser);\n+}\n+\n+/* A table of interesting location_t values, giving one axis of our test\n+   matrix.  */\n+\n+static const location_t boundary_locations[] = {\n+  /* Zero means \"don't override the default values for a new line_table\".  */\n+  0,\n+\n+  /* An arbitrary non-zero value that isn't close to one of\n+     the boundary values below.  */\n+  0x10000,\n+\n+  /* Values near LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES.  */\n+  LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES - 0x100,\n+  LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES - 1,\n+  LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES,\n+  LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES + 1,\n+  LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES + 0x100,\n+\n+  /* Values near LINE_MAP_MAX_LOCATION_WITH_COLS.  */\n+  LINE_MAP_MAX_LOCATION_WITH_COLS - 0x100,\n+  LINE_MAP_MAX_LOCATION_WITH_COLS - 1,\n+  LINE_MAP_MAX_LOCATION_WITH_COLS,\n+  LINE_MAP_MAX_LOCATION_WITH_COLS + 1,\n+  LINE_MAP_MAX_LOCATION_WITH_COLS + 0x100,\n+};\n+\n /* Run all of the selftests within this file.  */\n \n void\n input_c_tests ()\n {\n-  test_accessing_ordinary_linemaps ();\n+  test_should_have_column_data_p ();\n   test_unknown_location ();\n   test_builtins ();\n+\n+  /* As noted above in the description of struct line_table_case,\n+     we want to explore a test matrix of interesting line_table\n+     situations, running various selftests for each case within the\n+     matrix.  */\n+\n+  /* Run all tests with:\n+     (a) line_table->default_range_bits == 0, and\n+     (b) line_table->default_range_bits == 5.  */\n+  int num_cases_tested = 0;\n+  for (int default_range_bits = 0; default_range_bits <= 5;\n+       default_range_bits += 5)\n+    {\n+      /* ...and use each of the \"interesting\" location values as\n+\t the starting location within line_table.  */\n+      const int num_boundary_locations\n+\t= sizeof (boundary_locations) / sizeof (boundary_locations[0]);\n+      for (int loc_idx = 0; loc_idx < num_boundary_locations; loc_idx++)\n+\t{\n+\t  line_table_case c (default_range_bits, boundary_locations[loc_idx]);\n+\n+\t  /* Run all tests for the given case within the test matrix.  */\n+\t  test_accessing_ordinary_linemaps (c);\n+\t  test_lexer (c);\n+\n+\t  num_cases_tested++;\n+\t}\n+    }\n+\n+  /* Verify that we fully covered the test matrix.  */\n+  ASSERT_EQ (num_cases_tested, 2 * 12);\n+\n   test_reading_source_line ();\n }\n "}, {"sha": "967e76bd2c8d333740e28b1526d832bc66a30c5c", "filename": "gcc/selftest.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/741d3be543de40621ea8a18c50e4664a2dc76d5a/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/741d3be543de40621ea8a18c50e4664a2dc76d5a/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=741d3be543de40621ea8a18c50e4664a2dc76d5a", "patch": "@@ -129,13 +129,19 @@ extern int num_passes;\n    ::selftest::pass if they are equal,\n    ::selftest::fail if they are non-equal.  */\n \n-#define ASSERT_EQ(EXPECTED, ACTUAL)\t\t\t       \\\n+#define ASSERT_EQ(EXPECTED, ACTUAL) \\\n+  ASSERT_EQ_AT ((SELFTEST_LOCATION), (EXPECTED), (ACTUAL))\n+\n+/* Like ASSERT_EQ, but treat LOC as the effective location of the\n+   selftest.  */\n+\n+#define ASSERT_EQ_AT(LOC, EXPECTED, ACTUAL)\t\t       \\\n   SELFTEST_BEGIN_STMT\t\t\t\t\t       \\\n   const char *desc = \"ASSERT_EQ (\" #EXPECTED \", \" #ACTUAL \")\"; \\\n   if ((EXPECTED) == (ACTUAL))\t\t\t\t       \\\n-    ::selftest::pass (SELFTEST_LOCATION, desc);\t\t\t       \\\n+    ::selftest::pass ((LOC), desc);\t\t\t       \\\n   else\t\t\t\t\t\t\t       \\\n-    ::selftest::fail (SELFTEST_LOCATION, desc);\t\t\t       \\\n+    ::selftest::fail ((LOC), desc);\t\t\t       \\\n   SELFTEST_END_STMT\n \n /* Evaluate EXPECTED and ACTUAL and compare them with !=, calling"}, {"sha": "b4ddd499777396f38b451b9f22ef4003f0e72c65", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/741d3be543de40621ea8a18c50e4664a2dc76d5a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/741d3be543de40621ea8a18c50e4664a2dc76d5a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=741d3be543de40621ea8a18c50e4664a2dc76d5a", "patch": "@@ -1,3 +1,9 @@\n+2016-07-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/plugin/location_overflow_plugin.c (plugin_init): Avoid\n+\thardcoding the values of LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES\n+\tand LINE_MAP_MAX_LOCATION_WITH_COLS.\n+\n 2016-07-11  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/71801"}, {"sha": "3644d9fd82e9c107d6b86ec5c5d5a4c4d6b7e727", "filename": "gcc/testsuite/gcc.dg/plugin/location_overflow_plugin.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/741d3be543de40621ea8a18c50e4664a2dc76d5a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flocation_overflow_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/741d3be543de40621ea8a18c50e4664a2dc76d5a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flocation_overflow_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flocation_overflow_plugin.c?ref=741d3be543de40621ea8a18c50e4664a2dc76d5a", "patch": "@@ -87,11 +87,11 @@ plugin_init (struct plugin_name_args *plugin_info,\n   original_finalizer = diagnostic_finalizer (global_dc);\n   switch (base_location)\n     {\n-    case 0x50000001:\n+    case LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES + 1:\n       diagnostic_finalizer (global_dc) = verify_unpacked_ranges;\n       break;\n \n-    case 0x60000001:\n+    case LINE_MAP_MAX_LOCATION_WITH_COLS + 1:\n       diagnostic_finalizer (global_dc) = verify_no_columns;\n       break;\n "}, {"sha": "168e08c15cff3ba76640403beef5545a48fb103a", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/741d3be543de40621ea8a18c50e4664a2dc76d5a/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/741d3be543de40621ea8a18c50e4664a2dc76d5a/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=741d3be543de40621ea8a18c50e4664a2dc76d5a", "patch": "@@ -1,3 +1,12 @@\n+2016-07-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* include/line-map.h (LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES):\n+\tMove here from line-map.c.\n+\t(LINE_MAP_MAX_LOCATION_WITH_COLS): Likewise.\n+\t* line-map.c (LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES): Move from\n+\there to line-map.h.\n+\t(LINE_MAP_MAX_LOCATION_WITH_COLS): Likewise.\n+\n 2016-06-22  David Malcolm  <dmalcolm@redhat.com>\n \n \t* directives.c (do_include_common): Pass on \"location\" to"}, {"sha": "43576761e63f13928666f8c471613cb356956045", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/741d3be543de40621ea8a18c50e4664a2dc76d5a/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/741d3be543de40621ea8a18c50e4664a2dc76d5a/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=741d3be543de40621ea8a18c50e4664a2dc76d5a", "patch": "@@ -260,6 +260,16 @@ typedef unsigned int linenum_type;\n    worked example in libcpp/location-example.txt.  */\n typedef unsigned int source_location;\n \n+/* Do not pack ranges if locations get higher than this.\n+   If you change this, update:\n+     gcc.dg/plugin/location-overflow-test-*.c.  */\n+const source_location LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES = 0x50000000;\n+\n+/* Do not track column numbers if locations get higher than this.\n+   If you change this, update:\n+     gcc.dg/plugin/location-overflow-test-*.c.  */\n+const source_location LINE_MAP_MAX_LOCATION_WITH_COLS = 0x60000000;\n+\n /* A range of source locations.\n \n    Ranges are closed:"}, {"sha": "141af9d2cdee17cdb8480513e63d5268421626ce", "filename": "libcpp/line-map.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/741d3be543de40621ea8a18c50e4664a2dc76d5a/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/741d3be543de40621ea8a18c50e4664a2dc76d5a/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=741d3be543de40621ea8a18c50e4664a2dc76d5a", "patch": "@@ -31,18 +31,6 @@ along with this program; see the file COPYING3.  If not see\n    disabled).  */\n const unsigned int LINE_MAP_MAX_COLUMN_NUMBER = (1U << 12);\n \n-/* Do not pack ranges if locations get higher than this.\n-   If you change this, update:\n-     gcc.dg/plugin/location_overflow_plugin.c\n-     gcc.dg/plugin/location-overflow-test-*.c.  */\n-const source_location LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES = 0x50000000;\n-\n-/* Do not track column numbers if locations get higher than this.\n-   If you change this, update:\n-     gcc.dg/plugin/location_overflow_plugin.c\n-     gcc.dg/plugin/location-overflow-test-*.c.  */\n-const source_location LINE_MAP_MAX_LOCATION_WITH_COLS = 0x60000000;\n-\n /* Highest possible source location encoded within an ordinary or\n    macro map.  */\n const source_location LINE_MAP_MAX_SOURCE_LOCATION = 0x70000000;"}]}