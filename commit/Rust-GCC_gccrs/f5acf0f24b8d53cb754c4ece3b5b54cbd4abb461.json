{"sha": "f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVhY2YwZjI0YjhkNTNjYjc1NGM0ZWNlM2I1YjU0Y2JkNGFiYjQ2MQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2013-01-12T12:52:41Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2013-01-12T12:52:41Z"}, "message": "re PR fortran/55868 (gfortran generates for CLASS(*)   __m_MOD___vtab__$tar on NO_DOLLAR_IN_LABEL systems)\n\n2013-01-08  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/55868\n\t* class.c (get_unique_type_string): Change $tar to STAR and\n\treplace sprintf by strcpy where there is no formatting.\n\t* decl.c (gfc_match_decl_type_spec): Change $tar to STAR.\n\n2013-01-08  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/55868\n\t* gfortran.dg/unlimited_polymorphic_8.f90: Update\n\tscan-tree-dump-times for foo.0.x._vptr to deal with change from\n\t$tar to STAR.\n\nFrom-SVN: r195124", "tree": {"sha": "f5b055e68f9a182564e6b0204f6542edd95fc27c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5b055e68f9a182564e6b0204f6542edd95fc27c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461/comments", "author": null, "committer": null, "parents": [{"sha": "90229b5d002782a34431d2821f10ca97573559c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90229b5d002782a34431d2821f10ca97573559c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90229b5d002782a34431d2821f10ca97573559c2"}], "stats": {"total": 196, "additions": 105, "deletions": 91}, "files": [{"sha": "54700c6263867f77f229a4fd904462e45b98c982", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461", "patch": "@@ -1,3 +1,10 @@\n+2013-01-08  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/55868\n+\t* class.c (get_unique_type_string): Change $tar to STAR and\n+\treplace sprintf by strcpy where there is no formatting.\n+\t* decl.c (gfc_match_decl_type_spec): Change $tar to STAR.\n+\n 2013-01-09  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/47203"}, {"sha": "3bb326cf0fb1ec8e8f422a7ad198582b7e542a03", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461", "patch": "@@ -460,9 +460,9 @@ get_unique_type_string (char *string, gfc_symbol *derived)\n {\n   char dt_name[GFC_MAX_SYMBOL_LEN+1];\n   if (derived->attr.unlimited_polymorphic)\n-    sprintf (dt_name, \"%s\", \"$tar\");\n+    strcpy (dt_name, \"STAR\");\n   else\n-  sprintf (dt_name, \"%s\", derived->name);\n+    strcpy (dt_name, derived->name);\n   dt_name[0] = TOUPPER (dt_name[0]);\n   if (derived->attr.unlimited_polymorphic)\n     sprintf (string, \"_%s\", dt_name);"}, {"sha": "f2a9941963d6cc45debd55fd3eac1d8be1360db5", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461", "patch": "@@ -737,7 +737,7 @@ match_char_length (gfc_expr **expr, bool *deferred, bool obsolescent_check)\n   int length;\n   match m;\n \n-  *deferred = false; \n+  *deferred = false;\n   m = gfc_match_char ('*');\n   if (m != MATCH_YES)\n     return m;\n@@ -988,7 +988,7 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n      Don't repeat the checks here.  */\n   if (sym->attr.implicit_type)\n     return SUCCESS;\n-  \n+\n   /* For subroutines or functions that are passed to a BIND(C) procedure,\n      they're interoperable if they're BIND(C) and their params are all\n      interoperable.  */\n@@ -999,7 +999,7 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n           gfc_error_now (\"Procedure '%s' at %L must have the BIND(C) \"\n                          \"attribute to be C interoperable\", sym->name,\n                          &(sym->declared_at));\n-                         \n+\n           return FAILURE;\n         }\n       else\n@@ -1012,7 +1012,7 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n                                       sym->common_block);\n         }\n     }\n-  \n+\n   /* See if we've stored a reference to a procedure that owns sym.  */\n   if (sym->ns != NULL && sym->ns->proc_name != NULL)\n     {\n@@ -1028,7 +1028,7 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t\t\t   \"BIND(C) procedure '%s' but is not C interoperable \"\n \t\t\t   \"because derived type '%s' is not C interoperable\",\n \t\t\t   sym->name, &(sym->declared_at),\n-\t\t\t   sym->ns->proc_name->name, \n+\t\t\t   sym->ns->proc_name->name,\n \t\t\t   sym->ts.u.derived->name);\n \t      else if (sym->ts.type == BT_CLASS)\n \t\tgfc_error (\"Variable '%s' at %L is a dummy argument to the \"\n@@ -1350,7 +1350,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t until later for derived type variables and procedure pointers.  */\n       if (sym->ts.type != BT_DERIVED && init->ts.type != BT_DERIVED\n \t  && sym->ts.type != BT_CLASS && init->ts.type != BT_CLASS\n-\t  && !sym->attr.proc_pointer \n+\t  && !sym->attr.proc_pointer\n \t  && gfc_check_assign_symbol (sym, NULL, init) == FAILURE)\n \treturn FAILURE;\n \n@@ -1436,7 +1436,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t      int k;\n \t      gfc_expr* lower;\n \t      gfc_expr* e;\n-\t      \n+\n \t      lower = sym->as->lower[dim];\n \t      if (lower->expr_type != EXPR_CONSTANT)\n \t\t{\n@@ -1498,7 +1498,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t\t\t\t\t\t? init\n \t\t\t\t\t\t: gfc_copy_expr (init),\n \t\t\t\t\t     &init->where);\n-\t\t\n+\n \t      array->shape = gfc_get_shape (sym->as->rank);\n \t      for (n = 0; n < sym->as->rank; n++)\n \t\tspec_dimen_size (sym->as, n, &array->shape[n]);\n@@ -1759,7 +1759,7 @@ match_pointer_init (gfc_expr **init, int procptr)\n \n   if (!procptr)\n     gfc_resolve_expr (*init);\n-  \n+\n   if (gfc_notify_std (GFC_STD_F2008, \"non-NULL pointer \"\n \t\t      \"initialization at %C\") == FAILURE)\n     return MATCH_ERROR;\n@@ -1919,7 +1919,7 @@ variable_decl (int elem)\n \t  sym->ts.is_c_interop = current_ts.is_c_interop;\n \t  sym->ts.is_iso_c = current_ts.is_iso_c;\n \t  m = MATCH_YES;\n-\t\n+\n \t  /* Check to see if we have an array specification.  */\n \t  if (cp_as != NULL)\n \t    {\n@@ -2002,7 +2002,7 @@ variable_decl (int elem)\n \t    goto cleanup;\n \t}\n     }\n-    \n+\n   if (check_function_name (name) == FAILURE)\n     {\n       m = MATCH_ERROR;\n@@ -2023,7 +2023,7 @@ variable_decl (int elem)\n       if (gfc_notify_std (GFC_STD_GNU, \"Old-style \"\n \t\t\t  \"initialization at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n- \n+\n       return match_old_style_init (name);\n     }\n \n@@ -2218,7 +2218,7 @@ gfc_match_kind_spec (gfc_typespec *ts, bool kind_expr_only)\n     {\n       if (gfc_matching_function)\n \t{\n-\t  /* The function kind expression might include use associated or \n+\t  /* The function kind expression might include use associated or\n \t     imported parameters and try again after the specification\n \t     expressions.....  */\n \t  if (gfc_match_char (')') != MATCH_YES)\n@@ -2267,7 +2267,7 @@ gfc_match_kind_spec (gfc_typespec *ts, bool kind_expr_only)\n       ts->is_c_interop = e->ts.is_iso_c;\n       ts->f90_type = e->ts.f90_type;\n     }\n-  \n+\n   gfc_free_expr (e);\n   e = NULL;\n \n@@ -2362,7 +2362,7 @@ match_char_kind (int * kind, int * is_iso_c)\n   if (n != MATCH_YES && gfc_matching_function)\n     {\n       /* The expression might include use-associated or imported\n-\t parameters and try again after the specification \n+\t parameters and try again after the specification\n \t expressions.  */\n       gfc_free_expr (e);\n       gfc_undo_symbols ();\n@@ -2405,7 +2405,7 @@ match_char_kind (int * kind, int * is_iso_c)\n \n   if (m == MATCH_ERROR)\n      gfc_current_locus = where;\n-  \n+\n   /* Return what we know from the test(s).  */\n   return m;\n \n@@ -2457,7 +2457,7 @@ gfc_match_char_spec (gfc_typespec *ts)\n   if (gfc_match (\" kind =\") == MATCH_YES)\n     {\n       m = match_char_kind (&kind, &is_iso_c);\n-       \n+\n       if (m == MATCH_ERROR)\n \tgoto done;\n       if (m == MATCH_NO)\n@@ -2572,11 +2572,11 @@ gfc_match_char_spec (gfc_typespec *ts)\n        looking for the length (line 1690, roughly).  it's the last\n        testcase for parsing the kind params of a character variable.\n        However, it's not actually the length.\t this seems like it\n-       could be an error.  \n+       could be an error.\n        To see if the user used a C interop kind, test the expr\n        of the so called length, and see if it's C interoperable.  */\n     ts->is_c_interop = len->ts.is_iso_c;\n-  \n+\n   return MATCH_YES;\n }\n \n@@ -2764,11 +2764,11 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \t  gfc_symbol *upe;\n \t  gfc_symtree *st;\n \t  ts->type = BT_CLASS;\n-\t  gfc_find_symbol (\"$tar\", gfc_current_ns, 1, &upe);\n+\t  gfc_find_symbol (\"STAR\", gfc_current_ns, 1, &upe);\n \t  if (upe == NULL)\n \t    {\n-\t      upe = gfc_new_symbol (\"$tar\", gfc_current_ns);\n-\t      st = gfc_new_symtree (&gfc_current_ns->sym_root, \"$tar\");\n+\t      upe = gfc_new_symbol (\"STAR\", gfc_current_ns);\n+\t      st = gfc_new_symtree (&gfc_current_ns->sym_root, \"STAR\");\n \t      st->n.sym = upe;\n \t      gfc_set_sym_referenced (upe);\n \t      upe->refs++;\n@@ -2783,9 +2783,9 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \t}\n \t  else\n \t    {\n-\t      st = gfc_find_symtree (gfc_current_ns->sym_root, \"$tar\");\n+\t      st = gfc_find_symtree (gfc_current_ns->sym_root, \"STAR\");\n \t      if (st == NULL)\n-\t\tst = gfc_new_symtree (&gfc_current_ns->sym_root, \"$tar\");\n+\t\tst = gfc_new_symtree (&gfc_current_ns->sym_root, \"STAR\");\n \t      st->n.sym = upe;\n \t      upe->refs++;\n \t    }\n@@ -2805,7 +2805,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \n   /* Defer association of the derived type until the end of the\n      specification block.  However, if the derived type can be\n-     found, add it to the typespec.  */  \n+     found, add it to the typespec.  */\n   if (gfc_matching_function)\n     {\n       ts->u.derived = NULL;\n@@ -2846,7 +2846,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \t\t    || gfc_current_ns->has_import_set;\n       gfc_find_symbol (name, NULL, iface, &sym);\n       if (sym && sym->generic && gfc_find_symbol (dt_name, NULL, 1, &dt_sym))\n-\t{       \n+\t{\n \t  gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n \t  return MATCH_ERROR;\n \t}\n@@ -3836,7 +3836,7 @@ match_attr_spec (void)\n         case DECL_IS_BIND_C:\n            t = gfc_add_is_bind_c(&current_attr, NULL, &seen_at[d], 0);\n            break;\n-           \n+\n \tcase DECL_VALUE:\n \t  if (gfc_notify_std (GFC_STD_F2003, \"VALUE attribute \"\n \t\t\t      \"at %C\")\n@@ -3889,7 +3889,7 @@ match_attr_spec (void)\n    there is more than one argument (num_idents), it is an error.  */\n \n static gfc_try\n-set_binding_label (const char **dest_label, const char *sym_name, \n+set_binding_label (const char **dest_label, const char *sym_name,\n \t\t   int num_idents)\n {\n   if (num_idents > 1 && has_name_equals)\n@@ -3909,7 +3909,7 @@ set_binding_label (const char **dest_label, const char *sym_name,\n       if (sym_name != NULL && has_name_equals == 0)\n         *dest_label = IDENTIFIER_POINTER (get_identifier (sym_name));\n     }\n-   \n+\n   return SUCCESS;\n }\n \n@@ -3954,7 +3954,7 @@ verify_com_block_vars_c_interop (gfc_common_head *com_block)\n   gfc_try retval = SUCCESS;\n \n   curr_sym = com_block->head;\n-  \n+\n   /* Make sure we have at least one symbol.  */\n   if (curr_sym == NULL)\n     return retval;\n@@ -3966,7 +3966,7 @@ verify_com_block_vars_c_interop (gfc_common_head *com_block)\n       /* The second to last param, 1, says this is in a common block.  */\n       retval = verify_bind_c_sym (curr_sym, &(curr_sym->ts), 1, com_block);\n       curr_sym = curr_sym->common_next;\n-    } while (curr_sym != NULL); \n+    } while (curr_sym != NULL);\n \n   return retval;\n }\n@@ -4005,7 +4005,7 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n      enough type info, then verify that it's a C interop kind.\n      The info could be in the symbol already, or possibly still in\n      the given ts (current_ts), so look in both.  */\n-  if (tmp_sym->ts.type != BT_UNKNOWN || ts->type != BT_UNKNOWN) \n+  if (tmp_sym->ts.type != BT_UNKNOWN || ts->type != BT_UNKNOWN)\n     {\n       if (gfc_verify_c_interop (&(tmp_sym->ts)) != SUCCESS)\n \t{\n@@ -4031,7 +4031,7 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n                              tmp_sym->name, &(tmp_sym->declared_at));\n \t    }\n \t}\n-      \n+\n       /* Variables declared w/in a common block can't be bind(c)\n \t since there's no way for C to see these variables, so there's\n \t semantically no reason for the attribute.  */\n@@ -4044,7 +4044,7 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n \t\t     &(tmp_sym->declared_at));\n \t  retval = FAILURE;\n \t}\n-      \n+\n       /* Scalar variables that are bind(c) can not have the pointer\n \t or allocatable attributes.  */\n       if (tmp_sym->attr.is_bind_c == 1)\n@@ -4107,7 +4107,7 @@ gfc_try\n set_verify_bind_c_sym (gfc_symbol *tmp_sym, int num_idents)\n {\n   gfc_try retval = SUCCESS;\n-  \n+\n   /* TODO: Do we need to make sure the vars aren't marked private?  */\n \n   /* Set the is_bind_c bit in symbol_attribute.  */\n@@ -4128,9 +4128,9 @@ gfc_try\n set_verify_bind_c_com_block (gfc_common_head *com_block, int num_idents)\n {\n   gfc_try retval = SUCCESS;\n-  \n+\n   /* destLabel, common name, typespec (which may have binding label).  */\n-  if (set_binding_label (&com_block->binding_label, com_block->name, \n+  if (set_binding_label (&com_block->binding_label, com_block->name,\n \t\t\t num_idents)\n       != SUCCESS)\n     return FAILURE;\n@@ -4153,7 +4153,7 @@ get_bind_c_idents (void)\n   gfc_symbol *tmp_sym = NULL;\n   match found_id;\n   gfc_common_head *com_block = NULL;\n-  \n+\n   if (gfc_match_name (name) == MATCH_YES)\n     {\n       found_id = MATCH_YES;\n@@ -4170,7 +4170,7 @@ get_bind_c_idents (void)\n \t\t \"attribute specification statement at %C\");\n       return FAILURE;\n     }\n-   \n+\n   /* Save the current identifier and look for more.  */\n   do\n     {\n@@ -4180,7 +4180,7 @@ get_bind_c_idents (void)\n       /* Make sure we have a sym or com block, and verify that it can\n \t be bind(c).  Set the appropriate field(s) and look for more\n \t identifiers.  */\n-      if (tmp_sym != NULL || com_block != NULL)\t\t\n+      if (tmp_sym != NULL || com_block != NULL)\n         {\n \t  if (tmp_sym != NULL)\n \t    {\n@@ -4194,7 +4194,7 @@ get_bind_c_idents (void)\n \t\t  != SUCCESS)\n \t\treturn FAILURE;\n \t    }\n-\t \n+\n \t  /* Look to see if we have another identifier.  */\n \t  tmp_sym = NULL;\n \t  if (gfc_match_eos () == MATCH_YES)\n@@ -4230,15 +4230,15 @@ get_bind_c_idents (void)\n \n \n /* Try and match a BIND(C) attribute specification statement.  */\n-   \n+\n match\n gfc_match_bind_c_stmt (void)\n {\n   match found_match = MATCH_NO;\n   gfc_typespec *ts;\n \n   ts = &current_ts;\n-  \n+\n   /* This may not be necessary.  */\n   gfc_clear_ts (ts);\n   /* Clear the temporary binding label holder.  */\n@@ -4276,7 +4276,7 @@ gfc_match_data_decl (void)\n   int elem;\n \n   num_idents_on_line = 0;\n-  \n+\n   m = gfc_match_decl_type_spec (&current_ts, 0);\n   if (m != MATCH_YES)\n     return m;\n@@ -4662,7 +4662,7 @@ gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n \n   /* Initialize to having found nothing.  */\n   found_match = MATCH_NO;\n-  is_bind_c = MATCH_NO; \n+  is_bind_c = MATCH_NO;\n   is_result = MATCH_NO;\n \n   /* Get the next char to narrow between result and bind(c).  */\n@@ -4690,7 +4690,7 @@ gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n \t}\n       else\n \t/* This should only be MATCH_ERROR.  */\n-\tfound_match = is_result; \n+\tfound_match = is_result;\n       break;\n     case 'b':\n       /* Look for bind(c) first.  */\n@@ -4728,7 +4728,7 @@ gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n \t  == FAILURE)\n      \treturn MATCH_ERROR;\n     }\n-  \n+\n   return found_match;\n }\n \n@@ -4940,7 +4940,7 @@ match_procedure_decl (void)\n \t      return MATCH_ERROR;\n \t    }\n \t  /* Set binding label for BIND(C).  */\n-\t  if (set_binding_label (&sym->binding_label, sym->name, num) \n+\t  if (set_binding_label (&sym->binding_label, sym->name, num)\n \t      != SUCCESS)\n \t    return MATCH_ERROR;\n \t}\n@@ -5263,7 +5263,7 @@ gfc_match_function_decl (void)\n   locus old_loc;\n   match m;\n   match suffix_match;\n-  match found_match; /* Status returned by match func.  */  \n+  match found_match; /* Status returned by match func.  */\n \n   if (gfc_current_state () != COMP_NONE\n       && gfc_current_state () != COMP_INTERFACE\n@@ -5346,10 +5346,10 @@ gfc_match_function_decl (void)\n     {\n       /* Make changes to the symbol.  */\n       m = MATCH_ERROR;\n-      \n+\n       if (gfc_add_function (&sym->attr, sym->name, NULL) == FAILURE)\n \tgoto cleanup;\n-      \n+\n       if (gfc_missing_attr (&sym->attr, NULL) == FAILURE\n \t  || copy_prefix (&sym->attr, &sym->declared_at) == FAILURE)\n \tgoto cleanup;\n@@ -5536,7 +5536,7 @@ gfc_match_entry (void)\n         gfc_error_now (\"BIND(C) attribute at %L can only be used for \"\n                        \"variables or common blocks\", &gfc_current_locus);\n     }\n-  \n+\n   /* Check what next non-whitespace character is so we can tell if there\n      is the required parens if we have a BIND(C).  */\n   gfc_gobble_whitespace ();\n@@ -5705,7 +5705,7 @@ gfc_match_subroutine (void)\n      is the required parens if we have a BIND(C).  */\n   gfc_gobble_whitespace ();\n   peek_char = gfc_peek_ascii_char ();\n-  \n+\n   if (gfc_add_subroutine (&sym->attr, sym->name, NULL) == FAILURE)\n     return MATCH_ERROR;\n \n@@ -5766,7 +5766,7 @@ gfc_match_subroutine (void)\n \t  == FAILURE)\n         return MATCH_ERROR;\n     }\n-  \n+\n   if (gfc_match_eos () != MATCH_YES)\n     {\n       gfc_syntax_error (ST_SUBROUTINE);\n@@ -5797,12 +5797,12 @@ gfc_match_subroutine (void)\n match\n gfc_match_bind_c (gfc_symbol *sym, bool allow_binding_name)\n {\n-  /* binding label, if exists */   \n+  /* binding label, if exists */\n   const char* binding_label = NULL;\n   match double_quote;\n   match single_quote;\n \n-  /* Initialize the flag that specifies whether we encountered a NAME= \n+  /* Initialize the flag that specifies whether we encountered a NAME=\n      specifier or not.  */\n   has_name_equals = 0;\n \n@@ -5837,12 +5837,12 @@ gfc_match_bind_c (gfc_symbol *sym, bool allow_binding_name)\n                      \"at %C\");\n           return MATCH_ERROR;\n         }\n-      \n+\n       /* Grab the binding label, using functions that will not lower\n \t case the names automatically.\t*/\n       if (gfc_match_name_C (&binding_label) != MATCH_YES)\n \t return MATCH_ERROR;\n-      \n+\n       /* Get the closing quotation.  */\n       if (double_quote == MATCH_YES)\n \t{\n@@ -6236,7 +6236,7 @@ attr_decl1 (void)\n       m = MATCH_ERROR;\n       goto cleanup;\n     }\n-  \n+\n   var_locus = gfc_current_locus;\n \n   /* Deal with possible array specification for certain attributes.  */\n@@ -6307,7 +6307,7 @@ attr_decl1 (void)\n \t  goto cleanup;\n \t}\n     }\n-    \n+\n   if (sym->ts.type == BT_CLASS\n       && gfc_build_class_symbol (&sym->ts, &sym->attr, &sym->as, false) == FAILURE)\n     {\n@@ -6324,7 +6324,7 @@ attr_decl1 (void)\n   if (sym->attr.cray_pointee && sym->as != NULL)\n     {\n       /* Fix the array spec.  */\n-      m = gfc_mod_pointee_as (sym->as);   \t\n+      m = gfc_mod_pointee_as (sym->as);\n       if (m == MATCH_ERROR)\n \tgoto cleanup;\n     }\n@@ -6485,7 +6485,7 @@ cray_pointer_decl (void)\n \t{\n \t  gfc_free_array_spec (as);\n \t  as = NULL;\n-\t}   \n+\t}\n \n       if (gfc_add_cray_pointee (&cpte->attr, &var_locus) == FAILURE)\n \treturn MATCH_ERROR;\n@@ -6503,31 +6503,31 @@ cray_pointer_decl (void)\n \t  gfc_free_array_spec (as);\n \t  return MATCH_ERROR;\n \t}\n-      \n+\n       as = NULL;\n-    \n+\n       if (cpte->as != NULL)\n \t{\n \t  /* Fix array spec.  */\n \t  m = gfc_mod_pointee_as (cpte->as);\n \t  if (m == MATCH_ERROR)\n \t    return m;\n-\t} \n-   \n+\t}\n+\n       /* Point the Pointee at the Pointer.  */\n       cpte->cp_pointer = cptr;\n \n       if (gfc_match_char (')') != MATCH_YES)\n \t{\n \t  gfc_error (\"Expected \\\")\\\" at %C\");\n-\t  return MATCH_ERROR;    \n+\t  return MATCH_ERROR;\n \t}\n       m = gfc_match_char (',');\n       if (m != MATCH_YES)\n \tdone = true; /* Stop searching for more declarations.  */\n \n     }\n-  \n+\n   if (m == MATCH_ERROR /* Failed when trying to find ',' above.  */\n       || gfc_match_eos () != MATCH_YES)\n     {\n@@ -6618,7 +6618,7 @@ gfc_match_pointer (void)\n     {\n       gfc_clear_attr (&current_attr);\n       current_attr.pointer = 1;\n-    \n+\n       return attr_decl ();\n     }\n }\n@@ -7163,7 +7163,7 @@ gfc_match_volatile (void)\n \n   for(;;)\n     {\n-      /* VOLATILE is special because it can be added to host-associated \n+      /* VOLATILE is special because it can be added to host-associated\n \t symbols locally. Except for coarrays. */\n       m = gfc_match_symbol (&sym, 1);\n       switch (m)\n@@ -7224,7 +7224,7 @@ gfc_match_asynchronous (void)\n \n   for(;;)\n     {\n-      /* ASYNCHRONOUS is special because it can be added to host-associated \n+      /* ASYNCHRONOUS is special because it can be added to host-associated\n \t symbols locally.  */\n       m = gfc_match_symbol (&sym, 1);\n       switch (m)\n@@ -7308,7 +7308,7 @@ gfc_match_modproc (void)\n     }\n   else\n     gfc_current_locus = old_locus;\n-      \n+\n   for (;;)\n     {\n       bool last = false;\n@@ -7622,7 +7622,7 @@ gfc_match_derived_decl (void)\n   /* Construct the f2k_derived namespace if it is not yet there.  */\n   if (!sym->f2k_derived)\n     sym->f2k_derived = gfc_get_namespace (NULL, 0);\n-  \n+\n   if (extended && !sym->components)\n     {\n       gfc_component *p;\n@@ -7636,7 +7636,7 @@ gfc_match_derived_decl (void)\n       p->ts.type = BT_DERIVED;\n       p->ts.u.derived = extended;\n       p->initializer = gfc_default_initializer (&p->ts);\n-      \n+\n       /* Set extension level.  */\n       if (extended->attr.extension == 255)\n \t{\n@@ -7668,7 +7668,7 @@ gfc_match_derived_decl (void)\n }\n \n \n-/* Cray Pointees can be declared as: \n+/* Cray Pointees can be declared as:\n       pointer (ipt, a (n,m,...,*))  */\n \n match\n@@ -7686,15 +7686,15 @@ gfc_mod_pointee_as (gfc_array_spec *as)\n }\n \n \n-/* Match the enum definition statement, here we are trying to match \n-   the first line of enum definition statement.  \n+/* Match the enum definition statement, here we are trying to match\n+   the first line of enum definition statement.\n    Returns MATCH_YES if match is found.  */\n \n match\n gfc_match_enum (void)\n {\n   match m;\n-  \n+\n   m = gfc_match_eos ();\n   if (m != MATCH_YES)\n     return m;\n@@ -8181,7 +8181,7 @@ match_procedure_in_type (void)\n       return MATCH_ERROR;\n     }\n \n-  /* Match the binding names.  */ \n+  /* Match the binding names.  */\n   for(num=1;;num++)\n     {\n       m = gfc_match_name (name);\n@@ -8268,7 +8268,7 @@ match_procedure_in_type (void)\n \t\t\t    false))\n \treturn MATCH_ERROR;\n       gfc_set_sym_referenced (stree->n.tb->u.specific->n.sym);\n-  \n+\n       if (gfc_match_eos () == MATCH_YES)\n \treturn MATCH_YES;\n       if (gfc_match_char (',') != MATCH_YES)\n@@ -8325,7 +8325,7 @@ gfc_match_generic (void)\n \n   /* Match the binding name; depending on type (operator / generic) format\n      it for future error messages into bind_name.  */\n- \n+\n   m = gfc_match_generic_spec (&op_type, name, &op);\n   if (m == MATCH_ERROR)\n     return MATCH_ERROR;\n@@ -8340,11 +8340,11 @@ gfc_match_generic (void)\n     case INTERFACE_GENERIC:\n       snprintf (bind_name, sizeof (bind_name), \"%s\", name);\n       break;\n- \n+\n     case INTERFACE_USER_OP:\n       snprintf (bind_name, sizeof (bind_name), \"OPERATOR(.%s.)\", name);\n       break;\n- \n+\n     case INTERFACE_INTRINSIC_OP:\n       snprintf (bind_name, sizeof (bind_name), \"OPERATOR(%s)\",\n \t\tgfc_op2string (op));\n@@ -8360,7 +8360,7 @@ gfc_match_generic (void)\n       gfc_error (\"Expected '=>' at %C\");\n       goto error;\n     }\n-  \n+\n   /* Try to find existing GENERIC binding with this name / for this operator;\n      if there is something, check that it is another GENERIC and then extend\n      it rather than building a new node.  Otherwise, create it and put it\n@@ -8435,7 +8435,7 @@ gfc_match_generic (void)\n \n \t    break;\n \t  }\n-\t  \n+\n \tcase INTERFACE_INTRINSIC_OP:\n \t  ns->tb_op[op] = tb;\n \t  break;\n@@ -8513,7 +8513,7 @@ gfc_match_final_decl (void)\n       if (!gfc_is_whitespace (c) && c != ':')\n \treturn MATCH_NO;\n     }\n-  \n+\n   if (gfc_state_stack->state != COMP_DERIVED_CONTAINS)\n     {\n       if (gfc_current_form == FORM_FIXED)\n@@ -8637,7 +8637,7 @@ const ext_attr_t ext_attr_list[] = {\n    MATCH_NO.  */\n match\n gfc_match_gcc_attributes (void)\n-{ \n+{\n   symbol_attribute attr;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   unsigned id;\n@@ -8692,7 +8692,7 @@ gfc_match_gcc_attributes (void)\n \n       if (find_special (name, &sym, true))\n \treturn MATCH_ERROR;\n-      \n+\n       sym->attr.ext_attr |= attr.ext_attr;\n \n       if (gfc_match_eos () == MATCH_YES)"}, {"sha": "868f5aa555cd8d9537d4d206870095fd142c6ea1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461", "patch": "@@ -1,3 +1,10 @@\n+2013-01-08  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/55868\n+\t* gfortran.dg/unlimited_polymorphic_8.f90: Update\n+\tscan-tree-dump-times for foo.0.x._vptr to deal with change from\n+\t$tar to STAR.\n+\n 2013-01-11  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* gcc.c-torture/compile/pr55921.c: Don't use matching constraints."}, {"sha": "816807835a0c06a2e8843792f9b6a928009fb925", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_8.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_8.f90?ref=f5acf0f24b8d53cb754c4ece3b5b54cbd4abb461", "patch": "@@ -16,5 +16,5 @@ subroutine bar(this)\n end\n \n ! { dg-final { scan-tree-dump-times \"foo.0.x._data = 0B;\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"foo.0.x._vptr = .* &__vtab__.tar;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"foo.0.x._vptr = .* &__vtab__STAR;\" 1 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"optimized\" } }"}]}