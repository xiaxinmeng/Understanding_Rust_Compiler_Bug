{"sha": "ca83d38556d2c0ac60a369d42258fc0a39df86bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E4M2QzODU1NmQyYzBhYzYwYTM2OWQ0MjI1OGZjMGEzOWRmODZiZg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-11-21T00:20:02Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-11-21T00:20:02Z"}, "message": "tree-ssa-loop-im.c (schedule_sm, [...]): Use vector of edges instead of array.\n\n\t* tree-ssa-loop-im.c (schedule_sm, determine_lsm_ref,\n\thoist_memory_references, loop_suitable_for_sm, determine_lsm_loop):\n\tUse vector of edges instead of array.\n\t* tree-ssa-loop-niter.c (find_loop_niter, find_loop_niter_by_eval,\n\testimate_numbers_of_iterations_loop): Ditto.\n\t* predict.c (predict_loops): Ditto.\n\t* loop-unroll.c (analyze_insns_in_loop): Ditto.\n\t* tree-ssa-threadupdate.c: Remove declaration of heap allocation for\n\tedge vectors.\n\t* basic-block.h: Declare heap allocation for edge vectors.\n\t* tree-outof-ssa.c: Ditto.\n\t* cfgloop.c (get_loop_exit_edges): Return vector of edges.\n\t* cfgloop.h (get_loop_exit_edges): Declaration changed.\n\nFrom-SVN: r119039", "tree": {"sha": "5936129bd622c7aef21ba556b43971c620090ebd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5936129bd622c7aef21ba556b43971c620090ebd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca83d38556d2c0ac60a369d42258fc0a39df86bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca83d38556d2c0ac60a369d42258fc0a39df86bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca83d38556d2c0ac60a369d42258fc0a39df86bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca83d38556d2c0ac60a369d42258fc0a39df86bf/comments", "author": null, "committer": null, "parents": [{"sha": "c61191974ba056b73abcee46eca65cd440a2b2e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c61191974ba056b73abcee46eca65cd440a2b2e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c61191974ba056b73abcee46eca65cd440a2b2e2"}], "stats": {"total": 166, "additions": 88, "deletions": 78}, "files": [{"sha": "c960ed934f779a8d57977dfed6e5c64cb7b26b97", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca83d38556d2c0ac60a369d42258fc0a39df86bf", "patch": "@@ -1,3 +1,19 @@\n+2006-11-21  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-im.c (schedule_sm, determine_lsm_ref,\n+\thoist_memory_references, loop_suitable_for_sm, determine_lsm_loop):\n+\tUse vector of edges instead of array.\n+\t* tree-ssa-loop-niter.c (find_loop_niter, find_loop_niter_by_eval,\n+\testimate_numbers_of_iterations_loop): Ditto.\n+\t* predict.c (predict_loops): Ditto.\n+\t* loop-unroll.c (analyze_insns_in_loop): Ditto.\n+\t* tree-ssa-threadupdate.c: Remove declaration of heap allocation for\n+\tedge vectors.\n+\t* basic-block.h: Declare heap allocation for edge vectors.\n+\t* tree-outof-ssa.c: Ditto.\n+\t* cfgloop.c (get_loop_exit_edges): Return vector of edges.\n+\t* cfgloop.h (get_loop_exit_edges): Declaration changed.\n+\n 2006-11-20  Zack Weinberg  <zackw@panix.com>\n \n \t* gengtype.c (process_gc_options): Remove unnecessary forward decl."}, {"sha": "e330f3e40f3220af6921003bd51c44c209ab9302", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=ca83d38556d2c0ac60a369d42258fc0a39df86bf", "patch": "@@ -146,6 +146,7 @@ struct edge_def GTY(())\n typedef struct edge_def *edge;\n DEF_VEC_P(edge);\n DEF_VEC_ALLOC_P(edge,gc);\n+DEF_VEC_ALLOC_P(edge,heap);\n \n #define EDGE_FALLTHRU\t\t1\t/* 'Straight line' flow */\n #define EDGE_ABNORMAL\t\t2\t/* Strange flow, like computed"}, {"sha": "4a5631df08162853a6619a067dcfc038138e6239", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=ca83d38556d2c0ac60a369d42258fc0a39df86bf", "patch": "@@ -881,30 +881,24 @@ get_loop_body_in_bfs_order (const struct loop *loop)\n   return blocks;\n }\n \n-/* Gets exit edges of a LOOP, returning their number in N_EDGES.  */\n-edge *\n-get_loop_exit_edges (const struct loop *loop, unsigned int *num_edges)\n+/* Returns the list of the exit edges of a LOOP.  */\n+\n+VEC (edge, heap) *\n+get_loop_exit_edges (const struct loop *loop)\n {\n-  edge *edges, e;\n-  unsigned i, n;\n-  basic_block * body;\n+  VEC (edge, heap) *edges = NULL;\n+  edge e;\n+  unsigned i;\n+  basic_block *body;\n   edge_iterator ei;\n \n   gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n \n   body = get_loop_body (loop);\n-  n = 0;\n-  for (i = 0; i < loop->num_nodes; i++)\n-    FOR_EACH_EDGE (e, ei, body[i]->succs)\n-      if (!flow_bb_inside_loop_p (loop, e->dest))\n-\tn++;\n-  edges = XNEWVEC (edge, n);\n-  *num_edges = n;\n-  n = 0;\n   for (i = 0; i < loop->num_nodes; i++)\n     FOR_EACH_EDGE (e, ei, body[i]->succs)\n       if (!flow_bb_inside_loop_p (loop, e->dest))\n-\tedges[n++] = e;\n+\tVEC_safe_push (edge, heap, edges, e);\n   free (body);\n \n   return edges;"}, {"sha": "b02b4c7879ae768cb8d2cb0224ab984cceaa0a65", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=ca83d38556d2c0ac60a369d42258fc0a39df86bf", "patch": "@@ -222,7 +222,7 @@ extern void mark_loop_exit_edges (struct loops *);\n extern basic_block *get_loop_body (const struct loop *);\n extern basic_block *get_loop_body_in_dom_order (const struct loop *);\n extern basic_block *get_loop_body_in_bfs_order (const struct loop *);\n-extern edge *get_loop_exit_edges (const struct loop *, unsigned *);\n+extern VEC (edge, heap) *get_loop_exit_edges (const struct loop *);\n extern unsigned num_loop_branches (const struct loop *);\n \n extern edge loop_preheader_edge (const struct loop *);"}, {"sha": "7d230fb6f3afa41d3b7e1e51431d024835b2cd93", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=ca83d38556d2c0ac60a369d42258fc0a39df86bf", "patch": "@@ -1709,14 +1709,15 @@ static struct opt_info *\n analyze_insns_in_loop (struct loop *loop)\n {\n   basic_block *body, bb;\n-  unsigned i, num_edges = 0;\n+  unsigned i;\n   struct opt_info *opt_info = XCNEW (struct opt_info);\n   rtx insn;\n   struct iv_to_split *ivts = NULL;\n   struct var_to_expand *ves = NULL;\n   PTR *slot1;\n   PTR *slot2;\n-  edge *edges = get_loop_exit_edges (loop, &num_edges);\n+  VEC (edge, heap) *edges = get_loop_exit_edges (loop);\n+  edge exit;\n   bool can_apply = false;\n   \n   iv_analysis_loop_init (loop);\n@@ -1730,11 +1731,14 @@ analyze_insns_in_loop (struct loop *loop)\n   /* Record the loop exit bb and loop preheader before the unrolling.  */\n   opt_info->loop_preheader = loop_preheader_edge (loop)->src;\n   \n-  if (num_edges == 1\n-      && !(edges[0]->flags & EDGE_COMPLEX))\n+  if (VEC_length (edge, edges) == 1)\n     {\n-      opt_info->loop_exit = split_edge (edges[0]);\n-      can_apply = true;\n+      exit = VEC_index (edge, edges, 0);\n+      if (!(exit->flags & EDGE_COMPLEX))\n+\t{\n+\t  opt_info->loop_exit = split_edge (exit);\n+\t  can_apply = true;\n+\t}\n     }\n   \n   if (flag_variable_expansion_in_unroller\n@@ -1774,7 +1778,7 @@ analyze_insns_in_loop (struct loop *loop)\n       }\n     }\n   \n-  free (edges);\n+  VEC_free (edge, heap, edges);\n   free (body);\n   return opt_info;\n }"}, {"sha": "5e905430273b8fc7e1c7cf69752e0573201d18f9", "filename": "gcc/predict.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=ca83d38556d2c0ac60a369d42258fc0a39df86bf", "patch": "@@ -640,23 +640,23 @@ predict_loops (struct loops *loops_info)\n   for (i = 1; i < loops_info->num; i++)\n     {\n       basic_block bb, *bbs;\n-      unsigned j;\n-      unsigned n_exits;\n+      unsigned j, n_exits;\n       struct loop *loop = loops_info->parray[i];\n-      edge *exits;\n+      VEC (edge, heap) *exits;\n       struct tree_niter_desc niter_desc;\n+      edge ex;\n \n-      exits = get_loop_exit_edges (loop, &n_exits);\n+      exits = get_loop_exit_edges (loop);\n+      n_exits = VEC_length (edge, exits);\n \n-\n-      for (j = 0; j < n_exits; j++)\n+      for (j = 0; VEC_iterate (edge, exits, j, ex); j++)\n \t{\n \t  tree niter = NULL;\n \n-\t  if (number_of_iterations_exit (loop, exits[j], &niter_desc, false))\n+\t  if (number_of_iterations_exit (loop, ex, &niter_desc, false))\n \t    niter = niter_desc.niter;\n \t  if (!niter || TREE_CODE (niter_desc.niter) != INTEGER_CST)\n-\t    niter = loop_niter_by_eval (loop, exits[j]);\n+\t    niter = loop_niter_by_eval (loop, ex);\n \n \t  if (TREE_CODE (niter) == INTEGER_CST)\n \t    {\n@@ -673,10 +673,10 @@ predict_loops (struct loops *loops_info)\n \t      else\n \t\tprobability = ((REG_BR_PROB_BASE + max / 2) / max);\n \n-\t      predict_edge (exits[j], PRED_LOOP_ITERATIONS, probability);\n+\t      predict_edge (ex, PRED_LOOP_ITERATIONS, probability);\n \t    }\n \t}\n-      free (exits);\n+      VEC_free (edge, heap, exits);\n \n       bbs = get_loop_body (loop);\n "}, {"sha": "b502fccec66fd58c86ad168a1094fb4db7b4eb4d", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=ca83d38556d2c0ac60a369d42258fc0a39df86bf", "patch": "@@ -1976,9 +1976,6 @@ rewrite_trees (var_map map, tree *values)\n   delete_elim_graph (g);\n }\n \n-\n-DEF_VEC_ALLOC_P(edge,heap);\n-\n /* These are the local work structures used to determine the best place to \n    insert the copies that were placed on edges by the SSA->normal pass..  */\n static VEC(edge,heap) *edge_leader;"}, {"sha": "e10017daf30c39a2794c4b1e1b7af251a8ed3abc", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=ca83d38556d2c0ac60a369d42258fc0a39df86bf", "patch": "@@ -1016,20 +1016,20 @@ get_lsm_tmp_name (tree ref)\n /* Records request for store motion of memory reference REF from LOOP.\n    MEM_REFS is the list of occurrences of the reference REF inside LOOP;\n    these references are rewritten by a new temporary variable.\n-   Exits from the LOOP are stored in EXITS, there are N_EXITS of them.\n-   The initialization of the temporary variable is put to the preheader\n-   of the loop, and assignments to the reference from the temporary variable\n-   are emitted to exits.  */\n+   Exits from the LOOP are stored in EXITS.  The initialization of the\n+   temporary variable is put to the preheader of the loop, and assignments\n+   to the reference from the temporary variable are emitted to exits.  */\n \n static void\n-schedule_sm (struct loop *loop, edge *exits, unsigned n_exits, tree ref,\n+schedule_sm (struct loop *loop, VEC (edge, heap) *exits, tree ref,\n \t     struct mem_ref_loc *mem_refs)\n {\n   struct mem_ref_loc *aref;\n   tree tmp_var;\n   unsigned i;\n   tree load, store;\n   struct fmt_data fmt_data;\n+  edge ex;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -1060,24 +1060,24 @@ schedule_sm (struct loop *loop, edge *exits, unsigned n_exits, tree ref,\n      all dependencies.  */\n   bsi_insert_on_edge (loop_latch_edge (loop), load);\n \n-  for (i = 0; i < n_exits; i++)\n+  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n     {\n       store = build2 (MODIFY_EXPR, void_type_node,\n \t\t      unshare_expr (ref), tmp_var);\n-      bsi_insert_on_edge (exits[i], store);\n+      bsi_insert_on_edge (ex, store);\n     }\n }\n \n /* Check whether memory reference REF can be hoisted out of the LOOP.  If this\n    is true, prepare the statements that load the value of the memory reference\n    to a temporary variable in the loop preheader, store it back on the loop\n    exits, and replace all the references inside LOOP by this temporary variable.\n-   LOOP has N_EXITS stored in EXITS.  CLOBBERED_VOPS is the bitmap of virtual\n+   EXITS is the list of exits of LOOP.  CLOBBERED_VOPS is the bitmap of virtual\n    operands that are clobbered by a call or accessed through multiple references\n    in loop.  */\n \n static void\n-determine_lsm_ref (struct loop *loop, edge *exits, unsigned n_exits,\n+determine_lsm_ref (struct loop *loop, VEC (edge, heap) *exits,\n \t\t   bitmap clobbered_vops, struct mem_ref *ref)\n {\n   struct mem_ref_loc *aref;\n@@ -1123,35 +1123,36 @@ determine_lsm_ref (struct loop *loop, edge *exits, unsigned n_exits,\n \treturn;\n     }\n \n-  schedule_sm (loop, exits, n_exits, ref->mem, ref->locs);\n+  schedule_sm (loop, exits, ref->mem, ref->locs);\n }\n \n /* Hoists memory references MEM_REFS out of LOOP.  CLOBBERED_VOPS is the list\n    of vops clobbered by call in loop or accessed by multiple memory references.\n-   EXITS is the list of N_EXITS exit edges of the LOOP.  */\n+   EXITS is the list of exit edges of the LOOP.  */\n \n static void\n hoist_memory_references (struct loop *loop, struct mem_ref *mem_refs,\n-\t\t\t bitmap clobbered_vops, edge *exits, unsigned n_exits)\n+\t\t\t bitmap clobbered_vops, VEC (edge, heap) *exits)\n {\n   struct mem_ref *ref;\n \n   for (ref = mem_refs; ref; ref = ref->next)\n-    determine_lsm_ref (loop, exits, n_exits, clobbered_vops, ref);\n+    determine_lsm_ref (loop, exits, clobbered_vops, ref);\n }\n \n-/* Checks whether LOOP (with N_EXITS exits stored in EXITS array) is suitable\n+/* Checks whether LOOP (with exits stored in EXITS array) is suitable\n    for a store motion optimization (i.e. whether we can insert statement\n    on its exits).  */\n \n static bool\n-loop_suitable_for_sm (struct loop *loop ATTRIBUTE_UNUSED, edge *exits,\n-\t\t      unsigned n_exits)\n+loop_suitable_for_sm (struct loop *loop ATTRIBUTE_UNUSED,\n+\t\t      VEC (edge, heap) *exits)\n {\n   unsigned i;\n+  edge ex;\n \n-  for (i = 0; i < n_exits; i++)\n-    if (exits[i]->flags & EDGE_ABNORMAL)\n+  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n+    if (ex->flags & EDGE_ABNORMAL)\n       return false;\n \n   return true;\n@@ -1345,14 +1346,13 @@ free_mem_refs (struct mem_ref *refs)\n static void\n determine_lsm_loop (struct loop *loop)\n {\n-  unsigned n_exits;\n-  edge *exits = get_loop_exit_edges (loop, &n_exits);\n+  VEC (edge, heap) *exits = get_loop_exit_edges (loop);\n   bitmap clobbered_vops;\n   struct mem_ref *mem_refs;\n \n-  if (!loop_suitable_for_sm (loop, exits, n_exits))\n+  if (!loop_suitable_for_sm (loop, exits))\n     {\n-      free (exits);\n+      VEC_free (edge, heap, exits);\n       return;\n     }\n \n@@ -1364,10 +1364,10 @@ determine_lsm_loop (struct loop *loop)\n   find_more_ref_vops (mem_refs, clobbered_vops);\n \n   /* Hoist all suitable memory references.  */\n-  hoist_memory_references (loop, mem_refs, clobbered_vops, exits, n_exits);\n+  hoist_memory_references (loop, mem_refs, clobbered_vops, exits);\n \n   free_mem_refs (mem_refs);\n-  free (exits);\n+  VEC_free (edge, heap, exits);\n   BITMAP_FREE (clobbered_vops);\n }\n "}, {"sha": "f410d8c63a894d07f47f2d1fc22566d5b15c6892", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=ca83d38556d2c0ac60a369d42258fc0a39df86bf", "patch": "@@ -1161,16 +1161,15 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n tree\n find_loop_niter (struct loop *loop, edge *exit)\n {\n-  unsigned n_exits, i;\n-  edge *exits = get_loop_exit_edges (loop, &n_exits);\n+  unsigned i;\n+  VEC (edge, heap) *exits = get_loop_exit_edges (loop);\n   edge ex;\n   tree niter = NULL_TREE, aniter;\n   struct tree_niter_desc desc;\n \n   *exit = NULL;\n-  for (i = 0; i < n_exits; i++)\n+  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n     {\n-      ex = exits[i];\n       if (!just_once_each_iteration_p (loop, ex->src))\n \tcontinue;\n \n@@ -1217,7 +1216,7 @@ find_loop_niter (struct loop *loop, edge *exit)\n \t  continue;\n \t}\n     }\n-  free (exits);\n+  VEC_free (edge, heap, exits);\n \n   return niter ? niter : chrec_dont_know;\n }\n@@ -1446,15 +1445,14 @@ loop_niter_by_eval (struct loop *loop, edge exit)\n tree\n find_loop_niter_by_eval (struct loop *loop, edge *exit)\n {\n-  unsigned n_exits, i;\n-  edge *exits = get_loop_exit_edges (loop, &n_exits);\n+  unsigned i;\n+  VEC (edge, heap) *exits = get_loop_exit_edges (loop);\n   edge ex;\n   tree niter = NULL_TREE, aniter;\n \n   *exit = NULL;\n-  for (i = 0; i < n_exits; i++)\n+  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n     {\n-      ex = exits[i];\n       if (!just_once_each_iteration_p (loop, ex->src))\n \tcontinue;\n \n@@ -1469,7 +1467,7 @@ find_loop_niter_by_eval (struct loop *loop, edge *exit)\n       niter = aniter;\n       *exit = ex;\n     }\n-  free (exits);\n+  VEC_free (edge, heap, exits);\n \n   return niter ? niter : chrec_dont_know;\n }\n@@ -1986,20 +1984,21 @@ infer_loop_bounds_from_undefined (struct loop *loop)\n static void\n estimate_numbers_of_iterations_loop (struct loop *loop)\n {\n-  edge *exits;\n+  VEC (edge, heap) *exits;\n   tree niter, type;\n-  unsigned i, n_exits;\n+  unsigned i;\n   struct tree_niter_desc niter_desc;\n+  edge ex;\n \n   /* Give up if we already have tried to compute an estimation.  */\n   if (loop->estimate_state != EST_NOT_COMPUTED)\n     return;\n   loop->estimate_state = EST_NOT_AVAILABLE;\n \n-  exits = get_loop_exit_edges (loop, &n_exits);\n-  for (i = 0; i < n_exits; i++)\n+  exits = get_loop_exit_edges (loop);\n+  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n     {\n-      if (!number_of_iterations_exit (loop, exits[i], &niter_desc, false))\n+      if (!number_of_iterations_exit (loop, ex, &niter_desc, false))\n \tcontinue;\n \n       niter = niter_desc.niter;\n@@ -2010,10 +2009,10 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n \t\t\tniter);\n       record_estimate (loop, niter,\n \t\t       niter_desc.additional_info,\n-\t\t       last_stmt (exits[i]->src),\n+\t\t       last_stmt (ex->src),\n \t\t       true, true);\n     }\n-  free (exits);\n+  VEC_free (edge, heap, exits);\n   \n   infer_loop_bounds_from_undefined (loop);\n   compute_estimated_nb_iterations (loop);"}, {"sha": "c6b52095716d891ec7d3c60459a78a73fd2a32b3", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83d38556d2c0ac60a369d42258fc0a39df86bf/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=ca83d38556d2c0ac60a369d42258fc0a39df86bf", "patch": "@@ -149,7 +149,6 @@ struct local_info\n    opportunities as they are discovered.  We keep the registered\n    jump threading opportunities in this vector as edge pairs\n    (original_edge, target_edge).  */\n-DEF_VEC_ALLOC_P(edge,heap);\n static VEC(edge,heap) *threaded_edges;\n \n "}]}