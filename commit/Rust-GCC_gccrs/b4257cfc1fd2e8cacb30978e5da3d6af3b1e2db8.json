{"sha": "b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQyNTdjZmMxZmQyZThjYWNiMzA5NzhlNWRhM2Q2YWYzYjFlMmRiOA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2005-12-02T17:09:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2005-12-02T17:09:40Z"}, "message": "tree-ssa-loop-im.c (schedule_sm): Use buildN instead of build.\n\n2005-12-02  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-loop-im.c (schedule_sm): Use buildN instead of build.\n\t* tree-complex.c (update_complex_assignment, expand_complex_div_wide):\n\tLikewise.\n\t* tree-ssa-ccp.c (maybe_fold_offset_to_array_ref,\n\tmaybe_fold_offset_to_component_ref): Likewise.\n\t* tree-ssa-dom.c (thread_across_edge,\n\tsimplify_rhs_and_lookup_avail_expr,\n\tfind_equivalent_equality_comparison, record_equivalences_from_stmt):\n\tLikewise.\n\t* gimple-low.c (lower_function_body, lower_return_expr): Likewise.\n\t* tree-eh.c (do_return_redirection, honor_protect_cleanup_actions,\n\tlower_try_finally_switch): Likewise.\n\t* tree-if-conv.c (add_to_dst_predicate_list,\n\treplace_phi_with_cond_modify_expr, ifc_temp_var): Likewise.\n\t* gimplify.c (internal_get_tmp_var, gimple_build_eh_filter,\n\tvoidify_wrapper_expr, build_stack_save_restore, gimplify_bind_expr,\n\tgimplify_return_expr, gimplify_decl_expr, gimplify_switch_expr,\n\tgimplify_case_label_expr, gimplify_exit_expr, gimplify_self_mod_expr,\n\tshortcut_cond_r, shortcut_cond_expr, gimplify_cond_expr,\n\tgimplify_init_ctor_eval, gimplify_init_constructor,\n\tgimplify_variable_sized_compare, gimplify_boolean_expr,\n\tgimplify_cleanup_point_expr, gimple_push_cleanup, gimplify_target_expr,\n\tgimplify_expr, gimplify_body, gimplify_function_tree,\n\tforce_gimple_operand): Likewise.\n\t* tree-ssa-pre.c (create_expression_by_pieces): Likewise.\n\t* tree-mudflap.c (mf_decl_cache_locals, mf_build_check_statement_for,\n\tmx_register_decls): Likewise.\n\t* tree-nested.c (init_tmp_var, save_tmp_var, get_static_chain,\n\tget_frame_field, finalize_nesting_tree_1): Likewise.\n\t* tree-inline.c (setup_one_parameter): Likewise.\n\t* tree-vect-transform.c (vectorizable_condition): Likewise.\n\t* tree-outof-ssa.c (insert_copy_on_edge, insert_backedge_copies):\n\tLikewise.\n\t* tree-profile.c (tree_gen_edge_profiler): Likewise.\n\t* tree-cfg.c (factor_computed_gotos, gimplify_val): Likewise.\n\t* c-parser.c (c_parser_if_body, c_parser_switch_statement): Likewise.\n\t* tree-chrec.h (build_polynomial_chrec): Likewise.\n\nFrom-SVN: r107907", "tree": {"sha": "54e787c5e39a380b235142cd2cfef88b4b6ecb84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54e787c5e39a380b235142cd2cfef88b4b6ecb84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a25a46d37a3f19ceb935d3f797fd6d370f10c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47a25a46d37a3f19ceb935d3f797fd6d370f10c1"}], "stats": {"total": 444, "additions": 242, "deletions": 202}, "files": [{"sha": "aa94752abc1299f8920089e02a0c854c01103fd8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -1,3 +1,43 @@\n+2005-12-02  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-loop-im.c (schedule_sm): Use buildN instead of build.\n+\t* tree-complex.c (update_complex_assignment, expand_complex_div_wide):\n+\tLikewise.\n+\t* tree-ssa-ccp.c (maybe_fold_offset_to_array_ref,\n+\tmaybe_fold_offset_to_component_ref): Likewise.\n+\t* tree-ssa-dom.c (thread_across_edge,\n+\tsimplify_rhs_and_lookup_avail_expr,\n+\tfind_equivalent_equality_comparison, record_equivalences_from_stmt):\n+\tLikewise.\n+\t* gimple-low.c (lower_function_body, lower_return_expr): Likewise.\n+\t* tree-eh.c (do_return_redirection, honor_protect_cleanup_actions,\n+\tlower_try_finally_switch): Likewise.\n+\t* tree-if-conv.c (add_to_dst_predicate_list,\n+\treplace_phi_with_cond_modify_expr, ifc_temp_var): Likewise.\n+\t* gimplify.c (internal_get_tmp_var, gimple_build_eh_filter,\n+\tvoidify_wrapper_expr, build_stack_save_restore, gimplify_bind_expr,\n+\tgimplify_return_expr, gimplify_decl_expr, gimplify_switch_expr,\n+\tgimplify_case_label_expr, gimplify_exit_expr, gimplify_self_mod_expr,\n+\tshortcut_cond_r, shortcut_cond_expr, gimplify_cond_expr,\n+\tgimplify_init_ctor_eval, gimplify_init_constructor,\n+\tgimplify_variable_sized_compare, gimplify_boolean_expr,\n+\tgimplify_cleanup_point_expr, gimple_push_cleanup, gimplify_target_expr,\n+\tgimplify_expr, gimplify_body, gimplify_function_tree,\n+\tforce_gimple_operand): Likewise.\n+\t* tree-ssa-pre.c (create_expression_by_pieces): Likewise.\n+\t* tree-mudflap.c (mf_decl_cache_locals, mf_build_check_statement_for,\n+\tmx_register_decls): Likewise.\n+\t* tree-nested.c (init_tmp_var, save_tmp_var, get_static_chain,\n+\tget_frame_field, finalize_nesting_tree_1): Likewise.\n+\t* tree-inline.c (setup_one_parameter): Likewise.\n+\t* tree-vect-transform.c (vectorizable_condition): Likewise.\n+\t* tree-outof-ssa.c (insert_copy_on_edge, insert_backedge_copies):\n+\tLikewise.\n+\t* tree-profile.c (tree_gen_edge_profiler): Likewise.\n+\t* tree-cfg.c (factor_computed_gotos, gimplify_val): Likewise.\n+\t* c-parser.c (c_parser_if_body, c_parser_switch_statement): Likewise.\n+\t* tree-chrec.h (build_polynomial_chrec): Likewise.\n+\n 2005-12-02  Richard Guenther  <rguenther@suse.de>\n \n \t* config/alpha/alpha.c (alpha_va_start, alpha_gimplify_va_arg_1i,"}, {"sha": "6ddbe51c01ec2014b59c6de48b90447d0581c6b7", "filename": "gcc/c-parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -3629,7 +3629,7 @@ c_parser_if_body (c_parser *parser, bool *if_p)\n     c_parser_label (parser);\n   *if_p = c_parser_next_token_is_keyword (parser, RID_IF);\n   if (extra_warnings && c_parser_next_token_is (parser, CPP_SEMICOLON))\n-    add_stmt (build (NOP_EXPR, NULL_TREE, NULL_TREE));\n+    add_stmt (build1 (NOP_EXPR, NULL_TREE, NULL_TREE));\n   c_parser_statement_after_labels (parser);\n   return c_end_compound_stmt (block, flag_isoc99);\n }\n@@ -3692,7 +3692,7 @@ c_parser_switch_statement (c_parser *parser)\n   body = c_parser_c99_block_statement (parser);\n   c_finish_case (body);\n   if (c_break_label)\n-    add_stmt (build (LABEL_EXPR, void_type_node, c_break_label));\n+    add_stmt (build1 (LABEL_EXPR, void_type_node, c_break_label));\n   c_break_label = save_break;\n   add_stmt (c_end_compound_stmt (block, flag_isoc99));\n }"}, {"sha": "44171341d31f1f45cfed69defb3e463322c89ca6", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -91,7 +91,7 @@ lower_function_body (void)\n       && (data.return_statements == NULL\n           || TREE_OPERAND (TREE_VALUE (data.return_statements), 0) != NULL))\n     {\n-      x = build (RETURN_EXPR, void_type_node, NULL);\n+      x = build1 (RETURN_EXPR, void_type_node, NULL);\n       SET_EXPR_LOCATION (x, cfun->function_end_locus);\n       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n     }\n@@ -100,7 +100,7 @@ lower_function_body (void)\n      at the end of the function.  */\n   for (t = data.return_statements ; t ; t = TREE_CHAIN (t))\n     {\n-      x = build (LABEL_EXPR, void_type_node, TREE_PURPOSE (t));\n+      x = build1 (LABEL_EXPR, void_type_node, TREE_PURPOSE (t));\n       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n \n       /* Remove the line number from the representative return statement.\n@@ -503,7 +503,7 @@ lower_return_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n \n   /* Generate a goto statement and remove the return statement.  */\n  found:\n-  t = build (GOTO_EXPR, void_type_node, label);\n+  t = build1 (GOTO_EXPR, void_type_node, label);\n   SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n   tsi_link_before (tsi, t, TSI_SAME_STMT);\n   tsi_delink (tsi);"}, {"sha": "1bd73da4be81c3d1d1098202e7cd0a7ad50f4681", "filename": "gcc/gimplify.c", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -533,7 +533,7 @@ internal_get_tmp_var (tree val, tree *pre_p, tree *post_p, bool is_formal)\n   if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE)\n     DECL_COMPLEX_GIMPLE_REG_P (t) = 1;\n \n-  mod = build (MODIFY_EXPR, TREE_TYPE (t), t, val);\n+  mod = build2 (MODIFY_EXPR, TREE_TYPE (t), t, val);\n \n   if (EXPR_HAS_LOCATION (val))\n     SET_EXPR_LOCUS (mod, EXPR_LOCUS (val));\n@@ -796,10 +796,10 @@ gimple_build_eh_filter (tree body, tree allowed, tree failure)\n   tree t;\n \n   /* FIXME should the allowed types go in TREE_TYPE?  */\n-  t = build (EH_FILTER_EXPR, void_type_node, allowed, NULL_TREE);\n+  t = build2 (EH_FILTER_EXPR, void_type_node, allowed, NULL_TREE);\n   append_to_statement_list (failure, &EH_FILTER_FAILURE (t));\n \n-  t = build (TRY_CATCH_EXPR, void_type_node, NULL_TREE, t);\n+  t = build2 (TRY_CATCH_EXPR, void_type_node, NULL_TREE, t);\n   append_to_statement_list (body, &TREE_OPERAND (t, 0));\n \n   return t;\n@@ -866,7 +866,7 @@ voidify_wrapper_expr (tree wrapper, tree temp)\n \t{\n \t  tree ptr = TREE_OPERAND (*p, 0);\n \t  temp = create_tmp_var (TREE_TYPE (ptr), \"retval\");\n-\t  *p = build (MODIFY_EXPR, TREE_TYPE (ptr), temp, ptr);\n+\t  *p = build2 (MODIFY_EXPR, TREE_TYPE (ptr), temp, ptr);\n \t  temp = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (temp)), temp);\n \t  /* If this is a BIND_EXPR for a const inline function, it might not\n \t     have TREE_SIDE_EFFECTS set.  That is no longer accurate.  */\n@@ -876,7 +876,7 @@ voidify_wrapper_expr (tree wrapper, tree temp)\n \t{\n \t  if (!temp)\n \t    temp = create_tmp_var (TREE_TYPE (wrapper), \"retval\");\n-\t  *p = build (MODIFY_EXPR, TREE_TYPE (temp), temp, *p);\n+\t  *p = build2 (MODIFY_EXPR, TREE_TYPE (temp), temp, *p);\n \t  TREE_SIDE_EFFECTS (wrapper) = 1;\n \t}\n \n@@ -900,7 +900,7 @@ build_stack_save_restore (tree *save, tree *restore)\n \t\t\t\tNULL_TREE);\n   tmp_var = create_tmp_var (ptr_type_node, \"saved_stack\");\n \n-  *save = build (MODIFY_EXPR, ptr_type_node, tmp_var, save_call);\n+  *save = build2 (MODIFY_EXPR, ptr_type_node, tmp_var, save_call);\n   *restore =\n     build_function_call_expr (implicit_built_in_decls[BUILT_IN_STACK_RESTORE],\n \t\t\t      tree_cons (NULL_TREE, tmp_var, NULL_TREE));\n@@ -947,8 +947,8 @@ gimplify_bind_expr (tree *expr_p, tree temp, tree *pre_p)\n \t format of the emitted code: see mx_register_decls().  */\n       build_stack_save_restore (&stack_save, &stack_restore);\n \n-      t = build (TRY_FINALLY_EXPR, void_type_node,\n-\t\t BIND_EXPR_BODY (bind_expr), NULL_TREE);\n+      t = build2 (TRY_FINALLY_EXPR, void_type_node,\n+\t\t  BIND_EXPR_BODY (bind_expr), NULL_TREE);\n       append_to_statement_list (stack_restore, &TREE_OPERAND (t, 1));\n \n       BIND_EXPR_BODY (bind_expr) = NULL_TREE;\n@@ -1038,7 +1038,7 @@ gimplify_return_expr (tree stmt, tree *pre_p)\n   if (result == result_decl)\n     ret_expr = result;\n   else\n-    ret_expr = build (MODIFY_EXPR, TREE_TYPE (result), result_decl, result);\n+    ret_expr = build2 (MODIFY_EXPR, TREE_TYPE (result), result_decl, result);\n   TREE_OPERAND (stmt, 0) = ret_expr;\n \n   return GS_ALL_DONE;\n@@ -1107,7 +1107,7 @@ gimplify_decl_expr (tree *stmt_p)\n \t  if (!TREE_STATIC (decl))\n \t    {\n \t      DECL_INITIAL (decl) = NULL_TREE;\n-\t      init = build (MODIFY_EXPR, void_type_node, decl, init);\n+\t      init = build2 (MODIFY_EXPR, void_type_node, decl, init);\n \t      gimplify_and_add (init, stmt_p);\n \t    }\n \t  else\n@@ -1253,11 +1253,11 @@ gimplify_switch_expr (tree *expr_p, tree *pre_p)\n \t{\n \t  /* If the switch has no default label, add one, so that we jump\n \t     around the switch body.  */\n-\t  default_case = build (CASE_LABEL_EXPR, void_type_node, NULL_TREE,\n-\t\t\t\tNULL_TREE, create_artificial_label ());\n+\t  default_case = build3 (CASE_LABEL_EXPR, void_type_node, NULL_TREE,\n+\t\t\t\t NULL_TREE, create_artificial_label ());\n \t  append_to_statement_list (SWITCH_BODY (switch_expr), pre_p);\n-\t  *expr_p = build (LABEL_EXPR, void_type_node,\n-\t\t\t   CASE_LABEL (default_case));\n+\t  *expr_p = build1 (LABEL_EXPR, void_type_node,\n+\t\t\t    CASE_LABEL (default_case));\n \t}\n       else\n \t*expr_p = SWITCH_BODY (switch_expr);\n@@ -1285,7 +1285,7 @@ gimplify_case_label_expr (tree *expr_p)\n \n   gcc_assert (gimplify_ctxp->case_labels);\n   VEC_safe_push (tree, heap, gimplify_ctxp->case_labels, expr);\n-  *expr_p = build (LABEL_EXPR, void_type_node, CASE_LABEL (expr));\n+  *expr_p = build1 (LABEL_EXPR, void_type_node, CASE_LABEL (expr));\n   return GS_ALL_DONE;\n }\n \n@@ -1319,7 +1319,7 @@ gimplify_exit_expr (tree *expr_p)\n   tree expr;\n \n   expr = build_and_jump (&gimplify_ctxp->exit_label);\n-  expr = build (COND_EXPR, void_type_node, cond, expr, NULL_TREE);\n+  expr = build3 (COND_EXPR, void_type_node, cond, expr, NULL_TREE);\n   *expr_p = expr;\n \n   return GS_OK;\n@@ -1759,8 +1759,8 @@ gimplify_self_mod_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \treturn ret;\n     }\n \n-  t1 = build (arith_code, TREE_TYPE (*expr_p), lhs, rhs);\n-  t1 = build (MODIFY_EXPR, TREE_TYPE (lvalue), lvalue, t1);\n+  t1 = build2 (arith_code, TREE_TYPE (*expr_p), lhs, rhs);\n+  t1 = build2 (MODIFY_EXPR, TREE_TYPE (lvalue), lvalue, t1);\n \n   if (postfix)\n     {\n@@ -2007,17 +2007,17 @@ shortcut_cond_r (tree pred, tree *true_label_p, tree *false_label_p)\n \t   if (b) goto yes; else goto no;\n \t else\n \t   if (c) goto yes; else goto no;  */\n-      expr = build (COND_EXPR, void_type_node, TREE_OPERAND (pred, 0),\n-\t\t    shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p,\n-\t\t\t\t     false_label_p),\n-\t\t    shortcut_cond_r (TREE_OPERAND (pred, 2), true_label_p,\n-\t\t\t\t     false_label_p));\n+      expr = build3 (COND_EXPR, void_type_node, TREE_OPERAND (pred, 0),\n+\t\t     shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p,\n+\t\t\t\t      false_label_p),\n+\t\t     shortcut_cond_r (TREE_OPERAND (pred, 2), true_label_p,\n+\t\t\t\t      false_label_p));\n     }\n   else\n     {\n-      expr = build (COND_EXPR, void_type_node, pred,\n-\t\t    build_and_jump (true_label_p),\n-\t\t    build_and_jump (false_label_p));\n+      expr = build3 (COND_EXPR, void_type_node, pred,\n+\t\t     build_and_jump (true_label_p),\n+\t\t     build_and_jump (false_label_p));\n     }\n \n   if (local_label)\n@@ -2052,7 +2052,7 @@ shortcut_cond_expr (tree expr)\n \t  then_ = shortcut_cond_expr (expr);\n \t  then_se = then_ && TREE_SIDE_EFFECTS (then_);\n \t  pred = TREE_OPERAND (pred, 0);\n-\t  expr = build (COND_EXPR, void_type_node, pred, then_, NULL_TREE);\n+\t  expr = build3 (COND_EXPR, void_type_node, pred, then_, NULL_TREE);\n \t}\n     }\n   if (!then_se)\n@@ -2067,7 +2067,7 @@ shortcut_cond_expr (tree expr)\n \t  else_ = shortcut_cond_expr (expr);\n \t  else_se = else_ && TREE_SIDE_EFFECTS (else_);\n \t  pred = TREE_OPERAND (pred, 0);\n-\t  expr = build (COND_EXPR, void_type_node, pred, NULL_TREE, else_);\n+\t  expr = build3 (COND_EXPR, void_type_node, pred, NULL_TREE, else_);\n \t}\n     }\n \n@@ -2282,8 +2282,8 @@ gimplify_cond_expr (tree *expr_p, tree *pre_p, tree *post_p, tree target,\n \t  \n \t  tmp2 = tmp = create_tmp_var (type, \"iftmp\");\n \n-\t  expr = build (COND_EXPR, void_type_node, TREE_OPERAND (expr, 0),\n-\t\t\tTREE_OPERAND (expr, 1), TREE_OPERAND (expr, 2));\n+\t  expr = build3 (COND_EXPR, void_type_node, TREE_OPERAND (expr, 0),\n+\t\t\t TREE_OPERAND (expr, 1), TREE_OPERAND (expr, 2));\n \n \t  result = build_fold_indirect_ref (tmp);\n \t  ret = GS_ALL_DONE;\n@@ -2293,12 +2293,12 @@ gimplify_cond_expr (tree *expr_p, tree *pre_p, tree *post_p, tree target,\n \t if this branch is void; in C++ it can be, if it's a throw.  */\n       if (TREE_TYPE (TREE_OPERAND (expr, 1)) != void_type_node)\n \tTREE_OPERAND (expr, 1)\n-\t  = build (MODIFY_EXPR, void_type_node, tmp, TREE_OPERAND (expr, 1));\n+\t  = build2 (MODIFY_EXPR, void_type_node, tmp, TREE_OPERAND (expr, 1));\n \n       /* Build the else clause, 't1 = b;'.  */\n       if (TREE_TYPE (TREE_OPERAND (expr, 2)) != void_type_node)\n \tTREE_OPERAND (expr, 2)\n-\t  = build (MODIFY_EXPR, void_type_node, tmp2, TREE_OPERAND (expr, 2));\n+\t  = build2 (MODIFY_EXPR, void_type_node, tmp2, TREE_OPERAND (expr, 2));\n \n       TREE_TYPE (expr) = void_type_node;\n       recalculate_side_effects (expr);\n@@ -2712,14 +2712,14 @@ gimplify_init_ctor_eval (tree object, VEC(constructor_elt,gc) *elts,\n \n       if (array_elt_type)\n \t{\n-\t  cref = build (ARRAY_REF, array_elt_type, unshare_expr (object),\n-\t\t\tpurpose, NULL_TREE, NULL_TREE);\n+\t  cref = build4 (ARRAY_REF, array_elt_type, unshare_expr (object),\n+\t\t\t purpose, NULL_TREE, NULL_TREE);\n \t}\n       else\n \t{\n \t  gcc_assert (TREE_CODE (purpose) == FIELD_DECL);\n-\t  cref = build (COMPONENT_REF, TREE_TYPE (purpose),\n-\t\t\tunshare_expr (object), purpose, NULL_TREE);\n+\t  cref = build3 (COMPONENT_REF, TREE_TYPE (purpose),\n+\t\t\t unshare_expr (object), purpose, NULL_TREE);\n \t}\n \n       if (TREE_CODE (value) == CONSTRUCTOR\n@@ -2728,7 +2728,7 @@ gimplify_init_ctor_eval (tree object, VEC(constructor_elt,gc) *elts,\n \t\t\t\t pre_p, cleared);\n       else\n \t{\n-\t  init = build (MODIFY_EXPR, TREE_TYPE (cref), cref, value);\n+\t  init = build2 (MODIFY_EXPR, TREE_TYPE (cref), cref, value);\n \t  gimplify_and_add (init, pre_p);\n \t}\n     }\n@@ -2946,7 +2946,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t  }\n \telse\n \t  {\n-\t    ctor = build (COMPLEX_EXPR, type, r, i);\n+\t    ctor = build2 (COMPLEX_EXPR, type, r, i);\n \t    TREE_OPERAND (*expr_p, 1) = ctor;\n \t    ret = gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p, post_p,\n \t\t\t\t rhs_predicate_for (TREE_OPERAND (*expr_p, 0)),\n@@ -3377,7 +3377,7 @@ gimplify_variable_sized_compare (tree *expr_p)\n   t = implicit_built_in_decls[BUILT_IN_MEMCMP];\n   t = build_function_call_expr (t, args);\n   *expr_p\n-    = build (TREE_CODE (*expr_p), TREE_TYPE (*expr_p), t, integer_zero_node);\n+    = build2 (TREE_CODE (*expr_p), TREE_TYPE (*expr_p), t, integer_zero_node);\n \n   return GS_OK;\n }\n@@ -3400,9 +3400,9 @@ gimplify_boolean_expr (tree *expr_p)\n   /* Preserve the original type of the expression.  */\n   tree type = TREE_TYPE (*expr_p);\n \n-  *expr_p = build (COND_EXPR, type, *expr_p,\n-\t\t   convert (type, boolean_true_node),\n-\t\t   convert (type, boolean_false_node));\n+  *expr_p = build3 (COND_EXPR, type, *expr_p,\n+\t\t    convert (type, boolean_true_node),\n+\t\t    convert (type, boolean_false_node));\n \n   return GS_OK;\n }\n@@ -3847,7 +3847,7 @@ gimplify_cleanup_point_expr (tree *expr_p, tree *pre_p)\n \t\tcode = TRY_FINALLY_EXPR;\n \n \t      sl = tsi_split_statement_list_after (&iter);\n-\t      tfe = build (code, void_type_node, sl, NULL_TREE);\n+\t      tfe = build2 (code, void_type_node, sl, NULL_TREE);\n \t      append_to_statement_list (TREE_OPERAND (wce, 0),\n \t\t\t\t        &TREE_OPERAND (tfe, 1));\n \t      *wce_p = tfe;\n@@ -3908,12 +3908,12 @@ gimple_push_cleanup (tree var, tree cleanup, bool eh_only, tree *pre_p)\n       */\n \n       tree flag = create_tmp_var (boolean_type_node, \"cleanup\");\n-      tree ffalse = build (MODIFY_EXPR, void_type_node, flag,\n-\t\t\t   boolean_false_node);\n-      tree ftrue = build (MODIFY_EXPR, void_type_node, flag,\n-\t\t\t  boolean_true_node);\n-      cleanup = build (COND_EXPR, void_type_node, flag, cleanup, NULL);\n-      wce = build (WITH_CLEANUP_EXPR, void_type_node, cleanup);\n+      tree ffalse = build2 (MODIFY_EXPR, void_type_node, flag,\n+\t\t\t    boolean_false_node);\n+      tree ftrue = build2 (MODIFY_EXPR, void_type_node, flag,\n+\t\t\t   boolean_true_node);\n+      cleanup = build3 (COND_EXPR, void_type_node, flag, cleanup, NULL);\n+      wce = build1 (WITH_CLEANUP_EXPR, void_type_node, cleanup);\n       append_to_statement_list (ffalse, &gimplify_ctxp->conditional_cleanups);\n       append_to_statement_list (wce, &gimplify_ctxp->conditional_cleanups);\n       append_to_statement_list (ftrue, pre_p);\n@@ -3925,7 +3925,7 @@ gimple_push_cleanup (tree var, tree cleanup, bool eh_only, tree *pre_p)\n     }\n   else\n     {\n-      wce = build (WITH_CLEANUP_EXPR, void_type_node, cleanup);\n+      wce = build1 (WITH_CLEANUP_EXPR, void_type_node, cleanup);\n       CLEANUP_EH_ONLY (wce) = eh_only;\n       append_to_statement_list (wce, pre_p);\n     }\n@@ -3961,7 +3961,7 @@ gimplify_target_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \t    gimplify_bind_expr (&init, temp, pre_p);\n \t  if (init != temp)\n \t    {\n-\t      init = build (MODIFY_EXPR, void_type_node, temp, init);\n+\t      init = build2 (MODIFY_EXPR, void_type_node, temp, init);\n \t      ret = gimplify_expr (&init, pre_p, post_p, is_gimple_stmt,\n \t\t\t\t   fb_none);\n \t    }\n@@ -4562,7 +4562,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t     given a TREE_ADDRESSABLE type.  */\n \t  tree tmp = create_tmp_var_raw (type, \"vol\");\n \t  gimple_add_tmp_var (tmp);\n-\t  *expr_p = build (MODIFY_EXPR, type, tmp, *expr_p);\n+\t  *expr_p = build2 (MODIFY_EXPR, type, tmp, *expr_p);\n \t}\n       else\n \t/* We can't do anything useful with a volatile reference to\n@@ -4912,8 +4912,8 @@ gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n   /* If there isn't an outer BIND_EXPR, add one.  */\n   if (TREE_CODE (body) != BIND_EXPR)\n     {\n-      tree b = build (BIND_EXPR, void_type_node, NULL_TREE,\n-\t\t      NULL_TREE, NULL_TREE);\n+      tree b = build3 (BIND_EXPR, void_type_node, NULL_TREE,\n+\t\t       NULL_TREE, NULL_TREE);\n       TREE_SIDE_EFFECTS (b) = 1;\n       append_to_statement_list_force (body, &BIND_EXPR_BODY (b));\n       body = b;\n@@ -4983,15 +4983,15 @@ gimplify_function_tree (tree fndecl)\n     {\n       tree tf, x, bind;\n \n-      tf = build (TRY_FINALLY_EXPR, void_type_node, NULL, NULL);\n+      tf = build2 (TRY_FINALLY_EXPR, void_type_node, NULL, NULL);\n       TREE_SIDE_EFFECTS (tf) = 1;\n       x = DECL_SAVED_TREE (fndecl);\n       append_to_statement_list (x, &TREE_OPERAND (tf, 0));\n       x = implicit_built_in_decls[BUILT_IN_PROFILE_FUNC_EXIT];\n       x = build_function_call_expr (x, NULL);\n       append_to_statement_list (x, &TREE_OPERAND (tf, 1));\n \n-      bind = build (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n+      bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n       TREE_SIDE_EFFECTS (bind) = 1;\n       x = implicit_built_in_decls[BUILT_IN_PROFILE_FUNC_ENTER];\n       x = build_function_call_expr (x, NULL);\n@@ -5029,7 +5029,7 @@ force_gimple_operand (tree expr, tree *stmts, bool simple, tree var)\n   gimplify_ctxp->into_ssa = in_ssa_p;\n \n   if (var)\n-    expr = build (MODIFY_EXPR, TREE_TYPE (var), var, expr);\n+    expr = build2 (MODIFY_EXPR, TREE_TYPE (var), var, expr);\n \n   ret = gimplify_expr (&expr, stmts, NULL,\n \t\t       gimple_test_f, fb_rvalue);"}, {"sha": "c468b64b1e5ebba89403d5322d00d7a2c06204ae", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -298,8 +298,8 @@ factor_computed_gotos (void)\n \t    }\n \n \t  /* Copy the original computed goto's destination into VAR.  */\n-\t  assignment = build (MODIFY_EXPR, ptr_type_node,\n-\t\t\t      var, GOTO_DESTINATION (last));\n+\t  assignment = build2 (MODIFY_EXPR, ptr_type_node,\n+\t\t\t       var, GOTO_DESTINATION (last));\n \t  bsi_insert_before (&bsi, assignment, BSI_SAME_STMT);\n \n \t  /* And re-vector the computed goto to the new destination.  */\n@@ -5074,7 +5074,7 @@ gimplify_val (block_stmt_iterator *bsi, tree type, tree exp)\n     return exp;\n \n   t = make_rename_temp (type, NULL);\n-  new_stmt = build (MODIFY_EXPR, type, t, exp);\n+  new_stmt = build2 (MODIFY_EXPR, type, t, exp);\n \n   orig_stmt = bsi_stmt (*bsi);\n   SET_EXPR_LOCUS (new_stmt, EXPR_LOCUS (orig_stmt));"}, {"sha": "683eade7fec01f34fc3cc7b89d2717855e886fd3", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -105,8 +105,8 @@ build_polynomial_chrec (unsigned loop_num,\n       || right == chrec_dont_know)\n     return chrec_dont_know;\n \n-  return build (POLYNOMIAL_CHREC, TREE_TYPE (left), \n-\t\tbuild_int_cst (NULL_TREE, loop_num), left, right);\n+  return build3 (POLYNOMIAL_CHREC, TREE_TYPE (left), \n+\t\t build_int_cst (NULL_TREE, loop_num), left, right);\n }\n \n \f"}, {"sha": "d85674257f45dbe9813977b5c67173a26607e2fa", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -629,7 +629,7 @@ update_complex_assignment (block_stmt_iterator *bsi, tree r, tree i)\n     update_complex_components (bsi, stmt, r, i);\n   \n   type = TREE_TYPE (TREE_OPERAND (mod, 1));\n-  TREE_OPERAND (mod, 1) = build (COMPLEX_EXPR, type, r, i);\n+  TREE_OPERAND (mod, 1) = build2 (COMPLEX_EXPR, type, r, i);\n   update_stmt (stmt);\n }\n \n@@ -1055,7 +1055,7 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n     {\n       edge e;\n \n-      cond = build (COND_EXPR, void_type_node, cond, NULL, NULL);\n+      cond = build3 (COND_EXPR, void_type_node, cond, NULL_TREE, NULL_TREE);\n       bsi_insert_before (bsi, cond, BSI_SAME_STMT);\n \n       /* Split the original block, and create the TRUE and FALSE blocks.  */\n@@ -1065,8 +1065,8 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n       bb_true = create_empty_bb (bb_cond);\n       bb_false = create_empty_bb (bb_true);\n \n-      t1 = build (GOTO_EXPR, void_type_node, tree_block_label (bb_true));\n-      t2 = build (GOTO_EXPR, void_type_node, tree_block_label (bb_false));\n+      t1 = build1 (GOTO_EXPR, void_type_node, tree_block_label (bb_true));\n+      t2 = build1 (GOTO_EXPR, void_type_node, tree_block_label (bb_false));\n       COND_EXPR_THEN (cond) = t1;\n       COND_EXPR_ELSE (cond) = t2;\n \n@@ -1120,9 +1120,9 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n \n      if (bb_true)\n        {\n-\t t1 = build (MODIFY_EXPR, inner_type, rr, tr);\n+\t t1 = build2 (MODIFY_EXPR, inner_type, rr, tr);\n \t bsi_insert_before (bsi, t1, BSI_SAME_STMT);\n-\t t1 = build (MODIFY_EXPR, inner_type, ri, ti);\n+\t t1 = build2 (MODIFY_EXPR, inner_type, ri, ti);\n \t bsi_insert_before (bsi, t1, BSI_SAME_STMT);\n \t bsi_remove (bsi);\n        }\n@@ -1159,9 +1159,9 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n \n      if (bb_false)\n        {\n-\t t1 = build (MODIFY_EXPR, inner_type, rr, tr);\n+\t t1 = build2 (MODIFY_EXPR, inner_type, rr, tr);\n \t bsi_insert_before (bsi, t1, BSI_SAME_STMT);\n-\t t1 = build (MODIFY_EXPR, inner_type, ri, ti);\n+\t t1 = build2 (MODIFY_EXPR, inner_type, ri, ti);\n \t bsi_insert_before (bsi, t1, BSI_SAME_STMT);\n \t bsi_remove (bsi);\n        }"}, {"sha": "859d68743da74833d1e9971a7405a6bbfa5c6394", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -644,13 +644,13 @@ do_return_redirection (struct goto_queue_node *q, tree finlab, tree mod,\n \t    else\n \t      new = *return_value_p;\n \n-\t    x = build (MODIFY_EXPR, TREE_TYPE (new), new, old);\n+\t    x = build2 (MODIFY_EXPR, TREE_TYPE (new), new, old);\n \t    append_to_statement_list (x, &q->repl_stmt);\n \n \t    if (new == result)\n \t      x = result;\n \t    else\n-\t      x = build (MODIFY_EXPR, TREE_TYPE (result), result, new);\n+\t      x = build2 (MODIFY_EXPR, TREE_TYPE (result), result, new);\n \t    q->cont_stmt = build1 (RETURN_EXPR, void_type_node, x);\n \t  }\n \n@@ -839,21 +839,21 @@ honor_protect_cleanup_actions (struct leh_state *outer_state,\n       save_filt = create_tmp_var (integer_type_node, \"save_filt\");\n \n       i = tsi_start (finally);\n-      x = build (EXC_PTR_EXPR, ptr_type_node);\n-      x = build (MODIFY_EXPR, void_type_node, save_eptr, x);\n+      x = build0 (EXC_PTR_EXPR, ptr_type_node);\n+      x = build2 (MODIFY_EXPR, void_type_node, save_eptr, x);\n       tsi_link_before (&i, x, TSI_CONTINUE_LINKING);\n \n-      x = build (FILTER_EXPR, integer_type_node);\n-      x = build (MODIFY_EXPR, void_type_node, save_filt, x);\n+      x = build0 (FILTER_EXPR, integer_type_node);\n+      x = build2 (MODIFY_EXPR, void_type_node, save_filt, x);\n       tsi_link_before (&i, x, TSI_CONTINUE_LINKING);\n \n       i = tsi_last (finally);\n-      x = build (EXC_PTR_EXPR, ptr_type_node);\n-      x = build (MODIFY_EXPR, void_type_node, x, save_eptr);\n+      x = build0 (EXC_PTR_EXPR, ptr_type_node);\n+      x = build2 (MODIFY_EXPR, void_type_node, x, save_eptr);\n       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n \n-      x = build (FILTER_EXPR, integer_type_node);\n-      x = build (MODIFY_EXPR, void_type_node, x, save_filt);\n+      x = build0 (FILTER_EXPR, integer_type_node);\n+      x = build2 (MODIFY_EXPR, void_type_node, x, save_filt);\n       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n \n       x = build_resx (get_eh_region_number (tf->region));\n@@ -863,10 +863,10 @@ honor_protect_cleanup_actions (struct leh_state *outer_state,\n   /* Wrap the block with protect_cleanup_actions as the action.  */\n   if (protect_cleanup_actions)\n     {\n-      x = build (EH_FILTER_EXPR, void_type_node, NULL, NULL);\n+      x = build2 (EH_FILTER_EXPR, void_type_node, NULL, NULL);\n       append_to_statement_list (protect_cleanup_actions, &EH_FILTER_FAILURE (x));\n       EH_FILTER_MUST_NOT_THROW (x) = 1;\n-      finally = build (TRY_CATCH_EXPR, void_type_node, finally, x);\n+      finally = build2 (TRY_CATCH_EXPR, void_type_node, finally, x);\n       lower_eh_filter (outer_state, &finally);\n     }\n   else\n@@ -1163,8 +1163,8 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n   finally_label = create_artificial_label ();\n \n   case_label_vec = make_tree_vec (ndests);\n-  switch_stmt = build (SWITCH_EXPR, integer_type_node, finally_tmp,\n-\t\t       NULL_TREE, case_label_vec);\n+  switch_stmt = build3 (SWITCH_EXPR, integer_type_node, finally_tmp,\n+\t\t        NULL_TREE, case_label_vec);\n   switch_body = NULL;\n   last_case = NULL;\n   last_case_index = 0;\n@@ -1175,8 +1175,8 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n \n   if (tf->may_fallthru)\n     {\n-      x = build (MODIFY_EXPR, void_type_node, finally_tmp,\n-\t\t build_int_cst (NULL_TREE, fallthru_index));\n+      x = build2 (MODIFY_EXPR, void_type_node, finally_tmp,\n+\t\t  build_int_cst (NULL_TREE, fallthru_index));\n       append_to_statement_list (x, tf->top_p);\n \n       if (tf->may_throw)\n@@ -1186,13 +1186,13 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n \t}\n \n \n-      last_case = build (CASE_LABEL_EXPR, void_type_node,\n-\t\t\t build_int_cst (NULL_TREE, fallthru_index), NULL,\n-\t\t\t create_artificial_label ());\n+      last_case = build3 (CASE_LABEL_EXPR, void_type_node,\n+\t\t\t  build_int_cst (NULL_TREE, fallthru_index), NULL,\n+\t\t\t  create_artificial_label ());\n       TREE_VEC_ELT (case_label_vec, last_case_index) = last_case;\n       last_case_index++;\n \n-      x = build (LABEL_EXPR, void_type_node, CASE_LABEL (last_case));\n+      x = build1 (LABEL_EXPR, void_type_node, CASE_LABEL (last_case));\n       append_to_statement_list (x, &switch_body);\n \n       x = lower_try_finally_fallthru_label (tf);\n@@ -1205,17 +1205,17 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n       x = build1 (LABEL_EXPR, void_type_node, tf->eh_label);\n       append_to_statement_list (x, tf->top_p);\n \n-      x = build (MODIFY_EXPR, void_type_node, finally_tmp,\n-\t\t build_int_cst (NULL_TREE, eh_index));\n+      x = build2 (MODIFY_EXPR, void_type_node, finally_tmp,\n+\t\t  build_int_cst (NULL_TREE, eh_index));\n       append_to_statement_list (x, tf->top_p);\n \n-      last_case = build (CASE_LABEL_EXPR, void_type_node,\n-\t\t\t build_int_cst (NULL_TREE, eh_index), NULL,\n-\t\t\t create_artificial_label ());\n+      last_case = build3 (CASE_LABEL_EXPR, void_type_node,\n+\t\t\t  build_int_cst (NULL_TREE, eh_index), NULL,\n+\t\t\t  create_artificial_label ());\n       TREE_VEC_ELT (case_label_vec, last_case_index) = last_case;\n       last_case_index++;\n \n-      x = build (LABEL_EXPR, void_type_node, CASE_LABEL (last_case));\n+      x = build1 (LABEL_EXPR, void_type_node, CASE_LABEL (last_case));\n       append_to_statement_list (x, &switch_body);\n       x = build_resx (get_eh_region_number (tf->region));\n       append_to_statement_list (x, &switch_body);\n@@ -1237,31 +1237,31 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n \n       if (q->index < 0)\n \t{\n-\t  mod = build (MODIFY_EXPR, void_type_node, finally_tmp,\n-\t\t       build_int_cst (NULL_TREE, return_index));\n+\t  mod = build2 (MODIFY_EXPR, void_type_node, finally_tmp,\n+\t\t        build_int_cst (NULL_TREE, return_index));\n \t  do_return_redirection (q, finally_label, mod, &return_val);\n \t  switch_id = return_index;\n \t}\n       else\n \t{\n-\t  mod = build (MODIFY_EXPR, void_type_node, finally_tmp,\n-\t\t       build_int_cst (NULL_TREE, q->index));\n+\t  mod = build2 (MODIFY_EXPR, void_type_node, finally_tmp,\n+\t\t        build_int_cst (NULL_TREE, q->index));\n \t  do_goto_redirection (q, finally_label, mod);\n \t  switch_id = q->index;\n \t}\n \n       case_index = j + q->index;\n       if (!TREE_VEC_ELT (case_label_vec, case_index))\n \tTREE_VEC_ELT (case_label_vec, case_index)\n-\t  = build (CASE_LABEL_EXPR, void_type_node,\n-\t\t   build_int_cst (NULL_TREE, switch_id), NULL,\n-\t\t   /* We store the cont_stmt in the\n-\t\t      CASE_LABEL, so that we can recover it\n-\t\t      in the loop below.  We don't create\n-\t\t      the new label while walking the\n-\t\t      goto_queue because pointers don't\n-\t\t      offer a stable order.  */\n-\t\t   q->cont_stmt);\n+\t  = build3 (CASE_LABEL_EXPR, void_type_node,\n+\t\t    build_int_cst (NULL_TREE, switch_id), NULL,\n+\t\t    /* We store the cont_stmt in the\n+\t\t       CASE_LABEL, so that we can recover it\n+\t\t       in the loop below.  We don't create\n+\t\t       the new label while walking the\n+\t\t       goto_queue because pointers don't\n+\t\t       offer a stable order.  */\n+\t\t    q->cont_stmt);\n     }\n   for (j = last_case_index; j < last_case_index + nlabels; j++)\n     {\n@@ -1277,7 +1277,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n       label = create_artificial_label ();\n       CASE_LABEL (last_case) = label;\n \n-      x = build (LABEL_EXPR, void_type_node, label);\n+      x = build1 (LABEL_EXPR, void_type_node, label);\n       append_to_statement_list (x, &switch_body);\n       append_to_statement_list (cont_stmt, &switch_body);\n       maybe_record_in_goto_queue (state, cont_stmt);"}, {"sha": "f87d64d680dbda598fe21ea9b16046358ec856da", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -630,8 +630,8 @@ add_to_dst_predicate_list (struct loop * loop, basic_block bb,\n         bsi_insert_before (bsi, tmp_stmts2, BSI_SAME_STMT);\n \n       /* new_cond == prev_cond AND cond */\n-      tmp = build (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t   unshare_expr (prev_cond), cond);\n+      tmp = build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t    unshare_expr (prev_cond), cond);\n       tmp_stmt = ifc_temp_var (boolean_type_node, tmp);\n       bsi_insert_before (bsi, tmp_stmt, BSI_SAME_STMT);\n       new_cond = TREE_OPERAND (tmp_stmt, 0);\n@@ -792,13 +792,13 @@ replace_phi_with_cond_modify_expr (tree phi, tree cond, basic_block true_bb,\n     }\n \n   /* Build new RHS using selected condition and arguments.  */\n-  rhs = build (COND_EXPR, TREE_TYPE (PHI_RESULT (phi)),\n-\t       unshare_expr (cond), unshare_expr (arg_0),\n-\t       unshare_expr (arg_1));\n+  rhs = build3 (COND_EXPR, TREE_TYPE (PHI_RESULT (phi)),\n+\t        unshare_expr (cond), unshare_expr (arg_0),\n+\t        unshare_expr (arg_1));\n \n   /* Create new MODIFY expression using RHS.  */\n-  new_stmt = build (MODIFY_EXPR, TREE_TYPE (PHI_RESULT (phi)),\n-\t\t    unshare_expr (PHI_RESULT (phi)), rhs);\n+  new_stmt = build2 (MODIFY_EXPR, TREE_TYPE (PHI_RESULT (phi)),\n+\t\t     unshare_expr (PHI_RESULT (phi)), rhs);\n \n   /* Make new statement definition of the original phi result.  */\n   SSA_NAME_DEF_STMT (PHI_RESULT (phi)) = new_stmt;\n@@ -993,7 +993,7 @@ ifc_temp_var (tree type, tree exp)\n   add_referenced_tmp_var (var);\n \n   /* Build new statement to assign EXP to new variable.  */\n-  stmt = build (MODIFY_EXPR, type, var, exp);\n+  stmt = build2 (MODIFY_EXPR, type, var, exp);\n \n   /* Get SSA name for the new variable and set make new statement\n      its definition statement.  */"}, {"sha": "e26bab63b934696c719e6013a89de07c905919c8", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -1148,7 +1148,7 @@ setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n \n       /* We want to use MODIFY_EXPR, not INIT_EXPR here so that we\n \t keep our trees in gimple form.  */\n-      init_stmt = build (MODIFY_EXPR, TREE_TYPE (var), var, rhs);\n+      init_stmt = build2 (MODIFY_EXPR, TREE_TYPE (var), var, rhs);\n \n       /* If we did not create a gimple value and we did not create a gimple\n \t cast of a gimple value, then we will need to gimplify INIT_STMTS"}, {"sha": "7384be0a6b7927579063bee16682f099adaf91c4", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -453,14 +453,14 @@ mf_decl_cache_locals (void)\n \n   /* Build initialization nodes for the cache vars.  We just load the\n      globals into the cache variables.  */\n-  t = build (MODIFY_EXPR, TREE_TYPE (mf_cache_shift_decl_l),\n-             mf_cache_shift_decl_l, mf_cache_shift_decl);\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (mf_cache_shift_decl_l),\n+              mf_cache_shift_decl_l, mf_cache_shift_decl);\n   SET_EXPR_LOCATION (t, DECL_SOURCE_LOCATION (current_function_decl));\n   gimplify_to_stmt_list (&t);\n   shift_init_stmts = t;\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (mf_cache_mask_decl_l),\n-             mf_cache_mask_decl_l, mf_cache_mask_decl);\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (mf_cache_mask_decl_l),\n+              mf_cache_mask_decl_l, mf_cache_mask_decl);\n   SET_EXPR_LOCATION (t, DECL_SOURCE_LOCATION (current_function_decl));\n   gimplify_to_stmt_list (&t);\n   mask_init_stmts = t;\n@@ -548,31 +548,31 @@ mf_build_check_statement_for (tree base, tree limit,\n   mf_limit = create_tmp_var (mf_uintptr_type, \"__mf_limit\");\n \n   /* Build: __mf_base = (uintptr_t) <base address expression>.  */\n-  t = build (MODIFY_EXPR, void_type_node, mf_base,\n-             convert (mf_uintptr_type, unshare_expr (base)));\n+  t = build2 (MODIFY_EXPR, void_type_node, mf_base,\n+              convert (mf_uintptr_type, unshare_expr (base)));\n   SET_EXPR_LOCUS (t, locus);\n   gimplify_to_stmt_list (&t);\n   head = tsi_start (t);\n   tsi = tsi_last (t);\n \n   /* Build: __mf_limit = (uintptr_t) <limit address expression>.  */\n-  t = build (MODIFY_EXPR, void_type_node, mf_limit,\n-             convert (mf_uintptr_type, unshare_expr (limit)));\n+  t = build2 (MODIFY_EXPR, void_type_node, mf_limit,\n+              convert (mf_uintptr_type, unshare_expr (limit)));\n   SET_EXPR_LOCUS (t, locus);\n   gimplify_to_stmt_list (&t);\n   tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n \n   /* Build: __mf_elem = &__mf_lookup_cache [(__mf_base >> __mf_shift)\n                                             & __mf_mask].  */\n-  t = build (RSHIFT_EXPR, mf_uintptr_type, mf_base,\n-             (flag_mudflap_threads ? mf_cache_shift_decl : mf_cache_shift_decl_l));\n-  t = build (BIT_AND_EXPR, mf_uintptr_type, t,\n-             (flag_mudflap_threads ? mf_cache_mask_decl : mf_cache_mask_decl_l));\n-  t = build (ARRAY_REF,\n-             TREE_TYPE (TREE_TYPE (mf_cache_array_decl)),\n-             mf_cache_array_decl, t, NULL_TREE, NULL_TREE);\n+  t = build2 (RSHIFT_EXPR, mf_uintptr_type, mf_base,\n+              (flag_mudflap_threads ? mf_cache_shift_decl : mf_cache_shift_decl_l));\n+  t = build2 (BIT_AND_EXPR, mf_uintptr_type, t,\n+              (flag_mudflap_threads ? mf_cache_mask_decl : mf_cache_mask_decl_l));\n+  t = build4 (ARRAY_REF,\n+              TREE_TYPE (TREE_TYPE (mf_cache_array_decl)),\n+              mf_cache_array_decl, t, NULL_TREE, NULL_TREE);\n   t = build1 (ADDR_EXPR, mf_cache_structptr_type, t);\n-  t = build (MODIFY_EXPR, void_type_node, mf_elem, t);\n+  t = build2 (MODIFY_EXPR, void_type_node, mf_elem, t);\n   SET_EXPR_LOCUS (t, locus);\n   gimplify_to_stmt_list (&t);\n   tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n@@ -592,10 +592,10 @@ mf_build_check_statement_for (tree base, tree limit,\n      the edge to the THEN clause of the conditional jump as unlikely.  */\n \n   /* Construct t <-- '__mf_elem->low  > __mf_base'.  */\n-  t = build (COMPONENT_REF, mf_uintptr_type,\n-             build1 (INDIRECT_REF, mf_cache_struct_type, mf_elem),\n-             TYPE_FIELDS (mf_cache_struct_type), NULL_TREE);\n-  t = build (GT_EXPR, boolean_type_node, t, mf_base);\n+  t = build3 (COMPONENT_REF, mf_uintptr_type,\n+              build1 (INDIRECT_REF, mf_cache_struct_type, mf_elem),\n+              TYPE_FIELDS (mf_cache_struct_type), NULL_TREE);\n+  t = build2 (GT_EXPR, boolean_type_node, t, mf_base);\n \n   /* Construct '__mf_elem->high < __mf_limit'.\n \n@@ -605,28 +605,28 @@ mf_build_check_statement_for (tree base, tree limit,\n \n      Then build 'u <-- (u < v).  */\n \n-  u = build (COMPONENT_REF, mf_uintptr_type,\n-             build1 (INDIRECT_REF, mf_cache_struct_type, mf_elem),\n-             TREE_CHAIN (TYPE_FIELDS (mf_cache_struct_type)), NULL_TREE);\n+  u = build3 (COMPONENT_REF, mf_uintptr_type,\n+              build1 (INDIRECT_REF, mf_cache_struct_type, mf_elem),\n+              TREE_CHAIN (TYPE_FIELDS (mf_cache_struct_type)), NULL_TREE);\n \n   v = mf_limit;\n \n-  u = build (LT_EXPR, boolean_type_node, u, v);\n+  u = build2 (LT_EXPR, boolean_type_node, u, v);\n \n   /* Build the composed conditional: t <-- 't || u'.  Then store the\n      result of the evaluation of 't' in a temporary variable which we\n      can use as the condition for the conditional jump.  */\n-  t = build (TRUTH_OR_EXPR, boolean_type_node, t, u);\n+  t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, u);\n   cond = create_tmp_var (boolean_type_node, \"__mf_unlikely_cond\");\n-  t = build (MODIFY_EXPR, boolean_type_node, cond, t);\n+  t = build2 (MODIFY_EXPR, boolean_type_node, cond, t);\n   gimplify_to_stmt_list (&t);\n   tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n \n   /* Build the conditional jump.  'cond' is just a temporary so we can\n      simply build a void COND_EXPR.  We do need labels in both arms though.  */\n-  t = build (COND_EXPR, void_type_node, cond,\n-             build (GOTO_EXPR, void_type_node, tree_block_label (then_bb)),\n-             build (GOTO_EXPR, void_type_node, tree_block_label (join_bb)));\n+  t = build3 (COND_EXPR, void_type_node, cond,\n+              build1 (GOTO_EXPR, void_type_node, tree_block_label (then_bb)),\n+              build1 (GOTO_EXPR, void_type_node, tree_block_label (join_bb)));\n   SET_EXPR_LOCUS (t, locus);\n   tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n \n@@ -671,12 +671,12 @@ mf_build_check_statement_for (tree base, tree limit,\n \n   if (! flag_mudflap_threads)\n     {\n-      t = build (MODIFY_EXPR, void_type_node,\n-                 mf_cache_shift_decl_l, mf_cache_shift_decl);\n+      t = build2 (MODIFY_EXPR, void_type_node,\n+                  mf_cache_shift_decl_l, mf_cache_shift_decl);\n       tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n \n-      t = build (MODIFY_EXPR, void_type_node,\n-                 mf_cache_mask_decl_l, mf_cache_mask_decl);\n+      t = build2 (MODIFY_EXPR, void_type_node,\n+                  mf_cache_mask_decl_l, mf_cache_mask_decl);\n       tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n     }\n \n@@ -1053,8 +1053,8 @@ mx_register_decls (tree decl, tree *stmt_list)\n   /* Actually, (initially_stmts!=NULL) <=> (finally_stmts!=NULL) */\n   if (finally_stmts != NULL_TREE)\n     {\n-      tree t = build (TRY_FINALLY_EXPR, void_type_node,\n-                      *stmt_list, finally_stmts);\n+      tree t = build2 (TRY_FINALLY_EXPR, void_type_node,\n+                       *stmt_list, finally_stmts);\n       *stmt_list = NULL;\n       append_to_statement_list (t, stmt_list);\n     }"}, {"sha": "7f60faa646b09535415418ddd7236c8cea2e818e", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -380,7 +380,7 @@ init_tmp_var (struct nesting_info *info, tree exp, tree_stmt_iterator *tsi)\n   tree t, stmt;\n \n   t = create_tmp_var_for (info, TREE_TYPE (exp), NULL);\n-  stmt = build (MODIFY_EXPR, TREE_TYPE (t), t, exp);\n+  stmt = build2 (MODIFY_EXPR, TREE_TYPE (t), t, exp);\n   SET_EXPR_LOCUS (stmt, EXPR_LOCUS (tsi_stmt (*tsi)));\n   tsi_link_before (tsi, stmt, TSI_SAME_STMT);\n \n@@ -408,7 +408,7 @@ save_tmp_var (struct nesting_info *info, tree exp,\n   tree t, stmt;\n \n   t = create_tmp_var_for (info, TREE_TYPE (exp), NULL);\n-  stmt = build (MODIFY_EXPR, TREE_TYPE (t), exp, t);\n+  stmt = build2 (MODIFY_EXPR, TREE_TYPE (t), exp, t);\n   SET_EXPR_LOCUS (stmt, EXPR_LOCUS (tsi_stmt (*tsi)));\n   tsi_link_after (tsi, stmt, TSI_SAME_STMT);\n \n@@ -749,7 +749,7 @@ get_static_chain (struct nesting_info *info, tree target_context,\n \t  tree field = get_chain_field (i);\n \n \t  x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n-\t  x = build (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n+\t  x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n \t  x = init_tmp_var (info, x, tsi);\n \t}\n     }\n@@ -783,14 +783,14 @@ get_frame_field (struct nesting_info *info, tree target_context,\n \t  tree field = get_chain_field (i);\n \n \t  x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n-\t  x = build (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n+\t  x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n \t  x = init_tmp_var (info, x, tsi);\n \t}\n \n       x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n     }\n \n-  x = build (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n+  x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n   return x;\n }\n \n@@ -1370,9 +1370,9 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \t  else\n \t    x = p;\n \n-\t  y = build (COMPONENT_REF, TREE_TYPE (field),\n-\t\t     root->frame_decl, field, NULL_TREE);\n-\t  x = build (MODIFY_EXPR, TREE_TYPE (field), y, x);\n+\t  y = build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t      root->frame_decl, field, NULL_TREE);\n+\t  x = build2 (MODIFY_EXPR, TREE_TYPE (field), y, x);\n \t  append_to_statement_list (x, &stmt_list);\n \t}\n     }\n@@ -1381,9 +1381,9 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n      from chain_decl.  */\n   if (root->chain_field)\n     {\n-      tree x = build (COMPONENT_REF, TREE_TYPE (root->chain_field),\n-\t\t      root->frame_decl, root->chain_field, NULL_TREE);\n-      x = build (MODIFY_EXPR, TREE_TYPE (x), x, get_chain_decl (root));\n+      tree x = build3 (COMPONENT_REF, TREE_TYPE (root->chain_field),\n+\t\t       root->frame_decl, root->chain_field, NULL_TREE);\n+      x = build2 (MODIFY_EXPR, TREE_TYPE (x), x, get_chain_decl (root));\n       append_to_statement_list (x, &stmt_list);\n     }\n \n@@ -1408,8 +1408,8 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \t  x = build_addr (i->context, context);\n \t  arg = tree_cons (NULL, x, arg);\n \n-\t  x = build (COMPONENT_REF, TREE_TYPE (field),\n-\t\t     root->frame_decl, field, NULL_TREE);\n+\t  x = build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t      root->frame_decl, field, NULL_TREE);\n \t  x = build_addr (x, context);\n \t  arg = tree_cons (NULL, x, arg);\n "}, {"sha": "5f829881e8a28ff0ae61348cf1a92a57e4ace1b6", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -191,7 +191,7 @@ insert_copy_on_edge (edge e, tree dest, tree src)\n {\n   tree copy;\n \n-  copy = build (MODIFY_EXPR, TREE_TYPE (dest), dest, src);\n+  copy = build2 (MODIFY_EXPR, TREE_TYPE (dest), dest, src);\n   set_is_used (dest);\n \n   if (TREE_CODE (src) == ADDR_EXPR)\n@@ -2471,8 +2471,8 @@ insert_backedge_copies (void)\n \n \t\t  /* Create a new instance of the underlying\n \t\t     variable of the PHI result.  */\n-\t\t  stmt = build (MODIFY_EXPR, TREE_TYPE (result_var),\n-\t\t\t\tNULL, PHI_ARG_DEF (phi, i));\n+\t\t  stmt = build2 (MODIFY_EXPR, TREE_TYPE (result_var),\n+\t\t\t\t NULL_TREE, PHI_ARG_DEF (phi, i));\n \t\t  name = make_ssa_name (result_var, stmt);\n \t\t  TREE_OPERAND (stmt, 0) = name;\n "}, {"sha": "0fdb3a23b66c71aceec563c39185b8d5a11ffd9b", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -106,11 +106,11 @@ tree_gen_edge_profiler (int edgeno, edge e)\n   tree tmp1 = create_tmp_var (gcov_type_node, \"PROF\");\n   tree tmp2 = create_tmp_var (gcov_type_node, \"PROF\");\n   tree ref = tree_coverage_counter_ref (GCOV_COUNTER_ARCS, edgeno);\n-  tree stmt1 = build (MODIFY_EXPR, gcov_type_node, tmp1, ref);\n-  tree stmt2 = build (MODIFY_EXPR, gcov_type_node, tmp2,\n-\t\t      build (PLUS_EXPR, gcov_type_node, \n-\t\t\t     tmp1, integer_one_node));\n-  tree stmt3 = build (MODIFY_EXPR, gcov_type_node, ref, tmp2);\n+  tree stmt1 = build2 (MODIFY_EXPR, gcov_type_node, tmp1, ref);\n+  tree stmt2 = build2 (MODIFY_EXPR, gcov_type_node, tmp2,\n+\t\t       build2 (PLUS_EXPR, gcov_type_node, \n+\t\t\t      tmp1, integer_one_node));\n+  tree stmt3 = build2 (MODIFY_EXPR, gcov_type_node, ref, tmp2);\n   bsi_insert_on_edge (e, stmt1);\n   bsi_insert_on_edge (e, stmt2);\n   bsi_insert_on_edge (e, stmt3);"}, {"sha": "133d00a709035421e511a98b35311c61ee67eef7", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -1589,9 +1589,9 @@ maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type)\n   if (!integer_zerop (elt_offset))\n     idx = int_const_binop (PLUS_EXPR, idx, elt_offset, 0);\n \n-  return build (ARRAY_REF, orig_type, base, idx, min_idx,\n-\t\tsize_int (tree_low_cst (elt_size, 1)\n-\t\t\t  / (TYPE_ALIGN_UNIT (elt_type))));\n+  return build4 (ARRAY_REF, orig_type, base, idx, min_idx,\n+\t\t size_int (tree_low_cst (elt_size, 1)\n+\t\t\t   / (TYPE_ALIGN_UNIT (elt_type))));\n }\n \n \n@@ -1652,7 +1652,7 @@ maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n \t{\n \t  if (base_is_ptr)\n \t    base = build1 (INDIRECT_REF, record_type, base);\n-\t  t = build (COMPONENT_REF, field_type, base, f, NULL_TREE);\n+\t  t = build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);\n \t  return t;\n \t}\n       \n@@ -1692,7 +1692,7 @@ maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n      nonzero offset into them.  Recurse and hope for a valid match.  */\n   if (base_is_ptr)\n     base = build1 (INDIRECT_REF, record_type, base);\n-  base = build (COMPONENT_REF, field_type, base, f, NULL_TREE);\n+  base = build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);\n \n   t = maybe_fold_offset_to_array_ref (base, offset, orig_type);\n   if (t)"}, {"sha": "1c7bcbe5c612930287ede755a8065a68d799e9a2", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -834,9 +834,9 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t  dummy_cond = walk_data->global_data;\n \t  if (! dummy_cond)\n \t    {\n-\t      dummy_cond = build (cond_code, boolean_type_node, op0, op1);\n-\t      dummy_cond = build (COND_EXPR, void_type_node,\n-\t\t\t\t  dummy_cond, NULL, NULL);\n+\t      dummy_cond = build2 (cond_code, boolean_type_node, op0, op1);\n+\t      dummy_cond = build3 (COND_EXPR, void_type_node,\n+\t\t\t\t   dummy_cond, NULL_TREE, NULL_TREE);\n \t      walk_data->global_data = dummy_cond;\n \t    }\n \t  else\n@@ -1851,17 +1851,17 @@ simplify_rhs_and_lookup_avail_expr (tree stmt, int insert)\n \t\t  if (rhs_def_code != rhs_code)\n \t\t    {\n \t\t      if (rhs_def_code == MINUS_EXPR)\n-\t\t        t = build (MINUS_EXPR, type, outer_const, def_stmt_op1);\n+\t\t        t = build2 (MINUS_EXPR, type, outer_const, def_stmt_op1);\n \t\t      else\n-\t\t        t = build (MINUS_EXPR, type, def_stmt_op1, outer_const);\n+\t\t        t = build2 (MINUS_EXPR, type, def_stmt_op1, outer_const);\n \t\t      rhs_code = PLUS_EXPR;\n \t\t    }\n \t\t  else if (rhs_def_code == MINUS_EXPR)\n-\t\t    t = build (PLUS_EXPR, type, def_stmt_op1, outer_const);\n+\t\t    t = build2 (PLUS_EXPR, type, def_stmt_op1, outer_const);\n \t\t  else\n-\t\t    t = build (rhs_def_code, type, def_stmt_op1, outer_const);\n+\t\t    t = build2 (rhs_def_code, type, def_stmt_op1, outer_const);\n \t\t  t = local_fold (t);\n-\t\t  t = build (rhs_code, type, def_stmt_op0, t);\n+\t\t  t = build2 (rhs_code, type, def_stmt_op0, t);\n \t\t  t = local_fold (t);\n \n \t\t  /* If the result is a suitable looking gimple expression,\n@@ -1969,8 +1969,8 @@ find_equivalent_equality_comparison (tree cond)\n \t  new = build1 (TREE_CODE (def_rhs), def_rhs_inner_type, op1);\n \t  new = local_fold (new);\n \t  if (is_gimple_val (new) && tree_int_cst_equal (new, op1))\n-\t    return build (TREE_CODE (cond), TREE_TYPE (cond),\n-\t\t\t  def_rhs_inner, new);\n+\t    return build2 (TREE_CODE (cond), TREE_TYPE (cond),\n+\t\t\t   def_rhs_inner, new);\n \t}\n     }\n   return NULL;\n@@ -2752,7 +2752,7 @@ record_equivalences_from_stmt (tree stmt,\n       if (rhs)\n \t{\n \t  /* Build a new statement with the RHS and LHS exchanged.  */\n-\t  new = build (MODIFY_EXPR, TREE_TYPE (stmt), rhs, lhs);\n+\t  new = build2 (MODIFY_EXPR, TREE_TYPE (stmt), rhs, lhs);\n \n \t  create_ssa_artficial_load_stmt (new, stmt);\n "}, {"sha": "8da06ef85773a15afba85da4584de1a018b7af55", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -1070,7 +1070,7 @@ schedule_sm (struct loop *loop, edge *exits, unsigned n_exits, tree ref,\n       LIM_DATA (aref->stmt)->sm_done = true;\n \n   /* Emit the load & stores.  */\n-  load = build (MODIFY_EXPR, void_type_node, tmp_var, ref);\n+  load = build2 (MODIFY_EXPR, void_type_node, tmp_var, ref);\n   get_stmt_ann (load)->common.aux = xcalloc (1, sizeof (struct lim_aux_data));\n   LIM_DATA (load)->max_loop = loop;\n   LIM_DATA (load)->tgt_loop = loop;\n@@ -1081,8 +1081,8 @@ schedule_sm (struct loop *loop, edge *exits, unsigned n_exits, tree ref,\n \n   for (i = 0; i < n_exits; i++)\n     {\n-      store = build (MODIFY_EXPR, void_type_node,\n-\t\t     unshare_expr (ref), tmp_var);\n+      store = build2 (MODIFY_EXPR, void_type_node,\n+\t\t      unshare_expr (ref), tmp_var);\n       bsi_insert_on_edge (exits[i], store);\n     }\n }"}, {"sha": "806b9af495eec46d25aa92518ec68e9ea8dc1aa5", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -1595,7 +1595,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n   add_referenced_tmp_var (temp);\n   if (TREE_CODE (TREE_TYPE (expr)) == COMPLEX_TYPE)\n     DECL_COMPLEX_GIMPLE_REG_P (temp) = 1;\n-  newexpr = build (MODIFY_EXPR, TREE_TYPE (expr), temp, newexpr);\n+  newexpr = build2 (MODIFY_EXPR, TREE_TYPE (expr), temp, newexpr);\n   name = make_ssa_name (temp, newexpr);\n   TREE_OPERAND (newexpr, 0) = name;\n   NECESSARY (newexpr) = 0;"}, {"sha": "bdf26173288ad13ebb6f90f5e0d0ca2524538287", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=b4257cfc1fd2e8cacb30978e5da3d6af3b1e2db8", "patch": "@@ -2019,8 +2019,8 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   /* Arguments are ready. create the new vector stmt.  */\n   vec_compare = build2 (TREE_CODE (cond_expr), vectype, \n \t\t\tvec_cond_lhs, vec_cond_rhs);\n-  vec_cond_expr = build (VEC_COND_EXPR, vectype, \n-\t\t\t vec_compare, vec_then_clause, vec_else_clause);\n+  vec_cond_expr = build3 (VEC_COND_EXPR, vectype, \n+\t\t\t  vec_compare, vec_then_clause, vec_else_clause);\n \n   *vec_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, vec_cond_expr);\n   new_temp = make_ssa_name (vec_dest, *vec_stmt);"}]}