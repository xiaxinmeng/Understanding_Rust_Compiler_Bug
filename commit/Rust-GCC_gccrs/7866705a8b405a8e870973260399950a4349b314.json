{"sha": "7866705a8b405a8e870973260399950a4349b314", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg2NjcwNWE4YjQwNWE4ZTg3MDk3MzI2MDM5OTk1MGE0MzQ5YjMxNA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-03-24T07:20:42Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-03-24T07:20:42Z"}, "message": "typeck.c (comptypes): First determine if the types are compatible from a target-independent point of view.\n\n\t* typeck.c (comptypes): First determine if the types are compatible\n\tfrom a target-independent point of view.  Check target attributes\n\tlast.\n\n\t* class.c (build_base_path):\n\t(build_vbase_offset_vtbl_entries):\n\t(add_vcall_offset): Replace fold (buildN (...)) with fold_buildN.\n\t* error.c (dump_expr): Likewise.\n\t* init.c (build_zero_init, expand_cleanup_for_base,\n\tbuild_vec_delete_1): Likewise.\n\t* mangle.c (write_integer_cst): Likewise.\n\t* method.c (thunk_adjust): Likewise.\n\t* pt.c (convert_nontype_argument, tsubst, unify): Likewise.\n\t* tree.c (cxx_print_statistics, array_type_nelts_total): Likewise.\n\t* typeck.c (build_ptrmemfunc_access_expr,\n\t(get_member_function_from_ptrfunc): Likewise.\n\nFrom-SVN: r96985", "tree": {"sha": "5e7a25d8aa7a9331ab052a5f2209c65c048a4ef2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e7a25d8aa7a9331ab052a5f2209c65c048a4ef2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7866705a8b405a8e870973260399950a4349b314", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7866705a8b405a8e870973260399950a4349b314", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7866705a8b405a8e870973260399950a4349b314", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7866705a8b405a8e870973260399950a4349b314/comments", "author": null, "committer": null, "parents": [{"sha": "29ae384381fd7b3e8bb465b3345a4b91c9ff4582", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ae384381fd7b3e8bb465b3345a4b91c9ff4582", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ae384381fd7b3e8bb465b3345a4b91c9ff4582"}], "stats": {"total": 191, "additions": 113, "deletions": 78}, "files": [{"sha": "ae435c1a5cf13af5a83761fcebd164ad7c82a3d2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7866705a8b405a8e870973260399950a4349b314", "patch": "@@ -1,3 +1,22 @@\n+2005-03-24  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* typeck.c (comptypes): First determine if the types are compatible\n+\tfrom a target-independent point of view.  Check target attributes\n+\tlast.\n+\n+\t* class.c (build_base_path):\n+\t(build_vbase_offset_vtbl_entries):\n+\t(add_vcall_offset): Replace fold (buildN (...)) with fold_buildN.\n+\t* error.c (dump_expr): Likewise.\n+\t* init.c (build_zero_init, expand_cleanup_for_base,\n+\tbuild_vec_delete_1): Likewise.\n+\t* mangle.c (write_integer_cst): Likewise.\n+\t* method.c (thunk_adjust): Likewise.\n+\t* pt.c (convert_nontype_argument, tsubst, unify): Likewise.\n+\t* tree.c (cxx_print_statistics, array_type_nelts_total): Likewise.\n+\t* typeck.c (build_ptrmemfunc_access_expr,\n+\t(get_member_function_from_ptrfunc): Likewise.\n+\n 2005-03-23  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* cp-objcp-common.h (LANG_HOOKS_TRUTHVALUE_CONVERSION): Remove.\n@@ -290,7 +309,7 @@\n \tAdd qualifiers when declaring a typedef of a function type.\n \tMember function pointers pick up the qualifiers of the typedef\n \tused to declare them.\n-        Don't complain about creating cv-qualified function types.\n+\tDon't complain about creating cv-qualified function types.\n \tComplain about qualified function typedefs that are used to\n \tdeclare non-static member functions or free functions.\n \tUse cp_apply_type_quals_to_decl."}, {"sha": "c684e81aedf955fe91eea2de99555fda8278dbb6", "filename": "gcc/cp/class.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7866705a8b405a8e870973260399950a4349b314", "patch": "@@ -296,8 +296,8 @@ build_base_path (enum tree_code code,\n   if (null_test)\n     {\n       tree zero = cp_convert (TREE_TYPE (expr), integer_zero_node);\n-      null_test = fold (build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\texpr, zero));\n+      null_test = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t       expr, zero);\n     }\n \n   /* If this is a simple base reference, express it as a COMPONENT_REF.  */\n@@ -388,9 +388,9 @@ build_base_path (enum tree_code code,\n \n  out:\n   if (null_test)\n-    expr = fold (build3 (COND_EXPR, target_type, null_test, expr,\n-\t\t\t fold (build1 (NOP_EXPR, target_type,\n-\t\t\t\t       integer_zero_node))));\n+    expr = fold_build3 (COND_EXPR, target_type, null_test, expr,\n+\t\t\tfold_build1 (NOP_EXPR, target_type,\n+\t\t\t\t     integer_zero_node));\n \n   return expr;\n }\n@@ -7406,9 +7406,9 @@ build_vbase_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n       \n       *vid->last_init \n \t= build_tree_list (NULL_TREE,\n-\t\t\t   fold (build1 (NOP_EXPR, \n-\t\t\t\t\t vtable_entry_type,\n-\t\t\t\t\t delta)));\n+\t\t\t   fold_build1 (NOP_EXPR, \n+\t\t\t\t\tvtable_entry_type,\n+\t\t\t\t\tdelta));\n       vid->last_init = &TREE_CHAIN (*vid->last_init);\n     }\n }\n@@ -7633,8 +7633,8 @@ add_vcall_offset (tree orig_fn, tree binfo, vtbl_init_data *vid)\n \t     BINFO_OFFSET from vid->binfo.  */\n \t  vcall_offset = size_diffop (BINFO_OFFSET (base),\n \t\t\t\t      BINFO_OFFSET (vid->binfo));\n-\t  vcall_offset = fold (build1 (NOP_EXPR, vtable_entry_type,\n-\t\t\t\t       vcall_offset));\n+\t  vcall_offset = fold_build1 (NOP_EXPR, vtable_entry_type,\n+\t\t\t\t      vcall_offset);\n \t}\n       /* Add the initializer to the vtable.  */\n       *vid->last_init = build_tree_list (NULL_TREE, vcall_offset);"}, {"sha": "1748fe0aa69cee052f1d5654df01bdaad051498e", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=7866705a8b405a8e870973260399950a4349b314", "patch": "@@ -1413,9 +1413,9 @@ dump_expr (tree t, int flags)\n \tif (TREE_CODE (type) == ARRAY_REF)\n \t  type = build_cplus_array_type\n \t    (TREE_OPERAND (type, 0),\n-\t     build_index_type (fold (build2 (MINUS_EXPR, integer_type_node,\n-\t\t\t\t\t     TREE_OPERAND (type, 1),\n-\t\t\t\t\t     integer_one_node))));\n+\t     build_index_type (fold_build2 (MINUS_EXPR, integer_type_node,\n+\t\t\t\t\t    TREE_OPERAND (type, 1),\n+\t\t\t\t\t    integer_one_node)));\n \tdump_type (type, flags);\n \tif (init)\n \t  {"}, {"sha": "69089fe82691e2d8a4f7f0aaef697e3795284429", "filename": "gcc/cp/init.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=7866705a8b405a8e870973260399950a4349b314", "patch": "@@ -222,8 +222,8 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n       /* Iterate over the array elements, building initializations.  */\n       inits = NULL_TREE;\n       if (nelts)\n-\tmax_index = fold (build2 (MINUS_EXPR, TREE_TYPE (nelts),\n-\t\t\t\t  nelts, integer_one_node));\n+\tmax_index = fold_build2 (MINUS_EXPR, TREE_TYPE (nelts),\n+\t\t\t\t nelts, integer_one_node);\n       else\n \tmax_index = array_type_nelts (type);\n       gcc_assert (TREE_CODE (max_index) == INTEGER_CST);\n@@ -826,9 +826,9 @@ expand_cleanup_for_base (tree binfo, tree flag)\n \t\t\t\t    binfo,\n \t\t\t\t    LOOKUP_NORMAL | LOOKUP_NONVIRTUAL);\n   if (flag)\n-    expr = fold (build3 (COND_EXPR, void_type_node,\n-\t\t\t c_common_truthvalue_conversion (flag),\n-\t\t\t expr, integer_zero_node));\n+    expr = fold_build3 (COND_EXPR, void_type_node,\n+\t\t\tc_common_truthvalue_conversion (flag),\n+\t\t\texpr, integer_zero_node);\n \n   finish_eh_cleanup (expr);\n }\n@@ -2241,9 +2241,9 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \n   tbase = create_temporary_var (ptype);\n   tbase_init = build_modify_expr (tbase, NOP_EXPR,\n-\t\t\t\t  fold (build2 (PLUS_EXPR, ptype,\n-\t\t\t\t\t\tbase,\n-\t\t\t\t\t\tvirtual_size)));\n+\t\t\t\t  fold_build2 (PLUS_EXPR, ptype,\n+\t\t\t\t\t       base,\n+\t\t\t\t\t       virtual_size));\n   DECL_REGISTER (tbase) = 1;\n   controller = build3 (BIND_EXPR, void_type_node, tbase,\n \t\t       NULL_TREE, NULL_TREE);\n@@ -2308,11 +2308,11 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n     body = integer_zero_node;\n   \n   /* Outermost wrapper: If pointer is null, punt.  */\n-  body = fold (build3 (COND_EXPR, void_type_node,\n-\t\t       fold (build2 (NE_EXPR, boolean_type_node, base,\n-\t\t\t\t     convert (TREE_TYPE (base),\n-\t\t\t\t\t      integer_zero_node))),\n-\t\t       body, integer_zero_node));\n+  body = fold_build3 (COND_EXPR, void_type_node,\n+\t\t      fold_build2 (NE_EXPR, boolean_type_node, base,\n+\t\t\t\t   convert (TREE_TYPE (base),\n+\t\t\t\t\t    integer_zero_node)),\n+\t\t      body, integer_zero_node);\n   body = build1 (NOP_EXPR, void_type_node, body);\n \n   if (controller)"}, {"sha": "0f358cd98e58c836abecd3b9ed3cb6b82013134c", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=7866705a8b405a8e870973260399950a4349b314", "patch": "@@ -1249,16 +1249,16 @@ write_integer_cst (const tree cst)\n       if (sign < 0)\n \t{\n \t  write_char ('n');\n-\t  n = fold (build1 (NEGATE_EXPR, type, n));\n+\t  n = fold_build1 (NEGATE_EXPR, type, n);\n \t}\n       do\n \t{\n-\t  tree d = fold (build2 (FLOOR_DIV_EXPR, type, n, base));\n-\t  tree tmp = fold (build2 (MULT_EXPR, type, d, base));\n+\t  tree d = fold_build2 (FLOOR_DIV_EXPR, type, n, base);\n+\t  tree tmp = fold_build2 (MULT_EXPR, type, d, base);\n \t  unsigned c;\n \n \t  done = integer_zerop (d);\n-\t  tmp = fold (build2 (MINUS_EXPR, type, n, tmp));\n+\t  tmp = fold_build2 (MINUS_EXPR, type, n, tmp);\n \t  c = hwint_to_ascii (TREE_INT_CST_LOW (tmp), 10, ptr,\n \t\t\t      done ? 1 : chunk_digits);\n \t  ptr -= c;"}, {"sha": "70d664283bbdbf8bd962e2ef9e8135b534099dba", "filename": "gcc/cp/method.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=7866705a8b405a8e870973260399950a4349b314", "patch": "@@ -220,8 +220,8 @@ thunk_adjust (tree ptr, bool this_adjusting,\n {\n   if (this_adjusting)\n     /* Adjust the pointer by the constant.  */\n-    ptr = fold (build2 (PLUS_EXPR, TREE_TYPE (ptr), ptr,\n-\t\t\tssize_int (fixed_offset)));\n+    ptr = fold_build2 (PLUS_EXPR, TREE_TYPE (ptr), ptr,\n+\t\t       ssize_int (fixed_offset));\n \n   /* If there's a virtual offset, look up that value in the vtable and\n      adjust the pointer again.  */\n@@ -242,13 +242,13 @@ thunk_adjust (tree ptr, bool this_adjusting,\n       /* Get the offset itself.  */\n       vtable = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (vtable)), vtable);\n       /* Adjust the `this' pointer.  */\n-      ptr = fold (build2 (PLUS_EXPR, TREE_TYPE (ptr), ptr, vtable));\n+      ptr = fold_build2 (PLUS_EXPR, TREE_TYPE (ptr), ptr, vtable);\n     }\n   \n   if (!this_adjusting)\n     /* Adjust the pointer by the constant.  */\n-    ptr = fold (build2 (PLUS_EXPR, TREE_TYPE (ptr), ptr,\n-\t\t\tssize_int (fixed_offset)));\n+    ptr = fold_build2 (PLUS_EXPR, TREE_TYPE (ptr), ptr,\n+\t\t       ssize_int (fixed_offset));\n \n   return ptr;\n }"}, {"sha": "d5514f32aa31f630e6f5ba3d86ef0d199f17bb19", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7866705a8b405a8e870973260399950a4349b314", "patch": "@@ -3612,7 +3612,7 @@ convert_nontype_argument (tree type, tree expr)\n       if (!expr || expr == error_mark_node)\n \treturn expr;\n \n-      expr = build_nop(type, build_address (expr));\n+      expr = build_nop (type, build_address (expr));\n     }\n   /* [temp.arg.nontype]/5, bullet 6\n \n@@ -7342,7 +7342,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tif (e1 == error_mark_node || e2 == error_mark_node)\n \t  return error_mark_node;\n \n-\treturn fold (build2 (TREE_CODE (t), TREE_TYPE (t), e1, e2));\n+\treturn fold_build2 (TREE_CODE (t), TREE_TYPE (t), e1, e2);\n       }\n \n     case NEGATE_EXPR:\n@@ -7352,7 +7352,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tif (e == error_mark_node)\n \t  return error_mark_node;\n \n-\treturn fold (build1 (TREE_CODE (t), TREE_TYPE (t), e));\n+\treturn fold_build1 (TREE_CODE (t), TREE_TYPE (t), e);\n       }\n \n     case TYPENAME_TYPE:\n@@ -10158,10 +10158,10 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t     not an integer constant.  */\n \t  if (TREE_CODE (parm_max) == MINUS_EXPR)\n \t    {\n-\t      arg_max = fold (build2 (PLUS_EXPR, \n-\t\t\t\t      integer_type_node,\n-\t\t\t\t      arg_max,\n-\t\t\t\t      TREE_OPERAND (parm_max, 1)));\n+\t      arg_max = fold_build2 (PLUS_EXPR, \n+\t\t\t\t     integer_type_node,\n+\t\t\t\t     arg_max,\n+\t\t\t\t     TREE_OPERAND (parm_max, 1));\n \t      parm_max = TREE_OPERAND (parm_max, 0);\n \t    }\n "}, {"sha": "8b0d9aa872f766a5e1e2792bef2107af373b8325", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=7866705a8b405a8e870973260399950a4349b314", "patch": "@@ -1112,9 +1112,9 @@ cxx_print_statistics (void)\n tree\n array_type_nelts_top (tree type)\n {\n-  return fold (build2 (PLUS_EXPR, sizetype,\n-\t\t       array_type_nelts (type),\n-\t\t       integer_one_node));\n+  return fold_build2 (PLUS_EXPR, sizetype,\n+\t\t      array_type_nelts (type),\n+\t\t      integer_one_node);\n }\n \n /* Return, as an INTEGER_CST node, the number of elements for TYPE\n@@ -1129,7 +1129,7 @@ array_type_nelts_total (tree type)\n   while (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       tree n = array_type_nelts_top (type);\n-      sz = fold (build2 (MULT_EXPR, sizetype, sz, n));\n+      sz = fold_build2 (MULT_EXPR, sizetype, sz, n);\n       type = TREE_TYPE (type);\n     }\n   return sz;"}, {"sha": "e2cb1f8bb104dc2d7f45aef93bcb1973372f2d54", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 47, "deletions": 31, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7866705a8b405a8e870973260399950a4349b314/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=7866705a8b405a8e870973260399950a4349b314", "patch": "@@ -905,8 +905,6 @@ comp_array_types (tree t1, tree t2, bool allow_redeclaration)\n bool\n comptypes (tree t1, tree t2, int strict)\n {\n-  int retval;\n-\n   if (t1 == t2)\n     return true;\n \n@@ -969,9 +967,7 @@ comptypes (tree t1, tree t2, int strict)\n       && TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n     return true;\n \n-  if (!(*targetm.comp_type_attributes) (t1, t2))\n-    return false;\n-\n+  /* Compare the types.  Break out if they could be the same.  */\n   switch (TREE_CODE (t1))\n     {\n     case TEMPLATE_TEMPLATE_PARM:\n@@ -984,7 +980,7 @@ comptypes (tree t1, tree t2, int strict)\n \t   DECL_TEMPLATE_PARMS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (t2))))\n \treturn false;\n       if (TREE_CODE (t1) == TEMPLATE_TEMPLATE_PARM)\n-\treturn true;\n+\tbreak;\n       /* Don't check inheritance.  */\n       strict = COMPARE_STRICT;\n       /* Fall through.  */\n@@ -995,70 +991,90 @@ comptypes (tree t1, tree t2, int strict)\n \t  && (TYPE_TI_TEMPLATE (t1) == TYPE_TI_TEMPLATE (t2)\n \t      || TREE_CODE (t1) == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t  && comp_template_args (TYPE_TI_ARGS (t1), TYPE_TI_ARGS (t2)))\n-\treturn true;\n+\tbreak;\n       \n       if ((strict & COMPARE_BASE) && DERIVED_FROM_P (t1, t2))\n-\treturn true;\n+\tbreak;\n       else if ((strict & COMPARE_DERIVED) && DERIVED_FROM_P (t2, t1))\n-\treturn true;\n+\tbreak;\n       \n-      /* We may be dealing with Objective-C instances...  */\n+      /* We may be dealing with Objective-C instances.  */\n       if (TREE_CODE (t1) == RECORD_TYPE\n-\t  && ((retval = objc_comptypes (t1, t2, 0)) >= 0))\n-         return retval;\n-      /* ...but fall through if we are not.  */\n+\t  && objc_comptypes (t1, t2, 0) > 0)\n+\tbreak;\n \n       return false;\n \n     case OFFSET_TYPE:\n       if (!comptypes (TYPE_OFFSET_BASETYPE (t1), TYPE_OFFSET_BASETYPE (t2),\n \t\t      strict & ~COMPARE_REDECLARATION))\n \treturn false;\n-      return same_type_p (TREE_TYPE (t1), TREE_TYPE (t2));\n+      if (!same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\treturn false;\n+      break;\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n-      return TYPE_MODE (t1) == TYPE_MODE (t2)\n-\t     && TYPE_REF_CAN_ALIAS_ALL (t1) == TYPE_REF_CAN_ALIAS_ALL (t2)\n-\t     && same_type_p (TREE_TYPE (t1), TREE_TYPE (t2));\n+      if (TYPE_MODE (t1) != TYPE_MODE (t2)\n+\t  || TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2)\n+\t  || !same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\treturn false;\n+      break;\n \n     case METHOD_TYPE:\n     case FUNCTION_TYPE:\n       if (!same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n \treturn false;\n-      return compparms (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2));\n+      if (!compparms (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2)))\n+\treturn false;\n+      break;\n \n     case ARRAY_TYPE:\n       /* Target types must match incl. qualifiers.  */\n-      return comp_array_types (t1, t2, !!(strict & COMPARE_REDECLARATION));\n+      if (!comp_array_types (t1, t2, !!(strict & COMPARE_REDECLARATION)))\n+\treturn false;\n+      break;\n \n     case TEMPLATE_TYPE_PARM:\n-      return (TEMPLATE_TYPE_IDX (t1) == TEMPLATE_TYPE_IDX (t2)\n-\t      && TEMPLATE_TYPE_LEVEL (t1) == TEMPLATE_TYPE_LEVEL (t2));\n+      if (TEMPLATE_TYPE_IDX (t1) != TEMPLATE_TYPE_IDX (t2)\n+\t  || TEMPLATE_TYPE_LEVEL (t1) != TEMPLATE_TYPE_LEVEL (t2))\n+\treturn false;\n+      break;\n \n     case TYPENAME_TYPE:\n       if (!cp_tree_equal (TYPENAME_TYPE_FULLNAME (t1),\n \t\t\t  TYPENAME_TYPE_FULLNAME (t2)))\n         return false;\n-      return same_type_p (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2));\n+      if (!same_type_p (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2)))\n+\treturn false;\n+      break;\n \n     case UNBOUND_CLASS_TEMPLATE:\n       if (!cp_tree_equal (TYPE_IDENTIFIER (t1), TYPE_IDENTIFIER (t2)))\n         return false;\n-      return same_type_p (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2));\n+      if (!same_type_p (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2)))\n+\treturn false;\n+      break;\n \n     case COMPLEX_TYPE:\n-      return same_type_p (TREE_TYPE (t1), TREE_TYPE (t2));\n+      if (!same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\treturn false;\n+      break;\n \n     case VECTOR_TYPE:\n-      return TYPE_VECTOR_SUBPARTS (t1) == TYPE_VECTOR_SUBPARTS (t2)\n-\t     && same_type_p (TREE_TYPE (t1), TREE_TYPE (t2));\n+      if (TYPE_VECTOR_SUBPARTS (t1) != TYPE_VECTOR_SUBPARTS (t2)\n+\t  || !same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\treturn false;\n       break;\n \n     default:\n-      break;\n+      return false;\n     }\n-  return false;\n+\n+  /* If we get here, we know that from a target independent POV the\n+     types are the same.  Make sure the target attributes are also\n+     the same.  */\n+  return targetm.comp_type_attributes (t1, t2);\n }\n \n /* Returns 1 if TYPE1 is at least as qualified as TYPE2.  */\n@@ -1995,8 +2011,8 @@ build_ptrmemfunc_access_expr (tree ptrmem, tree member_name)\n \t\t\t  /*want_type=*/false);\n   member_type = cp_build_qualified_type (TREE_TYPE (member),\n \t\t\t\t\t cp_type_quals (ptrmem_type));\n-  return fold (build3 (COMPONENT_REF, member_type,\n-\t\t       ptrmem, member, NULL_TREE));\n+  return fold_build3 (COMPONENT_REF, member_type,\n+\t\t      ptrmem, member, NULL_TREE);\n }\n \n /* Given an expression PTR for a pointer, return an expression\n@@ -2343,7 +2359,7 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n       vtbl = build_indirect_ref (vtbl, NULL);\n \n       /* Finally, extract the function pointer from the vtable.  */\n-      e2 = fold (build2 (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, idx));\n+      e2 = fold_build2 (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, idx);\n       e2 = build_indirect_ref (e2, NULL);\n       TREE_CONSTANT (e2) = 1;\n       TREE_INVARIANT (e2) = 1;"}]}