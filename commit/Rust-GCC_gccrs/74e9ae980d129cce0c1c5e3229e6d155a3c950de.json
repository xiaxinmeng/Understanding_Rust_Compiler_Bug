{"sha": "74e9ae980d129cce0c1c5e3229e6d155a3c950de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRlOWFlOTgwZDEyOWNjZTBjMWM1ZTMyMjllNmQxNTVhM2M5NTBkZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-12T15:19:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-12T15:19:25Z"}, "message": "* gnat_rm.texi, gnat_ugn.texi, doc: Documentation updates and clean ups\n\nFrom-SVN: r223079", "tree": {"sha": "e998e2c4ed98c0d3b20c1691c7eb8aa1add791e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e998e2c4ed98c0d3b20c1691c7eb8aa1add791e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74e9ae980d129cce0c1c5e3229e6d155a3c950de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74e9ae980d129cce0c1c5e3229e6d155a3c950de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74e9ae980d129cce0c1c5e3229e6d155a3c950de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74e9ae980d129cce0c1c5e3229e6d155a3c950de/comments", "author": null, "committer": null, "parents": [{"sha": "69031b454519e235ca01c1b4020f5ef728ddc4d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69031b454519e235ca01c1b4020f5ef728ddc4d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69031b454519e235ca01c1b4020f5ef728ddc4d1"}], "stats": {"total": 1445, "additions": 743, "deletions": 702}, "files": [{"sha": "5599a81413ae2ada46084b734b9d0a90e2646731", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_aspects.rst", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_aspects.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_aspects.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_aspects.rst?ref=74e9ae980d129cce0c1c5e3229e6d155a3c950de", "patch": "@@ -201,6 +201,16 @@ characters in this context).\n See section 'Performing Dimensionality Analysis in GNAT' in the GNAT Users\n Guide for detailed examples of use of the dimension system.\n \n+Aspect Disable_Controlled\n+=========================\n+.. index:: Disable_Controlled\n+\n+The aspect  `Disable_Controlled` is defined for controlled record types. If\n+active, this aspect causes suppression of all related calls to `Initialize`,\n+`Adjust`, and `Finalize`. The intended use is for conditional compilation,\n+where for example you might want a record to be controlled or not depending on\n+whether some run-time check is enabled or suppressed.\n+\n Aspect Effective_Reads\n ======================\n .. index:: Effective_Reads\n@@ -511,6 +521,12 @@ Aspect Value_Size\n This aspect is equivalent to a `Value_Size`\n attribute definition clause.\n \n+Aspect Volatile_Full_Access\n+===========================\n+.. index:: Volatile_Full_Access\n+\n+This boolean aspect is equivalent to pragma `Volatile_Full_Access`.\n+\n Aspect Warnings\n ===============\n .. index:: Warnings"}, {"sha": "cb43587ecd939af605c27a619733186343ee8d73", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_attributes.rst", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst?ref=74e9ae980d129cce0c1c5e3229e6d155a3c950de", "patch": "@@ -793,10 +793,6 @@ range).  The result is static for static subtypes.  `Range_Length`\n applied to the index subtype of a one dimensional array always gives the\n same result as `Length` applied to the array itself.\n \n-Attribute Ref\n-=============\n-.. index:: Ref\n-\n Attribute Restriction_Set\n =========================\n .. index:: Restriction_Set"}, {"sha": "058db24357557af3e94d8f6318b76c81c0c1d538", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=74e9ae980d129cce0c1c5e3229e6d155a3c950de", "patch": "@@ -6583,6 +6583,38 @@ in some Ada 83 compilers, including DEC Ada 83.  The Ada 95 / Ada 2005\n implementation of pragma Volatile is upwards compatible with the\n implementation in DEC Ada 83.\n \n+Pragma Volatile_Full_Access\n+===========================\n+\n+Syntax:\n+\n+\n+.. code-block:: ada\n+\n+  pragma Volatile_Full_Access (LOCAL_NAME);\n+\n+\n+This is similar in effect to pragma Volatile, except that any reference to the\n+object is guaranteed to be done only with instructions that read or write all\n+the bits of the object. Furthermore, if the object is of a composite type,\n+then any reference to a component of the object is guaranteed to read and/or\n+write all the bits of the object.\n+\n+The intention is that this be suitable for use with memory-mapped I/O devices\n+on some machines. Note that there are two important respects in which this is\n+different from `pragma Atomic`. First a reference to a `Volatile_Full_Access`\n+object is not a sequential action in the RM 9.10 sense and, therefore, does\n+not create a synchronization point. Second, in the case of `pragma Atomic`,\n+there is no guarantee that all the bits will be accessed if the reference\n+is not to the whole object; the compiler is allowed (and generally will)\n+access only part of the object in this case.\n+\n+It is not permissible to specify `Atomic` and `Volatile_Full_Access` for\n+the same object.\n+\n+It is not permissible to specify `Volatile_Full_Access` for a composite\n+(record or array) type or object that has at least one `Aliased` component.\n+\n Pragma Warning_As_Error\n =======================\n "}, {"sha": "8d28d24fe60a417b6152872bd488101120dcce46", "filename": "gcc/ada/doc/gnat_rm/representation_clauses_and_pragmas.rst", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fdoc%2Fgnat_rm%2Frepresentation_clauses_and_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fdoc%2Fgnat_rm%2Frepresentation_clauses_and_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Frepresentation_clauses_and_pragmas.rst?ref=74e9ae980d129cce0c1c5e3229e6d155a3c950de", "patch": "@@ -371,10 +371,10 @@ Consider the following modified version of the above program:\n \n   begin\n      Put_Line (Integer'Image (V2'Size));\n-     Put_Line (Integer'IMage (Size (V2)));\n+     Put_Line (Integer'Image (Size (V2)));\n      V2 := (True, 'x');\n      Put_Line (Integer'Image (V2'Size));\n-     Put_Line (Integer'IMage (Size (V2)));\n+     Put_Line (Integer'Image (Size (V2)));\n   end q;\n \n The output from this program is\n@@ -553,11 +553,6 @@ is illegal to convert from one access subtype to the other. For a more\n complete description of this additional legality rule, see the\n description of the `Object_Size` attribute.\n \n-At the implementation level, Esize stores the Object_Size and the\n-RM_Size field stores the `Value_Size` (and hence the value of the\n-`Size` attribute,\n-which, as noted above, is equivalent to `Value_Size`).\n-\n To get a feel for the difference, consider the following examples (note\n that in each case the base is `Short_Short_Integer` with a size of 8):\n \n@@ -573,15 +568,17 @@ that in each case the base is `Short_Short_Integer` with a size of 8):\n +---------------------------------------------+-------------+-------------+\n |``subtype x4 is x2'base range 0 .. 10;``     |  8          |    4        |\n +---------------------------------------------+-------------+-------------+\n+|``dynamic : x2'Base range -64 .. +63;``      |             |             |\n++---------------------------------------------+-------------+-------------+\n |``subtype x5 is x2 range 0 .. dynamic;``     | 16          |    3*       |\n +---------------------------------------------+-------------+-------------+\n-|``subtype x6 is x2'base range 0 .. dynamic;``|  8          |    3*       |\n+|``subtype x6 is x2'base range 0 .. dynamic;``|  8          |    7*       |\n +---------------------------------------------+-------------+-------------+\n \n-Note: the entries marked '3*' are not actually specified by the Ada\n-Reference Manual, but it seems in the spirit of the RM rules to allocate\n-the minimum number of bits (here 3, given the range for `x2`)\n-known to be large enough to hold the given range of values.\n+Note: the entries marked '*' are not actually specified by the Ada\n+Reference Manual, which has nothing to say about size in the dynamic\n+case. What GNAT does is to allocate sufficient bits to accomodate any\n+possible dynamic values for the bounds at run-time.\n \n So far, so good, but GNAT has to obey the RM rules, so the question is\n under what conditions must the RM `Size` be used.\n@@ -620,7 +617,7 @@ since it must be rounded up so that this value is a multiple of the\n alignment (4 bytes = 32 bits).\n \n For all other types, the `Object_Size`\n-and Value_Size are the same (and equivalent to the RM attribute `Size`).\n+and `Value_Size` are the same (and equivalent to the RM attribute `Size`).\n Only `Size` may be specified for such types.\n \n Note that `Value_Size` can be used to force biased representation\n@@ -822,7 +819,7 @@ definition clause on byte ordering.  Briefly, it has no effect at all, but\n a detailed example will be helpful.  Before giving this\n example, let us review the precise\n definition of the effect of defining `Bit_Order`.  The effect of a\n-non-standard bit order is described in section 15.5.3 of the Ada\n+non-standard bit order is described in section 13.5.3 of the Ada\n Reference Manual:\n \n    \"2   A bit ordering is a method of interpreting the meaning of\n@@ -840,7 +837,7 @@ this context, we visit section 13.5.1 of the manual:\n The critical point here is that storage places are taken from\n the values after normalization, not before.  So the `Bit_Order`\n interpretation applies to normalized values.  The interpretation\n-is described in the later part of the 15.5.3 paragraph:\n+is described in the later part of the 13.5.3 paragraph:\n \n    \"2   A bit ordering is a method of interpreting the meaning of\n    the storage place attributes.  High_Order_First (known in the"}, {"sha": "79569b0ff12531065d8953370c09c78c3db6eecd", "filename": "gcc/ada/doc/gnat_ugn/gnat_project_manager.rst", "status": "modified", "additions": 27, "deletions": 55, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_project_manager.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_project_manager.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_project_manager.rst?ref=74e9ae980d129cce0c1c5e3229e6d155a3c950de", "patch": "@@ -300,10 +300,7 @@ locating the specified source files in the specified source directories.\n   However, when compiling a multi-language application, or a pure C\n   application, the project manager must be told which languages are of\n   interest, which is done by setting the **Languages** attribute to a list of\n-  strings, each of which is the name of a language. Tools like\n-  *gnatmake* only know about Ada, while other tools like\n-  *gprbuild* know about many more languages such as C, C++, Fortran,\n-  assembly and others can be added dynamically.\n+  strings, each of which is the name of a language.\n \n   .. index:: Naming scheme (GNAT Project Manager)\n \n@@ -416,8 +413,7 @@ Its value is the path to the object directory, either absolute or\n relative to the directory containing the project file. This\n directory must already exist and be readable and writable, although\n some tools have a switch to create the directory if needed (See\n-the switch `-p` for *gnatmake*\n-and *gprbuild*).\n+the switch `-p` for *gprbuild*).\n \n If the attribute `Object_Dir` is not specified, it defaults to\n the project directory, that is the directory containing the project file.\n@@ -569,7 +565,7 @@ packages would be involved in the build process.\n           for Exec_Dir use \".\";\n           for Main use (\"proc.adb\");\n   \n-          package Builder is  --<<<  for gnatmake and gprbuild\n+          package Builder is  --<<<  for gprbuild\n           end Builder;\n \n           package Compiler is --<<<  for the compiler\n@@ -667,7 +663,7 @@ Several attributes can be used to specify the switches:\n \n The switches for the other tools are defined in a similar manner through the\n **Default_Switches** and **Switches** attributes, respectively in the\n-*Builder* package (for *gnatmake* and *gprbuild*),\n+*Builder* package (for *gprbuild*),\n the *Binder* package (binding Ada executables) and the *Linker*\n package (for linking executables).\n \n@@ -682,18 +678,17 @@ Here is the command we would use from the command line:\n \n .. code-block:: sh\n \n-     gnatmake -Pbuild\n+     gprbuild -Pbuild\n   \n This will automatically build the executables specified through the\n *Main* attribute: for each, it will compile or recompile the\n sources for which the object file does not exist or is not up-to-date; it\n will then run the binder; and finally run the linker to create the\n executable itself.\n \n-*gnatmake* only knows how to handle Ada files. By using\n-*gprbuild* as a builder, you could automatically manage C files the\n+The *gprbuild* builder, can automatically manage C files the\n same way: create the file :file:`utils.c` in the :file:`common` directory,\n-set the attribute *Languages* to `\"(Ada, C)\"`, and run\n+set the attribute *Languages* to `\"(Ada, C)\"`, and re-run\n \n .. code-block:: sh\n \n@@ -1226,16 +1221,10 @@ following algorithm, in this order; the first matching file is used:\n   Such directories depend on the tool used. The locations searched in the\n   specified order are:\n \n-  * :file:`<prefix>/<target>/lib/gnat`\n-    (for *gnatmake* in all cases, and for *gprbuild* if option\n-    *--target* is specified)\n-  * :file:`<prefix>/<target>/share/gpr`\n-    (for *gnatmake* in all cases, and for *gprbuild* if option\n-    *--target* is specified)\n+  * :file:`<prefix>/<target>/lib/gnat` if option *--target* is specified\n+  * :file:`<prefix>/<target>/share/gpr` if option *--target* is specified\n   * :file:`<prefix>/share/gpr/`\n-    (for *gnatmake* and *gprbuild*)\n   * :file:`<prefix>/lib/gnat/`\n-    (for *gnatmake* and *gprbuild*)\n \n   In our example, :file:`gtkada.gpr` is found in the predefined directory if\n   it was installed at the same root as GNAT.\n@@ -1486,19 +1475,13 @@ order of priority):\n .. index:: -X (usage with GNAT Project Manager)\n \n **Command line**:\n-  When launching *gnatmake* or *gprbuild*, the user can pass\n+  When launching *gprbuild*, the user can pass\n   extra *-X* switches to define the external value. In\n   our case, the command line might look like\n \n-  ::\n-\n-           gnatmake -Pbuild.gpr -Xmode=debug\n-           \n-  or\n-\n-  ::\n+  .. code-block:: sh\n \n-         gnatmake -Pbuild.gpr -Xmode=release\n+         gprbuild -Pbuild.gpr -Xmode=release\n     \n \n **Environment variables**:\n@@ -1776,14 +1759,8 @@ of shard libraries reduces the size of the final executable and can also reduce\n the memory footprint at execution time when the library is shared among several\n executables.\n \n-It is also possible to build **multi-language libraries**. When using\n-*gprbuild* as a builder, multi-language library projects allow naturally\n-the creation of multi-language libraries . *gnatmake*, does not try to\n-compile non Ada sources. However, when the project is multi-language, it will\n-automatically link all object files found in the object directory, whether or\n-not they were compiled from an Ada source file. This specific behavior does not\n-apply to Ada-only projects which only take into account the objects\n-corresponding to the sources of the project.\n+*gprbuild also allows to build **multi-language libraries** when specifying\n+sources from multiple languages.\n \n A non-library project can import a library project. When the builder is invoked\n on the former, the library of the latter is only rebuilt when absolutely\n@@ -1802,11 +1779,11 @@ the following two commands need to be used:\n \n .. code-block:: sh\n \n-     gnatmake -Plogging.gpr\n-     gnatmake -Pbuild.gpr\n+     gprbuild -Plogging.gpr\n+     gprbuild -Pbuild.gpr\n   \n All :file:`ALI` files will also be copied from the object directory to the\n-library directory. To build executables, *gnatmake* will use the\n+library directory. To build executables, *gprbuild* will use the\n library rather than the individual object files.\n \n Library projects can also be useful to describe a library that needs to be used\n@@ -2307,18 +2284,17 @@ Very often, modules will build their own executables (for testing\n purposes for instance), or libraries (for easier reuse in various\n contexts).\n \n-However, if you build your project through *gnatmake* or\n-*gprbuild*, using a syntax similar to\n+However, if you build your project through *gprbuild*, using a syntax similar to\n \n ::\n \n      gprbuild -PA.gpr\n   \n this will only rebuild the main programs of project A, not those of the\n imported projects B and C. Therefore you have to spawn several\n-*gnatmake* commands, one per project, to build all executables.\n+*gprbuild* commands, one per project, to build all executables.\n This is a little inconvenient, but more importantly is inefficient\n-because *gnatmake* needs to do duplicate work to ensure that sources are\n+because *gprbuild* needs to do duplicate work to ensure that sources are\n up-to-date, and cannot easily compile things in parallel when using\n the -j switch.\n \n@@ -2349,10 +2325,6 @@ aggregate project, you will need to add \"p.gpr\" in the list of project\n files for the aggregate project, or the main will not be built when\n building the aggregate project.\n \n-Aggregate projects are supported only with *gprbuild*, not with\n-*gnatmake*.\n-\n-\n .. _Building_a_set_of_projects_with_a_single_command:\n \n Building a set of projects with a single command\n@@ -2463,7 +2435,7 @@ once.\n Since there is no ambiguity as to which switches should be used, files\n can be compiled in parallel (through the usual -j switch) and this can\n be done while maximizing the use of CPUs (compared to launching\n-multiple *gprbuild* and *gnatmake* commands in parallel).\n+multiple *gprbuild* commands in parallel).\n \n \n .. _Syntax_of_aggregate_projects:\n@@ -3118,8 +3090,8 @@ The following packages are currently supported in project files\n \n *Binder*\n   This package specifies characteristics useful when invoking the binder either\n-  directly via the *gnat* driver or when using a builder such as\n-  *gnatmake* or *gprbuild*. See :ref:`Main_Subprograms`.\n+  directly via the *gnat* driver or when using *gprbuild*.\n+  See :ref:`Main_Subprograms`.\n \n *Builder*\n   This package specifies the compilation options used when building an\n@@ -3353,7 +3325,7 @@ External Values\n \n An external value is an expression whose value is obtained from the command\n that invoked the processing of the current project file (typically a\n-*gnatmake* or *gprbuild* command).\n+*gprbuild* command).\n \n There are two kinds of external values, one that returns a single string, and\n one that returns a string list.\n@@ -4576,9 +4548,9 @@ Package IDE Attributes\n * **Compiler_Command**: single, indexed, case-insensitive index\n \n   Index is a language Name. Value is a string that denotes the command to be\n-  used to invoke the compiler. The value of `Compiler_Command (\"Ada\")` is\n-  expected to be compatible with *gnatmake*, in particular in\n-  the handling of switches.\n+  used to invoke the compiler. For historical reasons, the value of\n+  `Compiler_Command (\"Ada\")` is expected to be a reference to *gnatmake* or\n+  *cross-gnatmake*.\n \n * **Debugger_Command**: single\n "}, {"sha": "2694fef667d9db7d9f677f35a8b0daa719b66c31", "filename": "gcc/ada/doc/gnat_ugn/gnat_utility_programs.rst", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst?ref=74e9ae980d129cce0c1c5e3229e6d155a3c950de", "patch": "@@ -4983,5 +4983,6 @@ Alternatively, you may run the script using the following command line:\n \n   * generic tests for nested generic packages and their instantiations\n   * tests for protected subprograms and entries\n+  * pragma No_Run_Time\n   * if pragmas for C and C++ interaction are used, manual adjustments might be\n     necessary to make the test driver compilable"}, {"sha": "281cb382bd7c5b1cf4b9c9393a071ed7d07f19db", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 628, "deletions": 574, "changes": 1202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=74e9ae980d129cce0c1c5e3229e6d155a3c950de"}, {"sha": "3a4146cacb0fcfb5930ebb223b45097a63c966d1", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 27, "deletions": 54, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e9ae980d129cce0c1c5e3229e6d155a3c950de/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=74e9ae980d129cce0c1c5e3229e6d155a3c950de", "patch": "@@ -21,7 +21,7 @@\n \n @copying\n @quotation\n-GNAT User's Guide for Native Platforms , March 24, 2015\n+GNAT User's Guide for Native Platforms , May 12, 2015\n \n AdaCore\n \n@@ -17021,10 +17021,7 @@ the default naming convention.\n However, when compiling a multi-language application, or a pure C\n application, the project manager must be told which languages are of\n interest, which is done by setting the @strong{Languages} attribute to a list of\n-strings, each of which is the name of a language. Tools like\n-@emph{gnatmake} only know about Ada, while other tools like\n-@emph{gprbuild} know about many more languages such as C, C++, Fortran,\n-assembly and others can be added dynamically.\n+strings, each of which is the name of a language.\n \n @geindex Naming scheme (GNAT Project Manager)\n \n@@ -17143,8 +17140,7 @@ Its value is the path to the object directory, either absolute or\n relative to the directory containing the project file. This\n directory must already exist and be readable and writable, although\n some tools have a switch to create the directory if needed (See\n-the switch @cite{-p} for @emph{gnatmake}\n-and @emph{gprbuild}).\n+the switch @cite{-p} for @emph{gprbuild}).\n \n If the attribute @cite{Object_Dir} is not specified, it defaults to\n the project directory, that is the directory containing the project file.\n@@ -17293,7 +17289,7 @@ packages would be involved in the build process.\n @c    for Exec_Dir use \".\";\n @c    for Main use (\"proc.adb\");\n @c \n-@c    package Builder is  --<<<  for gnatmake and gprbuild\n+@c    package Builder is  --<<<  for gprbuild\n @c    end Builder;\n @c \n @c    package Compiler is --<<<  for the compiler\n@@ -17397,7 +17393,7 @@ used for all the sources of the project.\n \n The switches for the other tools are defined in a similar manner through the\n @strong{Default_Switches} and @strong{Switches} attributes, respectively in the\n-@emph{Builder} package (for @emph{gnatmake} and @emph{gprbuild}),\n+@emph{Builder} package (for @emph{gprbuild}),\n the @emph{Binder} package (binding Ada executables) and the @emph{Linker}\n package (for linking executables).\n \n@@ -17410,7 +17406,7 @@ Now that our project files are written, let's build our executable.\n Here is the command we would use from the command line:\n \n @example\n-gnatmake -Pbuild\n+gprbuild -Pbuild\n @end example\n \n This will automatically build the executables specified through the\n@@ -17419,10 +17415,9 @@ sources for which the object file does not exist or is not up-to-date; it\n will then run the binder; and finally run the linker to create the\n executable itself.\n \n-@emph{gnatmake} only knows how to handle Ada files. By using\n-@emph{gprbuild} as a builder, you could automatically manage C files the\n+The @emph{gprbuild} builder, can automatically manage C files the\n same way: create the file @code{utils.c} in the @code{common} directory,\n-set the attribute @emph{Languages} to @cite{\"(Ada@comma{} C)\"}, and run\n+set the attribute @emph{Languages} to @cite{\"(Ada@comma{} C)\"}, and re-run\n \n @example\n gprbuild -Pbuild\n@@ -18034,22 +18029,16 @@ specified order are:\n @itemize *\n \n @item \n-@code{<prefix>/<target>/lib/gnat}\n-(for @emph{gnatmake} in all cases, and for @emph{gprbuild} if option\n-@emph{--target} is specified)\n+@code{<prefix>/<target>/lib/gnat} if option @emph{--target} is specified\n \n @item \n-@code{<prefix>/<target>/share/gpr}\n-(for @emph{gnatmake} in all cases, and for @emph{gprbuild} if option\n-@emph{--target} is specified)\n+@code{<prefix>/<target>/share/gpr} if option @emph{--target} is specified\n \n @item \n @code{<prefix>/share/gpr/}\n-(for @emph{gnatmake} and @emph{gprbuild})\n \n @item \n @code{<prefix>/lib/gnat/}\n-(for @emph{gnatmake} and @emph{gprbuild})\n @end itemize\n \n In our example, @code{gtkada.gpr} is found in the predefined directory if\n@@ -18318,18 +18307,12 @@ order of priority):\n \n @item @strong{Command line}:\n \n-When launching @emph{gnatmake} or @emph{gprbuild}, the user can pass\n+When launching @emph{gprbuild}, the user can pass\n extra @emph{-X} switches to define the external value. In\n our case, the command line might look like\n \n @example\n-gnatmake -Pbuild.gpr -Xmode=debug\n-@end example\n-\n-or\n-\n-@example\n-gnatmake -Pbuild.gpr -Xmode=release\n+gprbuild -Pbuild.gpr -Xmode=release\n @end example\n \n @item @strong{Environment variables}:\n@@ -18639,14 +18622,8 @@ of shard libraries reduces the size of the final executable and can also reduce\n the memory footprint at execution time when the library is shared among several\n executables.\n \n-It is also possible to build @strong{multi-language libraries}. When using\n-@emph{gprbuild} as a builder, multi-language library projects allow naturally\n-the creation of multi-language libraries . @emph{gnatmake}, does not try to\n-compile non Ada sources. However, when the project is multi-language, it will\n-automatically link all object files found in the object directory, whether or\n-not they were compiled from an Ada source file. This specific behavior does not\n-apply to Ada-only projects which only take into account the objects\n-corresponding to the sources of the project.\n+@emph{gprbuild also allows to build **multi-language libraries*} when specifying\n+sources from multiple languages.\n \n A non-library project can import a library project. When the builder is invoked\n on the former, the library of the latter is only rebuilt when absolutely\n@@ -18664,12 +18641,12 @@ up to date, and that all the sources of @cite{Build} are also up to date,\n the following two commands need to be used:\n \n @example\n-gnatmake -Plogging.gpr\n-gnatmake -Pbuild.gpr\n+gprbuild -Plogging.gpr\n+gprbuild -Pbuild.gpr\n @end example\n \n All @code{ALI} files will also be copied from the object directory to the\n-library directory. To build executables, @emph{gnatmake} will use the\n+library directory. To build executables, @emph{gprbuild} will use the\n library rather than the individual object files.\n \n Library projects can also be useful to describe a library that needs to be used\n@@ -19210,18 +19187,17 @@ Very often, modules will build their own executables (for testing\n purposes for instance), or libraries (for easier reuse in various\n contexts).\n \n-However, if you build your project through @emph{gnatmake} or\n-@emph{gprbuild}, using a syntax similar to\n+However, if you build your project through @emph{gprbuild}, using a syntax similar to\n \n @example\n gprbuild -PA.gpr\n @end example\n \n this will only rebuild the main programs of project A, not those of the\n imported projects B and C. Therefore you have to spawn several\n-@emph{gnatmake} commands, one per project, to build all executables.\n+@emph{gprbuild} commands, one per project, to build all executables.\n This is a little inconvenient, but more importantly is inefficient\n-because @emph{gnatmake} needs to do duplicate work to ensure that sources are\n+because @emph{gprbuild} needs to do duplicate work to ensure that sources are\n up-to-date, and cannot easily compile things in parallel when using\n the -j switch.\n \n@@ -19252,9 +19228,6 @@ aggregate project, you will need to add \"p.gpr\" in the list of project\n files for the aggregate project, or the main will not be built when\n building the aggregate project.\n \n-Aggregate projects are supported only with @emph{gprbuild}, not with\n-@emph{gnatmake}.\n-\n @node Building a set of projects with a single command,Define a build environment,Building all main programs from a single project tree,Aggregate Projects\n @anchor{gnat_ugn/gnat_project_manager building-a-set-of-projects-with-a-single-command}@anchor{184}@anchor{gnat_ugn/gnat_project_manager id29}@anchor{185}\n @subsection Building a set of projects with a single command\n@@ -19363,7 +19336,7 @@ once.\n Since there is no ambiguity as to which switches should be used, files\n can be compiled in parallel (through the usual -j switch) and this can\n be done while maximizing the use of CPUs (compared to launching\n-multiple @emph{gprbuild} and @emph{gnatmake} commands in parallel).\n+multiple @emph{gprbuild} commands in parallel).\n \n @node Syntax of aggregate projects,package Builder in aggregate projects,Performance improvements in builder,Aggregate Projects\n @anchor{gnat_ugn/gnat_project_manager id32}@anchor{18a}@anchor{gnat_ugn/gnat_project_manager syntax-of-aggregate-projects}@anchor{18b}\n@@ -20141,8 +20114,8 @@ The following packages are currently supported in project files\n @item @emph{Binder}\n \n This package specifies characteristics useful when invoking the binder either\n-directly via the @emph{gnat} driver or when using a builder such as\n-@emph{gnatmake} or @emph{gprbuild}. See @ref{15d,,Main Subprograms}.\n+directly via the @emph{gnat} driver or when using @emph{gprbuild}.\n+See @ref{15d,,Main Subprograms}.\n \n @item @emph{Builder}\n \n@@ -20402,7 +20375,7 @@ Illegal := \"gnat.adc\" & List2;  --  Illegal, must start with list\n \n An external value is an expression whose value is obtained from the command\n that invoked the processing of the current project file (typically a\n-@emph{gnatmake} or @emph{gprbuild} command).\n+@emph{gprbuild} command).\n \n There are two kinds of external values, one that returns a single string, and\n one that returns a string list.\n@@ -21882,9 +21855,9 @@ in a cross-compilation environment, for example @cite{\"wtx\"} or\n @strong{Compiler_Command}: single, indexed, case-insensitive index\n \n Index is a language Name. Value is a string that denotes the command to be\n-used to invoke the compiler. The value of @cite{Compiler_Command (\"Ada\")} is\n-expected to be compatible with @emph{gnatmake}, in particular in\n-the handling of switches.\n+used to invoke the compiler. For historical reasons, the value of\n+@cite{Compiler_Command (\"Ada\")} is expected to be a reference to @emph{gnatmake} or\n+@emph{cross-gnatmake}.\n \n @item \n @strong{Debugger_Command}: single"}]}