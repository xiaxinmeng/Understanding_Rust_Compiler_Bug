{"sha": "8824fd4cc119ccbeaab451122d5cbff6971bf958", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgyNGZkNGNjMTE5Y2NiZWFhYjQ1MTEyMmQ1Y2JmZjY5NzFiZjk1OA==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "coudert@clipper.ens.fr", "date": "2005-11-27T11:42:46Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2005-11-27T11:42:46Z"}, "message": "re PR libfortran/24919 ([4.0] CRLF support in libgfortran)\n\n\tPR libfortran/24919\n\n\t* io/list_read.c (eat_separator, finish_separator,\n\tread_character): Handle CRLF separators correctly during reads.\n\t(nml_query): Use the HAVE_CRLF macro to print adequate newlines.\n\t* io/io.h (st_parameter_dt): Add comment about the possible\n\tvalues for sf_seen_eor.\n\t* io/unix.c (tempfile, regular_file): HAVE_CRLF doesn't imply\n\tthat O_BINARY is defined, so we add that condition.\n\t(stream_at_bof): Fix typo in comment.\n\t* io/transfer.c (read_sf): Handle correctly CRLF, setting\n\tsf_seen_eor value to 2 instead of 1.\n\t(formatted_transfer_scalar): Use the sf_seen_eor value to\n\thandle CRLF the right way.\n\t* io/write.c (nml_write_obj, namelist_write): Use CRLF as newline\n\twhen HAVE_CRLF is defined.\n\n\t* gfortran.dg/ftell_1.f90: Modify testcase so that it doesn't\n\tfail on CRLF platforms.\n\t* gfortran.dg/ftell_2.f90: Likewise.\n\nFrom-SVN: r107563", "tree": {"sha": "01365c36dc1d3c013aab270a069fc3359416ae3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01365c36dc1d3c013aab270a069fc3359416ae3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8824fd4cc119ccbeaab451122d5cbff6971bf958", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8824fd4cc119ccbeaab451122d5cbff6971bf958", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8824fd4cc119ccbeaab451122d5cbff6971bf958", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8824fd4cc119ccbeaab451122d5cbff6971bf958/comments", "author": null, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8edbdaf7352ccfcf7a18650dca29695038d2978c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8edbdaf7352ccfcf7a18650dca29695038d2978c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8edbdaf7352ccfcf7a18650dca29695038d2978c"}], "stats": {"total": 136, "additions": 121, "deletions": 15}, "files": [{"sha": "66bf1af2106b918c89502ea837dc38408d6e88cc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8824fd4cc119ccbeaab451122d5cbff6971bf958/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8824fd4cc119ccbeaab451122d5cbff6971bf958/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8824fd4cc119ccbeaab451122d5cbff6971bf958", "patch": "@@ -1,3 +1,10 @@\n+2005-11-27  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR libfortran/24919\n+\t* gfortran.dg/ftell_1.f90: Modify testcase so that it doesn't\n+\tfail on CRLF platforms.\n+\t* gfortran.dg/ftell_2.f90: Likewise.\n+\n 2005-11-26  Eric Christopher  <echristo@apple.com>\n \n \t* gcc.dg/intmax_t-1.c: Remove mips xfail."}, {"sha": "eb09caf70542dafee45a2acbc4f83c1506cad505", "filename": "gcc/testsuite/gfortran.dg/ftell_1.f90", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8824fd4cc119ccbeaab451122d5cbff6971bf958/gcc%2Ftestsuite%2Fgfortran.dg%2Fftell_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8824fd4cc119ccbeaab451122d5cbff6971bf958/gcc%2Ftestsuite%2Fgfortran.dg%2Fftell_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fftell_1.f90?ref=8824fd4cc119ccbeaab451122d5cbff6971bf958", "patch": "@@ -1,12 +1,15 @@\n ! { dg-do run }\n-  integer*8 o\n+  integer*8 o, o2\n \n   open (10, status=\"scratch\")\n   call ftell (10, o)\n   if (o /= 0) call abort\n   write (10,\"(A)\") \"1234567\"\n   call ftell (10, o)\n-  if (o /= 8) call abort\n+  if (o /= 8 .and. o /= 9) call abort\n+  write (10,\"(A)\") \"1234567\"\n+  call ftell (10, o2)\n+  if (o2 /= 2 * o) call abort\n   close (10)\n   call ftell (10, o)\n   if (o /= -1) call abort"}, {"sha": "a6fc1c19682d6e98af00373613a0abad2d31d337", "filename": "gcc/testsuite/gfortran.dg/ftell_2.f90", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8824fd4cc119ccbeaab451122d5cbff6971bf958/gcc%2Ftestsuite%2Fgfortran.dg%2Fftell_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8824fd4cc119ccbeaab451122d5cbff6971bf958/gcc%2Ftestsuite%2Fgfortran.dg%2Fftell_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fftell_2.f90?ref=8824fd4cc119ccbeaab451122d5cbff6971bf958", "patch": "@@ -1,8 +1,12 @@\n ! { dg-do run }\n+  integer*8 o\n   open (10, status=\"scratch\")\n   if (ftell(10) /= 0) call abort\n   write (10,\"(A)\") \"1234567\"\n-  if (ftell(10) /= 8) call abort\n+  if (ftell(10) /= 8 .and. ftell(10) /= 9) call abort\n+  o = ftell(10)\n+  write (10,\"(A)\") \"1234567\"\n+  if (ftell(10) /= 2 * o) call abort\n   close (10)\n   if (ftell(10) /= -1) call abort\n   end"}, {"sha": "109e090e501f40d98bbcfff8b83847c803601ecb", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8824fd4cc119ccbeaab451122d5cbff6971bf958/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8824fd4cc119ccbeaab451122d5cbff6971bf958/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=8824fd4cc119ccbeaab451122d5cbff6971bf958", "patch": "@@ -1,3 +1,21 @@\n+2005-11-27  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR libfortran/24919\n+\t* io/list_read.c (eat_separator, finish_separator,\n+\tread_character): Handle CRLF separators correctly during reads.\n+\t(nml_query): Use the HAVE_CRLF macro to print adequate newlines.\n+\t* io/io.h (st_parameter_dt): Add comment about the possible\n+\tvalues for sf_seen_eor.\n+\t* io/unix.c (tempfile, regular_file): HAVE_CRLF doesn't imply\n+\tthat O_BINARY is defined, so we add that condition.\n+\t(stream_at_bof): Fix typo in comment.\n+\t* io/transfer.c (read_sf): Handle correctly CRLF, setting\n+\tsf_seen_eor value to 2 instead of 1.\n+\t(formatted_transfer_scalar): Use the sf_seen_eor value to\n+\thandle CRLF the right way.\n+\t* io/write.c (nml_write_obj, namelist_write): Use CRLF as newline\n+\twhen HAVE_CRLF is defined.\n+\n 2005-11-26  Richard Henderson  <rth@redhat.com>\n \n \t* io/list_read.c (nml_parse_qualifier): Use ssize_t instead of int"}, {"sha": "48cc2a19ab208914bdffafdad25b19587b499407", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8824fd4cc119ccbeaab451122d5cbff6971bf958/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8824fd4cc119ccbeaab451122d5cbff6971bf958/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=8824fd4cc119ccbeaab451122d5cbff6971bf958", "patch": "@@ -379,12 +379,16 @@ typedef struct st_parameter_dt\n \t  int skips;\n \t  /* Number of spaces to be done for T and X-editing.  */\n \t  int pending_spaces;\n+\t  /* Whether an EOR condition was encountered. Value is:\n+\t       0 if no EOR was encountered\n+\t       1 if an EOR was encountered due to a 1-byte marker (LF)\n+\t       2 if an EOR was encountered due to a 2-bytes marker (CRLF) */\n+\t  int sf_seen_eor;\n \t  unit_advance advance_status;\n \n \t  unsigned reversion_flag : 1; /* Format reversion has occurred.  */\n \t  unsigned first_item : 1;\n \t  unsigned seen_dollar : 1;\n-\t  unsigned sf_seen_eor : 1;\n \t  unsigned eor_condition : 1;\n \t  unsigned no_leading_blank : 1;\n \t  unsigned char_flag : 1;"}, {"sha": "3988e3f00d87d077162fbe043532f7ca121b6b2c", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8824fd4cc119ccbeaab451122d5cbff6971bf958/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8824fd4cc119ccbeaab451122d5cbff6971bf958/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=8824fd4cc119ccbeaab451122d5cbff6971bf958", "patch": "@@ -201,7 +201,7 @@ eat_spaces (st_parameter_dt *dtp)\n static void\n eat_separator (st_parameter_dt *dtp)\n {\n-  char c;\n+  char c, n;\n \n   eat_spaces (dtp);\n   dtp->u.p.comma_flag = 0;\n@@ -218,8 +218,18 @@ eat_separator (st_parameter_dt *dtp)\n       dtp->u.p.input_complete = 1;\n       break;\n \n-    case '\\n':\n     case '\\r':\n+      n = next_char(dtp);\n+      if (n == '\\n')\n+\tdtp->u.p.at_eol = 1;\n+      else\n+        {\n+\t  unget_char (dtp, n);\n+\t  unget_char (dtp, c);\n+        } \n+      break;\n+\n+    case '\\n':\n       dtp->u.p.at_eol = 1;\n       break;\n \n@@ -263,7 +273,7 @@ finish_separator (st_parameter_dt *dtp)\n       else\n \t{\n \t  c = eat_spaces (dtp);\n-\t  if (c == '\\n')\n+\t  if (c == '\\n' || c == '\\r')\n \t    goto restart;\n \t}\n \n@@ -796,7 +806,7 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n \t      goto done;\n \t    }\n \n-\t  if (c != '\\n')\n+\t  if (c != '\\n' && c != '\\r')\n \t    push_char (dtp, c);\n \t  break;\n \n@@ -1741,32 +1751,56 @@ nml_query (st_parameter_dt *dtp, char c)\n \t  /* \"&namelist_name\\n\"  */\n \n \t  len = dtp->namelist_name_len;\n+#ifdef HAVE_CRLF\n+\t  p = write_block (dtp, len + 3);\n+#else\n \t  p = write_block (dtp, len + 2);\n+#endif\n \t  if (!p)\n \t    goto query_return;\n \t  memcpy (p, \"&\", 1);\n \t  memcpy ((char*)(p + 1), dtp->namelist_name, len);\n+#ifdef HAVE_CRLF\n+\t  memcpy ((char*)(p + len + 1), \"\\r\\n\", 2);\n+#else\n \t  memcpy ((char*)(p + len + 1), \"\\n\", 1);\n+#endif\n \t  for (nl = dtp->u.p.ionml; nl; nl = nl->next)\n \t    {\n \n \t      /* \" var_name\\n\"  */\n \n \t      len = strlen (nl->var_name);\n+#ifdef HAVE_CRLF\n+\t      p = write_block (dtp, len + 3);\n+#else\n \t      p = write_block (dtp, len + 2);\n+#endif\n \t      if (!p)\n \t\tgoto query_return;\n \t      memcpy (p, \" \", 1);\n \t      memcpy ((char*)(p + 1), nl->var_name, len);\n+#ifdef HAVE_CRLF\n+\t      memcpy ((char*)(p + len + 1), \"\\r\\n\", 2);\n+#else\n \t      memcpy ((char*)(p + len + 1), \"\\n\", 1);\n+#endif\n \t    }\n \n \t  /* \"&end\\n\"  */\n \n+#ifdef HAVE_CRLF\n+\t  p = write_block (dtp, 6);\n+#else\n \t  p = write_block (dtp, 5);\n+#endif\n \t  if (!p)\n \t    goto query_return;\n+#ifdef HAVE_CRLF\n+\t  memcpy (p, \"&end\\r\\n\", 6);\n+#else\n \t  memcpy (p, \"&end\\n\", 5);\n+#endif\n \t}\n \n       /* Flush the stream to force immediate output.  */"}, {"sha": "44cf27ec65af2885a65340750105a2c42da70ad2", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8824fd4cc119ccbeaab451122d5cbff6971bf958/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8824fd4cc119ccbeaab451122d5cbff6971bf958/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=8824fd4cc119ccbeaab451122d5cbff6971bf958", "patch": "@@ -136,7 +136,8 @@ static char *\n read_sf (st_parameter_dt *dtp, int *length)\n {\n   char *base, *p, *q;\n-  int n, readlen;\n+  int n, readlen, crlf;\n+  gfc_offset pos;\n \n   if (*length > SCRATCH_SIZE)\n     dtp->u.p.line_buffer = get_mem (*length);\n@@ -183,6 +184,19 @@ read_sf (st_parameter_dt *dtp, int *length)\n \t  if (dtp->u.p.advance_status == ADVANCE_NO || dtp->u.p.seen_dollar)\n \t    dtp->u.p.eor_condition = 1;\n \n+\t  crlf = 0;\n+\t  /* If we encounter a CR, it might be a CRLF.  */\n+\t  if (*q == '\\r') /* Probably a CRLF */\n+\t    {\n+\t      readlen = 1;\n+\t      pos = stream_offset (dtp->u.p.current_unit->s);\n+\t      q = salloc_r (dtp->u.p.current_unit->s, &readlen);\n+\t      if (*q != '\\n' && readlen == 1) /* Not a CRLF after all.  */\n+\t\tsseek (dtp->u.p.current_unit->s, pos);\n+\t      else\n+\t\tcrlf = 1;\n+\t    }\n+\n \t  /* Without padding, terminate the I/O statement without assigning\n \t     the value.  With padding, the value still needs to be assigned,\n \t     so we can just continue with a short read.  */\n@@ -193,7 +207,7 @@ read_sf (st_parameter_dt *dtp, int *length)\n \t    }\n \n \t  *length = n;\n-\t  dtp->u.p.sf_seen_eor = 1;\n+\t  dtp->u.p.sf_seen_eor = (crlf ? 2 : 1);\n \t  break;\n \t}\n \n@@ -803,10 +817,20 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t      /* Adjust everything for end-of-record condition */\n \t      if (dtp->u.p.sf_seen_eor && !is_internal_unit (dtp))\n \t\t{\n-\t\t  dtp->u.p.current_unit->bytes_left--;\n+\t\t  if (dtp->u.p.sf_seen_eor == 2)\n+\t\t    {\n+\t\t      /* The EOR was a CRLF (two bytes wide).  */\n+\t\t      dtp->u.p.current_unit->bytes_left -= 2;\n+\t\t      dtp->u.p.skips -= 2;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* The EOR marker was only one byte wide.  */\n+\t\t      dtp->u.p.current_unit->bytes_left--;\n+\t\t      dtp->u.p.skips--;\n+\t\t    }\n \t\t  bytes_used = pos;\n \t\t  dtp->u.p.sf_seen_eor = 0;\n-\t\t  dtp->u.p.skips--;\n \t\t}\n \t      if (dtp->u.p.skips < 0)\n \t\t{"}, {"sha": "6750b6f614208e1d91c3f42a6fd26128fc781e67", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8824fd4cc119ccbeaab451122d5cbff6971bf958/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8824fd4cc119ccbeaab451122d5cbff6971bf958/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=8824fd4cc119ccbeaab451122d5cbff6971bf958", "patch": "@@ -1037,7 +1037,7 @@ tempfile (st_parameter_open *opp)\n \n   if (mktemp (template))\n     do\n-#ifdef HAVE_CRLF\n+#if defined(HAVE_CRLF) && defined(O_BINARY)\n       fd = open (template, O_RDWR | O_CREAT | O_EXCL | O_BINARY,\n                  S_IREAD | S_IWRITE);\n #else\n@@ -1127,7 +1127,7 @@ regular_file (st_parameter_open *opp, unit_flags *flags)\n \n   /* rwflag |= O_LARGEFILE; */\n \n-#ifdef HAVE_CRLF\n+#if defined(HAVE_CRLF) && defined(O_BINARY)\n   crflag |= O_BINARY;\n #endif\n \n@@ -1475,7 +1475,7 @@ stream_at_bof (stream * s)\n }\n \n \n-/* stream_at_eof()-- Returns nonzero if the stream is at the beginning\n+/* stream_at_eof()-- Returns nonzero if the stream is at the end\n  * of the file. */\n \n int"}, {"sha": "8ae2c131955c4a2e8fc978007dae57f96fce6463", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8824fd4cc119ccbeaab451122d5cbff6971bf958/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8824fd4cc119ccbeaab451122d5cbff6971bf958/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=8824fd4cc119ccbeaab451122d5cbff6971bf958", "patch": "@@ -1536,7 +1536,11 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \n   if (obj->type != GFC_DTYPE_DERIVED)\n     {\n+#ifdef HAVE_CRLF\n+      write_character (dtp, \"\\r\\n \", 3);\n+#else\n       write_character (dtp, \"\\n \", 2);\n+#endif\n       len = 0;\n       if (base)\n \t{\n@@ -1728,7 +1732,11 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t  if (num > 5)\n \t    {\n \t      num = 0;\n+#ifdef HAVE_CRLF\n+\t      write_character (dtp, \"\\r\\n \", 3);\n+#else\n \t      write_character (dtp, \"\\n \", 2);\n+#endif\n \t    }\n \t  rep_ctr = 1;\n \t}\n@@ -1808,7 +1816,11 @@ namelist_write (st_parameter_dt *dtp)\n \t  t1 = nml_write_obj (dtp, t2, dummy_offset, dummy, dummy_name);\n \t}\n     }\n+#ifdef HAVE_CRLF\n+  write_character (dtp, \"  /\\r\\n \", 5);\n+#else\n   write_character (dtp, \"  /\\n\", 4);\n+#endif\n \n   /* Recover the original delimiter.  */\n "}]}