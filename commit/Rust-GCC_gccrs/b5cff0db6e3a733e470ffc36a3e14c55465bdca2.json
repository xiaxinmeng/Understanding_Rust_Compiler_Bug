{"sha": "b5cff0db6e3a733e470ffc36a3e14c55465bdca2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVjZmYwZGI2ZTNhNzMzZTQ3MGZmYzM2YTNlMTRjNTU0NjViZGNhMg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-11-09T13:18:12Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-11-09T15:29:47Z"}, "message": "Clean up irange self tests.\n\nCurrently we have all the irange and range-op tests in range-op.cc.\nThis patch splits them up into the appropriate file (irange\ntests in value-range.cc and range-op tests in range-op.cc).  The patch\nalso splits up the tests themselves by functionality.  It's not perfect,\nbut significantly better than the mess we had.\n\ngcc/ChangeLog:\n\n\t* function-tests.c (test_ranges): Call range_op_tests.\n\t* range-op.cc (build_range3): Move to value-range.cc.\n\t(range3_tests): Same.\n\t(int_range_max_tests): Same.\n\t(multi_precision_range_tests): Same.\n\t(range_tests): Same.\n\t(operator_tests): Split up...\n\t(range_op_tests): Split up...\n\t(range_op_cast_tests): ...here.\n\t(range_op_lshift_tests): ...here.\n\t(range_op_rshift_tests): ...here.\n\t(range_op_bitwise_and_tests): ...here.\n\t* selftest.h (range_op_tests): New.\n\t* value-range.cc (build_range3): New.\n\t(range_tests_irange3): New.\n\t(range_tests_int_range_max): New.\n\t(range_tests_legacy): New.\n\t(range_tests_misc): New.\n\t(range_tests): New.", "tree": {"sha": "eb1f7dd5a955a26a08b3f2310d54c2b88a4e7fa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb1f7dd5a955a26a08b3f2310d54c2b88a4e7fa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5cff0db6e3a733e470ffc36a3e14c55465bdca2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5cff0db6e3a733e470ffc36a3e14c55465bdca2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5cff0db6e3a733e470ffc36a3e14c55465bdca2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5cff0db6e3a733e470ffc36a3e14c55465bdca2/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f27a3b37b4805feba138dd421f039e3267b1c5f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f27a3b37b4805feba138dd421f039e3267b1c5f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f27a3b37b4805feba138dd421f039e3267b1c5f0"}], "stats": {"total": 1025, "additions": 532, "deletions": 493}, "files": [{"sha": "92f1acf780e532e542286afb555ebba89b1b2695", "filename": "gcc/function-tests.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5cff0db6e3a733e470ffc36a3e14c55465bdca2/gcc%2Ffunction-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5cff0db6e3a733e470ffc36a3e14c55465bdca2/gcc%2Ffunction-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction-tests.c?ref=b5cff0db6e3a733e470ffc36a3e14c55465bdca2", "patch": "@@ -580,6 +580,7 @@ test_ranges ()\n   function *fun = DECL_STRUCT_FUNCTION (fndecl);\n   push_cfun (fun);\n   range_tests ();\n+  range_op_tests ();\n   pop_cfun ();\n }\n "}, {"sha": "bbb2a61ae3585554994f1c49b8bb1cfc1f629e64", "filename": "gcc/range-op.cc", "status": "modified", "additions": 150, "deletions": 493, "changes": 643, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5cff0db6e3a733e470ffc36a3e14c55465bdca2/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5cff0db6e3a733e470ffc36a3e14c55465bdca2/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=b5cff0db6e3a733e470ffc36a3e14c55465bdca2", "patch": "@@ -3361,421 +3361,28 @@ range_cast (irange &r, tree type)\n \n #if CHECKING_P\n #include \"selftest.h\"\n-#include \"stor-layout.h\"\n \n namespace selftest\n {\n #define INT(N) build_int_cst (integer_type_node, (N))\n #define UINT(N) build_int_cstu (unsigned_type_node, (N))\n #define INT16(N) build_int_cst (short_integer_type_node, (N))\n #define UINT16(N) build_int_cstu (short_unsigned_type_node, (N))\n-#define INT64(N) build_int_cstu (long_long_integer_type_node, (N))\n-#define UINT64(N) build_int_cstu (long_long_unsigned_type_node, (N))\n-#define UINT128(N) build_int_cstu (u128_type, (N))\n-#define UCHAR(N) build_int_cstu (unsigned_char_type_node, (N))\n #define SCHAR(N) build_int_cst (signed_char_type_node, (N))\n-\n-static int_range<3>\n-build_range3 (int a, int b, int c, int d, int e, int f)\n-{\n-  int_range<3> i1 (INT (a), INT (b));\n-  int_range<3> i2 (INT (c), INT (d));\n-  int_range<3> i3 (INT (e), INT (f));\n-  i1.union_ (i2);\n-  i1.union_ (i3);\n-  return i1;\n-}\n-\n-static void\n-range3_tests ()\n-{\n-  typedef int_range<3> int_range3;\n-  int_range3 r0, r1, r2;\n-  int_range3 i1, i2, i3;\n-\n-  // ([10,20] U [5,8]) U [1,3] ==> [1,3][5,8][10,20].\n-  r0 = int_range3 (INT (10), INT (20));\n-  r1 = int_range3 (INT (5), INT (8));\n-  r0.union_ (r1);\n-  r1 = int_range3 (INT (1), INT (3));\n-  r0.union_ (r1);\n-  ASSERT_TRUE (r0 == build_range3 (1, 3, 5, 8, 10, 20));\n-\n-  // [1,3][5,8][10,20] U [-5,0] => [-5,3][5,8][10,20].\n-  r1 = int_range3 (INT (-5), INT (0));\n-  r0.union_ (r1);\n-  ASSERT_TRUE (r0 == build_range3 (-5, 3, 5, 8, 10, 20));\n-\n-  // [10,20][30,40] U [50,60] ==> [10,20][30,40][50,60].\n-  r1 = int_range3 (INT (50), INT (60));\n-  r0 = int_range3 (INT (10), INT (20));\n-  r0.union_ (int_range3 (INT (30), INT (40)));\n-  r0.union_ (r1);\n-  ASSERT_TRUE (r0 == build_range3 (10, 20, 30, 40, 50, 60));\n-  // [10,20][30,40][50,60] U [70, 80] ==> [10,20][30,40][50,60][70,80].\n-  r1 = int_range3 (INT (70), INT (80));\n-  r0.union_ (r1);\n-\n-  r2 = build_range3 (10, 20, 30, 40, 50, 60);\n-  r2.union_ (int_range3 (INT (70), INT (80)));\n-  ASSERT_TRUE (r0 == r2);\n-\n-  // [10,20][30,40][50,60] U [6,35] => [6,40][50,60].\n-  r0 = build_range3 (10, 20, 30, 40, 50, 60);\n-  r1 = int_range3 (INT (6), INT (35));\n-  r0.union_ (r1);\n-  r1 = int_range3 (INT (6), INT (40));\n-  r1.union_ (int_range3 (INT (50), INT (60)));\n-  ASSERT_TRUE (r0 == r1);\n-\n-  // [10,20][30,40][50,60] U [6,60] => [6,60].\n-  r0 = build_range3 (10, 20, 30, 40, 50, 60);\n-  r1 = int_range3 (INT (6), INT (60));\n-  r0.union_ (r1);\n-  ASSERT_TRUE (r0 == int_range3 (INT (6), INT (60)));\n-\n-  // [10,20][30,40][50,60] U [6,70] => [6,70].\n-  r0 = build_range3 (10, 20, 30, 40, 50, 60);\n-  r1 = int_range3 (INT (6), INT (70));\n-  r0.union_ (r1);\n-  ASSERT_TRUE (r0 == int_range3 (INT (6), INT (70)));\n-\n-  // [10,20][30,40][50,60] U [35,70] => [10,20][30,70].\n-  r0 = build_range3 (10, 20, 30, 40, 50, 60);\n-  r1 = int_range3 (INT (35), INT (70));\n-  r0.union_ (r1);\n-  r1 = int_range3 (INT (10), INT (20));\n-  r1.union_ (int_range3 (INT (30), INT (70)));\n-  ASSERT_TRUE (r0 == r1);\n-\n-  // [10,20][30,40][50,60] U [15,35] => [10,40][50,60].\n-  r0 = build_range3 (10, 20, 30, 40, 50, 60);\n-  r1 = int_range3 (INT (15), INT (35));\n-  r0.union_ (r1);\n-  r1 = int_range3 (INT (10), INT (40));\n-  r1.union_ (int_range3 (INT (50), INT (60)));\n-  ASSERT_TRUE (r0 == r1);\n-\n-  // [10,20][30,40][50,60] U [35,35] => [10,20][30,40][50,60].\n-  r0 = build_range3 (10, 20, 30, 40, 50, 60);\n-  r1 = int_range3 (INT (35), INT (35));\n-  r0.union_ (r1);\n-  ASSERT_TRUE (r0 == build_range3 (10, 20, 30, 40, 50, 60));\n-}\n-\n-static void\n-int_range_max_tests ()\n-{\n-  int_range_max big;\n-  unsigned int nrange;\n-\n-  // Build a huge multi-range range.\n-  for (nrange = 0; nrange < 50; ++nrange)\n-    {\n-      int_range<1> tmp (INT (nrange*10), INT (nrange*10 + 5));\n-      big.union_ (tmp);\n-    }\n-  ASSERT_TRUE (big.num_pairs () == nrange);\n-\n-  // Verify that we can copy it without loosing precision.\n-  int_range_max copy (big);\n-  ASSERT_TRUE (copy.num_pairs () == nrange);\n-\n-  // Inverting it should produce one more sub-range.\n-  big.invert ();\n-  ASSERT_TRUE (big.num_pairs () == nrange + 1);\n-\n-  int_range<1> tmp (INT (5), INT (37));\n-  big.intersect (tmp);\n-  ASSERT_TRUE (big.num_pairs () == 4);\n-\n-  // Test that [10,10][20,20] does NOT contain 15.\n-  {\n-    int_range_max i1 (build_int_cst (integer_type_node, 10),\n-\t\t      build_int_cst (integer_type_node, 10));\n-    int_range_max i2 (build_int_cst (integer_type_node, 20),\n-\t\t      build_int_cst (integer_type_node, 20));\n-    i1.union_ (i2);\n-    ASSERT_FALSE (i1.contains_p (build_int_cst (integer_type_node, 15)));\n-  }\n-\n-}\n-\n-static void\n-multi_precision_range_tests ()\n-{\n-  // Test truncating copy to int_range<1>.\n-  int_range<3> big = build_range3 (10, 20, 30, 40, 50, 60);\n-  int_range<1> small = big;\n-  ASSERT_TRUE (small == int_range<1> (INT (10), INT (60)));\n-\n-  // Test truncating copy to int_range<2>.\n-  int_range<2> medium = big;\n-  ASSERT_TRUE (!medium.undefined_p ());\n-\n-  // Test that a truncating copy of [MIN,20][22,40][80,MAX]\n-  // ends up as a conservative anti-range of ~[21,21].\n-  big = int_range<3> (vrp_val_min (integer_type_node), INT (20));\n-  big.union_ (int_range<1> (INT (22), INT (40)));\n-  big.union_ (int_range<1> (INT (80), vrp_val_max (integer_type_node)));\n-  small = big;\n-  ASSERT_TRUE (small == int_range<1> (INT (21), INT (21), VR_ANTI_RANGE));\n-\n-  // Copying a legacy symbolic to an int_range should normalize the\n-  // symbolic at copy time.\n-  {\n-    tree ssa = make_ssa_name (integer_type_node);\n-    value_range legacy_range (ssa, INT (25));\n-    int_range<2> copy = legacy_range;\n-    ASSERT_TRUE (copy == int_range<2>  (vrp_val_min (integer_type_node),\n-\t\t\t\t\tINT (25)));\n-\n-    // Test that copying ~[abc_23, abc_23] to a multi-range yields varying.\n-    legacy_range = value_range (ssa, ssa, VR_ANTI_RANGE);\n-    copy = legacy_range;\n-    ASSERT_TRUE (copy.varying_p ());\n-  }\n-\n-  range3_tests ();\n-}\n+#define UCHAR(N) build_int_cstu (unsigned_char_type_node, (N))\n \n static void\n-operator_tests ()\n-{\n-  tree min = vrp_val_min (integer_type_node);\n-  tree max = vrp_val_max (integer_type_node);\n-  tree tiny = fold_build2 (PLUS_EXPR, integer_type_node, min,\n-\t\t\t   build_one_cst (integer_type_node));\n-  int_range_max res;\n-  int_range_max i1 (tiny, max);\n-  int_range_max i2 (build_int_cst (integer_type_node, 255),\n-\t\t    build_int_cst (integer_type_node, 255));\n-\n-  // [MIN+1, MAX] = OP1 & 255: OP1 is VARYING\n-  op_bitwise_and.op1_range (res, integer_type_node, i1, i2);\n-  ASSERT_TRUE (res == int_range<1> (integer_type_node));\n-\n-  // VARYING = OP1 & 255: OP1 is VARYING\n-  i1 = int_range<1> (integer_type_node);\n-  op_bitwise_and.op1_range (res, integer_type_node, i1, i2);\n-  ASSERT_TRUE (res == int_range<1> (integer_type_node));\n-\n-  // Test that 0x808.... & 0x8.... still contains 0x8....\n-  // for a large set of numbers.\n-  {\n-    tree big_type = long_long_unsigned_type_node;\n-    // big_num = 0x808,0000,0000,0000\n-    tree big_num = fold_build2 (LSHIFT_EXPR, big_type,\n-\t\t\t\tbuild_int_cst (big_type, 0x808),\n-\t\t\t\tbuild_int_cst (big_type, 48));\n-    op_bitwise_and.fold_range (res, big_type,\n-\t\t\t       int_range <1> (big_type),\n-\t\t\t       int_range <1> (big_num, big_num));\n-    // val = 0x8,0000,0000,0000\n-    tree val = fold_build2 (LSHIFT_EXPR, big_type,\n-\t\t\t    build_int_cst (big_type, 0x8),\n-\t\t\t    build_int_cst (big_type, 48));\n-    ASSERT_TRUE (res.contains_p (val));\n-  }\n-\n-  // unsigned: [3, MAX] = OP1 >> 1\n-  {\n-    int_range_max lhs (build_int_cst (unsigned_type_node, 3),\n-\t\t       TYPE_MAX_VALUE (unsigned_type_node));\n-    int_range_max one (build_one_cst (unsigned_type_node),\n-\t\t       build_one_cst (unsigned_type_node));\n-    int_range_max op1;\n-    op_rshift.op1_range (op1, unsigned_type_node, lhs, one);\n-    ASSERT_FALSE (op1.contains_p (UINT (3)));\n-  }\n-\n-  // signed: [3, MAX] = OP1 >> 1\n-  {\n-    int_range_max lhs (INT (3), TYPE_MAX_VALUE (integer_type_node));\n-    int_range_max one (INT (1), INT (1));\n-    int_range_max op1;\n-    op_rshift.op1_range (op1, integer_type_node, lhs, one);\n-    ASSERT_FALSE (op1.contains_p (INT (-2)));\n-  }\n-\n-  // This is impossible, so OP1 should be [].\n-  // signed: [MIN, MIN] = OP1 >> 1\n-  {\n-    int_range_max lhs (TYPE_MIN_VALUE (integer_type_node),\n-\t\t       TYPE_MIN_VALUE (integer_type_node));\n-    int_range_max one (INT (1), INT (1));\n-    int_range_max op1;\n-    op_rshift.op1_range (op1, integer_type_node, lhs, one);\n-    ASSERT_TRUE (op1.undefined_p ());\n-  }\n-\n-  // signed: ~[-1] = OP1 >> 31\n-  if (TYPE_PRECISION (integer_type_node) > 31)\n-    {\n-      int_range_max lhs (INT (-1), INT (-1), VR_ANTI_RANGE);\n-      int_range_max shift (INT (31), INT (31));\n-      int_range_max op1;\n-      op_rshift.op1_range (op1, integer_type_node, lhs, shift);\n-      int_range_max negatives = range_negatives (integer_type_node);\n-      negatives.intersect (op1);\n-      ASSERT_TRUE (negatives.undefined_p ());\n-    }\n-\n-  if (TYPE_PRECISION (unsigned_type_node) > 31)\n-    {\n-      // unsigned VARYING = op1 << 1 should be VARYING.\n-      int_range<2> lhs (unsigned_type_node);\n-      int_range<2> shift (INT (1), INT (1));\n-      int_range_max op1;\n-      op_lshift.op1_range (op1, unsigned_type_node, lhs, shift);\n-      ASSERT_TRUE (op1.varying_p ());\n-\n-      // 0 = op1 << 1  should be [0,0], [0x8000000, 0x8000000].\n-      int_range<2> zero (UINT (0), UINT (0));\n-      op_lshift.op1_range (op1, unsigned_type_node, zero, shift);\n-      ASSERT_TRUE (op1.num_pairs () == 2);\n-      // Remove the [0,0] range.\n-      op1.intersect (zero);\n-      ASSERT_TRUE (op1.num_pairs () == 1);\n-      //  op1 << 1   should be [0x8000,0x8000] << 1,\n-      //  which should result in [0,0].\n-      int_range_max result;\n-      op_lshift.fold_range (result, unsigned_type_node, op1, shift);\n-      ASSERT_TRUE (result == zero);\n-    }\n-  // signed VARYING = op1 << 1 should be VARYING.\n-  if (TYPE_PRECISION (integer_type_node) > 31)\n-    {\n-      // unsigned VARYING = op1 << 1  hould be VARYING.\n-      int_range<2> lhs (integer_type_node);\n-      int_range<2> shift (INT (1), INT (1));\n-      int_range_max op1;\n-      op_lshift.op1_range (op1, integer_type_node, lhs, shift);\n-      ASSERT_TRUE (op1.varying_p ());\n-\n-      //  0 = op1 << 1  should be [0,0], [0x8000000, 0x8000000].\n-      int_range<2> zero (INT (0), INT (0));\n-      op_lshift.op1_range (op1, integer_type_node, zero, shift);\n-      ASSERT_TRUE (op1.num_pairs () == 2);\n-      // Remove the [0,0] range.\n-      op1.intersect (zero);\n-      ASSERT_TRUE (op1.num_pairs () == 1);\n-      //  op1 << 1   shuould be [0x8000,0x8000] << 1,\n-      //  which should result in [0,0].\n-      int_range_max result;\n-      op_lshift.fold_range (result, unsigned_type_node, op1, shift);\n-      ASSERT_TRUE (result == zero);\n-    }\n-}\n-\n-// Run all of the selftests within this file.\n-\n-void\n-range_tests ()\n+range_op_cast_tests ()\n {\n-  tree u128_type = build_nonstandard_integer_type (128, /*unsigned=*/1);\n-  int_range<1> i1, i2, i3;\n-  int_range<1> r0, r1, rold;\n-\n-  // Test 1-bit signed integer union.\n-  // [-1,-1] U [0,0] = VARYING.\n-  tree one_bit_type = build_nonstandard_integer_type (1, 0);\n-  tree one_bit_min = vrp_val_min (one_bit_type);\n-  tree one_bit_max = vrp_val_max (one_bit_type);\n-  {\n-    int_range<2> min (one_bit_min, one_bit_min);\n-    int_range<2> max (one_bit_max, one_bit_max);\n-    max.union_ (min);\n-    ASSERT_TRUE (max.varying_p ());\n-  }\n-\n-  // Test inversion of 1-bit signed integers.\n-  {\n-    int_range<2> min (one_bit_min, one_bit_min);\n-    int_range<2> max (one_bit_max, one_bit_max);\n-    int_range<2> t;\n-    t = min;\n-    t.invert ();\n-    ASSERT_TRUE (t == max);\n-    t = max;\n-    t.invert ();\n-    ASSERT_TRUE (t == min);\n-  }\n-\n-  // Test that NOT(255) is [0..254] in 8-bit land.\n-  int_range<1> not_255 (UCHAR (255), UCHAR (255), VR_ANTI_RANGE);\n-  ASSERT_TRUE (not_255 == int_range<1> (UCHAR (0), UCHAR (254)));\n-\n-  // Test that NOT(0) is [1..255] in 8-bit land.\n-  int_range<1> not_zero = range_nonzero (unsigned_char_type_node);\n-  ASSERT_TRUE (not_zero == int_range<1> (UCHAR (1), UCHAR (255)));\n-\n-  // Check that [0,127][0x..ffffff80,0x..ffffff]\n-  //  => ~[128, 0x..ffffff7f].\n-  r0 = int_range<1> (UINT128 (0), UINT128 (127));\n-  tree high = build_minus_one_cst (u128_type);\n-  // low = -1 - 127 => 0x..ffffff80.\n-  tree low = fold_build2 (MINUS_EXPR, u128_type, high, UINT128(127));\n-  r1 = int_range<1> (low, high); // [0x..ffffff80, 0x..ffffffff]\n-  // r0 = [0,127][0x..ffffff80,0x..fffffff].\n-  r0.union_ (r1);\n-  // r1 = [128, 0x..ffffff7f].\n-  r1 = int_range<1> (UINT128(128),\n-\t\t     fold_build2 (MINUS_EXPR, u128_type,\n-\t\t\t\t  build_minus_one_cst (u128_type),\n-\t\t\t\t  UINT128(128)));\n-  r0.invert ();\n-  ASSERT_TRUE (r0 == r1);\n-\n+  int_range<1> r0, r1, r2, rold;\n   r0.set_varying (integer_type_node);\n-  tree minint = wide_int_to_tree (integer_type_node, r0.lower_bound ());\n   tree maxint = wide_int_to_tree (integer_type_node, r0.upper_bound ());\n \n+  // If a range is in any way outside of the range for the converted\n+  // to range, default to the range for the new type.\n   r0.set_varying (short_integer_type_node);\n   tree minshort = wide_int_to_tree (short_integer_type_node, r0.lower_bound ());\n   tree maxshort = wide_int_to_tree (short_integer_type_node, r0.upper_bound ());\n-\n-  r0.set_varying (unsigned_type_node);\n-  tree maxuint = wide_int_to_tree (unsigned_type_node, r0.upper_bound ());\n-\n-  // Check that ~[0,5] => [6,MAX] for unsigned int.\n-  r0 = int_range<1> (UINT (0), UINT (5));\n-  r0.invert ();\n-  ASSERT_TRUE (r0 == int_range<1> (UINT(6), maxuint));\n-\n-  // Check that ~[10,MAX] => [0,9] for unsigned int.\n-  r0 = int_range<1> (UINT(10), maxuint);\n-  r0.invert ();\n-  ASSERT_TRUE (r0 == int_range<1> (UINT (0), UINT (9)));\n-\n-  // Check that ~[0,5] => [6,MAX] for unsigned 128-bit numbers.\n-  r0 = int_range<1> (UINT128 (0), UINT128 (5), VR_ANTI_RANGE);\n-  r1 = int_range<1> (UINT128(6), build_minus_one_cst (u128_type));\n-  ASSERT_TRUE (r0 == r1);\n-\n-  // Check that [~5] is really [-MIN,4][6,MAX].\n-  r0 = int_range<1> (INT (5), INT (5), VR_ANTI_RANGE);\n-  r1 = int_range<1> (minint, INT (4));\n-  r1.union_ (int_range<1> (INT (6), maxint));\n-  ASSERT_FALSE (r1.undefined_p ());\n-  ASSERT_TRUE (r0 == r1);\n-\n-  r1 = int_range<1> (INT (5), INT (5));\n-  int_range<1> r2 (r1);\n-  ASSERT_TRUE (r1 == r2);\n-\n-  r1 = int_range<1> (INT (5), INT (10));\n-\n-  r1 = int_range<1> (integer_type_node,\n-\t\t     wi::to_wide (INT (5)), wi::to_wide (INT (10)));\n-  ASSERT_TRUE (r1.contains_p (INT (7)));\n-\n-  r1 = int_range<1> (SCHAR (0), SCHAR (20));\n-  ASSERT_TRUE (r1.contains_p (SCHAR(15)));\n-  ASSERT_FALSE (r1.contains_p (SCHAR(300)));\n-\n-  // If a range is in any way outside of the range for the converted\n-  // to range, default to the range for the new type.\n   if (TYPE_PRECISION (TREE_TYPE (maxint))\n       > TYPE_PRECISION (short_integer_type_node))\n     {\n@@ -3865,25 +3472,6 @@ range_tests ()\n \t       TYPE_MAX_VALUE (short_unsigned_type_node));\n   ASSERT_TRUE (r0 == r1);\n \n-  // NOT([10,20]) ==> [-MIN,9][21,MAX].\n-  r0 = r1 = int_range<1> (INT (10), INT (20));\n-  r2 = int_range<1> (minint, INT(9));\n-  r2.union_ (int_range<1> (INT(21), maxint));\n-  ASSERT_FALSE (r2.undefined_p ());\n-  r1.invert ();\n-  ASSERT_TRUE (r1 == r2);\n-  // Test that NOT(NOT(x)) == x.\n-  r2.invert ();\n-  ASSERT_TRUE (r0 == r2);\n-\n-  // Test that booleans and their inverse work as expected.\n-  r0 = range_zero (boolean_type_node);\n-  ASSERT_TRUE (r0 == int_range<1> (build_zero_cst (boolean_type_node),\n-\t\t\t\t   build_zero_cst (boolean_type_node)));\n-  r0.invert ();\n-  ASSERT_TRUE (r0 == int_range<1> (build_one_cst (boolean_type_node),\n-\t\t\t\t   build_one_cst (boolean_type_node)));\n-\n   // Casting NONZERO to a narrower type will wrap/overflow so\n   // it's just the entire range for the narrower type.\n   //\n@@ -3910,84 +3498,153 @@ range_tests ()\n   r2 = int_range<1> (INT (1), INT (32767));\n   r1.union_ (r2);\n   ASSERT_TRUE (r0 == r1);\n+}\n \n-  // Make sure NULL and non-NULL of pointer types work, and that\n-  // inverses of them are consistent.\n-  tree voidp = build_pointer_type (void_type_node);\n-  r0 = range_zero (voidp);\n-  r1 = r0;\n-  r0.invert ();\n-  r0.invert ();\n-  ASSERT_TRUE (r0 == r1);\n+static void\n+range_op_lshift_tests ()\n+{\n+  // Test that 0x808.... & 0x8.... still contains 0x8....\n+  // for a large set of numbers.\n+  {\n+    int_range_max res;\n+    tree big_type = long_long_unsigned_type_node;\n+    // big_num = 0x808,0000,0000,0000\n+    tree big_num = fold_build2 (LSHIFT_EXPR, big_type,\n+\t\t\t\tbuild_int_cst (big_type, 0x808),\n+\t\t\t\tbuild_int_cst (big_type, 48));\n+    op_bitwise_and.fold_range (res, big_type,\n+\t\t\t       int_range <1> (big_type),\n+\t\t\t       int_range <1> (big_num, big_num));\n+    // val = 0x8,0000,0000,0000\n+    tree val = fold_build2 (LSHIFT_EXPR, big_type,\n+\t\t\t    build_int_cst (big_type, 0x8),\n+\t\t\t    build_int_cst (big_type, 48));\n+    ASSERT_TRUE (res.contains_p (val));\n+  }\n \n-  // [10,20] U [15, 30] => [10, 30].\n-  r0 = int_range<1> (INT (10), INT (20));\n-  r1 = int_range<1> (INT (15), INT (30));\n-  r0.union_ (r1);\n-  ASSERT_TRUE (r0 == int_range<1> (INT (10), INT (30)));\n-\n-  // [15,40] U [] => [15,40].\n-  r0 = int_range<1> (INT (15), INT (40));\n-  r1.set_undefined ();\n-  r0.union_ (r1);\n-  ASSERT_TRUE (r0 == int_range<1> (INT (15), INT (40)));\n-\n-  // [10,20] U [10,10] => [10,20].\n-  r0 = int_range<1> (INT (10), INT (20));\n-  r1 = int_range<1> (INT (10), INT (10));\n-  r0.union_ (r1);\n-  ASSERT_TRUE (r0 == int_range<1> (INT (10), INT (20)));\n-\n-  // [10,20] U [9,9] => [9,20].\n-  r0 = int_range<1> (INT (10), INT (20));\n-  r1 = int_range<1> (INT (9), INT (9));\n-  r0.union_ (r1);\n-  ASSERT_TRUE (r0 == int_range<1> (INT (9), INT (20)));\n-\n-  // [10,20] ^ [15,30] => [15,20].\n-  r0 = int_range<1> (INT (10), INT (20));\n-  r1 = int_range<1> (INT (15), INT (30));\n-  r0.intersect (r1);\n-  ASSERT_TRUE (r0 == int_range<1> (INT (15), INT (20)));\n-\n-  // Test the internal sanity of wide_int's wrt HWIs.\n-  ASSERT_TRUE (wi::max_value (TYPE_PRECISION (boolean_type_node),\n-\t\t\t      TYPE_SIGN (boolean_type_node))\n-\t       == wi::uhwi (1, TYPE_PRECISION (boolean_type_node)));\n-\n-  // Test zero_p().\n-  r0 = int_range<1> (INT (0), INT (0));\n-  ASSERT_TRUE (r0.zero_p ());\n-\n-  // Test nonzero_p().\n-  r0 = int_range<1> (INT (0), INT (0));\n-  r0.invert ();\n-  ASSERT_TRUE (r0.nonzero_p ());\n-\n-  // test legacy interaction\n-  // r0 = ~[1,1]\n-  r0 = int_range<1> (UINT (1), UINT (1), VR_ANTI_RANGE);\n-  // r1 = ~[3,3]\n-  r1 = int_range<1> (UINT (3), UINT (3), VR_ANTI_RANGE);\n-\n-  // vv = [0,0][2,2][4, MAX]\n-  int_range<3> vv = r0;\n-  vv.intersect (r1);\n-\n-  ASSERT_TRUE (vv.contains_p (UINT (2)));\n-  ASSERT_TRUE (vv.num_pairs () == 3);\n-\n-  // create r0 as legacy [1,1]\n-  r0 = int_range<1> (UINT (1), UINT (1));\n-  // And union it with  [0,0][2,2][4,MAX] multi range\n-  r0.union_ (vv);\n-  // The result should be [0,2][4,MAX], or ~[3,3]  but it must contain 2\n-  ASSERT_TRUE (r0.contains_p (UINT (2)));\n-\n-\n-  multi_precision_range_tests ();\n-  int_range_max_tests ();\n-  operator_tests ();\n+  if (TYPE_PRECISION (unsigned_type_node) > 31)\n+    {\n+      // unsigned VARYING = op1 << 1 should be VARYING.\n+      int_range<2> lhs (unsigned_type_node);\n+      int_range<2> shift (INT (1), INT (1));\n+      int_range_max op1;\n+      op_lshift.op1_range (op1, unsigned_type_node, lhs, shift);\n+      ASSERT_TRUE (op1.varying_p ());\n+\n+      // 0 = op1 << 1  should be [0,0], [0x8000000, 0x8000000].\n+      int_range<2> zero (UINT (0), UINT (0));\n+      op_lshift.op1_range (op1, unsigned_type_node, zero, shift);\n+      ASSERT_TRUE (op1.num_pairs () == 2);\n+      // Remove the [0,0] range.\n+      op1.intersect (zero);\n+      ASSERT_TRUE (op1.num_pairs () == 1);\n+      //  op1 << 1   should be [0x8000,0x8000] << 1,\n+      //  which should result in [0,0].\n+      int_range_max result;\n+      op_lshift.fold_range (result, unsigned_type_node, op1, shift);\n+      ASSERT_TRUE (result == zero);\n+    }\n+  // signed VARYING = op1 << 1 should be VARYING.\n+  if (TYPE_PRECISION (integer_type_node) > 31)\n+    {\n+      // unsigned VARYING = op1 << 1  hould be VARYING.\n+      int_range<2> lhs (integer_type_node);\n+      int_range<2> shift (INT (1), INT (1));\n+      int_range_max op1;\n+      op_lshift.op1_range (op1, integer_type_node, lhs, shift);\n+      ASSERT_TRUE (op1.varying_p ());\n+\n+      //  0 = op1 << 1  should be [0,0], [0x8000000, 0x8000000].\n+      int_range<2> zero (INT (0), INT (0));\n+      op_lshift.op1_range (op1, integer_type_node, zero, shift);\n+      ASSERT_TRUE (op1.num_pairs () == 2);\n+      // Remove the [0,0] range.\n+      op1.intersect (zero);\n+      ASSERT_TRUE (op1.num_pairs () == 1);\n+      //  op1 << 1   shuould be [0x8000,0x8000] << 1,\n+      //  which should result in [0,0].\n+      int_range_max result;\n+      op_lshift.fold_range (result, unsigned_type_node, op1, shift);\n+      ASSERT_TRUE (result == zero);\n+    }\n+}\n+\n+static void\n+range_op_rshift_tests ()\n+{\n+  // unsigned: [3, MAX] = OP1 >> 1\n+  {\n+    int_range_max lhs (build_int_cst (unsigned_type_node, 3),\n+\t\t       TYPE_MAX_VALUE (unsigned_type_node));\n+    int_range_max one (build_one_cst (unsigned_type_node),\n+\t\t       build_one_cst (unsigned_type_node));\n+    int_range_max op1;\n+    op_rshift.op1_range (op1, unsigned_type_node, lhs, one);\n+    ASSERT_FALSE (op1.contains_p (UINT (3)));\n+  }\n+\n+  // signed: [3, MAX] = OP1 >> 1\n+  {\n+    int_range_max lhs (INT (3), TYPE_MAX_VALUE (integer_type_node));\n+    int_range_max one (INT (1), INT (1));\n+    int_range_max op1;\n+    op_rshift.op1_range (op1, integer_type_node, lhs, one);\n+    ASSERT_FALSE (op1.contains_p (INT (-2)));\n+  }\n+\n+  // This is impossible, so OP1 should be [].\n+  // signed: [MIN, MIN] = OP1 >> 1\n+  {\n+    int_range_max lhs (TYPE_MIN_VALUE (integer_type_node),\n+\t\t       TYPE_MIN_VALUE (integer_type_node));\n+    int_range_max one (INT (1), INT (1));\n+    int_range_max op1;\n+    op_rshift.op1_range (op1, integer_type_node, lhs, one);\n+    ASSERT_TRUE (op1.undefined_p ());\n+  }\n+\n+  // signed: ~[-1] = OP1 >> 31\n+  if (TYPE_PRECISION (integer_type_node) > 31)\n+    {\n+      int_range_max lhs (INT (-1), INT (-1), VR_ANTI_RANGE);\n+      int_range_max shift (INT (31), INT (31));\n+      int_range_max op1;\n+      op_rshift.op1_range (op1, integer_type_node, lhs, shift);\n+      int_range_max negatives = range_negatives (integer_type_node);\n+      negatives.intersect (op1);\n+      ASSERT_TRUE (negatives.undefined_p ());\n+    }\n+}\n+\n+static void\n+range_op_bitwise_and_tests ()\n+{\n+  int_range_max res;\n+  tree min = vrp_val_min (integer_type_node);\n+  tree max = vrp_val_max (integer_type_node);\n+  tree tiny = fold_build2 (PLUS_EXPR, integer_type_node, min,\n+\t\t\t   build_one_cst (integer_type_node));\n+  int_range_max i1 (tiny, max);\n+  int_range_max i2 (build_int_cst (integer_type_node, 255),\n+\t\t    build_int_cst (integer_type_node, 255));\n+\n+  // [MIN+1, MAX] = OP1 & 255: OP1 is VARYING\n+  op_bitwise_and.op1_range (res, integer_type_node, i1, i2);\n+  ASSERT_TRUE (res == int_range<1> (integer_type_node));\n+\n+  // VARYING = OP1 & 255: OP1 is VARYING\n+  i1 = int_range<1> (integer_type_node);\n+  op_bitwise_and.op1_range (res, integer_type_node, i1, i2);\n+  ASSERT_TRUE (res == int_range<1> (integer_type_node));\n+}\n+\n+void\n+range_op_tests ()\n+{\n+  range_op_rshift_tests ();\n+  range_op_lshift_tests ();\n+  range_op_bitwise_and_tests ();\n+  range_op_cast_tests ();\n }\n \n } // namespace selftest"}, {"sha": "963e074b4d29157dd6a3b2041d4f42017a91b606", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5cff0db6e3a733e470ffc36a3e14c55465bdca2/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5cff0db6e3a733e470ffc36a3e14c55465bdca2/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=b5cff0db6e3a733e470ffc36a3e14c55465bdca2", "patch": "@@ -248,6 +248,7 @@ extern void ordered_hash_map_tests_cc_tests ();\n extern void predict_c_tests ();\n extern void pretty_print_c_tests ();\n extern void range_tests ();\n+extern void range_op_tests ();\n extern void read_rtl_function_c_tests ();\n extern void rtl_tests_c_tests ();\n extern void sbitmap_c_tests ();"}, {"sha": "61f7da278d6450aa6043ace03561d67479be19e7", "filename": "gcc/value-range.cc", "status": "modified", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5cff0db6e3a733e470ffc36a3e14c55465bdca2/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5cff0db6e3a733e470ffc36a3e14c55465bdca2/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=b5cff0db6e3a733e470ffc36a3e14c55465bdca2", "patch": "@@ -2068,3 +2068,383 @@ DEFINE_INT_RANGE_INSTANCE(2)\n DEFINE_INT_RANGE_INSTANCE(3)\n DEFINE_INT_RANGE_INSTANCE(255)\n DEFINE_INT_RANGE_GC_STUBS(1)\n+\n+#if CHECKING_P\n+#include \"selftest.h\"\n+\n+namespace selftest\n+{\n+#define INT(N) build_int_cst (integer_type_node, (N))\n+#define UINT(N) build_int_cstu (unsigned_type_node, (N))\n+#define UINT128(N) build_int_cstu (u128_type, (N))\n+#define UCHAR(N) build_int_cstu (unsigned_char_type_node, (N))\n+#define SCHAR(N) build_int_cst (signed_char_type_node, (N))\n+\n+static int_range<3>\n+build_range3 (int a, int b, int c, int d, int e, int f)\n+{\n+  int_range<3> i1 (INT (a), INT (b));\n+  int_range<3> i2 (INT (c), INT (d));\n+  int_range<3> i3 (INT (e), INT (f));\n+  i1.union_ (i2);\n+  i1.union_ (i3);\n+  return i1;\n+}\n+\n+static void\n+range_tests_irange3 ()\n+{\n+  typedef int_range<3> int_range3;\n+  int_range3 r0, r1, r2;\n+  int_range3 i1, i2, i3;\n+\n+  // ([10,20] U [5,8]) U [1,3] ==> [1,3][5,8][10,20].\n+  r0 = int_range3 (INT (10), INT (20));\n+  r1 = int_range3 (INT (5), INT (8));\n+  r0.union_ (r1);\n+  r1 = int_range3 (INT (1), INT (3));\n+  r0.union_ (r1);\n+  ASSERT_TRUE (r0 == build_range3 (1, 3, 5, 8, 10, 20));\n+\n+  // [1,3][5,8][10,20] U [-5,0] => [-5,3][5,8][10,20].\n+  r1 = int_range3 (INT (-5), INT (0));\n+  r0.union_ (r1);\n+  ASSERT_TRUE (r0 == build_range3 (-5, 3, 5, 8, 10, 20));\n+\n+  // [10,20][30,40] U [50,60] ==> [10,20][30,40][50,60].\n+  r1 = int_range3 (INT (50), INT (60));\n+  r0 = int_range3 (INT (10), INT (20));\n+  r0.union_ (int_range3 (INT (30), INT (40)));\n+  r0.union_ (r1);\n+  ASSERT_TRUE (r0 == build_range3 (10, 20, 30, 40, 50, 60));\n+  // [10,20][30,40][50,60] U [70, 80] ==> [10,20][30,40][50,60][70,80].\n+  r1 = int_range3 (INT (70), INT (80));\n+  r0.union_ (r1);\n+\n+  r2 = build_range3 (10, 20, 30, 40, 50, 60);\n+  r2.union_ (int_range3 (INT (70), INT (80)));\n+  ASSERT_TRUE (r0 == r2);\n+\n+  // [10,20][30,40][50,60] U [6,35] => [6,40][50,60].\n+  r0 = build_range3 (10, 20, 30, 40, 50, 60);\n+  r1 = int_range3 (INT (6), INT (35));\n+  r0.union_ (r1);\n+  r1 = int_range3 (INT (6), INT (40));\n+  r1.union_ (int_range3 (INT (50), INT (60)));\n+  ASSERT_TRUE (r0 == r1);\n+\n+  // [10,20][30,40][50,60] U [6,60] => [6,60].\n+  r0 = build_range3 (10, 20, 30, 40, 50, 60);\n+  r1 = int_range3 (INT (6), INT (60));\n+  r0.union_ (r1);\n+  ASSERT_TRUE (r0 == int_range3 (INT (6), INT (60)));\n+\n+  // [10,20][30,40][50,60] U [6,70] => [6,70].\n+  r0 = build_range3 (10, 20, 30, 40, 50, 60);\n+  r1 = int_range3 (INT (6), INT (70));\n+  r0.union_ (r1);\n+  ASSERT_TRUE (r0 == int_range3 (INT (6), INT (70)));\n+\n+  // [10,20][30,40][50,60] U [35,70] => [10,20][30,70].\n+  r0 = build_range3 (10, 20, 30, 40, 50, 60);\n+  r1 = int_range3 (INT (35), INT (70));\n+  r0.union_ (r1);\n+  r1 = int_range3 (INT (10), INT (20));\n+  r1.union_ (int_range3 (INT (30), INT (70)));\n+  ASSERT_TRUE (r0 == r1);\n+\n+  // [10,20][30,40][50,60] U [15,35] => [10,40][50,60].\n+  r0 = build_range3 (10, 20, 30, 40, 50, 60);\n+  r1 = int_range3 (INT (15), INT (35));\n+  r0.union_ (r1);\n+  r1 = int_range3 (INT (10), INT (40));\n+  r1.union_ (int_range3 (INT (50), INT (60)));\n+  ASSERT_TRUE (r0 == r1);\n+\n+  // [10,20][30,40][50,60] U [35,35] => [10,20][30,40][50,60].\n+  r0 = build_range3 (10, 20, 30, 40, 50, 60);\n+  r1 = int_range3 (INT (35), INT (35));\n+  r0.union_ (r1);\n+  ASSERT_TRUE (r0 == build_range3 (10, 20, 30, 40, 50, 60));\n+}\n+\n+static void\n+range_tests_int_range_max ()\n+{\n+  int_range_max big;\n+  unsigned int nrange;\n+\n+  // Build a huge multi-range range.\n+  for (nrange = 0; nrange < 50; ++nrange)\n+    {\n+      int_range<1> tmp (INT (nrange*10), INT (nrange*10 + 5));\n+      big.union_ (tmp);\n+    }\n+  ASSERT_TRUE (big.num_pairs () == nrange);\n+\n+  // Verify that we can copy it without loosing precision.\n+  int_range_max copy (big);\n+  ASSERT_TRUE (copy.num_pairs () == nrange);\n+\n+  // Inverting it should produce one more sub-range.\n+  big.invert ();\n+  ASSERT_TRUE (big.num_pairs () == nrange + 1);\n+\n+  int_range<1> tmp (INT (5), INT (37));\n+  big.intersect (tmp);\n+  ASSERT_TRUE (big.num_pairs () == 4);\n+\n+  // Test that [10,10][20,20] does NOT contain 15.\n+  {\n+    int_range_max i1 (build_int_cst (integer_type_node, 10),\n+\t\t      build_int_cst (integer_type_node, 10));\n+    int_range_max i2 (build_int_cst (integer_type_node, 20),\n+\t\t      build_int_cst (integer_type_node, 20));\n+    i1.union_ (i2);\n+    ASSERT_FALSE (i1.contains_p (build_int_cst (integer_type_node, 15)));\n+  }\n+}\n+\n+static void\n+range_tests_legacy ()\n+{\n+  // Test truncating copy to int_range<1>.\n+  int_range<3> big = build_range3 (10, 20, 30, 40, 50, 60);\n+  int_range<1> small = big;\n+  ASSERT_TRUE (small == int_range<1> (INT (10), INT (60)));\n+\n+  // Test truncating copy to int_range<2>.\n+  int_range<2> medium = big;\n+  ASSERT_TRUE (!medium.undefined_p ());\n+\n+  // Test that a truncating copy of [MIN,20][22,40][80,MAX]\n+  // ends up as a conservative anti-range of ~[21,21].\n+  big = int_range<3> (vrp_val_min (integer_type_node), INT (20));\n+  big.union_ (int_range<1> (INT (22), INT (40)));\n+  big.union_ (int_range<1> (INT (80), vrp_val_max (integer_type_node)));\n+  small = big;\n+  ASSERT_TRUE (small == int_range<1> (INT (21), INT (21), VR_ANTI_RANGE));\n+\n+  // Copying a legacy symbolic to an int_range should normalize the\n+  // symbolic at copy time.\n+  {\n+    tree ssa = make_ssa_name (integer_type_node);\n+    value_range legacy_range (ssa, INT (25));\n+    int_range<2> copy = legacy_range;\n+    ASSERT_TRUE (copy == int_range<2>  (vrp_val_min (integer_type_node),\n+\t\t\t\t\tINT (25)));\n+\n+    // Test that copying ~[abc_23, abc_23] to a multi-range yields varying.\n+    legacy_range = value_range (ssa, ssa, VR_ANTI_RANGE);\n+    copy = legacy_range;\n+    ASSERT_TRUE (copy.varying_p ());\n+  }\n+}\n+\n+static void\n+range_tests_misc ()\n+{\n+  tree u128_type = build_nonstandard_integer_type (128, /*unsigned=*/1);\n+  int_range<1> i1, i2, i3;\n+  int_range<1> r0, r1, rold;\n+\n+  // Test 1-bit signed integer union.\n+  // [-1,-1] U [0,0] = VARYING.\n+  tree one_bit_type = build_nonstandard_integer_type (1, 0);\n+  tree one_bit_min = vrp_val_min (one_bit_type);\n+  tree one_bit_max = vrp_val_max (one_bit_type);\n+  {\n+    int_range<2> min (one_bit_min, one_bit_min);\n+    int_range<2> max (one_bit_max, one_bit_max);\n+    max.union_ (min);\n+    ASSERT_TRUE (max.varying_p ());\n+  }\n+\n+  // Test inversion of 1-bit signed integers.\n+  {\n+    int_range<2> min (one_bit_min, one_bit_min);\n+    int_range<2> max (one_bit_max, one_bit_max);\n+    int_range<2> t;\n+    t = min;\n+    t.invert ();\n+    ASSERT_TRUE (t == max);\n+    t = max;\n+    t.invert ();\n+    ASSERT_TRUE (t == min);\n+  }\n+\n+  // Test that NOT(255) is [0..254] in 8-bit land.\n+  int_range<1> not_255 (UCHAR (255), UCHAR (255), VR_ANTI_RANGE);\n+  ASSERT_TRUE (not_255 == int_range<1> (UCHAR (0), UCHAR (254)));\n+\n+  // Test that NOT(0) is [1..255] in 8-bit land.\n+  int_range<1> not_zero = range_nonzero (unsigned_char_type_node);\n+  ASSERT_TRUE (not_zero == int_range<1> (UCHAR (1), UCHAR (255)));\n+\n+  // Check that [0,127][0x..ffffff80,0x..ffffff]\n+  //  => ~[128, 0x..ffffff7f].\n+  r0 = int_range<1> (UINT128 (0), UINT128 (127));\n+  tree high = build_minus_one_cst (u128_type);\n+  // low = -1 - 127 => 0x..ffffff80.\n+  tree low = fold_build2 (MINUS_EXPR, u128_type, high, UINT128(127));\n+  r1 = int_range<1> (low, high); // [0x..ffffff80, 0x..ffffffff]\n+  // r0 = [0,127][0x..ffffff80,0x..fffffff].\n+  r0.union_ (r1);\n+  // r1 = [128, 0x..ffffff7f].\n+  r1 = int_range<1> (UINT128(128),\n+\t\t     fold_build2 (MINUS_EXPR, u128_type,\n+\t\t\t\t  build_minus_one_cst (u128_type),\n+\t\t\t\t  UINT128(128)));\n+  r0.invert ();\n+  ASSERT_TRUE (r0 == r1);\n+\n+  r0.set_varying (integer_type_node);\n+  tree minint = wide_int_to_tree (integer_type_node, r0.lower_bound ());\n+  tree maxint = wide_int_to_tree (integer_type_node, r0.upper_bound ());\n+\n+  r0.set_varying (short_integer_type_node);\n+\n+  r0.set_varying (unsigned_type_node);\n+  tree maxuint = wide_int_to_tree (unsigned_type_node, r0.upper_bound ());\n+\n+  // Check that ~[0,5] => [6,MAX] for unsigned int.\n+  r0 = int_range<1> (UINT (0), UINT (5));\n+  r0.invert ();\n+  ASSERT_TRUE (r0 == int_range<1> (UINT(6), maxuint));\n+\n+  // Check that ~[10,MAX] => [0,9] for unsigned int.\n+  r0 = int_range<1> (UINT(10), maxuint);\n+  r0.invert ();\n+  ASSERT_TRUE (r0 == int_range<1> (UINT (0), UINT (9)));\n+\n+  // Check that ~[0,5] => [6,MAX] for unsigned 128-bit numbers.\n+  r0 = int_range<1> (UINT128 (0), UINT128 (5), VR_ANTI_RANGE);\n+  r1 = int_range<1> (UINT128(6), build_minus_one_cst (u128_type));\n+  ASSERT_TRUE (r0 == r1);\n+\n+  // Check that [~5] is really [-MIN,4][6,MAX].\n+  r0 = int_range<1> (INT (5), INT (5), VR_ANTI_RANGE);\n+  r1 = int_range<1> (minint, INT (4));\n+  r1.union_ (int_range<1> (INT (6), maxint));\n+  ASSERT_FALSE (r1.undefined_p ());\n+  ASSERT_TRUE (r0 == r1);\n+\n+  r1 = int_range<1> (INT (5), INT (5));\n+  int_range<1> r2 (r1);\n+  ASSERT_TRUE (r1 == r2);\n+\n+  r1 = int_range<1> (INT (5), INT (10));\n+\n+  r1 = int_range<1> (integer_type_node,\n+\t\t     wi::to_wide (INT (5)), wi::to_wide (INT (10)));\n+  ASSERT_TRUE (r1.contains_p (INT (7)));\n+\n+  r1 = int_range<1> (SCHAR (0), SCHAR (20));\n+  ASSERT_TRUE (r1.contains_p (SCHAR(15)));\n+  ASSERT_FALSE (r1.contains_p (SCHAR(300)));\n+\n+  // NOT([10,20]) ==> [-MIN,9][21,MAX].\n+  r0 = r1 = int_range<1> (INT (10), INT (20));\n+  r2 = int_range<1> (minint, INT(9));\n+  r2.union_ (int_range<1> (INT(21), maxint));\n+  ASSERT_FALSE (r2.undefined_p ());\n+  r1.invert ();\n+  ASSERT_TRUE (r1 == r2);\n+  // Test that NOT(NOT(x)) == x.\n+  r2.invert ();\n+  ASSERT_TRUE (r0 == r2);\n+\n+  // Test that booleans and their inverse work as expected.\n+  r0 = range_zero (boolean_type_node);\n+  ASSERT_TRUE (r0 == int_range<1> (build_zero_cst (boolean_type_node),\n+\t\t\t\t   build_zero_cst (boolean_type_node)));\n+  r0.invert ();\n+  ASSERT_TRUE (r0 == int_range<1> (build_one_cst (boolean_type_node),\n+\t\t\t\t   build_one_cst (boolean_type_node)));\n+\n+  // Make sure NULL and non-NULL of pointer types work, and that\n+  // inverses of them are consistent.\n+  tree voidp = build_pointer_type (void_type_node);\n+  r0 = range_zero (voidp);\n+  r1 = r0;\n+  r0.invert ();\n+  r0.invert ();\n+  ASSERT_TRUE (r0 == r1);\n+\n+  // [10,20] U [15, 30] => [10, 30].\n+  r0 = int_range<1> (INT (10), INT (20));\n+  r1 = int_range<1> (INT (15), INT (30));\n+  r0.union_ (r1);\n+  ASSERT_TRUE (r0 == int_range<1> (INT (10), INT (30)));\n+\n+  // [15,40] U [] => [15,40].\n+  r0 = int_range<1> (INT (15), INT (40));\n+  r1.set_undefined ();\n+  r0.union_ (r1);\n+  ASSERT_TRUE (r0 == int_range<1> (INT (15), INT (40)));\n+\n+  // [10,20] U [10,10] => [10,20].\n+  r0 = int_range<1> (INT (10), INT (20));\n+  r1 = int_range<1> (INT (10), INT (10));\n+  r0.union_ (r1);\n+  ASSERT_TRUE (r0 == int_range<1> (INT (10), INT (20)));\n+\n+  // [10,20] U [9,9] => [9,20].\n+  r0 = int_range<1> (INT (10), INT (20));\n+  r1 = int_range<1> (INT (9), INT (9));\n+  r0.union_ (r1);\n+  ASSERT_TRUE (r0 == int_range<1> (INT (9), INT (20)));\n+\n+  // [10,20] ^ [15,30] => [15,20].\n+  r0 = int_range<1> (INT (10), INT (20));\n+  r1 = int_range<1> (INT (15), INT (30));\n+  r0.intersect (r1);\n+  ASSERT_TRUE (r0 == int_range<1> (INT (15), INT (20)));\n+\n+  // Test the internal sanity of wide_int's wrt HWIs.\n+  ASSERT_TRUE (wi::max_value (TYPE_PRECISION (boolean_type_node),\n+\t\t\t      TYPE_SIGN (boolean_type_node))\n+\t       == wi::uhwi (1, TYPE_PRECISION (boolean_type_node)));\n+\n+  // Test zero_p().\n+  r0 = int_range<1> (INT (0), INT (0));\n+  ASSERT_TRUE (r0.zero_p ());\n+\n+  // Test nonzero_p().\n+  r0 = int_range<1> (INT (0), INT (0));\n+  r0.invert ();\n+  ASSERT_TRUE (r0.nonzero_p ());\n+\n+  // test legacy interaction\n+  // r0 = ~[1,1]\n+  r0 = int_range<1> (UINT (1), UINT (1), VR_ANTI_RANGE);\n+  // r1 = ~[3,3]\n+  r1 = int_range<1> (UINT (3), UINT (3), VR_ANTI_RANGE);\n+\n+  // vv = [0,0][2,2][4, MAX]\n+  int_range<3> vv = r0;\n+  vv.intersect (r1);\n+\n+  ASSERT_TRUE (vv.contains_p (UINT (2)));\n+  ASSERT_TRUE (vv.num_pairs () == 3);\n+\n+  // create r0 as legacy [1,1]\n+  r0 = int_range<1> (UINT (1), UINT (1));\n+  // And union it with  [0,0][2,2][4,MAX] multi range\n+  r0.union_ (vv);\n+  // The result should be [0,2][4,MAX], or ~[3,3]  but it must contain 2\n+  ASSERT_TRUE (r0.contains_p (UINT (2)));\n+}\n+\n+void\n+range_tests ()\n+{\n+  range_tests_legacy ();\n+  range_tests_irange3 ();\n+  range_tests_int_range_max ();\n+  range_tests_misc ();\n+}\n+\n+} // namespace selftest\n+\n+#endif // CHECKING_P"}]}