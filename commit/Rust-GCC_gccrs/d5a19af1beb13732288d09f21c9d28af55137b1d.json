{"sha": "d5a19af1beb13732288d09f21c9d28af55137b1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVhMTlhZjFiZWIxMzczMjI4OGQwOWYyMWM5ZDI4YWY1NTEzN2IxZA==", "commit": {"author": {"name": "David Holsgrove", "email": "david.holsgrove@xilinx.com", "date": "2014-02-23T18:36:38Z"}, "committer": {"name": "Michael Eager", "email": "eager@gcc.gnu.org", "date": "2014-02-23T18:36:38Z"}, "message": "predicates.md: Add cmp_op predicate.\n\n2014-02-23  David Holsgrove <david.holsgrove@xilinx.com>\n\n\t* config/microblaze/predicates.md: Add cmp_op predicate.\n\t* config/microblaze/microblaze.md: Add branch_compare instruction \n\twhich uses cmp_op predicate and emits cmp insn before branch.\n\t* config/microblaze/microblaze.c (microblaze_emit_compare): Rename \n\tto microblaze_expand_conditional_branch and consolidate logic.\n\t(microblaze_expand_conditional_branch): emit branch_compare\n\tinsn instead of handling cmp op separate from branch insn.\n\nFrom-SVN: r208055", "tree": {"sha": "489ca9896a54997b5f3351776fd6c7cfda7883b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/489ca9896a54997b5f3351776fd6c7cfda7883b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5a19af1beb13732288d09f21c9d28af55137b1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5a19af1beb13732288d09f21c9d28af55137b1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5a19af1beb13732288d09f21c9d28af55137b1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5a19af1beb13732288d09f21c9d28af55137b1d/comments", "author": {"login": "davidholsgrove", "id": 4031547, "node_id": "MDQ6VXNlcjQwMzE1NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4031547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidholsgrove", "html_url": "https://github.com/davidholsgrove", "followers_url": "https://api.github.com/users/davidholsgrove/followers", "following_url": "https://api.github.com/users/davidholsgrove/following{/other_user}", "gists_url": "https://api.github.com/users/davidholsgrove/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidholsgrove/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidholsgrove/subscriptions", "organizations_url": "https://api.github.com/users/davidholsgrove/orgs", "repos_url": "https://api.github.com/users/davidholsgrove/repos", "events_url": "https://api.github.com/users/davidholsgrove/events{/privacy}", "received_events_url": "https://api.github.com/users/davidholsgrove/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9fbb94f2270d423ed8715578e7fa76daa8e85ab9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fbb94f2270d423ed8715578e7fa76daa8e85ab9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fbb94f2270d423ed8715578e7fa76daa8e85ab9"}], "stats": {"total": 165, "additions": 89, "deletions": 76}, "files": [{"sha": "6204106d47068d52ba70b6f9811044aca31cb91f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5a19af1beb13732288d09f21c9d28af55137b1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5a19af1beb13732288d09f21c9d28af55137b1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5a19af1beb13732288d09f21c9d28af55137b1d", "patch": "@@ -1,20 +1,30 @@\n+2014-02-23  David Holsgrove <david.holsgrove@xilinx.com>\n+\n+\t* config/microblaze/predicates.md: Add cmp_op predicate.\n+\t* config/microblaze/microblaze.md: Add branch_compare instruction \n+\twhich uses cmp_op predicate and emits cmp insn before branch.\n+\t* config/microblaze/microblaze.c (microblaze_emit_compare): Rename \n+\tto microblaze_expand_conditional_branch and consolidate logic.\n+\t(microblaze_expand_conditional_branch): emit branch_compare\n+\tinsn instead of handling cmp op separate from branch insn.\n+\n 2014-02-23  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.c (rs6000_emit_le_vsx_move): Relax assert\n \tto permit subregs.\n \n 2014-02-23  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n-        * config/rs6000/altivec.md (altivec_lve<VI_char>x): Replace\n-        define_insn with define_expand and new define_insn\n-        *altivec_lve<VI_char>x_internal.\n-        (altivec_stve<VI_char>x): Replace define_insn with define_expand\n-        and new define_insn *altivec_stve<VI_char>x_internal.\n-        * config/rs6000/rs6000-protos.h (altivec_expand_stvex_be): New\n-        prototype.\n-        * config/rs6000/rs6000.c (altivec_expand_lvx_be): Document use by\n-        lve*x built-ins.\n-        (altivec_expand_stvex_be): New function.\n+\t* config/rs6000/altivec.md (altivec_lve<VI_char>x): Replace\n+\tdefine_insn with define_expand and new define_insn\n+\t*altivec_lve<VI_char>x_internal.\n+\t(altivec_stve<VI_char>x): Replace define_insn with define_expand\n+\tand new define_insn *altivec_stve<VI_char>x_internal.\n+\t* config/rs6000/rs6000-protos.h (altivec_expand_stvex_be): New\n+\tprototype.\n+\t* config/rs6000/rs6000.c (altivec_expand_lvx_be): Document use by\n+\tlve*x built-ins.\n+\t(altivec_expand_stvex_be): New function.\n \n 2014-02-22  Joern Rennecke  <joern.rennecke@embecosm.com>\n "}, {"sha": "985d26a40cad0fce0e770c025af7198de7d09ca4", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 24, "deletions": 44, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5a19af1beb13732288d09f21c9d28af55137b1d/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5a19af1beb13732288d09f21c9d28af55137b1d/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=d5a19af1beb13732288d09f21c9d28af55137b1d", "patch": "@@ -3257,65 +3257,45 @@ microblaze_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n   emit_move_insn (mem, fnaddr);\n }\n \f\n-/* Emit instruction to perform compare.  \n-   cmp is (compare_op op0 op1).  */\n-static rtx\n-microblaze_emit_compare (enum machine_mode mode, rtx cmp, enum rtx_code *cmp_code)\n+/* Generate conditional branch -- first, generate test condition,\n+   second, generate correct branch instruction.  */\n+\n+void\n+microblaze_expand_conditional_branch (enum machine_mode mode, rtx operands[])\n {\n-  rtx cmp_op0 = XEXP (cmp, 0);\n-  rtx cmp_op1 = XEXP (cmp, 1);\n+  enum rtx_code code = GET_CODE (operands[0]);\n+  rtx cmp_op0 = operands[1];\n+  rtx cmp_op1 = operands[2];\n+  rtx label1 = operands[3];\n   rtx comp_reg = gen_reg_rtx (SImode);\n-  enum rtx_code code = *cmp_code;\n-  \n+  rtx condition;\n+\n   gcc_assert ((GET_CODE (cmp_op0) == REG) || (GET_CODE (cmp_op0) == SUBREG));\n \n   /* If comparing against zero, just test source reg.  */\n-  if (cmp_op1 == const0_rtx) \n-    return cmp_op0;\n+  if (cmp_op1 == const0_rtx)\n+    {\n+      comp_reg = cmp_op0;\n+      condition = gen_rtx_fmt_ee (signed_condition (code), SImode, comp_reg, const0_rtx);\n+      emit_jump_insn (gen_condjump (condition, label1));\n+    }\n \n-  if (code == EQ || code == NE)\n+  else if (code == EQ || code == NE)\n     {\n       /* Use xor for equal/not-equal comparison.  */\n       emit_insn (gen_xorsi3 (comp_reg, cmp_op0, cmp_op1));\n+      condition = gen_rtx_fmt_ee (signed_condition (code), SImode, comp_reg, const0_rtx);\n+      emit_jump_insn (gen_condjump (condition, label1));\n     }\n-  else if (code == GT || code == GTU || code == LE || code == LEU)\n-    {\n-      /* MicroBlaze compare is not symmetrical.  */\n-      /* Swap argument order.  */\n-      cmp_op1 = force_reg (mode, cmp_op1);\n-      if (code == GT || code == LE) \n-        emit_insn (gen_signed_compare (comp_reg, cmp_op0, cmp_op1));\n-      else\n-        emit_insn (gen_unsigned_compare (comp_reg, cmp_op0, cmp_op1));\n-      /* Translate test condition.  */\n-      *cmp_code = swap_condition (code);\n-    }\n-  else /* if (code == GE || code == GEU || code == LT || code == LTU) */\n+  else\n     {\n+      /* Generate compare and branch in single instruction. */\n       cmp_op1 = force_reg (mode, cmp_op1);\n-      if (code == GE || code == LT) \n-        emit_insn (gen_signed_compare (comp_reg, cmp_op1, cmp_op0));\n-      else\n-        emit_insn (gen_unsigned_compare (comp_reg, cmp_op1, cmp_op0));\n+      condition = gen_rtx_fmt_ee (code, mode, cmp_op0, cmp_op1);\n+      emit_jump_insn (gen_branch_compare(condition, cmp_op0, cmp_op1, label1));\n     }\n-\n-  return comp_reg;\n }\n \n-/* Generate conditional branch -- first, generate test condition,\n-   second, generate correct branch instruction.  */\n-\n-void\n-microblaze_expand_conditional_branch (enum machine_mode mode, rtx operands[])\n-{\n-  enum rtx_code code = GET_CODE (operands[0]);\n-  rtx comp;\n-  rtx condition;\n-\n-  comp = microblaze_emit_compare (mode, operands[0], &code);\n-  condition = gen_rtx_fmt_ee (signed_condition (code), SImode, comp, const0_rtx);\n-  emit_jump_insn (gen_condjump (condition, operands[3]));\n-}\n \n void\n microblaze_expand_conditional_branch_sf (rtx operands[])"}, {"sha": "0e43a65586a6865675a75f0ecbc527a1df7c269a", "filename": "gcc/config/microblaze/microblaze.md", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5a19af1beb13732288d09f21c9d28af55137b1d/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5a19af1beb13732288d09f21c9d28af55137b1d/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md?ref=d5a19af1beb13732288d09f21c9d28af55137b1d", "patch": "@@ -1635,28 +1635,6 @@\n   (set_attr \"length\"\t\"4\")]\n )              \n \n-(define_insn \"signed_compare\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(unspec\n-\t\t[(match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"d\")] UNSPEC_CMP))]\n-  \"\"\n-  \"cmp\\t%0,%1,%2\"\n-  [(set_attr \"type\"\t\"arith\")\n-  (set_attr \"mode\"\t\"SI\")\n-  (set_attr \"length\"\t\"4\")])\n-\n-(define_insn \"unsigned_compare\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(unspec \n-\t\t[(match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"d\")] UNSPEC_CMPU))]\n-  \"\"\n-  \"cmpu\\t%0,%1,%2\"\n-  [(set_attr \"type\"\t\"arith\")\n-  (set_attr \"mode\"\t\"SI\")\n-  (set_attr \"length\"\t\"4\")])\n-\n ;;----------------------------------------------------------------\n ;; Setting a register from an floating point comparison. \n ;;----------------------------------------------------------------\n@@ -1730,6 +1708,47 @@\n    (set_attr \"length\"\t\"4\")]\n )\n \n+(define_insn \"branch_compare\"\n+  [(set (pc)\n+        (if_then_else (match_operator:SI 0 \"cmp_op\"\n+                                         [(match_operand:SI 1 \"register_operand\" \"d\")\n+                                          (match_operand:SI 2 \"register_operand\" \"d\")\n+                                         ])\n+                      (label_ref (match_operand 3))\n+                      (pc)))\n+  (clobber(reg:SI R_TMP))]\n+  \"\"\n+  {\n+    operands[4] = gen_rtx_REG (SImode, MB_ABI_ASM_TEMP_REGNUM);\n+    enum rtx_code code = GET_CODE (operands[0]);\n+\n+    if (code == GT || code == LE)\n+      {\n+        output_asm_insn (\"cmp\\tr18,%z1,%z2\", operands);\n+        code = swap_condition (code);\n+      }\n+    else if (code == GTU || code == LEU)\n+      {\n+        output_asm_insn (\"cmpu\\tr18,%z1,%z2\", operands);\n+        code = swap_condition (code);\n+      }\n+    else if (code == GE || code == LT)\n+      {\n+        output_asm_insn (\"cmp\\tr18,%z2,%z1\", operands);\n+      }\n+    else if (code == GEU || code == LTU)\n+      {\n+        output_asm_insn (\"cmpu\\tr18,%z2,%z1\", operands);\n+      }\n+\n+    operands[0] = gen_rtx_fmt_ee (signed_condition (code), SImode, operands[4], const0_rtx);\n+    return \"b%C0i%?\\tr18,%3\";\n+  }\n+  [(set_attr \"type\"     \"branch\")\n+   (set_attr \"mode\"     \"none\")\n+   (set_attr \"length\"   \"12\")]\n+)\n+\n ;;----------------------------------------------------------------\n ;; Unconditional branches\n ;;----------------------------------------------------------------"}, {"sha": "bfdf4ea810b4573250dee5a390c04bd3fcbdb1ee", "filename": "gcc/config/microblaze/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5a19af1beb13732288d09f21c9d28af55137b1d/gcc%2Fconfig%2Fmicroblaze%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5a19af1beb13732288d09f21c9d28af55137b1d/gcc%2Fconfig%2Fmicroblaze%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fpredicates.md?ref=d5a19af1beb13732288d09f21c9d28af55137b1d", "patch": "@@ -123,3 +123,7 @@\n ;; Test for valid PIC call operand\n (define_predicate \"call_insn_plt_operand\"\n   (match_test \"PLT_ADDR_P (op)\"))\n+\n+;; Return if the code of this rtx pattern is a comparison.\n+(define_predicate \"cmp_op\"\n+  (match_code \"gt,ge,gtu,geu,lt,le,ltu,leu\"))"}]}