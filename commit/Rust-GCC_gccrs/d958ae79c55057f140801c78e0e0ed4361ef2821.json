{"sha": "d958ae79c55057f140801c78e0e0ed4361ef2821", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk1OGFlNzljNTUwNTdmMTQwODAxYzc4ZTBlMGVkNDM2MWVmMjgyMQ==", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.vnet.ibm.com", "date": "2015-12-18T09:50:02Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2015-12-18T09:50:02Z"}, "message": "S/390: Simplify vector conditionals\n\ngcc/ChangeLog:\n\n2015-12-18  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n\n\t* config/s390/s390.c (s390_expand_vcond): Convert vector\n\tconditional into shift.\n\t* config/s390/vector.md: Change operand predicate.\n\ngcc/testsuite/ChangeLog:\n\n2015-12-18  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n\n\t* gcc.target/s390/vcond-shift.c: New test to check vcond\n\tsimplification.\n\nFrom-SVN: r231808", "tree": {"sha": "75fe343aca7ef7d2afb1fc0e29d11310d7ba6091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75fe343aca7ef7d2afb1fc0e29d11310d7ba6091"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d958ae79c55057f140801c78e0e0ed4361ef2821", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d958ae79c55057f140801c78e0e0ed4361ef2821", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d958ae79c55057f140801c78e0e0ed4361ef2821", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d958ae79c55057f140801c78e0e0ed4361ef2821/comments", "author": {"login": "rdapp1", "id": 22046046, "node_id": "MDQ6VXNlcjIyMDQ2MDQ2", "avatar_url": "https://avatars.githubusercontent.com/u/22046046?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp1", "html_url": "https://github.com/rdapp1", "followers_url": "https://api.github.com/users/rdapp1/followers", "following_url": "https://api.github.com/users/rdapp1/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp1/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp1/subscriptions", "organizations_url": "https://api.github.com/users/rdapp1/orgs", "repos_url": "https://api.github.com/users/rdapp1/repos", "events_url": "https://api.github.com/users/rdapp1/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "332477628507525e3f252183a864d74bddb5c77f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/332477628507525e3f252183a864d74bddb5c77f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/332477628507525e3f252183a864d74bddb5c77f"}], "stats": {"total": 139, "additions": 126, "deletions": 13}, "files": [{"sha": "28a8624bab7923cacabf1a861638ccf04cc5bf05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d958ae79c55057f140801c78e0e0ed4361ef2821/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d958ae79c55057f140801c78e0e0ed4361ef2821/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d958ae79c55057f140801c78e0e0ed4361ef2821", "patch": "@@ -1,3 +1,9 @@\n+2015-12-18  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390.c (s390_expand_vcond): Convert vector\n+\tconditional into shift.\n+\t* config/s390/vector.md: Change operand predicate.\n+\n 2015-12-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/driver-native.c (s390_host_detect_local_cpu): Pick"}, {"sha": "111d46898f87c4210550c33894489530f2983e49", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 52, "deletions": 11, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d958ae79c55057f140801c78e0e0ed4361ef2821/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d958ae79c55057f140801c78e0e0ed4361ef2821/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=d958ae79c55057f140801c78e0e0ed4361ef2821", "patch": "@@ -6139,19 +6139,60 @@ s390_expand_vcond (rtx target, rtx then, rtx els,\n   machine_mode result_mode;\n   rtx result_target;\n \n+  machine_mode target_mode = GET_MODE (target);\n+  machine_mode cmp_mode = GET_MODE (cmp_op1);\n+  rtx op = (cond == LT) ? els : then;\n+\n+  /* Try to optimize x < 0 ? -1 : 0 into (signed) x >> 31\n+     and x < 0 ? 1 : 0 into (unsigned) x >> 31.  Likewise\n+     for short and byte (x >> 15 and x >> 7 respectively).  */\n+  if ((cond == LT || cond == GE)\n+      && target_mode == cmp_mode\n+      && cmp_op2 == CONST0_RTX (cmp_mode)\n+      && op == CONST0_RTX (target_mode)\n+      && s390_vector_mode_supported_p (target_mode)\n+      && GET_MODE_CLASS (target_mode) == MODE_VECTOR_INT)\n+    {\n+      rtx negop = (cond == LT) ? then : els;\n+\n+      int shift = GET_MODE_BITSIZE (GET_MODE_INNER (target_mode)) - 1;\n+\n+      /* if x < 0 ? 1 : 0 or if x >= 0 ? 0 : 1 */\n+      if (negop == CONST1_RTX (target_mode))\n+\t{\n+\t  rtx res = expand_simple_binop (cmp_mode, LSHIFTRT, cmp_op1,\n+\t\t\t\t\t GEN_INT (shift), target,\n+\t\t\t\t\t 1, OPTAB_DIRECT);\n+\t  if (res != target)\n+\t    emit_move_insn (target, res);\n+\t  return;\n+\t}\n+\n+      /* if x < 0 ? -1 : 0 or if x >= 0 ? 0 : -1 */\n+      else if (constm1_operand (negop, target_mode))\n+\t{\n+\t  rtx res = expand_simple_binop (cmp_mode, ASHIFTRT, cmp_op1,\n+\t\t\t\t\t GEN_INT (shift), target,\n+\t\t\t\t\t 0, OPTAB_DIRECT);\n+\t  if (res != target)\n+\t    emit_move_insn (target, res);\n+\t  return;\n+\t}\n+    }\n+\n   /* We always use an integral type vector to hold the comparison\n      result.  */\n-  result_mode = GET_MODE (cmp_op1) == V2DFmode ? V2DImode : GET_MODE (cmp_op1);\n+  result_mode = cmp_mode == V2DFmode ? V2DImode : cmp_mode;\n   result_target = gen_reg_rtx (result_mode);\n \n-  /* Alternatively this could be done by reload by lowering the cmp*\n-     predicates.  But it appears to be better for scheduling etc. to\n-     have that in early.  */\n+  /* We allow vector immediates as comparison operands that\n+     can be handled by the optimization above but not by the\n+     following code.  Hence, force them into registers here.  */\n   if (!REG_P (cmp_op1))\n-    cmp_op1 = force_reg (GET_MODE (target), cmp_op1);\n+    cmp_op1 = force_reg (target_mode, cmp_op1);\n \n   if (!REG_P (cmp_op2))\n-    cmp_op2 = force_reg (GET_MODE (target), cmp_op2);\n+    cmp_op2 = force_reg (target_mode, cmp_op2);\n \n   s390_expand_vec_compare (result_target, cond,\n \t\t\t   cmp_op1, cmp_op2);\n@@ -6161,7 +6202,7 @@ s390_expand_vcond (rtx target, rtx then, rtx els,\n   if (constm1_operand (then, GET_MODE (then))\n       && const0_operand (els, GET_MODE (els)))\n     {\n-      emit_move_insn (target, gen_rtx_SUBREG (GET_MODE (target),\n+      emit_move_insn (target, gen_rtx_SUBREG (target_mode,\n \t\t\t\t\t      result_target, 0));\n       return;\n     }\n@@ -6170,20 +6211,20 @@ s390_expand_vcond (rtx target, rtx then, rtx els,\n   /* This gets triggered e.g.\n      with gcc.c-torture/compile/pr53410-1.c */\n   if (!REG_P (then))\n-    then = force_reg (GET_MODE (target), then);\n+    then = force_reg (target_mode, then);\n \n   if (!REG_P (els))\n-    els = force_reg (GET_MODE (target), els);\n+    els = force_reg (target_mode, els);\n \n   tmp = gen_rtx_fmt_ee (EQ, VOIDmode,\n \t\t\tresult_target,\n \t\t\tCONST0_RTX (result_mode));\n \n   /* We compared the result against zero above so we have to swap then\n      and els here.  */\n-  tmp = gen_rtx_IF_THEN_ELSE (GET_MODE (target), tmp, els, then);\n+  tmp = gen_rtx_IF_THEN_ELSE (target_mode, tmp, els, then);\n \n-  gcc_assert (GET_MODE (target) == GET_MODE (then));\n+  gcc_assert (target_mode == GET_MODE (then));\n   emit_insn (gen_rtx_SET (target, tmp));\n }\n "}, {"sha": "f6a85c8a55cf0d0dabe88b4cabc5d6247b523f37", "filename": "gcc/config/s390/vector.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d958ae79c55057f140801c78e0e0ed4361ef2821/gcc%2Fconfig%2Fs390%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d958ae79c55057f140801c78e0e0ed4361ef2821/gcc%2Fconfig%2Fs390%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvector.md?ref=d958ae79c55057f140801c78e0e0ed4361ef2821", "patch": "@@ -403,7 +403,7 @@\n \t(if_then_else:V_HW\n \t (match_operator 3 \"comparison_operator\"\n \t\t\t [(match_operand:V_HW2 4 \"register_operand\" \"\")\n-\t\t\t  (match_operand:V_HW2 5 \"register_operand\" \"\")])\n+\t\t\t  (match_operand:V_HW2 5 \"nonmemory_operand\" \"\")])\n \t (match_operand:V_HW 1 \"nonmemory_operand\" \"\")\n \t (match_operand:V_HW 2 \"nonmemory_operand\" \"\")))]\n   \"TARGET_VX && GET_MODE_NUNITS (<V_HW:MODE>mode) == GET_MODE_NUNITS (<V_HW2:MODE>mode)\"\n@@ -418,7 +418,7 @@\n \t(if_then_else:V_HW\n \t (match_operator 3 \"comparison_operator\"\n \t\t\t [(match_operand:V_HW2 4 \"register_operand\" \"\")\n-\t\t\t  (match_operand:V_HW2 5 \"register_operand\" \"\")])\n+\t\t\t  (match_operand:V_HW2 5 \"nonmemory_operand\" \"\")])\n \t (match_operand:V_HW 1 \"nonmemory_operand\" \"\")\n \t (match_operand:V_HW 2 \"nonmemory_operand\" \"\")))]\n   \"TARGET_VX && GET_MODE_NUNITS (<V_HW:MODE>mode) == GET_MODE_NUNITS (<V_HW2:MODE>mode)\""}, {"sha": "8f1e82683054cd941c9660121722c4bf35785bd4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d958ae79c55057f140801c78e0e0ed4361ef2821/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d958ae79c55057f140801c78e0e0ed4361ef2821/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d958ae79c55057f140801c78e0e0ed4361ef2821", "patch": "@@ -1,3 +1,8 @@\n+2015-12-18  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n+\n+\t* gcc.target/s390/vcond-shift.c: New test to check vcond\n+\tsimplification.\n+\n 2015-12-18  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/68196"}, {"sha": "f58bd1f8cf4b059e382f4a713a1dd6e8c9c4d33e", "filename": "gcc/testsuite/gcc.target/s390/vcond-shift.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d958ae79c55057f140801c78e0e0ed4361ef2821/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvcond-shift.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d958ae79c55057f140801c78e0e0ed4361ef2821/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvcond-shift.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvcond-shift.c?ref=d958ae79c55057f140801c78e0e0ed4361ef2821", "patch": "@@ -0,0 +1,61 @@\n+/* Check if conditional vector instructions are simplified\n+   into shift operations.  */\n+/* { dg-do compile { target { s390*-*-* } } } */\n+/* { dg-options \"-O3 -march=z13 -mzarch\" } */\n+\n+/* { dg-final { scan-assembler \"vesraf\\t%v.?,%v.?,31\" } } */\n+/* { dg-final { scan-assembler \"vesrah\\t%v.?,%v.?,15\" } } */\n+/* { dg-final { scan-assembler \"vesrab\\t%v.?,%v.?,7\" } } */\n+/* { dg-final { scan-assembler-not \"vzero\\t*\" } } */\n+/* { dg-final { scan-assembler \"vesrlf\\t%v.?,%v.?,31\" } } */\n+/* { dg-final { scan-assembler \"vesrlh\\t%v.?,%v.?,15\" } } */\n+/* { dg-final { scan-assembler \"vesrlb\\t%v.?,%v.?,7\" } } */\n+\n+#define SZ 4\n+#define SZ2 8\n+#define SZ3 16\n+\n+void foo(int *w)\n+{\n+  int i;\n+  /* Should expand to (w + (w < 0 ? 1 : 0)) >> 1\n+     which in turn should get simplified to (w + (w >> 31)) >> 1.  */\n+  for (i = 0; i < SZ; i++)\n+    w[i] = w[i] / 2;\n+}\n+\n+void foo2(short *w)\n+{\n+  int i;\n+  for (i = 0; i < SZ2; i++)\n+    w[i] = w[i] / 2;\n+}\n+\n+\n+void foo3(signed char *w)\n+{\n+  int i;\n+  for (i = 0; i < SZ3; i++)\n+    w[i] = w[i] / 2;\n+}\n+\n+int baz(int *x)\n+{\n+  int i;\n+  for (i = 0; i < SZ; i++)\n+    x[i] = x[i] < 0 ? -1 : 0;\n+}\n+\n+int baf(short *x)\n+{\n+  int i;\n+  for (i = 0; i < SZ2; i++)\n+    x[i] = x[i] >= 0 ? 0 : 1;\n+}\n+\n+int bal(signed char *x)\n+{\n+  int i;\n+  for (i = 0; i < SZ3; i++)\n+    x[i] = x[i] >= 0 ? 0 : -1;\n+}"}]}