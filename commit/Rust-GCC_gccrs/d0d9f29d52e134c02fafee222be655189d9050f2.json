{"sha": "d0d9f29d52e134c02fafee222be655189d9050f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBkOWYyOWQ1MmUxMzRjMDJmYWZlZTIyMmJlNjU1MTg5ZDkwNTBmMg==", "commit": {"author": {"name": "Liaiss Merzougue", "email": "merzougue@adacore.com", "date": "2020-01-13T12:07:26Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-21T07:22:47Z"}, "message": "[Ada] Codepeer remarks take into account\n\ngcc/ada/\n\n\t* libgnat/s-carsi8.adb (Compare_Array_S8): Add pragma Assert to\n\tavoid warning concerning Left_Len and RighLen value regarding\n\tBytes_Compared_As_Words.\n\t* libgnat/s-carun8.adb (Compare_Array_U8): Likewise.\n\t* libgnat/s-geveop.adb (Binary_Operation, Unary_Operation): Add\n\tpragma Assert concerning divide by 0 warning.\n\t* libgnat/s-imgcha.adb (Image_Character): Code update to prevent\n\tconstant operation warning.\n\t(Image_Character): Add pragma Assert concerning the unchecked\n\tString size.\n\t* libgnat/s-imgdec.adb\n\t(Round): Upate loop code to prevent warning concerning\n\tDigs'First access.\n\t(Round): Add pragma assert.\n\t(Set): Add pragma Assert for the unchecked string size.\n\t(Set_Digits): Add pragma Assert for the input range.\n\t(Set_Decimal_Digits): Add pragma Assert.\n\t(Set_Blank_And_Sign): Add pragma Assert for the input range.\n\t* libgnat/s-arit64.adb (DoubleDivide): Add pragma Assert\n\tconcerning Du /= 0.\n\t(Multiply_With_Ovflo_Check): Add pragma Annotate to avoid\n\twarning concerning unsigned -> signed conversion.\n\t* libgnat/s-imguns.adb (Set_Image_Unsigned): Add pragma Assert\n\tto prevent overflow check warning.  Add pragma Assert for\n\tcontrolling S'First = 1.\n\t* libgnat/s-imgrea.adb (Image_Floating_Point, Set, Set_Digs,\n\tSet_Special_Fill, Convert_Integer): Add pragma Annotate to\n\tprevent overflow check warning.\n\t(Set_Image_Real): Add pragma Annotate to avoid dead code warning\n\ton float check. Add pragma Assert to prevent overflow check\n\twarning.\n\t* libgnat/s-imgwiu.adb (Set_Digits, Set_Image_Width_Unsigned):\n\tAdd pragma assert to prevent overflow check warning.\n\t* libgnat/s-imgllu.adb (Set_Image_Long_Long_Unsigned): Add\n\tpragma assert to prevent overflow check warning.\n\t* libgnat/s-imgint.adb (Set_Digits): Add Assert for input\n\tconstraint and to prevent overflow check warning, create\n\tNon_Positive subtype, and change the T parameter as Non_Positive\n\tinstead Integer.\n\t(Set_Image_Integer): Add pragma assert to prevent overflow check\n\twarning.\n\t* libgnat/s-imglli.adb (Set_Digits): Add Assert for input\n\tconstraint and to prevent overflow check warning, create\n\tNon_Positive subtype, and change the T parameter as Non_Positive\n\tinstead Integer.\n\t(Set_Image_Long_Long_Integer): Add pragma assert to prevent\n\toverflow check warning.\n\t* libgnat/s-fatgen.adb (Decompose, Pred, Succ): Add pragma\n\tAnnotate to prevent dead code due to invalid float check.\n\t* libgnat/s-imenne.adb (Image_Enumeration_8,\n\tImage_Enumeration_16, Image_Enumeration_32): Add pragma Assert\n\tto prevent overflow check warning.  Add Names_Index subtype for\n\trestricting Index_table content.", "tree": {"sha": "1e114f5ffb604976972cb0962f6133b010c38b95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e114f5ffb604976972cb0962f6133b010c38b95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0d9f29d52e134c02fafee222be655189d9050f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0d9f29d52e134c02fafee222be655189d9050f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0d9f29d52e134c02fafee222be655189d9050f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0d9f29d52e134c02fafee222be655189d9050f2/comments", "author": {"login": "liaiss", "id": 62889025, "node_id": "MDQ6VXNlcjYyODg5MDI1", "avatar_url": "https://avatars.githubusercontent.com/u/62889025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/liaiss", "html_url": "https://github.com/liaiss", "followers_url": "https://api.github.com/users/liaiss/followers", "following_url": "https://api.github.com/users/liaiss/following{/other_user}", "gists_url": "https://api.github.com/users/liaiss/gists{/gist_id}", "starred_url": "https://api.github.com/users/liaiss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/liaiss/subscriptions", "organizations_url": "https://api.github.com/users/liaiss/orgs", "repos_url": "https://api.github.com/users/liaiss/repos", "events_url": "https://api.github.com/users/liaiss/events{/privacy}", "received_events_url": "https://api.github.com/users/liaiss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05eb5c6142c9406666c97c588ff2c9bdc1706562", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05eb5c6142c9406666c97c588ff2c9bdc1706562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05eb5c6142c9406666c97c588ff2c9bdc1706562"}], "stats": {"total": 245, "additions": 229, "deletions": 16}, "files": [{"sha": "937490e4bde70b68c7fb72b3b87ff2600e26efaf", "filename": "gcc/ada/libgnat/s-arit64.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-arit64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-arit64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit64.adb?ref=d0d9f29d52e134c02fafee222be655189d9050f2", "patch": "@@ -214,6 +214,15 @@ package body System.Arith_64 is\n \n       --  Perform the actual division\n \n+      pragma Assert (Du /= 0);\n+      --  Multiplication of 2-limbs arguments Yu and Zu leads to 4-limbs\n+      --  result (where each limb is 32bits). Cases where 4 limbs are needed\n+      --  require Yhi/=0 and Zhi/=0 and lead to early exit. Remaining cases\n+      --  where 3 limbs are needed correspond to Hi(T2)/=0 and lead to\n+      --  early exit. Thus at this point result fits in 2 limbs which are\n+      --  exactly Lo(T2) and Lo(T1), which corresponds to the value of Du.\n+      --  As the case where one of Yu or Zu is null also led to early exit,\n+      --  Du/=0 here.\n       Qu := Xu / Du;\n       Ru := Xu rem Du;\n \n@@ -305,12 +314,16 @@ package body System.Arith_64 is\n       if X >= 0 then\n          if Y >= 0 then\n             return To_Pos_Int (T2);\n+            pragma Annotate (CodePeer, Intentional, \"precondition\",\n+                             \"Intentional Unsigned->Signed conversion\");\n          else\n             return To_Neg_Int (T2);\n          end if;\n       else -- X < 0\n          if Y < 0 then\n             return To_Pos_Int (T2);\n+            pragma Annotate (CodePeer, Intentional, \"precondition\",\n+                             \"Intentional Unsigned->Signed conversion\");\n          else\n             return To_Neg_Int (T2);\n          end if;\n@@ -476,6 +489,12 @@ package body System.Arith_64 is\n          Zhi := Hi (Zu);\n          Zlo := Lo (Zu);\n \n+         pragma Assert (Zhi /= 0);\n+         --  Hi(Zu)/=0 before normalization. The sequence of Shift_Left\n+         --  operations results in the leading bit of Zu being 1 by moving\n+         --  the leftmost 1-bit in Zu to leading position, thus Zhi=Hi(Zu)/=0\n+         --  here.\n+\n          --  Note that when we scale up the dividend, it still fits in four\n          --  digits, since we already tested for overflow, and scaling does\n          --  not change the invariant that (D (1) & D (2)) < Zu."}, {"sha": "2da7f5a5f9f26d0c99116d85e54ca1649e55e8ab", "filename": "gcc/ada/libgnat/s-carsi8.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-carsi8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-carsi8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-carsi8.adb?ref=d0d9f29d52e134c02fafee222be655189d9050f2", "patch": "@@ -97,6 +97,13 @@ package body System.Compare_Array_Signed_8 is\n             end if;\n          end loop;\n \n+         pragma Assert (Left_Len >= Bytes_Compared_As_Words);\n+         pragma Assert (Right_Len >= Bytes_Compared_As_Words);\n+         --  Left_Len and Right_Len are always greater or equal to\n+         --  Bytes_Compared_As_Words because:\n+         --    * Compare_Len is min (Left_Len, Right_Len)\n+         --    * Words_To_Compare = Compare_Len / 4\n+         --    * Bytes_Compared_As_Words = Words_To_Compare * 4\n          return Compare_Array_S8_Unaligned\n                   (AddA (Left,  Address (Bytes_Compared_As_Words)),\n                    AddA (Right, Address (Bytes_Compared_As_Words)),"}, {"sha": "0ed3d268129a6b8f348a109c2c56c4a3b5fbd9ac", "filename": "gcc/ada/libgnat/s-carun8.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-carun8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-carun8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-carun8.adb?ref=d0d9f29d52e134c02fafee222be655189d9050f2", "patch": "@@ -98,6 +98,13 @@ package body System.Compare_Array_Unsigned_8 is\n             end if;\n          end loop;\n \n+         pragma Assert (Left_Len >= Bytes_Compared_As_Words);\n+         pragma Assert (Right_Len >= Bytes_Compared_As_Words);\n+         --  Left_Len and Right_Len are always greater or equal to\n+         --  Bytes_Compared_As_Words because:\n+         --    * Compare_Len is min (Left_Len, Right_Len)\n+         --    * Words_To_Compare = Compare_Len / 4\n+         --    * Bytes_Compared_As_Words = Words_To_Compare * 4\n          return Compare_Array_U8_Unaligned\n                   (AddA (Left,  Address (Bytes_Compared_As_Words)),\n                    AddA (Right, Address (Bytes_Compared_As_Words)),"}, {"sha": "a598a124390e8f5ba939dd4a46af47aa48b0f9dc", "filename": "gcc/ada/libgnat/s-fatgen.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-fatgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-fatgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fatgen.adb?ref=d0d9f29d52e134c02fafee222be655189d9050f2", "patch": "@@ -172,10 +172,14 @@ package body System.Fat_Gen is\n \n       elsif X > T'Safe_Last then\n          Frac := Invrad;\n+         pragma Annotate (CodePeer, Intentional, \"dead code\",\n+                          \"Check float range.\");\n          Expo := T'Machine_Emax + 1;\n \n       elsif X < T'Safe_First then\n          Frac := -Invrad;\n+         pragma Annotate (CodePeer, Intentional, \"dead code\",\n+                          \"Check float range.\");\n          Expo := T'Machine_Emax + 2;    -- how many extra negative values?\n \n       else\n@@ -217,6 +221,8 @@ package body System.Fat_Gen is\n \n                while Ax < R_Neg_Power (Expbits'Last) loop\n                   Ax := Ax * R_Power (Expbits'Last);\n+                  pragma Annotate (CodePeer, Intentional, \"dead code\",\n+                                   \"Check float range.\");\n                   Ex := Ex - Log_Power (Expbits'Last);\n                end loop;\n                pragma Annotate\n@@ -424,7 +430,11 @@ package body System.Fat_Gen is\n       --  For infinities, return unchanged\n \n       elsif X < T'First or else X > T'Last then\n+         pragma Annotate (CodePeer, Intentional, \"condition predetermined\",\n+                          \"Check for invalid float\");\n          return X;\n+         pragma Annotate (CodePeer, Intentional, \"dead code\",\n+                          \"Check float range.\");\n \n       --  Subtract from the given number a number equivalent to the value\n       --  of its least significant bit. Given that the most significant bit\n@@ -673,7 +683,11 @@ package body System.Fat_Gen is\n       --  For infinities, return unchanged\n \n       elsif X < T'First or else X > T'Last then\n+         pragma Annotate (CodePeer, Intentional, \"condition predetermined\",\n+                          \"Check for invalid float\");\n          return X;\n+         pragma Annotate (CodePeer, Intentional, \"dead code\",\n+                          \"Check float range.\");\n \n       --  Add to the given number a number equivalent to the value\n       --  of its least significant bit. Given that the most significant bit"}, {"sha": "ff62a344c14fe720b8c21d6e1f1615383d889570", "filename": "gcc/ada/libgnat/s-geveop.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-geveop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-geveop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-geveop.adb?ref=d0d9f29d52e134c02fafee222be655189d9050f2", "patch": "@@ -66,6 +66,13 @@ package body System.Generic_Vector_Operations is\n       function VP is new Ada.Unchecked_Conversion (Address, Vector_Ptr);\n       function EP is new Ada.Unchecked_Conversion (Address, Element_Ptr);\n \n+      pragma Assert (VI > 0);\n+      --  VI = VU\n+      --  VU = Vectors.Vector'Size / Storage_Unit\n+      --  Vector'Size = System.Word_Size\n+      --  System.Word_Size is a multiple of Storage_Unit\n+      --  Vector'Size > Storage_Unit\n+      --  VI > 0\n       SA : constant Address :=\n              AddA (XA, To_Address\n                          ((Integer_Address (Length) / VI * VI) and Unaligned));\n@@ -111,6 +118,13 @@ package body System.Generic_Vector_Operations is\n       function VP is new Ada.Unchecked_Conversion (Address, Vector_Ptr);\n       function EP is new Ada.Unchecked_Conversion (Address, Element_Ptr);\n \n+      pragma Assert (VI > 0);\n+      --  VI = VU\n+      --  VU = Vectors.Vector'Size / Storage_Unit\n+      --  Vector'Size = System.Word_Size\n+      --  System.Word_Size is a multiple of Storage_Unit\n+      --  Vector'Size > Storage_Unit\n+      --  VI > 0\n       SA : constant Address :=\n              AddA (XA, To_Address\n                          ((Integer_Address (Length) / VI * VI) and Unaligned));"}, {"sha": "8409f6a4a4811efb0dc59483c620e44c7112184d", "filename": "gcc/ada/libgnat/s-imenne.adb", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imenne.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imenne.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imenne.adb?ref=d0d9f29d52e134c02fafee222be655189d9050f2", "patch": "@@ -49,8 +49,11 @@ package body System.Img_Enum_New is\n       pragma Assert (S'First = 1);\n \n       type Natural_8 is range 0 .. 2 ** 7 - 1;\n+      subtype Names_Index is\n+        Natural_8 range Natural_8 (Names'First)\n+                          .. Natural_8 (Names'Last) + 1;\n       subtype Index is Natural range Natural'First .. Names'Length;\n-      type Index_Table is array (Index) of Natural_8;\n+      type Index_Table is array (Index) of Names_Index;\n       type Index_Table_Ptr is access Index_Table;\n \n       function To_Index_Table_Ptr is\n@@ -61,6 +64,13 @@ package body System.Img_Enum_New is\n       Start : constant Natural := Natural (IndexesT (Pos));\n       Next  : constant Natural := Natural (IndexesT (Pos + 1));\n \n+      pragma Assert (Next - 1 >= Start);\n+      pragma Assert (Start >= Names'First);\n+      pragma Assert (Next - 1 <= Names'Last);\n+\n+      pragma Assert (Next - Start <= S'Last);\n+      --  The caller should guarantee that S is large enough to contain the\n+      --  enumeration image.\n    begin\n       S (1 .. Next - Start) := Names (Start .. Next - 1);\n       P := Next - Start;\n@@ -80,8 +90,11 @@ package body System.Img_Enum_New is\n       pragma Assert (S'First = 1);\n \n       type Natural_16 is range 0 .. 2 ** 15 - 1;\n+      subtype Names_Index is\n+        Natural_16 range Natural_16 (Names'First)\n+                           .. Natural_16 (Names'Last) + 1;\n       subtype Index is Natural range Natural'First .. Names'Length;\n-      type Index_Table is array (Index) of Natural_16;\n+      type Index_Table is array (Index) of Names_Index;\n       type Index_Table_Ptr is access Index_Table;\n \n       function To_Index_Table_Ptr is\n@@ -92,6 +105,13 @@ package body System.Img_Enum_New is\n       Start : constant Natural := Natural (IndexesT (Pos));\n       Next  : constant Natural := Natural (IndexesT (Pos + 1));\n \n+      pragma Assert (Next - 1 >= Start);\n+      pragma Assert (Start >= Names'First);\n+      pragma Assert (Next - 1 <= Names'Last);\n+\n+      pragma Assert (Next - Start <= S'Last);\n+      --  The caller should guarantee that S is large enough to contain the\n+      --  enumeration image.\n    begin\n       S (1 .. Next - Start) := Names (Start .. Next - 1);\n       P := Next - Start;\n@@ -111,8 +131,11 @@ package body System.Img_Enum_New is\n       pragma Assert (S'First = 1);\n \n       type Natural_32 is range 0 .. 2 ** 31 - 1;\n+      subtype Names_Index is\n+        Natural_32 range Natural_32 (Names'First)\n+                           .. Natural_32 (Names'Last) + 1;\n       subtype Index is Natural range Natural'First .. Names'Length;\n-      type Index_Table is array (Index) of Natural_32;\n+      type Index_Table is array (Index) of Names_Index;\n       type Index_Table_Ptr is access Index_Table;\n \n       function To_Index_Table_Ptr is\n@@ -123,6 +146,13 @@ package body System.Img_Enum_New is\n       Start : constant Natural := Natural (IndexesT (Pos));\n       Next  : constant Natural := Natural (IndexesT (Pos + 1));\n \n+      pragma Assert (Next - 1 >= Start);\n+      pragma Assert (Start >= Names'First);\n+      pragma Assert (Next - 1 <= Names'Last);\n+\n+      pragma Assert (Next - Start <= S'Last);\n+      --  The caller should guarantee that S is large enough to contain the\n+      --  enumeration image.\n    begin\n       S (1 .. Next - Start) := Names (Start .. Next - 1);\n       P := Next - Start;"}, {"sha": "06048eb64f1338132b1a1bc9400ea6e2a90520d5", "filename": "gcc/ada/libgnat/s-imgcha.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imgcha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imgcha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgcha.adb?ref=d0d9f29d52e134c02fafee222be655189d9050f2", "patch": "@@ -140,8 +140,12 @@ package body System.Img_Char is\n             declare\n                VP : constant Natural := Character'Pos (V);\n             begin\n-               S (1 .. 9) := \"RESERVED_\";\n-               S (10) := Character'Val (48 + VP / 100);\n+               pragma Assert (S'First = 1 and S'Last >= 12);\n+               --  As described in the header description, this procedure\n+               --  doesn't check the size of the string provided by the caller\n+               --  and suppose S'First is 1.\n+               S (1 .. 10) := \"RESERVED_1\";\n+               --  Since C1_Range is 127..159, the first character is always 1\n                S (11) := Character'Val (48 + (VP / 10) mod 10);\n                S (12) := Character'Val (48 + VP mod 10);\n                P := 12;"}, {"sha": "840dadbdd1f170666cd2c52d052c60ecdc87db28", "filename": "gcc/ada/libgnat/s-imgdec.adb", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imgdec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imgdec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgdec.adb?ref=d0d9f29d52e134c02fafee222be655189d9050f2", "patch": "@@ -72,6 +72,10 @@ package body System.Img_Dec is\n       Aft   : Natural;\n       Exp   : Natural)\n    is\n+      pragma Assert (NDigs >= 1);\n+      pragma Assert (Digs'First = 1);\n+      pragma Assert (Digs'First < Digs'Last);\n+\n       Minus : constant Boolean := (Digs (Digs'First) = '-');\n       --  Set True if input is negative\n \n@@ -135,6 +139,10 @@ package body System.Img_Dec is\n       procedure Round (N : Integer) is\n          D : Character;\n \n+         pragma Assert (NDigs >= 1);\n+         pragma Assert (Digs'First = 1);\n+         pragma Assert (Digs'First < Digs'Last);\n+\n       begin\n          --  Nothing to do if rounding past the last digit we have\n \n@@ -164,10 +172,17 @@ package body System.Img_Dec is\n \n          else\n             LD := N;\n+            pragma Assert (LD >= 1);\n+            --  In this case, we have N < LD and N >= FD. FD is a Natural,\n+            --  So we can conclude, LD >= 1\n             ND := LD - 1;\n+            pragma Assert (N + 1 <= Digs'Last);\n \n             if Digs (N + 1) >= '5' then\n-               for J in reverse 2 .. N loop\n+               for J in reverse Digs'First + 1 .. Digs'First + N - 1 loop\n+                  pragma Assert (Digs (J) in '0' .. '9' | ' ' | '-');\n+                  --  Because it is a decimal image, we can assume that\n+                  --  it can only contain these characters.\n                   D := Character'Succ (Digs (J));\n \n                   if D <= '9' then\n@@ -196,6 +211,17 @@ package body System.Img_Dec is\n \n       procedure Set (C : Character) is\n       begin\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done as documented in the header : updating P to\n+         --  point to the last character stored, the caller promises that the\n+         --  buffer is large enough and no check is made for this.\n+         --  Constraint_Error will not necessarily be raised if this\n+         --  requirement is violated, since it is perfectly valid to compile\n+         --  this unit with checks off.\n+         --\n+         --  Due to codepeer limitation, codepeer should be used with switch:\n+         --   -no-propagation system.img_dec.set_decimal_digits.set\n          P := P + 1;\n          S (P) := C;\n       end Set;\n@@ -230,6 +256,9 @@ package body System.Img_Dec is\n \n       procedure Set_Digits (S, E : Natural) is\n       begin\n+         pragma Assert (S >= Digs'First and E <= Digs'Last);\n+         --  S and E should be in the Digs array range\n+         --  TBC: Analysis should be completed\n          for J in S .. E loop\n             Set (Digs (J));\n          end loop;\n@@ -254,8 +283,10 @@ package body System.Img_Dec is\n       if Exp > 0 then\n          Set_Blanks_And_Sign (Fore - 1);\n          Round (Digits_After_Point + 2);\n+\n          Set (Digs (FD));\n          FD := FD + 1;\n+         pragma Assert (ND >= 1);\n          ND := ND - 1;\n          Set ('.');\n \n@@ -388,6 +419,9 @@ package body System.Img_Dec is\n \n             else\n                Set_Blanks_And_Sign (Fore - Digits_Before_Point);\n+               pragma Assert (FD + Digits_Before_Point - 1 >= 0);\n+               --  In this branch, we have Digits_Before_Point > 0. It is the\n+               --  else of test (Digits_Before_Point <= 0)\n                Set_Digits (FD, FD + Digits_Before_Point - 1);\n                Set ('.');\n                Set_Digits (FD + Digits_Before_Point, LD);"}, {"sha": "112d62bcc4ce70a687a10ec400e06d073c86a006", "filename": "gcc/ada/libgnat/s-imgint.adb", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imgint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imgint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgint.adb?ref=d0d9f29d52e134c02fafee222be655189d9050f2", "patch": "@@ -31,8 +31,10 @@\n \n package body System.Img_Int is\n \n+   subtype Non_Positive is Integer range Integer'First .. 0;\n+\n    procedure Set_Digits\n-     (T : Integer;\n+     (T : Non_Positive;\n       S : in out String;\n       P : in out Natural);\n    --  Set digits of absolute value of T, which is zero or negative. We work\n@@ -66,16 +68,26 @@ package body System.Img_Int is\n    ----------------\n \n    procedure Set_Digits\n-     (T : Integer;\n+     (T : Non_Positive;\n       S : in out String;\n       P : in out Natural)\n    is\n    begin\n       if T <= -10 then\n          Set_Digits (T / 10, S, P);\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done since, as documented in the Set_Image_Integer\n+         --  specification, the caller guarantees that S is long enough to\n+         --  hold the result.\n          P := P + 1;\n          S (P) := Character'Val (48 - (T rem 10));\n       else\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done since, as documented in the Set_Image_Integer\n+         --  specification, the caller guarantees that S is long enough to\n+         --  hold the result.\n          P := P + 1;\n          S (P) := Character'Val (48 - T);\n       end if;\n@@ -94,6 +106,10 @@ package body System.Img_Int is\n       if V >= 0 then\n          Set_Digits (-V, S, P);\n       else\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done since, as documented in the specification,\n+         --  the caller guarantees that S is long enough to hold the result.\n          P := P + 1;\n          S (P) := '-';\n          Set_Digits (V, S, P);"}, {"sha": "66332fe0fcaa230ba1e12688d3c47a152212c5fb", "filename": "gcc/ada/libgnat/s-imglli.adb", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imglli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imglli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imglli.adb?ref=d0d9f29d52e134c02fafee222be655189d9050f2", "patch": "@@ -31,8 +31,11 @@\n \n package body System.Img_LLI is\n \n+   subtype Non_Positive is Long_Long_Integer\n+                        range Long_Long_Integer'First .. 0;\n+\n    procedure Set_Digits\n-     (T : Long_Long_Integer;\n+     (T : Non_Positive;\n       S : in out String;\n       P : in out Natural);\n    --  Set digits of absolute value of T, which is zero or negative. We work\n@@ -66,16 +69,26 @@ package body System.Img_LLI is\n    ----------------\n \n    procedure Set_Digits\n-     (T : Long_Long_Integer;\n+     (T : Non_Positive;\n       S : in out String;\n       P : in out Natural)\n    is\n    begin\n       if T <= -10 then\n          Set_Digits (T / 10, S, P);\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done as documented in the Set_Image_Long_Long_Integer\n+         --  specification: The caller guarantees that S is long enough to\n+         --  hold the result.\n          P := P + 1;\n          S (P) := Character'Val (48 - (T rem 10));\n       else\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done as documented in the Set_Image_Long_Long_Integer\n+         --  specification: The caller guarantees that S is long enough to\n+         --  hold the result.\n          P := P + 1;\n          S (P) := Character'Val (48 - T);\n       end if;\n@@ -93,6 +106,10 @@ package body System.Img_LLI is\n       if V >= 0 then\n          Set_Digits (-V, S, P);\n       else\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done as documented in the specification:\n+         --  The caller guarantees that S is long enough to hold the result.\n          P := P + 1;\n          S (P) := '-';\n          Set_Digits (V, S, P);"}, {"sha": "e2952ee0825666f6768b0bdc7bea7b9d82ebca52", "filename": "gcc/ada/libgnat/s-imgllu.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imgllu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imgllu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllu.adb?ref=d0d9f29d52e134c02fafee222be655189d9050f2", "patch": "@@ -61,10 +61,18 @@ package body System.Img_LLU is\n    begin\n       if V >= 10 then\n          Set_Image_Long_Long_Unsigned (V / 10, S, P);\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done since, as documented in the specification, the\n+         --  caller guarantees that S is long enough to hold the result.\n          P := P + 1;\n          S (P) := Character'Val (48 + (V rem 10));\n \n       else\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done since, as documented in the specification, the\n+         --  caller guarantees that S is long enough to hold the result.\n          P := P + 1;\n          S (P) := Character'Val (48 + V);\n       end if;"}, {"sha": "a37e8790c49f6ee0198a508cb12dbfa9c27cc3ff", "filename": "gcc/ada/libgnat/s-imgrea.adb", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imgrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imgrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgrea.adb?ref=d0d9f29d52e134c02fafee222be655189d9050f2", "patch": "@@ -99,6 +99,11 @@ package body System.Img_Real is\n       if (not Is_Negative (V) and then V <= Long_Long_Float'Last)\n         or else (not Long_Long_Float'Signed_Zeros and then V = -0.0)\n       then\n+         pragma Annotate (CodePeer, False_Positive, \"condition predetermined\",\n+                          \"CodePeer analysis ignores NaN and Inf values\");\n+         pragma Assert (S'Last > 1);\n+         --  The caller is responsible for S to be large enough for all\n+         --  Image_Floating_Point operation.\n          S (1) := ' ';\n          P := 1;\n       else\n@@ -376,6 +381,8 @@ package body System.Img_Real is\n             Set_Image_Unsigned\n               (Unsigned (Long_Long_Float'Truncation (X)),\n                Digs, Ndigs);\n+            pragma Annotate (CodePeer, False_Positive, \"overflow check\",\n+                             \"The X integer part fits in unsigned\");\n \n          --  But if we want more digits than fit in Unsigned, we have to use\n          --  the Long_Long_Unsigned routine after all.\n@@ -394,6 +401,12 @@ package body System.Img_Real is\n \n       procedure Set (C : Character) is\n       begin\n+         pragma Assert (P in S'First - 1 .. S'Last - 1);\n+         --  No check is done as documented in the header: updating P to point\n+         --  to the last character stored, the caller promises that the buffer\n+         --  is large enough and no check is made for this. Constraint_Error\n+         --  will not necessarily be raised if this requirement is violated,\n+         --  since it is perfectly valid to compile this unit with checks off.\n          P := P + 1;\n          S (P) := C;\n       end Set;\n@@ -424,6 +437,8 @@ package body System.Img_Real is\n \n       procedure Set_Digs (S, E : Natural) is\n       begin\n+         pragma Assert (S >= Digs'First and E <= Digs'Last);\n+         --  S and E should be in the Digs array range\n          for J in S .. E loop\n             Set (Digs (J));\n          end loop;\n@@ -437,9 +452,13 @@ package body System.Img_Real is\n          F : Natural;\n \n       begin\n+         pragma Assert ((Fore + Aft - N + 1) in Natural);\n+         --  Fore + Aft - N + 1 should be in the Natural range\n          F := Fore + 1 + Aft - N;\n \n          if Exp /= 0 then\n+            pragma Assert (F + Exp + 1 <= Natural'Last);\n+            --  F + Exp + 1 should be in the Natural range\n             F := F + Exp + 1;\n          end if;\n \n@@ -487,24 +506,23 @@ package body System.Img_Real is\n          --  an infinite value, so we print Inf.\n \n          if V > Long_Long_Float'Last then\n-            pragma Annotate\n-              (CodePeer, Intentional, \"test always true\", \"test for infinity\");\n-\n+            pragma Annotate (CodePeer, False_Positive, \"dead code\",\n+                             \"CodePeer analysis ignores NaN and Inf values\");\n             Set ('+');\n             Set ('I');\n             Set ('n');\n             Set ('f');\n             Set_Special_Fill (4);\n-\n          --  In all other cases we print NaN\n \n          elsif V < Long_Long_Float'First then\n             Set ('-');\n+            pragma Annotate (CodePeer, False_Positive, \"dead code\",\n+                             \"CodePeer analysis ignores NaN and Inf values\");\n             Set ('I');\n             Set ('n');\n             Set ('f');\n             Set_Special_Fill (4);\n-\n          else\n             Set ('N');\n             Set ('a');\n@@ -597,6 +615,7 @@ package body System.Img_Real is\n \n                   for J in 1 .. Scale + NF loop\n                      Ndigs := Ndigs + 1;\n+                     pragma Assert (Ndigs <= Digs'Last);\n                      Digs (Ndigs) := '0';\n                   end loop;\n \n@@ -663,6 +682,7 @@ package body System.Img_Real is\n \n             for J in 1 .. NFrac - Maxdigs + 1 loop\n                Ndigs := Ndigs + 1;\n+               pragma Assert (Ndigs <= Digs'Last);\n                Digs (Ndigs) := '0';\n                Scale := Scale - 1;\n             end loop;"}, {"sha": "02195e3c3d3ef2bdc009467eddf9ef4d51965062", "filename": "gcc/ada/libgnat/s-imguns.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imguns.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imguns.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imguns.adb?ref=d0d9f29d52e134c02fafee222be655189d9050f2", "patch": "@@ -58,13 +58,21 @@ package body System.Img_Uns is\n       S : in out String;\n       P : in out Natural)\n    is\n+      pragma Assert (S'First = 1);\n    begin\n       if V >= 10 then\n          Set_Image_Unsigned (V / 10, S, P);\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done since, as documented in the specification,\n+         --  the caller guarantees that S is long enough to hold the result.\n          P := P + 1;\n          S (P) := Character'Val (48 + (V rem 10));\n-\n       else\n+         pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                        P < Natural'Last);\n+         --  No check is done since, as documented in the specification,\n+         --  the caller guarantees that S is long enough to hold the result.\n          P := P + 1;\n          S (P) := Character'Val (48 + V);\n       end if;"}, {"sha": "9ac9621e99c517ed5ebeae8bbe4baf4b340245a1", "filename": "gcc/ada/libgnat/s-imgwiu.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imgwiu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d9f29d52e134c02fafee222be655189d9050f2/gcc%2Fada%2Flibgnat%2Fs-imgwiu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgwiu.adb?ref=d0d9f29d52e134c02fafee222be655189d9050f2", "patch": "@@ -102,9 +102,17 @@ package body System.Img_WIU is\n       begin\n          if T >= 10 then\n             Set_Digits (T / 10);\n+            pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                           P < Natural'Last);\n+            --  No check is done since, as documented in the specification,\n+            --  the caller guarantees that S is long enough to hold the result.\n             P := P + 1;\n             S (P) := Character'Val (T mod 10 + Character'Pos ('0'));\n          else\n+            pragma Assert (P >= (S'First - 1) and P < S'Last and\n+                           P < Natural'Last);\n+            --  No check is done since, as documented in the specification,\n+            --  the caller guarantees that S is long enough to hold the result.\n             P := P + 1;\n             S (P) := Character'Val (T + Character'Pos ('0'));\n          end if;\n@@ -123,12 +131,19 @@ package body System.Img_WIU is\n          T := P;\n \n          while F > Start loop\n+            pragma Assert (T >= S'First and T <= S'Last and\n+                           F >= S'First and F <= S'Last);\n+            --  No check is done since, as documented in the specification,\n+            --  the caller guarantees that S is long enough to hold the result.\n             S (T) := S (F);\n             T := T - 1;\n             F := F - 1;\n          end loop;\n \n          for J in Start + 1 .. T loop\n+            pragma Assert (J >= S'First and J <= S'Last);\n+            --  No check is done since, as documented in the specification,\n+            --  the caller guarantees that S is long enough to hold the result.\n             S (J) := ' ';\n          end loop;\n       end if;"}]}