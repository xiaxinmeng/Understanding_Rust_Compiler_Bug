{"sha": "3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZhM2M0YmQ1ZGRhYzhiNDVmNTlkZWU0YzM1NDAwYzJhNTczOWU5ZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-10-15T23:59:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-10-15T23:59:23Z"}, "message": "decl.c (reshape_init): Fix typo.\n\n\t* decl.c (reshape_init): Fix typo.\n\n\t* cp-tree.h (operator_name_info_t): Add arity.\n\t* lex.c (init_operators): Initialize it.\n\t* mangle.c (write_conversion_operator_name): New function.\n\t(write_unqualified_name): Use it.\n\t(write_template_args): Accept template arguments as a TREE_LIST.\n\t(write_expression): Adjust handling of qualified names to match\n\tspecification.\n\n\t* g++.dg/init/array6.C: New test.\n\n\t* g++.dg/abi/mangle13.C: Likewise.\n\t* g++.dg/abi/mangle14.C: Likewise.\n\t* g++.dg/abi/mangle15.C: Likewise.\n\nFrom-SVN: r58185", "tree": {"sha": "0134f16c7bc733a94804996062fde94ce3d4b0f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0134f16c7bc733a94804996062fde94ce3d4b0f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/comments", "author": null, "committer": null, "parents": [{"sha": "c15c18c5815a10afc6057038d2a50053083a5491", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c15c18c5815a10afc6057038d2a50053083a5491", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c15c18c5815a10afc6057038d2a50053083a5491"}], "stats": {"total": 218, "additions": 198, "deletions": 20}, "files": [{"sha": "c529abbb3236aafb469713fc22af7bf9cb12c56d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e", "patch": "@@ -1,3 +1,15 @@\n+2002-10-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* decl.c (reshape_init): Fix typo.\n+\n+\t* cp-tree.h (operator_name_info_t): Add arity.\n+\t* lex.c (init_operators): Initialize it.\n+\t* mangle.c (write_conversion_operator_name): New function.\n+\t(write_unqualified_name): Use it.\n+\t(write_template_args): Accept template arguments as a TREE_LIST.\n+\t(write_expression): Adjust handling of qualified names to match\n+\tspecification.\n+\n 2002-10-15  Jason Merrill  <jason@redhat.com>\n \n \t* call.c (call_builtin_trap): New fn."}, {"sha": "52f921cab84163e94880399896b3dc4e443e94f2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e", "patch": "@@ -3481,6 +3481,8 @@ typedef struct operator_name_info_t\n   const char *name;\n   /* The mangled name of the operator.  */\n   const char *mangled_name;\n+  /* The arity of the operator.  */\n+  int arity;\n } operator_name_info_t;\n \n /* A mapping from tree codes to operator name information.  */"}, {"sha": "70d5d318f3374698d0488fd2a77957a76aa6d1f7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e", "patch": "@@ -7836,7 +7836,7 @@ reshape_init (tree type, tree *initp)\n       return old_init;\n     }\n \n-  if (TREE_CODE (old_init) == STRING_CST\n+  if (TREE_CODE (old_init_value) == STRING_CST\n       && TREE_CODE (type) == ARRAY_TYPE\n       && char_type_p (TREE_TYPE (type)))\n     {"}, {"sha": "4558940d6751a5babd58cb355ad3179c1ec3e96b", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e", "patch": "@@ -263,7 +263,8 @@ init_operators ()\n \t : &operator_name_info[(int) CODE]);\t\t\t\t    \\\n   oni->identifier = identifier;\t\t\t\t\t\t    \\\n   oni->name = NAME;\t\t\t\t\t\t\t    \\\n-  oni->mangled_name = MANGLING;\n+  oni->mangled_name = MANGLING;                                             \\\n+  oni->arity = ARITY;\n \n #include \"operators.def\"\n #undef DEF_OPERATOR"}, {"sha": "642bc735d643f4b0957b4e4badf63fd69b2441a7", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 115, "deletions": 17, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e", "patch": "@@ -166,6 +166,7 @@ static void write_nested_name PARAMS ((tree));\n static void write_prefix PARAMS ((tree));\n static void write_template_prefix PARAMS ((tree));\n static void write_unqualified_name PARAMS ((tree));\n+static void write_conversion_operator_name (tree);\n static void write_source_name PARAMS ((tree));\n static int hwint_to_ascii PARAMS ((unsigned HOST_WIDE_INT, unsigned int, char *, unsigned));\n static void write_number PARAMS ((unsigned HOST_WIDE_INT, int,\n@@ -1016,8 +1017,7 @@ write_unqualified_name (decl)\n \t}\n       else\n \ttype = TREE_TYPE (DECL_NAME (decl));\n-      write_string (\"cv\");\n-      write_type (type);\n+      write_conversion_operator_name (type);\n     }\n   else if (DECL_OVERLOADED_OPERATOR_P (decl))\n     {\n@@ -1033,6 +1033,15 @@ write_unqualified_name (decl)\n     write_source_name (DECL_NAME (decl));\n }\n \n+/* Write the unqualified-name for a conversion operator to TYPE.  */\n+\n+static void\n+write_conversion_operator_name (tree type)\n+{\n+  write_string (\"cv\");\n+  write_type (type);\n+}\n+\n /* Non-termial <source-name>.  IDENTIFIER is an IDENTIFIER_NODE.  \n \n      <source-name> ::= </length/ number> <identifier>  */\n@@ -1780,24 +1789,37 @@ static void\n write_template_args (args)\n      tree args;\n {\n-  int i;\n-  int length = TREE_VEC_LENGTH (args);\n-\n   MANGLE_TRACE_TREE (\"template-args\", args);\n \n-  my_friendly_assert (length > 0, 20000422);\n+  write_char ('I');\n \n-  if (TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+  if (TREE_CODE (args) == TREE_VEC)\n     {\n-      /* We have nested template args.  We want the innermost template\n-\t argument list.  */\n-      args = TREE_VEC_ELT (args, length - 1);\n-      length = TREE_VEC_LENGTH (args);\n+      int i;\n+      int length = TREE_VEC_LENGTH (args);\n+      my_friendly_assert (length > 0, 20000422);\n+\n+      if (TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+\t{\n+\t  /* We have nested template args.  We want the innermost template\n+\t     argument list.  */\n+\t  args = TREE_VEC_ELT (args, length - 1);\n+\t  length = TREE_VEC_LENGTH (args);\n+\t}\n+      for (i = 0; i < length; ++i)\n+\twrite_template_arg (TREE_VEC_ELT (args, i));\n+    }\n+  else \n+    {\n+      my_friendly_assert (TREE_CODE (args) == TREE_LIST, 20021014);\n+\n+      while (args)\n+\t{\n+\t  write_template_arg (TREE_VALUE (args));\n+\t  args = TREE_CHAIN (args);\n+\t}\n     }\n \n-  write_char ('I');\n-  for (i = 0; i < length; ++i)\n-    write_template_arg (TREE_VEC_ELT (args, i));\n   write_char ('E');\n }\n \n@@ -1807,7 +1829,9 @@ write_template_args (args)\n \n    <expr-primary> ::= <template-param>\n \t\t  ::= L <type> <value number> E  # literal\n-\t\t  ::= L <mangled-name> E         # external name  */\n+\t\t  ::= L <mangled-name> E         # external name  \n+                  ::= sr <type> <unqualified-name>\n+                  ::= sr <type> <unqualified-name> <template-args> */\n \n static void\n write_expression (expr)\n@@ -1859,6 +1883,75 @@ write_expression (expr)\n       write_string (\"st\");\n       write_type (TREE_OPERAND (expr, 0));\n     }\n+  else if (abi_version_at_least (2) && TREE_CODE (expr) == SCOPE_REF)\n+    {\n+      tree scope = TREE_OPERAND (expr, 0);\n+      tree member = TREE_OPERAND (expr, 1);\n+\n+      /* If the MEMBER is a real declaration, then the qualifying\n+\t scope was not dependent.  Ideally, we would not have a\n+\t SCOPE_REF in those cases, but sometimes we do.  If the second\n+\t argument is a DECL, then the name must not have been\n+\t dependent.  */\n+      if (DECL_P (member))\n+\twrite_expression (member);\n+      else\n+\t{\n+\t  tree template_args;\n+\n+\t  write_string (\"sr\");\n+\t  write_type (scope);\n+\t  /* If MEMBER is a template-id, separate the template\n+\t     from the arguments.  */\n+\t  if (TREE_CODE (member) == TEMPLATE_ID_EXPR)\n+\t    {\n+\t      template_args = TREE_OPERAND (member, 1);\n+\t      member = TREE_OPERAND (member, 0);\n+\t      if (TREE_CODE (member) == LOOKUP_EXPR)\n+\t\tmember = TREE_OPERAND (member, 0);\n+\t    }\n+\t  else\n+\t    template_args = NULL_TREE;\n+\t  /* Write out the name of the MEMBER.  */\n+\t  if (IDENTIFIER_TYPENAME_P (member))\n+\t    write_conversion_operator_name (TREE_TYPE (member));\n+\t  else if (IDENTIFIER_OPNAME_P (member))\n+\t    {\n+\t      int i;\n+\t      const char *mangled_name = NULL;\n+\n+\t      /* Unfortunately, there is no easy way to go from the\n+\t\t name of the operator back to the corresponding tree\n+\t\t code.  */\n+\t      for (i = 0; i < LAST_CPLUS_TREE_CODE; ++i)\n+\t\tif (operator_name_info[i].identifier == member)\n+\t\t  {\n+\t\t    /* The ABI says that we prefer binary operator\n+\t\t       names to unary operator names.  */\n+\t\t    if (operator_name_info[i].arity == 2)\n+\t\t      {\n+\t\t\tmangled_name = operator_name_info[i].mangled_name;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    else if (!mangled_name)\n+\t\t      mangled_name = operator_name_info[i].mangled_name;\n+\t\t  }\n+\t\telse if (assignment_operator_name_info[i].identifier\n+\t\t\t == member)\n+\t\t  {\n+\t\t    mangled_name \n+\t\t      = assignment_operator_name_info[i].mangled_name;\n+\t\t    break;\n+\t\t  }\n+\t      write_string (mangled_name);\n+\t    }\n+\t  else\n+\t    write_source_name (member);\n+\t  /* Write out the template arguments.  */\n+\t  if (template_args)\n+\t    write_template_args (template_args);\n+\t}\n+    }\n   else\n     {\n       int i;\n@@ -1880,7 +1973,7 @@ write_expression (expr)\n \n \t  code = TREE_CODE (expr);\n \t}\n-      \n+\n       /* If it wasn't any of those, recursively expand the expression.  */\n       write_string (operator_name_info[(int) code].mangled_name);\n \n@@ -1904,7 +1997,12 @@ write_expression (expr)\n \t  if (TREE_CODE (TREE_OPERAND (expr, 1)) == IDENTIFIER_NODE)\n \t    write_source_name (TREE_OPERAND (expr, 1));\n \t  else\n-\t    write_encoding (TREE_OPERAND (expr, 1));\n+\t    {\n+\t      /* G++ 3.2 incorrectly put out both the \"sr\" code and\n+\t\t the nested name of the qualified name.  */\n+\t      G.need_abi_warning = 1;\n+\t      write_encoding (TREE_OPERAND (expr, 1));\n+\t    }\n \t  break;\n \n \tdefault:"}, {"sha": "50f478fc58638b005321aa8ecda78bebf3955b0c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e", "patch": "@@ -1,7 +1,15 @@\n+2002-10-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/init/array6.C: New test.\n+\t\n+\t* g++.dg/abi/mangle13.C: Likewise.\n+\t* g++.dg/abi/mangle14.C: Likewise.\n+\t* g++.dg/abi/mangle15.C: Likewise.\n+\n 2002-10-14  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/abi/empty8.C: New test.\n-\n+\t\n 2002-10-15  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/init/ctor1.C: New test."}, {"sha": "716c4c36f410901dc2620ea5a317f84feca18fe2", "filename": "gcc/testsuite/g++.dg/abi/mangle13.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle13.C?ref=3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e", "patch": "@@ -0,0 +1,28 @@\n+// { dg-options \"-fabi-version=0\" }\n+\n+struct A {\n+  template <typename T> int f ();\n+  int operator+();\n+  operator int ();\n+  template <typename T> \n+  int operator-();\n+};\n+\n+typedef int (A::*P)();\n+\n+template <P> struct S {};\n+\n+template <typename T> void g (S<&T::template f<int> >) {}\n+template <typename T> void g (S<&T::operator+ >) {}\n+template <typename T> void g (S<&T::operator int>) {}\n+template <typename T> void g (S<&T::template operator- <double> >) {}\n+\n+template void g<A> (S<&A::f<int> >);\n+template void g<A> (S<&A::operator+>);\n+template void g<A> (S<&A::operator int>);\n+template void g<A> (S<&A::operator-<double> >);\n+\n+// { dg-final { scan-assembler _Z1gI1AEv1SIXadsrT_1fIiEEE } }\n+// { dg-final { scan-assembler _Z1gI1AEv1SIXadsrT_plEE } }\n+// { dg-final { scan-assembler _Z1gI1AEv1SIXadsrT_cviEE } }\n+// { dg-final { scan-assembler _Z1gI1AEv1SIXadsrT_miIdEEE } }"}, {"sha": "8e2bfddde76aeba857f0b6232d0fbd59ad88ba9f", "filename": "gcc/testsuite/g++.dg/abi/mangle14.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle14.C?ref=3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile }\n+// { dg-options \"-Wabi\" }\n+\n+struct A {\n+  template <typename T> int f ();\n+};\n+\n+typedef int (A::*P)();\n+\n+template <P> struct S {};\n+\n+void g (S<&A::f<int> >) {} // { dg-warning \"mangle\" }"}, {"sha": "3c112e263f07c48f0ffb0b646fd4cdbec6d8f692", "filename": "gcc/testsuite/g++.dg/abi/mangle15.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle15.C?ref=3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile }\n+// { dg-options \"-fabi-version=0\" }\n+\n+struct A {\n+  template <typename T> int f ();\n+};\n+\n+typedef int (A::*P)();\n+\n+template <P> struct S {};\n+\n+void g (S<&A::f<int> >) {}\n+\n+// { dg-final { scan-assembler _Z1g1SIXadL_ZN1A1fIiEEivEEE } }"}, {"sha": "1b04709cb92e44088198572b0bc47d45acc24726", "filename": "gcc/testsuite/g++.dg/init/array6.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray6.C?ref=3fa3c4bd5ddac8b45f59dee4c35400c2a5739e9e", "patch": "@@ -0,0 +1,3 @@\n+// { dg-do compile }\n+\n+char arr [][4] = { \"one\", \"two\" };"}]}