{"sha": "867c8b03ffc45fee45b414d511ccf125ca5a8c4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY3YzhiMDNmZmM0NWZlZTQ1YjQxNGQ1MTFjY2YxMjVjYTVhOGM0Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-11-18T22:04:48Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-11-18T22:04:48Z"}, "message": "libgcov-driver.c (get_gcov_dump_complete): Update comments.\n\n\t* libgcov-driver.c (get_gcov_dump_complete): Update comments.\n\t(all_prg, crc32): Remove static vars.\n\t(gcov_exit_compute_summary): Rewrite to return crc32; do not clear\n\tall_prg.\n\t(gcov_exit_merge_gcda): Add crc32 parameter.\n\t(gcov_exit_merge_summary): Add crc32 and all_prg parameter;\n\tdo not account run if it was already accounted.\n\t(gcov_exit_dump_gcov): Add crc32 and all_prg parameters.\n\t(gcov_exit): Initialize all_prg; update.\n\nFrom-SVN: r204983", "tree": {"sha": "6680f4897b5aad3d438e5a609b5928438629d868", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6680f4897b5aad3d438e5a609b5928438629d868"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/867c8b03ffc45fee45b414d511ccf125ca5a8c4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/867c8b03ffc45fee45b414d511ccf125ca5a8c4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/867c8b03ffc45fee45b414d511ccf125ca5a8c4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/867c8b03ffc45fee45b414d511ccf125ca5a8c4c/comments", "author": null, "committer": null, "parents": [{"sha": "2c2af141b47cc2b19efad70e4c0be41eb82029fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c2af141b47cc2b19efad70e4c0be41eb82029fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c2af141b47cc2b19efad70e4c0be41eb82029fb"}], "stats": {"total": 80, "additions": 51, "deletions": 29}, "files": [{"sha": "792031dc9d956e2889a629f22e653c2569773e88", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/867c8b03ffc45fee45b414d511ccf125ca5a8c4c/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/867c8b03ffc45fee45b414d511ccf125ca5a8c4c/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=867c8b03ffc45fee45b414d511ccf125ca5a8c4c", "patch": "@@ -1,3 +1,15 @@\n+2013-11-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* libgcov-driver.c (get_gcov_dump_complete): Update comments.\n+\t(all_prg, crc32): Remove static vars.\n+\t(gcov_exit_compute_summary): Rewrite to return crc32; do not clear\n+\tall_prg.\n+\t(gcov_exit_merge_gcda): Add crc32 parameter.\n+\t(gcov_exit_merge_summary): Add crc32 and all_prg parameter;\n+\tdo not account run if it was already accounted.\n+\t(gcov_exit_dump_gcov): Add crc32 and all_prg parameters.\n+\t(gcov_exit): Initialize all_prg; update.\n+\n 2013-11-15  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* configure: Regenerate."}, {"sha": "9d527cd93e31ee29fcfa279b5a2119315408a9db", "filename": "libgcc/libgcov-driver.c", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/867c8b03ffc45fee45b414d511ccf125ca5a8c4c/libgcc%2Flibgcov-driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/867c8b03ffc45fee45b414d511ccf125ca5a8c4c/libgcc%2Flibgcov-driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver.c?ref=867c8b03ffc45fee45b414d511ccf125ca5a8c4c", "patch": "@@ -96,7 +96,7 @@ static size_t gcov_max_filename = 0;\n /* Flag when the profile has already been dumped via __gcov_dump().  */\n static int gcov_dump_complete;\n \n-/* A global functino that get the vaule of gcov_dump_complete.  */\n+/* A global function that get the vaule of gcov_dump_complete.  */\n \n int\n get_gcov_dump_complete (void)\n@@ -319,12 +319,6 @@ gcov_compute_histogram (struct gcov_summary *sum)\n \n /* summary for program.  */\n static struct gcov_summary this_prg;\n-#if !GCOV_LOCKED\n-/* summary for all instances of program.  */\n-static struct gcov_summary all_prg;\n-#endif\n-/* crc32 for this program.  */\n-static gcov_unsigned_t crc32;\n /* gcda filename.  */\n static char *gi_filename;\n /* buffer for the fn_data from another program.  */\n@@ -333,10 +327,9 @@ static struct gcov_fn_buffer *fn_buffer;\n static struct gcov_summary_buffer *sum_buffer;\n \n /* This funtions computes the program level summary and the histo-gram.\n-   It initializes ALL_PRG, computes CRC32, and stores the summary in\n-   THIS_PRG. All these three variables are file statics.  */\n+   It computes and returns CRC32  and stored summari in THIS_PRG.  */\n \n-static void\n+static gcov_unsigned_t\n gcov_exit_compute_summary (void)\n {\n   struct gcov_info *gi_ptr;\n@@ -346,10 +339,8 @@ gcov_exit_compute_summary (void)\n   int f_ix;\n   unsigned t_ix;\n   gcov_unsigned_t c_num;\n+  gcov_unsigned_t crc32 = 0;\n \n-#if !GCOV_LOCKED\n-  memset (&all_prg, 0, sizeof (all_prg));\n-#endif\n   /* Find the totals for this execution.  */\n   memset (&this_prg, 0, sizeof (this_prg));\n   for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n@@ -391,6 +382,7 @@ gcov_exit_compute_summary (void)\n         }\n     }\n   gcov_compute_histogram (&this_prg);\n+  return crc32;\n }\n \n /* A struct that bundles all the related information about the\n@@ -412,7 +404,8 @@ static int\n gcov_exit_merge_gcda (struct gcov_info *gi_ptr,\n                       struct gcov_summary *prg_p,\n                       gcov_position_t *summary_pos_p,\n-                      gcov_position_t *eof_pos_p)\n+                      gcov_position_t *eof_pos_p,\n+\t\t      gcov_unsigned_t crc32)\n {\n   gcov_unsigned_t tag, length;\n   unsigned t_ix;\n@@ -652,13 +645,19 @@ gcov_exit_write_gcda (const struct gcov_info *gi_ptr,\n    Return -1 on error. Return 0 on success.  */\n \n static int\n-gcov_exit_merge_summary (const struct gcov_info *gi_ptr, struct gcov_summary *prg)\n+gcov_exit_merge_summary (const struct gcov_info *gi_ptr, struct gcov_summary *prg,\n+\t\t\t gcov_unsigned_t crc32, struct gcov_summary *all_prg)\n {\n   struct gcov_ctr_summary *cs_prg, *cs_tprg;\n-#if !GCOV_LOCKED\n-  struct gcov_ctr_summary *cs_all;\n-#endif\n   unsigned t_ix;\n+  /* If application calls fork or exec multiple times, we end up storing\n+     profile repeadely.  We should not account this as multiple runs or\n+     functions executed once may mistakely become cold.  */\n+  static int run_accounted = 0;\n+#if !GCOV_LOCKED \n+  /* summary for all instances of program.  */ \n+  struct gcov_ctr_summary *cs_all;\n+#endif \n \n   /* Merge the summaries.  */\n   for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n@@ -668,13 +667,18 @@ gcov_exit_merge_summary (const struct gcov_info *gi_ptr, struct gcov_summary *pr\n \n       if (gi_ptr->merge[t_ix])\n         {\n-          if (!cs_prg->runs++)\n+\t  int first = !cs_prg->runs;\n+\n+\t  if (!run_accounted)\n+\t    cs_prg->runs++;\n+\t  run_accounted = 1;\n+          if (first)\n             cs_prg->num = cs_tprg->num;\n           cs_prg->sum_all += cs_tprg->sum_all;\n           if (cs_prg->run_max < cs_tprg->run_max)\n             cs_prg->run_max = cs_tprg->run_max;\n           cs_prg->sum_max += cs_tprg->run_max;\n-          if (cs_prg->runs == 1)\n+          if (first)\n             memcpy (cs_prg->histogram, cs_tprg->histogram,\n                    sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n           else\n@@ -686,9 +690,8 @@ gcov_exit_merge_summary (const struct gcov_info *gi_ptr, struct gcov_summary *pr\n                       gi_filename);\n           return -1;\n         }\n-\n #if !GCOV_LOCKED\n-      cs_all = &all_prg.ctrs[t_ix];\n+      cs_all = &all_prg->ctrs[t_ix];\n       if (!cs_all->runs && cs_prg->runs)\n         {\n           cs_all->num = cs_prg->num;\n@@ -697,7 +700,7 @@ gcov_exit_merge_summary (const struct gcov_info *gi_ptr, struct gcov_summary *pr\n           cs_all->run_max = cs_prg->run_max;\n           cs_all->sum_max = cs_prg->sum_max;\n         }\n-      else if (!all_prg.checksum\n+      else if (!all_prg->checksum\n                /* Don't compare the histograms, which may have slight\n                   variations depending on the order they were updated\n                   due to the truncating integer divides used in the\n@@ -711,7 +714,7 @@ gcov_exit_merge_summary (const struct gcov_info *gi_ptr, struct gcov_summary *pr\n                gcov_error (\"profiling:%s:Data file mismatch - some \"\n                            \"data files may have been concurrently \"\n                            \"updated without locking support\\n\", gi_filename);\n-               all_prg.checksum = ~0u;\n+               all_prg->checksum = ~0u;\n              }\n #endif\n     }\n@@ -729,7 +732,8 @@ gcov_exit_merge_summary (const struct gcov_info *gi_ptr, struct gcov_summary *pr\n    summaries separate.  */\n \n static void\n-gcov_exit_dump_gcov (struct gcov_info *gi_ptr, struct gcov_filename_aux *gf)\n+gcov_exit_dump_gcov (struct gcov_info *gi_ptr, struct gcov_filename_aux *gf,\n+\t\t     gcov_unsigned_t crc32, struct gcov_summary *all_prg)\n {\n   struct gcov_summary prg; /* summary for this object over all program.  */\n   int error;\n@@ -753,7 +757,8 @@ gcov_exit_dump_gcov (struct gcov_info *gi_ptr, struct gcov_filename_aux *gf)\n           gcov_error (\"profiling:%s:Not a gcov data file\\n\", gi_filename);\n           goto read_fatal;\n         }\n-      error = gcov_exit_merge_gcda (gi_ptr, &prg, &summary_pos, &eof_pos);\n+      error = gcov_exit_merge_gcda (gi_ptr, &prg, &summary_pos, &eof_pos,\n+\t\t\t\t    crc32);\n       if (error == -1)\n         goto read_fatal;\n     }\n@@ -766,7 +771,7 @@ gcov_exit_dump_gcov (struct gcov_info *gi_ptr, struct gcov_filename_aux *gf)\n       summary_pos = eof_pos;\n     }\n \n-  error = gcov_exit_merge_summary (gi_ptr, &prg);\n+  error = gcov_exit_merge_summary (gi_ptr, &prg, crc32, all_prg);\n   if (error == -1)\n     goto read_fatal;\n \n@@ -794,19 +799,24 @@ gcov_exit (void)\n {\n   struct gcov_info *gi_ptr;\n   struct gcov_filename_aux gf;\n+  gcov_unsigned_t crc32;\n+  struct gcov_summary all_prg;\n \n   /* Prevent the counters from being dumped a second time on exit when the\n      application already wrote out the profile using __gcov_dump().  */\n   if (gcov_dump_complete)\n     return;\n \n-  gcov_exit_compute_summary ();\n+  crc32 = gcov_exit_compute_summary ();\n \n   allocate_filename_struct (&gf);\n+#if !GCOV_LOCKED\n+  memset (&all_prg, 0, sizeof (all_prg));\n+#endif\n \n   /* Now merge each file.  */\n   for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n-    gcov_exit_dump_gcov (gi_ptr, &gf);\n+    gcov_exit_dump_gcov (gi_ptr, &gf, crc32, &all_prg);\n \n   if (gi_filename)\n     free (gi_filename);"}]}