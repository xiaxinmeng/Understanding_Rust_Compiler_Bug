{"sha": "8aeea6e67d77adc1a5e1575e4543d4259295be39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFlZWE2ZTY3ZDc3YWRjMWE1ZTE1NzVlNDU0M2Q0MjU5Mjk1YmUzOQ==", "commit": {"author": {"name": "Lars Brinkhoff", "email": "lars@nocrew.org", "date": "2001-08-03T01:19:20Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2001-08-03T01:19:20Z"}, "message": "combine.c, [...]: consistently use \"VAX\", \"VAXen\", and \"MicroVAX\" in comments and documentation.\n\n\t* combine.c, config.gcc, cse.c, defaults.h, real.c, reload.c,\n\tsimplify-rtx.c, config/alpha/alpha.h, config/avr/avr.h,\n\tconfig/convex/convex.h, config/d30v/d30v.c,\n\tconfig/d30v/d30v.h, config/dsp16xx/dsp16xx.h,\n\tconfig/elxsi/elxsi.h, config/fr30/fr30.h, config/m88k/m88k.c,\n\tconfig/mips/mips.h, config/mn10200/mn10200.h,\n\tconfig/mn10300/mn10300.h, config/pdp11/pdp11.md,\n\tconfig/v850/v850.h, config/vax/openbsd.h,\n\tconfig/vax/openbsd1.h, config/vax/ultrix.h,\n\tconfig/vax/vax-protos.h, config/vax/vax.c, config/vax/vax.h,\n\tconfig/vax/vax.md, config/vax/vaxv.h, config/vax/xm-vms.h,\n\tcp/decl2.c, doc/contrib.texi, doc/cpp.texi, doc/gcc.texi,\n\tdoc/install.texi, doc/invoke.texi, doc/md.texi, doc/rtl.texi,\n\tdoc/tm.texi: consistently use \"VAX\", \"VAXen\", and \"MicroVAX\"\n        in comments and documentation.\n\nFrom-SVN: r44589", "tree": {"sha": "84a4044443510c1b5b0e3a9c9f61f35ed627660b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84a4044443510c1b5b0e3a9c9f61f35ed627660b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8aeea6e67d77adc1a5e1575e4543d4259295be39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aeea6e67d77adc1a5e1575e4543d4259295be39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aeea6e67d77adc1a5e1575e4543d4259295be39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aeea6e67d77adc1a5e1575e4543d4259295be39/comments", "author": {"login": "larsbrinkhoff", "id": 775050, "node_id": "MDQ6VXNlcjc3NTA1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/775050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/larsbrinkhoff", "html_url": "https://github.com/larsbrinkhoff", "followers_url": "https://api.github.com/users/larsbrinkhoff/followers", "following_url": "https://api.github.com/users/larsbrinkhoff/following{/other_user}", "gists_url": "https://api.github.com/users/larsbrinkhoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/larsbrinkhoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/larsbrinkhoff/subscriptions", "organizations_url": "https://api.github.com/users/larsbrinkhoff/orgs", "repos_url": "https://api.github.com/users/larsbrinkhoff/repos", "events_url": "https://api.github.com/users/larsbrinkhoff/events{/privacy}", "received_events_url": "https://api.github.com/users/larsbrinkhoff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "36e10d77f212d88ecc4f97fff8636cdb744c0cb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36e10d77f212d88ecc4f97fff8636cdb744c0cb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36e10d77f212d88ecc4f97fff8636cdb744c0cb9"}], "stats": {"total": 236, "additions": 127, "deletions": 109}, "files": [{"sha": "8acdf1a51a02dd789b0a6f10a52fd4c832eb581e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1,3 +1,21 @@\n+2001-08-02  Lars Brinkhoff  <lars@nocrew.org>\n+\n+\t* combine.c, config.gcc, cse.c, defaults.h, real.c, reload.c,\n+\tsimplify-rtx.c, config/alpha/alpha.h, config/avr/avr.h,\n+\tconfig/convex/convex.h, config/d30v/d30v.c,\n+\tconfig/d30v/d30v.h, config/dsp16xx/dsp16xx.h,\n+\tconfig/elxsi/elxsi.h, config/fr30/fr30.h, config/m88k/m88k.c,\n+\tconfig/mips/mips.h, config/mn10200/mn10200.h,\n+\tconfig/mn10300/mn10300.h, config/pdp11/pdp11.md,\n+\tconfig/v850/v850.h, config/vax/openbsd.h,\n+\tconfig/vax/openbsd1.h, config/vax/ultrix.h,\n+\tconfig/vax/vax-protos.h, config/vax/vax.c, config/vax/vax.h,\n+\tconfig/vax/vax.md, config/vax/vaxv.h, config/vax/xm-vms.h,\n+\tcp/decl2.c, doc/contrib.texi, doc/cpp.texi, doc/gcc.texi,\n+\tdoc/install.texi, doc/invoke.texi, doc/md.texi, doc/rtl.texi,\n+\tdoc/tm.texi: consistently use \"VAX\", \"VAXen\", and \"MicroVAX\"\n+        in comments and documentation.\n+\n 2001-08-03  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n \n \t* line-map.c: New."}, {"sha": "62ab3aa7c6e4de233bd2983406f3d75ebeca813b", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -6266,7 +6266,7 @@ extract_left_shift (x, count)\n \n    Return the new rtx, usually just X.\n \n-   Also, for machines like the Vax that don't have logical shift insns,\n+   Also, for machines like the VAX that don't have logical shift insns,\n    try to convert logical to arithmetic shift operations in cases where\n    they are equivalent.  This undoes the canonicalizations to logical\n    shifts done elsewhere.\n@@ -8954,7 +8954,7 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n       /* We simplify the tests below and elsewhere by converting\n \t ASHIFTRT to LSHIFTRT if we know the sign bit is clear.\n \t `make_compound_operation' will convert it to a ASHIFTRT for\n-\t those machines (such as Vax) that don't have a LSHIFTRT.  */\n+\t those machines (such as VAX) that don't have a LSHIFTRT.  */\n       if (GET_MODE_BITSIZE (shift_mode) <= HOST_BITS_PER_WIDE_INT\n \t  && code == ASHIFTRT\n \t  && ((nonzero_bits (varop, shift_mode)"}, {"sha": "0900fe1d43b11bcf7971515b71f87b246befbf6e", "filename": "gcc/config.gcc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -3149,11 +3149,11 @@ v850-*-*)\n \tc_target_objs=\"v850-c.o\"\n \tcxx_target_objs=\"v850-c.o\"\n \t;;\n-vax-*-bsd*)\t\t\t# vaxen running BSD\n+vax-*-bsd*)\t\t\t# VAXen running BSD\n \tuse_collect2=yes\n \tfloat_format=vax\n \t;;\n-vax-*-sysv*)\t\t\t# vaxen running system V\n+vax-*-sysv*)\t\t\t# VAXen running system V\n \ttm_file=\"${tm_file} vax/vaxv.h\"\n \txm_defines=POSIX\n \tfloat_format=vax\n@@ -3169,16 +3169,16 @@ vax-*-openbsd*)\n \tfloat_format=vax\n \tuse_collect2=yes\n \t;;\n-vax-*-ultrix*)\t\t\t# vaxen running ultrix\n+vax-*-ultrix*)\t\t\t# VAXen running ultrix\n \ttm_file=\"${tm_file} vax/ultrix.h\"\n \tfloat_format=vax\n \t;;\n-vax-*-vms*)\t\t\t# vaxen running VMS\n+vax-*-vms*)\t\t\t# VAXen running VMS\n \txm_file=vax/xm-vms.h\n \ttm_file=vax/vms.h\n \tfloat_format=vax\n \t;;\n-vax-*-*)\t\t\t# vax default entry\n+vax-*-*)\t\t\t# VAX default entry\n \tfloat_format=vax\n \t;;\n we32k-att-sysv*)"}, {"sha": "9a724edd2cf7e32b5f7a0fd48e7e1deddc1d8b76", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -2097,7 +2097,7 @@ literal_section ()\t\t\t\t\t\t\\\n \t      fprintf (asm_out_file, \"\\\\%o\", c);\t\t\t      \\\n \t      /* After an octal-escape, if a digit follows,\t\t      \\\n \t\t terminate one string constant and start another.\t      \\\n-\t\t The Vax assembler fails to stop reading the escape\t      \\\n+\t\t The VAX assembler fails to stop reading the escape\t      \\\n \t\t after three digits, so this is the only way we\t\t      \\\n \t\t can get it to parse the data properly.  */\t\t      \\\n \t      if (i < thissize - 1\t\t\t\t\t      \\"}, {"sha": "dfb588231ec20ff632b5475980a2cfdd0a0b885b", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1132,7 +1132,7 @@ enum reg_class {\n    argument popping will always be the responsibility of the calling\n    function.\n \n-   On the Vax, all functions always pop their arguments, so the\n+   On the VAX, all functions always pop their arguments, so the\n    definition of this macro is STACK-SIZE.  On the 68000, using the\n    standard calling convention, no functions pop their arguments, so\n    the value of the macro is always 0 in this case.  But an\n@@ -1157,7 +1157,7 @@ enum reg_class {\n    hard register in which to pass the argument, or zero to pass the\n    argument on the stack.\n \n-   For machines like the Vax and 68000, where normally all arguments\n+   For machines like the VAX and 68000, where normally all arguments\n    are pushed, zero suffices as a definition.\n \n    The value of the expression can also be a `parallel' RTX.  This is"}, {"sha": "c0615e41ace96fdf6abd805092a2e76f1eba7173", "filename": "gcc/config/convex/convex.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fconvex%2Fconvex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fconvex%2Fconvex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1144,11 +1144,11 @@ enum reg_class {\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n-/* Convex uses Vax or IEEE floats.\n+/* Convex uses VAX or IEEE floats.\n    Follow the host format. */\n #define TARGET_FLOAT_FORMAT HOST_FLOAT_FORMAT\n \n-/* But must prevent real.c from constructing Vax dfloats */\n+/* But must prevent real.c from constructing VAX dfloats */\n #define REAL_VALUE_ATOF(X,S) atof (X)\n \n /* Check a `double' value for validity for a particular machine mode.  */"}, {"sha": "cf5918fe9f9d1eee8edf880fc6c5ca55e2dc7a69", "filename": "gcc/config/d30v/d30v.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fd30v%2Fd30v.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fd30v%2Fd30v.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.c?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1966,7 +1966,7 @@ d30v_function_arg_boundary (mode, type)\n    register in which to pass the argument, or zero to pass the argument on the\n    stack.\n \n-   For machines like the Vax and 68000, where normally all arguments are\n+   For machines like the VAX and 68000, where normally all arguments are\n    pushed, zero suffices as a definition.\n \n    The usual way to make the ANSI library `stdarg.h' work on a machine where"}, {"sha": "5e0f0b0a02b165ccd862afae7f48143210c4e65f", "filename": "gcc/config/d30v/d30v.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -869,7 +869,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n         there is no need to define this macro when the format is IEEE.\n \n    VAX_FLOAT_FORMAT'\n-        This code indicates the peculiar format used on the Vax.\n+        This code indicates the peculiar format used on the VAX.\n \n    UNKNOWN_FLOAT_FORMAT'\n         This code indicates any other format.\n@@ -2290,7 +2290,7 @@ typedef struct d30v_stack {\n    variable number of bytes is passed, it is zero, and argument popping will\n    always be the responsibility of the calling function.\n \n-   On the Vax, all functions always pop their arguments, so the definition of\n+   On the VAX, all functions always pop their arguments, so the definition of\n    this macro is STACK-SIZE.  On the 68000, using the standard calling\n    convention, no functions pop their arguments, so the value of the macro is\n    always 0 in this case.  But an alternative calling convention is available\n@@ -2317,7 +2317,7 @@ typedef struct d30v_stack {\n    register in which to pass the argument, or zero to pass the argument on the\n    stack.\n \n-   For machines like the Vax and 68000, where normally all arguments are\n+   For machines like the VAX and 68000, where normally all arguments are\n    pushed, zero suffices as a definition.\n \n    The usual way to make the ANSI library `stdarg.h' work on a machine where"}, {"sha": "f98d6789d24ba199a58b86f53cf102fe4305d455", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1643,7 +1643,7 @@ const_section ()                                                   \\\n \t      fprintf (asm_out_file, \"%d\", c);\t\t\t              \\\n \t      /* After an octal-escape, if a digit follows,\t\t      \\\n \t\t terminate one string constant and start another.\t      \\\n-\t\t The Vax assembler fails to stop reading the escape\t      \\\n+\t\t The VAX assembler fails to stop reading the escape\t      \\\n \t\t after three digits, so this is the only way we\t\t      \\\n \t\t can get it to parse the data properly.  \t\t      \\\n \t      if (i < thissize - 1\t\t\t\t\t      \\"}, {"sha": "8d138238191915fc078c9ffd81eb06f986637c42", "filename": "gcc/config/elxsi/elxsi.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Felxsi%2Felxsi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Felxsi%2Felxsi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -62,7 +62,7 @@ extern int target_flags;\n \n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.\n-   This is not true on the vax.  */\n+   This is not true on the VAX.  */\n #define BITS_BIG_ENDIAN 0\n \n /* Define this if most significant byte of a word is the lowest numbered.  */\n@@ -151,7 +151,7 @@ extern int target_flags;\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n-   On the vax, all registers are one word long.  */\n+   On the VAX, all registers are one word long.  */\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n@@ -219,7 +219,7 @@ extern int target_flags;\n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n    \n-/* The vax has only one kind of registers, so NO_REGS and ALL_REGS\n+/* The VAX has only one kind of registers, so NO_REGS and ALL_REGS\n    are the only classes.  */\n \n enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n@@ -276,7 +276,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n-/* On the vax, this is always the size of MODE in words,\n+/* On the VAX, this is always the size of MODE in words,\n    since all registers are the same size.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n@@ -308,7 +308,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n    FUNTYPE is the data type of the function (as a tree),\n    or for a library call it is an identifier node for the subroutine name.\n \n-   On the Vax, the RET insn always pops all the args for any function.  */\n+   On the VAX, the RET insn always pops all the args for any function.  */\n \n #define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) (SIZE)\n \n@@ -317,15 +317,15 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n \n-/* On the Vax the return value is in R0 regardless.  */   \n+/* On the VAX the return value is in R0 regardless.  */   \n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n   gen_rtx_REG (TYPE_MODE (VALTYPE), 0)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-/* On the Vax the return value is in R0 regardless.  */   \n+/* On the VAX the return value is in R0 regardless.  */   \n \n #define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, 0)\n \n@@ -335,12 +335,12 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define PCC_STATIC_STRUCT_RETURN\n \n /* 1 if N is a possible register number for a function value.\n-   On the Vax, R0 is the only register thus used.  */\n+   On the VAX, R0 is the only register thus used.  */\n \n #define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n \n /* 1 if N is a possible register number for function argument passing.\n-   On the Vax, no registers are used in this way.  */\n+   On the VAX, no registers are used in this way.  */\n \n #define FUNCTION_ARG_REGNO_P(N) 0\n \f\n@@ -350,7 +350,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n    and about the args processed so far, enough to enable macros\n    such as FUNCTION_ARG to determine where the next arg should go.\n \n-   On the vax, this is a single integer, which is a number of bytes\n+   On the VAX, this is a single integer, which is a number of bytes\n    of arguments scanned so far.  */\n \n #define CUMULATIVE_ARGS int\n@@ -359,7 +359,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.\n \n-   On the vax, the offset starts at 0.  */\n+   On the VAX, the offset starts at 0.  */\n \n #define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,x,INDIRECT)\t\\\n  ((CUM) = 0)\n@@ -386,7 +386,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n-/* On the vax all args are pushed.  */   \n+/* On the VAX all args are pushed.  */   \n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n \n@@ -545,7 +545,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n    It is always safe for this macro to do nothing.  It exists to recognize\n    opportunities to optimize the output.\n \n-   For the vax, nothing needs to be done.  */\n+   For the VAX, nothing needs to be done.  */\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n \n@@ -634,7 +634,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* Tell final.c how to eliminate redundant test instructions.  */\n \n /* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  No extra ones are needed for the vax.  */\n+   (see `conditions.h').  No extra ones are needed for the VAX.  */\n \n /* Store in cc_status the expressions\n    that the condition codes will describe\n@@ -687,7 +687,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* #define DBX_DEBUGGING_INFO */\n \n /* How to renumber registers for dbx and gdb.\n-   Vax needs no change in the numeration.  */\n+   VAX needs no change in the numeration.  */\n \n #define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n \n@@ -807,7 +807,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n   fprintf (FILE, \"\\tld.32\\t%s,[.sp]\\n\\taddi.64\\t4,.sp\\n\", reg_names[REGNO])\n \n /* This is how to output an element of a case-vector that is absolute.\n-   (The Vax does not use such vectors,\n+   (The VAX does not use such vectors,\n    but we must define this macro anyway.)  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\"}, {"sha": "57d56613ee4416a1cfa630a21f51e59250a38150", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -297,7 +297,7 @@ extern int target_flags;\n         there is no need to define this macro when the format is IEEE.\n \n    VAX_FLOAT_FORMAT'\n-        This code indicates the peculiar format used on the Vax.\n+        This code indicates the peculiar format used on the VAX.\n \n    UNKNOWN_FLOAT_FORMAT'\n         This code indicates any other format.\n@@ -842,7 +842,7 @@ enum reg_class\n    variable number of bytes is passed, it is zero, and argument popping will\n    always be the responsibility of the calling function.\n \n-   On the Vax, all functions always pop their arguments, so the definition of\n+   On the VAX, all functions always pop their arguments, so the definition of\n    this macro is STACK-SIZE.  On the 68000, using the standard calling\n    convention, no functions pop their arguments, so the value of the macro is\n    always 0 in this case.  But an alternative calling convention is available"}, {"sha": "4ece2d6052e415de1fc8ac1b452ce93ecef5772d", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1653,7 +1653,7 @@ output_ascii (file, opcode, max, p, size)\n \t}\n       else if (in_escape && c >= '0' && c <= '9')\n \t{\n-\t  /* If a digit follows an octal-escape, the Vax assembler fails\n+\t  /* If a digit follows an octal-escape, the VAX assembler fails\n \t     to stop reading the escape after three digits.  Continue to\n \t     output the values as an octal-escape until a non-digit is\n \t     found.  */"}, {"sha": "0d47c087b665184479a524d608583b35c4d144fa", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -2314,7 +2314,7 @@ extern struct mips_frame_info current_frame_info;\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n-   On the vax, sp@- in a byte insn really pushes a word.  */\n+   On the VAX, sp@- in a byte insn really pushes a word.  */\n \n /* #define PUSH_ROUNDING(BYTES) 0 */\n "}, {"sha": "10b76f16cbe3b759a956e06953bfca9a86326f7e", "filename": "gcc/config/mn10200/mn10200.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -726,7 +726,7 @@ struct cum_arg { int nbytes; };\n /* Tell final.c how to eliminate redundant test instructions.  */\n \n /* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  No extra ones are needed for the vax.  */\n+   (see `conditions.h').  No extra ones are needed for the VAX.  */\n \n /* Store in cc_status the expressions\n    that the condition codes will describe"}, {"sha": "7835c0f08938b93b885f5d565a8fb8b610f277a4", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -793,7 +793,7 @@ struct cum_arg {int nbytes; };\n /* Tell final.c how to eliminate redundant test instructions.  */\n \n /* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  No extra ones are needed for the vax.  */\n+   (see `conditions.h').  No extra ones are needed for the VAX.  */\n \n /* Store in cc_status the expressions\n    that the condition codes will describe"}, {"sha": "bbc2b9bf74d9d4515a7591b3339e3bf6e8f36018", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1148,7 +1148,7 @@\n   [(set_attr \"length\" \"1,2,2,3\")])\n \n ;;;;- and instructions\n-;; Bit-and on the pdp (like on the vax) is done with a clear-bits insn.\n+;; Bit-and on the pdp (like on the VAX) is done with a clear-bits insn.\n (define_expand \"andsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(and:SI (match_operand:SI 1 \"general_operand\" \"0\")"}, {"sha": "ae7098ad2446957c4c9cdc5a9c2f04b452480666", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -975,7 +975,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Tell final.c how to eliminate redundant test instructions.  */\n \n /* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  No extra ones are needed for the vax.  */\n+   (see `conditions.h').  No extra ones are needed for the VAX.  */\n \n /* Store in cc_status the expressions\n    that the condition codes will describe"}, {"sha": "84f4c8e4bc4d5af6e789fddfcfe844031e0b32cb", "filename": "gcc/config/vax/openbsd.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fopenbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fopenbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fopenbsd.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1,4 +1,4 @@\n-/* Configuration fragment for a vax OpenBSD target.\n+/* Configuration fragment for a VAX OpenBSD target.\n    Copyright (C) 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n@@ -18,7 +18,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* Amend common OpenBSD definitions for vax target.  */\n+/* Amend common OpenBSD definitions for VAX target.  */\n \n #undef CPP_PREDEFINES\n #define CPP_PREDEFINES \"-D__unix__ -D__vax__ -D__OpenBSD__ -Asystem=unix -Asystem=OpenBSD -Acpu=vax -Amachine=vax\""}, {"sha": "3a72ef8804930b28087a43fe4d27405a9bc4782a", "filename": "gcc/config/vax/openbsd1.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fopenbsd1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fopenbsd1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fopenbsd1.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1,4 +1,4 @@\n-/* Configuration fragment for a vax OpenBSD target.\n+/* Configuration fragment for a VAX OpenBSD target.\n    Copyright (C) 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC."}, {"sha": "0be135c4c4d3b47754db9f11d7b85f0fb4ca6813", "filename": "gcc/config/vax/ultrix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fultrix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fultrix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fultrix.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -22,7 +22,7 @@ Boston, MA 02111-1307, USA.  */\n #define CPP_PREDEFINES \" -Dvax -Dunix -Dultrix -Dbsd4_2 -D__vax -D__unix -D__ultrix -D__bsd4_2 -Asystem=unix -Asystem=bsd -Acpu=vax -Amachine=vax\"\n \n /* These are as defined in /usr/include/sys/stdtypes.h.\n-   These values are for ultrix 4.2 on the vax.  */\n+   These values are for ultrix 4.2 on the VAX.  */\n #define SIZE_TYPE \"unsigned int\"\n #define PTRDIFF_TYPE \"int\"\n #define WCHAR_TYPE \"unsigned int\""}, {"sha": "a149838100199d7ae5ee36d8d88da19a7d784f6e", "filename": "gcc/config/vax/vax-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-protos.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1,4 +1,4 @@\n-/* Definitions of target machine for GNU compiler.  Vax version.\n+/* Definitions of target machine for GNU compiler.  VAX version.\n    Copyright (C) 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC."}, {"sha": "e8a13dcb7f44ad8f93f5aa15287e2c310b2812d0", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1,4 +1,4 @@\n-/* Subroutines for insn-output.c for Vax.\n+/* Subroutines for insn-output.c for VAX.\n    Copyright (C) 1987, 1994, 1995, 1997, 1998, 1999, 2000\n    Free Software Foundation, Inc.\n "}, {"sha": "903e627840aaa4d1e2bc0926de077edbc039c118", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1,4 +1,4 @@\n-/* Definitions of target machine for GNU compiler.  Vax version.\n+/* Definitions of target machine for GNU compiler.  VAX version.\n    Copyright (C) 1987, 1988, 1991, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000, 2001 Free Software Foundation, Inc.\n \n@@ -95,16 +95,16 @@ extern int target_flags;\n \n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.\n-   This is not true on the vax.  */\n+   This is not true on the VAX.  */\n #define BITS_BIG_ENDIAN 0\n \n /* Define this if most significant byte of a word is the lowest numbered.  */\n-/* That is not true on the vax.  */\n+/* That is not true on the VAX.  */\n #define BYTES_BIG_ENDIAN 0\n \n /* Define this if most significant word of a multiword number is the lowest\n    numbered.  */\n-/* This is not true on the vax.  */\n+/* This is not true on the VAX.  */\n #define WORDS_BIG_ENDIAN 0\n \n /* Number of bits in an addressable storage unit */\n@@ -166,7 +166,7 @@ extern int target_flags;\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n-   On the vax, these are the AP, FP, SP and PC.  */\n+   On the VAX, these are the AP, FP, SP and PC.  */\n #define FIXED_REGISTERS {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1}\n \n /* 1 for registers not available across function calls.\n@@ -181,12 +181,12 @@ extern int target_flags;\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n-   On the vax, all registers are one word long.  */\n+   On the VAX, all registers are one word long.  */\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the vax, all registers can hold all modes.  */\n+   On the VAX, all registers can hold all modes.  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n@@ -198,7 +198,7 @@ extern int target_flags;\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n \n-/* Vax pc is overloaded on a register.  */\n+/* VAX pc is overloaded on a register.  */\n #define PC_REGNUM 15\n \n /* Register to use for pushing function arguments.  */\n@@ -243,7 +243,7 @@ extern int target_flags;\n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n    \n-/* The vax has only one kind of registers, so NO_REGS and ALL_REGS\n+/* The VAX has only one kind of registers, so NO_REGS and ALL_REGS\n    are the only classes.  */\n \n enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n@@ -323,7 +323,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n-/* On the vax, this is always the size of MODE in words,\n+/* On the VAX, this is always the size of MODE in words,\n    since all registers are the same size.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n@@ -357,7 +357,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n-   On the vax, -(sp) pushes only the bytes of the operands.  */\n+   On the VAX, -(sp) pushes only the bytes of the operands.  */\n #define PUSH_ROUNDING(BYTES) (BYTES)\n \n /* Offset of first parameter from the argument pointer register value.  */\n@@ -370,7 +370,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    or for a library call it is an identifier node for the subroutine name.\n    SIZE is the number of bytes of arguments passed on the stack.\n \n-   On the Vax, the RET insn pops a maximum of 255 args for any function.  */\n+   On the VAX, the RET insn pops a maximum of 255 args for any function.  */\n \n #define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) \\\n   ((SIZE) > 255*4 ? 0 : (SIZE))\n@@ -380,15 +380,15 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n \n-/* On the Vax the return value is in R0 regardless.  */   \n+/* On the VAX the return value is in R0 regardless.  */   \n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n   gen_rtx_REG (TYPE_MODE (VALTYPE), 0)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-/* On the Vax the return value is in R0 regardless.  */   \n+/* On the VAX the return value is in R0 regardless.  */   \n \n #define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, 0)\n \n@@ -398,12 +398,12 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define PCC_STATIC_STRUCT_RETURN\n \n /* 1 if N is a possible register number for a function value.\n-   On the Vax, R0 is the only register thus used.  */\n+   On the VAX, R0 is the only register thus used.  */\n \n #define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n \n /* 1 if N is a possible register number for function argument passing.\n-   On the Vax, no registers are used in this way.  */\n+   On the VAX, no registers are used in this way.  */\n \n #define FUNCTION_ARG_REGNO_P(N) 0\n \f\n@@ -413,7 +413,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    and about the args processed so far, enough to enable macros\n    such as FUNCTION_ARG to determine where the next arg should go.\n \n-   On the vax, this is a single integer, which is a number of bytes\n+   On the VAX, this is a single integer, which is a number of bytes\n    of arguments scanned so far.  */\n \n #define CUMULATIVE_ARGS int\n@@ -422,7 +422,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.\n \n-   On the vax, the offset starts at 0.  */\n+   On the VAX, the offset starts at 0.  */\n \n #define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n  ((CUM) = 0)\n@@ -449,7 +449,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n-/* On the vax all args are pushed.  */   \n+/* On the VAX all args are pushed.  */   \n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n \n@@ -491,15 +491,15 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    as of the start of the function body.  This depends on the layout\n    of the fixed parts of the stack frame and on how registers are saved.\n \n-   On the Vax, FRAME_POINTER_REQUIRED is always 1, so the definition of this\n+   On the VAX, FRAME_POINTER_REQUIRED is always 1, so the definition of this\n    macro doesn't matter.  But it must be defined.  */\n \n #define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = 0;\n \n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.  */\n \n-/* On the vax, the trampoline contains an entry mask and two instructions:\n+/* On the VAX, the trampoline contains an entry mask and two instructions:\n      .word NN\n      movl $STATIC,r0   (store the functions static chain)\n      jmp  *$FUNCTION   (jump to function code at address FUNCTION)  */\n@@ -767,7 +767,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    It is always safe for this macro to do nothing.  It exists to recognize\n    opportunities to optimize the output.\n \n-   For the vax, nothing needs to be done.  */\n+   For the VAX, nothing needs to be done.  */\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n \n@@ -835,7 +835,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n \n /* When a prototype says `char' or `short', really pass an `int'.\n-   (On the vax, this is required for system-library compatibility.)  */\n+   (On the VAX, this is required for system-library compatibility.)  */\n #define PROMOTE_PROTOTYPES 1\n \n /* Specify the machine mode that pointers have.\n@@ -942,7 +942,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* Tell final.c how to eliminate redundant test instructions.  */\n \n /* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  No extra ones are needed for the vax.  */\n+   (see `conditions.h').  No extra ones are needed for the VAX.  */\n \n /* Store in cc_status the expressions\n    that the condition codes will describe\n@@ -1056,7 +1056,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define DBX_DEBUGGING_INFO\n \n /* How to renumber registers for dbx and gdb.\n-   Vax needs no change in the numeration.  */\n+   VAX needs no change in the numeration.  */\n \n #define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n \n@@ -1077,7 +1077,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* Output the .stabs for a C `static' variable in the data section.  */\n #define DBX_STATIC_STAB_DATA_SECTION\n \n-/* Vax specific: which type character is used for type double?  */\n+/* VAX specific: which type character is used for type double?  */\n \n #define ASM_DOUBLE_CHAR (TARGET_G_FLOAT ? 'g' : 'd')\n \n@@ -1165,7 +1165,7 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\tmovl (sp)+,%s\\n\", reg_names[REGNO])\n \n /* This is how to output an element of a case-vector that is absolute.\n-   (The Vax does not use such vectors,\n+   (The VAX does not use such vectors,\n    but we must define this macro anyway.)  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n@@ -1247,7 +1247,7 @@ VAX operand formatting codes:\n    h\tthe low 16 bits of a negated constant operand\n    #\t'd' or 'g' depending on whether dfloat or gfloat is used  */\n \n-/* The purpose of D is to get around a quirk or bug in vax assembler\n+/* The purpose of D is to get around a quirk or bug in VAX assembler\n    whereby -1 in a 64-bit immediate operand means 0x00000000ffffffff,\n    which is not a 64-bit minus one.  */\n "}, {"sha": "efff55aa59e4671e8809eafd823e84dd7caabc42", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1,4 +1,4 @@\n-;; Machine description for GNU compiler, Vax Version\n+;; Machine description for GNU compiler, VAX Version\n ;; Copyright (C) 1987, 1988, 1991, 1994, 1995, 1996, 1998, 1999, 2000, 2001\n ;; Free Software Foundation, Inc.\n \n@@ -122,7 +122,7 @@\n   \"\"\n   \"bitb %0,%1\")\n \n-;; The vax has no sCOND insns.  It does have add/subtract with carry\n+;; The VAX has no sCOND insns.  It does have add/subtract with carry\n ;; which could be used to implement the sltu and sgeu patterns.  However,\n ;; to do this properly requires a complete rewrite of the compare insns\n ;; to keep them together with the sltu/sgeu insns until after the\n@@ -146,7 +146,7 @@\n    clrf %0\n    movf %1,%0\")\n \n-;; Some vaxes don't support this instruction.\n+;; Some VAXen don't support this instruction.\n ;;(define_insn \"movti\"\n ;;  [(set (match_operand:TI 0 \"general_operand\" \"=g\")\n ;;\t(match_operand:TI 1 \"general_operand\" \"g\"))]\n@@ -161,7 +161,7 @@\n    clrq %0\n    movq %D1,%0\")\n \n-;; The VAX move instructions have space-time tradeoffs.  On a microVAX\n+;; The VAX move instructions have space-time tradeoffs.  On a MicroVAX\n ;; register-register mov instructions take 3 bytes and 2 CPU cycles.  clrl\n ;; takes 2 bytes and 3 cycles.  mov from constant to register takes 2 cycles\n ;; if the constant is smaller than 4 bytes, 3 cycles for a longword\n@@ -525,7 +525,7 @@\n    but it not faster on other models.\n \n    \"movab #(r1),r2\" is usually shorter than \"addl3 #,r1,r2\", and is\n-   faster on a VAX 3, but some VAXes (e.g. VAX 9000) will stall if\n+   faster on a VAX 3, but some VAXen (e.g. VAX 9000) will stall if\n    a register is used in an address too soon after it is set.\n    Compromise by using movab only when it is shorter than the add\n    or the base register in the address is one of sp, ap, and fp,\n@@ -920,7 +920,7 @@\n ;  \"\"\n ;  \"ediv %2,%1,%0,%3\")\n \f\n-;; Bit-and on the vax is done with a clear-bits insn.\n+;; Bit-and on the VAX is done with a clear-bits insn.\n (define_expand \"andsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(and:SI (not:SI (match_operand:SI 1 \"general_operand\" \"g\"))\n@@ -1159,7 +1159,7 @@\n   \"\"\n   \"mcomb %1,%0\")\n \f\n-;; Arithmetic right shift on the vax works by negating the shift count,\n+;; Arithmetic right shift on the VAX works by negating the shift count,\n ;; then emitting a right shift with the shift count negated.  This means\n ;; that all actual shift counts in the RTL will be positive.  This \n ;; prevents converting shifts to ZERO_EXTRACTs with negative positions,\n@@ -1212,7 +1212,7 @@\n   return \\\"ashl %2,%1,%0\\\";\n }\")\n \n-;; Arithmetic right shift on the vax works by negating the shift count.\n+;; Arithmetic right shift on the VAX works by negating the shift count.\n (define_expand \"ashrdi3\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=g\")\n \t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"g\")\n@@ -1257,7 +1257,7 @@\n   operands[4] = gen_lowpart (QImode, operands[2]);\n }\")\n \n-;; Rotate right on the vax works by negating the shift count.\n+;; Rotate right on the VAX works by negating the shift count.\n (define_expand \"rotrsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"g\")"}, {"sha": "fe5c74649bb7a50926df6a39bba88d3df7d97f53", "filename": "gcc/config/vax/vaxv.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fvaxv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fvaxv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvaxv.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1,4 +1,4 @@\n-/* Definitions of target machine for GNU compiler.  Vax sysV version.\n+/* Definitions of target machine for GNU compiler.  VAX sysV version.\n    Copyright (C) 1988, 1993, 1996, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC."}, {"sha": "ba88d25736f439bd59ed6d6401b49ec50654e240", "filename": "gcc/config/vax/xm-vms.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fxm-vms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fconfig%2Fvax%2Fxm-vms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fxm-vms.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1,4 +1,4 @@\n-/* Configuration for GNU C-compiler for Vax.\n+/* Configuration for GNU C-compiler for VAX.\n    Copyright (C) 1987, 1994, 1995, 1996, 1997, 2001\n    Free Software Foundation, Inc.\n "}, {"sha": "4d1ca2c0895896688efd68c2437d3b296e09e0b8", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -587,7 +587,7 @@ cxx_decode_option (argc, argv)\n \t\t{\n \t\t  *lang_f_options[j].variable = lang_f_options[j].on_value;\n \t\t  /* A goto here would be cleaner,\n-\t\t     but breaks the vax pcc.  */\n+\t\t     but breaks the VAX pcc.  */\n \t\t  found = 1;\n \t\t}\n \t      if (p[0] == 'n' && p[1] == 'o' && p[2] == '-'"}, {"sha": "c7d1fccdaa12cc6ff4924c6513b5add165bb3e46", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -3339,7 +3339,7 @@ fold_rtx (x, insn)\n     case PC:\n       /* If the next insn is a CODE_LABEL followed by a jump table,\n \t PC's value is a LABEL_REF pointing to that label.  That\n-\t lets us fold switch statements on the Vax.  */\n+\t lets us fold switch statements on the VAX.  */\n       if (insn && GET_CODE (insn) == JUMP_INSN)\n \t{\n \t  rtx next = next_nonnote_insn (insn);\n@@ -6852,7 +6852,7 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n \t  && NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)\n \tbreak;\n \n-      /* Don't cse over a call to setjmp; on some machines (eg vax)\n+      /* Don't cse over a call to setjmp; on some machines (eg VAX)\n \t the regs restored by the longjmp come from\n \t a later time than the setjmp.  */\n       if (GET_CODE (p) == NOTE"}, {"sha": "d2724f30883335326c4179dbe399c2f31fd40946", "filename": "gcc/defaults.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -101,7 +101,7 @@ do { ASM_OUTPUT_LABEL(FILE,LABEL_ALTERNATE_NAME (INSN)); } while (0)\n \t      fprintf (asm_out_file, \"\\\\%o\", c);\t\t\t      \\\n \t      /* After an octal-escape, if a digit follows,\t\t      \\\n \t\t terminate one string constant and start another.\t      \\\n-\t\t The Vax assembler fails to stop reading the escape\t      \\\n+\t\t The VAX assembler fails to stop reading the escape\t      \\\n \t\t after three digits, so this is the only way we\t\t      \\\n \t\t can get it to parse the data properly.  */\t\t      \\\n \t      if (i < thissize - 1 && ISDIGIT(p[i + 1]))\t\t      \\"}, {"sha": "caaf15b6232bc3357003a743043cb7632a13761f", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -540,7 +540,7 @@ Teemu Torma for thread safe exception handling support.\n \n @item\n Leonard Tower wrote parts of the parser, RTL generator, and RTL\n-definitions, and of the Vax machine description.\n+definitions, and of the VAX machine description.\n \n @item\n Tom Tromey for internationalization support and his Java work."}, {"sha": "76d7b0cdef47da4007b7b382e4b79e18fa8f3c85", "filename": "gcc/doc/cpp.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcpp.texi?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -2958,12 +2958,12 @@ are used as the error message.\n You would use @samp{#error} inside of a conditional that detects a\n combination of parameters which you know the program does not properly\n support.  For example, if you know that the program will not run\n-properly on a Vax, you might write\n+properly on a VAX, you might write\n \n @example\n @group\n #ifdef __vax__\n-#error \"Won't work on Vaxen.  See comments at get_last_object.\"\n+#error \"Won't work on VAXen.  See comments at get_last_object.\"\n #endif\n @end group\n @end example"}, {"sha": "252f93496befeb2f7fe11584301f420cd2127b0c", "filename": "gcc/doc/gcc.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Fgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Fgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcc.texi?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -909,7 +909,7 @@ convention for structure and union returning.  Use the option\n @option{-mhc-struct-return} to tell GCC to use a convention compatible\n with it.\n \n-@cindex Vax calling convention\n+@cindex VAX calling convention\n @cindex Ultrix calling convention\n @item\n @opindex fcall-saved"}, {"sha": "c0d7662076c767bcfec727f7f61df1d7cbd13c3a", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -3167,7 +3167,7 @@ On a System V release 4 system, make sure @file{/usr/bin} precedes\n <hr>\n @end html\n @heading @anchor{vax-dec-ultrix}vax-dec-ultrix\n-Don't try compiling with Vax C (@code{vcc}).  It produces incorrect code\n+Don't try compiling with VAX C (@code{vcc}).  It produces incorrect code\n in some cases (for example, when @code{alloca} is used).\n \n @html"}, {"sha": "4ae2fc3653ed9d6d58fe5968e2424be2697908a4", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -3263,14 +3263,14 @@ in many functions.  @strong{It also makes debugging impossible on\n some machines.}\n \n @ifset INTERNALS\n-On some machines, such as the Vax, this flag has no effect, because\n+On some machines, such as the VAX, this flag has no effect, because\n the standard calling sequence automatically handles the frame pointer\n and nothing is saved by pretending it doesn't exist.  The\n machine-description macro @code{FRAME_POINTER_REQUIRED} controls\n whether a target machine supports this flag.  @xref{Registers}.\n @end ifset\n @ifclear INTERNALS\n-On some machines, such as the Vax, this flag has no effect, because\n+On some machines, such as the VAX, this flag has no effect, because\n the standard calling sequence automatically handles the frame pointer\n and nothing is saved by pretending it doesn't exist.  The\n machine-description macro @code{FRAME_POINTER_REQUIRED} controls\n@@ -5026,7 +5026,7 @@ command with the @option{-V} option.\n \n Earlier we discussed the standard option @option{-b} which chooses among\n different installed compilers for completely different target\n-machines, such as Vax vs.@: 68000 vs.@: 80386.\n+machines, such as VAX vs.@: 68000 vs.@: 80386.\n \n In addition, each of these target machine types can have its own\n special options, starting with @samp{-m}, to choose among various\n@@ -5297,13 +5297,13 @@ The default is 4 for 68HC11 and 2 for 68HC12.\n @subsection VAX Options\n @cindex VAX options\n \n-These @samp{-m} options are defined for the Vax:\n+These @samp{-m} options are defined for the VAX:\n \n @table @gcctabopt\n @item -munix\n @opindex munix\n Do not output certain jump instructions (@code{aobleq} and so on)\n-that the Unix assembler for the Vax cannot handle across long\n+that the Unix assembler for the VAX cannot handle across long\n ranges.\n \n @item -mgnu"}, {"sha": "8fa221deda3c6133dc02f721b5090977c3612477", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -3131,7 +3131,7 @@ A comparison insn sets the condition code, recording the results of both\n signed and unsigned comparison of the given operands.  A separate branch\n insn tests the condition code and branches or not according its value.\n The branch insns come in distinct signed and unsigned flavors.  Many\n-common machines, such as the Vax, the 68000 and the 32000, work this\n+common machines, such as the VAX, the 68000 and the 32000, work this\n way.\n \n Some machines have distinct signed and unsigned compare instructions, and"}, {"sha": "cfe7ba9cc123bf95deb541d2b49d1572c4bbb9da", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1620,7 +1620,7 @@ Represents the result of arithmetically shifting @var{x} left by @var{c}\n places.  @var{x} have mode @var{m}, a fixed-point machine mode.  @var{c}\n be a fixed-point mode or be a constant with mode @code{VOIDmode}; which\n mode is determined by the mode called for in the machine description\n-entry for the left-shift instruction.  For example, on the Vax, the mode\n+entry for the left-shift instruction.  For example, on the VAX, the mode\n of @var{c} is @code{QImode} regardless of @var{m}.\n \n @findex lshiftrt\n@@ -2070,7 +2070,7 @@ valid for the mode of @var{lval}.\n @item (return)\n As the sole expression in a pattern, represents a return from the\n current function, on machines where this can be done with one\n-instruction, such as Vaxes.  On machines where a multi-instruction\n+instruction, such as VAXen.  On machines where a multi-instruction\n ``epilogue'' must be executed in order to return from the function,\n returning is done by jumping to a label which precedes the epilogue, and\n the @code{return} expression code is never used."}, {"sha": "bdee2f892cf1e0d65faf216560e28e79cd4df6de", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -1304,7 +1304,7 @@ need to define this macro when the format is IEEE@.\n \n @findex VAX_FLOAT_FORMAT\n @item VAX_FLOAT_FORMAT\n-This code indicates the peculiar format used on the Vax.\n+This code indicates the peculiar format used on the VAX.\n \n @findex IBM_FLOAT_FORMAT\n @item IBM_FLOAT_FORMAT\n@@ -3235,7 +3235,7 @@ in the compiler and was not mentioned in the C code being compiled.\n stack.  If a variable number of bytes is passed, it is zero, and\n argument popping will always be the responsibility of the calling function.\n \n-On the Vax, all functions always pop their arguments, so the definition\n+On the VAX, all functions always pop their arguments, so the definition\n of this macro is @var{stack-size}.  On the 68000, using the standard\n calling convention, no functions pop their arguments, so the value of\n the macro is always 0 in this case.  But an alternative calling\n@@ -3274,7 +3274,7 @@ The value of the expression is usually either a @code{reg} RTX for the\n hard register in which to pass the argument, or zero to pass the\n argument on the stack.\n \n-For machines like the Vax and 68000, where normally all arguments are\n+For machines like the VAX and 68000, where normally all arguments are\n pushed, zero suffices as a definition.\n \n The value of the expression can also be a @code{parallel} RTX@.  This is"}, {"sha": "9dd6ba903911e4914c0e20d1ab308663f40affb7", "filename": "gcc/real.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -4404,7 +4404,7 @@ euifrac (x, i, frac)\n     {\n       /* Long integer overflow: output large integer\n \t and correct fraction.\n-\t Note, the BSD microvax compiler says that ~(0UL)\n+\t Note, the BSD MicroVAX compiler says that ~(0UL)\n \t is a syntax error.  */\n       *i = ~(0L);\n       eshift (xi, k);"}, {"sha": "94cd337b2ab51c675f993f2f2ed6ca926fcfb5ee", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -5091,7 +5091,7 @@ update_auto_inc_notes (insn, regno, reloadnum)\n /* Note that we take shortcuts assuming that no multi-reg machine mode\n    occurs as part of an address.\n    Also, this is not fully machine-customizable; it works for machines\n-   such as vaxes and 68000's and 32000's, but other possible machines\n+   such as VAXen and 68000's and 32000's, but other possible machines\n    could have addressing modes that this does not handle right.  */\n \n static int"}, {"sha": "11254da5e1ba512d8b1d694b82db26a3cfb2a41e", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeea6e67d77adc1a5e1575e4543d4259295be39/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=8aeea6e67d77adc1a5e1575e4543d4259295be39", "patch": "@@ -708,7 +708,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t  /* (sign_extend (truncate (minus (label_ref L1) (label_ref L2))))\n \t     becomes just the MINUS if its mode is MODE.  This allows\n \t     folding switch statements on machines using casesi (such as\n-\t     the Vax).  */\n+\t     the VAX).  */\n \t  if (GET_CODE (op) == TRUNCATE\n \t      && GET_MODE (XEXP (op, 0)) == mode\n \t      && GET_CODE (XEXP (op, 0)) == MINUS"}]}