{"sha": "97488870283d923cea932db7763346087cbd9452", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc0ODg4NzAyODNkOTIzY2VhOTMyZGI3NzYzMzQ2MDg3Y2JkOTQ1Mg==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2003-01-09T17:28:49Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-01-09T17:28:49Z"}, "message": "defaults.h (EXTRA_MEMORY_CONSTRAINT): Add STR argument.\n\n\t* defaults.h (EXTRA_MEMORY_CONSTRAINT): Add STR argument.\n\t(EXTRA_ADDRESS_CONSTRAINT): Likewise.\n\t(CONSTRAINT_LEN): Provide default definition.\n\t(CONST_OK_FOR_CONSTRAINT_P): Likewise.\n\t(CONST_DOUBLE_OK_FOR_CONSTRAINT_P): Likewise.\n\t(EXTRA_CONSTRAINT_STR): Likewise.\n\t(REG_CLASS_FROM_CONSTRAINT): Define.\n\t* genoutput.c (check_constraint_len, constraint_len): New functions.\n\t(validate_insn_alternatives): Check CONSTRAINT_LEN for each\n\tconstraint / modifier.\n\t(gen_insn): Call check_constraint_len.\n\t* local-alloc.c (block_alloc): Update to use new macros / pass\n\tsecond argument to EXTRA_{MEMORY,ADDRESS}_CONSTRAINT.\n\t* ra-build.c (handle_asm_insn): Likewise.\n\t* recog.c (asm_operand_ok, preprocess_constraints): Likewise.\n\t(constrain_operands, peep2_find_free_register): Likewise.\n\t* regclass.c (record_operand_costs, record_reg_classes): Likewise.\n\t* regmove.c (find_matches): Likewise.\n\t* reload.c (push_secondary_reload, find_reloads): Likewise.\n\t(alternative_allows_memconst): Likewise.\n\t* reload1.c (maybe_fix_stack_asms): Likewise.\n\t(reload_cse_simplify_operands): Likewise.\n\t* stmt.c (parse_output_constraint, parse_input_constraint): Likewise.\n\t* doc/tm.texi (CONSTRAINT_LEN, REG_CLASS_FROM_CONSTRAINT): Document.\n\t(CONST_OK_FOR_CONSTRAINT_P): Likewise.\n\t(CONST_DOUBLE_OK_FOR_CONSTRAINT_P, EXTRA_CONSTRAINT_STR): Likewise.\n\t(EXTRA_MEMORY_CONSTRAINT, EXTRA_ADDRESS_CONSTRAINT): Add STR argument.\n\t* config/s390/s390.h (EXTRA_MEMORY_CONSTRAINT): Likewise.\n\nFrom-SVN: r61119", "tree": {"sha": "71e3146782ec281fdcd5e689d1f1cbbe5f3c2286", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71e3146782ec281fdcd5e689d1f1cbbe5f3c2286"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97488870283d923cea932db7763346087cbd9452", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97488870283d923cea932db7763346087cbd9452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97488870283d923cea932db7763346087cbd9452", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97488870283d923cea932db7763346087cbd9452/comments", "author": null, "committer": null, "parents": [{"sha": "e2c734c181b1235369d02d76b554925faec4753b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c734c181b1235369d02d76b554925faec4753b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2c734c181b1235369d02d76b554925faec4753b"}], "stats": {"total": 947, "additions": 609, "deletions": 338}, "files": [{"sha": "5a61481aa480fd6d19c0b28627ddde8e646da666", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97488870283d923cea932db7763346087cbd9452/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97488870283d923cea932db7763346087cbd9452/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=97488870283d923cea932db7763346087cbd9452", "patch": "@@ -1,4 +1,33 @@\n-Thu Jan  9 17:23:19 2003  J\"orn Rennecke <joern.rennecke@superh.com>\n+Thu Jan  9 17:26:40 2003  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* defaults.h (EXTRA_MEMORY_CONSTRAINT): Add STR argument.\n+\t(EXTRA_ADDRESS_CONSTRAINT): Likewise.\n+\t(CONSTRAINT_LEN): Provide default definition.\n+\t(CONST_OK_FOR_CONSTRAINT_P): Likewise.\n+\t(CONST_DOUBLE_OK_FOR_CONSTRAINT_P): Likewise.\n+\t(EXTRA_CONSTRAINT_STR): Likewise.\n+\t(REG_CLASS_FROM_CONSTRAINT): Define.\n+\t* genoutput.c (check_constraint_len, constraint_len): New functions.\n+\t(validate_insn_alternatives): Check CONSTRAINT_LEN for each\n+\tconstraint / modifier.\n+\t(gen_insn): Call check_constraint_len.\n+\t* local-alloc.c (block_alloc): Update to use new macros / pass\n+\tsecond argument to EXTRA_{MEMORY,ADDRESS}_CONSTRAINT.\n+\t* ra-build.c (handle_asm_insn): Likewise.\n+\t* recog.c (asm_operand_ok, preprocess_constraints): Likewise.\n+\t(constrain_operands, peep2_find_free_register): Likewise.\n+\t* regclass.c (record_operand_costs, record_reg_classes): Likewise.\n+\t* regmove.c (find_matches): Likewise.\n+\t* reload.c (push_secondary_reload, find_reloads): Likewise.\n+\t(alternative_allows_memconst): Likewise.\n+\t* reload1.c (maybe_fix_stack_asms): Likewise.\n+\t(reload_cse_simplify_operands): Likewise.\n+\t* stmt.c (parse_output_constraint, parse_input_constraint): Likewise.\n+\t* doc/tm.texi (CONSTRAINT_LEN, REG_CLASS_FROM_CONSTRAINT): Document.\n+\t(CONST_OK_FOR_CONSTRAINT_P): Likewise.\n+\t(CONST_DOUBLE_OK_FOR_CONSTRAINT_P, EXTRA_CONSTRAINT_STR): Likewise.\n+\t(EXTRA_MEMORY_CONSTRAINT, EXTRA_ADDRESS_CONSTRAINT): Add STR argument.\n+\t* config/s390/s390.h (EXTRA_MEMORY_CONSTRAINT): Likewise.\n \n \t* sh.h (OVERRIDE_OPTIONS): Allow first scheduling pass for SH5.\n "}, {"sha": "fce6c48867d5392e3cb587852d372d7ef69055ce", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97488870283d923cea932db7763346087cbd9452/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97488870283d923cea932db7763346087cbd9452/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=97488870283d923cea932db7763346087cbd9452", "patch": "@@ -473,7 +473,7 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n      ((C) == 'Q' ?  q_constraint (OP) : \t\t\t\\\n       (C) == 'S' ?  larl_operand (OP, GET_MODE (OP)) : 0)\n \n-#define EXTRA_MEMORY_CONSTRAINT(C) ((C) == 'Q')\n+#define EXTRA_MEMORY_CONSTRAINT(C,STR) ((C) == 'Q')\n \n \n /* Stack layout and calling conventions.  */"}, {"sha": "39f9d09838116b4519df33fec3abb88e09338a6e", "filename": "gcc/defaults.h", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97488870283d923cea932db7763346087cbd9452/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97488870283d923cea932db7763346087cbd9452/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=97488870283d923cea932db7763346087cbd9452", "patch": "@@ -604,13 +604,38 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n /* Determine whether extra constraint letter should be handled\n    via address reload (like 'o').  */\n #ifndef EXTRA_MEMORY_CONSTRAINT\n-#define EXTRA_MEMORY_CONSTRAINT(C) 0\n+#define EXTRA_MEMORY_CONSTRAINT(C,STR) 0\n #endif\n \n /* Determine whether extra constraint letter should be handled\n    as an address (like 'p').  */\n #ifndef EXTRA_ADDRESS_CONSTRAINT\n-#define EXTRA_ADDRESS_CONSTRAINT(C) 0\n+#define EXTRA_ADDRESS_CONSTRAINT(C,STR) 0\n+#endif\n+\n+/* When a port defines CONSTRAINT_LEN, it should use DEFAULT_CONSTRAINT_LEN\n+   for all the characters that it does not want to change, so things like the\n+  'length' of a digit in a matching constraint is an implementation detail,\n+   and not part of the interface.  */\n+#define DEFAULT_CONSTRAINT_LEN(C,STR) 1\n+\n+#ifndef CONSTRAINT_LEN\n+#define CONSTRAINT_LEN(C,STR) DEFAULT_CONSTRAINT_LEN (C, STR)\n+#endif\n+\n+#if defined (CONST_OK_FOR_LETTER_P) && ! defined (CONST_OK_FOR_CONSTRAINT_P)\n+#define CONST_OK_FOR_CONSTRAINT_P(VAL,C,STR) CONST_OK_FOR_LETTER_P (VAL, C)\n+#endif\n+\n+#if defined (CONST_DOUBLE_OK_FOR_LETTER_P) && ! defined (CONST_DOUBLE_OK_FOR_CONSTRAINT_P)\n+#define CONST_DOUBLE_OK_FOR_CONSTRAINT_P(OP,C,STR) \\\n+  CONST_DOUBLE_OK_FOR_LETTER_P (OP, C)\n+#endif\n+\n+#define REG_CLASS_FROM_CONSTRAINT(C,STR) REG_CLASS_FROM_LETTER (C)\n+\n+#if defined (EXTRA_CONSTRAINT) && ! defined (EXTRA_CONSTRAINT_STR)\n+#define EXTRA_CONSTRAINT_STR(OP, C,STR) EXTRA_CONSTRAINT (OP, C)\n #endif\n \n #endif  /* ! GCC_DEFAULTS_H */"}, {"sha": "fa4248c1c67c7772df72e22526e59df62867191d", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97488870283d923cea932db7763346087cbd9452/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97488870283d923cea932db7763346087cbd9452/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=97488870283d923cea932db7763346087cbd9452", "patch": "@@ -1910,7 +1910,8 @@ If the usage of an entire class of registers depends on the target\n flags, you may indicate this to GCC by using this macro to modify\n @code{fixed_regs} and @code{call_used_regs} to 1 for each of the\n registers in the classes which should not be used by GCC@.  Also define\n-the macro @code{REG_CLASS_FROM_LETTER} to return @code{NO_REGS} if it\n+the macro @code{REG_CLASS_FROM_LETTER} / @code{REG_CLASS_FROM_CONSTRAINT}\n+to return @code{NO_REGS} if it\n is called with a letter for a class that shouldn't be used.\n \n (However, if this class is not included in @code{GENERAL_REGS} and all\n@@ -2330,6 +2331,21 @@ index register must belong.  An index register is one used in an\n address where its value is either multiplied by a scale factor or\n added to another register (as well as added to a displacement).\n \n+@findex CONSTRAINT_LEN\n+@item CONSTRAINT_LEN (@var{char}, @var{str})\n+For the constraint at the start of @var{str}, which starts with the letter\n+@var{c}, return the length.  This allows you to have register class /\n+constant / extra constraints that are longer than a single letter;\n+you don't need to define this macro if you can do with single-letter\n+constraints only.  The definition of this macro should use\n+DEFAULT_CONSTRAINT_LEN for all the characters that you don't want\n+to handle specially.\n+There are some sanity checks in genoutput.c that check the constraint lengths\n+for the md file, so you can also use this macro to help you while you are\n+transitioning from a byzantine single-letter-constraint scheme: when you\n+return a negative length for a constraint you want to re-use, genoutput\n+will complain about every instance where it is used in the md file.\n+\n @findex REG_CLASS_FROM_LETTER\n @item REG_CLASS_FROM_LETTER (@var{char})\n A C expression which defines the machine-dependent operand constraint\n@@ -2339,6 +2355,12 @@ the value should be @code{NO_REGS}.  The register letter @samp{r},\n corresponding to class @code{GENERAL_REGS}, will not be passed\n to this macro; you do not need to handle it.\n \n+@findex REG_CLASS_FROM_CONSTRAINT\n+@item REG_CLASS_FROM_CONSTRAINT (@var{char}, @var{str})\n+Like @code{REG_CLASS_FROM_LETTER}, but you also get the constraint string\n+passed in @var{str}, so that you can use suffixes to distinguish between\n+different variants.\n+\n @findex REGNO_OK_FOR_BASE_P\n @item REGNO_OK_FOR_BASE_P (@var{num})\n A C expression which is nonzero if register number @var{num} is\n@@ -2608,6 +2630,12 @@ the appropriate range and return 1 if so, 0 otherwise.  If @var{c} is\n not one of those letters, the value should be 0 regardless of\n @var{value}.\n \n+@findex CONST_OK_FOR_CONSTRAINT_P\n+@item CONST_OK_FOR_CONSTRAINT_P (@var{value}, @var{c}, @var{str})\n+Like @code{CONST_OK_FOR_LETTER_P}, but you also get the constraint\n+string passed in @var{str}, so that you can use suffixes to distinguish\n+between different variants.\n+\n @findex CONST_DOUBLE_OK_FOR_LETTER_P\n @item CONST_DOUBLE_OK_FOR_LETTER_P (@var{value}, @var{c})\n A C expression that defines the machine-dependent operand constraint\n@@ -2624,12 +2652,19 @@ letters, the value should be 0 regardless of @var{value}.\n or both kinds of values.  It can use @code{GET_MODE} to distinguish\n between these kinds.\n \n+@findex CONST_DOUBLE_OK_FOR_CONSTRAINT_P\n+@item CONST_DOUBLE_OK_FOR_CONSTRAINT_P (@var{value}, @var{c}, @var{str})\n+Like @code{CONST_DOUBLE_OK_FOR_LETTER_P}, but you also get the constraint\n+string passed in @var{str}, so that you can use suffixes to distinguish\n+between different variants.\n+\n @findex EXTRA_CONSTRAINT\n @item EXTRA_CONSTRAINT (@var{value}, @var{c})\n A C expression that defines the optional machine-dependent constraint\n letters that can be used to segregate specific types of operands, usually\n memory references, for the target machine.  Any letter that is not\n-elsewhere defined and not matched by @code{REG_CLASS_FROM_LETTER}\n+elsewhere defined and not matched by @code{REG_CLASS_FROM_LETTER} /\n+@code{REG_CLASS_FROM_CONSTRAINT}\n may be used.  Normally this macro will not be defined.\n \n If it is required for a particular target machine, it should return 1\n@@ -2645,14 +2680,21 @@ a @samp{Q} constraint on the input and @samp{r} on the output.  The next\n alternative specifies @samp{m} on the input and a register class that\n does not include r0 on the output.\n \n+@findex EXTRA_CONSTRAINT_STR\n+@item EXTRA_CONSTRAINT_STR (@var{value}, @var{c}, @var{str})\n+Like @code{EXTRA_CONSTRAINT}, but you also get the constraint string passed\n+in @var{str}, so that you can use suffixes to distinguish between different\n+variants.\n+\n @findex EXTRA_MEMORY_CONSTRAINT\n-@item EXTRA_MEMORY_CONSTRAINT (@var{c})\n+@item EXTRA_MEMORY_CONSTRAINT (@var{c}, @var{str})\n A C expression that defines the optional machine-dependent constraint\n letters, amongst those accepted by @code{EXTRA_CONSTRAINT}, that should\n be treated like memory constraints by the reload pass.\n \n It should return 1 if the operand type represented by the constraint \n-letter @var{c} comprises a subset of all memory references including\n+at the start of @var{str}, the first letter of which is the letter @var{c},\n+ comprises a subset of all memory references including\n all those whose address is simply a base register.  This allows the reload \n pass to reload an operand, if it does not directly correspond to the operand \n type of @var{c}, by copying its address into a base register.\n@@ -2668,16 +2710,18 @@ into a base register if required.  This is analogous to the way\n a @samp{o} constraint can handle any memory operand.\n \n @findex EXTRA_ADDRESS_CONSTRAINT\n-@item EXTRA_ADDRESS_CONSTRAINT (@var{c})\n+@item EXTRA_ADDRESS_CONSTRAINT (@var{c}, @var{str})\n A C expression that defines the optional machine-dependent constraint\n-letters, amongst those accepted by @code{EXTRA_CONSTRAINT}, that should\n+letters, amongst those accepted by @code{EXTRA_CONSTRAINT} /\n+@code{EXTRA_CONSTRAINT_STR}, that should\n be treated like address constraints by the reload pass.\n \n It should return 1 if the operand type represented by the constraint \n-letter @var{c} comprises a subset of all memory addresses including\n+at the startr of @{str}, which starts with the letter @var{c}, comprises\n+a subset of all memory addresses including\n all those that consist of just a base register.  This allows the reload \n pass to reload an operand, if it does not directly correspond to the operand \n-type of @var{c}, by copying it into a base register.\n+type of @var{str}, by copying it into a base register.\n \n Any constraint marked as @code{EXTRA_ADDRESS_CONSTRAINT} can only\n be used with the @code{address_operand} predicate.  It is treated "}, {"sha": "3a1ad817908b3b502c68924ee242dcc9dbf322b3", "filename": "gcc/genoutput.c", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97488870283d923cea932db7763346087cbd9452/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97488870283d923cea932db7763346087cbd9452/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=97488870283d923cea932db7763346087cbd9452", "patch": "@@ -189,6 +189,8 @@ static void gen_insn PARAMS ((rtx, int));\n static void gen_peephole PARAMS ((rtx, int));\n static void gen_expand PARAMS ((rtx, int));\n static void gen_split PARAMS ((rtx, int));\n+static void check_constraint_len PARAMS ((void));\n+static int constraint_len PARAMS ((const char *, int));\n \f\n const char *\n get_insn_name (index)\n@@ -749,7 +751,51 @@ validate_insn_alternatives (d)\n   for (start = 0; start < d->n_operands; start++)\n     if (d->operand[start].n_alternatives > 0)\n       {\n-\tif (n == 0)\n+\tint len, i;\n+\tconst char *p;\n+\tchar c;\n+\tint which_alternative = 0;\n+\tint alternative_count_unsure = 0;\n+\n+\tfor (p = d->operand[start].constraint; (c = *p); p += len)\n+\t  {\n+\t    len = CONSTRAINT_LEN (c, p);\n+\n+\t    if (len < 1 || (len > 1 && strchr (\",#*+=&%!0123456789\", c)))\n+\t      {\n+\t\tmessage_with_line (d->lineno,\n+\t\t\t\t   \"invalid length %d for char '%c' in alternative %d of operand %d\",\n+\t\t\t\t    len, c, which_alternative, start);\n+\t\tlen = 1;\n+\t\thave_error = 1;\n+\t      }\n+\n+\t    if (c == ',')\n+\t      {\n+\t        which_alternative++;\n+\t\tcontinue;\n+\t      }\n+\n+\t    for (i = 1; i < len; i++)\n+\t      if (p[i] == '\\0')\n+\t\t{\n+\t\t  message_with_line (d->lineno,\n+\t\t\t\t     \"NUL in alternative %d of operand %d\",\n+\t\t\t\t     which_alternative, start);\n+\t\t  alternative_count_unsure = 1;\n+\t\t  break;\n+\t\t}\n+\t      else if (strchr (\",#*\", p[i]))\n+\t\t{\n+\t\t  message_with_line (d->lineno,\n+\t\t\t\t     \"'%c' in alternative %d of operand %d\",\n+\t\t\t\t     p[i], which_alternative, start);\n+\t\t  alternative_count_unsure = 1;\n+\t\t}\n+\t  }\n+\tif (alternative_count_unsure)\n+\t  have_error = 1;\n+\telse if (n == 0)\n \t  n = d->operand[start].n_alternatives;\n \telse if (n != d->operand[start].n_alternatives)\n \t  {\n@@ -816,6 +862,7 @@ gen_insn (insn, lineno)\n   d->n_operands = max_opno + 1;\n   d->n_dups = num_dups;\n \n+  check_constraint_len ();\n   validate_insn_operands (d);\n   validate_insn_alternatives (d);\n   place_operands (d);\n@@ -1043,3 +1090,41 @@ strip_whitespace (s)\n   *p = '\\0';\n   return q;\n }\n+\n+/* Verify that DEFAULT_CONSTRAINT_LEN is used properly and not\n+   tampered with.  This isn't bullet-proof, but it should catch\n+   most genuine mistakes.  */\n+static void\n+check_constraint_len ()\n+{\n+  const char *p;\n+  int d;\n+\n+  for (p = \",#*+=&%!1234567890\"; *p; p++)\n+    for (d = -9; d < 9; d++)\n+      if (constraint_len (p, d) != d)\n+\tabort ();\n+}\n+\n+static int\n+constraint_len (p, genoutput_default_constraint_len)\n+     const char *p;\n+     int genoutput_default_constraint_len;\n+{\n+  /* Check that we still match defaults.h .  First we do a generation-time\n+     check that fails if the value is not the expected one...  */\n+  if (DEFAULT_CONSTRAINT_LEN (*p, p) != 1)\n+    abort ();\n+  /* And now a comile-time check that should give a diagnostic if the\n+     definition doesn't exactly match.  */\n+#define DEFAULT_CONSTRAINT_LEN(C,STR) 1\n+  /* Now re-define DEFAULT_CONSTRAINT_LEN so that we can verify it is\n+     being used.  */\n+#undef DEFAULT_CONSTRAINT_LEN\n+#define DEFAULT_CONSTRAINT_LEN(C,STR) \\\n+  ((C) != *p || STR != p ? -1 : genoutput_default_constraint_len)\n+  return CONSTRAINT_LEN (*p, p);\n+  /* And set it back.  */\n+#undef DEFAULT_CONSTRAINT_LEN\n+#define DEFAULT_CONSTRAINT_LEN(C,STR) 1\n+}"}, {"sha": "ff252a3c66497d39d0c92d4b2cd69292d7d3b72b", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 45, "deletions": 38, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97488870283d923cea932db7763346087cbd9452/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97488870283d923cea932db7763346087cbd9452/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=97488870283d923cea932db7763346087cbd9452", "patch": "@@ -1338,7 +1338,8 @@ block_alloc (b)\n \t\t     There may be more than one register, but we only try one\n \t\t     of them.  */\n \t\t  if (recog_data.constraints[i][0] == 'p'\n-\t\t      || EXTRA_ADDRESS_CONSTRAINT (recog_data.constraints[i][0]))\n+\t\t      || EXTRA_ADDRESS_CONSTRAINT (recog_data.constraints[i][0],\n+\t\t\t\t\t\t   recog_data.constraints[i]))\n \t\t    while (GET_CODE (r1) == PLUS || GET_CODE (r1) == MULT)\n \t\t      r1 = XEXP (r1, 0);\n \n@@ -2424,50 +2425,56 @@ requires_inout (p)\n   int found_zero = 0;\n   int reg_allowed = 0;\n   int num_matching_alts = 0;\n+  int len;\n \n-  while ((c = *p++))\n-    switch (c)\n-      {\n-      case '=':  case '+':  case '?':\n-      case '#':  case '&':  case '!':\n-      case '*':  case '%':\n-      case 'm':  case '<':  case '>':  case 'V':  case 'o':\n-      case 'E':  case 'F':  case 'G':  case 'H':\n-      case 's':  case 'i':  case 'n':\n-      case 'I':  case 'J':  case 'K':  case 'L':\n-      case 'M':  case 'N':  case 'O':  case 'P':\n-      case 'X':\n-\t/* These don't say anything we care about.  */\n-\tbreak;\n+  for ( ; c = *p; p += len)\n+    {\n+      len = CONSTRAINT_LEN (c, p);\n+      switch (c)\n+\t{\n+\tcase '=':  case '+':  case '?':\n+\tcase '#':  case '&':  case '!':\n+\tcase '*':  case '%':\n+\tcase 'm':  case '<':  case '>':  case 'V':  case 'o':\n+\tcase 'E':  case 'F':  case 'G':  case 'H':\n+\tcase 's':  case 'i':  case 'n':\n+\tcase 'I':  case 'J':  case 'K':  case 'L':\n+\tcase 'M':  case 'N':  case 'O':  case 'P':\n+\tcase 'X':\n+\t  /* These don't say anything we care about.  */\n+\t  break;\n \n-      case ',':\n-\tif (found_zero && ! reg_allowed)\n-\t  num_matching_alts++;\n+\tcase ',':\n+\t  if (found_zero && ! reg_allowed)\n+\t    num_matching_alts++;\n \n-\tfound_zero = reg_allowed = 0;\n-\tbreak;\n+\t  found_zero = reg_allowed = 0;\n+\t  break;\n \n-      case '0':\n-\tfound_zero = 1;\n-\tbreak;\n+\tcase '0':\n+\t  found_zero = 1;\n+\t  break;\n \n-      case '1':  case '2':  case '3':  case '4': case '5':\n-      case '6':  case '7':  case '8':  case '9':\n-\t/* Skip the balance of the matching constraint.  */\n-\twhile (ISDIGIT (*p))\n-\t  p++;\n-\tbreak;\n+\tcase '1':  case '2':  case '3':  case '4': case '5':\n+\tcase '6':  case '7':  case '8':  case '9':\n+\t  /* Skip the balance of the matching constraint.  */\n+\t  do\n+\t    p++;\n+\t  while (ISDIGIT (*p));\n+\t  len = 0;\n+\t  break;\n \n-      default:\n-\tif (REG_CLASS_FROM_LETTER (c) == NO_REGS\n-\t    && !EXTRA_ADDRESS_CONSTRAINT (c))\n+\tdefault:\n+\t  if (REG_CLASS_FROM_CONSTRAINT (c, p) == NO_REGS\n+\t      && !EXTRA_ADDRESS_CONSTRAINT (c, p))\n+\t    break;\n+\t  /* FALLTHRU */\n+\tcase 'p':\n+\tcase 'g': case 'r':\n+\t  reg_allowed = 1;\n \t  break;\n-\t/* FALLTHRU */\n-      case 'p':\n-      case 'g': case 'r':\n-\treg_allowed = 1;\n-\tbreak;\n-      }\n+\t}\n+    }\n \n   if (found_zero && ! reg_allowed)\n     num_matching_alts++;"}, {"sha": "2272fa5998110ea2ed8d3c9600834b61d0cbae77", "filename": "gcc/ra-build.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97488870283d923cea932db7763346087cbd9452/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97488870283d923cea932db7763346087cbd9452/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=97488870283d923cea932db7763346087cbd9452", "patch": "@@ -2933,13 +2933,13 @@ handle_asm_insn (df, insn)\n       CLEAR_HARD_REG_SET (allowed);\n       while (1)\n \t{\n-\t  char c = *p++;\n+\t  char c = *p;\n \n \t  if (c == '\\0' || c == ',' || c == '#')\n \t    {\n \t      /* End of one alternative - mark the regs in the current\n-\t       class, and reset the class.\n-\t       */\n+\t       class, and reset the class.  */\n+\t      p++;\n \t      IOR_HARD_REG_SET (allowed, reg_class_contents[cls]);\n \t      if (cls != NO_REGS)\n \t\tnothing_allowed = 0;\n@@ -2977,8 +2977,10 @@ handle_asm_insn (df, insn)\n \t      default:\n \t\tcls =\n \t\t  (int) reg_class_subunion[cls][(int)\n-\t\t\t\t\t\tREG_CLASS_FROM_LETTER (c)];\n+\t\t\t\t\t\tREG_CLASS_FROM_CONSTRAINT (c,\n+\t\t\t\t\t\t\t\t\t   p)];\n \t    }\n+\t  p += CONSTRAINT_LEN (c, p);\n \t}\n \n       /* Now make conflicts between this web, and all hardregs, which"}, {"sha": "8d36e513e37deaf280ff26e1f68d6598f059f027", "filename": "gcc/recog.c", "status": "modified", "additions": 101, "deletions": 68, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97488870283d923cea932db7763346087cbd9452/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97488870283d923cea932db7763346087cbd9452/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=97488870283d923cea932db7763346087cbd9452", "patch": "@@ -1681,18 +1681,21 @@ asm_operand_ok (op, constraint)\n \n   while (*constraint)\n     {\n-      char c = *constraint++;\n+      char c = *constraint;\n+      int len;\n       switch (c)\n \t{\n+\tcase ',':\n+\t  constraint++;\n+\t  continue;\n \tcase '=':\n \tcase '+':\n \tcase '*':\n \tcase '%':\n-\tcase '?':\n \tcase '!':\n \tcase '#':\n \tcase '&':\n-\tcase ',':\n+\tcase '?':\n \t  break;\n \n \tcase '0': case '1': case '2': case '3': case '4':\n@@ -1701,25 +1704,27 @@ asm_operand_ok (op, constraint)\n \t     proper matching constraint, but we can't actually fail\n \t     the check if they didn't.  Indicate that results are\n \t     inconclusive.  */\n-\t  while (ISDIGIT (*constraint))\n+\t  do\n \t    constraint++;\n-\t  result = -1;\n-\t  break;\n+\t  while (ISDIGIT (*constraint));\n+\t  if (! result)\n+\t    result = -1;\n+\t  continue;\n \n \tcase 'p':\n \t  if (address_operand (op, VOIDmode))\n-\t    return 1;\n+\t    result = 1;\n \t  break;\n \n \tcase 'm':\n \tcase 'V': /* non-offsettable */\n \t  if (memory_operand (op, VOIDmode))\n-\t    return 1;\n+\t    result = 1;\n \t  break;\n \n \tcase 'o': /* offsettable */\n \t  if (offsettable_nonstrict_memref_p (op))\n-\t    return 1;\n+\t    result = 1;\n \t  break;\n \n \tcase '<':\n@@ -1734,34 +1739,34 @@ asm_operand_ok (op, constraint)\n \t      && (1\n \t\t  || GET_CODE (XEXP (op, 0)) == PRE_DEC\n \t\t  || GET_CODE (XEXP (op, 0)) == POST_DEC))\n-\t    return 1;\n+\t    result = 1;\n \t  break;\n \n \tcase '>':\n \t  if (GET_CODE (op) == MEM\n \t      && (1\n \t\t  || GET_CODE (XEXP (op, 0)) == PRE_INC\n \t\t  || GET_CODE (XEXP (op, 0)) == POST_INC))\n-\t    return 1;\n+\t    result = 1;\n \t  break;\n \n \tcase 'E':\n \tcase 'F':\n \t  if (GET_CODE (op) == CONST_DOUBLE\n \t      || (GET_CODE (op) == CONST_VECTOR\n \t\t  && GET_MODE_CLASS (GET_MODE (op)) == MODE_VECTOR_FLOAT))\n-\t    return 1;\n+\t    result = 1;\n \t  break;\n \n \tcase 'G':\n \t  if (GET_CODE (op) == CONST_DOUBLE\n-\t      && CONST_DOUBLE_OK_FOR_LETTER_P (op, 'G'))\n-\t    return 1;\n+\t      && CONST_DOUBLE_OK_FOR_CONSTRAINT_P (op, 'G', constraint))\n+\t    result = 1;\n \t  break;\n \tcase 'H':\n \t  if (GET_CODE (op) == CONST_DOUBLE\n-\t      && CONST_DOUBLE_OK_FOR_LETTER_P (op, 'H'))\n-\t    return 1;\n+\t      && CONST_DOUBLE_OK_FOR_CONSTRAINT_P (op, 'H', constraint))\n+\t    result = 1;\n \t  break;\n \n \tcase 's':\n@@ -1777,94 +1782,100 @@ asm_operand_ok (op, constraint)\n \t      && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op))\n #endif\n \t      )\n-\t    return 1;\n+\t    result = 1;\n \t  break;\n \n \tcase 'n':\n \t  if (GET_CODE (op) == CONST_INT\n \t      || (GET_CODE (op) == CONST_DOUBLE\n \t\t  && GET_MODE (op) == VOIDmode))\n-\t    return 1;\n+\t    result = 1;\n \t  break;\n \n \tcase 'I':\n \t  if (GET_CODE (op) == CONST_INT\n-\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'I'))\n-\t    return 1;\n+\t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'I', constraint))\n+\t    result = 1;\n \t  break;\n \tcase 'J':\n \t  if (GET_CODE (op) == CONST_INT\n-\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'J'))\n-\t    return 1;\n+\t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'J', constraint))\n+\t    result = 1;\n \t  break;\n \tcase 'K':\n \t  if (GET_CODE (op) == CONST_INT\n-\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'K'))\n-\t    return 1;\n+\t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'K', constraint))\n+\t    result = 1;\n \t  break;\n \tcase 'L':\n \t  if (GET_CODE (op) == CONST_INT\n-\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'L'))\n-\t    return 1;\n+\t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'L', constraint))\n+\t    result = 1;\n \t  break;\n \tcase 'M':\n \t  if (GET_CODE (op) == CONST_INT\n-\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'M'))\n-\t    return 1;\n+\t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'M', constraint))\n+\t    result = 1;\n \t  break;\n \tcase 'N':\n \t  if (GET_CODE (op) == CONST_INT\n-\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'N'))\n-\t    return 1;\n+\t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'N', constraint))\n+\t    result = 1;\n \t  break;\n \tcase 'O':\n \t  if (GET_CODE (op) == CONST_INT\n-\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'O'))\n-\t    return 1;\n+\t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'O', constraint))\n+\t    result = 1;\n \t  break;\n \tcase 'P':\n \t  if (GET_CODE (op) == CONST_INT\n-\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'P'))\n-\t    return 1;\n+\t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'P', constraint))\n+\t    result = 1;\n \t  break;\n \n \tcase 'X':\n-\t  return 1;\n+\t  result = 1;\n \n \tcase 'g':\n \t  if (general_operand (op, VOIDmode))\n-\t    return 1;\n+\t    result = 1;\n \t  break;\n \n \tdefault:\n \t  /* For all other letters, we first check for a register class,\n \t     otherwise it is an EXTRA_CONSTRAINT.  */\n-\t  if (REG_CLASS_FROM_LETTER (c) != NO_REGS)\n+\t  if (REG_CLASS_FROM_CONSTRAINT (c, constraint) != NO_REGS)\n \t    {\n \t    case 'r':\n \t      if (GET_MODE (op) == BLKmode)\n \t\tbreak;\n \t      if (register_operand (op, VOIDmode))\n-\t\treturn 1;\n+\t\tresult = 1;\n \t    }\n-#ifdef EXTRA_CONSTRAINT\n-\t  if (EXTRA_CONSTRAINT (op, c))\n-\t    return 1;\n-\t  if (EXTRA_MEMORY_CONSTRAINT (c))\n+#ifdef EXTRA_CONSTRAINT_STR\n+\t  if (EXTRA_CONSTRAINT_STR (op, c, constraint))\n+\t    result = 1;\n+\t  if (EXTRA_MEMORY_CONSTRAINT (c, constraint))\n \t    {\n \t      /* Every memory operand can be reloaded to fit.  */\n \t      if (memory_operand (op, VOIDmode))\n-\t        return 1;\n+\t        result = 1;\n \t    }\n-\t  if (EXTRA_ADDRESS_CONSTRAINT (c))\n+\t  if (EXTRA_ADDRESS_CONSTRAINT (c, constraint))\n \t    {\n \t      /* Every address operand can be reloaded to fit.  */\n \t      if (address_operand (op, VOIDmode))\n-\t        return 1;\n+\t        result = 1;\n \t    }\n #endif\n \t  break;\n \t}\n+      len = CONSTRAINT_LEN (c, constraint);\n+      do\n+\tconstraint++;\n+      while (--len && *constraint);\n+      if (len)\n+\treturn 0;\n     }\n \n   return result;\n@@ -2233,13 +2244,16 @@ preprocess_constraints ()\n \n \t  for (;;)\n \t    {\n-\t      char c = *p++;\n+\t      char c = *p;\n \t      if (c == '#')\n \t\tdo\n-\t\t  c = *p++;\n+\t\t  c = *++p;\n \t\twhile (c != ',' && c != '\\0');\n \t      if (c == ',' || c == '\\0')\n-\t\tbreak;\n+\t\t{\n+\t\t  p++;\n+\t\t  break;\n+\t\t}\n \n \t      switch (c)\n \t\t{\n@@ -2265,11 +2279,11 @@ preprocess_constraints ()\n \t\tcase '5': case '6': case '7': case '8': case '9':\n \t\t  {\n \t\t    char *end;\n-\t\t    op_alt[j].matches = strtoul (p - 1, &end, 10);\n+\t\t    op_alt[j].matches = strtoul (p, &end, 10);\n \t\t    recog_op_alt[op_alt[j].matches][j].matched = i;\n \t\t    p = end;\n \t\t  }\n-\t\t  break;\n+\t\t  continue;\n \n \t\tcase 'm':\n \t\t  op_alt[j].memory_ok = 1;\n@@ -2301,22 +2315,28 @@ preprocess_constraints ()\n \t\t  break;\n \n \t\tdefault:\n-\t\t  if (EXTRA_MEMORY_CONSTRAINT (c))\n+\t\t  if (EXTRA_MEMORY_CONSTRAINT (c, p))\n \t\t    {\n \t\t      op_alt[j].memory_ok = 1;\n \t\t      break;\n \t\t    }\n-\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c))\n+\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n \t\t    {\n \t\t      op_alt[j].is_address = 1;\n-\t\t      op_alt[j].class = reg_class_subunion[(int) op_alt[j].class]\n-\t\t        [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n+\t\t      op_alt[j].class\n+\t\t\t= (reg_class_subunion\n+\t\t\t   [(int) op_alt[j].class]\n+\t\t\t   [(int) MODE_BASE_REG_CLASS (VOIDmode)]);\n \t\t      break;\n \t\t    }\n \n-\t\t  op_alt[j].class = reg_class_subunion[(int) op_alt[j].class][(int) REG_CLASS_FROM_LETTER ((unsigned char) c)];\n+\t\t  op_alt[j].class\n+\t\t    = (reg_class_subunion\n+\t\t       [(int) op_alt[j].class]\n+\t\t       [(int) REG_CLASS_FROM_CONSTRAINT ((unsigned char) c, p)]);\n \t\t  break;\n \t\t}\n+\t      p += CONSTRAINT_LEN (c, p);\n \t    }\n \t}\n     }\n@@ -2331,7 +2351,7 @@ preprocess_constraints ()\n    alternative of constraints was matched: 0 for the first alternative,\n    1 for the next, etc.\n \n-   In addition, when two operands are match\n+   In addition, when two operands are required to match\n    and it happens that the output operand is (reg) while the\n    input operand is --(reg) or ++(reg) (a pre-inc or pre-dec),\n    make the output operand look like the input.\n@@ -2390,6 +2410,7 @@ constrain_operands (strict)\n \t  int offset = 0;\n \t  int win = 0;\n \t  int val;\n+\t  int len;\n \n \t  earlyclobber[opno] = 0;\n \n@@ -2414,18 +2435,27 @@ constrain_operands (strict)\n \t  if (*p == 0 || *p == ',')\n \t    win = 1;\n \n-\t  while (*p && (c = *p++) != ',')\n-\t    switch (c)\n+\t  do\n+\t    switch (c = *p, len = CONSTRAINT_LEN (c, p), c)\n \t      {\n+\t      case '\\0':\n+\t\tlen = 0;\n+\t\tbreak;\n+\t      case ',':\n+\t\tc = '\\0';\n+\t\tbreak;\n+\n \t      case '?':  case '!': case '*':  case '%':\n \t      case '=':  case '+':\n \t\tbreak;\n \n \t      case '#':\n \t\t/* Ignore rest of this alternative as far as\n \t\t   constraint checking is concerned.  */\n-\t\twhile (*p && *p != ',')\n+\t\tdo\n \t\t  p++;\n+\t\twhile (*p && *p != ',');\n+\t\tlen = 0;\n \t\tbreak;\n \n \t      case '&':\n@@ -2447,7 +2477,7 @@ constrain_operands (strict)\n \t\t  char *end;\n \t\t  int match;\n \n-\t\t  match = strtoul (p - 1, &end, 10);\n+\t\t  match = strtoul (p, &end, 10);\n \t\t  p = end;\n \n \t\t  if (strict < 0)\n@@ -2482,6 +2512,7 @@ constrain_operands (strict)\n \t\t      funny_match[funny_match_index++].other = match;\n \t\t    }\n \t\t}\n+\t\tlen = 0;\n \t\tbreak;\n \n \t      case 'p':\n@@ -2551,7 +2582,7 @@ constrain_operands (strict)\n \t      case 'G':\n \t      case 'H':\n \t\tif (GET_CODE (op) == CONST_DOUBLE\n-\t\t    && CONST_DOUBLE_OK_FOR_LETTER_P (op, c))\n+\t\t    && CONST_DOUBLE_OK_FOR_CONSTRAINT_P (op, c, p))\n \t\t  win = 1;\n \t\tbreak;\n \n@@ -2581,7 +2612,7 @@ constrain_operands (strict)\n \t      case 'O':\n \t      case 'P':\n \t\tif (GET_CODE (op) == CONST_INT\n-\t\t    && CONST_OK_FOR_LETTER_P (INTVAL (op), c))\n+\t\t    && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), c, p))\n \t\t  win = 1;\n \t\tbreak;\n \n@@ -2612,7 +2643,8 @@ constrain_operands (strict)\n \t\t{\n \t\t  enum reg_class class;\n \n-\t\t  class = (c == 'r' ? GENERAL_REGS : REG_CLASS_FROM_LETTER (c));\n+\t\t  class = (c == 'r'\n+\t\t\t   ? GENERAL_REGS : REG_CLASS_FROM_CONSTRAINT (c, p));\n \t\t  if (class != NO_REGS)\n \t\t    {\n \t\t      if (strict < 0\n@@ -2624,11 +2656,11 @@ constrain_operands (strict)\n \t\t\t      && reg_fits_class_p (op, class, offset, mode)))\n \t\t        win = 1;\n \t\t    }\n-#ifdef EXTRA_CONSTRAINT\n-\t\t  else if (EXTRA_CONSTRAINT (op, c))\n+#ifdef EXTRA_CONSTRAINT_STR\n+\t\t  else if (EXTRA_CONSTRAINT_STR (op, c, p))\n \t\t    win = 1;\n \n-\t\t  if (EXTRA_MEMORY_CONSTRAINT (c))\n+\t\t  if (EXTRA_MEMORY_CONSTRAINT (c, p))\n \t\t    {\n \t\t      /* Every memory operand can be reloaded to fit.  */\n \t\t      if (strict < 0 && GET_CODE (op) == MEM)\n@@ -2643,7 +2675,7 @@ constrain_operands (strict)\n \t\t\t  && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n \t\t\twin = 1;\n \t\t    }\n-\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c))\n+\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n \t\t    {\n \t\t      /* Every address operand can be reloaded to fit.  */\n \t\t      if (strict < 0)\n@@ -2653,6 +2685,7 @@ constrain_operands (strict)\n \t\t  break;\n \t\t}\n \t      }\n+\t  while (p += len, c);\n \n \t  constraints[opno] = p;\n \t  /* If this operand did not win somehow,\n@@ -3009,7 +3042,7 @@ peep2_find_free_register (from, to, class_str, mode, reg_set)\n     }\n \n   class = (class_str[0] == 'r' ? GENERAL_REGS\n-\t   : REG_CLASS_FROM_LETTER (class_str[0]));\n+\t   : REG_CLASS_FROM_CONSTRAINT (class_str[0], class_str));\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {"}, {"sha": "334bc21b408026cb80a80ad9403b7585a87b54eb", "filename": "gcc/regclass.c", "status": "modified", "additions": 134, "deletions": 127, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97488870283d923cea932db7763346087cbd9452/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97488870283d923cea932db7763346087cbd9452/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=97488870283d923cea932db7763346087cbd9452", "patch": "@@ -977,7 +977,7 @@ record_operand_costs (insn, op_costs, reg_pref)\n \trecord_address_regs (XEXP (recog_data.operand[i], 0),\n \t\t\t     MODE_BASE_REG_CLASS (modes[i]), frequency * 2);\n       else if (constraints[i][0] == 'p'\n-\t       || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0]))\n+\t       || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0], constraints[i]))\n \trecord_address_regs (recog_data.operand[i],\n \t\t\t     MODE_BASE_REG_CLASS (modes[i]), frequency * 2);\n     }\n@@ -1548,154 +1548,161 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \t     any of the constraints.  Collect the valid register classes\n \t     and see if this operand accepts memory.  */\n \n-\t  while (*p && (c = *p++) != ',')\n-\t    switch (c)\n-\t      {\n-\t      case '*':\n-\t\t/* Ignore the next letter for this pass.  */\n-\t\tp++;\n-\t\tbreak;\n-\n-\t      case '?':\n-\t\talt_cost += 2;\n-\t      case '!':  case '#':  case '&':\n-\t      case '0':  case '1':  case '2':  case '3':  case '4':\n-\t      case '5':  case '6':  case '7':  case '8':  case '9':\n-\t\tbreak;\n+\t  while ((c = *p))\n+\t    {\n+\t      switch (c)\n+\t\t{\n+\t\tcase ',':\n+\t\t  break;\n+\t\tcase '*':\n+\t\t  /* Ignore the next letter for this pass.  */\n+\t\t  c = *++p;\n+\t\t  break;\n \n-\t      case 'p':\n-\t\tallows_addr = 1;\n-\t\twin = address_operand (op, GET_MODE (op));\n-\t\t/* We know this operand is an address, so we want it to be\n-\t\t   allocated to a register that can be the base of an\n-\t\t   address, ie BASE_REG_CLASS.  */\n-\t\tclasses[i]\n-\t\t  = reg_class_subunion[(int) classes[i]]\n-\t\t    [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n-\t\tbreak;\n+\t\tcase '?':\n+\t\t  alt_cost += 2;\n+\t\tcase '!':  case '#':  case '&':\n+\t\tcase '0':  case '1':  case '2':  case '3':  case '4':\n+\t\tcase '5':  case '6':  case '7':  case '8':  case '9':\n+\t\t  break;\n \n-\t      case 'm':  case 'o':  case 'V':\n-\t\t/* It doesn't seem worth distinguishing between offsettable\n-\t\t   and non-offsettable addresses here.  */\n-\t\tallows_mem[i] = 1;\n-\t\tif (GET_CODE (op) == MEM)\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\tcase 'p':\n+\t\t  allows_addr = 1;\n+\t\t  win = address_operand (op, GET_MODE (op));\n+\t\t  /* We know this operand is an address, so we want it to be\n+\t\t     allocated to a register that can be the base of an\n+\t\t     address, ie BASE_REG_CLASS.  */\n+\t\t  classes[i]\n+\t\t    = reg_class_subunion[(int) classes[i]]\n+\t\t      [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n+\t\t  break;\n \n-\t      case '<':\n-\t\tif (GET_CODE (op) == MEM\n-\t\t    && (GET_CODE (XEXP (op, 0)) == PRE_DEC\n-\t\t\t|| GET_CODE (XEXP (op, 0)) == POST_DEC))\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\tcase 'm':  case 'o':  case 'V':\n+\t\t  /* It doesn't seem worth distinguishing between offsettable\n+\t\t     and non-offsettable addresses here.  */\n+\t\t  allows_mem[i] = 1;\n+\t\t  if (GET_CODE (op) == MEM)\n+\t\t    win = 1;\n+\t\t  break;\n \n-\t      case '>':\n-\t\tif (GET_CODE (op) == MEM\n-\t\t    && (GET_CODE (XEXP (op, 0)) == PRE_INC\n-\t\t\t|| GET_CODE (XEXP (op, 0)) == POST_INC))\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\tcase '<':\n+\t\t  if (GET_CODE (op) == MEM\n+\t\t      && (GET_CODE (XEXP (op, 0)) == PRE_DEC\n+\t\t\t  || GET_CODE (XEXP (op, 0)) == POST_DEC))\n+\t\t    win = 1;\n+\t\t  break;\n \n-\t      case 'E':\n-\t      case 'F':\n-\t\tif (GET_CODE (op) == CONST_DOUBLE\n-\t\t    || (GET_CODE (op) == CONST_VECTOR\n-\t\t\t&& (GET_MODE_CLASS (GET_MODE (op))\n-\t\t\t    == MODE_VECTOR_FLOAT)))\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\tcase '>':\n+\t\t  if (GET_CODE (op) == MEM\n+\t\t      && (GET_CODE (XEXP (op, 0)) == PRE_INC\n+\t\t\t  || GET_CODE (XEXP (op, 0)) == POST_INC))\n+\t\t    win = 1;\n+\t\t  break;\n \n-\t      case 'G':\n-\t      case 'H':\n-\t\tif (GET_CODE (op) == CONST_DOUBLE\n-\t\t    && CONST_DOUBLE_OK_FOR_LETTER_P (op, c))\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\tcase 'E':\n+\t\tcase 'F':\n+\t\t  if (GET_CODE (op) == CONST_DOUBLE\n+\t\t      || (GET_CODE (op) == CONST_VECTOR\n+\t\t\t  && (GET_MODE_CLASS (GET_MODE (op))\n+\t\t\t      == MODE_VECTOR_FLOAT)))\n+\t\t    win = 1;\n+\t\t  break;\n \n-\t      case 's':\n-\t\tif (GET_CODE (op) == CONST_INT\n-\t\t    || (GET_CODE (op) == CONST_DOUBLE\n-\t\t\t&& GET_MODE (op) == VOIDmode))\n+\t\tcase 'G':\n+\t\tcase 'H':\n+\t\t  if (GET_CODE (op) == CONST_DOUBLE\n+\t\t      && CONST_DOUBLE_OK_FOR_CONSTRAINT_P (op, c, p))\n+\t\t    win = 1;\n \t\t  break;\n-\t      case 'i':\n-\t\tif (CONSTANT_P (op)\n+\n+\t\tcase 's':\n+\t\t  if (GET_CODE (op) == CONST_INT\n+\t\t      || (GET_CODE (op) == CONST_DOUBLE\n+\t\t\t  && GET_MODE (op) == VOIDmode))\n+\t\t    break;\n+\t\tcase 'i':\n+\t\t  if (CONSTANT_P (op)\n #ifdef LEGITIMATE_PIC_OPERAND_P\n-\t\t    && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op))\n+\t\t      && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op))\n #endif\n-\t\t    )\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\t      )\n+\t\t    win = 1;\n+\t\t  break;\n \n-\t      case 'n':\n-\t\tif (GET_CODE (op) == CONST_INT\n-\t\t    || (GET_CODE (op) == CONST_DOUBLE\n-\t\t\t&& GET_MODE (op) == VOIDmode))\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\tcase 'n':\n+\t\t  if (GET_CODE (op) == CONST_INT\n+\t\t      || (GET_CODE (op) == CONST_DOUBLE\n+\t\t\t  && GET_MODE (op) == VOIDmode))\n+\t\t    win = 1;\n+\t\t  break;\n \n-\t      case 'I':\n-\t      case 'J':\n-\t      case 'K':\n-\t      case 'L':\n-\t      case 'M':\n-\t      case 'N':\n-\t      case 'O':\n-\t      case 'P':\n-\t\tif (GET_CODE (op) == CONST_INT\n-\t\t    && CONST_OK_FOR_LETTER_P (INTVAL (op), c))\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\tcase 'I':\n+\t\tcase 'J':\n+\t\tcase 'K':\n+\t\tcase 'L':\n+\t\tcase 'M':\n+\t\tcase 'N':\n+\t\tcase 'O':\n+\t\tcase 'P':\n+\t\t  if (GET_CODE (op) == CONST_INT\n+\t\t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), c, p))\n+\t\t    win = 1;\n+\t\t  break;\n \n-\t      case 'X':\n-\t\twin = 1;\n-\t\tbreak;\n+\t\tcase 'X':\n+\t\t  win = 1;\n+\t\t  break;\n \n-\t      case 'g':\n-\t\tif (GET_CODE (op) == MEM\n-\t\t    || (CONSTANT_P (op)\n+\t\tcase 'g':\n+\t\t  if (GET_CODE (op) == MEM\n+\t\t      || (CONSTANT_P (op)\n #ifdef LEGITIMATE_PIC_OPERAND_P\n-\t\t\t&& (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op))\n+\t\t\t  && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op))\n #endif\n-\t\t\t))\n-\t\t  win = 1;\n-\t\tallows_mem[i] = 1;\n-\t      case 'r':\n-\t\tclasses[i]\n-\t\t  = reg_class_subunion[(int) classes[i]][(int) GENERAL_REGS];\n-\t\tbreak;\n-\n-\t      default:\n-\t\tif (REG_CLASS_FROM_LETTER (c) != NO_REGS)\n+\t\t\t  ))\n+\t\t    win = 1;\n+\t\t  allows_mem[i] = 1;\n+\t\tcase 'r':\n \t\t  classes[i]\n-\t\t    = reg_class_subunion[(int) classes[i]]\n-\t\t      [(int) REG_CLASS_FROM_LETTER (c)];\n-#ifdef EXTRA_CONSTRAINT\n-\t\telse if (EXTRA_CONSTRAINT (op, c))\n-\t\t  win = 1;\n+\t\t    = reg_class_subunion[(int) classes[i]][(int) GENERAL_REGS];\n+\t\t  break;\n \n-\t\tif (EXTRA_MEMORY_CONSTRAINT (c))\n-\t\t  {\n-\t\t    /* Every MEM can be reloaded to fit.  */\n-\t\t    allows_mem[i] = 1;\n-\t\t    if (GET_CODE (op) == MEM)\n-\t\t      win = 1;\n-\t\t  }\n-\t\tif (EXTRA_ADDRESS_CONSTRAINT (op))\n-\t\t  {\n-\t\t    /* Every address can be reloaded to fit.  */\n-\t\t    allows_addr = 1;\n-\t\t    if (address_operand (op, GET_MODE (op)))\n-\t\t      win = 1;\n-\t\t    /* We know this operand is an address, so we want it to be\n-\t\t       allocated to a register that can be the base of an\n-\t\t       address, ie BASE_REG_CLASS.  */\n+\t\tdefault:\n+\t\t  if (REG_CLASS_FROM_CONSTRAINT (c, p) != NO_REGS)\n \t\t    classes[i]\n \t\t      = reg_class_subunion[(int) classes[i]]\n-\t\t        [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n-\t\t  }\n+\t\t\t[(int) REG_CLASS_FROM_CONSTRAINT (c, p)];\n+#ifdef EXTRA_CONSTRAINT_STR\n+\t\t  else if (EXTRA_CONSTRAINT_STR (op, c, p))\n+\t\t    win = 1;\n+\n+\t\t  if (EXTRA_MEMORY_CONSTRAINT (c, p))\n+\t\t    {\n+\t\t      /* Every MEM can be reloaded to fit.  */\n+\t\t      allows_mem[i] = 1;\n+\t\t      if (GET_CODE (op) == MEM)\n+\t\t\twin = 1;\n+\t\t    }\n+\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n+\t\t    {\n+\t\t      /* Every address can be reloaded to fit.  */\n+\t\t      allows_addr = 1;\n+\t\t      if (address_operand (op, GET_MODE (op)))\n+\t\t\twin = 1;\n+\t\t      /* We know this operand is an address, so we want it to\n+\t\t\t be allocated to a register that can be the base of an\n+\t\t\t address, ie BASE_REG_CLASS.  */\n+\t\t      classes[i]\n+\t\t\t= reg_class_subunion[(int) classes[i]]\n+\t\t\t  [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n+\t\t    }\n #endif\n+\t\t  break;\n+\t\t}\n+\t      p += CONSTRAINT_LEN (c, p);\n+\t      if (c == ',')\n \t\tbreak;\n-\t      }\n+\t    }\n \n \t  constraints[i] = p;\n "}, {"sha": "eb5141f8bea4b7a031d7bfc3bbd64c20fddd50eb", "filename": "gcc/regmove.c", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97488870283d923cea932db7763346087cbd9452/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97488870283d923cea932db7763346087cbd9452/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=97488870283d923cea932db7763346087cbd9452", "patch": "@@ -1570,47 +1570,50 @@ find_matches (insn, matchp)\n \tif (*p == ',')\n \t  i++;\n \n-      while ((c = *p++) != '\\0' && c != ',')\n-\tswitch (c)\n-\t  {\n-\t  case '=':\n-\t    break;\n-\t  case '+':\n-\t    break;\n-\t  case '&':\n-\t    matchp->early_clobber[op_no] = 1;\n-\t    break;\n-\t  case '%':\n-\t    matchp->commutative[op_no] = op_no + 1;\n-\t    matchp->commutative[op_no + 1] = op_no;\n-\t    break;\n-\n-\t  case '0': case '1': case '2': case '3': case '4':\n-\t  case '5': case '6': case '7': case '8': case '9':\n+      while ((c = *p) != '\\0' && c != ',')\n+\t{\n+\t  switch (c)\n \t    {\n-\t      char *end;\n-\t      unsigned long match_ul = strtoul (p - 1, &end, 10);\n-\t      int match = match_ul;\n+\t    case '=':\n+\t      break;\n+\t    case '+':\n+\t      break;\n+\t    case '&':\n+\t      matchp->early_clobber[op_no] = 1;\n+\t      break;\n+\t    case '%':\n+\t      matchp->commutative[op_no] = op_no + 1;\n+\t      matchp->commutative[op_no + 1] = op_no;\n+\t      break;\n \n-\t      p = end;\n+\t    case '0': case '1': case '2': case '3': case '4':\n+\t    case '5': case '6': case '7': case '8': case '9':\n+\t      {\n+\t\tchar *end;\n+\t\tunsigned long match_ul = strtoul (p, &end, 10);\n+\t\tint match = match_ul;\n \n-\t      if (match < op_no && likely_spilled[match])\n-\t\tbreak;\n-\t      matchp->with[op_no] = match;\n-\t      any_matches = 1;\n-\t      if (matchp->commutative[op_no] >= 0)\n-\t\tmatchp->with[matchp->commutative[op_no]] = match;\n-\t    }\n-\t    break;\n+\t\tp = end;\n+\n+\t\tif (match < op_no && likely_spilled[match])\n+\t\t  continue;\n+\t\tmatchp->with[op_no] = match;\n+\t\tany_matches = 1;\n+\t\tif (matchp->commutative[op_no] >= 0)\n+\t\t  matchp->with[matchp->commutative[op_no]] = match;\n+\t      }\n+\t    continue;\n \n \t  case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'h':\n \t  case 'j': case 'k': case 'l': case 'p': case 'q': case 't': case 'u':\n \t  case 'v': case 'w': case 'x': case 'y': case 'z': case 'A': case 'B':\n \t  case 'C': case 'D': case 'W': case 'Y': case 'Z':\n-\t    if (CLASS_LIKELY_SPILLED_P (REG_CLASS_FROM_LETTER ((unsigned char) c)))\n+\t    if (CLASS_LIKELY_SPILLED_P (REG_CLASS_FROM_CONSTRAINT ((unsigned char) c, p) ))\n \t      likely_spilled[op_no] = 1;\n \t    break;\n \t  }\n+\t  p += CONSTRAINT_LEN (c, p);\n+\t}\n     }\n   return any_matches;\n }"}, {"sha": "11fe356710aca93e1fa14c10b1542a6b8f9c465f", "filename": "gcc/reload.c", "status": "modified", "additions": 67, "deletions": 43, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97488870283d923cea932db7763346087cbd9452/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97488870283d923cea932db7763346087cbd9452/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=97488870283d923cea932db7763346087cbd9452", "patch": "@@ -381,11 +381,13 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \tinsn_class = ALL_REGS;\n       else\n \t{\n-\t  char insn_letter\n-\t    = insn_data[(int) icode].operand[!in_p].constraint[in_p];\n+\t  const char *insn_constraint\n+\t    = &insn_data[(int) icode].operand[!in_p].constraint[in_p];\n+\t  char insn_letter = *insn_constraint;\n \t  insn_class\n \t    = (insn_letter == 'r' ? GENERAL_REGS\n-\t       : REG_CLASS_FROM_LETTER ((unsigned char) insn_letter));\n+\t       : REG_CLASS_FROM_CONSTRAINT ((unsigned char) insn_letter,\n+\t\t\t\t\t    insn_constraint));\n \n           if (insn_class == NO_REGS)\n \t    abort ();\n@@ -403,11 +405,14 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \tmode = insn_data[(int) icode].operand[2].mode;\n       else\n \t{\n-\t  char t_letter = insn_data[(int) icode].operand[2].constraint[2];\n+\t  const char *t_constraint\n+\t    = &insn_data[(int) icode].operand[2].constraint[2];\n+\t  char t_letter = *t_constraint;\n \t  class = insn_class;\n \t  t_mode = insn_data[(int) icode].operand[2].mode;\n \t  t_class = (t_letter == 'r' ? GENERAL_REGS\n-\t\t     : REG_CLASS_FROM_LETTER ((unsigned char) t_letter));\n+\t\t     : REG_CLASS_FROM_CONSTRAINT ((unsigned char) t_letter,\n+\t\t\t\t\t\t  t_constraint));\n \t  t_icode = icode;\n \t  icode = CODE_FOR_nothing;\n \t}\n@@ -2587,8 +2592,9 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       /* Scan this operand's constraint to see if it is an output operand,\n \t an in-out operand, is commutative, or should match another.  */\n \n-      while ((c = *p++))\n+      while ((c = *p))\n \t{\n+\t  p += CONSTRAINT_LEN (c, p);\n \t  if (c == '=')\n \t    modified[i] = RELOAD_WRITE;\n \t  else if (c == '+')\n@@ -2664,7 +2670,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t/* Ignore things like match_operator operands.  */\n \t;\n       else if (constraints[i][0] == 'p'\n-\t       || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0]))\n+\t       || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0], constraints[i]))\n \t{\n \t  find_reloads_address (recog_data.operand_mode[i], (rtx*) 0,\n \t\t\t\trecog_data.operand[i],\n@@ -2829,13 +2835,16 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       for (i = 0; i < noperands; i++)\n \t{\n \t  char *p = constraints[i];\n+\t  char *end;\n+\t  int len;\n \t  int win = 0;\n \t  int did_match = 0;\n \t  /* 0 => this operand can be reloaded somehow for this alternative.  */\n \t  int badop = 1;\n \t  /* 0 => this operand can be reloaded if the alternative allows regs.  */\n \t  int winreg = 0;\n \t  int c;\n+\t  int m;\n \t  rtx operand = recog_data.operand[i];\n \t  int offset = 0;\n \t  /* Nonzero means this is a MEM that must be reloaded into a reg\n@@ -2964,9 +2973,16 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t     or set WINREG if this operand could fit after reloads\n \t     provided the constraint allows some registers.  */\n \n-\t  while (*p && (c = *p++) != ',')\n-\t    switch (c)\n+\t  do\n+\t    switch ((c = *p, len = CONSTRAINT_LEN (c, p)), c)\n \t      {\n+\t      case '\\0':\n+\t\tlen = 0;\n+\t\tbreak;\n+\t      case ',':\n+\t\tc = '\\0';\n+\t\tbreak;\n+\n \t      case '=':  case '+':  case '*':\n \t\tbreak;\n \n@@ -2987,76 +3003,80 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      case '#':\n \t\t/* Ignore rest of this alternative as far as\n \t\t   reloading is concerned.  */\n-\t\twhile (*p && *p != ',')\n+\t\tdo\n \t\t  p++;\n+\t\twhile (*p && *p != ',');\n+\t\tlen = 0;\n \t\tbreak;\n \n \t      case '0':  case '1':  case '2':  case '3':  case '4':\n \t      case '5':  case '6':  case '7':  case '8':  case '9':\n-\t\tc = strtoul (p - 1, &p, 10);\n+\t\tm = strtoul (p, &end, 10);\n+\t\tp = end;\n+\t\tlen = 0;\n \n-\t\tthis_alternative_matches[i] = c;\n+\t\tthis_alternative_matches[i] = m;\n \t\t/* We are supposed to match a previous operand.\n \t\t   If we do, we win if that one did.\n \t\t   If we do not, count both of the operands as losers.\n \t\t   (This is too conservative, since most of the time\n \t\t   only a single reload insn will be needed to make\n \t\t   the two operands win.  As a result, this alternative\n \t\t   may be rejected when it is actually desirable.)  */\n-\t\tif ((swapped && (c != commutative || i != commutative + 1))\n+\t\tif ((swapped && (m != commutative || i != commutative + 1))\n \t\t    /* If we are matching as if two operands were swapped,\n \t\t       also pretend that operands_match had been computed\n \t\t       with swapped.\n \t\t       But if I is the second of those and C is the first,\n \t\t       don't exchange them, because operands_match is valid\n \t\t       only on one side of its diagonal.  */\n \t\t    ? (operands_match\n-\t\t       [(c == commutative || c == commutative + 1)\n-\t\t       ? 2 * commutative + 1 - c : c]\n+\t\t       [(m == commutative || m == commutative + 1)\n+\t\t       ? 2 * commutative + 1 - m : m]\n \t\t       [(i == commutative || i == commutative + 1)\n \t\t       ? 2 * commutative + 1 - i : i])\n-\t\t    : operands_match[c][i])\n+\t\t    : operands_match[m][i])\n \t\t  {\n \t\t    /* If we are matching a non-offsettable address where an\n \t\t       offsettable address was expected, then we must reject\n \t\t       this combination, because we can't reload it.  */\n-\t\t    if (this_alternative_offmemok[c]\n-\t\t\t&& GET_CODE (recog_data.operand[c]) == MEM\n-\t\t\t&& this_alternative[c] == (int) NO_REGS\n-\t\t\t&& ! this_alternative_win[c])\n+\t\t    if (this_alternative_offmemok[m]\n+\t\t\t&& GET_CODE (recog_data.operand[m]) == MEM\n+\t\t\t&& this_alternative[m] == (int) NO_REGS\n+\t\t\t&& ! this_alternative_win[m])\n \t\t      bad = 1;\n \n-\t\t    did_match = this_alternative_win[c];\n+\t\t    did_match = this_alternative_win[m];\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    /* Operands don't match.  */\n \t\t    rtx value;\n \t\t    /* Retroactively mark the operand we had to match\n \t\t       as a loser, if it wasn't already.  */\n-\t\t    if (this_alternative_win[c])\n+\t\t    if (this_alternative_win[m])\n \t\t      losers++;\n-\t\t    this_alternative_win[c] = 0;\n-\t\t    if (this_alternative[c] == (int) NO_REGS)\n+\t\t    this_alternative_win[m] = 0;\n+\t\t    if (this_alternative[m] == (int) NO_REGS)\n \t\t      bad = 1;\n \t\t    /* But count the pair only once in the total badness of\n \t\t       this alternative, if the pair can be a dummy reload.  */\n \t\t    value\n \t\t      = find_dummy_reload (recog_data.operand[i],\n-\t\t\t\t\t   recog_data.operand[c],\n+\t\t\t\t\t   recog_data.operand[m],\n \t\t\t\t\t   recog_data.operand_loc[i],\n-\t\t\t\t\t   recog_data.operand_loc[c],\n-\t\t\t\t\t   operand_mode[i], operand_mode[c],\n-\t\t\t\t\t   this_alternative[c], -1,\n-\t\t\t\t\t   this_alternative_earlyclobber[c]);\n+\t\t\t\t\t   recog_data.operand_loc[m],\n+\t\t\t\t\t   operand_mode[i], operand_mode[m],\n+\t\t\t\t\t   this_alternative[m], -1,\n+\t\t\t\t\t   this_alternative_earlyclobber[m]);\n \n \t\t    if (value != 0)\n \t\t      losers--;\n \t\t  }\n \t\t/* This can be fixed with reloads if the operand\n \t\t   we are supposed to match can be fixed with reloads.  */\n \t\tbadop = 0;\n-\t\tthis_alternative[i] = this_alternative[c];\n+\t\tthis_alternative[i] = this_alternative[m];\n \n \t\t/* If we have to reload this operand and some previous\n \t\t   operand also had to match the same thing as this\n@@ -3175,7 +3195,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      case 'G':\n \t      case 'H':\n \t\tif (GET_CODE (operand) == CONST_DOUBLE\n-\t\t    && CONST_DOUBLE_OK_FOR_LETTER_P (operand, c))\n+\t\t    && CONST_DOUBLE_OK_FOR_CONSTRAINT_P (operand, c, p))\n \t\t  win = 1;\n \t\tbreak;\n \n@@ -3209,7 +3229,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      case 'O':\n \t      case 'P':\n \t\tif (GET_CODE (operand) == CONST_INT\n-\t\t    && CONST_OK_FOR_LETTER_P (INTVAL (operand), c))\n+\t\t    && CONST_OK_FOR_CONSTRAINT_P (INTVAL (operand), c, p))\n \t\t  win = 1;\n \t\tbreak;\n \n@@ -3242,14 +3262,14 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\tgoto reg;\n \n \t      default:\n-\t\tif (REG_CLASS_FROM_LETTER (c) == NO_REGS)\n+\t\tif (REG_CLASS_FROM_CONSTRAINT (c, p) == NO_REGS)\n \t\t  {\n-#ifdef EXTRA_CONSTRAINT\n-\t\t    if (EXTRA_MEMORY_CONSTRAINT (c))\n+#ifdef EXTRA_CONSTRAINT_STR\n+\t\t    if (EXTRA_MEMORY_CONSTRAINT (c, p))\n \t\t      {\n \t\t\tif (force_reload)\n \t\t\t  break;\n-\t\t        if (EXTRA_CONSTRAINT (operand, c))\n+\t\t        if (EXTRA_CONSTRAINT_STR (operand, c, p))\n \t\t          win = 1;\n \t\t\t/* If the address was already reloaded,\n \t\t\t   we win as well.  */\n@@ -3262,7 +3282,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t    && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n \t\t\t    && reg_renumber[REGNO (operand)] < 0\n \t\t\t    && ((reg_equiv_mem[REGNO (operand)] != 0\n-\t\t\t         && EXTRA_CONSTRAINT (reg_equiv_mem[REGNO (operand)], c))\n+\t\t\t         && EXTRA_CONSTRAINT_STR (reg_equiv_mem[REGNO (operand)], c, p))\n \t\t\t        || (reg_equiv_address[REGNO (operand)] != 0)))\n \t\t\t  win = 1;\n \n@@ -3276,9 +3296,9 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\toffmemok = 1;\n \t\t\tbreak;\n \t\t      }\n-\t\t    if (EXTRA_ADDRESS_CONSTRAINT (c))\n+\t\t    if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n \t\t      {\n-\t\t        if (EXTRA_CONSTRAINT (operand, c))\n+\t\t        if (EXTRA_CONSTRAINT_STR (operand, c, p))\n \t\t          win = 1;\n \n \t\t\t/* If we didn't already win, we can reload\n@@ -3292,14 +3312,16 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\tbreak;\n \t\t      }\n \n-\t\t    if (EXTRA_CONSTRAINT (operand, c))\n+\t\t    if (EXTRA_CONSTRAINT_STR (operand, c, p))\n \t\t      win = 1;\n #endif\n \t\t    break;\n \t\t  }\n \n \t\tthis_alternative[i]\n-\t\t  = (int) reg_class_subunion[this_alternative[i]][(int) REG_CLASS_FROM_LETTER (c)];\n+\t\t  = (int) (reg_class_subunion\n+\t\t\t   [this_alternative[i]]\n+\t\t\t   [(int) REG_CLASS_FROM_CONSTRAINT (c, p)]);\n \t      reg:\n \t\tif (GET_MODE (operand) == BLKmode)\n \t\t  break;\n@@ -3310,6 +3332,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t  win = 1;\n \t\tbreak;\n \t      }\n+\t  while ((p += len), c);\n \n \t  constraints[i] = p;\n \n@@ -4358,8 +4381,9 @@ alternative_allows_memconst (constraint, altnum)\n     }\n   /* Scan the requested alternative for 'm' or 'o'.\n      If one of them is present, this alternative accepts memory constants.  */\n-  while ((c = *constraint++) && c != ',' && c != '#')\n-    if (c == 'm' || c == 'o' || EXTRA_MEMORY_CONSTRAINT (c))\n+  for (; (c = *constraint) && c != ',' && c != '#';\n+       constraint += CONSTRAINT_LEN (c, constraint))\n+    if (c == 'm' || c == 'o' || EXTRA_MEMORY_CONSTRAINT (c, constraint))\n       return 1;\n   return 0;\n }"}, {"sha": "4fd401c89bb5ab97c553b107da19fe5b17d3d36c", "filename": "gcc/reload1.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97488870283d923cea932db7763346087cbd9452/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97488870283d923cea932db7763346087cbd9452/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=97488870283d923cea932db7763346087cbd9452", "patch": "@@ -1355,14 +1355,15 @@ maybe_fix_stack_asms ()\n \n \t  for (;;)\n \t    {\n-\t      char c = *p++;\n+\t      char c = *p;\n \n \t      if (c == '\\0' || c == ',' || c == '#')\n \t\t{\n \t\t  /* End of one alternative - mark the regs in the current\n \t\t     class, and reset the class.  */\n \t\t  IOR_HARD_REG_SET (allowed, reg_class_contents[cls]);\n \t\t  cls = NO_REGS;\n+\t\t  p++;\n \t\t  if (c == '#')\n \t\t    do {\n \t\t      c = *p++;\n@@ -1393,13 +1394,14 @@ maybe_fix_stack_asms ()\n \t\t  break;\n \n \t\tdefault:\n-\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c))\n+\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n \t\t    cls = (int) reg_class_subunion[cls]\n \t\t      [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n \t\t  else\n \t\t    cls = (int) reg_class_subunion[cls]\n-\t\t      [(int) REG_CLASS_FROM_LETTER (c)];\n+\t\t      [(int) REG_CLASS_FROM_CONSTRAINT (c, p)];\n \t\t}\n+\t      p += CONSTRAINT_LEN (c, p);\n \t    }\n \t}\n       /* Those of the registers which are clobbered, but allowed by the\n@@ -8418,7 +8420,7 @@ reload_cse_simplify_operands (insn, testreg)\n \t  p = constraints[i];\n \t  for (;;)\n \t    {\n-\t      char c = *p++;\n+\t      char c = *p;\n \n \t      switch (c)\n \t\t{\n@@ -8442,7 +8444,9 @@ reload_cse_simplify_operands (insn, testreg)\n \n \t\tdefault:\n \t\t  class\n-\t\t    = reg_class_subunion[(int) class][(int) REG_CLASS_FROM_LETTER ((unsigned char) c)];\n+\t\t    = (reg_class_subunion\n+\t\t       [(int) class]\n+\t\t       [(int) REG_CLASS_FROM_CONSTRAINT ((unsigned char) c, p)]);\n \t\t  break;\n \n \t\tcase ',': case '\\0':\n@@ -8462,6 +8466,7 @@ reload_cse_simplify_operands (insn, testreg)\n \t\t  j++;\n \t\t  break;\n \t\t}\n+\t      p += CONSTRAINT_LEN (c, p);\n \n \t      if (c == '\\0')\n \t\tbreak;"}, {"sha": "960bea0f24e6726902fbccd6d69cfd4e29ec96e2", "filename": "gcc/stmt.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97488870283d923cea932db7763346087cbd9452/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97488870283d923cea932db7763346087cbd9452/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=97488870283d923cea932db7763346087cbd9452", "patch": "@@ -1197,7 +1197,7 @@ parse_output_constraint (constraint_p, operand_num, ninputs, noutputs,\n     }\n \n   /* Loop through the constraint string.  */\n-  for (p = constraint + 1; *p; ++p)\n+  for (p = constraint + 1; *p; p += CONSTRAINT_LEN (*p, p))\n     switch (*p)\n       {\n       case '+':\n@@ -1249,12 +1249,12 @@ parse_output_constraint (constraint_p, operand_num, ninputs, noutputs,\n       default:\n \tif (!ISALPHA (*p))\n \t  break;\n-\tif (REG_CLASS_FROM_LETTER (*p) != NO_REGS)\n+\tif (REG_CLASS_FROM_CONSTRAINT (*p, p) != NO_REGS)\n \t  *allows_reg = true;\n-#ifdef EXTRA_CONSTRAINT\n-\telse if (EXTRA_ADDRESS_CONSTRAINT (*p))\n+#ifdef EXTRA_CONSTRAINT_STR\n+\telse if (EXTRA_ADDRESS_CONSTRAINT (*p, p))\n \t  *allows_reg = true;\n-\telse if (EXTRA_MEMORY_CONSTRAINT (*p))\n+\telse if (EXTRA_MEMORY_CONSTRAINT (*p, p))\n \t  *allows_mem = true;\n \telse\n \t  {\n@@ -1297,7 +1297,7 @@ parse_input_constraint (constraint_p, input_num, ninputs, noutputs, ninout,\n \n   /* Make sure constraint has neither `=', `+', nor '&'.  */\n \n-  for (j = 0; j < c_len; j++)\n+  for (j = 0; j < c_len; j += CONSTRAINT_LEN (constraint[j], constraint+j))\n     switch (constraint[j])\n       {\n       case '+':  case '=':  case '&':\n@@ -1356,10 +1356,16 @@ parse_input_constraint (constraint_p, input_num, ninputs, noutputs, ninout,\n \t      *constraint_p = constraint;\n \t      c_len = strlen (constraint);\n \t      j = 0;\n+\t      /* ??? At the end of the loop, we will skip the first part of\n+\t\t the matched constraint.  This assumes not only that the\n+\t\t other constraint is an output constraint, but also that\n+\t\t the '=' or '+' come first.  */\n \t      break;\n \t    }\n \t  else\n \t    j = end - constraint;\n+\t  /* Anticipate increment at end of loop.  */\n+\t  j--;\n \t}\n \t/* Fall through.  */\n \n@@ -1378,12 +1384,13 @@ parse_input_constraint (constraint_p, input_num, ninputs, noutputs, ninout,\n \t    error (\"invalid punctuation `%c' in constraint\", constraint[j]);\n \t    return false;\n \t  }\n-\tif (REG_CLASS_FROM_LETTER (constraint[j]) != NO_REGS)\n+\tif (REG_CLASS_FROM_CONSTRAINT (constraint[j], constraint + j)\n+\t    != NO_REGS)\n \t  *allows_reg = true;\n-#ifdef EXTRA_CONSTRAINT\n-\telse if (EXTRA_ADDRESS_CONSTRAINT (constraint[j]))\n+#ifdef EXTRA_CONSTRAINT_STR\n+\telse if (EXTRA_ADDRESS_CONSTRAINT (constraint[j], constraint + j))\n \t  *allows_reg = true;\n-\telse if (EXTRA_MEMORY_CONSTRAINT (constraint[j]))\n+\telse if (EXTRA_MEMORY_CONSTRAINT (constraint[j], constraint + j))\n \t  *allows_mem = true;\n \telse\n \t  {"}]}