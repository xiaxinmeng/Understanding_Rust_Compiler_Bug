{"sha": "b1985ca02ea01cd32de23be109672a7ebf593a46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE5ODVjYTAyZWEwMWNkMzJkZTIzYmUxMDk2NzJhN2ViZjU5M2E0Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-12-15T11:02:28Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-12-15T11:02:28Z"}, "message": "re PR tree-optimization/88464 (AVX-512 vectorization of masked scatter failing with \"not suitable for scatter store\")\n\n\tPR tree-optimization/88464\n\tPR target/88498\n\t* tree-vect-stmts.c (vect_build_gather_load_calls): For NARROWING\n\tand mask with integral masktype, don't try to permute mask vectors,\n\tinstead emit VEC_UNPACK_{LO,HI}_EXPR.  Fix up NOP_EXPR operand.\n\t(vectorizable_store): Handle masked scatters with decl and integral\n\tmask type.\n\t(permute_vec_elements): Allow scalar_dest to be NULL.\n\t* config/i386/i386.c (ix86_get_builtin)\n\t<case IX86_BUILTIN_GATHER3ALTDIV16SF>: Use lowpart_subreg for masks.\n\t<case IX86_BUILTIN_GATHER3ALTDIV8SF>: Don't assume mask and src have\n\tto be the same.\n\n\t* gcc.target/i386/avx512f-pr88462-1.c: Rename to ...\n\t* gcc.target/i386/avx512f-pr88464-1.c: ... this.  Fix up PR number.\n\tExpect 4 vectorized loops instead of 3.\n\t(f4): New function.\n\t* gcc.target/i386/avx512f-pr88462-2.c: Rename to ...\n\t* gcc.target/i386/avx512f-pr88464-2.c: ... this.  Fix up PR number\n\tand #include.\n\t(avx512f_test): Prepare arguments for f4 and check the results.\n\t* gcc.target/i386/avx512f-pr88464-3.c: New test.\n\t* gcc.target/i386/avx512f-pr88464-4.c: New test.\n\nFrom-SVN: r267169", "tree": {"sha": "dcf3ccf64849f93f2fc560d0b53e8993c344dc6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcf3ccf64849f93f2fc560d0b53e8993c344dc6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1985ca02ea01cd32de23be109672a7ebf593a46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1985ca02ea01cd32de23be109672a7ebf593a46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1985ca02ea01cd32de23be109672a7ebf593a46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1985ca02ea01cd32de23be109672a7ebf593a46/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ee34ebba1573641e069bae17a228f597b3f57205", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee34ebba1573641e069bae17a228f597b3f57205", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee34ebba1573641e069bae17a228f597b3f57205"}], "stats": {"total": 190, "additions": 152, "deletions": 38}, "files": [{"sha": "f829e93cd499730b910ef3956e1aef938cc8c6a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1985ca02ea01cd32de23be109672a7ebf593a46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1985ca02ea01cd32de23be109672a7ebf593a46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b1985ca02ea01cd32de23be109672a7ebf593a46", "patch": "@@ -1,3 +1,18 @@\n+2018-12-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/88464\n+\tPR target/88498\n+\t* tree-vect-stmts.c (vect_build_gather_load_calls): For NARROWING\n+\tand mask with integral masktype, don't try to permute mask vectors,\n+\tinstead emit VEC_UNPACK_{LO,HI}_EXPR.  Fix up NOP_EXPR operand.\n+\t(vectorizable_store): Handle masked scatters with decl and integral\n+\tmask type.\n+\t(permute_vec_elements): Allow scalar_dest to be NULL.\n+\t* config/i386/i386.c (ix86_get_builtin)\n+\t<case IX86_BUILTIN_GATHER3ALTDIV16SF>: Use lowpart_subreg for masks.\n+\t<case IX86_BUILTIN_GATHER3ALTDIV8SF>: Don't assume mask and src have\n+\tto be the same.\n+\n 2018-12-15  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa.c (cgraph_build_static_cdtor_1): Add OPTIMIZATION and TARGET"}, {"sha": "b6dea0c061d7e196127b365d8718028061507b3f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1985ca02ea01cd32de23be109672a7ebf593a46/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1985ca02ea01cd32de23be109672a7ebf593a46/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b1985ca02ea01cd32de23be109672a7ebf593a46", "patch": "@@ -37607,13 +37607,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n \t    op0 = copy_to_mode_reg (GET_MODE (op0), op0);\n \t  emit_insn (gen (half, op0));\n \t  op0 = half;\n-\t  if (GET_MODE (op3) != VOIDmode)\n-\t    {\n-\t      if (!nonimmediate_operand (op3, GET_MODE (op3)))\n-\t\top3 = copy_to_mode_reg (GET_MODE (op3), op3);\n-\t      emit_insn (gen (half, op3));\n-\t      op3 = half;\n-\t    }\n+\t  op3 = lowpart_subreg (QImode, op3, HImode);\n \t  break;\n \tcase IX86_BUILTIN_GATHER3ALTDIV8SF:\n \tcase IX86_BUILTIN_GATHER3ALTDIV8SI:\n@@ -37630,6 +37624,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n \t  op0 = half;\n \t  if (GET_MODE (op3) != VOIDmode)\n \t    {\n+\t      half = gen_reg_rtx (mode0);\n \t      if (!nonimmediate_operand (op3, GET_MODE (op3)))\n \t\top3 = copy_to_mode_reg (GET_MODE (op3), op3);\n \t      emit_insn (gen (half, op3));"}, {"sha": "d815e70a9c065eb7a9ab7f2655b82d0d20e249be", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1985ca02ea01cd32de23be109672a7ebf593a46/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1985ca02ea01cd32de23be109672a7ebf593a46/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b1985ca02ea01cd32de23be109672a7ebf593a46", "patch": "@@ -1,3 +1,18 @@\n+2018-12-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/88464\n+\tPR target/88498\n+\t* gcc.target/i386/avx512f-pr88462-1.c: Rename to ...\n+\t* gcc.target/i386/avx512f-pr88464-1.c: ... this.  Fix up PR number.\n+\tExpect 4 vectorized loops instead of 3.\n+\t(f4): New function.\n+\t* gcc.target/i386/avx512f-pr88462-2.c: Rename to ...\n+\t* gcc.target/i386/avx512f-pr88464-2.c: ... this.  Fix up PR number\n+\tand #include.\n+\t(avx512f_test): Prepare arguments for f4 and check the results.\n+\t* gcc.target/i386/avx512f-pr88464-3.c: New test.\n+\t* gcc.target/i386/avx512f-pr88464-4.c: New test.\n+\n 2018-12-15  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/84644"}, {"sha": "06d21bb0129904a66c1ae2a30d2cb29b0ec43fa6", "filename": "gcc/testsuite/gcc.target/i386/avx512f-pr88464-1.c", "status": "renamed", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1985ca02ea01cd32de23be109672a7ebf593a46/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr88464-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1985ca02ea01cd32de23be109672a7ebf593a46/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr88464-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr88464-1.c?ref=b1985ca02ea01cd32de23be109672a7ebf593a46", "patch": "@@ -1,8 +1,8 @@\n-/* PR tree-optimization/88462 */\n+/* PR tree-optimization/88464 */\n /* { dg-do compile } */\n /* { dg-options \"-O3 -mavx512f -mprefer-vector-width=512 -mtune=skylake-avx512 -fdump-tree-vect-details\" } */\n-/* { dg-final { scan-tree-dump-times \"loop vectorized using 64 byte vectors\" 3 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops in function\" 3 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"loop vectorized using 64 byte vectors\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops in function\" 4 \"vect\" } } */\n \n __attribute__((noipa)) void\n f1 (double * __restrict__ a, const double * __restrict__ b, const int * __restrict__ c, int n)\n@@ -33,3 +33,13 @@ f3 (float * __restrict__ a, const float * __restrict__ b, const int * __restrict\n     if (a[i] > 10.0f)\n       a[i] = b[c[i]];\n }\n+\n+__attribute__((noipa)) void\n+f4 (float * __restrict__ a, const float * __restrict__ b, const long * __restrict__ c, int n)\n+{\n+  int i;\n+#pragma GCC ivdep\n+  for (i = 0; i < n; ++i)\n+    if (a[i] > 10.0f)\n+      a[i] = b[c[i]];\n+}", "previous_filename": "gcc/testsuite/gcc.target/i386/avx512f-pr88462-1.c"}, {"sha": "845bf509d827fc580f5e1ca95e6d0beb8e25ab6c", "filename": "gcc/testsuite/gcc.target/i386/avx512f-pr88464-2.c", "status": "renamed", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1985ca02ea01cd32de23be109672a7ebf593a46/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr88464-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1985ca02ea01cd32de23be109672a7ebf593a46/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr88464-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr88464-2.c?ref=b1985ca02ea01cd32de23be109672a7ebf593a46", "patch": "@@ -1,10 +1,10 @@\n-/* PR tree-optimization/88462 */\n+/* PR tree-optimization/88464 */\n /* { dg-do run { target { avx512f } } } */\n /* { dg-options \"-O3 -mavx512f -mprefer-vector-width=512 -mtune=skylake-avx512\" } */\n \n #include \"avx512f-check.h\"\n \n-#include \"avx512f-pr88462-1.c\"\n+#include \"avx512f-pr88464-1.c\"\n \n static void\n avx512f_test (void)\n@@ -47,5 +47,15 @@ avx512f_test (void)\n       asm volatile (\"\" : \"+g\" (i));\n       if (c[i] != ((i % 3) != 2 ? (1023 - i) * 4.0f : -5.0f))\n \tabort ();\n+      c[i] = (i % 3) != 0 ? 15.0f : -5.0f;\n+      e[i] = (i % 3) != 0 ? 1023 - i : __INT_MAX__;\n+      f[i] = 5 * i;\n+    }\n+  f4 (c, f, e, 1024);\n+  for (i = 0; i < 1024; i++)\n+    {\n+      asm volatile (\"\" : \"+g\" (i));\n+      if (c[i] != ((i % 3) != 0 ? (1023 - i) * 5.0f : -5.0f))\n+\tabort ();\n     }\n }", "previous_filename": "gcc/testsuite/gcc.target/i386/avx512f-pr88462-2.c"}, {"sha": "589e018d1e223a56d926401344d580f3937698fe", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 95, "deletions": 26, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1985ca02ea01cd32de23be109672a7ebf593a46/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1985ca02ea01cd32de23be109672a7ebf593a46/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=b1985ca02ea01cd32de23be109672a7ebf593a46", "patch": "@@ -2655,6 +2655,7 @@ vect_build_gather_load_calls (stmt_vec_info stmt_info,\n   if (mask && TREE_CODE (masktype) == INTEGER_TYPE)\n     masktype = build_same_sized_truth_vector_type (srctype);\n \n+  tree mask_halftype = masktype;\n   tree perm_mask = NULL_TREE;\n   tree mask_perm_mask = NULL_TREE;\n   if (known_eq (nunits, gather_off_nunits))\n@@ -2690,13 +2691,16 @@ vect_build_gather_load_calls (stmt_vec_info stmt_info,\n \n       ncopies *= 2;\n \n-      if (mask)\n+      if (mask && masktype == real_masktype)\n \t{\n \t  for (int i = 0; i < count; ++i)\n \t    sel[i] = i | (count / 2);\n \t  indices.new_vector (sel, 2, count);\n \t  mask_perm_mask = vect_gen_perm_mask_checked (masktype, indices);\n \t}\n+      else if (mask)\n+\tmask_halftype\n+\t  = build_same_sized_truth_vector_type (gs_info->offset_vectype);\n     }\n   else\n     gcc_unreachable ();\n@@ -2761,7 +2765,7 @@ vect_build_gather_load_calls (stmt_vec_info stmt_info,\n \t    {\n \t      if (j == 0)\n \t\tvec_mask = vect_get_vec_def_for_operand (mask, stmt_info);\n-\t      else\n+\t      else if (modifier != NARROW || (j & 1) == 0)\n \t\tvec_mask = vect_get_vec_def_for_stmt_copy (loop_vinfo,\n \t\t\t\t\t\t\t   vec_mask);\n \n@@ -2779,17 +2783,27 @@ vect_build_gather_load_calls (stmt_vec_info stmt_info,\n \t\t  mask_op = var;\n \t\t}\n \t    }\n+\t  if (modifier == NARROW && masktype != real_masktype)\n+\t    {\n+\t      var = vect_get_new_ssa_name (mask_halftype, vect_simple_var);\n+\t      gassign *new_stmt\n+\t\t= gimple_build_assign (var, (j & 1) ? VEC_UNPACK_HI_EXPR\n+\t\t\t\t\t\t    : VEC_UNPACK_LO_EXPR,\n+\t\t\t\t       mask_op);\n+\t      vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n+\t      mask_op = var;\n+\t    }\n \t  src_op = mask_op;\n \t}\n \n       tree mask_arg = mask_op;\n       if (masktype != real_masktype)\n \t{\n-\t  tree utype;\n-\t  if (TYPE_MODE (real_masktype) == TYPE_MODE (masktype))\n+\t  tree utype, optype = TREE_TYPE (mask_op);\n+\t  if (TYPE_MODE (real_masktype) == TYPE_MODE (optype))\n \t    utype = real_masktype;\n \t  else\n-\t    utype = lang_hooks.types.type_for_mode (TYPE_MODE (masktype), 1);\n+\t    utype = lang_hooks.types.type_for_mode (TYPE_MODE (optype), 1);\n \t  var = vect_get_new_ssa_name (utype, vect_scalar_var);\n \t  mask_arg = build1 (VIEW_CONVERT_EXPR, utype, mask_op);\n \t  gassign *new_stmt\n@@ -2801,7 +2815,7 @@ vect_build_gather_load_calls (stmt_vec_info stmt_info,\n \t      gcc_assert (TYPE_PRECISION (utype)\n \t\t\t  <= TYPE_PRECISION (real_masktype));\n \t      var = vect_get_new_ssa_name (real_masktype, vect_scalar_var);\n-\t      new_stmt = gimple_build_assign (var, NOP_EXPR, utype);\n+\t      new_stmt = gimple_build_assign (var, NOP_EXPR, mask_arg);\n \t      vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n \t      mask_arg = var;\n \t    }\n@@ -6361,7 +6375,8 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t    return false;\n \t}\n       else if (memory_access_type != VMAT_LOAD_STORE_LANES\n-\t       && (memory_access_type != VMAT_GATHER_SCATTER || gs_info.decl))\n+\t       && (memory_access_type != VMAT_GATHER_SCATTER\n+\t\t   || (gs_info.decl && !VECTOR_BOOLEAN_TYPE_P (mask_vectype))))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6419,7 +6434,9 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       tree vec_oprnd0 = NULL_TREE, vec_oprnd1 = NULL_TREE, src;\n       tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gs_info.decl));\n       tree rettype, srctype, ptrtype, idxtype, masktype, scaletype;\n-      tree ptr, mask, var, scale, perm_mask = NULL_TREE;\n+      tree ptr, var, scale, vec_mask;\n+      tree mask_arg = NULL_TREE, mask_op = NULL_TREE, perm_mask = NULL_TREE;\n+      tree mask_halfvectype = mask_vectype;\n       edge pe = loop_preheader_edge (loop);\n       gimple_seq seq;\n       basic_block new_bb;\n@@ -6460,6 +6477,10 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  perm_mask = vect_gen_perm_mask_checked (vectype, indices);\n \t  gcc_assert (perm_mask != NULL_TREE);\n \t  ncopies *= 2;\n+\n+\t  if (mask)\n+\t    mask_halfvectype\n+\t      = build_same_sized_truth_vector_type (gs_info.offset_vectype);\n \t}\n       else\n \tgcc_unreachable ();\n@@ -6482,10 +6503,11 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  gcc_assert (!new_bb);\n \t}\n \n-      /* Currently we support only unconditional scatter stores,\n-\t so mask should be all ones.  */\n-      mask = build_int_cst (masktype, -1);\n-      mask = vect_init_vector (stmt_info, mask, masktype, NULL);\n+      if (mask == NULL_TREE)\n+\t{\n+\t  mask_arg = build_int_cst (masktype, -1);\n+\t  mask_arg = vect_init_vector (stmt_info, mask_arg, masktype, NULL);\n+\t}\n \n       scale = build_int_cst (scaletype, gs_info.scale);\n \n@@ -6494,36 +6516,46 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t{\n \t  if (j == 0)\n \t    {\n-\t      src = vec_oprnd1\n-\t\t= vect_get_vec_def_for_operand (op, stmt_info);\n-\t      op = vec_oprnd0\n-\t\t= vect_get_vec_def_for_operand (gs_info.offset, stmt_info);\n+\t      src = vec_oprnd1 = vect_get_vec_def_for_operand (op, stmt_info);\n+\t      op = vec_oprnd0 = vect_get_vec_def_for_operand (gs_info.offset,\n+\t\t\t\t\t\t\t      stmt_info);\n+\t      if (mask)\n+\t\tmask_op = vec_mask = vect_get_vec_def_for_operand (mask,\n+\t\t\t\t\t\t\t\t   stmt_info);\n \t    }\n \t  else if (modifier != NONE && (j & 1))\n \t    {\n \t      if (modifier == WIDEN)\n \t\t{\n-\t\t  src = vec_oprnd1\n-\t\t    = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd1);\n+\t\t  src\n+\t\t    = vec_oprnd1 = vect_get_vec_def_for_stmt_copy (vinfo,\n+\t\t\t\t\t\t\t\t   vec_oprnd1);\n \t\t  op = permute_vec_elements (vec_oprnd0, vec_oprnd0, perm_mask,\n \t\t\t\t\t     stmt_info, gsi);\n+\t\t  if (mask)\n+\t\t    mask_op\n+\t\t      = vec_mask = vect_get_vec_def_for_stmt_copy (vinfo,\n+\t\t\t\t\t\t\t\t   vec_mask);\n \t\t}\n \t      else if (modifier == NARROW)\n \t\t{\n \t\t  src = permute_vec_elements (vec_oprnd1, vec_oprnd1, perm_mask,\n \t\t\t\t\t      stmt_info, gsi);\n-\t\t  op = vec_oprnd0\n-\t\t    = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd0);\n+\t\t  op = vec_oprnd0 = vect_get_vec_def_for_stmt_copy (vinfo,\n+\t\t\t\t\t\t\t\t    vec_oprnd0);\n \t\t}\n \t      else\n \t\tgcc_unreachable ();\n \t    }\n \t  else\n \t    {\n-\t      src = vec_oprnd1\n-\t\t= vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd1);\n-\t      op = vec_oprnd0\n-\t\t= vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd0);\n+\t      src = vec_oprnd1 = vect_get_vec_def_for_stmt_copy (vinfo,\n+\t\t\t\t\t\t\t\t vec_oprnd1);\n+\t      op = vec_oprnd0 = vect_get_vec_def_for_stmt_copy (vinfo,\n+\t\t\t\t\t\t\t\tvec_oprnd0);\n+\t      if (mask)\n+\t\tmask_op = vec_mask = vect_get_vec_def_for_stmt_copy (vinfo,\n+\t\t\t\t\t\t\t\t     vec_mask);\n \t    }\n \n \t  if (!useless_type_conversion_p (srctype, TREE_TYPE (src)))\n@@ -6550,8 +6582,45 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t      op = var;\n \t    }\n \n+\t  if (mask)\n+\t    {\n+\t      tree utype;\n+\t      mask_arg = mask_op;\n+\t      if (modifier == NARROW)\n+\t\t{\n+\t\t  var = vect_get_new_ssa_name (mask_halfvectype,\n+\t\t\t\t\t       vect_simple_var);\n+\t\t  gassign *new_stmt\n+\t\t    = gimple_build_assign (var, (j & 1) ? VEC_UNPACK_HI_EXPR\n+\t\t\t\t\t\t\t: VEC_UNPACK_LO_EXPR,\n+\t\t\t\t\t   mask_op);\n+\t\t  vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n+\t\t  mask_arg = var;\n+\t\t}\n+\t      tree optype = TREE_TYPE (mask_arg);\n+\t      if (TYPE_MODE (masktype) == TYPE_MODE (optype))\n+\t\tutype = masktype;\n+\t      else\n+\t\tutype = lang_hooks.types.type_for_mode (TYPE_MODE (optype), 1);\n+\t      var = vect_get_new_ssa_name (utype, vect_scalar_var);\n+\t      mask_arg = build1 (VIEW_CONVERT_EXPR, utype, mask_arg);\n+\t      gassign *new_stmt\n+\t\t= gimple_build_assign (var, VIEW_CONVERT_EXPR, mask_arg);\n+\t      vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n+\t      mask_arg = var;\n+\t      if (!useless_type_conversion_p (masktype, utype))\n+\t\t{\n+\t\t  gcc_assert (TYPE_PRECISION (utype)\n+\t\t\t      <= TYPE_PRECISION (masktype));\n+\t\t  var = vect_get_new_ssa_name (masktype, vect_scalar_var);\n+\t\t  new_stmt = gimple_build_assign (var, NOP_EXPR, mask_arg);\n+\t\t  vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n+\t\t  mask_arg = var;\n+\t\t}\n+\t    }\n+\n \t  gcall *new_stmt\n-\t    = gimple_build_call (gs_info.decl, 5, ptr, mask, op, src, scale);\n+\t    = gimple_build_call (gs_info.decl, 5, ptr, mask_arg, op, src, scale);\n \t  stmt_vec_info new_stmt_info\n \t    = vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n \n@@ -7284,7 +7353,7 @@ permute_vec_elements (tree x, tree y, tree mask_vec, stmt_vec_info stmt_info,\n   gimple *perm_stmt;\n \n   tree scalar_dest = gimple_get_lhs (stmt_info->stmt);\n-  if (TREE_CODE (scalar_dest) == SSA_NAME)\n+  if (scalar_dest && TREE_CODE (scalar_dest) == SSA_NAME)\n     perm_dest = vect_create_destination_var (scalar_dest, vectype);\n   else\n     perm_dest = vect_get_new_vect_var (vectype, vect_simple_var, NULL);"}]}