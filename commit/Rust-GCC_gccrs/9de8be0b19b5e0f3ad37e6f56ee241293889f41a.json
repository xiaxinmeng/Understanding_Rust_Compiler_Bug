{"sha": "9de8be0b19b5e0f3ad37e6f56ee241293889f41a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRlOGJlMGIxOWI1ZTBmM2FkMzdlNmY1NmVlMjQxMjkzODg5ZjQxYQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-03-18T00:57:13Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-03-18T00:57:13Z"}, "message": "natString.cc (rehash): Don't bother with memset; _Jv_AllocBytes returns zero'd memory.\n\n\t* java/lang/natString.cc (rehash): Don't bother with memset;\n\t_Jv_AllocBytes returns zero'd memory.  Use _Jv_AllocBytesChecked.\n\tUse UNMASK_PTR.\n\t(UNMASK_PTR): New macro.\n\t(intern): Unmask pointer before returning it.  Register finalizer\n\tfor the string.\n\t(unintern): Handle case where\n\t(MASK_PTR): New macro.\n\t(PTR_MAKSED): Likewise.\n\t(_Jv_NewStringUtf8Const): Use UNMASK_PTR.\n\nFrom-SVN: r40593", "tree": {"sha": "31405df7690693b7c1f8fab8a6eb2ffa631fb15d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31405df7690693b7c1f8fab8a6eb2ffa631fb15d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9de8be0b19b5e0f3ad37e6f56ee241293889f41a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de8be0b19b5e0f3ad37e6f56ee241293889f41a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9de8be0b19b5e0f3ad37e6f56ee241293889f41a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de8be0b19b5e0f3ad37e6f56ee241293889f41a/comments", "author": null, "committer": null, "parents": [{"sha": "2eb6fbf861e3c0907b9cdb2163783c8f60b8f012", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eb6fbf861e3c0907b9cdb2163783c8f60b8f012", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eb6fbf861e3c0907b9cdb2163783c8f60b8f012"}], "stats": {"total": 89, "additions": 71, "deletions": 18}, "files": [{"sha": "4ba2d8673b808db52f35349a2f386289c428b8dc", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de8be0b19b5e0f3ad37e6f56ee241293889f41a/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de8be0b19b5e0f3ad37e6f56ee241293889f41a/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=9de8be0b19b5e0f3ad37e6f56ee241293889f41a", "patch": "@@ -1,3 +1,16 @@\n+2001-03-17  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/natString.cc (rehash): Don't bother with memset;\n+\t_Jv_AllocBytes returns zero'd memory.  Use _Jv_AllocBytesChecked.\n+\tUse UNMASK_PTR.\n+\t(UNMASK_PTR): New macro.\n+\t(intern): Unmask pointer before returning it.  Register finalizer\n+\tfor the string.\n+\t(unintern): Handle case where \n+\t(MASK_PTR): New macro.\n+\t(PTR_MAKSED): Likewise.\n+\t(_Jv_NewStringUtf8Const): Use UNMASK_PTR.\n+\n 2001-03-01  Andrew Haley  <aph@redhat.com>\n \n \t* java/lang/natThrowable.cc (printRawStackTrace): Copy the"}, {"sha": "cc3d8eb46d1fd44200dad32c2d3de7aeeab47a97", "filename": "libjava/java/lang/natString.cc", "status": "modified", "additions": 58, "deletions": 18, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de8be0b19b5e0f3ad37e6f56ee241293889f41a/libjava%2Fjava%2Flang%2FnatString.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de8be0b19b5e0f3ad37e6f56ee241293889f41a/libjava%2Fjava%2Flang%2FnatString.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatString.cc?ref=9de8be0b19b5e0f3ad37e6f56ee241293889f41a", "patch": "@@ -1,6 +1,6 @@\n // natString.cc - Implementation of java.lang.String native methods.\n \n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -45,6 +45,10 @@ static int strhash_size = 0;  /* Number of slots available in strhash.\n #define DELETED_STRING ((jstring)(~0))\n #define SET_STRING_IS_INTERNED(STR) /* nothing */\n \n+#define UNMASK_PTR(Ptr) (((unsigned long) (Ptr)) & ~0x01)\n+#define MASK_PTR(Ptr) (((unsigned long) (Ptr)) | 0x01)\n+#define PTR_MASKED(Ptr) (((unsigned long) (Ptr)) & 0x01)\n+\n /* Find a slot where the string with elements DATA, length LEN,\n    and hash HASH should go in the strhash table of interned strings. */\n jstring*\n@@ -61,7 +65,8 @@ _Jv_StringFindSlot (jchar* data, jint len, jint hash)\n   for (;;)\n     {\n       jstring* ptr = &strhash[index];\n-      if (*ptr == NULL)\n+      jstring value = (jstring) UNMASK_PTR (*ptr);\n+      if (value == NULL)\n \t{\n \t  if (deleted_index >= 0)\n \t    return (&strhash[deleted_index]);\n@@ -70,8 +75,8 @@ _Jv_StringFindSlot (jchar* data, jint len, jint hash)\n \t}\n       else if (*ptr == DELETED_STRING)\n \tdeleted_index = index;\n-      else if ((*ptr)->length() == len\n-\t       && memcmp(JvGetStringChars(*ptr), data, 2*len) == 0)\n+      else if (value->length() == len\n+\t       && memcmp(JvGetStringChars(value), data, 2*len) == 0)\n \treturn (ptr);\n       index = (index + step) & (strhash_size - 1);\n       JvAssert (index != start_index);\n@@ -115,16 +120,18 @@ java::lang::String::rehash()\n   if (strhash == NULL)\n     {\n       strhash_size = 1024;\n-      strhash = (jstring *) _Jv_AllocBytes (strhash_size * sizeof (jstring));\n+      strhash = (jstring *) _Jv_AllocBytesChecked (strhash_size\n+\t\t\t\t\t\t   * sizeof (jstring));\n       memset (strhash, 0, strhash_size * sizeof (jstring));\n     }\n   else\n     {\n       int i = strhash_size;\n       jstring* ptr = strhash + i;\n-      strhash_size *= 2;\n-      strhash = (jstring *) _Jv_AllocBytes (strhash_size * sizeof (jstring));\n-      memset (strhash, 0, strhash_size * sizeof (jstring));\n+      int nsize = strhash_size * 2;\n+      jstring *next = (jstring *) _Jv_AllocBytesChecked (nsize\n+\t\t\t\t\t\t\t * sizeof (jstring));\n+      memset (next, 0, nsize * sizeof (jstring));\n \n       while (--i >= 0)\n \t{\n@@ -134,19 +141,23 @@ java::lang::String::rehash()\n \n \t  /* This is faster equivalent of\n \t   * *__JvGetInternSlot(*ptr) = *ptr; */\n-\t  jint hash = (*ptr)->hashCode();\n-\t  jint index = hash & (strhash_size - 1);\n+\t  jstring val = (jstring) UNMASK_PTR (*ptr);\n+\t  jint hash = val->hashCode();\n+\t  jint index = hash & (nsize - 1);\n \t  jint step = 8 * hash + 7;\n \t  for (;;)\n \t    {\n-\t      if (strhash[index] == NULL)\n+\t      if (next[index] == NULL)\n \t\t{\n-\t\t  strhash[index] = *ptr;\n+\t\t  next[index] = *ptr;\n \t\t  break;\n \t\t}\n-\t      index = (index + step) & (strhash_size - 1);\n+\t      index = (index + step) & (nsize - 1);\n \t    }\n \t}\n+\n+      strhash_size = nsize;\n+      strhash = next;\n     }\n }\n \n@@ -158,12 +169,16 @@ java::lang::String::intern()\n     rehash();\n   jstring* ptr = _Jv_StringGetSlot(this);\n   if (*ptr != NULL && *ptr != DELETED_STRING)\n-    return *ptr;\n+    {\n+      // See description in unintern() to understand this.\n+      *ptr = (jstring) MASK_PTR (*ptr);\n+      return (jstring) UNMASK_PTR (*ptr);\n+    }\n   SET_STRING_IS_INTERNED(this);\n   strhash_count++;\n   *ptr = this;\n   // When string is GC'd, clear the slot in the hash table.\n-  // _Jv_RegisterFinalizer ((void *) this, unintern);\n+  _Jv_RegisterFinalizer ((void *) this, unintern);\n   return this;\n }\n \n@@ -176,8 +191,33 @@ java::lang::String::unintern (jobject obj)\n   jstring* ptr = _Jv_StringGetSlot(str);\n   if (*ptr == NULL || *ptr == DELETED_STRING)\n     return;\n-  *ptr = DELETED_STRING;\n-  strhash_count--;\n+\n+  // We assume the lowest bit of the pointer is free for our nefarious\n+  // manipulations.  What we do is set it to `0' (implicitly) when\n+  // interning the String.  If we subsequently re-intern the same\n+  // String, then we set the bit.  When finalizing, if the bit is set\n+  // then we clear it and re-register the finalizer.  We know this is\n+  // a safe approach because both the intern() and unintern() acquire\n+  // the class lock; this bit can't be manipulated when the lock is\n+  // not held.  So if we are finalizing and the bit is clear then we\n+  // know all references are gone and we can clear the entry in the\n+  // hash table.  The naive approach of simply clearing the pointer\n+  // here fails in the case where a request to intern a new string\n+  // with the same contents is made between the time the intern()d\n+  // string is found to be unreachable and when the finalizer is\n+  // actually run.  In this case we could clear a pointer to a valid\n+  // string, and future intern() calls for that particular value would\n+  // spuriously fail.\n+  if (PTR_MASKED (*ptr))\n+    {\n+      *ptr = (jstring) UNMASK_PTR (*ptr);\n+      _Jv_RegisterFinalizer ((void *) obj, unintern);\n+    }\n+  else\n+    {\n+      *ptr = DELETED_STRING;\n+      strhash_count--;\n+    }\n }\n \n jstring\n@@ -232,7 +272,7 @@ _Jv_NewStringUtf8Const (Utf8Const* str)\n   int hash = str->hash;\n   jstring* ptr = _Jv_StringFindSlot (chrs, length, hash);\n   if (*ptr != NULL && *ptr != DELETED_STRING)\n-    return *ptr;\n+    return (jstring) UNMASK_PTR (*ptr);\n   strhash_count++;\n   if (jstr == NULL)\n     {"}]}