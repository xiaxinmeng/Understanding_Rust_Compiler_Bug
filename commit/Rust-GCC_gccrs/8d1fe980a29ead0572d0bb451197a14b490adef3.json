{"sha": "8d1fe980a29ead0572d0bb451197a14b490adef3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQxZmU5ODBhMjllYWQwNTcyZDBiYjQ1MTE5N2ExNGI0OTBhZGVmMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-12T09:14:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-12T09:14:02Z"}, "message": "[multiple changes]\n\n2015-05-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Add_Internal_Interface_Entities): Do no generate\n\tfreeze nodes for these in ASIS mode, because they lead to\n\telaoration order issues in gigi.\n\n2015-05-12  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Expression_Function): Code\n\tcleanup. Use Copy_Subprogram_Spec to create a proper spec.\n\t(Analyze_Subprogram_Body_Helper): Code cleanup. Do not\n\tprepare a stand alone body for inlining in GNATprove mode\n\twhen inside a generic.\t(Body_Has_Contract): Reimplemented.\n\t(Build_Subprogram_Declaration): New routine.\n\t* sem_ch10.adb (Analyze_Compilation_Unit): Capture global\n\treferences within generic bodies by loading them.\n\t* sem_util.adb (Copy_Parameter_List): Code cleanup.\n\t(Copy_Subprogram_Spec): New routine.\n\t(Is_Contract_Annotation): New routine.\n\t* sem_util.ads (Copy_Subprogram_Spec): New routine.\n\t(Is_Contract_Annotation): New routine.\n\n2015-05-12  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_attr.adb (Resolve_Attribute): Do not analyze the generated\n\tbody of an expression function when the prefix of attribute\n\t'Access is the body.\n\nFrom-SVN: r223048", "tree": {"sha": "14c42d7be7d52c0aea6495f06f89866916d5ca64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14c42d7be7d52c0aea6495f06f89866916d5ca64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d1fe980a29ead0572d0bb451197a14b490adef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d1fe980a29ead0572d0bb451197a14b490adef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d1fe980a29ead0572d0bb451197a14b490adef3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d1fe980a29ead0572d0bb451197a14b490adef3/comments", "author": null, "committer": null, "parents": [{"sha": "cb2e147086286e59c24e5eb1528c11bbdfa08d05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb2e147086286e59c24e5eb1528c11bbdfa08d05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb2e147086286e59c24e5eb1528c11bbdfa08d05"}], "stats": {"total": 502, "additions": 305, "deletions": 197}, "files": [{"sha": "fb21d9389be63a95ba993d05d69cf0ea7c9e8ab5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1fe980a29ead0572d0bb451197a14b490adef3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1fe980a29ead0572d0bb451197a14b490adef3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8d1fe980a29ead0572d0bb451197a14b490adef3", "patch": "@@ -1,3 +1,31 @@\n+2015-05-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Add_Internal_Interface_Entities): Do no generate\n+\tfreeze nodes for these in ASIS mode, because they lead to\n+\telaoration order issues in gigi.\n+\n+2015-05-12  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Expression_Function): Code\n+\tcleanup. Use Copy_Subprogram_Spec to create a proper spec.\n+\t(Analyze_Subprogram_Body_Helper): Code cleanup. Do not\n+\tprepare a stand alone body for inlining in GNATprove mode\n+\twhen inside a generic.\t(Body_Has_Contract): Reimplemented.\n+\t(Build_Subprogram_Declaration): New routine.\n+\t* sem_ch10.adb (Analyze_Compilation_Unit): Capture global\n+\treferences within generic bodies by loading them.\n+\t* sem_util.adb (Copy_Parameter_List): Code cleanup.\n+\t(Copy_Subprogram_Spec): New routine.\n+\t(Is_Contract_Annotation): New routine.\n+\t* sem_util.ads (Copy_Subprogram_Spec): New routine.\n+\t(Is_Contract_Annotation): New routine.\n+\n+2015-05-12  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_attr.adb (Resolve_Attribute): Do not analyze the generated\n+\tbody of an expression function when the prefix of attribute\n+\t'Access is the body.\n+\n 2015-05-12  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch3.adb (Build_Derived_Enumeration_Type): The anonymous base"}, {"sha": "16cbccfb166e445b2770e4bbc67b13e3d189d47d", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1fe980a29ead0572d0bb451197a14b490adef3/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1fe980a29ead0572d0bb451197a14b490adef3/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=8d1fe980a29ead0572d0bb451197a14b490adef3", "patch": "@@ -10675,13 +10675,31 @@ package body Sem_Attr is\n                      Subp_Body :=\n                        Unit_Declaration_Node (Corresponding_Body (Subp_Decl));\n \n-                     --  Analyze the body of the expression function to freeze\n-                     --  the expression. This takes care of the case where the\n-                     --  'Access is part of dispatch table initialization and\n-                     --  the generated body of the expression function has not\n-                     --  been analyzed yet.\n+                     --  The body has already been analyzed when the expression\n+                     --  function acts as a completion.\n \n-                     if not Analyzed (Subp_Body) then\n+                     if Analyzed (Subp_Body) then\n+                        null;\n+\n+                     --  Attribute 'Access may appear within the generated body\n+                     --  of the expression function subject to the attribute:\n+\n+                     --    function F is (... F'Access ...);\n+\n+                     --  If the expression function is on the scope stack, then\n+                     --  the body is currently being analyzed. Do not reanalyze\n+                     --  it because this will lead to infinite recursion.\n+\n+                     elsif In_Open_Scopes (Subp_Id) then\n+                        null;\n+\n+                      --  Analyze the body of the expression function to freeze\n+                      --  the expression. This takes care of the case where the\n+                      --  'Access is part of dispatch table initialization and\n+                      --  the generated body of the expression function has not\n+                      --  been analyzed yet.\n+\n+                     else\n                         Analyze (Subp_Body);\n                      end if;\n                   end if;"}, {"sha": "9f68d15123fec606351dac10450809d1eed25565", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1fe980a29ead0572d0bb451197a14b490adef3/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1fe980a29ead0572d0bb451197a14b490adef3/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=8d1fe980a29ead0572d0bb451197a14b490adef3", "patch": "@@ -1020,16 +1020,18 @@ package body Sem_Ch10 is\n \n       Remove_Context (N);\n \n-      --  If this is the main unit and we are generating code, we must check\n-      --  that all generic units in the context have a body if they need it,\n-      --  even if they have not been instantiated. In the absence of .ali files\n-      --  for generic units, we must force the load of the body, just to\n-      --  produce the proper error if the body is absent. We skip this\n-      --  verification if the main unit itself is generic.\n+      --  When generating code for a non-generic main unit, check that withed\n+      --  generic units have a body if they need it, even if the units have not\n+      --  been instantiated. Force the load of the bodies to produce the proper\n+      --  error if the body is absent. The same applies to GNATprove mode, with\n+      --  the added benefit of capturing global references within the generic.\n+      --  This in turn allows for proper inlining of subprogram bodies without\n+      --  a previous declaration.\n \n       if Get_Cunit_Unit_Number (N) = Main_Unit\n-        and then Operating_Mode = Generate_Code\n-        and then Expander_Active\n+        and then ((Operating_Mode = Generate_Code and then Expander_Active)\n+                     or else\n+                  (Operating_Mode = Check_Semantics and then GNATprove_Mode))\n       then\n          --  Check whether the source for the body of the unit must be included\n          --  in a standalone library.\n@@ -1066,7 +1068,7 @@ package body Sem_Ch10 is\n                then\n                   Nam := Entity (Name (Item));\n \n-                  --  Compile generic subprogram, unless it is intrinsic or\n+                  --  Compile the generic subprogram, unless it is intrinsic or\n                   --  imported so no body is required, or generic package body\n                   --  if the package spec requires a body.\n \n@@ -1080,20 +1082,21 @@ package body Sem_Ch10 is\n \n                      if Present (Renamed_Object (Nam)) then\n                         Un :=\n-                           Load_Unit\n-                             (Load_Name  => Get_Body_Name\n-                                              (Get_Unit_Name\n-                                                (Unit_Declaration_Node\n-                                                  (Renamed_Object (Nam)))),\n-                              Required   => False,\n-                              Subunit    => False,\n-                              Error_Node => N,\n-                              Renamings  => True);\n+                          Load_Unit\n+                            (Load_Name  =>\n+                               Get_Body_Name\n+                                 (Get_Unit_Name\n+                                   (Unit_Declaration_Node\n+                                     (Renamed_Object (Nam)))),\n+                             Required   => False,\n+                             Subunit    => False,\n+                             Error_Node => N,\n+                             Renamings  => True);\n                      else\n                         Un :=\n                           Load_Unit\n-                            (Load_Name  => Get_Body_Name\n-                                             (Get_Unit_Name (Item)),\n+                            (Load_Name  =>\n+                               Get_Body_Name (Get_Unit_Name (Item)),\n                              Required   => False,\n                              Subunit    => False,\n                              Error_Node => N,"}, {"sha": "c88e1d86247c261e205d084b96d3ae08d97c31f9", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1fe980a29ead0572d0bb451197a14b490adef3/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1fe980a29ead0572d0bb451197a14b490adef3/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=8d1fe980a29ead0572d0bb451197a14b490adef3", "patch": "@@ -1772,9 +1772,13 @@ package body Sem_Ch3 is\n                --  locally defined tagged types (or compiling with static\n                --  dispatch tables generation disabled) the corresponding\n                --  entry of the secondary dispatch table is filled when\n-               --  such an entity is frozen.\n+               --  such an entity is frozen. This is an expansion activity\n+               --  that must be suppressed for ASIS because it leads to\n+               --  gigi elaboration issues in annotate mode.\n \n-               Set_Has_Delayed_Freeze (New_Subp);\n+               if not ASIS_Mode then\n+                  Set_Has_Delayed_Freeze (New_Subp);\n+               end if;\n             end if;\n \n             <<Continue>>\n@@ -1794,7 +1798,7 @@ package body Sem_Ch3 is\n    -----------------------------------\n \n    procedure Analyze_Component_Declaration (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (N);\n+      Loc : constant Source_Ptr := Sloc (Component_Definition (N));\n       Id  : constant Entity_Id  := Defining_Identifier (N);\n       E   : constant Node_Id    := Expression (N);\n       Typ : constant Node_Id    :=\n@@ -2137,9 +2141,14 @@ package body Sem_Ch3 is\n       then\n          declare\n             Act_T : constant Entity_Id := Build_Default_Subtype (T, N);\n+\n          begin\n             Set_Etype (Id, Act_T);\n-            Set_Component_Definition (N,\n+\n+            --  Rewrite the component definition to use the constrained\n+            --  subtype.\n+\n+            Rewrite (Component_Definition (N),\n               Make_Component_Definition (Loc,\n                 Subtype_Indication => New_Occurrence_Of (Act_T, Loc)));\n          end;"}, {"sha": "f0fb6d4073b59cf937c384a41ddca6f066791a71", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 103, "deletions": 132, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1fe980a29ead0572d0bb451197a14b490adef3/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1fe980a29ead0572d0bb451197a14b490adef3/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=8d1fe980a29ead0572d0bb451197a14b490adef3", "patch": "@@ -268,10 +268,10 @@ package body Sem_Ch6 is\n    ---------------------------------\n \n    procedure Analyze_Expression_Function (N : Node_Id) is\n-      Loc      : constant Source_Ptr := Sloc (N);\n-      LocX     : constant Source_Ptr := Sloc (Expression (N));\n-      Expr     : constant Node_Id    := Expression (N);\n-      Spec     : constant Node_Id    := Specification (N);\n+      Expr : constant Node_Id    := Expression (N);\n+      Loc  : constant Source_Ptr := Sloc (N);\n+      LocX : constant Source_Ptr := Sloc (Expr);\n+      Spec : constant Node_Id    := Specification (N);\n \n       Def_Id :  Entity_Id;\n \n@@ -293,36 +293,11 @@ package body Sem_Ch6 is\n \n       Inline_Processing_Required := True;\n \n-      --  Create a specification for the generated body. Types and defauts in\n-      --  the profile are copies of the spec, but new entities must be created\n-      --  for the unit name and the formals.\n+      --  Create a specification for the generated body. This must be done\n+      --  prior to the analysis of the initial declaration.\n \n-      New_Spec := New_Copy_Tree (Spec);\n-      Set_Defining_Unit_Name (New_Spec,\n-        Make_Defining_Identifier (Sloc (Defining_Unit_Name (Spec)),\n-          Chars (Defining_Unit_Name (Spec))));\n-\n-      if Present (Parameter_Specifications (New_Spec)) then\n-         declare\n-            Formal_Spec : Node_Id;\n-            Def         : Entity_Id;\n-\n-         begin\n-            Formal_Spec := First (Parameter_Specifications (New_Spec));\n-\n-            --  Create a new formal parameter at the same source position\n-\n-            while Present (Formal_Spec) loop\n-               Def := Defining_Identifier (Formal_Spec);\n-               Set_Defining_Identifier (Formal_Spec,\n-                 Make_Defining_Identifier (Sloc (Def),\n-                   Chars => Chars (Def)));\n-               Next (Formal_Spec);\n-            end loop;\n-         end;\n-      end if;\n-\n-      Prev := Current_Entity_In_Scope (Defining_Entity (Spec));\n+      New_Spec := Copy_Subprogram_Spec (Spec);\n+      Prev     := Current_Entity_In_Scope (Defining_Entity (Spec));\n \n       --  If there are previous overloadable entities with the same name,\n       --  check whether any of them is completed by the expression function.\n@@ -2272,7 +2247,7 @@ package body Sem_Ch6 is\n \n    procedure Analyze_Subprogram_Body_Helper (N : Node_Id) is\n       Loc          : constant Source_Ptr := Sloc (N);\n-      Body_Spec    : constant Node_Id    := Specification (N);\n+      Body_Spec    : Node_Id             := Specification (N);\n       Body_Id      : Entity_Id           := Defining_Entity (Body_Spec);\n       Prev_Id      : constant Entity_Id  := Current_Entity_In_Scope (Body_Id);\n       Conformant   : Boolean;\n@@ -2309,6 +2284,9 @@ package body Sem_Ch6 is\n       --  Check whether unanalyzed body has an aspect or pragma that may\n       --  generate a SPARK contract.\n \n+      procedure Build_Subprogram_Declaration;\n+      --  Create a matching subprogram declaration for subprogram body N\n+\n       procedure Check_Anonymous_Return;\n       --  Ada 2005: if a function returns an access type that denotes a task,\n       --  or a type that contains tasks, we must create a master entity for\n@@ -2486,63 +2464,114 @@ package body Sem_Ch6 is\n       -----------------------\n \n       function Body_Has_Contract return Boolean is\n-         Decls  : constant List_Id := Declarations (N);\n-         A_Spec : Node_Id;\n-         A      : Aspect_Id;\n-         Decl   : Node_Id;\n-         P_Id   : Pragma_Id;\n+         Decls : constant List_Id := Declarations (N);\n+         Item  : Node_Id;\n \n       begin\n-         --  Check for unanalyzed aspects in the body that will\n-         --  generate a contract.\n+         --  Check for unanalyzed aspects in the body that will generate a\n+         --  contract.\n \n          if Present (Aspect_Specifications (N)) then\n-            A_Spec := First (Aspect_Specifications (N));\n-            while Present (A_Spec) loop\n-               A := Get_Aspect_Id (Chars (Identifier (A_Spec)));\n-\n-               if A = Aspect_Contract_Cases or else\n-                  A = Aspect_Depends        or else\n-                  A = Aspect_Global         or else\n-                  A = Aspect_Pre            or else\n-                  A = Aspect_Precondition   or else\n-                  A = Aspect_Post           or else\n-                  A = Aspect_Postcondition\n-               then\n+            Item := First (Aspect_Specifications (N));\n+            while Present (Item) loop\n+               if Is_Contract_Annotation (Item) then\n                   return True;\n                end if;\n \n-               Next (A_Spec);\n+               Next (Item);\n             end loop;\n          end if;\n \n          --  Check for pragmas that may generate a contract\n \n          if Present (Decls) then\n-            Decl := First (Decls);\n-            while Present (Decl) loop\n-               if Nkind (Decl) = N_Pragma then\n-                  P_Id := Get_Pragma_Id (Pragma_Name (Decl));\n-\n-                  if P_Id = Pragma_Contract_Cases or else\n-                     P_Id = Pragma_Depends        or else\n-                     P_Id = Pragma_Global         or else\n-                     P_Id = Pragma_Pre            or else\n-                     P_Id = Pragma_Precondition   or else\n-                     P_Id = Pragma_Post           or else\n-                     P_Id = Pragma_Postcondition\n-                  then\n-                     return True;\n-                  end if;\n+            Item := First (Decls);\n+            while Present (Item) loop\n+               if Nkind (Item) = N_Pragma\n+                 and then Is_Contract_Annotation (Item)\n+               then\n+                  return True;\n                end if;\n \n-               Next (Decl);\n+               Next (Item);\n             end loop;\n          end if;\n \n          return False;\n       end Body_Has_Contract;\n \n+      ----------------------------------\n+      -- Build_Subprogram_Declaration --\n+      ----------------------------------\n+\n+      procedure Build_Subprogram_Declaration is\n+         Asp       : Node_Id;\n+         Decl      : Node_Id;\n+         Subp_Decl : Node_Id;\n+\n+      begin\n+         --  Create a matching subprogram spec using the profile of the body.\n+         --  The structure of the tree is identical, but has new entities for\n+         --  the defining unit name and formal parameters.\n+\n+         Subp_Decl :=\n+           Make_Subprogram_Declaration (Loc,\n+             Specification => Copy_Subprogram_Spec (Body_Spec));\n+\n+         --  Relocate the aspects of the subprogram body to the new subprogram\n+         --  spec because it acts as the initial declaration.\n+         --  ??? what about pragmas\n+\n+         Move_Aspects (N, To => Subp_Decl);\n+         Insert_Before_And_Analyze (N, Subp_Decl);\n+\n+         --  The analysis of the subprogram spec aspects may introduce pragmas\n+         --  that need to be analyzed.\n+\n+         Decl := Next (Subp_Decl);\n+         while Present (Decl) loop\n+\n+            --  Stop the search for pragmas once the body has been reached as\n+            --  this terminates the region where pragmas may appear.\n+\n+            if Decl = N then\n+               exit;\n+\n+            elsif Nkind (Decl) = N_Pragma then\n+               Analyze (Decl);\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+\n+         Spec_Id := Defining_Entity (Subp_Decl);\n+         Set_Corresponding_Spec (N, Spec_Id);\n+\n+         --  Mark the generated spec as a source construct to ensure that all\n+         --  calls to it are properly registered in ALI files for GNATprove.\n+\n+         Set_Comes_From_Source (Spec_Id, True);\n+\n+         --  If aspect SPARK_Mode was specified on the body, it needs to be\n+         --  repeated both on the generated spec and the body.\n+\n+         Asp := Find_Aspect (Spec_Id, Aspect_SPARK_Mode);\n+\n+         if Present (Asp) then\n+            Asp := New_Copy_Tree (Asp);\n+            Set_Analyzed (Asp, False);\n+            Set_Aspect_Specifications (N, New_List (Asp));\n+         end if;\n+\n+         --  Ensure that the specs of the subprogram declaration and its body\n+         --  are identical, otherwise they will appear non-conformant due to\n+         --  rewritings in the default values of formal parameters.\n+\n+         Body_Spec := Copy_Subprogram_Spec (Body_Spec);\n+         Set_Specification (N, Body_Spec);\n+         Body_Id := Analyze_Subprogram_Specification (Body_Spec);\n+      end Build_Subprogram_Declaration;\n+\n       ----------------------------\n       -- Check_Anonymous_Return --\n       ----------------------------\n@@ -3221,68 +3250,9 @@ package body Sem_Ch6 is\n                  --  to the spec, leading to legality errors.\n \n                  and then not Body_Has_Contract\n+                 and then not Inside_A_Generic\n                then\n-                  declare\n-                     Body_Spec : constant Node_Id :=\n-                                   Copy_Separate_Tree (Specification (N));\n-                     New_Decl  : constant Node_Id :=\n-                                   Make_Subprogram_Declaration (Loc,\n-                                     Copy_Separate_Tree (Specification (N)));\n-\n-                     SPARK_Mode_Aspect : Node_Id;\n-                     Aspects           : List_Id;\n-                     Prag, Aspect      : Node_Id;\n-\n-                  begin\n-                     Insert_Before (N, New_Decl);\n-                     Move_Aspects (From => N, To => New_Decl);\n-\n-                     --  Mark the newly moved aspects as not analyzed, so that\n-                     --  their effect on New_Decl is properly analyzed.\n-\n-                     Aspect := First (Aspect_Specifications (New_Decl));\n-                     while Present (Aspect) loop\n-                        Set_Analyzed (Aspect, False);\n-                        Next (Aspect);\n-                     end loop;\n-\n-                     Analyze (New_Decl);\n-\n-                     --  The analysis of the generated subprogram declaration\n-                     --  may have introduced pragmas that need to be analyzed.\n-\n-                     Prag := Next (New_Decl);\n-                     while Prag /= N loop\n-                        Analyze (Prag);\n-                        Next (Prag);\n-                     end loop;\n-\n-                     Spec_Id := Defining_Entity (New_Decl);\n-\n-                     --  As Body_Id originally comes from source, mark the new\n-                     --  Spec_Id as such, which is required so that calls to\n-                     --  this subprogram are registered in the local effects\n-                     --  stored in ALI files for GNATprove.\n-\n-                     Set_Comes_From_Source (Spec_Id, True);\n-\n-                     --  If aspect SPARK_Mode was specified on the body, it\n-                     --  needs to be repeated on the generated decl and the\n-                     --  body. Since the original aspect was moved to the\n-                     --  generated decl, copy it for the body.\n-\n-                     if Has_Aspect (Spec_Id, Aspect_SPARK_Mode) then\n-                        SPARK_Mode_Aspect :=\n-                          New_Copy (Find_Aspect (Spec_Id, Aspect_SPARK_Mode));\n-                        Set_Analyzed (SPARK_Mode_Aspect, False);\n-                        Aspects := New_List (SPARK_Mode_Aspect);\n-                        Set_Aspect_Specifications (N, Aspects);\n-                     end if;\n-\n-                     Set_Specification (N, Body_Spec);\n-                     Body_Id := Analyze_Subprogram_Specification (Body_Spec);\n-                     Set_Corresponding_Spec (N, Spec_Id);\n-                  end;\n+                  Build_Subprogram_Declaration;\n                end if;\n             end if;\n \n@@ -3777,7 +3747,8 @@ package body Sem_Ch6 is\n         and then Full_Analysis\n         and then not Inside_A_Generic\n         and then Present (Spec_Id)\n-        and then Nkind (Parent (Parent (Spec_Id))) = N_Subprogram_Declaration\n+        and then Nkind (Unit_Declaration_Node (Spec_Id)) =\n+                   N_Subprogram_Declaration\n         and then Can_Be_Inlined_In_GNATprove_Mode (Spec_Id, Body_Id)\n         and then not Body_Has_Contract\n       then"}, {"sha": "ba8eb1d17458bf8946b15dcd9039d9ca010f5e84", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 99, "deletions": 29, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1fe980a29ead0572d0bb451197a14b490adef3/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1fe980a29ead0572d0bb451197a14b490adef3/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8d1fe980a29ead0572d0bb451197a14b490adef3", "patch": "@@ -4412,21 +4412,19 @@ package body Sem_Util is\n       if No (First_Formal (Subp_Id)) then\n          return No_List;\n       else\n-         Plist := New_List;\n+         Plist  := New_List;\n          Formal := First_Formal (Subp_Id);\n          while Present (Formal) loop\n-            Append\n-              (Make_Parameter_Specification (Loc,\n+            Append_To (Plist,\n+              Make_Parameter_Specification (Loc,\n                 Defining_Identifier =>\n-                  Make_Defining_Identifier (Sloc (Formal),\n-                    Chars => Chars (Formal)),\n-                In_Present  => In_Present (Parent (Formal)),\n-                Out_Present => Out_Present (Parent (Formal)),\n-             Parameter_Type =>\n+                  Make_Defining_Identifier (Sloc (Formal), Chars (Formal)),\n+                In_Present          => In_Present (Parent (Formal)),\n+                Out_Present         => Out_Present (Parent (Formal)),\n+                Parameter_Type      =>\n                   New_Occurrence_Of (Etype (Formal), Loc),\n-                Expression =>\n-                  New_Copy_Tree (Expression (Parent (Formal)))),\n-              Plist);\n+                Expression          =>\n+                  New_Copy_Tree (Expression (Parent (Formal)))));\n \n             Next_Formal (Formal);\n          end loop;\n@@ -4435,6 +4433,43 @@ package body Sem_Util is\n       return Plist;\n    end Copy_Parameter_List;\n \n+   --------------------------\n+   -- Copy_Subprogram_Spec --\n+   --------------------------\n+\n+   function Copy_Subprogram_Spec (Spec : Node_Id) return Node_Id is\n+      Def_Id      : Node_Id;\n+      Formal_Spec : Node_Id;\n+      Result      : Node_Id;\n+\n+   begin\n+      --  The structure of the original tree must be replicated without any\n+      --  alterations. Use New_Copy_Tree for this purpose.\n+\n+      Result := New_Copy_Tree (Spec);\n+\n+      --  Create a new entity for the defining unit name\n+\n+      Def_Id := Defining_Unit_Name (Result);\n+      Set_Defining_Unit_Name (Result,\n+        Make_Defining_Identifier (Sloc (Def_Id), Chars (Def_Id)));\n+\n+      --  Create new entities for the formal parameters\n+\n+      if Present (Parameter_Specifications (Result)) then\n+         Formal_Spec := First (Parameter_Specifications (Result));\n+         while Present (Formal_Spec) loop\n+            Def_Id := Defining_Identifier (Formal_Spec);\n+            Set_Defining_Identifier (Formal_Spec,\n+              Make_Defining_Identifier (Sloc (Def_Id), Chars (Def_Id)));\n+\n+            Next (Formal_Spec);\n+         end loop;\n+      end if;\n+\n+      return Result;\n+   end Copy_Subprogram_Spec;\n+\n    --------------------------------\n    -- Corresponding_Generic_Type --\n    --------------------------------\n@@ -10299,6 +10334,29 @@ package body Sem_Util is\n             or else Is_Task_Interface (T));\n    end Is_Concurrent_Interface;\n \n+   -----------------------\n+   -- Is_Constant_Bound --\n+   -----------------------\n+\n+   function Is_Constant_Bound (Exp : Node_Id) return Boolean is\n+   begin\n+      if Compile_Time_Known_Value (Exp) then\n+         return True;\n+\n+      elsif Is_Entity_Name (Exp) and then Present (Entity (Exp)) then\n+         return Is_Constant_Object (Entity (Exp))\n+           or else Ekind (Entity (Exp)) = E_Enumeration_Literal;\n+\n+      elsif Nkind (Exp) in N_Binary_Op then\n+         return Is_Constant_Bound (Left_Opnd (Exp))\n+           and then Is_Constant_Bound (Right_Opnd (Exp))\n+           and then Scope (Entity (Exp)) = Standard_Standard;\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Constant_Bound;\n+\n    ---------------------------\n    --  Is_Container_Element --\n    ---------------------------\n@@ -10478,28 +10536,40 @@ package body Sem_Util is\n       end;\n    end Is_Container_Element;\n \n-   -----------------------\n-   -- Is_Constant_Bound --\n-   -----------------------\n-\n-   function Is_Constant_Bound (Exp : Node_Id) return Boolean is\n-   begin\n-      if Compile_Time_Known_Value (Exp) then\n-         return True;\n+   ----------------------------\n+   -- Is_Contract_Annotation --\n+   ----------------------------\n \n-      elsif Is_Entity_Name (Exp) and then Present (Entity (Exp)) then\n-         return Is_Constant_Object (Entity (Exp))\n-           or else Ekind (Entity (Exp)) = E_Enumeration_Literal;\n+   function Is_Contract_Annotation (Item : Node_Id) return Boolean is\n+      Nam : Name_Id;\n \n-      elsif Nkind (Exp) in N_Binary_Op then\n-         return Is_Constant_Bound (Left_Opnd (Exp))\n-           and then Is_Constant_Bound (Right_Opnd (Exp))\n-           and then Scope (Entity (Exp)) = Standard_Standard;\n+   begin\n+      if Nkind (Item) = N_Aspect_Specification then\n+         Nam := Chars (Identifier (Item));\n \n-      else\n-         return False;\n+      else pragma Assert (Nkind (Item) = N_Pragma);\n+         Nam := Pragma_Name (Item);\n       end if;\n-   end Is_Constant_Bound;\n+\n+      return\n+        Nam = Name_Abstract_State\n+          or else Nam = Name_Contract_Cases\n+          or else Nam = Name_Depends\n+          or else Nam = Name_Extensions_Visible\n+          or else Nam = Name_Global\n+          or else Nam = Name_Initial_Condition\n+          or else Nam = Name_Initializes\n+          or else Nam = Name_Post\n+          or else Nam = Name_Post_Class\n+          or else Nam = Name_Postcondition\n+          or else Nam = Name_Pre\n+          or else Nam = Name_Pre_Class\n+          or else Nam = Name_Precondition\n+          or else Nam = Name_Refined_Depends\n+          or else Nam = Name_Refined_Global\n+          or else Nam = Name_Refined_State\n+          or else Nam = Name_Test_Case;\n+   end Is_Contract_Annotation;\n \n    --------------------------------------\n    -- Is_Controlling_Limited_Procedure --"}, {"sha": "044047bc86248b21d63a267e504a4eecb5b6d00e", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1fe980a29ead0572d0bb451197a14b490adef3/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1fe980a29ead0572d0bb451197a14b490adef3/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=8d1fe980a29ead0572d0bb451197a14b490adef3", "patch": "@@ -397,19 +397,24 @@ package Sem_Util is\n    --    Depends\n    --    Global\n \n-   function Copy_Parameter_List (Subp_Id : Entity_Id) return List_Id;\n-   --  Utility to create a parameter profile for a new subprogram spec, when\n-   --  the subprogram has a body that acts as spec. This is done for some cases\n-   --  of inlining, and for private protected ops. Also used to create bodies\n-   --  for stubbed subprograms.\n-\n    function Copy_Component_List\n      (R_Typ : Entity_Id;\n       Loc   : Source_Ptr) return List_Id;\n    --  Copy components from record type R_Typ that come from source. Used to\n    --  create a new compatible record type. Loc is the source location assigned\n    --  to the created nodes.\n \n+   function Copy_Parameter_List (Subp_Id : Entity_Id) return List_Id;\n+   --  Utility to create a parameter profile for a new subprogram spec, when\n+   --  the subprogram has a body that acts as spec. This is done for some cases\n+   --  of inlining, and for private protected ops. Also used to create bodies\n+   --  for stubbed subprograms.\n+\n+   function Copy_Subprogram_Spec (Spec : Node_Id) return Node_Id;\n+   --  Replicate a function or a procedure specification denoted by Spec. The\n+   --  resulting tree is an exact duplicate of the original tree. New entities\n+   --  are created for the unit name and the formal parameters.\n+\n    function Corresponding_Generic_Type (T : Entity_Id) return Entity_Id;\n    --  If a type is a generic actual type, return the corresponding formal in\n    --  the generic parent unit. There is no direct link in the tree for this\n@@ -1186,6 +1191,10 @@ package Sem_Util is\n    --  explicit dereference. The transformation applies when it has the form\n    --  F (X).Discr.all.\n \n+   function Is_Contract_Annotation (Item : Node_Id) return Boolean;\n+   --  Determine whether aspect specification or pragma Item is a contract\n+   --  annotation.\n+\n    function Is_Controlling_Limited_Procedure\n      (Proc_Nam : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-345): Determine whether Proc_Nam is a primitive procedure"}]}