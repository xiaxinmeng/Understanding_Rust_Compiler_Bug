{"sha": "875eda9c345e57676c4f21f753274ee51025fa41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc1ZWRhOWMzNDVlNTc2NzZjNGYyMWY3NTMyNzRlZTUxMDI1ZmE0MQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-10-03T21:33:57Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-10-03T21:33:57Z"}, "message": "PR optimization/9325, PR java/6391\n\n\n\tPR optimization/9325, PR java/6391\n\t* fold-const.c (fold_convert): For floating point to integer\n\tconversions, return the maximum/minimum representable integer\n\tvalue if the real constant overflows the destination type.\n\t* tree.c (real_value_from_int_cst): Allow the type to be NULL,\n\tmeaning don't truncate the result to a floating point mode.\n\tSimplify the logic by calling real_from_integer directly.\n\t* simplify-rtx.c (simplify_unary_operation):  Implement the\n\tsame semantics for folding floating point to integer conversions\n\tin RTL.\n\n\t* gcc.c-torture/execute/20031003-1.c: New test case.\n\nFrom-SVN: r72079", "tree": {"sha": "09c0fbd9595e9411be41c39493368c74ad3a13be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09c0fbd9595e9411be41c39493368c74ad3a13be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/875eda9c345e57676c4f21f753274ee51025fa41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/875eda9c345e57676c4f21f753274ee51025fa41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/875eda9c345e57676c4f21f753274ee51025fa41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/875eda9c345e57676c4f21f753274ee51025fa41/comments", "author": null, "committer": null, "parents": [{"sha": "4dbe1556cce68a32108fbad54c6e445240f8bb4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dbe1556cce68a32108fbad54c6e445240f8bb4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dbe1556cce68a32108fbad54c6e445240f8bb4b"}], "stats": {"total": 245, "additions": 202, "deletions": 43}, "files": [{"sha": "123cb3fa84d428cefc53c498e2eb43fb2ed965c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875eda9c345e57676c4f21f753274ee51025fa41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875eda9c345e57676c4f21f753274ee51025fa41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=875eda9c345e57676c4f21f753274ee51025fa41", "patch": "@@ -1,3 +1,16 @@\n+2003-10-03  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR optimization/9325, PR java/6391\n+\t* fold-const.c (fold_convert): For floating point to integer\n+\tconversions, return the maximum/minimum representable integer\n+\tvalue if the real constant overflows the destination type.\n+\t* tree.c (real_value_from_int_cst): Allow the type to be NULL,\n+\tmeaning don't truncate the result to a floating point mode.\n+\tSimplify the logic by calling real_from_integer directly.\n+\t* simplify-rtx.c (simplify_unary_operation):  Implement the\n+\tsame semantics for folding floating point to integer conversions\n+\tin RTL.\n+\n 2003-10-03  Chris Demetriou  <cgd@broadcom.com>\n \n \t* config/mips/mips.c (mips_emit_prefetch): Restructure"}, {"sha": "1cf444d3f67f44d51f9f7b67a42a4a6bd7047912", "filename": "gcc/fold-const.c", "status": "modified", "additions": 51, "deletions": 29, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875eda9c345e57676c4f21f753274ee51025fa41/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875eda9c345e57676c4f21f753274ee51025fa41/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=875eda9c345e57676c4f21f753274ee51025fa41", "patch": "@@ -1599,41 +1599,63 @@ fold_convert (tree t, tree arg1)\n \t}\n       else if (TREE_CODE (arg1) == REAL_CST)\n \t{\n-\t  /* Don't initialize these, use assignments.\n-\t     Initialized local aggregates don't work on old compilers.  */\n-\t  REAL_VALUE_TYPE x;\n-\t  REAL_VALUE_TYPE l;\n-\t  REAL_VALUE_TYPE u;\n-\t  tree type1 = TREE_TYPE (arg1);\n-\t  int no_upper_bound;\n-\n-\t  x = TREE_REAL_CST (arg1);\n-\t  l = real_value_from_int_cst (type1, TYPE_MIN_VALUE (type));\n-\n-\t  no_upper_bound = (TYPE_MAX_VALUE (type) == NULL);\n-\t  if (!no_upper_bound)\n-\t    u = real_value_from_int_cst (type1, TYPE_MAX_VALUE (type));\n+\t  /* The following code implements the floating point to integer\n+\t     conversion rules required by the Java Language Specification,\n+\t     that IEEE NaNs are mapped to zero and values that overflow\n+\t     the target precision saturate, i.e. values greater than\n+\t     INT_MAX are mapped to INT_MAX, and values less than INT_MIN\n+\t     are mapped to INT_MIN.  These semantics are allowed by the\n+\t     C and C++ standards that simply state that the behavior of\n+\t     FP-to-integer conversion is unspecified upon overflow.  */\n+\n+\t  HOST_WIDE_INT high, low;\n+\n+\t  REAL_VALUE_TYPE x = TREE_REAL_CST (arg1);\n+\t  /* If x is NaN, return zero and show we have an overflow.  */\n+\t  if (REAL_VALUE_ISNAN (x))\n+\t    {\n+\t      overflow = 1;\n+\t      high = 0;\n+\t      low = 0;\n+\t    }\n \n \t  /* See if X will be in range after truncation towards 0.\n \t     To compensate for truncation, move the bounds away from 0,\n \t     but reject if X exactly equals the adjusted bounds.  */\n-\t  REAL_ARITHMETIC (l, MINUS_EXPR, l, dconst1);\n-\t  if (!no_upper_bound)\n-\t    REAL_ARITHMETIC (u, PLUS_EXPR, u, dconst1);\n-\t  /* If X is a NaN, use zero instead and show we have an overflow.\n-\t     Otherwise, range check.  */\n-\t  if (REAL_VALUE_ISNAN (x))\n-\t    overflow = 1, x = dconst0;\n-\t  else if (! (REAL_VALUES_LESS (l, x)\n-\t\t      && !no_upper_bound\n-\t\t      && REAL_VALUES_LESS (x, u)))\n-\t    overflow = 1;\n \n-\t  {\n-\t    HOST_WIDE_INT low, high;\n+\t  if (! overflow)\n+\t    {\n+\t      tree lt = TYPE_MIN_VALUE (type);\n+\t      REAL_VALUE_TYPE l = real_value_from_int_cst (NULL_TREE, lt);\n+\t      REAL_ARITHMETIC (l, MINUS_EXPR, l, dconst1);\n+\t      if (! REAL_VALUES_LESS (l, x))\n+\t\t{\n+\t\t  overflow = 1;\n+\t\t  high = TREE_INT_CST_HIGH (lt);\n+\t\t  low = TREE_INT_CST_LOW (lt);\n+\t\t}\n+\t    }\n+\n+\t  if (! overflow)\n+\t    {\n+\t      tree ut = TYPE_MAX_VALUE (type);\n+\t      if (ut)\n+\t\t{\n+\t\t  REAL_VALUE_TYPE u = real_value_from_int_cst (NULL_TREE, ut);\n+\t\t  REAL_ARITHMETIC (u, PLUS_EXPR, u, dconst1);\n+\t\t  if (! REAL_VALUES_LESS (x, u))\n+\t\t    {\n+\t\t      overflow = 1;\n+\t\t      high = TREE_INT_CST_HIGH (ut);\n+\t\t      low = TREE_INT_CST_LOW (ut);\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  if (! overflow)\n \t    REAL_VALUE_TO_INT (&low, &high, x);\n-\t    t = build_int_2 (low, high);\n-\t  }\n+\n+\t  t = build_int_2 (low, high);\n \t  TREE_TYPE (t) = type;\n \t  TREE_OVERFLOW (t)\n \t    = TREE_OVERFLOW (arg1) | force_fit_type (t, overflow);"}, {"sha": "3e0bdbfa27a0c6d2a2e5a2bc42edbf869c0641dc", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 87, "deletions": 7, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875eda9c345e57676c4f21f753274ee51025fa41/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875eda9c345e57676c4f21f753274ee51025fa41/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=875eda9c345e57676c4f21f753274ee51025fa41", "patch": "@@ -775,19 +775,99 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n   else if (GET_CODE (trueop) == CONST_DOUBLE\n \t   && GET_MODE_CLASS (GET_MODE (trueop)) == MODE_FLOAT\n \t   && GET_MODE_CLASS (mode) == MODE_INT\n-\t   && width <= HOST_BITS_PER_WIDE_INT && width > 0)\n+\t   && width <= 2*HOST_BITS_PER_WIDE_INT && width > 0)\n     {\n-      HOST_WIDE_INT i;\n-      REAL_VALUE_TYPE d;\n-      REAL_VALUE_FROM_CONST_DOUBLE (d, trueop);\n+      /* Although the overflow semantics of RTL's FIX and UNSIGNED_FIX\n+\t operators are intentionally left unspecified (to ease implemention\n+\t by target backends), for consistency, this routine implements the\n+\t same semantics for constant folding as used by the middle-end.  */\n+\n+      HOST_WIDE_INT xh, xl, th, tl;\n+      REAL_VALUE_TYPE x, t;\n+      REAL_VALUE_FROM_CONST_DOUBLE (x, trueop);\n       switch (code)\n \t{\n-\tcase FIX:\t\ti = REAL_VALUE_FIX (d);\t\t  break;\n-\tcase UNSIGNED_FIX:\ti = REAL_VALUE_UNSIGNED_FIX (d);  break;\n+\tcase FIX:\n+\t  if (REAL_VALUE_ISNAN (x))\n+\t    return const0_rtx;\n+\n+\t  /* Test against the signed upper bound.  */\n+\t  if (width > HOST_BITS_PER_WIDE_INT)\n+\t    {\n+\t      th = ((unsigned HOST_WIDE_INT) 1\n+\t\t    << (width - HOST_BITS_PER_WIDE_INT - 1)) - 1;\n+\t      tl = -1;\n+\t    }\n+\t  else\n+\t    {\n+\t      th = 0;\n+\t      tl = ((unsigned HOST_WIDE_INT) 1 << (width - 1)) - 1;\n+\t    }\n+\t  real_from_integer (&t, VOIDmode, tl, th, 0);\n+\t  if (REAL_VALUES_LESS (t, x))\n+\t    {\n+\t      xh = th;\n+\t      xl = tl;\n+\t      break;\n+\t    }\n+\n+\t  /* Test against the signed lower bound.  */\n+\t  if (width > HOST_BITS_PER_WIDE_INT)\n+\t    {\n+\t      th = (HOST_WIDE_INT) -1 << (width - HOST_BITS_PER_WIDE_INT - 1);\n+\t      tl = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      th = -1;\n+\t      tl = (HOST_WIDE_INT) -1 << (width - 1);\n+\t    }\n+\t  real_from_integer (&t, VOIDmode, tl, th, 0);\n+\t  if (REAL_VALUES_LESS (x, t))\n+\t    {\n+\t      xh = th;\n+\t      xl = tl;\n+\t      break;\n+\t    }\n+\t  REAL_VALUE_TO_INT (&xl, &xh, x);\n+\t  break;\n+\n+\tcase UNSIGNED_FIX:\n+\t  if (REAL_VALUE_ISNAN (x) || REAL_VALUE_NEGATIVE (x))\n+\t    return const0_rtx;\n+\n+\t  /* Test against the unsigned upper bound.  */\n+\t  if (width == 2*HOST_BITS_PER_WIDE_INT)\n+\t    {\n+\t      th = -1;\n+\t      tl = -1;\n+\t    }\n+\t  else if (width >= HOST_BITS_PER_WIDE_INT)\n+\t    {\n+\t      th = ((unsigned HOST_WIDE_INT) 1\n+\t\t    << (width - HOST_BITS_PER_WIDE_INT)) - 1;\n+\t      tl = -1;\n+\t    }\n+\t  else\n+\t    {\n+\t      th = 0;\n+\t      tl = ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n+\t    }\n+\t  real_from_integer (&t, VOIDmode, tl, th, 1);\n+\t  if (REAL_VALUES_LESS (t, x))\n+\t    {\n+\t      xh = th;\n+\t      xl = tl;\n+\t      break;\n+\t    }\n+\n+\t  REAL_VALUE_TO_INT (&xl, &xh, x);\n+\t  break;\n+\n \tdefault:\n \t  abort ();\n \t}\n-      return gen_int_mode (i, mode);\n+      return immed_double_const (xl, xh, mode);\n     }\n \n   /* This was formerly used only for non-IEEE float."}, {"sha": "7e10c016b4cce50af372e697341b5cfadc626b84", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875eda9c345e57676c4f21f753274ee51025fa41/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875eda9c345e57676c4f21f753274ee51025fa41/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=875eda9c345e57676c4f21f753274ee51025fa41", "patch": "@@ -1,3 +1,8 @@\n+2003-10-03  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR optimization/9325, PR java/6391\n+\t* gcc.c-torture/execute/20031003-1.c: New test case.\n+\n 2003-10-02  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR optimization/12180"}, {"sha": "b60711f732bf4d88626a0327d2c7ba5e08bbebb7", "filename": "gcc/testsuite/gcc.c-torture/execute/20031003-1.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875eda9c345e57676c4f21f753274ee51025fa41/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20031003-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875eda9c345e57676c4f21f753274ee51025fa41/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20031003-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20031003-1.c?ref=875eda9c345e57676c4f21f753274ee51025fa41", "patch": "@@ -0,0 +1,42 @@\n+/* PR optimization/9325  */\n+\n+extern void abort (void);\n+\n+int f1()\n+{\n+  return (int)2147483648.0f;\n+}\n+\n+int f2()\n+{\n+  return (int)(float)(2147483647);\n+}\n+\n+int f3()\n+{\n+  float a = 2147483648.0f;\n+  return (int)a;\n+}\n+\n+int f4()\n+{\n+  int a = 2147483647;\n+  float b = (float)a;\n+  return (int)b;\n+}\n+\n+int main()\n+{\n+  if (f1() != 2147483647)\n+    abort ();\n+  if (f2() != 2147483647)\n+    abort ();\n+#ifdef __OPTIMIZE__\n+  if (f3() != 2147483647)\n+    abort ();\n+  if (f4() != 2147483647)\n+    abort ();\n+#endif\n+  return 0;\n+}\n+"}, {"sha": "c83b24052b6f7f20cdb7b5e21423153b6ece1ff8", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875eda9c345e57676c4f21f753274ee51025fa41/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875eda9c345e57676c4f21f753274ee51025fa41/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=875eda9c345e57676c4f21f753274ee51025fa41", "patch": "@@ -488,20 +488,17 @@ build_real (tree type, REAL_VALUE_TYPE d)\n    and whose value is the integer value of the INTEGER_CST node I.  */\n \n REAL_VALUE_TYPE\n-real_value_from_int_cst (tree type ATTRIBUTE_UNUSED, tree i)\n+real_value_from_int_cst (tree type, tree i)\n {\n   REAL_VALUE_TYPE d;\n \n   /* Clear all bits of the real value type so that we can later do\n      bitwise comparisons to see if two values are the same.  */\n   memset (&d, 0, sizeof d);\n \n-  if (! TREE_UNSIGNED (TREE_TYPE (i)))\n-    REAL_VALUE_FROM_INT (d, TREE_INT_CST_LOW (i), TREE_INT_CST_HIGH (i),\n-\t\t\t TYPE_MODE (type));\n-  else\n-    REAL_VALUE_FROM_UNSIGNED_INT (d, TREE_INT_CST_LOW (i),\n-\t\t\t\t  TREE_INT_CST_HIGH (i), TYPE_MODE (type));\n+  real_from_integer (&d, type ? TYPE_MODE (type) : VOIDmode,\n+\t\t     TREE_INT_CST_LOW (i), TREE_INT_CST_HIGH (i),\n+\t\t     TREE_UNSIGNED (TREE_TYPE (i)));\n   return d;\n }\n "}]}