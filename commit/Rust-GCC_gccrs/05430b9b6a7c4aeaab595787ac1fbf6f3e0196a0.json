{"sha": "05430b9b6a7c4aeaab595787ac1fbf6f3e0196a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU0MzBiOWI2YTdjNGFlYWFiNTk1Nzg3YWMxZmJmNmYzZTAxOTZhMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-05-31T15:30:55Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-05-31T15:36:58Z"}, "message": "Cleanup indexable tree streaming.\n\ngcc/\n\n\t* lto-section-out.c (lto_output_decl_index): Remove.\n\t(lto_output_field_decl_index): Move to lto-streamer-out.c\n\t(lto_output_fn_decl_index): Move to lto-streamer-out.c\n\t(lto_output_namespace_decl_index): Remove.\n\t(lto_output_var_decl_index): Remove.\n\t(lto_output_type_decl_index): Remove.\n\t(lto_output_type_ref_index): Remove.\n\t* lto-streamer-out.c (output_type_ref): Remove.\n\t(lto_get_index): New function.\n\t(lto_output_tree_ref): Remove.\n\t(lto_indexable_tree_ref): New function.\n\t(lto_output_var_decl_index): Move here from lto-section-out.c; simplify.\n\t(lto_output_fn_decl_index): Move here from lto-section-out.c; simplify.\n\t(stream_write_tree_ref): Update.\n\t(lto_output_tree): Update.\n\t* lto-streamer.h (lto_output_decl_index): Remove prototype.\n\t(lto_output_field_decl_index): Remove prototype.\n\t(lto_output_namespace_decl_index): Remove prototype.\n\t(lto_output_type_decl_index): Remove prototype.\n\t(lto_output_type_ref_index): Remove prototype.\n\t(lto_output_var_decl_index): Move.\n\t(lto_output_fn_decl_index): Move", "tree": {"sha": "b071f55a317925dc0e88f1672122cc7a72dc08a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b071f55a317925dc0e88f1672122cc7a72dc08a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05430b9b6a7c4aeaab595787ac1fbf6f3e0196a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05430b9b6a7c4aeaab595787ac1fbf6f3e0196a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05430b9b6a7c4aeaab595787ac1fbf6f3e0196a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05430b9b6a7c4aeaab595787ac1fbf6f3e0196a0/comments", "author": null, "committer": null, "parents": [{"sha": "1d2d5afc80f07b1a62b025f17310c91a17500ab7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d2d5afc80f07b1a62b025f17310c91a17500ab7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d2d5afc80f07b1a62b025f17310c91a17500ab7"}], "stats": {"total": 333, "additions": 134, "deletions": 199}, "files": [{"sha": "b546e8a2fe077e9f295a3df8a05b41595da9397a", "filename": "gcc/lto-section-out.c", "status": "modified", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05430b9b6a7c4aeaab595787ac1fbf6f3e0196a0/gcc%2Flto-section-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05430b9b6a7c4aeaab595787ac1fbf6f3e0196a0/gcc%2Flto-section-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-out.c?ref=05430b9b6a7c4aeaab595787ac1fbf6f3e0196a0", "patch": "@@ -147,111 +147,6 @@ lto_write_stream (struct lto_output_stream *obs)\n     }\n }\n \n-\n-/* Lookup NAME in ENCODER.  If NAME is not found, create a new entry in\n-   ENCODER for NAME with the next available index of ENCODER,  then\n-   print the index to OBS.  True is returned if NAME was added to\n-   ENCODER.  The resulting index is stored in THIS_INDEX.\n-\n-   If OBS is NULL, the only action is to add NAME to the encoder. */\n-\n-bool\n-lto_output_decl_index (struct lto_output_stream *obs,\n-\t\t       struct lto_tree_ref_encoder *encoder,\n-\t\t       tree name, unsigned int *this_index)\n-{\n-  bool new_entry_p = FALSE;\n-  bool existed_p;\n-\n-  unsigned int &index\n-    = encoder->tree_hash_table->get_or_insert (name, &existed_p);\n-  if (!existed_p)\n-    {\n-      index = encoder->trees.length ();\n-      if (streamer_dump_file)\n-\t{\n-\t  print_node_brief (streamer_dump_file, \"     Encoding indexable \",\n-\t\t\t    name, 4);\n-\t  fprintf (streamer_dump_file, \"  as %i \\n\", index);\n-\t}\n-      encoder->trees.safe_push (name);\n-      new_entry_p = TRUE;\n-    }\n-\n-  if (obs)\n-    streamer_write_uhwi_stream (obs, index);\n-  *this_index = index;\n-  return new_entry_p;\n-}\n-\n-/* Output a field DECL to OBS.  */\n-\n-void\n-lto_output_field_decl_index (struct lto_out_decl_state *decl_state,\n-\t\t\t     struct lto_output_stream * obs, tree decl)\n-{\n-  unsigned int index;\n-  lto_output_decl_index (obs, &decl_state->streams[LTO_DECL_STREAM_FIELD_DECL],\n-\t\t\t decl, &index);\n-}\n-\n-/* Output a function DECL to OBS.  */\n-\n-void\n-lto_output_fn_decl_index (struct lto_out_decl_state *decl_state,\n-\t\t\t  struct lto_output_stream * obs, tree decl)\n-{\n-  unsigned int index;\n-  lto_output_decl_index (obs, &decl_state->streams[LTO_DECL_STREAM_FN_DECL],\n-\t\t\t decl, &index);\n-}\n-\n-/* Output a namespace DECL to OBS.  */\n-\n-void\n-lto_output_namespace_decl_index (struct lto_out_decl_state *decl_state,\n-\t\t\t\t struct lto_output_stream * obs, tree decl)\n-{\n-  unsigned int index;\n-  lto_output_decl_index (obs,\n-\t\t\t &decl_state->streams[LTO_DECL_STREAM_NAMESPACE_DECL],\n-\t\t\t decl, &index);\n-}\n-\n-/* Output a static or extern var DECL to OBS.  */\n-\n-void\n-lto_output_var_decl_index (struct lto_out_decl_state *decl_state,\n-\t\t\t   struct lto_output_stream * obs, tree decl)\n-{\n-  unsigned int index;\n-  lto_output_decl_index (obs, &decl_state->streams[LTO_DECL_STREAM_VAR_DECL],\n-\t\t\t decl, &index);\n-}\n-\n-/* Output a type DECL to OBS.  */\n-\n-void\n-lto_output_type_decl_index (struct lto_out_decl_state *decl_state,\n-\t\t\t    struct lto_output_stream * obs, tree decl)\n-{\n-  unsigned int index;\n-  lto_output_decl_index (obs, &decl_state->streams[LTO_DECL_STREAM_TYPE_DECL],\n-\t\t\t decl, &index);\n-}\n-\n-/* Output a type REF to OBS.  */\n-\n-void\n-lto_output_type_ref_index (struct lto_out_decl_state *decl_state,\n-\t\t\t   struct lto_output_stream *obs, tree ref)\n-{\n-  unsigned int index;\n-  lto_output_decl_index (obs, &decl_state->streams[LTO_DECL_STREAM_TYPE],\n-\t\t\t ref, &index);\n-}\n-\n-\n /* Create the output block and return it.  */\n \n struct lto_simple_output_block *"}, {"sha": "1910ee2a5ea147c5b2f7deb613a04ae047ff5bbb", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 130, "deletions": 79, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05430b9b6a7c4aeaab595787ac1fbf6f3e0196a0/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05430b9b6a7c4aeaab595787ac1fbf6f3e0196a0/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=05430b9b6a7c4aeaab595787ac1fbf6f3e0196a0", "patch": "@@ -119,15 +119,6 @@ destroy_output_block (struct output_block *ob)\n }\n \n \n-/* Look up NODE in the type table and write the index for it to OB.  */\n-\n-static void\n-output_type_ref (struct output_block *ob, tree node)\n-{\n-  streamer_write_record_start (ob, LTO_type_ref);\n-  lto_output_type_ref_index (ob->decl_state, ob->main_stream, node);\n-}\n-\n /* Wrapper around variably_modified_type_p avoiding type modification\n    during WPA streaming.  */\n \n@@ -224,97 +215,148 @@ lto_output_location (struct output_block *ob, struct bitpack_d *bp,\n }\n \n \n+/* Lookup NAME in ENCODER.  If NAME is not found, create a new entry in\n+   ENCODER for NAME with the next available index of ENCODER,  then\n+   print the index to OBS.\n+   Return the index.  */\n+\n+\n+static unsigned\n+lto_get_index (struct lto_tree_ref_encoder *encoder, tree t)\n+{\n+  bool existed_p;\n+\n+  unsigned int &index\n+    = encoder->tree_hash_table->get_or_insert (t, &existed_p);\n+  if (!existed_p)\n+    {\n+      index = encoder->trees.length ();\n+      if (streamer_dump_file)\n+\t{\n+\t  print_node_brief (streamer_dump_file, \"     Encoding indexable \",\n+\t\t\t    t, 4);\n+\t  fprintf (streamer_dump_file, \"  as %i \\n\", index);\n+\t}\n+      encoder->trees.safe_push (t);\n+    }\n+\n+  return index;\n+}\n+\n+\n /* If EXPR is an indexable tree node, output a reference to it to\n    output block OB.  Otherwise, output the physical representation of\n    EXPR to OB.  */\n \n static void\n-lto_output_tree_ref (struct output_block *ob, tree expr)\n+lto_indexable_tree_ref (struct output_block *ob, tree expr,\n+\t\t\tenum LTO_tags *tag, unsigned *index)\n {\n   enum tree_code code;\n+  enum lto_decl_stream_e_t encoder;\n+\n+  gcc_checking_assert (tree_is_indexable (expr));\n \n   if (TYPE_P (expr))\n     {\n-      output_type_ref (ob, expr);\n-      return;\n+      *tag = LTO_type_ref;\n+      encoder = LTO_DECL_STREAM_TYPE;\n     }\n-\n-  code = TREE_CODE (expr);\n-  switch (code)\n+  else\n     {\n-    case SSA_NAME:\n-      streamer_write_record_start (ob, LTO_ssa_name_ref);\n-      streamer_write_uhwi (ob, SSA_NAME_VERSION (expr));\n-      break;\n+      code = TREE_CODE (expr);\n+      switch (code)\n+\t{\n+\tcase SSA_NAME:\n+\t  *tag = LTO_ssa_name_ref;\n+\t  *index = SSA_NAME_VERSION (expr);\n+\t  return;\n+\t  break;\n \n-    case FIELD_DECL:\n-      streamer_write_record_start (ob, LTO_field_decl_ref);\n-      lto_output_field_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n+\tcase FIELD_DECL:\n+\t  *tag = LTO_field_decl_ref;\n+\t  encoder = LTO_DECL_STREAM_FIELD_DECL;\n+\t  break;\n \n-    case FUNCTION_DECL:\n-      streamer_write_record_start (ob, LTO_function_decl_ref);\n-      lto_output_fn_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n+\tcase FUNCTION_DECL:\n+\t  *tag = LTO_function_decl_ref;\n+\t  encoder = LTO_DECL_STREAM_FN_DECL;\n+\t  break;\n \n-    case VAR_DECL:\n-    case DEBUG_EXPR_DECL:\n-      gcc_assert (decl_function_context (expr) == NULL || TREE_STATIC (expr));\n-      /* FALLTHRU */\n-    case PARM_DECL:\n-      streamer_write_record_start (ob, LTO_global_decl_ref);\n-      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n-\n-    case CONST_DECL:\n-      streamer_write_record_start (ob, LTO_const_decl_ref);\n-      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n-\n-    case IMPORTED_DECL:\n-      gcc_assert (decl_function_context (expr) == NULL);\n-      streamer_write_record_start (ob, LTO_imported_decl_ref);\n-      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n-\n-    case TYPE_DECL:\n-      streamer_write_record_start (ob, LTO_type_decl_ref);\n-      lto_output_type_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n-\n-    case NAMELIST_DECL:\n-      streamer_write_record_start (ob, LTO_namelist_decl_ref);\n-      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n+\tcase VAR_DECL:\n+\tcase DEBUG_EXPR_DECL:\n+\t  gcc_checking_assert (decl_function_context (expr) == NULL\n+\t\t\t       || TREE_STATIC (expr));\n+\t  /* FALLTHRU */\n+\tcase PARM_DECL:\n+\t  *tag = LTO_global_decl_ref;\n+\t  encoder = LTO_DECL_STREAM_VAR_DECL;\n+\t  break;\n \n-    case NAMESPACE_DECL:\n-      streamer_write_record_start (ob, LTO_namespace_decl_ref);\n-      lto_output_namespace_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n+\tcase CONST_DECL:\n+\t  *tag = LTO_const_decl_ref;\n+\t  encoder = LTO_DECL_STREAM_VAR_DECL;\n+\t  break;\n \n-    case LABEL_DECL:\n-      streamer_write_record_start (ob, LTO_label_decl_ref);\n-      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n+\tcase TYPE_DECL:\n+\t  *tag = LTO_type_decl_ref;\n+\t  encoder = LTO_DECL_STREAM_TYPE_DECL;\n+\t  break;\n \n-    case RESULT_DECL:\n-      streamer_write_record_start (ob, LTO_result_decl_ref);\n-      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n+\tcase NAMESPACE_DECL:\n+\t  *tag = LTO_namespace_decl_ref;\n+\t  encoder = LTO_DECL_STREAM_NAMESPACE_DECL;\n+\t  break;\n \n-    case TRANSLATION_UNIT_DECL:\n-      streamer_write_record_start (ob, LTO_translation_unit_decl_ref);\n-      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n+\tcase LABEL_DECL:\n+\t  *tag = LTO_label_decl_ref;\n+\t  encoder = LTO_DECL_STREAM_VAR_DECL;\n+\t  break;\n \n-    default:\n-      /* No other node is indexable, so it should have been handled by\n-\t lto_output_tree.  */\n-      gcc_unreachable ();\n+\tcase RESULT_DECL:\n+\t  *tag = LTO_result_decl_ref;\n+\t  encoder = LTO_DECL_STREAM_VAR_DECL;\n+\t  break;\n+\n+\tcase TRANSLATION_UNIT_DECL:\n+\t  *tag = LTO_translation_unit_decl_ref;\n+\t  encoder = LTO_DECL_STREAM_VAR_DECL;\n+\t  break;\n+\n+\tdefault:\n+\t  /* No other node is indexable, so it should have been handled by\n+\t     lto_output_tree.  */\n+\t  gcc_unreachable ();\n+\t}\n     }\n+  *index = lto_get_index (&ob->decl_state->streams[encoder], expr);\n }\n \n \n+/* Output a static or extern var DECL to OBS.  */\n+\n+void\n+lto_output_var_decl_index (struct lto_out_decl_state *decl_state,\n+\t\t\t   struct lto_output_stream * obs, tree decl)\n+{\n+  gcc_checking_assert (TREE_CODE (decl) == VAR_DECL);\n+  streamer_write_uhwi_stream\n+     (obs, lto_get_index (&decl_state->streams[LTO_DECL_STREAM_VAR_DECL],\n+\t\t\t  decl));\n+}\n+\n+\n+/* Output a static or extern var DECL to OBS.  */\n+\n+void\n+lto_output_fn_decl_index (struct lto_out_decl_state *decl_state,\n+\t\t\t  struct lto_output_stream * obs, tree decl)\n+{\n+  gcc_checking_assert (TREE_CODE (decl) == FUNCTION_DECL);\n+  streamer_write_uhwi_stream\n+     (obs, lto_get_index (&decl_state->streams[LTO_DECL_STREAM_FN_DECL], decl));\n+}\n+\n /* Return true if EXPR is a tree node that can be written to disk.  */\n \n static inline bool\n@@ -427,8 +469,12 @@ stream_write_tree_ref (struct output_block *ob, tree t)\n \tstreamer_write_uhwi (ob, ix + LTO_NUM_TAGS);\n       else\n \t{\n-\t  gcc_checking_assert (tree_is_indexable (t));\n-\t  lto_output_tree_ref (ob, t);\n+\t  enum LTO_tags tag;\n+\t  unsigned ix;\n+\n+\t  lto_indexable_tree_ref (ob, t, &tag, &ix);\n+\t  streamer_write_uhwi (ob, tag);\n+\t  streamer_write_uhwi (ob, ix);\n \t}\n       if (streamer_debugging)\n \tstreamer_write_uhwi (ob, TREE_CODE (t));\n@@ -1754,7 +1800,12 @@ lto_output_tree (struct output_block *ob, tree expr,\n \n   if (this_ref_p && tree_is_indexable (expr))\n     {\n-      lto_output_tree_ref (ob, expr);\n+      enum LTO_tags tag;\n+      unsigned ix;\n+\n+      lto_indexable_tree_ref (ob, expr, &tag, &ix);\n+      streamer_write_record_start (ob, tag);\n+      streamer_write_uhwi (ob, ix);\n       return;\n     }\n "}, {"sha": "6ab0505c3fd31cfd72482e0973d7a4d182878532", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05430b9b6a7c4aeaab595787ac1fbf6f3e0196a0/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05430b9b6a7c4aeaab595787ac1fbf6f3e0196a0/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=05430b9b6a7c4aeaab595787ac1fbf6f3e0196a0", "patch": "@@ -841,21 +841,6 @@ extern void lto_end_section (void);\n extern void lto_write_data (const void *, unsigned int);\n extern void lto_write_raw_data (const void *, unsigned int);\n extern void lto_write_stream (struct lto_output_stream *);\n-extern bool lto_output_decl_index (struct lto_output_stream *,\n-\t\t\t    struct lto_tree_ref_encoder *,\n-\t\t\t    tree, unsigned int *);\n-extern void lto_output_field_decl_index (struct lto_out_decl_state *,\n-\t\t\t\t  struct lto_output_stream *, tree);\n-extern void lto_output_fn_decl_index (struct lto_out_decl_state *,\n-\t\t\t       struct lto_output_stream *, tree);\n-extern void lto_output_namespace_decl_index (struct lto_out_decl_state *,\n-\t\t\t\t      struct lto_output_stream *, tree);\n-extern void lto_output_var_decl_index (struct lto_out_decl_state *,\n-\t\t\t\tstruct lto_output_stream *, tree);\n-extern void lto_output_type_decl_index (struct lto_out_decl_state *,\n-\t\t\t\t struct lto_output_stream *, tree);\n-extern void lto_output_type_ref_index (struct lto_out_decl_state *,\n-\t\t\t\tstruct lto_output_stream *, tree);\n extern struct lto_simple_output_block *lto_create_simple_output_block (\n \t\t\t\tenum lto_section_type);\n extern void lto_destroy_simple_output_block (struct lto_simple_output_block *);\n@@ -923,6 +908,10 @@ extern struct output_block *create_output_block (enum lto_section_type);\n extern void destroy_output_block (struct output_block *);\n extern void lto_output_tree (struct output_block *, tree, bool, bool);\n extern void stream_write_tree_ref (struct output_block *, tree);\n+extern void lto_output_var_decl_index (struct lto_out_decl_state *,\n+\t\t\t\t       struct lto_output_stream *, tree);\n+extern void lto_output_fn_decl_index (struct lto_out_decl_state *,\n+\t\t\t\t      struct lto_output_stream *, tree);\n extern void lto_output_toplevel_asms (void);\n extern void produce_asm (struct output_block *ob, tree fn);\n extern void lto_output ();"}]}