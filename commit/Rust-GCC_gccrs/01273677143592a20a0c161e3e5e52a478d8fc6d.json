{"sha": "01273677143592a20a0c161e3e5e52a478d8fc6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEyNzM2NzcxNDM1OTJhMjBhMGMxNjFlM2U1ZTUyYTQ3OGQ4ZmM2ZA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-16T10:52:14Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-16T10:52:14Z"}, "message": "re PR middle-end/54146 (Very slow compile with attribute((flatten)))\n\n\tPR middle-end/54146\n\t* tree-flow.h (compute_global_livein): Remove prototype.\n\t* tree-into-ssa.c (compute_global_livein): Remove function.\n\t* tree-ssa-loop-manip.c: Include gimple-pretty-print.h.\n\t(find_sibling_superloop): New function.\n\t(compute_live_loop_exits): New function.\n\t(add_exit_phis_edge): Rename to add_exit_phi.  Do not allow\n\tinserting a PHI in a block that is not a loop exit for VAR.\n\tAdd dumping if TDF_DETAILS.\n\t(add_exit_phis_var): Rewrite.\n\t(add_exit_phis): Update.\n\t(get_loops_exits): Rewrite to return an array of per-loop exits\n\trather than one bitmap with all loop exits.\n\t(find_uses_to_rename_bb): Ignore virtual PHI nodes.\n\t(rewrite_into_loop_closed_ssa): Update.\n\nFrom-SVN: r190442", "tree": {"sha": "e65720504a6ef8d7e205979cb6ddd502a52181c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e65720504a6ef8d7e205979cb6ddd502a52181c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01273677143592a20a0c161e3e5e52a478d8fc6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01273677143592a20a0c161e3e5e52a478d8fc6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01273677143592a20a0c161e3e5e52a478d8fc6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01273677143592a20a0c161e3e5e52a478d8fc6d/comments", "author": null, "committer": null, "parents": [{"sha": "ca9b1cd87255144e5b7a063e5571f0e698dd9702", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca9b1cd87255144e5b7a063e5571f0e698dd9702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca9b1cd87255144e5b7a063e5571f0e698dd9702"}], "stats": {"total": 312, "additions": 203, "deletions": 109}, "files": [{"sha": "ef89872e60047083f8ea591be8f4b91999e00fdf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01273677143592a20a0c161e3e5e52a478d8fc6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01273677143592a20a0c161e3e5e52a478d8fc6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01273677143592a20a0c161e3e5e52a478d8fc6d", "patch": "@@ -1,3 +1,21 @@\n+2012-08-16  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR middle-end/54146\n+\t* tree-flow.h (compute_global_livein): Remove prototype.\n+\t* tree-into-ssa.c (compute_global_livein): Remove function.\n+\t* tree-ssa-loop-manip.c: Include gimple-pretty-print.h.\n+\t(find_sibling_superloop): New function.\n+\t(compute_live_loop_exits): New function.\n+\t(add_exit_phis_edge): Rename to add_exit_phi.  Do not allow\n+\tinserting a PHI in a block that is not a loop exit for VAR.\n+\tAdd dumping if TDF_DETAILS.\n+\t(add_exit_phis_var): Rewrite.\n+\t(add_exit_phis): Update.\n+\t(get_loops_exits): Rewrite to return an array of per-loop exits\n+\trather than one bitmap with all loop exits.\n+\t(find_uses_to_rename_bb): Ignore virtual PHI nodes.\n+\t(rewrite_into_loop_closed_ssa): Update.\n+\n 2012-08-16  Nick Clifton  <nickc@redhat.com>\n \n \t* config/i386/i386elf.h (ASM_OUTPUT_ASCII): Cast _ascii_bytes"}, {"sha": "7ea58e56562ca662e67d813a378cfa0549f14f8d", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01273677143592a20a0c161e3e5e52a478d8fc6d/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01273677143592a20a0c161e3e5e52a478d8fc6d/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=01273677143592a20a0c161e3e5e52a478d8fc6d", "patch": "@@ -521,7 +521,6 @@ tree create_new_def_for (tree, gimple, def_operand_p);\n bool need_ssa_update_p (struct function *);\n bool name_registered_for_update_p (tree);\n void release_ssa_name_after_update_ssa (tree);\n-void compute_global_livein (bitmap, bitmap);\n void mark_virtual_operands_for_renaming (struct function *);\n tree get_current_def (tree);\n void set_current_def (tree, tree);"}, {"sha": "073a4881a6284e7f6b331bd7747e8a92163f1206", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01273677143592a20a0c161e3e5e52a478d8fc6d/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01273677143592a20a0c161e3e5e52a478d8fc6d/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=01273677143592a20a0c161e3e5e52a478d8fc6d", "patch": "@@ -404,63 +404,6 @@ set_current_def (tree var, tree def)\n   get_common_info (var)->current_def = def;\n }\n \n-\n-/* Compute global livein information given the set of blocks where\n-   an object is locally live at the start of the block (LIVEIN)\n-   and the set of blocks where the object is defined (DEF_BLOCKS).\n-\n-   Note: This routine augments the existing local livein information\n-   to include global livein (i.e., it modifies the underlying bitmap\n-   for LIVEIN).  */\n-\n-void\n-compute_global_livein (bitmap livein, bitmap def_blocks)\n-{\n-  unsigned i;\n-  bitmap_iterator bi;\n-  VEC (basic_block, heap) *worklist;\n-\n-  /* Normally the work list size is bounded by the number of basic\n-     blocks in the largest loop.  We don't know this number, but we\n-     can be fairly sure that it will be relatively small.  */\n-  worklist = VEC_alloc (basic_block, heap, MAX (8, n_basic_blocks / 128));\n-\n-  EXECUTE_IF_SET_IN_BITMAP (livein, 0, i, bi)\n-    VEC_safe_push (basic_block, heap, worklist, BASIC_BLOCK (i));\n-\n-  /* Iterate until the worklist is empty.  */\n-  while (! VEC_empty (basic_block, worklist))\n-    {\n-      edge e;\n-      edge_iterator ei;\n-\n-      /* Pull a block off the worklist.  */\n-      basic_block bb = VEC_pop (basic_block, worklist);\n-\n-      /* Make sure we have at least enough room in the work list\n-\t for all predecessors of this block.  */\n-      VEC_reserve (basic_block, heap, worklist, EDGE_COUNT (bb->preds));\n-\n-      /* For each predecessor block.  */\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\t{\n-\t  basic_block pred = e->src;\n-\t  int pred_index = pred->index;\n-\n-\t  /* None of this is necessary for the entry block.  */\n-\t  if (pred != ENTRY_BLOCK_PTR\n-\t      && ! bitmap_bit_p (def_blocks, pred_index)\n-\t      && bitmap_set_bit (livein, pred_index))\n-\t    {\n-\t      VEC_quick_push (basic_block, worklist, pred);\n-\t    }\n-\t}\n-    }\n-\n-  VEC_free (basic_block, heap, worklist);\n-}\n-\n-\n /* Cleans up the REWRITE_THIS_STMT and REGISTER_DEFS_IN_THIS_STMT flags for\n    all statements in basic block BB.  */\n "}, {"sha": "7017c9a3b4a4c994fade0c807d24f28d1c365bb6", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 185, "deletions": 51, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01273677143592a20a0c161e3e5e52a478d8fc6d/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01273677143592a20a0c161e3e5e52a478d8fc6d/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=01273677143592a20a0c161e3e5e52a478d8fc6d", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"tree-flow.h\"\n #include \"dumpfile.h\"\n+#include \"gimple-pretty-print.h\"\n #include \"cfgloop.h\"\n #include \"tree-pass.h\"\t/* ??? for TODO_update_ssa but this isn't a pass.  */\n #include \"tree-scalar-evolution.h\"\n@@ -129,70 +130,198 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n   add_phi_arg (stmt, va, loop_latch_edge (loop), UNKNOWN_LOCATION);\n }\n \n-/* Add exit phis for the USE on EXIT.  */\n+/* Return the outermost superloop LOOP of USE_LOOP that is a superloop of\n+   both DEF_LOOP and USE_LOOP.  */\n+\n+static inline struct loop *\n+find_sibling_superloop (struct loop *use_loop, struct loop *def_loop)\n+{\n+  unsigned ud = loop_depth (use_loop);\n+  unsigned dd = loop_depth (def_loop);\n+  gcc_assert (ud > 0 && dd > 0);\n+  if (ud > dd)\n+    use_loop = superloop_at_depth (use_loop, dd);\n+  if (ud < dd)\n+    def_loop = superloop_at_depth (def_loop, ud);\n+  while (loop_outer (use_loop) != loop_outer (def_loop))\n+    {\n+      use_loop = loop_outer (use_loop);\n+      def_loop = loop_outer (def_loop);\n+      gcc_assert (use_loop && def_loop);\n+    }\n+  return use_loop;\n+}\n+\n+/* DEF_BB is a basic block containing a DEF that needs rewriting into\n+   loop-closed SSA form.  USE_BLOCKS is the set of basic blocks containing\n+   uses of DEF that \"escape\" from the loop containing DEF_BB (i.e. blocks in\n+   USE_BLOCKS are dominated by DEF_BB but not in the loop father of DEF_B).\n+   ALL_EXITS[I] is the set of all basic blocks that exit loop I.\n+\n+   Compute the subset of LOOP_EXITS that exit the loop containing DEF_BB\n+   or one of its loop fathers, in which DEF is live.  This set is returned\n+   in the bitmap LIVE_EXITS.\n+\n+   Instead of computing the complete livein set of the def, we use the loop\n+   nesting tree as a form of poor man's structure analysis.  This greatly\n+   speeds up the analysis, which is important because this function may be\n+   called on all SSA names that need rewriting, one at a time.  */\n \n static void\n-add_exit_phis_edge (basic_block exit, tree use)\n+compute_live_loop_exits (bitmap live_exits, bitmap use_blocks,\n+\t\t\t bitmap *loop_exits, basic_block def_bb)\n {\n-  gimple phi, def_stmt = SSA_NAME_DEF_STMT (use);\n-  basic_block def_bb = gimple_bb (def_stmt);\n-  struct loop *def_loop;\n+  unsigned i;\n+  bitmap_iterator bi;\n+  VEC (basic_block, heap) *worklist;\n+  struct loop *def_loop = def_bb->loop_father;\n+  unsigned def_loop_depth = loop_depth (def_loop);\n+  bitmap def_loop_exits;\n+\n+  /* Normally the work list size is bounded by the number of basic\n+     blocks in the largest loop.  We don't know this number, but we\n+     can be fairly sure that it will be relatively small.  */\n+  worklist = VEC_alloc (basic_block, heap, MAX (8, n_basic_blocks / 128));\n+\n+  EXECUTE_IF_SET_IN_BITMAP (use_blocks, 0, i, bi)\n+    {\n+      basic_block use_bb = BASIC_BLOCK (i);\n+      struct loop *use_loop = use_bb->loop_father;\n+      gcc_checking_assert (def_loop != use_loop\n+\t\t\t   && ! flow_loop_nested_p (def_loop, use_loop));\n+      if (! flow_loop_nested_p (use_loop, def_loop))\n+\tuse_bb = find_sibling_superloop (use_loop, def_loop)->header;\n+      if (bitmap_set_bit (live_exits, use_bb->index))\n+\tVEC_safe_push (basic_block, heap, worklist, use_bb);\n+    }\n+\n+  /* Iterate until the worklist is empty.  */\n+  while (! VEC_empty (basic_block, worklist))\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      /* Pull a block off the worklist.  */\n+      basic_block bb = VEC_pop (basic_block, worklist);\n+\n+      /* Make sure we have at least enough room in the work list\n+\t for all predecessors of this block.  */\n+      VEC_reserve (basic_block, heap, worklist, EDGE_COUNT (bb->preds));\n+\n+      /* For each predecessor block.  */\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t{\n+\t  basic_block pred = e->src;\n+\t  struct loop *pred_loop = pred->loop_father;\n+\t  unsigned pred_loop_depth = loop_depth (pred_loop);\n+\t  bool pred_visited;\n+\n+\t  /* We should have met DEF_BB along the way.  */\n+\t  gcc_assert (pred != ENTRY_BLOCK_PTR);\n+\n+\t  if (pred_loop_depth >= def_loop_depth)\n+\t    {\n+\t      if (pred_loop_depth > def_loop_depth)\n+\t\tpred_loop = superloop_at_depth (pred_loop, def_loop_depth);\n+\t      /* If we've reached DEF_LOOP, our train ends here.  */\n+\t      if (pred_loop == def_loop)\n+\t\tcontinue;\n+\t    }\n+\t  else if (! flow_loop_nested_p (pred_loop, def_loop))\n+\t    pred = find_sibling_superloop (pred_loop, def_loop)->header;\n+\n+\t  /* Add PRED to the LIVEIN set.  PRED_VISITED is true if\n+\t     we had already added PRED to LIVEIN before.  */\n+\t  pred_visited = !bitmap_set_bit (live_exits, pred->index);\n+\n+\t  /* If we have visited PRED before, don't add it to the worklist.\n+\t     If BB dominates PRED, then we're probably looking at a loop.\n+\t     We're only interested in looking up in the dominance tree\n+\t     because DEF_BB dominates all the uses.  */\n+\t  if (pred_visited || dominated_by_p (CDI_DOMINATORS, pred, bb))\n+\t    continue;\n+\n+\t  VEC_quick_push (basic_block, worklist, pred);\n+\t}\n+    }\n+  VEC_free (basic_block, heap, worklist);\n+\n+  def_loop_exits = BITMAP_ALLOC (&loop_renamer_obstack);\n+  for (struct loop *loop = def_loop;\n+       loop != current_loops->tree_root;\n+       loop = loop_outer (loop))\n+    bitmap_ior_into (def_loop_exits, loop_exits[loop->num]);\n+  bitmap_and_into (live_exits, def_loop_exits);\n+  BITMAP_FREE (def_loop_exits);\n+}\n+\n+/* Add a loop-closing PHI for VAR in basic block EXIT.  */\n+\n+static void\n+add_exit_phi (basic_block exit, tree var)\n+{\n+  gimple phi;\n   edge e;\n   edge_iterator ei;\n \n-  /* Check that some of the edges entering the EXIT block exits a loop in\n-     that USE is defined.  */\n+#ifdef ENABLE_CHECKING\n+  /* Check that at least one of the edges entering the EXIT block exits\n+     the loop, or a superloop of that loop, that VAR is defined in.  */\n+  gimple def_stmt = SSA_NAME_DEF_STMT (var);\n+  basic_block def_bb = gimple_bb (def_stmt);\n   FOR_EACH_EDGE (e, ei, exit->preds)\n     {\n-      def_loop = find_common_loop (def_bb->loop_father, e->src->loop_father);\n-      if (!flow_bb_inside_loop_p (def_loop, e->dest))\n+      struct loop *aloop = find_common_loop (def_bb->loop_father,\n+\t\t\t\t\t     e->src->loop_father);\n+      if (!flow_bb_inside_loop_p (aloop, e->dest))\n \tbreak;\n     }\n \n-  if (!e)\n-    return;\n+  gcc_checking_assert (e);\n+#endif\n \n   phi = create_phi_node (NULL_TREE, exit);\n-  create_new_def_for (use, phi, gimple_phi_result_ptr (phi));\n+  create_new_def_for (var, phi, gimple_phi_result_ptr (phi));\n   FOR_EACH_EDGE (e, ei, exit->preds)\n-    add_phi_arg (phi, use, e, UNKNOWN_LOCATION);\n+    add_phi_arg (phi, var, e, UNKNOWN_LOCATION);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \";; Created LCSSA PHI: \");\n+      print_gimple_stmt (dump_file, phi, 0, dump_flags);\n+    }\n }\n \n /* Add exit phis for VAR that is used in LIVEIN.\n-   Exits of the loops are stored in EXITS.  */\n+   Exits of the loops are stored in LOOP_EXITS.  */\n \n static void\n-add_exit_phis_var (tree var, bitmap livein, bitmap exits)\n+add_exit_phis_var (tree var, bitmap use_blocks, bitmap *loop_exits)\n {\n-  bitmap def;\n   unsigned index;\n-  basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (var));\n   bitmap_iterator bi;\n+  basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (var));\n+  bitmap live_exits = BITMAP_ALLOC (&loop_renamer_obstack);\n \n   gcc_checking_assert (! virtual_operand_p (var));\n-  bitmap_clear_bit (livein, def_bb->index);\n+  gcc_assert (! bitmap_bit_p (use_blocks, def_bb->index));\n \n-  def = BITMAP_ALLOC (&loop_renamer_obstack);\n-  bitmap_set_bit (def, def_bb->index);\n-  compute_global_livein (livein, def);\n-  BITMAP_FREE (def);\n+  compute_live_loop_exits (live_exits, use_blocks, loop_exits, def_bb);\n \n-  EXECUTE_IF_AND_IN_BITMAP (exits, livein, 0, index, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (live_exits, 0, index, bi)\n     {\n-      add_exit_phis_edge (BASIC_BLOCK (index), var);\n+      add_exit_phi (BASIC_BLOCK (index), var);\n     }\n \n-  /* Free the livein bitmap.  We'll not be needing it anymore, and\n-     it may have grown quite large.  No reason to hold on to it.  */\n-  bitmap_clear (livein);\n+  BITMAP_FREE (live_exits);\n }\n \n /* Add exit phis for the names marked in NAMES_TO_RENAME.\n    Exits of the loops are stored in EXITS.  Sets of blocks where the ssa\n    names are used are stored in USE_BLOCKS.  */\n \n static void\n-add_exit_phis (bitmap names_to_rename, bitmap *use_blocks, bitmap loop_exits)\n+add_exit_phis (bitmap names_to_rename, bitmap *use_blocks, bitmap *loop_exits)\n {\n   unsigned i;\n   bitmap_iterator bi;\n@@ -203,28 +332,24 @@ add_exit_phis (bitmap names_to_rename, bitmap *use_blocks, bitmap loop_exits)\n     }\n }\n \n-/* Returns a bitmap of all loop exit edge targets.  */\n+/* Fill the array of bitmaps LOOP_EXITS with all loop exit edge targets.  */\n \n-static bitmap\n-get_loops_exits (void)\n+static void\n+get_loops_exits (bitmap *loop_exits)\n {\n-  bitmap exits = BITMAP_ALLOC (&loop_renamer_obstack);\n-  basic_block bb;\n+  loop_iterator li;\n+  struct loop *loop;\n+  unsigned j;\n   edge e;\n-  edge_iterator ei;\n \n-  FOR_EACH_BB (bb)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (e->src != ENTRY_BLOCK_PTR\n-\t    && !flow_bb_inside_loop_p (e->src->loop_father, bb))\n-\t  {\n-\t    bitmap_set_bit (exits, bb->index);\n-\t    break;\n-\t  }\n+      VEC(edge, heap) *exit_edges = get_loop_exit_edges (loop);\n+      loop_exits[loop->num] = BITMAP_ALLOC (&loop_renamer_obstack);\n+      FOR_EACH_VEC_ELT (edge, exit_edges, j, e)\n+        bitmap_set_bit (loop_exits[loop->num], e->dest->index);\n+      VEC_free (edge, heap, exit_edges);\n     }\n-\n-  return exits;\n }\n \n /* For USE in BB, if it is used outside of the loop it is defined in,\n@@ -301,8 +426,12 @@ find_uses_to_rename_bb (basic_block bb, bitmap *use_blocks, bitmap need_phis)\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n     for (bsi = gsi_start_phis (e->dest); !gsi_end_p (bsi); gsi_next (&bsi))\n-      find_uses_to_rename_use (bb, PHI_ARG_DEF_FROM_EDGE (gsi_stmt (bsi), e),\n-\t\t\t       use_blocks, need_phis);\n+      {\n+        gimple phi = gsi_stmt (bsi);\n+\tif (! virtual_operand_p (gimple_phi_result (phi)))\n+\t  find_uses_to_rename_use (bb, PHI_ARG_DEF_FROM_EDGE (phi, e),\n+\t\t\t\t   use_blocks, need_phis);\n+      }\n \n   for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n     find_uses_to_rename_stmt (gsi_stmt (bsi), use_blocks, need_phis);\n@@ -372,22 +501,26 @@ find_uses_to_rename (bitmap changed_bbs, bitmap *use_blocks, bitmap need_phis)\n void\n rewrite_into_loop_closed_ssa (bitmap changed_bbs, unsigned update_flag)\n {\n-  bitmap loop_exits;\n+  bitmap *loop_exits;\n   bitmap *use_blocks;\n   bitmap names_to_rename;\n \n   loops_state_set (LOOP_CLOSED_SSA);\n   if (number_of_loops () <= 1)\n     return;\n \n+  /* If the pass has caused the SSA form to be out-of-date, update it\n+     now.  */\n+  update_ssa (update_flag);\n+\n   bitmap_obstack_initialize (&loop_renamer_obstack);\n \n-  loop_exits = get_loops_exits ();\n   names_to_rename = BITMAP_ALLOC (&loop_renamer_obstack);\n \n-  /* If the pass has caused the SSA form to be out-of-date, update it\n-     now.  */\n-  update_ssa (update_flag);\n+  /* An array of bitmaps where LOOP_EXITS[I] is the set of basic blocks\n+     that are the destination of an edge exiting loop number I.  */\n+  loop_exits = XNEWVEC (bitmap, number_of_loops ());\n+  get_loops_exits (loop_exits);\n \n   /* Uses of names to rename.  We don't have to initialize this array,\n      because we know that we will only have entries for the SSA names\n@@ -403,6 +536,7 @@ rewrite_into_loop_closed_ssa (bitmap changed_bbs, unsigned update_flag)\n \n   bitmap_obstack_release (&loop_renamer_obstack);\n   free (use_blocks);\n+  free (loop_exits);\n \n   /* Fix up all the names found to be used outside their original\n      loops.  */"}]}