{"sha": "a2b22788aeaf14e9d9e9b83e95e8a47b843dfa22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJiMjI3ODhhZWFmMTRlOWQ5ZTliODNlOTVlOGE0N2I4NDNkZmEyMg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-24T12:13:21Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-24T12:13:21Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r139", "tree": {"sha": "3659c03facb9023778f7929d829d23e21b9b41fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3659c03facb9023778f7929d829d23e21b9b41fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2b22788aeaf14e9d9e9b83e95e8a47b843dfa22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b22788aeaf14e9d9e9b83e95e8a47b843dfa22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2b22788aeaf14e9d9e9b83e95e8a47b843dfa22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b22788aeaf14e9d9e9b83e95e8a47b843dfa22/comments", "author": null, "committer": null, "parents": [{"sha": "52c00c9c97d7c84bfa8fcd9fcab7cf555808cb62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52c00c9c97d7c84bfa8fcd9fcab7cf555808cb62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52c00c9c97d7c84bfa8fcd9fcab7cf555808cb62"}], "stats": {"total": 558, "additions": 286, "deletions": 272}, "files": [{"sha": "5d4e3f112b07fbe50511112aff9344d513aae0c6", "filename": "gcc/protoize.c", "status": "modified", "additions": 286, "deletions": 272, "changes": 558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b22788aeaf14e9d9e9b83e95e8a47b843dfa22/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b22788aeaf14e9d9e9b83e95e8a47b843dfa22/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=a2b22788aeaf14e9d9e9b83e95e8a47b843dfa22", "patch": "@@ -28,20 +28,33 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define __STDC__ 1\n #endif /* defined(__cplusplus) && !defined(__STDC__) */\n \n-#if defined (__cplusplus)\n-extern \"C\" {\t\t\t/* Start of extern \"C\" section.  */\n-#endif /* defined(__cplusplus) */\n+#if defined(__GNUC__) || defined (__GNUG__)\n+#define VOLATILE volatile\n+#else\n+#define VOLATILE\n+#endif\n \n /* It is incorrect to include config.h here, because this file is being\n    compiled for the target, and hence definitions concerning only the host\n-   do not apply.  */\n+   do not apply.  Instead we include tconfig.h, which is the xm file\n+   *for the target*, which also includes the tm.h file *for the target*.\n+   This way, we get definitions of POSIX, USG and VMS for the target.  */\n \n-#include \"tm.h\"\n+#include \"tconfig.h\"\n+\n+/* The documentation says to use TARGET_POSIX, so check for it as well\n+   as POSIX.  */\n+#if defined(TARGET_POSIX) && !defined(POSIX)\n+#define POSIX\n+#endif\n+\n+/* If the user asked for POSIX via _POSIX_SOURCE, turn on POSIX code.  */\n+#if defined(_POSIX_SOURCE) && !defined(POSIX)\n+#define POSIX\n+#endif\n \n /* On a POSIX system, request definition of all the POSIX facilities.  */\n-/* We use TARGET_POSIX because protoize is compiled for the target system,\n-   and TARGET_POSIX is the symbol that describes it in tm.h.  */\n-#ifdef TARGET_POSIX\n+#if defined(POSIX) && !defined(_POSIX_SOURCE)\n #define _POSIX_SOURCE\n #endif\n \n@@ -56,7 +69,6 @@ extern \"C\" {\t\t\t/* Start of extern \"C\" section.  */\n #include \"gvarargs.h\"\n #include \"getopt.h\"\n \n-#include <limits.h>\n #ifndef PATH_MAX\t/* <limits.h> defines this on most POSIX systems.  */\n #include <sys/param.h>\n #define PATH_MAX MAXPATHLEN\n@@ -80,9 +92,10 @@ extern \"C\" {\t\t\t/* Start of extern \"C\" section.  */\n #endif\n \n extern int errno;\n-extern char * sys_errlist[];\n+extern char *sys_errlist[];\n+extern char *version_string;\n \n-#if defined(TARGET_POSIX)\n+#if defined(POSIX)\n \n #include <stdlib.h>\n #include <unistd.h>\n@@ -109,7 +122,7 @@ extern char * sys_errlist[];\n \n #endif /* (_POSIX_VERSION < 199009) */\n \n-#else /* !defined(TARGET_POSIX) */\n+#else /* !defined(POSIX) */\n \n #define R_OK    4       /* Test for Read permission */\n #define W_OK    2       /* Test for Write permission */\n@@ -130,14 +143,19 @@ extern char *getwd (char *);\n extern char *getcwd (char *, size_t);\n #endif /* (defined (USG) || defined (VMS)) */\n \n-/* Declaring stat, kill or __flsbuf with a prototype\n-   causes conflicts with system headers on some systems.\n-   Declaring abort causes trouble if it is a macro.  */\n+/* Declaring stat or __flsbuf with a prototype\n+   causes conflicts with system headers on some systems.  */\n \n+#ifndef abort\n+extern VOLATILE void abort (void);\n+#endif\n+extern int kill(int, int);\n extern int creat (const char *, int);\n extern int open (const char *, int, ...);\n+#if 0 /* These conflict with stdio.h on some systems.  */\n extern int fprintf (FILE *, const char *, ...);\n extern int printf (const char *, ...);\n+#endif /* 0 */\n extern void exit (int);\n extern void *malloc (size_t);\n extern void *realloc (void *, size_t);\n@@ -160,21 +178,23 @@ extern void longjmp (jmp_buf, int);\n extern char *   strcat(char *, const char *);\n extern int      strcmp(const char *, const char *);\n extern char *   strcpy(char *, const char *);\n+#if 0 /* size_t from sys/types.h may fail to match GCC.\n+\t If so, we would get a warning from this.\n+\t So do without the prototype.  */\n extern size_t   strlen(const char *);\n+#endif\n extern int      strncmp(const char *, const char *, size_t);\n extern char *   strncpy(char *, const char *, size_t);\n extern char *   strrchr(const char *, int);\n \n #if !(defined (USG) || defined (VMS))\n extern int vfork (void);\n #define fork vfork\n+#else\n+extern int fork (void);\n #endif /* !(defined (USG) || defined (VMS)) */\n \n-#endif /* !defined(TARGET_POSIX) */\n-\n-#if defined (__cplusplus)\n-}\t\t\t\t/* End of extern \"C\" section.  */\n-#endif /* defined(__cplusplus) */\n+#endif /* !defined(POSIX) */\n \n /* Look for these where the `const' qualifier is intentionally cast aside.  */\n \n@@ -205,15 +225,11 @@ typedef const void * const_pointer_type;\n #define STD_PROTO_DIR \"/usr/local/lib\"\n #endif /* !defined(STD_PROTO_DIR) */\n \n-/* String to identify this version.  */\n-\n-static const char * const version_string = \"Version 1.07\";\n-\n /* Suffix of aux_info files.  */\n \n static const char * const aux_info_suffix = \".X\";\n \n-/* String to attach to pathnames for saved versions of original files.  */\n+/* String to attach to filenames for saved versions of original files.  */\n \n static const char * const save_suffix = \".save\";\n \n@@ -229,10 +245,10 @@ static const char * const syscalls_filename = \"SYSCALLS.c\";\n \n static const char * const default_syscalls_dir = STD_PROTO_DIR;\n \n-/* Variable to hold the complete absolutized pathname of the SYSCALLS.c.X\n+/* Variable to hold the complete absolutized filename of the SYSCALLS.c.X\n    file.  */\n \n-static char * syscalls_pathname;\n+static char * syscalls_absolute_filename;\n \n #endif /* !defined(UNPROTOIZE) */\n \n@@ -333,13 +349,15 @@ struct string_list *exclude_list;\n static const char * const other_var_style = \"stdarg\";\n #else /* !defined(UNPROTOIZE) */\n static const char * const other_var_style = \"varargs\";\n-static const char * const varargs_style_indicator = STRINGIFY(va_alist);\n+/* Note that this is a string containing the expansion of va_alist.\n+   But in `main' we discard all but the first token.  */\n+static const char *varargs_style_indicator = STRINGIFY(va_alist);\n #endif /* !defined(UNPROTOIZE) */\n \n /* The following two types are used to create hash tables.  In this program,\n    there are two hash tables which are used to store and quickly lookup two\n    different classes of strings.  The first type of strings stored in the\n-   first hash table are absolute pathnames of files which protoize needs to\n+   first hash table are absolute filenames of files which protoize needs to\n    know about.  The second type of strings (stored in the second hash table)\n    are function names.  It is this second class of strings which really\n    inspired the use of the hash tables, because there may be a lot of them.  */\n@@ -353,10 +371,10 @@ typedef struct file_info_struct file_info;\n typedef struct f_list_chain_item_struct f_list_chain_item;\n \n /* In the struct below, note that the \"_info\" field has two different uses\n-   depending on the type of hash table we are in (i.e. either the pathnames\n-   hash table or the function names hash table).  In the pathnames hash table\n+   depending on the type of hash table we are in (i.e. either the filenames\n+   hash table or the function names hash table).  In the filenames hash table\n    the info fields of the entries point to the file_info struct which is\n-   associated with each pathname (1 per pathname).  In the function names\n+   associated with each filename (1 per filename).  In the function names\n    hash table, the info field points to the head of a singly linked list of\n    def_dec_info entries which are all defs or decs of the function whose\n    name is pointed to by the \"symbol\" field.  Keeping all of the defs/decs\n@@ -380,7 +398,7 @@ struct hash_table_entry_struct {\n typedef hash_table_entry hash_table[HASH_TABLE_SIZE];\n \n /* The following struct holds all of the important information about any\n-   single pathname (e.g. file) which we need to know about.  */\n+   single filename (e.g. file) which we need to know about.  */\n \n struct file_info_struct {\n   const hash_table_entry *\thash_entry; /* -> to associated hash entry */\n@@ -439,7 +457,7 @@ struct def_dec_info_struct {\n #endif /* !defined(UNPROTOIZE) */\n };\n \n-/* Pointer to the tail component of the pathname by which this program was\n+/* Pointer to the tail component of the filename by which this program was\n    invoked.  Used everywhere in error and warning messages.  */\n \n static const char *pname;\n@@ -479,12 +497,12 @@ static int filename_index = 0;\n \n /* Count of command line arguments which were \"filename\" arguments.  */\n \n-static int base_source_files = 0;\n+static int n_base_source_files = 0;\n \n /* Points to a malloc'ed list of pointers to all of the filenames of base\n    source files which were specified on the command line.  */\n \n-static const char **base_source_paths;\n+static const char **base_source_filenames;\n \n /* Line number of the line within the current aux_info file that we\n    are currently processing.  Used for error messages in case the prototypes\n@@ -494,13 +512,13 @@ static int current_aux_info_lineno;\n \n /* Pointer to the name of the source file currently being converted.  */\n \n-static const char *convert_path;\n+static const char *convert_filename;\n \n /* Pointer to relative root string (taken from aux_info file) which indicates\n    where directory the user was in when he did the compilation step that\n    produced the containing aux_info file. */\n \n-static const char *invocation_path;\n+static const char *invocation_filename;\n \n /* Pointer to the base of the input buffer that holds the original text for the\n    source file currently being converted.  */\n@@ -555,9 +573,9 @@ static const char *last_known_line_start;\n \n static int last_known_line_number;\n \n-/* The pathnames hash table.  */\n+/* The filenames hash table.  */\n \n-static hash_table pathname_primary;\n+static hash_table filename_primary;\n \n /* The function names hash table.  */\n \n@@ -568,7 +586,7 @@ static hash_table function_name_primary;\n \n static jmp_buf source_confusion_recovery;\n \n-/* A pointer to the current directory pathname (used by abspath).  */\n+/* A pointer to the current directory filename (used by abspath).  */\n \n static char *cwd_buffer;\n \n@@ -584,7 +602,7 @@ static char * saved_repl_write_ptr;\n \n /* Forward declaration.  */\n \n-static const char *shortpath (const char *cwd, const char *pathname);\n+static const char *shortpath (const char *cwd, const char *filename);\n \f\n /* Allocate some space, but check that the allocation was successful.  */\n \n@@ -596,7 +614,7 @@ xmalloc (size_t byte_count)\n   if ((rv = malloc (byte_count)) == NULL)\n     {\n       fprintf (stderr, \"\\n%s: fatal error: can't allocate %u more bytes of memory\\n\",\n-        pname, byte_count);\n+\t       pname, byte_count);\n       exit (1);\n       return 0;\t\t/* avoid warnings */\n     }\n@@ -614,7 +632,7 @@ xrealloc (pointer_type old_space, size_t byte_count)\n   if ((rv = realloc (old_space, byte_count)) == NULL)\n     {\n       fprintf (stderr, \"\\n%s: fatal error: can't allocate %u more bytes of memory\\n\",\n-        pname, byte_count);\n+\t       pname, byte_count);\n       exit (1);\n       return 0;\t\t/* avoid warnings */\n     }\n@@ -636,7 +654,7 @@ xfree (const_pointer_type p)\n /* Make a copy of a string INPUT with size SIZE.  */\n \n static char *\n-savestring (char *input, int size)\n+savestring (const char *input, int size)\n {\n   char *output = (char *) xmalloc (size + 1);\n   strcpy (output, input);\n@@ -683,7 +701,7 @@ substr (const char *s1, const char *const s2)\n     {\n       const char *p1;\n       const char *p2;\n-      char c;\n+      int c;\n \n       for (p1 = s1, p2 = s2; c = *p2; p1++, p2++)\n         if (*p1 != c)\n@@ -729,15 +747,16 @@ static void\n usage (void)\n {\n #ifdef UNPROTOIZE\n-  fprintf (stderr, \"%s: usage '%s [ -VqfnkN ] [ -i <istring> ] [ pathname ... ]'\\n\",\n+  fprintf (stderr, \"%s: usage '%s [ -VqfnkN ] [ -i <istring> ] [ filename ... ]'\\n\",\n+\t   pname, pname);\n #else /* !defined(UNPROTOIZE) */\n-  fprintf (stderr, \"%s: usage '%s [ -VqfnkNlgC ] [ -B <diname> ] [ pathname ... ]'\\n\",\n+  fprintf (stderr, \"%s: usage '%s [ -VqfnkNlgC ] [ -B <diname> ] [ filename ... ]'\\n\",\n+\t   pname, pname);\n #endif /* !defined(UNPROTOIZE) */\n-    pname, pname);\n   exit (1);\n }\n \n-/* Return true if the given pathname (assumed to be an absolute pathname)\n+/* Return true if the given filename (assumed to be an absolute filename)\n    designates a file residing anywhere beneath any one of the \"system\"\n    include directories.  */\n \n@@ -747,7 +766,7 @@ in_system_include_dir (const char *path)\n   struct default_include *p;\n \n   if (path[0] != '/')\n-    abort ();\t\t/* Must be an absolutized pathname.  */\n+    abort ();\t\t/* Must be an absolutized filename.  */\n \n   for (p = include_defaults; p->fname; p++)\n     if (!strncmp (path, p->fname, strlen (p->fname))\n@@ -757,7 +776,7 @@ in_system_include_dir (const char *path)\n }\n \f\n #if 0\n-/* Return true if the given pathname designates a file that the user has\n+/* Return true if the given filename designates a file that the user has\n    read access to and for which the user has write access to the containing\n    directory.  */\n \n@@ -777,7 +796,7 @@ file_could_be_converted (const char *path)\n     if (dir_last_slash)\n       *dir_last_slash = '\\0';\n     else\n-      abort ();  /* Should have been an absolutized pathname.  */\n+      abort ();  /* Should have been an absolutized filename.  */\n   }\n \n   if (access (path, W_OK))\n@@ -786,7 +805,7 @@ file_could_be_converted (const char *path)\n   return 1;\n }\n \n-/* Return true if the given pathname designates a file that we are allowed\n+/* Return true if the given filename designates a file that we are allowed\n    to modify.  Files which we should not attempt to modify are (a) \"system\"\n    include files, and (b) files which the user doesn't have write access to,\n    and (c) files which reside in directories which the user doesn't have\n@@ -811,30 +830,30 @@ file_normally_convertable (const char *path)\n     if (dir_last_slash)\n       *dir_last_slash = '\\0';\n     else\n-      abort ();  /* Should have been an absolutized pathname.  */\n+      abort ();  /* Should have been an absolutized filename.  */\n   }\n \n   if (access (path, R_OK))\n     {\n       if (!quiet_flag)\n         fprintf (stderr, \"%s: warning: no read access for file `%s'\\n\",\n-          pname, shortpath (NULL, path));\n+\t\t pname, shortpath (NULL, path));\n       return 0;\n     }\n \n   if (access (path, W_OK))\n     {\n       if (!quiet_flag)\n         fprintf (stderr, \"%s: warning: no write access for file `%s'\\n\",\n-          pname, shortpath (NULL, path));\n+\t\t pname, shortpath (NULL, path));\n       return 0;\n     }\n \n   if (access (dir_name, W_OK))\n     {\n       if (!quiet_flag)\n         fprintf (stderr, \"%s: warning: no write access for dir containing `%s'\\n\",\n-          pname, shortpath (NULL, path));\n+\t\t pname, shortpath (NULL, path));\n       return 0;\n     }\n \n@@ -983,7 +1002,7 @@ add_symbol (hash_table_entry *p, const char *s)\n   return p;\n }\n \n-/* Look for a particular function name or pathname in the particular\n+/* Look for a particular function name or filename in the particular\n    hash table indicated by \"hash_tab_p\".  If the name is not in the\n    given hash table, add it.  Either way, return a pointer to the\n    hash table entry for the given name.  */\n@@ -1117,48 +1136,48 @@ continue_outer: ;\n   return (got_unexpanded ? dupstr (line_buf) : 0);\n }\n \f\n-/* Return the absolutized pathname for the given relative\n-   pathname.  Note that if that pathname is already absolute, it may\n+/* Return the absolutized filename for the given relative\n+   filename.  Note that if that filename is already absolute, it may\n    still be returned in a modified form because this routine also\n    eliminates redundant slashes and single dots and eliminates double\n-   dots to get a shortest possible pathname from the given input\n-   pathname.  The absolutization of relative pathnames is made by\n-   assuming that the given pathname is to be taken as relative to\n+   dots to get a shortest possible filename from the given input\n+   filename.  The absolutization of relative filenames is made by\n+   assuming that the given filename is to be taken as relative to\n    the first argument (cwd) or to the current directory if cwd is\n    NULL.  */\n \n static char *\n-abspath (const char *cwd, const char *rel_pathname)\n+abspath (const char *cwd, const char *rel_filename)\n {\n   /* Setup the current working directory as needed.  */\n   const char *cwd2 = (cwd) ? cwd : cwd_buffer;\n   char *const abs_buffer\n-    = (char *) alloca (strlen (cwd2) + strlen (rel_pathname) + 1);\n+    = (char *) alloca (strlen (cwd2) + strlen (rel_filename) + 1);\n   char *endp = abs_buffer;\n   char *outp, *inp;\n \n-  /* Copy the  pathname (possibly preceeded by the current working\n+  /* Copy the  filename (possibly preceeded by the current working\n      directory name) into the absolutization buffer.  */\n \n   {\n     const char *src_p;\n \n-    if (rel_pathname[0] != '/')\n+    if (rel_filename[0] != '/')\n       {\n         src_p = cwd2;\n         while (*endp++ = *src_p++)\n           continue;\n         *(endp-1) = '/';        \t\t/* overwrite null */\n       }\n-    src_p = rel_pathname;\n+    src_p = rel_filename;\n     while (*endp++ = *src_p++)\n       continue;\n     if (endp[-1] == '/')\n       *endp = '\\0';\n   }\n \n   /* Now make a copy of abs_buffer into abs_buffer, shortening the\n-     pathname (by taking out slashes and dots) as we go.  */\n+     filename (by taking out slashes and dots) as we go.  */\n \n   outp = inp = abs_buffer;\n   *outp++ = *inp++;        \t/* copy first slash */\n@@ -1192,8 +1211,8 @@ abspath (const char *cwd, const char *rel_pathname)\n                      point above the absolute root of the logical file\n                      system.  */\n \n-              \t  fprintf (stderr, \"%s: fatal error: invalid pathname: %s\\n\",\n-                    pname, rel_pathname);\n+              \t  fprintf (stderr, \"%s: invalid file name: %s\\n\",\n+\t\t\t   pname, rel_filename);\n               \t  exit (1);\n               \t}\n                     *++outp = '\\0';\n@@ -1216,30 +1235,30 @@ abspath (const char *cwd, const char *rel_pathname)\n   return dupstr (abs_buffer);\n }\n \f\n-/* Given a pathname (and possibly a directory name from which the pathname\n+/* Given a filename (and possibly a directory name from which the filename\n    is relative) return a string which is the shortest possible\n-   equivalent for the corresponding full (absolutized) pathname.  The\n+   equivalent for the corresponding full (absolutized) filename.  The\n    shortest possible equivalent may be constructed by converting the\n-   absolutized pathname to be a relative pathname (i.e. relative to\n-   the actual current working directory).  However if a relative pathname\n-   is longer, then the full absolute pathname is returned.\n+   absolutized filename to be a relative filename (i.e. relative to\n+   the actual current working directory).  However if a relative filename\n+   is longer, then the full absolute filename is returned.\n \n    KNOWN BUG:\n \n-   Note that \"simple-minded\" conversion of any given type of pathname (either\n-   relative or absolute) may not result in a valid equivalent pathname if any\n-   subpart of the original pathname is actually a symbolic link.  */\n+   Note that \"simple-minded\" conversion of any given type of filename (either\n+   relative or absolute) may not result in a valid equivalent filename if any\n+   subpart of the original filename is actually a symbolic link.  */\n \n static const char *\n-shortpath (const char *cwd, const char *pathname)\n+shortpath (const char *cwd, const char *filename)\n {\n   char *rel_buffer;\n   char *rel_buf_p;\n   char *cwd_p = cwd_buffer;\n   char *path_p;\n   int unmatched_slash_count = 0;\n \n-  path_p = abspath (cwd, pathname);\n+  path_p = abspath (cwd, filename);\n   rel_buf_p = rel_buffer = (char *) xmalloc (strlen (path_p) + 1);\n \n   while (*cwd_p && (*cwd_p == *path_p))\n@@ -1283,25 +1302,27 @@ shortpath (const char *cwd, const char *pathname)\n       --rel_buf_p;\n       if (*(rel_buf_p-1) == '/')\n         *--rel_buf_p = '\\0';\n-      if (strlen (rel_buffer) > strlen (pathname))\n-\tstrcpy (rel_buffer, pathname);\n+      if (strlen (rel_buffer) > strlen (filename))\n+\tstrcpy (rel_buffer, filename);\n       return rel_buffer;\n     }\n   /* NOTREACHED */\n   return 0;\t/* Prevent warnings for old versions of GCC.  */\n }\n \f\n-/* Lookup the given pathname in the hash table for pathnames.  If it is a\n+/* Lookup the given filename in the hash table for filenames.  If it is a\n    new one, then the hash table info pointer will be null.  In this case,\n-   we create a new file_info record to go with the pathname, and we initialize\n+   we create a new file_info record to go with the filename, and we initialize\n    that record with some reasonable values.  */\n \n static file_info *\n-find_file (const char *pathname, int do_not_stat)\n+find_file (char *filename, int do_not_stat)\n+/* FILENAME was const, but that causes a warning on AIX when calling stat.\n+   That is probably a bug in AIX, but might as well avoid the warning.  */\n {\n   hash_table_entry *hash_entry_p;\n \n-  hash_entry_p = lookup (pathname_primary, pathname);\n+  hash_entry_p = lookup (filename_primary, filename);\n   if (hash_entry_p->fip)\n     return hash_entry_p->fip;\n   else\n@@ -1316,10 +1337,10 @@ find_file (const char *pathname, int do_not_stat)\n         stat_buf.st_mtime = (time_t) 0;\n       else\n         {\n-          if (stat (pathname, &stat_buf) == -1)\n+          if (stat (filename, &stat_buf) == -1)\n             {\n               fprintf (stderr, \"%s: error: can't get status of `%s': %s\\n\",\n-                pname, shortpath (NULL, pathname), sys_errlist[errno]);\n+\t\t       pname, shortpath (NULL, filename), sys_errlist[errno]);\n               stat_buf.st_mtime = (time_t) -1;\n             }\n         }\n@@ -1339,7 +1360,7 @@ static void\n aux_info_corrupted (void)\n {\n   fprintf (stderr, \"\\n%s: fatal error: aux info file corrupted at line %d\\n\",\n-    pname, current_aux_info_lineno);\n+\t   pname, current_aux_info_lineno);\n   exit (1);\n }\n \n@@ -1409,7 +1430,7 @@ referenced_file_is_newer (const char *l, time_t aux_info_mtime)\n      may cause a new file_info record to be created if this is the first time\n      that we have ever known about this particular file.  */\n \n-  fi_p = find_file (abspath (invocation_path, filename), 0);\n+  fi_p = find_file (abspath (invocation_filename, filename), 0);\n \n   return (fi_p->mtime > aux_info_mtime);\n }\n@@ -1464,16 +1485,16 @@ save_def_or_dec (const char *l, int is_syscalls)\n        may cause a new file_info record to be created if this is the first time\n        that we have ever known about this particular file.\n   \n-       Note that we started out by forcing all of the base source file pathnames\n+       Note that we started out by forcing all of the base source file names\n        (i.e. the names of the aux_info files with the .X stripped off) into the\n-       pathnames hash table, and we simultaneously setup file_info records for\n-       all of these base file pathnames (even if they may be useless later).\n-       The file_info records for all of these \"base\" file pathnames (properly)\n+       filenames hash table, and we simultaneously setup file_info records for\n+       all of these base file names (even if they may be useless later).\n+       The file_info records for all of these \"base\" file names (properly)\n        act as file_info records for the \"original\" (i.e. un-included) files\n        which were submitted to gcc for compilation (when the -fgen-aux-info\n        option was used).  */\n   \n-    def_dec_p->file = find_file (abspath (invocation_path, filename), is_syscalls);\n+    def_dec_p->file = find_file (abspath (invocation_filename, filename), is_syscalls);\n   }\n \n   {\n@@ -1868,25 +1889,25 @@ munge_compile_params (const char *params_list)\n    file to go with a specific base source file.  */\n \n static int\n-gen_aux_info_file (const char *base_pathname)\n+gen_aux_info_file (const char *base_filename)\n {\n   int child_pid;\n \n   if (!filename_index)\n     munge_compile_params (\"\");\n \n-  compile_params[filename_index] = shortpath (NULL, base_pathname);\n+  compile_params[filename_index] = shortpath (NULL, base_filename);\n \n   if (!quiet_flag)\n     fprintf (stderr, \"%s: compiling `%s'\\n\",\n-      pname, compile_params[filename_index]);\n+\t     pname, compile_params[filename_index]);\n \n   if (child_pid = fork ())\n     {\n       if (child_pid == -1)\n         {\n           fprintf (stderr, \"%s: error: could not fork process: %s\\n\",\n-            pname, sys_errlist[errno]);\n+\t\t   pname, sys_errlist[errno]);\n           return 0;\n         }\n \n@@ -1914,7 +1935,7 @@ gen_aux_info_file (const char *base_pathname)\n         if (wait (&wait_status) == -1)\n           {\n             fprintf (stderr, \"%s: error: wait for process failed: %s\\n\",\n-              pname, sys_errlist[errno]);\n+\t\t     pname, sys_errlist[errno]);\n             return 0;\n           }\n         if (!WIFEXITED (wait_status))\n@@ -1930,7 +1951,7 @@ gen_aux_info_file (const char *base_pathname)\n       if (execvp (compile_params[0], (char *const *) compile_params))\n         {\n           fprintf (stderr, \"%s: error: execvp returned: %s\\n\",\n-            pname, sys_errlist[errno]);\n+\t\t   pname, sys_errlist[errno]);\n           exit (errno);\n         }\n       return 1;\t\t/* Never executed.  */\n@@ -1941,21 +1962,21 @@ gen_aux_info_file (const char *base_pathname)\n    Save all of the important stuff for later.  */\n \n static void\n-process_aux_info_file (const char *base_source_pathname, int keep_it, int is_syscalls)\n+process_aux_info_file (const char *base_source_filename, int keep_it, int is_syscalls)\n {\n-  char *const aux_info_pathname\n-    = (char *) alloca (strlen (base_source_pathname)\n+  char *const aux_info_filename\n+    = (char *) alloca (strlen (base_source_filename)\n \t\t       + strlen (aux_info_suffix) + 1);\n   char *aux_info_base;\n   char *aux_info_limit;\n   const char *aux_info_second_line;\n   time_t aux_info_mtime;\n   size_t aux_info_size;\n \n-  /* Construct the aux_info pathname from the base source pathname.  */\n+  /* Construct the aux_info filename from the base source filename.  */\n \n-  strcpy (aux_info_pathname, base_source_pathname);\n-  strcat (aux_info_pathname, aux_info_suffix);\n+  strcpy (aux_info_filename, base_source_filename);\n+  strcat (aux_info_filename, aux_info_suffix);\n \n   /* Check that the aux_info file exists and is readable.  If it does not\n      exist, try to create it (once only).  */\n@@ -1966,25 +1987,26 @@ start_over: ;\n     int retries = 0;\n \n retry:\n-    if (access (aux_info_pathname, R_OK) == -1)\n+    if (access (aux_info_filename, R_OK) == -1)\n       {\n         if (errno == ENOENT && retries == 0)\n           {\n             if (is_syscalls)\n               {\n                 fprintf (stderr, \"%s: warning: missing SYSCALLS file `%s'\\n\",\n-                  pname, aux_info_pathname);\n+\t\t\t pname, aux_info_filename);\n                 return;\n               }\n-            if (!gen_aux_info_file (base_source_pathname))\n+            if (!gen_aux_info_file (base_source_filename))\n               return;\n             retries++;\n             goto retry;\n           }\n         else\n           {\n             fprintf (stderr, \"%s: error: can't read aux info file `%s': %s\\n\",\n-              pname, shortpath (NULL, aux_info_pathname), sys_errlist[errno]);\n+\t\t     pname, shortpath (NULL, aux_info_filename),\n+\t\t     sys_errlist[errno]);\n             errors++;\n             return;\n           }\n@@ -1996,10 +2018,11 @@ start_over: ;\n \n     /* Get some status information about this aux_info file.  */\n   \n-    if (stat (aux_info_pathname, &stat_buf) == -1)\n+    if (stat (aux_info_filename, &stat_buf) == -1)\n       {\n         fprintf (stderr, \"%s: error: can't get status of aux info file `%s': %s\\n\",\n-          pname, shortpath (NULL, aux_info_pathname), sys_errlist[errno]);\n+\t\t pname, shortpath (NULL, aux_info_filename),\n+\t\t sys_errlist[errno]);\n         errors++;\n         return;\n       }\n@@ -2022,10 +2045,11 @@ start_over: ;\n \n     /* Open the aux_info file.  */\n   \n-    if ((aux_info_file = open (aux_info_pathname, O_RDONLY, 0444 )) == -1)\n+    if ((aux_info_file = open (aux_info_filename, O_RDONLY, 0444 )) == -1)\n       {\n         fprintf (stderr, \"%s: error: can't open aux info file `%s' for reading: %s\\n\",\n-          pname, shortpath (NULL, aux_info_pathname), sys_errlist[errno]);\n+\t\t pname, shortpath (NULL, aux_info_filename),\n+\t\t sys_errlist[errno]);\n         return;\n       }\n   \n@@ -2040,7 +2064,8 @@ start_over: ;\n     if (read (aux_info_file, aux_info_base, aux_info_size) != aux_info_size)\n       {\n         fprintf (stderr, \"%s: error: while reading aux info file `%s': %s\\n\",\n-          pname, shortpath (NULL, aux_info_pathname), sys_errlist[errno]);\n+\t\t pname, shortpath (NULL, aux_info_filename),\n+\t\t sys_errlist[errno]);\n         free (aux_info_base);\n         close (aux_info_file);\n         return;\n@@ -2051,7 +2076,8 @@ start_over: ;\n     if (close (aux_info_file))\n       {\n         fprintf (stderr, \"%s: error: while closing aux info file `%s': %s\\n\",\n-          pname, shortpath (NULL, aux_info_pathname), sys_errlist[errno]);\n+\t\t pname, shortpath (NULL, aux_info_filename),\n+\t\t sys_errlist[errno]);\n         free (aux_info_base);\n         close (aux_info_file);\n         return;\n@@ -2062,15 +2088,16 @@ start_over: ;\n      fails for some reason, don't even worry about it.  */\n \n   if (!keep_it)\n-    if (unlink (aux_info_pathname) == -1)\n+    if (unlink (aux_info_filename) == -1)\n       fprintf (stderr, \"%s: error: can't delete aux info file `%s': %s\\n\",\n-        pname, shortpath (NULL, aux_info_pathname), sys_errlist[errno]);\n+\t       pname, shortpath (NULL, aux_info_filename),\n+\t       sys_errlist[errno]);\n \n   /* Save a pointer into the first line of the aux_info file which\n-     contains the pathname of the directory from which the compiler\n+     contains the filename of the directory from which the compiler\n      was invoked when the associated source file was compiled.\n      This information is used later to help create complete\n-     pathnames out of the (potentially) relative pathnames in\n+     filenames out of the (potentially) relative filenames in\n      the aux_info file.  */\n \n   {\n@@ -2081,7 +2108,7 @@ start_over: ;\n     p++;\n     while (*p == ' ')\n       p++;\n-    invocation_path = p;\t/* Save a pointer to first byte of path.  */\n+    invocation_filename = p;\t/* Save a pointer to first byte of path.  */\n     while (*p != ' ')\n       p++;\n     *p++ = '/';\n@@ -2109,12 +2136,11 @@ start_over: ;\n             if (referenced_file_is_newer (aux_info_p, aux_info_mtime))\n               {\n                 free (aux_info_base);\n-                if (unlink (aux_info_pathname) == -1)\n+                if (unlink (aux_info_filename) == -1)\n                   {\n                     fprintf (stderr, \"%s: error: can't delete file `%s': %s\\n\",\n-                      pname,\n-                      shortpath (NULL, aux_info_pathname),\n-                      sys_errlist[errno]);\n+\t\t\t     pname, shortpath (NULL, aux_info_filename),\n+\t\t\t     sys_errlist[errno]);\n                     return;\n                   }\n                 goto start_over;\n@@ -2167,35 +2193,35 @@ start_over: ;\n static void\n rename_c_file (const hash_table_entry *hp)\n {\n-  const char *pathname = hp->symbol;\n-  int last_char_index = strlen (pathname) - 1;\n-  char *const new_pathname = (char *) alloca (strlen (pathname) + 1);\n+  const char *filename = hp->symbol;\n+  int last_char_index = strlen (filename) - 1;\n+  char *const new_filename = (char *) alloca (strlen (filename) + 1);\n \n   /* Note that we don't care here if the given file was converted or not.  It\n      is possible that the given file was *not* converted, simply because there\n      was nothing in it which actually required conversion.  Even in this case,\n      we want to do the renaming.  Note that we only rename files with the .c\n      suffix.  */\n \n-  if (pathname[last_char_index] != 'c' || pathname[last_char_index-1] != '.')\n+  if (filename[last_char_index] != 'c' || filename[last_char_index-1] != '.')\n     return;\n \n-  strcpy (new_pathname, pathname);\n-  new_pathname[last_char_index] = 'C';\n+  strcpy (new_filename, filename);\n+  new_filename[last_char_index] = 'C';\n \n-  if (link (pathname, new_pathname) == -1)\n+  if (link (filename, new_filename) == -1)\n     {\n       fprintf (stderr, \"%s: warning: can't link file `%s' to `%s': %s\\n\",\n-        pname, shortpath (NULL, pathname),\n-          shortpath (NULL, new_pathname), sys_errlist[errno]);\n+\t       pname, shortpath (NULL, filename),\n+\t       shortpath (NULL, new_filename), sys_errlist[errno]);\n       errors++;\n       return;\n     }\n \n-  if (unlink (pathname) == -1)\n+  if (unlink (filename) == -1)\n     {\n       fprintf (stderr, \"%s: warning: can't delete file `%s': %s\\n\",\n-        pname, shortpath (NULL, pathname), sys_errlist[errno]);\n+\t       pname, shortpath (NULL, filename), sys_errlist[errno]);\n       errors++;\n       return;\n     }\n@@ -2316,26 +2342,24 @@ find_extern_def (const def_dec_info *head, const def_dec_info *user)\n               {\n                 conflict_noted = 1;\n                 fprintf (stderr, \"%s: error: conflicting extern definitions of '%s'\\n\",\n-                  pname, head->hash_entry->symbol);\n+\t\t\t pname, head->hash_entry->symbol);\n                 if (!quiet_flag)\n                   {\n                     fprintf (stderr, \"%s: declarations of '%s' will not be converted\\n\",\n-                      pname, head->hash_entry->symbol);\n+\t\t\t     pname, head->hash_entry->symbol);\n                     fprintf (stderr, \"%s: conflict list for '%s' follows:\\n\",\n-                      pname, head->hash_entry->symbol);\n+\t\t\t     pname, head->hash_entry->symbol);\n                     fprintf (stderr, \"%s:     %s(%d): %s\\n\",\n-                      pname,\n-                      shortpath (NULL, extern_def_p->file->hash_entry->symbol),\n-                      extern_def_p->line,\n-                      extern_def_p->ansi_decl);\n+\t\t\t     pname,\n+\t\t\t     shortpath (NULL, extern_def_p->file->hash_entry->symbol),\n+\t\t\t     extern_def_p->line, extern_def_p->ansi_decl);\n                   }\n               }\n             if (!quiet_flag)\n               fprintf (stderr, \"%s:     %s(%d): %s\\n\",\n-                pname,\n-                shortpath (NULL, dd_p->file->hash_entry->symbol),\n-                dd_p->line,\n-                dd_p->ansi_decl);\n+\t\t       pname,\n+\t\t       shortpath (NULL, dd_p->file->hash_entry->symbol),\n+\t\t       dd_p->line, dd_p->ansi_decl);\n           }\n       }\n \n@@ -2357,9 +2381,9 @@ find_extern_def (const def_dec_info *head, const def_dec_info *user)\n             extern_def_p = dd_p;\t/* save a pointer to the definition */\n             if (!quiet_flag)\n               fprintf (stderr, \"%s: warning: using formals list from %s(%d) for function `%s'\\n\",\n-                pname,\n-                shortpath (NULL, dd_p->file->hash_entry->symbol),\n-                dd_p->line, dd_p->hash_entry->symbol);\n+\t\t       pname,\n+\t\t       shortpath (NULL, dd_p->file->hash_entry->symbol),\n+\t\t       dd_p->line, dd_p->hash_entry->symbol);\n             break;\n           }\n \n@@ -2392,18 +2416,14 @@ find_extern_def (const def_dec_info *head, const def_dec_info *user)\n                     + strlen (user->hash_entry->symbol) + 2;\n                 strcpy (p, \"???);\");\n \n-                fprintf (stderr, \"%s: please add `%s' to SYSCALLS (see %s(%d))\\n\",\n-                  pname,\n-                  needed+7,\t/* Don't print \"extern \" */\n-                  shortpath (NULL, file),\n-                  user->line);\n+                fprintf (stderr, \"%s: %d: `%s' used but missing from SYSCALLS\\n\",\n+\t\t\t shortpath (NULL, file), user->line,\n+\t\t\t needed+7);\t/* Don't print \"extern \" */\n               }\n             else\n-              fprintf (stderr, \"%s: warning: no extern definition for `%s' (see %s(%d))\\n\",\n-                pname,\n-                user->hash_entry->symbol,\n-                shortpath (NULL, file),\n-                user->line);\n+              fprintf (stderr, \"%s: %d: warning: no extern definition for `%s'\\n\",\n+\t\t       shortpath (NULL, file), user->line,\n+\t\t       user->hash_entry->symbol);\n         }\n     }\n   return extern_def_p;\n@@ -2431,16 +2451,14 @@ find_static_definition (const def_dec_info *user)\n     {\n       if (!quiet_flag)\n         fprintf (stderr, \"%s: warning: no static definition for `%s' in file `%s'\\n\",\n-          pname,\n-          head->hash_entry->symbol,\n-          shortpath (NULL, user->file->hash_entry->symbol));\n+\t\t pname, head->hash_entry->symbol,\n+\t\t shortpath (NULL, user->file->hash_entry->symbol));\n     }\n   else if (num_static_defs > 1)\n     {\n       fprintf (stderr, \"%s: error: multiple static defs of `%s' in file `%s'\\n\",\n-        pname,\n-        head->hash_entry->symbol,\n-        shortpath (NULL, user->file->hash_entry->symbol));\n+\t       pname, head->hash_entry->symbol,\n+\t       shortpath (NULL, user->file->hash_entry->symbol));\n       return NULL;\n     }\n   return static_def_p;\n@@ -2608,11 +2626,12 @@ declare_source_confusing (const char *clean_p)\n   if (!quiet_flag)\n     {\n       if (clean_p == 0)\n-        fprintf (stderr, \"%s: warning: source too confusing near %s(%d)\\n\",\n-        pname, shortpath (NULL, convert_path), last_known_line_number);\n+        fprintf (stderr, \"%s: %d: warning: source too confusing\\n\",\n+\t\t shortpath (NULL, convert_filename), last_known_line_number);\n       else\n-        fprintf (stderr, \"%s: warning: source too confusing at %s(%d)\\n\",\n-        pname, shortpath (NULL, convert_path), identify_lineno (clean_p));\n+        fprintf (stderr, \"%s: %d: warning: source too confusing\\n\",\n+\t\t shortpath (NULL, convert_filename),\n+\t\t identify_lineno (clean_p));\n     }\n   longjmp (source_confusion_recovery, 1);\n }\n@@ -2805,10 +2824,9 @@ edit_fn_declaration (const def_dec_info *def_dec_p,\n   if (other_variable_style_function (definition->ansi_decl))\n     {\n       if (!quiet_flag)\n-        fprintf (stderr, \"%s: warning: varargs function declaration at %s(%d) not converted\\n\",\n-          pname,\n-          shortpath (NULL, def_dec_p->file->hash_entry->symbol),\n-          def_dec_p->line);\n+        fprintf (stderr, \"%s: %d: warning: varargs function declaration not converted\\n\",\n+\t\t shortpath (NULL, def_dec_p->file->hash_entry->symbol),\n+\t\t def_dec_p->line);\n       return;\n     }\n \n@@ -2822,7 +2840,7 @@ edit_fn_declaration (const def_dec_info *def_dec_p,\n     {\n       restore_pointers ();\n       fprintf (stderr, \"%s: declaration of function `%s' not converted\\n\",\n-        pname, function_to_edit);\n+\t       pname, function_to_edit);\n       return;\n     }\n \n@@ -2945,7 +2963,7 @@ edit_fn_declaration (const def_dec_info *def_dec_p,\n         {\n           if (!quiet_flag)\n             fprintf (stderr, \"%s: warning: too many parameter lists in declaration of `%s'\\n\",\n-              pname, def_dec_p->hash_entry->symbol);\n+\t\t     pname, def_dec_p->hash_entry->symbol);\n           check_source (0, end_formals);  /* leave the declaration intact */\n         }\n #endif /* !defined(UNPROTOIZE) */\n@@ -2966,7 +2984,7 @@ edit_fn_declaration (const def_dec_info *def_dec_p,\n               {\n                 if (!quiet_flag)\n                   fprintf (stderr, \"\\n%s: warning: too few parameter lists in declaration of `%s'\\n\",\n-                    pname, def_dec_p->hash_entry->symbol);\n+\t\t\t   pname, def_dec_p->hash_entry->symbol);\n                 check_source (0, start_formals); /* leave the decl intact */\n               }\n #endif /* !defined(UNPROTOIZE) */\n@@ -3057,14 +3075,13 @@ edit_formals_lists (const char *end_formals, unsigned f_list_count, const def_de\n       if (func_name_len == 0)\n         check_source (0, func_name_start);\n       if (func_name_len != strlen (expected)\n-        || strncmp (func_name_start, expected, func_name_len))\n+\t  || strncmp (func_name_start, expected, func_name_len))\n         {\n-          fprintf (stderr, \"%s: warning: found `%s' at %s(%d) but expected `%s'\\n\",\n-            pname,\n-            dupnstr (func_name_start, func_name_len),\n-            shortpath (NULL, def_dec_p->file->hash_entry->symbol),\n-            identify_lineno (func_name_start),\n-            expected);\n+          fprintf (stderr, \"%s: %d: warning: found `%s' but expected `%s'\\n\",\n+\t\t   shortpath (NULL, def_dec_p->file->hash_entry->symbol),\n+\t\t   identify_lineno (func_name_start),\n+\t\t   dupnstr (func_name_start, func_name_len),\n+\t\t   expected);\n           return 1;\n         }\n     }\n@@ -3218,7 +3235,7 @@ add_local_decl (const def_dec_info *def_dec_p, const char *clean_text_p)\n     {\n       restore_pointers ();\n       fprintf (stderr, \"%s: local declaration for function `%s' not inserted\\n\",\n-        pname, function_to_edit);\n+\t       pname, function_to_edit);\n       return;\n     }\n \n@@ -3245,11 +3262,9 @@ add_local_decl (const def_dec_info *def_dec_p, const char *clean_text_p)\n     {\n       if (!quiet_flag)\n         fprintf (stderr,\n-          \"\\n%s: warning: can't add declaration of `%s' into macro call at %s(%d)\\n\",\n-          pname,\n-          def_dec_p->hash_entry->symbol,\n-          def_dec_p->file->hash_entry->symbol,\n-          def_dec_p->line);\n+          \"\\n%s: %d: warning: can't add declaration of `%s' into macro call\\n\",\n+          def_dec_p->file->hash_entry->symbol, def_dec_p->line, \n+          def_dec_p->hash_entry->symbol);\n       return;\n     }\n \n@@ -3320,7 +3335,7 @@ add_global_decls (const file_info *file_p, const char *clean_text_p)\n     {\n       restore_pointers ();\n       fprintf (stderr, \"%s: global declarations for file `%s' not inserted\\n\",\n-        pname, shortpath (NULL, file_p->hash_entry->symbol));\n+\t       pname, shortpath (NULL, file_p->hash_entry->symbol));\n       return;\n     }\n \n@@ -3409,7 +3424,7 @@ edit_fn_definition (const def_dec_info *def_dec_p, const char *clean_text_p)\n     {\n       restore_pointers ();\n       fprintf (stderr, \"%s: definition of function `%s' not converted\\n\",\n-        pname, function_to_edit);\n+\t       pname, function_to_edit);\n       return;\n     }\n \n@@ -3427,11 +3442,10 @@ edit_fn_definition (const def_dec_info *def_dec_p, const char *clean_text_p)\n   if (other_variable_style_function (def_dec_p->ansi_decl))\n     {\n       if (!quiet_flag)\n-        fprintf (stderr, \"%s: warning: %s function definition at %s(%d) not converted\\n\",\n-          pname,\n-          other_var_style,\n-          shortpath (NULL, def_dec_p->file->hash_entry->symbol),\n-          identify_lineno (end_formals));\n+        fprintf (stderr, \"%s: %d: warning: definition of %s not converted\\n\",\n+\t\t shortpath (NULL, def_dec_p->file->hash_entry->symbol),\n+\t\t identify_lineno (end_formals), \n+\t\t other_var_style);\n       output_up_to (end_formals);\n       return;\n     }\n@@ -3440,7 +3454,7 @@ edit_fn_definition (const def_dec_info *def_dec_p, const char *clean_text_p)\n     {\n       restore_pointers ();\n       fprintf (stderr, \"%s: definition of function `%s' not converted\\n\",\n-        pname, function_to_edit);\n+\t       pname, function_to_edit);\n       return;\n     }\n \n@@ -3765,11 +3779,9 @@ scan_for_missed_items (const file_info *file_p)\n \t\t    /* If we make it here, then we did not know about this\n \t\t       function definition.  */\n \n-\t\t    fprintf (stderr, \"%s: warning: `%s' at %s(%d) was #if 0\\n\",\n-\t\t\t     pname,\n-\t\t\t     func_name,\n+\t\t    fprintf (stderr, \"%s: %d: warning: `%s' was #if 0\\n\",\n \t\t\t     shortpath (NULL, file_p->hash_entry->symbol),\n-\t\t\t     identify_lineno (id_start));\n+\t\t\t     identify_lineno (id_start), func_name);\n \t\t    fprintf (stderr, \"%s: function definition not converted\\n\",\n \t\t\t     pname);\n \t\t  }\n@@ -3811,45 +3823,46 @@ edit_file (const hash_table_entry *hp)\n   if (!needs_to_be_converted (file_p))\n     return;\n \n-  convert_path = file_p->hash_entry->symbol;\n+  convert_filename = file_p->hash_entry->symbol;\n \n   /* Convert a file if it is in a directory where we want conversion\n      and the file is not excluded.  */\n \n-  if (!directory_specified_p (convert_path)\n-      || file_excluded_p (convert_path))\n+  if (!directory_specified_p (convert_filename)\n+      || file_excluded_p (convert_filename))\n     {\n       if (!quiet_flag\n #ifdef UNPROTOIZE\n           /* Don't even mention \"system\" include files unless we are\n              protoizing.  If we are protoizing, we mention these as a\n              gentile way of prodding the user to convert his \"system\"\n              include files to prototype format.  */\n-          && !in_system_include_dir (convert_path)\n+          && !in_system_include_dir (convert_filename)\n #endif /* defined(UNPROTOIZE) */\n           )\n         fprintf (stderr, \"%s: file `%s' not converted\\n\",\n-          pname, shortpath (NULL, convert_path));\n+\t\t pname, shortpath (NULL, convert_filename));\n       return;\n     }\n \n   /* Let the user know what we are up to.  */\n \n   if (nochange_flag)\n-      puts (shortpath (NULL, convert_path));\n+      puts (shortpath (NULL, convert_filename));\n   else\n     {\n       fprintf (stderr, \"%s: converting file `%s'\\n\",\n-        pname, shortpath (NULL, convert_path));\n+\t       pname, shortpath (NULL, convert_filename));\n       fflush (stderr);\n     }\n \n   /* Find out the size (in bytes) of the original file.  */\n \n-  if (stat (convert_path, &stat_buf) == -1)\n+  /* The cast avoids an erroneous warning on AIX.  */\n+  if (stat ((char *)convert_filename, &stat_buf) == -1)\n     {\n       fprintf (stderr, \"%s: error: can't get status for file `%s': %s\\n\",\n-        pname, shortpath (NULL, convert_path), sys_errlist[errno]);\n+\t       pname, shortpath (NULL, convert_filename), sys_errlist[errno]);\n       return;\n     }\n   orig_size = stat_buf.st_size;\n@@ -3880,10 +3893,11 @@ edit_file (const hash_table_entry *hp)\n \n     /* Open the file to be converted in READ ONLY mode.  */\n \n-    if ((input_file = open (convert_path, O_RDONLY, 0444)) == -1)\n+    if ((input_file = open (convert_filename, O_RDONLY, 0444)) == -1)\n       {\n         fprintf (stderr, \"%s: error: can't open file `%s' for reading: %s\\n\",\n-          pname, shortpath (NULL, convert_path), sys_errlist[errno]);\n+\t\t pname, shortpath (NULL, convert_filename),\n+\t\t sys_errlist[errno]);\n         return;\n       }\n \n@@ -3895,7 +3909,8 @@ edit_file (const hash_table_entry *hp)\n       {\n         close (input_file);\n         fprintf (stderr, \"\\n%s: error: while reading input file `%s': %s\\n\",\n-          pname, shortpath (NULL, convert_path), sys_errlist[errno]);\n+\t\t pname, shortpath (NULL, convert_filename),\n+\t\t sys_errlist[errno]);\n         return;\n       }\n \n@@ -3918,26 +3933,25 @@ edit_file (const hash_table_entry *hp)\n   {\n     int clean_file;\n     size_t clean_size = orig_text_limit - orig_text_base;\n-    char *const clean_path = (char *) alloca (strlen (convert_path) + 6 + 1);\n+    char *const clean_filename = (char *) alloca (strlen (convert_filename) + 6 + 1);\n \n     /* Open (and create) the clean file.  */\n   \n-    strcpy (clean_path, convert_path);\n-    strcat (clean_path, \".clean\");\n-    if ((clean_file = creat (clean_path, 0666)) == -1)\n+    strcpy (clean_filename, convert_filename);\n+    strcat (clean_filename, \".clean\");\n+    if ((clean_file = creat (clean_filename, 0666)) == -1)\n       {\n         fprintf (stderr, \"%s: error: can't create/open clean file `%s': %s\\n\",\n-          pname,\n-          shortpath (NULL, clean_path),\n-          sys_errlist[errno]);\n+\t\t pname, shortpath (NULL, clean_filename),\n+\t\t sys_errlist[errno]);\n         return;\n       }\n   \n     /* Write the clean file.  */\n   \n     if (write (clean_file, new_clean_text_base, clean_size) != clean_size)\n       fprintf (stderr, \"%s: error: while writing file `%s': %s\\n\",\n-        pname, shortpath (NULL, clean_path), sys_errlist[errno]);\n+\t       pname, shortpath (NULL, clean_filename), sys_errlist[errno]);\n   \n     close (clean_file);\n   }\n@@ -4019,39 +4033,37 @@ edit_file (const hash_table_entry *hp)\n \n   if (!nosave_flag)\n     {\n-      char *new_path =\n-          (char *) xmalloc (strlen (convert_path) + strlen (save_suffix) + 2);\n+      char *new_filename =\n+          (char *) xmalloc (strlen (convert_filename) + strlen (save_suffix) + 2);\n   \n-      strcpy (new_path, convert_path);\n-      strcat (new_path, save_suffix);\n-      if (link (convert_path, new_path) == -1)\n+      strcpy (new_filename, convert_filename);\n+      strcat (new_filename, save_suffix);\n+      if (link (convert_filename, new_filename) == -1)\n         {\n           if (errno == EEXIST)\n             {\n               if (!quiet_flag)\n                 fprintf (stderr, \"%s: warning: file `%s' already saved in `%s'\\n\",\n-                  pname,\n-                  shortpath (NULL, convert_path),\n-                  shortpath (NULL, new_path));\n+\t\t\t pname,\n+\t\t\t shortpath (NULL, convert_filename),\n+\t\t\t shortpath (NULL, new_filename));\n             }\n           else\n             {\n               fprintf (stderr, \"%s: error: can't link file `%s' to `%s': %s\\n\",\n-                pname,\n-                shortpath (NULL, convert_path),\n-                shortpath (NULL, new_path),\n-                sys_errlist[errno]);\n+\t\t       pname,\n+\t\t       shortpath (NULL, convert_filename),\n+\t\t       shortpath (NULL, new_filename),\n+\t\t       sys_errlist[errno]);\n               return;\n             }\n         }\n     }\n \n-  if (unlink (convert_path) == -1)\n+  if (unlink (convert_filename) == -1)\n     {\n       fprintf (stderr, \"%s: error: can't delete file `%s': %s\\n\",\n-        pname,\n-        shortpath (NULL, convert_path),\n-        sys_errlist[errno]);\n+\t       pname, shortpath (NULL, convert_filename), sys_errlist[errno]);\n       return;\n     }\n \n@@ -4060,12 +4072,11 @@ edit_file (const hash_table_entry *hp)\n \n     /* Open (and create) the output file.  */\n   \n-    if ((output_file = creat (convert_path, 0666)) == -1)\n+    if ((output_file = creat (convert_filename, 0666)) == -1)\n       {\n         fprintf (stderr, \"%s: error: can't create/open output file `%s': %s\\n\",\n-          pname,\n-          shortpath (NULL, convert_path),\n-          sys_errlist[errno]);\n+\t\t pname, shortpath (NULL, convert_filename),\n+\t\t sys_errlist[errno]);\n         return;\n       }\n   \n@@ -4076,7 +4087,8 @@ edit_file (const hash_table_entry *hp)\n   \n       if (write (output_file, repl_text_base, out_size) != out_size)\n         fprintf (stderr, \"%s: error: while writing file `%s': %s\\n\",\n-          pname, shortpath (NULL, convert_path), sys_errlist[errno]);\n+\t\t pname, shortpath (NULL, convert_filename),\n+\t\t sys_errlist[errno]);\n     }\n   \n     close (output_file);\n@@ -4090,9 +4102,10 @@ edit_file (const hash_table_entry *hp)\n \n   /* Change the mode of the output file to match the original file.  */\n \n-  if (chmod (convert_path, stat_buf.st_mode) == -1)\n+  /* The cast avoids an erroneous warning on AIX.  */\n+  if (chmod ((char *)convert_filename, stat_buf.st_mode) == -1)\n     fprintf (stderr, \"%s: error: can't change mode of file `%s': %s\\n\",\n-      pname, shortpath (NULL, convert_path), sys_errlist[errno]);\n+\t     pname, shortpath (NULL, convert_filename), sys_errlist[errno]);\n \n   /* Note:  We would try to change the owner and group of the output file\n      to match those of the input file here, except that may not be a good\n@@ -4108,7 +4121,8 @@ static void\n do_processing (void)\n {\n   const char * const *base_pp;\n-  const char * const * const end_pps = &base_source_paths[base_source_files];\n+  const char * const * const end_pps\n+    = &base_source_filenames[n_base_source_files];\n \n #ifndef UNPROTOIZE\n   int syscalls_len;\n@@ -4119,7 +4133,7 @@ do_processing (void)\n      aux_info_file just read will be automatically deleted unless the\n      keep_flag is set.  */\n \n-  for (base_pp = base_source_paths; base_pp < end_pps; base_pp++)\n+  for (base_pp = base_source_filenames; base_pp < end_pps; base_pp++)\n     process_aux_info_file (*base_pp, keep_flag, 0);\n \n #ifndef UNPROTOIZE\n@@ -4129,31 +4143,31 @@ do_processing (void)\n \n   if (nondefault_syscalls_dir)\n     {\n-      syscalls_pathname\n+      syscalls_absolute_filename\n         = (char *) xmalloc (strlen (nondefault_syscalls_dir)\n                             + strlen (syscalls_filename) + 1);\n-      strcpy (syscalls_pathname, nondefault_syscalls_dir);\n+      strcpy (syscalls_absolute_filename, nondefault_syscalls_dir);\n     }\n   else\n     {\n-      syscalls_pathname\n+      syscalls_absolute_filename\n         = (char *) xmalloc (strlen (default_syscalls_dir)\n                             + strlen (syscalls_filename) + 1);\n-      strcpy (syscalls_pathname, default_syscalls_dir);\n+      strcpy (syscalls_absolute_filename, default_syscalls_dir);\n     }\n \n-  syscalls_len = strlen (syscalls_pathname);\n-  if (*(syscalls_pathname + syscalls_len - 1) != '/')\n+  syscalls_len = strlen (syscalls_filename);\n+  if (*(syscalls_absolute_filename + syscalls_len - 1) != '/')\n     {\n-      *(syscalls_pathname + syscalls_len++) = '/';\n-      *(syscalls_pathname + syscalls_len) = '\\0';\n+      *(syscalls_absolute_filename + syscalls_len++) = '/';\n+      *(syscalls_absolute_filename + syscalls_len) = '\\0';\n     }\n-  strcat (syscalls_pathname, syscalls_filename);\n+  strcat (syscalls_absolute_filename, syscalls_filename);\n   \n   /* Call process_aux_info_file in such a way that it does not try to\n      delete the SYSCALLS aux_info file.  */\n \n-  process_aux_info_file (syscalls_pathname, 1, 1);\n+  process_aux_info_file (syscalls_absolute_filename, 1, 1);\n \n #endif /* !defined(UNPROTOIZE) */\n \n@@ -4164,7 +4178,7 @@ do_processing (void)\n      file_info record that they hang from.  The following line causes all of\n      these lists to be rearranged into ascending line number order.  */\n \n-  visit_each_hash_node (pathname_primary, reverse_def_dec_list);\n+  visit_each_hash_node (filename_primary, reverse_def_dec_list);\n \n #ifndef UNPROTOIZE\n \n@@ -4181,15 +4195,15 @@ do_processing (void)\n \n   /* Now convert each file that can be converted (and needs to be).  */\n \n-  visit_each_hash_node (pathname_primary, edit_file);\n+  visit_each_hash_node (filename_primary, edit_file);\n \n #ifndef UNPROTOIZE\n \n   /* If we are working in cplusplus mode, try to rename all .c files to .C\n      files.  Don't panic if some of the renames don't work.  */\n \n   if (cplusplus_flag && !nochange_flag)\n-    visit_each_hash_node (pathname_primary, rename_c_file);\n+    visit_each_hash_node (filename_primary, rename_c_file);\n \n #endif /* !defined(UNPROTOIZE) */\n }\n@@ -4231,11 +4245,11 @@ main (int argc, char **const argv)\n   size = 100;\n   while (1)\n     {\n-      int value;\n+      char *value;\n \n       cwd_buffer = (char *) xmalloc (size);\n       value = getcwd (cwd_buffer, size);\n-      if (value > 0 && value < size)\n+      if (value != 0 || errno != ERANGE)\n \tbreak;\n       free (cwd_buffer);\n       size *= 2;\n@@ -4311,23 +4325,23 @@ main (int argc, char **const argv)\n \t}\n     }\n  \n-  base_source_files = argc - optind;\n+  n_base_source_files = argc - optind;\n \n-  /* Now actually make a list of the base source pathnames.  */\n+  /* Now actually make a list of the base source filenames.  */\n \n-  base_source_paths =\n-    (const char **) xmalloc ((base_source_files + 1) * sizeof (char *));\n-  base_source_files = 0;\n+  base_source_filenames =\n+    (const char **) xmalloc ((n_base_source_files + 1) * sizeof (char *));\n+  n_base_source_files = 0;\n   for (; optind < argc; optind++)\n     {\n       const char *path = abspath (NULL, argv[optind]);\n       int len = strlen (path);\n \n       if (path[len-1] == 'c' && path[len-2] == '.')\n-\tbase_source_paths[base_source_files++] = path;\n+\tbase_source_filenames[n_base_source_files++] = path;\n       else\n \t{\n-\t  fprintf (stderr, \"%s: input pathnames must have .c suffixes: %s\\n\",\n+\t  fprintf (stderr, \"%s: input file names must have .c suffixes: %s\\n\",\n \t\t   pname, shortpath (NULL, path));\n \t  errors++;\n \t}"}]}