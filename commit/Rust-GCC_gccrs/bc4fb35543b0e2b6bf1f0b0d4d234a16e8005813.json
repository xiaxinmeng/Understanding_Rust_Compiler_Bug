{"sha": "bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM0ZmIzNTU0M2IwZTJiNmJmMWYwYjBkNGQyMzRhMTZlODAwNTgxMw==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2012-03-15T16:38:14Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2012-03-15T16:38:14Z"}, "message": "tree-vect-patterns.c (widened_name_p): Rename to ...\n\nChangeLog:\n\n\t* tree-vect-patterns.c (widened_name_p): Rename to ...\n\t(type_conversion_p): ... this.  Add new argument to determine\n\tif it's a promotion or demotion operation.  Check for\n\tCONVERT_EXPR_CODE_P instead of NOP_EXPR.\n\t(vect_recog_dot_prod_pattern): Call type_conversion_p instead\n\twidened_name_p.\n\t(vect_recog_widen_mult_pattern, vect_recog_widen_sum_pattern,\n\tvect_operation_fits_smaller_type, vect_recog_widen_shift_pattern):\n\tLikewise.\n\t(vect_recog_mixed_size_cond_pattern): Likewise and allow\n\tnon-constant then and else clauses.\n\ntestsuite/ChangeLog:\n\n\t* gcc.dg/vect/slp-cond-3.c: New test.\n\t* gcc.dg/vect/slp-cond-4.c: New test.\n\nCo-Authored-By: Ulrich Weigand <ulrich.weigand@linaro.org>\n\nFrom-SVN: r185437", "tree": {"sha": "12318ab6ab78d9fd0332f5306fb9421094d5d790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12318ab6ab78d9fd0332f5306fb9421094d5d790"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f57091836580804c6db4de0df9a7d078ff578d4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f57091836580804c6db4de0df9a7d078ff578d4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f57091836580804c6db4de0df9a7d078ff578d4b"}], "stats": {"total": 330, "additions": 292, "deletions": 38}, "files": [{"sha": "594192c6c327fd6d4b9e4178e9e033e4a7a05389", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813", "patch": "@@ -1,3 +1,18 @@\n+2012-03-15  Ira Rosen  <irar@il.ibm.com>\n+\t    Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\n+\t* tree-vect-patterns.c (widened_name_p): Rename to ...\n+\t(type_conversion_p): ... this.  Add new argument to determine\n+\tif it's a promotion or demotion operation.  Check for\n+\tCONVERT_EXPR_CODE_P instead of NOP_EXPR.\n+\t(vect_recog_dot_prod_pattern): Call type_conversion_p instead\n+\twidened_name_p.\n+\t(vect_recog_widen_mult_pattern, vect_recog_widen_sum_pattern,\n+\tvect_operation_fits_smaller_type, vect_recog_widen_shift_pattern):\n+\tLikewise.\n+\t(vect_recog_mixed_size_cond_pattern): Likewise and allow\n+\tnon-constant then and else clauses.\n+\n 2012-03-15  Ira Rosen  <irar@il.ibm.com>\n \t    Ulrich Weigand  <ulrich.weigand@linaro.org>\n "}, {"sha": "b41781ff1d39bf08253d0e9ca963d401abc5608f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813", "patch": "@@ -1,3 +1,9 @@\n+2012-03-15  Ira Rosen  <irar@il.ibm.com>\n+\t    Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\n+\t* gcc.dg/vect/slp-cond-3.c: New test.\n+\t* gcc.dg/vect/slp-cond-4.c: New test.\n+\n 2012-03-15  Ira Rosen  <irar@il.ibm.com>\n \t    Ulrich Weigand  <ulrich.weigand@linaro.org>\n "}, {"sha": "4ee2dcec3af0fa954eaba35015f972ff593e7983", "filename": "gcc/testsuite/gcc.dg/vect/slp-cond-3.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-3.c?ref=bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813", "patch": "@@ -0,0 +1,84 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+/* Comparison in int, then/else and result in unsigned char.  */\n+\n+static inline unsigned char\n+foo (int x, int y, int a, int b)\n+{\n+  if (x >= y)\n+    return a;\n+  else\n+    return b;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+bar (unsigned char * __restrict__ a, unsigned char * __restrict__ b,\n+     unsigned char * __restrict__ c, unsigned char * __restrict__ d,\n+     unsigned char * __restrict__ e, int w)\n+{\n+  int i;\n+  for (i = 0; i < N/16; i++, a += 16, b += 16, c += 16, d += 16, e += 16)\n+    {\n+      e[0] = foo (c[0], d[0], a[0] * w, b[0] * w);\n+      e[1] = foo (c[1], d[1], a[1] * w, b[1] * w);\n+      e[2] = foo (c[2], d[2], a[2] * w, b[2] * w);\n+      e[3] = foo (c[3], d[3], a[3] * w, b[3] * w);\n+      e[4] = foo (c[4], d[4], a[4] * w, b[4] * w);\n+      e[5] = foo (c[5], d[5], a[5] * w, b[5] * w);\n+      e[6] = foo (c[6], d[6], a[6] * w, b[6] * w);\n+      e[7] = foo (c[7], d[7], a[7] * w, b[7] * w);\n+      e[8] = foo (c[8], d[8], a[8] * w, b[8] * w);\n+      e[9] = foo (c[9], d[9], a[9] * w, b[9] * w);\n+      e[10] = foo (c[10], d[10], a[10] * w, b[10] * w);\n+      e[11] = foo (c[11], d[11], a[11] * w, b[11] * w);\n+      e[12] = foo (c[12], d[12], a[12] * w, b[12] * w);\n+      e[13] = foo (c[13], d[13], a[13] * w, b[13] * w);\n+      e[14] = foo (c[14], d[14], a[14] * w, b[14] * w);\n+      e[15] = foo (c[15], d[15], a[15] * w, b[15] * w);\n+    }\n+}\n+\n+\n+unsigned char a[N], b[N], c[N], d[N], e[N];\n+\n+int main ()\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = i;\n+      b[i] = 5;\n+      e[i] = 0;\n+\n+      switch (i % 9)\n+        {\n+        case 0: asm (\"\"); c[i] = i; d[i] = i + 1; break;\n+        case 1: c[i] = 0; d[i] = 0; break;\n+        case 2: c[i] = i + 1; d[i] = i - 1; break;\n+        case 3: c[i] = i; d[i] = i + 7; break;\n+        case 4: c[i] = i; d[i] = i; break;\n+        case 5: c[i] = i + 16; d[i] = i + 3; break;\n+        case 6: c[i] = i - 5; d[i] = i; break;\n+        case 7: c[i] = i; d[i] = i; break;\n+        case 8: c[i] = i; d[i] = i - 7; break;\n+        }\n+    }\n+\n+  bar (a, b, c, d, e, 2);\n+  for (i = 0; i < N; i++)\n+    if (e[i] != ((i % 3) == 0 ? 10 : 2 * i))\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "60a62384e03900a3118338dbbb60f63fe6b46948", "filename": "gcc/testsuite/gcc.dg/vect/slp-cond-4.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-4.c?ref=bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813", "patch": "@@ -0,0 +1,86 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+/* Comparison in short, then/else and result in int.  */\n+static inline int\n+foo (short x, short y, int a, int b)\n+{\n+  if (x >= y)\n+    return a;\n+  else\n+    return b;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+bar (short * __restrict__ a, short * __restrict__ b,\n+     short * __restrict__ c, short * __restrict__ d,\n+     int * __restrict__ e, int w)\n+{\n+  int i;\n+  int stride = 16;\n+\n+  for (i = 0; i < N/stride; i++, a += stride, b += stride, c += stride,\n+                                d += stride, e += stride)\n+    {\n+      e[0] = foo (c[0], d[0], a[0], b[0]);\n+      e[1] = foo (c[1], d[1], a[1], b[1]);\n+      e[2] = foo (c[2], d[2], a[2], b[2]);\n+      e[3] = foo (c[3], d[3], a[3], b[3]);\n+      e[4] = foo (c[4], d[4], a[4], b[4]);\n+      e[5] = foo (c[5], d[5], a[5], b[5]);\n+      e[6] = foo (c[6], d[6], a[6], b[6]);\n+      e[7] = foo (c[7], d[7], a[7], b[7]);\n+      e[8] = foo (c[8], d[8], a[8], b[8]);\n+      e[9] = foo (c[9], d[9], a[9], b[9]);\n+      e[10] = foo (c[10], d[10], a[10], b[10]);\n+      e[11] = foo (c[11], d[11], a[11], b[11]);\n+      e[12] = foo (c[12], d[12], a[12], b[12]);\n+      e[13] = foo (c[13], d[13], a[13], b[13]);\n+      e[14] = foo (c[14], d[14], a[14], b[14]);\n+      e[15] = foo (c[15], d[15], a[15], b[15]);\n+    }\n+}\n+\n+\n+short a[N], b[N], c[N], d[N];\n+int e[N];\n+\n+int main ()\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = i;\n+      b[i] = 5;\n+      e[i] = 0;\n+\n+      switch (i % 9)\n+        {\n+        case 0: asm (\"\"); c[i] = - i - 1; d[i] = i + 1; break;\n+        case 1: c[i] = 0; d[i] = 0; break;\n+        case 2: c[i] = i + 1; d[i] = - i - 1; break;\n+        case 3: c[i] = i; d[i] = i + 7; break;\n+        case 4: c[i] = i; d[i] = i; break;\n+        case 5: c[i] = i + 16; d[i] = i + 3; break;\n+        case 6: c[i] = - i - 5; d[i] = - i; break;\n+        case 7: c[i] = - i; d[i] = - i; break;\n+        case 8: c[i] = - i; d[i] = - i - 7; break;\n+        }\n+    }\n+\n+  bar (a, b, c, d, e, 2);\n+  for (i = 0; i < N; i++)\n+    if (e[i] != ((i % 3) == 0 ? 5 : i))\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "b871c0ba3615565fcf4dd115d924951052807a8d", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 101, "deletions": 38, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813", "patch": "@@ -84,18 +84,16 @@ new_pattern_def_seq (stmt_vec_info stmt_info, gimple stmt)\n   append_pattern_def_seq (stmt_info, stmt);\n }\n \n-/* Function widened_name_p\n-\n-   Check whether NAME, an ssa-name used in USE_STMT,\n-   is a result of a type-promotion, such that:\n+/* Check whether NAME, an ssa-name used in USE_STMT,\n+   is a result of a type promotion or demotion, such that:\n      DEF_STMT: NAME = NOP (name0)\n-   where the type of name0 (HALF_TYPE) is smaller than the type of NAME.\n+   where the type of name0 (ORIG_TYPE) is smaller/bigger than the type of NAME.\n    If CHECK_SIGN is TRUE, check that either both types are signed or both are\n    unsigned.  */\n \n static bool\n-widened_name_p (tree name, gimple use_stmt, tree *half_type, gimple *def_stmt,\n-\t\tbool check_sign)\n+type_conversion_p (tree name, gimple use_stmt, bool check_sign,\n+\t\t   tree *orig_type, gimple *def_stmt, bool *promotion)\n {\n   tree dummy;\n   gimple dummy_gimple;\n@@ -118,21 +116,27 @@ widened_name_p (tree name, gimple use_stmt, tree *half_type, gimple *def_stmt,\n       && dt != vect_external_def && dt != vect_constant_def)\n     return false;\n \n-  if (! *def_stmt)\n+  if (!*def_stmt)\n     return false;\n \n   if (!is_gimple_assign (*def_stmt))\n     return false;\n \n-  if (gimple_assign_rhs_code (*def_stmt) != NOP_EXPR)\n+  if (!CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (*def_stmt)))\n     return false;\n \n   oprnd0 = gimple_assign_rhs1 (*def_stmt);\n \n-  *half_type = TREE_TYPE (oprnd0);\n-  if (!INTEGRAL_TYPE_P (type) || !INTEGRAL_TYPE_P (*half_type)\n-      || ((TYPE_UNSIGNED (type) != TYPE_UNSIGNED (*half_type)) && check_sign)\n-      || (TYPE_PRECISION (type) < (TYPE_PRECISION (*half_type) * 2)))\n+  *orig_type = TREE_TYPE (oprnd0);\n+  if (!INTEGRAL_TYPE_P (type) || !INTEGRAL_TYPE_P (*orig_type)\n+      || ((TYPE_UNSIGNED (type) != TYPE_UNSIGNED (*orig_type)) && check_sign))\n+    return false;\n+\n+  if (TYPE_PRECISION (type) >= (TYPE_PRECISION (*orig_type) * 2))\n+    *promotion = true;\n+  else if (TYPE_PRECISION (*orig_type) >= (TYPE_PRECISION (type) * 2))\n+    *promotion = false;\n+  else\n     return false;\n \n   if (!vect_is_simple_use (oprnd0, *def_stmt, loop_vinfo,\n@@ -214,6 +218,7 @@ vect_recog_dot_prod_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   struct loop *loop;\n   tree var;\n+  bool promotion;\n \n   if (!loop_info)\n     return NULL;\n@@ -277,7 +282,9 @@ vect_recog_dot_prod_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n         return NULL;\n       stmt = last_stmt;\n \n-      if (widened_name_p (oprnd0, stmt, &half_type, &def_stmt, true))\n+      if (type_conversion_p (oprnd0, stmt, true, &half_type, &def_stmt,\n+                               &promotion)\n+         && promotion)\n         {\n           stmt = def_stmt;\n           oprnd0 = gimple_assign_rhs1 (stmt);\n@@ -334,10 +341,14 @@ vect_recog_dot_prod_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n       if (!types_compatible_p (TREE_TYPE (oprnd0), prod_type)\n           || !types_compatible_p (TREE_TYPE (oprnd1), prod_type))\n         return NULL;\n-      if (!widened_name_p (oprnd0, stmt, &half_type0, &def_stmt, true))\n+      if (!type_conversion_p (oprnd0, stmt, true, &half_type0, &def_stmt,\n+                                &promotion)\n+          || !promotion)\n         return NULL;\n       oprnd00 = gimple_assign_rhs1 (def_stmt);\n-      if (!widened_name_p (oprnd1, stmt, &half_type1, &def_stmt, true))\n+      if (!type_conversion_p (oprnd0, stmt, true, &half_type1, &def_stmt,\n+                                &promotion)\n+          || !promotion)\n         return NULL;\n       oprnd01 = gimple_assign_rhs1 (def_stmt);\n       if (!types_compatible_p (half_type0, half_type1))\n@@ -552,6 +563,7 @@ vect_recog_widen_mult_pattern (VEC (gimple, heap) **stmts,\n   int dummy_int;\n   VEC (tree, heap) *dummy_vec;\n   bool op1_ok;\n+  bool promotion;\n \n   if (!is_gimple_assign (last_stmt))\n     return NULL;\n@@ -571,12 +583,15 @@ vect_recog_widen_mult_pattern (VEC (gimple, heap) **stmts,\n     return NULL;\n \n   /* Check argument 0.  */\n-  if (!widened_name_p (oprnd0, last_stmt, &half_type0, &def_stmt0, false))\n-    return NULL;\n+  if (!type_conversion_p (oprnd0, last_stmt, false, &half_type0, &def_stmt0,\n+                         &promotion)\n+      || !promotion)\n+     return NULL;\n   /* Check argument 1.  */\n-  op1_ok = widened_name_p (oprnd1, last_stmt, &half_type1, &def_stmt1, false);\n+  op1_ok = type_conversion_p (oprnd1, last_stmt, false, &half_type1,\n+                              &def_stmt1, &promotion);\n \n-  if (op1_ok)\n+  if (op1_ok && promotion)\n     {\n       oprnd0 = gimple_assign_rhs1 (def_stmt0);\n       oprnd1 = gimple_assign_rhs1 (def_stmt1);\n@@ -816,6 +831,7 @@ vect_recog_widen_sum_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   struct loop *loop;\n   tree var;\n+  bool promotion;\n \n   if (!loop_info)\n     return NULL;\n@@ -855,8 +871,10 @@ vect_recog_widen_sum_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n      Left to check that oprnd0 is defined by a cast from type 'type' to type\n      'TYPE'.  */\n \n-  if (!widened_name_p (oprnd0, last_stmt, &half_type, &stmt, true))\n-    return NULL;\n+  if (!type_conversion_p (oprnd0, last_stmt, true, &half_type, &stmt,\n+                          &promotion)\n+      || !promotion)\n+     return NULL;\n \n   oprnd0 = gimple_assign_rhs1 (stmt);\n   *type_in = half_type;\n@@ -922,6 +940,7 @@ vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (vinfo_for_stmt (stmt));\n   bb_vec_info bb_info = STMT_VINFO_BB_VINFO (vinfo_for_stmt (stmt));\n   struct loop *loop = NULL;\n+  bool promotion;\n \n   if (loop_info)\n     loop = LOOP_VINFO_LOOP (loop_info);\n@@ -956,7 +975,9 @@ vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n   else\n     {\n       first = true;\n-      if (!widened_name_p (oprnd, stmt, &half_type, &def_stmt, false)\n+      if (!type_conversion_p (oprnd, stmt, false, &half_type, &def_stmt,\n+                               &promotion)\n+         || !promotion\n           || !gimple_bb (def_stmt)\n           || (loop && !flow_bb_inside_loop_p (loop, gimple_bb (def_stmt)))\n \t  || (!loop && gimple_bb (def_stmt) != BB_VINFO_BB (bb_info)\n@@ -1350,6 +1371,7 @@ vect_recog_widen_shift_pattern (VEC (gimple, heap) **stmts,\n   VEC (tree, heap) * dummy_vec;\n   gimple use_stmt = NULL;\n   bool over_widen = false;\n+  bool promotion;\n \n   if (!is_gimple_assign (last_stmt) || !vinfo_for_stmt (last_stmt))\n     return NULL;\n@@ -1404,8 +1426,10 @@ vect_recog_widen_shift_pattern (VEC (gimple, heap) **stmts,\n     return NULL;\n \n   /* Check operand 0: it has to be defined by a type promotion.  */\n-  if (!widened_name_p (oprnd0, last_stmt, &half_type0, &def_stmt0, false))\n-    return NULL;\n+  if (!type_conversion_p (oprnd0, last_stmt, false, &half_type0, &def_stmt0,\n+                          &promotion)\n+      || !promotion)\n+     return NULL;\n \n   /* Check operand 1: has to be positive.  We check that it fits the type\n      in vect_handle_widen_op_by_const ().  */\n@@ -1847,9 +1871,9 @@ vect_recog_sdivmod_pow2_pattern (VEC (gimple, heap) **stmts,\n      S1  a_T = x_t CMP y_t ? b_T : c_T;\n \n    where type 'TYPE' is an integral type which has different size\n-   from 'type'.  b_T and c_T are constants and if 'TYPE' is wider\n+   from 'type'.  b_T and c_T are either constants (and if 'TYPE' is wider\n    than 'type', the constants need to fit into an integer type\n-   with the same width as 'type'.\n+   with the same width as 'type') or results of conversion from 'type'.\n \n    Input:\n \n@@ -1874,11 +1898,15 @@ vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n   gimple last_stmt = VEC_index (gimple, *stmts, 0);\n   tree cond_expr, then_clause, else_clause;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt), def_stmt_info;\n-  tree type, vectype, comp_vectype, itype, vecitype;\n+  tree type, vectype, comp_vectype, itype = NULL_TREE, vecitype;\n   enum machine_mode cmpmode;\n   gimple pattern_stmt, def_stmt;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n+  tree orig_type0 = NULL_TREE, orig_type1 = NULL_TREE;\n+  gimple def_stmt0 = NULL, def_stmt1 = NULL;\n+  bool promotion;\n+  tree comp_scalar_type;\n \n   if (!is_gimple_assign (last_stmt)\n       || gimple_assign_rhs_code (last_stmt) != COND_EXPR\n@@ -1889,19 +1917,50 @@ vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n   then_clause = gimple_assign_rhs2 (last_stmt);\n   else_clause = gimple_assign_rhs3 (last_stmt);\n \n-  if (TREE_CODE (then_clause) != INTEGER_CST\n-      || TREE_CODE (else_clause) != INTEGER_CST)\n-    return NULL;\n-\n   if (!COMPARISON_CLASS_P (cond_expr))\n     return NULL;\n \n-  comp_vectype\n-    = get_vectype_for_scalar_type (TREE_TYPE (TREE_OPERAND (cond_expr, 0)));\n+  comp_scalar_type = TREE_TYPE (TREE_OPERAND (cond_expr, 0));\n+  comp_vectype = get_vectype_for_scalar_type (comp_scalar_type);\n   if (comp_vectype == NULL_TREE)\n     return NULL;\n \n   type = gimple_expr_type (last_stmt);\n+  if (types_compatible_p (type, comp_scalar_type)\n+      || ((TREE_CODE (then_clause) != INTEGER_CST\n+\t   || TREE_CODE (else_clause) != INTEGER_CST)\n+\t  && !INTEGRAL_TYPE_P (comp_scalar_type))\n+      || !INTEGRAL_TYPE_P (type))\n+    return NULL;\n+\n+  if ((TREE_CODE (then_clause) != INTEGER_CST\n+       && !type_conversion_p (then_clause, last_stmt, false, &orig_type0,\n+                              &def_stmt0, &promotion))\n+      || (TREE_CODE (else_clause) != INTEGER_CST\n+          && !type_conversion_p (else_clause, last_stmt, false, &orig_type1,\n+                                 &def_stmt1, &promotion)))\n+    return NULL;\n+\n+  if (orig_type0 && orig_type1\n+      && !types_compatible_p (orig_type0, orig_type1))\n+    return NULL;\n+\n+  if (orig_type0)\n+    {\n+      if (!types_compatible_p (orig_type0, comp_scalar_type))\n+\treturn NULL;\n+      then_clause = gimple_assign_rhs1 (def_stmt0);\n+      itype = orig_type0;\n+    }\n+\n+  if (orig_type1)\n+    {\n+      if (!types_compatible_p (orig_type1, comp_scalar_type))\n+\treturn NULL;\n+      else_clause = gimple_assign_rhs1 (def_stmt1);\n+      itype = orig_type1;\n+    }\n+\n   cmpmode = GET_MODE_INNER (TYPE_MODE (comp_vectype));\n \n   if (GET_MODE_BITSIZE (TYPE_MODE (type)) == GET_MODE_BITSIZE (cmpmode))\n@@ -1914,8 +1973,10 @@ vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n   if (expand_vec_cond_expr_p (vectype, comp_vectype))\n     return NULL;\n \n-  itype = build_nonstandard_integer_type (GET_MODE_BITSIZE (cmpmode),\n-\t\t\t\t\t  TYPE_UNSIGNED (type));\n+  if (itype == NULL_TREE)\n+    itype = build_nonstandard_integer_type (GET_MODE_BITSIZE (cmpmode),\n+  \t\t\t\t\t    TYPE_UNSIGNED (type));\n+\n   if (itype == NULL_TREE\n       || GET_MODE_BITSIZE (TYPE_MODE (itype)) != GET_MODE_BITSIZE (cmpmode))\n     return NULL;\n@@ -1929,8 +1990,10 @@ vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n \n   if (GET_MODE_BITSIZE (TYPE_MODE (type)) > GET_MODE_BITSIZE (cmpmode))\n     {\n-      if (!int_fits_type_p (then_clause, itype)\n-\t  || !int_fits_type_p (else_clause, itype))\n+      if ((TREE_CODE (then_clause) == INTEGER_CST\n+\t   && !int_fits_type_p (then_clause, itype))\n+\t  || (TREE_CODE (else_clause) == INTEGER_CST\n+\t      && !int_fits_type_p (else_clause, itype)))\n \treturn NULL;\n     }\n "}]}