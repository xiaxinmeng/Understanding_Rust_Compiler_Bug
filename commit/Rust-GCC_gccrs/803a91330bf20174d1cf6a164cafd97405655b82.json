{"sha": "803a91330bf20174d1cf6a164cafd97405655b82", "node_id": "C_kwDOANBUbNoAKDgwM2E5MTMzMGJmMjAxNzRkMWNmNmExNjRjYWZkOTc0MDU2NTViODI", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-12-13T23:33:06Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-12-13T23:58:18Z"}, "message": "ipa-sra: Move caller->callee propagation before callee->caller one\n\nThis patch does not do any functional changes, it merely moves\ntop-down propagation in the IPA-SRA WPA phase before bottom-up one.\nThis also meant moving some preliminary checks from the latter to the\nformer - where they need to be in their own loop over each SCC because\nthe subsequent one looks at callers.\n\nCurrently the propagations are independent (top-down is used for\nreturn value rermoval, bottom-up for parameter removal and splitting)\nbut subsequent patches will introduce flags about parameters which\nshould be propagated from callers first and used in splitting.  I\nseparated this change to test ir independently and make those\nsubsequent patches cleaner.\n\nWhile at it, I also replaced couple of FOR_EACH_VEC_ELT macros with\nC++11 style iteration.\n\ngcc/ChangeLog:\n\n2022-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-sra.cc (ipa_sra_analysis): Move top-down analysis before\n\tbottom-up analysis.  Replace FOR_EACH_VEC_ELT with C++11 iteration.\n\ngcc/testsuite/ChangeLog:\n\n2021-12-14  Martin Jambor  <mjambor@suse.cz>\n\n\t* gcc.dg/ipa/ipa-sra-25.c: New test", "tree": {"sha": "f2f10edbe80cf912a263b00ecf6e40a285785fe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2f10edbe80cf912a263b00ecf6e40a285785fe6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/803a91330bf20174d1cf6a164cafd97405655b82", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmOZEZoACgkQv2PBvD+k\nNUBiJw//Rs8IYQvirPXupzlxIy5QqTeohmZswk6Nccw8qROEY36FSg28jsa5ELqN\noIuAn8fVZrajWPUycCQSu67WpefupLpZJDYDJsMygPsfuC4VSyWMg3AGWkr303uk\nvz/hbH0JICWCzLVAVcyU3YimGQfVf2ZrWEQ6nn8F6L4nVmWIMIhkk89b7UrVnOXE\nIWjdpxydEyte7vAwKbgSephdzepQeoX5jCK1iHBZpwqKSDA3A1demrQQXfqn2IIY\nwdWTxZveTnburvJvcPS14ovW9V1YlXuCBCgw/2NQTERw2udpD4gfyn1E9rioonrS\ngSGaP5+3nWGDBrP2pIOMlg0HHc6rBKppucdE1+EDIYhqASTTX7Jj+0E+jGyXn/g3\n77vkFp/OLVKgxToarHZXNVmAGrUiW368pGompHsy6LVDhyUld4fH1WgVkKcqFG9a\nMBJuBC4tKZrzAcMYBzLtPC0k3veL+ui0oqdPEkOCvkhdZnygJbQcVH3DxPtowWb0\nCtr1Imc5IcfvgwVl+R3wacoRkr56ysDZ0fwL3Cz58EeldxPah3QikY9YPE2hSKuX\nQa5GKqqYCMyu6mSJ64XvjoczK11j6ZKmM5SD9aWY0Gek+RUPeU8TBW7HMr2kvcqK\nogPmYmg+uY7Crx552Ut+TtWafk6/H4gTifLOnDV3sUhnX9EaDAw=\n=6NRs\n-----END PGP SIGNATURE-----", "payload": "tree f2f10edbe80cf912a263b00ecf6e40a285785fe6\nparent 10478270fe0c39c59eb0f35d19356a63bdf3a2ad\nauthor Martin Jambor <mjambor@suse.cz> 1670974386 +0100\ncommitter Martin Jambor <mjambor@suse.cz> 1670975898 +0100\n\nipa-sra: Move caller->callee propagation before callee->caller one\n\nThis patch does not do any functional changes, it merely moves\ntop-down propagation in the IPA-SRA WPA phase before bottom-up one.\nThis also meant moving some preliminary checks from the latter to the\nformer - where they need to be in their own loop over each SCC because\nthe subsequent one looks at callers.\n\nCurrently the propagations are independent (top-down is used for\nreturn value rermoval, bottom-up for parameter removal and splitting)\nbut subsequent patches will introduce flags about parameters which\nshould be propagated from callers first and used in splitting.  I\nseparated this change to test ir independently and make those\nsubsequent patches cleaner.\n\nWhile at it, I also replaced couple of FOR_EACH_VEC_ELT macros with\nC++11 style iteration.\n\ngcc/ChangeLog:\n\n2022-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-sra.cc (ipa_sra_analysis): Move top-down analysis before\n\tbottom-up analysis.  Replace FOR_EACH_VEC_ELT with C++11 iteration.\n\ngcc/testsuite/ChangeLog:\n\n2021-12-14  Martin Jambor  <mjambor@suse.cz>\n\n\t* gcc.dg/ipa/ipa-sra-25.c: New test\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/803a91330bf20174d1cf6a164cafd97405655b82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/803a91330bf20174d1cf6a164cafd97405655b82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/803a91330bf20174d1cf6a164cafd97405655b82/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10478270fe0c39c59eb0f35d19356a63bdf3a2ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10478270fe0c39c59eb0f35d19356a63bdf3a2ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10478270fe0c39c59eb0f35d19356a63bdf3a2ad"}], "stats": {"total": 140, "additions": 78, "deletions": 62}, "files": [{"sha": "65d6417a35d872b0c20afe3115fd79c5da5f6db6", "filename": "gcc/ipa-sra.cc", "status": "modified", "additions": 61, "deletions": 62, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/803a91330bf20174d1cf6a164cafd97405655b82/gcc%2Fipa-sra.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/803a91330bf20174d1cf6a164cafd97405655b82/gcc%2Fipa-sra.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.cc?ref=803a91330bf20174d1cf6a164cafd97405655b82", "patch": "@@ -3926,27 +3926,74 @@ ipa_sra_analysis (void)\n   auto_vec <cgraph_node *, 16> stack;\n   int node_scc_count = ipa_reduced_postorder (order, true, NULL);\n \n-  /* One sweep from callees to callers for parameter removal and splitting.  */\n-  for (int i = 0; i < node_scc_count; i++)\n+  /* One sweep from callers to callees for return value removal.  */\n+  for (int i = node_scc_count - 1; i >= 0 ; i--)\n     {\n       cgraph_node *scc_rep = order[i];\n       vec<cgraph_node *> cycle_nodes = ipa_get_nodes_in_cycle (scc_rep);\n-      unsigned j;\n \n-      /* Preliminary IPA function level checks and first step of parameter\n-\t removal.  */\n-      cgraph_node *v;\n-      FOR_EACH_VEC_ELT (cycle_nodes, j, v)\n+      /* Preliminary IPA function level checks.  */\n+      for (cgraph_node *v : cycle_nodes)\n \t{\n \t  isra_func_summary *ifs = func_sums->get (v);\n \t  if (!ifs || !ifs->m_candidate)\n \t    continue;\n \t  if (!ipa_sra_ipa_function_checks (v)\n \t      || check_all_callers_for_issues (v))\n-\t    {\n-\t      ifs->zap ();\n-\t      continue;\n-\t    }\n+\t    ifs->zap ();\n+\t}\n+\n+      for (cgraph_node *v : cycle_nodes)\n+\t{\n+\t  isra_func_summary *ifs = func_sums->get (v);\n+\t  if (!ifs || !ifs->m_candidate)\n+\t    continue;\n+\t  bool return_needed\n+\t    = (ifs->m_returns_value\n+\t       && (!dbg_cnt (ipa_sra_retvalues)\n+\t\t   || v->call_for_symbol_and_aliases (retval_used_p,\n+\t\t\t\t\t\t      NULL, true)));\n+\t  ifs->m_return_ignored = !return_needed;\n+\t  if (return_needed)\n+\t    isra_push_node_to_stack (v, ifs, &stack);\n+\t}\n+\n+      while (!stack.is_empty ())\n+\t{\n+\t  cgraph_node *node = stack.pop ();\n+\t  isra_func_summary *ifs = func_sums->get (node);\n+\t  gcc_checking_assert (ifs && ifs->m_queued);\n+\t  ifs->m_queued = false;\n+\n+\t  for (cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n+\t    if (ipa_edge_within_scc (cs)\n+\t\t&& call_sums->get (cs)->m_return_returned)\n+\t      {\n+\t\tenum availability av;\n+\t\tcgraph_node *callee = cs->callee->function_symbol (&av);\n+\t\tisra_func_summary *to_ifs = func_sums->get (callee);\n+\t\tif (to_ifs && to_ifs->m_return_ignored)\n+\t\t  {\n+\t\t    to_ifs->m_return_ignored = false;\n+\t\t    isra_push_node_to_stack (callee, to_ifs, &stack);\n+\t\t  }\n+\t      }\n+\t}\n+      cycle_nodes.release ();\n+    }\n+\n+  /* One sweep from callees to callers for parameter removal and splitting.  */\n+  for (int i = 0; i < node_scc_count; i++)\n+    {\n+      cgraph_node *scc_rep = order[i];\n+      vec<cgraph_node *> cycle_nodes = ipa_get_nodes_in_cycle (scc_rep);\n+\n+      /* First step of parameter removal.  */\n+      for (cgraph_node *v : cycle_nodes)\n+\t{\n+\t  isra_func_summary *ifs = func_sums->get (v);\n+\t  if (!ifs || !ifs->m_candidate)\n+\t    continue;\n \t  if (disable_unavailable_parameters (v, ifs))\n \t    continue;\n \t  for (cgraph_edge *cs = v->indirect_calls; cs; cs = cs->next_callee)\n@@ -3959,7 +4006,7 @@ ipa_sra_analysis (void)\n       /* Look at edges within the current SCC and propagate used-ness across\n \t them, pushing onto the stack all notes which might need to be\n \t revisited.  */\n-      FOR_EACH_VEC_ELT (cycle_nodes, j, v)\n+      for (cgraph_node *v : cycle_nodes)\n \tv->call_for_symbol_thunks_and_aliases (propagate_used_to_scc_callers,\n \t\t\t\t\t       &stack, true);\n \n@@ -3980,7 +4027,7 @@ ipa_sra_analysis (void)\n       do\n \t{\n \t  repeat_scc_access_propagation = false;\n-\t  FOR_EACH_VEC_ELT (cycle_nodes, j, v)\n+\t  for (cgraph_node *v : cycle_nodes)\n \t    {\n \t      isra_func_summary *ifs = func_sums->get (v);\n \t      if (!ifs\n@@ -3995,60 +4042,12 @@ ipa_sra_analysis (void)\n       while (repeat_scc_access_propagation);\n \n       if (flag_checking)\n-\tFOR_EACH_VEC_ELT (cycle_nodes, j, v)\n+\tfor (cgraph_node *v : cycle_nodes)\n \t  verify_splitting_accesses (v, true);\n \n       cycle_nodes.release ();\n     }\n \n-  /* One sweep from caller to callees for result removal.  */\n-  for (int i = node_scc_count - 1; i >= 0 ; i--)\n-    {\n-      cgraph_node *scc_rep = order[i];\n-      vec<cgraph_node *> cycle_nodes = ipa_get_nodes_in_cycle (scc_rep);\n-      unsigned j;\n-\n-      cgraph_node *v;\n-      FOR_EACH_VEC_ELT (cycle_nodes, j, v)\n-\t{\n-\t  isra_func_summary *ifs = func_sums->get (v);\n-\t  if (!ifs || !ifs->m_candidate)\n-\t    continue;\n-\n-\t  bool return_needed\n-\t    = (ifs->m_returns_value\n-\t       && (!dbg_cnt (ipa_sra_retvalues)\n-\t\t   || v->call_for_symbol_and_aliases (retval_used_p,\n-\t\t\t\t\t\t      NULL, true)));\n-\t  ifs->m_return_ignored = !return_needed;\n-\t  if (return_needed)\n-\t    isra_push_node_to_stack (v, ifs, &stack);\n-\t}\n-\n-      while (!stack.is_empty ())\n-\t{\n-\t  cgraph_node *node = stack.pop ();\n-\t  isra_func_summary *ifs = func_sums->get (node);\n-\t  gcc_checking_assert (ifs && ifs->m_queued);\n-\t  ifs->m_queued = false;\n-\n-\t  for (cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n-\t    if (ipa_edge_within_scc (cs)\n-\t\t&& call_sums->get (cs)->m_return_returned)\n-\t      {\n-\t\tenum availability av;\n-\t\tcgraph_node *callee = cs->callee->function_symbol (&av);\n-\t\tisra_func_summary *to_ifs = func_sums->get (callee);\n-\t\tif (to_ifs && to_ifs->m_return_ignored)\n-\t\t  {\n-\t\t    to_ifs->m_return_ignored = false;\n-\t\t    isra_push_node_to_stack (callee, to_ifs, &stack);\n-\t\t  }\n-\t      }\n-\t}\n-      cycle_nodes.release ();\n-    }\n-\n   ipa_free_postorder_info ();\n   free (order);\n "}, {"sha": "46fc1a5457180fbdc3ea924635f8a0d46ad71996", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-25.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/803a91330bf20174d1cf6a164cafd97405655b82/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/803a91330bf20174d1cf6a164cafd97405655b82/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-25.c?ref=803a91330bf20174d1cf6a164cafd97405655b82", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wmaybe-uninitialized -Werror\"  } */\n+\n+int cbos();\n+static int aos() {\n+  cbos();\n+  return 0;\n+}\n+int cbos_ptr;\n+long cbos_psize;\n+int cbos() {\n+  if (cbos_ptr)\n+    return aos();\n+  if (cbos_psize)\n+    return 1;\n+  return 0;\n+}"}]}