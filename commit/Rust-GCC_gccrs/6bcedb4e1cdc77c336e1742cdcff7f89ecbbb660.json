{"sha": "6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJjZWRiNGUxY2RjNzdjMzM2ZTE3NDJjZGNmZjdmODllY2JiYjY2MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-10-18T18:59:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-10-18T18:59:04Z"}, "message": "c-common.h (flag_no_builtin): Declare.\n\n\t* c-common.h (flag_no_builtin): Declare.\n\t(flag_no_nonansi_builtin): Likewise.\n\t(c_common_nodes_and_builtins): Change prototype.\n\t* c-common.c (flag_no_builtin): New variable.\n\t(flag_no_nonansi_builtin): Likewise.\n\t(c_common_nodes_and_builtins): Remove parameters.  Adjust\n\taccordingly.\n\t* c-decl.c (flag_no_builtin): Remove.\n\t(flag_no_nonansi_builtin): Likewise.\n\t(init_decl_processing): Adjust call to\n\tc_common_nodes_and_builtins.\n\n\t* cp-tree.h (cp_tree_index): Add CPTI_FAKE_STD.\n\t(fake_std_node): New macro.\n\t* decl.c (in_std): Rename to ...\n\t(in_fake_std): ... this.\n\t(flag_no_builtin): Remove.\n\t(flag_no_nonansi_builtin): Likewise.\n\t(walk_namespaces_r): Use fake_std_node.\n\t(push_namespace): Use std_identifier.\n\t(pop_namespace): Use in_fake_std.\n\t(lookup_name_real): Use fake_std_node.\n\t(init_decl_processing): When -fhonor-std, create the `std'\n\tnamespace.  Don't create a dummy fake_std_node in that case.\n\tAdjust call to c_common_nodes_and_builtins.  Use std_identifier.\n\t(builtin_function): Put builtins whose names don't begin\n\twith `_' in the std namespace.\n\t* decl2.c (flag_no_builtin): Remove.\n\t(flag_no_nonansi_builtin): Likewise.\n\t(set_decl_namespace): Use fake_std_node.\n\t(validate_nonmember_using_decl): Likewise.\n\t(do_using_directive): Likewise.\n\t(handle_class_head): Likewise.\n\t* dump.c (dequeue_and_dump): Likewise.\n\t* except.c (init_exception_processing): Use std_identifier.\n\t* init.c (build_member_call): Use fake_std_node.\n\t* rtti.c (init_rtti_processing): Use std_identifier.\n\nFrom-SVN: r36940", "tree": {"sha": "549802a7ccf67eda822a46929952ac0b0725f86e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/549802a7ccf67eda822a46929952ac0b0725f86e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/comments", "author": null, "committer": null, "parents": [{"sha": "989b26a751281908472e10913d6187dbb8dae7a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/989b26a751281908472e10913d6187dbb8dae7a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/989b26a751281908472e10913d6187dbb8dae7a9"}], "stats": {"total": 218, "additions": 135, "deletions": 83}, "files": [{"sha": "88c5ee601953233fe30f9e1b17ca541aab156734", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "patch": "@@ -1,3 +1,17 @@\n+2000-10-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* c-common.h (flag_no_builtin): Declare.\n+\t(flag_no_nonansi_builtin): Likewise.\n+\t(c_common_nodes_and_builtins): Change prototype.\n+\t* c-common.c (flag_no_builtin): New variable.\n+\t(flag_no_nonansi_builtin): Likewise.\n+\t(c_common_nodes_and_builtins): Remove parameters.  Adjust\n+\taccordingly.\n+\t* c-decl.c (flag_no_builtin): Remove.\n+\t(flag_no_nonansi_builtin): Likewise.\n+\t(init_decl_processing): Adjust call to\n+\tc_common_nodes_and_builtins.\n+\t\n 2000-10-18  Marc Espie <espie@openbsd.org>\n \n \t* tm.texi (LIBGCC_SPEC): Synch with reality."}, {"sha": "086177f5860f16ca563bddcd8fe47374a898862c", "filename": "gcc/c-common.c", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "patch": "@@ -140,6 +140,15 @@ cpp_reader  parse_in;\n \n tree c_global_trees[CTI_MAX];\n \n+/* Nonzero means don't recognize the non-ANSI builtin functions.  */\n+\n+int flag_no_builtin;\n+\n+/* Nonzero means don't recognize the non-ANSI builtin functions.\n+   -ansi sets this.  */\n+\n+int flag_no_nonansi_builtin;\n+\n /* Nonzero means warn about possible violations of sequence point rules.  */\n \n int warn_sequence_point;\n@@ -4767,16 +4776,10 @@ lang_get_alias_set (t)\n }\n \n /* Build tree nodes and builtin functions common to both C and C++ language\n-   frontends.\n-   CPLUS_MODE is nonzero if we are called from the C++ frontend, we generate\n-   some stricter prototypes in that case.\n-   NO_BUILTINS and NO_NONANSI_BUILTINS contain the respective values of\n-   the language frontend flags flag_no_builtin and\n-   flag_no_nonansi_builtin.  */\n+   frontends.  */\n \n void\n-c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n-    int cplus_mode, no_builtins, no_nonansi_builtins;\n+c_common_nodes_and_builtins ()\n {\n   tree temp;\n   tree memcpy_ftype, memset_ftype, strlen_ftype;\n@@ -4889,7 +4892,8 @@ c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n \t\t\t\t\t\t const_string_type_node,\n \t\t\t\t\t\t endlink)));\n \n-  traditional_len_type_node = (flag_traditional && ! cplus_mode\n+  traditional_len_type_node = ((flag_traditional && \n+\t\t\t\tc_language != clk_cplusplus)\n \t\t\t       ? integer_type_node : sizetype);\n   traditional_len_endlink = tree_cons (NULL_TREE, traditional_len_type_node,\n \t\t\t\t       endlink);\n@@ -4908,9 +4912,11 @@ c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n \t\t\t   tree_cons (NULL_TREE, const_string_type_node,\n \t\t\t\t      endlink));\n \n-  traditional_ptr_type_node = (flag_traditional && ! cplus_mode\n+  traditional_ptr_type_node = ((flag_traditional && \n+\t\t\t\tc_language != clk_cplusplus)\n \t\t\t       ? string_type_node : ptr_type_node);\n-  traditional_cptr_type_node = (flag_traditional && ! cplus_mode\n+  traditional_cptr_type_node = ((flag_traditional && \n+\t\t\t\t c_language != clk_cplusplus)\n \t\t\t       ? const_string_type_node : const_ptr_type_node);\n \n   /* Prototype for memcpy.  */\n@@ -4970,7 +4976,7 @@ c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n \t\t    BUILT_IN_NORMAL, NULL_PTR);\n   /* Define alloca, ffs as builtins.\n      Declare _exit just to mark it as volatile.  */\n-  if (! no_builtins && ! no_nonansi_builtins)\n+  if (! flag_no_builtin && ! flag_no_nonansi_builtin)\n     {\n #ifndef SMALL_STACK\n       temp = builtin_function (\"alloca\", ptr_ftype_sizetype,\n@@ -5166,7 +5172,7 @@ c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n     builtin_function (\"__builtin_fputs\", int_ftype_any,\n \t\t      BUILT_IN_FPUTS, BUILT_IN_NORMAL, \"fputs\");\n \n-  if (! no_builtins)\n+  if (! flag_no_builtin)\n     {\n       builtin_function (\"abs\", int_ftype_int, BUILT_IN_ABS,\n \t\t\tBUILT_IN_NORMAL, NULL_PTR);\n@@ -5178,7 +5184,7 @@ c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n \t\t\tBUILT_IN_NORMAL, NULL_PTR);\n       builtin_function (\"labs\", long_ftype_long, BUILT_IN_LABS,\n \t\t\tBUILT_IN_NORMAL, NULL_PTR);\n-      if (flag_isoc99 || ! no_nonansi_builtins)\n+      if (flag_isoc99 || ! flag_no_nonansi_builtin)\n \tbuiltin_function (\"llabs\", longlong_ftype_longlong, BUILT_IN_LLABS,\n \t\t\t  BUILT_IN_NORMAL, NULL_PTR);\n       builtin_function (\"memcpy\", memcpy_ftype, BUILT_IN_MEMCPY,\n@@ -5225,27 +5231,19 @@ c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n \n       /* Declare these functions volatile\n \t to avoid spurious \"control drops through\" warnings.  */\n-      temp = builtin_function (\"abort\", cplus_mode ? void_ftype : void_ftype_any,\n+      temp = builtin_function (\"abort\", \n+\t\t\t       ((c_language == clk_cplusplus)\n+\t\t\t\t? void_ftype : void_ftype_any),\n \t\t\t       0, NOT_BUILT_IN, NULL_PTR);\n       TREE_THIS_VOLATILE (temp) = 1;\n       TREE_SIDE_EFFECTS (temp) = 1;\n \n-#if 0 /* ??? The C++ frontend used to do this.  */\n-      /* Well, these are actually ANSI, but we can't set DECL_BUILT_IN on\n-\t them...  */\n-      DECL_BUILT_IN_NONANSI (temp) = 1;\n-#endif\n       temp = builtin_function (\"exit\",\n-\t\t\t       cplus_mode ? void_ftype_int : void_ftype_any,\n+\t\t\t       ((c_language == clk_cplusplus)\n+\t\t\t\t? void_ftype_int : void_ftype_any),\n \t\t\t       0, NOT_BUILT_IN, NULL_PTR);\n       TREE_THIS_VOLATILE (temp) = 1;\n       TREE_SIDE_EFFECTS (temp) = 1;\n-\n-#if 0 /* ??? The C++ frontend used to do this.  */\n-      /* Well, these are actually ANSI, but we can't set DECL_BUILT_IN on\n-\t them...  */\n-      DECL_BUILT_IN_NONANSI (temp) = 1;\n-#endif\n     }\n \n #if 0"}, {"sha": "1776bad1b71bb11ad758cc6350bc38c790f40942", "filename": "gcc/c-common.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "patch": "@@ -370,6 +370,15 @@ extern int flag_hosted;\n \n extern int flag_noniso_default_format_attributes;\n \n+/* Nonzero means don't recognize any builtin functions.  */\n+\n+extern int flag_no_builtin;\n+\n+/* Nonzero means don't recognize the non-ANSI builtin functions.\n+   -ansi sets this.  */\n+\n+extern int flag_no_nonansi_builtin;\n+\n /* Nonzero means warn about suggesting putting in ()'s.  */\n \n extern int warn_parentheses;\n@@ -454,7 +463,7 @@ extern tree c_build_qualified_type              PARAMS ((tree, int));\n \n /* Build tree nodes and builtin functions common to both C and C++ language\n    frontends.  */\n-extern void c_common_nodes_and_builtins\t\tPARAMS ((int, int, int));\n+extern void c_common_nodes_and_builtins\t\tPARAMS ((void));\n \n extern tree build_va_arg\t\t\tPARAMS ((tree, tree));\n "}, {"sha": "8621e8a8c288782c8a9eb623970108ea36bf3eb3", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "patch": "@@ -343,15 +343,6 @@ int flag_short_wchar;\n \n int flag_no_asm;\n \n-/* Nonzero means don't recognize any builtin functions.  */\n-\n-int flag_no_builtin;\n-\n-/* Nonzero means don't recognize the non-ANSI builtin functions.\n-   -ansi sets this.  */\n-\n-int flag_no_nonansi_builtin;\n-\n /* Nonzero means do some things the same way PCC does.  */\n \n int flag_traditional;\n@@ -3144,7 +3135,7 @@ init_decl_processing ()\n     = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (PTRDIFF_TYPE)));\n   unsigned_ptrdiff_type_node = unsigned_type (ptrdiff_type_node);\n \n-  c_common_nodes_and_builtins (0, flag_no_builtin, flag_no_nonansi_builtin);\n+  c_common_nodes_and_builtins ();\n \n   endlink = void_list_node;\n   ptr_ftype_void = build_function_type (ptr_type_node, endlink);"}, {"sha": "f0fbee8d94536805fdb955a6d13f2c82ad9a92e6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "patch": "@@ -1,3 +1,31 @@\n+2000-10-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (cp_tree_index): Add CPTI_FAKE_STD.\n+\t(fake_std_node): New macro.\n+\t* decl.c (in_std): Rename to ...\n+\t(in_fake_std): ... this.\n+\t(flag_no_builtin): Remove.\n+\t(flag_no_nonansi_builtin): Likewise.\n+\t(walk_namespaces_r): Use fake_std_node.\n+\t(push_namespace): Use std_identifier.\n+\t(pop_namespace): Use in_fake_std.\n+\t(lookup_name_real): Use fake_std_node.\n+\t(init_decl_processing): When -fhonor-std, create the `std'\n+\tnamespace.  Don't create a dummy fake_std_node in that case.\n+\tAdjust call to c_common_nodes_and_builtins.  Use std_identifier.\n+\t(builtin_function): Put builtins whose names don't begin\n+\twith `_' in the std namespace.\n+\t* decl2.c (flag_no_builtin): Remove.\n+\t(flag_no_nonansi_builtin): Likewise.\n+\t(set_decl_namespace): Use fake_std_node.\n+\t(validate_nonmember_using_decl): Likewise.\n+\t(do_using_directive): Likewise.\n+\t(handle_class_head): Likewise.\n+\t* dump.c (dequeue_and_dump): Likewise.\n+\t* except.c (init_exception_processing): Use std_identifier.\n+\t* init.c (build_member_call): Use fake_std_node.\n+\t* rtti.c (init_rtti_processing): Use std_identifier.\n+\t \n 2000-10-17  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (back_end_hook): Remove declaration."}, {"sha": "ed25a8fc10e29bd10bb357d7c556eeeeed557f47", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "patch": "@@ -586,6 +586,7 @@ enum cp_tree_index\n     CPTI_VTBL_TYPE,\n     CPTI_VTBL_PTR_TYPE,\n     CPTI_STD,\n+    CPTI_FAKE_STD,\n     CPTI_ABI,\n     CPTI_TYPE_INFO_TYPE,\n     CPTI_TINFO_DECL_ID,\n@@ -679,7 +680,14 @@ extern tree cp_global_trees[CPTI_MAX];\n #define unknown_type_node\t\tcp_global_trees[CPTI_UNKNOWN_TYPE]\n #define vtbl_type_node\t\t\tcp_global_trees[CPTI_VTBL_TYPE]\n #define vtbl_ptr_type_node\t\tcp_global_trees[CPTI_VTBL_PTR_TYPE]\n+/* When the `std' namespace is a real namespace, this is the\n+   corresponding NAMESPACE_DECL.  When the `std' namespace is an alias\n+   for the global namespace, this is NULL_TREE.  */\n #define std_node\t\t\tcp_global_trees[CPTI_STD]\n+/* When the `std' namespace is a real namespace, this is the\n+   ERROR_MARK_NODE.  Otherwise, this is a dummy NAMESPACE_DECL that\n+   should be treated like the global namespace.  */\n+#define fake_std_node                   cp_global_trees[CPTI_FAKE_STD]\n #define abi_node                        cp_global_trees[CPTI_ABI]\n #define type_info_type_node\t\tcp_global_trees[CPTI_TYPE_INFO_TYPE]\n #define tinfo_decl_id\t\t\tcp_global_trees[CPTI_TINFO_DECL_ID]\n@@ -744,7 +752,6 @@ extern tree cp_global_trees[CPTI_MAX];\n #define cp_push_exception_identifier    cp_global_trees[CPTI_PUSH_EXCEPTION_IDENTIFIER]\n /* The name of the std namespace.  */\n #define std_identifier                  cp_global_trees[CPTI_STD_IDENTIFIER]\n-\n #define lang_name_c                     cp_global_trees[CPTI_LANG_NAME_C]\n #define lang_name_cplusplus             cp_global_trees[CPTI_LANG_NAME_CPLUSPLUS]\n #define lang_name_java                  cp_global_trees[CPTI_LANG_NAME_JAVA]"}, {"sha": "ee4571c94e840b09c45c86378419b700b79fa96d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "patch": "@@ -267,8 +267,10 @@ tree cp_global_trees[CPTI_MAX];\n \n static tree global_type_node;\n \n-/* Namespace std.  */\n-int in_std;\n+/* If non-zero, this is the number of times we have entered the `std'\n+   namespace when we are treating that namespace as an alias for the\n+   global namespace.  */\n+static int in_fake_std;\n \n /* Expect only namespace names now. */\n static int only_namespace_names;\n@@ -354,15 +356,6 @@ int flag_noniso_default_format_attributes = 1;\n \n extern int flag_short_double;\n \n-/* Nonzero means don't recognize any builtin functions.  */\n-\n-extern int flag_no_builtin;\n-\n-/* Nonzero means don't recognize the non-ANSI builtin functions.\n-   -ansi sets this.  */\n-\n-extern int flag_no_nonansi_builtin;\n-\n /* Nonzero if we want to conserve space in the .o files.  We do this\n    by putting uninitialized data and runtime initialized data into\n    .common instead of .data at the expense of not flagging multiple\n@@ -1829,7 +1822,7 @@ walk_namespaces_r (namespace, f, data)\n       if (!DECL_LANG_SPECIFIC (current))\n \t{\n \t  /* Hmm. std. */\n-\t  my_friendly_assert (current == std_node, 393);\n+\t  my_friendly_assert (current == fake_std_node, 393);\n \t  continue;\n \t}\n \n@@ -2324,9 +2317,10 @@ push_namespace (name)\n       implicit_use = 1;\n     }\n   else if (current_namespace == global_namespace\n-\t   && name == DECL_NAME (std_node))\n+\t   && !flag_honor_std\n+\t   && name == std_identifier)\n     {\n-      in_std++;\n+      in_fake_std++;\n       return;\n     }\n   else\n@@ -2376,8 +2370,8 @@ pop_namespace ()\n {\n   if (current_namespace == global_namespace)\n     {\n-      my_friendly_assert (in_std>0, 980421);\n-      in_std--;\n+      my_friendly_assert (in_fake_std > 0, 980421);\n+      in_fake_std--;\n       return;\n     }\n   current_namespace = CP_DECL_CONTEXT (current_namespace);\n@@ -5888,7 +5882,7 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n         flags |= LOOKUP_TEMPLATES_EXPECTED;\n \n       /* std:: becomes :: for now.  */\n-      if (got_scope == std_node)\n+      if (got_scope && got_scope == fake_std_node)\n \tgot_scope = void_type_node;\n \n       if (got_scope)\n@@ -6364,6 +6358,22 @@ init_decl_processing ()\n   NAMESPACE_LEVEL (global_namespace) = global_binding_level;\n   declare_namespace_level ();\n \n+  /* Create the `std' namespace.  */\n+  if (flag_honor_std)\n+    {\n+      push_namespace (std_identifier);\n+      std_node = current_namespace;\n+      pop_namespace ();\n+      fake_std_node = error_mark_node;\n+    }\n+  else\n+    {\n+      fake_std_node = build_decl (NAMESPACE_DECL,\n+\t\t\t\t  std_identifier,\n+\t\t\t\t  void_type_node);\n+      pushdecl (fake_std_node);\n+    }\n+  \n   /* Define `int' and `char' first so that dbx will output them first.  */\n   record_builtin_type (RID_INT, NULL_PTR, integer_type_node);\n   record_builtin_type (RID_CHAR, \"char\", char_type_node);\n@@ -6519,7 +6529,7 @@ init_decl_processing ()\n     = build_pointer_type (build_qualified_type (void_type_node,\n \t\t\t\t\t\tTYPE_QUAL_CONST));\n   vtt_parm_type = build_pointer_type (const_ptr_type_node);\n-  c_common_nodes_and_builtins (1, flag_no_builtin, flag_no_nonansi_builtin);\n+  c_common_nodes_and_builtins ();\n   lang_type_promotes_to = convert_type_from_ellipsis;\n \n   void_ftype_ptr\n@@ -6615,12 +6625,6 @@ init_decl_processing ()\n   layout_type (vtbl_ptr_type_node);\n   record_builtin_type (RID_MAX, NULL_PTR, vtbl_ptr_type_node);\n \n-  std_node = build_decl (NAMESPACE_DECL,\n-\t\t\t flag_honor_std \n-\t\t\t ? get_identifier (\"fake std\") : std_identifier,\n-\t\t\t void_type_node);\n-  pushdecl (std_node);\n-  \n   if (flag_new_abi)\n     {\n       push_namespace (get_identifier (\"__cxxabiv1\"));\n@@ -6637,7 +6641,7 @@ init_decl_processing ()\n   {\n     tree bad_alloc_type_node, newtype, deltype;\n     if (flag_honor_std)\n-      push_namespace (get_identifier (\"std\"));\n+      push_namespace (std_identifier);\n     bad_alloc_type_node = xref_tag\n       (class_type_node, get_identifier (\"bad_alloc\"), 1);\n     if (flag_honor_std)\n@@ -6801,10 +6805,20 @@ builtin_function (name, type, code, class, libname)\n \n   my_friendly_assert (DECL_CONTEXT (decl) == NULL_TREE, 392);\n \n+  /* All builtins that don't begin with an `_' should go in the `std'\n+     namespace.  */\n+  if (flag_honor_std && name[0] != '_') \n+    {\n+      push_namespace (std_identifier);\n+      DECL_CONTEXT (decl) = std_node;\n+    }\n+  pushdecl (decl);\n+  if (flag_honor_std && name[0] != '_')\n+    pop_namespace ();\n+\n   /* Since `pushdecl' relies on DECL_ASSEMBLER_NAME instead of DECL_NAME,\n      we cannot change DECL_ASSEMBLER_NAME until we have installed this\n      function in the namespace.  */\n-  pushdecl (decl);\n   if (libname)\n     DECL_ASSEMBLER_NAME (decl) = get_identifier (libname);\n   make_function_rtl (decl);"}, {"sha": "9c61e559f130caf84dac7a5bb18a4aa6e07490d2", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "patch": "@@ -159,15 +159,6 @@ int flag_no_asm;\n \n int flag_no_gnu_keywords;\n \n-/* Nonzero means don't recognize the non-ANSI builtin functions.  */\n-\n-int flag_no_builtin;\n-\n-/* Nonzero means don't recognize the non-ANSI builtin functions.\n-   -ansi sets this.  */\n-\n-int flag_no_nonansi_builtin;\n-\n /* Nonzero means do some things the same way PCC does.  Only provided so\n    the compiler will link.  */\n \n@@ -4600,7 +4591,7 @@ set_decl_namespace (decl, scope, friendp)\n      int friendp;\n {\n   tree old;\n-  if (scope == std_node)\n+  if (scope == fake_std_node)\n     scope = global_namespace;\n   /* Get rid of namespace aliases. */\n   scope = ORIGINAL_NAMESPACE (scope);\n@@ -5107,7 +5098,7 @@ validate_nonmember_using_decl (decl, scope, name)\n      tree *name;\n {\n   if (TREE_CODE (decl) == SCOPE_REF\n-      && TREE_OPERAND (decl, 0) == std_node)\n+      && TREE_OPERAND (decl, 0) == fake_std_node)\n     {\n       if (namespace_bindings_p ()\n \t  && current_namespace == global_namespace)\n@@ -5353,7 +5344,7 @@ void\n do_using_directive (namespace)\n      tree namespace;\n {\n-  if (namespace == std_node)\n+  if (namespace == fake_std_node)\n     return;\n   /* using namespace A::B::C; */\n   if (TREE_CODE (namespace) == SCOPE_REF)\n@@ -5452,7 +5443,7 @@ handle_class_head (aggr, scope, id)\n   \n       if (current == NULL_TREE)\n         current = current_namespace;\n-      if (scope == std_node)\n+      if (scope == fake_std_node)\n         scope = global_namespace;\n       if (scope == NULL_TREE)\n         scope = global_namespace;"}, {"sha": "d528e1c76d4507de41ae1e75d5564b7f280b1991", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "patch": "@@ -606,7 +606,7 @@ dequeue_and_dump (di)\n     case NAMESPACE_DECL:\n       /* The fake `::std' namespace does not have DECL_LANG_SPECIFIC,\n \t and therefore many other macros do not work on it.  */\n-      if (t == std_node)\n+      if (t == fake_std_node)\n \tbreak;\n       if (DECL_NAMESPACE_ALIAS (t))\n \tdump_child (\"alis\", DECL_NAMESPACE_ALIAS (t));"}, {"sha": "d3c3d169e6791c3aeef21d352e11789aa6cd3694", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "patch": "@@ -143,7 +143,7 @@ init_exception_processing ()\n   tree vtype = build_function_type (void_type_node, void_list_node);\n   \n   if (flag_honor_std)\n-    push_namespace (get_identifier (\"std\"));\n+    push_namespace (std_identifier);\n   terminate_node = build_cp_library_fn_ptr (\"terminate\", vtype);\n   TREE_THIS_VOLATILE (terminate_node) = 1;\n   TREE_NOTHROW (terminate_node) = 1;"}, {"sha": "a9360e52723c8045ca9c6213c2c17c4d0ec3e747", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "patch": "@@ -1485,7 +1485,7 @@ build_member_call (type, name, parmlist)\n   if (DECL_P (name))\n     name = DECL_NAME (name);\n \n-  if (type == std_node)\n+  if (type == fake_std_node)\n     return build_x_function_call (do_scoped_id (name, 0), parmlist,\n \t\t\t\t  current_class_ref);\n   if (TREE_CODE (type) == NAMESPACE_DECL)\n@@ -1620,7 +1620,7 @@ build_offset_ref (type, name)\n   if (TREE_CODE (name) == TEMPLATE_DECL)\n     return name;\n \n-  if (type == std_node)\n+  if (type == fake_std_node)\n     return do_scoped_id (name, 0);\n \n   if (processing_template_decl || uses_template_parms (type))"}, {"sha": "f172c5fe66764bdf553c6535205c48676ebcb9e8", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=6bcedb4e1cdc77c336e1742cdcff7f89ecbbb660", "patch": "@@ -80,7 +80,7 @@ void\n init_rtti_processing ()\n {\n   if (flag_honor_std)\n-    push_namespace (get_identifier (\"std\"));\n+    push_namespace (std_identifier);\n   type_info_type_node = xref_tag\n     (class_type_node, get_identifier (\"type_info\"), 1);\n   if (flag_honor_std)"}]}