{"sha": "630d30e96d138be05bea2e2769026ef819fb417d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMwZDMwZTk2ZDEzOGJlMDViZWEyZTI3NjkwMjZlZjgxOWZiNDE3ZA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-09-05T07:47:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T07:47:26Z"}, "message": "exp_ch4.adb (Expand_N_In): Replace test of expression in its own type by valid test and generate warning.\n\n2005-09-01  Robert Dewar  <dewar@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_In): Replace test of expression in its own\n\ttype by valid test and generate warning.\n\t(Tagged_Membership): Generate call to the run-time\n\tsubprogram IW_Membership in case of \"Iface_CW_Typ in Typ'Class\"\n\tChange formal name Subtype_Mark to Result_Definition in several calls to\n\tMake_Function_Specification.\n\t(Expand_Allocator_Expression): Add tests for suppression of the AI-344\n\tcheck for proper accessibility of the operand of a class-wide allocator.\n\tThe check can be left out if checks are suppressed or if the expression\n\thas a specific tagged type whose level is known to be safe.\n\n\t* exp_ch5.adb (Expand_N_Assignment_Statement): Simplify the code that\n\tgenerates the run-time check associated with null-excluding entities.\n\t(Expand_N_Return_Statement): Add tests to determine if the accessibility\n\tcheck on the level of the return expression of a class-wide function\n\tcan be elided. The check usually isn't needed if the expression has a\n\tspecific type (unless it's a conversion or a formal parameter). Also\n\tadd a test for whether accessibility checks are suppressed. Augment\n\tthe comments to describe the conditions for performing the check.\n\nFrom-SVN: r103849", "tree": {"sha": "c73b6d3daab6c005edab3f279a15da80c4f077c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c73b6d3daab6c005edab3f279a15da80c4f077c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/630d30e96d138be05bea2e2769026ef819fb417d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630d30e96d138be05bea2e2769026ef819fb417d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/630d30e96d138be05bea2e2769026ef819fb417d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630d30e96d138be05bea2e2769026ef819fb417d/comments", "author": null, "committer": null, "parents": [{"sha": "1a2c495da918ad782b233126773e4fc34bdacbe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a2c495da918ad782b233126773e4fc34bdacbe5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a2c495da918ad782b233126773e4fc34bdacbe5"}], "stats": {"total": 172, "additions": 129, "deletions": 43}, "files": [{"sha": "fbdb701550a977683ce937e4d9624919c822ddf9", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 110, "deletions": 34, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630d30e96d138be05bea2e2769026ef819fb417d/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630d30e96d138be05bea2e2769026ef819fb417d/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=630d30e96d138be05bea2e2769026ef819fb417d", "patch": "@@ -444,21 +444,24 @@ package body Exp_Ch4 is\n                 Expression          => Node));\n          end if;\n \n-         --  Ada 2005 (AI-344):\n-         --  For an allocator with a class-wide designated type, generate an\n-         --  accessibility check to verify that the level of the type of the\n-         --  created object is not deeper than the level of the access type.\n-         --  If the type of the qualified expression is class-wide, then\n-         --  always generate the check. Otherwise, only generate the check\n-         --  if the level of the qualified expression type is statically deeper\n-         --  than the access type. Although the static accessibility will\n-         --  generally have been performed as a legality check, it won't have\n-         --  been done in cases where the allocator appears in a generic body,\n-         --  so the run-time check is needed in general. (Not yet doing the\n-         --  optimization to suppress the check for the static level case.???)\n+         --  Ada 2005 (AI-344): For an allocator with a class-wide designated\n+         --  type, generate an accessibility check to verify that the level of\n+         --  the type of the created object is not deeper than the level of the\n+         --  access type. If the type of the qualified expression is class-\n+         --  wide, then always generate the check. Otherwise, only generate the\n+         --  check if the level of the qualified expression type is statically\n+         --  deeper than the access type. Although the static accessibility\n+         --  will generally have been performed as a legality check, it won't\n+         --  have been done in cases where the allocator appears in generic\n+         --  body, so a run-time check is needed in general.\n \n          if Ada_Version >= Ada_05\n            and then Is_Class_Wide_Type (Designated_Type (PtrT))\n+           and then not Scope_Suppress (Accessibility_Check)\n+           and then\n+             (Is_Class_Wide_Type (Etype (Exp))\n+                or else\n+              Type_Access_Level (Etype (Exp)) > Type_Access_Level (PtrT))\n          then\n             Insert_Action (N,\n                Make_Raise_Program_Error (Loc,\n@@ -1388,7 +1391,7 @@ package body Exp_Ch4 is\n             Make_Function_Specification (Loc,\n               Defining_Unit_Name       => Func_Name,\n               Parameter_Specifications => Formals,\n-              Subtype_Mark => New_Reference_To (Standard_Boolean, Loc)),\n+              Result_Definition => New_Reference_To (Standard_Boolean, Loc)),\n \n           Declarations =>  Decls,\n \n@@ -1833,7 +1836,7 @@ package body Exp_Ch4 is\n    --            end loop;\n    --         end if;\n \n-   --         . . .\n+   --         ...\n \n    --         if Sn'Length /= 0 then\n    --            P := Sn'First;\n@@ -2215,7 +2218,7 @@ package body Exp_Ch4 is\n         Make_Function_Specification (Loc,\n           Defining_Unit_Name       => Func_Id,\n           Parameter_Specifications => Param_Specs,\n-          Subtype_Mark             => New_Reference_To (Base_Typ, Loc));\n+          Result_Definition        => New_Reference_To (Base_Typ, Loc));\n \n       --  Construct L's object declaration\n \n@@ -3034,22 +3037,81 @@ package body Exp_Ch4 is\n       Rop    : constant Node_Id    := Right_Opnd (N);\n       Static : constant Boolean    := Is_OK_Static_Expression (N);\n \n+      procedure Substitute_Valid_Check;\n+      --  Replaces node N by Lop'Valid. This is done when we have an explicit\n+      --  test for the left operand being in range of its subtype.\n+\n+      ----------------------------\n+      -- Substitute_Valid_Check --\n+      ----------------------------\n+\n+      procedure Substitute_Valid_Check is\n+      begin\n+         Rewrite (N,\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => Relocate_Node (Lop),\n+             Attribute_Name => Name_Valid));\n+\n+         Analyze_And_Resolve (N, Rtyp);\n+\n+         Error_Msg_N (\"?explicit membership test may be optimized away\", N);\n+         Error_Msg_N (\"\\?use ''Valid attribute instead\", N);\n+         return;\n+      end Substitute_Valid_Check;\n+\n+   --  Start of processing for Expand_N_In\n+\n    begin\n-      --  If we have an explicit range, do a bit of optimization based\n-      --  on range analysis (we may be able to kill one or both checks).\n+      --  Check case of explicit test for an expression in range of its\n+      --  subtype. This is suspicious usage and we replace it with a 'Valid\n+      --  test and give a warning.\n+\n+      if Is_Scalar_Type (Etype (Lop))\n+        and then Nkind (Rop) in N_Has_Entity\n+        and then Etype (Lop) = Entity (Rop)\n+        and then Comes_From_Source (N)\n+      then\n+         Substitute_Valid_Check;\n+         return;\n+      end if;\n+\n+      --  Case of explicit range\n \n       if Nkind (Rop) = N_Range then\n          declare\n-            Lcheck : constant Compare_Result :=\n-                       Compile_Time_Compare (Lop, Low_Bound (Rop));\n-            Ucheck : constant Compare_Result :=\n-                       Compile_Time_Compare (Lop, High_Bound (Rop));\n+            Lo : constant Node_Id := Low_Bound (Rop);\n+            Hi : constant Node_Id := High_Bound (Rop);\n+\n+            Lo_Orig : constant Node_Id := Original_Node (Lo);\n+            Hi_Orig : constant Node_Id := Original_Node (Hi);\n+\n+            Lcheck : constant Compare_Result := Compile_Time_Compare (Lop, Lo);\n+            Ucheck : constant Compare_Result := Compile_Time_Compare (Lop, Hi);\n \n          begin\n-            --  If either check is known to fail, replace result\n-            --  by False, since the other check does not matter.\n-            --  Preserve the static flag for legality checks, because\n-            --  we are constant-folding beyond RM 4.9.\n+            --  If test is explicit x'first .. x'last, replace by valid check\n+\n+            if Is_Scalar_Type (Etype (Lop))\n+              and then Nkind (Lo_Orig) = N_Attribute_Reference\n+              and then Attribute_Name (Lo_Orig) = Name_First\n+              and then Nkind (Prefix (Lo_Orig)) in N_Has_Entity\n+              and then Entity (Prefix (Lo_Orig)) = Etype (Lop)\n+              and then Nkind (Hi_Orig) = N_Attribute_Reference\n+              and then Attribute_Name (Hi_Orig) = Name_Last\n+              and then Nkind (Prefix (Hi_Orig)) in N_Has_Entity\n+              and then Entity (Prefix (Hi_Orig)) = Etype (Lop)\n+              and then Comes_From_Source (N)\n+            then\n+               Substitute_Valid_Check;\n+               return;\n+            end if;\n+\n+            --  If we have an explicit range, do a bit of optimization based\n+            --  on range analysis (we may be able to kill one or both checks).\n+\n+            --  If either check is known to fail, replace result by False since\n+            --  the other check does not matter. Preserve the static flag for\n+            --  legality checks, because we are constant-folding beyond RM 4.9.\n \n             if Lcheck = LT or else Ucheck = GT then\n                Rewrite (N,\n@@ -3452,16 +3514,26 @@ package body Exp_Ch4 is\n    --  can be done. This avoids needing to duplicate this expansion code.\n \n    procedure Expand_N_Not_In (N : Node_Id) is\n-      Loc  : constant Source_Ptr := Sloc (N);\n-      Typ  : constant Entity_Id  := Etype (N);\n+      Loc : constant Source_Ptr := Sloc (N);\n+      Typ : constant Entity_Id  := Etype (N);\n+      Cfs : constant Boolean    := Comes_From_Source (N);\n \n    begin\n       Rewrite (N,\n         Make_Op_Not (Loc,\n           Right_Opnd =>\n             Make_In (Loc,\n               Left_Opnd  => Left_Opnd (N),\n-              Right_Opnd => Right_Opnd (N))));\n+                     Right_Opnd => Right_Opnd (N))));\n+\n+      --  We want this tp appear as coming from source if original does (see\n+      --  tranformations in Expand_N_In).\n+\n+      Set_Comes_From_Source (N, Cfs);\n+      Set_Comes_From_Source (Right_Opnd (N), Cfs);\n+\n+      --  Now analyze tranformed node\n+\n       Analyze_And_Resolve (N, Typ);\n    end Expand_N_Not_In;\n \n@@ -3995,7 +4067,7 @@ package body Exp_Ch4 is\n                --     Obj1 : Enclosing_Non_UU_Type;\n                --     Obj2 : Enclosing_Non_UU_Type (1);\n \n-               --     . . . Obj1 = Obj2 . . .\n+               --     ...  Obj1 = Obj2 ...\n \n                --     Generated code:\n \n@@ -5446,7 +5518,7 @@ package body Exp_Ch4 is\n                 Make_Parameter_Specification (Loc,\n                   Defining_Identifier => A,\n                   Parameter_Type      => New_Reference_To (Typ, Loc))),\n-              Subtype_Mark => New_Reference_To (Typ, Loc)),\n+              Result_Definition => New_Reference_To (Typ, Loc)),\n \n           Declarations => New_List (\n             Make_Object_Declaration (Loc,\n@@ -7715,7 +7787,7 @@ package body Exp_Ch4 is\n             Make_Function_Specification (Loc,\n               Defining_Unit_Name       => Func_Name,\n               Parameter_Specifications => Formals,\n-              Subtype_Mark => New_Reference_To (Standard_Boolean, Loc)),\n+              Result_Definition => New_Reference_To (Standard_Boolean, Loc)),\n \n           Declarations => New_List (\n             Make_Object_Declaration (Loc,\n@@ -7846,7 +7918,7 @@ package body Exp_Ch4 is\n             Make_Function_Specification (Loc,\n               Defining_Unit_Name       => Func_Name,\n               Parameter_Specifications => Formals,\n-              Subtype_Mark             => New_Reference_To (Typ, Loc)),\n+              Result_Definition        => New_Reference_To (Typ, Loc)),\n \n           Declarations => New_List (\n             Make_Object_Declaration (Loc,\n@@ -8052,7 +8124,12 @@ package body Exp_Ch4 is\n \n          --  Ada 2005 (AI-251): Class-wide applied to interfaces\n \n-         if Is_Interface (Etype (Class_Wide_Type (Right_Type))) then\n+         if Is_Interface (Etype (Class_Wide_Type (Right_Type)))\n+\n+            --   Give support to: \"Iface_CW_Typ in Typ'Class\"\n+\n+           or else Is_Interface (Left_Type)\n+         then\n             return\n               Make_Function_Call (Loc,\n                  Name => New_Occurrence_Of (RTE (RE_IW_Membership), Loc),\n@@ -8087,7 +8164,6 @@ package body Exp_Ch4 is\n                New_Reference_To\n                  (Node (First_Elmt (Access_Disp_Table (Right_Type))), Loc));\n       end if;\n-\n    end Tagged_Membership;\n \n    ------------------------------"}, {"sha": "54da8cb4811181853ba19c062aef52ba9ac9d50a", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630d30e96d138be05bea2e2769026ef819fb417d/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630d30e96d138be05bea2e2769026ef819fb417d/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=630d30e96d138be05bea2e2769026ef819fb417d", "patch": "@@ -1542,7 +1542,7 @@ package body Exp_Ch5 is\n       --  create dereferences but are not semantic aliasings.\n \n       elsif Is_Private_Type (Etype (Lhs))\n-        and then  Has_Discriminants (Typ)\n+        and then Has_Discriminants (Typ)\n         and then Nkind (Lhs) = N_Explicit_Dereference\n         and then Comes_From_Source (Lhs)\n       then\n@@ -1621,17 +1621,13 @@ package body Exp_Ch5 is\n            (Expression (Rhs), Designated_Type (Etype (Lhs)));\n       end if;\n \n-      --  Ada 2005 (AI-231): Generate conversion to the null-excluding\n-      --  type to force the corresponding run-time check\n+      --  Ada 2005 (AI-231): Generate the run-time check\n \n       if Is_Access_Type (Typ)\n-        and then\n-          ((Is_Entity_Name (Lhs) and then Can_Never_Be_Null (Entity (Lhs)))\n-             or else Can_Never_Be_Null (Etype (Lhs)))\n+        and then Can_Never_Be_Null (Etype (Lhs))\n+        and then not Can_Never_Be_Null (Etype (Rhs))\n       then\n-         Rewrite (Rhs, Convert_To (Etype (Lhs),\n-                                   Relocate_Node (Rhs)));\n-         Analyze_And_Resolve (Rhs, Etype (Lhs));\n+         Apply_Constraint_Check (Rhs, Etype (Lhs));\n       end if;\n \n       --  If we are assigning an access type and the left side is an\n@@ -2833,9 +2829,23 @@ package body Exp_Ch5 is\n       --  Ada 2005 (AI-344): If the result type is class-wide, then insert\n       --  a check that the level of the return expression's underlying type\n       --  is not deeper than the level of the master enclosing the function.\n+      --  Always generate the check when the type of the return expression\n+      --  is class-wide, when it's a type conversion, or when it's a formal\n+      --  parameter. Otherwise, suppress the check in the case where the\n+      --  return expression has a specific type whose level is known not to\n+      --  be statically deeper than the function's result type.\n \n       elsif Ada_Version >= Ada_05\n         and then Is_Class_Wide_Type (Return_Type)\n+        and then not Scope_Suppress (Accessibility_Check)\n+        and then\n+          (Is_Class_Wide_Type (Etype (Exp))\n+            or else Nkind (Exp) = N_Type_Conversion\n+            or else Nkind (Exp) = N_Unchecked_Type_Conversion\n+            or else (Is_Entity_Name (Exp)\n+                       and then Ekind (Entity (Exp)) in Formal_Kind)\n+            or else Scope_Depth (Enclosing_Dynamic_Scope (Etype (Exp))) >\n+                      Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))\n       then\n          Insert_Action (Exp,\n            Make_Raise_Program_Error (Loc,"}]}