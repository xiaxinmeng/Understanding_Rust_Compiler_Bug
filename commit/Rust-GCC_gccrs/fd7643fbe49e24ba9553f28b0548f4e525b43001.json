{"sha": "fd7643fbe49e24ba9553f28b0548f4e525b43001", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ3NjQzZmJlNDllMjRiYTk1NTNmMjhiMDU0OGY0ZTUyNWI0MzAwMQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-07-19T16:06:52Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-07-19T16:06:52Z"}, "message": "s390.c (legitimize_pic_address): Access local symbols relative to the GOT instead of relative to the literal...\n\n\t* config/s390/s390.c (legitimize_pic_address): Access local symbols\n\trelative to the GOT instead of relative to the literal pool base.\n\t(s390_output_symbolic_const): Handle new GOT-relative accesses.\n\t* config/s390/s390.md (\"call\"): Access local functions and PLT stubs\n\trelative to the GOT instead of relative to the literal pool base.\n\t(\"call_value\"): Likewise.\n\t(\"call_value_tls\"): Likewise.\n\n\t* config/s390/s390.c (s390_chunkify_start): Remove pool anchor\n\treloading.  Support LTREL_BASE / LTREL_OFFSET construct.\n\t(s390_chunkify_finish): Likewise.\n\t(s390_chunkify_cancel): Likewise.\n\t(s390_reorg): Adapt caller.\n\t(find_base_register_in_addr,\n\tfind_base_register_ref, replace_base_register_ref): Delete.\n\t(find_ltrel_base, replace_ltrel_base): New functions.\n\t(find_constant_pool_ref): Handle LTREL_BASE unspecs.\n\t(s390_decompose_address): Handle LTREL_BASE unspecs.  Optimize\n\tbase vs. index register usage.\n\t(struct constant_pool): Remove 'anchor'.\n\t(s390_add_anchor): Delete.\n\t(s390_dump_pool): Remove anchor handling.\n\t* config/s390/s390.md (\"reload_anchor\"): Remove.\n\n\t* config/s390/s390.c (s390_split_branches): Use LTREL_BASE/OFFSET.\n\t(s390_load_got): New function.  Use LTREL_BASE/OFFSET.\n\t(s390_emit_prologue): Use it.\n\t* config/s390/s390.md (\"builtin_longjmp\", \"builtin_setjmp_setup\",\n\t\"builtin_setjmp_receiver\"): Cleanup.  Use s390_load_got.  Do not\n\thard-code register 14.\n\t* config/s390/s390-protos.h (s390_load_got): Declare.\n\n\t* config/s390/s390.c (NR_C_MODES, constant_modes, gen_consttable):\n\tSupport TImode constants.\n\t* config/s390/s390.md (\"consttable_ti\"): New.\n\t(\"consttable_si\", \"consttable_di\"): Handle TLS symbols correctly.\n\n\t* config/s390/s390.md (UNSPEC_LTREL_OFFSET, UNSPEC_LTREL_BASE,\n\tUNSPEC_GOTENT, UNSPEC_GOT, UNSPEC_GOTOFF, UNSPEC_PLT, UNSPEC_PLTOFF,\n\tUNSPEC_RELOAD_BASE, UNSPECV_POOL, UNSPECV_POOL_START, UNSPECV_POOL_END,\n\tUNSPECV_POOL_QI, UNSPECV_POOL_HI, UNSPECV_POOL_SI, UNSPECV_POOL_DI,\n\tUNSPECV_POOL_TI, UNSPECV_POOL_SF, UNSPECV_POOL_DF, UNSPECV_MAIN_POOL):\n\tNew symbolic constants.\n\t(\"consttable_qi\", \"consttable_hi\", \"consttable_si\", \"consttable_di\",\n\t\"consttable_sf\", \"consttable_df\", \"pool_start_31\", \"pool_end_31\",\n\t\"pool_start_64\", \"pool_end_64\", \"reload_base_31\", \"reload_base_64\",\n\t\"pool\", \"literal_pool_31\", \"literal_pool_64\"): Cleanup.  Use\n\tsymbolic UNSPEC values.\n\t* config/s390/s390.c (larl_operand, s390_short_displacement,\n\tbras_sym_operand, s390_cannot_force_const_mem,\n\ts390_delegitimize_address, s390_decompose_address,\n\tlegitimize_pic_address, s390_output_symbolic_const,\n\ts390_function_profiler): Use symbolic UNSPEC values.\n\nFrom-SVN: r69592", "tree": {"sha": "02cea568b924e27ac832ae11fcd4f2d2e4287cee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02cea568b924e27ac832ae11fcd4f2d2e4287cee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd7643fbe49e24ba9553f28b0548f4e525b43001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd7643fbe49e24ba9553f28b0548f4e525b43001", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd7643fbe49e24ba9553f28b0548f4e525b43001", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd7643fbe49e24ba9553f28b0548f4e525b43001/comments", "author": null, "committer": null, "parents": [{"sha": "35a6c8736ad32b6c47af367c3ce08bb61281eccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35a6c8736ad32b6c47af367c3ce08bb61281eccc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35a6c8736ad32b6c47af367c3ce08bb61281eccc"}], "stats": {"total": 803, "additions": 384, "deletions": 419}, "files": [{"sha": "99f56e6c69e34b31d49834a133b0e2ed60509266", "filename": "gcc/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7643fbe49e24ba9553f28b0548f4e525b43001/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7643fbe49e24ba9553f28b0548f4e525b43001/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd7643fbe49e24ba9553f28b0548f4e525b43001", "patch": "@@ -1,3 +1,59 @@\n+2003-07-19  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.c (legitimize_pic_address): Access local symbols \n+\trelative to the GOT instead of relative to the literal pool base.\n+\t(s390_output_symbolic_const): Handle new GOT-relative accesses.\n+\t* config/s390/s390.md (\"call\"): Access local functions and PLT stubs\n+\trelative to the GOT instead of relative to the literal pool base.\n+\t(\"call_value\"): Likewise.\n+\t(\"call_value_tls\"): Likewise.\n+\n+\t* config/s390/s390.c (s390_chunkify_start): Remove pool anchor \n+\treloading.  Support LTREL_BASE / LTREL_OFFSET construct.\n+\t(s390_chunkify_finish): Likewise.\n+\t(s390_chunkify_cancel): Likewise.\n+\t(s390_reorg): Adapt caller.\n+\t(find_base_register_in_addr,\n+\tfind_base_register_ref, replace_base_register_ref): Delete.\n+\t(find_ltrel_base, replace_ltrel_base): New functions.\n+\t(find_constant_pool_ref): Handle LTREL_BASE unspecs.\n+\t(s390_decompose_address): Handle LTREL_BASE unspecs.  Optimize\n+\tbase vs. index register usage.\n+\t(struct constant_pool): Remove 'anchor'.\n+\t(s390_add_anchor): Delete.\n+\t(s390_dump_pool): Remove anchor handling.\n+\t* config/s390/s390.md (\"reload_anchor\"): Remove.\n+\n+\t* config/s390/s390.c (s390_split_branches): Use LTREL_BASE/OFFSET.\n+\t(s390_load_got): New function.  Use LTREL_BASE/OFFSET.\n+\t(s390_emit_prologue): Use it.\n+\t* config/s390/s390.md (\"builtin_longjmp\", \"builtin_setjmp_setup\", \n+\t\"builtin_setjmp_receiver\"): Cleanup.  Use s390_load_got.  Do not \n+\thard-code register 14.\n+\t* config/s390/s390-protos.h (s390_load_got): Declare.\n+\n+\t* config/s390/s390.c (NR_C_MODES, constant_modes, gen_consttable): \n+\tSupport TImode constants.\n+\t* config/s390/s390.md (\"consttable_ti\"): New.\n+\t(\"consttable_si\", \"consttable_di\"): Handle TLS symbols correctly.\n+\n+\t* config/s390/s390.md (UNSPEC_LTREL_OFFSET, UNSPEC_LTREL_BASE,\n+\tUNSPEC_GOTENT, UNSPEC_GOT, UNSPEC_GOTOFF, UNSPEC_PLT, UNSPEC_PLTOFF,\n+\tUNSPEC_RELOAD_BASE, UNSPECV_POOL, UNSPECV_POOL_START, UNSPECV_POOL_END,\n+\tUNSPECV_POOL_QI, UNSPECV_POOL_HI, UNSPECV_POOL_SI, UNSPECV_POOL_DI,\n+\tUNSPECV_POOL_TI, UNSPECV_POOL_SF, UNSPECV_POOL_DF, UNSPECV_MAIN_POOL):\n+\tNew symbolic constants.\n+\t(\"consttable_qi\", \"consttable_hi\", \"consttable_si\", \"consttable_di\",\n+\t\"consttable_sf\", \"consttable_df\", \"pool_start_31\", \"pool_end_31\",\n+\t\"pool_start_64\", \"pool_end_64\", \"reload_base_31\", \"reload_base_64\",\n+\t\"pool\", \"literal_pool_31\", \"literal_pool_64\"): Cleanup.  Use\n+\tsymbolic UNSPEC values.\n+\t* config/s390/s390.c (larl_operand, s390_short_displacement, \n+\tbras_sym_operand, s390_cannot_force_const_mem,\n+\ts390_delegitimize_address, s390_decompose_address,\n+\tlegitimize_pic_address, s390_output_symbolic_const,\n+\ts390_function_profiler): Use symbolic UNSPEC values.\n+\n 2003-07-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* alias.c alloc-pool.c bitmap.c bitmap.h bt-load.c builtins.c"}, {"sha": "a6ed004ffbf5bdbc5e7b546cc559f188aee70ebd", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7643fbe49e24ba9553f28b0548f4e525b43001/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7643fbe49e24ba9553f28b0548f4e525b43001/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=fd7643fbe49e24ba9553f28b0548f4e525b43001", "patch": "@@ -24,6 +24,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n extern void optimization_options PARAMS ((int, int));\n extern void override_options PARAMS ((void));\n extern int s390_arg_frame_offset PARAMS ((void));\n+extern void s390_load_got PARAMS ((int));\n extern void s390_emit_prologue PARAMS ((void));\n extern void s390_emit_epilogue PARAMS ((void));\n extern void s390_function_profiler PARAMS ((FILE *, int));"}, {"sha": "91e1a29d0a1d5523756841723c716eca3c520906", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 232, "deletions": 317, "changes": 549, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7643fbe49e24ba9553f28b0548f4e525b43001/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7643fbe49e24ba9553f28b0548f4e525b43001/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=fd7643fbe49e24ba9553f28b0548f4e525b43001", "patch": "@@ -215,9 +215,8 @@ static int addr_generation_dependency_p PARAMS ((rtx, rtx));\n static int s390_split_branches PARAMS ((rtx, bool *));\n static void find_constant_pool_ref PARAMS ((rtx, rtx *));\n static void replace_constant_pool_ref PARAMS ((rtx *, rtx, rtx));\n-static int find_base_register_in_addr PARAMS ((struct s390_address *));\n-static bool find_base_register_ref PARAMS ((rtx));\n-static void replace_base_register_ref PARAMS ((rtx *, rtx));\n+static rtx find_ltrel_base PARAMS ((rtx));\n+static void replace_ltrel_base PARAMS ((rtx *, rtx));\n static void s390_optimize_prolog PARAMS ((int));\n static bool s390_fixup_clobbered_return_reg PARAMS ((rtx));\n static int find_unused_clobbered_reg PARAMS ((void));\n@@ -1134,10 +1133,10 @@ larl_operand (op, mode)\n   /* Now we must have a @GOTENT offset or @PLT stub\n      or an @INDNTPOFF TLS offset.  */\n   if (GET_CODE (op) == UNSPEC\n-      && XINT (op, 1) == 111)\n+      && XINT (op, 1) == UNSPEC_GOTENT)\n     return 1;\n   if (GET_CODE (op) == UNSPEC\n-      && XINT (op, 1) == 113)\n+      && XINT (op, 1) == UNSPEC_PLT)\n     return 1;\n   if (GET_CODE (op) == UNSPEC\n       && XINT (op, 1) == UNSPEC_INDNTPOFF)\n@@ -1249,7 +1248,7 @@ s390_short_displacement (disp)\n   /* GOT offset is not OK, the GOT can be large.  */\n   if (GET_CODE (disp) == CONST\n       && GET_CODE (XEXP (disp, 0)) == UNSPEC\n-      && XINT (XEXP (disp, 0), 1) == 110)\n+      && XINT (XEXP (disp, 0), 1) == UNSPEC_GOT)\n     return 0;\n \n   /* All other symbolic constants are literal pool references,\n@@ -1455,7 +1454,7 @@ bras_sym_operand (op, mode)\n   /* Allow @PLT stubs.  */\n   if (code == CONST\n       && GET_CODE (XEXP (op, 0)) == UNSPEC\n-      && XINT (XEXP (op, 0), 1) == 113)\n+      && XINT (XEXP (op, 0), 1) == UNSPEC_PLT)\n     return 1;\n   return 0;\n }\n@@ -1749,10 +1748,10 @@ s390_cannot_force_const_mem (x)\n       switch (XINT (x, 1))\n \t{\n \t/* Only lt-relative or GOT-relative UNSPECs are OK.  */\n-\tcase 100:\n-\tcase 104:\n-\tcase 112:\n-\tcase 114:\n+\tcase UNSPEC_LTREL_OFFSET:\n+\tcase UNSPEC_GOT:\n+\tcase UNSPEC_GOTOFF:\n+\tcase UNSPEC_PLTOFF:\n \tcase UNSPEC_TLSGD:\n \tcase UNSPEC_TLSLDM:\n \tcase UNSPEC_NTPOFF:\n@@ -1996,6 +1995,8 @@ s390_decompose_address (addr, out)\n   rtx indx = NULL_RTX;\n   rtx disp = NULL_RTX;\n   int pointer = FALSE;\n+  int base_ptr = FALSE;\n+  int indx_ptr = FALSE;\n \n   /* Decompose address into base + index + displacement.  */\n \n@@ -2041,35 +2042,18 @@ s390_decompose_address (addr, out)\n     disp = addr;\t\t/* displacement */\n \n \n-  /* Prefer to use pointer as base, not index.  */\n-  if (base && indx)\n-    {\n-      int base_ptr = GET_CODE (base) == UNSPEC\n-\t\t     || (REG_P (base) && REG_POINTER (base));\n-      int indx_ptr = GET_CODE (indx) == UNSPEC\n-\t\t     || (REG_P (indx) && REG_POINTER (indx));\n-\n-      if (!base_ptr && indx_ptr)\n-\t{\n-\t  rtx tmp = base;\n-\t  base = indx;\n-\t  indx = tmp;\n-\t}\n-    }\n-\n   /* Validate base register.  */\n   if (base)\n     {\n       if (GET_CODE (base) == UNSPEC)\n         {\n-          if (XVECLEN (base, 0) != 1 || XINT (base, 1) != 101)\n-\t      return FALSE;\n-\t  base = XVECEXP (base, 0, 0);\n-\t  pointer = TRUE;\n+          if (XVECLEN (base, 0) != 1 || XINT (base, 1) != UNSPEC_LTREL_BASE)\n+\t    return FALSE;\n+\t  base = gen_rtx_REG (Pmode, BASE_REGISTER);\n \t}\n \n       if (GET_CODE (base) != REG || GET_MODE (base) != Pmode)\n-\t  return FALSE;\n+\treturn FALSE;\n \n       if (REGNO (base) == BASE_REGISTER\n \t  || REGNO (base) == STACK_POINTER_REGNUM\n@@ -2082,22 +2066,21 @@ s390_decompose_address (addr, out)\n \t      && REGNO (base) <= LAST_VIRTUAL_REGISTER)\n           || (flag_pic\n               && REGNO (base) == PIC_OFFSET_TABLE_REGNUM))\n-        pointer = TRUE;\n+        pointer = base_ptr = TRUE;\n     }\n \n   /* Validate index register.  */\n   if (indx)\n     {\n       if (GET_CODE (indx) == UNSPEC)\n         {\n-          if (XVECLEN (indx, 0) != 1 || XINT (indx, 1) != 101)\n-\t      return FALSE;\n-\t  indx = XVECEXP (indx, 0, 0);\n-\t  pointer = TRUE;\n+          if (XVECLEN (indx, 0) != 1 || XINT (indx, 1) != UNSPEC_LTREL_BASE)\n+\t    return FALSE;\n+\t  indx = gen_rtx_REG (Pmode, BASE_REGISTER);\n \t}\n \n       if (GET_CODE (indx) != REG || GET_MODE (indx) != Pmode)\n-\t  return FALSE;\n+\treturn FALSE;\n \n       if (REGNO (indx) == BASE_REGISTER\n \t  || REGNO (indx) == STACK_POINTER_REGNUM\n@@ -2110,7 +2093,16 @@ s390_decompose_address (addr, out)\n \t      && REGNO (indx) <= LAST_VIRTUAL_REGISTER)\n           || (flag_pic\n               && REGNO (indx) == PIC_OFFSET_TABLE_REGNUM))\n-        pointer = TRUE;\n+        pointer = indx_ptr = TRUE;\n+    }\n+\n+  /* Prefer to use pointer as base, not index.  */\n+  if (base && indx && !base_ptr\n+      && (indx_ptr || (!REG_POINTER (base) && REG_POINTER (indx))))\n+    {\n+      rtx tmp = base;\n+      base = indx;\n+      indx = tmp;\n     }\n \n   /* Validate displacement.  */\n@@ -2134,11 +2126,11 @@ s390_decompose_address (addr, out)\n \t    }\n         }\n \n-      /* In the small-PIC case, the linker converts @GOT12 \n+      /* In the small-PIC case, the linker converts @GOT\n          and @GOTNTPOFF offsets to possible displacements.  */\n       else if (GET_CODE (disp) == CONST\n                && GET_CODE (XEXP (disp, 0)) == UNSPEC\n-               && (XINT (XEXP (disp, 0), 1) == 110\n+               && (XINT (XEXP (disp, 0), 1) == UNSPEC_GOT\n \t\t   || XINT (XEXP (disp, 0), 1) == UNSPEC_GOTNTPOFF))\n         {\n           if (flag_pic != 1)\n@@ -2205,7 +2197,8 @@ s390_decompose_address (addr, out)\n           else\n             base = gen_rtx_REG (Pmode, BASE_REGISTER);\n \n-          disp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, disp), 100);\n+          disp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, disp), \n+\t\t\t\t UNSPEC_LTREL_OFFSET);\n           disp = gen_rtx_CONST (Pmode, disp);\n \n           if (offset)\n@@ -2356,19 +2349,19 @@ legitimize_pic_address (orig, reg)\n         }\n       else\n         {\n-          /* Access local symbols relative to the literal pool.  */\n+          /* Access local symbols relative to the GOT.  */\n \n           rtx temp = reg? reg : gen_reg_rtx (Pmode);\n \n-          addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 100);\n+\t  if (reload_in_progress || reload_completed)\n+\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\n+          addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTOFF);\n           addr = gen_rtx_CONST (Pmode, addr);\n           addr = force_const_mem (Pmode, addr);\n \t  emit_move_insn (temp, addr);\n \n-          base = gen_rtx_REG (Pmode, BASE_REGISTER);\n-          base = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, base), 101);\n-          new = gen_rtx_PLUS (Pmode, base, temp);\n-\n+          new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n           if (reg != 0)\n             {\n               emit_move_insn (reg, new);\n@@ -2384,12 +2377,12 @@ legitimize_pic_address (orig, reg)\n       if (flag_pic == 1)\n         {\n           /* Assume GOT offset < 4k.  This is handled the same way\n-             in both 31- and 64-bit code (@GOT12).  */\n+             in both 31- and 64-bit code (@GOT).  */\n \n \t  if (reload_in_progress || reload_completed)\n \t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \n-          new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 110);\n+          new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOT);\n           new = gen_rtx_CONST (Pmode, new);\n           new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n           new = gen_rtx_MEM (Pmode, new);\n@@ -2404,7 +2397,7 @@ legitimize_pic_address (orig, reg)\n \n           rtx temp = gen_reg_rtx (Pmode);\n \n-          new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 111);\n+          new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTENT);\n           new = gen_rtx_CONST (Pmode, new);\n           emit_move_insn (temp, new);\n \n@@ -2423,7 +2416,7 @@ legitimize_pic_address (orig, reg)\n \t  if (reload_in_progress || reload_completed)\n \t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \n-          addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 112);\n+          addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOT);\n           addr = gen_rtx_CONST (Pmode, addr);\n           addr = force_const_mem (Pmode, addr);\n           emit_move_insn (temp, addr);\n@@ -2446,35 +2439,41 @@ legitimize_pic_address (orig, reg)\n                 abort ();\n               switch (XINT (addr, 1))\n                 {\n-                  /* If someone moved an @GOT or lt-relative UNSPEC\n+                  /* If someone moved a GOT-relative UNSPEC\n                      out of the literal pool, force them back in.  */\n-                  case 100:\n-                  case 112:\n-                  case 114:\n+                  case UNSPEC_GOTOFF:\n+                  case UNSPEC_PLTOFF:\n                     new = force_const_mem (Pmode, orig);\n                     break;\n \n+                  /* @GOT is OK as is if small.  */\n+\t\t  case UNSPEC_GOT:\n+\t\t    if (flag_pic == 2)\n+\t\t      new = force_const_mem (Pmode, orig);\n+\t\t    break;\n+\n                   /* @GOTENT is OK as is.  */\n-                  case 111:\n+                  case UNSPEC_GOTENT:\n                     break;\n \n                   /* @PLT is OK as is on 64-bit, must be converted to\n-                     lt-relative PLT on 31-bit.  */\n-                  case 113:\n+                     GOT-relative @PLTOFF on 31-bit.  */\n+                  case UNSPEC_PLT:\n                     if (!TARGET_64BIT)\n                       {\n                         rtx temp = reg? reg : gen_reg_rtx (Pmode);\n \n+\t\t\tif (reload_in_progress || reload_completed)\n+\t\t\t  regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\n                         addr = XVECEXP (addr, 0, 0);\n-                        addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 114);\n+                        addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), \n+\t\t\t\t\t       UNSPEC_PLTOFF);\n                         addr = gen_rtx_CONST (Pmode, addr);\n                         addr = force_const_mem (Pmode, addr);\n \t                emit_move_insn (temp, addr);\n \n-                        base = gen_rtx_REG (Pmode, BASE_REGISTER);\n-                        base = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, base), 101);\n-                        new = gen_rtx_PLUS (Pmode, base, temp);\n-\n+                        new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n                         if (reg != 0)\n                           {\n                             emit_move_insn (reg, new);\n@@ -2533,20 +2532,21 @@ legitimize_pic_address (orig, reg)\n                 }\n               else\n                 {\n-                  /* Access local symbols relative to the literal pool.  */\n+                  /* Access local symbols relative to the GOT.  */\n \n                   rtx temp = reg? reg : gen_reg_rtx (Pmode);\n \n-                  addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op0), 100);\n+\t\t  if (reload_in_progress || reload_completed)\n+\t\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\n+                  addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op0), \n+\t\t\t\t\t UNSPEC_GOTOFF);\n                   addr = gen_rtx_PLUS (Pmode, addr, op1);\n                   addr = gen_rtx_CONST (Pmode, addr);\n                   addr = force_const_mem (Pmode, addr);\n         \t  emit_move_insn (temp, addr);\n \n-                  base = gen_rtx_REG (Pmode, BASE_REGISTER);\n-                  base = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, base), 101);\n-                  new = gen_rtx_PLUS (Pmode, base, temp);\n-\n+                  new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n                   if (reg != 0)\n                     {\n                       emit_move_insn (reg, new);\n@@ -2555,15 +2555,15 @@ legitimize_pic_address (orig, reg)\n                 }\n \t    }\n \n-          /* Now, check whether it is an LT-relative symbol plus offset\n+          /* Now, check whether it is a GOT relative symbol plus offset\n              that was pulled out of the literal pool.  Force it back in.  */\n \n \t  else if (GET_CODE (op0) == UNSPEC\n \t           && GET_CODE (op1) == CONST_INT)\n             {\n \t      if (XVECLEN (op0, 0) != 1)\n                 abort ();\n-              if (XINT (op0, 1) != 100)\n+              if (XINT (op0, 1) != UNSPEC_GOTOFF)\n                 abort ();\n \n               new = force_const_mem (Pmode, orig);\n@@ -3279,7 +3279,7 @@ s390_delegitimize_address (orig_x)\n     {\n       y = XEXP (XEXP (x, 1), 0);\n       if (GET_CODE (y) == UNSPEC\n-\t  && XINT (y, 1) == 110)\n+\t  && XINT (y, 1) == UNSPEC_GOT)\n \treturn XVECEXP (y, 0, 0);\n       return orig_x;\n     }\n@@ -3288,7 +3288,7 @@ s390_delegitimize_address (orig_x)\n     {\n       y = XEXP (x, 0);\n       if (GET_CODE (y) == UNSPEC\n-\t  && XINT (y, 1) == 111)\n+\t  && XINT (y, 1) == UNSPEC_GOTENT)\n \treturn XVECEXP (y, 0, 0);\n       return orig_x;\n     }\n@@ -3378,37 +3378,30 @@ s390_output_symbolic_const (file, x)\n         output_operand_lossage (\"invalid UNSPEC as operand (1)\");\n       switch (XINT (x, 1))\n         {\n-        case 100:\n-        case 104:\n+        case UNSPEC_LTREL_OFFSET:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n           fprintf (file, \"-\");\t\n \t  s390_output_symbolic_const (file, cfun->machine->literal_pool_label);\n  \t  break;\n-        case 105:\n-\t  s390_output_symbolic_const (file, cfun->machine->literal_pool_label);\n-          fprintf (file, \"-\");\n-\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n-\t  break;\n-\tcase 110:\n-\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n-\t  fprintf (file, \"@GOT12\");\n-\t  break;\n-\tcase 111:\n+\tcase UNSPEC_GOTENT:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n \t  fprintf (file, \"@GOTENT\");\n \t  break;\n-\tcase 112:\n+\tcase UNSPEC_GOT:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n \t  fprintf (file, \"@GOT\");\n \t  break;\n-\tcase 113:\n+\tcase UNSPEC_GOTOFF:\n+\t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n+\t  fprintf (file, \"@GOTOFF\");\n+\t  break;\n+\tcase UNSPEC_PLT:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n \t  fprintf (file, \"@PLT\");\n \t  break;\n-\tcase 114:\n+\tcase UNSPEC_PLTOFF:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n-          fprintf (file, \"@PLT-\");\n-\t  s390_output_symbolic_const (file, cfun->machine->literal_pool_label);\n+\t  fprintf (file, \"@PLTOFF\");\n \t  break;\n \tcase UNSPEC_TLSGD:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n@@ -3968,14 +3961,16 @@ s390_split_branches (temp_reg, temp_used)\n       else\n \t{\n \t  new_literal = 1;\n-\t  tmp = gen_rtx_UNSPEC (SImode, gen_rtvec (1, *label), 104);\n-\t  tmp = gen_rtx_CONST (SImode, tmp);\n-\t  tmp = force_const_mem (SImode, tmp);\n-\t  tmp = emit_insn_before (gen_rtx_SET (Pmode, temp_reg, tmp), insn);\n+\t  target = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, *label), \n+\t\t\t\t   UNSPEC_LTREL_OFFSET);\n+\t  target = gen_rtx_CONST (Pmode, target);\n+\t  target = force_const_mem (Pmode, target);\n+\t  tmp = emit_insn_before (gen_rtx_SET (Pmode, temp_reg, target), insn);\n \t  INSN_ADDRESSES_NEW (tmp, -1);\n \n-\t  target = gen_rtx_REG (Pmode, BASE_REGISTER);\n-\t  target = gen_rtx_PLUS (Pmode, target, temp_reg);\n+          target = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, XEXP (target, 0)), \n+\t\t\t\t   UNSPEC_LTREL_BASE);\n+\t  target = gen_rtx_PLUS (Pmode, temp_reg, target);\n \t}\n \n       if (!validate_change (insn, label, target, 0))\n@@ -4002,6 +3997,11 @@ find_constant_pool_ref (x, ref)\n   int i, j;\n   const char *fmt;\n \n+  /* Ignore LTREL_BASE references.  */\n+  if (GET_CODE (x) == UNSPEC\n+      && XINT (x, 1) == UNSPEC_LTREL_BASE)\n+    return;\n+\n   if (GET_CODE (x) == SYMBOL_REF\n       && CONSTANT_POOL_ADDRESS_P (x))\n     {\n@@ -4100,159 +4100,83 @@ replace_constant_pool_ref (x, ref, addr)\n     }\n }\n \n-/* Check whether ADDR is an address that uses the base register, \n-   without actually constituting a literal pool access.  (This happens\n-   in 31-bit PIC mode, where the base register is used as anchor for\n-   relative addressing of local symbols.) \n-\n-   Returns 1 if the base register occupies the base slot,\n-   returns 2 if the base register occupies the index slot,\n-   returns 0 if the address is not of this form.  */\n-\n-static int\n-find_base_register_in_addr (addr)\n-     struct s390_address *addr;\n-{\n-  /* If DISP is complex, we might have a literal pool reference.  */\n-  if (addr->disp && GET_CODE (addr->disp) != CONST_INT)\n-    return 0;\n-\n-  if (addr->base && REG_P (addr->base) && REGNO (addr->base) == BASE_REGISTER)\n-    return 1;\n-\n-  if (addr->indx && REG_P (addr->indx) && REGNO (addr->indx) == BASE_REGISTER)\n-    return 2;\n-\n-  return 0;\n-}\n-\n-/* Return true if X contains an address that uses the base register, \n-   without actually constituting a literal pool access.  */\n+/* Check whether X contains an UNSPEC_LTREL_BASE.  \n+   Return its constant pool symbol if found, NULL_RTX otherwise.  */\n \n-static bool\n-find_base_register_ref (x)\n+static rtx\n+find_ltrel_base (x)\n      rtx x;\n {\n-  bool retv = FALSE;\n-  struct s390_address addr;\n   int i, j;\n   const char *fmt;\n \n-  /* Addresses can only occur inside a MEM ...  */\n-  if (GET_CODE (x) == MEM)\n-    {\n-      if (s390_decompose_address (XEXP (x, 0), &addr)\n-\t  && find_base_register_in_addr (&addr))\n-\treturn TRUE;\n-    }\n-\n-  /* ... or a load-address type pattern.  */\n-  if (GET_CODE (x) == SET && GET_CODE (SET_DEST (x)) == REG)\n-    {\n-      if (s390_decompose_address (SET_SRC (x), &addr)\n-\t  && find_base_register_in_addr (&addr))\n-\treturn TRUE;\n-    }\n+  if (GET_CODE (x) == UNSPEC\n+      && XINT (x, 1) == UNSPEC_LTREL_BASE)\n+    return XVECEXP (x, 0, 0);\n \n   fmt = GET_RTX_FORMAT (GET_CODE (x));\n   for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n         {\n-          retv |= find_base_register_ref (XEXP (x, i));\n+          rtx fnd = find_ltrel_base (XEXP (x, i));\n+\t  if (fnd)\n+\t    return fnd;\n         }\n       else if (fmt[i] == 'E')\n         {\n           for (j = 0; j < XVECLEN (x, i); j++)\n-            retv |= find_base_register_ref (XVECEXP (x, i, j));\n+\t    {\n+              rtx fnd = find_ltrel_base (XVECEXP (x, i, j));\n+\t      if (fnd)\n+\t\treturn fnd;\n+\t    }\n         }\n     }\n \n-  return retv;\n+  return NULL_RTX;\n }\n \n-/* If X contains an address that uses the base register,\n-   without actually constituting a literal pool access,\n-   replace the base register with REPL in all such cases.\n-\n-   Handles both MEMs and load address patterns.  */\n+/* Replace any occurrence of UNSPEC_LTREL_BASE in X with BASE.  */\n \n static void\n-replace_base_register_ref (x, repl)\n+replace_ltrel_base (x, base)\n      rtx *x;\n-     rtx repl;\n+     rtx base;\n {\n-  struct s390_address addr;\n-  rtx new_addr;\n-  int i, j, pos;\n+  int i, j;\n   const char *fmt;\n \n-  /* Addresses can only occur inside a MEM ...  */\n-  if (GET_CODE (*x) == MEM)\n+  if (GET_CODE (*x) == UNSPEC\n+      && XINT (*x, 1) == UNSPEC_LTREL_BASE)\n     {\n-      if (s390_decompose_address (XEXP (*x, 0), &addr)\n-\t  && (pos = find_base_register_in_addr (&addr)))\n-\t{\n-\t  if (pos == 1)\n-\t    addr.base = repl;\n-\t  else\n-\t    addr.indx = repl;\n-\n-\t  new_addr = addr.base;\n-\t  if (addr.indx)\n-\t    new_addr = gen_rtx_PLUS (Pmode, new_addr, addr.indx);\n-\t  if (addr.disp)\n-\t    new_addr = gen_rtx_PLUS (Pmode, new_addr, addr.disp);\n-\n-\t  *x = replace_equiv_address (*x, new_addr);\n-\t  return;\n-\t}\n-    }\n-\n-  /* ... or a load-address type pattern.  */\n-  if (GET_CODE (*x) == SET && GET_CODE (SET_DEST (*x)) == REG)\n-    {\n-      if (s390_decompose_address (SET_SRC (*x), &addr)\n-\t  && (pos = find_base_register_in_addr (&addr)))\n-\t{\n-\t  if (pos == 1)\n-\t    addr.base = repl;\n-\t  else\n-\t    addr.indx = repl;\n-\n-\t  new_addr = addr.base;\n-\t  if (addr.indx)\n-\t    new_addr = gen_rtx_PLUS (Pmode, new_addr, addr.indx);\n-\t  if (addr.disp)\n-\t    new_addr = gen_rtx_PLUS (Pmode, new_addr, addr.disp);\n-\n-\t  SET_SRC (*x) = new_addr;\n-\t  return;\n-\t}\n+      *x = base;\n+      return;\n     }\n \n   fmt = GET_RTX_FORMAT (GET_CODE (*x));\n   for (i = GET_RTX_LENGTH (GET_CODE (*x)) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n         {\n-          replace_base_register_ref (&XEXP (*x, i), repl);\n+          replace_ltrel_base (&XEXP (*x, i), base);\n         }\n       else if (fmt[i] == 'E')\n         {\n           for (j = 0; j < XVECLEN (*x, i); j++)\n-            replace_base_register_ref (&XVECEXP (*x, i, j), repl);\n+            replace_ltrel_base (&XVECEXP (*x, i, j), base);\n         }\n     }\n }\n \n \n-/* We keep a list of constants we which we have to add to internal\n+/* We keep a list of constants which we have to add to internal\n    constant tables in the middle of large functions.  */\n \n-#define NR_C_MODES 6\n+#define NR_C_MODES 7\n enum machine_mode constant_modes[NR_C_MODES] = \n {\n+  TImode,\n   DFmode, DImode,\n   SFmode, SImode,\n   HImode,\n@@ -4261,6 +4185,7 @@ enum machine_mode constant_modes[NR_C_MODES] =\n \n rtx (*gen_consttable[NR_C_MODES])(rtx) =\n {\n+  gen_consttable_ti,\n   gen_consttable_df, gen_consttable_di,\n   gen_consttable_sf, gen_consttable_si,\n   gen_consttable_hi,\n@@ -4284,11 +4209,10 @@ struct constant_pool\n   struct constant *constants[NR_C_MODES];\n   rtx label;\n   int size;\n-  bool anchor;\n };\n \n-static struct constant_pool * s390_chunkify_start PARAMS ((rtx, bool *));\n-static void s390_chunkify_finish PARAMS ((struct constant_pool *, rtx));\n+static struct constant_pool * s390_chunkify_start PARAMS ((void));\n+static void s390_chunkify_finish PARAMS ((struct constant_pool *));\n static void s390_chunkify_cancel PARAMS ((struct constant_pool *));\n \n static struct constant_pool *s390_start_pool PARAMS ((struct constant_pool **, rtx));\n@@ -4297,7 +4221,6 @@ static void s390_add_pool_insn PARAMS ((struct constant_pool *, rtx));\n static struct constant_pool *s390_find_pool PARAMS ((struct constant_pool *, rtx));\n static void s390_add_constant PARAMS ((struct constant_pool *, rtx, enum machine_mode));\n static rtx s390_find_constant PARAMS ((struct constant_pool *, rtx, enum machine_mode));\n-static void s390_add_anchor PARAMS ((struct constant_pool *));\n static rtx s390_dump_pool PARAMS ((struct constant_pool *));\n static void s390_free_pool PARAMS ((struct constant_pool *));\n \n@@ -4322,7 +4245,6 @@ s390_start_pool (pool_list, insn)\n   pool->pool_insn = NULL_RTX;\n   pool->insns = BITMAP_XMALLOC ();\n   pool->size = 0;\n-  pool->anchor = FALSE;\n \n   for (prev = pool_list; *prev; prev = &(*prev)->next)\n     ;\n@@ -4439,19 +4361,6 @@ s390_find_constant (pool, val, mode)\n   return offset;\n }\n \n-/* Set 'anchor' flag in POOL.  */\n-\n-static void\n-s390_add_anchor (pool)\n-     struct constant_pool *pool;\n-{\n-  if (!pool->anchor)\n-    {\n-      pool->anchor = TRUE;\n-      pool->size += 4;\n-    }\n-}\n-\n /* Dump out the constants in POOL.  */\n \n static rtx\n@@ -4473,26 +4382,16 @@ s390_dump_pool (pool)\n   insn = emit_label_after (pool->label, insn);\n   INSN_ADDRESSES_NEW (insn, -1);\n \n-  /* Emit anchor if we need one.  */\n-  if (pool->anchor)\n-    {\n-      rtx anchor = gen_rtx_LABEL_REF (VOIDmode, pool->label);\n-      anchor = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, anchor), 105);\n-      anchor = gen_rtx_CONST (VOIDmode, anchor);\n-      insn = emit_insn_after (gen_consttable_si (anchor), insn);\n-      INSN_ADDRESSES_NEW (insn, -1);\n-    }\n-\n   /* Dump constants in descending alignment requirement order,\n      ensuring proper alignment for every constant.  */\n   for (i = 0; i < NR_C_MODES; i++)\n     for (c = pool->constants[i]; c; c = c->next)\n       {\n-\t/* Convert 104 unspecs to pool-relative references.  */\n+\t/* Convert UNSPEC_LTREL_OFFSET unspecs to pool-relative references.  */\n \trtx value = c->value;\n \tif (GET_CODE (value) == CONST\n \t    && GET_CODE (XEXP (value, 0)) == UNSPEC\n-\t    && XINT (XEXP (value, 0), 1) == 104\n+\t    && XINT (XEXP (value, 0), 1) == UNSPEC_LTREL_OFFSET\n \t    && XVECLEN (XEXP (value, 0), 0) == 1)\n \t  {\n \t    value = gen_rtx_MINUS (Pmode, XVECEXP (XEXP (value, 0), 0, 0),\n@@ -4547,25 +4446,20 @@ s390_free_pool (pool)\n } \n \n \n-/* Chunkify the literal pool if required.\n-\n-   Code generated by this routine is allowed to use\n-   TEMP_REG as temporary scratch register.  If this is\n-   done, TEMP_USED is set to true.  */\n+/* Chunkify the literal pool if required.  */\n \n #define S390_POOL_CHUNK_MIN\t0xc00\n #define S390_POOL_CHUNK_MAX\t0xe00\n \n static struct constant_pool * \n-s390_chunkify_start (temp_reg, temp_used)\n-     rtx temp_reg;\n-     bool *temp_used;\n+s390_chunkify_start (void)\n {\n   rtx base_reg = gen_rtx_REG (Pmode, BASE_REGISTER);\n \n   struct constant_pool *curr_pool = NULL, *pool_list = NULL;\n   int extra_size = 0;\n   bitmap far_labels;\n+  rtx pending_ltrel = NULL_RTX;\n   rtx insn;\n \n   rtx (*gen_reload_base) PARAMS ((rtx, rtx)) =\n@@ -4581,46 +4475,59 @@ s390_chunkify_start (temp_reg, temp_used)\n \n   shorten_branches (get_insns ());\n \n-  /* Scan all insns and move literals to pool chunks.\n-     Also, emit anchor reload insns before every insn that uses \n-     the literal pool base register as anchor pointer.  */\n+  /* Scan all insns and move literals to pool chunks.  */\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n+      /* Check for pending LTREL_BASE.  */\n+      if (INSN_P (insn))\n+\t{\n+\t  rtx ltrel_base = find_ltrel_base (PATTERN (insn));\n+\t  if (ltrel_base)\n+\t    {\n+\t      if (ltrel_base == pending_ltrel)\n+\t\tpending_ltrel = NULL_RTX;\n+\t      else\n+\t\tabort ();\n+\t    }\n+\t}\n+\n       if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n \t{\n \t  rtx pool_ref = NULL_RTX;\n \t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n \t  if (pool_ref)\n \t    {\n+\t      rtx constant = get_pool_constant (pool_ref);\n+\t      enum machine_mode mode = get_pool_mode (pool_ref);\n+\n \t      if (!curr_pool)\n \t\tcurr_pool = s390_start_pool (&pool_list, insn);\n \n-\t      s390_add_constant (curr_pool, get_pool_constant (pool_ref), \n-\t\t\t\t\t    get_pool_mode (pool_ref));\n+\t      s390_add_constant (curr_pool, constant, mode);\n \t      s390_add_pool_insn (curr_pool, insn);\n-\t    }\n \n-\t  else if (!TARGET_64BIT && flag_pic\n-                   && find_base_register_ref (PATTERN (insn)))\n-\t    {\n-\t      rtx new = gen_reload_anchor (temp_reg, base_reg);\n-\t      new = emit_insn_before (new, insn);\n-\t      INSN_ADDRESSES_NEW (new, INSN_ADDRESSES (INSN_UID (insn)));\n-\t      extra_size += 8;\n-\t      *temp_used = 1;\n-\t      \n-\t      if (!curr_pool)\n-\t\tcurr_pool = s390_start_pool (&pool_list, new);\n-\n-\t      s390_add_anchor (curr_pool);\n-\t      s390_add_pool_insn (curr_pool, insn);\n+\t      /* Don't split the pool chunk between a LTREL_OFFSET load\n+\t\t and the corresponding LTREL_BASE.  */\n+\t      if (GET_CODE (constant) == CONST\n+\t\t  && GET_CODE (XEXP (constant, 0)) == UNSPEC\n+\t\t  && XINT (XEXP (constant, 0), 1) == UNSPEC_LTREL_OFFSET)\n+\t\t{\n+\t\t  if (pending_ltrel)\n+\t\t    abort ();\n+\t\t  pending_ltrel = pool_ref;\n+\t\t}\n \t    }\n \t}\n \n       if (GET_CODE (insn) == JUMP_INSN || GET_CODE (insn) == CODE_LABEL)\n-\tif (curr_pool)\n-\t  s390_add_pool_insn (curr_pool, insn);\n+\t{\n+\t  if (curr_pool)\n+\t    s390_add_pool_insn (curr_pool, insn);\n+\t  /* An LTREL_BASE must follow within the same basic block.  */\n+\t  if (pending_ltrel)\n+\t    abort ();\n+\t}\n \n       if (!curr_pool \n \t  || INSN_ADDRESSES_SIZE () <= (size_t) INSN_UID (insn)\n@@ -4672,10 +4579,9 @@ s390_chunkify_start (temp_reg, temp_used)\n \t      if (get_attr_length (insn) == 0)\n \t\tcontinue;\n \n-\t      /* Don't separate insns created by s390_split_branches.  */\n-\t      if (GET_CODE (insn) == INSN \n-\t\t  && GET_CODE (PATTERN (insn)) == SET\n-\t\t  && rtx_equal_p (SET_DEST (PATTERN (insn)), temp_reg))\n+\t      /* Don't separate LTREL_BASE from the corresponding \n+\t\t LTREL_OFFSET load.  */\n+\t      if (pending_ltrel)\n \t\tcontinue;\n \n  \t      label = gen_label_rtx ();\n@@ -4698,6 +4604,8 @@ s390_chunkify_start (temp_reg, temp_used)\n \n   if (curr_pool)\n     s390_end_pool (curr_pool, NULL_RTX);\n+  if (pending_ltrel)\n+    abort ();\n \n \n   /* Find all labels that are branched into \n@@ -4811,15 +4719,11 @@ s390_chunkify_start (temp_reg, temp_used)\n \n /* POOL_LIST is a chunk list as prepared by s390_chunkify_start.\n    After we have decided to use this list, finish implementing \n-   all changes to the current function as required.\n-\n-   Code generated by this routine is allowed to use\n-   TEMP_REG as temporary scratch register.  */\n+   all changes to the current function as required.  */\n  \n static void\n-s390_chunkify_finish (pool_list, temp_reg)\n+s390_chunkify_finish (pool_list)\n      struct constant_pool *pool_list;\n-     rtx temp_reg;\n {\n   rtx base_reg = gen_rtx_REG (Pmode, BASE_REGISTER);\n   struct constant_pool *curr_pool = NULL;\n@@ -4830,6 +4734,9 @@ s390_chunkify_finish (pool_list, temp_reg)\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn)) \n     {\n+      if (INSN_P (insn))\n+\treplace_ltrel_base (&PATTERN (insn), base_reg);\n+\n       curr_pool = s390_find_pool (pool_list, insn);\n       if (!curr_pool)\n \tcontinue;\n@@ -4846,12 +4753,6 @@ s390_chunkify_finish (pool_list, temp_reg)\n               replace_constant_pool_ref (&PATTERN (insn), pool_ref, addr);\n               INSN_CODE (insn) = -1;\n             }\n-\n-\t  else if (!TARGET_64BIT && flag_pic\n-                   && find_base_register_ref (PATTERN (insn)))\n-\t    {\n-\t      replace_base_register_ref (&PATTERN (insn), temp_reg);\n-\t    }\n         }\n     }\n \n@@ -4906,7 +4807,7 @@ s390_chunkify_cancel (pool_list)\n       remove_insn (curr_pool->pool_insn);\n     }\n \n-  /* Remove all base/anchor register reload insns.  */\n+  /* Remove all base register reload insns.  */\n \n   for (insn = get_insns (); insn; )\n     {\n@@ -4915,8 +4816,7 @@ s390_chunkify_cancel (pool_list)\n       if (GET_CODE (insn) == INSN\n \t  && GET_CODE (PATTERN (insn)) == SET\n \t  && GET_CODE (SET_SRC (PATTERN (insn))) == UNSPEC\n-\t  && (XINT (SET_SRC (PATTERN (insn)), 1) == 210\n-\t      || XINT (SET_SRC (PATTERN (insn)), 1) == 211))\n+\t  && XINT (SET_SRC (PATTERN (insn)), 1) == UNSPEC_RELOAD_BASE)\n \tremove_insn (insn);\n \n       insn = next_insn;\n@@ -5231,7 +5131,7 @@ s390_reorg ()\n       struct constant_pool *pool_list;\n  \n       /* Try to chunkify the literal pool.  */\n-      pool_list = s390_chunkify_start (temp_reg, &temp_used);\n+      pool_list = s390_chunkify_start ();\n \n       /* Split out-of-range branches.  If this has created new\n \t literal pool entries, cancel current chunk list and\n@@ -5262,7 +5162,7 @@ s390_reorg ()\n       /* If we made it up to here, both conditions are satisfied.\n \t Finish up pool chunkification if required.  */\n       if (pool_list)\n-\ts390_chunkify_finish (pool_list, temp_reg);\n+\ts390_chunkify_finish (pool_list);\n  \n       break;\n     }\n@@ -5555,6 +5455,52 @@ restore_gprs (base, offset, first, last)\n   return insn;\n }\n \n+/* Emit code to load the GOT register.  If MAYBE_DEAD is true,\n+   annotate generated insns with REG_MAYBE_DEAD notes.  */\n+\n+static GTY(()) rtx got_symbol;\n+void\n+s390_load_got (maybe_dead)\n+     int maybe_dead;\n+{\n+  if (!got_symbol)\n+    {\n+      got_symbol = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n+      SYMBOL_REF_FLAGS (got_symbol) = SYMBOL_FLAG_LOCAL;\n+    }\n+\n+  if (TARGET_64BIT)\n+    {\n+      rtx insn = emit_move_insn (pic_offset_table_rtx, got_symbol);\n+      if (maybe_dead)\n+        REG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n+                                             REG_NOTES (insn));\n+    }\n+  else\n+    {\n+      rtx offset, insn;\n+\n+      offset = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, got_symbol), \n+\t\t\t       UNSPEC_LTREL_OFFSET);\n+      offset = gen_rtx_CONST (Pmode, offset);\n+      offset = force_const_mem (Pmode, offset);\n+\n+      insn = emit_move_insn (pic_offset_table_rtx, offset);\n+      if (maybe_dead)\n+\tREG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n+\t\t\t\t\t     REG_NOTES (insn));\n+\n+      offset = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, XEXP (offset, 0)), \n+\t\t\t       UNSPEC_LTREL_BASE);\n+      offset = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, offset);\n+\n+      insn = emit_move_insn (pic_offset_table_rtx, offset);\n+      if (maybe_dead)\n+\tREG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n+\t\t\t\t\t     REG_NOTES (insn));\n+    }\n+}\n+\n /* Expand the prologue into a bunch of separate insns.  */\n \n void\n@@ -5724,38 +5670,7 @@ s390_emit_prologue ()\n   /* Set up got pointer, if needed.  */\n   \n   if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n-    {\n-      rtx got_symbol = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n-      SYMBOL_REF_FLAGS (got_symbol) = SYMBOL_FLAG_LOCAL;\n-\n-      if (TARGET_64BIT)\n-\t{\n-\t  insn = emit_insn (gen_movdi (pic_offset_table_rtx,\n-\t\t\t\t       got_symbol));\t\t \n-\n-          /* It can happen that the GOT pointer isn't really needed ...  */\n-          REG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n-                                               REG_NOTES (insn));\n-\t}\n-      else\n-\t{\n-          got_symbol = gen_rtx_UNSPEC (VOIDmode, \n-\t\t\t\t       gen_rtvec (1, got_symbol), 100);\n-          got_symbol = gen_rtx_CONST (VOIDmode, got_symbol);\n-\t  got_symbol = force_const_mem (Pmode, got_symbol);\n-\t  insn = emit_move_insn (pic_offset_table_rtx,\n-\t\t\t\t got_symbol);\t\t \n-          REG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n-                                               REG_NOTES (insn));\n-\n-          got_symbol = gen_rtx_REG (Pmode, BASE_REGISTER);\n-          got_symbol = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, got_symbol), 101);\n-          got_symbol = gen_rtx_PLUS (Pmode, got_symbol, pic_offset_table_rtx);\n-\t  insn = emit_move_insn (pic_offset_table_rtx, got_symbol);\n-          REG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n-                                               REG_NOTES (insn));\n-\t}\n-    }      \n+    s390_load_got (true);\n }\n \n /* Expand the epilogue into a bunch of separate insns.  */\n@@ -6649,7 +6564,7 @@ s390_function_profiler (file, labelno)\n   op[4] = gen_rtx_SYMBOL_REF (Pmode, \"_mcount\");\n   if (flag_pic)\n     {\n-      op[4] = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op[4]), 113);\n+      op[4] = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op[4]), UNSPEC_PLT);\n       op[4] = gen_rtx_CONST (Pmode, op[4]);\n     }\n \n@@ -6749,7 +6664,7 @@ s390_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n     {\n       nonlocal = 1;\n       op[0] = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op[0]),\n-\t\t\t      TARGET_64BIT ? 113 : flag_pic == 2 ? 112 : 110);\n+\t\t\t      TARGET_64BIT ? UNSPEC_PLT : UNSPEC_GOT);\n       op[0] = gen_rtx_CONST (Pmode, op[0]);\n     }\n "}, {"sha": "e5807027652c9744c4ed9a7b8be0d072ecb8cd3f", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 95, "deletions": 102, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7643fbe49e24ba9553f28b0548f4e525b43001/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7643fbe49e24ba9553f28b0548f4e525b43001/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=fd7643fbe49e24ba9553f28b0548f4e525b43001", "patch": "@@ -50,7 +50,19 @@\n ;;\n \n (define_constants\n-  [; TLS relocation specifiers\n+  [; GOT/PLT and lt-relative accesses\n+   (UNSPEC_LTREL_OFFSET\t\t100)\n+   (UNSPEC_LTREL_BASE\t\t101)\n+   (UNSPEC_GOTENT\t\t110)\n+   (UNSPEC_GOT\t\t\t111)\n+   (UNSPEC_GOTOFF\t\t112)\n+   (UNSPEC_PLT\t\t\t113)\n+   (UNSPEC_PLTOFF\t\t114)\n+\n+   ; Literal pool\n+   (UNSPEC_RELOAD_BASE\t\t210)\n+\n+   ; TLS relocation specifiers\n    (UNSPEC_TLSGD\t\t500)\n    (UNSPEC_TLSLDM\t\t501)\n    (UNSPEC_NTPOFF               502)\n@@ -69,7 +81,20 @@\n ;;\n \n (define_constants\n-  [; TLS support\n+  [; Literal pool\n+   (UNSPECV_POOL\t\t200)\n+   (UNSPECV_POOL_START\t\t201)\n+   (UNSPECV_POOL_END\t\t202)\n+   (UNSPECV_POOL_QI\t\t203)\n+   (UNSPECV_POOL_HI\t\t204)\n+   (UNSPECV_POOL_SI\t\t205)\n+   (UNSPECV_POOL_DI\t\t206)\n+   (UNSPECV_POOL_TI\t\t207)\n+   (UNSPECV_POOL_SF\t\t208)\n+   (UNSPECV_POOL_DF\t\t209)\n+   (UNSPECV_MAIN_POOL\t\t300)\n+\n+   ; TLS support\n    (UNSPECV_SET_TP\t\t500)\n   ])\n \n@@ -6382,7 +6407,6 @@\n   \"\"\n   \"\n {\n-  int plt_call = 0;\n   rtx insn;\n \n   /* Direct function calls need special treatment.  */\n@@ -6394,34 +6418,26 @@\n          replace the symbol itself with the PLT stub.  */\n       if (flag_pic && !SYMBOL_REF_LOCAL_P (sym))\n         {\n-          sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), 113);\n+          sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), UNSPEC_PLT);\n           sym = gen_rtx_CONST (Pmode, sym);\n-\n-\t  plt_call = 1;\n         }\n \n       /* Unless we can use the bras(l) insn, force the \n          routine address into a register.  */\n       if (!TARGET_SMALL_EXEC && !TARGET_64BIT)\n-        {\n-          rtx target = gen_reg_rtx (Pmode);\n-          emit_move_insn (target, sym);\n-          sym = target;\n-        }\n+\t{\n+\t  if (flag_pic)\n+\t    sym = legitimize_pic_address (sym, 0);\n+\t  else\n+\t    sym = force_reg (Pmode, sym);\n+\t}\n \n       operands[0] = gen_rtx_MEM (QImode, sym);\n     }\n \n   /* Emit insn.  */\n   insn = emit_call_insn (gen_call_exp (operands[0], operands[1],\n   \t\t\t\t       gen_rtx_REG (Pmode, RETURN_REGNUM)));\n-\n-  /* In 31-bit, we must load the GOT register even if the \n-     compiler doesn't know about it, because the PLT glue \n-     code uses it.  In 64-bit, this is not necessary.  */\n-  if (plt_call && !TARGET_64BIT)\n-    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n-\n   DONE;\n }\")\n \n@@ -6501,7 +6517,6 @@\n   \"\"\n   \"\n {\n-  int plt_call = 0;\n   rtx insn;\n \n   /* Direct function calls need special treatment.  */\n@@ -6513,19 +6528,18 @@\n          replace the symbol itself with the PLT stub.  */\n       if (flag_pic && !SYMBOL_REF_LOCAL_P (sym))\n         {\n-          sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), 113);\n+          sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), UNSPEC_PLT);\n           sym = gen_rtx_CONST (Pmode, sym);\n-\n-\t  plt_call = 1;\n         }\n \n       /* Unless we can use the bras(l) insn, force the \n          routine address into a register.  */\n       if (!TARGET_SMALL_EXEC && !TARGET_64BIT)\n         {\n-          rtx target = gen_reg_rtx (Pmode);\n-          emit_move_insn (target, sym);\n-          sym = target;\n+\t  if (flag_pic)\n+\t    sym = legitimize_pic_address (sym, 0);\n+\t  else\n+\t    sym = force_reg (Pmode, sym);\n         }\n \n       operands[1] = gen_rtx_MEM (QImode, sym);\n@@ -6535,13 +6549,6 @@\n   insn = emit_call_insn (\n \t    gen_call_value_exp (operands[0], operands[1], operands[2],\n   \t\t\t\tgen_rtx_REG (Pmode, RETURN_REGNUM)));\n-\n-  /* In 31-bit, we must load the GOT register even if the \n-     compiler doesn't know about it, because the PLT glue \n-     code uses it.  In 64-bit, this is not necessary.  */\n-  if (plt_call && !TARGET_64BIT)\n-    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n-\n   DONE;\n }\")\n \n@@ -6694,16 +6701,17 @@\n     abort ();\n \n   sym = s390_tls_get_offset ();\n-  sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), 113);\n+  sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), UNSPEC_PLT);\n   sym = gen_rtx_CONST (Pmode, sym);\n \n   /* Unless we can use the bras(l) insn, force the \n      routine address into a register.  */\n   if (!TARGET_SMALL_EXEC && !TARGET_64BIT)\n     {\n-      rtx target = gen_reg_rtx (Pmode);\n-      emit_move_insn (target, sym);\n-      sym = target;\n+      if (flag_pic)\n+\tsym = legitimize_pic_address (sym, 0);\n+      else\n+\tsym = force_reg (Pmode, sym);\n     }\n \n   sym = gen_rtx_MEM (QImode, sym);\n@@ -6840,43 +6848,36 @@\n ;\n \n (define_expand \"builtin_setjmp_setup\"\n-  [(unspec [(match_operand 0 \"register_operand\" \"a\")] 1)]\n+  [(match_operand 0 \"register_operand\" \"\")]\n   \"\"\n-  \"\n {\n   rtx base = gen_rtx_MEM (Pmode, plus_constant (operands[0], 4 * GET_MODE_SIZE (Pmode)));\n   rtx basereg = gen_rtx_REG (Pmode, BASE_REGISTER);\n \n   emit_move_insn (base, basereg);\n   DONE;\n-}\")\n+})\n \n (define_expand \"builtin_setjmp_receiver\"\n-  [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] 2)]\n+  [(match_operand 0 \"\" \"\")]\n   \"flag_pic\"\n-  \"\n {\n-  rtx gotreg = gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM);\n-  rtx got = gen_rtx_SYMBOL_REF (Pmode, \\\"_GLOBAL_OFFSET_TABLE_\\\");\n-  SYMBOL_REF_FLAGS (got) = SYMBOL_FLAG_LOCAL;\n-\n-  emit_move_insn (gotreg, got);\n-  emit_insn (gen_rtx_USE (VOIDmode, gotreg));\n+  s390_load_got (false);\n+  emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n   DONE;\n-}\")\n+})\n \n (define_expand \"builtin_longjmp\"\n-  [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")] 3)]\n+  [(match_operand 0 \"register_operand\" \"\")]\n   \"\"\n-  \"\n {\n   /* The elements of the buffer are, in order:  */\n   rtx fp = gen_rtx_MEM (Pmode, operands[0]);\n   rtx lab = gen_rtx_MEM (Pmode, plus_constant (operands[0], GET_MODE_SIZE (Pmode)));\n   rtx stack = gen_rtx_MEM (Pmode, plus_constant (operands[0], 2 * GET_MODE_SIZE (Pmode)));\n   rtx base = gen_rtx_MEM (Pmode, plus_constant (operands[0], 4 * GET_MODE_SIZE (Pmode)));\n   rtx basereg = gen_rtx_REG (Pmode, BASE_REGISTER);\n-  rtx jmp = gen_rtx_REG (Pmode, 14);\n+  rtx jmp = gen_reg_rtx (Pmode);\n \n   emit_move_insn (jmp, lab);\n   emit_move_insn (basereg, base);\n@@ -6888,7 +6889,7 @@\n   emit_insn (gen_rtx_USE (VOIDmode, basereg));\n   emit_indirect_jump (jmp);\n   DONE;\n-}\")\n+})\n \n \n ;; These patterns say how to save and restore the stack pointer.  We need not\n@@ -6979,56 +6980,58 @@\n ;\n \n (define_insn \"consttable_qi\"\n-  [(unspec_volatile [(match_operand:QI 0 \"consttable_operand\" \"X\")] 200)]\n+  [(unspec_volatile [(match_operand:QI 0 \"consttable_operand\" \"X\")] \n+\t\t    UNSPECV_POOL_QI)]\n   \"\"\n-  \"*\n {\n   assemble_integer (operands[0], 1, BITS_PER_UNIT, 1);\n-  return \\\"\\\";\n-}\"\n+  return \"\";\n+}\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"1\")])\n \n (define_insn \"consttable_hi\"\n-  [(unspec_volatile [(match_operand:HI 0 \"consttable_operand\" \"X\")] 201)]\n+  [(unspec_volatile [(match_operand:HI 0 \"consttable_operand\" \"X\")] \n+\t\t    UNSPECV_POOL_HI)]\n   \"\"\n-  \"*\n {\n   assemble_integer (operands[0], 2, 2*BITS_PER_UNIT, 1);\n-  return \\\"\\\";\n-}\"\n+  return \"\";\n+}\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"2\")])\n \n (define_insn \"consttable_si\"\n-  [(unspec_volatile [(match_operand:SI 0 \"consttable_operand\" \"X\")] 202)]\n+  [(unspec_volatile [(match_operand:SI 0 \"consttable_operand\" \"X\")] \n+\t\t    UNSPECV_POOL_SI)]\n   \"\"\n-  \"*\n-{\n-  if (!TARGET_64BIT && flag_pic && SYMBOLIC_CONST (operands[0]))\n-    return \\\".long\\\\t%0\\\";\n-\n-  assemble_integer (operands[0], 4, 4*BITS_PER_UNIT, 1);\n-  return \\\"\\\";\n-}\"\n+  \".long\\t%0\"\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"4\")])\n \n (define_insn \"consttable_di\"\n-  [(unspec_volatile [(match_operand:DI 0 \"consttable_operand\" \"X\")] 203)]\n+  [(unspec_volatile [(match_operand:DI 0 \"consttable_operand\" \"X\")] \n+\t\t    UNSPECV_POOL_DI)]\n   \"\"\n-  \"*\n-{\n-  assemble_integer (operands[0], 8, 8*BITS_PER_UNIT, 1);\n-  return \\\"\\\";\n-}\"\n+  \".quad\\t%0\"\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"8\")])\n \n+(define_insn \"consttable_ti\"\n+  [(unspec_volatile [(match_operand:TI 0 \"consttable_operand\" \"X\")] \n+\t\t    UNSPECV_POOL_TI)]\n+  \"\"\n+{\n+  assemble_integer (operands[0], 16, 16*BITS_PER_UNIT, 1);\n+  return \"\";\n+}\n+  [(set_attr \"op_type\"  \"NN\")\n+   (set_attr \"length\"   \"16\")])\n+\n (define_insn \"consttable_sf\"\n-  [(unspec_volatile [(match_operand:SF 0 \"consttable_operand\" \"X\")] 204)]\n+  [(unspec_volatile [(match_operand:SF 0 \"consttable_operand\" \"X\")] \n+\t\t    UNSPECV_POOL_SF)]\n   \"\"\n-  \"*\n {\n   REAL_VALUE_TYPE r;\n \n@@ -7037,15 +7040,15 @@\n \n   REAL_VALUE_FROM_CONST_DOUBLE (r, operands[0]);\n   assemble_real (r, SFmode, 4*BITS_PER_UNIT);\n-  return \\\"\\\";\n-}\"\n+  return \"\";\n+}\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"4\")])\n \n (define_insn \"consttable_df\"\n-  [(unspec_volatile [(match_operand:DF 0 \"consttable_operand\" \"X\")] 205)]\n+  [(unspec_volatile [(match_operand:DF 0 \"consttable_operand\" \"X\")]\n+\t\t    UNSPECV_POOL_DF)]\n   \"\"\n-  \"*\n {\n   REAL_VALUE_TYPE r;\n \n@@ -7054,42 +7057,42 @@\n \n   REAL_VALUE_FROM_CONST_DOUBLE (r, operands[0]);\n   assemble_real (r, DFmode, 8*BITS_PER_UNIT);\n-  return \\\"\\\";\n-}\"\n+  return \"\";\n+}\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"8\")])\n \n (define_insn \"pool_start_31\"\n-  [(unspec_volatile [(const_int 0)] 206)]\n+  [(unspec_volatile [(const_int 0)] UNSPECV_POOL_START)]\n   \"!TARGET_64BIT\"\n   \".align\\\\t4\"\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"2\")])\n \n (define_insn \"pool_end_31\"\n-  [(unspec_volatile [(const_int 0)] 207)]\n+  [(unspec_volatile [(const_int 0)] UNSPECV_POOL_END)]\n   \"!TARGET_64BIT\"\n   \".align\\\\t2\"\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"2\")])\n \n (define_insn \"pool_start_64\"\n-  [(unspec_volatile [(const_int 0)] 206)]\n+  [(unspec_volatile [(const_int 0)] UNSPECV_POOL_START)]\n   \"TARGET_64BIT\"\n   \".section\\\\t.rodata\\;.align\\\\t8\"\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"0\")])\n \n (define_insn \"pool_end_64\"\n-  [(unspec_volatile [(const_int 0)] 207)]\n+  [(unspec_volatile [(const_int 0)] UNSPECV_POOL_END)]\n   \"TARGET_64BIT\"\n   \".previous\"\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"0\")])\n \n (define_insn \"reload_base_31\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-        (unspec:SI [(label_ref (match_operand 1 \"\" \"\"))] 210))]\n+        (unspec:SI [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_RELOAD_BASE))]\n   \"!TARGET_64BIT\"\n   \"basr\\\\t%0,0\\;la\\\\t%0,%1-.(%0)\"\n   [(set_attr \"op_type\" \"NN\")\n@@ -7098,24 +7101,14 @@\n \n (define_insn \"reload_base_64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n-        (unspec:DI [(label_ref (match_operand 1 \"\" \"\"))] 210))]\n+        (unspec:DI [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_RELOAD_BASE))]\n   \"TARGET_64BIT\"\n   \"larl\\\\t%0,%1\"\n   [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"    \"larl\")])\n \n-(define_insn \"reload_anchor\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-        (unspec:SI [(match_operand:SI 1 \"register_operand\" \"a\")] 211))]\n-  \"!TARGET_64BIT\"\n-  \"l\\\\t%0,0(%1)\\;la\\\\t%0,0(%0,%1)\"\n-  [(set_attr \"op_type\" \"NN\")\n-   (set_attr \"type\"    \"la\")\n-   (set_attr \"atype\"   \"agen\")\n-   (set_attr \"length\"  \"8\")])\n-\n (define_insn \"pool\"\n-  [(unspec_volatile [(match_operand 0 \"const_int_operand\" \"n\")] 220)]\n+  [(unspec_volatile [(match_operand 0 \"const_int_operand\" \"n\")] UNSPECV_POOL)]\n   \"\"\n   \"* abort ();\"\n   [(set_attr \"op_type\" \"NN\")\n@@ -7164,7 +7157,7 @@\n    (set_attr \"atype\"   \"agen\")])\n \n (define_insn \"literal_pool_31\"\n-  [(unspec_volatile [(const_int 0)] 300)\n+  [(unspec_volatile [(const_int 0)] UNSPECV_MAIN_POOL)\n    (set (match_operand:SI 0 \"register_operand\" \"=a\") \n         (label_ref (match_operand 1 \"\" \"\")))\t\n    (use (label_ref (match_operand 2 \"\" \"\")))]\n@@ -7188,7 +7181,7 @@\n    (set_attr \"type\"    \"larl\")])\n \n (define_insn \"literal_pool_64\"\n-  [(unspec_volatile [(const_int 0)] 300)\n+  [(unspec_volatile [(const_int 0)] UNSPECV_MAIN_POOL)\n    (set (match_operand:DI 0 \"register_operand\" \"=a\") \n         (label_ref (match_operand 1 \"\" \"\")))\t\n    (use (label_ref (match_operand 2 \"\" \"\")))]"}]}