{"sha": "e86a02f87d8a11480c1421ef2dd71b8b5f43d938", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg2YTAyZjg3ZDhhMTE0ODBjMTQyMWVmMmRkNzFiOGI1ZjQzZDkzOA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-09-24T10:52:30Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-09-24T10:52:30Z"}, "message": "This patch fixes PR96495 - frees result components outside loop.\n\n2020-24-09  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/96495\n\t* trans-expr.c (gfc_conv_procedure_call): Take the deallocation\n\tof allocatable result components of a scalar result outside the\n\tscalarization loop. Find and use the stored result.\n\ngcc/testsuite/\n\tPR fortran/96495\n\t* gfortran.dg/alloc_comp_result_2.f90 : New test.", "tree": {"sha": "87dd382f6a75e535a9fc6570dc85b3dc74b2d83a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87dd382f6a75e535a9fc6570dc85b3dc74b2d83a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e86a02f87d8a11480c1421ef2dd71b8b5f43d938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86a02f87d8a11480c1421ef2dd71b8b5f43d938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e86a02f87d8a11480c1421ef2dd71b8b5f43d938", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86a02f87d8a11480c1421ef2dd71b8b5f43d938/comments", "author": null, "committer": null, "parents": [{"sha": "fe28d34079aad7d3bf8d9bfd78d0ba43110b7906", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe28d34079aad7d3bf8d9bfd78d0ba43110b7906", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe28d34079aad7d3bf8d9bfd78d0ba43110b7906"}], "stats": {"total": 119, "additions": 95, "deletions": 24}, "files": [{"sha": "a690839f591f794c0d215a4617ff3baae2a89d8b", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a02f87d8a11480c1421ef2dd71b8b5f43d938/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a02f87d8a11480c1421ef2dd71b8b5f43d938/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=e86a02f87d8a11480c1421ef2dd71b8b5f43d938", "patch": "@@ -6421,6 +6421,26 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t  if (!finalized && !e->must_finalize)\n \t    {\n+\t      bool scalar_res_outside_loop;\n+\t      scalar_res_outside_loop = e->expr_type == EXPR_FUNCTION\n+\t\t\t\t\t&& parm_rank == 0\n+\t\t\t\t\t&& parmse.loop;\n+\n+\t      if (scalar_res_outside_loop)\n+\t\t{\n+\t\t  /* Go through the ss chain to find the argument and use\n+\t\t     the stored value.  */\n+\t\t  gfc_ss *tmp_ss = parmse.loop->ss;\n+\t\t  for (; tmp_ss; tmp_ss = tmp_ss->next)\n+\t\t    if (tmp_ss->info\n+\t\t\t&& tmp_ss->info->expr == e\n+\t\t\t&& tmp_ss->info->data.scalar.value != NULL_TREE)\n+\t\t      {\n+\t\t\ttmp = tmp_ss->info->data.scalar.value;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t}\n+\n \t      if ((e->ts.type == BT_CLASS\n \t\t   && GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))\n \t\t  || e->ts.type == BT_DERIVED)\n@@ -6429,7 +6449,11 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      else if (e->ts.type == BT_CLASS)\n \t\ttmp = gfc_deallocate_alloc_comp (CLASS_DATA (e)->ts.u.derived,\n \t\t\t\t\t\t tmp, parm_rank);\n-\t      gfc_prepend_expr_to_block (&post, tmp);\n+\n+\t      if (scalar_res_outside_loop)\n+\t\tgfc_add_expr_to_block (&parmse.loop->post, tmp);\n+\t      else\n+\t\tgfc_prepend_expr_to_block (&post, tmp);\n \t    }\n         }\n "}, {"sha": "6b0918715d77018c19376614ba26397d4937b70d", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_result_2.f90", "status": "modified", "additions": 70, "deletions": 23, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a02f87d8a11480c1421ef2dd71b8b5f43d938/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_result_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a02f87d8a11480c1421ef2dd71b8b5f43d938/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_result_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_result_2.f90?ref=e86a02f87d8a11480c1421ef2dd71b8b5f43d938", "patch": "@@ -1,28 +1,75 @@\n ! { dg-do run }\n-! Tests the fix for PR40440, in which gfortran tried to deallocate\n-! the allocatable components of the actual argument of CALL SUB\n !\n-! Contributed by Juergen Reuter <juergen.reuter@desy.de>\n-! Reduced testcase from Tobias Burnus  <burnus@gcc.gnu.org> \n+! Test the fix for PR96495 - segfaults at runtime at locations below.\n !\n+! Contributed by Paul Luckner  <paul.luckner@rwth-aachen.de>\n+!\n+module foo_m\n+\n   implicit none\n-  type t\n-    integer, allocatable :: A(:)\n-  end type t\n-  type (t) :: arg\n-  arg = t ([1,2,3])\n-  call sub (func (arg))\n+\n+  type foo\n+    integer, allocatable :: j(:)\n+  end type\n+\n+  interface operator(.unary.)\n+    module procedure neg_foo\n+  end interface\n+\n+  interface operator(.binary.)\n+    module procedure foo_sub_foo\n+  end interface\n+\n+  interface operator(.binaryElemental.)\n+    module procedure foo_add_foo\n+  end interface\n+\n contains\n-  function func (a)\n-    type(t), pointer :: func\n-    type(t), target :: a\n-    integer, save :: i = 0\n-    if (i /= 0) STOP 1! multiple calls would cause this abort\n-    i = i + 1\n-    func => a\n-  end function func\n-  subroutine sub (a)\n-    type(t), intent(IN), target :: a\n-    if (any (a%A .ne. [1,2,3])) STOP 2\n-  end subroutine sub\n-end\n+\n+  elemental function foo_add_foo(f, g) result(h)\n+    !! an example for an elemental binary operator\n+    type(foo), intent(in) :: f, g\n+    type(foo)             :: h\n+\n+    allocate (h%j(size(f%j)), source = f%j+g%j)\n+  end function\n+\n+  elemental function foo_sub_foo(f, g) result(h)\n+    !! an example for an elemental binary operator\n+    type(foo), intent(in) :: f, g\n+    type(foo)             :: h\n+\n+    allocate (h%j(size(f%j)), source = f%j-3*g%j)\n+  end function\n+\n+  pure function neg_foo(f) result(g)\n+    !! an example for a unary operator\n+    type(foo), intent(in) :: f\n+    type(foo)             :: g\n+\n+    allocate (g%j(size(f%j)), source = -f%j)\n+  end function\n+\n+end module\n+\n+program main_tmp\n+\n+  use foo_m\n+\n+  implicit none\n+\n+  type(foo) f, g(2)\n+\n+  allocate (f%j(3))\n+  f%j = [2, 3, 4]\n+\n+  g = f\n+  if (any (g(2)%j .ne. [2, 3, 4])) stop 1\n+\n+  g = g .binaryElemental. (f .binary. f)     ! threw \"Segmentation fault\"\n+  if (any (g(2)%j .ne. [-2,-3,-4])) stop 2\n+\n+  g = g .binaryElemental. (  .unary.  f)     ! threw \"Segmentation fault\"\n+  if (any (g(2)%j .ne. [-4,-6,-8])) stop 3\n+\n+end program\n\\ No newline at end of file"}]}