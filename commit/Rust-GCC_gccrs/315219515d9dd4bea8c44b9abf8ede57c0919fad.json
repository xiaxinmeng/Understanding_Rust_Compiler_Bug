{"sha": "315219515d9dd4bea8c44b9abf8ede57c0919fad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE1MjE5NTE1ZDlkZDRiZWE4YzQ0YjlhYmY4ZWRlNTdjMDkxOWZhZA==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2015-06-26T22:35:29Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2015-06-26T22:35:29Z"}, "message": "c-common.c (check_main_parameter_types): Use VECTOR_TYPE_P or VECTOR_INTEGER_TYPE_P throughout.\n\n\t* c-common.c (check_main_parameter_types): Use VECTOR_TYPE_P\n\tor VECTOR_INTEGER_TYPE_P throughout.\n\t* c-gimplify.c: Likewise.\n\n\t* c-typeck.c: Use VECTOR_TYPE_P throughout.\n\nFrom-SVN: r225089", "tree": {"sha": "70d92b04f77e22e6df12fd0af70cce94eb8462dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70d92b04f77e22e6df12fd0af70cce94eb8462dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/315219515d9dd4bea8c44b9abf8ede57c0919fad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315219515d9dd4bea8c44b9abf8ede57c0919fad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/315219515d9dd4bea8c44b9abf8ede57c0919fad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315219515d9dd4bea8c44b9abf8ede57c0919fad/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e0ff153d398cdeb1864aa64f0045091c8bb2de98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0ff153d398cdeb1864aa64f0045091c8bb2de98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0ff153d398cdeb1864aa64f0045091c8bb2de98"}], "stats": {"total": 47, "additions": 27, "deletions": 20}, "files": [{"sha": "ffad035ffefa87b8e86cdea69dc3825ca768d39a", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315219515d9dd4bea8c44b9abf8ede57c0919fad/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315219515d9dd4bea8c44b9abf8ede57c0919fad/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=315219515d9dd4bea8c44b9abf8ede57c0919fad", "patch": "@@ -1,3 +1,9 @@\n+2015-06-27  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-common.c (check_main_parameter_types): Use VECTOR_TYPE_P\n+\tor VECTOR_INTEGER_TYPE_P throughout.\n+\t* c-gimplify.c: Likewise.\n+\n 2015-06-26  Marek Polacek  <polacek@redhat.com>\n \n \t* array-notation-common.c (find_rank): Use INDIRECT_REF_P."}, {"sha": "06d2abcd451fd799f5593eebfe8eb5d682144afb", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315219515d9dd4bea8c44b9abf8ede57c0919fad/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315219515d9dd4bea8c44b9abf8ede57c0919fad/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=315219515d9dd4bea8c44b9abf8ede57c0919fad", "patch": "@@ -2412,7 +2412,7 @@ check_main_parameter_types (tree decl)\n bool\n vector_targets_convertible_p (const_tree t1, const_tree t2)\n {\n-  if (TREE_CODE (t1) == VECTOR_TYPE && TREE_CODE (t2) == VECTOR_TYPE\n+  if (VECTOR_TYPE_P (t1) && VECTOR_TYPE_P (t2)\n       && (TYPE_VECTOR_OPAQUE (t1) || TYPE_VECTOR_OPAQUE (t2))\n       && tree_int_cst_equal (TYPE_SIZE (t1), TYPE_SIZE (t2)))\n     return true;\n@@ -2500,17 +2500,16 @@ c_build_vec_perm_expr (location_t loc, tree v0, tree v1, tree mask,\n       || mask == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (TREE_TYPE (mask)) != VECTOR_TYPE\n-      || TREE_CODE (TREE_TYPE (TREE_TYPE (mask))) != INTEGER_TYPE)\n+  if (!VECTOR_INTEGER_TYPE_P (TREE_TYPE (mask)))\n     {\n       if (complain)\n \terror_at (loc, \"__builtin_shuffle last argument must \"\n \t\t       \"be an integer vector\");\n       return error_mark_node;\n     }\n \n-  if (TREE_CODE (TREE_TYPE (v0)) != VECTOR_TYPE\n-      || TREE_CODE (TREE_TYPE (v1)) != VECTOR_TYPE)\n+  if (!VECTOR_TYPE_P (TREE_TYPE (v0))\n+      || !VECTOR_TYPE_P (TREE_TYPE (v1)))\n     {\n       if (complain)\n \terror_at (loc, \"__builtin_shuffle arguments must be vectors\");\n@@ -12482,7 +12481,7 @@ convert_vector_to_pointer_for_subscript (location_t loc,\n \t\t\t\t\t tree *vecp, tree index)\n {\n   bool ret = false;\n-  if (TREE_CODE (TREE_TYPE (*vecp)) == VECTOR_TYPE)\n+  if (VECTOR_TYPE_P (TREE_TYPE (*vecp)))\n     {\n       tree type = TREE_TYPE (*vecp);\n       tree type1;\n@@ -12548,8 +12547,7 @@ scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1,\n   bool integer_only_op = false;\n   enum stv_conv ret = stv_firstarg;\n \n-  gcc_assert (TREE_CODE (type0) == VECTOR_TYPE\n-\t      || TREE_CODE (type1) == VECTOR_TYPE);\n+  gcc_assert (VECTOR_TYPE_P (type0) || VECTOR_TYPE_P (type1));\n   switch (code)\n     {\n       /* Most GENERIC binary expressions require homogeneous arguments.\n@@ -12599,7 +12597,7 @@ scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1,\n       case LT_EXPR:\n       case GT_EXPR:\n       /* What about UNLT_EXPR?  */\n-\tif (TREE_CODE (type0) == VECTOR_TYPE)\n+\tif (VECTOR_TYPE_P (type0))\n \t  {\n \t    ret = stv_secondarg;\n \t    std::swap (type0, type1);"}, {"sha": "98a6d53c9d314162b20aa1eafa18e01fa11225b4", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315219515d9dd4bea8c44b9abf8ede57c0919fad/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315219515d9dd4bea8c44b9abf8ede57c0919fad/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=315219515d9dd4bea8c44b9abf8ede57c0919fad", "patch": "@@ -248,7 +248,7 @@ c_gimplify_expr (tree *expr_p, gimple_seq *pre_p ATTRIBUTE_UNUSED,\n \t   We should get rid of this conversion when we have a proper\n \t   type demotion/promotion pass.  */\n \ttree *op1_p = &TREE_OPERAND (*expr_p, 1);\n-\tif (TREE_CODE (TREE_TYPE (*op1_p)) != VECTOR_TYPE\n+\tif (!VECTOR_TYPE_P (TREE_TYPE (*op1_p))\n \t    && !types_compatible_p (TYPE_MAIN_VARIANT (TREE_TYPE (*op1_p)),\n \t\t\t\t    unsigned_type_node)\n \t    && !types_compatible_p (TYPE_MAIN_VARIANT (TREE_TYPE (*op1_p)),"}, {"sha": "edba3f1f51b696104d5bae3aebe166ffcbf2ea41", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315219515d9dd4bea8c44b9abf8ede57c0919fad/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315219515d9dd4bea8c44b9abf8ede57c0919fad/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=315219515d9dd4bea8c44b9abf8ede57c0919fad", "patch": "@@ -1,3 +1,7 @@\n+2015-06-27  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-typeck.c: Use VECTOR_TYPE_P throughout.\n+\n 2015-06-26  Marek Polacek  <polacek@redhat.com>\n \n \t* c-array-notation.c (fix_builtin_array_notation_fn): Use"}, {"sha": "8e2696a7a212628c1bed4b298678b6cce5be681f", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315219515d9dd4bea8c44b9abf8ede57c0919fad/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315219515d9dd4bea8c44b9abf8ede57c0919fad/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=315219515d9dd4bea8c44b9abf8ede57c0919fad", "patch": "@@ -2457,7 +2457,7 @@ build_array_ref (location_t loc, tree array, tree index)\n   if (TREE_CODE (TREE_TYPE (array)) != ARRAY_TYPE\n       && TREE_CODE (TREE_TYPE (array)) != POINTER_TYPE\n       /* Allow vector[index] but not index[vector].  */\n-      && TREE_CODE (TREE_TYPE (array)) != VECTOR_TYPE)\n+      && !VECTOR_TYPE_P (TREE_TYPE (array)))\n     {\n       if (TREE_CODE (TREE_TYPE (index)) != ARRAY_TYPE\n \t  && TREE_CODE (TREE_TYPE (index)) != POINTER_TYPE)\n@@ -6729,7 +6729,7 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n      vector constructor is not constant (e.g. {1,2,3,foo()}) then punt\n      below and handle as a constructor.  */\n   if (code == VECTOR_TYPE\n-      && TREE_CODE (TREE_TYPE (inside_init)) == VECTOR_TYPE\n+      && VECTOR_TYPE_P (TREE_TYPE (inside_init))\n       && vector_types_convertible_p (TREE_TYPE (inside_init), type, true)\n       && TREE_CONSTANT (inside_init))\n     {\n@@ -7180,7 +7180,7 @@ really_start_incremental_init (tree type)\n   if (type == 0)\n     type = TREE_TYPE (constructor_decl);\n \n-  if (TREE_CODE (type) == VECTOR_TYPE\n+  if (VECTOR_TYPE_P (type)\n       && TYPE_VECTOR_OPAQUE (type))\n     error (\"opaque vector types cannot be initialized\");\n \n@@ -7266,7 +7266,7 @@ really_start_incremental_init (tree type)\n \n       constructor_unfilled_index = constructor_index;\n     }\n-  else if (TREE_CODE (constructor_type) == VECTOR_TYPE)\n+  else if (VECTOR_TYPE_P (constructor_type))\n     {\n       /* Vectors are like simple fixed-size arrays.  */\n       constructor_max_index =\n@@ -7439,7 +7439,7 @@ push_init_level (location_t loc, int implicit,\n       constructor_unfilled_fields = constructor_fields;\n       constructor_bit_index = bitsize_zero_node;\n     }\n-  else if (TREE_CODE (constructor_type) == VECTOR_TYPE)\n+  else if (VECTOR_TYPE_P (constructor_type))\n     {\n       /* Vectors are like simple fixed-size arrays.  */\n       constructor_max_index =\n@@ -7619,7 +7619,7 @@ pop_init_level (location_t loc, int implicit,\n   else if (TREE_CODE (constructor_type) != RECORD_TYPE\n \t   && TREE_CODE (constructor_type) != UNION_TYPE\n \t   && TREE_CODE (constructor_type) != ARRAY_TYPE\n-\t   && TREE_CODE (constructor_type) != VECTOR_TYPE)\n+\t   && !VECTOR_TYPE_P (constructor_type))\n     {\n       /* A nonincremental scalar initializer--just return\n \t the element, after verifying there is just one.  */\n@@ -8769,7 +8769,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t\t\t      pop_init_level (loc, 1, braced_init_obstack),\n \t\t\t      true, braced_init_obstack);\n       else if ((TREE_CODE (constructor_type) == ARRAY_TYPE\n-\t        || TREE_CODE (constructor_type) == VECTOR_TYPE)\n+\t\t|| VECTOR_TYPE_P (constructor_type))\n \t       && constructor_max_index\n \t       && tree_int_cst_lt (constructor_max_index,\n \t\t\t\t   constructor_index))\n@@ -9039,7 +9039,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t       constructor_unfilled_index.  */\n \t    constructor_unfilled_index = constructor_index;\n \t}\n-      else if (TREE_CODE (constructor_type) == VECTOR_TYPE)\n+      else if (VECTOR_TYPE_P (constructor_type))\n \t{\n \t  tree elttype = TYPE_MAIN_VARIANT (TREE_TYPE (constructor_type));\n \n@@ -10302,8 +10302,7 @@ build_binary_op (location_t location, enum tree_code code,\n \n   /* Do not apply default conversion in mixed vector/scalar expression.  */\n   if (convert_p\n-      && !((TREE_CODE (TREE_TYPE (op0)) == VECTOR_TYPE)\n-\t   != (TREE_CODE (TREE_TYPE (op1)) == VECTOR_TYPE)))\n+      && VECTOR_TYPE_P (TREE_TYPE (op0)) == VECTOR_TYPE_P (TREE_TYPE (op1)))\n     {\n       op0 = default_conversion (op0);\n       op1 = default_conversion (op1);"}]}