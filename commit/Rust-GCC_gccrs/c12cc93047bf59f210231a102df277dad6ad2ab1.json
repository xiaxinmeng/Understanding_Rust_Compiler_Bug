{"sha": "c12cc93047bf59f210231a102df277dad6ad2ab1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzEyY2M5MzA0N2JmNTlmMjEwMjMxYTEwMmRmMjc3ZGFkNmFkMmFiMQ==", "commit": {"author": {"name": "Keith Besaw", "email": "kbesaw@us.ibm.com", "date": "2005-09-06T10:59:58Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2005-09-06T10:59:58Z"}, "message": "common.opt: Add option ftree-vect-loop-version.\n\n        * common.opt: Add option ftree-vect-loop-version.\n        * params.def: Add --param vect-max-version-checks.\n        * doc/invoke.texi: Document ftree-vect-loop-version and\n        --param vect-max-version-checks.\n        * tree-vectorizer.h (_loop_vec_info): Add ptr_mask and\n        may_misalign_stmts and defines for accessors.\n        * tree-vectorizer.c : (new_loop_vec_info): VEC_alloc for\n        LOOP_VINFO_MAY_MISALIGN_STMTS.\n        (destroy_loop_vec_info): VEC_free for\n        LOOP_VINFO_MAY_MISALIGN_STMTS.\n        * tree-vect-analyze.c (vect_compute_data_ref_alignment):\n        Update documentation.\n        (vect_update_misalignment_for_peel): New.\n        (vect_enhance_data_refs_alignment): Update to choose loop\n        peeling or loop versioning if appropriate for the (potentially)\n        unaligned data references in the loop.\n        (vect_analyze_data_refs_alignment): Remove call to\n        vect_enhance_data_refs_alignment so the checks can be done\n        earlier.\n        (vect_analyze_loop): Add call to vect_enhance_data_refs_alignment\n        and move up call to vect_analyze_data_refs_alignment.\n        * tree-vect-transform.c (vect_create_cond_for_align_checks): New.\n        (vect_transform_loop): Add call to loop_version.\n\nFrom-SVN: r103941", "tree": {"sha": "d212aa353f9a4c74483a300139b763af6e6840f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d212aa353f9a4c74483a300139b763af6e6840f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c12cc93047bf59f210231a102df277dad6ad2ab1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c12cc93047bf59f210231a102df277dad6ad2ab1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c12cc93047bf59f210231a102df277dad6ad2ab1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c12cc93047bf59f210231a102df277dad6ad2ab1/comments", "author": null, "committer": null, "parents": [{"sha": "4fe8db686f069d34fa01cb98668163823cc38d04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe8db686f069d34fa01cb98668163823cc38d04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fe8db686f069d34fa01cb98668163823cc38d04"}], "stats": {"total": 819, "additions": 645, "deletions": 174}, "files": [{"sha": "310d84af1fd98a9d1d3a006d58e80e38f3261ddd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -1,3 +1,29 @@\n+2005-09-06  Keith Besaw  <kbesaw@us.ibm.com>\n+\n+\t* common.opt: Add option ftree-vect-loop-version.\n+\t* params.def: Add --param vect-max-version-checks.\n+\t* doc/invoke.texi: Document ftree-vect-loop-version and\n+\t--param vect-max-version-checks.\n+\t* tree-vectorizer.h (_loop_vec_info): Add ptr_mask and\n+\tmay_misalign_stmts and defines for accessors.\n+\t* tree-vectorizer.c : (new_loop_vec_info): VEC_alloc for\n+\tLOOP_VINFO_MAY_MISALIGN_STMTS.\n+\t(destroy_loop_vec_info): VEC_free for\n+\tLOOP_VINFO_MAY_MISALIGN_STMTS.\n+\t* tree-vect-analyze.c (vect_compute_data_ref_alignment):\n+\tUpdate documentation.\n+\t(vect_update_misalignment_for_peel): New.\n+\t(vect_enhance_data_refs_alignment): Update to choose loop\n+\tpeeling or loop versioning if appropriate for the (potentially)\n+\tunaligned data references in the loop.\n+\t(vect_analyze_data_refs_alignment): Remove call to\n+\tvect_enhance_data_refs_alignment so the checks can be done\n+\tearlier.\n+\t(vect_analyze_loop): Add call to vect_enhance_data_refs_alignment\n+\tand move up call to vect_analyze_data_refs_alignment.\n+\t* tree-vect-transform.c (vect_create_cond_for_align_checks): New.\n+\t(vect_transform_loop): Add call to loop_version.\n+\n 2005-09-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/23098"}, {"sha": "67e91d39a853e2c4a808e476af38591c8b67e126", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -998,6 +998,10 @@ ftree-vectorize\n Common Report Var(flag_tree_vectorize)\n Enable loop vectorization on trees\n \n+ftree-vect-loop-version\n+Common Report Var(flag_tree_vect_loop_version) Init(1)\n+Enable loop versioning when doing loop vectorization on trees\n+\n ftree-vectorizer-verbose=\n Common RejectNegative Joined\n -ftree-vectorizer-verbose=<number>\tSet the verbosity level of the vectorizer"}, {"sha": "7dfa3a4693d635e7f8b4f79a381f449f729b4fc0", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -337,7 +337,7 @@ Objective-C and Objective-C++ Dialects}.\n -ftree-loop-linear -ftree-loop-im -ftree-loop-ivcanon -fivopts @gol\n -ftree-dominator-opts -ftree-dse -ftree-copyrename -ftree-sink @gol\n -ftree-ch -ftree-sra -ftree-ter -ftree-lrs -ftree-fre -ftree-vectorize @gol\n--ftree-salias -fweb @gol\n+-ftree-vect-loop-version -ftree-salias -fweb @gol\n -ftree-copy-prop -ftree-store-ccp -ftree-store-copy-prop -fwhole-program @gol\n --param @var{name}=@var{value}\n -O  -O0  -O1  -O2  -O3  -Os}\n@@ -4391,7 +4391,8 @@ optimizations designed to reduce code size.\n \n @option{-Os} disables the following optimization flags:\n @gccoptlist{-falign-functions  -falign-jumps  -falign-loops @gol\n--falign-labels  -freorder-blocks  -freorder-blocks-and-partition -fprefetch-loop-arrays}\n+-falign-labels  -freorder-blocks  -freorder-blocks-and-partition @gol\n+-fprefetch-loop-arrays  -ftree-vect-loop-version}\n \n If you use multiple @option{-O} options, with or without level numbers,\n the last such option is the one that is effective.\n@@ -5038,6 +5039,15 @@ optimization later.  This is enabled by default at @option{-O} and higher.\n @item -ftree-vectorize\n Perform loop vectorization on trees.\n \n+@item -ftree-vect-loop-version\n+@opindex ftree-vect-loop-version\n+Perform loop versioning when doing loop vectorization on trees.  When a loop\n+appears to be vectorizable except that data alignment or data dependence cannot\n+be determined at compile time then vectorized and non-vectorized versions of\n+the loop are generated along with runtime checks for alignment or dependence\n+to control which version is executed.  This option is enabled by default\n+except at level @option{-Os} where it is disabled.\n+\n @item -ftree-vrp\n Perform Value Range Propagation on trees.  This is similar to the\n constant propagation pass, but instead of values, ranges of values are\n@@ -5883,6 +5893,11 @@ optimization when a new iv is added to the set.\n Bound on size of expressions used in the scalar evolutions analyzer.\n Large expressions slow the analyzer.\n \n+@item vect-max-version-checks\n+The maxinum number of runtime checks that can be performed when doing\n+loop versioning in the vectorizer.  See option ftree-vect-loop-version\n+for more information.\n+\n @item max-iterations-to-track\n \n The maximum number of iterations of a loop the brute force algorithm"}, {"sha": "3ac45979a21e7366bcba8a66d7b992c7ebc75827", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -398,6 +398,11 @@ DEFPARAM(PARAM_SCEV_MAX_EXPR_SIZE,\n \t \"Bound on size of expressions used in the scalar evolutions analyzer\",\n \t 20, 0, 0)\n \n+DEFPARAM(PARAM_VECT_MAX_VERSION_CHECKS,\n+         \"vect-max-version-checks\",\n+         \"Bound on number of runtime checks inserted by the vectorizer's loop versioning\",\n+         6, 0, 0)\n+\n /* The product of the next two is used to decide whether or not to\n    use .GLOBAL_VAR.  See tree-dfa.c.  */\n DEFPARAM(PARAM_GLOBAL_VAR_THRESHOLD,"}, {"sha": "2dabdf91fa5f2bcaa36e6c8db378450ce8c40eb9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -1,3 +1,19 @@\n+2005-09-06  Keith Besaw  <kbesaw@us.ibm.com>\n+\n+\t* gcc.dg/vect/vect-29.c: Update xfail testing.\n+\t* gcc.dg/vect/vect-44.c: Same.\n+\t* gcc.dg/vect/vect-48.c: Same.\n+\t* gcc.dg/vect/vect-50.c: Same.\n+\t* gcc.dg/vect/vect-72.c: Same.\n+\t* gcc.dg/vect/vect-77.c: Same.\n+\t* gcc.dg/vect/vect-78.c: Same.\n+\t* gcc.dg/vect/vect-80.c: Same.\n+\t* gcc.dg/vect/vect-96.c: Same.\n+\t* gcc.dg/vect/vect-100.c: Same.\n+\t* gcc.dg/vect/vect-exp: Add default flags for Os-vect-*.\n+\t* gfortran.dg/vect/vect-2.f90: Update xfail testing.\n+\t* gfortran.dg/vect/vect-5.f90: Same.\n+\n 2005-09-06  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/debug/dwarf2/dwarf-char1.c: Accept more assembler comment"}, {"sha": "2b79975b0b533f15ea04b582e49a552825bbd8eb", "filename": "gcc/testsuite/gcc.dg/vect/vect-100.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-100.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-100.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-100.c?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -21,7 +21,7 @@ int main1 () {\n   \n   p = (struct extraction *) malloc (sizeof (struct extraction));\n \n-  /* Not vectorizable: p may alias a and/or b, since they are globals.  */\n+  /* Vectorizable: alias analysis determines that p can't point to a and/or b.  */\n   for (i = 0; i < N; i++)\n     {\n       p->a[i] = a[i];\n@@ -73,6 +73,6 @@ int main (void)\n }\n \n /* Requires versioning.  */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 0 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "ac398148cea0b588fa4cc01714f8c4f3d0b1b2ee", "filename": "gcc/testsuite/gcc.dg/vect/vect-29.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-29.c?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -43,7 +43,11 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* For targets that don't support misaligned loads we version for the load.\n+   (The store is aligned).  */\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail vect_no_align } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" {target vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e0e763245865ead3b0ac33bfafe030c7d282bf71", "filename": "gcc/testsuite/gcc.dg/vect/vect-44.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-44.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-44.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-44.c?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -51,7 +51,12 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* For targets that don't support misaligned loads we version for the \n+   all three accesses (peeling to align the store will not force the\n+   two loads to be aligned).  */\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 3 \"vect\" { target vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e2199d028a6af498633ea619b19d6b7c95f90698", "filename": "gcc/testsuite/gcc.dg/vect/vect-48.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-48.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-48.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-48.c?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -52,7 +52,11 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* For targets that don't support misaligned loads we version for the two loads.\n+   (The store is aligned).  */\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 2 \"vect\" { target vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "6f065e8d66305f069b0311bc73a9142791c99c75", "filename": "gcc/testsuite/gcc.dg/vect/vect-50.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-50.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-50.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-50.c?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -49,7 +49,12 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* For targets that don't support misaligned loads we version for the\n+   all three accesses (peeling to align the store will not force the\n+   two loads to be aligned).  */\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 3 \"vect\" { target vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "6b9b1844ee74828629d7d1b9a699767779b5ed7b", "filename": "gcc/testsuite/gcc.dg/vect/vect-52.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-52.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-52.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-52.c?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -51,7 +51,11 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* For targets that don't support misaligned loads we version for the two loads.\n+   (The store is aligned).  */\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 2 \"vect\" { target vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "79c0ccb7af04d225f7a1b1f017c880e53143e70d", "filename": "gcc/testsuite/gcc.dg/vect/vect-77.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-77.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-77.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-77.c?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -43,7 +43,11 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail { vect_no_align } } } } */\n+/* For targets that don't support misaligned loads we version for the load.\n+   (The store is aligned).  */\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { vect_no_align } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "b4fc63b41e15b05581982848921e4b143af251cc", "filename": "gcc/testsuite/gcc.dg/vect/vect-78.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-78.c?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -44,7 +44,11 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail { vect_no_align } } } } */\n+/* For targets that don't support misaligned loads we version for the load.\n+   (The store is aligned).  */\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { vect_no_align } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "3696b52c460d33e28bc85f878988ef09946e956f", "filename": "gcc/testsuite/gcc.dg/vect/vect-80.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-80.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-80.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-80.c?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -43,7 +43,12 @@ int main (void)\n   return 0;\t\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* For targets that don't support misaligned loads we version for the\n+   all three accesses (peeling to align the store will not force the\n+   two loads to be aligned).  */\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 3 \"vect\" { target vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ac3194e62c3efa1a769e049f707100e42cb8886a", "filename": "gcc/testsuite/gcc.dg/vect/vect-96.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -37,7 +37,12 @@ int main (void)\n   return main1 (8);\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* The store is unaligned, the load is aligned. For targets that support unaligned\n+   loads, peel to align the store and generated unaligned access for the loads.\n+   For targets that don't support unaligned loads, version for the store.  */\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail vect_no_align } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "bfa6dced9b15989353a74e2b2debe3b2ae5b756d", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -102,6 +102,11 @@ lappend DEFAULT_VECTCFLAGS \"-ftrapv\"\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/trapv-vect*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n+# With -Os\n+lappend DEFAULT_VECTCFLAGS \"-Os\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/Os-vect-*.\\[cS\\]]]  \\\n+        \"\" $DEFAULT_VECTCFLAGS\n+\n # Clean up.\n set dg-do-what-default ${save-dg-do-what-default}\n "}, {"sha": "a881d9726d3c73fe6f18d9997299e7481cbdac51", "filename": "gcc/testsuite/gfortran.dg/vect/vect-2.f90", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-2.f90?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -8,7 +8,15 @@ SUBROUTINE FOO(A, B, C)\n PRINT*, C(500000)\n END\n \n-! { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail vect_no_align } } }\n+! First loop (A=LOG(X)) is vectorized using peeling to align the store.\n+! Same for the second loop (B=LOG(Y)).\n+! Third loop (C = A + B) is vectorized using versioning (for targets that don't\n+! support unaligned loads) or using peeling to align the store (on targets that \n+! support unaligned loads).\n+\n+! { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } }\n ! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail vect_no_align } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { target vect_no_align } } }\n ! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 3 \"vect\" {target vect_no_align } } }\n ! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "52c07549c54748e598e88df820c03ee793351b5a", "filename": "gcc/testsuite/gfortran.dg/vect/vect-5.f90", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-5.f90?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -35,9 +35,10 @@ program main\n         stop\n         end\n \n-! { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { xfail { vect_no_align || lp64 } } } }\n+! { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { xfail { lp64 } } } }\n ! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || lp64 } } } }\n ! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || lp64 } } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 3 \"vect\" {target vect_no_align } } }\n \n ! We also expect to vectorize one loop for lp64 targets that support \n ! misaligned access:"}, {"sha": "2c5136b19748b3d7bc0c7a9c809f6cc0be27d542", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 348, "deletions": 156, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -33,6 +33,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"cfgloop.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n+#include \"params.h\"\n #include \"tree-chrec.h\"\n #include \"tree-data-ref.h\"\n #include \"tree-scalar-evolution.h\"\n@@ -47,7 +48,7 @@ static bool vect_analyze_data_ref_accesses (loop_vec_info);\n static bool vect_analyze_data_ref_dependences (loop_vec_info);\n static bool vect_analyze_data_refs_alignment (loop_vec_info);\n static bool vect_compute_data_refs_alignment (loop_vec_info);\n-static void vect_enhance_data_refs_alignment (loop_vec_info);\n+static bool vect_enhance_data_refs_alignment (loop_vec_info);\n static bool vect_analyze_operations (loop_vec_info);\n static bool vect_determine_vectorization_factor (loop_vec_info);\n \n@@ -61,6 +62,9 @@ static bool vect_analyze_data_ref_dependence\n static bool vect_compute_data_ref_alignment (struct data_reference *); \n static bool vect_analyze_data_ref_access (struct data_reference *);\n static bool vect_can_advance_ivs_p (loop_vec_info);\n+static void vect_update_misalignment_for_peel\n+  (struct data_reference *, struct data_reference *, int npeel);\n+ \n \n /* Function vect_determine_vectorization_factor\n \n@@ -370,7 +374,8 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n     }\n \n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      || LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0)\n+      || LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0\n+      || LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"epilog loop required.\");\n@@ -791,11 +796,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n /* Function vect_compute_data_refs_alignment\n \n    Compute the misalignment of data references in the loop.\n-   This pass may take place at function granularity instead of at loop\n-   granularity.\n-\n-   FOR NOW: No analysis is actually performed. Misalignment is calculated\n-   only for trivial cases. TODO.  */\n+   Return FALSE if a data reference is found that cannot be vectorized.  */\n \n static bool\n vect_compute_data_refs_alignment (loop_vec_info loop_vinfo)\n@@ -814,6 +815,93 @@ vect_compute_data_refs_alignment (loop_vec_info loop_vinfo)\n }\n \n \n+/* Function vect_update_misalignment_for_peel\n+\n+   DR - the data reference whose misalignment is to be adjusted.\n+   DR_PEEL - the data reference whose misalignment is being made\n+             zero in the vector loop by the peel.\n+   NPEEL - the number of iterations in the peel loop if the misalignment\n+           of DR_PEEL is known at compile time.  */\n+\n+static void\n+vect_update_misalignment_for_peel (struct data_reference *dr,\n+                                   struct data_reference *dr_peel, int npeel)\n+{\n+  unsigned int i;\n+  int drsize;\n+  VEC(dr_p,heap) *same_align_drs;\n+  struct data_reference *current_dr;\n+\n+  if (known_alignment_for_access_p (dr)\n+      && DR_MISALIGNMENT (dr) == DR_MISALIGNMENT (dr_peel))\n+    {\n+      DR_MISALIGNMENT (dr) = 0;\n+      return;\n+    }\n+\n+  /* It can be assumed that the data refs with the same alignment as dr_peel\n+     are aligned in the vector loop.  */\n+  same_align_drs\n+    = STMT_VINFO_SAME_ALIGN_REFS (vinfo_for_stmt (DR_STMT (dr_peel)));\n+  for (i = 0; VEC_iterate (dr_p, same_align_drs, i, current_dr); i++)\n+    {\n+      if (current_dr != dr)\n+        continue;\n+      gcc_assert (DR_MISALIGNMENT (dr) == DR_MISALIGNMENT (dr_peel));\n+      DR_MISALIGNMENT (dr) = 0;\n+      return;\n+    }\n+\n+  if (known_alignment_for_access_p (dr)\n+      && known_alignment_for_access_p (dr_peel))\n+    {  \n+      drsize = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n+      DR_MISALIGNMENT (dr) += npeel * drsize;\n+      DR_MISALIGNMENT (dr) %= UNITS_PER_SIMD_WORD;\n+      return;\n+    }\n+\n+  DR_MISALIGNMENT (dr) = -1;\n+}\n+\n+\n+/* Function vect_verify_datarefs_alignment\n+\n+   Return TRUE if all data references in the loop can be\n+   handled with respect to alignment.  */\n+\n+static bool\n+vect_verify_datarefs_alignment (loop_vec_info loop_vinfo)\n+{\n+  varray_type datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  enum dr_alignment_support supportable_dr_alignment;\n+  unsigned int i;\n+\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n+    {\n+      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n+      supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n+      if (!supportable_dr_alignment)\n+        {\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+            {\n+              if (DR_IS_READ (dr))\n+                fprintf (vect_dump, \n+                         \"not vectorized: unsupported unaligned load.\");\n+              else\n+                fprintf (vect_dump, \n+                         \"not vectorized: unsupported unaligned store.\");\n+            }\n+          return false;\n+        }\n+      if (supportable_dr_alignment != dr_aligned\n+          && vect_print_dump_info (REPORT_ALIGNMENT))\n+        fprintf (vect_dump, \"Vectorizing an unaligned access.\");\n+    }\n+  return true;\n+}\n+\n+\n /* Function vect_enhance_data_refs_alignment\n \n    This pass will use loop versioning and loop peeling in order to enhance\n@@ -822,42 +910,30 @@ vect_compute_data_refs_alignment (loop_vec_info loop_vinfo)\n    FOR NOW: we assume that whatever versioning/peeling takes place, only the\n    original loop is to be vectorized; Any other loops that are created by\n    the transformations performed in this pass - are not supposed to be\n-   vectorized. This restriction will be relaxed.  */\n+   vectorized. This restriction will be relaxed.\n+\n+   This pass will require a cost model to guide it whether to apply peeling\n+   or versioning or a combination of the two. For example, the scheme that\n+   intel uses when given a loop with several memory accesses, is as follows:\n+   choose one memory access ('p') which alignment you want to force by doing\n+   peeling. Then, either (1) generate a loop in which 'p' is aligned and all\n+   other accesses are not necessarily aligned, or (2) use loop versioning to\n+   generate one loop in which all accesses are aligned, and another loop in\n+   which only 'p' is necessarily aligned.\n+\n+   (\"Automatic Intra-Register Vectorization for the Intel Architecture\",\n+   Aart J.C. Bik, Milind Girkar, Paul M. Grey and Ximmin Tian, International\n+   Journal of Parallel Programming, Vol. 30, No. 2, April 2002.)\n+\n+   Devising a cost model is the most critical aspect of this work. It will\n+   guide us on which access to peel for, whether to use loop versioning, how\n+   many versions to create, etc. The cost model will probably consist of\n+   generic considerations as well as target specific considerations (on\n+   powerpc for example, misaligned stores are more painful than misaligned\n+   loads).\n+\n+   Here are the general steps involved in alignment enhancements:\n \n-static void\n-vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n-{\n-  varray_type loop_datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n-  varray_type datarefs;\n-  VEC(dr_p,heap) *same_align_drs;\n-  struct data_reference *dr0 = NULL;\n-  struct data_reference *dr;\n-  unsigned int i, j;\n-  bool check_loads;\n-\n-  /*\n-     This pass will require a cost model to guide it whether to apply peeling \n-     or versioning or a combination of the two. For example, the scheme that\n-     intel uses when given a loop with several memory accesses, is as follows:\n-     choose one memory access ('p') which alignment you want to force by doing \n-     peeling. Then, either (1) generate a loop in which 'p' is aligned and all \n-     other accesses are not necessarily aligned, or (2) use loop versioning to \n-     generate one loop in which all accesses are aligned, and another loop in \n-     which only 'p' is necessarily aligned. \n-\n-     (\"Automatic Intra-Register Vectorization for the Intel Architecture\",\n-      Aart J.C. Bik, Milind Girkar, Paul M. Grey and Ximmin Tian, International\n-      Journal of Parallel Programming, Vol. 30, No. 2, April 2002.)\t\n-\n-     Devising a cost model is the most critical aspect of this work. It will \n-     guide us on which access to peel for, whether to use loop versioning, how \n-     many versions to create, etc. The cost model will probably consist of \n-     generic considerations as well as target specific considerations (on \n-     powerpc for example, misaligned stores are more painful than misaligned \n-     loads). \n-\n-     Here is the general steps involved in alignment enhancements:\n-    \n      -- original loop, before alignment analysis:\n \tfor (i=0; i<N; i++){\n \t  x = q[i];\t\t\t# DR_MISALIGNMENT(q) = unknown\n@@ -876,14 +952,14 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  x = q[i];\t\t\t# DR_MISALIGNMENT(q) = 3\n \t  p[i] = y;\t\t\t# DR_MISALIGNMENT(p) = 0\n \t}\n-     } \n+     }\n      else {\n \tfor (i=0; i<N; i++){\t# loop 1B\n \t  x = q[i];\t\t\t# DR_MISALIGNMENT(q) = 3\n \t  p[i] = y;\t\t\t# DR_MISALIGNMENT(p) = unaligned\n \t}\n      }\n-   \n+\n      -- Possibility 2: we do loop peeling:\n      for (i = 0; i < 3; i++){\t# (scalar loop, not to be vectorized).\n \tx = q[i];\n@@ -900,23 +976,57 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \tp[i] = y;\n      }\n      if (p is aligned) {\n-\tfor (i = 3; i<N; i++){  # loop 3A\n+\tfor (i = 3; i<N; i++){\t# loop 3A\n \t  x = q[i];\t\t\t# DR_MISALIGNMENT(q) = 0\n \t  p[i] = y;\t\t\t# DR_MISALIGNMENT(p) = 0\n \t}\n-     } \n+     }\n      else {\n \tfor (i = 3; i<N; i++){\t# loop 3B\n \t  x = q[i];\t\t\t# DR_MISALIGNMENT(q) = 0\n \t  p[i] = y;\t\t\t# DR_MISALIGNMENT(p) = unaligned\n \t}\n      }\n \n-     These loops are later passed to loop_transform to be vectorized. The \n-     vectorizer will use the alignment information to guide the transformation \n-     (whether to generate regular loads/stores, or with special handling for \n-     misalignment). \n-   */\n+     These loops are later passed to loop_transform to be vectorized. The\n+     vectorizer will use the alignment information to guide the transformation\n+     (whether to generate regular loads/stores, or with special handling for\n+     misalignment).  */\n+\n+static bool\n+vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n+{\n+  varray_type datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  enum dr_alignment_support supportable_dr_alignment;\n+  struct data_reference *dr0 = NULL;\n+  struct data_reference *dr;\n+  unsigned int i;\n+  bool do_peeling = false;\n+  bool do_versioning = false;\n+  bool stat;\n+\n+  /* While cost model enhancements are expected in the future, the high level\n+     view of the code at this time is as follows:\n+\n+     A) If there is a misaligned write then see if peeling to align this write\n+        can make all data references satisfy vect_supportable_dr_alignment.\n+        If so, update data structures as needed and return true.  Note that\n+        at this time vect_supportable_dr_alignment is known to return false\n+        for a a misaligned write.\n+\n+     B) If peeling wasn't possible and there is a data reference with an\n+        unknown misalignment that does not satisfy vect_supportable_dr_alignment\n+        then see if loop versioning checks can be used to make all data\n+        references satisfy vect_supportable_dr_alignment.  If so, update\n+        data structures as needed and return true.\n+\n+     C) If neither peeling nor versioning were successful then return false if\n+        any data reference does not satisfy vect_supportable_dr_alignment.\n+\n+     D) Return true (all data references satisfy vect_supportable_dr_alignment).\n+\n+     Note, Possibility 3 above (which is peeling and versioning together) is not\n+     being done at this time.  */\n \n   /* (1) Peeling to force alignment.  */\n \n@@ -932,106 +1042,210 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n      misaligned store in the loop.\n      Rationale: misaligned stores are not yet supported.\n \n-     TODO: Use a better cost model.  */\n+     TODO: Use a cost model.  */\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_datarefs); i++)\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n     {\n-      dr0 = VARRAY_GENERIC_PTR (loop_datarefs, i);\n-      if (!DR_IS_READ (dr0) && !aligned_access_p (dr0))\n-\t{\n-\t  LOOP_VINFO_UNALIGNED_DR (loop_vinfo) = dr0;\n-\t  LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) = DR_MISALIGNMENT (dr0);\n-\t  break;\n-\t}\n+      dr = VARRAY_GENERIC_PTR (datarefs, i);\n+      if (!DR_IS_READ (dr) && !aligned_access_p (dr))\n+        {\n+          dr0 = dr;\n+          do_peeling = true;\n+          break;\n+        }\n     }\n \n-  /* (1.2) Update the alignment info according to the peeling factor.\n-\t   If the misalignment of the DR we peel for is M, then the\n-\t   peeling factor is VF - M, and the misalignment of each access DR_i\n-\t   in the loop is DR_MISALIGNMENT (DR_i) + VF - M.\n-\t   If the misalignment of the DR we peel for is unknown, then the \n-\t   misalignment of each access DR_i in the loop is also unknown.\n-\n-           TODO: - consider accesses that are known to have the same\n-                   alignment, even if that alignment is unknown.  */\n+  /* Often peeling for alignment will require peeling for loop-bound, which in \n+     turn requires that we know how to adjust the loop ivs after the loop.  */\n+  if (!vect_can_advance_ivs_p (loop_vinfo))\n+    do_peeling = false;\n \n-  if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n+  if (do_peeling)\n     {\n       int mis;\n       int npeel = 0;\n \n       if (known_alignment_for_access_p (dr0))\n-\t{\n-\t  /* Since it's known at compile time, compute the number of iterations\n-\t     in the peeled loop (the peeling factor) for use in updating\n-\t     DR_MISALIGNMENT values.  The peeling factor is the vectorization\n-\t     factor minus the misalignment as an element count.  */\n-\t  mis = DR_MISALIGNMENT (dr0);\n-\t  mis /= GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr0))));\n-\t  npeel = LOOP_VINFO_VECT_FACTOR (loop_vinfo) - mis;\n+        {\n+          /* Since it's known at compile time, compute the number of iterations\n+             in the peeled loop (the peeling factor) for use in updating\n+             DR_MISALIGNMENT values.  The peeling factor is the vectorization\n+             factor minus the misalignment as an element count.  */\n+          mis = DR_MISALIGNMENT (dr0);\n+          mis /= GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr0))));\n+          npeel = LOOP_VINFO_VECT_FACTOR (loop_vinfo) - mis;\n+        }\n+\n+      /* Ensure that all data refs can be vectorized after the peel.  */\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n+        {\n+          int save_misalignment;\n+\n+\t  dr = VARRAY_GENERIC_PTR (datarefs, i);\n+\t  if (dr == dr0)\n+\t    continue;\n+\t  save_misalignment = DR_MISALIGNMENT (dr);\n+\t  vect_update_misalignment_for_peel (dr, dr0, npeel);\n+\t  supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n+\t  DR_MISALIGNMENT (dr) = save_misalignment;\n+\t  \n+\t  if (!supportable_dr_alignment)\n+\t    {\n+\t      do_peeling = false;\n+\t      break;\n+\t    }\n \t}\n \n-      datarefs = loop_datarefs;\n-      check_loads = false;\n-      for (j = 0; j < 2; j++)\n-\t{\n+      if (do_peeling)\n+        {\n+          /* (1.2) Update the DR_MISALIGNMENT of each data reference DR_i.\n+             If the misalignment of DR_i is identical to that of dr0 then set\n+             DR_MISALIGNMENT (DR_i) to zero.  If the misalignment of DR_i and\n+             dr0 are known at compile time then increment DR_MISALIGNMENT (DR_i)\n+             by the peeling factor times the element size of DR_i (MOD the\n+             vectorization factor times the size).  Otherwise, the\n+             misalignment of DR_i must be set to unknown.  */\n \t  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n \t    {\n-\t      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n-\n-\t      if (dr == dr0 || (!check_loads && DR_IS_READ (dr)))\n-\t\tcontinue;\n-\t      if (known_alignment_for_access_p (dr)\n-\t\t  && DR_MISALIGNMENT (dr) == DR_MISALIGNMENT (dr0))\n-\t\tDR_MISALIGNMENT (dr) = 0;\n-\t      else if (known_alignment_for_access_p (dr)\n-\t\t       && known_alignment_for_access_p (dr0))\n-\t\t{\n-\t\t  int drsize = \n-\t\t\tGET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n-\n-\t\t  DR_MISALIGNMENT (dr) += npeel * drsize;\n-\t\t  DR_MISALIGNMENT (dr) %= UNITS_PER_SIMD_WORD;\n-\t\t}\n-\t      else\n-\t\tDR_MISALIGNMENT (dr) = -1;\n+\t      dr = VARRAY_GENERIC_PTR (datarefs, i);\n+\t      if (dr == dr0)\n+\t        continue;\n+\t      vect_update_misalignment_for_peel (dr, dr0, npeel);\n \t    }\n-\t  check_loads = true;\n-\t}\n \n-      same_align_drs = \n-\tSTMT_VINFO_SAME_ALIGN_REFS (vinfo_for_stmt (DR_STMT (dr0)));\n-      for (i = 0; VEC_iterate (dr_p, same_align_drs, i, dr); i++)\n+          LOOP_VINFO_UNALIGNED_DR (loop_vinfo) = dr0;\n+          LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) = DR_MISALIGNMENT (dr0);\n+          DR_MISALIGNMENT (dr0) = 0;\n+\t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n+            fprintf (vect_dump, \"Alignment of access forced using peeling.\");\n+\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            fprintf (vect_dump, \"Peeling for alignment will be applied.\");\n+\n+\t  stat = vect_verify_datarefs_alignment (loop_vinfo);\n+\t  gcc_assert (stat);\n+          return stat;\n+        }\n+    }\n+\n+\n+  /* (2) Versioning to force alignment.  */\n+\n+  /* Try versioning if:\n+     1) flag_tree_vect_loop_version is TRUE\n+     2) optimize_size is FALSE\n+     3) there is at least one unsupported misaligned data ref with an unknown\n+        misalignment, and\n+     4) all misaligned data refs with a known misalignment are supported, and\n+     5) the number of runtime alignment checks is within reason.  */\n+\n+  do_versioning = flag_tree_vect_loop_version && (!optimize_size);\n+\n+  if (do_versioning)\n+    {\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n         {\n+          dr = VARRAY_GENERIC_PTR (datarefs, i);\n+\n+          if (aligned_access_p (dr))\n+            continue;\n+\n+          supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n+\n+          if (!supportable_dr_alignment)\n+            {\n+              tree stmt;\n+              int mask;\n+              tree vectype;\n+\n+              if (known_alignment_for_access_p (dr)\n+                  || VEC_length (tree,\n+                                 LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n+                     >= (unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_CHECKS))\n+                {\n+                  do_versioning = false;\n+                  break;\n+                }\n+\n+              stmt = DR_STMT (dr);\n+              vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n+              gcc_assert (vectype);\n+  \n+              /* The rightmost bits of an aligned address must be zeros.\n+                 Construct the mask needed for this test.  For example,\n+                 GET_MODE_SIZE for the vector mode V4SI is 16 bytes so the\n+                 mask must be 15 = 0xf. */\n+              mask = GET_MODE_SIZE (TYPE_MODE (vectype)) - 1;\n+\n+              /* FORNOW: use the same mask to test all potentially unaligned\n+                 references in the loop.  The vectorizer currently supports\n+                 a single vector size, see the reference to\n+                 GET_MODE_NUNITS (TYPE_MODE (vectype)) where the\n+                 vectorization factor is computed.  */\n+              gcc_assert (!LOOP_VINFO_PTR_MASK (loop_vinfo)\n+                          || LOOP_VINFO_PTR_MASK (loop_vinfo) == mask);\n+              LOOP_VINFO_PTR_MASK (loop_vinfo) = mask;\n+              VEC_safe_push (tree, heap,\n+                             LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo),\n+                             DR_STMT (dr));\n+            }\n+        }\n+      \n+      /* Versioning requires at least one misaligned data reference.  */\n+      if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo)) == 0)\n+        do_versioning = false;\n+      else if (!do_versioning)\n+        VEC_truncate (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo), 0);\n+    }\n+\n+  if (do_versioning)\n+    {\n+      VEC(tree,heap) *may_misalign_stmts\n+        = LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo);\n+      tree stmt;\n+\n+      /* It can now be assumed that the data references in the statements\n+         in LOOP_VINFO_MAY_MISALIGN_STMTS will be aligned in the version\n+         of the loop being vectorized.  */\n+      for (i = 0; VEC_iterate (tree, may_misalign_stmts, i, stmt); i++)\n+        {\n+          stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+          dr = STMT_VINFO_DATA_REF (stmt_info);\n           DR_MISALIGNMENT (dr) = 0;\n+\t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n+            fprintf (vect_dump, \"Alignment of access forced using versioning.\");\n         }\n \n-      DR_MISALIGNMENT (dr0) = 0;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"Versioning for alignment will be applied.\");\n+\n+      /* Peeling and versioning can't be done together at this time.  */\n+      gcc_assert (! (do_peeling && do_versioning));\n+\n+      stat = vect_verify_datarefs_alignment (loop_vinfo);\n+      gcc_assert (stat);\n+      return stat;\n     }\n+\n+  /* This point is reached if neither peeling nor versioning is being done.  */\n+  gcc_assert (! (do_peeling || do_versioning));\n+\n+  stat = vect_verify_datarefs_alignment (loop_vinfo);\n+  return stat;\n }\n \n \n /* Function vect_analyze_data_refs_alignment\n \n    Analyze the alignment of the data-references in the loop.\n-   FOR NOW: Until support for misaligned accesses is in place, only if all\n-   accesses are aligned can the loop be vectorized. This restriction will be \n-   relaxed.  */ \n+   Return FALSE if a data reference is found that cannot be vectorized.  */\n \n static bool\n vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n-  varray_type datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n-  enum dr_alignment_support supportable_dr_alignment;\n-  unsigned int i;\n-\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_data_refs_alignment ===\");\n \n-\n-  /* This pass may take place at function granularity instead of at loop\n-     granularity.  */\n-\n   if (!vect_compute_data_refs_alignment (loop_vinfo))\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n@@ -1040,48 +1254,14 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n       return false;\n     }\n \n-\n-  /* This pass will decide on using loop versioning and/or loop peeling in \n-     order to enhance the alignment of data references in the loop.  */\n-\n-  vect_enhance_data_refs_alignment (loop_vinfo);\n-\n-\n-  /* Finally, check that all the data references in the loop can be\n-     handled with respect to their alignment.  */\n-\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n-    {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n-      supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n-      if (!supportable_dr_alignment)\n-\t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\t    {\n-\t      if (DR_IS_READ (dr))\n-\t\tfprintf (vect_dump,\n-\t\t\t \"not vectorized: unsupported unaligned load.\");\n-\t      else\n-\t\tfprintf (vect_dump,\n-\t\t\t \"not vectorized: unsupported unaligned store.\");\n-\t    }\n-\t  return false;\n-\t}\n-      if (supportable_dr_alignment != dr_aligned \n-\t  && (vect_print_dump_info (REPORT_ALIGNMENT)))\n-\tfprintf (vect_dump, \"Vectorizing an unaligned access.\");\n-    }\n-  if (LOOP_VINFO_UNALIGNED_DR (loop_vinfo)\n-      && vect_print_dump_info (REPORT_ALIGNMENT))\n-    fprintf (vect_dump, \"Alignment of access forced using peeling.\");\n   return true;\n }\n \n \n /* Function vect_analyze_data_ref_access.\n \n    Analyze the access pattern of the data-reference DR. For now, a data access\n-   has to consecutive to be considered vectorizable.  */\n+   has to be consecutive to be considered vectorizable.  */\n \n static bool\n vect_analyze_data_ref_access (struct data_reference *dr)\n@@ -1524,7 +1704,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \n /* Function vect_can_advance_ivs_p\n \n-   In case the number of iterations that LOOP iterates in unknown at compile \n+   In case the number of iterations that LOOP iterates is unknown at compile \n    time, an epilog loop will be generated, and the loop induction variables \n    (IVs) will be \"advanced\" to the value they are supposed to take just before \n    the epilog loop.  Here we check that the access function of the loop IVs\n@@ -1827,6 +2007,18 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n+  /* Analyze the alignment of the data-refs in the loop.\n+     Fail if a data reference is found that cannot be vectorized.  */\n+\n+  ok = vect_analyze_data_refs_alignment (loop_vinfo);\n+  if (!ok)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"bad data alignment.\");\n+      destroy_loop_vec_info (loop_vinfo);\n+      return NULL;\n+    }\n+\n   ok = vect_determine_vectorization_factor (loop_vinfo);\n   if (!ok)\n     {\n@@ -1860,10 +2052,10 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n-  /* Analyze the alignment of the data-refs in the loop.\n-     FORNOW: Only aligned accesses are handled.  */\n+  /* This pass will decide on using loop versioning and/or loop peeling in\n+     order to enhance the alignment of data references in the loop.  */\n \n-  ok = vect_analyze_data_refs_alignment (loop_vinfo);\n+  ok = vect_enhance_data_refs_alignment (loop_vinfo);\n   if (!ok)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))"}, {"sha": "f498adb74c530d398c6ab99ac91363e3b2c7d0ae", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 147, "deletions": 1, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -336,7 +336,7 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       tree data_ref_base = base_name;\n-      fprintf (vect_dump, \"create array_ref of type: \");\n+      fprintf (vect_dump, \"create vector-pointer variable to type: \");\n       print_generic_expr (vect_dump, vectype, TDF_SLIM);\n       if (TREE_CODE (data_ref_base) == VAR_DECL)\n         fprintf (vect_dump, \"  vectorizing a one dimensional array ref: \");\n@@ -2697,6 +2697,128 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n }\n \n \n+/* Function vect_create_cond_for_align_checks.\n+\n+   Create a conditional expression that represents the alignment checks for\n+   all of data references (array element references) whose alignment must be\n+   checked at runtime.\n+\n+   Input:\n+   LOOP_VINFO - two fields of the loop information are used.\n+                LOOP_VINFO_PTR_MASK is the mask used to check the alignment.\n+                LOOP_VINFO_MAY_MISALIGN_STMTS contains the refs to be checked.\n+\n+   Output:\n+   COND_EXPR_STMT_LIST - statements needed to construct the conditional\n+                         expression.\n+   The returned value is the conditional expression to be used in the if\n+   statement that controls which version of the loop gets executed at runtime.\n+\n+   The algorithm makes two assumptions:\n+     1) The number of bytes \"n\" in a vector is a power of 2.\n+     2) An address \"a\" is aligned if a%n is zero and that this\n+        test can be done as a&(n-1) == 0.  For example, for 16\n+        byte vectors the test is a&0xf == 0.  */\n+\n+static tree\n+vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n+                                   tree *cond_expr_stmt_list)\n+{\n+  VEC(tree,heap) *may_misalign_stmts\n+    = LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo);\n+  tree ref_stmt;\n+  int mask = LOOP_VINFO_PTR_MASK (loop_vinfo);\n+  tree mask_cst;\n+  unsigned int i;\n+  tree psize;\n+  tree int_ptrsize_type;\n+  char tmp_name[20];\n+  tree or_tmp_name = NULL_TREE;\n+  tree and_tmp, and_tmp_name, and_stmt;\n+  tree ptrsize_zero;\n+\n+  /* Check that mask is one less than a power of 2, i.e., mask is\n+     all zeros followed by all ones.  */\n+  gcc_assert ((mask != 0) && ((mask & (mask+1)) == 0));\n+\n+  /* CHECKME: what is the best integer or unsigned type to use to hold a\n+     cast from a pointer value?  */\n+  psize = TYPE_SIZE (ptr_type_node);\n+  int_ptrsize_type\n+    = lang_hooks.types.type_for_size (tree_low_cst (psize, 1), 0);\n+\n+  /* Create expression (mask & (dr_1 || ... || dr_n)) where dr_i is the address\n+     of the first vector of the i'th data reference. */\n+\n+  for (i = 0; VEC_iterate (tree, may_misalign_stmts, i, ref_stmt); i++)\n+    {\n+      tree new_stmt_list = NULL_TREE;   \n+      tree addr_base;\n+      tree addr_tmp, addr_tmp_name, addr_stmt;\n+      tree or_tmp, new_or_tmp_name, or_stmt;\n+\n+      /* create: addr_tmp = (int)(address_of_first_vector) */\n+      addr_base = vect_create_addr_base_for_vector_ref (ref_stmt, \n+\t\t\t\t\t\t\t&new_stmt_list, \n+\t\t\t\t\t\t\tNULL_TREE);\n+\n+      if (new_stmt_list != NULL_TREE)\n+        append_to_statement_list_force (new_stmt_list, cond_expr_stmt_list);\n+\n+      sprintf (tmp_name, \"%s%d\", \"addr2int\", i);\n+      addr_tmp = create_tmp_var (int_ptrsize_type, tmp_name);\n+      add_referenced_tmp_var (addr_tmp);\n+      addr_tmp_name = make_ssa_name (addr_tmp, NULL_TREE);\n+      addr_stmt = fold_convert (int_ptrsize_type, addr_base);\n+      addr_stmt = build2 (MODIFY_EXPR, void_type_node,\n+                          addr_tmp_name, addr_stmt);\n+      SSA_NAME_DEF_STMT (addr_tmp_name) = addr_stmt;\n+      append_to_statement_list_force (addr_stmt, cond_expr_stmt_list);\n+\n+      /* The addresses are OR together.  */\n+\n+      if (or_tmp_name != NULL_TREE)\n+        {\n+          /* create: or_tmp = or_tmp | addr_tmp */\n+          sprintf (tmp_name, \"%s%d\", \"orptrs\", i);\n+          or_tmp = create_tmp_var (int_ptrsize_type, tmp_name);\n+          add_referenced_tmp_var (or_tmp);\n+          new_or_tmp_name = make_ssa_name (or_tmp, NULL_TREE);\n+          or_stmt = build2 (MODIFY_EXPR, void_type_node, new_or_tmp_name,\n+                            build2 (BIT_IOR_EXPR, int_ptrsize_type,\n+\t                            or_tmp_name,\n+                                    addr_tmp_name));\n+          SSA_NAME_DEF_STMT (new_or_tmp_name) = or_stmt;\n+          append_to_statement_list_force (or_stmt, cond_expr_stmt_list);\n+          or_tmp_name = new_or_tmp_name;\n+        }\n+      else\n+        or_tmp_name = addr_tmp_name;\n+\n+    } /* end for i */\n+\n+  mask_cst = build_int_cst (int_ptrsize_type, mask);\n+\n+  /* create: and_tmp = or_tmp & mask  */\n+  and_tmp = create_tmp_var (int_ptrsize_type, \"andmask\" );\n+  add_referenced_tmp_var (and_tmp);\n+  and_tmp_name = make_ssa_name (and_tmp, NULL_TREE);\n+\n+  and_stmt = build2 (MODIFY_EXPR, void_type_node,\n+                     and_tmp_name,\n+                     build2 (BIT_AND_EXPR, int_ptrsize_type,\n+                             or_tmp_name, mask_cst));\n+  SSA_NAME_DEF_STMT (and_tmp_name) = and_stmt;\n+  append_to_statement_list_force (and_stmt, cond_expr_stmt_list);\n+\n+  /* Make and_tmp the left operand of the conditional test against zero.\n+     if and_tmp has a non-zero bit then some address is unaligned.  */\n+  ptrsize_zero = build_int_cst (int_ptrsize_type, 0);\n+  return build2 (EQ_EXPR, boolean_type_node,\n+                 and_tmp_name, ptrsize_zero);\n+}\n+\n+\n /* Function vect_transform_loop.\n \n    The analysis phase has determined that the loop is vectorizable.\n@@ -2720,6 +2842,30 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vec_transform_loop ===\");\n \n+  /* If the loop has data references that may or may not be aligned then\n+     two versions of the loop need to be generated, one which is vectorized\n+     and one which isn't.  A test is then generated to control which of the\n+     loops is executed.  The test checks for the alignment of all of the\n+     data references that may or may not be aligned. */\n+\n+  if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo)))\n+    {\n+      struct loop *nloop;\n+      tree cond_expr;\n+      tree cond_expr_stmt_list = NULL_TREE;\n+      basic_block condition_bb;\n+      block_stmt_iterator cond_exp_bsi;\n+\n+      cond_expr = vect_create_cond_for_align_checks (loop_vinfo,\n+                                                     &cond_expr_stmt_list);\n+      initialize_original_copy_tables ();\n+      nloop = loop_version (loops, loop, cond_expr, &condition_bb, true);\n+      free_original_copy_tables();\n+      update_ssa (TODO_update_ssa);\n+      cond_exp_bsi = bsi_last (condition_bb);\n+      bsi_insert_before (&cond_exp_bsi, cond_expr_stmt_list, BSI_SAME_STMT);\n+    }\n+\n   /* CHECKME: we wouldn't need this if we calles update_ssa once\n      for all loops.  */\n   bitmap_zero (vect_vnames_to_rename);"}, {"sha": "1e415cb9dd96520a8ceb18126e97aae18aaa265d", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -137,6 +137,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"cfglayout.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n+#include \"params.h\"\n #include \"toplev.h\"\n #include \"tree-chrec.h\"\n #include \"tree-data-ref.h\"\n@@ -1420,6 +1421,8 @@ new_loop_vec_info (struct loop *loop)\n   VARRAY_GENERIC_PTR_INIT (LOOP_VINFO_DATAREFS (res), 20, \"loop_datarefs\");\n   VARRAY_GENERIC_PTR_INIT (LOOP_VINFO_DDRS (res), 20, \"loop_ddrs\");\n   LOOP_VINFO_UNALIGNED_DR (res) = NULL;\n+  LOOP_VINFO_MAY_MISALIGN_STMTS (res)\n+    = VEC_alloc (tree, heap, PARAM_VALUE (PARAM_VECT_MAX_VERSION_CHECKS));\n \n   return res;\n }\n@@ -1480,6 +1483,7 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo)\n   free (LOOP_VINFO_BBS (loop_vinfo));\n   varray_clear (LOOP_VINFO_DATAREFS (loop_vinfo));\n   varray_clear (LOOP_VINFO_DDRS (loop_vinfo));\n+  VEC_free (tree, heap, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo));\n \n   free (loop_vinfo);\n }\n@@ -2049,7 +2053,7 @@ vectorize_loops (struct loops *loops)\n       if (!loop_vinfo || !LOOP_VINFO_VECTORIZABLE_P (loop_vinfo))\n \tcontinue;\n \n-      vect_transform_loop (loop_vinfo, loops); \n+      vect_transform_loop (loop_vinfo, loops);\n       num_vectorized_loops++;\n     }\n "}, {"sha": "4f7fd951d6d4a79dca3f76f925a0400350375755", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c12cc93047bf59f210231a102df277dad6ad2ab1/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c12cc93047bf59f210231a102df277dad6ad2ab1", "patch": "@@ -117,28 +117,37 @@ typedef struct _loop_vec_info {\n                  unaligned_dr.  */\n   int peeling_for_alignment;\n \n+  /* The mask used to check the alignment of pointers or arrays.  */\n+  int ptr_mask;\n+\n   /* All data references in the loop.  */\n   varray_type datarefs;\n \n   /* All data dependences in the loop.  */\n   varray_type ddrs;\n \n+  /* Statements in the loop that have data references that are candidates for a\n+     runtime (loop versioning) misalignment check.  */\n+  VEC(tree,heap) *may_misalign_stmts;\n+\n   /* The loop location in the source.  */\n   LOC loop_line_number;\n } *loop_vec_info;\n \n-  /* Access Functions.  */\n+/* Access Functions.  */\n #define LOOP_VINFO_LOOP(L)            (L)->loop\n #define LOOP_VINFO_BBS(L)             (L)->bbs\n #define LOOP_VINFO_EXIT_COND(L)       (L)->exit_cond\n #define LOOP_VINFO_NITERS(L)          (L)->num_iters\n #define LOOP_VINFO_VECTORIZABLE_P(L)  (L)->vectorizable\n #define LOOP_VINFO_VECT_FACTOR(L)     (L)->vectorization_factor\n+#define LOOP_VINFO_PTR_MASK(L)        (L)->ptr_mask\n #define LOOP_VINFO_DATAREFS(L)        (L)->datarefs\n #define LOOP_VINFO_DDRS(L)            (L)->ddrs\n #define LOOP_VINFO_INT_NITERS(L)      (TREE_INT_CST_LOW ((L)->num_iters))\n #define LOOP_PEELING_FOR_ALIGNMENT(L) (L)->peeling_for_alignment\n #define LOOP_VINFO_UNALIGNED_DR(L)    (L)->unaligned_dr\n+#define LOOP_VINFO_MAY_MISALIGN_STMTS(L) (L)->may_misalign_stmts\n #define LOOP_VINFO_LOC(L)             (L)->loop_line_number\n \n #define LOOP_VINFO_NITERS_KNOWN_P(L)                     \\"}]}