{"sha": "2130efe6ac7beba72d289e3dd145daa10aeaed54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjEzMGVmZTZhYzdiZWJhNzJkMjg5ZTNkZDE0NWRhYTEwYWVhZWQ1NA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-08-26T13:12:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-08-26T14:02:32Z"}, "message": "tree-optimization/96698 - fix ICE when vectorizing nested cycles\n\nThis fixes vectorized PHI latch edge updating and delay it until\nall of the loop is code generated to deal with the case that the\nlatch def is a PHI in the same block.\n\n2020-08-26  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/96698\n\t* tree-vectorizer.h (loop_vec_info::reduc_latch_defs): New.\n\t(loop_vec_info::reduc_latch_slp_defs): Likewise.\n\t* tree-vect-stmts.c (vect_transform_stmt): Only record\n\tstmts to update PHI latches from, perform the update ...\n\t* tree-vect-loop.c (vect_transform_loop): ... here after\n\tvectorizing those PHIs.\n\t(info_for_reduction): Properly handle non-reduction PHIs.\n\n\t* gcc.dg/vect/pr96698.c: New testcase.", "tree": {"sha": "9f9f63553ccafec89b413aea2df46de595dbf809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f9f63553ccafec89b413aea2df46de595dbf809"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2130efe6ac7beba72d289e3dd145daa10aeaed54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2130efe6ac7beba72d289e3dd145daa10aeaed54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2130efe6ac7beba72d289e3dd145daa10aeaed54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2130efe6ac7beba72d289e3dd145daa10aeaed54/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3eefb302d2bd8502cb3d8fe44e672b11092ccaf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eefb302d2bd8502cb3d8fe44e672b11092ccaf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eefb302d2bd8502cb3d8fe44e672b11092ccaf6"}], "stats": {"total": 88, "additions": 63, "deletions": 25}, "files": [{"sha": "1d141c1dfff78e3391a4f41efe82ba7ff93f7d41", "filename": "gcc/testsuite/gcc.dg/vect/pr96698.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2130efe6ac7beba72d289e3dd145daa10aeaed54/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr96698.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2130efe6ac7beba72d289e3dd145daa10aeaed54/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr96698.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr96698.c?ref=2130efe6ac7beba72d289e3dd145daa10aeaed54", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+\n+void test(int a, int* i)\n+{\n+  for (; a < 5; ++a)\n+    {\n+      int b = 0;\n+      int c = 0;\n+      for (; b != -11; b--)\n+\tfor (int d = 0; d ==0; d++)\n+\t  {\n+\t    *i += c & a;\n+\t    c = b;\n+\t  }\n+    }\n+}\n+\n+/* We should be able to vectorize the inner cycle.  */\n+/* { dg-final { scan-tree-dump \"OUTER LOOP VECTORIZED\" \"vect\" { target vect_int } } } */"}, {"sha": "50abb2b2f3cc44dce321e771d1ef75b865d32308", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2130efe6ac7beba72d289e3dd145daa10aeaed54/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2130efe6ac7beba72d289e3dd145daa10aeaed54/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=2130efe6ac7beba72d289e3dd145daa10aeaed54", "patch": "@@ -4646,7 +4646,8 @@ info_for_reduction (vec_info *vinfo, stmt_vec_info stmt_info)\n {\n   stmt_info = vect_orig_stmt (stmt_info);\n   gcc_assert (STMT_VINFO_REDUC_DEF (stmt_info));\n-  if (!is_a <gphi *> (stmt_info->stmt))\n+  if (!is_a <gphi *> (stmt_info->stmt)\n+      || !VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_info)))\n     stmt_info = STMT_VINFO_REDUC_DEF (stmt_info);\n   gphi *phi = as_a <gphi *> (stmt_info->stmt);\n   if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def)\n@@ -9031,6 +9032,38 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n \t    }\n \t}\n \n+      /* Fill in backedge defs of reductions.  */\n+      for (unsigned i = 0; i < loop_vinfo->reduc_latch_defs.length (); ++i)\n+\t{\n+\t  stmt_vec_info stmt_info = loop_vinfo->reduc_latch_defs[i];\n+\t  stmt_vec_info orig_stmt_info = vect_orig_stmt (stmt_info);\n+\t  vec<gimple *> &phi_info\n+\t    = STMT_VINFO_VEC_STMTS (STMT_VINFO_REDUC_DEF (orig_stmt_info));\n+\t  vec<gimple *> &vec_stmt\n+\t    = STMT_VINFO_VEC_STMTS (stmt_info);\n+\t  gcc_assert (phi_info.length () == vec_stmt.length ());\n+\t  gphi *phi\n+\t    = dyn_cast <gphi *> (STMT_VINFO_REDUC_DEF (orig_stmt_info)->stmt);\n+\t  edge e = loop_latch_edge (gimple_bb (phi_info[0])->loop_father);\n+\t  for (unsigned j = 0; j < phi_info.length (); ++j)\n+\t    add_phi_arg (as_a <gphi *> (phi_info[j]),\n+\t\t\t gimple_get_lhs (vec_stmt[j]), e,\n+\t\t\t gimple_phi_arg_location (phi, e->dest_idx));\n+\t}\n+      for (unsigned i = 0; i < loop_vinfo->reduc_latch_slp_defs.length (); ++i)\n+\t{\n+\t  slp_tree slp_node = loop_vinfo->reduc_latch_slp_defs[i].first;\n+\t  slp_tree phi_node = loop_vinfo->reduc_latch_slp_defs[i].second;\n+\t  gphi *phi = as_a <gphi *> (SLP_TREE_SCALAR_STMTS (phi_node)[0]->stmt);\n+\t  e = loop_latch_edge (gimple_bb (phi)->loop_father);\n+\t  gcc_assert (SLP_TREE_VEC_STMTS (phi_node).length ()\n+\t\t      == SLP_TREE_VEC_STMTS (slp_node).length ());\n+\t  for (unsigned j = 0; j < SLP_TREE_VEC_STMTS (phi_node).length (); ++j)\n+\t    add_phi_arg (as_a <gphi *> (SLP_TREE_VEC_STMTS (phi_node)[j]),\n+\t\t\t vect_get_slp_vect_def (slp_node, j),\n+\t\t\t e, gimple_phi_arg_location (phi, e->dest_idx));\n+\t}\n+\n       /* Stub out scalar statements that must not survive vectorization.\n \t Doing this here helps with grouped statements, or statements that\n \t are involved in patterns.  */"}, {"sha": "04d202e670ea202434ffa1f7050a8ed246999898", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2130efe6ac7beba72d289e3dd145daa10aeaed54/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2130efe6ac7beba72d289e3dd145daa10aeaed54/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=2130efe6ac7beba72d289e3dd145daa10aeaed54", "patch": "@@ -10920,8 +10920,8 @@ vect_transform_stmt (vec_info *vinfo,\n   if (STMT_VINFO_TYPE (stmt_info) == store_vec_info_type)\n     return is_store;\n \n-  /* If this stmt defines a value used on a backedge, update the\n-     vectorized PHIs.  */\n+  /* If this stmt defines a value used on a backedge, record it so\n+     we can update the vectorized PHIs later.  */\n   stmt_vec_info orig_stmt_info = vect_orig_stmt (stmt_info);\n   stmt_vec_info reduc_info;\n   if (STMT_VINFO_REDUC_DEF (orig_stmt_info)\n@@ -10940,30 +10940,11 @@ vect_transform_stmt (vec_info *vinfo,\n \t  && (e = loop_latch_edge (gimple_bb (phi)->loop_father))\n \t  && (PHI_ARG_DEF_FROM_EDGE (phi, e)\n \t      == gimple_get_lhs (orig_stmt_info->stmt)))\n-\t{\n-\t  vec<gimple *> &phi_info\n-\t    = STMT_VINFO_VEC_STMTS (STMT_VINFO_REDUC_DEF (orig_stmt_info));\n-\t  vec<gimple *> &vec_stmt\n-\t    = STMT_VINFO_VEC_STMTS (stmt_info);\n-\t  gcc_assert (phi_info.length () == vec_stmt.length ());\n-\t  for (unsigned i = 0; i < phi_info.length (); ++i)\n-\t    add_phi_arg (as_a <gphi *> (phi_info[i]),\n-\t\t\t gimple_get_lhs (vec_stmt[i]), e,\n-\t\t\t gimple_phi_arg_location (phi, e->dest_idx));\n-\t}\n+\tas_a <loop_vec_info> (vinfo)->reduc_latch_defs.safe_push (stmt_info);\n       else if (slp_node\n \t       && slp_node != slp_node_instance->reduc_phis)\n-\t{\n-\t  slp_tree phi_node = slp_node_instance->reduc_phis;\n-\t  gphi *phi = as_a <gphi *> (SLP_TREE_SCALAR_STMTS (phi_node)[0]->stmt);\n-\t  e = loop_latch_edge (gimple_bb (phi)->loop_father);\n-\t  gcc_assert (SLP_TREE_VEC_STMTS (phi_node).length ()\n-\t\t      == SLP_TREE_VEC_STMTS (slp_node).length ());\n-\t  for (unsigned i = 0; i < SLP_TREE_VEC_STMTS (phi_node).length (); ++i)\n-\t    add_phi_arg (as_a <gphi *> (SLP_TREE_VEC_STMTS (phi_node)[i]),\n-\t\t\t vect_get_slp_vect_def (slp_node, i),\n-\t\t\t e, gimple_phi_arg_location (phi, e->dest_idx));\n-\t}\n+\tas_a <loop_vec_info> (vinfo)->reduc_latch_slp_defs.safe_push\n+\t    (std::make_pair (slp_node, slp_node_instance->reduc_phis));\n     }\n \n   /* Handle stmts whose DEF is used outside the loop-nest that is"}, {"sha": "f36e2ad96267085aa0f240a8ced3aef17e724c1b", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2130efe6ac7beba72d289e3dd145daa10aeaed54/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2130efe6ac7beba72d289e3dd145daa10aeaed54/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=2130efe6ac7beba72d289e3dd145daa10aeaed54", "patch": "@@ -627,6 +627,11 @@ typedef class _loop_vec_info : public vec_info {\n      stmt in the chain.  */\n   auto_vec<stmt_vec_info> reduction_chains;\n \n+  /* The vectorized stmts defining the latch values of the reduction\n+     they are involved with.  */\n+  auto_vec<stmt_vec_info> reduc_latch_defs;\n+  auto_vec<std::pair<slp_tree, slp_tree> > reduc_latch_slp_defs;\n+\n   /* Cost vector for a single scalar iteration.  */\n   auto_vec<stmt_info_for_cost> scalar_cost_vec;\n "}]}