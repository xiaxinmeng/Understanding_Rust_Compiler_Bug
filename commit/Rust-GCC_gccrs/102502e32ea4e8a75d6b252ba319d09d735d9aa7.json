{"sha": "102502e32ea4e8a75d6b252ba319d09d735d9aa7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAyNTAyZTMyZWE0ZThhNzVkNmIyNTJiYTMxOWQwOWQ3MzVkOWFhNw==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2020-07-14T11:39:46Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2020-07-14T11:39:46Z"}, "message": "[OpenMP, Fortran] Add structure/derived-type element mapping\n\ngcc/fortran/ChangeLog:\n\n\t* openmp.c (gfc_match_omp_clauses): Match also derived-type\n\tcomponent refs in OMP_CLAUSE_MAP.\n\t(resolve_omp_clauses): Resolve those.\n\t* trans-openmp.c (gfc_trans_omp_array_section, gfc_trans_omp_clauses):\n\tHandle OpenMP structure-element mapping.\n\t(gfc_trans_oacc_construct, gfc_trans_oacc_executable_directive,\n\t(gfc_trans_oacc_combined_directive, gfc_trans_oacc_declare): Update\n\tadd openacc=true in gfc_trans_omp_clauses call.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/goacc/finalize-1.f: Update dump scan pattern.\n\t* gfortran.dg/gomp/map-1.f90: Update dg-error.\n\t* gfortran.dg/gomp/map-2.f90: New test.\n\nlibgomp/ChangeLog:\n\n\t* testsuite/libgomp.fortran/struct-elem-map-1.f90: New test.", "tree": {"sha": "6f36014d56cdeb71b20c56fc9ad303762388519a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f36014d56cdeb71b20c56fc9ad303762388519a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/102502e32ea4e8a75d6b252ba319d09d735d9aa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/102502e32ea4e8a75d6b252ba319d09d735d9aa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/102502e32ea4e8a75d6b252ba319d09d735d9aa7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/102502e32ea4e8a75d6b252ba319d09d735d9aa7/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "174e79bf73331b41b7a14dffd45ed8293487f0e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174e79bf73331b41b7a14dffd45ed8293487f0e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/174e79bf73331b41b7a14dffd45ed8293487f0e0"}], "stats": {"total": 713, "additions": 595, "deletions": 118}, "files": [{"sha": "7de2f6e1b1deb5dd93a9bdd32db8afffa4655f85", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/102502e32ea4e8a75d6b252ba319d09d735d9aa7/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/102502e32ea4e8a75d6b252ba319d09d735d9aa7/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=102502e32ea4e8a75d6b252ba319d09d735d9aa7", "patch": "@@ -1464,7 +1464,7 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t      head = NULL;\n \t      if (gfc_match_omp_variable_list (\"\", &c->lists[OMP_LIST_MAP],\n \t\t\t\t\t       false, NULL, &head,\n-\t\t\t\t\t       true) == MATCH_YES)\n+\t\t\t\t\t       true, true) == MATCH_YES)\n \t\t{\n \t\t  gfc_omp_namelist *n;\n \t\t  for (n = *head; n; n = n->next)\n@@ -4553,7 +4553,7 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \n \t\t    /* Look through component refs to find last array\n \t\t       reference.  */\n-\t\t    if (openacc && resolved)\n+\t\t    if (resolved)\n \t\t      {\n \t\t\t/* The \"!$acc cache\" directive allows rectangular\n \t\t\t   subarrays to be specified, with some restrictions\n@@ -4563,6 +4563,7 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t\t   arr(-n:n,-n:n) could be contiguous even if it looks\n \t\t\t   like it may not be.  */\n \t\t\tif (list != OMP_LIST_CACHE\n+\t\t\t    && list != OMP_LIST_DEPEND\n \t\t\t    && !gfc_is_simply_contiguous (n->expr, false, true)\n \t\t\t    && gfc_is_not_contiguous (n->expr))\n \t\t\t  gfc_error (\"Array is not contiguous at %L\","}, {"sha": "f35ff4191c27e60e0bb5558647614696ce2c8492", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 235, "deletions": 97, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/102502e32ea4e8a75d6b252ba319d09d735d9aa7/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/102502e32ea4e8a75d6b252ba319d09d735d9aa7/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=102502e32ea4e8a75d6b252ba319d09d735d9aa7", "patch": "@@ -2092,10 +2092,11 @@ static vec<tree, va_heap, vl_embed> *doacross_steps;\n static void\n gfc_trans_omp_array_section (stmtblock_t *block, gfc_omp_namelist *n,\n \t\t\t     tree decl, bool element, gomp_map_kind ptr_kind,\n-\t\t\t     tree node, tree &node2, tree &node3, tree &node4)\n+\t\t\t     tree &node, tree &node2, tree &node3, tree &node4)\n {\n   gfc_se se;\n   tree ptr, ptr2;\n+  tree elemsz = NULL_TREE;\n \n   gfc_init_se (&se, NULL);\n \n@@ -2104,7 +2105,8 @@ gfc_trans_omp_array_section (stmtblock_t *block, gfc_omp_namelist *n,\n       gfc_conv_expr_reference (&se, n->expr);\n       gfc_add_block_to_block (block, &se.pre);\n       ptr = se.expr;\n-      OMP_CLAUSE_SIZE (node) = TYPE_SIZE_UNIT (TREE_TYPE (ptr));\n+      OMP_CLAUSE_SIZE (node) = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (ptr)));\n+      elemsz = OMP_CLAUSE_SIZE (node);\n     }\n   else\n     {\n@@ -2114,14 +2116,15 @@ gfc_trans_omp_array_section (stmtblock_t *block, gfc_omp_namelist *n,\n       gfc_add_block_to_block (block, &se.pre);\n       OMP_CLAUSE_SIZE (node) = gfc_full_array_size (block, se.expr,\n \t\t\t\t\t\t    GFC_TYPE_ARRAY_RANK (type));\n-      tree elemsz = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n+      elemsz = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n       elemsz = fold_convert (gfc_array_index_type, elemsz);\n       OMP_CLAUSE_SIZE (node) = fold_build2 (MULT_EXPR, gfc_array_index_type,\n \t\t\t\t\t    OMP_CLAUSE_SIZE (node), elemsz);\n     }\n-  gfc_add_block_to_block (block, &se.post);\n+  gcc_assert (se.post.head == NULL_TREE);\n   ptr = fold_convert (build_pointer_type (char_type_node), ptr);\n   OMP_CLAUSE_DECL (node) = build_fold_indirect_ref (ptr);\n+  ptr = fold_convert (ptrdiff_type_node, ptr);\n \n   if (POINTER_TYPE_P (TREE_TYPE (decl))\n       && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (decl)))\n@@ -2134,28 +2137,71 @@ gfc_trans_omp_array_section (stmtblock_t *block, gfc_omp_namelist *n,\n       OMP_CLAUSE_SIZE (node4) = size_int (0);\n       decl = build_fold_indirect_ref (decl);\n     }\n-  ptr = fold_convert (sizetype, ptr);\n+  else if (ptr_kind == GOMP_MAP_ALWAYS_POINTER\n+\t   && n->expr->ts.type == BT_CHARACTER\n+\t   && n->expr->ts.deferred)\n+    {\n+      gomp_map_kind map_kind;\n+      if (GOMP_MAP_COPY_TO_P (OMP_CLAUSE_MAP_KIND (node)))\n+\tmap_kind = GOMP_MAP_TO;\n+      else if (OMP_CLAUSE_MAP_KIND (node) == GOMP_MAP_RELEASE\n+\t       || OMP_CLAUSE_MAP_KIND (node) == GOMP_MAP_DELETE)\n+\tmap_kind = OMP_CLAUSE_MAP_KIND (node);\n+      else\n+\tmap_kind = GOMP_MAP_ALLOC;\n+      gcc_assert (se.string_length);\n+      node4 = build_omp_clause (input_location, OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_SET_MAP_KIND (node4, map_kind);\n+      OMP_CLAUSE_DECL (node4) = se.string_length;\n+      OMP_CLAUSE_SIZE (node4) = TYPE_SIZE_UNIT (gfc_charlen_type_node);\n+    }\n   if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n     {\n+      tree desc_node;\n       tree type = TREE_TYPE (decl);\n       ptr2 = gfc_conv_descriptor_data_get (decl);\n-      node2 = build_omp_clause (input_location,\n-\t\t\t\tOMP_CLAUSE_MAP);\n-      OMP_CLAUSE_SET_MAP_KIND (node2, GOMP_MAP_TO_PSET);\n-      OMP_CLAUSE_DECL (node2) = decl;\n-      OMP_CLAUSE_SIZE (node2) = TYPE_SIZE_UNIT (type);\n+      desc_node = build_omp_clause (input_location, OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_DECL (desc_node) = decl;\n+      OMP_CLAUSE_SIZE (desc_node) = TYPE_SIZE_UNIT (type);\n+      if (ptr_kind == GOMP_MAP_ALWAYS_POINTER)\n+\t{\n+\t  OMP_CLAUSE_SET_MAP_KIND (desc_node, GOMP_MAP_TO);\n+\t  node2 = node;\n+\t  node = desc_node;  /* Needs to come first.  */\n+\t}\n+      else\n+\t{\n+\t  OMP_CLAUSE_SET_MAP_KIND (desc_node, GOMP_MAP_TO_PSET);\n+\t  node2 = desc_node;\n+\t}\n       node3 = build_omp_clause (input_location,\n \t\t\t\tOMP_CLAUSE_MAP);\n       OMP_CLAUSE_SET_MAP_KIND (node3, ptr_kind);\n       OMP_CLAUSE_DECL (node3)\n \t= gfc_conv_descriptor_data_get (decl);\n+      /* This purposely does not include GOMP_MAP_ALWAYS_POINTER.  The extra\n+\t cast prevents gimplify.c from recognising it as being part of the\n+\t struct \u2013 and adding an 'alloc: for the 'desc.data' pointer, which\n+\t would break as the 'desc' (the descriptor) is also mapped\n+\t (see node4 above).  */\n       if (ptr_kind == GOMP_MAP_ATTACH_DETACH)\n \tSTRIP_NOPS (OMP_CLAUSE_DECL (node3));\n     }\n   else\n     {\n       if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n-\tptr2 = build_fold_addr_expr (decl);\n+\t{\n+\t  tree offset;\n+\t  ptr2 = build_fold_addr_expr (decl);\n+\t  offset = fold_build2 (MINUS_EXPR, ptrdiff_type_node, ptr,\n+\t\t\t\tfold_convert (ptrdiff_type_node, ptr2));\n+\t  offset = build2 (TRUNC_DIV_EXPR, ptrdiff_type_node,\n+\t\t\t   offset, fold_convert (ptrdiff_type_node, elemsz));\n+\t  offset = build4_loc (input_location, ARRAY_REF,\n+\t\t\t       TREE_TYPE (TREE_TYPE (decl)),\n+\t\t\t       decl, offset, NULL_TREE, NULL_TREE);\n+\t  OMP_CLAUSE_DECL (node) = offset;\n+\t}\n       else\n \t{\n \t  gcc_assert (POINTER_TYPE_P (TREE_TYPE (decl)));\n@@ -2166,14 +2212,15 @@ gfc_trans_omp_array_section (stmtblock_t *block, gfc_omp_namelist *n,\n       OMP_CLAUSE_SET_MAP_KIND (node3, ptr_kind);\n       OMP_CLAUSE_DECL (node3) = decl;\n     }\n-  ptr2 = fold_convert (sizetype, ptr2);\n-  OMP_CLAUSE_SIZE (node3)\n-    = fold_build2 (MINUS_EXPR, sizetype, ptr, ptr2);\n+  ptr2 = fold_convert (ptrdiff_type_node, ptr2);\n+  OMP_CLAUSE_SIZE (node3) = fold_build2 (MINUS_EXPR, ptrdiff_type_node,\n+\t\t\t\t\t ptr, ptr2);\n }\n \n static tree\n gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n-\t\t       locus where, bool declare_simd = false)\n+\t\t       locus where, bool declare_simd = false,\n+\t\t       bool openacc = false)\n {\n   tree omp_clauses = NULL_TREE, chunk_size, c;\n   int list, ifc;\n@@ -2488,6 +2535,67 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t      tree node2 = NULL_TREE;\n \t      tree node3 = NULL_TREE;\n \t      tree node4 = NULL_TREE;\n+\n+\t      switch (n->u.map_op)\n+\t\t{\n+\t\tcase OMP_MAP_ALLOC:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALLOC);\n+\t\t  break;\n+\t\tcase OMP_MAP_IF_PRESENT:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_IF_PRESENT);\n+\t\t  break;\n+\t\tcase OMP_MAP_ATTACH:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ATTACH);\n+\t\t  break;\n+\t\tcase OMP_MAP_TO:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_TO);\n+\t\t  break;\n+\t\tcase OMP_MAP_FROM:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FROM);\n+\t\t  break;\n+\t\tcase OMP_MAP_TOFROM:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_TOFROM);\n+\t\t  break;\n+\t\tcase OMP_MAP_ALWAYS_TO:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALWAYS_TO);\n+\t\t  break;\n+\t\tcase OMP_MAP_ALWAYS_FROM:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALWAYS_FROM);\n+\t\t  break;\n+\t\tcase OMP_MAP_ALWAYS_TOFROM:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALWAYS_TOFROM);\n+\t\t  break;\n+\t\tcase OMP_MAP_RELEASE:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_RELEASE);\n+\t\t  break;\n+\t\tcase OMP_MAP_DELETE:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_DELETE);\n+\t\t  break;\n+\t\tcase OMP_MAP_DETACH:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_DETACH);\n+\t\t  break;\n+\t\tcase OMP_MAP_FORCE_ALLOC:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_ALLOC);\n+\t\t  break;\n+\t\tcase OMP_MAP_FORCE_TO:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_TO);\n+\t\t  break;\n+\t\tcase OMP_MAP_FORCE_FROM:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_FROM);\n+\t\t  break;\n+\t\tcase OMP_MAP_FORCE_TOFROM:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_TOFROM);\n+\t\t  break;\n+\t\tcase OMP_MAP_FORCE_PRESENT:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_PRESENT);\n+\t\t  break;\n+\t\tcase OMP_MAP_FORCE_DEVICEPTR:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_DEVICEPTR);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\n \t      tree decl = gfc_trans_omp_variable (n->sym, false);\n \t      if (DECL_P (decl))\n \t\tTREE_ADDRESSABLE (decl) = 1;\n@@ -2496,7 +2604,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t      && n->expr->ref->u.ar.type == AR_FULL))\n \t\t{\n \t\t  tree present = gfc_omp_check_optional_argument (decl, true);\n-\t\t  if (n->sym->ts.type == BT_CLASS)\n+\t\t  if (openacc && n->sym->ts.type == BT_CLASS)\n \t\t    {\n \t\t      tree type = TREE_TYPE (decl);\n \t\t      if (n->sym->attr.optional)\n@@ -2724,8 +2832,42 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t      /* Last component is a scalar.  */\n \t\t      gfc_conv_expr (&se, n->expr);\n \t\t      gfc_add_block_to_block (block, &se.pre);\n-\t\t      OMP_CLAUSE_DECL (node) = se.expr;\n+\t\t      /* For BT_CHARACTER a pointer is returned.  */\n+\t\t      OMP_CLAUSE_DECL (node)\n+\t\t\t= POINTER_TYPE_P (TREE_TYPE (se.expr))\n+\t\t\t  ? build_fold_indirect_ref (se.expr) : se.expr;\n \t\t      gfc_add_block_to_block (block, &se.post);\n+\t\t      if (sym_attr.pointer || sym_attr.allocatable)\n+\t\t\t{\n+\t\t\t  node2 = build_omp_clause (input_location,\n+\t\t\t\t\t\t    OMP_CLAUSE_MAP);\n+\t\t\t  OMP_CLAUSE_SET_MAP_KIND (node2,\n+\t\t\t\t\t\t   openacc\n+\t\t\t\t\t\t   ? GOMP_MAP_ATTACH_DETACH\n+\t\t\t\t\t\t   : GOMP_MAP_ALWAYS_POINTER);\n+\t\t\t  OMP_CLAUSE_DECL (node2)\n+\t\t\t    = POINTER_TYPE_P (TREE_TYPE (se.expr))\n+\t\t\t      ? se.expr :  gfc_build_addr_expr (NULL, se.expr);\n+\t\t\t  OMP_CLAUSE_SIZE (node2) = size_int (0);\n+\t\t\t  if (!openacc\n+\t\t\t      && n->expr->ts.type == BT_CHARACTER\n+\t\t\t      && n->expr->ts.deferred)\n+\t\t\t    {\n+\t\t\t      gcc_assert (se.string_length);\n+\t\t\t      tree tmp = gfc_get_char_type (n->expr->ts.kind);\n+\t\t\t      OMP_CLAUSE_SIZE (node)\n+\t\t\t\t= fold_build2 (MULT_EXPR, size_type_node,\n+\t\t\t\t\t       fold_convert (size_type_node,\n+\t\t\t\t\t\t\t     se.string_length),\n+\t\t\t\t\t       TYPE_SIZE_UNIT (tmp));\n+\t\t\t      node3 = build_omp_clause (input_location,\n+\t\t\t\t\t\t\tOMP_CLAUSE_MAP);\n+\t\t\t      OMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_TO);\n+\t\t\t      OMP_CLAUSE_DECL (node3) = se.string_length;\n+\t\t\t      OMP_CLAUSE_SIZE (node3)\n+\t\t\t\t= TYPE_SIZE_UNIT (gfc_charlen_type_node);\n+\t\t\t    }\n+\t\t\t}\n \t\t      goto finalize_map_clause;\n \t\t    }\n \n@@ -2752,7 +2894,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t  if (lastcomp->u.c.component->ts.type == BT_DERIVED\n \t\t      || lastcomp->u.c.component->ts.type == BT_CLASS)\n \t\t    {\n-\t\t      if (sym_attr.allocatable || sym_attr.pointer)\n+\t\t      if (sym_attr.pointer || (openacc && sym_attr.allocatable))\n \t\t\t{\n \t\t\t  tree data, size;\n \n@@ -2773,7 +2915,9 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t  node2 = build_omp_clause (input_location,\n \t\t\t\t\t\t    OMP_CLAUSE_MAP);\n \t\t\t  OMP_CLAUSE_SET_MAP_KIND (node2,\n-\t\t\t\t\t\t   GOMP_MAP_ATTACH_DETACH);\n+\t\t\t\t\t\t   openacc\n+\t\t\t\t\t\t   ? GOMP_MAP_ATTACH_DETACH\n+\t\t\t\t\t\t   : GOMP_MAP_ALWAYS_POINTER);\n \t\t\t  OMP_CLAUSE_DECL (node2) = data;\n \t\t\t  OMP_CLAUSE_SIZE (node2) = size_int (0);\n \t\t\t}\n@@ -2800,32 +2944,82 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \n \t\t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (inner)))\n \t\t\t{\n+\t\t\t  gomp_map_kind map_kind;\n+\t\t\t  tree desc_node;\n \t\t\t  tree type = TREE_TYPE (inner);\n \t\t\t  tree ptr = gfc_conv_descriptor_data_get (inner);\n \t\t\t  ptr = build_fold_indirect_ref (ptr);\n \t\t\t  OMP_CLAUSE_DECL (node) = ptr;\n-\t\t\t  node2 = build_omp_clause (input_location,\n-\t\t\t\t\t\t    OMP_CLAUSE_MAP);\n-\t\t\t  OMP_CLAUSE_SET_MAP_KIND (node2, GOMP_MAP_TO_PSET);\n-\t\t\t  OMP_CLAUSE_DECL (node2) = inner;\n-\t\t\t  OMP_CLAUSE_SIZE (node2) = TYPE_SIZE_UNIT (type);\n-\t\t\t  node3 = build_omp_clause (input_location,\n-\t\t\t\t\t\t    OMP_CLAUSE_MAP);\n-\t\t\t  OMP_CLAUSE_SET_MAP_KIND (node3,\n-\t\t\t\t\t\t   GOMP_MAP_ATTACH_DETACH);\n-\t\t\t  OMP_CLAUSE_DECL (node3)\n-\t\t\t    = gfc_conv_descriptor_data_get (inner);\n-\t\t\t  STRIP_NOPS (OMP_CLAUSE_DECL (node3));\n-\t\t\t  OMP_CLAUSE_SIZE (node3) = size_int (0);\n \t\t\t  int rank = GFC_TYPE_ARRAY_RANK (type);\n \t\t\t  OMP_CLAUSE_SIZE (node)\n \t\t\t    = gfc_full_array_size (block, inner, rank);\n \t\t\t  tree elemsz\n \t\t\t    = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n+\t\t\t  if (GOMP_MAP_COPY_TO_P (OMP_CLAUSE_MAP_KIND (node)))\n+\t\t\t    map_kind = GOMP_MAP_TO;\n+\t\t\t  else if (n->u.map_op == OMP_MAP_RELEASE\n+\t\t\t\t   || n->u.map_op == OMP_MAP_DELETE)\n+\t\t\t    map_kind = OMP_CLAUSE_MAP_KIND (node);\n+\t\t\t  else\n+\t\t\t    map_kind = GOMP_MAP_ALLOC;\n+\t\t\t  if (!openacc\n+\t\t\t      && n->expr->ts.type == BT_CHARACTER\n+\t\t\t      && n->expr->ts.deferred)\n+\t\t\t    {\n+\t\t\t      gcc_assert (se.string_length);\n+\t\t\t      tree len = fold_convert (size_type_node,\n+\t\t\t\t\t\t       se.string_length);\n+\t\t\t      elemsz = gfc_get_char_type (n->expr->ts.kind);\n+\t\t\t      elemsz = TYPE_SIZE_UNIT (elemsz);\n+\t\t\t      elemsz = fold_build2 (MULT_EXPR, size_type_node,\n+\t\t\t\t\t\t    len, elemsz);\n+\t\t\t      node4 = build_omp_clause (input_location,\n+\t\t\t\t\t\t\tOMP_CLAUSE_MAP);\n+\t\t\t      OMP_CLAUSE_SET_MAP_KIND (node4, map_kind);\n+\t\t\t      OMP_CLAUSE_DECL (node4) = se.string_length;\n+\t\t\t      OMP_CLAUSE_SIZE (node4)\n+\t\t\t\t= TYPE_SIZE_UNIT (gfc_charlen_type_node);\n+\t\t\t    }\n \t\t\t  elemsz = fold_convert (gfc_array_index_type, elemsz);\n \t\t\t  OMP_CLAUSE_SIZE (node)\n \t\t\t    = fold_build2 (MULT_EXPR, gfc_array_index_type,\n \t\t\t\t\t   OMP_CLAUSE_SIZE (node), elemsz);\n+\t\t\t  desc_node = build_omp_clause (input_location,\n+\t\t\t\t\t\t\tOMP_CLAUSE_MAP);\n+\t\t\t  if (openacc)\n+\t\t\t    OMP_CLAUSE_SET_MAP_KIND (desc_node,\n+\t\t\t\t\t\t     GOMP_MAP_TO_PSET);\n+\t\t\t  else\n+\t\t\t    OMP_CLAUSE_SET_MAP_KIND (desc_node, map_kind);\n+\t\t\t  OMP_CLAUSE_DECL (desc_node) = inner;\n+\t\t\t  OMP_CLAUSE_SIZE (desc_node) = TYPE_SIZE_UNIT (type);\n+\t\t\t  if (openacc)\n+\t\t\t    node2 = desc_node;\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      node2 = node;\n+\t\t\t      node = desc_node;  /* Put first.  */\n+\t\t\t    }\n+\t\t\t  node3 = build_omp_clause (input_location,\n+\t\t\t\t\t\t    OMP_CLAUSE_MAP);\n+\t\t\t  OMP_CLAUSE_SET_MAP_KIND (node3,\n+\t\t\t\t\t\t   openacc\n+\t\t\t\t\t\t   ? GOMP_MAP_ATTACH_DETACH\n+\t\t\t\t\t\t   : GOMP_MAP_ALWAYS_POINTER);\n+\t\t\t  OMP_CLAUSE_DECL (node3)\n+\t\t\t    = gfc_conv_descriptor_data_get (inner);\n+\t\t\t  /* Similar to gfc_trans_omp_array_section (details\n+\t\t\t     there), we add/keep the cast for OpenMP to prevent\n+\t\t\t     that an 'alloc:' gets added for node3 ('desc.data')\n+\t\t\t     as that is part of the whole descriptor (node3).\n+\t\t\t     TODO: Remove once the ME handles this properly.  */\n+\t\t\t  if (!openacc)\n+\t\t\t    OMP_CLAUSE_DECL (node3)\n+\t\t\t\t= fold_convert (TREE_TYPE (TREE_OPERAND(ptr, 0)),\n+\t\t\t\t\t\tOMP_CLAUSE_DECL (node3));\n+\t\t\t  else\n+\t\t\t    STRIP_NOPS (OMP_CLAUSE_DECL (node3));\n+\t\t\t  OMP_CLAUSE_SIZE (node3) = size_int (0);\n \t\t\t}\n \t\t      else\n \t\t\tOMP_CLAUSE_DECL (node) = inner;\n@@ -2837,9 +3031,11 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t   && lastcomp->next->type == REF_ARRAY\n \t\t\t   && lastcomp->next->u.ar.type == AR_ELEMENT);\n \n+\t\t      gomp_map_kind kind = (openacc ? GOMP_MAP_ATTACH_DETACH\n+\t\t\t\t\t\t    : GOMP_MAP_ALWAYS_POINTER);\n \t\t      gfc_trans_omp_array_section (block, n, inner, element,\n-\t\t\t\t\t\t   GOMP_MAP_ATTACH_DETACH,\n-\t\t\t\t\t\t   node, node2, node3, node4);\n+\t\t\t\t\t\t   kind, node, node2, node3,\n+\t\t\t\t\t\t   node4);\n \t\t    }\n \t\t}\n \t      else  /* An array element or array section.  */\n@@ -2851,65 +3047,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t}\n \n \t      finalize_map_clause:\n-\t      switch (n->u.map_op)\n-\t\t{\n-\t\tcase OMP_MAP_ALLOC:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALLOC);\n-\t\t  break;\n-\t\tcase OMP_MAP_IF_PRESENT:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_IF_PRESENT);\n-\t\t  break;\n-\t\tcase OMP_MAP_ATTACH:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ATTACH);\n-\t\t  break;\n-\t\tcase OMP_MAP_TO:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_TO);\n-\t\t  break;\n-\t\tcase OMP_MAP_FROM:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FROM);\n-\t\t  break;\n-\t\tcase OMP_MAP_TOFROM:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_TOFROM);\n-\t\t  break;\n-\t\tcase OMP_MAP_ALWAYS_TO:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALWAYS_TO);\n-\t\t  break;\n-\t\tcase OMP_MAP_ALWAYS_FROM:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALWAYS_FROM);\n-\t\t  break;\n-\t\tcase OMP_MAP_ALWAYS_TOFROM:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALWAYS_TOFROM);\n-\t\t  break;\n-\t\tcase OMP_MAP_RELEASE:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_RELEASE);\n-\t\t  break;\n-\t\tcase OMP_MAP_DELETE:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_DELETE);\n-\t\t  break;\n-\t\tcase OMP_MAP_DETACH:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_DETACH);\n-\t\t  break;\n-\t\tcase OMP_MAP_FORCE_ALLOC:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_ALLOC);\n-\t\t  break;\n-\t\tcase OMP_MAP_FORCE_TO:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_TO);\n-\t\t  break;\n-\t\tcase OMP_MAP_FORCE_FROM:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_FROM);\n-\t\t  break;\n-\t\tcase OMP_MAP_FORCE_TOFROM:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_TOFROM);\n-\t\t  break;\n-\t\tcase OMP_MAP_FORCE_PRESENT:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_PRESENT);\n-\t\t  break;\n-\t\tcase OMP_MAP_FORCE_DEVICEPTR:\n-\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_DEVICEPTR);\n-\t\t  break;\n-\t\tdefault:\n-\t\t  gcc_unreachable ();\n-\t\t}\n+\n \t      omp_clauses = gfc_trans_add_clause (node, omp_clauses);\n \t      if (node2)\n \t\tomp_clauses = gfc_trans_add_clause (node2, omp_clauses);\n@@ -3661,7 +3799,7 @@ gfc_trans_oacc_construct (gfc_code *code)\n \n   gfc_start_block (&block);\n   oacc_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n-\t\t\t\t\tcode->loc);\n+\t\t\t\t\tcode->loc, false, true);\n   stmt = gfc_trans_omp_code (code->block->next, true);\n   stmt = build2_loc (input_location, construct_code, void_type_node, stmt,\n \t\t     oacc_clauses);\n@@ -3697,7 +3835,7 @@ gfc_trans_oacc_executable_directive (gfc_code *code)\n \n   gfc_start_block (&block);\n   oacc_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n-\t\t\t\t\tcode->loc);\n+\t\t\t\t\tcode->loc, false, true);\n   stmt = build1_loc (input_location, construct_code, void_type_node, \n \t\t     oacc_clauses);\n   gfc_add_expr_to_block (&block, stmt);\n@@ -4522,7 +4660,7 @@ gfc_trans_oacc_combined_directive (gfc_code *code)\n       if (construct_code == OACC_KERNELS)\n \tconstruct_clauses.lists[OMP_LIST_REDUCTION] = NULL;\n       oacc_clauses = gfc_trans_omp_clauses (&block, &construct_clauses,\n-\t\t\t\t\t    code->loc);\n+\t\t\t\t\t    code->loc, false, true);\n     }\n   if (!loop_clauses.seq)\n     pblock = &block;\n@@ -5703,7 +5841,7 @@ gfc_trans_oacc_declare (gfc_code *code)\n   gfc_start_block (&block);\n \n   oacc_clauses = gfc_trans_omp_clauses (&block, code->ext.oacc_declare->clauses,\n-\t\t\t\t\tcode->loc);\n+\t\t\t\t\tcode->loc, false, true);\n   stmt = gfc_trans_omp_code (code->block->next, true);\n   stmt = build2_loc (input_location, construct_code, void_type_node, stmt,\n \t\t     oacc_clauses);"}, {"sha": "74fa408082b5f6678c7ecceac0d67768264a1387", "filename": "gcc/testsuite/gfortran.dg/goacc/finalize-1.f", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/102502e32ea4e8a75d6b252ba319d09d735d9aa7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffinalize-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/102502e32ea4e8a75d6b252ba319d09d735d9aa7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffinalize-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffinalize-1.f?ref=102502e32ea4e8a75d6b252ba319d09d735d9aa7", "patch": "@@ -20,7 +20,7 @@ SUBROUTINE f\n ! { dg-final { scan-tree-dump-times \"(?n)#pragma omp target oacc_enter_exit_data map\\\\(delete:del_f \\\\\\[len: \\[0-9\\]+\\\\\\]\\\\) finalize$\" 1 \"gimple\" } }\n \n !$ACC EXIT DATA FINALIZE DELETE (del_f_p(2:5))\n-! { dg-final { scan-tree-dump-times \"(?n)#pragma acc exit data map\\\\(release:\\\\*\\\\(c_char \\\\*\\\\) parm\\\\.0\\\\.data \\\\\\[len: \\[^\\\\\\]\\]+\\\\\\]\\\\) map\\\\(to:del_f_p \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(alloc:\\\\(integer\\\\(kind=1\\\\)\\\\\\[0:\\\\\\] \\\\* restrict\\\\) del_f_p\\\\.data \\\\\\[pointer assign, bias: \\\\(sizetype\\\\) parm\\\\.0\\\\.data - \\\\(sizetype\\\\) del_f_p\\\\.data\\\\\\]\\\\) finalize;$\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)#pragma acc exit data map\\\\(release:\\\\*\\\\(c_char \\\\*\\\\) parm\\\\.0\\\\.data \\\\\\[len: \\[^\\\\\\]\\]+\\\\\\]\\\\) map\\\\(to:del_f_p \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(alloc:\\\\(integer\\\\(kind=1\\\\)\\\\\\[0:\\\\\\] \\\\* restrict\\\\) del_f_p\\\\.data \\\\\\[pointer assign, bias: \\\\(integer\\\\(kind=8\\\\)\\\\) parm\\\\.0\\\\.data - \\\\(integer\\\\(kind=8\\\\)\\\\) del_f_p\\\\.data\\\\\\]\\\\) finalize;$\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"(?n)#pragma omp target oacc_enter_exit_data map\\\\(delete:MEM\\\\\\[\\\\(c_char \\\\*\\\\)\\[^\\\\\\]\\]+\\\\\\] \\\\\\[len: \\[^\\\\\\]\\]+\\\\\\]\\\\) map\\\\(to:del_f_p \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(alloc:del_f_p\\\\.data \\\\\\[pointer assign, bias: \\[^\\\\\\]\\]+\\\\\\]\\\\) finalize$\" 1 \"gimple\" } }\n \n !$ACC EXIT DATA COPYOUT (cpo_r)\n@@ -32,6 +32,6 @@ SUBROUTINE f\n ! { dg-final { scan-tree-dump-times \"(?n)#pragma omp target oacc_enter_exit_data map\\\\(force_from:cpo_f \\\\\\[len: \\[0-9\\]+\\\\\\]\\\\) finalize$\" 1 \"gimple\" } }\n \n !$ACC EXIT DATA COPYOUT (cpo_f_p(4:10)) FINALIZE\n-! { dg-final { scan-tree-dump-times \"(?n)#pragma acc exit data map\\\\(from:\\\\*\\\\(c_char \\\\*\\\\) parm\\\\.1\\\\.data \\\\\\[len: \\[^\\\\\\]\\]+\\\\\\]\\\\) map\\\\(to:cpo_f_p \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(alloc:\\\\(integer\\\\(kind=1\\\\)\\\\\\[0:\\\\\\] \\\\* restrict\\\\) cpo_f_p\\\\.data \\\\\\[pointer assign, bias: \\\\(sizetype\\\\) parm\\\\.1\\\\.data - \\\\(sizetype\\\\) cpo_f_p\\\\.data\\\\\\]\\\\) finalize;$\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)#pragma acc exit data map\\\\(from:\\\\*\\\\(c_char \\\\*\\\\) parm\\\\.1\\\\.data \\\\\\[len: \\[^\\\\\\]\\]+\\\\\\]\\\\) map\\\\(to:cpo_f_p \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(alloc:\\\\(integer\\\\(kind=1\\\\)\\\\\\[0:\\\\\\] \\\\* restrict\\\\) cpo_f_p\\\\.data \\\\\\[pointer assign, bias: \\\\(integer\\\\(kind=8\\\\)\\\\) parm\\\\.1\\\\.data - \\\\(integer\\\\(kind=8\\\\)\\\\) cpo_f_p\\\\.data\\\\\\]\\\\) finalize;$\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"(?n)#pragma omp target oacc_enter_exit_data map\\\\(force_from:MEM\\\\\\[\\\\(c_char \\\\*\\\\)\\[^\\\\\\]\\]+\\\\\\] \\\\\\[len: \\[^\\\\\\]\\]+\\\\\\]\\\\) map\\\\(to:cpo_f_p \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(alloc:cpo_f_p\\\\.data \\\\\\[pointer assign, bias: \\[^\\\\\\]\\]+\\\\\\]\\\\) finalize$\" 1 \"gimple\" } }\n       END SUBROUTINE f"}, {"sha": "831feffcc431b9d0e05e692c0ca96fc3ecabbc21", "filename": "gcc/testsuite/gfortran.dg/gomp/map-1.f90", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/102502e32ea4e8a75d6b252ba319d09d735d9aa7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fmap-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/102502e32ea4e8a75d6b252ba319d09d735d9aa7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fmap-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fmap-1.f90?ref=102502e32ea4e8a75d6b252ba319d09d735d9aa7", "patch": "@@ -57,18 +57,20 @@ subroutine test(aas)\n   !$omp target map(j(:))\n   !$omp end target\n \n-  !$omp target map(j(1:9:2)) ! { dg-error \"Stride should not be specified for array section in MAP clause\" }\n+  !$omp target map(j(1:9:2))\n+ ! { dg-error \"Array is not contiguous\" \"\" { target *-*-* } 60 }\n+ ! { dg-error \"Stride should not be specified for array section in MAP clause\" \"\" { target *-*-* } 60 }\n   !$omp end target\n \n   !$omp target map(aas(5:))\n   !$omp end target\n-  ! { dg-error \"Rightmost upper bound of assumed size array section not specified\" \"\" { target *-*-* } 63 }\n-  ! { dg-error \"'aas' in MAP clause at \\\\\\(1\\\\\\) is not a proper array section\" \"\" { target *-*-* } 63 }\n+  ! { dg-error \"Rightmost upper bound of assumed size array section not specified\" \"\" { target *-*-* } 65 }\n+  ! { dg-error \"'aas' in MAP clause at \\\\\\(1\\\\\\) is not a proper array section\" \"\" { target *-*-* } 65 }\n \n   !$omp target map(aas(:))\n   !$omp end target\n-  ! { dg-error \"Rightmost upper bound of assumed size array section not specified\" \"\" { target *-*-* } 68 }\n-  ! { dg-error \"'aas' in MAP clause at \\\\\\(1\\\\\\) is not a proper array section\" \"\" { target *-*-* } 68 }\n+  ! { dg-error \"Rightmost upper bound of assumed size array section not specified\" \"\" { target *-*-* } 70 }\n+  ! { dg-error \"'aas' in MAP clause at \\\\\\(1\\\\\\) is not a proper array section\" \"\" { target *-*-* } 70 }\n \n   !$omp target map(aas) ! { dg-error \"Assumed size array\" }\n   !$omp end target\n@@ -81,29 +83,28 @@ subroutine test(aas)\n \n   !$omp target map(k(5:))\n   !$omp end target\n-  ! { dg-error \"Rank mismatch in array reference\" \"\" { target *-*-* } 82 }\n-  ! { dg-error \"'k' in MAP clause at \\\\\\(1\\\\\\) is not a proper array section\" \"\" { target *-*-* } 82 }\n+  ! { dg-error \"Rank mismatch in array reference\" \"\" { target *-*-* } 84 }\n+  ! { dg-error \"'k' in MAP clause at \\\\\\(1\\\\\\) is not a proper array section\" \"\" { target *-*-* } 84 }\n \n   !$omp target map(k(5:,:,3))\n   !$omp end target\n-  ! { dg-error \"Rank mismatch in array reference\" \"\" { target *-*-* } 87 }\n-  ! { dg-error \"'k' in MAP clause at \\\\\\(1\\\\\\) is not a proper array section\" \"\" { target *-*-* } 87 }\n+  ! { dg-error \"Rank mismatch in array reference\" \"\" { target *-*-* } 89 }\n+  ! { dg-error \"'k' in MAP clause at \\\\\\(1\\\\\\) is not a proper array section\" \"\" { target *-*-* } 89 }\n \n   !$omp target map(tt)\n   !$omp end target\n \n-  !$omp target map(tt%i) ! { dg-error \"Syntax error in OpenMP variable list\" }\n+  !$omp target map(tt%k) ! { dg-error \"not a member of\" }\n   !$omp end target ! { dg-error \"Unexpected !\\\\\\$OMP END TARGET statement\" }\n \n-  !$omp target map(tt%j) ! { dg-error \"Syntax error in OpenMP variable list\" }\n-  !$omp end target ! { dg-error \"Unexpected !\\\\\\$OMP END TARGET statement\" }\n+  !$omp target map(tt%j)\n+  !$omp end target\n \n-  ! broken test\n-  !$omp target map(tt%j(1)) ! { dg-error \"Syntax error in OpenMP variable list\" }\n-  !$omp end target ! { dg-error \"Unexpected !\\\\\\$OMP END TARGET statement\" }\n+  !$omp target map(tt%j(1))\n+  !$omp end target\n \n-  !$omp target map(tt%j(1:)) ! { dg-error \"Syntax error in OpenMP variable list\" }\n-  !$omp end target ! { dg-error \"Unexpected !\\\\\\$OMP END TARGET statement\" }\n+  !$omp target map(tt%j(1:))\n+  !$omp end target\n \n   !$omp target map(tp) ! { dg-error \"THREADPRIVATE object 'tp' in MAP clause\" }\n   !$omp end target"}, {"sha": "73c4f5a87d0ea5ae45d1ca895a999f5579aaabd6", "filename": "gcc/testsuite/gfortran.dg/gomp/map-2.f90", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/102502e32ea4e8a75d6b252ba319d09d735d9aa7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fmap-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/102502e32ea4e8a75d6b252ba319d09d735d9aa7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fmap-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fmap-2.f90?ref=102502e32ea4e8a75d6b252ba319d09d735d9aa7", "patch": "@@ -0,0 +1,6 @@\n+type t\n+  integer :: i\n+end type t\n+type(t) v\n+!$omp target enter data map(to:v%i, v%i)  ! { dg-error \"appears more than once in map clauses\" }\n+end"}, {"sha": "f18eeb90165cdc84fdc7e68991aa77a5fe2e8905", "filename": "libgomp/testsuite/libgomp.fortran/struct-elem-map-1.f90", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/102502e32ea4e8a75d6b252ba319d09d735d9aa7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fstruct-elem-map-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/102502e32ea4e8a75d6b252ba319d09d735d9aa7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fstruct-elem-map-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fstruct-elem-map-1.f90?ref=102502e32ea4e8a75d6b252ba319d09d735d9aa7", "patch": "@@ -0,0 +1,331 @@\n+! { dg-do run }\n+!\n+! Test OpenMP 4.5 structure-element mapping\n+\n+! TODO: character(kind=4,...) needs to be tested, but depends on\n+!       PR fortran/95837\n+! TODO: ...%str4 should be tested but that currently fails due to\n+!       PR fortran/95868 (see commented lined)\n+! TODO: Test also array-valued var, nested derived types,\n+!       type-extended types.\n+\n+program main\n+  implicit none\n+\n+  type t2\n+    integer :: a, b\n+    ! For complex, assume small integers are exactly representable\n+    complex(kind=8) :: c\n+    integer :: d(10)\n+    integer, pointer :: e => null(), f(:) => null()\n+    character(len=5) :: str1\n+    character(len=5) :: str2(4)\n+    character(len=:), pointer :: str3 => null()\n+    character(len=:), pointer :: str4(:) => null()\n+  end type t2\n+\n+  integer :: i\n+\n+  call one ()\n+  call two ()\n+  call three ()\n+  call four ()\n+  call five ()\n+  call six ()\n+  call seven ()\n+  call eight ()\n+\n+contains\n+  ! Implicitly mapped \u2013 but no pointers are mapped\n+  subroutine one() \n+    type(t2) :: var, var2(4)\n+    type(t2), pointer :: var3, var4(:)\n+\n+    print '(g0)', '==== TESTCASE \"one\" ===='\n+\n+    var = t2(a = 1, &\n+             b = 2, c = cmplx(-1.0_8, 2.0_8,kind=8), &\n+             d = [(-3*i, i = 1, 10)], &\n+             str1 = \"abcde\", &\n+             str2 = [\"12345\", \"67890\", \"ABCDE\", \"FGHIJ\"])\n+    allocate (var%e, source=99)\n+    allocate (var%f, source=[22, 33, 44, 55])\n+    allocate (var%str3, source=\"HelloWorld\")\n+    allocate (var%str4, source=[\"Let's\", \"Go!!!\"])\n+\n+    !$omp target map(tofrom:var)\n+      if (var%a /= 1) stop 1\n+      if (var%b /= 2)  stop 2\n+      if (var%c%re /= -1.0_8 .or. var%c%im /= 2.0_8) stop 3\n+      if (any (var%d /= [(-3*i, i = 1, 10)])) stop 4\n+      if (var%str1 /= \"abcde\") stop 5\n+      if (any (var%str2 /= [\"12345\", \"67890\", \"ABCDE\", \"FGHIJ\"])) stop 6\n+    !$omp end target\n+\n+    deallocate(var%e, var%f, var%str3, var%str4)\n+  end subroutine one\n+\n+  ! Explicitly mapped \u2013 all and full arrays\n+  subroutine two() \n+    type(t2) :: var, var2(4)\n+    type(t2), pointer :: var3, var4(:)\n+\n+    print '(g0)', '==== TESTCASE \"two\" ===='\n+\n+    var = t2(a = 1, &\n+             b = 2, c = cmplx(-1.0_8, 2.0_8,kind=8), &\n+             d = [(-3*i, i = 1, 10)], &\n+             str1 = \"abcde\", &\n+             str2 = [\"12345\", \"67890\", \"ABCDE\", \"FGHIJ\"])\n+    allocate (var%e, source=99)\n+    allocate (var%f, source=[22, 33, 44, 55])\n+    allocate (var%str3, source=\"HelloWorld\")\n+    allocate (var%str4, source=[\"Let's\", \"Go!!!\"])\n+\n+    !$omp target map(tofrom: var%a, var%b, var%c, var%d, var%e, var%f, &\n+    !$omp&                   var%str1, var%str2, var%str3, var%str4)\n+      if (var%a /= 1) stop 1\n+      if (var%b /= 2)  stop 2\n+      if (var%c%re /= -1.0_8 .or. var%c%im /= 2.0_8) stop 3\n+      if (any (var%d /= [(-3*i, i = 1, 10)])) stop 4\n+      if (var%str1 /= \"abcde\") stop 5\n+      if (any (var%str2 /= [\"12345\", \"67890\", \"ABCDE\", \"FGHIJ\"])) stop 6\n+\n+      if (.not. associated (var%e)) stop 7\n+      if (var%e /= 99) stop 8\n+      if (.not. associated (var%f)) stop 9\n+      if (size (var%f) /= 4) stop 10\n+      if (any (var%f /= [22, 33, 44, 55])) stop 11\n+      if (.not. associated (var%str3)) stop 12\n+      if (len (var%str3) /= len (\"HelloWorld\")) stop 13\n+      if (var%str3 /= \"HelloWorld\") stop 14\n+      if (.not. associated (var%str4)) stop 15\n+      if (len (var%str4) /= 5) stop 16\n+      if (size (var%str4) /= 2) stop 17\n+      if (any (var%str4 /= [\"Let's\", \"Go!!!\"])) stop 18\n+    !$omp end target\n+\n+    deallocate(var%e, var%f, var%str3, var%str4)\n+  end subroutine two\n+\n+  ! Explicitly mapped \u2013 one by one but full arrays\n+  subroutine three() \n+    type(t2) :: var, var2(4)\n+    type(t2), pointer :: var3, var4(:)\n+\n+    print '(g0)', '==== TESTCASE \"three\" ===='\n+\n+    var = t2(a = 1, &\n+             b = 2, c = cmplx(-1.0_8, 2.0_8,kind=8), &\n+             d = [(-3*i, i = 1, 10)], &\n+             str1 = \"abcde\", &\n+             str2 = [\"12345\", \"67890\", \"ABCDE\", \"FGHIJ\"])\n+    allocate (var%e, source=99)\n+    allocate (var%f, source=[22, 33, 44, 55])\n+    allocate (var%str3, source=\"HelloWorld\")\n+    allocate (var%str4, source=[\"Let's\", \"Go!!!\"])\n+\n+    !$omp target map(tofrom: var%a)\n+      if (var%a /= 1) stop 1\n+    !$omp end target\n+    !$omp target map(tofrom: var%b)\n+      if (var%b /= 2)  stop 2\n+    !$omp end target\n+    !$omp target map(tofrom: var%c)\n+      if (var%c%re /= -1.0_8 .or. var%c%im /= 2.0_8) stop 3\n+    !$omp end target\n+    !$omp target map(tofrom: var%d)\n+      if (any (var%d /= [(-3*i, i = 1, 10)])) stop 4\n+    !$omp end target\n+    !$omp target map(tofrom: var%str1)\n+      if (var%str1 /= \"abcde\") stop 5\n+    !$omp end target\n+    !$omp target map(tofrom: var%str2)\n+      if (any (var%str2 /= [\"12345\", \"67890\", \"ABCDE\", \"FGHIJ\"])) stop 6\n+    !$omp end target\n+\n+    !$omp target map(tofrom: var%e)\n+      if (.not. associated (var%e)) stop 7\n+      if (var%e /= 99) stop 8\n+    !$omp end target\n+    !$omp target map(tofrom: var%f)\n+      if (.not. associated (var%f)) stop 9\n+      if (size (var%f) /= 4) stop 10\n+      if (any (var%f /= [22, 33, 44, 55])) stop 11\n+    !$omp end target\n+    !$omp target map(tofrom: var%str3)\n+      if (.not. associated (var%str3)) stop 12\n+      if (len (var%str3) /= len (\"HelloWorld\")) stop 13\n+      if (var%str3 /= \"HelloWorld\") stop 14\n+    !$omp end target\n+    !$omp target map(tofrom: var%str4)\n+      if (.not. associated (var%str4)) stop 15\n+      if (len (var%str4) /= 5) stop 16\n+      if (size (var%str4) /= 2) stop 17\n+      if (any (var%str4 /= [\"Let's\", \"Go!!!\"])) stop 18\n+    !$omp end target\n+\n+    deallocate(var%e, var%f, var%str3, var%str4)\n+  end subroutine three\n+\n+  ! Explicitly mapped \u2013 all but only subarrays\n+  subroutine four() \n+    type(t2) :: var, var2(4)\n+    type(t2), pointer :: var3, var4(:)\n+\n+    print '(g0)', '==== TESTCASE \"four\" ===='\n+\n+    var = t2(a = 1, &\n+             b = 2, c = cmplx(-1.0_8, 2.0_8,kind=8), &\n+             d = [(-3*i, i = 1, 10)], &\n+             str1 = \"abcde\", &\n+             str2 = [\"12345\", \"67890\", \"ABCDE\", \"FGHIJ\"])\n+    allocate (var%f, source=[22, 33, 44, 55])\n+    allocate (var%str4, source=[\"Let's\", \"Go!!!\"])\n+\n+!   !$omp target map(tofrom: var%d(4:7), var%f(2:3), var%str2(2:3), var%str4(2:2))\n+    !$omp target map(tofrom: var%d(4:7), var%f(2:3), var%str2(2:3))\n+      if (any (var%d(4:7) /= [(-3*i, i = 4, 7)])) stop 4\n+      if (any (var%str2(2:3) /= [\"67890\", \"ABCDE\"])) stop 6\n+\n+      if (.not. associated (var%f)) stop 9\n+      if (size (var%f) /= 4) stop 10\n+      if (any (var%f(2:3) /= [33, 44])) stop 11\n+!     if (.not. associated (var%str4)) stop 15\n+!     if (len (var%str4) /= 5) stop 16\n+!     if (size (var%str4) /= 2) stop 17\n+!     if (var%str4(2) /= \"Go!!!\") stop 18\n+    !$omp end target\n+\n+    deallocate(var%f, var%str4)\n+  end subroutine four\n+\n+  ! Explicitly mapped \u2013 all but only subarrays and one by one\n+  subroutine five() \n+    type(t2) :: var, var2(4)\n+    type(t2), pointer :: var3, var4(:)\n+\n+    print '(g0)', '==== TESTCASE \"five\" ===='\n+\n+    var = t2(a = 1, &\n+             b = 2, c = cmplx(-1.0_8, 2.0_8,kind=8), &\n+             d = [(-3*i, i = 1, 10)], &\n+             str1 = \"abcde\", &\n+             str2 = [\"12345\", \"67890\", \"ABCDE\", \"FGHIJ\"])\n+    allocate (var%f, source=[22, 33, 44, 55])\n+    allocate (var%str4, source=[\"Let's\", \"Go!!!\"])\n+\n+    !$omp target map(tofrom: var%d(4:7))\n+      if (any (var%d(4:7) /= [(-3*i, i = 4, 7)])) stop 4\n+    !$omp end target\n+    !$omp target map(tofrom: var%str2(2:3))\n+      if (any (var%str2(2:3) /= [\"67890\", \"ABCDE\"])) stop 6\n+    !$omp end target\n+\n+    !$omp target map(tofrom: var%f(2:3))\n+     if (.not. associated (var%f)) stop 9\n+     if (size (var%f) /= 4) stop 10\n+     if (any (var%f(2:3) /= [33, 44])) stop 11\n+    !$omp end target\n+!  !$omp target map(tofrom: var%str4(2:2))\n+!     if (.not. associated (var%str4)) stop 15\n+!     if (len (var%str4) /= 5) stop 16\n+!     if (size (var%str4) /= 2) stop 17\n+!     if (var%str4(2) /= \"Go!!!\") stop 18\n+!  !$omp end target\n+\n+    deallocate(var%f, var%str4)\n+  end subroutine five\n+\n+  ! Explicitly mapped \u2013 all but only array elements\n+  subroutine six() \n+    type(t2) :: var, var2(4)\n+    type(t2), pointer :: var3, var4(:)\n+\n+    print '(g0)', '==== TESTCASE \"six\" ===='\n+\n+    var = t2(a = 1, &\n+             b = 2, c = cmplx(-1.0_8, 2.0_8,kind=8), &\n+             d = [(-3*i, i = 1, 10)], &\n+             str1 = \"abcde\", &\n+             str2 = [\"12345\", \"67890\", \"ABCDE\", \"FGHIJ\"])\n+    allocate (var%f, source=[22, 33, 44, 55])\n+    allocate (var%str4, source=[\"Let's\", \"Go!!!\"])\n+\n+!   !$omp target map(tofrom: var%d(5), var%f(3), var%str2(3), var%str4(2))\n+    !$omp target map(tofrom: var%d(5), var%f(3), var%str2(3))\n+      if (var%d(5) /= -3*5) stop 4\n+      if (var%str2(3) /= \"ABCDE\") stop 6\n+\n+     if (.not. associated (var%f)) stop 9\n+     if (size (var%f) /= 4) stop 10\n+     if (var%f(3) /= 44) stop 11\n+!     if (.not. associated (var%str4)) stop 15\n+!     if (len (var%str4) /= 5) stop 16\n+!     if (size (var%str4) /= 2) stop 17\n+!     if (var%str4(2) /= \"Go!!!\") stop 18\n+    !$omp end target\n+\n+    deallocate(var%f, var%str4)\n+  end subroutine six\n+\n+  ! Explicitly mapped \u2013 all but only array elements and one by one\n+  subroutine seven() \n+    type(t2) :: var, var2(4)\n+    type(t2), pointer :: var3, var4(:)\n+\n+    print '(g0)', '==== TESTCASE \"seven\" ===='\n+\n+    var = t2(a = 1, &\n+             b = 2, c = cmplx(-1.0_8, 2.0_8,kind=8), &\n+             d = [(-3*i, i = 1, 10)], &\n+             str1 = \"abcde\", &\n+             str2 = [\"12345\", \"67890\", \"ABCDE\", \"FGHIJ\"])\n+    allocate (var%f, source=[22, 33, 44, 55])\n+    allocate (var%str4, source=[\"Let's\", \"Go!!!\"])\n+\n+    !$omp target map(tofrom: var%d(5))\n+      if (var%d(5) /= (-3*5)) stop 4\n+    !$omp end target\n+    !$omp target map(tofrom: var%str2(2:3))\n+      if (any (var%str2(2:3) /= [\"67890\", \"ABCDE\"])) stop 6\n+    !$omp end target\n+\n+    !$omp target map(tofrom: var%f(2:3))\n+     if (.not. associated (var%f)) stop 9\n+     if (size (var%f) /= 4) stop 10\n+     if (any (var%f(2:3) /= [33, 44])) stop 11\n+    !$omp end target\n+!   !$omp target map(tofrom: var%str4(2:2))\n+!     if (.not. associated (var%str4)) stop 15\n+!     if (len (var%str4) /= 5) stop 16\n+!     if (size (var%str4) /= 2) stop 17\n+!     if (var%str4(2) /= \"Go!!!\") stop 18\n+!   !$omp end target\n+\n+    deallocate(var%f, var%str4)\n+  end subroutine seven\n+\n+  ! Check mapping of NULL pointers\n+  subroutine eight() \n+    type(t2) :: var, var2(4)\n+    type(t2), pointer :: var3, var4(:)\n+\n+    print '(g0)', '==== TESTCASE \"eight\" ===='\n+\n+    var = t2(a = 1, &\n+             b = 2, c = cmplx(-1.0_8, 2.0_8,kind=8), &\n+             d = [(-3*i, i = 1, 10)], &\n+             str1 = \"abcde\", &\n+             str2 = [\"12345\", \"67890\", \"ABCDE\", \"FGHIJ\"])\n+\n+!    !$omp target map(tofrom: var%e, var%f, var%str3, var%str4)\n+    !$omp target map(tofrom: var%e, var%str3)\n+      if (associated (var%e)) stop 1\n+!      if (associated (var%f)) stop 2\n+      if (associated (var%str3)) stop 3\n+!      if (associated (var%str4)) stop 4\n+    !$omp end target\n+  end subroutine eight\n+\n+end program main"}]}