{"sha": "86d9e8d8649eed63bb456092fba7bcb5d38664bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZkOWU4ZDg2NDllZWQ2M2JiNDU2MDkyZmJhN2JjYjVkMzg2NjRiYg==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@waitaki.otago.ac.nz", "date": "2001-05-31T06:05:29Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-05-31T06:05:29Z"}, "message": "parse.y (do_resolve_class): Check for cyclic inheritance during inner class resolution.\n\n2001-04-27  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n\n\t* parse.y (do_resolve_class): Check for cyclic inheritance during\n\tinner class resolution.\n\n(http://gcc.gnu.org/ml/gcc-patches/2001-04/msg01330.html)\n\nFrom-SVN: r42737", "tree": {"sha": "12fb4498d39e76f2172cd224ddf4b790d45dc6f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12fb4498d39e76f2172cd224ddf4b790d45dc6f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86d9e8d8649eed63bb456092fba7bcb5d38664bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86d9e8d8649eed63bb456092fba7bcb5d38664bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86d9e8d8649eed63bb456092fba7bcb5d38664bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86d9e8d8649eed63bb456092fba7bcb5d38664bb/comments", "author": null, "committer": null, "parents": [{"sha": "9fd51e6700a8ba4db53969fffa773b22a49c1843", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fd51e6700a8ba4db53969fffa773b22a49c1843", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fd51e6700a8ba4db53969fffa773b22a49c1843"}], "stats": {"total": 32, "additions": 26, "deletions": 6}, "files": [{"sha": "95b7445e5d2b0e70d636ec0b47ca7e52fe02f8b4", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d9e8d8649eed63bb456092fba7bcb5d38664bb/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d9e8d8649eed63bb456092fba7bcb5d38664bb/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=86d9e8d8649eed63bb456092fba7bcb5d38664bb", "patch": "@@ -100,6 +100,11 @@\n \n \t* verify.c (verify_jvm_instructions): Initialize variable.\n \n+2001-04-27  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\t* parse.y (do_resolve_class): Check for cyclic inheritance during\n+\tinner class resolution. \n+\n 2001-04-27  Per Bothner  <per@bothner.com>\n \n \t* parse.y (java_expand_classes):  Don't change ctxp_for_generation"}, {"sha": "2b0038b69618c93ec05b4ce56224cd274f0b3054", "filename": "gcc/java/parse.y", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d9e8d8649eed63bb456092fba7bcb5d38664bb/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d9e8d8649eed63bb456092fba7bcb5d38664bb/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=86d9e8d8649eed63bb456092fba7bcb5d38664bb", "patch": "@@ -5522,13 +5522,14 @@ tree\n do_resolve_class (enclosing, class_type, decl, cl)\n      tree enclosing, class_type, decl, cl;\n {\n-  tree new_class_decl;\n+  tree new_class_decl, super, start;\n \n   /* Do not try to replace TYPE_NAME (class_type) by a variable, since\n      it is changed by find_in_imports{_on_demand} and (but it doesn't\n      really matter) qualify_and_find */\n \n   /* 0- Search in the current class as an inner class */\n+  start = enclosing;\n \n   /* Maybe some code here should be added to load the class or\n      something, at least if the class isn't an inner class and ended\n@@ -5551,14 +5552,28 @@ do_resolve_class (enclosing, class_type, decl, cl)\n \t}\n \n       /* Now go to the upper classes, bail out if necessary. */\n-      enclosing = CLASSTYPE_SUPER (TREE_TYPE (enclosing));\n-      if (!enclosing || enclosing == object_type_node)\n+      super = CLASSTYPE_SUPER (TREE_TYPE (enclosing));\n+      if (!super || super == object_type_node)\n         break;\n \n-      if (TREE_CODE (enclosing) == POINTER_TYPE)\n-\tenclosing = do_resolve_class (NULL, enclosing, NULL, NULL);\n+      if (TREE_CODE (super) == POINTER_TYPE)\n+        super = do_resolve_class (NULL, super, NULL, NULL);\n       else\n-        enclosing = TYPE_NAME (enclosing);\n+\tsuper = TYPE_NAME (super);\n+ \n+      /* We may not have checked for circular inheritance yet, so do so\n+         here to prevent an infinite loop. */\n+      if (super == start)\n+        {\n+          if (!cl)\n+            cl = lookup_cl (decl);\n+\t  \n+          parse_error_context\n+            (cl, \"Cyclic inheritance involving %s\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (enclosing)));\n+          break;\n+        }\n+      enclosing = super;\n     }\n \n   /* 1- Check for the type in single imports. This will change"}]}