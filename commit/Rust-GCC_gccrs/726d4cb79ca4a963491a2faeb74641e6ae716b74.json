{"sha": "726d4cb79ca4a963491a2faeb74641e6ae716b74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI2ZDRjYjc5Y2E0YTk2MzQ5MWEyZmFlYjc0NjQxZTZhZTcxNmI3NA==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2004-05-10T23:25:13Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2004-05-10T23:25:13Z"}, "message": "re PR target/15130 ([3.3/3.4][sh4-linux] miscompilation with -O2)\n\n\tPR target/15130\n\t* config/sh/sh-protos.h (sh_expand_epilogue): Change prototype.\n\t* config/sh/sh.c (output_stack_adjust): Take the sibcall epilogue\n\tinto account.  Compute the correct number of general registers\n\tfor the return value.  Generate a special push/pop sequence when\n\tfailing to get a temporary register for non SHmedia epilogue.\n\t(sh_expand_epilogue): Add an argument to show whether it's for\n\tsibcall or not.  Set the 3rd argument of output_stack_adjust to\n\t-1 if needed.\n\t(sh_need_epilogue): Call sh_expand_epilogue with 0.\n\t* config/sh/sh.md (sibcall_epilogue): Call sh_expand_epilogue\n\twith 1.\n\t(epilogue): Call sh_expand_epilogue with 0.\n\nFrom-SVN: r81683", "tree": {"sha": "aeb2d5e436b16aa338bd7429b2513cc5e20811c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aeb2d5e436b16aa338bd7429b2513cc5e20811c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/726d4cb79ca4a963491a2faeb74641e6ae716b74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/726d4cb79ca4a963491a2faeb74641e6ae716b74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/726d4cb79ca4a963491a2faeb74641e6ae716b74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/726d4cb79ca4a963491a2faeb74641e6ae716b74/comments", "author": null, "committer": null, "parents": [{"sha": "0c196bf9d84c1d3b638bb4cd5f9e088b861afa08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c196bf9d84c1d3b638bb4cd5f9e088b861afa08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c196bf9d84c1d3b638bb4cd5f9e088b861afa08"}], "stats": {"total": 111, "additions": 95, "deletions": 16}, "files": [{"sha": "c8a73c22fffa7faa460612de0ecbf0d4e30a5b6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726d4cb79ca4a963491a2faeb74641e6ae716b74/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726d4cb79ca4a963491a2faeb74641e6ae716b74/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=726d4cb79ca4a963491a2faeb74641e6ae716b74", "patch": "@@ -1,3 +1,19 @@\n+2004-05-10  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\tPR target/15130\n+\t* config/sh/sh-protos.h (sh_expand_epilogue): Change prototype.\n+\t* config/sh/sh.c (output_stack_adjust): Take the sibcall epilogue\n+\tinto account.  Compute the correct number of general registers\n+\tfor the return value.  Generate a special push/pop sequence when\n+\tfailing to get a temporary register for non SHmedia epilogue.\n+\t(sh_expand_epilogue): Add an argument to show whether it's for\n+\tsibcall or not.  Set the 3rd argument of output_stack_adjust to\n+\t-1 if needed.\n+\t(sh_need_epilogue): Call sh_expand_epilogue with 0.\n+\t* config/sh/sh.md (sibcall_epilogue): Call sh_expand_epilogue\n+\twith 1.\n+\t(epilogue): Call sh_expand_epilogue with 0.\n+\n 2004-05-10  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* gcse.c (eliminate_partially_redundant_loads): Instead of returning early,"}, {"sha": "7abdac48922146b769dd14ca33cd81660b17cfb1", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726d4cb79ca4a963491a2faeb74641e6ae716b74/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726d4cb79ca4a963491a2faeb74641e6ae716b74/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=726d4cb79ca4a963491a2faeb74641e6ae716b74", "patch": "@@ -109,7 +109,7 @@ extern int sh_handle_pragma (int (*)(void), void (*)(int), const char *);\n extern struct rtx_def *get_fpscr_rtx (void);\n extern int sh_media_register_for_return (void);\n extern void sh_expand_prologue (void);\n-extern void sh_expand_epilogue (void);\n+extern void sh_expand_epilogue (bool);\n extern int sh_need_epilogue (void);\n extern void sh_set_return_address (rtx, rtx);\n extern int initial_elimination_offset (int, int);"}, {"sha": "5b44f1be03cfe184d880db5c720927b9031a0d0d", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 76, "deletions": 13, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726d4cb79ca4a963491a2faeb74641e6ae716b74/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726d4cb79ca4a963491a2faeb74641e6ae716b74/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=726d4cb79ca4a963491a2faeb74641e6ae716b74", "patch": "@@ -4630,8 +4630,9 @@ static int extra_push;\n \n /* Adjust the stack by SIZE bytes.  REG holds the rtl of the register to be\n    adjusted.  If epilogue_p is zero, this is for a prologue; otherwise, it's\n-   for an epilogue.  If LIVE_REGS_MASK is nonzero, it points to a HARD_REG_SET\n-   of all the registers that are about to be restored, and hence dead.  */\n+   for an epilogue and a negative value means that it's for a sibcall\n+   epilogue.  If LIVE_REGS_MASK is nonzero, it points to a HARD_REG_SET of\n+   all the registers that are about to be restored, and hence dead.  */\n \n static void\n output_stack_adjust (int size, rtx reg, int epilogue_p,\n@@ -4666,17 +4667,27 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n \t  /* If TEMP is invalid, we could temporarily save a general\n \t     register to MACL.  However, there is currently no need\n \t     to handle this case, so just abort when we see it.  */\n-\t  if (current_function_interrupt\n+\t  if (epilogue_p < 0\n+\t      || current_function_interrupt\n \t      || ! call_used_regs[temp] || fixed_regs[temp])\n \t    temp = -1;\n-\t  if (temp < 0 && ! current_function_interrupt)\n+\t  if (temp < 0 && ! current_function_interrupt\n+\t      && (TARGET_SHMEDIA || epilogue_p >= 0))\n \t    {\n \t      HARD_REG_SET temps;\n \t      COPY_HARD_REG_SET (temps, call_used_reg_set);\n \t      AND_COMPL_HARD_REG_SET (temps, call_fixed_reg_set);\n-\t      if (epilogue_p)\n+\t      if (epilogue_p > 0)\n \t\t{\n-\t\t  for (i = 0; i < HARD_REGNO_NREGS (FIRST_RET_REG, DImode); i++)\n+\t\t  int nreg = 0;\n+\t\t  if (current_function_return_rtx)\n+\t\t    {\n+\t\t      enum machine_mode mode;\n+\t\t      mode = GET_MODE (current_function_return_rtx);\n+\t\t      if (BASE_RETURN_VALUE_REG (mode) == FIRST_RET_REG)\n+\t\t\tnreg = HARD_REGNO_NREGS (FIRST_RET_REG, mode);\n+\t\t    }\n+\t\t  for (i = 0; i < nreg; i++)\n \t\t    CLEAR_HARD_REG_BIT (temps, FIRST_RET_REG + i);\n \t\t  if (current_function_calls_eh_return)\n \t\t    {\n@@ -4685,7 +4696,10 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n \t\t\tCLEAR_HARD_REG_BIT (temps, EH_RETURN_DATA_REGNO (i));\n \t\t    }\n \t\t}\n-\t      else\n+\t      if (TARGET_SHMEDIA && epilogue_p < 0)\n+\t\tfor (i = FIRST_TARGET_REG; i <= LAST_TARGET_REG; i++)\n+\t\t  CLEAR_HARD_REG_BIT (temps, i);\n+\t      if (epilogue_p <= 0)\n \t\t{\n \t\t  for (i = FIRST_PARM_REG;\n \t\t       i < FIRST_PARM_REG + NPARM_REGS (SImode); i++)\n@@ -4698,7 +4712,55 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n \t  if (temp < 0 && live_regs_mask)\n \t    temp = scavenge_reg (live_regs_mask);\n \t  if (temp < 0)\n-\t    abort ();\n+\t    {\n+\t      /* If we reached here, the most likely case is the (sibcall)\n+\t\t epilogue for non SHmedia.  Put a special push/pop sequence\n+\t\t for such case as the last resort.  This looks lengthy but\n+\t\t would not be problem because it seems to be very rare.  */\n+\t      if (! TARGET_SHMEDIA && epilogue_p)\n+\t\t{\n+\t\t  rtx adj_reg, tmp_reg, mem;\n+\n+\t\t  /* ??? There is still the slight possibility that r4 or r5\n+\t\t     have been reserved as fixed registers or assigned as\n+\t\t     global registers, and they change during an interrupt.\n+\t\t     There are possible ways to handle this:\n+\t\t     - If we are adjusting the frame pointer (r14), we can do\n+\t\t       with a single temp register and an ordinary push / pop\n+\t\t       on the stack.\n+\t\t     - Grab any call-used or call-saved registers (i.e. not\n+\t\t       fixed or globals) for the temps we need.  We might\n+\t\t       also grab r14 if we are adjusting the stack pointer.\n+\t\t       If we can't find enough available registers, issue\n+\t\t       a diagnostic and abort - the user must have reserved\n+\t\t       way too many registers.\n+\t\t     But since all this is rather unlikely to happen and\n+\t\t     would require extra testing, we just abort if r4 / r5\n+\t\t     are not available.  */\n+\t\t  if (fixed_regs[4] || fixed_regs[5]\n+\t\t      || global_regs[4] || global_regs[5])\n+\t\t    abort ();\n+\n+\t\t  adj_reg = gen_rtx_REG (GET_MODE (reg), 4);\n+\t\t  tmp_reg = gen_rtx_REG (GET_MODE (reg), 5);\n+\t\t  emit_move_insn (gen_rtx_MEM (Pmode, reg), adj_reg);\n+\t\t  emit_insn (GEN_MOV (adj_reg, GEN_INT (size)));\n+\t\t  emit_insn (GEN_ADD3 (adj_reg, adj_reg, reg));\n+\t\t  mem = gen_rtx_MEM (Pmode, gen_rtx_PRE_DEC (Pmode, adj_reg));\n+\t\t  emit_move_insn (mem, tmp_reg);\n+\t\t  emit_move_insn (tmp_reg, gen_rtx_MEM (Pmode, reg));\n+\t\t  mem = gen_rtx_MEM (Pmode, gen_rtx_PRE_DEC (Pmode, adj_reg));\n+\t\t  emit_move_insn (mem, tmp_reg);\n+\t\t  emit_move_insn (reg, adj_reg);\n+\t\t  mem = gen_rtx_MEM (Pmode, gen_rtx_POST_INC (Pmode, reg));\n+\t\t  emit_move_insn (adj_reg, mem);\n+\t\t  mem = gen_rtx_MEM (Pmode, gen_rtx_POST_INC (Pmode, reg));\n+\t\t  emit_move_insn (tmp_reg, mem);\n+\t\t  return;\n+\t\t}\n+\t      else\n+\t\tabort ();\n+\t    }\n \t  const_reg = gen_rtx_REG (GET_MODE (reg), temp);\n \n \t  /* If SIZE is negative, subtract the positive value.\n@@ -5538,7 +5600,7 @@ sh_expand_prologue (void)\n }\n \n void\n-sh_expand_epilogue (void)\n+sh_expand_epilogue (bool sibcall_p)\n {\n   HARD_REG_SET live_regs_mask;\n   int d, i;\n@@ -5547,6 +5609,7 @@ sh_expand_epilogue (void)\n   int save_flags = target_flags;\n   int frame_size, save_size;\n   int fpscr_deferred = 0;\n+  int e = sibcall_p ? -1 : 1;\n \n   d = calc_live_regs (&live_regs_mask);\n \n@@ -5581,7 +5644,7 @@ sh_expand_epilogue (void)\n \n   if (frame_pointer_needed)\n     {\n-      output_stack_adjust (frame_size, frame_pointer_rtx, 1, &live_regs_mask);\n+      output_stack_adjust (frame_size, frame_pointer_rtx, e, &live_regs_mask);\n \n       /* We must avoid moving the stack pointer adjustment past code\n \t which reads from the local frame, else an interrupt could\n@@ -5597,7 +5660,7 @@ sh_expand_epilogue (void)\n \t occur after the SP adjustment and clobber data in the local\n \t frame.  */\n       emit_insn (gen_blockage ());\n-      output_stack_adjust (frame_size, stack_pointer_rtx, 1, &live_regs_mask);\n+      output_stack_adjust (frame_size, stack_pointer_rtx, e, &live_regs_mask);\n     }\n \n   if (SHMEDIA_REGS_STACK_ADJUST ())\n@@ -5770,7 +5833,7 @@ sh_expand_epilogue (void)\n   output_stack_adjust (extra_push + current_function_pretend_args_size\n \t\t       + save_size + d_rounding\n \t\t       + current_function_args_info.stack_regs * 8,\n-\t\t       stack_pointer_rtx, 1, NULL);\n+\t\t       stack_pointer_rtx, e, NULL);\n \n   if (current_function_calls_eh_return)\n     emit_insn (GEN_ADD3 (stack_pointer_rtx, stack_pointer_rtx,\n@@ -5798,7 +5861,7 @@ sh_need_epilogue (void)\n       rtx epilogue;\n \n       start_sequence ();\n-      sh_expand_epilogue ();\n+      sh_expand_epilogue (0);\n       epilogue = get_insns ();\n       end_sequence ();\n       sh_need_epilogue_known = (epilogue == NULL ? -1 : 1);"}, {"sha": "d3b4c9466ed3e141e27654069f50b66042350510", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726d4cb79ca4a963491a2faeb74641e6ae716b74/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726d4cb79ca4a963491a2faeb74641e6ae716b74/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=726d4cb79ca4a963491a2faeb74641e6ae716b74", "patch": "@@ -6467,7 +6467,7 @@\n   \"\"\n   \"\n {\n-  sh_expand_epilogue ();\n+  sh_expand_epilogue (1);\n   if (TARGET_SHCOMPACT)\n     {\n       rtx insn, set;\n@@ -7348,7 +7348,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   \"\"\n   \"\n {\n-  sh_expand_epilogue ();\n+  sh_expand_epilogue (0);\n   emit_jump_insn (gen_return ());\n   DONE;\n }\")"}]}