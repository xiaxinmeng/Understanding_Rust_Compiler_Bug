{"sha": "2941cc061a7a0cafdfa0aec2be9387c92b590625", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk0MWNjMDYxYTdhMGNhZmRmYTBhZWMyYmU5Mzg3YzkyYjU5MDYyNQ==", "commit": {"author": {"name": "Jeroen Frijters", "email": "jeroen@frijters.net", "date": "2004-02-06T13:27:36Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-02-06T13:27:36Z"}, "message": "ObjectInputStream.java: Made all calls to dumpElement[ln] conditional on dump flag.\n\n2004-02-06  Jeroen Frijters  <jeroen@frijters.net>\n\n\t* java/io/ObjectInputStream.java: Made all calls\n\tto dumpElement[ln] conditional on dump flag. (readObject): Changed to\n\tuse cached info from ObjectStreamClass. (readClassDescriptor):\n\tCache more information in ObjectStreamClass. (processResolution,\n\treadFields): Use cached info from ObjectStreamClass.\n\t(newObject): Throw exception instead of returning null for failure.\n\t(getField, getMethod, callReadMethod, setBooleanField, setByteField,\n\tsetCharField, setDoubleField, setFloatField, setIntField,\n\tsetLongField, setShortField, setObjectField, readObjectParams):\n\tRemoved. (dumpElement, dumpElementln): Removed dump flag condition\n\tcheck.\n\t* java/io/ObjectStreamField.java (hasReadMethod): Removed.\n\t(setClass): Added call to cacheMethods() (findMethod): New method.\n\t(cacheMethods): New method. (ObjectStreamClass): Added call to\n\tcacheMethods(). (setFields): Cache fields. (getClassUID): Use\n\tAccessController.doPrivileged to invoke setAccessible.\n\t(readObjectMethod, readResolveMethod, realClassIsSerializable,\n\trealClassIsExternalizable, fieldMapping, firstNonSerializableParent):\n\tNew fields.\n\t* java/io/ObjectStreamField.java (ObjectStreamField): New constructor.\n\t(ObjectStreamField): Removed FIXME workaround. (getTypeString,\n\tisPrimitive): Made safe for cases where type == null.\n\t(setBooleanField, setByteField, setCharField, setShortField,\n\tsetIntField, setLongField, setFloatField, setDoubleField,\n\tsetObjectField): New methods.\n\nFrom-SVN: r77395", "tree": {"sha": "fb6663e4a39d87f86d5337e6215ad1769df33c95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb6663e4a39d87f86d5337e6215ad1769df33c95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2941cc061a7a0cafdfa0aec2be9387c92b590625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2941cc061a7a0cafdfa0aec2be9387c92b590625", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2941cc061a7a0cafdfa0aec2be9387c92b590625", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2941cc061a7a0cafdfa0aec2be9387c92b590625/comments", "author": {"login": "jfrijters", "id": 2994393, "node_id": "MDQ6VXNlcjI5OTQzOTM=", "avatar_url": "https://avatars.githubusercontent.com/u/2994393?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jfrijters", "html_url": "https://github.com/jfrijters", "followers_url": "https://api.github.com/users/jfrijters/followers", "following_url": "https://api.github.com/users/jfrijters/following{/other_user}", "gists_url": "https://api.github.com/users/jfrijters/gists{/gist_id}", "starred_url": "https://api.github.com/users/jfrijters/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jfrijters/subscriptions", "organizations_url": "https://api.github.com/users/jfrijters/orgs", "repos_url": "https://api.github.com/users/jfrijters/repos", "events_url": "https://api.github.com/users/jfrijters/events{/privacy}", "received_events_url": "https://api.github.com/users/jfrijters/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eb457a7a0791d32d9b0df5ff8425abe59a9bee75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb457a7a0791d32d9b0df5ff8425abe59a9bee75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb457a7a0791d32d9b0df5ff8425abe59a9bee75"}], "stats": {"total": 1081, "additions": 486, "deletions": 595}, "files": [{"sha": "204cd71641308129e3955ec16593c368ed51fdcb", "filename": "libjava/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2941cc061a7a0cafdfa0aec2be9387c92b590625/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2941cc061a7a0cafdfa0aec2be9387c92b590625/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=2941cc061a7a0cafdfa0aec2be9387c92b590625", "patch": "@@ -1,3 +1,31 @@\n+2004-02-06  Jeroen Frijters  <jeroen@frijters.net>\n+\n+\t* java/io/ObjectInputStream.java: Made all calls\n+\tto dumpElement[ln] conditional on dump flag. (readObject): Changed to\n+\tuse cached info from ObjectStreamClass. (readClassDescriptor):\n+\tCache more information in ObjectStreamClass. (processResolution,\n+\treadFields): Use cached info from ObjectStreamClass.\n+\t(newObject): Throw exception instead of returning null for failure.\n+\t(getField, getMethod, callReadMethod, setBooleanField, setByteField,\n+\tsetCharField, setDoubleField, setFloatField, setIntField,\n+\tsetLongField, setShortField, setObjectField, readObjectParams):\n+\tRemoved. (dumpElement, dumpElementln): Removed dump flag condition\n+\tcheck.\n+\t* java/io/ObjectStreamField.java (hasReadMethod): Removed.\n+\t(setClass): Added call to cacheMethods() (findMethod): New method.\n+\t(cacheMethods): New method. (ObjectStreamClass): Added call to\n+\tcacheMethods(). (setFields): Cache fields. (getClassUID): Use\n+\tAccessController.doPrivileged to invoke setAccessible.\n+\t(readObjectMethod, readResolveMethod, realClassIsSerializable,\n+\trealClassIsExternalizable, fieldMapping, firstNonSerializableParent):\n+\tNew fields.\n+\t* java/io/ObjectStreamField.java (ObjectStreamField): New constructor.\n+\t(ObjectStreamField): Removed FIXME workaround. (getTypeString,\n+\tisPrimitive): Made safe for cases where type == null.\n+\t(setBooleanField, setByteField, setCharField, setShortField,\n+\tsetIntField, setLongField, setFloatField, setDoubleField,\n+\tsetObjectField): New methods.\n+\n 2004-02-05  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n \t* java/awt/Component.java (getFont): Return a default font"}, {"sha": "d0def09181c98cef9bb875fa6e6ede8afadbdb5e", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 246, "deletions": 561, "changes": 807, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2941cc061a7a0cafdfa0aec2be9387c92b590625/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2941cc061a7a0cafdfa0aec2be9387c92b590625/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=2941cc061a7a0cafdfa0aec2be9387c92b590625", "patch": "@@ -138,7 +138,7 @@ public final Object readObject() throws ClassNotFoundException, IOException\n     this.isDeserializing = true;\n \n     byte marker = this.realInputStream.readByte();\n-    dumpElement(\"MARKER: 0x\" + Integer.toHexString(marker) + \" \");\n+    if(dump) dumpElement(\"MARKER: 0x\" + Integer.toHexString(marker) + \" \");\n \n     try\n       {\n@@ -155,33 +155,33 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \t  case TC_BLOCKDATALONG:\n \t    {\n \t      if (marker == TC_BLOCKDATALONG)\n-\t\tdumpElementln(\"BLOCKDATALONG\");\n+\t\tif(dump) dumpElementln(\"BLOCKDATALONG\");\n \t      else\n-\t\tdumpElementln(\"BLOCKDATA\");\n+\t\tif(dump) dumpElementln(\"BLOCKDATA\");\n \t      readNextBlock(marker);\n \t      throw new StreamCorruptedException(\"Unexpected blockData\");\n \t    }\n \n \t  case TC_NULL:\n \t    {\n-\t      dumpElementln(\"NULL\");\n+\t      if(dump) dumpElementln(\"NULL\");\n \t      ret_val = null;\n \t      break;\n \t    }\n \n \t  case TC_REFERENCE:\n \t    {\n-\t      dumpElement(\"REFERENCE \");\n+\t      if(dump) dumpElement(\"REFERENCE \");\n \t      Integer oid = new Integer(this.realInputStream.readInt());\n-\t      dumpElementln(Integer.toHexString(oid.intValue()));\n+\t      if(dump) dumpElementln(Integer.toHexString(oid.intValue()));\n \t      ret_val = ((ObjectIdentityWrapper)\n \t\t\t this.objectLookupTable.get(oid)).object;\n \t      break;\n \t    }\n \n \t  case TC_CLASS:\n \t    {\n-\t      dumpElementln(\"CLASS\");\n+\t      if(dump) dumpElementln(\"CLASS\");\n \t      ObjectStreamClass osc = (ObjectStreamClass)readObject();\n \t      Class clazz = osc.forClass();\n \t      assignNewHandle(clazz);\n@@ -191,7 +191,7 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \n \t  case TC_PROXYCLASSDESC:\n \t    {\n-\t      dumpElementln(\"PROXYCLASS\");\n+\t      if(dump) dumpElementln(\"PROXYCLASS\");\n \t      int n_intf = this.realInputStream.readInt();\n \t      String[] intfs = new String[n_intf];\n \t      for (int i = 0; i < n_intf; i++)\n@@ -242,41 +242,42 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \t  case TC_STRING:\n \t  case TC_LONGSTRING:\n \t    {\n-\t      dumpElement(\"STRING=\");\n+\t      if(dump) dumpElement(\"STRING=\");\n \t      String s = this.realInputStream.readUTF();\n-\t      dumpElementln(s);\n-\t      ret_val = processResolution(s, assignNewHandle(s));\n+\t      if(dump) dumpElementln(s);\n+\t      ret_val = processResolution(null, s, assignNewHandle(s));\n \t      break;\n \t    }\n \n \t  case TC_ARRAY:\n \t    {\n-\t      dumpElementln(\"ARRAY\");\n+\t      if(dump) dumpElementln(\"ARRAY\");\n \t      ObjectStreamClass osc = (ObjectStreamClass)readObject();\n \t      Class componentType = osc.forClass().getComponentType();\n-\t      dumpElement(\"ARRAY LENGTH=\");\n+\t      if(dump) dumpElement(\"ARRAY LENGTH=\");\n \t      int length = this.realInputStream.readInt();\n-\t      dumpElementln (length + \"; COMPONENT TYPE=\" + componentType);\n+\t      if(dump) dumpElementln (length + \"; COMPONENT TYPE=\" + componentType);\n \t      Object array = Array.newInstance(componentType, length);\n \t      int handle = assignNewHandle(array);\n \t      readArrayElements(array, componentType);\n-\t      for (int i = 0, len = Array.getLength(array); i < len; i++)\n-\t\tdumpElementln(\"  ELEMENT[\" + i + \"]=\" + Array.get(array, i));\n-\t      ret_val = processResolution(array, handle);\n+\t      if(dump)\n+\t        for (int i = 0, len = Array.getLength(array); i < len; i++)\n+\t\t  dumpElementln(\"  ELEMENT[\" + i + \"]=\" + Array.get(array, i));\n+\t      ret_val = processResolution(null, array, handle);\n \t      break;\n \t    }\n \n \t  case TC_OBJECT:\n \t    {\n-\t      dumpElementln(\"OBJECT\");\n+\t      if(dump) dumpElementln(\"OBJECT\");\n \t      ObjectStreamClass osc = (ObjectStreamClass)readObject();\n \t      Class clazz = osc.forClass();\n \t      \n-\t      if (!Serializable.class.isAssignableFrom(clazz))\n+\t      if (!osc.realClassIsSerializable)\n \t\tthrow new NotSerializableException\n \t\t  (clazz + \" is not Serializable, and thus cannot be deserialized.\");\n \t      \n-\t      if (Externalizable.class.isAssignableFrom(clazz))\n+\t      if (osc.realClassIsExternalizable)\n \t\t{\n \t\t  Externalizable obj = null;\n \t\t  \n@@ -315,23 +316,11 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \t\t  if (read_from_blocks)\n \t\t    setBlockDataMode(oldmode);\n \t\t  \n-\t\t  ret_val = processResolution(obj, handle);\n+\t\t  ret_val = processResolution(osc, obj, handle);\n \t\t  break;\n-\t\t} // end if (Externalizable.class.isAssignableFrom (clazz))\n-\t      \n-\t      // find the first non-serializable, non-abstract\n-\t      // class in clazz's inheritance hierarchy\n-\t      Class first_nonserial = clazz.getSuperclass();\n-\t      while (Serializable.class.isAssignableFrom(first_nonserial)\n-\t\t     || Modifier.isAbstract(first_nonserial.getModifiers()))\n-\t\tfirst_nonserial = first_nonserial.getSuperclass();\n-\t      \n-\t      Object obj = null;\n-\t      obj = newObject(clazz, first_nonserial);\n-\t      \n-\t      if (obj == null)\n-\t\tthrow new ClassNotFoundException\n-\t\t  (\"Instance of \" + clazz + \" could not be created\");\n+\t\t} // end if (osc.realClassIsExternalizable)\n+\n+\t      Object obj = newObject(clazz, osc.firstNonSerializableParent);\n \t      \n \t      int handle = assignNewHandle(obj);\n \t      this.currentObject = obj;\n@@ -342,36 +331,37 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \t\t{\n \t\t  this.currentObjectStreamClass = hierarchy[i];\n \t\t  \n-\t\t  dumpElementln(\"Reading fields of \" + this.currentObjectStreamClass.getName ());\n+\t\t  if(dump) dumpElementln(\"Reading fields of \" + this.currentObjectStreamClass.getName ());\n \n \t\t  // XXX: should initialize fields in classes in the hierarchy\n \t\t  // that aren't in the stream\n \t\t  // should skip over classes in the stream that aren't in the\n \t\t  // real classes hierarchy\n \t\t  \n-\t\t  if (this.currentObjectStreamClass.hasReadMethod())\n+\t\t  Method readObjectMethod = this.currentObjectStreamClass.readObjectMethod;\n+\t\t  if (readObjectMethod != null)\n \t\t    {\n \t\t      fieldsAlreadyRead = false;\n \t\t      boolean oldmode = setBlockDataMode(true);\n-\t\t      callReadMethod(obj, this.currentObjectStreamClass);\n+\t\t      callReadMethod(readObjectMethod, this.currentObjectStreamClass.forClass(), obj);\n \t\t      setBlockDataMode(oldmode);\n-\t\t      dumpElement(\"ENDBLOCKDATA? \");\n+\t\t      if(dump) dumpElement(\"ENDBLOCKDATA? \");\n \t\t      try\n \t\t\t{\n \t\t\t  // FIXME: XXX: This try block is to catch EOF which is\n \t\t\t  // thrown for some objects.  That indicates a bug in the logic.\n \t\t\t  if (this.realInputStream.readByte() != TC_ENDBLOCKDATA)\n \t\t\t    throw new IOException\n \t\t\t      (\"No end of block data seen for class with readObject (ObjectInputStream) method.\");\n-\t\t\t  dumpElementln(\"yes\");\n+\t\t\t  if(dump) dumpElementln(\"yes\");\n \t\t\t}\n \t\t      catch (EOFException e)\n \t\t\t{\n-\t\t\t  dumpElementln(\"no, got EOFException\");\n+\t\t\t  if(dump) dumpElementln(\"no, got EOFException\");\n \t\t\t}\n \t\t      catch (IOException e)\n \t\t\t{\n-\t\t\t  dumpElementln(\"no, got IOException\");\n+\t\t\t  if(dump) dumpElementln(\"no, got IOException\");\n \t\t\t}\n \t\t    }\n \t\t  else\n@@ -382,21 +372,21 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \n \t      this.currentObject = null;\n \t      this.currentObjectStreamClass = null;\n-\t      ret_val = processResolution(obj, handle);\n+\t      ret_val = processResolution(osc, obj, handle);\n \t      break;\n \t    }\n \n \t  case TC_RESET:\n-\t    dumpElementln(\"RESET\");\n+\t    if(dump) dumpElementln(\"RESET\");\n \t    clearHandles();\n \t    ret_val = readObject();\n \t    break;\n \n \t  case TC_EXCEPTION:\n \t    {\n-\t      dumpElement(\"EXCEPTION=\");\n+\t      if(dump) dumpElement(\"EXCEPTION=\");\n \t      Exception e = (Exception)readObject();\n-\t      dumpElementln(e.toString());\n+\t      if(dump) dumpElementln(e.toString());\n \t      clearHandles();\n \t      throw new WriteAbortedException(\"Exception thrown during writing of stream\", e);\n \t    }\n@@ -440,27 +430,29 @@ public final Object readObject() throws ClassNotFoundException, IOException\n   protected ObjectStreamClass readClassDescriptor()\n     throws ClassNotFoundException, IOException\n   {\n-    dumpElement(\"CLASSDESC NAME=\");\n+    if(dump) dumpElement(\"CLASSDESC NAME=\");\n     String name = this.realInputStream.readUTF();\n-    dumpElement(name + \"; UID=\");\n+    if(dump) dumpElement(name + \"; UID=\");\n     long uid = this.realInputStream.readLong ();\n-    dumpElement(Long.toHexString(uid) + \"; FLAGS=\");\n+    if(dump) dumpElement(Long.toHexString(uid) + \"; FLAGS=\");\n     byte flags = this.realInputStream.readByte ();\n-    dumpElement(Integer.toHexString(flags) + \"; FIELD COUNT=\");\n+    if(dump) dumpElement(Integer.toHexString(flags) + \"; FIELD COUNT=\");\n     short field_count = this.realInputStream.readShort();\n-    dumpElementln(Short.toString(field_count));\n+    if(dump) dumpElementln(Short.toString(field_count));\n     ObjectStreamField[] fields = new ObjectStreamField[field_count];\n     ObjectStreamClass osc = new ObjectStreamClass(name, uid,\n \t\t\t\t\t\t  flags, fields);\n     assignNewHandle(osc);\n+\n+    ClassLoader currentLoader = currentLoader();\n \t      \n     for (int i = 0; i < field_count; i++)\n       {\n-\tdumpElement(\"  TYPE CODE=\");\n+\tif(dump) dumpElement(\"  TYPE CODE=\");\n \tchar type_code = (char)this.realInputStream.readByte();\n-\tdumpElement(type_code + \"; FIELD NAME=\");\n+\tif(dump) dumpElement(type_code + \"; FIELD NAME=\");\n \tString field_name = this.realInputStream.readUTF();\n-\tdumpElementln(field_name);\n+\tif(dump) dumpElementln(field_name);\n \tString class_name;\n \t\t  \n \t// If the type code is an array or an object we must\n@@ -473,35 +465,87 @@ protected ObjectStreamClass readClassDescriptor()\n \t  class_name = String.valueOf(type_code);\n \t\t  \n \tfields[i] =\n-\t  new ObjectStreamField(field_name, class_name, currentLoader());\n+\t  new ObjectStreamField(field_name, class_name, currentLoader);\n       }\n \t      \n     /* Now that fields have been read we may resolve the class\n      * (and read annotation if needed). */\n     Class clazz = resolveClass(osc);\n-    \n-    for (int i = 0; i < field_count; i++)\n+\n+    boolean oldmode = setBlockDataMode(true);\n+    osc.setClass(clazz, lookupClass(clazz.getSuperclass()));\n+    classLookupTable.put(clazz, osc);\n+    setBlockDataMode(oldmode);\n+\n+    // find the first non-serializable, non-abstract\n+    // class in clazz's inheritance hierarchy\n+    Class first_nonserial = clazz.getSuperclass();\n+    while (Serializable.class.isAssignableFrom(first_nonserial)\n+\t|| Modifier.isAbstract(first_nonserial.getModifiers()))\n+\tfirst_nonserial = first_nonserial.getSuperclass();\n+\n+    osc.firstNonSerializableParent = first_nonserial;\n+    osc.realClassIsSerializable = Serializable.class.isAssignableFrom(clazz);\n+    osc.realClassIsExternalizable = Externalizable.class.isAssignableFrom(clazz);\n+\n+    ObjectStreamField[] stream_fields = osc.fields;\n+    ObjectStreamField[] real_fields = ObjectStreamClass.lookup(clazz).fields;\n+    ObjectStreamField[] fieldmapping = new ObjectStreamField[2 * Math.max(stream_fields.length, real_fields.length)];\n+    osc.fieldMapping = fieldmapping;\n+\n+    int stream_idx = 0;\n+    int real_idx = 0;\n+    int map_idx = 0;\n+\n+    while (stream_idx < stream_fields.length\n+\t   || real_idx < real_fields.length)\n       {\n-\tField f;\n-\t\n-\ttry\n+\tObjectStreamField stream_field = null;\n+\tObjectStreamField real_field = null;\n+\n+\tif (stream_idx == stream_fields.length)\n \t  {\n-\t    f = clazz.getDeclaredField(fields[i].getName());\n-\t    if (f != null && !f.getType().equals(fields[i].getType()))\n-\t      throw new InvalidClassException\n-\t\t(\"invalid field type for \" + fields[i].getName() + \" in class \"\n-\t\t + name + \" (requested was \\\"\" + fields[i].getType()\n-\t\t + \" and found \\\"\" + f.getType() + \"\\\")\"); \n+\t    real_field = real_fields[real_idx++];\n \t  }\n-\tcatch (NoSuchFieldException _)\n+\telse if (real_idx == real_fields.length)\n \t  {\n+\t    stream_field = stream_fields[stream_idx++];\n \t  }\n-      }\n+\telse\n+\t  {\n+\t    int comp_val =\n+\t\treal_fields[real_idx].compareTo (stream_fields[stream_idx]);\n \n-    boolean oldmode = setBlockDataMode(true);\n-    osc.setClass(clazz, lookupClass(clazz.getSuperclass()));\n-    classLookupTable.put(clazz, osc);\n-    setBlockDataMode(oldmode);\n+\t    if (comp_val < 0)\n+\t      {\n+\t\treal_field = real_fields[real_idx++];\n+\t      }\n+\t    else if (comp_val > 0)\n+\t      {\n+\t\tstream_field = stream_fields[stream_idx++];\n+\t      }\n+\t    else\n+\t      {\n+\t\tstream_field = stream_fields[stream_idx++];\n+\t\treal_field = real_fields[real_idx++];\n+\t\tif(stream_field.getType() != real_field.getType())\n+\t\t    throw new InvalidClassException\n+\t\t\t(\"invalid field type for \" + real_field.getName() +\n+\t\t\t\" in class \" + name);\n+\t      }\n+\t  }\n+\tif (stream_field != null)\n+\t  {\n+\t    if (stream_field.getOffset() < 0)\n+\t\tstream_field = null;\n+\t    else if (!stream_field.isToSet())\n+\t\treal_field = null;\n+\t  }\n+\tif (real_field != null && !real_field.isToSet())\n+\t    real_field = null;\n+\tfieldmapping[map_idx++] = stream_field;\n+\tfieldmapping[map_idx++] = real_field;\n+      }\n \n     return osc;\n   }\n@@ -763,11 +807,11 @@ protected boolean enableResolveObject (boolean enable)\n   protected void readStreamHeader()\n     throws IOException, StreamCorruptedException\n   {\n-    dumpElement(\"STREAM MAGIC \");\n+    if(dump) dumpElement(\"STREAM MAGIC \");\n     if (this.realInputStream.readShort() != STREAM_MAGIC)\n       throw new StreamCorruptedException(\"Invalid stream magic number\");\n \n-    dumpElementln(\"STREAM VERSION \");\n+    if(dump) dumpElementln(\"STREAM VERSION \");\n     if (this.realInputStream.readShort() != STREAM_VERSION)\n       throw new StreamCorruptedException(\"Invalid stream version number\");\n   }\n@@ -1045,7 +1089,7 @@ public abstract Object get(String name, Object defvalue)\n    * deserializing class (if present). It cannot (and should not)be called\n    * outside of it. Its goal is to read all fields in the real input stream\n    * and keep them accessible through the {@link #GetField} class. Calling\n-   * this method will not alterate the deserializing object.\n+   * this method will not alter the deserializing object.\n    *\n    * @return A valid freshly created 'GetField' instance to get access to\n    * the deserialized stream.\n@@ -1375,20 +1419,18 @@ private int assignNewHandle(Object obj)\n     return this.nextOID++;\n   }\n \n-  private Object processResolution(Object obj, int handle)\n+  private Object processResolution(ObjectStreamClass osc, Object obj, int handle)\n     throws IOException\n   {\n-    if (obj instanceof Serializable)\n+    if (osc != null && obj instanceof Serializable)\n       {\n-        Method m = null; \n \ttry\n \t  {\n-\t    Class classArgs[] = {};\n-\t    m = getMethod(obj.getClass(), \"readResolve\", classArgs);\n-\t    obj = m.invoke(obj, new Object[] {});\t\n-\t  }\n-\tcatch (NoSuchMethodException ignore)\n-\t  {\n+\t    Method m = osc.readResolveMethod; \n+\t    if(m != null)\n+\t    {\n+\t\tobj = m.invoke(obj, new Object[] {});\n+\t    }\n \t  }\n \tcatch (IllegalAccessException ignore)\n \t  {\n@@ -1422,15 +1464,15 @@ private void readNextBlock(byte marker) throws IOException\n   {\n     if (marker == TC_BLOCKDATA)\n       {\n-\tdumpElement(\"BLOCK DATA SIZE=\");\n+\tif(dump) dumpElement(\"BLOCK DATA SIZE=\");\n \tthis.blockDataBytes = this.realInputStream.readUnsignedByte();\n-\tdumpElementln (Integer.toString(this.blockDataBytes));\n+\tif(dump) dumpElementln (Integer.toString(this.blockDataBytes));\n       }\n     else if (marker == TC_BLOCKDATALONG)\n       {\n-\tdumpElement(\"BLOCK DATA LONG SIZE=\");\n+\tif(dump) dumpElement(\"BLOCK DATA LONG SIZE=\");\n \tthis.blockDataBytes = this.realInputStream.readInt();\n-\tdumpElementln (Integer.toString(this.blockDataBytes));\n+\tif(dump) dumpElementln (Integer.toString(this.blockDataBytes));\n       }\n     else\n       {\n@@ -1517,159 +1559,124 @@ private void readArrayElements (Object array, Class clazz)\n   private void readFields (Object obj, ObjectStreamClass stream_osc)\n     throws ClassNotFoundException, IOException\n   {\n-    ObjectStreamField[] stream_fields = stream_osc.fields;\n-    ObjectStreamField[] real_fields =\n-      lookupClass(stream_osc.forClass()).fields;\n-\n-    boolean default_initialize, set_value;\n-    String field_name = null;\n-    Class type = null;\n-    ObjectStreamField stream_field = null;\n-    ObjectStreamField real_field = null;\n-    int stream_idx = 0;\n-    int real_idx = 0;\n+    ObjectStreamField[] fields = stream_osc.fieldMapping;\n \n-    while (stream_idx < stream_fields.length\n-\t   && real_idx < real_fields.length)\n+    for (int i = 0; i < fields.length; i += 2)\n       {\n-\tdefault_initialize = false;\n-\tset_value = true;\n-\n-\tif (stream_idx == stream_fields.length)\n-\t  default_initialize = true;\n-\telse\n-\t  {\n-\t    stream_field = stream_fields[stream_idx];\n-\t    type = stream_field.getType();\n-\t  }\n-\n-\tif (real_idx == real_fields.length)\n-\t  set_value = false;\n-\telse\n+\tObjectStreamField stream_field = fields[i];\n+\tObjectStreamField real_field = fields[i + 1];\n+\tif(stream_field != null || real_field != null)\n \t  {\n-\t    real_field = real_fields[real_idx];\n-\t    type = real_field.getType();\n-\t    field_name = real_field.getName();\n-\t  }\n-\n-\tif (set_value && !default_initialize)\n-\t  {\n-\t    int comp_val =\n-\t      real_field.compareTo (stream_field);\n-\n-\t    if (comp_val < 0)\n+\t    boolean read_value = stream_field != null;\n+\t    boolean set_value = real_field != null;\n+\t    String field_name;\n+\t    char type;\n+\t    if (stream_field != null)\n \t      {\n-\t\tdefault_initialize = true;\n-\t\treal_idx++;\n-\t      }\n-\t    else if (comp_val > 0)\n-\t      {\n-\t\tset_value = false;\n-\t\tstream_idx++;\n+\t\tfield_name = stream_field.getName();\n+\t\ttype = stream_field.getTypeCode();\n \t      }\n \t    else\n \t      {\n-\t\treal_idx++;\n-\t\tstream_idx++;\n+\t\tfield_name = real_field.getName();\n+\t\ttype = real_field.getTypeCode();\n \t      }\n-\t  }\n-\n-\tif (stream_field.getOffset() < 0)\n-\t  {\n-\t    default_initialize = true;\n-\t    set_value = false;\n-\t  }\n-\t\n-\tif (!stream_field.isToSet()) \n-\t  set_value = false;\n \n-\ttry\n-\t  {\n-\t    if (type == Boolean.TYPE)\n-\t      {\n-\t\tboolean value =\n-\t\t  default_initialize ? false : this.realInputStream.readBoolean();\n-\t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\tif (set_value)\n-\t\t  setBooleanField(obj, stream_osc.forClass(), field_name, value);\n-\t      }\n-\t    else if (type == Byte.TYPE)\n-\t      {\n-\t\tbyte value =\n-\t\t  default_initialize ? 0 : this.realInputStream.readByte();\n-\t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\tif (set_value)\n-\t\t  setByteField(obj, stream_osc.forClass(), field_name, value);\n-\t      }\n-\t    else if (type == Character.TYPE)\n-\t      {\n-\t\tchar value =\n-\t\t  default_initialize ? (char)0 : this.realInputStream.readChar();\n-\t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\tif (set_value)\n-\t\t  setCharField(obj, stream_osc.forClass(), field_name, value);\n-\t      }\n-\t    else if (type == Double.TYPE)\n-\t      {\n-\t\tdouble value =\n-\t\t  default_initialize ? 0 : this.realInputStream.readDouble();\n-\t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\tif (set_value)\n-\t\t  setDoubleField(obj, stream_osc.forClass(), field_name, value);\n-\t      }\n-\t    else if (type == Float.TYPE)\n-\t      {\n-\t\tfloat value =\n-\t\t  default_initialize ? 0 : this.realInputStream.readFloat();\n-\t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\tif (set_value)\n-\t\t  setFloatField(obj, stream_osc.forClass(), field_name, value);\n-\t      }\n-\t    else if (type == Integer.TYPE)\n-\t      {\n-\t\tint value =\n-\t\t  default_initialize ? 0 : this.realInputStream.readInt();\n-\t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\tif (set_value)\n-\t\t  setIntField(obj, stream_osc.forClass(), field_name, value);\n-\t      }\n-\t    else if (type == Long.TYPE)\n-\t      {\n-\t\tlong value =\n-\t\t  default_initialize ? 0 : this.realInputStream.readLong();\n-\t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\tif (set_value)\n-\t\t  setLongField(obj, stream_osc.forClass(), field_name, value);\n-\t      }\n-\t    else if (type == Short.TYPE)\n-\t      {\n-\t\tshort value =\n-\t\t  default_initialize ? (short)0 : this.realInputStream.readShort();\n-\t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n-\t\tif (set_value)\n-\t\t  setShortField(obj, stream_osc.forClass(), field_name, value);\n-\t      }\n-\t    else\n+\t    switch(type)\n \t      {\n-\t\tObject value =\n-\t\t  default_initialize ? null : readObject();\n-\t\tif (set_value)\n-\t\t  setObjectField(obj, stream_osc.forClass(), field_name,\n-\t\t\t\t  real_field.getTypeString(), value);\n+\t\tcase 'Z':\n+\t\t  {\n+\t\t    boolean value =\n+\t\t\tread_value ? this.realInputStream.readBoolean() : false;\n+\t\t    if (dump && read_value && set_value)\n+\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n+\t\t    if (set_value)\n+\t\t\treal_field.setBooleanField(obj, value);\n+\t\t    break;\n+\t\t  }\n+\t\tcase 'B':\n+\t\t  {\n+\t\t    byte value =\n+\t\t\tread_value ? this.realInputStream.readByte() : 0;\n+\t\t    if (dump && read_value && set_value)\n+\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n+\t\t    if (set_value)\n+\t\t\treal_field.setByteField(obj, value);\n+\t\t    break;\n+\t\t  }\n+\t\tcase 'C':\n+\t\t  {\n+\t\t    char value =\n+\t\t\tread_value ? this.realInputStream.readChar(): 0;\n+\t\t    if (dump && read_value && set_value)\n+\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n+\t\t    if (set_value)\n+\t\t\treal_field.setCharField(obj, value);\n+\t\t    break;\n+\t\t  }\n+\t\tcase 'D':\n+\t\t  {\n+\t\t    double value =\n+\t\t\tread_value ? this.realInputStream.readDouble() : 0;\n+\t\t    if (dump && read_value && set_value)\n+\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n+\t\t    if (set_value)\n+\t\t\treal_field.setDoubleField(obj, value);\n+\t\t    break;\n+\t\t  }\n+\t\tcase 'F':\n+\t\t  {\n+\t\t    float value =\n+\t\t\tread_value ? this.realInputStream.readFloat() : 0;\n+\t\t    if (dump && read_value && set_value)\n+\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n+\t\t    if (set_value)\n+\t\t\treal_field.setFloatField(obj, value);\n+\t\t    break;\n+\t\t  }\n+\t\tcase 'I':\n+\t\t  {\n+\t\t    int value =\n+\t\t\tread_value ? this.realInputStream.readInt() : 0;\n+\t\t    if (dump && read_value && set_value)\n+\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n+\t\t    if (set_value)\n+\t\t\treal_field.setIntField(obj, value);\n+\t\t    break;\n+\t\t  }\n+\t\tcase 'J':\n+\t\t  {\n+\t\t    long value =\n+\t\t\tread_value ? this.realInputStream.readLong() : 0;\n+\t\t    if (dump && read_value && set_value)\n+\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n+\t\t    if (set_value)\n+\t\t\treal_field.setLongField(obj, value);\n+\t\t    break;\n+\t\t  }\n+\t\tcase 'S':\n+\t\t  {\n+\t\t    short value =\n+\t\t\tread_value ? this.realInputStream.readShort() : 0;\n+\t\t    if (dump && read_value && set_value)\n+\t\t    dumpElementln(\"  \" + field_name + \": \" + value);\n+\t\t    if (set_value)\n+\t\t\treal_field.setShortField(obj, value);\n+\t\t    break;\n+\t\t  }\n+\t\tcase 'L':\n+\t\tcase '[':\n+\t\t  {\n+\t\t    Object value =\n+\t\t\tread_value ? readObject() : null;\n+\t\t    if (set_value)\n+\t\t\treal_field.setObjectField(obj, value);\n+\t\t    break;\n+\t\t  }\n+\t\tdefault:\n+\t\t    throw new InternalError(\"Invalid type code: \" + type);\n \t      }\n \t  }\n-\tcatch (NoSuchFieldError e)\n-\t  {\n-\t    dumpElementln(\"XXXX \" + field_name + \" does not exist.\");\n-\t  }\n       }\n   }\n \n@@ -1689,6 +1696,7 @@ private boolean setBlockDataMode (boolean on)\n   // returns a new instance of REAL_CLASS that has been constructed\n   // only to the level of CONSTRUCTOR_CLASS (a super class of REAL_CLASS)\n   private Object newObject (Class real_class, Class constructor_class)\n+    throws ClassNotFoundException\n   {\n     try\n       {\n@@ -1698,7 +1706,8 @@ private Object newObject (Class real_class, Class constructor_class)\n       }\n     catch (InstantiationException e)\n       {\n-\treturn null;\n+        throw new ClassNotFoundException\n+\t\t(\"Instance of \" + real_class + \" could not be created\");\n       }\n   }\n \n@@ -1728,77 +1737,13 @@ private void invokeValidators() throws InvalidObjectException\n    * @param sm SecurityManager instance which should be called.\n    * @return The current class loader in the calling stack.\n    */\n-  private static ClassLoader currentClassLoader (SecurityManager sm)\n-  {\n-    // FIXME: This is too simple.\n-    return ClassLoader.getSystemClassLoader ();\n-  }\n-\n-  /**\n-   * This method tries to access a precise field called in the\n-   * specified class. Before accessing the field, it tries to\n-   * gain control on this field. If the field is either declared as \n-   * not persistent or transient then it returns null\n-   * immediately.\n-   *\n-   * @param klass Class to get the field from.\n-   * @param name Name of the field to access.\n-   * @return Field instance representing the requested field.\n-   * @throws NoSuchFieldException if the field does not exist.\n-   */\n-  private Field getField(Class klass, String name)\n-    throws java.lang.NoSuchFieldException\n-  {\n-    final Field f = klass.getDeclaredField(name);\n-    ObjectStreamField sf = lookupClass(klass).getField(name);\n-    \n-    AccessController.doPrivileged(new PrivilegedAction()\n-      {\n-\tpublic Object run()\n-\t{\n-\t  f.setAccessible(true);\n-\t  return null;\n-\t}\n-      });\n-\n-    /* We do not want to modify transient fields. They should\n-     * be left to 0.\n-     * N.B.: Not valid if the field is in serialPersistentFields. \n-     */\n-    if (Modifier.isTransient(f.getModifiers()) && !sf.isPersistent())\n-      return null;\n-   \n-    return f;\n-  }\n-\n-  private static Method getMethod (Class klass, String name, Class args[])\n-    throws java.lang.NoSuchMethodException\n-  {\n-    final Method m = klass.getDeclaredMethod(name, args);\n-    AccessController.doPrivileged(new PrivilegedAction()\n-      {\n-\tpublic Object run()\n-\t{\n-\t  m.setAccessible(true);\n-\t  return null;\n-\t}\n-      });\n-    return m;\n-  }\n+  private static native ClassLoader currentClassLoader (SecurityManager sm);\n \n-  private void callReadMethod (Object obj, ObjectStreamClass osc) throws IOException\n+  private void callReadMethod (Method readObject, Class klass, Object obj) throws IOException\n   {\n-    Class klass = osc.forClass();\n     try\n       {\n-\tClass classArgs[] = {ObjectInputStream.class};\n-\tMethod m = getMethod (klass, \"readObject\", classArgs);\n-\tObject args[] = {this};\n-\tm.invoke(obj, args);\n-      }\n-    catch (NoSuchMethodException nsme)\n-      {\n-\t// Nothing.\n+\treadObject.invoke(obj, new Object[] { this });\n       }\n     catch (InvocationTargetException x)\n       {\n@@ -1827,265 +1772,7 @@ private native Object allocateObject (Class clazz)\n \n   private native void callConstructor (Class clazz, Object obj);\n \n-  /**\n-   * This method writes a \"boolean\" value <code>val</code> in the specified field\n-   * of the instance <code>obj</code> of the type <code>klass</code>.\n-   *\n-   * @param obj Instance to setup.\n-   * @param klass Class type of the specified instance.\n-   * @param field_name Name of the field in the specified class type.\n-   * @param val The boolean value to write into the field.\n-   * @throws InvalidClassException if the specified field has not the required type.\n-   * @throws IOException if there is no field of that name in the specified class.\n-   */\n-  private void setBooleanField(Object obj, Class klass, String field_name,\n-\t\t\t\tboolean val) throws IOException, InvalidClassException\n-  {\n-    try\n-      {\n-\tField f = getField(klass, field_name);\n-\tf.setBoolean(obj, val);\n-      }\n-    catch (IllegalArgumentException _)\n-      {\n-\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n-      }\n-    catch (Exception _)\n-      {\n-      }    \n-  }\n-\n-  /**\n-   * This method writes a \"byte\" value <code>val</code> in the specified field\n-   * of the instance <code>obj</code> of the type <code>klass</code>.\n-   *\n-   * @param obj Instance to setup.\n-   * @param klass Class type of the specified instance.\n-   * @param field_name Name of the field in the specified class type.\n-   * @param val The byte value to write into the field.\n-   * @throws InvalidClassException if the specified field has not the required type.\n-   * @throws IOException if there is no field of that name in the specified class.\n-   */\n-  private void setByteField(Object obj, Class klass, String field_name,\n-\t\t\t     byte val) throws IOException, InvalidClassException\n-  {\n-    try\n-      {\n-\tField f = getField(klass, field_name);\n-\tf.setByte(obj, val);\n-      }\n-    catch (IllegalArgumentException _)\n-      {\n-\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n-      }\n-    catch (Exception _)\n-      {\n-      }    \n-  }\n-\n-  /**\n-   * This method writes a \"character\" value <code>val</code> in the specified field\n-   * of the instance <code>obj</code> of the type <code>klass</code>.\n-   *\n-   * @param obj Instance to setup.\n-   * @param klass Class type of the specified instance.\n-   * @param field_name Name of the field in the specified class type.\n-   * @param val The character value to write into the field.\n-   * @throws InvalidClassException if the specified field has not the required type.\n-   * @throws IOException if there is no field of that name in the specified class.\n-   */\n-  private void setCharField(Object obj, Class klass, String field_name,\n-\t\t\t     char val) throws IOException, InvalidClassException\n-  {\n-    try\n-      {\n-\tField f = getField(klass, field_name);\n-\tf.setChar(obj, val);\n-      }\n-    catch (IllegalArgumentException _)\n-      {\n-\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n-      }\n-    catch (Exception _)\n-      {\n-      }    \n-  }\n-\n-  /**\n-   * This method writes a \"double\" value <code>val</code> in the specified field\n-   * of the instance <code>obj</code> of the type <code>klass</code>.\n-   *\n-   * @param obj Instance to setup.\n-   * @param klass Class type of the specified instance.\n-   * @param field_name Name of the field in the specified class type.\n-   * @param val The double value to write into the field.\n-   * @throws InvalidClassException if the specified field has not the required type.\n-   * @throws IOException if there is no field of that name in the specified class.\n-   */\n-  private void setDoubleField(Object obj, Class klass, String field_name,\n-\t\t\t       double val) throws IOException, InvalidClassException\n-  {\n-    try\n-      {\n-\tField f = getField(klass, field_name);\n-\tf.setDouble(obj, val);\n-      }\n-    catch (IllegalArgumentException _)\n-      {\n-\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n-      }\n-    catch (Exception _)\n-      {\n-      }    \n-  }\n-\n-  /**\n-   * This method writes a \"float\" value <code>val</code> in the specified field\n-   * of the instance <code>obj</code> of the type <code>klass</code>.\n-   *\n-   * @param obj Instance to setup.\n-   * @param klass Class type of the specified instance.\n-   * @param field_name Name of the field in the specified class type.\n-   * @param val The float value to write into the field.\n-   * @throws InvalidClassException if the specified field has not the required type.\n-   * @throws IOException if there is no field of that name in the specified class.\n-   */\n-  private void setFloatField(Object obj, Class klass, String field_name,\n-\t\t\t      float val) throws IOException, InvalidClassException\n-  {\n-    try\n-      {\n-\tField f = getField(klass, field_name);\n-\tf.setFloat(obj, val);\n-      }\n-    catch (IllegalArgumentException _)\n-      {\n-\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n-      }\n-    catch (Exception _)\n-      {\n-      }    \n-  }\n-\n-  /**\n-   * This method writes an \"integer\" value <code>val</code> in the specified field\n-   * of the instance <code>obj</code> of the type <code>klass</code>.\n-   *\n-   * @param obj Instance to setup.\n-   * @param klass Class type of the specified instance.\n-   * @param field_name Name of the field in the specified class type.\n-   * @param val The integer value to write into the field.\n-   * @throws InvalidClassException if the specified field has not the required type.\n-   * @throws IOException if there is no field of that name in the specified class.\n-   */\n-  private void setIntField(Object obj, Class klass, String field_name,\n-\t\t\t    int val) throws IOException, InvalidClassException\n-  {\n-    try\n-      {\n-\tField f = getField(klass, field_name);\n-\tf.setInt(obj, val);\n-      }\n-    catch (IllegalArgumentException _)\n-      {\n-\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n-      }\n-    catch (Exception _)\n-      {\n-      }    \n-  }\n-\n-  /**\n-   * This method writes the long value <code>val</code> in the specified field\n-   * of the instance <code>obj</code> of the type <code>klass</code>.\n-   *\n-   * @param obj Instance to setup.\n-   * @param klass Class type of the specified instance.\n-   * @param field_name Name of the field in the specified class type.\n-   * @param val The long value to write into the field.\n-   * @throws InvalidClassException if the specified field has not the required type.\n-   * @throws IOException if there is no field of that name in the specified class.\n-   */\n-  private void setLongField(Object obj, Class klass, String field_name,\n-\t\t\t     long val) throws IOException, InvalidClassException\n-  {\n-    try\n-      {\n-\tField f = getField(klass, field_name);\n-\tf.setLong(obj, val);\n-      }\n-    catch (IllegalArgumentException _)\n-      {\n-\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n-      }\n-    catch (Exception _)\n-      {\n-      }    \n-  }\n-\n-  /**\n-   * This method writes a \"short\" value <code>val</code> in the specified field\n-   * of the instance <code>obj</code> of the type <code>klass</code>.\n-   *\n-   * @param obj Instance to setup.\n-   * @param klass Class type of the specified instance.\n-   * @param field_name Name of the field in the specified class type.\n-   * @param val The short value to write into the field.\n-   * @throws InvalidClassException if the specified field has not the required type.\n-   * @throws IOException if there is no field of that name in the specified class.\n-   */\n-  private void setShortField(Object obj, Class klass, String field_name,\n-\t\t\t      short val) throws IOException, InvalidClassException\n-  {\n-    try\n-      {\n-\tField f = getField(klass, field_name);\n-\tf.setShort(obj, val);\n-      }\n-    catch (IllegalArgumentException _)\n-      {\n-\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n-      }\n-    catch (Exception _)\n-      {\n-      }    \n-  }\n-\n-  /**\n-   * This method writes an \"object\" value <code>val</code> in the specified field\n-   * of the instance <code>obj</code> of the type <code>klass</code>.\n-   *\n-   * @param obj Instance to setup.\n-   * @param klass Class type of the specified instance.\n-   * @param field_name Name of the field in the specified class type.\n-   * @param val The \"object\" value to write into the field.\n-   * @throws InvalidClassException if the specified field has not the required type.\n-   * @throws IOException if there is no field of that name in the specified class.\n-   */\n-  private void setObjectField(Object obj, Class klass, String field_name,\n-\t\t\t       String type_code, Object val) throws IOException, InvalidClassException\n-  {\n-    try\n-      {\n- \tField f = getField(klass, field_name);\n-\tObjectStreamField of = new ObjectStreamField(field_name, f.getType());\n-\t\n-\tif (of.getTypeString() == null ||\n-\t    !of.getTypeString().equals(type_code))\n-          throw new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n- \tf.set(obj, val);\n-      }\n-    catch (InvalidClassException e)\n-      {\n-\tthrow e;\n-      }\n-    catch (Exception _)\n-      {\n-      }\n-  }\n-\n   private static final int BUFFER_SIZE = 1024;\n-  private static final Class[] readObjectParams = { ObjectInputStream.class };\n \n   private DataInputStream realInputStream;\n   private DataInputStream dataInputStream;\n@@ -2106,18 +1793,16 @@ private void setObjectField(Object obj, Class klass, String field_name,\n   private Hashtable classLookupTable;\n   private GetField prereadFields;\n \n-  private static boolean dump;\n+  private static boolean dump = false && Configuration.DEBUG;\n \n   private void dumpElement (String msg)\n   {\n-    if (Configuration.DEBUG && dump)  \n-      System.out.print(msg);\n+    System.out.print(msg);\n   }\n   \n   private void dumpElementln (String msg)\n   {\n-    if (Configuration.DEBUG && dump)\n-      System.out.println(msg);\n+    System.out.println(msg);\n   }\n \n   static"}, {"sha": "429db187b4752805f859c045c43be289c9348051", "filename": "libjava/java/io/ObjectStreamClass.java", "status": "modified", "additions": 92, "deletions": 29, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2941cc061a7a0cafdfa0aec2be9387c92b590625/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2941cc061a7a0cafdfa0aec2be9387c92b590625/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamClass.java?ref=2941cc061a7a0cafdfa0aec2be9387c92b590625", "patch": "@@ -45,9 +45,11 @@\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n import java.lang.reflect.Proxy;\n+import java.security.AccessController;\n import java.security.DigestOutputStream;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n+import java.security.PrivilegedAction;\n import java.security.Security;\n import java.util.Arrays;\n import java.util.Comparator;\n@@ -192,29 +194,6 @@ boolean hasWriteMethod()\n     return (flags & ObjectStreamConstants.SC_WRITE_METHOD) != 0;\n   }\n \n-\n-  // Returns true iff the class that this ObjectStreamClass represents\n-  // has the following method:\n-  //\n-  // private void readObject (ObjectOutputStream)\n-  //\n-  // This method is used by the class to override default\n-  // serialization behavior.\n-  boolean hasReadMethod()\n-  {\n-    try\n-      {\n-\tClass[] readObjectParams = { ObjectInputStream.class };\n-\tforClass().getDeclaredMethod(\"readObject\", readObjectParams);\n-\treturn true;\n-      }\n-    catch (NoSuchMethodException e)\n-      {\n-\treturn false;\n-      }\n-  }\n-\n-\n   // Returns true iff the class that this ObjectStreamClass represents\n   // implements Serializable but does *not* implement Externalizable.\n   boolean isSerializable()\n@@ -306,6 +285,8 @@ void setClass(Class cl, ObjectStreamClass superClass) throws InvalidClassExcepti\n   {\n     this.clazz = cl;\n \n+    cacheMethods();\n+\n     long class_uid = getClassUID(cl);\n     if (uid == 0)\n       uid = class_uid;\n@@ -452,6 +433,50 @@ void calculateOffsets()\n       fields[i].setOffset(objectFieldCount++);\n   }\n \n+  private Method findMethod(Method[] methods, String name, Class[] params,\n+\t\t\t    Class returnType)\n+  {\n+outer:\n+    for(int i = 0; i < methods.length; i++)\n+    {\n+\tif(methods[i].getName().equals(name) &&\n+\t   methods[i].getReturnType() == returnType)\n+\t{\n+\t    Class[] mp = methods[i].getParameterTypes();\n+\t    if(mp.length == params.length)\n+\t    {\n+\t\tfor(int j = 0; j < mp.length; j++)\n+\t\t{\n+\t\t    if(mp[j] != params[j])\n+\t\t    {\n+\t\t\tcontinue outer;\n+\t\t    }\n+\t\t}\n+\t\tfinal Method m = methods[i];\n+\t\tAccessController.doPrivileged(new PrivilegedAction()\n+\t\t{\n+\t\t    public Object run()\n+\t\t    {\n+\t\t\tm.setAccessible(true);\n+\t\t\treturn null;\n+\t\t    }\n+\t\t});\n+\t\treturn m;\n+\t    }\n+\t}\n+    }\n+    return null;\n+  }\n+\n+  private void cacheMethods()\n+  {\n+    Method[] methods = forClass().getDeclaredMethods();\n+    readObjectMethod = findMethod(methods, \"readObject\",\n+\t\t\t\t  new Class[] { ObjectInputStream.class },\n+\t\t\t\t  Void.TYPE);\n+    readResolveMethod = findMethod(methods, \"readResolve\",\n+\t\t\t\t   new Class[0], Object.class);\n+  }\n \n   private ObjectStreamClass(Class cl)\n   {\n@@ -460,6 +485,7 @@ private ObjectStreamClass(Class cl)\n     isProxyClass = Proxy.isProxyClass(cl);\n \n     clazz = cl;\n+    cacheMethods();\n     name = cl.getName();\n     setFlags(cl);\n     setFields(cl);\n@@ -508,9 +534,16 @@ private void setFields(Class cl)\n \n     try\n       {\n-\tField serialPersistentFields =\n+\tfinal Field serialPersistentFields =\n \t  cl.getDeclaredField(\"serialPersistentFields\");\n-\tserialPersistentFields.setAccessible(true);\n+\tAccessController.doPrivileged(new PrivilegedAction()\n+\t{\n+\t    public Object run()\n+\t    {\n+\t\tserialPersistentFields.setAccessible(true);\n+\t\treturn null;\n+\t    }\n+\t});\n \tint modifiers = serialPersistentFields.getModifiers();\n \n \tif (Modifier.isStatic(modifiers)\n@@ -553,12 +586,28 @@ private void setFields(Class cl)\n     for (int from = 0, to = 0; from < all_fields.length; from++)\n       if (all_fields[from] != null)\n \t{\n-\t  Field f = all_fields[from];\n-\t  fields[to] = new ObjectStreamField(f.getName(), f.getType());\n+\t  final Field f = all_fields[from];\n+\t  AccessController.doPrivileged(new PrivilegedAction()\n+\t  {\n+\t      public Object run()\n+\t      {\n+\t\t  f.setAccessible(true);\n+\t\t  return null;\n+\t      }\n+\t  });\n+\t  fields[to] = new ObjectStreamField(all_fields[from]);\n \t  to++;\n \t}\n \n     Arrays.sort(fields);\n+    // Make sure we don't have any duplicate field names\n+    // (Sun JDK 1.4.1. throws an Internal Error as well)\n+    for (int i = 1; i < fields.length; i++)\n+      {\n+\tif(fields[i - 1].getName().equals(fields[i].getName()))\n+\t    throw new InternalError(\"Duplicate field \" + \n+\t\t\tfields[i].getName() + \" in class \" + cl.getName());\n+      }\n     calculateOffsets();\n   }\n \n@@ -571,8 +620,15 @@ private long getClassUID(Class cl)\n \t// Use getDeclaredField rather than getField, since serialVersionUID\n \t// may not be public AND we only want the serialVersionUID of this\n \t// class, not a superclass or interface.\n-\tField suid = cl.getDeclaredField(\"serialVersionUID\");\n-\tsuid.setAccessible(true);\n+\tfinal Field suid = cl.getDeclaredField(\"serialVersionUID\");\n+\tAccessController.doPrivileged(new PrivilegedAction()\n+\t{\n+\t    public Object run()\n+\t    {\n+\t\tsuid.setAccessible(true);\n+\t\treturn null;\n+\t    }\n+\t});\n \tint modifiers = suid.getModifiers();\n \n \tif (Modifier.isStatic(modifiers)\n@@ -769,6 +825,13 @@ private ObjectStreamField[] getSerialPersistentFields(Class clazz)\n   int primFieldSize = -1;  // -1 if not yet calculated\n   int objectFieldCount;\n \n+  Method readObjectMethod;\n+  Method readResolveMethod;\n+  boolean realClassIsSerializable;\n+  boolean realClassIsExternalizable;\n+  ObjectStreamField[] fieldMapping;\n+  Class firstNonSerializableParent;\n+\n   boolean isProxyClass = false;\n \n   // This is probably not necessary because this class is special cased already"}, {"sha": "603fe30917d2581978edc414739a8d10f8d73fe0", "filename": "libjava/java/io/ObjectStreamField.java", "status": "modified", "additions": 120, "deletions": 5, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2941cc061a7a0cafdfa0aec2be9387c92b590625/libjava%2Fjava%2Fio%2FObjectStreamField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2941cc061a7a0cafdfa0aec2be9387c92b590625/libjava%2Fjava%2Fio%2FObjectStreamField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamField.java?ref=2941cc061a7a0cafdfa0aec2be9387c92b590625", "patch": "@@ -38,6 +38,8 @@\n \n package java.io;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n import gnu.java.lang.reflect.TypeSignature;\n \n /**\n@@ -54,6 +56,14 @@ public class ObjectStreamField implements Comparable\n   private boolean unshared;\n   private boolean persistent = false;\n   private boolean toset = true;\n+  private Field field;\n+\n+  ObjectStreamField (Field field)\n+  {\n+    this (field.getName(), field.getType());\n+    this.field = field;\n+    toset = !Modifier.isFinal(field.getModifiers());\n+  }\n \n   /**\n    * This constructor creates an ObjectStreamField instance \n@@ -105,7 +115,6 @@ public ObjectStreamField (String name, Class type, boolean unshared)\n       }\n     catch(ClassNotFoundException e)\n       {\n-        type = Object.class; //FIXME: ???\n       }\n   }\n   \n@@ -128,7 +137,6 @@ public ObjectStreamField (String name, Class type, boolean unshared)\n       }\n     catch(ClassNotFoundException e)\n       {\n-        type = Object.class; // ALSO FIXME \n       }\n   }\n \n@@ -176,7 +184,7 @@ public char getTypeCode ()\n   public String getTypeString ()\n   {\n     // use intern()\n-    if (this.type.isPrimitive())\n+    if (isPrimitive())\n       return null;\n     return typename.intern();\n   }\n@@ -225,7 +233,7 @@ public boolean isUnshared ()\n    */\n   public boolean isPrimitive ()\n   {\n-    return type.isPrimitive ();\n+    return typename.length() == 1;\n   }\n \n   public int compareTo (Object o)\n@@ -299,5 +307,112 @@ public String toString ()\n   {\n     return \"ObjectStreamField< \" + type + \" \" + name + \" >\";\n   }\n-}\n \n+  final void setBooleanField(Object obj, boolean val)\n+  {\n+      try\n+      {\n+\t  field.setBoolean(obj, val);\n+      }\n+      catch(IllegalAccessException x)\n+      {\n+\t  throw new InternalError(x.getMessage());\n+      }\n+  }\n+\n+  final void setByteField(Object obj, byte val)\n+  {\n+      try\n+      {\n+\t  field.setByte(obj, val);\n+      }\n+      catch(IllegalAccessException x)\n+      {\n+\t  throw new InternalError(x.getMessage());\n+      }\n+  }\n+\n+  final void setCharField(Object obj, char val)\n+  {\n+      try\n+      {\n+\t  field.setChar(obj, val);\n+      }\n+      catch(IllegalAccessException x)\n+      {\n+\t  throw new InternalError(x.getMessage());\n+      }\n+  }\n+\n+  final void setShortField(Object obj, short val)\n+  {\n+      try\n+      {\n+\t  field.setShort(obj, val);\n+      }\n+      catch(IllegalAccessException x)\n+      {\n+\t  throw new InternalError(x.getMessage());\n+      }\n+  }\n+\n+  final void setIntField(Object obj, int val)\n+  {\n+      try\n+      {\n+\t  field.setInt(obj, val);\n+      }\n+      catch(IllegalAccessException x)\n+      {\n+\t  throw new InternalError(x.getMessage());\n+      }\n+  }\n+\n+  final void setLongField(Object obj, long val)\n+  {\n+      try\n+      {\n+\t  field.setLong(obj, val);\n+      }\n+      catch(IllegalAccessException x)\n+      {\n+\t  throw new InternalError(x.getMessage());\n+      }\n+  }\n+\n+  final void setFloatField(Object obj, float val)\n+  {\n+      try\n+      {\n+\t  field.setFloat(obj, val);\n+      }\n+      catch(IllegalAccessException x)\n+      {\n+\t  throw new InternalError(x.getMessage());\n+      }\n+  }\n+\n+  final void setDoubleField(Object obj, double val)\n+  {\n+      try\n+      {\n+\t  field.setDouble(obj, val);\n+      }\n+      catch(IllegalAccessException x)\n+      {\n+\t  throw new InternalError(x.getMessage());\n+      }\n+  }\n+\n+  final void setObjectField(Object obj, Object val)\n+  {\n+    try\n+      {\n+\tfield.set(obj, val);\n+      }\n+    catch(IllegalAccessException x)\n+      {\n+\tthrow new InternalError(x.getMessage());\n+      }\n+  }\n+}"}]}