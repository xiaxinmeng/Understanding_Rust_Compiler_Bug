{"sha": "bdac5f5848fbb6646b1beee01bb045a778195e73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRhYzVmNTg0OGZiYjY2NDZiMWJlZWUwMWJiMDQ1YTc3ODE5NWU3Mw==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-06-29T16:04:35Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-06-29T16:04:35Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1336", "tree": {"sha": "4d0ad94f4fb5359e4c5330300091d0cd90282f55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d0ad94f4fb5359e4c5330300091d0cd90282f55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdac5f5848fbb6646b1beee01bb045a778195e73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdac5f5848fbb6646b1beee01bb045a778195e73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdac5f5848fbb6646b1beee01bb045a778195e73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdac5f5848fbb6646b1beee01bb045a778195e73/comments", "author": null, "committer": null, "parents": [{"sha": "8194c19cbe07371c2505a4719986209b7d403650", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8194c19cbe07371c2505a4719986209b7d403650", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8194c19cbe07371c2505a4719986209b7d403650"}], "stats": {"total": 271, "additions": 267, "deletions": 4}, "files": [{"sha": "c58d03bbfd652b599ebba0d466222622a0fa89bd", "filename": "gcc/final.c", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdac5f5848fbb6646b1beee01bb045a778195e73/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdac5f5848fbb6646b1beee01bb045a778195e73/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=bdac5f5848fbb6646b1beee01bb045a778195e73", "patch": "@@ -49,6 +49,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"insn-config.h\"\n+#include \"insn-flags.h\"\n #include \"insn-attr.h\"\n #include \"insn-codes.h\"\n #include \"recog.h\"\n@@ -111,6 +112,7 @@ void output_addr_const ();\n static void output_source_line ();\n rtx final_scan_insn ();\n void profile_function ();\n+static void profile_after_prologue ();\n \n #ifdef HAVE_ATTR_length\n static int asm_insn_count ();\n@@ -689,6 +691,20 @@ final_start_function (first, file, optimize)\n     next_block_index = 1;\n #endif\n \n+  /* If the machine represents the prologue as RTL, the profiling code must\n+     be emitted when NOTE_INSN_PROLOGUE_END is scanned.  */\n+#ifdef HAVE_prologue\n+  if (! HAVE_prologue)\n+#endif\n+    profile_after_prologue (file);\n+\n+  profile_label_no++;\n+}\n+\n+static void\n+profile_after_prologue (file)\n+     FILE *file;\n+{\n #ifdef FUNCTION_BLOCK_PROFILER\n   if (profile_block_flag)\n     {\n@@ -700,8 +716,6 @@ final_start_function (first, file, optimize)\n   if (profile_flag)\n     profile_function (file);\n #endif /* not PROFILE_BEFORE_PROLOGUE */\n-\n-  profile_label_no++;\n }\n \n void\n@@ -926,6 +940,23 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n       if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n \tbreak;\n \n+      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_PROLOGUE_END)\n+\t{\n+#ifdef FUNCTION_END_PROLOGUE\n+\t  FUNCTION_END_PROLOGUE (file);\n+#endif\n+\t  profile_after_prologue (file);\n+\t  break;\n+\t}\n+\n+#ifdef FUNCTION_BEGIN_EPILOGUE\n+      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EPILOGUE_BEG)\n+\t{\n+\t  FUNCTION_BEGIN_EPILOGUE (file);\n+\t  break;\n+\t}\n+#endif\n+\n       if (write_symbols == NO_DEBUG)\n \tbreak;\n       if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n@@ -1061,7 +1092,11 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \n     case BARRIER:\n #ifdef ASM_OUTPUT_ALIGN_CODE\n-      ASM_OUTPUT_ALIGN_CODE (file);\n+      /* Don't litter the assembler output with needless alignments.  A\n+\t BARRIER will be placed at the end of every function if HAVE_epilogue\n+\t is true.  */\t \n+      if (NEXT_INSN (insn))\n+\tASM_OUTPUT_ALIGN_CODE (file);\n #endif\n       break;\n "}, {"sha": "17d30ab659ec1bd8472a4347fb8b5cd3bb9e54e2", "filename": "gcc/function.c", "status": "modified", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdac5f5848fbb6646b1beee01bb045a778195e73/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdac5f5848fbb6646b1beee01bb045a778195e73/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=bdac5f5848fbb6646b1beee01bb045a778195e73", "patch": "@@ -53,6 +53,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"insn-config.h\"\n #include \"recog.h\"\n #include \"output.h\"\n+#include \"basic-block.h\"\n \n /* Round a value to the lowest integer less than it that is a multiple of\n    the required alignment.  Avoid using division in case the value is\n@@ -4076,3 +4077,209 @@ expand_function_end (filename, line)\n      then you will lose.  */\n   fixup_gotos (0, 0, 0, get_insns (), 0);\n }\n+\f\n+/* These arrays record the INSN_UIDs of the prologue and epilogue insns.  */\n+\n+static int *prologue;\n+static int *epilogue;\n+\n+/* Create an array that records the INSN_UIDs of INSNS (either a sequence\n+   or a single insn).  */\n+\n+static int *\n+record_insns (insns)\n+     rtx insns;\n+{\n+  int *vec;\n+\n+  if (GET_CODE (insns) == SEQUENCE)\n+    {\n+      int len = XVECLEN (insns, 0);\n+      vec = (int *) oballoc ((len + 1) * sizeof (int));\n+      vec[len] = 0;\n+      while (--len >= 0)\n+\tvec[len] = INSN_UID (XVECEXP (insns, 0, len));\n+    }\n+  else\n+    {\n+      vec = (int *) oballoc (2 * sizeof (int));\n+      vec[0] = INSN_UID (insns);\n+      vec[1] = 0;\n+    }\n+  return vec;\n+}\n+\n+/* Determine whether INSN is in the array of INSN_UIDs VEC.  */\n+\n+static rtx\n+contains (insn, vec)\n+     rtx insn;\n+     int *vec;\n+{\n+  register int i, j;\n+\n+  if (GET_CODE (insn) == INSN\n+      && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+    {\n+      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+\tfor (j = 0; vec[j]; j++)\n+\t  if (INSN_UID (XVECEXP (PATTERN (insn), 0, i)) == vec[j])\n+\t    return XVECEXP (PATTERN (insn), 0, i);\n+    }\n+  else\n+    {\n+      for (j = 0; vec[j]; j++)\n+\tif (INSN_UID (insn) == vec[j])\n+\t  return insn;\n+    }\n+  return 0;\n+}\n+\n+/* Generate the prologe and epilogue RTL if the machine supports it.  Thread\n+   this into place with notes indicating where the prologue ends and where\n+   the epilogue begins.  Update the basic block information when possible.  */\n+\n+void\n+thread_prologue_and_epilogue_insns (f)\n+     rtx f;\n+{\n+#ifdef HAVE_prologue\n+  if (HAVE_prologue)\n+    {\n+      rtx head, seq, insn;\n+\n+      /* The first insn (a NOTE_INSN_DELETED) is followed by zero or more\n+\t prologue insns and a NOTE_INSN_PROLOGUE_END.  */\n+      emit_note_after (NOTE_INSN_PROLOGUE_END, f);\n+      seq = gen_prologue ();\n+      head = emit_insn_after (seq, f);\n+\n+      /* Include the new prologue insns in the first block.  Ignore them\n+\t if they form a basic block unto themselves.  */\n+      if (basic_block_head && n_basic_blocks\n+\t  && GET_CODE (basic_block_head[0]) != CODE_LABEL)\n+\tbasic_block_head[0] = NEXT_INSN (f);\n+\n+      /* Retain a map of the prologue insns.  */\n+      prologue = record_insns (GET_CODE (seq) == SEQUENCE ? seq : head);\n+    }\n+  else\n+#endif\n+    prologue = 0;\n+\n+#ifdef HAVE_epilogue\n+  if (HAVE_epilogue)\n+    {\n+      rtx insn = get_last_insn ();\n+      rtx prev = prev_nonnote_insn (insn);\n+\n+      /* If we end with a BARRIER, we don't need an epilogue.  */\n+      if (! (prev && GET_CODE (prev) == BARRIER))\n+\t{\n+\t  rtx tail, seq;\n+\n+\t  /* The last basic block ends with a NOTE_INSN_EPILOGUE_BEG,\n+\t     the epilogue insns (this must include the jump insn that\n+\t     returns), USE insns ad the end of a function, and a BARRIER.  */\n+\n+\t  emit_barrier_after (insn);\n+\n+\t  /* Place the epilogue before the USE insns at the end of a\n+\t     function.  */\n+\t  while (prev\n+\t\t && GET_CODE (prev) == INSN\n+\t\t && GET_CODE (PATTERN (prev)) == USE)\n+\t    {\n+\t      insn = PREV_INSN (prev);\n+\t      prev = prev_nonnote_insn (prev);\n+\t    }\n+\n+\t  seq = gen_epilogue ();\n+\t  tail = emit_jump_insn_after (seq, insn);\n+\t  emit_note_after (NOTE_INSN_EPILOGUE_BEG, insn);\n+\n+\t  /* Include the new epilogue insns in the last block.  Ignore\n+\t     them if they form a basic block unto themselves.  */\n+\t  if (basic_block_end && n_basic_blocks\n+\t      && GET_CODE (basic_block_end[n_basic_blocks - 1]) != JUMP_INSN)\n+\t    basic_block_end[n_basic_blocks - 1] = tail;\n+\n+\t  /* Retain a map of the epilogue insns.  */\n+\t  epilogue = record_insns (GET_CODE (seq) == SEQUENCE ? seq : tail);\n+\t  return;\n+\t}\n+    }\n+#endif\n+  epilogue = 0;\n+}\n+\n+/* Reposition the prologue-end and epilogue-begin notes after instruction\n+   scheduling and delayed branch scheduling.  */\n+\n+void\n+reposition_prologue_and_epilogue_notes (f)\n+     rtx f;\n+{\n+#if defined (HAVE_prologue) || defined (HAVE_epilogue)\n+  /* Reposition the prologue and epilogue notes.  */\n+  if (n_basic_blocks)\n+    {\n+      rtx next, prev;\n+\n+      if (prologue)\n+\t{\n+\t  register rtx insn, end_prologue;\n+\n+\t  /* From the end of the first basic block, search backward for a\n+\t     prologue insn.  */\n+\t  for (insn = NEXT_INSN (PREV_INSN (basic_block_end[0]));\n+\t       insn; insn = prev_nonnote_insn (insn))\n+\t    if (contains (insn, prologue))\n+\t      {\n+\t\tend_prologue = insn;\n+\t\t/* Find the prologue-end note and move it to just after the\n+\t\t   last prologue insn.  */\n+\t\tfor (insn = f; insn; insn = NEXT_INSN (insn))\n+\t\t  if (GET_CODE (insn) == NOTE\n+\t\t      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_PROLOGUE_END)\n+\t\t    break;\n+\t\tnext = NEXT_INSN (insn);\n+\t\tprev = PREV_INSN (insn);\n+\t\tif (prev)\n+\t\t  NEXT_INSN (prev) = next;\n+\t\tif (next)\n+\t\t  PREV_INSN (next) = prev;\n+\t\tadd_insn_after (insn, end_prologue);\n+\t\tbreak;\n+\t      }\n+\t}\n+\n+      if (epilogue)\n+\t{\n+\t  register rtx insn, beg_epilogue;\n+\n+\t  /* From the start of the last basic block, search forward for an\n+\t     epilogue insn.  */\n+\t  for (insn = PREV_INSN (NEXT_INSN (basic_block_head[n_basic_blocks - 1]));\n+\t       insn; insn = next_nonnote_insn (insn))\n+\t    if (beg_epilogue = contains (insn, epilogue))\n+\t      {\n+\t\t/* Find the epilogue-begin note and move it to just before\n+\t\t   the first epilogue insn.  */\n+\t\tfor (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n+\t\t  if (GET_CODE (insn) == NOTE\n+\t\t      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EPILOGUE_BEG)\n+\t\t    break;\n+\t\tnext = NEXT_INSN (insn);\n+\t\tprev = PREV_INSN (insn);\n+\t\tif (prev)\n+\t\t  NEXT_INSN (prev) = next;\n+\t\tif (next)\n+\t\t  PREV_INSN (next) = prev;\n+\t\tadd_insn_after (insn, PREV_INSN (beg_epilogue));\n+\t\tbreak;\n+\t      }\n+\t}\n+    }\n+#endif /* HAVE_prologue or HAVE_epilogue */\n+}"}, {"sha": "50c97c374037f7f4808204b6ec26794f4bac111a", "filename": "gcc/reorg.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdac5f5848fbb6646b1beee01bb045a778195e73/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdac5f5848fbb6646b1beee01bb045a778195e73/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=bdac5f5848fbb6646b1beee01bb045a778195e73", "patch": "@@ -3592,6 +3592,10 @@ dbr_schedule (first, file)\n   /* It is not clear why the line below is needed, but it does seem to be.  */\n   unfilled_firstobj = (rtx *) obstack_alloc (&unfilled_slots_obstack, 0);\n \n+  /* Reposition the prologue and epilogue notes in case we moved the\n+     prologue/epilogue insns.  */\n+  reposition_prologue_and_epilogue_notes (first);\n+\n   if (file)\n     {\n       register int i, j, need_comma;"}, {"sha": "8a4e98339cd211348555834ab8ce2ead50aa9b02", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdac5f5848fbb6646b1beee01bb045a778195e73/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdac5f5848fbb6646b1beee01bb045a778195e73/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=bdac5f5848fbb6646b1beee01bb045a778195e73", "patch": "@@ -169,7 +169,8 @@ char *note_insn_name[] = { \"NOTE_INSN_FUNCTION_BEG\", \"NOTE_INSN_DELETED\",\n \t\t\t   \"NOTE_INSN_BLOCK_BEG\", \"NOTE_INSN_BLOCK_END\",\n \t\t\t   \"NOTE_INSN_LOOP_BEG\", \"NOTE_INSN_LOOP_END\",\n \t\t\t   \"NOTE_INSN_FUNCTION_END\", \"NOTE_INSN_SETJMP\",\n-\t\t\t   \"NOTE_INSN_LOOP_CONT\", \"NOTE_INSN_LOOP_VTOP\" };\n+\t\t\t   \"NOTE_INSN_LOOP_CONT\", \"NOTE_INSN_LOOP_VTOP\",\n+\t\t\t   \"NOTE_INSN_PROLOGUE_END\", \"NOTE_INSN_EPILOGUE_BEG\" };\n \n char *reg_note_name[] = { \"\", \"REG_DEAD\", \"REG_INC\", \"REG_EQUIV\", \"REG_WAS_0\",\n \t\t\t  \"REG_EQUAL\", \"REG_RETVAL\", \"REG_LIBCALL\","}, {"sha": "f1a1a7fa8a26d0304f2024f0adfe570b46cc7103", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdac5f5848fbb6646b1beee01bb045a778195e73/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdac5f5848fbb6646b1beee01bb045a778195e73/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=bdac5f5848fbb6646b1beee01bb045a778195e73", "patch": "@@ -336,6 +336,10 @@ extern char *reg_note_name[];\n #define NOTE_INSN_LOOP_CONT -8\n /* Generated at the start of a duplicated exit test.  */\n #define NOTE_INSN_LOOP_VTOP -9\n+/* This marks the point immediately after the last prologue insn.  */\n+#define NOTE_INSN_PROLOGUE_END -10\n+/* This marks the point immediately prior to the first epilogue insn.  */\n+#define NOTE_INSN_EPILOGUE_BEG -11\n /* Don't forget to change note_insn_name in rtl.c.  */\n \n #define NOTE_DECL_NAME(INSN) ((INSN)->fld[3].rtstr)"}, {"sha": "937d9e3a8ecf9e46a31c4e0eab1a08cbddbbbf43", "filename": "gcc/sched.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdac5f5848fbb6646b1beee01bb045a778195e73/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdac5f5848fbb6646b1beee01bb045a778195e73/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=bdac5f5848fbb6646b1beee01bb045a778195e73", "patch": "@@ -3949,6 +3949,11 @@ schedule_insns (dump_file)\n #endif\n     }\n \n+  /* Reposition the prologue and epilogue notes in case we moved the\n+     prologue/epilogue insns.  */\n+  if (reload_completed)\n+    reposition_prologue_and_epilogue_notes (get_insns ());\n+\n   if (write_symbols != NO_DEBUG)\n     {\n       rtx line = 0;"}, {"sha": "4614d1bc678567d5abe82265b89adf248e2c6cad", "filename": "gcc/toplev.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdac5f5848fbb6646b1beee01bb045a778195e73/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdac5f5848fbb6646b1beee01bb045a778195e73/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=bdac5f5848fbb6646b1beee01bb045a778195e73", "patch": "@@ -2368,6 +2368,13 @@ rest_of_compilation (decl)\n \n   reload_completed = 1;\n \n+  /* On some machines, the prologue and epilogue code, or parts thereof,\n+     can be represented as RTL.  Doing so lets us schedule insns between\n+     it and the rest of the code and also allows delayed branch\n+     scheduling to operate in the epilogue.  */\n+\n+  thread_prologue_and_epilogue_insns (insns);\n+\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n     {\n       if (sched2_dump)"}]}