{"sha": "135f54eb848abc87511894692ee47866ebed247d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM1ZjU0ZWI4NDhhYmM4NzUxMTg5NDY5MmVlNDc4NjZlYmVkMjQ3ZA==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2004-01-25T13:08:08Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-01-25T13:08:08Z"}, "message": "Class.java: Imports reworked, reformated.\n\n2004-01-25  Michael Koch  <konqueror@gmx.de>\n\n\t* java/lang/Class.java: Imports reworked, reformated.\n\t(Class): Javadoc added.\n\t(forName): Likewise.\n\t(getClasses): Likewise.\n\t(getClassLoader): Likewise.\n\t(getComponentType): Likewise.\n\t(getConstructor): Likewise.\n\t(getConstructors): Likewise.\n\t(getDeclaredConstructor): Likewise.\n\t(getDeclaredClasses): Likewise.\n\t(getDeclaredConstructors): Likewise.\n\t(getDeclaredField): Likewise.\n\t(getDeclaredMethod): Likewise.\n\t(getDeclaredMethods): Likewise.\n\t(getDeclaringClass): Likewise.\n\t(getField): Likewise.\n\t(getInterfaces): Likewise.\n\t(getMethod): Likewise.\n\t(getMethods): Likewise.\n\t(getModifiers): Likewise.\n\t(getName): Likewise.\n\t(getResource): Likewise.\n\t(getResourceAsStream): Likewise.\n\t(getSigners): Likewise.\n\t(setSigners): Likewise.\n\t(getSuperclass): Likewise.\n\t(isArray): Likewise.\n\t(isAssignableFrom): Likewise.\n\t(isInstance): Likewise.\n\t(isInterface): Likewise.\n\t(isPrimitive): Likewise.\n\t(newInstance): Likewise.\n\t(getProtectionDomain): Likewise.\n\t(toString): Likewise.\n\t(Class): Moved.\n\t(initializeClass): Likewise.\n\t(finalize): Likewise.\n\nFrom-SVN: r76554", "tree": {"sha": "455345e72bda30ca53af3e05702593050a78a1d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/455345e72bda30ca53af3e05702593050a78a1d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/135f54eb848abc87511894692ee47866ebed247d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/135f54eb848abc87511894692ee47866ebed247d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/135f54eb848abc87511894692ee47866ebed247d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/135f54eb848abc87511894692ee47866ebed247d/comments", "author": null, "committer": null, "parents": [{"sha": "e6d8312885dab0589b31eb3c0a88d2c1414222f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6d8312885dab0589b31eb3c0a88d2c1414222f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6d8312885dab0589b31eb3c0a88d2c1414222f1"}], "stats": {"total": 676, "additions": 583, "deletions": 93}, "files": [{"sha": "a0b607a4f72f76bdecdd27ad22b6c55bf33c93b1", "filename": "libjava/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135f54eb848abc87511894692ee47866ebed247d/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135f54eb848abc87511894692ee47866ebed247d/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=135f54eb848abc87511894692ee47866ebed247d", "patch": "@@ -1,3 +1,43 @@\n+2004-01-25  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/lang/Class.java: Imports reworked, reformated.\n+\t(Class): Javadoc added.\n+\t(forName): Likewise.\n+\t(getClasses): Likewise.\n+\t(getClassLoader): Likewise.\n+\t(getComponentType): Likewise.\n+\t(getConstructor): Likewise.\n+\t(getConstructors): Likewise.\n+\t(getDeclaredConstructor): Likewise.\n+\t(getDeclaredClasses): Likewise.\n+\t(getDeclaredConstructors): Likewise.\n+\t(getDeclaredField): Likewise.\n+\t(getDeclaredMethod): Likewise.\n+\t(getDeclaredMethods): Likewise.\n+\t(getDeclaringClass): Likewise.\n+\t(getField): Likewise.\n+\t(getInterfaces): Likewise.\n+\t(getMethod): Likewise.\n+\t(getMethods): Likewise.\n+\t(getModifiers): Likewise.\n+\t(getName): Likewise.\n+\t(getResource): Likewise.\n+\t(getResourceAsStream): Likewise.\n+\t(getSigners): Likewise.\n+\t(setSigners): Likewise.\n+\t(getSuperclass): Likewise.\n+\t(isArray): Likewise.\n+\t(isAssignableFrom): Likewise.\n+\t(isInstance): Likewise.\n+\t(isInterface): Likewise.\n+\t(isPrimitive): Likewise.\n+\t(newInstance): Likewise.\n+\t(getProtectionDomain): Likewise.\n+\t(toString): Likewise.\n+\t(Class): Moved.\n+\t(initializeClass): Likewise.\n+\t(finalize): Likewise.\n+\n 2004-01-24  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/net/protocol/jar/Connection.java\n@@ -43,6 +83,7 @@\n 2004-01-23  Michael Koch  <konqueror@gmx.de>\n \n \t* java/lang/VMClassLoader.java: Reworked imports.\n+\t\n 2004-01-23  Michael Koch  <konqueror@gmx.de>\n \n \t* javax/swing/AbstractAction.java: Reformated."}, {"sha": "0d61b5e4dbfb9474ed0079158df197133013b322", "filename": "libjava/java/lang/Class.java", "status": "modified", "additions": 542, "deletions": 93, "changes": 635, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135f54eb848abc87511894692ee47866ebed247d/libjava%2Fjava%2Flang%2FClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135f54eb848abc87511894692ee47866ebed247d/libjava%2Fjava%2Flang%2FClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.java?ref=135f54eb848abc87511894692ee47866ebed247d", "patch": "@@ -38,62 +38,247 @@\n \n package java.lang;\n \n-import java.io.Serializable;\n import java.io.InputStream;\n-import java.lang.reflect.*;\n-import java.security.*;\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.security.ProtectionDomain;\n import java.util.Arrays;\n import java.util.HashSet;\n \n /**\n+ * A Class represents a Java type.  There will never be multiple Class\n+ * objects with identical names and ClassLoaders. Primitive types, array\n+ * types, and void also have a Class object.\n+ *\n+ * <p>Arrays with identical type and number of dimensions share the same\n+ * class (and null \"system\" ClassLoader, incidentally).  The name of an\n+ * array class is <code>[&lt;signature format&gt;;</code> ... for example,\n+ * String[]'s class is <code>[Ljava.lang.String;</code>. boolean, byte,\n+ * short, char, int, long, float and double have the \"type name\" of\n+ * Z,B,S,C,I,J,F,D for the purposes of array classes.  If it's a\n+ * multidimensioned array, the same principle applies:\n+ * <code>int[][][]</code> == <code>[[[I</code>.\n+ *\n+ * <p>There is no public constructor - Class objects are obtained only through\n+ * the virtual machine, as defined in ClassLoaders.\n+ *\n+ * @serialData Class objects serialize specially:\n+ * <code>TC_CLASS ClassDescriptor</code>. For more serialization information,\n+ * see {@link ObjectStreamClass}.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n  * @author Tom Tromey <tromey@cygnus.com>\n- * @date October 1, 1998 \n- */\n-\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * plus gcj compiler sources (to determine object layout)\n- * Status:  Sufficient for our purposes, but some methods missing\n- * and some not implemented.\n+ * @since 1.0\n+ * @see ClassLoader\n  */\n-\n public final class Class implements Serializable\n {\n+  /**\n+   * Class is non-instantiable from Java code; only the VM can create\n+   * instances of this class.\n+   */\n+  private Class ()\n+  {\n+  }\n+\n+  // Initialize the class.\n+  private native void initializeClass ();\n+\n+  // finalization\n+  protected native void finalize () throws Throwable;\n+\n+  /**\n+   * Use the classloader of the current class to load, link, and initialize\n+   * a class. This is equivalent to your code calling\n+   * <code>Class.forName(name, true, getClass().getClassLoader())</code>.\n+   *\n+   * @param name the name of the class to find\n+   * @return the Class object representing the class\n+   * @throws ClassNotFoundException if the class was not found by the\n+   *         classloader\n+   * @throws LinkageError if linking the class fails\n+   * @throws ExceptionInInitializerError if the class loads, but an exception\n+   *         occurs during initialization\n+   */\n   public static native Class forName (String className)\n     throws ClassNotFoundException;\n-  /** @since 1.2 */\n+\n+  /**\n+   * Use the specified classloader to load and link a class. If the loader\n+   * is null, this uses the bootstrap class loader (provide the security\n+   * check succeeds). Unfortunately, this method cannot be used to obtain\n+   * the Class objects for primitive types or for void, you have to use\n+   * the fields in the appropriate java.lang wrapper classes.\n+   *\n+   * <p>Calls <code>classloader.loadclass(name, initialize)</code>.\n+   *\n+   * @param name the name of the class to find\n+   * @param initialize whether or not to initialize the class at this time\n+   * @param classloader the classloader to use to find the class; null means\n+   *        to use the bootstrap class loader\n+   * @throws ClassNotFoundException if the class was not found by the\n+   *         classloader\n+   * @throws LinkageError if linking the class fails\n+   * @throws ExceptionInInitializerError if the class loads, but an exception\n+   *         occurs during initialization\n+   * @throws SecurityException if the <code>classloader</code> argument\n+   *         is <code>null</code> and the caller does not have the\n+   *         <code>RuntimePermission(\"getClassLoader\")</code> permission\n+   * @see ClassLoader\n+   * @since 1.2\n+   */\n   public static native Class forName (String className, boolean initialize,\n \t\t\t\t      ClassLoader loader)\n     throws ClassNotFoundException;\n+  \n+  /**\n+   * Get all the public member classes and interfaces declared in this\n+   * class or inherited from superclasses. This returns an array of length\n+   * 0 if there are no member classes, including for primitive types. A\n+   * security check may be performed, with\n+   * <code>checkMemberAccess(this, Member.PUBLIC)</code> as well as\n+   * <code>checkPackageAccess</code> both having to succeed.\n+   *\n+   * @return all public member classes in this class\n+   * @throws SecurityException if the security check fails\n+   * @since 1.1\n+   */\n   public native Class[] getClasses ();\n+  \n+  /**\n+   * Get the ClassLoader that loaded this class.  If it was loaded by the\n+   * system classloader, this method will return null. If there is a security\n+   * manager, and the caller's class loader does not match the requested\n+   * one, a security check of <code>RuntimePermission(\"getClassLoader\")</code>\n+   * must first succeed. Primitive types and void return null.\n+   *\n+   * @return the ClassLoader that loaded this class\n+   * @throws SecurityException if the security check fails\n+   * @see ClassLoader\n+   * @see RuntimePermission\n+   */\n   public native ClassLoader getClassLoader ();\n+  \n+  /**\n+   * If this is an array, get the Class representing the type of array.\n+   * Examples: \"[[Ljava.lang.String;\" would return \"[Ljava.lang.String;\", and\n+   * calling getComponentType on that would give \"java.lang.String\".  If\n+   * this is not an array, returns null.\n+   *\n+   * @return the array type of this class, or null\n+   * @see Array\n+   * @since 1.1\n+   */\n   public native Class getComponentType ();\n \n-  public native Constructor getConstructor (Class[] parameterTypes)\n+  /**\n+   * Get a public constructor declared in this class. If the constructor takes\n+   * no argument, an array of zero elements and null are equivalent for the\n+   * types argument. A security check may be performed, with\n+   * <code>checkMemberAccess(this, Member.PUBLIC)</code> as well as\n+   * <code>checkPackageAccess</code> both having to succeed.\n+   *\n+   * @param types the type of each parameter\n+   * @return the constructor\n+   * @throws NoSuchMethodException if the constructor does not exist\n+   * @throws SecurityException if the security check fails\n+   * @see #getConstructors()\n+   * @since 1.1\n+   */\n+  public native Constructor getConstructor(Class[] args)\n     throws NoSuchMethodException, SecurityException;\n \n   // This is used to implement getConstructors and\n   // getDeclaredConstructors.\n   private native Constructor[] _getConstructors (boolean declared)\n     throws SecurityException;\n \n-  public Constructor[] getConstructors () throws SecurityException\n+  /**\n+   * Get all the public constructors of this class. This returns an array of\n+   * length 0 if there are no constructors, including for primitive types,\n+   * arrays, and interfaces. It does, however, include the default\n+   * constructor if one was supplied by the compiler. A security check may\n+   * be performed, with <code>checkMemberAccess(this, Member.PUBLIC)</code>\n+   * as well as <code>checkPackageAccess</code> both having to succeed.\n+   *\n+   * @return all public constructors in this class\n+   * @throws SecurityException if the security check fails\n+   * @since 1.1\n+   */\n+  public Constructor[] getConstructors()\n+    throws SecurityException\n   {\n-    return _getConstructors (false);\n+    return _getConstructors(false);\n   }\n \n-  public native Constructor getDeclaredConstructor (Class[] parameterTypes)\n+  /**\n+   * Get a constructor declared in this class. If the constructor takes no\n+   * argument, an array of zero elements and null are equivalent for the\n+   * types argument. A security check may be performed, with\n+   * <code>checkMemberAccess(this, Member.DECLARED)</code> as well as\n+   * <code>checkPackageAccess</code> both having to succeed.\n+   *\n+   * @param types the type of each parameter\n+   * @return the constructor\n+   * @throws NoSuchMethodException if the constructor does not exist\n+   * @throws SecurityException if the security check fails\n+   * @see #getDeclaredConstructors()\n+   * @since 1.1\n+   */\n+  public native Constructor getDeclaredConstructor(Class[] args)\n     throws NoSuchMethodException, SecurityException;\n \n-  public native Class[] getDeclaredClasses () throws SecurityException;\n+  /**\n+   * Get all the declared member classes and interfaces in this class, but\n+   * not those inherited from superclasses. This returns an array of length\n+   * 0 if there are no member classes, including for primitive types. A\n+   * security check may be performed, with\n+   * <code>checkMemberAccess(this, Member.DECLARED)</code> as well as\n+   * <code>checkPackageAccess</code> both having to succeed.\n+   *\n+   * @return all declared member classes in this class\n+   * @throws SecurityException if the security check fails\n+   * @since 1.1\n+   */\n+  public native Class[] getDeclaredClasses() throws SecurityException;\n \n-  public Constructor[] getDeclaredConstructors () throws SecurityException\n+  /**\n+   * Get all the declared constructors of this class. This returns an array of\n+   * length 0 if there are no constructors, including for primitive types,\n+   * arrays, and interfaces. It does, however, include the default\n+   * constructor if one was supplied by the compiler. A security check may\n+   * be performed, with <code>checkMemberAccess(this, Member.DECLARED)</code>\n+   * as well as <code>checkPackageAccess</code> both having to succeed.\n+   *\n+   * @return all constructors in this class\n+   * @throws SecurityException if the security check fails\n+   * @since 1.1\n+   */\n+  public Constructor[] getDeclaredConstructors()\n+    throws SecurityException\n   {\n-    return _getConstructors (true);\n+    return _getConstructors(true);\n   }\n \n-  public native Field getDeclaredField (String fieldName)\n+  /**\n+   * Get a field declared in this class, where name is its simple name. The\n+   * implicit length field of arrays is not available. A security check may\n+   * be performed, with <code>checkMemberAccess(this, Member.DECLARED)</code>\n+   * as well as <code>checkPackageAccess</code> both having to succeed.\n+   *\n+   * @param name the name of the field\n+   * @return the field\n+   * @throws NoSuchFieldException if the field does not exist\n+   * @throws SecurityException if the security check fails\n+   * @see #getDeclaredFields()\n+   * @since 1.1\n+   */\n+  public native Field getDeclaredField(String fieldName)\n     throws NoSuchFieldException, SecurityException;\n \n   /**\n@@ -116,39 +301,97 @@ public Field[] getDeclaredFields()\n \n   native Field[] getDeclaredFields (boolean publicOnly);\n \n-  private native Method _getDeclaredMethod (String methodName,\n-\t\t\t\t\t    Class[] parameterTypes);\n+  private native Method _getDeclaredMethod(String methodName, Class[] args);\n \n-  public Method getDeclaredMethod (String methodName, Class[] parameterTypes)\n+  /**\n+   * Get a method declared in this class, where name is its simple name. The\n+   * implicit methods of Object are not available from arrays or interfaces.\n+   * Constructors (named \"<init>\" in the class file) and class initializers\n+   * (name \"<clinit>\") are not available.  The Virtual Machine allows\n+   * multiple methods with the same signature but differing return types; in\n+   * such a case the most specific return types are favored, then the final\n+   * choice is arbitrary. If the method takes no argument, an array of zero\n+   * elements and null are equivalent for the types argument. A security\n+   * check may be performed, with\n+   * <code>checkMemberAccess(this, Member.DECLARED)</code> as well as\n+   * <code>checkPackageAccess</code> both having to succeed.\n+   *\n+   * @param methodName the name of the method\n+   * @param types the type of each parameter\n+   * @return the method\n+   * @throws NoSuchMethodException if the method does not exist\n+   * @throws SecurityException if the security check fails\n+   * @see #getDeclaredMethods()\n+   * @since 1.1\n+   */\n+  public Method getDeclaredMethod(String methodName, Class[] args)\n     throws NoSuchMethodException, SecurityException\n   {\n     memberAccessCheck(Member.DECLARED);\n \n     if (\"<init>\".equals(methodName) || \"<clinit>\".equals(methodName))\n       throw new NoSuchMethodException(methodName);\n \n-    Method m = _getDeclaredMethod(methodName, parameterTypes);\n-    if (m == null)\n-      throw new NoSuchMethodException (methodName);\n-    return m;\n+    Method match = _getDeclaredMethod(methodName, args);\n+    if (match == null)\n+      throw new NoSuchMethodException(methodName);\n+    return match;\n   }\n \n+  /**\n+   * Get all the declared methods in this class, but not those inherited from\n+   * superclasses. This returns an array of length 0 if there are no methods,\n+   * including for primitive types. This does include the implicit methods of\n+   * arrays and interfaces which mirror methods of Object, nor does it\n+   * include constructors or the class initialization methods. The Virtual\n+   * Machine allows multiple methods with the same signature but differing\n+   * return types; all such methods are in the returned array. A security\n+   * check may be performed, with\n+   * <code>checkMemberAccess(this, Member.DECLARED)</code> as well as\n+   * <code>checkPackageAccess</code> both having to succeed.\n+   *\n+   * @return all declared methods in this class\n+   * @throws SecurityException if the security check fails\n+   * @since 1.1\n+   */\n   public native Method[] getDeclaredMethods () throws SecurityException;\n-\n+ \n+  /**\n+   * If this is a nested or inner class, return the class that declared it.\n+   * If not, return null.\n+   *\n+   * @return the declaring class of this class\n+   * @since 1.1\n+   */\n   // This is marked as unimplemented in the JCL book.\n   public native Class getDeclaringClass ();\n \n   private native Field getField (String fieldName, int hash)\n     throws NoSuchFieldException, SecurityException;\n \n-  public Field getField (String fieldName)\n+  /**\n+   * Get a public field declared or inherited in this class, where name is\n+   * its simple name. If the class contains multiple accessible fields by\n+   * that name, an arbitrary one is returned. The implicit length field of\n+   * arrays is not available. A security check may be performed, with\n+   * <code>checkMemberAccess(this, Member.PUBLIC)</code> as well as\n+   * <code>checkPackageAccess</code> both having to succeed.\n+   *\n+   * @param fieldName the name of the field\n+   * @return the field\n+   * @throws NoSuchFieldException if the field does not exist\n+   * @throws SecurityException if the security check fails\n+   * @see #getFields()\n+   * @since 1.1\n+   */\n+  public Field getField(String fieldName)\n     throws NoSuchFieldException, SecurityException\n   {\n-    memberAccessCheck (Member.PUBLIC);\n-    Field fld = getField(fieldName, fieldName.hashCode());\n-    if (fld == null)\n+    memberAccessCheck(Member.PUBLIC);\n+    Field field = getField(fieldName, fieldName.hashCode());\n+    if (field == null)\n       throw new NoSuchFieldException(fieldName);\n-    return fld;\n+    return field;\n   }\n \n   /**\n@@ -191,6 +434,7 @@ private Field[] internalGetFields()\n    * classloader of this class or when the classloader of this class\n    * is null.\n    *\n+   * @return the package for this class, if it is available\n    * @since 1.2\n    */\n   public Package getPackage()\n@@ -205,84 +449,292 @@ public Package getPackage()\n \t  pkg = name.substring(0, idx);\n \treturn cl.getPackage(pkg);\n       }\n-    else\n-      return null;\n+    return null;\n   }\n \n+  /**\n+   * Get the interfaces this class <em>directly</em> implements, in the\n+   * order that they were declared. This returns an empty array, not null,\n+   * for Object, primitives, void, and classes or interfaces with no direct\n+   * superinterface. Array types return Cloneable and Serializable.\n+   *\n+   * @return the interfaces this class directly implements\n+   */\n   public native Class[] getInterfaces ();\n \n-  private final native void getSignature (StringBuffer buffer);\n-  private static final native String getSignature (Class[] parameterTypes,\n-\t\t\t\t\t\t   boolean is_construtor);\n+  private final native void getSignature(StringBuffer buffer);\n+  private static final native String getSignature(Class[] args,\n+\t\t\t\t\t\t  boolean is_construtor);\n \n-  public native Method _getMethod (String methodName, Class[] parameterTypes);\n+  public native Method _getMethod(String methodName, Class[] args);\n \n-  public Method getMethod (String methodName, Class[] parameterTypes)\n+  /**\n+   * Get a public method declared or inherited in this class, where name is\n+   * its simple name. The implicit methods of Object are not available from\n+   * interfaces.  Constructors (named \"<init>\" in the class file) and class\n+   * initializers (name \"<clinit>\") are not available.  The Virtual\n+   * Machine allows multiple methods with the same signature but differing\n+   * return types, and the class can inherit multiple methods of the same\n+   * return type; in such a case the most specific return types are favored,\n+   * then the final choice is arbitrary. If the method takes no argument, an\n+   * array of zero elements and null are equivalent for the types argument.\n+   * A security check may be performed, with\n+   * <code>checkMemberAccess(this, Member.PUBLIC)</code> as well as\n+   * <code>checkPackageAccess</code> both having to succeed.\n+   *\n+   * @param methodName the name of the method\n+   * @param types the type of each parameter\n+   * @return the method\n+   * @throws NoSuchMethodException if the method does not exist\n+   * @throws SecurityException if the security check fails\n+   * @see #getMethods()\n+   * @since 1.1\n+   */\n+  public Method getMethod(String methodName, Class[] args)\n     throws NoSuchMethodException, SecurityException\n   {\n     memberAccessCheck(Member.PUBLIC);\n \n     if (\"<init>\".equals(methodName) || \"<clinit>\".equals(methodName))\n       throw new NoSuchMethodException(methodName);\n \n-    Method m = _getMethod(methodName, parameterTypes);\n-    if (m == null)\n-      throw new NoSuchMethodException (methodName);\n-    return m;\n+    Method method = _getMethod(methodName, args);\n+    if (method == null)\n+      throw new NoSuchMethodException(methodName);\n+    return method;\n   }\n \n   private native int _getMethods (Method[] result, int offset);\n+  \n+  /**\n+   * Get all the public methods declared in this class or inherited from\n+   * superclasses. This returns an array of length 0 if there are no methods,\n+   * including for primitive types. This does not include the implicit\n+   * methods of interfaces which mirror methods of Object, nor does it\n+   * include constructors or the class initialization methods. The Virtual\n+   * Machine allows multiple methods with the same signature but differing\n+   * return types; all such methods are in the returned array. A security\n+   * check may be performed, with\n+   * <code>checkMemberAccess(this, Member.PUBLIC)</code> as well as\n+   * <code>checkPackageAccess</code> both having to succeed.\n+   *\n+   * @return all public methods in this class\n+   * @throws SecurityException if the security check fails\n+   * @since 1.1\n+   */\n   public native Method[] getMethods () throws SecurityException;\n \n+  /**\n+   * Get the modifiers of this class.  These can be decoded using Modifier,\n+   * and is limited to one of public, protected, or private, and any of\n+   * final, static, abstract, or interface. An array class has the same\n+   * public, protected, or private modifier as its component type, and is\n+   * marked final but not an interface. Primitive types and void are marked\n+   * public and final, but not an interface.\n+   *\n+   * @return the modifiers of this class\n+   * @see Modifer\n+   * @since 1.1\n+   */\n   public native int getModifiers ();\n+  \n+  /**\n+   * Get the name of this class, separated by dots for package separators.\n+   * Primitive types and arrays are encoded as:\n+   * <pre>\n+   * boolean             Z\n+   * byte                B\n+   * char                C\n+   * short               S\n+   * int                 I\n+   * long                J\n+   * float               F\n+   * double              D\n+   * void                V\n+   * array type          [<em>element type</em>\n+   * class or interface, alone: &lt;dotted name&gt;\n+   * class or interface, as element type: L&lt;dotted name&gt;;\n+   *\n+   * @return the name of this class\n+   */\n   public native String getName ();\n \n-  public java.net.URL getResource (String resourceName)\n+  /**\n+   * Get a resource URL using this class's package using the\n+   * getClassLoader().getResource() method.  If this class was loaded using\n+   * the system classloader, ClassLoader.getSystemResource() is used instead.\n+   *\n+   * <p>If the name you supply is absolute (it starts with a <code>/</code>),\n+   * then it is passed on to getResource() as is.  If it is relative, the\n+   * package name is prepended, and <code>.</code>'s are replaced with\n+   * <code>/</code>.\n+   *\n+   * <p>The URL returned is system- and classloader-dependent, and could\n+   * change across implementations.\n+   *\n+   * @param resourceName the name of the resource, generally a path\n+   * @return the URL to the resource\n+   * @throws NullPointerException if name is null\n+   * @since 1.1\n+   */\n+  public URL getResource(String resourceName)\n   {\n-    String name = resourcePath (resourceName);\n-    ClassLoader loader = getClassLoader ();\n+    String name = resourcePath(resourceName);\n+    ClassLoader loader = getClassLoader();\n     if (loader == null)\n-      return ClassLoader.getSystemResource (name);\n-    else\n-      return loader.getResource (name);\n+      return ClassLoader.getSystemResource(name);\n+    return loader.getResource(name);\n   }\n \n-  public java.io.InputStream getResourceAsStream (String resourceName)\n+  /**\n+   * Get a resource using this class's package using the\n+   * getClassLoader().getResourceAsStream() method.  If this class was loaded\n+   * using the system classloader, ClassLoader.getSystemResource() is used\n+   * instead.\n+   *\n+   * <p>If the name you supply is absolute (it starts with a <code>/</code>),\n+   * then it is passed on to getResource() as is.  If it is relative, the\n+   * package name is prepended, and <code>.</code>'s are replaced with\n+   * <code>/</code>.\n+   *\n+   * <p>The URL returned is system- and classloader-dependent, and could\n+   * change across implementations.\n+   *\n+   * @param resourceName the name of the resource, generally a path\n+   * @return an InputStream with the contents of the resource in it, or null\n+   * @throws NullPointerException if name is null\n+   * @since 1.1\n+   */\n+  public InputStream getResourceAsStream(String resourceName)\n   {\n-    String name = resourcePath (resourceName);\n-    ClassLoader loader = getClassLoader ();\n+    String name = resourcePath(resourceName);\n+    ClassLoader loader = getClassLoader();\n     if (loader == null)\n-      return ClassLoader.getSystemResourceAsStream (name);\n-    else\n-      return loader.getResourceAsStream (name);\n+      return ClassLoader.getSystemResourceAsStream(name);\n+    return loader.getResourceAsStream(name);\n   }\n \n-  private String resourcePath (String resourceName)\n+  private String resourcePath(String resourceName)\n   {\n-    if (resourceName.startsWith (\"/\"))\n-      return resourceName.substring (1);\n+    if (resourceName.startsWith(\"/\"))\n+      return resourceName.substring(1);\n \n     Class c = this;\n-    while (c.isArray ())\n-      c = c.getComponentType ();\n-\n-    String packageName = c.getName ().replace ('.', '/');\n-    int end = packageName.lastIndexOf ('/');\n-    if (end == -1)\n-      return resourceName;\n-    else\n-      return packageName.substring (0, end+1) + resourceName;\n+    while (c.isArray())\n+      c = c.getComponentType();\n+\n+    String packageName = c.getName().replace('.', '/');\n+    int end = packageName.lastIndexOf('/');\n+    if (end != -1)\n+      return packageName.substring(0, end + 1) + resourceName;\n+    return resourceName;\n   }\n \n+  /**\n+   * Get the signers of this class. This returns null if there are no signers,\n+   * such as for primitive types or void.\n+   *\n+   * @return the signers of this class\n+   * @since 1.1\n+   */\n   public native Object[] getSigners ();\n+  \n+  /**\n+   * Set the signers of this class.\n+   *\n+   * @param signers the signers of this class\n+   */\n   native void setSigners(Object[] signers);\n \n+  /**\n+   * Get the direct superclass of this class.  If this is an interface,\n+   * Object, a primitive type, or void, it will return null. If this is an\n+   * array type, it will return Object.\n+   *\n+   * @return the direct superclass of this class\n+   */\n   public native Class getSuperclass ();\n+  \n+  /**\n+   * Return whether this class is an array type.\n+   *\n+   * @return whether this class is an array type\n+   * @since 1.1\n+   */\n   public native boolean isArray ();\n-  public native boolean isAssignableFrom (Class cls);\n-  public native boolean isInstance (Object obj);\n+  \n+  /**\n+   * Discover whether an instance of the Class parameter would be an\n+   * instance of this Class as well.  Think of doing\n+   * <code>isInstance(c.newInstance())</code> or even\n+   * <code>c.newInstance() instanceof (this class)</code>. While this\n+   * checks widening conversions for objects, it must be exact for primitive\n+   * types.\n+   *\n+   * @param c the class to check\n+   * @return whether an instance of c would be an instance of this class\n+   *         as well\n+   * @throws NullPointerException if c is null\n+   * @since 1.1\n+   */\n+  public native boolean isAssignableFrom (Class c);\n+ \n+  /**\n+   * Discover whether an Object is an instance of this Class.  Think of it\n+   * as almost like <code>o instanceof (this class)</code>.\n+   *\n+   * @param o the Object to check\n+   * @return whether o is an instance of this class\n+   * @since 1.1\n+   */\n+  public native boolean isInstance (Object o);\n+  \n+  /**\n+   * Check whether this class is an interface or not.  Array types are not\n+   * interfaces.\n+   *\n+   * @return whether this class is an interface or not\n+   */\n   public native boolean isInterface ();\n+  \n+  /**\n+   * Return whether this class is a primitive type.  A primitive type class\n+   * is a class representing a kind of \"placeholder\" for the various\n+   * primitive types, or void.  You can access the various primitive type\n+   * classes through java.lang.Boolean.TYPE, java.lang.Integer.TYPE, etc.,\n+   * or through boolean.class, int.class, etc.\n+   *\n+   * @return whether this class is a primitive type\n+   * @see Boolean#TYPE\n+   * @see Byte#TYPE\n+   * @see Character#TYPE\n+   * @see Short#TYPE\n+   * @see Integer#TYPE\n+   * @see Long#TYPE\n+   * @see Float#TYPE\n+   * @see Double#TYPE\n+   * @see Void#TYPE\n+   * @since 1.1\n+   */\n   public native boolean isPrimitive ();\n+  \n+  /**\n+   * Get a new instance of this class by calling the no-argument constructor.\n+   * The class is initialized if it has not been already. A security check\n+   * may be performed, with <code>checkMemberAccess(this, Member.PUBLIC)</code>\n+   * as well as <code>checkPackageAccess</code> both having to succeed.\n+   *\n+   * @return a new instance of this class\n+   * @throws InstantiationException if there is not a no-arg constructor\n+   *         for this class, including interfaces, abstract classes, arrays,\n+   *         primitive types, and void; or if an exception occurred during\n+   *         the constructor\n+   * @throws IllegalAccessException if you are not allowed to access the\n+   *         no-arg constructor because of scoping reasons\n+   * @throws SecurityException if the security check fails\n+   * @throws ExceptionInInitializerError if class initialization caused by\n+   *         this call fails with an exception\n+   */\n   public native Object newInstance ()\n     throws InstantiationException, IllegalAccessException;\n \n@@ -291,14 +743,15 @@ public native Object newInstance ()\n   private native ProtectionDomain getProtectionDomain0();\n \n   /**\n-   * Returns the protection domain of this class. If the classloader\n-   * did not record the protection domain when creating this class\n-   * the unknown protection domain is returned which has a <code>null</code>\n-   * code source and all permissions.\n+   * Returns the protection domain of this class. If the classloader did not\n+   * record the protection domain when creating this class the unknown\n+   * protection domain is returned which has a <code>null</code> code source\n+   * and all permissions.\n    *\n-   * @exception SecurityException if a security manager exists and the caller\n+   * @return the protection domain\n+   * @throws SecurityException if the security manager exists and the caller\n    * does not have <code>RuntimePermission(\"getProtectionDomain\")</code>.\n-   *\n+   * @see RuntimePermission\n    * @since 1.2\n    */\n   public ProtectionDomain getProtectionDomain()\n@@ -315,11 +768,18 @@ public ProtectionDomain getProtectionDomain()\n       return protectionDomain;\n   }\n \n-  public String toString ()\n+  /**\n+   * Return the human-readable form of this Object.  For an object, this\n+   * is either \"interface \" or \"class \" followed by <code>getName()</code>,\n+   * for primitive types and void it is just <code>getName()</code>.\n+   *\n+   * @return the human-readable form of this Object\n+   */\n+  public String toString()\n   {\n-    if (isPrimitive ())\n-      return getName ();\n-    return (isInterface () ? \"interface \" : \"class \") + getName ();\n+    if (isPrimitive())\n+      return getName();\n+    return (isInterface() ? \"interface \" : \"class \") + getName();\n   }\n \n   /**\n@@ -391,17 +851,6 @@ public boolean desiredAssertionStatus()\n     return c.defaultAssertionStatus;\n   }\n \n-  // Don't allow new classes to be made.\n-  private Class ()\n-  {\n-  }\n-\n-  // Initialize the class.\n-  private native void initializeClass ();\n-\n-  // finalization\n-  protected native void finalize () throws Throwable;\n-\n   /**\n    * Strip the last portion of the name (after the last dot).\n    *"}]}