{"sha": "17adeaa773a12d1fc04b1af28aadd9c255ae56d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdhZGVhYTc3M2ExMmQxZmMwNGIxYWYyOGFhZGQ5YzI1NWFlNTZkMA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2014-06-30T18:30:50Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2014-06-30T18:30:50Z"}, "message": "re PR c++/54891 ([C++11] lambda-expression and explicit type conversion (cast notation))\n\n/cp\n2014-06-30  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/54891\n\t* parser.c (cp_parser_tokens_start_cast_expression): In C++11\n\ta '[' can also start a primary-expression.\n\t(cp_parser_cast_expression): Parse a cast-expression only tentatively\n\twhen cp_parser_tokens_start_cast_expression returns -1.\n\n/testsuite\n2014-06-30  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/54891\n\t* g++.dg/cpp0x/lambda/lambda-cast1.C: New.\n\nFrom-SVN: r212162", "tree": {"sha": "0d0e586063aba446bedd32780b1491e8f843acd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d0e586063aba446bedd32780b1491e8f843acd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17adeaa773a12d1fc04b1af28aadd9c255ae56d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17adeaa773a12d1fc04b1af28aadd9c255ae56d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17adeaa773a12d1fc04b1af28aadd9c255ae56d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17adeaa773a12d1fc04b1af28aadd9c255ae56d0/comments", "author": null, "committer": null, "parents": [{"sha": "6e7ceb171d0905bdd7ffb7f97d98c2f0b11226a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e7ceb171d0905bdd7ffb7f97d98c2f0b11226a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e7ceb171d0905bdd7ffb7f97d98c2f0b11226a3"}], "stats": {"total": 102, "additions": 72, "deletions": 30}, "files": [{"sha": "bfe4da64af555bb7ea2a0d40fecdfb149be434e4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17adeaa773a12d1fc04b1af28aadd9c255ae56d0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17adeaa773a12d1fc04b1af28aadd9c255ae56d0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=17adeaa773a12d1fc04b1af28aadd9c255ae56d0", "patch": "@@ -1,3 +1,11 @@\n+2014-06-30  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/54891\n+\t* parser.c (cp_parser_tokens_start_cast_expression): In C++11\n+\ta '[' can also start a primary-expression.\n+\t(cp_parser_cast_expression): Parse a cast-expression only tentatively\n+\twhen cp_parser_tokens_start_cast_expression returns -1.\n+\n 2014-06-30  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/61539"}, {"sha": "013fc6ecd08301e04b8814931c7aa45090429dec", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17adeaa773a12d1fc04b1af28aadd9c255ae56d0/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17adeaa773a12d1fc04b1af28aadd9c255ae56d0/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=17adeaa773a12d1fc04b1af28aadd9c255ae56d0", "patch": "@@ -4109,6 +4109,7 @@ complain_flags (bool decltype_p)\n      this\n      ( expression )\n      id-expression\n+     lambda-expression (C++11)\n \n    GNU Extensions:\n \n@@ -7621,10 +7622,10 @@ cp_parser_delete_expression (cp_parser* parser)\n \t\t\ttf_warning_or_error);\n }\n \n-/* Returns true if TOKEN may start a cast-expression and false\n-   otherwise.  */\n+/* Returns 1 if TOKEN may start a cast-expression and, in C++11,\n+   isn't '[', -1 if TOKEN is '[' in C++11, 0 otherwise.  */\n \n-static bool\n+static int\n cp_parser_tokens_start_cast_expression (cp_parser *parser)\n {\n   cp_token *token = cp_lexer_peek_token (parser->lexer);\n@@ -7667,20 +7668,23 @@ cp_parser_tokens_start_cast_expression (cp_parser *parser)\n     case CPP_OR:\n     case CPP_OR_OR:\n     case CPP_EOF:\n-      return false;\n+      return 0;\n \n     case CPP_OPEN_PAREN:\n       /* In ((type ()) () the last () isn't a valid cast-expression,\n \t so the whole must be parsed as postfix-expression.  */\n       return cp_lexer_peek_nth_token (parser->lexer, 2)->type\n \t     != CPP_CLOSE_PAREN;\n \n-      /* '[' may start a primary-expression in obj-c++.  */\n+      /* '[' may start a primary-expression in obj-c++ and in C++11,\n+\t as a lambda-expression, eg, '(void)[]{}'.  */\n     case CPP_OPEN_SQUARE:\n+      if (cxx_dialect >= cxx11)\n+\treturn -1;\n       return c_dialect_objc ();\n \n     default:\n-      return true;\n+      return 1;\n     }\n }\n \n@@ -7705,7 +7709,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n     {\n       tree type = NULL_TREE;\n       tree expr = NULL_TREE;\n-      bool cast_expression_p;\n+      int cast_expression = 0;\n       const char *saved_message;\n \n       /* There's no way to know yet whether or not this is a cast.\n@@ -7728,6 +7732,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t will commit to the parse at that point, because we cannot\n \t undo the action that is done when creating a new class.  So,\n \t then we cannot back up and do a postfix-expression.\n+\n \t Another tricky case is the following (c++/29234):\n \n          struct S { void operator () (); };\n@@ -7746,20 +7751,30 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t we are dealing with an unary-expression, a postfix-expression\n \t or something else.\n \n+\t Yet another tricky case, in C++11, is the following (c++/54891):\n+\n+\t (void)[]{};\n+\n+         The issue is that usually, besides the case of lambda-expressions,\n+\t the parenthesized type-id cannot be followed by '[', and, eg, we\n+\t want to parse '(C ())[2];' in parse/pr26997.C as unary-expression.\n+\t Thus, if cp_parser_tokens_start_cast_expression returns -1, below\n+\t we don't commit, we try a cast-expression, then an unary-expression.\n+\n \t Save tokens so that we can put them back.  */\n       cp_lexer_save_tokens (parser->lexer);\n \n       /* We may be looking at a cast-expression.  */\n-      cast_expression_p\n-\t= (cp_parser_skip_to_closing_parenthesis (parser, false, false,\n-\t\t\t\t\t\t  /*consume_paren=*/true)\n-\t   && cp_parser_tokens_start_cast_expression (parser));\n+      if (cp_parser_skip_to_closing_parenthesis (parser, false, false,\n+\t\t\t\t\t\t /*consume_paren=*/true))\n+\tcast_expression\n+\t  = cp_parser_tokens_start_cast_expression (parser);\n \n       /* Roll back the tokens we skipped.  */\n       cp_lexer_rollback_tokens (parser->lexer);\n       /* If we aren't looking at a cast-expression, simulate an error so\n-\t that the call to cp_parser_parse_definitely below will fail.  */\n-      if (!cast_expression_p)\n+\t that the call to cp_parser_error_occurred below returns true.  */\n+      if (!cast_expression)\n \tcp_parser_simulate_error (parser);\n       else\n \t{\n@@ -7780,30 +7795,37 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t function returning T.  */\n       if (!cp_parser_error_occurred (parser))\n \t{\n-\t  cp_parser_parse_definitely (parser);\n+\t  /* Only commit if the cast-expression doesn't start with '[' in\n+\t     C++11, which may or may not start a lambda-expression.  */\n+\t  if (cast_expression > 0)\n+\t    cp_parser_commit_to_topmost_tentative_parse (parser);\n+\n \t  expr = cp_parser_cast_expression (parser,\n \t\t\t\t\t    /*address_p=*/false,\n \t\t\t\t\t    /*cast_p=*/true,\n \t\t\t\t\t    /*decltype_p=*/false,\n \t\t\t\t\t    pidk);\n \n-\t  /* Warn about old-style casts, if so requested.  */\n-\t  if (warn_old_style_cast\n-\t      && !in_system_header_at (input_location)\n-\t      && !VOID_TYPE_P (type)\n-\t      && current_lang_name != lang_name_c)\n-\t    warning (OPT_Wold_style_cast, \"use of old-style cast\");\n-\n-\t  /* Only type conversions to integral or enumeration types\n-\t     can be used in constant-expressions.  */\n-\t  if (!cast_valid_in_integral_constant_expression_p (type)\n-\t      && cp_parser_non_integral_constant_expression (parser,\n-\t\t\t\t\t\t\t     NIC_CAST))\n-\t    return error_mark_node;\n+\t  if (cp_parser_parse_definitely (parser))\n+\t    {\n+\t      /* Warn about old-style casts, if so requested.  */\n+\t      if (warn_old_style_cast\n+\t\t  && !in_system_header_at (input_location)\n+\t\t  && !VOID_TYPE_P (type)\n+\t\t  && current_lang_name != lang_name_c)\n+\t\twarning (OPT_Wold_style_cast, \"use of old-style cast\");\n+\n+\t      /* Only type conversions to integral or enumeration types\n+\t\t can be used in constant-expressions.  */\n+\t      if (!cast_valid_in_integral_constant_expression_p (type)\n+\t\t  && cp_parser_non_integral_constant_expression (parser,\n+\t\t\t\t\t\t\t\t NIC_CAST))\n+\t\treturn error_mark_node;\n \n-\t  /* Perform the cast.  */\n-\t  expr = build_c_cast (input_location, type, expr);\n-\t  return expr;\n+\t      /* Perform the cast.  */\n+\t      expr = build_c_cast (input_location, type, expr);\n+\t      return expr;\n+\t    }\n \t}\n       else \n         cp_parser_abort_tentative_parse (parser);"}, {"sha": "abfe4812a6d6c0dd8dab6d4506185758d06389a0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17adeaa773a12d1fc04b1af28aadd9c255ae56d0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17adeaa773a12d1fc04b1af28aadd9c255ae56d0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=17adeaa773a12d1fc04b1af28aadd9c255ae56d0", "patch": "@@ -1,3 +1,8 @@\n+2014-06-30  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/54891\n+\t* g++.dg/cpp0x/lambda/lambda-cast1.C: New.\n+\n 2014-06-30  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/51400"}, {"sha": "e5d49ca43e9ee31fd6a3b813980805d13624ec19", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-cast1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17adeaa773a12d1fc04b1af28aadd9c255ae56d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-cast1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17adeaa773a12d1fc04b1af28aadd9c255ae56d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-cast1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-cast1.C?ref=17adeaa773a12d1fc04b1af28aadd9c255ae56d0", "patch": "@@ -0,0 +1,7 @@\n+// PR c++/54891\n+// { dg-do compile { target c++11 } }\n+\n+int main()\n+{\n+  (void)[]{};\n+}"}]}