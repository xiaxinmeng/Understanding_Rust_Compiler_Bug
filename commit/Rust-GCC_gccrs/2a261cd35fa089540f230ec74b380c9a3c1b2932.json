{"sha": "2a261cd35fa089540f230ec74b380c9a3c1b2932", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEyNjFjZDM1ZmEwODk1NDBmMjMwZWM3NGIzODBjOWEzYzFiMjkzMg==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2012-07-31T02:44:35Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2012-07-31T02:44:35Z"}, "message": "expmed.h (NUM_MODE_VECTOR_INT): Define.\n\n\t* expmed.h (NUM_MODE_VECTOR_INT): Define.\n\t(struct expmed_op_cheap, struct expmed_op_costs): New structures.\n\t(struct target_expmed): Convert x_mul_highpart_cost and\n\tx_mul_widen_cost fields to be indexed by integer modes.\n\tConvert x_sdiv_pow2_cheap and x_smod_pow2_cheap fields to be\n\tof type struct expmed_op_cheap.  Convert other cost fields to be\n\tof type struct_expmed_op_costs.\n\t(mul_widen_cost_ptr, mul_highpart_cost_ptr): Adjust for new\n\tindexing of respective fields.\n\t(expmed_op_cheap_ptr): New function.\n\t(sdiv_pow2_cheap_ptr, smod_pow2_cheap_ptr): Call it.\n\t(expmed_op_cost_ptr): New function.\n\t(add_cost_ptr, neg_cost_ptr, shift_cost_ptr, shiftadd_cost_ptr,\n\tshiftsub0_cost_ptr, shiftsub1_cost_ptr, mul_cost_ptr,\n\tsdiv_cost_ptr, udiv_cost_ptr): Call it.\n\nFrom-SVN: r189994", "tree": {"sha": "9c743c087dc8b5808d62742d25ee84c8a8d31f57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c743c087dc8b5808d62742d25ee84c8a8d31f57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a261cd35fa089540f230ec74b380c9a3c1b2932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a261cd35fa089540f230ec74b380c9a3c1b2932", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a261cd35fa089540f230ec74b380c9a3c1b2932", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a261cd35fa089540f230ec74b380c9a3c1b2932/comments", "author": null, "committer": null, "parents": [{"sha": "b959718f2c5118e21bbc5a1dc1b943f005233ad8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b959718f2c5118e21bbc5a1dc1b943f005233ad8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b959718f2c5118e21bbc5a1dc1b943f005233ad8"}], "stats": {"total": 142, "additions": 116, "deletions": 26}, "files": [{"sha": "15196d819741493d60fa8156eb59658a3ff370f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a261cd35fa089540f230ec74b380c9a3c1b2932/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a261cd35fa089540f230ec74b380c9a3c1b2932/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a261cd35fa089540f230ec74b380c9a3c1b2932", "patch": "@@ -1,3 +1,21 @@\n+2012-07-30  Nathan Froyd  <froydnj@gcc.gnu.org>\n+\n+\t* expmed.h (NUM_MODE_VECTOR_INT): Define.\n+\t(struct expmed_op_cheap, struct expmed_op_costs): New structures.\n+\t(struct target_expmed): Convert x_mul_highpart_cost and\n+\tx_mul_widen_cost fields to be indexed by integer modes.\n+\tConvert x_sdiv_pow2_cheap and x_smod_pow2_cheap fields to be\n+\tof type struct expmed_op_cheap.  Convert other cost fields to be\n+\tof type struct_expmed_op_costs.\n+\t(mul_widen_cost_ptr, mul_highpart_cost_ptr): Adjust for new\n+\tindexing of respective fields.\n+\t(expmed_op_cheap_ptr): New function.\n+\t(sdiv_pow2_cheap_ptr, smod_pow2_cheap_ptr): Call it.\n+\t(expmed_op_cost_ptr): New function.\n+\t(add_cost_ptr, neg_cost_ptr, shift_cost_ptr, shiftadd_cost_ptr,\n+\tshiftsub0_cost_ptr, shiftsub1_cost_ptr, mul_cost_ptr,\n+\tsdiv_cost_ptr, udiv_cost_ptr): Call it.\n+\n 2012-07-30  Sandra Loosemore  <sandra@codesourcery.com>\n \t    Julian Brown  <julian@codesourcery.com>\n "}, {"sha": "bde5caeb466e1dff385554e87efed55977e99492", "filename": "gcc/expmed.h", "status": "modified", "additions": 98, "deletions": 26, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a261cd35fa089540f230ec74b380c9a3c1b2932/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a261cd35fa089540f230ec74b380c9a3c1b2932/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=2a261cd35fa089540f230ec74b380c9a3c1b2932", "patch": "@@ -125,6 +125,23 @@ struct alg_hash_entry {\n #endif\n \n #define NUM_MODE_INT (MAX_MODE_INT - MIN_MODE_INT + 1)\n+#define NUM_MODE_VECTOR_INT (MAX_MODE_VECTOR_INT - MIN_MODE_VECTOR_INT + 1)\n+\n+struct expmed_op_cheap {\n+  /* Whether an operation is cheap in a given integer mode.  */\n+  bool cheap_int[2][NUM_MODE_INT];\n+\n+  /* Whether an operation is cheap in a given vector integer mode.  */\n+  bool cheap_vector_int[2][NUM_MODE_VECTOR_INT];\n+};\n+\n+struct expmed_op_costs {\n+  /* The cost of an operation in a given integer mode.  */\n+  int int_cost[2][NUM_MODE_INT];\n+\n+  /* The cost of an operation in a given vector integer mode.  */\n+  int vector_int_cost[2][NUM_MODE_VECTOR_INT];\n+};\n \n /* Target-dependent globals.  */\n struct target_expmed {\n@@ -140,23 +157,23 @@ struct target_expmed {\n      powers of two, so don't use branches; emit the operation instead.\n      Usually, this will mean that the MD file will emit non-branch\n      sequences.  */\n-  bool x_sdiv_pow2_cheap[2][NUM_MACHINE_MODES];\n-  bool x_smod_pow2_cheap[2][NUM_MACHINE_MODES];\n+  struct expmed_op_cheap x_sdiv_pow2_cheap;\n+  struct expmed_op_cheap x_smod_pow2_cheap;\n \n   /* Cost of various pieces of RTL.  Note that some of these are indexed by\n      shift count and some by mode.  */\n   int x_zero_cost[2];\n-  int x_add_cost[2][NUM_MACHINE_MODES];\n-  int x_neg_cost[2][NUM_MACHINE_MODES];\n-  int x_shift_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n-  int x_shiftadd_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n-  int x_shiftsub0_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n-  int x_shiftsub1_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n-  int x_mul_cost[2][NUM_MACHINE_MODES];\n-  int x_sdiv_cost[2][NUM_MACHINE_MODES];\n-  int x_udiv_cost[2][NUM_MACHINE_MODES];\n-  int x_mul_widen_cost[2][NUM_MACHINE_MODES];\n-  int x_mul_highpart_cost[2][NUM_MACHINE_MODES];\n+  struct expmed_op_costs x_add_cost;\n+  struct expmed_op_costs x_neg_cost;\n+  struct expmed_op_costs x_shift_cost[MAX_BITS_PER_WORD];\n+  struct expmed_op_costs x_shiftadd_cost[MAX_BITS_PER_WORD];\n+  struct expmed_op_costs x_shiftsub0_cost[MAX_BITS_PER_WORD];\n+  struct expmed_op_costs x_shiftsub1_cost[MAX_BITS_PER_WORD];\n+  struct expmed_op_costs x_mul_cost;\n+  struct expmed_op_costs x_sdiv_cost;\n+  struct expmed_op_costs x_udiv_cost;\n+  int x_mul_widen_cost[2][NUM_MODE_INT];\n+  int x_mul_highpart_cost[2][NUM_MODE_INT];\n \n   /* Conversion costs are only defined between two scalar integer modes\n      of different sizes.  The first machine mode is the destination mode,\n@@ -195,12 +212,58 @@ set_alg_hash_used_p (bool usedp)\n   this_target_expmed->x_alg_hash_used_p = usedp;\n }\n \n+/* Return a pointer to a boolean contained in EOC indicating whether\n+   a particular operation performed in MODE is cheap when optimizing\n+   for SPEED.  */\n+\n+static inline bool *\n+expmed_op_cheap_ptr (struct expmed_op_cheap *eoc, bool speed,\n+\t\t     enum machine_mode mode)\n+{\n+  gcc_assert (GET_MODE_CLASS (mode) == MODE_INT\n+\t      || GET_MODE_CLASS (mode) == MODE_VECTOR_INT);\n+\n+  if (GET_MODE_CLASS (mode) == MODE_INT)\n+    {\n+      int idx = mode - MIN_MODE_INT;\n+      return &eoc->cheap_int[speed][idx];\n+    }\n+  else\n+    {\n+      int idx = mode - MIN_MODE_VECTOR_INT;\n+      return &eoc->cheap_vector_int[speed][idx];\n+    }\n+}\n+\n+/* Return a pointer to a cost contained in COSTS when a particular\n+   operation is performed in MODE when optimizing for SPEED.  */\n+\n+static inline int *\n+expmed_op_cost_ptr (struct expmed_op_costs *costs, bool speed,\n+\t\t    enum machine_mode mode)\n+{\n+  gcc_assert (GET_MODE_CLASS (mode) == MODE_INT\n+\t      || GET_MODE_CLASS (mode) == MODE_VECTOR_INT);\n+\n+  if (GET_MODE_CLASS (mode) == MODE_INT)\n+    {\n+      int idx = mode - MIN_MODE_INT;\n+      return &costs->int_cost[speed][idx];\n+    }\n+  else\n+    {\n+      int idx = mode - MIN_MODE_VECTOR_INT;\n+      return &costs->vector_int_cost[speed][idx];\n+    }\n+}\n+\n /* Subroutine of {set_,}sdiv_pow2_cheap.  Not to be used otherwise.  */\n \n static inline bool *\n sdiv_pow2_cheap_ptr (bool speed, enum machine_mode mode)\n {\n-  return &this_target_expmed->x_sdiv_pow2_cheap[speed][mode];\n+  return expmed_op_cheap_ptr (&this_target_expmed->x_sdiv_pow2_cheap,\n+\t\t\t      speed, mode);\n }\n \n /* Set whether a signed division by a power of 2 is cheap in MODE\n@@ -226,7 +289,8 @@ sdiv_pow2_cheap (bool speed, enum machine_mode mode)\n static inline bool *\n smod_pow2_cheap_ptr (bool speed, enum machine_mode mode)\n {\n-  return &this_target_expmed->x_smod_pow2_cheap[speed][mode];\n+  return expmed_op_cheap_ptr (&this_target_expmed->x_smod_pow2_cheap,\n+\t\t\t      speed, mode);\n }\n \n /* Set whether a signed modulo by a power of 2 is CHEAP in MODE when\n@@ -276,7 +340,7 @@ zero_cost (bool speed)\n static inline int *\n add_cost_ptr (bool speed, enum machine_mode mode)\n {\n-  return &this_target_expmed->x_add_cost[speed][mode];\n+  return expmed_op_cost_ptr (&this_target_expmed->x_add_cost, speed, mode);\n }\n \n /* Set the COST of computing an add in MODE when optimizing for SPEED.  */\n@@ -300,7 +364,7 @@ add_cost (bool speed, enum machine_mode mode)\n static inline int *\n neg_cost_ptr (bool speed, enum machine_mode mode)\n {\n-  return &this_target_expmed->x_neg_cost[speed][mode];\n+  return expmed_op_cost_ptr (&this_target_expmed->x_neg_cost, speed, mode);\n }\n \n /* Set the COST of computing a negation in MODE when optimizing for SPEED.  */\n@@ -325,7 +389,8 @@ neg_cost (bool speed, enum machine_mode mode)\n static inline int *\n shift_cost_ptr (bool speed, enum machine_mode mode, int bits)\n {\n-  return &this_target_expmed->x_shift_cost[speed][mode][bits];\n+  return expmed_op_cost_ptr (&this_target_expmed->x_shift_cost[bits],\n+\t\t\t     speed, mode);\n }\n \n /* Set the COST of doing a shift in MODE by BITS when optimizing for SPEED.  */\n@@ -350,7 +415,8 @@ shift_cost (bool speed, enum machine_mode mode, int bits)\n static inline int *\n shiftadd_cost_ptr (bool speed, enum machine_mode mode, int bits)\n {\n-  return &this_target_expmed->x_shiftadd_cost[speed][mode][bits];\n+  return expmed_op_cost_ptr (&this_target_expmed->x_shiftadd_cost[bits],\n+\t\t\t     speed, mode);\n }\n \n /* Set the COST of doing a shift in MODE by BITS followed by an add when\n@@ -376,7 +442,8 @@ shiftadd_cost (bool speed, enum machine_mode mode, int bits)\n static inline int *\n shiftsub0_cost_ptr (bool speed, enum machine_mode mode, int bits)\n {\n-  return &this_target_expmed->x_shiftsub0_cost[speed][mode][bits];\n+  return expmed_op_cost_ptr (&this_target_expmed->x_shiftsub0_cost[bits],\n+\t\t\t     speed, mode);\n }\n \n /* Set the COST of doing a shift in MODE by BITS and then subtracting a\n@@ -402,7 +469,8 @@ shiftsub0_cost (bool speed, enum machine_mode mode, int bits)\n static inline int *\n shiftsub1_cost_ptr (bool speed, enum machine_mode mode, int bits)\n {\n-  return &this_target_expmed->x_shiftsub1_cost[speed][mode][bits];\n+  return expmed_op_cost_ptr (&this_target_expmed->x_shiftsub1_cost[bits],\n+\t\t\t     speed, mode);\n }\n \n /* Set the COST of subtracting a shift in MODE by BITS from a value when\n@@ -428,7 +496,7 @@ shiftsub1_cost (bool speed, enum machine_mode mode, int bits)\n static inline int *\n mul_cost_ptr (bool speed, enum machine_mode mode)\n {\n-  return &this_target_expmed->x_mul_cost[speed][mode];\n+  return expmed_op_cost_ptr (&this_target_expmed->x_mul_cost, speed, mode);\n }\n \n /* Set the COST of doing a multiplication in MODE when optimizing for\n@@ -454,7 +522,7 @@ mul_cost (bool speed, enum machine_mode mode)\n static inline int *\n sdiv_cost_ptr (bool speed, enum machine_mode mode)\n {\n-  return &this_target_expmed->x_sdiv_cost[speed][mode];\n+  return expmed_op_cost_ptr (&this_target_expmed->x_sdiv_cost, speed, mode);\n }\n \n /* Set the COST of doing a signed division in MODE when optimizing\n@@ -480,7 +548,7 @@ sdiv_cost (bool speed, enum machine_mode mode)\n static inline int *\n udiv_cost_ptr (bool speed, enum machine_mode mode)\n {\n-  return &this_target_expmed->x_udiv_cost[speed][mode];\n+  return expmed_op_cost_ptr (&this_target_expmed->x_udiv_cost, speed, mode);\n }\n \n /* Set the COST of doing an unsigned division in MODE when optimizing\n@@ -506,7 +574,9 @@ udiv_cost (bool speed, enum machine_mode mode)\n static inline int *\n mul_widen_cost_ptr (bool speed, enum machine_mode mode)\n {\n-  return &this_target_expmed->x_mul_widen_cost[speed][mode];\n+  gcc_assert (GET_MODE_CLASS (mode) == MODE_INT);\n+\n+  return &this_target_expmed->x_mul_widen_cost[speed][mode - MIN_MODE_INT];\n }\n \n /* Set the COST for computing a widening multiplication in MODE when\n@@ -532,7 +602,9 @@ mul_widen_cost (bool speed, enum machine_mode mode)\n static inline int *\n mul_highpart_cost_ptr (bool speed, enum machine_mode mode)\n {\n-  return &this_target_expmed->x_mul_highpart_cost[speed][mode];\n+  gcc_assert (GET_MODE_CLASS (mode) == MODE_INT);\n+\n+  return &this_target_expmed->x_mul_highpart_cost[speed][mode - MIN_MODE_INT];\n }\n \n /* Set the COST for computing the high part of a multiplication in MODE"}]}