{"sha": "fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI5MzAzMDZiYTRjYmI2ZmQ1NGQxY2JmYTAxM2NiNmM4ZjkyYWQ0Zg==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2014-05-06T00:11:29Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-05-06T00:11:29Z"}, "message": "compiler: Use backend interface for slice construction.\n\n\t* go-gcc.cc (Gcc_backend::implicit_variable): Rename from\n\tgc_root_variable.  Add name and is_constant parameters.\n\nFrom-SVN: r210088", "tree": {"sha": "f3a9e000cbf0028296817998178ce156cf0715e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3a9e000cbf0028296817998178ce156cf0715e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f/comments", "author": null, "committer": null, "parents": [{"sha": "3e7b0938f13f937df971a1bc42f1dd32ca8a81bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb"}], "stats": {"total": 207, "additions": 96, "deletions": 111}, "files": [{"sha": "8fe468f9b3dd364b811ce30dca5213e763e2839a", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f", "patch": "@@ -1,3 +1,8 @@\n+2014-05-05  Chris Manghane  <cmang@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::implicit_variable): Rename from\n+\tgc_root_variable.  Add name and is_constant parameters.\n+\n 2014-05-05  Chris Manghane  <cmang@google.com>\n \n \t* go-gcc.cc (Gcc_backend::indirect_expression): Add btype"}, {"sha": "3d9fc8e369a5ba34e7552d376ba57d5ed0fee82e", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f", "patch": "@@ -381,7 +381,7 @@ class Gcc_backend : public Backend\n \t\t     Location, Bstatement**);\n \n   Bvariable*\n-  gc_root_variable(Btype*, Bexpression*);\n+  implicit_variable(const std::string&, Btype*, Bexpression*, bool);\n \n   Bvariable*\n   immutable_struct(const std::string&, bool, bool, Btype*, Location);\n@@ -2476,22 +2476,29 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n   return new Bvariable(var);\n }\n \n-// Make a GC root variable.\n+// Create an implicit variable that is compiler-defined.  This is used when\n+// generating GC root variables and storing the values of a slice initializer.\n \n Bvariable*\n-Gcc_backend::gc_root_variable(Btype* type, Bexpression* init)\n+Gcc_backend::implicit_variable(const std::string& name, Btype* type,\n+\t\t\t       Bexpression* init, bool is_constant)\n {\n   tree type_tree = type->get_tree();\n   tree init_tree = init->get_tree();\n   if (type_tree == error_mark_node || init_tree == error_mark_node)\n     return this->error_variable();\n \n   tree decl = build_decl(BUILTINS_LOCATION, VAR_DECL,\n-                         create_tmp_var_name(\"gc\"), type_tree);\n+                         get_identifier_from_string(name), type_tree);\n   DECL_EXTERNAL(decl) = 0;\n   TREE_PUBLIC(decl) = 0;\n   TREE_STATIC(decl) = 1;\n   DECL_ARTIFICIAL(decl) = 1;\n+  if (is_constant)\n+    {\n+      TREE_READONLY(decl) = 1;\n+      TREE_CONSTANT(decl) = 1;\n+    }\n   DECL_INITIAL(decl) = init_tree;\n   rest_of_decl_compilation(decl, 1, 0);\n "}, {"sha": "95f494accfc3d2271b185132dc5c5f0505f9021a", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f", "patch": "@@ -536,11 +536,16 @@ class Backend\n \t\t     bool address_is_taken, Location location,\n \t\t     Bstatement** pstatement) = 0;\n \n-  // Create a GC root variable. TYPE is the __go_gc_root_list struct described\n-  // in Gogo::register_gc_vars.  INIT is the composite literal consisting of a\n-  // pointer to the next GC root and the global variables registered.\n+  // Create an implicit variable that is compiler-defined.  This is used when\n+  // generating GC root variables and storing the values of a slice constructor.\n+  // NAME is the name of the variable, either gc# for GC roots or C# for slice\n+  // initializers.  TYPE is the type of the implicit variable with an initial\n+  // value INIT.  IS_CONSTANT is true if the implicit variable should be treated\n+  // like it is immutable.  For slice initializers, if the values must be copied\n+  // to the heap, the variable IS_CONSTANT.\n   virtual Bvariable*\n-  gc_root_variable(Btype* type, Bexpression* init) = 0;\n+  implicit_variable(const std::string& name, Btype* type, Bexpression* init,\n+\t\t    bool is_constant) = 0;\n \n   // Create a named immutable initialized data structure.  This is\n   // used for type descriptors, map descriptors, and function"}, {"sha": "9381764e1439609a2d16e2ab798b6752089f726e", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 56, "deletions": 102, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f", "patch": "@@ -4113,20 +4113,47 @@ Unary_expression::do_get_tree(Translate_context* context)\n \t    }\n \t}\n \n-      if (this->is_gc_root_)\n+      static unsigned int counter;\n+      char buf[100];\n+      if (this->is_gc_root_ || this->is_slice_init_)\n \t{\n-\t  // Build a decl for a GC root variable.  GC roots are mutable, so they\n-\t  // cannot be represented as an immutable_struct in the backend.\n-\t  Bvariable* gc_root = gogo->backend()->gc_root_variable(btype, bexpr);\n-\t  bexpr = gogo->backend()->var_expression(gc_root, loc);\n+\t  bool copy_to_heap = false;\n+\t  if (this->is_gc_root_)\n+\t    {\n+\t      // Build a decl for a GC root variable.  GC roots are mutable, so\n+\t      // they cannot be represented as an immutable_struct in the\n+\t      // backend.\n+\t      static unsigned int root_counter;\n+\t      snprintf(buf, sizeof buf, \"gc%u\", root_counter);\n+\t      ++root_counter;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Build a decl for a slice value initializer.  An immutable slice\n+\t      // value initializer may have to be copied to the heap if it\n+\t      // contains pointers in a non-constant context.\n+\t      snprintf(buf, sizeof buf, \"C%u\", counter);\n+\t      ++counter;\n+\n+\t      Array_type* at = this->expr_->type()->array_type();\n+\t      go_assert(at != NULL);\n+\n+\t      // If we are not copying the value to the heap, we will only\n+\t      // initialize the value once, so we can use this directly\n+\t      // rather than copying it.  In that case we can't make it\n+\t      // read-only, because the program is permitted to change it.\n+\t      copy_to_heap = (at->element_type()->has_pointer()\n+\t\t\t      && !context->is_const());\n+\t    }\n+\t  Bvariable* implicit =\n+\t    gogo->backend()->implicit_variable(buf, btype, bexpr, copy_to_heap);\n+\t  bexpr = gogo->backend()->var_expression(implicit, loc);\n \t}\n       else if ((this->expr_->is_composite_literal()\n            || this->expr_->string_expression() != NULL)\n           && this->expr_->is_immutable())\n         {\n \t  // Build a decl for a constant constructor.\n-          static unsigned int counter;\n-          char buf[100];\n           snprintf(buf, sizeof buf, \"C%u\", counter);\n           ++counter;\n \n@@ -12450,6 +12477,7 @@ Slice_construction_expression::do_get_tree(Translate_context* context)\n       return error_mark_node;\n     }\n \n+  Location loc = this->location();\n   Type* element_type = array_type->element_type();\n   if (this->valtype_ == NULL)\n     {\n@@ -12464,35 +12492,24 @@ Slice_construction_expression::do_get_tree(Translate_context* context)\n           else\n             mpz_init_set_ui(lenval, this->indexes()->back() + 1);\n         }\n-      Location loc = this->location();\n       Type* int_type = Type::lookup_integer_type(\"int\");\n       length = Expression::make_integer(&lenval, int_type, loc);\n       mpz_clear(lenval);\n       this->valtype_ = Type::make_array_type(element_type, length);\n     }\n \n-  tree values;\n-  Gogo* gogo = context->gogo();\n-  Btype* val_btype = this->valtype_->get_backend(gogo);\n+  Expression_list* vals = this->vals();\n   if (this->vals() == NULL || this->vals()->empty())\n     {\n-      // We need to create a unique value.\n-      Btype* int_btype = Type::lookup_integer_type(\"int\")->get_backend(gogo);\n-      Bexpression* zero = gogo->backend()->zero_expression(int_btype);\n-      std::vector<unsigned long> index(1, 0);\n-      std::vector<Bexpression*> val(1, zero);\n-      Bexpression* ctor =\n-\tgogo->backend()->array_constructor_expression(val_btype, index, val,\n-\t\t\t\t\t\t      this->location());\n-      values = expr_to_tree(ctor);\n+      // We need to create a unique value for the empty array literal.\n+      vals = new Expression_list;\n+      vals->push_back(NULL);\n     }\n-  else\n-    values = expr_to_tree(this->get_constructor(context, val_btype));\n-\n-  if (values == error_mark_node)\n-    return error_mark_node;\n+  Expression* array_val =\n+    new Fixed_array_construction_expression(this->valtype_, this->indexes(),\n+\t\t\t\t\t    vals, loc);\n \n-  bool is_constant_initializer = TREE_CONSTANT(values);\n+  bool is_constant_initializer = array_val->is_immutable();\n \n   // We have to copy the initial values into heap memory if we are in\n   // a function or if the values are not constants.  We also have to\n@@ -12503,89 +12520,22 @@ Slice_construction_expression::do_get_tree(Translate_context* context)\n \t\t       || (element_type->has_pointer()\n \t\t\t   && !context->is_const()));\n \n-  if (is_constant_initializer)\n-    {\n-      tree tmp = build_decl(this->location().gcc_location(), VAR_DECL,\n-\t\t\t    create_tmp_var_name(\"C\"), TREE_TYPE(values));\n-      DECL_EXTERNAL(tmp) = 0;\n-      TREE_PUBLIC(tmp) = 0;\n-      TREE_STATIC(tmp) = 1;\n-      DECL_ARTIFICIAL(tmp) = 1;\n-      if (copy_to_heap)\n-\t{\n-\t  // If we are not copying the value to the heap, we will only\n-\t  // initialize the value once, so we can use this directly\n-\t  // rather than copying it.  In that case we can't make it\n-\t  // read-only, because the program is permitted to change it.\n-\t  TREE_READONLY(tmp) = 1;\n-\t  TREE_CONSTANT(tmp) = 1;\n-\t}\n-      DECL_INITIAL(tmp) = values;\n-      rest_of_decl_compilation(tmp, 1, 0);\n-      values = tmp;\n-    }\n-\n-  tree space;\n-  tree set;\n+  Expression* space;\n   if (!copy_to_heap)\n     {\n-      // the initializer will only run once.\n-      space = build_fold_addr_expr(values);\n-      set = NULL_TREE;\n+      // The initializer will only run once.\n+      space = Expression::make_unary(OPERATOR_AND, array_val, loc);\n+      space->unary_expression()->set_is_slice_init();\n     }\n   else\n-    {\n-      Expression* alloc =\n-          context->gogo()->allocate_memory(this->valtype_, this->location());\n-      space = save_expr(alloc->get_tree(context));\n-\n-      tree s = fold_convert(build_pointer_type(TREE_TYPE(values)), space);\n-      tree ref = build_fold_indirect_ref_loc(this->location().gcc_location(),\n-                                             s);\n-      TREE_THIS_NOTRAP(ref) = 1;\n-      set = build2(MODIFY_EXPR, void_type_node, ref, values);\n-    }\n+    space = Expression::make_heap_expression(array_val, loc);\n \n   // Build a constructor for the slice.\n \n-  tree type_tree = type_to_tree(this->type()->get_backend(context->gogo()));\n-  if (type_tree == error_mark_node)\n-    return error_mark_node;\n-  go_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n-\n-  vec<constructor_elt, va_gc> *init;\n-  vec_alloc(init, 3);\n-\n-  constructor_elt empty = {NULL, NULL};\n-  constructor_elt* elt = init->quick_push(empty);\n-  tree field = TYPE_FIELDS(type_tree);\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n-  elt->index = field;\n-  elt->value = fold_convert(TREE_TYPE(field), space);\n-\n-  tree length_tree = this->valtype_->array_type()->length()->get_tree(context);\n-  elt = init->quick_push(empty);\n-  field = DECL_CHAIN(field);\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n-  elt->index = field;\n-  elt->value = fold_convert(TREE_TYPE(field), length_tree);\n-\n-  elt = init->quick_push(empty);\n-  field = DECL_CHAIN(field);\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\"__capacity\") == 0);\n-  elt->index = field;\n-  elt->value = fold_convert(TREE_TYPE(field), length_tree);\n-\n-  tree constructor = build_constructor(type_tree, init);\n-  if (constructor == error_mark_node)\n-    return error_mark_node;\n-  if (!copy_to_heap)\n-    TREE_CONSTANT(constructor) = 1;\n-\n-  if (set == NULL_TREE)\n-    return constructor;\n-  else\n-    return build2(COMPOUND_EXPR, type_tree, set, constructor);\n+  Expression* len = this->valtype_->array_type()->length();\n+  Expression* slice_val =\n+    Expression::make_slice_value(this->type(), space, len, len, loc);\n+  return slice_val->get_tree(context);\n }\n \n // Make a slice composite literal.  This is used by the type\n@@ -14802,6 +14752,10 @@ class Struct_field_offset_expression : public Expression\n   { }\n \n  protected:\n+  bool\n+  do_is_immutable() const\n+  { return true; }\n+\n   Type*\n   do_type()\n   { return Type::lookup_integer_type(\"uintptr\"); }"}, {"sha": "6f03e02a8c6d984bf688db5880f6e1c3fdddce78", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=fb930306ba4cbb6fd54d1cbfa013cb6c8f92ad4f", "patch": "@@ -1305,7 +1305,7 @@ class Unary_expression : public Expression\n   Unary_expression(Operator op, Expression* expr, Location location)\n     : Expression(EXPRESSION_UNARY, location),\n       op_(op), escapes_(true), create_temp_(false), is_gc_root_(false),\n-      expr_(expr), issue_nil_check_(false)\n+      is_slice_init_(false), expr_(expr), issue_nil_check_(false)\n   { }\n \n   // Return the operator.\n@@ -1344,6 +1344,15 @@ class Unary_expression : public Expression\n     this->is_gc_root_ = true;\n   }\n \n+  // Record that this is an address expression of a slice value initializer,\n+  // which is mutable if the values are not copied to the heap.\n+  void\n+  set_is_slice_init()\n+  {\n+    go_assert(this->op_ == OPERATOR_AND);\n+    this->is_slice_init_ = true;\n+  }\n+\n   // Apply unary opcode OP to UNC, setting NC.  Return true if this\n   // could be done, false if not.  Issue errors for overflow.\n   static bool\n@@ -1427,6 +1436,11 @@ class Unary_expression : public Expression\n   // special struct composite literal that is mutable when addressed, meaning\n   // it cannot be represented as an immutable_struct in the backend.\n   bool is_gc_root_;\n+  // True if this is an address expression for a slice value with an immutable\n+  // initializer.  The initializer for a slice's value pointer has an array\n+  // type, meaning it cannot be represented as an immutable_struct in the\n+  // backend.\n+  bool is_slice_init_;\n   // The operand.\n   Expression* expr_;\n   // Whether or not to issue a nil check for this expression if its address"}]}