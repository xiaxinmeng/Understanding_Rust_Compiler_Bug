{"sha": "0a222ba757886807ca7a62858783c3eaa95f9356", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGEyMjJiYTc1Nzg4NjgwN2NhN2E2Mjg1ODc4M2MzZWFhOTVmOTM1Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-07-09T10:13:56Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-07-09T10:13:56Z"}, "message": "sparc.h (STACK_SAVEAREA_MODE): Move around.\n\n\t* config/sparc/sparc.h (STACK_SAVEAREA_MODE): Move around.\n\t(FP_REG_P): Delete.\n\t(IN_OR_GLOBAL_P): Likewise.\n\nFrom-SVN: r176074", "tree": {"sha": "37aefed2dfcd28c3d1c7fe411e4e6869f066a34d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37aefed2dfcd28c3d1c7fe411e4e6869f066a34d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a222ba757886807ca7a62858783c3eaa95f9356", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a222ba757886807ca7a62858783c3eaa95f9356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a222ba757886807ca7a62858783c3eaa95f9356", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a222ba757886807ca7a62858783c3eaa95f9356/comments", "author": null, "committer": null, "parents": [{"sha": "4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c"}], "stats": {"total": 31, "additions": 12, "deletions": 19}, "files": [{"sha": "dfef1fb5c6dc7e91e4d75ae558ddc97ef0973beb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a222ba757886807ca7a62858783c3eaa95f9356/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a222ba757886807ca7a62858783c3eaa95f9356/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a222ba757886807ca7a62858783c3eaa95f9356", "patch": "@@ -1,3 +1,9 @@\n+2011-07-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/sparc/sparc.h (STACK_SAVEAREA_MODE): Move around.\n+\t(FP_REG_P): Delete.\n+\t(IN_OR_GLOBAL_P): Likewise.\n+\n 2011-07-08  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/45437"}, {"sha": "81308e79b3d4ac20eb8c9a2504bcd102e871bf63", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a222ba757886807ca7a62858783c3eaa95f9356/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a222ba757886807ca7a62858783c3eaa95f9356/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=0a222ba757886807ca7a62858783c3eaa95f9356", "patch": "@@ -630,6 +630,11 @@ extern enum cmodel sparc_cmodel;\n      : MAX ((COMPUTED), (SPECIFIED)))\t\t\t\\\n    :  MAX ((COMPUTED), (SPECIFIED)))\n \n+/* We need 2 words, so we can save the stack pointer and the return register\n+   of the function containing a non-local goto target.  */\n+#define STACK_SAVEAREA_MODE(LEVEL) \\\n+  ((LEVEL) == SAVE_NONLOCAL ? (TARGET_ARCH64 ? TImode : DImode) : Pmode)\n+\n /* Make strings word-aligned so strcpy from constants will be faster.  */\n #define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n   ((TREE_CODE (EXP) == STRING_CST\t\\\n@@ -1377,11 +1382,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n    functions that have frame pointers.  */\n #define EXIT_IGNORE_STACK 1\n \n-/* We need 2 words, so we can save the stack pointer and the return register\n-   of the function containing a non-local goto target.  */\n-#define STACK_SAVEAREA_MODE(LEVEL) \\\n-  ((LEVEL) == SAVE_NONLOCAL ? (TARGET_ARCH64 ? TImode : DImode) : Pmode)\n-\n /* Length in units of the trampoline for entering a nested function.  */\n #define TRAMPOLINE_SIZE (TARGET_ARCH64 ? 32 : 16)\n \n@@ -1517,24 +1517,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define REGNO_OK_FOR_FP_P(REGNO) \\\n   (((unsigned) (REGNO) - 32 < (TARGET_V9 ? (unsigned)64 : (unsigned)32)) \\\n    || ((unsigned) reg_renumber[REGNO] - 32 < (TARGET_V9 ? (unsigned)64 : (unsigned)32)))\n+\n #define REGNO_OK_FOR_CCFP_P(REGNO) \\\n  (TARGET_V9 \\\n   && (((unsigned) (REGNO) - 96 < (unsigned)4) \\\n       || ((unsigned) reg_renumber[REGNO] - 96 < (unsigned)4)))\n-\n-/* Now macros that check whether X is a register and also,\n-   strictly, whether it is in a specified class.\n-\n-   These macros are specific to the SPARC, and may be used only\n-   in code for printing assembler insns and in conditions for\n-   define_optimization.  */\n-\n-/* 1 if X is an fp register.  */\n-\n-#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n-\n-/* Is X, a REG, an in or global register?  i.e. is regno 0..7 or 24..31 */\n-#define IN_OR_GLOBAL_P(X) (REGNO (X) < 8 || (REGNO (X) >= 24 && REGNO (X) <= 31))\n \f\n /* Maximum number of registers that can appear in a valid memory address.  */\n "}]}