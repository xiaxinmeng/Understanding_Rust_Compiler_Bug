{"sha": "07d7662ff7ed987d98a61f333169b65620ec8202", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdkNzY2MmZmN2VkOTg3ZDk4YTYxZjMzMzE2OWI2NTYyMGVjODIwMg==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2019-07-18T17:17:31Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2019-07-18T17:17:31Z"}, "message": "re PR target/91188 (strict_low_part operations do not work)\n\n\tPR target/91188\n\t* config/i386/i386.md (*addqi_1_slp): Use register_operand predicate\n\tfor operand 0.  Do not use (match_dup) to match operand 1 with\n\toperand 0.  Add check in insn constraint that either input operand\n\tmatches operand 0.  Use SWI12 mode iterator to also handle\n\tHImode operands.\n\t(*and<mode>_1_slp): Ditto.\n\t(*<code>qi_1_slp): Ditto.\n\t(*sub<mode>_1_slp): Use register_operand predicate for operand 0.\n\tDo not use (match_dup) to match operand 1 with operand 0.  Add\n\tcheck in insn constraint that operand 1 matches operand 0.\n\tUse SWI12 mode iterator to also handle HImode operands.\n\t(*ashl<mode>3_1_slp): Ditto.\n\t(*<shift_insn><mode>3_1_slp): Ditto.\n\t(*<rotate_insn><mode>3_1_slp): Ditto.\n\ntestsuite/ChangeLog:\n\n\tPR target/91188\n\t* gcc.target/i386/pr91188-1a.c: New test.\n\t* gcc.target/i386/pr91188-1b.c: Ditto.\n\t* gcc.target/i386/pr91188-1c.c: Ditto.\n\t* gcc.target/i386/pr91188-2a.c: Ditto.\n\t* gcc.target/i386/pr91188-2b.c: Ditto.\n\t* gcc.target/i386/pr91188-2c.c: Ditto.\n\nFrom-SVN: r273578", "tree": {"sha": "6249d46c573b8695de4b987c6c4c55f01b4e6de9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6249d46c573b8695de4b987c6c4c55f01b4e6de9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07d7662ff7ed987d98a61f333169b65620ec8202", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07d7662ff7ed987d98a61f333169b65620ec8202", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07d7662ff7ed987d98a61f333169b65620ec8202", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07d7662ff7ed987d98a61f333169b65620ec8202/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "36729568fbf96ea0d481344cf3ef559c74f59f95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36729568fbf96ea0d481344cf3ef559c74f59f95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36729568fbf96ea0d481344cf3ef559c74f59f95"}], "stats": {"total": 701, "additions": 603, "deletions": 98}, "files": [{"sha": "4a64253a3c039616d01ff23f85e0193d7fce2441", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07d7662ff7ed987d98a61f333169b65620ec8202", "patch": "@@ -1,3 +1,21 @@\n+2019-07-18  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/91188\n+\t* config/i386/i386.md (*addqi_1_slp): Use register_operand predicate\n+\tfor operand 0.  Do not use (match_dup) to match operand 1 with\n+\toperand 0.  Add check in insn constraint that either input operand\n+\tmatches operand 0.  Use SWI12 mode iterator to also handle\n+\tHImode operands.\n+\t(*and<mode>_1_slp): Ditto.\n+\t(*<code>qi_1_slp): Ditto.\n+\t(*sub<mode>_1_slp): Use register_operand predicate for operand 0.\n+\tDo not use (match_dup) to match operand 1 with operand 0.  Add\n+\tcheck in insn constraint that operand 1 matches operand 0.\n+\tUse SWI12 mode iterator to also handle HImode operands.\n+\t(*ashl<mode>3_1_slp): Ditto.\n+\t(*<shift_insn><mode>3_1_slp): Ditto.\n+\t(*<rotate_insn><mode>3_1_slp): Ditto.\n+\n 2019-07-18  Sylvia Taylor  <sylvia.taylor@arm.com>\n \n \t* config/arm/arm-builtins.c"}, {"sha": "4fc03009c53017791c1aca4942bc7e41118257fd", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 96, "deletions": 98, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=07d7662ff7ed987d98a61f333169b65620ec8202", "patch": "@@ -5583,41 +5583,39 @@\n \t      (symbol_ref \"!TARGET_PARTIAL_REG_STALL\")]\n \t   (symbol_ref \"true\")))])\n \n-(define_insn \"*addqi_1_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm,q\"))\n-\t(plus:QI (match_dup 0)\n-\t\t (match_operand:QI 1 \"general_operand\" \"qn,m\")))\n+(define_insn \"*add<mode>_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>\"))\n+\t(plus:SWI12 (match_operand:SWI12 1 \"nonimmediate_operand\" \"%0\")\n+\t\t    (match_operand:SWI12 2 \"general_operand\" \"<r>mn\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n+   /* FIXME: without this LRA can't reload this pattern, see PR82524.  */\n+   && (rtx_equal_p (operands[0], operands[1])\n+       || rtx_equal_p (operands[0], operands[2]))\"\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_INCDEC:\n-      if (operands[1] == const1_rtx)\n-\treturn \"inc{b}\\t%0\";\n+      if (operands[2] == const1_rtx)\n+\treturn \"inc{<imodesuffix>}\\t%0\";\n       else\n \t{\n-\t  gcc_assert (operands[1] == constm1_rtx);\n-\t  return \"dec{b}\\t%0\";\n+\t  gcc_assert (operands[2] == constm1_rtx);\n+\t  return \"dec{<imodesuffix>}\\t%0\";\n \t}\n \n     default:\n-      if (x86_maybe_negate_const_int (&operands[1], QImode))\n-\treturn \"sub{b}\\t{%1, %0|%0, %1}\";\n+      if (x86_maybe_negate_const_int (&operands[2], QImode))\n+\treturn \"sub{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n \n-      return \"add{b}\\t{%1, %0|%0, %1}\";\n+      return \"add{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n     }\n }\n   [(set (attr \"type\")\n-     (if_then_else (match_operand:QI 1 \"incdec_operand\")\n+     (if_then_else (match_operand:QI 2 \"incdec_operand\")\n \t(const_string \"incdec\")\n-\t(const_string \"alu1\")))\n-   (set (attr \"memory\")\n-     (if_then_else (match_operand 1 \"memory_operand\")\n-        (const_string \"load\")\n-        (const_string \"none\")))\n-   (set_attr \"mode\" \"QI\")])\n+\t(const_string \"alu\")))\n+   (set_attr \"mode\" \"<MODE>\")])\n \n ;; Split non destructive adds if we cannot use lea.\n (define_split\n@@ -6345,16 +6343,17 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*subqi_1_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm,q\"))\n-\t(minus:QI (match_dup 0)\n-\t\t  (match_operand:QI 1 \"general_operand\" \"qn,m\")))\n+(define_insn \"*sub<mode>_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>\"))\n+\t(minus:SWI12 (match_operand:SWI12 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:SWI12 2 \"general_operand\" \"<r>mn\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"sub{b}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"alu1\")\n-   (set_attr \"mode\" \"QI\")])\n+  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n+   /* FIXME: without this LRA can't reload this pattern, see PR82524.  */\n+   && rtx_equal_p (operands[0], operands[1])\"\n+  \"sub{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*sub<mode>_2\"\n   [(set (reg FLAGS_REG)\n@@ -8548,16 +8547,18 @@\n \t      (symbol_ref \"!TARGET_PARTIAL_REG_STALL\")]\n \t   (symbol_ref \"true\")))])\n \n-(define_insn \"*andqi_1_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm,q\"))\n-\t(and:QI (match_dup 0)\n-\t\t(match_operand:QI 1 \"general_operand\" \"qn,m\")))\n+(define_insn \"*and<mode>_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>\"))\n+\t(and:SWI12 (match_operand:SWI12 1 \"nonimmediate_operand\" \"%0\")\n+\t\t   (match_operand:SWI12 2 \"general_operand\" \"<r>mn\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"and{b}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"alu1\")\n-   (set_attr \"mode\" \"QI\")])\n+   /* FIXME: without this LRA can't reload this pattern, see PR82524.  */\n+   && (rtx_equal_p (operands[0], operands[1])\n+       || rtx_equal_p (operands[0], operands[2]))\"\n+  \"and{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_split\n   [(set (match_operand:SWI248 0 \"register_operand\")\n@@ -9098,16 +9099,18 @@\n \t      (symbol_ref \"!TARGET_PARTIAL_REG_STALL\")]\n \t   (symbol_ref \"true\")))])\n \n-(define_insn \"*<code>qi_1_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm,q\"))\n-\t(any_or:QI (match_dup 0)\n-\t\t   (match_operand:QI 1 \"general_operand\" \"qn,m\")))\n+(define_insn \"*<code><mode>_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>\"))\n+\t(any_or:SWI12 (match_operand:SWI12 1 \"nonimmediate_operand\" \"%0\")\n+\t\t      (match_operand:SWI12 2 \"general_operand\" \"<r>mn\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"<logic>{b}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"alu1\")\n-   (set_attr \"mode\" \"QI\")])\n+   /* FIXME: without this LRA can't reload this pattern, see PR82524.  */\n+   && (rtx_equal_p (operands[0], operands[1])\n+       || rtx_equal_p (operands[0], operands[2]))\"\n+  \"<logic>{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*<code><mode>_2\"\n   [(set (reg FLAGS_REG)\n@@ -9162,7 +9165,7 @@\n   \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n    && ix86_match_ccmode (insn, CCNOmode)\n    && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"<logic>{b}\\t{%1, %0|%0, %1}\"\n+  \"<logic>{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu1\")\n    (set_attr \"mode\" \"QI\")])\n \n@@ -10318,48 +10321,45 @@\n \t      (symbol_ref \"!TARGET_PARTIAL_REG_STALL\")]\n \t   (symbol_ref \"true\")))])\n \n-(define_insn \"*ashlqi3_1_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n-\t(ashift:QI (match_dup 0)\n-\t\t   (match_operand:QI 1 \"nonmemory_operand\" \"cI\")))\n+(define_insn \"*ashl<mode>3_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>\"))\n+\t(ashift:SWI12 (match_operand:SWI12 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"cI\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(optimize_function_for_size_p (cfun)\n-    || !TARGET_PARTIAL_FLAG_REG_STALL\n-    || (operands[1] == const1_rtx\n-\t&& (TARGET_SHIFT1\n-\t    || (TARGET_DOUBLE_WITH_ADD && REG_P (operands[0])))))\"\n+  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n+   /* FIXME: without this LRA can't reload this pattern, see PR82524.  */\n+   && rtx_equal_p (operands[0], operands[1])\"\n {\n   switch (get_attr_type (insn))\n     {\n-    case TYPE_ALU1:\n-      gcc_assert (operands[1] == const1_rtx);\n-      return \"add{b}\\t%0, %0\";\n+    case TYPE_ALU:\n+      gcc_assert (operands[2] == const1_rtx);\n+      return \"add{<imodesuffix>}\\t%0, %0\";\n \n     default:\n-      if (operands[1] == const1_rtx\n+      if (operands[2] == const1_rtx\n \t  && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{b}\\t%0\";\n+\treturn \"sal{<imodesuffix>}\\t%0\";\n       else\n-\treturn \"sal{b}\\t{%1, %0|%0, %1}\";\n+\treturn \"sal{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n     }\n }\n   [(set (attr \"type\")\n-     (cond [(and (and (match_test \"TARGET_DOUBLE_WITH_ADD\")\n-\t\t      (match_operand 0 \"register_operand\"))\n-\t\t (match_operand 1 \"const1_operand\"))\n-\t      (const_string \"alu1\")\n+     (cond [(and (match_test \"TARGET_DOUBLE_WITH_ADD\")\n+\t\t (match_operand 2 \"const1_operand\"))\n+\t      (const_string \"alu\")\n \t   ]\n-\t   (const_string \"ishift1\")))\n+\t   (const_string \"ishift\")))\n    (set (attr \"length_immediate\")\n      (if_then_else\n-       (ior (eq_attr \"type\" \"alu1\")\n-\t    (and (eq_attr \"type\" \"ishift1\")\n-\t\t (and (match_operand 1 \"const1_operand\")\n+       (ior (eq_attr \"type\" \"alu\")\n+\t    (and (eq_attr \"type\" \"ishift\")\n+\t\t (and (match_operand 2 \"const1_operand\")\n \t\t      (ior (match_test \"TARGET_SHIFT1\")\n \t\t\t   (match_test \"optimize_function_for_size_p (cfun)\")))))\n        (const_string \"0\")\n        (const_string \"*\")))\n-   (set_attr \"mode\" \"QI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n ;; Convert ashift to the lea pattern to avoid flags dependency.\n (define_split\n@@ -10937,31 +10937,30 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*<shift_insn>qi3_1_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n-\t(any_shiftrt:QI (match_dup 0)\n-\t\t\t(match_operand:QI 1 \"nonmemory_operand\" \"cI\")))\n+(define_insn \"*<shift_insn><mode>3_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>\"))\n+\t(any_shiftrt:SWI12 (match_operand:SWI12 1 \"register_operand\" \"0\")\n+\t\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(optimize_function_for_size_p (cfun)\n-    || !TARGET_PARTIAL_REG_STALL\n-    || (operands[1] == const1_rtx\n-\t&& TARGET_SHIFT1))\"\n+  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n+   /* FIXME: without this LRA can't reload this pattern, see PR82524.  */\n+   && rtx_equal_p (operands[0], operands[1])\"\n {\n-  if (operands[1] == const1_rtx\n+  if (operands[2] == const1_rtx\n       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-    return \"<shift>{b}\\t%0\";\n+    return \"<shift>{<imodesuffix>}\\t%0\";\n   else\n-    return \"<shift>{b}\\t{%1, %0|%0, %1}\";\n+    return \"<shift>{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n }\n-  [(set_attr \"type\" \"ishift1\")\n+  [(set_attr \"type\" \"ishift\")\n    (set (attr \"length_immediate\")\n      (if_then_else\n-       (and (match_operand 1 \"const1_operand\")\n+       (and (match_operand 2 \"const1_operand\")\n \t    (ior (match_test \"TARGET_SHIFT1\")\n \t\t (match_test \"optimize_function_for_size_p (cfun)\")))\n        (const_string \"0\")\n        (const_string \"*\")))\n-   (set_attr \"mode\" \"QI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n ;; This pattern can't accept a variable shift count, since shifts by\n ;; zero don't affect the flags.  We assume that shifts by constant\n@@ -11366,31 +11365,30 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*<rotate_insn>qi3_1_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n-\t(any_rotate:QI (match_dup 0)\n-\t\t       (match_operand:QI 1 \"nonmemory_operand\" \"cI\")))\n+(define_insn \"*<rotate_insn><mode>3_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>\"))\n+\t(any_rotate:SWI12 (match_operand:SWI12 1 \"register_operand\" \"0\")\n+\t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"cI\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(optimize_function_for_size_p (cfun)\n-    || !TARGET_PARTIAL_REG_STALL\n-    || (operands[1] == const1_rtx\n-\t&& TARGET_SHIFT1))\"\n+  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n+   /* FIXME: without this LRA can't reload this pattern, see PR82524.  */\n+   && rtx_equal_p (operands[0], operands[1])\"\n {\n-  if (operands[1] == const1_rtx\n+  if (operands[2] == const1_rtx\n       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-    return \"<rotate>{b}\\t%0\";\n+    return \"<rotate>{<imodesuffix>}\\t%0\";\n   else\n-    return \"<rotate>{b}\\t{%1, %0|%0, %1}\";\n+    return \"<rotate>{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n }\n-  [(set_attr \"type\" \"rotate1\")\n+  [(set_attr \"type\" \"rotate\")\n    (set (attr \"length_immediate\")\n      (if_then_else\n-       (and (match_operand 1 \"const1_operand\")\n+       (and (match_operand 2 \"const1_operand\")\n \t    (ior (match_test \"TARGET_SHIFT1\")\n \t\t (match_test \"optimize_function_for_size_p (cfun)\")))\n        (const_string \"0\")\n        (const_string \"*\")))\n-   (set_attr \"mode\" \"QI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_split\n  [(set (match_operand:HI 0 \"QIreg_operand\")"}, {"sha": "7eb95f7127d65c6c143e8271008c59fb3794a755", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=07d7662ff7ed987d98a61f333169b65620ec8202", "patch": "@@ -1,3 +1,13 @@\n+2019-07-18  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/91188\n+\t* gcc.target/i386/pr91188-1a.c: New test.\n+\t* gcc.target/i386/pr91188-1b.c: Ditto.\n+\t* gcc.target/i386/pr91188-1c.c: Ditto.\n+\t* gcc.target/i386/pr91188-2a.c: Ditto.\n+\t* gcc.target/i386/pr91188-2b.c: Ditto.\n+\t* gcc.target/i386/pr91188-2c.c: Ditto.\n+\n 2019-07-18  Sylvia Taylor  <sylvia.taylor@arm.com>\n \n         PR target/90317"}, {"sha": "8673c2a25cf5814911b3402e24f96784c3355cdb", "filename": "gcc/testsuite/gcc.target/i386/pr91188-1a.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-1a.c?ref=07d7662ff7ed987d98a61f333169b65620ec8202", "patch": "@@ -0,0 +1,63 @@\n+/* PR target/91188 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-additional-options \"-mregparm=3\" { target ia32 } } */\n+/* { dg-final { scan-assembler-not \"movzbl\" } } */\n+/* { dg-final { scan-assembler-not \"movb\" } } */\n+\n+struct S\n+{\n+  unsigned char val;\n+  unsigned char pad1;\n+  unsigned short pad2;\n+};\n+\n+struct S\n+test_and (struct S a, unsigned char b)\n+{\n+  a.val &= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]andb\" } } */\n+\n+struct S\n+test_or (struct S a, unsigned char b)\n+{\n+  a.val |= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]orb\" } } */\n+\n+struct S\n+test_xor (struct S a, unsigned char b)\n+{\n+  a.val ^= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]xorb\" } } */\n+\n+struct S\n+test_add (struct S a, unsigned char b)\n+{\n+  a.val += b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]addb\" } } */\n+\n+struct S\n+test_sub (struct S a, unsigned char b)\n+{\n+  a.val -= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]subb\" } } */"}, {"sha": "92949116306dc4e7f824241acb1369a1b699e4ed", "filename": "gcc/testsuite/gcc.target/i386/pr91188-1b.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-1b.c?ref=07d7662ff7ed987d98a61f333169b65620ec8202", "patch": "@@ -0,0 +1,65 @@\n+/* PR target/91188 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-additional-options \"-mregparm=3\" { target ia32 } } */\n+/* { dg-final { scan-assembler-not \"movzbl\" } } */\n+/* { dg-final { scan-assembler-not \"movb\" } } */\n+\n+struct S\n+{\n+  unsigned char val;\n+  unsigned char pad1;\n+  unsigned short pad2;\n+};\n+\n+unsigned char b;\n+\n+struct S\n+test_and (struct S a)\n+{\n+  a.val &= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]andb\" } } */\n+\n+struct S\n+test_or (struct S a)\n+{\n+  a.val |= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]orb\" } } */\n+\n+struct S\n+test_xor (struct S a)\n+{\n+  a.val ^= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]xorb\" } } */\n+\n+struct S\n+test_add (struct S a)\n+{\n+  a.val += b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]addb\" } } */\n+\n+struct S\n+test_sub (struct S a)\n+{\n+  a.val -= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]subb\" } } */"}, {"sha": "0b32420ea66c62f6370d12d2d3c0336750ddebba", "filename": "gcc/testsuite/gcc.target/i386/pr91188-1c.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-1c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-1c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-1c.c?ref=07d7662ff7ed987d98a61f333169b65620ec8202", "patch": "@@ -0,0 +1,113 @@\n+/* PR target/91188 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-additional-options \"-mregparm=3\" { target ia32 } } */\n+/* { dg-final { scan-assembler-not \"movzbl\" } } */\n+/* { dg-final { scan-assembler-not \"movb\" } } */\n+\n+struct S\n+{\n+  unsigned char val;\n+  unsigned char pad1;\n+  unsigned short pad2;\n+};\n+\n+struct S\n+test_and (struct S a)\n+{\n+  a.val &= 0x42;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]andb\" } } */\n+\n+struct S\n+test_or (struct S a)\n+{\n+  a.val |= 0x42;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]orb\" } } */\n+\n+struct S\n+test_xor (struct S a)\n+{\n+  a.val ^= 0x42;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]xorb\" } } */\n+\n+struct S\n+test_sal (struct S a)\n+{\n+  a.val <<= 3;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]salb\" } } */\n+\n+struct S\n+test_shr (struct S a)\n+{\n+  a.val >>= 3;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]shrb\" } } */\n+\n+struct S\n+test_sar (struct S a)\n+{\n+  a.val = (signed char) a.val >> 3;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]sarb\" } } */\n+\n+struct S\n+test_rol (struct S a)\n+{\n+  a.val = (a.val << 3 | a.val >> 5) ;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]rolb\" } } */\n+\n+struct S\n+test_ror (struct S a)\n+{\n+  a.val = (a.val >> 3 | a.val << 5) ;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]rorb\" } } */\n+\n+struct S\n+test_add (struct S a)\n+{\n+  a.val += 42;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]addb\" } } */\n+\n+struct S\n+test_sub (struct S a)\n+{\n+  a.val -= 42;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]subb\" } } */"}, {"sha": "65291145f5c05e0c949281e30a03409d9a3f5fc9", "filename": "gcc/testsuite/gcc.target/i386/pr91188-2a.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-2a.c?ref=07d7662ff7ed987d98a61f333169b65620ec8202", "patch": "@@ -0,0 +1,62 @@\n+/* PR target/91188 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-additional-options \"-mregparm=3\" { target ia32 } } */\n+/* { dg-final { scan-assembler-not \"movzwl\" } } */\n+/* { dg-final { scan-assembler-not \"movw\" } } */\n+\n+struct S\n+{\n+  unsigned short val;\n+  unsigned short pad;\n+};\n+\n+struct S\n+test_and (struct S a, unsigned short b)\n+{\n+  a.val &= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]andw\" } } */\n+\n+struct S\n+test_or (struct S a, unsigned short b)\n+{\n+  a.val |= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]orw\" } } */\n+\n+struct S\n+test_xor (struct S a, unsigned short b)\n+{\n+  a.val ^= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]xorw\" } } */\n+\n+struct S\n+test_add (struct S a, unsigned short b)\n+{\n+  a.val += b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]addw\" } } */\n+\n+struct S\n+test_sub (struct S a, unsigned short b)\n+{\n+  a.val -= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]subw\" } } */"}, {"sha": "cdaeae094f9e430d0149fa708ed94a077d9921f3", "filename": "gcc/testsuite/gcc.target/i386/pr91188-2b.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-2b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-2b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-2b.c?ref=07d7662ff7ed987d98a61f333169b65620ec8202", "patch": "@@ -0,0 +1,64 @@\n+/* PR target/91188 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-additional-options \"-mregparm=3\" { target ia32 } } */\n+/* { dg-final { scan-assembler-not \"movzwl\" } } */\n+/* { dg-final { scan-assembler-not \"movw\" } } */\n+\n+struct S\n+{\n+  unsigned short val;\n+  unsigned short pad;\n+};\n+\n+unsigned short b;\n+\n+struct S\n+test_and (struct S a)\n+{\n+  a.val &= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]andw\" } } */\n+\n+struct S\n+test_or (struct S a)\n+{\n+  a.val |= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]orw\" } } */\n+\n+struct S\n+test_xor (struct S a)\n+{\n+  a.val ^= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]xorw\" } } */\n+\n+struct S\n+test_add (struct S a)\n+{\n+  a.val += b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]addw\" } } */\n+\n+struct S\n+test_sub (struct S a)\n+{\n+  a.val -= b;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]subw\" } } */"}, {"sha": "c84e9c5b1ea98c5808d8d559e263fab136e06044", "filename": "gcc/testsuite/gcc.target/i386/pr91188-2c.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-2c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07d7662ff7ed987d98a61f333169b65620ec8202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-2c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91188-2c.c?ref=07d7662ff7ed987d98a61f333169b65620ec8202", "patch": "@@ -0,0 +1,112 @@\n+/* PR target/91188 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-additional-options \"-mregparm=3\" { target ia32 } } */\n+/* { dg-final { scan-assembler-not \"movzwl\" } } */\n+/* { dg-final { scan-assembler-not \"movw\" } } */\n+\n+struct S\n+{\n+  unsigned short val;\n+  unsigned short pad;\n+};\n+\n+struct S\n+test_and (struct S a)\n+{\n+  a.val &= 0x42;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]andw\" } } */\n+\n+struct S\n+test_or (struct S a)\n+{\n+  a.val |= 0x42;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]orw\" } } */\n+\n+struct S\n+test_xor (struct S a)\n+{\n+  a.val ^= 0x42;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]xorw\" } } */\n+\n+struct S\n+test_sal (struct S a)\n+{\n+  a.val <<= 3;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]salw\" } } */\n+\n+struct S\n+test_shr (struct S a)\n+{\n+  a.val >>= 3;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]shrw\" } } */\n+\n+struct S\n+test_sar (struct S a)\n+{\n+  a.val = (signed short) a.val >> 3;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]sarw\" } } */\n+\n+struct S\n+test_rol (struct S a)\n+{\n+  a.val = (a.val << 3 | a.val >> 13) ;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]rolw\" } } */\n+\n+struct S\n+test_ror (struct S a)\n+{\n+  a.val = (a.val >> 3 | a.val << 13) ;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]rorw\" } } */\n+\n+struct S\n+test_add (struct S a)\n+{\n+  a.val += 42;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]addw\" } } */\n+\n+struct S\n+test_sub (struct S a)\n+{\n+  a.val -= 42;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]subw\" } } */"}]}