{"sha": "b73a6056563470e5b99e79a0dc769c351e906e6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjczYTYwNTY1NjM0NzBlNWI5OWU3OWEwZGM3NjljMzUxZTkwNmU2ZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2007-01-28T05:04:48Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-01-28T05:04:48Z"}, "message": "tree.c (tree_fold_gcd): Delete.\n\n\n\t* tree.c (tree_fold_gcd): Delete.\n\t* tree.h (tree_fold_gcd): Remove prototype.\n\t* tree-data-ref.c (tree_fold_divides_p): Don't use tree_fold_gcd to\n\ttest whether one constant integer is a multiple of another.  Instead\n\tcall int_const_binop with TRUNC_MOD_EXPR and test for a zero result.\n\t* fold-const.c (multiple_of_p):  We've determined both TOP and\n\tBOTTOM are integer constants so we can call int_const_binop directly\n\tinstead of the more generic const_binop.\n\nFrom-SVN: r121253", "tree": {"sha": "d5119687bedfd7a7f56d6218696508ae430f8416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5119687bedfd7a7f56d6218696508ae430f8416"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b73a6056563470e5b99e79a0dc769c351e906e6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b73a6056563470e5b99e79a0dc769c351e906e6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b73a6056563470e5b99e79a0dc769c351e906e6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b73a6056563470e5b99e79a0dc769c351e906e6e/comments", "author": null, "committer": null, "parents": [{"sha": "74890d7bbdacf14edfcd1e50bac0e5053a2bdf53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74890d7bbdacf14edfcd1e50bac0e5053a2bdf53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74890d7bbdacf14edfcd1e50bac0e5053a2bdf53"}], "stats": {"total": 62, "additions": 17, "deletions": 45}, "files": [{"sha": "6d3de89adaa2fe3b26e4f128f590249adb90f1b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b73a6056563470e5b99e79a0dc769c351e906e6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b73a6056563470e5b99e79a0dc769c351e906e6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b73a6056563470e5b99e79a0dc769c351e906e6e", "patch": "@@ -1,3 +1,14 @@\n+2007-01-27  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* tree.c (tree_fold_gcd): Delete.\n+\t* tree.h (tree_fold_gcd): Remove prototype.\n+\t* tree-data-ref.c (tree_fold_divides_p): Don't use tree_fold_gcd to\n+\ttest whether one constant integer is a multiple of another.  Instead\n+\tcall int_const_binop with TRUNC_MOD_EXPR and test for a zero result.\n+\t* fold-const.c (multiple_of_p):  We've determined both TOP and\n+\tBOTTOM are integer constants so we can call int_const_binop directly\n+\tinstead of the more generic const_binop.\n+\n 2007-01-27  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (size_binop): In the fast-paths for X+0, 0+X, X-0 and"}, {"sha": "34ff7111072eb910d37108848657e1cf9526c162", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b73a6056563470e5b99e79a0dc769c351e906e6e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b73a6056563470e5b99e79a0dc769c351e906e6e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b73a6056563470e5b99e79a0dc769c351e906e6e", "patch": "@@ -12527,8 +12527,8 @@ multiple_of_p (tree type, tree top, tree bottom)\n \t      && (tree_int_cst_sgn (top) < 0\n \t\t  || tree_int_cst_sgn (bottom) < 0)))\n \treturn 0;\n-      return integer_zerop (const_binop (TRUNC_MOD_EXPR,\n-\t\t\t\t\t top, bottom, 0));\n+      return integer_zerop (int_const_binop (TRUNC_MOD_EXPR,\n+\t\t\t\t\t     top, bottom, 0));\n \n     default:\n       return 0;"}, {"sha": "d6201b6cf60db3ce7ade6ee2913b82c30408ff92", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b73a6056563470e5b99e79a0dc769c351e906e6e/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b73a6056563470e5b99e79a0dc769c351e906e6e/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=b73a6056563470e5b99e79a0dc769c351e906e6e", "patch": "@@ -561,11 +561,11 @@ base_addr_differ_p (struct data_reference *dra,\n /* Returns true iff A divides B.  */\n \n static inline bool \n-tree_fold_divides_p (tree a, \n-\t\t     tree b)\n+tree_fold_divides_p (tree a, tree b)\n {\n-  /* Determines whether (A == gcd (A, B)).  */\n-  return tree_int_cst_equal (a, tree_fold_gcd (a, b));\n+  gcc_assert (TREE_CODE (a) == INTEGER_CST);\n+  gcc_assert (TREE_CODE (b) == INTEGER_CST);\n+  return integer_zerop (int_const_binop (TRUNC_MOD_EXPR, b, a, 0));\n }\n \n /* Returns true iff A divides B.  */"}, {"sha": "6824c14d16cffb218a6702a7928bbd4216841328", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b73a6056563470e5b99e79a0dc769c351e906e6e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b73a6056563470e5b99e79a0dc769c351e906e6e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b73a6056563470e5b99e79a0dc769c351e906e6e", "patch": "@@ -7465,44 +7465,6 @@ int_cst_value (tree x)\n   return val;\n }\n \n-/* Returns the greatest common divisor of A and B, which must be\n-   INTEGER_CSTs.  */\n-\n-tree\n-tree_fold_gcd (tree a, tree b)\n-{\n-  tree a_mod_b;\n-  tree type = TREE_TYPE (a);\n-\n-  gcc_assert (TREE_CODE (a) == INTEGER_CST);\n-  gcc_assert (TREE_CODE (b) == INTEGER_CST);\n-\n-  if (integer_zerop (a))\n-    return b;\n-\n-  if (integer_zerop (b))\n-    return a;\n-\n-  if (tree_int_cst_sgn (a) == -1)\n-    a = fold_build2 (MULT_EXPR, type, a,\n-\t\t     build_int_cst (type, -1));\n-\n-  if (tree_int_cst_sgn (b) == -1)\n-    b = fold_build2 (MULT_EXPR, type, b,\n-\t\t     build_int_cst (type, -1));\n-\n-  while (1)\n-    {\n-      a_mod_b = fold_build2 (FLOOR_MOD_EXPR, type, a, b);\n-\n-      if (!TREE_INT_CST_LOW (a_mod_b)\n-\t  && !TREE_INT_CST_HIGH (a_mod_b))\n-\treturn b;\n-\n-      a = b;\n-      b = a_mod_b;\n-    }\n-}\n \n /* Returns unsigned variant of TYPE.  */\n "}, {"sha": "ddb7e6af24d9573dd97e426e38de33722611c4cb", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b73a6056563470e5b99e79a0dc769c351e906e6e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b73a6056563470e5b99e79a0dc769c351e906e6e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b73a6056563470e5b99e79a0dc769c351e906e6e", "patch": "@@ -4454,7 +4454,6 @@ extern void build_common_builtin_nodes (void);\n extern tree build_nonstandard_integer_type (unsigned HOST_WIDE_INT, int);\n extern tree build_range_type (tree, tree, tree);\n extern HOST_WIDE_INT int_cst_value (tree);\n-extern tree tree_fold_gcd (tree, tree);\n extern tree build_addr (tree, tree);\n \n extern bool fields_compatible_p (tree, tree);"}]}