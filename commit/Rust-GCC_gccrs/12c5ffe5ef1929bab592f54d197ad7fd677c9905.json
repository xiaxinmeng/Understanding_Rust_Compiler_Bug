{"sha": "12c5ffe5ef1929bab592f54d197ad7fd677c9905", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJjNWZmZTVlZjE5MjliYWI1OTJmNTRkMTk3YWQ3ZmQ2NzdjOTkwNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-07-15T17:09:56Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-07-15T17:09:56Z"}, "message": "re PR debug/48220 (DW_OP_GNU_entry_value/DW_TAG_GNU_call_site_parameter vs register window)\n\n\tPR target/48220\n\t* doc/md.texi (Standard Names): Document window_save.\n\t* cfgexpand.c (expand_debug_parm_decl): New function extracted from\n\texpand_debug_expr and expand_debug_source_expr.  If the target has\n\ta window_save instruction, adjust the ENTRY_VALUE_EXP.\n\t(expand_debug_expr) <SSA_NAME>: Call expand_debug_parm_decl if the\n\tSSA_NAME_VAR is a parameter.\n\t(expand_debug_source_expr) <PARM_DECL>: Call expand_debug_parm_decl.\n\t* var-tracking.c (parm_reg_t): New type and associated vector type.\n\t(windowed_parm_regs): New variable.\n\t(adjust_insn): If the target has a window_save instruction and this\n\tis the instruction, make its effect on parameter registers explicit.\n\t(next_non_note_insn_var_location): New function.\n\t(emit_notes_in_bb): Use it instead of NEXT_INSN throughout.\n\t(vt_add_function_parameter): If the target has a window_save insn,\n\tadjust the incoming RTL and record that in windowed_parm_regs.\n\t(vt_finalize): Free windowed_parm_regs.\n\nFrom-SVN: r176318", "tree": {"sha": "50c59d144fb0377196004267e3d65142ab7825c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50c59d144fb0377196004267e3d65142ab7825c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12c5ffe5ef1929bab592f54d197ad7fd677c9905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c5ffe5ef1929bab592f54d197ad7fd677c9905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12c5ffe5ef1929bab592f54d197ad7fd677c9905", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c5ffe5ef1929bab592f54d197ad7fd677c9905/comments", "author": null, "committer": null, "parents": [{"sha": "021a9e7ef276ac9c00e72a5fd676f20b6d6b36c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/021a9e7ef276ac9c00e72a5fd676f20b6d6b36c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/021a9e7ef276ac9c00e72a5fd676f20b6d6b36c0"}], "stats": {"total": 248, "additions": 186, "deletions": 62}, "files": [{"sha": "fdcb498ed99faf3d5184d61a3e68eb2c0ae2a00a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c5ffe5ef1929bab592f54d197ad7fd677c9905/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c5ffe5ef1929bab592f54d197ad7fd677c9905/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12c5ffe5ef1929bab592f54d197ad7fd677c9905", "patch": "@@ -1,3 +1,23 @@\n+2011-07-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR target/48220\n+\t* doc/md.texi (Standard Names): Document window_save.\n+\t* cfgexpand.c (expand_debug_parm_decl): New function extracted from\n+\texpand_debug_expr and expand_debug_source_expr.  If the target has\n+\ta window_save instruction, adjust the ENTRY_VALUE_EXP.\n+\t(expand_debug_expr) <SSA_NAME>: Call expand_debug_parm_decl if the\n+\tSSA_NAME_VAR is a parameter.\n+\t(expand_debug_source_expr) <PARM_DECL>: Call expand_debug_parm_decl.\n+\t* var-tracking.c (parm_reg_t): New type and associated vector type.\n+\t(windowed_parm_regs): New variable.\n+\t(adjust_insn): If the target has a window_save instruction and this\n+\tis the instruction, make its effect on parameter registers explicit.\n+\t(next_non_note_insn_var_location): New function.\n+\t(emit_notes_in_bb): Use it instead of NEXT_INSN throughout.\n+\t(vt_add_function_parameter): If the target has a window_save insn,\n+\tadjust the incoming RTL and record that in windowed_parm_regs.\n+\t(vt_finalize): Free windowed_parm_regs.\n+\n 2011-07-15  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* doc/invoke.texi (C6X Options): New section."}, {"sha": "f87308c72a077fe42192ac1247c5b1534c8470d9", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 63, "deletions": 57, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c5ffe5ef1929bab592f54d197ad7fd677c9905/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c5ffe5ef1929bab592f54d197ad7fd677c9905/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=12c5ffe5ef1929bab592f54d197ad7fd677c9905", "patch": "@@ -2358,8 +2358,60 @@ convert_debug_memory_address (enum machine_mode mode, rtx x,\n   return x;\n }\n \n-/* Return an RTX equivalent to the value of the tree expression\n-   EXP.  */\n+/* Return an RTX equivalent to the value of the parameter DECL.  */\n+\n+static rtx\n+expand_debug_parm_decl (tree decl)\n+{\n+  rtx incoming = DECL_INCOMING_RTL (decl);\n+\n+  if (incoming\n+      && GET_MODE (incoming) != BLKmode\n+      && ((REG_P (incoming) && HARD_REGISTER_P (incoming))\n+\t  || (MEM_P (incoming)\n+\t      && REG_P (XEXP (incoming, 0))\n+\t      && HARD_REGISTER_P (XEXP (incoming, 0)))))\n+    {\n+      rtx rtl = gen_rtx_ENTRY_VALUE (GET_MODE (incoming));\n+\n+#ifdef HAVE_window_save\n+      /* DECL_INCOMING_RTL uses the INCOMING_REGNO of parameter registers.\n+\t If the target machine has an explicit window save instruction, the\n+\t actual entry value is the corresponding OUTGOING_REGNO instead.  */\n+      if (REG_P (incoming)\n+\t  && OUTGOING_REGNO (REGNO (incoming)) != REGNO (incoming))\n+\tincoming\n+\t  = gen_rtx_REG_offset (incoming, GET_MODE (incoming),\n+\t\t\t\tOUTGOING_REGNO (REGNO (incoming)), 0);\n+      else if (MEM_P (incoming))\n+\t{\n+\t  rtx reg = XEXP (incoming, 0);\n+\t  if (OUTGOING_REGNO (REGNO (reg)) != REGNO (reg))\n+\t    {\n+\t      reg = gen_raw_REG (GET_MODE (reg), OUTGOING_REGNO (REGNO (reg)));\n+\t      incoming = replace_equiv_address_nv (incoming, reg);\n+\t    }\n+\t}\n+#endif\n+\n+      ENTRY_VALUE_EXP (rtl) = incoming;\n+      return rtl;\n+    }\n+\n+  if (incoming\n+      && GET_MODE (incoming) != BLKmode\n+      && !TREE_ADDRESSABLE (decl)\n+      && MEM_P (incoming)\n+      && (XEXP (incoming, 0) == virtual_incoming_args_rtx\n+\t  || (GET_CODE (XEXP (incoming, 0)) == PLUS\n+\t      && XEXP (XEXP (incoming, 0), 0) == virtual_incoming_args_rtx\n+\t      && CONST_INT_P (XEXP (XEXP (incoming, 0), 1)))))\n+    return incoming;\n+\n+  return NULL_RTX;\n+}\n+\n+/* Return an RTX equivalent to the value of the tree expression EXP.  */\n \n static rtx\n expand_debug_expr (tree exp)\n@@ -3169,36 +3221,12 @@ expand_debug_expr (tree exp)\n \t\tif (SSA_NAME_IS_DEFAULT_DEF (exp)\n \t\t    && TREE_CODE (SSA_NAME_VAR (exp)) == PARM_DECL)\n \t\t  {\n-\t\t    rtx incoming = DECL_INCOMING_RTL (SSA_NAME_VAR (exp));\n-\t\t    if (incoming\n-\t\t\t&& GET_MODE (incoming) != BLKmode\n-\t\t\t&& ((REG_P (incoming) && HARD_REGISTER_P (incoming))\n-\t\t\t    || (MEM_P (incoming)\n-\t\t\t\t&& REG_P (XEXP (incoming, 0))\n-\t\t\t\t&& HARD_REGISTER_P (XEXP (incoming, 0)))))\n-\t\t      {\n-\t\t\top0 = gen_rtx_ENTRY_VALUE (GET_MODE (incoming));\n-\t\t\tENTRY_VALUE_EXP (op0) = incoming;\n-\t\t\tgoto adjust_mode;\n-\t\t      }\n-\t\t    if (incoming\n-\t\t\t&& MEM_P (incoming)\n-\t\t\t&& !TREE_ADDRESSABLE (SSA_NAME_VAR (exp))\n-\t\t\t&& GET_MODE (incoming) != BLKmode\n-\t\t\t&& (XEXP (incoming, 0) == virtual_incoming_args_rtx\n-\t\t\t    || (GET_CODE (XEXP (incoming, 0)) == PLUS\n-\t\t\t\t&& XEXP (XEXP (incoming, 0), 0)\n-\t\t\t\t   == virtual_incoming_args_rtx\n-\t\t\t\t&& CONST_INT_P (XEXP (XEXP (incoming, 0),\n-\t\t\t\t\t\t      1)))))\n-\t\t      {\n-\t\t\top0 = incoming;\n-\t\t\tgoto adjust_mode;\n-\t\t      }\n+\t\t    op0 = expand_debug_parm_decl (SSA_NAME_VAR (exp));\n+\t\t    if (op0)\n+\t\t      goto adjust_mode;\n \t\t    op0 = expand_debug_expr (SSA_NAME_VAR (exp));\n-\t\t    if (!op0)\n-\t\t      return NULL;\n-\t\t    goto adjust_mode;\n+\t\t    if (op0)\n+\t\t      goto adjust_mode;\n \t\t  }\n \t\treturn NULL;\n \t      }\n@@ -3327,36 +3355,14 @@ expand_debug_source_expr (tree exp)\n     {\n     case PARM_DECL:\n       {\n-\trtx incoming = DECL_INCOMING_RTL (exp);\n \tmode = DECL_MODE (exp);\n-\tif (incoming\n-\t    && GET_MODE (incoming) != BLKmode\n-\t    && ((REG_P (incoming) && HARD_REGISTER_P (incoming))\n-\t\t|| (MEM_P (incoming)\n-\t\t    && REG_P (XEXP (incoming, 0))\n-\t\t    && HARD_REGISTER_P (XEXP (incoming, 0)))))\n-\t  {\n-\t    op0 = gen_rtx_ENTRY_VALUE (GET_MODE (incoming));\n-\t    ENTRY_VALUE_EXP (op0) = incoming;\n-\t    break;\n-\t  }\n-\tif (incoming\n-\t    && MEM_P (incoming)\n-\t    && !TREE_ADDRESSABLE (exp)\n-\t    && GET_MODE (incoming) != BLKmode\n-\t    && (XEXP (incoming, 0) == virtual_incoming_args_rtx\n-\t\t|| (GET_CODE (XEXP (incoming, 0)) == PLUS\n-\t\t    && XEXP (XEXP (incoming, 0), 0)\n-\t\t       == virtual_incoming_args_rtx\n-\t\t    && CONST_INT_P (XEXP (XEXP (incoming, 0), 1)))))\n-\t  {\n-\t    op0 = incoming;\n-\t    break;\n-\t  }\n+\top0 = expand_debug_parm_decl (exp);\n+\tif (op0)\n+\t   break;\n \t/* See if this isn't an argument that has been completely\n \t   optimized out.  */\n \tif (!DECL_RTL_SET_P (exp)\n-\t    && incoming == NULL_RTX\n+\t    && !DECL_INCOMING_RTL (exp)\n \t    && DECL_ABSTRACT_ORIGIN (current_function_decl))\n \t  {\n \t    tree aexp = exp;"}, {"sha": "1f08daee4f29e3140692c9eff87085fd9694cee3", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c5ffe5ef1929bab592f54d197ad7fd677c9905/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c5ffe5ef1929bab592f54d197ad7fd677c9905/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=12c5ffe5ef1929bab592f54d197ad7fd677c9905", "patch": "@@ -5333,6 +5333,14 @@ Using a prologue pattern is generally preferred over defining\n The @code{prologue} pattern is particularly useful for targets which perform\n instruction scheduling.\n \n+@cindex @code{window_save} instruction pattern\n+@anchor{window_save instruction pattern}\n+@item @samp{window_save}\n+This pattern, if defined, emits RTL for a register window save.  It should\n+be defined if the target machine has register windows but the window events\n+are decoupled from calls to subroutines.  The canonical example is the SPARC\n+architecture.\n+\n @cindex @code{epilogue} instruction pattern\n @anchor{epilogue instruction pattern}\n @item @samp{epilogue}"}, {"sha": "4842b780201ece394d839cf8dcb46f155ac1e444", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 95, "deletions": 5, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c5ffe5ef1929bab592f54d197ad7fd677c9905/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c5ffe5ef1929bab592f54d197ad7fd677c9905/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=12c5ffe5ef1929bab592f54d197ad7fd677c9905", "patch": "@@ -34,7 +34,7 @@\n    operations.\n    The micro operations of one instruction are ordered so that\n    pre-modifying stack adjustment < use < use with no var < call insn <\n-     < set < clobber < post-modifying stack adjustment\n+     < clobber < set < post-modifying stack adjustment\n \n    Then, a forward dataflow analysis is performed to find out how locations\n    of variables change through code and to propagate the variable locations\n@@ -400,6 +400,17 @@ static shared_hash empty_shared_hash;\n /* Scratch register bitmap used by cselib_expand_value_rtx.  */\n static bitmap scratch_regs = NULL;\n \n+typedef struct GTY(()) parm_reg {\n+  rtx outgoing;\n+  rtx incoming;\n+} parm_reg_t;\n+\n+DEF_VEC_O(parm_reg_t);\n+DEF_VEC_ALLOC_O(parm_reg_t, gc);\n+\n+/* Vector of windowed parameter registers, if any.  */\n+static VEC(parm_reg_t, gc) *windowed_parm_regs = NULL;\n+\n /* Variable used to tell whether cselib_process_insn called our hook.  */\n static bool cselib_hook_called;\n \n@@ -970,6 +981,33 @@ adjust_insn (basic_block bb, rtx insn)\n {\n   struct adjust_mem_data amd;\n   rtx set;\n+\n+#ifdef HAVE_window_save\n+  /* If the target machine has an explicit window save instruction, the\n+     transformation OUTGOING_REGNO -> INCOMING_REGNO is done there.  */\n+  if (RTX_FRAME_RELATED_P (insn)\n+      && find_reg_note (insn, REG_CFA_WINDOW_SAVE, NULL_RTX))\n+    {\n+      unsigned int i, nregs = VEC_length(parm_reg_t, windowed_parm_regs);\n+      rtx rtl = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (nregs * 2));\n+      parm_reg_t *p;\n+\n+      FOR_EACH_VEC_ELT (parm_reg_t, windowed_parm_regs, i, p)\n+\t{\n+\t  XVECEXP (rtl, 0, i * 2)\n+\t    = gen_rtx_SET (VOIDmode, p->incoming, p->outgoing);\n+\t  /* Do not clobber the attached DECL, but only the REG.  */\n+\t  XVECEXP (rtl, 0, i * 2 + 1)\n+\t    = gen_rtx_CLOBBER (GET_MODE (p->outgoing),\n+\t\t\t       gen_raw_REG (GET_MODE (p->outgoing),\n+\t\t\t\t\t    REGNO (p->outgoing)));\n+\t}\n+\n+      validate_change (NULL_RTX, &PATTERN (insn), rtl, true);\n+      return;\n+    }\n+#endif\n+\n   amd.mem_mode = VOIDmode;\n   amd.stack_adjust = -VTI (bb)->out.stack_adjust;\n   amd.side_effects = NULL_RTX;\n@@ -8002,6 +8040,23 @@ emit_notes_for_differences (rtx insn, dataflow_set *old_set,\n   emit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN, new_set->vars);\n }\n \n+/* Return the next insn after INSN that is not a NOTE_INSN_VAR_LOCATION.  */\n+\n+static rtx\n+next_non_note_insn_var_location (rtx insn)\n+{\n+  while (insn)\n+    {\n+      insn = NEXT_INSN (insn);\n+      if (insn == 0\n+\t  || !NOTE_P (insn)\n+\t  || NOTE_KIND (insn) != NOTE_INSN_VAR_LOCATION)\n+\tbreak;\n+    }\n+\n+  return insn;\n+}\n+\n /* Emit the notes for changes of location parts in the basic block BB.  */\n \n static void\n@@ -8016,6 +8071,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n   FOR_EACH_VEC_ELT (micro_operation, VTI (bb)->mos, i, mo)\n     {\n       rtx insn = mo->insn;\n+      rtx next_insn = next_non_note_insn_var_location (insn);\n \n       switch (mo->type)\n \t{\n@@ -8222,7 +8278,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \t\tval_store (set, XEXP (reverse, 0), XEXP (reverse, 1),\n \t\t\t   insn, false);\n \n-\t      emit_notes_for_changes (NEXT_INSN (insn), EMIT_NOTE_BEFORE_INSN,\n+\t      emit_notes_for_changes (next_insn, EMIT_NOTE_BEFORE_INSN,\n \t\t\t\t      set->vars);\n \t    }\n \t    break;\n@@ -8245,7 +8301,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \t\tvar_mem_delete_and_set (set, loc, true, VAR_INIT_STATUS_INITIALIZED,\n \t\t\t\t\tset_src);\n \n-\t      emit_notes_for_changes (NEXT_INSN (insn), EMIT_NOTE_BEFORE_INSN,\n+\t      emit_notes_for_changes (next_insn, EMIT_NOTE_BEFORE_INSN,\n \t\t\t\t      set->vars);\n \t    }\n \t    break;\n@@ -8270,7 +8326,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \t      else\n \t\tvar_mem_delete_and_set (set, loc, false, src_status, set_src);\n \n-\t      emit_notes_for_changes (NEXT_INSN (insn), EMIT_NOTE_BEFORE_INSN,\n+\t      emit_notes_for_changes (next_insn, EMIT_NOTE_BEFORE_INSN,\n \t\t\t\t      set->vars);\n \t    }\n \t    break;\n@@ -8297,7 +8353,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \t      else\n \t\tvar_mem_delete (set, loc, true);\n \n-\t      emit_notes_for_changes (NEXT_INSN (insn), EMIT_NOTE_BEFORE_INSN,\n+\t      emit_notes_for_changes (next_insn, EMIT_NOTE_BEFORE_INSN,\n \t\t\t\t      set->vars);\n \t    }\n \t    break;\n@@ -8483,6 +8539,39 @@ vt_add_function_parameter (tree parm)\n \t\t\t\t    plus_constant (arg_pointer_rtx, off));\n     }\n \n+#ifdef HAVE_window_save\n+  /* DECL_INCOMING_RTL uses the INCOMING_REGNO of parameter registers.\n+     If the target machine has an explicit window save instruction, the\n+     actual entry value is the corresponding OUTGOING_REGNO instead.  */\n+  if (REG_P (incoming)\n+      && HARD_REGISTER_P (incoming)\n+      && OUTGOING_REGNO (REGNO (incoming)) != REGNO (incoming))\n+    {\n+      parm_reg_t *p\n+\t= VEC_safe_push (parm_reg_t, gc, windowed_parm_regs, NULL);\n+      p->incoming = incoming;\n+      incoming\n+\t= gen_rtx_REG_offset (incoming, GET_MODE (incoming),\n+\t\t\t      OUTGOING_REGNO (REGNO (incoming)), 0);\n+      p->outgoing = incoming;\n+    }\n+  else if (MEM_P (incoming)\n+\t   && REG_P (XEXP (incoming, 0))\n+\t   && HARD_REGISTER_P (XEXP (incoming, 0)))\n+    {\n+      rtx reg = XEXP (incoming, 0);\n+      if (OUTGOING_REGNO (REGNO (reg)) != REGNO (reg))\n+\t{\n+\t  parm_reg_t *p\n+\t    = VEC_safe_push (parm_reg_t, gc, windowed_parm_regs, NULL);\n+\t  p->incoming = reg;\n+\t  reg = gen_raw_REG (GET_MODE (reg), OUTGOING_REGNO (REGNO (reg)));\n+\t  p->outgoing = reg;\n+\t  incoming = replace_equiv_address_nv (incoming, reg);\n+\t}\n+    }\n+#endif\n+\n   if (!vt_get_decl_and_offset (incoming, &decl, &offset))\n     {\n       if (REG_P (incoming) || MEM_P (incoming))\n@@ -9046,6 +9135,7 @@ vt_finalize (void)\n       cselib_finish ();\n       BITMAP_FREE (scratch_regs);\n       scratch_regs = NULL;\n+      VEC_free (parm_reg_t, gc, windowed_parm_regs);\n     }\n \n   if (vui_vec)"}]}