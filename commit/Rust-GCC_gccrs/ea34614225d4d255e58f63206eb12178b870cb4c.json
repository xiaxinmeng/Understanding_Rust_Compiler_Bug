{"sha": "ea34614225d4d255e58f63206eb12178b870cb4c", "node_id": "C_kwDOANBUbNoAKGVhMzQ2MTQyMjVkNGQyNTVlNThmNjMyMDZlYjEyMTc4Yjg3MGNiNGM", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-23T15:44:42Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:07Z"}, "message": "gccrs: Compiler proper interface kicks off the pipeline\n\nThis is a wrapper to get out of C land in the rust-lang.cc and into our\nclass hierarchy for the rust front-end. We expect that the front-end only\nsupport one source file input as the expansion pass will attempt to resolve\nthat relative pass and parse accordingly.\n\nThe main missing piece here is that we are using saw_errors() to return\nearly which is unnecessary but as our error handling has been improving\nover time we will start to take advantage of error node in our type system\nas well as error_mark_node from GCC. The caveat being that our lints/checks\nexpect no errors and will throw an assertion.\n\n\tgcc/rust/\n\t* rust-lang.cc: New.\n\t* rust-session-manager.cc: New.\n\t* rust-session-manager.h: New.", "tree": {"sha": "f636c093e1f14f58363f02e7c8ac749ec0158ce8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f636c093e1f14f58363f02e7c8ac749ec0158ce8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea34614225d4d255e58f63206eb12178b870cb4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea34614225d4d255e58f63206eb12178b870cb4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea34614225d4d255e58f63206eb12178b870cb4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea34614225d4d255e58f63206eb12178b870cb4c/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bba14a0790f0858f76118bbb9b3a8231eb241138", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bba14a0790f0858f76118bbb9b3a8231eb241138", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bba14a0790f0858f76118bbb9b3a8231eb241138"}], "stats": {"total": 2003, "additions": 2003, "deletions": 0}, "files": [{"sha": "241a9b4dae309a971be273b1666ca7df6c730415", "filename": "gcc/rust/rust-lang.cc", "status": "added", "additions": 456, "deletions": 0, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea34614225d4d255e58f63206eb12178b870cb4c/gcc%2Frust%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea34614225d4d255e58f63206eb12178b870cb4c/gcc%2Frust%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.cc?ref=ea34614225d4d255e58f63206eb12178b870cb4c", "patch": "@@ -0,0 +1,456 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-system.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"tree.h\"\n+#include \"gimple-expr.h\"\n+#include \"diagnostic.h\"\n+#include \"opts.h\"\n+#include \"fold-const.h\"\n+#include \"gimplify.h\"\n+#include \"stor-layout.h\"\n+#include \"debug.h\"\n+#include \"convert.h\"\n+#include \"langhooks.h\"\n+#include \"langhooks-def.h\"\n+#include \"selftest.h\"\n+#include \"rust-cfg-parser.h\"\n+#include \"rust-privacy-ctx.h\"\n+#include \"rust-ast-resolve-item.h\"\n+#include \"rust-optional.h\"\n+\n+#include <mpfr.h>\n+// note: header files must be in this order or else forward declarations don't\n+// work properly. Kinda dumb system, but have to live with it. clang-format\n+// seems to mess it up\n+/* Order: config, system, coretypes, target, tree, gimple-expr, diagnostic,\n+ * opts, fold-const, gimplify, stor-layout, debug, convert, langhooks,\n+ * langhooks-def */\n+\n+// FIXME: test saving intellisense\n+#include \"options.h\"\n+\n+// version check to stop compiling if c++ isn't c++11 or higher\n+#if __cplusplus < 201103\n+#error                                                                         \\\n+  \"GCC Rust frontend requires C++11 or higher. You can compile the g++ frontend first and then compile the Rust frontend using that.\"\n+#endif\n+// TODO: is this best way to do it? Is it allowed? (should be)\n+\n+/* General TODOs:\n+ *  - convert all copies of expensive-to-copy (deep copy) AST objects into\n+ * moves, if possible. Don't remove clone functionality - it may be required for\n+ * e.g. HIR conversion.\n+ */\n+\n+#include \"rust-session-manager.h\"\n+\n+// Language-dependent contents of a type. GTY() mark used for garbage collector.\n+struct GTY (()) lang_type\n+{\n+};\n+\n+// Language-dependent contents of a decl.\n+struct GTY (()) lang_decl\n+{\n+};\n+\n+// Language-dependent contents of an identifier.  This must include a\n+// tree_identifier.\n+struct GTY (()) lang_identifier\n+{\n+  struct tree_identifier common;\n+};\n+\n+// The resulting tree type.\n+union GTY ((\n+  desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n+  chain_next (\n+    \"CODE_CONTAINS_STRUCT (TREE_CODE (&%h.generic), \"\n+    \"TS_COMMON) ? ((union lang_tree_node *) TREE_CHAIN (&%h.generic)) : NULL\")))\n+  lang_tree_node\n+{\n+  union tree_node GTY ((tag (\"0\"), desc (\"tree_node_structure (&%h)\"))) generic;\n+  struct lang_identifier GTY ((tag (\"1\"))) identifier;\n+};\n+\n+// We don't use language_function.\n+struct GTY (()) language_function\n+{\n+};\n+\n+// has to be in same compilation unit as session, so here for now\n+void\n+rust_add_target_info (const char *key, const char *value)\n+{\n+  sorry (\"TODO\");\n+\n+  Rust::Session::get_instance ().options.target_data.insert_key_value_pair (\n+    key, value);\n+}\n+\n+/* Language hooks.  */\n+\n+/* Initial lang hook called (possibly), used for initialisation.\n+ * Must call build_common_tree_nodes, set_sizetype, build_common_tree_nodes_2,\n+ * and build_common_builtin_nodes, as well as set global variable\n+ * void_list_node. Apparently called after option handling? */\n+static bool\n+grs_langhook_init (void)\n+{\n+  /* Something to do with this:\n+   This allows the code in d-builtins.cc to not have to worry about\n+   converting (C signed char *) to (D char *) for string arguments of\n+   built-in functions. The parameter (signed_char = false) specifies\n+   whether char is signed.  */\n+  build_common_tree_nodes (false);\n+\n+  // Creates a new TREE_LIST node with purpose NULL_TREE and value\n+  // void_type_node\n+  void_list_node = build_tree_list (NULL_TREE, void_type_node);\n+\n+  // Builds built-ins for middle-end after all front-end built-ins are already\n+  // instantiated\n+  build_common_builtin_nodes ();\n+\n+  mpfr_set_default_prec (128);\n+\n+  using_eh_for_cleanups ();\n+\n+  // initialise compiler session\n+  Rust::Session::get_instance ().init ();\n+\n+  return true;\n+}\n+\n+/* The option mask (something to do with options for specific frontends or\n+ * something). */\n+static unsigned int\n+grs_langhook_option_lang_mask (void)\n+{\n+  return CL_Rust;\n+}\n+\n+/* Initialize the options structure. */\n+static void\n+grs_langhook_init_options_struct (struct gcc_options *opts)\n+{\n+  /* Operations are always wrapping in Rust, even on signed integer. This is\n+   * useful for the low level wrapping_{add, sub, mul} intrinsics, not for\n+   * regular arithmetic operations which are checked for overflow anyway using\n+   * builtins */\n+  opts->x_flag_wrapv = 1;\n+\n+  /* We need to warn on unused variables by default */\n+  opts->x_warn_unused_variable = 1;\n+  /* For const variables too */\n+  opts->x_warn_unused_const_variable = 1;\n+  /* And finally unused result for #[must_use] */\n+  opts->x_warn_unused_result = 1;\n+\n+  // nothing yet - used by frontends to change specific options for the language\n+  Rust::Session::get_instance ().init_options ();\n+}\n+\n+/* Main entry point for front-end, apparently. Finds input file names in global\n+ * vars in_fnames and num_in_fnames. From this, frontend can take over and do\n+ * actual parsing and initial compilation. This function must create a complete\n+ * parse tree in a global var, and then return.\n+ *\n+ * Some consider this the \"start of compilation\". */\n+static void\n+grs_langhook_parse_file (void)\n+{\n+  rust_debug (\"Preparing to parse files. \");\n+\n+  Rust::Session::get_instance ().handle_input_files (num_in_fnames, in_fnames);\n+}\n+\n+/* Seems to get the exact type for a specific type - e.g. for scalar float with\n+ * 32-bit bitsize, it returns float, and for 64-bit bitsize, it returns double.\n+ * Used to map RTL nodes to machine modes or something like that. */\n+static tree\n+grs_langhook_type_for_mode (machine_mode mode, int unsignedp)\n+{\n+  // TODO: change all this later to match rustc types\n+  if (mode == TYPE_MODE (float_type_node))\n+    return float_type_node;\n+\n+  if (mode == TYPE_MODE (double_type_node))\n+    return double_type_node;\n+\n+  if (mode == TYPE_MODE (intQI_type_node)) // quarter integer mode - single byte\n+\t\t\t\t\t   // treated as integer\n+    return unsignedp ? unsigned_intQI_type_node : intQI_type_node;\n+  if (mode\n+      == TYPE_MODE (intHI_type_node)) // half integer mode - two-byte integer\n+    return unsignedp ? unsigned_intHI_type_node : intHI_type_node;\n+  if (mode\n+      == TYPE_MODE (intSI_type_node)) // single integer mode - four-byte integer\n+    return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n+  if (mode\n+      == TYPE_MODE (\n+\tintDI_type_node)) // double integer mode - eight-byte integer\n+    return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n+  if (mode\n+      == TYPE_MODE (intTI_type_node)) // tetra integer mode - 16-byte integer\n+    return unsignedp ? unsigned_intTI_type_node : intTI_type_node;\n+\n+  if (mode == TYPE_MODE (integer_type_node))\n+    return unsignedp ? unsigned_type_node : integer_type_node;\n+\n+  if (mode == TYPE_MODE (long_integer_type_node))\n+    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n+\n+  if (mode == TYPE_MODE (long_long_integer_type_node))\n+    return unsignedp ? long_long_unsigned_type_node\n+\t\t     : long_long_integer_type_node;\n+\n+  if (COMPLEX_MODE_P (mode))\n+    {\n+      if (mode == TYPE_MODE (complex_float_type_node))\n+\treturn complex_float_type_node;\n+      if (mode == TYPE_MODE (complex_double_type_node))\n+\treturn complex_double_type_node;\n+      if (mode == TYPE_MODE (complex_long_double_type_node))\n+\treturn complex_long_double_type_node;\n+      if (mode == TYPE_MODE (complex_integer_type_node) && !unsignedp)\n+\treturn complex_integer_type_node;\n+    }\n+  /* gcc_unreachable */\n+  return NULL;\n+}\n+\n+// Record a builtin function. We just ignore builtin functions.\n+static tree\n+grs_langhook_builtin_function (tree decl ATTRIBUTE_UNUSED)\n+{\n+  return decl;\n+}\n+\n+/* Return true if we are in the global binding level (which is never,\n+ * apparently). */\n+static bool\n+grs_langhook_global_bindings_p (void)\n+{\n+  // return current_function_decl == NULL_TREE;\n+  // gcc_unreachable();\n+  // return true;\n+  return false;\n+}\n+\n+/* Push a declaration into the current binding level.  We can't\n+   usefully implement this since we don't want to convert from tree\n+   back to one of our internal data structures.  I think the only way\n+   this is used is to record a decl which is to be returned by\n+   getdecls, and we could implement it for that purpose if\n+   necessary.  */\n+static tree\n+grs_langhook_pushdecl (tree decl ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n+/* This hook is used to get the current list of declarations as trees.\n+   We don't support that; instead we use the write_globals hook.  This\n+   can't simply crash because it is called by -gstabs.  */\n+static tree\n+grs_langhook_getdecls (void)\n+{\n+  // gcc_unreachable();\n+  return NULL;\n+}\n+\n+// Handle Rust-specific options. Return false if nothing happened.\n+static bool\n+grs_langhook_handle_option (\n+  size_t scode, const char *arg, HOST_WIDE_INT value, int kind ATTRIBUTE_UNUSED,\n+  location_t loc ATTRIBUTE_UNUSED,\n+  const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n+{\n+  // Convert integer code to lang.opt enum codes with names.\n+  enum opt_code code = (enum opt_code) scode;\n+\n+  // Delegate to session manager\n+  return Rust::Session::get_instance ().handle_option (code, arg, value, kind,\n+\t\t\t\t\t\t       loc, handlers);\n+}\n+\n+/* Run after parsing options.  */\n+static bool\n+grs_langhook_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n+{\n+  // can be used to override other options if required\n+\n+  // satisfies an assert in init_excess_precision in toplev.cc\n+  if (flag_excess_precision /*_cmdline*/ == EXCESS_PRECISION_DEFAULT)\n+    flag_excess_precision /*_cmdline*/ = EXCESS_PRECISION_STANDARD;\n+\n+  /* Returning false means that the backend should be used.  */\n+  return false;\n+}\n+\n+/* Rust-specific gimplification. May need to gimplify e.g.\n+ * CALL_EXPR_STATIC_CHAIN */\n+static int\n+grs_langhook_gimplify_expr (tree *expr_p ATTRIBUTE_UNUSED,\n+\t\t\t    gimple_seq *pre_p ATTRIBUTE_UNUSED,\n+\t\t\t    gimple_seq *post_p ATTRIBUTE_UNUSED)\n+{\n+  if (TREE_CODE (*expr_p) == CALL_EXPR\n+      && CALL_EXPR_STATIC_CHAIN (*expr_p) != NULL_TREE)\n+    gimplify_expr (&CALL_EXPR_STATIC_CHAIN (*expr_p), pre_p, post_p,\n+\t\t   is_gimple_val, fb_rvalue);\n+  return GS_UNHANDLED;\n+}\n+\n+static tree\n+grs_langhook_eh_personality (void)\n+{\n+  static tree personality_decl;\n+  if (personality_decl == NULL_TREE)\n+    {\n+      personality_decl = build_personality_function (\"gccrs\");\n+      rust_preserve_from_gc (personality_decl);\n+    }\n+  return personality_decl;\n+}\n+\n+tree\n+convert (tree type, tree expr)\n+{\n+  if (type == error_mark_node || expr == error_mark_node\n+      || TREE_TYPE (expr) == error_mark_node)\n+    return error_mark_node;\n+\n+  if (type == TREE_TYPE (expr))\n+    return expr;\n+\n+  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))\n+    return fold_convert (type, expr);\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case VOID_TYPE:\n+    case BOOLEAN_TYPE:\n+      return fold_convert (type, expr);\n+    case INTEGER_TYPE:\n+      return convert_to_integer (type, expr);\n+    case POINTER_TYPE:\n+      return convert_to_pointer (type, expr);\n+    case REAL_TYPE:\n+      return convert_to_real (type, expr);\n+    case COMPLEX_TYPE:\n+      return convert_to_complex (type, expr);\n+    default:\n+      break;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* FIXME: This is a hack to preserve trees that we create from the\n+   garbage collector.  */\n+\n+static GTY (()) tree rust_gc_root;\n+\n+void\n+rust_preserve_from_gc (tree t)\n+{\n+  rust_gc_root = tree_cons (NULL_TREE, t, rust_gc_root);\n+}\n+\n+/* Convert an identifier for use in an error message.  */\n+\n+const char *\n+rust_localize_identifier (const char *ident)\n+{\n+  return identifier_to_locale (ident);\n+}\n+\n+/* The language hooks data structure. This is the main interface between the GCC\n+ * front-end and the GCC middle-end/back-end. A list of language hooks could be\n+ * found in <gcc>/langhooks.h\n+ */\n+#undef LANG_HOOKS_NAME\n+#undef LANG_HOOKS_INIT\n+#undef LANG_HOOKS_OPTION_LANG_MASK\n+#undef LANG_HOOKS_INIT_OPTIONS_STRUCT\n+#undef LANG_HOOKS_HANDLE_OPTION\n+#undef LANG_HOOKS_POST_OPTIONS\n+#undef LANG_HOOKS_PARSE_FILE\n+#undef LANG_HOOKS_TYPE_FOR_MODE\n+#undef LANG_HOOKS_BUILTIN_FUNCTION\n+#undef LANG_HOOKS_GLOBAL_BINDINGS_P\n+#undef LANG_HOOKS_PUSHDECL\n+#undef LANG_HOOKS_GETDECLS\n+#undef LANG_HOOKS_WRITE_GLOBALS\n+#undef LANG_HOOKS_GIMPLIFY_EXPR\n+#undef LANG_HOOKS_EH_PERSONALITY\n+\n+#define LANG_HOOKS_NAME \"GNU Rust\"\n+#define LANG_HOOKS_INIT grs_langhook_init\n+#define LANG_HOOKS_OPTION_LANG_MASK grs_langhook_option_lang_mask\n+#define LANG_HOOKS_INIT_OPTIONS_STRUCT grs_langhook_init_options_struct\n+#define LANG_HOOKS_HANDLE_OPTION grs_langhook_handle_option\n+#define LANG_HOOKS_POST_OPTIONS grs_langhook_post_options\n+/* Main lang-hook, apparently. Finds input file names in global vars in_fnames\n+ * and num_in_fnames From this, frontend can take over and do actual parsing and\n+ * initial compilation.\n+ * This hook must create a complete parse tree in a global var, and then return.\n+ */\n+#define LANG_HOOKS_PARSE_FILE grs_langhook_parse_file\n+#define LANG_HOOKS_TYPE_FOR_MODE grs_langhook_type_for_mode\n+#define LANG_HOOKS_BUILTIN_FUNCTION grs_langhook_builtin_function\n+#define LANG_HOOKS_GLOBAL_BINDINGS_P grs_langhook_global_bindings_p\n+#define LANG_HOOKS_PUSHDECL grs_langhook_pushdecl\n+#define LANG_HOOKS_GETDECLS grs_langhook_getdecls\n+#define LANG_HOOKS_GIMPLIFY_EXPR grs_langhook_gimplify_expr\n+#define LANG_HOOKS_EH_PERSONALITY grs_langhook_eh_personality\n+\n+#if CHECKING_P\n+\n+#undef LANG_HOOKS_RUN_LANG_SELFTESTS\n+#define LANG_HOOKS_RUN_LANG_SELFTESTS selftest::run_rust_tests\n+\n+namespace selftest {\n+\n+void\n+run_rust_tests ()\n+{\n+  // Call tests for the rust frontend here\n+  rust_cfg_parser_test ();\n+  rust_privacy_ctx_test ();\n+  rust_crate_name_validation_test ();\n+  rust_simple_path_resolve_test ();\n+  rust_optional_test ();\n+}\n+} // namespace selftest\n+\n+#endif /* !CHECKING_P */\n+\n+// Expands all LANG_HOOKS_x of GCC\n+struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+\n+// These are for GCC's garbage collector to work properly or something\n+#include \"gt-rust-rust-lang.h\"\n+#include \"gtype-rust.h\""}, {"sha": "6d7f1a85f199a4b17a530b87b9c45660dc809b83", "filename": "gcc/rust/rust-session-manager.cc", "status": "added", "additions": 1189, "deletions": 0, "changes": 1189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea34614225d4d255e58f63206eb12178b870cb4c/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea34614225d4d255e58f63206eb12178b870cb4c/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=ea34614225d4d255e58f63206eb12178b870cb4c", "patch": "@@ -0,0 +1,1189 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-session-manager.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-unsafe-checker.h\"\n+#include \"rust-lex.h\"\n+#include \"rust-parse.h\"\n+#include \"rust-macro-expand.h\"\n+#include \"rust-ast-resolve.h\"\n+#include \"rust-ast-lower.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-privacy-check.h\"\n+#include \"rust-const-checker.h\"\n+#include \"rust-tycheck-dump.h\"\n+#include \"rust-compile.h\"\n+#include \"rust-cfg-parser.h\"\n+#include \"rust-lint-scan-deadcode.h\"\n+#include \"rust-lint-unused-var.h\"\n+#include \"rust-hir-dump.h\"\n+#include \"rust-ast-dump.h\"\n+#include \"rust-export-metadata.h\"\n+#include \"rust-imports.h\"\n+#include \"rust-extern-crate.h\"\n+#include \"rust-attributes.h\"\n+\n+#include \"diagnostic.h\"\n+#include \"input.h\"\n+#include \"selftest.h\"\n+#include \"target.h\"\n+\n+extern bool\n+saw_errors (void);\n+\n+extern Linemap *\n+rust_get_linemap ();\n+\n+extern Backend *\n+rust_get_backend ();\n+\n+namespace Rust {\n+\n+const char *kLexDumpFile = \"gccrs.lex.dump\";\n+const char *kASTDumpFile = \"gccrs.ast.dump\";\n+const char *kASTPrettyDumpFile = \"gccrs.ast-pretty.dump\";\n+const char *kASTExpandedDumpFile = \"gccrs.ast-expanded.dump\";\n+const char *kHIRDumpFile = \"gccrs.hir.dump\";\n+const char *kHIRPrettyDumpFile = \"gccrs.hir-pretty.dump\";\n+const char *kHIRTypeResolutionDumpFile = \"gccrs.type-resolution.dump\";\n+const char *kTargetOptionsDumpFile = \"gccrs.target-options.dump\";\n+\n+const std::string kDefaultCrateName = \"rust_out\";\n+const size_t kMaxNameLength = 64;\n+\n+Session &\n+Session::get_instance ()\n+{\n+  static Session instance;\n+  return instance;\n+}\n+\n+static std::string\n+infer_crate_name (const std::string &filename)\n+{\n+  if (filename == \"-\")\n+    return kDefaultCrateName;\n+\n+  std::string crate = std::string (filename);\n+  size_t path_sep = crate.find_last_of (file_separator);\n+\n+  // find the base filename\n+  if (path_sep != std::string::npos)\n+    crate.erase (0, path_sep + 1);\n+\n+  // find the file stem name (remove file extension)\n+  size_t ext_position = crate.find_last_of ('.');\n+  if (ext_position != std::string::npos)\n+    crate.erase (ext_position);\n+\n+  // Replace all the '-' symbols with '_' per Rust rules\n+  for (auto &c : crate)\n+    {\n+      if (c == '-')\n+\tc = '_';\n+    }\n+  return crate;\n+}\n+\n+/* Validate the crate name using the ASCII rules\n+   TODO: Support Unicode version of the rules */\n+\n+static bool\n+validate_crate_name (const std::string &crate_name, Error &error)\n+{\n+  if (crate_name.empty ())\n+    {\n+      error = Error (Location (), \"crate name cannot be empty\");\n+      return false;\n+    }\n+  if (crate_name.length () > kMaxNameLength)\n+    {\n+      error = Error (Location (), \"crate name cannot exceed %lu characters\",\n+\t\t     (unsigned long) kMaxNameLength);\n+      return false;\n+    }\n+  for (auto &c : crate_name)\n+    {\n+      if (!(ISALNUM (c) || c == '_'))\n+\t{\n+\t  error = Error (Location (),\n+\t\t\t \"invalid character %<%c%> in crate name: %<%s%>\", c,\n+\t\t\t crate_name.c_str ());\n+\t  return false;\n+\t}\n+    }\n+  return true;\n+}\n+\n+void\n+Session::init ()\n+{\n+  options.target_data.insert_key_value_pair (\"target_pointer_width\",\n+\t\t\t\t\t     std::to_string (POINTER_SIZE));\n+  options.target_data.insert_key_value_pair (\"target_endian\", BYTES_BIG_ENDIAN\n+\t\t\t\t\t\t\t\t? \"big\"\n+\t\t\t\t\t\t\t\t: \"little\");\n+\n+  // setup singleton linemap\n+  linemap = rust_get_linemap ();\n+\n+  // setup backend to GCC GIMPLE\n+  backend = rust_get_backend ();\n+\n+  // setup mappings class\n+  mappings = Analysis::Mappings::get ();\n+}\n+\n+/* Initialise default options. Actually called before handle_option, unlike init\n+ * itself. */\n+void\n+Session::init_options ()\n+{}\n+\n+// Handle option selection.\n+bool\n+Session::handle_option (\n+  enum opt_code code, const char *arg, HOST_WIDE_INT value ATTRIBUTE_UNUSED,\n+  int kind ATTRIBUTE_UNUSED, location_t loc ATTRIBUTE_UNUSED,\n+  const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n+{\n+  // used to store whether results of various stuff are successful\n+  bool ret = true;\n+\n+  // Handles options as listed in lang.opt.\n+  switch (code)\n+    {\n+    case OPT_I:\n+      case OPT_L: {\n+\t// TODO: add search path\n+\tconst std::string p = std::string (arg);\n+\tadd_search_path (p);\n+      }\n+      break;\n+\n+    case OPT_frust_crate_:\n+      // set the crate name\n+      if (arg != nullptr)\n+\t{\n+\t  auto error = Error (Location (), std::string ());\n+\t  if ((ret = validate_crate_name (arg, error)))\n+\t    {\n+\t      options.set_crate_name (arg);\n+\t      options.crate_name_set_manually = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      rust_assert (!error.message.empty ());\n+\t      error.emit_error ();\n+\t    }\n+\t}\n+      else\n+\tret = false;\n+      break;\n+\n+    case OPT_frust_dump_:\n+      // enable dump and return whether this was successful\n+      if (arg != nullptr)\n+\t{\n+\t  ret = enable_dump (std::string (arg));\n+\t}\n+      else\n+\t{\n+\t  ret = false;\n+\t}\n+      break;\n+\n+    case OPT_frust_mangling_:\n+      Compile::Mangler::set_mangling (flag_rust_mangling);\n+      break;\n+\n+      case OPT_frust_cfg_: {\n+\tauto string_arg = std::string (arg);\n+\tret = handle_cfg_option (string_arg);\n+\tbreak;\n+      }\n+\n+    case OPT_frust_edition_:\n+      options.set_edition (flag_rust_edition);\n+      break;\n+\n+    case OPT_frust_metadata_output_:\n+      options.set_metadata_output (arg);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return ret;\n+}\n+\n+bool\n+Session::handle_cfg_option (std::string &input)\n+{\n+  std::string key;\n+  std::string value;\n+\n+  // Refactor this if needed\n+  if (!parse_cfg_option (input, key, value))\n+    {\n+      rust_error_at (\n+\tLocation (),\n+\t\"invalid argument to %<-frust-cfg%>: Accepted formats are \"\n+\t\"%<-frust-cfg=key%> or %<-frust-cfg=key=\\\"value\\\"%> (quoted)\");\n+      return false;\n+    }\n+\n+  if (value.empty ())\n+    // rustc does not seem to error on dup key\n+    options.target_data.insert_key (key);\n+  else\n+    options.target_data.insert_key_value_pair (key, value);\n+\n+  return true;\n+}\n+\n+/* Enables a certain dump depending on the name passed in. Returns true if\n+ * name is valid, false otherwise. */\n+bool\n+Session::enable_dump (std::string arg)\n+{\n+  if (arg.empty ())\n+    {\n+      rust_error_at (\n+\tLocation (),\n+\t\"dump option was not given a name. choose %<lex%>, %<parse%>, \"\n+\t\"%<register_plugins%>, %<injection%>, %<expansion%>, %<resolution%>,\"\n+\t\" %<target_options%>, %<hir%>, or %<all%>\");\n+      return false;\n+    }\n+\n+  if (arg == \"all\")\n+    {\n+      options.enable_all_dump_options ();\n+    }\n+  else if (arg == \"lex\")\n+    {\n+      options.enable_dump_option (CompileOptions::LEXER_DUMP);\n+    }\n+  else if (arg == \"parse\")\n+    {\n+      options.enable_dump_option (CompileOptions::PARSER_AST_DUMP);\n+    }\n+  else if (arg == \"ast-pretty\")\n+    {\n+      options.enable_dump_option (CompileOptions::AST_DUMP_PRETTY);\n+    }\n+  else if (arg == \"register_plugins\")\n+    {\n+      options.enable_dump_option (CompileOptions::REGISTER_PLUGINS_DUMP);\n+    }\n+  else if (arg == \"injection\")\n+    {\n+      options.enable_dump_option (CompileOptions::INJECTION_DUMP);\n+    }\n+  else if (arg == \"expansion\")\n+    {\n+      options.enable_dump_option (CompileOptions::EXPANSION_DUMP);\n+    }\n+  else if (arg == \"resolution\")\n+    {\n+      options.enable_dump_option (CompileOptions::RESOLUTION_DUMP);\n+    }\n+  else if (arg == \"target_options\")\n+    {\n+      options.enable_dump_option (CompileOptions::TARGET_OPTION_DUMP);\n+    }\n+  else if (arg == \"hir\")\n+    {\n+      options.enable_dump_option (CompileOptions::HIR_DUMP);\n+    }\n+  else if (arg == \"hir-pretty\")\n+    {\n+      options.enable_dump_option (CompileOptions::HIR_DUMP_PRETTY);\n+    }\n+  else\n+    {\n+      rust_error_at (\n+\tLocation (),\n+\t\"dump option %qs was unrecognised. choose %<lex%>, %<parse%>, \"\n+\t\"%<register_plugins%>, %<injection%>, %<expansion%>, %<resolution%>,\"\n+\t\" %<target_options%>, or %<hir%>\",\n+\targ.c_str ());\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/* Actual main entry point for front-end. Called from langhook to parse files.\n+ */\n+void\n+Session::handle_input_files (int num_files, const char **files)\n+{\n+  if (num_files != 1)\n+    rust_fatal_error (Location (),\n+\t\t      \"only one file may be specified on the command line\");\n+\n+  const auto &file = files[0];\n+\n+  if (options.crate_name.empty ())\n+    {\n+      auto filename = \"-\";\n+      if (num_files > 0)\n+\tfilename = files[0];\n+\n+      auto crate_name = infer_crate_name (filename);\n+      rust_debug (\"inferred crate name: %s\", crate_name.c_str ());\n+      // set the preliminary crate name here\n+      // we will figure out the real crate name in `handle_crate_name`\n+      options.set_crate_name (crate_name);\n+    }\n+\n+  CrateNum crate_num = mappings->get_next_crate_num (options.get_crate_name ());\n+  mappings->set_current_crate (crate_num);\n+\n+  rust_debug (\"Attempting to parse file: %s\", file);\n+  compile_crate (file);\n+}\n+\n+void\n+Session::handle_crate_name (const AST::Crate &parsed_crate)\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+  auto crate_name_changed = false;\n+  auto error = Error (Location (), std::string ());\n+\n+  for (const auto &attr : parsed_crate.inner_attrs)\n+    {\n+      if (attr.get_path () != \"crate_name\")\n+\tcontinue;\n+      if (!attr.has_attr_input ())\n+\t{\n+\t  rust_error_at (attr.get_locus (),\n+\t\t\t \"%<crate_name%> accepts one argument\");\n+\t  continue;\n+\t}\n+\n+      auto &literal\n+\t= static_cast<AST::AttrInputLiteral &> (attr.get_attr_input ());\n+      const auto &msg_str = literal.get_literal ().as_string ();\n+      if (!validate_crate_name (msg_str, error))\n+\t{\n+\t  error.locus = attr.get_locus ();\n+\t  error.emit_error ();\n+\t  continue;\n+\t}\n+\n+      auto options = Session::get_instance ().options;\n+      if (options.crate_name_set_manually && (options.crate_name != msg_str))\n+\t{\n+\t  rust_error_at (attr.get_locus (),\n+\t\t\t \"%<-frust-crate-name%> and %<#[crate_name]%> are \"\n+\t\t\t \"required to match, but %qs does not match %qs\",\n+\t\t\t options.crate_name.c_str (), msg_str.c_str ());\n+\t}\n+      crate_name_changed = true;\n+      options.set_crate_name (msg_str);\n+      mappings->set_crate_name (mappings->get_current_crate (), msg_str);\n+    }\n+\n+  options.crate_name_set_manually |= crate_name_changed;\n+  if (!options.crate_name_set_manually\n+      && !validate_crate_name (options.crate_name, error))\n+    {\n+      error.emit_error ();\n+      rust_inform (linemap->get_location (0),\n+\t\t   \"crate name inferred from this file\");\n+    }\n+}\n+\n+// Parses a single file with filename filename.\n+void\n+Session::compile_crate (const char *filename)\n+{\n+  RAIIFile file_wrap (filename);\n+  if (!file_wrap.ok ())\n+    {\n+      rust_error_at (Location (), \"cannot open filename %s: %m\", filename);\n+      return;\n+    }\n+\n+  // parse file here\n+  /* create lexer and parser - these are file-specific and so aren't instance\n+   * variables */\n+  Lexer lex (filename, std::move (file_wrap), linemap);\n+  Parser<Lexer> parser (lex);\n+\n+  // generate crate from parser\n+  std::unique_ptr<AST::Crate> ast_crate = parser.parse_crate ();\n+\n+  // handle crate name\n+  handle_crate_name (*ast_crate.get ());\n+\n+  // dump options\n+  if (options.dump_option_enabled (CompileOptions::LEXER_DUMP))\n+    {\n+      dump_lex (parser);\n+    }\n+  if (options.dump_option_enabled (CompileOptions::PARSER_AST_DUMP))\n+    {\n+      dump_ast (parser, *ast_crate.get ());\n+    }\n+  if (options.dump_option_enabled (CompileOptions::AST_DUMP_PRETTY))\n+    {\n+      dump_ast_pretty (*ast_crate.get ());\n+    }\n+  if (options.dump_option_enabled (CompileOptions::TARGET_OPTION_DUMP))\n+    {\n+      options.target_data.dump_target_options ();\n+    }\n+\n+  if (saw_errors ())\n+    return;\n+\n+  // setup the mappings for this AST\n+  CrateNum current_crate = mappings->get_current_crate ();\n+  AST::Crate &parsed_crate\n+    = mappings->insert_ast_crate (std::move (ast_crate), current_crate);\n+\n+  /* basic pipeline:\n+   *  - lex\n+   *  - parse\n+   *  - register plugins (dummy stage for now) - attribute injection? what is\n+   * this? (attribute injection is injecting attributes specified in command\n+   * line into crate root)\n+   *  - injection (some lint checks or dummy, register builtin macros, crate\n+   * injection)\n+   *  - expansion (expands all macros, maybe build test harness, AST\n+   * validation, maybe macro crate)\n+   *  - resolution (name resolution, type resolution, maybe feature checking,\n+   * maybe buffered lints)\n+   *  TODO not done */\n+\n+  rust_debug (\"\\033[0;31mSUCCESSFULLY PARSED CRATE \\033[0m\");\n+\n+  // If -fsyntax-only was passed, we can just skip the remaining passes.\n+  // Parsing errors are already emitted in `parse_crate()`\n+  if (flag_syntax_only)\n+    return;\n+\n+  // register plugins pipeline stage\n+  register_plugins (parsed_crate);\n+  rust_debug (\"\\033[0;31mSUCCESSFULLY REGISTERED PLUGINS \\033[0m\");\n+  if (options.dump_option_enabled (CompileOptions::REGISTER_PLUGINS_DUMP))\n+    {\n+      // TODO: what do I dump here?\n+    }\n+\n+  // injection pipeline stage\n+  injection (parsed_crate);\n+  rust_debug (\"\\033[0;31mSUCCESSFULLY FINISHED INJECTION \\033[0m\");\n+  if (options.dump_option_enabled (CompileOptions::INJECTION_DUMP))\n+    {\n+      // TODO: what do I dump here? injected crate names?\n+    }\n+\n+  Analysis::AttributeChecker ().go (parsed_crate);\n+\n+  // expansion pipeline stage\n+  expansion (parsed_crate);\n+  rust_debug (\"\\033[0;31mSUCCESSFULLY FINISHED EXPANSION \\033[0m\");\n+  if (options.dump_option_enabled (CompileOptions::EXPANSION_DUMP))\n+    {\n+      // dump AST with expanded stuff\n+      rust_debug (\"BEGIN POST-EXPANSION AST DUMP\");\n+      dump_ast_expanded (parser, parsed_crate);\n+      rust_debug (\"END POST-EXPANSION AST DUMP\");\n+    }\n+\n+  // resolution pipeline stage\n+  Resolver::NameResolution::Resolve (parsed_crate);\n+  if (options.dump_option_enabled (CompileOptions::RESOLUTION_DUMP))\n+    {\n+      // TODO: what do I dump here? resolved names? AST with resolved names?\n+    }\n+\n+  if (saw_errors ())\n+    return;\n+\n+  // lower AST to HIR\n+  std::unique_ptr<HIR::Crate> lowered\n+    = HIR::ASTLowering::Resolve (parsed_crate);\n+  if (saw_errors ())\n+    return;\n+\n+  // add the mappings to it\n+  HIR::Crate &hir = mappings->insert_hir_crate (std::move (lowered));\n+  if (options.dump_option_enabled (CompileOptions::HIR_DUMP))\n+    {\n+      dump_hir (hir);\n+    }\n+  if (options.dump_option_enabled (CompileOptions::HIR_DUMP_PRETTY))\n+    {\n+      dump_hir_pretty (hir);\n+    }\n+\n+  // type resolve\n+  Resolver::TypeResolution::Resolve (hir);\n+  if (options.dump_option_enabled (CompileOptions::TYPE_RESOLUTION_DUMP))\n+    {\n+      dump_type_resolution (hir);\n+    }\n+\n+  if (saw_errors ())\n+    return;\n+\n+  // Various HIR error passes. The privacy pass happens before the unsafe checks\n+  Privacy::Resolver::resolve (hir);\n+  if (saw_errors ())\n+    return;\n+\n+  HIR::UnsafeChecker ().go (hir);\n+  HIR::ConstChecker ().go (hir);\n+\n+  if (saw_errors ())\n+    return;\n+\n+  // do compile to gcc generic\n+  Compile::Context ctx (backend);\n+  Compile::CompileCrate::Compile (hir, &ctx);\n+\n+  // we can't do static analysis if there are errors to worry about\n+  if (!saw_errors ())\n+    {\n+      // lints\n+      Analysis::ScanDeadcode::Scan (hir);\n+      Analysis::UnusedVariables::Lint (ctx);\n+\n+      // metadata\n+      bool specified_emit_metadata\n+\t= flag_rust_embed_metadata || options.metadata_output_path_set ();\n+      if (!specified_emit_metadata)\n+\t{\n+\t  Metadata::PublicInterface::ExportTo (\n+\t    hir, Metadata::PublicInterface::expected_metadata_filename ());\n+\t}\n+      else\n+\t{\n+\t  if (flag_rust_embed_metadata)\n+\t    Metadata::PublicInterface::Export (hir);\n+\t  if (options.metadata_output_path_set ())\n+\t    Metadata::PublicInterface::ExportTo (\n+\t      hir, options.get_metadata_output ());\n+\t}\n+    }\n+\n+  // pass to GCC middle-end\n+  ctx.write_to_backend ();\n+}\n+\n+void\n+Session::register_plugins (AST::Crate &crate ATTRIBUTE_UNUSED)\n+{\n+  rust_debug (\"ran register_plugins (with no body)\");\n+}\n+\n+// TODO: move somewhere else\n+bool\n+contains_name (const AST::AttrVec &attrs, std::string name)\n+{\n+  for (const auto &attr : attrs)\n+    {\n+      if (attr.get_path () == name)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+void\n+Session::injection (AST::Crate &crate)\n+{\n+  rust_debug (\"started injection\");\n+\n+  // lint checks in future maybe?\n+\n+  // register builtin macros\n+  /* In rustc, builtin macros are divided into 3 categories depending on use -\n+   * \"bang\" macros, \"attr\" macros, and \"derive\" macros. I think the meanings\n+   * of these categories should be fairly obvious to anyone who has used rust.\n+   * Builtin macro list by category: Bang\n+   *      - asm\n+   *      - assert\n+   *      - cfg\n+   *      - column\n+   *      - compile_error\n+   *      - concat_idents\n+   *      - concat\n+   *      - env\n+   *      - file\n+   *      - format_args_nl\n+   *      - format_args\n+   *      - global_asm\n+   *      - include_bytes\n+   *      - include_str\n+   *      - include\n+   *      - line\n+   *      - log_syntax\n+   *      - module_path\n+   *      - option_env\n+   *      - stringify\n+   *      - trace_macros\n+   *  Attr\n+   *      - bench\n+   *      - global_allocator\n+   *      - test\n+   *      - test_case\n+   *  Derive\n+   *      - Clone\n+   *      - Copy\n+   *      - Debug\n+   *      - Default\n+   *      - Eq\n+   *      - Hash\n+   *      - Ord\n+   *      - PartialEq\n+   *      - PartialOrd\n+   *      - RustcDecodable\n+   *      - RustcEncodable\n+   * rustc also has a \"quote\" macro that is defined differently and is\n+   * supposedly not stable so eh. */\n+  /* TODO: actually implement injection of these macros. In particular, derive\n+   * macros, cfg, and test should be prioritised since they seem to be used\n+   * the most. */\n+\n+  // crate injection\n+  std::vector<std::string> names;\n+  if (contains_name (crate.inner_attrs, \"no_core\"))\n+    {\n+      // no prelude\n+      injected_crate_name = \"\";\n+    }\n+  else if (contains_name (crate.inner_attrs, \"no_std\"))\n+    {\n+      names.push_back (\"core\");\n+\n+      if (!contains_name (crate.inner_attrs, \"compiler_builtins\"))\n+\t{\n+\t  names.push_back (\"compiler_builtins\");\n+\t}\n+\n+      injected_crate_name = \"core\";\n+    }\n+  else\n+    {\n+      names.push_back (\"std\");\n+\n+      injected_crate_name = \"std\";\n+    }\n+\n+  // reverse iterate through names to insert crate items in \"forward\" order at\n+  // beginning of crate\n+  for (auto it = names.rbegin (); it != names.rend (); ++it)\n+    {\n+      // create \"macro use\" attribute for use on extern crate item to enable\n+      // loading macros from it\n+      AST::Attribute attr (AST::SimplePath::from_str (\"macro_use\", Location ()),\n+\t\t\t   nullptr);\n+\n+      // create \"extern crate\" item with the name\n+      std::unique_ptr<AST::ExternCrate> extern_crate (\n+\tnew AST::ExternCrate (*it, AST::Visibility::create_error (),\n+\t\t\t      {std::move (attr)},\n+\t\t\t      Linemap::unknown_location ()));\n+\n+      // insert at beginning\n+      // crate.items.insert (crate.items.begin (), std::move (extern_crate));\n+    }\n+\n+  // create use tree path\n+  // prelude is injected_crate_name\n+  // FIXME: Once we do want to include the standard library, add the prelude\n+  // use item\n+  // std::vector<AST::SimplePathSegment> segments\n+  //   = {AST::SimplePathSegment (injected_crate_name, Location ()),\n+  //      AST::SimplePathSegment (\"prelude\", Location ()),\n+  //      AST::SimplePathSegment (\"v1\", Location ())};\n+  // // create use tree and decl\n+  // std::unique_ptr<AST::UseTreeGlob> use_tree (\n+  //   new AST::UseTreeGlob (AST::UseTreeGlob::PATH_PREFIXED,\n+  //     \t\t  AST::SimplePath (std::move (segments)), Location ()));\n+  // AST::Attribute prelude_attr (AST::SimplePath::from_str (\"prelude_import\",\n+  //     \t\t\t\t\t\t  Location ()),\n+  //     \t\t       nullptr);\n+  // std::unique_ptr<AST::UseDeclaration> use_decl (\n+  //   new AST::UseDeclaration (std::move (use_tree),\n+  //     \t\t     AST::Visibility::create_error (),\n+  //     \t\t     {std::move (prelude_attr)}, Location ()));\n+\n+  // crate.items.insert (crate.items.begin (), std::move (use_decl));\n+\n+  /* TODO: potentially add checking attribute crate type? I can't figure out\n+   * what this does currently comment says \"Unconditionally collect crate\n+   * types from attributes to make them used\", which presumably refers to\n+   * checking the linkage info by \"crate_type\". It also seems to ensure that\n+   * an invalid crate type is not specified, so maybe just do that. Valid\n+   * crate types: bin lib dylib staticlib cdylib rlib proc-macro */\n+\n+  // this crate type will have options affecting the metadata ouput\n+\n+  rust_debug (\"finished injection\");\n+}\n+\n+void\n+Session::expansion (AST::Crate &crate)\n+{\n+  rust_debug (\"started expansion\");\n+\n+  /* rustc has a modification to windows PATH temporarily here, which may end\n+   * up being required */\n+\n+  // create macro expansion config?\n+  // if not, would at least have to configure recursion_limit\n+  ExpansionCfg cfg;\n+\n+  // create extctxt? from parse session, cfg, and resolver?\n+  /* expand by calling cxtctxt object's monotonic_expander's expand_crate\n+   * method. */\n+  MacroExpander expander (crate, cfg, *this);\n+  expander.expand_crate ();\n+\n+  // error reporting - check unused macros, get missing fragment specifiers\n+\n+  // build test harness\n+\n+  // ast validation (also with proc macro decls)\n+\n+  // maybe create macro crate if not rustdoc\n+\n+  rust_debug (\"finished expansion\");\n+}\n+\n+void\n+Session::dump_lex (Parser<Lexer> &parser) const\n+{\n+  std::ofstream out;\n+  out.open (kLexDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kLexDumpFile);\n+      return;\n+    }\n+\n+  // TODO: rewrite lexer dump or something so that it allows for the crate\n+  // to already be parsed\n+  parser.debug_dump_lex_output (out);\n+  out.close ();\n+}\n+\n+void\n+Session::dump_ast (Parser<Lexer> &parser, AST::Crate &crate) const\n+{\n+  std::ofstream out;\n+  out.open (kASTDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kASTDumpFile);\n+      return;\n+    }\n+\n+  parser.debug_dump_ast_output (crate, out);\n+  out.close ();\n+}\n+\n+void\n+Session::dump_ast_pretty (AST::Crate &crate) const\n+{\n+  std::ofstream out;\n+  out.open (kASTPrettyDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kASTDumpFile);\n+      return;\n+    }\n+\n+  AST::Dump (out).go (crate);\n+\n+  out.close ();\n+}\n+\n+void\n+Session::dump_ast_expanded (Parser<Lexer> &parser, AST::Crate &crate) const\n+{\n+  std::ofstream out;\n+  out.open (kASTExpandedDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kASTExpandedDumpFile);\n+      return;\n+    }\n+\n+  parser.debug_dump_ast_output (crate, out);\n+  out.close ();\n+}\n+\n+void\n+Session::dump_hir (HIR::Crate &crate) const\n+{\n+  std::ofstream out;\n+  out.open (kHIRDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kHIRDumpFile);\n+      return;\n+    }\n+\n+  out << crate.as_string ();\n+  out.close ();\n+}\n+\n+void\n+Session::dump_hir_pretty (HIR::Crate &crate) const\n+{\n+  std::ofstream out;\n+  out.open (kHIRPrettyDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kHIRPrettyDumpFile);\n+      return;\n+    }\n+\n+  HIR::Dump (out).go (crate);\n+  out.close ();\n+}\n+\n+void\n+Session::dump_type_resolution (HIR::Crate &hir) const\n+{\n+  std::ofstream out;\n+  out.open (kHIRTypeResolutionDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kHIRTypeResolutionDumpFile);\n+      return;\n+    }\n+\n+  Resolver::TypeResolverDump::go (hir, out);\n+  out.close ();\n+}\n+\n+// imports\n+\n+NodeId\n+Session::load_extern_crate (const std::string &crate_name, Location locus)\n+{\n+  // has it already been loaded?\n+  CrateNum found_crate_num = UNKNOWN_CREATENUM;\n+  bool found = mappings->lookup_crate_name (crate_name, found_crate_num);\n+  if (found)\n+    {\n+      NodeId resolved_node_id = UNKNOWN_NODEID;\n+      bool resolved\n+\t= mappings->crate_num_to_nodeid (found_crate_num, resolved_node_id);\n+      rust_assert (resolved);\n+\n+      return resolved_node_id;\n+    }\n+\n+  std::string relative_import_path = \"\";\n+  Import::Stream *s\n+    = Import::open_package (crate_name, locus, relative_import_path);\n+  if (s == NULL)\n+    {\n+      rust_error_at (locus, \"failed to locate crate %<%s%>\",\n+\t\t     crate_name.c_str ());\n+      return UNKNOWN_NODEID;\n+    }\n+\n+  Imports::ExternCrate extern_crate (*s);\n+  bool ok = extern_crate.load (locus);\n+  if (!ok)\n+    {\n+      rust_error_at (locus, \"failed to load crate metadata\");\n+      return UNKNOWN_NODEID;\n+    }\n+\n+  // ensure the current vs this crate name don't collide\n+  const std::string current_crate_name = mappings->get_current_crate_name ();\n+  if (current_crate_name.compare (extern_crate.get_crate_name ()) == 0)\n+    {\n+      rust_error_at (locus, \"current crate name %<%s%> collides with this\",\n+\t\t     current_crate_name.c_str ());\n+      return UNKNOWN_NODEID;\n+    }\n+\n+  // setup mappings\n+  CrateNum saved_crate_num = mappings->get_current_crate ();\n+  CrateNum crate_num\n+    = mappings->get_next_crate_num (extern_crate.get_crate_name ());\n+  mappings->set_current_crate (crate_num);\n+\n+  // then lets parse this as a 2nd crate\n+  Lexer lex (extern_crate.get_metadata ());\n+  Parser<Lexer> parser (lex);\n+  std::unique_ptr<AST::Crate> metadata_crate = parser.parse_crate ();\n+  AST::Crate &parsed_crate\n+    = mappings->insert_ast_crate (std::move (metadata_crate), crate_num);\n+\n+  // name resolve it\n+  Resolver::NameResolution::Resolve (parsed_crate);\n+\n+  // perform hir lowering\n+  std::unique_ptr<HIR::Crate> lowered\n+    = HIR::ASTLowering::Resolve (parsed_crate);\n+  HIR::Crate &hir = mappings->insert_hir_crate (std::move (lowered));\n+\n+  // perform type resolution\n+  Resolver::TypeResolution::Resolve (hir);\n+\n+  // always restore the crate_num\n+  mappings->set_current_crate (saved_crate_num);\n+\n+  return parsed_crate.get_node_id ();\n+}\n+//\n+\n+void\n+TargetOptions::dump_target_options () const\n+{\n+  std::ofstream out;\n+  out.open (kTargetOptionsDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kTargetOptionsDumpFile);\n+      return;\n+    }\n+\n+  if (features.empty ())\n+    {\n+      out << \"No target options available!\\n\";\n+    }\n+\n+  for (const auto &pairs : features)\n+    {\n+      for (const auto &value : pairs.second)\n+\tout << pairs.first + \": \\\"\" + value + \"\\\"\\n\";\n+\n+      if (pairs.second.empty ())\n+\tout << pairs.first + \"\\n\";\n+    }\n+\n+  out.close ();\n+}\n+\n+void\n+TargetOptions::init_derived_values ()\n+{\n+  // enable derived values based on target families\n+  if (has_key_value_pair (\"target_family\", \"unix\"))\n+    insert_key (\"unix\");\n+  if (has_key_value_pair (\"target_family\", \"windows\"))\n+    insert_key (\"windows\");\n+\n+  // implicitly enable features - this should not be required in general\n+  if (has_key_value_pair (\"target_feature\", \"aes\"))\n+    enable_implicit_feature_reqs (\"aes\");\n+  if (has_key_value_pair (\"target_feature\", \"avx\"))\n+    enable_implicit_feature_reqs (\"sse4.2\");\n+  if (has_key_value_pair (\"target_feature\", \"avx2\"))\n+    enable_implicit_feature_reqs (\"avx\");\n+  if (has_key_value_pair (\"target_feature\", \"pclmulqdq\"))\n+    enable_implicit_feature_reqs (\"sse2\");\n+  if (has_key_value_pair (\"target_feature\", \"sha\"))\n+    enable_implicit_feature_reqs (\"sse2\");\n+  if (has_key_value_pair (\"target_feature\", \"sse2\"))\n+    enable_implicit_feature_reqs (\"sse\");\n+  if (has_key_value_pair (\"target_feature\", \"sse3\"))\n+    enable_implicit_feature_reqs (\"sse2\");\n+  if (has_key_value_pair (\"target_feature\", \"sse4.1\"))\n+    enable_implicit_feature_reqs (\"sse3\");\n+  if (has_key_value_pair (\"target_feature\", \"sse4.2\"))\n+    enable_implicit_feature_reqs (\"sse4.1\");\n+  if (has_key_value_pair (\"target_feature\", \"ssse3\"))\n+    enable_implicit_feature_reqs (\"sse3\");\n+}\n+\n+void\n+TargetOptions::enable_implicit_feature_reqs (std::string feature)\n+{\n+  if (feature == \"aes\")\n+    enable_implicit_feature_reqs (\"sse2\");\n+  else if (feature == \"avx\")\n+    enable_implicit_feature_reqs (\"sse4.2\");\n+  else if (feature == \"avx2\")\n+    enable_implicit_feature_reqs (\"avx\");\n+  else if (feature == \"fma\")\n+    enable_implicit_feature_reqs (\"avx\");\n+  else if (feature == \"pclmulqdq\")\n+    enable_implicit_feature_reqs (\"sse2\");\n+  else if (feature == \"sha\")\n+    enable_implicit_feature_reqs (\"sse2\");\n+  else if (feature == \"sse2\")\n+    enable_implicit_feature_reqs (\"sse\");\n+  else if (feature == \"sse3\")\n+    enable_implicit_feature_reqs (\"sse2\");\n+  else if (feature == \"sse4.1\")\n+    enable_implicit_feature_reqs (\"sse3\");\n+  else if (feature == \"sse4.2\")\n+    enable_implicit_feature_reqs (\"sse4.1\");\n+  else if (feature == \"ssse3\")\n+    enable_implicit_feature_reqs (\"sse3\");\n+\n+  if (!has_key_value_pair (\"target_feature\", feature))\n+    {\n+      insert_key_value_pair (\"target_feature\", feature);\n+\n+      rust_debug (\"had to implicitly enable feature '%s'!\", feature.c_str ());\n+    }\n+}\n+\n+// NOTEs:\n+/* mrustc compile pipeline:\n+ *  - target load (pass target spec to parser?)\n+ *  - parse (convert source to AST)\n+ *  - load crates (load any explicitly mentioned extern crates [not all of\n+ * them])\n+ *  - expand (AST transformations from attributes and macros, loads remaining\n+ * extern crates [std/core and any triggered by macro expansion])\n+ *  - implicit crates (test harness, allocator crate, panic crate)\n+ *  - resolve use (annotate every 'use' item with source [supposedly handles\n+ * nasty recursion])\n+ *  - resolve index (generate index of visible items for every module [avoids\n+ * recursion in next pass])\n+ *  - resolve absolute (resolve all paths into either variable names\n+ * [types/values] or absolute paths)\n+ *  - HIR lower (convert modified AST to simpler HIR [both expressions and\n+ * module tree])\n+ *  - resolve type aliases (replace any usages of type aliases with actual\n+ * type [except associated types])\n+ *  - resolve bind (iterate HIR tree and set binding annotations on all\n+ * concrete types [avoids path lookups later])\n+ *  - resolve HIR markings (generate \"markings\" [e.g. for Copy/Send/Sync/...]\n+ * for all types\n+ *  - sort impls (small pass - sort impls into groups)\n+ *  - resolve UFCS outer (determine source trait for all top-level <T>::Type\n+ * [qualified] paths)\n+ *  - resolve UFCS paths (do the same, but include for exprs this time. also\n+ * normalises results of previous pass [expanding known associated types])\n+ *  - constant evaluate (evaluate all constants)\n+ *  - typecheck outer (checks impls are sane)\n+ *  - typecheck expressions (resolve and check types for all exprs)\n+ *  - expand HIR annotate (annotate how exprs are used - used for closure\n+ * extractions and reborrows)\n+ *  - expand HIR closures (extract closures into structs implementing Fn*\n+ * traits)\n+ *  - expand HIR vtables (generate vtables for types with dyn dispatch)\n+ *  - expand HIR calls (converts method and callable calls into explicit\n+ * function calls)\n+ *  - expand HIR reborrows (apply reborrow rules [taking '&mut *v' instead of\n+ * 'v'])\n+ *  - expand HIR erasedtype (replace all erased types 'impl Trait' with the\n+ * true type)\n+ *  - typecheck expressions (validate - double check that previous passes\n+ * haven't broke type system rules)\n+ *  - lower MIR (convert HIR exprs into a control-flow graph [MIR])\n+ *  - MIR validate (check that the generated MIR is consistent)\n+ *  - MIR cleanup (perform various transformations on MIR - replace reads of\n+ * const items with the item itself; convert casts to unsized types into\n+ * 'MakeDst' operations)\n+ *  - MIR optimise (perform various simple optimisations on the MIR - constant\n+ * propagation, dead code elimination, borrow elimination, some inlining)\n+ *  - MIR validate PO (re-validate the MIR)\n+ *  - MIR validate full (optionally: perform expensive state-tracking\n+ * validation on MIR)\n+ *  - trans enumerate (enumerate all items needed for code generation,\n+ * primarily types used for generics)\n+ *  - trans auto impls (create magic trait impls as enumerated in previous\n+ * pass)\n+ *  - trans monomorph (generate monomorphised copies of all functions [with\n+ * generics replaced with real types])\n+ *  - MIR optimise inline (run optimisation again, this time with full type\n+ * info [primarily for inlining])\n+ *  - HIR serialise (write out HIR dump [module tree and generic/inline MIR])\n+ *  - trans codegen (generate final output file: emit C source file and call C\n+ * compiler) */\n+\n+/* rustc compile pipeline (basic, in way less detail):\n+ *  - parse input (parse .rs to AST)\n+ *  - name resolution, macro expansion, and configuration (process AST\n+ * recursively, resolving paths, expanding macros, processing #[cfg] nodes\n+ * [i.e. maybe stripping stuff from AST])\n+ *  - lower to HIR\n+ *  - type check and other analyses (e.g. privacy checking)\n+ *  - lower to MIR and post-processing (and do stuff like borrow checking)\n+ *  - translation to LLVM IR and LLVM optimisations (produce the .o files)\n+ *  - linking (link together .o files) */\n+\n+/* Pierced-together rustc compile pipeline (from source):\n+ *  - parse input (parse file to crate)\n+ *  - register plugins (attributes injection, set various options, register\n+ * lints, load plugins)\n+ *  - expansion/configure and expand (initial 'cfg' processing, 'loading\n+ * compiler plugins', syntax expansion, secondary 'cfg' expansion, synthesis\n+ * of a test harness if required, injection of any std lib dependency and\n+ * prelude, and name resolution) - actually documented inline\n+ *      - seeming pierced-together order: pre-AST expansion lint checks,\n+ * registering builtin macros, crate injection, then expand all macros, then\n+ * maybe build test harness, AST validation, maybe create a macro crate (if\n+ * not rustdoc), name resolution, complete gated feature checking, add all\n+ * buffered lints\n+ *  - create global context (lower to HIR)\n+ *  - analysis on global context (HIR optimisations? create MIR?)\n+ *  - code generation\n+ *  - link */\n+} // namespace Rust\n+\n+#if CHECKING_P\n+namespace selftest {\n+void\n+rust_crate_name_validation_test (void)\n+{\n+  auto error = Rust::Error (Location (), std::string ());\n+  ASSERT_TRUE (Rust::validate_crate_name (\"example\", error));\n+  ASSERT_TRUE (Rust::validate_crate_name (\"abcdefg_1234\", error));\n+  ASSERT_TRUE (Rust::validate_crate_name (\"1\", error));\n+  // FIXME: The next test does not pass as of current implementation\n+  // ASSERT_TRUE (Rust::CompileOptions::validate_crate_name (\"\u60ca\u5413\"));\n+  // NOTE: - is not allowed in the crate name ...\n+\n+  ASSERT_FALSE (Rust::validate_crate_name (\"abcdefg-1234\", error));\n+  ASSERT_FALSE (Rust::validate_crate_name (\"a+b\", error));\n+  ASSERT_FALSE (Rust::validate_crate_name (\"/a+b/\", error));\n+\n+  /* Tests for crate name inference */\n+  ASSERT_EQ (Rust::infer_crate_name (\"c.rs\"), \"c\");\n+  // NOTE: ... but - is allowed when in the filename\n+  ASSERT_EQ (Rust::infer_crate_name (\"a-b.rs\"), \"a_b\");\n+  ASSERT_EQ (Rust::infer_crate_name (\"book.rs.txt\"), \"book.rs\");\n+#if defined(HAVE_DOS_BASED_FILE_SYSTEM)\n+  ASSERT_EQ (Rust::infer_crate_name (\"a\\\\c\\\\a-b.rs\"), \"a_b\");\n+#else\n+  ASSERT_EQ (Rust::infer_crate_name (\"a/c/a-b.rs\"), \"a_b\");\n+#endif\n+}\n+} // namespace selftest\n+#endif // CHECKING_P"}, {"sha": "99dd107239b163bbf9e3c5f95ad08d5218c8d72c", "filename": "gcc/rust/rust-session-manager.h", "status": "added", "additions": 358, "deletions": 0, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea34614225d4d255e58f63206eb12178b870cb4c/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea34614225d4d255e58f63206eb12178b870cb4c/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=ea34614225d4d255e58f63206eb12178b870cb4c", "patch": "@@ -0,0 +1,358 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+// #include \"rust-session-manager.h\"\n+\n+#ifndef RUST_SESSION_MANAGER_H\n+#define RUST_SESSION_MANAGER_H\n+\n+#include \"rust-linemap.h\"\n+#include \"rust-backend.h\"\n+#include \"rust-hir-map.h\"\n+#include \"safe-ctype.h\"\n+\n+#include \"config.h\"\n+#include \"rust-system.h\"\n+#include \"coretypes.h\"\n+#include \"options.h\"\n+\n+namespace Rust {\n+// parser forward decl\n+template <typename ManagedTokenSource> class Parser;\n+class Lexer;\n+// crate forward decl\n+namespace AST {\n+struct Crate;\n+}\n+// crate forward decl\n+namespace HIR {\n+struct Crate;\n+}\n+\n+/* Data related to target, most useful for conditional compilation and\n+ * whatever. */\n+struct TargetOptions\n+{\n+  /* TODO: maybe make private and access through helpers to allow changes to\n+   * impl */\n+  std::unordered_map<std::string, std::unordered_set<std::string> > features;\n+\n+public:\n+  // Returns whether a key is defined in the feature set.\n+  bool has_key (std::string key) const\n+  {\n+    return features.find (key) != features.end ();\n+  }\n+\n+  // Returns whether a key exists with the given value in the feature set.\n+  bool has_key_value_pair (std::string key, std::string value) const\n+  {\n+    auto it = features.find (key);\n+    if (it != features.end ())\n+      {\n+\tauto set = it->second;\n+\tauto it2 = set.find (value);\n+\tif (it2 != set.end ())\n+\t  return true;\n+      }\n+    return false;\n+  }\n+\n+  /* Returns the singular value from the key, or if the key has multiple, an\n+   * empty string. */\n+  std::string get_singular_value (std::string key) const\n+  {\n+    auto it = features.find (key);\n+    if (it != features.end ())\n+      {\n+\tauto set = it->second;\n+\tif (set.size () == 1)\n+\t  return *set.begin ();\n+      }\n+    return \"\";\n+  }\n+\n+  /* Returns all values associated with a key (including none), or an empty\n+   * set if no key is found. */\n+  std::unordered_set<std::string> get_values_for_key (std::string key) const\n+  {\n+    auto it = features.find (key);\n+    if (it != features.end ())\n+      return it->second;\n+    return {};\n+  }\n+\n+  /* Inserts a key (no value) into the feature set. This will do nothing if\n+   * the key already exists. This returns whether the insertion was successful\n+   * (i.e. whether key already existed). */\n+  bool insert_key (std::string key)\n+  {\n+    return features\n+      .insert (std::make_pair (key, std::unordered_set<std::string> ()))\n+      .second;\n+  }\n+\n+  // Inserts a key-value pair into the feature set.\n+  void insert_key_value_pair (std::string key, std::string value)\n+  {\n+    auto existing_set = get_values_for_key (key);\n+    existing_set.insert (std::move (value));\n+    features[std::move (key)] = std::move (existing_set);\n+  }\n+\n+  // Dump all target options to stderr.\n+  void dump_target_options () const;\n+\n+  /* Creates derived values and implicit enables after all target info is\n+   * added (e.g. \"unix\"). */\n+  void init_derived_values ();\n+\n+  /* Enables all requirements for the feature given, and will enable feature\n+   * itself if not enabled. */\n+  void enable_implicit_feature_reqs (std::string feature);\n+\n+  /* According to reference, Rust uses either multi-map key-values or just\n+   * values (although values may be aliases for a key-value value). This seems\n+   * like overkill. Thus, depending on whether the attributes used in cfg are\n+   * fixed or not, I think I'll either put each non-multimap \"key-value\" as a\n+   * separate field and have the multimap \"key-values\" in a regular map for\n+   * that one key, or actually use a multimap.\n+   *\n+   * rustc itself uses a set of key-value tuples where the second tuple\n+   * element is optional. This gets rid of the requirement to make a\n+   * multi-map, I guess, but seems like it might make search slow (unless all\n+   * \"is defined\"-only ones have empty string as second element). */\n+  /* cfg attributes:\n+   * - target_arch: single value\n+   * - target_feature: multiple values possible\n+   * - target_os: single value\n+   * - target_family: single value (or no value?)\n+   * - unix: set when target_family = \"unix\"\n+   * - windows: set when target_family = \"windows\"\n+   *  - if these are just syntactic sugar, then maybe have a separate set or\n+   * map for this kind of stuff\n+   * - target_env: set when needed for disambiguation about ABI - usually\n+   * empty string for GNU, complicated\n+   *  - seems to be a single value (if any)\n+   * - target_endian: single value; \"little\" or \"big\"\n+   * - target_pointer_width: single value, \"32\" for 32-bit pointers, etc.\n+   * - target_vendor, single value\n+   * - test: set when testing is being done\n+   *  - again, seems similar to a \"is defined\" rather than \"is equal to\" like\n+   * unix\n+   * - debug_assertions: seems to \"is defined\"\n+   * - proc_macro: no idea, bad docs. seems to be boolean, so maybe \"is\n+   * defined\"\n+   */\n+};\n+\n+// Defines compiler options (e.g. dump, etc.).\n+struct CompileOptions\n+{\n+  enum DumpOption\n+  {\n+    LEXER_DUMP,\n+    PARSER_AST_DUMP,\n+    AST_DUMP_PRETTY,\n+    REGISTER_PLUGINS_DUMP,\n+    INJECTION_DUMP,\n+    EXPANSION_DUMP,\n+    RESOLUTION_DUMP,\n+    TARGET_OPTION_DUMP,\n+    HIR_DUMP,\n+    HIR_DUMP_PRETTY,\n+    TYPE_RESOLUTION_DUMP,\n+  };\n+\n+  std::set<DumpOption> dump_options;\n+\n+  /* configuration options - actually useful for conditional compilation and\n+   * whatever data related to target arch, features, os, family, env, endian,\n+   * pointer width, vendor */\n+  TargetOptions target_data;\n+  std::string crate_name;\n+  bool crate_name_set_manually = false;\n+  bool enable_test = false;\n+  bool debug_assertions = false;\n+  bool proc_macro = false;\n+  std::string metadata_output_path;\n+\n+  enum class Edition\n+  {\n+    E2015 = 0,\n+    E2018,\n+    E2021,\n+  } edition\n+    = Edition::E2015;\n+\n+  bool dump_option_enabled (DumpOption option) const\n+  {\n+    return dump_options.find (option) != dump_options.end ();\n+  }\n+\n+  void enable_dump_option (DumpOption option) { dump_options.insert (option); }\n+\n+  void enable_all_dump_options ()\n+  {\n+    enable_dump_option (DumpOption::LEXER_DUMP);\n+    enable_dump_option (DumpOption::PARSER_AST_DUMP);\n+    enable_dump_option (DumpOption::AST_DUMP_PRETTY);\n+    enable_dump_option (DumpOption::REGISTER_PLUGINS_DUMP);\n+    enable_dump_option (DumpOption::INJECTION_DUMP);\n+    enable_dump_option (DumpOption::EXPANSION_DUMP);\n+    enable_dump_option (DumpOption::RESOLUTION_DUMP);\n+    enable_dump_option (DumpOption::TARGET_OPTION_DUMP);\n+    enable_dump_option (DumpOption::HIR_DUMP);\n+    enable_dump_option (DumpOption::HIR_DUMP_PRETTY);\n+    enable_dump_option (DumpOption::TYPE_RESOLUTION_DUMP);\n+  }\n+\n+  void set_crate_name (std::string name)\n+  {\n+    rust_assert (!name.empty ());\n+\n+    crate_name = std::move (name);\n+  }\n+\n+  const std::string &get_crate_name () const\n+  {\n+    rust_assert (!crate_name.empty ());\n+    return crate_name;\n+  }\n+\n+  void set_edition (int raw_edition)\n+  {\n+    edition = static_cast<Edition> (raw_edition);\n+  }\n+\n+  const Edition &get_edition () { return edition; }\n+\n+  void set_metadata_output (const std::string &path)\n+  {\n+    metadata_output_path = path;\n+  }\n+\n+  const std::string &get_metadata_output () const\n+  {\n+    return metadata_output_path;\n+  }\n+\n+  bool metadata_output_path_set () const\n+  {\n+    return !metadata_output_path.empty ();\n+  }\n+};\n+\n+/* Defines a compiler session. This is for a single compiler invocation, so\n+ * potentially includes parsing multiple crates. */\n+struct Session\n+{\n+  CompileOptions options;\n+  /* This should really be in a per-crate storage area but it is wiped with\n+   * every file so eh. */\n+  std::string injected_crate_name;\n+\n+  /* extra files get included during late stages of compilation (e.g. macro\n+   * expansion) */\n+  std::vector<std::string> extra_files;\n+\n+  // backend wrapper to GCC GENERIC\n+  Backend *backend;\n+\n+  // backend linemap\n+  Linemap *linemap;\n+\n+  // mappings\n+  Analysis::Mappings *mappings;\n+\n+public:\n+  /* Get a reference to the static session instance */\n+  static Session &get_instance ();\n+\n+  Session () = default;\n+  ~Session () = default;\n+\n+  /* This initializes the compiler session. Corresponds to langhook\n+   * grs_langhook_init(). Note that this is called after option handling. */\n+  void init ();\n+\n+  // delete those constructors so we don't access the singleton in any\n+  // other way than via `get_instance()`\n+  Session (Session const &) = delete;\n+  void operator= (Session const &) = delete;\n+\n+  bool handle_option (enum opt_code code, const char *arg, HOST_WIDE_INT value,\n+\t\t      int kind, location_t loc,\n+\t\t      const struct cl_option_handlers *handlers);\n+  void handle_input_files (int num_files, const char **files);\n+  void init_options ();\n+  void handle_crate_name (const AST::Crate &parsed_crate);\n+\n+  /* This function saves the filename data into the session manager using the\n+   * `move` semantics, and returns a C-style string referencing the input\n+   * std::string */\n+  inline const char *include_extra_file (std::string filename)\n+  {\n+    extra_files.push_back (std::move (filename));\n+    return extra_files.back ().c_str ();\n+  }\n+\n+  NodeId load_extern_crate (const std::string &crate_name, Location locus);\n+\n+private:\n+  void compile_crate (const char *filename);\n+  bool enable_dump (std::string arg);\n+\n+  void dump_lex (Parser<Lexer> &parser) const;\n+  void dump_ast (Parser<Lexer> &parser, AST::Crate &crate) const;\n+  void dump_ast_pretty (AST::Crate &crate) const;\n+  void dump_ast_expanded (Parser<Lexer> &parser, AST::Crate &crate) const;\n+  void dump_hir (HIR::Crate &crate) const;\n+  void dump_hir_pretty (HIR::Crate &crate) const;\n+  void dump_type_resolution (HIR::Crate &crate) const;\n+\n+  // pipeline stages - TODO maybe move?\n+  /* Register plugins pipeline stage. TODO maybe move to another object?\n+   * Currently dummy stage. In future will handle attribute injection\n+   * (top-level inner attribute creation from command line arguments), setting\n+   * options maybe, registering lints maybe, loading plugins maybe. */\n+  void register_plugins (AST::Crate &crate);\n+\n+  /* Injection pipeline stage. TODO maybe move to another object? Maybe have\n+   * some lint checks (in future, obviously), register builtin macros, crate\n+   * injection. */\n+  void injection (AST::Crate &crate);\n+\n+  /* Expansion pipeline stage. TODO maybe move to another object? Expands all\n+   * macros, maybe build test harness in future, AST validation, maybe create\n+   * macro crate (if not rustdoc).*/\n+  void expansion (AST::Crate &crate);\n+\n+  // handle cfg_option\n+  bool handle_cfg_option (std::string &data);\n+};\n+\n+} // namespace Rust\n+\n+#if CHECKING_P\n+namespace selftest {\n+extern void\n+rust_crate_name_validation_test (void);\n+}\n+#endif // CHECKING_P\n+\n+#endif"}]}