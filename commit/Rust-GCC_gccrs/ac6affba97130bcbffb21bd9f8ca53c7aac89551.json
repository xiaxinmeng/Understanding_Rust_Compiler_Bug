{"sha": "ac6affba97130bcbffb21bd9f8ca53c7aac89551", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM2YWZmYmE5NzEzMGJjYmZmYjIxYmQ5ZjhjYTUzYzdhYWM4OTU1MQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-03T10:52:47Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-03T12:33:37Z"}, "message": "tree-optimization/80928 - SLP vectorize nested loop induction\n\nThis adds SLP vectorization of nested inductions.\n\n2020-11-03  Richard Biener <rguenther@suse.de>\n\n\tPR tree-optimization/80928\n\t* tree-vect-loop.c (vectorizable_induction): SLP vectorize\n\tnested inductions.\n\n\t* gcc.dg/vect/vect-outer-slp-2.c: New testcase.\n\t* gcc.dg/vect/vect-outer-slp-3.c: Likewise.", "tree": {"sha": "a783ee9359c945300597edd7cd63367348d3d224", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a783ee9359c945300597edd7cd63367348d3d224"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac6affba97130bcbffb21bd9f8ca53c7aac89551", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac6affba97130bcbffb21bd9f8ca53c7aac89551", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac6affba97130bcbffb21bd9f8ca53c7aac89551", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac6affba97130bcbffb21bd9f8ca53c7aac89551/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a562d44924489d2e82dc61fca4607ab38061b375", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a562d44924489d2e82dc61fca4607ab38061b375", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a562d44924489d2e82dc61fca4607ab38061b375"}], "stats": {"total": 229, "additions": 164, "deletions": 65}, "files": [{"sha": "08b4fc52430326fea3a93455c7b92710328d2bb1", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-slp-2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6affba97130bcbffb21bd9f8ca53c7aac89551/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-slp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6affba97130bcbffb21bd9f8ca53c7aac89551/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-slp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-slp-2.c?ref=ac6affba97130bcbffb21bd9f8ca53c7aac89551", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-require-effective-target vect_intdouble_cvt } */\n+\n+#include \"tree-vect.h\"\n+\n+double image[40];\n+\n+void __attribute__((noipa))\n+foo (void)\n+{\n+  for (int i = 0; i < 20; i++)\n+    {\n+      double suma = 0;\n+      double sumb = 0;\n+      for (int j = 0; j < 40; j++)\n+\t{\n+\t  suma += j+i;\n+\t  sumb += j+i;\n+\t}\n+      image[2*i] = suma;\n+      image[2*i+1] = sumb;\n+    }\n+}\n+\n+int main ()\n+{\n+  check_vect ();\n+\n+  foo ();\n+\n+  for (int i = 0; i < 20; i++)\n+    {\n+      double suma = 0;\n+      double sumb = 0;\n+      for (int j = 0; j < 40; j++)\n+\t{\n+\t  suma += j+i;\n+\t  sumb += j+i;\n+\t  asm (\"\" : \"+g\" (suma));\n+\t  asm (\"\" : \"+g\" (sumb));\n+\t}\n+      if (image[2*i] != suma\n+\t  || image[2*i+1] != sumb)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" } } */"}, {"sha": "c67d3690bb4d2dda776b7d6fafd1c714a85da108", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-slp-3.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6affba97130bcbffb21bd9f8ca53c7aac89551/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-slp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6affba97130bcbffb21bd9f8ca53c7aac89551/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-slp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-slp-3.c?ref=ac6affba97130bcbffb21bd9f8ca53c7aac89551", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-require-effective-target vect_intdouble_cvt } */\n+\n+#include \"tree-vect.h\"\n+\n+double image[40];\n+\n+void __attribute__((noipa))\n+foo (void)\n+{\n+  for (int i = 0; i < 20; i++)\n+    {\n+      double suma = 0;\n+      double sumb = 0;\n+      int k = image[2*i];\n+      int l = image[2*i+1];\n+      for (int j = 0; j < 40; j++)\n+        {\n+          suma += k+i;\n+          sumb += l+i;\n+          k++;\n+          l++;\n+        }\n+      image[2*i] = suma;\n+      image[2*i+1] = sumb;\n+    }\n+}\n+\n+int main ()\n+{\n+  check_vect ();\n+\n+  for (int i = 0; i < 40; ++i)\n+    image[i] = 1.;\n+\n+  foo ();\n+\n+  for (int i = 0; i < 20; i++)\n+    {\n+      double suma = 0;\n+      double sumb = 0;\n+      int k = 1;\n+      int l = 1;\n+      for (int j = 0; j < 40; j++)\n+\t{\n+          suma += k+i;\n+          sumb += l+i;\n+\t  asm (\"\" : \"+g\" (suma));\n+\t  asm (\"\" : \"+g\" (sumb));\n+          k++;\n+          l++;\n+\t}\n+      if (image[2*i] != suma\n+\t  || image[2*i+1] != sumb)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" } } */"}, {"sha": "41e2e2ade207f509cdb5c945e4c7e7b6aa37490b", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 51, "deletions": 65, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6affba97130bcbffb21bd9f8ca53c7aac89551/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6affba97130bcbffb21bd9f8ca53c7aac89551/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=ac6affba97130bcbffb21bd9f8ca53c7aac89551", "patch": "@@ -7686,7 +7686,6 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n   poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   unsigned i;\n   tree expr;\n-  gimple_seq stmts;\n   gimple_stmt_iterator si;\n \n   gphi *phi = dyn_cast <gphi *> (stmt_info->stmt);\n@@ -7726,10 +7725,6 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \t  return false;\n \t}\n \n-      /* FORNOW: outer loop induction with SLP not supported.  */\n-      if (STMT_SLP_TYPE (stmt_info))\n-\treturn false;\n-\n       exit_phi = NULL;\n       latch_e = loop_latch_edge (loop->inner);\n       loop_arg = PHI_ARG_DEF_FROM_EDGE (phi, latch_e);\n@@ -7875,32 +7870,37 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n       /* Now generate the IVs.  */\n       unsigned nvects = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n       gcc_assert ((const_nunits * nvects) % group_size == 0);\n-      unsigned nivs = least_common_multiple (group_size,\n-\t\t\t\t\t     const_nunits) / const_nunits;\n-      unsigned lup_mul = (nvects * const_nunits) / group_size;\n+      unsigned nivs;\n+      if (nested_in_vect_loop)\n+\tnivs = nvects;\n+      else\n+\tnivs = least_common_multiple (group_size,\n+\t\t\t\t      const_nunits) / const_nunits;\n       tree stept = TREE_TYPE (step_vectype);\n-      tree lupdate_mul\n-\t= build_vector_from_val (step_vectype,\n-\t\t\t\t SCALAR_FLOAT_TYPE_P (stept)\n-\t\t\t\t ? build_real_from_wide (stept, lup_mul,\n-\t\t\t\t\t\t\t UNSIGNED)\n-\t\t\t\t : build_int_cstu (stept, lup_mul));\n+      tree lupdate_mul = NULL_TREE;\n+      if (!nested_in_vect_loop)\n+\t{\n+\t  /* The number of iterations covered in one vector iteration.  */\n+\t  unsigned lup_mul = (nvects * const_nunits) / group_size;\n+\t  lupdate_mul\n+\t    = build_vector_from_val (step_vectype,\n+\t\t\t\t     SCALAR_FLOAT_TYPE_P (stept)\n+\t\t\t\t     ? build_real_from_wide (stept, lup_mul,\n+\t\t\t\t\t\t\t     UNSIGNED)\n+\t\t\t\t     : build_int_cstu (stept, lup_mul));\n+\t}\n       tree peel_mul = NULL_TREE;\n+      gimple_seq init_stmts = NULL;\n       if (LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo))\n \t{\n-\t  stmts = NULL;\n \t  if (SCALAR_FLOAT_TYPE_P (stept))\n-\t    peel_mul = gimple_build (&stmts, FLOAT_EXPR, stept,\n+\t    peel_mul = gimple_build (&init_stmts, FLOAT_EXPR, stept,\n \t\t\t\t     LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo));\n \t  else\n-\t    peel_mul = gimple_convert (&stmts, stept,\n+\t    peel_mul = gimple_convert (&init_stmts, stept,\n \t\t\t\t       LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo));\n-\t  peel_mul = gimple_build_vector_from_val (&stmts, step_vectype, peel_mul);\n-\t  if (stmts)\n-\t    {\n-\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-\t      gcc_assert (!new_bb);\n-\t    }\n+\t  peel_mul = gimple_build_vector_from_val (&init_stmts,\n+\t\t\t\t\t\t   step_vectype, peel_mul);\n \t}\n       unsigned ivn;\n       auto_vec<tree> vec_steps;\n@@ -7911,34 +7911,31 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \t  tree_vector_builder mul_elts (step_vectype, const_nunits, 1);\n \t  for (unsigned eltn = 0; eltn < const_nunits; ++eltn)\n \t    {\n+\t      /* The scalar steps of the IVs.  */\n \t      tree elt = steps[(ivn*const_nunits + eltn) % group_size];\n \t      step_elts.quick_push (elt);\n \t      if (!init_node)\n \t\t{\n+\t\t  /* The scalar inits of the IVs if not vectorized.  */\n \t\t  elt = inits[(ivn*const_nunits + eltn) % group_size];\n \t\t  init_elts.quick_push (elt);\n \t\t}\n+\t      /* The number of steps to add to the initial values.  */\n \t      unsigned mul_elt = (ivn*const_nunits + eltn) / group_size;\n \t      mul_elts.quick_push (SCALAR_FLOAT_TYPE_P (stept)\n \t\t\t\t   ? build_real_from_wide (stept,\n \t\t\t\t\t\t\t   mul_elt, UNSIGNED)\n \t\t\t\t   : build_int_cstu (stept, mul_elt));\n \t    }\n-\t  stmts = NULL;\n-\t  vec_step = gimple_build_vector (&stmts, &step_elts);\n-\t  vec_step = gimple_convert (&stmts, step_vectype, vec_step);\n+\t  vec_step = gimple_build_vector (&init_stmts, &step_elts);\n+\t  vec_step = gimple_convert (&init_stmts, step_vectype, vec_step);\n \t  vec_steps.safe_push (vec_step);\n-\t  tree step_mul = gimple_build_vector (&stmts, &mul_elts);\n+\t  tree step_mul = gimple_build_vector (&init_stmts, &mul_elts);\n \t  if (peel_mul)\n-\t    gimple_build (&stmts, PLUS_EXPR, step_vectype,\n-\t\t\t  step_mul, peel_mul);\n+\t    step_mul = gimple_build (&init_stmts, PLUS_EXPR, step_vectype,\n+\t\t\t\t     step_mul, peel_mul);\n \t  if (!init_node)\n-\t    vec_init = gimple_build_vector (&stmts, &init_elts);\n-\t  if (stmts)\n-\t    {\n-\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-\t      gcc_assert (!new_bb);\n-\t    }\n+\t    vec_init = gimple_build_vector (&init_stmts, &init_elts);\n \n \t  /* Create the induction-phi that defines the induction-operand.  */\n \t  vec_dest = vect_get_new_vect_var (vectype, vect_simple_var,\n@@ -7947,15 +7944,11 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \t  induc_def = PHI_RESULT (induction_phi);\n \n \t  /* Create the iv update inside the loop  */\n-\t  stmts = NULL;\n-\t  tree up = gimple_build (&stmts, MULT_EXPR, step_vectype,\n-\t\t\t\t  vec_step, lupdate_mul);\n-\t  if (stmts)\n-\t    {\n-\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-\t      gcc_assert (!new_bb);\n-\t    }\n-\t  stmts = NULL;\n+\t  tree up = vec_step;\n+\t  if (lupdate_mul)\n+\t    up = gimple_build (&init_stmts, MULT_EXPR, step_vectype,\n+\t\t\t       vec_step, lupdate_mul);\n+\t  gimple_seq stmts = NULL;\n \t  vec_def = gimple_convert (&stmts, step_vectype, induc_def);\n \t  vec_def = gimple_build (&stmts,\n \t\t\t\t  PLUS_EXPR, step_vectype, vec_def, up);\n@@ -7966,17 +7959,15 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \n \t  if (init_node)\n \t    vec_init = vect_get_slp_vect_def (init_node, ivn);\n-\t  if (!integer_zerop (step_mul))\n+\t  if (!nested_in_vect_loop\n+\t      && !integer_zerop (step_mul))\n \t    {\n-\t      stmts = NULL;\n-\t      vec_def = gimple_convert (&stmts, step_vectype, vec_init);\n-\t      up = gimple_build (&stmts, MULT_EXPR, step_vectype,\n+\t      vec_def = gimple_convert (&init_stmts, step_vectype, vec_init);\n+\t      up = gimple_build (&init_stmts, MULT_EXPR, step_vectype,\n \t\t\t\t vec_step, step_mul);\n-\t      vec_def = gimple_build (&stmts, PLUS_EXPR, step_vectype,\n+\t      vec_def = gimple_build (&init_stmts, PLUS_EXPR, step_vectype,\n \t\t\t\t      vec_def, up);\n-\t      vec_init = gimple_convert (&stmts, vectype, vec_def);\n-\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-\t      gcc_assert (!new_bb);\n+\t      vec_init = gimple_convert (&init_stmts, vectype, vec_def);\n \t    }\n \n \t  /* Set the arguments of the phi node:  */\n@@ -8001,19 +7992,11 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \t    {\n \t      gimple *iv = SLP_TREE_VEC_STMTS (slp_node)[ivn - nivs];\n \t      tree def = gimple_get_lhs (iv);\n-\t      gimple_seq stmts = NULL;\n \t      if (ivn < 2*nivs)\n-\t\t{\n-\t\t  vec_steps[ivn - nivs]\n-\t\t    = gimple_build (&stmts, MULT_EXPR, step_vectype,\n-\t\t\t\t    vec_steps[ivn - nivs], lupdate_mul);\n-\t\t  if (stmts)\n-\t\t    {\n-\t\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-\t\t      gcc_assert (!new_bb);\n-\t\t    }\n-\t\t}\n-\t      stmts = NULL;\n+\t\tvec_steps[ivn - nivs]\n+\t\t  = gimple_build (&init_stmts, MULT_EXPR, step_vectype,\n+\t\t\t\t  vec_steps[ivn - nivs], lupdate_mul);\n+\t      gimple_seq stmts = NULL;\n \t      def = gimple_convert (&stmts, step_vectype, def);\n \t      def = gimple_build (&stmts, PLUS_EXPR, step_vectype,\n \t\t\t\t  def, vec_steps[ivn % nivs]);\n@@ -8030,13 +8013,16 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \t    }\n \t}\n \n+      new_bb = gsi_insert_seq_on_edge_immediate (pe, init_stmts);\n+      gcc_assert (!new_bb);\n+\n       return true;\n     }\n \n   init_expr = PHI_ARG_DEF_FROM_EDGE (phi,\n \t\t\t\t     loop_preheader_edge (iv_loop));\n \n-  stmts = NULL;\n+  gimple_seq stmts = NULL;\n   if (!nested_in_vect_loop)\n     {\n       /* Convert the initial value to the IV update type.  */"}]}