{"sha": "ed396e68008200351bd49b4eb8a1cbe644d3b5f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQzOTZlNjgwMDgyMDAzNTFiZDQ5YjRlYjhhMWNiZTY0NGQzYjVmMw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-28T10:22:48Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-28T10:22:48Z"}, "message": "regclass.c (renumber, [...]): New static variables, moved out of allocate_reg_info.\n\n        * regclass.c (renumber, regno_allocated): New static variables, moved\n        out of allocate_reg_info.\n        (allocate_reg_info): Move these two variables outside the function.\n        Move code to free memory into new function free_reg_info.\n        (free_reg_info): New function, broken out of allocate_reg_info.\n        * toplev.c (compile_file): Call free_reg_info, not allocate_reg_info.\n        * rtl.h (allocate_reg_info): Don't declare.\n        (free_reg_info): Declare.\n\nFrom-SVN: r23397", "tree": {"sha": "930e66784844e640aa3c34f9123f16d19b6cb753", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/930e66784844e640aa3c34f9123f16d19b6cb753"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed396e68008200351bd49b4eb8a1cbe644d3b5f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed396e68008200351bd49b4eb8a1cbe644d3b5f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed396e68008200351bd49b4eb8a1cbe644d3b5f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed396e68008200351bd49b4eb8a1cbe644d3b5f3/comments", "author": null, "committer": null, "parents": [{"sha": "e626b8402cd9d9bfb88ddc0cc65f6cc734928d72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e626b8402cd9d9bfb88ddc0cc65f6cc734928d72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e626b8402cd9d9bfb88ddc0cc65f6cc734928d72"}], "stats": {"total": 70, "additions": 43, "deletions": 27}, "files": [{"sha": "a84f2124f9a14c294f87210b77985df8540c0581", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed396e68008200351bd49b4eb8a1cbe644d3b5f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed396e68008200351bd49b4eb8a1cbe644d3b5f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed396e68008200351bd49b4eb8a1cbe644d3b5f3", "patch": "@@ -1,5 +1,14 @@\n Wed Oct 28 03:59:29 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n \n+\t* regclass.c (renumber, regno_allocated): New static variables, moved\n+\tout of allocate_reg_info.\n+\t(allocate_reg_info): Move these two variables outside the function.\n+\tMove code to free memory into new function free_reg_info.\n+\t(free_reg_info): New function, broken out of allocate_reg_info.\n+\t* toplev.c (compile_file): Call free_reg_info, not allocate_reg_info.\n+\t* rtl.h (allocate_reg_info): Don't declare.\n+\t(free_reg_info): Declare.\n+\n \t* final.c (cleanup_subreg_operands):  ASM_INPUTs need no treatment.\n \n Wed Oct 28 02:38:12 1998  Jason Merrill  <jason@yorick.cygnus.com>"}, {"sha": "d9b6db6dee697175276b4ff2e3e5c1bf952c5dae", "filename": "gcc/regclass.c", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed396e68008200351bd49b4eb8a1cbe644d3b5f3/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed396e68008200351bd49b4eb8a1cbe644d3b5f3/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=ed396e68008200351bd49b4eb8a1cbe644d3b5f3", "patch": "@@ -1827,6 +1827,9 @@ auto_inc_dec_reg_p (reg, mode)\n \n #endif /* REGISTER_CONSTRAINTS */\n \f\n+static short *renumber = (short *)0;\n+static size_t regno_allocated = 0;\n+\n /* Allocate enough space to hold NUM_REGS registers for the tables used for\n    reg_scan and flow_analysis that are indexed by the register number.  If\n    NEW_P is non zero, initialize all of the registers, otherwise only\n@@ -1840,38 +1843,12 @@ allocate_reg_info (num_regs, new_p, renumber_p)\n      int new_p;\n      int renumber_p;\n {\n-  static size_t regno_allocated = 0;\n-  static short *renumber = (short *)0;\n   size_t size_info;\n   size_t size_renumber;\n   size_t min = (new_p) ? 0 : reg_n_max;\n   struct reg_info_data *reg_data;\n   struct reg_info_data *reg_next;\n \n-  /* Free up all storage allocated */\n-  if (num_regs < 0)\n-    {\n-      if (reg_n_info)\n-\t{\n-\t  VARRAY_FREE (reg_n_info);\n-\t  for (reg_data = reg_info_head; reg_data; reg_data = reg_next)\n-\t    {\n-\t      reg_next = reg_data->next;\n-\t      free ((char *)reg_data);\n-\t    }\n-\n-\t  free (prefclass_buffer);\n-\t  free (altclass_buffer);\n-\t  prefclass_buffer = (char *)0;\n-\t  altclass_buffer = (char *)0;\n-\t  reg_info_head = (struct reg_info_data *)0;\n-\t  renumber = (short *)0;\n-\t}\n-      regno_allocated = 0;\n-      reg_n_max = 0;\n-      return;\n-    }\n-\n   if (num_regs > regno_allocated)\n     {\n       size_t old_allocated = regno_allocated;\n@@ -1973,6 +1950,32 @@ allocate_reg_info (num_regs, new_p, renumber_p)\n   MAX_REGNO_REG_SET (num_regs, new_p, renumber_p);\n }\n \n+/* Free up the space allocated by allocate_reg_info.  */\n+void\n+free_reg_info ()\n+{\n+  if (reg_n_info)\n+    {\n+      struct reg_info_data *reg_data;\n+      struct reg_info_data *reg_next;\n+\n+      VARRAY_FREE (reg_n_info);\n+      for (reg_data = reg_info_head; reg_data; reg_data = reg_next)\n+\t{\n+\t  reg_next = reg_data->next;\n+\t  free ((char *)reg_data);\n+\t}\n+\n+      free (prefclass_buffer);\n+      free (altclass_buffer);\n+      prefclass_buffer = (char *)0;\n+      altclass_buffer = (char *)0;\n+      reg_info_head = (struct reg_info_data *)0;\n+      renumber = (short *)0;\n+    }\n+  regno_allocated = 0;\n+  reg_n_max = 0;\n+}\n \f\n /* This is the `regscan' pass of the compiler, run just before cse\n    and again just before loop."}, {"sha": "0ca999e38abb5e63bebdf2cfb98dfb777854bea1", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed396e68008200351bd49b4eb8a1cbe644d3b5f3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed396e68008200351bd49b4eb8a1cbe644d3b5f3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ed396e68008200351bd49b4eb8a1cbe644d3b5f3", "patch": "@@ -1010,7 +1010,7 @@ extern rtx find_use_as_address\t\tPROTO((rtx, rtx, HOST_WIDE_INT));\n extern int max_parallel;\n \n /* Free up register info memory.  */\n-extern void allocate_reg_info\t\tPROTO((size_t, int, int));\n+extern void free_reg_info\t\tPROTO((void));\n \n /* recog.c */\n extern int asm_noperands\t\tPROTO((rtx));"}, {"sha": "197d2801d7860a66a7eb8d57231b5b57b2513327", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed396e68008200351bd49b4eb8a1cbe644d3b5f3/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed396e68008200351bd49b4eb8a1cbe644d3b5f3/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ed396e68008200351bd49b4eb8a1cbe644d3b5f3", "patch": "@@ -3067,6 +3067,7 @@ compile_file (name)\n   ASM_FILE_END (asm_out_file);\n #endif\n \n+\n   /* Language-specific end of compilation actions.  */\n  finish_syntax:\n   lang_finish ();\n@@ -3097,6 +3098,9 @@ compile_file (name)\n       && (ferror (asm_out_file) != 0 || fclose (asm_out_file) != 0))\n     fatal_io_error (asm_file_name);\n \n+  /* Free up memory for the benefit of leak detectors.  */\n+  free_reg_info ();\n+\n   /* Print the times.  */\n \n   if (! quiet_flag)"}]}