{"sha": "df4f95dbd4764ffc1e8270e5b3c0fd71b6724562", "node_id": "C_kwDOANBUbNoAKGRmNGY5NWRiZDQ3NjRmZmMxZTgyNzBlNWIzYzBmZDcxYjY3MjQ1NjI", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-06-03T13:08:41Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-06-03T13:08:41Z"}, "message": "c++: find_template_parameters and PARM_DECLs [PR105797]\n\nAs explained in r11-4959-gde6f64f9556ae3, the atom cache assumes two\nequivalent expressions (according to cp_tree_equal) must use the same\ntemplate parameters (according to find_template_parameters).  This\nassumption turned out to not hold for TARGET_EXPR, which was addressed\nby that commit.\n\nBut this assumption apparently doesn't hold for PARM_DECL either:\nfind_template_parameters walks its DECL_CONTEXT but cp_tree_equal by\ndefault doesn't consider DECL_CONTEXT unless comparing_specializations\nis set.  Thus in the first testcase below, the atomic constraints of #1\nand #2 are equivalent according to cp_tree_equal, but according to\nfind_template_parameters the former uses T and the latter uses both T\nand U (surprisingly).\n\nWe could fix this assumption violation by setting comparing_specializations\nin the atom_hasher, which would make cp_tree_equal return false for the\ntwo atoms, but that seems overly pessimistic here.  Ideally the atoms\nshould continue being considered equivalent and we instead fix\nfind_template_paremeters to return just T for #2's atom.\n\nTo that end this patch makes for_each_template_parm_r stop walking the\nDECL_CONTEXT of a PARM_DECL.  This should be safe to do because\ntsubst_copy / tsubst_decl only substitutes the TREE_TYPE of a PARM_DECL\nand doesn't bother substituting the DECL_CONTEXT, thus the only relevant\ntemplate parameters are those used in its type.  any_template_parm_r is\ncurrently responsible for walking its TREE_TYPE, but I suppose it now makes\nsense for for_each_template_parm_r to do so instead.\n\nIn passing this patch also makes for_each_template_parm_r stop walking\nthe DECL_CONTEXT of a VAR_/FUNCTION_DECL since doing so after walking\nDECL_TI_ARGS is redundant, I think.\n\nI experimented with not walking DECL_CONTEXT for CONST_DECL, but the\nsecond testcase below demonstrates it's necessary to walk it.\n\n\tPR c++/105797\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (for_each_template_parm_r) <case FUNCTION_DECL, VAR_DECL>:\n\tDon't walk DECL_CONTEXT.\n\t<case PARM_DECL>: Likewise.  Walk TREE_TYPE.\n\t<case CONST_DECL>: Simplify.\n\t(any_template_parm_r) <case PARM_DECL>: Don't walk TREE_TYPE.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/concepts-decltype4.C: New test.\n\t* g++.dg/cpp2a/concepts-memfun3.C: New test.", "tree": {"sha": "7d9eefc872aebaaafc6c3a8c28cfd0b22fa98d80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d9eefc872aebaaafc6c3a8c28cfd0b22fa98d80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df4f95dbd4764ffc1e8270e5b3c0fd71b6724562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df4f95dbd4764ffc1e8270e5b3c0fd71b6724562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df4f95dbd4764ffc1e8270e5b3c0fd71b6724562", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df4f95dbd4764ffc1e8270e5b3c0fd71b6724562/comments", "author": null, "committer": null, "parents": [{"sha": "1982fe2692b6c3b7f969ffc4edac59f9d4359e91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1982fe2692b6c3b7f969ffc4edac59f9d4359e91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1982fe2692b6c3b7f969ffc4edac59f9d4359e91"}], "stats": {"total": 38, "additions": 33, "deletions": 5}, "files": [{"sha": "d0c4c9889c9e4d91e468db42fb8cae429eb836b7", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4f95dbd4764ffc1e8270e5b3c0fd71b6724562/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4f95dbd4764ffc1e8270e5b3c0fd71b6724562/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=df4f95dbd4764ffc1e8270e5b3c0fd71b6724562", "patch": "@@ -10561,11 +10561,14 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n     case VAR_DECL:\n       if (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t))\n \tWALK_SUBTREE (DECL_TI_ARGS (t));\n-      /* Fall through.  */\n+      break;\n \n     case PARM_DECL:\n+      WALK_SUBTREE (TREE_TYPE (t));\n+      break;\n+\n     case CONST_DECL:\n-      if (TREE_CODE (t) == CONST_DECL && DECL_TEMPLATE_PARM_P (t))\n+      if (DECL_TEMPLATE_PARM_P (t))\n \tWALK_SUBTREE (DECL_INITIAL (t));\n       if (DECL_CONTEXT (t)\n \t  && pfd->include_nondeduced_p)\n@@ -10824,9 +10827,6 @@ any_template_parm_r (tree t, void *data)\n       break;\n \n     case TEMPLATE_PARM_INDEX:\n-    case PARM_DECL:\n-      /* A parameter or constraint variable may also depend on a template\n-\t parameter without explicitly naming it.  */\n       WALK_SUBTREE (TREE_TYPE (t));\n       break;\n "}, {"sha": "6683d224cf8fe6811bafae84aef6a6d6da29a133", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-decltype4.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4f95dbd4764ffc1e8270e5b3c0fd71b6724562/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-decltype4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4f95dbd4764ffc1e8270e5b3c0fd71b6724562/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-decltype4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-decltype4.C?ref=df4f95dbd4764ffc1e8270e5b3c0fd71b6724562", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/105797\n+// { dg-do compile { target c++20 } }\n+\n+template<class T>\n+concept C = requires { T(); };\n+\n+template<class T>\n+void f(T v) requires C<decltype(v)>; // #1\n+\n+template<class T, class U>\n+void f(T v) requires C<decltype(v)>; // #2\n+\n+int main() {\n+  f<int, int>(0);\n+  f<int>(0);\n+}"}, {"sha": "beb30d0e3506aa879c5c853b567020affdbf7d5e", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-memfun3.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4f95dbd4764ffc1e8270e5b3c0fd71b6724562/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memfun3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4f95dbd4764ffc1e8270e5b3c0fd71b6724562/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memfun3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memfun3.C?ref=df4f95dbd4764ffc1e8270e5b3c0fd71b6724562", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target c++20 } }\n+\n+template<int I>\n+struct A {\n+  enum E { e = I };\n+  static void f() requires (e != 0);\n+};\n+\n+int main() {\n+  A<1>::f();\n+  A<0>::f(); // { dg-error \"no match\" }\n+}"}]}