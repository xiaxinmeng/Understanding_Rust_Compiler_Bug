{"sha": "3d2cf79f8112e357327a1a8a1765ab1c6022244c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QyY2Y3OWY4MTEyZTM1NzMyN2ExYThhMTc2NWFiMWM2MDIyMjQ0Yw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-10-22T08:42:37Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-10-22T08:42:37Z"}, "message": "Makefile.in (OBJS): Add gimple-match.o and generic-match.o.\n\n2014-10-22  Richard Biener  <rguenther@suse.de>\n\tPrathamesh Kulkarni  <bilbotheelffriend@gmail.com>\n\n\t* Makefile.in (OBJS): Add gimple-match.o and generic-match.o.\n\t(MOSTLYCLEANFILES): Add gimple-match.c and generic-match.c.\n\t(gimple-match.c): Generate by triggering s-match.\n\t(generic-match.c): Likewise.\n\t(s-match): Rule to build gimple-match.c and generic-match.c\n\tby running the genmatch generator program.\n\t(build/hash-table.o): Dependencies to build hash-table.c for the host.\n\t(build/genmatch.o): Dependencies to build genmatch.\n\t(genprog): Add match.\n\t(build/genmatch): Likewise.\n\t(TEXI_GCCINT_FILES): Add match-and-simplify.texi.\n\t* generic-match-head.c: New file.\n\t* gimple-match-head.c: Likewise.\n\t* gimple-match.h: Likewise.\n\t* genmatch.c: Likewise.\n\t* match.pd: Likewise.\n\t* builtins.h (fold_builtin_n): Export.\n\t* builtins.c (fold_builtin_n): Likewise.\n\t* gimple-fold.h (gimple_build): Declare various overloads.\n\t(gimple_simplify): Likewise.\n\t(gimple_convert): Re-implement in terms of gimple_build.\n\t* gimple-fold.c (gimple_convert): Remove.\n\t(gimple_build): New functions.\n\n\t* doc/match-and-simplify.texi: New file.\n\t* doc/gccint.texi: Add menu item Match and Simplify and include\n\tmatch-and-simplify.texi.\n\nCo-Authored-By: Prathamesh Kulkarni <bilbotheelffriend@gmail.com>\n\nFrom-SVN: r216542", "tree": {"sha": "b44c5fbbe45ceabde1404a524b10797087c153bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b44c5fbbe45ceabde1404a524b10797087c153bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d2cf79f8112e357327a1a8a1765ab1c6022244c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d2cf79f8112e357327a1a8a1765ab1c6022244c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d2cf79f8112e357327a1a8a1765ab1c6022244c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d2cf79f8112e357327a1a8a1765ab1c6022244c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d9f1cd276094689daa6451b7e24fe7bd683395f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d9f1cd276094689daa6451b7e24fe7bd683395f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d9f1cd276094689daa6451b7e24fe7bd683395f"}], "stats": {"total": 4663, "additions": 4648, "deletions": 15}, "files": [{"sha": "b596a3857d473ca44ade7c077c01c92e25dfba52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d2cf79f8112e357327a1a8a1765ab1c6022244c", "patch": "@@ -1,3 +1,33 @@\n+2014-10-22  Richard Biener  <rguenther@suse.de>\n+\tPrathamesh Kulkarni  <bilbotheelffriend@gmail.com>\n+\n+\t* Makefile.in (OBJS): Add gimple-match.o and generic-match.o.\n+\t(MOSTLYCLEANFILES): Add gimple-match.c and generic-match.c.\n+\t(gimple-match.c): Generate by triggering s-match.\n+\t(generic-match.c): Likewise.\n+\t(s-match): Rule to build gimple-match.c and generic-match.c\n+\tby running the genmatch generator program.\n+\t(build/hash-table.o): Dependencies to build hash-table.c for the host.\n+\t(build/genmatch.o): Dependencies to build genmatch.\n+\t(genprog): Add match.\n+\t(build/genmatch): Likewise.\n+\t(TEXI_GCCINT_FILES): Add match-and-simplify.texi.\n+\t* generic-match-head.c: New file.\n+\t* gimple-match-head.c: Likewise.\n+\t* gimple-match.h: Likewise.\n+\t* genmatch.c: Likewise.\n+\t* match.pd: Likewise.\n+\t* builtins.h (fold_builtin_n): Export.\n+\t* builtins.c (fold_builtin_n): Likewise.\n+\t* gimple-fold.h (gimple_build): Declare various overloads.\n+\t(gimple_simplify): Likewise.\n+\t(gimple_convert): Re-implement in terms of gimple_build.\n+\t* gimple-fold.c (gimple_convert): Remove.\n+\t(gimple_build): New functions.\n+\t* doc/match-and-simplify.texi: New file.\n+\t* doc/gccint.texi: Add menu item Match and Simplify and include\n+\tmatch-and-simplify.texi.\n+\n 2014-10-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/63594"}, {"sha": "6aa59ed3ee78db5bd3d229ac83f7b4796b78ad3c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3d2cf79f8112e357327a1a8a1765ab1c6022244c", "patch": "@@ -204,6 +204,8 @@ gengtype-lex.o-warn = -Wno-error\n libgcov-util.o-warn = -Wno-error\n libgcov-driver-tool.o-warn = -Wno-error\n libgcov-merge-tool.o-warn = -Wno-error\n+gimple-match.o-warn = -Wno-unused-variable -Wno-unused-parameter\n+generic-match.o-warn = -Wno-unused-variable -Wno-unused-parameter\n \n # All warnings have to be shut off in stage1 if the compiler used then\n # isn't gcc; configure determines that.  WARN_CFLAGS will be either\n@@ -1227,6 +1229,8 @@ OBJS = \\\n \tgimple-iterator.o \\\n \tgimple-fold.o \\\n \tgimple-low.o \\\n+\tgimple-match.o \\\n+\tgeneric-match.o \\\n \tgimple-pretty-print.o \\\n \tgimple-ssa-isolate-paths.o \\\n \tgimple-ssa-strength-reduction.o \\\n@@ -1504,7 +1508,7 @@ MOSTLYCLEANFILES = insn-flags.h insn-config.h insn-codes.h \\\n  insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \\\n  insn-attr.h insn-attr-common.h insn-attrtab.c insn-dfatab.c \\\n  insn-latencytab.c insn-opinit.c insn-opinit.h insn-preds.c insn-constants.h \\\n- tm-preds.h tm-constrs.h checksum-options \\\n+ tm-preds.h tm-constrs.h checksum-options gimple-match.c generic-match.c \\\n  tree-check.h min-insn-modes.c insn-modes.c insn-modes.h \\\n  genrtl.h gt-*.h gtype-*.h gtype-desc.c gtyp-input.list \\\n  xgcc$(exeext) cpp$(exeext) \\\n@@ -2021,7 +2025,7 @@ $(common_out_object_file): $(common_out_file)\n .PRECIOUS: insn-config.h insn-flags.h insn-codes.h insn-constants.h \\\n   insn-emit.c insn-recog.c insn-extract.c insn-output.c insn-peep.c \\\n   insn-attr.h insn-attr-common.h insn-attrtab.c insn-dfatab.c \\\n-  insn-latencytab.c insn-preds.c\n+  insn-latencytab.c insn-preds.c gimple-match.c generic-match.c\n \n # Dependencies for the md file.  The first time through, we just assume\n # the md file itself and the generated dependency file (in order to get\n@@ -2230,6 +2234,20 @@ s-tm-texi: build/genhooks$(build_exeext) $(srcdir)/doc/tm.texi.in\n \t  false; \\\n \tfi\n \n+gimple-match.c: s-match gimple-match-head.c ; @true\n+generic-match.c: s-match generic-match-head.c ; @true\n+\n+s-match: build/genmatch$(build_exeext) $(srcdir)/match*.pd\n+\t$(RUN_GEN) build/genmatch$(build_exeext) --gimple $(srcdir)/match.pd \\\n+\t    > tmp-gimple-match.c\n+\t$(RUN_GEN) build/genmatch$(build_exeext) --generic $(srcdir)/match.pd \\\n+\t    > tmp-generic-match.c\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-gimple-match.c \\\n+\t    \t\t\t\t\tgimple-match.c\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-generic-match.c \\\n+\t    \t\t\t\t\tgeneric-match.c\n+\t$(STAMP) s-match\n+\n GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(host_xm_file_list) \\\n   $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) $(srcdir)/bitmap.h \\\n@@ -2378,6 +2396,8 @@ build/rtl.o: rtl.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H)\t\\\n   $(RTL_H) $(GGC_H) errors.h\n build/vec.o : vec.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(VEC_H)\t\\\n    $(GGC_H) toplev.h $(DIAGNOSTIC_CORE_H)\n+build/hash-table.o : hash-table.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h  \\\n+   $(HASH_TABLE_H) $(GGC_H) toplev.h $(DIAGNOSTIC_CORE_H)\n build/gencondmd.o : build/gencondmd.c $(BCONFIG_H) $(SYSTEM_H)\t\t\\\n   coretypes.h $(GTM_H) insn-constants.h\t\t\t\t\t\\\n   $(filter-out insn-flags.h, $(RTL_H) $(TM_P_H) $(FUNCTION_H) $(REGS_H) \\\n@@ -2473,6 +2493,8 @@ build/genhooks.o : genhooks.c $(TARGET_DEF) $(C_TARGET_DEF)\t\t\\\n   $(COMMON_TARGET_DEF) $(BCONFIG_H) $(SYSTEM_H) errors.h\n build/genmddump.o : genmddump.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n   coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n+build/genmatch.o : genmatch.c $(BCONFIG_H) $(SYSTEM_H) \\\n+  coretypes.h errors.h\n \n # Compile the programs that generate insn-* from the machine description.\n # They are compiled with $(COMPILER_FOR_BUILD), and associated libraries,\n@@ -2493,11 +2515,14 @@ genprogerr = $(genprogmd) genrtl modes gtype hooks\n $(genprogerr:%=build/gen%$(build_exeext)): $(BUILD_ERRORS)\n \n # Remaining build programs.\n-genprog = $(genprogerr) check checksum condmd\n+genprog = $(genprogerr) check checksum condmd match\n \n # These programs need libs over and above what they get from the above list.\n build/genautomata$(build_exeext) : BUILD_LIBS += -lm\n \n+build/genmatch$(build_exeext) : $(CPPLIB) $(LIBIBERTY) \\\n+  $(BUILD_ERRORS) build/vec.o build/hash-table.o\n+\n # These programs are not linked with the MD reader.\n build/gengtype$(build_exeext) : build/gengtype-lex.o build/gengtype-parse.o \\\n               build/gengtype-state.o build/version.o build/errors.o\n@@ -2832,7 +2857,8 @@ TEXI_GCCINT_FILES = gccint.texi gcc-common.texi gcc-vers.texi\t\t\\\n \t configfiles.texi collect2.texi headerdirs.texi funding.texi\t\\\n \t gnu.texi gpl_v3.texi fdl.texi contrib.texi languages.texi\t\\\n \t sourcebuild.texi gty.texi libgcc.texi cfg.texi tree-ssa.texi\t\\\n-\t loop.texi generic.texi gimple.texi plugins.texi optinfo.texi\n+\t loop.texi generic.texi gimple.texi plugins.texi optinfo.texi   \\\n+\t match-and-simplify.texi\n \n TEXI_GCCINSTALL_FILES = install.texi install-old.texi fdl.texi\t\t\\\n \t gcc-common.texi gcc-vers.texi"}, {"sha": "e47b936df55b3e138c2e923326d2c9e387c188d4", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=3d2cf79f8112e357327a1a8a1765ab1c6022244c", "patch": "@@ -180,7 +180,6 @@ static tree fold_builtin_fabs (location_t, tree, tree);\n static tree fold_builtin_abs (location_t, tree, tree);\n static tree fold_builtin_unordered_cmp (location_t, tree, tree, tree, enum tree_code,\n \t\t\t\t\tenum tree_code);\n-static tree fold_builtin_n (location_t, tree, tree *, int, bool);\n static tree fold_builtin_0 (location_t, tree, bool);\n static tree fold_builtin_1 (location_t, tree, tree, bool);\n static tree fold_builtin_2 (location_t, tree, tree, tree, bool);\n@@ -10395,7 +10394,7 @@ fold_builtin_4 (location_t loc, tree fndecl,\n \n #define MAX_ARGS_TO_FOLD_BUILTIN 4\n \n-static tree\n+tree\n fold_builtin_n (location_t loc, tree fndecl, tree *args, int nargs, bool ignore)\n {\n   tree ret = NULL_TREE;"}, {"sha": "7261bf804587739f9014d4ff10c9dcc7a8b83618", "filename": "gcc/builtins.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=3d2cf79f8112e357327a1a8a1765ab1c6022244c", "patch": "@@ -75,6 +75,7 @@ extern tree fold_fma (location_t, tree, tree, tree, tree);\n extern bool avoid_folding_inline_builtin (tree);\n extern tree fold_call_expr (location_t, tree, bool);\n extern tree fold_builtin_call_array (location_t, tree, tree, int, tree *);\n+extern tree fold_builtin_n (location_t, tree, tree *, int, bool);\n extern bool validate_gimple_arglist (const_gimple, ...);\n extern rtx default_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n extern bool fold_builtin_next_arg (tree, bool);"}, {"sha": "e5563c58de0c213e61f38f49ac54c5392f14cdcc", "filename": "gcc/doc/gccint.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fdoc%2Fgccint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fdoc%2Fgccint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint.texi?ref=3d2cf79f8112e357327a1a8a1765ab1c6022244c", "patch": "@@ -123,6 +123,7 @@ Additional tutorial information is linked to from\n * Plugins::         Extending the compiler with plugins.\n * LTO::             Using Link-Time Optimization.\n \n+* Match and Simplify:: How to write expression simplification patterns for GIMPLE and GENERIC\n * Funding::         How to help assure funding for free software.\n * GNU Project::     The GNU Project and GNU/Linux.\n \n@@ -158,6 +159,7 @@ Additional tutorial information is linked to from\n @include gty.texi\n @include plugins.texi\n @include lto.texi\n+@include match-and-simplify.texi\n \n @include funding.texi\n @include gnu.texi"}, {"sha": "d63d8b81ead1b52cc35ed094d619fb8fc1e42c54", "filename": "gcc/doc/match-and-simplify.texi", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fdoc%2Fmatch-and-simplify.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fdoc%2Fmatch-and-simplify.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmatch-and-simplify.texi?ref=3d2cf79f8112e357327a1a8a1765ab1c6022244c", "patch": "@@ -0,0 +1,314 @@\n+@c Copyright (C) 2014 Free Software Foundation, Inc.\n+@c Free Software Foundation, Inc.\n+@c This is part of the GCC manual.\n+@c For copying conditions, see the file gcc.texi.\n+\n+@node Match and Simplify\n+@chapter Match and Simplify\n+@cindex Match and Simplify\n+\n+The GIMPLE and GENERIC pattern matching project match-and-simplify\n+tries to address several issues.\n+\n+@enumerate\n+@item unify expression simplifications currently spread and duplicated\n+    over separate files like fold-const.c, gimple-fold.c and builtins.c\n+@item allow for a cheap way to implement building and simplifying\n+    non-trivial GIMPLE expressions, avoiding the need to go through\n+    building and simplifying GENERIC via fold_buildN and then\n+    gimplifying via force_gimple_operand\n+@end enumerate\n+\n+To address these the project introduces a simple domain specific language\n+to write expression simplifications from which code targeting GIMPLE\n+and GENERIC is auto-generated.  The GENERIC variant follows the\n+fold_buildN API while for the GIMPLE variant and to address 2) new\n+APIs are introduced.\n+\n+@menu\n+* GIMPLE API::\n+* The Language::\n+@end menu\n+\n+@node GIMPLE API\n+@section GIMPLE API\n+@cindex GIMPLE API\n+\n+@deftypefn {GIMPLE function} tree gimple_simplify (enum tree_code, tree, tree, gimple_seq *, tree (*)(tree))\n+@deftypefnx {GIMPLE function} tree gimple_simplify (enum tree_code, tree, tree, tree, gimple_seq *, tree (*)(tree))\n+@deftypefnx {GIMPLE function} tree gimple_simplify (enum tree_code, tree, tree, tree, tree, gimple_seq *, tree (*)(tree))\n+@deftypefnx {GIMPLE function} tree gimple_simplify (enum built_in_function, tree, tree, gimple_seq *, tree (*)(tree))\n+@deftypefnx {GIMPLE function} tree gimple_simplify (enum built_in_function, tree, tree, tree, gimple_seq *, tree (*)(tree))\n+@deftypefnx {GIMPLE function} tree gimple_simplify (enum built_in_function, tree, tree, tree, gimple_seq *, tree (*)(tree))\n+The main GIMPLE API entry to the expression simplifications mimicing\n+that of the GENERIC fold_@{unary,binary,ternary@} functions.\n+@end deftypefn\n+\n+thus providing n-ary overloads for operation or function.  The\n+additional arguments are a gimple_seq where built statements are\n+inserted on (if @code{NULL} then simplifications requiring new statements\n+are not performed) and a valueization hook that can be used to\n+tie simplifications to a SSA lattice.\n+\n+In addition to those APIs @code{fold_stmt} is overloaded with\n+a valueization hook:\n+\n+@deftypefn bool fold_stmt (gimple_stmt_iterator *, tree (*)(tree));\n+@end deftypefn\n+\n+\n+Ontop of these a @code{fold_buildN}-like API for GIMPLE is introduced:\n+\n+@deftypefn {GIMPLE function} tree gimple_build (gimple_seq *, location_t, enum tree_code, tree, tree, tree (*valueize) (tree) = NULL);\n+@deftypefnx {GIMPLE function} tree gimple_build (gimple_seq *, location_t, enum tree_code, tree, tree, tree, tree (*valueize) (tree) = NULL);\n+@deftypefnx {GIMPLE function} tree gimple_build (gimple_seq *, location_t, enum tree_code, tree, tree, tree, tree, tree (*valueize) (tree) = NULL);\n+@deftypefnx {GIMPLE function} tree gimple_build (gimple_seq *, location_t, enum built_in_function, tree, tree, tree (*valueize) (tree) = NULL);\n+@deftypefnx {GIMPLE function} tree gimple_build (gimple_seq *, location_t, enum built_in_function, tree, tree, tree, tree (*valueize) (tree) = NULL);\n+@deftypefnx {GIMPLE function} tree gimple_convert (gimple_seq *, location_t, tree, tree);\n+@end deftypefn\n+\n+which is supposed to replace @code{force_gimple_operand (fold_buildN (...), ...)}\n+and calls to @code{fold_convert}.  Overloads without the @code{location_t}\n+argument exist.  Built statements are inserted on the provided sequence\n+and simplification is performed using the optional valueization hook.\n+\n+\n+@node The Language\n+@section The Language\n+@cindex The Language\n+\n+The language to write expression simplifications in resembles other\n+domain-specific languages GCC uses.  Thus it is lispy.  Lets start\n+with an example from the match.pd file:\n+\n+@smallexample\n+(simplify\n+  (bit_and @@0 integer_all_onesp)\n+  @@0)\n+@end smallexample\n+\n+This example contains all required parts of an expression simplification.\n+A simplification is wrapped inside a @code{(simplify ...)} expression.\n+That contains at least two operands - an expression that is matched\n+with the GIMPLE or GENERIC IL and a replacement expression that is\n+returned if the match was successful.\n+\n+Expressions have an operator ID, @code{bit_and} in this case.  Expressions can\n+be lower-case tree codes with @code{_expr} stripped off or builtin\n+function code names in all-caps, like @code{BUILT_IN_SQRT}.\n+\n+@code{@@n} denotes a so-called capture.  It captures the operand and lets\n+you refer to it in other places of the match-and-simplify.  In the\n+above example it is refered to in the replacement expression.  Captures\n+are @code{@@} followed by a number or an identifier.\n+\n+@smallexample\n+(simplify\n+  (bit_xor @@0 @@0)\n+  @{ build_zero_cst (type); @})\n+@end smallexample\n+\n+In this example @code{@@0} is mentioned twice which constrains the matched\n+expression to have two equal operands.  This example also introduces\n+operands written in C code.  These can be used in the expression\n+replacements and are supposed to evaluate to a tree node which has to\n+be a valid GIMPLE operand (so you cannot generate expressions in C code).\n+\n+@smallexample\n+(simplify\n+  (trunc_mod integer_zerop@@0 @@1)\n+  (if (!integer_zerop (@@1)))\n+  @@0)\n+@end smallexample\n+\n+Here @code{@@0} captures the first operand of the trunc_mod expression\n+which is also predicated with @code{integer_zerop}.  Expression operands\n+may be either expressions, predicates or captures.  Captures\n+can be unconstrained or capture expresions or predicates.\n+\n+This example introduces an optional operand of simplify,\n+the if-expression.  This condition is evaluated after the\n+expression matched in the IL and is required to evaluate to true\n+to enable the replacement expression.  The expression operand\n+of the @code{if} is a standard C expression which may contain references\n+to captures.\n+\n+A @code{if} expression can be used to specify a common condition\n+for multiple simplify patterns, avoiding the need\n+to repeat that multiple times:\n+\n+@smallexample\n+(if (!TYPE_SATURATING (type)\n+     && !FLOAT_TYPE_P (type) && !FIXED_POINT_TYPE_P (type))\n+  (simplify\n+    (minus (plus @@0 @@1) @@0)\n+    @@1)\n+  (simplify\n+    (minus (minus @@0 @@1) @@0)\n+    (negate @@1)))\n+@end smallexample\n+\n+Ifs can be nested.\n+\n+Captures can also be used for capturing results of sub-expressions.\n+\n+@smallexample\n+#if GIMPLE\n+(simplify\n+  (pointer_plus (addr@@2 @@0) INTEGER_CST_P@@1)\n+  (if (is_gimple_min_invariant (@@2)))\n+  @{\n+    HOST_WIDE_INT off;\n+    tree base = get_addr_base_and_unit_offset (@@0, &off);\n+    off += tree_to_uhwi (@@1);\n+    /* Now with that we should be able to simply write\n+       (addr (mem_ref (addr @@base) (plus @@off @@1)))  */\n+    build1 (ADDR_EXPR, type,\n+            build2 (MEM_REF, TREE_TYPE (TREE_TYPE (@@2)),\n+                    build_fold_addr_expr (base),\n+                    build_int_cst (ptr_type_node, off)));\n+  @})\n+#endif\n+@end smallexample\n+\n+In the above example, @code{@@2} captures the result of the expression\n+@code{(addr @@0)}.  For outermost expression only its type can be captured,\n+and the keyword @code{type} is reserved for this purpose.  The above\n+example also gives a way to conditionalize patterns to only apply\n+to @code{GIMPLE} or @code{GENERIC} by means of using the pre-defined\n+preprocessor macros @code{GIMPLE} and @code{GENERIC} and using\n+preprocessor directives.\n+\n+@smallexample\n+(simplify\n+  (bit_and:c integral_op_p@@0 (bit_ior:c (bit_not @@0) @@1))\n+  (bit_and @@1 @@0))\n+@end smallexample\n+\n+Here we introduce flags on match expressions.  There is currently\n+a single flag, @code{c}, which denotes that the expression should\n+be also matched commutated.  Thus the above match expression\n+is really the following four match expressions:\n+\n+  (bit_and integral_op_p@@0 (bit_ior (bit_not @@0) @@1))\n+  (bit_and (bit_ior (bit_not @@0) @@1) integral_op_p@@0)\n+  (bit_and integral_op_p@@0 (bit_ior @@1 (bit_not @@0)))\n+  (bit_and (bit_ior @@1 (bit_not @@0)) integral_op_p@@0)\n+\n+Usual canonicalizations you know from GENERIC expressions are\n+applied before matching, so for example constant operands always\n+come second in commutative expressions.\n+\n+More features exist to avoid too much repetition.\n+\n+@smallexample\n+(for op (plus pointer_plus minus bit_ior bit_xor)\n+  (simplify\n+    (op @@0 integer_zerop)\n+    @@0))\n+@end smallexample\n+\n+A @code{for} expression can be used to repeat a pattern for each\n+operator specified, substituting @code{op}.  @code{for} can be\n+nested and a @code{for} can have multiple operators to iterate.\n+\n+@smallexample\n+(for opa (plus minus)\n+     opb (minus plus)\n+  (for opc (plus minus)\n+    (simplify...\n+@end smallexample\n+\n+In this example the pattern will be repeated four times with\n+@code{opa, opb, opc} being @code{plus, minus, plus},\n+@code{plus, minus, minus}, @code{minus, plus, plus},\n+@code{minus, plus, minus}.\n+\n+Another building block are @code{with} expressions in the\n+result expression which nest the generated code in a new C block\n+followed by its argument:\n+\n+@smallexample\n+(simplify\n+ (convert (mult @@0 @@1))\n+ (with @{ tree utype = unsigned_type_for (type); @}\n+  (convert (mult (convert:utype @@0) (convert:utype @@1)))))\n+@end smallexample\n+\n+This allows code nested in the @code{with} to refer to the declared\n+variables.  In the above case we use the feature to specify the\n+type of a generated expression with the @code{:type} syntax where\n+@code{type} needs to be an identifier that refers to the desired type.\n+Usually the types of the generated result expressions are\n+determined from the context, but sometimes like in the above case\n+it is required that you specify them explicitely.\n+\n+As intermediate conversions are often optional there is a way to\n+avoid the need to repeat patterns both with and without such\n+conversions.  Namely you can mark a conversion as being optional\n+with a @code{?}:\n+\n+@smallexample\n+(simplify\n+ (eq (convert@@0 @@1) (convert? @@2))\n+ (eq @@1 (convert @@2)))\n+@end smallexample\n+\n+which will match both @code{(eq (convert @@1) (convert @@2))} and\n+@code{(eq (convert @@1) @@2)}.  The optional converts are supposed\n+to be all either present or not, thus\n+@code{(eq (convert? @@1) (convert? @@2))} will result in two\n+patterns only.  If you want to match all four combinations you\n+have access to two additional conditional converts as in\n+@code{(eq (convert1? @@1) (convert2? @@2))}.\n+\n+Predicates available from the GCC middle-end need to be made\n+available explicitely via @code{define_predicates}:\n+\n+@smallexample\n+(define_predicates\n+ integer_onep integer_zerop integer_all_onesp)\n+@end smallexample\n+\n+You can also define predicates using the pattern matching language\n+and the @code{match} form:\n+\n+@smallexample\n+(match negate_expr_p\n+ INTEGER_CST\n+ (if (TYPE_OVERFLOW_WRAPS (type)\n+      || may_negate_without_overflow_p (t))))\n+(match negate_expr_p\n+ (negate @@0))\n+@end smallexample\n+\n+This shows that for @code{match} expressions there is @code{t}\n+available which captures the outermost expression (something\n+not possible in the @code{simplify} context).  As you can see\n+@code{match} has an identifier as first operand which is how\n+you refer to the predicate in patterns.  Multiple @code{match}\n+for the same identifier add additional cases where the predicate\n+matches.\n+\n+Predicates can also match an expression in which case you need\n+to provide a template specifying the identifier and where to\n+get its operands from:\n+\n+@smallexample\n+(match (logical_inverted_value @@0)\n+ (eq @@0 integer_zerop))\n+(match (logical_inverted_value @@0)\n+ (bit_not truth_valued_p@@0))\n+@end smallexample\n+\n+You can use the above predicate like\n+\n+@smallexample\n+(simplify\n+ (bit_and @@0 (logical_inverted_value @@0))\n+ @{ build_zero_cst (type); @})\n+@end smallexample\n+\n+Which will match a bitwise and of an operand with its logical\n+inverted value.\n+"}, {"sha": "245f3ede456394796668259fd48eebac73f33271", "filename": "gcc/generic-match-head.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fgeneric-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fgeneric-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgeneric-match-head.c?ref=3d2cf79f8112e357327a1a8a1765ab1c6022244c", "patch": "@@ -0,0 +1,48 @@\n+/* Preamble and helpers for the autogenerated generic-match.c file.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"stor-layout.h\"\n+#include \"flags.h\"\n+#include \"tm.h\"\n+#include \"hard-reg-set.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-expr.h\"\n+#include \"is-a.h\"\n+#include \"gimple.h\"\n+#include \"gimple-ssa.h\"\n+#include \"tree-ssanames.h\"\n+#include \"gimple-fold.h\"\n+#include \"gimple-iterator.h\"\n+#include \"expr.h\"\n+#include \"tree-dfa.h\"\n+#include \"builtins.h\"\n+#include \"tree-phinodes.h\"\n+#include \"ssa-iterators.h\"\n+#include \"dumpfile.h\"\n+#include \"gimple-match.h\"\n+\n+"}, {"sha": "2def7fa58cdcdcaff2cf6957d652ac7acbbd9eca", "filename": "gcc/genmatch.c", "status": "added", "additions": 3039, "deletions": 0, "changes": 3039, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=3d2cf79f8112e357327a1a8a1765ab1c6022244c"}, {"sha": "5b47cbc37bb7608faed86392477aaed40a5a2220", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 192, "deletions": 9, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=3d2cf79f8112e357327a1a8a1765ab1c6022244c", "patch": "@@ -5364,19 +5364,202 @@ rewrite_to_defined_overflow (gimple stmt)\n   return stmts;\n }\n \n-/* Return OP converted to TYPE by emitting a conversion statement on SEQ\n-   if required using location LOC.  Note that OP will be returned\n-   unmodified if GIMPLE does not require an explicit conversion between\n-   its type and TYPE.  */\n+\n+/* Build the expression CODE OP0 of type TYPE with location LOC,\n+   simplifying it first if possible using VALUEIZE if not NULL.\n+   OP0 is expected to be valueized already.  Returns the built\n+   expression value and appends statements possibly defining it\n+   to SEQ.  */\n+\n+tree\n+gimple_build (gimple_seq *seq, location_t loc,\n+\t      enum tree_code code, tree type, tree op0,\n+\t      tree (*valueize)(tree))\n+{\n+  tree res = gimple_simplify (code, type, op0, seq, valueize);\n+  if (!res)\n+    {\n+      if (gimple_in_ssa_p (cfun))\n+\tres = make_ssa_name (type, NULL);\n+      else\n+\tres = create_tmp_reg (type, NULL);\n+      gimple stmt;\n+      if (code == REALPART_EXPR\n+\t  || code == IMAGPART_EXPR\n+\t  || code == VIEW_CONVERT_EXPR)\n+\tstmt = gimple_build_assign_with_ops (code, res,\n+\t\t\t\t\t     build1 (code, type,\n+\t\t\t\t\t\t     op0), NULL_TREE);\n+      else\n+\tstmt = gimple_build_assign_with_ops (code, res, op0, NULL_TREE);\n+      gimple_set_location (stmt, loc);\n+      gimple_seq_add_stmt_without_update (seq, stmt);\n+    }\n+  return res;\n+}\n+\n+/* Build the expression OP0 CODE OP1 of type TYPE with location LOC,\n+   simplifying it first if possible using VALUEIZE if not NULL.\n+   OP0 and OP1 are expected to be valueized already.  Returns the built\n+   expression value and appends statements possibly defining it\n+   to SEQ.  */\n+\n+tree\n+gimple_build (gimple_seq *seq, location_t loc,\n+\t      enum tree_code code, tree type, tree op0, tree op1,\n+\t      tree (*valueize)(tree))\n+{\n+  tree res = gimple_simplify (code, type, op0, op1, seq, valueize);\n+  if (!res)\n+    {\n+      if (gimple_in_ssa_p (cfun))\n+\tres = make_ssa_name (type, NULL);\n+      else\n+\tres = create_tmp_reg (type, NULL);\n+      gimple stmt = gimple_build_assign_with_ops (code, res, op0, op1);\n+      gimple_set_location (stmt, loc);\n+      gimple_seq_add_stmt_without_update (seq, stmt);\n+    }\n+  return res;\n+}\n+\n+/* Build the expression (CODE OP0 OP1 OP2) of type TYPE with location LOC,\n+   simplifying it first if possible using VALUEIZE if not NULL.\n+   OP0, OP1 and OP2 are expected to be valueized already.  Returns the built\n+   expression value and appends statements possibly defining it\n+   to SEQ.  */\n+\n+tree\n+gimple_build (gimple_seq *seq, location_t loc,\n+\t      enum tree_code code, tree type, tree op0, tree op1, tree op2,\n+\t      tree (*valueize)(tree))\n+{\n+  tree res = gimple_simplify (code, type, op0, op1, op2,\n+\t\t\t      seq, valueize);\n+  if (!res)\n+    {\n+      if (gimple_in_ssa_p (cfun))\n+\tres = make_ssa_name (type, NULL);\n+      else\n+\tres = create_tmp_reg (type, NULL);\n+      gimple stmt;\n+      if (code == BIT_FIELD_REF)\n+\tstmt = gimple_build_assign_with_ops (code, res,\n+\t\t\t\t\t     build3 (BIT_FIELD_REF, type,\n+\t\t\t\t\t\t     op0, op1, op2),\n+\t\t\t\t\t     NULL_TREE);\n+      else\n+\tstmt = gimple_build_assign_with_ops (code, res, op0, op1, op2);\n+      gimple_set_location (stmt, loc);\n+      gimple_seq_add_stmt_without_update (seq, stmt);\n+    }\n+  return res;\n+}\n+\n+/* Build the call FN (ARG0) with a result of type TYPE\n+   (or no result if TYPE is void) with location LOC,\n+   simplifying it first if possible using VALUEIZE if not NULL.\n+   ARG0 is expected to be valueized already.  Returns the built\n+   expression value (or NULL_TREE if TYPE is void) and appends\n+   statements possibly defining it to SEQ.  */\n+\n+tree\n+gimple_build (gimple_seq *seq, location_t loc,\n+\t      enum built_in_function fn, tree type, tree arg0,\n+\t      tree (*valueize)(tree))\n+{\n+  tree res = gimple_simplify (fn, type, arg0, seq, valueize);\n+  if (!res)\n+    {\n+      tree decl = builtin_decl_implicit (fn);\n+      gimple stmt = gimple_build_call (decl, 1, arg0);\n+      if (!VOID_TYPE_P (type))\n+\t{\n+\t  if (gimple_in_ssa_p (cfun))\n+\t    res = make_ssa_name (type, NULL);\n+\t  else\n+\t    res = create_tmp_reg (type, NULL);\n+\t  gimple_call_set_lhs (stmt, res);\n+\t}\n+      gimple_set_location (stmt, loc);\n+      gimple_seq_add_stmt_without_update (seq, stmt);\n+    }\n+  return res;\n+}\n+\n+/* Build the call FN (ARG0, ARG1) with a result of type TYPE\n+   (or no result if TYPE is void) with location LOC,\n+   simplifying it first if possible using VALUEIZE if not NULL.\n+   ARG0 is expected to be valueized already.  Returns the built\n+   expression value (or NULL_TREE if TYPE is void) and appends\n+   statements possibly defining it to SEQ.  */\n+\n+tree\n+gimple_build (gimple_seq *seq, location_t loc,\n+\t      enum built_in_function fn, tree type, tree arg0, tree arg1,\n+\t      tree (*valueize)(tree))\n+{\n+  tree res = gimple_simplify (fn, type, arg0, arg1, seq, valueize);\n+  if (!res)\n+    {\n+      tree decl = builtin_decl_implicit (fn);\n+      gimple stmt = gimple_build_call (decl, 2, arg0, arg1);\n+      if (!VOID_TYPE_P (type))\n+\t{\n+\t  if (gimple_in_ssa_p (cfun))\n+\t    res = make_ssa_name (type, NULL);\n+\t  else\n+\t    res = create_tmp_reg (type, NULL);\n+\t  gimple_call_set_lhs (stmt, res);\n+\t}\n+      gimple_set_location (stmt, loc);\n+      gimple_seq_add_stmt_without_update (seq, stmt);\n+    }\n+  return res;\n+}\n+\n+/* Build the call FN (ARG0, ARG1, ARG2) with a result of type TYPE\n+   (or no result if TYPE is void) with location LOC,\n+   simplifying it first if possible using VALUEIZE if not NULL.\n+   ARG0 is expected to be valueized already.  Returns the built\n+   expression value (or NULL_TREE if TYPE is void) and appends\n+   statements possibly defining it to SEQ.  */\n+\n+tree\n+gimple_build (gimple_seq *seq, location_t loc,\n+\t      enum built_in_function fn, tree type,\n+\t      tree arg0, tree arg1, tree arg2,\n+\t      tree (*valueize)(tree))\n+{\n+  tree res = gimple_simplify (fn, type, arg0, arg1, arg2, seq, valueize);\n+  if (!res)\n+    {\n+      tree decl = builtin_decl_implicit (fn);\n+      gimple stmt = gimple_build_call (decl, 3, arg0, arg1, arg2);\n+      if (!VOID_TYPE_P (type))\n+\t{\n+\t  if (gimple_in_ssa_p (cfun))\n+\t    res = make_ssa_name (type, NULL);\n+\t  else\n+\t    res = create_tmp_reg (type, NULL);\n+\t  gimple_call_set_lhs (stmt, res);\n+\t}\n+      gimple_set_location (stmt, loc);\n+      gimple_seq_add_stmt_without_update (seq, stmt);\n+    }\n+  return res;\n+}\n+\n+/* Build the conversion (TYPE) OP with a result of type TYPE\n+   with location LOC if such conversion is neccesary in GIMPLE,\n+   simplifying it first.\n+   Returns the built expression value and appends\n+   statements possibly defining it to SEQ.  */\n \n tree\n gimple_convert (gimple_seq *seq, location_t loc, tree type, tree op)\n {\n   if (useless_type_conversion_p (type, TREE_TYPE (op)))\n     return op;\n-  op = fold_convert_loc (loc, type, op);\n-  gimple_seq stmts = NULL;\n-  op = force_gimple_operand (op, &stmts, true, NULL_TREE);\n-  gimple_seq_add_seq_without_update (seq, stmts);\n-  return op;\n+  return gimple_build (seq, loc, NOP_EXPR, type, op);\n }"}, {"sha": "93814cad0f18b114421bae074287725f64b3ba5b", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=3d2cf79f8112e357327a1a8a1765ab1c6022244c", "patch": "@@ -45,11 +45,84 @@ extern tree gimple_fold_indirect_ref (tree);\n extern bool arith_code_with_undefined_signed_overflow (tree_code);\n extern gimple_seq rewrite_to_defined_overflow (gimple);\n \n+/* gimple_build, functionally matching fold_buildN, outputs stmts\n+   int the provided sequence, matching and simplifying them on-the-fly.\n+   Supposed to replace force_gimple_operand (fold_buildN (...), ...).  */\n+extern tree gimple_build (gimple_seq *, location_t,\n+\t\t\t  enum tree_code, tree, tree,\n+\t\t\t  tree (*valueize) (tree) = NULL);\n+inline tree\n+gimple_build (gimple_seq *seq,\n+\t      enum tree_code code, tree type, tree op0)\n+{\n+  return gimple_build (seq, UNKNOWN_LOCATION, code, type, op0);\n+}\n+extern tree gimple_build (gimple_seq *, location_t,\n+\t\t\t  enum tree_code, tree, tree, tree,\n+\t\t\t  tree (*valueize) (tree) = NULL);\n+inline tree\n+gimple_build (gimple_seq *seq,\n+\t      enum tree_code code, tree type, tree op0, tree op1)\n+{\n+  return gimple_build (seq, UNKNOWN_LOCATION, code, type, op0, op1);\n+}\n+extern tree gimple_build (gimple_seq *, location_t,\n+\t\t\t  enum tree_code, tree, tree, tree, tree,\n+\t\t\t  tree (*valueize) (tree) = NULL);\n+inline tree\n+gimple_build (gimple_seq *seq,\n+\t      enum tree_code code, tree type, tree op0, tree op1, tree op2)\n+{\n+  return gimple_build (seq, UNKNOWN_LOCATION, code, type, op0, op1, op2);\n+}\n+extern tree gimple_build (gimple_seq *, location_t,\n+\t\t\t  enum built_in_function, tree, tree,\n+\t\t\t  tree (*valueize) (tree) = NULL);\n+inline tree\n+gimple_build (gimple_seq *seq,\n+\t      enum built_in_function fn, tree type, tree arg0)\n+{\n+  return gimple_build (seq, UNKNOWN_LOCATION, fn, type, arg0);\n+}\n+extern tree gimple_build (gimple_seq *, location_t,\n+\t\t\t  enum built_in_function, tree, tree, tree,\n+\t\t\t  tree (*valueize) (tree) = NULL);\n+inline tree\n+gimple_build (gimple_seq *seq,\n+\t      enum built_in_function fn, tree type, tree arg0, tree arg1)\n+{\n+  return gimple_build (seq, UNKNOWN_LOCATION, fn, type, arg0, arg1);\n+}\n+extern tree gimple_build (gimple_seq *, location_t,\n+\t\t\t  enum built_in_function, tree, tree, tree, tree,\n+\t\t\t  tree (*valueize) (tree) = NULL);\n+inline tree\n+gimple_build (gimple_seq *seq,\n+\t      enum built_in_function fn, tree type,\n+\t      tree arg0, tree arg1, tree arg2)\n+{\n+  return gimple_build (seq, UNKNOWN_LOCATION, fn, type, arg0, arg1, arg2);\n+}\n+\n extern tree gimple_convert (gimple_seq *, location_t, tree, tree);\n inline tree\n gimple_convert (gimple_seq *seq, tree type, tree op)\n {\n   return gimple_convert (seq, UNKNOWN_LOCATION, type, op);\n }\n \n+/* In gimple-match.c.  */\n+extern tree gimple_simplify (enum tree_code, tree, tree,\n+\t\t\t     gimple_seq *, tree (*)(tree));\n+extern tree gimple_simplify (enum tree_code, tree, tree, tree,\n+\t\t\t     gimple_seq *, tree (*)(tree));\n+extern tree gimple_simplify (enum tree_code, tree, tree, tree, tree,\n+\t\t\t     gimple_seq *, tree (*)(tree));\n+extern tree gimple_simplify (enum built_in_function, tree, tree,\n+\t\t\t     gimple_seq *, tree (*)(tree));\n+extern tree gimple_simplify (enum built_in_function, tree, tree, tree,\n+\t\t\t     gimple_seq *, tree (*)(tree));\n+extern tree gimple_simplify (enum built_in_function, tree, tree, tree, tree,\n+\t\t\t     gimple_seq *, tree (*)(tree));\n+\n #endif  /* GCC_GIMPLE_FOLD_H */"}, {"sha": "0558e9a892e2fa1a6b7981caf63e2f169ea9b79f", "filename": "gcc/gimple-match-head.c", "status": "added", "additions": 838, "deletions": 0, "changes": 838, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=3d2cf79f8112e357327a1a8a1765ab1c6022244c", "patch": "@@ -0,0 +1,838 @@\n+/* Preamble and helpers for the autogenerated gimple-match.c file.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"stor-layout.h\"\n+#include \"flags.h\"\n+#include \"tm.h\"\n+#include \"hard-reg-set.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-expr.h\"\n+#include \"is-a.h\"\n+#include \"gimple.h\"\n+#include \"gimple-ssa.h\"\n+#include \"tree-ssanames.h\"\n+#include \"gimple-fold.h\"\n+#include \"gimple-iterator.h\"\n+#include \"expr.h\"\n+#include \"tree-dfa.h\"\n+#include \"builtins.h\"\n+#include \"tree-phinodes.h\"\n+#include \"ssa-iterators.h\"\n+#include \"dumpfile.h\"\n+#include \"gimple-match.h\"\n+\n+\n+/* Forward declarations of the private auto-generated matchers.\n+   They expect valueized operands in canonical order and do not\n+   perform simplification of all-constant operands.  */\n+static bool gimple_simplify (code_helper *, tree *,\n+\t\t\t     gimple_seq *, tree (*)(tree),\n+\t\t\t     code_helper, tree, tree);\n+static bool gimple_simplify (code_helper *, tree *,\n+\t\t\t     gimple_seq *, tree (*)(tree),\n+\t\t\t     code_helper, tree, tree, tree);\n+static bool gimple_simplify (code_helper *, tree *,\n+\t\t\t     gimple_seq *, tree (*)(tree),\n+\t\t\t     code_helper, tree, tree, tree, tree);\n+\n+\n+/* Return whether T is a constant that we'll dispatch to fold to\n+   evaluate fully constant expressions.  */\n+\n+static inline bool\n+constant_for_folding (tree t)\n+{\n+  return (CONSTANT_CLASS_P (t)\n+\t  /* The following is only interesting to string builtins.  */\n+\t  || (TREE_CODE (t) == ADDR_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (t, 0)) == STRING_CST));\n+}\n+\n+\n+/* Helper that matches and simplifies the toplevel result from\n+   a gimple_simplify run (where we don't want to build\n+   a stmt in case it's used in in-place folding).  Replaces\n+   *RES_CODE and *RES_OPS with a simplified and/or canonicalized\n+   result and returns whether any change was made.  */\n+\n+static bool\n+gimple_resimplify1 (gimple_seq *seq,\n+\t\t    code_helper *res_code, tree type, tree *res_ops,\n+\t\t    tree (*valueize)(tree))\n+{\n+  if (constant_for_folding (res_ops[0]))\n+    {\n+      tree tem = NULL_TREE;\n+      if (res_code->is_tree_code ())\n+\ttem = fold_unary_to_constant (*res_code, type, res_ops[0]);\n+      else\n+\t{\n+\t  tree decl = builtin_decl_implicit (*res_code);\n+\t  if (decl)\n+\t    {\n+\t      tem = fold_builtin_n (UNKNOWN_LOCATION, decl, res_ops, 1, false);\n+\t      if (tem)\n+\t\t{\n+\t\t  /* fold_builtin_n wraps the result inside a NOP_EXPR.  */\n+\t\t  STRIP_NOPS (tem);\n+\t\t  tem = fold_convert (type, tem);\n+\t\t}\n+\t    }\n+\t}\n+      if (tem != NULL_TREE\n+\t  && CONSTANT_CLASS_P (tem))\n+\t{\n+\t  res_ops[0] = tem;\n+\t  res_ops[1] = NULL_TREE;\n+\t  res_ops[2] = NULL_TREE;\n+\t  *res_code = TREE_CODE (res_ops[0]);\n+\t  return true;\n+\t}\n+    }\n+\n+  code_helper res_code2;\n+  tree res_ops2[3] = {};\n+  if (gimple_simplify (&res_code2, res_ops2, seq, valueize,\n+\t\t       *res_code, type, res_ops[0]))\n+    {\n+      *res_code = res_code2;\n+      res_ops[0] = res_ops2[0];\n+      res_ops[1] = res_ops2[1];\n+      res_ops[2] = res_ops2[2];\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Helper that matches and simplifies the toplevel result from\n+   a gimple_simplify run (where we don't want to build\n+   a stmt in case it's used in in-place folding).  Replaces\n+   *RES_CODE and *RES_OPS with a simplified and/or canonicalized\n+   result and returns whether any change was made.  */\n+\n+static bool\n+gimple_resimplify2 (gimple_seq *seq,\n+\t\t    code_helper *res_code, tree type, tree *res_ops,\n+\t\t    tree (*valueize)(tree))\n+{\n+  if (constant_for_folding (res_ops[0]) && constant_for_folding (res_ops[1]))\n+    {\n+      tree tem = NULL_TREE;\n+      if (res_code->is_tree_code ())\n+\ttem = fold_binary_to_constant (*res_code, type,\n+\t\t\t\t       res_ops[0], res_ops[1]);\n+      else\n+\t{\n+\t  tree decl = builtin_decl_implicit (*res_code);\n+\t  if (decl)\n+\t    {\n+\t      tem = fold_builtin_n (UNKNOWN_LOCATION, decl, res_ops, 2, false);\n+\t      if (tem)\n+\t\t{\n+\t\t  /* fold_builtin_n wraps the result inside a NOP_EXPR.  */\n+\t\t  STRIP_NOPS (tem);\n+\t\t  tem = fold_convert (type, tem);\n+\t\t}\n+\t    }\n+\t}\n+      if (tem != NULL_TREE\n+\t  && CONSTANT_CLASS_P (tem))\n+\t{\n+\t  res_ops[0] = tem;\n+\t  res_ops[1] = NULL_TREE;\n+\t  res_ops[2] = NULL_TREE;\n+\t  *res_code = TREE_CODE (res_ops[0]);\n+\t  return true;\n+\t}\n+    }\n+\n+  /* Canonicalize operand order.  */\n+  bool canonicalized = false;\n+  if (res_code->is_tree_code ()\n+      && (TREE_CODE_CLASS ((enum tree_code) *res_code) == tcc_comparison\n+\t  || commutative_tree_code (*res_code))\n+      && tree_swap_operands_p (res_ops[0], res_ops[1], false))\n+    {\n+      tree tem = res_ops[0];\n+      res_ops[0] = res_ops[1];\n+      res_ops[1] = tem;\n+      if (TREE_CODE_CLASS ((enum tree_code) *res_code) == tcc_comparison)\n+\t*res_code = swap_tree_comparison (*res_code);\n+      canonicalized = true;\n+    }\n+\n+  code_helper res_code2;\n+  tree res_ops2[3] = {};\n+  if (gimple_simplify (&res_code2, res_ops2, seq, valueize,\n+\t\t       *res_code, type, res_ops[0], res_ops[1]))\n+    {\n+      *res_code = res_code2;\n+      res_ops[0] = res_ops2[0];\n+      res_ops[1] = res_ops2[1];\n+      res_ops[2] = res_ops2[2];\n+      return true;\n+    }\n+\n+  return canonicalized;\n+}\n+\n+/* Helper that matches and simplifies the toplevel result from\n+   a gimple_simplify run (where we don't want to build\n+   a stmt in case it's used in in-place folding).  Replaces\n+   *RES_CODE and *RES_OPS with a simplified and/or canonicalized\n+   result and returns whether any change was made.  */\n+\n+static bool\n+gimple_resimplify3 (gimple_seq *seq,\n+\t\t    code_helper *res_code, tree type, tree *res_ops,\n+\t\t    tree (*valueize)(tree))\n+{\n+  if (constant_for_folding (res_ops[0]) && constant_for_folding (res_ops[1])\n+      && constant_for_folding (res_ops[2]))\n+    {\n+      tree tem = NULL_TREE;\n+      if (res_code->is_tree_code ())\n+\ttem = fold_ternary/*_to_constant*/ (*res_code, type, res_ops[0],\n+\t\t\t\t\t    res_ops[1], res_ops[2]);\n+      else\n+\t{\n+\t  tree decl = builtin_decl_implicit (*res_code);\n+\t  if (decl)\n+\t    {\n+\t      tem = fold_builtin_n (UNKNOWN_LOCATION, decl, res_ops, 3, false);\n+\t      if (tem)\n+\t\t{\n+\t\t  /* fold_builtin_n wraps the result inside a NOP_EXPR.  */\n+\t\t  STRIP_NOPS (tem);\n+\t\t  tem = fold_convert (type, tem);\n+\t\t}\n+\t    }\n+\t}\n+      if (tem != NULL_TREE\n+\t  && CONSTANT_CLASS_P (tem))\n+\t{\n+\t  res_ops[0] = tem;\n+\t  res_ops[1] = NULL_TREE;\n+\t  res_ops[2] = NULL_TREE;\n+\t  *res_code = TREE_CODE (res_ops[0]);\n+\t  return true;\n+\t}\n+    }\n+\n+  /* Canonicalize operand order.  */\n+  bool canonicalized = false;\n+  if (res_code->is_tree_code ()\n+      && commutative_ternary_tree_code (*res_code)\n+      && tree_swap_operands_p (res_ops[0], res_ops[1], false))\n+    {\n+      tree tem = res_ops[0];\n+      res_ops[0] = res_ops[1];\n+      res_ops[1] = tem;\n+      canonicalized = true;\n+    }\n+\n+  code_helper res_code2;\n+  tree res_ops2[3] = {};\n+  if (gimple_simplify (&res_code2, res_ops2, seq, valueize,\n+\t\t       *res_code, type,\n+\t\t       res_ops[0], res_ops[1], res_ops[2]))\n+    {\n+      *res_code = res_code2;\n+      res_ops[0] = res_ops2[0];\n+      res_ops[1] = res_ops2[1];\n+      res_ops[2] = res_ops2[2];\n+      return true;\n+    }\n+\n+  return canonicalized;\n+}\n+\n+\n+/* If in GIMPLE expressions with CODE go as single-rhs build\n+   a GENERIC tree for that expression into *OP0.  */\n+\n+void\n+maybe_build_generic_op (enum tree_code code, tree type,\n+\t\t\ttree *op0, tree op1, tree op2)\n+{\n+  switch (code)\n+    {\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+      *op0 = build1 (code, type, *op0);\n+      break;\n+    case BIT_FIELD_REF:\n+      *op0 = build3 (code, type, *op0, op1, op2);\n+      break;\n+    default:;\n+    }\n+}\n+\n+/* Push the exploded expression described by RCODE, TYPE and OPS\n+   as a statement to SEQ if necessary and return a gimple value\n+   denoting the value of the expression.  If RES is not NULL\n+   then the result will be always RES and even gimple values are\n+   pushed to SEQ.  */\n+\n+tree\n+maybe_push_res_to_seq (code_helper rcode, tree type, tree *ops,\n+\t\t       gimple_seq *seq, tree res)\n+{\n+  if (rcode.is_tree_code ())\n+    {\n+      if (!res\n+\t  && (TREE_CODE_LENGTH ((tree_code) rcode) == 0\n+\t      || ((tree_code) rcode) == ADDR_EXPR)\n+\t  && is_gimple_val (ops[0]))\n+\treturn ops[0];\n+      if (!seq)\n+\treturn NULL_TREE;\n+      /* Play safe and do not allow abnormals to be mentioned in\n+         newly created statements.  */\n+      if ((TREE_CODE (ops[0]) == SSA_NAME\n+\t   && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[0]))\n+\t  || (ops[1]\n+\t      && TREE_CODE (ops[1]) == SSA_NAME\n+\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[1]))\n+\t  || (ops[2]\n+\t      && TREE_CODE (ops[2]) == SSA_NAME\n+\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[2])))\n+\treturn NULL_TREE;\n+      if (!res)\n+\tres = make_ssa_name (type, NULL);\n+      maybe_build_generic_op (rcode, type, &ops[0], ops[1], ops[2]);\n+      gimple new_stmt = gimple_build_assign_with_ops (rcode, res,\n+\t\t\t\t\t\t      ops[0], ops[1], ops[2]);\n+      gimple_seq_add_stmt_without_update (seq, new_stmt);\n+      return res;\n+    }\n+  else\n+    {\n+      if (!seq)\n+\treturn NULL_TREE;\n+      tree decl = builtin_decl_implicit (rcode);\n+      if (!decl)\n+\treturn NULL_TREE;\n+      unsigned nargs = type_num_arguments (TREE_TYPE (decl));\n+      gcc_assert (nargs <= 3);\n+      /* Play safe and do not allow abnormals to be mentioned in\n+         newly created statements.  */\n+      if ((TREE_CODE (ops[0]) == SSA_NAME\n+\t   && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[0]))\n+\t  || (nargs >= 2\n+\t      && TREE_CODE (ops[1]) == SSA_NAME\n+\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[1]))\n+\t  || (nargs == 3\n+\t      && TREE_CODE (ops[2]) == SSA_NAME\n+\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[2])))\n+\treturn NULL_TREE;\n+      if (!res)\n+\tres = make_ssa_name (type, NULL);\n+      gimple new_stmt = gimple_build_call (decl, nargs, ops[0], ops[1], ops[2]);\n+      gimple_call_set_lhs (new_stmt, res);\n+      gimple_seq_add_stmt_without_update (seq, new_stmt);\n+      return res;\n+    }\n+}\n+\n+\n+/* Public API overloads follow for operation being tree_code or\n+   built_in_function and for one to three operands or arguments.\n+   They return NULL_TREE if nothing could be simplified or\n+   the resulting simplified value with parts pushed to SEQ.\n+   If SEQ is NULL then if the simplification needs to create\n+   new stmts it will fail.  If VALUEIZE is non-NULL then all\n+   SSA names will be valueized using that hook prior to\n+   applying simplifications.  */\n+\n+/* Unary ops.  */\n+\n+tree\n+gimple_simplify (enum tree_code code, tree type,\n+\t\t tree op0,\n+\t\t gimple_seq *seq, tree (*valueize)(tree))\n+{\n+  if (constant_for_folding (op0))\n+    {\n+      tree res = fold_unary_to_constant (code, type, op0);\n+      if (res != NULL_TREE\n+\t  && CONSTANT_CLASS_P (res))\n+\treturn res;\n+    }\n+\n+  code_helper rcode;\n+  tree ops[3] = {};\n+  if (!gimple_simplify (&rcode, ops, seq, valueize,\n+\t\t\tcode, type, op0))\n+    return NULL_TREE;\n+  return maybe_push_res_to_seq (rcode, type, ops, seq);\n+}\n+\n+/* Binary ops.  */\n+\n+tree\n+gimple_simplify (enum tree_code code, tree type,\n+\t\t tree op0, tree op1,\n+\t\t gimple_seq *seq, tree (*valueize)(tree))\n+{\n+  if (constant_for_folding (op0) && constant_for_folding (op1))\n+    {\n+      tree res = fold_binary_to_constant (code, type, op0, op1);\n+      if (res != NULL_TREE\n+\t  && CONSTANT_CLASS_P (res))\n+\treturn res;\n+    }\n+\n+  /* Canonicalize operand order both for matching and fallback stmt\n+     generation.  */\n+  if ((commutative_tree_code (code)\n+       || TREE_CODE_CLASS (code) == tcc_comparison)\n+      && tree_swap_operands_p (op0, op1, false))\n+    {\n+      tree tem = op0;\n+      op0 = op1;\n+      op1 = tem;\n+      if (TREE_CODE_CLASS (code) == tcc_comparison)\n+\tcode = swap_tree_comparison (code);\n+    }\n+\n+  code_helper rcode;\n+  tree ops[3] = {};\n+  if (!gimple_simplify (&rcode, ops, seq, valueize,\n+\t\t\tcode, type, op0, op1))\n+    return NULL_TREE;\n+  return maybe_push_res_to_seq (rcode, type, ops, seq);\n+}\n+\n+/* Ternary ops.  */\n+\n+tree\n+gimple_simplify (enum tree_code code, tree type,\n+\t\t tree op0, tree op1, tree op2,\n+\t\t gimple_seq *seq, tree (*valueize)(tree))\n+{\n+  if (constant_for_folding (op0) && constant_for_folding (op1)\n+      && constant_for_folding (op2))\n+    {\n+      tree res = fold_ternary/*_to_constant */ (code, type, op0, op1, op2);\n+      if (res != NULL_TREE\n+\t  && CONSTANT_CLASS_P (res))\n+\treturn res;\n+    }\n+\n+  /* Canonicalize operand order both for matching and fallback stmt\n+     generation.  */\n+  if (commutative_ternary_tree_code (code)\n+      && tree_swap_operands_p (op0, op1, false))\n+    {\n+      tree tem = op0;\n+      op0 = op1;\n+      op1 = tem;\n+    }\n+\n+  code_helper rcode;\n+  tree ops[3] = {};\n+  if (!gimple_simplify (&rcode, ops, seq, valueize,\n+\t\t\tcode, type, op0, op1, op2))\n+    return NULL_TREE;\n+  return maybe_push_res_to_seq (rcode, type, ops, seq);\n+}\n+\n+/* Builtin function with one argument.  */\n+\n+tree\n+gimple_simplify (enum built_in_function fn, tree type,\n+\t\t tree arg0,\n+\t\t gimple_seq *seq, tree (*valueize)(tree))\n+{\n+  if (constant_for_folding (arg0))\n+    {\n+      tree decl = builtin_decl_implicit (fn);\n+      if (decl)\n+\t{\n+\t  tree res = fold_builtin_n (UNKNOWN_LOCATION, decl, &arg0, 1, false);\n+\t  if (res)\n+\t    {\n+\t      /* fold_builtin_n wraps the result inside a NOP_EXPR.  */\n+\t      STRIP_NOPS (res);\n+\t      res = fold_convert (type, res);\n+\t      if (CONSTANT_CLASS_P (res))\n+\t\treturn res;\n+\t    }\n+\t}\n+    }\n+\n+  code_helper rcode;\n+  tree ops[3] = {};\n+  if (!gimple_simplify (&rcode, ops, seq, valueize,\n+\t\t\tfn, type, arg0))\n+    return NULL_TREE;\n+  return maybe_push_res_to_seq (rcode, type, ops, seq);\n+}\n+\n+/* Builtin function with two arguments.  */\n+\n+tree\n+gimple_simplify (enum built_in_function fn, tree type,\n+\t\t tree arg0, tree arg1,\n+\t\t gimple_seq *seq, tree (*valueize)(tree))\n+{\n+  if (constant_for_folding (arg0)\n+      && constant_for_folding (arg1))\n+    {\n+      tree decl = builtin_decl_implicit (fn);\n+      if (decl)\n+\t{\n+\t  tree args[2];\n+\t  args[0] = arg0;\n+\t  args[1] = arg1;\n+\t  tree res = fold_builtin_n (UNKNOWN_LOCATION, decl, args, 2, false);\n+\t  if (res)\n+\t    {\n+\t      /* fold_builtin_n wraps the result inside a NOP_EXPR.  */\n+\t      STRIP_NOPS (res);\n+\t      res = fold_convert (type, res);\n+\t      if (CONSTANT_CLASS_P (res))\n+\t\treturn res;\n+\t    }\n+\t}\n+    }\n+\n+  code_helper rcode;\n+  tree ops[3] = {};\n+  if (!gimple_simplify (&rcode, ops, seq, valueize,\n+\t\t\tfn, type, arg0, arg1))\n+    return NULL_TREE;\n+  return maybe_push_res_to_seq (rcode, type, ops, seq);\n+}\n+\n+/* Builtin function with three arguments.  */\n+\n+tree\n+gimple_simplify (enum built_in_function fn, tree type,\n+\t\t tree arg0, tree arg1, tree arg2,\n+\t\t gimple_seq *seq, tree (*valueize)(tree))\n+{\n+  if (constant_for_folding (arg0)\n+      && constant_for_folding (arg1)\n+      && constant_for_folding (arg2))\n+    {\n+      tree decl = builtin_decl_implicit (fn);\n+      if (decl)\n+\t{\n+\t  tree args[3];\n+\t  args[0] = arg0;\n+\t  args[1] = arg1;\n+\t  args[2] = arg2;\n+\t  tree res = fold_builtin_n (UNKNOWN_LOCATION, decl, args, 3, false);\n+\t  if (res)\n+\t    {\n+\t      /* fold_builtin_n wraps the result inside a NOP_EXPR.  */\n+\t      STRIP_NOPS (res);\n+\t      res = fold_convert (type, res);\n+\t      if (CONSTANT_CLASS_P (res))\n+\t\treturn res;\n+\t    }\n+\t}\n+    }\n+\n+  code_helper rcode;\n+  tree ops[3] = {};\n+  if (!gimple_simplify (&rcode, ops, seq, valueize,\n+\t\t\tfn, type, arg0, arg1, arg2))\n+    return NULL_TREE;\n+  return maybe_push_res_to_seq (rcode, type, ops, seq);\n+}\n+\n+\n+/* The main STMT based simplification entry.  It is used by the fold_stmt\n+   and the fold_stmt_to_constant APIs.  */\n+\n+bool\n+gimple_simplify (gimple stmt,\n+\t\t code_helper *rcode, tree *ops,\n+\t\t gimple_seq *seq, tree (*valueize)(tree))\n+{\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_ASSIGN:\n+      {\n+\tenum tree_code code = gimple_assign_rhs_code (stmt);\n+\ttree type = TREE_TYPE (gimple_assign_lhs (stmt));\n+\tswitch (gimple_assign_rhs_class (stmt))\n+\t  {\n+\t  case GIMPLE_SINGLE_RHS:\n+\t    if (code == REALPART_EXPR\n+\t\t|| code == IMAGPART_EXPR\n+\t\t|| code == VIEW_CONVERT_EXPR)\n+\t      {\n+\t\ttree op0 = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n+\t\tif (valueize && TREE_CODE (op0) == SSA_NAME)\n+\t\t  {\n+\t\t    tree tem = valueize (op0);\n+\t\t    if (tem)\n+\t\t      op0 = tem;\n+\t\t  }\n+\t\t*rcode = code;\n+\t\tops[0] = op0;\n+\t\treturn gimple_resimplify1 (seq, rcode, type, ops, valueize);\n+\t      }\n+\t    else if (code == BIT_FIELD_REF)\n+\t      {\n+\t\ttree rhs1 = gimple_assign_rhs1 (stmt);\n+\t\ttree op0 = TREE_OPERAND (rhs1, 0);\n+\t\tif (valueize && TREE_CODE (op0) == SSA_NAME)\n+\t\t  {\n+\t\t    tree tem = valueize (op0);\n+\t\t    if (tem)\n+\t\t      op0 = tem;\n+\t\t  }\n+\t\t*rcode = code;\n+\t\tops[0] = op0;\n+\t\tops[1] = TREE_OPERAND (rhs1, 1);\n+\t\tops[2] = TREE_OPERAND (rhs1, 2);\n+\t\treturn gimple_resimplify3 (seq, rcode, type, ops, valueize);\n+\t      }\n+\t    else if (code == SSA_NAME\n+\t\t     && valueize)\n+\t      {\n+\t\ttree op0 = gimple_assign_rhs1 (stmt);\n+\t\ttree valueized = valueize (op0);\n+\t\tif (!valueized || op0 == valueized)\n+\t\t  return false;\n+\t\tops[0] = valueized;\n+\t\t*rcode = TREE_CODE (op0);\n+\t\treturn true;\n+\t      }\n+\t    break;\n+\t  case GIMPLE_UNARY_RHS:\n+\t    {\n+\t      tree rhs1 = gimple_assign_rhs1 (stmt);\n+\t      if (valueize && TREE_CODE (rhs1) == SSA_NAME)\n+\t\t{\n+\t\t  tree tem = valueize (rhs1);\n+\t\t  if (tem)\n+\t\t    rhs1 = tem;\n+\t\t}\n+\t      *rcode = code;\n+\t      ops[0] = rhs1;\n+\t      return gimple_resimplify1 (seq, rcode, type, ops, valueize);\n+\t    }\n+\t  case GIMPLE_BINARY_RHS:\n+\t    {\n+\t      tree rhs1 = gimple_assign_rhs1 (stmt);\n+\t      if (valueize && TREE_CODE (rhs1) == SSA_NAME)\n+\t\t{\n+\t\t  tree tem = valueize (rhs1);\n+\t\t  if (tem)\n+\t\t    rhs1 = tem;\n+\t\t}\n+\t      tree rhs2 = gimple_assign_rhs2 (stmt);\n+\t      if (valueize && TREE_CODE (rhs2) == SSA_NAME)\n+\t\t{\n+\t\t  tree tem = valueize (rhs2);\n+\t\t  if (tem)\n+\t\t    rhs2 = tem;\n+\t\t}\n+\t      *rcode = code;\n+\t      ops[0] = rhs1;\n+\t      ops[1] = rhs2;\n+\t      return gimple_resimplify2 (seq, rcode, type, ops, valueize);\n+\t    }\n+\t  case GIMPLE_TERNARY_RHS:\n+\t    {\n+\t      tree rhs1 = gimple_assign_rhs1 (stmt);\n+\t      if (valueize && TREE_CODE (rhs1) == SSA_NAME)\n+\t\t{\n+\t\t  tree tem = valueize (rhs1);\n+\t\t  if (tem)\n+\t\t    rhs1 = tem;\n+\t\t}\n+\t      tree rhs2 = gimple_assign_rhs2 (stmt);\n+\t      if (valueize && TREE_CODE (rhs2) == SSA_NAME)\n+\t\t{\n+\t\t  tree tem = valueize (rhs2);\n+\t\t  if (tem)\n+\t\t    rhs2 = tem;\n+\t\t}\n+\t      tree rhs3 = gimple_assign_rhs3 (stmt);\n+\t      if (valueize && TREE_CODE (rhs3) == SSA_NAME)\n+\t\t{\n+\t\t  tree tem = valueize (rhs3);\n+\t\t  if (tem)\n+\t\t    rhs3 = tem;\n+\t\t}\n+\t      *rcode = code;\n+\t      ops[0] = rhs1;\n+\t      ops[1] = rhs2;\n+\t      ops[2] = rhs3;\n+\t      return gimple_resimplify3 (seq, rcode, type, ops, valueize);\n+\t    }\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\tbreak;\n+      }\n+\n+    case GIMPLE_CALL:\n+      /* ???  This way we can't simplify calls with side-effects.  */\n+      if (gimple_call_lhs (stmt) != NULL_TREE)\n+\t{\n+\t  tree fn = gimple_call_fn (stmt);\n+\t  /* ???  Internal function support missing.  */\n+\t  if (!fn)\n+\t    return false;\n+\t  if (valueize && TREE_CODE (fn) == SSA_NAME)\n+\t    {\n+\t      tree tem = valueize (fn);\n+\t      if (tem)\n+\t\tfn = tem;\n+\t    }\n+\t  if (!fn\n+\t      || TREE_CODE (fn) != ADDR_EXPR\n+\t      || TREE_CODE (TREE_OPERAND (fn, 0)) != FUNCTION_DECL\n+\t      || DECL_BUILT_IN_CLASS (TREE_OPERAND (fn, 0)) != BUILT_IN_NORMAL\n+\t      || !builtin_decl_implicit (DECL_FUNCTION_CODE (TREE_OPERAND (fn, 0)))\n+\t      || !gimple_builtin_call_types_compatible_p (stmt,\n+\t\t\t\t\t\t\t  TREE_OPERAND (fn, 0)))\n+\t    return false;\n+\n+\t  tree decl = TREE_OPERAND (fn, 0);\n+\t  tree type = TREE_TYPE (gimple_call_lhs (stmt));\n+\t  switch (gimple_call_num_args (stmt))\n+\t    {\n+\t    case 1:\n+\t      {\n+\t\ttree arg1 = gimple_call_arg (stmt, 0);\n+\t\tif (valueize && TREE_CODE (arg1) == SSA_NAME)\n+\t\t  {\n+\t\t    tree tem = valueize (arg1);\n+\t\t    if (tem)\n+\t\t      arg1 = tem;\n+\t\t  }\n+\t\t*rcode = DECL_FUNCTION_CODE (decl);\n+\t\tops[0] = arg1;\n+\t\treturn gimple_resimplify1 (seq, rcode, type, ops, valueize);\n+\t      }\n+\t    case 2:\n+\t      {\n+\t\ttree arg1 = gimple_call_arg (stmt, 0);\n+\t\tif (valueize && TREE_CODE (arg1) == SSA_NAME)\n+\t\t  {\n+\t\t    tree tem = valueize (arg1);\n+\t\t    if (tem)\n+\t\t      arg1 = tem;\n+\t\t  }\n+\t\ttree arg2 = gimple_call_arg (stmt, 1);\n+\t\tif (valueize && TREE_CODE (arg2) == SSA_NAME)\n+\t\t  {\n+\t\t    tree tem = valueize (arg2);\n+\t\t    if (tem)\n+\t\t      arg2 = tem;\n+\t\t  }\n+\t\t*rcode = DECL_FUNCTION_CODE (decl);\n+\t\tops[0] = arg1;\n+\t\tops[1] = arg2;\n+\t\treturn gimple_resimplify2 (seq, rcode, type, ops, valueize);\n+\t      }\n+\t    case 3:\n+\t      {\n+\t\ttree arg1 = gimple_call_arg (stmt, 0);\n+\t\tif (valueize && TREE_CODE (arg1) == SSA_NAME)\n+\t\t  {\n+\t\t    tree tem = valueize (arg1);\n+\t\t    if (tem)\n+\t\t      arg1 = tem;\n+\t\t  }\n+\t\ttree arg2 = gimple_call_arg (stmt, 1);\n+\t\tif (valueize && TREE_CODE (arg2) == SSA_NAME)\n+\t\t  {\n+\t\t    tree tem = valueize (arg2);\n+\t\t    if (tem)\n+\t\t      arg2 = tem;\n+\t\t  }\n+\t\ttree arg3 = gimple_call_arg (stmt, 2);\n+\t\tif (valueize && TREE_CODE (arg3) == SSA_NAME)\n+\t\t  {\n+\t\t    tree tem = valueize (arg3);\n+\t\t    if (tem)\n+\t\t      arg3 = tem;\n+\t\t  }\n+\t\t*rcode = DECL_FUNCTION_CODE (decl);\n+\t\tops[0] = arg1;\n+\t\tops[1] = arg2;\n+\t\tops[2] = arg3;\n+\t\treturn gimple_resimplify3 (seq, rcode, type, ops, valueize);\n+\t      }\n+\t    default:\n+\t      return false;\n+\t    }\n+\t}\n+      break;\n+\n+    case GIMPLE_COND:\n+      {\n+\ttree lhs = gimple_cond_lhs (stmt);\n+\tif (valueize && TREE_CODE (lhs) == SSA_NAME)\n+\t  {\n+\t    tree tem = valueize (lhs);\n+\t    if (tem)\n+\t      lhs = tem;\n+\t  }\n+\ttree rhs = gimple_cond_rhs (stmt);\n+\tif (valueize && TREE_CODE (rhs) == SSA_NAME)\n+\t  {\n+\t    tree tem = valueize (rhs);\n+\t    if (tem)\n+\t      rhs = tem;\n+\t  }\n+\t*rcode = gimple_cond_code (stmt);\n+\tops[0] = lhs;\n+\tops[1] = rhs;\n+        return gimple_resimplify2 (seq, rcode, boolean_type_node, ops, valueize);\n+      }\n+\n+    default:\n+      break;\n+    }\n+\n+  return false;\n+}\n+\n+\n+/* Helper for the autogenerated code, valueize OP.  */\n+\n+inline tree\n+do_valueize (tree (*valueize)(tree), tree op)\n+{\n+  if (valueize && TREE_CODE (op) == SSA_NAME)\n+    return valueize (op);\n+  return op;\n+}\n+"}, {"sha": "571d5fd311e1c51853094b33d628a4abcc5ba025", "filename": "gcc/gimple-match.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fgimple-match.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fgimple-match.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match.h?ref=3d2cf79f8112e357327a1a8a1765ab1c6022244c", "patch": "@@ -0,0 +1,50 @@\n+/* Gimple simplify definitions.\n+\n+   Copyright (C) 2011-2014 Free Software Foundation, Inc.\n+   Contributed by Richard Guenther <rguenther@suse.de>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GIMPLE_MATCH_H\n+#define GCC_GIMPLE_MATCH_H\n+\n+\n+/* Helper to transparently allow tree codes and builtin function codes\n+   exist in one storage entity.  */\n+class code_helper\n+{\n+public:\n+  code_helper () {}\n+  code_helper (tree_code code) : rep ((int) code) {}\n+  code_helper (built_in_function fn) : rep (-(int) fn) {}\n+  operator tree_code () const { return (tree_code) rep; }\n+  operator built_in_function () const { return (built_in_function) -rep; }\n+  bool is_tree_code () const { return rep > 0; }\n+  bool is_fn_code () const { return rep < 0; }\n+  int get_rep () const { return rep; }\n+private:\n+  int rep;\n+};\n+\n+bool gimple_simplify (gimple, code_helper *, tree *, gimple_seq *,\n+\t\t      tree (*)(tree));\n+tree maybe_push_res_to_seq (code_helper, tree, tree *,\n+\t\t\t    gimple_seq *, tree res = NULL_TREE);\n+void maybe_build_generic_op (enum tree_code, tree, tree *, tree, tree);\n+\n+\n+#endif  /* GCC_GIMPLE_MATCH_H */"}, {"sha": "097dfcd2dfacd356419b82940806614128cfddbf", "filename": "gcc/match.pd", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cf79f8112e357327a1a8a1765ab1c6022244c/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=3d2cf79f8112e357327a1a8a1765ab1c6022244c", "patch": "@@ -0,0 +1,30 @@\n+/* Match-and-simplify patterns for shared GENERIC and GIMPLE folding.\n+   This file is consumed by genmatch which produces gimple-match.c\n+   and generic-match.c from it.\n+\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by Richard Biener <rguenther@suse.de>\n+   and Prathamesh Kulkarni  <bilbotheelffriend@gmail.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+/* Generic tree predicates we inherit.  */\n+(define_predicates\n+   integer_onep integer_zerop integer_all_onesp\n+   real_zerop real_onep\n+   CONSTANT_CLASS_P)"}]}