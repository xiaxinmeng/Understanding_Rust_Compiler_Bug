{"sha": "15e23330102f2c2a0815c70cf0ffca18fcdfdc40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVlMjMzMzAxMDJmMmMyYTA4MTVjNzBjZjBmZmNhMThmY2RmZGM0MA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-09-25T16:49:48Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-09-25T16:49:48Z"}, "message": "lang.opt: Add -Wdo-subscript.\n\n2017-09-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* lang.opt:  Add -Wdo-subscript.\n\t* frontend-passes.c (do_t): New type.\n\t(doloop_list): Use variable of do_type.\n\t(if_level): Variable to track if levels.\n\t(select_level): Variable to track select levels.\n\t(gfc_run_passes): Initialize i_level and select_level.\n\t(doloop_code): Record current level of if + select\n\tlevel in doloop_list.  Add seen_goto if there could\n\tbe a branch outside the loop. Use different type for\n\tdoloop_list.\n\t(doloop_function): Call do_intent and do_subscript; move\n\tfunctionality of checking INTENT to do_intent.\n\t(insert_index_t): New type, for callback_insert_index.\n\t(callback_insert_index): New function.\n\t(insert_index): New function.\n\t(do_subscript): New function.\n\t(do_intent): New function.\n\t(gfc_code_walker): Keep track of if_level and select_level.\n\t* invoke.texi: Document -Wdo-subscript.\n\n2017-09-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* gfortran.dg/do_subscript_1.f90: New test.\n\t* gfortran.dg/do_subscript_2.f90: New test.\n\t* gfortran.dg/gomp/associate1.f90: Add out of bounds warning.\n\t* gfortran.dg/predcom-1.f: Adjust loop bounds.\n\t* gfortran.dg/unconstrained_commons.f: Add out of bounds warning.\n\nFrom-SVN: r253156", "tree": {"sha": "ac972b3706f15d894f99950f2eb6dd4519f8d5c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac972b3706f15d894f99950f2eb6dd4519f8d5c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15e23330102f2c2a0815c70cf0ffca18fcdfdc40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e23330102f2c2a0815c70cf0ffca18fcdfdc40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e23330102f2c2a0815c70cf0ffca18fcdfdc40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e23330102f2c2a0815c70cf0ffca18fcdfdc40/comments", "author": null, "committer": null, "parents": [{"sha": "58e17cf84636d72e3620b5af50b0336d9364ddd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58e17cf84636d72e3620b5af50b0336d9364ddd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58e17cf84636d72e3620b5af50b0336d9364ddd0"}], "stats": {"total": 487, "additions": 471, "deletions": 16}, "files": [{"sha": "8cbf282e6cc0927a8722971a3e5603576a44ea04", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e23330102f2c2a0815c70cf0ffca18fcdfdc40/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e23330102f2c2a0815c70cf0ffca18fcdfdc40/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=15e23330102f2c2a0815c70cf0ffca18fcdfdc40", "patch": "@@ -1,3 +1,25 @@\n+2017-09-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* lang.opt:  Add -Wdo-subscript.\n+\t* frontend-passes.c (do_t): New type.\n+\t(doloop_list): Use variable of do_type.\n+\t(if_level): Variable to track if levels.\n+\t(select_level): Variable to track select levels.\n+\t(gfc_run_passes): Initialize i_level and select_level.\n+\t(doloop_code): Record current level of if + select\n+\tlevel in doloop_list.  Add seen_goto if there could\n+\tbe a branch outside the loop. Use different type for\n+\tdoloop_list.\n+\t(doloop_function): Call do_intent and do_subscript; move\n+\tfunctionality of checking INTENT to do_intent.\n+\t(insert_index_t): New type, for callback_insert_index.\n+\t(callback_insert_index): New function.\n+\t(insert_index): New function.\n+\t(do_subscript): New function.\n+\t(do_intent): New function.\n+\t(gfc_code_walker): Keep track of if_level and select_level.\n+\t* invoke.texi: Document -Wdo-subscript.\n+\n 2017-09-25  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* trans.c (gfc_unlikely): Remove unnecessary fold_convert."}, {"sha": "93f2c0fa03824fef3527d6250de0477cdf2ce2f3", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 338, "deletions": 12, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e23330102f2c2a0815c70cf0ffca18fcdfdc40/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e23330102f2c2a0815c70cf0ffca18fcdfdc40/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=15e23330102f2c2a0815c70cf0ffca18fcdfdc40", "patch": "@@ -39,6 +39,8 @@ static bool optimize_lexical_comparison (gfc_expr *);\n static void optimize_minmaxloc (gfc_expr **);\n static bool is_empty_string (gfc_expr *e);\n static void doloop_warn (gfc_namespace *);\n+static int do_intent (gfc_expr **);\n+static int do_subscript (gfc_expr **);\n static void optimize_reduction (gfc_namespace *);\n static int callback_reduction (gfc_expr **, int *, void *);\n static void realloc_strings (gfc_namespace *);\n@@ -98,10 +100,20 @@ static int iterator_level;\n \n /* Keep track of DO loop levels.  */\n \n-static vec<gfc_code *> doloop_list;\n+typedef struct {\n+  gfc_code *c;\n+  int branch_level;\n+  bool seen_goto;\n+} do_t;\n \n+static vec<do_t> doloop_list;\n static int doloop_level;\n \n+/* Keep track of if and select case levels.  */\n+\n+static int if_level;\n+static int select_level;\n+\n /* Vector of gfc_expr * to keep track of DO loops.  */\n \n struct my_struct *evec;\n@@ -133,6 +145,8 @@ gfc_run_passes (gfc_namespace *ns)\n      change.  */\n \n   doloop_level = 0;\n+  if_level = 0;\n+  select_level = 0;\n   doloop_warn (ns);\n   doloop_list.release ();\n   int w, e;\n@@ -2231,6 +2245,8 @@ doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n   gfc_formal_arglist *f;\n   gfc_actual_arglist *a;\n   gfc_code *cl;\n+  do_t loop, *lp;\n+  bool seen_goto;\n \n   co = *c;\n \n@@ -2239,14 +2255,65 @@ doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n   if ((unsigned) doloop_level < doloop_list.length())\n     doloop_list.truncate (doloop_level);\n \n+  seen_goto = false;\n   switch (co->op)\n     {\n     case EXEC_DO:\n \n       if (co->ext.iterator && co->ext.iterator->var)\n-\tdoloop_list.safe_push (co);\n+\tloop.c = co;\n       else\n-\tdoloop_list.safe_push ((gfc_code *) NULL);\n+\tloop.c = NULL;\n+\n+      loop.branch_level = if_level + select_level;\n+      loop.seen_goto = false;\n+      doloop_list.safe_push (loop);\n+      break;\n+\n+      /* If anything could transfer control away from a suspicious\n+\t subscript, make sure to set seen_goto in the current DO loop\n+\t (if any).  */\n+    case EXEC_GOTO:\n+    case EXEC_EXIT:\n+    case EXEC_STOP:\n+    case EXEC_ERROR_STOP:\n+    case EXEC_CYCLE:\n+      seen_goto = true;\n+      break;\n+\n+    case EXEC_OPEN:\n+      if (co->ext.open->err)\n+\tseen_goto = true;\n+      break;\n+\n+    case EXEC_CLOSE:\n+      if (co->ext.close->err)\n+\tseen_goto = true;\n+      break;\n+\n+    case EXEC_BACKSPACE:\n+    case EXEC_ENDFILE:\n+    case EXEC_REWIND:\n+    case EXEC_FLUSH:\n+\n+      if (co->ext.filepos->err)\n+\tseen_goto = true;\n+      break;\n+\n+    case EXEC_INQUIRE:\n+      if (co->ext.filepos->err)\n+\tseen_goto = true;\n+      break;\n+\n+    case EXEC_READ:\n+    case EXEC_WRITE:\n+      if (co->ext.dt->err || co->ext.dt->end || co->ext.dt->eor)\n+\tseen_goto = true;\n+      break;\n+\n+    case EXEC_WAIT:\n+      if (co->ext.wait->err || co->ext.wait->end || co->ext.wait->eor)\n+\tloop.seen_goto = true;\n       break;\n \n     case EXEC_CALL:\n@@ -2265,9 +2332,10 @@ doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n \n       while (a && f)\n \t{\n-\t  FOR_EACH_VEC_ELT (doloop_list, i, cl)\n+\t  FOR_EACH_VEC_ELT (doloop_list, i, lp)\n \t    {\n \t      gfc_symbol *do_sym;\n+\t      cl = lp->c;\n \n \t      if (cl == NULL)\n \t\tbreak;\n@@ -2282,14 +2350,14 @@ doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t\t\t\t   \"value inside loop  beginning at %L as \"\n \t\t\t\t   \"INTENT(OUT) argument to subroutine %qs\",\n \t\t\t\t   do_sym->name, &a->expr->where,\n-\t\t\t\t   &doloop_list[i]->loc,\n+\t\t\t\t   &(doloop_list[i].c->loc),\n \t\t\t\t   co->symtree->n.sym->name);\n \t\t  else if (f->sym->attr.intent == INTENT_INOUT)\n \t\t    gfc_error_now (\"Variable %qs at %L not definable inside \"\n \t\t\t\t   \"loop beginning at %L as INTENT(INOUT) \"\n \t\t\t\t   \"argument to subroutine %qs\",\n \t\t\t\t   do_sym->name, &a->expr->where,\n-\t\t\t\t   &doloop_list[i]->loc,\n+\t\t\t\t   &(doloop_list[i].c->loc),\n \t\t\t\t   co->symtree->n.sym->name);\n \t\t}\n \t    }\n@@ -2301,20 +2369,267 @@ doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n     default:\n       break;\n     }\n+  if (seen_goto && doloop_level > 0)\n+    doloop_list[doloop_level-1].seen_goto = true;\n+\n   return 0;\n }\n \n-/* Callback function for functions checking that we do not pass a DO variable\n-   to an INTENT(OUT) or INTENT(INOUT) dummy variable.  */\n+/* Callback function to warn about different things within DO loops.  */\n \n static int\n do_function (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t     void *data ATTRIBUTE_UNUSED)\n+{\n+  do_t *last;\n+\n+  if (doloop_list.length () == 0)\n+    return 0;\n+\n+  if ((*e)->expr_type == EXPR_FUNCTION)\n+    do_intent (e);\n+\n+  last = &doloop_list.last();\n+  if (last->seen_goto && !warn_do_subscript)\n+    return 0;\n+\n+  if ((*e)->expr_type == EXPR_VARIABLE)\n+    do_subscript (e);\n+\n+  return 0;\n+}\n+\n+typedef struct\n+{\n+  gfc_symbol *sym;\n+  mpz_t val;\n+} insert_index_t;\n+\n+/* Callback function - if the expression is the variable in data->sym,\n+   replace it with a constant from data->val.  */\n+\n+static int\n+callback_insert_index (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t       void *data)\n+{\n+  insert_index_t *d;\n+  gfc_expr *ex, *n;\n+\n+  ex = (*e);\n+  if (ex->expr_type != EXPR_VARIABLE)\n+    return 0;\n+\n+  d = (insert_index_t *) data;\n+  if (ex->symtree->n.sym != d->sym)\n+    return 0;\n+\n+  n = gfc_get_constant_expr (BT_INTEGER, ex->ts.kind, &ex->where);\n+  mpz_set (n->value.integer, d->val);\n+\n+  gfc_free_expr (ex);\n+  *e = n;\n+  return 0;\n+}\n+\n+/* In the expression e, replace occurrences of the variable sym with\n+   val.  If this results in a constant expression, return true and\n+   return the value in ret.  Return false if the expression already\n+   is a constant.  Caller has to clear ret in that case.  */\n+\n+static bool\n+insert_index (gfc_expr *e, gfc_symbol *sym, mpz_t val, mpz_t ret)\n+{\n+  gfc_expr *n;\n+  insert_index_t data;\n+  bool rc;\n+\n+  if (e->expr_type == EXPR_CONSTANT)\n+    return false;\n+\n+  n = gfc_copy_expr (e);\n+  data.sym = sym;\n+  mpz_init_set (data.val, val);\n+  gfc_expr_walker (&n, callback_insert_index, (void *) &data);\n+  gfc_simplify_expr (n, 0);\n+\n+  if (n->expr_type == EXPR_CONSTANT)\n+    {\n+      rc = true;\n+      mpz_init_set (ret, n->value.integer);\n+    }\n+  else\n+    rc = false;\n+\n+  mpz_clear (data.val);\n+  gfc_free_expr (n);\n+  return rc;\n+\n+}\n+\n+/* Check array subscripts for possible out-of-bounds accesses in DO\n+   loops with constant bounds.  */\n+\n+static int\n+do_subscript (gfc_expr **e)\n+{\n+  gfc_expr *v;\n+  gfc_array_ref *ar;\n+  gfc_ref *ref;\n+  int i,j;\n+  gfc_code *dl;\n+  do_t *lp;\n+\n+  v = *e;\n+  /* Constants are already checked.  */\n+  if (v->expr_type == EXPR_CONSTANT)\n+    return 0;\n+\n+  for (ref = v->ref; ref; ref = ref->next)\n+    {\n+      if (ref->type == REF_ARRAY && ref->u.ar.type == AR_ELEMENT)\n+\t{\n+\t  ar = & ref->u.ar;\n+\t  FOR_EACH_VEC_ELT (doloop_list, j, lp)\n+\t    {\n+\t      gfc_symbol *do_sym;\n+\t      mpz_t do_start, do_step, do_end;\n+\t      bool have_do_start, have_do_end;\n+\t      bool error_not_proven;\n+\t      int warn;\n+\n+\t      dl = lp->c;\n+\t      if (dl == NULL)\n+\t\tbreak;\n+\n+\t      /* If we are within a branch, or a goto or equivalent\n+\t\t was seen in the DO loop before, then we cannot prove that\n+\t\t this expression is actually evaluated.  Don't do anything\n+\t\t unless we want to see it all.  */\n+\t      error_not_proven = lp->seen_goto\n+\t\t|| lp->branch_level < if_level + select_level;\n+\n+\t      if (error_not_proven && !warn_do_subscript)\n+\t\tbreak;\n+\n+\t      if (error_not_proven)\n+\t\twarn = OPT_Wdo_subscript;\n+\t      else\n+\t\twarn = 0;\n+\n+\t      do_sym = dl->ext.iterator->var->symtree->n.sym;\n+\t      if (do_sym->ts.type != BT_INTEGER)\n+\t\tcontinue;\n+\n+\t      /* If we do not know about the stepsize, the loop may be zero trip.\n+\t\t Do not warn in this case.  */\n+\t  \n+\t      if (dl->ext.iterator->step->expr_type == EXPR_CONSTANT)\n+\t\tmpz_init_set (do_step, dl->ext.iterator->step->value.integer);\n+\t      else\n+\t\tcontinue;\n+\n+\t      if (dl->ext.iterator->start->expr_type == EXPR_CONSTANT)\n+\t\t{\n+\t\t  have_do_start = true;\n+\t\t  mpz_init_set (do_start, dl->ext.iterator->start->value.integer);\n+\t\t}\n+\t      else\n+\t\thave_do_start = false;\n+\n+\t  \n+\t      if (dl->ext.iterator->end->expr_type == EXPR_CONSTANT)\n+\t\t{\n+\t\t  have_do_end = true;\n+\t\t  mpz_init_set (do_end, dl->ext.iterator->end->value.integer);\n+\t\t}\n+\t      else\n+\t\thave_do_end = false;\n+\n+\t      if (!have_do_start && !have_do_end)\n+\t\treturn 0;\n+\n+\t      /* May have to correct the end value if the step does not equal\n+\t\t one.  */\n+\t      if (have_do_start && have_do_end && mpz_cmp_ui (do_step, 1) != 0)\n+\t\t{\n+\t\t  mpz_t diff, rem;\n+\n+\t\t  mpz_init (diff);\n+\t\t  mpz_init (rem);\n+\t\t  mpz_sub (diff, do_end, do_start);\n+\t\t  mpz_tdiv_r (rem, diff, do_step);\n+\t\t  mpz_sub (do_end, do_end, rem);\n+\t\t  mpz_clear (diff);\n+\t\t  mpz_clear (rem);\n+\t\t}\n+\n+\t      for (i = 0; i< ar->dimen; i++)\n+\t\t{\n+\t\t  mpz_t val;\n+\t\t  if (ar->dimen_type[i] == DIMEN_ELEMENT && have_do_start\n+\t\t      && insert_index (ar->start[i], do_sym, do_start, val))\n+\t\t    {\n+\t\t      if (ar->as->lower[i]\n+\t\t\t  && ar->as->lower[i]->expr_type == EXPR_CONSTANT\n+\t\t\t  && mpz_cmp (val, ar->as->lower[i]->value.integer) < 0)\n+\t\t\tgfc_warning (warn, \"Array reference at %L out of bounds \"\n+\t\t\t\t     \"(%ld < %ld) in loop beginning at %L\",\n+\t\t\t\t     &ar->start[i]->where, mpz_get_si (val),\n+\t\t\t\t     mpz_get_si (ar->as->lower[i]->value.integer),\n+\t\t\t\t     &doloop_list[j].c->loc);\n+\n+\t\t      if (ar->as->upper[i]\n+\t\t\t  && ar->as->upper[i]->expr_type == EXPR_CONSTANT\n+\t\t\t  && mpz_cmp (val, ar->as->upper[i]->value.integer) > 0)\n+\t\t\t    gfc_warning (warn, \"Array reference at %L out of bounds \"\n+\t\t\t\t\t \"(%ld > %ld) in loop beginning at %L\",\n+\t\t\t\t\t &ar->start[i]->where, mpz_get_si (val),\n+\t\t\t\t\t mpz_get_si (ar->as->upper[i]->value.integer),\n+\t\t\t\t\t &doloop_list[j].c->loc);\n+\n+\t\t      mpz_clear (val);\n+\t\t    }\n+\n+\t\t  if (ar->dimen_type[i] == DIMEN_ELEMENT && have_do_end\n+\t\t      && insert_index (ar->start[i], do_sym, do_end, val))\n+\t\t    {\n+\t\t      if (ar->as->lower[i]\n+\t\t\t  && ar->as->lower[i]->expr_type == EXPR_CONSTANT\n+\t\t\t  && mpz_cmp (val, ar->as->lower[i]->value.integer) < 0)\n+\t\t\tgfc_warning (warn, \"Array reference at %L out of bounds \"\n+\t\t\t\t     \"(%ld < %ld) in loop beginning at %L\",\n+\t\t\t\t     &ar->start[i]->where, mpz_get_si (val),\n+\t\t\t\t     mpz_get_si (ar->as->lower[i]->value.integer),\n+\t\t\t\t     &doloop_list[j].c->loc);\n+\n+\t\t      if (ar->as->upper[i]\n+\t\t\t  && ar->as->upper[i]->expr_type == EXPR_CONSTANT\n+\t\t\t  && mpz_cmp (val, ar->as->upper[i]->value.integer) > 0)\n+\t\t\tgfc_warning (warn, \"Array reference at %L out of bounds \"\n+\t\t\t\t     \"(%ld > %ld) in loop beginning at %L\",\n+\t\t\t\t     &ar->start[i]->where, mpz_get_si (val),\n+\t\t\t\t     mpz_get_si (ar->as->upper[i]->value.integer),\n+\t\t\t\t     &doloop_list[j].c->loc);\n+\n+\t\t      mpz_clear (val);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n+/* Function for functions checking that we do not pass a DO variable\n+   to an INTENT(OUT) or INTENT(INOUT) dummy variable.  */\n+\n+static int\n+do_intent (gfc_expr **e)\n {\n   gfc_formal_arglist *f;\n   gfc_actual_arglist *a;\n   gfc_expr *expr;\n   gfc_code *dl;\n+  do_t *lp;\n   int i;\n \n   expr = *e;\n@@ -2337,10 +2652,10 @@ do_function (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n \n   while (a && f)\n     {\n-      FOR_EACH_VEC_ELT (doloop_list, i, dl)\n+      FOR_EACH_VEC_ELT (doloop_list, i, lp)\n \t{\n \t  gfc_symbol *do_sym;\n-\n+\t  dl = lp->c;\n \t  if (dl == NULL)\n \t    break;\n \n@@ -2353,13 +2668,13 @@ do_function (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t\tgfc_error_now (\"Variable %qs at %L set to undefined value \"\n \t\t\t       \"inside loop beginning at %L as INTENT(OUT) \"\n \t\t\t       \"argument to function %qs\", do_sym->name,\n-\t\t\t       &a->expr->where, &doloop_list[i]->loc,\n+\t\t\t       &a->expr->where, &doloop_list[i].c->loc,\n \t\t\t       expr->symtree->n.sym->name);\n \t      else if (f->sym->attr.intent == INTENT_INOUT)\n \t\tgfc_error_now (\"Variable %qs at %L not definable inside loop\"\n \t\t\t       \" beginning at %L as INTENT(INOUT) argument to\"\n \t\t\t       \" function %qs\", do_sym->name,\n-\t\t\t       &a->expr->where, &doloop_list[i]->loc,\n+\t\t\t       &a->expr->where, &doloop_list[i].c->loc,\n \t\t\t       expr->symtree->n.sym->name);\n \t    }\n \t}\n@@ -4055,6 +4370,10 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \t      WALK_SUBEXPR (co->ext.iterator->step);\n \t      break;\n \n+\t    case EXEC_IF:\n+\t      if_level ++;\n+\t      break;\n+\n \t    case EXEC_WHERE:\n \t      in_where = true;\n \t      break;\n@@ -4073,6 +4392,7 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \n \t    case EXEC_SELECT:\n \t      WALK_SUBEXPR (co->expr1);\n+\t      select_level ++;\n \t      for (b = co->block; b; b = b->block)\n \t\t{\n \t\t  gfc_case *cp;\n@@ -4329,6 +4649,12 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \t  if (co->op == EXEC_DO)\n \t    doloop_level --;\n \n+\t  if (co->op == EXEC_IF)\n+\t    if_level --;\n+\n+\t  if (co->op == EXEC_SELECT)\n+\t    select_level --;\n+  \n \t  in_omp_workshare = saved_in_omp_workshare;\n \t  in_where = saved_in_where;\n \t}"}, {"sha": "63a144276fa42847fcfa400824ce199edb9b710e", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e23330102f2c2a0815c70cf0ffca18fcdfdc40/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e23330102f2c2a0815c70cf0ffca18fcdfdc40/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=15e23330102f2c2a0815c70cf0ffca18fcdfdc40", "patch": "@@ -145,8 +145,8 @@ by type.  Explanations are in the following sections.\n @xref{Error and Warning Options,,Options to request or suppress errors\n and warnings}.\n @gccoptlist{-Waliasing -Wall -Wampersand -Wargument-mismatch -Warray-bounds\n--Wc-binding-type -Wcharacter-truncation @gol\n--Wconversion -Wfunction-elimination -Wimplicit-interface @gol\n+-Wc-binding-type -Wcharacter-truncation -Wconversion @gol\n+-Wdo-subscript -Wfunction-elimination -Wimplicit-interface @gol\n -Wimplicit-procedure -Wintrinsic-shadow -Wuse-without-only -Wintrinsics-std @gol\n -Wline-truncation -Wno-align-commons -Wno-tabs -Wreal-q-constant @gol\n -Wsurprising -Wunderflow -Wunused-parameter -Wrealloc-lhs -Wrealloc-lhs-all @gol\n@@ -907,8 +907,8 @@ option does @emph{not} imply @option{-Wconversion}.\n @cindex extra warnings\n @cindex warnings, extra\n Enables some warning options for usages of language features which\n-may be problematic. This currently includes @option{-Wcompare-reals}\n-and @option{-Wunused-parameter}.\n+may be problematic. This currently includes @option{-Wcompare-reals},\n+@option{-Wunused-parameter} and @option{-Wdo-subscript}.\n \n @item -Wimplicit-interface\n @opindex @code{Wimplicit-interface}\n@@ -1080,6 +1080,21 @@ target. This option is implied by @option{-Wall}.\n Warn if a @code{DO} loop is known to execute zero times at compile\n time.  This option is implied by @option{-Wall}.\n \n+@item -Wdo-subscript\n+@opindex @code{Wdo-subscript}\n+Warn if an array subscript inside a DO loop could lead to an\n+out-of-bounds access even if the compiler can not prove that the\n+statement is actually executed, in cases like\n+@smallexample\n+  real a(3)\n+  do i=1,4\n+    if (condition(i)) then\n+      a(i) = 1.2\n+    end if\n+  end do\n+@end smallexample\n+This option is implied by @option{-Wextra}.\n+\n @item -Werror\n @opindex @code{Werror}\n @cindex warnings, to errors"}, {"sha": "37ed4a3291ccce88b2e675fcd27d0005cba13352", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e23330102f2c2a0815c70cf0ffca18fcdfdc40/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e23330102f2c2a0815c70cf0ffca18fcdfdc40/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=15e23330102f2c2a0815c70cf0ffca18fcdfdc40", "patch": "@@ -237,6 +237,10 @@ Wconversion-extra\n Fortran Var(warn_conversion_extra) Warning\n Warn about most implicit conversions.\n \n+Wdo-subscript\n+Fortran Var(warn_do_subscript) Warning LangEnabledBy(Fortran,Wextra)\n+Warn about possibly incorrect subscripts in do loops\n+\n Wextra\n Fortran Warning\n ; Documented in common"}, {"sha": "cee8e3c285cc7c67df85472c746160a252173e38", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e23330102f2c2a0815c70cf0ffca18fcdfdc40/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e23330102f2c2a0815c70cf0ffca18fcdfdc40/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=15e23330102f2c2a0815c70cf0ffca18fcdfdc40", "patch": "@@ -1,3 +1,11 @@\n+2017-09-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* gfortran.dg/do_subscript_1.f90: New test.\n+\t* gfortran.dg/do_subscript_2.f90: New test.\n+\t* gfortran.dg/gomp/associate1.f90: Add out of bounds warning.\n+\t* gfortran.dg/predcom-1.f: Adjust loop bounds.\n+\t* gfortran.dg/unconstrained_commons.f: Add out of bounds warning.\n+\n 2017-09-25  Will Schmidt  <will_schmidt@vnet.ibm.com>\n \n \t* gcc.target/powerpc/fold-vec-st-char.c: New."}, {"sha": "a4b5058d67f5b225ee927120b40f3adc914827ae", "filename": "gcc/testsuite/gfortran.dg/do_subscript_1.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e23330102f2c2a0815c70cf0ffca18fcdfdc40/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_subscript_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e23330102f2c2a0815c70cf0ffca18fcdfdc40/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_subscript_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_subscript_1.f90?ref=15e23330102f2c2a0815c70cf0ffca18fcdfdc40", "patch": "@@ -0,0 +1,57 @@\n+! { dg-do compile }\n+program main\n+  real, dimension(3) :: a\n+  a = 42.\n+  do i=-1,3,2 ! { dg-warning \"out of bounds\" }\n+     a(i) = 0  ! { dg-warning \"out of bounds \\\\(-1 < 1\\\\)\" }\n+  end do\n+  do i=4,1,-1 ! { dg-warning \"out of bounds\" }\n+     a(i) = 22 ! { dg-warning \"out of bounds \\\\(4 > 3\\\\)\" }\n+  end do\n+  do i=1,4 ! { dg-warning \"out of bounds\" }\n+     a(i) = 32 ! { dg-warning \"out of bounds \\\\(4 > 3\\\\)\" }\n+  end do\n+  do i=3,0,-1 ! { dg-warning \"out of bounds\" }\n+     a(i) = 12 ! { dg-warning \"out of bounds \\\\(0 < 1\\\\)\" }\n+  end do\n+  do i=-1,3\n+     if (i>0) a(i) = a(i) + 1 ! No warning inside if\n+  end do\n+  do i=-1,4\n+     select case(i)\n+     case(1:3)\n+        a(i) = -234  ! No warning inside select case\n+     end select\n+  end do\n+  do i=1,3 ! { dg-warning \"out of bounds\" }\n+     a(i+1) = a(i) ! { dg-warning \"out of bounds \\\\(4 > 3\\\\)\" }\n+     a(i-1) = a(i) ! { dg-warning \"out of bounds \\\\(0 < 1\\\\)\" }\n+  end do\n+  do i=3,1,-1 ! { dg-warning \"out of bounds\" }\n+     a(i) = a(i-1) ! { dg-warning \"out of bounds \\\\(0 < 1\\\\)\" }\n+     a(i) = a(i+1) ! { dg-warning \"out of bounds \\\\(4 > 3\\\\)\" }\n+  end do\n+  do i=1,2 ! { dg-warning \"out of bounds\" }\n+     a(i) = a(i*i) ! { dg-warning \"out of bounds \\\\(4 > 3\\\\)\" }\n+  end do\n+  do i=1,4,2\n+     a(i) = a(i)*2 ! No error\n+  end do\n+  do i=1,4\n+     if (i > 3) exit\n+     a(i) = 33\n+  end do\n+  do i=0,3 ! { dg-warning \"out of bounds \\\\(0 < 1\\\\)\" }\n+    a(i) = 13.  ! { dg-warning \"out of bounds \\\\(0 < 1\\\\)\" }\n+    if (i < 1) exit\n+  end do\n+  do i=0,3\n+    if (i < 1) cycle\n+    a(i) = -21.\n+  end do\n+  do i=0,3 ! { dg-warning \"out of bounds \\\\(0 < 1\\\\)\" }\n+    do j=1,2\n+       a(i) = -123 ! { dg-warning \"out of bounds \\\\(0 < 1\\\\)\" }\n+    end do\n+  end do\n+end program main"}, {"sha": "efea428c7c7144d558d7bdaa103b5e6555e66fb0", "filename": "gcc/testsuite/gfortran.dg/do_subscript_2.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e23330102f2c2a0815c70cf0ffca18fcdfdc40/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_subscript_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e23330102f2c2a0815c70cf0ffca18fcdfdc40/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_subscript_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_subscript_2.f90?ref=15e23330102f2c2a0815c70cf0ffca18fcdfdc40", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-Wdo-subscript\" }\n+program main\n+  real, dimension(3) :: a\n+  a = 42.\n+  do i=-1,3 ! { dg-warning \"out of bounds \\\\(-1 < 1\\\\)\" }\n+     select case(i)\n+     case(1:3)\n+        a(i) = -234  ! { dg-warning \"out of bounds \\\\(-1 < 1\\\\)\" }\n+     end select\n+  end do\n+  do i=1,4,2\n+     a(i) = a(i)*2 ! No warning - end value is 3\n+  end do\n+  do i=1,4  ! { dg-warning \"out of bounds \\\\(4 > 3\\\\)\" }\n+     if (i > 3) exit\n+     a(i) = 33  ! { dg-warning \"out of bounds \\\\(4 > 3\\\\)\" }\n+  end do\n+  do i=0,3  ! { dg-warning \"out of bounds \\\\(0 < 1\\\\)\" }\n+    if (i < 1) cycle\n+    a(i) = -21. ! { dg-warning \"out of bounds \\\\(0 < 1\\\\)\" }\n+  end do\n+end program main"}]}