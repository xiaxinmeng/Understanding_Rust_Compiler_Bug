{"sha": "06066f92aaea9e9b0fff53a693b300bb9aa1121a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYwNjZmOTJhYWVhOWU5YjBmZmY1M2E2OTNiMzAwYmI5YWExMTIxYQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2009-07-12T07:09:07Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2009-07-12T07:09:07Z"}, "message": "tree-parloops.c (loop_parallel_p): Call vect_is_simple_reduction with additional argument.\n\n\n\t* tree-parloops.c (loop_parallel_p): Call vect_is_simple_reduction\n\twith additional argument.\n\t* tree-vectorizer.h (enum vect_def_type): Add \n\tvect_double_reduction_def.\n\t(vect_is_simple_reduction): Add argument.\n\t* tree-vect-loop.c (vect_determine_vectorization_factor): Fix \n\tindentation.\n\t(vect_analyze_scalar_cycles_1): Detect double reduction. Call\n\tvect_is_simple_reduction with additional argument.\n\t(vect_analyze_loop_operations): Handle exit phi nodes in case of\n\tdouble reduction.\n\t(reduction_code_for_scalar_code): Handle additional codes by\n\treturning ERROR_MARK for them. Fix comment and indentation.\n\t(vect_is_simple_reduction): Fix comment, add argument to specify\n\tdouble reduction. Detect double reduction.\n\t(get_initial_def_for_induction): Fix indentation.\n\t(get_initial_def_for_reduction): Fix comment and indentation.\n\tHandle double reduction. Create initial definitions that do not\n\trequire adjustment if ADJUSTMENT_DEF is NULL. Handle additional cases.\n\t(vect_create_epilog_for_reduction): Fix comment, add argument to\n\thandle double reduction. Use PLUS_EXPR in case of MINUS_EXPR in\n\tepilogue result extraction. Create double reduction phi node and\n\treplace relevant uses.\n\t(vectorizable_reduction): Call vect_is_simple_reduction with\n\tadditional argument. Fix indentation. Update epilogue code treatment\n\taccording to the changes in reduction_code_for_scalar_code. Check \n\tfor double reduction. Call vect_create_epilog_for_reduction with\n\tadditional argument.\n\t* tree-vect-stmts.c (process_use): Handle double reduction, update\n\tdocumentation.\n\t(vect_mark_stmts_to_be_vectorized): Handle double reduction.\n\t(vect_get_vec_def_for_operand): Likewise.\n\nFrom-SVN: r149526", "tree": {"sha": "7547f479237ee79f26fd81c529e65dfa6d42573b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7547f479237ee79f26fd81c529e65dfa6d42573b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06066f92aaea9e9b0fff53a693b300bb9aa1121a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06066f92aaea9e9b0fff53a693b300bb9aa1121a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06066f92aaea9e9b0fff53a693b300bb9aa1121a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06066f92aaea9e9b0fff53a693b300bb9aa1121a/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b20231fe2437d57d4b97aba62a0c28a68c9719dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b20231fe2437d57d4b97aba62a0c28a68c9719dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b20231fe2437d57d4b97aba62a0c28a68c9719dd"}], "stats": {"total": 1043, "additions": 893, "deletions": 150}, "files": [{"sha": "edeb0492b36ab990141f4e2c1f2d8087d0675c7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06066f92aaea9e9b0fff53a693b300bb9aa1121a", "patch": "@@ -1,3 +1,38 @@\n+2009-07-12  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-parloops.c (loop_parallel_p): Call vect_is_simple_reduction\n+\twith additional argument.\n+\t* tree-vectorizer.h (enum vect_def_type): Add \n+\tvect_double_reduction_def.\n+\t(vect_is_simple_reduction): Add argument.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor): Fix \n+\tindentation.\n+\t(vect_analyze_scalar_cycles_1): Detect double reduction. Call\n+\tvect_is_simple_reduction with additional argument.\n+\t(vect_analyze_loop_operations): Handle exit phi nodes in case of\n+\tdouble reduction.\n+\t(reduction_code_for_scalar_code): Handle additional codes by\n+\treturning ERROR_MARK for them. Fix comment and indentation.\n+\t(vect_is_simple_reduction): Fix comment, add argument to specify\n+\tdouble reduction. Detect double reduction.\n+\t(get_initial_def_for_induction): Fix indentation.\n+\t(get_initial_def_for_reduction): Fix comment and indentation.\n+\tHandle double reduction. Create initial definitions that do not\n+\trequire adjustment if ADJUSTMENT_DEF is NULL. Handle additional cases.\n+\t(vect_create_epilog_for_reduction): Fix comment, add argument to\n+\thandle double reduction. Use PLUS_EXPR in case of MINUS_EXPR in\n+\tepilogue result extraction. Create double reduction phi node and\n+\treplace relevant uses.\n+\t(vectorizable_reduction): Call vect_is_simple_reduction with\n+\tadditional argument. Fix indentation. Update epilogue code treatment\n+\taccording to the changes in reduction_code_for_scalar_code. Check \n+\tfor double reduction. Call vect_create_epilog_for_reduction with\n+\tadditional argument.\n+\t* tree-vect-stmts.c (process_use): Handle double reduction, update\n+\tdocumentation.\n+\t(vect_mark_stmts_to_be_vectorized): Handle double reduction.\n+\t(vect_get_vec_def_for_operand): Likewise.\n+\n 2009-07-12  Danny Smith  <dansmister@gmail.com>\n \n \t* config/i386/winnt.c (i386_pe_determine_dllexport_p): Don't"}, {"sha": "7df599ed587287c49bf3957f6d30a9e5e0f2639a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=06066f92aaea9e9b0fff53a693b300bb9aa1121a", "patch": "@@ -1,3 +1,11 @@\n+2009-07-12  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/no-scevccp-outer-2.c: Expect to vectorize.\n+\t* gcc.dg/vect/vect-double-reduc-1.c, gcc.dg/vect/vect-double-reduc-2.c,\n+\tgcc.dg/vect/vect-double-reduc-3.c, gcc.dg/vect/vect-double-reduc-4.c,\n+\tgcc.dg/vect/vect-double-reduc-5.c, gcc.dg/vect/vect-double-reduc-6.c,\n+\tgcc.dg/vect/vect-double-reduc-7.c: New tests.\n+\n 2009-07-12  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* gfortran.dg/f2003_io_4.f03, gfortran.dg/read_size_noadvance.f90,"}, {"sha": "13b37883c2e9f489d78e40de319ab29dc84c0b9a", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-2.c?ref=06066f92aaea9e9b0fff53a693b300bb9aa1121a", "patch": "@@ -1,4 +1,6 @@\n /* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n #define N 40\n \n int\n@@ -14,5 +16,5 @@ foo (){\n   return diff;\n }\n \n-/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\"  } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e3358428a48b01434e0a08a4ac3b3e6ad8bec728", "filename": "gcc/testsuite/gcc.dg/vect/vect-double-reduc-1.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-1.c?ref=06066f92aaea9e9b0fff53a693b300bb9aa1121a", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-require-effective-target vect_int_mult } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define K 32\n+\n+int in[2*K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int coeff[K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int out[K];\n+int check_result[K] = {642816,660736,678656,696576,714496,732416,750336,768256,786176,804096,822016,839936,857856,875776,893696,911616,929536,947456,965376,983296,1001216,1019136,1037056,1054976,1072896,1090816,1108736,1126656,1144576,1162496,1180416,1198336};\n+\n+__attribute__ ((noinline)) void \n+foo ()\n+{\n+  int sum = 0, i, j, k;\n+\n+  for (k = 0; k < K; k++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < K; j++) \n+        for (i = 0; i < K; i++) \n+          sum += in[i+k][j] * coeff[i][j];\n+ \n+      out[k] = sum;\n+    }\n+}\n+\n+int main ()\n+{\n+  int i, j, k;\n+\n+  check_vect ();\n+\n+  for  (j = 0; j < K; j++)\n+    {\n+      for (i = 0; i < 2*K; i++)\n+        in[i][j] = i+j;\n+\n+      for (i = 0; i < K; i++)\n+        coeff[i][j] = i+2;\n+    }\n+\n+  foo();\n+\n+  for (k = 0; k < K; k++)\n+    if (out[k] != check_result[k])\n+      abort ();\n+\n+  return 0;\n+}\n+        \n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+      "}, {"sha": "be469be02de6d77bde02f06a7b7cb5df2f5ac708", "filename": "gcc/testsuite/gcc.dg/vect/vect-double-reduc-2.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-2.c?ref=06066f92aaea9e9b0fff53a693b300bb9aa1121a", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-require-effective-target vect_int_mult } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define K 32\n+\n+int in[2*K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int coeff[K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int out[K];\n+int check_result[K] = {357184,339264,321344,303424,285504,267584,249664,231744,213824,195904,177984,160064,142144,124224,106304,88384,70464,52544,34624,16704,-1216,-19136,-37056,-54976,-72896,-90816,-108736,-126656,-144576,-162496,-180416,-198336};\n+\n+__attribute__ ((noinline)) void \n+foo ()\n+{\n+  int res = 0, i, j, k;\n+\n+  for (k = 0; k < K; k++)\n+    {\n+      res = 1000000;\n+      for (j = 0; j < K; j++) \n+        for (i = 0; i < K; i++) \n+          res -= in[i+k][j] * coeff[i][j];\n+ \n+      out[k] = res;\n+    }\n+}\n+\n+int main ()\n+{\n+  int i, j, k;\n+\n+  check_vect ();\n+\n+  for  (j = 0; j < K; j++)\n+    {\n+      for (i = 0; i < 2*K; i++)\n+        in[i][j] = i+j;\n+\n+      for (i = 0; i < K; i++)\n+        coeff[i][j] = i+2;\n+    }\n+\n+  foo();\n+\n+  for (k = 0; k < K; k++)\n+    if (out[k] != check_result[k])\n+      abort ();\n+\n+  return 0;\n+}\n+        \n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+      "}, {"sha": "87b5a04099e49b74001b18e4fd4615fc62f3a49c", "filename": "gcc/testsuite/gcc.dg/vect/vect-double-reduc-3.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-3.c?ref=06066f92aaea9e9b0fff53a693b300bb9aa1121a", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define K 32\n+\n+int in[2*K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int coeff[K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int out_max[K], out_min[K];\n+int check_max[K] = {62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93};\n+int check_min[K] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};\n+\n+__attribute__ ((noinline)) void \n+foo (int x, int y)\n+{\n+  int max, min, i, j, k;\n+\n+  for (k = 0; k < K; k++)\n+    {\n+      max = x;\n+      min = y;\n+      for (j = 0; j < K; j++) \n+        for (i = 0; i < K; i++)\n+          {\n+            max = max < in[i+k][j] ? in[i+k][j] : max; \n+            min = min > in[i+k][j] ? in[i+k][j] : min; \n+          }\n+      out_max[k] = max;\n+      out_min[k] = min;\n+    }\n+}\n+\n+int main ()\n+{\n+  int i, j, k;\n+\n+  check_vect ();\n+\n+  for  (j = 0; j < K; j++)\n+    {\n+      for (i = 0; i < 2*K; i++)\n+        in[i][j] = i+j;\n+\n+      for (i = 0; i < K; i++)\n+        coeff[i][j] = i+2;\n+    }\n+\n+  foo(0, 0);\n+\n+  for (k = 0; k < K; k++)\n+    if (out_max[k] != check_max[k] || out_min[k] != 0)\n+      abort ();\n+\n+  foo(100, 45);\n+\n+  for (k = 0; k < K; k++)\n+    if (out_min[k] != check_min[k] || out_max[k] != 100)\n+      abort ();\n+\n+  return 0;\n+}\n+        \n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail vect_no_int_max } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+      "}, {"sha": "90e0da70a20b9a79987987335cf2a046defb3291", "filename": "gcc/testsuite/gcc.dg/vect/vect-double-reduc-4.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-4.c?ref=06066f92aaea9e9b0fff53a693b300bb9aa1121a", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-require-effective-target vect_int_mult } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define K 32\n+\n+int in[2*K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int coeff[K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int out[K];\n+int check_result[K] = {652816,670736,688656,706576,724496,742416,760336,778256,796176,814096,832016,849936,867856,885776,903696,921616,939536,957456,975376,993296,1011216,1029136,1047056,1064976,1082896,1100816,1118736,1136656,1154576,1172496,1190416,1208336};\n+\n+__attribute__ ((noinline)) void \n+foo ()\n+{\n+  int sum = 0, i, j, k;\n+\n+  for (k = 0; k < K; k++)\n+    {\n+      sum = 10000;\n+      for (j = 0; j < K; j++) \n+        for (i = 0; i < K; i++) \n+          sum += in[i+k][j] * coeff[i][j];\n+ \n+      out[k] = sum;\n+    }\n+}\n+\n+int main ()\n+{\n+  int i, j, k;\n+\n+  check_vect ();\n+\n+  for  (j = 0; j < K; j++)\n+    {\n+      for (i = 0; i < 2*K; i++)\n+        in[i][j] = i+j;\n+\n+      for (i = 0; i < K; i++)\n+        coeff[i][j] = i+2;\n+    }\n+\n+  foo();\n+\n+  for (k = 0; k < K; k++)\n+    if (out[k] != check_result[k])\n+      abort ();\n+\n+  return 0;\n+}\n+        \n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+      "}, {"sha": "f624d86502f853c8ae1def899e5521303a14281a", "filename": "gcc/testsuite/gcc.dg/vect/vect-double-reduc-5.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-5.c?ref=06066f92aaea9e9b0fff53a693b300bb9aa1121a", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int_mult } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define K 32\n+\n+signed short in[2*K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+signed short coeff[K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int out[K];\n+int check_result[K] = {642816,660736,678656,696576,714496,732416,750336,768256,786176,804096,822016,839936,857856,875776,893696,911616,929536,947456,965376,983296,1001216,1019136,1037056,1054976,1072896,1090816,1108736,1126656,1144576,1162496,1180416,1198336};\n+\n+__attribute__ ((noinline)) void \n+foo ()\n+{\n+  int sum = 0, i, j, k;\n+\n+  for (k = 0; k < K; k++)\n+    {\n+      sum = 0;\n+      for (j = 0; j < K; j++) \n+        for (i = 0; i < K; i++) \n+          sum += in[i+k][j] * coeff[i][j];\n+ \n+      out[k] = sum;\n+    }\n+}\n+\n+int main ()\n+{\n+  int i, j, k;\n+\n+  check_vect ();\n+\n+  for  (j = 0; j < K; j++)\n+    {\n+      for (i = 0; i < 2*K; i++)\n+        in[i][j] = i+j;\n+\n+      for (i = 0; i < K; i++)\n+        coeff[i][j] = i+2;\n+    }\n+\n+  foo();\n+\n+  for (k = 0; k < K; k++)\n+    if (out[k] != check_result[k])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* Vectorization of loops with multiple types and double reduction is not \n+   supported yet.  */       \n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+      "}, {"sha": "f52b32bfad9c5be43462d0d0676338238dd10242", "filename": "gcc/testsuite/gcc.dg/vect/vect-double-reduc-6.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-6.c?ref=06066f92aaea9e9b0fff53a693b300bb9aa1121a", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int_mult } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define K 4 \n+\n+int in[2*K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int out[K];\n+int check_result[K] = {0,16,256,4096};\n+\n+__attribute__ ((noinline)) void \n+foo ()\n+{\n+  int sum;\n+  int i, j, k;\n+\n+  for (k = 0; k < K; k++)\n+    {\n+      sum = 1;\n+      for (j = 0; j < K; j++) \n+        for (i = 0; i < K; i++)\n+          sum *= in[i+k][j];\n+      out[k] = sum;\n+    }\n+}\n+\n+int main ()\n+{\n+  int i, j, k;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < 2*K; i++)\n+    for (j = 0; j < K; j++)\n+      in[i][j] = (i+2)/3;\n+\n+  foo();\n+\n+  for (k = 0; k < K; k++)\n+    if (out[k] != check_result[k])\n+      abort ();\n+\n+  return 0;\n+}\n+        \n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+      "}, {"sha": "9e7ced7f927975311acde63ed537d26ec9ba33de", "filename": "gcc/testsuite/gcc.dg/vect/vect-double-reduc-7.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-double-reduc-7.c?ref=06066f92aaea9e9b0fff53a693b300bb9aa1121a", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define K 32\n+\n+int in[2*K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int out[K];\n+int check_result[K] = {63,63,191,191,127,127,191,191,127,127,191,191,127,127,191,191,127,127,191,191,127,127,191,191,127,127,191,191,127,127,191,191};\n+\n+__attribute__ ((noinline)) void \n+foo ()\n+{\n+  int res_or, res_and, res_xor, i, j, k;\n+\n+  for (k = 0; k < K; k++)\n+    {\n+      res_or = 0;\n+      for (j = 0; j < K; j++) \n+        for (i = 0; i < K; i++) \n+          res_or = res_or | in[i+k][j];\n+ \n+      res_and = 1;\n+      for (j = 0; j < K; j++)\n+        for (i = 0; i < K; i++)\n+          res_and = res_and & in[i+k][j];\n+\n+      res_xor = 0;\n+      for (j = 0; j < K; j++)\n+        for (i = 0; i < K; i++)\n+          res_xor = res_xor ^ in[i+k][j];\n+\n+      out[k] = res_or + res_and + res_xor;\n+    }\n+}\n+\n+int main ()\n+{\n+  int i, j, k;\n+\n+  check_vect ();\n+\n+  for  (j = 0; j < K; j++)\n+    {\n+      for (i = 0; i < 2*K; i++)\n+        in[i][j] = i+j;\n+\n+      for (i = 0; i < K; i++)\n+        out[i] = i+j;\n+    }\n+\n+  foo();\n+\n+  for (k = 0; k < K; k++)\n+    if (out[k] != check_result[k])\n+      abort ();\n+\n+  return 0;\n+}\n+        \n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 3 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+      "}, {"sha": "28c96a26f598ddc24827587a44c55dfffb21b1c3", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=06066f92aaea9e9b0fff53a693b300bb9aa1121a", "patch": "@@ -284,13 +284,15 @@ loop_parallel_p (struct loop *loop, htab_t reduction_list,\n     {\n       gimple phi = gsi_stmt (gsi);\n       gimple reduc_stmt = NULL;\n+      bool dummy;\n \n       /* ??? TODO: Change this into a generic function that \n          recognizes reductions.  */\n       if (!is_gimple_reg (PHI_RESULT (phi)))\n \tcontinue;\n       if (simple_loop_info)\n-\treduc_stmt = vect_is_simple_reduction (simple_loop_info, phi, true);\n+\treduc_stmt = vect_is_simple_reduction (simple_loop_info, phi, true, \n+                                               &dummy);\n \n       /*  Create a reduction_info struct, initialize it and insert it to \n          the reduction list.  */"}, {"sha": "c96fb04a814ce2a2df443fa95d50c30ef769f15b", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 381, "deletions": 112, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=06066f92aaea9e9b0fff53a693b300bb9aa1121a", "patch": "@@ -291,8 +291,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t    }\n \t  else\n \t    {\n-\n-\t      gcc_assert (! STMT_VINFO_DATA_REF (stmt_info)\n+\t      gcc_assert (!STMT_VINFO_DATA_REF (stmt_info)\n \t\t\t  && !is_pattern_stmt_p (stmt_info));\n \n \t      scalar_type = vect_get_smallest_scalar_type (stmt, &dummy, \n@@ -410,6 +409,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n   tree dumy;\n   VEC(gimple,heap) *worklist = VEC_alloc (gimple, heap, 64);\n   gimple_stmt_iterator gsi;\n+  bool double_reduc;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_scalar_cycles ===\");\n@@ -477,26 +477,39 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n       gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_unknown_def_type);\n \n       nested_cycle = (loop != LOOP_VINFO_LOOP (loop_vinfo));\n-      reduc_stmt = vect_is_simple_reduction (loop_vinfo, phi, !nested_cycle);\n+      reduc_stmt = vect_is_simple_reduction (loop_vinfo, phi, !nested_cycle, \n+                                             &double_reduc);\n       if (reduc_stmt)\n         {\n-          if (nested_cycle)\n+          if (double_reduc)\n             {\n               if (vect_print_dump_info (REPORT_DETAILS))\n-                fprintf (vect_dump, \"Detected vectorizable nested cycle.\");\n+                fprintf (vect_dump, \"Detected double reduction.\");\n \n-              STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_nested_cycle;\n+              STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_double_reduction_def;\n               STMT_VINFO_DEF_TYPE (vinfo_for_stmt (reduc_stmt)) =\n-                                                        vect_nested_cycle;\n+                                                    vect_double_reduction_def;\n             }\n-          else\n+          else \n             {\n-              if (vect_print_dump_info (REPORT_DETAILS))\n-                fprintf (vect_dump, \"Detected reduction.\");\n+              if (nested_cycle)\n+                {\n+                  if (vect_print_dump_info (REPORT_DETAILS))\n+                    fprintf (vect_dump, \"Detected vectorizable nested cycle.\");\n \n-              STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_reduction_def;\n-              STMT_VINFO_DEF_TYPE (vinfo_for_stmt (reduc_stmt)) =\n-                                                        vect_reduction_def;\n+                  STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_nested_cycle;\n+                  STMT_VINFO_DEF_TYPE (vinfo_for_stmt (reduc_stmt)) =\n+                                                             vect_nested_cycle;\n+                }\n+              else\n+                {\n+                  if (vect_print_dump_info (REPORT_DETAILS))\n+                    fprintf (vect_dump, \"Detected reduction.\");\n+\n+                  STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_reduction_def;\n+                  STMT_VINFO_DEF_TYPE (vinfo_for_stmt (reduc_stmt)) =\n+                                                           vect_reduction_def;\n+                }\n             }\n         }\n       else\n@@ -1111,10 +1124,13 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n               /* inner-loop loop-closed exit phi in outer-loop vectorization\n                  (i.e. a phi in the tail of the outer-loop).\n                  FORNOW: we currently don't support the case that these phis\n-                 are not used in the outerloop, cause this case requires\n-                 to actually do something here.  */\n-              if (!STMT_VINFO_RELEVANT_P (stmt_info)\n-                  || STMT_VINFO_LIVE_P (stmt_info))\n+                 are not used in the outerloop (unless it is double reduction,\n+                 i.e., this phi is vect_reduction_def), cause this case \n+                 requires to actually do something here.  */\n+              if ((!STMT_VINFO_RELEVANT_P (stmt_info)\n+                   || STMT_VINFO_LIVE_P (stmt_info))\n+                  && STMT_VINFO_DEF_TYPE (stmt_info) \n+                     != vect_double_reduction_def)\n                 {\n                   if (vect_print_dump_info (REPORT_DETAILS))\n                     fprintf (vect_dump,\n@@ -1466,31 +1482,40 @@ vect_analyze_loop (struct loop *loop)\n    Output:\n    REDUC_CODE - the corresponding tree-code to be used to reduce the\n       vector of partial results into a single scalar result (which\n-      will also reside in a vector).\n+      will also reside in a vector) or ERROR_MARK if the operation is\n+      a supported reduction operation, but does not have such tree-code.\n \n-   Return TRUE if a corresponding REDUC_CODE was found, FALSE otherwise.  */\n+   Return FALSE if CODE currently cannot be vectorized as reduction.  */\n \n static bool\n reduction_code_for_scalar_code (enum tree_code code,\n                                 enum tree_code *reduc_code)\n {\n   switch (code)\n-  {\n-  case MAX_EXPR:\n-    *reduc_code = REDUC_MAX_EXPR;\n-    return true;\n-\n-  case MIN_EXPR:\n-    *reduc_code = REDUC_MIN_EXPR;\n-    return true;\n-\n-  case PLUS_EXPR:\n-    *reduc_code = REDUC_PLUS_EXPR;\n-    return true;\n-\n-  default:\n-    return false;\n-  }\n+    {\n+      case MAX_EXPR:\n+        *reduc_code = REDUC_MAX_EXPR;\n+        return true;\n+\n+      case MIN_EXPR:\n+        *reduc_code = REDUC_MIN_EXPR;\n+        return true;\n+\n+      case PLUS_EXPR:\n+        *reduc_code = REDUC_PLUS_EXPR;\n+        return true;\n+\n+      case MULT_EXPR:\n+      case MINUS_EXPR:\n+      case BIT_IOR_EXPR:\n+      case BIT_XOR_EXPR:\n+      case BIT_AND_EXPR:\n+        *reduc_code = ERROR_MARK;\n+        return true;\n+\n+      default:\n+       return false;\n+    }\n }\n \n \n@@ -1507,7 +1532,7 @@ report_vect_op (gimple stmt, const char *msg)\n \n /* Function vect_is_simple_reduction\n \n-   Detect a cross-iteration def-use cycle that represents a simple\n+   (1) Detect a cross-iteration def-use cycle that represents a simple\n    reduction computation. We look for the following pattern:\n \n    loop_header:\n@@ -1524,12 +1549,20 @@ report_vect_op (gimple stmt, const char *msg)\n    Condition 1 is tested here.\n    Conditions 2,3 are tested in vect_mark_stmts_to_be_vectorized.  \n \n-   Also detect a cross-iteration def-use cycle in nested loops, i.e., nested\n-   cycles, if CHECK_REDUCTION is false.  */\n+   (2) Detect a cross-iteration def-use cycle in nested loops, i.e., \n+   nested cycles, if CHECK_REDUCTION is false.  \n+\n+   (3) Detect cycles of phi nodes in outer-loop vectorization, i.e., double\n+   reductions:\n+\n+     a1 = phi < a0, a2 >\n+     inner loop (def of a3)\n+     a2 = phi < a3 >    \n+*/\n \n gimple\n vect_is_simple_reduction (loop_vec_info loop_info, gimple phi, \n-                          bool check_reduction)\n+                          bool check_reduction, bool *double_reduc)\n {\n   struct loop *loop = (gimple_bb (phi))->loop_father;\n   struct loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n@@ -1543,6 +1576,9 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi,\n   tree name;\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n+  bool phi_def;\n+\n+  *double_reduc = false;\n \n   /* If CHECK_REDUCTION is true, we assume inner-most loop vectorization,\n      otherwise, we assume outer loop vectorization.  */\n@@ -1584,14 +1620,24 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi,\n       return NULL;\n     }\n \n-  if (!is_gimple_assign (def_stmt))\n+  if (!is_gimple_assign (def_stmt) && gimple_code (def_stmt) != GIMPLE_PHI)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         print_gimple_stmt (vect_dump, def_stmt, 0, TDF_SLIM);\n       return NULL;\n     }\n \n-  name = gimple_assign_lhs (def_stmt);\n+  if (is_gimple_assign (def_stmt))\n+    {\n+      name = gimple_assign_lhs (def_stmt);\n+      phi_def = false;\n+    }\n+  else\n+    {\n+      name = PHI_RESULT (def_stmt);\n+      phi_def = true;\n+    }\n+\n   nloop_uses = 0;\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, name)\n     {\n@@ -1608,6 +1654,37 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi,\n \t}\n     }\n \n+  /* If DEF_STMT is a phi node itself, we expect it to have a single argument\n+     defined in the inner loop.  */\n+  if (phi_def)\n+    {\n+      op1 = PHI_ARG_DEF (def_stmt, 0);\n+\n+      if (gimple_phi_num_args (def_stmt) != 1\n+          || TREE_CODE (op1) != SSA_NAME)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            fprintf (vect_dump, \"unsupported phi node definition.\");\n+\n+          return NULL;\n+        }\n+\n+      def1 = SSA_NAME_DEF_STMT (op1); \n+      if (flow_bb_inside_loop_p (loop, gimple_bb (def_stmt)) \n+          && loop->inner\n+          && flow_bb_inside_loop_p (loop->inner, gimple_bb (def1))\n+          && is_gimple_assign (def1))\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            report_vect_op (def_stmt, \"detected double reduction: \");\n+ \n+          *double_reduc = true;\n+          return def_stmt;\n+        }\n+\n+      return NULL;\n+    }\n+\n   code = gimple_assign_rhs_code (def_stmt);\n \n   if (check_reduction \n@@ -1697,7 +1774,6 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi,\n       return NULL;\n     }\n \n-\n   /* Check that one def is the reduction def, defined by PHI,\n      the other def is either defined in the loop (\"vect_internal_def\"),\n      or it's an induction (defined by a loop-header phi-node).  */\n@@ -2296,7 +2372,7 @@ get_initial_def_for_induction (gimple iv_phi)\n   access_fn = analyze_scalar_evolution (iv_loop, PHI_RESULT (iv_phi));\n   gcc_assert (access_fn);\n   ok = vect_is_simple_iv_evolution (iv_loop->num, access_fn,\n-                                  &init_expr, &step_expr);\n+                                    &init_expr, &step_expr);\n   gcc_assert (ok);\n   pe = loop_preheader_edge (iv_loop);\n \n@@ -2306,7 +2382,8 @@ get_initial_def_for_induction (gimple iv_phi)\n       /* iv_loop is nested in the loop to be vectorized.  init_expr had already\n \t been created during vectorization of previous stmts; We obtain it from\n \t the STMT_VINFO_VEC_STMT of the defining stmt. */\n-      tree iv_def = PHI_ARG_DEF_FROM_EDGE (iv_phi, loop_preheader_edge (iv_loop));\n+      tree iv_def = PHI_ARG_DEF_FROM_EDGE (iv_phi, \n+                                           loop_preheader_edge (iv_loop));\n       vec_init = vect_get_vec_def_for_operand (iv_def, iv_phi, NULL);\n     }\n   else\n@@ -2507,18 +2584,16 @@ get_initial_def_for_induction (gimple iv_phi)\n         vector of partial results.\n \n    Option1 (adjust in epilog): Initialize the vector as follows:\n-     add:         [0,0,...,0,0]\n-     mult:        [1,1,...,1,1]\n-     min/max:     [init_val,init_val,..,init_val,init_val]\n-     bit and/or:  [init_val,init_val,..,init_val,init_val]\n+     add/bit or/xor: [0,0,...,0,0]\n+     mult/bit and:   [1,1,...,1,1]\n+     min/max:        [init_val,init_val,..,init_val,init_val]\n    and when necessary (e.g. add/mult case) let the caller know\n    that it needs to adjust the result by init_val.\n \n    Option2: Initialize the vector as follows:\n-     add:         [0,0,...,0,init_val]\n-     mult:        [1,1,...,1,init_val]\n-     min/max:     [init_val,init_val,...,init_val]\n-     bit and/or:  [init_val,init_val,...,init_val]\n+     add/bit or/xor: [init_val,0,0,...,0]\n+     mult/bit and:   [init_val,1,1,...,1]\n+     min/max:        [init_val,init_val,...,init_val]\n    and no adjustments are needed.\n \n    For example, for the following code:\n@@ -2533,11 +2608,14 @@ get_initial_def_for_induction (gimple iv_phi)\n    the result at the end by 'init_val'.\n \n    FORNOW, we are using the 'adjust in epilog' scheme, because this way the\n-   initialization vector is simpler (same element in all entries).\n+   initialization vector is simpler (same element in all entries), if\n+   ADJUSTMENT_DEF is not NULL, and Option2 otherwise.\n+   \n    A cost model should help decide between these two schemes.  */\n \n tree\n-get_initial_def_for_reduction (gimple stmt, tree init_val, tree *adjustment_def)\n+get_initial_def_for_reduction (gimple stmt, tree init_val, \n+                               tree *adjustment_def)\n {\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n@@ -2551,47 +2629,118 @@ get_initial_def_for_reduction (gimple stmt, tree init_val, tree *adjustment_def)\n   tree t = NULL_TREE;\n   int i;\n   bool nested_in_vect_loop = false; \n+  tree init_value;\n+  REAL_VALUE_TYPE real_init_val = dconst0;\n+  int int_init_val = 0;\n \n   gcc_assert (vectype);\n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n   gcc_assert (POINTER_TYPE_P (scalar_type) || INTEGRAL_TYPE_P (scalar_type)\n \t      || SCALAR_FLOAT_TYPE_P (scalar_type));\n+\n   if (nested_in_vect_loop_p (loop, stmt))\n     nested_in_vect_loop = true;\n   else\n     gcc_assert (loop == (gimple_bb (stmt))->loop_father);\n \n-  switch (code)\n-  {\n-  case WIDEN_SUM_EXPR:\n-  case DOT_PROD_EXPR:\n-  case PLUS_EXPR:\n-  case MINUS_EXPR:\n-    if (nested_in_vect_loop)\n-      *adjustment_def = vect_get_vec_def_for_operand (init_val, stmt, NULL);\n-    else\n-      *adjustment_def = init_val;\n-    /* Create a vector of zeros for init_def.  */\n-    if (SCALAR_FLOAT_TYPE_P (scalar_type))\n-      def_for_init = build_real (scalar_type, dconst0);\n-    else\n-      def_for_init = build_int_cst (scalar_type, 0);\n-      \n-    for (i = nunits - 1; i >= 0; --i)\n-      t = tree_cons (NULL_TREE, def_for_init, t);\n-    init_def = build_vector (vectype, t);\n-    break;\n+  /* In case of double reduction we only create a vector variable to be put\n+     in the reduction phi node. The actual statement creation is done in\n+     vect_create_epilog_for_reduction.  */\n+  if (TREE_CODE (init_val) == SSA_NAME\n+      && vinfo_for_stmt (SSA_NAME_DEF_STMT (init_val)) \n+      && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (SSA_NAME_DEF_STMT (init_val))) \n+          == vect_double_reduction_def)\n+    {\n+      *adjustment_def = NULL;\n+      return vect_create_destination_var (init_val, vectype);\n+    }\n \n-  case MIN_EXPR:\n-  case MAX_EXPR:\n-    *adjustment_def = NULL_TREE;\n-    init_def = vect_get_vec_def_for_operand (init_val, stmt, NULL);\n-    break;\n+  if (TREE_CONSTANT (init_val))\n+    {\n+      if (SCALAR_FLOAT_TYPE_P (scalar_type))\n+        init_value = build_real (scalar_type, TREE_REAL_CST (init_val));\n+      else\n+        init_value = build_int_cst (scalar_type, TREE_INT_CST_LOW (init_val));\n+    }\n+  else\n+    init_value = init_val;\n \n-  default:\n-    gcc_unreachable ();\n-  }\n+  switch (code)\n+    {\n+      case WIDEN_SUM_EXPR:\n+      case DOT_PROD_EXPR:\n+      case PLUS_EXPR:\n+      case MINUS_EXPR:\n+      case BIT_IOR_EXPR:\n+      case BIT_XOR_EXPR:\n+      case MULT_EXPR:\n+      case BIT_AND_EXPR:\n+        /* ADJUSMENT_DEF is NULL when called from \n+           vect_create_epilog_for_reduction to vectorize double reduction.  */\n+        if (adjustment_def)\n+          {\n+            if (nested_in_vect_loop)\n+              *adjustment_def = vect_get_vec_def_for_operand (init_val, stmt, \n+                                                              NULL);\n+            else\n+              *adjustment_def = init_val;\n+          }\n+\n+        if (code == MULT_EXPR || code == BIT_AND_EXPR)\n+          {\n+            real_init_val = dconst1;\n+            int_init_val = 1;\n+          }\n+\n+        if (SCALAR_FLOAT_TYPE_P (scalar_type))\n+          def_for_init = build_real (scalar_type, real_init_val);\n+        else\n+          def_for_init = build_int_cst (scalar_type, int_init_val);\n+\n+        /* Create a vector of '0' or '1' except the first element.  */ \n+        for (i = nunits - 2; i >= 0; --i)\n+          t = tree_cons (NULL_TREE, def_for_init, t);\n+\n+        /* Option1: the first element is '0' or '1' as well.  */\n+        if (adjustment_def)\n+          {\n+            t = tree_cons (NULL_TREE, def_for_init, t);\n+            init_def = build_vector (vectype, t);\n+            break;\n+          }\n+\n+        /* Option2: the first element is INIT_VAL.  */\n+        t = tree_cons (NULL_TREE, init_value, t);\n+        if (TREE_CONSTANT (init_val))\n+          init_def = build_vector (vectype, t);\n+        else\n+          init_def = build_constructor_from_list (vectype, t);\n+\n+        break;\n+\n+      case MIN_EXPR:\n+      case MAX_EXPR:\n+        if (adjustment_def)\n+          {\n+            *adjustment_def = NULL_TREE;\n+            init_def = vect_get_vec_def_for_operand (init_val, stmt, NULL);\n+            break;\n+          }\n+\n+        for (i = nunits - 1; i >= 0; --i)\n+          t = tree_cons (NULL_TREE, init_value, t);\n+\n+        if (TREE_CONSTANT (init_val))\n+          init_def = build_vector (vectype, t);\n+        else\n+          init_def = build_constructor_from_list (vectype, t);\n+\n+        break;\n+\n+      default:\n+        gcc_unreachable ();\n+    }\n \n   return init_def;\n }\n@@ -2613,6 +2762,7 @@ get_initial_def_for_reduction (gimple stmt, tree init_val, tree *adjustment_def)\n    REDUCTION_PHI is the phi-node that carries the reduction computation.\n    REDUC_INDEX is the index of the operand in the right hand side of the \n      statement that is defined by REDUCTION_PHI.\n+   DOUBLE_REDUC is TRUE if double reduction phi nodes should be handled.\n \n    This function:\n    1. Creates the reduction def-use cycle: sets the arguments for \n@@ -2657,14 +2807,15 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n \t\t\t\t  int ncopies,\n \t\t\t\t  enum tree_code reduc_code,\n \t\t\t\t  gimple reduction_phi,\n-                                  int reduc_index)\n+                                  int reduc_index, \n+                                  bool double_reduc)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   stmt_vec_info prev_phi_info;\n   tree vectype;\n   enum machine_mode mode;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo), *outer_loop = NULL;\n   basic_block exit_bb;\n   tree scalar_dest;\n   tree scalar_type;\n@@ -2694,6 +2845,7 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n   \n   if (nested_in_vect_loop_p (loop, stmt))\n     {\n+      outer_loop = loop;\n       loop = loop->inner;\n       nested_in_vect_loop = true;\n     }\n@@ -2726,7 +2878,7 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n      the scalar def before the loop, that defines the initial value\n      of the reduction variable.  */\n   vec_initial_def = vect_get_vec_def_for_operand (reduction_op, stmt,\n-\t\t\t\t\t\t  &adjustment_def);\n+\t\t\t\t\t          &adjustment_def);\n \n   phi = reduction_phi;\n   def = vect_def;\n@@ -2744,8 +2896,8 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n \t{\n \t  fprintf (vect_dump, \"transform reduction: created def-use cycle: \");\n \t  print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n-\t  fprintf (vect_dump, \"\\n\");\n-\t  print_gimple_stmt (vect_dump, SSA_NAME_DEF_STMT (def), 0, TDF_SLIM);\n+          fprintf (vect_dump, \"\\n\");\n+          print_gimple_stmt (vect_dump, SSA_NAME_DEF_STMT (def), 0, TDF_SLIM);\n \t}\n \n       phi = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (phi));\n@@ -2831,15 +2983,25 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n   bitsize = TYPE_SIZE (scalar_type);\n   bytesize = TYPE_SIZE_UNIT (scalar_type);\n \n+  /* For MINUS_EXPR the initial vector is [init_val,0,...,0], therefore,\n+     partial results are added and not subtracted.  */\n+  if (code == MINUS_EXPR)\n+    code = PLUS_EXPR;\n \n   /* In case this is a reduction in an inner-loop while vectorizing an outer\n      loop - we don't need to extract a single scalar result at the end of the\n-     inner-loop.  The final vector of partial results will be used in the\n-     vectorized outer-loop, or reduced to a scalar result at the end of the\n-     outer-loop.  */\n-  if (nested_in_vect_loop)\n+     inner-loop (unless it is double reduction, i.e., the use of reduction is\n+     outside the outer-loop). The final vector of partial results will be used \n+     in the vectorized outer-loop, or reduced to a scalar result at the end of\n+     the outer-loop.  */\n+  if (nested_in_vect_loop && !double_reduc)\n     goto vect_finalize_reduction;\n \n+  /* The epilogue is created for the outer-loop, i.e., for the loop being\n+     vectorized.  */\n+  if (double_reduc)\n+    loop = outer_loop;\n+\n   /* FORNOW */\n   gcc_assert (ncopies == 1);\n \n@@ -2914,6 +3076,7 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n \t       bit_offset /= 2)\n \t    {\n \t      tree bitpos = size_int (bit_offset);\n+              \n \t      epilog_stmt = gimple_build_assign_with_ops (shift_code, vec_dest,\n \t\t\t\t\t\t\t  new_temp, bitpos);\n \t      new_name = make_ssa_name (vec_dest, epilog_stmt);\n@@ -2987,7 +3150,7 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n     {\n       tree rhs;\n \n-      gcc_assert (!nested_in_vect_loop);\n+      gcc_assert (!nested_in_vect_loop || double_reduc);\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"extract scalar result\");\n \n@@ -3007,6 +3170,9 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n \n vect_finalize_reduction:\n \n+  if (double_reduc)\n+    loop = loop->inner;\n+\n   /* 2.5 Adjust the final result by the initial value of the reduction\n \t variable. (When such adjustment is not needed, then\n \t 'adjustment_def' is zero).  For example, if code is PLUS we create:\n@@ -3016,11 +3182,6 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n     {\n       if (nested_in_vect_loop)\n \t{\n-          /* For MINUS_EXPR we create new_temp = loop_exit_def + adjustment_def\n-             since the initial value is [0,0,...,0].  */\n-          if (code == MINUS_EXPR)\n-            code = PLUS_EXPR;\n-\n \t  gcc_assert (TREE_CODE (TREE_TYPE (adjustment_def)) == VECTOR_TYPE);\n \t  expr = build2 (code, vectype, PHI_RESULT (new_phi), adjustment_def);\n \t  new_dest = vect_create_destination_var (scalar_dest, vectype);\n@@ -3055,6 +3216,7 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n \t  VEC_quick_push (gimple, phis, exit_phi);\n \t}\n     }\n+\n   /* We expect to have found an exit_phi because of loop-closed-ssa form.  */\n   gcc_assert (!VEC_empty (gimple, phis));\n \n@@ -3063,12 +3225,13 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n       if (nested_in_vect_loop)\n \t{\n \t  stmt_vec_info stmt_vinfo = vinfo_for_stmt (exit_phi);\n+          gimple vect_phi;\n \n \t  /* FORNOW. Currently not supporting the case that an inner-loop\n \t     reduction is not used in the outer-loop (but only outside the\n-\t     outer-loop).  */\n-\t  gcc_assert (STMT_VINFO_RELEVANT_P (stmt_vinfo) \n-\t\t      && !STMT_VINFO_LIVE_P (stmt_vinfo));\n+\t     outer-loop), unless it is double reduction.  */\n+\t  gcc_assert ((STMT_VINFO_RELEVANT_P (stmt_vinfo) \n+                      && !STMT_VINFO_LIVE_P (stmt_vinfo)) || double_reduc);\n \n \t  epilog_stmt = adjustment_def ? epilog_stmt : new_phi;\n \t  STMT_VINFO_VEC_STMT (stmt_vinfo) = epilog_stmt;\n@@ -3078,7 +3241,88 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n \t  if (adjustment_def)\n \t    STMT_VINFO_RELATED_STMT (vinfo_for_stmt (epilog_stmt)) =\n \t\tSTMT_VINFO_RELATED_STMT (vinfo_for_stmt (new_phi));\n-\t  continue;\n+\n+          if (!double_reduc \n+              || STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_double_reduction_def)\n+            continue;\n+\n+          /* Handle double reduction: \n+\n+             stmt1: s1 = phi <s0, s2>  - double reduction phi (outer loop)\n+             stmt2:   s3 = phi <s1, s4> - (regular) reduction phi (inner loop)\n+             stmt3:   s4 = use (s3)     - (regular) reduction stmt (inner loop)\n+             stmt4: s2 = phi <s4>      - double reduction stmt (outer loop)\n+\n+             At that point the regular reduction (stmt2 and stmt3) is already \n+             vectorized, as well as the exit phi node, stmt4.\n+             Here we vectorize the phi node of double reduction, stmt1, and\n+             update all relevant statements.  */\n+\n+          /* Go through all the uses of s2 to find double reduction phi node, \n+             i.e., stmt1 above.  */\n+          orig_name = PHI_RESULT (exit_phi);\n+          FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, orig_name)\n+            {\n+              stmt_vec_info use_stmt_vinfo = vinfo_for_stmt (use_stmt);\n+              stmt_vec_info new_phi_vinfo;\n+              tree vect_phi_init, preheader_arg, vect_phi_res, init_def;\n+              basic_block bb = gimple_bb (use_stmt);\n+              gimple use;\n+\n+              /* Check that USE_STMT is really double reduction phi node.  */\n+              if (gimple_code (use_stmt) != GIMPLE_PHI\n+                  || gimple_phi_num_args (use_stmt) != 2\n+                  || !use_stmt_vinfo\n+                  || STMT_VINFO_DEF_TYPE (use_stmt_vinfo) \n+                      != vect_double_reduction_def\n+                  || bb->loop_father != outer_loop)\n+                continue;\n+\n+              /* Create vector phi node for double reduction: \n+                 vs1 = phi <vs0, vs2> \n+                 vs1 was created previously in this function by a call to\n+                 vect_get_vec_def_for_operand and is stored in vec_initial_def;\n+                 vs2 is defined by EPILOG_STMT, the vectorized EXIT_PHI;\n+                 vs0 is created here.  */\n+\n+              /* Create vector phi node.  */\n+              vect_phi = create_phi_node (vec_initial_def, bb);\n+              new_phi_vinfo = new_stmt_vec_info (vect_phi, \n+                                    loop_vec_info_for_loop (outer_loop), NULL);\n+              set_vinfo_for_stmt (vect_phi, new_phi_vinfo);\n+\n+              /* Create vs0 - initial def of the double reduction phi.  */              \n+              preheader_arg = PHI_ARG_DEF_FROM_EDGE (use_stmt, \n+                                             loop_preheader_edge (outer_loop)); \n+              init_def = get_initial_def_for_reduction (stmt, preheader_arg,\n+                                                        NULL);\n+              vect_phi_init = vect_init_vector (use_stmt, init_def, vectype,\n+                                                NULL);\n+               \n+              /* Update phi node arguments with vs0 and vs2.  */\n+              add_phi_arg (vect_phi, vect_phi_init, \n+                           loop_preheader_edge (outer_loop));\n+              add_phi_arg (vect_phi, PHI_RESULT (epilog_stmt), \n+                           loop_latch_edge (outer_loop));\n+              if (vect_print_dump_info (REPORT_DETAILS))\n+                {\n+                  fprintf (vect_dump, \"created double reduction phi node: \");\n+                  print_gimple_stmt (vect_dump, vect_phi, 0, TDF_SLIM);\n+                }\n+\n+              vect_phi_res = PHI_RESULT (vect_phi);\n+\n+              /* Replace the use, i.e., set the correct vs1 in the regular\n+                 reduction phi node. FORNOW, NCOPIES is always 1, so the loop\n+                 is redundant.  */                  \n+              use = reduction_phi;\n+              for (j = 0; j < ncopies; j++)\n+                {\n+                  edge pr_edge = loop_preheader_edge (loop);\n+                  SET_PHI_ARG_DEF (use, pr_edge->dest_idx, vect_phi_res); \n+                  use = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (use));\n+                }\n+            }\n \t}\n \n       /* Replace the uses:  */\n@@ -3087,6 +3331,7 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n \tFOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n \t  SET_USE (use_p, new_temp);\n     }\n+\n   VEC_free (gimple, heap, phis);\n } \n \n@@ -3171,6 +3416,10 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   gimple reduc_def_stmt = NULL;\n   /* The default is that the reduction variable is the last in statement.  */\n   int reduc_index = 2;\n+  bool double_reduc = false, dummy;\n+  basic_block def_bb;\n+  struct loop * def_stmt_loop;\n+  tree def_arg;\n \n   if (nested_in_vect_loop_p (loop, stmt))\n     {\n@@ -3185,7 +3434,6 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   /* 1. Is vectorizable reduction?  */\n-\n   /* Not supportable if the reduction variable is used in the loop.  */\n   if (STMT_VINFO_RELEVANT (stmt_info) > vect_used_in_outer)\n     return false;\n@@ -3300,10 +3548,11 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   if (orig_stmt) \n     gcc_assert (orig_stmt == vect_is_simple_reduction (loop_vinfo, \n                                                        reduc_def_stmt, \n-                                                       !nested_cycle));\n+                                                       !nested_cycle, \n+                                                       &dummy));\n   else\n     gcc_assert (stmt == vect_is_simple_reduction (loop_vinfo, reduc_def_stmt, \n-                                                  !nested_cycle));\n+                                                  !nested_cycle, &dummy));\n   \n   if (STMT_VINFO_LIVE_P (vinfo_for_stmt (reduc_def_stmt)))\n     return false;\n@@ -3400,25 +3649,43 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       orig_code = code;\n     }\n \n-  if (nested_cycle)\n-    epilog_reduc_code = orig_code;\n-  else\n-    if (!reduction_code_for_scalar_code (orig_code, &epilog_reduc_code))\n-      return false;\n+  if (!reduction_code_for_scalar_code (orig_code, &epilog_reduc_code))\n+    return false;\n \n-  reduc_optab = optab_for_tree_code (epilog_reduc_code, vectype, optab_default);\n+  reduc_optab = optab_for_tree_code (epilog_reduc_code, vectype, \n+                                     optab_default);\n   if (!reduc_optab)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"no optab for reduction.\");\n       epilog_reduc_code = ERROR_MARK;\n     }\n-  if (optab_handler (reduc_optab, vec_mode)->insn_code == CODE_FOR_nothing)\n+\n+  if (reduc_optab\n+      && optab_handler (reduc_optab, vec_mode)->insn_code == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"reduc op not supported by target.\");\n       epilog_reduc_code = ERROR_MARK;\n     }\n+\n+  def_bb = gimple_bb (reduc_def_stmt);\n+  def_stmt_loop = def_bb->loop_father;\n+  def_arg = PHI_ARG_DEF_FROM_EDGE (reduc_def_stmt,\n+                                   loop_preheader_edge (def_stmt_loop));\n+  if (TREE_CODE (def_arg) == SSA_NAME\n+      && vinfo_for_stmt (SSA_NAME_DEF_STMT (def_arg))\n+      && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (SSA_NAME_DEF_STMT (def_arg)))\n+          == vect_double_reduction_def)\n+    double_reduc = true;\n+\n+  if (double_reduc && ncopies > 1)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"multiple types in double reduction\");\n+\n+      return false;\n+    }\n  \n   if (!vec_stmt) /* transformation not required.  */\n     {\n@@ -3560,8 +3827,10 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n      epilog reduction code.  */\n   if (!single_defuse_cycle)\n     new_temp = gimple_assign_lhs (*vec_stmt);\n+\n   vect_create_epilog_for_reduction (new_temp, stmt, epilog_copies,\n-\t\t\t\t    epilog_reduc_code, first_phi, reduc_index);\n+\t\t\t\t    epilog_reduc_code, first_phi, reduc_index,\n+                                    double_reduc);\n   return true;\n }\n "}, {"sha": "891ee1860f09c2f8309faa72d818052da3d2ab9f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 53, "deletions": 35, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=06066f92aaea9e9b0fff53a693b300bb9aa1121a", "patch": "@@ -331,7 +331,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n \t\t...\n \tinner-loop:\n \t\td = def_stmt\n-\touter-loop-tail-bb:\n+\touter-loop-tail-bb (or outer-loop-exit-bb in double reduction):\n \t\tstmt # use (d)\t\t*/\n   else if (flow_loop_nested_p (bb->loop_father, def_bb->loop_father))\n     {\n@@ -341,7 +341,8 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n       switch (relevant)\n         {\n         case vect_unused_in_scope:\n-          relevant = (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def) ?\n+          relevant = (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def \n+            || STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_double_reduction_def) ?\n                       vect_used_in_outer_by_reduction : vect_unused_in_scope;\n           break;\n \n@@ -393,7 +394,8 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   basic_block bb;\n   gimple phi;\n   bool live_p;\n-  enum vect_relevant relevant;\n+  enum vect_relevant relevant, tmp_relevant;\n+  enum vect_def_type def_type;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_mark_stmts_to_be_vectorized ===\");\n@@ -465,49 +467,64 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t identify stmts that are used solely by a reduction, and therefore the \n \t order of the results that they produce does not have to be kept.  */\n \n-      if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def)\n+      def_type = STMT_VINFO_DEF_TYPE (stmt_vinfo);\n+      tmp_relevant = relevant;\n+      switch (def_type)\n         {\n-\t  enum vect_relevant tmp_relevant = relevant;\n-\t  switch (tmp_relevant)\n-\t    {\n-\t    case vect_unused_in_scope:\n-\t      gcc_assert (gimple_code (stmt) != GIMPLE_PHI);\n-\t      relevant = vect_used_by_reduction;\n-\t      break;\n+          case vect_reduction_def:\n+\t    switch (tmp_relevant)\n+\t      {\n+\t        case vect_unused_in_scope:\n+\t          relevant = vect_used_by_reduction;\n+\t          break;\n \n-\t    case vect_used_by_reduction:\n-\t      if (gimple_code (stmt) == GIMPLE_PHI)\n-\t\tbreak;\n-\t      /* fall through */\n+\t        case vect_used_by_reduction:\n+\t          if (gimple_code (stmt) == GIMPLE_PHI)\n+                    break;\n+  \t          /* fall through */\n \n-\t    default:\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t        fprintf (vect_dump, \"unsupported use of reduction.\");\n-\t      VEC_free (gimple, heap, worklist);\n-\t      return false;\n-\t    }\n+\t        default:\n+\t          if (vect_print_dump_info (REPORT_DETAILS))\n+\t            fprintf (vect_dump, \"unsupported use of reduction.\");\n \n-\t  live_p = false;\t\n-\t}\n-      else if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_nested_cycle)\n-        {\n-          enum vect_relevant tmp_relevant = relevant;\n-          switch (tmp_relevant)\n-            {\n-              case vect_unused_in_scope:\n-              case vect_used_in_outer_by_reduction:\n-              case vect_used_in_outer:\n-                break;\n+  \t          VEC_free (gimple, heap, worklist);\n+\t          return false;\n+\t      }\n \n-              default:\n+\t    live_p = false;\t\n+\t    break;\n+ \n+          case vect_nested_cycle:\n+            if (tmp_relevant != vect_unused_in_scope\n+                && tmp_relevant != vect_used_in_outer_by_reduction\n+                && tmp_relevant != vect_used_in_outer)\n+              {\n                 if (vect_print_dump_info (REPORT_DETAILS))\n                   fprintf (vect_dump, \"unsupported use of nested cycle.\");\n \n                 VEC_free (gimple, heap, worklist);\n                 return false;\n-            }\n+              }\n+\n+            live_p = false; \n+            break; \n+      \n+          case vect_double_reduction_def:\n+            if (tmp_relevant != vect_unused_in_scope\n+                && tmp_relevant != vect_used_by_reduction)\n+              {\n+                if (vect_print_dump_info (REPORT_DETAILS))\n+                  fprintf (vect_dump, \"unsupported use of double reduction.\");\n+\n+                VEC_free (gimple, heap, worklist);\n+                return false;\n+              }\n+\n+            live_p = false;\n+            break; \n \n-          live_p = false; \n+          default:\n+            break;\n         }\n  \n       FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n@@ -974,6 +991,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n \n     /* Case 4: operand is defined by a loop header phi - reduction  */\n     case vect_reduction_def:\n+    case vect_double_reduction_def:\n     case vect_nested_cycle:\n       {\n \tstruct loop *loop;"}, {"sha": "c7dab10c13fcb257b944e4a18fa06f8d908999f3", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06066f92aaea9e9b0fff53a693b300bb9aa1121a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=06066f92aaea9e9b0fff53a693b300bb9aa1121a", "patch": "@@ -61,6 +61,7 @@ enum vect_def_type {\n   vect_internal_def,\n   vect_induction_def,\n   vect_reduction_def,\n+  vect_double_reduction_def,\n   vect_nested_cycle,\n   vect_unknown_def_type\n };\n@@ -822,7 +823,7 @@ extern tree vect_create_addr_base_for_vector_ref (gimple, gimple_seq *,\n /* In tree-vect-loop.c.  */\n /* FORNOW: Used in tree-parloops.c.  */\n extern void destroy_loop_vec_info (loop_vec_info, bool);\n-extern gimple vect_is_simple_reduction (loop_vec_info, gimple, bool);\n+extern gimple vect_is_simple_reduction (loop_vec_info, gimple, bool, bool *);\n /* Drive for loop analysis stage.  */\n extern loop_vec_info vect_analyze_loop (struct loop *);\n /* Drive for loop transformation stage.  */"}]}