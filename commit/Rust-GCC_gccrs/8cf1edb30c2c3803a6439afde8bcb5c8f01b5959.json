{"sha": "8cf1edb30c2c3803a6439afde8bcb5c8f01b5959", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNmMWVkYjMwYzJjMzgwM2E2NDM5YWZkZThiY2I1YzhmMDFiNTk1OQ==", "commit": {"author": {"name": "Guilhem Lavaux", "email": "guilhem@kaffe.org", "date": "2004-05-04T22:00:30Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-05-04T22:00:30Z"}, "message": "2004-05-05  Guilhem Lavaux <guilhem@kaffe.org>\n\n\t* java/text/DecimalFormat.java\n\t(MAXIMUM_INTEGER_DIGITS): New constant to keep the numeric value 309.\n\t(applyPatternWithSymbols): Use MAXIMUM_INTEGER_DIGITS.\n\t(parse): Fixed handling of exponentiation notation and grouping.\n\n2004-05-05  Guilhem Lavaux <guilhem@kaffe.org>\n\n\t* java/text/DecimalFormat.java\n\t(scanFix): Build attribute array. Fixed error reporting.\n\t(applyPatternWithSymbols): Store attributes for the prefix and\n\tsuffix.\n\t(formatInternal): New method. Changed the way the string is\n\tcomputed. Implemented attributes. Cleant up rounding in\n\texponential notation.\n\t(format): Use formatInternal.\n\t(formatToCharacterIterator): New method.\n\t(exponentRound, negativePrefixRanges, positivePrefixRanges,\n\tnegativePrefixAttrs, positivePrefixAttrs, negativeSuffixRanges,\n\tpositiveSuffixRanges, negativeSuffixAttrs, positiveSuffixAttrs):\n\tNew fields.\n\nFrom-SVN: r81491", "tree": {"sha": "defe099ae4d498f26593658eecf72a09b38fb5a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/defe099ae4d498f26593658eecf72a09b38fb5a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cf1edb30c2c3803a6439afde8bcb5c8f01b5959", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf1edb30c2c3803a6439afde8bcb5c8f01b5959", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cf1edb30c2c3803a6439afde8bcb5c8f01b5959", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf1edb30c2c3803a6439afde8bcb5c8f01b5959/comments", "author": null, "committer": null, "parents": [{"sha": "aff9d141f673a525df45b21a687efe624d30d642", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aff9d141f673a525df45b21a687efe624d30d642", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aff9d141f673a525df45b21a687efe624d30d642"}], "stats": {"total": 248, "additions": 184, "deletions": 64}, "files": [{"sha": "91080fffb80857bfa8513f2ad319f2a6bf9bcae8", "filename": "libjava/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cf1edb30c2c3803a6439afde8bcb5c8f01b5959/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cf1edb30c2c3803a6439afde8bcb5c8f01b5959/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8cf1edb30c2c3803a6439afde8bcb5c8f01b5959", "patch": "@@ -1,3 +1,26 @@\n+2004-05-05  Guilhem Lavaux <guilhem@kaffe.org>\n+\n+\t* java/text/DecimalFormat.java\n+\t(MAXIMUM_INTEGER_DIGITS): New constant to keep the numeric value 309.\n+\t(applyPatternWithSymbols): Use MAXIMUM_INTEGER_DIGITS.\n+\t(parse): Fixed handling of exponentiation notation and grouping.\n+\n+2004-05-05  Guilhem Lavaux <guilhem@kaffe.org>\n+\n+\t* java/text/DecimalFormat.java\n+\t(scanFix): Build attribute array. Fixed error reporting.\n+\t(applyPatternWithSymbols): Store attributes for the prefix and\n+\tsuffix.\n+\t(formatInternal): New method. Changed the way the string is\n+\tcomputed. Implemented attributes. Cleant up rounding in\n+\texponential notation.\n+\t(format): Use formatInternal.\n+\t(formatToCharacterIterator): New method.\n+\t(exponentRound, negativePrefixRanges, positivePrefixRanges,\n+\tnegativePrefixAttrs, positivePrefixAttrs, negativeSuffixRanges,\n+\tpositiveSuffixRanges, negativeSuffixAttrs, positiveSuffixAttrs):\n+\tNew fields.\n+\n 2004-05-04  Dalibor Topic  <robilad@kaffe.org>\n \n \t* java/security/interfaces/DSAKeyPairGenerator.java,"}, {"sha": "977acd8f92f7b5c7f654410617d2e41ec30d37d2", "filename": "libjava/java/text/DecimalFormat.java", "status": "modified", "additions": 161, "deletions": 64, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cf1edb30c2c3803a6439afde8bcb5c8f01b5959/libjava%2Fjava%2Ftext%2FDecimalFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cf1edb30c2c3803a6439afde8bcb5c8f01b5959/libjava%2Fjava%2Ftext%2FDecimalFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDecimalFormat.java?ref=8cf1edb30c2c3803a6439afde8bcb5c8f01b5959", "patch": "@@ -37,7 +37,13 @@\n \n package java.text;\n \n+import gnu.java.text.AttributedFormatBuffer;\n+import gnu.java.text.FormatBuffer;\n+import gnu.java.text.FormatCharacterIterator;\n+import gnu.java.text.StringFormatBuffer;\n+\n import java.util.Currency;\n+import java.util.HashMap;\n import java.util.Locale;\n import java.util.MissingResourceException;\n import java.util.ResourceBundle;\n@@ -58,37 +64,48 @@ public class DecimalFormat extends NumberFormat\n {\n   // This is a helper for applyPatternWithSymbols.  It reads a prefix\n   // or a suffix.  It can cause some side-effects.\n-  private final int scanFix (String pattern, int index, StringBuffer buf,\n+  private final int scanFix (String pattern, int index, FormatBuffer buf,\n \t\t\t     String patChars, DecimalFormatSymbols syms,\n \t\t\t     boolean is_suffix)\n   {\n     int len = pattern.length();\n-    buf.setLength(0);\n+    boolean quoteStarted = false;\n+    buf.clear();\n+    \n     boolean multiplierSet = false;\n     while (index < len)\n       {\n \tchar c = pattern.charAt(index);\n+\n+\tif (quoteStarted)\n+\t  {\n+\t    if (c == '\\'')\n+\t      quoteStarted = false;\n+\t    else\n+\t      buf.append(c);\n+\t    index++;\n+\t    continue;\n+\t  }\n+\n \tif (c == '\\'' && index + 1 < len\n \t    && pattern.charAt(index + 1) == '\\'')\n \t  {\n \t    buf.append(c);\n-\t    ++index;\n+\t    index++;\n \t  }\n-\telse if (c == '\\'' && index + 2 < len\n-\t\t && pattern.charAt(index + 2) == '\\'')\n+\telse if (c == '\\'')\n \t  {\n-\t    buf.append(pattern.charAt(index + 1));\n-\t    index += 2;\n+\t    quoteStarted = true;\n \t  }\n \telse if (c == '\\u00a4')\n \t  {\n \t    if (index + 1 < len && pattern.charAt(index + 1) == '\\u00a4')\n \t      {\n-\t\tbuf.append(syms.getInternationalCurrencySymbol());\n-\t\t++index;\n+\t\tbuf.append(syms.getInternationalCurrencySymbol(), NumberFormat.Field.CURRENCY);\n+\t\tindex++;\n \t      }\n \t    else\n-\t      buf.append(syms.getCurrencySymbol());\n+\t      buf.append(syms.getCurrencySymbol(), NumberFormat.Field.CURRENCY);\n \t  }\n \telse if (c == syms.getPercent())\n \t  {\n@@ -97,7 +114,7 @@ else if (c == syms.getPercent())\n \t\t\t\t\t\t  \"- index: \" + index);\n \t    multiplierSet = true;\n \t    multiplier = 100;\n-\t    buf.append(c);\n+\t    buf.append(c, NumberFormat.Field.PERCENT);\n \t  }\n \telse if (c == syms.getPerMill())\n \t  {\n@@ -106,7 +123,7 @@ else if (c == syms.getPerMill())\n \t\t\t\t\t\t  \"- index: \" + index);\n \t    multiplierSet = true;\n \t    multiplier = 1000;\n-\t    buf.append(c);\n+\t    buf.append(c, NumberFormat.Field.PERMILLE);\n \t  }\n \telse if (patChars.indexOf(c) != -1)\n \t  {\n@@ -115,9 +132,12 @@ else if (patChars.indexOf(c) != -1)\n \t  }\n \telse\n \t  buf.append(c);\n-\t++index;\n+\tindex++;\n       }\n \n+    if (quoteStarted)\n+      throw new IllegalArgumentException (\"pattern is lacking a closing quote\");\n+\n     return index;\n   }\n \n@@ -259,6 +279,16 @@ else if (patChars.indexOf(c) != -1)\n \t    useExponentialNotation = true;\n \t    minExponentDigits = (byte) zeroCount;\n \t  }\n+\n+\tmaximumIntegerDigits = groupingSize;\n+\tgroupingSize = 0;\n+\tif (maximumIntegerDigits > minimumIntegerDigits && maximumIntegerDigits > 0)\n+\t  {\n+\t    minimumIntegerDigits = 1;\n+\t    exponentRound = maximumIntegerDigits;\n+\t  }\n+\telse\n+\t  exponentRound = 1;\n       }\n \n     return index;\n@@ -304,17 +334,23 @@ private final void applyPatternWithSymbols (String pattern,\n     minimumFractionDigits = 0;\n     minimumIntegerDigits = 1;\n \n-    StringBuffer buf = new StringBuffer ();\n+    AttributedFormatBuffer buf = new AttributedFormatBuffer ();\n     String patChars = patternChars (syms);\n \n     int max = pattern.length();\n     int index = scanFix (pattern, 0, buf, patChars, syms, false);\n-    positivePrefix = buf.toString();\n+    buf.sync();\n+    positivePrefix = buf.getBuffer().toString();\n+    positivePrefixRanges = buf.getRanges();\n+    positivePrefixAttrs = buf.getAttributes();\n \n     index = scanFormat (pattern, index, patChars, syms, true);\n \n     index = scanFix (pattern, index, buf, patChars, syms, true);\n-    positiveSuffix = buf.toString();\n+    buf.sync();\n+    positiveSuffix = buf.getBuffer().toString();\n+    positiveSuffixRanges = buf.getRanges();\n+    positiveSuffixAttrs = buf.getAttributes();\n \n     if (index == pattern.length())\n       {\n@@ -329,14 +365,20 @@ private final void applyPatternWithSymbols (String pattern,\n \t\t\t\t\t      \"expected - index: \" + index);\n \n \tindex = scanFix (pattern, index + 1, buf, patChars, syms, false);\n-\tnegativePrefix = buf.toString();\n+\tbuf.sync();\n+\tnegativePrefix = buf.getBuffer().toString();\n+\tnegativePrefixRanges = buf.getRanges();\n+\tnegativePrefixAttrs = buf.getAttributes();\n \n \t// We parse the negative format for errors but we don't let\n \t// it side-effect this object.\n \tindex = scanFormat (pattern, index, patChars, syms, false);\n \n \tindex = scanFix (pattern, index, buf, patChars, syms, true);\n-\tnegativeSuffix = buf.toString();\n+\tbuf.sync();\n+\tnegativeSuffix = buf.getBuffer().toString();\n+\tnegativeSuffixRanges = buf.getRanges();\n+\tnegativeSuffixAttrs = buf.getAttributes();\n \n \tif (index != pattern.length())\n \t  throw new IllegalArgumentException (\"end of pattern expected \" +\n@@ -409,39 +451,43 @@ && equals(positiveSuffix, dup.positiveSuffix)\n \t    && useExponentialNotation == dup.useExponentialNotation);\n   }\n \n-  public StringBuffer format (double number, StringBuffer dest,\n-\t\t\t      FieldPosition fieldPos)\n+  protected void formatInternal (double number, FormatBuffer dest,\n+\t\t\t\t FieldPosition fieldPos)\n   {\n     // A very special case.\n     if (Double.isNaN(number))\n       {\n \tdest.append(symbols.getNaN());\n-\tif (fieldPos != null && fieldPos.getField() == INTEGER_FIELD)\n+\tif (fieldPos != null && \n+\t    (fieldPos.getField() == INTEGER_FIELD ||\n+\t     fieldPos.getFieldAttribute() == NumberFormat.Field.INTEGER))\n \t  {\n \t    int index = dest.length();\n \t    fieldPos.setBeginIndex(index - symbols.getNaN().length());\n \t    fieldPos.setEndIndex(index);\n \t  }\n-\treturn dest;\n+\treturn;\n       }\n \n     boolean is_neg = number < 0;\n     if (is_neg)\n       {\n \tif (negativePrefix != null)\n-\t  dest.append(negativePrefix);\n+\t  dest.append(negativePrefix, negativePrefixRanges, negativePrefixAttrs);\n \telse\n \t  {\n-\t    dest.append(symbols.getMinusSign());\n-\t    dest.append(positivePrefix);\n+\t    dest.append(symbols.getMinusSign(), NumberFormat.Field.SIGN);\n+\t    dest.append(positivePrefix, positivePrefixRanges, positivePrefixAttrs);\n \t  }\n \tnumber = - number;\n       }\n     else\n-      dest.append(positivePrefix);\n+      dest.append(positivePrefix, positivePrefixRanges, positivePrefixAttrs);\n \n     int integerBeginIndex = dest.length();\n     int integerEndIndex = 0;\n+    int zeroStart = symbols.getZeroDigit() - '0';\n+\n     if (Double.isInfinite (number))\n       {\n \tdest.append(symbols.getInfinity());\n@@ -457,6 +503,7 @@ public StringBuffer format (double number, StringBuffer dest,\n \tif (useExponentialNotation)\n \t  {\n \t    exponent = (long) Math.floor (Math.log(number) / Math.log(10));\n+\t    exponent = exponent - (exponent % exponentRound);\n \t    if (minimumIntegerDigits > 0)\n \t      exponent -= minimumIntegerDigits - 1;\n \t    baseNumber = (number / Math.pow(10.0, exponent));\n@@ -468,33 +515,57 @@ public StringBuffer format (double number, StringBuffer dest,\n \tbaseNumber += 5 * Math.pow(10.0, - maximumFractionDigits - 1);\n \n \tint index = dest.length();\n-\tdouble intPart = Math.floor(baseNumber);\n-\tint count = 0;\n-\twhile (count < maximumIntegerDigits\n-\t       && (intPart > 0 || count < minimumIntegerDigits))\n+\t//double intPart = Math.floor(baseNumber);\n+\tString intPart = Long.toString((long)Math.floor(baseNumber));\n+\tint count, groupPosition = intPart.length();\n+\n+\tdest.setDefaultAttribute(NumberFormat.Field.INTEGER);\n+\n+\tfor (count = 0; count < minimumIntegerDigits-intPart.length(); count++)\n+\t  dest.append(symbols.getZeroDigit());\n+\n+\tfor (count = 0;\n+\t     count < maximumIntegerDigits && count < intPart.length();\n+\t     count++)\n \t  {\n-\t    long dig = (long) (intPart % 10);\n-\t    intPart = Math.floor(intPart / 10);\n+\t    int dig = intPart.charAt(count);\n \n \t    // Append group separator if required.\n-\t    if (groupingUsed && count > 0 && groupingSize != 0 && count % groupingSize == 0)\n-\t      dest.insert(index, symbols.getGroupingSeparator());\n-\n-\t    dest.insert(index, (char) (symbols.getZeroDigit() + dig));\n+\t    if (groupingUsed && count > 0 && groupingSize != 0 && groupPosition % groupingSize == 0)\n+\t      {\n+\t\tdest.append(symbols.getGroupingSeparator(), NumberFormat.Field.GROUPING_SEPARATOR);\n+\t\tdest.setDefaultAttribute(NumberFormat.Field.INTEGER);\n+\t      }\n+\t    dest.append((char) (zeroStart + dig));\n \n-\t    ++count;\n+\t    groupPosition--;\n \t  }\n+\tdest.setDefaultAttribute(null);\n \n \tintegerEndIndex = dest.length();\n-\n+\t   \n \tint decimal_index = integerEndIndex;\n \tint consecutive_zeros = 0;\n \tint total_digits = 0;\n \n+\tint localMaximumFractionDigits = maximumFractionDigits;\n+\n+\tif (useExponentialNotation)\n+\t  localMaximumFractionDigits += minimumIntegerDigits - count;\n+\n \t// Strip integer part from NUMBER.\n \tdouble fracPart = baseNumber - Math.floor(baseNumber);\n+\t\n+\tif ( ((fracPart != 0 || minimumFractionDigits > 0) && localMaximumFractionDigits > 0)\n+\t     || decimalSeparatorAlwaysShown)\n+\t  {\n+\t    dest.append (symbols.getDecimalSeparator(), NumberFormat.Field.DECIMAL_SEPARATOR);\n+\t  }\n+\n+\n+\tdest.setDefaultAttribute(NumberFormat.Field.FRACTION);\n \tfor (count = 0;\n-\t     count < maximumFractionDigits\n+\t     count < localMaximumFractionDigits\n \t       && (fracPart != 0 || count < minimumFractionDigits);\n \t     ++count)\n \t  {\n@@ -517,61 +588,82 @@ public StringBuffer format (double number, StringBuffer dest,\n \t\t\t\t    total_digits - minimumFractionDigits);\n \tif (extra_zeros > 0)\n \t  {\n-\t    dest.setLength(dest.length() - extra_zeros);\n+\t    dest.cutTail(extra_zeros);\n \t    total_digits -= extra_zeros;\n-\t  }\n-\n-\t// If required, add the decimal symbol.\n-\tif (decimalSeparatorAlwaysShown\n-\t    || total_digits > 0)\n-\t  {\n-\t    dest.insert(decimal_index, symbols.getDecimalSeparator());\n-\t    if (fieldPos != null && fieldPos.getField() == FRACTION_FIELD)\n-\t      {\n-\t\tfieldPos.setBeginIndex(decimal_index + 1);\n-\t\tfieldPos.setEndIndex(dest.length());\n-\t      }\n+\t    if (total_digits == 0 && !decimalSeparatorAlwaysShown)\n+\t      dest.cutTail(1);\n \t  }\n \n \t// Finally, print the exponent.\n \tif (useExponentialNotation)\n \t  {\n-\t    dest.append(symbols.getExponential());\n+\t    dest.append(symbols.getExponential(), NumberFormat.Field.EXPONENT_SYMBOL);\t    \n \t    if (exponent < 0)\n \t      {\n-\t\tdest.append (symbols.getMinusSign ());\n+\t\tdest.append (symbols.getMinusSign (), NumberFormat.Field.EXPONENT_SIGN);\n \t\texponent = - exponent;\n \t      }\n \t    index = dest.length();\n+\t    dest.setDefaultAttribute(NumberFormat.Field.EXPONENT);\n+\t    String exponentString = Long.toString ((long) exponent);\n+\t    \n+\t    for (count = 0; count < minExponentDigits-exponentString.length();\n+\t\t count++)\n+\t      dest.append((char) symbols.getZeroDigit());\n+\n \t    for (count = 0;\n-\t\t exponent > 0 || count < minExponentDigits;\n+\t\t count < exponentString.length();\n \t\t ++count)\n \t      {\n-\t\tlong dig = exponent % 10;\n-\t\texponent /= 10;\n-\t\tdest.insert(index, (char) (symbols.getZeroDigit() + dig));\n+\t\tint dig = exponentString.charAt(count);\n+\t\tdest.append((char) (zeroStart + dig));\n \t      }\n \t  }\n       }\n \n-    if (fieldPos != null && fieldPos.getField() == INTEGER_FIELD)\n+    if (fieldPos != null && \n+\t(fieldPos.getField() == INTEGER_FIELD ||\n+\t fieldPos.getFieldAttribute() == NumberFormat.Field.INTEGER))\n       {\n \tfieldPos.setBeginIndex(integerBeginIndex);\n \tfieldPos.setEndIndex(integerEndIndex);\n       }\n \n-    dest.append((is_neg && negativeSuffix != null)\n-\t\t? negativeSuffix\n-\t\t: positiveSuffix);\n+    if (is_neg && negativeSuffix != null)\n+      dest.append(negativeSuffix, negativeSuffixRanges, negativeSuffixAttrs);\n+    else\n+      dest.append(positiveSuffix, positiveSuffixRanges, positiveSuffixAttrs);\n+  }\n+\n+  public StringBuffer format (double number, StringBuffer dest,\n+\t\t\t      FieldPosition fieldPos)\n+  {\n+    formatInternal (number, new StringFormatBuffer(dest), fieldPos);\n     return dest;\n   }\n \n+  public AttributedCharacterIterator formatToCharacterIterator (Object value)\n+  {\n+    AttributedFormatBuffer sbuf = new AttributedFormatBuffer();\n+\n+    if (value instanceof Number)\n+      formatInternal(((Number) value).doubleValue(), sbuf, null);\n+    else\n+      throw new IllegalArgumentException \n+\t(\"Cannot format given Object as a Number\");\n+    \n+    sbuf.sync();\n+    return new FormatCharacterIterator(sbuf.getBuffer().toString(), \n+\t\t\t\t       sbuf.getRanges(), \n+\t\t\t\t       sbuf.getAttributes());\n+  }\n+\n   public StringBuffer format (long number, StringBuffer dest,\n \t\t\t      FieldPosition fieldPos)\n   {\n     // If using exponential notation, we just format as a double.\n     if (useExponentialNotation)\n-      return format ((double) number, dest, fieldPos);\n+       return format ((double) number, dest, fieldPos);\n \n     boolean is_neg = number < 0;\n     if (is_neg)\n@@ -964,7 +1056,7 @@ private final String computePattern (DecimalFormatSymbols syms)\n     // digits.  Past that we need hash marks up to the grouping\n     // separator (and one beyond).\n     int total_digits = Math.max(minimumIntegerDigits,\n-\t\t\t\tgroupingUsed ? groupingSize + 1: 0);\n+\t\t\t\tgroupingUsed ? groupingSize + 1: groupingSize);\n     for (int i = 0; i < total_digits - minimumIntegerDigits; ++i)\n       mainPattern.append(syms.getDigit());\n     for (int i = total_digits - minimumIntegerDigits; i < total_digits; ++i)\n@@ -1022,11 +1114,16 @@ public String toPattern ()\n   private boolean decimalSeparatorAlwaysShown;\n   private byte groupingSize;\n   private byte minExponentDigits;\n+  private int exponentRound;\n   private int multiplier;\n   private String negativePrefix;\n   private String negativeSuffix;\n   private String positivePrefix;\n   private String positiveSuffix;\n+  private int[] negativePrefixRanges, positivePrefixRanges;\n+  private HashMap[] negativePrefixAttrs, positivePrefixAttrs;\n+  private int[] negativeSuffixRanges, positiveSuffixRanges;\n+  private HashMap[] negativeSuffixAttrs, positiveSuffixAttrs;\n   private int serialVersionOnStream = 1;\n   private DecimalFormatSymbols symbols;\n   private boolean useExponentialNotation;"}]}