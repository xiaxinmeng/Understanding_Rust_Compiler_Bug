{"sha": "25e22dc0cb9714b9c85a057d72dc4c6a00d688ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVlMjJkYzBjYjk3MTRiOWM4NWEwNTdkNzJkYzRjNmEwMGQ2ODhhYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-08-16T15:41:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-08-16T15:41:05Z"}, "message": "Thu Aug 16 17:39:45 CEST 2001  Jan Hubicka  <jh@suse.cz>\n\n\t* function.c (put_var_into_stack): Temporarily clear DECL_RTL.\n\t(assign_params): Avoid setting DECL_RTL to unfinished RTX.\n\t(expand_function_start): Likewise.\n\t* stmt.c (expand_decl): Likewise.\n\t* varasm.c (make_decl_rtx): Likewise.\n\nFrom-SVN: r44940", "tree": {"sha": "80f7f087ef4086f375aabc690b443d6bc9622d94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80f7f087ef4086f375aabc690b443d6bc9622d94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25e22dc0cb9714b9c85a057d72dc4c6a00d688ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e22dc0cb9714b9c85a057d72dc4c6a00d688ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25e22dc0cb9714b9c85a057d72dc4c6a00d688ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e22dc0cb9714b9c85a057d72dc4c6a00d688ab/comments", "author": null, "committer": null, "parents": [{"sha": "7256efa629eaade7e927099a12ecd5ad305f118b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7256efa629eaade7e927099a12ecd5ad305f118b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7256efa629eaade7e927099a12ecd5ad305f118b"}], "stats": {"total": 192, "additions": 134, "deletions": 58}, "files": [{"sha": "6800290ebfec2341d81367e77006a17d34a01ea3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e22dc0cb9714b9c85a057d72dc4c6a00d688ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e22dc0cb9714b9c85a057d72dc4c6a00d688ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25e22dc0cb9714b9c85a057d72dc4c6a00d688ab", "patch": "@@ -1,3 +1,11 @@\n+Thu Aug 16 17:39:45 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* function.c (put_var_into_stack): Temporarily clear DECL_RTL.\n+\t(assign_params): Avoid setting DECL_RTL to unfinished RTX.\n+\t(expand_function_start): Likewise.\n+\t* stmt.c (expand_decl): Likewise.\n+\t* varasm.c (make_decl_rtx): Likewise.\n+\n 2001-08-16  Jason Merrill  <jason_merrill@redhat.com>\n \n \t* stor-layout.c (layout_decl): Don't set DECL_USER_ALIGN."}, {"sha": "d3e581975a9e8cd0a6b089476d4e0aabb7d0920a", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e22dc0cb9714b9c85a057d72dc4c6a00d688ab/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e22dc0cb9714b9c85a057d72dc4c6a00d688ab/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=25e22dc0cb9714b9c85a057d72dc4c6a00d688ab", "patch": "@@ -7137,10 +7137,10 @@ the target supports DWARF 2 frame unwind information.\n This describes commands for alignment.\n \n @table @code\n-@findex LABEL_ALIGN_AFTER_BARRIER\n-@item LABEL_ALIGN_AFTER_BARRIER (@var{label})\n-The alignment (log base 2) to put in front of @var{label}, which follows\n-a @code{BARRIER}.\n+@findex JUMP_ALIGN_AFTER_BARRIER\n+@item JUMP_ALIGN (@var{label})\n+The alignment (log base 2) to put in front of @var{label}, which is\n+a common destination of jumps and has no fallthru incomming edge.\n \n This macro need not be defined if you don't want any special alignment\n to be done at such a time.  Most machine descriptions do not currently\n@@ -7149,8 +7149,17 @@ define the macro.\n Unless it's necessary to inspect the @var{label} parameter, it is better\n to set the variable @var{align_jumps} in the target's\n @code{OVERRIDE_OPTIONS}.  Otherwise, you should try to honour the user's\n-selection in @var{align_jumps} in a @code{LABEL_ALIGN_AFTER_BARRIER}\n-implementation.\n+selection in @var{align_jumps} in a @code{JUMP_ALIGN} implementation.\n+\n+@table @code\n+@findex LABEL_ALIGN_AFTER_BARRIER\n+@item LABEL_ALIGN_AFTER_BARRIER (@var{label})\n+The alignment (log base 2) to put in front of @var{label}, which follows\n+a @code{BARRIER}.\n+\n+This macro need not be defined if you don't want any special alignment\n+to be done at such a time.  Most machine descriptions do not currently\n+define the macro.\n \n @findex LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP\n @item LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP"}, {"sha": "ad922915c85efd0a3a7d32a663b8ca9580b9274b", "filename": "gcc/final.c", "status": "modified", "additions": 108, "deletions": 52, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e22dc0cb9714b9c85a057d72dc4c6a00d688ab/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e22dc0cb9714b9c85a057d72dc4c6a00d688ab/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=25e22dc0cb9714b9c85a057d72dc4c6a00d688ab", "patch": "@@ -632,11 +632,6 @@ static struct label_alignment *label_align;\n void\n init_insn_lengths ()\n {\n-  if (label_align)\n-    {\n-      free (label_align);\n-      label_align = 0;\n-    }\n   if (uid_shuid)\n     {\n       free (uid_shuid);\n@@ -780,11 +775,19 @@ get_attr_length (insn)\n #endif\n \n #ifndef LABEL_ALIGN_AFTER_BARRIER\n-#define LABEL_ALIGN_AFTER_BARRIER(LABEL) align_jumps_log\n+#define LABEL_ALIGN_AFTER_BARRIER(LABEL) 1\n #endif\n \n #ifndef LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP\n-#define LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP (align_jumps-1)\n+#define LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP 0\n+#endif\n+\n+#ifndef JUMP_ALIGN\n+#define JUMP_ALIGN(LABEL) align_jumps_log\n+#endif\n+\n+#ifndef JUMP_ALIGN_MAX_SKIP\n+#define JUMP_ALIGN_MAX_SKIP (align_jumps-1)\n #endif\n \n #ifndef ADDR_VEC_ALIGN\n@@ -935,6 +938,85 @@ insn_current_reference_address (branch)\n }\n #endif /* HAVE_ATTR_length */\n \f\n+void\n+compute_alignments ()\n+{\n+  int i;\n+  int log, max_skip, max_log;\n+\n+  if (label_align)\n+    {\n+      free (label_align);\n+      label_align = 0;\n+    }\n+\n+  max_labelno = max_label_num ();\n+  min_labelno = get_first_label_num ();\n+  label_align = (struct label_alignment *) xcalloc ((max_labelno - min_labelno + 1),\n+\t     sizeof (struct label_alignment));\n+\n+  /* If not optimizing or optimizing for size, don't assign any alignments.  */\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      rtx label = bb->head;\n+      int fallthru_frequency = 0, branch_frequency = 0, has_fallthru = 0;\n+      edge e;\n+\n+      if (GET_CODE (label) != CODE_LABEL)\n+\tcontinue;\n+      max_log = LABEL_ALIGN (label);\n+      max_skip = LABEL_ALIGN_MAX_SKIP;\n+\n+      for (e = bb->pred; e; e = e->pred_next)\n+\t{\n+\t  if (e->flags & EDGE_FALLTHRU)\n+\t    has_fallthru = 1, fallthru_frequency += EDGE_FREQUENCY (e);\n+\t  else\n+\t    branch_frequency += EDGE_FREQUENCY (e);\n+\t}\n+\n+      /* There are two purposes to align block with no fallthru incomming edge:\n+\t 1) to avoid fetch stalls when branch destination is near cache boundary\n+\t 2) to improve cache effciency in case the previous block is not executed\n+\t    (so it does not need to be in the cache).\n+\n+\t We to catch first case, we align frequently executed blocks.\n+\t To catch the second, we align blocks that are executed more frequently\n+\t than the predecesor and the predecesor is likely to not be executed\n+\t when function is called.  */\n+\n+      if (!has_fallthru\n+\t  && (branch_frequency > BB_FREQ_MAX / 10\n+\t      || (bb->frequency > BASIC_BLOCK (i - 1)->frequency * 10\n+\t\t  && (BASIC_BLOCK (i - 1)->frequency\n+\t\t      <= ENTRY_BLOCK_PTR->frequency / 2))))\n+\t{\n+\t  log = JUMP_ALIGN (label);\n+\t  if (max_log < log)\n+\t    {\n+\t      max_log = log;\n+\t      max_skip = JUMP_ALIGN_MAX_SKIP;\n+\t    }\n+\t}\n+      /* In case block is frequent and reached mostly by non-fallthru edge,\n+\t align it.  It is most likely an first block of loop.  */\n+      if (has_fallthru\n+\t  && branch_frequency + fallthru_frequency > BB_FREQ_MAX / 10\n+\t  && branch_frequency > fallthru_frequency * 5)\n+\t{\n+\t  log = LOOP_ALIGN (label);\n+\t  if (max_log < log)\n+\t    {\n+\t      max_log = log;\n+\t      max_skip = LOOP_ALIGN_MAX_SKIP;\n+\t    }\n+\t}\n+      LABEL_TO_ALIGNMENT (label) = max_log;\n+      LABEL_TO_MAX_SKIP (label) = max_skip;\n+    }\n+}\n+\f\n /* Make a pass over all insns and compute their actual lengths by shortening\n    any branches of variable length if possible.  */\n \n@@ -972,21 +1054,22 @@ shorten_branches (first)\n \n #endif\n \n-  /* We must do some computations even when not actually shortening, in\n-     order to get the alignment information for the labels.  */\n-\n-  init_insn_lengths ();\n-\n   /* Compute maximum UID and allocate label_align / uid_shuid.  */\n   max_uid = get_max_uid ();\n \n-  max_labelno = max_label_num ();\n-  min_labelno = get_first_label_num ();\n-  label_align = (struct label_alignment *)\n-    xcalloc ((max_labelno - min_labelno + 1), sizeof (struct label_alignment));\n-\n   uid_shuid = (int *) xmalloc (max_uid * sizeof *uid_shuid);\n \n+  if (max_labelno != max_label_num ())\n+    {\n+      int old = max_labelno;\n+      max_labelno = max_label_num ();\n+      label_align = (struct label_alignment *) xrealloc\n+\t(label_align,\n+\t (max_labelno - min_labelno + 1) * sizeof (struct label_alignment));\n+      memset (label_align + old + 1 - min_labelno, 0,\n+\t      sizeof (struct label_alignment) * (max_labelno - old));\n+    }\n+\n   /* Initialize label_align and set up uid_shuid to be strictly\n      monotonically rising with insn order.  */\n   /* We use max_log here to keep track of the maximum alignment we want to\n@@ -1012,6 +1095,14 @@ shorten_branches (first)\n       else if (GET_CODE (insn) == CODE_LABEL)\n \t{\n \t  rtx next;\n+\t  \n+\t  /* Merge in alignments computed by compute_alignments.  */\n+\t  log = LABEL_TO_ALIGNMENT (insn);\n+\t  if (max_log < log)\n+\t    {\n+\t      max_log = log;\n+\t      max_skip = LABEL_TO_MAX_SKIP (insn);\n+\t    }\n \n \t  log = LABEL_ALIGN (insn);\n \t  if (max_log < log)\n@@ -1063,41 +1154,6 @@ shorten_branches (first)\n \t\tbreak;\n \t      }\n \t}\n-      /* Again, we allow NOTE_INSN_LOOP_BEG - INSN - CODE_LABEL\n-\t sequences in order to handle reorg output efficiently.  */\n-      else if (GET_CODE (insn) == NOTE\n-\t       && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t{\n-\t  rtx label;\n-\t  int nest = 0;\n-\n-\t  /* Search for the label that starts the loop.\n-\t     Don't skip past the end of the loop, since that could\n-\t     lead to putting an alignment where it does not belong.\n-\t     However, a label after a nested (non-)loop would be OK.  */\n-\t  for (label = insn; label; label = NEXT_INSN (label))\n-\t    {\n-\t      if (GET_CODE (label) == NOTE\n-\t\t  && NOTE_LINE_NUMBER (label) == NOTE_INSN_LOOP_BEG)\n-\t\tnest++;\n-\t      else if (GET_CODE (label) == NOTE\n-\t\t       && NOTE_LINE_NUMBER (label) == NOTE_INSN_LOOP_END\n-\t\t       && --nest == 0)\n-\t\tbreak;\n-\t      else if (GET_CODE (label) == CODE_LABEL)\n-\t\t{\n-\t\t  log = LOOP_ALIGN (label);\n-\t\t  if (max_log < log)\n-\t\t    {\n-\t\t      max_log = log;\n-\t\t      max_skip = LOOP_ALIGN_MAX_SKIP;\n-\t\t    }\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\tcontinue;\n     }\n #ifdef HAVE_ATTR_length\n "}, {"sha": "c2cf497485d5dff80d076822815df1b418da349f", "filename": "gcc/output.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e22dc0cb9714b9c85a057d72dc4c6a00d688ab/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e22dc0cb9714b9c85a057d72dc4c6a00d688ab/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=25e22dc0cb9714b9c85a057d72dc4c6a00d688ab", "patch": "@@ -20,6 +20,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+/* Compute branch alignments based on frequency information in the CFG.  */\n+extern void compute_alignments  PARAMS ((void));\n+\n /* Initialize data in final at the beginning of a compilation.  */\n extern void init_final\t\tPARAMS ((const char *));\n "}]}