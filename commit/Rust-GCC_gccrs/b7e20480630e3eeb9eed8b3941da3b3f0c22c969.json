{"sha": "b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "node_id": "C_kwDOANBUbNoAKGI3ZTIwNDgwNjMwZTNlZWI5ZWVkOGIzOTQxZGEzYjNmMGMyMmM5Njk", "commit": {"author": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2021-11-12T12:29:00Z"}, "committer": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2021-11-12T12:29:48Z"}, "message": "openmp: Relax handling of implicit map vs. existing device mappings\n\nThis patch implements relaxing the requirements when a map with the implicit\nattribute encounters an overlapping existing map. As the OpenMP 5.0 spec\ndescribes on page 320, lines 18-27 (and 5.1 spec, page 352, lines 13-22):\n\n\"If a single contiguous part of the original storage of a list item with an\n implicit data-mapping attribute has corresponding storage in the device data\n environment prior to a task encountering the construct that is associated with\n the map clause, only that part of the original storage will have corresponding\n storage in the device data environment as a result of the map clause.\"\n\n2021-11-12  Chung-Lin Tang  <cltang@codesourcery.com>\n\ninclude/ChangeLog:\n\n\t* gomp-constants.h (GOMP_MAP_FLAG_SPECIAL_3): Define special bit macro.\n\t(GOMP_MAP_IMPLICIT): New special map kind bits value.\n\t(GOMP_MAP_FLAG_SPECIAL_BITS): Define helper mask for whole set of\n\tspecial map kind bits.\n\t(GOMP_MAP_IMPLICIT_P): New predicate macro for implicit map kinds.\n\ngcc/ChangeLog:\n\n\t* tree.h (OMP_CLAUSE_MAP_RUNTIME_IMPLICIT_P): New access macro for\n\t'implicit' bit, using 'base.deprecated_flag' field of tree_node.\n\t* tree-pretty-print.c (dump_omp_clause): Add support for printing\n\timplicit attribute in tree dumping.\n\t* gimplify.c (gimplify_adjust_omp_clauses_1):\n\tSet OMP_CLAUSE_MAP_RUNTIME_IMPLICIT_P to 1 if map clause is implicitly\n\tcreated.\n\t(gimplify_adjust_omp_clauses): Adjust place of adding implicitly created\n\tclauses, from simple append, to starting of list, after non-map clauses.\n\t* omp-low.c (lower_omp_target): Add GOMP_MAP_IMPLICIT bits into kind\n\tvalues passed to libgomp for implicit maps.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/gomp/target-implicit-map-1.c: New test.\n\t* c-c++-common/goacc/combined-reduction.c: Adjust scan test pattern.\n\t* c-c++-common/goacc/firstprivate-mappings-1.c: Likewise.\n\t* c-c++-common/goacc/mdc-1.c: Likewise.\n\t* g++.dg/goacc/firstprivate-mappings-1.C: Likewise.\n\nlibgomp/ChangeLog:\n\n\t* target.c (gomp_map_vars_existing): Add 'bool implicit' parameter, add\n\timplicit map handling to allow a \"superset\" existing map as valid case.\n\t(get_kind): Adjust to filter out GOMP_MAP_IMPLICIT bits in return value.\n\t(get_implicit): New function to extract implicit status.\n\t(gomp_map_fields_existing): Adjust arguments in calls to\n\tgomp_map_vars_existing, and add uses of get_implicit.\n\t(gomp_map_vars_internal): Likewise.\n\t* testsuite/libgomp.c-c++-common/target-implicit-map-1.c: New test.", "tree": {"sha": "22c172a9847cc76055eca0ecbd31d75fc9979273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22c172a9847cc76055eca0ecbd31d75fc9979273"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/comments", "author": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a54ce8865a885bca5ab9c4aa6ec725cd13c09901", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a54ce8865a885bca5ab9c4aa6ec725cd13c09901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a54ce8865a885bca5ab9c4aa6ec725cd13c09901"}], "stats": {"total": 206, "additions": 178, "deletions": 28}, "files": [{"sha": "4e022d860a1445ac0acf0d149520ce035d3dc882", "filename": "gcc/gimplify.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "patch": "@@ -10889,6 +10889,10 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n \t  gcc_unreachable ();\n \t}\n       OMP_CLAUSE_SET_MAP_KIND (clause, kind);\n+      /* Setting of the implicit flag for the runtime is currently disabled for\n+\t OpenACC.  */\n+      if ((gimplify_omp_ctxp->region_type & ORT_ACC) == 0)\n+\tOMP_CLAUSE_MAP_RUNTIME_IMPLICIT_P (clause) = 1;\n       if (DECL_SIZE (decl)\n \t  && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n \t{\n@@ -11504,9 +11508,15 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \tlist_p = &OMP_CLAUSE_CHAIN (c);\n     }\n \n-  /* Add in any implicit data sharing.  */\n+  /* Add in any implicit data sharing.  Implicit clauses are added at the start\n+     of the clause list, but after any non-map clauses.  */\n   struct gimplify_adjust_omp_clauses_data data;\n-  data.list_p = list_p;\n+  tree *implicit_add_list_p = orig_list_p;\n+  while (*implicit_add_list_p\n+\t && OMP_CLAUSE_CODE (*implicit_add_list_p) != OMP_CLAUSE_MAP)\n+    implicit_add_list_p = &OMP_CLAUSE_CHAIN (*implicit_add_list_p);\n+\n+  data.list_p = implicit_add_list_p;\n   data.pre_p = pre_p;\n   splay_tree_foreach (ctx->variables, gimplify_adjust_omp_clauses_1, &data);\n "}, {"sha": "63a47f62d08a3e3696c5ca679232ac1c197dd446", "filename": "gcc/omp-low.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "patch": "@@ -13168,6 +13168,19 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t    else if (integer_nonzerop (s))\n \t\t      tkind_zero = tkind;\n \t\t  }\n+\t\tif (tkind_zero == tkind\n+\t\t    && OMP_CLAUSE_MAP_RUNTIME_IMPLICIT_P (c)\n+\t\t    && (((tkind & GOMP_MAP_FLAG_SPECIAL_BITS)\n+\t\t\t & ~GOMP_MAP_IMPLICIT)\n+\t\t\t== 0))\n+\t\t  {\n+\t\t    /* If this is an implicit map, and the GOMP_MAP_IMPLICIT\n+\t\t       bits are not interfered by other special bit encodings,\n+\t\t       then turn the GOMP_IMPLICIT_BIT flag on for the runtime\n+\t\t       to see.  */\n+\t\t    tkind |= GOMP_MAP_IMPLICIT;\n+\t\t    tkind_zero = tkind;\n+\t\t  }\n \t\tbreak;\n \t      case OMP_CLAUSE_FIRSTPRIVATE:\n \t\tgcc_checking_assert (is_gimple_omp_oacc (ctx->stmt));"}, {"sha": "74ab05bc856480be27ee8b85741e5b5a03f4edfd", "filename": "gcc/testsuite/c-c++-common/goacc/combined-reduction.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fcombined-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fcombined-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fcombined-reduction.c?ref=b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "patch": "@@ -23,7 +23,7 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"omp target oacc_parallel reduction.+:v1. map.tofrom:v1\" 1 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"omp target oacc_parallel reduction.+:v1. firstprivate.n. map.tofrom:v1\" 1 \"gimple\" } } */\n /* { dg-final { scan-tree-dump-times \"acc loop reduction.+:v1. private.i.\" 1 \"gimple\" } } */\n /* { dg-final { scan-tree-dump-times \"omp target oacc_kernels map.force_tofrom:n .len: 4.. map.force_tofrom:v1 .len: 4..\" 1 \"gimple\" } } */\n /* { dg-final { scan-tree-dump-times \"acc loop reduction.+:v1. private.i.\" 1 \"gimple\" } } */"}, {"sha": "5134ef6ed6cbb089c39dbe5a3e2c465845a60aa5", "filename": "gcc/testsuite/c-c++-common/goacc/firstprivate-mappings-1.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Ffirstprivate-mappings-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Ffirstprivate-mappings-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Ffirstprivate-mappings-1.c?ref=b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "patch": "@@ -419,12 +419,7 @@ vla (int array_li)\n   copyout (array_so)\n   /* The gimplifier has created an implicit 'firstprivate' clause for the array\n      length.\n-     { dg-final { scan-tree-dump {(?n)#pragma omp target oacc_parallel map\\(from:array_so \\[len: 4\\]\\) firstprivate\\(array_li.[0-9]+\\)} omplower { target { ! c++ } } } }\n-     { dg-final { scan-tree-dump {(?n)#pragma omp target oacc_parallel map\\(from:array_so \\[len: 4\\]\\) firstprivate\\(} omplower { target { c++ } } } }\n-     (C++ computes an intermediate value, so can't scan for 'firstprivate(array_li)'.)  */\n-  /* For C, non-LP64, the gimplifier has also created a mapping for the array\n-     itself; PR90859.\n-     { dg-final { scan-tree-dump {(?n)#pragma omp target oacc_parallel map\\(from:array_so \\[len: 4\\]\\) firstprivate\\(array_li.[0-9]+\\) map\\(tofrom:\\(\\*array.[0-9]+\\) \\[len: D\\.[0-9]+\\]\\) map\\(firstprivate:array \\[pointer assign, bias: 0\\]\\) \\[} omplower { target { c && { ! lp64 } } } } } */\n+     { dg-final { scan-tree-dump {(?n)#pragma omp target oacc_parallel firstprivate\\(array_li.[0-9]+\\) map\\(from:array_so \\[len: 4\\]\\) \\[} omplower } } */\n   {\n     array_so = sizeof array;\n   }"}, {"sha": "0a123bec58f4e1aba7fc048257aef95b20f5499c", "filename": "gcc/testsuite/c-c++-common/goacc/mdc-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fmdc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fmdc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fmdc-1.c?ref=b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "patch": "@@ -45,7 +45,7 @@ t1 ()\n \n /* { dg-final { scan-tree-dump-times \"pragma omp target oacc_enter_data map.to:s .len: 32..\" 1 \"omplower\" } } */\n /* { dg-final { scan-tree-dump-times \"pragma omp target oacc_data map.tofrom:.z .len: 40.. map.struct:s .len: 1.. map.alloc:s.a .len: 8.. map.tofrom:._1 .len: 40.. map.attach:s.a .bias: 0..\" 1 \"omplower\" } } */\n-/* { dg-final { scan-tree-dump-times \"pragma omp target oacc_parallel map.attach:s.e .bias: 0.. map.tofrom:s .len: 32\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"pragma omp target oacc_parallel map.tofrom:s .len: 32.. map.attach:s.e .bias: 0..\" 1 \"omplower\" } } */\n /* { dg-final { scan-tree-dump-times \"pragma omp target oacc_enter_data map.attach:a .bias: 0..\" 1 \"omplower\" } } */\n /* { dg-final { scan-tree-dump-times \"pragma omp target oacc_exit_data map.detach:a .bias: 0..\" 1 \"omplower\" } } */\n /* { dg-final { scan-tree-dump-times \"pragma omp target oacc_enter_data map.to:a .len: 8..\" 1 \"omplower\" } } */"}, {"sha": "52944fdc65a8ff757f29a782a7e1ded79973417d", "filename": "gcc/testsuite/c-c++-common/gomp/target-implicit-map-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-implicit-map-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-implicit-map-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-implicit-map-1.c?ref=b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+#ifdef __cplusplus\n+extern \"C\"\n+#else\n+extern\n+#endif\n+void abort (void);\n+\n+int\n+main (void)\n+{\n+  #define N 5\n+  int array[N][N];\n+\n+  for (int i = 0; i < N; i++)\n+    {\n+      #pragma omp target enter data map(alloc: array[i:1][0:N])\n+\n+      #pragma omp target\n+      for (int j = 0; j < N; j++)\n+\tarray[i][j] = i * 10 + j;\n+\n+      #pragma omp target exit data map(from: array[i:1][0:N])\n+    }\n+\n+  for (int i = 0; i < N; i++)\n+    for (int j = 0; j < N; j++)\n+      if (array[i][j] != i + j)\n+\tabort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {#pragma omp target enter data map\\(alloc:array\\[[^]]+\\]\\[0\\] \\[len: [0-9]+\\]\\)} \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(i\\) map\\(tofrom:array \\[len: [0-9]+\\]\\[implicit\\]\\)} \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump {#pragma omp target exit data map\\(from:array\\[[^]]+\\]\\[0\\] \\[len: [0-9]+\\]\\)} \"gimple\" } } */"}, {"sha": "99a3bd472f7bbd59293b7e95495567ce0d30ca9c", "filename": "gcc/testsuite/g++.dg/goacc/firstprivate-mappings-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Ffirstprivate-mappings-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Ffirstprivate-mappings-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Ffirstprivate-mappings-1.C?ref=b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "patch": "@@ -416,7 +416,7 @@ vla (int &array_li)\n   copyout (array_so)\n   /* The gimplifier has created an implicit 'firstprivate' clause for the array\n      length.\n-     { dg-final { scan-tree-dump {(?n)#pragma omp target oacc_parallel map\\(from:array_so \\[len: 4\\]\\) firstprivate\\(} omplower } }\n+     { dg-final { scan-tree-dump {(?n)#pragma omp target oacc_parallel firstprivate\\([^)]+\\) map\\(from:array_so \\[len: 4\\]\\)} omplower } }\n      (C++ computes an intermediate value, so can't scan for 'firstprivate(array_li)'.)  */\n   {\n     array_so = sizeof array;"}, {"sha": "fcc0796e3a198f14aef08a9de0b0dbaad61ff1d6", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "patch": "@@ -971,6 +971,9 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n \t\t\t     spc, flags, false);\n \t  pp_right_bracket (pp);\n \t}\n+      if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_MAP\n+\t  && OMP_CLAUSE_MAP_RUNTIME_IMPLICIT_P (clause))\n+\tpp_string (pp, \"[implicit]\");\n       pp_right_paren (pp);\n       break;\n "}, {"sha": "03719b18c67544e6ced68e6c9beb533b47ee0fb4", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "patch": "@@ -1689,6 +1689,11 @@ class auto_suppress_location_wrappers\n    map clause.  */\n #define OMP_CLAUSE_MAP_IMPLICIT(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->base.default_def_flag)\n+/* Nonzero if this map clause is to be indicated to the runtime as 'implicit',\n+   due to being created through implicit data-mapping rules in the middle-end.\n+   NOTE: this is different than OMP_CLAUSE_MAP_IMPLICIT.  */\n+#define OMP_CLAUSE_MAP_RUNTIME_IMPLICIT_P(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->base.deprecated_flag)\n \n /* True on an OMP_CLAUSE_USE_DEVICE_PTR with an OpenACC 'if_present'\n    clause.  */"}, {"sha": "3e42d7123aea51b7346569d55ee1ae7b68a0ae2b", "filename": "include/gomp-constants.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "patch": "@@ -40,11 +40,22 @@\n #define GOMP_MAP_FLAG_SPECIAL_0\t\t(1 << 2)\n #define GOMP_MAP_FLAG_SPECIAL_1\t\t(1 << 3)\n #define GOMP_MAP_FLAG_SPECIAL_2\t\t(1 << 4)\n+#define GOMP_MAP_FLAG_SPECIAL_3\t\t(1 << 5)\n #define GOMP_MAP_FLAG_SPECIAL_4\t\t(1 << 6)\n #define GOMP_MAP_FLAG_SPECIAL\t\t(GOMP_MAP_FLAG_SPECIAL_1 \\\n \t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL_0)\n #define GOMP_MAP_DEEP_COPY\t\t(GOMP_MAP_FLAG_SPECIAL_4 \\\n \t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL_2)\n+/* This value indicates the map was created implicitly according to\n+   OpenMP rules.  */\n+#define GOMP_MAP_IMPLICIT\t\t(GOMP_MAP_FLAG_SPECIAL_3 \\\n+\t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL_4)\n+/* Mask for entire set of special map kind bits.  */\n+#define GOMP_MAP_FLAG_SPECIAL_BITS\t(GOMP_MAP_FLAG_SPECIAL_0 \\\n+\t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL_1 \\\n+\t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL_2 \\\n+\t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL_3 \\\n+\t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL_4)\n /* Flag to force a specific behavior (or else, trigger a run-time error).  */\n #define GOMP_MAP_FLAG_FORCE\t\t(1 << 7)\n \n@@ -186,6 +197,9 @@ enum gomp_map_kind\n #define GOMP_MAP_ALWAYS_P(X) \\\n   (GOMP_MAP_ALWAYS_TO_P (X) || ((X) == GOMP_MAP_ALWAYS_FROM))\n \n+#define GOMP_MAP_IMPLICIT_P(X) \\\n+  (((X) & GOMP_MAP_FLAG_SPECIAL_BITS) == GOMP_MAP_IMPLICIT)\n+\n \n /* Asynchronous behavior.  Keep in sync with\n    libgomp/{openacc.h,openacc.f90,openacc_lib.h}:acc_async_t.  */"}, {"sha": "3c1eee23a442711dc85c346129a5c154ddcb93ba", "filename": "libgomp/target.c", "status": "modified", "additions": 57, "deletions": 17, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "patch": "@@ -539,7 +539,7 @@ static inline void\n gomp_map_vars_existing (struct gomp_device_descr *devicep,\n \t\t\tstruct goacc_asyncqueue *aq, splay_tree_key oldn,\n \t\t\tsplay_tree_key newn, struct target_var_desc *tgt_var,\n-\t\t\tunsigned char kind, bool always_to_flag,\n+\t\t\tunsigned char kind, bool always_to_flag, bool implicit,\n \t\t\tstruct gomp_coalesce_buf *cbuf,\n \t\t\thtab_t *refcount_set)\n {\n@@ -550,11 +550,22 @@ gomp_map_vars_existing (struct gomp_device_descr *devicep,\n   tgt_var->always_copy_from = GOMP_MAP_ALWAYS_FROM_P (kind);\n   tgt_var->is_attach = false;\n   tgt_var->offset = newn->host_start - oldn->host_start;\n-  tgt_var->length = newn->host_end - newn->host_start;\n+\n+  /* For implicit maps, old contained in new is valid.  */\n+  bool implicit_subset = (implicit\n+\t\t\t  && newn->host_start <= oldn->host_start\n+\t\t\t  && oldn->host_end <= newn->host_end);\n+  if (implicit_subset)\n+    tgt_var->length = oldn->host_end - oldn->host_start;\n+  else\n+    tgt_var->length = newn->host_end - newn->host_start;\n \n   if ((kind & GOMP_MAP_FLAG_FORCE)\n-      || oldn->host_start > newn->host_start\n-      || oldn->host_end < newn->host_end)\n+      /* For implicit maps, old contained in new is valid.  */\n+      || !(implicit_subset\n+\t   /* Otherwise, new contained inside old is considered valid.  */\n+\t   || (oldn->host_start <= newn->host_start\n+\t       && newn->host_end <= oldn->host_end)))\n     {\n       gomp_mutex_unlock (&devicep->lock);\n       gomp_fatal (\"Trying to map into device [%p..%p) object when \"\n@@ -564,20 +575,42 @@ gomp_map_vars_existing (struct gomp_device_descr *devicep,\n     }\n \n   if (GOMP_MAP_ALWAYS_TO_P (kind) || always_to_flag)\n-    gomp_copy_host2dev (devicep, aq,\n-\t\t\t(void *) (oldn->tgt->tgt_start + oldn->tgt_offset\n-\t\t\t\t  + newn->host_start - oldn->host_start),\n-\t\t\t(void *) newn->host_start,\n-\t\t\tnewn->host_end - newn->host_start, false, cbuf);\n+    {\n+      /* Implicit + always should not happen. If this does occur, below\n+\t address/length adjustment is a TODO.  */\n+      assert (!implicit_subset);\n+\n+      gomp_copy_host2dev (devicep, aq,\n+\t\t\t  (void *) (oldn->tgt->tgt_start + oldn->tgt_offset\n+\t\t\t\t    + newn->host_start - oldn->host_start),\n+\t\t\t  (void *) newn->host_start,\n+\t\t\t  newn->host_end - newn->host_start, false, cbuf);\n+    }\n \n   gomp_increment_refcount (oldn, refcount_set);\n }\n \n static int\n get_kind (bool short_mapkind, void *kinds, int idx)\n {\n-  return short_mapkind ? ((unsigned short *) kinds)[idx]\n-\t\t       : ((unsigned char *) kinds)[idx];\n+  if (!short_mapkind)\n+    return ((unsigned char *) kinds)[idx];\n+\n+  int val = ((unsigned short *) kinds)[idx];\n+  if (GOMP_MAP_IMPLICIT_P (val))\n+    val &= ~GOMP_MAP_IMPLICIT;\n+  return val;\n+}\n+\n+\n+static bool\n+get_implicit (bool short_mapkind, void *kinds, int idx)\n+{\n+  if (!short_mapkind)\n+    return false;\n+\n+  int val = ((unsigned short *) kinds)[idx];\n+  return GOMP_MAP_IMPLICIT_P (val);\n }\n \n static void\n@@ -631,19 +664,22 @@ gomp_map_fields_existing (struct target_mem_desc *tgt,\n   struct splay_tree_s *mem_map = &devicep->mem_map;\n   struct splay_tree_key_s cur_node;\n   int kind;\n+  bool implicit;\n   const bool short_mapkind = true;\n   const int typemask = short_mapkind ? 0xff : 0x7;\n \n   cur_node.host_start = (uintptr_t) hostaddrs[i];\n   cur_node.host_end = cur_node.host_start + sizes[i];\n   splay_tree_key n2 = splay_tree_lookup (mem_map, &cur_node);\n   kind = get_kind (short_mapkind, kinds, i);\n+  implicit = get_implicit (short_mapkind, kinds, i);\n   if (n2\n       && n2->tgt == n->tgt\n       && n2->host_start - n->host_start == n2->tgt_offset - n->tgt_offset)\n     {\n       gomp_map_vars_existing (devicep, aq, n2, &cur_node, &tgt->list[i],\n-\t\t\t      kind & typemask, false, cbuf, refcount_set);\n+\t\t\t      kind & typemask, false, implicit, cbuf,\n+\t\t\t      refcount_set);\n       return;\n     }\n   if (sizes[i] == 0)\n@@ -659,7 +695,8 @@ gomp_map_fields_existing (struct target_mem_desc *tgt,\n \t\t == n2->tgt_offset - n->tgt_offset)\n \t    {\n \t      gomp_map_vars_existing (devicep, aq, n2, &cur_node, &tgt->list[i],\n-\t\t\t\t      kind & typemask, false, cbuf, refcount_set);\n+\t\t\t\t      kind & typemask, false, implicit, cbuf,\n+\t\t\t\t      refcount_set);\n \t      return;\n \t    }\n \t}\n@@ -671,7 +708,8 @@ gomp_map_fields_existing (struct target_mem_desc *tgt,\n \t  && n2->host_start - n->host_start == n2->tgt_offset - n->tgt_offset)\n \t{\n \t  gomp_map_vars_existing (devicep, aq, n2, &cur_node, &tgt->list[i],\n-\t\t\t\t  kind & typemask, false, cbuf, refcount_set);\n+\t\t\t\t  kind & typemask, false, implicit, cbuf,\n+\t\t\t\t  refcount_set);\n \t  return;\n \t}\n     }\n@@ -903,6 +941,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n   for (i = 0; i < mapnum; i++)\n     {\n       int kind = get_kind (short_mapkind, kinds, i);\n+      bool implicit = get_implicit (short_mapkind, kinds, i);\n       if (hostaddrs[i] == NULL\n \t  || (kind & typemask) == GOMP_MAP_FIRSTPRIVATE_INT)\n \t{\n@@ -1085,8 +1124,8 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t}\n \t    }\n \t  gomp_map_vars_existing (devicep, aq, n, &cur_node, &tgt->list[i],\n-\t\t\t\t  kind & typemask, always_to_cnt > 0, NULL,\n-\t\t\t\t  refcount_set);\n+\t\t\t\t  kind & typemask, always_to_cnt > 0, implicit,\n+\t\t\t\t  NULL, refcount_set);\n \t  i += always_to_cnt;\n \t}\n       else\n@@ -1256,6 +1295,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \telse if (tgt->list[i].key == NULL)\n \t  {\n \t    int kind = get_kind (short_mapkind, kinds, i);\n+\t    bool implicit = get_implicit (short_mapkind, kinds, i);\n \t    if (hostaddrs[i] == NULL)\n \t      continue;\n \t    switch (kind & typemask)\n@@ -1415,7 +1455,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t    splay_tree_key n = splay_tree_lookup (mem_map, k);\n \t    if (n && n->refcount != REFCOUNT_LINK)\n \t      gomp_map_vars_existing (devicep, aq, n, k, &tgt->list[i],\n-\t\t\t\t      kind & typemask, false, cbufp,\n+\t\t\t\t      kind & typemask, false, implicit, cbufp,\n \t\t\t\t      refcount_set);\n \t    else\n \t      {"}, {"sha": "f2e72936862397e07990bdf6d0e903b9f29698aa", "filename": "libgomp/testsuite/libgomp.c-c++-common/target-implicit-map-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-implicit-map-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e20480630e3eeb9eed8b3941da3b3f0c22c969/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-implicit-map-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-implicit-map-1.c?ref=b7e20480630e3eeb9eed8b3941da3b3f0c22c969", "patch": "@@ -0,0 +1,31 @@\n+#ifdef __cplusplus\n+extern \"C\"\n+#else\n+extern\n+#endif\n+void abort (void);\n+\n+int\n+main (void)\n+{\n+  #define N 5\n+  int array[N][N];\n+\n+  for (int i = 0; i < N; i++)\n+    {\n+      #pragma omp target enter data map(alloc: array[i:1][0:N])\n+\n+      #pragma omp target\n+      for (int j = 0; j < N; j++)\n+\tarray[i][j] = i + j;\n+\n+      #pragma omp target exit data map(from: array[i:1][0:N])\n+    }\n+\n+  for (int i = 0; i < N; i++)\n+    for (int j = 0; j < N; j++)\n+      if (array[i][j] != i + j)\n+\tabort ();\n+\n+  return 0;\n+}"}]}