{"sha": "bf245bf4848da017739e3298121f7482c6dd2ab0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYyNDViZjQ4NDhkYTAxNzczOWUzMjk4MTIxZjc0ODJjNmRkMmFiMA==", "commit": {"author": {"name": "Pat Haugen", "email": "pthaugen@us.ibm.com", "date": "2014-04-28T20:21:29Z"}, "committer": {"name": "Pat Haugen", "email": "pthaugen@gcc.gnu.org", "date": "2014-04-28T20:21:29Z"}, "message": "sync.md (AINT mode_iterator): Move definition.\n\n\t* config/rs6000/sync.md (AINT mode_iterator): Move definition.\n\t(loadsync_<mode>): Change mode.\n\t(load_quadpti, store_quadpti): New.\n\t(atomic_load<mode>, atomic_store<mode>): Add support for TI mode.\n\t* config/rs6000/rs6000.md (unspec enum): Add UNSPEC_LSQ.\n\nFrom-SVN: r209873", "tree": {"sha": "a7d57360418a1eb6e93cf70c776e537350b847d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7d57360418a1eb6e93cf70c776e537350b847d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf245bf4848da017739e3298121f7482c6dd2ab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf245bf4848da017739e3298121f7482c6dd2ab0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf245bf4848da017739e3298121f7482c6dd2ab0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf245bf4848da017739e3298121f7482c6dd2ab0/comments", "author": null, "committer": null, "parents": [{"sha": "bc76a4d5b51a8d0777122ab5f53bb38483453abd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc76a4d5b51a8d0777122ab5f53bb38483453abd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc76a4d5b51a8d0777122ab5f53bb38483453abd"}], "stats": {"total": 118, "additions": 101, "deletions": 17}, "files": [{"sha": "e5f77cac18caf3e3f55ffb1f9f6921d5378ec7f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf245bf4848da017739e3298121f7482c6dd2ab0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf245bf4848da017739e3298121f7482c6dd2ab0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf245bf4848da017739e3298121f7482c6dd2ab0", "patch": "@@ -1,3 +1,11 @@\n+2014-04-28  Pat Haugen  <pthaugen@us.ibm.com>\n+\n+\t* config/rs6000/sync.md (AINT mode_iterator): Move definition.\n+\t(loadsync_<mode>): Change mode.\n+\t(load_quadpti, store_quadpti): New.\n+\t(atomic_load<mode>, atomic_store<mode>): Add support for TI mode.\n+\t* config/rs6000/rs6000.md (unspec enum): Add UNSPEC_LSQ.\n+\n 2014-04-28  Martin Jambor  <mjambor@suse.cz>\n \n \t* tree-sra.c (sra_modify_expr): Generate new memory accesses with"}, {"sha": "8c384b3808abf82b4254b26f3fbc75a196de0a68", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf245bf4848da017739e3298121f7482c6dd2ab0/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf245bf4848da017739e3298121f7482c6dd2ab0/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=bf245bf4848da017739e3298121f7482c6dd2ab0", "patch": "@@ -629,14 +629,14 @@\n        (match_test \"offsettable_nonstrict_memref_p (op)\")))\n \n ;; Return 1 if the operand is suitable for load/store quad memory.\n-;; This predicate only checks for non-atomic loads/stores.\n+;; This predicate only checks for non-atomic loads/stores (not lqarx/stqcx).\n (define_predicate \"quad_memory_operand\"\n   (match_code \"mem\")\n {\n   rtx addr, op0, op1;\n   int ret;\n \n-  if (!TARGET_QUAD_MEMORY)\n+  if (!TARGET_QUAD_MEMORY && !TARGET_SYNC_TI)\n     ret = 0;\n \n   else if (!memory_operand (op, mode))"}, {"sha": "e853bc4f92ce6d987d3de83af3fc7f9be942f259", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf245bf4848da017739e3298121f7482c6dd2ab0/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf245bf4848da017739e3298121f7482c6dd2ab0/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=bf245bf4848da017739e3298121f7482c6dd2ab0", "patch": "@@ -134,6 +134,7 @@\n    UNSPEC_DIVEUO\n    UNSPEC_UNPACK_128BIT\n    UNSPEC_PACK_128BIT\n+   UNSPEC_LSQ\n   ])\n \n ;;"}, {"sha": "63152ed04d20e9a8299b4a24b3358f48ae15d3d6", "filename": "gcc/config/rs6000/sync.md", "status": "modified", "additions": 90, "deletions": 15, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf245bf4848da017739e3298121f7482c6dd2ab0/gcc%2Fconfig%2Frs6000%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf245bf4848da017739e3298121f7482c6dd2ab0/gcc%2Fconfig%2Frs6000%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsync.md?ref=bf245bf4848da017739e3298121f7482c6dd2ab0", "patch": "@@ -107,29 +107,74 @@\n   \"isync\"\n   [(set_attr \"type\" \"isync\")])\n \n+;; Types that we should provide atomic instructions for.\n+(define_mode_iterator AINT [QI\n+\t\t\t    HI\n+\t\t\t    SI\n+\t\t\t    (DI \"TARGET_POWERPC64\")\n+\t\t\t    (TI \"TARGET_SYNC_TI\")])\n+\n ;; The control dependency used for load dependency described\n ;; in B.2.3 of the Power ISA 2.06B.\n (define_insn \"loadsync_<mode>\"\n-  [(unspec_volatile:BLK [(match_operand:INT1 0 \"register_operand\" \"r\")]\n+  [(unspec_volatile:BLK [(match_operand:AINT 0 \"register_operand\" \"r\")]\n \t\t\tUNSPECV_ISYNC)\n    (clobber (match_scratch:CC 1 \"=y\"))]\n   \"\"\n   \"cmpw %1,%0,%0\\;bne- %1,$+4\\;isync\"\n   [(set_attr \"type\" \"isync\")\n    (set_attr \"length\" \"12\")])\n \n+(define_insn \"load_quadpti\"\n+  [(set (match_operand:PTI 0 \"quad_int_reg_operand\" \"=&r\")\n+\t(unspec:PTI\n+\t [(match_operand:TI 1 \"quad_memory_operand\" \"wQ\")] UNSPEC_LSQ))]\n+  \"TARGET_SYNC_TI\n+   && !reg_mentioned_p (operands[0], operands[1])\"\n+  \"lq %0,%1\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_expand \"atomic_load<mode>\"\n-  [(set (match_operand:INT1 0 \"register_operand\" \"\")\t\t;; output\n-\t(match_operand:INT1 1 \"memory_operand\" \"\"))\t\t;; memory\n+  [(set (match_operand:AINT 0 \"register_operand\" \"\")\t\t;; output\n+\t(match_operand:AINT 1 \"memory_operand\" \"\"))\t\t;; memory\n    (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\t\t;; model\n   \"\"\n {\n+  if (<MODE>mode == TImode && !TARGET_SYNC_TI)\n+    FAIL;\n+\n   enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n \n   if (model == MEMMODEL_SEQ_CST)\n     emit_insn (gen_hwsync ());\n \n-  emit_move_insn (operands[0], operands[1]);\n+  if (<MODE>mode != TImode)\n+    emit_move_insn (operands[0], operands[1]);\n+  else\n+    {\n+      rtx op0 = operands[0];\n+      rtx op1 = operands[1];\n+      rtx pti_reg = gen_reg_rtx (PTImode);\n+\n+      // Can't have indexed address for 'lq'\n+      if (indexed_address (XEXP (op1, 0), TImode))\n+\t{\n+\t  rtx old_addr = XEXP (op1, 0);\n+\t  rtx new_addr = force_reg (Pmode, old_addr);\n+\t  operands[1] = op1 = replace_equiv_address (op1, new_addr);\n+\t}\n+\n+      emit_insn (gen_load_quadpti (pti_reg, op1));\n+\n+      if (WORDS_BIG_ENDIAN)\n+\temit_move_insn (op0, gen_lowpart (TImode, pti_reg));\n+      else\n+\t{\n+\t  emit_move_insn (gen_lowpart (DImode, op0), gen_highpart (DImode, pti_reg));\n+\t  emit_move_insn (gen_highpart (DImode, op0), gen_lowpart (DImode, pti_reg));\n+\t}\n+    }\n \n   switch (model)\n     {\n@@ -146,12 +191,24 @@\n   DONE;\n })\n \n+(define_insn \"store_quadpti\"\n+  [(set (match_operand:PTI 0 \"quad_memory_operand\" \"=wQ\")\n+\t(unspec:PTI\n+\t [(match_operand:PTI 1 \"quad_int_reg_operand\" \"r\")] UNSPEC_LSQ))]\n+  \"TARGET_SYNC_TI\"\n+  \"stq %1,%0\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_expand \"atomic_store<mode>\"\n-  [(set (match_operand:INT1 0 \"memory_operand\" \"\")\t\t;; memory\n-\t(match_operand:INT1 1 \"register_operand\" \"\"))\t\t;; input\n+  [(set (match_operand:AINT 0 \"memory_operand\" \"\")\t\t;; memory\n+\t(match_operand:AINT 1 \"register_operand\" \"\"))\t\t;; input\n    (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\t\t;; model\n   \"\"\n {\n+  if (<MODE>mode == TImode && !TARGET_SYNC_TI)\n+    FAIL;\n+\n   enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n   switch (model)\n     {\n@@ -166,7 +223,33 @@\n     default:\n       gcc_unreachable ();\n     }\n-  emit_move_insn (operands[0], operands[1]);\n+  if (<MODE>mode != TImode)\n+    emit_move_insn (operands[0], operands[1]);\n+  else\n+    {\n+      rtx op0 = operands[0];\n+      rtx op1 = operands[1];\n+      rtx pti_reg = gen_reg_rtx (PTImode);\n+\n+      // Can't have indexed address for 'stq'\n+      if (indexed_address (XEXP (op0, 0), TImode))\n+\t{\n+\t  rtx old_addr = XEXP (op0, 0);\n+\t  rtx new_addr = force_reg (Pmode, old_addr);\n+\t  operands[0] = op0 = replace_equiv_address (op0, new_addr);\n+\t}\n+\n+      if (WORDS_BIG_ENDIAN)\n+\temit_move_insn (pti_reg, gen_lowpart (PTImode, op1));\n+      else\n+\t{\n+\t  emit_move_insn (gen_lowpart (DImode, pti_reg), gen_highpart (DImode, op1));\n+\t  emit_move_insn (gen_highpart (DImode, pti_reg), gen_lowpart (DImode, op1));\n+\t}\n+\n+      emit_insn (gen_store_quadpti (gen_lowpart (PTImode, op0), pti_reg));\n+    }\n+\n   DONE;\n })\n \n@@ -180,14 +263,6 @@\n \t\t\t      SI\n \t\t\t      (DI \"TARGET_POWERPC64\")])\n \n-;; Types that we should provide atomic instructions for.\n-\n-(define_mode_iterator AINT [QI\n-\t\t\t    HI\n-\t\t\t    SI\n-\t\t\t    (DI \"TARGET_POWERPC64\")\n-\t\t\t    (TI \"TARGET_SYNC_TI\")])\n-\n (define_insn \"load_locked<mode>\"\n   [(set (match_operand:ATOMIC 0 \"int_reg_operand\" \"=r\")\n \t(unspec_volatile:ATOMIC"}]}