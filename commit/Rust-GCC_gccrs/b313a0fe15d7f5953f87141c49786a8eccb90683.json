{"sha": "b313a0fe15d7f5953f87141c49786a8eccb90683", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMxM2EwZmUxNWQ3ZjU5NTNmODcxNDFjNDk3ODZhOGVjY2I5MDY4Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-10-06T06:01:27Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-10-06T06:01:27Z"}, "message": "c-decl.c (warn_missing_noreturn): Remove.\n\n        * c-decl.c (warn_missing_noreturn): Remove.\n        (c_expand_body): Don't set or check can_reach_end.\n        * c-tree.h (warn_missing_noreturn): Move ...\n        * flags.h: ... here.\n        (can_reach_end): Remove.\n        * flow.c (check_function_return_warnings): New.\n        (make_edges): No edge to exit for noreturn sibcalls.\n        * function.c (expand_function_end): Save the return value\n        clobber instruction.\n        (mark_function_status): Mark it.\n        * function.h (struct function): Add x_clobber_return_insn.\n        * jump.c (can_reach_end): Remove.\n        (calculate_can_reach_end): Remove.\n        (jump_optimize_1): Don't call it.\n        * output.h (check_function_return_warnings): Declare.\n        * toplev.c (warn_missing_noreturn): Move from c-decl.c\n        (rest_of_compilation): Call check_function_return_warnings.\n\nFrom-SVN: r36750", "tree": {"sha": "2a84a351f2dd9e081499cea34c0929d359328dd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a84a351f2dd9e081499cea34c0929d359328dd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b313a0fe15d7f5953f87141c49786a8eccb90683", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b313a0fe15d7f5953f87141c49786a8eccb90683", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b313a0fe15d7f5953f87141c49786a8eccb90683", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b313a0fe15d7f5953f87141c49786a8eccb90683/comments", "author": null, "committer": null, "parents": [{"sha": "63c16fc50c5cf446269da98919ccc7016bd4498f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63c16fc50c5cf446269da98919ccc7016bd4498f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63c16fc50c5cf446269da98919ccc7016bd4498f"}], "stats": {"total": 196, "additions": 89, "deletions": 107}, "files": [{"sha": "a33743dfb18b12b40a2a99c0b7efb89a4bbc9e7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b313a0fe15d7f5953f87141c49786a8eccb90683", "patch": "@@ -1,3 +1,23 @@\n+2000-10-05  Richard Henderson  <rth@cygnus.com>\n+\n+\t* c-decl.c (warn_missing_noreturn): Remove.\n+\t(c_expand_body): Don't set or check can_reach_end.\n+\t* c-tree.h (warn_missing_noreturn): Move ...\n+\t* flags.h: ... here.\n+\t(can_reach_end): Remove.\n+\t* flow.c (check_function_return_warnings): New.\n+\t(make_edges): No edge to exit for noreturn sibcalls.\n+\t* function.c (expand_function_end): Save the return value\n+\tclobber instruction.\n+\t(mark_function_status): Mark it.\n+\t* function.h (struct function): Add x_clobber_return_insn.\n+\t* jump.c (can_reach_end): Remove.\n+\t(calculate_can_reach_end): Remove.\n+\t(jump_optimize_1): Don't call it.\n+\t* output.h (check_function_return_warnings): Declare.\n+\t* toplev.c (warn_missing_noreturn): Move from c-decl.c\n+\t(rest_of_compilation): Call check_function_return_warnings.\n+\n 2000-10-05  Richard Henderson  <rth@cygnus.com>\n \n \t* Makefile.in (NM_FOR_TARGET): New."}, {"sha": "9dbaa2846857c9d16cfc951ac437ff9f0bb4099a", "filename": "gcc/c-decl.c", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=b313a0fe15d7f5953f87141c49786a8eccb90683", "patch": "@@ -403,10 +403,6 @@ int warn_cast_qual;\n \n int warn_bad_function_cast;\n \n-/* Warn about functions which might be candidates for attribute noreturn.  */\n-\n-int warn_missing_noreturn;\n-\n /* Warn about traditional constructs whose meanings changed in ANSI C.  */\n \n int warn_traditional;\n@@ -6760,9 +6756,6 @@ c_expand_body (fndecl, nested_p)\n   /* Generate rtl for function exit.  */\n   expand_function_end (input_filename, lineno, 0);\n \n-  /* So we can tell if jump_optimize sets it to 1.  */\n-  can_reach_end = 0;\n-\n   /* If this is a nested function, protect the local variables in the stack\n      above us from being collected while we're compiling this function.  */\n   if (nested_p)\n@@ -6775,25 +6768,11 @@ c_expand_body (fndecl, nested_p)\n   if (nested_p)\n     ggc_pop_context ();\n \n-  current_function_returns_null |= can_reach_end;\n-\n-  if (warn_missing_noreturn\n-      && !TREE_THIS_VOLATILE (fndecl)\n-      && !current_function_returns_null\n-      && !current_function_returns_value)\n-    warning (\"function might be possible candidate for attribute `noreturn'\");\n-\n-  if (TREE_THIS_VOLATILE (fndecl) && current_function_returns_null)\n-    warning (\"`noreturn' function does return\");\n-  else if (warn_return_type && can_reach_end\n-\t   && !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (fndecl))))\n-    /* If this function returns non-void and control can drop through,\n-       complain.  */\n-    warning (\"control reaches end of non-void function\");\n   /* With just -W, complain only if function returns both with\n      and without a value.  */\n-  else if (extra_warnings\n-\t   && current_function_returns_value && current_function_returns_null)\n+  if (extra_warnings\n+      && current_function_returns_value\n+      && current_function_returns_null)\n     warning (\"this function may return with or without a value\");\n \n   /* If requested, warn about function definitions where the function will"}, {"sha": "b8adce15454f6aae02dc5b472f3bd7901ead2d67", "filename": "gcc/c-tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=b313a0fe15d7f5953f87141c49786a8eccb90683", "patch": "@@ -342,10 +342,6 @@ extern int warn_cast_qual;\n \n extern int warn_bad_function_cast;\n \n-/* Warn about functions which might be candidates for attribute noreturn. */\n-\n-extern int warn_missing_noreturn;\n-\n /* Warn about traditional constructs whose meanings changed in ANSI C.  */\n \n extern int warn_traditional;"}, {"sha": "7fec383bdd732c20d5198a96318bb64def0442e2", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=b313a0fe15d7f5953f87141c49786a8eccb90683", "patch": "@@ -132,6 +132,10 @@ extern int warn_switch;\n \n extern int warn_return_type;\n \n+/* Warn about functions which might be candidates for attribute noreturn. */\n+\n+extern int warn_missing_noreturn;\n+\n /* Nonzero means warn about pointer casts that increase the required\n    alignment of the target type (and might therefore lead to a crash\n    due to a misaligned access).  */\n@@ -547,11 +551,6 @@ extern int flag_renumber_insns;\n \n extern int frame_pointer_needed;\n \n-/* Set nonzero if jump_optimize finds that control falls through\n-   at the end of the function.  */\n-\n-extern int can_reach_end;\n-\n /* Nonzero if GCC must add code to check memory access (used by Checker).  */\n \n extern int flag_check_memory_usage;"}, {"sha": "52eed8d179cd953162b2dbf059fd31d83f2abebc", "filename": "gcc/flow.c", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b313a0fe15d7f5953f87141c49786a8eccb90683", "patch": "@@ -511,6 +511,43 @@ find_basic_blocks (f, nregs, file)\n #endif\n }\n \n+void\n+check_function_return_warnings ()\n+{\n+  if (warn_missing_noreturn\n+      && !TREE_THIS_VOLATILE (cfun->decl)\n+      && EXIT_BLOCK_PTR->pred == NULL)\n+    warning (\"function might be possible candidate for attribute `noreturn'\");\n+\n+  /* If we have a path to EXIT, then we do return.  */\n+  if (TREE_THIS_VOLATILE (cfun->decl)\n+      && EXIT_BLOCK_PTR->pred != NULL)\n+    warning (\"`noreturn' function does return\");\n+\n+  /* If the clobber_return_insn appears in some basic block, then we\n+     do reach the end without returning a value.  */\n+  else if (warn_return_type\n+\t   && cfun->x_clobber_return_insn != NULL\n+\t   && EXIT_BLOCK_PTR->pred != NULL)\n+    {\n+      int max_uid = get_max_uid ();\n+\n+      /* If clobber_return_insn was excised by jump1, then renumber_insns\n+\t can make max_uid smaller than the number still recorded in our rtx.\n+\t That's fine, since this is a quick way of verifying that the insn\n+\t is no longer in the chain.  */\n+      if (INSN_UID (cfun->x_clobber_return_insn) < max_uid)\n+\t{\n+\t  /* Recompute insn->block mapping, since the initial mapping is\n+\t     set before we delete unreachable blocks.  */\n+\t  compute_bb_for_insn (max_uid);\n+\n+\t  if (BLOCK_FOR_INSN (cfun->x_clobber_return_insn) != NULL)\n+\t    warning (\"control reaches end of non-void function\");\n+\t}\n+    }\n+}\n+\n /* Count the basic blocks of the function.  */\n \n static int\n@@ -1115,8 +1152,11 @@ make_edges (label_value_list)\n \t wouldn't have created the sibling call in the first place.  */\n \n       if (code == CALL_INSN && SIBLING_CALL_P (insn))\n-\tmake_edge (edge_cache, bb, EXIT_BLOCK_PTR,\n-\t\t   EDGE_ABNORMAL | EDGE_ABNORMAL_CALL);\n+\t{\n+\t  if (! find_reg_note (insn, REG_NORETURN, NULL_RTX))\n+\t    make_edge (edge_cache, bb, EXIT_BLOCK_PTR,\n+\t\t       EDGE_ABNORMAL | EDGE_ABNORMAL_CALL);\n+\t}\n       else\n \n       /* If this is a CALL_INSN, then mark it as reaching the active EH"}, {"sha": "85a18bf0b8739937fca265ee2d0962f3a464593a", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=b313a0fe15d7f5953f87141c49786a8eccb90683", "patch": "@@ -6658,12 +6658,20 @@ expand_function_end (filename, line, end_bindings)\n \n   if (return_label)\n     {\n+      rtx before, after;\n+\n       /* Before the return label, clobber the return registers so that\n          they are not propogated live to the rest of the function.  This\n \t can only happen with functions that drop through; if there had\n \t been a return statement, there would have either been a return\n \t rtx, or a jump to the return label.  */\n+\n+      before = get_last_insn ();\n       clobber_return_register ();\n+      after = get_last_insn ();\n+\n+      if (before != after)\n+\tcfun->x_clobber_return_insn = after;\n \n       emit_label (return_label);\n     }\n@@ -7429,6 +7437,7 @@ mark_function_status (p)\n   ggc_mark_tree (p->x_context_display);\n   ggc_mark_tree (p->x_trampoline_list);\n   ggc_mark_rtx (p->epilogue_delay_list);\n+  ggc_mark_rtx (p->x_clobber_return_insn);\n \n   mark_temp_slot (p->x_temp_slots);\n "}, {"sha": "f3124a7b71ab1f127f865b7397d4dfc475a1bb96", "filename": "gcc/function.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=b313a0fe15d7f5953f87141c49786a8eccb90683", "patch": "@@ -373,6 +373,11 @@ struct function\n      needed by inner routines.  */\n   rtx x_arg_pointer_save_area;\n \n+  /* If the function returns non-void, we will emit a clobber of the\n+     return registers just in case the user fell off the end without\n+     returning a proper value.  This is that insn.  */\n+  rtx x_clobber_return_insn;\n+\n   /* Offset to end of allocated area of stack frame.\n      If stack grows down, this is the address of the last stack slot allocated.\n      If stack grows up, this is the address for the next slot.  */"}, {"sha": "8574f161526573ebc919f5bd1ea6b4dd2f5ffad7", "filename": "gcc/jump.c", "status": "modified", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=b313a0fe15d7f5953f87141c49786a8eccb90683", "patch": "@@ -95,10 +95,6 @@ static rtx *jump_chain;\n \n static int max_jump_chain;\n \n-/* Set nonzero by jump_optimize if control can fall through\n-   to the end of the function.  */\n-int can_reach_end;\n-\n /* Indicates whether death notes are significant in cross jump analysis.\n    Normally they are not significant, because of A and B jump to C,\n    and R dies in A, it must die in B.  But this might not be true after\n@@ -112,7 +108,6 @@ static void delete_barrier_successors\tPARAMS ((rtx));\n static void mark_all_labels\t\tPARAMS ((rtx, int));\n static rtx delete_unreferenced_labels\tPARAMS ((rtx));\n static void delete_noop_moves\t\tPARAMS ((rtx));\n-static int calculate_can_reach_end\tPARAMS ((rtx, int));\n static int duplicate_loop_exit_test\tPARAMS ((rtx));\n static void find_cross_jump\t\tPARAMS ((rtx, rtx, int, rtx *, rtx *));\n static void do_cross_jump\t\tPARAMS ((rtx, rtx, rtx));\n@@ -743,13 +738,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t}\n   }\n \n-  /* CAN_REACH_END is persistent for each function.  Once set it should\n-     not be cleared.  This is especially true for the case where we\n-     delete the NOTE_FUNCTION_END note.  CAN_REACH_END is cleared by\n-     the front-end before compiling each function.  */\n-  if (! minimal && calculate_can_reach_end (last_insn, optimize != 0))\n-    can_reach_end = 1;\n-\n end:\n   /* Clean up.  */\n   free (jump_chain);\n@@ -1062,66 +1050,6 @@ delete_noop_moves (f)\n     }\n }\n \n-/* See if there is still a NOTE_INSN_FUNCTION_END in this function.\n-   If so indicate that this function can drop off the end by returning\n-   1, else return 0.\n-\n-   CHECK_DELETED indicates whether we must check if the note being\n-   searched for has the deleted flag set.\n-\n-   DELETE_FINAL_NOTE indicates whether we should delete the note\n-   if we find it.  */\n-\n-static int\n-calculate_can_reach_end (last, delete_final_note)\n-     rtx last;\n-     int delete_final_note;\n-{\n-  rtx insn = last;\n-  int n_labels = 1;\n-\n-  while (insn != NULL_RTX)\n-    {\n-      int ok = 0;\n-\n-      /* One label can follow the end-note: the return label.  */\n-      if (GET_CODE (insn) == CODE_LABEL && n_labels-- > 0)\n-\tok = 1;\n-      /* Ordinary insns can follow it if returning a structure.  */\n-      else if (GET_CODE (insn) == INSN)\n-\tok = 1;\n-      /* If machine uses explicit RETURN insns, no epilogue,\n-\t then one of them follows the note.  */\n-      else if (GET_CODE (insn) == JUMP_INSN\n-\t       && GET_CODE (PATTERN (insn)) == RETURN)\n-\tok = 1;\n-      /* A barrier can follow the return insn.  */\n-      else if (GET_CODE (insn) == BARRIER)\n-\tok = 1;\n-      /* Other kinds of notes can follow also.  */\n-      else if (GET_CODE (insn) == NOTE\n-\t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_FUNCTION_END)\n-\tok = 1;\n-\n-      if (ok != 1)\n-\tbreak;\n-\n-      insn = PREV_INSN (insn);\n-    }\n-\n-  /* See if we backed up to the appropriate type of note.  */\n-  if (insn != NULL_RTX\n-      && GET_CODE (insn) == NOTE\n-      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_END)\n-    {\n-      if (delete_final_note)\n-\tdelete_insn (insn);\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n /* LOOP_START is a NOTE_INSN_LOOP_BEG note that is followed by an unconditional\n    jump.  Assume that this unconditional jump is to the exit test code.  If\n    the code is sufficiently simple, make a copy of it before INSN,"}, {"sha": "e5d2ae6b3ce0772863b5eaf6b099c37568fe3732", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=b313a0fe15d7f5953f87141c49786a8eccb90683", "patch": "@@ -136,6 +136,7 @@ extern void find_basic_blocks\t\tPARAMS ((rtx, int, FILE *));\n extern void cleanup_cfg\t\t\tPARAMS ((rtx));\n extern void free_basic_block_vars     PARAMS ((int));\n extern void set_block_num             PARAMS ((rtx, int));\n+extern void check_function_return_warnings PARAMS ((void));\n #endif\n \n /* Functions in varasm.c.  */"}, {"sha": "4e7ec89b96078ed3bb806c84b5c4014597c9c741", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b313a0fe15d7f5953f87141c49786a8eccb90683/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b313a0fe15d7f5953f87141c49786a8eccb90683", "patch": "@@ -1405,6 +1405,10 @@ int warn_padded;\n \n int warn_disabled_optimization;\n \n+/* Warn about functions which might be candidates for attribute noreturn.  */\n+\n+int warn_missing_noreturn;\n+\n /* Likewise for -W.  */\n \n lang_independent_options W_options[] =\n@@ -3209,6 +3213,7 @@ rest_of_compilation (decl)\n \n   find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n   cleanup_cfg (insns);\n+  check_function_return_warnings ();\n \n   close_dump_file (DFI_cfg, print_rtl_with_bb, insns);\n "}]}