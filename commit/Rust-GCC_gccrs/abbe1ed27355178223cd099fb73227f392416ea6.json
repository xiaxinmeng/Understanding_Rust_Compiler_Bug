{"sha": "abbe1ed27355178223cd099fb73227f392416ea6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJiZTFlZDI3MzU1MTc4MjIzY2QwOTlmYjczMjI3ZjM5MjQxNmVhNg==", "commit": {"author": {"name": "Stam Markianos-Wright", "email": "stam.markianos-wright@arm.com", "date": "2020-01-10T19:23:41Z"}, "committer": {"name": "Stam Markianos-Wright", "email": "stammark@gcc.gnu.org", "date": "2020-01-10T19:23:41Z"}, "message": "config.gcc: Add arm_bf16.h.\n\n2020-01-10  Stam Markianos-Wright  <stam.markianos-wright@arm.com>\n\n\t* config.gcc: Add arm_bf16.h.\n\t* config/aarch64/aarch64-builtins.c\n\t(aarch64_simd_builtin_std_type): Add BFmode.\n\t(aarch64_init_simd_builtin_types): Define element types for vector\n\ttypes.\n\t(aarch64_init_bf16_types): New function.\n\t(aarch64_general_init_builtins): Add arm_init_bf16_types function call.\n\t* config/aarch64/aarch64-modes.def: Add BFmode and V4BF, V8BF vector\n\tmodes.\n\t* config/aarch64/aarch64-simd-builtin-types.def: Add BF SIMD types.\n\t* config/aarch64/aarch64-simd.md: Add BF vector types to NEON move\n\tpatterns.\n\t* config/aarch64/aarch64.h (AARCH64_VALID_SIMD_DREG_MODE): Add V4BF.\n\t(AARCH64_VALID_SIMD_QREG_MODE): Add V8BF.\n\t* config/aarch64/aarch64.c\n\t(aarch64_classify_vector_mode): Add support for BF types.\n\t(aarch64_gimplify_va_arg_expr): Add support for BF types.\n\t(aarch64_vq_mode): Add support for BF types.\n\t(aarch64_simd_container_mode): Add support for BF types.\n\t(aarch64_mangle_type): Add support for BF scalar type.\n\t* config/aarch64/aarch64.md: Add BFmode to movhf pattern.\n\t* config/aarch64/arm_bf16.h: New file.\n\t* config/aarch64/arm_neon.h: Add arm_bf16.h and Bfloat vector types.\n\t* config/aarch64/iterators.md: Add BF types to mode attributes.\n\t(HFBF, GPF_TF_F16_MOV, VDMOV, VQMOV, VQMOV_NO2Em VALL_F16MOV): New.\n\n2020-01-10  Stam Markianos-Wright  <stam.markianos-wright@arm.com>\n\n\t* g++.dg/abi/mangle-neon-aarch64.C: Add Bfloat SIMD types to test.\n\t* g++.dg/ext/arm-bf16/bf16-mangle-aarch64-1.C: New test.\n\t* gcc.target/aarch64/bfloat16_scalar_1.c: New test.\n\t* gcc.target/aarch64/bfloat16_scalar_2.c: New test.\n\t* gcc.target/aarch64/bfloat16_scalar_3.c: New test.\n\t* gcc.target/aarch64/bfloat16_scalar_4.c: New test.\n\t* gcc.target/aarch64/bfloat16_simd_1.c: New test.\n\t* gcc.target/aarch64/bfloat16_simd_2.c: New test.\n\t* gcc.target/aarch64/bfloat16_simd_3.c: New test.\n\nFrom-SVN: r280129", "tree": {"sha": "48d44a41894a46d1897b6b55956de9f942fa6171", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48d44a41894a46d1897b6b55956de9f942fa6171"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abbe1ed27355178223cd099fb73227f392416ea6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abbe1ed27355178223cd099fb73227f392416ea6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abbe1ed27355178223cd099fb73227f392416ea6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abbe1ed27355178223cd099fb73227f392416ea6/comments", "author": {"login": "Stammark", "id": 30555766, "node_id": "MDQ6VXNlcjMwNTU1NzY2", "avatar_url": "https://avatars.githubusercontent.com/u/30555766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Stammark", "html_url": "https://github.com/Stammark", "followers_url": "https://api.github.com/users/Stammark/followers", "following_url": "https://api.github.com/users/Stammark/following{/other_user}", "gists_url": "https://api.github.com/users/Stammark/gists{/gist_id}", "starred_url": "https://api.github.com/users/Stammark/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Stammark/subscriptions", "organizations_url": "https://api.github.com/users/Stammark/orgs", "repos_url": "https://api.github.com/users/Stammark/repos", "events_url": "https://api.github.com/users/Stammark/events{/privacy}", "received_events_url": "https://api.github.com/users/Stammark/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "337ea6b216afd412b85f3fda78a36467ffe4a817", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/337ea6b216afd412b85f3fda78a36467ffe4a817", "html_url": "https://github.com/Rust-GCC/gccrs/commit/337ea6b216afd412b85f3fda78a36467ffe4a817"}], "stats": {"total": 875, "additions": 829, "deletions": 46}, "files": [{"sha": "0f10afcd0fe10de9d8d306c957d5bee0d81d0801", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -1,3 +1,31 @@\n+2020-01-10  Stam Markianos-Wright  <stam.markianos-wright@arm.com>\n+\n+\t* config.gcc: Add arm_bf16.h.\n+\t* config/aarch64/aarch64-builtins.c\n+\t(aarch64_simd_builtin_std_type): Add BFmode.\n+\t(aarch64_init_simd_builtin_types): Define element types for vector\n+\ttypes.\n+\t(aarch64_init_bf16_types): New function.\n+\t(aarch64_general_init_builtins): Add arm_init_bf16_types function call.\n+\t* config/aarch64/aarch64-modes.def: Add BFmode and V4BF, V8BF vector\n+\tmodes.\n+\t* config/aarch64/aarch64-simd-builtin-types.def: Add BF SIMD types.\n+\t* config/aarch64/aarch64-simd.md: Add BF vector types to NEON move\n+\tpatterns.\n+\t* config/aarch64/aarch64.h (AARCH64_VALID_SIMD_DREG_MODE): Add V4BF.\n+\t(AARCH64_VALID_SIMD_QREG_MODE): Add V8BF.\n+\t* config/aarch64/aarch64.c\n+\t(aarch64_classify_vector_mode): Add support for BF types.\n+\t(aarch64_gimplify_va_arg_expr): Add support for BF types.\n+\t(aarch64_vq_mode): Add support for BF types.\n+\t(aarch64_simd_container_mode): Add support for BF types.\n+\t(aarch64_mangle_type): Add support for BF scalar type.\n+\t* config/aarch64/aarch64.md: Add BFmode to movhf pattern.\n+\t* config/aarch64/arm_bf16.h: New file.\n+\t* config/aarch64/arm_neon.h: Add arm_bf16.h and Bfloat vector types.\n+\t* config/aarch64/iterators.md: Add BF types to mode attributes.\n+\t(HFBF, GPF_TF_F16_MOV, VDMOV, VQMOV, VQMOV_NO2Em VALL_F16MOV): New.\n+\n 2020-01-10  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/93173 - incorrect tree sharing."}, {"sha": "30bea511d412712d1450ff842fa48a53ee97ff2c", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -315,7 +315,7 @@ m32c*-*-*)\n         ;;\n aarch64*-*-*)\n \tcpu_type=aarch64\n-\textra_headers=\"arm_fp16.h arm_neon.h arm_acle.h arm_sve.h\"\n+\textra_headers=\"arm_fp16.h arm_neon.h arm_bf16.h arm_acle.h arm_sve.h\"\n \tc_target_objs=\"aarch64-c.o\"\n \tcxx_target_objs=\"aarch64-c.o\"\n \td_target_objs=\"aarch64-d.o\""}, {"sha": "f0e0461b7f0459fbd88b1d8ecdd90e02140451ea", "filename": "gcc/config/aarch64/aarch64-builtins.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -68,6 +68,9 @@\n #define hi_UP    E_HImode\n #define hf_UP    E_HFmode\n #define qi_UP    E_QImode\n+#define bf_UP    E_BFmode\n+#define v4bf_UP  E_V4BFmode\n+#define v8bf_UP  E_V8BFmode\n #define UP(X) X##_UP\n \n #define SIMD_MAX_BUILTIN_ARGS 5\n@@ -568,6 +571,10 @@ static tree aarch64_simd_intXI_type_node = NULL_TREE;\n tree aarch64_fp16_type_node = NULL_TREE;\n tree aarch64_fp16_ptr_type_node = NULL_TREE;\n \n+/* Back-end node type for brain float (bfloat) types.  */\n+tree aarch64_bf16_type_node = NULL_TREE;\n+tree aarch64_bf16_ptr_type_node = NULL_TREE;\n+\n /* Wrapper around add_builtin_function.  NAME is the name of the built-in\n    function, TYPE is the function type, and CODE is the function subcode\n    (relative to AARCH64_BUILTIN_GENERAL).  */\n@@ -659,6 +666,8 @@ aarch64_simd_builtin_std_type (machine_mode mode,\n       return float_type_node;\n     case E_DFmode:\n       return double_type_node;\n+    case E_BFmode:\n+      return aarch64_bf16_type_node;\n     default:\n       gcc_unreachable ();\n     }\n@@ -750,6 +759,10 @@ aarch64_init_simd_builtin_types (void)\n   aarch64_simd_types[Float64x1_t].eltype = double_type_node;\n   aarch64_simd_types[Float64x2_t].eltype = double_type_node;\n \n+  /* Init Bfloat vector types with underlying __bf16 type.  */\n+  aarch64_simd_types[Bfloat16x4_t].eltype = aarch64_bf16_type_node;\n+  aarch64_simd_types[Bfloat16x8_t].eltype = aarch64_bf16_type_node;\n+\n   for (i = 0; i < nelts; i++)\n     {\n       tree eltype = aarch64_simd_types[i].eltype;\n@@ -1059,6 +1072,19 @@ aarch64_init_fp16_types (void)\n   aarch64_fp16_ptr_type_node = build_pointer_type (aarch64_fp16_type_node);\n }\n \n+/* Initialize the backend REAL_TYPE type supporting bfloat types.  */\n+static void\n+aarch64_init_bf16_types (void)\n+{\n+  aarch64_bf16_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (aarch64_bf16_type_node) = 16;\n+  SET_TYPE_MODE (aarch64_bf16_type_node, BFmode);\n+  layout_type (aarch64_bf16_type_node);\n+\n+  lang_hooks.types.register_builtin_type (aarch64_bf16_type_node, \"__bf16\");\n+  aarch64_bf16_ptr_type_node = build_pointer_type (aarch64_bf16_type_node);\n+}\n+\n /* Pointer authentication builtins that will become NOP on legacy platform.\n    Currently, these builtins are for internal use only (libgcc EH unwinder).  */\n \n@@ -1214,6 +1240,8 @@ aarch64_general_init_builtins (void)\n \n   aarch64_init_fp16_types ();\n \n+  aarch64_init_bf16_types ();\n+\n   if (TARGET_SIMD)\n     aarch64_init_simd_builtins ();\n "}, {"sha": "1eeb8d884520b1a53b8a580f165d42858c03228c", "filename": "gcc/config/aarch64/aarch64-modes.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -69,6 +69,13 @@ VECTOR_MODES (FLOAT, 16);     /*            V4SF V2DF.  */\n VECTOR_MODE (FLOAT, DF, 1);   /*                 V1DF.  */\n VECTOR_MODE (FLOAT, HF, 2);   /*                 V2HF.  */\n \n+/* Bfloat16 modes.  */\n+FLOAT_MODE (BF, 2, 0);\n+ADJUST_FLOAT_FORMAT (BF, &arm_bfloat_half_format);\n+\n+VECTOR_MODE (FLOAT, BF, 4);   /*\t\t V4BF.  */\n+VECTOR_MODE (FLOAT, BF, 8);   /*\t\t V8BF.  */\n+\n /* Oct Int: 256-bit integer mode needed for 32-byte vector arguments.  */\n INT_MODE (OI, 32);\n "}, {"sha": "e885755bc927d1174dce8d490636df463b76d2f8", "filename": "gcc/config/aarch64/aarch64-simd-builtin-types.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Faarch64-simd-builtin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Faarch64-simd-builtin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd-builtin-types.def?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -50,3 +50,5 @@\n   ENTRY (Float32x4_t, V4SF, none, 13)\n   ENTRY (Float64x1_t, V1DF, none, 13)\n   ENTRY (Float64x2_t, V2DF, none, 13)\n+  ENTRY (Bfloat16x4_t, V4BF, none, 14)\n+  ENTRY (Bfloat16x8_t, V8BF, none, 14)"}, {"sha": "2989096b170364dc7cbcd3675e36cc81ded33e28", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -19,8 +19,8 @@\n ;; <http://www.gnu.org/licenses/>.\n \n (define_expand \"mov<mode>\"\n-  [(set (match_operand:VALL_F16 0 \"nonimmediate_operand\")\n-\t(match_operand:VALL_F16 1 \"general_operand\"))]\n+  [(set (match_operand:VALL_F16MOV 0 \"nonimmediate_operand\")\n+\t(match_operand:VALL_F16MOV 1 \"general_operand\"))]\n   \"TARGET_SIMD\"\n   \"\n   /* Force the operand into a register if it is not an\n@@ -101,10 +101,10 @@\n   [(set_attr \"type\" \"neon_dup<q>\")]\n )\n \n-(define_insn \"*aarch64_simd_mov<VD:mode>\"\n-  [(set (match_operand:VD 0 \"nonimmediate_operand\"\n+(define_insn \"*aarch64_simd_mov<VDMOV:mode>\"\n+  [(set (match_operand:VDMOV 0 \"nonimmediate_operand\"\n \t\t\"=w, m,  m,  w, ?r, ?w, ?r, w\")\n-\t(match_operand:VD 1 \"general_operand\"\n+\t(match_operand:VDMOV 1 \"general_operand\"\n \t\t\"m,  Dz, w,  w,  w,  r,  r, Dn\"))]\n   \"TARGET_SIMD\n    && (register_operand (operands[0], <MODE>mode)\n@@ -129,10 +129,10 @@\n \t\t     mov_reg, neon_move<q>\")]\n )\n \n-(define_insn \"*aarch64_simd_mov<VQ:mode>\"\n-  [(set (match_operand:VQ 0 \"nonimmediate_operand\"\n+(define_insn \"*aarch64_simd_mov<VQMOV:mode>\"\n+  [(set (match_operand:VQMOV 0 \"nonimmediate_operand\"\n \t\t\"=w, Umn,  m,  w, ?r, ?w, ?r, w\")\n-\t(match_operand:VQ 1 \"general_operand\"\n+\t(match_operand:VQMOV 1 \"general_operand\"\n \t\t\"m,  Dz, w,  w,  w,  r,  r, Dn\"))]\n   \"TARGET_SIMD\n    && (register_operand (operands[0], <MODE>mode)\n@@ -234,8 +234,8 @@\n \n \n (define_split\n-  [(set (match_operand:VQ 0 \"register_operand\" \"\")\n-      (match_operand:VQ 1 \"register_operand\" \"\"))]\n+  [(set (match_operand:VQMOV 0 \"register_operand\" \"\")\n+      (match_operand:VQMOV 1 \"register_operand\" \"\"))]\n   \"TARGET_SIMD && reload_completed\n    && GP_REGNUM_P (REGNO (operands[0]))\n    && GP_REGNUM_P (REGNO (operands[1]))\"\n@@ -246,8 +246,8 @@\n })\n \n (define_split\n-  [(set (match_operand:VQ 0 \"register_operand\" \"\")\n-        (match_operand:VQ 1 \"register_operand\" \"\"))]\n+  [(set (match_operand:VQMOV 0 \"register_operand\" \"\")\n+        (match_operand:VQMOV 1 \"register_operand\" \"\"))]\n   \"TARGET_SIMD && reload_completed\n    && ((FP_REGNUM_P (REGNO (operands[0])) && GP_REGNUM_P (REGNO (operands[1])))\n        || (GP_REGNUM_P (REGNO (operands[0])) && FP_REGNUM_P (REGNO (operands[1]))))\"\n@@ -258,8 +258,8 @@\n })\n \n (define_expand \"@aarch64_split_simd_mov<mode>\"\n-  [(set (match_operand:VQ 0)\n-        (match_operand:VQ 1))]\n+  [(set (match_operand:VQMOV 0)\n+        (match_operand:VQMOV 1))]\n   \"TARGET_SIMD\"\n   {\n     rtx dst = operands[0];\n@@ -295,8 +295,8 @@\n (define_insn \"aarch64_simd_mov_from_<mode>low\"\n   [(set (match_operand:<VHALF> 0 \"register_operand\" \"=r\")\n         (vec_select:<VHALF>\n-          (match_operand:VQ 1 \"register_operand\" \"w\")\n-          (match_operand:VQ 2 \"vect_par_cnst_lo_half\" \"\")))]\n+          (match_operand:VQMOV 1 \"register_operand\" \"w\")\n+          (match_operand:VQMOV 2 \"vect_par_cnst_lo_half\" \"\")))]\n   \"TARGET_SIMD && reload_completed\"\n   \"umov\\t%0, %1.d[0]\"\n   [(set_attr \"type\" \"neon_to_gp<q>\")\n@@ -306,8 +306,8 @@\n (define_insn \"aarch64_simd_mov_from_<mode>high\"\n   [(set (match_operand:<VHALF> 0 \"register_operand\" \"=r\")\n         (vec_select:<VHALF>\n-          (match_operand:VQ 1 \"register_operand\" \"w\")\n-          (match_operand:VQ 2 \"vect_par_cnst_hi_half\" \"\")))]\n+          (match_operand:VQMOV 1 \"register_operand\" \"w\")\n+          (match_operand:VQMOV 2 \"vect_par_cnst_hi_half\" \"\")))]\n   \"TARGET_SIMD && reload_completed\"\n   \"umov\\t%0, %1.d[1]\"\n   [(set_attr \"type\" \"neon_to_gp<q>\")\n@@ -1471,8 +1471,8 @@\n ;; On big-endian this is { zeroes, operand }\n \n (define_insn \"move_lo_quad_internal_<mode>\"\n-  [(set (match_operand:VQ_NO2E 0 \"register_operand\" \"=w,w,w\")\n-\t(vec_concat:VQ_NO2E\n+  [(set (match_operand:VQMOV_NO2E 0 \"register_operand\" \"=w,w,w\")\n+\t(vec_concat:VQMOV_NO2E\n \t  (match_operand:<VHALF> 1 \"register_operand\" \"w,r,r\")\n \t  (vec_duplicate:<VHALF> (const_int 0))))]\n   \"TARGET_SIMD && !BYTES_BIG_ENDIAN\"\n@@ -1501,8 +1501,8 @@\n )\n \n (define_insn \"move_lo_quad_internal_be_<mode>\"\n-  [(set (match_operand:VQ_NO2E 0 \"register_operand\" \"=w,w,w\")\n-\t(vec_concat:VQ_NO2E\n+  [(set (match_operand:VQMOV_NO2E 0 \"register_operand\" \"=w,w,w\")\n+\t(vec_concat:VQMOV_NO2E\n \t  (vec_duplicate:<VHALF> (const_int 0))\n \t  (match_operand:<VHALF> 1 \"register_operand\" \"w,r,r\")))]\n   \"TARGET_SIMD && BYTES_BIG_ENDIAN\"\n@@ -1531,8 +1531,8 @@\n )\n \n (define_expand \"move_lo_quad_<mode>\"\n-  [(match_operand:VQ 0 \"register_operand\")\n-   (match_operand:VQ 1 \"register_operand\")]\n+  [(match_operand:VQMOV 0 \"register_operand\")\n+   (match_operand:VQMOV 1 \"register_operand\")]\n   \"TARGET_SIMD\"\n {\n   if (BYTES_BIG_ENDIAN)\n@@ -1549,11 +1549,11 @@\n ;; For big-endian this is { operand1, operand2 }\n \n (define_insn \"aarch64_simd_move_hi_quad_<mode>\"\n-  [(set (match_operand:VQ 0 \"register_operand\" \"+w,w\")\n-        (vec_concat:VQ\n+  [(set (match_operand:VQMOV 0 \"register_operand\" \"+w,w\")\n+        (vec_concat:VQMOV\n           (vec_select:<VHALF>\n                 (match_dup 0)\n-                (match_operand:VQ 2 \"vect_par_cnst_lo_half\" \"\"))\n+                (match_operand:VQMOV 2 \"vect_par_cnst_lo_half\" \"\"))\n \t  (match_operand:<VHALF> 1 \"register_operand\" \"w,r\")))]\n   \"TARGET_SIMD && !BYTES_BIG_ENDIAN\"\n   \"@\n@@ -1563,12 +1563,12 @@\n )\n \n (define_insn \"aarch64_simd_move_hi_quad_be_<mode>\"\n-  [(set (match_operand:VQ 0 \"register_operand\" \"+w,w\")\n-        (vec_concat:VQ\n+  [(set (match_operand:VQMOV 0 \"register_operand\" \"+w,w\")\n+        (vec_concat:VQMOV\n \t  (match_operand:<VHALF> 1 \"register_operand\" \"w,r\")\n           (vec_select:<VHALF>\n                 (match_dup 0)\n-                (match_operand:VQ 2 \"vect_par_cnst_lo_half\" \"\"))))]\n+                (match_operand:VQMOV 2 \"vect_par_cnst_lo_half\" \"\"))))]\n   \"TARGET_SIMD && BYTES_BIG_ENDIAN\"\n   \"@\n    ins\\\\t%0.d[1], %1.d[0]\n@@ -1577,7 +1577,7 @@\n )\n \n (define_expand \"move_hi_quad_<mode>\"\n- [(match_operand:VQ 0 \"register_operand\")\n+ [(match_operand:VQMOV 0 \"register_operand\")\n   (match_operand:<VHALF> 1 \"register_operand\")]\n  \"TARGET_SIMD\"\n {"}, {"sha": "47eb0bb18983fb27a5b7d2db1e8d268bfe5ef060", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -1693,6 +1693,7 @@ aarch64_classify_vector_mode (machine_mode mode)\n     case E_V2SImode:\n     /* ...E_V1DImode doesn't exist.  */\n     case E_V4HFmode:\n+    case E_V4BFmode:\n     case E_V2SFmode:\n     case E_V1DFmode:\n     /* 128-bit Advanced SIMD vectors.  */\n@@ -1701,6 +1702,7 @@ aarch64_classify_vector_mode (machine_mode mode)\n     case E_V4SImode:\n     case E_V2DImode:\n     case E_V8HFmode:\n+    case E_V8BFmode:\n     case E_V4SFmode:\n     case E_V2DFmode:\n       return TARGET_SIMD ? VEC_ADVSIMD : 0;\n@@ -15596,6 +15598,10 @@ aarch64_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n \t  field_t = aarch64_fp16_type_node;\n \t  field_ptr_t = aarch64_fp16_ptr_type_node;\n \t  break;\n+\tcase E_BFmode:\n+\t  field_t = aarch64_bf16_type_node;\n+\t  field_ptr_t = aarch64_bf16_ptr_type_node;\n+\t  break;\n \tcase E_V2SImode:\n \tcase E_V4SImode:\n \t    {\n@@ -16109,6 +16115,8 @@ aarch64_vq_mode (scalar_mode mode)\n       return V4SFmode;\n     case E_HFmode:\n       return V8HFmode;\n+    case E_BFmode:\n+      return V8BFmode;\n     case E_SImode:\n       return V4SImode;\n     case E_HImode:\n@@ -16144,6 +16152,8 @@ aarch64_simd_container_mode (scalar_mode mode, poly_int64 width)\n \t    return V2SFmode;\n \t  case E_HFmode:\n \t    return V4HFmode;\n+\t  case E_BFmode:\n+\t    return V4BFmode;\n \t  case E_SImode:\n \t    return V2SImode;\n \t  case E_HImode:\n@@ -16258,9 +16268,14 @@ aarch64_mangle_type (const_tree type)\n   if (lang_hooks.types_compatible_p (CONST_CAST_TREE (type), va_list_type))\n     return \"St9__va_list\";\n \n-  /* Half-precision float.  */\n+  /* Half-precision floating point types.  */\n   if (TREE_CODE (type) == REAL_TYPE && TYPE_PRECISION (type) == 16)\n-    return \"Dh\";\n+    {\n+      if (TYPE_MODE (type) == BFmode)\n+\treturn \"u6__bf16\";\n+      else\n+\treturn \"Dh\";\n+    }\n \n   /* Mangle AArch64-specific internal types.  TYPE_NAME is non-NULL_TREE for\n      builtin types.  */"}, {"sha": "eb1eca4b2feb6ab3ed2b6db4fbbc400c7673defd", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -1136,13 +1136,13 @@ extern enum aarch64_code_model aarch64_cmodel;\n #define AARCH64_VALID_SIMD_DREG_MODE(MODE) \\\n   ((MODE) == V2SImode || (MODE) == V4HImode || (MODE) == V8QImode \\\n    || (MODE) == V2SFmode || (MODE) == V4HFmode || (MODE) == DImode \\\n-   || (MODE) == DFmode)\n+   || (MODE) == DFmode || (MODE) == V4BFmode)\n \n /* Modes valid for AdvSIMD Q registers.  */\n #define AARCH64_VALID_SIMD_QREG_MODE(MODE) \\\n   ((MODE) == V4SImode || (MODE) == V8HImode || (MODE) == V16QImode \\\n    || (MODE) == V4SFmode || (MODE) == V8HFmode || (MODE) == V2DImode \\\n-   || (MODE) == V2DFmode)\n+   || (MODE) == V2DFmode || (MODE) == V8BFmode)\n \n #define ENDIAN_LANE_N(NUNITS, N) \\\n   (BYTES_BIG_ENDIAN ? NUNITS - 1 - N : N)\n@@ -1190,6 +1190,11 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n extern tree aarch64_fp16_type_node;\n extern tree aarch64_fp16_ptr_type_node;\n \n+/* This type is the user-visible __bf16, and a pointer to that type.  Defined\n+   in aarch64-builtins.c.  */\n+extern tree aarch64_bf16_type_node;\n+extern tree aarch64_bf16_ptr_type_node;\n+\n /* The generic unwind code in libgcc does not initialize the frame pointer.\n    So in order to unwind a function using a frame pointer, the very first\n    function that is unwound must save the frame pointer.  That way the frame"}, {"sha": "c0b7010bcd38022c7f0016697cf8dd864c35682b", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -1310,8 +1310,8 @@\n })\n \n (define_expand \"mov<mode>\"\n-  [(set (match_operand:GPF_TF_F16 0 \"nonimmediate_operand\")\n-\t(match_operand:GPF_TF_F16 1 \"general_operand\"))]\n+  [(set (match_operand:GPF_TF_F16_MOV 0 \"nonimmediate_operand\")\n+\t(match_operand:GPF_TF_F16_MOV 1 \"general_operand\"))]\n   \"\"\n   {\n     if (!TARGET_FLOAT)\n@@ -1327,11 +1327,11 @@\n   }\n )\n \n-(define_insn \"*movhf_aarch64\"\n-  [(set (match_operand:HF 0 \"nonimmediate_operand\" \"=w,w  , w,?r,w,w  ,w  ,w,m,r,m ,r\")\n-\t(match_operand:HF 1 \"general_operand\"      \"Y ,?rY,?r, w,w,Ufc,Uvi,m,w,m,rY,r\"))]\n-  \"TARGET_FLOAT && (register_operand (operands[0], HFmode)\n-    || aarch64_reg_or_fp_zero (operands[1], HFmode))\"\n+(define_insn \"*mov<mode>_aarch64\"\n+  [(set (match_operand:HFBF 0 \"nonimmediate_operand\" \"=w,w  , w,?r,w,w  ,w  ,w,m,r,m ,r\")\n+\t(match_operand:HFBF 1 \"general_operand\"      \"Y ,?rY,?r, w,w,Ufc,Uvi,m,w,m,rY,r\"))]\n+  \"TARGET_FLOAT && (register_operand (operands[0], <MODE>mode)\n+    || aarch64_reg_or_fp_zero (operands[1], <MODE>mode))\"\n   \"@\n    movi\\\\t%0.4h, #0\n    fmov\\\\t%h0, %w1"}, {"sha": "3759c0d1cb449a7f0125cc2a1433127564d66622", "filename": "gcc/config/aarch64/arm_bf16.h", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Farm_bf16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Farm_bf16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Farm_bf16.h?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -0,0 +1,32 @@\n+/* Arm BF16 instrinsics include file.\n+\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by Arm.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _AARCH64_BF16_H_\n+#define _AARCH64_BF16_H_\n+\n+typedef __bf16 bfloat16_t;\n+\n+#endif"}, {"sha": "eaba156e26cf35b07b96972fe2741a9c00d6caa9", "filename": "gcc/config/aarch64/arm_neon.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Farm_neon.h?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -73,6 +73,9 @@ typedef __fp16 float16_t;\n typedef float float32_t;\n typedef double float64_t;\n \n+typedef __Bfloat16x4_t bfloat16x4_t;\n+typedef __Bfloat16x8_t bfloat16x8_t;\n+\n typedef struct int8x8x2_t\n {\n   int8x8_t val[2];\n@@ -34606,6 +34609,8 @@ vrnd64xq_f64 (float64x2_t __a)\n \n #pragma GCC pop_options\n \n+#include \"arm_bf16.h\"\n+\n #undef __aarch64_vget_lane_any\n \n #undef __aarch64_vdup_lane_any"}, {"sha": "b9843b83c5f1453739f7b1a8e35193b59884f912", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -57,9 +57,16 @@\n ;; Iterator for all scalar floating point modes (HF, SF, DF)\n (define_mode_iterator GPF_HF [HF SF DF])\n \n+;; Iterator for all 16-bit scalar floating point modes (HF, BF)\n+(define_mode_iterator HFBF [HF BF])\n+\n ;; Iterator for all scalar floating point modes (HF, SF, DF and TF)\n (define_mode_iterator GPF_TF_F16 [HF SF DF TF])\n \n+;; Iterator for all scalar floating point modes suitable for moving, including\n+;; special BF type (HF, SF, DF, TF and BF)\n+(define_mode_iterator GPF_TF_F16_MOV [HF BF SF DF TF])\n+\n ;; Double vector modes.\n (define_mode_iterator VDF [V2SF V4HF])\n \n@@ -79,6 +86,9 @@\n ;; Double vector modes.\n (define_mode_iterator VD [V8QI V4HI V4HF V2SI V2SF])\n \n+;; Double vector modes suitable for moving.  Includes BFmode.\n+(define_mode_iterator VDMOV [V8QI V4HI V4HF V4BF V2SI V2SF])\n+\n ;; All modes stored in registers d0-d31.\n (define_mode_iterator DREG [V8QI V4HI V4HF V2SI V2SF DF])\n \n@@ -97,6 +107,12 @@\n ;; Copy of the above.\n (define_mode_iterator VQ2 [V16QI V8HI V4SI V2DI V8HF V4SF V2DF])\n \n+;; Quad vector modes suitable for moving.  Includes BFmode.\n+(define_mode_iterator VQMOV [V16QI V8HI V4SI V2DI V8HF V8BF V4SF V2DF])\n+\n+;; VQMOV without 2-element modes.\n+(define_mode_iterator VQMOV_NO2E [V16QI V8HI V4SI V8HF V8BF V4SF])\n+\n ;; Quad integer vector modes.\n (define_mode_iterator VQ_I [V16QI V8HI V4SI V2DI])\n \n@@ -160,6 +176,11 @@\n (define_mode_iterator VALL_F16 [V8QI V16QI V4HI V8HI V2SI V4SI V2DI\n \t\t\t\tV4HF V8HF V2SF V4SF V2DF])\n \n+;; All Advanced SIMD modes suitable for moving, loading, and storing,\n+;; including special Bfloat vector types.\n+(define_mode_iterator VALL_F16MOV [V8QI V16QI V4HI V8HI V2SI V4SI V2DI\n+\t\t\t\t   V4HF V8HF V4BF V8BF V2SF V4SF V2DF])\n+\n ;; The VALL_F16 modes except the 128-bit 2-element ones.\n (define_mode_iterator VALL_F16_NO_V2Q [V8QI V16QI V4HI V8HI V2SI V4SI\n \t\t\t\tV4HF V8HF V2SF V4SF])\n@@ -873,6 +894,7 @@\n \t\t\t  (V2SI \"2\") (V4SI \"4\")\n \t\t\t\t     (V2DI \"2\")\n \t\t\t  (V4HF \"4\") (V8HF \"8\")\n+\t\t\t  (V4BF \"4\") (V8BF \"8\")\n \t\t\t  (V2SF \"2\") (V4SF \"4\")\n \t\t\t  (V1DF \"1\") (V2DF \"2\")\n \t\t\t  (DI \"1\") (DF \"1\")])\n@@ -1013,7 +1035,8 @@\n \t\t\t  (V8HF \"16b\") (V2SF  \"8b\")\n \t\t\t  (V4SF \"16b\") (V2DF  \"16b\")\n \t\t\t  (DI   \"8b\")  (DF    \"8b\")\n-\t\t\t  (SI   \"8b\")  (SF    \"8b\")])\n+\t\t\t  (SI   \"8b\")  (SF    \"8b\")\n+\t\t\t  (V4BF \"8b\")  (V8BF  \"16b\")])\n \n ;; Define element mode for each vector mode.\n (define_mode_attr VEL [(V8QI  \"QI\") (V16QI \"QI\")\n@@ -1093,12 +1116,13 @@\n \t\t\t (V2SI \"SI\")    (V4SI  \"V2SI\")\n \t\t\t (V2DI \"DI\")    (V2SF  \"SF\")\n \t\t\t (V4SF \"V2SF\")  (V4HF \"V2HF\")\n-\t\t\t (V8HF \"V4HF\")  (V2DF  \"DF\")])\n+\t\t\t (V8HF \"V4HF\")  (V2DF  \"DF\")\n+\t\t\t (V8BF \"V4BF\")])\n \n ;; Half modes of all vector modes, in lower-case.\n (define_mode_attr Vhalf [(V8QI \"v4qi\")  (V16QI \"v8qi\")\n \t\t\t (V4HI \"v2hi\")  (V8HI  \"v4hi\")\n-\t\t\t (V8HF  \"v4hf\")\n+\t\t\t (V8HF  \"v4hf\") (V8BF  \"v4bf\")\n \t\t\t (V2SI \"si\")    (V4SI  \"v2si\")\n \t\t\t (V2DI \"di\")    (V2SF  \"sf\")\n \t\t\t (V4SF \"v2sf\")  (V2DF  \"df\")])\n@@ -1404,6 +1428,7 @@\n \t\t     (V2SI \"\") (V4SI  \"_q\")\n \t\t     (DI   \"\") (V2DI  \"_q\")\n \t\t     (V4HF \"\") (V8HF \"_q\")\n+\t\t     (V4BF \"\") (V8BF \"_q\")\n \t\t     (V2SF \"\") (V4SF  \"_q\")\n \t\t\t       (V2DF  \"_q\")\n \t\t     (QI \"\") (HI \"\") (SI \"\") (DI \"\") (HF \"\") (SF \"\") (DF \"\")])"}, {"sha": "45a04f1b5a5163f984da0e0ebb6ca802e5f53fb4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -1,3 +1,15 @@\n+2020-01-10  Stam Markianos-Wright  <stam.markianos-wright@arm.com>\n+\n+\t* g++.dg/abi/mangle-neon-aarch64.C: Add Bfloat SIMD types to test.\n+\t* g++.dg/ext/arm-bf16/bf16-mangle-aarch64-1.C: New test.\n+\t* gcc.target/aarch64/bfloat16_scalar_1.c: New test.\n+\t* gcc.target/aarch64/bfloat16_scalar_2.c: New test.\n+\t* gcc.target/aarch64/bfloat16_scalar_3.c: New test.\n+\t* gcc.target/aarch64/bfloat16_scalar_4.c: New test.\n+\t* gcc.target/aarch64/bfloat16_simd_1.c: New test.\n+\t* gcc.target/aarch64/bfloat16_simd_2.c: New test.\n+\t* gcc.target/aarch64/bfloat16_simd_3.c: New test.\n+\n 2020-01-10  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.target/aarch64/sve/struct_vect_1.c (N): Protect with #ifndef."}, {"sha": "50c1452ed83c8a2f4ad3b162931292db328813c6", "filename": "gcc/testsuite/g++.dg/abi/mangle-neon-aarch64.C", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle-neon-aarch64.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle-neon-aarch64.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle-neon-aarch64.C?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -14,6 +14,7 @@ void f4 (uint16x4_t a) {}\n void f5 (uint32x2_t a) {}\n void f23 (uint64x1_t a) {}\n void f61 (float16x4_t a) {}\n+void f62 (bfloat16x4_t a) {}\n void f6 (float32x2_t a) {}\n void f7 (poly8x8_t a) {}\n void f8 (poly16x4_t a) {}\n@@ -27,6 +28,7 @@ void f14 (uint16x8_t a) {}\n void f15 (uint32x4_t a) {}\n void f16 (uint64x2_t a) {}\n void f171 (float16x8_t a) {}\n+void f172 (bfloat16x8_t a) {}\n void f17 (float32x4_t a) {}\n void f18 (float64x2_t a) {}\n void f19 (poly8x16_t a) {}\n@@ -45,6 +47,7 @@ void g1 (int8x16_t, int8x16_t) {}\n // { dg-final { scan-assembler \"_Z2f512__Uint32x2_t:\" } }\n // { dg-final { scan-assembler \"_Z3f2312__Uint64x1_t:\" } }\n // { dg-final { scan-assembler \"_Z3f6113__Float16x4_t:\" } }\n+// { dg-final { scan-assembler \"_Z3f6214__Bfloat16x4_t:\" } }\n // { dg-final { scan-assembler \"_Z2f613__Float32x2_t:\" } }\n // { dg-final { scan-assembler \"_Z2f711__Poly8x8_t:\" } }\n // { dg-final { scan-assembler \"_Z2f812__Poly16x4_t:\" } }\n@@ -57,6 +60,7 @@ void g1 (int8x16_t, int8x16_t) {}\n // { dg-final { scan-assembler \"_Z3f1512__Uint32x4_t:\" } }\n // { dg-final { scan-assembler \"_Z3f1612__Uint64x2_t:\" } }\n // { dg-final { scan-assembler \"_Z4f17113__Float16x8_t:\" } }\n+// { dg-final { scan-assembler \"_Z4f17214__Bfloat16x8_t:\" } }\n // { dg-final { scan-assembler \"_Z3f1713__Float32x4_t:\" } }\n // { dg-final { scan-assembler \"_Z3f1813__Float64x2_t:\" } }\n // { dg-final { scan-assembler \"_Z3f1912__Poly8x16_t:\" } }"}, {"sha": "5426a1814b842db9d73d556bcc228d19f970f466", "filename": "gcc/testsuite/g++.dg/ext/arm-bf16/bf16-mangle-aarch64-1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Farm-bf16%2Fbf16-mangle-aarch64-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Farm-bf16%2Fbf16-mangle-aarch64-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Farm-bf16%2Fbf16-mangle-aarch64-1.C?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target aarch64*-*-* } } */\n+\n+/* Test mangling */\n+\n+/* { dg-final { scan-assembler \"\\t.global\\t_Z1fPu6__bf16\" } } */\n+void f (__bf16 *x) { }\n+\n+/* { dg-final { scan-assembler \"\\t.global\\t_Z1gPu6__bf16S_\" } } */\n+void g (__bf16 *x, __bf16 *y) { }\n+\n+/* { dg-final { scan-assembler \"\\t.global\\t_ZN1SIu6__bf16u6__bf16E1iE\" } } */\n+template <typename T, typename U> struct S { static int i; };\n+template <> int S<__bf16, __bf16>::i = 3;"}, {"sha": "ef43766495c8f7bc628e658b2818bdc5b8bea247", "filename": "gcc/testsuite/gcc.target/aarch64/bfloat16_scalar_1.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_scalar_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_scalar_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_scalar_1.c?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -0,0 +1,102 @@\n+/* { dg-do assemble { target { aarch64*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-add-options arm_v8_2a_bf16_neon }  */\n+/* { dg-additional-options \"-O3 --save-temps -std=gnu90\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_bf16.h>\n+\n+/*\n+**stacktest1:\n+**\tsub\tsp, sp, #16\n+**\tstr\th0, \\[sp, 14\\]\n+**\tldr\th0, \\[sp, 14\\]\n+**\tadd\tsp, sp, 16\n+**\tret\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**bfloat_mov_ww:\n+**\tmov\tv1.h\\[0\\], v2.h\\[0\\]\n+**\tret\n+*/\n+void bfloat_mov_ww (void)\n+{\n+  register bfloat16_t x asm (\"h2\");\n+  register bfloat16_t y asm (\"h1\");\n+  asm volatile (\"\" : \"=w\" (x));\n+  y = x;\n+  asm volatile (\"\" :: \"w\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rw:\n+**\tdup\tv1.4h, w1\n+**\tret\n+*/\n+void bfloat_mov_rw (void)\n+{\n+  register bfloat16_t x asm (\"w1\");\n+  register bfloat16_t y asm (\"h1\");\n+  asm volatile (\"\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"\" :: \"w\" (y));\n+}\n+\n+/*\n+**bfloat_mov_wr:\n+**\tumov\tw1, v1.h\\[0\\]\n+**\tret\n+*/\n+void bfloat_mov_wr (void)\n+{\n+  register bfloat16_t x asm (\"h1\");\n+  register bfloat16_t y asm (\"w1\");\n+  asm volatile (\"\" : \"=w\" (x));\n+  y = x;\n+  asm volatile (\"\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rr:\n+**\tmov\tw1, w2\n+**\tret\n+*/\n+void bfloat_mov_rr (void)\n+{\n+  register bfloat16_t x asm (\"w2\");\n+  register bfloat16_t y asm (\"w1\");\n+  asm volatile (\"\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rm:\n+**\tstrh\tw2, \\[x0\\]\n+**\tret\n+*/\n+void bfloat_mov_rm (bfloat16_t *ptr)\n+{\n+   register bfloat16_t x asm (\"w2\");\n+   asm volatile (\"\" : \"=r\" (x));\n+   *ptr = x;\n+}\n+\n+/*\n+**bfloat_mov_mr:\n+**\tldrh\tw2, \\[x0\\]\n+**\tret\n+*/\n+void bfloat_mov_mr (bfloat16_t *ptr)\n+{\n+   register bfloat16_t y asm (\"w2\");\n+   y = *ptr;\n+   asm volatile (\"\" :: \"r\" (y));\n+}\n+"}, {"sha": "df8e7518c24c6534f04f1e1b3c50e2655f69bf95", "filename": "gcc/testsuite/gcc.target/aarch64/bfloat16_scalar_2.c", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_scalar_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_scalar_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_scalar_2.c?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -0,0 +1,106 @@\n+/* { dg-do assemble { target { aarch64*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-additional-options \"-march=armv8.2-a -O3 --save-temps -std=gnu90\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_bf16.h>\n+\n+#pragma GCC push_options\n+#pragma GCC target (\"+bf16\")\n+\n+/*\n+**stacktest1:\n+**\tsub\tsp, sp, #16\n+**\tstr\th0, \\[sp, 14\\]\n+**\tldr\th0, \\[sp, 14\\]\n+**\tadd\tsp, sp, 16\n+**\tret\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**bfloat_mov_ww:\n+**\tmov\tv1.h\\[0\\], v2.h\\[0\\]\n+**\tret\n+*/\n+void bfloat_mov_ww (void)\n+{\n+  register bfloat16_t x asm (\"h2\");\n+  register bfloat16_t y asm (\"h1\");\n+  asm volatile (\"\" : \"=w\" (x));\n+  y = x;\n+  asm volatile (\"\" :: \"w\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rw:\n+**\tdup\tv1.4h, w1\n+**\tret\n+*/\n+void bfloat_mov_rw (void)\n+{\n+  register bfloat16_t x asm (\"w1\");\n+  register bfloat16_t y asm (\"h1\");\n+  asm volatile (\"\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"\" :: \"w\" (y));\n+}\n+\n+/*\n+**bfloat_mov_wr:\n+**\tumov\tw1, v1.h\\[0\\]\n+**\tret\n+*/\n+void bfloat_mov_wr (void)\n+{\n+  register bfloat16_t x asm (\"h1\");\n+  register bfloat16_t y asm (\"w1\");\n+  asm volatile (\"\" : \"=w\" (x));\n+  y = x;\n+  asm volatile (\"\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rr:\n+**\tmov\tw1, w2\n+**\tret\n+*/\n+void bfloat_mov_rr (void)\n+{\n+  register bfloat16_t x asm (\"w2\");\n+  register bfloat16_t y asm (\"w1\");\n+  asm volatile (\"\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rm:\n+**\tstrh\tw2, \\[x0\\]\n+**\tret\n+*/\n+void bfloat_mov_rm (bfloat16_t *ptr)\n+{\n+   register bfloat16_t x asm (\"w2\");\n+   asm volatile (\"\" : \"=r\" (x));\n+   *ptr = x;\n+}\n+\n+/*\n+**bfloat_mov_mr:\n+**\tldrh\tw2, \\[x0\\]\n+**\tret\n+*/\n+void bfloat_mov_mr (bfloat16_t *ptr)\n+{\n+   register bfloat16_t y asm (\"w2\");\n+   y = *ptr;\n+   asm volatile (\"\" :: \"r\" (y));\n+}\n+\n+#pragma GCC pop_options\n+"}, {"sha": "5d7a4317ceefbdd411062fe506e3bf9461d98bf8", "filename": "gcc/testsuite/gcc.target/aarch64/bfloat16_scalar_3.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_scalar_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_scalar_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_scalar_3.c?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -0,0 +1,101 @@\n+/* { dg-do assemble { target { aarch64*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-additional-options \"-march=armv8.2-a -O3 --save-temps -std=gnu90\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_bf16.h>\n+\n+/*\n+**stacktest1:\n+**\tsub\tsp, sp, #16\n+**\tstr\th0, \\[sp, 14\\]\n+**\tldr\th0, \\[sp, 14\\]\n+**\tadd\tsp, sp, 16\n+**\tret\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**bfloat_mov_ww:\n+**\tmov\tv1.h\\[0\\], v2.h\\[0\\]\n+**\tret\n+*/\n+void bfloat_mov_ww (void)\n+{\n+  register bfloat16_t x asm (\"h2\");\n+  register bfloat16_t y asm (\"h1\");\n+  asm volatile (\"\" : \"=w\" (x));\n+  y = x;\n+  asm volatile (\"\" :: \"w\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rw:\n+**\tdup\tv1.4h, w1\n+**\tret\n+*/\n+void bfloat_mov_rw (void)\n+{\n+  register bfloat16_t x asm (\"w1\");\n+  register bfloat16_t y asm (\"h1\");\n+  asm volatile (\"\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"\" :: \"w\" (y));\n+}\n+\n+/*\n+**bfloat_mov_wr:\n+**\tumov\tw1, v1.h\\[0\\]\n+**\tret\n+*/\n+void bfloat_mov_wr (void)\n+{\n+  register bfloat16_t x asm (\"h1\");\n+  register bfloat16_t y asm (\"w1\");\n+  asm volatile (\"\" : \"=w\" (x));\n+  y = x;\n+  asm volatile (\"\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rr:\n+**\tmov\tw1, w2\n+**\tret\n+*/\n+void bfloat_mov_rr (void)\n+{\n+  register bfloat16_t x asm (\"w2\");\n+  register bfloat16_t y asm (\"w1\");\n+  asm volatile (\"\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rm:\n+**\tstrh\tw2, \\[x0\\]\n+**\tret\n+*/\n+void bfloat_mov_rm (bfloat16_t *ptr)\n+{\n+   register bfloat16_t x asm (\"w2\");\n+   asm volatile (\"\" : \"=r\" (x));\n+   *ptr = x;\n+}\n+\n+/*\n+**bfloat_mov_mr:\n+**\tldrh\tw2, \\[x0\\]\n+**\tret\n+*/\n+void bfloat_mov_mr (bfloat16_t *ptr)\n+{\n+   register bfloat16_t y asm (\"w2\");\n+   y = *ptr;\n+   asm volatile (\"\" :: \"r\" (y));\n+}\n+"}, {"sha": "b812011c223b257fe405ef210d24bf5edc3535c0", "filename": "gcc/testsuite/gcc.target/aarch64/bfloat16_scalar_4.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_scalar_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_scalar_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_scalar_4.c?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do assemble { target { aarch64*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-add-options arm_v8_2a_bf16_neon }  */\n+/* { dg-additional-options \"-std=c99 -pedantic-errors -O3 --save-temps\" } */\n+\n+#include <arm_bf16.h>\n+\n+_Complex bfloat16_t stacktest1 (_Complex bfloat16_t __a)\n+{\n+  volatile _Complex bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/* { dg-error {ISO C does not support plain 'complex' meaning 'double complex'} \"\" { target *-*-* } 8 } */\n+/* { dg-error {expected '=', ',', ';', 'asm' or '__attribute__' before 'stacktest1'} \"\" { target *-*-* } 8 } */\n+"}, {"sha": "6cad557ebf2cd8e9b2f063d1cc7e9ad4a3e6ac31", "filename": "gcc/testsuite/gcc.target/aarch64/bfloat16_simd_1.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_simd_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_simd_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_simd_1.c?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -0,0 +1,93 @@\n+/* { dg-do assemble { target { aarch64*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-add-options arm_v8_2a_bf16_neon }  */\n+/* { dg-additional-options \"-O3 --save-temps\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_neon.h>\n+\n+/*\n+**stacktest1:\n+**\tsub\tsp, sp, #16\n+**\tstr\th0, \\[sp, 14\\]\n+**\tldr\th0, \\[sp, 14\\]\n+**\tadd\tsp, sp, 16\n+**\tret\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest2:\n+**\tsub\tsp, sp, #16\n+**\tstr\td0, \\[sp, 8\\]\n+**\tldr\td0, \\[sp, 8\\]\n+**\tadd\tsp, sp, 16\n+**\tret\n+*/\n+bfloat16x4_t stacktest2 (bfloat16x4_t __a)\n+{\n+  volatile bfloat16x4_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest3:\n+**\tsub\tsp, sp, #16\n+**\tstr\tq0, \\[sp\\]\n+**\tldr\tq0, \\[sp\\]\n+**\tadd\tsp, sp, 16\n+**\tret\n+*/\n+bfloat16x8_t stacktest3 (bfloat16x8_t __a)\n+{\n+  volatile bfloat16x8_t b = __a;\n+  return b;\n+}\n+\n+/*  Test compilation of __attribute__ vectors of 8, 16, 32, etc. BFloats.  */\n+typedef bfloat16_t v8bf __attribute__((vector_size(16)));\n+typedef bfloat16_t v16bf __attribute__((vector_size(32)));\n+typedef bfloat16_t v32bf __attribute__((vector_size(64)));\n+typedef bfloat16_t v64bf __attribute__((vector_size(128)));\n+typedef bfloat16_t v128bf __attribute__((vector_size(256)));\n+\n+v8bf stacktest4 (v8bf __a)\n+{\n+  volatile v8bf b = __a;\n+  return b;\n+}\n+\n+v16bf stacktest5 (v16bf __a)\n+{\n+  volatile v16bf b = __a;\n+  return b;\n+}\n+\n+v32bf stacktest6 (v32bf __a)\n+{\n+  volatile v32bf b = __a;\n+  return b;\n+}\n+\n+v64bf stacktest7 (v64bf __a)\n+{\n+  volatile v64bf b = __a;\n+  return b;\n+}\n+\n+v128bf stacktest8 (v128bf __a)\n+{\n+  volatile v128bf b = __a;\n+  return b;\n+}\n+\n+/* Test use of constant values to assign values to vectors.  */\n+\n+typedef bfloat16_t v2bf __attribute__((vector_size(4)));\n+v2bf c2 (void) { return (v2bf) 0x12345678; }\n+\n+bfloat16x4_t c3 (void) { return (bfloat16x4_t) 0x1234567812345678; }"}, {"sha": "3891dcfc900ab942bf29eb638d16660a194597e4", "filename": "gcc/testsuite/gcc.target/aarch64/bfloat16_simd_2.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_simd_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_simd_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_simd_2.c?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-do assemble { target { aarch64*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-additional-options \"-march=armv8.2-a -O3 --save-temps\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_neon.h>\n+\n+#pragma GCC push_options\n+#pragma GCC target (\"+bf16\")\n+\n+/*\n+**stacktest1:\n+**\tsub\tsp, sp, #16\n+**\tstr\th0, \\[sp, 14\\]\n+**\tldr\th0, \\[sp, 14\\]\n+**\tadd\tsp, sp, 16\n+**\tret\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest2:\n+**\tsub\tsp, sp, #16\n+**\tstr\td0, \\[sp, 8\\]\n+**\tldr\td0, \\[sp, 8\\]\n+**\tadd\tsp, sp, 16\n+**\tret\n+*/\n+bfloat16x4_t stacktest2 (bfloat16x4_t __a)\n+{\n+  volatile bfloat16x4_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest3:\n+**\tsub\tsp, sp, #16\n+**\tstr\tq0, \\[sp\\]\n+**\tldr\tq0, \\[sp\\]\n+**\tadd\tsp, sp, 16\n+**\tret\n+*/\n+bfloat16x8_t stacktest3 (bfloat16x8_t __a)\n+{\n+  volatile bfloat16x8_t b = __a;\n+  return b;\n+}\n+\n+/*  Test compilation of __attribute__ vectors of 8, 16, 32, etc. BFloats.  */\n+typedef bfloat16_t v8bf __attribute__((vector_size(16)));\n+typedef bfloat16_t v16bf __attribute__((vector_size(32)));\n+typedef bfloat16_t v32bf __attribute__((vector_size(64)));\n+typedef bfloat16_t v64bf __attribute__((vector_size(128)));\n+typedef bfloat16_t v128bf __attribute__((vector_size(256)));\n+\n+v8bf stacktest4 (v8bf __a)\n+{\n+  volatile v8bf b = __a;\n+  return b;\n+}\n+\n+v16bf stacktest5 (v16bf __a)\n+{\n+  volatile v16bf b = __a;\n+  return b;\n+}\n+\n+v32bf stacktest6 (v32bf __a)\n+{\n+  volatile v32bf b = __a;\n+  return b;\n+}\n+\n+v64bf stacktest7 (v64bf __a)\n+{\n+  volatile v64bf b = __a;\n+  return b;\n+}\n+\n+v128bf stacktest8 (v128bf __a)\n+{\n+  volatile v128bf b = __a;\n+  return b;\n+}\n+\n+/* Test use of constant values to assign values to vectors.  */\n+\n+typedef bfloat16_t v2bf __attribute__((vector_size(4)));\n+v2bf c2 (void) { return (v2bf) 0x12345678; }\n+\n+bfloat16x4_t c3 (void) { return (bfloat16x4_t) 0x1234567812345678; }\n+\n+#pragma GCC pop_options"}, {"sha": "b35f5e527be1fe7a6fd928bcd326b57fb376596a", "filename": "gcc/testsuite/gcc.target/aarch64/bfloat16_simd_3.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_simd_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbe1ed27355178223cd099fb73227f392416ea6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_simd_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbfloat16_simd_3.c?ref=abbe1ed27355178223cd099fb73227f392416ea6", "patch": "@@ -0,0 +1,92 @@\n+/* { dg-do assemble { target { aarch64*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-additional-options \"-march=armv8.2-a -O3 --save-temps\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_neon.h>\n+\n+/*\n+**stacktest1:\n+**\tsub\tsp, sp, #16\n+**\tstr\th0, \\[sp, 14\\]\n+**\tldr\th0, \\[sp, 14\\]\n+**\tadd\tsp, sp, 16\n+**\tret\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest2:\n+**\tsub\tsp, sp, #16\n+**\tstr\td0, \\[sp, 8\\]\n+**\tldr\td0, \\[sp, 8\\]\n+**\tadd\tsp, sp, 16\n+**\tret\n+*/\n+bfloat16x4_t stacktest2 (bfloat16x4_t __a)\n+{\n+  volatile bfloat16x4_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest3:\n+**\tsub\tsp, sp, #16\n+**\tstr\tq0, \\[sp\\]\n+**\tldr\tq0, \\[sp\\]\n+**\tadd\tsp, sp, 16\n+**\tret\n+*/\n+bfloat16x8_t stacktest3 (bfloat16x8_t __a)\n+{\n+  volatile bfloat16x8_t b = __a;\n+  return b;\n+}\n+\n+/*  Test compilation of __attribute__ vectors of 8, 16, 32, etc. BFloats.  */\n+typedef bfloat16_t v8bf __attribute__((vector_size(16)));\n+typedef bfloat16_t v16bf __attribute__((vector_size(32)));\n+typedef bfloat16_t v32bf __attribute__((vector_size(64)));\n+typedef bfloat16_t v64bf __attribute__((vector_size(128)));\n+typedef bfloat16_t v128bf __attribute__((vector_size(256)));\n+\n+v8bf stacktest4 (v8bf __a)\n+{\n+  volatile v8bf b = __a;\n+  return b;\n+}\n+\n+v16bf stacktest5 (v16bf __a)\n+{\n+  volatile v16bf b = __a;\n+  return b;\n+}\n+\n+v32bf stacktest6 (v32bf __a)\n+{\n+  volatile v32bf b = __a;\n+  return b;\n+}\n+\n+v64bf stacktest7 (v64bf __a)\n+{\n+  volatile v64bf b = __a;\n+  return b;\n+}\n+\n+v128bf stacktest8 (v128bf __a)\n+{\n+  volatile v128bf b = __a;\n+  return b;\n+}\n+\n+/* Test use of constant values to assign values to vectors.  */\n+\n+typedef bfloat16_t v2bf __attribute__((vector_size(4)));\n+v2bf c2 (void) { return (v2bf) 0x12345678; }\n+\n+bfloat16x4_t c3 (void) { return (bfloat16x4_t) 0x1234567812345678; }"}]}