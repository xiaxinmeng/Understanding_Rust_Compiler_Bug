{"sha": "e89964e31c5f26caefe5fffb0ccc1fb4932f44bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg5OTY0ZTMxYzVmMjZjYWVmZTVmZmZiMGNjYzFmYjQ5MzJmNDRiYw==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2011-04-03T11:21:06Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2011-04-03T11:21:06Z"}, "message": "lto-streamer.h (struct lto_streamer_cache_d): Remove offsets and next_slot members.\n\n\t* lto-streamer.h (struct lto_streamer_cache_d): Remove offsets\n\tand next_slot members.\n\t(lto_streamer_cache_insert, lto_streamer_cache_insert_at,\n\tlto_streamer_cache_lookup, lto_streamer_cache_get): Adjust prototypes.\n\t(lto_streamer_cache_append): Declare.\n\t* lto-streamer.c (lto_streamer_cache_add_to_node_array): Use\n\tunsigned index, remove offset parameter, ensure that we append\n\tor update existing entries.\n\t(lto_streamer_cache_insert_1): Use unsigned index, remove offset_p\n\tparameter, update next_slot for append.\n\t(lto_streamer_cache_insert): Use unsigned index, remove offset_p\n\tparameter.\n\t(lto_streamer_cache_insert_at): Likewise.\n\t(lto_streamer_cache_append): New function.\n\t(lto_streamer_cache_lookup): Use unsigned index.\n\t(lto_streamer_cache_get): Likewise.\n\t(lto_record_common_node): Don't test tree_node_can_be_shared.\n\t(preload_common_node): Adjust call to lto_streamer_cache_insert.\n\t(lto_streamer_cache_delete): Don't free offsets member.\n\t* lto-streamer-out.c (eq_string_slot_node): Use memcmp.\n\t(lto_output_string_with_length): Use lto_output_data_stream.\n\t(lto_output_tree_header): Remove ix parameter, don't write it.\n\t(lto_output_builtin_tree): Likewise.\n\t(lto_write_tree): Adjust callers to above, don't track and write\n\toffset, write unsigned index.\n\t(output_unreferenced_globals): Don't emit all global vars.\n\t(write_global_references): Use unsigned indices.\n\t(lto_output_decl_state_refs): Likewise.\n\t(write_symbol): Likewise.\n\t* lto-streamer-in.c (lto_input_chain): Move earlier.\n\t(input_function): Use unsigned index.\n\t(input_alias_pairs): Don't read and then ignore all global vars.\n\t(lto_materialize_tree): Remove ix_p parameter, don't read index,\n\tdon't pass it back, use lto_streamer_cache_append.\n\t(lto_register_var_decl_in_symtab): Use unsigned index.\n\t(lto_register_function_decl_in_symtab): Likewise.\n\t(lto_get_pickled_tree): Don't read in or handle offset, read unsigned\n\tindex.\n\t(lto_get_builtin_tree): Don't read index, use\n\tlto_streamer_cache_append.\n\t(lto_read_tree): Adjust call to lto_materialize_tree.\n\n\t* ipa-inline.c (cgraph_edge_badness): Move growth calculaton,\n\tdon't use function calls in arguments to MIN.\n\n\t* varasm.c (decl_binds_to_current_def_p): Don't check TREE_PUBLIC\n\ttwice.\n\n\t* gimple.c (gimple_type_leader_entry): Mark deletable.\n\nlto/\n\t* lto.c (lto_materialize_function): Don't read and then discard\n\tsections in WPA mode.\n\t(lto_read_in_decl_state): Adjust call to lto_streamer_cache_get.\n\n\t* lto-lang.c (registered_builtin_fndecls): Remove.\n\t(lto_getdecls): Return NULL_TREE.\n\t(lto_builtin_function): Don't remember in registered_builtin_fndecls.\n\nFrom-SVN: r171906", "tree": {"sha": "1e63a8bdd37fbff2c65aec3206ef1005c2481cd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e63a8bdd37fbff2c65aec3206ef1005c2481cd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9a5b5b2a2771889f315d778629dc7e6245a69cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9a5b5b2a2771889f315d778629dc7e6245a69cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9a5b5b2a2771889f315d778629dc7e6245a69cf"}], "stats": {"total": 464, "additions": 207, "deletions": 257}, "files": [{"sha": "8a10a7c017bfa97b3e3121737d7a049eb2abd72e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e89964e31c5f26caefe5fffb0ccc1fb4932f44bc", "patch": "@@ -1,3 +1,55 @@\n+2011-04-03  Michael Matz  <matz@suse.de>\n+\n+\t* lto-streamer.h (struct lto_streamer_cache_d): Remove offsets\n+\tand next_slot members.\n+\t(lto_streamer_cache_insert, lto_streamer_cache_insert_at,\n+\tlto_streamer_cache_lookup, lto_streamer_cache_get): Adjust prototypes.\n+\t(lto_streamer_cache_append): Declare.\n+\t* lto-streamer.c (lto_streamer_cache_add_to_node_array): Use\n+\tunsigned index, remove offset parameter, ensure that we append\n+\tor update existing entries.\n+\t(lto_streamer_cache_insert_1): Use unsigned index, remove offset_p\n+\tparameter, update next_slot for append.\n+\t(lto_streamer_cache_insert): Use unsigned index, remove offset_p\n+\tparameter.\n+\t(lto_streamer_cache_insert_at): Likewise.\n+\t(lto_streamer_cache_append): New function.\n+\t(lto_streamer_cache_lookup): Use unsigned index.\n+\t(lto_streamer_cache_get): Likewise.\n+\t(lto_record_common_node): Don't test tree_node_can_be_shared.\n+\t(preload_common_node): Adjust call to lto_streamer_cache_insert.\n+\t(lto_streamer_cache_delete): Don't free offsets member.\n+\t* lto-streamer-out.c (eq_string_slot_node): Use memcmp.\n+\t(lto_output_string_with_length): Use lto_output_data_stream.\n+\t(lto_output_tree_header): Remove ix parameter, don't write it.\n+\t(lto_output_builtin_tree): Likewise.\n+\t(lto_write_tree): Adjust callers to above, don't track and write\n+\toffset, write unsigned index.\n+\t(output_unreferenced_globals): Don't emit all global vars.\n+\t(write_global_references): Use unsigned indices.\n+\t(lto_output_decl_state_refs): Likewise.\n+\t(write_symbol): Likewise.\n+\t* lto-streamer-in.c (lto_input_chain): Move earlier.\n+\t(input_function): Use unsigned index.\n+\t(input_alias_pairs): Don't read and then ignore all global vars.\n+\t(lto_materialize_tree): Remove ix_p parameter, don't read index,\n+\tdon't pass it back, use lto_streamer_cache_append.\n+\t(lto_register_var_decl_in_symtab): Use unsigned index.\n+\t(lto_register_function_decl_in_symtab): Likewise.\n+\t(lto_get_pickled_tree): Don't read in or handle offset, read unsigned\n+\tindex.\n+\t(lto_get_builtin_tree): Don't read index, use\n+\tlto_streamer_cache_append.\n+\t(lto_read_tree): Adjust call to lto_materialize_tree.\n+\n+\t* ipa-inline.c (cgraph_edge_badness): Move growth calculaton,\n+\tdon't use function calls in arguments to MIN.\n+\n+\t* varasm.c (decl_binds_to_current_def_p): Don't check TREE_PUBLIC\n+\ttwice.\n+\n+\t* gimple.c (gimple_type_leader_entry): Mark deletable.\n+\n 2011-04-03  Alan Modra  <amodra@gmail.com>\n \n \t* dwarf2out.c (mem_loc_descriptor): Recurse on LO_SUM."}, {"sha": "8881aaa460d43494faa70fbb6a201adb351806c0", "filename": "gcc/gimple.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=e89964e31c5f26caefe5fffb0ccc1fb4932f44bc", "patch": "@@ -3242,8 +3242,8 @@ typedef struct GTY(()) gimple_type_leader_entry_s {\n } gimple_type_leader_entry;\n \n #define GIMPLE_TYPE_LEADER_SIZE 16381\n-static GTY((length(\"GIMPLE_TYPE_LEADER_SIZE\"))) gimple_type_leader_entry\n-  *gimple_type_leader;\n+static GTY((deletable, length(\"GIMPLE_TYPE_LEADER_SIZE\")))\n+  gimple_type_leader_entry *gimple_type_leader;\n \n /* Lookup an existing leader for T and return it or NULL_TREE, if\n    there is none in the cache.  */"}, {"sha": "77ab17e64e53fcd5127b942689d6cfe1435ea81c", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=e89964e31c5f26caefe5fffb0ccc1fb4932f44bc", "patch": "@@ -519,13 +519,15 @@ static int\n cgraph_edge_badness (struct cgraph_edge *edge, bool dump)\n {\n   gcov_type badness;\n-  int growth =\n-    (cgraph_estimate_size_after_inlining (edge->caller, edge->callee)\n-     - edge->caller->global.size);\n+  int growth;\n \n   if (edge->callee->local.disregard_inline_limits)\n     return INT_MIN;\n \n+  growth =\n+    (cgraph_estimate_size_after_inlining (edge->caller, edge->callee)\n+     - edge->caller->global.size);\n+\n   if (dump)\n     {\n       fprintf (dump_file, \"    Badness calculation for %s -> %s\\n\",\n@@ -584,11 +586,11 @@ cgraph_edge_badness (struct cgraph_edge *edge, bool dump)\n       int growth_for_all;\n       badness = growth * 10000;\n       benefitperc =\n-\tMIN (100 * inline_summary (edge->callee)->time_inlining_benefit /\n-\t     (edge->callee->global.time + 1) +1, 100);\n+\t100 * inline_summary (edge->callee)->time_inlining_benefit\n+\t    / (edge->callee->global.time + 1) +1;\n+      benefitperc = MIN (benefitperc, 100);\n       div *= benefitperc;\n \n-\n       /* Decrease badness if call is nested.  */\n       /* Compress the range so we don't overflow.  */\n       if (div > 10000)"}, {"sha": "fc5bc637f3829576d4cf79c62009cbf5e2ed5f04", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 37, "deletions": 75, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=e89964e31c5f26caefe5fffb0ccc1fb4932f44bc", "patch": "@@ -387,6 +387,33 @@ lto_input_tree_ref (struct lto_input_block *ib, struct data_in *data_in,\n }\n \n \n+/* Read a chain of tree nodes from input block IB. DATA_IN contains\n+   tables and descriptors for the file being read.  */\n+\n+static tree\n+lto_input_chain (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  int i, count;\n+  tree first, prev, curr;\n+\n+  first = prev = NULL_TREE;\n+  count = lto_input_sleb128 (ib);\n+  for (i = 0; i < count; i++)\n+    {\n+      curr = lto_input_tree (ib, data_in);\n+      if (prev)\n+\tTREE_CHAIN (prev) = curr;\n+      else\n+\tfirst = curr;\n+\n+      TREE_CHAIN (curr) = NULL_TREE;\n+      prev = curr;\n+    }\n+\n+  return first;\n+}\n+\n+\n /* Read and return a double-linked list of catch handlers from input\n    block IB, using descriptors in DATA_IN.  */\n \n@@ -1255,7 +1282,7 @@ input_function (tree fn_decl, struct data_in *data_in,\n        oarg && narg;\n        oarg = TREE_CHAIN (oarg), narg = TREE_CHAIN (narg))\n     {\n-      int ix;\n+      unsigned ix;\n       bool res;\n       res = lto_streamer_cache_lookup (data_in->reader_cache, oarg, &ix);\n       gcc_assert (res);\n@@ -1352,11 +1379,6 @@ input_alias_pairs (struct lto_input_block *ib, struct data_in *data_in)\n \n   clear_line_info (data_in);\n \n-  /* Skip over all the unreferenced globals.  */\n-  do\n-    var = lto_input_tree (ib, data_in);\n-  while (var);\n-\n   var = lto_input_tree (ib, data_in);\n   while (var)\n     {\n@@ -1828,23 +1850,17 @@ unpack_value_fields (struct bitpack_d *bp, tree expr)\n \n static tree\n lto_materialize_tree (struct lto_input_block *ib, struct data_in *data_in,\n-\t\t      enum LTO_tags tag, int *ix_p)\n+\t\t      enum LTO_tags tag)\n {\n   struct bitpack_d bp;\n   enum tree_code code;\n   tree result;\n #ifdef LTO_STREAMER_DEBUG\n   HOST_WIDEST_INT orig_address_in_writer;\n #endif\n-  HOST_WIDE_INT ix;\n \n   result = NULL_TREE;\n \n-  /* Read the header of the node we are about to create.  */\n-  ix = lto_input_sleb128 (ib);\n-  gcc_assert ((int) ix == ix);\n-  *ix_p = (int) ix;\n-\n #ifdef LTO_STREAMER_DEBUG\n   /* Read the word representing the memory address for the tree\n      as it was written by the writer.  This is useful when\n@@ -1876,8 +1892,7 @@ lto_materialize_tree (struct lto_input_block *ib, struct data_in *data_in,\n     }\n   else\n     {\n-      /* All other nodes can be materialized with a raw make_node\n-\t call.  */\n+      /* All other nodes can be materialized with a raw make_node call.  */\n       result = make_node (code);\n     }\n \n@@ -1904,39 +1919,12 @@ lto_materialize_tree (struct lto_input_block *ib, struct data_in *data_in,\n   /* Enter RESULT in the reader cache.  This will make RESULT\n      available so that circular references in the rest of the tree\n      structure can be resolved in subsequent calls to lto_input_tree.  */\n-  lto_streamer_cache_insert_at (data_in->reader_cache, result, ix);\n+  lto_streamer_cache_append (data_in->reader_cache, result);\n \n   return result;\n }\n \n \n-/* Read a chain of tree nodes from input block IB. DATA_IN contains\n-   tables and descriptors for the file being read.  */\n-\n-static tree\n-lto_input_chain (struct lto_input_block *ib, struct data_in *data_in)\n-{\n-  int i, count;\n-  tree first, prev, curr;\n-\n-  first = prev = NULL_TREE;\n-  count = lto_input_sleb128 (ib);\n-  for (i = 0; i < count; i++)\n-    {\n-      curr = lto_input_tree (ib, data_in);\n-      if (prev)\n-\tTREE_CHAIN (prev) = curr;\n-      else\n-\tfirst = curr;\n-\n-      TREE_CHAIN (curr) = NULL_TREE;\n-      prev = curr;\n-    }\n-\n-  return first;\n-}\n-\n-\n /* Read all pointer fields in the TS_COMMON structure of EXPR from input\n    block IB.  DATA_IN contains tables and descriptors for the\n    file being read.  */\n@@ -2463,7 +2451,7 @@ lto_register_var_decl_in_symtab (struct data_in *data_in, tree decl)\n      declaration for merging.  */\n   if (TREE_PUBLIC (decl))\n     {\n-      int ix;\n+      unsigned ix;\n       if (!lto_streamer_cache_lookup (data_in->reader_cache, decl, &ix))\n \tgcc_unreachable ();\n       lto_symtab_register_decl (decl, get_resolution (data_in, ix),\n@@ -2530,7 +2518,7 @@ lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl)\n      declaration for merging.  */\n   if (TREE_PUBLIC (decl) && !DECL_ABSTRACT (decl))\n     {\n-      int ix;\n+      unsigned ix;\n       if (!lto_streamer_cache_lookup (data_in->reader_cache, decl, &ix))\n \tgcc_unreachable ();\n       lto_symtab_register_decl (decl, get_resolution (data_in, ix),\n@@ -2545,35 +2533,14 @@ lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl)\n static tree\n lto_get_pickled_tree (struct lto_input_block *ib, struct data_in *data_in)\n {\n-  HOST_WIDE_INT ix;\n+  unsigned HOST_WIDE_INT ix;\n   tree result;\n   enum LTO_tags expected_tag;\n-  unsigned HOST_WIDE_INT orig_offset;\n \n-  ix = lto_input_sleb128 (ib);\n+  ix = lto_input_uleb128 (ib);\n   expected_tag = (enum LTO_tags) lto_input_uleb128 (ib);\n \n-  orig_offset = lto_input_uleb128 (ib);\n-  gcc_assert (orig_offset == (unsigned) orig_offset);\n-\n   result = lto_streamer_cache_get (data_in->reader_cache, ix);\n-  if (result == NULL_TREE)\n-    {\n-      /* We have not yet read the cache slot IX.  Go to the offset\n-\t in the stream where the physical tree node is, and materialize\n-\t it from there.  */\n-      struct lto_input_block fwd_ib;\n-\n-      /* If we are trying to go back in the stream, something is wrong.\n-\t We should've read the node at the earlier position already.  */\n-      if (ib->p >= orig_offset)\n-\tinternal_error (\"bytecode stream: tried to jump backwards in the \"\n-\t\t        \"stream\");\n-\n-      LTO_INIT_INPUT_BLOCK (fwd_ib, ib->data, orig_offset, ib->len);\n-      result = lto_input_tree (&fwd_ib, data_in);\n-    }\n-\n   gcc_assert (result\n               && TREE_CODE (result) == lto_tag_to_tree_code (expected_tag));\n \n@@ -2591,16 +2558,12 @@ lto_get_builtin_tree (struct lto_input_block *ib, struct data_in *data_in)\n   enum built_in_function fcode;\n   const char *asmname;\n   tree result;\n-  int ix;\n \n   fclass = (enum built_in_class) lto_input_uleb128 (ib);\n   gcc_assert (fclass == BUILT_IN_NORMAL || fclass == BUILT_IN_MD);\n \n   fcode = (enum built_in_function) lto_input_uleb128 (ib);\n \n-  ix = lto_input_sleb128 (ib);\n-  gcc_assert (ix == (int) ix);\n-\n   if (fclass == BUILT_IN_NORMAL)\n     {\n       gcc_assert (fcode < END_BUILTINS);\n@@ -2620,7 +2583,7 @@ lto_get_builtin_tree (struct lto_input_block *ib, struct data_in *data_in)\n   if (asmname)\n     set_builtin_user_assembler_name (result, asmname);\n \n-  lto_streamer_cache_insert_at (data_in->reader_cache, result, ix);\n+  lto_streamer_cache_append (data_in->reader_cache, result);\n \n   return result;\n }\n@@ -2634,9 +2597,8 @@ lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n \t       enum LTO_tags tag)\n {\n   tree result;\n-  int ix;\n \n-  result = lto_materialize_tree (ib, data_in, tag, &ix);\n+  result = lto_materialize_tree (ib, data_in, tag);\n \n   /* Read all the pointer fields in RESULT.  */\n   lto_input_tree_pointers (ib, data_in, result);"}, {"sha": "787f4f2494d3e98cedecb11a295f22ed451a35af", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 22, "deletions": 65, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=e89964e31c5f26caefe5fffb0ccc1fb4932f44bc", "patch": "@@ -70,13 +70,7 @@ eq_string_slot_node (const void *p1, const void *p2)\n   const struct string_slot *ds2 = (const struct string_slot *) p2;\n \n   if (ds1->len == ds2->len)\n-    {\n-      int i;\n-      for (i = 0; i < ds1->len; i++)\n-\tif (ds1->s[i] != ds2->s[i])\n-\t  return 0;\n-      return 1;\n-    }\n+    return memcmp (ds1->s, ds2->s, ds1->len) == 0;\n \n   return 0;\n }\n@@ -181,20 +175,18 @@ lto_output_string_with_length (struct output_block *ob,\n       unsigned int start = string_stream->total_size;\n       struct string_slot *new_slot\n \t= (struct string_slot *) xmalloc (sizeof (struct string_slot));\n-      unsigned int i;\n \n       new_slot->s = string;\n       new_slot->len = len;\n       new_slot->slot_num = start;\n       *slot = new_slot;\n       lto_output_uleb128_stream (index_stream, start);\n       lto_output_uleb128_stream (string_stream, len);\n-      for (i = 0; i < len; i++)\n-\tlto_output_1_stream (string_stream, string[i]);\n+      lto_output_data_stream (string_stream, string, len);\n     }\n   else\n     {\n-      struct string_slot *old_slot = (struct string_slot *)*slot;\n+      struct string_slot *old_slot = *slot;\n       lto_output_uleb128_stream (index_stream, old_slot->slot_num);\n       free (string);\n     }\n@@ -1247,7 +1239,7 @@ lto_output_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n    where EXPR is stored.  REF_P is as in lto_output_tree.  */\n \n static void\n-lto_output_tree_header (struct output_block *ob, tree expr, int ix)\n+lto_output_tree_header (struct output_block *ob, tree expr)\n {\n   enum LTO_tags tag;\n   enum tree_code code;\n@@ -1264,7 +1256,6 @@ lto_output_tree_header (struct output_block *ob, tree expr, int ix)\n      variable sized nodes).  */\n   tag = lto_tree_code_to_tag (code);\n   output_record_start (ob, tag);\n-  output_sleb128 (ob, ix);\n \n   /* The following will cause bootstrap miscomparisons.  Enable with care.  */\n #ifdef LTO_STREAMER_DEBUG\n@@ -1293,7 +1284,7 @@ lto_output_tree_header (struct output_block *ob, tree expr, int ix)\n    the index into the streamer cache where EXPR is stored.*/\n \n static void\n-lto_output_builtin_tree (struct output_block *ob, tree expr, int ix)\n+lto_output_builtin_tree (struct output_block *ob, tree expr)\n {\n   gcc_assert (lto_stream_as_builtin_p (expr));\n \n@@ -1305,7 +1296,6 @@ lto_output_builtin_tree (struct output_block *ob, tree expr, int ix)\n   output_record_start (ob, LTO_builtin_decl);\n   output_uleb128 (ob, DECL_BUILT_IN_CLASS (expr));\n   output_uleb128 (ob, DECL_FUNCTION_CODE (expr));\n-  output_sleb128 (ob, ix);\n \n   if (DECL_ASSEMBLER_NAME_SET_P (expr))\n     {\n@@ -1330,13 +1320,13 @@ lto_output_builtin_tree (struct output_block *ob, tree expr, int ix)\n    where EXPR is stored.  */\n \n static void\n-lto_write_tree (struct output_block *ob, tree expr, bool ref_p, int ix)\n+lto_write_tree (struct output_block *ob, tree expr, bool ref_p)\n {\n   struct bitpack_d bp;\n \n   /* Write the header, containing everything needed to materialize\n      EXPR on the reading side.  */\n-  lto_output_tree_header (ob, expr, ix);\n+  lto_output_tree_header (ob, expr);\n \n   /* Pack all the non-pointer fields in EXPR into a bitpack and write\n      the resulting bitpack.  */\n@@ -1373,9 +1363,8 @@ lto_output_integer_cst (struct output_block *ob, tree cst, bool ref_p)\n void\n lto_output_tree (struct output_block *ob, tree expr, bool ref_p)\n {\n-  int ix;\n+  unsigned ix;\n   bool existed_p;\n-  unsigned offset;\n \n   if (expr == NULL_TREE)\n     {\n@@ -1391,22 +1380,15 @@ lto_output_tree (struct output_block *ob, tree expr, bool ref_p)\n       return;\n     }\n \n-  /* Determine the offset in the stream where EXPR will be written.\n-     This is used when emitting pickle references so the reader knows\n-     where to reconstruct the pickled object from.  This allows\n-     circular and forward references within the same stream.  */\n-  offset = ob->main_stream->total_size;\n-\n-  existed_p = lto_streamer_cache_insert (ob->writer_cache, expr, &ix, &offset);\n+  existed_p = lto_streamer_cache_insert (ob->writer_cache, expr, &ix);\n   if (existed_p)\n     {\n       /* If a node has already been streamed out, make sure that\n \t we don't write it more than once.  Otherwise, the reader\n \t will instantiate two different nodes for the same object.  */\n       output_record_start (ob, LTO_tree_pickle_reference);\n-      output_sleb128 (ob, ix);\n+      output_uleb128 (ob, ix);\n       output_uleb128 (ob, lto_tree_code_to_tag (TREE_CODE (expr)));\n-      output_uleb128 (ob, offset);\n     }\n   else if (lto_stream_as_builtin_p (expr))\n     {\n@@ -1415,13 +1397,13 @@ lto_output_tree (struct output_block *ob, tree expr, bool ref_p)\n \t compiler on startup.  The only builtins that need to\n \t be written out are BUILT_IN_FRONTEND.  For all other\n \t builtins, we simply write the class and code.  */\n-      lto_output_builtin_tree (ob, expr, ix);\n+      lto_output_builtin_tree (ob, expr);\n     }\n   else\n     {\n       /* This is the first time we see EXPR, write its fields\n \t to OB.  */\n-      lto_write_tree (ob, expr, ref_p, ix);\n+      lto_write_tree (ob, expr, ref_p);\n     }\n }\n \n@@ -2085,7 +2067,6 @@ output_unreferenced_globals (cgraph_node_set set, varpool_node_set vset)\n   struct output_block *ob;\n   alias_pair *p;\n   unsigned i;\n-  struct varpool_node *vnode;\n   symbol_alias_set_t *defined;\n   struct sets setdata;\n \n@@ -2100,30 +2081,6 @@ output_unreferenced_globals (cgraph_node_set set, varpool_node_set vset)\n   /* Make string 0 be a NULL string.  */\n   lto_output_1_stream (ob->string_stream, 0);\n \n-  /* Emit references for all the global symbols.  If a global symbol\n-     was never referenced in any of the functions of this file, it\n-     would not be emitted otherwise.  This will result in unreferenced\n-     symbols at link time if a file defines a global symbol but\n-     never references it.  */\n-  FOR_EACH_STATIC_VARIABLE (vnode)\n-   if (vnode->needed && varpool_node_in_set_p (vnode, vset))\n-      {\n-\ttree var = vnode->decl;\n-\n-\tif (TREE_CODE (var) == VAR_DECL)\n-\t  {\n-\t    /* Output the object in order to output references used in the\n-\t       initialization. */\n-\t    lto_output_tree (ob, var, true);\n-\n-\t    /* If it is public we also need a reference to the object itself. */\n-\t    if (TREE_PUBLIC (var))\n-\t      lto_output_tree_ref (ob, var);\n-\t  }\n-      }\n-\n-  output_zero (ob);\n-\n   /* We really need to propagate in both directoins:\n      for normal aliases we propagate from first defined alias to\n      all aliases defined based on it.  For weakrefs we propagate in\n@@ -2327,19 +2284,19 @@ write_global_references (struct output_block *ob,\n  \t\t\t struct lto_tree_ref_encoder *encoder)\n {\n   tree t;\n-  int32_t index;\n-  const int32_t size = lto_tree_ref_encoder_size (encoder);\n+  uint32_t index;\n+  const uint32_t size = lto_tree_ref_encoder_size (encoder);\n \n   /* Write size as 32-bit unsigned. */\n   lto_output_data_stream (ref_stream, &size, sizeof (int32_t));\n \n   for (index = 0; index < size; index++)\n     {\n-      int32_t slot_num;\n+      uint32_t slot_num;\n \n       t = lto_tree_ref_encoder_get_tree (encoder, index);\n       lto_streamer_cache_lookup (ob->writer_cache, t, &slot_num);\n-      gcc_assert (slot_num >= 0);\n+      gcc_assert (slot_num != (unsigned)-1);\n       lto_output_data_stream (ref_stream, &slot_num, sizeof slot_num);\n     }\n }\n@@ -2368,15 +2325,15 @@ lto_output_decl_state_refs (struct output_block *ob,\n \t\t\t    struct lto_out_decl_state *state)\n {\n   unsigned i;\n-  int32_t ref;\n+  uint32_t ref;\n   tree decl;\n \n   /* Write reference to FUNCTION_DECL.  If there is not function,\n      write reference to void_type_node. */\n   decl = (state->fn_decl) ? state->fn_decl : void_type_node;\n   lto_streamer_cache_lookup (ob->writer_cache, decl, &ref);\n-  gcc_assert (ref >= 0);\n-  lto_output_data_stream (out_stream, &ref, sizeof (int32_t));\n+  gcc_assert (ref != (unsigned)-1);\n+  lto_output_data_stream (out_stream, &ref, sizeof (uint32_t));\n \n   for (i = 0;  i < LTO_N_DECL_STREAMS; i++)\n     write_global_references (ob, out_stream, &state->streams[i]);\n@@ -2413,7 +2370,7 @@ write_symbol (struct lto_streamer_cache_d *cache,\n   const char *name;\n   enum gcc_plugin_symbol_kind kind;\n   enum gcc_plugin_symbol_visibility visibility;\n-  int slot_num;\n+  unsigned slot_num;\n   uint64_t size;\n   const char *comdat;\n   unsigned char c;\n@@ -2440,7 +2397,7 @@ write_symbol (struct lto_streamer_cache_d *cache,\n   pointer_set_insert (seen, name);\n \n   lto_streamer_cache_lookup (cache, t, &slot_num);\n-  gcc_assert (slot_num >= 0);\n+  gcc_assert (slot_num != (unsigned)-1);\n \n   if (DECL_EXTERNAL (t))\n     {\n@@ -2551,7 +2508,7 @@ produce_symtab (struct output_block *ob,\n   memset (&stream, 0, sizeof (stream));\n \n   /* Write all functions. \n-     First write all defined functions and the write all used functions.\n+     First write all defined functions and then write all used functions.\n      This is done so only to handle duplicated symbols in cgraph.  */\n   for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n     {"}, {"sha": "06afb97f35594c096084cfdc93ca256f00141241", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 45, "deletions": 66, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=e89964e31c5f26caefe5fffb0ccc1fb4932f44bc", "patch": "@@ -314,29 +314,25 @@ check_handled_ts_structures (void)\n \n \n /* Helper for lto_streamer_cache_insert_1.  Add T to CACHE->NODES at\n-   slot IX.  Add OFFSET to CACHE->OFFSETS at slot IX.  */\n+   slot IX.  */\n \n static void\n lto_streamer_cache_add_to_node_array (struct lto_streamer_cache_d *cache,\n-\t\t\t\t      int ix, tree t, unsigned offset)\n+\t\t\t\t      unsigned ix, tree t)\n {\n-  gcc_assert (ix >= 0);\n+  /* Make sure we're either replacing an old element or\n+     appending consecutively.  */\n+  gcc_assert (ix <= VEC_length (tree, cache->nodes));\n \n-  /* Grow the array of nodes and offsets to accomodate T at IX.  */\n-  if (ix >= (int) VEC_length (tree, cache->nodes))\n-    {\n-      size_t sz = ix + (20 + ix) / 4;\n-      VEC_safe_grow_cleared (tree, heap, cache->nodes, sz);\n-      VEC_safe_grow_cleared (unsigned, heap, cache->offsets, sz);\n-    }\n-\n-  VEC_replace (tree, cache->nodes, ix, t);\n-  VEC_replace (unsigned, cache->offsets, ix, offset);\n+  if (ix == VEC_length (tree, cache->nodes))\n+    VEC_safe_push (tree, heap, cache->nodes, t);\n+  else\n+    VEC_replace (tree, cache->nodes, ix, t);\n }\n \n \n /* Helper for lto_streamer_cache_insert and lto_streamer_cache_insert_at.\n-   CACHE, T, IX_P and OFFSET_P are as in lto_streamer_cache_insert.\n+   CACHE, T, and IX_P are as in lto_streamer_cache_insert.\n \n    If INSERT_AT_NEXT_SLOT_P is true, T is inserted at the next available\n    slot in the cache.  Otherwise, T is inserted at the position indicated\n@@ -347,13 +343,12 @@ lto_streamer_cache_add_to_node_array (struct lto_streamer_cache_d *cache,\n \n static bool\n lto_streamer_cache_insert_1 (struct lto_streamer_cache_d *cache,\n-\t\t\t     tree t, int *ix_p, unsigned *offset_p,\n+\t\t\t     tree t, unsigned *ix_p,\n \t\t\t     bool insert_at_next_slot_p)\n {\n   void **slot;\n   struct tree_int_map d_entry, *entry;\n-  int ix;\n-  unsigned offset;\n+  unsigned ix;\n   bool existed_p;\n \n   gcc_assert (t);\n@@ -364,28 +359,24 @@ lto_streamer_cache_insert_1 (struct lto_streamer_cache_d *cache,\n     {\n       /* Determine the next slot to use in the cache.  */\n       if (insert_at_next_slot_p)\n-\tix = cache->next_slot++;\n+\tix = VEC_length (tree, cache->nodes);\n       else\n \tix = *ix_p;\n \n       entry = (struct tree_int_map *)pool_alloc (cache->node_map_entries);\n       entry->base.from = t;\n-      entry->to = (unsigned) ix;\n+      entry->to = ix;\n       *slot = entry;\n \n-      /* If no offset was given, store the invalid offset -1.  */\n-      offset = (offset_p) ? *offset_p : (unsigned) -1;\n-\n-      lto_streamer_cache_add_to_node_array (cache, ix, t, offset);\n+      lto_streamer_cache_add_to_node_array (cache, ix, t);\n \n       /* Indicate that the item was not present in the cache.  */\n       existed_p = false;\n     }\n   else\n     {\n       entry = (struct tree_int_map *) *slot;\n-      ix = (int) entry->to;\n-      offset = VEC_index (unsigned, cache->offsets, ix);\n+      ix = entry->to;\n \n       if (!insert_at_next_slot_p && ix != *ix_p)\n \t{\n@@ -404,10 +395,7 @@ lto_streamer_cache_insert_1 (struct lto_streamer_cache_d *cache,\n \t  gcc_assert (lto_stream_as_builtin_p (t));\n \t  ix = *ix_p;\n \n-\t  /* Since we are storing a builtin, the offset into the\n-\t     stream is not necessary as we will not need to read\n-\t     forward in the stream.  */\n-\t  lto_streamer_cache_add_to_node_array (cache, ix, t, -1);\n+\t  lto_streamer_cache_add_to_node_array (cache, ix, t);\n \t}\n \n       /* Indicate that T was already in the cache.  */\n@@ -417,9 +405,6 @@ lto_streamer_cache_insert_1 (struct lto_streamer_cache_d *cache,\n   if (ix_p)\n     *ix_p = ix;\n \n-  if (offset_p)\n-    *offset_p = offset;\n-\n   return existed_p;\n }\n \n@@ -428,21 +413,13 @@ lto_streamer_cache_insert_1 (struct lto_streamer_cache_d *cache,\n    return true.  Otherwise, return false.\n \n    If IX_P is non-null, update it with the index into the cache where\n-   T has been stored.\n-\n-   *OFFSET_P represents the offset in the stream where T is physically\n-   written out.  The first time T is added to the cache, *OFFSET_P is\n-   recorded in the cache together with T.  But if T already existed\n-   in the cache, *OFFSET_P is updated with the value that was recorded\n-   the first time T was added to the cache.\n-\n-   If OFFSET_P is NULL, it is ignored.  */\n+   T has been stored.  */\n \n bool\n lto_streamer_cache_insert (struct lto_streamer_cache_d *cache, tree t,\n-\t\t\t   int *ix_p, unsigned *offset_p)\n+\t\t\t   unsigned *ix_p)\n {\n-  return lto_streamer_cache_insert_1 (cache, t, ix_p, offset_p, true);\n+  return lto_streamer_cache_insert_1 (cache, t, ix_p, true);\n }\n \n \n@@ -451,24 +428,33 @@ lto_streamer_cache_insert (struct lto_streamer_cache_d *cache, tree t,\n \n bool\n lto_streamer_cache_insert_at (struct lto_streamer_cache_d *cache,\n-\t\t\t      tree t, int ix)\n+\t\t\t      tree t, unsigned ix)\n {\n-  return lto_streamer_cache_insert_1 (cache, t, &ix, NULL, false);\n+  return lto_streamer_cache_insert_1 (cache, t, &ix, false);\n }\n \n \n-/* Return true if tree node T exists in CACHE.  If IX_P is\n+/* Appends tree node T to CACHE, even if T already existed in it.  */\n+\n+void\n+lto_streamer_cache_append (struct lto_streamer_cache_d *cache, tree t)\n+{\n+  unsigned ix = VEC_length (tree, cache->nodes);\n+  lto_streamer_cache_insert_1 (cache, t, &ix, false);\n+}\n+\n+/* Return true if tree node T exists in CACHE, otherwise false.  If IX_P is\n    not NULL, write to *IX_P the index into the cache where T is stored\n-   (-1 if T is not found).  */\n+   ((unsigned)-1 if T is not found).  */\n \n bool\n lto_streamer_cache_lookup (struct lto_streamer_cache_d *cache, tree t,\n-\t\t\t   int *ix_p)\n+\t\t\t   unsigned *ix_p)\n {\n   void **slot;\n   struct tree_int_map d_slot;\n   bool retval;\n-  int ix;\n+  unsigned ix;\n \n   gcc_assert (t);\n \n@@ -482,7 +468,7 @@ lto_streamer_cache_lookup (struct lto_streamer_cache_d *cache, tree t,\n   else\n     {\n       retval = true;\n-      ix = (int) ((struct tree_int_map *) *slot)->to;\n+      ix = ((struct tree_int_map *) *slot)->to;\n     }\n \n   if (ix_p)\n@@ -495,17 +481,14 @@ lto_streamer_cache_lookup (struct lto_streamer_cache_d *cache, tree t,\n /* Return the tree node at slot IX in CACHE.  */\n \n tree\n-lto_streamer_cache_get (struct lto_streamer_cache_d *cache, int ix)\n+lto_streamer_cache_get (struct lto_streamer_cache_d *cache, unsigned ix)\n {\n   gcc_assert (cache);\n \n-  /* If the reader is requesting an index beyond the length of the\n-     cache, it will need to read ahead.  Return NULL_TREE to indicate\n-     that.  */\n-  if ((unsigned) ix >= VEC_length (tree, cache->nodes))\n-    return NULL_TREE;\n+  /* Make sure we're not requesting something we don't have.  */\n+  gcc_assert (ix < VEC_length (tree, cache->nodes));\n \n-  return VEC_index (tree, cache->nodes, (unsigned) ix);\n+  return VEC_index (tree, cache->nodes, ix);\n }\n \n \n@@ -538,13 +521,10 @@ lto_record_common_node (tree *nodep, VEC(tree, heap) **common_nodes,\n \n   VEC_safe_push (tree, heap, *common_nodes, node);\n \n-  if (tree_node_can_be_shared (node))\n-    {\n-      if (POINTER_TYPE_P (node)\n-\t  || TREE_CODE (node) == COMPLEX_TYPE\n-\t  || TREE_CODE (node) == ARRAY_TYPE)\n-\tlto_record_common_node (&TREE_TYPE (node), common_nodes, seen_nodes);\n-    }\n+  if (POINTER_TYPE_P (node)\n+      || TREE_CODE (node) == COMPLEX_TYPE\n+      || TREE_CODE (node) == ARRAY_TYPE)\n+    lto_record_common_node (&TREE_TYPE (node), common_nodes, seen_nodes);\n }\n \n \n@@ -607,7 +587,7 @@ preload_common_node (struct lto_streamer_cache_d *cache, tree t)\n {\n   gcc_assert (t);\n \n-  lto_streamer_cache_insert (cache, t, NULL, NULL);\n+  lto_streamer_cache_insert (cache, t, NULL);\n \n  /* The FIELD_DECLs of structures should be shared, so that every\n     COMPONENT_REF uses the same tree node when referencing a field.\n@@ -667,7 +647,6 @@ lto_streamer_cache_delete (struct lto_streamer_cache_d *c)\n   htab_delete (c->node_map);\n   free_alloc_pool (c->node_map_entries);\n   VEC_free (tree, heap, c->nodes);\n-  VEC_free (unsigned, heap, c->offsets);\n   free (c);\n }\n "}, {"sha": "43b8fcb77a632de54f1634de3adf072310d81bbd", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=e89964e31c5f26caefe5fffb0ccc1fb4932f44bc", "patch": "@@ -350,14 +350,8 @@ struct lto_streamer_cache_d\n   /* Node map to store entries into.  */\n   alloc_pool node_map_entries;\n \n-  /* Next available slot in the nodes and offsets arrays.  */\n-  unsigned next_slot;\n-\n   /* The nodes pickled so far.  */\n   VEC(tree,heap) *nodes;\n-\n-  /* Offset into the stream where the nodes have been written.  */\n-  VEC(unsigned,heap) *offsets;\n };\n \n \n@@ -831,12 +825,13 @@ extern void lto_bitmap_free (bitmap);\n extern char *lto_get_section_name (int, const char *, struct lto_file_decl_data *);\n extern void print_lto_report (void);\n extern bool lto_streamer_cache_insert (struct lto_streamer_cache_d *, tree,\n-\t\t\t\t       int *, unsigned *);\n+\t\t\t\t       unsigned *);\n extern bool lto_streamer_cache_insert_at (struct lto_streamer_cache_d *, tree,\n-\t\t\t\t\t  int);\n+\t\t\t\t\t  unsigned);\n+extern void lto_streamer_cache_append (struct lto_streamer_cache_d *, tree);\n extern bool lto_streamer_cache_lookup (struct lto_streamer_cache_d *, tree,\n-\t\t\t\t       int *);\n-extern tree lto_streamer_cache_get (struct lto_streamer_cache_d *, int);\n+\t\t\t\t       unsigned *);\n+extern tree lto_streamer_cache_get (struct lto_streamer_cache_d *, unsigned);\n extern struct lto_streamer_cache_d *lto_streamer_cache_create (void);\n extern void lto_streamer_cache_delete (struct lto_streamer_cache_d *);\n extern void lto_streamer_init (void);"}, {"sha": "00f695f00ee2b124ce67b095a405b48e3e0909bd", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=e89964e31c5f26caefe5fffb0ccc1fb4932f44bc", "patch": "@@ -1,3 +1,13 @@\n+2011-04-03  Michael Matz  <matz@suse.de>\n+\n+\t* lto.c (lto_materialize_function): Don't read and then discard\n+\tsections in WPA mode.\n+\t(lto_read_in_decl_state): Adjust call to lto_streamer_cache_get.\n+\n+\t* lto-lang.c (registered_builtin_fndecls): Remove.\n+\t(lto_getdecls): Return NULL_TREE.\n+\t(lto_builtin_function): Don't remember in registered_builtin_fndecls.\n+\n 2011-03-31  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/48246"}, {"sha": "535fc584f9009676817da4a2cf1eb033ad91772e", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=e89964e31c5f26caefe5fffb0ccc1fb4932f44bc", "patch": "@@ -615,11 +615,6 @@ lto_define_builtins (tree va_list_ref_type_node ATTRIBUTE_UNUSED,\n \n static GTY(()) tree registered_builtin_types;\n \n-/* A chain of builtin functions that we need to recognize.  We will\n-   assume that all other function names we see will be defined by the\n-   user's program.  */\n-static GTY(()) tree registered_builtin_fndecls;\n-\n /* Language hooks.  */\n \n static unsigned int\n@@ -994,7 +989,10 @@ lto_pushdecl (tree t ATTRIBUTE_UNUSED)\n static tree\n lto_getdecls (void)\n {\n-  return registered_builtin_fndecls;\n+  /* We have our own write_globals langhook, hence the getdecls\n+     langhook shouldn't be used, except by dbxout.c, so we can't\n+     just abort here.  */\n+  return NULL_TREE;\n }\n \n static void\n@@ -1010,10 +1008,6 @@ lto_write_globals (void)\n static tree\n lto_builtin_function (tree decl)\n {\n-  /* Record it.  */\n-  TREE_CHAIN (decl) = registered_builtin_fndecls;\n-  registered_builtin_fndecls = decl;\n-\n   return decl;\n }\n "}, {"sha": "556e7e69d167d1f9a2331922db4df5c279e695cb", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=e89964e31c5f26caefe5fffb0ccc1fb4932f44bc", "patch": "@@ -149,37 +149,36 @@ lto_materialize_function (struct cgraph_node *node)\n       /* Clones don't need to be read.  */\n       if (node->clone_of)\n \treturn;\n-      file_data = node->local.lto_file_data;\n-      name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)); \n-\n-      /* We may have renamed the declaration, e.g., a static function.  */\n-      name = lto_get_decl_name_mapping (file_data, name);\n-\n-      data = lto_get_section_data (file_data, LTO_section_function_body,\n-\t\t\t\t   name, &len);\n-      if (!data)\n-\tfatal_error (\"%s: section %s is missing\",\n-\t\t     file_data->file_name,\n-\t\t     name);\n-\n-      gcc_assert (DECL_STRUCT_FUNCTION (decl) == NULL);\n \n       /* Load the function body only if not operating in WPA mode.  In\n \t WPA mode, the body of the function is not needed.  */\n       if (!flag_wpa)\n \t{\n+\t  file_data = node->local.lto_file_data;\n+\t  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\n+\t  /* We may have renamed the declaration, e.g., a static function.  */\n+\t  name = lto_get_decl_name_mapping (file_data, name);\n+\n+\t  data = lto_get_section_data (file_data, LTO_section_function_body,\n+\t\t\t\t       name, &len);\n+\t  if (!data)\n+\t    fatal_error (\"%s: section %s is missing\",\n+\t\t\t file_data->file_name,\n+\t\t\t name);\n+\n+\t  gcc_assert (DECL_STRUCT_FUNCTION (decl) == NULL);\n+\n \t  allocate_struct_function (decl, false);\n \t  announce_function (decl);\n \t  lto_input_function_body (file_data, decl, data);\n \t  if (DECL_FUNCTION_PERSONALITY (decl) && !first_personality_decl)\n \t    first_personality_decl = DECL_FUNCTION_PERSONALITY (decl);\n \t  lto_stats.num_function_bodies++;\n+\t  lto_free_section_data (file_data, LTO_section_function_body, name,\n+\t\t\t\t data, len);\n+\t  ggc_collect ();\n \t}\n-\n-      lto_free_section_data (file_data, LTO_section_function_body, name,\n-\t\t\t     data, len);\n-      if (!flag_wpa)\n-\tggc_collect ();\n     }\n \n   /* Let the middle end know about the function.  */\n@@ -200,7 +199,7 @@ lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n   uint32_t i, j;\n   \n   ix = *data++;\n-  decl = lto_streamer_cache_get (data_in->reader_cache, (int) ix);\n+  decl = lto_streamer_cache_get (data_in->reader_cache, ix);\n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n       gcc_assert (decl == void_type_node);"}, {"sha": "84eae3e7d44d2476121f6198a90a99acaa175bac", "filename": "gcc/varasm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89964e31c5f26caefe5fffb0ccc1fb4932f44bc/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=e89964e31c5f26caefe5fffb0ccc1fb4932f44bc", "patch": "@@ -6798,7 +6798,7 @@ default_binds_local_p_1 (const_tree exp, int shlib)\n    current module (shared library or executable), that is to binds_local_p.\n    We use this fact to avoid need for another target hook and implement\n    the logic using binds_local_p and just special cases where\n-   decl_binds_to_current_def_p is stronger than binds local_p.  In particular\n+   decl_binds_to_current_def_p is stronger than binds_local_p.  In particular\n    the weak definitions (that can be overwritten at linktime by other\n    definition from different object file) and when resolution info is available\n    we simply use the knowledge passed to us by linker plugin.  */\n@@ -6811,15 +6811,15 @@ decl_binds_to_current_def_p (tree decl)\n   if (!targetm.binds_local_p (decl))\n     return false;\n   /* When resolution is available, just use it.  */\n-  if (TREE_CODE (decl) == VAR_DECL && TREE_PUBLIC (decl)\n+  if (TREE_CODE (decl) == VAR_DECL\n       && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n     {\n       struct varpool_node *vnode = varpool_get_node (decl);\n       if (vnode\n \t  && vnode->resolution != LDPR_UNKNOWN)\n \treturn resolution_to_local_definition_p (vnode->resolution);\n     }\n-  else if (TREE_CODE (decl) == FUNCTION_DECL && TREE_PUBLIC (decl))\n+  else if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       struct cgraph_node *node = cgraph_get_node_or_alias (decl);\n       if (node"}]}