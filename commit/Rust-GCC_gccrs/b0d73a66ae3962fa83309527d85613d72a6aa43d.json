{"sha": "b0d73a66ae3962fa83309527d85613d72a6aa43d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBkNzNhNjZhZTM5NjJmYTgzMzA5NTI3ZDg1NjEzZDcyYTZhYTQzZA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-11T20:00:52Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-11T20:00:52Z"}, "message": "c++: Substitute into function parms in lexical order [PR96560]\n\nThis makes tsubst_arg_types substitute into a function's parameter types\nin left-to-right instead of right-to-left order, in accordance with DR 1227.\n\n\tDR 1227\n\tPR c++/96560\n\ngcc/cp/ChangeLog:\n\n\t* pt.c (tsubst_arg_types): Rearrange so that we substitute into\n\tTYPE_ARG_TYPES in forward order while short circuiting\n\tappropriately.  Adjust formatting.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/template/sfinae-dr1227.C: New test.", "tree": {"sha": "e0413db10b88d4d2e525bfa2960dfd6c819a99c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0413db10b88d4d2e525bfa2960dfd6c819a99c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0d73a66ae3962fa83309527d85613d72a6aa43d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d73a66ae3962fa83309527d85613d72a6aa43d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0d73a66ae3962fa83309527d85613d72a6aa43d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d73a66ae3962fa83309527d85613d72a6aa43d/comments", "author": null, "committer": null, "parents": [{"sha": "1e690757d30775ed340a368b9a9463b2ad68de01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e690757d30775ed340a368b9a9463b2ad68de01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e690757d30775ed340a368b9a9463b2ad68de01"}], "stats": {"total": 138, "additions": 83, "deletions": 55}, "files": [{"sha": "141388ad2e5a1c82210d5f3f187818e6a3a5c9c7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 60, "deletions": 55, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d73a66ae3962fa83309527d85613d72a6aa43d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d73a66ae3962fa83309527d85613d72a6aa43d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b0d73a66ae3962fa83309527d85613d72a6aa43d", "patch": "@@ -14946,20 +14946,13 @@ tsubst_arg_types (tree arg_types,\n \t\t  tsubst_flags_t complain,\n \t\t  tree in_decl)\n {\n-  tree remaining_arg_types;\n   tree type = NULL_TREE;\n-  int i = 1;\n+  int len = 1;\n   tree expanded_args = NULL_TREE;\n-  tree default_arg;\n \n   if (!arg_types || arg_types == void_list_node || arg_types == end)\n     return arg_types;\n \n-  remaining_arg_types = tsubst_arg_types (TREE_CHAIN (arg_types),\n-\t\t\t\t\t  args, end, complain, in_decl);\n-  if (remaining_arg_types == error_mark_node)\n-    return error_mark_node;\n-\n   if (PACK_EXPANSION_P (TREE_VALUE (arg_types)))\n     {\n       /* For a pack expansion, perform substitution on the\n@@ -14970,7 +14963,7 @@ tsubst_arg_types (tree arg_types,\n \n       if (TREE_CODE (expanded_args) == TREE_VEC)\n         /* So that we'll spin through the parameters, one by one.  */\n-        i = TREE_VEC_LENGTH (expanded_args);\n+\tlen = TREE_VEC_LENGTH (expanded_args);\n       else\n         {\n           /* We only partially substituted into the parameter\n@@ -14979,59 +14972,71 @@ tsubst_arg_types (tree arg_types,\n           expanded_args = NULL_TREE;\n         }\n     }\n+  else\n+    type = tsubst (TREE_VALUE (arg_types), args, complain, in_decl);\n \n-  while (i > 0) {\n-    --i;\n-\n-    if (expanded_args)\n-      type = TREE_VEC_ELT (expanded_args, i);\n-    else if (!type)\n-      type = tsubst (TREE_VALUE (arg_types), args, complain, in_decl);\n+  /* Check if a substituted type is erroneous before substituting into\n+     the rest of the chain.  */\n+  for (int i = 0; i < len; i++)\n+    {\n+      if (expanded_args)\n+\ttype = TREE_VEC_ELT (expanded_args, i);\n \n-    if (type == error_mark_node)\n-      return error_mark_node;\n-    if (VOID_TYPE_P (type))\n-      {\n-        if (complain & tf_error)\n-          {\n-            error (\"invalid parameter type %qT\", type);\n-            if (in_decl)\n-              error (\"in declaration %q+D\", in_decl);\n-          }\n-        return error_mark_node;\n+      if (type == error_mark_node)\n+\treturn error_mark_node;\n+      if (VOID_TYPE_P (type))\n+\t{\n+\t  if (complain & tf_error)\n+\t    {\n+\t      error (\"invalid parameter type %qT\", type);\n+\t      if (in_decl)\n+\t\terror (\"in declaration %q+D\", in_decl);\n+\t    }\n+\t  return error_mark_node;\n+\t}\n     }\n \n-    /* Do array-to-pointer, function-to-pointer conversion, and ignore\n-       top-level qualifiers as required.  */\n-    type = cv_unqualified (type_decays_to (type));\n+  /* We do not substitute into default arguments here.  The standard\n+     mandates that they be instantiated only when needed, which is\n+     done in build_over_call.  */\n+  tree default_arg = TREE_PURPOSE (arg_types);\n \n-    /* We do not substitute into default arguments here.  The standard\n-       mandates that they be instantiated only when needed, which is\n-       done in build_over_call.  */\n-    default_arg = TREE_PURPOSE (arg_types);\n+  /* Except that we do substitute default arguments under tsubst_lambda_expr,\n+     since the new op() won't have any associated template arguments for us\n+     to refer to later.  */\n+  if (lambda_fn_in_template_p (in_decl))\n+    default_arg = tsubst_copy_and_build (default_arg, args, complain, in_decl,\n+\t\t\t\t\t false/*fn*/, false/*constexpr*/);\n \n-    /* Except that we do substitute default arguments under tsubst_lambda_expr,\n-       since the new op() won't have any associated template arguments for us\n-       to refer to later.  */\n-    if (lambda_fn_in_template_p (in_decl))\n-      default_arg = tsubst_copy_and_build (default_arg, args, complain, in_decl,\n-\t\t\t\t\t   false/*fn*/, false/*constexpr*/);\n+  tree remaining_arg_types = tsubst_arg_types (TREE_CHAIN (arg_types),\n+\t\t\t\t\t       args, end, complain, in_decl);\n+  if (remaining_arg_types == error_mark_node)\n+    return error_mark_node;\n \n-    if (default_arg && TREE_CODE (default_arg) == DEFERRED_PARSE)\n-      {\n-        /* We've instantiated a template before its default arguments\n-           have been parsed.  This can happen for a nested template\n-           class, and is not an error unless we require the default\n-           argument in a call of this function.  */\n-        remaining_arg_types = \n-          tree_cons (default_arg, type, remaining_arg_types);\n-\tvec_safe_push (DEFPARSE_INSTANTIATIONS (default_arg),\n-\t\t       remaining_arg_types);\n-      }\n-    else\n-      remaining_arg_types =\n-        hash_tree_cons (default_arg, type, remaining_arg_types);\n-  }\n+  for (int i = len-1; i >= 0; i--)\n+    {\n+      if (expanded_args)\n+\ttype = TREE_VEC_ELT (expanded_args, i);\n+\n+      /* Do array-to-pointer, function-to-pointer conversion, and ignore\n+\t top-level qualifiers as required.  */\n+      type = cv_unqualified (type_decays_to (type));\n+\n+      if (default_arg && TREE_CODE (default_arg) == DEFERRED_PARSE)\n+\t{\n+\t  /* We've instantiated a template before its default arguments\n+\t     have been parsed.  This can happen for a nested template\n+\t     class, and is not an error unless we require the default\n+\t     argument in a call of this function.  */\n+\t  remaining_arg_types\n+\t    = tree_cons (default_arg, type, remaining_arg_types);\n+\t  vec_safe_push (DEFPARSE_INSTANTIATIONS (default_arg),\n+\t\t\t remaining_arg_types);\n+\t}\n+      else\n+\tremaining_arg_types\n+\t  = hash_tree_cons (default_arg, type, remaining_arg_types);\n+    }\n \n   return remaining_arg_types;\n }"}, {"sha": "821ff0313b69764e3b26c003c5f9f72ad173c685", "filename": "gcc/testsuite/g++.dg/template/sfinae-dr1227.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d73a66ae3962fa83309527d85613d72a6aa43d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae-dr1227.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d73a66ae3962fa83309527d85613d72a6aa43d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae-dr1227.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae-dr1227.C?ref=b0d73a66ae3962fa83309527d85613d72a6aa43d", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/96560\n+// DR 1227\n+// Test that we substitute function parameter types in lexical order.\n+\n+template <class T>\n+struct A { typedef typename T::type type; }; // { dg-error \"void\" }\n+\n+template <class T> void f(typename T::type, typename A<T>::type);\n+template <class T> long f(...);\n+\n+long x = f<int>(0, 0); // { dg-bogus \"\" } OK\n+\n+\n+template <class T> void g(T, typename A<T>::type);\n+template <class T> long g(...);\n+\n+long y = g<void>(0, 0); // { dg-bogus \"\" } OK\n+\n+\n+template <class T> void h(typename A<T>::type, T);\n+template <class T> long h(...);\n+\n+long z = h<void>(0, 0); // { dg-message \"required from here\" } hard error"}]}