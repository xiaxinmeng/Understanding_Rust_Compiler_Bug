{"sha": "5cd2e126f5c5705fa1aa7fafef3d6b94a99593da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNkMmUxMjZmNWM1NzA1ZmExYWE3ZmFmZWYzZDZiOTRhOTk1OTNkYQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-01-29T13:36:15Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-01-29T13:36:15Z"}, "message": "libstdc++: Make tests for std::ranges access functions more robust\n\n\t* testsuite/std/ranges/access/end.cc: Do not assume test_range::end()\n\treturns the same type as test_range::begin(). Add comments.\n\t* testsuite/std/ranges/access/rbegin.cc: Likewise.\n\t* testsuite/std/ranges/access/rend.cc: Likewise.\n\t* testsuite/std/ranges/range.cc: Do not assume the sentinel for\n\ttest_range is the same as its iterator type.\n\t* testsuite/util/testsuite_iterators.h (test_range::sentinel): Add\n\toperator- overloads to satisfy sized_sentinel_for when the iterator\n\tsatisfies random_access_iterator.", "tree": {"sha": "d759fca7ab12d32e415c712b9afef00827a6a259", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d759fca7ab12d32e415c712b9afef00827a6a259"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6693911f069b1ada7c04aa1d00c3653ba694958a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6693911f069b1ada7c04aa1d00c3653ba694958a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6693911f069b1ada7c04aa1d00c3653ba694958a"}], "stats": {"total": 147, "additions": 112, "deletions": 35}, "files": [{"sha": "133e216cc5951388350e97d185ee75c57824d084", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5cd2e126f5c5705fa1aa7fafef3d6b94a99593da", "patch": "@@ -1,3 +1,15 @@\n+2020-01-29  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* testsuite/std/ranges/access/end.cc: Do not assume test_range::end()\n+\treturns the same type as test_range::begin(). Add comments.\n+\t* testsuite/std/ranges/access/rbegin.cc: Likewise.\n+\t* testsuite/std/ranges/access/rend.cc: Likewise.\n+\t* testsuite/std/ranges/range.cc: Do not assume the sentinel for\n+\ttest_range is the same as its iterator type.\n+\t* testsuite/util/testsuite_iterators.h (test_range::sentinel): Add\n+\toperator- overloads to satisfy sized_sentinel_for when the iterator\n+\tsatisfies random_access_iterator.\n+\n 2020-01-28  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/93470"}, {"sha": "c3a1028dc148e9f0740c58bc3fb9a6cab2716eac", "filename": "libstdc++-v3/testsuite/std/ranges/access/end.cc", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fend.cc?ref=5cd2e126f5c5705fa1aa7fafef3d6b94a99593da", "patch": "@@ -29,6 +29,8 @@ test01()\n {\n   int a[2] = {};\n \n+  // t + extent_v<T> if E is of array type T.\n+\n   static_assert(same_as<decltype(std::ranges::end(a)), decltype(a + 2)>);\n   static_assert(noexcept(std::ranges::end(a)));\n   VERIFY( std::ranges::end(a) == (a + 2) );\n@@ -44,13 +46,16 @@ test02()\n \n   int a[] = { 0, 1 };\n \n+  // Otherwise, decay-copy(t.end()) if it is a valid expression\n+  // and its type S models sentinel_for<decltype(ranges::begin(E))>.\n+\n   test_range<int, random_access_iterator_wrapper> r(a);\n   static_assert(same_as<decltype(std::ranges::end(r)), decltype(r.end())>);\n-  VERIFY( std::ranges::end(r) == r.end() );\n+  VERIFY( std::ranges::end(r) == std::ranges::next(r.begin(), 2) );\n \n   test_range<int, input_iterator_wrapper> i(a);\n   static_assert(same_as<decltype(std::ranges::end(i)), decltype(i.end())>);\n-  VERIFY( std::ranges::end(i) == i.end() );\n+  VERIFY( std::ranges::end(i) == std::ranges::next(i.begin(), 2) );\n \n   test_range<int, output_iterator_wrapper> o(a);\n   static_assert(same_as<decltype(std::ranges::end(o)), decltype(o.end())>);\n@@ -93,6 +98,9 @@ test03()\n   R r;\n   const R& c = r;\n \n+  // Otherwise, decay-copy(end(t)) if it is a valid expression\n+  // and its type S models sentinel_for<decltype(ranges::begin(E))>.\n+\n   static_assert(same_as<decltype(std::ranges::end(r)), decltype(end(r))>);\n   static_assert(!noexcept(std::ranges::end(r)));\n   VERIFY( std::ranges::end(r) == end(r) );"}, {"sha": "e92e5bc69ac9ff053c974aa69a18ebd5feaf66ea", "filename": "libstdc++-v3/testsuite/std/ranges/access/rbegin.cc", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frbegin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frbegin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frbegin.cc?ref=5cd2e126f5c5705fa1aa7fafef3d6b94a99593da", "patch": "@@ -38,6 +38,8 @@ void\n test01()\n {\n   constexpr R1 r;\n+  // decay-copy(t.rbegin()) if it is a valid expression\n+  // and its type I models input_or_output_iterator.\n   static_assert( std::ranges::rbegin(r) == &r.i );\n   static_assert( std::ranges::rbegin(std::move(r)) == &r.i );\n }\n@@ -60,6 +62,8 @@ void\n test02()\n {\n   constexpr R2 r;\n+  // Otherwise, decay-copy(rbegin(t)) if it is a valid expression\n+  // and its type I models input_or_output_iterator [...]\n   static_assert( std::ranges::rbegin(r)\n       == std::make_reverse_iterator(std::ranges::end(r)) );\n   static_assert( std::ranges::rbegin(std::move(r))\n@@ -69,11 +73,29 @@ test02()\n void\n test03()\n {\n-  using __gnu_test::test_range;\n-  using __gnu_test::bidirectional_iterator_wrapper;\n+  struct R3\n+  : __gnu_test::test_range<int, __gnu_test::bidirectional_iterator_wrapper>\n+  {\n+    R3(int (&a)[2]) : test_range(a) { }\n+\n+    using test_range::begin;\n+\n+    // Replace test_range::end() to return same type as begin()\n+    // so ranges::rbegin will wrap it in a reverse_iterator .\n+    auto end() &\n+    {\n+      using __gnu_test::bidirectional_iterator_wrapper;\n+      return bidirectional_iterator_wrapper<int>(bounds.last, &bounds);\n+    }\n+  };\n \n   int a[2] = { };\n-  test_range<int, bidirectional_iterator_wrapper> r(a);\n+  R3 r(a);\n+\n+  // Otherwise, make_reverse_iterator(ranges::end(t)) if both ranges::begin(t)\n+  // and ranges::end(t) are valid expressions of the same type I which models\n+  // bidirectional_iterator.\n+\n   VERIFY( std::ranges::rbegin(r) == std::make_reverse_iterator(std::ranges::end(r)) );\n }\n "}, {"sha": "f6909b8340cd4319873c4498782264889e2d9705", "filename": "libstdc++-v3/testsuite/std/ranges/access/rend.cc", "status": "modified", "additions": 55, "deletions": 28, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frend.cc?ref=5cd2e126f5c5705fa1aa7fafef3d6b94a99593da", "patch": "@@ -40,65 +40,91 @@ void\n test01()\n {\n   constexpr R1 r;\n+\n+  // decay-copy(t.rend()) if it is a valid expression\n+  // and its type S models sentinel_for<decltype(ranges::rbegin(E))>\n+\n   static_assert( std::ranges::rend(r) == &r.i + 1 );\n   static_assert( std::ranges::rend(std::move(r)) == &r.i + 1 );\n }\n \n struct R2\n {\n-  int a[2] = { };\n-  long l[2] = { };\n+  int i = 0;\n \n-  constexpr const int* begin() const { return a; }\n-  constexpr const int* end() const { return a + 2; }\n+  int* rbegin() noexcept { return &i + 1; }\n+  long* rend() noexcept { return nullptr; } // not a sentinel for rbegin()\n \n-  friend constexpr const long* begin(const R2&& r) { return r.l; }\n-  friend constexpr const long* end(const R2&& r) { return r.l + 2; }\n+  friend long* rbegin(R2&) noexcept { return nullptr; }\n+  friend int* rend(R2& r) { return &r.i; }\n };\n \n-// N.B. this is a lie, begin/end on an R2 rvalue will return a dangling pointer.\n-template<> constexpr bool std::ranges::enable_safe_range<R2> = true;\n-\n void\n test02()\n {\n-  constexpr R2 r;\n-  static_assert( std::ranges::rend(r)\n-      == std::make_reverse_iterator(std::ranges::begin(r)) );\n-  static_assert( std::ranges::rend(std::move(r))\n-      == std::make_reverse_iterator(std::ranges::begin(std::move(r))) );\n+  R2 r;\n+\n+  // Otherwise, decay-copy(rend(t)) if it is a valid expression\n+  // and its type S models sentinel_for<decltype(ranges::rbegin(E))>\n+\n+  auto i1 = std::ranges::rbegin(r);\n+  auto i2 = rend(r);\n+  static_assert( std::sentinel_for<decltype(i2), decltype(i1)> );\n+  VERIFY( std::ranges::rend(r) == &r.i );\n+  static_assert( !noexcept(std::ranges::rend(r)) );\n }\n \n struct R3\n {\n-  int i = 0;\n+  int a[2] = { };\n+  long l[2] = { };\n \n-  int* rbegin() noexcept { return &i + 1; }\n-  long* rend() noexcept { return nullptr; } // not a sentinel for rbegin()\n+  constexpr const int* begin() const { return a; }\n+  constexpr const int* end() const { return a + 2; }\n \n-  friend long* rbegin(R3&) noexcept { return nullptr; }\n-  friend int* rend(R3& r) { return &r.i; }\n+  friend constexpr const long* begin(const R3&& r) { return r.l; }\n+  friend constexpr const long* end(const R3&& r) { return r.l + 2; }\n };\n \n+// N.B. this is a lie, begin/end on an R3 rvalue will return a dangling pointer.\n+template<> constexpr bool std::ranges::enable_safe_range<R3> = true;\n+\n void\n test03()\n {\n-  R3 r;\n-  auto i1 = std::ranges::rbegin(r);\n-  auto i2 = rend(r);\n-  static_assert( std::sentinel_for<decltype(i2), decltype(i1)> );\n-  // VERIFY( std::ranges::rend(r) == r.i );\n-  // static_assert( !noexcept(std::ranges::rend(r)) );\n+  constexpr R3 r;\n+\n+  // Otherwise, make_reverse_iterator(ranges::begin(t)) if both\n+  // ranges::begin(t) and ranges::end(t) are valid expressions\n+  // of the same type I which models bidirectional_iterator.\n+\n+  static_assert( std::ranges::rend(r)\n+      == std::make_reverse_iterator(std::ranges::begin(r)) );\n+  static_assert( std::ranges::rend(std::move(r))\n+      == std::make_reverse_iterator(std::ranges::begin(std::move(r))) );\n }\n \n void\n test04()\n {\n-  using __gnu_test::test_range;\n-  using __gnu_test::bidirectional_iterator_wrapper;\n+  struct R4\n+  : __gnu_test::test_range<int, __gnu_test::bidirectional_iterator_wrapper>\n+  {\n+    R4(int (&a)[2]) : test_range(a) { }\n+\n+    using test_range::begin;\n+\n+    // Replace test_range::end() to return same type as begin()\n+    // so ranges::rend will wrap it in a reverse_iterator.\n+    auto end() &\n+    {\n+      using __gnu_test::bidirectional_iterator_wrapper;\n+      return bidirectional_iterator_wrapper<int>(bounds.last, &bounds);\n+    }\n+  };\n \n   int a[2] = { };\n-  test_range<int, bidirectional_iterator_wrapper> r(a);\n+  R4 r(a);\n   VERIFY( std::ranges::rend(r) == std::make_reverse_iterator(std::ranges::begin(r)) );\n }\n \n@@ -108,4 +134,5 @@ main()\n   test01();\n   test02();\n   test03();\n+  test04();\n }"}, {"sha": "cf349de8735ab6b1e18727a46102027870a34377", "filename": "libstdc++-v3/testsuite/std/ranges/range.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Frange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Frange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Frange.cc?ref=5cd2e126f5c5705fa1aa7fafef3d6b94a99593da", "patch": "@@ -66,7 +66,7 @@ static_assert( same_as<std::ranges::iterator_t<O>,\n \t\t       decltype(std::declval<O&>().begin())> );\n \n static_assert( same_as<std::ranges::sentinel_t<C>,\n-\t\t       contiguous_iterator_wrapper<char>> );\n+\t\t       decltype(std::declval<C&>().end())> );\n static_assert( same_as<std::ranges::sentinel_t<O>,\n \t\t       decltype(std::declval<O&>().end())> );\n "}, {"sha": "1c7fbd001e015319d5395d7818610b4a62656db5", "filename": "libstdc++-v3/testsuite/util/testsuite_iterators.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd2e126f5c5705fa1aa7fafef3d6b94a99593da/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h?ref=5cd2e126f5c5705fa1aa7fafef3d6b94a99593da", "patch": "@@ -675,8 +675,16 @@ namespace __gnu_test\n \t{\n \t  T* end;\n \n-\t  friend bool operator==(const sentinel& s, const I& i)\n+\t  friend bool operator==(const sentinel& s, const I& i) noexcept\n \t  { return s.end == i.ptr; }\n+\n+\t  friend auto operator-(const sentinel& s, const I& i) noexcept\n+\t    requires std::random_access_iterator<I>\n+\t  { return s.end - i.ptr; }\n+\n+\t  friend auto operator-(const I& i, const sentinel& s) noexcept\n+\t    requires std::random_access_iterator<I>\n+\t  { return i.ptr - s.end; }\n \t};\n \n       auto"}]}