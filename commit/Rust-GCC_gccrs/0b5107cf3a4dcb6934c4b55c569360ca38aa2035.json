{"sha": "0b5107cf3a4dcb6934c4b55c569360ca38aa2035", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI1MTA3Y2YzYTRkY2I2OTM0YzRiNTVjNTY5MzYwY2EzOGFhMjAzNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-04-17T21:39:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-04-17T21:39:30Z"}, "message": "i386.c (athlon_cost): Fix lea, divide and XFmode move costs.\n\n\t* i386.c (athlon_cost): Fix lea, divide and XFmode move costs.\n\t(x86_integer_DFmode_moves, x86_partial_reg_dependency,\n\t x86_memory_mismatch_stall): New global variables.\n\t(ix86_adjust_cost): Handle MEMORY_BOTH on places MEMORY_STORE was only\n\talloved; fix load penalties for Athlon.\n\t* i386.h (x86_integer_DFmode_moves, x86_partial_reg_dependency,\n\tx86_memory_mismatch_stall): Declare.\n\t(TARGET_INTEGER_DFMODE_MOVES, TARGET_PARTIAL_REG_DEPENDENCY,\n\t TARGET_MEMORY_MISMATCH_STALL): New.\n\t* i386.md (athlon scheduling parameters): Fix latencies according to\n\tAthlon Optimization Manual.\n\t(sahf, xchg, fldcw, leave instruction patterns): Set athlon_decode to\n\tvector.\n\t(fsqrt instruction patterns): Set athlon_decode to direct.\n\t(movhi_1): Promote for TARGET_PARTIAL_REG_DEPENDENCY and for\n\tPARTIAL_REGISTER_STALL with !TARGET_HIMODE_MATH machines.\n\t(movqi_1): Handle promoting correctly for TARGET_PARTIAL_REG_DEPENDENCY\n\tand TARGET_PARTIAL_REGISTER_STALL machines.\n\t(pushdf_nointeger): New pattern.\n\t(pushdf_integer): Rename from pushdf.\n\t(movdf_nointger): Enable for !TARGET_INTEGER_DFMODE_MOVES machines.\n\t(movdf_intger): Disable for !TARGET_INTEGER_DFMODE_MOVES machines.\n\nFrom-SVN: r33215", "tree": {"sha": "f968a9f00f97ceb6019eb8ab06dc60d7581752dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f968a9f00f97ceb6019eb8ab06dc60d7581752dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b5107cf3a4dcb6934c4b55c569360ca38aa2035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b5107cf3a4dcb6934c4b55c569360ca38aa2035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b5107cf3a4dcb6934c4b55c569360ca38aa2035", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b5107cf3a4dcb6934c4b55c569360ca38aa2035/comments", "author": null, "committer": null, "parents": [{"sha": "10f135942226e4ae2bbeb48515be4368d9745d68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f135942226e4ae2bbeb48515be4368d9745d68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10f135942226e4ae2bbeb48515be4368d9745d68"}], "stats": {"total": 302, "additions": 236, "deletions": 66}, "files": [{"sha": "8d11d84a3c3c114e6decd6fe901fdb635b4bb8ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5107cf3a4dcb6934c4b55c569360ca38aa2035/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5107cf3a4dcb6934c4b55c569360ca38aa2035/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b5107cf3a4dcb6934c4b55c569360ca38aa2035", "patch": "@@ -1,3 +1,28 @@\n+Mon Apr 17 23:35:29 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (athlon_cost): Fix lea, divide and XFmode move costs.\n+\t(x86_integer_DFmode_moves, x86_partial_reg_dependency,\n+\t x86_memory_mismatch_stall): New global variables.\n+\t(ix86_adjust_cost): Handle MEMORY_BOTH on places MEMORY_STORE was only\n+\talloved; fix load penalties for Athlon.\n+\t* i386.h (x86_integer_DFmode_moves, x86_partial_reg_dependency,\n+\tx86_memory_mismatch_stall): Declare.\n+\t(TARGET_INTEGER_DFMODE_MOVES, TARGET_PARTIAL_REG_DEPENDENCY,\n+\t TARGET_MEMORY_MISMATCH_STALL): New.\n+\t* i386.md (athlon scheduling parameters): Fix latencies according to\n+\tAthlon Optimization Manual.\n+\t(sahf, xchg, fldcw, leave instruction patterns): Set athlon_decode to\n+\tvector.\n+\t(fsqrt instruction patterns): Set athlon_decode to direct.\n+\t(movhi_1): Promote for TARGET_PARTIAL_REG_DEPENDENCY and for\n+\tPARTIAL_REGISTER_STALL with !TARGET_HIMODE_MATH machines.\n+\t(movqi_1): Handle promoting correctly for TARGET_PARTIAL_REG_DEPENDENCY\n+\tand TARGET_PARTIAL_REGISTER_STALL machines.\n+\t(pushdf_nointeger): New pattern.\n+\t(pushdf_integer): Rename from pushdf.\n+\t(movdf_nointger): Enable for !TARGET_INTEGER_DFMODE_MOVES machines.\n+\t(movdf_intger): Disable for !TARGET_INTEGER_DFMODE_MOVES machines.\n+\n 2000-04-17  Richard Henderson  <rth@cygnus.com>\n \n \t* loop.c (canonicalize_condition): Add WANT_REG argument."}, {"sha": "b2e81a47e2ac4d2d449fe0f46e9c7937958a373b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5107cf3a4dcb6934c4b55c569360ca38aa2035/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5107cf3a4dcb6934c4b55c569360ca38aa2035/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0b5107cf3a4dcb6934c4b55c569360ca38aa2035", "patch": "@@ -163,12 +163,12 @@ struct processor_costs k6_cost = {\n \n struct processor_costs athlon_cost = {\n   1,\t\t\t\t\t/* cost of an add instruction */\n-  1,\t\t\t\t\t/* cost of a lea instruction */\n+  2,\t\t\t\t\t/* cost of a lea instruction */\n   1,\t\t\t\t\t/* variable shift costs */\n   1,\t\t\t\t\t/* constant shift costs */\n   5,\t\t\t\t\t/* cost of starting a multiply */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n-  19,\t\t\t\t\t/* cost of a divide/mod */\n+  42,\t\t\t\t\t/* cost of a divide/mod */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n   4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -177,9 +177,9 @@ struct processor_costs athlon_cost = {\n \t\t\t\t\t   Relative to reg-reg move (2). */\n   {2, 3, 2},\t\t\t\t/* cost of storing integer registers */\n   4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {6, 6, 6},\t\t\t\t/* cost of loading fp registers\n+  {6, 6, 20},\t\t\t\t/* cost of loading fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 4, 4}\t\t\t\t/* cost of loading integer registers */\n+  {4, 4, 16}\t\t\t\t/* cost of loading integer registers */\n };\n \n struct processor_costs *ix86_cost = &pentium_cost;\n@@ -222,6 +222,9 @@ const int x86_sub_esp_4 = m_ATHLON | m_PPRO;\n const int x86_sub_esp_8 = m_ATHLON | m_PPRO | m_386 | m_486;\n const int x86_add_esp_4 = m_ATHLON | m_K6;\n const int x86_add_esp_8 = m_ATHLON | m_PPRO | m_K6 | m_386 | m_486;\n+const int x86_integer_DFmode_moves = ~m_ATHLON;\n+const int x86_partial_reg_dependency = m_ATHLON;\n+const int x86_memory_mismatch_stall = m_ATHLON;\n \n #define AT_BP(mode) (gen_rtx_MEM ((mode), hard_frame_pointer_rtx))\n \n@@ -6287,6 +6290,7 @@ ix86_adjust_cost (insn, link, dep_insn, cost)\n      int cost;\n {\n   enum attr_type insn_type, dep_insn_type;\n+  enum attr_memory memory;\n   rtx set, set2;\n   int dep_insn_code_number;\n \n@@ -6334,7 +6338,8 @@ ix86_adjust_cost (insn, link, dep_insn, cost)\n \t increase the cost here for non-imov insns.  */\n       if (dep_insn_type != TYPE_IMOV\n \t  && dep_insn_type != TYPE_FMOV\n-\t  && get_attr_memory (dep_insn) == MEMORY_LOAD)\n+\t  && ((memory = get_attr_memory (dep_insn) == MEMORY_LOAD)\n+              || memory == MEMORY_BOTH))\n \tcost += 1;\n \n       /* INT->FP conversion is expensive.  */\n@@ -6359,7 +6364,8 @@ ix86_adjust_cost (insn, link, dep_insn, cost)\n \n       /* Since we can't represent delayed latencies of load+operation, \n \t increase the cost here for non-imov insns.  */\n-      if (get_attr_memory (dep_insn) == MEMORY_LOAD)\n+      if ((memory = get_attr_memory (dep_insn) == MEMORY_LOAD)\n+          || memory == MEMORY_BOTH)\n \tcost += (dep_insn_type != TYPE_IMOV) ? 2 : 1;\n \n       /* INT->FP conversion is expensive.  */\n@@ -6368,19 +6374,15 @@ ix86_adjust_cost (insn, link, dep_insn, cost)\n       break;\n \n     case PROCESSOR_ATHLON:\n-      /* Address Generation Interlock cause problems on the Athlon CPU because\n-         the loads and stores are done in order so once one load or store has\n-\t to wait, others must too, so penalize the AGIs slightly by one cycle.\n-\t We might experiment with this value later.  */\n-      if (ix86_agi_dependant (insn, dep_insn, insn_type))\n-\tcost += 1;\n+      if ((memory = get_attr_memory (dep_insn)) == MEMORY_LOAD\n+           || memory == MEMORY_BOTH)\n+\t{\n+\t  if (dep_insn_type == TYPE_IMOV || dep_insn_type == TYPE_FMOV)\n+\t    cost += 2;\n+\t  else\n+\t    cost += 3;\n+        }\n \n-      /* Since we can't represent delayed latencies of load+operation, \n-\t increase the cost here for non-imov insns.  */\n-      if (dep_insn_type != TYPE_IMOV\n-\t  && dep_insn_type != TYPE_FMOV\n-\t  && get_attr_memory (dep_insn) == MEMORY_LOAD)\n-\tcost += 2;\n     default:\n       break;\n     }"}, {"sha": "8ae7be8d44467d10337e4761362eb694f09ece36", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5107cf3a4dcb6934c4b55c569360ca38aa2035/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5107cf3a4dcb6934c4b55c569360ca38aa2035/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=0b5107cf3a4dcb6934c4b55c569360ca38aa2035", "patch": "@@ -173,8 +173,9 @@ extern const int x86_use_cltd, x86_read_modify_write;\n extern const int x86_read_modify, x86_split_long_moves;\n extern const int x86_promote_QImode, x86_single_stringop;\n extern const int x86_himode_math, x86_qimode_math, x86_promote_qi_regs;\n-extern const int x86_promote_hi_regs;\n+extern const int x86_promote_hi_regs, x86_integer_DFmode_moves;\n extern const int x86_add_esp_4, x86_add_esp_8, x86_sub_esp_4, x86_sub_esp_8;\n+extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;\n \n #define TARGET_USE_LEAVE (x86_use_leave & CPUMASK)\n #define TARGET_PUSH_MEMORY (x86_push_memory & CPUMASK)\n@@ -206,6 +207,9 @@ extern const int x86_add_esp_4, x86_add_esp_8, x86_sub_esp_4, x86_sub_esp_8;\n #define TARGET_ADD_ESP_8 (x86_add_esp_8 & CPUMASK)\n #define TARGET_SUB_ESP_4 (x86_sub_esp_4 & CPUMASK)\n #define TARGET_SUB_ESP_8 (x86_sub_esp_8 & CPUMASK)\n+#define TARGET_INTEGER_DFMODE_MOVES (x86_integer_DFmode_moves & CPUMASK)\n+#define TARGET_PARTIAL_REG_DEPENDENCY (x86_partial_reg_dependency & CPUMASK)\n+#define TARGET_MEMORY_MISMATCH_STALL (x86_memory_mismatch_stall & CPUMASK)\n \n #define TARGET_STACK_PROBE (target_flags & MASK_STACK_PROBE)\n "}, {"sha": "8b9b2530e78709e780beca59efdda59eaad6454f", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 186, "deletions": 47, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5107cf3a4dcb6934c4b55c569360ca38aa2035/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5107cf3a4dcb6934c4b55c569360ca38aa2035/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0b5107cf3a4dcb6934c4b55c569360ca38aa2035", "patch": "@@ -738,7 +738,7 @@\n ;; communicates with all the execution units seperately instead.\n \n (define_attr \"athlon_decode\" \"direct,vector\"\n-  (cond [(eq_attr \"type\" \"call,imul,idiv,other,multi,fcmov,fpspc,str\")\n+  (cond [(eq_attr \"type\" \"call,imul,idiv,other,multi,fcmov,fpspc,str,pop,cld,fcmov\")\n \t   (const_string \"vector\")\n          (and (eq_attr \"type\" \"push\")\n               (match_operand 1 \"memory_operand\" \"\"))\n@@ -766,7 +766,7 @@\n \n (define_function_unit \"athlon_ieu\" 3 0\n   (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"type\" \"alu1,negnot,alu,icmp,imov,imovx,lea,incdec,ishift,imul,idiv,ibr,setcc,push,pop,call,callv,icmov,str,cld\"))\n+       (eq_attr \"type\" \"alu1,negnot,alu,icmp,imov,imovx,lea,incdec,ishift,ibr,call,callv,icmov,cld,pop,setcc,push,pop\"))\n   1 1)\n \n (define_function_unit \"athlon_ieu\" 3 0\n@@ -777,12 +777,12 @@\n (define_function_unit \"athlon_ieu\" 3 0\n   (and (eq_attr \"cpu\" \"athlon\")\n        (eq_attr \"type\" \"imul\"))\n-  4 0)\n+  5 0)\n \n (define_function_unit \"athlon_ieu\" 3 0\n   (and (eq_attr \"cpu\" \"athlon\")\n        (eq_attr \"type\" \"idiv\"))\n-  27 0)\n+  42 0)\n \n (define_function_unit \"athlon_muldiv\" 1 0\n   (and (eq_attr \"cpu\" \"athlon\")\n@@ -792,56 +792,118 @@\n (define_function_unit \"athlon_muldiv\" 1 0\n   (and (eq_attr \"cpu\" \"athlon\")\n        (eq_attr \"type\" \"idiv\"))\n-  27 27)\n+  42 42)\n \n-(define_attr \"athlon_fpunits\" \"none,store,mul,add,muladd,all\"\n+(define_attr \"athlon_fpunits\" \"none,store,mul,add,muladd,any\"\n   (cond [(eq_attr \"type\" \"fop,fop1,fcmp\")\n \t   (const_string \"add\")\n-         (eq_attr \"type\" \"fmul,fdiv,fpspc,fsgn\")\n+         (eq_attr \"type\" \"fmul,fdiv,fpspc,fsgn,fcmov\")\n \t   (const_string \"mul\")\n-\t (and (eq_attr \"type\" \"fmov\") (eq_attr \"memory\" \"!none\"))\n+\t (and (eq_attr \"type\" \"fmov\") (eq_attr \"memory\" \"store,both\"))\n \t   (const_string \"store\")\n+\t (and (eq_attr \"type\" \"fmov\") (eq_attr \"memory\" \"load\"))\n+\t   (const_string \"any\")\n          (and (eq_attr \"type\" \"fmov\")\n               (ior (match_operand:SI 1 \"register_operand\" \"\")\n                    (match_operand 1 \"immediate_operand\" \"\")))\n \t   (const_string \"store\")\n          (eq_attr \"type\" \"fmov\")\n-\t   (const_string \"muladd\")\n-         (eq_attr \"type\" \"fcmov\")\n-\t   (const_string \"all\")]\n+\t   (const_string \"muladd\")]\n \t(const_string \"none\")))\n \n-(define_function_unit \"athlon_fp_mul\" 1 0\n+;; We use latencies 1 for definitions.  This is OK to model colisions\n+;; in execution units.  The real latencies are modeled in the \"fp\" pipeline.\n+\n+;; fsin, fcos: 96-192\n+;; fsincos: 107-211\n+;; fsqrt: 19 for SFmode, 27 for DFmode, 35 for XFmode.\n+(define_function_unit \"athlon_fp\" 3 0\n   (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"athlon_fpunits\" \"mul,all\"))\n-  4 1)\n+       (eq_attr \"type\" \"fpspc\"))\n+  100 1)\n \n-(define_function_unit \"athlon_fp_add\" 1 0\n+;; 16 cycles for SFmode, 20 for DFmode and 24 for XFmode.\n+(define_function_unit \"athlon_fp\" 3 0\n   (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"athlon_fpunits\" \"add,all\"))\n+       (eq_attr \"type\" \"fdiv\"))\n+  24 1)\n+\n+(define_function_unit \"athlon_fp\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"fop,fop1,fmul\"))\n   4 1)\n \n-(define_function_unit \"athlon_fp_muladd\" 2 0\n+;; XFmode loads are slow.\n+;; XFmode store is slow too (8 cycles), but we don't need to model it, because\n+;; there are no dependent instructions.\n+\n+(define_function_unit \"athlon_fp\" 3 0\n   (and (eq_attr \"cpu\" \"athlon\")\n        (and (eq_attr \"type\" \"fmov\")\n-            (eq_attr \"athlon_fpunits\" \"muladd,mul,add,all\")))\n+\t    (match_operand:XF 1 \"memory_operand\" \"\")))\n+  10 1)\n+\n+(define_function_unit \"athlon_fp\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"fmov,fsgn\"))\n   2 1)\n \n+;; fcmp and ftst instructions\n+(define_function_unit \"athlon_fp\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (and (eq_attr \"type\" \"fcmp\")\n+\t    (eq_attr \"athlon_decode\" \"direct\")))\n+  3 1)\n+\n+;; fcmpi instructions.\n+(define_function_unit \"athlon_fp\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (and (eq_attr \"type\" \"fcmp\")\n+\t    (eq_attr \"athlon_decode\" \"vector\")))\n+  3 1)\n+\n+(define_function_unit \"athlon_fp\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"fcmov\"))\n+  7 1)\n+\n+(define_function_unit \"athlon_fp_mul\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"athlon_fpunits\" \"mul\"))\n+  1 1)\n+\n+(define_function_unit \"athlon_fp_add\" 1 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"athlon_fpunits\" \"add\"))\n+  1 1)\n+\n (define_function_unit \"athlon_fp_muladd\" 2 0\n   (and (eq_attr \"cpu\" \"athlon\")\n-       (and (eq_attr \"type\" \"!fmov\")\n-            (eq_attr \"athlon_fpunits\" \"muladd,mul,add,all\")))\n-  4 1)\n+       (eq_attr \"athlon_fpunits\" \"muladd,mul,add\"))\n+  1 1)\n \n (define_function_unit \"athlon_fp_store\" 1 0\n   (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"athlon_fpunits\" \"store,all\"))\n+       (eq_attr \"athlon_fpunits\" \"store\"))\n   1 1)\n \n-(define_function_unit \"athlon_agu\" 3 0\n+;; We don't need to model the Adress Generation Unit, since we don't model\n+;; the re-order buffer yet and thus we never schedule more than three operations\n+;; at time.  Later we may want to experiment with MD_SCHED macros modeling the\n+;; decoders independently on the functional units.\n+\n+;(define_function_unit \"athlon_agu\" 3 0\n+;  (and (eq_attr \"cpu\" \"athlon\")\n+;       (and (eq_attr \"memory\" \"!none\")\n+;            (eq_attr \"athlon_fpunits\" \"none\")))\n+;  1 1)\n+\n+;; Model load unit to avoid too long sequences of loads.  We don't need to\n+;; model store queue, since it is hardly going to be bottleneck.\n+\n+(define_function_unit \"athlon_load\" 2 0\n   (and (eq_attr \"cpu\" \"athlon\")\n-       (and (eq_attr \"memory\" \"!none\")\n-            (eq_attr \"athlon_fpunits\" \"none\")))\n+       (eq_attr \"memory\" \"load,both\"))\n   1 1)\n \n \f\n@@ -1255,6 +1317,7 @@\n   \"\"\n   \"sahf\"\n   [(set_attr \"length\" \"1\")\n+   (set_attr \"athlon_decode\" \"vector\")\n    (set_attr \"ppro_uops\" \"one\")])\n \n ;; Pentium Pro can do steps 1 through 3 in one go.\n@@ -1390,6 +1453,7 @@\n   \"xchg{l}\\\\t%1, %0\"\n   [(set_attr \"type\" \"imov\")\n    (set_attr \"pent_pair\" \"np\")\n+   (set_attr \"athlon_decode\" \"vector\")\n    (set_attr \"ppro_uops\" \"few\")])\n \n (define_expand \"movhi\"\n@@ -1437,8 +1501,10 @@\n }\"\n   [(set (attr \"type\")\n      (cond [(and (eq_attr \"alternative\" \"0\")\n-\t\t (eq (symbol_ref \"TARGET_PARTIAL_REG_STALL\")\n-\t\t     (const_int 0)))\n+\t\t (ior (eq (symbol_ref \"TARGET_PARTIAL_REG_STALL\")\n+\t\t\t  (const_int 0))\n+\t\t      (eq (symbol_ref \"TARGET_HIMODE_MATH\")\n+\t\t\t  (const_int 0))))\n \t      (const_string \"imov\")\n \t    (and (eq_attr \"alternative\" \"1,2\")\n \t\t (match_operand:HI 1 \"aligned_operand\" \"\"))\n@@ -1456,8 +1522,10 @@\n \t\t  (match_operand:HI 1 \"aligned_operand\" \"\"))\n \t       (const_string \"0\")\n \t     (and (eq_attr \"alternative\" \"0\")\n-\t\t  (eq (symbol_ref \"TARGET_PARTIAL_REG_STALL\")\n-\t\t      (const_int 0)))\n+\t\t  (ior (eq (symbol_ref \"TARGET_PARTIAL_REG_STALL\")\n+\t\t\t   (const_int 0))\n+\t\t       (eq (symbol_ref \"TARGET_HIMODE_MATH\")\n+\t\t\t   (const_int 0))))\n \t       (const_string \"0\")\n \t    ]\n \t    (const_string \"1\")))\n@@ -1547,9 +1615,19 @@\n   [(set_attr \"type\" \"pop\")\n    (set_attr \"length_prefix\" \"1\")])\n \n+;; Situation is quite tricky about when to choose full sized (SImode) move\n+;; over QImode moves.  For Q_REG -> Q_REG move we use full size only for\n+;; partial register dependency machines (such as AMD Athlon), where QImode\n+;; moves issue extra dependency and for partial register stalls machines\n+;; that don't use QImode patterns (and QImode move cause stall on the next\n+;; instruction).\n+;;\n+;; For loads of Q_REG to NONQ_REG we use full sized moves except for partial\n+;; register stall machines with, where we use QImode instructions, since\n+;; partial register stall can be caused there.  Then we use movzx.\n (define_insn \"*movqi_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,q,r,?r,m\")\n-\t(match_operand:QI 1 \"general_operand\" \"qn,qm,rn,qm,qn\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,q ,q ,r,r ,?r,m\")\n+\t(match_operand:QI 1 \"general_operand\"      \" q,qn,qm,q,rn,qm,qn\"))]\n   \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n   \"*\n {\n@@ -1560,26 +1638,50 @@\n \tabort ();\n       return \\\"movz{bl|x}\\\\t{%1, %k0|%k0, %1}\\\";\n     default:\n-      if (which_alternative == 2)\n+      if (which_alternative == 4 || which_alternative == 3\n+\t  || (which_alternative == 1 && get_attr_length (insn) == 5)\n+\t  || (which_alternative == 0\n+\t      && ((TARGET_PARTIAL_REG_STALL && !TARGET_QIMODE_MATH)\n+\t\t  || TARGET_PARTIAL_REG_DEPENDENCY)))\n         return \\\"mov{l}\\\\t{%k1, %k0|%k0, %k1}\\\";\n       else\n         return \\\"mov{b}\\\\t{%1, %0|%0, %1}\\\";\n     }\n }\"\n   [(set (attr \"type\")\n-     (cond [(eq_attr \"alternative\" \"3\")\n+     (cond [(and (eq_attr \"alternative\" \"3\")\n+\t\t (ior (eq (symbol_ref \"TARGET_PARTIAL_REG_STALL\")\n+\t\t\t  (const_int 0))\n+\t\t      (eq (symbol_ref \"TARGET_QIMODE_MATH\")\n+\t\t\t  (const_int 0))))\n+\t      (const_string \"imov\")\n+\t    (eq_attr \"alternative\" \"3,5\")\n \t      (const_string \"imovx\")\n \t    (and (ne (symbol_ref \"TARGET_MOVX\")\n \t\t     (const_int 0))\n-\t\t (eq_attr \"alternative\" \"1\"))\n+\t\t (eq_attr \"alternative\" \"2\"))\n \t      (const_string \"imovx\")\n \t   ]\n \t   (const_string \"imov\")))\n     ; There's no place to override just the immediate length\n     (set (attr \"length\")\n       (cond [(and (eq_attr \"type\" \"imov\")\n-\t\t  (and (eq_attr \"alternative\" \"2\")\n-\t\t       (match_operand:HI 1 \"immediate_operand\" \"\")))\n+\t\t  (and (match_operand:HI 1 \"immediate_operand\" \"\")\n+\t\t       (eq_attr \"alternative\" \"4\")))\n+\t       (const_string \"5\")\n+\t     ;; Avoid extra dependency on partial register.\n+\t     (and (eq_attr \"type\" \"imov\")\n+\t\t  (and (eq_attr \"alternative\" \"1\")\n+\t\t       (ne (symbol_ref \"TARGET_PARTIAL_REG_DEPENDENCY\")\n+\t\t\t   (const_int 0))))\n+\t       (const_string \"5\")\n+\t     ;; Avoid partial register stalls when not using QImode arithmetic\n+\t     (and (eq_attr \"type\" \"imov\")\n+\t\t  (and (eq_attr \"alternative\" \"1\")\n+\t\t       (and (ne (symbol_ref \"TARGET_PARTIAL_REG_STALL\")\n+\t\t\t\t(const_int 0))\n+\t\t\t    (eq (symbol_ref \"TARGET_QIMODE_MATH\")\n+\t\t\t\t(const_int 0)))))\n \t       (const_string \"5\")\n \t    ]\n \t    (const_string \"*\")))])\n@@ -1904,10 +2006,38 @@\n ;; On the average, pushdf using integers can be still shorter.  Allow this\n ;; pattern for optimize_size too.\n \n-(define_insn \"*pushdf\"\n+(define_insn \"*pushdf_nointeger\"\n+  [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<\")\n+\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,Fo#f,*r#f\"))]\n+  \"!TARGET_INTEGER_DFMODE_MOVES\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      /* %%% We loose REG_DEAD notes for controling pops if we split late.  */\n+      operands[0] = gen_rtx_MEM (DFmode, stack_pointer_rtx);\n+      operands[2] = stack_pointer_rtx;\n+      operands[3] = GEN_INT (8);\n+      if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+\treturn \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fstp%z0\\\\t%y0\\\";\n+      else\n+\treturn \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fst%z0\\\\t%y0\\\";\n+\n+    case 1:\n+    case 2:\n+      return \\\"#\\\";\n+\n+    default:\n+      abort ();\n+    }\n+}\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"*pushdf_integer\"\n   [(set (match_operand:DF 0 \"push_operand\" \"=<,<\")\n \t(match_operand:DF 1 \"general_no_elim_operand\" \"f#r,rFo#f\"))]\n-  \"\"\n+  \"TARGET_INTEGER_DFMODE_MOVES\"\n   \"*\n {\n   switch (which_alternative)\n@@ -1955,7 +2085,7 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,m,f,*r,o\")\n \t(match_operand:DF 1 \"general_operand\" \"fm,f,G,*roF,F*r\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n-   && optimize_size\n+   && (optimize_size || !TARGET_INTEGER_DFMODE_MOVES)\n    && (reload_in_progress || reload_completed\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n        || memory_operand (operands[0], DFmode))\" \n@@ -2002,7 +2132,7 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#r,m,f#r,r#f,o\")\n \t(match_operand:DF 1 \"general_operand\" \"fm#r,f#r,G,roF#f,Fr#f\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n-   && !optimize_size\n+   && !optimize_size && TARGET_INTEGER_DFMODE_MOVES\n    && (reload_in_progress || reload_completed\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n        || memory_operand (operands[0], DFmode))\" \n@@ -2304,7 +2434,8 @@\n   else\n     return \\\"fxch\\\\t%0\\\";\n }\"\n-  [(set_attr \"type\" \"fxch\")])\n+  [(set_attr \"type\" \"fxch\")\n+   (set_attr \"athlon_decode\" \"vector\")])\n \f\n ;; Zero extension instructions\n \n@@ -3202,6 +3333,7 @@\n   \"TARGET_80387\"\n   \"fldcw\\\\t%0\"\n   [(set_attr \"length_opcode\" \"2\")\n+   (set_attr \"athlon_decode\" \"vector\")\n    (set_attr \"ppro_uops\" \"few\")])\n \f\n ;; Conversion between fixed point and floating point.\n@@ -7691,6 +7823,7 @@\n   \"\"\n   \"leave\"\n   [(set_attr \"length\" \"1\")\n+   (set_attr \"athlon_decode\" \"vector\")\n    (set_attr \"ppro_uops\" \"few\")])\n \f\n (define_expand \"ffssi2\"\n@@ -8123,47 +8256,53 @@\n \t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387\"\n   \"fsqrt\"\n-  [(set_attr \"type\" \"fpspc\")])\n+  [(set_attr \"type\" \"fpspc\")\n+   (set_attr \"athlon_decode\" \"direct\")])\n \n (define_insn \"sqrtdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(sqrt:DF (match_operand:DF 1 \"register_operand\" \"0\")))]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387\n    && (TARGET_IEEE_FP || flag_fast_math) \"\n   \"fsqrt\"\n-  [(set_attr \"type\" \"fpspc\")])\n+  [(set_attr \"type\" \"fpspc\")\n+   (set_attr \"athlon_decode\" \"direct\")])\n \n (define_insn \"*sqrtextendsfdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(sqrt:DF (float_extend:DF\n \t\t  (match_operand:SF 1 \"register_operand\" \"0\"))))]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387\"\n   \"fsqrt\"\n-  [(set_attr \"type\" \"fpspc\")])\n+  [(set_attr \"type\" \"fpspc\")\n+   (set_attr \"athlon_decode\" \"direct\")])\n \n (define_insn \"sqrtxf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(sqrt:XF (match_operand:XF 1 \"register_operand\" \"0\")))]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n    && (TARGET_IEEE_FP || flag_fast_math) \"\n   \"fsqrt\"\n-  [(set_attr \"type\" \"fpspc\")])\n+  [(set_attr \"type\" \"fpspc\")\n+   (set_attr \"athlon_decode\" \"direct\")])\n \n (define_insn \"*sqrtextenddfxf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(sqrt:XF (float_extend:XF\n \t\t  (match_operand:DF 1 \"register_operand\" \"0\"))))]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387\"\n   \"fsqrt\"\n-  [(set_attr \"type\" \"fpspc\")])\n+  [(set_attr \"type\" \"fpspc\")\n+   (set_attr \"athlon_decode\" \"direct\")])\n \n (define_insn \"*sqrtextendsfxf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(sqrt:XF (float_extend:XF\n \t\t  (match_operand:SF 1 \"register_operand\" \"0\"))))]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387\"\n   \"fsqrt\"\n-  [(set_attr \"type\" \"fpspc\")])\n+  [(set_attr \"type\" \"fpspc\")\n+   (set_attr \"athlon_decode\" \"direct\")])\n \n (define_insn \"sindf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")"}]}