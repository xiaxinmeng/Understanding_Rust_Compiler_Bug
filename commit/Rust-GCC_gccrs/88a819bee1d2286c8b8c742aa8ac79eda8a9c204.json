{"sha": "88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhhODE5YmVlMWQyMjg2YzhiOGM3NDJhYThhYzc5ZWRhOGE5YzIwNA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-10-31T14:39:44Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-10-31T14:39:44Z"}, "message": "[C++ PATCH] overloaded operator fns [2/N]\n\nhttps://gcc.gnu.org/ml/gcc-patches/2017-10/msg02326.html\n\tgcc/cp/\n\t* cp-tree.h (ovl_op_identifier): New.\n\t(assign_op_identifier, call_op_identifier): Adjust.\n\t(cp_operator_id, cp_assignment_operator_ide): Delete.\n\t(SET_OVERLOADED_OPERATOR_CODE): Delete.\n\t(OVL_OP_INFO): New.\n\t* call.c (op_error): Use OVL_OP_INFO.\n\t(build_conditional_expr_1): Use ovl_op_identifier.\n\t(build_new_op_1): Use OVL_OP_INFO & ovl_op_identifier.\n\t(build_op_delete_call): Likewise.\n\t* class.c (type_requires_array_cookie): Use ovl_op_identifier.\n\t* decl.c (duplicate_decls): Directly copy operator code.\n\t(builtin_function_1): Do not set operator code.\n\t(build_library_fn): Directly set operator code.\n\t(push_cp_library_fn): Use ovl_op_identifier.\n\t(grok_op_properties): Directly set operator code.\n\t* decl2.c (maybe_warn_sized_delete): Use ovl_op_identifier.\n\t* error.c (dump_expr): Use OVL_OP_INFO.\n\t(op_to_string): Add assop arg. Use OVL_OP_INFO.\n\t(assop_to_string): Delete.\n\t(args_to_string): Adjust.\n\t* init.c (build_new_1): Use ovl_op_identifier.\n\t* mangle.c (write_unqualified_name): Use OVL_OP_INFO.\n\t(write_expression): Likewise.\n\t* method.c (synthesized_method_walk): Use ovl_op_identifier.\n\t(implicitly_declare_fn): Use assign_op_identifier. Directly set\n\toperator code.\n\t* name-lookup.c (get_class_binding): Use assign_op_identifier.\n\t* parser.c (cp_parser_operator): Use ovl_op_identifier.\n\t(cp_parser_omp_clause_reduction): Likewise.\n\t* semantics.c (omp_reduction_id): Likewise.\n\t* typeck.c (cxx_sizeof_or_alignof_type): Use OVL_OP_INFO.\n\n\tlibcc1/\n\t* libcp1plugin.cc (plugin_build_decl): Use ovl_op_identifier.\n\tDirectly set operator code.\n\t(plugin_build_dependent_expr): Use ovl_op_identifier.\n\nFrom-SVN: r254267", "tree": {"sha": "dc1df4321c6847d88a2b11efff77e2d138f03f45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc1df4321c6847d88a2b11efff77e2d138f03f45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f6a35e8954606007940045101284fbd7c251ed76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6a35e8954606007940045101284fbd7c251ed76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6a35e8954606007940045101284fbd7c251ed76"}], "stats": {"total": 233, "additions": 114, "deletions": 119}, "files": [{"sha": "cca3a4b9fc5e35bc3b7517f5952e9d65d35a3169", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -1,5 +1,37 @@\n 2017-10-31  Nathan Sidwell  <nathan@acm.org>\n \n+\t* cp-tree.h (ovl_op_identifier): New.\n+\t(assign_op_identifier, call_op_identifier): Adjust.\n+\t(cp_operator_id, cp_assignment_operator_ide): Delete.\n+\t(SET_OVERLOADED_OPERATOR_CODE): Delete.\n+\t(OVL_OP_INFO): New.\n+\t* call.c (op_error): Use OVL_OP_INFO.\n+\t(build_conditional_expr_1): Use ovl_op_identifier.\n+\t(build_new_op_1): Use OVL_OP_INFO & ovl_op_identifier.\n+\t(build_op_delete_call): Likewise.\n+\t* class.c (type_requires_array_cookie): Use ovl_op_identifier.\n+\t* decl.c (duplicate_decls): Directly copy operator code.\n+\t(builtin_function_1): Do not set operator code.\n+\t(build_library_fn): Directly set operator code.\n+\t(push_cp_library_fn): Use ovl_op_identifier.\n+\t(grok_op_properties): Directly set operator code.\n+\t* decl2.c (maybe_warn_sized_delete): Use ovl_op_identifier.\n+\t* error.c (dump_expr): Use OVL_OP_INFO.\n+\t(op_to_string): Add assop arg. Use OVL_OP_INFO.\n+\t(assop_to_string): Delete.\n+\t(args_to_string): Adjust.\n+\t* init.c (build_new_1): Use ovl_op_identifier.\n+\t* mangle.c (write_unqualified_name): Use OVL_OP_INFO.\n+\t(write_expression): Likewise.\n+\t* method.c (synthesized_method_walk): Use ovl_op_identifier.\n+\t(implicitly_declare_fn): Use assign_op_identifier. Directly set\n+\toperator code.\n+\t* name-lookup.c (get_class_binding): Use assign_op_identifier.\n+\t* parser.c (cp_parser_operator): Use ovl_op_identifier.\n+\t(cp_parser_omp_clause_reduction): Likewise.\n+\t* semantics.c (omp_reduction_id): Likewise.\n+\t* typeck.c (cxx_sizeof_or_alignof_type): Use OVL_OP_INFO.\n+\n \t* cp-tree.h (assign_op_identifier, call_op_identifier): Define.\n \t(LAMBDA_FUNCTION_P): Use DECL_OVERLOADED_OPERATOR_IS.\n \t(DECL_OVERLOADED_OPERATOR_P): Just retuurn true/false."}, {"sha": "6875492e68708877a797406fd6d7972a4c45244b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -4620,12 +4620,8 @@ static void\n op_error (location_t loc, enum tree_code code, enum tree_code code2,\n \t  tree arg1, tree arg2, tree arg3, bool match)\n {\n-  const char *opname;\n-\n-  if (code == MODIFY_EXPR)\n-    opname = assignment_operator_name_info[code2].name;\n-  else\n-    opname = operator_name_info[code].name;\n+  bool assop = code == MODIFY_EXPR;\n+  const char *opname = OVL_OP_INFO (assop, assop ? code2 : code)->name;\n \n   switch (code)\n     {\n@@ -5184,7 +5180,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n       add_builtin_candidates (&candidates,\n \t\t\t      COND_EXPR,\n \t\t\t      NOP_EXPR,\n-\t\t\t      cp_operator_id (COND_EXPR),\n+\t\t\t      ovl_op_identifier (false, COND_EXPR),\n \t\t\t      args,\n \t\t\t      LOOKUP_NORMAL, complain);\n \n@@ -5574,7 +5570,6 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n {\n   struct z_candidate *candidates = 0, *cand;\n   vec<tree, va_gc> *arglist;\n-  tree fnname;\n   tree args[3];\n   tree result = NULL_TREE;\n   bool result_valid_p = false;\n@@ -5591,14 +5586,13 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n       || error_operand_p (arg3))\n     return error_mark_node;\n \n-  if (code == MODIFY_EXPR)\n+  bool ismodop = code == MODIFY_EXPR;\n+  if (ismodop)\n     {\n       code2 = TREE_CODE (arg3);\n       arg3 = NULL_TREE;\n-      fnname = cp_assignment_operator_id (code2);\n     }\n-  else\n-    fnname = cp_operator_id (code);\n+  tree fnname = ovl_op_identifier (ismodop, ismodop ? code2 : code);\n \n   arg1 = prep_operand (arg1);\n \n@@ -5793,7 +5787,7 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n \t\t? G_(\"no %<%D(int)%> declared for postfix %qs,\"\n \t\t     \" trying prefix operator instead\")\n \t\t: G_(\"no %<%D(int)%> declared for postfix %qs\");\n-\t      permerror (loc, msg, fnname, operator_name_info[code].name);\n+\t      permerror (loc, msg, fnname, OVL_OP_INFO (false, code)->name);\n \t    }\n \n \t  if (!flag_permissive)\n@@ -6205,7 +6199,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \n   type = strip_array_types (TREE_TYPE (TREE_TYPE (addr)));\n \n-  fnname = cp_operator_id (code);\n+  fnname = ovl_op_identifier (false, code);\n \n   if (CLASS_TYPE_P (type)\n       && COMPLETE_TYPE_P (complete_type (type))\n@@ -6434,7 +6428,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \n   if (complain & tf_error)\n     error (\"no suitable %<operator %s%> for %qT\",\n-\t   operator_name_info[(int)code].name, type);\n+\t   OVL_OP_INFO (false, code)->name, type);\n   return error_mark_node;\n }\n "}, {"sha": "9755f18cc4c94b786710afdfa9f1e91246bfba8d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -5304,7 +5304,7 @@ type_requires_array_cookie (tree type)\n      the array to the deallocation function, so we will need to store\n      a cookie.  */\n   fns = lookup_fnfields (TYPE_BINFO (type),\n-\t\t\t cp_operator_id (VEC_DELETE_EXPR),\n+\t\t\t ovl_op_identifier (false, VEC_DELETE_EXPR),\n \t\t\t /*protect=*/0);\n   /* If there are no `operator []' members, or the lookup is\n      ambiguous, then we don't need a cookie.  */"}, {"sha": "a9b2304d10f3ee92840306f156e00d2c072397da", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -245,24 +245,14 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n    then deletes the entire object.  */\n #define deleting_dtor_identifier\tcp_global_trees[CPTI_DELETING_DTOR_IDENTIFIER]\n \n-#define assign_op_identifier (cp_assignment_operator_id (NOP_EXPR))\n-#define call_op_identifier (cp_operator_id (CALL_EXPR))\n+#define ovl_op_identifier(ISASS, CODE)  (OVL_OP_INFO(ISASS, CODE)->identifier)\n+#define assign_op_identifier (ovl_op_identifier (true, NOP_EXPR))\n+#define call_op_identifier (ovl_op_identifier (false, CALL_EXPR))\n /* The name used for conversion operators -- but note that actual\n    conversion functions use special identifiers outside the identifier\n    table.  */\n #define conv_op_identifier\t\tcp_global_trees[CPTI_CONV_OP_IDENTIFIER]\n \n-/* The name of the identifier used internally to represent operator CODE.  */\n-#define cp_operator_id(CODE) \\\n-  (operator_name_info[(int) (CODE)].identifier)\n-\n-/* The name of the identifier used to represent assignment operator CODE,\n-   both simple (i.e., operator= with CODE == NOP_EXPR) and compound (e.g.,\n-   operator+= with CODE == PLUS_EXPR).  Includes copy and move assignment.\n-   Use copy_fn_p() to test specifically for copy assignment.  */\n-#define cp_assignment_operator_id(CODE)\t\t\t\t\\\n-  (assignment_operator_name_info[(int) (CODE)].identifier)\n-\n #define delta_identifier\t\tcp_global_trees[CPTI_DELTA_IDENTIFIER]\n #define in_charge_identifier\t\tcp_global_trees[CPTI_IN_CHARGE_IDENTIFIER]\n /* The name of the parameter that contains a pointer to the VTT to use\n@@ -2810,10 +2800,6 @@ struct GTY(()) lang_decl {\n #define SET_VAR_HAD_UNKNOWN_BOUND(NODE) \\\n   (DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))->u.base.unknown_bound_p = true)\n \n-/* Set the overloaded operator code for NODE to CODE.  */\n-#define SET_OVERLOADED_OPERATOR_CODE(NODE, CODE) \\\n-  (LANG_DECL_FN_CHECK (NODE)->operator_code = (CODE))\n-\n /* True iff decl NODE is for an overloaded operator.  */\n #define DECL_OVERLOADED_OPERATOR_P(NODE)\t\t\\\n   IDENTIFIER_ANY_OP_P (DECL_NAME (NODE))\n@@ -5506,6 +5492,12 @@ extern GTY(()) operator_name_info_t operator_name_info\n extern GTY(()) operator_name_info_t assignment_operator_name_info\n   [(int) MAX_TREE_CODES];\n \n+/* Given an ass_op_p boolean and a tree code, return a pointer to its\n+   overloaded operator info.  */\n+#define OVL_OP_INFO(IS_ASS_P, TREE_CODE)\t\t\t\\\n+  (((IS_ASS_P) ? assignment_operator_name_info : operator_name_info)\t\\\n+   + (TREE_CODE))\n+\n /* A type-qualifier, or bitmask therefore, using the TYPE_QUAL\n    constants.  */\n "}, {"sha": "82d9326ac5b451c9e94dd73b489a61df20f5938a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -1922,8 +1922,8 @@ next_arg:;\n       DECL_OVERRIDE_P (newdecl) |= DECL_OVERRIDE_P (olddecl);\n       DECL_THIS_STATIC (newdecl) |= DECL_THIS_STATIC (olddecl);\n       if (DECL_OVERLOADED_OPERATOR_P (olddecl))\n-\tSET_OVERLOADED_OPERATOR_CODE\n-\t  (newdecl, DECL_OVERLOADED_OPERATOR_CODE (olddecl));\n+\tDECL_OVERLOADED_OPERATOR_CODE (newdecl)\n+\t  = DECL_OVERLOADED_OPERATOR_CODE (olddecl);\n       new_defines_function = DECL_INITIAL (newdecl) != NULL_TREE;\n \n       /* Optionally warn about more than one declaration for the same\n@@ -4359,7 +4359,6 @@ builtin_function_1 (tree decl, tree context, bool is_global)\n   retrofit_lang_decl (decl);\n \n   DECL_ARTIFICIAL (decl) = 1;\n-  SET_OVERLOADED_OPERATOR_CODE (decl, ERROR_MARK);\n   SET_DECL_LANGUAGE (decl, lang_c);\n   /* Runtime library routines are, by definition, available in an\n      external shared object.  */\n@@ -4447,7 +4446,7 @@ build_library_fn (tree name, enum tree_code operator_code, tree type,\n   DECL_EXTERNAL (fn) = 1;\n   TREE_PUBLIC (fn) = 1;\n   DECL_ARTIFICIAL (fn) = 1;\n-  SET_OVERLOADED_OPERATOR_CODE (fn, operator_code);\n+  DECL_OVERLOADED_OPERATOR_CODE (fn) = operator_code;\n   SET_DECL_LANGUAGE (fn, lang_c);\n   /* Runtime library routines are, by definition, available in an\n      external shared object.  */\n@@ -4512,9 +4511,8 @@ static tree\n push_cp_library_fn (enum tree_code operator_code, tree type,\n \t\t    int ecf_flags)\n {\n-  tree fn = build_cp_library_fn (cp_operator_id (operator_code),\n-\t\t\t\t operator_code,\n-\t\t\t\t type, ecf_flags);\n+  tree fn = build_cp_library_fn (ovl_op_identifier (false, operator_code),\n+\t\t\t\t operator_code, type, ecf_flags);\n   pushdecl (fn);\n   if (flag_tm)\n     apply_tm_attr (fn, get_identifier (\"transaction_safe\"));\n@@ -12938,7 +12936,7 @@ grok_op_properties (tree decl, bool complain)\n       }\n     while (0);\n   gcc_assert (operator_code != MAX_TREE_CODES);\n-  SET_OVERLOADED_OPERATOR_CODE (decl, operator_code);\n+  DECL_OVERLOADED_OPERATOR_CODE (decl) = operator_code;\n \n   if (operator_code == NEW_EXPR || operator_code == VEC_NEW_EXPR\n       || operator_code == DELETE_EXPR || operator_code == VEC_DELETE_EXPR)\n@@ -13111,7 +13109,7 @@ grok_op_properties (tree decl, bool complain)\n \t      gcc_unreachable ();\n \t    }\n \n-\t  SET_OVERLOADED_OPERATOR_CODE (decl, operator_code);\n+\t  DECL_OVERLOADED_OPERATOR_CODE (decl) = operator_code;\n \n \t  if ((operator_code == POSTINCREMENT_EXPR\n \t       || operator_code == POSTDECREMENT_EXPR)"}, {"sha": "a23b96c53e734cd4661a83a7f5626ff51bca0e34", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -4455,7 +4455,7 @@ maybe_warn_sized_delete (enum tree_code code)\n   tree sized = NULL_TREE;\n   tree unsized = NULL_TREE;\n \n-  for (ovl_iterator iter (get_global_binding (cp_operator_id (code)));\n+  for (ovl_iterator iter (get_global_binding (ovl_op_identifier (false, code)));\n        iter; ++iter)\n     {\n       tree fn = *iter;"}, {"sha": "2537713b5c9b748a2ca42481d3218106ce7cbe81", "filename": "gcc/cp/error.c", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -50,13 +50,12 @@ static cxx_pretty_printer * const cxx_pp = &actual_pretty_printer;\n # define NEXT_CODE(T) (TREE_CODE (TREE_TYPE (T)))\n \n static const char *args_to_string (tree, int);\n-static const char *assop_to_string (enum tree_code);\n static const char *code_to_string (enum tree_code);\n static const char *cv_to_string (tree, int);\n static const char *decl_to_string (tree, int);\n static const char *expr_to_string (tree);\n static const char *fndecl_to_string (tree, int);\n-static const char *op_to_string\t(enum tree_code);\n+static const char *op_to_string\t(bool, enum tree_code);\n static const char *parm_to_string (int);\n static const char *type_to_string (tree, int);\n \n@@ -2230,8 +2229,7 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n \n     case INIT_EXPR:\n     case MODIFY_EXPR:\n-      dump_binary_op (pp, assignment_operator_name_info[NOP_EXPR].name,\n-\t\t      t, flags);\n+      dump_binary_op (pp, OVL_OP_INFO (true, NOP_EXPR)->name, t, flags);\n       break;\n \n     case PLUS_EXPR:\n@@ -2255,7 +2253,7 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n     case EQ_EXPR:\n     case NE_EXPR:\n     case EXACT_DIV_EXPR:\n-      dump_binary_op (pp, operator_name_info[TREE_CODE (t)].name, t, flags);\n+      dump_binary_op (pp, OVL_OP_INFO (false, TREE_CODE (t))->name, t, flags);\n       break;\n \n     case CEIL_DIV_EXPR:\n@@ -2386,14 +2384,14 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n     case TRUTH_NOT_EXPR:\n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n-      dump_unary_op (pp, operator_name_info [TREE_CODE (t)].name, t, flags);\n+      dump_unary_op (pp, OVL_OP_INFO (false, TREE_CODE (t))->name, t, flags);\n       break;\n \n     case POSTDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n       pp_cxx_left_paren (pp);\n       dump_expr (pp, TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_ws_string (pp, operator_name_info[TREE_CODE (t)].name);\n+      pp_cxx_ws_string (pp, OVL_OP_INFO (false, TREE_CODE (t))->name);\n       pp_cxx_right_paren (pp);\n       break;\n \n@@ -2656,7 +2654,7 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      pp_cxx_ws_string (pp, operator_name_info[TREE_CODE (t)].name);\n+      pp_cxx_ws_string (pp, OVL_OP_INFO (false, TREE_CODE (t))->name);\n       pp_cxx_whitespace (pp);\n       dump_expr (pp, TREE_OPERAND (t, 0), flags);\n       break;\n@@ -3136,9 +3134,9 @@ parm_to_string (int p)\n }\n \n static const char *\n-op_to_string (enum tree_code p)\n+op_to_string (bool assop, enum tree_code p)\n {\n-  tree id = operator_name_info[p].identifier;\n+  tree id = ovl_op_identifier (assop, p);\n   return id ? IDENTIFIER_POINTER (id) : M_(\"<unknown>\");\n }\n \n@@ -3179,13 +3177,6 @@ type_to_string (tree typ, int verbose)\n   return pp_ggc_formatted_text (cxx_pp);\n }\n \n-static const char *\n-assop_to_string (enum tree_code p)\n-{\n-  tree id = assignment_operator_name_info[(int) p].identifier;\n-  return id ? IDENTIFIER_POINTER (id) : M_(\"{unknown}\");\n-}\n-\n static const char *\n args_to_string (tree p, int verbose)\n {\n@@ -4044,9 +4035,9 @@ cp_printer (pretty_printer *pp, text_info *text, const char *spec,\n     case 'E': result = expr_to_string (next_tree);\t\tbreak;\n     case 'F': result = fndecl_to_string (next_tree, verbose);\tbreak;\n     case 'L': result = language_to_string (next_lang);\t\tbreak;\n-    case 'O': result = op_to_string (next_tcode);\t\tbreak;\n+    case 'O': result = op_to_string (false, next_tcode);\tbreak;\n     case 'P': result = parm_to_string (next_int);\t\tbreak;\n-    case 'Q': result = assop_to_string (next_tcode);\t\tbreak;\n+    case 'Q': result = op_to_string (true, next_tcode);\t\tbreak;\n     case 'S': result = subst_to_string (next_tree);\t\tbreak;\n     case 'T': result = type_to_string (next_tree, verbose);\tbreak;\n     case 'V': result = cv_to_string (next_tree, verbose);\tbreak;"}, {"sha": "9e6e3aff779158ffd9e86b90aa0398e2bc5194fa", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -3055,7 +3055,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n   tree fnname;\n   tree fns;\n \n-  fnname = cp_operator_id (array_p ? VEC_NEW_EXPR : NEW_EXPR);\n+  fnname = ovl_op_identifier (false, array_p ? VEC_NEW_EXPR : NEW_EXPR);\n \n   member_new_p = !globally_qualified_p\n \t\t && CLASS_TYPE_P (elt_type)"}, {"sha": "fe0aeaca2e3fb8333518517a701d60e18e39b833", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -1345,13 +1345,10 @@ write_unqualified_name (tree decl)\n \t}\n       else if (DECL_OVERLOADED_OPERATOR_P (decl))\n \t{\n-\t  operator_name_info_t *oni;\n-\t  if (DECL_ASSIGNMENT_OPERATOR_P (decl))\n-\t    oni = assignment_operator_name_info;\n-\t  else\n-\t    oni = operator_name_info;\n-\n-\t  write_string (oni[DECL_OVERLOADED_OPERATOR_CODE (decl)].mangled_name);\n+\t  const char *mangled_name\n+\t    = (OVL_OP_INFO (DECL_ASSIGNMENT_OPERATOR_P (decl),\n+\t       DECL_OVERLOADED_OPERATOR_CODE (decl))->mangled_name);\n+\t  write_string (mangled_name);\n \t}\n       else if (UDLIT_OPER_P (DECL_NAME (decl)))\n \twrite_literal_operator_name (DECL_NAME (decl));\n@@ -3064,8 +3061,8 @@ write_expression (tree expr)\n   else if (TREE_CODE (expr) == MODOP_EXPR)\n     {\n       enum tree_code subop = TREE_CODE (TREE_OPERAND (expr, 1));\n-      const char *name = (assignment_operator_name_info[(int) subop]\n-\t\t\t  .mangled_name);\n+      const char *name = OVL_OP_INFO (true, subop)->mangled_name;\n+\n       write_string (name);\n       write_expression (TREE_OPERAND (expr, 0));\n       write_expression (TREE_OPERAND (expr, 2));\n@@ -3090,7 +3087,7 @@ write_expression (tree expr)\n       if (NEW_EXPR_USE_GLOBAL (expr))\n \twrite_string (\"gs\");\n \n-      write_string (operator_name_info[(int) code].mangled_name);\n+      write_string (OVL_OP_INFO (false, code)->mangled_name);\n \n       for (t = placement; t; t = TREE_CHAIN (t))\n \twrite_expression (TREE_VALUE (t));\n@@ -3130,7 +3127,7 @@ write_expression (tree expr)\n       if (DELETE_EXPR_USE_GLOBAL (expr))\n \twrite_string (\"gs\");\n \n-      write_string (operator_name_info[(int) code].mangled_name);\n+      write_string (OVL_OP_INFO (false, code)->mangled_name);\n \n       write_expression (TREE_OPERAND (expr, 0));\n     }\n@@ -3195,7 +3192,7 @@ write_expression (tree expr)\n \n \t  if (TREE_CODE (ob) == ARROW_EXPR)\n \t    {\n-\t      write_string (operator_name_info[(int)code].mangled_name);\n+\t      write_string (OVL_OP_INFO (false, code)->mangled_name);\n \t      ob = TREE_OPERAND (ob, 0);\n \t      write_expression (ob);\n \t    }\n@@ -3212,7 +3209,7 @@ write_expression (tree expr)\n \t}\n \n       /* If it wasn't any of those, recursively expand the expression.  */\n-      name = operator_name_info[(int) code].mangled_name;\n+      name = OVL_OP_INFO (false, code)->mangled_name;\n \n       /* We used to mangle const_cast and static_cast like a C cast.  */\n       if (code == CONST_CAST_EXPR\n@@ -3221,7 +3218,7 @@ write_expression (tree expr)\n \t  if (abi_warn_or_compat_version_crosses (6))\n \t    G.need_abi_warning = 1;\n \t  if (!abi_version_at_least (6))\n-\t    name = operator_name_info[CAST_EXPR].mangled_name;\n+\t    name = OVL_OP_INFO (false, CAST_EXPR)->mangled_name;\n \t}\n \n       if (name == NULL)\n@@ -3322,7 +3319,7 @@ write_expression (tree expr)\n \t\t  if (i == 0)\n \t\t    {\n \t\t      int fcode = TREE_INT_CST_LOW (operand);\n-\t\t      write_string (operator_name_info[fcode].mangled_name);\n+\t\t      write_string (OVL_OP_INFO (false, fcode)->mangled_name);\n \t\t      continue;\n \t\t    }\n \t\t  else if (code == BINARY_LEFT_FOLD_EXPR)"}, {"sha": "034431d20850bc898032a629db2d8d10b8314fd6", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -1703,12 +1703,12 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t{\n \t  /* Unlike for base ctor/op=/dtor, for operator delete it's fine\n \t     to have a null fn (no class-specific op delete).  */\n-\t  fn = locate_fn_flags (ctype, cp_operator_id (DELETE_EXPR),\n+\t  fn = locate_fn_flags (ctype, ovl_op_identifier (false, DELETE_EXPR),\n \t\t\t\tptr_type_node, flags, tf_none);\n \t  if (fn && fn == error_mark_node)\n \t    {\n \t      if (complain & tf_error)\n-\t\tlocate_fn_flags (ctype, cp_operator_id (DELETE_EXPR),\n+\t\tlocate_fn_flags (ctype, ovl_op_identifier (false, DELETE_EXPR),\n \t\t\t\t ptr_type_node, flags, complain);\n \t      if (deleted_p)\n \t\t*deleted_p = true;\n@@ -2008,7 +2008,7 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n \t  || kind == sfk_move_assignment)\n \t{\n \t  return_type = build_reference_type (type);\n-\t  name = cp_assignment_operator_id (NOP_EXPR);\n+\t  name = assign_op_identifier;\n \t}\n       else\n \tname = ctor_identifier;\n@@ -2078,7 +2078,7 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n \n   if (!IDENTIFIER_CDTOR_P (name))\n     /* Assignment operator.  */\n-    SET_OVERLOADED_OPERATOR_CODE (fn, NOP_EXPR);\n+    DECL_OVERLOADED_OPERATOR_CODE (fn) = NOP_EXPR;\n   else if (IDENTIFIER_CTOR_P (name))\n     DECL_CXX_CONSTRUCTOR_P (fn) = true;\n   else"}, {"sha": "1b35390cd9efc3252c0a2402eee5a06402f689f6", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -1299,7 +1299,7 @@ get_class_binding (tree klass, tree name, int type_or_fns)\n \t  if (CLASSTYPE_LAZY_DESTRUCTOR (klass))\n \t    lazily_declare_fn (sfk_destructor, klass);\n \t}\n-      else if (name == cp_assignment_operator_id (NOP_EXPR))\n+      else if (name == assign_op_identifier)\n \t{\n \t  if (CLASSTYPE_LAZY_COPY_ASSIGN (klass))\n \t    lazily_declare_fn (sfk_copy_assignment, klass);"}, {"sha": "bcaefdec2ad0f105c5284453b1812a5408ec2096", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -15006,7 +15006,7 @@ cp_parser_operator (cp_parser* parser)\n      operator token.  */\n   if (op != ERROR_MARK)\n     {\n-      id = assop ? cp_assignment_operator_id (op) : cp_operator_id (op);\n+      id = ovl_op_identifier (assop, op);\n       if (!consumed)\n \tcp_lexer_consume_token (parser->lexer);\n     }\n@@ -32588,21 +32588,21 @@ cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n \t    code = MIN_EXPR;\n \t  else if (strcmp (p, \"max\") == 0)\n \t    code = MAX_EXPR;\n-\t  else if (id == cp_operator_id (PLUS_EXPR))\n+\t  else if (id == ovl_op_identifier (false, PLUS_EXPR))\n \t    code = PLUS_EXPR;\n-\t  else if (id == cp_operator_id (MULT_EXPR))\n+\t  else if (id == ovl_op_identifier (false, MULT_EXPR))\n \t    code = MULT_EXPR;\n-\t  else if (id == cp_operator_id (MINUS_EXPR))\n+\t  else if (id == ovl_op_identifier (false, MINUS_EXPR))\n \t    code = MINUS_EXPR;\n-\t  else if (id == cp_operator_id (BIT_AND_EXPR))\n+\t  else if (id == ovl_op_identifier (false, BIT_AND_EXPR))\n \t    code = BIT_AND_EXPR;\n-\t  else if (id == cp_operator_id (BIT_IOR_EXPR))\n+\t  else if (id == ovl_op_identifier (false, BIT_IOR_EXPR))\n \t    code = BIT_IOR_EXPR;\n-\t  else if (id == cp_operator_id (BIT_XOR_EXPR))\n+\t  else if (id == ovl_op_identifier (false, BIT_XOR_EXPR))\n \t    code = BIT_XOR_EXPR;\n-\t  else if (id == cp_operator_id (TRUTH_ANDIF_EXPR))\n+\t  else if (id == ovl_op_identifier (false, TRUTH_ANDIF_EXPR))\n \t    code = TRUTH_ANDIF_EXPR;\n-\t  else if (id == cp_operator_id (TRUTH_ORIF_EXPR))\n+\t  else if (id == ovl_op_identifier (false, TRUTH_ORIF_EXPR))\n \t    code = TRUTH_ORIF_EXPR;\n \t  id = omp_reduction_id (code, id, NULL_TREE);\n \t  tree scope = parser->scope;"}, {"sha": "b513c4df575c41bf2c410a8e6428ad2c1bab4414", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -5099,7 +5099,7 @@ omp_reduction_id (enum tree_code reduction_code, tree reduction_id, tree type)\n     case BIT_IOR_EXPR:\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n-      reduction_id = cp_operator_id (reduction_code);\n+      reduction_id = ovl_op_identifier (false, reduction_code);\n       break;\n     case MIN_EXPR:\n       p = \"min\";"}, {"sha": "38fd1583dc98f5ae821b4909e414646a7a63e30d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -1562,7 +1562,7 @@ cxx_sizeof_or_alignof_type (tree type, enum tree_code op, bool complain)\n       if (complain)\n \tpedwarn (input_location, OPT_Wpointer_arith, \n \t\t \"invalid application of %qs to a member function\", \n-\t\t operator_name_info[(int) op].name);\n+\t\t OVL_OP_INFO (false, op)->name);\n       else\n \treturn error_mark_node;\n       value = size_one_node;"}, {"sha": "70998bcddacc5411cb4a1856873fcc6187fecf32", "filename": "libcc1/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/libcc1%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/libcc1%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FChangeLog?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -1,3 +1,9 @@\n+2017-10-31  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* libcp1plugin.cc (plugin_build_decl): Use ovl_op_identifier.\n+\tDirectly set operator code.\n+\t(plugin_build_dependent_expr): Use ovl_op_identifier.\n+\n 2017-10-04  Nathan Sidwell  <nathan@acm.org>\n \n \t* libcp1plugin.cc (supplement_binding): Don't use"}, {"sha": "d83521ec176e6f06fa1f446aa68e8fb2427eb37c", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a819bee1d2286c8b8c742aa8ac79eda8a9c204/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=88a819bee1d2286c8b8c742aa8ac79eda8a9c204", "patch": "@@ -1346,12 +1346,7 @@ plugin_build_decl (cc1_plugin::connection *self,\n \t    }\n \n \t  if (opcode != ERROR_MARK)\n-\t    {\n-\t      if (assop)\n-\t\tidentifier = cp_assignment_operator_id (opcode);\n-\t      else\n-\t\tidentifier = cp_operator_id (opcode);\n-\t    }\n+\t    identifier = ovl_op_identifier (assop, opcode);\n \t}\n       decl = build_lang_decl_loc (loc, code, identifier, sym_type);\n       /* FIXME: current_lang_name is lang_name_c while compiling an\n@@ -1410,19 +1405,14 @@ plugin_build_decl (cc1_plugin::connection *self,\n \t  DECL_DECLARED_INLINE_P (decl) = 1;\n \t  DECL_INITIAL (decl) = error_mark_node;\n \t}\n-      if (ctor || dtor)\n-\t{\n-\t  if (ctor)\n-\t    DECL_CXX_CONSTRUCTOR_P (decl) = 1;\n-\t  if (dtor)\n-\t    DECL_CXX_DESTRUCTOR_P (decl) = 1;\n-\t}\n-      else\n-\t{\n-\t  if ((sym_flags & GCC_CP_FLAG_SPECIAL_FUNCTION)\n-\t      && opcode != ERROR_MARK)\n-\t    SET_OVERLOADED_OPERATOR_CODE (decl, opcode);\n-\t}\n+\n+      if (ctor)\n+\tDECL_CXX_CONSTRUCTOR_P (decl) = 1;\n+      else if (dtor)\n+\tDECL_CXX_DESTRUCTOR_P (decl) = 1;\n+      else if ((sym_flags & GCC_CP_FLAG_SPECIAL_FUNCTION)\n+\t       && opcode != ERROR_MARK)\n+\tDECL_OVERLOADED_OPERATOR_CODE (decl) = opcode;\n     }\n   else if (RECORD_OR_UNION_CODE_P (code))\n     {\n@@ -2649,12 +2639,7 @@ plugin_build_dependent_expr (cc1_plugin::connection *self,\n       gcc_assert (convop || !conv_type);\n \n       if (opcode != ERROR_MARK)\n-\t{\n-\t  if (assop)\n-\t    identifier = cp_assignment_operator_id (opcode);\n-\t  else\n-\t    identifier = cp_operator_id (opcode);\n-\t}\n+\tidentifier = ovl_op_identifier (assop, opcode);\n \n       gcc_assert (identifier);\n     }"}]}