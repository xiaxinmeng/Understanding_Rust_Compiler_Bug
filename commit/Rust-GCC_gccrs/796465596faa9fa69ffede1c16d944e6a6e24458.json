{"sha": "796465596faa9fa69ffede1c16d944e6a6e24458", "node_id": "C_kwDOANBUbNoAKDc5NjQ2NTU5NmZhYTlmYTY5ZmZlZGUxYzE2ZDk0NGU2YTZlMjQ0NTg", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-20T14:34:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-20T14:34:37Z"}, "message": "Merge #950\n\n950: Match macro repetitions r=CohenArthur a=CohenArthur\n\nThis PR adds support for matching macro invocations and counting the amount of times they've been matched\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "16b2a74efab22fedab1448a7b6872c452072c19a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16b2a74efab22fedab1448a7b6872c452072c19a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/796465596faa9fa69ffede1c16d944e6a6e24458", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiElF9CRBK7hj4Ov3rIwAAW5QIALNYzXtcwrg8fFmdgUN+hOZB\nITRDeMXEcxW9OMpoa+sNyEMvmAxz4c2JYRxecAeh1pdSxo6pjiZIkzUHrn3wf/e9\nctxzj3xVaTaBVIaRpeZs18vuAw8Fmf4KZwXPp2/oOayUXcRkR2K5g9G2hlOuzajz\nIuWqNe82OOlcHKI8rGRaQQo7e4m6gtp9njIvwFUc7q7BhZlCsyBxliL3ErWUmzRV\nlab93U+dAZhwMBVRfd/thYqULF+fqJs+qbq+32Ag9hKivpSYKFjRl4M8y8+KbtX+\nKRc30VXTaf26zzxYZWaZI53M7GMLnTvzueoN/ldQzBaIwcqSWnhTHnLmiIGiFb4=\n=bxKC\n-----END PGP SIGNATURE-----\n", "payload": "tree 16b2a74efab22fedab1448a7b6872c452072c19a\nparent 4e096b1f14671270fb0c7b449d92b3e558bb769d\nparent d0d4dcfdb438af7c5f15afeba2ca77ecbe2be013\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1645367677 +0000\ncommitter GitHub <noreply@github.com> 1645367677 +0000\n\nMerge #950\n\n950: Match macro repetitions r=CohenArthur a=CohenArthur\n\nThis PR adds support for matching macro invocations and counting the amount of times they've been matched\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/796465596faa9fa69ffede1c16d944e6a6e24458", "html_url": "https://github.com/Rust-GCC/gccrs/commit/796465596faa9fa69ffede1c16d944e6a6e24458", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/796465596faa9fa69ffede1c16d944e6a6e24458/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e096b1f14671270fb0c7b449d92b3e558bb769d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e096b1f14671270fb0c7b449d92b3e558bb769d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e096b1f14671270fb0c7b449d92b3e558bb769d"}, {"sha": "d0d4dcfdb438af7c5f15afeba2ca77ecbe2be013", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0d4dcfdb438af7c5f15afeba2ca77ecbe2be013", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0d4dcfdb438af7c5f15afeba2ca77ecbe2be013"}], "stats": {"total": 279, "additions": 265, "deletions": 14}, "files": [{"sha": "52445019078c12ffbb4ab17f122bbe764e3f2e91", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=796465596faa9fa69ffede1c16d944e6a6e24458", "patch": "@@ -2446,13 +2446,13 @@ MacroMatchRepetition::as_string () const\n   str += \"\\n Op: \";\n   switch (op)\n     {\n-    case ASTERISK:\n+    case ANY:\n       str += \"*\";\n       break;\n-    case PLUS:\n+    case ONE_OR_MORE:\n       str += \"+\";\n       break;\n-    case QUESTION_MARK:\n+    case ZERO_OR_ONE:\n       str += \"?\";\n       break;\n     case NONE:"}, {"sha": "995b255294df7fc6c5004a4d7cd0166a412c5a5f", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=796465596faa9fa69ffede1c16d944e6a6e24458", "patch": "@@ -134,9 +134,9 @@ class MacroMatchRepetition : public MacroMatch\n   enum MacroRepOp\n   {\n     NONE,\n-    ASTERISK,\n-    PLUS,\n-    QUESTION_MARK\n+    ANY,\n+    ONE_OR_MORE,\n+    ZERO_OR_ONE,\n   };\n \n private:\n@@ -206,6 +206,9 @@ class MacroMatchRepetition : public MacroMatch\n     return MacroMatchType::Repetition;\n   }\n \n+  MacroRepOp get_op () const { return op; }\n+  std::vector<std::unique_ptr<MacroMatch> > &get_matches () { return matches; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "68859291873b54cc81eb2968046b7766ef2a1dc3", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 114, "deletions": 3, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=796465596faa9fa69ffede1c16d944e6a6e24458", "patch": "@@ -3520,6 +3520,7 @@ MacroExpander::match_matcher (Parser<MacroInvocLexer> &parser,\n   for (auto &match : matcher.get_matches ())\n     {\n       size_t offs_begin = source.get_offs ();\n+\n       switch (match->get_macro_match_type ())\n \t{\n \t  case AST::MacroMatch::MacroMatchType::Fragment: {\n@@ -3597,13 +3598,123 @@ MacroExpander::match_token (Parser<MacroInvocLexer> &parser, AST::Token &token)\n   return parser.skip_token (token.get_id ());\n }\n \n+bool\n+MacroExpander::match_n_matches (\n+  Parser<MacroInvocLexer> &parser,\n+  std::vector<std::unique_ptr<AST::MacroMatch>> &matches, size_t &match_amount,\n+  size_t lo_bound, size_t hi_bound)\n+{\n+  match_amount = 0;\n+\n+  const MacroInvocLexer &source = parser.get_token_source ();\n+  while (true)\n+    {\n+      // If the current token is a closing macro delimiter, break away.\n+      // TODO: Is this correct?\n+      auto t_id = parser.peek_current_token ()->get_id ();\n+      if (t_id == RIGHT_PAREN || t_id == RIGHT_SQUARE || t_id == RIGHT_CURLY)\n+\tbreak;\n+\n+      bool valid_current_match = false;\n+      for (auto &match : matches)\n+\t{\n+\t  size_t offs_begin = source.get_offs ();\n+\t  switch (match->get_macro_match_type ())\n+\t    {\n+\t      case AST::MacroMatch::MacroMatchType::Fragment: {\n+\t\tAST::MacroMatchFragment *fragment\n+\t\t  = static_cast<AST::MacroMatchFragment *> (match.get ());\n+\t\tvalid_current_match = match_fragment (parser, *fragment);\n+\n+\t\t// matched fragment get the offset in the token stream\n+\t\tsize_t offs_end = source.get_offs ();\n+\t\tsub_stack.peek ().insert (\n+\t\t  {fragment->get_ident (),\n+\t\t   {fragment->get_ident (), offs_begin, offs_end}});\n+\t      }\n+\t      break;\n+\n+\t      case AST::MacroMatch::MacroMatchType::Tok: {\n+\t\tAST::Token *tok = static_cast<AST::Token *> (match.get ());\n+\t\tvalid_current_match = match_token (parser, *tok);\n+\t      }\n+\t      break;\n+\n+\t      case AST::MacroMatch::MacroMatchType::Repetition: {\n+\t\tAST::MacroMatchRepetition *rep\n+\t\t  = static_cast<AST::MacroMatchRepetition *> (match.get ());\n+\t\tvalid_current_match = match_repetition (parser, *rep);\n+\t      }\n+\t      break;\n+\n+\t      case AST::MacroMatch::MacroMatchType::Matcher: {\n+\t\tAST::MacroMatcher *m\n+\t\t  = static_cast<AST::MacroMatcher *> (match.get ());\n+\t\tvalid_current_match = match_matcher (parser, *m);\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+      // If we've encountered an error once, stop trying to match more\n+      // repetitions\n+      if (!valid_current_match)\n+\tbreak;\n+\n+      match_amount++;\n+\n+      // Break early if we notice there's too many expressions already\n+      if (hi_bound && match_amount > hi_bound)\n+\tbreak;\n+    }\n+\n+  // Check if the amount of matches we got is valid: Is it more than the lower\n+  // bound and less than the higher bound?\n+  if (!hi_bound) // infinite amount, no upper bound\n+    return match_amount >= lo_bound;\n+  else\n+    return match_amount >= lo_bound && match_amount <= hi_bound;\n+}\n+\n bool\n MacroExpander::match_repetition (Parser<MacroInvocLexer> &parser,\n \t\t\t\t AST::MacroMatchRepetition &rep)\n {\n-  // TODO\n-  gcc_unreachable ();\n-  return false;\n+  size_t match_amount = 0;\n+  bool res = false;\n+\n+  std::string lo_str;\n+  std::string hi_str;\n+  switch (rep.get_op ())\n+    {\n+    case AST::MacroMatchRepetition::MacroRepOp::ANY:\n+      lo_str = \"0\";\n+      hi_str = \"+inf\";\n+      res = match_n_matches (parser, rep.get_matches (), match_amount);\n+      break;\n+    case AST::MacroMatchRepetition::MacroRepOp::ONE_OR_MORE:\n+      lo_str = \"1\";\n+      hi_str = \"+inf\";\n+      res = match_n_matches (parser, rep.get_matches (), match_amount, 1);\n+      break;\n+    case AST::MacroMatchRepetition::MacroRepOp::ZERO_OR_ONE:\n+      lo_str = \"0\";\n+      hi_str = \"1\";\n+      res = match_n_matches (parser, rep.get_matches (), match_amount, 0, 1);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (!res)\n+    rust_error_at (rep.get_match_locus (),\n+\t\t   \"invalid amount of matches for macro invocation. Expected \"\n+\t\t   \"between %s and %s, got %lu\",\n+\t\t   lo_str.c_str (), hi_str.c_str (), match_amount);\n+\n+  rust_debug_loc (rep.get_match_locus (), \"%s matched %lu times\",\n+\t\t  res ? \"successfully\" : \"unsuccessfully\", match_amount);\n+\n+  return res;\n }\n \n AST::ASTFragment"}, {"sha": "d49c77571b23bc3d5b5582987701a5bf01c95bc0", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=796465596faa9fa69ffede1c16d944e6a6e24458", "patch": "@@ -193,6 +193,31 @@ struct MacroExpander\n   bool match_matcher (Parser<MacroInvocLexer> &parser,\n \t\t      AST::MacroMatcher &matcher);\n \n+  /**\n+   * Match any amount of matches\n+   *\n+   * @param parser Parser to use for matching\n+   * @param matches All consecutive matches to identify\n+   * @param match_amount Reference in which to store the ammount of succesful\n+   * and valid matches\n+   *\n+   * @param lo_bound Lower bound of the matcher. When specified, the matcher\n+   * will only succeed if it parses at *least* `lo_bound` fragments. If\n+   * unspecified, the matcher could succeed when parsing 0 fragments.\n+   *\n+   * @param hi_bound Higher bound of the matcher. When specified, the matcher\n+   * will only succeed if it parses *less than* `hi_bound` fragments. If\n+   * unspecified, the matcher could succeed when parsing an infinity of\n+   * fragments.\n+   *\n+   * @return true if matching was successful and within the given limits, false\n+   * otherwise\n+   */\n+  bool match_n_matches (Parser<MacroInvocLexer> &parser,\n+\t\t\tstd::vector<std::unique_ptr<AST::MacroMatch>> &matches,\n+\t\t\tsize_t &match_amount, size_t lo_bound = 0,\n+\t\t\tsize_t hi_bound = 0);\n+\n   static std::vector<std::unique_ptr<AST::Token>>\n   substitute_tokens (std::vector<std::unique_ptr<AST::Token>> &input,\n \t\t     std::vector<std::unique_ptr<AST::Token>> &macro,"}, {"sha": "af8f625c6c05bd9c87c7783fdd17a5e61f32b391", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=796465596faa9fa69ffede1c16d944e6a6e24458", "patch": "@@ -1991,20 +1991,19 @@ Parser<ManagedTokenSource>::parse_macro_match_repetition ()\n \n   // parse repetition operator\n   t = lexer.peek_token ();\n-  AST::MacroMatchRepetition::MacroRepOp op\n-    = AST::MacroMatchRepetition::ASTERISK;\n+  AST::MacroMatchRepetition::MacroRepOp op = AST::MacroMatchRepetition::NONE;\n   switch (t->get_id ())\n     {\n     case ASTERISK:\n-      op = AST::MacroMatchRepetition::ASTERISK;\n+      op = AST::MacroMatchRepetition::ANY;\n       lexer.skip_token ();\n       break;\n     case PLUS:\n-      op = AST::MacroMatchRepetition::PLUS;\n+      op = AST::MacroMatchRepetition::ONE_OR_MORE;\n       lexer.skip_token ();\n       break;\n     case QUESTION_MARK:\n-      op = AST::MacroMatchRepetition::QUESTION_MARK;\n+      op = AST::MacroMatchRepetition::ZERO_OR_ONE;\n       lexer.skip_token ();\n       break;\n     default:"}, {"sha": "e59155cf76f758aa82fe4e1bc62b2415c87eb5ee", "filename": "gcc/testsuite/rust/compile/macro6.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro6.rs?ref=796465596faa9fa69ffede1c16d944e6a6e24458", "patch": "@@ -0,0 +1,11 @@\n+macro_rules! zero_or_one {\n+    ($($a:literal)?) => { // { dg-error \"invalid amount of matches for macro invocation. Expected between 0 and 1, got 2\" }\n+        f()\n+    }\n+}\n+\n+fn main() {\n+    zero_or_one!();\n+    zero_or_one!(14);\n+    zero_or_one!(125 12 \"gcc\"); // { dg-error \"Failed to match any rule within macro\" }\n+}"}, {"sha": "b57c5cbd473c77d347ec5a21cdcd49a22d0e84fc", "filename": "gcc/testsuite/rust/compile/macro7.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro7.rs?ref=796465596faa9fa69ffede1c16d944e6a6e24458", "patch": "@@ -0,0 +1,13 @@\n+fn f() {}\n+\n+macro_rules! one_or_more {\n+    ($($a:literal)+) => { // { dg-error \"invalid amount of matches for macro invocation\" }\n+        f()\n+    }\n+}\n+\n+fn main() {\n+    one_or_more!(1 1 1 1 1 1 1 1 1 1 1 \"rust\" 'c');\n+    one_or_more!(1);\n+    one_or_more!(); // { dg-error \"Failed to match any rule within macro\" }\n+}"}, {"sha": "756d5b05491e3534a248176b8a6c94aea16d9732", "filename": "gcc/testsuite/rust/compile/macro8.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro8.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro8.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro8.rs?ref=796465596faa9fa69ffede1c16d944e6a6e24458", "patch": "@@ -0,0 +1,12 @@\n+fn f() {}\n+\n+macro_rules! expr {\n+    ($($a:expr)?) => {\n+        f()\n+    }\n+}\n+\n+fn main() {\n+    expr!();\n+    expr!(14);\n+}"}, {"sha": "c1e13e323236666815425b68fe771a32e2617050", "filename": "gcc/testsuite/rust/execute/torture/macros7.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros7.rs?ref=796465596faa9fa69ffede1c16d944e6a6e24458", "patch": "@@ -0,0 +1,26 @@\n+// { dg-output \"any\\nany\\nany\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+fn f() {\n+    let r_s = \"any\\n\\0\";\n+    let s_p = r_s as *const str;\n+    let c_p = s_p as *const i8;\n+\n+    unsafe { printf(c_p); }\n+}\n+\n+macro_rules! any {\n+    ($($a:expr)*) => {\n+        f()\n+    }\n+}\n+\n+fn main() -> i32 {\n+    any!();\n+    any!(a + b);\n+    any!(a + b    14 \"gcc\");\n+\n+    0\n+}"}, {"sha": "2f1e23895727f03eea52fbe1e6ea46592e698b9f", "filename": "gcc/testsuite/rust/execute/torture/macros8.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros8.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros8.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros8.rs?ref=796465596faa9fa69ffede1c16d944e6a6e24458", "patch": "@@ -0,0 +1,25 @@\n+// { dg-output \"zo1\\nzo1\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+fn f() {\n+    let r_s = \"zo1\\n\\0\";\n+    let s_p = r_s as *const str;\n+    let c_p = s_p as *const i8;\n+\n+    unsafe { printf(c_p); }\n+}\n+\n+macro_rules! zero_or_one {\n+    ($($a:expr)?) => {\n+        f()\n+    }\n+}\n+\n+fn main() -> i32 {\n+    zero_or_one!();\n+    zero_or_one!(f());\n+\n+    0\n+}"}, {"sha": "22dec2a94cc8cb90329fc2f0712024d613d6442d", "filename": "gcc/testsuite/rust/execute/torture/macros9.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796465596faa9fa69ffede1c16d944e6a6e24458/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros9.rs?ref=796465596faa9fa69ffede1c16d944e6a6e24458", "patch": "@@ -0,0 +1,26 @@\n+// { dg-output \"oom\\noom\\noom\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+fn f() {\n+    let r_s = \"oom\\n\\0\";\n+    let s_p = r_s as *const str;\n+    let c_p = s_p as *const i8;\n+\n+    unsafe { printf(c_p); }\n+}\n+\n+macro_rules! one_or_more {\n+    ($($a:expr)+) => {\n+        f()\n+    }\n+}\n+\n+fn main() -> i32 {\n+    one_or_more!(f());\n+    one_or_more!(f() f());\n+    one_or_more!(f() f() 15 + 12);\n+\n+    0\n+}"}]}