{"sha": "6358a676c3eb4c6df013ce8319bcf429cd14232b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM1OGE2NzZjM2ViNGM2ZGYwMTNjZTgzMTliY2Y0MjljZDE0MjMyYg==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2017-10-11T13:18:06Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2017-10-11T13:18:06Z"}, "message": "X+Y < X iff Y<0 moved to match.pd\n\n2017-10-11  Marc Glisse  <marc.glisse@inria.fr>\n\ngcc/\n\t* fold-const.c (fold_binary_loc) [X +- Y CMP X]: Move ...\n\t* match.pd: ... here.\n\t((T) X == (T) Y): Relax condition.\n\ngcc/testsuite/\n\t* gcc.dg/Wstrict-overflow-7.c: Xfail.\n\t* gcc.dg/pragma-diag-3.c: Likewise.\n\nFrom-SVN: r253642", "tree": {"sha": "61016df93fd440c4971cd59ede26e0ce978eaaea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61016df93fd440c4971cd59ede26e0ce978eaaea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6358a676c3eb4c6df013ce8319bcf429cd14232b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6358a676c3eb4c6df013ce8319bcf429cd14232b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6358a676c3eb4c6df013ce8319bcf429cd14232b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6358a676c3eb4c6df013ce8319bcf429cd14232b/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b4ec1d31a5d605c8bea45ca919d3a60dfdac771f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4ec1d31a5d605c8bea45ca919d3a60dfdac771f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4ec1d31a5d605c8bea45ca919d3a60dfdac771f"}], "stats": {"total": 200, "additions": 62, "deletions": 138}, "files": [{"sha": "d30aa3adf2d7a1b4be3ef070570a91ffc1a16a5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6358a676c3eb4c6df013ce8319bcf429cd14232b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6358a676c3eb4c6df013ce8319bcf429cd14232b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6358a676c3eb4c6df013ce8319bcf429cd14232b", "patch": "@@ -1,3 +1,9 @@\n+2017-10-11  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\t* fold-const.c (fold_binary_loc) [X +- Y CMP X]: Move ...\n+\t* match.pd: ... here.\n+\t((T) X == (T) Y): Relax condition.\n+\n 2017-10-11  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/82472"}, {"sha": "e22b02f13120713ba98b81ac60c34e56d3482a99", "filename": "gcc/fold-const.c", "status": "modified", "additions": 7, "deletions": 133, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6358a676c3eb4c6df013ce8319bcf429cd14232b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6358a676c3eb4c6df013ce8319bcf429cd14232b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6358a676c3eb4c6df013ce8319bcf429cd14232b", "patch": "@@ -10502,40 +10502,6 @@ fold_binary_loc (location_t loc,\n \t  && code == NE_EXPR)\n         return non_lvalue_loc (loc, fold_convert_loc (loc, type, arg0));\n \n-      /* Transform comparisons of the form X +- Y CMP X to Y CMP 0.  */\n-      if ((TREE_CODE (arg0) == PLUS_EXPR\n-\t   || TREE_CODE (arg0) == POINTER_PLUS_EXPR\n-\t   || TREE_CODE (arg0) == MINUS_EXPR)\n-\t  && operand_equal_p (tree_strip_nop_conversions (TREE_OPERAND (arg0,\n-\t\t\t\t\t\t\t\t\t0)),\n-\t\t\t      arg1, 0)\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n-\t      || POINTER_TYPE_P (TREE_TYPE (arg0))))\n-\t{\n-\t  tree val = TREE_OPERAND (arg0, 1);\n-\t  val = fold_build2_loc (loc, code, type, val,\n-\t\t\t\t build_int_cst (TREE_TYPE (val), 0));\n-\t  return omit_two_operands_loc (loc, type, val,\n-\t\t\t\t\tTREE_OPERAND (arg0, 0), arg1);\n-\t}\n-\n-      /* Transform comparisons of the form X CMP X +- Y to Y CMP 0.  */\n-      if ((TREE_CODE (arg1) == PLUS_EXPR\n-\t   || TREE_CODE (arg1) == POINTER_PLUS_EXPR\n-\t   || TREE_CODE (arg1) == MINUS_EXPR)\n-\t  && operand_equal_p (tree_strip_nop_conversions (TREE_OPERAND (arg1,\n-\t\t\t\t\t\t\t\t\t0)),\n-\t\t\t      arg0, 0)\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n-\t      || POINTER_TYPE_P (TREE_TYPE (arg1))))\n-\t{\n-\t  tree val = TREE_OPERAND (arg1, 1);\n-\t  val = fold_build2_loc (loc, code, type, val,\n-\t\t\t\t build_int_cst (TREE_TYPE (val), 0));\n-\t  return omit_two_operands_loc (loc, type, val,\n-\t\t\t\t\tTREE_OPERAND (arg1, 0), arg0);\n-\t}\n-\n       /* If this is an EQ or NE comparison with zero and ARG0 is\n \t (1 << foo) & bar, convert it to (bar >> foo) & 1.  Both require\n \t two operations, but the latter can be done in one less insn\n@@ -10918,130 +10884,38 @@ fold_binary_loc (location_t loc,\n       /* Transform comparisons of the form X +- C CMP X.  */\n       if ((TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n \t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0)\n-\t  && ((TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n-\t       && !HONOR_SNANS (arg0))\n-\t      || (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))))\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n+\t  && !HONOR_SNANS (arg0))\n \t{\n \t  tree arg01 = TREE_OPERAND (arg0, 1);\n \t  enum tree_code code0 = TREE_CODE (arg0);\n-\t  int is_positive;\n-\n-\t  if (TREE_CODE (arg01) == REAL_CST)\n-\t    is_positive = REAL_VALUE_NEGATIVE (TREE_REAL_CST (arg01)) ? -1 : 1;\n-\t  else\n-\t    is_positive = tree_int_cst_sgn (arg01);\n+\t  int is_positive = REAL_VALUE_NEGATIVE (TREE_REAL_CST (arg01)) ? -1 : 1;\n \n \t  /* (X - c) > X becomes false.  */\n \t  if (code == GT_EXPR\n \t      && ((code0 == MINUS_EXPR && is_positive >= 0)\n \t\t  || (code0 == PLUS_EXPR && is_positive <= 0)))\n-\t    {\n-\t      if (TREE_CODE (arg01) == INTEGER_CST\n-\t\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n-\t\tfold_overflow_warning ((\"assuming signed overflow does not \"\n-\t\t\t\t\t\"occur when assuming that (X - c) > X \"\n-\t\t\t\t\t\"is always false\"),\n-\t\t\t\t       WARN_STRICT_OVERFLOW_ALL);\n-\t      return constant_boolean_node (0, type);\n-\t    }\n+\t    return constant_boolean_node (0, type);\n \n \t  /* Likewise (X + c) < X becomes false.  */\n \t  if (code == LT_EXPR\n \t      && ((code0 == PLUS_EXPR && is_positive >= 0)\n \t\t  || (code0 == MINUS_EXPR && is_positive <= 0)))\n-\t    {\n-\t      if (TREE_CODE (arg01) == INTEGER_CST\n-\t\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n-\t\tfold_overflow_warning ((\"assuming signed overflow does not \"\n-\t\t\t\t\t\"occur when assuming that \"\n-\t\t\t\t\t\"(X + c) < X is always false\"),\n-\t\t\t\t       WARN_STRICT_OVERFLOW_ALL);\n-\t      return constant_boolean_node (0, type);\n-\t    }\n+\t    return constant_boolean_node (0, type);\n \n \t  /* Convert (X - c) <= X to true.  */\n \t  if (!HONOR_NANS (arg1)\n \t      && code == LE_EXPR\n \t      && ((code0 == MINUS_EXPR && is_positive >= 0)\n \t\t  || (code0 == PLUS_EXPR && is_positive <= 0)))\n-\t    {\n-\t      if (TREE_CODE (arg01) == INTEGER_CST\n-\t\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n-\t\tfold_overflow_warning ((\"assuming signed overflow does not \"\n-\t\t\t\t\t\"occur when assuming that \"\n-\t\t\t\t\t\"(X - c) <= X is always true\"),\n-\t\t\t\t       WARN_STRICT_OVERFLOW_ALL);\n-\t      return constant_boolean_node (1, type);\n-\t    }\n+\t    return constant_boolean_node (1, type);\n \n \t  /* Convert (X + c) >= X to true.  */\n \t  if (!HONOR_NANS (arg1)\n \t      && code == GE_EXPR\n \t      && ((code0 == PLUS_EXPR && is_positive >= 0)\n \t\t  || (code0 == MINUS_EXPR && is_positive <= 0)))\n-\t    {\n-\t      if (TREE_CODE (arg01) == INTEGER_CST\n-\t\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n-\t\tfold_overflow_warning ((\"assuming signed overflow does not \"\n-\t\t\t\t\t\"occur when assuming that \"\n-\t\t\t\t\t\"(X + c) >= X is always true\"),\n-\t\t\t\t       WARN_STRICT_OVERFLOW_ALL);\n-\t      return constant_boolean_node (1, type);\n-\t    }\n-\n-\t  if (TREE_CODE (arg01) == INTEGER_CST)\n-\t    {\n-\t      /* Convert X + c > X and X - c < X to true for integers.  */\n-\t      if (code == GT_EXPR\n-\t          && ((code0 == PLUS_EXPR && is_positive > 0)\n-\t\t      || (code0 == MINUS_EXPR && is_positive < 0)))\n-\t\t{\n-\t\t  if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n-\t\t    fold_overflow_warning ((\"assuming signed overflow does \"\n-\t\t\t\t\t    \"not occur when assuming that \"\n-\t\t\t\t\t    \"(X + c) > X is always true\"),\n-\t\t\t\t\t   WARN_STRICT_OVERFLOW_ALL);\n-\t\t  return constant_boolean_node (1, type);\n-\t\t}\n-\n-\t      if (code == LT_EXPR\n-\t          && ((code0 == MINUS_EXPR && is_positive > 0)\n-\t\t      || (code0 == PLUS_EXPR && is_positive < 0)))\n-\t\t{\n-\t\t  if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n-\t\t    fold_overflow_warning ((\"assuming signed overflow does \"\n-\t\t\t\t\t    \"not occur when assuming that \"\n-\t\t\t\t\t    \"(X - c) < X is always true\"),\n-\t\t\t\t\t   WARN_STRICT_OVERFLOW_ALL);\n-\t\t  return constant_boolean_node (1, type);\n-\t\t}\n-\n-\t      /* Convert X + c <= X and X - c >= X to false for integers.  */\n-\t      if (code == LE_EXPR\n-\t          && ((code0 == PLUS_EXPR && is_positive > 0)\n-\t\t      || (code0 == MINUS_EXPR && is_positive < 0)))\n-\t\t{\n-\t\t  if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n-\t\t    fold_overflow_warning ((\"assuming signed overflow does \"\n-\t\t\t\t\t    \"not occur when assuming that \"\n-\t\t\t\t\t    \"(X + c) <= X is always false\"),\n-\t\t\t\t\t   WARN_STRICT_OVERFLOW_ALL);\n-\t\t  return constant_boolean_node (0, type);\n-\t\t}\n-\n-\t      if (code == GE_EXPR\n-\t          && ((code0 == MINUS_EXPR && is_positive > 0)\n-\t\t      || (code0 == PLUS_EXPR && is_positive < 0)))\n-\t\t{\n-\t\t  if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n-\t\t    fold_overflow_warning ((\"assuming signed overflow does \"\n-\t\t\t\t\t    \"not occur when assuming that \"\n-\t\t\t\t\t    \"(X - c) >= X is always false\"),\n-\t\t\t\t\t   WARN_STRICT_OVERFLOW_ALL);\n-\t\t  return constant_boolean_node (0, type);\n-\t\t}\n-\t    }\n+\t    return constant_boolean_node (1, type);\n \t}\n \n       /* If we are comparing an ABS_EXPR with a constant, we can"}, {"sha": "f2c43737b800d650e36f899551b87435f74dba81", "filename": "gcc/match.pd", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6358a676c3eb4c6df013ce8319bcf429cd14232b/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6358a676c3eb4c6df013ce8319bcf429cd14232b/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=6358a676c3eb4c6df013ce8319bcf429cd14232b", "patch": "@@ -1280,6 +1280,44 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t   || TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0))))\n    (op @1 @0))))\n \n+/* X + Y < Y is the same as X < 0 when there is no overflow.  */\n+(for op (lt le gt ge)\n+ (simplify\n+  (op:c (plus:c@2 @0 @1) @1)\n+  (if (ANY_INTEGRAL_TYPE_P (TREE_TYPE (@0))\n+       && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (@0))\n+       && (CONSTANT_CLASS_P (@0) || single_use (@2)))\n+   (op @0 { build_zero_cst (TREE_TYPE (@0)); }))))\n+/* For equality, this is also true with wrapping overflow.  */\n+(for op (eq ne)\n+ (simplify\n+  (op:c (nop_convert@3 (plus:c@2 @0 (convert1? @1))) (convert2? @1))\n+  (if (ANY_INTEGRAL_TYPE_P (TREE_TYPE (@0))\n+       && (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (@0))\n+\t   || TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))\n+       && (CONSTANT_CLASS_P (@0) || (single_use (@2) && single_use (@3)))\n+       && tree_nop_conversion_p (TREE_TYPE (@3), TREE_TYPE (@2))\n+       && tree_nop_conversion_p (TREE_TYPE (@3), TREE_TYPE (@1)))\n+   (op @0 { build_zero_cst (TREE_TYPE (@0)); })))\n+ (simplify\n+  (op:c (nop_convert@3 (pointer_plus@2 (convert1? @0) @1)) (convert2? @0))\n+  (if (tree_nop_conversion_p (TREE_TYPE (@2), TREE_TYPE (@0))\n+       && tree_nop_conversion_p (TREE_TYPE (@3), TREE_TYPE (@0))\n+       && (CONSTANT_CLASS_P (@1) || (single_use (@2) && single_use (@3))))\n+   (op @1 { build_zero_cst (TREE_TYPE (@1)); }))))\n+\n+/* X - Y < X is the same as Y > 0 when there is no overflow.\n+   For equality, this is also true with wrapping overflow.  */\n+(for op (simple_comparison)\n+ (simplify\n+  (op:c @0 (minus@2 @0 @1))\n+  (if (ANY_INTEGRAL_TYPE_P (TREE_TYPE (@0))\n+       && (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (@0))\n+\t   || ((op == EQ_EXPR || op == NE_EXPR)\n+\t       && TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0))))\n+       && (CONSTANT_CLASS_P (@1) || single_use (@2)))\n+   (op @1 { build_zero_cst (TREE_TYPE (@1)); }))))\n+\n /* Transform:\n  * (X / Y) == 0 -> X < Y if X, Y are unsigned.\n  * (X / Y) != 0 -> X >= Y, if X, Y are unsigned.\n@@ -3125,7 +3163,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (op (abs @0) zerop@1)\n   (op @0 @1)))\n \n-/* From fold_sign_changed_comparison and fold_widened_comparison.  */\n+/* From fold_sign_changed_comparison and fold_widened_comparison.\n+   FIXME: the lack of symmetry is disturbing.  */\n (for cmp (simple_comparison)\n  (simplify\n   (cmp (convert@0 @00) (convert?@1 @10))\n@@ -3138,11 +3177,11 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n        && single_use (@0))\n    (if (TYPE_PRECISION (TREE_TYPE (@00)) == TYPE_PRECISION (TREE_TYPE (@0))\n \t&& (TREE_CODE (@10) == INTEGER_CST\n-\t    || (@1 != @10 && types_match (TREE_TYPE (@10), TREE_TYPE (@00))))\n+\t    || @1 != @10)\n \t&& (TYPE_UNSIGNED (TREE_TYPE (@00)) == TYPE_UNSIGNED (TREE_TYPE (@0))\n \t    || cmp == NE_EXPR\n \t    || cmp == EQ_EXPR)\n-\t&& (POINTER_TYPE_P (TREE_TYPE (@00)) == POINTER_TYPE_P (TREE_TYPE (@0))))\n+\t&& !POINTER_TYPE_P (TREE_TYPE (@00)))\n     /* ???  The special-casing of INTEGER_CST conversion was in the original\n        code and here to avoid a spurious overflow flag on the resulting\n        constant which fold_convert produces.  */"}, {"sha": "20f7b0f132c5ddbbddba8a53ec6c9520965e9080", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6358a676c3eb4c6df013ce8319bcf429cd14232b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6358a676c3eb4c6df013ce8319bcf429cd14232b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6358a676c3eb4c6df013ce8319bcf429cd14232b", "patch": "@@ -1,3 +1,8 @@\n+2017-10-11  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\t* gcc.dg/Wstrict-overflow-7.c: Xfail.\n+\t* gcc.dg/pragma-diag-3.c: Likewise.\n+\n 2017-10-11  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/82472"}, {"sha": "401cbc3c98717d959210e9418111c1be3266fcdf", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6358a676c3eb4c6df013ce8319bcf429cd14232b/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6358a676c3eb4c6df013ce8319bcf429cd14232b/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-7.c?ref=6358a676c3eb4c6df013ce8319bcf429cd14232b", "patch": "@@ -6,5 +6,5 @@\n int\n foo (int i)\n {\n-  return i + 10 > i; /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" } */\n+  return i + 10 > i; /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" { xfail *-*-* } } */\n }"}, {"sha": "b6ee60f16770924a1e882f10b0c9376ff040c568", "filename": "gcc/testsuite/gcc.dg/pragma-diag-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6358a676c3eb4c6df013ce8319bcf429cd14232b/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-diag-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6358a676c3eb4c6df013ce8319bcf429cd14232b/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-diag-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-diag-3.c?ref=6358a676c3eb4c6df013ce8319bcf429cd14232b", "patch": "@@ -15,7 +15,7 @@ void testing2() {\n \n void testing3() {\n   int k = 4;\n-  k + 4 < k; /* { dg-error \"overflow\" } */\n+  k + 4 < k; /* { dg-error \"overflow\" \"\" { xfail *-*-* } } */\n }\n \n int bar()"}]}