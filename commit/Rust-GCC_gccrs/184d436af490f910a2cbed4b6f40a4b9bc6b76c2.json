{"sha": "184d436af490f910a2cbed4b6f40a4b9bc6b76c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg0ZDQzNmFmNDkwZjkxMGEyY2JlZDRiNmY0MGE0YjliYzZiNzZjMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-02-27T10:27:15Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-02-27T10:27:15Z"}, "message": "decl.c (gnat_to_gnu_entity): Revert previous change that creates a special VAR_DECL for debugging purposes.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Revert previous\n\tchange that creates a special VAR_DECL for debugging purposes.  For an\n\taliased object with an unconstrained nominal subtype, make its type a\n\tthin reference to the underlying object.\n\t* gcc-interface/utils2.c (build_unary_op) <INDIRECT_REF>: Deal with\n\texpressions built for the initialization of above objects.\n\nFrom-SVN: r184593", "tree": {"sha": "e1fae0ee4051283969b2c263b8aa570e6a25ef3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1fae0ee4051283969b2c263b8aa570e6a25ef3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/184d436af490f910a2cbed4b6f40a4b9bc6b76c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/184d436af490f910a2cbed4b6f40a4b9bc6b76c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/184d436af490f910a2cbed4b6f40a4b9bc6b76c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/184d436af490f910a2cbed4b6f40a4b9bc6b76c2/comments", "author": null, "committer": null, "parents": [{"sha": "2c2a780f7f5a7ba054cf1ba5b1998b031c1d9535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c2a780f7f5a7ba054cf1ba5b1998b031c1d9535", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c2a780f7f5a7ba054cf1ba5b1998b031c1d9535"}], "stats": {"total": 121, "additions": 77, "deletions": 44}, "files": [{"sha": "ab89b0b8c64885ebc93cdc5b15e1366360659354", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/184d436af490f910a2cbed4b6f40a4b9bc6b76c2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/184d436af490f910a2cbed4b6f40a4b9bc6b76c2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=184d436af490f910a2cbed4b6f40a4b9bc6b76c2", "patch": "@@ -1,3 +1,12 @@\n+2012-02-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Revert previous\n+\tchange that creates a special VAR_DECL for debugging purposes.  For an\n+\taliased object with an unconstrained nominal subtype, make its type a\n+\tthin reference to the underlying object.\n+\t* gcc-interface/utils2.c (build_unary_op) <INDIRECT_REF>: Deal with\n+\texpressions built for the initialization of above objects.\n+\n 2012-02-24  Dave Korn  <dave.korn.cygwin@gmail.com>\n \n \t* gcc-interface/Makefile.in (WIN_SO_PREFIX [windows targets]): New"}, {"sha": "55f86812140bd0bac155b7397418df9116e1c818", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/184d436af490f910a2cbed4b6f40a4b9bc6b76c2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/184d436af490f910a2cbed4b6f40a4b9bc6b76c2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=184d436af490f910a2cbed4b6f40a4b9bc6b76c2", "patch": "@@ -1379,6 +1379,49 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    const_flag = true;\n \t  }\n \n+\t/* If this is an aliased object with an unconstrained nominal subtype,\n+\t   we make its type a thin reference, i.e. the reference counterpart\n+\t   of a thin pointer, so that it points to the array part.  This is\n+\t   aimed at making it easier for the debugger to decode the object.\n+\t   Note that we have to do that this late because of the couple of\n+\t   allocation adjustments that might be made just above.  */\n+\tif (Is_Constr_Subt_For_UN_Aliased (Etype (gnat_entity))\n+\t    && Is_Array_Type (Etype (gnat_entity))\n+\t    && !type_annotate_only)\n+\t  {\n+\t    tree gnu_array\n+\t      = gnat_to_gnu_type (Base_Type (Etype (gnat_entity)));\n+\n+\t    /* In case the object with the template has already been allocated\n+\t       just above, we have nothing to do here.  */\n+\t    if (!TYPE_IS_THIN_POINTER_P (gnu_type))\n+\t      {\n+\t        gnu_size = NULL_TREE;\n+\t\tused_by_ref = true;\n+\n+\t\tif (definition && !imported_p)\n+\t\t  {\n+\t\t    tree gnu_unc_var\n+\t\t      = create_var_decl (concat_name (gnu_entity_name, \"UNC\"),\n+\t\t\t\t\t NULL_TREE, gnu_type, gnu_expr,\n+\t\t\t\t\t const_flag, Is_Public (gnat_entity),\n+\t\t\t\t\t false, static_p, NULL, gnat_entity);\n+\t\t    gnu_expr\n+\t\t      = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_unc_var);\n+\t\t    TREE_CONSTANT (gnu_expr) = 1;\n+\t\t    const_flag = true;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    gnu_expr = NULL_TREE;\n+\t\t    const_flag = false;\n+\t\t  }\n+\t      }\n+\n+\t    gnu_type\n+\t      = build_reference_type (TYPE_OBJECT_RECORD_TYPE (gnu_array));\n+\t  }\n+\n \tif (const_flag)\n \t  gnu_type = build_qualified_type (gnu_type, (TYPE_QUALS (gnu_type)\n \t\t\t\t\t\t      | TYPE_QUAL_CONST));\n@@ -1469,41 +1512,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      }\n \t  }\n \n-\t/* If this is an aliased object with an unconstrained nominal subtype\n-\t   and optimization isn't enabled, create a VAR_DECL for debugging\n-\t   purposes whose type is a thin reference (the reference counterpart\n-\t   of a thin pointer), so that it will be directly initialized to the\n-\t   address of the array part.  */\n-\telse if (Is_Constr_Subt_For_UN_Aliased (Etype (gnat_entity))\n-\t\t && Is_Array_Type (Etype (gnat_entity))\n-\t\t && !type_annotate_only\n-\t\t && !optimize\n-\t\t && debug_info_p)\n-\t  {\n-\t    tree gnu_array\n-\t      = gnat_to_gnu_type (Base_Type (Etype (gnat_entity)));\n-\t    tree gnu_thin_type\n-\t      = build_reference_type (TYPE_OBJECT_RECORD_TYPE (gnu_array));\n-\t    tree gnu_ref, gnu_debug_decl;\n-\n-\t    /* In case the object with the template has already been indirectly\n-\t       allocated, we have nothing to do here.  */\n-\t    if (TYPE_IS_THIN_POINTER_P (gnu_type))\n-\t      gnu_ref = gnu_decl;\n-\t    else\n-\t      gnu_ref = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_decl);\n-\t    gnu_ref = convert (gnu_thin_type, gnu_ref);\n-\n-\t    gnu_debug_decl\n-\t      = create_var_decl (gnu_entity_name, gnu_ext_name,\n-\t\t\t\t gnu_thin_type, NULL_TREE, const_flag,\n-\t\t\t\t Is_Public (gnat_entity), !definition,\n-\t\t\t\t static_p, attr_list, gnat_entity);\n-\t    SET_DECL_VALUE_EXPR (gnu_debug_decl, gnu_ref);\n-\t    DECL_HAS_VALUE_EXPR_P (gnu_debug_decl) = 1;\n-\t    DECL_IGNORED_P (gnu_decl) = 1;\n-\t  }\n-\n \t/* If this is a constant and we are defining it or it generates a real\n \t   symbol at the object level and we are referencing it, we may want\n \t   or need to have a true variable to represent it:"}, {"sha": "3322341c27c4ec9a1be88bad9cc65a9bc1fcadee", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/184d436af490f910a2cbed4b6f40a4b9bc6b76c2/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/184d436af490f910a2cbed4b6f40a4b9bc6b76c2/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=184d436af490f910a2cbed4b6f40a4b9bc6b76c2", "patch": "@@ -1365,8 +1365,8 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \tdefault:\n \tcommon:\n \n-\t  /* If we are taking the address of a padded record whose field is\n-\t     contains a template, take the address of the template.  */\n+\t  /* If we are taking the address of a padded record whose field\n+\t     contains a template, take the address of the field.  */\n \t  if (TYPE_IS_PADDING_P (type)\n \t      && TREE_CODE (TREE_TYPE (TYPE_FIELDS (type))) == RECORD_TYPE\n \t      && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (TYPE_FIELDS (type))))\n@@ -1387,14 +1387,30 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \ttree t = remove_conversions (operand, false);\n \tbool can_never_be_null = DECL_P (t) && DECL_CAN_NEVER_BE_NULL_P (t);\n \n-\t/* If TYPE is a thin pointer, first convert to the fat pointer.  */\n-\tif (TYPE_IS_THIN_POINTER_P (type)\n-\t    && TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)))\n+\t/* If TYPE is a thin pointer, either first retrieve the base if this\n+\t   is an expression with an offset built for the initialization of an\n+\t   object with an unconstrained nominal subtype, or else convert to\n+\t   the fat pointer.  */\n+\tif (TYPE_IS_THIN_POINTER_P (type))\n \t  {\n-\t    operand = convert\n-\t\t      (TREE_TYPE (TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type))),\n-\t\t       operand);\n-\t    type = TREE_TYPE (operand);\n+\t    tree rec_type = TREE_TYPE (type);\n+\n+\t    if (TREE_CODE (operand) == POINTER_PLUS_EXPR\n+\t\t&& integer_zerop\n+\t\t   (size_binop (PLUS_EXPR, TREE_OPERAND (operand, 1),\n+\t\t\t\tDECL_FIELD_OFFSET (TYPE_FIELDS (rec_type))))\n+\t\t&& TREE_CODE (TREE_OPERAND (operand, 0)) == NOP_EXPR)\n+\t      {\n+\t\toperand = TREE_OPERAND (TREE_OPERAND (operand, 0), 0);\n+\t\ttype = TREE_TYPE (operand);\n+\t      }\n+\t    else if (TYPE_UNCONSTRAINED_ARRAY (rec_type))\n+\t      {\n+\t\toperand\n+\t\t  = convert (TREE_TYPE (TYPE_UNCONSTRAINED_ARRAY (rec_type)),\n+\t\t\t     operand);\n+\t\ttype = TREE_TYPE (operand);\n+\t      }\n \t  }\n \n \t/* If we want to refer to an unconstrained array, use the appropriate"}]}