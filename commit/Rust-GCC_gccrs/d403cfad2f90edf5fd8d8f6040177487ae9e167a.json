{"sha": "d403cfad2f90edf5fd8d8f6040177487ae9e167a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQwM2NmYWQyZjkwZWRmNWZkOGQ4ZjYwNDAxNzc0ODdhZTllMTY3YQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2019-08-19T08:36:35Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-08-19T08:36:35Z"}, "message": "[Ada] Process type extensions for -gnatw.h\n\nThis patch enables gap detection in type extensions.\n\nWith the -gnatw.h switch, on 64-bit machines,\nthe following test should get warnings:\n\ngcc -c gaps.ads -gnatw.h\ngaps.ads:16:07: warning: 48-bit gap before component \"Comp2\"\ngaps.ads:17:07: warning: 8-bit gap before component \"Comp3\"\n\npackage Gaps is\n   type Integer_16 is mod 2**16;\n\n   type TestGap is tagged record\n      Comp1 : Integer_16;\n   end record;\n   for TestGap use record\n      Comp1 at 0 + 8 range 0..15;\n   end record;\n\n   type TestGap2 is new TestGap with record\n      Comp2  : Integer_16;\n      Comp3  : Integer_16;\n   end record;\n   for TestGap2 use record\n      Comp2 at 08 + 8 range 0..15;\n      Comp3 at 11 + 8 range 0..15;\n   end record;\n\nend Gaps;\n\n2019-08-19  Bob Duff  <duff@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch13.adb (Record_Hole_Check): Procedure to check for holes\n\tthat incudes processing type extensions. A type extension is\n\tprocessed by first calling Record_Hole_Check recursively on the\n\tparent type to compute the bit number after the last component\n\tof the parent.\n\nFrom-SVN: r274653", "tree": {"sha": "05dc28b59765f7292b2c14024c3f8786ff5ae2f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05dc28b59765f7292b2c14024c3f8786ff5ae2f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d403cfad2f90edf5fd8d8f6040177487ae9e167a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d403cfad2f90edf5fd8d8f6040177487ae9e167a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d403cfad2f90edf5fd8d8f6040177487ae9e167a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d403cfad2f90edf5fd8d8f6040177487ae9e167a/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eb6b9c9bcb5ac89eab098d3774e6429b6cfaeb6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6b9c9bcb5ac89eab098d3774e6429b6cfaeb6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb6b9c9bcb5ac89eab098d3774e6429b6cfaeb6e"}], "stats": {"total": 427, "additions": 243, "deletions": 184}, "files": [{"sha": "f6e00851384dc28a7e516d99c75ce25cb87ab6bc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d403cfad2f90edf5fd8d8f6040177487ae9e167a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d403cfad2f90edf5fd8d8f6040177487ae9e167a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d403cfad2f90edf5fd8d8f6040177487ae9e167a", "patch": "@@ -1,3 +1,11 @@\n+2019-08-19  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch13.adb (Record_Hole_Check): Procedure to check for holes\n+\tthat incudes processing type extensions. A type extension is\n+\tprocessed by first calling Record_Hole_Check recursively on the\n+\tparent type to compute the bit number after the last component\n+\tof the parent.\n+\n 2019-08-19  Gary Dismukes  <dismukes@adacore.com>\n \n \t* checks.adb (Length_Mismatch_Info_Message): New function in"}, {"sha": "a3a7be728f0a4fb1602d86bf7fc68e449a4c62a2", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 235, "deletions": 184, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d403cfad2f90edf5fd8d8f6040177487ae9e167a/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d403cfad2f90edf5fd8d8f6040177487ae9e167a/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=d403cfad2f90edf5fd8d8f6040177487ae9e167a", "patch": "@@ -10122,6 +10122,14 @@ package body Sem_Ch13 is\n       --  issued, since the message was already given. Comp is also set to\n       --  Empty if the current \"component clause\" is in fact a pragma.\n \n+      procedure Record_Hole_Check\n+        (Rectype : Entity_Id; After_Last : out Uint; Warn : Boolean);\n+      --  Checks for gaps in the given Rectype. Compute After_Last, the bit\n+      --  number after the last component. Warn is True on the initial call,\n+      --  and warnings are given for gaps. For a type extension, this is called\n+      --  recursively to compute After_Last for the parent type; in this case\n+      --  Warn is False and the warnings are suppressed.\n+\n       -----------------------------\n       -- Check_Component_Overlap --\n       -----------------------------\n@@ -10233,6 +10241,225 @@ package body Sem_Ch13 is\n          end if;\n       end Find_Component;\n \n+      -----------------------\n+      -- Record_Hole_Check --\n+      -----------------------\n+\n+      procedure Record_Hole_Check\n+        (Rectype : Entity_Id; After_Last : out Uint; Warn : Boolean)\n+      is\n+         Decl : constant Node_Id := Declaration_Node (Base_Type (Rectype));\n+         --  Full declaration of record type\n+\n+         procedure Check_Component_List\n+           (DS   : List_Id;\n+            CL   : Node_Id;\n+            Sbit : Uint;\n+            Abit : out Uint);\n+         --  Check component list CL for holes. DS is a list of discriminant\n+         --  specifications to be included in the consideration of components.\n+         --  Sbit is the starting bit, which is zero if there are no preceding\n+         --  components (before a variant part, or a parent type, or a tag\n+         --  field). If there are preceding components, Sbit is the bit just\n+         --  after the last such component. Abit is set to the bit just after\n+         --  the last component of DS and CL.\n+\n+         --------------------------\n+         -- Check_Component_List --\n+         --------------------------\n+\n+         procedure Check_Component_List\n+           (DS   : List_Id;\n+            CL   : Node_Id;\n+            Sbit : Uint;\n+            Abit : out Uint)\n+         is\n+            Compl : Integer;\n+\n+         begin\n+            Compl := Integer (List_Length (Component_Items (CL)));\n+\n+            if DS /= No_List then\n+               Compl := Compl + Integer (List_Length (DS));\n+            end if;\n+\n+            declare\n+               Comps : array (Natural range 0 .. Compl) of Entity_Id;\n+               --  Gather components (zero entry is for sort routine)\n+\n+               Ncomps : Natural := 0;\n+               --  Number of entries stored in Comps (starting at Comps (1))\n+\n+               Citem : Node_Id;\n+               --  One component item or discriminant specification\n+\n+               Nbit  : Uint;\n+               --  Starting bit for next component\n+\n+               CEnt  : Entity_Id;\n+               --  Component entity\n+\n+               Variant : Node_Id;\n+               --  One variant\n+\n+               function Lt (Op1, Op2 : Natural) return Boolean;\n+               --  Compare routine for Sort\n+\n+               procedure Move (From : Natural; To : Natural);\n+               --  Move routine for Sort\n+\n+               package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n+\n+               --------\n+               -- Lt --\n+               --------\n+\n+               function Lt (Op1, Op2 : Natural) return Boolean is\n+               begin\n+                  return Component_Bit_Offset (Comps (Op1))\n+                       < Component_Bit_Offset (Comps (Op2));\n+               end Lt;\n+\n+               ----------\n+               -- Move --\n+               ----------\n+\n+               procedure Move (From : Natural; To : Natural) is\n+               begin\n+                  Comps (To) := Comps (From);\n+               end Move;\n+\n+            begin\n+               --  Gather discriminants into Comp\n+\n+               if DS /= No_List then\n+                  Citem := First (DS);\n+                  while Present (Citem) loop\n+                     if Nkind (Citem) = N_Discriminant_Specification then\n+                        declare\n+                           Ent : constant Entity_Id :=\n+                                   Defining_Identifier (Citem);\n+                        begin\n+                           if Ekind (Ent) = E_Discriminant then\n+                              Ncomps := Ncomps + 1;\n+                              Comps (Ncomps) := Ent;\n+                           end if;\n+                        end;\n+                     end if;\n+\n+                     Next (Citem);\n+                  end loop;\n+               end if;\n+\n+               --  Gather component entities into Comp\n+\n+               Citem := First (Component_Items (CL));\n+               while Present (Citem) loop\n+                  if Nkind (Citem) = N_Component_Declaration then\n+                     Ncomps := Ncomps + 1;\n+                     Comps (Ncomps) := Defining_Identifier (Citem);\n+                  end if;\n+\n+                  Next (Citem);\n+               end loop;\n+\n+               --  Now sort the component entities based on the first bit.\n+               --  Note we already know there are no overlapping components.\n+\n+               Sorting.Sort (Ncomps);\n+\n+               --  Loop through entries checking for holes\n+\n+               Nbit := Sbit;\n+               for J in 1 .. Ncomps loop\n+                  CEnt := Comps (J);\n+\n+                  declare\n+                     CBO : constant Uint := Component_Bit_Offset (CEnt);\n+\n+                  begin\n+                     --  Skip components with unknown offsets\n+\n+                     if CBO /= No_Uint and then CBO >= 0 then\n+                        Error_Msg_Uint_1 := CBO - Nbit;\n+\n+                        if Warn and then Error_Msg_Uint_1 > 0 then\n+                           Error_Msg_NE\n+                             (\"?H?^-bit gap before component&\",\n+                              Component_Name (Component_Clause (CEnt)),\n+                              CEnt);\n+                        end if;\n+\n+                        Nbit := CBO + Esize (CEnt);\n+                     end if;\n+                  end;\n+               end loop;\n+\n+               --  Set Abit to just after the last nonvariant component\n+\n+               Abit := Nbit;\n+\n+               --  Process variant parts recursively if present. Set Abit to\n+               --  the maximum for all variant parts.\n+\n+               if Present (Variant_Part (CL)) then\n+                  declare\n+                     Var_Start : constant Uint := Nbit;\n+                  begin\n+                     Variant := First (Variants (Variant_Part (CL)));\n+                     while Present (Variant) loop\n+                        Check_Component_List\n+                          (No_List, Component_List (Variant), Var_Start, Nbit);\n+                        Next (Variant);\n+                        if Nbit > Abit then\n+                           Abit := Nbit;\n+                        end if;\n+                     end loop;\n+                  end;\n+               end if;\n+            end;\n+         end Check_Component_List;\n+\n+         Sbit : Uint;\n+         --  Starting bit for call to Check_Component_List. Zero for an\n+         --  untagged type. The size of the Tag for a nonderived tagged\n+         --  type. Parent size for a type extension.\n+\n+         Record_Definition : Node_Id;\n+         --  Record_Definition containing Component_List to pass to\n+         --  Check_Component_List.\n+\n+      --  Start of processing for Record_Hole_Check\n+\n+      begin\n+         if Is_Tagged_Type (Rectype) then\n+            Sbit := UI_From_Int (System_Address_Size);\n+         else\n+            Sbit := Uint_0;\n+         end if;\n+\n+         if Nkind (Decl) = N_Full_Type_Declaration then\n+            Record_Definition := Type_Definition (Decl);\n+\n+            --  If we have a record extension, set Sbit to point after the last\n+            --  component of the parent type, by calling Record_Hole_Check\n+            --  recursively.\n+\n+            if Nkind (Record_Definition) = N_Derived_Type_Definition then\n+               Record_Definition := Record_Extension_Part (Record_Definition);\n+               Record_Hole_Check (Underlying_Type (Parent_Subtype (Rectype)),\n+                                  After_Last => Sbit, Warn => False);\n+            end if;\n+\n+            if Nkind (Record_Definition) = N_Record_Definition then\n+               Check_Component_List\n+                 (Discriminant_Specifications (Decl),\n+                  Component_List (Record_Definition),\n+                  Sbit, After_Last);\n+            end if;\n+         end if;\n+      end Record_Hole_Check;\n+\n    --  Start of processing for Check_Record_Representation_Clause\n \n    begin\n@@ -10589,192 +10816,16 @@ package body Sem_Ch13 is\n          end Overlap_Check2;\n       end if;\n \n-      --  The following circuit deals with warning on record holes (gaps). We\n-      --  skip this check if overlap was detected, since it makes sense for the\n-      --  programmer to fix this illegality before worrying about warnings.\n-\n-      if not Overlap_Detected and Warn_On_Record_Holes then\n-         Record_Hole_Check : declare\n-            Decl : constant Node_Id := Declaration_Node (Base_Type (Rectype));\n-            --  Full declaration of record type\n-\n-            procedure Check_Component_List\n-              (CL   : Node_Id;\n-               Sbit : Uint;\n-               DS   : List_Id);\n-            --  Check component list CL for holes. The starting bit should be\n-            --  Sbit. which is zero for the main record component list and set\n-            --  appropriately for recursive calls for variants. DS is set to\n-            --  a list of discriminant specifications to be included in the\n-            --  consideration of components. It is No_List if none to consider.\n-\n-            --------------------------\n-            -- Check_Component_List --\n-            --------------------------\n-\n-            procedure Check_Component_List\n-              (CL   : Node_Id;\n-               Sbit : Uint;\n-               DS   : List_Id)\n-            is\n-               Compl : Integer;\n-\n-            begin\n-               Compl := Integer (List_Length (Component_Items (CL)));\n-\n-               if DS /= No_List then\n-                  Compl := Compl + Integer (List_Length (DS));\n-               end if;\n-\n-               declare\n-                  Comps : array (Natural range 0 .. Compl) of Entity_Id;\n-                  --  Gather components (zero entry is for sort routine)\n-\n-                  Ncomps : Natural := 0;\n-                  --  Number of entries stored in Comps (starting at Comps (1))\n-\n-                  Citem : Node_Id;\n-                  --  One component item or discriminant specification\n-\n-                  Nbit  : Uint;\n-                  --  Starting bit for next component\n-\n-                  CEnt  : Entity_Id;\n-                  --  Component entity\n-\n-                  Variant : Node_Id;\n-                  --  One variant\n-\n-                  function Lt (Op1, Op2 : Natural) return Boolean;\n-                  --  Compare routine for Sort\n-\n-                  procedure Move (From : Natural; To : Natural);\n-                  --  Move routine for Sort\n-\n-                  package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n-\n-                  --------\n-                  -- Lt --\n-                  --------\n-\n-                  function Lt (Op1, Op2 : Natural) return Boolean is\n-                  begin\n-                     return Component_Bit_Offset (Comps (Op1))\n-                       <\n-                       Component_Bit_Offset (Comps (Op2));\n-                  end Lt;\n-\n-                  ----------\n-                  -- Move --\n-                  ----------\n-\n-                  procedure Move (From : Natural; To : Natural) is\n-                  begin\n-                     Comps (To) := Comps (From);\n-                  end Move;\n-\n-               begin\n-                  --  Gather discriminants into Comp\n-\n-                  if DS /= No_List then\n-                     Citem := First (DS);\n-                     while Present (Citem) loop\n-                        if Nkind (Citem) = N_Discriminant_Specification then\n-                           declare\n-                              Ent : constant Entity_Id :=\n-                                      Defining_Identifier (Citem);\n-                           begin\n-                              if Ekind (Ent) = E_Discriminant then\n-                                 Ncomps := Ncomps + 1;\n-                                 Comps (Ncomps) := Ent;\n-                              end if;\n-                           end;\n-                        end if;\n-\n-                        Next (Citem);\n-                     end loop;\n-                  end if;\n-\n-                  --  Gather component entities into Comp\n-\n-                  Citem := First (Component_Items (CL));\n-                  while Present (Citem) loop\n-                     if Nkind (Citem) = N_Component_Declaration then\n-                        Ncomps := Ncomps + 1;\n-                        Comps (Ncomps) := Defining_Identifier (Citem);\n-                     end if;\n-\n-                     Next (Citem);\n-                  end loop;\n-\n-                  --  Now sort the component entities based on the first bit.\n-                  --  Note we already know there are no overlapping components.\n-\n-                  Sorting.Sort (Ncomps);\n-\n-                  --  Loop through entries checking for holes\n-\n-                  Nbit := Sbit;\n-                  for J in 1 .. Ncomps loop\n-                     CEnt := Comps (J);\n-\n-                     declare\n-                        CBO : constant Uint := Component_Bit_Offset (CEnt);\n-\n-                     begin\n-                        --  Skip components with unknown offsets\n-\n-                        if CBO /= No_Uint and then CBO >= 0 then\n-                           Error_Msg_Uint_1 := CBO - Nbit;\n-\n-                           if Error_Msg_Uint_1 > 0 then\n-                              Error_Msg_NE\n-                                (\"?H?^-bit gap before component&\",\n-                                 Component_Name (Component_Clause (CEnt)),\n-                                 CEnt);\n-                           end if;\n-\n-                           Nbit := CBO + Esize (CEnt);\n-                        end if;\n-                     end;\n-                  end loop;\n-\n-                  --  Process variant parts recursively if present\n-\n-                  if Present (Variant_Part (CL)) then\n-                     Variant := First (Variants (Variant_Part (CL)));\n-                     while Present (Variant) loop\n-                        Check_Component_List\n-                          (Component_List (Variant), Nbit, No_List);\n-                        Next (Variant);\n-                     end loop;\n-                  end if;\n-               end;\n-            end Check_Component_List;\n-\n-         --  Start of processing for Record_Hole_Check\n+      --  Check for record holes (gaps). We skip this check if overlap was\n+      --  detected, since it makes sense for the programmer to fix this\n+      --  error before worrying about warnings.\n \n+      if Warn_On_Record_Holes and not Overlap_Detected then\n+         declare\n+            Ignore : Uint;\n          begin\n-            declare\n-               Sbit : Uint;\n-\n-            begin\n-               if Is_Tagged_Type (Rectype) then\n-                  Sbit := UI_From_Int (System_Address_Size);\n-               else\n-                  Sbit := Uint_0;\n-               end if;\n-\n-               if Nkind (Decl) = N_Full_Type_Declaration\n-                 and then Nkind (Type_Definition (Decl)) = N_Record_Definition\n-               then\n-                  Check_Component_List\n-                    (Component_List (Type_Definition (Decl)),\n-                     Sbit,\n-                     Discriminant_Specifications (Decl));\n-               end if;\n-            end;\n-         end Record_Hole_Check;\n+            Record_Hole_Check (Rectype, After_Last => Ignore, Warn => True);\n+         end;\n       end if;\n \n       --  For records that have component clauses for all components, and whose"}]}