{"sha": "69720717c143a9dc77d4c52dd5e2f19858425fa8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk3MjA3MTdjMTQzYTlkYzc3ZDRjNTJkZDVlMmYxOTg1ODQyNWZhOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-07-17T08:10:04Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-07-17T08:10:04Z"}, "message": "[Ada] Type mismatch warning for imported C++ class\n\n2018-07-17  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* gcc-interface/ada-tree.h (TYPE_RETURN_BY_DIRECT_REF_P): Define for\n\tMETHOD_TYPE too.\n\t(TYPE_RETURN_UNCONSTRAINED_P): Likewise.\n\t(TYPE_CI_CO_LIST): Likewise.\n\t* gcc-interface/gigi.h (is_cplusplus_method): Delete.\n\t(fntype_same_flags_p): Adjust comment.\n\t* gcc-interface/decl.c (Has_Thiscall_Convention): Delete.\n\t(gnat_to_gnu_entity) <E_Subprogram_Type>: Do not set the \"thiscall\"\n\tattribute directly.\n\t(is_cplusplus_method): Make static and adjust head comment.\n\t(gnat_to_gnu_param): Return a pointer for the \"this\" parameter of\n\tC++ constructors.\n\t(gnat_to_gnu_subprog_type): Turn imported C++ constructors into their\n\tcallable form.  Generate a METHOD_TYPE node for imported C++ methods.\n\tSet param_list at the very end of the processing.\n\t(substitute_in_type) <METHOD_TYPE>: New case.\n\t* gcc-interface/misc.c (gnat_print_type) <METHOD_TYPE>: Likewise.\n\t(gnat_type_hash_eq): Accept METHOD_TYPE.\n\t* gcc-interface/trans.c (Identifier_to_gnu): Deal with METHOD_TYPE.\n\t(Attribute_to_gnu): Likewise.\n\t(Call_to_gnu): Likewise.\n\t(process_freeze_entity): Likewise.\n\t* gcc-interface/utils.c (create_subprog_decl): Adjust head comment.\n\t(fntype_same_flags_p): Likewise.\n\nFrom-SVN: r262792", "tree": {"sha": "58f1e9f5f651c6376b9924d9b982df13c26b31c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58f1e9f5f651c6376b9924d9b982df13c26b31c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69720717c143a9dc77d4c52dd5e2f19858425fa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69720717c143a9dc77d4c52dd5e2f19858425fa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69720717c143a9dc77d4c52dd5e2f19858425fa8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69720717c143a9dc77d4c52dd5e2f19858425fa8/comments", "author": null, "committer": null, "parents": [{"sha": "123483ca18f7d6d0c5b28230e826a44a7cf4f111", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/123483ca18f7d6d0c5b28230e826a44a7cf4f111", "html_url": "https://github.com/Rust-GCC/gccrs/commit/123483ca18f7d6d0c5b28230e826a44a7cf4f111"}], "stats": {"total": 170, "additions": 115, "deletions": 55}, "files": [{"sha": "99ae0ea67b3463a2f9c8a1018e442c051852a030", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69720717c143a9dc77d4c52dd5e2f19858425fa8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69720717c143a9dc77d4c52dd5e2f19858425fa8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=69720717c143a9dc77d4c52dd5e2f19858425fa8", "patch": "@@ -1,3 +1,30 @@\n+2018-07-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (TYPE_RETURN_BY_DIRECT_REF_P): Define for\n+\tMETHOD_TYPE too.\n+\t(TYPE_RETURN_UNCONSTRAINED_P): Likewise.\n+\t(TYPE_CI_CO_LIST): Likewise.\n+\t* gcc-interface/gigi.h (is_cplusplus_method): Delete.\n+\t(fntype_same_flags_p): Adjust comment.\n+\t* gcc-interface/decl.c (Has_Thiscall_Convention): Delete.\n+\t(gnat_to_gnu_entity) <E_Subprogram_Type>: Do not set the \"thiscall\"\n+\tattribute directly.\n+\t(is_cplusplus_method): Make static and adjust head comment.\n+\t(gnat_to_gnu_param): Return a pointer for the \"this\" parameter of\n+\tC++ constructors.\n+\t(gnat_to_gnu_subprog_type): Turn imported C++ constructors into their\n+\tcallable form.  Generate a METHOD_TYPE node for imported C++ methods.\n+\tSet param_list at the very end of the processing.\n+\t(substitute_in_type) <METHOD_TYPE>: New case.\n+\t* gcc-interface/misc.c (gnat_print_type) <METHOD_TYPE>: Likewise.\n+\t(gnat_type_hash_eq): Accept METHOD_TYPE.\n+\t* gcc-interface/trans.c (Identifier_to_gnu): Deal with METHOD_TYPE.\n+\t(Attribute_to_gnu): Likewise.\n+\t(Call_to_gnu): Likewise.\n+\t(process_freeze_entity): Likewise.\n+\t* gcc-interface/utils.c (create_subprog_decl): Adjust head comment.\n+\t(fntype_same_flags_p): Likewise.\n+\n 2018-07-17  Piotr Trojanek  <trojanek@adacore.com>\n \n \t* inline.adb (Expand_Inlined_Call): Remove extra parentheses."}, {"sha": "77e6bac05baba0fe9bd44d3d4cf7f19cba8f25ba", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69720717c143a9dc77d4c52dd5e2f19858425fa8/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69720717c143a9dc77d4c52dd5e2f19858425fa8/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=69720717c143a9dc77d4c52dd5e2f19858425fa8", "patch": "@@ -83,11 +83,11 @@ do {\t\t\t\t\t\t\t \\\n   ((TREE_CODE (NODE) == INTEGER_TYPE || TREE_CODE (NODE) == ARRAY_TYPE) \\\n    && TYPE_PACKED_ARRAY_TYPE_P (NODE))\n \n-/* For FUNCTION_TYPEs, nonzero if the function returns by direct reference,\n-   i.e. the callee returns a pointer to a memory location it has allocated\n-   and the caller only needs to dereference the pointer.  */\n+/* For FUNCTION_TYPE and METHOD_TYPE, nonzero if the function returns by\n+   direct reference, i.e. the callee returns a pointer to a memory location\n+   it has allocated and the caller only needs to dereference the pointer.  */\n #define TYPE_RETURN_BY_DIRECT_REF_P(NODE) \\\n-  TYPE_LANG_FLAG_0 (FUNCTION_TYPE_CHECK (NODE))\n+  TYPE_LANG_FLAG_0 (FUNC_OR_METHOD_CHECK (NODE))\n \n /* For INTEGER_TYPE, nonzero if this is a modular type with a modulus that\n    is not equal to two to the power of its mode's size.  */\n@@ -97,10 +97,10 @@ do {\t\t\t\t\t\t\t \\\n    an Ada array other than the first.  */\n #define TYPE_MULTI_ARRAY_P(NODE) TYPE_LANG_FLAG_1 (ARRAY_TYPE_CHECK (NODE))\n \n-/* For FUNCTION_TYPE, nonzero if this denotes a function returning an\n-   unconstrained array or record.  */\n+/* For FUNCTION_TYPE and METHOD_TYPE, nonzero if function returns an\n+   unconstrained array or record type.  */\n #define TYPE_RETURN_UNCONSTRAINED_P(NODE) \\\n-  TYPE_LANG_FLAG_1 (FUNCTION_TYPE_CHECK (NODE))\n+  TYPE_LANG_FLAG_1 (FUNC_OR_METHOD_CHECK (NODE))\n \n /* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this denotes\n    a justified modular type (will only be true for RECORD_TYPE).  */\n@@ -228,12 +228,11 @@ do {\t\t\t\t\t\t\t \\\n #define TYPE_GCC_MAX_VALUE(NODE) \\\n   (TYPE_MAX_VALUE_RAW (NUMERICAL_TYPE_CHECK (NODE)))\n \n-/* For a FUNCTION_TYPE, if the subprogram has parameters passed by copy in/\n-   copy out, this is the list of nodes used to specify the return values of\n-   the out (or in out) parameters that are passed by copy in/copy out.  For\n-   a full description of the copy in/copy out parameter passing mechanism\n-   refer to the routine gnat_to_gnu_entity.  */\n-#define TYPE_CI_CO_LIST(NODE) TYPE_LANG_SLOT_1 (FUNCTION_TYPE_CHECK (NODE))\n+/* For a FUNCTION_TYPE and METHOD_TYPE, if the function has parameters passed\n+   by copy in/copy out, this is the list of nodes used to specify the return\n+   values of these parameters.  For a full description of the copy in/copy out\n+   parameter passing mechanism refer to the routine gnat_to_gnu_entity.  */\n+#define TYPE_CI_CO_LIST(NODE) TYPE_LANG_SLOT_1 (FUNC_OR_METHOD_CHECK (NODE))\n \n /* For an ARRAY_TYPE with variable size, this is the padding type built for\n    the array type when it is itself the component type of another array.  */"}, {"sha": "123fefb3131ca822533914882f6360511abbb799", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 63, "deletions": 25, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69720717c143a9dc77d4c52dd5e2f19858425fa8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69720717c143a9dc77d4c52dd5e2f19858425fa8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=69720717c143a9dc77d4c52dd5e2f19858425fa8", "patch": "@@ -52,23 +52,19 @@\n #include \"ada-tree.h\"\n #include \"gigi.h\"\n \n-/* \"stdcall\" and \"thiscall\" conventions should be processed in a specific way\n-   on 32-bit x86/Windows only.  The macros below are helpers to avoid having\n-   to check for a Windows specific attribute throughout this unit.  */\n+/* The \"stdcall\" convention is really supported on 32-bit x86/Windows only.\n+   The following macro is a helper to avoid having to check for a Windows\n+   specific attribute throughout this unit.  */\n \n #if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n #ifdef TARGET_64BIT\n #define Has_Stdcall_Convention(E) \\\n   (!TARGET_64BIT && Convention (E) == Convention_Stdcall)\n-#define Has_Thiscall_Convention(E) \\\n-  (!TARGET_64BIT && is_cplusplus_method (E))\n #else\n #define Has_Stdcall_Convention(E) (Convention (E) == Convention_Stdcall)\n-#define Has_Thiscall_Convention(E) (is_cplusplus_method (E))\n #endif\n #else\n #define Has_Stdcall_Convention(E) 0\n-#define Has_Thiscall_Convention(E) 0\n #endif\n \n #define STDCALL_PREFIX \"_imp__\"\n@@ -3983,11 +3979,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n \t     get_identifier (\"stdcall\"), NULL_TREE,\n \t     gnat_entity);\n-\telse if (Has_Thiscall_Convention (gnat_entity))\n-\t  prepend_one_attribute\n-\t    (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n-\t     get_identifier (\"thiscall\"), NULL_TREE,\n-\t     gnat_entity);\n \n \t/* If we should request stack realignment for a foreign convention\n \t   subprogram, do so.  Note that this applies to task entry points\n@@ -4841,11 +4832,12 @@ get_unpadded_type (Entity_Id gnat_entity)\n /* Return whether the E_Subprogram_Type/E_Function/E_Procedure GNAT_ENTITY is\n    a C++ imported method or equivalent.\n \n-   We use the predicate on 32-bit x86/Windows to find out whether we need to\n-   use the \"thiscall\" calling convention for GNAT_ENTITY.  This convention is\n-   used for C++ methods (functions with METHOD_TYPE) by the back-end.  */\n+   We use the predicate to find out whether we need to use METHOD_TYPE instead\n+   of FUNCTION_TYPE for GNAT_ENTITY for the sake compatibility with C++.  This\n+   in turn determines whether the \"thiscall\" calling convention is used by the\n+   back-end for GNAT_ENTITY on 32-bit x86/Windows.  */\n \n-bool\n+static bool\n is_cplusplus_method (Entity_Id gnat_entity)\n {\n   /* A constructor is a method on the C++ side.  We deal with it now because\n@@ -5258,6 +5250,14 @@ gnat_to_gnu_param (Entity_Id gnat_param, tree gnu_param_type, bool first,\n     gnu_param_type\n       = make_type_from_size (gnu_param_type, size_int (POINTER_SIZE), 0);\n \n+  /* Use a pointer type for the \"this\" pointer of C++ constructors.  */\n+  else if (Chars (gnat_param) == Name_uInit && Is_Constructor (gnat_subprog))\n+    {\n+      gcc_assert (mech == By_Reference);\n+      gnu_param_type = build_pointer_type (gnu_param_type);\n+      by_ref = true;\n+    }\n+\n   /* If we were requested or muss pass by reference, do so.\n      If we were requested to pass by copy, do so.\n      Otherwise, for foreign conventions, pass In Out or Out parameters\n@@ -5557,6 +5557,7 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t\t\t  bool debug_info_p, tree *param_list)\n {\n   const Entity_Kind kind = Ekind (gnat_subprog);\n+  const bool method_p = is_cplusplus_method (gnat_subprog);\n   Entity_Id gnat_return_type = Etype (gnat_subprog);\n   Entity_Id gnat_param;\n   tree gnu_type = present_gnu_tree (gnat_subprog)\n@@ -5598,7 +5599,7 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n     gnu_return_type = void_type_node;\n \n   else if (gnu_type\n-\t   && TREE_CODE (gnu_type) == FUNCTION_TYPE\n+\t   && FUNC_OR_METHOD_TYPE_P (gnu_type)\n \t   && !TYPE_IS_DUMMY_P (TREE_TYPE (gnu_type)))\n     {\n       gnu_return_type = TREE_TYPE (gnu_type);\n@@ -5743,7 +5744,7 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n      Similarly, if the function returns an unconstrained type, then the\n      function will allocate the return value on the secondary stack and\n      thus calls to it cannot be CSE'ed, lest the stack be reclaimed.  */\n-  if (TREE_CODE (gnu_return_type) == VOID_TYPE || return_unconstrained_p)\n+  if (VOID_TYPE_P (gnu_return_type) || return_unconstrained_p)\n     const_flag = false;\n \n   /* Loop over the parameters and get their associated GCC tree.  While doing\n@@ -5862,7 +5863,8 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t{\n \t  gnu_param_type_list\n \t    = tree_cons (NULL_TREE, gnu_param_type, gnu_param_type_list);\n-\t  gnu_param_list = chainon (gnu_param, gnu_param_list);\n+\t  DECL_CHAIN (gnu_param) = gnu_param_list;\n+\t  gnu_param_list = gnu_param;\n \t  save_gnu_tree (gnat_param, gnu_param, false);\n \n \t  /* A pure function in the Ada sense which takes an access parameter\n@@ -5975,18 +5977,37 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n   /* The lists have been built in reverse.  */\n   gnu_param_type_list = nreverse (gnu_param_type_list);\n   gnu_param_type_list = chainon (gnu_param_type_list, void_list_node);\n-  *param_list = nreverse (gnu_param_list);\n+  gnu_param_list = nreverse (gnu_param_list);\n   gnu_cico_list = nreverse (gnu_cico_list);\n \n+  /* Turn imported C++ constructors into their callable form as done in the\n+     front-end, i.e. add the \"this\" pointer and void the return type.  */\n+  if (method_p\n+      && Is_Constructor (gnat_subprog)\n+      && !VOID_TYPE_P (gnu_return_type))\n+    {\n+      tree gnu_param_type\n+\t= build_pointer_type (gnat_to_gnu_profile_type (gnat_return_type));\n+      tree gnu_param_name = get_identifier (Get_Name_String (Name_uInit));\n+      tree gnu_param\n+\t= build_decl (input_location, PARM_DECL, gnu_param_name,\n+\t\t      gnu_param_type);\n+      gnu_param_type_list\n+\t= tree_cons (NULL_TREE, gnu_param_type, gnu_param_type_list);\n+      DECL_CHAIN (gnu_param) = gnu_param_list;\n+      gnu_param_list = gnu_param;\n+      gnu_return_type = void_type_node;\n+    }\n+\n   /* If the profile is incomplete, we only set the (temporary) return and\n      parameter types; otherwise, we build the full type.  In either case,\n      we reuse an already existing GCC tree that we built previously here.  */\n   if (incomplete_profile_p)\n     {\n-      if (gnu_type && TREE_CODE (gnu_type) == FUNCTION_TYPE)\n+      if (gnu_type && FUNC_OR_METHOD_TYPE_P (gnu_type))\n \t;\n       else\n-\tgnu_type = make_node (FUNCTION_TYPE);\n+\tgnu_type = make_node (method_p ? METHOD_TYPE : FUNCTION_TYPE);\n       TREE_TYPE (gnu_type) = gnu_return_type;\n       TYPE_ARG_TYPES (gnu_type) = gnu_param_type_list;\n       TYPE_RETURN_UNCONSTRAINED_P (gnu_type) = return_unconstrained_p;\n@@ -5995,10 +6016,16 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n     }\n   else\n     {\n-      if (gnu_type && TREE_CODE (gnu_type) == FUNCTION_TYPE)\n+      if (gnu_type && FUNC_OR_METHOD_TYPE_P (gnu_type))\n \t{\n \t  TREE_TYPE (gnu_type) = gnu_return_type;\n \t  TYPE_ARG_TYPES (gnu_type) = gnu_param_type_list;\n+\t  if (method_p)\n+\t    {\n+\t      tree gnu_basetype = TREE_TYPE (TREE_VALUE (gnu_param_type_list));\n+\t      TYPE_METHOD_BASETYPE (gnu_type)\n+\t\t= TYPE_MAIN_VARIANT (gnu_basetype);\n+\t    }\n \t  TYPE_CI_CO_LIST (gnu_type) = gnu_cico_list;\n \t  TYPE_RETURN_UNCONSTRAINED_P (gnu_type) = return_unconstrained_p;\n \t  TYPE_RETURN_BY_DIRECT_REF_P (gnu_type) = return_by_direct_ref_p;\n@@ -6008,8 +6035,16 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t}\n       else\n \t{\n-\t  gnu_type\n-\t    = build_function_type (gnu_return_type, gnu_param_type_list);\n+\t  if (method_p)\n+\t    {\n+\t      tree gnu_basetype = TREE_TYPE (TREE_VALUE (gnu_param_type_list));\n+\t      gnu_type\n+\t\t= build_method_type_directly (gnu_basetype, gnu_return_type,\n+\t\t\t\t\t      TREE_CHAIN (gnu_param_type_list));\n+\t    }\n+\t  else\n+\t    gnu_type\n+\t      = build_function_type (gnu_return_type, gnu_param_type_list);\n \n \t  /* GNU_TYPE may be shared since GCC hashes types.  Unshare it if it\n \t     has a different TYPE_CI_CO_LIST or flags.  */\n@@ -6070,6 +6105,8 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t}\n     }\n \n+  *param_list = gnu_param_list;\n+\n   return gnu_type;\n }\n \n@@ -9857,6 +9894,7 @@ substitute_in_type (tree t, tree f, tree r)\n       return build_complex_type (nt);\n \n     case FUNCTION_TYPE:\n+    case METHOD_TYPE:\n       /* These should never show up here.  */\n       gcc_unreachable ();\n "}, {"sha": "a75cb90944919e1f962834b2e143eba0b05f326f", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69720717c143a9dc77d4c52dd5e2f19858425fa8/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69720717c143a9dc77d4c52dd5e2f19858425fa8/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=69720717c143a9dc77d4c52dd5e2f19858425fa8", "patch": "@@ -110,10 +110,6 @@ extern void elaborate_entity (Entity_Id gnat_entity);\n /* Get the unpadded version of a GNAT type.  */\n extern tree get_unpadded_type (Entity_Id gnat_entity);\n \n-/* Return whether the E_Subprogram_Type/E_Function/E_Procedure GNAT_ENTITY is\n-   a C++ imported method or equivalent.  */\n-extern bool is_cplusplus_method (Entity_Id gnat_entity);\n-\n /* Create a record type that contains a SIZE bytes long field of TYPE with a\n     starting bit position so that it is aligned to ALIGN bits, and leaving at\n     least ROOM bytes free before the field.  BASE_ALIGN is the alignment the\n@@ -548,7 +544,7 @@ extern int gnat_types_compatible_p (tree t1, tree t2);\n /* Return true if EXPR is a useless type conversion.  */\n extern bool gnat_useless_type_conversion (tree expr);\n \n-/* Return true if T, a FUNCTION_TYPE, has the specified list of flags.  */\n+/* Return true if T, a {FUNCTION,METHOD}_TYPE, has the specified flags.  */\n extern bool fntype_same_flags_p (const_tree, tree, bool, bool, bool);\n \n /* Create an expression whose value is that of EXPR,"}, {"sha": "05bbf2e841a6d922226b6d95c93155d4c9efa9ca", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69720717c143a9dc77d4c52dd5e2f19858425fa8/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69720717c143a9dc77d4c52dd5e2f19858425fa8/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=69720717c143a9dc77d4c52dd5e2f19858425fa8", "patch": "@@ -473,6 +473,7 @@ gnat_print_type (FILE *file, tree node, int indent)\n   switch (TREE_CODE (node))\n     {\n     case FUNCTION_TYPE:\n+    case METHOD_TYPE:\n       print_node (file, \"ci/co list\", TYPE_CI_CO_LIST (node), indent + 4);\n       break;\n \n@@ -684,12 +685,12 @@ gnat_get_fixed_point_type_info (const_tree type,\n \n /* Return true if types T1 and T2 are identical for type hashing purposes.\n    Called only after doing all language independent checks.  At present,\n-   this function is only called when both types are FUNCTION_TYPE.  */\n+   this is only called when both types are FUNCTION_TYPE or METHOD_TYPE.  */\n \n static bool\n gnat_type_hash_eq (const_tree t1, const_tree t2)\n {\n-  gcc_assert (TREE_CODE (t1) == FUNCTION_TYPE);\n+  gcc_assert (FUNC_OR_METHOD_TYPE_P (t1) && TREE_CODE (t1) == TREE_CODE (t2));\n   return fntype_same_flags_p (t1, TYPE_CI_CO_LIST (t2),\n \t\t\t      TYPE_RETURN_UNCONSTRAINED_P (t2),\n \t\t\t      TYPE_RETURN_BY_DIRECT_REF_P (t2),"}, {"sha": "31e098a0c707a60e8b244dbc8cc295dd27ff4657", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69720717c143a9dc77d4c52dd5e2f19858425fa8/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69720717c143a9dc77d4c52dd5e2f19858425fa8/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=69720717c143a9dc77d4c52dd5e2f19858425fa8", "patch": "@@ -1226,7 +1226,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n      of a discriminated type whose full view can be elaborated statically, to\n      avoid problematic conversions to the nominal subtype.  But remove any\n      padding from the resulting type.  */\n-  if (TREE_CODE (TREE_TYPE (gnu_result)) == FUNCTION_TYPE\n+  if (FUNC_OR_METHOD_TYPE_P (TREE_TYPE (gnu_result))\n       || Is_Constr_Subt_For_UN_Aliased (gnat_temp_type)\n       || (Ekind (gnat_temp) == E_Constant\n \t  && Present (Full_View (gnat_temp))\n@@ -1730,15 +1730,14 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t since it can use a special calling convention on some platforms,\n \t which cannot be propagated to the access type.  */\n       else if (attribute == Attr_Access\n-\t       && Nkind (gnat_prefix) == N_Identifier\n-\t       && is_cplusplus_method (Entity (gnat_prefix)))\n+\t       && TREE_CODE (TREE_TYPE (gnu_prefix)) == METHOD_TYPE)\n \tpost_error (\"access to C++ constructor or member function not allowed\",\n \t\t    gnat_node);\n \n       /* For other address attributes applied to a nested function,\n \t find an inner ADDR_EXPR and annotate it so that we can issue\n \t a useful warning with -Wtrampolines.  */\n-      else if (TREE_CODE (TREE_TYPE (gnu_prefix)) == FUNCTION_TYPE)\n+      else if (FUNC_OR_METHOD_TYPE_P (TREE_TYPE (gnu_prefix)))\n \t{\n \t  gnu_expr = remove_conversions (gnu_result, false);\n \n@@ -4283,7 +4282,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n   Node_Id gnat_actual;\n   bool sync;\n \n-  gcc_assert (TREE_CODE (gnu_subprog_type) == FUNCTION_TYPE);\n+  gcc_assert (FUNC_OR_METHOD_TYPE_P (gnu_subprog_type));\n \n   /* If we are calling a stubbed function, raise Program_Error, but Elaborate\n      all our args first.  */\n@@ -8743,7 +8742,7 @@ process_freeze_entity (Node_Id gnat_node)\n   if (gnu_old\n       && ((TREE_CODE (gnu_old) == FUNCTION_DECL\n \t   && (kind == E_Function || kind == E_Procedure))\n-\t  || (TREE_CODE (TREE_TYPE (gnu_old)) == FUNCTION_TYPE\n+\t  || (FUNC_OR_METHOD_TYPE_P (TREE_TYPE (gnu_old))\n \t      && kind == E_Subprogram_Type)))\n     return;\n "}, {"sha": "a162069b46c50674ca574e77dfc4b357424399be", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69720717c143a9dc77d4c52dd5e2f19858425fa8/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69720717c143a9dc77d4c52dd5e2f19858425fa8/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=69720717c143a9dc77d4c52dd5e2f19858425fa8", "patch": "@@ -3191,9 +3191,9 @@ create_label_decl (tree name, Node_Id gnat_node)\n }\n \f\n /* Return a FUNCTION_DECL node.  NAME is the name of the subprogram, ASM_NAME\n-   its assembler name, TYPE its type (a FUNCTION_TYPE node), PARAM_DECL_LIST\n-   the list of its parameters (a list of PARM_DECL nodes chained through the\n-   DECL_CHAIN field).\n+   its assembler name, TYPE its type (a FUNCTION_TYPE or METHOD_TYPE node),\n+   PARAM_DECL_LIST the list of its parameters (a list of PARM_DECL nodes\n+   chained through the DECL_CHAIN field).\n \n    INLINE_STATUS describes the inline flags to be set on the FUNCTION_DECL.\n \n@@ -3589,7 +3589,7 @@ gnat_useless_type_conversion (tree expr)\n   return false;\n }\n \n-/* Return true if T, a FUNCTION_TYPE, has the specified list of flags.  */\n+/* Return true if T, a {FUNCTION,METHOD}_TYPE, has the specified flags.  */\n \n bool\n fntype_same_flags_p (const_tree t, tree cico_list, bool return_unconstrained_p,"}]}