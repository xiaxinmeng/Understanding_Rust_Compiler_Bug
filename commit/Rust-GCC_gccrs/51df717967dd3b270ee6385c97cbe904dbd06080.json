{"sha": "51df717967dd3b270ee6385c97cbe904dbd06080", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFkZjcxNzk2N2RkM2IyNzBlZTYzODVjOTdjYmU5MDRkYmQwNjA4MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-25T18:43:59Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-25T18:43:59Z"}, "message": "re PR target/19556 (ICE  with -march=pentium-m (during bootstrap))\n\n        PR target/19556\n        PR target/19584\n        * config/i386/i386.c (x86_inter_unit_moves): Zero.\n        (ix86_preferred_reload_class): Rewrite fp-constant section, with\n        80387 enabled, to return a proper subclass.  Return the subset that\n        overlaps with GENERAL_REGS for PLUS.\n        * config/i386/i386.md (movsi_1, movdi_2): Set type to \"mmx\" for pxor.\n\nFrom-SVN: r94223", "tree": {"sha": "48c7dc3151bb7c95314d2dfba39408fa601cfba6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48c7dc3151bb7c95314d2dfba39408fa601cfba6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51df717967dd3b270ee6385c97cbe904dbd06080", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51df717967dd3b270ee6385c97cbe904dbd06080", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51df717967dd3b270ee6385c97cbe904dbd06080", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51df717967dd3b270ee6385c97cbe904dbd06080/comments", "author": null, "committer": null, "parents": [{"sha": "c63f5a428cc7b15651e076b291e1a72c36d74618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c63f5a428cc7b15651e076b291e1a72c36d74618", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c63f5a428cc7b15651e076b291e1a72c36d74618"}], "stats": {"total": 93, "additions": 68, "deletions": 25}, "files": [{"sha": "d659cdb2ffd9efb738fa781ddc6e1a10596fb20d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51df717967dd3b270ee6385c97cbe904dbd06080/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51df717967dd3b270ee6385c97cbe904dbd06080/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51df717967dd3b270ee6385c97cbe904dbd06080", "patch": "@@ -1,3 +1,13 @@\n+2005-01-25  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/19556\n+\tPR target/19584\n+\t* config/i386/i386.c (x86_inter_unit_moves): Zero.\n+\t(ix86_preferred_reload_class): Rewrite fp-constant section, with\n+\t80387 enabled, to return a proper subclass.  Return the subset that\n+\toverlaps with GENERAL_REGS for PLUS.\n+\t* config/i386/i386.md (movsi_1, movdi_2): Set type to \"mmx\" for pxor.\n+\n 2005-01-25  Richard Henderson  <rth@redhat.com>\n \n \tPR middle-end/19609"}, {"sha": "d9c18d05a307eb4acc879202efc902968567b8d4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 55, "deletions": 22, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51df717967dd3b270ee6385c97cbe904dbd06080/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51df717967dd3b270ee6385c97cbe904dbd06080/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=51df717967dd3b270ee6385c97cbe904dbd06080", "patch": "@@ -571,7 +571,11 @@ const int x86_sse_typeless_stores = m_ATHLON_K8;\n const int x86_sse_load0_by_pxor = m_PPRO | m_PENT4 | m_NOCONA;\n const int x86_use_ffreep = m_ATHLON_K8;\n const int x86_rep_movl_optimal = m_386 | m_PENT | m_PPRO | m_K6;\n-const int x86_inter_unit_moves = ~(m_ATHLON_K8);\n+\n+/* ??? Allowing interunit moves makes it all too easy for the compiler to put\n+   integer data in xmm registers.  Which results in pretty abysmal code.  */\n+const int x86_inter_unit_moves = 0 /* ~(m_ATHLON_K8) */;\n+\n const int x86_ext_80387_constants = m_K6 | m_ATHLON | m_PENT4 | m_NOCONA | m_PPRO;\n /* Some CPU cores are not able to predict more than 4 branch instructions in\n    the 16 byte window.  */\n@@ -14666,36 +14670,65 @@ ix86_free_from_memory (enum machine_mode mode)\n enum reg_class\n ix86_preferred_reload_class (rtx x, enum reg_class class)\n {\n+  /* We're only allowed to return a subclass of CLASS.  Many of the \n+     following checks fail for NO_REGS, so eliminate that early.  */\n   if (class == NO_REGS)\n     return NO_REGS;\n-  if (GET_CODE (x) == CONST_VECTOR && x != CONST0_RTX (GET_MODE (x)))\n-    return NO_REGS;\n+\n+  /* All classes can load zeros.  */\n+  if (x == CONST0_RTX (GET_MODE (x)))\n+    return class;\n+\n+  /* Floating-point constants need more complex checks.  */\n   if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) != VOIDmode)\n     {\n-      /* SSE can't load any constant directly yet.  */\n-      if (SSE_CLASS_P (class))\n-\treturn NO_REGS;\n-      /* Floats can load 0 and 1.  */\n-      if (MAYBE_FLOAT_CLASS_P (class) && standard_80387_constant_p (x))\n-\t{\n-\t  /* Limit class to non-SSE.  Use GENERAL_REGS if possible.  */\n-\t  if (MAYBE_SSE_CLASS_P (class))\n-\t    return (reg_class_subset_p (class, GENERAL_REGS)\n-\t\t    ? GENERAL_REGS : FLOAT_REGS);\n-\t  else\n-\t    return class;\n-\t}\n       /* General regs can load everything.  */\n       if (reg_class_subset_p (class, GENERAL_REGS))\n-\treturn class;\n-      /* In case we haven't resolved FLOAT or SSE yet, give up.  */\n-      if (MAYBE_FLOAT_CLASS_P (class) || MAYBE_SSE_CLASS_P (class))\n-\treturn NO_REGS;\n+        return class;\n+\n+      /* Floats can load 0 and 1 plus some others.  Note that we eliminated\n+\t zero above.  We only want to wind up preferring 80387 registers if\n+\t we plan on doing computation with them.  */\n+      if (TARGET_80387\n+\t  && (TARGET_MIX_SSE_I387 \n+\t      || !(TARGET_SSE_MATH && SSE_FLOAT_MODE_P (GET_MODE (x))))\n+\t  && standard_80387_constant_p (x))\n+\t{\n+\t  /* Limit class to non-sse.  */\n+\t  if (class == FLOAT_SSE_REGS)\n+\t    return FLOAT_REGS;\n+\t  if (class == FP_TOP_SSE_REGS)\n+\t    return FP_TOP_REG;\n+\t  if (class == FP_SECOND_SSE_REGS)\n+\t    return FP_SECOND_REG;\n+\t  if (class == FLOAT_INT_REGS || class == FLOAT_REGS)\n+\t    return class;\n+\t}\n+\n+      return NO_REGS;\n     }\n   if (MAYBE_MMX_CLASS_P (class) && CONSTANT_P (x))\n     return NO_REGS;\n-  if (GET_MODE (x) == QImode && ! reg_class_subset_p (class, Q_REGS))\n-    return Q_REGS;\n+  if (MAYBE_SSE_CLASS_P (class) && CONSTANT_P (x))\n+    return NO_REGS;\n+\n+  /* Generally when we see PLUS here, it's the function invariant\n+     (plus soft-fp const_int).  Which can only be computed into general\n+     regs.  */\n+  if (GET_CODE (x) == PLUS)\n+    return reg_class_subset_p (class, GENERAL_REGS) ? class : NO_REGS;\n+\n+  /* QImode constants are easy to load, but non-constant QImode data\n+     must go into Q_REGS.  */\n+  if (GET_MODE (x) == QImode && !CONSTANT_P (x))\n+    {\n+      if (reg_class_subset_p (class, Q_REGS))\n+\treturn class;\n+      if (reg_class_subset_p (Q_REGS, class))\n+\treturn Q_REGS;\n+      return NO_REGS;\n+    }\n+\n   return class;\n }\n "}, {"sha": "1a07002c768013f817ef0fdd43d6a77539f3e92b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51df717967dd3b270ee6385c97cbe904dbd06080/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51df717967dd3b270ee6385c97cbe904dbd06080/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=51df717967dd3b270ee6385c97cbe904dbd06080", "patch": "@@ -1172,7 +1172,7 @@\n }\n   [(set (attr \"type\")\n      (cond [(eq_attr \"alternative\" \"2\")\n-\t      (const_string \"mmxadd\")\n+\t      (const_string \"mmx\")\n \t    (eq_attr \"alternative\" \"3,4,5\")\n \t      (const_string \"mmxmov\")\n \t    (eq_attr \"alternative\" \"6\")\n@@ -1913,7 +1913,7 @@\n    movlps\\t{%1, %0|%0, %1}\n    movaps\\t{%1, %0|%0, %1}\n    movlps\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"*,*,mmxadd,mmxmov,mmxmov,sselog1,ssemov,ssemov,ssemov,sselog1,ssemov,ssemov,ssemov\")\n+  [(set_attr \"type\" \"*,*,mmx,mmxmov,mmxmov,sselog1,ssemov,ssemov,ssemov,sselog1,ssemov,ssemov,ssemov\")\n    (set_attr \"mode\" \"DI,DI,DI,DI,DI,TI,DI,TI,DI,V4SF,V2SF,V4SF,V2SF\")])\n \n (define_split\n@@ -1978,7 +1978,7 @@\n }\n   [(set (attr \"type\")\n      (cond [(eq_attr \"alternative\" \"5\")\n-\t      (const_string \"mmxadd\")\n+\t      (const_string \"mmx\")\n \t    (eq_attr \"alternative\" \"6,7,8\")\n \t      (const_string \"mmxmov\")\n \t    (eq_attr \"alternative\" \"9\")"}]}