{"sha": "9969aaf67e4c806bc58a5b110f6a0849365eee05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk2OWFhZjY3ZTRjODA2YmM1OGE1YjExMGY2YTA4NDkzNjVlZWUwNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-09-02T06:47:01Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-09-02T06:47:01Z"}, "message": "re PR middle-end/17258 (gcc.c-torture/compile/20030224-1.c:16: internal compiler error: in expand_expr_addr_expr, at expr.c:6157)\n\n        PR middle-end/17258\n        * calls.c (initialize_argument_information): Tighten pass-through\n        conditions for pass-by-reference.  Remove dead TARGET_EXPR code.\n        Use build_fold_addr_expr.\n        (emit_library_call_value_1): Use build_fold_addr_expr.  Remove code\n        that assumes ADDR_EXPR allocates stack space.\n        * fold-const.c (build_fold_addr_expr_with_type): Look through\n        WITH_SIZE_EXPR.\n\nFrom-SVN: r86957", "tree": {"sha": "92274b998af0cc6f86fd45d1b53bb9d1eef8bed0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92274b998af0cc6f86fd45d1b53bb9d1eef8bed0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9969aaf67e4c806bc58a5b110f6a0849365eee05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9969aaf67e4c806bc58a5b110f6a0849365eee05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9969aaf67e4c806bc58a5b110f6a0849365eee05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9969aaf67e4c806bc58a5b110f6a0849365eee05/comments", "author": null, "committer": null, "parents": [{"sha": "57579172585eae4fd6f57c0dbd55ea998ddfb63f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57579172585eae4fd6f57c0dbd55ea998ddfb63f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57579172585eae4fd6f57c0dbd55ea998ddfb63f"}], "stats": {"total": 107, "additions": 45, "deletions": 62}, "files": [{"sha": "bc63754d38093e779c203b585d39e4d547ed3683", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9969aaf67e4c806bc58a5b110f6a0849365eee05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9969aaf67e4c806bc58a5b110f6a0849365eee05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9969aaf67e4c806bc58a5b110f6a0849365eee05", "patch": "@@ -1,3 +1,14 @@\n+2004-09-01  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/17258\n+\t* calls.c (initialize_argument_information): Tighten pass-through\n+\tconditions for pass-by-reference.  Remove dead TARGET_EXPR code.\n+\tUse build_fold_addr_expr.\n+\t(emit_library_call_value_1): Use build_fold_addr_expr.  Remove code\n+\tthat assumes ADDR_EXPR allocates stack space.\n+\t* fold-const.c (build_fold_addr_expr_with_type): Look through\n+\tWITH_SIZE_EXPR.\n+\n 2004-09-01  Dan Nicolaescu  <dann@ics.uci.edu>\n \n \t* gengenrtl.c (gendef): Use rtx_alloc, don't do PUT_CODE."}, {"sha": "e350a3fed14ac42f525f66b5e0cd00e46019d840", "filename": "gcc/calls.c", "status": "modified", "additions": 30, "deletions": 62, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9969aaf67e4c806bc58a5b110f6a0849365eee05/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9969aaf67e4c806bc58a5b110f6a0849365eee05/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=9969aaf67e4c806bc58a5b110f6a0849365eee05", "patch": "@@ -970,54 +970,30 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n       if (pass_by_reference (args_so_far, TYPE_MODE (type),\n \t\t\t     type, argpos < n_named_args))\n \t{\n-\t  /* If we're compiling a thunk, pass through invisible\n-             references instead of making a copy.  */\n+\t  bool callee_copies;\n+\t  tree base;\n+\n+\t  callee_copies\n+\t    = FUNCTION_ARG_CALLEE_COPIES (*args_so_far, TYPE_MODE (type),\n+\t\t\t\t\t  type, argpos < n_named_args);\n+\n+\t  /* If we're compiling a thunk, pass through invisible references\n+\t     instead of making a copy.  */\n \t  if (call_from_thunk_p\n-\t      || (FUNCTION_ARG_CALLEE_COPIES (*args_so_far, TYPE_MODE (type),\n-\t\t\t\t\t     type, argpos < n_named_args)\n-\t\t  /* If it's in a register, we must make a copy of it too.  */\n-\t\t  /* ??? Is this a sufficient test?  Is there a better one? */\n-\t\t  && !(TREE_CODE (args[i].tree_value) == VAR_DECL\n-\t\t       && REG_P (DECL_RTL (args[i].tree_value)))\n-\t\t  && ! TREE_ADDRESSABLE (type))\n-\t      )\n+\t      || (callee_copies\n+\t\t  && !TREE_ADDRESSABLE (type)\n+\t\t  && (base = get_base_address (args[i].tree_value))\n+\t\t  && (!DECL_P (base) || MEM_P (DECL_RTL (base)))))\n \t    {\n-\t      /* C++ uses a TARGET_EXPR to indicate that we want to make a\n-\t         new object from the argument.  If we are passing by\n-\t         invisible reference, the callee will do that for us, so we\n-\t         can strip off the TARGET_EXPR.  This is not always safe,\n-\t         but it is safe in the only case where this is a useful\n-\t         optimization; namely, when the argument is a plain object.\n-\t         In that case, the frontend is just asking the backend to\n-\t         make a bitwise copy of the argument.  */\n-\n-\t      if (TREE_CODE (args[i].tree_value) == TARGET_EXPR\n-\t\t  && (DECL_P (TREE_OPERAND (args[i].tree_value, 1)))\n-\t\t  && ! REG_P (DECL_RTL (TREE_OPERAND (args[i].tree_value, 1))))\n-\t\targs[i].tree_value = TREE_OPERAND (args[i].tree_value, 1);\n-\n-\t      /* We can't use sibcalls if a callee-copied argument is stored\n-\t\t in the current function's frame.  */\n-\t      if (!call_from_thunk_p\n-\t\t  && (!DECL_P (args[i].tree_value)\n-\t\t      || !TREE_STATIC (args[i].tree_value)))\n+\t      /* We can't use sibcalls if a callee-copied argument is\n+\t\t stored in the current function's frame.  */\n+\t      if (!call_from_thunk_p && DECL_P (base) && !TREE_STATIC (base))\n \t\t*may_tailcall = false;\n \n-\t      args[i].tree_value = build1 (ADDR_EXPR,\n-\t\t\t\t\t   build_pointer_type (type),\n-\t\t\t\t\t   args[i].tree_value);\n-\t      type = build_pointer_type (type);\n-\t    }\n-\t  else if (TREE_CODE (args[i].tree_value) == TARGET_EXPR)\n-\t    {\n-\t      /* In the V3 C++ ABI, parameters are destroyed in the caller.\n-\t\t We implement this by passing the address of the temporary\n-\t         rather than expanding it into another allocated slot.  */\n-\t      args[i].tree_value = build1 (ADDR_EXPR,\n-\t\t\t\t\t   build_pointer_type (type),\n-\t\t\t\t\t   args[i].tree_value);\n-\t      type = build_pointer_type (type);\n-\t      *may_tailcall = false;\n+\t      args[i].tree_value = build_fold_addr_expr (args[i].tree_value);\n+\t      type = TREE_TYPE (args[i].tree_value);\n+\n+\t      *ecf_flags &= ~(ECF_CONST | ECF_LIBCALL_BLOCK);\n \t    }\n \t  else\n \t    {\n@@ -1051,12 +1027,15 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t\tcopy = assign_temp (type, 0, 1, 0);\n \n \t      store_expr (args[i].tree_value, copy, 0);\n-\t      *ecf_flags &= ~(ECF_CONST | ECF_PURE | ECF_LIBCALL_BLOCK);\n \n-\t      args[i].tree_value = build1 (ADDR_EXPR,\n-\t\t\t\t\t   build_pointer_type (type),\n-\t\t\t\t\t   make_tree (type, copy));\n-\t      type = build_pointer_type (type);\n+\t      if (callee_copies)\n+\t\t*ecf_flags &= ~(ECF_CONST | ECF_LIBCALL_BLOCK);\n+\t      else\n+\t\t*ecf_flags &= ~(ECF_CONST | ECF_PURE | ECF_LIBCALL_BLOCK);\n+\n+\t      args[i].tree_value\n+\t\t= build_fold_addr_expr (make_tree (type, copy));\n+\t      type = TREE_TYPE (args[i].tree_value);\n \t      *may_tailcall = false;\n \t    }\n \t}\n@@ -3379,25 +3358,14 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t      flags |= ECF_PURE;\n \t    }\n \n-\t  if (GET_MODE (val) == MEM && ! must_copy)\n+\t  if (GET_MODE (val) == MEM && !must_copy)\n \t    slot = val;\n-\t  else if (must_copy)\n+\t  else\n \t    {\n \t      slot = assign_temp (lang_hooks.types.type_for_mode (mode, 0),\n \t\t\t\t  0, 1, 1);\n \t      emit_move_insn (slot, val);\n \t    }\n-\t  else\n-\t    {\n-\t      tree type = lang_hooks.types.type_for_mode (mode, 0);\n-\n-\t      slot\n-\t\t= gen_rtx_MEM (mode,\n-\t\t\t       expand_expr (build1 (ADDR_EXPR,\n-\t\t\t\t\t\t    build_pointer_type (type),\n-\t\t\t\t\t\t    make_tree (type, val)),\n-\t\t\t\t\t    NULL_RTX, VOIDmode, 0));\n-\t    }\n \n \t  call_fusage = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t\t   gen_rtx_USE (VOIDmode, slot),"}, {"sha": "d8c511a615ebf66ab4eb980dfab512b33cb69797", "filename": "gcc/fold-const.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9969aaf67e4c806bc58a5b110f6a0849365eee05/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9969aaf67e4c806bc58a5b110f6a0849365eee05/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=9969aaf67e4c806bc58a5b110f6a0849365eee05", "patch": "@@ -10446,6 +10446,10 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n tree\n build_fold_addr_expr_with_type (tree t, tree ptrtype)\n {\n+  /* The size of the object is not relevant when talking about its address.  */\n+  if (TREE_CODE (t) == WITH_SIZE_EXPR)\n+    t = TREE_OPERAND (t, 0);\n+\n   if (TREE_CODE (t) == INDIRECT_REF)\n     {\n       t = TREE_OPERAND (t, 0);"}]}