{"sha": "19235870adf79a3422aed017819c537f1d1375ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkyMzU4NzBhZGY3OWEzNDIyYWVkMDE3ODE5YzUzN2YxZDEzNzVhYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-02T14:23:52Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-02T14:23:52Z"}, "message": "New Language: Ada\n\nFrom-SVN: r45956", "tree": {"sha": "0509e847916fc00cfe5c311617e039600afa9622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0509e847916fc00cfe5c311617e039600afa9622"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19235870adf79a3422aed017819c537f1d1375ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19235870adf79a3422aed017819c537f1d1375ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19235870adf79a3422aed017819c537f1d1375ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19235870adf79a3422aed017819c537f1d1375ac/comments", "author": null, "committer": null, "parents": [{"sha": "38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38cbfe40a046b12a3d9bc56e6cf76d86c458ef39"}], "stats": {"total": 38371, "additions": 38371, "deletions": 0}, "files": [{"sha": "a4fa121ed1619ade83a8ad801fa805c5631663d3", "filename": "gcc/ada/par-ch10.adb", "status": "added", "additions": 1080, "deletions": 0, "changes": 1080, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,1080 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P A R . C H 1 0                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.115 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Style_Checks (All_Checks);\n+--  Turn off subprogram body ordering check. Subprograms are in order\n+--  by RM section rather than alphabetical\n+\n+with Fname;    use Fname;\n+with Fname.UF; use Fname.UF;\n+with Hostparm; use Hostparm;\n+with Uname;    use Uname;\n+\n+separate (Par)\n+package body Ch10 is\n+\n+   --  Local functions, used only in this chapter\n+\n+   function P_Context_Clause    return List_Id;\n+   function P_Subunit           return Node_Id;\n+\n+   function Set_Location return Source_Ptr;\n+   --  The current compilation unit starts with Token at Token_Ptr. This\n+   --  function determines the corresponding source location for the start\n+   --  of the unit, including any preceding comment lines.\n+\n+   procedure Unit_Display\n+     (Cunit      : Node_Id;\n+      Loc        : Source_Ptr;\n+      SR_Present : Boolean);\n+   --  This procedure is used to generate a line of output for the a unit in\n+   --  the source program. Cunit is the node for the compilation unit, and\n+   --  Loc is the source location for the start of the unit in the source\n+   --  file (which is not necessarily the Sloc of the Cunit node). This\n+   --  output is written to the standard output file for use by gnatchop.\n+\n+   procedure Unit_Location (Sind : Source_File_Index; Loc : Source_Ptr);\n+   --  This routine has the same calling sequence as Unit_Display, but\n+   --  it outputs only the line number and offset of the location, Loc,\n+   --  using Cunit to obtain the proper source file index.\n+\n+   -------------------------\n+   -- 10.1.1  Compilation --\n+   -------------------------\n+\n+   --  COMPILATION ::= {COMPILATION_UNIT}\n+\n+   --  There is no specific parsing routine for a compilation, since we only\n+   --  permit a single compilation in a source file, so there is no explicit\n+   --  occurrence of compilations as such (our representation of a compilation\n+   --  is a series of separate source files).\n+\n+   ------------------------------\n+   -- 10.1.1  Compilation unit --\n+   ------------------------------\n+\n+   --  COMPILATION_UNIT ::=\n+   --    CONTEXT_CLAUSE LIBRARY_ITEM\n+   --  | CONTEXT_CLAUSE SUBUNIT\n+\n+   --  LIBRARY_ITEM ::=\n+   --    private LIBRARY_UNIT_DECLARATION\n+   --  | LIBRARY_UNIT_BODY\n+   --  | [private] LIBRARY_UNIT_RENAMING_DECLARATION\n+\n+   --  LIBRARY_UNIT_DECLARATION ::=\n+   --    SUBPROGRAM_DECLARATION | PACKAGE_DECLARATION\n+   --  | GENERIC_DECLARATION    | GENERIC_INSTANTIATION\n+\n+   --  LIBRARY_UNIT_RENAMING_DECLARATION ::=\n+   --    PACKAGE_RENAMING_DECLARATION\n+   --  | GENERIC_RENAMING_DECLARATION\n+   --  | SUBPROGRAM_RENAMING_DECLARATION\n+\n+   --  LIBRARY_UNIT_BODY ::= SUBPROGRAM_BODY | PACKAGE_BODY\n+\n+   --  Error recovery: cannot raise Error_Resync. If an error occurs, tokens\n+   --  are skipped up to the next possible beginning of a compilation unit.\n+\n+   --  Note: if only configuration pragmas are found, Empty is returned\n+\n+   --  Note: in syntax-only mode, it is possible for P_Compilation_Unit\n+   --  to return strange things that are not really compilation units.\n+   --  This is done to help out gnatchop when it is faced with nonsense.\n+\n+   function P_Compilation_Unit return Node_Id is\n+      Scan_State         : Saved_Scan_State;\n+      Body_Node          : Node_Id;\n+      Specification_Node : Node_Id;\n+      Unit_Node          : Node_Id;\n+      Comp_Unit_Node     : Node_Id;\n+      Name_Node          : Node_Id;\n+      Item               : Node_Id;\n+      Private_Sloc       : Source_Ptr := No_Location;\n+      Config_Pragmas     : List_Id;\n+      P                  : Node_Id;\n+      SR_Present         : Boolean;\n+\n+      Cunit_Error_Flag   : Boolean := False;\n+      --  This flag is set True if we have to scan for a compilation unit\n+      --  token. It is used to ensure clean termination in such cases by\n+      --  not insisting on being at the end of file, and, in the sytax only\n+      --  case by not scanning for additional compilation units.\n+\n+      Cunit_Location : Source_Ptr;\n+      --  Location of unit for unit identification output (List_Unit option)\n+\n+   begin\n+      Num_Library_Units := Num_Library_Units + 1;\n+\n+      --  Set location of the compilation unit if unit list option set\n+      --  and we are in syntax check only mode\n+\n+      if List_Units and then Operating_Mode = Check_Syntax then\n+         Cunit_Location := Set_Location;\n+      else\n+         Cunit_Location := No_Location;\n+      end if;\n+\n+      --  Deal with initial pragmas\n+\n+      Config_Pragmas := No_List;\n+\n+      --  If we have an initial Source_Reference pragma, then remember\n+      --  the fact to generate an NR parameter in the output line.\n+\n+      SR_Present := False;\n+\n+      if Token = Tok_Pragma then\n+         Save_Scan_State (Scan_State);\n+         Item := P_Pragma;\n+\n+         if Item = Error\n+           or else Chars (Item) /= Name_Source_Reference\n+         then\n+            Restore_Scan_State (Scan_State);\n+\n+         else\n+            SR_Present := True;\n+\n+            --  If first unit, record the file name for gnatchop use\n+\n+            if Operating_Mode = Check_Syntax\n+              and then List_Units\n+              and then Num_Library_Units = 1\n+            then\n+               Write_Str (\"Source_Reference pragma for file \"\"\");\n+               Write_Name (Full_Ref_Name (Current_Source_File));\n+               Write_Char ('\"');\n+               Write_Eol;\n+            end if;\n+\n+            Config_Pragmas := New_List (Item);\n+         end if;\n+      end if;\n+\n+      --  Scan out any configuration pragmas\n+\n+      while Token = Tok_Pragma loop\n+         Save_Scan_State (Scan_State);\n+         Item := P_Pragma;\n+\n+         if Item = Error\n+           or else Chars (Item) > Last_Configuration_Pragma_Name\n+         then\n+            Restore_Scan_State (Scan_State);\n+            exit;\n+         end if;\n+\n+         if Config_Pragmas = No_List then\n+            Config_Pragmas := Empty_List;\n+\n+            if Operating_Mode = Check_Syntax and then List_Units then\n+               Write_Str (\"Configuration pragmas at\");\n+               Unit_Location (Current_Source_File, Cunit_Location);\n+               Write_Eol;\n+            end if;\n+         end if;\n+\n+         Append (Item, Config_Pragmas);\n+         Cunit_Location := Set_Location;\n+      end loop;\n+\n+      --  Establish compilation unit node and scan context items\n+\n+      Comp_Unit_Node := New_Node (N_Compilation_Unit, No_Location);\n+      Set_Cunit (Current_Source_Unit, Comp_Unit_Node);\n+      Set_Context_Items (Comp_Unit_Node, P_Context_Clause);\n+      Set_Aux_Decls_Node\n+        (Comp_Unit_Node, New_Node (N_Compilation_Unit_Aux, No_Location));\n+\n+      if Present (Config_Pragmas) then\n+\n+         --  Check for case of only configuration pragmas present\n+\n+         if Token = Tok_EOF\n+           and then Is_Empty_List (Context_Items (Comp_Unit_Node))\n+         then\n+            if Operating_Mode = Check_Syntax then\n+               return Empty;\n+\n+            else\n+               Item := First (Config_Pragmas);\n+               Error_Msg_N\n+                 (\"cannot compile configuration pragmas with gcc\", Item);\n+               Error_Msg_N\n+                 (\"use gnatchop -c to process configuration pragmas!\", Item);\n+               raise Unrecoverable_Error;\n+            end if;\n+\n+         --  Otherwise configuration pragmas are simply prepended to the\n+         --  context of the current unit.\n+\n+         else\n+            Append_List (Context_Items (Comp_Unit_Node), Config_Pragmas);\n+            Set_Context_Items (Comp_Unit_Node, Config_Pragmas);\n+         end if;\n+      end if;\n+\n+      --  Check for PRIVATE. Note that for the moment we allow this in\n+      --  Ada_83 mode, since we do not yet know if we are compiling a\n+      --  predefined unit, and if we are then it would be allowed anyway.\n+\n+      if Token = Tok_Private then\n+         Private_Sloc := Token_Ptr;\n+         Set_Keyword_Casing (Current_Source_File, Determine_Token_Casing);\n+         if Style_Check then Style.Check_Indentation; end if;\n+\n+         Save_Scan_State (Scan_State); -- at PRIVATE\n+         Scan; -- past PRIVATE\n+\n+         if Token = Tok_Separate then\n+            Error_Msg_SP (\"cannot have private subunits!\");\n+\n+         elsif Token = Tok_Package then\n+            Scan; -- past PACKAGE\n+\n+            if Token = Tok_Body then\n+               Restore_Scan_State (Scan_State); -- to PRIVATE\n+               Error_Msg_SC (\"cannot have private package body!\");\n+               Scan; -- ignore PRIVATE\n+\n+            else\n+               Restore_Scan_State (Scan_State); -- to PRIVATE\n+               Scan; -- past PRIVATE\n+               Set_Private_Present (Comp_Unit_Node, True);\n+            end if;\n+\n+         elsif Token = Tok_Procedure\n+           or else Token = Tok_Function\n+           or else Token = Tok_Generic\n+         then\n+            Set_Private_Present (Comp_Unit_Node, True);\n+         end if;\n+      end if;\n+\n+      --  Loop to find our way to a compilation unit token\n+\n+      loop\n+         exit when Token in Token_Class_Cunit and then Token /= Tok_With;\n+\n+         exit when Bad_Spelling_Of (Tok_Package)\n+           or else Bad_Spelling_Of (Tok_Function)\n+           or else Bad_Spelling_Of (Tok_Generic)\n+           or else Bad_Spelling_Of (Tok_Separate)\n+           or else Bad_Spelling_Of (Tok_Procedure);\n+\n+         --  Allow task and protected for nice error recovery purposes\n+\n+         exit when Token = Tok_Task\n+           or else Token = Tok_Protected;\n+\n+         if Token = Tok_With then\n+            Error_Msg_SC (\"misplaced WITH\");\n+            Append_List (P_Context_Clause, Context_Items (Comp_Unit_Node));\n+\n+         elsif Bad_Spelling_Of (Tok_With) then\n+            Append_List (P_Context_Clause, Context_Items (Comp_Unit_Node));\n+\n+         else\n+            Error_Msg_SC (\"compilation unit expected\");\n+            Cunit_Error_Flag := True;\n+            Resync_Cunit;\n+\n+            --  If we are at an end of file, then just quit, the above error\n+            --  message was complaint enough.\n+\n+            if Token = Tok_EOF then\n+               return Error;\n+            end if;\n+         end if;\n+      end loop;\n+\n+      --  We have a compilation unit token, so that's a reasonable choice for\n+      --  determining the standard casing convention used for keywords in case\n+      --  it hasn't already been done on seeing a WITH or PRIVATE.\n+\n+      Set_Keyword_Casing (Current_Source_File, Determine_Token_Casing);\n+      if Style_Check then Style.Check_Indentation; end if;\n+\n+      --  Remaining processing depends on particular type of compilation unit\n+\n+      if Token = Tok_Package then\n+\n+         --  A common error is to omit the body keyword after package. We can\n+         --  often diagnose this early on (before getting loads of errors from\n+         --  contained subprogram bodies), by knowing that that the file we\n+         --  are compiling has a name that requires a body to be found.\n+\n+         --  However, we do not do this check if we are operating in syntax\n+         --  checking only mode, because in that case there may be multiple\n+         --  units in the same file, and the file name is not a reliable guide.\n+\n+         Save_Scan_State (Scan_State);\n+         Scan; -- past Package keyword\n+\n+         if Token /= Tok_Body\n+           and then Operating_Mode /= Check_Syntax\n+           and then\n+             Get_Expected_Unit_Type\n+               (File_Name (Current_Source_File)) = Expect_Body\n+         then\n+            Error_Msg_BC (\"keyword BODY expected here [see file name]\");\n+            Restore_Scan_State (Scan_State);\n+            Set_Unit (Comp_Unit_Node, P_Package (Pf_Pbod));\n+         else\n+            Restore_Scan_State (Scan_State);\n+            Set_Unit (Comp_Unit_Node, P_Package (Pf_Decl_Gins_Pbod_Rnam));\n+         end if;\n+\n+      elsif Token = Tok_Generic then\n+         Set_Unit (Comp_Unit_Node, P_Generic);\n+\n+      elsif Token = Tok_Separate then\n+         Set_Unit (Comp_Unit_Node, P_Subunit);\n+\n+      elsif Token = Tok_Procedure\n+        or else Token = Tok_Function\n+      then\n+         Set_Unit (Comp_Unit_Node, P_Subprogram (Pf_Decl_Gins_Pbod_Rnam));\n+\n+         --  A little bit of an error recovery check here. If we just scanned\n+         --  a subprogram declaration (as indicated by an SIS entry being\n+         --  active), then if the following token is BEGIN or an identifier,\n+         --  or a token which can reasonably start a declaration but cannot\n+         --  start a compilation unit, then we assume that the semicolon in\n+         --  the declaration should have been IS.\n+\n+         if SIS_Entry_Active then\n+\n+            if Token = Tok_Begin\n+               or else Token = Tok_Identifier\n+               or else Token in Token_Class_Deckn\n+            then\n+               Push_Scope_Stack;\n+               Scope.Table (Scope.Last).Etyp := E_Name;\n+               Scope.Table (Scope.Last).Sloc := SIS_Sloc;\n+               Scope.Table (Scope.Last).Ecol := SIS_Ecol;\n+               Scope.Table (Scope.Last).Lreq := False;\n+               SIS_Entry_Active := False;\n+\n+               --  If we had a missing semicolon in the declaration, then\n+               --  change the message to from <missing \";\"> to <missing \"is\">\n+\n+               if SIS_Missing_Semicolon_Message /= No_Error_Msg then\n+                  Change_Error_Text     -- Replace: \"missing \"\";\"\" \"\n+                    (SIS_Missing_Semicolon_Message, \"missing IS\");\n+\n+               --  Otherwise we saved the semicolon position, so complain\n+\n+               else\n+                  Error_Msg (\"\"\";\"\" should be IS\", SIS_Semicolon_Sloc);\n+               end if;\n+\n+               Body_Node := Unit (Comp_Unit_Node);\n+               Specification_Node := Specification (Body_Node);\n+               Change_Node (Body_Node, N_Subprogram_Body);\n+               Set_Specification (Body_Node, Specification_Node);\n+               Parse_Decls_Begin_End (Body_Node);\n+               Set_Unit (Comp_Unit_Node, Body_Node);\n+            end if;\n+\n+         --  If we scanned a subprogram body, make sure we did not have private\n+\n+         elsif Private_Sloc /= No_Location\n+           and then Nkind (Unit (Comp_Unit_Node)) /= N_Function_Instantiation\n+           and then Nkind (Unit (Comp_Unit_Node)) /= N_Procedure_Instantiation\n+         then\n+            Error_Msg (\"cannot have private subprogram body\", Private_Sloc);\n+\n+         --  P_Subprogram can yield an abstract subprogram, but this cannot\n+         --  be a compilation unit. Treat as a subprogram declaration.\n+\n+         elsif\n+           Nkind (Unit (Comp_Unit_Node)) = N_Abstract_Subprogram_Declaration\n+         then\n+            Error_Msg_N\n+              (\"compilation unit cannot be abstract subprogram\",\n+                 Unit (Comp_Unit_Node));\n+\n+            Unit_Node :=\n+              New_Node (N_Subprogram_Declaration, Sloc (Comp_Unit_Node));\n+            Set_Specification (Unit_Node,\n+              Specification (Unit (Comp_Unit_Node)));\n+            Set_Unit (Comp_Unit_Node, Unit_Node);\n+         end if;\n+\n+      --  Otherwise we have TASK. This is not really an acceptable token,\n+      --  but we accept it to improve error recovery.\n+\n+      elsif Token = Tok_Task then\n+         Scan; -- Past TASK\n+\n+         if Token = Tok_Type then\n+            Error_Msg_SP\n+              (\"task type cannot be used as compilation unit\");\n+         else\n+            Error_Msg_SP\n+              (\"task declaration cannot be used as compilation unit\");\n+         end if;\n+\n+         --  If in check syntax mode, accept the task anyway. This is done\n+         --  particularly to improve the behavior of GNATCHOP in this case.\n+\n+         if Operating_Mode = Check_Syntax then\n+            Set_Unit (Comp_Unit_Node, P_Task);\n+\n+         --  If not in syntax only mode, treat this as horrible error\n+\n+         else\n+            Cunit_Error_Flag := True;\n+            return Error;\n+         end if;\n+\n+      else pragma Assert (Token = Tok_Protected);\n+         Scan; -- Past PROTECTED\n+\n+         if Token = Tok_Type then\n+            Error_Msg_SP\n+              (\"protected type cannot be used as compilation unit\");\n+         else\n+            Error_Msg_SP\n+              (\"protected declaration cannot be used as compilation unit\");\n+         end if;\n+\n+         --  If in check syntax mode, accept protected anyway. This is done\n+         --  particularly to improve the behavior of GNATCHOP in this case.\n+\n+         if Operating_Mode = Check_Syntax then\n+            Set_Unit (Comp_Unit_Node, P_Protected);\n+\n+         --  If not in syntax only mode, treat this as horrible error\n+\n+         else\n+            Cunit_Error_Flag := True;\n+            return Error;\n+         end if;\n+      end if;\n+\n+      --  Here is where locate the compilation unit entity. This is a little\n+      --  tricky, since it is buried in various places.\n+\n+      Unit_Node := Unit (Comp_Unit_Node);\n+\n+      --  Another error from which it is hard to recover\n+\n+      if Nkind (Unit_Node) = N_Subprogram_Body_Stub\n+        or else Nkind (Unit_Node) = N_Package_Body_Stub\n+      then\n+         Cunit_Error_Flag := True;\n+         return Error;\n+      end if;\n+\n+      --  Only try this if we got an OK unit!\n+\n+      if Unit_Node /= Error then\n+         if Nkind (Unit_Node) = N_Subunit then\n+            Unit_Node := Proper_Body (Unit_Node);\n+         end if;\n+\n+         if Nkind (Unit_Node) in N_Generic_Declaration then\n+            Unit_Node := Specification (Unit_Node);\n+         end if;\n+\n+         if Nkind (Unit_Node) = N_Package_Declaration\n+           or else Nkind (Unit_Node) = N_Subprogram_Declaration\n+           or else Nkind (Unit_Node) = N_Subprogram_Body\n+           or else Nkind (Unit_Node) = N_Subprogram_Renaming_Declaration\n+         then\n+            Unit_Node := Specification (Unit_Node);\n+\n+         elsif Nkind (Unit_Node) = N_Subprogram_Renaming_Declaration then\n+            if Ada_83 then\n+               Error_Msg_N\n+                 (\"(Ada 83) library unit renaming not allowed\", Unit_Node);\n+            end if;\n+         end if;\n+\n+         if Nkind (Unit_Node) = N_Task_Body\n+           or else Nkind (Unit_Node) = N_Protected_Body\n+           or else Nkind (Unit_Node) = N_Task_Type_Declaration\n+           or else Nkind (Unit_Node) = N_Protected_Type_Declaration\n+           or else Nkind (Unit_Node) = N_Single_Task_Declaration\n+           or else Nkind (Unit_Node) = N_Single_Protected_Declaration\n+         then\n+            Name_Node := Defining_Identifier (Unit_Node);\n+         else\n+            Name_Node := Defining_Unit_Name (Unit_Node);\n+         end if;\n+\n+         Set_Sloc (Comp_Unit_Node, Sloc (Name_Node));\n+         Set_Sloc (Aux_Decls_Node (Comp_Unit_Node), Sloc (Name_Node));\n+\n+         --  Set Entity field in file table. Easier now that we have name!\n+         --  Note that this is also skipped if we had a bad unit\n+\n+         if Nkind (Name_Node) = N_Defining_Program_Unit_Name then\n+            Set_Cunit_Entity\n+              (Current_Source_Unit, Defining_Identifier (Name_Node));\n+         else\n+            Set_Cunit_Entity (Current_Source_Unit, Name_Node);\n+         end if;\n+\n+         Set_Unit_Name\n+           (Current_Source_Unit, Get_Unit_Name (Unit (Comp_Unit_Node)));\n+\n+      --  If we had a bad unit, make sure the fatal flag is set in the file\n+      --  table entry, since this is surely a fatal error and also set our\n+      --  flag to inhibit the requirement that we be at end of file.\n+\n+      else\n+         Cunit_Error_Flag := True;\n+         Set_Fatal_Error (Current_Source_Unit);\n+      end if;\n+\n+      --  Clear away any missing semicolon indication, we are done with that\n+      --  unit, so what's done is done, and we don't want anything hanging\n+      --  around from the attempt to parse it!\n+\n+      SIS_Entry_Active := False;\n+\n+      --  Scan out pragmas after unit\n+\n+      while Token = Tok_Pragma loop\n+         Save_Scan_State (Scan_State);\n+\n+         --  If we are in syntax scan mode allowing multiple units, then\n+         --  start the next unit if we encounter a configuration pragma,\n+         --  or a source reference pragma. We take care not to actually\n+         --  scan the pragma in this case since we don't want it to take\n+         --  effect for the current unit.\n+\n+         if Operating_Mode = Check_Syntax then\n+            Scan;  -- past Pragma\n+\n+            if Token = Tok_Identifier\n+              and then\n+                (Token_Name in\n+                         First_Pragma_Name .. Last_Configuration_Pragma_Name\n+                   or else Token_Name = Name_Source_Reference)\n+            then\n+               Restore_Scan_State (Scan_State); -- to Pragma\n+               exit;\n+            end if;\n+         end if;\n+\n+         --  Otherwise eat the pragma, it definitely belongs with the\n+         --  current unit, and not with the following unit.\n+\n+         Restore_Scan_State (Scan_State); -- to Pragma\n+         P := P_Pragma;\n+\n+         if No (Pragmas_After (Aux_Decls_Node (Comp_Unit_Node))) then\n+            Set_Pragmas_After\n+              (Aux_Decls_Node (Comp_Unit_Node), New_List);\n+         end if;\n+\n+         Append (P, Pragmas_After (Aux_Decls_Node (Comp_Unit_Node)));\n+      end loop;\n+\n+      --  Cancel effect of any outstanding pragma Warnings (Off)\n+\n+      Set_Warnings_Mode_On (Scan_Ptr);\n+\n+      --  Ada 83 error checks\n+\n+      if Ada_83 then\n+\n+         --  Check we did not with any child units\n+\n+         Item := First (Context_Items (Comp_Unit_Node));\n+\n+         while Present (Item) loop\n+            if Nkind (Item) = N_With_Clause\n+              and then Nkind (Name (Item)) /= N_Identifier\n+            then\n+               Error_Msg_N (\"(Ada 83) child units not allowed\", Item);\n+            end if;\n+\n+            Next (Item);\n+         end loop;\n+\n+         --  Check that we did not have a PRIVATE keyword present\n+\n+         if Private_Present (Comp_Unit_Node) then\n+            Error_Msg\n+              (\"(Ada 83) private units not allowed\", Private_Sloc);\n+         end if;\n+      end if;\n+\n+      --  If no serious error, then output possible unit information line\n+      --  for gnatchop if we are in syntax only, list units mode.\n+\n+      if not Cunit_Error_Flag\n+        and then List_Units\n+        and then Operating_Mode = Check_Syntax\n+      then\n+         Unit_Display (Comp_Unit_Node, Cunit_Location, SR_Present);\n+      end if;\n+\n+      --  And now we should be at the end of file\n+\n+      if Token /= Tok_EOF then\n+\n+         --  If we already had to scan for a compilation unit, then don't\n+         --  give any further error message, since it just sems to make\n+         --  things worse, and we already gave a serious error message.\n+\n+         if Cunit_Error_Flag then\n+            null;\n+\n+         --  If we are in check syntax mode, then we allow multiple units\n+         --  so we just return with Token not set to Tok_EOF and no message.\n+\n+         elsif Operating_Mode = Check_Syntax then\n+            return Comp_Unit_Node;\n+\n+         --  Otherwise we have an error. We suppress the error message\n+         --  if we already had a fatal error, since this stops junk\n+         --  cascaded messages in some situations.\n+\n+         else\n+            if not Fatal_Error (Current_Source_Unit) then\n+\n+               if Token in Token_Class_Cunit then\n+                  Error_Msg_SC\n+                    (\"end of file expected, \" &\n+                     \"file can have only one compilation unit\");\n+\n+               else\n+                  Error_Msg_SC (\"end of file expected\");\n+               end if;\n+            end if;\n+         end if;\n+\n+         --  Skip tokens to end of file, so that the -gnatl listing\n+         --  will be complete in this situation, but no error checking\n+         --  other than that provided at the token level.\n+\n+         while Token /= Tok_EOF loop\n+            Scan;\n+         end loop;\n+\n+         return Error;\n+\n+      --  Normal return (we were at the end of file as expected)\n+\n+      else\n+         return Comp_Unit_Node;\n+      end if;\n+\n+   exception\n+\n+      --  An error resync is a serious bomb, so indicate result unit no good\n+\n+      when Error_Resync =>\n+         Set_Fatal_Error (Current_Source_Unit);\n+         return Error;\n+\n+   end P_Compilation_Unit;\n+\n+   --------------------------\n+   -- 10.1.1  Library Item --\n+   --------------------------\n+\n+   --  Parsed by P_Compilation_Unit (10.1.1)\n+\n+   --------------------------------------\n+   -- 10.1.1  Library Unit Declaration --\n+   --------------------------------------\n+\n+   --  Parsed by P_Compilation_Unit (10.1.1)\n+\n+   ------------------------------------------------\n+   -- 10.1.1  Library Unit Renaming Declaration  --\n+   ------------------------------------------------\n+\n+   --  Parsed by P_Compilation_Unit (10.1.1)\n+\n+   -------------------------------\n+   -- 10.1.1  Library Unit Body --\n+   -------------------------------\n+\n+   --  Parsed by P_Compilation_Unit (10.1.1)\n+\n+   ------------------------------\n+   -- 10.1.1  Parent Unit Name --\n+   ------------------------------\n+\n+   --  Parsed (as a name) by its parent construct\n+\n+   ----------------------------\n+   -- 10.1.2  Context Clause --\n+   ----------------------------\n+\n+   --  CONTEXT_CLAUSE ::= {CONTEXT_ITEM}\n+\n+   --  CONTEXT_ITEM ::= WITH_CLAUSE | USE_CLAUSE | WITH_TYPE_CLAUSE\n+\n+   --  WITH_CLAUSE ::=\n+   --    with library_unit_NAME {,library_unit_NAME};\n+\n+   --  WITH_TYPE_CLAUSE ::=\n+   --    with type type_NAME is access; | with type type_NAME is tagged;\n+\n+   --  Error recovery: Cannot raise Error_Resync\n+\n+   function P_Context_Clause return List_Id is\n+      Item_List  : List_Id;\n+      With_Node  : Node_Id;\n+      First_Flag : Boolean;\n+\n+   begin\n+      Item_List := New_List;\n+\n+      --  Get keyword casing from WITH keyword in case not set yet\n+\n+      if Token = Tok_With then\n+         Set_Keyword_Casing (Current_Source_File, Determine_Token_Casing);\n+      end if;\n+\n+      --  Loop through context items\n+\n+      loop\n+         if Style_Check then Style.Check_Indentation; end if;\n+\n+         --  Gather any pragmas appearing in the context clause\n+\n+         P_Pragmas_Opt (Item_List);\n+\n+         --  Processing for WITH clause\n+\n+         if Token = Tok_With then\n+            Scan; -- past WITH\n+\n+            if Token = Tok_Type then\n+\n+               --  WITH TYPE is an extension\n+\n+               if not Extensions_Allowed then\n+                  Error_Msg_SP (\"`WITH TYPE` is a non-standard extension\");\n+\n+                  if OpenVMS then\n+                     Error_Msg_SP\n+                       (\"\\unit must be compiled with \" &\n+                        \"'/'E'X'T'E'N'S'I'O'N'S'_'A'L'L'O'W'E'D qualifier\");\n+                  else\n+                     Error_Msg_SP\n+                       (\"\\unit must be compiled with -gnatX switch\");\n+                  end if;\n+               end if;\n+\n+               Scan;  -- past TYPE\n+               With_Node := New_Node (N_With_Type_Clause, Token_Ptr);\n+               Append (With_Node, Item_List);\n+               Set_Name (With_Node, P_Qualified_Simple_Name);\n+\n+               T_Is;\n+\n+               if Token = Tok_Tagged then\n+                  Set_Tagged_Present (With_Node);\n+                  Scan;\n+\n+               elsif Token = Tok_Access then\n+                  Scan;\n+\n+               else\n+                  Error_Msg_SC (\"expect tagged or access qualifier\");\n+               end if;\n+\n+               TF_Semicolon;\n+\n+            else\n+               First_Flag := True;\n+\n+               --  Loop through names in one with clause, generating a separate\n+               --  N_With_Clause node for each nam encountered.\n+\n+               loop\n+                  With_Node := New_Node (N_With_Clause, Token_Ptr);\n+                  Append (With_Node, Item_List);\n+\n+                  --  Note that we allow with'ing of child units, even in\n+                  --  Ada 83 mode, since presumably if this is not desired,\n+                  --  then the compilation of the child unit itself is the\n+                  --  place where such an \"error\" should be caught.\n+\n+                  Set_Name (With_Node, P_Qualified_Simple_Name);\n+                  Set_First_Name (With_Node, First_Flag);\n+                  First_Flag := False;\n+                  exit when Token /= Tok_Comma;\n+                  Scan; -- past comma\n+               end loop;\n+\n+               Set_Last_Name (With_Node, True);\n+               TF_Semicolon;\n+            end if;\n+\n+         --  Processing for USE clause\n+\n+         elsif Token = Tok_Use then\n+            Append (P_Use_Clause, Item_List);\n+\n+         --  Anything else is end of context clause\n+\n+         else\n+            exit;\n+         end if;\n+      end loop;\n+\n+      return Item_List;\n+   end P_Context_Clause;\n+\n+   --------------------------\n+   -- 10.1.2  Context Item --\n+   --------------------------\n+\n+   --  Parsed by P_Context_Clause (10.1.2)\n+\n+   -------------------------\n+   -- 10.1.2  With Clause --\n+   -------------------------\n+\n+   --  Parsed by P_Context_Clause (10.1.2)\n+\n+   -----------------------\n+   -- 10.1.3  Body Stub --\n+   -----------------------\n+\n+   --  Subprogram stub parsed by P_Subprogram (6.1)\n+   --  Package stub parsed by P_Package (7.1)\n+   --  Task stub parsed by P_Task (9.1)\n+   --  Protected stub parsed by P_Protected (9.4)\n+\n+   ----------------------------------\n+   -- 10.1.3  Subprogram Body Stub --\n+   ----------------------------------\n+\n+   --  Parsed by P_Subprogram (6.1)\n+\n+   -------------------------------\n+   -- 10.1.3  Package Body Stub --\n+   -------------------------------\n+\n+   --  Parsed by P_Package (7.1)\n+\n+   ----------------------------\n+   -- 10.1.3  Task Body Stub --\n+   ----------------------------\n+\n+   --  Parsed by P_Task (9.1)\n+\n+   ---------------------------------\n+   -- 10.1.3  Protected Body Stub --\n+   ---------------------------------\n+\n+   --  Parsed by P_Protected (9.4)\n+\n+   ---------------------\n+   -- 10.1.3  Subunit --\n+   ---------------------\n+\n+   --  SUBUNIT ::= separate (PARENT_UNIT_NAME) PROPER_BODY\n+\n+   --  PARENT_UNIT_NAME ::= NAME\n+\n+   --  The caller has checked that the initial token is SEPARATE\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Subunit return Node_Id is\n+      Subunit_Node : Node_Id;\n+      Body_Node    : Node_Id;\n+\n+   begin\n+      Subunit_Node := New_Node (N_Subunit, Token_Ptr);\n+      Body_Node := Error; -- in case no good body found\n+      Scan; -- past SEPARATE;\n+\n+      T_Left_Paren;\n+      Set_Name (Subunit_Node, P_Qualified_Simple_Name);\n+      T_Right_Paren;\n+\n+      if Token = Tok_Semicolon then\n+         Error_Msg_SC (\"unexpected semicolon ignored\");\n+         Scan;\n+      end if;\n+\n+      if Token = Tok_Function or else Token = Tok_Procedure then\n+         Body_Node := P_Subprogram (Pf_Pbod);\n+\n+      elsif Token = Tok_Package then\n+         Body_Node := P_Package (Pf_Pbod);\n+\n+      elsif Token = Tok_Protected then\n+         Scan; -- past PROTECTED\n+\n+         if Token = Tok_Body then\n+            Body_Node := P_Protected;\n+         else\n+            Error_Msg_AP (\"BODY expected\");\n+            return Error;\n+         end if;\n+\n+      elsif Token = Tok_Task then\n+         Scan; -- past TASK\n+\n+         if Token = Tok_Body then\n+            Body_Node := P_Task;\n+         else\n+            Error_Msg_AP (\"BODY expected\");\n+            return Error;\n+         end if;\n+\n+      else\n+         Error_Msg_SC (\"proper body expected\");\n+         return Error;\n+      end if;\n+\n+      Set_Proper_Body  (Subunit_Node, Body_Node);\n+      return Subunit_Node;\n+\n+   end P_Subunit;\n+\n+   ------------------\n+   -- Set_Location --\n+   ------------------\n+\n+   function Set_Location return Source_Ptr is\n+      Physical   : Boolean;\n+      Loc        : Source_Ptr;\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      --  A special check. If the first token is pragma, and this is a\n+      --  Source_Reference pragma, then do NOT eat previous comments, since\n+      --  the Source_Reference pragma is required to be the first line in\n+      --  the source file.\n+\n+      if Token = Tok_Pragma then\n+         Save_Scan_State (Scan_State);\n+         Scan; --  past Pragma\n+\n+         if Token = Tok_Identifier\n+           and then Token_Name = Name_Source_Reference\n+         then\n+            Restore_Scan_State (Scan_State);\n+            return Token_Ptr;\n+         end if;\n+\n+         Restore_Scan_State (Scan_State);\n+      end if;\n+\n+      --  Otherwise acquire previous comments and blank lines\n+\n+      if Prev_Token = No_Token then\n+         return Source_First (Current_Source_File);\n+\n+      else\n+         Loc := Prev_Token_Ptr;\n+         loop\n+            exit when Loc = Token_Ptr;\n+\n+            if Source (Loc) in Line_Terminator then\n+               Skip_Line_Terminators (Loc, Physical);\n+               exit when Physical;\n+            end if;\n+\n+            Loc := Loc + 1;\n+         end loop;\n+\n+         return Loc;\n+      end if;\n+   end Set_Location;\n+\n+   ------------------\n+   -- Unit_Display --\n+   ------------------\n+\n+   --  The format of the generated line, as expected by GNATCHOP is\n+\n+   --    Unit {unit} line {line}, file offset {offs} [, SR], file name {file}\n+\n+   --  where\n+\n+   --     {unit}     unit name with terminating (spec) or (body)\n+   --     {line}     starting line number\n+   --     {offs}     offset to start of text in file\n+   --     {file}     source file name\n+\n+   --  The SR parameter is present only if a source reference pragma was\n+   --  scanned for this unit. The significance is that gnatchop should not\n+   --  attempt to add another one.\n+\n+   procedure Unit_Display\n+     (Cunit      : Node_Id;\n+      Loc        : Source_Ptr;\n+      SR_Present : Boolean)\n+   is\n+      Unum : constant Unit_Number_Type    := Get_Cunit_Unit_Number (Cunit);\n+      Sind : constant Source_File_Index   := Source_Index (Unum);\n+      Unam : constant Unit_Name_Type      := Unit_Name (Unum);\n+\n+   begin\n+      if List_Units then\n+         Write_Str (\"Unit \");\n+         Write_Unit_Name (Unit_Name (Unum));\n+         Unit_Location (Sind, Loc);\n+\n+         if SR_Present then\n+            Write_Str (\", SR\");\n+         end if;\n+\n+         Write_Str (\", file name \");\n+         Write_Name (Get_File_Name (Unam, Nkind (Unit (Cunit)) = N_Subunit));\n+         Write_Eol;\n+      end if;\n+   end Unit_Display;\n+\n+   -------------------\n+   -- Unit_Location --\n+   -------------------\n+\n+   procedure Unit_Location (Sind : Source_File_Index; Loc : Source_Ptr) is\n+      Line : constant Logical_Line_Number := Get_Logical_Line_Number (Loc);\n+      --  Should the above be the physical line number ???\n+\n+   begin\n+      Write_Str (\" line \");\n+      Write_Int (Int (Line));\n+\n+      Write_Str (\", file offset \");\n+      Write_Int (Int (Loc) - Int (Source_First (Sind)));\n+   end Unit_Location;\n+\n+end Ch10;"}, {"sha": "8b59c54ea133884f441b9de893735552aed06509", "filename": "gcc/ada/par-ch11.adb", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch11.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,246 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P A R . C H 1 1                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.22 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Style_Checks (All_Checks);\n+--  Turn off subprogram body ordering check. Subprograms are in order\n+--  by RM section rather than alphabetical\n+\n+with Sinfo.CN; use Sinfo.CN;\n+\n+separate (Par)\n+package body Ch11 is\n+\n+   --  Local functions, used only in this chapter\n+\n+   function P_Exception_Handler  return Node_Id;\n+   function P_Exception_Choice   return Node_Id;\n+\n+   ---------------------------------\n+   -- 11.1  Exception Declaration --\n+   ---------------------------------\n+\n+   --  Parsed by P_Identifier_Declaration (3.3.1)\n+\n+   ------------------------------------------\n+   -- 11.2  Handled Sequence Of Statements --\n+   ------------------------------------------\n+\n+   --  HANDLED_SEQUENCE_OF_STATEMENTS ::=\n+   --      SEQUENCE_OF_STATEMENTS\n+   --    [exception\n+   --      EXCEPTION_HANDLER\n+   --      {EXCEPTION_HANDLER}]\n+\n+   --  Error_Recovery : Cannot raise Error_Resync\n+\n+   function P_Handled_Sequence_Of_Statements return Node_Id is\n+      Handled_Stmt_Seq_Node : Node_Id;\n+\n+   begin\n+      Handled_Stmt_Seq_Node :=\n+        New_Node (N_Handled_Sequence_Of_Statements, Token_Ptr);\n+      Set_Statements\n+        (Handled_Stmt_Seq_Node, P_Sequence_Of_Statements (SS_Extm_Sreq));\n+\n+      if Token = Tok_Exception then\n+         Scan; -- past EXCEPTION\n+         Set_Exception_Handlers\n+           (Handled_Stmt_Seq_Node, Parse_Exception_Handlers);\n+      end if;\n+\n+      return Handled_Stmt_Seq_Node;\n+   end P_Handled_Sequence_Of_Statements;\n+\n+   -----------------------------\n+   -- 11.2  Exception Handler --\n+   -----------------------------\n+\n+   --  EXCEPTION_HANDLER ::=\n+   --    when [CHOICE_PARAMETER_SPECIFICATION :]\n+   --      EXCEPTION_CHOICE {| EXCEPTION_CHOICE} =>\n+   --        SEQUENCE_OF_STATEMENTS\n+\n+   --  CHOICE_PARAMETER_SPECIFICATION ::= DEFINING_IDENTIFIER\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Exception_Handler return Node_Id is\n+      Scan_State        : Saved_Scan_State;\n+      Handler_Node      : Node_Id;\n+      Choice_Param_Node : Node_Id;\n+\n+   begin\n+      Handler_Node := New_Node (N_Exception_Handler, Token_Ptr);\n+      T_When;\n+\n+      --  Test for possible choice parameter present\n+\n+      if Token = Tok_Identifier then\n+         Choice_Param_Node := Token_Node;\n+         Save_Scan_State (Scan_State); -- at identifier\n+         Scan; -- past identifier\n+\n+         if Token = Tok_Colon then\n+            if Ada_83 then\n+               Error_Msg_SP (\"(Ada 83) choice parameter not allowed!\");\n+            end if;\n+\n+            Scan; -- past :\n+            Change_Identifier_To_Defining_Identifier (Choice_Param_Node);\n+            Set_Choice_Parameter (Handler_Node, Choice_Param_Node);\n+\n+         elsif Token = Tok_Others then\n+            Error_Msg_AP (\"missing \"\":\"\"\");\n+            Change_Identifier_To_Defining_Identifier (Choice_Param_Node);\n+            Set_Choice_Parameter (Handler_Node, Choice_Param_Node);\n+\n+         else\n+            Restore_Scan_State (Scan_State); -- to identifier\n+         end if;\n+      end if;\n+\n+      --  Loop through exception choices\n+\n+      Set_Exception_Choices (Handler_Node, New_List);\n+\n+      loop\n+         Append (P_Exception_Choice, Exception_Choices (Handler_Node));\n+         exit when Token /= Tok_Vertical_Bar;\n+         Scan; -- past vertical bar\n+      end loop;\n+\n+      TF_Arrow;\n+      Set_Statements (Handler_Node, P_Sequence_Of_Statements (SS_Sreq_Whtm));\n+      return Handler_Node;\n+   end P_Exception_Handler;\n+\n+   ------------------------------------------\n+   -- 11.2  Choice Parameter Specification --\n+   ------------------------------------------\n+\n+   --  Parsed by P_Exception_Handler (11.2)\n+\n+   ----------------------------\n+   -- 11.2  Exception Choice --\n+   ----------------------------\n+\n+   --  EXCEPTION_CHOICE ::= exception_NAME | others\n+\n+   --  Error recovery: cannot raise Error_Resync. If an error occurs, then the\n+   --  scan pointer is advanced to the next arrow or vertical bar or semicolon.\n+\n+   function P_Exception_Choice return Node_Id is\n+   begin\n+\n+      if Token = Tok_Others then\n+         Scan; -- past OTHERS\n+         return New_Node (N_Others_Choice, Prev_Token_Ptr);\n+\n+      else\n+         return P_Name; -- exception name\n+      end if;\n+\n+   exception\n+      when Error_Resync =>\n+         Resync_Choice;\n+         return Error;\n+   end P_Exception_Choice;\n+\n+   ---------------------------\n+   -- 11.3  Raise Statement --\n+   ---------------------------\n+\n+   --  RAISE_STATEMENT ::= raise [exception_NAME];\n+\n+   --  The caller has verified that the initial token is RAISE\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Raise_Statement return Node_Id is\n+      Raise_Node : Node_Id;\n+\n+   begin\n+      Raise_Node := New_Node (N_Raise_Statement, Token_Ptr);\n+      Scan; -- past RAISE\n+\n+      if Token /= Tok_Semicolon then\n+         Set_Name (Raise_Node, P_Name);\n+      end if;\n+\n+      TF_Semicolon;\n+      return Raise_Node;\n+   end P_Raise_Statement;\n+\n+   ------------------------------\n+   -- Parse_Exception_Handlers --\n+   ------------------------------\n+\n+   --  This routine scans out a list of exception handlers appearing in a\n+   --  construct as:\n+\n+   --    exception\n+   --      EXCEPTION_HANDLER {EXCEPTION_HANDLER}\n+\n+   --  The caller has scanned out the EXCEPTION keyword\n+\n+   --  Control returns after scanning the last exception handler, presumably\n+   --  at the keyword END, but this is not checked in this routine.\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function Parse_Exception_Handlers return List_Id is\n+      Handler       : Node_Id;\n+      Handlers_List : List_Id;\n+      Pragmas_List  : List_Id;\n+\n+   begin\n+      Handlers_List := New_List;\n+      P_Pragmas_Opt (Handlers_List);\n+\n+      if Token = Tok_End then\n+         Error_Msg_SC (\"must have at least one exception handler!\");\n+\n+      else\n+         loop\n+            Handler := P_Exception_Handler;\n+            Pragmas_List := No_List;\n+            Append (Handler, Handlers_List);\n+\n+            --  Note: no need to check for pragmas here. Although the\n+            --  syntax officially allows them in this position, they\n+            --  will have been swallowed up as part of the statement\n+            --  sequence of the handler we just scanned out.\n+\n+            exit when Token /= Tok_When;\n+         end loop;\n+      end if;\n+\n+      return Handlers_List;\n+   end Parse_Exception_Handlers;\n+\n+end Ch11;"}, {"sha": "139243e67e2bbc8a2a2ae5a9e76264f1dd42438e", "filename": "gcc/ada/par-ch12.adb", "status": "added", "additions": 882, "deletions": 0, "changes": 882, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,882 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P A R . C H 1 2                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.46 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Style_Checks (All_Checks);\n+--  Turn off subprogram body ordering check. Subprograms are in order\n+--  by RM section rather than alphabetical\n+\n+separate (Par)\n+package body Ch12 is\n+\n+   --  Local functions, used only in this chapter\n+\n+   function P_Formal_Derived_Type_Definition           return Node_Id;\n+   function P_Formal_Discrete_Type_Definition          return Node_Id;\n+   function P_Formal_Fixed_Point_Definition            return Node_Id;\n+   function P_Formal_Floating_Point_Definition         return Node_Id;\n+   function P_Formal_Modular_Type_Definition           return Node_Id;\n+   function P_Formal_Package_Declaration               return Node_Id;\n+   function P_Formal_Private_Type_Definition           return Node_Id;\n+   function P_Formal_Signed_Integer_Type_Definition    return Node_Id;\n+   function P_Formal_Subprogram_Declaration            return Node_Id;\n+   function P_Formal_Type_Declaration                  return Node_Id;\n+   function P_Formal_Type_Definition                   return Node_Id;\n+   function P_Generic_Association                      return Node_Id;\n+\n+   procedure P_Formal_Object_Declarations (Decls : List_Id);\n+   --  Scans one or more formal object declarations and appends them to\n+   --  Decls. Scans more than one declaration only in the case where the\n+   --  source has a declaration with multiple defining identifiers.\n+\n+   --------------------------------\n+   -- 12.1  Generic (also 8.5.5) --\n+   --------------------------------\n+\n+   --  This routine parses either one of the forms of a generic declaration\n+   --  or a generic renaming declaration.\n+\n+   --  GENERIC_DECLARATION ::=\n+   --    GENERIC_SUBPROGRAM_DECLARATION | GENERIC_PACKAGE_DECLARATION\n+\n+   --  GENERIC_SUBPROGRAM_DECLARATION ::=\n+   --    GENERIC_FORMAL_PART SUBPROGRAM_SPECIFICATION;\n+\n+   --  GENERIC_PACKAGE_DECLARATION ::=\n+   --    GENERIC_FORMAL_PART PACKAGE_SPECIFICATION;\n+\n+   --  GENERIC_FORMAL_PART ::=\n+   --    generic {GENERIC_FORMAL_PARAMETER_DECLARATION | USE_CLAUSE}\n+\n+   --  GENERIC_RENAMING_DECLARATION ::=\n+   --    generic package DEFINING_PROGRAM_UNIT_NAME\n+   --      renames generic_package_NAME\n+   --  | generic procedure DEFINING_PROGRAM_UNIT_NAME\n+   --      renames generic_procedure_NAME\n+   --  | generic function DEFINING_PROGRAM_UNIT_NAME\n+   --      renames generic_function_NAME\n+\n+   --  GENERIC_FORMAL_PARAMETER_DECLARATION ::=\n+   --    FORMAL_OBJECT_DECLARATION\n+   --  | FORMAL_TYPE_DECLARATION\n+   --  | FORMAL_SUBPROGRAM_DECLARATION\n+   --  | FORMAL_PACKAGE_DECLARATION\n+\n+   --  The caller has checked that the initial token is GENERIC\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Generic return Node_Id is\n+      Gen_Sloc   : constant Source_Ptr := Token_Ptr;\n+      Gen_Decl   : Node_Id;\n+      Decl_Node  : Node_Id;\n+      Decls      : List_Id;\n+      Def_Unit   : Node_Id;\n+      Ren_Token  : Token_Type;\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      Scan; -- past GENERIC\n+\n+      if Token = Tok_Private then\n+         Error_Msg_SC (\"PRIVATE goes before GENERIC, not after\");\n+         Scan; -- past junk PRIVATE token\n+      end if;\n+\n+      Save_Scan_State (Scan_State); -- at token past GENERIC\n+\n+      --  Check for generic renaming declaration case\n+\n+      if Token = Tok_Package\n+        or else Token = Tok_Function\n+        or else Token = Tok_Procedure\n+      then\n+         Ren_Token := Token;\n+         Scan; -- scan past PACKAGE, FUNCTION or PROCEDURE\n+\n+         if Token = Tok_Identifier then\n+            Def_Unit := P_Defining_Program_Unit_Name;\n+\n+            Check_Misspelling_Of (Tok_Renames);\n+\n+            if Token = Tok_Renames then\n+               if Ren_Token = Tok_Package then\n+                  Decl_Node := New_Node\n+                    (N_Generic_Package_Renaming_Declaration, Gen_Sloc);\n+\n+               elsif Ren_Token = Tok_Procedure then\n+                  Decl_Node := New_Node\n+                    (N_Generic_Procedure_Renaming_Declaration, Gen_Sloc);\n+\n+               else -- Ren_Token = Tok_Function then\n+                  Decl_Node := New_Node\n+                    (N_Generic_Function_Renaming_Declaration, Gen_Sloc);\n+               end if;\n+\n+               Scan; -- past RENAMES\n+               Set_Defining_Unit_Name (Decl_Node, Def_Unit);\n+               Set_Name (Decl_Node, P_Name);\n+               TF_Semicolon;\n+               return Decl_Node;\n+            end if;\n+         end if;\n+      end if;\n+\n+      --  Fall through if this is *not* a generic renaming declaration\n+\n+      Restore_Scan_State (Scan_State);\n+      Decls := New_List;\n+\n+      --  Loop through generic parameter declarations and use clauses\n+\n+      Decl_Loop : loop\n+         P_Pragmas_Opt (Decls);\n+         Ignore (Tok_Private);\n+\n+         if Token = Tok_Use then\n+            Append (P_Use_Clause, Decls);\n+         else\n+            --  Parse a generic parameter declaration\n+\n+            if Token = Tok_Identifier then\n+               P_Formal_Object_Declarations (Decls);\n+\n+            elsif Token = Tok_Type then\n+               Append (P_Formal_Type_Declaration, Decls);\n+\n+            elsif Token = Tok_With then\n+               Scan; -- past WITH\n+\n+               if Token = Tok_Package then\n+                  Append (P_Formal_Package_Declaration, Decls);\n+\n+               elsif Token = Tok_Procedure or Token = Tok_Function then\n+                  Append (P_Formal_Subprogram_Declaration, Decls);\n+\n+               else\n+                  Error_Msg_BC\n+                    (\"FUNCTION, PROCEDURE or PACKAGE expected here\");\n+                  Resync_Past_Semicolon;\n+               end if;\n+\n+            elsif Token = Tok_Subtype then\n+               Error_Msg_SC (\"subtype declaration not allowed \" &\n+                                \"as generic parameter declaration!\");\n+               Resync_Past_Semicolon;\n+\n+            else\n+               exit Decl_Loop;\n+            end if;\n+         end if;\n+\n+      end loop Decl_Loop;\n+\n+      --  Generic formal part is scanned, scan out subprogram or package spec\n+\n+      if Token = Tok_Package then\n+         Gen_Decl := New_Node (N_Generic_Package_Declaration, Gen_Sloc);\n+         Set_Specification (Gen_Decl, P_Package (Pf_Spcn));\n+      else\n+         Gen_Decl := New_Node (N_Generic_Subprogram_Declaration, Gen_Sloc);\n+         Set_Specification (Gen_Decl, P_Subprogram_Specification);\n+         TF_Semicolon;\n+      end if;\n+\n+      Set_Generic_Formal_Declarations (Gen_Decl, Decls);\n+      return Gen_Decl;\n+   end P_Generic;\n+\n+   -------------------------------\n+   -- 12.1  Generic Declaration --\n+   -------------------------------\n+\n+   --  Parsed by P_Generic (12.1)\n+\n+   ------------------------------------------\n+   -- 12.1  Generic Subprogram Declaration --\n+   ------------------------------------------\n+\n+   --  Parsed by P_Generic (12.1)\n+\n+   ---------------------------------------\n+   -- 12.1  Generic Package Declaration --\n+   ---------------------------------------\n+\n+   --  Parsed by P_Generic (12.1)\n+\n+   -------------------------------\n+   -- 12.1  Generic Formal Part --\n+   -------------------------------\n+\n+   --  Parsed by P_Generic (12.1)\n+\n+   -------------------------------------------------\n+   -- 12.1   Generic Formal Parameter Declaration --\n+   -------------------------------------------------\n+\n+   --  Parsed by P_Generic (12.1)\n+\n+   ---------------------------------\n+   -- 12.3  Generic Instantiation --\n+   ---------------------------------\n+\n+   --  Generic package instantiation parsed by P_Package (7.1)\n+   --  Generic procedure instantiation parsed by P_Subprogram (6.1)\n+   --  Generic function instantiation parsed by P_Subprogram (6.1)\n+\n+   -------------------------------\n+   -- 12.3  Generic Actual Part --\n+   -------------------------------\n+\n+   --  GENERIC_ACTUAL_PART ::=\n+   --    (GENERIC_ASSOCIATION {, GENERIC_ASSOCIATION})\n+\n+   --  Returns a list of generic associations, or Empty if none are present\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Generic_Actual_Part_Opt return List_Id is\n+      Association_List : List_Id;\n+\n+   begin\n+      --  Figure out if a generic actual part operation is present. Clearly\n+      --  there is no generic actual part if the current token is semicolon\n+\n+      if Token = Tok_Semicolon then\n+         return No_List;\n+\n+      --  If we don't have a left paren, then we have an error, and the job\n+      --  is to figure out whether a left paren or semicolon was intended.\n+      --  We assume a missing left paren (and hence a generic actual part\n+      --  present) if the current token is not on a new line, or if it is\n+      --  indented from the subprogram token. Otherwise assume missing\n+      --  semicolon (which will be diagnosed by caller) and no generic part\n+\n+      elsif Token /= Tok_Left_Paren\n+        and then Token_Is_At_Start_Of_Line\n+        and then Start_Column <= Scope.Table (Scope.Last).Ecol\n+      then\n+         return No_List;\n+\n+      --  Otherwise we have a generic actual part (either a left paren is\n+      --  present, or we have decided that there must be a missing left paren)\n+\n+      else\n+         Association_List := New_List;\n+         T_Left_Paren;\n+\n+         loop\n+            Append (P_Generic_Association, Association_List);\n+            exit when not Comma_Present;\n+         end loop;\n+\n+         T_Right_Paren;\n+         return Association_List;\n+      end if;\n+\n+   end P_Generic_Actual_Part_Opt;\n+\n+   -------------------------------\n+   -- 12.3  Generic Association --\n+   -------------------------------\n+\n+   --  GENERIC_ASSOCIATION ::=\n+   --    [generic_formal_parameter_SELECTOR_NAME =>]\n+   --      EXPLICIT_GENERIC_ACTUAL_PARAMETER\n+\n+   --  EXPLICIT_GENERIC_ACTUAL_PARAMETER ::=\n+   --    EXPRESSION      | variable_NAME   | subprogram_NAME\n+   --  | entry_NAME      | SUBTYPE_MARK    | package_instance_NAME\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Generic_Association return Node_Id is\n+      Scan_State         : Saved_Scan_State;\n+      Param_Name_Node    : Node_Id;\n+      Generic_Assoc_Node : Node_Id;\n+\n+   begin\n+      Generic_Assoc_Node := New_Node (N_Generic_Association, Token_Ptr);\n+\n+      if Token in Token_Class_Desig then\n+         Param_Name_Node := Token_Node;\n+         Save_Scan_State (Scan_State); -- at designator\n+         Scan; -- past simple name or operator symbol\n+\n+         if Token = Tok_Arrow then\n+            Scan; -- past arrow\n+            Set_Selector_Name (Generic_Assoc_Node, Param_Name_Node);\n+         else\n+            Restore_Scan_State (Scan_State); -- to designator\n+         end if;\n+      end if;\n+\n+      Set_Explicit_Generic_Actual_Parameter (Generic_Assoc_Node, P_Expression);\n+      return Generic_Assoc_Node;\n+   end P_Generic_Association;\n+\n+   ---------------------------------------------\n+   -- 12.3  Explicit Generic Actual Parameter --\n+   ---------------------------------------------\n+\n+   --  Parsed by P_Generic_Association (12.3)\n+\n+   --------------------------------------\n+   -- 12.4  Formal Object Declarations --\n+   --------------------------------------\n+\n+   --  FORMAL_OBJECT_DECLARATION ::=\n+   --    DEFINING_IDENTIFIER_LIST :\n+   --      MODE SUBTYPE_MARK [:= DEFAULT_EXPRESSION];\n+\n+   --  The caller has checked that the initial token is an identifier\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   procedure P_Formal_Object_Declarations (Decls : List_Id) is\n+      Decl_Node  : Node_Id;\n+      Scan_State : Saved_Scan_State;\n+      Num_Idents : Nat;\n+      Ident      : Nat;\n+\n+      Idents : array (Int range 1 .. 4096) of Entity_Id;\n+      --  This array holds the list of defining identifiers. The upper bound\n+      --  of 4096 is intended to be essentially infinite, and we do not even\n+      --  bother to check for it being exceeded.\n+\n+   begin\n+      Idents (1) := P_Defining_Identifier;\n+      Num_Idents := 1;\n+\n+      while Comma_Present loop\n+         Num_Idents := Num_Idents + 1;\n+         Idents (Num_Idents) := P_Defining_Identifier;\n+      end loop;\n+\n+      T_Colon;\n+\n+      --  If there are multiple identifiers, we repeatedly scan the\n+      --  type and initialization expression information by resetting\n+      --  the scan pointer (so that we get completely separate trees\n+      --  for each occurrence).\n+\n+      if Num_Idents > 1 then\n+         Save_Scan_State (Scan_State);\n+      end if;\n+\n+      --  Loop through defining identifiers in list\n+\n+      Ident := 1;\n+      Ident_Loop : loop\n+         Decl_Node := New_Node (N_Formal_Object_Declaration, Token_Ptr);\n+         Set_Defining_Identifier (Decl_Node, Idents (Ident));\n+         P_Mode (Decl_Node);\n+         Set_Subtype_Mark (Decl_Node, P_Subtype_Mark_Resync);\n+         No_Constraint;\n+         Set_Expression (Decl_Node, Init_Expr_Opt);\n+\n+         if Ident > 1 then\n+            Set_Prev_Ids (Decl_Node, True);\n+         end if;\n+\n+         if Ident < Num_Idents then\n+            Set_More_Ids (Decl_Node, True);\n+         end if;\n+\n+         Append (Decl_Node, Decls);\n+\n+         exit Ident_Loop when Ident = Num_Idents;\n+         Ident := Ident + 1;\n+         Restore_Scan_State (Scan_State);\n+      end loop Ident_Loop;\n+\n+      TF_Semicolon;\n+   end P_Formal_Object_Declarations;\n+\n+   -----------------------------------\n+   -- 12.5  Formal Type Declaration --\n+   -----------------------------------\n+\n+   --  FORMAL_TYPE_DECLARATION ::=\n+   --    type DEFINING_IDENTIFIER [DISCRIMINANT_PART]\n+   --      is FORMAL_TYPE_DEFINITION;\n+\n+   --  The caller has checked that the initial token is TYPE\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Formal_Type_Declaration return Node_Id is\n+      Decl_Node  : Node_Id;\n+\n+   begin\n+      Decl_Node := New_Node (N_Formal_Type_Declaration, Token_Ptr);\n+      Scan; -- past TYPE\n+      Set_Defining_Identifier (Decl_Node, P_Defining_Identifier);\n+\n+      if P_Unknown_Discriminant_Part_Opt then\n+         Set_Unknown_Discriminants_Present (Decl_Node, True);\n+      else\n+         Set_Discriminant_Specifications\n+           (Decl_Node, P_Known_Discriminant_Part_Opt);\n+      end if;\n+\n+      T_Is;\n+\n+      Set_Formal_Type_Definition (Decl_Node, P_Formal_Type_Definition);\n+      TF_Semicolon;\n+      return Decl_Node;\n+   end P_Formal_Type_Declaration;\n+\n+   ----------------------------------\n+   -- 12.5  Formal Type Definition --\n+   ----------------------------------\n+\n+   --  FORMAL_TYPE_DEFINITION ::=\n+   --    FORMAL_PRIVATE_TYPE_DEFINITION\n+   --  | FORMAL_DERIVED_TYPE_DEFINITION\n+   --  | FORMAL_DISCRETE_TYPE_DEFINITION\n+   --  | FORMAL_SIGNED_INTEGER_TYPE_DEFINITION\n+   --  | FORMAL_MODULAR_TYPE_DEFINITION\n+   --  | FORMAL_FLOATING_POINT_DEFINITION\n+   --  | FORMAL_ORDINARY_FIXED_POINT_DEFINITION\n+   --  | FORMAL_DECIMAL_FIXED_POINT_DEFINITION\n+   --  | FORMAL_ARRAY_TYPE_DEFINITION\n+   --  | FORMAL_ACCESS_TYPE_DEFINITION\n+\n+   --  FORMAL_ARRAY_TYPE_DEFINITION ::= ARRAY_TYPE_DEFINITION\n+\n+   --  FORMAL_ACCESS_TYPE_DEFINITION ::= ACCESS_TYPE_DEFINITION\n+\n+   function P_Formal_Type_Definition return Node_Id is\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      if Token_Name = Name_Abstract then\n+         Check_95_Keyword (Tok_Abstract, Tok_Tagged);\n+      end if;\n+\n+      if Token_Name = Name_Tagged then\n+         Check_95_Keyword (Tok_Tagged, Tok_Private);\n+         Check_95_Keyword (Tok_Tagged, Tok_Limited);\n+      end if;\n+\n+      case Token is\n+\n+         --  Mostly we can tell what we have from the initial token. The one\n+         --  exception is ABSTRACT, where we have to scan ahead to see if we\n+         --  have a formal derived type or a formal private type definition.\n+\n+         when Tok_Abstract =>\n+            Save_Scan_State (Scan_State);\n+            Scan; -- past ABSTRACT\n+\n+            if Token = Tok_New then\n+               Restore_Scan_State (Scan_State); -- to ABSTRACT\n+               return P_Formal_Derived_Type_Definition;\n+\n+            else\n+               Restore_Scan_State (Scan_State); -- to ABSTRACT\n+               return P_Formal_Private_Type_Definition;\n+            end if;\n+\n+         when Tok_Private | Tok_Limited | Tok_Tagged =>\n+            return P_Formal_Private_Type_Definition;\n+\n+         when Tok_New =>\n+            return P_Formal_Derived_Type_Definition;\n+\n+         when Tok_Left_Paren =>\n+            return P_Formal_Discrete_Type_Definition;\n+\n+         when Tok_Range =>\n+            return P_Formal_Signed_Integer_Type_Definition;\n+\n+         when Tok_Mod =>\n+            return P_Formal_Modular_Type_Definition;\n+\n+         when Tok_Digits =>\n+            return P_Formal_Floating_Point_Definition;\n+\n+         when Tok_Delta =>\n+            return P_Formal_Fixed_Point_Definition;\n+\n+         when Tok_Array =>\n+            return P_Array_Type_Definition;\n+\n+         when Tok_Access =>\n+            return P_Access_Type_Definition;\n+\n+         when Tok_Record =>\n+            Error_Msg_SC (\"record not allowed in generic type definition!\");\n+            Discard_Junk_Node (P_Record_Definition);\n+            return Error;\n+\n+         when others =>\n+            Error_Msg_BC (\"expecting generic type definition here\");\n+            Resync_Past_Semicolon;\n+            return Error;\n+\n+      end case;\n+   end P_Formal_Type_Definition;\n+\n+   --------------------------------------------\n+   -- 12.5.1  Formal Private Type Definition --\n+   --------------------------------------------\n+\n+   --  FORMAL_PRIVATE_TYPE_DEFINITION ::=\n+   --    [[abstract] tagged] [limited] private\n+\n+   --  The caller has checked the initial token is PRIVATE, ABSTRACT,\n+   --   TAGGED or LIMITED\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Formal_Private_Type_Definition return Node_Id is\n+      Def_Node : Node_Id;\n+\n+   begin\n+      Def_Node := New_Node (N_Formal_Private_Type_Definition, Token_Ptr);\n+\n+      if Token = Tok_Abstract then\n+         Scan; -- past ABSTRACT\n+\n+         if Token_Name = Name_Tagged then\n+            Check_95_Keyword (Tok_Tagged, Tok_Private);\n+            Check_95_Keyword (Tok_Tagged, Tok_Limited);\n+         end if;\n+\n+         if Token /= Tok_Tagged then\n+            Error_Msg_SP (\"ABSTRACT must be followed by TAGGED\");\n+         else\n+            Set_Abstract_Present (Def_Node, True);\n+         end if;\n+      end if;\n+\n+      if Token = Tok_Tagged then\n+         Set_Tagged_Present (Def_Node, True);\n+         Scan; -- past TAGGED\n+      end if;\n+\n+      if Token = Tok_Limited then\n+         Set_Limited_Present (Def_Node, True);\n+         Scan; -- past LIMITED\n+      end if;\n+\n+      Set_Sloc (Def_Node, Token_Ptr);\n+      T_Private;\n+      return Def_Node;\n+   end P_Formal_Private_Type_Definition;\n+\n+   --------------------------------------------\n+   -- 12.5.1  Formal Derived Type Definition --\n+   --------------------------------------------\n+\n+   --  FORMAL_DERIVED_TYPE_DEFINITION ::=\n+   --    [abstract] new SUBTYPE_MARK [with private]\n+\n+   --  The caller has checked the initial token(s) is/are NEW or ASTRACT NEW\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Formal_Derived_Type_Definition return Node_Id is\n+      Def_Node : Node_Id;\n+\n+   begin\n+      Def_Node := New_Node (N_Formal_Derived_Type_Definition, Token_Ptr);\n+\n+      if Token = Tok_Abstract then\n+         Set_Abstract_Present (Def_Node);\n+         Scan; -- past ABSTRACT\n+      end if;\n+\n+      Scan; -- past NEW;\n+      Set_Subtype_Mark (Def_Node, P_Subtype_Mark);\n+      No_Constraint;\n+\n+      if Token = Tok_With then\n+         Scan; -- past WITH\n+         Set_Private_Present (Def_Node, True);\n+         T_Private;\n+      end if;\n+\n+      return Def_Node;\n+   end P_Formal_Derived_Type_Definition;\n+\n+   ---------------------------------------------\n+   -- 12.5.2  Formal Discrete Type Definition --\n+   ---------------------------------------------\n+\n+   --  FORMAL_DISCRETE_TYPE_DEFINITION ::= (<>)\n+\n+   --  The caller has checked the initial token is left paren\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Formal_Discrete_Type_Definition return Node_Id is\n+      Def_Node : Node_Id;\n+\n+   begin\n+      Def_Node := New_Node (N_Formal_Discrete_Type_Definition, Token_Ptr);\n+      Scan; -- past left paren\n+      T_Box;\n+      T_Right_Paren;\n+      return Def_Node;\n+   end P_Formal_Discrete_Type_Definition;\n+\n+   ---------------------------------------------------\n+   -- 12.5.2  Formal Signed Integer Type Definition --\n+   ---------------------------------------------------\n+\n+   --  FORMAL_SIGNED_INTEGER_TYPE_DEFINITION ::= range <>\n+\n+   --  The caller has checked the initial token is RANGE\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Formal_Signed_Integer_Type_Definition return Node_Id is\n+      Def_Node : Node_Id;\n+\n+   begin\n+      Def_Node :=\n+        New_Node (N_Formal_Signed_Integer_Type_Definition, Token_Ptr);\n+      Scan; -- past RANGE\n+      T_Box;\n+      return Def_Node;\n+   end P_Formal_Signed_Integer_Type_Definition;\n+\n+   --------------------------------------------\n+   -- 12.5.2  Formal Modular Type Definition --\n+   --------------------------------------------\n+\n+   --  FORMAL_MODULAR_TYPE_DEFINITION ::= mod <>\n+\n+   --  The caller has checked the initial token is MOD\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Formal_Modular_Type_Definition return Node_Id is\n+      Def_Node : Node_Id;\n+\n+   begin\n+      Def_Node :=\n+        New_Node (N_Formal_Modular_Type_Definition, Token_Ptr);\n+      Scan; -- past MOD\n+      T_Box;\n+      return Def_Node;\n+   end P_Formal_Modular_Type_Definition;\n+\n+   ----------------------------------------------\n+   -- 12.5.2  Formal Floating Point Definition --\n+   ----------------------------------------------\n+\n+   --  FORMAL_FLOATING_POINT_DEFINITION ::= digits <>\n+\n+   --  The caller has checked the initial token is DIGITS\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Formal_Floating_Point_Definition return Node_Id is\n+      Def_Node : Node_Id;\n+\n+   begin\n+      Def_Node :=\n+        New_Node (N_Formal_Floating_Point_Definition, Token_Ptr);\n+      Scan; -- past DIGITS\n+      T_Box;\n+      return Def_Node;\n+   end P_Formal_Floating_Point_Definition;\n+\n+   -------------------------------------------\n+   -- 12.5.2  Formal Fixed Point Definition --\n+   -------------------------------------------\n+\n+   --  This routine parses either a formal ordinary fixed point definition\n+   --  or a formal decimal fixed point definition:\n+\n+   --  FORMAL_ORDINARY_FIXED_POINT_DEFINITION ::= delta <>\n+\n+   --  FORMAL_DECIMAL_FIXED_POINT_DEFINITION ::= delta <> digits <>\n+\n+   --  The caller has checked the initial token is DELTA\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Formal_Fixed_Point_Definition return Node_Id is\n+      Def_Node   : Node_Id;\n+      Delta_Sloc : Source_Ptr;\n+\n+   begin\n+      Delta_Sloc := Token_Ptr;\n+      Scan; -- past DELTA\n+      T_Box;\n+\n+      if Token = Tok_Digits then\n+         Def_Node :=\n+           New_Node (N_Formal_Decimal_Fixed_Point_Definition, Delta_Sloc);\n+         Scan; -- past DIGITS\n+         T_Box;\n+      else\n+         Def_Node :=\n+           New_Node (N_Formal_Ordinary_Fixed_Point_Definition, Delta_Sloc);\n+      end if;\n+\n+      return Def_Node;\n+   end P_Formal_Fixed_Point_Definition;\n+\n+   ----------------------------------------------------\n+   -- 12.5.2  Formal Ordinary Fixed Point Definition --\n+   ----------------------------------------------------\n+\n+   --  Parsed by P_Formal_Fixed_Point_Definition (12.5.2)\n+\n+   ---------------------------------------------------\n+   -- 12.5.2  Formal Decimal Fixed Point Definition --\n+   ---------------------------------------------------\n+\n+   --  Parsed by P_Formal_Fixed_Point_Definition (12.5.2)\n+\n+   ------------------------------------------\n+   -- 12.5.3  Formal Array Type Definition --\n+   ------------------------------------------\n+\n+   --  Parsed by P_Formal_Type_Definition (12.5)\n+\n+   -------------------------------------------\n+   -- 12.5.4  Formal Access Type Definition --\n+   -------------------------------------------\n+\n+   --  Parsed by P_Formal_Type_Definition (12.5)\n+\n+   -----------------------------------------\n+   -- 12.6  Formal Subprogram Declaration --\n+   -----------------------------------------\n+\n+   --  FORMAL_SUBPROGRAM_DECLARATION ::=\n+   --    with SUBPROGRAM_SPECIFICATION [is SUBPROGRAM_DEFAULT];\n+\n+   --  SUBPROGRAM_DEFAULT ::= DEFAULT_NAME | <>\n+\n+   --  DEFAULT_NAME ::= NAME\n+\n+   --  The caller has checked that the initial tokens are WITH FUNCTION or\n+   --  WITH PROCEDURE, and the initial WITH has been scanned out.\n+\n+   --  Note: we separate this into two procedures because the name is allowed\n+   --  to be an operator symbol for a function, but not for a procedure.\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Formal_Subprogram_Declaration return Node_Id is\n+      Def_Node : Node_Id;\n+\n+   begin\n+      Def_Node := New_Node (N_Formal_Subprogram_Declaration, Prev_Token_Ptr);\n+      Set_Specification (Def_Node, P_Subprogram_Specification);\n+\n+      if Token = Tok_Is then\n+         T_Is; -- past IS, skip extra IS or \";\"\n+\n+         if Token = Tok_Box then\n+            Set_Box_Present (Def_Node, True);\n+            Scan; -- past <>\n+\n+         else\n+            Set_Default_Name (Def_Node, P_Name);\n+         end if;\n+\n+      end if;\n+\n+      T_Semicolon;\n+      return Def_Node;\n+   end P_Formal_Subprogram_Declaration;\n+\n+   ------------------------------\n+   -- 12.6  Subprogram Default --\n+   ------------------------------\n+\n+   --  Parsed by P_Formal_Procedure_Declaration (12.6)\n+\n+   ------------------------\n+   -- 12.6  Default Name --\n+   ------------------------\n+\n+   --  Parsed by P_Formal_Procedure_Declaration (12.6)\n+\n+   --------------------------------------\n+   -- 12.7  Formal Package Declaration --\n+   --------------------------------------\n+\n+   --  FORMAL_PACKAGE_DECLARATION ::=\n+   --    with package DEFINING_IDENTIFIER\n+   --      is new generic_package_NAME FORMAL_PACKAGE_ACTUAL_PART;\n+\n+   --  FORMAL_PACKAGE_ACTUAL_PART ::=\n+   --    (<>) | [GENERIC_ACTUAL_PART]\n+\n+   --  The caller has checked that the initial tokens are WITH PACKAGE,\n+   --  and the initial WITH has been scanned out (so Token = Tok_Package).\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Formal_Package_Declaration return Node_Id is\n+      Def_Node : Node_Id;\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      Def_Node := New_Node (N_Formal_Package_Declaration, Prev_Token_Ptr);\n+      Scan; -- past PACKAGE\n+      Set_Defining_Identifier (Def_Node, P_Defining_Identifier);\n+      T_Is;\n+      T_New;\n+      Set_Name (Def_Node, P_Qualified_Simple_Name);\n+\n+      if Token = Tok_Left_Paren then\n+         Save_Scan_State (Scan_State); -- at the left paren\n+         Scan; -- past the left paren\n+\n+         if Token = Tok_Box then\n+            Set_Box_Present (Def_Node, True);\n+            Scan; -- past box\n+            T_Right_Paren;\n+\n+         else\n+            Restore_Scan_State (Scan_State); -- to the left paren\n+            Set_Generic_Associations (Def_Node, P_Generic_Actual_Part_Opt);\n+         end if;\n+      end if;\n+\n+      T_Semicolon;\n+      return Def_Node;\n+   end P_Formal_Package_Declaration;\n+\n+   --------------------------------------\n+   -- 12.7  Formal Package Actual Part --\n+   --------------------------------------\n+\n+   --  Parsed by P_Formal_Package_Declaration (12.7)\n+\n+end Ch12;"}, {"sha": "03bd7bf12752bec1ef3da91da8c2084ec4b99ad5", "filename": "gcc/ada/par-ch13.adb", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch13.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,441 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P A R . C H 1 3                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.34 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Style_Checks (All_Checks);\n+--  Turn off subprogram body ordering check. Subprograms are in order\n+--  by RM section rather than alphabetical\n+\n+separate (Par)\n+package body Ch13 is\n+\n+   --  Local functions, used only in this chapter\n+\n+   function P_Component_Clause return Node_Id;\n+   function P_Mod_Clause return Node_Id;\n+\n+   --------------------------------------------\n+   -- 13.1  Representation Clause (also I.7) --\n+   --------------------------------------------\n+\n+   --  REPRESENTATION_CLAUSE ::=\n+   --    ATTRIBUTE_DEFINITION_CLAUSE\n+   --  | ENUMERATION_REPRESENTATION_CLAUSE\n+   --  | RECORD_REPRESENTATION_CLAUSE\n+   --  | AT_CLAUSE\n+\n+   --  ATTRIBUTE_DEFINITION_CLAUSE ::=\n+   --    for LOCAL_NAME'ATTRIBUTE_DESIGNATOR use EXPRESSION;\n+   --  | for LOCAL_NAME'ATTRIBUTE_DESIGNATOR use NAME;\n+\n+   --  Note: in Ada 83, the expression must be a simple expression\n+\n+   --  AT_CLAUSE ::= for DIRECT_NAME use at EXPRESSION;\n+\n+   --  Note: in Ada 83, the expression must be a simple expression\n+\n+   --  ENUMERATION_REPRESENTATION_CLAUSE ::=\n+   --    for first_subtype_LOCAL_NAME use ENUMERATION_AGGREGATE;\n+\n+   --  ENUMERATION_AGGREGATE ::= ARRAY_AGGREGATE\n+\n+   --  RECORD_REPRESENTATION_CLAUSE ::=\n+   --    for first_subtype_LOCAL_NAME use\n+   --      record [MOD_CLAUSE]\n+   --        {COMPONENT_CLAUSE}\n+   --      end record;\n+\n+   --  Note: for now we allow only a direct name as the local name in the\n+   --  above constructs. This probably needs changing later on ???\n+\n+   --  The caller has checked that the initial token is FOR\n+\n+   --  Error recovery: cannot raise Error_Resync, if an error occurs,\n+   --  the scan is repositioned past the next semicolon.\n+\n+   function P_Representation_Clause return Node_Id is\n+      For_Loc         : Source_Ptr;\n+      Name_Node       : Node_Id;\n+      Prefix_Node     : Node_Id;\n+      Attr_Name       : Name_Id;\n+      Identifier_Node : Node_Id;\n+      Rep_Clause_Node : Node_Id;\n+      Expr_Node       : Node_Id;\n+      Record_Items    : List_Id;\n+\n+   begin\n+      For_Loc := Token_Ptr;\n+      Scan; -- past FOR\n+\n+      --  Note that the name in a representation clause is always a simple\n+      --  name, even in the attribute case, see AI-300 which made this so!\n+\n+      Identifier_Node := P_Identifier;\n+\n+      --  Check case of qualified name to give good error message\n+\n+      if Token = Tok_Dot then\n+         Error_Msg_SC\n+            (\"representation clause requires simple name!\");\n+\n+         loop\n+            exit when Token /= Tok_Dot;\n+            Scan; -- past dot\n+            Discard_Junk_Node (P_Identifier);\n+         end loop;\n+      end if;\n+\n+      --  Attribute Definition Clause\n+\n+      if Token = Tok_Apostrophe then\n+\n+         --  Allow local names of the form a'b'.... This enables\n+         --  us to parse class-wide streams attributes correctly.\n+\n+         Name_Node := Identifier_Node;\n+         while Token = Tok_Apostrophe loop\n+\n+            Scan; -- past apostrophe\n+\n+            Identifier_Node := Token_Node;\n+            Attr_Name := No_Name;\n+\n+            if Token = Tok_Identifier then\n+               Attr_Name := Token_Name;\n+\n+               if not Is_Attribute_Name (Attr_Name) then\n+                  Signal_Bad_Attribute;\n+               end if;\n+\n+               if Style_Check then\n+                  Style.Check_Attribute_Name (False);\n+               end if;\n+\n+            --  Here for case of attribute designator is not an identifier\n+\n+            else\n+               if Token = Tok_Delta then\n+                  Attr_Name := Name_Delta;\n+\n+               elsif Token = Tok_Digits then\n+                  Attr_Name := Name_Digits;\n+\n+               elsif Token = Tok_Access then\n+                  Attr_Name := Name_Access;\n+\n+               else\n+                  Error_Msg_AP (\"attribute designator expected\");\n+                  raise Error_Resync;\n+               end if;\n+\n+               if Style_Check then\n+                  Style.Check_Attribute_Name (True);\n+               end if;\n+            end if;\n+\n+            --  We come here with an OK attribute scanned, and the\n+            --  corresponding Attribute identifier node stored in Ident_Node.\n+\n+            Prefix_Node := Name_Node;\n+            Name_Node := New_Node (N_Attribute_Reference, Prev_Token_Ptr);\n+            Set_Prefix (Name_Node, Prefix_Node);\n+            Set_Attribute_Name (Name_Node, Attr_Name);\n+            Scan;\n+         end loop;\n+\n+         Rep_Clause_Node := New_Node (N_Attribute_Definition_Clause, For_Loc);\n+         Set_Name (Rep_Clause_Node, Prefix_Node);\n+         Set_Chars (Rep_Clause_Node, Attr_Name);\n+         T_Use;\n+\n+         Expr_Node := P_Expression_No_Right_Paren;\n+         Check_Simple_Expression_In_Ada_83 (Expr_Node);\n+         Set_Expression (Rep_Clause_Node, Expr_Node);\n+\n+      else\n+         TF_Use;\n+         Rep_Clause_Node := Empty;\n+\n+         --  AT follows USE (At Clause)\n+\n+         if Token = Tok_At then\n+            Scan; -- past AT\n+            Rep_Clause_Node := New_Node (N_At_Clause, For_Loc);\n+            Set_Identifier (Rep_Clause_Node, Identifier_Node);\n+            Expr_Node := P_Expression_No_Right_Paren;\n+            Check_Simple_Expression_In_Ada_83 (Expr_Node);\n+            Set_Expression (Rep_Clause_Node, Expr_Node);\n+\n+         --  RECORD follows USE (Record Representation Clause)\n+\n+         elsif Token = Tok_Record then\n+            Record_Items := P_Pragmas_Opt;\n+            Rep_Clause_Node :=\n+              New_Node (N_Record_Representation_Clause, For_Loc);\n+            Set_Identifier (Rep_Clause_Node, Identifier_Node);\n+\n+            Push_Scope_Stack;\n+            Scope.Table (Scope.Last).Etyp := E_Record;\n+            Scope.Table (Scope.Last).Ecol := Start_Column;\n+            Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+            Scan; -- past RECORD\n+            Record_Items := P_Pragmas_Opt;\n+\n+            --  Possible Mod Clause\n+\n+            if Token = Tok_At then\n+               Set_Mod_Clause (Rep_Clause_Node, P_Mod_Clause);\n+               Set_Pragmas_Before (Mod_Clause (Rep_Clause_Node), Record_Items);\n+               Record_Items := P_Pragmas_Opt;\n+            end if;\n+\n+            if No (Record_Items) then\n+               Record_Items := New_List;\n+            end if;\n+\n+            Set_Component_Clauses (Rep_Clause_Node, Record_Items);\n+\n+            --  Loop through component clauses\n+\n+            loop\n+               if Token not in Token_Class_Name then\n+                  exit when Check_End;\n+               end if;\n+\n+               Append (P_Component_Clause, Record_Items);\n+               P_Pragmas_Opt (Record_Items);\n+            end loop;\n+\n+         --  Left paren follows USE (Enumeration Representation Clause)\n+\n+         elsif Token = Tok_Left_Paren then\n+            Rep_Clause_Node :=\n+              New_Node (N_Enumeration_Representation_Clause, For_Loc);\n+            Set_Identifier (Rep_Clause_Node, Identifier_Node);\n+            Set_Array_Aggregate (Rep_Clause_Node, P_Aggregate);\n+\n+         --  Some other token follows FOR (invalid representation clause)\n+\n+         else\n+            Error_Msg_SC (\"invalid representation clause\");\n+            raise Error_Resync;\n+         end if;\n+      end if;\n+\n+      TF_Semicolon;\n+      return Rep_Clause_Node;\n+\n+   exception\n+      when Error_Resync =>\n+         Resync_Past_Semicolon;\n+         return Error;\n+\n+   end P_Representation_Clause;\n+\n+   ----------------------\n+   -- 13.1  Local Name --\n+   ----------------------\n+\n+   --  Local name is always parsed by its parent. In the case of its use in\n+   --  pragmas, the check for a local name is handled in Par.Prag and allows\n+   --  all the possible forms of local name. For the uses in chapter 13, we\n+   --  currently only allow a direct name, but this should probably change???\n+\n+   ---------------------------\n+   -- 13.1  At Clause (I.7) --\n+   ---------------------------\n+\n+   --  Parsed by P_Representation_Clause (13.1)\n+\n+   ---------------------------------------\n+   -- 13.3  Attribute Definition Clause --\n+   ---------------------------------------\n+\n+   --  Parsed by P_Representation_Clause (13.1)\n+\n+   ---------------------------------------------\n+   -- 13.4  Enumeration Representation Clause --\n+   ---------------------------------------------\n+\n+   --  Parsed by P_Representation_Clause (13.1)\n+\n+   ---------------------------------\n+   -- 13.4  Enumeration Aggregate --\n+   ---------------------------------\n+\n+   --  Parsed by P_Representation_Clause (13.1)\n+\n+   ------------------------------------------\n+   -- 13.5.1  Record Representation Clause --\n+   ------------------------------------------\n+\n+   --  Parsed by P_Representation_Clause (13.1)\n+\n+   ------------------------------\n+   -- 13.5.1  Mod Clause (I.8) --\n+   ------------------------------\n+\n+   --  MOD_CLAUSE ::= at mod static_EXPRESSION;\n+\n+   --  Note: in Ada 83, the expression must be a simple expression\n+\n+   --  The caller has checked that the initial Token is AT\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   --  Note: the caller is responsible for setting the Pragmas_Before field\n+\n+   function P_Mod_Clause return Node_Id is\n+      Mod_Node  : Node_Id;\n+      Expr_Node : Node_Id;\n+\n+   begin\n+      Mod_Node := New_Node (N_Mod_Clause, Token_Ptr);\n+      Scan; -- past AT\n+      T_Mod;\n+      Expr_Node := P_Expression_No_Right_Paren;\n+      Check_Simple_Expression_In_Ada_83 (Expr_Node);\n+      Set_Expression (Mod_Node, Expr_Node);\n+      TF_Semicolon;\n+      return Mod_Node;\n+   end P_Mod_Clause;\n+\n+   ------------------------------\n+   -- 13.5.1  Component Clause --\n+   ------------------------------\n+\n+   --  COMPONENT_CLAUSE ::=\n+   --    COMPONENT_CLAUSE_COMPONENT_NAME at POSITION\n+   --      range FIRST_BIT .. LAST_BIT;\n+\n+   --  COMPONENT_CLAUSE_COMPONENT_NAME ::=\n+   --    component_DIRECT_NAME\n+   --  | component_DIRECT_NAME'ATTRIBUTE_DESIGNATOR\n+   --  | FIRST_SUBTYPE_DIRECT_NAME'ATTRIBUTE_DESIGNATOR\n+\n+   --  POSITION ::= static_EXPRESSION\n+\n+   --  Note: in Ada 83, the expression must be a simple expression\n+\n+   --  FIRST_BIT ::= static_SIMPLE_EXPRESSION\n+   --  LAST_BIT ::= static_SIMPLE_EXPRESSION\n+\n+   --  Note: the AARM V2.0 grammar has an error at this point, it uses\n+   --  EXPRESSION instead of SIMPLE_EXPRESSION for FIRST_BIT and LAST_BIT\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Component_Clause return Node_Id is\n+      Component_Node : Node_Id;\n+      Comp_Name      : Node_Id;\n+      Expr_Node      : Node_Id;\n+\n+   begin\n+      Component_Node := New_Node (N_Component_Clause, Token_Ptr);\n+      Comp_Name := P_Name;\n+\n+      if Nkind (Comp_Name) = N_Identifier\n+        or else Nkind (Comp_Name) = N_Attribute_Reference\n+      then\n+         Set_Component_Name (Component_Node, Comp_Name);\n+      else\n+         Error_Msg_N\n+           (\"component name must be direct name or attribute\", Comp_Name);\n+         Set_Component_Name (Component_Node, Error);\n+      end if;\n+\n+      Set_Sloc (Component_Node, Token_Ptr);\n+      T_At;\n+      Expr_Node := P_Expression_No_Right_Paren;\n+      Check_Simple_Expression_In_Ada_83 (Expr_Node);\n+      Set_Position (Component_Node, Expr_Node);\n+      T_Range;\n+      Expr_Node := P_Expression_No_Right_Paren;\n+      Check_Simple_Expression_In_Ada_83 (Expr_Node);\n+      Set_First_Bit (Component_Node, Expr_Node);\n+      T_Dot_Dot;\n+      Expr_Node := P_Expression_No_Right_Paren;\n+      Check_Simple_Expression_In_Ada_83 (Expr_Node);\n+      Set_Last_Bit (Component_Node, Expr_Node);\n+      TF_Semicolon;\n+      return Component_Node;\n+   end P_Component_Clause;\n+\n+   ----------------------\n+   -- 13.5.1  Position --\n+   ----------------------\n+\n+   --  Parsed by P_Component_Clause (13.5.1)\n+\n+   -----------------------\n+   -- 13.5.1  First Bit --\n+   -----------------------\n+\n+   --  Parsed by P_Component_Clause (13.5.1)\n+\n+   ----------------------\n+   -- 13.5.1  Last Bit --\n+   ----------------------\n+\n+   --  Parsed by P_Component_Clause (13.5.1)\n+\n+   --------------------------\n+   -- 13.8  Code Statement --\n+   --------------------------\n+\n+   --  CODE_STATEMENT ::= QUALIFIED_EXPRESSION\n+\n+   --  On entry the caller has scanned the SUBTYPE_MARK (passed in as the\n+   --  single argument, and the scan points to the apostrophe.\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Code_Statement (Subtype_Mark : Node_Id) return Node_Id is\n+      Node1 : Node_Id;\n+\n+   begin\n+      Scan; -- past apostrophe\n+\n+      --  If left paren, then we have a possible code statement\n+\n+      if Token = Tok_Left_Paren then\n+         Node1 := New_Node (N_Code_Statement, Sloc (Subtype_Mark));\n+         Set_Expression (Node1, P_Qualified_Expression (Subtype_Mark));\n+         TF_Semicolon;\n+         return Node1;\n+\n+      --  Otherwise we have an illegal range attribute. Note that P_Name\n+      --  ensures that Token = Tok_Range is the only possibility left here.\n+\n+      else -- Token = Tok_Range\n+         Error_Msg_SC (\"RANGE attribute illegal here!\");\n+         raise Error_Resync;\n+      end if;\n+\n+   end P_Code_Statement;\n+\n+end Ch13;"}, {"sha": "0eeacead811324c8a82fe11d1fa483ec9b4ddd47", "filename": "gcc/ada/par-ch2.adb", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch2.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,405 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P A R . C H 2                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.35 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Style_Checks (All_Checks);\n+--  Turn off subprogram body ordering check. Subprograms are in order\n+--  by RM section rather than alphabetical\n+\n+separate (Par)\n+package body Ch2 is\n+\n+   --  Local functions, used only in this chapter\n+\n+   function P_Pragma_Argument_Association return Node_Id;\n+\n+   ---------------------\n+   -- 2.3  Identifier --\n+   ---------------------\n+\n+   --  IDENTIFIER ::= LETTER {[UNDERLINE] LETTER_OR_DIGIT}\n+\n+   --  LETTER_OR_DIGIT ::= IDENTIFIER_LETTER | DIGIT\n+\n+   --  An IDENTIFIER shall not be a reserved word\n+\n+   --  Error recovery: can raise Error_Resync (cannot return Error)\n+\n+   function P_Identifier return Node_Id is\n+      Ident_Node : Node_Id;\n+\n+   begin\n+      --  All set if we do indeed have an identifier\n+\n+      if Token = Tok_Identifier then\n+         Ident_Node := Token_Node;\n+         Scan; -- past Identifier\n+         return Ident_Node;\n+\n+      --  If we have a reserved identifier, manufacture an identifier with\n+      --  a corresponding name after posting an appropriate error message\n+\n+      elsif Is_Reserved_Identifier then\n+         Scan_Reserved_Identifier (Force_Msg => False);\n+         Ident_Node := Token_Node;\n+         Scan; -- past the node\n+         return Ident_Node;\n+\n+      --  Otherwise we have junk that cannot be interpreted as an identifier\n+\n+      else\n+         T_Identifier; -- to give message\n+         raise Error_Resync;\n+      end if;\n+   end P_Identifier;\n+\n+   --------------------------\n+   -- 2.3  Letter Or Digit --\n+   --------------------------\n+\n+   --  Parsed by P_Identifier (2.3)\n+\n+   --------------------------\n+   -- 2.4  Numeric Literal --\n+   --------------------------\n+\n+   --  NUMERIC_LITERAL ::= DECIMAL_LITERAL | BASED_LITERAL\n+\n+   --  Numeric literal is returned by the scanner as either\n+   --  Tok_Integer_Literal or Tok_Real_Literal\n+\n+   ----------------------------\n+   -- 2.4.1  Decimal Literal --\n+   ----------------------------\n+\n+   --  DECIMAL_LITERAL ::= NUMERAL [.NUMERAL] [EXPONENT]\n+\n+   --  Handled by scanner as part of numeric lIteral handing (see 2.4)\n+\n+   --------------------\n+   -- 2.4.1  Numeral --\n+   --------------------\n+\n+   --  NUMERAL ::= DIGIT {[UNDERLINE] DIGIT}\n+\n+   --  Handled by scanner as part of numeric literal handling (see 2.4)\n+\n+   ---------------------\n+   -- 2.4.1  Exponent --\n+   ---------------------\n+\n+   --  EXPONENT ::= E [+] NUMERAL | E - NUMERAL\n+\n+   --  Handled by scanner as part of numeric literal handling (see 2.4)\n+\n+   --------------------------\n+   -- 2.4.2  Based Literal --\n+   --------------------------\n+\n+   --  BASED_LITERAL ::=\n+   --   BASE # BASED_NUMERAL [.BASED_NUMERAL] # [EXPONENT]\n+\n+   --  Handled by scanner as part of numeric literal handling (see 2.4)\n+\n+   -----------------\n+   -- 2.4.2  Base --\n+   -----------------\n+\n+   --  BASE ::= NUMERAL\n+\n+   --  Handled by scanner as part of numeric literal handling (see 2.4)\n+\n+   --------------------------\n+   -- 2.4.2  Based Numeral --\n+   --------------------------\n+\n+   --  BASED_NUMERAL ::=\n+   --    EXTENDED_DIGIT {[UNDERLINE] EXTENDED_DIGIT}\n+\n+   --  Handled by scanner as part of numeric literal handling (see 2.4)\n+\n+   ---------------------------\n+   -- 2.4.2  Extended Digit --\n+   ---------------------------\n+\n+   --  EXTENDED_DIGIT ::= DIGIT | A | B | C | D | E | F\n+\n+   --  Handled by scanner as part of numeric literal handling (see 2.4)\n+\n+   ----------------------------\n+   -- 2.5  Character Literal --\n+   ----------------------------\n+\n+   --  CHARACTER_LITERAL ::= ' GRAPHIC_CHARACTER '\n+\n+   --  Handled by the scanner and returned as Tok_Character_Literal\n+\n+   -------------------------\n+   -- 2.6  String Literal --\n+   -------------------------\n+\n+   --  STRING LITERAL ::= \"{STRING_ELEMENT}\"\n+\n+   --  Handled by the scanner and returned as Tok_Character_Literal\n+   --  or if the string looks like an operator as Tok_Operator_Symbol.\n+\n+   -------------------------\n+   -- 2.6  String Element --\n+   -------------------------\n+\n+   --  STRING_ELEMENT ::= \"\" | non-quotation_mark_GRAPHIC_CHARACTER\n+\n+   --  A STRING_ELEMENT is either a pair of quotation marks (\"),\n+   --  or a single GRAPHIC_CHARACTER other than a quotation mark.\n+\n+   --  Handled by scanner as part of string literal handling (see 2.4)\n+\n+   ------------------\n+   -- 2.7  Comment --\n+   ------------------\n+\n+   --  A COMMENT starts with two adjacent hyphens and extends up to the\n+   --  end of the line. A COMMENT may appear on any line of a program.\n+\n+   --  Handled by the scanner which simply skips past encountered comments\n+\n+   -----------------\n+   -- 2.8  Pragma --\n+   -----------------\n+\n+   --  PRAGMA ::= pragma IDENTIFIER\n+   --    [(PRAGMA_ARGUMENT_ASSOCIATION {, PRAGMA_ARGUMENT_ASSOCIATION})];\n+\n+   --  The caller has checked that the initial token is PRAGMA\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   --  One special piece of processing is needed in this routine. As described\n+   --  in the section on \"Handling semicolon used in place of IS\" in module\n+   --  Parse, the parser detects the case of missing subprogram bodies to\n+   --  allow recovery from this syntactic error. Pragma INTERFACE (and, for\n+   --  Ada 95, pragma IMPORT) can appear in place of the body. The parser must\n+   --  recognize the use of these two pragmas in this context, otherwise it\n+   --  will think there are missing bodies, and try to change ; to IS, when\n+   --  in fact the bodies ARE present, supplied by these pragmas.\n+\n+   function P_Pragma return Node_Id is\n+\n+      Interface_Check_Required : Boolean := False;\n+      --  Set True if check of pragma INTERFACE is required\n+\n+      Import_Check_Required : Boolean := False;\n+      --  Set True if check of pragma IMPORT is required\n+\n+      Arg_Count : Int := 0;\n+      --  Number of argument associations processed\n+\n+      Pragma_Node   : Node_Id;\n+      Pragma_Name   : Name_Id;\n+      Semicolon_Loc : Source_Ptr;\n+      Ident_Node    : Node_Id;\n+      Assoc_Node    : Node_Id;\n+\n+   begin\n+      Pragma_Node := New_Node (N_Pragma, Token_Ptr);\n+      Scan; -- past PRAGMA\n+      Pragma_Name := Token_Name;\n+\n+      if Style_Check then\n+         Style.Check_Pragma_Name;\n+      end if;\n+\n+      Ident_Node := P_Identifier;\n+      Set_Chars (Pragma_Node, Pragma_Name);\n+      Delete_Node (Ident_Node);\n+\n+      --  See if special INTERFACE/IMPORT check is required\n+\n+      if SIS_Entry_Active then\n+         Interface_Check_Required := (Pragma_Name = Name_Interface);\n+         Import_Check_Required    := (Pragma_Name = Name_Import);\n+      else\n+         Interface_Check_Required := False;\n+         Import_Check_Required    := False;\n+      end if;\n+\n+      --  Scan arguments. We assume that arguments are present if there is\n+      --  a left paren, or if a semicolon is missing and there is another\n+      --  token on the same line as the pragma name.\n+\n+      if Token = Tok_Left_Paren\n+        or else (Token /= Tok_Semicolon\n+                   and then not Token_Is_At_Start_Of_Line)\n+      then\n+         Set_Pragma_Argument_Associations (Pragma_Node, New_List);\n+         T_Left_Paren;\n+\n+         loop\n+            Arg_Count := Arg_Count + 1;\n+            Assoc_Node := P_Pragma_Argument_Association;\n+\n+            if Arg_Count = 2\n+              and then (Interface_Check_Required or else Import_Check_Required)\n+            then\n+               --  Here is where we cancel the SIS active status if this pragma\n+               --  supplies a body for the currently active subprogram spec.\n+\n+               if Nkind (Expression (Assoc_Node)) in N_Direct_Name\n+                 and then Chars (Expression (Assoc_Node)) = Chars (SIS_Labl)\n+               then\n+                  SIS_Entry_Active := False;\n+               end if;\n+            end if;\n+\n+            Append (Assoc_Node, Pragma_Argument_Associations (Pragma_Node));\n+            exit when Token /= Tok_Comma;\n+            Scan; -- past comma\n+         end loop;\n+\n+         T_Right_Paren;\n+      end if;\n+\n+      Semicolon_Loc := Token_Ptr;\n+\n+      if Token /= Tok_Semicolon then\n+         T_Semicolon;\n+         Resync_Past_Semicolon;\n+      else\n+         Scan; -- past semicolon\n+      end if;\n+\n+      if Is_Pragma_Name (Chars (Pragma_Node)) then\n+         return Par.Prag (Pragma_Node, Semicolon_Loc);\n+\n+      else\n+         --  Unrecognized pragma, warning generated in Sem_Prag\n+\n+         return Pragma_Node;\n+      end if;\n+\n+   exception\n+      when Error_Resync =>\n+         Resync_Past_Semicolon;\n+         return Error;\n+\n+   end P_Pragma;\n+\n+   --  This routine is called if a pragma is encountered in an inappropriate\n+   --  position, the pragma is scanned out and control returns to continue.\n+\n+   --  The caller has checked that the initial token is pragma\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   procedure P_Pragmas_Misplaced is\n+   begin\n+      while Token = Tok_Pragma loop\n+         Error_Msg_SC (\"pragma not allowed here\");\n+         Discard_Junk_Node (P_Pragma);\n+      end loop;\n+   end P_Pragmas_Misplaced;\n+\n+   --  This function is called to scan out an optional sequence of pragmas.\n+   --  If no pragmas are found, then No_List is returned.\n+\n+   --  Error recovery: Cannot raise Error_Resync\n+\n+   function P_Pragmas_Opt return List_Id is\n+      L : List_Id;\n+\n+   begin\n+      if Token = Tok_Pragma then\n+         L := New_List;\n+         P_Pragmas_Opt (L);\n+         return L;\n+\n+      else\n+         return No_List;\n+      end if;\n+   end P_Pragmas_Opt;\n+\n+   --  This procedure is called to scan out an optional sequence of pragmas.\n+   --  Any pragmas found are appended to the list provided as an argument.\n+\n+   --  Error recovery: Cannot raise Error_Resync\n+\n+   procedure P_Pragmas_Opt (List : List_Id) is\n+      P : Node_Id;\n+\n+   begin\n+      while Token = Tok_Pragma loop\n+         P := P_Pragma;\n+\n+         if Chars (P) = Name_Assert or else Chars (P) = Name_Debug then\n+            Error_Msg_Name_1 := Chars (P);\n+            Error_Msg_N\n+              (\"pragma% must be in declaration/statement context\", P);\n+         else\n+            Append (P, List);\n+         end if;\n+      end loop;\n+   end P_Pragmas_Opt;\n+\n+   --------------------------------------\n+   -- 2.8  Pragma_Argument Association --\n+   --------------------------------------\n+\n+   --  PRAGMA_ARGUMENT_ASSOCIATION ::=\n+   --    [pragma_argument_IDENTIFIER =>] NAME\n+   --  | [pragma_argument_IDENTIFIER =>] EXPRESSION\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Pragma_Argument_Association return Node_Id is\n+      Scan_State      : Saved_Scan_State;\n+      Pragma_Arg_Node : Node_Id;\n+      Identifier_Node : Node_Id;\n+\n+   begin\n+      Pragma_Arg_Node := New_Node (N_Pragma_Argument_Association, Token_Ptr);\n+      Set_Chars (Pragma_Arg_Node, No_Name);\n+\n+      if Token = Tok_Identifier then\n+         Identifier_Node := Token_Node;\n+         Save_Scan_State (Scan_State); -- at Identifier\n+         Scan; -- past Identifier\n+\n+         if Token = Tok_Arrow then\n+            Scan; -- past arrow\n+            Set_Chars (Pragma_Arg_Node, Chars (Identifier_Node));\n+            Delete_Node (Identifier_Node);\n+         else\n+            Restore_Scan_State (Scan_State); -- to Identifier\n+         end if;\n+      end if;\n+\n+      Set_Expression (Pragma_Arg_Node, P_Expression);\n+      return Pragma_Arg_Node;\n+\n+   end P_Pragma_Argument_Association;\n+\n+end Ch2;"}, {"sha": "937f02d0e7cbd8aee9e2b3b22877e3bdba7aa19f", "filename": "gcc/ada/par-ch3.adb", "status": "added", "additions": 3724, "deletions": 0, "changes": 3724, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "30fba5619cc895ffe8d4c85d006bec5fe5a4e1f6", "filename": "gcc/ada/par-ch4.adb", "status": "added", "additions": 2298, "deletions": 0, "changes": 2298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,2298 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P A R . C H 4                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.91 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Style_Checks (All_Checks);\n+--  Turn off subprogram body ordering check. Subprograms are in order\n+--  by RM section rather than alphabetical\n+\n+separate (Par)\n+package body Ch4 is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function P_Aggregate_Or_Paren_Expr                 return Node_Id;\n+   function P_Allocator                               return Node_Id;\n+   function P_Record_Or_Array_Component_Association   return Node_Id;\n+   function P_Factor                                  return Node_Id;\n+   function P_Primary                                 return Node_Id;\n+   function P_Relation                                return Node_Id;\n+   function P_Term                                    return Node_Id;\n+\n+   function P_Binary_Adding_Operator                  return Node_Kind;\n+   function P_Logical_Operator                        return Node_Kind;\n+   function P_Multiplying_Operator                    return Node_Kind;\n+   function P_Relational_Operator                     return Node_Kind;\n+   function P_Unary_Adding_Operator                   return Node_Kind;\n+\n+   procedure Bad_Range_Attribute (Loc : Source_Ptr);\n+   --  Called to place complaint about bad range attribute at the given\n+   --  source location. Terminates by raising Error_Resync.\n+\n+   function P_Range_Attribute_Reference\n+     (Prefix_Node : Node_Id)\n+      return        Node_Id;\n+   --  Scan a range attribute reference. The caller has scanned out the\n+   --  prefix. The current token is known to be an apostrophe and the\n+   --  following token is known to be RANGE.\n+\n+   procedure Set_Op_Name (Node : Node_Id);\n+   --  Procedure to set name field (Chars) in operator node\n+\n+   -------------------------\n+   -- Bad_Range_Attribute --\n+   -------------------------\n+\n+   procedure Bad_Range_Attribute (Loc : Source_Ptr) is\n+   begin\n+      Error_Msg (\"range attribute cannot be used in expression\", Loc);\n+      Resync_Expression;\n+   end Bad_Range_Attribute;\n+\n+   ------------------\n+   -- Set_Op_Name --\n+   ------------------\n+\n+   procedure Set_Op_Name (Node : Node_Id) is\n+      type Name_Of_Type is array (N_Op) of Name_Id;\n+      Name_Of : Name_Of_Type := Name_Of_Type'(\n+         N_Op_And                    => Name_Op_And,\n+         N_Op_Or                     => Name_Op_Or,\n+         N_Op_Xor                    => Name_Op_Xor,\n+         N_Op_Eq                     => Name_Op_Eq,\n+         N_Op_Ne                     => Name_Op_Ne,\n+         N_Op_Lt                     => Name_Op_Lt,\n+         N_Op_Le                     => Name_Op_Le,\n+         N_Op_Gt                     => Name_Op_Gt,\n+         N_Op_Ge                     => Name_Op_Ge,\n+         N_Op_Add                    => Name_Op_Add,\n+         N_Op_Subtract               => Name_Op_Subtract,\n+         N_Op_Concat                 => Name_Op_Concat,\n+         N_Op_Multiply               => Name_Op_Multiply,\n+         N_Op_Divide                 => Name_Op_Divide,\n+         N_Op_Mod                    => Name_Op_Mod,\n+         N_Op_Rem                    => Name_Op_Rem,\n+         N_Op_Expon                  => Name_Op_Expon,\n+         N_Op_Plus                   => Name_Op_Add,\n+         N_Op_Minus                  => Name_Op_Subtract,\n+         N_Op_Abs                    => Name_Op_Abs,\n+         N_Op_Not                    => Name_Op_Not,\n+\n+         --  We don't really need these shift operators, since they never\n+         --  appear as operators in the source, but the path of least\n+         --  resistance is to put them in (the aggregate must be complete)\n+\n+         N_Op_Rotate_Left            => Name_Rotate_Left,\n+         N_Op_Rotate_Right           => Name_Rotate_Right,\n+         N_Op_Shift_Left             => Name_Shift_Left,\n+         N_Op_Shift_Right            => Name_Shift_Right,\n+         N_Op_Shift_Right_Arithmetic => Name_Shift_Right_Arithmetic);\n+\n+   begin\n+      if Nkind (Node) in N_Op then\n+         Set_Chars (Node, Name_Of (Nkind (Node)));\n+      end if;\n+   end Set_Op_Name;\n+\n+   --------------------------\n+   -- 4.1  Name (also 6.4) --\n+   --------------------------\n+\n+   --  NAME ::=\n+   --    DIRECT_NAME        | EXPLICIT_DEREFERENCE\n+   --  | INDEXED_COMPONENT  | SLICE\n+   --  | SELECTED_COMPONENT | ATTRIBUTE\n+   --  | TYPE_CONVERSION    | FUNCTION_CALL\n+   --  | CHARACTER_LITERAL\n+\n+   --  DIRECT_NAME ::= IDENTIFIER | OPERATOR_SYMBOL\n+\n+   --  PREFIX ::= NAME | IMPLICIT_DEREFERENCE\n+\n+   --  EXPLICIT_DEREFERENCE ::= NAME . all\n+\n+   --  IMPLICIT_DEREFERENCE ::= NAME\n+\n+   --  INDEXED_COMPONENT ::= PREFIX (EXPRESSION {, EXPRESSION})\n+\n+   --  SLICE ::= PREFIX (DISCRETE_RANGE)\n+\n+   --  SELECTED_COMPONENT ::= PREFIX . SELECTOR_NAME\n+\n+   --  SELECTOR_NAME ::= IDENTIFIER | CHARACTER_LITERAL | OPERATOR_SYMBOL\n+\n+   --  ATTRIBUTE_REFERENCE ::= PREFIX ' ATTRIBUTE_DESIGNATOR\n+\n+   --  ATTRIBUTE_DESIGNATOR ::=\n+   --    IDENTIFIER [(static_EXPRESSION)]\n+   --  | access | delta | digits\n+\n+   --  FUNCTION_CALL ::=\n+   --    function_NAME\n+   --  | function_PREFIX ACTUAL_PARAMETER_PART\n+\n+   --  ACTUAL_PARAMETER_PART ::=\n+   --    (PARAMETER_ASSOCIATION {,PARAMETER_ASSOCIATION})\n+\n+   --  PARAMETER_ASSOCIATION ::=\n+   --    [formal_parameter_SELECTOR_NAME =>] EXPLICIT_ACTUAL_PARAMETER\n+\n+   --  EXPLICIT_ACTUAL_PARAMETER ::= EXPRESSION | variable_NAME\n+\n+   --  Note: syntactically a procedure call looks just like a function call,\n+   --  so this routine is in practice used to scan out procedure calls as well.\n+\n+   --  On return, Expr_Form is set to either EF_Name or EF_Simple_Name\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   --  Note: if on return Token = Tok_Apostrophe, then the apostrophe must be\n+   --  followed by either a left paren (qualified expression case), or by\n+   --  range (range attribute case). All other uses of apostrophe (i.e. all\n+   --  other attributes) are handled in this routine.\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Name return Node_Id is\n+      Scan_State  : Saved_Scan_State;\n+      Name_Node   : Node_Id;\n+      Prefix_Node : Node_Id;\n+      Ident_Node  : Node_Id;\n+      Expr_Node   : Node_Id;\n+      Range_Node  : Node_Id;\n+      Arg_Node    : Node_Id;\n+\n+      Arg_List  : List_Id := No_List; -- kill junk warning\n+      Attr_Name : Name_Id := No_Name; -- kill junk warning\n+\n+   begin\n+      if Token not in Token_Class_Name then\n+         Error_Msg_AP (\"name expected\");\n+         raise Error_Resync;\n+      end if;\n+\n+      --  Loop through designators in qualified name\n+\n+      Name_Node := Token_Node;\n+\n+      loop\n+         Scan; -- past designator\n+         exit when Token /= Tok_Dot;\n+         Save_Scan_State (Scan_State); -- at dot\n+         Scan; -- past dot\n+\n+         --  If we do not have another designator after the dot, then join\n+         --  the normal circuit to handle a dot extension (may be .all or\n+         --  character literal case). Otherwise loop back to scan the next\n+         --  designator.\n+\n+         if Token not in Token_Class_Desig then\n+            goto Scan_Name_Extension_Dot;\n+         else\n+            Prefix_Node := Name_Node;\n+            Name_Node := New_Node (N_Selected_Component, Prev_Token_Ptr);\n+            Set_Prefix (Name_Node, Prefix_Node);\n+            Set_Selector_Name (Name_Node, Token_Node);\n+         end if;\n+      end loop;\n+\n+      --  We have now scanned out a qualified designator. If the last token is\n+      --  an operator symbol, then we certainly do not have the Snam case, so\n+      --  we can just use the normal name extension check circuit\n+\n+      if Prev_Token = Tok_Operator_Symbol then\n+         goto Scan_Name_Extension;\n+      end if;\n+\n+      --  We have scanned out a qualified simple name, check for name extension\n+      --  Note that we know there is no dot here at this stage, so the only\n+      --  possible cases of name extension are apostrophe and left paren.\n+\n+      if Token = Tok_Apostrophe then\n+         Save_Scan_State (Scan_State); -- at apostrophe\n+         Scan; -- past apostrophe\n+\n+         --  If left paren, then this might be a qualified expression, but we\n+         --  are only in the business of scanning out names, so return with\n+         --  Token backed up to point to the apostrophe. The treatment for\n+         --  the range attribute is similar (we do not consider x'range to\n+         --  be a name in this grammar).\n+\n+         if Token = Tok_Left_Paren or else Token = Tok_Range then\n+            Restore_Scan_State (Scan_State); -- to apostrophe\n+            Expr_Form := EF_Simple_Name;\n+            return Name_Node;\n+\n+         --  Otherwise we have the case of a name extended by an attribute\n+\n+         else\n+            goto Scan_Name_Extension_Apostrophe;\n+         end if;\n+\n+      --  Check case of qualified simple name extended by a left parenthesis\n+\n+      elsif Token = Tok_Left_Paren then\n+         Scan; -- past left paren\n+         goto Scan_Name_Extension_Left_Paren;\n+\n+      --  Otherwise the qualified simple name is not extended, so return\n+\n+      else\n+         Expr_Form := EF_Simple_Name;\n+         return Name_Node;\n+      end if;\n+\n+      --  Loop scanning past name extensions. A label is used for control\n+      --  transfer for this loop for ease of interfacing with the finite state\n+      --  machine in the parenthesis scanning circuit, and also to allow for\n+      --  passing in control to the appropriate point from the above code.\n+\n+      <<Scan_Name_Extension>>\n+\n+         --  Character literal used as name cannot be extended. Also this\n+         --  cannot be a call, since the name for a call must be a designator.\n+         --  Return in these cases, or if there is no name extension\n+\n+         if Token not in Token_Class_Namext\n+           or else Prev_Token = Tok_Char_Literal\n+         then\n+            Expr_Form := EF_Name;\n+            return Name_Node;\n+         end if;\n+\n+      --  Merge here when we know there is a name extension\n+\n+      <<Scan_Name_Extension_OK>>\n+\n+         if Token = Tok_Left_Paren then\n+            Scan; -- past left paren\n+            goto Scan_Name_Extension_Left_Paren;\n+\n+         elsif Token = Tok_Apostrophe then\n+            Save_Scan_State (Scan_State); -- at apostrophe\n+            Scan; -- past apostrophe\n+            goto Scan_Name_Extension_Apostrophe;\n+\n+         else -- Token = Tok_Dot\n+            Save_Scan_State (Scan_State); -- at dot\n+            Scan; -- past dot\n+            goto Scan_Name_Extension_Dot;\n+         end if;\n+\n+      --  Case of name extended by dot (selection), dot is already skipped\n+      --  and the scan state at the point of the dot is saved in Scan_State.\n+\n+      <<Scan_Name_Extension_Dot>>\n+\n+         --  Explicit dereference case\n+\n+         if Token = Tok_All then\n+            Prefix_Node := Name_Node;\n+            Name_Node := New_Node (N_Explicit_Dereference, Token_Ptr);\n+            Set_Prefix (Name_Node, Prefix_Node);\n+            Scan; -- past ALL\n+            goto Scan_Name_Extension;\n+\n+         --  Selected component case\n+\n+         elsif Token in Token_Class_Name then\n+            Prefix_Node := Name_Node;\n+            Name_Node := New_Node (N_Selected_Component, Prev_Token_Ptr);\n+            Set_Prefix (Name_Node, Prefix_Node);\n+            Set_Selector_Name (Name_Node, Token_Node);\n+            Scan; -- past selector\n+            goto Scan_Name_Extension;\n+\n+         --  Reserved identifier as selector\n+\n+         elsif Is_Reserved_Identifier then\n+            Scan_Reserved_Identifier (Force_Msg => False);\n+            Prefix_Node := Name_Node;\n+            Name_Node := New_Node (N_Selected_Component, Prev_Token_Ptr);\n+            Set_Prefix (Name_Node, Prefix_Node);\n+            Set_Selector_Name (Name_Node, Token_Node);\n+            Scan; -- past identifier used as selector\n+            goto Scan_Name_Extension;\n+\n+         --  If dot is at end of line and followed by nothing legal,\n+         --  then assume end of name and quit (dot will be taken as\n+         --  an erroneous form of some other punctuation by our caller).\n+\n+         elsif Token_Is_At_Start_Of_Line then\n+            Restore_Scan_State (Scan_State);\n+            return Name_Node;\n+\n+         --  Here if nothing legal after the dot\n+\n+         else\n+            Error_Msg_AP (\"selector expected\");\n+            raise Error_Resync;\n+         end if;\n+\n+      --  Here for an apostrophe as name extension. The scan position at the\n+      --  apostrophe has already been saved, and the apostrophe scanned out.\n+\n+      <<Scan_Name_Extension_Apostrophe>>\n+\n+         Scan_Apostrophe : declare\n+            function Apostrophe_Should_Be_Semicolon return Boolean;\n+            --  Checks for case where apostrophe should probably be\n+            --  a semicolon, and if so, gives appropriate message,\n+            --  resets the scan pointer to the apostrophe, changes\n+            --  the current token to Tok_Semicolon, and returns True.\n+            --  Otherwise returns False.\n+\n+            function Apostrophe_Should_Be_Semicolon return Boolean is\n+            begin\n+               if Token_Is_At_Start_Of_Line then\n+                  Restore_Scan_State (Scan_State); -- to apostrophe\n+                  Error_Msg_SC (\"\"\"''\"\" should be \"\";\"\"\");\n+                  Token := Tok_Semicolon;\n+                  return True;\n+               else\n+                  return False;\n+               end if;\n+            end Apostrophe_Should_Be_Semicolon;\n+\n+         --  Start of processing for Scan_Apostrophe\n+\n+         begin\n+            --  If range attribute after apostrophe, then return with Token\n+            --  pointing to the apostrophe. Note that in this case the prefix\n+            --  need not be a simple name (cases like A.all'range). Similarly\n+            --  if there is a left paren after the apostrophe, then we also\n+            --  return with Token pointing to the apostrophe (this is the\n+            --  qualified expression case).\n+\n+            if Token = Tok_Range or else Token = Tok_Left_Paren then\n+               Restore_Scan_State (Scan_State); -- to apostrophe\n+               Expr_Form := EF_Name;\n+               return Name_Node;\n+\n+            --  Here for cases where attribute designator is an identifier\n+\n+            elsif Token = Tok_Identifier then\n+               Attr_Name := Token_Name;\n+\n+               if not Is_Attribute_Name (Attr_Name) then\n+                  if Apostrophe_Should_Be_Semicolon then\n+                     Expr_Form := EF_Name;\n+                     return Name_Node;\n+                  else\n+                     Signal_Bad_Attribute;\n+                  end if;\n+               end if;\n+\n+               if Style_Check then\n+                  Style.Check_Attribute_Name (False);\n+               end if;\n+\n+               Delete_Node (Token_Node);\n+\n+            --  Here for case of attribute designator is not an identifier\n+\n+            else\n+               if Token = Tok_Delta then\n+                  Attr_Name := Name_Delta;\n+\n+               elsif Token = Tok_Digits then\n+                  Attr_Name := Name_Digits;\n+\n+               elsif Token = Tok_Access then\n+                  Attr_Name := Name_Access;\n+\n+               elsif Apostrophe_Should_Be_Semicolon then\n+                  Expr_Form := EF_Name;\n+                  return Name_Node;\n+\n+               else\n+                  Error_Msg_AP (\"attribute designator expected\");\n+                  raise Error_Resync;\n+               end if;\n+\n+               if Style_Check then\n+                  Style.Check_Attribute_Name (True);\n+               end if;\n+            end if;\n+\n+            --  We come here with an OK attribute scanned, and the\n+            --  corresponding Attribute identifier node stored in Ident_Node.\n+\n+            Prefix_Node := Name_Node;\n+            Name_Node := New_Node (N_Attribute_Reference, Prev_Token_Ptr);\n+            Scan; -- past attribute designator\n+            Set_Prefix (Name_Node, Prefix_Node);\n+            Set_Attribute_Name (Name_Node, Attr_Name);\n+\n+            --  Scan attribute arguments/designator\n+\n+            if Token = Tok_Left_Paren then\n+               Set_Expressions (Name_Node, New_List);\n+               Scan; -- past left paren\n+\n+               loop\n+                  declare\n+                     Expr : constant Node_Id := P_Expression;\n+\n+                  begin\n+                     if Token = Tok_Arrow then\n+                        Error_Msg_SC\n+                          (\"named parameters not permitted for attributes\");\n+                        Scan; -- past junk arrow\n+\n+                     else\n+                        Append (Expr, Expressions (Name_Node));\n+                        exit when not Comma_Present;\n+                     end if;\n+                  end;\n+               end loop;\n+\n+               T_Right_Paren;\n+            end if;\n+\n+            goto Scan_Name_Extension;\n+         end Scan_Apostrophe;\n+\n+      --  Here for left parenthesis extending name (left paren skipped)\n+\n+      <<Scan_Name_Extension_Left_Paren>>\n+\n+         --  We now have to scan through a list of items, terminated by a\n+         --  right parenthesis. The scan is handled by a finite state\n+         --  machine. The possibilities are:\n+\n+         --   (discrete_range)\n+\n+         --      This is a slice. This case is handled in LP_State_Init.\n+\n+         --   (expression, expression, ..)\n+\n+         --      This is interpreted as an indexed component, i.e. as a\n+         --      case of a name which can be extended in the normal manner.\n+         --      This case is handled by LP_State_Name or LP_State_Expr.\n+\n+         --   (..., identifier => expression , ...)\n+\n+         --      If there is at least one occurence of identifier => (but\n+         --      none of the other cases apply), then we have a call.\n+\n+         --  Test for Id => case\n+\n+         if Token = Tok_Identifier then\n+            Save_Scan_State (Scan_State); -- at Id\n+            Scan; -- past Id\n+\n+            --  Test for => (allow := as an error substitute)\n+\n+            if Token = Tok_Arrow or else Token = Tok_Colon_Equal then\n+               Restore_Scan_State (Scan_State); -- to Id\n+               Arg_List := New_List;\n+               goto LP_State_Call;\n+\n+            else\n+               Restore_Scan_State (Scan_State); -- to Id\n+            end if;\n+         end if;\n+\n+         --  Here we have an expression after all\n+\n+         Expr_Node := P_Expression_Or_Range_Attribute;\n+\n+         --  Check cases of discrete range for a slice\n+\n+         --  First possibility: Range_Attribute_Reference\n+\n+         if Expr_Form = EF_Range_Attr then\n+            Range_Node := Expr_Node;\n+\n+         --  Second possibility: Simple_expression .. Simple_expression\n+\n+         elsif Token = Tok_Dot_Dot then\n+            Check_Simple_Expression (Expr_Node);\n+            Range_Node := New_Node (N_Range, Token_Ptr);\n+            Set_Low_Bound (Range_Node, Expr_Node);\n+            Scan; -- past ..\n+            Expr_Node := P_Expression;\n+            Check_Simple_Expression (Expr_Node);\n+            Set_High_Bound (Range_Node, Expr_Node);\n+\n+         --  Third possibility: Type_name range Range\n+\n+         elsif Token = Tok_Range then\n+            if Expr_Form /= EF_Simple_Name then\n+               Error_Msg_SC (\"subtype mark must precede RANGE\");\n+               raise Error_Resync;\n+            end if;\n+\n+            Range_Node := P_Subtype_Indication (Expr_Node);\n+\n+         --  Otherwise we just have an expression. It is true that we might\n+         --  have a subtype mark without a range constraint but this case\n+         --  is syntactically indistinguishable from the expression case.\n+\n+         else\n+            Arg_List := New_List;\n+            goto LP_State_Expr;\n+         end if;\n+\n+         --  Fall through here with unmistakable Discrete range scanned,\n+         --  which means that we definitely have the case of a slice. The\n+         --  Discrete range is in Range_Node.\n+\n+         if Token = Tok_Comma then\n+            Error_Msg_SC (\"slice cannot have more than one dimension\");\n+            raise Error_Resync;\n+\n+         elsif Token /= Tok_Right_Paren then\n+            T_Right_Paren;\n+            raise Error_Resync;\n+\n+         else\n+            Scan; -- past right paren\n+            Prefix_Node := Name_Node;\n+            Name_Node := New_Node (N_Slice, Sloc (Prefix_Node));\n+            Set_Prefix (Name_Node, Prefix_Node);\n+            Set_Discrete_Range (Name_Node, Range_Node);\n+\n+            --  An operator node is legal as a prefix to other names,\n+            --  but not for a slice.\n+\n+            if Nkind (Prefix_Node) = N_Operator_Symbol then\n+               Error_Msg_N (\"illegal prefix for slice\", Prefix_Node);\n+            end if;\n+\n+            --  If we have a name extension, go scan it\n+\n+            if Token in Token_Class_Namext then\n+               goto Scan_Name_Extension_OK;\n+\n+            --  Otherwise return (a slice is a name, but is not a call)\n+\n+            else\n+               Expr_Form := EF_Name;\n+               return Name_Node;\n+            end if;\n+         end if;\n+\n+      --  In LP_State_Expr, we have scanned one or more expressions, and\n+      --  so we have a call or an indexed component which is a name. On\n+      --  entry we have the expression just scanned in Expr_Node and\n+      --  Arg_List contains the list of expressions encountered so far\n+\n+      <<LP_State_Expr>>\n+         Append (Expr_Node, Arg_List);\n+\n+         if Token = Tok_Arrow then\n+            Error_Msg\n+              (\"expect identifier in parameter association\",\n+                Sloc (Expr_Node));\n+            Scan;  --   past arrow.\n+\n+         elsif not Comma_Present then\n+            T_Right_Paren;\n+            Prefix_Node := Name_Node;\n+            Name_Node := New_Node (N_Indexed_Component, Sloc (Prefix_Node));\n+            Set_Prefix (Name_Node, Prefix_Node);\n+            Set_Expressions (Name_Node, Arg_List);\n+            goto Scan_Name_Extension;\n+         end if;\n+\n+         --  Comma present (and scanned out), test for identifier => case\n+         --  Test for identifer => case\n+\n+         if Token = Tok_Identifier then\n+            Save_Scan_State (Scan_State); -- at Id\n+            Scan; -- past Id\n+\n+            --  Test for => (allow := as error substitute)\n+\n+            if Token = Tok_Arrow or else Token = Tok_Colon_Equal then\n+               Restore_Scan_State (Scan_State); -- to Id\n+               goto LP_State_Call;\n+\n+            --  Otherwise it's just an expression after all, so backup\n+\n+            else\n+               Restore_Scan_State (Scan_State); -- to Id\n+            end if;\n+         end if;\n+\n+         --  Here we have an expression after all, so stay in this state\n+\n+         Expr_Node := P_Expression;\n+         goto LP_State_Expr;\n+\n+      --  LP_State_Call corresponds to the situation in which at least\n+      --  one instance of Id => Expression has been encountered, so we\n+      --  know that we do not have a name, but rather a call. We enter\n+      --  it with the scan pointer pointing to the next argument to scan,\n+      --  and Arg_List containing the list of arguments scanned so far.\n+\n+      <<LP_State_Call>>\n+\n+         --  Test for case of Id => Expression (named parameter)\n+\n+         if Token = Tok_Identifier then\n+            Save_Scan_State (Scan_State); -- at Id\n+            Ident_Node := Token_Node;\n+            Scan; -- past Id\n+\n+            --  Deal with => (allow := as erroneous substitute)\n+\n+            if Token = Tok_Arrow or else Token = Tok_Colon_Equal then\n+               Arg_Node :=\n+                 New_Node (N_Parameter_Association, Prev_Token_Ptr);\n+               Set_Selector_Name (Arg_Node, Ident_Node);\n+               T_Arrow;\n+               Set_Explicit_Actual_Parameter (Arg_Node, P_Expression);\n+               Append (Arg_Node, Arg_List);\n+\n+               --  If a comma follows, go back and scan next entry\n+\n+               if Comma_Present then\n+                  goto LP_State_Call;\n+\n+               --  Otherwise we have the end of a call\n+\n+               else\n+                  Prefix_Node := Name_Node;\n+                  Name_Node :=\n+                    New_Node (N_Function_Call, Sloc (Prefix_Node));\n+                  Set_Name (Name_Node, Prefix_Node);\n+                  Set_Parameter_Associations (Name_Node, Arg_List);\n+                  T_Right_Paren;\n+\n+                  if Token in Token_Class_Namext then\n+                     goto Scan_Name_Extension_OK;\n+\n+                  --  This is a case of a call which cannot be a name\n+\n+                  else\n+                     Expr_Form := EF_Name;\n+                     return Name_Node;\n+                  end if;\n+               end if;\n+\n+            --  Not named parameter: Id started an expression after all\n+\n+            else\n+               Restore_Scan_State (Scan_State); -- to Id\n+            end if;\n+         end if;\n+\n+         --  Here if entry did not start with Id => which means that it\n+         --  is a positional parameter, which is not allowed, since we\n+         --  have seen at least one named parameter already.\n+\n+         Error_Msg_SC\n+            (\"positional parameter association \" &\n+              \"not allowed after named one\");\n+\n+         Expr_Node := P_Expression;\n+\n+         --  Leaving the '>' in an association is not unusual, so suggest\n+         --  a possible fix.\n+\n+         if Nkind (Expr_Node) = N_Op_Eq then\n+            Error_Msg_N (\"\\maybe `=>` was intended\", Expr_Node);\n+         end if;\n+\n+         --  We go back to scanning out expressions, so that we do not get\n+         --  multiple error messages when several positional parameters\n+         --  follow a named parameter.\n+\n+         goto LP_State_Expr;\n+\n+         --  End of treatment for name extensions starting with left paren\n+\n+      --  End of loop through name extensions\n+\n+   end P_Name;\n+\n+   --  This function parses a restricted form of Names which are either\n+   --  designators, or designators preceded by a sequence of prefixes\n+   --  that are direct names.\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Function_Name return Node_Id is\n+      Designator_Node : Node_Id;\n+      Prefix_Node     : Node_Id;\n+      Selector_Node   : Node_Id;\n+      Dot_Sloc        : Source_Ptr := No_Location;\n+\n+   begin\n+      --  Prefix_Node is set to the gathered prefix so far, Empty means that\n+      --  no prefix has been scanned. This allows us to build up the result\n+      --  in the required right recursive manner.\n+\n+      Prefix_Node := Empty;\n+\n+      --  Loop through prefixes\n+\n+      loop\n+         Designator_Node := Token_Node;\n+\n+         if Token not in Token_Class_Desig then\n+            return P_Identifier; -- let P_Identifier issue the error message\n+\n+         else -- Token in Token_Class_Desig\n+            Scan; -- past designator\n+            exit when Token /= Tok_Dot;\n+         end if;\n+\n+         --  Here at a dot, with token just before it in Designator_Node\n+\n+         if No (Prefix_Node) then\n+            Prefix_Node := Designator_Node;\n+         else\n+            Selector_Node := New_Node (N_Selected_Component, Dot_Sloc);\n+            Set_Prefix (Selector_Node, Prefix_Node);\n+            Set_Selector_Name (Selector_Node, Designator_Node);\n+            Prefix_Node := Selector_Node;\n+         end if;\n+\n+         Dot_Sloc := Token_Ptr;\n+         Scan; -- past dot\n+      end loop;\n+\n+      --  Fall out of the loop having just scanned a designator\n+\n+      if No (Prefix_Node) then\n+         return Designator_Node;\n+      else\n+         Selector_Node := New_Node (N_Selected_Component, Dot_Sloc);\n+         Set_Prefix (Selector_Node, Prefix_Node);\n+         Set_Selector_Name (Selector_Node, Designator_Node);\n+         return Selector_Node;\n+      end if;\n+\n+   exception\n+      when Error_Resync =>\n+         return Error;\n+\n+   end P_Function_Name;\n+\n+   --  This function parses a restricted form of Names which are either\n+   --  identifiers, or identifiers preceded by a sequence of prefixes\n+   --  that are direct names.\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Qualified_Simple_Name return Node_Id is\n+      Designator_Node : Node_Id;\n+      Prefix_Node     : Node_Id;\n+      Selector_Node   : Node_Id;\n+      Dot_Sloc        : Source_Ptr := No_Location;\n+\n+   begin\n+      --  Prefix node is set to the gathered prefix so far, Empty means that\n+      --  no prefix has been scanned. This allows us to build up the result\n+      --  in the required right recursive manner.\n+\n+      Prefix_Node := Empty;\n+\n+      --  Loop through prefixes\n+\n+      loop\n+         Designator_Node := Token_Node;\n+\n+         if Token = Tok_Identifier then\n+            Scan; -- past identifier\n+            exit when Token /= Tok_Dot;\n+\n+         elsif Token not in Token_Class_Desig then\n+            return P_Identifier; -- let P_Identifier issue the error message\n+\n+         else\n+            Scan; -- past designator\n+\n+            if Token /= Tok_Dot then\n+               Error_Msg_SP (\"identifier expected\");\n+               return Error;\n+            end if;\n+         end if;\n+\n+         --  Here at a dot, with token just before it in Designator_Node\n+\n+         if No (Prefix_Node) then\n+            Prefix_Node := Designator_Node;\n+         else\n+            Selector_Node := New_Node (N_Selected_Component, Dot_Sloc);\n+            Set_Prefix (Selector_Node, Prefix_Node);\n+            Set_Selector_Name (Selector_Node, Designator_Node);\n+            Prefix_Node := Selector_Node;\n+         end if;\n+\n+         Dot_Sloc := Token_Ptr;\n+         Scan; -- past dot\n+      end loop;\n+\n+      --  Fall out of the loop having just scanned an identifier\n+\n+      if No (Prefix_Node) then\n+         return Designator_Node;\n+      else\n+         Selector_Node := New_Node (N_Selected_Component, Dot_Sloc);\n+         Set_Prefix (Selector_Node, Prefix_Node);\n+         Set_Selector_Name (Selector_Node, Designator_Node);\n+         return Selector_Node;\n+      end if;\n+\n+   exception\n+      when Error_Resync =>\n+         return Error;\n+\n+   end P_Qualified_Simple_Name;\n+\n+   --  This procedure differs from P_Qualified_Simple_Name only in that it\n+   --  raises Error_Resync if any error is encountered. It only returns after\n+   --  scanning a valid qualified simple name.\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Qualified_Simple_Name_Resync return Node_Id is\n+      Designator_Node : Node_Id;\n+      Prefix_Node     : Node_Id;\n+      Selector_Node   : Node_Id;\n+      Dot_Sloc        : Source_Ptr := No_Location;\n+\n+   begin\n+      Prefix_Node := Empty;\n+\n+      --  Loop through prefixes\n+\n+      loop\n+         Designator_Node := Token_Node;\n+\n+         if Token = Tok_Identifier then\n+            Scan; -- past identifier\n+            exit when Token /= Tok_Dot;\n+\n+         elsif Token not in Token_Class_Desig then\n+            Discard_Junk_Node (P_Identifier); -- to issue the error message\n+            raise Error_Resync;\n+\n+         else\n+            Scan; -- past designator\n+\n+            if Token /= Tok_Dot then\n+               Error_Msg_SP (\"identifier expected\");\n+               raise Error_Resync;\n+            end if;\n+         end if;\n+\n+         --  Here at a dot, with token just before it in Designator_Node\n+\n+         if No (Prefix_Node) then\n+            Prefix_Node := Designator_Node;\n+         else\n+            Selector_Node := New_Node (N_Selected_Component, Dot_Sloc);\n+            Set_Prefix (Selector_Node, Prefix_Node);\n+            Set_Selector_Name (Selector_Node, Designator_Node);\n+            Prefix_Node := Selector_Node;\n+         end if;\n+\n+         Dot_Sloc := Token_Ptr;\n+         Scan; -- past period\n+      end loop;\n+\n+      --  Fall out of the loop having just scanned an identifier\n+\n+      if No (Prefix_Node) then\n+         return Designator_Node;\n+      else\n+         Selector_Node := New_Node (N_Selected_Component, Dot_Sloc);\n+         Set_Prefix (Selector_Node, Prefix_Node);\n+         Set_Selector_Name (Selector_Node, Designator_Node);\n+         return Selector_Node;\n+      end if;\n+\n+   end P_Qualified_Simple_Name_Resync;\n+\n+   ----------------------\n+   -- 4.1  Direct_Name --\n+   ----------------------\n+\n+   --  Parsed by P_Name and other functions in section 4.1\n+\n+   -----------------\n+   -- 4.1  Prefix --\n+   -----------------\n+\n+   --  Parsed by P_Name (4.1)\n+\n+   -------------------------------\n+   -- 4.1  Explicit Dereference --\n+   -------------------------------\n+\n+   --  Parsed by P_Name (4.1)\n+\n+   -------------------------------\n+   -- 4.1  Implicit_Dereference --\n+   -------------------------------\n+\n+   --  Parsed by P_Name (4.1)\n+\n+   ----------------------------\n+   -- 4.1  Indexed Component --\n+   ----------------------------\n+\n+   --  Parsed by P_Name (4.1)\n+\n+   ----------------\n+   -- 4.1  Slice --\n+   ----------------\n+\n+   --  Parsed by P_Name (4.1)\n+\n+   -----------------------------\n+   -- 4.1  Selected_Component --\n+   -----------------------------\n+\n+   --  Parsed by P_Name (4.1)\n+\n+   ------------------------\n+   -- 4.1  Selector Name --\n+   ------------------------\n+\n+   --  Parsed by P_Name (4.1)\n+\n+   ------------------------------\n+   -- 4.1  Attribute Reference --\n+   ------------------------------\n+\n+   --  Parsed by P_Name (4.1)\n+\n+   -------------------------------\n+   -- 4.1  Attribute Designator --\n+   -------------------------------\n+\n+   --  Parsed by P_Name (4.1)\n+\n+   --------------------------------------\n+   -- 4.1.4  Range Attribute Reference --\n+   --------------------------------------\n+\n+   --  RANGE_ATTRIBUTE_REFERENCE ::= PREFIX ' RANGE_ATTRIBUTE_DESIGNATOR\n+\n+   --  RANGE_ATTRIBUTE_DESIGNATOR ::= range [(static_EXPRESSION)]\n+\n+   --  In the grammar, a RANGE attribute is simply a name, but its use is\n+   --  highly restricted, so in the parser, we do not regard it as a name.\n+   --  Instead, P_Name returns without scanning the 'RANGE part of the\n+   --  attribute, and the caller uses the following function to construct\n+   --  a range attribute in places where it is appropriate.\n+\n+   --  Note that RANGE here is treated essentially as an identifier,\n+   --  rather than a reserved word.\n+\n+   --  The caller has parsed the prefix, i.e. a name, and Token points to\n+   --  the apostrophe. The token after the apostrophe is known to be RANGE\n+   --  at this point. The prefix node becomes the prefix of the attribute.\n+\n+   --  Error_Recovery: Cannot raise Error_Resync\n+\n+   function P_Range_Attribute_Reference\n+     (Prefix_Node : Node_Id)\n+      return        Node_Id\n+   is\n+      Attr_Node  : Node_Id;\n+\n+   begin\n+      Attr_Node := New_Node (N_Attribute_Reference, Token_Ptr);\n+      Set_Prefix (Attr_Node, Prefix_Node);\n+      Scan; -- past apostrophe\n+\n+      if Style_Check then\n+         Style.Check_Attribute_Name (True);\n+      end if;\n+\n+      Set_Attribute_Name (Attr_Node, Name_Range);\n+      Scan; -- past RANGE\n+\n+      if Token = Tok_Left_Paren then\n+         Scan; -- past left paren\n+         Set_Expressions (Attr_Node, New_List (P_Expression));\n+         T_Right_Paren;\n+      end if;\n+\n+      return Attr_Node;\n+   end P_Range_Attribute_Reference;\n+\n+   ---------------------------------------\n+   -- 4.1.4  Range Attribute Designator --\n+   ---------------------------------------\n+\n+   --  Parsed by P_Range_Attribute_Reference (4.4)\n+\n+   --------------------\n+   -- 4.3  Aggregate --\n+   --------------------\n+\n+   --  AGGREGATE ::= RECORD_AGGREGATE | EXTENSION_AGGREGATE | ARRAY_AGGREGATE\n+\n+   --  Parsed by P_Aggregate_Or_Paren_Expr (4.3), except in the case where\n+   --  an aggregate is known to be required (code statement, extension\n+   --  aggregate), in which cases this routine performs the necessary check\n+   --  that we have an aggregate rather than a parenthesized expression\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Aggregate return Node_Id is\n+      Aggr_Sloc : constant Source_Ptr := Token_Ptr;\n+      Aggr_Node : constant Node_Id    := P_Aggregate_Or_Paren_Expr;\n+\n+   begin\n+      if Nkind (Aggr_Node) /= N_Aggregate\n+           and then\n+         Nkind (Aggr_Node) /= N_Extension_Aggregate\n+      then\n+         Error_Msg\n+           (\"aggregate may not have single positional component\", Aggr_Sloc);\n+         return Error;\n+      else\n+         return Aggr_Node;\n+      end if;\n+   end P_Aggregate;\n+\n+   -------------------------------------------------\n+   -- 4.3  Aggregate or Parenthesized Expresssion --\n+   -------------------------------------------------\n+\n+   --  This procedure parses out either an aggregate or a parenthesized\n+   --  expression (these two constructs are closely related, since a\n+   --  parenthesized expression looks like an aggregate with a single\n+   --  positional component).\n+\n+   --  AGGREGATE ::=\n+   --    RECORD_AGGREGATE | EXTENSION_AGGREGATE | ARRAY_AGGREGATE\n+\n+   --  RECORD_AGGREGATE ::= (RECORD_COMPONENT_ASSOCIATION_LIST)\n+\n+   --  RECORD_COMPONENT_ASSOCIATION_LIST ::=\n+   --     RECORD_COMPONENT_ASSOCIATION {, RECORD_COMPONENT_ASSOCIATION}\n+   --   | null record\n+\n+   --  RECORD_COMPONENT_ASSOCIATION ::=\n+   --    [COMPONENT_CHOICE_LIST =>] EXPRESSION\n+\n+   --  COMPONENT_CHOICE_LIST ::=\n+   --    component_SELECTOR_NAME {| component_SELECTOR_NAME}\n+   --  | others\n+\n+   --  EXTENSION_AGGREGATE ::=\n+   --    (ANCESTOR_PART with RECORD_COMPONENT_ASSOCIATION_LIST)\n+\n+   --  ANCESTOR_PART ::= EXPRESSION | SUBTYPE_MARK\n+\n+   --  ARRAY_AGGREGATE ::=\n+   --    POSITIONAL_ARRAY_AGGREGATE | NAMED_ARRAY_AGGREGATE\n+\n+   --  POSITIONAL_ARRAY_AGGREGATE ::=\n+   --    (EXPRESSION, EXPRESSION {, EXPRESSION})\n+   --  | (EXPRESSION {, EXPRESSION}, others => EXPRESSION)\n+\n+   --  NAMED_ARRAY_AGGREGATE ::=\n+   --    (ARRAY_COMPONENT_ASSOCIATION {, ARRAY_COMPONENT_ASSOCIATION})\n+\n+   --  PRIMARY ::= (EXPRESSION);\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Aggregate_Or_Paren_Expr return Node_Id is\n+      Aggregate_Node : Node_Id;\n+      Expr_List      : List_Id;\n+      Assoc_List     : List_Id;\n+      Expr_Node      : Node_Id;\n+      Lparen_Sloc    : Source_Ptr;\n+      Scan_State     : Saved_Scan_State;\n+\n+   begin\n+      Lparen_Sloc := Token_Ptr;\n+      T_Left_Paren;\n+\n+      --  Note: the mechanism used here of rescanning the initial expression\n+      --  is distinctly unpleasant, but it saves a lot of fiddling in scanning\n+      --  out the discrete choice list.\n+\n+      --  Deal with expression and extension aggregate cases first\n+\n+      if Token /= Tok_Others then\n+         Save_Scan_State (Scan_State); -- at start of expression\n+\n+         --  Deal with (NULL RECORD) case\n+\n+         if Token = Tok_Null then\n+            Scan; -- past NULL\n+\n+            if Token = Tok_Record then\n+               Aggregate_Node := New_Node (N_Aggregate, Lparen_Sloc);\n+               Set_Null_Record_Present (Aggregate_Node, True);\n+               Scan; -- past RECORD\n+               T_Right_Paren;\n+               return Aggregate_Node;\n+            else\n+               Restore_Scan_State (Scan_State); -- to NULL that must be expr\n+            end if;\n+         end if;\n+\n+         Expr_Node := P_Expression_Or_Range_Attribute;\n+\n+         --  Extension aggregate case\n+\n+         if Token = Tok_With then\n+\n+            if Nkind (Expr_Node) = N_Attribute_Reference\n+              and then Attribute_Name (Expr_Node) = Name_Range\n+            then\n+               Bad_Range_Attribute (Sloc (Expr_Node));\n+               return Error;\n+            end if;\n+\n+            if Ada_83 then\n+               Error_Msg_SC (\"(Ada 83) extension aggregate not allowed\");\n+            end if;\n+\n+            Aggregate_Node := New_Node (N_Extension_Aggregate, Lparen_Sloc);\n+            Set_Ancestor_Part (Aggregate_Node, Expr_Node);\n+            Scan; -- past WITH\n+\n+            --  Deal with WITH NULL RECORD case\n+\n+            if Token = Tok_Null then\n+               Save_Scan_State (Scan_State); -- at NULL\n+               Scan; -- past NULL\n+\n+               if Token = Tok_Record then\n+                  Scan; -- past RECORD\n+                  Set_Null_Record_Present (Aggregate_Node, True);\n+                  T_Right_Paren;\n+                  return Aggregate_Node;\n+\n+               else\n+                  Restore_Scan_State (Scan_State); -- to NULL that must be expr\n+               end if;\n+            end if;\n+\n+            if Token /= Tok_Others then\n+               Save_Scan_State (Scan_State);\n+               Expr_Node := P_Expression;\n+            else\n+               Expr_Node := Empty;\n+            end if;\n+\n+         --  Expression case\n+\n+         elsif Token = Tok_Right_Paren or else Token in Token_Class_Eterm then\n+\n+            if Nkind (Expr_Node) = N_Attribute_Reference\n+              and then Attribute_Name (Expr_Node) = Name_Range\n+            then\n+               Bad_Range_Attribute (Sloc (Expr_Node));\n+               return Error;\n+            end if;\n+\n+            --  Bump paren count of expression, note that if the paren count\n+            --  is already at the maximum, then we leave it alone. This will\n+            --  cause some failures in pathalogical conformance tests, which\n+            --  we do not shed a tear over!\n+\n+            if Expr_Node /= Error then\n+               if Paren_Count (Expr_Node) /= Paren_Count_Type'Last then\n+                  Set_Paren_Count (Expr_Node, Paren_Count (Expr_Node) + 1);\n+               end if;\n+            end if;\n+\n+            T_Right_Paren; -- past right paren (error message if none)\n+            return Expr_Node;\n+\n+         --  Normal aggregate case\n+\n+         else\n+            Aggregate_Node := New_Node (N_Aggregate, Lparen_Sloc);\n+         end if;\n+\n+      --  Others case\n+\n+      else\n+         Aggregate_Node := New_Node (N_Aggregate, Lparen_Sloc);\n+         Expr_Node := Empty;\n+      end if;\n+\n+      --  Prepare to scan list of component associations\n+\n+      Expr_List  := No_List; -- don't set yet, maybe all named entries\n+      Assoc_List := No_List; -- don't set yet, maybe all positional entries\n+\n+      --  This loop scans through component associations. On entry to the\n+      --  loop, an expression has been scanned at the start of the current\n+      --  association unless initial token was OTHERS, in which case\n+      --  Expr_Node is set to Empty.\n+\n+      loop\n+         --  Deal with others association first. This is a named association\n+\n+         if No (Expr_Node) then\n+            if No (Assoc_List) then\n+               Assoc_List := New_List;\n+            end if;\n+\n+            Append (P_Record_Or_Array_Component_Association, Assoc_List);\n+\n+         --  Improper use of WITH\n+\n+         elsif Token = Tok_With then\n+            Error_Msg_SC (\"WITH must be preceded by single expression in \" &\n+                             \"extension aggregate\");\n+            raise Error_Resync;\n+\n+         --  Assume positional case if comma, right paren, or literal or\n+         --  identifier or OTHERS follows (the latter cases are missing\n+         --  comma cases). Also assume positional if a semicolon follows,\n+         --  which can happen if there are missing parens\n+\n+         elsif Token = Tok_Comma\n+           or else Token = Tok_Right_Paren\n+           or else Token = Tok_Others\n+           or else Token in Token_Class_Lit_Or_Name\n+           or else Token = Tok_Semicolon\n+         then\n+            if Present (Assoc_List) then\n+               Error_Msg_BC\n+                  (\"\"\"=>\"\" expected (positional association cannot follow \" &\n+                   \"named association)\");\n+            end if;\n+\n+            if No (Expr_List) then\n+               Expr_List := New_List;\n+            end if;\n+\n+            Append (Expr_Node, Expr_List);\n+\n+         --  Anything else is assumed to be a named association\n+\n+         else\n+            Restore_Scan_State (Scan_State); -- to start of expression\n+\n+            if No (Assoc_List) then\n+               Assoc_List := New_List;\n+            end if;\n+\n+            Append (P_Record_Or_Array_Component_Association, Assoc_List);\n+         end if;\n+\n+         exit when not Comma_Present;\n+\n+         --  If we are at an expression terminator, something is seriously\n+         --  wrong, so let's get out now, before we start eating up stuff\n+         --  that doesn't belong to us!\n+\n+         if Token in Token_Class_Eterm then\n+            Error_Msg_AP (\"expecting expression or component association\");\n+            exit;\n+         end if;\n+\n+         --  Otherwise initiate for reentry to top of loop by scanning an\n+         --  initial expression, unless the first token is OTHERS.\n+\n+         if Token = Tok_Others then\n+            Expr_Node := Empty;\n+         else\n+            Save_Scan_State (Scan_State); -- at start of expression\n+            Expr_Node := P_Expression;\n+         end if;\n+      end loop;\n+\n+      --  All component associations (positional and named) have been scanned\n+\n+      T_Right_Paren;\n+      Set_Expressions (Aggregate_Node, Expr_List);\n+      Set_Component_Associations (Aggregate_Node, Assoc_List);\n+      return Aggregate_Node;\n+   end P_Aggregate_Or_Paren_Expr;\n+\n+   ------------------------------------------------\n+   -- 4.3  Record or Array Component Association --\n+   ------------------------------------------------\n+\n+   --  RECORD_COMPONENT_ASSOCIATION ::=\n+   --    [COMPONENT_CHOICE_LIST =>] EXPRESSION\n+\n+   --  COMPONENT_CHOICE_LIST =>\n+   --    component_SELECTOR_NAME {| component_SELECTOR_NAME}\n+   --  | others\n+\n+   --  ARRAY_COMPONENT_ASSOCIATION ::=\n+   --    DISCRETE_CHOICE_LIST => EXPRESSION\n+\n+   --  Note: this routine only handles the named cases, including others.\n+   --  Cases where the component choice list is not present have already\n+   --  been handled directly.\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Record_Or_Array_Component_Association return Node_Id is\n+      Assoc_Node : Node_Id;\n+\n+   begin\n+      Assoc_Node := New_Node (N_Component_Association, Token_Ptr);\n+      Set_Choices (Assoc_Node, P_Discrete_Choice_List);\n+      Set_Sloc (Assoc_Node, Token_Ptr);\n+      TF_Arrow;\n+      Set_Expression (Assoc_Node, P_Expression);\n+      return Assoc_Node;\n+   end P_Record_Or_Array_Component_Association;\n+\n+   -----------------------------\n+   -- 4.3.1  Record Aggregate --\n+   -----------------------------\n+\n+   --  Case of enumeration aggregate is parsed by P_Aggregate (4.3)\n+   --  All other cases are parsed by P_Aggregate_Or_Paren_Expr (4.3)\n+\n+   ----------------------------------------------\n+   -- 4.3.1  Record Component Association List --\n+   ----------------------------------------------\n+\n+   --  Parsed by P_Aggregate_Or_Paren_Expr (4.3)\n+\n+   ----------------------------------\n+   -- 4.3.1  Component Choice List --\n+   ----------------------------------\n+\n+   --  Parsed by P_Aggregate_Or_Paren_Expr (4.3)\n+\n+   --------------------------------\n+   -- 4.3.1  Extension Aggregate --\n+   --------------------------------\n+\n+   --  Parsed by P_Aggregate_Or_Paren_Expr (4.3)\n+\n+   --------------------------\n+   -- 4.3.1  Ancestor Part --\n+   --------------------------\n+\n+   --  Parsed by P_Aggregate_Or_Paren_Expr (4.3)\n+\n+   ----------------------------\n+   -- 4.3.1  Array Aggregate --\n+   ----------------------------\n+\n+   --  Parsed by P_Aggregate_Or_Paren_Expr (4.3)\n+\n+   ---------------------------------------\n+   -- 4.3.1  Positional Array Aggregate --\n+   ---------------------------------------\n+\n+   --  Parsed by P_Aggregate_Or_Paren_Expr (4.3)\n+\n+   ----------------------------------\n+   -- 4.3.1  Named Array Aggregate --\n+   ----------------------------------\n+\n+   --  Parsed by P_Aggregate_Or_Paren_Expr (4.3)\n+\n+   ----------------------------------------\n+   -- 4.3.1  Array Component Association --\n+   ----------------------------------------\n+\n+   --  Parsed by P_Aggregate_Or_Paren_Expr (4.3)\n+\n+   ---------------------\n+   -- 4.4  Expression --\n+   ---------------------\n+\n+   --  EXPRESSION ::=\n+   --    RELATION {and RELATION} | RELATION {and then RELATION}\n+   --  | RELATION {or RELATION}  | RELATION {or else RELATION}\n+   --  | RELATION {xor RELATION}\n+\n+   --  On return, Expr_Form indicates the categorization of the expression\n+   --  EF_Range_Attr is not a possible value (if a range attribute is found,\n+   --  an error message is given, and Error is returned).\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Expression return Node_Id is\n+      Logical_Op      : Node_Kind;\n+      Prev_Logical_Op : Node_Kind;\n+      Op_Location     : Source_Ptr;\n+      Node1           : Node_Id;\n+      Node2           : Node_Id;\n+\n+   begin\n+      Node1 := P_Relation;\n+\n+      if Token in Token_Class_Logop then\n+         Prev_Logical_Op := N_Empty;\n+\n+         loop\n+            Op_Location := Token_Ptr;\n+            Logical_Op := P_Logical_Operator;\n+\n+            if Prev_Logical_Op /= N_Empty and then\n+               Logical_Op /= Prev_Logical_Op\n+            then\n+               Error_Msg\n+                 (\"mixed logical operators in expression\", Op_Location);\n+               Prev_Logical_Op := N_Empty;\n+            else\n+               Prev_Logical_Op := Logical_Op;\n+            end if;\n+\n+            Node2 := Node1;\n+            Node1 := New_Node (Logical_Op, Op_Location);\n+            Set_Left_Opnd (Node1, Node2);\n+            Set_Right_Opnd (Node1, P_Relation);\n+            Set_Op_Name (Node1);\n+            exit when Token not in Token_Class_Logop;\n+         end loop;\n+\n+         Expr_Form := EF_Non_Simple;\n+      end if;\n+\n+      if Token = Tok_Apostrophe then\n+         Bad_Range_Attribute (Token_Ptr);\n+         return Error;\n+      else\n+         return Node1;\n+      end if;\n+\n+   end P_Expression;\n+\n+   --  This function is identical to the normal P_Expression, except that it\n+   --  checks that the expression scan did not stop on a right paren. It is\n+   --  called in all contexts where a right parenthesis cannot legitimately\n+   --  follow an expression.\n+\n+   function P_Expression_No_Right_Paren return Node_Id is\n+   begin\n+      return No_Right_Paren (P_Expression);\n+   end P_Expression_No_Right_Paren;\n+\n+   ----------------------------------------\n+   -- 4.4  Expression_Or_Range_Attribute --\n+   ----------------------------------------\n+\n+   --  EXPRESSION ::=\n+   --    RELATION {and RELATION} | RELATION {and then RELATION}\n+   --  | RELATION {or RELATION}  | RELATION {or else RELATION}\n+   --  | RELATION {xor RELATION}\n+\n+   --  RANGE_ATTRIBUTE_REFERENCE ::= PREFIX ' RANGE_ATTRIBUTE_DESIGNATOR\n+\n+   --  RANGE_ATTRIBUTE_DESIGNATOR ::= range [(static_EXPRESSION)]\n+\n+   --  On return, Expr_Form indicates the categorization of the expression\n+   --  and EF_Range_Attr is one of the possibilities.\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   --  In the grammar, a RANGE attribute is simply a name, but its use is\n+   --  highly restricted, so in the parser, we do not regard it as a name.\n+   --  Instead, P_Name returns without scanning the 'RANGE part of the\n+   --  attribute, and P_Expression_Or_Range_Attribute handles the range\n+   --  attribute reference. In the normal case where a range attribute is\n+   --  not allowed, an error message is issued by P_Expression.\n+\n+   function P_Expression_Or_Range_Attribute return Node_Id is\n+      Logical_Op      : Node_Kind;\n+      Prev_Logical_Op : Node_Kind;\n+      Op_Location     : Source_Ptr;\n+      Node1           : Node_Id;\n+      Node2           : Node_Id;\n+      Attr_Node       : Node_Id;\n+\n+   begin\n+      Node1 := P_Relation;\n+\n+      if Token = Tok_Apostrophe then\n+         Attr_Node := P_Range_Attribute_Reference (Node1);\n+         Expr_Form := EF_Range_Attr;\n+         return Attr_Node;\n+\n+      elsif Token in Token_Class_Logop then\n+         Prev_Logical_Op := N_Empty;\n+\n+         loop\n+            Op_Location := Token_Ptr;\n+            Logical_Op := P_Logical_Operator;\n+\n+            if Prev_Logical_Op /= N_Empty and then\n+               Logical_Op /= Prev_Logical_Op\n+            then\n+               Error_Msg\n+                 (\"mixed logical operators in expression\", Op_Location);\n+               Prev_Logical_Op := N_Empty;\n+            else\n+               Prev_Logical_Op := Logical_Op;\n+            end if;\n+\n+            Node2 := Node1;\n+            Node1 := New_Node (Logical_Op, Op_Location);\n+            Set_Left_Opnd (Node1, Node2);\n+            Set_Right_Opnd (Node1, P_Relation);\n+            Set_Op_Name (Node1);\n+            exit when Token not in Token_Class_Logop;\n+         end loop;\n+\n+         Expr_Form := EF_Non_Simple;\n+      end if;\n+\n+      if Token = Tok_Apostrophe then\n+         Bad_Range_Attribute (Token_Ptr);\n+         return Error;\n+      else\n+         return Node1;\n+      end if;\n+   end P_Expression_Or_Range_Attribute;\n+\n+   -------------------\n+   -- 4.4  Relation --\n+   -------------------\n+\n+   --  RELATION ::=\n+   --    SIMPLE_EXPRESSION [RELATIONAL_OPERATOR SIMPLE_EXPRESSION]\n+   --  | SIMPLE_EXPRESSION [not] in RANGE\n+   --  | SIMPLE_EXPRESSION [not] in SUBTYPE_MARK\n+\n+   --  On return, Expr_Form indicates the categorization of the expression\n+\n+   --  Note: if Token = Tok_Apostrophe on return, then Expr_Form is set to\n+   --  EF_Simple_Name and the following token is RANGE (range attribute case).\n+\n+   --  Error recovery: cannot raise Error_Resync. If an error occurs within an\n+   --  expression, then tokens are scanned until either a non-expression token,\n+   --  a right paren (not matched by a left paren) or a comma, is encountered.\n+\n+   function P_Relation return Node_Id is\n+      Node1, Node2 : Node_Id;\n+      Optok        : Source_Ptr;\n+\n+   begin\n+      Node1 := P_Simple_Expression;\n+\n+      if Token not in Token_Class_Relop then\n+         return Node1;\n+\n+      else\n+         --  Here we have a relational operator following. If so then scan it\n+         --  out. Note that the assignment symbol := is treated as a relational\n+         --  operator to improve the error recovery when it is misused for =.\n+         --  P_Relational_Operator also parses the IN and NOT IN operations.\n+\n+         Optok := Token_Ptr;\n+         Node2 := New_Node (P_Relational_Operator, Optok);\n+         Set_Left_Opnd (Node2, Node1);\n+         Set_Op_Name (Node2);\n+\n+         --  Case of IN or NOT IN\n+\n+         if Prev_Token = Tok_In then\n+            Set_Right_Opnd (Node2, P_Range_Or_Subtype_Mark);\n+\n+         --  Case of relational operator (= /= < <= > >=)\n+\n+         else\n+            Set_Right_Opnd (Node2, P_Simple_Expression);\n+         end if;\n+\n+         Expr_Form := EF_Non_Simple;\n+\n+         if Token in Token_Class_Relop then\n+            Error_Msg_SC (\"unexpected relational operator\");\n+            raise Error_Resync;\n+         end if;\n+\n+         return Node2;\n+      end if;\n+\n+   --  If any error occurs, then scan to the next expression terminator symbol\n+   --  or comma or right paren at the outer (i.e. current) parentheses level.\n+   --  The flags are set to indicate a normal simple expression.\n+\n+   exception\n+      when Error_Resync =>\n+         Resync_Expression;\n+         Expr_Form := EF_Simple;\n+         return Error;\n+   end P_Relation;\n+\n+   ----------------------------\n+   -- 4.4  Simple Expression --\n+   ----------------------------\n+\n+   --  SIMPLE_EXPRESSION ::=\n+   --    [UNARY_ADDING_OPERATOR] TERM {BINARY_ADDING_OPERATOR TERM}\n+\n+   --  On return, Expr_Form indicates the categorization of the expression\n+\n+   --  Note: if Token = Tok_Apostrophe on return, then Expr_Form is set to\n+   --  EF_Simple_Name and the following token is RANGE (range attribute case).\n+\n+   --  Error recovery: cannot raise Error_Resync. If an error occurs within an\n+   --  expression, then tokens are scanned until either a non-expression token,\n+   --  a right paren (not matched by a left paren) or a comma, is encountered.\n+\n+   --  Note: P_Simple_Expression is called only internally by higher level\n+   --  expression routines. In cases in the grammar where a simple expression\n+   --  is required, the approach is to scan an expression, and then post an\n+   --  appropriate error message if the expression obtained is not simple. This\n+   --  gives better error recovery and treatment.\n+\n+   function P_Simple_Expression return Node_Id is\n+      Scan_State : Saved_Scan_State;\n+      Node1      : Node_Id;\n+      Node2      : Node_Id;\n+      Tokptr     : Source_Ptr;\n+\n+   begin\n+      --  Check for cases starting with a name. There are two reasons for\n+      --  special casing. First speed things up by catching a common case\n+      --  without going through several routine layers. Second the caller must\n+      --  be informed via Expr_Form when the simple expression is a name.\n+\n+      if Token in Token_Class_Name then\n+         Node1 := P_Name;\n+\n+         --  Deal with apostrophe cases\n+\n+         if Token = Tok_Apostrophe then\n+            Save_Scan_State (Scan_State); -- at apostrophe\n+            Scan; -- past apostrophe\n+\n+            --  If qualified expression, scan it out and fall through\n+\n+            if Token = Tok_Left_Paren then\n+               Node1 := P_Qualified_Expression (Node1);\n+               Expr_Form := EF_Simple;\n+\n+            --  If range attribute, then we return with Token pointing to the\n+            --  apostrophe. Note: avoid the normal error check on exit. We\n+            --  know that the expression really is complete in this case!\n+\n+            else -- Token = Tok_Range then\n+               Restore_Scan_State (Scan_State); -- to apostrophe\n+               Expr_Form := EF_Simple_Name;\n+               return Node1;\n+            end if;\n+         end if;\n+\n+         --  If an expression terminator follows, the previous processing\n+         --  completely scanned out the expression (a common case), and\n+         --  left Expr_Form set appropriately for returning to our caller.\n+\n+         if Token in Token_Class_Sterm then\n+            null;\n+\n+         --  If we do not have an expression terminator, then complete the\n+         --  scan of a simple expression. This code duplicates the code\n+         --  found in P_Term and P_Factor.\n+\n+         else\n+            if Token = Tok_Double_Asterisk then\n+               if Style_Check then Style.Check_Exponentiation_Operator; end if;\n+               Node2 := New_Node (N_Op_Expon, Token_Ptr);\n+               Scan; -- past **\n+               Set_Left_Opnd (Node2, Node1);\n+               Set_Right_Opnd (Node2, P_Primary);\n+               Set_Op_Name (Node2);\n+               Node1 := Node2;\n+            end if;\n+\n+            loop\n+               exit when Token not in Token_Class_Mulop;\n+               Tokptr := Token_Ptr;\n+               Node2 := New_Node (P_Multiplying_Operator, Tokptr);\n+               if Style_Check then Style.Check_Binary_Operator; end if;\n+               Scan; -- past operator\n+               Set_Left_Opnd (Node2, Node1);\n+               Set_Right_Opnd (Node2, P_Factor);\n+               Set_Op_Name (Node2);\n+               Node1 := Node2;\n+            end loop;\n+\n+            loop\n+               exit when Token not in Token_Class_Binary_Addop;\n+               Tokptr := Token_Ptr;\n+               Node2 := New_Node (P_Binary_Adding_Operator, Tokptr);\n+               if Style_Check then Style.Check_Binary_Operator; end if;\n+               Scan; -- past operator\n+               Set_Left_Opnd (Node2, Node1);\n+               Set_Right_Opnd (Node2, P_Term);\n+               Set_Op_Name (Node2);\n+               Node1 := Node2;\n+            end loop;\n+\n+            Expr_Form := EF_Simple;\n+         end if;\n+\n+      --  Cases where simple expression does not start with a name\n+\n+      else\n+         --  Scan initial sign and initial Term\n+\n+         if Token in Token_Class_Unary_Addop then\n+            Tokptr := Token_Ptr;\n+            Node1 := New_Node (P_Unary_Adding_Operator, Tokptr);\n+            if Style_Check then Style.Check_Unary_Plus_Or_Minus; end if;\n+            Scan; -- past operator\n+            Set_Right_Opnd (Node1, P_Term);\n+            Set_Op_Name (Node1);\n+         else\n+            Node1 := P_Term;\n+         end if;\n+\n+         --  Scan out sequence of terms separated by binary adding operators\n+\n+         loop\n+            exit when Token not in Token_Class_Binary_Addop;\n+            Tokptr := Token_Ptr;\n+            Node2 := New_Node (P_Binary_Adding_Operator, Tokptr);\n+            Scan; -- past operator\n+            Set_Left_Opnd (Node2, Node1);\n+            Set_Right_Opnd (Node2, P_Term);\n+            Set_Op_Name (Node2);\n+            Node1 := Node2;\n+         end loop;\n+\n+         --  All done, we clearly do not have name or numeric literal so this\n+         --  is a case of a simple expression which is some other possibility.\n+\n+         Expr_Form := EF_Simple;\n+      end if;\n+\n+      --  Come here at end of simple expression, where we do a couple of\n+      --  special checks to improve error recovery.\n+\n+      --  Special test to improve error recovery. If the current token\n+      --  is a period, then someone is trying to do selection on something\n+      --  that is not a name, e.g. a qualified expression.\n+\n+      if Token = Tok_Dot then\n+         Error_Msg_SC (\"prefix for selection is not a name\");\n+         raise Error_Resync;\n+      end if;\n+\n+      --  Special test to improve error recovery: If the current token is\n+      --  not the first token on a line (as determined by checking the\n+      --  previous token position with the start of the current line),\n+      --  then we insist that we have an appropriate terminating token.\n+      --  Consider the following two examples:\n+\n+      --   1)  if A nad B then ...\n+\n+      --   2)  A := B\n+      --       C := D\n+\n+      --  In the first example, we would like to issue a binary operator\n+      --  expected message and resynchronize to the then. In the second\n+      --  example, we do not want to issue a binary operator message, so\n+      --  that instead we will get the missing semicolon message. This\n+      --  distinction is of course a heuristic which does not always work,\n+      --  but in practice it is quite effective.\n+\n+      --  Note: the one case in which we do not go through this circuit is\n+      --  when we have scanned a range attribute and want to return with\n+      --  Token pointing to the apostrophe. The apostrophe is not normally\n+      --  an expression terminator, and is not in Token_Class_Sterm, but\n+      --  in this special case we know that the expression is complete.\n+\n+      if not Token_Is_At_Start_Of_Line\n+         and then Token not in Token_Class_Sterm\n+      then\n+         Error_Msg_AP (\"binary operator expected\");\n+         raise Error_Resync;\n+      else\n+         return Node1;\n+      end if;\n+\n+   --  If any error occurs, then scan to next expression terminator symbol\n+   --  or comma, right paren or vertical bar at the outer (i.e. current) paren\n+   --  level. Expr_Form is set to indicate a normal simple expression.\n+\n+   exception\n+      when Error_Resync =>\n+         Resync_Expression;\n+         Expr_Form := EF_Simple;\n+         return Error;\n+\n+   end P_Simple_Expression;\n+\n+   -----------------------------------------------\n+   -- 4.4  Simple Expression or Range Attribute --\n+   -----------------------------------------------\n+\n+   --  SIMPLE_EXPRESSION ::=\n+   --    [UNARY_ADDING_OPERATOR] TERM {BINARY_ADDING_OPERATOR TERM}\n+\n+   --  RANGE_ATTRIBUTE_REFERENCE ::= PREFIX ' RANGE_ATTRIBUTE_DESIGNATOR\n+\n+   --  RANGE_ATTRIBUTE_DESIGNATOR ::= range [(static_EXPRESSION)]\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Simple_Expression_Or_Range_Attribute return Node_Id is\n+      Sexpr     : Node_Id;\n+      Attr_Node : Node_Id;\n+\n+   begin\n+      Sexpr := P_Simple_Expression;\n+\n+      if Token = Tok_Apostrophe then\n+         Attr_Node := P_Range_Attribute_Reference (Sexpr);\n+         Expr_Form := EF_Range_Attr;\n+         return Attr_Node;\n+\n+      else\n+         return Sexpr;\n+      end if;\n+   end P_Simple_Expression_Or_Range_Attribute;\n+\n+   ---------------\n+   -- 4.4  Term --\n+   ---------------\n+\n+   --  TERM ::= FACTOR {MULTIPLYING_OPERATOR FACTOR}\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Term return Node_Id is\n+      Node1, Node2 : Node_Id;\n+      Tokptr       : Source_Ptr;\n+\n+   begin\n+      Node1 := P_Factor;\n+\n+      loop\n+         exit when Token not in Token_Class_Mulop;\n+         Tokptr := Token_Ptr;\n+         Node2 := New_Node (P_Multiplying_Operator, Tokptr);\n+         Scan; -- past operator\n+         Set_Left_Opnd (Node2, Node1);\n+         Set_Right_Opnd (Node2, P_Factor);\n+         Set_Op_Name (Node2);\n+         Node1 := Node2;\n+      end loop;\n+\n+      return Node1;\n+   end P_Term;\n+\n+   -----------------\n+   -- 4.4  Factor --\n+   -----------------\n+\n+   --  FACTOR ::= PRIMARY [** PRIMARY] | abs PRIMARY | not PRIMARY\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Factor return Node_Id is\n+      Node1 : Node_Id;\n+      Node2 : Node_Id;\n+\n+   begin\n+      if Token = Tok_Abs then\n+         Node1 := New_Node (N_Op_Abs, Token_Ptr);\n+         if Style_Check then Style.Check_Abs_Not; end if;\n+         Scan; -- past ABS\n+         Set_Right_Opnd (Node1, P_Primary);\n+         Set_Op_Name (Node1);\n+         return Node1;\n+\n+      elsif Token = Tok_Not then\n+         Node1 := New_Node (N_Op_Not, Token_Ptr);\n+         if Style_Check then Style.Check_Abs_Not; end if;\n+         Scan; -- past NOT\n+         Set_Right_Opnd (Node1, P_Primary);\n+         Set_Op_Name (Node1);\n+         return Node1;\n+\n+      else\n+         Node1 := P_Primary;\n+\n+         if Token = Tok_Double_Asterisk then\n+            Node2 := New_Node (N_Op_Expon, Token_Ptr);\n+            Scan; -- past **\n+            Set_Left_Opnd (Node2, Node1);\n+            Set_Right_Opnd (Node2, P_Primary);\n+            Set_Op_Name (Node2);\n+            return Node2;\n+         else\n+            return Node1;\n+         end if;\n+      end if;\n+   end P_Factor;\n+\n+   ------------------\n+   -- 4.4  Primary --\n+   ------------------\n+\n+   --  PRIMARY ::=\n+   --    NUMERIC_LITERAL  | null\n+   --  | STRING_LITERAL   | AGGREGATE\n+   --  | NAME             | QUALIFIED_EXPRESSION\n+   --  | ALLOCATOR        | (EXPRESSION)\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Primary return Node_Id is\n+      Scan_State : Saved_Scan_State;\n+      Node1      : Node_Id;\n+\n+   begin\n+      --  The loop runs more than once only if misplaced pragmas are found\n+\n+      loop\n+         case Token is\n+\n+            --  Name token can start a name, call or qualified expression, all\n+            --  of which are acceptable possibilities for primary. Note also\n+            --  that string literal is included in name (as operator symbol)\n+            --  and type conversion is included in name (as indexed component).\n+\n+            when Tok_Char_Literal | Tok_Operator_Symbol | Tok_Identifier =>\n+               Node1 := P_Name;\n+\n+               --  All done unless apostrophe follows\n+\n+               if Token /= Tok_Apostrophe then\n+                  return Node1;\n+\n+               --  Apostrophe following means that we have either just parsed\n+               --  the subtype mark of a qualified expression, or the prefix\n+               --  or a range attribute.\n+\n+               else -- Token = Tok_Apostrophe\n+                  Save_Scan_State (Scan_State); -- at apostrophe\n+                  Scan; -- past apostrophe\n+\n+                  --  If range attribute, then this is always an error, since\n+                  --  the only legitimate case (where the scanned expression is\n+                  --  a qualified simple name) is handled at the level of the\n+                  --  Simple_Expression processing. This case corresponds to a\n+                  --  usage such as 3 + A'Range, which is always illegal.\n+\n+                  if Token = Tok_Range then\n+                     Restore_Scan_State (Scan_State); -- to apostrophe\n+                     Bad_Range_Attribute (Token_Ptr);\n+                     return Error;\n+\n+                  --  If left paren, then we have a qualified expression.\n+                  --  Note that P_Name guarantees that in this case, where\n+                  --  Token = Tok_Apostrophe on return, the only two possible\n+                  --  tokens following the apostrophe are left paren and\n+                  --  RANGE, so we know we have a left paren here.\n+\n+                  else -- Token = Tok_Left_Paren\n+                     return P_Qualified_Expression (Node1);\n+\n+                  end if;\n+               end if;\n+\n+            --  Numeric or string literal\n+\n+            when Tok_Integer_Literal |\n+                 Tok_Real_Literal    |\n+                 Tok_String_Literal  =>\n+\n+               Node1 := Token_Node;\n+               Scan; -- past number\n+               return Node1;\n+\n+            --  Left paren, starts aggregate or parenthesized expression\n+\n+            when Tok_Left_Paren =>\n+               return P_Aggregate_Or_Paren_Expr;\n+\n+            --  Allocator\n+\n+            when Tok_New =>\n+               return P_Allocator;\n+\n+            --  Null\n+\n+            when Tok_Null =>\n+               Scan; -- past NULL\n+               return New_Node (N_Null, Prev_Token_Ptr);\n+\n+            --  Pragma, not allowed here, so just skip past it\n+\n+            when Tok_Pragma =>\n+               P_Pragmas_Misplaced;\n+\n+            --  Anything else is illegal as the first token of a primary, but\n+            --  we test for a reserved identifier so that it is treated nicely\n+\n+            when others =>\n+               if Is_Reserved_Identifier then\n+                  return P_Identifier;\n+\n+               elsif Prev_Token = Tok_Comma then\n+                  Error_Msg_SP (\"extra \"\",\"\" ignored\");\n+                  raise Error_Resync;\n+\n+               else\n+                  Error_Msg_AP (\"missing operand\");\n+                  raise Error_Resync;\n+               end if;\n+\n+         end case;\n+      end loop;\n+   end P_Primary;\n+\n+   ---------------------------\n+   -- 4.5  Logical Operator --\n+   ---------------------------\n+\n+   --  LOGICAL_OPERATOR  ::=  and | or | xor\n+\n+   --  Note: AND THEN and OR ELSE are also treated as logical operators\n+   --  by the parser (even though they are not operators semantically)\n+\n+   --  The value returned is the appropriate Node_Kind code for the operator\n+   --  On return, Token points to the token following the scanned operator.\n+\n+   --  The caller has checked that the first token is a legitimate logical\n+   --  operator token (i.e. is either XOR, AND, OR).\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Logical_Operator return Node_Kind is\n+   begin\n+      if Token = Tok_And then\n+         if Style_Check then Style.Check_Binary_Operator; end if;\n+         Scan; -- past AND\n+\n+         if Token = Tok_Then then\n+            Scan; -- past THEN\n+            return N_And_Then;\n+         else\n+            return N_Op_And;\n+         end if;\n+\n+      elsif Token = Tok_Or then\n+         if Style_Check then Style.Check_Binary_Operator; end if;\n+         Scan; -- past OR\n+\n+         if Token = Tok_Else then\n+            Scan; -- past ELSE\n+            return N_Or_Else;\n+         else\n+            return N_Op_Or;\n+         end if;\n+\n+      else -- Token = Tok_Xor\n+         if Style_Check then Style.Check_Binary_Operator; end if;\n+         Scan; -- past XOR\n+         return N_Op_Xor;\n+      end if;\n+   end P_Logical_Operator;\n+\n+   ------------------------------\n+   -- 4.5  Relational Operator --\n+   ------------------------------\n+\n+   --  RELATIONAL_OPERATOR ::= = | /= | < | <= | > | >=\n+\n+   --  The value returned is the appropriate Node_Kind code for the operator.\n+   --  On return, Token points to the operator token, NOT past it.\n+\n+   --  The caller has checked that the first token is a legitimate relational\n+   --  operator token (i.e. is one of the operator tokens listed above).\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Relational_Operator return Node_Kind is\n+      Op_Kind : Node_Kind;\n+      Relop_Node : constant array (Token_Class_Relop) of Node_Kind :=\n+        (Tok_Less           => N_Op_Lt,\n+         Tok_Equal          => N_Op_Eq,\n+         Tok_Greater        => N_Op_Gt,\n+         Tok_Not_Equal      => N_Op_Ne,\n+         Tok_Greater_Equal  => N_Op_Ge,\n+         Tok_Less_Equal     => N_Op_Le,\n+         Tok_In             => N_In,\n+         Tok_Not            => N_Not_In,\n+         Tok_Box            => N_Op_Ne);\n+\n+   begin\n+      if Token = Tok_Box then\n+         Error_Msg_SC (\"\"\"<>\"\" should be \"\"/=\"\"\");\n+      end if;\n+\n+      Op_Kind := Relop_Node (Token);\n+      if Style_Check then Style.Check_Binary_Operator; end if;\n+      Scan; -- past operator token\n+\n+      if Prev_Token = Tok_Not then\n+         T_In;\n+      end if;\n+\n+      return Op_Kind;\n+   end P_Relational_Operator;\n+\n+   ---------------------------------\n+   -- 4.5  Binary Adding Operator --\n+   ---------------------------------\n+\n+   --  BINARY_ADDING_OPERATOR ::= + | - | &\n+\n+   --  The value returned is the appropriate Node_Kind code for the operator.\n+   --  On return, Token points to the operator token (NOT past it).\n+\n+   --  The caller has checked that the first token is a legitimate adding\n+   --  operator token (i.e. is one of the operator tokens listed above).\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Binary_Adding_Operator return Node_Kind is\n+      Addop_Node : constant array (Token_Class_Binary_Addop) of Node_Kind :=\n+        (Tok_Ampersand      => N_Op_Concat,\n+         Tok_Minus          => N_Op_Subtract,\n+         Tok_Plus           => N_Op_Add);\n+   begin\n+      return Addop_Node (Token);\n+   end P_Binary_Adding_Operator;\n+\n+   --------------------------------\n+   -- 4.5  Unary Adding Operator --\n+   --------------------------------\n+\n+   --  UNARY_ADDING_OPERATOR ::= + | -\n+\n+   --  The value returned is the appropriate Node_Kind code for the operator.\n+   --  On return, Token points to the operator token (NOT past it).\n+\n+   --  The caller has checked that the first token is a legitimate adding\n+   --  operator token (i.e. is one of the operator tokens listed above).\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Unary_Adding_Operator return Node_Kind is\n+      Addop_Node : constant array (Token_Class_Unary_Addop) of Node_Kind :=\n+        (Tok_Minus          => N_Op_Minus,\n+         Tok_Plus           => N_Op_Plus);\n+   begin\n+      return Addop_Node (Token);\n+   end P_Unary_Adding_Operator;\n+\n+   -------------------------------\n+   -- 4.5  Multiplying Operator --\n+   -------------------------------\n+\n+   --  MULTIPLYING_OPERATOR ::= * | / | mod | rem\n+\n+   --  The value returned is the appropriate Node_Kind code for the operator.\n+   --  On return, Token points to the operator token (NOT past it).\n+\n+   --  The caller has checked that the first token is a legitimate multiplying\n+   --  operator token (i.e. is one of the operator tokens listed above).\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Multiplying_Operator return Node_Kind is\n+      Mulop_Node : constant array (Token_Class_Mulop) of Node_Kind :=\n+        (Tok_Asterisk       => N_Op_Multiply,\n+         Tok_Mod            => N_Op_Mod,\n+         Tok_Rem            => N_Op_Rem,\n+         Tok_Slash          => N_Op_Divide);\n+   begin\n+      return Mulop_Node (Token);\n+   end P_Multiplying_Operator;\n+\n+   --------------------------------------\n+   -- 4.5  Highest Precedence Operator --\n+   --------------------------------------\n+\n+   --  Parsed by P_Factor (4.4)\n+\n+   --  Note: this rule is not in fact used by the grammar at any point!\n+\n+   --------------------------\n+   -- 4.6  Type Conversion --\n+   --------------------------\n+\n+   --  Parsed by P_Primary as a Name (4.1)\n+\n+   -------------------------------\n+   -- 4.7  Qualified Expression --\n+   -------------------------------\n+\n+   --  QUALIFIED_EXPRESSION ::=\n+   --    SUBTYPE_MARK ' (EXPRESSION) | SUBTYPE_MARK ' AGGREGATE\n+\n+   --  The caller has scanned the name which is the Subtype_Mark parameter\n+   --  and scanned past the single quote following the subtype mark. The\n+   --  caller has not checked that this name is in fact appropriate for\n+   --  a subtype mark name (i.e. it is a selected component or identifier).\n+\n+   --  Error_Recovery: cannot raise Error_Resync\n+\n+   function  P_Qualified_Expression (Subtype_Mark : Node_Id) return Node_Id is\n+      Qual_Node : Node_Id;\n+\n+   begin\n+      Qual_Node := New_Node (N_Qualified_Expression, Prev_Token_Ptr);\n+      Set_Subtype_Mark (Qual_Node, Check_Subtype_Mark (Subtype_Mark));\n+      Set_Expression (Qual_Node, P_Aggregate_Or_Paren_Expr);\n+      return Qual_Node;\n+   end P_Qualified_Expression;\n+\n+   --------------------\n+   -- 4.8  Allocator --\n+   --------------------\n+\n+   --  ALLOCATOR ::=\n+   --   new SUBTYPE_INDICATION | new QUALIFIED_EXPRESSION\n+\n+   --  The caller has checked that the initial token is NEW\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Allocator return Node_Id is\n+      Alloc_Node  : Node_Id;\n+      Type_Node   : Node_Id;\n+\n+   begin\n+      Alloc_Node := New_Node (N_Allocator, Token_Ptr);\n+      T_New;\n+      Type_Node := P_Subtype_Mark_Resync;\n+\n+      if Token = Tok_Apostrophe then\n+         Scan; -- past apostrophe\n+         Set_Expression (Alloc_Node, P_Qualified_Expression (Type_Node));\n+      else\n+         Set_Expression (Alloc_Node, P_Subtype_Indication (Type_Node));\n+      end if;\n+\n+      return Alloc_Node;\n+   end P_Allocator;\n+\n+end Ch4;"}, {"sha": "2ec56726e6b83443d03b283e4020c8191de194bf", "filename": "gcc/ada/par-ch5.adb", "status": "added", "additions": 2184, "deletions": 0, "changes": 2184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch5.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,2184 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P A R . C H 5                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.95 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Style_Checks (All_Checks);\n+--  Turn off subprogram body ordering check. Subprograms are in order\n+--  by RM section rather than alphabetical\n+\n+separate (Par)\n+package body Ch5 is\n+\n+   --  Local functions, used only in this chapter\n+\n+   function P_Case_Statement                     return Node_Id;\n+   function P_Case_Statement_Alternative         return Node_Id;\n+   function P_Condition                          return Node_Id;\n+   function P_Exit_Statement                     return Node_Id;\n+   function P_Goto_Statement                     return Node_Id;\n+   function P_If_Statement                       return Node_Id;\n+   function P_Label                              return Node_Id;\n+   function P_Loop_Parameter_Specification       return Node_Id;\n+   function P_Null_Statement                     return Node_Id;\n+\n+   function P_Assignment_Statement (LHS : Node_Id)  return Node_Id;\n+   --  Parse assignment statement. On entry, the caller has scanned the left\n+   --  hand side (passed in as Lhs), and the colon-equal (or some symbol\n+   --  taken to be an error equivalent such as equal).\n+\n+   function P_Begin_Statement (Block_Name : Node_Id := Empty) return Node_Id;\n+   --  Parse begin-end statement. If Block_Name is non-Empty on entry, it is\n+   --  the N_Identifier node for the label on the block. If Block_Name is\n+   --  Empty on entry (the default), then the block statement is unlabeled.\n+\n+   function P_Declare_Statement (Block_Name : Node_Id := Empty) return Node_Id;\n+   --  Parse declare block. If Block_Name is non-Empty on entry, it is\n+   --  the N_Identifier node for the label on the block. If Block_Name is\n+   --  Empty on entry (the default), then the block statement is unlabeled.\n+\n+   function P_For_Statement (Loop_Name : Node_Id := Empty) return Node_Id;\n+   --  Parse for statement. If Loop_Name is non-Empty on entry, it is\n+   --  the N_Identifier node for the label on the loop. If Loop_Name is\n+   --  Empty on entry (the default), then the for statement is unlabeled.\n+\n+   function P_Loop_Statement (Loop_Name : Node_Id := Empty) return Node_Id;\n+   --  Parse loop statement. If Loop_Name is non-Empty on entry, it is\n+   --  the N_Identifier node for the label on the loop. If Loop_Name is\n+   --  Empty on entry (the default), then the loop statement is unlabeled.\n+\n+   function P_While_Statement (Loop_Name : Node_Id := Empty) return Node_Id;\n+   --  Parse while statement. If Loop_Name is non-Empty on entry, it is\n+   --  the N_Identifier node for the label on the loop. If Loop_Name is\n+   --  Empty on entry (the default), then the while statement is unlabeled.\n+\n+   function Set_Loop_Block_Name (L : Character) return Name_Id;\n+   --  Given a letter 'L' for a loop or 'B' for a block, returns a name\n+   --  of the form L_nn or B_nn where nn is a serial number obtained by\n+   --  incrementing the variable Loop_Block_Count.\n+\n+   procedure Then_Scan;\n+   --  Scan past THEN token, testing for illegal junk after it\n+\n+   ---------------------------------\n+   -- 5.1  Sequence of Statements --\n+   ---------------------------------\n+\n+   --  SEQUENCE_OF_STATEMENTS ::= STATEMENT {STATEMENT}\n+\n+   --  STATEMENT ::=\n+   --    {LABEL} SIMPLE_STATEMENT | {LABEL} COMPOUND_STATEMENT\n+\n+   --  SIMPLE_STATEMENT ::=      NULL_STATEMENT\n+   --  | ASSIGNMENT_STATEMENT  | EXIT_STATEMENT\n+   --  | GOTO_STATEMENT        | PROCEDURE_CALL_STATEMENT\n+   --  | RETURN_STATEMENT      | ENTRY_CALL_STATEMENT\n+   --  | REQUEUE_STATEMENT     | DELAY_STATEMENT\n+   --  | ABORT_STATEMENT       | RAISE_STATEMENT\n+   --  | CODE_STATEMENT\n+\n+   --  COMPOUND_STATEMENT ::=\n+   --    IF_STATEMENT         | CASE_STATEMENT\n+   --  | LOOP_STATEMENT       | BLOCK_STATEMENT\n+   --  | ACCEPT_STATEMENT     | SELECT_STATEMENT\n+\n+   --  This procedure scans a sequence of statements. The caller sets SS_Flags\n+   --  to indicate acceptable termination conditions for the sequence:\n+\n+   --    SS_Flags.Eftm Terminate on ELSIF\n+   --    SS_Flags.Eltm Terminate on ELSE\n+   --    SS_Flags.Extm Terminate on EXCEPTION\n+   --    SS_Flags.Ortm Terminate on OR\n+   --    SS_Flags.Tatm Terminate on THEN ABORT (Token = ABORT on return)\n+   --    SS_Flags.Whtm Terminate on WHEN\n+   --    SS_Flags.Unco Unconditional terminate after scanning one statement\n+\n+   --  In addition, the scan is always terminated by encountering END or the\n+   --  end of file (EOF) condition. If one of the six above terminators is\n+   --  encountered with the corresponding SS_Flags flag not set, then the\n+   --  action taken is as follows:\n+\n+   --    If the keyword occurs to the left of the expected column of the end\n+   --    for the current sequence (as recorded in the current end context),\n+   --    then it is assumed to belong to an outer context, and is considered\n+   --    to terminate the sequence of statements.\n+\n+   --    If the keyword occurs to the right of, or in the expected column of\n+   --    the end for the current sequence, then an error message is output,\n+   --    the keyword together with its associated context is skipped, and\n+   --    the statement scan continues until another terminator is found.\n+\n+   --  Note that the first action means that control can return to the caller\n+   --  with Token set to a terminator other than one of those specified by the\n+   --  SS parameter. The caller should treat such a case as equivalent to END.\n+\n+   --  In addition, the flag SS_Flags.Sreq is set to True to indicate that at\n+   --  least one real statement (other than a pragma) is required in the\n+   --  statement sequence. During the processing of the sequence, this\n+   --  flag is manipulated to indicate the current status of the requirement\n+   --  for a statement. For example, it is turned off by the occurrence of a\n+   --  statement, and back on by a label (which requires a following statement)\n+\n+   --  Error recovery: cannot raise Error_Resync. If an error occurs during\n+   --  parsing a statement, then the scan pointer is advanced past the next\n+   --  semicolon and the parse continues.\n+\n+   function P_Sequence_Of_Statements (SS_Flags : SS_Rec) return List_Id is\n+\n+      Statement_Required : Boolean;\n+      --  This flag indicates if a subsequent statement (other than a pragma)\n+      --  is required. It is initialized from the Sreq flag, and modified as\n+      --  statements are scanned (a statement turns it off, and a label turns\n+      --  it back on again since a statement must follow a label).\n+\n+      Declaration_Found : Boolean := False;\n+      --  This flag is set True if a declaration is encountered, so that the\n+      --  error message about declarations in the statement part is only\n+      --  given once for a given sequence of statements.\n+\n+      Scan_State_Label : Saved_Scan_State;\n+      Scan_State       : Saved_Scan_State;\n+\n+      Statement_List : List_Id;\n+      Block_Label    : Name_Id;\n+      Id_Node        : Node_Id;\n+      Name_Node      : Node_Id;\n+\n+      procedure Junk_Declaration;\n+      --  Procedure called to handle error of declaration encountered in\n+      --  statement sequence.\n+\n+      procedure Test_Statement_Required;\n+      --  Flag error if Statement_Required flag set\n+\n+      procedure Junk_Declaration is\n+      begin\n+         if (not Declaration_Found) or All_Errors_Mode then\n+            Error_Msg_SC (\"declarations must come before BEGIN\");\n+            Declaration_Found := True;\n+         end if;\n+\n+         Skip_Declaration (Statement_List);\n+      end Junk_Declaration;\n+\n+      procedure Test_Statement_Required is\n+      begin\n+         if Statement_Required then\n+            Error_Msg_BC (\"statement expected\");\n+         end if;\n+      end Test_Statement_Required;\n+\n+   --  Start of processing for P_Sequence_Of_Statements\n+\n+   begin\n+      Statement_List := New_List;\n+      Statement_Required := SS_Flags.Sreq;\n+\n+      loop\n+         while Token = Tok_Semicolon loop\n+            Error_Msg_SC (\"unexpected semicolon ignored\");\n+            Scan; -- past junk semicolon\n+         end loop;\n+\n+         begin\n+            if Style_Check then Style.Check_Indentation; end if;\n+\n+            --  Deal with reserved identifier (in assignment or call)\n+\n+            if Is_Reserved_Identifier then\n+               Save_Scan_State (Scan_State); -- at possible bad identifier\n+               Scan; -- and scan past it\n+\n+               --  We have an reserved word which is spelled in identifier\n+               --  style, so the question is whether it really is intended\n+               --  to be an identifier.\n+\n+               if\n+                  --  If followed by a semicolon, then it is an identifier,\n+                  --  with the exception of the cases tested for below.\n+\n+                  (Token = Tok_Semicolon\n+                    and then Prev_Token /= Tok_Return\n+                    and then Prev_Token /= Tok_Null\n+                    and then Prev_Token /= Tok_Raise\n+                    and then Prev_Token /= Tok_End\n+                    and then Prev_Token /= Tok_Exit)\n+\n+                  --  If followed by colon, colon-equal, or dot, then we\n+                  --  definitely  have an identifier (could not be reserved)\n+\n+                  or else Token = Tok_Colon\n+                  or else Token = Tok_Colon_Equal\n+                  or else Token = Tok_Dot\n+\n+                  --  Left paren means we have an identifier except for those\n+                  --  reserved words that can legitimately be followed by a\n+                  --  left paren.\n+\n+                  or else\n+                    (Token = Tok_Left_Paren\n+                      and then Prev_Token /= Tok_Case\n+                      and then Prev_Token /= Tok_Delay\n+                      and then Prev_Token /= Tok_If\n+                      and then Prev_Token /= Tok_Elsif\n+                      and then Prev_Token /= Tok_Return\n+                      and then Prev_Token /= Tok_When\n+                      and then Prev_Token /= Tok_While\n+                      and then Prev_Token /= Tok_Separate)\n+               then\n+                  --  Here we have an apparent reserved identifier and the\n+                  --  token past it is appropriate to this usage (and would\n+                  --  be a definite error if this is not an identifier). What\n+                  --  we do is to use P_Identifier to fix up the identifier,\n+                  --  and then fall into the normal processing.\n+\n+                  Restore_Scan_State (Scan_State); -- back to the ID\n+                  Scan_Reserved_Identifier (Force_Msg => False);\n+\n+                  --  Not a reserved identifier after all (or at least we can't\n+                  --  be sure that it is), so reset the scan and continue.\n+\n+               else\n+                  Restore_Scan_State (Scan_State); -- back to the reserved word\n+               end if;\n+            end if;\n+\n+            --  Now look to see what kind of statement we have\n+\n+            case Token is\n+\n+               --  Case of end or EOF\n+\n+               when Tok_End | Tok_EOF =>\n+\n+                  --  These tokens always terminate the statement sequence\n+\n+                  Test_Statement_Required;\n+                  exit;\n+\n+               --  Case of ELSIF\n+\n+               when Tok_Elsif =>\n+\n+                  --  Terminate if Eftm set or if the ELSIF is to the left\n+                  --  of the expected column of the end for this sequence\n+\n+                  if SS_Flags.Eftm\n+                     or else Start_Column < Scope.Table (Scope.Last).Ecol\n+                  then\n+                     Test_Statement_Required;\n+                     exit;\n+\n+                  --  Otherwise complain and skip past ELSIF Condition then\n+\n+                  else\n+                     Error_Msg_SC (\"ELSIF not allowed here\");\n+                     Scan; -- past ELSIF\n+                     Discard_Junk_Node (P_Expression_No_Right_Paren);\n+                     Then_Scan;\n+                     Statement_Required := False;\n+                  end if;\n+\n+               --  Case of ELSE\n+\n+               when Tok_Else =>\n+\n+                  --  Terminate if Eltm set or if the else is to the left\n+                  --  of the expected column of the end for this sequence\n+\n+                  if SS_Flags.Eltm\n+                     or else Start_Column < Scope.Table (Scope.Last).Ecol\n+                  then\n+                     Test_Statement_Required;\n+                     exit;\n+\n+                  --  Otherwise complain and skip past else\n+\n+                  else\n+                     Error_Msg_SC (\"ELSE not allowed here\");\n+                     Scan; -- past ELSE\n+                     Statement_Required := False;\n+                  end if;\n+\n+               --  Case of exception\n+\n+               when Tok_Exception =>\n+                  Test_Statement_Required;\n+\n+                  --  If Extm not set and the exception is not to the left\n+                  --  of the expected column of the end for this sequence, then\n+                  --  we assume it belongs to the current sequence, even though\n+                  --  it is not permitted.\n+\n+                  if not SS_Flags.Extm and then\n+                     Start_Column >= Scope.Table (Scope.Last).Ecol\n+\n+                  then\n+                     Error_Msg_SC (\"exception handler not permitted here\");\n+                     Scan; -- past EXCEPTION\n+                     Discard_Junk_List (Parse_Exception_Handlers);\n+                  end if;\n+\n+                  --  Always return, in the case where we scanned out handlers\n+                  --  that we did not expect, Parse_Exception_Handlers returned\n+                  --  with Token being either end or EOF, so we are OK\n+\n+                  exit;\n+\n+               --  Case of OR\n+\n+               when Tok_Or =>\n+\n+                  --  Terminate if Ortm set or if the or is to the left\n+                  --  of the expected column of the end for this sequence\n+\n+                  if SS_Flags.Ortm\n+                     or else Start_Column < Scope.Table (Scope.Last).Ecol\n+                  then\n+                     Test_Statement_Required;\n+                     exit;\n+\n+                  --  Otherwise complain and skip past or\n+\n+                  else\n+                     Error_Msg_SC (\"OR not allowed here\");\n+                     Scan; -- past or\n+                     Statement_Required := False;\n+                  end if;\n+\n+               --  Case of THEN (deal also with THEN ABORT)\n+\n+               when Tok_Then =>\n+                  Save_Scan_State (Scan_State); -- at THEN\n+                  Scan; -- past THEN\n+\n+                  --  Terminate if THEN ABORT allowed (ATC case)\n+\n+                  exit when SS_Flags.Tatm and then Token = Tok_Abort;\n+\n+                  --  Otherwise we treat THEN as some kind of mess where we\n+                  --  did not see the associated IF, but we pick up assuming\n+                  --  it had been there!\n+\n+                  Restore_Scan_State (Scan_State); -- to THEN\n+                  Append_To (Statement_List, P_If_Statement);\n+                  Statement_Required := False;\n+\n+               --  Case of WHEN (error because we are not in a case)\n+\n+               when Tok_When | Tok_Others =>\n+\n+                  --  Terminate if Whtm set or if the WHEN is to the left\n+                  --  of the expected column of the end for this sequence\n+\n+                  if SS_Flags.Whtm\n+                     or else Start_Column < Scope.Table (Scope.Last).Ecol\n+                  then\n+                     Test_Statement_Required;\n+                     exit;\n+\n+                  --  Otherwise complain and skip when Choice {| Choice} =>\n+\n+                  else\n+                     Error_Msg_SC (\"WHEN not allowed here\");\n+                     Scan; -- past when\n+                     Discard_Junk_List (P_Discrete_Choice_List);\n+                     TF_Arrow;\n+                     Statement_Required := False;\n+                  end if;\n+\n+               --  Cases of statements starting with an identifier\n+\n+               when Tok_Identifier =>\n+                  Check_Bad_Layout;\n+\n+                  --  Save scan pointers and line number in case block label\n+\n+                  Id_Node := Token_Node;\n+                  Block_Label := Token_Name;\n+                  Save_Scan_State (Scan_State_Label); -- at possible label\n+                  Scan; -- past Id\n+\n+                  --  Check for common case of assignment, since it occurs\n+                  --  frequently, and we want to process it efficiently.\n+\n+                  if Token = Tok_Colon_Equal then\n+                     Scan; -- past the colon-equal\n+                     Append_To (Statement_List,\n+                       P_Assignment_Statement (Id_Node));\n+                     Statement_Required := False;\n+\n+                  --  Check common case of procedure call, another case that\n+                  --  we want to speed up as much as possible.\n+\n+                  elsif Token = Tok_Semicolon then\n+                     Append_To (Statement_List,\n+                       P_Statement_Name (Id_Node));\n+                     Scan; -- past semicolon\n+                     Statement_Required := False;\n+\n+                  --  Check for case of \"go to\" in place of \"goto\"\n+\n+                  elsif Token = Tok_Identifier\n+                    and then Block_Label = Name_Go\n+                    and then Token_Name = Name_To\n+                  then\n+                     Error_Msg_SP (\"goto is one word\");\n+                     Append_To (Statement_List, P_Goto_Statement);\n+                     Statement_Required := False;\n+\n+                  --  Check common case of = used instead of :=, just so we\n+                  --  give a better error message for this special misuse.\n+\n+                  elsif Token = Tok_Equal then\n+                     T_Colon_Equal; -- give := expected message\n+                     Append_To (Statement_List,\n+                       P_Assignment_Statement (Id_Node));\n+                     Statement_Required := False;\n+\n+                  --  Check case of loop label or block label\n+\n+                  elsif Token = Tok_Colon\n+                    or else (Token in Token_Class_Labeled_Stmt\n+                              and then not Token_Is_At_Start_Of_Line)\n+                  then\n+                     T_Colon; -- past colon (if there, or msg for missing one)\n+\n+                     --  Test for more than one label\n+\n+                     loop\n+                        exit when Token /= Tok_Identifier;\n+                        Save_Scan_State (Scan_State); -- at second Id\n+                        Scan; -- past Id\n+\n+                        if Token = Tok_Colon then\n+                           Error_Msg_SP\n+                              (\"only one label allowed on block or loop\");\n+                           Scan; -- past colon on extra label\n+\n+                           --  Use the second label as the \"real\" label\n+\n+                           Scan_State_Label := Scan_State;\n+\n+                           --  We will set Error_name as the Block_Label since\n+                           --  we really don't know which of the labels might\n+                           --  be used at the end of the loop or block!\n+\n+                           Block_Label := Error_Name;\n+\n+                        --  If Id with no colon, then backup to point to the\n+                        --  Id and we will issue the message below when we try\n+                        --  to scan out the statement as some other form.\n+\n+                        else\n+                           Restore_Scan_State (Scan_State); -- to second Id\n+                           exit;\n+                        end if;\n+                     end loop;\n+\n+                     --  Loop_Statement (labeled Loop_Statement)\n+\n+                     if Token = Tok_Loop then\n+                        Append_To (Statement_List,\n+                          P_Loop_Statement (Id_Node));\n+\n+                     --  While statement (labeled loop statement with WHILE)\n+\n+                     elsif Token = Tok_While then\n+                        Append_To (Statement_List,\n+                          P_While_Statement (Id_Node));\n+\n+                     --  Declare statement (labeled block statement with\n+                     --  DECLARE part)\n+\n+                     elsif Token = Tok_Declare then\n+                        Append_To (Statement_List,\n+                          P_Declare_Statement (Id_Node));\n+\n+                     --  Begin statement (labeled block statement with no\n+                     --  DECLARE part)\n+\n+                     elsif Token = Tok_Begin then\n+                        Append_To (Statement_List,\n+                          P_Begin_Statement (Id_Node));\n+\n+                     --  For statement (labeled loop statement with FOR)\n+\n+                     elsif Token = Tok_For then\n+                        Append_To (Statement_List,\n+                          P_For_Statement (Id_Node));\n+\n+                     --  Improper statement follows label. If we have an\n+                     --  expression token, then assume the colon was part\n+                     --  of a misplaced declaration.\n+\n+                     elsif Token not in Token_Class_Eterm then\n+                        Restore_Scan_State (Scan_State_Label);\n+                        Junk_Declaration;\n+\n+                     --  Otherwise complain we have inappropriate statement\n+\n+                     else\n+                        Error_Msg_AP\n+                          (\"loop or block statement must follow label\");\n+                     end if;\n+\n+                     Statement_Required := False;\n+\n+                  --  Here we have an identifier followed by something\n+                  --  other than a colon, semicolon or assignment symbol.\n+                  --  The only valid possibility is a name extension symbol\n+\n+                  elsif Token in Token_Class_Namext then\n+                     Restore_Scan_State (Scan_State_Label); -- to Id\n+                     Name_Node := P_Name;\n+\n+                     --  Skip junk right parens in this context\n+\n+                     while Token = Tok_Right_Paren loop\n+                        Error_Msg_SC (\"extra right paren\");\n+                        Scan; -- past )\n+                     end loop;\n+\n+                     --  Check context following call\n+\n+                     if Token = Tok_Colon_Equal then\n+                        Scan; -- past colon equal\n+                        Append_To (Statement_List,\n+                          P_Assignment_Statement (Name_Node));\n+                        Statement_Required := False;\n+\n+                     --  Check common case of = used instead of :=\n+\n+                     elsif Token = Tok_Equal then\n+                        T_Colon_Equal; -- give := expected message\n+                        Append_To (Statement_List,\n+                          P_Assignment_Statement (Name_Node));\n+                        Statement_Required := False;\n+\n+                     --  Check apostrophe cases\n+\n+                     elsif Token = Tok_Apostrophe then\n+                        Append_To (Statement_List,\n+                          P_Code_Statement (Name_Node));\n+                        Statement_Required := False;\n+\n+                     --  The only other valid item after a name is ; which\n+                     --  means that the item we just scanned was a call.\n+\n+                     elsif Token = Tok_Semicolon then\n+                        Append_To (Statement_List,\n+                          P_Statement_Name (Name_Node));\n+                        Scan; -- past semicolon\n+                        Statement_Required := False;\n+\n+                        --  Else we have a missing semicolon\n+\n+                     else\n+                        TF_Semicolon;\n+                        Statement_Required := False;\n+                     end if;\n+\n+                  --  If junk after identifier, check if identifier is an\n+                  --  instance of an incorrectly spelled keyword. If so, we\n+                  --  do nothing. The Bad_Spelling_Of will have reset Token\n+                  --  to the appropriate keyword, so the next time round the\n+                  --  loop we will process the modified token. Note that we\n+                  --  check for ELSIF before ELSE here. That's not accidental.\n+                  --  We don't want to identify a misspelling of ELSE as\n+                  --  ELSIF, and in particular we do not want to treat ELSEIF\n+                  --  as ELSE IF.\n+\n+                  else\n+                     Restore_Scan_State (Scan_State_Label); -- to identifier\n+\n+                     if Bad_Spelling_Of (Tok_Abort)\n+                       or else Bad_Spelling_Of (Tok_Accept)\n+                       or else Bad_Spelling_Of (Tok_Case)\n+                       or else Bad_Spelling_Of (Tok_Declare)\n+                       or else Bad_Spelling_Of (Tok_Delay)\n+                       or else Bad_Spelling_Of (Tok_Elsif)\n+                       or else Bad_Spelling_Of (Tok_Else)\n+                       or else Bad_Spelling_Of (Tok_End)\n+                       or else Bad_Spelling_Of (Tok_Exception)\n+                       or else Bad_Spelling_Of (Tok_Exit)\n+                       or else Bad_Spelling_Of (Tok_For)\n+                       or else Bad_Spelling_Of (Tok_Goto)\n+                       or else Bad_Spelling_Of (Tok_If)\n+                       or else Bad_Spelling_Of (Tok_Loop)\n+                       or else Bad_Spelling_Of (Tok_Or)\n+                       or else Bad_Spelling_Of (Tok_Pragma)\n+                       or else Bad_Spelling_Of (Tok_Raise)\n+                       or else Bad_Spelling_Of (Tok_Requeue)\n+                       or else Bad_Spelling_Of (Tok_Return)\n+                       or else Bad_Spelling_Of (Tok_Select)\n+                       or else Bad_Spelling_Of (Tok_When)\n+                       or else Bad_Spelling_Of (Tok_While)\n+                     then\n+                        null;\n+\n+                     --  If not a bad spelling, then we really have junk\n+\n+                     else\n+                        Scan; -- past identifier again\n+\n+                        --  If next token is first token on line, then we\n+                        --  consider that we were missing a semicolon after\n+                        --  the identifier, and process it as a procedure\n+                        --  call with no parameters.\n+\n+                        if Token_Is_At_Start_Of_Line then\n+                           Append_To (Statement_List,\n+                             P_Statement_Name (Id_Node));\n+                           T_Semicolon; -- to give error message\n+                           Statement_Required := False;\n+\n+                        --  Otherwise we give a missing := message and\n+                        --  simply abandon the junk that is there now.\n+\n+                        else\n+                           T_Colon_Equal; -- give := expected message\n+                           raise Error_Resync;\n+                        end if;\n+\n+                     end if;\n+                  end if;\n+\n+               --  Statement starting with operator symbol. This could be\n+               --  a call, a name starting an assignment, or a qualified\n+               --  expression.\n+\n+               when Tok_Operator_Symbol =>\n+                  Check_Bad_Layout;\n+                  Name_Node := P_Name;\n+\n+                  --  An attempt at a range attribute or a qualified expression\n+                  --  must be illegal here (a code statement cannot possibly\n+                  --  allow qualification by a function name).\n+\n+                  if Token = Tok_Apostrophe then\n+                     Error_Msg_SC (\"apostrophe illegal here\");\n+                     raise Error_Resync;\n+                  end if;\n+\n+                  --  Scan possible assignment if we have a name\n+\n+                  if Expr_Form = EF_Name\n+                    and then Token = Tok_Colon_Equal\n+                  then\n+                     Scan; -- past colon equal\n+                     Append_To (Statement_List,\n+                       P_Assignment_Statement (Name_Node));\n+                  else\n+                     Append_To (Statement_List,\n+                       P_Statement_Name (Name_Node));\n+                  end if;\n+\n+                  TF_Semicolon;\n+                  Statement_Required := False;\n+\n+               --  Label starting with << which must precede real statement\n+\n+               when Tok_Less_Less =>\n+                  Append_To (Statement_List, P_Label);\n+                  Statement_Required := True;\n+\n+               --  Pragma appearing as a statement in a statement sequence\n+\n+               when Tok_Pragma =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_Pragma);\n+\n+               --  Abort_Statement\n+\n+               when Tok_Abort =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_Abort_Statement);\n+                  Statement_Required := False;\n+\n+               --  Accept_Statement\n+\n+               when Tok_Accept =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_Accept_Statement);\n+                  Statement_Required := False;\n+\n+               --  Begin_Statement (Block_Statement with no declare, no label)\n+\n+               when Tok_Begin =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_Begin_Statement);\n+                  Statement_Required := False;\n+\n+               --  Case_Statement\n+\n+               when Tok_Case =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_Case_Statement);\n+                  Statement_Required := False;\n+\n+               --  Block_Statement with DECLARE and no label\n+\n+               when Tok_Declare =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_Declare_Statement);\n+                  Statement_Required := False;\n+\n+               --  Delay_Statement\n+\n+               when Tok_Delay =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_Delay_Statement);\n+                  Statement_Required := False;\n+\n+               --  Exit_Statement\n+\n+               when Tok_Exit =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_Exit_Statement);\n+                  Statement_Required := False;\n+\n+               --  Loop_Statement with FOR and no label\n+\n+               when Tok_For =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_For_Statement);\n+                  Statement_Required := False;\n+\n+               --  Goto_Statement\n+\n+               when Tok_Goto =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_Goto_Statement);\n+                  Statement_Required := False;\n+\n+               --  If_Statement\n+\n+               when Tok_If =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_If_Statement);\n+                  Statement_Required := False;\n+\n+               --  Loop_Statement\n+\n+               when Tok_Loop =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_Loop_Statement);\n+                  Statement_Required := False;\n+\n+               --  Null_Statement\n+\n+               when Tok_Null =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_Null_Statement);\n+                  Statement_Required := False;\n+\n+               --  Raise_Statement\n+\n+               when Tok_Raise =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_Raise_Statement);\n+                  Statement_Required := False;\n+\n+               --  Requeue_Statement\n+\n+               when Tok_Requeue =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_Requeue_Statement);\n+                  Statement_Required := False;\n+\n+               --  Return_Statement\n+\n+               when Tok_Return =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_Return_Statement);\n+                  Statement_Required := False;\n+\n+               --  Select_Statement\n+\n+               when Tok_Select =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_Select_Statement);\n+                  Statement_Required := False;\n+\n+               --  While_Statement (Block_Statement with while and no loop)\n+\n+               when Tok_While =>\n+                  Check_Bad_Layout;\n+                  Append_To (Statement_List, P_While_Statement);\n+                  Statement_Required := False;\n+\n+               --  Anything else is some kind of junk, signal an error message\n+               --  and then raise Error_Resync, to merge with the normal\n+               --  handling of a bad statement.\n+\n+               when others =>\n+\n+                  if Token in Token_Class_Declk then\n+                     Junk_Declaration;\n+\n+                  else\n+                     Error_Msg_BC (\"statement expected\");\n+                     raise Error_Resync;\n+                  end if;\n+            end case;\n+\n+         --  On error resynchronization, skip past next semicolon, and, since\n+         --  we are still in the statement loop, look for next statement. We\n+         --  set Statement_Required False to avoid an unnecessary error message\n+         --  complaining that no statement was found (i.e. we consider the\n+         --  junk to satisfy the requirement for a statement being present).\n+\n+         exception\n+            when Error_Resync =>\n+               Resync_Past_Semicolon_Or_To_Loop_Or_Then;\n+               Statement_Required := False;\n+         end;\n+\n+         exit when SS_Flags.Unco;\n+\n+      end loop;\n+\n+      return Statement_List;\n+\n+   end P_Sequence_Of_Statements;\n+\n+   --------------------\n+   -- 5.1  Statement --\n+   --------------------\n+\n+   --  Parsed by P_Sequence_Of_Statements (5.1), except for the case\n+   --  of a statement of the form of a name, which is handled here. The\n+   --  argument passed in is the tree for the name which has been scanned\n+   --  The returned value is the corresponding statement form.\n+\n+   --  This routine is also used by Par.Prag for processing the procedure\n+   --  call that appears as the second argument of a pragma Assert.\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Statement_Name (Name_Node : Node_Id) return Node_Id is\n+      Stmt_Node : Node_Id;\n+\n+   begin\n+      --  Case of Indexed component, which is a procedure call with arguments\n+\n+      if Nkind (Name_Node) = N_Indexed_Component then\n+         declare\n+            Prefix_Node : Node_Id := Prefix (Name_Node);\n+            Exprs_Node  : List_Id := Expressions (Name_Node);\n+         begin\n+            Change_Node (Name_Node, N_Procedure_Call_Statement);\n+            Set_Name (Name_Node, Prefix_Node);\n+            Set_Parameter_Associations (Name_Node, Exprs_Node);\n+            return Name_Node;\n+         end;\n+\n+      --  Case of function call node, which is a really a procedure call\n+\n+      elsif Nkind (Name_Node) = N_Function_Call then\n+         declare\n+            Fname_Node  : Node_Id := Name (Name_Node);\n+            Params_List : List_Id := Parameter_Associations (Name_Node);\n+\n+         begin\n+            Change_Node (Name_Node, N_Procedure_Call_Statement);\n+            Set_Name (Name_Node, Fname_Node);\n+            Set_Parameter_Associations (Name_Node, Params_List);\n+            return Name_Node;\n+         end;\n+\n+      --  Case of call to attribute that denotes a procedure. Here we\n+      --  just leave the attribute reference unchanged.\n+\n+      elsif Nkind (Name_Node) = N_Attribute_Reference\n+        and then Is_Procedure_Attribute_Name (Attribute_Name (Name_Node))\n+      then\n+         return Name_Node;\n+\n+      --  All other cases of names are parameterless procedure calls\n+\n+      else\n+         Stmt_Node :=\n+           New_Node (N_Procedure_Call_Statement, Sloc (Name_Node));\n+         Set_Name (Stmt_Node, Name_Node);\n+         return Stmt_Node;\n+      end if;\n+\n+   end P_Statement_Name;\n+\n+   ---------------------------\n+   -- 5.1  Simple Statement --\n+   ---------------------------\n+\n+   --  Parsed by P_Sequence_Of_Statements (5.1)\n+\n+   -----------------------------\n+   -- 5.1  Compound Statement --\n+   -----------------------------\n+\n+   --  Parsed by P_Sequence_Of_Statements (5.1)\n+\n+   -------------------------\n+   -- 5.1  Null Statement --\n+   -------------------------\n+\n+   --  NULL_STATEMENT ::= null;\n+\n+   --  The caller has already checked that the current token is null\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Null_Statement return Node_Id is\n+      Null_Stmt_Node : Node_Id;\n+\n+   begin\n+      Null_Stmt_Node := New_Node (N_Null_Statement, Token_Ptr);\n+      Scan; -- past NULL\n+      TF_Semicolon;\n+      return Null_Stmt_Node;\n+   end P_Null_Statement;\n+\n+   ----------------\n+   -- 5.1  Label --\n+   ----------------\n+\n+   --  LABEL ::= <<label_STATEMENT_IDENTIFIER>>\n+\n+   --  STATEMENT_INDENTIFIER ::= DIRECT_NAME\n+\n+   --  The IDENTIFIER of a STATEMENT_IDENTIFIER shall be an identifier\n+   --  (not an OPERATOR_SYMBOL)\n+\n+   --  The caller has already checked that the current token is <<\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Label return Node_Id is\n+      Label_Node : Node_Id;\n+\n+   begin\n+      Label_Node := New_Node (N_Label, Token_Ptr);\n+      Scan; -- past <<\n+      Set_Identifier (Label_Node, P_Identifier);\n+      T_Greater_Greater;\n+      Append_Elmt (Label_Node, Label_List);\n+      return Label_Node;\n+   end P_Label;\n+\n+   -------------------------------\n+   -- 5.1  Statement Identifier --\n+   -------------------------------\n+\n+   --  Statement label is parsed by P_Label (5.1)\n+\n+   --  Loop label is parsed by P_Loop_Statement (5.5), P_For_Statement (5.5)\n+   --   or P_While_Statement (5.5)\n+\n+   --  Block label is parsed by P_Begin_Statement (5.6) or\n+   --   P_Declare_Statement (5.6)\n+\n+   -------------------------------\n+   -- 5.2  Assignment Statement --\n+   -------------------------------\n+\n+   --  ASSIGNMENT_STATEMENT ::=\n+   --    variable_NAME := EXPRESSION;\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Assignment_Statement (LHS : Node_Id) return Node_Id is\n+      Assign_Node : Node_Id;\n+\n+   begin\n+      Assign_Node := New_Node (N_Assignment_Statement, Prev_Token_Ptr);\n+      Set_Name (Assign_Node, LHS);\n+      Set_Expression (Assign_Node, P_Expression_No_Right_Paren);\n+      TF_Semicolon;\n+      return Assign_Node;\n+   end P_Assignment_Statement;\n+\n+   -----------------------\n+   -- 5.3  If Statement --\n+   -----------------------\n+\n+   --  IF_STATEMENT ::=\n+   --    if CONDITION then\n+   --      SEQUENCE_OF_STATEMENTS\n+   --    {elsif CONDITION then\n+   --      SEQUENCE_OF_STATEMENTS}\n+   --    [else\n+   --      SEQUENCE_OF_STATEMENTS]\n+   --    end if;\n+\n+   --  The caller has checked that the initial token is IF (or in the error\n+   --  case of a mysterious THEN, the initial token may simply be THEN, in\n+   --  which case, no condition (or IF) was scanned).\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_If_Statement return Node_Id is\n+      If_Node    : Node_Id;\n+      Elsif_Node : Node_Id;\n+      Loc        : Source_Ptr;\n+\n+      procedure Add_Elsif_Part;\n+      --  An internal procedure used to scan out a single ELSIF part. On entry\n+      --  the ELSIF (or an ELSE which has been determined should be ELSIF) is\n+      --  scanned out and is in Prev_Token.\n+\n+      procedure Check_If_Column;\n+      --  An internal procedure used to check that THEN, ELSE ELSE, or ELSIF\n+      --  appear in the right place if column checking is enabled (i.e. if\n+      --  they are the first token on the line, then they must appear in\n+      --  the same column as the opening IF).\n+\n+      procedure Check_Then_Column;\n+      --  This procedure carries out the style checks for a THEN token\n+      --  Note that the caller has set Loc to the Source_Ptr value for\n+      --  the previous IF or ELSIF token. These checks apply only to a\n+      --  THEN at the start of a line.\n+\n+      function Else_Should_Be_Elsif return Boolean;\n+      --  An internal routine used to do a special error recovery check when\n+      --  an ELSE is encountered. It determines if the ELSE should be treated\n+      --  as an ELSIF. A positive decision (TRUE returned, is made if the ELSE\n+      --  is followed by a sequence of tokens, starting on the same line as\n+      --  the ELSE, which are not expression terminators, followed by a THEN.\n+      --  On entry, the ELSE has been scanned out.\n+\n+      procedure Add_Elsif_Part is\n+      begin\n+         if No (Elsif_Parts (If_Node)) then\n+            Set_Elsif_Parts (If_Node, New_List);\n+         end if;\n+\n+         Elsif_Node := New_Node (N_Elsif_Part, Prev_Token_Ptr);\n+         Loc := Prev_Token_Ptr;\n+         Set_Condition (Elsif_Node, P_Condition);\n+         Check_Then_Column;\n+         Then_Scan;\n+         Set_Then_Statements\n+           (Elsif_Node, P_Sequence_Of_Statements (SS_Eftm_Eltm_Sreq));\n+         Append (Elsif_Node, Elsif_Parts (If_Node));\n+      end Add_Elsif_Part;\n+\n+      procedure Check_If_Column is\n+      begin\n+         if Style.RM_Column_Check and then Token_Is_At_Start_Of_Line\n+           and then Start_Column /= Scope.Table (Scope.Last).Ecol\n+         then\n+            Error_Msg_Col := Scope.Table (Scope.Last).Ecol;\n+            Error_Msg_SC (\"(style) this token should be@\");\n+         end if;\n+      end Check_If_Column;\n+\n+      procedure Check_Then_Column is\n+      begin\n+         if Token_Is_At_Start_Of_Line and then Token = Tok_Then then\n+            Check_If_Column;\n+            if Style_Check then Style.Check_Then (Loc); end if;\n+         end if;\n+      end Check_Then_Column;\n+\n+      function Else_Should_Be_Elsif return Boolean is\n+         Scan_State : Saved_Scan_State;\n+\n+      begin\n+         if Token_Is_At_Start_Of_Line then\n+            return False;\n+\n+         else\n+            Save_Scan_State (Scan_State);\n+\n+            loop\n+               if Token in Token_Class_Eterm then\n+                  Restore_Scan_State (Scan_State);\n+                  return False;\n+               else\n+                  Scan; -- past non-expression terminating token\n+\n+                  if Token = Tok_Then then\n+                     Restore_Scan_State (Scan_State);\n+                     return True;\n+                  end if;\n+               end if;\n+            end loop;\n+         end if;\n+      end Else_Should_Be_Elsif;\n+\n+   --  Start of processing for P_If_Statement\n+\n+   begin\n+      If_Node := New_Node (N_If_Statement, Token_Ptr);\n+\n+      Push_Scope_Stack;\n+      Scope.Table (Scope.Last).Etyp := E_If;\n+      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+      Scope.Table (Scope.Last).Labl := Error;\n+      Scope.Table (Scope.Last).Node := If_Node;\n+\n+      if Token = Tok_If then\n+         Loc := Token_Ptr;\n+         Scan; -- past IF\n+         Set_Condition (If_Node, P_Condition);\n+\n+         --  Deal with misuse of IF expression => used instead\n+         --  of WHEN expression =>\n+\n+         if Token = Tok_Arrow then\n+            Error_Msg_SC (\"THEN expected\");\n+            Scan; -- past the arrow\n+            Pop_Scope_Stack; -- remove unneeded entry\n+            raise Error_Resync;\n+         end if;\n+\n+         Check_Then_Column;\n+\n+      else\n+         Error_Msg_SC (\"no IF for this THEN\");\n+         Set_Condition (If_Node, Error);\n+      end if;\n+\n+      Then_Scan;\n+\n+      Set_Then_Statements\n+        (If_Node, P_Sequence_Of_Statements (SS_Eftm_Eltm_Sreq));\n+\n+      --  This loop scans out else and elsif parts\n+\n+      loop\n+         if Token = Tok_Elsif then\n+            Check_If_Column;\n+\n+            if Present (Else_Statements (If_Node)) then\n+               Error_Msg_SP (\"ELSIF cannot appear after ELSE\");\n+            end if;\n+\n+            Scan; -- past ELSIF\n+            Add_Elsif_Part;\n+\n+         elsif Token = Tok_Else then\n+            Check_If_Column;\n+            Scan; -- past ELSE\n+\n+            if Else_Should_Be_Elsif then\n+               Error_Msg_SP (\"ELSE should be ELSIF\");\n+               Add_Elsif_Part;\n+\n+            else\n+               --  Here we have an else that really is an else\n+\n+               if Present (Else_Statements (If_Node)) then\n+                  Error_Msg_SP (\"Only one ELSE part allowed\");\n+                  Append_List\n+                    (P_Sequence_Of_Statements (SS_Eftm_Eltm_Sreq),\n+                     Else_Statements (If_Node));\n+               else\n+                  Set_Else_Statements\n+                    (If_Node, P_Sequence_Of_Statements (SS_Eftm_Eltm_Sreq));\n+               end if;\n+            end if;\n+\n+         --  If anything other than ELSE or ELSIF, exit the loop. The token\n+         --  had better be END (and in fact it had better be END IF), but\n+         --  we will let End_Statements take care of checking that.\n+\n+         else\n+            exit;\n+         end if;\n+      end loop;\n+\n+      End_Statements;\n+      return If_Node;\n+\n+   end P_If_Statement;\n+\n+   --------------------\n+   -- 5.3  Condition --\n+   --------------------\n+\n+   --  CONDITION ::= boolean_EXPRESSION\n+\n+   function P_Condition return Node_Id is\n+      Cond : Node_Id;\n+\n+   begin\n+      Cond := P_Expression_No_Right_Paren;\n+\n+      --  It is never possible for := to follow a condition, so if we get\n+      --  a := we assume it is a mistyped equality. Note that we do not try\n+      --  to reconstruct the tree correctly in this case, but we do at least\n+      --  give an accurate error message.\n+\n+      while Token = Tok_Colon_Equal loop\n+         Error_Msg_SC (\"\"\":=\"\" should be \"\"=\"\"\");\n+         Scan; -- past junk :=\n+         Discard_Junk_Node (P_Expression_No_Right_Paren);\n+      end loop;\n+\n+      return Cond;\n+   end P_Condition;\n+\n+   -------------------------\n+   -- 5.4  Case Statement --\n+   -------------------------\n+\n+   --  CASE_STATEMENT ::=\n+   --    case EXPRESSION is\n+   --      CASE_STATEMENT_ALTERNATIVE\n+   --      {CASE_STATEMENT_ALTERNATIVE}\n+   --    end case;\n+\n+   --  The caller has checked that the first token is CASE\n+\n+   --  Can raise Error_Resync\n+\n+   function P_Case_Statement return Node_Id is\n+      Case_Node         : Node_Id;\n+      Alternatives_List : List_Id;\n+      First_When_Loc    : Source_Ptr;\n+\n+   begin\n+      Case_Node := New_Node (N_Case_Statement, Token_Ptr);\n+\n+      Push_Scope_Stack;\n+      Scope.Table (Scope.Last).Etyp := E_Case;\n+      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+      Scope.Table (Scope.Last).Labl := Error;\n+      Scope.Table (Scope.Last).Node := Case_Node;\n+\n+      Scan; -- past CASE\n+      Set_Expression (Case_Node, P_Expression_No_Right_Paren);\n+      TF_Is;\n+\n+      --  Prepare to parse case statement alternatives\n+\n+      Alternatives_List := New_List;\n+      P_Pragmas_Opt (Alternatives_List);\n+      First_When_Loc := Token_Ptr;\n+\n+      --  Loop through case statement alternatives\n+\n+      loop\n+         --  If we have a WHEN or OTHERS, then that's fine keep going. Note\n+         --  that it is a semantic check to ensure the proper use of OTHERS\n+\n+         if Token = Tok_When or else Token = Tok_Others then\n+            Append (P_Case_Statement_Alternative, Alternatives_List);\n+\n+         --  If we have an END, then probably we are at the end of the case\n+         --  but we only exit if Check_End thinks the END was reasonable.\n+\n+         elsif Token = Tok_End then\n+            exit when Check_End;\n+\n+         --  Here if token is other than WHEN, OTHERS or END. We definitely\n+         --  have an error, but the question is whether or not to get out of\n+         --  the case statement. We don't want to get out early, or we will\n+         --  get a slew of junk error messages for subsequent when tokens.\n+\n+         --  If the token is not at the start of the line, or if it is indented\n+         --  with respect to the current case statement, then the best guess is\n+         --  that we are still supposed to be inside the case statement. We\n+         --  complain about the missing WHEN, and discard the junk statements.\n+\n+         elsif not Token_Is_At_Start_Of_Line\n+           or else Start_Column > Scope.Table (Scope.Last).Ecol\n+         then\n+            Error_Msg_BC (\"WHEN (case statement alternative) expected\");\n+\n+            --  Here is a possibility for infinite looping if we don't make\n+            --  progress. So try to process statements, otherwise exit\n+\n+            declare\n+               Error_Ptr : constant Source_Ptr := Scan_Ptr;\n+            begin\n+               Discard_Junk_List (P_Sequence_Of_Statements (SS_Whtm));\n+               exit when Scan_Ptr = Error_Ptr and then Check_End;\n+            end;\n+\n+         --  Here we have a junk token at the start of the line and it is\n+         --  not indented. If Check_End thinks there is a missing END, then\n+         --  we will get out of the case, otherwise we keep going.\n+\n+         else\n+            exit when Check_End;\n+         end if;\n+      end loop;\n+\n+      --  Make sure we have at least one alternative\n+\n+      if No (First_Non_Pragma (Alternatives_List)) then\n+         Error_Msg\n+            (\"WHEN expected, must have at least one alternative in case\",\n+             First_When_Loc);\n+         return Error;\n+\n+      else\n+         Set_Alternatives (Case_Node, Alternatives_List);\n+         return Case_Node;\n+      end if;\n+   end P_Case_Statement;\n+\n+   -------------------------------------\n+   -- 5.4  Case Statement Alternative --\n+   -------------------------------------\n+\n+   --  CASE_STATEMENT_ALTERNATIVE ::=\n+   --    when DISCRETE_CHOICE_LIST =>\n+   --      SEQUENCE_OF_STATEMENTS\n+\n+   --  The caller has checked that the initial token is WHEN or OTHERS\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Case_Statement_Alternative return Node_Id is\n+      Case_Alt_Node : Node_Id;\n+\n+   begin\n+      if Style_Check then Style.Check_Indentation; end if;\n+      Case_Alt_Node := New_Node (N_Case_Statement_Alternative, Token_Ptr);\n+      T_When; -- past WHEN (or give error in OTHERS case)\n+      Set_Discrete_Choices (Case_Alt_Node, P_Discrete_Choice_List);\n+      TF_Arrow;\n+      Set_Statements (Case_Alt_Node, P_Sequence_Of_Statements (SS_Sreq_Whtm));\n+      return Case_Alt_Node;\n+   end P_Case_Statement_Alternative;\n+\n+   -------------------------\n+   -- 5.5  Loop Statement --\n+   -------------------------\n+\n+   --  LOOP_STATEMENT ::=\n+   --    [LOOP_STATEMENT_IDENTIFIER:]\n+   --      [ITERATION_SCHEME] loop\n+   --        SEQUENCE_OF_STATEMENTS\n+   --      end loop [loop_IDENTIFIER];\n+\n+   --  ITERATION_SCHEME ::=\n+   --    while CONDITION\n+   --  | for LOOP_PARAMETER_SPECIFICATION\n+\n+   --  The parsing of loop statements is handled by one of three functions\n+   --  P_Loop_Statement, P_For_Statement or P_While_Statement depending\n+   --  on the initial keyword in the construct (excluding the identifier)\n+\n+   --  P_Loop_Statement\n+\n+   --  This function parses the case where no iteration scheme is present\n+\n+   --  The caller has checked that the initial token is LOOP. The parameter\n+   --  is the node identifiers for the loop label if any (or is set to Empty\n+   --  if there is no loop label).\n+\n+   --  Error recovery : cannot raise Error_Resync\n+\n+   function P_Loop_Statement (Loop_Name : Node_Id := Empty) return Node_Id is\n+      Loop_Node : Node_Id;\n+\n+   begin\n+      Push_Scope_Stack;\n+      Scope.Table (Scope.Last).Labl := Loop_Name;\n+      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+      Scope.Table (Scope.Last).Etyp := E_Loop;\n+\n+      Loop_Node := New_Node (N_Loop_Statement, Token_Ptr);\n+      TF_Loop;\n+\n+      if No (Loop_Name) then\n+         Set_Has_Created_Identifier (Loop_Node, True);\n+         Set_Identifier (Loop_Node,\n+           Make_Identifier (Sloc (Loop_Node), Set_Loop_Block_Name ('L')));\n+      else\n+         Set_Identifier (Loop_Node, Loop_Name);\n+      end if;\n+\n+      Append_Elmt (Loop_Node, Label_List);\n+\n+      Set_Statements (Loop_Node, P_Sequence_Of_Statements (SS_Sreq));\n+      End_Statements (Loop_Node);\n+      return Loop_Node;\n+   end P_Loop_Statement;\n+\n+   --  P_For_Statement\n+\n+   --  This function parses a loop statement with a FOR iteration scheme\n+\n+   --  The caller has checked that the initial token is FOR. The parameter\n+   --  is the node identifier for the block label if any (or is set to Empty\n+   --  if there is no block label).\n+\n+   --  Note: the caller fills in the Identifier field if a label was present\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_For_Statement (Loop_Name : Node_Id := Empty) return Node_Id is\n+      Loop_Node        : Node_Id;\n+      Iter_Scheme_Node : Node_Id;\n+      Loop_For_Flag    : Boolean;\n+\n+   begin\n+      Push_Scope_Stack;\n+      Scope.Table (Scope.Last).Labl := Loop_Name;\n+      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+      Scope.Table (Scope.Last).Etyp := E_Loop;\n+\n+      Loop_For_Flag := (Prev_Token = Tok_Loop);\n+      Scan; -- past FOR\n+      Iter_Scheme_Node := New_Node (N_Iteration_Scheme, Token_Ptr);\n+      Set_Loop_Parameter_Specification\n+         (Iter_Scheme_Node, P_Loop_Parameter_Specification);\n+\n+      --  The following is a special test so that a miswritten for loop such\n+      --  as \"loop for I in 1..10;\" is handled nicely, without making an extra\n+      --  entry in the scope stack. We don't bother to actually fix up the\n+      --  tree in this case since it's not worth the effort. Instead we just\n+      --  eat up the loop junk, leaving the entry for what now looks like an\n+      --  unmodified loop intact.\n+\n+      if Loop_For_Flag and then Token = Tok_Semicolon then\n+         Error_Msg_SC (\"LOOP belongs here, not before FOR\");\n+         Pop_Scope_Stack;\n+         return Error;\n+\n+      --  Normal case\n+\n+      else\n+         Loop_Node := New_Node (N_Loop_Statement, Token_Ptr);\n+         TF_Loop;\n+         Set_Statements (Loop_Node, P_Sequence_Of_Statements (SS_Sreq));\n+         End_Statements (Loop_Node);\n+         Set_Iteration_Scheme (Loop_Node, Iter_Scheme_Node);\n+\n+         if No (Loop_Name) then\n+            Set_Has_Created_Identifier (Loop_Node, True);\n+            Set_Identifier (Loop_Node,\n+              Make_Identifier (Sloc (Loop_Node), Set_Loop_Block_Name ('L')));\n+         else\n+            Set_Identifier (Loop_Node, Loop_Name);\n+         end if;\n+\n+         Append_Elmt (Loop_Node, Label_List);\n+\n+         return Loop_Node;\n+      end if;\n+\n+   end P_For_Statement;\n+\n+   --  P_While_Statement\n+\n+   --  This procedure scans a loop statement with a WHILE iteration scheme\n+\n+   --  The caller has checked that the initial token is WHILE. The parameter\n+   --  is the node identifier for the block label if any (or is set to Empty\n+   --  if there is no block label).\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_While_Statement (Loop_Name : Node_Id := Empty) return Node_Id is\n+      Loop_Node        : Node_Id;\n+      Iter_Scheme_Node : Node_Id;\n+      Loop_While_Flag  : Boolean;\n+\n+   begin\n+      Push_Scope_Stack;\n+      Scope.Table (Scope.Last).Labl := Loop_Name;\n+      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+      Scope.Table (Scope.Last).Etyp := E_Loop;\n+\n+      Loop_While_Flag := (Prev_Token = Tok_Loop);\n+      Iter_Scheme_Node := New_Node (N_Iteration_Scheme, Token_Ptr);\n+      Scan; -- past WHILE\n+      Set_Condition (Iter_Scheme_Node, P_Condition);\n+\n+      --  The following is a special test so that a miswritten for loop such\n+      --  as \"loop while I > 10;\" is handled nicely, without making an extra\n+      --  entry in the scope stack. We don't bother to actually fix up the\n+      --  tree in this case since it's not worth the effort. Instead we just\n+      --  eat up the loop junk, leaving the entry for what now looks like an\n+      --  unmodified loop intact.\n+\n+      if Loop_While_Flag and then Token = Tok_Semicolon then\n+         Error_Msg_SC (\"LOOP belongs here, not before WHILE\");\n+         Pop_Scope_Stack;\n+         return Error;\n+\n+      --  Normal case\n+\n+      else\n+         Loop_Node := New_Node (N_Loop_Statement, Token_Ptr);\n+         TF_Loop;\n+         Set_Statements (Loop_Node, P_Sequence_Of_Statements (SS_Sreq));\n+         End_Statements (Loop_Node);\n+         Set_Iteration_Scheme (Loop_Node, Iter_Scheme_Node);\n+\n+         if No (Loop_Name) then\n+            Set_Has_Created_Identifier (Loop_Node, True);\n+            Set_Identifier (Loop_Node,\n+              Make_Identifier (Sloc (Loop_Node), Set_Loop_Block_Name ('L')));\n+         else\n+            Set_Identifier (Loop_Node, Loop_Name);\n+         end if;\n+\n+         Append_Elmt (Loop_Node, Label_List);\n+\n+         return Loop_Node;\n+      end if;\n+\n+   end P_While_Statement;\n+\n+   ---------------------------------------\n+   -- 5.5  Loop Parameter Specification --\n+   ---------------------------------------\n+\n+   --  LOOP_PARAMETER_SPECIFICATION ::=\n+   --    DEFINING_IDENTIFIER in [reverse] DISCRETE_SUBTYPE_DEFINITION\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Loop_Parameter_Specification return Node_Id is\n+      Loop_Param_Specification_Node : Node_Id;\n+\n+      ID_Node    : Node_Id;\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      Loop_Param_Specification_Node :=\n+        New_Node (N_Loop_Parameter_Specification, Token_Ptr);\n+\n+      Save_Scan_State (Scan_State);\n+      ID_Node := P_Defining_Identifier;\n+      Set_Defining_Identifier (Loop_Param_Specification_Node, ID_Node);\n+\n+      if Token = Tok_Left_Paren then\n+         Error_Msg_SC (\"subscripted loop parameter not allowed\");\n+         Restore_Scan_State (Scan_State);\n+         Discard_Junk_Node (P_Name);\n+\n+      elsif Token = Tok_Dot then\n+         Error_Msg_SC (\"selected loop parameter not allowed\");\n+         Restore_Scan_State (Scan_State);\n+         Discard_Junk_Node (P_Name);\n+      end if;\n+\n+      T_In;\n+\n+      if Token = Tok_Reverse then\n+         Scan; -- past REVERSE\n+         Set_Reverse_Present (Loop_Param_Specification_Node, True);\n+      end if;\n+\n+      Set_Discrete_Subtype_Definition\n+        (Loop_Param_Specification_Node, P_Discrete_Subtype_Definition);\n+      return Loop_Param_Specification_Node;\n+\n+   exception\n+      when Error_Resync =>\n+         return Error;\n+   end P_Loop_Parameter_Specification;\n+\n+   --------------------------\n+   -- 5.6  Block Statement --\n+   --------------------------\n+\n+   --  BLOCK_STATEMENT ::=\n+   --    [block_STATEMENT_IDENTIFIER:]\n+   --      [declare\n+   --        DECLARATIVE_PART]\n+   --      begin\n+   --        HANDLED_SEQUENCE_OF_STATEMENTS\n+   --      end [block_IDENTIFIER];\n+\n+   --  The parsing of block statements is handled by one of the two functions\n+   --  P_Declare_Statement or P_Begin_Statement depending on whether or not\n+   --  a declare section is present\n+\n+   --  P_Declare_Statement\n+\n+   --  This function parses a block statement with DECLARE present\n+\n+   --  The caller has checked that the initial token is DECLARE.\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Declare_Statement\n+     (Block_Name : Node_Id := Empty)\n+      return       Node_Id\n+   is\n+      Block_Node : Node_Id;\n+\n+   begin\n+      Block_Node := New_Node (N_Block_Statement, Token_Ptr);\n+\n+      Push_Scope_Stack;\n+      Scope.Table (Scope.Last).Etyp := E_Name;\n+      Scope.Table (Scope.Last).Lreq := Present (Block_Name);\n+      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scope.Table (Scope.Last).Labl := Block_Name;\n+      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+\n+      Scan; -- past DECLARE\n+\n+      if No (Block_Name) then\n+         Set_Has_Created_Identifier (Block_Node, True);\n+         Set_Identifier (Block_Node,\n+           Make_Identifier (Sloc (Block_Node), Set_Loop_Block_Name ('B')));\n+      else\n+         Set_Identifier (Block_Node, Block_Name);\n+      end if;\n+\n+      Append_Elmt (Block_Node, Label_List);\n+      Parse_Decls_Begin_End (Block_Node);\n+      return Block_Node;\n+   end P_Declare_Statement;\n+\n+   --  P_Begin_Statement\n+\n+   --  This function parses a block statement with no DECLARE present\n+\n+   --  The caller has checked that the initial token is BEGIN\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Begin_Statement\n+     (Block_Name : Node_Id := Empty)\n+      return       Node_Id\n+   is\n+      Block_Node : Node_Id;\n+\n+   begin\n+      Block_Node := New_Node (N_Block_Statement, Token_Ptr);\n+\n+      Push_Scope_Stack;\n+      Scope.Table (Scope.Last).Etyp := E_Name;\n+      Scope.Table (Scope.Last).Lreq := Present (Block_Name);\n+      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scope.Table (Scope.Last).Labl := Block_Name;\n+      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+\n+      if No (Block_Name) then\n+         Set_Has_Created_Identifier (Block_Node, True);\n+         Set_Identifier (Block_Node,\n+           Make_Identifier (Sloc (Block_Node), Set_Loop_Block_Name ('B')));\n+      else\n+         Set_Identifier (Block_Node, Block_Name);\n+      end if;\n+\n+      Append_Elmt (Block_Node, Label_List);\n+\n+      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+      Scan; -- past BEGIN\n+      Set_Handled_Statement_Sequence\n+        (Block_Node, P_Handled_Sequence_Of_Statements);\n+      End_Statements (Handled_Statement_Sequence (Block_Node));\n+      return Block_Node;\n+   end P_Begin_Statement;\n+\n+   -------------------------\n+   -- 5.7  Exit Statement --\n+   -------------------------\n+\n+   --  EXIT_STATEMENT ::=\n+   --    exit [loop_NAME] [when CONDITION];\n+\n+   --  The caller has checked that the initial token is EXIT\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Exit_Statement return Node_Id is\n+      Exit_Node : Node_Id;\n+\n+      function Missing_Semicolon_On_Exit return Boolean;\n+      --  This function deals with the following specialized situation\n+      --\n+      --    when 'x' =>\n+      --       exit [identifier]\n+      --    when 'y' =>\n+      --\n+      --  This looks like a messed up EXIT WHEN, when in fact the problem\n+      --  is a missing semicolon. It is called with Token pointing to the\n+      --  WHEN token, and returns True if a semicolon is missing before\n+      --  the WHEN as in the above example.\n+\n+      function Missing_Semicolon_On_Exit return Boolean is\n+         State : Saved_Scan_State;\n+\n+      begin\n+         if not Token_Is_At_Start_Of_Line then\n+            return False;\n+\n+         elsif Scope.Table (Scope.Last).Etyp /= E_Case then\n+            return False;\n+\n+         else\n+            Save_Scan_State (State);\n+            Scan; -- past WHEN\n+            Scan; -- past token after WHEN\n+\n+            if Token = Tok_Arrow then\n+               Restore_Scan_State (State);\n+               return True;\n+            else\n+               Restore_Scan_State (State);\n+               return False;\n+            end if;\n+         end if;\n+      end Missing_Semicolon_On_Exit;\n+\n+   --  Start of processing for P_Exit_Statement\n+\n+   begin\n+      Exit_Node := New_Node (N_Exit_Statement, Token_Ptr);\n+      Scan; -- past EXIT\n+\n+      if Token = Tok_Identifier then\n+         Set_Name (Exit_Node, P_Qualified_Simple_Name);\n+\n+      elsif Style_Check then\n+         --  This EXIT has no name, so check that\n+         --  the innermost loop is unnamed too.\n+\n+         Check_No_Exit_Name :\n+         for J in reverse 1 .. Scope.Last loop\n+            if Scope.Table (J).Etyp = E_Loop then\n+               if Present (Scope.Table (J).Labl) then\n+\n+                  --  Innermost loop in fact had a name, style check fails\n+\n+                  Style.No_Exit_Name (Scope.Table (J).Labl);\n+               end if;\n+\n+               exit Check_No_Exit_Name;\n+            end if;\n+         end loop Check_No_Exit_Name;\n+      end if;\n+\n+      if Token = Tok_When and then not Missing_Semicolon_On_Exit then\n+         Scan; -- past WHEN\n+         Set_Condition (Exit_Node, P_Condition);\n+\n+      --  Allow IF instead of WHEN, giving error message\n+\n+      elsif Token = Tok_If then\n+         T_When;\n+         Scan; -- past IF used in place of WHEN\n+         Set_Condition (Exit_Node, P_Expression_No_Right_Paren);\n+      end if;\n+\n+      TF_Semicolon;\n+      return Exit_Node;\n+   end P_Exit_Statement;\n+\n+   -------------------------\n+   -- 5.8  Goto Statement --\n+   -------------------------\n+\n+   --  GOTO_STATEMENT ::= goto label_NAME;\n+\n+   --  The caller has checked that the initial token is GOTO  (or TO in the\n+   --  error case where GO and TO were incorrectly separated).\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Goto_Statement return Node_Id is\n+      Goto_Node : Node_Id;\n+\n+   begin\n+      Goto_Node := New_Node (N_Goto_Statement, Token_Ptr);\n+      Scan; -- past GOTO (or TO)\n+      Set_Name (Goto_Node, P_Qualified_Simple_Name_Resync);\n+      No_Constraint;\n+      TF_Semicolon;\n+      return Goto_Node;\n+   end P_Goto_Statement;\n+\n+   ---------------------------\n+   -- Parse_Decls_Begin_End --\n+   ---------------------------\n+\n+   --  This function parses the construct:\n+\n+   --      DECLARATIVE_PART\n+   --    begin\n+   --      HANDLED_SEQUENCE_OF_STATEMENTS\n+   --    end [NAME];\n+\n+   --  The caller has built the scope stack entry, and created the node to\n+   --  whose Declarations and Handled_Statement_Sequence fields are to be\n+   --  set. On return these fields are filled in (except in the case of a\n+   --  task body, where the handled statement sequence is optional, and may\n+   --  thus be Empty), and the scan is positioned past the End sequence.\n+\n+   --  If the BEGIN is missing, then the parent node is used to help construct\n+   --  an appropriate missing BEGIN message. Possibilities for the parent are:\n+\n+   --    N_Block_Statement     declare block\n+   --    N_Entry_Body          entry body\n+   --    N_Package_Body        package body (begin part optional)\n+   --    N_Subprogram_Body     procedure or function body\n+   --    N_Task_Body           task body\n+\n+   --  Note: in the case of a block statement, there is definitely a DECLARE\n+   --  present (because a Begin statement without a DECLARE is handled by the\n+   --  P_Begin_Statement procedure, which does not call Parse_Decls_Begin_End.\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   procedure Parse_Decls_Begin_End (Parent : Node_Id) is\n+      Body_Decl    : Node_Id;\n+      Body_Sloc    : Source_Ptr;\n+      Decls        : List_Id;\n+      Decl         : Node_Id;\n+      Parent_Nkind : Node_Kind;\n+      Spec_Node    : Node_Id;\n+      HSS          : Node_Id;\n+\n+      procedure Missing_Begin (Msg : String);\n+      --  Called to post a missing begin message. In the normal case this is\n+      --  posted at the start of the current token. A special case arises when\n+      --  P_Declarative_Items has previously found a missing begin, in which\n+      --  case we replace the original error message.\n+\n+      procedure Set_Null_HSS (Parent : Node_Id);\n+      --  Construct an empty handled statement sequence and install in Parent\n+      --  Leaves HSS set to reference the newly constructed statement sequence.\n+\n+      -------------------\n+      -- Missing_Begin --\n+      -------------------\n+\n+      procedure Missing_Begin (Msg : String) is\n+      begin\n+         if Missing_Begin_Msg = No_Error_Msg then\n+            Error_Msg_BC (Msg);\n+         else\n+            Change_Error_Text (Missing_Begin_Msg, Msg);\n+\n+            --  Purge any messages issued after than, since a missing begin\n+            --  can cause a lot of havoc, and it is better not to dump these\n+            --  cascaded messages on the user.\n+\n+            Purge_Messages (Get_Location (Missing_Begin_Msg), Prev_Token_Ptr);\n+         end if;\n+      end Missing_Begin;\n+\n+      ------------------\n+      -- Set_Null_HSS --\n+      ------------------\n+\n+      procedure Set_Null_HSS (Parent : Node_Id) is\n+         Null_Stm : Node_Id;\n+\n+      begin\n+         Null_Stm :=\n+           Make_Null_Statement (Token_Ptr);\n+         Set_Comes_From_Source (Null_Stm, False);\n+\n+         HSS :=\n+           Make_Handled_Sequence_Of_Statements (Token_Ptr,\n+             Statements => New_List (Null_Stm));\n+         Set_Comes_From_Source (HSS, False);\n+\n+         Set_Handled_Statement_Sequence (Parent, HSS);\n+      end Set_Null_HSS;\n+\n+   --  Start of processing for Parse_Decls_Begin_End\n+\n+   begin\n+      Decls := P_Declarative_Part;\n+\n+      --  Check for misplacement of later vs basic declarations in Ada 83\n+\n+      if Ada_83 then\n+         Decl := First (Decls);\n+\n+         --  Loop through sequence of basic declarative items\n+\n+         Outer : while Present (Decl) loop\n+            if Nkind (Decl) /= N_Subprogram_Body\n+              and then Nkind (Decl) /= N_Package_Body\n+              and then Nkind (Decl) /= N_Task_Body\n+              and then Nkind (Decl) not in  N_Body_Stub\n+            then\n+               Next (Decl);\n+\n+            --  Once a body is encountered, we only allow later declarative\n+            --  items. The inner loop checks the rest of the list.\n+\n+            else\n+               Body_Sloc := Sloc (Decl);\n+\n+               Inner : while Present (Decl) loop\n+                  if Nkind (Decl) not in N_Later_Decl_Item\n+                    and then Nkind (Decl) /= N_Pragma\n+                  then\n+                     if Ada_83 then\n+                        Error_Msg_Sloc := Body_Sloc;\n+                        Error_Msg_N\n+                          (\"(Ada 83) decl cannot appear after body#\", Decl);\n+                     end if;\n+                  end if;\n+\n+                  Next (Decl);\n+               end loop Inner;\n+            end if;\n+         end loop Outer;\n+      end if;\n+\n+      --  Here is where we deal with the case of IS used instead of semicolon.\n+      --  Specifically, if the last declaration in the declarative part is a\n+      --  subprogram body still marked as having a bad IS, then this is where\n+      --  we decide that the IS should really have been a semicolon and that\n+      --  the body should have been a declaration. Note that if the bad IS\n+      --  had turned out to be OK (i.e. a decent begin/end was found for it),\n+      --  then the Bad_Is_Detected flag would have been reset by now.\n+\n+      Body_Decl := Last (Decls);\n+\n+      if Present (Body_Decl)\n+        and then Nkind (Body_Decl) = N_Subprogram_Body\n+        and then Bad_Is_Detected (Body_Decl)\n+      then\n+         --  OK, we have the case of a bad IS, so we need to fix up the tree.\n+         --  What we have now is a subprogram body with attached declarations\n+         --  and a possible statement sequence.\n+\n+         --  First step is to take the declarations that were part of the bogus\n+         --  subprogram body and append them to the outer declaration chain.\n+         --  In other words we append them past the body (which we will later\n+         --  convert into a declaration).\n+\n+         Append_List (Declarations (Body_Decl), Decls);\n+\n+         --  Now take the handled statement sequence of the bogus body and\n+         --  set it as the statement sequence for the outer construct. Note\n+         --  that it may be empty (we specially allowed a missing BEGIN for\n+         --  a subprogram body marked as having a bad IS -- see below).\n+\n+         Set_Handled_Statement_Sequence (Parent,\n+           Handled_Statement_Sequence (Body_Decl));\n+\n+         --  Next step is to convert the old body node to a declaration node\n+\n+         Spec_Node := Specification (Body_Decl);\n+         Change_Node (Body_Decl, N_Subprogram_Declaration);\n+         Set_Specification (Body_Decl, Spec_Node);\n+\n+         --  Final step is to put the declarations for the parent where\n+         --  they belong, and then fall through the IF to scan out the\n+         --  END statements.\n+\n+         Set_Declarations (Parent, Decls);\n+\n+      --  This is the normal case (i.e. any case except the bad IS case)\n+      --  If we have a BEGIN, then scan out the sequence of statements, and\n+      --  also reset the expected column for the END to match the BEGIN.\n+\n+      else\n+         Set_Declarations (Parent, Decls);\n+\n+         if Token = Tok_Begin then\n+            if Style_Check then Style.Check_Indentation; end if;\n+\n+            Error_Msg_Col := Scope.Table (Scope.Last).Ecol;\n+\n+            if Style.RM_Column_Check\n+              and then Token_Is_At_Start_Of_Line\n+              and then Start_Column /= Error_Msg_Col\n+            then\n+               Error_Msg_SC (\"(style) BEGIN in wrong column, should be@\");\n+\n+            else\n+               Scope.Table (Scope.Last).Ecol := Start_Column;\n+            end if;\n+\n+            Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+            Scan; -- past BEGIN\n+            Set_Handled_Statement_Sequence (Parent,\n+              P_Handled_Sequence_Of_Statements);\n+\n+         --  No BEGIN present\n+\n+         else\n+            Parent_Nkind := Nkind (Parent);\n+\n+            --  A special check for the missing IS case. If we have a\n+            --  subprogram body that was marked as having a suspicious\n+            --  IS, and the current token is END, then we simply confirm\n+            --  the suspicion, and do not require a BEGIN to be present\n+\n+            if Parent_Nkind = N_Subprogram_Body\n+              and then Token  = Tok_End\n+              and then Scope.Table (Scope.Last).Etyp = E_Suspicious_Is\n+            then\n+               Scope.Table (Scope.Last).Etyp := E_Bad_Is;\n+\n+            --  Otherwise BEGIN is not required for a package body, so we\n+            --  don't mind if it is missing, but we do construct a dummy\n+            --  one (so that we have somewhere to set End_Label).\n+\n+            --  However if we have something other than a BEGIN which\n+            --  looks like it might be statements, then we signal a missing\n+            --  BEGIN for these cases as well. We define \"something which\n+            --  looks like it might be statements\" as a token other than\n+            --  END, EOF, or a token which starts declarations.\n+\n+            elsif Parent_Nkind = N_Package_Body\n+              and then (Token = Tok_End\n+                          or else Token = Tok_EOF\n+                          or else Token in Token_Class_Declk)\n+            then\n+               Set_Null_HSS (Parent);\n+\n+            --  These are cases in which a BEGIN is required and not present\n+\n+            else\n+               Set_Null_HSS (Parent);\n+\n+               --  Prepare to issue error message\n+\n+               Error_Msg_Sloc := Scope.Table (Scope.Last).Sloc;\n+               Error_Msg_Node_1 := Scope.Table (Scope.Last).Labl;\n+\n+               --  Now issue appropriate message\n+\n+               if Parent_Nkind = N_Block_Statement then\n+                  Missing_Begin (\"missing BEGIN for DECLARE#!\");\n+\n+               elsif Parent_Nkind = N_Entry_Body then\n+                  Missing_Begin (\"missing BEGIN for ENTRY#!\");\n+\n+               elsif Parent_Nkind = N_Subprogram_Body then\n+                  if Nkind (Specification (Parent))\n+                               = N_Function_Specification\n+                  then\n+                     Missing_Begin (\"missing BEGIN for function&#!\");\n+                  else\n+                     Missing_Begin (\"missing BEGIN for procedure&#!\");\n+                  end if;\n+\n+               --  The case for package body arises only when\n+               --  we have possible statement junk present.\n+\n+               elsif Parent_Nkind = N_Package_Body then\n+                  Missing_Begin (\"missing BEGIN for package body&#!\");\n+\n+               else\n+                  pragma Assert (Parent_Nkind = N_Task_Body);\n+                  Missing_Begin (\"missing BEGIN for task body&#!\");\n+               end if;\n+\n+               --  Here we pick up the statements after the BEGIN that\n+               --  should have been present but was not. We don't insist\n+               --  on statements being present if P_Declarative_Part had\n+               --  already found a missing BEGIN, since it might have\n+               --  swallowed a lone statement into the declarative part.\n+\n+               if Missing_Begin_Msg /= No_Error_Msg\n+                 and then Token = Tok_End\n+               then\n+                  null;\n+               else\n+                  Set_Handled_Statement_Sequence (Parent,\n+                    P_Handled_Sequence_Of_Statements);\n+               end if;\n+            end if;\n+         end if;\n+      end if;\n+\n+      --  Here with declarations and handled statement sequence scanned\n+\n+      if Present (Handled_Statement_Sequence (Parent)) then\n+         End_Statements (Handled_Statement_Sequence (Parent));\n+      else\n+         End_Statements;\n+      end if;\n+\n+      --  We know that End_Statements removed an entry from the scope stack\n+      --  (because it is required to do so under all circumstances). We can\n+      --  therefore reference the entry it removed one past the stack top.\n+      --  What we are interested in is whether it was a case of a bad IS.\n+\n+      if Scope.Table (Scope.Last + 1).Etyp = E_Bad_Is then\n+         Error_Msg (\"IS should be \"\";\"\"\", Scope.Table (Scope.Last + 1).S_Is);\n+         Set_Bad_Is_Detected (Parent, True);\n+      end if;\n+\n+   end Parse_Decls_Begin_End;\n+\n+   -------------------------\n+   -- Set_Loop_Block_Name --\n+   -------------------------\n+\n+   function Set_Loop_Block_Name (L : Character) return Name_Id is\n+   begin\n+      Name_Buffer (1) := L;\n+      Name_Buffer (2) := '_';\n+      Name_Len := 2;\n+      Loop_Block_Count := Loop_Block_Count + 1;\n+      Add_Nat_To_Name_Buffer (Loop_Block_Count);\n+      return Name_Find;\n+   end Set_Loop_Block_Name;\n+\n+   ---------------\n+   -- Then_Scan --\n+   ---------------\n+\n+   procedure Then_Scan is\n+   begin\n+      TF_Then;\n+\n+      while Token = Tok_Then loop\n+         Error_Msg_SC (\"redundant THEN\");\n+         TF_Then;\n+      end loop;\n+\n+      if Token = Tok_And or else Token = Tok_Or then\n+         Error_Msg_SC (\"unexpected logical operator\");\n+         Scan;\n+\n+         if (Prev_Token = Tok_And and then Token = Tok_Then)\n+              or else\n+            (Prev_Token = Tok_Or  and then Token = Tok_Else)\n+         then\n+            Scan;\n+         end if;\n+\n+         Discard_Junk_Node (P_Expression);\n+      end if;\n+\n+      if Token = Tok_Then then\n+         Scan;\n+      end if;\n+   end Then_Scan;\n+\n+end Ch5;"}, {"sha": "d5d1d3daaa121cd5254a1b2966cc8dbf492b6c3b", "filename": "gcc/ada/par-ch6.adb", "status": "added", "additions": 1165, "deletions": 0, "changes": 1165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,1165 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P A R . C H 6                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.81 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Style_Checks (All_Checks);\n+--  Turn off subprogram body ordering check. Subprograms are in order\n+--  by RM section rather than alphabetical\n+\n+with Sinfo.CN; use Sinfo.CN;\n+\n+separate (Par)\n+package body Ch6 is\n+\n+   --  Local subprograms, used only in this chapter\n+\n+   function P_Defining_Designator        return Node_Id;\n+   function P_Defining_Operator_Symbol   return Node_Id;\n+\n+   procedure Check_Junk_Semicolon_Before_Return;\n+   --  Check for common error of junk semicolon before RETURN keyword of\n+   --  function specification. If present, skip over it with appropriate\n+   --  error message, leaving Scan_Ptr pointing to the RETURN after. This\n+   --  routine also deals with a possibly misspelled version of Return.\n+\n+   ----------------------------------------\n+   -- Check_Junk_Semicolon_Before_Return --\n+   ----------------------------------------\n+\n+   procedure Check_Junk_Semicolon_Before_Return is\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      if Token = Tok_Semicolon then\n+         Save_Scan_State (Scan_State);\n+         Scan; -- past the semicolon\n+\n+         if Token = Tok_Return then\n+            Restore_Scan_State (Scan_State);\n+            Error_Msg_SC (\"Unexpected semicolon ignored\");\n+            Scan; -- rescan past junk semicolon\n+\n+         else\n+            Restore_Scan_State (Scan_State);\n+         end if;\n+\n+      elsif Bad_Spelling_Of (Tok_Return) then\n+         null;\n+      end if;\n+   end Check_Junk_Semicolon_Before_Return;\n+\n+   -----------------------------------------------------\n+   -- 6.1  Subprogram (Also 6.3, 8.5.4, 10.1.3, 12.3) --\n+   -----------------------------------------------------\n+\n+   --  This routine scans out a subprogram declaration, subprogram body,\n+   --  subprogram renaming declaration or subprogram generic instantiation.\n+\n+   --  SUBPROGRAM_DECLARATION ::= SUBPROGRAM_SPECIFICATION;\n+\n+   --  ABSTRACT_SUBPROGRAM_DECLARATION ::=\n+   --    SUBPROGRAM_SPECIFICATION is abstract;\n+\n+   --  SUBPROGRAM_SPECIFICATION ::=\n+   --      procedure DEFINING_PROGRAM_UNIT_NAME PARAMETER_PROFILE\n+   --    | function DEFINING_DESIGNATOR PARAMETER_AND_RESULT_PROFILE\n+\n+   --  PARAMETER_PROFILE ::= [FORMAL_PART]\n+\n+   --  PARAMETER_AND_RESULT_PROFILE ::= [FORMAL_PART] return SUBTYPE_MARK\n+\n+   --  SUBPROGRAM_BODY ::=\n+   --    SUBPROGRAM_SPECIFICATION is\n+   --      DECLARATIVE_PART\n+   --    begin\n+   --      HANDLED_SEQUENCE_OF_STATEMENTS\n+   --    end [DESIGNATOR];\n+\n+   --  SUBPROGRAM_RENAMING_DECLARATION ::=\n+   --    SUBPROGRAM_SPECIFICATION renames callable_entity_NAME;\n+\n+   --  SUBPROGRAM_BODY_STUB ::=\n+   --    SUBPROGRAM_SPECIFICATION is separate;\n+\n+   --  GENERIC_INSTANTIATION ::=\n+   --    procedure DEFINING_PROGRAM_UNIT_NAME is\n+   --      new generic_procedure_NAME [GENERIC_ACTUAL_PART];\n+   --  | function DEFINING_DESIGNATOR is\n+   --      new generic_function_NAME [GENERIC_ACTUAL_PART];\n+\n+   --  The value in Pf_Flags indicates which of these possible declarations\n+   --  is acceptable to the caller:\n+\n+   --    Pf_Flags.Decl                 Set if declaration OK\n+   --    Pf_Flags.Gins                 Set if generic instantiation OK\n+   --    Pf_Flags.Pbod                 Set if proper body OK\n+   --    Pf_Flags.Rnam                 Set if renaming declaration OK\n+   --    Pf_Flags.Stub                 Set if body stub OK\n+\n+   --  If an inappropriate form is encountered, it is scanned out but an\n+   --  error message indicating that it is appearing in an inappropriate\n+   --  context is issued. The only possible values for Pf_Flags are those\n+   --  defined as constants in the Par package.\n+\n+   --  The caller has checked that the initial token is FUNCTION or PROCEDURE\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Subprogram (Pf_Flags : Pf_Rec) return Node_Id is\n+      Specification_Node : Node_Id;\n+      Name_Node   : Node_Id;\n+      Fpart_List  : List_Id;\n+      Fpart_Sloc  : Source_Ptr;\n+      Return_Node : Node_Id;\n+      Inst_Node   : Node_Id;\n+      Body_Node   : Node_Id;\n+      Decl_Node   : Node_Id;\n+      Rename_Node : Node_Id;\n+      Absdec_Node : Node_Id;\n+      Stub_Node   : Node_Id;\n+      Fproc_Sloc  : Source_Ptr;\n+      Func        : Boolean;\n+      Scan_State  : Saved_Scan_State;\n+\n+   begin\n+      --  Set up scope stack entry. Note that the Labl field will be set later\n+\n+      SIS_Entry_Active := False;\n+      SIS_Missing_Semicolon_Message := No_Error_Msg;\n+      Push_Scope_Stack;\n+      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+      Scope.Table (Scope.Last).Etyp := E_Name;\n+      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scope.Table (Scope.Last).Lreq := False;\n+\n+      Func := (Token = Tok_Function);\n+      Fproc_Sloc := Token_Ptr;\n+      Scan; -- past FUNCTION or PROCEDURE\n+      Ignore (Tok_Type);\n+      Ignore (Tok_Body);\n+\n+      if Func then\n+         Name_Node := P_Defining_Designator;\n+\n+         if Nkind (Name_Node) = N_Defining_Operator_Symbol\n+           and then Scope.Last = 1\n+         then\n+            Error_Msg_SP (\"operator symbol not allowed at library level\");\n+            Name_Node := New_Entity (N_Defining_Identifier, Sloc (Name_Node));\n+\n+            --  Set name from file name, we need some junk name, and that's\n+            --  as good as anything. This is only approximate, since we do\n+            --  not do anything with non-standard name translations.\n+\n+            Get_Name_String (File_Name (Current_Source_File));\n+\n+            for J in 1 .. Name_Len loop\n+               if Name_Buffer (J) = '.' then\n+                  Name_Len := J - 1;\n+                  exit;\n+               end if;\n+            end loop;\n+\n+            Set_Chars (Name_Node, Name_Find);\n+            Set_Error_Posted (Name_Node);\n+         end if;\n+\n+      else\n+         Name_Node := P_Defining_Program_Unit_Name;\n+      end if;\n+\n+      Scope.Table (Scope.Last).Labl := Name_Node;\n+\n+      if Token = Tok_Colon then\n+         Error_Msg_SC (\"redundant colon ignored\");\n+         Scan; -- past colon\n+      end if;\n+\n+      --  Deal with generic instantiation, the one case in which we do not\n+      --  have a subprogram specification as part of whatever we are parsing\n+\n+      if Token = Tok_Is then\n+         Save_Scan_State (Scan_State); -- at the IS\n+         T_Is; -- checks for redundant IS's\n+\n+         if Token = Tok_New then\n+            if not Pf_Flags.Gins then\n+               Error_Msg_SC (\"generic instantation not allowed here!\");\n+            end if;\n+\n+            Scan; -- past NEW\n+\n+            if Func then\n+               Inst_Node := New_Node (N_Function_Instantiation, Fproc_Sloc);\n+               Set_Name (Inst_Node, P_Function_Name);\n+            else\n+               Inst_Node := New_Node (N_Procedure_Instantiation, Fproc_Sloc);\n+               Set_Name (Inst_Node, P_Qualified_Simple_Name);\n+            end if;\n+\n+            Set_Defining_Unit_Name (Inst_Node, Name_Node);\n+            Set_Generic_Associations (Inst_Node, P_Generic_Actual_Part_Opt);\n+            TF_Semicolon;\n+            Pop_Scope_Stack; -- Don't need scope stack entry in this case\n+            return Inst_Node;\n+\n+         else\n+            Restore_Scan_State (Scan_State); -- to the IS\n+         end if;\n+      end if;\n+\n+      --  If not a generic instantiation, then we definitely have a subprogram\n+      --  specification (all possibilities at this stage include one here)\n+\n+      Fpart_Sloc := Token_Ptr;\n+\n+      Check_Misspelling_Of (Tok_Return);\n+\n+      --  Scan formal part. First a special error check. If we have an\n+      --  identifier here, then we have a definite error. If this identifier\n+      --  is on the same line as the designator, then we assume it is the\n+      --  first formal after a missing left parenthesis\n+\n+      if Token = Tok_Identifier\n+        and then not Token_Is_At_Start_Of_Line\n+      then\n+            T_Left_Paren; -- to generate message\n+            Fpart_List := P_Formal_Part;\n+\n+      --  Otherwise scan out an optional formal part in the usual manner\n+\n+      else\n+         Fpart_List := P_Parameter_Profile;\n+      end if;\n+\n+      --  We treat what we have as a function specification if FUNCTION was\n+      --  used, or if a RETURN is present. This gives better error recovery\n+      --  since later RETURN statements will be valid in either case.\n+\n+      Check_Junk_Semicolon_Before_Return;\n+      Return_Node := Error;\n+\n+      if Token = Tok_Return then\n+         if not Func then\n+            Error_Msg (\"PROCEDURE should be FUNCTION\", Fproc_Sloc);\n+            Func := True;\n+         end if;\n+\n+         Scan; -- past RETURN\n+         Return_Node := P_Subtype_Mark;\n+         No_Constraint;\n+\n+      else\n+         if Func then\n+            Ignore (Tok_Right_Paren);\n+            TF_Return;\n+         end if;\n+      end if;\n+\n+      if Func then\n+         Specification_Node :=\n+           New_Node (N_Function_Specification, Fproc_Sloc);\n+         Set_Subtype_Mark (Specification_Node, Return_Node);\n+\n+      else\n+         Specification_Node :=\n+           New_Node (N_Procedure_Specification, Fproc_Sloc);\n+      end if;\n+\n+      Set_Defining_Unit_Name (Specification_Node, Name_Node);\n+      Set_Parameter_Specifications (Specification_Node, Fpart_List);\n+\n+      --  Error check: barriers not allowed on protected functions/procedures\n+\n+      if Token = Tok_When then\n+         if Func then\n+            Error_Msg_SC (\"barrier not allowed on function, only on entry\");\n+         else\n+            Error_Msg_SC (\"barrier not allowed on procedure, only on entry\");\n+         end if;\n+\n+         Scan; -- past WHEN\n+         Discard_Junk_Node (P_Expression);\n+      end if;\n+\n+      --  Deal with case of semicolon ending a subprogram declaration\n+\n+      if Token = Tok_Semicolon then\n+         if not Pf_Flags.Decl then\n+            T_Is;\n+         end if;\n+\n+         Scan; -- past semicolon\n+\n+         --  If semicolon is immediately followed by IS, then ignore the\n+         --  semicolon, and go process the body.\n+\n+         if Token = Tok_Is then\n+            Error_Msg_SP (\"unexpected semicolon ignored\");\n+            T_Is; -- ignroe redundant IS's\n+            goto Subprogram_Body;\n+\n+         --  If BEGIN follows in an appropriate column, we immediately\n+         --  commence the error action of assuming that the previous\n+         --  subprogram declaration should have been a subprogram body,\n+         --  i.e. that the terminating semicolon should have been IS.\n+\n+         elsif Token = Tok_Begin\n+            and then Start_Column >= Scope.Table (Scope.Last).Ecol\n+         then\n+            Error_Msg_SP (\"\"\";\"\" should be IS!\");\n+            goto Subprogram_Body;\n+\n+         else\n+            goto Subprogram_Declaration;\n+         end if;\n+\n+      --  Case of not followed by semicolon\n+\n+      else\n+         --  Subprogram renaming declaration case\n+\n+         Check_Misspelling_Of (Tok_Renames);\n+\n+         if Token = Tok_Renames then\n+            if not Pf_Flags.Rnam then\n+               Error_Msg_SC (\"renaming declaration not allowed here!\");\n+            end if;\n+\n+            Rename_Node :=\n+              New_Node (N_Subprogram_Renaming_Declaration, Token_Ptr);\n+            Scan; -- past RENAMES\n+            Set_Name (Rename_Node, P_Name);\n+            Set_Specification (Rename_Node, Specification_Node);\n+            TF_Semicolon;\n+            Pop_Scope_Stack;\n+            return Rename_Node;\n+\n+         --  Case of IS following subprogram specification\n+\n+         elsif Token = Tok_Is then\n+            T_Is; -- ignore redundant Is's\n+\n+            if Token_Name = Name_Abstract then\n+               Check_95_Keyword (Tok_Abstract, Tok_Semicolon);\n+            end if;\n+\n+            --  Deal nicely with (now obsolete) use of <> in place of abstract\n+\n+            if Token = Tok_Box then\n+               Error_Msg_SC (\"ABSTRACT expected\");\n+               Token := Tok_Abstract;\n+            end if;\n+\n+            --  Abstract subprogram declaration case\n+\n+            if Token = Tok_Abstract then\n+               Absdec_Node :=\n+                 New_Node (N_Abstract_Subprogram_Declaration, Token_Ptr);\n+               Set_Specification (Absdec_Node, Specification_Node);\n+               Pop_Scope_Stack; -- discard unneeded entry\n+               Scan; -- past ABSTRACT\n+               TF_Semicolon;\n+               return Absdec_Node;\n+\n+            --  Check for IS NEW with Formal_Part present and handle nicely\n+\n+            elsif Token = Tok_New then\n+               Error_Msg\n+                 (\"formal part not allowed in instantiation\", Fpart_Sloc);\n+               Scan; -- past NEW\n+\n+               if Func then\n+                  Inst_Node := New_Node (N_Function_Instantiation, Fproc_Sloc);\n+               else\n+                  Inst_Node :=\n+                    New_Node (N_Procedure_Instantiation, Fproc_Sloc);\n+               end if;\n+\n+               Set_Defining_Unit_Name (Inst_Node, Name_Node);\n+               Set_Name (Inst_Node, P_Name);\n+               Set_Generic_Associations (Inst_Node, P_Generic_Actual_Part_Opt);\n+               TF_Semicolon;\n+               Pop_Scope_Stack; -- Don't need scope stack entry in this case\n+               return Inst_Node;\n+\n+            else\n+               goto Subprogram_Body;\n+            end if;\n+\n+         --  Here we have a missing IS or missing semicolon, we always guess\n+         --  a missing semicolon, since we are pretty good at fixing up a\n+         --  semicolon which should really be an IS\n+\n+         else\n+            Error_Msg_AP (\"missing \"\";\"\"\");\n+            SIS_Missing_Semicolon_Message := Get_Msg_Id;\n+            goto Subprogram_Declaration;\n+         end if;\n+      end if;\n+\n+      --  Processing for subprogram body\n+\n+      <<Subprogram_Body>>\n+         if not Pf_Flags.Pbod then\n+            Error_Msg_SP (\"subprogram body not allowed here!\");\n+         end if;\n+\n+         --  Subprogram body stub case\n+\n+         if Separate_Present then\n+            if not Pf_Flags.Stub then\n+               Error_Msg_SC (\"body stub not allowed here!\");\n+            end if;\n+\n+            if Nkind (Name_Node) = N_Defining_Operator_Symbol then\n+               Error_Msg\n+                 (\"operator symbol cannot be used as subunit name\",\n+                  Sloc (Name_Node));\n+            end if;\n+\n+            Stub_Node :=\n+              New_Node (N_Subprogram_Body_Stub, Sloc (Specification_Node));\n+            Set_Specification (Stub_Node, Specification_Node);\n+            Scan; -- past SEPARATE\n+            Pop_Scope_Stack;\n+            TF_Semicolon;\n+            return Stub_Node;\n+\n+         --  Subprogram body case\n+\n+         else\n+            --  Here is the test for a suspicious IS (i.e. one that looks\n+            --  like it might more properly be a semicolon). See separate\n+            --  section discussing use of IS instead of semicolon in\n+            --  package Parse.\n+\n+            if (Token in Token_Class_Declk\n+                  or else\n+                Token = Tok_Identifier)\n+              and then Start_Column <= Scope.Table (Scope.Last).Ecol\n+              and then Scope.Last /= 1\n+            then\n+               Scope.Table (Scope.Last).Etyp := E_Suspicious_Is;\n+               Scope.Table (Scope.Last).S_Is := Prev_Token_Ptr;\n+            end if;\n+\n+            Body_Node :=\n+              New_Node (N_Subprogram_Body, Sloc (Specification_Node));\n+            Set_Specification (Body_Node, Specification_Node);\n+            Parse_Decls_Begin_End (Body_Node);\n+            return Body_Node;\n+         end if;\n+\n+      --  Processing for subprogram declaration\n+\n+      <<Subprogram_Declaration>>\n+         Decl_Node :=\n+           New_Node (N_Subprogram_Declaration, Sloc (Specification_Node));\n+         Set_Specification (Decl_Node, Specification_Node);\n+\n+         --  If this is a context in which a subprogram body is permitted,\n+         --  set active SIS entry in case (see section titled \"Handling\n+         --  Semicolon Used in Place of IS\" in body of Parser package)\n+         --  Note that SIS_Missing_Semicolon_Message is already set properly.\n+\n+         if Pf_Flags.Pbod then\n+            SIS_Labl := Scope.Table (Scope.Last).Labl;\n+            SIS_Sloc := Scope.Table (Scope.Last).Sloc;\n+            SIS_Ecol := Scope.Table (Scope.Last).Ecol;\n+            SIS_Declaration_Node := Decl_Node;\n+            SIS_Semicolon_Sloc := Prev_Token_Ptr;\n+            SIS_Entry_Active := True;\n+         end if;\n+\n+         Pop_Scope_Stack;\n+         return Decl_Node;\n+\n+   end P_Subprogram;\n+\n+   ---------------------------------\n+   -- 6.1  Subprogram Declaration --\n+   ---------------------------------\n+\n+   --  Parsed by P_Subprogram (6.1)\n+\n+   ------------------------------------------\n+   -- 6.1  Abstract Subprogram Declaration --\n+   ------------------------------------------\n+\n+   --  Parsed by P_Subprogram (6.1)\n+\n+   -----------------------------------\n+   -- 6.1  Subprogram Specification --\n+   -----------------------------------\n+\n+   --  SUBPROGRAM_SPECIFICATION ::=\n+   --      procedure DEFINING_PROGRAM_UNIT_NAME PARAMETER_PROFILE\n+   --    | function DEFINING_DESIGNATOR PARAMETER_AND_RESULT_PROFILE\n+\n+   --  PARAMETER_PROFILE ::= [FORMAL_PART]\n+\n+   --  PARAMETER_AND_RESULT_PROFILE ::= [FORMAL_PART] return SUBTYPE_MARK\n+\n+   --  Subprogram specifications that appear in subprogram declarations\n+   --  are parsed by P_Subprogram (6.1). This routine is used in other\n+   --  contexts where subprogram specifications occur.\n+\n+   --  Note: this routine does not affect the scope stack in any way\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Subprogram_Specification return Node_Id is\n+      Specification_Node : Node_Id;\n+\n+   begin\n+      if Token = Tok_Function then\n+         Specification_Node := New_Node (N_Function_Specification, Token_Ptr);\n+         Scan; -- past FUNCTION\n+         Ignore (Tok_Body);\n+         Set_Defining_Unit_Name (Specification_Node, P_Defining_Designator);\n+         Set_Parameter_Specifications\n+           (Specification_Node, P_Parameter_Profile);\n+         Check_Junk_Semicolon_Before_Return;\n+         TF_Return;\n+         Set_Subtype_Mark (Specification_Node, P_Subtype_Mark);\n+         No_Constraint;\n+         return Specification_Node;\n+\n+      elsif Token = Tok_Procedure then\n+         Specification_Node := New_Node (N_Procedure_Specification, Token_Ptr);\n+         Scan; -- past PROCEDURE\n+         Ignore (Tok_Body);\n+         Set_Defining_Unit_Name\n+           (Specification_Node, P_Defining_Program_Unit_Name);\n+         Set_Parameter_Specifications\n+           (Specification_Node, P_Parameter_Profile);\n+         return Specification_Node;\n+\n+      else\n+         Error_Msg_SC (\"subprogram specification expected\");\n+         raise Error_Resync;\n+      end if;\n+   end P_Subprogram_Specification;\n+\n+   ---------------------\n+   -- 6.1  Designator --\n+   ---------------------\n+\n+   --  DESIGNATOR ::=\n+   --    [PARENT_UNIT_NAME .] IDENTIFIER | OPERATOR_SYMBOL\n+\n+   --  The caller has checked that the initial token is an identifier,\n+   --  operator symbol, or string literal. Note that we don't bother to\n+   --  do much error diagnosis in this routine, since it is only used for\n+   --  the label on END lines, and the routines in package Par.Endh will\n+   --  check that the label is appropriate.\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Designator return Node_Id is\n+      Ident_Node  : Node_Id;\n+      Name_Node   : Node_Id;\n+      Prefix_Node : Node_Id;\n+\n+      function Real_Dot return Boolean;\n+      --  Tests if a current token is an interesting period, i.e. is followed\n+      --  by an identifier or operator symbol or string literal. If not, it is\n+      --  probably just incorrect punctuation to be caught by our caller. Note\n+      --  that the case of an operator symbol or string literal is also an\n+      --  error, but that is an error that we catch here. If the result is\n+      --  True, a real dot has been scanned and we are positioned past it,\n+      --  if the result is False, the scan position is unchanged.\n+\n+      function Real_Dot return Boolean is\n+         Scan_State  : Saved_Scan_State;\n+\n+      begin\n+         if Token /= Tok_Dot then\n+            return False;\n+\n+         else\n+            Save_Scan_State (Scan_State);\n+            Scan; -- past dot\n+\n+            if Token = Tok_Identifier\n+              or else Token = Tok_Operator_Symbol\n+              or else Token = Tok_String_Literal\n+            then\n+               return True;\n+\n+            else\n+               Restore_Scan_State (Scan_State);\n+               return False;\n+            end if;\n+         end if;\n+      end Real_Dot;\n+\n+   --  Start of processing for P_Designator\n+\n+   begin\n+      Ident_Node := Token_Node;\n+      Scan; -- past initial token\n+\n+      if Prev_Token = Tok_Operator_Symbol\n+        or else Prev_Token = Tok_String_Literal\n+        or else not Real_Dot\n+      then\n+         return Ident_Node;\n+\n+      --  Child name case\n+\n+      else\n+         Prefix_Node := Ident_Node;\n+\n+         --  Loop through child names, on entry to this loop, Prefix contains\n+         --  the name scanned so far, and Ident_Node is the last identifier.\n+\n+         loop\n+            Name_Node := New_Node (N_Selected_Component, Prev_Token_Ptr);\n+            Set_Prefix (Name_Node, Prefix_Node);\n+            Ident_Node := P_Identifier;\n+            Set_Selector_Name (Name_Node, Ident_Node);\n+            Prefix_Node := Name_Node;\n+            exit when not Real_Dot;\n+         end loop;\n+\n+         --  On exit from the loop, Ident_Node is the last identifier scanned,\n+         --  i.e. the defining identifier, and Prefix_Node is a node for the\n+         --  entire name, structured (incorrectly!) as a selected component.\n+\n+         Name_Node := Prefix (Prefix_Node);\n+         Change_Node (Prefix_Node, N_Designator);\n+         Set_Name (Prefix_Node, Name_Node);\n+         Set_Identifier (Prefix_Node, Ident_Node);\n+         return Prefix_Node;\n+      end if;\n+\n+   exception\n+      when Error_Resync =>\n+         while Token = Tok_Dot or else Token = Tok_Identifier loop\n+            Scan;\n+         end loop;\n+\n+         return Error;\n+   end P_Designator;\n+\n+   ------------------------------\n+   -- 6.1  Defining Designator --\n+   ------------------------------\n+\n+   --  DEFINING_DESIGNATOR ::=\n+   --    DEFINING_PROGRAM_UNIT_NAME | DEFINING_OPERATOR_SYMBOL\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Defining_Designator return Node_Id is\n+   begin\n+      if Token = Tok_Operator_Symbol then\n+         return P_Defining_Operator_Symbol;\n+\n+      elsif Token = Tok_String_Literal then\n+         Error_Msg_SC (\"invalid operator name\");\n+         Scan; -- past junk string\n+         return Error;\n+\n+      else\n+         return P_Defining_Program_Unit_Name;\n+      end if;\n+   end P_Defining_Designator;\n+\n+   -------------------------------------\n+   -- 6.1  Defining Program Unit Name --\n+   -------------------------------------\n+\n+   --  DEFINING_PROGRAM_UNIT_NAME ::=\n+   --    [PARENT_UNIT_NAME .] DEFINING_IDENTIFIER\n+\n+   --  Note: PARENT_UNIT_NAME may be present only in 95 mode at the outer level\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Defining_Program_Unit_Name return Node_Id is\n+      Ident_Node  : Node_Id;\n+      Name_Node   : Node_Id;\n+      Prefix_Node : Node_Id;\n+\n+   begin\n+      --  Set identifier casing if not already set and scan initial identifier\n+\n+      if Token = Tok_Identifier\n+        and then Identifier_Casing (Current_Source_File) = Unknown\n+      then\n+         Set_Identifier_Casing (Current_Source_File, Determine_Token_Casing);\n+      end if;\n+\n+      Ident_Node := P_Identifier;\n+      Merge_Identifier (Ident_Node, Tok_Return);\n+\n+      --  Normal case (not child library unit name)\n+\n+      if Token /= Tok_Dot then\n+         Change_Identifier_To_Defining_Identifier (Ident_Node);\n+         return Ident_Node;\n+\n+      --  Child library unit name case\n+\n+      else\n+         if Scope.Last > 1 then\n+            Error_Msg_SP (\"child unit allowed only at library level\");\n+            raise Error_Resync;\n+\n+         elsif Ada_83 then\n+            Error_Msg_SP (\"(Ada 83) child unit not allowed!\");\n+\n+         end if;\n+\n+         Prefix_Node := Ident_Node;\n+\n+         --  Loop through child names, on entry to this loop, Prefix contains\n+         --  the name scanned so far, and Ident_Node is the last identifier.\n+\n+         loop\n+            exit when Token /= Tok_Dot;\n+            Name_Node := New_Node (N_Selected_Component, Token_Ptr);\n+            Scan; -- past period\n+            Set_Prefix (Name_Node, Prefix_Node);\n+            Ident_Node := P_Identifier;\n+            Set_Selector_Name (Name_Node, Ident_Node);\n+            Prefix_Node := Name_Node;\n+         end loop;\n+\n+         --  On exit from the loop, Ident_Node is the last identifier scanned,\n+         --  i.e. the defining identifier, and Prefix_Node is a node for the\n+         --  entire name, structured (incorrectly!) as a selected component.\n+\n+         Name_Node := Prefix (Prefix_Node);\n+         Change_Node (Prefix_Node, N_Defining_Program_Unit_Name);\n+         Set_Name (Prefix_Node, Name_Node);\n+         Change_Identifier_To_Defining_Identifier (Ident_Node);\n+         Set_Defining_Identifier (Prefix_Node, Ident_Node);\n+\n+         --  All set with unit name parsed\n+\n+         return Prefix_Node;\n+      end if;\n+\n+   exception\n+      when Error_Resync =>\n+         while Token = Tok_Dot or else Token = Tok_Identifier loop\n+            Scan;\n+         end loop;\n+\n+         return Error;\n+   end P_Defining_Program_Unit_Name;\n+\n+   --------------------------\n+   -- 6.1  Operator Symbol --\n+   --------------------------\n+\n+   --  OPERATOR_SYMBOL ::= STRING_LITERAL\n+\n+   --  Operator symbol is returned by the scanner as Tok_Operator_Symbol\n+\n+   -----------------------------------\n+   -- 6.1  Defining Operator Symbol --\n+   -----------------------------------\n+\n+   --  DEFINING_OPERATOR_SYMBOL ::= OPERATOR_SYMBOL\n+\n+   --  The caller has checked that the initial symbol is an operator symbol\n+\n+   function P_Defining_Operator_Symbol return Node_Id is\n+      Op_Node : Node_Id;\n+\n+   begin\n+      Op_Node := Token_Node;\n+      Change_Operator_Symbol_To_Defining_Operator_Symbol (Op_Node);\n+      Scan; -- past operator symbol\n+      return Op_Node;\n+   end P_Defining_Operator_Symbol;\n+\n+   ----------------------------\n+   -- 6.1  Parameter_Profile --\n+   ----------------------------\n+\n+   --  PARAMETER_PROFILE ::= [FORMAL_PART]\n+\n+   --  Empty is returned if no formal part is present\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Parameter_Profile return List_Id is\n+   begin\n+      if Token = Tok_Left_Paren then\n+         Scan; -- part left paren\n+         return P_Formal_Part;\n+      else\n+         return No_List;\n+      end if;\n+   end P_Parameter_Profile;\n+\n+   ---------------------------------------\n+   -- 6.1  Parameter And Result Profile --\n+   ---------------------------------------\n+\n+   --  Parsed by its parent construct, which uses P_Parameter_Profile to\n+   --  parse the parameters, and P_Subtype_Mark to parse the return type.\n+\n+   ----------------------\n+   -- 6.1  Formal part --\n+   ----------------------\n+\n+   --  FORMAL_PART ::= (PARAMETER_SPECIFICATION {; PARAMETER_SPECIFICATION})\n+\n+   --  PARAMETER_SPECIFICATION ::=\n+   --    DEFINING_IDENTIFIER_LIST : MODE SUBTYPE_MARK\n+   --      [:= DEFAULT_EXPRESSION]\n+   --  | DEFINING_IDENTIFIER_LIST : ACCESS_DEFINITION\n+   --      [:= DEFAULT_EXPRESSION]\n+\n+   --  This scans the construct Formal_Part. The caller has already checked\n+   --  that the initial token is a left parenthesis, and skipped past it, so\n+   --  that on entry Token is the first token following the left parenthesis.\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Formal_Part return List_Id is\n+      Specification_List : List_Id;\n+      Specification_Node : Node_Id;\n+      Scan_State         : Saved_Scan_State;\n+      Num_Idents         : Nat;\n+      Ident              : Nat;\n+      Ident_Sloc         : Source_Ptr;\n+\n+      Idents : array (Int range 1 .. 4096) of Entity_Id;\n+      --  This array holds the list of defining identifiers. The upper bound\n+      --  of 4096 is intended to be essentially infinite, and we do not even\n+      --  bother to check for it being exceeded.\n+\n+   begin\n+      Specification_List := New_List;\n+\n+      Specification_Loop : loop\n+         begin\n+            if Token = Tok_Pragma then\n+               P_Pragmas_Misplaced;\n+            end if;\n+\n+            Ignore (Tok_Left_Paren);\n+            Ident_Sloc := Token_Ptr;\n+            Idents (1) := P_Defining_Identifier;\n+            Num_Idents := 1;\n+\n+            Ident_Loop : loop\n+               exit Ident_Loop when Token = Tok_Colon;\n+\n+               --  The only valid tokens are colon and comma, so if we have\n+               --  neither do a bit of investigation to see which is the\n+               --  better choice for insertion.\n+\n+               if Token /= Tok_Comma then\n+\n+                  --  Assume colon if IN or OUT keyword found\n+\n+                  exit Ident_Loop when Token = Tok_In or else Token = Tok_Out;\n+\n+                  --  Otherwise scan ahead\n+\n+                  Save_Scan_State (Scan_State);\n+                  Look_Ahead : loop\n+\n+                     --  If we run into a semicolon, then assume that a\n+                     --  colon was missing, e.g.  Parms (X Y; ...). Also\n+                     --  assume missing colon on EOF (a real disaster!)\n+                     --  and on a right paren, e.g. Parms (X Y), and also\n+                     --  on an assignment symbol, e.g. Parms (X Y := ..)\n+\n+                     if Token = Tok_Semicolon\n+                       or else Token = Tok_Right_Paren\n+                       or else Token = Tok_EOF\n+                       or else Token = Tok_Colon_Equal\n+                     then\n+                        Restore_Scan_State (Scan_State);\n+                        exit Ident_Loop;\n+\n+                     --  If we run into a colon, assume that we had a missing\n+                     --  comma, e.g. Parms (A B : ...). Also assume a missing\n+                     --  comma if we hit another comma, e.g. Parms (A B, C ..)\n+\n+                     elsif Token = Tok_Colon\n+                       or else Token = Tok_Comma\n+                     then\n+                        Restore_Scan_State (Scan_State);\n+                        exit Look_Ahead;\n+                     end if;\n+\n+                     Scan;\n+                  end loop Look_Ahead;\n+               end if;\n+\n+               --  Here if a comma is present, or to be assumed\n+\n+               T_Comma;\n+               Num_Idents := Num_Idents + 1;\n+               Idents (Num_Idents) := P_Defining_Identifier;\n+            end loop Ident_Loop;\n+\n+            --  Fall through the loop on encountering a colon, or deciding\n+            --  that there is a missing colon.\n+\n+            T_Colon;\n+\n+            --  If there are multiple identifiers, we repeatedly scan the\n+            --  type and initialization expression information by resetting\n+            --  the scan pointer (so that we get completely separate trees\n+            --  for each occurrence).\n+\n+            if Num_Idents > 1 then\n+               Save_Scan_State (Scan_State);\n+            end if;\n+\n+            --  Loop through defining identifiers in list\n+\n+            Ident := 1;\n+\n+            Ident_List_Loop : loop\n+               Specification_Node :=\n+                 New_Node (N_Parameter_Specification, Ident_Sloc);\n+               Set_Defining_Identifier (Specification_Node, Idents (Ident));\n+\n+               if Token = Tok_Access then\n+                  if Ada_83 then\n+                     Error_Msg_SC (\"(Ada 83) access parameters not allowed\");\n+                  end if;\n+\n+                  Set_Parameter_Type\n+                    (Specification_Node, P_Access_Definition);\n+\n+               else\n+                  P_Mode (Specification_Node);\n+\n+                  if Token = Tok_Procedure\n+                       or else\n+                     Token = Tok_Function\n+                  then\n+                     Error_Msg_SC (\"formal subprogram parameter not allowed\");\n+                     Scan;\n+\n+                     if Token = Tok_Left_Paren then\n+                        Discard_Junk_List (P_Formal_Part);\n+                     end if;\n+\n+                     if Token = Tok_Return then\n+                        Scan;\n+                        Discard_Junk_Node (P_Subtype_Mark);\n+                     end if;\n+\n+                     Set_Parameter_Type (Specification_Node, Error);\n+\n+                  else\n+                     Set_Parameter_Type (Specification_Node, P_Subtype_Mark);\n+                     No_Constraint;\n+                  end if;\n+               end if;\n+\n+               Set_Expression (Specification_Node, Init_Expr_Opt (True));\n+\n+               if Ident > 1 then\n+                  Set_Prev_Ids (Specification_Node, True);\n+               end if;\n+\n+               if Ident < Num_Idents then\n+                  Set_More_Ids (Specification_Node, True);\n+               end if;\n+\n+               Append (Specification_Node, Specification_List);\n+               exit Ident_List_Loop when Ident = Num_Idents;\n+               Ident := Ident + 1;\n+               Restore_Scan_State (Scan_State);\n+            end loop Ident_List_Loop;\n+\n+         exception\n+            when Error_Resync =>\n+               Resync_Semicolon_List;\n+         end;\n+\n+         if Token = Tok_Semicolon then\n+            Scan; -- past semicolon\n+\n+            --  If we have RETURN or IS after the semicolon, then assume\n+            --  that semicolon should have been a right parenthesis and exit\n+\n+            if Token = Tok_Is or else Token = Tok_Return then\n+               Error_Msg_SP (\"expected \"\")\"\" in place of \"\";\"\"\");\n+               exit Specification_Loop;\n+            end if;\n+\n+         elsif Token = Tok_Right_Paren then\n+            Scan; -- past right paren\n+            exit Specification_Loop;\n+\n+         --  Special check for common error of using comma instead of semicolon\n+\n+         elsif Token = Tok_Comma then\n+            T_Semicolon;\n+            Scan; -- past comma\n+\n+         --  Special check for omitted separator\n+\n+         elsif Token = Tok_Identifier then\n+            T_Semicolon;\n+\n+         --  If nothing sensible, skip to next semicolon or right paren\n+\n+         else\n+            T_Semicolon;\n+            Resync_Semicolon_List;\n+\n+            if Token = Tok_Semicolon then\n+               Scan; -- past semicolon\n+            else\n+               T_Right_Paren;\n+               exit Specification_Loop;\n+            end if;\n+         end if;\n+      end loop Specification_Loop;\n+\n+      return Specification_List;\n+   end P_Formal_Part;\n+\n+   ----------------------------------\n+   -- 6.1  Parameter Specification --\n+   ----------------------------------\n+\n+   --  Parsed by P_Formal_Part (6.1)\n+\n+   ---------------\n+   -- 6.1  Mode --\n+   ---------------\n+\n+   --  MODE ::= [in] | in out | out\n+\n+   --  There is no explicit node in the tree for the Mode. Instead the\n+   --  In_Present and Out_Present flags are set in the parent node to\n+   --  record the presence of keywords specifying the mode.\n+\n+   --  Error_Recovery: cannot raise Error_Resync\n+\n+   procedure P_Mode (Node : Node_Id) is\n+   begin\n+      if Token = Tok_In then\n+         Scan; -- past IN\n+         Set_In_Present (Node, True);\n+      end if;\n+\n+      if Token = Tok_Out then\n+         Scan; -- past OUT\n+         Set_Out_Present (Node, True);\n+      end if;\n+\n+      if Token = Tok_In then\n+         Error_Msg_SC (\"IN must preceed OUT in parameter mode\");\n+         Scan; -- past IN\n+         Set_In_Present (Node, True);\n+      end if;\n+   end P_Mode;\n+\n+   --------------------------\n+   -- 6.3  Subprogram Body --\n+   --------------------------\n+\n+   --  Parsed by P_Subprogram (6.1)\n+\n+   -----------------------------------\n+   -- 6.4  Procedure Call Statement --\n+   -----------------------------------\n+\n+   --  Parsed by P_Sequence_Of_Statements (5.1)\n+\n+   ------------------------\n+   -- 6.4  Function Call --\n+   ------------------------\n+\n+   --  Parsed by P_Call_Or_Name (4.1)\n+\n+   --------------------------------\n+   -- 6.4  Actual Parameter Part --\n+   --------------------------------\n+\n+   --  Parsed by P_Call_Or_Name (4.1)\n+\n+   --------------------------------\n+   -- 6.4  Parameter Association --\n+   --------------------------------\n+\n+   --  Parsed by P_Call_Or_Name (4.1)\n+\n+   ------------------------------------\n+   -- 6.4  Explicit Actual Parameter --\n+   ------------------------------------\n+\n+   --  Parsed by P_Call_Or_Name (4.1)\n+\n+   ---------------------------\n+   -- 6.5  Return Statement --\n+   ---------------------------\n+\n+   --  RETURN_STATEMENT ::= return [EXPRESSION];\n+\n+   --  The caller has checked that the initial token is RETURN\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Return_Statement return Node_Id is\n+      Return_Node : Node_Id;\n+\n+   begin\n+      Return_Node := New_Node (N_Return_Statement, Token_Ptr);\n+\n+      --  Sloc points to RETURN\n+      --  Expression (Op3)\n+\n+      Scan; -- past RETURN\n+\n+      if Token /= Tok_Semicolon then\n+\n+         --  If no semicolon, then scan an expression, except that\n+         --  we avoid trying to scan an expression if we are at an\n+         --  expression terminator since in that case the best error\n+         --  message is probably that we have a missing semicolon.\n+\n+         if Token not in Token_Class_Eterm then\n+            Set_Expression (Return_Node, P_Expression_No_Right_Paren);\n+         end if;\n+      end if;\n+\n+      TF_Semicolon;\n+      return Return_Node;\n+   end P_Return_Statement;\n+\n+end Ch6;"}, {"sha": "de632133f4bf563b04b1621068512f3c901d3108", "filename": "gcc/ada/par-ch7.adb", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch7.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,282 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P A R . C H 7                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.29 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Style_Checks (All_Checks);\n+--  Turn off subprogram body ordering check. Subprograms are in order\n+--  by RM section rather than alphabetical\n+\n+separate (Par)\n+package body Ch7 is\n+\n+   ---------------------------------------------\n+   -- 7.1  Package (also 8.5.3, 10.1.3, 12.3) --\n+   ---------------------------------------------\n+\n+   --  This routine scans out a package declaration, package body, or a\n+   --  renaming declaration or generic instantiation starting with PACKAGE\n+\n+   --  PACKAGE_DECLARATION ::= PACKAGE_SPECIFICATION;\n+\n+   --  PACKAGE_SPECIFICATION ::=\n+   --    package DEFINING_PROGRAM_UNIT_NAME is\n+   --      {BASIC_DECLARATIVE_ITEM}\n+   --    [private\n+   --      {BASIC_DECLARATIVE_ITEM}]\n+   --    end [[PARENT_UNIT_NAME .] IDENTIFIER]\n+\n+   --  PACKAGE_BODY ::=\n+   --    package body DEFINING_PROGRAM_UNIT_NAME is\n+   --      DECLARATIVE_PART\n+   --    [begin\n+   --      HANDLED_SEQUENCE_OF_STATEMENTS]\n+   --    end [[PARENT_UNIT_NAME .] IDENTIFIER]\n+\n+   --  PACKAGE_RENAMING_DECLARATION ::=\n+   --    package DEFINING_IDENTIFIER renames package_NAME;\n+\n+   --  PACKAGE_BODY_STUB ::=\n+   --    package body DEFINING_IDENTIFIER is separate;\n+\n+   --  The value in Pf_Flags indicates which of these possible declarations\n+   --  is acceptable to the caller:\n+\n+   --    Pf_Flags.Spcn                 Set if specification OK\n+   --    Pf_Flags.Decl                 Set if declaration OK\n+   --    Pf_Flags.Gins                 Set if generic instantiation OK\n+   --    Pf_Flags.Pbod                 Set if proper body OK\n+   --    Pf_Flags.Rnam                 Set if renaming declaration OK\n+   --    Pf_Flags.Stub                 Set if body stub OK\n+\n+   --  If an inappropriate form is encountered, it is scanned out but an\n+   --  error message indicating that it is appearing in an inappropriate\n+   --  context is issued. The only possible settings for Pf_Flags are those\n+   --  defined as constants in package Par.\n+\n+   --  Note: in all contexts where a package specification is required, there\n+   --  is a terminating semicolon. This semicolon is scanned out in the case\n+   --  where Pf_Flags is set to Pf_Spcn, even though it is not strictly part\n+   --  of the package specification (it's just too much trouble, and really\n+   --  quite unnecessary, to deal with scanning out an END where the semicolon\n+   --  after the END is not considered to be part of the END.\n+\n+   --  The caller has checked that the initial token is PACKAGE\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Package (Pf_Flags : Pf_Rec) return Node_Id is\n+      Package_Node       : Node_Id;\n+      Specification_Node : Node_Id;\n+      Name_Node          : Node_Id;\n+      Package_Sloc       : Source_Ptr;\n+\n+   begin\n+      Push_Scope_Stack;\n+      Scope.Table (Scope.Last).Etyp := E_Name;\n+      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scope.Table (Scope.Last).Lreq := False;\n+\n+      Package_Sloc := Token_Ptr;\n+      Scan; -- past PACKAGE\n+\n+      if Token = Tok_Type then\n+         Error_Msg_SC (\"TYPE not allowed here\");\n+         Scan; -- past TYPE\n+      end if;\n+\n+      --  Case of package body. Note that we demand a package body if that\n+      --  is the only possibility (even if the BODY keyword is not present)\n+\n+      if Token = Tok_Body or else Pf_Flags = Pf_Pbod then\n+         if not Pf_Flags.Pbod then\n+            Error_Msg_SC (\"package body cannot appear here!\");\n+         end if;\n+\n+         T_Body;\n+         Name_Node := P_Defining_Program_Unit_Name;\n+         Scope.Table (Scope.Last).Labl := Name_Node;\n+         TF_Is;\n+\n+         if Separate_Present then\n+            if not Pf_Flags.Stub then\n+               Error_Msg_SC (\"body stub cannot appear here!\");\n+            end if;\n+\n+            Scan; -- past SEPARATE\n+            TF_Semicolon;\n+            Pop_Scope_Stack;\n+\n+            Package_Node := New_Node (N_Package_Body_Stub, Package_Sloc);\n+            Set_Defining_Identifier (Package_Node, Name_Node);\n+\n+         else\n+            Package_Node := New_Node (N_Package_Body, Package_Sloc);\n+            Set_Defining_Unit_Name (Package_Node, Name_Node);\n+            Parse_Decls_Begin_End (Package_Node);\n+         end if;\n+\n+         return Package_Node;\n+\n+      --  Cases other than Package_Body\n+\n+      else\n+         Name_Node := P_Defining_Program_Unit_Name;\n+         Scope.Table (Scope.Last).Labl := Name_Node;\n+\n+         --  Case of renaming declaration\n+\n+         Check_Misspelling_Of (Tok_Renames);\n+\n+         if Token = Tok_Renames then\n+            if not Pf_Flags.Rnam then\n+               Error_Msg_SC (\"renaming declaration cannot appear here!\");\n+            end if;\n+\n+            Scan; -- past RENAMES;\n+\n+            Package_Node :=\n+              New_Node (N_Package_Renaming_Declaration, Package_Sloc);\n+            Set_Defining_Unit_Name (Package_Node, Name_Node);\n+            Set_Name (Package_Node, P_Qualified_Simple_Name);\n+\n+            No_Constraint;\n+            TF_Semicolon;\n+            Pop_Scope_Stack;\n+            return Package_Node;\n+\n+         else\n+            TF_Is;\n+\n+            --  Case of generic instantiation\n+\n+            if Token = Tok_New then\n+               if not Pf_Flags.Gins then\n+                  Error_Msg_SC\n+                     (\"generic instantiation cannot appear here!\");\n+               end if;\n+\n+               Scan; -- past NEW\n+\n+               Package_Node :=\n+                  New_Node (N_Package_Instantiation, Package_Sloc);\n+               Set_Defining_Unit_Name (Package_Node, Name_Node);\n+               Set_Name (Package_Node, P_Qualified_Simple_Name);\n+               Set_Generic_Associations\n+                 (Package_Node, P_Generic_Actual_Part_Opt);\n+               TF_Semicolon;\n+               Pop_Scope_Stack;\n+\n+            --  Case of package declaration or package specification\n+\n+            else\n+               Specification_Node :=\n+                 New_Node (N_Package_Specification, Package_Sloc);\n+\n+               Set_Defining_Unit_Name (Specification_Node, Name_Node);\n+               Set_Visible_Declarations\n+                 (Specification_Node, P_Basic_Declarative_Items);\n+\n+               if Token = Tok_Private then\n+                  Error_Msg_Col := Scope.Table (Scope.Last).Ecol;\n+\n+                  if Style.RM_Column_Check then\n+                     if Token_Is_At_Start_Of_Line\n+                       and then Start_Column /= Error_Msg_Col\n+                     then\n+                        Error_Msg_SC\n+                          (\"(style) PRIVATE in wrong column, should be@\");\n+                     end if;\n+                  end if;\n+\n+                  Scan; -- past PRIVATE\n+                  Set_Private_Declarations\n+                    (Specification_Node, P_Basic_Declarative_Items);\n+\n+                  --  Deal gracefully with multiple PRIVATE parts\n+\n+                  while Token = Tok_Private loop\n+                     Error_Msg_SC\n+                       (\"only one private part allowed per package\");\n+                     Scan; -- past PRIVATE\n+                     Append_List (P_Basic_Declarative_Items,\n+                       Private_Declarations (Specification_Node));\n+                  end loop;\n+               end if;\n+\n+               if Pf_Flags = Pf_Spcn then\n+                  Package_Node := Specification_Node;\n+               else\n+                  Package_Node :=\n+                    New_Node (N_Package_Declaration, Package_Sloc);\n+                  Set_Specification (Package_Node, Specification_Node);\n+               end if;\n+\n+               if Token = Tok_Begin then\n+                  Error_Msg_SC (\"begin block not allowed in package spec\");\n+                  Scan; -- past BEGIN\n+                  Discard_Junk_List (P_Sequence_Of_Statements (SS_None));\n+               end if;\n+\n+               End_Statements (Specification_Node);\n+            end if;\n+\n+            return Package_Node;\n+         end if;\n+      end if;\n+   end P_Package;\n+\n+   ------------------------------\n+   -- 7.1  Package Declaration --\n+   ------------------------------\n+\n+   --  Parsed by P_Package (7.1)\n+\n+   --------------------------------\n+   -- 7.1  Package Specification --\n+   --------------------------------\n+\n+   --  Parsed by P_Package (7.1)\n+\n+   -----------------------\n+   -- 7.1  Package Body --\n+   -----------------------\n+\n+   --  Parsed by P_Package (7.1)\n+\n+   -----------------------------------\n+   -- 7.3  Private Type Declaration --\n+   -----------------------------------\n+\n+   --  Parsed by P_Type_Declaration (3.2.1)\n+\n+   ----------------------------------------\n+   -- 7.3  Private Extension Declaration --\n+   ----------------------------------------\n+\n+   --  Parsed by P_Type_Declaration (3.2.1)\n+\n+end Ch7;"}, {"sha": "9d1b386280db07164422ab4ce04943b8e7a47d13", "filename": "gcc/ada/par-ch8.adb", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch8.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,175 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P A R . C H 8                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.16 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Style_Checks (All_Checks);\n+--  Turn off subprogram body ordering check. Subprograms are in order\n+--  by RM section rather than alphabetical\n+\n+separate (Par)\n+package body Ch8 is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function P_Use_Package_Clause                           return Node_Id;\n+   function P_Use_Type_Clause                              return Node_Id;\n+\n+   ---------------------\n+   -- 8.4  Use Clause --\n+   ---------------------\n+\n+   --  USE_CLAUSE ::= USE_PACKAGE_CLAUSE | USE_TYPE_CLAUSE\n+\n+   --  The caller has checked that the initial token is USE\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Use_Clause return Node_Id is\n+   begin\n+      Scan; -- past USE\n+\n+      if Token = Tok_Type then\n+         return P_Use_Type_Clause;\n+\n+      else\n+         return P_Use_Package_Clause;\n+      end if;\n+   end P_Use_Clause;\n+\n+   -----------------------------\n+   -- 8.4  Use Package Clause --\n+   -----------------------------\n+\n+   --  USE_PACKAGE_CLAUSE ::= use package_NAME {, package_NAME};\n+\n+   --  The caller has scanned out the USE keyword\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Use_Package_Clause return Node_Id is\n+      Use_Node : Node_Id;\n+\n+   begin\n+      Use_Node := New_Node (N_Use_Package_Clause, Prev_Token_Ptr);\n+      Set_Names (Use_Node, New_List);\n+\n+      if Token = Tok_Package then\n+         Error_Msg_SC (\"PACKAGE should not appear here\");\n+         Scan; -- past PACKAGE\n+      end if;\n+\n+      loop\n+         Append (P_Qualified_Simple_Name, Names (Use_Node));\n+         exit when Token /= Tok_Comma;\n+         Scan; -- past comma\n+      end loop;\n+\n+      TF_Semicolon;\n+      return Use_Node;\n+   end P_Use_Package_Clause;\n+\n+   --------------------------\n+   -- 8.4  Use Type Clause --\n+   --------------------------\n+\n+   --  USE_TYPE_CLAUSE ::= use type SUBTYPE_MARK {, SUBTYPE_MARK};\n+\n+   --  The caller has checked that the initial token is USE, scanned it out\n+   --  and that the current token is TYPE.\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Use_Type_Clause return Node_Id is\n+      Use_Node : Node_Id;\n+\n+   begin\n+      Use_Node := New_Node (N_Use_Type_Clause, Prev_Token_Ptr);\n+      Set_Subtype_Marks (Use_Node, New_List);\n+\n+      if Ada_83 then\n+         Error_Msg_SC (\"(Ada 83) use type not allowed!\");\n+      end if;\n+\n+      Scan; -- past TYPE\n+\n+      loop\n+         Append (P_Subtype_Mark, Subtype_Marks (Use_Node));\n+         No_Constraint;\n+         exit when Token /= Tok_Comma;\n+         Scan; -- past comma\n+      end loop;\n+\n+      TF_Semicolon;\n+      return Use_Node;\n+   end P_Use_Type_Clause;\n+\n+   -------------------------------\n+   -- 8.5  Renaming Declaration --\n+   -------------------------------\n+\n+   --  Object renaming declarations and exception renaming declarations\n+   --  are parsed by P_Identifier_Declaration (3.3.1)\n+\n+   --  Subprogram renaming declarations are parsed by P_Subprogram (6.1)\n+\n+   --  Package renaming declarations are parsed by P_Package (7.1)\n+\n+   --  Generic renaming declarations are parsed by P_Generic (12.1)\n+\n+   ----------------------------------------\n+   -- 8.5.1  Object Renaming Declaration --\n+   ----------------------------------------\n+\n+   --  Parsed by P_Identifier_Declarations (3.3.1)\n+\n+   ----------------------------------------\n+   -- 8.5.2  Exception Renaming Declaration --\n+   ----------------------------------------\n+\n+   --  Parsed by P_Identifier_Declarations (3.3.1)\n+\n+   -----------------------------------------\n+   -- 8.5.3  Package Renaming Declaration --\n+   -----------------------------------------\n+\n+   --  Parsed by P_Package (7.1)\n+\n+   --------------------------------------------\n+   -- 8.5.4  Subprogram Renaming Declaration --\n+   --------------------------------------------\n+\n+   --  Parsed by P_Subprogram (6.1)\n+\n+   -----------------------------------------\n+   -- 8.5.2  Generic Renaming Declaration --\n+   -----------------------------------------\n+\n+   --  Parsed by P_Generic (12.1)\n+\n+end Ch8;"}, {"sha": "87d6be6ae5f0b7f0aace19798a860bdcd8e12fe3", "filename": "gcc/ada/par-ch9.adb", "status": "added", "additions": 1616, "deletions": 0, "changes": 1616, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch9.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,1616 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P A R . C H 9                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.82 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Style_Checks (All_Checks);\n+--  Turn off subprogram body ordering check. Subprograms are in order\n+--  by RM section rather than alphabetical\n+\n+separate (Par)\n+package body Ch9 is\n+\n+   --  Local subprograms, used only in this chapter\n+\n+   function P_Accept_Alternative                   return Node_Id;\n+   function P_Delay_Alternative                    return Node_Id;\n+   function P_Delay_Relative_Statement             return Node_Id;\n+   function P_Delay_Until_Statement                return Node_Id;\n+   function P_Entry_Barrier                        return Node_Id;\n+   function P_Entry_Body_Formal_Part               return Node_Id;\n+   function P_Entry_Declaration                    return Node_Id;\n+   function P_Entry_Index_Specification            return Node_Id;\n+   function P_Protected_Definition                 return Node_Id;\n+   function P_Protected_Operation_Declaration_Opt  return Node_Id;\n+   function P_Protected_Operation_Items            return List_Id;\n+   function P_Task_Definition                      return Node_Id;\n+   function P_Task_Items                           return List_Id;\n+\n+   -----------------------------\n+   -- 9.1  Task (also 10.1.3) --\n+   -----------------------------\n+\n+   --  TASK_TYPE_DECLARATION ::=\n+   --    task type DEFINING_IDENTIFIER [KNOWN_DISCRIMINANT_PART]\n+   --      [is TASK_DEFINITION];\n+\n+   --  SINGLE_TASK_DECLARATION ::=\n+   --    task DEFINING_IDENTIFIER [is TASK_DEFINITION];\n+\n+   --  TASK_BODY ::=\n+   --    task body DEFINING_IDENTIFIER is\n+   --      DECLARATIVE_PART\n+   --    begin\n+   --      HANDLED_SEQUENCE_OF_STATEMENTS\n+   --    end [task_IDENTIFIER]\n+\n+   --  TASK_BODY_STUB ::=\n+   --    task body DEFINING_IDENTIFIER is separate;\n+\n+   --  This routine scans out a task declaration, task body, or task stub\n+\n+   --  The caller has checked that the initial token is TASK and scanned\n+   --  past it, so that Token is set to the token after TASK\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Task return Node_Id is\n+      Name_Node  : Node_Id;\n+      Task_Node  : Node_Id;\n+      Task_Sloc  : Source_Ptr;\n+\n+   begin\n+      Push_Scope_Stack;\n+      Scope.Table (Scope.Last).Etyp := E_Name;\n+      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+      Scope.Table (Scope.Last).Lreq := False;\n+      Task_Sloc := Prev_Token_Ptr;\n+\n+      if Token = Tok_Body then\n+         Scan; -- past BODY\n+         Name_Node := P_Defining_Identifier;\n+         Scope.Table (Scope.Last).Labl := Name_Node;\n+\n+         if Token = Tok_Left_Paren then\n+            Error_Msg_SC (\"discriminant part not allowed in task body\");\n+            Discard_Junk_List (P_Known_Discriminant_Part_Opt);\n+         end if;\n+\n+         TF_Is;\n+\n+         --  Task stub\n+\n+         if Token = Tok_Separate then\n+            Scan; -- past SEPARATE\n+            Task_Node := New_Node (N_Task_Body_Stub, Task_Sloc);\n+            Set_Defining_Identifier (Task_Node, Name_Node);\n+            TF_Semicolon;\n+            Pop_Scope_Stack; -- remove unused entry\n+\n+         --  Task body\n+\n+         else\n+            Task_Node := New_Node (N_Task_Body, Task_Sloc);\n+            Set_Defining_Identifier (Task_Node, Name_Node);\n+            Parse_Decls_Begin_End (Task_Node);\n+         end if;\n+\n+         return Task_Node;\n+\n+      --  Otherwise we must have a task declaration\n+\n+      else\n+         if Token = Tok_Type then\n+            Scan; -- past TYPE\n+            Task_Node := New_Node (N_Task_Type_Declaration, Task_Sloc);\n+            Name_Node := P_Defining_Identifier;\n+            Set_Defining_Identifier (Task_Node, Name_Node);\n+            Scope.Table (Scope.Last).Labl := Name_Node;\n+            Set_Discriminant_Specifications\n+              (Task_Node, P_Known_Discriminant_Part_Opt);\n+\n+         else\n+            Task_Node := New_Node (N_Single_Task_Declaration, Task_Sloc);\n+            Name_Node := P_Defining_Identifier;\n+            Set_Defining_Identifier (Task_Node, Name_Node);\n+            Scope.Table (Scope.Last).Labl := Name_Node;\n+\n+            if Token = Tok_Left_Paren then\n+               Error_Msg_SC (\"discriminant part not allowed for single task\");\n+               Discard_Junk_List (P_Known_Discriminant_Part_Opt);\n+            end if;\n+\n+         end if;\n+\n+         --  Parse optional task definition. Note that P_Task_Definition scans\n+         --  out the semicolon as well as the task definition itself.\n+\n+         if Token = Tok_Semicolon then\n+\n+            --  A little check, if the next token after semicolon is\n+            --  Entry, then surely the semicolon should really be IS\n+\n+            Scan; -- past semicolon\n+\n+            if Token = Tok_Entry then\n+               Error_Msg_SP (\"\"\";\"\" should be IS\");\n+               Set_Task_Definition (Task_Node, P_Task_Definition);\n+            else\n+               Pop_Scope_Stack; -- Remove unused entry\n+            end if;\n+         else\n+            TF_Is; -- must have IS if no semicolon\n+            Set_Task_Definition (Task_Node, P_Task_Definition);\n+         end if;\n+\n+         return Task_Node;\n+      end if;\n+   end P_Task;\n+\n+   --------------------------------\n+   -- 9.1  Task Type Declaration --\n+   --------------------------------\n+\n+   --  Parsed by P_Task (9.1)\n+\n+   ----------------------------------\n+   -- 9.1  Single Task Declaration --\n+   ----------------------------------\n+\n+   --  Parsed by P_Task (9.1)\n+\n+   --------------------------\n+   -- 9.1  Task Definition --\n+   --------------------------\n+\n+   --  TASK_DEFINITION ::=\n+   --      {TASK_ITEM}\n+   --    [private\n+   --      {TASK_ITEM}]\n+   --    end [task_IDENTIFIER];\n+\n+   --  The caller has already made the scope stack entry\n+\n+   --  Note: there is a small deviation from official syntax here in that we\n+   --  regard the semicolon after end as part of the Task_Definition, and in\n+   --  the official syntax, it's part of the enclosing declaration. The reason\n+   --  for this deviation is that otherwise the end processing would have to\n+   --  be special cased, which would be a nuisance!\n+\n+   --  Error recovery:  cannot raise Error_Resync\n+\n+   function P_Task_Definition return Node_Id is\n+      Def_Node  : Node_Id;\n+\n+   begin\n+      Def_Node := New_Node (N_Task_Definition, Token_Ptr);\n+      Set_Visible_Declarations (Def_Node, P_Task_Items);\n+\n+      if Token = Tok_Private then\n+         Scan; -- past PRIVATE\n+         Set_Private_Declarations (Def_Node, P_Task_Items);\n+\n+         --  Deal gracefully with multiple PRIVATE parts\n+\n+         while Token = Tok_Private loop\n+            Error_Msg_SC (\"Only one private part allowed per task\");\n+            Scan; -- past PRIVATE\n+            Append_List (P_Task_Items, Private_Declarations (Def_Node));\n+         end loop;\n+      end if;\n+\n+      End_Statements (Def_Node);\n+      return Def_Node;\n+   end P_Task_Definition;\n+\n+   --------------------\n+   -- 9.1  Task Item --\n+   --------------------\n+\n+   --  TASK_ITEM ::= ENTRY_DECLARATION | REPRESENTATION_CLAUSE\n+\n+   --  This subprogram scans a (possibly empty) list of task items and pragmas\n+\n+   --  Error recovery:  cannot raise Error_Resync\n+\n+   --  Note: a pragma can also be returned in this position\n+\n+   function P_Task_Items return List_Id is\n+      Items      : List_Id;\n+      Item_Node  : Node_Id;\n+      Decl_Sloc  : Source_Ptr;\n+\n+   begin\n+      --  Get rid of active SIS entry from outer scope. This means we will\n+      --  miss some nested cases, but it doesn't seem worth the effort. See\n+      --  discussion in Par for further details\n+\n+      SIS_Entry_Active := False;\n+\n+      --  Loop to scan out task items\n+\n+      Items := New_List;\n+\n+      Decl_Loop : loop\n+         Decl_Sloc := Token_Ptr;\n+\n+         if Token = Tok_Pragma then\n+            Append (P_Pragma, Items);\n+\n+         elsif Token = Tok_Entry then\n+            Append (P_Entry_Declaration, Items);\n+\n+         elsif Token = Tok_For then\n+            --  Representation clause in task declaration. The only rep\n+            --  clause which is legal in a protected is an address clause,\n+            --  so that is what we try to scan out.\n+\n+            Item_Node := P_Representation_Clause;\n+\n+            if Nkind (Item_Node) = N_At_Clause then\n+               Append (Item_Node, Items);\n+\n+            elsif Nkind (Item_Node) = N_Attribute_Definition_Clause\n+              and then Chars (Item_Node) = Name_Address\n+            then\n+               Append (Item_Node, Items);\n+\n+            else\n+               Error_Msg\n+                 (\"the only representation clause \" &\n+                  \"allowed here is an address clause!\", Decl_Sloc);\n+            end if;\n+\n+         elsif Token = Tok_Identifier\n+           or else Token in Token_Class_Declk\n+         then\n+            Error_Msg_SC (\"Illegal declaration in task definition\");\n+            Resync_Past_Semicolon;\n+\n+         else\n+            exit Decl_Loop;\n+         end if;\n+      end loop Decl_Loop;\n+\n+      return Items;\n+   end P_Task_Items;\n+\n+   --------------------\n+   -- 9.1  Task Body --\n+   --------------------\n+\n+   --  Parsed by P_Task (9.1)\n+\n+   ----------------------------------\n+   -- 9.4  Protected (also 10.1.3) --\n+   ----------------------------------\n+\n+   --  PROTECTED_TYPE_DECLARATION ::=\n+   --    protected type DEFINING_IDENTIFIER [KNOWN_DISCRIMINANT_PART]\n+   --      is PROTECTED_DEFINITION;\n+\n+   --  SINGLE_PROTECTED_DECLARATION ::=\n+   --    protected DEFINING_IDENTIFIER is PROTECTED_DEFINITION;\n+\n+   --  PROTECTED_BODY ::=\n+   --    protected body DEFINING_IDENTIFIER is\n+   --      {PROTECTED_OPERATION_ITEM}\n+   --    end [protected_IDENTIFIER];\n+\n+   --  PROTECTED_BODY_STUB ::=\n+   --    protected body DEFINING_IDENTIFIER is separate;\n+\n+   --  This routine scans out a protected declaration, protected body\n+   --  or a protected stub.\n+\n+   --  The caller has checked that the initial token is PROTECTED and\n+   --  scanned past it, so Token is set to the following token.\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Protected return Node_Id is\n+      Name_Node      : Node_Id;\n+      Protected_Node : Node_Id;\n+      Protected_Sloc : Source_Ptr;\n+\n+   begin\n+      Push_Scope_Stack;\n+      Scope.Table (Scope.Last).Etyp := E_Name;\n+      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scope.Table (Scope.Last).Lreq := False;\n+      Protected_Sloc := Prev_Token_Ptr;\n+\n+      if Token = Tok_Body then\n+         Scan; -- past BODY\n+         Name_Node := P_Defining_Identifier;\n+         Scope.Table (Scope.Last).Labl := Name_Node;\n+\n+         if Token = Tok_Left_Paren then\n+            Error_Msg_SC (\"discriminant part not allowed in protected body\");\n+            Discard_Junk_List (P_Known_Discriminant_Part_Opt);\n+         end if;\n+\n+         TF_Is;\n+\n+         --  Protected stub\n+\n+         if Token = Tok_Separate then\n+            Scan; -- past SEPARATE\n+            Protected_Node := New_Node (N_Protected_Body_Stub, Protected_Sloc);\n+            Set_Defining_Identifier (Protected_Node, Name_Node);\n+            TF_Semicolon;\n+            Pop_Scope_Stack; -- remove unused entry\n+\n+         --  Protected body\n+\n+         else\n+            Protected_Node := New_Node (N_Protected_Body, Protected_Sloc);\n+            Set_Defining_Identifier (Protected_Node, Name_Node);\n+            Set_Declarations (Protected_Node, P_Protected_Operation_Items);\n+            End_Statements (Protected_Node);\n+         end if;\n+\n+         return Protected_Node;\n+\n+      --  Otherwise we must have a protected declaration\n+\n+      else\n+         if Token = Tok_Type then\n+            Scan; -- past TYPE\n+            Protected_Node :=\n+              New_Node (N_Protected_Type_Declaration, Protected_Sloc);\n+            Name_Node := P_Defining_Identifier;\n+            Set_Defining_Identifier (Protected_Node, Name_Node);\n+            Scope.Table (Scope.Last).Labl := Name_Node;\n+            Set_Discriminant_Specifications\n+              (Protected_Node, P_Known_Discriminant_Part_Opt);\n+\n+         else\n+            Protected_Node :=\n+              New_Node (N_Single_Protected_Declaration, Protected_Sloc);\n+            Name_Node := P_Defining_Identifier;\n+            Set_Defining_Identifier (Protected_Node, Name_Node);\n+\n+            if Token = Tok_Left_Paren then\n+               Error_Msg_SC\n+                 (\"discriminant part not allowed for single protected\");\n+               Discard_Junk_List (P_Known_Discriminant_Part_Opt);\n+            end if;\n+\n+            Scope.Table (Scope.Last).Labl := Name_Node;\n+         end if;\n+\n+         T_Is;\n+         Set_Protected_Definition (Protected_Node, P_Protected_Definition);\n+         return Protected_Node;\n+      end if;\n+   end P_Protected;\n+\n+   -------------------------------------\n+   -- 9.4  Protected Type Declaration --\n+   -------------------------------------\n+\n+   --  Parsed by P_Protected (9.4)\n+\n+   ---------------------------------------\n+   -- 9.4  Single Protected Declaration --\n+   ---------------------------------------\n+\n+   --  Parsed by P_Protected (9.4)\n+\n+   -------------------------------\n+   -- 9.4  Protected Definition --\n+   -------------------------------\n+\n+   --  PROTECTED_DEFINITION ::=\n+   --      {PROTECTED_OPERATION_DECLARATION}\n+   --    [private\n+   --      {PROTECTED_ELEMENT_DECLARATION}]\n+   --    end [protected_IDENTIFIER]\n+\n+   --  PROTECTED_ELEMENT_DECLARATION ::=\n+   --    PROTECTED_OPERATION_DECLARATION\n+   --  | COMPONENT_DECLARATION\n+\n+   --  The caller has already established the scope stack entry\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Protected_Definition return Node_Id is\n+      Def_Node  : Node_Id;\n+      Item_Node : Node_Id;\n+\n+   begin\n+      Def_Node := New_Node (N_Protected_Definition, Token_Ptr);\n+\n+      --  Get rid of active SIS entry from outer scope. This means we will\n+      --  miss some nested cases, but it doesn't seem worth the effort. See\n+      --  discussion in Par for further details\n+\n+      SIS_Entry_Active := False;\n+\n+      --  Loop to scan visible declarations (protected operation declarations)\n+\n+      Set_Visible_Declarations (Def_Node, New_List);\n+\n+      loop\n+         Item_Node := P_Protected_Operation_Declaration_Opt;\n+         exit when No (Item_Node);\n+         Append (Item_Node, Visible_Declarations (Def_Node));\n+      end loop;\n+\n+      --  Deal with PRIVATE part (including graceful handling\n+      --  of multiple PRIVATE parts).\n+\n+      Private_Loop : while Token = Tok_Private loop\n+         if No (Private_Declarations (Def_Node)) then\n+            Set_Private_Declarations (Def_Node, New_List);\n+         else\n+            Error_Msg_SC (\"duplicate private part\");\n+         end if;\n+\n+         Scan; -- past PRIVATE\n+\n+         Declaration_Loop : loop\n+            if Token = Tok_Identifier then\n+               P_Component_Items (Private_Declarations (Def_Node));\n+            else\n+               Item_Node := P_Protected_Operation_Declaration_Opt;\n+               exit Declaration_Loop when No (Item_Node);\n+               Append (Item_Node, Private_Declarations (Def_Node));\n+            end if;\n+         end loop Declaration_Loop;\n+      end loop Private_Loop;\n+\n+      End_Statements (Def_Node);\n+      return Def_Node;\n+   end P_Protected_Definition;\n+\n+   ------------------------------------------\n+   -- 9.4  Protected Operation Declaration --\n+   ------------------------------------------\n+\n+   --  PROTECTED_OPERATION_DECLARATION ::=\n+   --    SUBPROGRAM_DECLARATION\n+   --  | ENTRY_DECLARATION\n+   --  | REPRESENTATION_CLAUSE\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   --  Note: a pragma can also be returned in this position\n+\n+   --  We are not currently permitting representation clauses to appear as\n+   --  protected operation declarations, do we have to rethink this???\n+\n+   function P_Protected_Operation_Declaration_Opt return Node_Id is\n+      L : List_Id;\n+      P : Source_Ptr;\n+\n+   begin\n+      --  This loop runs more than once only when a junk declaration\n+      --  is skipped.\n+\n+      loop\n+         if Token = Tok_Pragma then\n+            return P_Pragma;\n+\n+         elsif Token = Tok_Entry then\n+            return P_Entry_Declaration;\n+\n+         elsif Token = Tok_Function or else Token = Tok_Procedure then\n+            return P_Subprogram (Pf_Decl);\n+\n+         elsif Token = Tok_Identifier then\n+            L := New_List;\n+            P := Token_Ptr;\n+            Skip_Declaration (L);\n+\n+            if Nkind (First (L)) = N_Object_Declaration then\n+               Error_Msg\n+                 (\"component must be declared in private part of \" &\n+                  \"protected type\", P);\n+            else\n+               Error_Msg\n+                 (\"illegal declaration in protected definition\", P);\n+            end if;\n+\n+         elsif Token in Token_Class_Declk then\n+            Error_Msg_SC (\"illegal declaration in protected definition\");\n+            Resync_Past_Semicolon;\n+\n+            --  Return now to avoid cascaded messages if next declaration\n+            --  is a valid component declaration.\n+\n+            return Error;\n+\n+         elsif Token = Tok_For then\n+            Error_Msg_SC\n+              (\"representation clause not allowed in protected definition\");\n+            Resync_Past_Semicolon;\n+\n+         else\n+            return Empty;\n+         end if;\n+      end loop;\n+   end P_Protected_Operation_Declaration_Opt;\n+\n+   -----------------------------------\n+   -- 9.4  Protected Operation Item --\n+   -----------------------------------\n+\n+   --  PROTECTED_OPERATION_ITEM ::=\n+   --    SUBPROGRAM_DECLARATION\n+   --  | SUBPROGRAM_BODY\n+   --  | ENTRY_BODY\n+   --  | REPRESENTATION_CLAUSE\n+\n+   --  This procedure parses and returns a list of protected operation items\n+\n+   --  We are not currently permitting representation clauses to appear\n+   --  as protected operation items, do we have to rethink this???\n+\n+   function P_Protected_Operation_Items return List_Id is\n+      Item_List : List_Id;\n+\n+   begin\n+      Item_List := New_List;\n+\n+      loop\n+         if Token = Tok_Entry or else Bad_Spelling_Of (Tok_Entry) then\n+            Append (P_Entry_Body, Item_List);\n+\n+         elsif Token = Tok_Function or else Bad_Spelling_Of (Tok_Function)\n+                 or else\n+               Token = Tok_Procedure or else Bad_Spelling_Of (Tok_Procedure)\n+         then\n+            Append (P_Subprogram (Pf_Decl_Pbod), Item_List);\n+\n+         elsif Token = Tok_Pragma or else Bad_Spelling_Of (Tok_Pragma) then\n+            P_Pragmas_Opt (Item_List);\n+\n+         elsif Token = Tok_Private or else Bad_Spelling_Of (Tok_Private) then\n+            Error_Msg_SC (\"PRIVATE not allowed in protected body\");\n+            Scan; -- past PRIVATE\n+\n+         elsif Token = Tok_Identifier then\n+            Error_Msg_SC\n+              (\"all components must be declared in spec!\");\n+            Resync_Past_Semicolon;\n+\n+         elsif Token in Token_Class_Declk then\n+            Error_Msg_SC (\"this declaration not allowed in protected body\");\n+            Resync_Past_Semicolon;\n+\n+         else\n+            exit;\n+         end if;\n+      end loop;\n+\n+      return Item_List;\n+   end P_Protected_Operation_Items;\n+\n+   ------------------------------\n+   -- 9.5.2  Entry Declaration --\n+   ------------------------------\n+\n+   --  ENTRY_DECLARATION ::=\n+   --    entry DEFINING_IDENTIFIER [(DISCRETE_SUBTYPE_DEFINITION)]\n+   --      PARAMETER_PROFILE;\n+\n+   --  The caller has checked that the initial token is ENTRY\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Entry_Declaration return Node_Id is\n+      Decl_Node  : Node_Id;\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      Decl_Node := New_Node (N_Entry_Declaration, Token_Ptr);\n+      Scan; -- past ENTRY\n+\n+      Set_Defining_Identifier (Decl_Node, P_Defining_Identifier);\n+\n+      --  If left paren, could be (Discrete_Subtype_Definition) or Formal_Part\n+\n+      if Token = Tok_Left_Paren then\n+         Scan; -- past (\n+\n+         --  If identifier after left paren, could still be either\n+\n+         if Token = Tok_Identifier then\n+            Save_Scan_State (Scan_State); -- at Id\n+            Scan; -- past Id\n+\n+            --  If comma or colon after Id, must be Formal_Part\n+\n+            if Token = Tok_Comma or else Token = Tok_Colon then\n+               Restore_Scan_State (Scan_State); -- to Id\n+               Set_Parameter_Specifications (Decl_Node, P_Formal_Part);\n+\n+            --  Else if Id wi no comma or colon, must be discrete subtype defn\n+\n+            else\n+               Restore_Scan_State (Scan_State); -- to Id\n+               Set_Discrete_Subtype_Definition\n+                 (Decl_Node, P_Discrete_Subtype_Definition);\n+               T_Right_Paren;\n+               Set_Parameter_Specifications (Decl_Node, P_Parameter_Profile);\n+            end if;\n+\n+         --  If no Id, must be discrete subtype definition\n+\n+         else\n+            Set_Discrete_Subtype_Definition\n+              (Decl_Node, P_Discrete_Subtype_Definition);\n+            T_Right_Paren;\n+            Set_Parameter_Specifications (Decl_Node, P_Parameter_Profile);\n+         end if;\n+      end if;\n+\n+      --  Error recovery check for illegal return\n+\n+      if Token = Tok_Return then\n+         Error_Msg_SC (\"entry cannot have return value!\");\n+         Scan;\n+         Discard_Junk_Node (P_Subtype_Indication);\n+      end if;\n+\n+      --  Error recovery check for improper use of entry barrier in spec\n+\n+      if Token = Tok_When then\n+         Error_Msg_SC (\"barrier not allowed here (belongs in body)\");\n+         Scan; -- past WHEN;\n+         Discard_Junk_Node (P_Expression_No_Right_Paren);\n+      end if;\n+\n+      TF_Semicolon;\n+      return Decl_Node;\n+   end P_Entry_Declaration;\n+\n+   -----------------------------\n+   -- 9.5.2  Accept Statement --\n+   -----------------------------\n+\n+   --  ACCEPT_STATEMENT ::=\n+   --    accept entry_DIRECT_NAME\n+   --      [(ENTRY_INDEX)] PARAMETER_PROFILE [do\n+   --        HANDLED_SEQUENCE_OF_STATEMENTS\n+   --    end [entry_IDENTIFIER]];\n+\n+   --  The caller has checked that the initial token is ACCEPT\n+\n+   --  Error recovery: cannot raise Error_Resync. If an error occurs, the\n+   --  scan is resynchronized past the next semicolon and control returns.\n+\n+   function P_Accept_Statement return Node_Id is\n+      Scan_State  : Saved_Scan_State;\n+      Accept_Node : Node_Id;\n+      Hand_Seq    : Node_Id;\n+\n+   begin\n+      Push_Scope_Stack;\n+      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+      Scope.Table (Scope.Last).Ecol := Start_Column;\n+\n+      Accept_Node := New_Node (N_Accept_Statement, Token_Ptr);\n+      Scan; -- past ACCEPT\n+      Scope.Table (Scope.Last).Labl := Token_Node;\n+\n+      Set_Entry_Direct_Name (Accept_Node, P_Identifier);\n+\n+      --  Left paren could be (Entry_Index) or Formal_Part, determine which\n+\n+      if Token = Tok_Left_Paren then\n+         Save_Scan_State (Scan_State); -- at left paren\n+         Scan; -- past left paren\n+\n+         --  If first token after left paren not identifier, then Entry_Index\n+\n+         if Token /= Tok_Identifier then\n+            Set_Entry_Index (Accept_Node, P_Expression);\n+            T_Right_Paren;\n+            Set_Parameter_Specifications (Accept_Node, P_Parameter_Profile);\n+\n+         --  First token after left paren is identifier, could be either case\n+\n+         else -- Token = Tok_Identifier\n+            Scan; -- past identifier\n+\n+            --  If identifier followed by comma or colon, must be Formal_Part\n+\n+            if Token = Tok_Comma or else Token = Tok_Colon then\n+               Restore_Scan_State (Scan_State); -- to left paren\n+               Set_Parameter_Specifications (Accept_Node, P_Parameter_Profile);\n+\n+            --  If identifier not followed by comma/colon, must be entry index\n+\n+            else\n+               Restore_Scan_State (Scan_State); -- to left paren\n+               Scan; -- past left paren (again!)\n+               Set_Entry_Index (Accept_Node, P_Expression);\n+               T_Right_Paren;\n+               Set_Parameter_Specifications (Accept_Node, P_Parameter_Profile);\n+            end if;\n+         end if;\n+      end if;\n+\n+      --  Scan out DO if present\n+\n+      if Token = Tok_Do then\n+         Scope.Table (Scope.Last).Etyp := E_Name;\n+         Scope.Table (Scope.Last).Lreq := False;\n+         Scan; -- past DO\n+         Hand_Seq := P_Handled_Sequence_Of_Statements;\n+         Set_Handled_Statement_Sequence (Accept_Node, Hand_Seq);\n+         End_Statements (Handled_Statement_Sequence (Accept_Node));\n+\n+         --  Exception handlers not allowed in Ada 95 node\n+\n+         if Present (Exception_Handlers (Hand_Seq)) then\n+            if Ada_83 then\n+               Error_Msg_N\n+                 (\"(Ada 83) exception handlers in accept not allowed\",\n+                  First_Non_Pragma (Exception_Handlers (Hand_Seq)));\n+            end if;\n+         end if;\n+\n+      else\n+         Pop_Scope_Stack; -- discard unused entry\n+         TF_Semicolon;\n+      end if;\n+\n+      return Accept_Node;\n+\n+   --  If error, resynchronize past semicolon\n+\n+   exception\n+      when Error_Resync =>\n+         Resync_Past_Semicolon;\n+         return Error;\n+\n+   end P_Accept_Statement;\n+\n+   ------------------------\n+   -- 9.5.2  Entry Index --\n+   ------------------------\n+\n+   --  Parsed by P_Expression (4.4)\n+\n+   -----------------------\n+   -- 9.5.2  Entry Body --\n+   -----------------------\n+\n+   --  ENTRY_BODY ::=\n+   --    entry DEFINING_IDENTIFIER ENTRY_BODY_FORMAL_PART ENTRY_BARRIER is\n+   --      DECLARATIVE_PART\n+   --    begin\n+   --      HANDLED_SEQUENCE_OF_STATEMENTS\n+   --    end [entry_IDENTIFIER];\n+\n+   --  The caller has checked that the initial token is ENTRY\n+\n+   --  Error_Recovery: cannot raise Error_Resync\n+\n+   function P_Entry_Body return Node_Id is\n+      Entry_Node       : Node_Id;\n+      Formal_Part_Node : Node_Id;\n+      Name_Node        : Node_Id;\n+\n+   begin\n+      Push_Scope_Stack;\n+      Entry_Node := New_Node (N_Entry_Body, Token_Ptr);\n+      Scan; -- past ENTRY\n+\n+      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scope.Table (Scope.Last).Lreq := False;\n+      Scope.Table (Scope.Last).Etyp := E_Name;\n+\n+      Name_Node := P_Defining_Identifier;\n+      Set_Defining_Identifier (Entry_Node, Name_Node);\n+      Scope.Table (Scope.Last).Labl := Name_Node;\n+\n+      Formal_Part_Node := P_Entry_Body_Formal_Part;\n+      Set_Entry_Body_Formal_Part (Entry_Node, Formal_Part_Node);\n+\n+      Set_Condition (Formal_Part_Node, P_Entry_Barrier);\n+      Parse_Decls_Begin_End (Entry_Node);\n+      return Entry_Node;\n+   end P_Entry_Body;\n+\n+   -----------------------------------\n+   -- 9.5.2  Entry Body Formal Part --\n+   -----------------------------------\n+\n+   --  ENTRY_BODY_FORMAL_PART ::=\n+   --    [(ENTRY_INDEX_SPECIFICATION)] [PARAMETER_PART]\n+\n+   --  Error_Recovery: cannot raise Error_Resync\n+\n+   function P_Entry_Body_Formal_Part return Node_Id is\n+      Fpart_Node : Node_Id;\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      Fpart_Node := New_Node (N_Entry_Body_Formal_Part, Token_Ptr);\n+\n+      --  See if entry index specification present, and if so parse it\n+\n+      if Token = Tok_Left_Paren then\n+         Save_Scan_State (Scan_State); -- at left paren\n+         Scan; -- past left paren\n+\n+         if Token = Tok_For then\n+            Set_Entry_Index_Specification\n+              (Fpart_Node, P_Entry_Index_Specification);\n+            T_Right_Paren;\n+         else\n+            Restore_Scan_State (Scan_State); -- to left paren\n+         end if;\n+\n+      --  Check for (common?) case of left paren omitted before FOR. This\n+      --  is a tricky case, because the corresponding missing left paren\n+      --  can cause real havoc if a formal part is present which gets\n+      --  treated as part of the discrete subtype definition of the\n+      --  entry index specification, so just give error and resynchronize\n+\n+      elsif Token = Tok_For then\n+         T_Left_Paren; -- to give error message\n+         Resync_To_When;\n+      end if;\n+\n+      Set_Parameter_Specifications (Fpart_Node, P_Parameter_Profile);\n+      return Fpart_Node;\n+   end P_Entry_Body_Formal_Part;\n+\n+   --------------------------\n+   -- 9.5.2  Entry Barrier --\n+   --------------------------\n+\n+   --  ENTRY_BARRIER ::= when CONDITION\n+\n+   --  Error_Recovery: cannot raise Error_Resync\n+\n+   function P_Entry_Barrier return Node_Id is\n+      Bnode : Node_Id;\n+\n+   begin\n+      if Token = Tok_When then\n+         Scan; -- past WHEN;\n+         Bnode := P_Expression_No_Right_Paren;\n+\n+         if Token = Tok_Colon_Equal then\n+            Error_Msg_SC (\"\"\":=\"\" should be \"\"=\"\"\");\n+            Scan;\n+            Bnode := P_Expression_No_Right_Paren;\n+         end if;\n+\n+      else\n+         T_When; -- to give error message\n+         Bnode := Error;\n+      end if;\n+\n+      TF_Is;\n+      return Bnode;\n+   end P_Entry_Barrier;\n+\n+   --------------------------------------\n+   -- 9.5.2  Entry Index Specification --\n+   --------------------------------------\n+\n+   --  ENTRY_INDEX_SPECIFICATION ::=\n+   --    for DEFINING_IDENTIFIER in DISCRETE_SUBTYPE_DEFINITION\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Entry_Index_Specification return Node_Id is\n+      Iterator_Node : Node_Id;\n+\n+   begin\n+      Iterator_Node := New_Node (N_Entry_Index_Specification, Token_Ptr);\n+      T_For; -- past FOR\n+      Set_Defining_Identifier (Iterator_Node, P_Defining_Identifier);\n+      T_In;\n+      Set_Discrete_Subtype_Definition\n+        (Iterator_Node, P_Discrete_Subtype_Definition);\n+      return Iterator_Node;\n+   end P_Entry_Index_Specification;\n+\n+   ---------------------------------\n+   -- 9.5.3  Entry Call Statement --\n+   ---------------------------------\n+\n+   --  Parsed by P_Name (4.1). Within a select, an entry call is parsed\n+   --  by P_Select_Statement (9.7)\n+\n+   ------------------------------\n+   -- 9.5.4  Requeue Statement --\n+   ------------------------------\n+\n+   --  REQUEUE_STATEMENT ::= requeue entry_NAME [with abort];\n+\n+   --  The caller has checked that the initial token is requeue\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Requeue_Statement return Node_Id is\n+      Requeue_Node : Node_Id;\n+\n+   begin\n+      Requeue_Node := New_Node (N_Requeue_Statement, Token_Ptr);\n+      Scan; -- past REQUEUE\n+      Set_Name (Requeue_Node, P_Name);\n+\n+      if Token = Tok_With then\n+         Scan; -- past WITH\n+         T_Abort;\n+         Set_Abort_Present (Requeue_Node, True);\n+      end if;\n+\n+      TF_Semicolon;\n+      return Requeue_Node;\n+   end P_Requeue_Statement;\n+\n+   --------------------------\n+   -- 9.6  Delay Statement --\n+   --------------------------\n+\n+   --  DELAY_STATEMENT ::=\n+   --    DELAY_UNTIL_STATEMENT\n+   --  | DELAY_RELATIVE_STATEMENT\n+\n+   --  The caller has checked that the initial token is DELAY\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Delay_Statement return Node_Id is\n+   begin\n+      Scan; -- past DELAY\n+\n+      --  The following check for delay until misused in Ada 83 doesn't catch\n+      --  all cases, but it's good enough to catch most of them!\n+\n+      if Token_Name = Name_Until then\n+         Check_95_Keyword (Tok_Until, Tok_Left_Paren);\n+         Check_95_Keyword (Tok_Until, Tok_Identifier);\n+      end if;\n+\n+      if Token = Tok_Until then\n+         return P_Delay_Until_Statement;\n+      else\n+         return P_Delay_Relative_Statement;\n+      end if;\n+   end P_Delay_Statement;\n+\n+   --------------------------------\n+   -- 9.6  Delay Until Statement --\n+   --------------------------------\n+\n+   --  DELAY_UNTIL_STATEMENT ::= delay until delay_EXPRESSION;\n+\n+   --  The caller has checked that the initial token is DELAY, scanned it\n+   --  out and checked that the current token is UNTIL\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Delay_Until_Statement return Node_Id is\n+      Delay_Node : Node_Id;\n+\n+   begin\n+      Delay_Node := New_Node (N_Delay_Until_Statement, Prev_Token_Ptr);\n+      Scan; -- past UNTIL\n+      Set_Expression (Delay_Node, P_Expression_No_Right_Paren);\n+      TF_Semicolon;\n+      return Delay_Node;\n+   end P_Delay_Until_Statement;\n+\n+   -----------------------------------\n+   -- 9.6  Delay Relative Statement --\n+   -----------------------------------\n+\n+   --  DELAY_RELATIVE_STATEMENT ::= delay delay_EXPRESSION;\n+\n+   --  The caller has checked that the initial token is DELAY, scanned it\n+   --  out and determined that the current token is not UNTIL\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Delay_Relative_Statement return Node_Id is\n+      Delay_Node : Node_Id;\n+\n+   begin\n+      Delay_Node := New_Node (N_Delay_Relative_Statement, Prev_Token_Ptr);\n+      Set_Expression (Delay_Node, P_Expression_No_Right_Paren);\n+      Check_Simple_Expression_In_Ada_83 (Expression (Delay_Node));\n+      TF_Semicolon;\n+      return Delay_Node;\n+   end P_Delay_Relative_Statement;\n+\n+   ---------------------------\n+   -- 9.7  Select Statement --\n+   ---------------------------\n+\n+   --  SELECT_STATEMENT ::=\n+   --    SELECTIVE_ACCEPT\n+   --  | TIMED_ENTRY_CALL\n+   --  | CONDITIONAL_ENTRY_CALL\n+   --  | ASYNCHRONOUS_SELECT\n+\n+   --  SELECTIVE_ACCEPT ::=\n+   --    select\n+   --      [GUARD]\n+   --        SELECT_ALTERNATIVE\n+   --    {or\n+   --      [GUARD]\n+   --        SELECT_ALTERNATIVE\n+   --    [else\n+   --      SEQUENCE_OF_STATEMENTS]\n+   --    end select;\n+\n+   --  GUARD ::= when CONDITION =>\n+\n+   --  Note: the guard preceding a select alternative is included as part\n+   --  of the node generated for a selective accept alternative.\n+\n+   --  SELECT_ALTERNATIVE ::=\n+   --    ACCEPT_ALTERNATIVE\n+   --  | DELAY_ALTERNATIVE\n+   --  | TERMINATE_ALTERNATIVE\n+\n+   --  TIMED_ENTRY_CALL ::=\n+   --    select\n+   --      ENTRY_CALL_ALTERNATIVE\n+   --    or\n+   --      DELAY_ALTERNATIVE\n+   --    end select;\n+\n+   --  CONDITIONAL_ENTRY_CALL ::=\n+   --    select\n+   --      ENTRY_CALL_ALTERNATIVE\n+   --    else\n+   --      SEQUENCE_OF_STATEMENTS\n+   --    end select;\n+\n+   --  ENTRY_CALL_ALTERNATIVE ::=\n+   --    ENTRY_CALL_STATEMENT [SEQUENCE_OF_STATEMENTS]\n+\n+   --  ASYNCHRONOUS_SELECT ::=\n+   --    select\n+   --      TRIGGERING_ALTERNATIVE\n+   --    then abort\n+   --      ABORTABLE_PART\n+   --    end select;\n+\n+   --  TRIGGERING_ALTERNATIVE ::=\n+   --    TRIGGERING_STATEMENT [SEQUENCE_OF_STATEMENTS]\n+\n+   --  TRIGGERING_STATEMENT ::= ENTRY_CALL_STATEMENT | DELAY_STATEMENT\n+\n+   --  The caller has checked that the initial token is SELECT\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Select_Statement return Node_Id is\n+      Select_Node    : Node_Id;\n+      Select_Sloc    : Source_Ptr;\n+      Stmnt_Sloc     : Source_Ptr;\n+      Ecall_Node     : Node_Id;\n+      Alternative    : Node_Id;\n+      Select_Pragmas : List_Id;\n+      Alt_Pragmas    : List_Id;\n+      Statement_List : List_Id;\n+      Alt_List       : List_Id;\n+      Cond_Expr      : Node_Id;\n+      Delay_Stmnt    : Node_Id;\n+\n+   begin\n+      Push_Scope_Stack;\n+      Scope.Table (Scope.Last).Etyp := E_Select;\n+      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+      Scope.Table (Scope.Last).Labl := Error;\n+\n+      Select_Sloc := Token_Ptr;\n+      Scan; -- past SELECT\n+      Stmnt_Sloc := Token_Ptr;\n+      Select_Pragmas := P_Pragmas_Opt;\n+\n+      --  If first token after select is designator, then we have an entry\n+      --  call, which must be the start of a conditional entry call, timed\n+      --  entry call or asynchronous select\n+\n+      if Token in Token_Class_Desig then\n+\n+         --  Scan entry call statement\n+\n+         begin\n+            Ecall_Node := P_Name;\n+\n+            --  ??  The following two clauses exactly parallel code in ch5\n+            --      and should be commoned sometime\n+\n+            if Nkind (Ecall_Node) = N_Indexed_Component then\n+               declare\n+                  Prefix_Node : Node_Id := Prefix (Ecall_Node);\n+                  Exprs_Node  : List_Id := Expressions (Ecall_Node);\n+               begin\n+                  Change_Node (Ecall_Node, N_Procedure_Call_Statement);\n+                  Set_Name (Ecall_Node, Prefix_Node);\n+                  Set_Parameter_Associations (Ecall_Node, Exprs_Node);\n+               end;\n+\n+            elsif Nkind (Ecall_Node) = N_Function_Call then\n+               declare\n+                  Fname_Node  : Node_Id := Name (Ecall_Node);\n+                  Params_List : List_Id := Parameter_Associations (Ecall_Node);\n+\n+               begin\n+                  Change_Node (Ecall_Node, N_Procedure_Call_Statement);\n+                  Set_Name (Ecall_Node, Fname_Node);\n+                  Set_Parameter_Associations (Ecall_Node, Params_List);\n+               end;\n+\n+            elsif Nkind (Ecall_Node) = N_Identifier\n+              or else Nkind (Ecall_Node) = N_Selected_Component\n+            then\n+               --  Case of a call to a parameterless entry.\n+\n+               declare\n+                  C_Node : constant Node_Id :=\n+                         New_Node (N_Procedure_Call_Statement, Stmnt_Sloc);\n+               begin\n+                  Set_Name (C_Node, Ecall_Node);\n+                  Set_Parameter_Associations (C_Node, No_List);\n+                  Ecall_Node := C_Node;\n+               end;\n+            end if;\n+\n+            TF_Semicolon;\n+\n+         exception\n+            when Error_Resync =>\n+               Resync_Past_Semicolon;\n+               return Error;\n+         end;\n+\n+         Statement_List := P_Sequence_Of_Statements (SS_Eltm_Ortm_Tatm);\n+\n+         --  OR follows, we have a timed entry call\n+\n+         if Token = Tok_Or then\n+            Scan; -- past OR\n+            Alt_Pragmas := P_Pragmas_Opt;\n+\n+            Select_Node := New_Node (N_Timed_Entry_Call, Select_Sloc);\n+            Set_Entry_Call_Alternative (Select_Node,\n+              Make_Entry_Call_Alternative (Stmnt_Sloc,\n+                Entry_Call_Statement => Ecall_Node,\n+                Pragmas_Before       => Select_Pragmas,\n+                Statements           => Statement_List));\n+\n+            --  Only possibility is delay alternative. If we have anything\n+            --  else, give message, and treat as conditional entry call.\n+\n+            if Token /= Tok_Delay then\n+               Error_Msg_SC\n+                 (\"only allowed alternative in timed entry call is delay!\");\n+               Discard_Junk_List (P_Sequence_Of_Statements (SS_Sreq));\n+               Set_Delay_Alternative (Select_Node, Error);\n+\n+            else\n+               Set_Delay_Alternative (Select_Node, P_Delay_Alternative);\n+               Set_Pragmas_Before\n+                 (Delay_Alternative (Select_Node), Alt_Pragmas);\n+            end if;\n+\n+         --  ELSE follows, we have a conditional entry call\n+\n+         elsif Token = Tok_Else then\n+            Scan; -- past ELSE\n+            Select_Node := New_Node (N_Conditional_Entry_Call, Select_Sloc);\n+\n+            Set_Entry_Call_Alternative (Select_Node,\n+              Make_Entry_Call_Alternative (Stmnt_Sloc,\n+                Entry_Call_Statement => Ecall_Node,\n+                Pragmas_Before       => Select_Pragmas,\n+                Statements           => Statement_List));\n+\n+            Set_Else_Statements\n+              (Select_Node, P_Sequence_Of_Statements (SS_Sreq));\n+\n+         --  Only remaining case is THEN ABORT (asynchronous select)\n+\n+         elsif Token = Tok_Abort then\n+            Select_Node :=\n+              Make_Asynchronous_Select (Select_Sloc,\n+                Triggering_Alternative =>\n+                  Make_Triggering_Alternative (Stmnt_Sloc,\n+                    Triggering_Statement => Ecall_Node,\n+                    Pragmas_Before       => Select_Pragmas,\n+                    Statements           => Statement_List),\n+                Abortable_Part => P_Abortable_Part);\n+\n+         --  Else error\n+\n+         else\n+            if Ada_83 then\n+               Error_Msg_BC (\"OR or ELSE expected\");\n+            else\n+               Error_Msg_BC (\"OR or ELSE or THEN ABORT expected\");\n+            end if;\n+\n+            Select_Node := Error;\n+         end if;\n+\n+         End_Statements;\n+\n+      --  Here we have a selective accept or an an asynchronous select (first\n+      --  token after SELECT is other than a designator token).\n+\n+      else\n+         --  If we have delay with no guard, could be asynchronous select\n+\n+         if Token = Tok_Delay then\n+            Delay_Stmnt := P_Delay_Statement;\n+            Statement_List := P_Sequence_Of_Statements (SS_Eltm_Ortm_Tatm);\n+\n+            --  Asynchronous select\n+\n+            if Token = Tok_Abort then\n+               Select_Node :=\n+                 Make_Asynchronous_Select (Select_Sloc,\n+                   Triggering_Alternative =>\n+                     Make_Triggering_Alternative (Stmnt_Sloc,\n+                       Triggering_Statement => Delay_Stmnt,\n+                       Pragmas_Before       => Select_Pragmas,\n+                       Statements           => Statement_List),\n+                     Abortable_Part => P_Abortable_Part);\n+\n+               End_Statements;\n+               return Select_Node;\n+\n+            --  Delay which was not an asynchronous select. Must be a selective\n+            --  accept, and since at least one accept statement is required,\n+            --  we must have at least one OR phrase present.\n+\n+            else\n+               Alt_List := New_List (\n+                 Make_Delay_Alternative (Stmnt_Sloc,\n+                   Delay_Statement => Delay_Stmnt,\n+                   Pragmas_Before  => Select_Pragmas,\n+                   Statements      => Statement_List));\n+               T_Or;\n+               Alt_Pragmas := P_Pragmas_Opt;\n+            end if;\n+\n+         --  If not a delay statement, then must be another possibility for\n+         --  a selective accept alternative, or perhaps a guard is present\n+\n+         else\n+            Alt_List := New_List;\n+            Alt_Pragmas := Select_Pragmas;\n+         end if;\n+\n+         Select_Node := New_Node (N_Selective_Accept, Select_Sloc);\n+         Set_Select_Alternatives (Select_Node, Alt_List);\n+\n+         --  Scan out selective accept alternatives. On entry to this loop,\n+         --  we are just past a SELECT or OR token, and any pragmas that\n+         --  immediately follow the SELECT or OR are in Alt_Pragmas.\n+\n+         loop\n+            if Token = Tok_When then\n+\n+               if Present (Alt_Pragmas) then\n+                  Error_Msg_SC (\"pragmas may not precede guard\");\n+               end if;\n+\n+               Scan; --  past WHEN\n+               Cond_Expr := P_Expression_No_Right_Paren;\n+               T_Arrow;\n+               Alt_Pragmas := P_Pragmas_Opt;\n+\n+            else\n+               Cond_Expr := Empty;\n+            end if;\n+\n+            if Token = Tok_Accept then\n+               Alternative := P_Accept_Alternative;\n+\n+               --  Check for junk attempt at asynchronous select using\n+               --  an Accept alternative as the triggering statement\n+\n+               if Token = Tok_Abort\n+                 and then Is_Empty_List (Alt_List)\n+                 and then No (Cond_Expr)\n+               then\n+                  Error_Msg\n+                    (\"triggering statement must be entry call or delay\",\n+                     Sloc (Alternative));\n+                  Scan; -- past junk ABORT\n+                  Discard_Junk_List (P_Sequence_Of_Statements (SS_Sreq));\n+                  End_Statements;\n+                  return Error;\n+               end if;\n+\n+            elsif Token = Tok_Delay then\n+               Alternative := P_Delay_Alternative;\n+\n+            elsif Token = Tok_Terminate then\n+               Alternative := P_Terminate_Alternative;\n+\n+            else\n+               Error_Msg_SC\n+                 (\"Select alternative (ACCEPT, ABORT, DELAY) expected\");\n+               Alternative := Error;\n+\n+               if Token = Tok_Semicolon then\n+                  Scan; -- past junk semicolon\n+               end if;\n+            end if;\n+\n+            --  THEN ABORT at this stage is just junk\n+\n+            if Token = Tok_Abort then\n+               Error_Msg_SP (\"misplaced `THEN ABORT`\");\n+               Scan; -- past junk ABORT\n+               Discard_Junk_List (P_Sequence_Of_Statements (SS_Sreq));\n+               End_Statements;\n+               return Error;\n+\n+            else\n+               if Alternative /= Error then\n+                  Set_Condition (Alternative, Cond_Expr);\n+                  Set_Pragmas_Before (Alternative, Alt_Pragmas);\n+                  Append (Alternative, Alt_List);\n+               end if;\n+\n+               exit when Token /= Tok_Or;\n+            end if;\n+\n+            T_Or;\n+            Alt_Pragmas := P_Pragmas_Opt;\n+         end loop;\n+\n+         if Token = Tok_Else then\n+            Scan; -- past ELSE\n+            Set_Else_Statements\n+              (Select_Node, P_Sequence_Of_Statements (SS_Ortm_Sreq));\n+\n+            if Token = Tok_Or then\n+               Error_Msg_SC (\"select alternative cannot follow else part!\");\n+            end if;\n+         end if;\n+\n+         End_Statements;\n+      end if;\n+\n+      return Select_Node;\n+   end P_Select_Statement;\n+\n+   -----------------------------\n+   -- 9.7.1  Selective Accept --\n+   -----------------------------\n+\n+   --  Parsed by P_Select_Statement (9.7)\n+\n+   ------------------\n+   -- 9.7.1  Guard --\n+   ------------------\n+\n+   --  Parsed by P_Select_Statement (9.7)\n+\n+   -------------------------------\n+   -- 9.7.1  Select Alternative --\n+   -------------------------------\n+\n+   --  SELECT_ALTERNATIVE ::=\n+   --    ACCEPT_ALTERNATIVE\n+   --  | DELAY_ALTERNATIVE\n+   --  | TERMINATE_ALTERNATIVE\n+\n+   --  Note: the guard preceding a select alternative is included as part\n+   --  of the node generated for a selective accept alternative.\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   -------------------------------\n+   -- 9.7.1  Accept Alternative --\n+   -------------------------------\n+\n+   --  ACCEPT_ALTERNATIVE ::=\n+   --    ACCEPT_STATEMENT [SEQUENCE_OF_STATEMENTS]\n+\n+   --  Error_Recovery: Cannot raise Error_Resync\n+\n+   --  Note: the caller is responsible for setting the Pragmas_Before\n+   --  field of the returned N_Terminate_Alternative node.\n+\n+   function P_Accept_Alternative return Node_Id is\n+      Accept_Alt_Node : Node_Id;\n+\n+   begin\n+      Accept_Alt_Node := New_Node (N_Accept_Alternative, Token_Ptr);\n+      Set_Accept_Statement (Accept_Alt_Node, P_Accept_Statement);\n+\n+      --  Note: the reason that we accept THEN ABORT as a terminator for\n+      --  the sequence of statements is for error recovery which allows\n+      --  for misuse of an accept statement as a triggering statememt.\n+\n+      Set_Statements\n+        (Accept_Alt_Node, P_Sequence_Of_Statements (SS_Eltm_Ortm_Tatm));\n+      return Accept_Alt_Node;\n+   end P_Accept_Alternative;\n+\n+   ------------------------------\n+   -- 9.7.1  Delay Alternative --\n+   ------------------------------\n+\n+   --  DELAY_ALTERNATIVE ::=\n+   --    DELAY_STATEMENT [SEQUENCE_OF_STATEMENTS]\n+\n+   --  Error_Recovery: Cannot raise Error_Resync\n+\n+   --  Note: the caller is responsible for setting the Pragmas_Before\n+   --  field of the returned N_Terminate_Alternative node.\n+\n+   function P_Delay_Alternative return Node_Id is\n+      Delay_Alt_Node : Node_Id;\n+\n+   begin\n+      Delay_Alt_Node := New_Node (N_Delay_Alternative, Token_Ptr);\n+      Set_Delay_Statement (Delay_Alt_Node, P_Delay_Statement);\n+\n+      --  Note: the reason that we accept THEN ABORT as a terminator for\n+      --  the sequence of statements is for error recovery which allows\n+      --  for misuse of an accept statement as a triggering statememt.\n+\n+      Set_Statements\n+        (Delay_Alt_Node, P_Sequence_Of_Statements (SS_Eltm_Ortm_Tatm));\n+      return Delay_Alt_Node;\n+   end P_Delay_Alternative;\n+\n+   ----------------------------------\n+   -- 9.7.1  Terminate Alternative --\n+   ----------------------------------\n+\n+   --  TERMINATE_ALTERNATIVE ::= terminate;\n+\n+   --  Error_Recovery: Cannot raise Error_Resync\n+\n+   --  Note: the caller is responsible for setting the Pragmas_Before\n+   --  field of the returned N_Terminate_Alternative node.\n+\n+   function P_Terminate_Alternative return Node_Id is\n+      Terminate_Alt_Node : Node_Id;\n+\n+   begin\n+      Terminate_Alt_Node := New_Node (N_Terminate_Alternative, Token_Ptr);\n+      Scan; -- past TERMINATE\n+      TF_Semicolon;\n+\n+      --  For all other select alternatives, the sequence of statements\n+      --  after the alternative statement will swallow up any pragmas\n+      --  coming in this position. But the terminate alternative has no\n+      --  sequence of statements, so the pragmas here must be treated\n+      --  specially.\n+\n+      Set_Pragmas_After (Terminate_Alt_Node, P_Pragmas_Opt);\n+      return Terminate_Alt_Node;\n+   end P_Terminate_Alternative;\n+\n+   -----------------------------\n+   -- 9.7.2  Timed Entry Call --\n+   -----------------------------\n+\n+   --  Parsed by P_Select_Statement (9.7)\n+\n+   -----------------------------------\n+   -- 9.7.2  Entry Call Alternative --\n+   -----------------------------------\n+\n+   --  Parsed by P_Select_Statement (9.7)\n+\n+   -----------------------------------\n+   -- 9.7.3  Conditional Entry Call --\n+   -----------------------------------\n+\n+   --  Parsed by P_Select_Statement (9.7)\n+\n+   --------------------------------\n+   -- 9.7.4  Asynchronous Select --\n+   --------------------------------\n+\n+   --  Parsed by P_Select_Statement (9.7)\n+\n+   -----------------------------------\n+   -- 9.7.4  Triggering Alternative --\n+   -----------------------------------\n+\n+   --  Parsed by P_Select_Statement (9.7)\n+\n+   ---------------------------------\n+   -- 9.7.4  Triggering Statement --\n+   ---------------------------------\n+\n+   --  Parsed by P_Select_Statement (9.7)\n+\n+   ---------------------------\n+   -- 9.7.4  Abortable Part --\n+   ---------------------------\n+\n+   --  ABORTABLE_PART ::= SEQUENCE_OF_STATEMENTS\n+\n+   --  The caller has verified that THEN ABORT is present, and Token is\n+   --  pointing to the ABORT on entry (or if not, then we have an error)\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Abortable_Part return Node_Id is\n+      Abortable_Part_Node : Node_Id;\n+\n+   begin\n+      Abortable_Part_Node := New_Node (N_Abortable_Part, Token_Ptr);\n+      T_Abort; -- scan past ABORT\n+\n+      if Ada_83 then\n+         Error_Msg_SP (\"(Ada 83) asynchronous select not allowed!\");\n+      end if;\n+\n+      Set_Statements (Abortable_Part_Node, P_Sequence_Of_Statements (SS_Sreq));\n+      return Abortable_Part_Node;\n+   end P_Abortable_Part;\n+\n+   --------------------------\n+   -- 9.8  Abort Statement --\n+   --------------------------\n+\n+   --  ABORT_STATEMENT ::= abort task_NAME {, task_NAME};\n+\n+   --  The caller has checked that the initial token is ABORT\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Abort_Statement return Node_Id is\n+      Abort_Node : Node_Id;\n+\n+   begin\n+      Abort_Node := New_Node (N_Abort_Statement, Token_Ptr);\n+      Scan; -- past ABORT\n+      Set_Names (Abort_Node, New_List);\n+\n+      loop\n+         Append (P_Name, Names (Abort_Node));\n+         exit when Token /= Tok_Comma;\n+         Scan; -- past comma\n+      end loop;\n+\n+      TF_Semicolon;\n+      return Abort_Node;\n+   end P_Abort_Statement;\n+\n+end Ch9;"}, {"sha": "fa5b8c20a1aa46ac34c190c87d21a41942600b9f", "filename": "gcc/ada/par-endh.adb", "status": "added", "additions": 1191, "deletions": 0, "changes": 1191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-endh.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-endh.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-endh.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,1191 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P A R . E N D H                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.61 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Stringt; use Stringt;\n+with Uintp;   use Uintp;\n+\n+with GNAT.Spelling_Checker; use GNAT.Spelling_Checker;\n+\n+separate (Par)\n+package body Endh is\n+\n+   ----------------\n+   -- Local Data --\n+   ----------------\n+\n+   type End_Action_Type is (\n+   --  Type used to describe the result of the Pop_End_Context call\n+\n+      Accept_As_Scanned,\n+      --  Current end sequence is entirely c correct. In this case Token and\n+      --  the scan pointer are left pointing past the end sequence (i.e. they\n+      --  are unchanged from the values set on entry to Pop_End_Context).\n+\n+      Insert_And_Accept,\n+      --  Current end sequence is to be left in place to satisfy some outer\n+      --  scope. Token and the scan pointer are set to point to the end\n+      --  token, and should be left there. A message has been generated\n+      --  indicating a missing end sequence. This status is also used for\n+      --  the case when no end token is present.\n+\n+      Skip_And_Accept,\n+      --  The end sequence is incorrect (and an error message has been\n+      --  posted), but it will still be accepted. In this case Token and\n+      --  the scan pointer point back to the end token, and the caller\n+      --  should skip past the end sequence before proceeding.\n+\n+      Skip_And_Reject);\n+      --  The end sequence is judged to belong to an unrecognized inner\n+      --  scope. An appropriate message has been issued and the caller\n+      --  should skip past the end sequence and then proceed as though\n+      --  no end sequence had been encountered.\n+\n+   End_Action : End_Action_Type;\n+   --  The variable set by Pop_End_Context call showing which of the four\n+   --  decisions described above is judged the best.\n+\n+   End_Sloc : Source_Ptr;\n+   --  Source location of END token\n+\n+   End_OK : Boolean;\n+   --  Set False if error is found in END line\n+\n+   End_Column : Column_Number;\n+   --  Column of END line\n+\n+   End_Type : SS_End_Type;\n+   --  Type of END expected. The special value E_Dummy is set to indicate that\n+   --  no END token was present (so a missing END inserted message is needed)\n+\n+   End_Labl : Node_Id;\n+   --  Node_Id value for explicit name on END line, or for compiler supplied\n+   --  name in the case where an optional name is not given. Empty if no name\n+   --  appears. If non-empty, then it is either an N_Designator node for a\n+   --  child unit or a node with a Chars field identifying the actual label.\n+\n+   End_Labl_Present : Boolean;\n+   --  Indicates that the value in End_Labl was for an explicit label.\n+\n+   Syntax_OK : Boolean;\n+   --  Set True if the entry is syntactically correct\n+\n+   Token_OK : Boolean;\n+   --  Set True if the keyword in the END sequence matches, or if neither\n+   --  the END sequence nor the END stack entry has a keyword.\n+\n+   Label_OK : Boolean;\n+   --  Set True if both the END sequence and the END stack entry contained\n+   --  labels (other than No_Name or Error_Name) and the labels matched.\n+   --  This is a stronger condition than SYNTAX_OK, since it means that a\n+   --  label was present, even in a case where it was optional. Note that\n+   --  the case of no label required, and no label present does NOT set\n+   --  Label_OK to True, it is True only if a positive label match is found.\n+\n+   Column_OK : Boolean;\n+   --  Column_OK is set True if the END sequence appears in the expected column\n+\n+   Scan_State : Saved_Scan_State;\n+   --  Save state at start of END sequence, in case we decide not to eat it up\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Evaluate_End_Entry (SS_Index : Int);\n+   --  Compare scanned END entry (as recorded by a prior call to P_End_Scan)\n+   --  with a specified entry in the scope stack (the single parameter is the\n+   --  entry index in the scope stack). Note that Scan is not called. The above\n+   --  variables xxx_OK are set to indicate the result of the evaluation.\n+\n+   procedure Output_End_Deleted;\n+   --  Output a message complaining that the current END structure does not\n+   --  match anything and is being deleted.\n+\n+   procedure Output_End_Expected (Ins : Boolean);\n+   --  Output a message at the start of the current token which is always an\n+   --  END, complaining that the END is not of the right form. The message\n+   --  indicates the expected form. The information for the message is taken\n+   --  from the top entry in the scope stack. The Ins parameter is True if\n+   --  an end is being inserted, and false if an existing end is being\n+   --  replaced. Note that in the case of a suspicious IS for the Ins case,\n+   --  we do not output the message, but instead simply mark the scope stack\n+   --  entry as being a case of a bad IS.\n+\n+   procedure Output_End_Missing;\n+   --  Output a message just before the current token, complaining that the\n+   --  END is not of the right form. The message indicates the expected form.\n+   --  The information for the message is taken from the top entry in the\n+   --  scope stack. Note that in the case of a suspicious IS, we do not output\n+   --  the message, but instead simply mark the scope stack entry as a bad IS.\n+\n+   procedure Pop_End_Context;\n+   --  Pop_End_Context is called after processing a construct, to pop the\n+   --  top entry off the end stack. It decides on the appropriate action to\n+   --  to take, signalling the result by setting End_Action as described in\n+   --  the global variable section.\n+\n+   function Same_Label (Label1, Label2 : Node_Id) return Boolean;\n+   --  This function compares the two names associated with the given nodes.\n+   --  If they are both simple (i.e. have Chars fields), then they have to\n+   --  be the same name. Otherwise they must both be N_Selected_Component\n+   --  nodes, referring to the same set of names, or Label1 is an N_Designator\n+   --  referring to the same set of names as the N_Defining_Program_Unit_Name\n+   --  in Label2. Any other combination returns False. This routine is used\n+   --  to compare the End_Labl scanned from the End line with the saved label\n+   --  value in the scope stack.\n+\n+   ---------------\n+   -- Check_End --\n+   ---------------\n+\n+   function Check_End return Boolean is\n+      Name_On_Separate_Line : Boolean;\n+      --  Set True if the name on an END line is on a separate source line\n+      --  from the END. This is highly suspicious, but is allowed. The point\n+      --  is that we want to make sure that we don't just have a missing\n+      --  semicolon misleading us into swallowing an identifier from the\n+      --  following line.\n+\n+      Name_Scan_State : Saved_Scan_State;\n+      --  Save state at start of name if Name_On_Separate_Line is TRUE\n+\n+      Span_Node : constant Node_Id := Scope.Table (Scope.Last).Node;\n+\n+   begin\n+      End_Labl_Present := False;\n+      End_Labl := Empty;\n+\n+      --  Our first task is to scan out the END sequence if one is present.\n+      --  If none is present, signal by setting End_Type to E_Dummy.\n+\n+      if Token /= Tok_End then\n+         End_Type := E_Dummy;\n+\n+      else\n+         Save_Scan_State (Scan_State); -- at END\n+         End_Sloc := Token_Ptr;\n+         End_Column := Start_Column;\n+         End_OK := True;\n+         Scan; -- past END\n+\n+         --  Set End_Span if expected. note that this will be useless\n+         --  if we do not have the right ending keyword, but in this\n+         --  case we have a malformed program anyway, and the setting\n+         --  of End_Span will simply be unreliable in this case anyway.\n+\n+         if Present (Span_Node) then\n+            Set_End_Location (Span_Node, Token_Ptr);\n+         end if;\n+\n+         --  Cases of keywords where no label is allowed\n+\n+         if Token = Tok_Case then\n+            End_Type := E_Case;\n+            Scan; -- past CASE\n+\n+         elsif Token = Tok_If then\n+            End_Type := E_If;\n+            Scan; -- past IF\n+\n+         elsif Token = Tok_Record then\n+            End_Type := E_Record;\n+            Scan; -- past RECORD\n+\n+         elsif Token = Tok_Select then\n+            End_Type := E_Select;\n+            Scan; -- past SELECT\n+\n+         --  Cases which do allow labels\n+\n+         else\n+            --  LOOP\n+\n+            if Token = Tok_Loop then\n+               Scan; -- past LOOP\n+               End_Type := E_Loop;\n+\n+            --  FOR or WHILE allowed (signalling error) to substitute for LOOP\n+            --  if on the same line as the END\n+\n+            elsif (Token = Tok_For or else Token = Tok_While)\n+              and then not Token_Is_At_Start_Of_Line\n+            then\n+               Scan; -- past FOR or WHILE\n+               End_Type := E_Loop;\n+               End_OK := False;\n+\n+            --  Cases with no keyword\n+\n+            else\n+               End_Type := E_Name;\n+            end if;\n+\n+            --  Now see if a name is present\n+\n+            if Token = Tok_Identifier or else\n+               Token = Tok_String_Literal or else\n+               Token = Tok_Operator_Symbol\n+            then\n+               if Token_Is_At_Start_Of_Line then\n+                  Name_On_Separate_Line := True;\n+                  Save_Scan_State (Name_Scan_State);\n+               else\n+                  Name_On_Separate_Line := False;\n+               end if;\n+\n+               End_Labl := P_Designator;\n+               End_Labl_Present := True;\n+\n+               --  We have now scanned out a name. Here is where we do a check\n+               --  to catch the cases like:\n+               --\n+               --    end loop\n+               --    X := 3;\n+               --\n+               --  where the missing semicolon might make us swallow up the X\n+               --  as a bogus end label. In a situation like this, where the\n+               --  apparent name is on a separate line, we accept it only if\n+               --  it matches the label and is followed by a semicolon.\n+\n+               if Name_On_Separate_Line then\n+                  if Token /= Tok_Semicolon or else\n+                    not Same_Label (End_Labl, Scope.Table (Scope.Last).Labl)\n+                  then\n+                     Restore_Scan_State (Name_Scan_State);\n+                     End_Labl := Empty;\n+                     End_Labl_Present := False;\n+                  end if;\n+               end if;\n+\n+            --  Here for case of name allowed, but no name present. We will\n+            --  supply an implicit matching name, with source location set\n+            --  to the scan location past the END token.\n+\n+            else\n+               End_Labl := Scope.Table (Scope.Last).Labl;\n+\n+               if End_Labl > Empty_Or_Error then\n+\n+                  --  The task here is to construct a designator from the\n+                  --  opening label, with the components all marked as not\n+                  --  from source, and Is_End_Label set in the identifier\n+                  --  or operator symbol. The location for all components\n+                  --  is the curent token location.\n+\n+                  --  Case of child unit name\n+\n+                  if Nkind (End_Labl) = N_Defining_Program_Unit_Name then\n+                     declare\n+                        Eref : constant Node_Id :=\n+                                 Make_Identifier (Token_Ptr,\n+                                   Chars =>\n+                                     Chars (Defining_Identifier (End_Labl)));\n+\n+                        function Copy_Name (N : Node_Id) return Node_Id;\n+                        --  Copies a selected component or identifier\n+\n+                        function Copy_Name (N : Node_Id) return Node_Id is\n+                           R : Node_Id;\n+\n+                        begin\n+                           if Nkind (N) = N_Selected_Component then\n+                              return\n+                                Make_Selected_Component (Token_Ptr,\n+                                  Prefix        =>\n+                                    Copy_Name (Prefix (N)),\n+                                  Selector_Name =>\n+                                    Copy_Name (Selector_Name (N)));\n+\n+                           else\n+                              R :=\n+                                Make_Identifier (Token_Ptr,\n+                                  Chars => Chars (N));\n+                              Set_Comes_From_Source (N, False);\n+                              return R;\n+                           end if;\n+                        end Copy_Name;\n+\n+                     begin\n+                        Set_Comes_From_Source (Eref, False);\n+\n+                        End_Labl :=\n+                          Make_Designator (Token_Ptr,\n+                            Name       => Copy_Name (Name (End_Labl)),\n+                            Identifier => Eref);\n+                     end;\n+\n+                  --  Simple identifier case\n+\n+                  elsif Nkind (End_Labl) = N_Defining_Identifier\n+                    or else Nkind (End_Labl) = N_Identifier\n+                  then\n+                     End_Labl :=\n+                       Make_Identifier (Token_Ptr,\n+                         Chars => Chars (End_Labl));\n+\n+                  elsif Nkind (End_Labl) = N_Defining_Operator_Symbol\n+                    or else Nkind (End_Labl) = N_Operator_Symbol\n+                  then\n+                     Get_Decoded_Name_String (Chars (End_Labl));\n+\n+                     End_Labl :=\n+                       Make_Operator_Symbol (Token_Ptr,\n+                         Chars  => Chars (End_Labl),\n+                         Strval => String_From_Name_Buffer);\n+                  end if;\n+\n+                  Set_Comes_From_Source (End_Labl, False);\n+                  End_Labl_Present := False;\n+\n+                  --  Do style check for missing label\n+\n+                  if Style_Check\n+                    and then End_Type = E_Name\n+                    and then Present (Scope.Table (Scope.Last).Labl)\n+                  then\n+                     Style.No_End_Name (Scope.Table (Scope.Last).Labl);\n+                  end if;\n+               end if;\n+            end if;\n+         end if;\n+\n+         --  Except in case of END RECORD, semicolon must follow. For END\n+         --  RECORD, a semicolon does follow, but it is part of a higher level\n+         --  construct. In any case, a missing semicolon is not serious enough\n+         --  to consider the END statement to be bad in the sense that we\n+         --  are dealing with (i.e. to be suspicious that it is not in fact\n+         --  the END statement we are looking for!)\n+\n+         if End_Type /= E_Record then\n+            if Token = Tok_Semicolon then\n+               T_Semicolon;\n+\n+            --  Semicolon is missing. If the missing semicolon is at the end\n+            --  of the line, i.e. we are at the start of the line now, then\n+            --  a missing semicolon gets flagged, but is not serious enough\n+            --  to consider the END statement to be bad in the sense that we\n+            --  are dealing with (i.e. to be suspicious that this END is not\n+            --  the END statement we are looking for).\n+\n+            --  Similarly, if we are at a colon, we flag it but a colon for\n+            --  a semicolon is not serious enough to consider the END to be\n+            --  incorrect. Same thing for a period in place of a semicolon.\n+\n+            elsif Token_Is_At_Start_Of_Line\n+              or else Token = Tok_Colon\n+              or else Token = Tok_Dot\n+            then\n+               T_Semicolon;\n+\n+            --  If the missing semicolon is not at the start of the line,\n+            --  then we do consider the END line to be dubious in this sense.\n+\n+            else\n+               End_OK := False;\n+            end if;\n+         end if;\n+      end if;\n+\n+      --  Now we call the Pop_End_Context routine to get a recommendation\n+      --  as to what should be done with the END sequence we have scanned.\n+\n+      Pop_End_Context;\n+\n+      --  Remaining action depends on End_Action set by Pop_End_Context\n+\n+      case End_Action is\n+\n+         --  Accept_As_Scanned. In this case, Pop_End_Context left Token\n+         --  pointing past the last token of a syntactically correct END\n+\n+         when Accept_As_Scanned =>\n+\n+            --  Syntactically correct included the possibility of a missing\n+            --  semicolon. If we do have a missing semicolon, then we have\n+            --  already given a message, but now we scan out possible rubbish\n+            --  on the same line as the END\n+\n+            while not Token_Is_At_Start_Of_Line\n+              and then Prev_Token /= Tok_Record\n+              and then Prev_Token /= Tok_Semicolon\n+              and then Token /= Tok_End\n+              and then Token /= Tok_EOF\n+            loop\n+               Scan; -- past junk\n+            end loop;\n+\n+            return True;\n+\n+         --  Insert_And_Accept. In this case, Pop_End_Context has reset Token\n+         --  to point to the start of the END sequence, and recommends that it\n+         --  be left in place to satisfy an outer scope level END. This means\n+         --  that we proceed as though an END were present, and leave the scan\n+         --  pointer unchanged.\n+\n+         when Insert_And_Accept =>\n+            return True;\n+\n+         --  Skip_And_Accept. In this case, Pop_End_Context has reset Token\n+         --  to point to the start of the END sequence. This END sequence is\n+         --  syntactically incorrect, and an appropriate error message has\n+         --  already been posted. Pop_End_Context recommends accepting the\n+         --  END sequence as the one we want, so we skip past it and then\n+         --  proceed as though an END were present.\n+\n+         when Skip_And_Accept =>\n+            End_Skip;\n+            return True;\n+\n+         --  Skip_And_Reject. In this case, Pop_End_Context has reset Token\n+         --  to point to the start of the END sequence. This END sequence is\n+         --  syntactically incorrect, and an appropriate error message has\n+         --  already been posted. Pop_End_Context recommends entirely ignoring\n+         --  this END sequence, so we skip past it and then return False, since\n+         --  as far as the caller is concerned, no END sequence is present.\n+\n+         when Skip_And_Reject =>\n+            End_Skip;\n+            return False;\n+      end case;\n+   end Check_End;\n+\n+   --------------\n+   -- End Skip --\n+   --------------\n+\n+   --  This procedure skips past an END sequence. On entry Token contains\n+   --  Tok_End, and we know that the END sequence is syntactically incorrect,\n+   --  and that an appropriate error message has already been posted. The\n+   --  mission is simply to position the scan pointer to be the best guess of\n+   --  the position after the END sequence. We do not issue any additional\n+   --  error messages while carrying this out.\n+\n+   --  Error recovery: does not raise Error_Resync\n+\n+   procedure End_Skip is\n+   begin\n+      Scan; -- past END\n+\n+      --  If the scan past the END leaves us on the next line, that's probably\n+      --  where we should quit the scan, since it is likely that what we have\n+      --  is a missing semicolon. Consider the following:\n+\n+      --       END\n+      --       Process_Input;\n+\n+      --  This will have looked like a syntactically valid END sequence to the\n+      --  initial scan of the END, but subsequent checking will have determined\n+      --  that the label Process_Input is not an appropriate label. The real\n+      --  error is a missing semicolon after the END, and by leaving the scan\n+      --  pointer just past the END, we will improve the error recovery.\n+\n+      if Token_Is_At_Start_Of_Line then\n+         return;\n+      end if;\n+\n+      --  If there is a semicolon after the END, scan it out and we are done\n+\n+      if Token = Tok_Semicolon then\n+         T_Semicolon;\n+         return;\n+      end if;\n+\n+      --  Otherwise skip past a token after the END on the same line. Note\n+      --  that we do not eat a token on the following line since it seems\n+      --  very unlikely in any case that the END gets separated from its\n+      --  token, and we do not want to swallow up a keyword that starts a\n+      --  legitimate construct following the bad END.\n+\n+      if not Token_Is_At_Start_Of_Line\n+        and then\n+\n+         --  Cases of normal tokens following an END\n+\n+          (Token = Tok_Case   or else\n+           Token = Tok_For    or else\n+           Token = Tok_If     or else\n+           Token = Tok_Loop   or else\n+           Token = Tok_Record or else\n+           Token = Tok_Select or else\n+\n+         --  Cases of bogus keywords ending loops\n+\n+           Token = Tok_For    or else\n+           Token = Tok_While  or else\n+\n+         --  Cases of operator symbol names without quotes\n+\n+           Token = Tok_Abs    or else\n+           Token = Tok_And    or else\n+           Token = Tok_Mod    or else\n+           Token = Tok_Not    or else\n+           Token = Tok_Or     or else\n+           Token = Tok_Xor)\n+\n+      then\n+         Scan; -- past token after END\n+\n+         --  If that leaves us on the next line, then we are done. This is the\n+         --  same principle described above for the case of END at line end\n+\n+         if Token_Is_At_Start_Of_Line then\n+            return;\n+\n+         --  If we just scanned out record, then we are done, since the\n+         --  semicolon after END RECORD is not part of the END sequence\n+\n+         elsif Prev_Token = Tok_Record then\n+            return;\n+\n+         --  If we have a semicolon, scan it out and we are done\n+\n+         elsif Token = Tok_Semicolon then\n+            T_Semicolon;\n+            return;\n+         end if;\n+      end if;\n+\n+      --  Check for a label present on the same line\n+\n+      loop\n+         if Token_Is_At_Start_Of_Line then\n+            return;\n+         end if;\n+\n+         if Token /= Tok_Identifier\n+           and then Token /= Tok_Operator_Symbol\n+           and then Token /= Tok_String_Literal\n+         then\n+            exit;\n+         end if;\n+\n+         Scan; -- past identifier, operator symbol or string literal\n+\n+         if Token_Is_At_Start_Of_Line then\n+            return;\n+         elsif Token = Tok_Dot then\n+            Scan; -- past dot\n+         end if;\n+      end loop;\n+\n+      --  Skip final semicolon\n+\n+      if Token = Tok_Semicolon then\n+         T_Semicolon;\n+\n+      --  If we don't have a final semicolon, skip until we either encounter\n+      --  an END token, or a semicolon or the start of the next line. This\n+      --  allows general junk to follow the end line (normally it is hard to\n+      --  think that anyone will put anything deliberate here, and remember\n+      --  that we know there is a missing semicolon in any case). We also\n+      --  quite on an EOF (or else we would get stuck in an infinite loop\n+      --  if there is no line end at the end of the last line of the file)\n+\n+      else\n+         while Token /= Tok_End\n+           and then Token /= Tok_EOF\n+           and then Token /= Tok_Semicolon\n+           and then not Token_Is_At_Start_Of_Line\n+         loop\n+            Scan; -- past junk token on same line\n+         end loop;\n+      end if;\n+\n+      return;\n+   end End_Skip;\n+\n+   --------------------\n+   -- End Statements --\n+   --------------------\n+\n+   --  This procedure is called when END is required or expected to terminate\n+   --  a sequence of statements. The caller has already made an appropriate\n+   --  entry on the scope stack to describe the expected form of the END.\n+   --  End_Statements should only be used in cases where the only appropriate\n+   --  terminator is END.\n+\n+   --  Error recovery: cannot raise Error_Resync;\n+\n+   procedure End_Statements (Parent : Node_Id := Empty) is\n+   begin\n+      --  This loop runs more than once in the case where Check_End rejects\n+      --  the END sequence, as indicated by Check_End returning False.\n+\n+      loop\n+         if Check_End then\n+            if Present (Parent) then\n+               Set_End_Label (Parent, End_Labl);\n+            end if;\n+\n+            return;\n+         end if;\n+\n+         --  Extra statements past the bogus END are discarded. This is not\n+         --  ideal for maximum error recovery, but it's too much trouble to\n+         --  find an appropriate place to put them!\n+\n+         Discard_Junk_List (P_Sequence_Of_Statements (SS_None));\n+      end loop;\n+   end End_Statements;\n+\n+   ------------------------\n+   -- Evaluate End Entry --\n+   ------------------------\n+\n+   procedure Evaluate_End_Entry (SS_Index : Int) is\n+   begin\n+      Column_OK := (End_Column = Scope.Table (SS_Index).Ecol);\n+\n+      Token_OK  := (End_Type = Scope.Table (SS_Index).Etyp or else\n+                     (End_Type = E_Name and then\n+                       Scope.Table (SS_Index).Etyp >= E_Name));\n+\n+      Label_OK := End_Labl_Present\n+                    and then\n+                      (Same_Label (End_Labl, Scope.Table (SS_Index).Labl)\n+                        or else Scope.Table (SS_Index).Labl = Error);\n+\n+      --  Compute setting of Syntax_OK. We definitely have a syntax error\n+      --  if the Token does not match properly or if P_End_Scan detected\n+      --  a syntax error such as a missing semicolon.\n+\n+      if not Token_OK or not End_OK then\n+         Syntax_OK := False;\n+\n+      --  Final check is that label is OK. Certainly it is OK if there\n+      --  was an exact match on the label (the END label = the stack label)\n+\n+      elsif Label_OK then\n+         Syntax_OK := True;\n+\n+      --  Case of label present\n+\n+      elsif End_Labl_Present then\n+\n+         --  If probably misspelling, then complain, and pretend it is OK\n+\n+         declare\n+            Nam : constant Node_Or_Entity_Id := Scope.Table (SS_Index).Labl;\n+\n+         begin\n+            if Nkind (End_Labl) in N_Has_Chars\n+              and then Nkind (Nam) in N_Has_Chars\n+              and then Chars (End_Labl) > Error_Name\n+              and then Chars (Nam) > Error_Name\n+            then\n+               Get_Name_String (Chars (End_Labl));\n+               Error_Msg_Name_1 := Chars (Nam);\n+\n+               if Error_Msg_Name_1 > Error_Name then\n+                  declare\n+                     S : String (1 .. Name_Len) := Name_Buffer (1 .. Name_Len);\n+\n+                  begin\n+                     Get_Name_String (Error_Msg_Name_1);\n+\n+                     if Is_Bad_Spelling_Of\n+                         (Name_Buffer (1 .. Name_Len), S)\n+                     then\n+                        Error_Msg_N (\"misspelling of %\", End_Labl);\n+                        Syntax_OK := True;\n+                        return;\n+                     end if;\n+                  end;\n+               end if;\n+            end if;\n+         end;\n+\n+         Syntax_OK := False;\n+\n+      --  Otherwise we have cases of no label on the END line. For the loop\n+      --  case, this is acceptable only if the loop is unlabeled.\n+\n+      elsif End_Type = E_Loop then\n+         Syntax_OK := (Scope.Table (SS_Index).Labl = Empty);\n+\n+      --  Cases where a label is definitely allowed on the END line\n+\n+      elsif End_Type = E_Name then\n+         Syntax_OK := (Scope.Table (SS_Index).Labl = Empty or else\n+                         not Scope.Table (SS_Index).Lreq);\n+\n+      --  Otherwise we have cases which don't allow labels anyway, so we\n+      --  certainly accept an END which does not have a label.\n+\n+      else\n+         Syntax_OK := True;\n+      end if;\n+   end Evaluate_End_Entry;\n+\n+   ------------------------\n+   -- Output End Deleted --\n+   ------------------------\n+\n+   procedure Output_End_Deleted is\n+   begin\n+\n+      if End_Type = E_Loop then\n+         Error_Msg_SC (\"no LOOP for this `END LOOP`!\");\n+\n+      elsif End_Type = E_Case then\n+         Error_Msg_SC (\"no CASE for this `END CASE`\");\n+\n+      elsif End_Type = E_If then\n+         Error_Msg_SC (\"no IF for this `END IF`!\");\n+\n+      elsif End_Type = E_Record then\n+         Error_Msg_SC (\"no RECORD for this `END RECORD`!\");\n+\n+      elsif End_Type = E_Select then\n+         Error_Msg_SC (\"no SELECT for this `END SELECT`!\");\n+\n+      else\n+         Error_Msg_SC (\"no BEGIN for this END!\");\n+      end if;\n+   end Output_End_Deleted;\n+\n+   -------------------------\n+   -- Output End Expected --\n+   -------------------------\n+\n+   procedure Output_End_Expected (Ins : Boolean) is\n+      End_Type : SS_End_Type;\n+\n+   begin\n+      --  Suppress message if this was a potentially junk entry (e.g. a\n+      --  record entry where no record keyword was present.\n+\n+      if Scope.Table (Scope.Last).Junk then\n+         return;\n+      end if;\n+\n+      End_Type := Scope.Table (Scope.Last).Etyp;\n+      Error_Msg_Col    := Scope.Table (Scope.Last).Ecol;\n+      Error_Msg_Node_1 := Scope.Table (Scope.Last).Labl;\n+      Error_Msg_Sloc   := Scope.Table (Scope.Last).Sloc;\n+\n+      --  Suppress message if error was posted on opening label\n+\n+      if Present (Error_Msg_Node_1)\n+        and then Error_Posted (Error_Msg_Node_1)\n+      then\n+         return;\n+      end if;\n+\n+      if End_Type = E_Case then\n+         Error_Msg_SC (\"`END CASE;` expected@ for CASE#!\");\n+\n+      elsif End_Type = E_If then\n+         Error_Msg_SC (\"`END IF;` expected@ for IF#!\");\n+\n+      elsif End_Type = E_Loop then\n+         if Error_Msg_Node_1 = Empty then\n+            Error_Msg_SC\n+              (\"`END LOOP;` expected@ for LOOP#!\");\n+         else\n+            Error_Msg_SC (\"`END LOOP &;` expected@!\");\n+         end if;\n+\n+      elsif End_Type = E_Record then\n+         Error_Msg_SC\n+           (\"`END RECORD;` expected@ for RECORD#!\");\n+\n+      elsif End_Type = E_Select then\n+         Error_Msg_SC\n+           (\"`END SELECT;` expected@ for SELECT#!\");\n+\n+      --  All remaining cases are cases with a name (we do not treat\n+      --  the suspicious is cases specially for a replaced end, only\n+      --  for an inserted end).\n+\n+      elsif End_Type = E_Name or else (not Ins) then\n+         if Error_Msg_Node_1 = Empty then\n+            Error_Msg_SC (\"`END;` expected@ for BEGIN#!\");\n+         else\n+            Error_Msg_SC (\"`END &;` expected@!\");\n+         end if;\n+\n+      --  The other possibility is a missing END for a subprogram with a\n+      --  suspicious IS (that probably should have been a semicolon). The\n+      --  Missing IS confirms the suspicion!\n+\n+      else -- End_Type = E_Suspicious_Is or E_Bad_Is\n+         Scope.Table (Scope.Last).Etyp := E_Bad_Is;\n+      end if;\n+   end Output_End_Expected;\n+\n+   ------------------------\n+   -- Output End Missing --\n+   ------------------------\n+\n+   procedure Output_End_Missing is\n+      End_Type : SS_End_Type;\n+\n+   begin\n+      --  Suppress message if this was a potentially junk entry (e.g. a\n+      --  record entry where no record keyword was present.\n+\n+      if Scope.Table (Scope.Last).Junk then\n+         return;\n+      end if;\n+\n+      End_Type := Scope.Table (Scope.Last).Etyp;\n+      Error_Msg_Node_1 := Scope.Table (Scope.Last).Labl;\n+      Error_Msg_Sloc   := Scope.Table (Scope.Last).Sloc;\n+\n+      if End_Type = E_Case then\n+         Error_Msg_BC (\"missing `END CASE;` for CASE#!\");\n+\n+      elsif End_Type = E_If then\n+         Error_Msg_BC (\"missing `END IF;` for IF#!\");\n+\n+      elsif End_Type = E_Loop then\n+         if Error_Msg_Node_1 = Empty then\n+            Error_Msg_BC (\"missing `END LOOP;` for LOOP#!\");\n+         else\n+            Error_Msg_BC (\"missing `END LOOP &;`!\");\n+         end if;\n+\n+      elsif End_Type = E_Record then\n+         Error_Msg_SC\n+           (\"missing `END RECORD;` for RECORD#!\");\n+\n+      elsif End_Type = E_Select then\n+         Error_Msg_BC\n+           (\"missing `END SELECT;` for SELECT#!\");\n+\n+      elsif End_Type = E_Name then\n+         if Error_Msg_Node_1 = Empty then\n+            Error_Msg_BC (\"missing `END;` for BEGIN#!\");\n+         else\n+            Error_Msg_BC (\"missing `END &;`!\");\n+         end if;\n+\n+      else -- End_Type = E_Suspicious_Is or E_Bad_Is\n+         Scope.Table (Scope.Last).Etyp := E_Bad_Is;\n+      end if;\n+   end Output_End_Missing;\n+\n+   ---------------------\n+   -- Pop End Context --\n+   ---------------------\n+\n+   procedure Pop_End_Context is\n+\n+      Pretty_Good : Boolean;\n+      --  This flag is set True if the END sequence is syntactically incorrect,\n+      --  but is (from a heuristic point of view), pretty likely to be simply\n+      --  a misspelling of the intended END.\n+\n+      Outer_Match : Boolean;\n+      --  This flag is set True if we decide that the current END sequence\n+      --  belongs to some outer level entry in the scope stack, and thus\n+      --  we will NOT eat it up in matching the current expected END.\n+\n+   begin\n+      --  If not at END, then output END expected message\n+\n+      if End_Type = E_Dummy then\n+         Output_End_Missing;\n+         Pop_Scope_Stack;\n+         End_Action := Insert_And_Accept;\n+         return;\n+\n+      --  Otherwise we do have an END present\n+\n+      else\n+         --  A special check. If we have END; followed by an end of file,\n+         --  WITH or SEPARATE, then if we are not at the outer level, then\n+         --  we have a sytax error. Consider the example:\n+\n+         --   ...\n+         --      declare\n+         --         X : Integer;\n+         --      begin\n+         --         X := Father (A);\n+         --         Process (X, X);\n+         --   end;\n+         --   with Package1;\n+         --   ...\n+\n+         --  Now the END; here is a syntactically correct closer for the\n+         --  declare block, but if we eat it up, then we obviously have\n+         --  a missing END for the outer context (since WITH can only appear\n+         --  at the outer level.\n+\n+         --  In this situation, we always reserve the END; for the outer level,\n+         --  even if it is in the wrong column. This is because it's much more\n+         --  useful to have the error message point to the DECLARE than to the\n+         --  package header in this case.\n+\n+         --  We also reserve an end with a name before the end of file if the\n+         --  name is the one we expect at the outer level.\n+\n+         if (Token = Tok_EOF or else\n+             Token = Tok_With or else\n+             Token = Tok_Separate)\n+           and then End_Type >= E_Name\n+           and then (not End_Labl_Present\n+                      or else Same_Label (End_Labl, Scope.Table (1).Labl))\n+           and then Scope.Last > 1\n+         then\n+            Restore_Scan_State (Scan_State); -- to END\n+            Output_End_Expected (Ins => True);\n+            Pop_Scope_Stack;\n+            End_Action := Insert_And_Accept;\n+            return;\n+         end if;\n+\n+         --  Otherwise we go through the normal END evaluation procedure\n+\n+         Evaluate_End_Entry (Scope.Last);\n+\n+         --  If top entry in stack is syntactically correct, then we have\n+         --  scanned it out and everything is fine. This is the required\n+         --  action to properly process correct Ada programs.\n+\n+         if Syntax_OK then\n+\n+            --  Complain if checking columns and END is not in right column.\n+            --  Right in this context means exactly right, or on the same\n+            --  line as the opener.\n+\n+            if Style.RM_Column_Check then\n+               if End_Column /= Scope.Table (Scope.Last).Ecol\n+                 and then Current_Line_Start > Scope.Table (Scope.Last).Sloc\n+               then\n+                  Error_Msg_Col := Scope.Table (Scope.Last).Ecol;\n+                  Error_Msg\n+                    (\"(style) END in wrong column, should be@\", End_Sloc);\n+               end if;\n+            end if;\n+\n+            --  One final check. If the end had a label, check for an exact\n+            --  duplicate of this end sequence, and if so, skip it with an\n+            --  appropriate message.\n+\n+            if End_Labl_Present and then Token = Tok_End then\n+               declare\n+                  Scan_State : Saved_Scan_State;\n+                  End_Loc    : constant Source_Ptr := Token_Ptr;\n+                  Nxt_Labl   : Node_Id;\n+                  Dup_Found  : Boolean := False;\n+\n+               begin\n+                  Save_Scan_State (Scan_State);\n+\n+                  Scan; -- past END\n+\n+                  if Token = Tok_Identifier\n+                    or else Token = Tok_Operator_Symbol\n+                  then\n+                     Nxt_Labl := P_Designator;\n+\n+                     --  We only consider it an error if the label is a match\n+                     --  and would be wrong for the level one above us, and\n+                     --  the indentation is the same.\n+\n+                     if Token = Tok_Semicolon\n+                       and then Same_Label (End_Labl, Nxt_Labl)\n+                       and then End_Column = Start_Column\n+                       and then\n+                         (Scope.Last = 1\n+                            or else\n+                              (No (Scope.Table (Scope.Last - 1).Labl)\n+                                or else\n+                               not Same_Label\n+                                     (End_Labl,\n+                                      Scope.Table (Scope.Last - 1).Labl)))\n+                     then\n+                        T_Semicolon;\n+                        Error_Msg (\"duplicate end line ignored\", End_Loc);\n+                        Dup_Found := True;\n+                     end if;\n+                  end if;\n+\n+                  if not Dup_Found then\n+                     Restore_Scan_State (Scan_State);\n+                  end if;\n+               end;\n+            end if;\n+\n+            --  All OK, so return to caller indicating END is OK\n+\n+            Pop_Scope_Stack;\n+            End_Action := Accept_As_Scanned;\n+            return;\n+         end if;\n+\n+         --  If that check failed, then we definitely have an error. The issue\n+         --  is how to choose among three possible courses of action:\n+\n+         --   1. Ignore the current END text completely, scanning past it,\n+         --      deciding that it belongs neither to the current context,\n+         --      nor to any outer context.\n+\n+         --   2. Accept the current END text, scanning past it, and issuing\n+         --      an error message that it does not have the right form.\n+\n+         --   3. Leave the current END text in place, NOT scanning past it,\n+         --      issuing an error message indicating the END expected for the\n+         --      current context. In this case, the END is available to match\n+         --      some outer END context.\n+\n+         --  From a correct functioning point of view, it does not make any\n+         --  difference which of these three approaches we take, the program\n+         --  will work correctly in any case. However, making an accurate\n+         --  choice among these alternatives, i.e. choosing the one that\n+         --  corresponds to what the programmer had in mind, does make a\n+         --  significant difference in the quality of error recovery.\n+\n+         Restore_Scan_State (Scan_State); -- to END\n+\n+         --  First we see how good the current END entry is with respect to\n+         --  what we expect. It is considered pretty good if the token is OK,\n+         --  and either the label or the column matches. an END for RECORD is\n+         --  always considered to be pretty good in the record case. This is\n+         --  because not only does a record disallow a nested structure, but\n+         --  also it is unlikely that such nesting could occur by accident.\n+\n+         Pretty_Good := (Token_OK and (Column_OK or Label_OK))\n+                          or else Scope.Table (Scope.Last).Etyp = E_Record;\n+\n+         --  Next check, if there is a deeper entry in the stack which\n+         --  has a very high probability of being acceptable, then insert\n+         --  the END entry we want, leaving the higher level entry for later\n+\n+         for J in reverse 1 .. Scope.Last - 1 loop\n+            Evaluate_End_Entry (J);\n+\n+            --  To even consider the deeper entry to be immediately acceptable,\n+            --  it must be syntactically correct. Furthermore it must either\n+            --  have a correct label, or the correct column. If the current\n+            --  entry was a close match (Pretty_Good set), then we are even\n+            --  more strict in accepting the outer level one: even if it has\n+            --  the right label, it must have the right column as well.\n+\n+            if Syntax_OK then\n+               if Pretty_Good then\n+                  Outer_Match := Label_OK and Column_OK;\n+               else\n+                  Outer_Match := Label_OK or Column_OK;\n+               end if;\n+            else\n+               Outer_Match := False;\n+            end if;\n+\n+            --  If the outer entry does convincingly match the END text, then\n+            --  back up the scan to the start of the END sequence, issue an\n+            --  error message indicating the END we expected, and return with\n+            --  Token pointing to the END (case 3 from above discussion).\n+\n+            if Outer_Match then\n+               Output_End_Missing;\n+               Pop_Scope_Stack;\n+               End_Action := Insert_And_Accept;\n+               return;\n+            end if;\n+         end loop;\n+\n+         --  Here we have a situation in which the current END entry is\n+         --  syntactically incorrect, but there is no deeper entry in the\n+         --  END stack which convincingly matches it.\n+\n+         --  If the END text was judged to be a Pretty_Good match for the\n+         --  expected token or if it appears left of the expected column,\n+         --  then we will accept it as the one we want, scanning past it, even\n+         --  though it is not completely right (we issue a message showing what\n+         --  we expected it to be). This is action 2 from the discussion above.\n+         --  There is one other special case to consider: the LOOP case.\n+         --  Consider the example:\n+\n+         --     Lbl: loop\n+         --             null;\n+         --          end loop;\n+\n+         --  Here the column lines up with Lbl, so END LOOP is to the right,\n+         --  but it is still acceptable. LOOP is the one case where alignment\n+         --  practices vary substantially in practice.\n+\n+         if Pretty_Good\n+            or else End_Column <= Scope.Table (Scope.Last).Ecol\n+            or else (End_Type = Scope.Table (Scope.Last).Etyp\n+                        and then End_Type = E_Loop)\n+         then\n+            Output_End_Expected (Ins => False);\n+            Pop_Scope_Stack;\n+            End_Action := Skip_And_Accept;\n+            return;\n+\n+         --  Here we have the case where the END is to the right of the\n+         --  expected column and does not have a correct label to convince\n+         --  us that it nevertheless belongs to the current scope. For this\n+         --  we consider that it probably belongs not to the current context,\n+         --  but to some inner context that was not properly recognized (due to\n+         --  other syntax errors), and for which no proper scope stack entry\n+         --  was made. The proper action in this case is to delete the END text\n+         --  and return False to the caller as a signal to keep on looking for\n+         --  an acceptable END. This is action 1 from the discussion above.\n+\n+         else\n+            Output_End_Deleted;\n+            End_Action := Skip_And_Reject;\n+            return;\n+         end if;\n+      end if;\n+   end Pop_End_Context;\n+\n+   ----------------\n+   -- Same_Label --\n+   ----------------\n+\n+   function Same_Label (Label1, Label2 : Node_Id) return Boolean is\n+   begin\n+      if Nkind (Label1) in N_Has_Chars\n+        and then Nkind (Label2) in N_Has_Chars\n+      then\n+         return Chars (Label1) = Chars (Label2);\n+\n+      elsif Nkind (Label1) = N_Selected_Component\n+        and then Nkind (Label2) = N_Selected_Component\n+      then\n+         return Same_Label (Prefix (Label1), Prefix (Label2)) and then\n+           Same_Label (Selector_Name (Label1), Selector_Name (Label2));\n+\n+      elsif Nkind (Label1) = N_Designator\n+        and then Nkind (Label2) = N_Defining_Program_Unit_Name\n+      then\n+         return Same_Label (Name (Label1), Name (Label2)) and then\n+           Same_Label (Identifier (Label1), Defining_Identifier (Label2));\n+\n+      else\n+         return False;\n+      end if;\n+   end Same_Label;\n+\n+end Endh;"}, {"sha": "e43d3f3f01d9b0ed30309445fbc6fa8904963cd7", "filename": "gcc/ada/par-labl.adb", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-labl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-labl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-labl.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,202 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P A R . L A B L                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.18 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1998, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+separate (Par)\n+procedure Labl is\n+   Enclosing_Body_Or_Block : Node_Id;\n+   --  Innermost enclosing body or block statement\n+\n+   Label_Decl_Node : Node_Id;\n+   --  Implicit label declaration node\n+\n+   Defining_Ident_Node : Node_Id;\n+   --  Defining identifier node for implicit label declaration\n+\n+   Next_Label_Elmt : Elmt_Id;\n+   --  Next element on label element list\n+\n+   Label_Node : Node_Id;\n+   --  Next label node to process\n+\n+   function Find_Enclosing_Body_Or_Block (N : Node_Id) return Node_Id;\n+   --  Find the innermost body or block that encloses N.\n+\n+   function Find_Enclosing_Body (N : Node_Id) return Node_Id;\n+   --  Find the innermost body that encloses N.\n+\n+   procedure Check_Distinct_Labels;\n+   --  Checks the rule in RM-5.1(11), which requires distinct identifiers\n+   --  for all the labels in a given body.\n+\n+   ---------------------------\n+   -- Check_Distinct_Labels --\n+   ---------------------------\n+\n+   procedure Check_Distinct_Labels is\n+      Label_Id : constant Node_Id := Identifier (Label_Node);\n+\n+      Enclosing_Body : constant Node_Id :=\n+                         Find_Enclosing_Body (Enclosing_Body_Or_Block);\n+      --  Innermost enclosing body\n+\n+      Next_Other_Label_Elmt : Elmt_Id := First_Elmt (Label_List);\n+      --  Next element on label element list\n+\n+      Other_Label : Node_Id;\n+      --  Next label node to process\n+\n+   begin\n+      --  Loop through all the labels, and if we find some other label\n+      --  (i.e. not Label_Node) that has the same identifier,\n+      --  and whose innermost enclosing body is the same,\n+      --  then we have an error.\n+\n+      --  Note that in the worst case, this is quadratic in the number\n+      --  of labels.  However, labels are not all that common, and this\n+      --  is only called for explicit labels.\n+      --  ???Nonetheless, the efficiency could be improved. For example,\n+      --  call Labl for each body, rather than once per compilation.\n+\n+      while Present (Next_Other_Label_Elmt) loop\n+         Other_Label := Node (Next_Other_Label_Elmt);\n+\n+         exit when Label_Node = Other_Label;\n+\n+         if Chars (Label_Id) = Chars (Identifier (Other_Label))\n+           and then Enclosing_Body = Find_Enclosing_Body (Other_Label)\n+         then\n+            Error_Msg_Sloc := Sloc (Other_Label);\n+            Error_Msg_N (\"& conflicts with label#\", Label_Id);\n+            exit;\n+         end if;\n+\n+         Next_Elmt (Next_Other_Label_Elmt);\n+      end loop;\n+   end Check_Distinct_Labels;\n+\n+   -------------------------\n+   -- Find_Enclosing_Body --\n+   -------------------------\n+\n+   function Find_Enclosing_Body (N : Node_Id) return Node_Id is\n+      Result : Node_Id := N;\n+\n+   begin\n+      --  This is the same as Find_Enclosing_Body_Or_Block, except\n+      --  that we skip block statements and accept statements, instead\n+      --  of stopping at them.\n+\n+      while Present (Result)\n+        and then Nkind (Result) /= N_Entry_Body\n+        and then Nkind (Result) /= N_Task_Body\n+        and then Nkind (Result) /= N_Package_Body\n+        and then Nkind (Result) /= N_Subprogram_Body\n+      loop\n+         Result := Parent (Result);\n+      end loop;\n+\n+      return Result;\n+   end Find_Enclosing_Body;\n+\n+   ----------------------------------\n+   -- Find_Enclosing_Body_Or_Block --\n+   ----------------------------------\n+\n+   function Find_Enclosing_Body_Or_Block (N : Node_Id) return Node_Id is\n+      Result : Node_Id := Parent (N);\n+\n+   begin\n+      --  Climb up the parent chain until we find a body or block.\n+\n+      while Present (Result)\n+        and then Nkind (Result) /= N_Accept_Statement\n+        and then Nkind (Result) /= N_Entry_Body\n+        and then Nkind (Result) /= N_Task_Body\n+        and then Nkind (Result) /= N_Package_Body\n+        and then Nkind (Result) /= N_Subprogram_Body\n+        and then Nkind (Result) /= N_Block_Statement\n+      loop\n+         Result := Parent (Result);\n+      end loop;\n+\n+      return Result;\n+   end Find_Enclosing_Body_Or_Block;\n+\n+--  Start of processing for Par.Labl\n+\n+begin\n+   Next_Label_Elmt := First_Elmt (Label_List);\n+\n+   while Present (Next_Label_Elmt) loop\n+      Label_Node := Node (Next_Label_Elmt);\n+\n+      if not Comes_From_Source (Label_Node) then\n+         goto Next_Label;\n+      end if;\n+\n+      --  Find the innermost enclosing body or block, which is where\n+      --  we need to implicitly declare this label\n+\n+      Enclosing_Body_Or_Block := Find_Enclosing_Body_Or_Block (Label_Node);\n+\n+      --  If we didn't find a parent, then the label in question never got\n+      --  hooked into a reasonable declarative part. This happens only in\n+      --  error situations, and we simply ignore the entry (we aren't going\n+      --  to get into the semantics in any case given the error).\n+\n+      if Present (Enclosing_Body_Or_Block) then\n+         Check_Distinct_Labels;\n+\n+         --  Now create the implicit label declaration node and its\n+         --  corresponding defining identifier. Note that the defining\n+         --  occurrence of a label is the implicit label declaration that\n+         --  we are creating. The label itself is an applied occurrence.\n+\n+         Label_Decl_Node :=\n+           New_Node (N_Implicit_Label_Declaration, Sloc (Label_Node));\n+         Defining_Ident_Node :=\n+           New_Entity (N_Defining_Identifier, Sloc (Identifier (Label_Node)));\n+         Set_Chars (Defining_Ident_Node, Chars (Identifier (Label_Node)));\n+         Set_Defining_Identifier (Label_Decl_Node, Defining_Ident_Node);\n+         Set_Label_Construct (Label_Decl_Node, Label_Node);\n+\n+         --  Now attach the implicit label declaration to the appropriate\n+         --  declarative region, creating a declaration list if none exists\n+\n+         if not Present (Declarations (Enclosing_Body_Or_Block)) then\n+            Set_Declarations (Enclosing_Body_Or_Block, New_List);\n+         end if;\n+\n+         Append (Label_Decl_Node, Declarations (Enclosing_Body_Or_Block));\n+      end if;\n+\n+      <<Next_Label>>\n+         Next_Elmt (Next_Label_Elmt);\n+   end loop;\n+\n+end Labl;"}, {"sha": "39934caacb0c73aa8fafd0229c85ef8770be8cf8", "filename": "gcc/ada/par-load.adb", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-load.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,410 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P A R . L O A D                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.60 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  The Par.Load procedure loads all units that are definitely required before\n+--  it makes any sense at all to proceed with semantic analysis, including\n+--  with'ed units, corresponding specs for bodies, parents of child specs,\n+--  and parents of subunits. All these units are loaded and pointers installed\n+--  in the tree as described in the spec of package Lib.\n+\n+with Fname;    use Fname;\n+with Fname.UF; use Fname.UF;\n+with Lib.Load; use Lib.Load;\n+with Uname;    use Uname;\n+with Namet;    use Namet;\n+with Casing;   use Casing;\n+with Opt;      use Opt;\n+with Osint;    use Osint;\n+with Sinput.L; use Sinput.L;\n+with Stylesw;  use Stylesw;\n+with Validsw;  use Validsw;\n+\n+separate (Par)\n+procedure Load is\n+\n+   File_Name : File_Name_Type;\n+   --  Name of file for current unit, derived from unit name\n+\n+   Cur_Unum : Unit_Number_Type := Current_Source_Unit;\n+   --  Unit number of unit that we just finished parsing. Note that we need\n+   --  to capture this, because Source_Unit will change as we parse new\n+   --  source files in the multiple main source file case.\n+\n+   Curunit : constant Node_Id := Cunit (Cur_Unum);\n+   --  Compilation unit node for current compilation unit\n+\n+   Loc : Source_Ptr := Sloc (Curunit);\n+   --  Source location for compilation unit node\n+\n+   Save_Style_Check  : Boolean;\n+   Save_Style_Checks : Style_Check_Options;\n+   --  Save style check so it can be restored later\n+\n+   Save_Validity_Check  : Boolean;\n+   Save_Validity_Checks : Validity_Check_Options;\n+   --  Save validity check so it can be restored later\n+\n+   With_Cunit : Node_Id;\n+   --  Compilation unit node for withed unit\n+\n+   Context_Node : Node_Id;\n+   --  Next node in context items list\n+\n+   With_Node : Node_Id;\n+   --  N_With_Clause node\n+\n+   Spec_Name : Unit_Name_Type;\n+   --  Unit name of required spec\n+\n+   Body_Name : Unit_Name_Type;\n+   --  Unit name of corresponding body\n+\n+   Unum : Unit_Number_Type;\n+   --  Unit number of loaded unit\n+\n+   function Same_File_Name_Except_For_Case\n+     (Expected_File_Name : File_Name_Type;\n+      Actual_File_Name   : File_Name_Type)\n+      return               Boolean;\n+   --  Given an actual file name and an expected file name (the latter being\n+   --  derived from the unit name), determine if they are the same except for\n+   --  possibly different casing of letters.\n+\n+   function Same_File_Name_Except_For_Case\n+     (Expected_File_Name : File_Name_Type;\n+      Actual_File_Name   : File_Name_Type)\n+      return               Boolean\n+   is\n+   begin\n+      Get_Name_String (Actual_File_Name);\n+      Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n+\n+      declare\n+         Lower_Case_Actual_File_Name : String (1 .. Name_Len);\n+\n+      begin\n+         Lower_Case_Actual_File_Name := Name_Buffer (1 .. Name_Len);\n+         Get_Name_String (Expected_File_Name);\n+         Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n+         return Lower_Case_Actual_File_Name = Name_Buffer (1 .. Name_Len);\n+      end;\n+\n+   end Same_File_Name_Except_For_Case;\n+\n+--  Start of processing for Load\n+\n+begin\n+   --  Don't do any loads if we already had a fatal error\n+\n+   if Fatal_Error (Cur_Unum) then\n+      return;\n+   end if;\n+\n+   Save_Style_Check_Options (Save_Style_Checks);\n+   Save_Style_Check := Opt.Style_Check;\n+\n+   Save_Validity_Check_Options (Save_Validity_Checks);\n+   Save_Validity_Check := Opt.Validity_Checks_On;\n+\n+   --  If main unit, set Main_Unit_Entity (this will get overwritten if\n+   --  the main unit has a separate spec, that happens later on in Load)\n+\n+   if Cur_Unum = Main_Unit then\n+      Main_Unit_Entity := Cunit_Entity (Main_Unit);\n+   end if;\n+\n+   --  If we have no unit name, things are seriously messed up by previous\n+   --  errors, and we should not try to continue compilation.\n+\n+   if Unit_Name (Cur_Unum) = No_Name then\n+      raise Unrecoverable_Error;\n+   end if;\n+\n+   --  Next step, make sure that the unit name matches the file name\n+   --  and issue a warning message if not. We only output this for the\n+   --  main unit, since for other units it is more serious and is\n+   --  caught in a separate test below.\n+\n+   File_Name :=\n+     Get_File_Name\n+       (Unit_Name (Cur_Unum),\n+        Subunit => Nkind (Unit (Cunit (Cur_Unum))) = N_Subunit);\n+\n+   if Cur_Unum = Main_Unit\n+     and then File_Name /= Unit_File_Name (Cur_Unum)\n+     and then (File_Names_Case_Sensitive\n+                or not Same_File_Name_Except_For_Case\n+                         (File_Name, Unit_File_Name (Cur_Unum)))\n+   then\n+      Error_Msg_Name_1 := File_Name;\n+      Error_Msg\n+        (\"?file name does not match unit name, should be{\", Sloc (Curunit));\n+   end if;\n+\n+   --  For units other than the main unit, the expected unit name is set and\n+   --  must be the same as the actual unit name, or we are in big trouble, and\n+   --  abandon the compilation since there are situations where this really\n+   --  gets us into bad trouble (e.g. some subunit situations).\n+\n+   if Cur_Unum /= Main_Unit\n+     and then Expected_Unit (Cur_Unum) /= Unit_Name (Cur_Unum)\n+   then\n+      Loc := Error_Location (Cur_Unum);\n+      Error_Msg_Name_1 := Unit_File_Name (Cur_Unum);\n+      Get_Name_String (Error_Msg_Name_1);\n+\n+      --  Check for predefined file case\n+\n+      if Name_Len > 1\n+        and then Name_Buffer (2) = '-'\n+        and then (Name_Buffer (1) = 'a'\n+                    or else\n+                  Name_Buffer (1) = 's'\n+                    or else\n+                  Name_Buffer (1) = 'i'\n+                    or else\n+                  Name_Buffer (1) = 'g')\n+      then\n+         --  In the predefined file case, we know the user did not construct\n+         --  their own package, but we got the wrong one. This means that the\n+         --  name supplied by the user crunched to something we recognized,\n+         --  but then the file did not contain the unit expected. Most likely\n+         --  this is due to a misspelling, e.g.\n+\n+         --    with Ada.Calender;\n+\n+         --  This crunches to a-calend, which indeed contains the unit\n+         --  Ada.Calendar, and we can diagnose the misspelling. This is\n+         --  a simple heuristic, but it catches many common cases of\n+         --  misspelling of predefined unit names without needing a full\n+         --  list of them.\n+\n+         Error_Msg_Name_1 := Expected_Unit (Cur_Unum);\n+         Error_Msg (\"% is not a predefined library unit!\", Loc);\n+         Error_Msg_Name_1 := Unit_Name (Cur_Unum);\n+         Error_Msg (\"possible misspelling of %!\", Loc);\n+\n+      --  Non-predefined file name case\n+\n+      else\n+         Error_Msg (\"file { does not contain expected unit!\", Loc);\n+         Error_Msg_Unit_1 := Expected_Unit (Cur_Unum);\n+         Error_Msg (\"expected unit $!\", Loc);\n+         Error_Msg_Unit_1 := Unit_Name (Cur_Unum);\n+         Error_Msg (\"found unit $!\", Loc);\n+      end if;\n+\n+      raise Unrecoverable_Error;\n+   end if;\n+\n+   --  If current unit is a body, load its corresponding spec\n+\n+   if Nkind (Unit (Curunit)) = N_Package_Body\n+     or else Nkind (Unit (Curunit)) = N_Subprogram_Body\n+   then\n+      Spec_Name := Get_Spec_Name (Unit_Name (Cur_Unum));\n+      Unum :=\n+        Load_Unit\n+          (Load_Name  => Spec_Name,\n+           Required   => False,\n+           Subunit    => False,\n+           Error_Node => Curunit,\n+           Corr_Body  => Cur_Unum);\n+\n+      --  If we successfully load the unit, then set the spec pointer. Once\n+      --  again note that if the loaded unit has a fatal error, Load will\n+      --  have set our Fatal_Error flag to propagate this condition.\n+\n+      if Unum /= No_Unit then\n+         Set_Library_Unit (Curunit, Cunit (Unum));\n+\n+         --  If this is a separate spec for the main unit, then we reset\n+         --  Main_Unit_Entity to point to the entity for this separate spec\n+\n+         if Cur_Unum = Main_Unit then\n+            Main_Unit_Entity := Cunit_Entity (Unum);\n+         end if;\n+\n+      --  If we don't find the spec, then if we have a subprogram body, we\n+      --  are still OK, we just have a case of a body acting as its own spec\n+\n+      elsif Nkind (Unit (Curunit)) = N_Subprogram_Body then\n+         Set_Acts_As_Spec (Curunit, True);\n+         Set_Library_Unit (Curunit, Curunit);\n+\n+      --  Otherwise we do have an error, repeat the load request for the spec\n+      --  with Required set True to generate an appropriate error message.\n+\n+      else\n+         Unum :=\n+           Load_Unit\n+             (Load_Name  => Spec_Name,\n+              Required   => True,\n+              Subunit    => False,\n+              Error_Node => Curunit);\n+         return;\n+      end if;\n+\n+   --  If current unit is a child unit spec, load its parent\n+\n+   elsif Nkind (Unit (Curunit)) = N_Package_Declaration\n+     or else Nkind (Unit (Curunit)) =  N_Subprogram_Declaration\n+     or else Nkind (Unit (Curunit)) in N_Generic_Declaration\n+     or else Nkind (Unit (Curunit)) in N_Generic_Instantiation\n+     or else Nkind (Unit (Curunit)) in N_Renaming_Declaration\n+   then\n+      --  Turn style and validity checks off for parent unit\n+\n+      if not GNAT_Mode then\n+         Reset_Style_Check_Options;\n+         Reset_Validity_Check_Options;\n+      end if;\n+\n+      Spec_Name := Get_Parent_Spec_Name (Unit_Name (Cur_Unum));\n+\n+      if Spec_Name /= No_Name then\n+         Unum :=\n+           Load_Unit\n+             (Load_Name  => Spec_Name,\n+              Required   => True,\n+              Subunit    => False,\n+              Error_Node => Curunit);\n+\n+         if Unum /= No_Unit then\n+            Set_Parent_Spec (Unit (Curunit), Cunit (Unum));\n+         end if;\n+      end if;\n+\n+   --  If current unit is a subunit, then load its parent body\n+\n+   elsif Nkind (Unit (Curunit)) = N_Subunit then\n+      Body_Name := Get_Parent_Body_Name (Unit_Name (Cur_Unum));\n+      Unum :=\n+        Load_Unit\n+          (Load_Name  => Body_Name,\n+           Required   => True,\n+           Subunit    => True,\n+           Error_Node => Name (Unit (Curunit)));\n+\n+      if Unum /= No_Unit then\n+         Set_Library_Unit (Curunit, Cunit (Unum));\n+      end if;\n+\n+   end if;\n+\n+   --  Now we load with'ed units, with style/validity checks turned off\n+\n+   if not GNAT_Mode then\n+      Reset_Style_Check_Options;\n+      Reset_Validity_Check_Options;\n+   end if;\n+\n+   --  Loop through context items\n+\n+   Context_Node := First (Context_Items (Curunit));\n+   while Present (Context_Node) loop\n+\n+      if Nkind (Context_Node) = N_With_Clause then\n+         With_Node := Context_Node;\n+         Spec_Name := Get_Unit_Name (With_Node);\n+\n+         Unum :=\n+           Load_Unit\n+             (Load_Name  => Spec_Name,\n+              Required   => False,\n+              Subunit    => False,\n+              Error_Node => With_Node,\n+              Renamings  => True);\n+\n+         --  If we find the unit, then set spec pointer in the N_With_Clause\n+         --  to point to the compilation unit for the spec. Remember that\n+         --  the Load routine itself sets our Fatal_Error flag if the loaded\n+         --  unit gets a fatal error, so we don't need to worry about that.\n+\n+         if Unum /= No_Unit then\n+            Set_Library_Unit (With_Node, Cunit (Unum));\n+\n+         --  If the spec isn't found, then try finding the corresponding\n+         --  body, since it is possible that we have a subprogram body\n+         --  that is acting as a spec (since no spec is present).\n+\n+         else\n+            Body_Name := Get_Body_Name (Spec_Name);\n+            Unum :=\n+              Load_Unit\n+                (Load_Name  => Body_Name,\n+                 Required   => False,\n+                 Subunit    => False,\n+                 Error_Node => With_Node,\n+                 Renamings  => True);\n+\n+            --  If we got a subprogram body, then mark that we are using\n+            --  the body as a spec in the file table, and set the spec\n+            --  pointer in the N_With_Clause to point to the body entity.\n+\n+            if Unum /= No_Unit\n+              and then Nkind (Unit (Cunit (Unum))) = N_Subprogram_Body\n+            then\n+               With_Cunit := Cunit (Unum);\n+               Set_Library_Unit (With_Node, With_Cunit);\n+               Set_Acts_As_Spec (With_Cunit, True);\n+               Set_Library_Unit (With_Cunit, With_Cunit);\n+\n+            --  If we couldn't find the body, or if it wasn't a body spec\n+            --  then we are in trouble. We make one more call to Load to\n+            --  require the spec. We know it will fail of course, the\n+            --  purpose is to generate the required error message (we prefer\n+            --  that this message refer to the missing spec, not the body)\n+\n+            else\n+               Unum :=\n+                 Load_Unit\n+                   (Load_Name  => Spec_Name,\n+                    Required   => True,\n+                    Subunit    => False,\n+                    Error_Node => With_Node,\n+                    Renamings  => True);\n+\n+               --  Here we create a dummy package unit for the missing unit\n+\n+               Unum := Create_Dummy_Package_Unit (With_Node, Spec_Name);\n+               Set_Library_Unit (With_Node, Cunit (Unum));\n+            end if;\n+         end if;\n+      end if;\n+\n+      Next (Context_Node);\n+   end loop;\n+\n+   --  Restore style/validity check mode for main unit\n+\n+   Set_Style_Check_Options (Save_Style_Checks);\n+   Opt.Style_Check := Save_Style_Check;\n+   Set_Validity_Check_Options (Save_Validity_Checks);\n+   Opt.Validity_Checks_On := Save_Validity_Check;\n+end Load;"}, {"sha": "bfca40e8c18fde573708d0759751be4e94df4482", "filename": "gcc/ada/par-prag.adb", "status": "added", "additions": 950, "deletions": 0, "changes": 950, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,950 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P A R . P R A G                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.149 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Generally the parser checks the basic syntax of pragmas, but does not\n+--  do specialized syntax checks for individual pragmas, these are deferred\n+--  to semantic analysis time (see unit Sem_Prag). There are some pragmas\n+--  which require recognition and either partial or complete processing\n+--  during parsing, and this unit performs this required processing.\n+\n+with Fname.UF; use Fname.UF;\n+with Osint;    use Osint;\n+with Stringt;  use Stringt;\n+with Stylesw;  use Stylesw;\n+with Uintp;    use Uintp;\n+with Uname;    use Uname;\n+\n+separate (Par)\n+\n+function Prag (Pragma_Node : Node_Id; Semi : Source_Ptr) return Node_Id is\n+   Pragma_Name : constant Name_Id    := Chars (Pragma_Node);\n+   Pragma_Sloc : constant Source_Ptr := Sloc (Pragma_Node);\n+   Arg_Count   : Nat;\n+   Arg_Node    : Node_Id;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Arg1 return Node_Id;\n+   function Arg2 return Node_Id;\n+   function Arg3 return Node_Id;\n+   function Arg4 return Node_Id;\n+   --  Obtain specified Pragma_Argument_Association. It is allowable to call\n+   --  the routine for the argument one past the last present argument, but\n+   --  that is the only case in which a non-present argument can be referenced.\n+\n+   procedure Check_Arg_Count (Required : Int);\n+   --  Check argument count for pragma = Required.\n+   --  If not give error and raise Error_Resync.\n+\n+   procedure Check_Arg_Is_String_Literal (Arg : Node_Id);\n+   --  Check the expression of the specified argument to make sure that it\n+   --  is a string literal. If not give error and raise Error_Resync.\n+\n+   procedure Check_Arg_Is_On_Or_Off (Arg : Node_Id);\n+   --  Check the expression of the specified argument to make sure that it\n+   --  is an identifier which is either ON or OFF, and if not, then issue\n+   --  an error message and raise Error_Resync.\n+\n+   procedure Check_No_Identifier (Arg : Node_Id);\n+   --  Checks that the given argument does not have an identifier. If an\n+   --  identifier is present, then an error message is issued, and\n+   --  Error_Resync is raised.\n+\n+   procedure Check_Optional_Identifier (Arg : Node_Id; Id : Name_Id);\n+   --  Checks if the given argument has an identifier, and if so, requires\n+   --  it to match the given identifier name. If there is a non-matching\n+   --  identifier, then an error message is given and Error_Resync raised.\n+\n+   procedure Check_Required_Identifier (Arg : Node_Id; Id : Name_Id);\n+   --  Same as Check_Optional_Identifier, except that the name is required\n+   --  to be present and to match the given Id value.\n+\n+   ----------\n+   -- Arg1 --\n+   ----------\n+\n+   function Arg1 return Node_Id is\n+   begin\n+      return First (Pragma_Argument_Associations (Pragma_Node));\n+   end Arg1;\n+\n+   ----------\n+   -- Arg2 --\n+   ----------\n+\n+   function Arg2 return Node_Id is\n+   begin\n+      return Next (Arg1);\n+   end Arg2;\n+\n+   ----------\n+   -- Arg3 --\n+   ----------\n+\n+   function Arg3 return Node_Id is\n+   begin\n+      return Next (Arg2);\n+   end Arg3;\n+\n+   ----------\n+   -- Arg4 --\n+   ----------\n+\n+   function Arg4 return Node_Id is\n+   begin\n+      return Next (Arg3);\n+   end Arg4;\n+\n+   ---------------------\n+   -- Check_Arg_Count --\n+   ---------------------\n+\n+   procedure Check_Arg_Count (Required : Int) is\n+   begin\n+      if Arg_Count /= Required then\n+         Error_Msg (\"wrong number of arguments for pragma%\", Pragma_Sloc);\n+         raise Error_Resync;\n+      end if;\n+   end Check_Arg_Count;\n+\n+   ----------------------------\n+   -- Check_Arg_Is_On_Or_Off --\n+   ----------------------------\n+\n+   procedure Check_Arg_Is_On_Or_Off (Arg : Node_Id) is\n+      Argx : constant Node_Id := Expression (Arg);\n+\n+   begin\n+      if Nkind (Expression (Arg)) /= N_Identifier\n+        or else (Chars (Argx) /= Name_On\n+                   and then\n+                 Chars (Argx) /= Name_Off)\n+      then\n+         Error_Msg_Name_2 := Name_On;\n+         Error_Msg_Name_3 := Name_Off;\n+\n+         Error_Msg\n+           (\"argument for pragma% must be% or%\", Sloc (Argx));\n+         raise Error_Resync;\n+      end if;\n+   end Check_Arg_Is_On_Or_Off;\n+\n+   ---------------------------------\n+   -- Check_Arg_Is_String_Literal --\n+   ---------------------------------\n+\n+   procedure Check_Arg_Is_String_Literal (Arg : Node_Id) is\n+   begin\n+      if Nkind (Expression (Arg)) /= N_String_Literal then\n+         Error_Msg\n+           (\"argument for pragma% must be string literal\",\n+             Sloc (Expression (Arg)));\n+         raise Error_Resync;\n+      end if;\n+   end Check_Arg_Is_String_Literal;\n+\n+   -------------------------\n+   -- Check_No_Identifier --\n+   -------------------------\n+\n+   procedure Check_No_Identifier (Arg : Node_Id) is\n+   begin\n+      if Chars (Arg) /= No_Name then\n+         Error_Msg_N (\"pragma% does not permit named arguments\", Arg);\n+         raise Error_Resync;\n+      end if;\n+   end Check_No_Identifier;\n+\n+   -------------------------------\n+   -- Check_Optional_Identifier --\n+   -------------------------------\n+\n+   procedure Check_Optional_Identifier (Arg : Node_Id; Id : Name_Id) is\n+   begin\n+      if Present (Arg) and then Chars (Arg) /= No_Name then\n+         if Chars (Arg) /= Id then\n+            Error_Msg_Name_2 := Id;\n+            Error_Msg_N (\"pragma% argument expects identifier%\", Arg);\n+         end if;\n+      end if;\n+   end Check_Optional_Identifier;\n+\n+   -------------------------------\n+   -- Check_Required_Identifier --\n+   -------------------------------\n+\n+   procedure Check_Required_Identifier (Arg : Node_Id; Id : Name_Id) is\n+   begin\n+      if Chars (Arg) /= Id then\n+         Error_Msg_Name_2 := Id;\n+         Error_Msg_N (\"pragma% argument must have identifier%\", Arg);\n+      end if;\n+   end Check_Required_Identifier;\n+\n+   ----------\n+   -- Prag --\n+   ----------\n+\n+begin\n+   Error_Msg_Name_1 := Pragma_Name;\n+\n+   --  Count number of arguments. This loop also checks if any of the arguments\n+   --  are Error, indicating a syntax error as they were parsed. If so, we\n+   --  simply return, because we get into trouble with cascaded errors if we\n+   --  try to perform our error checks on junk arguments.\n+\n+   Arg_Count := 0;\n+\n+   if Present (Pragma_Argument_Associations (Pragma_Node)) then\n+      Arg_Node := Arg1;\n+\n+      while Arg_Node /= Empty loop\n+         Arg_Count := Arg_Count + 1;\n+\n+         if Expression (Arg_Node) = Error then\n+            return Error;\n+         end if;\n+\n+         Next (Arg_Node);\n+      end loop;\n+   end if;\n+\n+   --  Remaining processing is pragma dependent\n+\n+   case Get_Pragma_Id (Pragma_Name) is\n+\n+      ------------\n+      -- Ada_83 --\n+      ------------\n+\n+      --  This pragma must be processed at parse time, since we want to set\n+      --  the Ada 83 and Ada 95 switches properly at parse time to recognize\n+      --  Ada 83 syntax or Ada 95 syntax as appropriate.\n+\n+      when Pragma_Ada_83 =>\n+         Ada_83 := True;\n+         Ada_95 := False;\n+\n+      ------------\n+      -- Ada_95 --\n+      ------------\n+\n+      --  This pragma must be processed at parse time, since we want to set\n+      --  the Ada 83 and Ada_95 switches properly at parse time to recognize\n+      --  Ada 83 syntax or Ada 95 syntax as appropriate.\n+\n+      when Pragma_Ada_95 =>\n+         Ada_83 := False;\n+         Ada_95 := True;\n+\n+      -----------\n+      -- Debug --\n+      -----------\n+\n+      --  pragma Debug (PROCEDURE_CALL_STATEMENT);\n+\n+      --  This has to be processed by the parser because of the very peculiar\n+      --  form of the second parameter, which is syntactically from a formal\n+      --  point of view a function call (since it must be an expression), but\n+      --  semantically we treat it as a procedure call (which has exactly the\n+      --  same syntactic form, so that's why we can get away with this!)\n+\n+      when Pragma_Debug =>\n+         Check_Arg_Count (1);\n+         Check_No_Identifier (Arg1);\n+\n+         declare\n+            Expr : constant Node_Id := New_Copy (Expression (Arg1));\n+\n+         begin\n+            if Nkind (Expr) /= N_Indexed_Component\n+              and then Nkind (Expr) /= N_Function_Call\n+              and then Nkind (Expr) /= N_Identifier\n+              and then Nkind (Expr) /= N_Selected_Component\n+            then\n+               Error_Msg\n+                 (\"argument of pragma% is not procedure call\", Sloc (Expr));\n+               raise Error_Resync;\n+            else\n+               Set_Debug_Statement\n+                 (Pragma_Node, P_Statement_Name (Expr));\n+            end if;\n+         end;\n+\n+      -------------------------------\n+      -- Extensions_Allowed (GNAT) --\n+      -------------------------------\n+\n+      --  pragma Extensions_Allowed (Off | On)\n+\n+      --  The processing for pragma Extensions_Allowed must be done at\n+      --  parse time, since extensions mode may affect what is accepted.\n+\n+      when Pragma_Extensions_Allowed =>\n+         Check_Arg_Count (1);\n+         Check_No_Identifier (Arg1);\n+         Check_Arg_Is_On_Or_Off (Arg1);\n+         Opt.Extensions_Allowed := (Chars (Expression (Arg1)) = Name_On);\n+\n+      ----------------\n+      -- List (2.8) --\n+      ----------------\n+\n+      --  pragma List (Off | On)\n+\n+      --  The processing for pragma List must be done at parse time,\n+      --  since a listing can be generated in parse only mode.\n+\n+      when Pragma_List =>\n+         Check_Arg_Count (1);\n+         Check_No_Identifier (Arg1);\n+         Check_Arg_Is_On_Or_Off (Arg1);\n+\n+         --  We unconditionally make a List_On entry for the pragma, so that\n+         --  in the List (Off) case, the pragma will print even in a region\n+         --  of code with listing turned off (this is required!)\n+\n+         List_Pragmas.Increment_Last;\n+         List_Pragmas.Table (List_Pragmas.Last) :=\n+           (Ptyp => List_On, Ploc => Sloc (Pragma_Node));\n+\n+         --  Now generate the list off entry for pragma List (Off)\n+\n+         if Chars (Expression (Arg1)) = Name_Off then\n+            List_Pragmas.Increment_Last;\n+            List_Pragmas.Table (List_Pragmas.Last) :=\n+              (Ptyp => List_Off, Ploc => Semi);\n+         end if;\n+\n+      ----------------\n+      -- Page (2.8) --\n+      ----------------\n+\n+      --  pragma Page;\n+\n+      --  Processing for this pragma must be done at parse time, since a\n+      --  listing can be generated in parse only mode with semantics off.\n+\n+      when Pragma_Page =>\n+         Check_Arg_Count (0);\n+         List_Pragmas.Increment_Last;\n+         List_Pragmas.Table (List_Pragmas.Last) := (Page, Semi);\n+\n+      -----------------------------\n+      -- Source_File_Name (GNAT) --\n+      -----------------------------\n+\n+      --  There are five forms of this pragma:\n+\n+      --  pragma Source_File_Name (\n+      --    [UNIT_NAME      =>] unit_NAME,\n+      --     BODY_FILE_NAME =>  STRING_LITERAL);\n+\n+      --  pragma Source_File_Name (\n+      --    [UNIT_NAME      =>] unit_NAME,\n+      --     SPEC_FILE_NAME =>  STRING_LITERAL);\n+\n+      --  pragma Source_File_Name (\n+      --     BODY_FILE_NAME  => STRING_LITERAL\n+      --  [, DOT_REPLACEMENT => STRING_LITERAL]\n+      --  [, CASING          => CASING_SPEC]);\n+\n+      --  pragma Source_File_Name (\n+      --     SPEC_FILE_NAME  => STRING_LITERAL\n+      --  [, DOT_REPLACEMENT => STRING_LITERAL]\n+      --  [, CASING          => CASING_SPEC]);\n+\n+      --  pragma Source_File_Name (\n+      --     SUBUNIT_FILE_NAME  => STRING_LITERAL\n+      --  [, DOT_REPLACEMENT    => STRING_LITERAL]\n+      --  [, CASING             => CASING_SPEC]);\n+\n+      --  CASING_SPEC ::= Uppercase | Lowercase | Mixedcase\n+\n+      --  Note: we process this during parsing, since we need to have the\n+      --  source file names set well before the semantic analysis starts,\n+      --  since we load the spec and with'ed packages before analysis.\n+\n+      when Pragma_Source_File_Name => Source_File_Name : declare\n+         Unam  : Unit_Name_Type;\n+         Expr1 : Node_Id;\n+         Pat   : String_Ptr;\n+         Typ   : Character;\n+         Dot   : String_Ptr;\n+         Cas   : Casing_Type;\n+         Nast  : Nat;\n+\n+         function Get_Fname (Arg : Node_Id) return Name_Id;\n+         --  Process file name from unit name form of pragma\n+\n+         function Get_String_Argument (Arg : Node_Id) return String_Ptr;\n+         --  Process string literal value from argument\n+\n+         procedure Process_Casing (Arg : Node_Id);\n+         --  Process Casing argument of pattern form of pragma\n+\n+         procedure Process_Dot_Replacement (Arg : Node_Id);\n+         --  Process Dot_Replacement argument of patterm form of pragma\n+\n+         ---------------\n+         -- Get_Fname --\n+         ---------------\n+\n+         function Get_Fname (Arg : Node_Id) return Name_Id is\n+         begin\n+            String_To_Name_Buffer (Strval (Expression (Arg)));\n+\n+            for J in 1 .. Name_Len loop\n+               if Is_Directory_Separator (Name_Buffer (J)) then\n+                  Error_Msg\n+                    (\"directory separator character not allowed\",\n+                     Sloc (Expression (Arg)) + Source_Ptr (J));\n+               end if;\n+            end loop;\n+\n+            return Name_Find;\n+         end Get_Fname;\n+\n+         -------------------------\n+         -- Get_String_Argument --\n+         -------------------------\n+\n+         function Get_String_Argument (Arg : Node_Id) return String_Ptr is\n+            Str : String_Id;\n+\n+         begin\n+            if Nkind (Expression (Arg)) /= N_String_Literal\n+              and then\n+               Nkind (Expression (Arg)) /= N_Operator_Symbol\n+            then\n+               Error_Msg_N\n+                 (\"argument for pragma% must be string literal\", Arg);\n+               raise Error_Resync;\n+            end if;\n+\n+            Str := Strval (Expression (Arg));\n+\n+            --  Check string has no wide chars\n+\n+            for J in 1 .. String_Length (Str) loop\n+               if Get_String_Char (Str, J) > 255 then\n+                  Error_Msg\n+                    (\"wide character not allowed in pattern for pragma%\",\n+                     Sloc (Expression (Arg2)) + Text_Ptr (J) - 1);\n+               end if;\n+            end loop;\n+\n+            --  Acquire string\n+\n+            String_To_Name_Buffer (Str);\n+            return new String'(Name_Buffer (1 .. Name_Len));\n+         end Get_String_Argument;\n+\n+         --------------------\n+         -- Process_Casing --\n+         --------------------\n+\n+         procedure Process_Casing (Arg : Node_Id) is\n+            Expr : constant Node_Id := Expression (Arg);\n+\n+         begin\n+            Check_Required_Identifier (Arg, Name_Casing);\n+\n+            if Nkind (Expr) = N_Identifier then\n+               if Chars (Expr) = Name_Lowercase then\n+                  Cas := All_Lower_Case;\n+                  return;\n+               elsif Chars (Expr) = Name_Uppercase then\n+                  Cas := All_Upper_Case;\n+                  return;\n+               elsif Chars (Expr) = Name_Mixedcase then\n+                  Cas := Mixed_Case;\n+                  return;\n+               end if;\n+            end if;\n+\n+            Error_Msg_N\n+              (\"Casing argument for pragma% must be \" &\n+               \"one of Mixedcase, Lowercase, Uppercase\",\n+               Arg);\n+         end Process_Casing;\n+\n+         -----------------------------\n+         -- Process_Dot_Replacement --\n+         -----------------------------\n+\n+         procedure Process_Dot_Replacement (Arg : Node_Id) is\n+         begin\n+            Check_Required_Identifier (Arg, Name_Dot_Replacement);\n+            Dot := Get_String_Argument (Arg);\n+         end Process_Dot_Replacement;\n+\n+      --  Start of processing for Source_File_Name pragma\n+\n+      begin\n+         --  We permit from 1 to 3 arguments\n+\n+         if Arg_Count not in 1 .. 3 then\n+            Check_Arg_Count (1);\n+         end if;\n+\n+         Expr1 := Expression (Arg1);\n+\n+         --  If first argument is identifier or selected component, then\n+         --  we have the specific file case of the Source_File_Name pragma,\n+         --  and the first argument is a unit name.\n+\n+         if Nkind (Expr1) = N_Identifier\n+           or else\n+             (Nkind (Expr1) = N_Selected_Component\n+               and then\n+              Nkind (Selector_Name (Expr1)) = N_Identifier)\n+         then\n+            Check_Arg_Count (2);\n+\n+            Check_Optional_Identifier (Arg1, Name_Unit_Name);\n+            Unam := Get_Unit_Name (Expr1);\n+\n+            Check_Arg_Is_String_Literal (Arg2);\n+\n+            if Chars (Arg2) = Name_Spec_File_Name then\n+               Set_File_Name (Get_Spec_Name (Unam), Get_Fname (Arg2));\n+\n+            elsif Chars (Arg2) = Name_Body_File_Name then\n+               Set_File_Name (Unam, Get_Fname (Arg2));\n+\n+            else\n+               Error_Msg_N (\"pragma% argument has incorrect identifier\", Arg2);\n+               return Pragma_Node;\n+            end if;\n+\n+         --  If the first argument is not an identifier, then we must have\n+         --  the pattern form of the pragma, and the first argument must be\n+         --  the pattern string with an appropriate name.\n+\n+         else\n+            if Chars (Arg1) = Name_Spec_File_Name then\n+               Typ := 's';\n+\n+            elsif Chars (Arg1) = Name_Body_File_Name then\n+               Typ := 'b';\n+\n+            elsif Chars (Arg1) = Name_Subunit_File_Name then\n+               Typ := 'u';\n+\n+            elsif Chars (Arg1) = Name_Unit_Name then\n+               Error_Msg_N\n+                 (\"Unit_Name parameter for pragma% must be an identifier\",\n+                  Arg1);\n+               raise Error_Resync;\n+\n+            else\n+               Error_Msg_N (\"pragma% argument has incorrect identifier\", Arg1);\n+               raise Error_Resync;\n+            end if;\n+\n+            Pat := Get_String_Argument (Arg1);\n+\n+            --  Check pattern has exactly one asterisk\n+\n+            Nast := 0;\n+            for J in Pat'Range loop\n+               if Pat (J) = '*' then\n+                  Nast := Nast + 1;\n+               end if;\n+            end loop;\n+\n+            if Nast /= 1 then\n+               Error_Msg_N\n+                 (\"file name pattern must have exactly one * character\",\n+                  Arg2);\n+               return Pragma_Node;\n+            end if;\n+\n+            --  Set defaults for Casing and Dot_Separator parameters\n+\n+            Cas := All_Lower_Case;\n+\n+            Dot := new String'(\".\");\n+\n+            --  Process second and third arguments if present\n+\n+            if Arg_Count > 1 then\n+               if Chars (Arg2) = Name_Casing then\n+                  Process_Casing (Arg2);\n+\n+                  if Arg_Count = 3 then\n+                     Process_Dot_Replacement (Arg3);\n+                  end if;\n+\n+               else\n+                  Process_Dot_Replacement (Arg2);\n+\n+                  if Arg_Count = 3 then\n+                     Process_Casing (Arg3);\n+                  end if;\n+               end if;\n+            end if;\n+\n+            Set_File_Name_Pattern (Pat, Typ, Dot, Cas);\n+         end if;\n+      end Source_File_Name;\n+\n+      -----------------------------\n+      -- Source_Reference (GNAT) --\n+      -----------------------------\n+\n+      --  pragma Source_Reference\n+      --    (INTEGER_LITERAL [, STRING_LITERAL] );\n+\n+      --  Processing for this pragma must be done at parse time, since error\n+      --  messages needing the proper line numbers can be generated in parse\n+      --  only mode with semantic checking turned off, and indeed we usually\n+      --  turn off semantic checking anyway if any parse errors are found.\n+\n+      when Pragma_Source_Reference => Source_Reference : declare\n+         Fname : Name_Id;\n+\n+      begin\n+         if Arg_Count /= 1 then\n+            Check_Arg_Count (2);\n+            Check_No_Identifier (Arg2);\n+         end if;\n+\n+         --  Check that this is first line of file. We skip this test if\n+         --  we are in syntax check only mode, since we may be dealing with\n+         --  multiple compilation units.\n+\n+         if Get_Physical_Line_Number (Pragma_Sloc) /= 1\n+           and then Num_SRef_Pragmas (Current_Source_File) = 0\n+           and then Operating_Mode /= Check_Syntax\n+         then\n+            Error_Msg\n+              (\"first % pragma must be first line of file\", Pragma_Sloc);\n+            raise Error_Resync;\n+         end if;\n+\n+         Check_No_Identifier (Arg1);\n+\n+         if Arg_Count = 1 then\n+            if Num_SRef_Pragmas (Current_Source_File) = 0 then\n+               Error_Msg\n+                 (\"file name required for first % pragma in file\",\n+                  Pragma_Sloc);\n+               raise Error_Resync;\n+\n+            else\n+               Fname := No_Name;\n+            end if;\n+\n+         --  File name present\n+\n+         else\n+            Check_Arg_Is_String_Literal (Arg2);\n+            String_To_Name_Buffer (Strval (Expression (Arg2)));\n+            Fname := Name_Find;\n+\n+            if Num_SRef_Pragmas (Current_Source_File) > 0 then\n+               if Fname /= Full_Ref_Name (Current_Source_File) then\n+                  Error_Msg\n+                    (\"file name must be same in all % pragmas\", Pragma_Sloc);\n+                  raise Error_Resync;\n+               end if;\n+            end if;\n+         end if;\n+\n+         if Nkind (Expression (Arg1)) /= N_Integer_Literal then\n+            Error_Msg\n+              (\"argument for pragma% must be integer literal\",\n+                Sloc (Expression (Arg1)));\n+            raise Error_Resync;\n+\n+         --  OK, this source reference pragma is effective, however, we\n+         --  ignore it if it is not in the first unit in the multiple unit\n+         --  case. This is because the only purpose in this case is to\n+         --  provide source pragmas for subsequent use by gnatchop.\n+\n+         else\n+            if Num_Library_Units = 1 then\n+               Register_Source_Ref_Pragma\n+                 (Fname,\n+                  Strip_Directory (Fname),\n+                  UI_To_Int (Intval (Expression (Arg1))),\n+                  Get_Physical_Line_Number (Pragma_Sloc) + 1);\n+            end if;\n+         end if;\n+      end Source_Reference;\n+\n+      -------------------------\n+      -- Style_Checks (GNAT) --\n+      -------------------------\n+\n+      --  pragma Style_Checks (On | Off | ALL_CHECKS | STRING_LITERAL);\n+\n+      --  This is processed by the parser since some of the style\n+      --  checks take place during source scanning and parsing.\n+\n+      when Pragma_Style_Checks => Style_Checks : declare\n+         A  : Node_Id;\n+         S  : String_Id;\n+         C  : Char_Code;\n+         OK : Boolean := True;\n+\n+      begin\n+         --  Two argument case is only for semantics\n+\n+         if Arg_Count = 2 then\n+            null;\n+\n+         else\n+            Check_Arg_Count (1);\n+            Check_No_Identifier (Arg1);\n+            A := Expression (Arg1);\n+\n+            if Nkind (A) = N_String_Literal then\n+               S   := Strval (A);\n+\n+               declare\n+                  Slen    : Natural := Natural (String_Length (S));\n+                  Options : String (1 .. Slen);\n+                  J       : Natural;\n+                  Ptr     : Natural;\n+\n+               begin\n+                  J := 1;\n+                  loop\n+                     C := Get_String_Char (S, Int (J));\n+\n+                     if not In_Character_Range (C) then\n+                        OK := False;\n+                        Ptr := J;\n+                        exit;\n+\n+                     else\n+                        Options (J) := Get_Character (C);\n+                     end if;\n+\n+                     if J = Slen then\n+                        Set_Style_Check_Options (Options, OK, Ptr);\n+                        exit;\n+\n+                     else\n+                        J := J + 1;\n+                     end if;\n+                  end loop;\n+\n+                  if not OK then\n+                     Error_Msg\n+                       (\"invalid style check option\",\n+                        Sloc (Expression (Arg1)) + Source_Ptr (Ptr));\n+                     raise Error_Resync;\n+                  end if;\n+               end;\n+\n+            elsif Nkind (A) /= N_Identifier then\n+               OK := False;\n+\n+            elsif Chars (A) = Name_All_Checks then\n+               Stylesw.Set_Default_Style_Check_Options;\n+\n+            elsif Chars (A) = Name_On then\n+               Style_Check := True;\n+\n+            elsif Chars (A) = Name_Off then\n+               Style_Check := False;\n+\n+            else\n+               OK := False;\n+            end if;\n+\n+            if not OK then\n+               Error_Msg (\"incorrect argument for pragma%\", Sloc (A));\n+               raise Error_Resync;\n+            end if;\n+         end if;\n+      end Style_Checks;\n+\n+      ---------------------\n+      -- Warnings (GNAT) --\n+      ---------------------\n+\n+      --  pragma Warnings (On | Off, [LOCAL_NAME])\n+\n+      --  The one argument case is processed by the parser, since it may\n+      --  control parser warnings as well as semantic warnings, and in any\n+      --  case we want to be absolutely sure that the range in the warnings\n+      --  table is set well before any semantic analysis is performed.\n+\n+      when Pragma_Warnings =>\n+         if Arg_Count = 1 then\n+            Check_No_Identifier (Arg1);\n+            Check_Arg_Is_On_Or_Off (Arg1);\n+\n+            if Chars (Expression (Arg1)) = Name_On then\n+               Set_Warnings_Mode_On (Pragma_Sloc);\n+            else\n+               Set_Warnings_Mode_Off (Pragma_Sloc);\n+            end if;\n+         end if;\n+\n+      -----------------------\n+      -- All Other Pragmas --\n+      -----------------------\n+\n+      --  For all other pragmas, checking and processing is handled\n+      --  entirely in Sem_Prag, and no further checking is done by Par.\n+\n+      when Pragma_Abort_Defer              |\n+           Pragma_AST_Entry                |\n+           Pragma_All_Calls_Remote         |\n+           Pragma_Annotate                 |\n+           Pragma_Assert                   |\n+           Pragma_Asynchronous             |\n+           Pragma_Atomic                   |\n+           Pragma_Atomic_Components        |\n+           Pragma_Attach_Handler           |\n+           Pragma_CPP_Class                |\n+           Pragma_CPP_Constructor          |\n+           Pragma_CPP_Virtual              |\n+           Pragma_CPP_Vtable               |\n+           Pragma_C_Pass_By_Copy           |\n+           Pragma_Comment                  |\n+           Pragma_Common_Object            |\n+           Pragma_Complex_Representation   |\n+           Pragma_Component_Alignment      |\n+           Pragma_Controlled               |\n+           Pragma_Convention               |\n+           Pragma_Discard_Names            |\n+           Pragma_Eliminate                |\n+           Pragma_Elaborate                |\n+           Pragma_Elaborate_All            |\n+           Pragma_Elaborate_Body           |\n+           Pragma_Elaboration_Checks       |\n+           Pragma_Export                   |\n+           Pragma_Export_Exception         |\n+           Pragma_Export_Function          |\n+           Pragma_Export_Object            |\n+           Pragma_Export_Procedure         |\n+           Pragma_Export_Valued_Procedure  |\n+           Pragma_Extend_System            |\n+           Pragma_External_Name_Casing     |\n+           Pragma_Finalize_Storage_Only    |\n+           Pragma_Float_Representation     |\n+           Pragma_Ident                    |\n+           Pragma_Import                   |\n+           Pragma_Import_Exception         |\n+           Pragma_Import_Function          |\n+           Pragma_Import_Object            |\n+           Pragma_Import_Procedure         |\n+           Pragma_Import_Valued_Procedure  |\n+           Pragma_Initialize_Scalars       |\n+           Pragma_Inline                   |\n+           Pragma_Inline_Always            |\n+           Pragma_Inline_Generic           |\n+           Pragma_Inspection_Point         |\n+           Pragma_Interface                |\n+           Pragma_Interface_Name           |\n+           Pragma_Interrupt_Handler        |\n+           Pragma_Interrupt_Priority       |\n+           Pragma_Java_Constructor         |\n+           Pragma_Java_Interface           |\n+           Pragma_License                  |\n+           Pragma_Link_With                |\n+           Pragma_Linker_Alias             |\n+           Pragma_Linker_Options           |\n+           Pragma_Linker_Section           |\n+           Pragma_Locking_Policy           |\n+           Pragma_Long_Float               |\n+           Pragma_Machine_Attribute        |\n+           Pragma_Main                     |\n+           Pragma_Main_Storage             |\n+           Pragma_Memory_Size              |\n+           Pragma_No_Return                |\n+           Pragma_No_Run_Time              |\n+           Pragma_Normalize_Scalars        |\n+           Pragma_Optimize                 |\n+           Pragma_Pack                     |\n+           Pragma_Passive                  |\n+           Pragma_Polling                  |\n+           Pragma_Preelaborate             |\n+           Pragma_Priority                 |\n+           Pragma_Propagate_Exceptions     |\n+           Pragma_Psect_Object             |\n+           Pragma_Pure                     |\n+           Pragma_Pure_Function            |\n+           Pragma_Queuing_Policy           |\n+           Pragma_Remote_Call_Interface    |\n+           Pragma_Remote_Types             |\n+           Pragma_Restrictions             |\n+           Pragma_Restricted_Run_Time      |\n+           Pragma_Ravenscar                |\n+           Pragma_Reviewable               |\n+           Pragma_Share_Generic            |\n+           Pragma_Shared                   |\n+           Pragma_Shared_Passive           |\n+           Pragma_Storage_Size             |\n+           Pragma_Storage_Unit             |\n+           Pragma_Stream_Convert           |\n+           Pragma_Subtitle                 |\n+           Pragma_Suppress                 |\n+           Pragma_Suppress_All             |\n+           Pragma_Suppress_Debug_Info      |\n+           Pragma_Suppress_Initialization  |\n+           Pragma_System_Name              |\n+           Pragma_Task_Dispatching_Policy  |\n+           Pragma_Task_Info                |\n+           Pragma_Task_Name                |\n+           Pragma_Task_Storage             |\n+           Pragma_Time_Slice               |\n+           Pragma_Title                    |\n+           Pragma_Unchecked_Union          |\n+           Pragma_Unimplemented_Unit       |\n+           Pragma_Unreserve_All_Interrupts |\n+           Pragma_Unsuppress               |\n+           Pragma_Use_VADS_Size            |\n+           Pragma_Volatile                 |\n+           Pragma_Volatile_Components      |\n+           Pragma_Weak_External            |\n+           Pragma_Validity_Checks          =>\n+         null;\n+\n+   end case;\n+\n+   return Pragma_Node;\n+\n+   --------------------\n+   -- Error Handling --\n+   --------------------\n+\n+exception\n+   when Error_Resync =>\n+      return Error;\n+\n+end Prag;"}, {"sha": "d1ba793d9cd86216d25eb052f4aeb1469430ede3", "filename": "gcc/ada/par-sync.adb", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-sync.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-sync.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-sync.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,312 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P A R . S Y N C                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.19 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+separate (Par)\n+package body Sync is\n+\n+   procedure Resync_Init;\n+   --  This routine is called on initiating a resynchronization action\n+\n+   procedure Resync_Resume;\n+   --  This routine is called on completing a resynchronization action\n+\n+   -------------------\n+   -- Resync_Choice --\n+   -------------------\n+\n+   procedure Resync_Choice is\n+   begin\n+      Resync_Init;\n+\n+      --  Loop till we get a token that terminates a choice. Note that EOF is\n+      --  one such token, so we are sure to get out of this loop eventually!\n+\n+      while Token not in Token_Class_Cterm loop\n+         Scan;\n+      end loop;\n+\n+      Resync_Resume;\n+   end Resync_Choice;\n+\n+   ------------------\n+   -- Resync_Cunit --\n+   ------------------\n+\n+   procedure Resync_Cunit is\n+   begin\n+      Resync_Init;\n+\n+      while Token not in Token_Class_Cunit\n+        and then Token /= Tok_EOF\n+      loop\n+         Scan;\n+      end loop;\n+\n+      Resync_Resume;\n+   end Resync_Cunit;\n+\n+   -----------------------\n+   -- Resync_Expression --\n+   -----------------------\n+\n+   procedure Resync_Expression is\n+      Paren_Count : Int;\n+\n+   begin\n+      Resync_Init;\n+      Paren_Count := 0;\n+\n+      loop\n+         --  Terminating tokens are those in class Eterm and also RANGE,\n+         --  DIGITS or DELTA if not preceded by an apostrophe (if they are\n+         --  preceded by an apostrophe, then they are attributes). In addiion,\n+         --  at the outer parentheses level only, we also consider a comma,\n+         --  right parenthesis or vertical bar to terminate an expression.\n+\n+         if Token in Token_Class_Eterm\n+\n+           or else (Token in Token_Class_Atkwd\n+                     and then Prev_Token /= Tok_Apostrophe)\n+\n+           or else (Paren_Count = 0\n+                     and then\n+                       (Token = Tok_Comma\n+                         or else Token = Tok_Right_Paren\n+                         or else Token = Tok_Vertical_Bar))\n+         then\n+            --  A special check: if we stop on the ELSE of OR ELSE or the\n+            --  THEN of AND THEN, keep going, because this is not really an\n+            --  expression terminator after all. Also, keep going past WITH\n+            --  since this can be part of an extension aggregate\n+\n+            if (Token = Tok_Else and then Prev_Token = Tok_Or)\n+               or else (Token = Tok_Then and then Prev_Token = Tok_And)\n+               or else Token = Tok_With\n+            then\n+               null;\n+            else\n+               exit;\n+            end if;\n+         end if;\n+\n+         if Token = Tok_Left_Paren then\n+            Paren_Count := Paren_Count + 1;\n+\n+         elsif Token = Tok_Right_Paren then\n+            Paren_Count := Paren_Count - 1;\n+\n+         end if;\n+\n+         Scan; -- past token to be skipped\n+      end loop;\n+\n+      Resync_Resume;\n+   end Resync_Expression;\n+\n+   -----------------\n+   -- Resync_Init --\n+   -----------------\n+\n+   procedure Resync_Init is\n+   begin\n+      --  The following check makes sure we do not get stuck in an infinite\n+      --  loop resynchonizing and getting nowhere. If we are called to do a\n+      --  resynchronize and we are exactly at the same point that we left off\n+      --  on the last resynchronize call, then we force at least one token to\n+      --  be skipped so that we make progress!\n+\n+      if Token_Ptr = Last_Resync_Point then\n+         Scan; -- to skip at least one token\n+      end if;\n+\n+      --  Output extra error message if debug R flag is set\n+\n+      if Debug_Flag_R then\n+         Error_Msg_SC (\"resynchronizing!\");\n+      end if;\n+   end Resync_Init;\n+\n+   ---------------------------\n+   -- Resync_Past_Semicolon --\n+   ---------------------------\n+\n+   procedure Resync_Past_Semicolon is\n+   begin\n+      Resync_Init;\n+\n+      loop\n+         --  Done if we are at a semicolon\n+\n+         if Token = Tok_Semicolon then\n+            Scan; -- past semicolon\n+            exit;\n+\n+         --  Done if we are at a token which normally appears only after\n+         --  a semicolon. One special glitch is that the keyword private is\n+         --  in this category only if it does NOT appear after WITH.\n+\n+         elsif Token in Token_Class_After_SM\n+            and then (Token /= Tok_Private or else Prev_Token /= Tok_With)\n+         then\n+            exit;\n+\n+         --  Otherwise keep going\n+\n+         else\n+            Scan;\n+         end if;\n+      end loop;\n+\n+      --  Fall out of loop with resyncrhonization complete\n+\n+      Resync_Resume;\n+   end Resync_Past_Semicolon;\n+\n+   ----------------------------------------------\n+   -- Resync_Past_Semicolon_Or_To_Loop_Or_Then --\n+   ----------------------------------------------\n+\n+   procedure Resync_Past_Semicolon_Or_To_Loop_Or_Then is\n+   begin\n+      Resync_Init;\n+\n+      loop\n+         --  Done if at semicolon\n+\n+         if Token = Tok_Semicolon then\n+            Scan; -- past the semicolon\n+            exit;\n+\n+         --  Done if we are at a token which normally appears only after\n+         --  a semicolon. One special glitch is that the keyword private is\n+         --  in this category only if it does NOT appear after WITH.\n+\n+         elsif (Token in Token_Class_After_SM\n+                  and then (Token /= Tok_Private\n+                              or else Prev_Token /= Tok_With))\n+         then\n+            exit;\n+\n+         --  Done if we are at THEN or LOOP\n+\n+         elsif Token = Tok_Then or else Token = Tok_Loop then\n+            exit;\n+\n+         --  Otherwise keep going\n+\n+         else\n+            Scan;\n+         end if;\n+      end loop;\n+\n+      --  Fall out of loop with resyncrhonization complete\n+\n+      Resync_Resume;\n+   end Resync_Past_Semicolon_Or_To_Loop_Or_Then;\n+\n+   -------------------\n+   -- Resync_Resume --\n+   -------------------\n+\n+   procedure Resync_Resume is\n+   begin\n+      --  Save resync point (see special test in Resync_Init)\n+\n+      Last_Resync_Point := Token_Ptr;\n+\n+      if Debug_Flag_R then\n+         Error_Msg_SC (\"resuming here!\");\n+      end if;\n+   end Resync_Resume;\n+\n+   --------------------\n+   -- Resync_To_When --\n+   --------------------\n+\n+   procedure Resync_To_When is\n+   begin\n+      Resync_Init;\n+\n+      loop\n+         --  Done if at semicolon, WHEN or IS\n+\n+         if Token = Tok_Semicolon\n+           or else Token = Tok_When\n+           or else Token = Tok_Is\n+         then\n+            exit;\n+\n+         --  Otherwise keep going\n+\n+         else\n+            Scan;\n+         end if;\n+      end loop;\n+\n+      --  Fall out of loop with resyncrhonization complete\n+\n+      Resync_Resume;\n+   end Resync_To_When;\n+\n+   ---------------------------\n+   -- Resync_Semicolon_List --\n+   ---------------------------\n+\n+   procedure Resync_Semicolon_List is\n+      Paren_Count : Int;\n+\n+   begin\n+      Resync_Init;\n+      Paren_Count := 0;\n+\n+      loop\n+         if Token = Tok_EOF\n+           or else Token = Tok_Semicolon\n+           or else Token = Tok_Is\n+           or else Token in Token_Class_After_SM\n+         then\n+            exit;\n+\n+         elsif Token = Tok_Left_Paren then\n+            Paren_Count := Paren_Count + 1;\n+\n+         elsif Token = Tok_Right_Paren then\n+            if Paren_Count = 0 then\n+               exit;\n+            else\n+               Paren_Count := Paren_Count - 1;\n+            end if;\n+         end if;\n+\n+         Scan;\n+      end loop;\n+\n+      Resync_Resume;\n+   end Resync_Semicolon_List;\n+\n+end Sync;"}, {"sha": "4d49e7af7385261ca858665f6b1a247978adc2d2", "filename": "gcc/ada/par-tchk.adb", "status": "added", "additions": 812, "deletions": 0, "changes": 812, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-tchk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-tchk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-tchk.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,812 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P A R . T C H K                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.37 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Token scan routines.\n+\n+--  Error recovery: none of the T_xxx or TF_xxx routines raise Error_Resync\n+\n+separate (Par)\n+package body Tchk is\n+\n+   type Position is (SC, BC, AP);\n+   --  Specify position of error message (see Error_Msg_SC/BC/AP)\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Check_Token (T : Token_Type; P : Position);\n+   pragma Inline (Check_Token);\n+   --  Called by T_xx routines to check for reserved keyword token. P is the\n+   --  position of the error message if the token is missing (see Wrong_Token)\n+\n+   procedure Wrong_Token (T : Token_Type; P : Position);\n+   --  Called when scanning a reserved keyword when the keyword is not\n+   --  present. T is the token type for the keyword, and P indicates the\n+   --  position to be used to place a message relative to the current\n+   --  token if the keyword is not located nearby.\n+\n+   -----------------\n+   -- Check_Token --\n+   -----------------\n+\n+   procedure Check_Token (T : Token_Type; P : Position) is\n+   begin\n+      if Token = T then\n+         Scan;\n+         return;\n+      else\n+         Wrong_Token (T, P);\n+      end if;\n+   end Check_Token;\n+\n+   -------------\n+   -- T_Abort --\n+   -------------\n+\n+   procedure T_Abort is\n+   begin\n+      Check_Token (Tok_Abort, SC);\n+   end T_Abort;\n+\n+   -------------\n+   -- T_Arrow --\n+   -------------\n+\n+   procedure T_Arrow is\n+   begin\n+      if Token = Tok_Arrow then\n+         Scan;\n+\n+      --  A little recovery helper, accept then in place of =>\n+\n+      elsif Token = Tok_Then then\n+         Error_Msg_BC (\"missing \"\"=>\"\"\");\n+         Scan; -- past THEN used in place of =>\n+\n+      elsif Token = Tok_Colon_Equal then\n+         Error_Msg_SC (\"\"\":=\"\" should be \"\"=>\"\"\");\n+         Scan; -- past := used in place of =>\n+\n+      else\n+         Error_Msg_AP (\"missing \"\"=>\"\"\");\n+      end if;\n+   end T_Arrow;\n+\n+   ----------\n+   -- T_At --\n+   ----------\n+\n+   procedure T_At is\n+   begin\n+      Check_Token (Tok_At, SC);\n+   end T_At;\n+\n+   ------------\n+   -- T_Body --\n+   ------------\n+\n+   procedure T_Body is\n+   begin\n+      Check_Token (Tok_Body, BC);\n+   end T_Body;\n+\n+   -----------\n+   -- T_Box --\n+   -----------\n+\n+   procedure T_Box is\n+   begin\n+      if Token = Tok_Box then\n+         Scan;\n+      else\n+         Error_Msg_AP (\"missing \"\"<>\"\"\");\n+      end if;\n+   end T_Box;\n+\n+   -------------\n+   -- T_Colon --\n+   -------------\n+\n+   procedure T_Colon is\n+   begin\n+      if Token = Tok_Colon then\n+         Scan;\n+      else\n+         Error_Msg_AP (\"missing \"\":\"\"\");\n+      end if;\n+   end T_Colon;\n+\n+   -------------------\n+   -- T_Colon_Equal --\n+   -------------------\n+\n+   procedure T_Colon_Equal is\n+   begin\n+      if Token = Tok_Colon_Equal then\n+         Scan;\n+\n+      elsif Token = Tok_Equal then\n+         Error_Msg_SC (\"\"\"=\"\" should be \"\":=\"\"\");\n+         Scan;\n+\n+      elsif Token = Tok_Colon then\n+         Error_Msg_SC (\"\"\":\"\" should be \"\":=\"\"\");\n+         Scan;\n+\n+      elsif Token = Tok_Is then\n+         Error_Msg_SC (\"IS should be \"\":=\"\"\");\n+         Scan;\n+\n+      else\n+         Error_Msg_AP (\"missing \"\":=\"\"\");\n+      end if;\n+   end T_Colon_Equal;\n+\n+   -------------\n+   -- T_Comma --\n+   -------------\n+\n+   procedure T_Comma is\n+   begin\n+      if Token = Tok_Comma then\n+         Scan;\n+\n+      else\n+         if Token = Tok_Pragma then\n+            P_Pragmas_Misplaced;\n+         end if;\n+\n+         if Token = Tok_Comma then\n+            Scan;\n+         else\n+            Error_Msg_AP (\"missing \"\",\"\"\");\n+         end if;\n+      end if;\n+\n+      if Token = Tok_Pragma then\n+         P_Pragmas_Misplaced;\n+      end if;\n+   end T_Comma;\n+\n+   ---------------\n+   -- T_Dot_Dot --\n+   ---------------\n+\n+   procedure T_Dot_Dot is\n+   begin\n+      if Token = Tok_Dot_Dot then\n+         Scan;\n+      else\n+         Error_Msg_AP (\"missing \"\"..\"\"\");\n+      end if;\n+   end T_Dot_Dot;\n+\n+   -----------\n+   -- T_For --\n+   -----------\n+\n+   procedure T_For is\n+   begin\n+      Check_Token (Tok_For, AP);\n+   end T_For;\n+\n+   -----------------------\n+   -- T_Greater_Greater --\n+   -----------------------\n+\n+   procedure T_Greater_Greater is\n+   begin\n+      if Token = Tok_Greater_Greater then\n+         Scan;\n+      else\n+         Error_Msg_AP (\"missing \"\">>\"\"\");\n+      end if;\n+   end T_Greater_Greater;\n+\n+   ------------------\n+   -- T_Identifier --\n+   ------------------\n+\n+   procedure T_Identifier is\n+   begin\n+      if Token = Tok_Identifier then\n+         Scan;\n+      elsif Token in Token_Class_Literal then\n+         Error_Msg_SC (\"identifier expected\");\n+         Scan;\n+      else\n+         Error_Msg_AP (\"identifier expected\");\n+      end if;\n+   end T_Identifier;\n+\n+   ----------\n+   -- T_In --\n+   ----------\n+\n+   procedure T_In is\n+   begin\n+      Check_Token (Tok_In, AP);\n+   end T_In;\n+\n+   ----------\n+   -- T_Is --\n+   ----------\n+\n+   procedure T_Is is\n+   begin\n+      if Token = Tok_Is then\n+         Scan;\n+\n+         Ignore (Tok_Semicolon);\n+\n+      --  Allow OF, => or = to substitute for IS with complaint\n+\n+      elsif Token = Tok_Arrow\n+        or else Token = Tok_Of\n+        or else Token = Tok_Equal\n+      then\n+         Error_Msg_SC (\"missing IS\");\n+         Scan; -- token used in place of IS\n+      else\n+         Wrong_Token (Tok_Is, AP);\n+      end if;\n+\n+      while Token = Tok_Is loop\n+         Error_Msg_SC (\"extra IS ignored\");\n+         Scan;\n+      end loop;\n+   end T_Is;\n+\n+   ------------------\n+   -- T_Left_Paren --\n+   ------------------\n+\n+   procedure T_Left_Paren is\n+   begin\n+      if Token = Tok_Left_Paren then\n+         Scan;\n+      else\n+         Error_Msg_AP (\"missing \"\"(\"\"\");\n+      end if;\n+   end T_Left_Paren;\n+\n+   ------------\n+   -- T_Loop --\n+   ------------\n+\n+   procedure T_Loop is\n+   begin\n+      if Token = Tok_Do then\n+         Error_Msg_SC (\"LOOP expected\");\n+         Scan;\n+      else\n+         Check_Token (Tok_Loop, AP);\n+      end if;\n+   end T_Loop;\n+\n+   -----------\n+   -- T_Mod --\n+   -----------\n+\n+   procedure T_Mod is\n+   begin\n+      Check_Token (Tok_Mod, AP);\n+   end T_Mod;\n+\n+   -----------\n+   -- T_New --\n+   -----------\n+\n+   procedure T_New is\n+   begin\n+      Check_Token (Tok_New, AP);\n+   end T_New;\n+\n+   ----------\n+   -- T_Of --\n+   ----------\n+\n+   procedure T_Of is\n+   begin\n+      Check_Token (Tok_Of, AP);\n+   end T_Of;\n+\n+   ----------\n+   -- T_Or --\n+   ----------\n+\n+   procedure T_Or is\n+   begin\n+      Check_Token (Tok_Or, AP);\n+   end T_Or;\n+\n+   ---------------\n+   -- T_Private --\n+   ---------------\n+\n+   procedure T_Private is\n+   begin\n+      Check_Token (Tok_Private, SC);\n+   end T_Private;\n+\n+   -------------\n+   -- T_Range --\n+   -------------\n+\n+   procedure T_Range is\n+   begin\n+      Check_Token (Tok_Range, AP);\n+   end T_Range;\n+\n+   --------------\n+   -- T_Record --\n+   --------------\n+\n+   procedure T_Record is\n+   begin\n+      Check_Token (Tok_Record, AP);\n+   end T_Record;\n+\n+   -------------------\n+   -- T_Right_Paren --\n+   -------------------\n+\n+   procedure T_Right_Paren is\n+   begin\n+      if Token = Tok_Right_Paren then\n+         Scan;\n+      else\n+         Error_Msg_AP (\"missing \"\")\"\"\");\n+      end if;\n+   end T_Right_Paren;\n+\n+   -----------------\n+   -- T_Semicolon --\n+   -----------------\n+\n+   procedure T_Semicolon is\n+   begin\n+\n+      if Token = Tok_Semicolon then\n+         Scan;\n+\n+         if Token = Tok_Semicolon then\n+            Error_Msg_SC (\"extra \"\";\"\" ignored\");\n+            Scan;\n+         end if;\n+\n+      elsif Token = Tok_Colon then\n+         Error_Msg_SC (\"\"\":\"\" should be \"\";\"\"\");\n+         Scan;\n+\n+      elsif Token = Tok_Comma then\n+         Error_Msg_SC (\"\"\",\"\" should be \"\";\"\"\");\n+         Scan;\n+\n+      elsif Token = Tok_Dot then\n+         Error_Msg_SC (\"\"\".\"\" should be \"\";\"\"\");\n+         Scan;\n+\n+      --  An interesting little kludge here. If the previous token is a\n+      --  semicolon, then there is no way that we can legitimately need\n+      --  another semicolon. This could only arise in an error situation\n+      --  where an error has already been signalled. By simply ignoring\n+      --  the request for a semicolon in this case, we avoid some spurious\n+      --  missing semicolon messages.\n+\n+      elsif Prev_Token = Tok_Semicolon then\n+         return;\n+\n+      --  If the current token is | then this is a reasonable\n+      --  place to suggest the possibility of a \"C\" confusion :-)\n+\n+      elsif Token = Tok_Vertical_Bar then\n+         Error_Msg_SC (\"unexpected occurrence of \"\"|\"\", did you mean OR'?\");\n+         Resync_Past_Semicolon;\n+\n+      --  Otherwise we really do have a missing semicolon\n+\n+      else\n+         Error_Msg_AP (\"missing \"\";\"\"\");\n+         return;\n+      end if;\n+\n+   end T_Semicolon;\n+\n+   ------------\n+   -- T_Then --\n+   ------------\n+\n+   procedure T_Then is\n+   begin\n+      Check_Token (Tok_Then, AP);\n+   end T_Then;\n+\n+   ------------\n+   -- T_Type --\n+   ------------\n+\n+   procedure T_Type is\n+   begin\n+      Check_Token (Tok_Type, BC);\n+   end T_Type;\n+\n+   -----------\n+   -- T_Use --\n+   -----------\n+\n+   procedure T_Use is\n+   begin\n+      Check_Token (Tok_Use, SC);\n+   end T_Use;\n+\n+   ------------\n+   -- T_When --\n+   ------------\n+\n+   procedure T_When is\n+   begin\n+      Check_Token (Tok_When, SC);\n+   end T_When;\n+\n+   ------------\n+   -- T_With --\n+   ------------\n+\n+   procedure T_With is\n+   begin\n+      Check_Token (Tok_With, BC);\n+   end T_With;\n+\n+   --------------\n+   -- TF_Arrow --\n+   --------------\n+\n+   procedure TF_Arrow is\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      if Token = Tok_Arrow then\n+         Scan; -- skip arrow and we are done\n+\n+      elsif Token = Tok_Colon_Equal then\n+         T_Arrow; -- Let T_Arrow give the message\n+\n+      else\n+         T_Arrow; -- give missing arrow message\n+         Save_Scan_State (Scan_State); -- at start of junk tokens\n+\n+         loop\n+            if Prev_Token_Ptr < Current_Line_Start\n+              or else Token = Tok_Semicolon\n+              or else Token = Tok_EOF\n+            then\n+               Restore_Scan_State (Scan_State); -- to where we were!\n+               return;\n+            end if;\n+\n+            Scan; -- continue search!\n+\n+            if Token = Tok_Arrow then\n+               Scan; -- past arrow\n+               return;\n+            end if;\n+         end loop;\n+      end if;\n+   end TF_Arrow;\n+\n+   -----------\n+   -- TF_Is --\n+   -----------\n+\n+   procedure TF_Is is\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      if Token = Tok_Is then\n+         T_Is; -- past IS and we are done\n+\n+      --  Allow OF or => or = in place of IS (with error message)\n+\n+      elsif Token = Tok_Of\n+        or else Token = Tok_Arrow\n+        or else Token = Tok_Equal\n+      then\n+         T_Is; -- give missing IS message and skip bad token\n+\n+      else\n+         T_Is; -- give missing IS message\n+         Save_Scan_State (Scan_State); -- at start of junk tokens\n+\n+         loop\n+            if Prev_Token_Ptr < Current_Line_Start\n+              or else Token = Tok_Semicolon\n+              or else Token = Tok_EOF\n+            then\n+               Restore_Scan_State (Scan_State); -- to where we were!\n+               return;\n+            end if;\n+\n+            Scan; -- continue search!\n+\n+            if Token = Tok_Is\n+              or else Token = Tok_Of\n+              or else Token = Tok_Arrow\n+            then\n+               Scan; -- past IS or OF or =>\n+               return;\n+            end if;\n+         end loop;\n+      end if;\n+   end TF_Is;\n+\n+   -------------\n+   -- TF_Loop --\n+   -------------\n+\n+   procedure TF_Loop is\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      if Token = Tok_Loop then\n+         Scan; -- past LOOP and we are done\n+\n+      --  Allow DO or THEN in place of LOOP\n+\n+      elsif Token = Tok_Then or else Token = Tok_Do then\n+         T_Loop; -- give missing LOOP message\n+\n+      else\n+         T_Loop; -- give missing LOOP message\n+         Save_Scan_State (Scan_State); -- at start of junk tokens\n+\n+         loop\n+            if Prev_Token_Ptr < Current_Line_Start\n+              or else Token = Tok_Semicolon\n+              or else Token = Tok_EOF\n+            then\n+               Restore_Scan_State (Scan_State); -- to where we were!\n+               return;\n+            end if;\n+\n+            Scan; -- continue search!\n+\n+            if Token = Tok_Loop or else Token = Tok_Then then\n+               Scan; -- past loop or then (message already generated)\n+               return;\n+            end if;\n+         end loop;\n+      end if;\n+   end TF_Loop;\n+\n+   --------------\n+   -- TF_Return--\n+   --------------\n+\n+   procedure TF_Return is\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      if Token = Tok_Return then\n+         Scan; -- skip RETURN and we are done\n+\n+      else\n+         Error_Msg_SC (\"missing RETURN\");\n+         Save_Scan_State (Scan_State); -- at start of junk tokens\n+\n+         loop\n+            if Prev_Token_Ptr < Current_Line_Start\n+              or else Token = Tok_Semicolon\n+              or else Token = Tok_EOF\n+            then\n+               Restore_Scan_State (Scan_State); -- to where we were!\n+               return;\n+            end if;\n+\n+            Scan; -- continue search!\n+\n+            if Token = Tok_Return then\n+               Scan; -- past RETURN\n+               return;\n+            end if;\n+         end loop;\n+      end if;\n+   end TF_Return;\n+\n+   ------------------\n+   -- TF_Semicolon --\n+   ------------------\n+\n+   procedure TF_Semicolon is\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      if Token = Tok_Semicolon then\n+         T_Semicolon;\n+         return;\n+\n+      --  An interesting little kludge here. If the previous token is a\n+      --  semicolon, then there is no way that we can legitimately need\n+      --  another semicolon. This could only arise in an error situation\n+      --  where an error has already been signalled. By simply ignoring\n+      --  the request for a semicolon in this case, we avoid some spurious\n+      --  missing semicolon messages.\n+\n+      elsif Prev_Token = Tok_Semicolon then\n+         return;\n+\n+      else\n+         if Token = Tok_Pragma then\n+            P_Pragmas_Misplaced;\n+\n+            if Token = Tok_Semicolon then\n+               T_Semicolon;\n+               return;\n+            end if;\n+         end if;\n+\n+         T_Semicolon; -- give missing semicolon message\n+         Save_Scan_State (Scan_State); -- at start of junk tokens\n+\n+         loop\n+            if Prev_Token_Ptr < Current_Line_Start\n+              or else Token = Tok_EOF\n+            then\n+               Restore_Scan_State (Scan_State); -- to where we were\n+               return;\n+            end if;\n+\n+            Scan; -- continue search\n+\n+            if Token = Tok_Semicolon then\n+               T_Semicolon;\n+               return;\n+\n+            elsif Token in Token_Class_After_SM then\n+               return;\n+            end if;\n+         end loop;\n+      end if;\n+   end TF_Semicolon;\n+\n+   -------------\n+   -- TF_Then --\n+   -------------\n+\n+   procedure TF_Then is\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      if Token = Tok_Then then\n+         Scan; -- past THEN and we are done\n+\n+      else\n+         T_Then; -- give missing THEN message\n+         Save_Scan_State (Scan_State); -- at start of junk tokens\n+\n+         loop\n+            if Prev_Token_Ptr < Current_Line_Start\n+              or else Token = Tok_Semicolon\n+              or else Token = Tok_EOF\n+            then\n+               Restore_Scan_State (Scan_State); -- to where we were\n+               return;\n+            end if;\n+\n+            Scan; -- continue search!\n+\n+            if Token = Tok_Then then\n+               Scan; -- past THEN\n+               return;\n+            end if;\n+         end loop;\n+      end if;\n+   end TF_Then;\n+\n+   ------------\n+   -- TF_Use --\n+   ------------\n+\n+   procedure TF_Use is\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      if Token = Tok_Use then\n+         Scan; -- past USE and we are done\n+\n+      else\n+         T_Use; -- give USE expected message\n+         Save_Scan_State (Scan_State); -- at start of junk tokens\n+\n+         loop\n+            if Prev_Token_Ptr < Current_Line_Start\n+              or else Token = Tok_Semicolon\n+              or else Token = Tok_EOF\n+            then\n+               Restore_Scan_State (Scan_State); -- to where we were\n+               return;\n+            end if;\n+\n+            Scan; -- continue search!\n+\n+            if Token = Tok_Use then\n+               Scan; -- past use\n+               return;\n+            end if;\n+         end loop;\n+      end if;\n+   end TF_Use;\n+\n+   -----------------\n+   -- Wrong_Token --\n+   -----------------\n+\n+   procedure Wrong_Token (T : Token_Type; P : Position) is\n+      Missing : constant String := \"missing \";\n+      Image : constant String := Token_Type'Image (T);\n+      Tok_Name : constant String := Image (5 .. Image'Length);\n+      M : String (1 .. Missing'Length + Tok_Name'Length);\n+\n+   begin\n+      --  Set M to Missing & Tok_Name.\n+\n+      M (1 .. Missing'Length) := Missing;\n+      M (Missing'Length + 1 .. M'Last) := Tok_Name;\n+\n+      if Token = Tok_Semicolon then\n+         Scan;\n+\n+         if Token = T then\n+            Error_Msg_SP (\"extra \"\";\"\" ignored\");\n+            Scan;\n+         else\n+            Error_Msg_SP (M);\n+         end if;\n+\n+      elsif Token = Tok_Comma then\n+         Scan;\n+\n+         if Token = T then\n+            Error_Msg_SP (\"extra \"\",\"\" ignored\");\n+            Scan;\n+\n+         else\n+            Error_Msg_SP (M);\n+         end if;\n+\n+      else\n+         case P is\n+            when SC => Error_Msg_SC (M);\n+            when BC => Error_Msg_BC (M);\n+            when AP => Error_Msg_AP (M);\n+         end case;\n+      end if;\n+   end Wrong_Token;\n+\n+end Tchk;"}, {"sha": "f8082b64ee64b1797e5f64e72dcedae7c8cb0791", "filename": "gcc/ada/par-util.adb", "status": "added", "additions": 638, "deletions": 0, "changes": 638, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-util.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,638 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P A R . U T I L                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.64 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Uintp; use Uintp;\n+\n+with GNAT.Spelling_Checker; use GNAT.Spelling_Checker;\n+\n+separate (Par)\n+package body Util is\n+\n+   ---------------------\n+   -- Bad_Spelling_Of --\n+   ---------------------\n+\n+   function Bad_Spelling_Of (T : Token_Type) return Boolean is\n+      Tname : constant String := Token_Type'Image (T);\n+      --  Characters of token name\n+\n+      S : String (1 .. Tname'Last - 4);\n+      --  Characters of token name folded to lower case, omitting TOK_ at start\n+\n+      M1 : String (1 .. 42) := \"incorrect spelling of keyword ************\";\n+      M2 : String (1 .. 44) := \"illegal abbreviation of keyword ************\";\n+      --  Buffers used to construct error message\n+\n+      P1 : constant := 30;\n+      P2 : constant := 32;\n+      --  Starting subscripts in M1, M2 for keyword name\n+\n+      SL : constant Natural := S'Length;\n+      --  Length of expected token name excluding TOK_ at start\n+\n+   begin\n+      if Token /= Tok_Identifier then\n+         return False;\n+      end if;\n+\n+      for J in S'Range loop\n+         S (J) := Fold_Lower (Tname (Integer (J) + 4));\n+      end loop;\n+\n+      Get_Name_String (Token_Name);\n+\n+      --  A special check for case of PROGRAM used for PROCEDURE\n+\n+      if T = Tok_Procedure\n+        and then Name_Len = 7\n+        and then Name_Buffer (1 .. 7) = \"program\"\n+      then\n+         Error_Msg_SC (\"PROCEDURE expected\");\n+         Token := T;\n+         return True;\n+\n+      --  A special check for an illegal abbrevation\n+\n+      elsif Name_Len < S'Length\n+        and then Name_Len >= 4\n+        and then Name_Buffer (1 .. Name_Len) = S (1 .. Name_Len)\n+      then\n+         for J in 1 .. S'Last loop\n+            M2 (P2 + J - 1) := Fold_Upper (S (J));\n+         end loop;\n+\n+         Error_Msg_SC (M2 (1 .. P2 - 1 + S'Last));\n+         Token := T;\n+         return True;\n+      end if;\n+\n+      --  Now we go into the full circuit to check for a misspelling\n+\n+      --  Never consider something a misspelling if either the actual or\n+      --  expected string is less than 3 characters (before this check we\n+      --  used to consider i to be a misspelled if in some cases!)\n+\n+      if SL < 3 or else Name_Len < 3 then\n+         return False;\n+\n+      --  Special case: prefix matches, i.e. the leading characters of the\n+      --  token that we have exactly match the required keyword. If there\n+      --  are at least two characters left over, assume that we have a case\n+      --  of two keywords joined together which should not be joined.\n+\n+      elsif Name_Len > SL + 1\n+        and then S = Name_Buffer (1 .. SL)\n+      then\n+         Scan_Ptr := Token_Ptr + S'Length;\n+         Error_Msg_S (\"missing space\");\n+         Token := T;\n+         return True;\n+      end if;\n+\n+      if Is_Bad_Spelling_Of (Name_Buffer (1 .. Name_Len), S) then\n+\n+         for J in 1 .. S'Last loop\n+            M1 (P1 + J - 1) := Fold_Upper (S (J));\n+         end loop;\n+\n+         Error_Msg_SC (M1 (1 .. P1 - 1 + S'Last));\n+         Token := T;\n+         return True;\n+\n+      else\n+         return False;\n+      end if;\n+\n+   end Bad_Spelling_Of;\n+\n+   ----------------------\n+   -- Check_95_Keyword --\n+   ----------------------\n+\n+   --  On entry, the caller has checked that current token is an identifier\n+   --  whose name matches the name of the 95 keyword New_Tok.\n+\n+   procedure Check_95_Keyword (Token_95, Next : Token_Type) is\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      Save_Scan_State (Scan_State); -- at identifier/keyword\n+      Scan; -- past identifier/keyword\n+\n+      if Token = Next then\n+         Restore_Scan_State (Scan_State); -- to identifier\n+         Error_Msg_Name_1 := Token_Name;\n+         Error_Msg_SC (\"(Ada 83) keyword* cannot be used!\");\n+         Token := Token_95;\n+      else\n+         Restore_Scan_State (Scan_State); -- to identifier\n+      end if;\n+   end Check_95_Keyword;\n+\n+   ----------------------\n+   -- Check_Bad_Layout --\n+   ----------------------\n+\n+   procedure Check_Bad_Layout is\n+   begin\n+      if Style.RM_Column_Check and then Token_Is_At_Start_Of_Line\n+        and then Start_Column <= Scope.Table (Scope.Last).Ecol\n+      then\n+         Error_Msg_BC (\"(style) incorrect layout\");\n+      end if;\n+   end Check_Bad_Layout;\n+\n+   --------------------------\n+   -- Check_Misspelling_Of --\n+   --------------------------\n+\n+   procedure Check_Misspelling_Of (T : Token_Type) is\n+   begin\n+      if Bad_Spelling_Of (T) then\n+         null;\n+      end if;\n+   end Check_Misspelling_Of;\n+\n+   -----------------------------\n+   -- Check_Simple_Expression --\n+   -----------------------------\n+\n+   procedure Check_Simple_Expression (E : Node_Id) is\n+   begin\n+      if Expr_Form = EF_Non_Simple then\n+         Error_Msg_N (\"this expression must be parenthesized\", E);\n+      end if;\n+   end Check_Simple_Expression;\n+\n+   ---------------------------------------\n+   -- Check_Simple_Expression_In_Ada_83 --\n+   ---------------------------------------\n+\n+   procedure Check_Simple_Expression_In_Ada_83 (E : Node_Id) is\n+   begin\n+      if Expr_Form = EF_Non_Simple then\n+         if Ada_83 then\n+            Error_Msg_N (\"(Ada 83) this expression must be parenthesized!\", E);\n+         end if;\n+      end if;\n+   end Check_Simple_Expression_In_Ada_83;\n+\n+   ------------------------\n+   -- Check_Subtype_Mark --\n+   ------------------------\n+\n+   function Check_Subtype_Mark (Mark : Node_Id) return Node_Id is\n+   begin\n+      if Nkind (Mark) = N_Identifier\n+        or else Nkind (Mark) = N_Selected_Component\n+        or else (Nkind (Mark) = N_Attribute_Reference\n+                  and then Is_Type_Attribute_Name (Attribute_Name (Mark)))\n+        or else Mark = Error\n+      then\n+         return Mark;\n+      else\n+         Error_Msg (\"subtype mark expected\", Sloc (Mark));\n+         return Error;\n+      end if;\n+   end Check_Subtype_Mark;\n+\n+   -------------------\n+   -- Comma_Present --\n+   -------------------\n+\n+   function Comma_Present return Boolean is\n+      Scan_State  : Saved_Scan_State;\n+      Paren_Count : Nat;\n+\n+   begin\n+      --  First check, if a comma is present, then a comma is present!\n+\n+      if Token = Tok_Comma then\n+         T_Comma;\n+         return True;\n+\n+      --  If we have a right paren, then that is taken as ending the list\n+      --  i.e. no comma is present.\n+\n+      elsif Token = Tok_Right_Paren then\n+         return False;\n+\n+      --  If pragmas, then get rid of them and make a recursive call\n+      --  to process what follows these pragmas.\n+\n+      elsif Token = Tok_Pragma then\n+         P_Pragmas_Misplaced;\n+         return Comma_Present;\n+\n+      --  At this stage we have an error, and the goal is to decide on whether\n+      --  or not we should diagnose an error and report a (non-existent)\n+      --  comma as being present, or simply to report no comma is present\n+\n+      --  If we are a semicolon, then the question is whether we have a missing\n+      --  right paren, or whether the semicolon should have been a comma. To\n+      --  guess the right answer, we scan ahead keeping track of the paren\n+      --  level, looking for a clue that helps us make the right decision.\n+\n+      --  This approach is highly accurate in the single error case, and does\n+      --  not make bad mistakes in the multiple error case (indeed we can't\n+      --  really make a very bad decision at this point in any case).\n+\n+      elsif Token = Tok_Semicolon then\n+         Save_Scan_State (Scan_State);\n+         Scan; -- past semicolon\n+\n+         --  Check for being followed by identifier => which almost certainly\n+         --  means we are still in a parameter list and the comma should have\n+         --  been a semicolon (such a sequence could not follow a semicolon)\n+\n+         if Token = Tok_Identifier then\n+            Scan;\n+\n+            if Token = Tok_Arrow then\n+               goto Assume_Comma;\n+            end if;\n+         end if;\n+\n+         --  If that test didn't work, loop ahead looking for a comma or\n+         --  semicolon at the same parenthesis level. Always remember that\n+         --  we can't go badly wrong in an error situation like this!\n+\n+         Paren_Count := 0;\n+\n+         --  Here is the look ahead loop, Paren_Count tells us whether the\n+         --  token we are looking at is at the same paren level as the\n+         --  suspicious semicolon that we are trying to figure out.\n+\n+         loop\n+\n+            --  If we hit another semicolon or an end of file, and we have\n+            --  not seen a right paren or another comma on the way, then\n+            --  probably the semicolon did end the list. Indeed that is\n+            --  certainly the only single error correction possible here.\n+\n+            if Token = Tok_Semicolon or else Token = Tok_EOF then\n+               Restore_Scan_State (Scan_State);\n+               return False;\n+\n+            --  A comma at the same paren level as the semicolon is a strong\n+            --  indicator that the semicolon should have been a comma, indeed\n+            --  again this is the only possible single error correction.\n+\n+            elsif Token = Tok_Comma then\n+               exit when Paren_Count = 0;\n+\n+            --  A left paren just bumps the paren count\n+\n+            elsif Token = Tok_Left_Paren then\n+               Paren_Count := Paren_Count + 1;\n+\n+            --  A right paren that is at the same paren level as the semicolon\n+            --  also means that the only possible single error correction is\n+            --  to assume that the semicolon should have been a comma. If we\n+            --  are not at the same paren level, then adjust the paren level.\n+\n+            elsif Token = Tok_Right_Paren then\n+               exit when Paren_Count = 0;\n+               Paren_Count := Paren_Count - 1;\n+            end if;\n+\n+            --  Keep going, we haven't made a decision yet\n+\n+            Scan;\n+         end loop;\n+\n+         --  If we fall through the loop, it means that we found a terminating\n+         --  right paren or another comma. In either case it is reasonable to\n+         --  assume that the semicolon was really intended to be a comma. Also\n+         --  come here for the identifier arrow case.\n+\n+         <<Assume_Comma>>\n+            Restore_Scan_State (Scan_State);\n+            Error_Msg_SC (\"\"\";\"\" illegal here, replaced by \"\",\"\"\");\n+            Scan; -- past the semicolon\n+            return True;\n+\n+      --  If we are not at semicolon or a right paren, then we base the\n+      --  decision on whether or not the next token can be part of an\n+      --  expression. If not, then decide that no comma is present (the\n+      --  caller will eventually generate a missing right parent message)\n+\n+      elsif Token in Token_Class_Eterm then\n+         return False;\n+\n+      --  Otherwise we assume a comma is present, even if none is present,\n+      --  since the next token must be part of an expression, so if we were\n+      --  at the end of the list, then there is more than one error present.\n+\n+      else\n+         T_Comma; -- to give error\n+         return True;\n+      end if;\n+   end Comma_Present;\n+\n+   -----------------------\n+   -- Discard_Junk_List --\n+   -----------------------\n+\n+   procedure Discard_Junk_List (L : List_Id) is\n+   begin\n+      null;\n+   end Discard_Junk_List;\n+\n+   -----------------------\n+   -- Discard_Junk_Node --\n+   -----------------------\n+\n+   procedure Discard_Junk_Node (N : Node_Id) is\n+   begin\n+      null;\n+   end Discard_Junk_Node;\n+\n+   ------------\n+   -- Ignore --\n+   ------------\n+\n+   procedure Ignore (T : Token_Type) is\n+   begin\n+      if Token = T then\n+         if T = Tok_Comma then\n+            Error_Msg_SC (\"unexpected \"\",\"\" ignored\");\n+\n+         elsif T = Tok_Left_Paren then\n+            Error_Msg_SC (\"unexpected \"\"(\"\" ignored\");\n+\n+         elsif T = Tok_Right_Paren then\n+            Error_Msg_SC (\"unexpected \"\")\"\" ignored\");\n+\n+         elsif T = Tok_Semicolon then\n+            Error_Msg_SC (\"unexpected \"\";\"\" ignored\");\n+\n+         else\n+            declare\n+               Tname : constant String := Token_Type'Image (Token);\n+               Msg   : String := \"unexpected keyword ????????????????????????\";\n+\n+            begin\n+               --  Loop to copy characters of keyword name (ignoring Tok_)\n+\n+               for J in 5 .. Tname'Last loop\n+                  Msg (J + 14) := Fold_Upper (Tname (J));\n+               end loop;\n+\n+               Msg (Tname'Last + 15 .. Tname'Last + 22) := \" ignored\";\n+               Error_Msg_SC (Msg (1 .. Tname'Last + 22));\n+            end;\n+         end if;\n+\n+         Scan; -- Scan past ignored token\n+      end if;\n+   end Ignore;\n+\n+   ----------------------------\n+   -- Is_Reserved_Identifier --\n+   ----------------------------\n+\n+   function Is_Reserved_Identifier return Boolean is\n+   begin\n+      if not Is_Reserved_Keyword (Token) then\n+         return False;\n+\n+      else\n+         declare\n+            Ident_Casing : constant Casing_Type :=\n+                             Identifier_Casing (Current_Source_File);\n+\n+            Key_Casing   : constant Casing_Type :=\n+                             Keyword_Casing (Current_Source_File);\n+\n+         begin\n+            --  If the casing of identifiers and keywords is different in\n+            --  this source file, and the casing of this token matches the\n+            --  keyword casing, then we return False, since it is pretty\n+            --  clearly intended to be a keyword.\n+\n+            if Ident_Casing /= Unknown\n+              and then Key_Casing /= Unknown\n+              and then Ident_Casing /= Key_Casing\n+              and then Determine_Token_Casing = Key_Casing\n+            then\n+               return False;\n+\n+            --  Otherwise assume that an identifier was intended\n+\n+            else\n+               return True;\n+            end if;\n+         end;\n+      end if;\n+   end Is_Reserved_Identifier;\n+\n+   ----------------------\n+   -- Merge_Identifier --\n+   ----------------------\n+\n+   procedure Merge_Identifier (Prev : Node_Id; Nxt : Token_Type) is\n+   begin\n+      if Token /= Tok_Identifier then\n+         return;\n+      end if;\n+\n+      declare\n+         S : Saved_Scan_State;\n+         T : Token_Type;\n+\n+      begin\n+         Save_Scan_State (S);\n+         Scan;\n+         T := Token;\n+         Restore_Scan_State (S);\n+\n+         if T /= Nxt then\n+            return;\n+         end if;\n+      end;\n+\n+      --  Check exactly one space between identifiers\n+\n+      if Source (Token_Ptr - 1) /= ' '\n+        or else Int (Token_Ptr) /=\n+                  Int (Prev_Token_Ptr) + Length_Of_Name (Chars (Prev)) + 1\n+      then\n+         return;\n+      end if;\n+\n+      --  Do the merge\n+\n+      Get_Name_String (Chars (Token_Node));\n+\n+      declare\n+         Buf : String (1 .. Name_Len) := Name_Buffer (1 .. Name_Len);\n+\n+      begin\n+         Get_Name_String (Chars (Prev));\n+         Add_Char_To_Name_Buffer ('_');\n+         Add_Str_To_Name_Buffer (Buf);\n+         Set_Chars (Prev, Name_Find);\n+      end;\n+\n+      Error_Msg_Node_1 := Prev;\n+      Error_Msg_SC\n+        (\"unexpected identifier, possibly & was meant here\");\n+      Scan;\n+   end Merge_Identifier;\n+\n+   -------------------\n+   -- No_Constraint --\n+   -------------------\n+\n+   procedure No_Constraint is\n+   begin\n+      if Token in Token_Class_Consk then\n+         Error_Msg_SC (\"constraint not allowed here\");\n+         Discard_Junk_Node (P_Constraint_Opt);\n+      end if;\n+   end No_Constraint;\n+\n+   --------------------\n+   -- No_Right_Paren --\n+   --------------------\n+\n+   function No_Right_Paren (Expr : Node_Id) return Node_Id is\n+   begin\n+      if Token = Tok_Right_Paren then\n+         Error_Msg_SC (\"unexpected right parenthesis\");\n+         Resync_Expression;\n+         return Error;\n+      else\n+         return Expr;\n+      end if;\n+   end No_Right_Paren;\n+\n+   ---------------------\n+   -- Pop_Scope_Stack --\n+   ---------------------\n+\n+   procedure Pop_Scope_Stack is\n+   begin\n+      pragma Assert (Scope.Last > 0);\n+      Scope.Decrement_Last;\n+\n+      if Debug_Flag_P then\n+         Error_Msg_Uint_1 := UI_From_Int (Scope.Last);\n+         Error_Msg_SC (\"decrement scope stack ptr, new value = ^!\");\n+      end if;\n+   end Pop_Scope_Stack;\n+\n+   ----------------------\n+   -- Push_Scope_Stack --\n+   ----------------------\n+\n+   procedure Push_Scope_Stack is\n+   begin\n+      Scope.Increment_Last;\n+      Scope.Table (Scope.Last).Junk := False;\n+      Scope.Table (Scope.Last).Node := Empty;\n+\n+      if Debug_Flag_P then\n+         Error_Msg_Uint_1 := UI_From_Int (Scope.Last);\n+         Error_Msg_SC (\"increment scope stack ptr, new value = ^!\");\n+      end if;\n+   end Push_Scope_Stack;\n+\n+   ----------------------\n+   -- Separate_Present --\n+   ----------------------\n+\n+   function Separate_Present return Boolean is\n+      Scan_State : Saved_Scan_State;\n+\n+   begin\n+      if Token = Tok_Separate then\n+         return True;\n+\n+      elsif Token /= Tok_Identifier then\n+         return False;\n+\n+      else\n+         Save_Scan_State (Scan_State);\n+         Scan; -- past identifier\n+\n+         if Token = Tok_Semicolon then\n+            Restore_Scan_State (Scan_State);\n+            return Bad_Spelling_Of (Tok_Separate);\n+\n+         else\n+            Restore_Scan_State (Scan_State);\n+            return False;\n+         end if;\n+      end if;\n+   end Separate_Present;\n+\n+   --------------------------\n+   -- Signal_Bad_Attribute --\n+   --------------------------\n+\n+   procedure Signal_Bad_Attribute is\n+   begin\n+      Error_Msg_N (\"unrecognized attribute&\", Token_Node);\n+\n+      --  Check for possible misspelling\n+\n+      Get_Name_String (Token_Name);\n+\n+      declare\n+         AN : constant String := Name_Buffer (1 .. Name_Len);\n+\n+      begin\n+         Error_Msg_Name_1 := First_Attribute_Name;\n+         while Error_Msg_Name_1 <= Last_Attribute_Name loop\n+            Get_Name_String (Error_Msg_Name_1);\n+\n+            if Is_Bad_Spelling_Of\n+                 (AN, Name_Buffer (1 .. Name_Len))\n+            then\n+               Error_Msg_N\n+                 (\"\\possible misspelling of %\", Token_Node);\n+               exit;\n+            end if;\n+\n+            Error_Msg_Name_1 := Error_Msg_Name_1 + 1;\n+         end loop;\n+      end;\n+   end Signal_Bad_Attribute;\n+\n+   -------------------------------\n+   -- Token_Is_At_Start_Of_Line --\n+   -------------------------------\n+\n+   function Token_Is_At_Start_Of_Line return Boolean is\n+   begin\n+      return (Token_Ptr = First_Non_Blank_Location or else Token = Tok_EOF);\n+   end Token_Is_At_Start_Of_Line;\n+\n+end Util;"}, {"sha": "f45a83b4390be16c9bd698c3ac0e975cdcc1af3b", "filename": "gcc/ada/par.adb", "status": "added", "additions": 1181, "deletions": 0, "changes": 1181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,1181 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                  P A R                                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.126 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Casing;   use Casing;\n+with Csets;    use Csets;\n+with Debug;    use Debug;\n+with Elists;   use Elists;\n+with Errout;   use Errout;\n+with Fname;    use Fname;\n+with Lib;      use Lib;\n+with Namet;    use Namet;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Opt;      use Opt;\n+with Output;   use Output;\n+with Scans;    use Scans;\n+with Scn;      use Scn;\n+with Sinput;   use Sinput;\n+with Sinput.L; use Sinput.L;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Style;\n+with Table;\n+\n+function Par (Configuration_Pragmas : Boolean) return List_Id is\n+\n+   Num_Library_Units : Natural := 0;\n+   --  Count number of units parsed (relevant only in syntax check only mode,\n+   --  since in semantics check mode only a single unit is permitted anyway)\n+\n+   Unit_Node : Node_Id;\n+   --  Stores compilation unit node for current unit\n+\n+   Save_Config_Switches : Config_Switches_Type;\n+   --  Variable used to save values of config switches while we parse the\n+   --  new unit, to be restored on exit for proper recursive behavior.\n+\n+   Loop_Block_Count : Nat := 0;\n+   --  Counter used for constructing loop/block names (see the routine\n+   --  Par.Ch5.Get_Loop_Block_Name)\n+\n+   --------------------\n+   -- Error Recovery --\n+   --------------------\n+\n+   --  When an error is encountered, a call is made to one of the Error_Msg\n+   --  routines to record the error. If the syntax scan is not derailed by the\n+   --  error (e.g. a complaint that logical operators are inconsistent in an\n+   --  EXPRESSION), then control returns from the Error_Msg call, and the\n+   --  parse continues unimpeded.\n+\n+   --  If on the other hand, the Error_Msg represents a situation from which\n+   --  the parser cannot recover locally, the exception Error_Resync is raised\n+   --  immediately after the call to Error_Msg. Handlers for Error_Resync\n+   --  are located at strategic points to resynchronize the parse. For example,\n+   --  when an error occurs in a statement, the handler skips to the next\n+   --  semicolon and continues the scan from there.\n+\n+   --  Each parsing procedure contains a note with the heading \"Error recovery\"\n+   --  which shows if it can propagate the Error_Resync exception. In order\n+   --  not to propagate the exception, a procedure must either contain its own\n+   --  handler for this exception, or it must not call any other routines which\n+   --  propagate the exception.\n+\n+   --  Note: the arrangement of Error_Resync handlers is such that it should\n+   --  never be possible to transfer control through a procedure which made\n+   --  an entry in the scope stack, invalidating the contents of the stack.\n+\n+   Error_Resync : exception;\n+   --  Exception raised on error that is not handled locally, see above.\n+\n+   Last_Resync_Point : Source_Ptr;\n+   --  The resynchronization routines in Par.Sync run a risk of getting\n+   --  stuck in an infinite loop if they do not skip a token, and the caller\n+   --  keeps repeating the same resync call. On the other hand, if they skip\n+   --  a token unconditionally, some recovery opportunities are missed. The\n+   --  variable Last_Resync_Point records the token location previously set\n+   --  by a Resync call, and if a subsequent Resync call occurs at the same\n+   --  location, then the Resync routine does guarantee to skip a token.\n+\n+   --------------------------------------------\n+   -- Handling Semicolon Used in Place of IS --\n+   --------------------------------------------\n+\n+   --  The following global variables are used in handling the error situation\n+   --  of using a semicolon in place of IS in a subprogram declaration as in:\n+\n+   --    procedure X (Y : Integer);\n+   --       Q : Integer;\n+   --    begin\n+   --       ...\n+   --    end;\n+\n+   --  The two contexts in which this can appear are at the outer level, and\n+   --  within a declarative region. At the outer level, we know something is\n+   --  wrong as soon as we see the Q (or begin, if there are no declarations),\n+   --  and we can immediately decide that the semicolon should have been IS.\n+\n+   --  The situation in a declarative region is more complex. The declaration\n+   --  of Q could belong to the outer region, and we do not know that we have\n+   --  an error until we hit the begin. It is still not clear at this point\n+   --  from a syntactic point of view that something is wrong, because the\n+   --  begin could belong to the enclosing subprogram or package. However, we\n+   --  can incorporate a bit of semantic knowledge and note that the body of\n+   --  X is missing, so we definitely DO have an error. We diagnose this error\n+   --  as semicolon in place of IS on the subprogram line.\n+\n+   --  There are two styles for this diagnostic. If the begin immediately\n+   --  follows the semicolon, then we can place a flag (IS expected) right\n+   --  on the semicolon. Otherwise we do not detect the error until we hit\n+   --  the begin which refers back to the line with the semicolon.\n+\n+   --  To control the process in the second case, the following global\n+   --  variables are set to indicate that we have a subprogram declaration\n+   --  whose body is required and has not yet been found. The prefix SIS\n+   --  stands for \"Subprogram IS\" handling.\n+\n+   SIS_Entry_Active : Boolean;\n+   --  Set True to indicate that an entry is active (i.e. that a subprogram\n+   --  declaration has been encountered, and no body for this subprogram has\n+   --  been encountered). The remaining fields are valid only if this is True.\n+\n+   SIS_Labl : Node_Id;\n+   --  Subprogram designator\n+\n+   SIS_Sloc : Source_Ptr;\n+   --  Source location of FUNCTION/PROCEDURE keyword\n+\n+   SIS_Ecol : Column_Number;\n+   --  Column number of FUNCTION/PROCEDURE keyword\n+\n+   SIS_Semicolon_Sloc : Source_Ptr;\n+   --  Source location of semicolon at end of subprogram declaration\n+\n+   SIS_Declaration_Node : Node_Id;\n+   --  Pointer to tree node for subprogram declaration\n+\n+   SIS_Missing_Semicolon_Message : Error_Msg_Id;\n+   --  Used to save message ID of missing semicolon message (which will be\n+   --  modified to missing IS if necessary). Set to No_Error_Msg in the\n+   --  normal (non-error) case.\n+\n+   --  Five things can happen to an active SIS entry\n+\n+   --   1. If a BEGIN is encountered with an SIS entry active, then we have\n+   --   exactly the situation in which we know the body of the subprogram is\n+   --   missing. After posting an error message, we change the spec to a body,\n+   --   rechaining the declarations that intervened between the spec and BEGIN.\n+\n+   --   2. Another subprogram declaration or body is encountered. In this\n+   --   case the entry gets overwritten with the information for the new\n+   --   subprogram declaration. We don't catch some nested cases this way,\n+   --   but it doesn't seem worth the effort.\n+\n+   --   3. A nested declarative region (e.g. package declaration or package\n+   --   body) is encountered. The SIS active indication is reset at the start\n+   --   of such a nested region. Again, like case 2, this causes us to miss\n+   --   some nested cases, but it doesn't seen worth the effort to stack and\n+   --   unstack the SIS information. Maybe we will reconsider this if we ever\n+   --   get a complaint about a missed case :-)\n+\n+   --   4. We encounter a valid pragma INTERFACE or IMPORT that effectively\n+   --   supplies the missing body. In this case we reset the entry.\n+\n+   --   5. We encounter the end of the declarative region without encoutering\n+   --   a BEGIN first. In this situation we simply reset the entry. We know\n+   --   that there is a missing body, but it seems more reasonable to let the\n+   --   later semantic checking discover this.\n+\n+   --------------------------------------------\n+   -- Handling IS Used in Place of Semicolon --\n+   --------------------------------------------\n+\n+   --  This is a somewhat trickier situation, and we can't catch it in all\n+   --  cases, but we do our best to detect common situations resulting from\n+   --  a \"cut and paste\" operation which forgets to change the IS to semicolon.\n+   --  Consider the following example:\n+\n+   --    package body X is\n+   --      procedure A;\n+   --      procedure B is\n+   --      procedure C;\n+   --      ...\n+   --      procedure D is\n+   --      begin\n+   --         ...\n+   --      end;\n+   --    begin\n+   --      ...\n+   --    end;\n+\n+   --  The trouble is that the section of text from PROCEDURE B through END;\n+   --  consitutes a valid procedure body, and the danger is that we find out\n+   --  far too late that something is wrong (indeed most compilers will behave\n+   --  uncomfortably on the above example).\n+\n+   --  We have two approaches to helping to control this situation. First we\n+   --  make every attempt to avoid swallowing the last END; if we can be\n+   --  sure that some error will result from doing so. In particular, we won't\n+   --  accept the END; unless it is exactly correct (in particular it must not\n+   --  have incorrect name tokens), and we won't accept it if it is immediately\n+   --  followed by end of file, WITH or SEPARATE (all tokens that unmistakeably\n+   --  signal the start of a compilation unit, and which therefore allow us to\n+   --  reserve the END; for the outer level.) For more details on this aspect\n+   --  of the handling, see package Par.Endh.\n+\n+   --  If we can avoid eating up the END; then the result in the absense of\n+   --  any additional steps would be to post a missing END referring back to\n+   --  the subprogram with the bogus IS. Similarly, if the enclosing package\n+   --  has no BEGIN, then the result is a missing BEGIN message, which again\n+   --  refers back to the subprogram header.\n+\n+   --  Such an error message is not too bad (it's already a big improvement\n+   --  over what many parsers do), but it's not ideal, because the declarations\n+   --  following the IS have been absorbed into the wrong scope. In the above\n+   --  case, this could result for example in a bogus complaint that the body\n+   --  of D was missing from the package.\n+\n+   --  To catch at least some of these cases, we take the following additional\n+   --  steps. First, a subprogram body is marked as having a suspicious IS if\n+   --  the declaration line is followed by a line which starts with a symbol\n+   --  that can start a declaration in the same column, or to the left of the\n+   --  column in which the FUNCTION or PROCEDURE starts (normal style is to\n+   --  indent any declarations which really belong a subprogram). If such a\n+   --  subprogram encounters a missing BEGIN or missing END, then we decide\n+   --  that the IS should have been a semicolon, and the subprogram body node\n+   --  is marked (by setting the Bad_Is_Detected flag true. Note that we do\n+   --  not do this for library level procedures, only for nested procedures,\n+   --  since for library level procedures, we must have a body.\n+\n+   --  The processing for a declarative part checks to see if the last\n+   --  declaration scanned is marked in this way, and if it is, the tree\n+   --  is modified to reflect the IS being interpreted as a semicolon.\n+\n+   ---------------------------------------------------\n+   -- Parser Type Definitions and Control Variables --\n+   ---------------------------------------------------\n+\n+   --  The following variable and associated type declaration are used by the\n+   --  expression parsing routines to return more detailed information about\n+   --  the categorization of a parsed expression.\n+\n+   type Expr_Form_Type is (\n+      EF_Simple_Name,  -- Simple name, i.e. possibly qualified identifier\n+      EF_Name,         -- Simple expression which could also be a name\n+      EF_Simple,       -- Simple expression which is not call or name\n+      EF_Range_Attr,   -- Range attribute reference\n+      EF_Non_Simple);  -- Expression that is not a simple expression\n+\n+   Expr_Form : Expr_Form_Type;\n+\n+   --  The following type is used for calls to P_Subprogram, P_Package, P_Task,\n+   --  P_Protected to indicate which of several possibilities is acceptable.\n+\n+   type Pf_Rec is record\n+      Spcn : Boolean;                  -- True if specification OK\n+      Decl : Boolean;                  -- True if declaration OK\n+      Gins : Boolean;                  -- True if generic instantiation OK\n+      Pbod : Boolean;                  -- True if proper body OK\n+      Rnam : Boolean;                  -- True if renaming declaration OK\n+      Stub : Boolean;                  -- True if body stub OK\n+      Fil1 : Boolean;                  -- Filler to fill to 8 bits\n+      Fil2 : Boolean;                  -- Filler to fill to 8 bits\n+   end record;\n+   pragma Pack (Pf_Rec);\n+\n+   function T return Boolean renames True;\n+   function F return Boolean renames False;\n+\n+   Pf_Decl_Gins_Pbod_Rnam_Stub : constant Pf_Rec :=\n+                                             Pf_Rec'(F, T, T, T, T, T, F, F);\n+   Pf_Decl                     : constant Pf_Rec :=\n+                                             Pf_Rec'(F, T, F, F, F, F, F, F);\n+   Pf_Decl_Gins_Pbod_Rnam      : constant Pf_Rec :=\n+                                             Pf_Rec'(F, T, T, T, T, F, F, F);\n+   Pf_Decl_Pbod                : constant Pf_Rec :=\n+                                             Pf_Rec'(F, T, F, T, F, F, F, F);\n+   Pf_Pbod                     : constant Pf_Rec :=\n+                                             Pf_Rec'(F, F, F, T, F, F, F, F);\n+   Pf_Spcn                     : constant Pf_Rec :=\n+                                             Pf_Rec'(T, F, F, F, F, F, F, F);\n+   --  The above are the only allowed values of Pf_Rec arguments\n+\n+   type SS_Rec is record\n+      Eftm : Boolean;      -- ELSIF can terminate sequence\n+      Eltm : Boolean;      -- ELSE can terminate sequence\n+      Extm : Boolean;      -- EXCEPTION can terminate sequence\n+      Ortm : Boolean;      -- OR can terminate sequence\n+      Sreq : Boolean;      -- at least one statement required\n+      Tatm : Boolean;      -- THEN ABORT can terminate sequence\n+      Whtm : Boolean;      -- WHEN can terminate sequence\n+      Unco : Boolean;      -- Unconditional terminate after one statement\n+   end record;\n+   pragma Pack (SS_Rec);\n+\n+   SS_Eftm_Eltm_Sreq : constant SS_Rec := SS_Rec'(T, T, F, F, T, F, F, F);\n+   SS_Eltm_Ortm_Tatm : constant SS_Rec := SS_Rec'(F, T, F, T, F, T, F, F);\n+   SS_Extm_Sreq      : constant SS_Rec := SS_Rec'(F, F, T, F, T, F, F, F);\n+   SS_None           : constant SS_Rec := SS_Rec'(F, F, F, F, F, F, F, F);\n+   SS_Ortm_Sreq      : constant SS_Rec := SS_Rec'(F, F, F, T, T, F, F, F);\n+   SS_Sreq           : constant SS_Rec := SS_Rec'(F, F, F, F, T, F, F, F);\n+   SS_Sreq_Whtm      : constant SS_Rec := SS_Rec'(F, F, F, F, T, F, T, F);\n+   SS_Whtm           : constant SS_Rec := SS_Rec'(F, F, F, F, F, F, T, F);\n+   SS_Unco           : constant SS_Rec := SS_Rec'(F, F, F, F, F, F, F, T);\n+\n+   Label_List : Elist_Id;\n+   --  List of label nodes for labels appearing in the current compilation.\n+   --  Used by Par.Labl to construct the corresponding implicit declarations.\n+\n+   -----------------\n+   -- Scope Table --\n+   -----------------\n+\n+   --  The scope table, also referred to as the scope stack, is used to\n+   --  record the current scope context. It is organized as a stack, with\n+   --  inner nested entries corresponding to higher entries on the stack.\n+   --  An entry is made when the parser encounters the opening of a nested\n+   --  construct (such as a record, task, package etc.), and then package\n+   --  Par.Endh uses this stack to deal with END lines (including properly\n+   --  dealing with END nesting errors).\n+\n+   type SS_End_Type is\n+   --  Type of end entry required for this scope. The last two entries are\n+   --  used only in the subprogram body case to mark the case of a suspicious\n+   --  IS, or a bad IS (i.e. suspicions confirmed by missing BEGIN or END).\n+   --  See separate section on dealing with IS used in place of semicolon.\n+   --  Note that for many purposes E_Name, E_Suspicious_Is and E_Bad_Is are\n+   --  treated the same (E_Suspicious_Is and E_Bad_Is are simply special cases\n+   --  of E_Name). They are placed at the end of the enumeration so that a\n+   --  test for >= E_Name catches all three cases efficiently.\n+\n+      (E_Dummy,           -- dummy entry at outer level\n+       E_Case,            -- END CASE;\n+       E_If,              -- END IF;\n+       E_Loop,            -- END LOOP;\n+       E_Record,          -- END RECORD;\n+       E_Select,          -- END SELECT;\n+       E_Name,            -- END [name];\n+       E_Suspicious_Is,   -- END [name]; (case of suspicious IS)\n+       E_Bad_Is);         -- END [name]; (case of bad IS)\n+\n+   --  The following describes a single entry in the scope table\n+\n+   type Scope_Table_Entry is record\n+      Etyp : SS_End_Type;\n+      --  Type of end entry, as per above description\n+\n+      Lreq : Boolean;\n+      --  A flag indicating whether the label, if present, is required to\n+      --  appear on the end line. It is referenced only in the case of\n+      --  Etyp = E_Name or E_Suspicious_Is where the name may or may not be\n+      --  required (yes for labeled block, no in other cases). Note that for\n+      --  all cases except begin, the question of whether a label is required\n+      --  can be determined from the other fields (for loop, it is required if\n+      --  it is present, and for the other constructs it is never required or\n+      --  allowed).\n+\n+      Ecol : Column_Number;\n+      --  Contains the absolute column number (with tabs expanded) of the\n+      --  the expected column of the end assuming normal Ada indentation\n+      --  usage. If the RM_Column_Check mode is set, this value is used for\n+      --  generating error messages about indentation. Otherwise it is used\n+      --  only to control heuristic error recovery actions.\n+\n+      Labl : Node_Id;\n+      --  This field is used only for the LOOP and BEGIN cases, and is the\n+      --  Node_Id value of the label name. For all cases except child units,\n+      --  this value is an entity whose Chars field contains the name pointer\n+      --  that identifies the label uniquely. For the child unit case the Labl\n+      --  field references an N_Defining_Program_Unit_Name node for the name.\n+      --  For cases other than LOOP or BEGIN, the Label field is set to Error,\n+      --  indicating that it is an error to have a label on the end line.\n+\n+      Decl : List_Id;\n+      --  Points to the list of declarations (i.e. the declarative part)\n+      --  associated with this construct. It is set only in the END [name]\n+      --  cases, and is set to No_List for all other cases which do not have a\n+      --  declarative unit associated with them. This is used for determining\n+      --  the proper location for implicit label declarations.\n+\n+      Node : Node_Id;\n+      --  Empty except in the case of entries for IF and CASE statements,\n+      --  in which case it contains the N_If_Statement or N_Case_Statement\n+      --  node. This is used for setting the End_Span field.\n+\n+      Sloc : Source_Ptr;\n+      --  Source location of the opening token of the construct. This is\n+      --  used to refer back to this line in error messages (such as missing\n+      --  or incorrect end lines). The Sloc field is not used, and is not set,\n+      --  if a label is present (the Labl field provides the text name of the\n+      --  label in this case, which is fine for error messages).\n+\n+      S_Is : Source_Ptr;\n+      --  S_Is is relevant only if Etyp is set to E_Suspicious_Is or\n+      --  E_Bad_Is. It records the location of the IS that is considered\n+      --  to be suspicious.\n+\n+      Junk : Boolean;\n+      --  A boolean flag that is set true if the opening entry is the dubious\n+      --  result of some prior error, e.g. a record entry where the record\n+      --  keyword was missing. It is used to suppress the issuing of a\n+      --  corresponding junk complaint about the end line (we do not want\n+      --  to complain about a missing end record when there was no record).\n+   end record;\n+\n+   --  The following declares the scope table itself. The Last field is the\n+   --  stack pointer, so that Scope.Table (Scope.Last) is the top entry. The\n+   --  oldest entry, at Scope_Stack (0), is a dummy entry with Etyp set to\n+   --  E_Dummy, and the other fields undefined. This dummy entry ensures that\n+   --  Scope_Stack (Scope_Stack_Ptr).Etyp can always be tested, and that the\n+   --  scope stack pointer is always in range.\n+\n+   package Scope is new Table.Table (\n+     Table_Component_Type => Scope_Table_Entry,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => 50,\n+     Table_Increment      => 100,\n+     Table_Name           => \"Scope\");\n+\n+   ---------------------------------\n+   -- Parsing Routines by Chapter --\n+   ---------------------------------\n+\n+   --  Uncommented declarations in this section simply parse the construct\n+   --  corresponding to their name, and return an ID value for the Node or\n+   --  List that is created.\n+\n+   package Ch2 is\n+      function P_Identifier                           return Node_Id;\n+      function P_Pragma                               return Node_Id;\n+\n+      function P_Pragmas_Opt return List_Id;\n+      --  This function scans for a sequence of pragmas in other than a\n+      --  declaration sequence or statement sequence context. All pragmas\n+      --  can appear except pragmas Assert and Debug, which are only allowed\n+      --  in a declaration or statement sequence context.\n+\n+      procedure P_Pragmas_Misplaced;\n+      --  Skips misplaced pragmas with a complaint\n+\n+      procedure P_Pragmas_Opt (List : List_Id);\n+      --  Parses optional pragmas and appends them to the List\n+   end Ch2;\n+\n+   package Ch3 is\n+      Missing_Begin_Msg : Error_Msg_Id;\n+      --  This variable is set by a call to P_Declarative_Part. Normally it\n+      --  is set to No_Error_Msg, indicating that no special processing is\n+      --  required by the caller. The special case arises when a statement\n+      --  is found in the sequence of declarations. In this case the Id of\n+      --  the message issued (\"declaration expected\") is preserved in this\n+      --  variable, then the caller can change it to an appropriate missing\n+      --  begin message if indeed the BEGIN is missing.\n+\n+      function P_Access_Definition                    return Node_Id;\n+      function P_Access_Type_Definition               return Node_Id;\n+      function P_Array_Type_Definition                return Node_Id;\n+      function P_Basic_Declarative_Items              return List_Id;\n+      function P_Constraint_Opt                       return Node_Id;\n+      function P_Declarative_Part                     return List_Id;\n+      function P_Defining_Identifier                  return Node_Id;\n+      function P_Discrete_Choice_List                 return List_Id;\n+      function P_Discrete_Range                       return Node_Id;\n+      function P_Discrete_Subtype_Definition          return Node_Id;\n+      function P_Known_Discriminant_Part_Opt          return List_Id;\n+      function P_Signed_Integer_Type_Definition       return Node_Id;\n+      function P_Range                                return Node_Id;\n+      function P_Range_Or_Subtype_Mark                return Node_Id;\n+      function P_Range_Constraint                     return Node_Id;\n+      function P_Record_Definition                    return Node_Id;\n+      function P_Subtype_Indication                   return Node_Id;\n+      function P_Subtype_Mark                         return Node_Id;\n+      function P_Subtype_Mark_Resync                  return Node_Id;\n+      function P_Unknown_Discriminant_Part_Opt        return Boolean;\n+\n+      procedure P_Component_Items (Decls : List_Id);\n+      --  Scan out one or more component items and append them to the\n+      --  given list. Only scans out more than one declaration in the\n+      --  case where the source has a single declaration with multiple\n+      --  defining identifiers.\n+\n+      function Init_Expr_Opt (P : Boolean := False) return Node_Id;\n+      --  If an initialization expression is present (:= expression), then\n+      --  it is scanned out and returned, otherwise Empty is returned if no\n+      --  initialization expression is present. This procedure also handles\n+      --  certain common error cases cleanly. The parameter P indicates if\n+      --  a right paren can follow the expression (default = no right paren\n+      --  allowed).\n+\n+      procedure Skip_Declaration (S : List_Id);\n+      --  Used when scanning statements to skip past a mispaced declaration\n+      --  The declaration is scanned out and appended to the given list.\n+      --  Token is known to be a declaration token (in Token_Class_Declk)\n+      --  on entry, so there definition is a declaration to be scanned.\n+\n+      function P_Subtype_Indication (Subtype_Mark : Node_Id) return Node_Id;\n+      --  This version of P_Subtype_Indication is called when the caller has\n+      --  already scanned out the subtype mark which is passed as a parameter.\n+\n+      function P_Subtype_Mark_Attribute (Type_Node : Node_Id) return Node_Id;\n+      --  Parse a subtype mark attribute. The caller has already parsed the\n+      --  subtype mark, which is passed in as the argument, and has checked\n+      --  that the current token is apostrophe.\n+\n+   end Ch3;\n+\n+   package Ch4 is\n+      function P_Aggregate                            return Node_Id;\n+      function P_Expression                           return Node_Id;\n+      function P_Expression_No_Right_Paren            return Node_Id;\n+      function P_Expression_Or_Range_Attribute        return Node_Id;\n+      function P_Function_Name                        return Node_Id;\n+      function P_Name                                 return Node_Id;\n+      function P_Qualified_Simple_Name                return Node_Id;\n+      function P_Qualified_Simple_Name_Resync         return Node_Id;\n+      function P_Simple_Expression                    return Node_Id;\n+      function P_Simple_Expression_Or_Range_Attribute return Node_Id;\n+\n+      function P_Qualified_Expression\n+        (Subtype_Mark : Node_Id)\n+         return         Node_Id;\n+      --  This routine scans out a qualified expression when the caller has\n+      --  already scanned out the name and apostrophe of the construct.\n+\n+   end Ch4;\n+\n+   package Ch5 is\n+\n+      function P_Statement_Name (Name_Node : Node_Id) return Node_Id;\n+      --  Given a node representing a name (which is a call), converts it\n+      --  to the syntactically corresponding procedure call statement.\n+\n+      function P_Sequence_Of_Statements (SS_Flags : SS_Rec) return List_Id;\n+      --  The argument indicates the acceptable termination tokens.\n+      --  See body in Par.Ch5 for details of the use of this parameter.\n+\n+      procedure Parse_Decls_Begin_End (Parent : Node_Id);\n+      --  Parses declarations and handled statement sequence, setting\n+      --  fields of Parent node appropriately.\n+\n+   end Ch5;\n+\n+   package Ch6 is\n+      function P_Designator                           return Node_Id;\n+      function P_Defining_Program_Unit_Name           return Node_Id;\n+      function P_Formal_Part                          return List_Id;\n+      function P_Parameter_Profile                    return List_Id;\n+      function P_Return_Statement                     return Node_Id;\n+      function P_Subprogram_Specification             return Node_Id;\n+\n+      procedure P_Mode (Node : Node_Id);\n+      --  Sets In_Present and/or Out_Present flags in Node scanning past\n+      --  IN, OUT or IN OUT tokens in the source.\n+\n+      function P_Subprogram (Pf_Flags : Pf_Rec)       return Node_Id;\n+      --  Scans out any construct starting with either of the keywords\n+      --  PROCEDURE or FUNCTION. The parameter indicates which possible\n+      --  possible kinds of construct (body, spec, instantiation etc.)\n+      --  are permissible in the current context.\n+\n+   end Ch6;\n+\n+   package Ch7 is\n+      function P_Package (Pf_Flags : Pf_Rec) return Node_Id;\n+      --  Scans out any construct starting with the keyword PACKAGE. The\n+      --  parameter indicates which possible kinds of construct (body, spec,\n+      --  instantiation etc.) are permissible in the current context.\n+   end Ch7;\n+\n+   package Ch8 is\n+      function P_Use_Clause                           return Node_Id;\n+   end Ch8;\n+\n+   package Ch9 is\n+      function P_Abort_Statement                      return Node_Id;\n+      function P_Abortable_Part                       return Node_Id;\n+      function P_Accept_Statement                     return Node_Id;\n+      function P_Delay_Statement                      return Node_Id;\n+      function P_Entry_Body                           return Node_Id;\n+      function P_Protected                            return Node_Id;\n+      function P_Requeue_Statement                    return Node_Id;\n+      function P_Select_Statement                     return Node_Id;\n+      function P_Task                                 return Node_Id;\n+      function P_Terminate_Alternative                return Node_Id;\n+   end Ch9;\n+\n+   package Ch10 is\n+      function P_Compilation_Unit                     return Node_Id;\n+      --  Note: this function scans a single compilation unit, and\n+      --  checks that an end of file follows this unit, diagnosing\n+      --  any unexpected input as an error, and then skipping it, so\n+      --  that Token is set to Tok_EOF on return. An exception is in\n+      --  syntax-only mode, where multiple compilation units are\n+      --  permitted. In this case, P_Compilation_Unit does not check\n+      --  for end of file and there may be more compilation units to\n+      --  scan. The caller can uniquely detect this situation by the\n+      --  fact that Token is not set to Tok_EOF on return.\n+   end Ch10;\n+\n+   package Ch11 is\n+      function P_Handled_Sequence_Of_Statements       return Node_Id;\n+      function P_Raise_Statement                      return Node_Id;\n+\n+      function Parse_Exception_Handlers               return List_Id;\n+      --  Parses the partial construct EXCEPTION followed by a list of\n+      --  exception handlers which appears in a number of productions,\n+      --  and returns the list of exception handlers.\n+\n+   end Ch11;\n+\n+   package Ch12 is\n+      function P_Generic                              return Node_Id;\n+      function P_Generic_Actual_Part_Opt              return List_Id;\n+   end Ch12;\n+\n+   package Ch13 is\n+      function P_Representation_Clause                return Node_Id;\n+\n+      function P_Code_Statement (Subtype_Mark : Node_Id) return Node_Id;\n+      --  Function to parse a code statement. The caller has scanned out\n+      --  the name to be used as the subtype mark (but has not checked that\n+      --  it is suitable for use as a subtype mark, i.e. is either an\n+      --  identifier or a selected component). The current token is an\n+      --  apostrophe and the following token is either a left paren or\n+      --  RANGE (the latter being an error to be caught by P_Code_Statement.\n+   end Ch13;\n+\n+   --  Note: the parsing for annexe J features (i.e. obsolescent features)\n+   --  is found in the logical section where these features would be if\n+   --  they were not obsolescent. In particular:\n+\n+   --    Delta constraint is parsed by P_Delta_Constraint (3.5.9)\n+   --    At clause is parsed by P_At_Clause (13.1)\n+   --    Mod clause is parsed by P_Mod_Clause (13.5.1)\n+\n+   ------------------\n+   -- End Handling --\n+   ------------------\n+\n+   --  Routines for handling end lines, including scope recovery\n+\n+   package Endh is\n+\n+      function Check_End return Boolean;\n+      --  Called when an end sequence is required. In the absence of an error\n+      --  situation, Token contains Tok_End on entry, but in a missing end\n+      --  case, this may not be the case. Pop_End_Context is used to determine\n+      --  the appropriate action to be taken. The returned result is True if\n+      --  an End sequence was encountered and False if no End sequence was\n+      --  present. This occurs if the END keyword encountered was determined\n+      --  to be improper and deleted (i.e. Pop_End_Context set End_Action to\n+      --  Skip_And_Reject). Note that the END sequence includes a semicolon,\n+      --  except in the case of END RECORD, where a semicolon follows the END\n+      --  RECORD, but is not part of the record type definition itself.\n+\n+      procedure End_Skip;\n+      --  Skip past an end sequence. On entry Token contains Tok_End, and we\n+      --  we know that the end sequence is syntactically incorrect, and that\n+      --  an appropriate error message has already been posted. The mission\n+      --  is simply to position the scan pointer to be the best guess of the\n+      --  position after the end sequence. We do not issue any additional\n+      --  error messages while carrying this out.\n+\n+      procedure End_Statements (Parent : Node_Id := Empty);\n+      --  Called when an end is required or expected to terminate a sequence\n+      --  of statements. The caller has already made an appropriate entry in\n+      --  the Scope.Table to describe the expected form of the end. This can\n+      --  only be used in cases where the only appropriate terminator is end.\n+      --  If Parent is non-empty, then if a correct END line is encountered,\n+      --  the End_Label field of Parent is set appropriately.\n+\n+   end Endh;\n+\n+   ------------------------------------\n+   -- Resynchronization After Errors --\n+   ------------------------------------\n+\n+   --  These procedures are used to resynchronize after errors. Following an\n+   --  error which is not immediately locally recoverable, the exception\n+   --  Error_Resync is raised. The handler for Error_Resync typically calls\n+   --  one of these recovery procedures to resynchronize the source position\n+   --  to a point from which parsing can be restarted.\n+\n+   --  Note: these procedures output an information message that tokens are\n+   --  being skipped, but this message is output only if the option for\n+   --  Multiple_Errors_Per_Line is set in Options.\n+\n+   package Sync is\n+\n+      procedure Resync_Choice;\n+      --  Used if an error occurs scanning a choice. The scan pointer is\n+      --  advanced to the next vertical bar, arrow, or semicolon, whichever\n+      --  comes first. We also quit if we encounter an end of file.\n+\n+      procedure Resync_Expression;\n+      --  Used if an error is detected during the parsing of an expression.\n+      --  It skips past tokens until either a token which cannot be part of\n+      --  an expression is encountered (an expression terminator), or if a\n+      --  comma or right parenthesis or vertical bar is encountered at the\n+      --  current parenthesis level (a parenthesis level counter is maintained\n+      --  to carry out this test).\n+\n+      procedure Resync_Past_Semicolon;\n+      --  Used if an error occurs while scanning a sequence of declarations.\n+      --  The scan pointer is positioned past the next semicolon and the scan\n+      --  resumes. The scan is also resumed on encountering a token which\n+      --  starts a declaration (but we make sure to skip at least one token\n+      --  in this case, to avoid getting stuck in a loop).\n+\n+      procedure Resync_Past_Semicolon_Or_To_Loop_Or_Then;\n+      --  Used if an error occurs while scanning a sequence of statements.\n+      --  The scan pointer is positioned past the next semicolon, or to the\n+      --  next occurrence of either then or loop, and the scan resumes.\n+\n+      procedure Resync_To_When;\n+      --  Used when an error occurs scanning an entry index specification.\n+      --  The scan pointer is positioned to the next WHEN (or to IS or\n+      --  semicolon if either of these appear before WHEN, indicating\n+      --  another error has occurred).\n+\n+      procedure Resync_Semicolon_List;\n+      --  Used if an error occurs while scanning a parenthesized list of items\n+      --  separated by semicolons. The scan pointer is advanced to the next\n+      --  semicolon or right parenthesis at the outer parenthesis level, or\n+      --  to the next is or RETURN keyword occurence, whichever comes first.\n+\n+      procedure Resync_Cunit;\n+      --  Synchronize to next token which could be the start of a compilation\n+      --  unit, or to the end of file token.\n+\n+   end Sync;\n+\n+   -------------------------\n+   -- Token Scan Routines --\n+   -------------------------\n+\n+   --  Routines to check for expected tokens\n+\n+   package Tchk is\n+\n+      --  Procedures with names of the form T_xxx, where Tok_xxx is a token\n+      --  name, check that the current token matches the required token, and\n+      --  if so, scan past it. If not, an error is issued indicating that\n+      --  the required token is not present (xxx expected). In most cases, the\n+      --  scan pointer is not moved in the not-found case, but there are some\n+      --  exceptions to this, see for example T_Id, where the scan pointer is\n+      --  moved across a literal appearing where an identifier is expected.\n+\n+      procedure T_Abort;\n+      procedure T_Arrow;\n+      procedure T_At;\n+      procedure T_Body;\n+      procedure T_Box;\n+      procedure T_Colon;\n+      procedure T_Colon_Equal;\n+      procedure T_Comma;\n+      procedure T_Dot_Dot;\n+      procedure T_For;\n+      procedure T_Greater_Greater;\n+      procedure T_Identifier;\n+      procedure T_In;\n+      procedure T_Is;\n+      procedure T_Left_Paren;\n+      procedure T_Loop;\n+      procedure T_Mod;\n+      procedure T_New;\n+      procedure T_Of;\n+      procedure T_Or;\n+      procedure T_Private;\n+      procedure T_Range;\n+      procedure T_Record;\n+      procedure T_Right_Paren;\n+      procedure T_Semicolon;\n+      procedure T_Then;\n+      procedure T_Type;\n+      procedure T_Use;\n+      procedure T_When;\n+      procedure T_With;\n+\n+      --  Procedures have names of the form TF_xxx, where Tok_xxx is a token\n+      --  name check that the current token matches the required token, and\n+      --  if so, scan past it. If not, an error message is issued indicating\n+      --  that the required token is not present (xxx expected).\n+\n+      --  If the missing token is at the end of the line, then control returns\n+      --  immediately after posting the message. If there are remaining tokens\n+      --  on the current line, a search is conducted to see if the token\n+      --  appears later on the current line, as follows:\n+\n+      --  A call to Scan_Save is issued and a forward search for the token\n+      --  is carried out. If the token is found on the current line before a\n+      --  semicolon, then it is scanned out and the scan continues from that\n+      --  point. If not the scan is restored to the point where it was missing.\n+\n+      procedure TF_Arrow;\n+      procedure TF_Is;\n+      procedure TF_Loop;\n+      procedure TF_Return;\n+      procedure TF_Semicolon;\n+      procedure TF_Then;\n+      procedure TF_Use;\n+\n+   end Tchk;\n+\n+   ----------------------\n+   -- Utility Routines --\n+   ----------------------\n+\n+   package Util is\n+\n+      function Bad_Spelling_Of (T : Token_Type) return Boolean;\n+      --  This function is called in an error situation. It checks if the\n+      --  current token is an identifier whose name is a plausible bad\n+      --  spelling of the given keyword token, and if so, issues an error\n+      --  message, sets Token from T, and returns True. Otherwise Token is\n+      --  unchanged, and False is returned.\n+\n+      procedure Check_Bad_Layout;\n+      --  Check for bad indentation in RM checking mode. Used for statements\n+      --  and declarations. Checks if current token is at start of line and\n+      --  is exdented from the current expected end column, and if so an\n+      --  error message is generated.\n+\n+      procedure Check_Misspelling_Of (T : Token_Type);\n+      pragma Inline (Check_Misspelling_Of);\n+      --  This is similar to the function above, except that it does not\n+      --  return a result. It is typically used in a situation where any\n+      --  identifier is an error, and it makes sense to simply convert it\n+      --  to the given token if it is a plausible misspelling of it.\n+\n+      procedure Check_95_Keyword (Token_95, Next : Token_Type);\n+      --  This routine checks if the token after the current one matches the\n+      --  Next argument. If so, the scan is backed up to the current token\n+      --  and Token_Type is changed to Token_95 after issuing an appropriate\n+      --  error message (\"(Ada 83) keyword xx cannot be used\"). If not,\n+      --  the scan is backed up with Token_Type unchanged. This routine\n+      --  is used to deal with an attempt to use a 95 keyword in Ada 83\n+      --  mode. The caller has typically checked that the current token,\n+      --  an identifier, matches one of the 95 keywords.\n+\n+      procedure Check_Simple_Expression (E : Node_Id);\n+      --  Given an expression E, that has just been scanned, so that Expr_Form\n+      --  is still set, outputs an error if E is a non-simple expression. E is\n+      --  not modified by this call.\n+\n+      procedure Check_Simple_Expression_In_Ada_83 (E : Node_Id);\n+      --  Like Check_Simple_Expression, except that the error message is only\n+      --  given when operating in Ada 83 mode, and includes \"in Ada 83\".\n+\n+      function Check_Subtype_Mark (Mark : Node_Id) return Node_Id;\n+      --  Called to check that a node representing a name (or call) is\n+      --  suitable for a subtype mark, i.e, that it is an identifier or\n+      --  a selected component. If so, or if it is already Error, then\n+      --  it is returned unchanged. Otherwise an error message is issued\n+      --  and Error is returned.\n+\n+      function Comma_Present return Boolean;\n+      --  Used in comma delimited lists to determine if a comma is present, or\n+      --  can reasonably be assumed to have been present (an error message is\n+      --  generated in the latter case). If True is returned, the scan has been\n+      --  positioned past the comma. If False is returned, the scan position\n+      --  is unchanged. Note that all comma-delimited lists are terminated by\n+      --  a right paren, so the only legitimate tokens when Comma_Present is\n+      --  called are right paren and comma. If some other token is found, then\n+      --  Comma_Present has the job of deciding whether it is better to pretend\n+      --  a comma was present, post a message for a missing comma and return\n+      --  True, or return False and let the caller diagnose the missing right\n+      --  parenthesis.\n+\n+      procedure Discard_Junk_Node (N : Node_Id);\n+      procedure Discard_Junk_List (L : List_Id);\n+      pragma Inline (Discard_Junk_Node);\n+      pragma Inline (Discard_Junk_List);\n+      --  These procedures do nothing at all, their effect is simply to discard\n+      --  the argument. A typical use is to skip by some junk that is not\n+      --  expected in the current context.\n+\n+      procedure Ignore (T : Token_Type);\n+      --  If current token matches T, then give an error message and skip\n+      --  past it, otherwise the call has no effect at all. T may be any\n+      --  reserved word token, or comma, left or right paren, or semicolon.\n+\n+      function Is_Reserved_Identifier return Boolean;\n+      --  Test if current token is a reserved identifier. This test is based\n+      --  on the token being a keyword and being spelled in typical identifier\n+      --  style (i.e. starting with an upper case letter).\n+\n+      procedure Merge_Identifier (Prev : Node_Id; Nxt : Token_Type);\n+      --  Called when the previous token is an identifier (whose Token_Node\n+      --  value is given by Prev) to check if current token is an identifier\n+      --  that can be merged with the previous one adding an underscore. The\n+      --  merge is only attempted if the following token matches Nxt. If all\n+      --  conditions are met, an error message is issued, and the merge is\n+      --  carried out, modifying the Chars field of Prev.\n+\n+      procedure No_Constraint;\n+      --  Called in a place where no constraint is allowed, but one might\n+      --  appear due to a common error (e.g. after the type mark in a procedure\n+      --  parameter. If a constraint is present, an error message is posted,\n+      --  and the constraint is scanned and discarded.\n+\n+      function No_Right_Paren (Expr : Node_Id) return Node_Id;\n+      --  Function to check for no right paren at end of expression, returns\n+      --  its argument if no right paren, else flags paren and returns Error.\n+\n+      procedure Push_Scope_Stack;\n+      pragma Inline (Push_Scope_Stack);\n+      --  Push a new entry onto the scope stack. Scope.Last (the stack pointer)\n+      --  is incremented. The Junk field is preinitialized to False. The caller\n+      --  is expected to fill in all remaining entries of the new new top stack\n+      --  entry at Scope.Table (Scope.Last).\n+\n+      procedure Pop_Scope_Stack;\n+      --  Pop an entry off the top of the scope stack. Scope_Last (the scope\n+      --  table stack pointer) is decremented by one. It is a fatal error to\n+      --  try to pop off the dummy entry at the bottom of the stack (i.e.\n+      --  Scope.Last must be non-zero at the time of call).\n+\n+      function Separate_Present return Boolean;\n+      --  Determines if the current token is either Tok_Separate, or an\n+      --  identifier that is a possible misspelling of \"separate\" followed\n+      --  by a semicolon. True is returned if so, otherwise False.\n+\n+      procedure Signal_Bad_Attribute;\n+      --  The current token is an identifier that is supposed to be an\n+      --  attribute identifier but is not. This routine posts appropriate\n+      --  error messages, including a check for a near misspelling.\n+\n+      function Token_Is_At_Start_Of_Line return Boolean;\n+      pragma Inline (Token_Is_At_Start_Of_Line);\n+      --  Determines if the current token is the first token on the line\n+\n+   end Util;\n+\n+   ---------------------------------------\n+   -- Specialized Syntax Check Routines --\n+   ---------------------------------------\n+\n+   function Prag (Pragma_Node : Node_Id; Semi : Source_Ptr) return Node_Id;\n+   --  This function is passed a tree for a pragma that has been scanned out.\n+   --  The pragma is syntactically well formed according to the general syntax\n+   --  for pragmas and the pragma identifier is for one of the recognized\n+   --  pragmas. It performs specific syntactic checks for specific pragmas.\n+   --  The result is the input node if it is OK, or Error otherwise. The\n+   --  reason that this is separated out is to facilitate the addition\n+   --  of implementation defined pragmas. The second parameter records the\n+   --  location of the semicolon following the pragma (this is needed for\n+   --  correct processing of the List and Page pragmas). The returned value\n+   --  is a copy of Pragma_Node, or Error if an error is found.\n+\n+   -------------------------\n+   -- Subsidiary Routines --\n+   -------------------------\n+\n+   procedure Labl;\n+   --  This procedure creates implicit label declarations for all label that\n+   --  are declared in the current unit. Note that this could conceptually\n+   --  be done at the point where the labels are declared, but it is tricky\n+   --  to do it then, since the tree is not hooked up at the point where the\n+   --  label is declared (e.g. a sequence of statements is not yet attached\n+   --  to its containing scope at the point a label in the sequence is found)\n+\n+   procedure Load;\n+   --  This procedure loads all subsidiary units that are required by this\n+   --  unit, including with'ed units, specs for bodies, and parents for child\n+   --  units. It does not load bodies for inlined procedures and generics,\n+   --  since we don't know till semantic analysis is complete what is needed.\n+\n+   -----------\n+   -- Stubs --\n+   -----------\n+\n+   --  The package bodies can see all routines defined in all other subpackages\n+\n+   use Ch2;\n+   use Ch3;\n+   use Ch4;\n+   use Ch5;\n+   use Ch6;\n+   use Ch7;\n+   use Ch8;\n+   use Ch9;\n+   use Ch10;\n+   use Ch11;\n+   use Ch12;\n+   use Ch13;\n+\n+   use Endh;\n+   use Tchk;\n+   use Sync;\n+   use Util;\n+\n+   package body Ch2 is separate;\n+   package body Ch3 is separate;\n+   package body Ch4 is separate;\n+   package body Ch5 is separate;\n+   package body Ch6 is separate;\n+   package body Ch7 is separate;\n+   package body Ch8 is separate;\n+   package body Ch9 is separate;\n+   package body Ch10 is separate;\n+   package body Ch11 is separate;\n+   package body Ch12 is separate;\n+   package body Ch13 is separate;\n+\n+   package body Endh is separate;\n+   package body Tchk is separate;\n+   package body Sync is separate;\n+   package body Util is separate;\n+\n+   function Prag (Pragma_Node : Node_Id; Semi : Source_Ptr) return Node_Id\n+     is separate;\n+\n+   procedure Labl is separate;\n+   procedure Load is separate;\n+\n+   ---------\n+   -- Par --\n+   ---------\n+\n+--  This function is the parse routine called at the outer level. It parses\n+--  the current compilation unit and adds implicit label declarations.\n+\n+begin\n+   --  Deal with configuration pragmas case first\n+\n+   if Configuration_Pragmas then\n+      declare\n+         Ecount  : constant Int := Errors_Detected;\n+         Pragmas : List_Id := Empty_List;\n+         P_Node  : Node_Id;\n+\n+      begin\n+         loop\n+            if Token = Tok_EOF then\n+               return Pragmas;\n+\n+            elsif Token /= Tok_Pragma then\n+               Error_Msg_SC (\"only pragmas allowed in configuration file\");\n+               return Error_List;\n+\n+            else\n+               P_Node := P_Pragma;\n+\n+               if Errors_Detected > Ecount then\n+                  return Error_List;\n+               end if;\n+\n+               if Chars (P_Node) > Last_Configuration_Pragma_Name\n+                 and then Chars (P_Node) /= Name_Source_Reference\n+               then\n+                  Error_Msg_SC\n+                    (\"only configuration pragmas allowed \" &\n+                     \"in configuration file\");\n+                  return Error_List;\n+               end if;\n+\n+               Append (P_Node, Pragmas);\n+            end if;\n+         end loop;\n+      end;\n+\n+   --  Normal case of compilation unit\n+\n+   else\n+      Save_Opt_Config_Switches (Save_Config_Switches);\n+\n+      --  Special processing for language defined units. For this purpose\n+      --  we do NOT consider the renamings in annex J as predefined. That\n+      --  allows users to compile their own versions of these files, and\n+      --  in particular, in the VMS implementation, the DEC versions can\n+      --  be substituted for the standard Ada 95 versions.\n+\n+      if Is_Predefined_File_Name\n+           (Fname => File_Name (Current_Source_File),\n+            Renamings_Included => False)\n+      then\n+         Set_Opt_Config_Switches\n+           (Is_Internal_File_Name (File_Name (Current_Source_File)));\n+\n+         --  If this is the main unit, disallow compilation unless the -gnatg\n+         --  (GNAT mode) switch is set (from a user point of view, the rule is\n+         --  that language defined units cannot be recompiled).\n+\n+         --  However, an exception is s-rpc, and its children. We test this\n+         --  by looking at the character after the minus, the rule is that\n+         --  System.RPC and its children are the only children in System\n+         --  whose second level name can start with the letter r.\n+\n+         Get_Name_String (File_Name (Current_Source_File));\n+\n+         if (Name_Len < 3 or else Name_Buffer (1 .. 3) /= \"s-r\")\n+           and then Current_Source_Unit = Main_Unit\n+           and then not GNAT_Mode\n+           and then Operating_Mode = Generate_Code\n+         then\n+            Error_Msg_SC (\"language defined units may not be recompiled\");\n+         end if;\n+      end if;\n+\n+      --  The following loop runs more than once only in syntax check mode\n+      --  where we allow multiple compilation units in the same file.\n+\n+      loop\n+         Set_Opt_Config_Switches\n+           (Is_Internal_File_Name (File_Name (Current_Source_File)));\n+\n+         --  Initialize scope table and other parser control variables\n+\n+         Compiler_State := Parsing;\n+         Scope.Init;\n+         Scope.Increment_Last;\n+         Scope.Table (0).Etyp := E_Dummy;\n+         SIS_Entry_Active := False;\n+         Last_Resync_Point := No_Location;\n+\n+         Label_List := New_Elmt_List;\n+         Unit_Node := P_Compilation_Unit;\n+\n+         --  If we are not at an end of file, then this means that we are\n+         --  in syntax scan mode, and we can have another compilation unit,\n+         --  otherwise we will exit from the loop.\n+\n+         exit when Token = Tok_EOF;\n+         Restore_Opt_Config_Switches (Save_Config_Switches);\n+         Set_Comes_From_Source_Default (False);\n+      end loop;\n+\n+      --  Now that we have completely parsed the source file, we can\n+      --  complete the source file table entry.\n+\n+      Complete_Source_File_Entry;\n+\n+      --  An internal error check, the scope stack should now be empty\n+\n+      pragma Assert (Scope.Last = 0);\n+\n+      --  Remaining steps are to create implicit label declarations and to\n+      --  load required subsidiary sources. These steps are required only\n+      --  if we are doing semantic checking.\n+\n+      if Operating_Mode /= Check_Syntax or else Debug_Flag_F then\n+         Par.Labl;\n+         Par.Load;\n+      end if;\n+\n+      --  Restore settings of switches saved on entry\n+\n+      Restore_Opt_Config_Switches (Save_Config_Switches);\n+      Set_Comes_From_Source_Default (False);\n+      return Empty_List;\n+   end if;\n+\n+end Par;"}, {"sha": "c1110a0b135dce1ccbbf9bef1c7b0ca41dd364fe", "filename": "gcc/ada/par.ads", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fpar.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.ads?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,44 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                  P A R                                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.14 $                             --\n+--                                                                          --\n+--     Copyright (C) 1992,1993,1994,1995 Free Software Foundation, Inc.     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  The Par function and its subunits contains all the parsing routines\n+--  for the top down recursive descent parser that constructs the parse tree\n+\n+with Types; use Types;\n+\n+function Par (Configuration_Pragmas : Boolean) return List_Id;\n+--  Top level parsing routine. There are two cases:\n+--\n+--  If Configuration_Pragmas is False, Par parses a compilation unit in the\n+--  current source file and sets the Cunit, Cunit_Entity and Unit_Name fields\n+--  of the units table entry for Current_Source_Unit. On return the parse tree\n+--  is complete, and decorated with any required implicit label declarations.\n+--  The value returned in this case is always No_List.\n+--\n+--  If Configuration_Pragmas is True, Par parses a list of configuration\n+--  pragmas from the current source file, and returns the list of pragmas."}, {"sha": "aa793025f8a384c7364ff4ea0010a0efc7bcc886", "filename": "gcc/ada/prj-attr.adb", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,211 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P R J . A T T R                             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $\n+--                                                                          --\n+--             Copyright (C) 2001 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Characters.Handling; use Ada.Characters.Handling;\n+with Namet;     use Namet;\n+with Output;    use Output;\n+\n+package body Prj.Attr is\n+\n+   --  Names end with '#'\n+   --  Package names are preceded by 'P'\n+   --  Attribute names are preceded by two capital letters:\n+   --    'S' for Single or 'L' for list, then\n+   --    'V' for single variable, 'A' for associative array, or 'B' for both.\n+   --  End is indicated by two consecutive '#'.\n+\n+   Initialisation_Data : constant String :=\n+\n+   --  project attributes\n+\n+     \"SVobject_dir#\" &\n+     \"LVsource_dirs#\" &\n+     \"LVsource_files#\" &\n+     \"SVsource_list_file#\" &\n+     \"SVlibrary_dir#\" &\n+     \"SVlibrary_name#\" &\n+     \"SVlibrary_kind#\" &\n+     \"SVlibrary_elaboration#\" &\n+     \"SVlibrary_version#\" &\n+     \"LVmain#\" &\n+\n+   --  package Naming\n+\n+     \"Pnaming#\" &\n+     \"SVspecification_append#\" &\n+     \"SVbody_append#\" &\n+     \"SVseparate_append#\" &\n+     \"SVcasing#\" &\n+     \"SVdot_replacement#\" &\n+     \"SAspecification#\" &\n+     \"SAbody_part#\" &\n+\n+   --  package Compiler\n+\n+     \"Pcompiler#\" &\n+     \"LBswitches#\" &\n+     \"SVlocal_configuration_pragmas#\" &\n+\n+   --  package gnatmake\n+\n+     \"Pgnatmake#\" &\n+     \"LBswitches#\" &\n+     \"SVglobal_configuration_pragmas#\" &\n+\n+   --  package gnatls\n+\n+     \"Pgnatls#\" &\n+     \"LVswitches#\" &\n+\n+   --  package gnatbind\n+\n+     \"Pgnatbind#\" &\n+     \"LBswitches#\" &\n+\n+   --  package gnatlink\n+\n+     \"Pgnatlink#\" &\n+     \"LBswitches#\" &\n+\n+     \"#\";\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+      Start             : Positive           := Initialisation_Data'First;\n+      Finish            : Positive           := Start;\n+      Current_Package   : Package_Node_Id    := Empty_Package;\n+      Current_Attribute : Attribute_Node_Id  := Empty_Attribute;\n+      Is_An_Attribute   : Boolean            := False;\n+      Kind_1            : Variable_Kind      := Undefined;\n+      Kind_2            : Attribute_Kind     := Single;\n+      Package_Name      : Name_Id            := No_Name;\n+      Attribute_Name    : Name_Id            := No_Name;\n+      First_Attribute   : Attribute_Node_Id  := Attribute_First;\n+   begin\n+\n+      --  Make sure the two tables are empty\n+\n+      Attributes.Set_Last (Attributes.First);\n+      Package_Attributes.Set_Last (Package_Attributes.First);\n+\n+      while Initialisation_Data (Start) /= '#' loop\n+         Is_An_Attribute := True;\n+         case Initialisation_Data (Start) is\n+            when 'P' =>\n+               --  New allowed package\n+               Start := Start + 1;\n+               Finish := Start;\n+               while Initialisation_Data (Finish) /= '#' loop\n+                  Finish := Finish + 1;\n+               end loop;\n+               Name_Len := Finish - Start;\n+               Name_Buffer (1 .. Name_Len) :=\n+                 To_Lower (Initialisation_Data (Start .. Finish - 1));\n+               Package_Name := Name_Find;\n+               for Index in Package_First .. Package_Attributes.Last loop\n+                  if Package_Name = Package_Attributes.Table (Index).Name then\n+                     Write_Line (\"Duplicate package name \"\"\" &\n+                                 Initialisation_Data (Start .. Finish - 1) &\n+                                 \"\"\" in Prj.Attr body.\");\n+                     raise Program_Error;\n+                  end if;\n+               end loop;\n+\n+               Is_An_Attribute := False;\n+               Current_Attribute := Empty_Attribute;\n+               Package_Attributes.Increment_Last;\n+               Current_Package := Package_Attributes.Last;\n+               Package_Attributes.Table (Current_Package).Name :=\n+                 Package_Name;\n+               Start := Finish + 1;\n+            when 'S' =>\n+               Kind_1 := Single;\n+            when 'L' =>\n+               Kind_1 := List;\n+            when others =>\n+               raise Program_Error;\n+         end case;\n+\n+         if Is_An_Attribute then\n+            --  New attribute\n+            Start := Start + 1;\n+            case Initialisation_Data (Start) is\n+               when 'V' =>\n+                  Kind_2 := Single;\n+               when 'A' =>\n+                  Kind_2 := Associative_Array;\n+               when 'B' =>\n+                  Kind_2 := Both;\n+               when others =>\n+                  raise Program_Error;\n+            end case;\n+            Start := Start + 1;\n+            Finish := Start;\n+            while Initialisation_Data (Finish) /= '#' loop\n+               Finish := Finish + 1;\n+            end loop;\n+            Name_Len := Finish - Start;\n+            Name_Buffer (1 .. Name_Len) :=\n+              To_Lower (Initialisation_Data (Start .. Finish - 1));\n+            Attribute_Name := Name_Find;\n+            Attributes.Increment_Last;\n+            if Current_Attribute = Empty_Attribute then\n+               First_Attribute := Attributes.Last;\n+               if Current_Package /= Empty_Package then\n+                  Package_Attributes.Table (Current_Package).First_Attribute\n+                    := Attributes.Last;\n+               end if;\n+            else\n+               --  Check that there are no duplicate attributes\n+               for Index in First_Attribute .. Attributes.Last - 1 loop\n+                  if Attribute_Name =\n+                    Attributes.Table (Index).Name then\n+                     Write_Line (\"Duplicate attribute name \"\"\" &\n+                                 Initialisation_Data (Start .. Finish - 1) &\n+                                 \"\"\" in Prj.Attr body.\");\n+                     raise Program_Error;\n+                  end if;\n+               end loop;\n+               Attributes.Table (Current_Attribute).Next :=\n+                 Attributes.Last;\n+            end if;\n+            Current_Attribute := Attributes.Last;\n+            Attributes.Table (Current_Attribute) :=\n+              (Name    => Attribute_Name,\n+               Kind_1  => Kind_1,\n+               Kind_2  => Kind_2,\n+               Next    => Empty_Attribute);\n+            Start := Finish + 1;\n+         end if;\n+      end loop;\n+   end Initialize;\n+\n+end Prj.Attr;"}, {"sha": "ba4bb2e543b4c9cffb4ee94103bf39a4064bc140", "filename": "gcc/ada/prj-attr.ads", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.ads?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,108 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P R J . A T T R                             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.1 $\n+--                                                                          --\n+--             Copyright (C) 2001 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+--\n+--  This package defines allowed packages and attributes in GNAT project\n+--  files.\n+\n+with Types; use Types;\n+with Table;\n+\n+package Prj.Attr is\n+\n+   --  Define the allowed attributes\n+\n+   Attributes_Initial   : constant := 50;\n+   Attributes_Increment : constant := 50;\n+\n+   Attribute_Node_Low_Bound  : constant := 0;\n+   Attribute_Node_High_Bound : constant := 099_999_999;\n+\n+   type Attribute_Node_Id is\n+     range Attribute_Node_Low_Bound .. Attribute_Node_High_Bound;\n+\n+   First_Attribute_Node_Id : constant Attribute_Node_Id\n+     := Attribute_Node_Low_Bound;\n+\n+   Empty_Attribute : constant Attribute_Node_Id\n+     := Attribute_Node_Low_Bound;\n+\n+   type Attribute_Kind is (Single, Associative_Array, Both);\n+\n+   type Attribute_Record is record\n+      Name     : Name_Id;\n+      Kind_1   : Variable_Kind;\n+      Kind_2   : Attribute_Kind;\n+      Next     : Attribute_Node_Id;\n+   end record;\n+\n+   package Attributes is\n+      new Table.Table (Table_Component_Type => Attribute_Record,\n+                       Table_Index_Type     => Attribute_Node_Id,\n+                       Table_Low_Bound      => First_Attribute_Node_Id,\n+                       Table_Initial        => Attributes_Initial,\n+                       Table_Increment      => Attributes_Increment,\n+                       Table_Name           => \"Prj.Attr.Attributes\");\n+\n+   Attribute_First : constant Attribute_Node_Id := First_Attribute_Node_Id + 1;\n+\n+   --  Define the allowed packages\n+\n+   Packages_Initial   : constant := 10;\n+   Packages_Increment : constant := 10;\n+\n+   Package_Node_Low_Bound  : constant := 0;\n+   Package_Node_High_Bound : constant := 099_999_999;\n+\n+   type Package_Node_Id is\n+     range Package_Node_Low_Bound .. Package_Node_High_Bound;\n+\n+   First_Package_Node_Id : constant Package_Node_Id\n+     := Package_Node_Low_Bound;\n+\n+   Empty_Package : constant Package_Node_Id := Package_Node_Low_Bound;\n+\n+   type Package_Record is record\n+      Name            : Name_Id;\n+      First_Attribute : Attribute_Node_Id;\n+   end record;\n+\n+   package Package_Attributes is\n+      new Table.Table (Table_Component_Type => Package_Record,\n+                       Table_Index_Type     => Package_Node_Id,\n+                       Table_Low_Bound      => First_Package_Node_Id,\n+                       Table_Initial        => Packages_Initial,\n+                       Table_Increment      => Packages_Increment,\n+                       Table_Name           => \"Prj.Attr.Packages\");\n+\n+   Package_First : constant Package_Node_Id := Package_Node_Low_Bound + 1;\n+\n+   procedure Initialize;\n+   --  Initialize the two tables above (Attributes and Package_Attributes).\n+   --  This procedure should be called by Prj.Initialize.\n+\n+end Prj.Attr;"}, {"sha": "3447e18f57c8a029992c0e63224466ec1b01a312", "filename": "gcc/ada/prj-com.adb", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-com.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-com.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-com.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,49 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P R J . C O M                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.1 $\n+--                                                                          --\n+--             Copyright (C) 2000 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Namet;   use Namet;\n+with Stringt; use Stringt;\n+\n+package body Prj.Com is\n+\n+   ----------\n+   -- Hash --\n+   ----------\n+\n+   function Hash (Name : Name_Id) return Header_Num is\n+   begin\n+      return Hash (Get_Name_String (Name));\n+   end Hash;\n+\n+   function Hash (Name : String_Id) return Header_Num is\n+   begin\n+      String_To_Name_Buffer (Name);\n+      return Hash (Name_Buffer (1 .. Name_Len));\n+   end Hash;\n+\n+end Prj.Com;"}, {"sha": "ddb7d0f8ef7d69d54451f184deef3c0bca0871d4", "filename": "gcc/ada/prj-com.ads", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-com.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-com.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-com.ads?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,92 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P R J . C O M                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  The following package declares data types for GNAT project.\n+--  These data types are used in the bodies of the Prj hierarchy.\n+\n+with GNAT.HTable;\n+with Table;\n+with Types; use Types;\n+\n+package Prj.Com is\n+\n+   --  At one point, this package was private.\n+   --  It cannot be private, because it is used outside of\n+   --  the Prj hierarchy.\n+\n+   Tool_Name : Name_Id := No_Name;\n+\n+   Current_Verbosity : Verbosity := Default;\n+\n+   type Spec_Or_Body is\n+     (Specification, Body_Part);\n+\n+   type File_Name_Data is record\n+      Name         : Name_Id := No_Name;\n+      Path         : Name_Id := No_Name;\n+      Project      : Project_Id := No_Project;\n+      Needs_Pragma : Boolean := False;\n+   end record;\n+   --  File and Path name of a spec or body.\n+\n+   type File_Names_Data is array (Spec_Or_Body) of File_Name_Data;\n+\n+   type Unit_Id is new Nat;\n+   No_Unit : constant Unit_Id := 0;\n+   type Unit_Data is record\n+      Name       : Name_Id    := No_Name;\n+      File_Names : File_Names_Data;\n+   end record;\n+   --  File and Path names of a unit, with a reference to its\n+   --  GNAT Project File.\n+\n+   package Units is new Table.Table\n+     (Table_Component_Type => Unit_Data,\n+      Table_Index_Type     => Unit_Id,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 100,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Prj.Com.Units\");\n+\n+   type Header_Num is range 0 .. 2047;\n+\n+   function Hash is new GNAT.HTable.Hash (Header_Num => Header_Num);\n+\n+   function Hash (Name : Name_Id) return Header_Num;\n+\n+   function Hash (Name : String_Id) return Header_Num;\n+\n+   package Units_Htable is new GNAT.HTable.Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Unit_Id,\n+      No_Element => No_Unit,\n+      Key        => Name_Id,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+\n+end Prj.Com;"}, {"sha": "65f7e43a4b6e76ba1ddb92ce3a5c8b5794a8fa4a", "filename": "gcc/ada/prj-dect.adb", "status": "added", "additions": 942, "deletions": 0, "changes": 942, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-dect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-dect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,942 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P R J . D E C T                             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $\n+--                                                                          --\n+--             Copyright (C) 2001 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Errout;     use Errout;\n+with Prj.Strt;\n+with Prj.Tree;   use Prj.Tree;\n+with Scans;      use Scans;\n+with Sinfo;      use Sinfo;\n+with Types;      use Types;\n+with Prj.Attr;   use Prj.Attr;\n+\n+package body Prj.Dect is\n+\n+   type Zone is (In_Project, In_Package, In_Case_Construction);\n+\n+   procedure Parse_Attribute_Declaration\n+     (Attribute         : out Project_Node_Id;\n+      First_Attribute   : Attribute_Node_Id;\n+      Current_Project   : Project_Node_Id;\n+      Current_Package   : Project_Node_Id);\n+   --  Parse an attribute declaration.\n+\n+   procedure Parse_Case_Construction\n+     (Case_Construction : out Project_Node_Id;\n+      First_Attribute   : Attribute_Node_Id;\n+      Current_Project   : Project_Node_Id;\n+      Current_Package   : Project_Node_Id);\n+   --  Parse a case construction\n+\n+   procedure Parse_Declarative_Items\n+     (Declarations      : out Project_Node_Id;\n+      In_Zone           : Zone;\n+      First_Attribute   : Attribute_Node_Id;\n+      Current_Project   : Project_Node_Id;\n+      Current_Package   : Project_Node_Id);\n+   --  Parse declarative items. Depending on In_Zone, some declarative\n+   --  items may be forbiden.\n+\n+   procedure Parse_Package_Declaration\n+     (Package_Declaration : out Project_Node_Id;\n+      Current_Project     : Project_Node_Id);\n+   --  Parse a package declaration\n+\n+   procedure Parse_String_Type_Declaration\n+     (String_Type       : out Project_Node_Id;\n+      Current_Project   : Project_Node_Id;\n+      First_Attribute   : Attribute_Node_Id);\n+   --  type <name> is ( <literal_string> { , <literal_string> } ) ;\n+\n+   procedure Parse_Variable_Declaration\n+     (Variable          : out Project_Node_Id;\n+      First_Attribute   : Attribute_Node_Id;\n+      Current_Project   : Project_Node_Id;\n+      Current_Package   : Project_Node_Id);\n+   --  Parse a variable assignment\n+   --  <variable_Name> := <expression>; OR\n+   --  <variable_Name> : <string_type_Name> := <string_expression>;\n+\n+   -----------\n+   -- Parse --\n+   -----------\n+\n+   procedure Parse\n+     (Declarations    : out Project_Node_Id;\n+      Current_Project : Project_Node_Id;\n+      Modifying       : Project_Node_Id)\n+   is\n+      First_Declarative_Item : Project_Node_Id := Empty_Node;\n+\n+   begin\n+      Declarations := Default_Project_Node (Of_Kind => N_Project_Declaration);\n+      Set_Location_Of (Declarations, To => Token_Ptr);\n+      Set_Modified_Project_Of (Declarations, To => Modifying);\n+      Parse_Declarative_Items\n+        (Declarations    => First_Declarative_Item,\n+         In_Zone         => In_Project,\n+         First_Attribute => Prj.Attr.Attribute_First,\n+         Current_Project => Current_Project,\n+         Current_Package => Empty_Node);\n+      Set_First_Declarative_Item_Of\n+        (Declarations, To => First_Declarative_Item);\n+   end Parse;\n+\n+   ---------------------------------\n+   -- Parse_Attribute_Declaration --\n+   ---------------------------------\n+\n+   procedure Parse_Attribute_Declaration\n+     (Attribute       : out Project_Node_Id;\n+      First_Attribute : Attribute_Node_Id;\n+      Current_Project : Project_Node_Id;\n+      Current_Package : Project_Node_Id)\n+   is\n+      Current_Attribute : Attribute_Node_Id := First_Attribute;\n+\n+   begin\n+      Attribute := Default_Project_Node (Of_Kind => N_Attribute_Declaration);\n+      Set_Location_Of (Attribute, To => Token_Ptr);\n+\n+      --  Scan past \"for\"\n+\n+      Scan;\n+\n+      Expect (Tok_Identifier, \"identifier\");\n+\n+      if Token = Tok_Identifier then\n+         Set_Name_Of (Attribute, To => Token_Name);\n+         Set_Location_Of (Attribute, To => Token_Ptr);\n+         while Current_Attribute /= Empty_Attribute\n+           and then\n+             Attributes.Table (Current_Attribute).Name /= Token_Name\n+         loop\n+            Current_Attribute := Attributes.Table (Current_Attribute).Next;\n+         end loop;\n+\n+         if Current_Attribute = Empty_Attribute then\n+            Error_Msg (\"undefined attribute\", Token_Ptr);\n+         end if;\n+\n+         Scan;\n+      end if;\n+\n+      if Token = Tok_Left_Paren then\n+         if Current_Attribute /= Empty_Attribute\n+           and then Attributes.Table (Current_Attribute).Kind_2 = Single\n+         then\n+            Error_Msg (\"this attribute cannot be an associative array\",\n+                       Location_Of (Attribute));\n+         end if;\n+\n+         Scan;\n+         Expect (Tok_String_Literal, \"literal string\");\n+\n+         if Token = Tok_String_Literal then\n+            Set_Associative_Array_Index_Of (Attribute, Strval (Token_Node));\n+            Scan;\n+         end if;\n+\n+         Expect (Tok_Right_Paren, \")\");\n+\n+         if Token = Tok_Right_Paren then\n+            Scan;\n+         end if;\n+\n+      else\n+         if Current_Attribute /= Empty_Attribute\n+           and then\n+             Attributes.Table (Current_Attribute).Kind_2 = Associative_Array\n+         then\n+            Error_Msg (\"this attribute need to be an associative array\",\n+                       Location_Of (Attribute));\n+         end if;\n+      end if;\n+\n+      if Current_Attribute /= Empty_Attribute then\n+         Set_Expression_Kind_Of\n+           (Attribute, To => Attributes.Table (Current_Attribute).Kind_1);\n+      end if;\n+\n+      Expect (Tok_Use, \"use\");\n+\n+      if Token = Tok_Use then\n+         Scan;\n+\n+         declare\n+            Expression_Location : constant Source_Ptr := Token_Ptr;\n+            Expression          : Project_Node_Id     := Empty_Node;\n+\n+         begin\n+            Prj.Strt.Parse_Expression\n+              (Expression      => Expression,\n+               Current_Project => Current_Project,\n+               Current_Package => Current_Package);\n+            Set_Expression_Of (Attribute, To => Expression);\n+\n+            if Current_Attribute /= Empty_Attribute\n+              and then Expression /= Empty_Node\n+              and then Attributes.Table (Current_Attribute).Kind_1 /=\n+                                          Expression_Kind_Of (Expression)\n+            then\n+               Error_Msg\n+                 (\"wrong expression kind for the attribute\",\n+                  Expression_Location);\n+            end if;\n+         end;\n+      end if;\n+\n+   end Parse_Attribute_Declaration;\n+\n+   -----------------------------\n+   -- Parse_Case_Construction --\n+   -----------------------------\n+\n+   procedure Parse_Case_Construction\n+     (Case_Construction : out Project_Node_Id;\n+      First_Attribute   : Attribute_Node_Id;\n+      Current_Project   : Project_Node_Id;\n+      Current_Package   : Project_Node_Id)\n+   is\n+      Current_Item      : Project_Node_Id := Empty_Node;\n+      Next_Item         : Project_Node_Id := Empty_Node;\n+      First_Case_Item   : Boolean := True;\n+\n+      Variable_Location : Source_Ptr := No_Location;\n+\n+      String_Type       : Project_Node_Id := Empty_Node;\n+\n+      Case_Variable     : Project_Node_Id := Empty_Node;\n+\n+      First_Declarative_Item : Project_Node_Id := Empty_Node;\n+\n+      First_Choice      : Project_Node_Id := Empty_Node;\n+\n+   begin\n+      Case_Construction  :=\n+        Default_Project_Node (Of_Kind => N_Case_Construction);\n+      Set_Location_Of (Case_Construction, To => Token_Ptr);\n+\n+      --  Scan past \"case\"\n+\n+      Scan;\n+\n+      --  Get the switch variable\n+\n+      Expect (Tok_Identifier, \"identifier\");\n+\n+      if Token = Tok_Identifier then\n+         Variable_Location := Token_Ptr;\n+         Prj.Strt.Parse_Variable_Reference\n+           (Variable        => Case_Variable,\n+            Current_Project => Current_Project,\n+            Current_Package => Current_Package);\n+         Set_Case_Variable_Reference_Of\n+           (Case_Construction, To => Case_Variable);\n+\n+      else\n+         if Token /= Tok_Is then\n+            Scan;\n+         end if;\n+      end if;\n+\n+      if Case_Variable /= Empty_Node then\n+         String_Type := String_Type_Of (Case_Variable);\n+\n+         if String_Type = Empty_Node then\n+            Error_Msg (\"this variable is not typed\", Variable_Location);\n+         end if;\n+      end if;\n+\n+      Expect (Tok_Is, \"is\");\n+\n+      if Token = Tok_Is then\n+\n+         --  Scan past \"is\"\n+\n+         Scan;\n+      end if;\n+\n+      Prj.Strt.Start_New_Case_Construction (String_Type);\n+\n+      When_Loop :\n+\n+      while Token = Tok_When loop\n+\n+         if First_Case_Item then\n+            Current_Item := Default_Project_Node (Of_Kind => N_Case_Item);\n+            Set_First_Case_Item_Of (Case_Construction, To => Current_Item);\n+            First_Case_Item := False;\n+\n+         else\n+            Next_Item := Default_Project_Node (Of_Kind => N_Case_Item);\n+            Set_Next_Case_Item (Current_Item, To => Next_Item);\n+            Current_Item := Next_Item;\n+         end if;\n+\n+         Set_Location_Of (Current_Item, To => Token_Ptr);\n+\n+         --  Scan past \"when\"\n+\n+         Scan;\n+\n+         if Token = Tok_Others then\n+\n+            --  Scan past \"others\"\n+\n+            Scan;\n+\n+            Expect (Tok_Arrow, \"=>\");\n+\n+            --  Empty_Node in Field1 of a Case_Item indicates\n+            --  the \"when others =>\" branch.\n+\n+            Set_First_Choice_Of (Current_Item, To => Empty_Node);\n+\n+            Parse_Declarative_Items\n+              (Declarations    => First_Declarative_Item,\n+               In_Zone         => In_Case_Construction,\n+               First_Attribute => First_Attribute,\n+               Current_Project => Current_Project,\n+               Current_Package => Current_Package);\n+\n+            --  \"when others =>\" must be the last branch, so save the\n+            --  Case_Item and exit\n+\n+            Set_First_Declarative_Item_Of\n+              (Current_Item, To => First_Declarative_Item);\n+            exit When_Loop;\n+\n+         else\n+            Prj.Strt.Parse_Choice_List (First_Choice => First_Choice);\n+            Set_First_Choice_Of (Current_Item, To => First_Choice);\n+\n+            Expect (Tok_Arrow, \"=>\");\n+\n+            Parse_Declarative_Items\n+              (Declarations    => First_Declarative_Item,\n+               In_Zone         => In_Case_Construction,\n+               First_Attribute => First_Attribute,\n+               Current_Project => Current_Project,\n+               Current_Package => Current_Package);\n+\n+            Set_First_Declarative_Item_Of\n+              (Current_Item, To => First_Declarative_Item);\n+\n+         end if;\n+      end loop When_Loop;\n+\n+      Prj.Strt.End_Case_Construction;\n+\n+      Expect (Tok_End, \"end case\");\n+\n+      if Token = Tok_End then\n+\n+         --  Scan past \"end\"\n+\n+         Scan;\n+\n+         Expect (Tok_Case, \"case\");\n+\n+      end if;\n+\n+      --  Scan past \"case\"\n+\n+      Scan;\n+\n+      Expect (Tok_Semicolon, \";\");\n+\n+   end Parse_Case_Construction;\n+\n+   -----------------------------\n+   -- Parse_Declarative_Items --\n+   -----------------------------\n+\n+   procedure Parse_Declarative_Items\n+     (Declarations    : out Project_Node_Id;\n+      In_Zone         : Zone;\n+      First_Attribute : Attribute_Node_Id;\n+      Current_Project : Project_Node_Id;\n+      Current_Package : Project_Node_Id)\n+   is\n+      Current_Declarative_Item : Project_Node_Id := Empty_Node;\n+      Next_Declarative_Item    : Project_Node_Id := Empty_Node;\n+      Current_Declaration      : Project_Node_Id := Empty_Node;\n+      Item_Location            : Source_Ptr      := No_Location;\n+\n+   begin\n+      Declarations := Empty_Node;\n+\n+      loop\n+         --  We are always positioned at the token that precedes\n+         --  the first token of the declarative element.\n+         --  Scan past it\n+\n+         Scan;\n+\n+         Item_Location := Token_Ptr;\n+\n+         case Token is\n+            when Tok_Identifier =>\n+\n+               if In_Zone = In_Case_Construction then\n+                  Error_Msg (\"a variable cannot be declared here\",\n+                             Token_Ptr);\n+               end if;\n+\n+               Parse_Variable_Declaration\n+                 (Current_Declaration,\n+                  First_Attribute => First_Attribute,\n+                  Current_Project => Current_Project,\n+                  Current_Package => Current_Package);\n+\n+            when Tok_For =>\n+\n+               Parse_Attribute_Declaration\n+                 (Attribute       => Current_Declaration,\n+                  First_Attribute => First_Attribute,\n+                  Current_Project => Current_Project,\n+                  Current_Package => Current_Package);\n+\n+            when Tok_Package =>\n+\n+               --  Package declaration\n+\n+               if In_Zone /= In_Project then\n+                  Error_Msg (\"a package cannot be declared here\", Token_Ptr);\n+               end if;\n+\n+               Parse_Package_Declaration\n+                 (Package_Declaration => Current_Declaration,\n+                  Current_Project     => Current_Project);\n+\n+            when Tok_Type =>\n+\n+               --  Type String Declaration\n+\n+               if In_Zone /= In_Project then\n+                  Error_Msg (\"a string type cannot be declared here\",\n+                             Token_Ptr);\n+               end if;\n+\n+               Parse_String_Type_Declaration\n+                 (String_Type     => Current_Declaration,\n+                  Current_Project => Current_Project,\n+                  First_Attribute => First_Attribute);\n+\n+            when Tok_Case =>\n+\n+               --  Case construction\n+\n+               Parse_Case_Construction\n+                 (Case_Construction => Current_Declaration,\n+                  First_Attribute   => First_Attribute,\n+                  Current_Project   => Current_Project,\n+                  Current_Package   => Current_Package);\n+\n+            when others =>\n+               exit;\n+\n+               --  We are leaving Parse_Declarative_Items positionned\n+               --  at the first token after the list of declarative items.\n+               --  It could be \"end\" (for a project, a package declaration or\n+               --  a case construction) or \"when\" (for a case construction)\n+\n+         end case;\n+\n+         Expect (Tok_Semicolon, \"; after declarative items\");\n+\n+         if Current_Declarative_Item = Empty_Node then\n+            Current_Declarative_Item :=\n+              Default_Project_Node (Of_Kind => N_Declarative_Item);\n+            Declarations  := Current_Declarative_Item;\n+\n+         else\n+            Next_Declarative_Item :=\n+              Default_Project_Node (Of_Kind => N_Declarative_Item);\n+            Set_Next_Declarative_Item\n+              (Current_Declarative_Item, To => Next_Declarative_Item);\n+            Current_Declarative_Item := Next_Declarative_Item;\n+         end if;\n+\n+         Set_Current_Item_Node\n+           (Current_Declarative_Item, To => Current_Declaration);\n+         Set_Location_Of (Current_Declarative_Item, To => Item_Location);\n+\n+      end loop;\n+\n+   end Parse_Declarative_Items;\n+\n+   -------------------------------\n+   -- Parse_Package_Declaration --\n+   -------------------------------\n+\n+   procedure Parse_Package_Declaration\n+     (Package_Declaration : out Project_Node_Id;\n+      Current_Project     : Project_Node_Id)\n+   is\n+      First_Attribute        : Attribute_Node_Id := Empty_Attribute;\n+      Current_Package        : Package_Node_Id   := Empty_Package;\n+      First_Declarative_Item : Project_Node_Id   := Empty_Node;\n+\n+   begin\n+      Package_Declaration :=\n+        Default_Project_Node (Of_Kind => N_Package_Declaration);\n+      Set_Location_Of (Package_Declaration, To => Token_Ptr);\n+\n+      --  Scan past \"package\"\n+\n+      Scan;\n+\n+      Expect (Tok_Identifier, \"identifier\");\n+\n+      if Token = Tok_Identifier then\n+\n+         Set_Name_Of (Package_Declaration, To => Token_Name);\n+\n+         for Index in Package_Attributes.First .. Package_Attributes.Last loop\n+            if Token_Name = Package_Attributes.Table (Index).Name then\n+               First_Attribute :=\n+                 Package_Attributes.Table (Index).First_Attribute;\n+               Current_Package := Index;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         if Current_Package  = Empty_Package then\n+            Error_Msg (\"not an allowed package name\", Token_Ptr);\n+\n+         else\n+            Set_Package_Id_Of (Package_Declaration, To => Current_Package);\n+\n+            declare\n+               Current : Project_Node_Id := First_Package_Of (Current_Project);\n+\n+            begin\n+               while Current /= Empty_Node\n+                 and then Name_Of (Current) /= Token_Name\n+               loop\n+                  Current := Next_Package_In_Project (Current);\n+               end loop;\n+\n+               if Current /= Empty_Node then\n+                  Error_Msg\n+                    (\"package declared twice in the same project\", Token_Ptr);\n+\n+               else\n+                  --  Add the package to the project list\n+\n+                  Set_Next_Package_In_Project\n+                    (Package_Declaration,\n+                     To => First_Package_Of (Current_Project));\n+                  Set_First_Package_Of\n+                    (Current_Project, To => Package_Declaration);\n+               end if;\n+            end;\n+         end if;\n+\n+         --  Scan past the package name\n+\n+         Scan;\n+\n+      end if;\n+\n+      if Token = Tok_Renames then\n+         --  Scan past \"renames\"\n+         Scan;\n+\n+         Expect (Tok_Identifier, \"identifier\");\n+\n+         if Token = Tok_Identifier then\n+            declare\n+               Project_Name : Name_Id := Token_Name;\n+               Clause       : Project_Node_Id :=\n+                                First_With_Clause_Of (Current_Project);\n+               The_Project  : Project_Node_Id := Empty_Node;\n+\n+            begin\n+               while Clause /= Empty_Node loop\n+                  The_Project := Project_Node_Of (Clause);\n+                  exit when Name_Of (The_Project) = Project_Name;\n+                  Clause := Next_With_Clause_Of (Clause);\n+               end loop;\n+\n+               if Clause = Empty_Node then\n+                  Error_Msg (\"not an imported project\", Token_Ptr);\n+               else\n+                  Set_Project_Of_Renamed_Package_Of\n+                    (Package_Declaration, To => The_Project);\n+               end if;\n+            end;\n+\n+            Scan;\n+            Expect (Tok_Dot, \".\");\n+\n+            if Token = Tok_Dot then\n+               Scan;\n+               Expect (Tok_Identifier, \"identifier\");\n+\n+               if Token = Tok_Identifier then\n+                  if Name_Of (Package_Declaration) /= Token_Name then\n+                     Error_Msg (\"not the same package name\", Token_Ptr);\n+                  elsif\n+                    Project_Of_Renamed_Package_Of (Package_Declaration)\n+                                                              /= Empty_Node\n+                  then\n+                     declare\n+                        Current : Project_Node_Id :=\n+                                    First_Package_Of\n+                                      (Project_Of_Renamed_Package_Of\n+                                         (Package_Declaration));\n+\n+                     begin\n+                        while Current /= Empty_Node\n+                          and then Name_Of (Current) /= Token_Name\n+                        loop\n+                           Current := Next_Package_In_Project (Current);\n+                        end loop;\n+\n+                        if Current = Empty_Node then\n+                           Error_Msg\n+                             (\"not a package declared by the project\",\n+                              Token_Ptr);\n+                        end if;\n+                     end;\n+                  end if;\n+\n+                  Scan;\n+               end if;\n+            end if;\n+         end if;\n+\n+         Expect (Tok_Semicolon, \";\");\n+\n+      elsif Token = Tok_Is then\n+\n+         Parse_Declarative_Items\n+           (Declarations    => First_Declarative_Item,\n+            In_Zone         => In_Package,\n+            First_Attribute => First_Attribute,\n+            Current_Project => Current_Project,\n+            Current_Package => Package_Declaration);\n+\n+         Set_First_Declarative_Item_Of\n+           (Package_Declaration, To => First_Declarative_Item);\n+\n+         Expect (Tok_End, \"end\");\n+\n+         if Token = Tok_End then\n+\n+            --  Scan past \"end\"\n+\n+            Scan;\n+         end if;\n+\n+         --  We should have the name of the package after \"end\"\n+\n+         Expect (Tok_Identifier, \"identifier\");\n+\n+         if Token = Tok_Identifier\n+           and then Name_Of (Package_Declaration) /= No_Name\n+           and then Token_Name /= Name_Of (Package_Declaration)\n+         then\n+            Error_Msg_Name_1 := Name_Of (Package_Declaration);\n+            Error_Msg (\"expected {\", Token_Ptr);\n+         end if;\n+\n+         if Token /= Tok_Semicolon then\n+\n+            --  Scan past the package name\n+\n+            Scan;\n+         end if;\n+\n+         Expect (Tok_Semicolon, \";\");\n+\n+      else\n+         Error_Msg (\"expected \"\"is\"\" or \"\"renames\"\"\", Token_Ptr);\n+      end if;\n+\n+   end Parse_Package_Declaration;\n+\n+   -----------------------------------\n+   -- Parse_String_Type_Declaration --\n+   -----------------------------------\n+\n+   procedure Parse_String_Type_Declaration\n+     (String_Type     : out Project_Node_Id;\n+      Current_Project : Project_Node_Id;\n+      First_Attribute : Attribute_Node_Id)\n+   is\n+      Current      : Project_Node_Id := Empty_Node;\n+      First_String : Project_Node_Id := Empty_Node;\n+\n+   begin\n+      String_Type :=\n+        Default_Project_Node (Of_Kind => N_String_Type_Declaration);\n+\n+      Set_Location_Of (String_Type, To => Token_Ptr);\n+\n+      --  Scan past \"type\"\n+\n+      Scan;\n+\n+      Expect (Tok_Identifier, \"identifier\");\n+\n+      if Token = Tok_Identifier then\n+         Set_Name_Of (String_Type, To => Token_Name);\n+\n+         Current := First_String_Type_Of (Current_Project);\n+         while Current /= Empty_Node\n+           and then\n+           Name_Of (Current) /= Token_Name\n+         loop\n+            Current := Next_String_Type (Current);\n+         end loop;\n+\n+         if Current /= Empty_Node then\n+            Error_Msg (\"duplicate string type name\", Token_Ptr);\n+         else\n+            Current := First_Variable_Of (Current_Project);\n+            while Current /= Empty_Node\n+              and then Name_Of (Current) /= Token_Name\n+            loop\n+               Current := Next_Variable (Current);\n+            end loop;\n+\n+            if Current /= Empty_Node then\n+               Error_Msg (\"already a variable name\", Token_Ptr);\n+            else\n+               Set_Next_String_Type\n+                 (String_Type, To => First_String_Type_Of (Current_Project));\n+               Set_First_String_Type_Of (Current_Project, To => String_Type);\n+            end if;\n+         end if;\n+\n+         --  Scan past the name\n+\n+         Scan;\n+      end if;\n+\n+      Expect (Tok_Is, \"is\");\n+\n+      if Token = Tok_Is then\n+         Scan;\n+      end if;\n+\n+      Expect (Tok_Left_Paren, \"(\");\n+\n+      if Token = Tok_Left_Paren then\n+         Scan;\n+      end if;\n+\n+      Prj.Strt.Parse_String_Type_List (First_String => First_String);\n+      Set_First_Literal_String (String_Type, To => First_String);\n+\n+      Expect (Tok_Right_Paren, \")\");\n+\n+      if Token = Tok_Right_Paren then\n+         Scan;\n+      end if;\n+\n+   end Parse_String_Type_Declaration;\n+\n+   --------------------------------\n+   -- Parse_Variable_Declaration --\n+   --------------------------------\n+\n+   procedure Parse_Variable_Declaration\n+     (Variable        : out Project_Node_Id;\n+      First_Attribute : Attribute_Node_Id;\n+      Current_Project : Project_Node_Id;\n+      Current_Package : Project_Node_Id)\n+   is\n+      Expression_Location      : Source_Ptr;\n+      String_Type_Name         : Name_Id := No_Name;\n+      Project_String_Type_Name : Name_Id := No_Name;\n+      Type_Location            : Source_Ptr := No_Location;\n+      Project_Location         : Source_Ptr := No_Location;\n+      Expression               : Project_Node_Id := Empty_Node;\n+      Variable_Name            : constant Name_Id := Token_Name;\n+\n+   begin\n+      Variable :=\n+        Default_Project_Node (Of_Kind => N_Variable_Declaration);\n+      Set_Name_Of (Variable, To => Variable_Name);\n+      Set_Location_Of (Variable, To => Token_Ptr);\n+\n+      --  Scan past the variable name\n+\n+      Scan;\n+\n+      if Token = Tok_Colon then\n+\n+         --  Typed string variable declaration\n+\n+         Scan;\n+         Set_Kind_Of (Variable, N_Typed_Variable_Declaration);\n+         Expect (Tok_Identifier, \"identifier\");\n+\n+         if Token = Tok_Identifier then\n+            String_Type_Name := Token_Name;\n+            Type_Location := Token_Ptr;\n+            Scan;\n+\n+            if Token = Tok_Dot then\n+               Project_String_Type_Name := String_Type_Name;\n+               Project_Location := Type_Location;\n+\n+               --  Scan past the dot\n+\n+               Scan;\n+               Expect (Tok_Identifier, \"identifier\");\n+\n+               if Token = Tok_Identifier then\n+                  String_Type_Name := Token_Name;\n+                  Type_Location := Token_Ptr;\n+                  Scan;\n+               else\n+                  String_Type_Name := No_Name;\n+               end if;\n+            end if;\n+\n+            if String_Type_Name /= No_Name then\n+               declare\n+                  Current : Project_Node_Id :=\n+                              First_String_Type_Of (Current_Project);\n+\n+               begin\n+                  if Project_String_Type_Name /= No_Name then\n+                     declare\n+                        The_Project_Name_And_Node : constant\n+                          Tree_Private_Part.Project_Name_And_Node :=\n+                          Tree_Private_Part.Projects_Htable.Get\n+                                                    (Project_String_Type_Name);\n+\n+                        use Tree_Private_Part;\n+\n+                     begin\n+                        if The_Project_Name_And_Node =\n+                          Tree_Private_Part.No_Project_Name_And_Node\n+                        then\n+                           Error_Msg (\"unknown project\", Project_Location);\n+                           Current := Empty_Node;\n+                        else\n+                           Current :=\n+                             First_String_Type_Of\n+                                         (The_Project_Name_And_Node.Node);\n+                        end if;\n+                     end;\n+                  end if;\n+\n+                  while Current /= Empty_Node\n+                    and then Name_Of (Current) /= String_Type_Name\n+                  loop\n+                     Current := Next_String_Type (Current);\n+                  end loop;\n+\n+                  if Current = Empty_Node then\n+                     Error_Msg (\"unknown string type\", Type_Location);\n+                  else\n+                     Set_String_Type_Of\n+                       (Variable, To => Current);\n+                  end if;\n+               end;\n+            end if;\n+         end if;\n+      end if;\n+\n+      Expect (Tok_Colon_Equal, \":=\");\n+\n+      if Token = Tok_Colon_Equal then\n+         Scan;\n+      end if;\n+\n+      --  Get the single string or string list value\n+\n+      Expression_Location := Token_Ptr;\n+\n+      Prj.Strt.Parse_Expression\n+        (Expression      => Expression,\n+         Current_Project => Current_Project,\n+         Current_Package => Current_Package);\n+      Set_Expression_Of (Variable, To => Expression);\n+\n+      if Expression /= Empty_Node then\n+         Set_Expression_Kind_Of\n+           (Variable, To => Expression_Kind_Of (Expression));\n+      end if;\n+\n+      declare\n+         The_Variable : Project_Node_Id := Empty_Node;\n+\n+      begin\n+         if Current_Package /= Empty_Node then\n+            The_Variable :=  First_Variable_Of (Current_Package);\n+         elsif Current_Project /= Empty_Node then\n+            The_Variable :=  First_Variable_Of (Current_Project);\n+         end if;\n+\n+         while The_Variable /= Empty_Node\n+           and then Name_Of (The_Variable) /= Variable_Name\n+         loop\n+            The_Variable := Next_Variable (The_Variable);\n+         end loop;\n+\n+         if The_Variable = Empty_Node then\n+            if Current_Package /= Empty_Node then\n+               Set_Next_Variable\n+                 (Variable, To => First_Variable_Of (Current_Package));\n+               Set_First_Variable_Of (Current_Package, To => Variable);\n+\n+            elsif Current_Project /= Empty_Node then\n+               Set_Next_Variable\n+                 (Variable, To => First_Variable_Of (Current_Project));\n+               Set_First_Variable_Of (Current_Project, To => Variable);\n+            end if;\n+\n+         else\n+            if Expression_Kind_Of (Variable) /= Undefined then\n+               if Expression_Kind_Of (The_Variable) = Undefined then\n+                  Set_Expression_Kind_Of\n+                    (The_Variable, To => Expression_Kind_Of (Variable));\n+\n+               else\n+                  if Expression_Kind_Of (The_Variable) /=\n+                                                 Expression_Kind_Of (Variable)\n+                  then\n+                     Error_Msg (\"wrong expression kind for the variable\",\n+                                Expression_Location);\n+                  end if;\n+               end if;\n+            end if;\n+         end if;\n+      end;\n+\n+   end Parse_Variable_Declaration;\n+\n+end Prj.Dect;"}, {"sha": "3072c573b6243f800fc2f67349c2e05e8ab05f1a", "filename": "gcc/ada/prj-dect.ads", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-dect.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-dect.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.ads?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,41 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P R J . D E C T                             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $\n+--                                                                          --\n+--             Copyright (C) 2000 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+--\n+--  Parse a list of declarative items in a project file.\n+\n+with Prj.Tree;\n+\n+private package Prj.Dect is\n+\n+   procedure Parse\n+     (Declarations    : out Prj.Tree.Project_Node_Id;\n+      Current_Project : Prj.Tree.Project_Node_Id;\n+      Modifying       : Prj.Tree.Project_Node_Id);\n+   --  Parse project declarative items.\n+\n+end Prj.Dect;"}, {"sha": "171a2d03c1a91e399d3e43a2975c437a63b066c7", "filename": "gcc/ada/prj-env.adb", "status": "added", "additions": 1471, "deletions": 0, "changes": 1471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,1471 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P R J . E N V                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.17 $\n+--                                                                          --\n+--             Copyright (C) 2001 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with GNAT.OS_Lib; use GNAT.OS_Lib;\n+with Namet;       use Namet;\n+with Opt;\n+with Osint;       use Osint;\n+with Output;      use Output;\n+with Prj.Com;     use Prj.Com;\n+with Prj.Util;\n+with Snames;      use Snames;\n+with Stringt;     use Stringt;\n+with Table;\n+\n+package body Prj.Env is\n+\n+   type Naming_Id is new Nat;\n+   No_Naming : constant Naming_Id := 0;\n+\n+   Ada_Path_Buffer : String_Access := new String (1 .. 1_000);\n+   --  A buffer where values for ADA_INCLUDE_PATH\n+   --  and ADA_OBJECTS_PATH are stored.\n+\n+   Ada_Path_Length : Natural := 0;\n+   --  Index of the last valid character in Ada_Path_Buffer.\n+\n+   package Namings is new Table.Table (\n+     Table_Component_Type => Naming_Data,\n+     Table_Index_Type     => Naming_Id,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 5,\n+     Table_Increment      => 100,\n+     Table_Name           => \"Prj.Env.Namings\");\n+\n+   Default_Naming : constant Naming_Id := Namings.First;\n+\n+   Global_Configuration_Pragmas : Name_Id;\n+   Local_Configuration_Pragmas  : Name_Id;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Body_Path_Name_Of (Unit : Unit_Id) return String;\n+   --  Returns the path name of the body of a unit.\n+   --  Compute it first, if necessary.\n+\n+   function Spec_Path_Name_Of (Unit : Unit_Id) return String;\n+   --  Returns the path name of the spec of a unit.\n+   --  Compute it first, if necessary.\n+\n+   procedure Add_To_Path (Path : String);\n+   --  Add Path to global variable Ada_Path_Buffer\n+   --  Increment Ada_Path_Length\n+\n+   ----------------------\n+   -- Ada_Include_Path --\n+   ----------------------\n+\n+   function Ada_Include_Path (Project : Project_Id) return String_Access is\n+\n+      procedure Add (Project : Project_Id);\n+      --  Add all the source directories of a project to the path,\n+      --  only if this project has not been visited.\n+      --  Call itself recursively for projects being modified,\n+      --  and imported projects.\n+      --  Add the project to the list Seen if this is the first time\n+      --  we call Add for this project.\n+\n+      ---------\n+      -- Add --\n+      ---------\n+\n+      procedure Add (Project : Project_Id) is\n+      begin\n+         --  If Seen is empty, then the project cannot have been\n+         --  visited.\n+\n+         if not Projects.Table (Project).Seen then\n+            Projects.Table (Project).Seen := True;\n+\n+            declare\n+               Data : Project_Data := Projects.Table (Project);\n+               List : Project_List := Data.Imported_Projects;\n+\n+               Current : String_List_Id := Data.Source_Dirs;\n+               Source_Dir : String_Element;\n+\n+            begin\n+               --  Add to path all source directories of this project\n+\n+               while Current /= Nil_String loop\n+                  if Ada_Path_Length > 0 then\n+                     Add_To_Path (Path => (1 => Path_Separator));\n+                  end if;\n+\n+                  Source_Dir := String_Elements.Table (Current);\n+                  String_To_Name_Buffer (Source_Dir.Value);\n+\n+                  declare\n+                     New_Path : constant String :=\n+                       Name_Buffer (1 .. Name_Len);\n+                  begin\n+                     Add_To_Path (New_Path);\n+                  end;\n+\n+                  Current := Source_Dir.Next;\n+               end loop;\n+\n+               --  Call Add to the project being modified, if any\n+\n+               if Data.Modifies /= No_Project then\n+                  Add (Data.Modifies);\n+               end if;\n+\n+               --  Call Add for each imported project, if any\n+\n+               while List /= Empty_Project_List loop\n+                  Add (Project_Lists.Table (List).Project);\n+                  List := Project_Lists.Table (List).Next;\n+               end loop;\n+            end;\n+         end if;\n+\n+      end Add;\n+\n+   --  Start of processing for Ada_Include_Path\n+\n+   begin\n+      --  If it is the first time we call this function for\n+      --  this project, compute the source path\n+\n+      if Projects.Table (Project).Include_Path = null then\n+         Ada_Path_Length := 0;\n+\n+         for Index in 1 .. Projects.Last loop\n+            Projects.Table (Index).Seen := False;\n+         end loop;\n+\n+         Add (Project);\n+         Projects.Table (Project).Include_Path :=\n+           new String'(Ada_Path_Buffer (1 .. Ada_Path_Length));\n+      end if;\n+\n+      return Projects.Table (Project).Include_Path;\n+   end Ada_Include_Path;\n+\n+   ----------------------\n+   -- Ada_Objects_Path --\n+   ----------------------\n+\n+   function Ada_Objects_Path\n+     (Project             : Project_Id;\n+      Including_Libraries : Boolean := True)\n+     return String_Access is\n+\n+      procedure Add (Project : Project_Id);\n+      --  Add all the object directory of a project to the path,\n+      --  only if this project has not been visited.\n+      --  Call itself recursively for projects being modified,\n+      --  and imported projects.\n+      --  Add the project to the list Seen if this is the first time\n+      --  we call Add for this project.\n+\n+      ---------\n+      -- Add --\n+      ---------\n+\n+      procedure Add (Project : Project_Id) is\n+      begin\n+\n+         --  If this project has not been seen yet\n+\n+         if not Projects.Table (Project).Seen then\n+            Projects.Table (Project).Seen := True;\n+\n+            declare\n+               Data : Project_Data := Projects.Table (Project);\n+               List : Project_List := Data.Imported_Projects;\n+\n+            begin\n+               --  Add to path the object directory of this project\n+               --  except if we don't include library project and\n+               --  this is a library project.\n+\n+               if (Data.Library and then Including_Libraries)\n+                 or else\n+                 (Data.Object_Directory /= No_Name\n+                   and then\n+                   (not Including_Libraries or else not Data.Library))\n+               then\n+                  if Ada_Path_Length > 0 then\n+                     Add_To_Path (Path => (1 => Path_Separator));\n+                  end if;\n+\n+                  --  For a library project, att the library directory\n+\n+                  if Data.Library then\n+                     declare\n+                        New_Path : constant String :=\n+                          Get_Name_String (Data.Library_Dir);\n+                     begin\n+                        Add_To_Path (New_Path);\n+                     end;\n+                  else\n+\n+                     --  For a non library project, add the object directory\n+                     declare\n+                        New_Path : constant String :=\n+                          Get_Name_String (Data.Object_Directory);\n+                     begin\n+                        Add_To_Path (New_Path);\n+                     end;\n+                  end if;\n+               end if;\n+\n+               --  Call Add to the project being modified, if any\n+\n+               if Data.Modifies /= No_Project then\n+                  Add (Data.Modifies);\n+               end if;\n+\n+               --  Call Add for each imported project, if any\n+\n+               while List /= Empty_Project_List loop\n+                  Add (Project_Lists.Table (List).Project);\n+                  List := Project_Lists.Table (List).Next;\n+               end loop;\n+            end;\n+\n+         end if;\n+      end Add;\n+\n+   --  Start of processing for Ada_Objects_Path\n+\n+   begin\n+      --  If it is the first time we call this function for\n+      --  this project, compute the objects path\n+\n+      if Projects.Table (Project).Objects_Path = null then\n+         Ada_Path_Length := 0;\n+\n+         for Index in 1 .. Projects.Last loop\n+            Projects.Table (Index).Seen := False;\n+         end loop;\n+\n+         Add (Project);\n+         Projects.Table (Project).Objects_Path :=\n+           new String'(Ada_Path_Buffer (1 .. Ada_Path_Length));\n+      end if;\n+\n+      return Projects.Table (Project).Objects_Path;\n+   end Ada_Objects_Path;\n+\n+   -----------------\n+   -- Add_To_Path --\n+   -----------------\n+\n+   procedure Add_To_Path (Path : String) is\n+   begin\n+      --  If Ada_Path_Buffer is too small, double it\n+\n+      if Ada_Path_Length + Path'Length > Ada_Path_Buffer'Last then\n+         declare\n+            New_Ada_Path_Buffer : constant String_Access :=\n+                                    new String\n+                                      (1 .. Ada_Path_Buffer'Last +\n+                                                 Ada_Path_Buffer'Last);\n+\n+         begin\n+            New_Ada_Path_Buffer (1 .. Ada_Path_Length) :=\n+              Ada_Path_Buffer (1 .. Ada_Path_Length);\n+            Ada_Path_Buffer := New_Ada_Path_Buffer;\n+         end;\n+      end if;\n+\n+      Ada_Path_Buffer\n+        (Ada_Path_Length + 1 .. Ada_Path_Length + Path'Length) := Path;\n+      Ada_Path_Length := Ada_Path_Length + Path'Length;\n+   end Add_To_Path;\n+\n+   -----------------------\n+   -- Body_Path_Name_Of --\n+   -----------------------\n+\n+   function Body_Path_Name_Of (Unit : Unit_Id) return String is\n+      Data : Unit_Data := Units.Table (Unit);\n+\n+   begin\n+      --  If we don't know the path name of the body of this unit,\n+      --  we compute it, and we store it.\n+\n+      if Data.File_Names (Body_Part).Path = No_Name then\n+         declare\n+            Current_Source : String_List_Id :=\n+              Projects.Table (Data.File_Names (Body_Part).Project).Sources;\n+            Path : GNAT.OS_Lib.String_Access;\n+\n+         begin\n+            --  By default, put the file name\n+\n+            Data.File_Names (Body_Part).Path :=\n+              Data.File_Names (Body_Part).Name;\n+\n+            --  For each source directory\n+\n+            while Current_Source /= Nil_String loop\n+               String_To_Name_Buffer\n+                 (String_Elements.Table (Current_Source).Value);\n+               Path :=\n+                 Locate_Regular_File\n+                 (Namet.Get_Name_String\n+                  (Data.File_Names (Body_Part).Name),\n+                  Name_Buffer (1 .. Name_Len));\n+\n+               --  If the file is in this directory,\n+               --  then we store the path, and we are done.\n+\n+               if Path /= null then\n+                  Name_Len := Path'Length;\n+                  Name_Buffer (1 .. Name_Len) := Path.all;\n+                  Data.File_Names (Body_Part).Path := Name_Enter;\n+                  exit;\n+\n+               else\n+                  Current_Source :=\n+                    String_Elements.Table (Current_Source).Next;\n+               end if;\n+            end loop;\n+\n+            Units.Table (Unit) := Data;\n+         end;\n+      end if;\n+\n+      --  Returned the value stored\n+\n+      return Namet.Get_Name_String (Data.File_Names (Body_Part).Path);\n+   end Body_Path_Name_Of;\n+\n+   --------------------------------\n+   -- Create_Config_Pragmas_File --\n+   --------------------------------\n+\n+   procedure Create_Config_Pragmas_File\n+     (For_Project  : Project_Id;\n+      Main_Project : Project_Id)\n+   is\n+      File_Name : Temp_File_Name;\n+      File      : File_Descriptor := Invalid_FD;\n+\n+      The_Packages : Package_Id;\n+      Gnatmake     : Prj.Package_Id;\n+      Compiler     : Prj.Package_Id;\n+\n+      Current_Unit : Unit_Id := Units.First;\n+\n+      First_Project : Project_List := Empty_Project_List;\n+\n+      Current_Project : Project_List;\n+      Current_Naming  : Naming_Id;\n+\n+      Global_Attribute : Variable_Value := Nil_Variable_Value;\n+      Local_Attribute  : Variable_Value := Nil_Variable_Value;\n+\n+      Global_Attribute_Present : Boolean := False;\n+      Local_Attribute_Present  : Boolean := False;\n+\n+      procedure Check (Project : Project_Id);\n+\n+      procedure Check_Temp_File;\n+      --  Check that a temporary file has been opened.\n+      --  If not, create one, and put its name in the project data,\n+      --  with the indication that it is a temporary file.\n+\n+      procedure Copy_File (Name : String_Id);\n+      --  Copy a configuration pragmas file into the temp file.\n+\n+      procedure Put\n+        (Unit_Name : Name_Id;\n+         File_Name : Name_Id;\n+         Unit_Kind : Spec_Or_Body);\n+      --  Put an SFN pragma in the temporary file.\n+\n+      procedure Put (File : File_Descriptor; S : String);\n+\n+      procedure Put_Line (File : File_Descriptor; S : String);\n+\n+      -----------\n+      -- Check --\n+      -----------\n+\n+      procedure Check (Project : Project_Id) is\n+         Data : constant Project_Data := Projects.Table (Project);\n+\n+      begin\n+         if Current_Verbosity = High then\n+            Write_Str (\"Checking project file \"\"\");\n+            Write_Str (Namet.Get_Name_String (Data.Name));\n+            Write_Str (\"\"\".\");\n+            Write_Eol;\n+         end if;\n+\n+         --  Is this project in the list of the visited project?\n+\n+         Current_Project := First_Project;\n+         while Current_Project /= Empty_Project_List\n+           and then Project_Lists.Table (Current_Project).Project /= Project\n+         loop\n+            Current_Project := Project_Lists.Table (Current_Project).Next;\n+         end loop;\n+\n+         --  If it is not, put it in the list, and visit it\n+\n+         if Current_Project = Empty_Project_List then\n+            Project_Lists.Increment_Last;\n+            Project_Lists.Table (Project_Lists.Last) :=\n+              (Project => Project, Next => First_Project);\n+            First_Project := Project_Lists.Last;\n+\n+            --  Is the naming scheme of this project one that we know?\n+\n+            Current_Naming := Default_Naming;\n+            while Current_Naming <= Namings.Last and then\n+              not Same_Naming_Scheme\n+              (Left => Namings.Table (Current_Naming),\n+               Right => Data.Naming) loop\n+               Current_Naming := Current_Naming + 1;\n+            end loop;\n+\n+            --  If we don't know it, add it\n+\n+            if Current_Naming > Namings.Last then\n+               Namings.Increment_Last;\n+               Namings.Table (Namings.Last) := Data.Naming;\n+\n+               --  We need a temporary file to be created\n+\n+               Check_Temp_File;\n+\n+               --  Put the SFN pragmas for the naming scheme\n+\n+               --  Spec\n+\n+               Put_Line\n+                 (File, \"pragma Source_File_Name\");\n+               Put_Line\n+                 (File, \"  (Spec_File_Name  => \"\"*\" &\n+                  Namet.Get_Name_String (Data.Naming.Specification_Append) &\n+                  \"\"\",\");\n+               Put_Line\n+                 (File, \"   Casing          => \" &\n+                  Image (Data.Naming.Casing) & \",\");\n+               Put_Line\n+                 (File, \"   Dot_Replacement => \"\"\" &\n+                 Namet.Get_Name_String (Data.Naming.Dot_Replacement) &\n+                  \"\"\");\");\n+\n+               --  and body\n+\n+               Put_Line\n+                 (File, \"pragma Source_File_Name\");\n+               Put_Line\n+                 (File, \"  (Body_File_Name  => \"\"*\" &\n+                  Namet.Get_Name_String (Data.Naming.Body_Append) &\n+                  \"\"\",\");\n+               Put_Line\n+                 (File, \"   Casing          => \" &\n+                  Image (Data.Naming.Casing) & \",\");\n+               Put_Line\n+                 (File, \"   Dot_Replacement => \"\"\" &\n+                  Namet.Get_Name_String (Data.Naming.Dot_Replacement) &\n+                  \"\"\");\");\n+\n+               --  and maybe separate\n+\n+               if Data.Naming.Body_Append /= Data.Naming.Separate_Append then\n+                  Put_Line\n+                    (File, \"pragma Source_File_Name\");\n+                  Put_Line\n+                    (File, \"  (Subunit_File_Name  => \"\"*\" &\n+                     Namet.Get_Name_String (Data.Naming.Separate_Append) &\n+                     \"\"\",\");\n+                  Put_Line\n+                    (File, \"   Casing          => \" &\n+                     Image (Data.Naming.Casing) &\n+                     \",\");\n+                  Put_Line\n+                    (File, \"   Dot_Replacement => \"\"\" &\n+                     Namet.Get_Name_String (Data.Naming.Dot_Replacement) &\n+                     \"\"\");\");\n+               end if;\n+            end if;\n+\n+            if Data.Modifies /= No_Project then\n+               Check (Data.Modifies);\n+            end if;\n+\n+            declare\n+               Current : Project_List := Data.Imported_Projects;\n+\n+            begin\n+               while Current /= Empty_Project_List loop\n+                  Check (Project_Lists.Table (Current).Project);\n+                  Current := Project_Lists.Table (Current).Next;\n+               end loop;\n+            end;\n+         end if;\n+      end Check;\n+\n+      ---------------------\n+      -- Check_Temp_File --\n+      ---------------------\n+\n+      procedure Check_Temp_File is\n+      begin\n+         if File = Invalid_FD then\n+            GNAT.OS_Lib.Create_Temp_File (File, Name => File_Name);\n+            if File = Invalid_FD then\n+               Osint.Fail\n+                 (\"unable to create temporary configuration pragmas file\");\n+            elsif Opt.Verbose_Mode then\n+               Write_Str (\"Creating temp file \"\"\");\n+               Write_Str (File_Name);\n+               Write_Line (\"\"\"\");\n+            end if;\n+         end if;\n+      end Check_Temp_File;\n+\n+      ---------------\n+      -- Copy_File --\n+      ---------------\n+\n+      procedure Copy_File (Name : in String_Id) is\n+         Input         : File_Descriptor;\n+         Buffer        : String (1 .. 1_000);\n+         Input_Length  : Integer;\n+         Output_Length : Integer;\n+\n+      begin\n+         Check_Temp_File;\n+         String_To_Name_Buffer (Name);\n+\n+         if Opt.Verbose_Mode then\n+            Write_Str (\"Copying config pragmas file \"\"\");\n+            Write_Str (Name_Buffer (1 .. Name_Len));\n+            Write_Line (\"\"\" into temp file\");\n+         end if;\n+\n+         declare\n+            Name : constant String :=\n+              Name_Buffer (1 .. Name_Len)  & ASCII.NUL;\n+         begin\n+            Input := Open_Read (Name'Address, Binary);\n+         end;\n+\n+         if Input = Invalid_FD then\n+            Osint.Fail\n+              (\"cannot open configuration pragmas file \" &\n+               Name_Buffer (1 .. Name_Len));\n+         end if;\n+\n+         loop\n+            Input_Length := Read (Input, Buffer'Address, Buffer'Length);\n+            Output_Length := Write (File, Buffer'Address, Input_Length);\n+\n+            if Output_Length /= Input_Length then\n+               Osint.Fail (\"disk full\");\n+            end if;\n+\n+            exit when Input_Length < Buffer'Length;\n+         end loop;\n+\n+         Close (Input);\n+\n+      end Copy_File;\n+\n+      ---------\n+      -- Put --\n+      ---------\n+\n+      procedure Put\n+        (Unit_Name : Name_Id;\n+         File_Name : Name_Id;\n+         Unit_Kind : Spec_Or_Body)\n+      is\n+      begin\n+         --  A temporary file needs to be open\n+\n+         Check_Temp_File;\n+\n+         --  Put the pragma SFN for the unit kind (spec or body)\n+\n+         Put (File, \"pragma Source_File_Name (\");\n+         Put (File, Namet.Get_Name_String (Unit_Name));\n+\n+         if Unit_Kind = Specification then\n+            Put (File, \", Spec_File_Name => \"\"\");\n+         else\n+            Put (File, \", Body_File_Name => \"\"\");\n+         end if;\n+\n+         Put (File, Namet.Get_Name_String (File_Name));\n+         Put_Line (File, \"\"\");\");\n+      end Put;\n+\n+      procedure Put (File : File_Descriptor; S : String) is\n+         Last : Natural;\n+\n+      begin\n+         Last := Write (File, S (S'First)'Address, S'Length);\n+\n+         if Last /= S'Length then\n+            Osint.Fail (\"Disk full\");\n+         end if;\n+\n+         if Current_Verbosity = High then\n+            Write_Str (S);\n+         end if;\n+      end Put;\n+\n+      --------------\n+      -- Put_Line --\n+      --------------\n+\n+      procedure Put_Line (File : File_Descriptor; S : String) is\n+         S0   : String (1 .. S'Length + 1);\n+         Last : Natural;\n+\n+      begin\n+         --  Add an ASCII.LF to the string. As this gnat.adc\n+         --  is supposed to be used only by the compiler, we don't\n+         --  care about the characters for the end of line.\n+         --  The truth is we could have put a space, but it is\n+         --  more convenient to be able to read gnat.adc during\n+         --  development. And the development was done under UNIX.\n+         --  Hence the ASCII.LF.\n+\n+         S0 (1 .. S'Length) := S;\n+         S0 (S0'Last) := ASCII.LF;\n+         Last := Write (File, S0'Address, S0'Length);\n+\n+         if Last /= S'Length + 1 then\n+            Osint.Fail (\"Disk full\");\n+         end if;\n+\n+         if Current_Verbosity = High then\n+            Write_Line (S);\n+         end if;\n+      end Put_Line;\n+\n+   --  Start of processing for Create_Config_Pragmas_File\n+\n+   begin\n+\n+      if not Projects.Table (For_Project).Config_Checked then\n+\n+         --  Remove any memory of processed naming schemes, if any\n+\n+         Namings.Set_Last (Default_Naming);\n+\n+         --  Check the naming schemes\n+\n+         Check (For_Project);\n+\n+         --  Visit all the units and process those that need an SFN pragma\n+\n+         while Current_Unit <= Units.Last loop\n+            declare\n+               Unit : constant Unit_Data :=\n+                 Units.Table (Current_Unit);\n+\n+            begin\n+               if Unit.File_Names (Specification).Needs_Pragma then\n+                  Put (Unit.Name,\n+                       Unit.File_Names (Specification).Name,\n+                       Specification);\n+               end if;\n+\n+               if Unit.File_Names (Body_Part).Needs_Pragma then\n+                  Put (Unit.Name,\n+                       Unit.File_Names (Body_Part).Name,\n+                       Body_Part);\n+               end if;\n+\n+               Current_Unit := Current_Unit + 1;\n+            end;\n+         end loop;\n+\n+         The_Packages := Projects.Table (Main_Project).Decl.Packages;\n+         Gnatmake :=\n+           Prj.Util.Value_Of\n+           (Name        => Name_Gnatmake,\n+            In_Packages => The_Packages);\n+\n+         if Gnatmake /= No_Package then\n+            Global_Attribute := Prj.Util.Value_Of\n+              (Variable_Name => Global_Configuration_Pragmas,\n+               In_Variables => Packages.Table (Gnatmake).Decl.Attributes);\n+            Global_Attribute_Present :=\n+              Global_Attribute /= Nil_Variable_Value\n+              and then String_Length (Global_Attribute.Value) > 0;\n+         end if;\n+\n+         The_Packages := Projects.Table (For_Project).Decl.Packages;\n+         Compiler :=\n+           Prj.Util.Value_Of\n+           (Name        => Name_Compiler,\n+            In_Packages => The_Packages);\n+\n+         if Compiler /= No_Package then\n+            Local_Attribute := Prj.Util.Value_Of\n+              (Variable_Name => Local_Configuration_Pragmas,\n+               In_Variables => Packages.Table (Compiler).Decl.Attributes);\n+            Local_Attribute_Present :=\n+              Local_Attribute /= Nil_Variable_Value\n+              and then String_Length (Local_Attribute.Value) > 0;\n+         end if;\n+\n+         if Global_Attribute_Present then\n+\n+            if File /= Invalid_FD\n+              or else Local_Attribute_Present\n+            then\n+               Copy_File (Global_Attribute.Value);\n+            else\n+               String_To_Name_Buffer (Global_Attribute.Value);\n+               Projects.Table (For_Project).Config_File_Name := Name_Find;\n+            end if;\n+         end if;\n+\n+         if Local_Attribute_Present then\n+\n+            if File /= Invalid_FD then\n+               Copy_File (Local_Attribute.Value);\n+\n+            else\n+               String_To_Name_Buffer (Local_Attribute.Value);\n+               Projects.Table (For_Project).Config_File_Name := Name_Find;\n+            end if;\n+\n+         end if;\n+\n+         if File /= Invalid_FD then\n+            GNAT.OS_Lib.Close (File);\n+\n+            if Opt.Verbose_Mode then\n+               Write_Str (\"Closing configuration file \"\"\");\n+               Write_Str (File_Name);\n+               Write_Line (\"\"\"\");\n+            end if;\n+\n+            Name_Len := File_Name'Length;\n+            Name_Buffer (1 .. Name_Len) := File_Name;\n+            Projects.Table (For_Project).Config_File_Name := Name_Find;\n+            Projects.Table (For_Project).Config_File_Temp := True;\n+         end if;\n+\n+         Projects.Table (For_Project).Config_Checked := True;\n+\n+      end if;\n+\n+   end Create_Config_Pragmas_File;\n+\n+   ------------------------------------\n+   -- File_Name_Of_Library_Unit_Body --\n+   ------------------------------------\n+\n+   function File_Name_Of_Library_Unit_Body\n+     (Name    : String;\n+      Project : Project_Id)\n+      return    String\n+   is\n+      Data          : constant Project_Data := Projects.Table (Project);\n+      Original_Name : String := Name;\n+\n+      Extended_Spec_Name : String :=\n+                             Name & Namet.Get_Name_String\n+                                      (Data.Naming.Specification_Append);\n+      Extended_Body_Name : String :=\n+                             Name & Namet.Get_Name_String\n+                                      (Data.Naming.Body_Append);\n+\n+      Unit : Unit_Data;\n+\n+      The_Original_Name : Name_Id;\n+      The_Spec_Name     : Name_Id;\n+      The_Body_Name     : Name_Id;\n+\n+   begin\n+      Canonical_Case_File_Name (Original_Name);\n+      Name_Len := Original_Name'Length;\n+      Name_Buffer (1 .. Name_Len) := Original_Name;\n+      The_Original_Name := Name_Find;\n+\n+      Canonical_Case_File_Name (Extended_Spec_Name);\n+      Name_Len := Extended_Spec_Name'Length;\n+      Name_Buffer (1 .. Name_Len) := Extended_Spec_Name;\n+      The_Spec_Name := Name_Find;\n+\n+      Canonical_Case_File_Name (Extended_Body_Name);\n+      Name_Len := Extended_Body_Name'Length;\n+      Name_Buffer (1 .. Name_Len) := Extended_Body_Name;\n+      The_Body_Name := Name_Find;\n+\n+      if Current_Verbosity = High then\n+         Write_Str  (\"Looking for file name of \"\"\");\n+         Write_Str  (Name);\n+         Write_Char ('\"');\n+         Write_Eol;\n+         Write_Str  (\"   Extended Spec Name = \"\"\");\n+         Write_Str  (Extended_Spec_Name);\n+         Write_Char ('\"');\n+         Write_Eol;\n+         Write_Str  (\"   Extended Body Name = \"\"\");\n+         Write_Str  (Extended_Body_Name);\n+         Write_Char ('\"');\n+         Write_Eol;\n+      end if;\n+\n+      --  For every unit\n+\n+      for Current in reverse Units.First .. Units.Last loop\n+         Unit := Units.Table (Current);\n+\n+         --  If it is a unit of the same project\n+\n+         if Unit.File_Names (Body_Part).Project = Project then\n+            declare\n+               Current_Name : constant Name_Id :=\n+                                Unit.File_Names (Body_Part).Name;\n+\n+            begin\n+               --  If there is a body\n+\n+               if Current_Name /= No_Name then\n+                  if Current_Verbosity = High then\n+                     Write_Str  (\"   Comparing with \"\"\");\n+                     Write_Str  (Get_Name_String (Current_Name));\n+                     Write_Char ('\"');\n+                     Write_Eol;\n+                  end if;\n+\n+                  --  If it has the name of the original name,\n+                  --  return the original name\n+\n+                  if Unit.Name = The_Original_Name\n+                    or else Current_Name = The_Original_Name\n+                  then\n+                     if Current_Verbosity = High then\n+                        Write_Line (\"   OK\");\n+                     end if;\n+\n+                     return Get_Name_String (Current_Name);\n+\n+                  --  If it has the name of the extended body name,\n+                  --  return the extended body name\n+\n+                  elsif Current_Name = The_Body_Name then\n+                     if Current_Verbosity = High then\n+                        Write_Line (\"   OK\");\n+                     end if;\n+\n+                     return Extended_Body_Name;\n+\n+                  else\n+                     if Current_Verbosity = High then\n+                        Write_Line (\"   not good\");\n+                     end if;\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n+\n+         --  If it is a unit of the same project\n+\n+         if Units.Table (Current).File_Names (Specification).Project =\n+                                                                 Project\n+         then\n+            declare\n+               Current_Name : constant Name_Id :=\n+                                Unit.File_Names (Specification).Name;\n+\n+            begin\n+               --  If there is a spec\n+\n+               if Current_Name /= No_Name then\n+                  if Current_Verbosity = High then\n+                     Write_Str  (\"   Comparing with \"\"\");\n+                     Write_Str  (Get_Name_String (Current_Name));\n+                     Write_Char ('\"');\n+                     Write_Eol;\n+                  end if;\n+\n+                  --  If it has the same name as the original name,\n+                  --  return the original name\n+\n+                  if Unit.Name = The_Original_Name\n+                    or else Current_Name = The_Original_Name\n+                  then\n+                     if Current_Verbosity = High then\n+                        Write_Line (\"   OK\");\n+                     end if;\n+\n+                     return Get_Name_String (Current_Name);\n+\n+                  --  If it has the same name as the extended spec name,\n+                  --  return the extended spec name\n+\n+                  elsif Current_Name = The_Spec_Name then\n+                     if Current_Verbosity = High then\n+                        Write_Line (\"   OK\");\n+                     end if;\n+\n+                     return Extended_Spec_Name;\n+\n+                  else\n+                     if Current_Verbosity = High then\n+                        Write_Line (\"   not good\");\n+                     end if;\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n+\n+      end loop;\n+\n+      --  We don't know this file name, return an empty string\n+\n+      return \"\";\n+   end File_Name_Of_Library_Unit_Body;\n+\n+   -------------------------\n+   -- For_All_Object_Dirs --\n+   -------------------------\n+\n+   procedure For_All_Object_Dirs (Project : Project_Id) is\n+      Seen : Project_List := Empty_Project_List;\n+\n+      procedure Add (Project : Project_Id);\n+      --  Process a project. Remember the processes visited to avoid\n+      --  processing a project twice. Recursively process an eventual\n+      --  modified project, and all imported projects.\n+\n+      ---------\n+      -- Add --\n+      ---------\n+\n+      procedure Add (Project : Project_Id) is\n+         Data : constant Project_Data := Projects.Table (Project);\n+         List : Project_List := Data.Imported_Projects;\n+\n+      begin\n+         --  If the list of visited project is empty, then\n+         --  for sure we never visited this project.\n+\n+         if Seen = Empty_Project_List then\n+            Project_Lists.Increment_Last;\n+            Seen := Project_Lists.Last;\n+            Project_Lists.Table (Seen) :=\n+              (Project => Project, Next => Empty_Project_List);\n+\n+         else\n+            --  Check if the project is in the list\n+\n+            declare\n+               Current : Project_List := Seen;\n+\n+            begin\n+               loop\n+                  --  If it is, then there is nothing else to do\n+\n+                  if Project_Lists.Table (Current).Project = Project then\n+                     return;\n+                  end if;\n+\n+                  exit when Project_Lists.Table (Current).Next =\n+                    Empty_Project_List;\n+                  Current := Project_Lists.Table (Current).Next;\n+               end loop;\n+\n+               --  This project has never been visited, add it\n+               --  to the list.\n+\n+               Project_Lists.Increment_Last;\n+               Project_Lists.Table (Current).Next := Project_Lists.Last;\n+               Project_Lists.Table (Project_Lists.Last) :=\n+                 (Project => Project, Next => Empty_Project_List);\n+            end;\n+         end if;\n+\n+         --  If there is an object directory, call Action\n+         --  with its name\n+\n+         if Data.Object_Directory /= No_Name then\n+            Get_Name_String (Data.Object_Directory);\n+            Action (Name_Buffer (1 .. Name_Len));\n+         end if;\n+\n+         --  If we are modifying a project, visit it\n+\n+         if Data.Modifies /= No_Project then\n+            Add (Data.Modifies);\n+         end if;\n+\n+         --  And visit all imported projects\n+\n+         while List /= Empty_Project_List loop\n+            Add (Project_Lists.Table (List).Project);\n+            List := Project_Lists.Table (List).Next;\n+         end loop;\n+      end Add;\n+\n+   --  Start of processing for For_All_Object_Dirs\n+\n+   begin\n+      --  Visit this project, and its imported projects,\n+      --  recursively\n+\n+      Add (Project);\n+   end For_All_Object_Dirs;\n+\n+   -------------------------\n+   -- For_All_Source_Dirs --\n+   -------------------------\n+\n+   procedure For_All_Source_Dirs (Project : Project_Id) is\n+      Seen : Project_List := Empty_Project_List;\n+\n+      procedure Add (Project : Project_Id);\n+      --  Process a project. Remember the processes visited to avoid\n+      --  processing a project twice. Recursively process an eventual\n+      --  modified project, and all imported projects.\n+\n+      ---------\n+      -- Add --\n+      ---------\n+\n+      procedure Add (Project : Project_Id) is\n+         Data : constant Project_Data := Projects.Table (Project);\n+         List : Project_List := Data.Imported_Projects;\n+\n+      begin\n+         --  If the list of visited project is empty, then\n+         --  for sure we never visited this project.\n+\n+         if Seen = Empty_Project_List then\n+            Project_Lists.Increment_Last;\n+            Seen := Project_Lists.Last;\n+            Project_Lists.Table (Seen) :=\n+              (Project => Project, Next => Empty_Project_List);\n+\n+         else\n+            --  Check if the project is in the list\n+\n+            declare\n+               Current : Project_List := Seen;\n+\n+            begin\n+               loop\n+                  --  If it is, then there is nothing else to do\n+\n+                  if Project_Lists.Table (Current).Project = Project then\n+                     return;\n+                  end if;\n+\n+                  exit when Project_Lists.Table (Current).Next =\n+                    Empty_Project_List;\n+                  Current := Project_Lists.Table (Current).Next;\n+               end loop;\n+\n+               --  This project has never been visited, add it\n+               --  to the list.\n+\n+               Project_Lists.Increment_Last;\n+               Project_Lists.Table (Current).Next := Project_Lists.Last;\n+               Project_Lists.Table (Project_Lists.Last) :=\n+                 (Project => Project, Next => Empty_Project_List);\n+            end;\n+         end if;\n+\n+         declare\n+            Current    : String_List_Id := Data.Source_Dirs;\n+            The_String : String_Element;\n+\n+         begin\n+            --  Call action with the name of every source directorie\n+\n+            while Current /= Nil_String loop\n+               The_String := String_Elements.Table (Current);\n+               String_To_Name_Buffer (The_String.Value);\n+               Action (Name_Buffer (1 .. Name_Len));\n+               Current := The_String.Next;\n+            end loop;\n+         end;\n+\n+         --  If we are modifying a project, visit it\n+\n+         if Data.Modifies /= No_Project then\n+            Add (Data.Modifies);\n+         end if;\n+\n+         --  And visit all imported projects\n+\n+         while List /= Empty_Project_List loop\n+            Add (Project_Lists.Table (List).Project);\n+            List := Project_Lists.Table (List).Next;\n+         end loop;\n+      end Add;\n+\n+   --  Start of processing for For_All_Source_Dirs\n+\n+   begin\n+      --  Visit this project, and its imported projects recursively\n+\n+      Add (Project);\n+   end For_All_Source_Dirs;\n+\n+   -------------------\n+   -- Get_Reference --\n+   -------------------\n+\n+   procedure Get_Reference\n+     (Source_File_Name : String;\n+      Project          : out Project_Id;\n+      Path             : out Name_Id)\n+   is\n+   begin\n+      if Current_Verbosity > Default then\n+         Write_Str (\"Getting Reference_Of (\"\"\");\n+         Write_Str (Source_File_Name);\n+         Write_Str (\"\"\") ... \");\n+      end if;\n+\n+      declare\n+         Original_Name : String := Source_File_Name;\n+         Unit          : Unit_Data;\n+\n+      begin\n+         Canonical_Case_File_Name (Original_Name);\n+\n+         for Id in Units.First .. Units.Last loop\n+            Unit := Units.Table (Id);\n+\n+            if (Unit.File_Names (Specification).Name /= No_Name\n+                 and then\n+                   Namet.Get_Name_String\n+                     (Unit.File_Names (Specification).Name) = Original_Name)\n+              or else (Unit.File_Names (Specification).Path /= No_Name\n+                         and then\n+                           Namet.Get_Name_String\n+                           (Unit.File_Names (Specification).Path) =\n+                                                              Original_Name)\n+            then\n+               Project := Unit.File_Names (Specification).Project;\n+               Path := Unit.File_Names (Specification).Path;\n+\n+               if Current_Verbosity > Default then\n+                  Write_Str (\"Done: Specification.\");\n+                  Write_Eol;\n+               end if;\n+\n+               return;\n+\n+            elsif (Unit.File_Names (Body_Part).Name /= No_Name\n+                    and then\n+                      Namet.Get_Name_String\n+                        (Unit.File_Names (Body_Part).Name) = Original_Name)\n+              or else (Unit.File_Names (Body_Part).Path /= No_Name\n+                         and then Namet.Get_Name_String\n+                                    (Unit.File_Names (Body_Part).Path) =\n+                                                             Original_Name)\n+            then\n+               Project := Unit.File_Names (Body_Part).Project;\n+               Path := Unit.File_Names (Body_Part).Path;\n+\n+               if Current_Verbosity > Default then\n+                  Write_Str (\"Done: Body.\");\n+                  Write_Eol;\n+               end if;\n+\n+               return;\n+            end if;\n+\n+         end loop;\n+      end;\n+\n+      Project := No_Project;\n+      Path    := No_Name;\n+\n+      if Current_Verbosity > Default then\n+         Write_Str (\"Cannot be found.\");\n+         Write_Eol;\n+      end if;\n+   end Get_Reference;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+      Global : constant String := \"global_configuration_pragmas\";\n+      Local  : constant String :=  \"local_configuration_pragmas\";\n+   begin\n+      --  Put the standard GNAT naming scheme in the Namings table\n+\n+      Namings.Increment_Last;\n+      Namings.Table (Namings.Last) := Standard_Naming_Data;\n+      Name_Len := Global'Length;\n+      Name_Buffer (1 .. Name_Len) := Global;\n+      Global_Configuration_Pragmas := Name_Find;\n+      Name_Len := Local'Length;\n+      Name_Buffer (1 .. Name_Len) := Local;\n+      Local_Configuration_Pragmas := Name_Find;\n+   end Initialize;\n+\n+   ------------------------------------\n+   -- Path_Name_Of_Library_Unit_Body --\n+   ------------------------------------\n+\n+   function Path_Name_Of_Library_Unit_Body\n+     (Name    : String;\n+      Project : Project_Id)\n+      return String\n+   is\n+      Data : constant Project_Data := Projects.Table (Project);\n+      Original_Name : String := Name;\n+\n+      Extended_Spec_Name : String :=\n+                             Name & Namet.Get_Name_String\n+                                     (Data.Naming.Specification_Append);\n+      Extended_Body_Name : String :=\n+                             Name & Namet.Get_Name_String\n+                                     (Data.Naming.Body_Append);\n+\n+      First   : Unit_Id := Units.First;\n+      Current : Unit_Id;\n+      Unit    : Unit_Data;\n+\n+   begin\n+      Canonical_Case_File_Name (Original_Name);\n+      Canonical_Case_File_Name (Extended_Spec_Name);\n+      Canonical_Case_File_Name (Extended_Spec_Name);\n+\n+      if Current_Verbosity = High then\n+         Write_Str  (\"Looking for path name of \"\"\");\n+         Write_Str  (Name);\n+         Write_Char ('\"');\n+         Write_Eol;\n+         Write_Str  (\"   Extended Spec Name = \"\"\");\n+         Write_Str  (Extended_Spec_Name);\n+         Write_Char ('\"');\n+         Write_Eol;\n+         Write_Str  (\"   Extended Body Name = \"\"\");\n+         Write_Str  (Extended_Body_Name);\n+         Write_Char ('\"');\n+         Write_Eol;\n+      end if;\n+\n+      while First <= Units.Last\n+        and then Units.Table (First).File_Names (Body_Part).Project /= Project\n+      loop\n+         First := First + 1;\n+      end loop;\n+\n+      Current := First;\n+      while Current <= Units.Last loop\n+         Unit := Units.Table (Current);\n+\n+         if Unit.File_Names (Body_Part).Project = Project\n+           and then Unit.File_Names (Body_Part).Name /= No_Name\n+         then\n+            declare\n+               Current_Name : constant String :=\n+                 Namet.Get_Name_String (Unit.File_Names (Body_Part).Name);\n+            begin\n+               if Current_Verbosity = High then\n+                  Write_Str  (\"   Comparing with \"\"\");\n+                  Write_Str  (Current_Name);\n+                  Write_Char ('\"');\n+                  Write_Eol;\n+               end if;\n+\n+               if Current_Name = Original_Name then\n+                  if Current_Verbosity = High then\n+                     Write_Line (\"   OK\");\n+                  end if;\n+\n+                  return Body_Path_Name_Of (Current);\n+\n+               elsif Current_Name = Extended_Body_Name then\n+                  if Current_Verbosity = High then\n+                     Write_Line (\"   OK\");\n+                  end if;\n+\n+                  return Body_Path_Name_Of (Current);\n+\n+               else\n+                  if Current_Verbosity = High then\n+                     Write_Line (\"   not good\");\n+                  end if;\n+               end if;\n+            end;\n+\n+         elsif Unit.File_Names (Specification).Name /= No_Name then\n+            declare\n+               Current_Name : constant String :=\n+                                Namet.Get_Name_String\n+                                  (Unit.File_Names (Specification).Name);\n+\n+            begin\n+               if Current_Verbosity = High then\n+                  Write_Str  (\"   Comparing with \"\"\");\n+                  Write_Str  (Current_Name);\n+                  Write_Char ('\"');\n+                  Write_Eol;\n+               end if;\n+\n+               if Current_Name = Original_Name then\n+                  if Current_Verbosity = High then\n+                     Write_Line (\"   OK\");\n+                  end if;\n+\n+                  return Spec_Path_Name_Of (Current);\n+\n+               elsif Current_Name = Extended_Spec_Name then\n+\n+                  if Current_Verbosity = High then\n+                     Write_Line (\"   OK\");\n+                  end if;\n+\n+                  return Spec_Path_Name_Of (Current);\n+\n+               else\n+                  if Current_Verbosity = High then\n+                     Write_Line (\"   not good\");\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n+         Current := Current + 1;\n+      end loop;\n+\n+      return \"\";\n+   end Path_Name_Of_Library_Unit_Body;\n+\n+   -------------------\n+   -- Print_Sources --\n+   -------------------\n+\n+   procedure Print_Sources is\n+      Unit : Unit_Data;\n+\n+   begin\n+      Write_Line (\"List of Sources:\");\n+\n+      for Id in Units.First .. Units.Last loop\n+         Unit := Units.Table (Id);\n+         Write_Str  (\"   \");\n+         Write_Line (Namet.Get_Name_String (Unit.Name));\n+\n+         if Unit.File_Names (Specification).Name /= No_Name then\n+            if Unit.File_Names (Specification).Project = No_Project then\n+               Write_Line (\"   No project\");\n+\n+            else\n+               Write_Str  (\"   Project: \");\n+               Get_Name_String\n+                 (Projects.Table\n+                   (Unit.File_Names (Specification).Project).Path_Name);\n+               Write_Line (Name_Buffer (1 .. Name_Len));\n+            end if;\n+\n+            Write_Str  (\"      spec: \");\n+            Write_Line\n+              (Namet.Get_Name_String\n+               (Unit.File_Names (Specification).Name));\n+         end if;\n+\n+         if Unit.File_Names (Body_Part).Name /= No_Name then\n+            if Unit.File_Names (Body_Part).Project = No_Project then\n+               Write_Line (\"   No project\");\n+\n+            else\n+               Write_Str  (\"   Project: \");\n+               Get_Name_String\n+                 (Projects.Table\n+                   (Unit.File_Names (Body_Part).Project).Path_Name);\n+               Write_Line (Name_Buffer (1 .. Name_Len));\n+            end if;\n+\n+            Write_Str  (\"      body: \");\n+            Write_Line\n+              (Namet.Get_Name_String\n+               (Unit.File_Names (Body_Part).Name));\n+         end if;\n+\n+      end loop;\n+\n+      Write_Line (\"end of List of Sources.\");\n+   end Print_Sources;\n+\n+   -----------------------\n+   -- Spec_Path_Name_Of --\n+   -----------------------\n+\n+   function Spec_Path_Name_Of (Unit : Unit_Id) return String is\n+      Data : Unit_Data := Units.Table (Unit);\n+\n+   begin\n+      if Data.File_Names (Specification).Path = No_Name then\n+         declare\n+            Current_Source : String_List_Id :=\n+              Projects.Table (Data.File_Names (Specification).Project).Sources;\n+            Path : GNAT.OS_Lib.String_Access;\n+\n+         begin\n+            Data.File_Names (Specification).Path :=\n+              Data.File_Names (Specification).Name;\n+\n+            while Current_Source /= Nil_String loop\n+               String_To_Name_Buffer\n+                 (String_Elements.Table (Current_Source).Value);\n+               Path := Locate_Regular_File\n+                 (Namet.Get_Name_String\n+                  (Data.File_Names (Specification).Name),\n+                  Name_Buffer (1 .. Name_Len));\n+\n+               if Path /= null then\n+                  Name_Len := Path'Length;\n+                  Name_Buffer (1 .. Name_Len) := Path.all;\n+                  Data.File_Names (Specification).Path := Name_Enter;\n+                  exit;\n+               else\n+                  Current_Source :=\n+                    String_Elements.Table (Current_Source).Next;\n+               end if;\n+            end loop;\n+\n+            Units.Table (Unit) := Data;\n+         end;\n+      end if;\n+\n+      return Namet.Get_Name_String (Data.File_Names (Specification).Path);\n+   end Spec_Path_Name_Of;\n+\n+end Prj.Env;"}, {"sha": "272c559282a67eacefad82c91c657c1ad7afc5cb", "filename": "gcc/ada/prj-env.ads", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,99 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P R J . E N V                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.10 $\n+--                                                                          --\n+--             Copyright (C) 2001 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package implements services for Project-aware tools, related\n+--  to the environment (gnat.adc, ADA_INCLUDE_PATH, ADA_OBJECTS_PATH)\n+\n+with GNAT.OS_Lib; use GNAT.OS_Lib;\n+\n+package Prj.Env is\n+\n+   procedure Initialize;\n+   --  Put Standard_Naming_Data into Namings table (called by Prj.Initialize)\n+\n+   procedure Print_Sources;\n+   --  Output the list of sources, after Project files have been scanned\n+\n+   procedure Create_Config_Pragmas_File\n+     (For_Project  : Project_Id;\n+      Main_Project : Project_Id);\n+   --  If there needs to have SFN pragmas, either for non standard naming\n+   --  schemes or for individual units, or if Global_Configuration_Pragmas\n+   --  has been specified in package gnatmake of the main project, or if\n+   --  Local_Configuration_Pragmas has been specified in package Compiler\n+   --  of the main project, build (if needed) a temporary file that contains\n+   --  all configuration pragmas, and specify the configuration pragmas file\n+   --  in the project data.\n+\n+   function Ada_Include_Path (Project : Project_Id) return String_Access;\n+   --  Get the ADA_INCLUDE_PATH of a Project file. For the first call, compute\n+   --  it and cache it.\n+\n+   function Ada_Objects_Path\n+     (Project             : Project_Id;\n+      Including_Libraries : Boolean := True)\n+      return                String_Access;\n+   --  Get the ADA_OBJECTS_PATH of a Project file. For the first call, compute\n+   --  it and cache it. When Including_Libraries is False, do not include the\n+   --  object directories of the library projects, and do not cache the result.\n+\n+   function Path_Name_Of_Library_Unit_Body\n+     (Name    : String;\n+      Project : Project_Id)\n+      return    String;\n+   --  Returns the Path of a library unit.\n+\n+   function File_Name_Of_Library_Unit_Body\n+     (Name    : String;\n+      Project : Project_Id)\n+      return    String;\n+   --  Returns the file name of a library unit, in canonical case. Name may or\n+   --  may not have an extension (corresponding to the naming scheme of the\n+   --  project). If there is no body with this name, but there is a spec, the\n+   --  name of the spec is returned. If neither a body or a spec can be found,\n+   --  return an empty string.\n+\n+   procedure Get_Reference\n+     (Source_File_Name : String;\n+      Project          : out Project_Id;\n+      Path             : out Name_Id);\n+   --  Returns the project of a source.\n+\n+   generic\n+      with procedure Action (Path : String);\n+   procedure For_All_Source_Dirs (Project : Project_Id);\n+   --  Iterate through all the source directories of a project,\n+   --  including those of imported or modified projects.\n+\n+   generic\n+      with procedure Action (Path : String);\n+   procedure For_All_Object_Dirs (Project : Project_Id);\n+   --  Iterate through all the object directories of a project,\n+   --  including those of imported or modified projects.\n+\n+end Prj.Env;"}, {"sha": "b6f6ab8bb14a702f7f58ed698abd6a0cdc7ca4a5", "filename": "gcc/ada/prj-ext.adb", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-ext.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-ext.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-ext.adb?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,130 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P R J . E X T                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $\n+--                                                                          --\n+--             Copyright (C) 2000 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with GNAT.HTable;\n+with GNAT.OS_Lib; use GNAT.OS_Lib;\n+with Namet;       use Namet;\n+with Prj.Com;     use Prj.Com;\n+with Stringt;     use Stringt;\n+with Types;       use Types;\n+\n+package body Prj.Ext is\n+\n+   package Htable is new GNAT.HTable.Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => String_Id,\n+      No_Element => No_String,\n+      Key        => Name_Id,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+\n+   ---------\n+   -- Add --\n+   ---------\n+\n+   procedure Add\n+     (External_Name : String;\n+      Value         : String)\n+   is\n+      The_Key   : Name_Id;\n+      The_Value : String_Id;\n+\n+   begin\n+      Start_String;\n+      Store_String_Chars (Value);\n+      The_Value := End_String;\n+      Name_Len := External_Name'Length;\n+      Name_Buffer (1 .. Name_Len) := External_Name;\n+      The_Key := Name_Find;\n+      Htable.Set (The_Key, The_Value);\n+   end Add;\n+\n+   -----------\n+   -- Check --\n+   -----------\n+\n+   function Check (Declaration : String) return Boolean is\n+   begin\n+      for Equal_Pos in Declaration'Range loop\n+\n+         if Declaration (Equal_Pos) = '=' then\n+            exit when Equal_Pos = Declaration'First;\n+            exit when Equal_Pos = Declaration'Last;\n+            Add\n+              (External_Name =>\n+                 Declaration (Declaration'First .. Equal_Pos - 1),\n+               Value =>\n+                 Declaration (Equal_Pos + 1 .. Declaration'Last));\n+            return True;\n+         end if;\n+\n+      end loop;\n+\n+      return False;\n+   end Check;\n+\n+   --------------\n+   -- Value_Of --\n+   --------------\n+\n+   function Value_Of\n+     (External_Name : Name_Id;\n+      With_Default  : String_Id := No_String)\n+      return          String_Id\n+   is\n+      The_Value : String_Id;\n+\n+   begin\n+      The_Value := Htable.Get (External_Name);\n+\n+      if The_Value /= No_String then\n+         return The_Value;\n+      end if;\n+\n+      --  Find if it is an environment.\n+      --  If it is, put the value in the hash table.\n+\n+      declare\n+         Env_Value : constant String_Access :=\n+           Getenv (Get_Name_String (External_Name));\n+\n+      begin\n+         if Env_Value /= null and then Env_Value'Length > 0 then\n+            Start_String;\n+            Store_String_Chars (Env_Value.all);\n+            The_Value := End_String;\n+            Htable.Set (External_Name, The_Value);\n+            return The_Value;\n+\n+         else\n+            return With_Default;\n+         end if;\n+      end;\n+   end Value_Of;\n+\n+end Prj.Ext;"}, {"sha": "4c12b786bcf633b0a1e8119c7ab8d93fb6ccb685", "filename": "gcc/ada/prj-ext.ads", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-ext.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-ext.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-ext.ads?ref=19235870adf79a3422aed017819c537f1d1375ac", "patch": "@@ -0,0 +1,51 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              P R J . E X T                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $\n+--                                                                          --\n+--             Copyright (C) 2000 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Set, Get and cache External reference, to be used as External functions\n+--  in project files.\n+\n+with Types; use Types;\n+\n+package Prj.Ext is\n+\n+   procedure Add\n+     (External_Name : String;\n+      Value         : String);\n+   --  Add an external reference (or modify an existing one).\n+\n+   function Value_Of\n+     (External_Name : Name_Id;\n+      With_Default  : String_Id := No_String)\n+      return          String_Id;\n+   --  Get the value of an external reference, and cache it for future uses.\n+\n+   function Check (Declaration : String) return Boolean;\n+   --  Check that an external declaration <external>=<value> is correct.\n+   --  If it is correct, the external reference is Added.\n+\n+end Prj.Ext;"}, {"sha": "66031878d2b206c44c5e0e7513633bf0baa58fc2", "filename": "gcc/ada/prj-nmsc.adb", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "5fcc00538da3148befd6c63c5f31104143e68534", "filename": "gcc/ada/prj-nmsc.ads", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-nmsc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-nmsc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.ads?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "620d2e113a9887bbded9f408003b4e75d434f822", "filename": "gcc/ada/prj-pars.adb", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-pars.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-pars.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pars.adb?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "0adaf72f4c2d34d51efc086cb46ceeda85cf54d4", "filename": "gcc/ada/prj-pars.ads", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-pars.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-pars.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pars.ads?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "8100ad49e95a41236774d41e8eeb7f852ad99529", "filename": "gcc/ada/prj-part.adb", "status": "added", "additions": 871, "deletions": 0, "changes": 871, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "d960b732b355741405f963ab27ccd0797f19e03c", "filename": "gcc/ada/prj-part.ads", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-part.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-part.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.ads?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "4822596f96466cb022bfb14fc6e8a44f0bbd15e4", "filename": "gcc/ada/prj-proc.adb", "status": "added", "additions": 1371, "deletions": 0, "changes": 1371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "63259a42699eeaaf971c8c787c5fc46f9bc40544", "filename": "gcc/ada/prj-proc.ads", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-proc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-proc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.ads?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "790c632c2cfa5667f6af716d58c2878339fa5f54", "filename": "gcc/ada/prj-strt.adb", "status": "added", "additions": 943, "deletions": 0, "changes": 943, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-strt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-strt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.adb?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "9bbdbeb883239457b1e04e861d7b5feaee200bae", "filename": "gcc/ada/prj-strt.ads", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-strt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-strt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.ads?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "322e4aae39fa89b73aa80468bf3c4490de75bcbf", "filename": "gcc/ada/prj-tree.adb", "status": "added", "additions": 1478, "deletions": 0, "changes": 1478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "d32fcb1980896a4aa7172071d388580f85fa120d", "filename": "gcc/ada/prj-tree.ads", "status": "added", "additions": 742, "deletions": 0, "changes": 742, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-tree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-tree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.ads?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "6a94a0cfc4cdd1e4cfe0d03eefb6dd3d8672afb3", "filename": "gcc/ada/prj-util.adb", "status": "added", "additions": 415, "deletions": 0, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.adb?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "baef0404f0e6aa0f22fee9383b696d66e1f7fd6e", "filename": "gcc/ada/prj-util.ads", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj-util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.ads?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "8e30211791776e14da7d2f92db5c95cd568513d0", "filename": "gcc/ada/prj.adb", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "409a0717223b6c9a4d6d1910820de8f130fc5f24", "filename": "gcc/ada/prj.ads", "status": "added", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "43d630795a8fe5beb7956df8afb2313bcff2cafd", "filename": "gcc/ada/raise.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fraise.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fraise.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.c?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "8db83f4a2b8e230a86de7b4af64e510febc57300", "filename": "gcc/ada/raise.h", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fraise.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Fraise.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.h?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "9e711527e5bf2c9c7d458139de8adec3992d367c", "filename": "gcc/ada/repinfo.adb", "status": "added", "additions": 1024, "deletions": 0, "changes": 1024, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "0b41ba0864b3b18e49b5fed14b27092f5b65ee86", "filename": "gcc/ada/repinfo.ads", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frepinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frepinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.ads?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "305c818685cdbe7fc8b12135f0f9e1aadb535340", "filename": "gcc/ada/repinfo.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frepinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frepinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.h?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "a284cd42e82e709a49302945b874091f67425afd", "filename": "gcc/ada/restrict.adb", "status": "added", "additions": 458, "deletions": 0, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "426149efaaf142f2695f823440fdda28b3b85440", "filename": "gcc/ada/restrict.ads", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "3eb65408433b2a7018eff4a0155f33a31b79f323", "filename": "gcc/ada/rident.ads", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frident.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frident.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frident.ads?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "1299e1e2a13cff504d7360c3ece254e82b85082b", "filename": "gcc/ada/rtsfind.adb", "status": "added", "additions": 913, "deletions": 0, "changes": 913, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=19235870adf79a3422aed017819c537f1d1375ac"}, {"sha": "11304f625a85ee6f6c527c0a62145eb8fc34d6f5", "filename": "gcc/ada/rtsfind.ads", "status": "added", "additions": 2324, "deletions": 0, "changes": 2324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19235870adf79a3422aed017819c537f1d1375ac/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=19235870adf79a3422aed017819c537f1d1375ac"}]}