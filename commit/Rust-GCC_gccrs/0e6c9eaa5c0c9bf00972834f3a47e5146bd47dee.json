{"sha": "0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU2YzllYWE1YzBjOWJmMDA5NzI4MzRmM2E0N2U1MTQ2YmQ0N2RlZQ==", "commit": {"author": {"name": "Johannes Singler", "email": "singler@ira.uka.de", "date": "2007-10-08T21:14:45Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2007-10-08T21:14:45Z"}, "message": "base.h: Added plus and multiplies functor for differently typed objects.\n\n2007-10-08  Johannes Singler  <singler@ira.uka.de>\n\n\t* include/parallel/base.h: Added plus and multiplies functor\n       for differently typed objects.\n\t* include/parallel/numeric: Use it.\n\t* include/parallel/for_each_selectors.h: Allowed different types.\n\t* include/parallel/partial_sum.h: Fixed return value.\n\t* testsuite/26_numerics/accumulate/1.cc: Tests for accumulate.\n\t* testsuite/26_numerics/inner_product/1.cc: Tests for inner_product.\n\nFrom-SVN: r129140", "tree": {"sha": "da17effa76d21f3f47f27ae04cc5bc0c5c968251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da17effa76d21f3f47f27ae04cc5bc0c5c968251"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee/comments", "author": null, "committer": null, "parents": [{"sha": "9de88093b6e322a53b20ea23560ca3cd753120ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de88093b6e322a53b20ea23560ca3cd753120ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9de88093b6e322a53b20ea23560ca3cd753120ec"}], "stats": {"total": 222, "additions": 201, "deletions": 21}, "files": [{"sha": "90ea0bf815525addaf769d65f42196d897dcc47a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee", "patch": "@@ -1,3 +1,13 @@\n+2007-10-08  Johannes Singler  <singler@ira.uka.de>\n+\n+\t* include/parallel/base.h: Added plus and multiplies functor\n+       for differently typed objects.\n+\t* include/parallel/numeric: Use it.\n+\t* include/parallel/for_each_selectors.h: Allowed different types.\n+\t* include/parallel/partial_sum.h: Fixed return value.\n+\t* testsuite/26_numerics/accumulate/1.cc: Tests for accumulate.\n+\t* testsuite/26_numerics/inner_product/1.cc: Tests for inner_product.\n+\n 2007-10-08  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/stl_move.h (_GLIBCXX_MOVE): Add."}, {"sha": "0a86d8351fe4c724e35b368a76db364fc42a39f3", "filename": "libstdc++-v3/include/parallel/base.h", "status": "modified", "additions": 55, "deletions": 8, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h?ref=0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee", "patch": "@@ -112,14 +112,6 @@ namespace __gnu_parallel\n   };\n \n \n-  /** @brief Similar to std::equal_to, but allows two different types. */\n-  template<typename T1, typename T2>\n-  struct equal_to : std::binary_function<T1, T2, bool>\n-  {\n-    bool operator()(const T1& t1, const T2& t2) const\n-    { return t1 == t2; }\n-  };\n-\n   /** @brief Similar to std::binder1st, but giving the argument types explicitly. */\n   template<typename _Predicate, typename argument_type>\n     class unary_negate\n@@ -190,6 +182,14 @@ namespace __gnu_parallel\n       { return op(__x, value); }\n     };\n \n+  /** @brief Similar to std::equal_to, but allows two different types. */\n+  template<typename T1, typename T2>\n+  struct equal_to : std::binary_function<T1, T2, bool>\n+  {\n+    bool operator()(const T1& t1, const T2& t2) const\n+    { return t1 == t2; }\n+  };\n+\n   /** @brief Similar to std::less, but allows two different types. */\n   template<typename T1, typename T2>\n   struct less : std::binary_function<T1, T2, bool>\n@@ -212,6 +212,53 @@ namespace __gnu_parallel\n       { return __x < __y; }\n     };\n \n+\n+    /** @brief Similar to std::plus, but allows two different types. */\n+  template<typename _Tp1, typename _Tp2>\n+    struct plus : public std::binary_function<_Tp1, _Tp2, _Tp1>\n+    {\n+      typedef typeof(*static_cast<_Tp1*>(NULL) + *static_cast<_Tp2*>(NULL)) result;\n+\n+      result\n+      operator()(const _Tp1& __x, const _Tp2& __y) const\n+      { return __x + __y; }\n+    };\n+\n+  // Partial specialization for one type. Same as std::plus.\n+  template<typename _Tp>\n+    struct plus<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n+    {\n+      typedef typeof(*static_cast<_Tp*>(NULL) + *static_cast<_Tp*>(NULL)) result;\n+\n+      result\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x + __y; }\n+    };\n+\n+\n+  /** @brief Similar to std::multiplies, but allows two different types. */\n+  template<typename _Tp1, typename _Tp2>\n+    struct multiplies : public std::binary_function<_Tp1, _Tp2, _Tp1>\n+    {\n+      typedef typeof(*static_cast<_Tp1*>(NULL) * *static_cast<_Tp2*>(NULL)) result;\n+\n+      result\n+      operator()(const _Tp1& __x, const _Tp2& __y) const\n+      { return __x * __y; }\n+    };\n+\n+  // Partial specialization for one type. Same as std::multiplies.\n+  template<typename _Tp>\n+    struct multiplies<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n+    {\n+      typedef typeof(*static_cast<_Tp*>(NULL) * *static_cast<_Tp*>(NULL)) result;\n+\n+      result\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x * __y; }\n+    };\n+\n+\n   template<typename T, typename _DifferenceTp>\n   class pseudo_sequence;\n "}, {"sha": "392cc6ac7eacb4c27cc23e3e04bf01b8d8e507e4", "filename": "libstdc++-v3/include/parallel/for_each_selectors.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h?ref=0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee", "patch": "@@ -335,8 +335,8 @@ namespace __gnu_parallel\n \n     explicit accumulate_binop_reduct(BinOp& b) : binop(b) {}\n \n-    template<typename T>\n-    inline T operator()(T x, T y) { return binop(x, y); }\n+    template<typename Result, typename Addend>\n+    Result operator()(const Result& x, const Addend& y) { return binop(x, y); }\n   };\n }\n "}, {"sha": "21b8eea3fddbe7808ca7d63110ac2017d6f4a546", "filename": "libstdc++-v3/include/parallel/numeric", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric?ref=0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee", "patch": "@@ -114,7 +114,7 @@ namespace __parallel\n     typedef typename iterator_traits::value_type value_type;\n     typedef typename iterator_traits::iterator_category iterator_category;\n \n-    return accumulate_switch(begin, end, init, std::plus<value_type>(), \n+    return accumulate_switch(begin, end, init, __gnu_parallel::plus<T, value_type>(),\n \t\t\t     iterator_category(), parallelism_tag);\n   }\n \n@@ -126,7 +126,7 @@ namespace __parallel\n     typedef typename iterator_traits::value_type value_type;\n     typedef typename iterator_traits::iterator_category iterator_category;\n \n-    return accumulate_switch(begin, end, init, std::plus<value_type>(), \n+    return accumulate_switch(begin, end, init, __gnu_parallel::plus<T, value_type>(),\n \t\t\t     iterator_category());\n   }\n \n@@ -241,21 +241,34 @@ namespace __parallel\n \t\tInputIterator2 first2, T init, \n \t\t__gnu_parallel::parallelism parallelism_tag)\n   {\n-    typedef iterator_traits<InputIterator1> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    return inner_product(first1, last1, first2, init, std::plus<value_type>(), \n-\t\t\t std::multiplies<value_type>(), parallelism_tag);\n+    typedef iterator_traits<InputIterator1> traits_type1;\n+    typedef typename traits_type1::value_type value_type1;\n+    typedef iterator_traits<InputIterator2> traits_type2;\n+    typedef typename traits_type2::value_type value_type2;\n+\n+    typedef typename __gnu_parallel::multiplies<value_type1, value_type2>::result\n+        multiplies_result_type;\n+    return inner_product(first1, last1, first2, init,\n+                           __gnu_parallel::plus<T, multiplies_result_type>(),\n+                           __gnu_parallel::multiplies<value_type1, value_type2>(),\n+                           parallelism_tag);\n   }\n \n   template<typename InputIterator1, typename InputIterator2, typename T>\n   inline T\n   inner_product(InputIterator1 first1, InputIterator1 last1, \n \t\tInputIterator2 first2, T init)\n   {\n-    typedef iterator_traits<InputIterator1> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    return inner_product(first1, last1, first2, init, std::plus<value_type>(), \n-\t\t\t std::multiplies<value_type>());\n+    typedef iterator_traits<InputIterator1> traits_type1;\n+    typedef typename traits_type1::value_type value_type1;\n+    typedef iterator_traits<InputIterator2> traits_type2;\n+    typedef typename traits_type2::value_type value_type2;\n+\n+    typedef typename __gnu_parallel::multiplies<value_type1, value_type2>::result\n+        multiplies_result_type;\n+    return inner_product(first1, last1, first2, init,\n+                           __gnu_parallel::plus<T, multiplies_result_type>(),\n+                           __gnu_parallel::multiplies<value_type1, value_type2>());\n   }\n \n   // Sequential fallback."}, {"sha": "fbba6860184dcecec9276220719e703385b23a20", "filename": "libstdc++-v3/include/parallel/partial_sum.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h?ref=0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee", "patch": "@@ -190,7 +190,7 @@ namespace __gnu_parallel\n       default:\n \t// Partial_sum algorithm not implemented.\n \t_GLIBCXX_PARALLEL_ASSERT(0);\n-\treturn end;\n+\treturn result + n;\n       }\n   }\n }"}, {"sha": "046532debef971cd0982741dc80cf700a53dc802", "filename": "libstdc++-v3/testsuite/26_numerics/accumulate/1.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Faccumulate%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Faccumulate%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Faccumulate%2F1.cc?ref=0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee", "patch": "@@ -0,0 +1,54 @@\n+// Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 26.4.1 [lib.accumulate]\n+\n+#include <numeric>\n+#include <testsuite_hooks.h>\n+\n+int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n+const int NA = sizeof(A) / sizeof(int);\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  int res = std::accumulate(A, A + NA, 11);\n+  VERIFY( res == 66 );\n+}\n+\n+bool B[] = {true, false, true, true, false, true, false, true, true, false};\n+const int NB = sizeof(B) / sizeof(bool);\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  int res = std::accumulate(B, B + NB, 100);\n+  VERIFY( res == 106 );\n+}\n+\n+int\n+main()\n+{\n+    test01();\n+    test02();\n+    return 0;\n+}"}, {"sha": "d63c1d9109965c1b4f3ac60b538ea1fb6c291b14", "filename": "libstdc++-v3/testsuite/26_numerics/inner_product/1.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Finner_product%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Finner_product%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Finner_product%2F1.cc?ref=0e6c9eaa5c0c9bf00972834f3a47e5146bd47dee", "patch": "@@ -0,0 +1,56 @@\n+// Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 26.4.2 [lib.inner_product]\n+\n+#include <numeric>\n+#include <testsuite_hooks.h>\n+\n+int A1[] = {1, 2, 3, 4,  5,  6,  7,  8,  9, 10};\n+int A2[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n+const int NA = sizeof(A1) / sizeof(int);\n+\n+bool B1[] = {false, true, true, false, true, false, true, true, false, true};\n+bool B2[] = {true, false, true, true, false, true, false, true, true, false};\n+const int NB = sizeof(B1) / sizeof(bool);\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  int res = std::inner_product(A1, A1 + NA, A2, 31);\n+  VERIFY( res == 983 );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  int res = std::inner_product(B1, B1 + NB, B2, 100);\n+  VERIFY( res == 102 );\n+}\n+\n+int\n+main()\n+{\n+    test01();\n+    test02();\n+    return 0;\n+}"}]}