{"sha": "3518f9049248650232458d2ed88b2b3bd23ea2ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUxOGY5MDQ5MjQ4NjUwMjMyNDU4ZDJlZDg4YjJiM2JkMjNlYTJhZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-01-28T18:53:11Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-01-28T18:53:11Z"}, "message": "pa.h (CPP_SPEC for OLD_CC): Delete.\n\n\t* pa.h (CPP_SPEC for OLD_CC): Delete.\n\t(CC1_SPEC for OLD_CC): Likewise.\n\t(MODES_TIEABLE_P): Simplify.\n\t(ASM_OUTPUT_ADDR_VEC_ELT): Fix comment.\n\t(leaf_function): Delete unused variable.\n\t(HARD_REGNO_MODE_OK): Delete old useless version.\n\t(FIRST_PARM_OFFSET): Likewise.\n\t(FIRST_PARM_CALLER_OFFSET): Likewise.\n\t(EXPAND_BUILTIN_SAVEREGS): Likewise.\n\t(ASM_OUTPUT_REG_PUSH): Likewise.\n\t(ASM_OUTPUT_REG_POP): Likewise\n\nFrom-SVN: r3379", "tree": {"sha": "c079403939e9984e10f583648c1d208b3915e074", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c079403939e9984e10f583648c1d208b3915e074"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3518f9049248650232458d2ed88b2b3bd23ea2ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3518f9049248650232458d2ed88b2b3bd23ea2ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3518f9049248650232458d2ed88b2b3bd23ea2ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3518f9049248650232458d2ed88b2b3bd23ea2ad/comments", "author": null, "committer": null, "parents": [{"sha": "2ac5f14ab389d8a9c52be9ebc6f457917b770caa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ac5f14ab389d8a9c52be9ebc6f457917b770caa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ac5f14ab389d8a9c52be9ebc6f457917b770caa"}], "stats": {"total": 53, "additions": 3, "deletions": 50}, "files": [{"sha": "7c954baeca9d2da6bfbf817e093cf94130859176", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 3, "deletions": 50, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3518f9049248650232458d2ed88b2b3bd23ea2ad/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3518f9049248650232458d2ed88b2b3bd23ea2ad/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=3518f9049248650232458d2ed88b2b3bd23ea2ad", "patch": "@@ -116,14 +116,7 @@ extern int target_flags;\n \n /* Defines for a K&R CC */\n \n-#ifdef OLD_CC\n-#define CPP_SPEC \"%{!gnu:-nostdinc %{!nostinc:-I/usr/include}} \\\n-  %{gnu:%{nostdinc}} %{!gnu:-traditional} -Dvolatile=__volatile\"\n-#define CC1_SPEC \"%{!gnu:-traditional -fwritable-strings -fno-defer-pop} \\\n-  %{pg:} %{p:}\"\n-#else\n #define CC1_SPEC \"%{pg:} %{p:}\"\n-#endif\n   \n #define LINK_SPEC \"-u main\"\n \n@@ -408,14 +401,6 @@ extern int target_flags;\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On the HP-PA, the cpu registers can hold any mode.  We\n    force this to be an even register is it cannot hold the full mode.  */\n-#if 0\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  ((REGNO) == 0 ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\\\n-   : (REGNO) < 32 ? ((GET_MODE_SIZE (MODE) <= 4) ? 1 : ((REGNO) & 1) == 0)\\\n-   : (REGNO) < 48 ? (GET_MODE_SIZE (MODE) >= 4)\t\t\t\t\\\n-   : (GET_MODE_SIZE (MODE) > 4 ? ((REGNO) & 1) == 0\t\t\t\\\n-      : GET_MODE_SIZE (MODE) == 4))\n-#endif\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((REGNO) == 0 ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\\\n    : (REGNO) < 32 ? ((GET_MODE_SIZE (MODE) <= 4) ? 1 : ((REGNO) & 1) == 0)\\\n@@ -428,7 +413,7 @@ extern int target_flags;\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n    for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  ((MODE1) == (MODE2) || GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n+  (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n \n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n@@ -442,12 +427,7 @@ extern int target_flags;\n /* Base register for access to local variables of the function.  */\n #define FRAME_POINTER_REGNUM 4\n \n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-extern int leaf_function;\n-\n+/* Value should be nonzero if functions must have frame pointers. */\n #define FRAME_POINTER_REQUIRED (current_function_calls_alloca)\n   \n \n@@ -656,13 +636,11 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n \n    ??? Have to check on this.*/\n \n-/* #define FIRST_PARM_OFFSET(FNDECL) 36  */\n #define FIRST_PARM_OFFSET(FNDECL) -32 \n \n /* Absolute value of offset from top-of-stack address to location to store the\n    function parameter if it can't go in a register.\n    Addresses for following parameters are computed relative to this one.  */\n-/* #define FIRST_PARM_CALLER_OFFSET(FNDECL) 36 */\n #define FIRST_PARM_CALLER_OFFSET(FNDECL) -32 \n \n \n@@ -991,20 +969,6 @@ extern union tree_node *current_function_decl;\n    Ordinarily they are not call used registers, but they are for\n    _builtin_saveregs, so we must make this explicit.  */\n \n-\n-#if 0\n-#define EXPAND_BUILTIN_SAVEREGS(ARGLIST)\t\t\t\t\\\n-  (emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, TImode, 23))),\t\\\n-   (TARGET_SNAKE ?\t\t\t\t\t\t\t\\\n-    (emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 56))),\t\\\n-     emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 58))),\t\\\n-     emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 60))),\t\\\n-     emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 62)))) :\t\\\n-    (emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 36))),\t\\\n-     emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 37))),\t\\\n-     emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 38))),\t\\\n-     emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 39))))))\n-#endif\n #define EXPAND_BUILTIN_SAVEREGS(ARGLIST) (rtx)hppa_builtin_saveregs (ARGLIST)\n \n \f\n@@ -1710,22 +1674,11 @@ bss_section ()\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n   output_ascii ((FILE), (P), (SIZE))\n \n-#if 0\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tstws,mb %s,4(0,30)\\n\", reg_names[REGNO])\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tldws,ma -4(0,30),%s\\n\", reg_names[REGNO])\n-#endif\n-\n #define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\n #define ASM_OUTPUT_REG_POP(FILE,REGNO) \n /* This is how to output an element of a case-vector that is absolute.\n    Note that this method makes filling these branch delay slots\n-   virtually impossible.  */\n+   impossible.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n   fprintf (FILE, \"\\tb L$%04d\\n\\tnop\\n\", VALUE)"}]}