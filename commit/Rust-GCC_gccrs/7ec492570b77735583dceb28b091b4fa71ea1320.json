{"sha": "7ec492570b77735583dceb28b091b4fa71ea1320", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VjNDkyNTcwYjc3NzM1NTgzZGNlYjI4YjA5MWI0ZmE3MWVhMTMyMA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2009-05-20T10:18:10Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-05-20T10:18:10Z"}, "message": "tree-flow.h (insert_edge_copies_seq): Undeclare.\n\n2009-05-20  Martin Jambor  <mjambor@suse.cz>\n\n\t* tree-flow.h (insert_edge_copies_seq): Undeclare.\n\t(sra_insert_before): Likewise.\n\t(sra_insert_after): Likewise.\n\t(sra_init_cache): Likewise.\n\t(sra_type_can_be_decomposed_p): Likewise.\n\t* tree-mudflap.c (insert_edge_copies_seq): Copied here from tree-sra.c\n\t* tree-sra.c (sra_type_can_be_decomposed_p): Made static.\n\t(sra_insert_before): Likewise.\n\t(sra_insert_after): Likewise.\n\t(sra_init_cache): Likewise.\n\t(insert_edge_copies_seq): Made static and moved upwards.\n\n\t* tree-complex.c (extract_component): Added VIEW_CONVERT_EXPR switch\n\tcase.\n\n\t* tree-flow-inline.h (contains_view_convert_expr_p): New function.\n\n\t* ipa-prop.c (get_ssa_def_if_simple_copy): New function.\n\t(determine_cst_member_ptr): Call get_ssa_def_if_simple_copy to skip\n\tsimple copies.\n\nFrom-SVN: r147733", "tree": {"sha": "c7a89b4084761b0c88e079e93dac65e6158c5343", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7a89b4084761b0c88e079e93dac65e6158c5343"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ec492570b77735583dceb28b091b4fa71ea1320", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ec492570b77735583dceb28b091b4fa71ea1320", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ec492570b77735583dceb28b091b4fa71ea1320", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ec492570b77735583dceb28b091b4fa71ea1320/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3f6f0eb2e4a89be2eed80ad57bf003c3fc0aa210", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f6f0eb2e4a89be2eed80ad57bf003c3fc0aa210", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f6f0eb2e4a89be2eed80ad57bf003c3fc0aa210"}], "stats": {"total": 132, "additions": 101, "deletions": 31}, "files": [{"sha": "0e39144b79cb5e58ba63c4d1aeccd092bcb50d6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec492570b77735583dceb28b091b4fa71ea1320/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec492570b77735583dceb28b091b4fa71ea1320/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ec492570b77735583dceb28b091b4fa71ea1320", "patch": "@@ -1,3 +1,26 @@\n+2009-05-20  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* tree-flow.h (insert_edge_copies_seq): Undeclare.\n+\t(sra_insert_before): Likewise.\n+\t(sra_insert_after): Likewise.\n+\t(sra_init_cache): Likewise.\n+\t(sra_type_can_be_decomposed_p): Likewise.\n+\t* tree-mudflap.c (insert_edge_copies_seq): Copied here from tree-sra.c\n+\t* tree-sra.c (sra_type_can_be_decomposed_p): Made static.\n+\t(sra_insert_before): Likewise.\n+\t(sra_insert_after): Likewise.\n+\t(sra_init_cache): Likewise.\n+\t(insert_edge_copies_seq): Made static and moved upwards.\n+\n+\t* tree-complex.c (extract_component): Added VIEW_CONVERT_EXPR switch\n+\tcase.\n+\n+\t* tree-flow-inline.h (contains_view_convert_expr_p): New function.\n+\n+\t* ipa-prop.c (get_ssa_def_if_simple_copy): New function.\n+\t(determine_cst_member_ptr): Call get_ssa_def_if_simple_copy to skip\n+\tsimple copies.\n+\n 2009-05-20  Richard Guenther  <rguenther@suse.de>\n \n \t* expr.c (expand_expr_real_1): Avoid calling do_store_flag"}, {"sha": "6f5e26b2042dc6bd6fe9885530ed2098c7ade0bd", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec492570b77735583dceb28b091b4fa71ea1320/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec492570b77735583dceb28b091b4fa71ea1320/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=7ec492570b77735583dceb28b091b4fa71ea1320", "patch": "@@ -428,6 +428,22 @@ fill_member_ptr_cst_jump_function (struct ipa_jump_func *jfunc,\n   jfunc->value.member_cst.delta = delta;\n }\n \n+/* If RHS is an SSA_NAMe and it is defined by a simple copy assign statement,\n+   return the rhs of its defining statement.  */\n+\n+static inline tree\n+get_ssa_def_if_simple_copy (tree rhs)\n+{\n+  while (TREE_CODE (rhs) == SSA_NAME && !SSA_NAME_IS_DEFAULT_DEF (rhs))\n+    {\n+      gimple def_stmt = SSA_NAME_DEF_STMT (rhs);\n+\n+      if (gimple_assign_single_p (def_stmt))\n+\trhs = gimple_assign_rhs1 (def_stmt);\n+    }\n+  return rhs;\n+}\n+\n /* Traverse statements from CALL backwards, scanning whether the argument ARG\n    which is a member pointer is filled in with constant values.  If it is, fill\n    the jump function JFUNC in appropriately.  METHOD_FIELD and DELTA_FIELD are\n@@ -467,6 +483,7 @@ determine_cst_member_ptr (gimple call, tree arg, tree method_field,\n       fld = TREE_OPERAND (lhs, 1);\n       if (!method && fld == method_field)\n \t{\n+\t  rhs = get_ssa_def_if_simple_copy (rhs);\n \t  if (TREE_CODE (rhs) == ADDR_EXPR\n \t      && TREE_CODE (TREE_OPERAND (rhs, 0)) == FUNCTION_DECL\n \t      && TREE_CODE (TREE_TYPE (TREE_OPERAND (rhs, 0))) == METHOD_TYPE)\n@@ -484,6 +501,7 @@ determine_cst_member_ptr (gimple call, tree arg, tree method_field,\n \n       if (!delta && fld == delta_field)\n \t{\n+\t  rhs = get_ssa_def_if_simple_copy (rhs);\n \t  if (TREE_CODE (rhs) == INTEGER_CST)\n \t    {\n \t      delta = rhs;"}, {"sha": "3f1992b716b1fc2c19f8bdee3eac98d6fee62416", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec492570b77735583dceb28b091b4fa71ea1320/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec492570b77735583dceb28b091b4fa71ea1320/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=7ec492570b77735583dceb28b091b4fa71ea1320", "patch": "@@ -604,6 +604,7 @@ extract_component (gimple_stmt_iterator *gsi, tree t, bool imagpart_p,\n     case INDIRECT_REF:\n     case COMPONENT_REF:\n     case ARRAY_REF:\n+    case VIEW_CONVERT_EXPR:\n       {\n \ttree inner_type = TREE_TYPE (TREE_TYPE (t));\n "}, {"sha": "e6de3772c3c004872e3b03b8e3eb521021de436c", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec492570b77735583dceb28b091b4fa71ea1320/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec492570b77735583dceb28b091b4fa71ea1320/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=7ec492570b77735583dceb28b091b4fa71ea1320", "patch": "@@ -1136,6 +1136,21 @@ ref_contains_array_ref (const_tree ref)\n   return false;\n }\n \n+/* Return true if REF has an VIEW_CONVERT_EXPR somewhere in it.  */\n+\n+static inline bool\n+contains_view_convert_expr_p (const_tree ref)\n+{\n+  while (handled_component_p (ref))\n+    {\n+      if (TREE_CODE (ref) == VIEW_CONVERT_EXPR)\n+\treturn true;\n+      ref = TREE_OPERAND (ref, 0);\n+    }\n+\n+  return false;\n+}\n+\n /* Return true, if the two ranges [POS1, SIZE1] and [POS2, SIZE2]\n    overlap.  SIZE1 and/or SIZE2 can be (unsigned)-1 in which case the\n    range is open-ended.  Otherwise return false.  */"}, {"sha": "df14eeb22680723947f6af28b22312991e39b647", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec492570b77735583dceb28b091b4fa71ea1320/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec492570b77735583dceb28b091b4fa71ea1320/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=7ec492570b77735583dceb28b091b4fa71ea1320", "patch": "@@ -881,13 +881,6 @@ tree vn_lookup_with_vuses (tree, VEC (tree, gc) *);\n /* In tree-ssa-sink.c  */\n bool is_hidden_global_store (gimple);\n \n-/* In tree-sra.c  */\n-void insert_edge_copies_seq (gimple_seq, basic_block);\n-void sra_insert_before (gimple_stmt_iterator *, gimple_seq);\n-void sra_insert_after (gimple_stmt_iterator *, gimple_seq);\n-void sra_init_cache (void);\n-bool sra_type_can_be_decomposed_p (tree);\n-\n /* In tree-loop-linear.c  */\n extern void linear_transform_loops (void);\n extern unsigned perfect_loop_nest_depth (struct loop *);"}, {"sha": "5f4f5ac0b2958c194931dd403a54661b85d1b243", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec492570b77735583dceb28b091b4fa71ea1320/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec492570b77735583dceb28b091b4fa71ea1320/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=7ec492570b77735583dceb28b091b4fa71ea1320", "patch": "@@ -447,6 +447,26 @@ execute_mudflap_function_ops (void)\n   return 0;\n }\n \n+/* Insert a gimple_seq SEQ on all the outgoing edges out of BB.  Note that\n+   if BB has more than one edge, STMT will be replicated for each edge.\n+   Also, abnormal edges will be ignored.  */\n+\n+static void\n+insert_edge_copies_seq (gimple_seq seq, basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  unsigned n_copies = -1;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (!(e->flags & EDGE_ABNORMAL))\n+      n_copies++;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (!(e->flags & EDGE_ABNORMAL))\n+      gsi_insert_seq_on_edge (e, n_copies-- > 0 ? gimple_seq_copy (seq) : seq);\n+}\n+\n /* Create and initialize local shadow variables for the lookup cache\n    globals.  Put their decls in the *_l globals for use by\n    mf_build_check_statement_for.  */"}, {"sha": "0f68941716373cfbe8ecde5aecce3e50b0b5f22a", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec492570b77735583dceb28b091b4fa71ea1320/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec492570b77735583dceb28b091b4fa71ea1320/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=7ec492570b77735583dceb28b091b4fa71ea1320", "patch": "@@ -236,7 +236,7 @@ is_sra_scalar_type (tree type)\n    instantiated, just that if we decide to break up the type into\n    separate pieces that it can be done.  */\n \n-bool\n+static bool\n sra_type_can_be_decomposed_p (tree type)\n {\n   unsigned int cache = TYPE_UID (TYPE_MAIN_VARIANT (type)) * 2;\n@@ -1267,6 +1267,26 @@ build_element_name (struct sra_elt *elt)\n   return XOBFINISH (&sra_obstack, char *);\n }\n \n+/* Insert a gimple_seq SEQ on all the outgoing edges out of BB.  Note that\n+   if BB has more than one edge, STMT will be replicated for each edge.\n+   Also, abnormal edges will be ignored.  */\n+\n+static void\n+insert_edge_copies_seq (gimple_seq seq, basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  unsigned n_copies = -1;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (!(e->flags & EDGE_ABNORMAL))\n+      n_copies++;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (!(e->flags & EDGE_ABNORMAL))\n+      gsi_insert_seq_on_edge (e, n_copies-- > 0 ? gimple_seq_copy (seq) : seq);\n+}\n+\n /* Instantiate an element as an independent variable.  */\n \n static void\n@@ -2789,29 +2809,9 @@ generate_element_init (struct sra_elt *elt, tree init, gimple_seq *seq_p)\n   return ret;\n }\n \n-/* Insert a gimple_seq SEQ on all the outgoing edges out of BB.  Note that\n-   if BB has more than one edge, STMT will be replicated for each edge.\n-   Also, abnormal edges will be ignored.  */\n-\n-void\n-insert_edge_copies_seq (gimple_seq seq, basic_block bb)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  unsigned n_copies = -1;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (!(e->flags & EDGE_ABNORMAL)) \n-      n_copies++;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (!(e->flags & EDGE_ABNORMAL)) \n-      gsi_insert_seq_on_edge (e, n_copies-- > 0 ? gimple_seq_copy (seq) : seq);\n-}\n-\n /* Helper function to insert LIST before GSI, and set up line number info.  */\n \n-void\n+static void\n sra_insert_before (gimple_stmt_iterator *gsi, gimple_seq seq)\n {\n   gimple stmt = gsi_stmt (*gsi);\n@@ -2823,7 +2823,7 @@ sra_insert_before (gimple_stmt_iterator *gsi, gimple_seq seq)\n \n /* Similarly, but insert after GSI.  Handles insertion onto edges as well.  */\n \n-void\n+static void\n sra_insert_after (gimple_stmt_iterator *gsi, gimple_seq seq)\n {\n   gimple stmt = gsi_stmt (*gsi);\n@@ -3601,7 +3601,7 @@ debug_sra_elt_name (struct sra_elt *elt)\n   fputc ('\\n', stderr);\n }\n \n-void \n+static void\n sra_init_cache (void)\n {\n   if (sra_type_decomp_cache)"}]}