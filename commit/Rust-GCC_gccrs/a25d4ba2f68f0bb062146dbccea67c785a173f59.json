{"sha": "a25d4ba2f68f0bb062146dbccea67c785a173f59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI1ZDRiYTJmNjhmMGJiMDYyMTQ2ZGJjY2VhNjdjNzg1YTE3M2Y1OQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-10-06T10:52:10Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-10-06T10:52:10Z"}, "message": "(struct temp_slot): New field addr_taken.\n\n(assign_stack_temp): Initialize it.\n(mark_temp_addr_taken): New function.\n(preserve_temp_slots): Decrement level of things at same level but whose\naddress has been taken.\n\nFrom-SVN: r8224", "tree": {"sha": "080f358cd340fcea14e86010cc016521aeeecace", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/080f358cd340fcea14e86010cc016521aeeecace"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a25d4ba2f68f0bb062146dbccea67c785a173f59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25d4ba2f68f0bb062146dbccea67c785a173f59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a25d4ba2f68f0bb062146dbccea67c785a173f59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25d4ba2f68f0bb062146dbccea67c785a173f59/comments", "author": null, "committer": null, "parents": [{"sha": "3ac4f0e6d01988a06968fbf268f6f7a00bafb672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac4f0e6d01988a06968fbf268f6f7a00bafb672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ac4f0e6d01988a06968fbf268f6f7a00bafb672"}], "stats": {"total": 54, "additions": 43, "deletions": 11}, "files": [{"sha": "acb042e1f0c1ba989d92d7fa47801e8e957125e8", "filename": "gcc/function.c", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25d4ba2f68f0bb062146dbccea67c785a173f59/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25d4ba2f68f0bb062146dbccea67c785a173f59/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a25d4ba2f68f0bb062146dbccea67c785a173f59", "patch": "@@ -356,6 +356,8 @@ struct temp_slot\n   tree rtl_expr;\n   /* Non-zero if this temporary is currently in use.  */\n   char in_use;\n+  /* Non-zero if this temporary has its address taken.  */\n+  char addr_taken;\n   /* Nesting level at which this slot is being used.  */\n   int level;\n   /* Non-zero if this should survive a call to free_temp_slots.  */\n@@ -827,7 +829,7 @@ assign_stack_temp (mode, size, keep)\n \t  if (best_p->size - rounded_size >= alignment)\n \t    {\n \t      p = (struct temp_slot *) oballoc (sizeof (struct temp_slot));\n-\t      p->in_use = 0;\n+\t      p->in_use = p->addr_taken = 0;\n \t      p->size = best_p->size - rounded_size;\n \t      p->slot = gen_rtx (MEM, BLKmode,\n \t\t\t\t plus_constant (XEXP (best_p->slot, 0),\n@@ -860,7 +862,9 @@ assign_stack_temp (mode, size, keep)\n     }\n \n   p->in_use = 1;\n+  p->addr_taken = 0;\n   p->rtl_expr = sequence_rtl_expr;\n+\n   if (keep == 2)\n     {\n       p->level = target_temp_slot_level;\n@@ -984,6 +988,28 @@ update_temp_slot_address (old, new)\n     }\n }\n \n+/* If X could be a reference to a temporary slot, mark the fact that its\n+   adddress was taken.  */\n+\n+void\n+mark_temp_addr_taken (x)\n+     rtx x;\n+{\n+  struct temp_slot *p;\n+\n+  if (x == 0)\n+    return;\n+\n+  /* If X is not in memory or is at a constant address, it cannot be in\n+     a temporary slot.  */\n+  if (GET_CODE (x) != MEM || CONSTANT_P (XEXP (x, 0)))\n+    return;\n+\n+  p = find_temp_slot_from_address (XEXP (x, 0));\n+  if (p != 0)\n+    p->addr_taken = 1;\n+}\n+\n /* If X could be a reference to a temporary slot, mark that slot as belonging\n    to the to one level higher.  If X matched one of our slots, just mark that\n    one.  Otherwise, we can't easily predict which it is, so upgrade all of\n@@ -996,7 +1022,7 @@ void\n preserve_temp_slots (x)\n      rtx x;\n {\n-  struct temp_slot *p;\n+  struct temp_slot *p = 0;\n \n   if (x == 0)\n     return;\n@@ -1005,22 +1031,28 @@ preserve_temp_slots (x)\n      a temporary slot we know it points to.  To be consistent with\n      the code below, we really should preserve all non-kept slots\n      if we can't find a match, but that seems to be much too costly.  */\n-  if (GET_CODE (x) == REG && REGNO_POINTER_FLAG (REGNO (x))\n-      && (p = find_temp_slot_from_address (x)) != 0)\n-    {\n-      p->level--;\n-      return;\n-    }\n-    \n+  if (GET_CODE (x) == REG && REGNO_POINTER_FLAG (REGNO (x)))\n+    p = find_temp_slot_from_address (x);\n+\n   /* If X is not in memory or is at a constant address, it cannot be in\n      a temporary slot.  */\n-  if (GET_CODE (x) != MEM || CONSTANT_P (XEXP (x, 0)))\n+  if (p == 0 && (GET_CODE (x) != MEM || CONSTANT_P (XEXP (x, 0))))\n     return;\n \n   /* First see if we can find a match.  */\n-  p = find_temp_slot_from_address (XEXP (x, 0));\n+  if (p== 0)\n+    p = find_temp_slot_from_address (XEXP (x, 0));\n+\n   if (p != 0)\n     {\n+      /* Move everything at our level whose address was taken to our new\n+\t level in case we used its address.  */\n+      struct temp_slot *q;\n+\n+      for (q = temp_slots; q; q = q->next)\n+\tif (q != p && q->addr_taken && q->level == p->level)\n+\t  q->level--;\n+\n       p->level--;\n       return;\n     }"}]}