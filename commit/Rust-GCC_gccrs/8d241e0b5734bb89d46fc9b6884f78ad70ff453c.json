{"sha": "8d241e0b5734bb89d46fc9b6884f78ad70ff453c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQyNDFlMGI1NzM0YmI4OWQ0NmZjOWI2ODg0Zjc4YWQ3MGZmNDUzYw==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2003-05-10T11:06:26Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2003-05-10T11:06:26Z"}, "message": "re PR c++/9554 (Out of class declaration of member class template specialisation rejected)\n\n\tPR c++/9554\n\t* parser.c (cp_parser_class_name): Remove check_access parameter.\n\tAll caller adjusted.  Update declaration.\n\t(cp_parser_lookup_name): Likewise.\n\t* semantics.c (push_deferring_access_checks): Change parameter type\n\tto enum deferring_kind.  All caller adjusted.\n\t(resume_deferring_access_checks): Adjust to use new enum.\n\t(stop_deferring_access_checks): Likewise.\n\t(perform_or_defer_access_check): Likewise.\n\t* cp-tree.h (deferring_kind): New enum.\n\t(deferred_access): Adjust field type.\n\t(push_deferring_access_checks): Update declaration.\n\n\t* g++.dg/parse/access1.C: New test.\n\nFrom-SVN: r66659", "tree": {"sha": "6751b007e2578a4d8d505023786d468444b3694f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6751b007e2578a4d8d505023786d468444b3694f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d241e0b5734bb89d46fc9b6884f78ad70ff453c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d241e0b5734bb89d46fc9b6884f78ad70ff453c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d241e0b5734bb89d46fc9b6884f78ad70ff453c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d241e0b5734bb89d46fc9b6884f78ad70ff453c/comments", "author": null, "committer": null, "parents": [{"sha": "9ca5e6948d2326407210c8a88f1784ff818d2ff5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ca5e6948d2326407210c8a88f1784ff818d2ff5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ca5e6948d2326407210c8a88f1784ff818d2ff5"}], "stats": {"total": 182, "additions": 132, "deletions": 50}, "files": [{"sha": "2087066e0e70fa024219e498e09d7c29c27df5e7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d241e0b5734bb89d46fc9b6884f78ad70ff453c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d241e0b5734bb89d46fc9b6884f78ad70ff453c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8d241e0b5734bb89d46fc9b6884f78ad70ff453c", "patch": "@@ -1,3 +1,18 @@\n+2003-05-10  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/9554\n+\t* parser.c (cp_parser_class_name): Remove check_access parameter.\n+\tAll caller adjusted.  Update declaration.\n+\t(cp_parser_lookup_name): Likewise.\n+\t* semantics.c (push_deferring_access_checks): Change parameter type\n+\tto enum deferring_kind.  All caller adjusted.\n+\t(resume_deferring_access_checks): Adjust to use new enum.\n+\t(stop_deferring_access_checks): Likewise.\n+\t(perform_or_defer_access_check): Likewise.\n+\t* cp-tree.h (deferring_kind): New enum.\n+\t(deferred_access): Adjust field type.\n+\t(push_deferring_access_checks): Update declaration.\n+\n 2003-05-09  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/10555, c++/10576"}, {"sha": "89d068a2183613792b7fcca2b5b8cf0764128250", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d241e0b5734bb89d46fc9b6884f78ad70ff453c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d241e0b5734bb89d46fc9b6884f78ad70ff453c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8d241e0b5734bb89d46fc9b6884f78ad70ff453c", "patch": "@@ -3030,6 +3030,13 @@ typedef enum base_access {\n   ba_quiet = 4     /* Do not issue error messages (bit mask).  */\n } base_access;\n \n+/* The various kinds of access check during parsing.  */\n+typedef enum deferring_kind {\n+  dk_no_deferred = 0, /* Check access immediately */\n+  dk_deferred = 1,    /* Deferred check */\n+  dk_no_check = 2     /* No access check */\n+} deferring_kind;\n+\n /* The kind of base we can find, looking in a class hierarchy.\n    Values <0 indicate we failed.  */\n typedef enum base_kind {\n@@ -3088,8 +3095,8 @@ typedef struct deferred_access GTY(())\n      name being looked up; the TREE_VALUE is the DECL to which the\n      name was resolved.  */\n   tree deferred_access_checks;\n-  /* TRUE iff we are deferring access checks.  */\n-  bool deferring_access_checks_p;\n+  /* The current mode of access checks.  */\n+  enum deferring_kind deferring_access_checks_kind;\n   /* The next deferred access data in stack or linked-list.  */\n   struct deferred_access *next;\n } deferred_access;\n@@ -4044,7 +4051,7 @@ extern tree copied_binfo\t\t\t(tree, tree);\n extern tree original_binfo\t\t\t(tree, tree);\n \n /* in semantics.c */\n-extern void push_deferring_access_checks\t(bool defer_p);\n+extern void push_deferring_access_checks\t(deferring_kind);\n extern void resume_deferring_access_checks\t(void);\n extern void stop_deferring_access_checks\t(void);\n extern void pop_deferring_access_checks\t\t(void);"}, {"sha": "607749b234508592804c86200ec5c32b7a84b37b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 28, "deletions": 42, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d241e0b5734bb89d46fc9b6884f78ad70ff453c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d241e0b5734bb89d46fc9b6884f78ad70ff453c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=8d241e0b5734bb89d46fc9b6884f78ad70ff453c", "patch": "@@ -1545,7 +1545,7 @@ static bool cp_parser_ctor_initializer_opt_and_function_body\n /* Classes [gram.class] */\n \n static tree cp_parser_class_name\n-  (cp_parser *, bool, bool, bool, bool, bool, bool);\n+  (cp_parser *, bool, bool, bool, bool, bool);\n static tree cp_parser_class_specifier\n   (cp_parser *);\n static tree cp_parser_class_head\n@@ -1654,7 +1654,7 @@ static void cp_parser_label_declaration\n /* Utility Routines */\n \n static tree cp_parser_lookup_name\n-  (cp_parser *, tree, bool, bool, bool, bool);\n+  (cp_parser *, tree, bool, bool, bool);\n static tree cp_parser_lookup_name_simple\n   (cp_parser *, tree);\n static tree cp_parser_maybe_treat_template_as_class\n@@ -1914,7 +1914,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser)\n     {\n       tree name;\n \n-      /* If parsing tenatively, we should commit; we really are\n+      /* If parsing tentatively, we should commit; we really are\n \t looking at a declaration.  */\n       /* Consume the first identifier.  */\n       name = cp_lexer_consume_token (parser->lexer)->value;\n@@ -3081,7 +3081,6 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t\t\t\t\t      /*typename_keyword_p=*/false,\n \t\t\t\t\t      /*template_keyword_p=*/false,\n \t\t\t\t\t      /*type_p=*/false,\n-\t\t\t\t\t      /*check_access_p=*/true,\n \t\t\t\t\t      /*check_dependency=*/false,\n \t\t\t\t\t      /*class_head_p=*/false);\n \t    if (cp_parser_parse_definitely (parser))\n@@ -3099,7 +3098,6 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t\t\t\t      /*typename_keyword_p=*/false,\n \t\t\t\t      /*template_keyword_p=*/false,\n \t\t\t\t      /*type_p=*/false,\n-\t\t\t\t      /*check_access_p=*/true,\n \t\t\t\t      /*check_dependency=*/false,\n \t\t\t\t      /*class_head_p=*/false);\n \t    if (cp_parser_parse_definitely (parser))\n@@ -3117,7 +3115,6 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t\t\t\t      /*typename_keyword_p=*/false,\n \t\t\t\t      /*template_keyword_p=*/false,\n \t\t\t\t      /*type_p=*/false,\n-\t\t\t\t      /*check_access_p=*/true,\n \t\t\t\t      /*check_dependency=*/false,\n \t\t\t\t      /*class_head_p=*/false);\n \t    if (cp_parser_parse_definitely (parser))\n@@ -3132,7 +3129,6 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t\t\t\t  /*typename_keyword_p=*/false,\n \t\t\t\t  /*template_keyword_p=*/false,\n \t\t\t\t  /*type_p=*/false,\n-\t\t\t\t  /*check_access_p=*/true,\n \t\t\t\t  /*check_dependency=*/false,\n \t\t\t\t  /*class_head_p=*/false);\n \t/* If an error occurred, assume that the name of the\n@@ -3232,7 +3228,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n   else\n     start = -1;\n \n-  push_deferring_access_checks (true);\n+  push_deferring_access_checks (dk_deferred);\n \n   while (true)\n     {\n@@ -3485,7 +3481,6 @@ cp_parser_class_or_namespace_name (cp_parser *parser,\n \t\t\t\ttypename_keyword_p,\n \t\t\t\ttemplate_keyword_p,\n \t\t\t\ttype_p,\n-\t\t\t\t/*check_access_p=*/true,\n \t\t\t\tcheck_dependency_p,\n \t\t\t\t/*class_head_p=*/false);\n   /* If that didn't work, try for a namespace-name.  */\n@@ -6535,7 +6530,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n   /* Defer access checks until we know what is being declared; the\n      checks for names appearing in the decl-specifier-seq should be\n      done as if we were in the scope of the thing being declared.  */\n-  push_deferring_access_checks (true);\n+  push_deferring_access_checks (dk_deferred);\n \n   /* Parse the decl-specifier-seq.  We have to keep track of whether\n      or not the decl-specifier-seq declares a named class or\n@@ -6564,7 +6559,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n      where \"T\" should name a type -- but does not.  */\n   if (cp_parser_diagnose_invalid_type_name (parser))\n     {\n-      /* If parsing tenatively, we should commit; we really are\n+      /* If parsing tentatively, we should commit; we really are\n \t looking at a declaration.  */\n       cp_parser_commit_to_tentative_parse (parser);\n       /* Give up.  */\n@@ -7312,7 +7307,6 @@ cp_parser_mem_initializer_id (cp_parser* parser)\n \t\t\t\t /*typename_keyword_p=*/true,\n \t\t\t\t /*template_keyword_p=*/false,\n \t\t\t\t /*type_p=*/false,\n-\t\t\t\t /*check_access_p=*/true,\n \t\t\t\t /*check_dependency_p=*/true,\n \t\t\t\t /*class_head_p=*/false);\n   /* Otherwise, we could also be looking for an ordinary identifier.  */\n@@ -7322,7 +7316,6 @@ cp_parser_mem_initializer_id (cp_parser* parser)\n \t\t\t     /*typename_keyword_p=*/true,\n \t\t\t     /*template_keyword_p=*/false,\n \t\t\t     /*type_p=*/false,\n-\t\t\t     /*check_access_p=*/true,\n \t\t\t     /*check_dependency_p=*/true,\n \t\t\t     /*class_head_p=*/false);\n   /* If we found one, we're done.  */\n@@ -7942,7 +7935,7 @@ cp_parser_template_id (cp_parser *parser,\n   else\n     start_of_id = -1;\n \n-  push_deferring_access_checks (true);\n+  push_deferring_access_checks (dk_deferred);\n \n   /* Parse the template-name.  */\n   template = cp_parser_template_name (parser, template_keyword_p,\n@@ -8116,7 +8109,6 @@ cp_parser_template_name (cp_parser* parser,\n \n   /* Look up the name.  */\n   decl = cp_parser_lookup_name (parser, identifier,\n-\t\t\t\t/*check_access=*/true,\n \t\t\t\t/*is_type=*/false,\n \t\t\t\t/*is_namespace=*/false,\n \t\t\t\tcheck_dependency_p);\n@@ -8343,7 +8335,7 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n     }\n   /* We're done with the instantiation.  */\n   end_explicit_instantiation ();\n-  /* Trun access control back on.  */\n+  /* Turn access control back on.  */\n   scope_chain->check_access = flag_access_control;\n \n   cp_parser_consume_semicolon_at_end_of_statement (parser);\n@@ -8687,7 +8679,6 @@ cp_parser_type_name (cp_parser* parser)\n \t\t\t\t    /*typename_keyword_p=*/false,\n \t\t\t\t    /*template_keyword_p=*/false,\n \t\t\t\t    /*type_p=*/false,\n-\t\t\t\t    /*check_access_p=*/true,\n \t\t\t\t    /*check_dependency_p=*/true,\n \t\t\t\t    /*class_head_p=*/false);\n   /* If it's not a class-name, keep looking.  */\n@@ -8846,7 +8837,6 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t     types, so we set IS_TYPE to TRUE when calling\n \t     cp_parser_lookup_name.  */\n \t  decl = cp_parser_lookup_name (parser, identifier, \n-\t\t\t\t\t/*check_access=*/true,\n \t\t\t\t\t/*is_type=*/true,\n \t\t\t\t\t/*is_namespace=*/false,\n \t\t\t\t\t/*check_dependency=*/true);\n@@ -9114,7 +9104,6 @@ cp_parser_namespace_name (cp_parser* parser)\n      function if the token after the name is the scope resolution\n      operator.)  */\n   namespace_decl = cp_parser_lookup_name (parser, identifier,\n-\t\t\t\t\t  /*check_access=*/true,\n \t\t\t\t\t  /*is_type=*/false,\n \t\t\t\t\t  /*is_namespace=*/true,\n \t\t\t\t\t  /*check_dependency=*/true);\n@@ -10957,7 +10946,7 @@ cp_parser_function_definition (cp_parser* parser, bool* friend_p)\n      function is being defined.  There is no need to do this for the\n      definition of member functions; we cannot be defining a member\n      from another class.  */\n-  push_deferring_access_checks (!member_p);\n+  push_deferring_access_checks (member_p ? dk_no_check: dk_deferred);\n \n   /* Parse the decl-specifier-seq.  */\n   decl_specifiers \n@@ -11301,10 +11290,9 @@ cp_parser_initializer_list (cp_parser* parser)\n    keyword has been used to indicate that the name that appears next\n    is a template.  TYPE_P is true iff the next name should be treated\n    as class-name, even if it is declared to be some other kind of name\n-   as well.  The accessibility of the class-name is checked iff\n-   CHECK_ACCESS_P is true.  If CHECK_DEPENDENCY_P is FALSE, names are\n-   looked up in dependent scopes.  If CLASS_HEAD_P is TRUE, this class\n-   is the class being defined in a class-head.\n+   as well.  If CHECK_DEPENDENCY_P is FALSE, names are looked up in\n+   dependent scopes.  If CLASS_HEAD_P is TRUE, this class is the class\n+   being defined in a class-head.\n \n    Returns the TYPE_DECL representing the class.  */\n \n@@ -11313,7 +11301,6 @@ cp_parser_class_name (cp_parser *parser,\n \t\t      bool typename_keyword_p, \n \t\t      bool template_keyword_p, \n \t\t      bool type_p,\n-\t\t      bool check_access_p,\n \t\t      bool check_dependency_p,\n \t\t      bool class_head_p)\n {\n@@ -11368,7 +11355,6 @@ cp_parser_class_name (cp_parser *parser,\n \t    type_p = true;\n \t  /* Look up the name.  */\n \t  decl = cp_parser_lookup_name (parser, identifier, \n-\t\t\t\t\tcheck_access_p,\n \t\t\t\t\ttype_p,\n \t\t\t\t\t/*is_namespace=*/false,\n \t\t\t\t\tcheck_dependency_p);\n@@ -11434,7 +11420,7 @@ cp_parser_class_specifier (cp_parser* parser)\n   bool nested_name_specifier_p;\n   unsigned saved_num_template_parameter_lists;\n \n-  push_deferring_access_checks (false);  \n+  push_deferring_access_checks (dk_no_deferred);\n \n   /* Parse the class-head.  */\n   type = cp_parser_class_head (parser,\n@@ -11635,6 +11621,8 @@ cp_parser_class_head (cp_parser* parser,\n   if (cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false))\n     qualified_p = true;\n \n+  push_deferring_access_checks (dk_no_check);\n+\n   /* Determine the name of the class.  Begin by looking for an\n      optional nested-name-specifier.  */\n   nested_name_specifier \n@@ -11659,8 +11647,6 @@ cp_parser_class_head (cp_parser* parser,\n            class A { class B; };\n            class A::B {};\n \t \n-\t So, we ask cp_parser_class_name not to check accessibility.  \n-\n          We do not know if we will see a class-name, or a\n \t template-name.  We look for a class-name first, in case the\n \t class-name is a template-id; if we looked for the\n@@ -11670,7 +11656,6 @@ cp_parser_class_head (cp_parser* parser,\n \t\t\t\t   /*typename_keyword_p=*/false,\n \t\t\t\t   /*template_keyword_p=*/false,\n \t\t\t\t   /*type_p=*/true,\n-\t\t\t\t   /*check_access_p=*/false,\n \t\t\t\t   /*check_dependency_p=*/false,\n \t\t\t\t   /*class_head_p=*/true);\n       /* If that didn't work, ignore the nested-name-specifier.  */\n@@ -11729,6 +11714,8 @@ cp_parser_class_head (cp_parser* parser,\n \t}\n     }\n \n+  pop_deferring_access_checks ();\n+\n   /* If it's not a `:' or a `{' then we can't really be looking at a\n      class-head, since a class-head only appears as part of a\n      class-specifier.  We have to detect this situation before calling\n@@ -12528,7 +12515,6 @@ cp_parser_base_specifier (cp_parser* parser)\n \t\t\t       class_scope_p,\n \t\t\t       template_p,\n \t\t\t       /*type_p=*/true,\n-\t\t\t       /*check_access=*/true,\n \t\t\t       /*check_dependency_p=*/true,\n \t\t\t       /*class_head_p=*/false);\n \n@@ -13172,10 +13158,6 @@ cp_parser_label_declaration (cp_parser* parser)\n    If there was no entity with the indicated NAME, the ERROR_MARK_NODE\n    is returned.\n \n-   If CHECK_ACCESS is TRUE, then access control is performed on the\n-   declaration to which the name resolves, and an error message is\n-   issued if the declaration is inaccessible.\n-\n    If IS_TYPE is TRUE, bindings that do not refer to types are\n    ignored.\n \n@@ -13186,7 +13168,7 @@ cp_parser_label_declaration (cp_parser* parser)\n    types.  */\n \n static tree\n-cp_parser_lookup_name (cp_parser *parser, tree name, bool check_access, \n+cp_parser_lookup_name (cp_parser *parser, tree name, \n \t\t       bool is_type, bool is_namespace, bool check_dependency)\n {\n   tree decl;\n@@ -13354,7 +13336,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name, bool check_access,\n \n      During an explicit instantiation, access is not checked at all,\n      as per [temp.explicit].  */\n-  if (check_access && scope_chain->check_access && DECL_P (decl))\n+  if (DECL_P (decl))\n     {\n       tree qualifying_type;\n       \n@@ -13379,7 +13361,6 @@ static tree\n cp_parser_lookup_name_simple (cp_parser* parser, tree name)\n {\n   return cp_parser_lookup_name (parser, name, \n-\t\t\t\t/*check_access=*/true,\n \t\t\t\t/*is_type=*/false,\n \t\t\t\t/*is_namespace=*/false,\n \t\t\t\t/*check_dependency=*/true);\n@@ -13664,6 +13645,9 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n   cp_parser_parse_tentatively (parser);\n   /* Assume that we are looking at a constructor declarator.  */\n   constructor_p = true;\n+\n+  push_deferring_access_checks (dk_no_check);\n+\n   /* Look for the optional `::' operator.  */\n   cp_parser_global_scope_opt (parser,\n \t\t\t      /*current_scope_valid_p=*/false);\n@@ -13699,12 +13683,14 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t\t\t\t\t/*typename_keyword_p=*/false,\n \t\t\t\t\t/*template_keyword_p=*/false,\n \t\t\t\t\t/*type_p=*/false,\n-\t\t\t\t\t/*check_access_p=*/false,\n \t\t\t\t\t/*check_dependency_p=*/false,\n \t\t\t\t\t/*class_head_p=*/false);\n       /* If there was no class-name, then this is not a constructor.  */\n       constructor_p = !cp_parser_error_occurred (parser);\n     }\n+\n+  pop_deferring_access_checks ();\n+\n   /* If we're still considering a constructor, we have to see a `(',\n      to begin the parameter-declaration-clause, followed by either a\n      `)', an `...', or a decl-specifier.  We need to check for a\n@@ -13968,7 +13954,7 @@ cp_parser_single_declaration (cp_parser* parser,\n      whether it will be a function-definition.  */\n   cp_parser_parse_tentatively (parser);\n   /* Defer access checks until we know what is being declared.  */\n-  push_deferring_access_checks (true);\n+  push_deferring_access_checks (dk_deferred);\n \n   /* Try the `decl-specifier-seq [opt] init-declarator [opt]'\n      alternative.  */\n@@ -14558,7 +14544,7 @@ cp_parser_parse_tentatively (cp_parser* parser)\n   /* In order to avoid repetitive access control error messages,\n      access checks are queued up until we are no longer parsing\n      tentatively.  */\n-  push_deferring_access_checks (true);\n+  push_deferring_access_checks (dk_deferred);\n }\n \n /* Commit to the currently active tentative parse.  */\n@@ -14678,7 +14664,7 @@ yyparse (void)\n   bool error_occurred;\n \n   the_parser = cp_parser_new ();\n-  push_deferring_access_checks (false);\n+  push_deferring_access_checks (dk_no_deferred);\n   error_occurred = cp_parser_translation_unit (the_parser);\n   the_parser = NULL;\n   "}, {"sha": "dfe40ee02786eb5f494856edab074ec36ba43060", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d241e0b5734bb89d46fc9b6884f78ad70ff453c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d241e0b5734bb89d46fc9b6884f78ad70ff453c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=8d241e0b5734bb89d46fc9b6884f78ad70ff453c", "patch": "@@ -79,14 +79,65 @@ static tree clear_decl_rtl PARAMS ((tree *, int *, void *));\n       (SUBSTMT) = (COND);\t\t\t\t\\\n   } while (0)\n \n+/* Deferred Access Checking Overview\n+   ---------------------------------\n+\n+   Most C++ expressions and declarations require access checking\n+   to be performed during parsing.  However, in several cases,\n+   this has to be treated differently.\n+\n+   For member declarations, access checking has to be deferred\n+   until more information about the declaration is known.  For\n+   example:\n+\n+     class A {\n+         typedef int X;\n+       public:\n+         X f();\n+     };\n+\n+     A::X A::f();\n+     A::X g();\n+\n+   When we are parsing the function return type `A::X', we don't\n+   really know if this is allowed until we parse the function name.\n+\n+   Furthermore, some contexts require that access checking is\n+   never performed at all.  These include class heads, and template\n+   instantiations.\n+\n+   Typical use of access checking functions is described here:\n+   \n+   1. When we enter a context that requires certain access checking\n+      mode, the function `push_deferring_access_checks' is called with\n+      DEFERRING argument specifying the desired mode.  Access checking\n+      may be performed immediately (dk_no_deferred), deferred\n+      (dk_deferred), or not performed (dk_no_check).\n+\n+   2. When a declaration such as a type, or a variable, is encountered,\n+      the function `perform_or_defer_access_check' is called.  It\n+      maintains a TREE_LIST of all deferred checks.\n+\n+   3. The global `current_class_type' or `current_function_decl' is then\n+      setup by the parser.  `enforce_access' relies on these information\n+      to check access.\n+\n+   4. Upon exiting the context mentioned in step 1,\n+      `perform_deferred_access_checks' is called to check all declaration\n+      stored in the TREE_LIST.   `pop_deferring_access_checks' is then\n+      called to restore the previous access checking mode.\n+\n+      In case of parsing error, we simply call `pop_deferring_access_checks'\n+      without `perform_deferred_access_checks'.  */\n+\n /* Data for deferred access checking.  */\n static GTY(()) deferred_access *deferred_access_stack;\n static GTY(()) deferred_access *deferred_access_free_list;\n \n /* Save the current deferred access states and start deferred\n    access checking iff DEFER_P is true.  */\n \n-void push_deferring_access_checks (bool deferring_p)\n+void push_deferring_access_checks (deferring_kind deferring)\n {\n   deferred_access *d;\n \n@@ -101,7 +152,7 @@ void push_deferring_access_checks (bool deferring_p)\n \n   d->next = deferred_access_stack;\n   d->deferred_access_checks = NULL_TREE;\n-  d->deferring_access_checks_p = deferring_p;\n+  d->deferring_access_checks_kind = deferring;\n   deferred_access_stack = d;\n }\n \n@@ -110,14 +161,16 @@ void push_deferring_access_checks (bool deferring_p)\n \n void resume_deferring_access_checks (void)\n {\n-  deferred_access_stack->deferring_access_checks_p = true;\n+  if (deferred_access_stack->deferring_access_checks_kind == dk_no_deferred)\n+    deferred_access_stack->deferring_access_checks_kind = dk_deferred;\n }\n \n /* Stop deferring access checks.  */\n \n void stop_deferring_access_checks (void)\n {\n-  deferred_access_stack->deferring_access_checks_p = false;\n+  if (deferred_access_stack->deferring_access_checks_kind == dk_deferred)\n+    deferred_access_stack->deferring_access_checks_kind = dk_no_deferred;\n }\n \n /* Discard the current deferred access checks and restore the\n@@ -199,11 +252,14 @@ void perform_or_defer_access_check (tree class_type, tree decl)\n   tree check;\n \n   /* If we are not supposed to defer access checks, just check now.  */\n-  if (!deferred_access_stack->deferring_access_checks_p)\n+  if (deferred_access_stack->deferring_access_checks_kind == dk_no_deferred)\n     {\n       enforce_access (class_type, decl);\n       return;\n     }\n+  /* Exit if we are in a context that no access checking is performed.  */\n+  else if (deferred_access_stack->deferring_access_checks_kind == dk_no_check)\n+    return;\n \n   /* See if we are already going to perform this check.  */\n   for (check = deferred_access_stack->deferred_access_checks;"}, {"sha": "e30b5805844498c517fc800a2a717b26dc921356", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d241e0b5734bb89d46fc9b6884f78ad70ff453c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d241e0b5734bb89d46fc9b6884f78ad70ff453c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8d241e0b5734bb89d46fc9b6884f78ad70ff453c", "patch": "@@ -1,3 +1,8 @@\n+2003-05-10  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/9554\n+\t* g++.dg/parse/access1.C: New test.\n+\n 2003-05-09  DJ Delorie  <dj@redhat.com>\n \n \t* g++.dg/other/stdarg1.C: Make sure arg \"3\" is passed as a"}, {"sha": "f8994e39e3c71e53965faf7efd07faff9db7926b", "filename": "gcc/testsuite/g++.dg/parse/access1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d241e0b5734bb89d46fc9b6884f78ad70ff453c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Faccess1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d241e0b5734bb89d46fc9b6884f78ad70ff453c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Faccess1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Faccess1.C?ref=8d241e0b5734bb89d46fc9b6884f78ad70ff453c", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile }\n+\n+// Origin: Volker Lukas <vlukas@gmx.de>\n+\n+// PR c++/9554: Access checking for template ID as class head.\n+\n+class enclose\n+{\n+  template<typename T> struct enclosed;\n+};\n+\n+template <>\n+struct enclose::enclosed<int>;"}]}