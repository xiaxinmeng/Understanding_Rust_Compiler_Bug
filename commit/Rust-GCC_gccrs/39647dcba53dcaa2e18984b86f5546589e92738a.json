{"sha": "39647dcba53dcaa2e18984b86f5546589e92738a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk2NDdkY2JhNTNkY2FhMmUxODk4NGI4NmY1NTQ2NTg5ZTkyNzM4YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-10-23T14:20:45Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-10-23T14:20:45Z"}, "message": "(exact_real_inverse): Likewise, if no REAL_ARITHMETIC.\n\n(fold, case RDIV_EXPR): Turn divide by constant into multiplication by the\nreciprocal, if optimizing and result is exact.\n\nFrom-SVN: r13004", "tree": {"sha": "41a686f3679d9e1bea38994dc94a120874b5a422", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41a686f3679d9e1bea38994dc94a120874b5a422"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39647dcba53dcaa2e18984b86f5546589e92738a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39647dcba53dcaa2e18984b86f5546589e92738a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39647dcba53dcaa2e18984b86f5546589e92738a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39647dcba53dcaa2e18984b86f5546589e92738a/comments", "author": null, "committer": null, "parents": [{"sha": "ebc8186bf65078f5f390a9be1f1810803d7c0e65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebc8186bf65078f5f390a9be1f1810803d7c0e65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebc8186bf65078f5f390a9be1f1810803d7c0e65"}], "stats": {"total": 111, "additions": 106, "deletions": 5}, "files": [{"sha": "2af2f8b2cc37220ec552d6b1873afd6f8a012578", "filename": "gcc/fold-const.c", "status": "modified", "additions": 106, "deletions": 5, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39647dcba53dcaa2e18984b86f5546589e92738a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39647dcba53dcaa2e18984b86f5546589e92738a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=39647dcba53dcaa2e18984b86f5546589e92738a", "patch": "@@ -867,6 +867,94 @@ target_negative (x)\n   return x < 0;\n }\n #endif /* Target not IEEE */\n+\n+/* Try to change R into its exact multiplicative inverse in machine mode\n+   MODE.  Return nonzero function value if successful.  */\n+\n+int\n+exact_real_inverse (mode, r)\n+     enum machine_mode mode;\n+     REAL_VALUE_TYPE *r;\n+{\n+  union\n+    {\n+      double d;\n+      unsigned short i[4];\n+    }x, t, y;\n+  int i;\n+\n+  /* Usually disable if bounds checks are not reliable.  */\n+  if ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT) && !flag_pretend_float)\n+    return 0;\n+\n+  /* Set array index to the less significant bits in the unions, depending\n+     on the endian-ness of the host doubles.\n+     Disable if insufficient information on the data structure.  */\n+#if HOST_FLOAT_FORMAT == UNKNOWN_FLOAT_FORMAT\n+  return 0;\n+#else\n+#if HOST_FLOAT_FORMAT == VAX_FLOAT_FORMAT\n+#define K 2\n+#else\n+#if HOST_FLOAT_FORMAT == IBM_FLOAT_FORMAT\n+#define K 2\n+#else\n+#define K (2 * HOST_FLOAT_WORDS_BIG_ENDIAN)\n+#endif\n+#endif\n+#endif\n+\n+  if (setjmp (float_error))\n+    {\n+      /* Don't do the optimization if there was an arithmetic error.  */\n+fail:\n+      set_float_handler (NULL_PTR);\n+      return 0;\n+    }\n+  set_float_handler (float_error);\n+\n+  /* Domain check the argument.  */\n+  x.d = *r;\n+  if (x.d == 0.0)\n+    goto fail;\n+\n+#ifdef REAL_INFINITY\n+  if (REAL_VALUE_ISINF (x.d) || REAL_VALUE_ISNAN (x.d))\n+    goto fail;\n+#endif\n+\n+  /* Compute the reciprocal and check for numerical exactness.\n+     It is unnecessary to check all the significand bits to determine\n+     whether X is a power of 2.  If X is not, then it is impossible for\n+     the bottom half significand of both X and 1/X to be all zero bits.\n+     Hence we ignore the data structure of the top half and examine only\n+     the low order bits of the two significands.  */\n+  t.d = 1.0 / x.d;\n+  if (x.i[K] != 0 || x.i[K + 1] != 0 || t.i[K] != 0 || t.i[K + 1] != 0)\n+    goto fail;\n+\n+  /* Truncate to the required mode and range-check the result.  */\n+  y.d = REAL_VALUE_TRUNCATE (mode, t.d);\n+#ifdef CHECK_FLOAT_VALUE\n+  i = 0;\n+  if (CHECK_FLOAT_VALUE (mode, y.d, i))\n+    goto fail;\n+#endif\n+\n+  /* Fail if truncation changed the value.  */\n+  if (y.d != t.d || y.d == 0.0)\n+    goto fail;\n+\n+#ifdef REAL_INFINITY\n+  if (REAL_VALUE_ISINF (y.d) || REAL_VALUE_ISNAN (y.d))\n+    goto fail;\n+#endif\n+\n+  /* Output the reciprocal and return success flag.  */\n+  set_float_handler (NULL_PTR);\n+  *r = y.d;\n+  return 1;\n+}\n #endif /* no REAL_ARITHMETIC */\n \f\n /* Split a tree IN into a constant and a variable part\n@@ -4343,11 +4431,24 @@ fold (expr)\n \t so only do this if -ffast-math.  We can actually always safely\n \t do it if ARG1 is a power of two, but it's hard to tell if it is\n \t or not in a portable manner.  */\n-      if (TREE_CODE (arg1) == REAL_CST && flag_fast_math\n-\t  && 0 != (tem = const_binop (code, build_real (type, dconst1),\n-\t\t\t\t      arg1, 0)))\n-\treturn fold (build (MULT_EXPR, type, arg0, tem));\n-\n+      if (TREE_CODE (arg1) == REAL_CST)\n+\t{\n+\t  if (flag_fast_math\n+\t      && 0 != (tem = const_binop (code, build_real (type, dconst1),\n+\t\t\t\t\t  arg1, 0)))\n+\t    return fold (build (MULT_EXPR, type, arg0, tem));\n+\t  /* Find the reciprocal if optimizing and the result is exact. */\n+\t  else if (optimize)\n+\t    {\n+\t      REAL_VALUE_TYPE r;\n+\t      r = TREE_REAL_CST (arg1);\n+\t      if (exact_real_inverse (TYPE_MODE(TREE_TYPE(arg0)), &r))\n+\t\t  {\n+\t\t    tem = build_real (type, r);\n+\t\t    return fold (build (MULT_EXPR, type, arg0, tem));\n+\t\t  }\n+\t    }\n+\t}\n       goto binary;\n \n     case TRUNC_DIV_EXPR:"}]}