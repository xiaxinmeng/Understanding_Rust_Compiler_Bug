{"sha": "85cefe22564c4b7c1159a544fa692a24e0c71870", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVjZWZlMjI1NjRjNGI3YzExNTlhNTQ0ZmE2OTJhMjRlMGM3MTg3MA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-02-11T23:16:49Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-02-11T23:19:21Z"}, "message": "Fix -freorder-blocks-and-partition glitch with Windows SEH\n\nSince GCC 8, the -freorder-blocks-and-partition pass can split a function\ninto hot and cold parts, thus generating 2 CIEs for a single function in\nDWARF for exception purposes and doing an equivalent trick for Windows SEH.\n\nNow the Windows system unwinder is picky when it comes to the boundary\nbetween an active EH region and the end of the function and, therefore,\na nop may need to be added in specific cases.\n\ngcc/\n\t* config/i386/winnt.c (i386_pe_seh_unwind_emit): When switching to\n\tthe cold section, emit a nop before the directive if the previous\n\tactive instruction can throw.", "tree": {"sha": "819cf044158af0146dcd6170c2a01c53816386ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/819cf044158af0146dcd6170c2a01c53816386ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85cefe22564c4b7c1159a544fa692a24e0c71870", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85cefe22564c4b7c1159a544fa692a24e0c71870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85cefe22564c4b7c1159a544fa692a24e0c71870", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85cefe22564c4b7c1159a544fa692a24e0c71870/comments", "author": null, "committer": null, "parents": [{"sha": "5e40542f878127a1dd0421831c03cda1b977f2a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e40542f878127a1dd0421831c03cda1b977f2a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e40542f878127a1dd0421831c03cda1b977f2a0"}], "stats": {"total": 4, "additions": 4, "deletions": 0}, "files": [{"sha": "adc3f36f13b3f51a3c79d993870ea71679cf6dc8", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85cefe22564c4b7c1159a544fa692a24e0c71870/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85cefe22564c4b7c1159a544fa692a24e0c71870/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=85cefe22564c4b7c1159a544fa692a24e0c71870", "patch": "@@ -1231,6 +1231,10 @@ i386_pe_seh_unwind_emit (FILE *asm_out_file, rtx_insn *insn)\n   seh = cfun->machine->seh;\n   if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_SWITCH_TEXT_SECTIONS)\n     {\n+      /* See ix86_seh_fixup_eh_fallthru for the rationale.  */\n+      rtx_insn *prev = prev_active_insn (insn);\n+      if (prev && !insn_nothrow_p (prev))\n+\tfputs (\"\\tnop\\n\", asm_out_file);\n       fputs (\"\\t.seh_endproc\\n\", asm_out_file);\n       seh->in_cold_section = true;\n       return;"}]}