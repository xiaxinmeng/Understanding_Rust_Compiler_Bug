{"sha": "4d259d334e0a55382654f511a64d43089eccf569", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQyNTlkMzM0ZTBhNTUzODI2NTRmNTExYTY0ZDQzMDg5ZWNjZjU2OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-05-16T20:51:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-05-16T20:51:50Z"}, "message": "tree.c (verify_type_variant): Verify tree_base and type_common flags.\n\n\t* tree.c (verify_type_variant): Verify tree_base and type_common flags.\n\t(verify_type): Verify STRING_FLAG.\n\nFrom-SVN: r223252", "tree": {"sha": "7842ed2f76feaefce072d682f4ca4150d44629d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7842ed2f76feaefce072d682f4ca4150d44629d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d259d334e0a55382654f511a64d43089eccf569", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d259d334e0a55382654f511a64d43089eccf569", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d259d334e0a55382654f511a64d43089eccf569", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d259d334e0a55382654f511a64d43089eccf569/comments", "author": null, "committer": null, "parents": [{"sha": "f70713026c1c5d0a235e8fdd472c97ae125834fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f70713026c1c5d0a235e8fdd472c97ae125834fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f70713026c1c5d0a235e8fdd472c97ae125834fc"}], "stats": {"total": 240, "additions": 142, "deletions": 98}, "files": [{"sha": "58f37f124f2cf3236950e0e7542ed4d8a694f42d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d259d334e0a55382654f511a64d43089eccf569/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d259d334e0a55382654f511a64d43089eccf569/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d259d334e0a55382654f511a64d43089eccf569", "patch": "@@ -1,3 +1,8 @@\n+2015-05-16  Jan HUbicka  <hubicka@ucw.cz>\n+\n+\t* tree.c (verify_type_variant): Verify tree_base and type_common flags.\n+\t(verify_type): Verify STRING_FLAG.\n+\n 2015-05-16  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR fortran/44054"}, {"sha": "ae2cfdd3ebace3bcaa43ebcd1781eb303e04407f", "filename": "gcc/tree.c", "status": "modified", "additions": 137, "deletions": 98, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d259d334e0a55382654f511a64d43089eccf569/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d259d334e0a55382654f511a64d43089eccf569/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4d259d334e0a55382654f511a64d43089eccf569", "patch": "@@ -12468,92 +12468,137 @@ element_mode (const_tree t)\n     t = TREE_TYPE (t);\n   return TYPE_MODE (t);\n }\n+ \n \n /* Veirfy that basic properties of T match TV and thus T can be a variant of\n    TV.  TV should be the more specified variant (i.e. the main variant).  */\n \n static bool\n verify_type_variant (const_tree t, tree tv)\n {\n-  if (TREE_CODE (t) != TREE_CODE (tv))\n-    {\n-      error (\"type variant has different TREE_CODE\");\n-      debug_tree (tv);\n-      return false;\n-    }\n-  if (COMPLETE_TYPE_P (t) && TYPE_SIZE (t) != TYPE_SIZE (tv))\n-    {\n-      error (\"type variant has different TYPE_SIZE\");\n-      debug_tree (tv);\n-      error (\"type variant's TYPE_SIZE\");\n-      debug_tree (TYPE_SIZE (tv));\n-      error (\"type's TYPE_SIZE\");\n-      debug_tree (TYPE_SIZE (t));\n-      return false;\n-    }\n-  if (COMPLETE_TYPE_P (t)\n-      && TYPE_SIZE_UNIT (t) != TYPE_SIZE_UNIT (tv)\n-      /* FIXME: ideally we should compare pointer equality, but java FE produce\n- \t variants where size is INTEGER_CST of different type (int wrt size_type)\n-\t during libjava biuld.  */\n-      && !operand_equal_p (TYPE_SIZE_UNIT (t), TYPE_SIZE_UNIT (tv), 0))\n-    {\n-      error (\"type variant has different TYPE_SIZE_UNIT\");\n-      debug_tree (tv);\n-      error (\"type variant's TYPE_SIZE_UNIT\");\n-      debug_tree (TYPE_SIZE_UNIT (tv));\n-      error (\"type's TYPE_SIZE_UNIT\");\n-      debug_tree (TYPE_SIZE_UNIT (t));\n-      return false;\n+  /* Type variant can differ by:\n+\n+     - TYPE_QUALS: TYPE_READONLY, TYPE_VOLATILE, TYPE_ATOMIC, TYPE_RESTRICT,\n+                   ENCODE_QUAL_ADDR_SPACE. \n+     - main variant may be TYPE_COMPLETE_P and variant types !TYPE_COMPLETE_P\n+       in this case some values may not be set in the variant types\n+       (see TYPE_COMPLETE_P checks).\n+     - it is possible to have TYPE_ARTIFICIAL variant of non-artifical type\n+     - by TYPE_NAME and attributes (i.e. when variant originate by typedef)\n+     - TYPE_CANONICAL (TYPE_ALIAS_SET is the same among variants)\n+     - by the alignment: TYPE_ALIGN and TYPE_USER_ALIGN\n+     - during LTO by TYPE_CONTEXT if type is TYPE_FILE_SCOPE_P\n+       this is necessary to make it possible to merge types form different TUs\n+     - arrays, pointers and references may have TREE_TYPE that is a variant\n+       of TREE_TYPE of their main variants.\n+     - aggregates may have new TYPE_FIELDS list that list variants of\n+       the main variant TYPE_FIELDS.\n+     - vector types may differ by TYPE_VECTOR_OPAQUE\n+     - TYPE_METHODS is always NULL for vairant types and maintained for\n+       main variant only.\n+   */\n+\n+  /* Convenience macro for matching individual fields.  */\n+#define verify_variant_match(flag)\t\t\t\t\t    \\\n+  do {\t\t\t\t\t\t\t\t\t    \\\n+    if (flag (tv) != flag (t))\t\t\t\t\t\t    \\\n+      {\t\t\t\t\t\t\t\t\t    \\\n+\terror (\"type variant differs by \" #flag \".\");\t\t\t    \\\n+\tdebug_tree (tv);\t\t\t\t\t\t    \\\n+\treturn false;\t\t\t\t\t\t\t    \\\n+      }\t\t\t\t\t\t\t\t\t    \\\n+  } while (false)\n+\n+  /* tree_base checks.  */\n+\n+  verify_variant_match (TREE_CODE);\n+  /* FIXME: Ada builds non-artificial variants of artificial types.  */\n+  if (TYPE_ARTIFICIAL (tv) && 0)\n+    verify_variant_match (TYPE_ARTIFICIAL);\n+  if (POINTER_TYPE_P (tv))\n+    verify_variant_match (TYPE_REF_CAN_ALIAS_ALL);\n+  /* FIXME: TYPE_SIZES_GIMPLIFIED may differs for Ada build.  */\n+  verify_variant_match (TYPE_UNSIGNED);\n+  verify_variant_match (TYPE_ALIGN_OK);\n+  verify_variant_match (TYPE_PACKED);\n+  if (TREE_CODE (t) == REFERENCE_TYPE)\n+    verify_variant_match (TYPE_REF_IS_RVALUE);\n+  verify_variant_match (TYPE_SATURATING);\n+  /* FIXME: This check trigger during libstdc++ build.  */\n+  if (RECORD_OR_UNION_TYPE_P (t) && COMPLETE_TYPE_P (t) && 0)\n+    verify_variant_match (TYPE_FINAL_P);\n+\n+  /* tree_type_common checks.  */\n+\n+  if (COMPLETE_TYPE_P (t))\n+    {\n+      verify_variant_match (TYPE_SIZE);\n+      verify_variant_match (TYPE_MODE);\n+      if (TYPE_SIZE_UNIT (t) != TYPE_SIZE_UNIT (tv)\n+\t  /* FIXME: ideally we should compare pointer equality, but java FE\n+\t     produce variants where size is INTEGER_CST of different type (int\n+\t     wrt size_type) during libjava biuld.  */\n+\t  && !operand_equal_p (TYPE_SIZE_UNIT (t), TYPE_SIZE_UNIT (tv), 0))\n+\t{\n+\t  error (\"type variant has different TYPE_SIZE_UNIT\");\n+\t  debug_tree (tv);\n+\t  error (\"type variant's TYPE_SIZE_UNIT\");\n+\t  debug_tree (TYPE_SIZE_UNIT (tv));\n+\t  error (\"type's TYPE_SIZE_UNIT\");\n+\t  debug_tree (TYPE_SIZE_UNIT (t));\n+\t  return false;\n+\t}\n     }\n+  verify_variant_match (TYPE_PRECISION);\n+  verify_variant_match (TYPE_NO_FORCE_BLK);\n+  verify_variant_match (TYPE_NEEDS_CONSTRUCTING);\n+  if (RECORD_OR_UNION_TYPE_P (t))\n+    verify_variant_match (TYPE_TRANSPARENT_AGGR);\n+  else if (TREE_CODE (t) == ARRAY_TYPE)\n+    verify_variant_match (TYPE_NONALIASED_COMPONENT);\n+  /* During LTO we merge variant lists from diferent translation units\n+     that may differ BY TYPE_CONTEXT that in turn may point \n+     to TRANSLATION_UNIT_DECL.\n+     Ada also builds variants of types with different TYPE_CONTEXT.   */\n+  if ((!in_lto_p || !TYPE_FILE_SCOPE_P (t)) && 0)\n+    verify_variant_match (TYPE_CONTEXT);\n+  verify_variant_match (TYPE_STRING_FLAG);\n+  if (TYPE_ALIAS_SET_KNOWN_P (t) && TYPE_ALIAS_SET_KNOWN_P (tv))\n+    verify_variant_match (TYPE_ALIAS_SET);\n+\n+  /* tree_type_non_common checks.  */\n+\n   /* FIXME: C FE uses TYPE_VFIELD to record C_TYPE_INCOMPLETE_VARS\n-     and danagle the pointer from time to time.  */\n+     and dangle the pointer from time to time.  */\n   if (RECORD_OR_UNION_TYPE_P (t) && TYPE_VFIELD (t) != TYPE_VFIELD (tv)\n-      && (!TYPE_VFIELD (tv) || TREE_CODE (TYPE_VFIELD (tv)) != TREE_LIST))\n+      && (in_lto_p || !TYPE_VFIELD (tv)\n+\t  || TREE_CODE (TYPE_VFIELD (tv)) != TREE_LIST))\n     {\n       error (\"type variant has different TYPE_VFIELD\");\n       debug_tree (tv);\n       return false;\n     }\n-  if (((TREE_CODE (t) == ENUMERAL_TYPE && COMPLETE_TYPE_P (t))\n-\t|| TREE_CODE (t) == INTEGER_TYPE\n-\t|| TREE_CODE (t) == BOOLEAN_TYPE\n-\t|| TREE_CODE (t) == REAL_TYPE\n-\t|| TREE_CODE (t) == FIXED_POINT_TYPE)\n-       && (TYPE_MAX_VALUE (t) != TYPE_MAX_VALUE (tv)\n-\t   || TYPE_MIN_VALUE (t) != TYPE_MIN_VALUE (tv)))\n+  if ((TREE_CODE (t) == ENUMERAL_TYPE && COMPLETE_TYPE_P (t))\n+       || TREE_CODE (t) == INTEGER_TYPE\n+       || TREE_CODE (t) == BOOLEAN_TYPE\n+       || TREE_CODE (t) == REAL_TYPE\n+       || TREE_CODE (t) == FIXED_POINT_TYPE)\n     {\n-      error (\"type variant has different TYPE_MAX_VALUE or TYPE_MIN_VALUE\");\n-      debug_tree (tv);\n-      return false;\n-    }\n-  if (TREE_CODE (t) == METHOD_TYPE\n-      && TYPE_METHOD_BASETYPE (t) != TYPE_METHOD_BASETYPE (tv))\n-    {\n-      error (\"type variant has different TYPE_METHOD_BASETYPE\");\n-      debug_tree (tv);\n-      return false;\n+      verify_variant_match (TYPE_MAX_VALUE);\n+      verify_variant_match (TYPE_MIN_VALUE);\n     }\n+  if (TREE_CODE (t) == METHOD_TYPE)\n+    verify_variant_match (TYPE_METHOD_BASETYPE);\n   if (RECORD_OR_UNION_TYPE_P (t) && TYPE_METHODS (t))\n     {\n       error (\"type variant has TYPE_METHODS\");\n       debug_tree (tv);\n       return false;\n     }\n-  if (TREE_CODE (t) == OFFSET_TYPE\n-      && TYPE_OFFSET_BASETYPE (t) != TYPE_OFFSET_BASETYPE (tv))\n-    {\n-      error (\"type variant has different TYPE_OFFSET_BASETYPE\");\n-      debug_tree (tv);\n-      return false;\n-    }\n-  if (TREE_CODE (t) == ARRAY_TYPE\n-      && TYPE_ARRAY_MAX_SIZE (t) != TYPE_ARRAY_MAX_SIZE (tv))\n-    {\n-      error (\"type variant has different TYPE_ARRAY_MAX_SIZE\");\n-      debug_tree (tv);\n-      return false;\n-    }\n+  if (TREE_CODE (t) == OFFSET_TYPE)\n+    verify_variant_match (TYPE_OFFSET_BASETYPE);\n+  if (TREE_CODE (t) == ARRAY_TYPE)\n+    verify_variant_match (TYPE_ARRAY_MAX_SIZE);\n   /* FIXME: Be lax and allow TYPE_BINFO to be missing in variant types\n      or even type's main variant.  This is needed to make bootstrap pass\n      and the bug seems new in GCC 5.\n@@ -12581,28 +12626,10 @@ verify_type_variant (const_tree t, tree tv)\n     }\n \n   /* Check various uses of TYPE_VALUES_RAW.  */\n-  if (TREE_CODE (t) == ENUMERAL_TYPE\n-      && TYPE_VALUES (t) != TYPE_VALUES (tv))\n-    {\n-      error (\"type variant has different TYPE_VALUES\");\n-      debug_tree (tv);\n-      error (\"type variant's TYPE_VALUES\");\n-      debug_tree (TYPE_VALUES (tv));\n-      error (\"type's TYPE_VALUES\");\n-      debug_tree (TYPE_VALUES (t));\n-      return false;\n-    }\n-  else if (TREE_CODE (t) == ARRAY_TYPE\n-\t   && TYPE_DOMAIN (t) != TYPE_DOMAIN (tv))\n-    {\n-      error (\"type variant has different TYPE_DOMAIN\");\n-      debug_tree (tv);\n-      error (\"type variant's TYPE_DOMAIN\");\n-      debug_tree (TYPE_DOMAIN (tv));\n-      error (\"type's TYPE_DOMAIN\");\n-      debug_tree (TYPE_DOMAIN (t));\n-      return false;\n-    }\n+  if (TREE_CODE (t) == ENUMERAL_TYPE)\n+    verify_variant_match (TYPE_VALUES);\n+  else if (TREE_CODE (t) == ARRAY_TYPE)\n+    verify_variant_match (TYPE_DOMAIN);\n   /* Permit incomplete variants of complete type.  While FEs may complete\n      all variants, this does not happen for C++ templates in all cases.  */\n   else if (RECORD_OR_UNION_TYPE_P (t)\n@@ -12640,13 +12667,8 @@ verify_type_variant (const_tree t, tree tv)\n           return false;\n \t}\n     }\n-  else if ((TREE_CODE (t) == FUNCTION_TYPE || TREE_CODE (t) == METHOD_TYPE)\n-\t   && TYPE_ARG_TYPES (t) != TYPE_ARG_TYPES (tv))\n-    {\n-      error (\"type variant has different TYPE_ARG_TYPES\");\n-      debug_tree (tv);\n-      return false;\n-    }\n+  else if ((TREE_CODE (t) == FUNCTION_TYPE || TREE_CODE (t) == METHOD_TYPE))\n+    verify_variant_match (TYPE_ARG_TYPES);\n   /* For C++ the qualified variant of array type is really an array type\n      of qualified TREE_TYPE.\n      objc builds variants of pointer where pointer to type is a variant, too\n@@ -12665,15 +12687,11 @@ verify_type_variant (const_tree t, tree tv)\n       debug_tree (TREE_TYPE (t));\n       return false;\n     }\n-  if (TYPE_PRECISION (t) != TYPE_PRECISION (tv))\n-    {\n-      error (\"type variant has different TYPE_PRECISION\");\n-      debug_tree (tv);\n-      return false;\n-    }\n   return true;\n+#undef verify_type_variant\n }\n \n+\n /* Verify type T.  */\n \n void\n@@ -12966,6 +12984,27 @@ verify_type (const_tree t)\n       error (\"TYPE_CACHED_VALUES_P is set while it should not\");\n       error_found = true;\n     }\n+  if (TYPE_STRING_FLAG (t)\n+      && TREE_CODE (t) != ARRAY_TYPE && TREE_CODE (t) != INTEGER_TYPE)\n+    {\n+      error (\"TYPE_STRING_FLAG is set on wrong type code\");\n+      error_found = true;\n+    }\n+  else if (TYPE_STRING_FLAG (t))\n+    {\n+      const_tree b = t;\n+      if (TREE_CODE (b) == ARRAY_TYPE)\n+\tb = TREE_TYPE (t);\n+      /* Java builds arrays with TYPE_STRING_FLAG of promoted_char_type\n+\t that is 32bits.  */\n+      if (TREE_CODE (b) != INTEGER_TYPE)\n+\t{\n+\t  error (\"TYPE_STRING_FLAG is set on type that does not look like \"\n+\t\t \"char nor array of chars\");\n+\t  error_found = true;\n+\t}\n+    }\n+  \n \n \n   if (error_found)"}]}