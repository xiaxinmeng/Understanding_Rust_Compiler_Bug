{"sha": "6fc14f1963dfefead588a4cd8902d641ed69255c", "node_id": "C_kwDOANBUbNoAKDZmYzE0ZjE5NjNkZmVmZWFkNTg4YTRjZDg5MDJkNjQxZWQ2OTI1NWM", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-08-09T17:54:43Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-08-09T17:54:43Z"}, "message": "middle-end: Optimize ((X >> C1) & C2) != C3 for more cases.\n\nFollowing my middle-end patch for PR tree-optimization/94026, I'd promised\nJeff Law that I'd clean up the dead-code in fold-const.cc now that these\noptimizations are handled in match.pd.  Alas, I discovered things aren't\nquite that simple, as the transformations I'd added avoided cases where\nC2 overlapped with the new bits introduced by the shift, but the original\ncode handled any value of C2 provided that it had a single-bit set (under\nthe condition that C3 was always zero).\n\nThis patch upgrades the transformations supported by match.pd to cover\nany values of C2 and C3, provided that C1 is a valid bit shift constant,\nfor all three shift types (logical right, arithmetic right and left).\nThis then makes the code in fold-const.cc fully redundant, and adds\nsupport for some new (corner) cases not previously handled.  If the\nconstant C1 is valid for the type's precision, the shift is now always\neliminated (with C2 and C3 possibly updated to test the sign bit).\n\nInterestingly, the fold-const.cc code that I'm now deleting was originally\nadded by me back in 2006 to resolve PR middle-end/21137.  I've confirmed\nthat those testcase(s) remain resolved with this patch (and I'll close\n21137 in Bugzilla).  This patch also implements most (but not all) of the\nexamples mentioned in PR tree-optimization/98954, for which I have some\nfollow-up patches.\n\n2022-08-09  Roger Sayle  <roger@nextmovesoftware.com>\n\t    Richard Biener  <rguenther@suse.de>\n\ngcc/ChangeLog\n\tPR middle-end/21137\n\tPR tree-optimization/98954\n\t* fold-const.cc (fold_binary_loc): Remove optimizations to\n\toptimize ((X >> C1) & C2) ==/!= 0.\n\t* match.pd (cmp (bit_and (lshift @0 @1) @2) @3): Remove wi::ctz\n\tcheck, and handle all values of INTEGER_CSTs @2 and @3.\n\t(cmp (bit_and (rshift @0 @1) @2) @3): Likewise, remove wi::clz\n\tchecks, and handle all values of INTEGER_CSTs @2 and @3.\n\ngcc/testsuite/ChangeLog\n\tPR middle-end/21137\n\tPR tree-optimization/98954\n\t* gcc.dg/fold-eqandshift-4.c: New test case.", "tree": {"sha": "07530a7b52d77cb52b773483c081d7384a8e3ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07530a7b52d77cb52b773483c081d7384a8e3ee0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fc14f1963dfefead588a4cd8902d641ed69255c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fc14f1963dfefead588a4cd8902d641ed69255c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fc14f1963dfefead588a4cd8902d641ed69255c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fc14f1963dfefead588a4cd8902d641ed69255c/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9385cd9c74cf6662f43038aafe4d2467899f322e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9385cd9c74cf6662f43038aafe4d2467899f322e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9385cd9c74cf6662f43038aafe4d2467899f322e"}], "stats": {"total": 145, "additions": 80, "deletions": 65}, "files": [{"sha": "4f4ec81c8d4b6937ade3141a14c695b67c874c35", "filename": "gcc/fold-const.cc", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc14f1963dfefead588a4cd8902d641ed69255c/gcc%2Ffold-const.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc14f1963dfefead588a4cd8902d641ed69255c/gcc%2Ffold-const.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.cc?ref=6fc14f1963dfefead588a4cd8902d641ed69255c", "patch": "@@ -12204,60 +12204,6 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n \t    }\n \t}\n \n-      /* Fold ((X >> C1) & C2) == 0 and ((X >> C1) & C2) != 0 where\n-\t C1 is a valid shift constant, and C2 is a power of two, i.e.\n-\t a single bit.  */\n-      if (TREE_CODE (arg0) == BIT_AND_EXPR\n-\t  && integer_pow2p (TREE_OPERAND (arg0, 1))\n-\t  && integer_zerop (arg1))\n-\t{\n-\t  tree arg00 = TREE_OPERAND (arg0, 0);\n-\t  STRIP_NOPS (arg00);\n-\t  if (TREE_CODE (arg00) == RSHIFT_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (arg00, 1)) == INTEGER_CST)\n-\t    {\n-\t      tree itype = TREE_TYPE (arg00);\n-\t      tree arg001 = TREE_OPERAND (arg00, 1);\n-\t      prec = TYPE_PRECISION (itype);\n-\n-\t      /* Check for a valid shift count.  */\n-\t      if (wi::ltu_p (wi::to_wide (arg001), prec))\n-\t\t{\n-\t\t  tree arg01 = TREE_OPERAND (arg0, 1);\n-\t\t  tree arg000 = TREE_OPERAND (arg00, 0);\n-\t\t  unsigned HOST_WIDE_INT log2 = tree_log2 (arg01);\n-\t\t  /* If (C2 << C1) doesn't overflow, then\n-\t\t     ((X >> C1) & C2) != 0 can be rewritten as\n-\t\t     (X & (C2 << C1)) != 0.  */\n-\t\t  if ((log2 + TREE_INT_CST_LOW (arg001)) < prec)\n-\t\t    {\n-\t\t      tem = fold_build2_loc (loc, LSHIFT_EXPR, itype,\n-\t\t\t\t\t     arg01, arg001);\n-\t\t      tem = fold_build2_loc (loc, BIT_AND_EXPR, itype,\n-\t\t\t\t\t     arg000, tem);\n-\t\t      return fold_build2_loc (loc, code, type, tem,\n-\t\t\t\tfold_convert_loc (loc, itype, arg1));\n-\t\t    }\n-\t\t  /* Otherwise, for signed (arithmetic) shifts,\n-\t\t     ((X >> C1) & C2) != 0 is rewritten as X < 0, and\n-\t\t     ((X >> C1) & C2) == 0 is rewritten as X >= 0.  */\n-\t\t  else if (!TYPE_UNSIGNED (itype))\n-\t\t    return fold_build2_loc (loc, code == EQ_EXPR ? GE_EXPR\n-\t\t\t\t\t\t\t\t : LT_EXPR,\n-\t\t\t\t\t    type, arg000,\n-\t\t\t\t\t    build_int_cst (itype, 0));\n-\t\t  /* Otherwise, of unsigned (logical) shifts,\n-\t\t     ((X >> C1) & C2) != 0 is rewritten as (X,false), and\n-\t\t     ((X >> C1) & C2) == 0 is rewritten as (X,true).  */\n-\t\t  else\n-\t\t    return omit_one_operand_loc (loc, type,\n-\t\t\t\t\t code == EQ_EXPR ? integer_one_node\n-\t\t\t\t\t\t\t : integer_zero_node,\n-\t\t\t\t\t arg000);\n-\t\t}\n-\t    }\n-\t}\n-\n       /* If this is a comparison of a field, we may be able to simplify it.  */\n       if ((TREE_CODE (arg0) == COMPONENT_REF\n \t   || TREE_CODE (arg0) == BIT_FIELD_REF)"}, {"sha": "c22bc2ca1e811594bfe1ccd5369091b8eda56aaa", "filename": "gcc/match.pd", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc14f1963dfefead588a4cd8902d641ed69255c/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc14f1963dfefead588a4cd8902d641ed69255c/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=6fc14f1963dfefead588a4cd8902d641ed69255c", "patch": "@@ -3601,21 +3601,44 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (cmp (bit_and:s (lshift:s @0 INTEGER_CST@1) INTEGER_CST@2) INTEGER_CST@3)\n   (if (tree_fits_shwi_p (@1)\n        && tree_to_shwi (@1) > 0\n-       && tree_to_shwi (@1) < TYPE_PRECISION (TREE_TYPE (@0))\n-       && tree_to_shwi (@1) <= wi::ctz (wi::to_wide (@3)))\n-   (with { wide_int c1 = wi::to_wide (@1);\n-\t   wide_int c2 = wi::lrshift (wi::to_wide (@2), c1);\n-\t   wide_int c3 = wi::lrshift (wi::to_wide (@3), c1); }\n-    (cmp (bit_and @0 { wide_int_to_tree (TREE_TYPE (@0), c2); })\n-\t { wide_int_to_tree (TREE_TYPE (@0), c3); }))))\n+       && tree_to_shwi (@1) < TYPE_PRECISION (TREE_TYPE (@0)))\n+    (if (tree_to_shwi (@1) > wi::ctz (wi::to_wide (@3)))\n+      { constant_boolean_node (cmp == NE_EXPR, type); }\n+      (with { wide_int c1 = wi::to_wide (@1);\n+\t      wide_int c2 = wi::lrshift (wi::to_wide (@2), c1);\n+\t      wide_int c3 = wi::lrshift (wi::to_wide (@3), c1); }\n+\t(cmp (bit_and @0 { wide_int_to_tree (TREE_TYPE (@0), c2); })\n+\t     { wide_int_to_tree (TREE_TYPE (@0), c3); })))))\n  (simplify\n   (cmp (bit_and:s (rshift:s @0 INTEGER_CST@1) INTEGER_CST@2) INTEGER_CST@3)\n   (if (tree_fits_shwi_p (@1)\n        && tree_to_shwi (@1) > 0\n-       && tree_to_shwi (@1) < TYPE_PRECISION (TREE_TYPE (@0))\n-       && tree_to_shwi (@1) <= wi::clz (wi::to_wide (@2))\n-       && tree_to_shwi (@1) <= wi::clz (wi::to_wide (@3)))\n-   (cmp (bit_and @0 (lshift @2 @1)) (lshift @3 @1)))))\n+       && tree_to_shwi (@1) < TYPE_PRECISION (TREE_TYPE (@0)))\n+    (with { tree t0 = TREE_TYPE (@0);\n+\t    unsigned int prec = TYPE_PRECISION (t0);\n+\t    wide_int c1 = wi::to_wide (@1);\n+\t    wide_int c2 = wi::to_wide (@2);\n+\t    wide_int c3 = wi::to_wide (@3);\n+\t    wide_int sb = wi::set_bit_in_zero (prec - 1, prec); }\n+      (if ((c2 & c3) != c3)\n+        { constant_boolean_node (cmp == NE_EXPR, type); }\n+\t(if (TYPE_UNSIGNED (t0))\n+\t  (if ((c3 & wi::arshift (sb, c1 - 1)) != 0)\n+            { constant_boolean_node (cmp == NE_EXPR, type); }\n+\t    (cmp (bit_and @0 { wide_int_to_tree (t0, c2 << c1); })\n+\t\t { wide_int_to_tree (t0, c3 << c1); }))\n+\t  (with { wide_int smask = wi::arshift (sb, c1); }\n+\t    (switch\n+\t      (if ((c2 & smask) == 0)\n+\t\t(cmp (bit_and @0 { wide_int_to_tree (t0, c2 << c1); })\n+\t\t     { wide_int_to_tree (t0, c3 << c1); }))\n+\t      (if ((c3 & smask) == 0)\n+\t        (cmp (bit_and @0 { wide_int_to_tree (t0, (c2 << c1) | sb); })\n+\t\t     { wide_int_to_tree (t0, c3 << c1); }))\n+\t      (if ((c2 & smask) != (c3 & smask))\n+\t\t{ constant_boolean_node (cmp == NE_EXPR, type); })\n+\t      (cmp (bit_and @0 { wide_int_to_tree (t0, (c2 << c1) | sb); })\n+\t\t   { wide_int_to_tree (t0, (c3 << c1) | sb); })))))))))\n \n /* Fold (X << C1) & C2 into (X << C1) & (C2 | ((1 << C1) - 1))\n         (X >> C1) & C2 into (X >> C1) & (C2 | ~((type) -1 >> C1))"}, {"sha": "42d5190703ec33fab56a16164a47e23e51b5f816", "filename": "gcc/testsuite/gcc.dg/fold-eqandshift-4.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc14f1963dfefead588a4cd8902d641ed69255c/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-eqandshift-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc14f1963dfefead588a4cd8902d641ed69255c/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-eqandshift-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-eqandshift-4.c?ref=6fc14f1963dfefead588a4cd8902d641ed69255c", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+int sr30eq00(char x) { return ((x >> 4) & 0x30) == 0; }\n+int sr30ne00(char x) { return ((x >> 4) & 0x30) != 0; }\n+int sr30eq20(char z) { return ((z >> 4) & 0x30) == 0x20; }\n+int sr30ne20(char z) { return ((z >> 4) & 0x30) != 0x20; }\n+int sr30eq30(char x) { return ((x >> 4) & 0x30) == 0x30; }\n+int sr30ne30(char x) { return ((x >> 4) & 0x30) != 0x30; }\n+int sr33eq33(char x) { return ((x >> 4) & 0x33) == 0x33; }\n+int sr33ne33(char x) { return ((x >> 4) & 0x33) != 0x33; }\n+\n+int ur30eq00(unsigned char z) { return ((z >> 4) & 0x30) == 0; }\n+int ur30ne00(unsigned char z) { return ((z >> 4) & 0x30) != 0; }\n+int ur30eq30(unsigned char z) { return ((z >> 4) & 0x30) == 0x30; }\n+int ur30ne30(unsigned char z) { return ((z >> 4) & 0x30) != 0x30; }\n+int ur33eq03(unsigned char x) { return ((x >> 4) & 0x33) == 0x03; }\n+int ur33ne03(unsigned char x) { return ((x >> 4) & 0x33) != 0x03; }\n+int ur33eq30(unsigned char z) { return ((z >> 4) & 0x33) == 0x30; }\n+int ur33ne30(unsigned char z) { return ((z >> 4) & 0x33) != 0x30; }\n+int ur33eq33(unsigned char z) { return ((z >> 4) & 0x33) == 0x33; }\n+int ur33ne33(unsigned char z) { return ((z >> 4) & 0x33) != 0x33; }\n+\n+int sl30eq00(char x) { return ((char)(x << 4) & 0x30) == 0; }\n+int sl30ne00(char x) { return ((char)(x << 4) & 0x30) != 0; }\n+int sl30eq20(char x) { return ((char)(x << 4) & 0x30) == 0x20; }\n+int sl30ne20(char x) { return ((char)(x << 4) & 0x30) != 0x20; }\n+int sl30eq30(char x) { return ((char)(x << 4) & 0x30) == 0x30; }\n+int sl30ne30(char x) { return ((char)(x << 4) & 0x30) != 0x30; }\n+int sl33eq00(char x) { return ((char)(x << 4) & 0x33) == 0; }\n+int sl33ne00(char x) { return ((char)(x << 4) & 0x33) != 0; }\n+int sl33eq03(char z) { return ((char)(z << 4) & 0x33) == 0x03; }\n+int sl33ne03(char z) { return ((char)(z << 4) & 0x33) != 0x03; }\n+int sl33eq30(char x) { return ((char)(x << 4) & 0x33) == 0x30; }\n+int sl33ne30(char x) { return ((char)(x << 4) & 0x33) != 0x30; }\n+int sl33eq33(char z) { return ((char)(z << 4) & 0x33) == 0x33; }\n+int sl33ne33(char z) { return ((char)(z << 4) & 0x33) != 0x33; }\n+\n+/* { dg-final { scan-tree-dump-not \" >> \" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \" << \" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \"z_\\[0-9\\]\\\\(D\\\\)\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"return \\[01\\]\" 14 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"char z\\\\)\" 14 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"x_\\[0-9\\]\\\\(D\\\\)\" 18 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"char x\\\\)\" 18 \"optimized\" } } */\n+"}]}