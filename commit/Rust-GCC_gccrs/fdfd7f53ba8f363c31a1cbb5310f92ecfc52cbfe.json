{"sha": "fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRmZDdmNTNiYThmMzYzYzMxYTFjYmI1MzEwZjkyZWNmYzUyY2JmZQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-01-09T11:29:23Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2020-01-09T11:29:23Z"}, "message": "Add Optimization for various IPA parameters.\n\n2020-01-09  Martin Liska  <mliska@suse.cz>\n\n\t* auto-profile.c (auto_profile): Use opt_for_fn\n\tfor a parameter.\n\t* ipa-cp.c (ipcp_lattice::add_value): Likewise.\n\t(propagate_vals_across_arith_jfunc): Likewise.\n\t(hint_time_bonus): Likewise.\n\t(incorporate_penalties): Likewise.\n\t(good_cloning_opportunity_p): Likewise.\n\t(perform_estimation_of_a_value): Likewise.\n\t(estimate_local_effects): Likewise.\n\t(ipcp_propagate_stage): Likewise.\n\t* ipa-fnsummary.c (decompose_param_expr): Likewise.\n\t(set_switch_stmt_execution_predicate): Likewise.\n\t(analyze_function_body): Likewise.\n\t* ipa-inline-analysis.c (offline_size): Likewise.\n\t* ipa-inline.c (early_inliner): Likewise.\n\t* ipa-prop.c (ipa_analyze_node): Likewise.\n\t(ipcp_transform_function): Likewise.\n\t* ipa-sra.c (process_scan_results): Likewise.\n\t(ipa_sra_summarize_function): Likewise.\n\t* params.opt: Rename ipcp-unit-growth to\n\tipa-cp-unit-growth.  Add Optimization for various\n\tIPA-related parameters.\n\nFrom-SVN: r280040", "tree": {"sha": "93fae6aadf99180ec22f987d23046a1809c59d0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93fae6aadf99180ec22f987d23046a1809c59d0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "00294b189cf3285b17b4ca4135341e2614783553", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00294b189cf3285b17b4ca4135341e2614783553", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00294b189cf3285b17b4ca4135341e2614783553"}], "stats": {"total": 136, "additions": 88, "deletions": 48}, "files": [{"sha": "0891e98ebd30f82882bbd6e9bb4ea0f1bf847e4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe", "patch": "@@ -1,3 +1,28 @@\n+2020-01-09  Martin Liska  <mliska@suse.cz>\n+\n+\t* auto-profile.c (auto_profile): Use opt_for_fn\n+\tfor a parameter.\n+\t* ipa-cp.c (ipcp_lattice::add_value): Likewise.\n+\t(propagate_vals_across_arith_jfunc): Likewise.\n+\t(hint_time_bonus): Likewise.\n+\t(incorporate_penalties): Likewise.\n+\t(good_cloning_opportunity_p): Likewise.\n+\t(perform_estimation_of_a_value): Likewise.\n+\t(estimate_local_effects): Likewise.\n+\t(ipcp_propagate_stage): Likewise.\n+\t* ipa-fnsummary.c (decompose_param_expr): Likewise.\n+\t(set_switch_stmt_execution_predicate): Likewise.\n+\t(analyze_function_body): Likewise.\n+\t* ipa-inline-analysis.c (offline_size): Likewise.\n+\t* ipa-inline.c (early_inliner): Likewise.\n+\t* ipa-prop.c (ipa_analyze_node): Likewise.\n+\t(ipcp_transform_function): Likewise.\n+\t* ipa-sra.c (process_scan_results): Likewise.\n+\t(ipa_sra_summarize_function): Likewise.\n+\t* params.opt: Rename ipcp-unit-growth to\n+\tipa-cp-unit-growth.  Add Optimization for various\n+\tIPA-related parameters.\n+\n 2020-01-09  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/93054"}, {"sha": "c5e9f1336a72bd7ca16b29953f2e50c41ab705d3", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe", "patch": "@@ -1628,7 +1628,8 @@ auto_profile (void)\n        function before annotation, so the profile inside bar@loc_foo2\n        will be useful.  */\n     autofdo::stmt_set promoted_stmts;\n-    for (int i = 0; i < param_early_inliner_max_iterations; i++)\n+    for (int i = 0; i < opt_for_fn (node->decl,\n+\t\t\t\t    param_early_inliner_max_iterations); i++)\n       {\n         if (!flag_value_profile_transformations\n             || !autofdo::afdo_vpt_for_early_inline (&promoted_stmts))"}, {"sha": "64bbf7f2513e6445c3e5b0ca50d04337af0ef842", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe", "patch": "@@ -1860,7 +1860,8 @@ ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n \treturn false;\n       }\n \n-  if (!unlimited && values_count == param_ipa_cp_value_list_size)\n+  if (!unlimited && values_count == opt_for_fn (cs->caller->decl,\n+\t\t\t\t\t\tparam_ipa_cp_value_list_size))\n     {\n       /* We can only free sources, not the values themselves, because sources\n \t of other values in this SCC might point to them.   */\n@@ -2002,12 +2003,15 @@ propagate_vals_across_arith_jfunc (cgraph_edge *cs,\n     {\n       int i;\n \n-      if (src_lat != dest_lat || param_ipa_cp_max_recursive_depth < 1)\n+      int max_recursive_depth = opt_for_fn(cs->caller->decl,\n+\t\t\t\t\t   param_ipa_cp_max_recursive_depth);\n+      if (src_lat != dest_lat || max_recursive_depth < 1)\n \treturn dest_lat->set_contains_variable ();\n \n       /* No benefit if recursive execution is in low probability.  */\n       if (cs->sreal_frequency () * 100\n-\t  <= ((sreal) 1) * param_ipa_cp_min_recursive_probability)\n+\t  <= ((sreal) 1) * opt_for_fn (cs->caller->decl,\n+\t\t\t\t       param_ipa_cp_min_recursive_probability))\n \treturn dest_lat->set_contains_variable ();\n \n       auto_vec<ipcp_value<tree> *, 8> val_seeds;\n@@ -2037,7 +2041,7 @@ propagate_vals_across_arith_jfunc (cgraph_edge *cs,\n       /* Recursively generate lattice values with a limited count.  */\n       FOR_EACH_VEC_ELT (val_seeds, i, src_val)\n \t{\n-\t  for (int j = 1; j < param_ipa_cp_max_recursive_depth; j++)\n+\t  for (int j = 1; j < max_recursive_depth; j++)\n \t    {\n \t      tree cstval = get_val_across_arith_op (opcode, opnd1_type, opnd2,\n \t\t\t\t\t\t     src_val, res_type);\n@@ -3173,27 +3177,30 @@ devirtualization_time_bonus (struct cgraph_node *node,\n /* Return time bonus incurred because of HINTS.  */\n \n static int\n-hint_time_bonus (ipa_hints hints)\n+hint_time_bonus (cgraph_node *node, ipa_hints hints)\n {\n   int result = 0;\n   if (hints & (INLINE_HINT_loop_iterations | INLINE_HINT_loop_stride))\n-    result += param_ipa_cp_loop_hint_bonus;\n+    result += opt_for_fn (node->decl, param_ipa_cp_loop_hint_bonus);\n   return result;\n }\n \n /* If there is a reason to penalize the function described by INFO in the\n    cloning goodness evaluation, do so.  */\n \n static inline int64_t\n-incorporate_penalties (ipa_node_params *info, int64_t evaluation)\n+incorporate_penalties (cgraph_node *node, ipa_node_params *info,\n+\t\t       int64_t evaluation)\n {\n   if (info->node_within_scc && !info->node_is_self_scc)\n     evaluation = (evaluation\n-\t\t  * (100 - param_ipa_cp_recursion_penalty)) / 100;\n+\t\t  * (100 - opt_for_fn (node->decl,\n+\t\t\t\t       param_ipa_cp_recursion_penalty))) / 100;\n \n   if (info->node_calling_single_call)\n     evaluation = (evaluation\n-\t\t  * (100 - param_ipa_cp_single_call_penalty))\n+\t\t  * (100 - opt_for_fn (node->decl,\n+\t\t\t\t       param_ipa_cp_single_call_penalty)))\n       / 100;\n \n   return evaluation;\n@@ -3215,14 +3222,15 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n   gcc_assert (size_cost > 0);\n \n   class ipa_node_params *info = IPA_NODE_REF (node);\n+  int eval_threshold = opt_for_fn (node->decl, param_ipa_cp_eval_threshold);\n   if (max_count > profile_count::zero ())\n     {\n       int factor = RDIV (count_sum.probability_in\n \t\t\t\t (max_count).to_reg_br_prob_base ()\n \t\t         * 1000, REG_BR_PROB_BASE);\n       int64_t evaluation = (((int64_t) time_benefit * factor)\n \t\t\t\t    / size_cost);\n-      evaluation = incorporate_penalties (info, evaluation);\n+      evaluation = incorporate_penalties (node, info, evaluation);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -3234,16 +3242,16 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n \t\t info->node_within_scc\n \t\t   ? (info->node_is_self_scc ? \", self_scc\" : \", scc\") : \"\",\n \t\t info->node_calling_single_call ? \", single_call\" : \"\",\n-\t\t evaluation, param_ipa_cp_eval_threshold);\n+\t\t evaluation, eval_threshold);\n \t}\n \n-      return evaluation >= param_ipa_cp_eval_threshold;\n+      return evaluation >= eval_threshold;\n     }\n   else\n     {\n       int64_t evaluation = (((int64_t) time_benefit * freq_sum)\n \t\t\t\t    / size_cost);\n-      evaluation = incorporate_penalties (info, evaluation);\n+      evaluation = incorporate_penalties (node, info, evaluation);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"     good_cloning_opportunity_p (time: %i, \"\n@@ -3253,9 +3261,9 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n \t\t info->node_within_scc\n \t\t   ? (info->node_is_self_scc ? \", self_scc\" : \", scc\") : \"\",\n \t\t info->node_calling_single_call ? \", single_call\" : \"\",\n-\t\t evaluation, param_ipa_cp_eval_threshold);\n+\t\t evaluation, eval_threshold);\n \n-      return evaluation >= param_ipa_cp_eval_threshold;\n+      return evaluation >= eval_threshold;\n     }\n }\n \n@@ -3393,7 +3401,7 @@ perform_estimation_of_a_value (cgraph_node *node, vec<tree> known_csts,\n     time_benefit = base_time.to_int ()\n       + devirtualization_time_bonus (node, known_csts, known_contexts,\n \t\t\t\t     known_aggs)\n-      + hint_time_bonus (hints)\n+      + hint_time_bonus (node, hints)\n       + removable_params_cost + est_move_cost;\n \n   gcc_checking_assert (size >=0);\n@@ -3448,7 +3456,7 @@ estimate_local_effects (struct cgraph_node *node)\n \t\t\t\t\t known_aggs, &size, &time,\n \t\t\t\t\t &base_time, &hints);\n       time -= devirt_bonus;\n-      time -= hint_time_bonus (hints);\n+      time -= hint_time_bonus (node, hints);\n       time -= removable_params_cost;\n       size -= stats.n_calls * removable_params_cost;\n \n@@ -3876,7 +3884,7 @@ ipcp_propagate_stage (class ipa_topo_info *topo)\n   max_new_size = overall_size;\n   if (max_new_size < param_large_unit_insns)\n     max_new_size = param_large_unit_insns;\n-  max_new_size += max_new_size * param_ipcp_unit_growth / 100 + 1;\n+  max_new_size += max_new_size * param_ipa_cp_unit_growth / 100 + 1;\n \n   if (dump_file)\n     fprintf (dump_file, \"\\noverall_size: %li, max_new_size: %li\\n\","}, {"sha": "a16b892f4a351cf26ae162de514b2eddf611be4f", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe", "patch": "@@ -1324,7 +1324,7 @@ decompose_param_expr (struct ipa_func_body_info *fbi,\n \t\t      struct agg_position_info *aggpos,\n \t\t      expr_eval_ops *param_ops_p = NULL)\n {\n-  int op_limit = param_ipa_max_param_expr_ops;\n+  int op_limit = opt_for_fn (fbi->node->decl, param_ipa_max_param_expr_ops);\n   int op_count = 0;\n \n   if (param_ops_p)\n@@ -1555,7 +1555,8 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \n   auto_vec<std::pair<tree, tree> > ranges;\n   tree type = TREE_TYPE (op);\n-  int bound_limit = param_ipa_max_switch_predicate_bounds;\n+  int bound_limit = opt_for_fn (fbi->node->decl,\n+\t\t\t\tparam_ipa_max_switch_predicate_bounds);\n   int bound_count = 0;\n   wide_int vr_wmin, vr_wmax;\n   value_range_kind vr_type = get_range_info (op, &vr_wmin, &vr_wmax);\n@@ -2451,7 +2452,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t  fbi.bb_infos = vNULL;\n \t  fbi.bb_infos.safe_grow_cleared (last_basic_block_for_fn (cfun));\n \t  fbi.param_count = count_formal_params (node->decl);\n-\t  fbi.aa_walk_budget = param_ipa_max_aa_steps;\n+\t  fbi.aa_walk_budget = opt_for_fn (node->decl, param_ipa_max_aa_steps);\n \n \t  nonconstant_names.safe_grow_cleared\n \t    (SSANAMES (my_function)->length ());"}, {"sha": "3c71aab4ecb92293ef3a3dc8453dac0b3c139c4d", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe", "patch": "@@ -455,9 +455,10 @@ offline_size (struct cgraph_node *node, ipa_size_summary *info)\n          Take this into account.  */\n       else if (DECL_COMDAT (node->decl)\n \t       && node->can_remove_if_no_direct_calls_p ())\n-\treturn (info->size\n-\t\t* (100 - param_comdat_sharing_probability)\n-\t\t+ 50) / 100;\n+\t{\n+\t  int prob = opt_for_fn (node->decl, param_comdat_sharing_probability);\n+\t  return info->size * (100 - prob + 50) / 100;\n+\t}\n     }\n   return 0;\n }"}, {"sha": "4228e17951f2b1cf3ad0869d7e759b6ef0214969", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe", "patch": "@@ -2966,7 +2966,8 @@ early_inliner (function *fun)\n \t}\n       /* We iterate incremental inlining to get trivial cases of indirect\n \t inlining.  */\n-      while (iterations < param_early_inliner_max_iterations\n+      while (iterations < opt_for_fn (node->decl,\n+\t\t\t\t      param_early_inliner_max_iterations)\n \t     && early_inline_small_functions (node))\n \t{\n \t  timevar_push (TV_INTEGRATION);\n@@ -2985,7 +2986,8 @@ early_inliner (function *fun)\n \t      es->call_stmt_time\n \t\t= estimate_num_insns (edge->call_stmt, &eni_time_weights);\n \t    }\n-\t  if (iterations < param_early_inliner_max_iterations - 1)\n+\t  if (iterations < opt_for_fn (node->decl,\n+\t\t\t\t       param_early_inliner_max_iterations) - 1)\n \t    ipa_update_overall_fn_summary (node);\n \t  timevar_pop (TV_INTEGRATION);\n \t  iterations++;"}, {"sha": "01c3580adda26d12e87e23a7aa2f4da587f3978c", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe", "patch": "@@ -2876,7 +2876,7 @@ ipa_analyze_node (struct cgraph_node *node)\n   fbi.bb_infos = vNULL;\n   fbi.bb_infos.safe_grow_cleared (last_basic_block_for_fn (cfun));\n   fbi.param_count = ipa_get_param_count (info);\n-  fbi.aa_walk_budget = param_ipa_max_aa_steps;\n+  fbi.aa_walk_budget = opt_for_fn (node->decl, param_ipa_max_aa_steps);\n \n   for (struct cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n     {\n@@ -5756,7 +5756,7 @@ ipcp_transform_function (struct cgraph_node *node)\n   fbi.bb_infos = vNULL;\n   fbi.bb_infos.safe_grow_cleared (last_basic_block_for_fn (cfun));\n   fbi.param_count = param_count;\n-  fbi.aa_walk_budget = param_ipa_max_aa_steps;\n+  fbi.aa_walk_budget = opt_for_fn (node->decl, param_ipa_max_aa_steps);\n \n   vec_safe_grow_cleared (descriptors, param_count);\n   ipa_populate_param_decls (node, *descriptors);"}, {"sha": "79b543fa934be90e51e4cb4adef026b81297fa3c", "filename": "gcc/ipa-sra.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fipa-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fipa-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.c?ref=fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe", "patch": "@@ -2279,7 +2279,9 @@ process_scan_results (cgraph_node *node, struct function *fun,\n       if (!desc->by_ref || optimize_function_for_size_p (fun))\n \tparam_size_limit = cur_param_size;\n       else\n-\tparam_size_limit = param_ipa_sra_ptr_growth_factor * cur_param_size;\n+\t  param_size_limit\n+\t    = opt_for_fn (node->decl,\n+\t\t\t  param_ipa_sra_ptr_growth_factor) * cur_param_size;\n       if (nonarg_acc_size > param_size_limit\n \t  || (!desc->by_ref && nonarg_acc_size == param_size_limit))\n \t{\n@@ -2499,7 +2501,7 @@ ipa_sra_summarize_function (cgraph_node *node)\n \t  bb_dereferences = XCNEWVEC (HOST_WIDE_INT,\n \t\t\t\t      by_ref_count\n \t\t\t\t      * last_basic_block_for_fn (fun));\n-\t  aa_walking_limit = param_ipa_max_aa_steps;\n+\t  aa_walking_limit = opt_for_fn (node->decl, param_ipa_max_aa_steps);\n \t  scan_function (node, fun);\n \n \t  if (dump_file)"}, {"sha": "094e04aae5e7667d5a572df52d7f91ed417816a0", "filename": "gcc/params.opt", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=fdfd7f53ba8f363c31a1cbb5310f92ecfc52cbfe", "patch": "@@ -83,7 +83,7 @@ Common Joined UInteger Var(param_case_values_threshold) Param Optimization\n The smallest number of different values for which it is best to use a jump-table instead of a tree of conditional branches, if 0, use the default for the machine.\n \n -param=comdat-sharing-probability=\n-Common Joined UInteger Var(param_comdat_sharing_probability) Init(20) Param\n+Common Joined UInteger Var(param_comdat_sharing_probability) Init(20) Param Optimization\n Probability that COMDAT function will be shared with different compilation unit.\n \n -param=cxx-max-namespaces-for-diagnostic-help=\n@@ -191,61 +191,61 @@ Common Joined UInteger Var(param_integer_share_limit) Init(251) IntegerRange(2,\n The upper bound for sharing integer constants.\n \n -param=ipa-cp-eval-threshold=\n-Common Joined UInteger Var(param_ipa_cp_eval_threshold) Init(500) Param\n+Common Joined UInteger Var(param_ipa_cp_eval_threshold) Init(500) Param Optimization\n Threshold ipa-cp opportunity evaluation that is still considered beneficial to clone.\n \n -param=ipa-cp-loop-hint-bonus=\n-Common Joined UInteger Var(param_ipa_cp_loop_hint_bonus) Init(64) Param\n+Common Joined UInteger Var(param_ipa_cp_loop_hint_bonus) Init(64) Param Optimization\n Compile-time bonus IPA-CP assigns to candidates which make loop bounds or strides known.\n \n -param=ipa-cp-max-recursive-depth=\n-Common Joined UInteger Var(param_ipa_cp_max_recursive_depth) Init(8) Param\n+Common Joined UInteger Var(param_ipa_cp_max_recursive_depth) Init(8) Param Optimization\n Maximum depth of recursive cloning for self-recursive function.\n \n -param=ipa-cp-min-recursive-probability=\n-Common Joined UInteger Var(param_ipa_cp_min_recursive_probability) Init(2) Param\n+Common Joined UInteger Var(param_ipa_cp_min_recursive_probability) Init(2) Param Optimization\n Recursive cloning only when the probability of call being executed exceeds the parameter.\n \n -param=ipa-cp-recursion-penalty=\n-Common Joined UInteger Var(param_ipa_cp_recursion_penalty) Init(40) IntegerRange(0, 100) Param\n+Common Joined UInteger Var(param_ipa_cp_recursion_penalty) Init(40) IntegerRange(0, 100) Param Optimization\n Percentage penalty the recursive functions will receive when they are evaluated for cloning.\n \n -param=ipa-cp-single-call-penalty=\n-Common Joined UInteger Var(param_ipa_cp_single_call_penalty) Init(15) IntegerRange(0, 100) Param\n+Common Joined UInteger Var(param_ipa_cp_single_call_penalty) Init(15) IntegerRange(0, 100) Param Optimization\n Percentage penalty functions containing a single call to another function will receive when they are evaluated for cloning.\n \n+-param=ipa-cp-unit-growth=\n+Common Joined UInteger Var(param_ipa_cp_unit_growth) Init(10) Param\n+How much can given compilation unit grow because of the interprocedural constant propagation (in percent).\n+\n -param=ipa-cp-value-list-size=\n-Common Joined UInteger Var(param_ipa_cp_value_list_size) Init(8) Param\n+Common Joined UInteger Var(param_ipa_cp_value_list_size) Init(8) Param Optimization\n Maximum size of a list of values associated with each parameter for interprocedural constant propagation.\n \n -param=ipa-max-aa-steps=\n-Common Joined UInteger Var(param_ipa_max_aa_steps) Init(25000) Param\n+Common Joined UInteger Var(param_ipa_max_aa_steps) Init(25000) Param Optimization\n Maximum number of statements that will be visited by IPA formal parameter analysis based on alias analysis in any given function.\n \n -param=ipa-max-agg-items=\n Common Joined UInteger Var(param_ipa_max_agg_items) Init(16) Param\n Maximum number of aggregate content items for a parameter in jump functions and lattices.\n \n -param=ipa-max-param-expr-ops=\n-Common Joined UInteger Var(param_ipa_max_param_expr_ops) Init(10) Param\n+Common Joined UInteger Var(param_ipa_max_param_expr_ops) Init(10) Param Optimization\n Maximum number of operations in a parameter expression that can be handled by IPA analysis.\n \n -param=ipa-max-switch-predicate-bounds=\n-Common Joined UInteger Var(param_ipa_max_switch_predicate_bounds) Init(5) Param\n+Common Joined UInteger Var(param_ipa_max_switch_predicate_bounds) Init(5) Param Optimization\n Maximal number of boundary endpoints of case ranges of switch statement used during IPA functoin summary generation.\n \n -param=ipa-sra-max-replacements=\n Common Joined UInteger Var(param_ipa_sra_max_replacements) Init(8) IntegerRange(0, 16) Param\n Maximum pieces that IPA-SRA tracks per formal parameter, as a consequence, also the maximum number of replacements of a formal parameter.\n \n -param=ipa-sra-ptr-growth-factor=\n-Common Joined UInteger Var(param_ipa_sra_ptr_growth_factor) Init(2) Param\n+Common Joined UInteger Var(param_ipa_sra_ptr_growth_factor) Init(2) Param Optimization\n Maximum allowed growth of number and total size of new parameters that ipa-sra replaces a pointer to an aggregate with.\n \n--param=ipcp-unit-growth=\n-Common Joined UInteger Var(param_ipcp_unit_growth) Init(10) Param\n-How much can given compilation unit grow because of the interprocedural constant propagation (in percent).\n-\n -param=ira-loop-reserved-regs=\n Common Joined UInteger Var(param_ira_loop_reserved_regs) Init(2) Param Optimization\n The number of registers in each class kept unused by loop invariant motion.\n@@ -423,7 +423,7 @@ Common Joined UInteger Var(param_max_dse_active_local_stores) Init(5000) Param O\n Maximum number of active local stores in RTL dead store elimination.\n \n -param=max-early-inliner-iterations=\n-Common Joined UInteger Var(param_early_inliner_max_iterations) Init(1) Param\n+Common Joined UInteger Var(param_early_inliner_max_iterations) Init(1) Param Optimization\n The maximum number of nested indirect inlining performed by early inliner.\n \n -param=max-fields-for-field-sensitive="}]}