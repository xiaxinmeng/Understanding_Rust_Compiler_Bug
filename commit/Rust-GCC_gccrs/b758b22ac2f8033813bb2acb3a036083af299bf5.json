{"sha": "b758b22ac2f8033813bb2acb3a036083af299bf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc1OGIyMmFjMmY4MDMzODEzYmIyYWNiM2EwMzYwODNhZjI5OWJmNQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2005-03-24T18:32:18Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2005-03-24T18:32:18Z"}, "message": "memory: Forward to...\n\n\n2005-03-24  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/tr1/memory: Forward to...\n\t* include/tr1/boost_shared_ptr.h: ...here. Add Boost Software License.\n\t* include/Makefile.am (tr1_headers): Add boost_shared_ptr.h.\n\t* include/Makefile.in: Regenerate.\n\t* testsuite/tr1/2_general_utilities/memory/shared_ptr/cons/\n\tauto_ptr_neg.cc: Adjust line numbers.\n\nFrom-SVN: r97003", "tree": {"sha": "1d6564dcc953a460282e369de74b32aea1e3b1d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d6564dcc953a460282e369de74b32aea1e3b1d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b758b22ac2f8033813bb2acb3a036083af299bf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b758b22ac2f8033813bb2acb3a036083af299bf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b758b22ac2f8033813bb2acb3a036083af299bf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b758b22ac2f8033813bb2acb3a036083af299bf5/comments", "author": null, "committer": null, "parents": [{"sha": "8db2ba4032d683b70d21d443f519c79362db8593", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8db2ba4032d683b70d21d443f519c79362db8593", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8db2ba4032d683b70d21d443f519c79362db8593"}], "stats": {"total": 1929, "additions": 993, "deletions": 936}, "files": [{"sha": "6bb315b976d453517d67a931785043642077147e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b758b22ac2f8033813bb2acb3a036083af299bf5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b758b22ac2f8033813bb2acb3a036083af299bf5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b758b22ac2f8033813bb2acb3a036083af299bf5", "patch": "@@ -1,3 +1,12 @@\n+2005-03-24  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/tr1/memory: Forward to...\n+\t* include/tr1/boost_shared_ptr.h: ...here. Add Boost Software License.\n+\t* include/Makefile.am (tr1_headers): Add boost_shared_ptr.h.\n+\t* include/Makefile.in: Regenerate.\n+\t* testsuite/tr1/2_general_utilities/memory/shared_ptr/cons/\n+\tauto_ptr_neg.cc: Adjust line numbers.\n+\n 2005-03-23  Mark Mitchell  <mark@codesourcery.com>\n \n \t* testsuite/Makefile.am (all-local): Do not build testsuite_files.\n@@ -56,7 +65,7 @@\n \t(listdc++_build_support): New function.\n \t* testsuite/libstdc++-dg/normal.exp: Rework to dynamically\n \tgenerate list of tests.\n-\t\n+\n 2005-03-21  Chris Jefferson  <chris@bubblescope.net>\n \n \tPR libstdc++/20577"}, {"sha": "547ec373adbe44197330d93c48c5347422b86ae9", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b758b22ac2f8033813bb2acb3a036083af299bf5/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b758b22ac2f8033813bb2acb3a036083af299bf5/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=b758b22ac2f8033813bb2acb3a036083af299bf5", "patch": "@@ -228,6 +228,7 @@ tr1_srcdir = ${glibcxx_srcdir}/include/tr1\n tr1_builddir = ./tr1\n tr1_headers = \\\n \t${tr1_srcdir}/array \\\n+\t${tr1_srcdir}/boost_shared_ptr.h \\\n \t${tr1_srcdir}/functional \\\n \t${tr1_srcdir}/functional_iterate.h \\\n \t${tr1_srcdir}/memory \\"}, {"sha": "814bccf8b0845cc961319c6b861f3d053b1baab8", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b758b22ac2f8033813bb2acb3a036083af299bf5/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b758b22ac2f8033813bb2acb3a036083af299bf5/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=b758b22ac2f8033813bb2acb3a036083af299bf5", "patch": "@@ -447,6 +447,7 @@ tr1_srcdir = ${glibcxx_srcdir}/include/tr1\n tr1_builddir = ./tr1\n tr1_headers = \\\n \t${tr1_srcdir}/array \\\n+\t${tr1_srcdir}/boost_shared_ptr.h \\\n \t${tr1_srcdir}/functional \\\n \t${tr1_srcdir}/functional_iterate.h \\\n \t${tr1_srcdir}/memory \\"}, {"sha": "f55c0537586522076111e6bd194ba56f22199d30", "filename": "libstdc++-v3/include/tr1/boost_shared_ptr.h", "status": "added", "additions": 975, "deletions": 0, "changes": 975, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b758b22ac2f8033813bb2acb3a036083af299bf5/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b758b22ac2f8033813bb2acb3a036083af299bf5/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h?ref=b758b22ac2f8033813bb2acb3a036083af299bf5", "patch": "@@ -0,0 +1,975 @@\n+// <tr1/boost_shared_ptr.h> -*- C++ -*-\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//  shared_count.hpp\n+//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n+\n+//  shared_ptr.hpp\n+//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n+//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n+\n+//  weak_ptr.hpp\n+//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n+\n+//  enable_shared_from_this.hpp\n+//  Copyright (C) 2002 Peter Dimov\n+\n+// Distributed under the Boost Software License, Version 1.0. (See\n+// accompanying file LICENSE_1_0.txt or copy at\n+// http://www.boost.org/LICENSE_1_0.txt)\n+\n+// GCC Note:  based on version 1.32.0 of the Boost library.\n+\n+/** @file boost_memory.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _BOOST_SHARED_PTR_H\n+#define _BOOST_SHARED_PTR_H 1\n+\n+// namespace std::tr1\n+namespace std\n+{\n+namespace tr1\n+{\n+\n+class bad_weak_ptr : public std::exception\n+{\n+public:\n+\n+  virtual char const* what() const throw()\n+  {\n+    return \"tr1::bad_weak_ptr\";\n+  }\n+};\n+\n+// Helper for exception objects in <tr1/memory>\n+// TODO this should be defined in a different file.\n+inline void\n+__throw_bad_weak_ptr()\n+{\n+#if __EXCEPTIONS\n+  throw bad_weak_ptr();\n+#else\n+  std::abort();\n+#endif\n+}\n+\n+\n+template <typename _Tp>\n+  struct _Sp_deleter\n+  {\n+    typedef void result_type;\n+    typedef _Tp* argument_type;\n+\n+    void\n+    operator()(_Tp* p) const\n+    { delete p; }\n+  };\n+\n+\n+class _Sp_counted_base\n+{\n+public:\n+\n+  _Sp_counted_base()\n+  : _M_use_count(1), _M_weak_count(1)\n+  { }\n+\n+  virtual\n+  ~_Sp_counted_base() // nothrow\n+  { }\n+\n+  // dispose() is called when _M_use_count drops to zero, to release\n+  // the resources managed by *this.\n+  virtual void\n+  dispose() = 0; // nothrow\n+\n+  // destroy() is called when _M_weak_count drops to zero.\n+  virtual void\n+  destroy() // nothrow\n+  {\n+    delete this;\n+  }\n+\n+  virtual void*\n+  get_deleter(const std::type_info&) = 0;\n+\n+  void\n+  add_ref_copy()\n+  {\n+    __gnu_cxx::__atomic_add(&_M_use_count, 1);\n+  }\n+\n+  void\n+  add_ref_lock()\n+  {\n+    if (_M_use_count <= 0) // TODO not yet MT safe XXX\n+    {\n+      __throw_bad_weak_ptr();\n+    }\n+    __gnu_cxx::__atomic_add(&_M_use_count, 1);\n+  }\n+\n+  void\n+  release() // nothrow\n+  {\n+    if (__gnu_cxx::__exchange_and_add(&_M_use_count, -1) <= 1)\n+    {\n+      dispose();\n+      weak_release();\n+    }\n+  }\n+\n+  void\n+  weak_add_ref() // nothrow\n+  {\n+    __gnu_cxx::__atomic_add(&_M_weak_count, 1);\n+  }\n+\n+  void\n+  weak_release() // nothrow\n+  {\n+    if (__gnu_cxx::__exchange_and_add(&_M_weak_count, -1) <= 1)\n+    {\n+      destroy();\n+    }\n+  }\n+\n+  long\n+  use_count() const // nothrow\n+  {\n+    return _M_use_count;  // XXX is this MT safe?\n+  }\n+\n+private:\n+\n+  _Sp_counted_base(_Sp_counted_base const&);\n+  _Sp_counted_base& operator= (_Sp_counted_base const&);\n+\n+  _Atomic_word _M_use_count;        // #shared\n+  _Atomic_word _M_weak_count;       // #weak + (#shared != 0)\n+};\n+\n+template <typename _Ptr, typename _Deleter>\n+class _Sp_counted_base_impl : public _Sp_counted_base\n+{\n+public:\n+\n+  /**\n+   *  @brief   \n+   *  @pre     d(p) must not throw.\n+   */\n+  _Sp_counted_base_impl(_Ptr __p, _Deleter __d)\n+  : _M_ptr(__p), _M_del(__d)\n+  { }\n+\n+  virtual void\n+  dispose() // nothrow\n+  {\n+    _M_del(_M_ptr);\n+  }\n+\n+  virtual void*\n+  get_deleter(const std::type_info& __ti)\n+  {\n+    return __ti == typeid(_Deleter) ? &_M_del : 0;\n+  }\n+\n+private:\n+  _Sp_counted_base_impl(const _Sp_counted_base_impl&);\n+  _Sp_counted_base_impl& operator=(const _Sp_counted_base_impl&);\n+\n+  _Ptr     _M_ptr; // copy constructor must not throw\n+  _Deleter _M_del; // copy constructor must not throw\n+};\n+\n+class weak_count;\n+\n+class shared_count\n+{\n+private:\n+\n+  _Sp_counted_base* _M_pi;\n+\n+  friend class weak_count;\n+\n+public:\n+\n+  shared_count()\n+  : _M_pi(0) // nothrow\n+  { }\n+\n+  template <typename _Ptr, typename _Deleter>\n+    shared_count(_Ptr __p, _Deleter __d)\n+    : _M_pi(0)\n+    {\n+      try\n+      {\n+        _M_pi = new _Sp_counted_base_impl<_Ptr, _Deleter>(__p, __d);\n+      }\n+      catch(...)\n+      {\n+        __d(__p); // delete __p\n+        __throw_exception_again;\n+      }\n+    }\n+\n+  // auto_ptr<_Tp> is special cased to provide the strong guarantee\n+\n+  template <typename _Tp>\n+    explicit shared_count(std::auto_ptr<_Tp>& __r)\n+    : _M_pi(new _Sp_counted_base_impl<_Tp*,_Sp_deleter<_Tp> >(\n+            __r.get(), _Sp_deleter<_Tp>()\n+            ))\n+    { __r.release(); }\n+\n+  // throws bad_weak_ptr when __r.use_count() == 0\n+  explicit shared_count(const weak_count& __r);\n+\n+  ~shared_count() // nothrow\n+  {\n+    if (_M_pi != 0)\n+      _M_pi->release();\n+  }\n+\n+  shared_count(const shared_count& __r)\n+  : _M_pi(__r._M_pi) // nothrow\n+  {\n+    if (_M_pi != 0)\n+      _M_pi->add_ref_copy();\n+  }\n+\n+  shared_count&\n+  operator=(const shared_count& __r) // nothrow\n+  {\n+    _Sp_counted_base* __tmp = __r._M_pi;\n+\n+    if(__tmp != _M_pi)\n+    {\n+      if(__tmp != 0)\n+        __tmp->add_ref_copy();\n+      if(_M_pi != 0)\n+        _M_pi->release();\n+      _M_pi = __tmp;\n+    }\n+    return *this;\n+  }\n+\n+  void swap(shared_count& __r) // nothrow\n+  {\n+    _Sp_counted_base* __tmp = __r._M_pi;\n+    __r._M_pi = _M_pi;\n+    _M_pi = __tmp;\n+  }\n+\n+  long\n+  use_count() const // nothrow\n+  { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n+\n+  bool\n+  unique() const // nothrow\n+  { return this->use_count() == 1; }\n+\n+  friend inline bool\n+  operator==(const shared_count& __a, const shared_count& __b)\n+  { return __a._M_pi == __b._M_pi; }\n+\n+  friend inline bool\n+  operator<(const shared_count& __a, const shared_count& __b)\n+  { return std::less<_Sp_counted_base*>()(__a._M_pi, __b._M_pi); }\n+\n+  void*\n+  get_deleter(const std::type_info& __ti) const\n+  { return _M_pi ? _M_pi->get_deleter(__ti) : 0; }\n+};\n+\n+\n+class weak_count\n+{\n+private:\n+\n+  _Sp_counted_base * _M_pi;\n+\n+  friend class shared_count;\n+\n+public:\n+\n+  weak_count()\n+  : _M_pi(0) // nothrow\n+  { }\n+\n+  weak_count(const shared_count& __r)\n+  : _M_pi(__r._M_pi) // nothrow\n+  {\n+    if (_M_pi != 0)\n+      _M_pi->weak_add_ref();\n+  }\n+\n+  weak_count(const weak_count& __r)\n+  : _M_pi(__r._M_pi) // nothrow\n+  {\n+    if (_M_pi != 0)\n+      _M_pi->weak_add_ref();\n+  }\n+\n+  ~weak_count() // nothrow\n+  {\n+    if (_M_pi != 0)\n+      _M_pi->weak_release();\n+  }\n+\n+  weak_count&\n+  operator=(const shared_count& __r) // nothrow\n+  {\n+    _Sp_counted_base* __tmp = __r._M_pi;\n+    if (__tmp != 0)\n+      __tmp->weak_add_ref();\n+    if (_M_pi != 0)\n+      _M_pi->weak_release();\n+    _M_pi = __tmp;\n+\n+    return *this;\n+  }\n+\n+  weak_count&\n+  operator=(const weak_count& __r) // nothrow\n+  {\n+    _Sp_counted_base * __tmp = __r._M_pi;\n+    if (__tmp != 0)\n+      __tmp->weak_add_ref();\n+    if (_M_pi != 0)\n+      _M_pi->weak_release();\n+    _M_pi = __tmp;\n+\n+    return *this;\n+  }\n+\n+  void\n+  swap(weak_count& __r) // nothrow\n+  {\n+    _Sp_counted_base * __tmp = __r._M_pi;\n+    __r._M_pi = _M_pi;\n+    _M_pi = __tmp;\n+  }\n+\n+  long\n+  use_count() const // nothrow\n+  { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n+\n+  friend inline bool\n+  operator==(const weak_count& __a, const weak_count& __b)\n+  { return __a._M_pi == __b._M_pi; }\n+\n+  friend inline bool\n+  operator<(const weak_count& __a, const weak_count& __b)\n+  { return std::less<_Sp_counted_base*>()(__a._M_pi, __b._M_pi); }\n+};\n+\n+inline\n+shared_count::shared_count(const weak_count& __r)\n+: _M_pi(__r._M_pi)\n+{\n+  if (_M_pi != 0)\n+  {\n+    _M_pi->add_ref_lock();\n+  }\n+  else\n+  {\n+    __throw_bad_weak_ptr();\n+  }\n+}\n+\n+// fwd decls\n+template <typename _Tp> class weak_ptr;\n+template <typename _Tp> class enable_shared_from_this;\n+\n+struct __static_cast_tag {};\n+struct __const_cast_tag {};\n+struct __dynamic_cast_tag {};\n+struct __polymorphic_cast_tag {};\n+\n+template<class _Tp> struct shared_ptr_traits\n+{\n+    typedef _Tp & reference;\n+};\n+\n+template<> struct shared_ptr_traits<void>\n+{\n+    typedef void reference;\n+};\n+\n+template<> struct shared_ptr_traits<void const>\n+{\n+    typedef void reference;\n+};\n+\n+template<> struct shared_ptr_traits<void volatile>\n+{\n+    typedef void reference;\n+};\n+\n+template<> struct shared_ptr_traits<void const volatile>\n+{\n+    typedef void reference;\n+};\n+\n+\n+// enable_shared_from_this support\n+\n+// friend of enable_shared_from_this\n+template <typename _Tp1, typename _Tp2>\n+  void\n+  __enable_shared_from_this( const shared_count& __pn,\n+                             const enable_shared_from_this<_Tp1>* __pe,\n+                             const _Tp2* __px );\n+\n+inline void\n+__enable_shared_from_this(const shared_count&, ...)\n+{ }\n+\n+/**\n+ *  @class shared_ptr <tr1/memory>\n+ *\n+ *  A smart pointer with reference-counted copy semantics.\n+ *  The object pointed to is deleted when the last shared_ptr pointing to it\n+ *  is destroyed or reset.\n+ */\n+\n+template <typename _Tp>\n+  class shared_ptr\n+  {\n+    typedef typename shared_ptr_traits<_Tp>::reference _Reference;\n+\n+  public:\n+\n+    typedef _Tp   element_type;\n+\n+    /** @brief  Construct an empty %shared_ptr.\n+     *  @post   use_count()==0 && get()==0\n+     */\n+    shared_ptr() : _M_ptr(0), _M_refcount() // never throws\n+    { }\n+\n+    /** @brief  Construct a %shared_ptr that owns the pointer @a p.\n+     *  @param  p  A pointer that is convertible to element_type*.\n+     *  @post   use_count()==1 && get()==p\n+     *  @throw  std::bad_alloc, in which case @c delete @a p is called.\n+     */\n+    template <typename _Tp1>\n+      explicit shared_ptr(_Tp1* __p)\n+      : _M_ptr(__p), _M_refcount(__p, _Sp_deleter<_Tp1>())\n+      {\n+        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+        // __glibcxx_function_requires(_CompleteConcept<_Tp1*>)\n+\n+        __enable_shared_from_this( _M_refcount, __p, __p );\n+      }\n+\n+    //\n+    // Requirements: D's copy constructor and destructor must not throw\n+    //\n+    // shared_ptr will release p by calling d(p)\n+    //\n+    /** @brief  Construct a %shared_ptr that owns the pointer @a p\n+     *          and the deleter @a d.\n+     *  @param  p  A pointer.\n+     *  @param  d  A deleter.\n+     *  @post   use_count()==1 && get()==p\n+     *  @throw  std::bad_alloc, in which case @a d(p) is called.\n+     */\n+    template <typename _Tp1, typename _Deleter>\n+      shared_ptr(_Tp1* __p, _Deleter __d)\n+      : _M_ptr(__p), _M_refcount(__p, __d)\n+      {\n+        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+        // TODO requires D is CopyConstructible and d(p) well-formed\n+\n+        __enable_shared_from_this( _M_refcount, __p, __p );\n+      }\n+\n+    //  generated copy constructor, assignment, destructor are fine.\n+\n+    /** @brief  If @a r is empty, constructs an empty %shared_ptr; otherwise\n+     *          construct a %shared_ptr that shares ownership with @a r.\n+     *  @param  r  A %shared_ptr.\n+     *  @post   get()==r.get() && use_count()==r.use_count()\n+     *  @throw  std::bad_alloc, in which case \n+     */\n+    template <typename _Tp1>\n+      shared_ptr(const shared_ptr<_Tp1>& __r)\n+      : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n+      {\n+        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+      }\n+\n+    /** @brief  Constructs a %shared_ptr that shares ownership with @a r\n+     *          and stores a copy of the pointer stored in @a r.\n+     *  @param  r  A weak_ptr.\n+     *  @post   use_count()==r.use_count()\n+     *  @throw  bad_weak_ptr when r.expired(),\n+     *          in which case the constructor has no effect.\n+     */\n+    template <typename _Tp1>\n+      explicit shared_ptr(const weak_ptr<_Tp1>& __r)\n+      : _M_refcount(__r._M_refcount) // may throw\n+      {\n+        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+        // it is now safe to copy r__._M_ptr, as _M_refcount(__r._M_refcount)\n+        // did not throw\n+        _M_ptr = __r._M_ptr;\n+      }\n+\n+    /**\n+     * @post use_count()==1 and r.get()==0\n+     */\n+    template <typename _Tp1>\n+      explicit shared_ptr(std::auto_ptr<_Tp1>& __r)\n+      : _M_ptr(__r.get()), _M_refcount()\n+      {\n+        // TODO requires r.release() convertible to _Tp*, Tp1 is complete,\n+        // delete r.release() well-formed\n+        _Tp1 * __tmp = __r.get();\n+        _M_refcount = shared_count(__r);\n+\n+        __enable_shared_from_this( _M_refcount, __tmp, __tmp );\n+      }\n+\n+    template <typename _Tp1>\n+      shared_ptr(const shared_ptr<_Tp1>& __r, __static_cast_tag)\n+      : _M_ptr(static_cast<element_type*>(__r._M_ptr))\n+      , _M_refcount(__r._M_refcount)\n+      { }\n+\n+    template <typename _Tp1>\n+      shared_ptr(const shared_ptr<_Tp1>& __r, __const_cast_tag)\n+      : _M_ptr(const_cast<element_type*>(__r._M_ptr))\n+      , _M_refcount(__r._M_refcount)\n+      { }\n+\n+    template <typename _Tp1>\n+      shared_ptr(const shared_ptr<_Tp1>& __r, __dynamic_cast_tag)\n+      : _M_ptr(dynamic_cast<element_type*>(__r._M_ptr))\n+      , _M_refcount(__r._M_refcount)\n+      {\n+        if (_M_ptr == 0) // need to allocate new counter -- the cast failed\n+        {\n+          _M_refcount = shared_count();\n+        }\n+      }\n+\n+    template <typename _Tp1>\n+      shared_ptr&\n+      operator=(const shared_ptr<_Tp1>& __r) // never throws\n+      {\n+        _M_ptr = __r._M_ptr;\n+        _M_refcount = __r._M_refcount; // shared_count::op= doesn't throw\n+        return *this;\n+      }\n+\n+    template <typename _Tp1>\n+      shared_ptr&\n+      operator=(std::auto_ptr<_Tp1>& __r)\n+      {\n+        shared_ptr(__r).swap(*this);\n+        return *this;\n+      }\n+\n+    void\n+    reset() // never throws\n+    { shared_ptr().swap(*this); }\n+\n+    template <typename _Tp1>\n+      void\n+      reset(_Tp1* __p) // _Tp1 must be complete\n+      {\n+        _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr); // catch self-reset errors\n+        shared_ptr(__p).swap(*this);\n+      }\n+\n+    template <typename _Tp1, typename _Deleter>\n+      void\n+      reset(_Tp1 * __p, _Deleter __d)\n+      { shared_ptr(__p, __d).swap(*this); }\n+\n+    // error to instantiate if _Tp is [cv-qual] void\n+    _Reference\n+    operator*() const // never throws\n+    {\n+      _GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n+      return *_M_ptr;\n+    }\n+\n+    _Tp*\n+    operator->() const // never throws\n+    {\n+      _GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n+      return _M_ptr;\n+    }\n+    \n+    _Tp*\n+    get() const // never throws\n+    { return _M_ptr; }\n+\n+    // implicit conversion to \"bool\"\n+  private:\n+    typedef _Tp* shared_ptr::*__unspecified_bool_type;\n+\n+  public:\n+    operator __unspecified_bool_type() const // never throws\n+    { return _M_ptr == 0 ? 0 : &shared_ptr::_M_ptr; }\n+\n+    bool\n+    unique() const // never throws\n+    { return _M_refcount.unique(); }\n+\n+    long\n+    use_count() const // never throws\n+    { return _M_refcount.use_count(); }\n+\n+    void\n+    swap(shared_ptr<_Tp>& __other) // never throws\n+    {\n+      std::swap(_M_ptr, __other._M_ptr);\n+      _M_refcount.swap(__other._M_refcount);\n+    }\n+\n+  private:\n+    template <typename _Tp1>\n+      bool\n+      _M_less(const shared_ptr<_Tp1>& __rhs) const\n+      { return _M_refcount < __rhs._M_refcount; }\n+\n+    void*\n+    _M_get_deleter(const std::type_info& __ti) const\n+    { return _M_refcount.get_deleter(__ti); }\n+\n+    template <typename _Tp1> friend class shared_ptr;\n+    template <typename _Tp1> friend class weak_ptr;\n+\n+    // friends injected into enclosing namespace and found by ADL:\n+\n+    // get_deleter (experimental)\n+    template <typename _Del>\n+      friend inline _Del*\n+      get_deleter(const shared_ptr& __p)\n+      { return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del))); }\n+\n+    template <typename _Tp1>\n+      friend inline bool\n+      operator==(const shared_ptr& __a, const shared_ptr<_Tp1>& __b)\n+      { return __a.get() == __b.get(); }\n+\n+    template <typename _Tp1>\n+      friend inline bool\n+      operator!=(const shared_ptr& __a, const shared_ptr<_Tp1>& __b)\n+      { return __a.get() != __b.get(); }\n+\n+    template <typename _Tp1>\n+      friend inline bool\n+      operator<(const shared_ptr& __a, const shared_ptr<_Tp1>& __b)\n+      { return __a._M_less(__b); }\n+\n+    _Tp*         _M_ptr;         // contained pointer\n+    shared_count _M_refcount;    // reference counter\n+  };  // shared_ptr\n+\n+// 2.2.3.9 shared_ptr casts\n+\n+/** @warning The seemingly equivalent\n+ *           <code>shared_ptr<T>(static_cast<T*>(r.get()))</code>\n+ *           will eventually result in undefined behaviour,\n+ *           attempting to delete the same object twice.\n+ */\n+template <typename _Tp, typename _Tp1>\n+  shared_ptr<_Tp>\n+  static_pointer_cast(const shared_ptr<_Tp1>& __r)\n+  {\n+    return shared_ptr<_Tp>(__r, __static_cast_tag());\n+  }\n+\n+/** @warning The seemingly equivalent\n+ *           <code>shared_ptr<T>(const_cast<T*>(r.get()))</code>\n+ *           will eventually result in undefined behaviour,\n+ *           attempting to delete the same object twice.\n+ */\n+template <typename _Tp, typename _Tp1>\n+  shared_ptr<_Tp>\n+  const_pointer_cast(const shared_ptr<_Tp1>& __r)\n+  {\n+    return shared_ptr<_Tp>(__r, __const_cast_tag());\n+  }\n+\n+/** @warning The seemingly equivalent\n+ *           <code>shared_ptr<T>(dynamic_cast<T*>(r.get()))</code>\n+ *           will eventually result in undefined behaviour,\n+ *           attempting to delete the same object twice.\n+ */\n+template <typename _Tp, typename _Tp1>\n+  shared_ptr<_Tp>\n+  dynamic_pointer_cast(const shared_ptr<_Tp1>& __r)\n+  {\n+    return shared_ptr<_Tp>(__r, __dynamic_cast_tag());\n+  }\n+\n+// operator<<\n+template <typename _Ch, typename _Tr, typename _Tp>\n+  std::basic_ostream<_Ch,_Tr>&\n+  operator<<(std::basic_ostream<_Ch,_Tr>& __os, const shared_ptr<_Tp>& __p)\n+  {\n+    __os << __p.get();\n+    return __os;\n+  }\n+\n+\n+template <typename _Tp>\n+  class weak_ptr\n+  {\n+  public:\n+\n+    typedef _Tp element_type;\n+\n+    weak_ptr()\n+    : _M_ptr(0), _M_refcount() // never throws\n+    { }\n+\n+  //  generated copy constructor, assignment, destructor are fine\n+\n+  //\n+  //  The \"obvious\" converting constructor implementation:\n+  //\n+  //  template<class Y>\n+  //  weak_ptr(weak_ptr<Y> const & r): _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n+  //  {\n+  //  }\n+  //\n+  //  has a serious problem.\n+  //\n+  //  r._M_ptr may already have been invalidated. The _M_ptr(r._M_ptr)\n+  //  conversion may require access to *r._M_ptr (virtual inheritance).\n+  //\n+  //  It is not possible to avoid spurious access violations since\n+  //  in multithreaded programs r._M_ptr may be invalidated at any point.\n+  //\n+\n+    template <typename _Tp1>\n+      weak_ptr(const weak_ptr<_Tp1>& r)\n+      : _M_refcount(r._M_refcount) // never throws\n+      {\n+        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+        _M_ptr = r.lock().get();\n+      }\n+\n+    template <typename _Tp1>\n+      weak_ptr(const shared_ptr<_Tp1>& r)\n+      : _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n+      {\n+        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+      }\n+\n+    template <typename _Tp1>\n+      weak_ptr&\n+      operator=(const weak_ptr<_Tp1>& r) // never throws\n+      {\n+        _M_ptr = r.lock().get();\n+        _M_refcount = r._M_refcount;\n+        return *this;\n+      }\n+\n+    template <typename _Tp1>\n+      weak_ptr&\n+      operator=(const shared_ptr<_Tp1>& r) // never throws\n+      {\n+        _M_ptr = r._M_ptr;\n+        _M_refcount = r._M_refcount;\n+        return *this;\n+      }\n+\n+    shared_ptr<_Tp>\n+    lock() const // never throws\n+    {\n+#ifdef __GTHREADS\n+\n+      // optimization: avoid throw overhead\n+      if (expired())\n+      {\n+        return shared_ptr<element_type>();\n+      }\n+\n+      try\n+      {\n+        return shared_ptr<element_type>(*this);\n+      }\n+      catch (const bad_weak_ptr&)\n+      {\n+        // Q: how can we get here?\n+        // A: another thread may have invalidated r after the use_count test above.\n+        return shared_ptr<element_type>();\n+      }\n+\n+#else\n+\n+      // optimization: avoid try/catch overhead when single threaded\n+      return expired() ? shared_ptr<element_type>() : shared_ptr<element_type>(*this);\n+\n+#endif\n+    } // XXX MT\n+\n+\n+    long\n+    use_count() const // never throws\n+    { return _M_refcount.use_count(); }\n+\n+    bool\n+    expired() const // never throws\n+    { return _M_refcount.use_count() == 0; }\n+\n+    void\n+    reset() // never throws\n+    { weak_ptr().swap(*this); }\n+\n+    void\n+    swap(weak_ptr& __s) // never throws\n+    {\n+      std::swap(_M_ptr, __s._M_ptr);\n+      _M_refcount.swap(__s._M_refcount);\n+    }\n+\n+  private:\n+\n+    template <typename _Tp1>\n+      bool\n+      _M_less(const weak_ptr<_Tp1>& __rhs) const\n+      { return _M_refcount < __rhs._M_refcount; }\n+\n+    // used by __enable_shared_from_this\n+    void\n+    _M_assign(_Tp* __ptr, const shared_count& __refcount)\n+    {\n+      _M_ptr = __ptr;\n+      _M_refcount = __refcount;\n+    }\n+\n+    // friend injected into namespace and found by ADL\n+\n+    template <typename _Tp1>\n+      friend inline bool\n+      operator<(const weak_ptr& __lhs, const weak_ptr<_Tp1>& __rhs)\n+      { return __lhs._M_less(__rhs); }\n+\n+    template <typename _Tp1> friend class weak_ptr;\n+    template <typename _Tp1> friend class shared_ptr;\n+    friend class enable_shared_from_this<_Tp>;\n+\n+    _Tp*       _M_ptr;           // contained pointer\n+    weak_count _M_refcount;      // reference counter\n+\n+  };  // weak_ptr\n+\n+\n+\n+template <typename _Tp>\n+  class enable_shared_from_this\n+  {\n+  protected:\n+\n+    enable_shared_from_this()\n+    { }\n+\n+    enable_shared_from_this(const enable_shared_from_this&)\n+    { }\n+\n+    enable_shared_from_this&\n+    operator=(const enable_shared_from_this&)\n+    { return *this; }\n+\n+    ~enable_shared_from_this()\n+    { }\n+\n+  public:\n+\n+    shared_ptr<_Tp>\n+    shared_from_this()\n+    {\n+      shared_ptr<_Tp> p(this->_M_weak_this);\n+      return p;\n+    }\n+\n+    shared_ptr<const _Tp>\n+    shared_from_this() const\n+    {\n+      shared_ptr<const _Tp> p(this->_M_weak_this);\n+      return p;\n+    }\n+\n+  private:\n+    template <typename _Tp1>\n+      void\n+      _M_weak_assign(_Tp1* __p, const shared_count& __n) const\n+      { _M_weak_this._M_assign(__p, __n); }\n+\n+    template <typename _Tp1>\n+      friend void\n+      __enable_shared_from_this( const shared_count& __pn, const enable_shared_from_this* __pe, const _Tp1* __px)\n+      {\n+        if(__pe != 0)\n+          __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n+      }\n+\n+    mutable weak_ptr<_Tp> _M_weak_this;\n+  };\n+\n+} // namespace tr1\n+\n+/**\n+ *  @brief   std::swap() specialisation for shared_ptr.\n+ *  @relates shared_ptr.\n+ */\n+template <typename _Tp>\n+  inline void\n+  swap(tr1::shared_ptr<_Tp>& __a, tr1::shared_ptr<_Tp>& __b)\n+  {\n+    __a.swap(__b);\n+  }\n+\n+/**\n+ *  @brief   std::swap() specialisation for weak_ptr.\n+ *  @relates weak_ptr.\n+ */\n+template <typename _Tp>\n+  void\n+  swap(tr1::weak_ptr<_Tp>& __a, tr1::weak_ptr<_Tp>& __b)\n+  {\n+    __a.swap(__b);\n+  }\n+\n+} // namespace std\n+\n+#endif"}, {"sha": "93d206e5c290f5f8c048d7df7bca37a0cc48e889", "filename": "libstdc++-v3/include/tr1/memory", "status": "modified", "additions": 4, "deletions": 933, "changes": 937, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b758b22ac2f8033813bb2acb3a036083af299bf5/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b758b22ac2f8033813bb2acb3a036083af299bf5/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory?ref=b758b22ac2f8033813bb2acb3a036083af299bf5", "patch": "@@ -27,19 +27,6 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-//  boost/shared_count.hpp\n-//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n-\n-//  shared_ptr.hpp\n-//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.\n-//  Copyright (c) 2001, 2002, 2003 Peter Dimov\n-\n-//  weak_ptr.hpp\n-//  Copyright (c) 2001, 2002, 2003 Peter Dimov\n-\n-//  enable_shared_from_this.hpp\n-//  Copyright (c) 2002 Peter Dimov\n-\n #ifndef _TR1_MEMORY\n #define _TR1_MEMORY 1\n \n@@ -49,931 +36,15 @@\n #include <new>              // std::bad_alloc\n #include <typeinfo>         // std::type_info in get_deleter\n #include <cstddef>          // std::size_t\n-#include <algorithm>        // for std::swap\n-#include <iosfwd>           // for std::basic_ostream\n-#include <cstdlib>          // for std::abort\n+#include <algorithm>        // std::swap\n+#include <iosfwd>           // std::basic_ostream\n+#include <cstdlib>          // std::abort\n \n #include <bits/gthr.h>\n #include <bits/atomicity.h>\n #include <bits/functexcept.h>\n #include <debug/debug.h>\n \n-// namespace std::tr1\n-namespace std\n-{\n-namespace tr1\n-{\n-\n-class bad_weak_ptr : public std::exception\n-{\n-public:\n-\n-  virtual char const* what() const throw()\n-  {\n-    return \"tr1::bad_weak_ptr\";\n-  }\n-};\n-\n-// Helper for exception objects in <tr1/memory>\n-// TODO this should be defined in a different file.\n-inline void\n-__throw_bad_weak_ptr()\n-{\n-#if __EXCEPTIONS\n-  throw bad_weak_ptr();\n-#else\n-  std::abort();\n-#endif\n-}\n-\n-\n-template <typename _Tp>\n-  struct _Sp_deleter\n-  {\n-    typedef void result_type;\n-    typedef _Tp* argument_type;\n-\n-    void\n-    operator()(_Tp* p) const\n-    { delete p; }\n-  };\n-\n-\n-class _Sp_counted_base\n-{\n-public:\n-\n-  _Sp_counted_base()\n-  : _M_use_count(1), _M_weak_count(1)\n-  { }\n-\n-  virtual\n-  ~_Sp_counted_base() // nothrow\n-  { }\n-\n-  // dispose() is called when _M_use_count drops to zero, to release\n-  // the resources managed by *this.\n-  virtual void\n-  dispose() = 0; // nothrow\n-\n-  // destroy() is called when _M_weak_count drops to zero.\n-  virtual void\n-  destroy() // nothrow\n-  {\n-    delete this;\n-  }\n-\n-  virtual void*\n-  get_deleter(const std::type_info&) = 0;\n-\n-  void\n-  add_ref_copy()\n-  {\n-    __gnu_cxx::__atomic_add(&_M_use_count, 1);\n-  }\n-\n-  void\n-  add_ref_lock()\n-  {\n-    if (_M_use_count <= 0) // TODO not yet MT safe XXX\n-    {\n-      __throw_bad_weak_ptr();\n-    }\n-    __gnu_cxx::__atomic_add(&_M_use_count, 1);\n-  }\n-\n-  void\n-  release() // nothrow\n-  {\n-    if (__gnu_cxx::__exchange_and_add(&_M_use_count, -1) <= 1)\n-    {\n-      dispose();\n-      weak_release();\n-    }\n-  }\n-\n-  void\n-  weak_add_ref() // nothrow\n-  {\n-    __gnu_cxx::__atomic_add(&_M_weak_count, 1);\n-  }\n-\n-  void\n-  weak_release() // nothrow\n-  {\n-    if (__gnu_cxx::__exchange_and_add(&_M_weak_count, -1) <= 1)\n-    {\n-      destroy();\n-    }\n-  }\n-\n-  long\n-  use_count() const // nothrow\n-  {\n-    return _M_use_count;  // XXX is this MT safe?\n-  }\n-\n-private:\n-\n-  _Sp_counted_base(_Sp_counted_base const&);\n-  _Sp_counted_base& operator= (_Sp_counted_base const&);\n-\n-  _Atomic_word _M_use_count;        // #shared\n-  _Atomic_word _M_weak_count;       // #weak + (#shared != 0)\n-};\n-\n-template <typename _Ptr, typename _Deleter>\n-class _Sp_counted_base_impl : public _Sp_counted_base\n-{\n-public:\n-\n-  /**\n-   *  @brief   \n-   *  @pre     d(p) must not throw.\n-   */\n-  _Sp_counted_base_impl(_Ptr __p, _Deleter __d)\n-  : _M_ptr(__p), _M_del(__d)\n-  { }\n-\n-  virtual void\n-  dispose() // nothrow\n-  {\n-    _M_del(_M_ptr);\n-  }\n-\n-  virtual void*\n-  get_deleter(const std::type_info& __ti)\n-  {\n-    return __ti == typeid(_Deleter) ? &_M_del : 0;\n-  }\n-\n-private:\n-  _Sp_counted_base_impl(const _Sp_counted_base_impl&);\n-  _Sp_counted_base_impl& operator=(const _Sp_counted_base_impl&);\n-\n-  _Ptr     _M_ptr; // copy constructor must not throw\n-  _Deleter _M_del; // copy constructor must not throw\n-};\n-\n-class weak_count;\n-\n-class shared_count\n-{\n-private:\n-\n-  _Sp_counted_base* _M_pi;\n-\n-  friend class weak_count;\n-\n-public:\n-\n-  shared_count()\n-  : _M_pi(0) // nothrow\n-  { }\n-\n-  template <typename _Ptr, typename _Deleter>\n-    shared_count(_Ptr __p, _Deleter __d)\n-    : _M_pi(0)\n-    {\n-      try\n-      {\n-        _M_pi = new _Sp_counted_base_impl<_Ptr, _Deleter>(__p, __d);\n-      }\n-      catch(...)\n-      {\n-        __d(__p); // delete __p\n-        __throw_exception_again;\n-      }\n-    }\n-\n-  // auto_ptr<_Tp> is special cased to provide the strong guarantee\n-\n-  template <typename _Tp>\n-    explicit shared_count(std::auto_ptr<_Tp>& __r)\n-    : _M_pi(new _Sp_counted_base_impl<_Tp*,_Sp_deleter<_Tp> >(\n-            __r.get(), _Sp_deleter<_Tp>()\n-            ))\n-    { __r.release(); }\n-\n-  // throws bad_weak_ptr when __r.use_count() == 0\n-  explicit shared_count(const weak_count& __r);\n-\n-  ~shared_count() // nothrow\n-  {\n-    if (_M_pi != 0)\n-      _M_pi->release();\n-  }\n-\n-  shared_count(const shared_count& __r)\n-  : _M_pi(__r._M_pi) // nothrow\n-  {\n-    if (_M_pi != 0)\n-      _M_pi->add_ref_copy();\n-  }\n-\n-  shared_count&\n-  operator=(const shared_count& __r) // nothrow\n-  {\n-    _Sp_counted_base* __tmp = __r._M_pi;\n-\n-    if(__tmp != _M_pi)\n-    {\n-      if(__tmp != 0)\n-        __tmp->add_ref_copy();\n-      if(_M_pi != 0)\n-        _M_pi->release();\n-      _M_pi = __tmp;\n-    }\n-    return *this;\n-  }\n-\n-  void swap(shared_count& __r) // nothrow\n-  {\n-    _Sp_counted_base* __tmp = __r._M_pi;\n-    __r._M_pi = _M_pi;\n-    _M_pi = __tmp;\n-  }\n-\n-  long\n-  use_count() const // nothrow\n-  { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n-\n-  bool\n-  unique() const // nothrow\n-  { return this->use_count() == 1; }\n-\n-  friend inline bool\n-  operator==(const shared_count& __a, const shared_count& __b)\n-  { return __a._M_pi == __b._M_pi; }\n-\n-  friend inline bool\n-  operator<(const shared_count& __a, const shared_count& __b)\n-  { return std::less<_Sp_counted_base*>()(__a._M_pi, __b._M_pi); }\n-\n-  void*\n-  get_deleter(const std::type_info& __ti) const\n-  { return _M_pi ? _M_pi->get_deleter(__ti) : 0; }\n-};\n-\n-\n-class weak_count\n-{\n-private:\n-\n-  _Sp_counted_base * _M_pi;\n-\n-  friend class shared_count;\n-\n-public:\n-\n-  weak_count()\n-  : _M_pi(0) // nothrow\n-  { }\n-\n-  weak_count(const shared_count& __r)\n-  : _M_pi(__r._M_pi) // nothrow\n-  {\n-    if (_M_pi != 0)\n-      _M_pi->weak_add_ref();\n-  }\n-\n-  weak_count(const weak_count& __r)\n-  : _M_pi(__r._M_pi) // nothrow\n-  {\n-    if (_M_pi != 0)\n-      _M_pi->weak_add_ref();\n-  }\n-\n-  ~weak_count() // nothrow\n-  {\n-    if (_M_pi != 0)\n-      _M_pi->weak_release();\n-  }\n-\n-  weak_count&\n-  operator=(const shared_count& __r) // nothrow\n-  {\n-    _Sp_counted_base* __tmp = __r._M_pi;\n-    if (__tmp != 0)\n-      __tmp->weak_add_ref();\n-    if (_M_pi != 0)\n-      _M_pi->weak_release();\n-    _M_pi = __tmp;\n-\n-    return *this;\n-  }\n-\n-  weak_count&\n-  operator=(const weak_count& __r) // nothrow\n-  {\n-    _Sp_counted_base * __tmp = __r._M_pi;\n-    if (__tmp != 0)\n-      __tmp->weak_add_ref();\n-    if (_M_pi != 0)\n-      _M_pi->weak_release();\n-    _M_pi = __tmp;\n-\n-    return *this;\n-  }\n-\n-  void\n-  swap(weak_count& __r) // nothrow\n-  {\n-    _Sp_counted_base * __tmp = __r._M_pi;\n-    __r._M_pi = _M_pi;\n-    _M_pi = __tmp;\n-  }\n-\n-  long\n-  use_count() const // nothrow\n-  { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n-\n-  friend inline bool\n-  operator==(const weak_count& __a, const weak_count& __b)\n-  { return __a._M_pi == __b._M_pi; }\n-\n-  friend inline bool\n-  operator<(const weak_count& __a, const weak_count& __b)\n-  { return std::less<_Sp_counted_base*>()(__a._M_pi, __b._M_pi); }\n-};\n-\n-inline\n-shared_count::shared_count(const weak_count& __r)\n-: _M_pi(__r._M_pi)\n-{\n-  if (_M_pi != 0)\n-  {\n-    _M_pi->add_ref_lock();\n-  }\n-  else\n-  {\n-    __throw_bad_weak_ptr();\n-  }\n-}\n-\n-// fwd decls\n-template <typename _Tp> class weak_ptr;\n-template <typename _Tp> class enable_shared_from_this;\n-\n-struct __static_cast_tag {};\n-struct __const_cast_tag {};\n-struct __dynamic_cast_tag {};\n-struct __polymorphic_cast_tag {};\n-\n-template<class _Tp> struct shared_ptr_traits\n-{\n-    typedef _Tp & reference;\n-};\n-\n-template<> struct shared_ptr_traits<void>\n-{\n-    typedef void reference;\n-};\n-\n-template<> struct shared_ptr_traits<void const>\n-{\n-    typedef void reference;\n-};\n-\n-template<> struct shared_ptr_traits<void volatile>\n-{\n-    typedef void reference;\n-};\n-\n-template<> struct shared_ptr_traits<void const volatile>\n-{\n-    typedef void reference;\n-};\n-\n-\n-// enable_shared_from_this support\n-\n-// friend of enable_shared_from_this\n-template <typename _Tp1, typename _Tp2>\n-  void\n-  __enable_shared_from_this( const shared_count& __pn,\n-                             const enable_shared_from_this<_Tp1>* __pe,\n-                             const _Tp2* __px );\n-\n-inline void\n-__enable_shared_from_this(const shared_count&, ...)\n-{ }\n-\n-/**\n- *  @class shared_ptr <tr1/memory>\n- *\n- *  A smart pointer with reference-counted copy semantics.\n- *  The object pointed to is deleted when the last shared_ptr pointing to it\n- *  is destroyed or reset.\n- */\n-\n-template <typename _Tp>\n-  class shared_ptr\n-  {\n-    typedef typename shared_ptr_traits<_Tp>::reference _Reference;\n-\n-  public:\n-\n-    typedef _Tp   element_type;\n-\n-    /** @brief  Construct an empty %shared_ptr.\n-     *  @post   use_count()==0 && get()==0\n-     */\n-    shared_ptr() : _M_ptr(0), _M_refcount() // never throws\n-    { }\n-\n-    /** @brief  Construct a %shared_ptr that owns the pointer @a p.\n-     *  @param  p  A pointer that is convertible to element_type*.\n-     *  @post   use_count()==1 && get()==p\n-     *  @throw  std::bad_alloc, in which case @c delete @a p is called.\n-     */\n-    template <typename _Tp1>\n-      explicit shared_ptr(_Tp1* __p)\n-      : _M_ptr(__p), _M_refcount(__p, _Sp_deleter<_Tp1>())\n-      {\n-        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-        // __glibcxx_function_requires(_CompleteConcept<_Tp1*>)\n-\n-        __enable_shared_from_this( _M_refcount, __p, __p );\n-      }\n-\n-    //\n-    // Requirements: D's copy constructor and destructor must not throw\n-    //\n-    // shared_ptr will release p by calling d(p)\n-    //\n-    /** @brief  Construct a %shared_ptr that owns the pointer @a p\n-     *          and the deleter @a d.\n-     *  @param  p  A pointer.\n-     *  @param  d  A deleter.\n-     *  @post   use_count()==1 && get()==p\n-     *  @throw  std::bad_alloc, in which case @a d(p) is called.\n-     */\n-    template <typename _Tp1, typename _Deleter>\n-      shared_ptr(_Tp1* __p, _Deleter __d)\n-      : _M_ptr(__p), _M_refcount(__p, __d)\n-      {\n-        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-        // TODO requires D is CopyConstructible and d(p) well-formed\n-\n-        __enable_shared_from_this( _M_refcount, __p, __p );\n-      }\n-\n-    //  generated copy constructor, assignment, destructor are fine.\n-\n-    /** @brief  If @a r is empty, constructs an empty %shared_ptr; otherwise\n-     *          construct a %shared_ptr that shares ownership with @a r.\n-     *  @param  r  A %shared_ptr.\n-     *  @post   get()==r.get() && use_count()==r.use_count()\n-     *  @throw  std::bad_alloc, in which case \n-     */\n-    template <typename _Tp1>\n-      shared_ptr(const shared_ptr<_Tp1>& __r)\n-      : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n-      {\n-        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-      }\n-\n-    /** @brief  Constructs a %shared_ptr that shares ownership with @a r\n-     *          and stores a copy of the pointer stored in @a r.\n-     *  @param  r  A weak_ptr.\n-     *  @post   use_count()==r.use_count()\n-     *  @throw  bad_weak_ptr when r.expired(),\n-     *          in which case the constructor has no effect.\n-     */\n-    template <typename _Tp1>\n-      explicit shared_ptr(const weak_ptr<_Tp1>& __r)\n-      : _M_refcount(__r._M_refcount) // may throw\n-      {\n-        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-        // it is now safe to copy r__._M_ptr, as _M_refcount(__r._M_refcount)\n-        // did not throw\n-        _M_ptr = __r._M_ptr;\n-      }\n-\n-    /**\n-     * @post use_count()==1 and r.get()==0\n-     */\n-    template <typename _Tp1>\n-      explicit shared_ptr(std::auto_ptr<_Tp1>& __r)\n-      : _M_ptr(__r.get()), _M_refcount()\n-      {\n-        // TODO requires r.release() convertible to _Tp*, Tp1 is complete,\n-        // delete r.release() well-formed\n-        _Tp1 * __tmp = __r.get();\n-        _M_refcount = shared_count(__r);\n-\n-        __enable_shared_from_this( _M_refcount, __tmp, __tmp );\n-      }\n-\n-    template <typename _Tp1>\n-      shared_ptr(const shared_ptr<_Tp1>& __r, __static_cast_tag)\n-      : _M_ptr(static_cast<element_type*>(__r._M_ptr))\n-      , _M_refcount(__r._M_refcount)\n-      { }\n-\n-    template <typename _Tp1>\n-      shared_ptr(const shared_ptr<_Tp1>& __r, __const_cast_tag)\n-      : _M_ptr(const_cast<element_type*>(__r._M_ptr))\n-      , _M_refcount(__r._M_refcount)\n-      { }\n-\n-    template <typename _Tp1>\n-      shared_ptr(const shared_ptr<_Tp1>& __r, __dynamic_cast_tag)\n-      : _M_ptr(dynamic_cast<element_type*>(__r._M_ptr))\n-      , _M_refcount(__r._M_refcount)\n-      {\n-        if (_M_ptr == 0) // need to allocate new counter -- the cast failed\n-        {\n-          _M_refcount = shared_count();\n-        }\n-      }\n-\n-    template <typename _Tp1>\n-      shared_ptr&\n-      operator=(const shared_ptr<_Tp1>& __r) // never throws\n-      {\n-        _M_ptr = __r._M_ptr;\n-        _M_refcount = __r._M_refcount; // shared_count::op= doesn't throw\n-        return *this;\n-      }\n-\n-    template <typename _Tp1>\n-      shared_ptr&\n-      operator=(std::auto_ptr<_Tp1>& __r)\n-      {\n-        shared_ptr(__r).swap(*this);\n-        return *this;\n-      }\n-\n-    void\n-    reset() // never throws\n-    { shared_ptr().swap(*this); }\n-\n-    template <typename _Tp1>\n-      void\n-      reset(_Tp1* __p) // _Tp1 must be complete\n-      {\n-        _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr); // catch self-reset errors\n-        shared_ptr(__p).swap(*this);\n-      }\n-\n-    template <typename _Tp1, typename _Deleter>\n-      void\n-      reset(_Tp1 * __p, _Deleter __d)\n-      { shared_ptr(__p, __d).swap(*this); }\n-\n-    // error to instantiate if _Tp is [cv-qual] void\n-    _Reference\n-    operator*() const // never throws\n-    {\n-      _GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n-      return *_M_ptr;\n-    }\n-\n-    _Tp*\n-    operator->() const // never throws\n-    {\n-      _GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n-      return _M_ptr;\n-    }\n-    \n-    _Tp*\n-    get() const // never throws\n-    { return _M_ptr; }\n-\n-    // implicit conversion to \"bool\"\n-  private:\n-    typedef _Tp* shared_ptr::*__unspecified_bool_type;\n-\n-  public:\n-    operator __unspecified_bool_type() const // never throws\n-    { return _M_ptr == 0 ? 0 : &shared_ptr::_M_ptr; }\n-\n-    bool\n-    unique() const // never throws\n-    { return _M_refcount.unique(); }\n-\n-    long\n-    use_count() const // never throws\n-    { return _M_refcount.use_count(); }\n-\n-    void\n-    swap(shared_ptr<_Tp>& __other) // never throws\n-    {\n-      std::swap(_M_ptr, __other._M_ptr);\n-      _M_refcount.swap(__other._M_refcount);\n-    }\n-\n-  private:\n-    template <typename _Tp1>\n-      bool\n-      _M_less(const shared_ptr<_Tp1>& __rhs) const\n-      { return _M_refcount < __rhs._M_refcount; }\n-\n-    void*\n-    _M_get_deleter(const std::type_info& __ti) const\n-    { return _M_refcount.get_deleter(__ti); }\n-\n-    template <typename _Tp1> friend class shared_ptr;\n-    template <typename _Tp1> friend class weak_ptr;\n-\n-    // friends injected into enclosing namespace and found by ADL:\n-\n-    // get_deleter (experimental)\n-    template <typename _Del>\n-      friend inline _Del*\n-      get_deleter(const shared_ptr& __p)\n-      { return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del))); }\n-\n-    template <typename _Tp1>\n-      friend inline bool\n-      operator==(const shared_ptr& __a, const shared_ptr<_Tp1>& __b)\n-      { return __a.get() == __b.get(); }\n-\n-    template <typename _Tp1>\n-      friend inline bool\n-      operator!=(const shared_ptr& __a, const shared_ptr<_Tp1>& __b)\n-      { return __a.get() != __b.get(); }\n-\n-    template <typename _Tp1>\n-      friend inline bool\n-      operator<(const shared_ptr& __a, const shared_ptr<_Tp1>& __b)\n-      { return __a._M_less(__b); }\n-\n-    _Tp*         _M_ptr;         // contained pointer\n-    shared_count _M_refcount;    // reference counter\n-  };  // shared_ptr\n-\n-// 2.2.3.9 shared_ptr casts\n-\n-/** @warning The seemingly equivalent\n- *           <code>shared_ptr<T>(static_cast<T*>(r.get()))</code>\n- *           will eventually result in undefined behaviour,\n- *           attempting to delete the same object twice.\n- */\n-template <typename _Tp, typename _Tp1>\n-  shared_ptr<_Tp>\n-  static_pointer_cast(const shared_ptr<_Tp1>& __r)\n-  {\n-    return shared_ptr<_Tp>(__r, __static_cast_tag());\n-  }\n-\n-/** @warning The seemingly equivalent\n- *           <code>shared_ptr<T>(const_cast<T*>(r.get()))</code>\n- *           will eventually result in undefined behaviour,\n- *           attempting to delete the same object twice.\n- */\n-template <typename _Tp, typename _Tp1>\n-  shared_ptr<_Tp>\n-  const_pointer_cast(const shared_ptr<_Tp1>& __r)\n-  {\n-    return shared_ptr<_Tp>(__r, __const_cast_tag());\n-  }\n-\n-/** @warning The seemingly equivalent\n- *           <code>shared_ptr<T>(dynamic_cast<T*>(r.get()))</code>\n- *           will eventually result in undefined behaviour,\n- *           attempting to delete the same object twice.\n- */\n-template <typename _Tp, typename _Tp1>\n-  shared_ptr<_Tp>\n-  dynamic_pointer_cast(const shared_ptr<_Tp1>& __r)\n-  {\n-    return shared_ptr<_Tp>(__r, __dynamic_cast_tag());\n-  }\n-\n-// operator<<\n-template <typename _Ch, typename _Tr, typename _Tp>\n-  std::basic_ostream<_Ch,_Tr>&\n-  operator<<(std::basic_ostream<_Ch,_Tr>& __os, const shared_ptr<_Tp>& __p)\n-  {\n-    __os << __p.get();\n-    return __os;\n-  }\n-\n-\n-template <typename _Tp>\n-  class weak_ptr\n-  {\n-  public:\n-\n-    typedef _Tp element_type;\n-\n-    weak_ptr()\n-    : _M_ptr(0), _M_refcount() // never throws\n-    { }\n-\n-  //  generated copy constructor, assignment, destructor are fine\n-\n-  //\n-  //  The \"obvious\" converting constructor implementation:\n-  //\n-  //  template<class Y>\n-  //  weak_ptr(weak_ptr<Y> const & r): _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n-  //  {\n-  //  }\n-  //\n-  //  has a serious problem.\n-  //\n-  //  r._M_ptr may already have been invalidated. The _M_ptr(r._M_ptr)\n-  //  conversion may require access to *r._M_ptr (virtual inheritance).\n-  //\n-  //  It is not possible to avoid spurious access violations since\n-  //  in multithreaded programs r._M_ptr may be invalidated at any point.\n-  //\n-\n-    template <typename _Tp1>\n-      weak_ptr(const weak_ptr<_Tp1>& r)\n-      : _M_refcount(r._M_refcount) // never throws\n-      {\n-        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-        _M_ptr = r.lock().get();\n-      }\n-\n-    template <typename _Tp1>\n-      weak_ptr(const shared_ptr<_Tp1>& r)\n-      : _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n-      {\n-        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-      }\n-\n-    template <typename _Tp1>\n-      weak_ptr&\n-      operator=(const weak_ptr<_Tp1>& r) // never throws\n-      {\n-        _M_ptr = r.lock().get();\n-        _M_refcount = r._M_refcount;\n-        return *this;\n-      }\n-\n-    template <typename _Tp1>\n-      weak_ptr&\n-      operator=(const shared_ptr<_Tp1>& r) // never throws\n-      {\n-        _M_ptr = r._M_ptr;\n-        _M_refcount = r._M_refcount;\n-        return *this;\n-      }\n-\n-    shared_ptr<_Tp>\n-    lock() const // never throws\n-    {\n-#ifdef __GTHREADS\n-\n-      // optimization: avoid throw overhead\n-      if (expired())\n-      {\n-        return shared_ptr<element_type>();\n-      }\n-\n-      try\n-      {\n-        return shared_ptr<element_type>(*this);\n-      }\n-      catch (const bad_weak_ptr&)\n-      {\n-        // Q: how can we get here?\n-        // A: another thread may have invalidated r after the use_count test above.\n-        return shared_ptr<element_type>();\n-      }\n-\n-#else\n-\n-      // optimization: avoid try/catch overhead when single threaded\n-      return expired() ? shared_ptr<element_type>() : shared_ptr<element_type>(*this);\n-\n-#endif\n-    } // XXX MT\n-\n-\n-    long\n-    use_count() const // never throws\n-    { return _M_refcount.use_count(); }\n-\n-    bool\n-    expired() const // never throws\n-    { return _M_refcount.use_count() == 0; }\n-\n-    void\n-    reset() // never throws\n-    { weak_ptr().swap(*this); }\n-\n-    void\n-    swap(weak_ptr& __s) // never throws\n-    {\n-      std::swap(_M_ptr, __s._M_ptr);\n-      _M_refcount.swap(__s._M_refcount);\n-    }\n-\n-  private:\n-\n-    template <typename _Tp1>\n-      bool\n-      _M_less(const weak_ptr<_Tp1>& __rhs) const\n-      { return _M_refcount < __rhs._M_refcount; }\n-\n-    // used by __enable_shared_from_this\n-    void\n-    _M_assign(_Tp* __ptr, const shared_count& __refcount)\n-    {\n-      _M_ptr = __ptr;\n-      _M_refcount = __refcount;\n-    }\n-\n-    // friend injected into namespace and found by ADL\n-\n-    template <typename _Tp1>\n-      friend inline bool\n-      operator<(const weak_ptr& __lhs, const weak_ptr<_Tp1>& __rhs)\n-      { return __lhs._M_less(__rhs); }\n-\n-    template <typename _Tp1> friend class weak_ptr;\n-    template <typename _Tp1> friend class shared_ptr;\n-    friend class enable_shared_from_this<_Tp>;\n-\n-    _Tp*       _M_ptr;           // contained pointer\n-    weak_count _M_refcount;      // reference counter\n-\n-  };  // weak_ptr\n-\n-\n-\n-template <typename _Tp>\n-  class enable_shared_from_this\n-  {\n-  protected:\n-\n-    enable_shared_from_this()\n-    { }\n-\n-    enable_shared_from_this(const enable_shared_from_this&)\n-    { }\n-\n-    enable_shared_from_this&\n-    operator=(const enable_shared_from_this&)\n-    { return *this; }\n-\n-    ~enable_shared_from_this()\n-    { }\n-\n-  public:\n-\n-    shared_ptr<_Tp>\n-    shared_from_this()\n-    {\n-      shared_ptr<_Tp> p(this->_M_weak_this);\n-      return p;\n-    }\n-\n-    shared_ptr<const _Tp>\n-    shared_from_this() const\n-    {\n-      shared_ptr<const _Tp> p(this->_M_weak_this);\n-      return p;\n-    }\n-\n-  private:\n-    template <typename _Tp1>\n-      void\n-      _M_weak_assign(_Tp1* __p, const shared_count& __n) const\n-      { _M_weak_this._M_assign(__p, __n); }\n-\n-    template <typename _Tp1>\n-      friend void\n-      __enable_shared_from_this( const shared_count& __pn, const enable_shared_from_this* __pe, const _Tp1* __px)\n-      {\n-        if(__pe != 0)\n-          __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n-      }\n-\n-    mutable weak_ptr<_Tp> _M_weak_this;\n-  };\n-\n-} // namespace tr1\n-\n-/**\n- *  @brief   std::swap() specialisation for shared_ptr.\n- *  @relates shared_ptr.\n- */\n-template <typename _Tp>\n-  inline void\n-  swap(tr1::shared_ptr<_Tp>& __a, tr1::shared_ptr<_Tp>& __b)\n-  {\n-    __a.swap(__b);\n-  }\n-\n-/**\n- *  @brief   std::swap() specialisation for weak_ptr.\n- *  @relates weak_ptr.\n- */\n-template <typename _Tp>\n-  void\n-  swap(tr1::weak_ptr<_Tp>& __a, tr1::weak_ptr<_Tp>& __b)\n-  {\n-    __a.swap(__b);\n-  }\n-\n-} // namespace std\n+#include <tr1/boost_shared_ptr.h>\n \n #endif"}, {"sha": "ec219066aacc97ed9f371a663a5db526745733e2", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/cons/auto_ptr_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b758b22ac2f8033813bb2acb3a036083af299bf5/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fauto_ptr_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b758b22ac2f8033813bb2acb3a036083af299bf5/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fauto_ptr_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcons%2Fauto_ptr_neg.cc?ref=b758b22ac2f8033813bb2acb3a036083af299bf5", "patch": "@@ -45,6 +45,6 @@ main()\n   test01();\n   return 0;\n }\n-// { dg-error \"shared_ptr\" \"candidates are\" { target *-*-* } 482 }\n+// { dg-error \"shared_ptr\" \"candidates are\" { target *-*-* } 478 }\n \n-// { dg-error \"shared_ptr\" \"\" { target *-*-* } 472 }\n+// { dg-error \"shared_ptr\" \"\" { target *-*-* } 468 }"}]}