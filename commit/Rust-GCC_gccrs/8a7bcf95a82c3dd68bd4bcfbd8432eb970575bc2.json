{"sha": "8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "node_id": "C_kwDOANBUbNoAKDhhN2JjZjk1YTgyYzNkZDY4YmQ0YmNmYmQ4NDMyZWI5NzA1NzViYzI", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-09-20T19:48:52Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-09-23T16:12:41Z"}, "message": "c++: Implement __is_{nothrow_,}convertible [PR106784]\n\nTo improve compile times, the C++ library could use compiler built-ins\nrather than implementing std::is_convertible (and _nothrow) as class\ntemplates.  This patch adds the built-ins.  We already have\n__is_constructible and __is_assignable, and the nothrow forms of those.\n\nMicrosoft (and clang, for compatibility) also provide an alias called\n__is_convertible_to.  I did not add it, but it would be trivial to do\nso.\n\nI noticed that our __is_assignable doesn't implement the \"Access checks\nare performed as if from a context unrelated to either type\" requirement,\ntherefore std::is_assignable / __is_assignable give two different results\nhere:\n\n  class S {\n    operator int();\n    friend void g(); // #1\n  };\n\n  void\n  g ()\n  {\n    // #1 doesn't matter\n    static_assert(std::is_assignable<int&, S>::value, \"\");\n    static_assert(__is_assignable(int&, S), \"\");\n  }\n\nThis is not a problem if __is_assignable is not meant to be used by\nthe users.\n\nThis patch doesn't make libstdc++ use the new built-ins, but I had to\nrename a class otherwise its name would clash with the new built-in.\n\n\tPR c++/106784\n\ngcc/c-family/ChangeLog:\n\n\t* c-common.cc (c_common_reswords): Add __is_convertible and\n\t__is_nothrow_convertible.\n\t* c-common.h (enum rid): Add RID_IS_CONVERTIBLE and\n\tRID_IS_NOTHROW_CONVERTIBLE.\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (diagnose_trait_expr): Handle CPTK_IS_CONVERTIBLE\n\tand CPTK_IS_NOTHROW_CONVERTIBLE.\n\t* cp-objcp-common.cc (names_builtin_p): Handle RID_IS_CONVERTIBLE\n\tRID_IS_NOTHROW_CONVERTIBLE.\n\t* cp-tree.h (enum cp_trait_kind): Add CPTK_IS_CONVERTIBLE and\n\tCPTK_IS_NOTHROW_CONVERTIBLE.\n\t(is_convertible): Declare.\n\t(is_nothrow_convertible): Likewise.\n\t* cxx-pretty-print.cc (pp_cxx_trait_expression): Handle\n\tCPTK_IS_CONVERTIBLE and CPTK_IS_NOTHROW_CONVERTIBLE.\n\t* method.cc (is_convertible): New.\n\t(is_nothrow_convertible): Likewise.\n\t* parser.cc (cp_parser_primary_expression): Handle RID_IS_CONVERTIBLE\n\tand RID_IS_NOTHROW_CONVERTIBLE.\n\t(cp_parser_trait_expr): Likewise.\n\t* semantics.cc (trait_expr_value): Handle CPTK_IS_CONVERTIBLE and\n\tCPTK_IS_NOTHROW_CONVERTIBLE.\n\t(finish_trait_expr): Likewise.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/type_traits: Rename __is_nothrow_convertible to\n\t__is_nothrow_convertible_lib.\n\t* testsuite/20_util/is_nothrow_convertible/value_ext.cc: Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/ext/has-builtin-1.C: Enhance to test __is_convertible and\n\t__is_nothrow_convertible.\n\t* g++.dg/ext/is_convertible1.C: New test.\n\t* g++.dg/ext/is_convertible2.C: New test.\n\t* g++.dg/ext/is_nothrow_convertible1.C: New test.\n\t* g++.dg/ext/is_nothrow_convertible2.C: New test.", "tree": {"sha": "391e7f2aef62a839154be40fd95c7a3ccf3f3c10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/391e7f2aef62a839154be40fd95c7a3ccf3f3c10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d4df630c6cfb1909288a2796ec2f8b9ec4e8486", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d4df630c6cfb1909288a2796ec2f8b9ec4e8486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d4df630c6cfb1909288a2796ec2f8b9ec4e8486"}], "stats": {"total": 688, "additions": 684, "deletions": 4}, "files": [{"sha": "dce3045c9f27a663ed08fef89fbb8a51842fadf2", "filename": "gcc/c-family/c-common.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fc-family%2Fc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fc-family%2Fc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.cc?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -541,6 +541,8 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__is_constructible\", RID_IS_CONSTRUCTIBLE, D_CXXONLY },\n   { \"__is_nothrow_assignable\", RID_IS_NOTHROW_ASSIGNABLE, D_CXXONLY },\n   { \"__is_nothrow_constructible\", RID_IS_NOTHROW_CONSTRUCTIBLE, D_CXXONLY },\n+  { \"__is_convertible\", RID_IS_CONVERTIBLE, D_CXXONLY },\n+  { \"__is_nothrow_convertible\", RID_IS_NOTHROW_CONVERTIBLE, D_CXXONLY },\n   { \"__reference_constructs_from_temporary\", RID_REF_CONSTRUCTS_FROM_TEMPORARY,\n \t\t\t\t\tD_CXXONLY },\n   { \"__reference_converts_from_temporary\", RID_REF_CONVERTS_FROM_TEMPORARY,"}, {"sha": "31397d800299abe31606685f5c2e9d497b631ae2", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -184,6 +184,7 @@ enum rid\n   RID_IS_UNION,                RID_UNDERLYING_TYPE,\n   RID_IS_ASSIGNABLE,           RID_IS_CONSTRUCTIBLE,\n   RID_IS_NOTHROW_ASSIGNABLE,   RID_IS_NOTHROW_CONSTRUCTIBLE,\n+  RID_IS_CONVERTIBLE,\t\tRID_IS_NOTHROW_CONVERTIBLE,\n   RID_REF_CONSTRUCTS_FROM_TEMPORARY,\n   RID_REF_CONVERTS_FROM_TEMPORARY,\n "}, {"sha": "5839bfb4b52c930e16db22fb77685fd0f2d8c865", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -3697,6 +3697,12 @@ diagnose_trait_expr (tree expr, tree args)\n     case CPTK_HAS_UNIQUE_OBJ_REPRESENTATIONS:\n       inform (loc, \"  %qT does not have unique object representations\", t1);\n       break;\n+    case CPTK_IS_CONVERTIBLE:\n+      inform (loc, \"  %qT is not convertible from %qE\", t2, t1);\n+      break;\n+    case CPTK_IS_NOTHROW_CONVERTIBLE:\n+\tinform (loc, \"  %qT is not %<nothrow%> convertible from %qE\", t2, t1);\n+      break;\n     case CPTK_REF_CONSTRUCTS_FROM_TEMPORARY:\n       inform (loc, \"  %qT is not a reference that binds to a temporary \"\n \t      \"object of type %qT (direct-initialization)\", t1, t2);"}, {"sha": "64975699351e8e5aca8cb5389ba0a35762e68506", "filename": "gcc/cp/cp-objcp-common.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fcp%2Fcp-objcp-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fcp%2Fcp-objcp-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.cc?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -463,6 +463,8 @@ names_builtin_p (const char *name)\n     case RID_IS_NOTHROW_ASSIGNABLE:\n     case RID_IS_NOTHROW_CONSTRUCTIBLE:\n     case RID_UNDERLYING_TYPE:\n+    case RID_IS_CONVERTIBLE:\n+    case RID_IS_NOTHROW_CONVERTIBLE:\n     case RID_REF_CONSTRUCTS_FROM_TEMPORARY:\n     case RID_REF_CONVERTS_FROM_TEMPORARY:\n       return true;"}, {"sha": "e4d89207e2af29158929527f4204a94972f31fb3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -1407,6 +1407,8 @@ enum cp_trait_kind\n   CPTK_IS_CONSTRUCTIBLE,\n   CPTK_IS_NOTHROW_ASSIGNABLE,\n   CPTK_IS_NOTHROW_CONSTRUCTIBLE,\n+  CPTK_IS_CONVERTIBLE,\n+  CPTK_IS_NOTHROW_CONVERTIBLE,\n   CPTK_REF_CONSTRUCTS_FROM_TEMPORARY,\n   CPTK_REF_CONVERTS_FROM_TEMPORARY\n };\n@@ -7116,6 +7118,8 @@ extern tree forward_parm\t\t\t(tree);\n extern bool is_trivially_xible\t\t\t(enum tree_code, tree, tree);\n extern bool is_nothrow_xible\t\t\t(enum tree_code, tree, tree);\n extern bool is_xible\t\t\t\t(enum tree_code, tree, tree);\n+extern bool is_convertible\t\t\t(tree, tree);\n+extern bool is_nothrow_convertible\t\t(tree, tree);\n extern bool ref_xes_from_temporary\t\t(tree, tree, bool);\n extern tree get_defaulted_eh_spec\t\t(tree, tsubst_flags_t = tf_warning_or_error);\n extern bool maybe_explain_implicit_delete\t(tree);"}, {"sha": "e18143e39a98556a1981144f46ee9e9b6427d258", "filename": "gcc/cp/cxx-pretty-print.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fcp%2Fcxx-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fcp%2Fcxx-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.cc?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -2696,6 +2696,12 @@ pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)\n     case CPTK_IS_NOTHROW_CONSTRUCTIBLE:\n       pp_cxx_ws_string (pp, \"__is_nothrow_constructible\");\n       break;\n+    case CPTK_IS_CONVERTIBLE:\n+      pp_cxx_ws_string (pp, \"__is_convertible\");\n+      break;\n+    case CPTK_IS_NOTHROW_CONVERTIBLE:\n+      pp_cxx_ws_string (pp, \"__is_nothrow_convertible\");\n+      break;\n     case CPTK_REF_CONSTRUCTS_FROM_TEMPORARY:\n       pp_cxx_ws_string (pp, \"__reference_constructs_from_temporary\");\n       break;"}, {"sha": "c35a59fe56c1fd54679c6cfb357aed1ce701df9f", "filename": "gcc/cp/method.cc", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fcp%2Fmethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fcp%2Fmethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.cc?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -2236,6 +2236,37 @@ ref_xes_from_temporary (tree to, tree from, bool direct_init_p)\n   return ref_conv_binds_directly (to, val, direct_init_p).is_false ();\n }\n \n+/* Return true if FROM can be converted to TO using implicit conversions,\n+   or both FROM and TO are possibly cv-qualified void.  NB: This doesn't\n+   implement the \"Access checks are performed as if from a context unrelated\n+   to either type\" restriction.  */\n+\n+bool\n+is_convertible (tree from, tree to)\n+{\n+  if (VOID_TYPE_P (from) && VOID_TYPE_P (to))\n+    return true;\n+  tree expr = build_stub_object (from);\n+  expr = perform_implicit_conversion (to, expr, tf_none);\n+  if (expr == error_mark_node)\n+    return false;\n+  return !!expr;\n+}\n+\n+/* Like is_convertible, but the conversion is also noexcept.  */\n+\n+bool\n+is_nothrow_convertible (tree from, tree to)\n+{\n+  if (VOID_TYPE_P (from) && VOID_TYPE_P (to))\n+    return true;\n+  tree expr = build_stub_object (from);\n+  expr = perform_implicit_conversion (to, expr, tf_none);\n+  if (expr == NULL_TREE || expr == error_mark_node)\n+    return false;\n+  return expr_noexcept_p (expr, tf_none);\n+}\n+\n /* Categorize various special_function_kinds.  */\n #define SFK_CTOR_P(sfk) \\\n   ((sfk) >= sfk_constructor && (sfk) <= sfk_move_constructor)"}, {"sha": "bb83d1c78f682d72574f41ab474eaebdad0a421e", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -5922,6 +5922,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_IS_CONSTRUCTIBLE:\n \tcase RID_IS_NOTHROW_ASSIGNABLE:\n \tcase RID_IS_NOTHROW_CONSTRUCTIBLE:\n+\tcase RID_IS_CONVERTIBLE:\n+\tcase RID_IS_NOTHROW_CONVERTIBLE:\n \tcase RID_REF_CONSTRUCTS_FROM_TEMPORARY:\n \tcase RID_REF_CONVERTS_FROM_TEMPORARY:\n \t  return cp_parser_trait_expr (parser, token->keyword);\n@@ -11008,6 +11010,14 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n       kind = CPTK_IS_NOTHROW_CONSTRUCTIBLE;\n       variadic = true;\n       break;\n+    case RID_IS_CONVERTIBLE:\n+      kind = CPTK_IS_CONVERTIBLE;\n+      binary = true;\n+      break;\n+    case RID_IS_NOTHROW_CONVERTIBLE:\n+      kind = CPTK_IS_NOTHROW_CONVERTIBLE;\n+      binary = true;\n+      break;\n     case RID_REF_CONSTRUCTS_FROM_TEMPORARY:\n       kind = CPTK_REF_CONSTRUCTS_FROM_TEMPORARY;\n       binary = true;"}, {"sha": "92fc795df400787db1b638420fda2e409e5151e6", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -12044,6 +12044,12 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n     case CPTK_IS_NOTHROW_CONSTRUCTIBLE:\n       return is_nothrow_xible (INIT_EXPR, type1, type2);\n \n+    case CPTK_IS_CONVERTIBLE:\n+      return is_convertible (type1, type2);\n+\n+    case CPTK_IS_NOTHROW_CONVERTIBLE:\n+      return is_nothrow_convertible (type1, type2);\n+\n     case CPTK_REF_CONSTRUCTS_FROM_TEMPORARY:\n       return ref_xes_from_temporary (type1, type2, /*direct_init=*/true);\n \n@@ -12165,6 +12171,8 @@ finish_trait_expr (location_t loc, cp_trait_kind kind, tree type1, tree type2)\n     case CPTK_IS_TRIVIALLY_CONSTRUCTIBLE:\n     case CPTK_IS_NOTHROW_ASSIGNABLE:\n     case CPTK_IS_NOTHROW_CONSTRUCTIBLE:\n+    case CPTK_IS_CONVERTIBLE:\n+    case CPTK_IS_NOTHROW_CONVERTIBLE:\n     case CPTK_REF_CONSTRUCTS_FROM_TEMPORARY:\n     case CPTK_REF_CONVERTS_FROM_TEMPORARY:\n       if (!check_trait_type (type1)"}, {"sha": "17dabf648cff4b213fe42aabc2ded306598c67b3", "filename": "gcc/testsuite/g++.dg/ext/has-builtin-1.C", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas-builtin-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas-builtin-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas-builtin-1.C?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -131,3 +131,9 @@\n #if !__has_builtin (__builtin_is_pointer_interconvertible_with_class)\n # error \"__has_builtin (__builtin_is_pointer_interconvertible_with_class) failed\"\n #endif\n+#if !__has_builtin (__is_convertible)\n+# error \"__has_builtin (__is_convertible) failed\"\n+#endif\n+#if !__has_builtin (__is_nothrow_convertible)\n+# error \"__has_builtin (__is_nothrow_convertible) failed\"\n+#endif"}, {"sha": "2e72945bceb1d51eea0d9b080fafb6174a738396", "filename": "gcc/testsuite/g++.dg/ext/is_convertible1.C", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_convertible1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_convertible1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_convertible1.C?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -0,0 +1,269 @@\n+// PR c++/106784\n+// { dg-do compile { target c++11 } }\n+\n+#define SA(X) static_assert((X),#X)\n+\n+template<typename From, typename To>\n+struct is_convertible {\n+  static const bool value = __is_convertible(From, To);\n+};\n+\n+struct from_int {\n+  from_int(int);\n+};\n+\n+struct from_charp {\n+  from_charp(const char *);\n+};\n+\n+struct to_int {\n+  operator int();\n+};\n+\n+typedef int Fn(int);\n+typedef char Arr[10];\n+enum E { XYZZY };\n+\n+SA(!__is_convertible(int, void));\n+SA(__is_convertible(int, int));\n+SA(__is_convertible(int, from_int));\n+SA(__is_convertible(long, from_int));\n+SA(__is_convertible(double, from_int));\n+SA(__is_convertible(const int, from_int));\n+SA(__is_convertible(const int&, from_int));\n+SA(__is_convertible(to_int, int));\n+SA(__is_convertible(to_int, const int&));\n+SA(__is_convertible(to_int, long));\n+SA(!__is_convertible(to_int, int&));\n+SA(!__is_convertible(to_int, from_int));\n+SA(!__is_convertible(int, Fn));\n+SA(!__is_convertible(int, Fn*));\n+SA(!__is_convertible(int, Fn&));\n+SA(!__is_convertible(int, Arr));\n+SA(!__is_convertible(int, Arr&));\n+SA(!__is_convertible(int, int&));\n+SA(__is_convertible(int, const int&));\n+SA(!__is_convertible(const int, int&));\n+SA(__is_convertible(const int, const int&));\n+SA(!__is_convertible(int, int*));\n+\n+SA(!__is_convertible(int, E));\n+SA(__is_convertible(E, int));\n+\n+SA(__is_convertible(int&, int));\n+SA(__is_convertible(int&, int&));\n+SA(__is_convertible(int&, const int&));\n+SA(!__is_convertible(const int&, int&));\n+SA(__is_convertible(const int&, const int&));\n+SA(!__is_convertible(int&, int*));\n+SA(!__is_convertible(int&, void));\n+SA(!__is_convertible(int&, Fn));\n+SA(!__is_convertible(int&, Fn*));\n+SA(!__is_convertible(int&, Fn&));\n+SA(!__is_convertible(int&, Arr));\n+SA(!__is_convertible(int&, Arr&));\n+\n+SA(!__is_convertible(int*, int));\n+SA(!__is_convertible(int*, int&));\n+SA(!__is_convertible(int*, void));\n+SA(__is_convertible(int*, int*));\n+SA(__is_convertible(int*, const int*));\n+SA(!__is_convertible(const int*, int*));\n+SA(__is_convertible(const int*, const int*));\n+SA(!__is_convertible(int*, Fn));\n+SA(!__is_convertible(int*, Fn*));\n+SA(!__is_convertible(int*, Fn&));\n+SA(!__is_convertible(int*, Arr));\n+SA(!__is_convertible(int*, Arr&));\n+SA(!__is_convertible(int*, float*));\n+\n+SA(__is_convertible(void, void));\n+SA(!__is_convertible(void, char));\n+SA(!__is_convertible(void, char&));\n+SA(!__is_convertible(void, char*));\n+SA(!__is_convertible(char, void));\n+SA(__is_convertible(const void, void));\n+SA(__is_convertible(void, const void));\n+SA(__is_convertible(const void, const void));\n+SA(!__is_convertible(void, Fn));\n+SA(!__is_convertible(void, Fn&));\n+SA(!__is_convertible(void, Fn*));\n+SA(!__is_convertible(void, Arr));\n+SA(!__is_convertible(void, Arr&));\n+\n+SA(!__is_convertible(Fn, void));\n+SA(!__is_convertible(Fn, Fn));\n+SA(__is_convertible(Fn, Fn*));\n+SA(__is_convertible(Fn, Fn&));\n+SA(!__is_convertible(int(int), int(int)));\n+SA(__is_convertible(int(int), int(&)(int)));\n+SA(__is_convertible(int(int), int(&&)(int)));\n+SA(__is_convertible(int(int), int(*)(int)));\n+SA(__is_convertible(int(int), int(*const)(int)));\n+SA(!__is_convertible(int(int), char));\n+SA(!__is_convertible(int(int), char*));\n+SA(!__is_convertible(int(int), char&));\n+\n+SA(!__is_convertible(Fn&, void));\n+SA(!__is_convertible(Fn&, Fn));\n+SA(__is_convertible(Fn&, Fn&));\n+SA(__is_convertible(Fn&, Fn*));\n+SA(!__is_convertible(Fn&, Arr));\n+SA(!__is_convertible(Fn&, Arr&));\n+SA(!__is_convertible(Fn&, char));\n+SA(!__is_convertible(Fn&, char&));\n+SA(!__is_convertible(Fn&, char*));\n+\n+SA(!__is_convertible(Fn*, void));\n+SA(!__is_convertible(Fn*, Fn));\n+SA(!__is_convertible(Fn*, Fn&));\n+SA(__is_convertible(Fn*, Fn*));\n+SA(!__is_convertible(Fn*, Arr));\n+SA(!__is_convertible(Fn*, Arr&));\n+SA(!__is_convertible(Fn*, char));\n+SA(!__is_convertible(Fn*, char&));\n+SA(!__is_convertible(Fn*, char*));\n+\n+SA(!__is_convertible(Arr, void));\n+SA(!__is_convertible(Arr, Fn));\n+SA(!__is_convertible(Arr, Fn*));\n+SA(!__is_convertible(Arr, Fn&));\n+SA(!__is_convertible(Arr, Arr));\n+SA(!__is_convertible(Arr, Arr&));\n+SA(__is_convertible(Arr, const Arr&));\n+SA(!__is_convertible(Arr, volatile Arr&));\n+SA(!__is_convertible(Arr, const volatile Arr&));\n+SA(!__is_convertible(const Arr, Arr&));\n+SA(__is_convertible(const Arr, const Arr&));\n+SA(__is_convertible(Arr, Arr&&));\n+SA(__is_convertible(Arr, const Arr&&));\n+SA(__is_convertible(Arr, volatile Arr&&));\n+SA(__is_convertible(Arr, const volatile Arr&&));\n+SA(__is_convertible(const Arr, const Arr&&));\n+SA(!__is_convertible(Arr&, Arr&&));\n+SA(!__is_convertible(Arr&&, Arr&));\n+SA(!__is_convertible(Arr, char));\n+SA(__is_convertible(Arr, char*));\n+SA(__is_convertible(Arr, const char*));\n+SA(!__is_convertible(Arr, char&));\n+SA(!__is_convertible(const Arr, char*));\n+SA(__is_convertible(const Arr, const char*));\n+SA(!__is_convertible(int, int[1]));\n+SA(!__is_convertible(int[1], int[1]));\n+SA(!__is_convertible(int[1], int(&)[1]));\n+SA(__is_convertible(int(&)[1], int(&)[1]));\n+SA(__is_convertible(int(&)[1], const int(&)[1]));\n+SA(!__is_convertible(const int(&)[1], int(&)[1]));\n+SA(!__is_convertible(int[1][1], int*));\n+SA(!__is_convertible(int[][1], int*));\n+\n+SA(!__is_convertible(Arr&, void));\n+SA(!__is_convertible(Arr&, Fn));\n+SA(!__is_convertible(Arr&, Fn*));\n+SA(!__is_convertible(Arr&, Fn&));\n+SA(!__is_convertible(Arr&, Arr));\n+SA(__is_convertible(Arr&, Arr&));\n+SA(__is_convertible(Arr&, const Arr&));\n+SA(!__is_convertible(const Arr&, Arr&));\n+SA(__is_convertible(const Arr&, const Arr&));\n+SA(!__is_convertible(Arr&, char));\n+SA(__is_convertible(Arr&, char*));\n+SA(__is_convertible(Arr&, const char*));\n+SA(!__is_convertible(Arr&, char&));\n+SA(!__is_convertible(const Arr&, char*));\n+SA(__is_convertible(const Arr&, const char*));\n+SA(__is_convertible(Arr, from_charp));\n+SA(__is_convertible(Arr&, from_charp));\n+\n+struct B { };\n+struct D : B { };\n+\n+SA(__is_convertible(D, B));\n+SA(__is_convertible(D*, B*));\n+SA(__is_convertible(D&, B&));\n+SA(!__is_convertible(B, D));\n+SA(!__is_convertible(B*, D*));\n+SA(!__is_convertible(B&, D&));\n+\n+/* These are taken from LLVM's test/SemaCXX/type-traits.cpp.  */\n+\n+struct I {\n+  int i;\n+  I(int _i) : i(_i) { }\n+  operator int() const {\n+    return i;\n+  }\n+};\n+\n+struct F\n+{\n+  float f;\n+  F(float _f) : f(_f) {}\n+  F(const I& obj)\n+    : f(static_cast<float>(obj.i)) {}\n+  operator float() const {\n+    return f;\n+  }\n+  operator I() const {\n+    return I(static_cast<int>(f));\n+  }\n+};\n+\n+SA(__is_convertible(I, I));\n+SA(__is_convertible(I, const I));\n+SA(__is_convertible(I, int));\n+SA(__is_convertible(int, I));\n+SA(__is_convertible(I, F));\n+SA(__is_convertible(F, I));\n+SA(__is_convertible(F, float));\n+SA(__is_convertible(float, F));\n+\n+template<typename>\n+struct X {\n+  template<typename U> X(const X<U>&);\n+};\n+\n+SA(__is_convertible(X<int>, X<float>));\n+SA(__is_convertible(X<float>, X<int>));\n+\n+struct Abstract {\n+  virtual void f() = 0;\n+};\n+\n+SA(!__is_convertible(Abstract, Abstract));\n+\n+class hidden {\n+  hidden(const hidden&);\n+  friend void test ();\n+};\n+\n+SA(__is_convertible(hidden&, hidden&));\n+SA(__is_convertible(hidden&, const hidden&));\n+SA(__is_convertible(hidden&, volatile hidden&));\n+SA(__is_convertible(hidden&, const volatile hidden&));\n+SA(__is_convertible(const hidden&, const hidden&));\n+SA(__is_convertible(const hidden&, const volatile hidden&));\n+SA(__is_convertible(volatile hidden&, const volatile hidden&));\n+SA(__is_convertible(const volatile hidden&, const volatile hidden&));\n+SA(!__is_convertible(const hidden&, hidden&));\n+\n+void\n+test ()\n+{\n+  /* __is_convertible(hidden, hidden) should be false despite the\n+     friend declaration above, because \"Access checks are performed\n+     as if from a context unrelated to either type\", but we don't\n+     implement that for the built-in (std::is_convertible works as\n+     expected).  This is the case for __is_assignable as well.  */\n+  //SA(!__is_convertible(hidden, hidden));\n+}\n+\n+void\n+test2 ()\n+{\n+  struct X { };\n+  struct Y {\n+    explicit Y(X); // not viable for implicit conversions\n+  };\n+  SA(!__is_convertible(X, Y));\n+}"}, {"sha": "9b46e2643793e3541d141cccfd8b983b35f9b597", "filename": "gcc/testsuite/g++.dg/ext/is_convertible2.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_convertible2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_convertible2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_convertible2.C?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -0,0 +1,46 @@\n+// PR c++/106784\n+// { dg-do compile { target c++20 } }\n+// Adapted from <https://en.cppreference.com/w/cpp/types/is_convertible>.\n+\n+#include <string>\n+#include <string_view>\n+\n+#define SA(X) static_assert((X),#X)\n+\n+class E { public: template<class T> E(T&&) { } };\n+\n+int main()\n+{\n+    class A {};\n+    class B : public A {};\n+    class C {};\n+    class D { public: operator C() { return c; }  C c; };\n+\n+    SA(__is_convertible(B*, A*));\n+    SA(!__is_convertible(A*, B*));\n+    SA(__is_convertible(D, C));\n+    SA(!__is_convertible(B*, C*));\n+    SA(__is_convertible(A, E));\n+\n+    using std::operator \"\" s, std::operator \"\" sv;\n+\n+    auto stringify = []<typename T>(T x) {\n+        if constexpr (std::is_convertible_v<T, std::string> or\n+                      std::is_convertible_v<T, std::string_view>) {\n+            return x;\n+        } else {\n+            return std::to_string(x);\n+        }\n+    };\n+\n+    const char* three = \"three\";\n+\n+    SA(!__is_convertible(std::string_view, std::string));\n+    SA(__is_convertible(std::string, std::string_view));\n+\n+    auto s1 = stringify(\"one\"s);\n+    auto s2 = stringify(\"two\"sv);\n+    auto s3 = stringify(three);\n+    auto s4 = stringify(42);\n+    auto s5 = stringify(42.);\n+}"}, {"sha": "bb7243e4611006489a942aefaea282333901874e", "filename": "gcc/testsuite/g++.dg/ext/is_nothrow_convertible1.C", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_nothrow_convertible1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_nothrow_convertible1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_nothrow_convertible1.C?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -0,0 +1,270 @@\n+// PR c++/106784\n+// { dg-do compile { target c++11 } }\n+// Like is_convertible1.C, but conversion functions are made noexcept.\n+\n+#define SA(X) static_assert((X),#X)\n+\n+template<typename From, typename To>\n+struct is_nothrow_convertible {\n+  static const bool value = __is_nothrow_convertible(From, To);\n+};\n+\n+struct from_int {\n+  from_int(int) noexcept;\n+};\n+\n+struct from_charp {\n+  from_charp(const char *) noexcept;\n+};\n+\n+struct to_int {\n+  operator int() noexcept;\n+};\n+\n+typedef int Fn(int);\n+typedef char Arr[10];\n+enum E { XYZZY };\n+\n+SA(!__is_nothrow_convertible(int, void));\n+SA(__is_nothrow_convertible(int, int));\n+SA(__is_nothrow_convertible(int, from_int));\n+SA(__is_nothrow_convertible(long, from_int));\n+SA(__is_nothrow_convertible(double, from_int));\n+SA(__is_nothrow_convertible(const int, from_int));\n+SA(__is_nothrow_convertible(const int&, from_int));\n+SA(__is_nothrow_convertible(to_int, int));\n+SA(__is_nothrow_convertible(to_int, const int&));\n+SA(__is_nothrow_convertible(to_int, long));\n+SA(!__is_nothrow_convertible(to_int, int&));\n+SA(!__is_nothrow_convertible(to_int, from_int));\n+SA(!__is_nothrow_convertible(int, Fn));\n+SA(!__is_nothrow_convertible(int, Fn*));\n+SA(!__is_nothrow_convertible(int, Fn&));\n+SA(!__is_nothrow_convertible(int, Arr));\n+SA(!__is_nothrow_convertible(int, Arr&));\n+SA(!__is_nothrow_convertible(int, int&));\n+SA(__is_nothrow_convertible(int, const int&));\n+SA(!__is_nothrow_convertible(const int, int&));\n+SA(__is_nothrow_convertible(const int, const int&));\n+SA(!__is_nothrow_convertible(int, int*));\n+\n+SA(!__is_nothrow_convertible(int, E));\n+SA(__is_nothrow_convertible(E, int));\n+\n+SA(__is_nothrow_convertible(int&, int));\n+SA(__is_nothrow_convertible(int&, int&));\n+SA(__is_nothrow_convertible(int&, const int&));\n+SA(!__is_nothrow_convertible(const int&, int&));\n+SA(__is_nothrow_convertible(const int&, const int&));\n+SA(!__is_nothrow_convertible(int&, int*));\n+SA(!__is_nothrow_convertible(int&, void));\n+SA(!__is_nothrow_convertible(int&, Fn));\n+SA(!__is_nothrow_convertible(int&, Fn*));\n+SA(!__is_nothrow_convertible(int&, Fn&));\n+SA(!__is_nothrow_convertible(int&, Arr));\n+SA(!__is_nothrow_convertible(int&, Arr&));\n+\n+SA(!__is_nothrow_convertible(int*, int));\n+SA(!__is_nothrow_convertible(int*, int&));\n+SA(!__is_nothrow_convertible(int*, void));\n+SA(__is_nothrow_convertible(int*, int*));\n+SA(__is_nothrow_convertible(int*, const int*));\n+SA(!__is_nothrow_convertible(const int*, int*));\n+SA(__is_nothrow_convertible(const int*, const int*));\n+SA(!__is_nothrow_convertible(int*, Fn));\n+SA(!__is_nothrow_convertible(int*, Fn*));\n+SA(!__is_nothrow_convertible(int*, Fn&));\n+SA(!__is_nothrow_convertible(int*, Arr));\n+SA(!__is_nothrow_convertible(int*, Arr&));\n+SA(!__is_nothrow_convertible(int*, float*));\n+\n+SA(__is_nothrow_convertible(void, void));\n+SA(!__is_nothrow_convertible(void, char));\n+SA(!__is_nothrow_convertible(void, char&));\n+SA(!__is_nothrow_convertible(void, char*));\n+SA(!__is_nothrow_convertible(char, void));\n+SA(__is_nothrow_convertible(const void, void));\n+SA(__is_nothrow_convertible(void, const void));\n+SA(__is_nothrow_convertible(const void, const void));\n+SA(!__is_nothrow_convertible(void, Fn));\n+SA(!__is_nothrow_convertible(void, Fn&));\n+SA(!__is_nothrow_convertible(void, Fn*));\n+SA(!__is_nothrow_convertible(void, Arr));\n+SA(!__is_nothrow_convertible(void, Arr&));\n+\n+SA(!__is_nothrow_convertible(Fn, void));\n+SA(!__is_nothrow_convertible(Fn, Fn));\n+SA(__is_nothrow_convertible(Fn, Fn*));\n+SA(__is_nothrow_convertible(Fn, Fn&));\n+SA(!__is_nothrow_convertible(int(int), int(int)));\n+SA(__is_nothrow_convertible(int(int), int(&)(int)));\n+SA(__is_nothrow_convertible(int(int), int(&&)(int)));\n+SA(__is_nothrow_convertible(int(int), int(*)(int)));\n+SA(__is_nothrow_convertible(int(int), int(*const)(int)));\n+SA(!__is_nothrow_convertible(int(int), char));\n+SA(!__is_nothrow_convertible(int(int), char*));\n+SA(!__is_nothrow_convertible(int(int), char&));\n+\n+SA(!__is_nothrow_convertible(Fn&, void));\n+SA(!__is_nothrow_convertible(Fn&, Fn));\n+SA(__is_nothrow_convertible(Fn&, Fn&));\n+SA(__is_nothrow_convertible(Fn&, Fn*));\n+SA(!__is_nothrow_convertible(Fn&, Arr));\n+SA(!__is_nothrow_convertible(Fn&, Arr&));\n+SA(!__is_nothrow_convertible(Fn&, char));\n+SA(!__is_nothrow_convertible(Fn&, char&));\n+SA(!__is_nothrow_convertible(Fn&, char*));\n+\n+SA(!__is_nothrow_convertible(Fn*, void));\n+SA(!__is_nothrow_convertible(Fn*, Fn));\n+SA(!__is_nothrow_convertible(Fn*, Fn&));\n+SA(__is_nothrow_convertible(Fn*, Fn*));\n+SA(!__is_nothrow_convertible(Fn*, Arr));\n+SA(!__is_nothrow_convertible(Fn*, Arr&));\n+SA(!__is_nothrow_convertible(Fn*, char));\n+SA(!__is_nothrow_convertible(Fn*, char&));\n+SA(!__is_nothrow_convertible(Fn*, char*));\n+\n+SA(!__is_nothrow_convertible(Arr, void));\n+SA(!__is_nothrow_convertible(Arr, Fn));\n+SA(!__is_nothrow_convertible(Arr, Fn*));\n+SA(!__is_nothrow_convertible(Arr, Fn&));\n+SA(!__is_nothrow_convertible(Arr, Arr));\n+SA(!__is_nothrow_convertible(Arr, Arr&));\n+SA(__is_nothrow_convertible(Arr, const Arr&));\n+SA(!__is_nothrow_convertible(Arr, volatile Arr&));\n+SA(!__is_nothrow_convertible(Arr, const volatile Arr&));\n+SA(!__is_nothrow_convertible(const Arr, Arr&));\n+SA(__is_nothrow_convertible(const Arr, const Arr&));\n+SA(__is_nothrow_convertible(Arr, Arr&&));\n+SA(__is_nothrow_convertible(Arr, const Arr&&));\n+SA(__is_nothrow_convertible(Arr, volatile Arr&&));\n+SA(__is_nothrow_convertible(Arr, const volatile Arr&&));\n+SA(__is_nothrow_convertible(const Arr, const Arr&&));\n+SA(!__is_nothrow_convertible(Arr&, Arr&&));\n+SA(!__is_nothrow_convertible(Arr&&, Arr&));\n+SA(!__is_nothrow_convertible(Arr, char));\n+SA(__is_nothrow_convertible(Arr, char*));\n+SA(__is_nothrow_convertible(Arr, const char*));\n+SA(!__is_nothrow_convertible(Arr, char&));\n+SA(!__is_nothrow_convertible(const Arr, char*));\n+SA(__is_nothrow_convertible(const Arr, const char*));\n+SA(!__is_nothrow_convertible(int, int[1]));\n+SA(!__is_nothrow_convertible(int[1], int[1]));\n+SA(!__is_nothrow_convertible(int[1], int(&)[1]));\n+SA(__is_nothrow_convertible(int(&)[1], int(&)[1]));\n+SA(__is_nothrow_convertible(int(&)[1], const int(&)[1]));\n+SA(!__is_nothrow_convertible(const int(&)[1], int(&)[1]));\n+SA(!__is_nothrow_convertible(int[1][1], int*));\n+SA(!__is_nothrow_convertible(int[][1], int*));\n+\n+SA(!__is_nothrow_convertible(Arr&, void));\n+SA(!__is_nothrow_convertible(Arr&, Fn));\n+SA(!__is_nothrow_convertible(Arr&, Fn*));\n+SA(!__is_nothrow_convertible(Arr&, Fn&));\n+SA(!__is_nothrow_convertible(Arr&, Arr));\n+SA(__is_nothrow_convertible(Arr&, Arr&));\n+SA(__is_nothrow_convertible(Arr&, const Arr&));\n+SA(!__is_nothrow_convertible(const Arr&, Arr&));\n+SA(__is_nothrow_convertible(const Arr&, const Arr&));\n+SA(!__is_nothrow_convertible(Arr&, char));\n+SA(__is_nothrow_convertible(Arr&, char*));\n+SA(__is_nothrow_convertible(Arr&, const char*));\n+SA(!__is_nothrow_convertible(Arr&, char&));\n+SA(!__is_nothrow_convertible(const Arr&, char*));\n+SA(__is_nothrow_convertible(const Arr&, const char*));\n+SA(__is_nothrow_convertible(Arr, from_charp));\n+SA(__is_nothrow_convertible(Arr&, from_charp));\n+\n+struct B { };\n+struct D : B { };\n+\n+SA(__is_nothrow_convertible(D, B));\n+SA(__is_nothrow_convertible(D*, B*));\n+SA(__is_nothrow_convertible(D&, B&));\n+SA(!__is_nothrow_convertible(B, D));\n+SA(!__is_nothrow_convertible(B*, D*));\n+SA(!__is_nothrow_convertible(B&, D&));\n+\n+/* These are taken from LLVM's test/SemaCXX/type-traits.cpp.  */\n+\n+struct I {\n+  int i;\n+  I(int _i) noexcept : i(_i)  { }\n+  operator int() const noexcept {\n+    return i;\n+  }\n+};\n+\n+struct F\n+{\n+  float f;\n+  F(float _f) noexcept : f(_f) {}\n+  F(const I& obj) noexcept\n+    : f(static_cast<float>(obj.i)) {}\n+  operator float() const noexcept {\n+    return f;\n+  }\n+  operator I() const noexcept {\n+    return I(static_cast<int>(f));\n+  }\n+};\n+\n+SA(__is_nothrow_convertible(I, I));\n+SA(__is_nothrow_convertible(I, const I));\n+SA(__is_nothrow_convertible(I, int));\n+SA(__is_nothrow_convertible(int, I));\n+SA(__is_nothrow_convertible(I, F));\n+SA(__is_nothrow_convertible(F, I));\n+SA(__is_nothrow_convertible(F, float));\n+SA(__is_nothrow_convertible(float, F));\n+\n+template<typename>\n+struct X {\n+  template<typename U> X(const X<U>&) noexcept;\n+};\n+\n+SA(__is_nothrow_convertible(X<int>, X<float>));\n+SA(__is_nothrow_convertible(X<float>, X<int>));\n+\n+struct Abstract {\n+  virtual void f() = 0;\n+};\n+\n+SA(!__is_nothrow_convertible(Abstract, Abstract));\n+\n+class hidden {\n+  hidden(const hidden&);\n+  friend void test ();\n+};\n+\n+SA(__is_nothrow_convertible(hidden&, hidden&));\n+SA(__is_nothrow_convertible(hidden&, const hidden&));\n+SA(__is_nothrow_convertible(hidden&, volatile hidden&));\n+SA(__is_nothrow_convertible(hidden&, const volatile hidden&));\n+SA(__is_nothrow_convertible(const hidden&, const hidden&));\n+SA(__is_nothrow_convertible(const hidden&, const volatile hidden&));\n+SA(__is_nothrow_convertible(volatile hidden&, const volatile hidden&));\n+SA(__is_nothrow_convertible(const volatile hidden&, const volatile hidden&));\n+SA(!__is_nothrow_convertible(const hidden&, hidden&));\n+\n+void\n+test ()\n+{\n+  /* __is_nothrow_convertible(hidden, hidden) should be false despite the\n+     friend declaration above, because \"Access checks are performed\n+     as if from a context unrelated to either type\", but we don't\n+     implement that for the built-in (std::is_convertible works as\n+     expected).  This is the case for __is_assignable as well.  */\n+  //SA(!__is_nothrow_convertible(hidden, hidden));\n+}\n+\n+void\n+test2 ()\n+{\n+  struct X { };\n+  struct Y {\n+    explicit Y(X); // not viable for implicit conversions\n+  };\n+  SA(!__is_nothrow_convertible(X, Y));\n+}"}, {"sha": "aa089173b757f789d43be3830285116018a26748", "filename": "gcc/testsuite/g++.dg/ext/is_nothrow_convertible2.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_nothrow_convertible2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_nothrow_convertible2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_nothrow_convertible2.C?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/106784\n+// { dg-do compile { target c++11 } }\n+\n+#define SA(X) static_assert((X),#X)\n+\n+struct A { };\n+struct B { };\n+\n+struct M {\n+  operator A();\n+  operator B() noexcept;\n+  M(const A&);\n+  M(const B&) noexcept;\n+};\n+\n+SA(!__is_nothrow_convertible(A, M));\n+SA(!__is_nothrow_convertible(M, A));\n+SA(__is_nothrow_convertible(B, M));\n+SA(__is_nothrow_convertible(M, B));"}, {"sha": "1797b9e97f7cd641da1c9b6de5efc28a402728f1", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -1453,7 +1453,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // is_nothrow_convertible for C++11\n   template<typename _From, typename _To>\n-    struct __is_nothrow_convertible\n+    struct __is_nothrow_convertible_lib\n     : public __is_nt_convertible_helper<_From, _To>::type\n     { };\n \n@@ -2999,7 +2999,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct __is_nt_invocable_impl<_Result, _Ret,\n \t\t\t\t  __void_t<typename _Result::type>>\n     : __or_<is_void<_Ret>,\n-\t    __is_nothrow_convertible<typename _Result::type, _Ret>>::type\n+\t    __is_nothrow_convertible_lib<typename _Result::type, _Ret>>::type\n     { };\n   /// @endcond\n "}, {"sha": "d736d2ca260b08003268e5f9d9e07b5249678ed2", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_convertible/value_ext.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_convertible%2Fvalue_ext.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_convertible%2Fvalue_ext.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_convertible%2Fvalue_ext.cc?ref=8a7bcf95a82c3dd68bd4bcfbd8432eb970575bc2", "patch": "@@ -19,10 +19,10 @@\n \n #include <type_traits>\n \n-// Test the non-standard __is_nothrow_convertible trait\n+// Test the non-standard __is_nothrow_convertible_lib trait\n \n template<typename From, typename To>\n-  using is_nothrow_convertible = std::__is_nothrow_convertible<From, To>;\n+  using is_nothrow_convertible = std::__is_nothrow_convertible_lib<From, To>;\n \n #define IS_NT_CONVERTIBLE_DEFINED\n #include \"value.cc\""}]}