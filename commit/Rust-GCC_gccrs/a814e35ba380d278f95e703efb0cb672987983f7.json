{"sha": "a814e35ba380d278f95e703efb0cb672987983f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgxNGUzNWJhMzgwZDI3OGY5NWU3MDNlZmIwY2I2NzI5ODc5ODNmNw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-11-18T15:53:21Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-11-18T15:53:21Z"}, "message": "re PR fortran/83012 (Simply contiguous pointer function not recognized as contiguous)\n\n2017-11-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/83012\n\t* expr.c (gfc_is_simply_contiguous): If a function call through a\n\tclass variable is done through a reference, check the function's\n\tinterface.\n\n2017-11-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/83012\n\t* gfortran.dg/contiguous_5.f90: New test.\n\nFrom-SVN: r254914", "tree": {"sha": "0173a2a632321dfc1979d34f3b3dc35818619d1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0173a2a632321dfc1979d34f3b3dc35818619d1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a814e35ba380d278f95e703efb0cb672987983f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a814e35ba380d278f95e703efb0cb672987983f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a814e35ba380d278f95e703efb0cb672987983f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a814e35ba380d278f95e703efb0cb672987983f7/comments", "author": null, "committer": null, "parents": [{"sha": "cde30fe04594843d87226653c19dbc5e05fad7b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cde30fe04594843d87226653c19dbc5e05fad7b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cde30fe04594843d87226653c19dbc5e05fad7b4"}], "stats": {"total": 62, "additions": 60, "deletions": 2}, "files": [{"sha": "8be551822b1252c9e74afa92edeb4c5519b83368", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a814e35ba380d278f95e703efb0cb672987983f7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a814e35ba380d278f95e703efb0cb672987983f7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a814e35ba380d278f95e703efb0cb672987983f7", "patch": "@@ -1,3 +1,10 @@\n+2017-11-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/83012\n+\t* expr.c (gfc_is_simply_contiguous): If a function call through a\n+\tclass variable is done through a reference, check the function's\n+\tinterface.\n+\n 2017-11-17  Richard Biener  <rguenther@suse.de>\n \n \tPR fortran/83017"}, {"sha": "e1c0caccdc1056c12dfc87687395de4c158e3a48", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a814e35ba380d278f95e703efb0cb672987983f7/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a814e35ba380d278f95e703efb0cb672987983f7/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=a814e35ba380d278f95e703efb0cb672987983f7", "patch": "@@ -5207,8 +5207,31 @@ gfc_is_simply_contiguous (gfc_expr *expr, bool strict, bool permit_element)\n   gfc_symbol *sym;\n \n   if (expr->expr_type == EXPR_FUNCTION)\n-    return expr->value.function.esym\n-\t   ? expr->value.function.esym->result->attr.contiguous : false;\n+    {\n+      if (expr->value.function.esym)\n+\treturn expr->value.function.esym->result->attr.contiguous;\n+      else\n+\t{\n+\t  /* We have to jump through some hoops if this is a vtab entry.  */\n+\t  gfc_symbol *s;\n+\t  gfc_ref *r, *rc;\n+\n+\t  s = expr->symtree->n.sym;\n+\t  if (s->ts.type != BT_CLASS)\n+\t    return false;\n+\t  \n+\t  rc = NULL;\n+\t  for (r = expr->ref; r; r = r->next)\n+\t    if (r->type == REF_COMPONENT)\n+\t      rc = r;\n+\n+\t  if (rc == NULL || rc->u.c.component == NULL\n+\t      || rc->u.c.component->ts.interface == NULL)\n+\t    return false;\n+\n+\t  return rc->u.c.component->ts.interface->attr.contiguous;\n+\t}\n+    }\n   else if (expr->expr_type != EXPR_VARIABLE)\n     return false;\n "}, {"sha": "dabd308f88ae0fa0887698def104ed3e48bdff5f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a814e35ba380d278f95e703efb0cb672987983f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a814e35ba380d278f95e703efb0cb672987983f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a814e35ba380d278f95e703efb0cb672987983f7", "patch": "@@ -1,3 +1,8 @@\n+2017-11-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/83012\n+\t* gfortran.dg/contiguous_5.f90: New test.\n+\n 2017-11-17  Steve Ellcey  <sellcey@cavium.com>\n \n \t* gcc.target/aarch64/fmls.c: New test."}, {"sha": "71d6d0374b56c3d324e4650db3bbbe5c115a08c3", "filename": "gcc/testsuite/gfortran.dg/contiguous_5.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a814e35ba380d278f95e703efb0cb672987983f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a814e35ba380d278f95e703efb0cb672987983f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_5.f90?ref=a814e35ba380d278f95e703efb0cb672987983f7", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+! PR 83012 - this was incorrectly rejected.\n+! Original test case by Neil Carlson.\n+module mod\n+  type :: foo\n+    integer, pointer, contiguous :: p(:)\n+  contains\n+    procedure :: dataptr\n+  end type\n+contains\n+  function dataptr(this) result(dp)\n+    class(foo), intent(in) :: this\n+    integer, pointer, contiguous :: dp(:)\n+    dp => this%p\n+  end function\n+end module\n+\n+subroutine bar(x)\n+  use mod\n+  class(foo) :: x\n+  integer, pointer, contiguous :: p(:)\n+  p => x%dataptr()\n+end subroutine"}]}