{"sha": "ec9c42c9c30b96c45d1ab35b030c3f6c845288e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM5YzQyYzljMzBiOTZjNDVkMWFiMzViMDMwYzNmNmM4NDUyODhlOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-09-02T12:33:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-09-02T12:33:40Z"}, "message": "we dont use these bits of SGI STL\n\nFrom-SVN: r22184", "tree": {"sha": "242d3a2db871050df28d85b59e16b66f6a112dfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/242d3a2db871050df28d85b59e16b66f6a112dfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec9c42c9c30b96c45d1ab35b030c3f6c845288e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec9c42c9c30b96c45d1ab35b030c3f6c845288e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec9c42c9c30b96c45d1ab35b030c3f6c845288e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec9c42c9c30b96c45d1ab35b030c3f6c845288e9/comments", "author": null, "committer": null, "parents": [{"sha": "ff51efd52d404bb0e136496ab40b29528f82ebc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff51efd52d404bb0e136496ab40b29528f82ebc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff51efd52d404bb0e136496ab40b29528f82ebc2"}], "stats": {"total": 2712, "additions": 4, "deletions": 2708}, "files": [{"sha": "44ec2fb60e48067ce1235a9d73daf8dbf933920b", "filename": "libstdc++/stl/char_traits.h", "status": "removed", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff51efd52d404bb0e136496ab40b29528f82ebc2/libstdc%2B%2B%2Fstl%2Fchar_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff51efd52d404bb0e136496ab40b29528f82ebc2/libstdc%2B%2B%2Fstl%2Fchar_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fchar_traits.h?ref=ff51efd52d404bb0e136496ab40b29528f82ebc2", "patch": "@@ -1,135 +0,0 @@\n-/*\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */ \n-\n-#ifndef __SGI_STL_CHAR_TRAITS_H\n-#define __SGI_STL_CHAR_TRAITS_H\n-\n-#include <string.h>\n-#include <wchar.h>\n-\n-__STL_BEGIN_NAMESPACE\n-\n-// Class __char_traits_base.\n-\n-template <class _CharT, class _IntT> struct __char_traits_base {\n-  typedef _CharT char_type;\n-  typedef _IntT int_type;\n-  // typedef streamoff off_type;\n-  // typedef streampos pos_type;\n-  // typedef mbstate_t state_type;\n-\n-  static void assign(char_type& __c1, const char_type& __c2) { __c1 = __c2; }\n-  static bool eq(const _CharT& __c1, const _CharT& __c2) \n-    { return __c1 == __c2; }\n-  static bool lt(const _CharT& __c1, const _CharT& __c2) \n-    { return __c1 < __c2; }\n-\n-  static int compare(const _CharT* __s1, const _CharT* __s2, size_t __n) {\n-    for (size_t __i = 0; __i < __n; ++__i)\n-      if (!eq(__s1[__i], __s2[__i]))\n-        return __s1[__i] < __s2[__i] ? -1 : 1;\n-    return 0;\n-  }\n-\n-  static size_t length(const _CharT* __s) {\n-    const _CharT __null = _CharT();\n-    size_t __i;\n-    for (__i = 0; !eq(__s[__i], __null); ++__i)\n-      {}\n-    return __i;\n-  }\n-\n-  static const _CharT* find(const _CharT* __s, size_t __n, const _CharT& __c)\n-  {\n-    for ( ; __n > 0 ; ++__s, --__n)\n-      if (eq(*__s, __c))\n-        return __s;\n-    return 0;\n-  }\n-\n-  static _CharT* move(_CharT* __s1, const _CharT* __s2, size_t __n) {\n-    memmove(__s1, __s2, __n * sizeof(_CharT));\n-    return __s1;\n-  }\n-    \n-  static _CharT* copy(_CharT* __s1, const _CharT* __s2, size_t __n) {\n-    memcpy(__s1, __s2, __n * sizeof(_CharT));\n-    return __s1;\n-  } \n-\n-  static _CharT* assign(_CharT* __s, size_t __n, _CharT __c) {\n-    for (size_t __i = 0; __i < __n; ++__i)\n-      __s[__i] = __c;\n-    return __s;\n-  }\n-\n-  static int_type not_eof(const int_type& __c) {\n-    return !eq(__c, eof()) ? __c : 0;\n-  }\n-\n-  static char_type to_char_type(const int_type& __c) {\n-    return static_cast<char_type>(__c);\n-  }\n-\n-  static int_type to_int_type(const char_type& __c) {\n-    return static_cast<int_type>(__c);\n-  }\n-\n-  static bool eq_int_type(const int_type& __c1, const int_type& __c2) {\n-    return __c1 == __c2;\n-  }\n-\n-  static int_type eof() {\n-    return static_cast<int_type>(-1);\n-  }\n-};\n-\n-// Generic char_traits class.  Note that this class is provided only\n-//  as a base for explicit specialization; it is unlikely to be useful\n-//  as is for any particular user-defined type.  In particular, it \n-//  *will not work* for a non-POD type.\n-\n-template <class _CharT> struct char_traits\n-  : public __char_traits_base<_CharT, _CharT>\n-{};\n-\n-// Specialization for char.\n-\n-template<> struct char_traits<char> \n-  : public __char_traits_base<char, int>\n-{\n-  static int compare(const char* __s1, const char* __s2, size_t __n) \n-    { return memcmp(__s1, __s2, __n); }\n-  \n-  static size_t length(const char* __s) { return strlen(__s); }\n-\n-  static void assign(char& __c1, const char& __c2) { __c1 = __c2; }\n-\n-  static char* assign(char* __s, size_t __n, char __c)\n-    { memset(__s, __c, __n); return __s; }\n-};\n-\n-// Specialization for wchar_t.\n-\n-template<> struct char_traits<wchar_t>\n-  : public __char_traits_base<wchar_t, wint_t>\n-{};\n-\n-__STL_END_NAMESPACE\n-\n-#endif /* __SGI_STL_CHAR_TRAITS_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:\n-"}, {"sha": "0bdabbd111c8776d32eb1f8e2a9b19d544ef9602", "filename": "libstdc++/stl/limits", "status": "removed", "additions": 0, "deletions": 413, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff51efd52d404bb0e136496ab40b29528f82ebc2/libstdc%2B%2B%2Fstl%2Flimits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff51efd52d404bb0e136496ab40b29528f82ebc2/libstdc%2B%2B%2Fstl%2Flimits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Flimits?ref=ff51efd52d404bb0e136496ab40b29528f82ebc2", "patch": "@@ -1,413 +0,0 @@\n-/*\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-/* NOTE: This is not portable code.  Parts of numeric_limits<> are\n- * inherently machine-dependent, and this file is written for the MIPS\n- * architecture and the SGI MIPSpro C++ compiler.  Parts of it (in\n- * particular, some of the characteristics of floating-point types)\n- * are almost certainly incorrect for any other platform.\n- */\n-\n-#ifndef __SGI_CPP_LIMITS\n-#define __SGI_CPP_LIMITS\n-\n-#include <limits.h>\n-#include <float.h>\n-#include <stl_config.h>\n-\n-__STL_BEGIN_NAMESPACE\n-\n-enum float_round_style {\n-  round_indeterminate       = -1,\n-  round_toward_zero         =  0,\n-  round_to_nearest          =  1,\n-  round_toward_infinity     =  2,\n-  round_toward_neg_infinity =  3\n-};\n-\n-enum float_denorm_style {\n-  denorm_indeterminate = -1,\n-  denorm_absent        =  0,\n-  denorm_present       =  1\n-};\n-\n-// Base class for all specializations of numeric_limits.\n-\n-template <class __number>\n-class _Numeric_limits_base {\n-public:\n-  static const bool is_specialized = false;\n-\n-  static __number min() __STL_NOTHROW { return __number(); }\n-  static __number max() __STL_NOTHROW { return __number(); }\n-\n-  static const int digits   = 0;\n-  static const int digits10 = 0;\n-\n-  static const bool is_signed  = false;\n-  static const bool is_integer = false;\n-  static const bool is_exact   = false;\n-\n-  static const int radix = 0;\n-\n-  static __number epsilon() __STL_NOTHROW     { return __number(); }\n-  static __number round_error() __STL_NOTHROW { return __number(); }\n-\n-  static const int min_exponent   = 0;\n-  static const int min_exponent10 = 0;\n-  static const int max_exponent   = 0;\n-  static const int max_exponent10 = 0;\n-\n-  static const bool has_infinity      = false;\n-  static const bool has_quiet_NaN     = false;\n-  static const bool has_signaling_NaN = false;\n-  static const float_denorm_style has_denorm = denorm_absent;\n-  static const bool has_denorm_loss   = false;\n-\n-  static __number infinity() __STL_NOTHROW      { return __number(); }\n-  static __number quiet_NaN() __STL_NOTHROW     { return __number(); }\n-  static __number signaling_NaN() __STL_NOTHROW { return __number(); }\n-  static __number denorm_min() __STL_NOTHROW    { return __number(); }\n-\n-  static const bool is_iec559  = false;\n-  static const bool is_bounded = false;\n-  static const bool is_modulo  = false;\n-\n-  static const bool traps           = false;\n-  static const bool tinyness_before = false;\n-  static const float_round_style round_style = round_toward_zero;\n-};\n-\n-#define __declare_numeric_base_member(__type, __mem) \\\n-template <class __number> \\\n-  const __type _Numeric_limits_base<__number>:: __mem\n-\n-__declare_numeric_base_member(bool, is_specialized);\n-__declare_numeric_base_member(int, digits);\n-__declare_numeric_base_member(int, digits10);\n-__declare_numeric_base_member(bool, is_signed);\n-__declare_numeric_base_member(bool, is_integer);\n-__declare_numeric_base_member(bool, is_exact);\n-__declare_numeric_base_member(int, radix);\n-__declare_numeric_base_member(int, min_exponent);\n-__declare_numeric_base_member(int, max_exponent);\n-__declare_numeric_base_member(int, min_exponent10);\n-__declare_numeric_base_member(int, max_exponent10);\n-__declare_numeric_base_member(bool, has_infinity);\n-__declare_numeric_base_member(bool, has_quiet_NaN);\n-__declare_numeric_base_member(bool, has_signaling_NaN);\n-__declare_numeric_base_member(float_denorm_style, has_denorm);\n-__declare_numeric_base_member(bool, has_denorm_loss);\n-__declare_numeric_base_member(bool, is_iec559);\n-__declare_numeric_base_member(bool, is_bounded);\n-__declare_numeric_base_member(bool, is_modulo);\n-__declare_numeric_base_member(bool, traps);\n-__declare_numeric_base_member(bool, tinyness_before);\n-__declare_numeric_base_member(float_round_style, round_style);\n-\n-#undef __declare_numeric_base_member\n-\n-// Base class for integers.\n-\n-template <class _Int,\n-          _Int __imin,\n-          _Int __imax,\n-          int __idigits = -1>\n-class _Integer_limits : public _Numeric_limits_base<_Int> \n-{\n-public:\n-  static const bool is_specialized = true;\n-\n-  static _Int min() __STL_NOTHROW { return __imin; }\n-  static _Int max() __STL_NOTHROW { return __imax; }\n-\n-  static const int digits = \n-    (__idigits < 0) ? sizeof(_Int) * CHAR_BIT - (__imin == 0 ? 0 : 1) \n-                    : __idigits;\n-  static const int digits10 = (digits * 301) / 1000; \n-                                // log 2 = 0.301029995664...\n-\n-  static const bool is_signed = __imin != 0;\n-  static const bool is_integer = true;\n-  static const bool is_exact = true;\n-  static const int radix = 2;\n-\n-\n-  static const bool is_bounded = true;\n-  static const bool is_modulo = true;\n-};\n-\n-#define __declare_integer_limits_member(__type, __mem) \\\n-template <class _Int, _Int __imin, _Int __imax, int __idigits> \\\n-  const __type _Integer_limits<_Int, __imin, __imax, __idigits>:: __mem\n-\n-__declare_integer_limits_member(bool, is_specialized);\n-__declare_integer_limits_member(int, digits);\n-__declare_integer_limits_member(int, digits10);\n-__declare_integer_limits_member(bool, is_signed);\n-__declare_integer_limits_member(bool, is_integer);\n-__declare_integer_limits_member(bool, is_exact);\n-__declare_integer_limits_member(int, radix);\n-__declare_integer_limits_member(bool, is_bounded);\n-__declare_integer_limits_member(bool, is_modulo);\n-\n-#undef __declare_integer_limits_member\n-\n-// Base class for floating-point numbers.\n-template <class __number,\n-         int __Digits, int __Digits10,\n-         int __MinExp, int __MaxExp,\n-         int __MinExp10, int __MaxExp10,\n-         unsigned int __InfinityWord,\n-         unsigned int __QNaNWord, unsigned int __SNaNWord,\n-         bool __IsIEC559,\n-         float_round_style __RoundStyle>\n-class _Floating_limits : public _Numeric_limits_base<__number>\n-{\n-public:\n-  static const bool is_specialized = true;\n-\n-  static const int digits   = __Digits;\n-  static const int digits10 = __Digits10;\n-\n-  static const bool is_signed = true;\n-\n-  static const int radix = 2;\n-\n-  static const int min_exponent   = __MinExp;\n-  static const int max_exponent   = __MaxExp;\n-  static const int min_exponent10 = __MinExp10;\n-  static const int max_exponent10 = __MaxExp10;\n-\n-  static const bool has_infinity      = true;\n-  static const bool has_quiet_NaN     = true;\n-  static const bool has_signaling_NaN = true;\n-  static const float_denorm_style has_denorm = denorm_indeterminate;\n-  static const bool has_denorm_loss   = false;\n-\n-  static __number infinity() __STL_NOTHROW {\n-    static unsigned int _S_inf[sizeof(__number) / sizeof(int)] = \n-      { __InfinityWord };\n-    return *reinterpret_cast<__number*>(&_S_inf);\n-  }\n-  static __number quiet_NaN() __STL_NOTHROW {\n-    static unsigned int _S_nan[sizeof(__number) / sizeof(int)] = \n-      { __QNaNWord };\n-    return *reinterpret_cast<__number*>(&_S_nan);\n-  }\n-  static __number signaling_NaN() __STL_NOTHROW {\n-    static unsigned int _S_nan[sizeof(__number) / sizeof(int)] = \n-      { __SNaNWord };\n-    return *reinterpret_cast<__number*>(&_S_nan);\n-  }\n-\n-  static const bool is_iec559       = __IsIEC559;\n-  static const bool is_bounded      = true;\n-  static const bool traps           = true;\n-  static const bool tinyness_before = false;\n-\n-  static const float_round_style round_style = __RoundStyle;\n-};\n-\n-#define __declare_float_limits_member(__type, __mem) \\\n-template <class __Num, int __Dig, int __Dig10, \\\n-          int __MnX, int __MxX, int __MnX10, int __MxX10, \\\n-          unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, \\\n-          bool __IsIEEE, float_round_style __Sty> \\\n-const __type _Floating_limits<__Num, __Dig, __Dig10, \\\n-                              __MnX, __MxX, __MnX10, __MxX10, \\\n-                              __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>:: __mem\n-\n-__declare_float_limits_member(bool, is_specialized);  \n-__declare_float_limits_member(int, digits);  \n-__declare_float_limits_member(int, digits10);  \n-__declare_float_limits_member(bool, is_signed);  \n-__declare_float_limits_member(int, radix);  \n-__declare_float_limits_member(int, min_exponent);  \n-__declare_float_limits_member(int, max_exponent);  \n-__declare_float_limits_member(int, min_exponent10);  \n-__declare_float_limits_member(int, max_exponent10);  \n-__declare_float_limits_member(bool, has_infinity);\n-__declare_float_limits_member(bool, has_quiet_NaN);\n-__declare_float_limits_member(bool, has_signaling_NaN);\n-__declare_float_limits_member(float_denorm_style, has_denorm);\n-__declare_float_limits_member(bool, has_denorm_loss);\n-__declare_float_limits_member(bool, is_iec559);\n-__declare_float_limits_member(bool, is_bounded);\n-__declare_float_limits_member(bool, traps);\n-__declare_float_limits_member(bool, tinyness_before);\n-__declare_float_limits_member(float_round_style, round_style);\n-\n-#undef __declare_float_limits_member\n-\n-// Class numeric_limits\n-\n-// The unspecialized class.\n-\n-template<class T> \n-class numeric_limits : public _Numeric_limits_base<T> {};\n-\n-// Specializations for all built-in integral types.\n-\n-#ifndef __STL_NO_BOOL\n-\n-template<>\n-class numeric_limits<bool>\n-  : public _Integer_limits<bool, false, true, 0>\n-{};\n-\n-#endif /* __STL_NO_BOOL */\n-\n-template<>\n-class numeric_limits<char>\n-  : public _Integer_limits<char, CHAR_MIN, CHAR_MAX>\n-{};\n-\n-template<>\n-class numeric_limits<signed char>\n-  : public _Integer_limits<signed char, SCHAR_MIN, SCHAR_MAX>\n-{};\n-\n-template<>\n-class numeric_limits<unsigned char>\n-  : public _Integer_limits<unsigned char, 0, UCHAR_MAX>\n-{};\n-\n-#ifdef __STL_HAS_WCHAR_T\n-\n-template<>\n-class numeric_limits<wchar_t>\n-  : public _Integer_limits<wchar_t, INT_MIN, INT_MAX>\n-{};\n-\n-#endif\n-\n-template<>\n-class numeric_limits<short>\n-  : public _Integer_limits<short, SHRT_MIN, SHRT_MAX>\n-{};\n-\n-template<>\n-class numeric_limits<unsigned short>\n-  : public _Integer_limits<unsigned short, 0, USHRT_MAX>\n-{};\n-\n-template<>\n-class numeric_limits<int>\n-  : public _Integer_limits<int, INT_MIN, INT_MAX>\n-{};\n-\n-template<>\n-class numeric_limits<unsigned int>\n-  : public _Integer_limits<unsigned int, 0, UINT_MAX>\n-{};\n-\n-template<>\n-class numeric_limits<long>\n-  : public _Integer_limits<long, LONG_MIN, LONG_MAX>\n-{};\n-\n-template<>\n-class numeric_limits<unsigned long>\n-  : public _Integer_limits<unsigned long, 0, ULONG_MAX>\n-{};\n-\n-#ifdef __STL_LONG_LONG\n-\n-template<>\n-class numeric_limits<long long>\n-  : public _Integer_limits<long long, LONGLONG_MIN, LONGLONG_MAX>\n-{};\n-\n-template<>\n-class numeric_limits<unsigned long long>\n-  : public _Integer_limits<unsigned long long, 0, ULONGLONG_MAX>\n-{};\n-\n-#endif /* __STL_LONG_LONG */\n-\n-// Specializations for all built-in floating-point type.\n-\n-template<> class numeric_limits<float>\n-  : public _Floating_limits<float, \n-                            FLT_MANT_DIG,   // Binary digits of precision\n-                            FLT_DIG,        // Decimal digits of precision\n-                            FLT_MIN_EXP,    // Minimum exponent\n-                            FLT_MAX_EXP,    // Maximum exponent\n-                            FLT_MIN_10_EXP, // Minimum base 10 exponent\n-                            FLT_MAX_10_EXP, // Maximum base 10 exponent\n-                            0x7f800000u,    // First word of +infinity\n-                            0x7f810000u,    // First word of quiet NaN\n-                            0x7fc10000u,    // First word of signaling NaN\n-                            true,           // conforms to iec559\n-                            round_to_nearest>\n-{\n-public:\n-  static float min() __STL_NOTHROW { return FLT_MIN; }\n-  static float denorm_min() __STL_NOTHROW { return FLT_MIN; }\n-  static float max() __STL_NOTHROW { return FLT_MAX; }\n-  static float epsilon() __STL_NOTHROW { return FLT_EPSILON; }\n-  static float round_error() __STL_NOTHROW { return 0.5f; } // Units: ulps.\n-};\n-\n-template<> class numeric_limits<double>\n-  : public _Floating_limits<double, \n-                            DBL_MANT_DIG,   // Binary digits of precision\n-                            DBL_DIG,        // Decimal digits of precision\n-                            DBL_MIN_EXP,    // Minimum exponent\n-                            DBL_MAX_EXP,    // Maximum exponent\n-                            DBL_MIN_10_EXP, // Minimum base 10 exponent\n-                            DBL_MAX_10_EXP, // Maximum base 10 exponent\n-                            0x7ff00000u,    // First word of +infinity\n-                            0x7ff10000u,    // First word of quiet NaN\n-                            0x7ff90000u,    // First word of signaling NaN\n-                            true,           // conforms to iec559\n-                            round_to_nearest>\n-{\n-public:\n-  static double min() __STL_NOTHROW { return DBL_MIN; }\n-  static double denorm_min() __STL_NOTHROW { return DBL_MIN; }\n-  static double max() __STL_NOTHROW { return DBL_MAX; }\n-  static double epsilon() __STL_NOTHROW { return DBL_EPSILON; }\n-  static double round_error() __STL_NOTHROW { return 0.5; } // Units: ulps.\n-};\n-\n-template<> class numeric_limits<long double>\n-  : public _Floating_limits<long double, \n-                            LDBL_MANT_DIG,  // Binary digits of precision\n-                            LDBL_DIG,       // Decimal digits of precision\n-                            LDBL_MIN_EXP,   // Minimum exponent\n-                            LDBL_MAX_EXP,   // Maximum exponent\n-                            LDBL_MIN_10_EXP,// Minimum base 10 exponent\n-                            LDBL_MAX_10_EXP,// Maximum base 10 exponent\n-                            0x7ff00000u,    // First word of +infinity\n-                            0x7ff10000u,    // First word of quiet NaN\n-                            0x7ff90000u,    // First word of signaling NaN\n-                            false,          // Doesn't conform to iec559\n-                            round_to_nearest>\n-{\n-public:\n-  static long double min() __STL_NOTHROW { return LDBL_MIN; }\n-  static long double denorm_min() __STL_NOTHROW { return LDBL_MIN; }\n-  static long double max() __STL_NOTHROW { return LDBL_MAX; }\n-  static long double epsilon() __STL_NOTHROW { return LDBL_EPSILON; }\n-  static long double round_error() __STL_NOTHROW { return 4; } // Units: ulps.\n-};\n-\n-__STL_END_NAMESPACE\n-\n-#endif /* __SGI_CPP_LIMITS */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "f66143da837446ac53422d9a8880174ca1c27157", "filename": "libstdc++/stl/stdexcept", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff51efd52d404bb0e136496ab40b29528f82ebc2/libstdc%2B%2B%2Fstl%2Fstdexcept", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff51efd52d404bb0e136496ab40b29528f82ebc2/libstdc%2B%2B%2Fstl%2Fstdexcept", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstdexcept?ref=ff51efd52d404bb0e136496ab40b29528f82ebc2", "patch": "@@ -1,92 +0,0 @@\n-/*\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */ \n-\n-#ifndef __SGI_STDEXCEPT\n-#define __SGI_STDEXCEPT\n-\n-#include <stl_exception.h>\n-\n-#if !(defined(_MIPS_SIM) && defined(_ABIO32) && _MIPS_SIM == _ABIO32)\n-\n-#include <stl_string_fwd.h>\n-\n-__STL_BEGIN_NAMESPACE\n-\n-class logic_error : public __STL_EXCEPTION_BASE {\n-public:\n-  logic_error(const string& __s)\n-    { _S_string_copy(__s, _M_name, _S_bufsize); }\n-  virtual const char* what() const __STL_NOTHROW { return _M_name; }\n-private:\n-  enum { _S_bufsize = 256 };\n-  char _M_name[_S_bufsize];\n-};\n-\n-class runtime_error : public __STL_EXCEPTION_BASE {\n-public:\n-  runtime_error(const string& __s)\n-    { _S_string_copy(__s, _M_name, _S_bufsize); }\n-  virtual const char* what() const __STL_NOTHROW { return _M_name; }\n-private:\n-  enum { _S_bufsize = 256 };\n-  char _M_name[_S_bufsize];\n-};\n-\n-class domain_error : public logic_error {\n-public:\n-  domain_error(const string& __arg) : logic_error(__arg) {}\n-};\n-\n-class invalid_argument : public logic_error {\n-public:\n-  invalid_argument(const string& __arg) : logic_error(__arg) {}\n-};\n-\n-class length_error : public logic_error {\n-public:\n-  length_error(const string& __arg) : logic_error(__arg) {}\n-};\n-\n-class out_of_range : public logic_error {\n-public:\n-  out_of_range(const string& __arg) : logic_error(__arg) {}\n-};\n-\n-class range_error : public runtime_error {\n-public:\n-  range_error(const string& __arg) : runtime_error(__arg) {}\n-};\n-\n-class overflow_error : public runtime_error {\n-public:\n-  overflow_error(const string& __arg) : runtime_error(__arg) {}\n-};\n-\n-class underflow_error : public runtime_error {\n-public:\n-  underflow_error(const string& __arg) : runtime_error(__arg) {}\n-};\n-\n-__STL_END_NAMESPACE\n-\n-#ifndef __SGI_STL_STRING\n-#include <string>\n-#endif\n-\n-#endif /* Not o32 */\n-\n-#endif /* __SGI_STDEXCEPT */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "2a96568ebbdb4aabeb7ef82a047814d769b06037", "filename": "libstdc++/stl/stl_config.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec9c42c9c30b96c45d1ab35b030c3f6c845288e9/libstdc%2B%2B%2Fstl%2Fstl_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec9c42c9c30b96c45d1ab35b030c3f6c845288e9/libstdc%2B%2B%2Fstl%2Fstl_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_config.h?ref=ec9c42c9c30b96c45d1ab35b030c3f6c845288e9", "patch": "@@ -118,6 +118,10 @@\n        It should be upgraded to glibc 2.0 or later. */\n #   if !defined(_NOTHREADS) && __GLIBC__ >= 2 && defined(_G_USING_THUNKS)\n #     define __STL_PTHREADS\n+#     ifdef __STRICT_ANSI__\n+        /* Work around a bug in the glibc 2.0.x pthread.h.  */\n+#       define sigset_t __sigset_t\n+#     endif\n #   endif\n #   ifdef __EXCEPTIONS\n #     define __STL_USE_EXCEPTIONS"}, {"sha": "37b54d74442abb1c7ee083f3c1728ebfe593ef52", "filename": "libstdc++/stl/stl_exception.h", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff51efd52d404bb0e136496ab40b29528f82ebc2/libstdc%2B%2B%2Fstl%2Fstl_exception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff51efd52d404bb0e136496ab40b29528f82ebc2/libstdc%2B%2B%2Fstl%2Fstl_exception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_exception.h?ref=ff51efd52d404bb0e136496ab40b29528f82ebc2", "patch": "@@ -1,57 +0,0 @@\n-/*\n- * Copyright (c) 1998\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */ \n-\n-#ifndef __SGI_STL_EXCEPTION_H\n-#define __SGI_STL_EXCEPTION_H\n-\n-// This header exists solely for portability.  Normally it just includes\n-// the header <exception>.\n-\n-// The header <exception> contains low-level functions that interact\n-// with a compiler's exception-handling mechanism.  It is assumed to\n-// be supplied with the compiler, rather than with the library, because\n-// it is inherently tied very closely to the compiler itself.\n-\n-// On platforms where <exception> does not exist, this header defines\n-// an exception base class.  This is *not* a substitute for everything\n-// in <exception>, but it suffices to support a bare minimum of STL\n-// functionality.\n-\n-#include <stl_config.h>\n-\n-#ifndef __STL_NO_EXCEPTION_HEADER\n-\n-#include <exception>\n-#define __STL_EXCEPTION_BASE exception\n-\n-#else /* __STL_NO_EXCEPTION_HEADER */\n-\n-__STL_BEGIN_NAMESPACE\n-\n-class _Exception {\n-public:\n-  virtual ~_Exception() __STL_NOTHROW {}\n-  virtual const char* what() const __STL_NOTHROW { return \"\"; }\n-};\n-\n-#define __STL_EXCEPTION_BASE _Exception\n-\n-__STL_END_NAMESPACE\n-\n-#endif /* __STL_NO_EXCEPTION_HEADER */\n-\n-#endif /* __SGI_STL_EXCEPTION_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "d2af9e19f01c35d2bfea2ae8765bae9aa58b2fef", "filename": "libstdc++/stl/stl_string_fwd.h", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff51efd52d404bb0e136496ab40b29528f82ebc2/libstdc%2B%2B%2Fstl%2Fstl_string_fwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff51efd52d404bb0e136496ab40b29528f82ebc2/libstdc%2B%2B%2Fstl%2Fstl_string_fwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_string_fwd.h?ref=ff51efd52d404bb0e136496ab40b29528f82ebc2", "patch": "@@ -1,51 +0,0 @@\n-/*\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */ \n-\n-#ifndef __SGI_STL_STRING_FWD_H\n-#define __SGI_STL_STRING_FWD_H\n-\n-#include <stddef.h>\n-\n-__STL_BEGIN_NAMESPACE\n-\n-#ifdef __STL_USE_STD_ALLOCATORS\n-\n-template <class _Tp> class allocator;\n-\n-#else /* __STL_USE_STD_ALLOCATORS */\n-\n-template <bool __threads, int __inst> class _Default_alloc_template;\n-typedef _Default_alloc_template<true, 0> _Alloc;\n-\n-#endif /* __STL_USE_STD_ALLOCATORS */\n-\n-template <class _CharT> struct char_traits;\n-template <class _CharT, \n-          class _Traits = char_traits<_CharT>, \n-          class _Alloc = __STL_DEFAULT_ALLOCATOR(_CharT) >\n-class basic_string;\n-\n-typedef basic_string<char> string;\n-typedef basic_string<wchar_t> wstring;\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-void _S_string_copy(const basic_string<_CharT,_Traits,_Alloc>&, _CharT*, \n-                    size_t);\n-\n-__STL_END_NAMESPACE\n-\n-#endif /* __SGI_STL_STRING_FWD_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "24cfc20940f03271c03b148a1bd3787ba1fc8bd9", "filename": "libstdc++/stl/string", "status": "removed", "additions": 0, "deletions": 1960, "changes": 1960, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff51efd52d404bb0e136496ab40b29528f82ebc2/libstdc%2B%2B%2Fstl%2Fstring", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff51efd52d404bb0e136496ab40b29528f82ebc2/libstdc%2B%2B%2Fstl%2Fstring", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstring?ref=ff51efd52d404bb0e136496ab40b29528f82ebc2", "patch": "@@ -1,1960 +0,0 @@\n-/*\n- * Copyright (c) 1997,1998\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */ \n-\n-#ifndef __SGI_STL_STRING\n-#define __SGI_STL_STRING\n-\n-#include <ctype.h>        \n-#include <stdexcept>      // Includes stl_string_fwd.h and stl_config.h\n-#include <char_traits.h>  // This header name is an extension.\n-#include <iterator>\n-#include <functional>\n-#include <memory>\n-#include <algorithm>\n-\n-// Standard C++ string class.  This class has performance\n-// characteristics very much like vector<>, meaning, for example, that\n-// it does not perform reference-count or copy-on-write, and that\n-// concatenation of two strings is an O(N) operation. \n-\n-// There are three reasons why basic_string is not identical to\n-// vector.  First, basic_string always stores a null character at the\n-// end; this makes it possible for c_str to be a fast operation.\n-// Second, the C++ standard requires basic_string to copy elements\n-// using char_traits<>::assign, char_traits<>::copy, and\n-// char_traits<>::move.  This means that all of vector<>'s low-level\n-// operations must be rewritten.  Third, basic_string<> has a lot of\n-// extra functions in its interface that are convenient but, strictly\n-// speaking, redundant.\n-\n-// Additionally, the C++ standard imposes a major restriction: according\n-// to the standard, the character type _CharT must be a POD type.  This\n-// implementation weakens that restriction, and allows _CharT to be a\n-// a user-defined non-POD type.  However, _CharT must still have a\n-// default constructor.\n-\n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n-\n-// Helper classes that turn char_traits into function objects.\n-\n-template <class _Traits>\n-struct _Eq_traits\n-  : public binary_function<typename _Traits::char_type,\n-                           typename _Traits::char_type,\n-                           bool>\n-{\n-  bool operator()(const typename _Traits::char_type& __x,\n-                  const typename _Traits::char_type& __y) const\n-    { return _Traits::eq(__x, __y); }\n-};\n-\n-template <class _Traits>\n-struct _Lt_traits\n-  : public binary_function<typename _Traits::char_type,\n-                           typename _Traits::char_type,\n-                           bool>\n-{\n-  bool operator()(const typename _Traits::char_type& __x,\n-                  const typename _Traits::char_type& __y) const\n-    { return _Traits::lt(__x, __y); }\n-};\n-\n-template <class _Traits>\n-struct _Not_within_traits\n-  : public unary_function<typename _Traits::char_type, bool>\n-{\n-  typedef const typename _Traits::char_type* _Pointer;\n-  const _Pointer _M_first;\n-  const _Pointer _M_last;\n-\n-  _Not_within_traits(_Pointer __f, _Pointer __l) \n-    : _M_first(__f), _M_last(__l) {}\n-\n-  bool operator()(const typename _Traits::char_type& __x) const {\n-    return find_if(_M_first, _M_last, \n-                   bind1st(_Eq_traits<_Traits>(), __x)) == _M_last;\n-  }\n-};\n-\n-// ------------------------------------------------------------\n-// Class _String_base.  \n-\n-// _String_base is a helper class that makes it it easier to write an\n-// exception-safe version of basic_string.  The constructor allocates,\n-// but does not initialize, a block of memory.  The destructor\n-// deallocates, but does not destroy elements within, a block of\n-// memory.  The destructor assumes that _M_start either is null, or else\n-// points to a block of memory that was allocated using _String_base's \n-// allocator and whose size is _M_end_of_storage - _M_start.\n-\n-// Additionally, _String_base encapsulates the difference between\n-// old SGI-style allocators and standard-conforming allocators.\n-\n-#ifdef __STL_USE_STD_ALLOCATORS\n-\n-// General base class.\n-template <class _Tp, class _Alloc, bool _S_instanceless>\n-class _String_alloc_base {\n-public:\n-  typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;\n-  allocator_type get_allocator() const { return _M_data_allocator; }\n-\n-  _String_alloc_base(const allocator_type& __a)\n-    : _M_data_allocator(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)\n-    {}\n-\n-protected:\n-  _Tp* _M_allocate(size_t __n)\n-    { return _M_data_allocator.allocate(__n); }\n-  void _M_deallocate(_Tp* __p, size_t __n) {\n-    if (__p)\n-      _M_data_allocator.deallocate(__p, __n); \n-  }\n-\n-protected:\n-  allocator_type _M_data_allocator;\n-\n-  _Tp* _M_start;\n-  _Tp* _M_finish;\n-  _Tp* _M_end_of_storage;\n-};\n-\n-// Specialization for instanceless allocators.\n-template <class _Tp, class _Alloc>\n-class _String_alloc_base<_Tp,_Alloc,true> {\n-public:\n-  typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-\n-  _String_alloc_base(const allocator_type&)\n-    : _M_start(0), _M_finish(0), _M_end_of_storage(0) {}\n-\n-protected:\n-  typedef typename _Alloc_traits<_Tp, _Alloc>::_Alloc_type _Alloc_type;\n-  _Tp* _M_allocate(size_t __n)\n-    { return _Alloc_type::allocate(__n); }\n-  void _M_deallocate(_Tp* __p, size_t __n)\n-    { _Alloc_type::deallocate(__p, __n); }\n-\n-protected:\n-  _Tp* _M_start;\n-  _Tp* _M_finish;\n-  _Tp* _M_end_of_storage;\n-};\n-\n-template <class _Tp, class _Alloc>\n-class _String_base \n-  : public _String_alloc_base<_Tp, _Alloc,\n-                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-{\n-protected:\n-  typedef _String_alloc_base<_Tp, _Alloc,\n-                             _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-          _Base;\n-  typedef typename _Base::allocator_type allocator_type;\n-\n-  void _M_allocate_block(size_t __n) { \n-    if (__n <= max_size()) {\n-      _M_start  = _M_allocate(__n);\n-      _M_finish = _M_start;\n-      _M_end_of_storage = _M_start + __n;\n-    }\n-    else\n-      _M_throw_length_error();\n-  }\n-\n-  void _M_deallocate_block() \n-    { _M_deallocate(_M_start, _M_end_of_storage - _M_start); }\n-  \n-  size_t max_size() const { return (size_t(-1) / sizeof(_Tp)) - 1; }\n-\n-  _String_base(const allocator_type& __a) : _Base(__a) { }\n-  \n-  _String_base(const allocator_type& __a, size_t __n) : _Base(__a)\n-    { _M_allocate_block(__n); }\n-\n-  ~_String_base() { _M_deallocate_block(); }\n-\n-  void _M_throw_length_error() const;\n-  void _M_throw_out_of_range() const;\n-};\n-\n-#else /* __STL_USE_STD_ALLOCATORS */\n-\n-template <class _Tp, class _Alloc> class _String_base {\n-protected:\n-  typedef simple_alloc<_Tp, _Alloc> _Alloc_type;\n-  typedef _Alloc allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-\n-  _Tp* _M_start;\n-  _Tp* _M_finish;\n-  _Tp* _M_end_of_storage;\n-                                // Precondition: 0 < __n <= max_size().\n-\n-  _Tp* _M_allocate(size_t __n) { return _Alloc_type::allocate(__n); }\n-  void _M_deallocate(_Tp* __p, size_t __n) {\n-    if (__p)\n-      _Alloc_type::deallocate(__p, __n); \n-  }\n-\n-  void _M_allocate_block(size_t __n) { \n-    if (__n <= max_size()) {\n-      _M_start  = _M_allocate(__n);\n-      _M_finish = _M_start;\n-      _M_end_of_storage = _M_start + __n;\n-    }\n-    else\n-      _M_throw_length_error();\n-  }\n-\n-  void _M_deallocate_block() \n-    { _M_deallocate(_M_start, _M_end_of_storage - _M_start); }\n-  \n-  size_t max_size() const { return (size_t(-1) / sizeof(_Tp)) - 1; }\n-\n-  _String_base(const allocator_type&)\n-    : _M_start(0), _M_finish(0), _M_end_of_storage(0) { }\n-  \n-  _String_base(const allocator_type&, size_t __n)\n-    : _M_start(0), _M_finish(0), _M_end_of_storage(0)\n-    { _M_allocate_block(__n); }\n-\n-  ~_String_base() { _M_deallocate_block(); }\n-\n-  void _M_throw_length_error() const;\n-  void _M_throw_out_of_range() const;\n-};\n-\n-#endif /* __STL_USE_STD_ALLOCATORS */\n-\n-template <class _Tp, class _Alloc> \n-void _String_base<_Tp,_Alloc>::_M_throw_length_error() const {\n-  __STL_THROW(length_error(\"basic_string\"));\n-}\n-\n-template <class _Tp, class _Alloc> \n-void _String_base<_Tp, _Alloc>::_M_throw_out_of_range() const {\n-  __STL_THROW(out_of_range(\"basic_string\"));\n-}\n-\n-// ------------------------------------------------------------\n-// Class basic_string.  \n-\n-// Class invariants:\n-// (1) [start, finish) is a valid range.\n-// (2) Each iterator in [start, finish) points to a valid object\n-//     of type value_type.\n-// (3) *finish is a valid object of type value_type; in particular,\n-//     it is value_type().\n-// (4) [finish + 1, end_of_storage) is a valid range.\n-// (5) Each iterator in [finish + 1, end_of_storage) points to \n-//     unininitialized memory.\n-\n-// Note one important consequence: a string of length n must manage\n-// a block of memory whose size is at least n + 1.  \n-\n-\n-template <class _CharT, class _Traits, class _Alloc> \n-class basic_string : private _String_base<_CharT,_Alloc> {\n-public:\n-  typedef _CharT value_type;\n-  typedef _Traits traits_type;\n-\n-  typedef value_type* pointer;\n-  typedef const value_type* const_pointer;\n-  typedef value_type& reference;\n-  typedef const value_type& const_reference;\n-  typedef size_t size_type;\n-  typedef ptrdiff_t difference_type;\n-\n-  typedef const value_type*                const_iterator;\n-  typedef value_type*                      iterator;\n-  typedef reverse_iterator<const_iterator> const_reverse_iterator;\n-  typedef reverse_iterator<iterator>       reverse_iterator;\n-\n-  static const size_type npos = -1;\n-\n-  typedef _String_base<_CharT,_Alloc> _Base;\n-\n-public:                         // Constructor, destructor, assignment.\n-  typedef typename _Base::allocator_type allocator_type;\n-#ifdef __STL_USE_NAMESPACES\n-  using _Base::get_allocator;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-  explicit basic_string(const allocator_type& __a = allocator_type())\n-    : _Base(__a, 8) { construct(_M_finish); }\n-\n-  struct _Reserve_t {};\n-  basic_string(_Reserve_t, size_t __n,\n-               const allocator_type& __a = allocator_type())\n-    : _Base(__a, __n + 1) { construct(_M_finish); }\n-\n-  basic_string(const basic_string& __s) : _Base(__s.get_allocator()) \n-    { _M_range_initialize(__s.begin(), __s.end()); }\n-\n-  basic_string(const basic_string& __s, size_type __pos, size_type __n = npos,\n-               const allocator_type& __a = allocator_type()) \n-    : _Base(__a) {\n-    if (__pos > __s.size())\n-      _M_throw_out_of_range();\n-    else\n-      _M_range_initialize(__s.begin() + __pos,\n-                          __s.begin() + __pos + min(__n, __s.size() - __pos));\n-  }\n-\n-  basic_string(const _CharT* __s, size_type __n,\n-               const allocator_type& __a = allocator_type()) \n-    : _Base(__a) \n-    { _M_range_initialize(__s, __s + __n); }\n-\n-  basic_string(const _CharT* __s,\n-               const allocator_type& __a = allocator_type())\n-    : _Base(__a) \n-    { _M_range_initialize(__s, __s + _Traits::length(__s)); }\n-\n-  basic_string(size_type __n, _CharT __c,\n-               const allocator_type& __a = allocator_type())\n-    : _Base(__a, __n + 1)\n-  {\n-    _M_finish = uninitialized_fill_n(_M_start, __n, __c);\n-    _M_terminate_string();\n-  }\n-\n-  // Check to see if _InputIterator is an integer type.  If so, then\n-  // it can't be an iterator.\n-  template <class _InputIterator>\n-  basic_string(_InputIterator __f, _InputIterator __l,\n-               const allocator_type& __a = allocator_type())\n-    : _Base(__a)\n-  {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_initialize_dispatch(__f, __l, _Integral());\n-  }\n-\n-  ~basic_string() { destroy(_M_start, _M_finish + 1); }\n-    \n-  basic_string& operator=(const basic_string& __s) {\n-    if (&__s != this) \n-      assign(__s.begin(), __s.end());\n-    return *this;\n-  }\n-\n-  basic_string& operator=(const _CharT* __s) \n-    { return assign(__s, __s + _Traits::length(__s)); }\n-\n-  basic_string& operator=(_CharT __c)\n-    { return assign(static_cast<size_type>(1), __c); }\n-\n-private:                        // Protected members inherited from base.\n-#ifdef __STL_HAS_NAMESPACES\n-  using _Base::_M_allocate;\n-  using _Base::_M_deallocate;\n-  using _Base::_M_allocate_block;\n-  using _Base::_M_deallocate_block;\n-  using _Base::_M_throw_length_error;\n-  using _Base::_M_throw_out_of_range;\n-\n-  using _Base::_M_start;\n-  using _Base::_M_finish;\n-  using _Base::_M_end_of_storage;\n-#endif /* __STL_HAS_NAMESPACES */\n-\n-private:                        \n-  // Helper functions used by constructors.  It is a severe error for\n-  // any of them to be called anywhere except from within constructors.\n-\n-  void _M_terminate_string() {\n-    __STL_TRY {\n-      construct(_M_finish);\n-    }\n-    __STL_UNWIND(destroy(_M_start, _M_finish));\n-  }\n-    \n-  template <class _InputIter>\n-  void _M_range_initialize(_InputIter __f, _InputIter __l,\n-                           input_iterator_tag) {\n-    _M_allocate_block(8);\n-    construct(_M_finish);\n-    __STL_TRY {\n-      append(__f, __l);\n-    }\n-    __STL_UNWIND(destroy(_M_start, _M_finish + 1));\n-  }\n-\n-  template <class _ForwardIter>\n-  void _M_range_initialize(_ForwardIter __f, _ForwardIter __l, \n-                           forward_iterator_tag) {\n-    typename iterator_traits<_ForwardIter>::difference_type __n\n-      = distance(__f, __l);\n-    _M_allocate_block(__n + 1);\n-    _M_finish = uninitialized_copy(__f, __l, _M_start);\n-    _M_terminate_string();\n-  }\n-\n-  template <class _InputIter>\n-  void _M_range_initialize(_InputIter __f, _InputIter __l) {\n-    typedef typename iterator_traits<_InputIter>::iterator_category _Category;\n-    _M_range_initialize(__f, __l, _Category());\n-  }\n-\n-  template <class _Integer>\n-  void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) {\n-    _M_allocate_block(__n + 1);\n-    _M_finish = uninitialized_fill_n(_M_start, __n, __x);\n-    _M_terminate_string();\n-  }\n-\n-  template <class _InputIter>\n-  void _M_initialize_dispatch(_InputIter __f, _InputIter __l, __false_type) {\n-     _M_range_initialize(__f, __l);\n-  }\n-    \n-\n-public:                         // Iterators.\n-  iterator begin()             { return _M_start; }\n-  iterator end()               { return _M_finish; }\n-  const_iterator begin() const { return _M_start; }\n-  const_iterator end()   const { return _M_finish; }  \n-\n-  reverse_iterator rbegin()             \n-    { return reverse_iterator(_M_finish); }\n-  reverse_iterator rend()               \n-    { return reverse_iterator(_M_start); }\n-  const_reverse_iterator rbegin() const \n-    { return const_reverse_iterator(_M_finish); }\n-  const_reverse_iterator rend()   const \n-    { return const_reverse_iterator(_M_start); }\n-\n-public:                         // Size, capacity, etc.\n-  size_type size() const { return _M_finish - _M_start; }\n-  size_type length() const { return size(); }\n-#ifdef __STL_USE_NAMESPACES\n-  using _Base::max_size;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-  void resize(size_type __n, _CharT __c = _CharT()) {\n-    if (__n <= size())\n-      erase(begin() + __n, end());\n-    else\n-      append(__n - size(), __c);\n-  }\n-\n-  void reserve(size_type = 0);\n-\n-  size_type capacity() const { return (_M_end_of_storage - _M_start) - 1; }\n-\n-  void clear() {\n-    if (!empty()) {\n-      _Traits::assign(*_M_start, _CharT());\n-      destroy(_M_start+1, _M_finish+1);\n-      _M_finish = _M_start;\n-    }\n-  } \n-\n-  bool empty() const { return _M_start == _M_finish; }    \n-\n-public:                         // Element access.\n-\n-  const_reference operator[](size_type __n) const\n-    { return *(_M_start + __n); }\n-  reference operator[](size_type __n)\n-    { return *(_M_start + __n); }\n-\n-  const_reference at(size_type __n) const {\n-    if (__n >= size())\n-      _M_throw_out_of_range();\n-    return *(_M_start + __n);\n-  }\n-\n-  reference at(size_type __n) {\n-    if (__n >= size())\n-      _M_throw_out_of_range();\n-    return *(_M_start + __n);\n-  }\n-\n-public:                         // Append, operator+=, push_back.\n-\n-  basic_string& operator+=(const basic_string& __s) { return append(__s); }\n-  basic_string& operator+=(const _CharT* __s) { return append(__s); }\n-  basic_string& operator+=(_CharT __c) { push_back(__c); return *this; }\n-\n-  basic_string& append(const basic_string& __s) \n-    { return append(__s.begin(), __s.end()); }\n-\n-  basic_string& append(const basic_string& __s,\n-                       size_type __pos, size_type __n)\n-  {\n-    if (__pos > __s.size())\n-      _M_throw_out_of_range();\n-    return append(__s.begin() + __pos,\n-                  __s.begin() + __pos + min(__n, __s.size() - __pos));\n-  }\n-\n-  basic_string& append(const _CharT* __s, size_type __n) \n-    { return append(__s, __s+__n); }\n-\n-  basic_string& append(const _CharT* __s) \n-    { return append(__s, __s + _Traits::length(__s)); }\n-\n-  basic_string& append(size_type __n, _CharT __c);\n-\n-  // Check to see if _InputIterator is an integer type.  If so, then\n-  // it can't be an iterator.\n-  template <class _InputIter>\n-  basic_string& append(_InputIter __first, _InputIter __last) {\n-    typedef typename _Is_integer<_InputIter>::_Integral _Integral;\n-    return _M_append_dispatch(__first, __last, _Integral());\n-  }\n-\n-  void push_back(_CharT __c) {\n-    if (_M_finish + 1 == _M_end_of_storage)\n-      reserve(size() + max(size(), static_cast<size_type>(1)));\n-    construct(_M_finish + 1);\n-    _Traits::assign(*_M_finish, __c);\n-    ++_M_finish;\n-  }\n-\n-  void pop_back() {\n-    _Traits::assign(*(_M_finish - 1), _CharT());\n-    destroy(_M_finish);\n-    --_M_finish;\n-  }\n-\n-private:                        // Helper functions for append.\n-\n-  template <class _InputIter>\n-  basic_string& append(_InputIter __f, _InputIter __l, input_iterator_tag);\n-\n-  template <class _ForwardIter>\n-  basic_string& append(_ForwardIter __f, _ForwardIter __l, \n-                       forward_iterator_tag);\n-\n-  template <class _Integer>\n-  basic_string& _M_append_dispatch(_Integer __n, _Integer __x, __true_type) {\n-    return append((size_type) __n, (_CharT) __x);\n-  }\n-\n-  template <class _InputIter>\n-  basic_string& _M_append_dispatch(_InputIter __f, _InputIter __l,\n-                                   __false_type) {\n-    typedef typename iterator_traits<_InputIter>::iterator_category _Category;\n-    return append(__f, __l, _Category());\n-  }\n-\n-public:                         // Assign\n-  \n-  basic_string& assign(const basic_string& __s) \n-    { return assign(__s.begin(), __s.end()); }\n-\n-  basic_string& assign(const basic_string& __s, \n-                       size_type __pos, size_type __n) {\n-    if (__pos > __s.size())\n-      _M_throw_out_of_range();\n-    return assign(__s.begin() + __pos, \n-                  __s.begin() + __pos + min(__n, __s.size() - __pos));\n-  }\n-\n-  basic_string& assign(const _CharT* __s, size_type __n)\n-    { return assign(__s, __s + __n); }\n-\n-  basic_string& assign(const _CharT* __s)\n-    { return assign(__s, __s + _Traits::length(__s)); }\n-\n-  basic_string& assign(size_type __n, _CharT __c);\n-\n-  // Check to see if _InputIterator is an integer type.  If so, then\n-  // it can't be an iterator.\n-  template <class _InputIter>\n-  basic_string& assign(_InputIter __first, _InputIter __last) {\n-    typedef typename _Is_integer<_InputIter>::_Integral _Integral;\n-    return _M_assign_dispatch(__first, __last, _Integral());\n-  }\n-\n-  basic_string& assign(const _CharT* __f, const _CharT* __l);\n-\n-private:                        // Helper functions for assign.\n-\n-  template <class _Integer>\n-  basic_string& _M_assign_dispatch(_Integer __n, _Integer __x, __true_type) {\n-    return assign((size_type) __n, (_CharT) __x);\n-  }\n-\n-  template <class _InputIter>\n-  basic_string& _M_assign_dispatch(_InputIter __f, _InputIter __l,\n-                                   __false_type);\n-\n-public:                         // Insert\n-\n-  basic_string& insert(size_type __pos, const basic_string& __s) {\n-    if (__pos > size())\n-      _M_throw_out_of_range();\n-    if (size() > max_size() - __s.size())\n-      _M_throw_length_error();\n-    insert(_M_start + __pos, __s.begin(), __s.end());\n-    return *this;\n-  }\n-\n-  basic_string& insert(size_type __pos, const basic_string& __s,\n-                       size_type __beg, size_type __n) {\n-    if (__pos > size() || __beg > __s.size())\n-      _M_throw_out_of_range();\n-    size_type __len = min(__n, __s.size() - __beg);\n-    if (size() > max_size() - __len)\n-      _M_throw_length_error();\n-    insert(_M_start + __pos,\n-           __s.begin() + __beg, __s.begin() + __beg + __len);\n-    return *this;\n-  }\n-\n-  basic_string& insert(size_type __pos, const _CharT* __s, size_type __n) {\n-    if (__pos > size())\n-      _M_throw_out_of_range();\n-    if (size() > max_size() - __n)\n-      _M_throw_length_error();\n-    insert(_M_start + __pos, __s, __s + __n);\n-    return *this;\n-  }\n-\n-  basic_string& insert(size_type __pos, const _CharT* __s) {\n-    if (__pos > size())\n-      _M_throw_out_of_range();\n-    size_type __len = _Traits::length(__s);\n-    if (size() > max_size() - __len)\n-      _M_throw_length_error();\n-    insert(_M_start + __pos, __s, __s + __len);\n-    return *this;\n-  }\n-    \n-  basic_string& insert(size_type __pos, size_type __n, _CharT __c) {\n-    if (__pos > size())\n-      _M_throw_out_of_range();\n-    if (size() > max_size() - __n)\n-      _M_throw_length_error();\n-    insert(_M_start + __pos, __n, __c);\n-    return *this;\n-  }\n-\n-  iterator insert(iterator __p, _CharT __c) {\n-    if (__p == _M_finish) {\n-      push_back(__c);\n-      return _M_finish - 1;\n-    }\n-    else\n-      return _M_insert_aux(__p, __c);\n-  }\n-\n-  void insert(iterator __p, size_t __n, _CharT __c);\n-\n-  // Check to see if _InputIterator is an integer type.  If so, then\n-  // it can't be an iterator.\n-  template <class _InputIter>\n-  void insert(iterator __p, _InputIter __first, _InputIter __last) {\n-    typedef typename _Is_integer<_InputIter>::_Integral _Integral;\n-    _M_insert_dispatch(__p, __first, __last, _Integral());\n-  }\n-\n-private:                        // Helper functions for insert.\n-  template <class _InputIter>\n-  void insert(iterator __p, _InputIter, _InputIter, input_iterator_tag);\n-\n-  template <class _ForwardIter>\n-  void insert(iterator __p, _ForwardIter, _ForwardIter, forward_iterator_tag);\n-\n-\n-  template <class _Integer>\n-  void _M_insert_dispatch(iterator __p, _Integer __n, _Integer __x,\n-                          __true_type) {\n-    insert(__p, (size_type) __n, (_CharT) __x);\n-  }\n-\n-  template <class _InputIter>\n-  void _M_insert_dispatch(iterator __p, _InputIter __first, _InputIter __last,\n-                          __false_type) {\n-    typedef typename iterator_traits<_InputIter>::iterator_category _Category;\n-    insert(__p, __first, __last, _Category());\n-  }\n-\n-  iterator _M_insert_aux(iterator, _CharT);\n-\n-  template <class _InputIterator>\n-  void \n-  _M_copy(_InputIterator __first, _InputIterator __last, iterator __result) {\n-    for ( ; __first != __last; ++__first, ++__result)\n-      _Traits::assign(*__result, *__first);\n-  }\n-\n-  void \n-  _M_copy(const _CharT* __first, const _CharT* __last, _CharT* __result) {\n-    _Traits::copy(__result, __first, __last - __first);\n-  }\n-\n-public:                         // Erase.\n-\n-  basic_string& erase(size_type __pos = 0, size_type __n = npos) {\n-    if (__pos > size())\n-      _M_throw_out_of_range();\n-    erase(_M_start + __pos, _M_start + __pos + min(__n, size() - __pos));\n-    return *this;\n-  }  \n-\n-  iterator erase(iterator __position) {\n-                                // The move includes the terminating _CharT().\n-    _Traits::move(__position, __position + 1, _M_finish - __position);\n-    destroy(_M_finish);\n-    --_M_finish;\n-    return __position;\n-  }\n-\n-  iterator erase(iterator __first, iterator __last) {\n-    if (__first != __last) {\n-                                // The move includes the terminating _CharT().\n-      _Traits::move(__first, __last, (_M_finish - __last) + 1);\n-      const iterator __new_finish = _M_finish - (__last - __first);\n-      destroy(__new_finish + 1, _M_finish + 1);\n-      _M_finish = __new_finish;\n-    }\n-    return __first;\n-  }\n-\n-public:                         // Replace.  (Conceptually equivalent\n-                                // to erase followed by insert.)\n-  basic_string& replace(size_type __pos, size_type __n, \n-                        const basic_string& __s) {\n-    if (__pos > size())\n-      _M_throw_out_of_range();\n-    const size_type __len = min(__n, size() - __pos);\n-    if (size() - __len >= max_size() - __s.size())\n-      _M_throw_length_error();\n-    return replace(_M_start + __pos, _M_start + __pos + __len, \n-                   __s.begin(), __s.end());\n-  }\n-\n-  basic_string& replace(size_type __pos1, size_type __n1,\n-                        const basic_string& __s,\n-                        size_type __pos2, size_type __n2) {\n-    if (__pos1 > size() || __pos2 > __s.size())\n-      _M_throw_out_of_range();\n-    const size_type __len1 = min(__n1, size() - __pos1);\n-    const size_type __len2 = min(__n2, __s.size() - __pos2);\n-    if (size() - __len1 >= max_size() - __len2)\n-      _M_throw_length_error();\n-    return replace(_M_start + __pos1, _M_start + __pos1 + __len1,\n-                   __s._M_start + __pos2, __s._M_start + __pos2 + __len2);\n-  }\n-\n-  basic_string& replace(size_type __pos, size_type __n1,\n-                        const _CharT* __s, size_type __n2) {\n-    if (__pos > size())\n-      _M_throw_out_of_range();\n-    const size_type __len = min(__n1, size() - __pos);\n-    if (__n2 > max_size() || size() - __len >= max_size() - __n2)\n-      _M_throw_length_error();\n-    return replace(_M_start + __pos, _M_start + __pos + __len,\n-                   __s, __s + __n2);\n-  }\n-\n-  basic_string& replace(size_type __pos, size_type __n1,\n-                        const _CharT* __s) {\n-    if (__pos > size())\n-      _M_throw_out_of_range();\n-    const size_type __len = min(__n1, size() - __pos);\n-    const size_type __n2 = _Traits::length(__s);\n-    if (__n2 > max_size() || size() - __len >= max_size() - __n2)\n-      _M_throw_length_error();\n-    return replace(_M_start + __pos, _M_start + __pos + __len,\n-                   __s, __s + _Traits::length(__s));\n-  }\n-\n-  basic_string& replace(size_type __pos, size_type __n1,\n-                        size_type __n2, _CharT __c) {\n-    if (__pos > size())\n-      _M_throw_out_of_range();\n-    const size_type __len = min(__n1, size() - __pos);\n-    if (__n2 > max_size() || size() - __len >= max_size() - __n2)\n-      _M_throw_length_error();\n-    return replace(_M_start + __pos, _M_start + __pos + __len, __n2, __c);\n-  }\n-\n-  basic_string& replace(iterator __first, iterator __last, \n-                        const basic_string& __s) \n-    { return replace(__first, __last, __s.begin(), __s.end()); }\n-\n-  basic_string& replace(iterator __first, iterator __last,\n-                        const _CharT* __s, size_type __n) \n-    { return replace(__first, __last, __s, __s + __n); }\n-\n-  basic_string& replace(iterator __first, iterator __last,\n-                        const _CharT* __s) {\n-    return replace(__first, __last, __s, __s + _Traits::length(__s));\n-  }\n-\n-  basic_string& replace(iterator __first, iterator __last, \n-                        size_type __n, _CharT __c);\n-\n-  // Check to see if _InputIterator is an integer type.  If so, then\n-  // it can't be an iterator.\n-  template <class _InputIter>\n-  basic_string& replace(iterator __first, iterator __last,\n-                        _InputIter __f, _InputIter __l) {\n-    typedef typename _Is_integer<_InputIter>::_Integral _Integral;\n-    return _M_replace_dispatch(__first, __last, __f, __l,  _Integral());\n-  }\n-\n-private:                        // Helper functions for replace.\n-\n-  template <class _Integer>\n-  basic_string& _M_replace_dispatch(iterator __first, iterator __last,\n-                                    _Integer __n, _Integer __x,\n-                                    __true_type) {\n-    return replace(__first, __last, (size_type) __n, (_CharT) __x);\n-  }\n-\n-  template <class _InputIter>\n-  basic_string& _M_replace_dispatch(iterator __first, iterator __last,\n-                                    _InputIter __f, _InputIter __l,\n-                                    __false_type) {\n-    typedef typename iterator_traits<_InputIter>::iterator_category _Category;\n-    return replace(__first, __last, __f, __l, _Category());\n-  }\n-\n-  template <class _InputIter>\n-  basic_string& replace(iterator __first, iterator __last,\n-                        _InputIter __f, _InputIter __l, input_iterator_tag);\n-\n-  template <class _ForwardIter>\n-  basic_string& replace(iterator __first, iterator __last,\n-                        _ForwardIter __f, _ForwardIter __l, \n-                        forward_iterator_tag);\n-\n-public:                         // Other modifier member functions.\n-\n-  size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const {\n-    if (__pos > size())\n-      _M_throw_out_of_range();\n-    const size_type __len = min(__n, size() - __pos);\n-    _Traits::copy(__s, _M_start + __pos, __len);\n-    return __len;\n-  }\n-\n-  void swap(basic_string& __s) {\n-    __STD::swap(_M_start, __s._M_start);\n-    __STD::swap(_M_finish, __s._M_finish);\n-    __STD::swap(_M_end_of_storage, __s._M_end_of_storage);\n-  }\n-\n-public:                         // Conversion to C string.\n-\n-  const _CharT* c_str() const { return _M_start; }\n-  const _CharT* data()  const { return _M_start; }\n-\n-public:                         // find.\n-\n-  size_type find(const basic_string& __s, size_type __pos = 0) const \n-    { return find(__s.begin(), __pos, __s.size()); }\n-\n-  size_type find(const _CharT* __s, size_type __pos = 0) const \n-    { return find(__s, __pos, _Traits::length(__s)); }\n-\n-  size_type find(const _CharT* __s, size_type __pos, size_type __n) const;\n-  size_type find(_CharT __c, size_type __pos = 0) const;\n-\n-public:                         // rfind.\n-\n-  size_type rfind(const basic_string& __s, size_type __pos = npos) const \n-    { return rfind(__s.begin(), __pos, __s.size()); }\n-\n-  size_type rfind(const _CharT* __s, size_type __pos = npos) const \n-    { return rfind(__s, __pos, _Traits::length(__s)); }\n-\n-  size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const;\n-  size_type rfind(_CharT __c, size_type __pos = npos) const;\n-\n-public:                         // find_first_of\n-  \n-  size_type find_first_of(const basic_string& __s, size_type __pos = 0) const \n-    { return find_first_of(__s.begin(), __pos, __s.size()); }\n-\n-  size_type find_first_of(const _CharT* __s, size_type __pos = 0) const \n-    { return find_first_of(__s, __pos, _Traits::length(__s)); }\n-\n-  size_type find_first_of(const _CharT* __s, size_type __pos, \n-                          size_type __n) const;\n-\n-  size_type find_first_of(_CharT __c, size_type __pos = 0) const \n-    { return find(__c, __pos); }\n-\n-public:                         // find_last_of\n-\n-  size_type find_last_of(const basic_string& __s,\n-                         size_type __pos = npos) const\n-    { return find_last_of(__s.begin(), __pos, __s.size()); }\n-\n-  size_type find_last_of(const _CharT* __s, size_type __pos = npos) const \n-    { return find_last_of(__s, __pos, _Traits::length(__s)); }\n-\n-  size_type find_last_of(const _CharT* __s, size_type __pos, \n-                         size_type __n) const;\n-\n-  size_type find_last_of(_CharT __c, size_type __pos = npos) const {\n-    return rfind(__c, __pos);\n-  }\n-\n-public:                         // find_first_not_of\n-\n-  size_type find_first_not_of(const basic_string& __s, \n-                              size_type __pos = 0) const \n-    { return find_first_not_of(__s.begin(), __pos, __s.size()); }\n-\n-  size_type find_first_not_of(const _CharT* __s, size_type __pos = 0) const \n-    { return find_first_not_of(__s, __pos, _Traits::length(__s)); }\n-\n-  size_type find_first_not_of(const _CharT* __s, size_type __pos,\n-                              size_type __n) const;\n-\n-  size_type find_first_not_of(_CharT __c, size_type __pos = 0) const;\n-\n-public:                         // find_last_not_of\n-\n-  size_type find_last_not_of(const basic_string& __s, \n-                             size_type __pos = npos) const\n-    { return find_last_not_of(__s.begin(), __pos, __s.size()); }\n-\n-  size_type find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n-    { return find_last_not_of(__s, __pos, _Traits::length(__s)); }\n-\n-  size_type find_last_not_of(const _CharT* __s, size_type __pos,\n-                             size_type __n) const;\n-\n-  size_type find_last_not_of(_CharT __c, size_type __pos = npos) const;\n-\n-public:                         // Substring.\n-\n-  basic_string substr(size_type __pos = 0, size_type __n = npos) const {\n-    if (__pos > size())\n-      _M_throw_out_of_range();\n-    return basic_string(_M_start + __pos, \n-                        _M_start + __pos + min(__n, size() - __pos));\n-  }\n-\n-public:                         // Compare\n-\n-  int compare(const basic_string& __s) const \n-    { return _M_compare(_M_start, _M_finish, __s._M_start, __s._M_finish); }\n-\n-  int compare(size_type __pos1, size_type __n1,\n-              const basic_string& __s) const {\n-    if (__pos1 > size())\n-      _M_throw_out_of_range();\n-    return _M_compare(_M_start + __pos1, \n-                      _M_start + __pos1 + min(__n1, size() - __pos1),\n-                      __s._M_start, __s._M_finish);\n-  }\n-    \n-  int compare(size_type __pos1, size_type __n1,\n-              const basic_string& __s,\n-              size_type __pos2, size_type __n2) const {\n-    if (__pos1 > size() || __pos2 > __s.size())\n-      _M_throw_out_of_range();\n-    return _M_compare(_M_start + __pos1, \n-                      _M_start + __pos1 + min(__n1, size() - __pos1),\n-                      __s._M_start + __pos2, \n-                      __s._M_start + __pos2 + min(__n2, size() - __pos2));\n-  }\n-\n-  int compare(const _CharT* __s) const {\n-    return _M_compare(_M_start, _M_finish, __s, __s + _Traits::length(__s));\n-  }\n-\n-  int compare(size_type __pos1, size_type __n1, const _CharT* __s) const {\n-    if (__pos1 > size())\n-      _M_throw_out_of_range();\n-    return _M_compare(_M_start + __pos1, \n-                      _M_start + __pos1 + min(__n1, size() - __pos1),\n-                      __s, __s + _Traits::length(__s));\n-  }\n-\n-  int compare(size_type __pos1, size_type __n1, const _CharT* __s,\n-              size_type __n2) const {\n-    if (__pos1 > size())\n-      _M_throw_out_of_range();\n-    return _M_compare(_M_start + __pos1, \n-                      _M_start + __pos1 + min(__n1, size() - __pos1),\n-                      __s, __s + __n2);\n-  }\n-\n-private:                        // Helper functions for compare.\n-  \n-  static int _M_compare(const _CharT* __f1, const _CharT* __l1,\n-                        const _CharT* __f2, const _CharT* __l2) {\n-    const ptrdiff_t __n1 = __l1 - __f1;\n-    const ptrdiff_t __n2 = __l2 - __f2;\n-    const int cmp = _Traits::compare(__f1, __f2, min(__n1, __n2));\n-    return cmp != 0 ? cmp : (__n1 < __n2 ? -1 : (__n1 > __n2 ? 1 : 0));\n-  }\n-\n-  friend bool operator< __STL_NULL_TMPL_ARGS (const basic_string&,\n-                                              const basic_string&);\n-  friend bool operator< __STL_NULL_TMPL_ARGS (const _CharT*,\n-                                              const basic_string&);\n-  friend bool operator< __STL_NULL_TMPL_ARGS (const basic_string&,\n-                                              const _CharT*);\n-};\n-\n-\n-\n-// ------------------------------------------------------------\n-// Non-inline declarations.\n-\n-template <class _CharT, class _Traits, class _Alloc> \n-const basic_string<_CharT,_Traits,_Alloc>::size_type \n-basic_string<_CharT,_Traits,_Alloc>::npos;\n-\n-// Change the string's capacity so that it is large enough to hold\n-//  at least __res_arg elements, plus the terminating _CharT().  Note that,\n-//  if __res_arg < capacity(), this member function may actually decrease\n-//  the string's capacity.\n-template <class _CharT, class _Traits, class _Alloc> \n-void basic_string<_CharT,_Traits,_Alloc>::reserve(size_type __res_arg) {\n-  if (__res_arg > max_size())\n-    _M_throw_length_error();\n-\n-  size_type __n = max(__res_arg, size()) + 1;\n-  pointer __new_start = _M_allocate(__n);\n-  pointer __new_finish = __new_start;\n-\n-  __STL_TRY {\n-    __new_finish = uninitialized_copy(_M_start, _M_finish, __new_start);\n-    construct(__new_finish);\n-  }\n-  __STL_UNWIND((destroy(__new_start, __new_finish), \n-                _M_deallocate(__new_start, __n)));\n-\n-  destroy(_M_start, _M_finish + 1);\n-  _M_deallocate_block();\n-  _M_start = __new_start;\n-  _M_finish = __new_finish;\n-  _M_end_of_storage = __new_start + __n;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc> \n-basic_string<_CharT,_Traits,_Alloc>& \n-basic_string<_CharT,_Traits,_Alloc>::append(size_type __n, _CharT __c) {\n-  if (__n > max_size() || size() > max_size() - __n)\n-    _M_throw_length_error();\n-  if (size() + __n > capacity())\n-    reserve(size() + max(size(), __n));\n-  if (__n > 0) {\n-    uninitialized_fill_n(_M_finish + 1, __n - 1, __c);\n-    __STL_TRY {\n-      construct(_M_finish + __n);\n-    }\n-    __STL_UNWIND(destroy(_M_finish + 1, _M_finish + __n));\n-    _Traits::assign(*_M_finish, __c);\n-    _M_finish += __n;\n-  }\n-  return *this;\n-}\n-\n-template <class _Tp, class _Traits, class _Alloc> \n-template <class _InputIterator>\n-basic_string<_Tp, _Traits, _Alloc>& \n-basic_string<_Tp, _Traits, _Alloc>::append(_InputIterator __first, \n-                                          _InputIterator __last,\n-                                          input_iterator_tag) {\n-  for ( ; __first != __last ; ++__first)\n-    push_back(*__first);\n-  return *this;\n-}\n-\n-template <class _Tp, class _Traits, class _Alloc> \n-template <class _ForwardIter>\n-basic_string<_Tp, _Traits, _Alloc>& \n-basic_string<_Tp, _Traits, _Alloc>::append(_ForwardIter __first, \n-                                           _ForwardIter __last,\n-                                           forward_iterator_tag) {\n-  if (__first != __last) {\n-    const size_type __old_size = size();\n-    typename iterator_traits<_ForwardIter>::difference_type __n \n-      = distance(__first, __last);\n-    if (__n > max_size() || __old_size > max_size() - __n)\n-      _M_throw_length_error();\n-    if (__old_size + __n > capacity()) {\n-      const size_type __len = __old_size +\n-                            max(__old_size, static_cast<size_type>(__n)) + 1;\n-      pointer __new_start = _M_allocate(__len);\n-      pointer __new_finish = __new_start;\n-      __STL_TRY {\n-        __new_finish = uninitialized_copy(_M_start, _M_finish, __new_start);\n-        __new_finish = uninitialized_copy(__first, __last, __new_finish);\n-        construct(__new_finish);\n-      }\n-      __STL_UNWIND((destroy(__new_start,__new_finish),\n-                    _M_deallocate(__new_start,__len)));\n-      destroy(_M_start, _M_finish + 1);\n-      _M_deallocate_block();\n-      _M_start = __new_start;\n-      _M_finish = __new_finish;\n-      _M_end_of_storage = __new_start + __len; \n-    }\n-    else {\n-      _ForwardIter __f1 = __first;\n-      ++__f1;\n-      uninitialized_copy(__f1, __last, _M_finish + 1);\n-      __STL_TRY {\n-        construct(_M_finish + __n);\n-      }\n-      __STL_UNWIND(destroy(_M_finish + 1, _M_finish + __n));\n-      _Traits::assign(*_M_finish, *__first);\n-      _M_finish += __n;\n-    }\n-  }\n-  return *this;  \n-}\n-\n-template <class _CharT, class _Traits, class _Alloc> \n-basic_string<_CharT,_Traits,_Alloc>& \n-basic_string<_CharT,_Traits,_Alloc>::assign(size_type __n, _CharT __c) {\n-  if (__n <= size()) {\n-    _Traits::assign(_M_start, __n, __c);\n-    erase(_M_start + __n, _M_finish);\n-  }\n-  else {\n-    _Traits::assign(_M_start, size(), __c);\n-    append(__n - size(), __c);\n-  }\n-  return *this;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc> \n-template <class _InputIter>\n-basic_string<_CharT,_Traits,_Alloc>& basic_string<_CharT,_Traits,_Alloc>\n-  ::_M_assign_dispatch(_InputIter __f, _InputIter __l, __false_type)\n-{\n-  pointer __cur = _M_start;\n-  while (__f != __l && __cur != _M_finish) {\n-    _Traits::assign(*__cur, *__f);\n-    ++__f;\n-    ++__cur;\n-  }\n-  if (__f == __l)\n-    erase(__cur, _M_finish);\n-  else\n-    append(__f, __l);\n-  return *this;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc> \n-basic_string<_CharT,_Traits,_Alloc>& \n-basic_string<_CharT,_Traits,_Alloc>::assign(const _CharT* __f, \n-                                            const _CharT* __l)\n-{\n-  const ptrdiff_t __n = __l - __f;\n-  if (__n <= size()) {\n-    _Traits::copy(_M_start, __f, __n);\n-    erase(_M_start + __n, _M_finish);\n-  }\n-  else {\n-    _Traits::copy(_M_start, __f, size());\n-    append(__f + size(), __l);\n-  }\n-  return *this;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-basic_string<_CharT,_Traits,_Alloc>::iterator \n-basic_string<_CharT,_Traits,_Alloc>\n-  ::_M_insert_aux(basic_string<_CharT,_Traits,_Alloc>::iterator __p,\n-                  _CharT __c)\n-{\n-  iterator __new_pos = __p;\n-  if (_M_finish + 1 < _M_end_of_storage) {\n-    construct(_M_finish + 1);\n-    _Traits::move(__p + 1, __p, _M_finish - __p);\n-    _Traits::assign(*__p, __c);\n-    ++_M_finish;\n-  }\n-  else {\n-    const size_type __old_len = size();\n-    const size_type __len = __old_len +\n-                            max(__old_len, static_cast<size_type>(1)) + 1;\n-    iterator __new_start = _M_allocate(__len);\n-    iterator __new_finish = __new_start;\n-    __STL_TRY {\n-      __new_pos = uninitialized_copy(_M_start, __p, __new_start);\n-      construct(__new_pos, __c);\n-      __new_finish = __new_pos + 1;\n-      __new_finish = uninitialized_copy(__p, _M_finish, __new_finish);\n-      construct(__new_finish);\n-    }\n-    __STL_UNWIND((destroy(__new_start,__new_finish), \n-                  _M_deallocate(__new_start,__len)));\n-    destroy(_M_start, _M_finish + 1);\n-    _M_deallocate_block();\n-    _M_start = __new_start;\n-    _M_finish = __new_finish;\n-    _M_end_of_storage = __new_start + __len;\n-  }\n-  return __new_pos;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-void basic_string<_CharT,_Traits,_Alloc>\n-  ::insert(basic_string<_CharT,_Traits,_Alloc>::iterator __position,\n-           size_t __n, _CharT __c)\n-{\n-  if (__n != 0) {\n-    if (size_type(_M_end_of_storage - _M_finish) >= __n + 1) {\n-      const size_type __elems_after = _M_finish - __position;\n-      iterator __old_finish = _M_finish;\n-      if (__elems_after >= __n) {\n-        uninitialized_copy((_M_finish - __n) + 1, _M_finish + 1,\n-                           _M_finish + 1);\n-        _M_finish += __n;\n-        _Traits::move(__position + __n,\n-                      __position, (__elems_after - __n) + 1);\n-        _Traits::assign(__position, __n, __c);\n-      }\n-      else {\n-        uninitialized_fill_n(_M_finish + 1, __n - __elems_after - 1, __c);\n-        _M_finish += __n - __elems_after;\n-        __STL_TRY {\n-          uninitialized_copy(__position, __old_finish + 1, _M_finish);\n-          _M_finish += __elems_after;\n-        }\n-        __STL_UNWIND((destroy(__old_finish + 1, _M_finish), \n-                      _M_finish = __old_finish));\n-        _Traits::assign(__position, __elems_after + 1, __c);\n-      }\n-    }\n-    else {\n-      const size_type __old_size = size();        \n-      const size_type __len = __old_size + max(__old_size, __n) + 1;\n-      iterator __new_start = _M_allocate(__len);\n-      iterator __new_finish = __new_start;\n-      __STL_TRY {\n-        __new_finish = uninitialized_copy(_M_start, __position, __new_start);\n-        __new_finish = uninitialized_fill_n(__new_finish, __n, __c);\n-        __new_finish = uninitialized_copy(__position, _M_finish,\n-                                          __new_finish);\n-        construct(__new_finish);\n-      }\n-      __STL_UNWIND((destroy(__new_start,__new_finish),\n-                    _M_deallocate(__new_start,__len)));\n-      destroy(_M_start, _M_finish + 1);\n-      _M_deallocate_block();\n-      _M_start = __new_start;\n-      _M_finish = __new_finish;\n-      _M_end_of_storage = __new_start + __len;    \n-    }\n-  }\n-}\n-\n-template <class _Tp, class _Traits, class _Alloc>\n-template <class _InputIter>\n-void basic_string<_Tp, _Traits, _Alloc>::insert(iterator __p,\n-                                                _InputIter __first, \n-                                                _InputIter __last,\n-                                                input_iterator_tag)\n-{\n-  for ( ; __first != __last; ++__first) {\n-    __p = insert(__p, *__first);\n-    ++__p;\n-  }\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-template <class _ForwardIter>\n-void \n-basic_string<_CharT,_Traits,_Alloc>::insert(iterator __position,\n-                                           _ForwardIter __first, \n-                                           _ForwardIter __last,\n-                                           forward_iterator_tag)\n-{\n-  if (__first != __last) {\n-    const difference_type __n = distance(__first, __last);\n-    if (_M_end_of_storage - _M_finish >= __n + 1) {\n-      const difference_type __elems_after = _M_finish - __position;\n-      iterator __old_finish = _M_finish;\n-      if (__elems_after >= __n) {\n-        uninitialized_copy((_M_finish - __n) + 1, _M_finish + 1,\n-                           _M_finish + 1);\n-        _M_finish += __n;\n-        _Traits::move(__position + __n,\n-                      __position, (__elems_after - __n) + 1);\n-        _M_copy(__first, __last, __position);\n-      }\n-      else {\n-        _ForwardIter __mid = __first;\n-        advance(__mid, __elems_after + 1);\n-        uninitialized_copy(__mid, __last, _M_finish + 1);\n-        _M_finish += __n - __elems_after;\n-        __STL_TRY {\n-          uninitialized_copy(__position, __old_finish + 1, _M_finish);\n-          _M_finish += __elems_after;\n-        }\n-        __STL_UNWIND((destroy(__old_finish + 1, _M_finish), \n-                      _M_finish = __old_finish));\n-        _M_copy(__first, __mid, __position);\n-      }\n-    }\n-    else {\n-      const size_type __old_size = size();        \n-      const size_type __len\n-        = __old_size + max(__old_size, static_cast<size_type>(__n)) + 1;\n-      pointer __new_start = _M_allocate(__len);\n-      pointer __new_finish = __new_start;\n-      __STL_TRY {\n-        __new_finish = uninitialized_copy(_M_start, __position, __new_start);\n-        __new_finish = uninitialized_copy(__first, __last, __new_finish);\n-        __new_finish\n-          = uninitialized_copy(__position, _M_finish, __new_finish);\n-        construct(__new_finish);\n-      }\n-      __STL_UNWIND((destroy(__new_start,__new_finish),\n-                    _M_deallocate(__new_start,__len)));\n-      destroy(_M_start, _M_finish + 1);\n-      _M_deallocate_block();\n-      _M_start = __new_start;\n-      _M_finish = __new_finish;\n-      _M_end_of_storage = __new_start + __len; \n-    }\n-  }\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-basic_string<_CharT,_Traits,_Alloc>&\n-basic_string<_CharT,_Traits,_Alloc>\n-  ::replace(iterator __first, iterator __last, size_type __n, _CharT __c)\n-{\n-  const size_type __len = static_cast<size_type>(__last - __first);\n-  if (__len >= __n) {\n-    _Traits::assign(__first, __n, __c);\n-    erase(__first + __n, __last);\n-  }\n-  else {\n-    _Traits::assign(__first, __len, __c);\n-    insert(__last, __n - __len, __c);\n-  }\n-  return *this;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-template <class _InputIter>\n-basic_string<_CharT,_Traits,_Alloc>&\n-basic_string<_CharT,_Traits,_Alloc>\n-  ::replace(iterator __first, iterator __last, _InputIter __f, _InputIter __l,\n-            input_iterator_tag) \n-{\n-  for ( ; __first != __last && __f != __l; ++__first, ++__f)\n-    _Traits::assign(*__first, *__f);\n-\n-  if (__f == __l)\n-    erase(__first, __last);\n-  else\n-    insert(__last, __f, __l);\n-  return *this;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-template <class _ForwardIter>\n-basic_string<_CharT,_Traits,_Alloc>&\n-basic_string<_CharT,_Traits,_Alloc>\n-  ::replace(iterator __first, iterator __last,\n-            _ForwardIter __f, _ForwardIter __l,\n-            forward_iterator_tag) \n-{\n-    const typename iterator_traits<_ForwardIter>::difference_type __n =\n-      distance(__f, __l);\n-    const difference_type __len = __last - __first;\n-    if (__len >= __n) {\n-      _M_copy(__f, __l, __first);\n-      erase(__first + __n, __last);\n-    }\n-    else {\n-      _ForwardIter m = __f;\n-      advance(m, __len);\n-      _M_copy(__f, m, __first);\n-      insert(__last, m, __l);\n-    }\n-    return *this;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-basic_string<_CharT,_Traits,_Alloc>::size_type\n-basic_string<_CharT,_Traits,_Alloc>\n-  ::find(const _CharT* __s, size_type __pos, size_type __n) const \n-{\n-  if (__pos >= size())\n-    return npos;\n-  else {\n-    const const_iterator __result =\n-      search(_M_start + __pos, _M_finish, \n-             __s, __s + __n, _Eq_traits<_Traits>());\n-    return __result != _M_finish ? __result - begin() : npos;\n-  }\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-basic_string<_CharT,_Traits,_Alloc>::size_type\n-basic_string<_CharT,_Traits,_Alloc>\n-  ::find(_CharT __c, size_type __pos) const \n-{\n-  if (__pos >= size())\n-    return npos;\n-  else {\n-    const const_iterator __result =\n-      find_if(_M_start + __pos, _M_finish,\n-              bind2nd(_Eq_traits<_Traits>(), __c));\n-    return __result != _M_finish ? __result - begin() : npos;\n-  }\n-}    \n-\n-template <class _CharT, class _Traits, class _Alloc>\n-basic_string<_CharT,_Traits,_Alloc>::size_type\n-basic_string<_CharT,_Traits,_Alloc>\n-  ::rfind(const _CharT* __s, size_type __pos, size_type __n) const \n-{\n-  const size_t __len = size();\n-\n-  if (__n > __len)\n-    return npos;\n-  else if (__n == 0)\n-    return min(__len, __pos);\n-  else {\n-    const const_iterator __last = begin() + min(__len - __n, __pos) + __n;\n-    const const_iterator __result = find_end(begin(), __last,\n-                                           __s, __s + __n,\n-                                           _Eq_traits<_Traits>());\n-    return __result != __last ? __result - begin() : npos;\n-  }\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-basic_string<_CharT,_Traits,_Alloc>::size_type\n-basic_string<_CharT,_Traits,_Alloc>\n-  ::rfind(_CharT __c, size_type __pos) const \n-{\n-  const size_type __len = size();\n-\n-  if (__len < 1)\n-    return npos;\n-  else {\n-    const const_iterator __last = begin() + min(__len - 1, __pos) + 1;\n-    const_reverse_iterator __rresult =\n-      find_if(const_reverse_iterator(__last), rend(),\n-              bind2nd(_Eq_traits<_Traits>(), __c));\n-    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;\n-  }\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-basic_string<_CharT,_Traits,_Alloc>::size_type\n-basic_string<_CharT,_Traits,_Alloc>\n-  ::find_first_of(const _CharT* __s, size_type __pos, size_type __n) const\n-{\n-  if (__pos >= size())\n-    return npos;\n-  else {\n-    const const_iterator __result = std::find_first_of(begin() + __pos, end(),\n-                                                     __s, __s + __n,\n-                                                     _Eq_traits<_Traits>());\n-    return __result != _M_finish ? __result - begin() : npos;\n-  }\n-}\n-\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-basic_string<_CharT,_Traits,_Alloc>::size_type\n-basic_string<_CharT,_Traits,_Alloc>\n-  ::find_last_of(const _CharT* __s, size_type __pos, size_type __n) const\n-{\n-  const size_type __len = size();\n-\n-  if (__len < 1)\n-    return npos;\n-  else {\n-    const const_iterator __last = _M_start + min(__len - 1, __pos) + 1;\n-    const const_reverse_iterator __rresult =\n-      std::find_first_of(const_reverse_iterator(__last), rend(),\n-                         __s, __s + __n,\n-                         _Eq_traits<_Traits>());\n-    return __rresult != rend() ? (__rresult.base() - 1) - _M_start : npos;\n-  }\n-}\n-\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-basic_string<_CharT,_Traits,_Alloc>::size_type\n-basic_string<_CharT,_Traits,_Alloc>\n-  ::find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const\n-{\n-  if (__pos > size())\n-    return npos;\n-  else {\n-    const_iterator __result = find_if(_M_start + __pos, _M_finish,\n-                                _Not_within_traits<_Traits>(__s, __s + __n));\n-    return __result != _M_finish ? __result - _M_start : npos;\n-  }\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-basic_string<_CharT,_Traits,_Alloc>::size_type\n-basic_string<_CharT,_Traits,_Alloc>\n-  ::find_first_not_of(_CharT __c, size_type __pos) const\n-{\n-  if (__pos > size())\n-    return npos;\n-  else {\n-    const_iterator __result\n-      = find_if(begin() + __pos, end(),\n-                not1(bind2nd(_Eq_traits<_Traits>(), __c)));\n-    return __result != _M_finish ? __result - begin() : npos;\n-  }\n-}    \n-\n-template <class _CharT, class _Traits, class _Alloc>\n-basic_string<_CharT,_Traits,_Alloc>::size_type\n-basic_string<_CharT,_Traits,_Alloc>\n-  ::find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const \n-{\n-\n-  const size_type __len = size();\n-\n-  if (__len < 1)\n-    return npos;\n-  else {\n-    const const_iterator __last = begin() + min(__len - 1, __pos) + 1;\n-    const const_reverse_iterator __rresult =\n-      find_if(const_reverse_iterator(__last), rend(),\n-              _Not_within_traits<_Traits>(__s, __s + __n));\n-    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;\n-  }\n-}\n-\n-template <class _Tp, class _Traits, class _Alloc>\n-basic_string<_Tp, _Traits, _Alloc>::size_type\n-basic_string<_Tp, _Traits, _Alloc>\n-  ::find_last_not_of(_Tp __c, size_type __pos) const \n-{\n-  const size_type __len = size();\n-\n-  if (__len < 1)\n-    return npos;\n-  else {\n-    const const_iterator __last = begin() + min(__len - 1, __pos) + 1;\n-    const_reverse_iterator __rresult =\n-      find_if(const_reverse_iterator(__last), rend(),\n-              not1(bind2nd(_Eq_traits<_Traits>(), __c)));\n-    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;\n-  }\n-}\n-\n-// ------------------------------------------------------------\n-// Non-member functions.\n-\n-// Operator+\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline basic_string<_CharT,_Traits,_Alloc>\n-operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,\n-          const basic_string<_CharT,_Traits,_Alloc>& __y)\n-{\n-  typedef basic_string<_CharT,_Traits,_Alloc> _Str;\n-  typedef typename _Str::_Reserve_t _Reserve_t;\n-  _Str __result(_Reserve_t(), __x.size() + __y.size(), __x.get_allocator());\n-  __result.append(__x);\n-  __result.append(__y);\n-  return __result;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline basic_string<_CharT,_Traits,_Alloc>\n-operator+(const _CharT* __s,\n-          const basic_string<_CharT,_Traits,_Alloc>& __y) {\n-  typedef basic_string<_CharT,_Traits,_Alloc> _Str;\n-  typedef typename _Str::_Reserve_t _Reserve_t;\n-  const size_t __n = _Traits::length(__s);\n-  _Str __result(_Reserve_t(), __n + __y.size());\n-  __result.append(__s, __s + __n);\n-  __result.append(__y);\n-  return __result;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline basic_string<_CharT,_Traits,_Alloc>\n-operator+(_CharT __c,\n-          const basic_string<_CharT,_Traits,_Alloc>& __y) {\n-  typedef basic_string<_CharT,_Traits,_Alloc> _Str;\n-  typedef typename _Str::_Reserve_t _Reserve_t;\n-  _Str __result(_Reserve_t(), 1 + __y.size());\n-  __result.push_back(__c);\n-  __result.append(__y);\n-  return __result;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline basic_string<_CharT,_Traits,_Alloc>\n-operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,\n-          const _CharT* __s) {\n-  typedef basic_string<_CharT,_Traits,_Alloc> _Str;\n-  typedef typename _Str::_Reserve_t _Reserve_t;\n-  const size_t __n = _Traits::length(__s);\n-  _Str __result(_Reserve_t(), __x.size() + __n, __x.get_allocator());\n-  __result.append(__x);\n-  __result.append(__s, __s + __n);\n-  return __result;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline basic_string<_CharT,_Traits,_Alloc>\n-operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,\n-          const _CharT __c) {\n-  typedef basic_string<_CharT,_Traits,_Alloc> _Str;\n-  typedef typename _Str::_Reserve_t _Reserve_t;\n-  _Str __result(_Reserve_t(), __x.size() + 1, __x.get_allocator());\n-  __result.append(__x);\n-  __result.push_back(__c);\n-  return __result;\n-}\n-\n-// Operator== and operator!=\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,\n-           const basic_string<_CharT,_Traits,_Alloc>& __y) {\n-  return __x.size() == __y.size() &&\n-         _Traits::compare(__x.data(), __y.data(), __x.size()) == 0;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator==(const _CharT* __s,\n-           const basic_string<_CharT,_Traits,_Alloc>& __y) {\n-  size_t __n = _Traits::length(__s);\n-  return __n == __y.size() && _Traits::compare(__s, __y.data(), __n) == 0;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,\n-           const _CharT* __s) {\n-  size_t __n = _Traits::length(__s);\n-  return __x.size() == __n && _Traits::compare(__x.data(), __s, __n) == 0;\n-}\n-\n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,\n-           const basic_string<_CharT,_Traits,_Alloc>& __y) {\n-  return !(__x == __y);\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator!=(const _CharT* __s,\n-           const basic_string<_CharT,_Traits,_Alloc>& __y) {\n-  return !(__s == __y);\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,\n-           const _CharT* __s) {\n-  return !(__x == __s);\n-}\n-\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-// Operator< (and also >, <=, and >=).\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,\n-          const basic_string<_CharT,_Traits,_Alloc>& __y) {\n-  return basic_string<_CharT,_Traits,_Alloc>\n-    ::_M_compare(__x.begin(), __x.end(), __y.begin(), __y.end()) < 0;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator<(const _CharT* __s,\n-          const basic_string<_CharT,_Traits,_Alloc>& __y) {\n-  size_t __n = _Traits::length(__s);\n-  return basic_string<_CharT,_Traits,_Alloc>\n-    ::_M_compare(__s, __s + __n, __y.begin(), __y.end()) < 0;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,\n-          const _CharT* __s) {\n-  size_t __n = _Traits::length(__s);\n-  return basic_string<_CharT,_Traits,_Alloc>\n-    ::_M_compare(__x.begin(), __x.end(), __s, __s + __n) < 0;\n-}\n-\n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,\n-          const basic_string<_CharT,_Traits,_Alloc>& __y) {\n-  return __y < __x;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator>(const _CharT* __s,\n-          const basic_string<_CharT,_Traits,_Alloc>& __y) {\n-  return __y < __s;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,\n-          const _CharT* __s) {\n-  return __s < __x;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,\n-           const basic_string<_CharT,_Traits,_Alloc>& __y) {\n-  return !(__y < __x);\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator<=(const _CharT* __s,\n-           const basic_string<_CharT,_Traits,_Alloc>& __y) {\n-  return !(__y < __s);\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,\n-           const _CharT* __s) {\n-  return !(__s < __x);\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,\n-           const basic_string<_CharT,_Traits,_Alloc>& __y) {\n-  return !(__x < __y);\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator>=(const _CharT* __s,\n-           const basic_string<_CharT,_Traits,_Alloc>& __y) {\n-  return !(__s < __y);\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline bool\n-operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,\n-           const _CharT* __s) {\n-  return !(__x < __s);\n-}\n-\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-// Swap.\n-\n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-inline void swap(basic_string<_CharT,_Traits,_Alloc>& __x,\n-                 basic_string<_CharT,_Traits,_Alloc>& __y) {\n-  __x.swap(__y);\n-}\n-\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-// I/O.  (Using istream and ostream only, as opposed to the \n-// basic_istream and basic_ostream templates.  The result is that\n-// these functions really don't make all that much sense except\n-// for basic_string<char>.)\n-\n-inline void __sgi_string_fill(ostream& __o, size_t __n)\n-{\n-  char __f = __o.fill();\n-  size_t __i;\n-\n-  for (__i = 0; __i < __n; __i++) __o.put(__f);\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-ostream& operator<<(ostream& __os, \n-                    const basic_string<_CharT,_Traits,_Alloc>& __s)\n-{\n-  size_t __n = __s.size();\n-  size_t __pad_len = 0;\n-  const bool __left = bool(__os.flags() & ios::left);\n-  const size_t __w = __os.width();\n-\n-  if (__w > 0) {\n-    __n = min(__w, __n);\n-    __pad_len = __w - __n;\n-  }\n-    \n-  if (!__left)\n-    __sgi_string_fill(__os, __pad_len);\n-  \n-  const size_t __nwritten = __os.rdbuf()->sputn(__s.data(), __n);\n-\n-  if (__left)\n-    __sgi_string_fill(__os, __pad_len);\n-\n-  if (__nwritten != __n)\n-    __os.clear(__os.rdstate() | ios::failbit);\n-\n-  __os.width(0);\n-  return __os;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-istream& operator>>(istream& __is, basic_string<_CharT,_Traits,_Alloc>& __s)\n-{\n-\n-  if (__is.flags() & ios::skipws) {\n-    _CharT __c;\n-    do \n-      __is.get(__c);\n-    while (__is && isspace(__c));\n-    if (__is)\n-      __is.putback(__c);\n-  }\n-\n-  // If we arrive at end of file (or fail for some other reason) while\n-  // still discarding whitespace, then we don't try to read the string.\n-  if (__is) {\n-    __s.clear();\n-\n-    size_t __n = __is.width();\n-    if (__n == 0)\n-      __n = static_cast<size_t>(-1);\n-    else\n-      __s.reserve(__n);\n-\n-    while (__n-- > 0) {\n-      _CharT __c;\n-      __is.get(__c);\n-      if (!__is) \n-        break;\n-      else if (isspace(__c)) {\n-        __is.putback(__c);\n-        break;\n-      }\n-      else\n-        __s.push_back(__c);\n-    }\n-    \n-    // If we have successfully read some characters, and then arrive\n-    // at end of file, the stream should still be marked good.  Note\n-    // that we only clear errors that are due to EOF, not other kinds \n-    // of errors.\n-    if (__s.size() != 0 && __is.eof())\n-      __is.clear((~ios::eofbit & ~ios::failbit) & __is.rdstate());\n-  }\n-\n-  __is.width(0);\n-  return __is;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>    \n-istream& getline(istream& __is,\n-                 basic_string<_CharT,_Traits,_Alloc>& __s,\n-                 _CharT __delim = '\\n') {\n-  size_t __nread = 0;\n-  if (__is) {\n-    __s.clear();\n-\n-    _CharT __c;\n-    while (__nread < __s.max_size() && __is.get(__c)) {\n-      ++__nread;\n-      if (!_Traits::eq(__c, __delim)) \n-        __s.push_back(__c);\n-      else\n-        break;                  // Character is extracted but not appended.\n-    }\n-  }\n-\n-  if (__nread == 0 || __nread >= __s.max_size())\n-    __is.clear(__is.rdstate() | ios::failbit);\n-  return __is;\n-}\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-void _S_string_copy(const basic_string<_CharT,_Traits,_Alloc>& __s,\n-                    _CharT* __buf,\n-                    size_t __n)\n-{\n-  if (__n > 0) {\n-    const size_t __n = min(__n - 1, __s.size());\n-    copy(__s.begin(), __s.begin() + __n, __buf);\n-    __buf[__n] = _CharT();\n-  }\n-}\n-\n-// ------------------------------------------------------------\n-// Typedefs\n-\n-typedef basic_string<char> string;\n-typedef basic_string<wchar_t> wstring;\n-\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE\n-\n-#include <stl_hash_fun.h>\n-\n-__STL_BEGIN_NAMESPACE\n-\n-template <class _CharT, class _Traits, class _Alloc>\n-struct hash<basic_string<_CharT,_Traits,_Alloc> > {\n-  size_t operator()(const basic_string<_CharT,_Traits,_Alloc>& __s) const {\n-    unsigned long __h = 0; \n-    for (basic_string<_CharT,_Traits,_Alloc>::const_iterator __i\n-           = __s.begin();\n-         __i != __s.end();\n-         ++__i)\n-      __h = 5*__h + *__i;\n-    return size_t(__h);\n-  }\n-};\n-\n-__STL_END_NAMESPACE\n-\n-#endif /* __SGI_STL_STRING */\n-\n-\n-// Local Variables:\n-// mode:C++\n-// End:\n-"}]}