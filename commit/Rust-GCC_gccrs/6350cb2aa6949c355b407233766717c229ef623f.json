{"sha": "6350cb2aa6949c355b407233766717c229ef623f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM1MGNiMmFhNjk0OWMzNTViNDA3MjMzNzY2NzE3YzIyOWVmNjIzZg==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-09T09:47:31Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-09T09:47:31Z"}, "message": "[multiple changes]\n\n2017-11-09  Piotr Trojanek  <trojanek@adacore.com>\n\n\t* lib-xref-spark_specific.adb (Add_SPARK_Xrefs): Ignore loop parameters\n\tin expression funtions that are expanded into variables.\n\n2017-11-09  Piotr Trojanek  <trojanek@adacore.com>\n\n\t* sem_util.adb: Minor whitespace cleanup.\n\n2017-11-09  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* libgnarl/s-taprop__qnx.adb: Refine aarch64-qnx. Use the POSIX\n\ts-taprop version rather than a custom one.\n\t* sigtramp-qnx.c (aarch64-qnx): Implement the signal trampoline.\n\nFrom-SVN: r254563", "tree": {"sha": "41a971c28f58dd598e13fe71d782797eb5b39ec9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41a971c28f58dd598e13fe71d782797eb5b39ec9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6350cb2aa6949c355b407233766717c229ef623f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6350cb2aa6949c355b407233766717c229ef623f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6350cb2aa6949c355b407233766717c229ef623f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6350cb2aa6949c355b407233766717c229ef623f/comments", "author": null, "committer": null, "parents": [{"sha": "136ca74eb91c225ff18a7b08e0e7fd027b88517c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/136ca74eb91c225ff18a7b08e0e7fd027b88517c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/136ca74eb91c225ff18a7b08e0e7fd027b88517c"}], "stats": {"total": 1721, "additions": 82, "deletions": 1639}, "files": [{"sha": "281964029d70c734097f353fb1c1d39c2034c88e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6350cb2aa6949c355b407233766717c229ef623f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6350cb2aa6949c355b407233766717c229ef623f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6350cb2aa6949c355b407233766717c229ef623f", "patch": "@@ -1,3 +1,18 @@\n+2017-11-09  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* lib-xref-spark_specific.adb (Add_SPARK_Xrefs): Ignore loop parameters\n+\tin expression funtions that are expanded into variables.\n+\n+2017-11-09  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_util.adb: Minor whitespace cleanup.\n+\n+2017-11-09  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* libgnarl/s-taprop__qnx.adb: Refine aarch64-qnx. Use the POSIX\n+\ts-taprop version rather than a custom one.\n+\t* sigtramp-qnx.c (aarch64-qnx): Implement the signal trampoline.\n+\n 2017-11-08  Piotr Trojanek  <trojanek@adacore.com>\n \n \t* lib-xref.ads, lib-xref-spark_specific.adb"}, {"sha": "a30cb84b30f7281e0f98e9c583d3021586fd55c7", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6350cb2aa6949c355b407233766717c229ef623f/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6350cb2aa6949c355b407233766717c229ef623f/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=6350cb2aa6949c355b407233766717c229ef623f", "patch": "@@ -608,9 +608,11 @@ package body SPARK_Specific is\n               --  the analysis of the expanded body. We don't lose any globals\n               --  by discarding them, because such loop parameters can only be\n               --  accessed locally from within the expression function body.\n+              --  Note: some loop parameters are expanded into variables; they\n+              --  also must be ignored.\n \n               and then not\n-                (Ekind (Ref.Ent) = E_Loop_Parameter\n+                (Ekind_In (Ref.Ent, E_Loop_Parameter, E_Variable)\n                   and then Scope_Within\n                              (Ref.Ent, Unique_Entity (Ref.Ref_Scope))\n                   and then Is_Expression_Function (Ref.Ref_Scope))"}, {"sha": "85ebed799bd2a8aa55a6ebe08984275ee9111c4e", "filename": "gcc/ada/libgnarl/s-taprop__qnx.adb", "status": "removed", "additions": 0, "deletions": 1546, "changes": 1546, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ca74eb91c225ff18a7b08e0e7fd027b88517c/gcc%2Fada%2Flibgnarl%2Fs-taprop__qnx.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ca74eb91c225ff18a7b08e0e7fd027b88517c/gcc%2Fada%2Flibgnarl%2Fs-taprop__qnx.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__qnx.adb?ref=136ca74eb91c225ff18a7b08e0e7fd027b88517c", "patch": "@@ -1,1546 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the QNX/Neutrino version of this package\n-\n---  This package contains all the GNULL primitives that interface directly with\n---  the underlying OS.\n-\n---  Note: this file can only be used for POSIX compliant systems that implement\n---  SCHED_FIFO and Ceiling Locking correctly.\n-\n---  For configurations where SCHED_FIFO and priority ceiling are not a\n---  requirement, this file can also be used (e.g AiX threads)\n-\n-pragma Polling (Off);\n---  Turn off polling, we do not want ATC polling to take place during tasking\n---  operations. It causes infinite loops and other problems.\n-\n-with Ada.Unchecked_Conversion;\n-\n-with Interfaces.C;\n-\n-with System.Tasking.Debug;\n-with System.Interrupt_Management;\n-with System.OS_Constants;\n-with System.OS_Primitives;\n-with System.Task_Info;\n-\n-with System.Soft_Links;\n---  We use System.Soft_Links instead of System.Tasking.Initialization\n---  because the later is a higher level package that we shouldn't depend on.\n---  For example when using the restricted run time, it is replaced by\n---  System.Tasking.Restricted.Stages.\n-\n-package body System.Task_Primitives.Operations is\n-\n-   package OSC renames System.OS_Constants;\n-   package SSL renames System.Soft_Links;\n-\n-   use System.Tasking.Debug;\n-   use System.Tasking;\n-   use Interfaces.C;\n-   use System.OS_Interface;\n-   use System.Parameters;\n-   use System.OS_Primitives;\n-\n-   ----------------\n-   -- Local Data --\n-   ----------------\n-\n-   --  The followings are logically constants, but need to be initialized\n-   --  at run time.\n-\n-   Single_RTS_Lock : aliased RTS_Lock;\n-   --  This is a lock to allow only one thread of control in the RTS at\n-   --  a time; it is used to execute in mutual exclusion from all other tasks.\n-   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n-\n-   Environment_Task_Id : Task_Id;\n-   --  A variable to hold Task_Id for the environment task\n-\n-   Unblocked_Signal_Mask : aliased sigset_t;\n-   --  The set of signals that should be unblocked in all tasks\n-\n-   --  The followings are internal configuration constants needed\n-\n-   Next_Serial_Number : Task_Serial_Number := 100;\n-   --  We start at 100 (reserve some special values for using in error checks)\n-\n-   Time_Slice_Val : Integer;\n-   pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n-\n-   Dispatching_Policy : Character;\n-   pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n-\n-   Locking_Policy : Character;\n-   pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n-\n-   Foreign_Task_Elaborated : aliased Boolean := True;\n-   --  Used to identified fake tasks (i.e., non-Ada Threads)\n-\n-   Use_Alternate_Stack : constant Boolean := Alternate_Stack_Size /= 0;\n-   --  Whether to use an alternate signal stack for stack overflows\n-\n-   Abort_Handler_Installed : Boolean := False;\n-   --  True if a handler for the abort signal is installed\n-\n-   --------------------\n-   -- Local Packages --\n-   --------------------\n-\n-   package Specific is\n-\n-      procedure Initialize (Environment_Task : Task_Id);\n-      pragma Inline (Initialize);\n-      --  Initialize various data needed by this package\n-\n-      function Is_Valid_Task return Boolean;\n-      pragma Inline (Is_Valid_Task);\n-      --  Does executing thread have a TCB?\n-\n-      procedure Set (Self_Id : Task_Id);\n-      pragma Inline (Set);\n-      --  Set the self id for the current task\n-\n-      function Self return Task_Id;\n-      pragma Inline (Self);\n-      --  Return a pointer to the Ada Task Control Block of the calling task\n-\n-   end Specific;\n-\n-   package body Specific is separate;\n-   --  The body of this package is target specific\n-\n-   ----------------------------------\n-   -- ATCB allocation/deallocation --\n-   ----------------------------------\n-\n-   package body ATCB_Allocation is separate;\n-   --  The body of this package is shared across several targets\n-\n-   ---------------------------------\n-   -- Support for foreign threads --\n-   ---------------------------------\n-\n-   function Register_Foreign_Thread\n-     (Thread         : Thread_Id;\n-      Sec_Stack_Size : Size_Type := Unspecified_Size) return Task_Id;\n-   --  Allocate and initialize a new ATCB for the current Thread. The size of\n-   --  the secondary stack can be optionally specified.\n-\n-   function Register_Foreign_Thread\n-     (Thread         : Thread_Id;\n-      Sec_Stack_Size : Size_Type := Unspecified_Size)\n-     return Task_Id is separate;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Abort_Handler (Sig : Signal);\n-   --  Signal handler used to implement asynchronous abort.\n-   --  See also comment before body, below.\n-\n-   function To_Address is\n-     new Ada.Unchecked_Conversion (Task_Id, System.Address);\n-\n-   function GNAT_pthread_condattr_setup\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C,\n-     GNAT_pthread_condattr_setup, \"__gnat_pthread_condattr_setup\");\n-\n-   procedure Compute_Deadline\n-     (Time       : Duration;\n-      Mode       : ST.Delay_Modes;\n-      Check_Time : out Duration;\n-      Abs_Time   : out Duration;\n-      Rel_Time   : out Duration);\n-   --  Helper for Timed_Sleep and Timed_Delay: given a deadline specified by\n-   --  Time and Mode, compute the current clock reading (Check_Time), and the\n-   --  target absolute and relative clock readings (Abs_Time, Rel_Time). The\n-   --  epoch for Time depends on Mode; the epoch for Check_Time and Abs_Time\n-   --  is always that of CLOCK_RT_Ada.\n-\n-   -------------------\n-   -- Abort_Handler --\n-   -------------------\n-\n-   --  Target-dependent binding of inter-thread Abort signal to the raising of\n-   --  the Abort_Signal exception.\n-\n-   --  The technical issues and alternatives here are essentially the\n-   --  same as for raising exceptions in response to other signals\n-   --  (e.g. Storage_Error). See code and comments in the package body\n-   --  System.Interrupt_Management.\n-\n-   --  Some implementations may not allow an exception to be propagated out of\n-   --  a handler, and others might leave the signal or interrupt that invoked\n-   --  this handler masked after the exceptional return to the application\n-   --  code.\n-\n-   --  GNAT exceptions are originally implemented using setjmp()/longjmp(). On\n-   --  most UNIX systems, this will allow transfer out of a signal handler,\n-   --  which is usually the only mechanism available for implementing\n-   --  asynchronous handlers of this kind. However, some systems do not\n-   --  restore the signal mask on longjmp(), leaving the abort signal masked.\n-\n-   procedure Abort_Handler (Sig : Signal) is\n-      pragma Unreferenced (Sig);\n-\n-      T       : constant Task_Id := Self;\n-      Old_Set : aliased sigset_t;\n-\n-      Result : Interfaces.C.int;\n-      pragma Warnings (Off, Result);\n-\n-   begin\n-      --  It's not safe to raise an exception when using GCC ZCX mechanism.\n-      --  Note that we still need to install a signal handler, since in some\n-      --  cases (e.g. shutdown of the Server_Task in System.Interrupts) we\n-      --  need to send the Abort signal to a task.\n-\n-      if ZCX_By_Default then\n-         return;\n-      end if;\n-\n-      if T.Deferral_Level = 0\n-        and then T.Pending_ATC_Level < T.ATC_Nesting_Level and then\n-        not T.Aborting\n-      then\n-         T.Aborting := True;\n-\n-         --  Make sure signals used for RTS internal purpose are unmasked\n-\n-         Result := pthread_sigmask (SIG_UNBLOCK,\n-           Unblocked_Signal_Mask'Access, Old_Set'Access);\n-         pragma Assert (Result = 0);\n-\n-         raise Standard'Abort_Signal;\n-      end if;\n-   end Abort_Handler;\n-\n-   ----------------------\n-   -- Compute_Deadline --\n-   ----------------------\n-\n-   procedure Compute_Deadline\n-     (Time       : Duration;\n-      Mode       : ST.Delay_Modes;\n-      Check_Time : out Duration;\n-      Abs_Time   : out Duration;\n-      Rel_Time   : out Duration)\n-   is\n-   begin\n-      Check_Time := Monotonic_Clock;\n-\n-      --  Relative deadline\n-\n-      if Mode = Relative then\n-         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n-\n-         if Relative_Timed_Wait then\n-            Rel_Time := Duration'Min (Max_Sensible_Delay, Time);\n-         end if;\n-\n-         pragma Warnings (Off);\n-         --  Comparison \"OSC.CLOCK_RT_Ada = OSC.CLOCK_REALTIME\" is compile\n-         --  time known.\n-\n-      --  Absolute deadline specified using the tasking clock (CLOCK_RT_Ada)\n-\n-      elsif Mode = Absolute_RT\n-        or else OSC.CLOCK_RT_Ada = OSC.CLOCK_REALTIME\n-      then\n-         pragma Warnings (On);\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-\n-         if Relative_Timed_Wait then\n-            Rel_Time := Duration'Min (Max_Sensible_Delay, Time - Check_Time);\n-         end if;\n-\n-      --  Absolute deadline specified using the calendar clock, in the\n-      --  case where it is not the same as the tasking clock: compensate for\n-      --  difference between clock epochs (Base_Time - Base_Cal_Time).\n-\n-      else\n-         declare\n-            Cal_Check_Time : constant Duration := OS_Primitives.Clock;\n-            RT_Time        : constant Duration :=\n-                               Time + Check_Time - Cal_Check_Time;\n-\n-         begin\n-            Abs_Time :=\n-              Duration'Min (Check_Time + Max_Sensible_Delay, RT_Time);\n-\n-            if Relative_Timed_Wait then\n-               Rel_Time :=\n-                 Duration'Min (Max_Sensible_Delay, RT_Time - Check_Time);\n-            end if;\n-         end;\n-      end if;\n-   end Compute_Deadline;\n-\n-   -----------------\n-   -- Stack_Guard --\n-   -----------------\n-\n-   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n-      Stack_Base : constant Address := Get_Stack_Base (T.Common.LL.Thread);\n-      Page_Size  : Address;\n-      Res        : Interfaces.C.int;\n-\n-   begin\n-      if Stack_Base_Available then\n-\n-         --  Compute the guard page address\n-\n-         Page_Size := Address (Get_Page_Size);\n-         Res :=\n-           mprotect\n-             (Stack_Base - (Stack_Base mod Page_Size) + Page_Size,\n-              size_t (Page_Size),\n-              prot => (if On then PROT_ON else PROT_OFF));\n-         pragma Assert (Res = 0);\n-      end if;\n-   end Stack_Guard;\n-\n-   --------------------\n-   -- Get_Thread_Id  --\n-   --------------------\n-\n-   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n-   begin\n-      return T.Common.LL.Thread;\n-   end Get_Thread_Id;\n-\n-   ----------\n-   -- Self --\n-   ----------\n-\n-   function Self return Task_Id renames Specific.Self;\n-\n-   ---------------------\n-   -- Initialize_Lock --\n-   ---------------------\n-\n-   --  Note: mutexes and cond_variables needed per-task basis are initialized\n-   --  in Initialize_TCB and the Storage_Error is handled. Other mutexes (such\n-   --  as RTS_Lock, Memory_Lock...) used in RTS is initialized before any\n-   --  status change of RTS. Therefore raising Storage_Error in the following\n-   --  routines should be able to be handled safely.\n-\n-   procedure Initialize_Lock\n-     (Prio : System.Any_Priority;\n-      L    : not null access Lock)\n-   is\n-      Attributes : aliased pthread_mutexattr_t;\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      Result := pthread_mutexattr_init (Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      if Locking_Policy = 'C' then\n-         Result := pthread_mutexattr_setprotocol\n-           (Attributes'Access, PTHREAD_PRIO_PROTECT);\n-         pragma Assert (Result = 0);\n-\n-         Result := pthread_mutexattr_setprioceiling\n-            (Attributes'Access, Interfaces.C.int (Prio));\n-         pragma Assert (Result = 0);\n-\n-      elsif Locking_Policy = 'I' then\n-         Result := pthread_mutexattr_setprotocol\n-           (Attributes'Access, PTHREAD_PRIO_INHERIT);\n-         pragma Assert (Result = 0);\n-      end if;\n-\n-      Result := pthread_mutex_init (L.WO'Access, Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         Result := pthread_mutexattr_destroy (Attributes'Access);\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Attributes'Access);\n-      pragma Assert (Result = 0);\n-   end Initialize_Lock;\n-\n-   procedure Initialize_Lock\n-     (L : not null access RTS_Lock; Level : Lock_Level)\n-   is\n-      pragma Unreferenced (Level);\n-\n-      Attributes : aliased pthread_mutexattr_t;\n-      Result     : Interfaces.C.int;\n-\n-   begin\n-      Result := pthread_mutexattr_init (Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      if Locking_Policy = 'C' then\n-         Result := pthread_mutexattr_setprotocol\n-           (Attributes'Access, PTHREAD_PRIO_PROTECT);\n-         pragma Assert (Result = 0);\n-\n-         Result := pthread_mutexattr_setprioceiling\n-            (Attributes'Access, Interfaces.C.int (System.Any_Priority'Last));\n-         pragma Assert (Result = 0);\n-\n-      elsif Locking_Policy = 'I' then\n-         Result := pthread_mutexattr_setprotocol\n-           (Attributes'Access, PTHREAD_PRIO_INHERIT);\n-         pragma Assert (Result = 0);\n-      end if;\n-\n-      Result := pthread_mutex_init (L, Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         Result := pthread_mutexattr_destroy (Attributes'Access);\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Attributes'Access);\n-      pragma Assert (Result = 0);\n-   end Initialize_Lock;\n-\n-   -------------------\n-   -- Finalize_Lock --\n-   -------------------\n-\n-   procedure Finalize_Lock (L : not null access Lock) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_mutex_destroy (L.WO'Access);\n-      pragma Assert (Result = 0);\n-   end Finalize_Lock;\n-\n-   procedure Finalize_Lock (L : not null access RTS_Lock) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_mutex_destroy (L);\n-      pragma Assert (Result = 0);\n-   end Finalize_Lock;\n-\n-   ----------------\n-   -- Write_Lock --\n-   ----------------\n-\n-   procedure Write_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean)\n-   is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      Result := pthread_mutex_lock (L.WO'Access);\n-\n-      --  The cause of EINVAL is a priority ceiling violation\n-\n-      Ceiling_Violation := Result = EINVAL;\n-      pragma Assert (Result = 0 or else Ceiling_Violation);\n-   end Write_Lock;\n-\n-   procedure Write_Lock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_lock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Write_Lock;\n-\n-   procedure Write_Lock (T : Task_Id) is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Write_Lock;\n-\n-   ---------------\n-   -- Read_Lock --\n-   ---------------\n-\n-   procedure Read_Lock\n-     (L : not null access Lock; Ceiling_Violation : out Boolean) is\n-   begin\n-      Write_Lock (L, Ceiling_Violation);\n-   end Read_Lock;\n-\n-   ------------\n-   -- Unlock --\n-   ------------\n-\n-   procedure Unlock (L : not null access Lock) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_mutex_unlock (L.WO'Access);\n-      pragma Assert (Result = 0);\n-   end Unlock;\n-\n-   procedure Unlock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n-   is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_unlock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Unlock;\n-\n-   procedure Unlock (T : Task_Id) is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Unlock;\n-\n-   -----------------\n-   -- Set_Ceiling --\n-   -----------------\n-\n-   --  Dynamic priority ceilings are not supported by the underlying system\n-\n-   procedure Set_Ceiling\n-     (L    : not null access Lock;\n-      Prio : System.Any_Priority)\n-   is\n-      pragma Unreferenced (L, Prio);\n-   begin\n-      null;\n-   end Set_Ceiling;\n-\n-   -----------\n-   -- Sleep --\n-   -----------\n-\n-   procedure Sleep\n-     (Self_ID : Task_Id;\n-      Reason  : System.Tasking.Task_States)\n-   is\n-      pragma Unreferenced (Reason);\n-\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      Result :=\n-        pthread_cond_wait\n-          (cond  => Self_ID.Common.LL.CV'Access,\n-           mutex => (if Single_Lock\n-                     then Single_RTS_Lock'Access\n-                     else Self_ID.Common.LL.L'Access));\n-\n-      --  EINTR is not considered a failure\n-\n-      pragma Assert (Result = 0 or else Result = EINTR);\n-   end Sleep;\n-\n-   -----------------\n-   -- Timed_Sleep --\n-   -----------------\n-\n-   --  This is for use within the run-time system, so abort is\n-   --  assumed to be already deferred, and the caller should be\n-   --  holding its own ATCB lock.\n-\n-   procedure Timed_Sleep\n-     (Self_ID  : Task_Id;\n-      Time     : Duration;\n-      Mode     : ST.Delay_Modes;\n-      Reason   : Task_States;\n-      Timedout : out Boolean;\n-      Yielded  : out Boolean)\n-   is\n-      pragma Unreferenced (Reason);\n-\n-      Base_Time  : Duration;\n-      Check_Time : Duration;\n-      Abs_Time   : Duration;\n-      Rel_Time   : Duration;\n-\n-      Request    : aliased timespec;\n-      Result     : Interfaces.C.int;\n-\n-   begin\n-      Timedout := True;\n-      Yielded := False;\n-\n-      Compute_Deadline\n-        (Time       => Time,\n-         Mode       => Mode,\n-         Check_Time => Check_Time,\n-         Abs_Time   => Abs_Time,\n-         Rel_Time   => Rel_Time);\n-      Base_Time := Check_Time;\n-\n-      if Abs_Time > Check_Time then\n-         Request :=\n-           To_Timespec (if Relative_Timed_Wait then Rel_Time else Abs_Time);\n-\n-         loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n-\n-            Result :=\n-              pthread_cond_timedwait\n-                (cond    => Self_ID.Common.LL.CV'Access,\n-                 mutex   => (if Single_Lock\n-                             then Single_RTS_Lock'Access\n-                             else Self_ID.Common.LL.L'Access),\n-                 abstime => Request'Access);\n-\n-            Check_Time := Monotonic_Clock;\n-            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n-\n-            if Result = 0 or Result = EINTR then\n-\n-               --  Somebody may have called Wakeup for us\n-\n-               Timedout := False;\n-               exit;\n-            end if;\n-\n-            pragma Assert (Result = ETIMEDOUT);\n-         end loop;\n-      end if;\n-   end Timed_Sleep;\n-\n-   -----------------\n-   -- Timed_Delay --\n-   -----------------\n-\n-   --  This is for use in implementing delay statements, so we assume the\n-   --  caller is abort-deferred but is holding no locks.\n-\n-   procedure Timed_Delay\n-     (Self_ID : Task_Id;\n-      Time    : Duration;\n-      Mode    : ST.Delay_Modes)\n-   is\n-      Base_Time  : Duration;\n-      Check_Time : Duration;\n-      Abs_Time   : Duration;\n-      Rel_Time   : Duration;\n-      Request    : aliased timespec;\n-\n-      Result : Interfaces.C.int;\n-      pragma Warnings (Off, Result);\n-\n-   begin\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n-      Write_Lock (Self_ID);\n-\n-      Compute_Deadline\n-        (Time       => Time,\n-         Mode       => Mode,\n-         Check_Time => Check_Time,\n-         Abs_Time   => Abs_Time,\n-         Rel_Time   => Rel_Time);\n-      Base_Time := Check_Time;\n-\n-      if Abs_Time > Check_Time then\n-         Request :=\n-           To_Timespec (if Relative_Timed_Wait then Rel_Time else Abs_Time);\n-         Self_ID.Common.State := Delay_Sleep;\n-\n-         loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n-\n-            Result :=\n-              pthread_cond_timedwait\n-                (cond    => Self_ID.Common.LL.CV'Access,\n-                 mutex   => (if Single_Lock\n-                             then Single_RTS_Lock'Access\n-                             else Self_ID.Common.LL.L'Access),\n-                 abstime => Request'Access);\n-\n-            Check_Time := Monotonic_Clock;\n-            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n-\n-            pragma Assert (Result = 0\n-                             or else Result = ETIMEDOUT\n-                             or else Result = EINTR);\n-         end loop;\n-\n-         Self_ID.Common.State := Runnable;\n-      end if;\n-\n-      Unlock (Self_ID);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n-      Result := sched_yield;\n-   end Timed_Delay;\n-\n-   ---------------------\n-   -- Monotonic_Clock --\n-   ---------------------\n-\n-   function Monotonic_Clock return Duration is\n-      TS     : aliased timespec;\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := clock_gettime\n-        (clock_id => OSC.CLOCK_RT_Ada, tp => TS'Unchecked_Access);\n-      pragma Assert (Result = 0);\n-      return To_Duration (TS);\n-   end Monotonic_Clock;\n-\n-   -------------------\n-   -- RT_Resolution --\n-   -------------------\n-\n-   function RT_Resolution return Duration is\n-      TS     : aliased timespec;\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := clock_getres (OSC.CLOCK_REALTIME, TS'Unchecked_Access);\n-      pragma Assert (Result = 0);\n-\n-      return To_Duration (TS);\n-   end RT_Resolution;\n-\n-   ------------\n-   -- Wakeup --\n-   ------------\n-\n-   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n-      pragma Unreferenced (Reason);\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_cond_signal (T.Common.LL.CV'Access);\n-      pragma Assert (Result = 0);\n-   end Wakeup;\n-\n-   -----------\n-   -- Yield --\n-   -----------\n-\n-   procedure Yield (Do_Yield : Boolean := True) is\n-      Result : Interfaces.C.int;\n-      pragma Unreferenced (Result);\n-   begin\n-      if Do_Yield then\n-         Result := sched_yield;\n-      end if;\n-   end Yield;\n-\n-   ------------------\n-   -- Set_Priority --\n-   ------------------\n-\n-   procedure Set_Priority\n-     (T                   : Task_Id;\n-      Prio                : System.Any_Priority;\n-      Loss_Of_Inheritance : Boolean := False)\n-   is\n-      pragma Unreferenced (Loss_Of_Inheritance);\n-\n-      Result : Interfaces.C.int;\n-      Param  : aliased struct_sched_param;\n-\n-      function Get_Policy (Prio : System.Any_Priority) return Character;\n-      pragma Import (C, Get_Policy, \"__gnat_get_specific_dispatching\");\n-      --  Get priority specific dispatching policy\n-\n-      Priority_Specific_Policy : constant Character := Get_Policy (Prio);\n-      --  Upper case first character of the policy name corresponding to the\n-      --  task as set by a Priority_Specific_Dispatching pragma.\n-\n-   begin\n-      T.Common.Current_Priority := Prio;\n-      Param.sched_priority := To_Target_Priority (Prio);\n-\n-      if Time_Slice_Supported\n-        and then (Dispatching_Policy = 'R'\n-                  or else Priority_Specific_Policy = 'R'\n-                  or else Time_Slice_Val > 0)\n-      then\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_RR, Param'Access);\n-\n-      elsif Dispatching_Policy = 'F'\n-        or else Priority_Specific_Policy = 'F'\n-        or else Time_Slice_Val = 0\n-      then\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n-\n-      else\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n-      end if;\n-\n-      pragma Assert (Result = 0);\n-   end Set_Priority;\n-\n-   ------------------\n-   -- Get_Priority --\n-   ------------------\n-\n-   function Get_Priority (T : Task_Id) return System.Any_Priority is\n-   begin\n-      return T.Common.Current_Priority;\n-   end Get_Priority;\n-\n-   ----------------\n-   -- Enter_Task --\n-   ----------------\n-\n-   procedure Enter_Task (Self_ID : Task_Id) is\n-   begin\n-      Self_ID.Common.LL.Thread := pthread_self;\n-      Self_ID.Common.LL.LWP := lwp_self;\n-\n-      Specific.Set (Self_ID);\n-\n-      if Use_Alternate_Stack then\n-         declare\n-            Stack  : aliased stack_t;\n-            Result : Interfaces.C.int;\n-         begin\n-            Stack.ss_sp    := Self_ID.Common.Task_Alternate_Stack;\n-            Stack.ss_size  := Alternate_Stack_Size;\n-            Stack.ss_flags := 0;\n-            Result := sigaltstack (Stack'Access, null);\n-            pragma Assert (Result = 0);\n-         end;\n-      end if;\n-   end Enter_Task;\n-\n-   -------------------\n-   -- Is_Valid_Task --\n-   -------------------\n-\n-   function Is_Valid_Task return Boolean renames Specific.Is_Valid_Task;\n-\n-   -----------------------------\n-   -- Register_Foreign_Thread --\n-   -----------------------------\n-\n-   function Register_Foreign_Thread return Task_Id is\n-   begin\n-      if Is_Valid_Task then\n-         return Self;\n-      else\n-         return Register_Foreign_Thread (pthread_self);\n-      end if;\n-   end Register_Foreign_Thread;\n-\n-   --------------------\n-   -- Initialize_TCB --\n-   --------------------\n-\n-   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n-      Mutex_Attr : aliased pthread_mutexattr_t;\n-      Result     : Interfaces.C.int;\n-      Cond_Attr  : aliased pthread_condattr_t;\n-\n-   begin\n-      --  Give the task a unique serial number\n-\n-      Self_ID.Serial_Number := Next_Serial_Number;\n-      Next_Serial_Number := Next_Serial_Number + 1;\n-      pragma Assert (Next_Serial_Number /= 0);\n-\n-      if not Single_Lock then\n-         Result := pthread_mutexattr_init (Mutex_Attr'Access);\n-         pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-         if Result = 0 then\n-            if Locking_Policy = 'C' then\n-               Result :=\n-                 pthread_mutexattr_setprotocol\n-                   (Mutex_Attr'Access,\n-                    PTHREAD_PRIO_PROTECT);\n-               pragma Assert (Result = 0);\n-\n-               Result :=\n-                 pthread_mutexattr_setprioceiling\n-                   (Mutex_Attr'Access,\n-                    Interfaces.C.int (System.Any_Priority'Last));\n-               pragma Assert (Result = 0);\n-\n-            elsif Locking_Policy = 'I' then\n-               Result :=\n-                 pthread_mutexattr_setprotocol\n-                   (Mutex_Attr'Access,\n-                    PTHREAD_PRIO_INHERIT);\n-               pragma Assert (Result = 0);\n-            end if;\n-\n-            Result :=\n-              pthread_mutex_init\n-                (Self_ID.Common.LL.L'Access,\n-                 Mutex_Attr'Access);\n-            pragma Assert (Result = 0 or else Result = ENOMEM);\n-         end if;\n-\n-         if Result /= 0 then\n-            Succeeded := False;\n-            return;\n-         end if;\n-\n-         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-\n-      Result := pthread_condattr_init (Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = 0 then\n-         Result := GNAT_pthread_condattr_setup (Cond_Attr'Access);\n-         pragma Assert (Result = 0);\n-\n-         Result :=\n-           pthread_cond_init\n-             (Self_ID.Common.LL.CV'Access, Cond_Attr'Access);\n-         pragma Assert (Result = 0 or else Result = ENOMEM);\n-      end if;\n-\n-      if Result = 0 then\n-         Succeeded := True;\n-      else\n-         if not Single_Lock then\n-            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-            pragma Assert (Result = 0);\n-         end if;\n-\n-         Succeeded := False;\n-      end if;\n-\n-      Result := pthread_condattr_destroy (Cond_Attr'Access);\n-      pragma Assert (Result = 0);\n-   end Initialize_TCB;\n-\n-   -----------------\n-   -- Create_Task --\n-   -----------------\n-\n-   procedure Create_Task\n-     (T          : Task_Id;\n-      Wrapper    : System.Address;\n-      Stack_Size : System.Parameters.Size_Type;\n-      Priority   : System.Any_Priority;\n-      Succeeded  : out Boolean)\n-   is\n-      Attributes          : aliased pthread_attr_t;\n-      Adjusted_Stack_Size : Interfaces.C.size_t;\n-      Page_Size           : constant Interfaces.C.size_t :=\n-                              Interfaces.C.size_t (Get_Page_Size);\n-      Result              : Interfaces.C.int;\n-\n-      function Thread_Body_Access is new\n-        Ada.Unchecked_Conversion (System.Address, Thread_Body);\n-\n-      use System.Task_Info;\n-\n-   begin\n-      Adjusted_Stack_Size :=\n-         Interfaces.C.size_t (Stack_Size + Alternate_Stack_Size);\n-\n-      if Stack_Base_Available then\n-\n-         --  If Stack Checking is supported then allocate 2 additional pages:\n-\n-         --  In the worst case, stack is allocated at something like\n-         --  N * Get_Page_Size - epsilon, we need to add the size for 2 pages\n-         --  to be sure the effective stack size is greater than what\n-         --  has been asked.\n-\n-         Adjusted_Stack_Size := Adjusted_Stack_Size + 2 * Page_Size;\n-      end if;\n-\n-      --  Round stack size as this is required by some OSes (Darwin)\n-\n-      Adjusted_Stack_Size := Adjusted_Stack_Size + Page_Size - 1;\n-      Adjusted_Stack_Size :=\n-        Adjusted_Stack_Size - Adjusted_Stack_Size mod Page_Size;\n-\n-      Result := pthread_attr_init (Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Succeeded := False;\n-         return;\n-      end if;\n-\n-      Result :=\n-        pthread_attr_setdetachstate\n-          (Attributes'Access, PTHREAD_CREATE_DETACHED);\n-      pragma Assert (Result = 0);\n-\n-      Result :=\n-        pthread_attr_setstacksize\n-          (Attributes'Access, Adjusted_Stack_Size);\n-      pragma Assert (Result = 0);\n-\n-      if T.Common.Task_Info /= Default_Scope then\n-         case T.Common.Task_Info is\n-            when System.Task_Info.Process_Scope =>\n-               Result :=\n-                 pthread_attr_setscope\n-                   (Attributes'Access, PTHREAD_SCOPE_PROCESS);\n-\n-            when System.Task_Info.System_Scope =>\n-               Result :=\n-                 pthread_attr_setscope\n-                   (Attributes'Access, PTHREAD_SCOPE_SYSTEM);\n-\n-            when System.Task_Info.Default_Scope =>\n-               Result := 0;\n-         end case;\n-\n-         pragma Assert (Result = 0);\n-      end if;\n-\n-      --  Since the initial signal mask of a thread is inherited from the\n-      --  creator, and the Environment task has all its signals masked, we\n-      --  do not need to manipulate caller's signal mask at this point.\n-      --  All tasks in RTS will have All_Tasks_Mask initially.\n-\n-      --  Note: the use of Unrestricted_Access in the following call is needed\n-      --  because otherwise we have an error of getting a access-to-volatile\n-      --  value which points to a non-volatile object. But in this case it is\n-      --  safe to do this, since we know we have no problems with aliasing and\n-      --  Unrestricted_Access bypasses this check.\n-\n-      Result := pthread_create\n-        (T.Common.LL.Thread'Unrestricted_Access,\n-         Attributes'Access,\n-         Thread_Body_Access (Wrapper),\n-         To_Address (T));\n-      pragma Assert (Result = 0 or else Result = EAGAIN);\n-\n-      Succeeded := Result = 0;\n-\n-      Result := pthread_attr_destroy (Attributes'Access);\n-      pragma Assert (Result = 0);\n-\n-      if Succeeded then\n-         Set_Priority (T, Priority);\n-      end if;\n-   end Create_Task;\n-\n-   ------------------\n-   -- Finalize_TCB --\n-   ------------------\n-\n-   procedure Finalize_TCB (T : Task_Id) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-\n-      Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n-      pragma Assert (Result = 0);\n-\n-      if T.Known_Tasks_Index /= -1 then\n-         Known_Tasks (T.Known_Tasks_Index) := null;\n-      end if;\n-\n-      ATCB_Allocation.Free_ATCB (T);\n-   end Finalize_TCB;\n-\n-   ---------------\n-   -- Exit_Task --\n-   ---------------\n-\n-   procedure Exit_Task is\n-   begin\n-      --  Mark this task as unknown, so that if Self is called, it won't\n-      --  return a dangling pointer.\n-\n-      Specific.Set (null);\n-   end Exit_Task;\n-\n-   ----------------\n-   -- Abort_Task --\n-   ----------------\n-\n-   procedure Abort_Task (T : Task_Id) is\n-      Result : Interfaces.C.int;\n-   begin\n-      if Abort_Handler_Installed then\n-         Result :=\n-           pthread_kill\n-             (T.Common.LL.Thread,\n-              Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Abort_Task;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (S : in out Suspension_Object) is\n-      Mutex_Attr : aliased pthread_mutexattr_t;\n-      Cond_Attr  : aliased pthread_condattr_t;\n-      Result     : Interfaces.C.int;\n-\n-   begin\n-      --  Initialize internal state (always to False (RM D.10 (6)))\n-\n-      S.State := False;\n-      S.Waiting := False;\n-\n-      --  Initialize internal mutex\n-\n-      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-         pragma Assert (Result = 0);\n-\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-      pragma Assert (Result = 0);\n-\n-      --  Initialize internal condition variable\n-\n-      Result := pthread_condattr_init (Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Result := pthread_mutex_destroy (S.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         --  Storage_Error is propagated as intended if the allocation of the\n-         --  underlying OS entities fails.\n-\n-         raise Storage_Error;\n-\n-      else\n-         Result := GNAT_pthread_condattr_setup (Cond_Attr'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-\n-      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Result := pthread_mutex_destroy (S.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         Result := pthread_condattr_destroy (Cond_Attr'Access);\n-         pragma Assert (Result = 0);\n-\n-         --  Storage_Error is propagated as intended if the allocation of the\n-         --  underlying OS entities fails.\n-\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_condattr_destroy (Cond_Attr'Access);\n-      pragma Assert (Result = 0);\n-   end Initialize;\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      --  Destroy internal mutex\n-\n-      Result := pthread_mutex_destroy (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      --  Destroy internal condition variable\n-\n-      Result := pthread_cond_destroy (S.CV'Access);\n-      pragma Assert (Result = 0);\n-   end Finalize;\n-\n-   -------------------\n-   -- Current_State --\n-   -------------------\n-\n-   function Current_State (S : Suspension_Object) return Boolean is\n-   begin\n-      --  We do not want to use lock on this read operation. State is marked\n-      --  as Atomic so that we ensure that the value retrieved is correct.\n-\n-      return S.State;\n-   end Current_State;\n-\n-   ---------------\n-   -- Set_False --\n-   ---------------\n-\n-   procedure Set_False (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      SSL.Abort_Defer.all;\n-\n-      Result := pthread_mutex_lock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      S.State := False;\n-\n-      Result := pthread_mutex_unlock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      SSL.Abort_Undefer.all;\n-   end Set_False;\n-\n-   --------------\n-   -- Set_True --\n-   --------------\n-\n-   procedure Set_True (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      SSL.Abort_Defer.all;\n-\n-      Result := pthread_mutex_lock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      --  If there is already a task waiting on this suspension object then\n-      --  we resume it, leaving the state of the suspension object to False,\n-      --  as it is specified in (RM D.10(9)). Otherwise, it just leaves\n-      --  the state to True.\n-\n-      if S.Waiting then\n-         S.Waiting := False;\n-         S.State := False;\n-\n-         Result := pthread_cond_signal (S.CV'Access);\n-         pragma Assert (Result = 0);\n-\n-      else\n-         S.State := True;\n-      end if;\n-\n-      Result := pthread_mutex_unlock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      SSL.Abort_Undefer.all;\n-   end Set_True;\n-\n-   ------------------------\n-   -- Suspend_Until_True --\n-   ------------------------\n-\n-   procedure Suspend_Until_True (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      SSL.Abort_Defer.all;\n-\n-      Result := pthread_mutex_lock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      if S.Waiting then\n-\n-         --  Program_Error must be raised upon calling Suspend_Until_True\n-         --  if another task is already waiting on that suspension object\n-         --  (RM D.10(10)).\n-\n-         Result := pthread_mutex_unlock (S.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         SSL.Abort_Undefer.all;\n-\n-         raise Program_Error;\n-\n-      else\n-         --  Suspend the task if the state is False. Otherwise, the task\n-         --  continues its execution, and the state of the suspension object\n-         --  is set to False (ARM D.10 par. 9).\n-\n-         if S.State then\n-            S.State := False;\n-         else\n-            S.Waiting := True;\n-\n-            loop\n-               --  Loop in case pthread_cond_wait returns earlier than expected\n-               --  (e.g. in case of EINTR caused by a signal).\n-\n-               Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n-               pragma Assert (Result = 0 or else Result = EINTR);\n-\n-               exit when not S.Waiting;\n-            end loop;\n-         end if;\n-\n-         Result := pthread_mutex_unlock (S.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         SSL.Abort_Undefer.all;\n-      end if;\n-   end Suspend_Until_True;\n-\n-   ----------------\n-   -- Check_Exit --\n-   ----------------\n-\n-   --  Dummy version\n-\n-   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n-      pragma Unreferenced (Self_ID);\n-   begin\n-      return True;\n-   end Check_Exit;\n-\n-   --------------------\n-   -- Check_No_Locks --\n-   --------------------\n-\n-   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n-      pragma Unreferenced (Self_ID);\n-   begin\n-      return True;\n-   end Check_No_Locks;\n-\n-   ----------------------\n-   -- Environment_Task --\n-   ----------------------\n-\n-   function Environment_Task return Task_Id is\n-   begin\n-      return Environment_Task_Id;\n-   end Environment_Task;\n-\n-   --------------\n-   -- Lock_RTS --\n-   --------------\n-\n-   procedure Lock_RTS is\n-   begin\n-      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n-   end Lock_RTS;\n-\n-   ----------------\n-   -- Unlock_RTS --\n-   ----------------\n-\n-   procedure Unlock_RTS is\n-   begin\n-      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n-   end Unlock_RTS;\n-\n-   ------------------\n-   -- Suspend_Task --\n-   ------------------\n-\n-   function Suspend_Task\n-     (T           : ST.Task_Id;\n-      Thread_Self : Thread_Id) return Boolean\n-   is\n-   begin\n-      if T.Common.LL.Thread /= Thread_Self then\n-         return pthread_kill (T.Common.LL.Thread, SIGSTOP) = 0;\n-      else\n-         return True;\n-      end if;\n-   end Suspend_Task;\n-\n-   -----------------\n-   -- Resume_Task --\n-   -----------------\n-\n-   function Resume_Task\n-     (T           : ST.Task_Id;\n-      Thread_Self : Thread_Id) return Boolean\n-   is\n-   begin\n-      if T.Common.LL.Thread /= Thread_Self then\n-         return pthread_kill (T.Common.LL.Thread, SIGCONT) = 0;\n-      else\n-         return True;\n-      end if;\n-   end Resume_Task;\n-\n-   --------------------\n-   -- Stop_All_Tasks --\n-   --------------------\n-\n-   procedure Stop_All_Tasks is\n-   begin\n-      null;\n-   end Stop_All_Tasks;\n-\n-   ---------------\n-   -- Stop_Task --\n-   ---------------\n-\n-   function Stop_Task (T : ST.Task_Id) return Boolean is\n-      pragma Unreferenced (T);\n-   begin\n-      return False;\n-   end Stop_Task;\n-\n-   -------------------\n-   -- Continue_Task --\n-   -------------------\n-\n-   function Continue_Task (T : ST.Task_Id) return Boolean is\n-      pragma Unreferenced (T);\n-   begin\n-      return False;\n-   end Continue_Task;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (Environment_Task : Task_Id) is\n-      act     : aliased struct_sigaction;\n-      old_act : aliased struct_sigaction;\n-      Tmp_Set : aliased sigset_t;\n-      Result  : Interfaces.C.int;\n-\n-      function State\n-        (Int : System.Interrupt_Management.Interrupt_ID) return Character;\n-      pragma Import (C, State, \"__gnat_get_interrupt_state\");\n-      --  Get interrupt state.  Defined in a-init.c\n-      --  The input argument is the interrupt number,\n-      --  and the result is one of the following:\n-\n-      Default : constant Character := 's';\n-      --    'n'   this interrupt not set by any Interrupt_State pragma\n-      --    'u'   Interrupt_State pragma set state to User\n-      --    'r'   Interrupt_State pragma set state to Runtime\n-      --    's'   Interrupt_State pragma set state to System (use \"default\"\n-      --           system handler)\n-\n-   begin\n-      Environment_Task_Id := Environment_Task;\n-\n-      Interrupt_Management.Initialize;\n-\n-      --  Prepare the set of signals that should unblocked in all tasks\n-\n-      Result := sigemptyset (Unblocked_Signal_Mask'Access);\n-      pragma Assert (Result = 0);\n-\n-      for J in Interrupt_Management.Interrupt_ID loop\n-         if System.Interrupt_Management.Keep_Unmasked (J) then\n-            Result := sigaddset (Unblocked_Signal_Mask'Access, Signal (J));\n-            pragma Assert (Result = 0);\n-         end if;\n-      end loop;\n-\n-      --  Initialize the lock used to synchronize chain of all ATCBs\n-\n-      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n-\n-      Specific.Initialize (Environment_Task);\n-\n-      if Use_Alternate_Stack then\n-         Environment_Task.Common.Task_Alternate_Stack :=\n-           Alternate_Stack'Address;\n-      end if;\n-\n-      --  Make environment task known here because it doesn't go through\n-      --  Activate_Tasks, which does it for all other tasks.\n-\n-      Known_Tasks (Known_Tasks'First) := Environment_Task;\n-      Environment_Task.Known_Tasks_Index := Known_Tasks'First;\n-\n-      Enter_Task (Environment_Task);\n-\n-      if State\n-          (System.Interrupt_Management.Abort_Task_Interrupt) /= Default\n-      then\n-         act.sa_flags := 0;\n-         act.sa_handler := Abort_Handler'Address;\n-\n-         Result := sigemptyset (Tmp_Set'Access);\n-         pragma Assert (Result = 0);\n-         act.sa_mask := Tmp_Set;\n-\n-         Result :=\n-           sigaction\n-             (Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n-              act'Unchecked_Access,\n-              old_act'Unchecked_Access);\n-         pragma Assert (Result = 0);\n-         Abort_Handler_Installed := True;\n-      end if;\n-   end Initialize;\n-\n-   -----------------------\n-   -- Set_Task_Affinity --\n-   -----------------------\n-\n-   procedure Set_Task_Affinity (T : ST.Task_Id) is\n-      pragma Unreferenced (T);\n-\n-   begin\n-      --  Setting task affinity is not supported by the underlying system\n-\n-      null;\n-   end Set_Task_Affinity;\n-\n-end System.Task_Primitives.Operations;"}, {"sha": "33730ce083ceafcd02884d8b4fc349a95d9a7075", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6350cb2aa6949c355b407233766717c229ef623f/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6350cb2aa6949c355b407233766717c229ef623f/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=6350cb2aa6949c355b407233766717c229ef623f", "patch": "@@ -19536,9 +19536,9 @@ package body Sem_Util is\n       N : constant Entity_Id := Make_Temporary (Sloc_Value, Id_Char);\n \n    begin\n-      Set_Ekind          (N, Kind);\n-      Set_Is_Internal    (N, True);\n-      Append_Entity      (N, Scope_Id);\n+      Set_Ekind       (N, Kind);\n+      Set_Is_Internal (N, True);\n+      Append_Entity   (N, Scope_Id);\n \n       if Kind in Type_Kind then\n          Init_Size_Align (N);"}, {"sha": "67081c95a22fe9867e2febf2d5a33022b50f4b66", "filename": "gcc/ada/sigtramp-qnx.c", "status": "modified", "additions": 61, "deletions": 89, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6350cb2aa6949c355b407233766717c229ef623f/gcc%2Fada%2Fsigtramp-qnx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6350cb2aa6949c355b407233766717c229ef623f/gcc%2Fada%2Fsigtramp-qnx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-qnx.c?ref=6350cb2aa6949c355b407233766717c229ef623f", "patch": "@@ -74,14 +74,14 @@ void __gnat_sigtramp (int signo, void *si, void *ucontext,\n /* Trampoline body block\n    ---------------------  */\n \n+#define COMMON_CFI(REG) \\\n+  \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_OFFSET_##REG)\n+\n #ifdef __x86_64__\n /*****************************************\n  *               x86-64                  *\n  *****************************************/\n \n-#define COMMON_CFI(REG) \\\n-  \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_##REG)\n-\n // CFI register numbers\n #define REGNO_RAX 0\n #define REGNO_RDX 1\n@@ -98,27 +98,27 @@ void __gnat_sigtramp (int signo, void *si, void *ucontext,\n #define REGNO_R12 12\n #define REGNO_R13 13\n #define REGNO_R14 14\n-#define REGNO_R15 15\n+#define REGNO_R15 15 /* Used as CFA */\n #define REGNO_RPC 16 /* aka %rip */\n \n //  Registers offset from the regset structure\n-#define REG_RDI 0x00\n-#define REG_RSI 0x08\n-#define REG_RDX 0x10\n-#define REG_R10 0x18\n-#define REG_R8  0x20\n-#define REG_R9  0x28\n-#define REG_RAX 0x30\n-#define REG_RBX 0x38\n-#define REG_RBP 0x40\n-#define REG_RCX 0x48\n-#define REG_R11 0x50\n-#define REG_R12 0x58\n-#define REG_R13 0x60\n-#define REG_R14 0x68\n-#define REG_R15 0x70\n-#define REG_RPC 0x78 /* RIP */\n-#define REG_RSP 0x90\n+#define REG_OFFSET_RDI 0x00\n+#define REG_OFFSET_RSI 0x08\n+#define REG_OFFSET_RDX 0x10\n+#define REG_OFFSET_R10 0x18\n+#define REG_OFFSET_R8  0x20\n+#define REG_OFFSET_R9  0x28\n+#define REG_OFFSET_RAX 0x30\n+#define REG_OFFSET_RBX 0x38\n+#define REG_OFFSET_RBP 0x40\n+#define REG_OFFSET_RCX 0x48\n+#define REG_OFFSET_R11 0x50\n+#define REG_OFFSET_R12 0x58\n+#define REG_OFFSET_R13 0x60\n+#define REG_OFFSET_R14 0x68\n+#define REG_OFFSET_R15 0x70\n+#define REG_OFFSET_RPC 0x78 /* RIP */\n+#define REG_OFFSET_RSP 0x90\n \n #define CFI_COMMON_REGS \\\n CR(\"# CFI for common registers\\n\") \\\n@@ -163,47 +163,20 @@ TCR(\"ret\")\n  *               Aarch64                 *\n  *****************************************/\n \n-#define UC_MCONTEXT_SS 16\n-\n+/* CFA reg: any callee saved register will do */\n #define CFA_REG  19\n-#define BASE_REG 20\n-\n-#define DW_CFA_def_cfa    0x0c\n-#define DW_CFA_expression 0x10\n-\n-#define DW_OP_breg(n)     0x70+(n)\n \n-#define REG_REGNO_GR(n)   n\n-#define REG_REGNO_PC      30\n+/* General purpose registers */\n+#define REG_OFFSET_GR(n)     (n * 8)\n+#define REGNO_GR(n)   n\n \n-/* The first byte of the SLEB128 value of the offset.  */\n-#define REG_OFFSET_GR(n)         (UC_MCONTEXT_SS + n * 8)\n-#define REG_OFFSET_LONG_GR(n)    (UC_MCONTEXT_SS + n * 8 + 128)\n-#define REG_OFFSET_LONG128_GR(n) (UC_MCONTEXT_SS + (n - 16) * 8 + 128)\n-#define REG_OFFSET_LONG256_GR(n) (UC_MCONTEXT_SS + (n - 32) * 8 + 128)\n-\n-#define REG_OFFSET_LONG256_PC    REG_OFFSET_LONG256_GR(32)\n+/* point to the ELR value of the mcontext registers list */\n+#define REG_OFFSET_ELR           (32 * 8)\n+#define REGNO_PC      30\n \n #define CFI_DEF_CFA \\\n   TCR(\".cfi_def_cfa \" S(CFA_REG) \", 0\")\n \n-/* We need 4 variants depending on the offset: 0+, 64+, 128+, 256+.  */\n-#define COMMON_CFI(REG) \\\n-  \".cfi_escape \" S(DW_CFA_expression) \",\" S(REG_REGNO_##REG) \",2,\" \\\n-  S(DW_OP_breg(BASE_REG)) \",\" S(REG_OFFSET_##REG)\n-\n-#define COMMON_LONG_CFI(REG) \\\n-  \".cfi_escape \" S(DW_CFA_expression) \",\" S(REG_REGNO_##REG) \",3,\" \\\n-  S(DW_OP_breg(BASE_REG)) \",\" S(REG_OFFSET_LONG_##REG) \",0\"\n-\n-#define COMMON_LONG128_CFI(REG) \\\n-  \".cfi_escape \" S(DW_CFA_expression) \",\" S(REG_REGNO_##REG) \",3,\" \\\n-  S(DW_OP_breg(BASE_REG)) \",\" S(REG_OFFSET_LONG128_##REG) \",1\"\n-\n-#define COMMON_LONG256_CFI(REG) \\\n-  \".cfi_escape \" S(DW_CFA_expression) \",\" S(REG_REGNO_##REG) \",3,\" \\\n-  S(DW_OP_breg(BASE_REG)) \",\" S(REG_OFFSET_LONG256_##REG) \",2\"\n-\n #define CFI_COMMON_REGS \\\n   CR(\"# CFI for common registers\\n\") \\\n   TCR(COMMON_CFI(GR(0)))  \\\n@@ -212,48 +185,47 @@ TCR(\"ret\")\n   TCR(COMMON_CFI(GR(3)))  \\\n   TCR(COMMON_CFI(GR(4)))  \\\n   TCR(COMMON_CFI(GR(5)))  \\\n-  TCR(COMMON_LONG_CFI(GR(6)))  \\\n-  TCR(COMMON_LONG_CFI(GR(7)))  \\\n-  TCR(COMMON_LONG_CFI(GR(8)))  \\\n-  TCR(COMMON_LONG_CFI(GR(9)))  \\\n-  TCR(COMMON_LONG_CFI(GR(10))) \\\n-  TCR(COMMON_LONG_CFI(GR(11))) \\\n-  TCR(COMMON_LONG_CFI(GR(12))) \\\n-  TCR(COMMON_LONG_CFI(GR(13))) \\\n-  TCR(COMMON_LONG128_CFI(GR(14))) \\\n-  TCR(COMMON_LONG128_CFI(GR(15))) \\\n-  TCR(COMMON_LONG128_CFI(GR(16))) \\\n-  TCR(COMMON_LONG128_CFI(GR(17))) \\\n-  TCR(COMMON_LONG128_CFI(GR(18))) \\\n-  TCR(COMMON_LONG128_CFI(GR(19))) \\\n-  TCR(COMMON_LONG128_CFI(GR(20))) \\\n-  TCR(COMMON_LONG128_CFI(GR(21))) \\\n-  TCR(COMMON_LONG128_CFI(GR(22))) \\\n-  TCR(COMMON_LONG128_CFI(GR(23))) \\\n-  TCR(COMMON_LONG128_CFI(GR(24))) \\\n-  TCR(COMMON_LONG128_CFI(GR(25))) \\\n-  TCR(COMMON_LONG128_CFI(GR(26))) \\\n-  TCR(COMMON_LONG128_CFI(GR(27))) \\\n-  TCR(COMMON_LONG128_CFI(GR(28))) \\\n-  TCR(COMMON_LONG128_CFI(GR(29))) \\\n-  TCR(COMMON_LONG256_CFI(PC))\n+  TCR(COMMON_CFI(GR(6)))  \\\n+  TCR(COMMON_CFI(GR(7)))  \\\n+  TCR(COMMON_CFI(GR(8)))  \\\n+  TCR(COMMON_CFI(GR(9)))  \\\n+  TCR(COMMON_CFI(GR(10))) \\\n+  TCR(COMMON_CFI(GR(11))) \\\n+  TCR(COMMON_CFI(GR(12))) \\\n+  TCR(COMMON_CFI(GR(13))) \\\n+  TCR(COMMON_CFI(GR(14))) \\\n+  TCR(COMMON_CFI(GR(15))) \\\n+  TCR(COMMON_CFI(GR(16))) \\\n+  TCR(COMMON_CFI(GR(17))) \\\n+  TCR(COMMON_CFI(GR(18))) \\\n+  TCR(COMMON_CFI(GR(19))) \\\n+  TCR(COMMON_CFI(GR(20))) \\\n+  TCR(COMMON_CFI(GR(21))) \\\n+  TCR(COMMON_CFI(GR(22))) \\\n+  TCR(COMMON_CFI(GR(23))) \\\n+  TCR(COMMON_CFI(GR(24))) \\\n+  TCR(COMMON_CFI(GR(25))) \\\n+  TCR(COMMON_CFI(GR(26))) \\\n+  TCR(COMMON_CFI(GR(27))) \\\n+  TCR(COMMON_CFI(GR(28))) \\\n+  TCR(COMMON_CFI(GR(29))) \\\n+  TCR(\".cfi_offset \" S(REGNO_PC) \",\" S(REG_OFFSET_ELR)) \\\n+  TCR(\".cfi_return_column \" S(REGNO_PC))\n \n #define SIGTRAMP_BODY \\\n   CFI_DEF_CFA \\\n   CFI_COMMON_REGS \\\n   TCR(\"# Push FP and LR on stack\") \\\n-  TCR(\"stp x29, x30, [sp, #-32]!\") \\\n-  TCR(\"stp x\" S(CFA_REG) \", x\" S(BASE_REG) \", [sp, #16]\") \\\n-  TCR(\"mov x29, sp\") \\\n-  TCR(\"# Load the saved value of the stack pointer as CFA\") \\\n-  TCR(\"ldr x\" S(CFA_REG) \", [x2, #\" S(REG_OFFSET_GR(31)) \"]\") \\\n-  TCR(\"# Use x\" S(BASE_REG) \" as base register for the CFI\") \\\n-  TCR(\"mov x\" S(BASE_REG) \", x2\") \\\n+  TCR(\"stp x29, x30, [sp, #-16]!\") \\\n+  TCR(\"# Push CFA register on stack\") \\\n+  TCR(\"str x\" S(CFA_REG) \", [sp, #-8]!\" \\\n+  TCR(\"# Set the CFA register to x2 value\") \\\n+  TCR(\"mov x\" S(CFA_REG) \", x2\") \\\n   TCR(\"# Call the handler\") \\\n   TCR(\"blr x3\") \\\n   TCR(\"# Release our frame and return (should never get here!).\") \\\n-  TCR(\"ldp x\" S(CFA_REG) \", x\" S(BASE_REG)\" , [sp, #16]\") \\\n-  TCR(\"ldp x29, x30, [sp], 32\") \\\n+  TCR(\"ldr x\" S(CFA_REG) \" , [sp], 8\") \\\n+  TCR(\"ldp x29, x30, [sp], 16\") \\\n   TCR(\"ret\")\n \n #endif /* AARCH64 */"}]}