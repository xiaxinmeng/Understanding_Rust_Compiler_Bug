{"sha": "ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRmMGZjNmM5ZjFlYjg3NDdjOWNmNmI2OWU0OGYxMWY3Nzk2MzJkMg==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-03-07T09:52:56Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-03-07T09:52:56Z"}, "message": "resolve.cc (_Jv_SearchMethodInClass): New function.\n\n2000-03-07  Bryce McKinlay  <bryce@albatross.co.nz>\n\n        * resolve.cc (_Jv_SearchMethodInClass): New function.\n        (_Jv_ResolvePoolEntry): Search superinterfaces for interface\n        methods.\n        * java/lang/Class.h (_Jv_SearchMethodInClass): New prototype.\n\n2000-03-07  Bryce McKinlay  <bryce@albatross.co.nz>\n\n        * java/lang/Class.h (union _Jv_IDispatchTable): New declaration.\n        (struct _Jv_ifaces): New declaration.\n        JV_CLASS: New macro definition.\n        (getComponentType): Relocate below isArray() for inlining.\n        (getModifiers): Declare `inline'.\n        (getSuperclass): Ditto.\n        (isArray): Ditto.\n        (isPrimitive): Ditto.\n        (_Jv_IsAssignableFrom): New prototype.\n        (_Jv_LookupInterfaceMethodIdx): New prototype. Predeclare with \"C\"\n        linkage.\n        (_Jv_InitClass): Move from natClass.cc. Declare `inline'.\n        Check for JV_STATE_DONE before invoking initializeClass().\n        (_Jv_PrepareConstantTimeTables): New prototype.\n        (_Jv_GetInterfaces): Ditto.\n        (_Jv_GenerateITable): Ditto.\n        (_Jv_GetMethodString): Ditto.\n        (_Jv_AppendPartialITable): Ditto.\n        (_Jv_FindIIndex): Ditto.\n        depth, ancestors, idt: New class fields.\n\n        * java/lang/natClass.cc (isAssignableFrom): Move functionality to\n        inline function `_Jv_IsAssignableFrom'. Use that function.\n        (isInstance): Declare `inline'.\n        (initializeClass): Get lock on class before checking `state'. Unlock\n        before calling resolveClass0. Call _Jv_PrepareConstantTimeTables\n\twith the lock held.\n        (_Jv_LookupInterfaceMethod): Use _Jv_GetMessageString.\n        (_Jv_IsAssignableFrom): New inline function. Test assignability\n\tusing class->depth and ancestor table.\n        (_Jv_IsInstanceOf): Use _Jv_IsAssignableFrom.\n        (_Jv_CheckCast): Move from prims.cc. Use JV_CLASS and\n        _Jv_IsAssignableFrom.\n        (_Jv_CheckArrayStore): Ditto.\n        (_Jv_LookupInterfaceMethodIdx): New function.\n        INITIAL_IOFFSETS_LEN, INITIAL_IFACES_LEN: New #defines.\n        (_Jv_PrepareConstantTimeTables): New function.\n        (_Jv_IndexOf): Ditto.\n        (_Jv_GetInterfaces): Ditto.\n        (_Jv_GenerateITable): Ditto.\n        (_Jv_GetMethodString): Ditto.\n        (_Jv_AppendPartialITable): Ditto.\n        iindex_mutex, iindex_mutex_initialized: New static fields.\n        (_Jv_FindIIndex): New function.\n\n        * java/lang/natClassLoader.cc (_Jv_NewClass): Set new jclass fields.\n\n        * prims.cc (_Jv_CheckCast): Moved to natClass.cc.\n        (_Jv_CheckArrayStore): Ditto.\n        (JvNewCharArray, JvNewBooleanArray, JvNewByteArray, JvNewShortArray,\n        JvNewIntArray, JvNewLongArray, JvNewFloatArray, JvNewDoubleArray):\n        Moved to gcj/array.h.\n        (_Jv_Realloc): New function.\n\n        * gcj/cni.h: Move _Jv_PrimClass definitions to gcj/array.h.\n\n        * gcj/array.h: _Jv_PrimClass definitions moved from gcj/cni.h.\n        (JvNewCharArray, JvNewBooleanArray, JvNewByteArray,\n        JvNewShortArray, JvNewIntArray, JvNewLongArray, JvNewFloatArray,\n        JvNewDoubleArray): Implementations moved from prims.cc and\n        declared `inline'.\n\n        * gcj/javaprims.h (_Jv_Realloc): Prototype.\n\n        * include/jvm.h (_Jv_LookupInterfaceMethodIdx): Prototype.\n\nFrom-SVN: r32382", "tree": {"sha": "3d1200ab45d37376fcbddeff18a6199837857dca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d1200ab45d37376fcbddeff18a6199837857dca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/comments", "author": null, "committer": null, "parents": [{"sha": "173f556ccc41ea93cf66896d0c7778241467407f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/173f556ccc41ea93cf66896d0c7778241467407f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/173f556ccc41ea93cf66896d0c7778241467407f"}], "stats": {"total": 996, "additions": 772, "deletions": 224}, "files": [{"sha": "18dcf20df63ba5f6ebf952c3feaa1a57bb4f9444", "filename": "libjava/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "patch": "@@ -1,3 +1,77 @@\n+2000-03-07  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* resolve.cc (_Jv_SearchMethodInClass): New function.\n+\t(_Jv_ResolvePoolEntry): Search superinterfaces for interface methods.\n+\t* java/lang/Class.h (_Jv_SearchMethodInClass): New prototype.\n+\n+2000-03-07  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* java/lang/Class.h (union _Jv_IDispatchTable): New declaration.\n+\t(struct _Jv_ifaces): New declaration.\n+\tJV_CLASS: New macro definition.\n+\t(getComponentType): Relocate below isArray() for inlining.\n+\t(getModifiers): Declare `inline'.\n+\t(getSuperclass): Ditto.\n+\t(isArray): Ditto.\n+\t(isPrimitive): Ditto.\n+\t(_Jv_IsAssignableFrom): New prototype.\n+\t(_Jv_LookupInterfaceMethodIdx): New prototype. Predeclare with \"C\"\n+\tlinkage.\n+\t(_Jv_InitClass): Move from natClass.cc. Declare `inline'.\n+\tCheck for JV_STATE_DONE before invoking initializeClass().\n+\t(_Jv_PrepareConstantTimeTables): New prototype.\n+\t(_Jv_GetInterfaces): Ditto.\n+\t(_Jv_GenerateITable): Ditto.\n+\t(_Jv_GetMethodString): Ditto.\n+\t(_Jv_AppendPartialITable): Ditto.\n+\t(_Jv_FindIIndex): Ditto.\n+\tdepth, ancestors, idt: New class fields.\n+\n+\t* java/lang/natClass.cc (isAssignableFrom): Move functionality to\n+\tinline function `_Jv_IsAssignableFrom'. Use that function.\n+\t(isInstance): Declare `inline'.\n+\t(initializeClass): Get lock on class before checking `state'. Unlock \n+\tbefore calling resolveClass0. Call _Jv_PrepareConstantTimeTables with \n+\tthe lock held.\n+\t(_Jv_LookupInterfaceMethod): Use _Jv_GetMessageString.\n+\t(_Jv_IsAssignableFrom): New inline function. Test assignability using \n+\tclass->depth and ancestor table.\n+\t(_Jv_IsInstanceOf): Use _Jv_IsAssignableFrom.\n+\t(_Jv_CheckCast): Move from prims.cc. Use JV_CLASS and\n+\t_Jv_IsAssignableFrom.\n+\t(_Jv_CheckArrayStore): Ditto.\n+\t(_Jv_LookupInterfaceMethodIdx): New function. \n+\tINITIAL_IOFFSETS_LEN, INITIAL_IFACES_LEN: New #defines.\n+\t(_Jv_PrepareConstantTimeTables): New function.\n+\t(_Jv_IndexOf): Ditto.\n+\t(_Jv_GetInterfaces): Ditto.\n+\t(_Jv_GenerateITable): Ditto.\n+\t(_Jv_GetMethodString): Ditto.\n+\t(_Jv_AppendPartialITable): Ditto.\n+\tiindex_mutex, iindex_mutex_initialized: New static fields.\n+\t(_Jv_FindIIndex): New function.\n+\n+\t* java/lang/natClassLoader.cc (_Jv_NewClass): Set new jclass fields.\n+\n+\t* prims.cc (_Jv_CheckCast): Moved to natClass.cc.\n+\t(_Jv_CheckArrayStore): Ditto.\n+\t(JvNewCharArray, JvNewBooleanArray, JvNewByteArray, JvNewShortArray,\n+\tJvNewIntArray, JvNewLongArray, JvNewFloatArray, JvNewDoubleArray):\n+\tMoved to gcj/array.h.\n+\t(_Jv_Realloc): New function.\n+\n+\t* gcj/cni.h: Move _Jv_PrimClass definitions to gcj/array.h.\n+\n+\t* gcj/array.h: _Jv_PrimClass definitions moved from gcj/cni.h.\n+\t(JvNewCharArray, JvNewBooleanArray, JvNewByteArray,\n+\tJvNewShortArray, JvNewIntArray, JvNewLongArray, JvNewFloatArray,\n+\tJvNewDoubleArray): Implementations moved from prims.cc and\n+\tdeclared `inline'.\n+\n+\t* gcj/javaprims.h (_Jv_Realloc): Prototype.\n+\n+\t* include/jvm.h (_Jv_LookupInterfaceMethodIdx): Prototype.\n+\n 2000-03-06  Tom Tromey  <tromey@cygnus.com>\n \n \t* jni.cc (MARK_NONE): New define."}, {"sha": "8b355e263526467ee8db5dd61fd419e80659532f", "filename": "libjava/gcj/array.h", "status": "modified", "additions": 60, "deletions": 10, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fgcj%2Farray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fgcj%2Farray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Farray.h?ref=ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "patch": "@@ -55,18 +55,68 @@ typedef JArray<jfloat> *jfloatArray;\n typedef JArray<jdouble> *jdoubleArray;\n typedef JArray<jstring> *jstringArray;\n \n-extern \"C\" jbooleanArray JvNewBooleanArray (jint length);\n-extern \"C\" jbyteArray JvNewByteArray (jint length);\n-extern \"C\" jcharArray JvNewCharArray (jint length);\n-extern \"C\" jshortArray JvNewShortArray (jint length);\n-extern \"C\" jintArray JvNewIntArray (jint length);\n-extern \"C\" jlongArray JvNewLongArray (jint length);\n-extern \"C\" jfloatArray JvNewFloatArray (jint length);\n-extern \"C\" jdoubleArray JvNewDoubleArray (jint length);\n+extern class _Jv_PrimClass _Jv_byteClass, _Jv_shortClass, _Jv_intClass,\n+  _Jv_longClass, _Jv_booleanClass, _Jv_charClass, _Jv_floatClass,\n+  _Jv_doubleClass, _Jv_voidClass;\n+#define JvPrimClass(TYPE) ((jclass) & _Jv_##TYPE##Class)\n+\n extern \"C\" jobjectArray _Jv_NewObjectArray(jsize length, jclass, jobject init);\n+extern \"C\" jobject _Jv_NewPrimArray (jclass eltype, jint count);\n+\n+extern inline jobjectArray \n+JvNewObjectArray (jsize length, jclass cls, jobject init)\n+{ \n+  return _Jv_NewObjectArray (length, cls, init); \n+}\n+\n+extern inline jcharArray \n+JvNewCharArray (jint length)\n+{\n+  return (jcharArray) _Jv_NewPrimArray (JvPrimClass (char), length);\n+}\n+\n+extern inline jbooleanArray \n+JvNewBooleanArray (jint length)\n+{\n+  return (jbooleanArray) _Jv_NewPrimArray (JvPrimClass (boolean), length);\n+}\n+\n+extern inline jbyteArray \n+JvNewByteArray (jint length)\n+{\n+  return (jbyteArray) _Jv_NewPrimArray (JvPrimClass (byte), length);\n+}\n+\n+extern inline jshortArray \n+JvNewShortArray (jint length)\n+{\n+  return (jshortArray) _Jv_NewPrimArray (JvPrimClass (short), length);\n+}\n+\n+extern inline jintArray \n+JvNewIntArray (jint length)\n+{\n+  return (jintArray) _Jv_NewPrimArray (JvPrimClass (int), length);\n+}\n+\n+extern inline jlongArray \n+JvNewLongArray (jint length)\n+{\n+  return (jlongArray) _Jv_NewPrimArray (JvPrimClass (long), length);\n+}\n+\n+extern inline jfloatArray \n+JvNewFloatArray (jint length)\n+{\n+  return (jfloatArray) _Jv_NewPrimArray (JvPrimClass (float), length);\n+}\n+\n+extern inline jdoubleArray \n+JvNewDoubleArray (jint length)\n+{\n+  return (jdoubleArray) _Jv_NewPrimArray (JvPrimClass (double), length);\n+}\n \n-inline jobjectArray JvNewObjectArray (jsize length, jclass cls, jobject init)\n-{ return _Jv_NewObjectArray (length, cls, init); }\n \n extern \"C\" jstringArray JvConvertArgv(int argc, const char **argv);\n "}, {"sha": "2cad18584912023da535a009ef69a7689330a4e1", "filename": "libjava/gcj/cni.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fgcj%2Fcni.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fgcj%2Fcni.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fcni.h?ref=ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "patch": "@@ -93,11 +93,6 @@ JvNewStringUTF (const char *bytes)\n   return _Jv_NewStringUTF (bytes);\n }\n \n-extern class _Jv_PrimClass _Jv_byteClass, _Jv_shortClass, _Jv_intClass,\n-  _Jv_longClass, _Jv_booleanClass, _Jv_charClass, _Jv_floatClass,\n-  _Jv_doubleClass, _Jv_voidClass;\n-#define JvPrimClass(TYPE) ((jclass) & _Jv_##TYPE##Class)\n-\n class JvSynchronize\n {\n private:"}, {"sha": "2f3c4638b41543de0f924516baa5ce4acc9a249f", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "patch": "@@ -272,6 +272,7 @@ extern \"C\" jsize _Jv_GetStringUTFRegion (jstring, jsize, jsize, char *);\n extern \"C\" void _Jv_Throw (void *) __attribute__ ((__noreturn__));\n extern \"C\" void _Jv_Sjlj_Throw (void *) __attribute__ ((__noreturn__));\n extern \"C\" void* _Jv_Malloc (jsize) __attribute__((__malloc__));\n+extern \"C\" void* _Jv_Realloc (void *, jsize);\n extern \"C\" void _Jv_Free (void*);\n \n typedef unsigned short _Jv_ushort __attribute__((__mode__(__HI__)));"}, {"sha": "d24a5ff5830498f7276d1c263b0df9a724463808", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "patch": "@@ -156,7 +156,9 @@ extern \"C\" jobject _Jv_NewMultiArray (jclass klass, jint dims, ...)\n   __attribute__((__malloc__));\n extern \"C\" void *_Jv_CheckCast (jclass klass, jobject obj);\n extern \"C\" void *_Jv_LookupInterfaceMethod (jclass klass, Utf8Const *name,\n-\t\t\t\t\t    Utf8Const *signature);\n+                                           Utf8Const *signature);\n+extern \"C\" void *_Jv_LookupInterfaceMethodIdx (jclass klass, jclass iface, \n+                                               int meth_idx);\n extern \"C\" void _Jv_CheckArrayStore (jobject array, jobject obj);\n extern \"C\" void _Jv_RegisterClass (jclass klass);\n extern \"C\" void _Jv_RegisterClasses (jclass *classes);"}, {"sha": "8aefb70087d6da04e3213ba921a06fdffb6223d8", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 73, "deletions": 15, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "patch": "@@ -22,6 +22,10 @@ details.  */\n extern \"C\" void _Jv_InitClass (jclass klass);\n extern \"C\" void _Jv_RegisterClasses (jclass *classes);\n \n+// This must be predefined with \"C\" linkage.\n+extern \"C\" void *_Jv_LookupInterfaceMethodIdx (jclass klass, jclass iface, \n+                                               int meth_idx);\n+\n // These are the possible values for the `state' field of the class\n // structure.  Note that ordering is important here.  Whenever the\n // state changes, one should notify all waiters of this class.\n@@ -60,13 +64,41 @@ struct _Jv_Method\n   _Jv_Utf8Const *signature;\n   _Jv_ushort accflags;\n   void *ncode;\n-\n   _Jv_Method *getNextMethod ()\n   { return this + 1; }\n };\n \n+// Interface Dispatch Tables \n+union _Jv_IDispatchTable\n+{\n+  struct\n+  {\n+    // Index into interface's ioffsets.\n+    jshort iindex;\n+    jshort itable_length;\n+    // Class Interface dispatch table.\n+    void **itable;\n+  } cls;\n+\n+  struct\n+  {\n+    // Offsets into implementation class itables.\n+    jshort *ioffsets;\n+  } iface;\n+};\n+\n+// Used by _Jv_GetInterfaces ()\n+struct _Jv_ifaces\n+{\n+  jclass *list;\n+  jshort len;\n+  jshort count;\n+};\n+\n #define JV_PRIMITIVE_VTABLE ((_Jv_VTable *) -1)\n \n+#define JV_CLASS(Obj) ((jclass) (*(_Jv_VTable **) Obj)->clas)\n+\n class java::lang::Class : public java::lang::Object\n {\n public:\n@@ -78,11 +110,6 @@ class java::lang::Class : public java::lang::Object\n       return loader;\n     }\n \n-  jclass getComponentType (void)\n-    {\n-      return isArray () ? (* (jclass *) &methods) : 0;\n-    }\n-\n   java::lang::reflect::Constructor *getConstructor (JArray<jclass> *);\n   JArray<java::lang::reflect::Constructor *> *getConstructors (void);\n   java::lang::reflect::Constructor *getDeclaredConstructor (JArray<jclass> *);\n@@ -112,7 +139,7 @@ class java::lang::Class : public java::lang::Object\n   java::lang::reflect::Method *getMethod (jstring, JArray<jclass> *);\n   JArray<java::lang::reflect::Method *> *getMethods (void);\n \n-  jint getModifiers (void)\n+  inline jint getModifiers (void)\n     {\n       return accflags;\n     }\n@@ -123,21 +150,26 @@ class java::lang::Class : public java::lang::Object\n   java::io::InputStream *getResourceAsStream (jstring resourceName);\n   JArray<jobject> *getSigners (void);\n \n-  jclass getSuperclass (void)\n+  inline jclass getSuperclass (void)\n     {\n       return superclass;\n     }\n \n-  jboolean isArray (void)\n+  inline jboolean isArray (void)\n     {\n       return name->data[0] == '[';\n     }\n \n+  inline jclass getComponentType (void)\n+    {\n+      return isArray () ? (* (jclass *) &methods) : 0;\n+    }\n+\n   jboolean isAssignableFrom (jclass cls);\n   jboolean isInstance (jobject obj);\n   jboolean isInterface (void);\n-\n-  jboolean isPrimitive (void)\n+  \n+  inline jboolean isPrimitive (void)\n     {\n       return vtable == JV_PRIMITIVE_VTABLE;\n     }\n@@ -150,22 +182,32 @@ class java::lang::Class : public java::lang::Object\n     {\n       return size_in_bytes;\n     }\n-\n+    \n   // finalization\n   void finalize ();\n \n-private:\n+private:   \n+\n   void checkMemberAccess (jint flags);\n \n   void initializeClass (void);\n \n   // Friend functions implemented in natClass.cc.\n   friend _Jv_Method *_Jv_GetMethodLocal (jclass klass, _Jv_Utf8Const *name,\n \t\t\t\t\t _Jv_Utf8Const *signature);\n+  friend jboolean _Jv_IsAssignableFrom(jclass, jclass);\n+  friend void *_Jv_LookupInterfaceMethodIdx (jclass klass, jclass iface, \n+\t\t\t\t\t     int method_idx);\n+\n+  inline friend void \n+  _Jv_InitClass (jclass klass)\n+  {\n+    if (klass->state != JV_STATE_DONE)\n+      klass->initializeClass ();\n+  }\n+\n   friend _Jv_Method* _Jv_LookupDeclaredMethod (jclass, _Jv_Utf8Const *, \n \t\t\t\t\t       _Jv_Utf8Const*);\n-  friend void _Jv_InitClass (jclass klass);\n-\n   friend jfieldID JvGetFirstInstanceField (jclass);\n   friend jint JvNumInstanceFields (jclass);\n   friend jfieldID JvGetFirstStaticField (jclass);\n@@ -205,6 +247,12 @@ class java::lang::Class : public java::lang::Object\n \t\t\t      java::lang::ClassLoader *loader);\n \n   friend void _Jv_PrepareCompiledClass (jclass);\n+  friend void _Jv_PrepareConstantTimeTables (jclass);\n+  friend jshort _Jv_GetInterfaces (jclass, _Jv_ifaces *);\n+  friend void _Jv_GenerateITable (jclass, _Jv_ifaces *, jshort *);\n+  friend jstring _Jv_GetMethodString(jclass, _Jv_Utf8Const *);\n+  friend jshort _Jv_AppendPartialITable (jclass, jclass, void **, jshort);\n+  friend jshort _Jv_FindIIndex (jclass *, jshort *, jshort);\n \n #ifdef INTERPRETER\n   friend jboolean _Jv_IsInterpretedClass (jclass);\n@@ -213,6 +261,10 @@ class java::lang::Class : public java::lang::Object\n \t\t\t\t       _Jv_Utf8Const*);\n   friend void _Jv_InitField (jobject, jclass, int);\n   friend _Jv_word _Jv_ResolvePoolEntry (jclass, int);\n+  friend _Jv_Method *_Jv_SearchMethodInClass (jclass cls, jclass klass, \n+                        \t\t      _Jv_Utf8Const *method_name, \n+\t\t\t\t\t      _Jv_Utf8Const *method_signature);\n+\n   friend void _Jv_PrepareClass (jclass);\n \n   friend class _Jv_ClassReader;\t\n@@ -265,6 +317,12 @@ class java::lang::Class : public java::lang::Object\n   // The thread which has locked this class.  Used during class\n   // initialization.\n   java::lang::Thread *thread;\n+  // How many levels of \"extends\" this class is removed from Object.\n+  jshort depth;\n+  // Vector of this class's superclasses, ordered by decreasing depth.\n+  jclass *ancestors;\n+  // Interface Dispatch Table.\n+  _Jv_IDispatchTable *idt;\n };\n \n #endif /* __JAVA_LANG_CLASS_H__ */"}, {"sha": "64b25d0ca1a5ab03487ed9af712728e37439ca8f", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 442, "deletions": 68, "changes": 510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "patch": "@@ -10,13 +10,15 @@ details.  */\n \n #include <config.h>\n \n-#include <stdlib.h>\n+#include <limits.h>\n #include <string.h>\n \n #pragma implementation \"Class.h\"\n \n #include <gcj/cni.h>\n #include <jvm.h>\n+#include <java-threads.h>\n+\n #include <java/lang/Class.h>\n #include <java/lang/ClassLoader.h>\n #include <java/lang/String.h>\n@@ -26,6 +28,8 @@ details.  */\n #include <java/lang/reflect/Field.h>\n #include <java/lang/reflect/Constructor.h>\n #include <java/lang/AbstractMethodError.h>\n+#include <java/lang/ArrayStoreException.h>\n+#include <java/lang/ClassCastException.h>\n #include <java/lang/ClassNotFoundException.h>\n #include <java/lang/ExceptionInInitializerError.h>\n #include <java/lang/IllegalAccessException.h>\n@@ -34,6 +38,7 @@ details.  */\n #include <java/lang/InstantiationException.h>\n #include <java/lang/NoClassDefFoundError.h>\n #include <java/lang/NoSuchFieldException.h>\n+#include <java/lang/NoSuchMethodError.h>\n #include <java/lang/NoSuchMethodException.h>\n #include <java/lang/Thread.h>\n #include <java/lang/NullPointerException.h>\n@@ -608,48 +613,18 @@ java::lang::Class::getMethods (void)\n jboolean\n java::lang::Class::isAssignableFrom (jclass klass)\n {\n-  if (this == klass)\n-    return true;\n-  // Primitive types must be equal, which we just tested for.\n-  if (isPrimitive () || ! klass || klass->isPrimitive())\n-    return false;\n-\n-  // If target is array, so must source be.\n-  if (isArray ())\n-    {\n-      if (! klass->isArray())\n-\treturn false;\n-      return getComponentType()->isAssignableFrom(klass->getComponentType());\n-    }\n-\n-  if (isAssignableFrom (klass->getSuperclass()))\n-    return true;\n-\n-  if (isInterface())\n-    {\n-      // See if source implements this interface.\n-      for (int i = 0; i < klass->interface_count; ++i)\n-\t{\n-\t  jclass interface = klass->interfaces[i];\n-\t  // FIXME: ensure that class is prepared here.\n-\t  // See Spec 12.3.2.\n-\t  if (isAssignableFrom (interface))\n-\t    return true;\n-\t}\n-    }\n-\n-  return false;\n+  return _Jv_IsAssignableFrom (this, klass);\n }\n \n-jboolean\n+inline jboolean\n java::lang::Class::isInstance (jobject obj)\n {\n   if (! obj || isPrimitive ())\n     return false;\n   return isAssignableFrom (obj->getClass());\n }\n \n-jboolean\n+inline jboolean\n java::lang::Class::isInterface (void)\n {\n   return (accflags & java::lang::reflect::Modifier::INTERFACE) != 0;\n@@ -696,36 +671,32 @@ java::lang::Class::finalize (void)\n void\n java::lang::Class::initializeClass (void)\n {\n-  // Short-circuit to avoid needless locking.\n+  // jshort-circuit to avoid needless locking.\n   if (state == JV_STATE_DONE)\n     return;\n \n-  // do this before we enter the monitor below, since this can cause\n-  // exceptions.  Here we assume, that reading \"state\" is an atomic\n-  // operation, I pressume that is true? --Kresten\n+  // Step 1.\n+  _Jv_MonitorEnter (this);\n+\n   if (state < JV_STATE_LINKED)\n-    {\n+    {    \n #ifdef INTERPRETER\n       if (_Jv_IsInterpretedClass (this))\n \t{\n+\t  // this can throw exceptions, so exit the monitor as a precaution.\n+\t  _Jv_MonitorExit (this);\n \t  java::lang::ClassLoader::resolveClass0 (this);\n-\n-\t  // Step 1.\n \t  _Jv_MonitorEnter (this);\n \t}\n       else\n #endif\n         {\n-          // Step 1.\n-\t  _Jv_MonitorEnter (this);\n \t  _Jv_PrepareCompiledClass (this);\n \t}\n     }\n-  else\n-    {\n-      // Step 1.\n-      _Jv_MonitorEnter (this);\n-    }\n+  \n+  if (state <= JV_STATE_LINKED)\n+    _Jv_PrepareConstantTimeTables (this);\n \n   // Step 2.\n   java::lang::Thread *self = java::lang::Thread::currentThread();\n@@ -828,14 +799,14 @@ _Jv_GetMethodLocal (jclass klass, _Jv_Utf8Const *name,\n \n _Jv_Method *\n _Jv_LookupDeclaredMethod (jclass klass, _Jv_Utf8Const *name,\n-\t\t\t_Jv_Utf8Const *signature)\n+                          _Jv_Utf8Const *signature)\n {\n   for (; klass; klass = klass->getSuperclass())\n     {\n       _Jv_Method *meth = _Jv_GetMethodLocal (klass, name, signature);\n \n       if (meth)\n-\treturn meth;\n+        return meth;\n     }\n \n   return NULL;\n@@ -854,15 +825,15 @@ static _Jv_mcache method_cache[MCACHE_SIZE + 1];\n \n static void *\n _Jv_FindMethodInCache (jclass klass,\n-\t\t       _Jv_Utf8Const *name,\n-\t\t       _Jv_Utf8Const *signature)\n+                       _Jv_Utf8Const *name,\n+                       _Jv_Utf8Const *signature)\n {\n   int index = name->hash & MCACHE_SIZE;\n   _Jv_mcache *mc = method_cache + index;\n   _Jv_Method *m = mc->method;\n \n   if (mc->klass == klass\n-      && m != NULL\t\t// thread safe check\n+      && m != NULL             // thread safe check\n       && _Jv_equalUtf8Consts (m->name, name)\n       && _Jv_equalUtf8Consts (m->signature, signature))\n     return mc->method->ncode;\n@@ -871,7 +842,7 @@ _Jv_FindMethodInCache (jclass klass,\n \n static void\n _Jv_AddMethodToCache (jclass klass,\n-\t\t\t_Jv_Method *method)\n+                       _Jv_Method *method)\n {\n   _Jv_MonitorEnter (&ClassClass); \n \n@@ -885,8 +856,10 @@ _Jv_AddMethodToCache (jclass klass,\n \n void *\n _Jv_LookupInterfaceMethod (jclass klass, _Jv_Utf8Const *name,\n-\t\t\t   _Jv_Utf8Const *signature)\n+                           _Jv_Utf8Const *signature)\n {\n+  using namespace java::lang::reflect;\n+\n   void *ncode = _Jv_FindMethodInCache (klass, name, signature);\n   if (ncode != 0)\n     return ncode;\n@@ -895,31 +868,432 @@ _Jv_LookupInterfaceMethod (jclass klass, _Jv_Utf8Const *name,\n     {\n       _Jv_Method *meth = _Jv_GetMethodLocal (klass, name, signature);\n       if (! meth)\n-\tcontinue;\n-\n-      if (java::lang::reflect::Modifier::isStatic(meth->accflags))\n-\tJvThrow (new java::lang::IncompatibleClassChangeError);\n-      if (java::lang::reflect::Modifier::isAbstract(meth->accflags))\n-\tJvThrow (new java::lang::AbstractMethodError);\n-      if (! java::lang::reflect::Modifier::isPublic(meth->accflags))\n-\tJvThrow (new java::lang::IllegalAccessError);\n+        continue;\n+\n+      if (Modifier::isStatic(meth->accflags))\n+\tJvThrow (new java::lang::IncompatibleClassChangeError\n+\t         (_Jv_GetMethodString (klass, meth->name)));\n+      if (Modifier::isAbstract(meth->accflags))\n+\tJvThrow (new java::lang::AbstractMethodError\n+\t         (_Jv_GetMethodString (klass, meth->name)));\n+      if (! Modifier::isPublic(meth->accflags))\n+\tJvThrow (new java::lang::IllegalAccessError\n+\t         (_Jv_GetMethodString (klass, meth->name)));\n \n       _Jv_AddMethodToCache (klass, meth);\n \n       return meth->ncode;\n     }\n   JvThrow (new java::lang::IncompatibleClassChangeError);\n-  return NULL;\t\t\t// Placate compiler.\n+  return NULL;                 // Placate compiler.\n }\n \n-void\n-_Jv_InitClass (jclass klass)\n+// Fast interface method lookup by index.\n+void *\n+_Jv_LookupInterfaceMethodIdx (jclass klass, jclass iface, int method_idx)\n+{\n+  _Jv_IDispatchTable *cldt = klass->idt;\n+  int idx = iface->idt->iface.ioffsets[cldt->cls.iindex] + method_idx;\n+  return cldt->cls.itable[idx];\n+}\n+\n+inline jboolean\n+_Jv_IsAssignableFrom (jclass target, jclass source)\n {\n-  klass->initializeClass();\n+  if (target == &ObjectClass \n+      || source == target \n+      || (source->ancestors != NULL \n+          && source->ancestors[source->depth - target->depth] == target))\n+     return true;\n+     \n+  // If target is array, so must source be.  \n+  if (target->isArray ())\n+    {\n+      if (! source->isArray())\n+\treturn false;\n+      return _Jv_IsAssignableFrom(target->getComponentType(), \n+                                  source->getComponentType());\n+    }\n+        \n+  if (target->isInterface())\n+    {\n+      _Jv_IDispatchTable *cl_idt = source->idt;\n+      _Jv_IDispatchTable *if_idt = target->idt;\n+      jshort cl_iindex = cl_idt->cls.iindex;\n+      if (cl_iindex <= if_idt->iface.ioffsets[0])\n+        {\n+\t  jshort offset = if_idt->iface.ioffsets[cl_iindex];\n+\t  if (offset < cl_idt->cls.itable_length\n+\t      && cl_idt->cls.itable[offset] == target)\n+\t    return true;\n+\t}\n+      return false;\n+    }\n+    \n+  return false;\n }\n \n jboolean\n _Jv_IsInstanceOf(jobject obj, jclass cl)\n {\n-  return cl->isInstance(obj);\n+  return (obj ? _Jv_IsAssignableFrom (cl, JV_CLASS (obj)) : false);\n+}\n+\n+void *\n+_Jv_CheckCast (jclass c, jobject obj)\n+{\n+  if (obj != NULL && ! _Jv_IsAssignableFrom(c, JV_CLASS (obj)))\n+    JvThrow (new java::lang::ClassCastException);\n+  return obj;\n+}\n+\n+void\n+_Jv_CheckArrayStore (jobject arr, jobject obj)\n+{\n+  if (obj)\n+    {\n+      JvAssert (arr != NULL);\n+      jclass elt_class = (JV_CLASS (arr))->getComponentType();\n+      jclass obj_class = JV_CLASS (obj);\n+      if (! _Jv_IsAssignableFrom (elt_class, obj_class))\n+\tJvThrow (new java::lang::ArrayStoreException);\n+    }\n+}\n+\n+#define INITIAL_IOFFSETS_LEN 4\n+#define INITIAL_IFACES_LEN 4\n+\n+// Generate tables for constant-time assignment testing and interface\n+// method lookup. This implements the technique described by Per Bothner\n+// <per@bothner.com> on the java-discuss mailing list on 1999-09-02:\n+// http://sourceware.cygnus.com/ml/java-discuss/1999-q3/msg00377.html\n+void \n+_Jv_PrepareConstantTimeTables (jclass klass)\n+{  \n+  if (klass->isPrimitive () || klass->isInterface ())\n+    return;\n+  \n+  // Short-circuit in case we've been called already.\n+  if ((klass->idt != NULL) || klass->depth != 0)\n+    return;\n+\n+  // Calculate the class depth and ancestor table. The depth of a class \n+  // is how many \"extends\" it is removed from Object. Thus the depth of \n+  // java.lang.Object is 0, but the depth of java.io.FilterOutputStream \n+  // is 2. Depth is defined for all regular and array classes, but not \n+  // interfaces or primitive types.\n+   \n+  jclass klass0 = klass;\n+  while (klass0 != &ObjectClass)\n+    {\n+      klass0 = klass0->superclass;\n+      klass->depth++;\n+    }\n+\n+  // We do class member testing in constant time by using a small table \n+  // of all the ancestor classes within each class. The first element is \n+  // a pointer to the current class, and the rest are pointers to the \n+  // classes ancestors, ordered from the current class down by decreasing \n+  // depth. We do not include java.lang.Object in the table of ancestors, \n+  // since it is redundant.\n+\t\n+  klass->ancestors = (jclass *) _Jv_Malloc (klass->depth * sizeof (jclass));\n+  klass0 = klass;\n+  for (int index = 0; index < klass->depth; index++)\n+    {\n+      klass->ancestors[index] = klass0;\n+      klass0 = klass0->superclass;\n+    }\n+    \n+  if (klass->isArray () \n+      || java::lang::reflect::Modifier::isAbstract (klass->accflags))\n+    return;\n+\n+  klass->idt = \n+    (_Jv_IDispatchTable *) _Jv_Malloc (sizeof (_Jv_IDispatchTable));\n+    \n+  _Jv_ifaces ifaces;\n+\n+  ifaces.count = 0;\n+  ifaces.len = INITIAL_IFACES_LEN;\n+  ifaces.list = (jclass *) _Jv_Malloc (ifaces.len * sizeof (jclass *));\n+\n+  int itable_size = _Jv_GetInterfaces (klass, &ifaces);\n+\n+  if (ifaces.count > 0)\n+    {\n+      klass->idt->cls.itable = \n+\t(void **) _Jv_Malloc (itable_size * sizeof (void *));\n+      klass->idt->cls.itable_length = itable_size;\n+          \n+      jshort *itable_offsets = \n+\t(jshort *) _Jv_Malloc (ifaces.count * sizeof (jshort));\n+\n+      _Jv_GenerateITable (klass, &ifaces, itable_offsets);\n+\n+      jshort cls_iindex = \n+\t_Jv_FindIIndex (ifaces.list, itable_offsets, ifaces.count);\n+\n+      for (int i=0; i < ifaces.count; i++)\n+\t{\n+\t  ifaces.list[i]->idt->iface.ioffsets[cls_iindex] =\n+\t    itable_offsets[i];\n+\t}\n+\n+      klass->idt->cls.iindex = cls_iindex;\t    \n+\n+      _Jv_Free (ifaces.list);\n+      _Jv_Free (itable_offsets);\n+    }\n+  else \n+    {\n+      klass->idt->cls.iindex = SHRT_MAX;\n+    }\n+}\n+\n+// Return index of item in list, or -1 if item is not present.\n+jshort\n+_Jv_IndexOf (void *item, void **list, jshort list_len)\n+{\n+  for (int i=0; i < list_len; i++)\n+    {\n+      if (list[i] == item)\n+        return i;\n+    }\n+  return -1;\n+}\n+\n+// Find all unique interfaces directly or indirectly implemented by klass.\n+// Returns the size of the interface dispatch table (itable) for klass, which \n+// is the number of unique interfaces plus the total number of methods that \n+// those interfaces declare. May extend ifaces if required.\n+jshort\n+_Jv_GetInterfaces (jclass klass, _Jv_ifaces *ifaces)\n+{\n+  jshort result = 0;\n+  \n+  for (int i=0; i < klass->interface_count; i++)\n+    {\n+      jclass iface = klass->interfaces[i];\n+      if (_Jv_IndexOf (iface, (void **) ifaces->list, ifaces->count) == -1)\n+        {\n+\t  if (ifaces->count + 1 >= ifaces->len)\n+\t    {\n+\t      /* Resize ifaces list */\n+\t      ifaces->len = ifaces->len * 2;\n+\t      ifaces->list = (jclass *) _Jv_Realloc (ifaces->list, \n+\t                     ifaces->len * sizeof(jclass));\n+\t    }\n+\t  ifaces->list[ifaces->count] = iface;\n+\t  ifaces->count++;\n+\n+\t  result += _Jv_GetInterfaces (klass->interfaces[i], ifaces);\n+\t}\n+    }\n+    \n+  if (klass->isInterface())\n+    {\n+      result += klass->method_count + 1;\n+    }\n+  else\n+    {\n+      if (klass->superclass)\n+        {\n+\t  result += _Jv_GetInterfaces (klass->superclass, ifaces);\n+\t}\n+    }\n+  return result;\n+}\n+\n+// Fill out itable in klass, resolving method declarations in each ifaces.\n+// itable_offsets is filled out with the position of each iface in itable,\n+// such that itable[itable_offsets[n]] == ifaces.list[n].\n+void\n+_Jv_GenerateITable (jclass klass, _Jv_ifaces *ifaces, jshort *itable_offsets)\n+{\n+  void **itable = klass->idt->cls.itable;\n+  jshort itable_pos = 0;\n+\n+  for (int i=0; i < ifaces->count; i++)\n+    { \n+      jclass iface = ifaces->list[i];\n+      itable_offsets[i] = itable_pos;\n+      itable_pos = _Jv_AppendPartialITable (klass, iface, itable,\n+                   itable_pos);\n+      \n+      /* Create interface dispatch table for iface */\n+      if (iface->idt == NULL)\n+\t{\n+\t  iface->idt = \n+\t    (_Jv_IDispatchTable *) _Jv_Malloc (sizeof (_Jv_IDispatchTable));\n+\n+\t  // The first element of ioffsets is its length (itself included).\n+\t  jshort *ioffsets = \n+\t    (jshort *) _Jv_Malloc (INITIAL_IOFFSETS_LEN * sizeof (jshort));\n+\t  ioffsets[0] = INITIAL_IOFFSETS_LEN;\n+\t  for (int i=1; i < INITIAL_IOFFSETS_LEN; i++)\n+\t    ioffsets[i] = -1;\n+\n+\t  iface->idt->iface.ioffsets = ioffsets;\t    \n+\t}\n+    }\n+}\n+\n+// Format method name for use in error messages.\n+jstring\n+_Jv_GetMethodString (jclass klass, _Jv_Utf8Const *name)\n+{\n+  jstring r = JvNewStringUTF (klass->name->data);\n+  r = r->concat (JvNewStringUTF (\".\"));\n+  r = r->concat (JvNewStringUTF (name->data));\n+  return r;\n+}\n+\n+void \n+_Jv_ThrowNoSuchMethodError ()\n+{\n+  JvThrow (new java::lang::NoSuchMethodError ());\n+}\n+\n+// Each superinterface of a class (i.e. each interface that the class\n+// directly or indirectly implements) has a corresponding \"Partial\n+// Interface Dispatch Table\" whose size is (number of methods + 1) words.\n+// The first word is a pointer to the interface (i.e. the java.lang.Class\n+// instance for that interface).  The remaining words are pointers to the\n+// actual methods that implement the methods declared in the interface,\n+// in order of declaration.\n+//\n+// Append partial interface dispatch table for \"iface\" to \"itable\", at\n+// position itable_pos.\n+// Returns the offset at which the next partial ITable should be appended.\n+jshort\n+_Jv_AppendPartialITable (jclass klass, jclass iface, void **itable, \n+                         jshort pos)\n+{\n+  using namespace java::lang::reflect;\n+\n+  itable[pos++] = (void *) iface;\n+  _Jv_Method *meth;\n+  \n+  for (int j=0; j < iface->method_count; j++)\n+    {\n+      meth = NULL;\n+      for (jclass cl = klass; cl; cl = cl->getSuperclass())\n+        {\n+\t  meth = _Jv_GetMethodLocal (cl, iface->methods[j].name,\n+                 iface->methods[j].signature);\n+\t\t \n+\t  if (meth)\n+\t    break;\n+\t}\n+\n+      if (meth && (meth->name->data[0] == '<'))\n+\t{\n+\t  // leave a placeholder in the itable for hidden init methods.\n+          itable[pos] = NULL;\t\n+\t}\n+      else if (meth)\n+        {\n+\t  if (Modifier::isStatic(meth->accflags))\n+\t    JvThrow (new java::lang::IncompatibleClassChangeError\n+\t             (_Jv_GetMethodString (klass, meth->name)));\n+\t  if (Modifier::isAbstract(meth->accflags))\n+\t    JvThrow (new java::lang::AbstractMethodError\n+\t             (_Jv_GetMethodString (klass, meth->name)));\n+\t  if (! Modifier::isPublic(meth->accflags))\n+\t    JvThrow (new java::lang::IllegalAccessError\n+\t             (_Jv_GetMethodString (klass, meth->name)));\n+\n+\t  itable[pos] = meth->ncode;\n+\t}\n+      else\n+        {\n+\t  // The method doesn't exist in klass. Binary compatibility rules\n+\t  // permit this, so we delay the error until runtime using a pointer\n+\t  // to a method which throws an exception.\n+\t  itable[pos] = (void *) _Jv_ThrowNoSuchMethodError;\n+\t}\n+      pos++;\n+    }\n+    \n+  return pos;\n+}\n+\n+static _Jv_Mutex_t iindex_mutex;\n+bool iindex_mutex_initialized = false;\n+\n+// We need to find the correct offset in the Class Interface Dispatch \n+// Table for a given interface. Once we have that, invoking an interface \n+// method just requires combining the Method's index in the interface \n+// (known at compile time) to get the correct method.  Doing a type test \n+// (cast or instanceof) is the same problem: Once we have a possible Partial \n+// Interface Dispatch Table, we just compare the first element to see if it \n+// matches the desired interface. So how can we find the correct offset?  \n+// Our solution is to keep a vector of candiate offsets in each interface \n+// (idt->iface.ioffsets), and in each class we have an index \n+// (idt->cls.iindex) used to select the correct offset from ioffsets.\n+//\n+// Calculate and return iindex for a new class. \n+// ifaces is a vector of num interfaces that the class implements.\n+// offsets[j] is the offset in the interface dispatch table for the\n+// interface corresponding to ifaces[j].\n+// May extend the interface ioffsets if required.\n+jshort\n+_Jv_FindIIndex (jclass *ifaces, jshort *offsets, jshort num)\n+{\n+  int i;\n+  int j;\n+  \n+  // Acquire a global lock to prevent itable corruption in case of multiple \n+  // classes that implement an intersecting set of interfaces being linked\n+  // simultaneously. We can assume that the mutex will be initialized\n+  // single-threaded.\n+  if (! iindex_mutex_initialized)\n+    {\n+      _Jv_MutexInit (&iindex_mutex);\n+      iindex_mutex_initialized = true;\n+    }\n+  \n+  _Jv_MutexLock (&iindex_mutex);\n+  \n+  for (i=1;; i++)  /* each potential position in ioffsets */\n+    {\n+      for (j=0;; j++)  /* each iface */\n+        {\n+\t  if (j >= num)\n+\t    goto found;\n+\t  if (i > ifaces[j]->idt->iface.ioffsets[0])\n+\t    continue;\n+\t  int ioffset = ifaces[j]->idt->iface.ioffsets[i];\n+\t  /* We can potentially share this position with another class. */\n+\t  if (ioffset >= 0 && ioffset != offsets[j])\n+\t    break; /* Nope. Try next i. */\t  \n+\t}\n+    }\n+  found:\n+  for (j = 0; j < num; j++)\n+    {\n+      int len = ifaces[j]->idt->iface.ioffsets[0];\n+      if (i >= len) \n+\t{\n+\t  /* Resize ioffsets. */\n+\t  int newlen = 2 * len;\n+\t  if (i >= newlen)\n+\t    newlen = i + 3;\n+\t  jshort *old_ioffsets = ifaces[j]->idt->iface.ioffsets;\n+\t  jshort *new_ioffsets = (jshort *) _Jv_Realloc (old_ioffsets, \n+\t                                  newlen * sizeof(jshort));\t  \n+\t  new_ioffsets[0] = newlen;\n+\n+\t  while (len < newlen)\n+\t    new_ioffsets[len++] = -1;\n+\t  \n+\t  ifaces[j]->idt->iface.ioffsets = new_ioffsets;\n+\t}\n+      ifaces[j]->idt->iface.ioffsets[i] = offsets[j];\n+    }\n+\n+  _Jv_MutexUnlock (&iindex_mutex);\n+\n+  return i;\n }"}, {"sha": "a3eeaab60b24c0c8af3c7c205e4200bf9f27b17a", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "patch": "@@ -503,6 +503,9 @@ _Jv_NewClass (_Jv_Utf8Const *name, jclass superclass,\n   ret->interface_count = 0;\n   ret->state = JV_STATE_NOTHING;\n   ret->thread = NULL;\n+  ret->depth = 0;\n+  ret->ancestors = NULL;\n+  ret->idt = NULL;\n \n   _Jv_RegisterClass (ret);\n "}, {"sha": "beec6a6d953781d42477996ef715378d6c00f6b0", "filename": "libjava/prims.cc", "status": "modified", "additions": 15, "deletions": 79, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "patch": "@@ -42,11 +42,9 @@ details.  */\n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n #include <java/lang/ArithmeticException.h>\n #include <java/lang/ClassFormatError.h>\n-#include <java/lang/ClassCastException.h>\n #include <java/lang/NegativeArraySizeException.h>\n #include <java/lang/NullPointerException.h>\n #include <java/lang/OutOfMemoryError.h>\n-#include <java/lang/ArrayStoreException.h>\n #include <java/lang/System.h>\n #include <java/lang/reflect/Modifier.h>\n #include <java/io/PrintStream.h>\n@@ -286,31 +284,6 @@ _Jv_ThrowBadArrayIndex(jint bad_index)\n \t   (java::lang::String::valueOf(bad_index)));\n }\n \n-void*\n-_Jv_CheckCast (jclass c, jobject obj)\n-{\n-  if (obj != NULL && ! c->isAssignableFrom(obj->getClass()))\n-    JvThrow (new java::lang::ClassCastException);\n-  return obj;\n-}\n-\n-void\n-_Jv_CheckArrayStore (jobject arr, jobject obj)\n-{\n-  if (obj)\n-    {\n-      JvAssert (arr != NULL);\n-      jclass arr_class = arr->getClass();\n-      JvAssert (arr_class->isArray());\n-      jclass elt_class = arr_class->getComponentType();\n-      jclass obj_class = obj->getClass();\n-      if (! elt_class->isAssignableFrom(obj_class))\n-\tJvThrow (new java::lang::ArrayStoreException);\n-    }\n-}\n-\n-\f\n-\n // Allocate some unscanned memory and throw an exception if no memory.\n void *\n _Jv_AllocBytesChecked (jsize size)\n@@ -421,54 +394,6 @@ _Jv_NewPrimArray (jclass eltype, jint count)\n   return arr;\n }\n \n-jcharArray\n-JvNewCharArray (jint length)\n-{\n-  return (jcharArray) _Jv_NewPrimArray (JvPrimClass (char), length);\n-}\n-\n-jbooleanArray\n-JvNewBooleanArray (jint length)\n-{\n-  return (jbooleanArray) _Jv_NewPrimArray (JvPrimClass (boolean), length);\n-}\n-\n-jbyteArray\n-JvNewByteArray (jint length)\n-{\n-  return (jbyteArray) _Jv_NewPrimArray (JvPrimClass (byte), length);\n-}\n-\n-jshortArray\n-JvNewShortArray (jint length)\n-{\n-  return (jshortArray) _Jv_NewPrimArray (JvPrimClass (short), length);\n-}\n-\n-jintArray\n-JvNewIntArray (jint length)\n-{\n-  return (jintArray) _Jv_NewPrimArray (JvPrimClass (int), length);\n-}\n-\n-jlongArray\n-JvNewLongArray (jint length)\n-{\n-  return (jlongArray) _Jv_NewPrimArray (JvPrimClass (long), length);\n-}\n-\n-jfloatArray\n-JvNewFloatArray (jint length)\n-{\n-  return (jfloatArray) _Jv_NewPrimArray (JvPrimClass (float), length);\n-}\n-\n-jdoubleArray\n-JvNewDoubleArray (jint length)\n-{\n-  return (jdoubleArray) _Jv_NewPrimArray (JvPrimClass (double), length);\n-}\n-\n jobject\n _Jv_NewArray (jint type, jint size)\n {\n@@ -919,24 +844,35 @@ _Jv_SetMaximumHeapSize (const char *arg)\n \f\n \n void *\n-_Jv_MallocUnchecked (jsize size)\n+_Jv_Malloc (jsize size)\n {\n   if (size == 0)\n     size = 1;\n-  return malloc ((size_t) size);\n+  void *ptr = malloc ((size_t) size);\n+  if (ptr == NULL)\n+    JvThrow (no_memory);\n+  return ptr;\n }\n \n void *\n-_Jv_Malloc (jsize size)\n+_Jv_Realloc (void *ptr, jsize size)\n {\n   if (size == 0)\n     size = 1;\n-  void *ptr = malloc ((size_t) size);\n+  ptr = realloc (ptr, (size_t) size);\n   if (ptr == NULL)\n     JvThrow (no_memory);\n   return ptr;\n }\n \n+void *\n+_Jv_MallocUnchecked (jsize size)\n+{\n+  if (size == 0)\n+    size = 1;\n+  return malloc ((size_t) size);\n+}\n+\n void\n _Jv_Free (void* ptr)\n {"}, {"sha": "b471361530454f8ff7633cb112d89570bd727359", "filename": "libjava/resolve.cc", "status": "modified", "additions": 101, "deletions": 46, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "patch": "@@ -24,6 +24,7 @@ details.  */\n #include <java/lang/InternalError.h>\n #include <java/lang/VirtualMachineError.h>\n #include <java/lang/NoSuchFieldError.h>\n+#include <java/lang/NoSuchMethodError.h>\n #include <java/lang/ClassFormatError.h>\n #include <java/lang/IllegalAccessError.h>\n #include <java/lang/AbstractMethodError.h>\n@@ -230,67 +231,86 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n       _Jv_Method *the_method = 0;\n       jclass found_class = 0;\n \n-      // we make a loop here, because methods are allowed to be moved to\n-      // a super class, and still be visible.. (binary compatibility).\n+      // First search the class itself.\n+      the_method = _Jv_SearchMethodInClass (owner, klass, \n+\t           method_name, method_signature);\n \n-      for (jclass cls = owner; cls != 0; cls = cls->getSuperclass ())\n-\t{\n-\t  for (int i = 0;  i < cls->method_count;  i++)\n-\t    {\n-\t      _Jv_Method *method = &cls->methods[i];\n-\t      if (   (!_Jv_equalUtf8Consts (method->name,\n-\t\t\t\t\t    method_name))\n-\t\t  || (!_Jv_equalUtf8Consts (method->signature,\n-\t\t\t\t\t    method_signature)))\n-\t\tcontinue;\n+      if (the_method != 0)\n+        {\n+\t  found_class = owner;\n+          goto end_of_method_search;\n+\t}\n \n-\t      if (cls == klass \n-\t\t  || ((method->accflags & Modifier::PUBLIC) != 0)\n-\t\t  || (((method->accflags & Modifier::PROTECTED) != 0)\n-\t\t      && cls->isAssignableFrom (klass))\n-\t\t  || (((method->accflags & Modifier::PRIVATE) == 0)\n-\t\t      && _Jv_ClassNameSamePackage (cls->name,\n-\t\t\t\t\t\t   klass->name)))\n-\t\t{\n-\t\t  // FIXME: if (cls->loader != klass->loader), then we\n-\t\t  // must actually check that the types of arguments\n-\t\t  // correspond.  That is, for each argument type, and\n-\t\t  // the return type, doing _Jv_FindClassFromSignature\n-\t\t  // with either loader should produce the same result,\n-\t\t  // i.e., exactly the same jclass object. JVMS 5.4.3.3\n-\n-\t\t  the_method = method;\n+      // If we are resolving an interface method, search the interface's \n+      // superinterfaces (A superinterface is not an interface's superclass - \n+      // a superinterface is implemented by the interface).\n+      if (pool->tags[index] == JV_CONSTANT_InterfaceMethodref)\n+        {\n+\t  _Jv_ifaces ifaces;\n+\t  ifaces.count = 0;\n+\t  ifaces.len = 4;\n+\t  ifaces.list = (jclass *) _Jv_Malloc (ifaces.len * sizeof (jclass *));\n+\n+\t  _Jv_GetInterfaces (owner, &ifaces);\t  \n+          \n+\t  for (int i=0; i < ifaces.count; i++)\n+\t    {\n+\t      jclass cls = ifaces.list[i];\n+\t      the_method = _Jv_SearchMethodInClass (cls, klass, method_name, \n+\t                                            method_signature);\n+\t      if (the_method != 0)\n+\t        {\n \t\t  found_class = cls;\n-\n-\t\t  \n-\t\t  if (pool->tags[index] == JV_CONSTANT_InterfaceMethodref)\n-\t\t    vtable_index = -1;\n-\t\t  else\n-\t\t    vtable_index = _Jv_DetermineVTableIndex\n-\t\t      (cls, method_name, method_signature);\n-\n-\t\t  if (vtable_index == 0)\n-\t\t    throw_incompatible_class_change_error\n-\t\t      (JvNewStringLatin1 (\"method not found\"));\n-\n-\t\t  goto end_of_method_search;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  JvThrow (new java::lang::IllegalAccessError);\n+                  break;\n \t\t}\n \t    }\n+\t  \n+\t  _Jv_Free (ifaces.list);\n+\t  \n+\t  if (the_method != 0)\n+\t    goto end_of_method_search;\n+\t}\n+\n+      // Finally, search superclasses. \n+      for (jclass cls = owner->getSuperclass (); cls != 0; \n+           cls = cls->getSuperclass ())\n+\t{\n+\t  the_method = _Jv_SearchMethodInClass (cls, klass, \n+\t               method_name, method_signature);\n+          if (the_method != 0)\n+\t    {\n+\t      found_class = cls;\n+\t      break;\n+\t    }\n \t}\n \n     end_of_method_search:\n+    \n+      // FIXME: if (cls->loader != klass->loader), then we\n+      // must actually check that the types of arguments\n+      // correspond.  That is, for each argument type, and\n+      // the return type, doing _Jv_FindClassFromSignature\n+      // with either loader should produce the same result,\n+      // i.e., exactly the same jclass object. JVMS 5.4.3.3    \n+    \n+      if (pool->tags[index] == JV_CONSTANT_InterfaceMethodref)\n+\tvtable_index = -1;\n+      else\n+\tvtable_index = _Jv_DetermineVTableIndex\n+\t  (found_class, method_name, method_signature);\n+\n+      if (vtable_index == 0)\n+\tthrow_incompatible_class_change_error\n+\t  (JvNewStringLatin1 (\"method not found\"));\n+\n       if (the_method == 0)\n \t{\n \t  jstring msg = JvNewStringLatin1 (\"method \");\n \t  msg = msg->concat (owner->getName ());\n \t  msg = msg->concat (JvNewStringLatin1(\".\"));\n \t  msg = msg->concat (_Jv_NewStringUTF (method_name->data));\n \t  msg = msg->concat (JvNewStringLatin1(\" was not found.\"));\n-\t  JvThrow(new java::lang::NoSuchFieldError (msg));\n+\t  JvThrow(new java::lang::NoSuchMethodError (msg));\n \t}\n       \n       pool->data[index].rmethod = \n@@ -307,6 +327,41 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n   return pool->data[index];\n }\n \n+// Find a method declared in the cls that is referenced from klass and\n+// perform access checks.\n+_Jv_Method *\n+_Jv_SearchMethodInClass (jclass cls, jclass klass, \n+                         _Jv_Utf8Const *method_name, \n+\t\t\t _Jv_Utf8Const *method_signature)\n+{\n+  using namespace java::lang::reflect;\n+\n+  for (int i = 0;  i < cls->method_count;  i++)\n+    {\n+      _Jv_Method *method = &cls->methods[i];\n+      if (   (!_Jv_equalUtf8Consts (method->name,\n+\t\t\t\t    method_name))\n+\t  || (!_Jv_equalUtf8Consts (method->signature,\n+\t\t\t\t    method_signature)))\n+\tcontinue;\n+\n+      if (cls == klass \n+\t  || ((method->accflags & Modifier::PUBLIC) != 0)\n+\t  || (((method->accflags & Modifier::PROTECTED) != 0)\n+\t      && cls->isAssignableFrom (klass))\n+\t  || (((method->accflags & Modifier::PRIVATE) == 0)\n+\t      && _Jv_ClassNameSamePackage (cls->name,\n+\t\t\t\t\t   klass->name)))\n+\t{\n+\t  return method;\n+\t}\n+      else\n+\t{\n+\t  JvThrow (new java::lang::IllegalAccessError);\n+\t}\n+    }\n+  return 0;\n+}\n \n void\n _Jv_ResolveField (_Jv_Field *field, java::lang::ClassLoader *loader)"}]}