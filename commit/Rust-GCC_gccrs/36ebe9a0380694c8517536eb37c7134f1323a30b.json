{"sha": "36ebe9a0380694c8517536eb37c7134f1323a30b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZlYmU5YTAzODA2OTRjODUxNzUzNmViMzdjNzEzNGYxMzIzYTMwYg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-12-30T22:13:41Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-01-06T10:01:17Z"}, "message": "This brings structs back in post HIR changes. It supports structs\nwhere no base struct is referenced and the constructor is in order.", "tree": {"sha": "06901ff25aa5ea093184e0713bd0363735408959", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06901ff25aa5ea093184e0713bd0363735408959"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36ebe9a0380694c8517536eb37c7134f1323a30b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36ebe9a0380694c8517536eb37c7134f1323a30b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36ebe9a0380694c8517536eb37c7134f1323a30b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36ebe9a0380694c8517536eb37c7134f1323a30b/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "467141184aa274126ff7e2a41d08bb621b7a3fdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/467141184aa274126ff7e2a41d08bb621b7a3fdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/467141184aa274126ff7e2a41d08bb621b7a3fdf"}], "stats": {"total": 1021, "additions": 933, "deletions": 88}, "files": [{"sha": "584e210e068dc33dc8dcb5c522b66e0c2fd0f312", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -1571,9 +1571,16 @@ class StructExprField\n \n   virtual Location get_locus_slow () const = 0;\n \n+  NodeId get_node_id () const { return node_id; }\n+\n protected:\n   // pure virtual clone implementation\n   virtual StructExprField *clone_struct_expr_field_impl () const = 0;\n+\n+  StructExprField () : node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  NodeId node_id;\n };\n \n // Identifier-only variant of StructExprField AST node\n@@ -1584,7 +1591,8 @@ class StructExprFieldIdentifier : public StructExprField\n \n public:\n   StructExprFieldIdentifier (Identifier field_identifier, Location locus)\n-    : field_name (std::move (field_identifier)), locus (locus)\n+    : StructExprField (), field_name (std::move (field_identifier)),\n+      locus (locus)\n   {}\n \n   std::string as_string () const override { return field_name; }\n@@ -1611,7 +1619,7 @@ class StructExprFieldWithVal : public StructExprField\n \n protected:\n   StructExprFieldWithVal (std::unique_ptr<Expr> field_value)\n-    : value (std::move (field_value))\n+    : StructExprField (), value (std::move (field_value))\n   {}\n \n   // Copy constructor requires clone\n@@ -1769,6 +1777,15 @@ class StructExprStructFields : public StructExprStruct\n     return fields;\n   }\n \n+  void iterate (std::function<bool (StructExprField *)> cb)\n+  {\n+    for (auto &field : fields)\n+      {\n+\tif (!cb (field.get ()))\n+\t  return;\n+      }\n+  }\n+\n   StructBase &get_struct_base () { return struct_base; }\n   const StructBase &get_struct_base () const { return struct_base; }\n "}, {"sha": "9bd8de47c1f55caa9854c1c6da25c8e94dfd524a", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -1746,6 +1746,8 @@ class Struct : public VisItem\n     return where_clause;\n   }\n \n+  Identifier get_identifier () const { return struct_name; }\n+\n protected:\n   Struct (Identifier struct_name,\n \t  std::vector<std::unique_ptr<GenericParam> > generic_params,\n@@ -1802,6 +1804,8 @@ struct StructField\n \n   // should this store location info?\n \n+  NodeId node_id;\n+\n public:\n   // Returns whether struct field has any outer attributes.\n   bool has_outer_attributes () const { return !outer_attrs.empty (); }\n@@ -1877,6 +1881,8 @@ struct StructField\n   }\n \n   Visibility get_visibility () const { return visibility; }\n+\n+  NodeId get_node_id () const { return node_id; }\n };\n \n // Rust struct declaration with true struct type AST node\n@@ -1922,6 +1928,15 @@ class StructStruct : public Struct\n   std::vector<StructField> &get_fields () { return fields; }\n   const std::vector<StructField> &get_fields () const { return fields; }\n \n+  void iterate (std::function<bool (StructField &)> cb)\n+  {\n+    for (auto &field : fields)\n+      {\n+\tif (!cb (field))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "9f1475ae779e8e6c6622713ce97dab8f01d1695f", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -227,6 +227,14 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::FnType &type) override { gcc_unreachable (); }\n \n+  void visit (TyTy::ADTType &type) override\n+  {\n+    ::Btype *compiled_type = nullptr;\n+    bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n+    rust_assert (ok);\n+    translated = compiled_type;\n+  }\n+\n   void visit (TyTy::ArrayType &type) override\n   {\n     mpz_t ival;"}, {"sha": "7b01e0efa412c7b2e9c99c88b69be86e39109b02", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-compile-tyty.h\"\n #include \"rust-compile-resolve-path.h\"\n #include \"rust-compile-block.h\"\n+#include \"rust-compile-struct-field-expr.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -56,7 +57,7 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::CallExpr &expr)\n   {\n-    Bexpression *fn = ResolvePath::Compile (expr.get_fnexpr (), ctx);\n+    Bexpression *fn = ResolvePathRef::Compile (expr.get_fnexpr (), ctx);\n     rust_assert (fn != nullptr);\n \n     std::vector<Bexpression *> args;\n@@ -355,6 +356,25 @@ class CompileExpr : public HIRCompileBase\n     ctx->add_statement (block_stmt);\n   }\n \n+  void visit (HIR::StructExprStructFields &struct_expr)\n+  {\n+    Btype *type\n+      = ResolvePathType::Compile (&struct_expr.get_struct_name (), ctx);\n+\n+    // this assumes all fields are in order from type resolution and if a base\n+    // struct was specified those fields are filed via accesors\n+    std::vector<Bexpression *> vals;\n+    struct_expr.iterate ([&] (HIR::StructExprField *field) mutable -> bool {\n+      Bexpression *expr = CompileStructExprField::Compile (field, ctx);\n+      vals.push_back (expr);\n+      return true;\n+    });\n+\n+    translated\n+      = ctx->get_backend ()->constructor_expression (type, vals,\n+\t\t\t\t\t\t     struct_expr.get_locus ());\n+  }\n+\n private:\n   CompileExpr (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n "}, {"sha": "aa659627586e868dd25e79d3cc389f2d9e2aac7c", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -39,6 +39,35 @@ class CompileItem : public HIRCompileBase\n \n   virtual ~CompileItem () {}\n \n+  void visit (HIR::StructStruct &struct_decl)\n+  {\n+    std::vector<Backend::Btyped_identifier> fields;\n+    struct_decl.iterate ([&] (HIR::StructField &field) mutable -> bool {\n+      TyTy::TyBase *resolved_type = nullptr;\n+      bool ok\n+\t= ctx->get_tyctx ()->lookup_type (field.get_mappings ().get_hirid (),\n+\t\t\t\t\t  &resolved_type);\n+      rust_assert (ok);\n+\n+      Btype *compiled_field_ty\n+\t= TyTyCompile::compile (ctx->get_backend (), resolved_type);\n+\n+      Backend::Btyped_identifier f (field.field_name, compiled_field_ty,\n+\t\t\t\t    field.get_locus ());\n+      fields.push_back (std::move (f));\n+      return true;\n+    });\n+\n+    Btype *struct_type_record = ctx->get_backend ()->struct_type (fields);\n+    Btype *named_struct\n+      = ctx->get_backend ()->named_type (struct_decl.get_identifier (),\n+\t\t\t\t\t struct_type_record,\n+\t\t\t\t\t struct_decl.get_locus ());\n+    ctx->push_type (named_struct);\n+    ctx->insert_compiled_type (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t       named_struct);\n+  }\n+\n   void visit (HIR::ConstantItem &constant)\n   {\n     TyTy::TyBase *resolved_type = nullptr;"}, {"sha": "c24005e00c9cecce855221797c0fc05ccfa80036", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -25,7 +25,7 @@ namespace Rust {\n namespace Compile {\n \n void\n-ResolvePath::visit (HIR::PathInExpression &expr)\n+ResolvePathRef::visit (HIR::PathInExpression &expr)\n {\n   // need to look up the reference for this identifier\n   NodeId ref_node_id;\n@@ -70,5 +70,33 @@ ResolvePath::visit (HIR::PathInExpression &expr)\n     = ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n }\n \n+void\n+ResolvePathType::visit (HIR::PathInExpression &expr)\n+{\n+  // need to look up the reference for this identifier\n+  NodeId ref_node_id;\n+  if (!ctx->get_resolver ()->lookup_resolved_name (\n+\texpr.get_mappings ().get_nodeid (), &ref_node_id))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"failed to look up resolved name\");\n+      return;\n+    }\n+\n+  HirId ref;\n+  if (!ctx->get_mappings ()->lookup_node_to_hir (\n+\texpr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+      return;\n+    }\n+\n+  // assumes paths are functions for now\n+  if (!ctx->lookup_compiled_types (ref, &resolved))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"forward decl was not compiled\");\n+      return;\n+    }\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "a5543d2bdbb070b84bcf1f02ef82049c1daf76ce", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -25,27 +25,44 @@\n namespace Rust {\n namespace Compile {\n \n-class ResolvePath : public HIRCompileBase\n+class ResolvePathRef : public HIRCompileBase\n {\n public:\n   static Bexpression *Compile (HIR::Expr *expr, Context *ctx)\n   {\n-    ResolvePath resolver (ctx);\n+    ResolvePathRef resolver (ctx);\n     expr->accept_vis (resolver);\n     rust_assert (resolver.resolved != nullptr);\n     return resolver.resolved;\n   }\n \n-  virtual ~ResolvePath () {}\n-\n   void visit (HIR::PathInExpression &expr);\n \n private:\n-  ResolvePath (Context *ctx) : HIRCompileBase (ctx), resolved (nullptr) {}\n+  ResolvePathRef (Context *ctx) : HIRCompileBase (ctx), resolved (nullptr) {}\n \n   Bexpression *resolved;\n };\n \n+class ResolvePathType : public HIRCompileBase\n+{\n+public:\n+  static Btype *Compile (HIR::Expr *expr, Context *ctx)\n+  {\n+    ResolvePathType resolver (ctx);\n+    expr->accept_vis (resolver);\n+    rust_assert (resolver.resolved != nullptr);\n+    return resolver.resolved;\n+  }\n+\n+  void visit (HIR::PathInExpression &expr);\n+\n+private:\n+  ResolvePathType (Context *ctx) : HIRCompileBase (ctx), resolved (nullptr) {}\n+\n+  Btype *resolved;\n+};\n+\n } // namespace Compile\n } // namespace Rust\n "}, {"sha": "a394f7a88e44d883da6171caaa6d538f09d4050a", "filename": "gcc/rust/backend/rust-compile-struct-field-expr.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -0,0 +1,52 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_STRUCT_FIELD_EXPR\n+#define RUST_COMPILE_STRUCT_FIELD_EXPR\n+\n+#include \"rust-compile-base.h\"\n+#include \"rust-compile-tyty.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileStructExprField : public HIRCompileBase\n+{\n+public:\n+  static Bexpression *Compile (HIR::StructExprField *field, Context *ctx)\n+  {\n+    CompileStructExprField compiler (ctx);\n+    field->accept_vis (compiler);\n+    rust_assert (compiler.translated != nullptr);\n+    return compiler.translated;\n+  }\n+\n+  void visit (HIR::StructExprFieldIdentifierValue &field);\n+\n+private:\n+  CompileStructExprField (Context *ctx)\n+    : HIRCompileBase (ctx), translated (nullptr)\n+  {}\n+\n+  Bexpression *translated;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_STRUCT_FIELD_EXPR"}, {"sha": "24b45ee3c883e7749c23f15a656c8bfffb879cab", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -19,6 +19,7 @@\n #include \"rust-compile.h\"\n #include \"rust-compile-item.h\"\n #include \"rust-compile-expr.h\"\n+#include \"rust-compile-struct-field-expr.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -152,5 +153,13 @@ CompileConditionalBlocks::visit (HIR::IfExprConseqIf &expr)\n \t\t\t\t\t else_block, expr.get_locus ());\n }\n \n+// rust-compile-struct-field-expr.h\n+\n+void\n+CompileStructExprField::visit (HIR::StructExprFieldIdentifierValue &field)\n+{\n+  translated = CompileExpr::Compile (field.get_value (), ctx);\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "6fdb32c8800f52d303a5f26994b47d384ea0e465", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 83, "deletions": 18, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-diagnostics.h\"\n #include \"rust-ast-lower-base.h\"\n #include \"rust-ast-lower-block.h\"\n+#include \"rust-ast-lower-struct-field-expr.h\"\n \n namespace Rust {\n namespace HIR {\n@@ -62,6 +63,47 @@ class ArrayCapacityConstant : public ASTLoweringBase\n   size_t result;\n }; // namespace Resolver\n \n+class ASTLowerPathInExpression : public ASTLoweringBase\n+{\n+public:\n+  static HIR::PathInExpression *translate (AST::PathInExpression *expr)\n+  {\n+    ASTLowerPathInExpression compiler;\n+    expr->accept_vis (compiler);\n+    rust_assert (compiler.translated);\n+    return compiler.translated;\n+  }\n+\n+  ~ASTLowerPathInExpression () {}\n+\n+  void visit (AST::PathInExpression &expr)\n+  {\n+    std::vector<HIR::PathExprSegment> path_segments;\n+    expr.iterate_path_segments ([&] (AST::PathExprSegment &s) mutable -> bool {\n+      rust_assert (s.has_generic_args () == false); // TODO\n+\n+      HIR::PathIdentSegment is (s.get_ident_segment ().as_string ());\n+      HIR::PathExprSegment seg (is, s.get_locus ());\n+      path_segments.push_back (seg);\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::PathInExpression (mapping, std::move (path_segments),\n+\t\t\t\t\t    expr.get_locus (),\n+\t\t\t\t\t    expr.opening_scope_resolution ());\n+  }\n+\n+private:\n+  ASTLowerPathInExpression () : translated (nullptr) {}\n+\n+  HIR::PathInExpression *translated;\n+};\n+\n class ASTLoweringExpr : public ASTLoweringBase\n {\n public:\n@@ -107,24 +149,7 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::PathInExpression &expr)\n   {\n-    std::vector<HIR::PathExprSegment> path_segments;\n-    expr.iterate_path_segments ([&] (AST::PathExprSegment &s) mutable -> bool {\n-      rust_assert (s.has_generic_args () == false); // TODO\n-\n-      HIR::PathIdentSegment is (s.get_ident_segment ().as_string ());\n-      HIR::PathExprSegment seg (is, s.get_locus ());\n-      path_segments.push_back (seg);\n-      return true;\n-    });\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated = new HIR::PathInExpression (mapping, std::move (path_segments),\n-\t\t\t\t\t    expr.get_locus (),\n-\t\t\t\t\t    expr.opening_scope_resolution ());\n+    translated = ASTLowerPathInExpression::translate (&expr);\n   }\n \n   void visit (AST::ReturnExpr &expr)\n@@ -431,6 +456,46 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t\t  expr.get_locus ());\n   }\n \n+  void visit (AST::StructExprStructFields &struct_expr)\n+  {\n+    std::vector<HIR::Attribute> inner_attribs;\n+    std::vector<HIR::Attribute> outer_attribs;\n+\n+    // bit of a hack for now\n+    HIR::PathInExpression *path\n+      = ASTLowerPathInExpression::translate (&struct_expr.get_struct_name ());\n+    HIR::PathInExpression copied_path (*path);\n+    delete path;\n+\n+    HIR::StructBase *base = nullptr;\n+    if (struct_expr.has_struct_base ())\n+      {\n+\tHIR::Expr *translated_base = ASTLoweringExpr::translate (\n+\t  struct_expr.get_struct_base ().get_base_struct ().get ());\n+\tbase\n+\t  = new HIR::StructBase (std::unique_ptr<HIR::Expr> (translated_base));\n+      }\n+\n+    std::vector<std::unique_ptr<HIR::StructExprField> > fields;\n+    struct_expr.iterate ([&] (AST::StructExprField *field) mutable -> bool {\n+      HIR::StructExprField *translated\n+\t= ASTLowerStructExprField::translate (field);\n+      fields.push_back (std::unique_ptr<HIR::StructExprField> (translated));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, struct_expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::StructExprStructFields (mapping, copied_path,\n+\t\t\t\t\t std::move (fields),\n+\t\t\t\t\t struct_expr.get_locus (), base,\n+\t\t\t\t\t inner_attribs, outer_attribs);\n+  }\n+\n private:\n   ASTLoweringExpr () : translated (nullptr), translated_array_elems (nullptr) {}\n "}, {"sha": "3ac85aae7cb8a5bb60e613f976617e908a8c7d7d", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -43,6 +43,57 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   virtual ~ASTLoweringItem () {}\n \n+  void visit (AST::StructStruct &struct_decl)\n+  {\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+    std::vector<HIR::Attribute> outer_attrs;\n+\n+    bool is_unit = false;\n+    std::vector<HIR::StructField> fields;\n+    struct_decl.iterate ([&] (AST::StructField &field) mutable -> bool {\n+      std::vector<HIR::Attribute> outer_attrs;\n+      HIR::Visibility vis = HIR::Visibility::create_public ();\n+      HIR::Type *type\n+\t= ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     mappings->get_next_localdef_id (\n+\t\t\t\t       crate_num));\n+\n+      // FIXME\n+      // AST::StructField is missing Location info\n+      Location field_locus;\n+      HIR::StructField translated_field (mapping, field.get_field_name (),\n+\t\t\t\t\t std::unique_ptr<HIR::Type> (type), vis,\n+\t\t\t\t\t field_locus, outer_attrs);\n+      fields.push_back (std::move (translated_field));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::StructStruct (mapping, std::move (fields),\n+\t\t\t\t\tstruct_decl.get_identifier (),\n+\t\t\t\t\tstd::move (generic_params),\n+\t\t\t\t\tstd::move (where_clause), is_unit, vis,\n+\t\t\t\t\tstd::move (outer_attrs),\n+\t\t\t\t\tstruct_decl.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       struct_decl.get_locus ());\n+  }\n+\n   void visit (AST::ConstantItem &constant)\n   {\n     std::vector<HIR::Attribute> outer_attrs;"}, {"sha": "1b444a5a28b5d179031c58bf5b5db3f12238723a", "filename": "gcc/rust/hir/rust-ast-lower-struct-field-expr.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fhir%2Frust-ast-lower-struct-field-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fhir%2Frust-ast-lower-struct-field-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-struct-field-expr.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_STRUCT_FIELD_EXPR\n+#define RUST_AST_LOWER_STRUCT_FIELD_EXPR\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-ast-lower-base.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLowerStructExprField : public ASTLoweringBase\n+{\n+public:\n+  static HIR::StructExprField *translate (AST::StructExprField *field)\n+  {\n+    ASTLowerStructExprField compiler;\n+    field->accept_vis (compiler);\n+    rust_assert (compiler.translated != nullptr);\n+\n+    // compiler.mappings->insert_hir_expr (\n+    //   compiler.translated->get_mappings ().get_crate_num (),\n+    //   compiler.translated->get_mappings ().get_hirid (),\n+    //   compiler.translated);\n+\n+    return compiler.translated;\n+  }\n+\n+  ~ASTLowerStructExprField () {}\n+\n+  void visit (AST::StructExprFieldIdentifierValue &field);\n+\n+private:\n+  ASTLowerStructExprField () : translated (nullptr) {}\n+\n+  HIR::StructExprField *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_STRUCT_FIELD_EXPR"}, {"sha": "8dd88007d8355f1437b38a2d05a8217e8135b616", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -149,5 +149,22 @@ ASTLoweringIfBlock::visit (AST::IfExprConseqIf &expr)\n \t\t\t       expr.get_locus ());\n }\n \n+// rust-ast-lower-struct-field-expr.h\n+\n+void\n+ASTLowerStructExprField::visit (AST::StructExprFieldIdentifierValue &field)\n+{\n+  HIR::Expr *value = ASTLoweringExpr::translate (field.get_value ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::StructExprFieldIdentifierValue (\n+    mapping, field.get_field_name (), std::unique_ptr<HIR::Expr> (value),\n+    field.get_locus ());\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "bf564cdcd755b94e8f259d25ea42be333cd8240e", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 53, "deletions": 31, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -1315,9 +1315,9 @@ class TupleIndexExpr : public ExprWithoutBlock\n // Base struct/tuple/union value creator HIR node (abstract)\n class StructExpr : public ExprWithoutBlock\n {\n+protected:\n   PathInExpression struct_name;\n \n-protected:\n   // Protected constructor to allow initialising struct_name\n   StructExpr (Analysis::NodeMapping mappings, PathInExpression struct_path,\n \t      std::vector<Attribute> outer_attribs)\n@@ -1326,7 +1326,7 @@ class StructExpr : public ExprWithoutBlock\n   {}\n \n public:\n-  const PathInExpression &get_struct_name () const { return struct_name; }\n+  PathInExpression &get_struct_name () { return struct_name; }\n \n   std::string as_string () const override;\n };\n@@ -1417,6 +1417,8 @@ struct StructBase\n   bool is_invalid () const { return base_struct == nullptr; }\n \n   std::string as_string () const;\n+\n+  Expr *get_base () { return base_struct.get (); }\n };\n \n /* Base HIR node for a single struct expression field (in struct instance\n@@ -1436,9 +1438,20 @@ class StructExprField\n \n   virtual void accept_vis (HIRVisitor &vis) = 0;\n \n+  Analysis::NodeMapping &get_mappings () { return mappings; }\n+\n+  Location get_locus () { return locus; }\n+\n protected:\n   // pure virtual clone implementation\n   virtual StructExprField *clone_struct_expr_field_impl () const = 0;\n+\n+  StructExprField (Analysis::NodeMapping mapping, Location locus)\n+    : mappings (mapping), locus (locus)\n+  {}\n+\n+  Analysis::NodeMapping mappings;\n+  Location locus;\n };\n \n // Identifier-only variant of StructExprField HIR node\n@@ -1449,8 +1462,10 @@ class StructExprFieldIdentifier : public StructExprField\n \n   // TODO: should this store location data?\n \n-  StructExprFieldIdentifier (Identifier field_identifier)\n-    : field_name (std::move (field_identifier))\n+  StructExprFieldIdentifier (Analysis::NodeMapping mapping,\n+\t\t\t     Identifier field_identifier, Location locus)\n+    : StructExprField (mapping, locus),\n+      field_name (std::move (field_identifier))\n   {}\n \n   std::string as_string () const override { return field_name; }\n@@ -1470,23 +1485,26 @@ class StructExprFieldIdentifier : public StructExprField\n  * abstract */\n class StructExprFieldWithVal : public StructExprField\n {\n-public:\n   std::unique_ptr<Expr> value;\n \n protected:\n-  StructExprFieldWithVal (std::unique_ptr<Expr> field_value)\n-    : value (std::move (field_value))\n+  StructExprFieldWithVal (Analysis::NodeMapping mapping,\n+\t\t\t  std::unique_ptr<Expr> field_value, Location locus)\n+    : StructExprField (mapping, locus), value (std::move (field_value))\n   {}\n \n   // Copy constructor requires clone\n   StructExprFieldWithVal (StructExprFieldWithVal const &other)\n-    : value (other.value->clone_expr ())\n+    : StructExprField (other.mappings, other.locus),\n+      value (other.value->clone_expr ())\n   {}\n \n   // Overload assignment operator to clone unique_ptr\n   StructExprFieldWithVal &operator= (StructExprFieldWithVal const &other)\n   {\n     value = other.value->clone_expr ();\n+    mappings = other.mappings;\n+    locus = other.locus;\n \n     return *this;\n   }\n@@ -1497,6 +1515,8 @@ class StructExprFieldWithVal : public StructExprField\n \n public:\n   std::string as_string () const override;\n+\n+  Expr *get_value () { return value.get (); }\n };\n \n // Identifier and value variant of StructExprField HIR node\n@@ -1507,9 +1527,11 @@ class StructExprFieldIdentifierValue : public StructExprFieldWithVal\n \n   // TODO: should this store location data?\n \n-  StructExprFieldIdentifierValue (Identifier field_identifier,\n-\t\t\t\t  std::unique_ptr<Expr> field_value)\n-    : StructExprFieldWithVal (std::move (field_value)),\n+  StructExprFieldIdentifierValue (Analysis::NodeMapping mapping,\n+\t\t\t\t  Identifier field_identifier,\n+\t\t\t\t  std::unique_ptr<Expr> field_value,\n+\t\t\t\t  Location locus)\n+    : StructExprFieldWithVal (mapping, std::move (field_value), locus),\n       field_name (std::move (field_identifier))\n   {}\n \n@@ -1534,9 +1556,11 @@ class StructExprFieldIndexValue : public StructExprFieldWithVal\n \n   // TODO: should this store location data?\n \n-  StructExprFieldIndexValue (TupleIndex tuple_index,\n-\t\t\t     std::unique_ptr<Expr> field_value)\n-    : StructExprFieldWithVal (std::move (field_value)), index (tuple_index)\n+  StructExprFieldIndexValue (Analysis::NodeMapping mapping,\n+\t\t\t     TupleIndex tuple_index,\n+\t\t\t     std::unique_ptr<Expr> field_value, Location locus)\n+    : StructExprFieldWithVal (mapping, std::move (field_value), locus),\n+      index (tuple_index)\n   {}\n \n   std::string as_string () const override;\n@@ -1560,31 +1584,24 @@ class StructExprStructFields : public StructExprStruct\n   std::vector<std::unique_ptr<StructExprField> > fields;\n \n   // bool has_struct_base;\n-  StructBase struct_base;\n+  // FIXME make unique_ptr\n+  StructBase *struct_base;\n \n   std::string as_string () const override;\n \n-  bool has_struct_base () const { return !struct_base.is_invalid (); }\n-\n-  /*inline std::vector<std::unique_ptr<StructExprField>> get_fields()\n-  const { return fields;\n-  }*/\n-\n-  /*inline StructBase get_struct_base() const {\n-      return has_struct_base ? struct_base : StructBase::error();\n-  }*/\n+  bool has_struct_base () const { return struct_base != nullptr; }\n \n   // Constructor for StructExprStructFields when no struct base is used\n   StructExprStructFields (\n     Analysis::NodeMapping mappings, PathInExpression struct_path,\n     std::vector<std::unique_ptr<StructExprField> > expr_fields, Location locus,\n-    StructBase base_struct = StructBase::error (),\n+    StructBase *base_struct,\n     std::vector<Attribute> inner_attribs = std::vector<Attribute> (),\n     std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n     : StructExprStruct (std::move (mappings), std::move (struct_path),\n \t\t\tstd::move (inner_attribs), std::move (outer_attribs),\n \t\t\tlocus),\n-      fields (std::move (expr_fields)), struct_base (std::move (base_struct))\n+      fields (std::move (expr_fields)), struct_base (base_struct)\n   {}\n \n   // copy constructor with vector clone\n@@ -1615,6 +1632,15 @@ class StructExprStructFields : public StructExprStruct\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  void iterate (std::function<bool (StructExprField *)> cb)\n+  {\n+    for (auto &field : fields)\n+      {\n+\tif (!cb (field.get ()))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1752,11 +1778,7 @@ class StructExprUnit : public StructExpr\n   Location locus;\n \n public:\n-  std::string as_string () const override\n-  {\n-    return get_struct_name ().as_string ();\n-    // return struct_name.as_string();\n-  }\n+  std::string as_string () const override { return struct_name.as_string (); }\n \n   StructExprUnit (Analysis::NodeMapping mappings, PathInExpression struct_path,\n \t\t  std::vector<Attribute> outer_attribs, Location locus)"}, {"sha": "c72ca65a73f621372569702cdb8b395b68daef65", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -3683,7 +3683,7 @@ StructExprStruct::as_string () const\n {\n   std::string str (\"StructExprStruct (or subclass): \");\n \n-  str += \"\\n Path: \" + get_struct_name ().as_string ();\n+  str += \"\\n Path: \" + struct_name.as_string ();\n \n   // inner attributes\n   str += \"\\n inner attributes: \";\n@@ -3761,7 +3761,7 @@ StructExprStructFields::as_string () const\n     }\n   else\n     {\n-      str += struct_base.as_string ();\n+      str += struct_base->as_string ();\n     }\n \n   return str;"}, {"sha": "1046186c172fd49d5e3a829e990bb7a94148edd6", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -1390,7 +1390,7 @@ class TypeAlias : public VisItem, public TraitImplItem\n // Rust base struct declaration HIR node - abstract base class\n class Struct : public VisItem\n {\n-public:\n+protected:\n   // protected to enable access by derived classes - allows better as_string\n   Identifier struct_name;\n \n@@ -1403,6 +1403,9 @@ class Struct : public VisItem\n \n   Location locus;\n \n+public:\n+  Identifier get_identifier () const { return struct_name; }\n+\n   // Returns whether struct has generic parameters.\n   bool has_generics () const { return !generic_params.empty (); }\n \n@@ -1465,6 +1468,10 @@ struct StructField\n   Identifier field_name;\n   std::unique_ptr<Type> field_type;\n \n+  Analysis::NodeMapping mappings;\n+\n+  Location locus;\n+\n   // should this store location info?\n \n   // Returns whether struct field has any outer attributes.\n@@ -1473,18 +1480,19 @@ struct StructField\n   // Returns whether struct field has a non-private (non-default) visibility.\n   bool has_visibility () const { return !visibility.is_error (); }\n \n-  StructField (Identifier field_name, std::unique_ptr<Type> field_type,\n-\t       Visibility vis,\n+  StructField (Analysis::NodeMapping mappings, Identifier field_name,\n+\t       std::unique_ptr<Type> field_type, Visibility vis, Location locus,\n \t       std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)),\n-      field_name (std::move (field_name)), field_type (std::move (field_type))\n+      field_name (std::move (field_name)), field_type (std::move (field_type)),\n+      mappings (mappings), locus (locus)\n   {}\n \n   // Copy constructor\n   StructField (StructField const &other)\n     : outer_attrs (other.outer_attrs), visibility (other.visibility),\n       field_name (other.field_name),\n-      field_type (other.field_type->clone_type ())\n+      field_type (other.field_type->clone_type ()), mappings (other.mappings)\n   {}\n \n   ~StructField () = default;\n@@ -1496,6 +1504,7 @@ struct StructField\n     field_type = other.field_type->clone_type ();\n     visibility = other.visibility;\n     outer_attrs = other.outer_attrs;\n+    mappings = other.mappings;\n \n     return *this;\n   }\n@@ -1504,20 +1513,19 @@ struct StructField\n   StructField (StructField &&other) = default;\n   StructField &operator= (StructField &&other) = default;\n \n-  // Returns whether struct field is in an error state.\n-  bool is_error () const\n-  {\n-    return field_name.empty () && field_type == nullptr;\n-    // this should really be an or since neither are allowed\n-  }\n+  std::string as_string () const;\n \n-  // Creates an error state struct field.\n-  static StructField create_error ()\n+  Identifier get_field_name () const { return field_name; }\n+\n+  std::unique_ptr<Type> &get_field_type ()\n   {\n-    return StructField (std::string (\"\"), nullptr, Visibility::create_error ());\n+    rust_assert (field_type != nullptr);\n+    return field_type;\n   }\n \n-  std::string as_string () const;\n+  Analysis::NodeMapping get_mappings () const { return mappings; }\n+\n+  Location get_locus () { return locus; }\n };\n \n // Rust struct declaration with true struct type HIR node\n@@ -1560,6 +1568,15 @@ class StructStruct : public Struct\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  void iterate (std::function<bool (StructField &)> cb)\n+  {\n+    for (auto &field : fields)\n+      {\n+\tif (!cb (field))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "2292d16574a0b5fca97a4787117a790936a3dae2", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -21,6 +21,7 @@\n \n #include \"rust-ast-resolve-base.h\"\n #include \"rust-ast-full.h\"\n+#include \"rust-ast-resolve-struct-expr-field.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -38,19 +39,22 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::PathInExpression &expr)\n   {\n+    // name scope first\n     if (!resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n       {\n-\trust_error_at (expr.get_locus (), \"unknown path %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n-    else\n-      {\n-\tresolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n-\tresolver->insert_new_definition (expr.get_node_id (),\n-\t\t\t\t\t Definition{expr.get_node_id (),\n-\t\t\t\t\t\t    parent});\n+\t// check the type scope\n+\tif (!resolver->get_type_scope ().lookup (expr.as_string (),\n+\t\t\t\t\t\t &resolved_node))\n+\t  {\n+\t    rust_error_at (expr.get_locus (), \"unknown path %s\",\n+\t\t\t   expr.as_string ().c_str ());\n+\t    return;\n+\t  }\n       }\n+\n+    resolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n+    resolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t     Definition{expr.get_node_id (), parent});\n   }\n \n   void visit (AST::ReturnExpr &expr)\n@@ -154,6 +158,17 @@ class ResolveExpr : public ResolverBase\n     ResolveExpr::go (elems.get_elem_to_copy ().get (), elems.get_node_id ());\n   }\n \n+  void visit (AST::StructExprStructFields &struct_expr)\n+  {\n+    ResolveExpr::go (&struct_expr.get_struct_name (),\n+\t\t     struct_expr.get_node_id ());\n+    struct_expr.iterate (\n+      [&] (AST::StructExprField *struct_field) mutable -> bool {\n+\tResolveStructExprField::go (struct_field, struct_expr.get_node_id ());\n+\treturn true;\n+      });\n+  }\n+\n private:\n   ResolveExpr (NodeId parent) : ResolverBase (parent) {}\n };"}, {"sha": "523f985b209ce8951adfeebc8b563a917e324403", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -39,6 +39,14 @@ class ResolveItem : public ResolverBase\n \n   ~ResolveItem () {}\n \n+  void visit (AST::StructStruct &struct_decl)\n+  {\n+    struct_decl.iterate ([&] (AST::StructField &field) mutable -> bool {\n+      ResolveType::go (field.get_field_type ().get (), field.get_node_id ());\n+      return true;\n+    });\n+  }\n+\n   void visit (AST::ConstantItem &constant)\n   {\n     ResolveType::go (constant.get_type ().get (), constant.get_node_id ());"}, {"sha": "c705a0357b1891f617894cf1ae8ed27f2b285cbc", "filename": "gcc/rust/resolve/rust-ast-resolve-struct-expr-field.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_STRUCT_EXPR_FIELD\n+#define RUST_AST_RESOLVE_STRUCT_EXPR_FIELD\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// this resolves values being assigned not that the field actually exists yet.\n+// We cant resolve the field to struct until type resolution since the HIR\n+// Mappings don't exist yet.\n+class ResolveStructExprField : public ResolverBase\n+{\n+public:\n+  static void go (AST::StructExprField *field, NodeId parent)\n+  {\n+    ResolveStructExprField resolver (parent);\n+    field->accept_vis (resolver);\n+  }\n+\n+  virtual ~ResolveStructExprField () {}\n+\n+  void visit (AST::StructExprFieldIdentifierValue &field);\n+\n+  // TODO\n+\n+private:\n+  ResolveStructExprField (NodeId parent) : ResolverBase (parent) {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_STRUCT_EXPR_FIELD"}, {"sha": "f770ed7b16668b03298cc5d964dc8d2fda788091", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -36,6 +36,12 @@ class ResolveTopLevel : public ResolverBase\n \n   ~ResolveTopLevel () {}\n \n+  void visit (AST::StructStruct &struct_decl)\n+  {\n+    resolver->get_type_scope ().insert (struct_decl.get_identifier (),\n+\t\t\t\t\tstruct_decl.get_node_id ());\n+  }\n+\n   void visit (AST::ConstantItem &constant)\n   {\n     resolver->get_name_scope ().insert (constant.get_identifier (),"}, {"sha": "dc368aa60d281d0d71498707b31b7878795887d9", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -271,5 +271,13 @@ ResolveExpr::visit (AST::BlockExpr &expr)\n   resolver->get_type_scope ().pop ();\n }\n \n+// rust-ast-resolve-struct-expr-field.h\n+\n+void\n+ResolveStructExprField::visit (AST::StructExprFieldIdentifierValue &field)\n+{\n+  ResolveExpr::go (field.get_value ().get (), field.get_node_id ());\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "fd5a617f1d18d31f508a4409e91963560a0567c6", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-tyty.h\"\n #include \"rust-tyty-call.h\"\n #include \"rust-tyty-resolver.h\"\n+#include \"rust-hir-type-check-struct-field.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -136,9 +137,8 @@ class TypeCheckExpr : public TypeCheckBase\n     TyTy::TyBase *lookup;\n     if (!context->lookup_type (ref, &lookup))\n       {\n-\t// FIXME we need to be able to lookup the location info for the\n-\t// reference here\n-\trust_error_at (expr.get_locus (), \"consider giving this a type: %s\",\n+\trust_error_at (mappings->lookup_location (ref),\n+\t\t       \"consider giving this a type: %s\",\n \t\t       expr.as_string ().c_str ());\n \treturn;\n       }\n@@ -269,6 +269,11 @@ class TypeCheckExpr : public TypeCheckBase\n     infered_array_elems = TypeCheckExpr::Resolve (elems.get_elem_to_copy ());\n   }\n \n+  void visit (HIR::StructExprStructFields &struct_expr)\n+  {\n+    infered = TypeCheckStructExpr::Resolve (&struct_expr);\n+  }\n+\n private:\n   TypeCheckExpr ()\n     : TypeCheckBase (), infered (nullptr), infered_array_elems (nullptr)"}, {"sha": "727569db5cacd7d55d68486596b30d35b46f1b4b", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct-field.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -0,0 +1,61 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_STRUCT_FIELD\n+#define RUST_HIR_TYPE_CHECK_STRUCT_FIELD\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckStructExpr : public TypeCheckBase\n+{\n+public:\n+  static TyTy::TyBase *Resolve (HIR::StructExprStructFields *expr)\n+  {\n+    TypeCheckStructExpr resolver;\n+    expr->accept_vis (resolver);\n+    rust_assert (resolver.resolved != nullptr);\n+    return resolver.resolved;\n+  }\n+\n+  void visit (HIR::StructExprStructFields &struct_expr);\n+\n+  void visit (HIR::PathInExpression &path);\n+\n+  void visit (HIR::StructExprFieldIdentifierValue &field);\n+\n+private:\n+  TypeCheckStructExpr ()\n+    : TypeCheckBase (), resolved (nullptr), struct_path_resolved (nullptr)\n+  {}\n+\n+  TyTy::TyBase *resolved;\n+  TyTy::ADTType *struct_path_resolved;\n+  TyTy::TyBase *resolved_field;\n+  std::set<std::string> fields_assigned;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_STRUCT_FIELD"}, {"sha": "bcffe24209b1d48e2846cc8d55753559269ea588", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -37,6 +37,28 @@ class TypeCheckTopLevel : public TypeCheckBase\n     item->accept_vis (resolver);\n   }\n \n+  void visit (HIR::StructStruct &struct_decl)\n+  {\n+    std::vector<TyTy::StructFieldType *> fields;\n+    struct_decl.iterate ([&] (HIR::StructField &field) mutable -> bool {\n+      TyTy::TyBase *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     field.get_field_name (), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings ().get_hirid (),\n+\t\t\t    ty_field->get_field_type ());\n+      return true;\n+    });\n+\n+    TyTy::TyBase *type\n+      = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t   struct_decl.get_identifier (), std::move (fields));\n+\n+    context->insert_type (struct_decl.get_mappings ().get_hirid (), type);\n+  }\n+\n   void visit (HIR::ConstantItem &constant)\n   {\n     TyTy::TyBase *type = TypeCheckType::Resolve (constant.get_type ());"}, {"sha": "e7d33666826adb2825d84374bd9bcd175f30fae0", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -21,6 +21,7 @@\n #include \"rust-hir-type-check-toplevel.h\"\n #include \"rust-hir-type-check-item.h\"\n #include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-struct-field.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -45,5 +46,123 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n   });\n }\n \n+// RUST_HIR_TYPE_CHECK_STRUCT_FIELD\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n+{\n+  struct_expr.get_struct_name ().accept_vis (*this);\n+  if (struct_path_resolved == nullptr)\n+    {\n+      rust_fatal_error (struct_expr.get_struct_name ().get_locus (),\n+\t\t\t\"Failed to resolve type\");\n+      return;\n+    }\n+\n+  struct_expr.iterate ([&] (HIR::StructExprField *field) mutable -> bool {\n+    resolved_field = nullptr;\n+    field->accept_vis (*this);\n+    if (resolved_field == nullptr)\n+      {\n+\trust_fatal_error (field->get_locus (),\n+\t\t\t  \"failed to resolve type for field\");\n+\treturn false;\n+      }\n+\n+    context->insert_type (field->get_mappings ().get_hirid (), resolved_field);\n+    return true;\n+  });\n+\n+  TyTy::TyBase *expr_type = struct_path_resolved;\n+  if (struct_expr.has_struct_base ())\n+    {\n+      TyTy::TyBase *base_resolved\n+\t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get ());\n+      expr_type = expr_type->combine (base_resolved);\n+      if (resolved == nullptr)\n+\t{\n+\t  rust_fatal_error (\n+\t    struct_expr.struct_base->base_struct->get_locus_slow (),\n+\t    \"incompatible types for base struct reference\");\n+\t  return;\n+\t}\n+    }\n+  else if (fields_assigned.size () != struct_path_resolved->num_fields ())\n+    {\n+      rust_fatal_error (struct_expr.get_locus (),\n+\t\t\t\"some fields are not fully assigned\");\n+      return;\n+    }\n+\n+  resolved = expr_type;\n+}\n+\n+void\n+TypeCheckStructExpr::visit (HIR::PathInExpression &expr)\n+{\n+  NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+\n+  // then lookup the reference_node_id\n+  NodeId ref_node_id;\n+  if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"Failed to lookup reference for node: %s\",\n+\t\t     expr.as_string ().c_str ());\n+      return;\n+    }\n+\n+  // node back to HIR\n+  HirId ref;\n+  if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t     ref_node_id, &ref))\n+    {\n+      rust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+      return;\n+    }\n+\n+  // the base reference for this name _must_ have a type set\n+  TyTy::TyBase *lookup;\n+  if (!context->lookup_type (ref, &lookup))\n+    {\n+      rust_error_at (mappings->lookup_location (ref),\n+\t\t     \"consider giving this a type: %s\",\n+\t\t     expr.as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (lookup->get_kind () != TyTy::TypeKind::ADT)\n+    {\n+      rust_fatal_error (mappings->lookup_location (ref),\n+\t\t\t\"expected an ADT type\");\n+      return;\n+    }\n+  struct_path_resolved = (TyTy::ADTType *) lookup;\n+}\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n+{\n+  auto it = fields_assigned.find (field.field_name);\n+  if (it != fields_assigned.end ())\n+    {\n+      rust_fatal_error (field.get_locus (), \"used more than once\");\n+      return;\n+    }\n+\n+  TyTy::TyBase *value = TypeCheckExpr::Resolve (field.get_value ());\n+  TyTy::StructFieldType *field_type\n+    = struct_path_resolved->get_field (field.field_name);\n+  if (field_type == nullptr)\n+    {\n+      rust_error_at (field.get_locus (), \"unknown field\");\n+      return;\n+    }\n+\n+  resolved_field = field_type->get_field_type ()->combine (value);\n+  if (resolved_field != nullptr)\n+    fields_assigned.insert (field.field_name);\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "e5d33988e4635660ef7ac4f6979bfdece470b49e", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -134,6 +134,24 @@ class InferRules : protected BaseRules\n   TyBase *resolved;\n };\n \n+class StructFieldTypeRules : protected BaseRules\n+{\n+public:\n+  StructFieldTypeRules (StructFieldType *base)\n+    : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+private:\n+  StructFieldType *base;\n+  TyBase *resolved;\n+};\n+\n class UnitRules : protected BaseRules\n {\n public:"}, {"sha": "7658fed862897b219eb902cdefeb005dd0ccb1fd", "filename": "gcc/rust/typecheck/rust-tyty-visitor.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -29,6 +29,8 @@ class TyVisitor\n public:\n   virtual void visit (UnitType &type) {}\n   virtual void visit (InferType &type) {}\n+  virtual void visit (StructFieldType &type) {}\n+  virtual void visit (ADTType &type) {}\n   virtual void visit (FnType &type) {}\n   virtual void visit (ParamType &type) {}\n   virtual void visit (ArrayType &type) {}"}, {"sha": "756301b61a0efab46270eab6dc5640f58b5e6760", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -63,6 +63,47 @@ InferType::combine (TyBase *other)\n   return r.combine (other);\n }\n \n+void\n+StructFieldType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+StructFieldType::as_string () const\n+{\n+  return name + \":\" + ty->as_string ();\n+}\n+\n+TyBase *\n+StructFieldType::combine (TyBase *other)\n+{\n+  StructFieldTypeRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+ADTType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ADTType::as_string () const\n+{\n+  std::string fields_buffer;\n+  for (auto &field : fields)\n+    fields_buffer += field->as_string () + \"\\n\";\n+\n+  return identifier + \"{\\n\" + fields_buffer + \"\\n}\";\n+}\n+\n+TyBase *\n+ADTType::combine (TyBase *other)\n+{\n+  return nullptr;\n+}\n+\n void\n FnType::accept_vis (TyVisitor &vis)\n {"}, {"sha": "4ff78fff2e08bd3dbbb562e0daee43823388839b", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36ebe9a0380694c8517536eb37c7134f1323a30b/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=36ebe9a0380694c8517536eb37c7134f1323a30b", "patch": "@@ -41,6 +41,7 @@ enum TypeKind\n   UINT,\n   FLOAT,\n   UNIT,\n+  FIELD,\n   // there are more to add...\n };\n \n@@ -60,6 +61,8 @@ class TyBase\n \n   virtual bool is_unit () const { return kind == TypeKind::UNIT; }\n \n+  TypeKind get_kind () const { return kind; }\n+\n protected:\n   TyBase (HirId ref, TypeKind kind) : kind (kind), ref (ref) {}\n \n@@ -95,6 +98,65 @@ class UnitType : public TyBase\n   TyBase *combine (TyBase *other) override;\n };\n \n+class StructFieldType : public TyBase\n+{\n+public:\n+  StructFieldType (HirId ref, std::string name, TyBase *ty)\n+    : TyBase (ref, TypeKind::FIELD), name (name), ty (ty)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  bool is_unit () const override { return ty->is_unit (); }\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  std::string get_name () const { return name; }\n+\n+  TyBase *get_field_type () { return ty; }\n+\n+private:\n+  std::string name;\n+  TyBase *ty;\n+};\n+\n+class ADTType : public TyBase\n+{\n+public:\n+  ADTType (HirId ref, std::string identifier,\n+\t   std::vector<StructFieldType *> fields)\n+    : TyBase (ref, TypeKind::ADT), identifier (identifier), fields (fields)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  bool is_unit () const override { return false; }\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  size_t num_fields () const { return fields.size (); }\n+\n+  StructFieldType *get_field (size_t index) { return fields.at (index); }\n+\n+  StructFieldType *get_field (const std::string &lookup)\n+  {\n+    for (auto &field : fields)\n+      {\n+\tif (field->get_name ().compare (lookup) == 0)\n+\t  return field;\n+      }\n+    return nullptr;\n+  }\n+\n+private:\n+  std::string identifier;\n+  std::vector<StructFieldType *> fields;\n+};\n+\n class ParamType : public TyBase\n {\n public:"}]}