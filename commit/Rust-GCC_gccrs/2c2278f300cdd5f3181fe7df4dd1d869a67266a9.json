{"sha": "2c2278f300cdd5f3181fe7df4dd1d869a67266a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMyMjc4ZjMwMGNkZDVmMzE4MWZlN2RmNGRkMWQ4NjlhNjcyNjZhOQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-10-20T10:18:35Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-10-20T10:37:48Z"}, "message": "libstdc++: Remove inheritance from std::coroutine_handle<> [LWG 3460]\n\nThis removes the coroutine_handle<> base class from the primary template\nand the noop_coroutine_promise explicit specialization. To preserve the\nAPI various members are added, as they are no longer inherited from the\nbase class.\n\nI've also tweaked some indentation and formatting, and replaced\nsubclause numbers from the standard with stable names like\n[coroutine.handle.con].\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/coroutine (coroutine_handle<_Promise>): Remove\n\tbase class. Add constructors, conversions, accessors etc. as\n\tproposed for LWG 3460.\n\t(coroutine_handle<noop_coroutine_promise>): Likewise.\n\t* testsuite/18_support/coroutines/lwg3460.cc: New test.", "tree": {"sha": "ad787a015636ecdd36359e7801ee45298c6128ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad787a015636ecdd36359e7801ee45298c6128ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c2278f300cdd5f3181fe7df4dd1d869a67266a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c2278f300cdd5f3181fe7df4dd1d869a67266a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c2278f300cdd5f3181fe7df4dd1d869a67266a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c2278f300cdd5f3181fe7df4dd1d869a67266a9/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c3846e80210ba437644b5b91d9bd9c564ca565a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c3846e80210ba437644b5b91d9bd9c564ca565a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c3846e80210ba437644b5b91d9bd9c564ca565a"}], "stats": {"total": 199, "additions": 144, "deletions": 55}, "files": [{"sha": "6e1cf141579a3f85ed02ad3282151f6c78662a50", "filename": "libstdc++-v3/include/std/coroutine", "status": "modified", "additions": 90, "deletions": 55, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2278f300cdd5f3181fe7df4dd1d869a67266a9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcoroutine", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2278f300cdd5f3181fe7df4dd1d869a67266a9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcoroutine", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcoroutine?ref=2c2278f300cdd5f3181fe7df4dd1d869a67266a9", "patch": "@@ -87,7 +87,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     coroutine_handle<void>\n     {\n     public:\n-      // 17.12.3.1, construct/reset\n+      // [coroutine.handle.con], construct/reset\n       constexpr coroutine_handle() noexcept : _M_fr_ptr(0) {}\n \n       constexpr coroutine_handle(std::nullptr_t __h) noexcept\n@@ -101,7 +101,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n     public:\n-      // 17.12.3.2, export/import\n+      // [coroutine.handle.export.import], export/import\n       constexpr void* address() const noexcept { return _M_fr_ptr; }\n \n       constexpr static coroutine_handle from_address(void* __a) noexcept\n@@ -112,15 +112,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n     public:\n-      // 17.12.3.3, observers\n+      // [coroutine.handle.observers], observers\n       constexpr explicit operator bool() const noexcept\n       {\n \treturn bool(_M_fr_ptr);\n       }\n \n       bool done() const noexcept { return __builtin_coro_done(_M_fr_ptr); }\n \n-      // 17.12.3.4, resumption\n+      // [coroutine.handle.resumption], resumption\n       void operator()() const { resume(); }\n \n       void resume() const { __builtin_coro_resume(_M_fr_ptr); }\n@@ -131,87 +131,118 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void* _M_fr_ptr;\n   };\n \n-  // 17.12.3.6 Comparison operators\n-  /// [coroutine.handle.compare]\n-  constexpr bool operator==(coroutine_handle<> __a,\n-\t\t\t    coroutine_handle<> __b) noexcept\n+  // [coroutine.handle.compare], comparison operators\n+\n+  constexpr bool\n+  operator==(coroutine_handle<> __a, coroutine_handle<> __b) noexcept\n   {\n     return __a.address() == __b.address();\n   }\n \n #if _COROUTINES_USE_SPACESHIP\n   constexpr strong_ordering\n   operator<=>(coroutine_handle<> __a, coroutine_handle<> __b) noexcept\n-  { return std::compare_three_way()(__a.address(), __b.address()); }\n+  {\n+    return std::compare_three_way()(__a.address(), __b.address());\n+  }\n #else\n   // These are to enable operation with std=c++14,17.\n-  constexpr bool operator!=(coroutine_handle<> __a,\n-\t\t\t    coroutine_handle<> __b) noexcept\n+  constexpr bool\n+  operator!=(coroutine_handle<> __a, coroutine_handle<> __b) noexcept\n   {\n     return !(__a == __b);\n   }\n \n-  constexpr bool operator<(coroutine_handle<> __a,\n-\t\t\t   coroutine_handle<> __b) noexcept\n+  constexpr bool\n+  operator<(coroutine_handle<> __a, coroutine_handle<> __b) noexcept\n   {\n     return less<void*>()(__a.address(), __b.address());\n   }\n \n-  constexpr bool operator>(coroutine_handle<> __a,\n-\t\t\t   coroutine_handle<> __b) noexcept\n+  constexpr bool\n+  operator>(coroutine_handle<> __a, coroutine_handle<> __b) noexcept\n   {\n     return __b < __a;\n   }\n \n-  constexpr bool operator<=(coroutine_handle<> __a,\n-\t\t\t    coroutine_handle<> __b) noexcept\n+  constexpr bool\n+  operator<=(coroutine_handle<> __a, coroutine_handle<> __b) noexcept\n   {\n     return !(__a > __b);\n   }\n \n-  constexpr bool operator>=(coroutine_handle<> __a,\n-\t\t\t    coroutine_handle<> __b) noexcept\n+  constexpr bool\n+  operator>=(coroutine_handle<> __a, coroutine_handle<> __b) noexcept\n   {\n     return !(__a < __b);\n   }\n #endif\n \n   template <typename _Promise>\n-    struct coroutine_handle : coroutine_handle<>\n+    struct coroutine_handle\n     {\n-      // 17.12.3.1, construct/reset\n-      using coroutine_handle<>::coroutine_handle;\n+      // [coroutine.handle.con], construct/reset\n \n-      static coroutine_handle from_promise(_Promise& p)\n+      constexpr coroutine_handle() noexcept { }\n+\n+      constexpr coroutine_handle(nullptr_t) noexcept { }\n+\n+      static coroutine_handle\n+      from_promise(_Promise& __p)\n       {\n \tcoroutine_handle __self;\n \t__self._M_fr_ptr\n-\t  = __builtin_coro_promise((char*) &p, __alignof(_Promise), true);\n+\t  = __builtin_coro_promise((char*) &__p, __alignof(_Promise), true);\n \treturn __self;\n       }\n \n-      coroutine_handle& operator=(std::nullptr_t) noexcept\n+      coroutine_handle& operator=(nullptr_t) noexcept\n       {\n-\tcoroutine_handle<>::operator=(nullptr);\n+\t_M_fr_ptr = nullptr;\n \treturn *this;\n       }\n \n-    // 17.12.3.2, export/import\n-    constexpr static coroutine_handle from_address(void* __a)\n-    {\n-      coroutine_handle __self;\n-      __self._M_fr_ptr = __a;\n-      return __self;\n-    }\n+      // [coroutine.handle.export.import], export/import\n \n-    // 17.12.3.5, promise accesss\n-    _Promise& promise() const\n-    {\n-      void* __t\n-\t= __builtin_coro_promise (this->_M_fr_ptr, __alignof(_Promise), false);\n-      return *static_cast<_Promise*>(__t);\n-    }\n-  };\n+      constexpr void* address() const noexcept { return _M_fr_ptr; }\n+\n+      constexpr static coroutine_handle from_address(void* __a)\n+      {\n+\tcoroutine_handle __self;\n+\t__self._M_fr_ptr = __a;\n+\treturn __self;\n+      }\n+\n+      // [coroutine.handle.conv], conversion\n+      constexpr operator coroutine_handle<>() const noexcept\n+      { return coroutine_handle<>::from_address(address()); }\n+\n+      // [coroutine.handle.observers], observers\n+      constexpr explicit operator bool() const noexcept\n+      {\n+\treturn bool(_M_fr_ptr);\n+      }\n+\n+      bool done() const noexcept { return __builtin_coro_done(_M_fr_ptr); }\n+\n+      // [coroutine.handle.resumption], resumption\n+      void operator()() const { resume(); }\n+\n+      void resume() const { __builtin_coro_resume(_M_fr_ptr); }\n+\n+      void destroy() const { __builtin_coro_destroy(_M_fr_ptr); }\n+\n+      // [coroutine.handle.promise], promise access\n+      _Promise& promise() const\n+      {\n+\tvoid* __t\n+\t  = __builtin_coro_promise (_M_fr_ptr, __alignof(_Promise), false);\n+\treturn *static_cast<_Promise*>(__t);\n+      }\n+\n+    private:\n+      void* _M_fr_ptr = nullptr;\n+    };\n \n   /// [coroutine.noop]\n   struct noop_coroutine_promise\n@@ -231,35 +262,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // 17.12.4.1 Class noop_coroutine_promise\n   /// [coroutine.promise.noop]\n   template <>\n-    struct coroutine_handle<noop_coroutine_promise> : public coroutine_handle<>\n+    struct coroutine_handle<noop_coroutine_promise>\n     {\n-      using _Promise = noop_coroutine_promise;\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 3460. Unimplementable noop_coroutine_handle guarantees\n+      // [coroutine.handle.noop.conv], conversion\n+      constexpr operator coroutine_handle<>() const noexcept\n+      { return coroutine_handle<>::from_address(address()); }\n \n-    public:\n-      // 17.12.4.2.1, observers\n+      // [coroutine.handle.noop.observers], observers\n       constexpr explicit operator bool() const noexcept { return true; }\n \n       constexpr bool done() const noexcept { return false; }\n \n-      // 17.12.4.2.2, resumption\n+      // [coroutine.handle.noop.resumption], resumption\n       void operator()() const noexcept {}\n \n       void resume() const noexcept {}\n \n       void destroy() const noexcept {}\n \n-      // 17.12.4.2.3, promise access\n-      _Promise& promise() const\n-      {\n-\treturn *static_cast<_Promise*>(\n-\t  __builtin_coro_promise(this->_M_fr_ptr, __alignof(_Promise), false));\n-      }\n+      // [coroutine.handle.noop.promise], promise access\n+      noop_coroutine_promise& promise() const noexcept\n+      { return __noop_coro_fr.__p; }\n+\n+      // [coroutine.handle.noop.address], address\n+      constexpr void* address() const noexcept { return _M_fr_ptr; }\n \n-      // 17.12.4.2.4, address\n     private:\n-      friend coroutine_handle<noop_coroutine_promise> noop_coroutine() noexcept;\n+      friend coroutine_handle noop_coroutine() noexcept;\n+\n+      coroutine_handle() = default;\n \n-      coroutine_handle() noexcept { this->_M_fr_ptr = (void*) &__noop_coro_fr; }\n+      void* _M_fr_ptr = (void*) &__noop_coro_fr;\n     };\n \n   using noop_coroutine_handle = coroutine_handle<noop_coroutine_promise>;"}, {"sha": "14a94ded95b487423faf3c688d2d6aaaa52b0640", "filename": "libstdc++-v3/testsuite/18_support/coroutines/lwg3460.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2278f300cdd5f3181fe7df4dd1d869a67266a9/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcoroutines%2Flwg3460.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2278f300cdd5f3181fe7df4dd1d869a67266a9/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcoroutines%2Flwg3460.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcoroutines%2Flwg3460.cc?ref=2c2278f300cdd5f3181fe7df4dd1d869a67266a9", "patch": "@@ -0,0 +1,54 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <coroutine>\n+\n+void\n+test01()\n+{\n+  // LWG 3460. Unimplementable noop_coroutine_handle guarantees\n+\n+  static_assert( std::is_convertible_v<std::noop_coroutine_handle&,\n+\t\t\t\t       std::coroutine_handle<>> );\n+  static_assert( ! std::is_convertible_v<std::noop_coroutine_handle&,\n+\t\t\t\t\t std::coroutine_handle<>&> );\n+  static_assert( ! std::is_assignable_v<std::noop_coroutine_handle&,\n+\t\t\t\t\tstd::coroutine_handle<>> );\n+\n+  std::noop_coroutine_handle h = std::noop_coroutine();\n+  std::coroutine_handle<> h2 = h;\n+  h2();\t\t// no-op\n+  h2.resume();\t// no-op\n+  h2.destroy();\t// no-op\n+}\n+\n+void\n+test02()\n+{\n+  // LWG 3469. Precondition of coroutine_handle::promise may be insufficient\n+\n+  struct P1 { };\n+  struct P2 { };\n+\n+  static_assert( ! std::is_assignable_v<std::coroutine_handle<P1>&,\n+\t\t\t\t\tstd::coroutine_handle<>> );\n+  static_assert( ! std::is_assignable_v<std::coroutine_handle<P1>&,\n+\t\t\t\t\tstd::coroutine_handle<P2>> );\n+}"}]}