{"sha": "104e4daaa53212b718cc916a0a688c06dab6a5fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA0ZTRkYWFhNTMyMTJiNzE4Y2M5MTZhMGE2ODhjMDZkYWI2YTVmYg==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2005-11-15T13:56:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T13:56:14Z"}, "message": "clean.adb (Check_Project): Look for Ada code in extending project, even if Ada is not specified as a language.\n\n2005-11-14  Vincent Celier  <celier@adacore.com>\n\n\t* clean.adb (Check_Project): Look for Ada code in extending project,\n\teven if Ada is not specified as a language.\n\tUse new function DLL_Prefix for DLL_Name\n\t(Clean_Interface_Copy_Directory): New procedure\n\t(Clean_Library_Directory): New procedure\n\t(Clean_Directory): Remove procedure, no longer used\n\t(Clean_Project): Do not delete any file in an externally built project\n\n\t* prj-env.adb (Set_Ada_Paths.Add.Recursive_Add): Add the object\n\tdirectory of an extending project, even when there are no Ada source\n\tpresent.\n\t(Ada_Objects_Path.Add): Add Library_ALI_Dir, not Library_Dir to the path\n\t(Set_Ada_Paths.Add.Recursive_Add): Ditto\n\n\t* mlib-prj.adb (Check_Library): For all library projects, get the\n\tlibrary file timestamp.\n\t(Build_Library): Copy ALI files in Library_ALI_Dir, not in Library_Dir\n\t(Build_Library): Use new function DLL_Prefix for the DLL_Name\n\t(Clean): Remove procedure, no longer used\n\t(Ultimate_Extension_Of): New function\n\t(Build_Library): When cleaning the library directory, only remove an\n\texisting library file and any ALI file of a source of the project.\n\tWhen cleaning the interface copy directory, remove any source that\n\tcould be a source of the project.\n\n\t* prj.ads, prj.adb (Project_Empty): Add values of new components\n\tLibrary_TS and All_Imported_Projects.\n\t(Project_Empty): Add values for new components of Project_Data:\n\tLibrary_ALI_Dir and Display_Library_ALI_Dir\n\n\t* prj-attr.adb: New project level attribute name Library_ALI_Dir\n\n\t* prj-nmsc.adb (Check_Library_Attributes): Take into account new\n\tattribute Library_ALI_Dir.\n\t(Check_Library_Attributes): The library directory cannot be the same as\n\tany source directory of the project tree.\n\t(Check_Stand_Alone_Library): The interface copy directory cannot be\n\tthe same as any source directory of the project tree.\n\n\t* mlib.adb: Use Prj.Com.Fail, instead of Osint.Fail directly, to delete\n\tall temporary files.\n\nFrom-SVN: r106967", "tree": {"sha": "670ec552e0e07e24221f4ff7c9afded0eb8cb6ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/670ec552e0e07e24221f4ff7c9afded0eb8cb6ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/104e4daaa53212b718cc916a0a688c06dab6a5fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/104e4daaa53212b718cc916a0a688c06dab6a5fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/104e4daaa53212b718cc916a0a688c06dab6a5fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/104e4daaa53212b718cc916a0a688c06dab6a5fb/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f9f7e1022c37e88c1fd0d622af84d25c7b0507bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f7e1022c37e88c1fd0d622af84d25c7b0507bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9f7e1022c37e88c1fd0d622af84d25c7b0507bb"}], "stats": {"total": 1579, "additions": 1133, "deletions": 446}, "files": [{"sha": "e5682d08b307fd4606f9de0a4a332b00226cd113", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 473, "deletions": 228, "changes": 701, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=104e4daaa53212b718cc916a0a688c06dab6a5fb", "patch": "@@ -24,8 +24,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Command_Line; use Ada.Command_Line;\n-\n with ALI;      use ALI;\n with Csets;\n with Gnatvsn;\n@@ -45,6 +43,8 @@ with Snames;\n with Table;\n with Types;    use Types;\n \n+with Ada.Command_Line;          use Ada.Command_Line;\n+\n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with GNAT.IO;                   use GNAT.IO;\n with GNAT.OS_Lib;               use GNAT.OS_Lib;\n@@ -191,13 +191,17 @@ package body Clean is\n    --  Delete a global archive or a fake library project archive and the\n    --  dependency file, if they exist.\n \n-   procedure Clean_Directory (Dir : Name_Id);\n-   --  Delete all regular files in a library directory or in a library\n-   --  interface dir.\n-\n    procedure Clean_Executables;\n    --  Do the cleaning work when no project file is specified\n \n+   procedure Clean_Interface_Copy_Directory (Project : Project_Id);\n+   --  Delete files in an interface coy directory directory: any file that is\n+   --  a copy of a source of the project.\n+\n+   procedure Clean_Library_Directory (Project : Project_Id);\n+   --  Delete the library file in a library directory and any ALI file\n+   --  of a source of the project in a library ALI directory.\n+\n    procedure Clean_Project (Project : Project_Id);\n    --  Do the cleaning work when a project file is specified.\n    --  This procedure calls itself recursively when there are several\n@@ -241,6 +245,11 @@ package body Clean is\n    --  Returns True iff Prj is an extension of Of_Project or if Of_Project is\n    --  an extension of Prj.\n \n+   function Ultimate_Extension_Of (Project : Project_Id) return Project_Id;\n+   --  Returns either Project, if it is not extended by another project, or\n+   --  the project that extends Project, directly or indirectly, and that is\n+   --  not itself extended. Returns No_Project if Project is No_Project.\n+\n    procedure Usage;\n    --  Display the usage.\n    --  If called several times, the usage is displayed only the first time.\n@@ -356,46 +365,6 @@ package body Clean is\n       Change_Dir (Current_Dir);\n    end Clean_Archive;\n \n-   ---------------------\n-   -- Clean_Directory --\n-   ---------------------\n-\n-   procedure Clean_Directory (Dir : Name_Id) is\n-      Directory : constant String := Get_Name_String (Dir);\n-      Current   : constant Dir_Name_Str := Get_Current_Dir;\n-\n-      Direc : Dir_Type;\n-\n-      Name : String (1 .. 200);\n-      Last : Natural;\n-\n-   begin\n-      Change_Dir (Directory);\n-      Open (Direc, \".\");\n-\n-      --  For each regular file in the directory, if switch -n has not been\n-      --  specified, make it writable and delete the file.\n-\n-      loop\n-         Read (Direc, Name, Last);\n-         exit when Last = 0;\n-\n-         if Is_Regular_File (Name (1 .. Last)) then\n-            if not Do_Nothing then\n-               Set_Writable (Name (1 .. Last));\n-            end if;\n-\n-            Delete (Directory, Name (1 .. Last));\n-         end if;\n-      end loop;\n-\n-      Close (Direc);\n-\n-      --  Restore the initial working directory\n-\n-      Change_Dir (Current);\n-   end Clean_Directory;\n-\n    -----------------------\n    -- Clean_Executables --\n    -----------------------\n@@ -550,6 +519,242 @@ package body Clean is\n       end loop;\n    end Clean_Executables;\n \n+   ------------------------------------\n+   -- Clean_Interface_Copy_Directory --\n+   ------------------------------------\n+\n+   procedure Clean_Interface_Copy_Directory (Project : Project_Id) is\n+      Current : constant String := Get_Current_Dir;\n+      Data    : constant Project_Data := Project_Tree.Projects.Table (Project);\n+\n+      Direc : Dir_Type;\n+\n+      Name : String (1 .. 200);\n+      Last : Natural;\n+\n+      Delete_File : Boolean;\n+      Unit        : Unit_Data;\n+\n+   begin\n+      if Data.Library and then Data.Library_Src_Dir /= No_Name then\n+         declare\n+            Directory : constant String :=\n+                          Get_Name_String (Data.Library_Src_Dir);\n+\n+         begin\n+            Change_Dir (Get_Name_String (Data.Library_Src_Dir));\n+            Open (Direc, \".\");\n+\n+            --  For each regular file in the directory, if switch -n has not\n+            --  been specified, make it writable and delete the file if it is\n+            --  a copy of a source of the project.\n+\n+            loop\n+               Read (Direc, Name, Last);\n+               exit when Last = 0;\n+\n+               if Is_Regular_File (Name (1 .. Last)) then\n+                  Canonical_Case_File_Name (Name (1 .. Last));\n+                  Delete_File := False;\n+\n+                  --  Compare with source file names of the project\n+\n+                  for Index in 1 .. Unit_Table.Last (Project_Tree.Units) loop\n+                     Unit := Project_Tree.Units.Table (Index);\n+\n+                     if Ultimate_Extension_Of\n+                       (Unit.File_Names (Body_Part).Project) = Project\n+                       and then\n+                         Get_Name_String\n+                           (Unit.File_Names (Body_Part).Name) =\n+                       Name (1 .. Last)\n+                     then\n+                        Delete_File := True;\n+                        exit;\n+                     end if;\n+\n+                     if Ultimate_Extension_Of\n+                       (Unit.File_Names (Specification).Project) = Project\n+                       and then\n+                         Get_Name_String\n+                           (Unit.File_Names (Specification).Name) =\n+                       Name (1 .. Last)\n+                     then\n+                        Delete_File := True;\n+                        exit;\n+                     end if;\n+                  end loop;\n+\n+                  if Delete_File then\n+                     if not Do_Nothing then\n+                        Set_Writable (Name (1 .. Last));\n+                     end if;\n+\n+                     Delete (Directory, Name (1 .. Last));\n+                  end if;\n+               end if;\n+            end loop;\n+\n+            Close (Direc);\n+\n+            --  Restore the initial working directory\n+\n+            Change_Dir (Current);\n+         end;\n+      end if;\n+   end Clean_Interface_Copy_Directory;\n+\n+   -----------------------------\n+   -- Clean_Library_Directory --\n+   -----------------------------\n+\n+   procedure Clean_Library_Directory (Project : Project_Id) is\n+      Current : constant String := Get_Current_Dir;\n+      Data    : constant Project_Data := Project_Tree.Projects.Table (Project);\n+\n+      Lib_Filename : constant String := Get_Name_String (Data.Library_Name);\n+      DLL_Name     : constant String :=\n+                       DLL_Prefix & Lib_Filename & \".\" & DLL_Ext;\n+      Archive_Name : constant String :=\n+                       \"lib\" & Lib_Filename & \".\" & Archive_Ext;\n+      Direc        : Dir_Type;\n+\n+      Name : String (1 .. 200);\n+      Last : Natural;\n+\n+      Delete_File : Boolean;\n+\n+   begin\n+      if Data.Library then\n+         declare\n+            Lib_Directory     : constant String :=\n+                                  Get_Name_String (Data.Library_Dir);\n+            Lib_ALI_Directory : constant String :=\n+                                  Get_Name_String (Data.Library_ALI_Dir);\n+\n+         begin\n+            Change_Dir (Lib_Directory);\n+            Open (Direc, \".\");\n+\n+            --  For each regular file in the directory, if switch -n has not\n+            --  been specified, make it writable and delete the file if it is\n+            --  the library file.\n+\n+            loop\n+               Read (Direc, Name, Last);\n+               exit when Last = 0;\n+\n+               if Is_Regular_File (Name (1 .. Last)) then\n+                  Canonical_Case_File_Name (Name (1 .. Last));\n+                  Delete_File := False;\n+\n+                  if (Data.Library_Kind = Static and then\n+                        Name (1 .. Last) =  Archive_Name)\n+                    or else\n+                      ((Data.Library_Kind = Dynamic or else\n+                          Data.Library_Kind = Relocatable)\n+                       and then\n+                         Name (1 .. Last) = DLL_Name)\n+                  then\n+                     if not Do_Nothing then\n+                        Set_Writable (Name (1 .. Last));\n+                     end if;\n+\n+                     Delete (Lib_Directory, Name (1 .. Last));\n+                     exit;\n+                  end if;\n+               end if;\n+            end loop;\n+\n+            Close (Direc);\n+\n+            Change_Dir (Lib_ALI_Directory);\n+            Open (Direc, \".\");\n+\n+            --  For each regular file in the directory, if switch -n has not\n+            --  been specified, make it writable and delete the file if it is\n+            --  any ALI file of a source of the project.\n+\n+            loop\n+               Read (Direc, Name, Last);\n+               exit when Last = 0;\n+\n+               if Is_Regular_File (Name (1 .. Last)) then\n+                  Canonical_Case_File_Name (Name (1 .. Last));\n+                  Delete_File := False;\n+\n+                  if Last > 4 and then Name (Last - 3 .. Last) = \".ali\" then\n+                     declare\n+                        Unit : Unit_Data;\n+                     begin\n+                        --  Compare with ALI file names of the project\n+\n+                        for\n+                          Index in 1 .. Unit_Table.Last (Project_Tree.Units)\n+                        loop\n+                           Unit := Project_Tree.Units.Table (Index);\n+\n+                           if Unit.File_Names (Body_Part).Project /=\n+                             No_Project\n+                           then\n+                              if  Ultimate_Extension_Of\n+                                (Unit.File_Names (Body_Part).Project) =\n+                                 Project\n+                              then\n+                                 Get_Name_String\n+                                   (Unit.File_Names (Body_Part).Name);\n+                                 Name_Len := Name_Len -\n+                                   File_Extension\n+                                     (Name (1 .. Name_Len))'Length;\n+                                 if Name_Buffer (1 .. Name_Len) =\n+                                     Name (1 .. Last - 4)\n+                                 then\n+                                    Delete_File := True;\n+                                    exit;\n+                                 end if;\n+                              end if;\n+\n+                           elsif Ultimate_Extension_Of\n+                                   (Unit.File_Names (Specification).Project) =\n+                                                                        Project\n+                           then\n+                              Get_Name_String\n+                                (Unit.File_Names (Specification).Name);\n+                              Name_Len := Name_Len -\n+                                            File_Extension\n+                                              (Name (1 .. Name_Len))'Length;\n+\n+                              if Name_Buffer (1 .. Name_Len) =\n+                                   Name (1 .. Last - 4)\n+                              then\n+                                 Delete_File := True;\n+                                 exit;\n+                              end if;\n+                           end if;\n+                        end loop;\n+                     end;\n+                  end if;\n+\n+                  if Delete_File then\n+                     if not Do_Nothing then\n+                        Set_Writable (Name (1 .. Last));\n+                     end if;\n+\n+                     Delete (Lib_ALI_Directory, Name (1 .. Last));\n+                  end if;\n+\n+               end if;\n+            end loop;\n+\n+            Close (Direc);\n+\n+            --  Restore the initial working directory\n+\n+            Change_Dir (Current);\n+         end;\n+      end if;\n+   end Clean_Library_Directory;\n+\n    -------------------\n    -- Clean_Project --\n    -------------------\n@@ -588,251 +793,271 @@ package body Clean is\n            (\"Cannot specify executable(s) for a Library Project File\");\n       end if;\n \n-      if Verbose_Mode then\n-         Put (\"Cleaning project \"\"\");\n-         Put (Get_Name_String (Data.Name));\n-         Put_Line (\"\"\"\");\n-      end if;\n+      --  Nothing to clean in an externally built project\n \n-      --  Add project to the list of processed projects\n+      if Data.Externally_Built then\n+         if Verbose_Mode then\n+            Put (\"Nothing to do to clean externally built project \"\"\");\n+            Put (Get_Name_String (Data.Name));\n+            Put_Line (\"\"\"\");\n+         end if;\n \n-      Processed_Projects.Increment_Last;\n-      Processed_Projects.Table (Processed_Projects.Last) := Project;\n+      else\n+         if Verbose_Mode then\n+            Put (\"Cleaning project \"\"\");\n+            Put (Get_Name_String (Data.Name));\n+            Put_Line (\"\"\"\");\n+         end if;\n \n-      if Data.Object_Directory /= No_Name then\n-         declare\n-            Obj_Dir : constant String :=\n-                        Get_Name_String (Data.Object_Directory);\n+         --  Add project to the list of processed projects\n \n-         begin\n-            Change_Dir (Obj_Dir);\n+         Processed_Projects.Increment_Last;\n+         Processed_Projects.Table (Processed_Projects.Last) := Project;\n \n-            --  First, deal with Ada\n+         if Data.Object_Directory /= No_Name then\n+            declare\n+               Obj_Dir : constant String :=\n+                           Get_Name_String (Data.Object_Directory);\n \n-            --  Look through the units to find those that are either immediate\n-            --  sources or inherited sources of the project.\n+            begin\n+               Change_Dir (Obj_Dir);\n \n-            if Data.Languages (Ada_Language_Index) then\n-               for Unit in Unit_Table.First ..\n-                           Unit_Table.Last (Project_Tree.Units)\n-               loop\n-                  U_Data := Project_Tree.Units.Table (Unit);\n-                  File_Name1 := No_Name;\n-                  File_Name2 := No_Name;\n+               --  First, deal with Ada\n \n-                  --  If either the spec or the body is a source of the\n-                  --  project, check for the corresponding ALI file in the\n-                  --  object directory.\n+               --  Look through the units to find those that are either\n+               --  immediate sources or inherited sources of the project.\n+               --  Extending projects may have no language specified, if\n+               --  Source_Dirs or Source_Files is specified as an empty list,\n+               --  so always look for Ada units in extending projects.\n \n-                  if In_Extension_Chain\n-                    (U_Data.File_Names (Body_Part).Project, Project)\n-                    or else\n-                      In_Extension_Chain\n-                        (U_Data.File_Names (Specification).Project, Project)\n-                  then\n-                     File_Name1 := U_Data.File_Names (Body_Part).Name;\n-                     Index1     := U_Data.File_Names (Body_Part).Index;\n-                     File_Name2 := U_Data.File_Names (Specification).Name;\n-                     Index2     := U_Data.File_Names (Specification).Index;\n-\n-                     --  If there is no body file name, then there may be only\n-                     --  a spec.\n-\n-                     if File_Name1 = No_Name then\n-                        File_Name1 := File_Name2;\n-                        Index1     := Index2;\n-                        File_Name2 := No_Name;\n-                        Index2     := 0;\n+               if Data.Languages (Ada_Language_Index)\n+                 or else Data.Extends /= No_Project\n+               then\n+                  for Unit in Unit_Table.First ..\n+                    Unit_Table.Last (Project_Tree.Units)\n+                  loop\n+                     U_Data := Project_Tree.Units.Table (Unit);\n+                     File_Name1 := No_Name;\n+                     File_Name2 := No_Name;\n+\n+                     --  If either the spec or the body is a source of the\n+                     --  project, check for the corresponding ALI file in the\n+                     --  object directory.\n+\n+                     if In_Extension_Chain\n+                       (U_Data.File_Names (Body_Part).Project, Project)\n+                       or else\n+                         In_Extension_Chain\n+                           (U_Data.File_Names (Specification).Project, Project)\n+                     then\n+                        File_Name1 := U_Data.File_Names (Body_Part).Name;\n+                        Index1     := U_Data.File_Names (Body_Part).Index;\n+                        File_Name2 := U_Data.File_Names (Specification).Name;\n+                        Index2     := U_Data.File_Names (Specification).Index;\n+\n+                        --  If there is no body file name, then there may be\n+                        --  only a spec.\n+\n+                        if File_Name1 = No_Name then\n+                           File_Name1 := File_Name2;\n+                           Index1     := Index2;\n+                           File_Name2 := No_Name;\n+                           Index2     := 0;\n+                        end if;\n                      end if;\n-                  end if;\n \n-                  --  If there is either a spec or a body, look for files\n-                  --  in the object directory.\n+                     --  If there is either a spec or a body, look for files\n+                     --  in the object directory.\n \n-                  if File_Name1 /= No_Name then\n-                     Lib_File := Osint.Lib_File_Name (File_Name1, Index1);\n+                     if File_Name1 /= No_Name then\n+                        Lib_File := Osint.Lib_File_Name (File_Name1, Index1);\n \n-                     declare\n-                        Asm : constant String := Assembly_File_Name (Lib_File);\n-                        ALI : constant String := ALI_File_Name      (Lib_File);\n-                        Obj : constant String := Object_File_Name   (Lib_File);\n-                        Adt : constant String := Tree_File_Name     (Lib_File);\n-                        Deb : constant String :=\n-                                Debug_File_Name (File_Name1);\n-                        Rep : constant String :=\n-                                Repinfo_File_Name (File_Name1);\n-                        Del : Boolean := True;\n+                        declare\n+                           Asm : constant String :=\n+                                   Assembly_File_Name (Lib_File);\n+                           ALI : constant String :=\n+                                   ALI_File_Name      (Lib_File);\n+                           Obj : constant String :=\n+                                   Object_File_Name   (Lib_File);\n+                           Adt : constant String :=\n+                                   Tree_File_Name     (Lib_File);\n+                           Deb : constant String :=\n+                                   Debug_File_Name (File_Name1);\n+                           Rep : constant String :=\n+                                   Repinfo_File_Name (File_Name1);\n+                           Del : Boolean := True;\n \n-                     begin\n-                        --  If the ALI file exists and is read-only, no file\n-                        --  is deleted.\n+                        begin\n+                           --  If the ALI file exists and is read-only, no file\n+                           --  is deleted.\n \n-                        if Is_Regular_File (ALI) then\n-                           if Is_Writable_File (ALI) then\n-                              Delete (Obj_Dir, ALI);\n+                           if Is_Regular_File (ALI) then\n+                              if Is_Writable_File (ALI) then\n+                                 Delete (Obj_Dir, ALI);\n \n-                           else\n-                              Del := False;\n+                              else\n+                                 Del := False;\n \n-                              if Verbose_Mode then\n-                                 Put ('\"');\n-                                 Put (Obj_Dir);\n+                                 if Verbose_Mode then\n+                                    Put ('\"');\n+                                    Put (Obj_Dir);\n \n-                                 if Obj_Dir (Obj_Dir'Last) /=\n+                                    if Obj_Dir (Obj_Dir'Last) /=\n                                       Dir_Separator\n-                                 then\n-                                    Put (Dir_Separator);\n-                                 end if;\n+                                    then\n+                                       Put (Dir_Separator);\n+                                    end if;\n \n-                                 Put (ALI);\n-                                 Put_Line (\"\"\" is read-only\");\n+                                    Put (ALI);\n+                                    Put_Line (\"\"\" is read-only\");\n+                                 end if;\n                               end if;\n                            end if;\n-                        end if;\n \n-                        if Del then\n+                           if Del then\n \n-                           --  Object file\n+                              --  Object file\n \n-                           if Is_Regular_File (Obj) then\n-                              Delete (Obj_Dir, Obj);\n-                           end if;\n+                              if Is_Regular_File (Obj) then\n+                                 Delete (Obj_Dir, Obj);\n+                              end if;\n \n-                           --  Assembly file\n+                              --  Assembly file\n \n-                           if Is_Regular_File (Asm) then\n-                              Delete (Obj_Dir, Asm);\n-                           end if;\n+                              if Is_Regular_File (Asm) then\n+                                 Delete (Obj_Dir, Asm);\n+                              end if;\n \n-                           --  Tree file\n+                              --  Tree file\n \n-                           if Is_Regular_File (Adt) then\n-                              Delete (Obj_Dir, Adt);\n-                           end if;\n+                              if Is_Regular_File (Adt) then\n+                                 Delete (Obj_Dir, Adt);\n+                              end if;\n \n-                           --  First expanded source file\n+                              --  First expanded source file\n \n-                           if Is_Regular_File (Deb) then\n-                              Delete (Obj_Dir, Deb);\n-                           end if;\n+                              if Is_Regular_File (Deb) then\n+                                 Delete (Obj_Dir, Deb);\n+                              end if;\n \n-                           --  Repinfo file\n+                              --  Repinfo file\n \n-                           if Is_Regular_File (Rep) then\n-                              Delete (Obj_Dir, Rep);\n-                           end if;\n+                              if Is_Regular_File (Rep) then\n+                                 Delete (Obj_Dir, Rep);\n+                              end if;\n \n-                           --  Second expanded source file\n-\n-                           if File_Name2 /= No_Name then\n-                              declare\n-                                 Deb : constant String :=\n-                                         Debug_File_Name   (File_Name2);\n-                                 Rep : constant String :=\n-                                         Repinfo_File_Name (File_Name2);\n-                              begin\n-                                 if Is_Regular_File (Deb) then\n-                                    Delete (Obj_Dir, Deb);\n-                                 end if;\n+                              --  Second expanded source file\n \n-                                 if Is_Regular_File (Rep) then\n-                                    Delete (Obj_Dir, Rep);\n-                                 end if;\n-                              end;\n+                              if File_Name2 /= No_Name then\n+                                 declare\n+                                    Deb : constant String :=\n+                                            Debug_File_Name (File_Name2);\n+                                    Rep : constant String :=\n+                                            Repinfo_File_Name (File_Name2);\n+\n+                                 begin\n+                                    if Is_Regular_File (Deb) then\n+                                       Delete (Obj_Dir, Deb);\n+                                    end if;\n+\n+                                    if Is_Regular_File (Rep) then\n+                                       Delete (Obj_Dir, Rep);\n+                                    end if;\n+                                 end;\n+                              end if;\n                            end if;\n-                        end if;\n-                     end;\n-                  end if;\n-               end loop;\n-            end if;\n+                        end;\n+                     end if;\n+                  end loop;\n+               end if;\n \n-            --  Check if a global archive and it dependency file could have\n-            --  been created and, if they exist, delete them.\n+               --  Check if a global archive and it dependency file could have\n+               --  been created and, if they exist, delete them.\n \n-            if Project = Main_Project and then not Data.Library then\n-               Global_Archive := False;\n+               if Project = Main_Project and then not Data.Library then\n+                  Global_Archive := False;\n \n-               for Proj in Project_Table.First ..\n-                           Project_Table.Last (Project_Tree.Projects)\n-               loop\n-                  if Project_Tree.Projects.Table\n+                  for Proj in Project_Table.First ..\n+                    Project_Table.Last (Project_Tree.Projects)\n+                  loop\n+                     if Project_Tree.Projects.Table\n                        (Proj).Other_Sources_Present\n-                  then\n-                     Global_Archive := True;\n-                     exit;\n-                  end if;\n-               end loop;\n+                     then\n+                        Global_Archive := True;\n+                        exit;\n+                     end if;\n+                  end loop;\n \n-               if Global_Archive then\n-                  Clean_Archive (Project);\n+                  if Global_Archive then\n+                     Clean_Archive (Project);\n+                  end if;\n                end if;\n-            end if;\n-\n-            if Data.Other_Sources_Present then\n \n-               --  There is non-Ada code: delete the object files and\n-               --  the dependency files if they exist.\n+               if Data.Other_Sources_Present then\n \n-               Source_Id := Data.First_Other_Source;\n+                  --  There is non-Ada code: delete the object files and\n+                  --  the dependency files if they exist.\n \n-               while Source_Id /= No_Other_Source loop\n-                  Source :=\n-                    Project_Tree.Other_Sources.Table (Source_Id);\n+                  Source_Id := Data.First_Other_Source;\n+                  while Source_Id /= No_Other_Source loop\n+                     Source :=\n+                       Project_Tree.Other_Sources.Table (Source_Id);\n \n-                  if Is_Regular_File\n+                     if Is_Regular_File\n                        (Get_Name_String (Source.Object_Name))\n-                  then\n-                     Delete (Obj_Dir, Get_Name_String (Source.Object_Name));\n-                  end if;\n+                     then\n+                        Delete (Obj_Dir, Get_Name_String (Source.Object_Name));\n+                     end if;\n \n-                  if Is_Regular_File (Get_Name_String (Source.Dep_Name)) then\n-                     Delete (Obj_Dir, Get_Name_String (Source.Dep_Name));\n-                  end if;\n+                     if\n+                       Is_Regular_File (Get_Name_String (Source.Dep_Name))\n+                     then\n+                        Delete (Obj_Dir, Get_Name_String (Source.Dep_Name));\n+                     end if;\n \n-                  Source_Id := Source.Next;\n-               end loop;\n+                     Source_Id := Source.Next;\n+                  end loop;\n \n-               --  If it is a library with only non Ada sources, delete\n-               --  the fake archive and the dependency file, if they exist.\n+                  --  If it is a library with only non Ada sources, delete\n+                  --  the fake archive and the dependency file, if they exist.\n \n-               if Data.Library\n-                 and then not Data.Languages (Ada_Language_Index)\n-               then\n-                  Clean_Archive (Project);\n+                  if Data.Library\n+                    and then not Data.Languages (Ada_Language_Index)\n+                  then\n+                     Clean_Archive (Project);\n+                  end if;\n                end if;\n-            end if;\n-         end;\n-      end if;\n+            end;\n+         end if;\n \n-      --  If this is a library project, clean the library directory, the\n-      --  interface copy dir and, for a Stand-Alone Library, the binder\n-      --  generated files of the library.\n+         --  If this is a library project, clean the library directory, the\n+         --  interface copy dir and, for a Stand-Alone Library, the binder\n+         --  generated files of the library.\n \n-      --  The directories are cleaned only if switch -c is not specified\n+         --  The directories are cleaned only if switch -c is not specified\n \n-      if Data.Library then\n-         if not Compile_Only then\n-            Clean_Directory (Data.Library_Dir);\n+         if Data.Library then\n+            if not Compile_Only then\n+               Clean_Library_Directory (Project);\n+\n+               if Data.Library_Src_Dir /= No_Name then\n+                  Clean_Interface_Copy_Directory (Project);\n+               end if;\n+            end if;\n \n-            if Data.Library_Src_Dir /= No_Name\n-              and then Data.Library_Src_Dir /= Data.Library_Dir\n+            if Data.Standalone_Library and then\n+              Data.Object_Directory /= No_Name\n             then\n-               Clean_Directory (Data.Library_Src_Dir);\n+               Delete_Binder_Generated_Files\n+                 (Get_Name_String (Data.Object_Directory), Data.Library_Name);\n             end if;\n          end if;\n \n-         if Data.Standalone_Library and then\n-            Data.Object_Directory /= No_Name\n-         then\n-            Delete_Binder_Generated_Files\n-              (Get_Name_String (Data.Object_Directory), Data.Library_Name);\n+         if Verbose_Mode then\n+            New_Line;\n          end if;\n       end if;\n \n-      if Verbose_Mode then\n-         New_Line;\n-      end if;\n-\n       --  If switch -r is specified, call Clean_Project recursively for the\n       --  imported projects and the project being extended.\n \n@@ -1610,6 +1835,26 @@ package body Clean is\n       return Src & Tree_Suffix;\n    end Tree_File_Name;\n \n+   ---------------------------\n+   -- Ultimate_Extension_Of --\n+   ---------------------------\n+\n+   function Ultimate_Extension_Of (Project : Project_Id) return Project_Id is\n+      Result : Project_Id := Project;\n+      Data   : Project_Data;\n+\n+   begin\n+      if Project /= No_Project then\n+         loop\n+            Data := Project_Tree.Projects.Table (Result);\n+            exit when Data.Extended_By = No_Project;\n+            Result := Data.Extended_By;\n+         end loop;\n+      end if;\n+\n+      return Result;\n+   end Ultimate_Extension_Of;\n+\n    -----------\n    -- Usage --\n    -----------"}, {"sha": "8169f6b0752f9e9162c2986626400730e126f6f6", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 282, "deletions": 136, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=104e4daaa53212b718cc916a0a688c06dab6a5fb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---              Copyright (C) 2001-2005, Ada Core Technologies, Inc.        --\n+--                     Copyright (C) 2001-2005, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -139,7 +139,7 @@ package body MLib.Prj is\n       Table_Initial        => 50,\n       Table_Increment      => 100);\n \n-   --  List of options set in the command line.\n+   --  List of options set in the command line\n \n    Options : Argument_List_Access;\n \n@@ -182,7 +182,7 @@ package body MLib.Prj is\n       Hash       => Hash,\n       Equal      => \"=\");\n \n-   --  The projects imported directly or indirectly.\n+   --  The projects imported directly or indirectly\n \n    package Processed_Projects is new GNAT.HTable.Simple_HTable\n      (Header_Num => Header_Num,\n@@ -192,7 +192,7 @@ package body MLib.Prj is\n       Hash       => Hash,\n       Equal      => \"=\");\n \n-   --  The library projects imported directly or indirectly.\n+   --  The library projects imported directly or indirectly\n \n    package Library_Projs is new Table.Table (\n      Table_Component_Type => Project_Id,\n@@ -205,22 +205,18 @@ package body MLib.Prj is\n    type Build_Mode_State is (None, Static, Dynamic, Relocatable);\n \n    procedure Add_Argument (S : String);\n-   --  Add one argument to the array Arguments.\n-   --  If Arguments is full, double its size.\n+   --  Add one argument to Arguments array, if array is full, double its size\n \n    function ALI_File_Name (Source : String) return String;\n-   --  Return the ALI file name corresponding to a source.\n+   --  Return the ALI file name corresponding to a source\n \n    procedure Check (Filename : String);\n-   --  Check if filename is a regular file. Fail if it is not.\n+   --  Check if filename is a regular file. Fail if it is not\n \n    procedure Check_Context;\n    --  Check each object files in table Object_Files\n    --  Fail if any of them is not a regular file\n \n-   procedure Clean (Directory : Name_Id);\n-   --  Attempt to delete all files in Directory, but not subdirectories\n-\n    procedure Copy_Interface_Sources\n      (For_Project : Project_Id;\n       In_Tree     : Project_Tree_Ref;\n@@ -244,6 +240,12 @@ package body MLib.Prj is\n    --  Indicate if Stand-Alone Libraries are automatically initialized using\n    --  the constructor mechanism.\n \n+   function Ultimate_Extension_Of\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return Project_Id;\n+   --  Returns the Project_Id of project Project. Returns No_Project\n+   --  if Project is No_Project.\n+\n    ------------------\n    -- Add_Argument --\n    ------------------\n@@ -360,9 +362,6 @@ package body MLib.Prj is\n       --  If null, Path Option is not supported.\n       --  Not a constant so that it can be deallocated.\n \n-      Copy_Dir : Name_Id;\n-      --  Directory where to copy ALI files and possibly interface sources\n-\n       First_ALI : Name_Id := No_Name;\n       --  Store the ALI file name of a source of the library (the first found)\n \n@@ -1395,7 +1394,7 @@ package body MLib.Prj is\n \n          declare\n             DLL_Name : aliased String :=\n-                         Lib_Dirpath.all & \"/lib\" &\n+                         Lib_Dirpath.all & '/' & DLL_Prefix &\n                            Lib_Filename.all & \".\" & DLL_Ext;\n \n             Archive_Name : aliased String :=\n@@ -1477,14 +1476,120 @@ package body MLib.Prj is\n             end;\n          end if;\n \n-         --  Clean the library directory, if it is also the directory where\n-         --  the ALI files are copied, either because there is no interface\n-         --  copy directory or because the interface copy directory is the\n-         --  same as the library directory.\n+         declare\n+            Current_Dir  : constant String := Get_Current_Dir;\n+            Dir          : Dir_Type;\n+\n+            Name : String (1 .. 200);\n+            Last : Natural;\n+\n+            Disregard : Boolean;\n+\n+            DLL_Name : aliased constant String :=\n+                         Lib_Filename.all & \".\" & DLL_Ext;\n+\n+            Archive_Name : aliased constant String :=\n+                             Lib_Filename.all & \".\" & Archive_Ext;\n+\n+            Delete : Boolean := False;\n+\n+         begin\n+            --  Clean the library directory: remove any file with the name of\n+            --  the library file and any ALI file of a source of the project.\n+\n+            begin\n+               Get_Name_String\n+                 (In_Tree.Projects.Table (For_Project).Library_Dir);\n+               Change_Dir (Name_Buffer (1 .. Name_Len));\n+\n+            exception\n+               when others =>\n+                  Com.Fail\n+                    (\"unable to access library directory \"\"\",\n+                     Name_Buffer (1 .. Name_Len),\n+                     \"\"\"\");\n+            end;\n+\n+            Open (Dir, \".\");\n+\n+            loop\n+               Read (Dir, Name, Last);\n+               exit when Last = 0;\n+\n+               if Is_Regular_File (Name (1 .. Last)) then\n+                  Canonical_Case_File_Name (Name (1 .. Last));\n+                  Delete := False;\n+\n+                  if (The_Build_Mode = Static and then\n+                        Name (1 .. Last) =  Archive_Name)\n+                    or else\n+                      ((The_Build_Mode = Dynamic or else\n+                          The_Build_Mode = Relocatable)\n+                       and then\n+                         Name (1 .. Last) = DLL_Name)\n+                  then\n+                     Delete := True;\n+\n+                  elsif Last > 4 and then Name (Last - 3 .. Last) = \".ali\" then\n+                     declare\n+                        Unit : Unit_Data;\n+                     begin\n+                        --  Compare with ALI file names of the project\n+\n+                        for Index in 1 .. Unit_Table.Last (In_Tree.Units) loop\n+                           Unit := In_Tree.Units.Table (Index);\n+\n+                           if Unit.File_Names (Body_Part).Project /=\n+                             No_Project\n+                           then\n+                              if  Ultimate_Extension_Of\n+                                (Unit.File_Names (Body_Part).Project, In_Tree)\n+                                 = For_Project\n+                              then\n+                                 Get_Name_String\n+                                   (Unit.File_Names (Body_Part).Name);\n+                                 Name_Len := Name_Len -\n+                                   File_Extension\n+                                     (Name (1 .. Name_Len))'Length;\n+                                 if Name_Buffer (1 .. Name_Len) =\n+                                     Name (1 .. Last - 4)\n+                                 then\n+                                    Delete := True;\n+                                    exit;\n+                                 end if;\n+                              end if;\n+\n+                           elsif Ultimate_Extension_Of\n+                             (Unit.File_Names (Specification).Project, In_Tree)\n+                             = For_Project\n+                           then\n+                              Get_Name_String\n+                                (Unit.File_Names (Specification).Name);\n+                              Name_Len := Name_Len -\n+                                File_Extension (Name (1 .. Name_Len))'Length;\n+\n+                              if Name_Buffer (1 .. Name_Len) =\n+                                   Name (1 .. Last - 4)\n+                              then\n+                                 Delete := True;\n+                                 exit;\n+                              end if;\n+                           end if;\n+                        end loop;\n+                     end;\n+                  end if;\n+\n+                  if Delete then\n+                     Set_Writable (Name (1 .. Last));\n+                     Delete_File (Name (1 .. Last), Disregard);\n+                  end if;\n+               end if;\n+            end loop;\n \n-         Copy_Dir :=\n-           In_Tree.Projects.Table (For_Project).Library_Dir;\n-         Clean (Copy_Dir);\n+            Close (Dir);\n+\n+            Change_Dir (Current_Dir);\n+         end;\n \n          --  Call procedure to build the library, depending on the build mode\n \n@@ -1516,7 +1621,7 @@ package body MLib.Prj is\n          end case;\n \n          --  We need to copy the ALI files from the object directory to\n-         --  the library directory, so that the linker find them there,\n+         --  the library ALI directory, so that the linker find them there,\n          --  and does not need to look in the object directory where it\n          --  would also find the object files; and we don't want that:\n          --  we want the linker to use the library.\n@@ -1526,7 +1631,7 @@ package body MLib.Prj is\n \n          Copy_ALI_Files\n            (Files      => Ali_Files.all,\n-            To         => Copy_Dir,\n+            To         => In_Tree.Projects.Table (For_Project).Library_ALI_Dir,\n             Interfaces => Arguments (1 .. Argument_Number));\n \n          --  Copy interface sources if Library_Src_Dir specified\n@@ -1535,23 +1640,89 @@ package body MLib.Prj is\n            and then In_Tree.Projects.Table\n                       (For_Project).Library_Src_Dir /= No_Name\n          then\n-            --  Clean the interface copy directory, if it is not also the\n-            --  library directory. If it is also the library directory, it\n-            --  has already been cleaned before generation of the library.\n+            --  Clean the interface copy directory: remove any source that\n+            --  could be a source of the project.\n \n-            if In_Tree.Projects.Table\n-              (For_Project).Library_Src_Dir /= Copy_Dir\n-            then\n-               Copy_Dir := In_Tree.Projects.Table\n-                             (For_Project).Library_Src_Dir;\n-               Clean (Copy_Dir);\n-            end if;\n+            begin\n+               Get_Name_String\n+                 (In_Tree.Projects.Table (For_Project).Library_Src_Dir);\n+               Change_Dir (Name_Buffer (1 .. Name_Len));\n+\n+            exception\n+               when others =>\n+                  Com.Fail\n+                    (\"unable to access library source copy directory \"\"\",\n+                     Name_Buffer (1 .. Name_Len),\n+                     \"\"\"\");\n+            end;\n+\n+            declare\n+               Dir    : Dir_Type;\n+               Delete : Boolean;\n+               Unit   : Unit_Data;\n+\n+               Name : String (1 .. 200);\n+               Last : Natural;\n+\n+               Disregard : Boolean;\n+\n+            begin\n+               Open (Dir, \".\");\n+\n+               loop\n+                  Read (Dir, Name, Last);\n+                  exit when Last = 0;\n+\n+                  if Is_Regular_File (Name (1 .. Last)) then\n+                     Canonical_Case_File_Name (Name (1 .. Last));\n+                     Delete := False;\n+\n+                     --  Compare with source file names of the project\n+\n+                     for Index in 1 .. Unit_Table.Last (In_Tree.Units) loop\n+                        Unit := In_Tree.Units.Table (Index);\n+\n+                        if Ultimate_Extension_Of\n+                            (Unit.File_Names (Body_Part).Project, In_Tree) =\n+                            For_Project\n+                          and then\n+                            Get_Name_String\n+                              (Unit.File_Names (Body_Part).Name) =\n+                            Name (1 .. Last)\n+                        then\n+                           Delete := True;\n+                           exit;\n+                        end if;\n+\n+                        if Ultimate_Extension_Of\n+                           (Unit.File_Names (Specification).Project, In_Tree) =\n+                           For_Project\n+                          and then\n+                           Get_Name_String\n+                             (Unit.File_Names (Specification).Name) =\n+                           Name (1 .. Last)\n+                        then\n+                           Delete := True;\n+                           exit;\n+                        end if;\n+                     end loop;\n+                  end if;\n+\n+                  if Delete then\n+                     Set_Writable (Name (1 .. Last));\n+                     Delete_File (Name (1 .. Last), Disregard);\n+                  end if;\n+               end loop;\n+\n+               Close (Dir);\n+            end;\n \n             Copy_Interface_Sources\n               (For_Project => For_Project,\n                In_Tree     => In_Tree,\n                Interfaces  => Arguments (1 .. Argument_Number),\n-               To_Dir      => Copy_Dir);\n+               To_Dir      => In_Tree.Projects.Table\n+                                (For_Project).Library_Src_Dir);\n          end if;\n       end if;\n \n@@ -1591,130 +1762,84 @@ package body MLib.Prj is\n    procedure Check_Library\n      (For_Project : Project_Id; In_Tree : Project_Tree_Ref)\n    is\n-      Data : constant Project_Data :=\n-               In_Tree.Projects.Table (For_Project);\n+      Data    : constant Project_Data :=\n+                  In_Tree.Projects.Table (For_Project);\n+      Lib_TS  : Time_Stamp_Type;\n+      Current : constant Dir_Name_Str := Get_Current_Dir;\n \n    begin\n       --  No need to build the library if there is no object directory,\n       --  hence no object files to build the library.\n \n-      if Data.Library\n-        and then not Data.Need_To_Build_Lib\n-        and then Data.Object_Directory /= No_Name\n-      then\n+      if Data.Library then\n          declare\n-            Current  : constant Dir_Name_Str := Get_Current_Dir;\n             Lib_Name : constant Name_Id :=\n-                         Library_File_Name_For (For_Project, In_Tree);\n-            Lib_TS   : Time_Stamp_Type;\n-            Obj_TS   : Time_Stamp_Type;\n-\n-            Object_Dir : Dir_Type;\n-\n+              Library_File_Name_For (For_Project, In_Tree);\n          begin\n-            if Hostparm.OpenVMS then\n-               B_Start (B_Start'Last) := '$';\n-            end if;\n-\n             Change_Dir (Get_Name_String (Data.Library_Dir));\n-\n             Lib_TS := File_Stamp (Lib_Name);\n+            In_Tree.Projects.Table (For_Project).Library_TS := Lib_TS;\n+         end;\n \n-            --  If the library file does not exist, then the time stamp will\n-            --  be Empty_Time_Stamp, earlier than any other time stamp.\n-\n-            Change_Dir (Get_Name_String (Data.Object_Directory));\n-            Open (Dir => Object_Dir, Dir_Name => \".\");\n-\n-            --  For all entries in the object directory\n-\n-            loop\n-               Read (Object_Dir, Name_Buffer, Name_Len);\n-               exit when Name_Len = 0;\n-\n-               --  Check if it is an object file, but ignore any binder\n-               --  generated file.\n-\n-               if Is_Obj (Name_Buffer (1 .. Name_Len))\n-                  and then Name_Buffer (1 .. B_Start'Length) /= B_Start\n-               then\n-                  --  Get the object file time stamp\n-\n-                  Obj_TS := File_Stamp (Name_Find);\n-\n-                  --  If library file time stamp is earlier, set\n-                  --  Need_To_Build_Lib and return. String comparaison is used,\n-                  --  otherwise time stamps may be too close and the\n-                  --  comparaison would return True, which would trigger\n-                  --  an unnecessary rebuild of the library.\n-\n-                  if String (Lib_TS) < String (Obj_TS) then\n-\n-                     --  Library must be rebuilt\n+         if not Data.Externally_Built\n+           and then not Data.Need_To_Build_Lib\n+           and then Data.Object_Directory /= No_Name\n+         then\n+            declare\n+               Obj_TS     : Time_Stamp_Type;\n+               Object_Dir : Dir_Type;\n \n-                     In_Tree.Projects.Table\n-                       (For_Project).Need_To_Build_Lib := True;\n-                     exit;\n-                  end if;\n+            begin\n+               if Hostparm.OpenVMS then\n+                  B_Start (B_Start'Last) := '$';\n                end if;\n-            end loop;\n \n-            Change_Dir (Current);\n-         end;\n-      end if;\n-   end Check_Library;\n+               --  If the library file does not exist, then the time stamp will\n+               --  be Empty_Time_Stamp, earlier than any other time stamp.\n \n-   -----------\n-   -- Clean --\n-   -----------\n-\n-   procedure Clean (Directory : Name_Id) is\n-      Current  : constant Dir_Name_Str := Get_Current_Dir;\n-\n-      Dir : Dir_Type;\n+               Change_Dir (Get_Name_String (Data.Object_Directory));\n+               Open (Dir => Object_Dir, Dir_Name => \".\");\n \n-      Name : String (1 .. 200);\n-      Last : Natural;\n+               --  For all entries in the object directory\n \n-      Disregard : Boolean;\n+               loop\n+                  Read (Object_Dir, Name_Buffer, Name_Len);\n+                  exit when Name_Len = 0;\n \n-   begin\n-      Get_Name_String (Directory);\n+                  --  Check if it is an object file, but ignore any binder\n+                  --  generated file.\n \n-      --  Change the working directory to the directory to clean\n+                  if Is_Obj (Name_Buffer (1 .. Name_Len))\n+                    and then Name_Buffer (1 .. B_Start'Length) /= B_Start\n+                  then\n+                     --  Get the object file time stamp\n \n-      begin\n-         Change_Dir (Name_Buffer (1 .. Name_Len));\n+                     Obj_TS := File_Stamp (Name_Find);\n \n-      exception\n-         when others =>\n-            Com.Fail\n-              (\"unable to access directory \"\"\",\n-               Name_Buffer (1 .. Name_Len),\n-               \"\"\"\");\n-      end;\n+                     --  If library file time stamp is earlier, set\n+                     --  Need_To_Build_Lib and return. String comparaison is\n+                     --  used, otherwise time stamps may be too close and the\n+                     --  comparaison would return True, which would trigger\n+                     --  an unnecessary rebuild of the library.\n \n-      Open (Dir, \".\");\n+                     if String (Lib_TS) < String (Obj_TS) then\n \n-      --  For each regular file in the directory, make it writable and\n-      --  delete the file.\n+                        --  Library must be rebuilt\n \n-      loop\n-         Read (Dir, Name, Last);\n-         exit when Last = 0;\n+                        In_Tree.Projects.Table\n+                          (For_Project).Need_To_Build_Lib := True;\n+                        exit;\n+                     end if;\n+                  end if;\n+               end loop;\n \n-         if Is_Regular_File (Name (1 .. Last)) then\n-            Set_Writable (Name (1 .. Last));\n-            Delete_File (Name (1 .. Last), Disregard);\n+               Close (Object_Dir);\n+            end;\n          end if;\n-      end loop;\n-\n-      Close (Dir);\n \n-      --  Restore the initial working directory\n-\n-      Change_Dir (Current);\n-   end Clean;\n+         Change_Dir (Current);\n+      end if;\n+   end Check_Library;\n \n    ----------------------------\n    -- Copy_Interface_Sources --\n@@ -1749,8 +1874,7 @@ package body MLib.Prj is\n \n       function Is_Same_Or_Extension\n         (Extending : Project_Id;\n-         Extended  : Project_Id)\n-         return Boolean;\n+         Extended  : Project_Id) return Boolean;\n       --  Return True if project Extending is equal to or extends project\n       --  Extended.\n \n@@ -1793,8 +1917,7 @@ package body MLib.Prj is\n \n       function Is_Same_Or_Extension\n         (Extending : Project_Id;\n-         Extended  : Project_Id)\n-         return Boolean\n+         Extended  : Project_Id) return Boolean\n       is\n          Ext : Project_Id := Extending;\n \n@@ -2075,4 +2198,27 @@ package body MLib.Prj is\n       return C_SALs_Init_Using_Constructors /= 0;\n    end SALs_Use_Constructors;\n \n+   ---------------------------\n+   -- Ultimate_Extension_Of --\n+   ---------------------------\n+\n+   function Ultimate_Extension_Of\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return Project_Id\n+   is\n+      Result : Project_Id := Project;\n+      Data   : Project_Data;\n+\n+   begin\n+      if Project /= No_Project then\n+         loop\n+            Data := In_Tree.Projects.Table (Result);\n+            exit when Data.Extended_By = No_Project;\n+            Result := Data.Extended_By;\n+         end loop;\n+      end if;\n+\n+      return Result;\n+   end Ultimate_Extension_Of;\n+\n end MLib.Prj;"}, {"sha": "549578a25b2acf878d6f1ba9ee1e058e8507e502", "filename": "gcc/ada/mlib.adb", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fmlib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fmlib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib.adb?ref=104e4daaa53212b718cc916a0a688c06dab6a5fb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 1999-2005, Ada Core Technologies, Inc.           --\n+--                     Copyright (C) 1999-2005, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,6 +34,8 @@ with Namet;  use Namet;\n \n with MLib.Utl; use MLib.Utl;\n \n+with Prj.Com;\n+\n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n \n package body MLib is\n@@ -67,24 +69,24 @@ package body MLib is\n    procedure Check_Library_Name (Name : String) is\n    begin\n       if Name'Length = 0 then\n-         Fail (\"library name cannot be empty\");\n+         Prj.Com.Fail (\"library name cannot be empty\");\n       end if;\n \n       if Name'Length > Max_Characters_In_Library_Name then\n-         Fail (\"illegal library name \"\"\", Name, \"\"\": too long\");\n+         Prj.Com.Fail (\"illegal library name \"\"\", Name, \"\"\": too long\");\n       end if;\n \n       if not Is_Letter (Name (Name'First)) then\n-         Fail (\"illegal library name \"\"\",\n-               Name,\n-               \"\"\": should start with a letter\");\n+         Prj.Com.Fail (\"illegal library name \"\"\",\n+                       Name,\n+                       \"\"\": should start with a letter\");\n       end if;\n \n       for Index in Name'Range loop\n          if not Is_Alphanumeric (Name (Index)) then\n-            Fail (\"illegal library name \"\"\",\n-                  Name,\n-                  \"\"\": should include only letters and digits\");\n+            Prj.Com.Fail (\"illegal library name \"\"\",\n+                          Name,\n+                          \"\"\": should include only letters and digits\");\n          end if;\n       end loop;\n    end Check_Library_Name;\n@@ -273,7 +275,7 @@ package body MLib is\n             end;\n \n             if not Success then\n-               Fail (\"could not copy ALI files to library dir\");\n+               Prj.Com.Fail (\"could not copy ALI files to library dir\");\n             end if;\n          end loop;\n       end if;"}, {"sha": "b43fe801bc36e35c220ea2716a8bada857a40606", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=104e4daaa53212b718cc916a0a688c06dab6a5fb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n+--          Copyright (C) 2001-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -55,7 +55,7 @@ package body Prj.Attr is\n    --        insensitive\n    --    'c' same as 'b', with optional index\n \n-   --  End is indicated by two consecutive '#'.\n+   --  End is indicated by two consecutive '#'\n \n    Initialization_Data : constant String :=\n \n@@ -75,6 +75,7 @@ package body Prj.Attr is\n      \"SVlibrary_auto_init#\" &\n      \"LVlibrary_options#\" &\n      \"SVlibrary_src_dir#\" &\n+     \"SVlibrary_ali_dir#\" &\n      \"SVlibrary_gcc#\" &\n      \"SVlibrary_symbol_file#\" &\n      \"SVlibrary_symbol_policy#\" &"}, {"sha": "c20be6dd7395b57c3c9e2151a10830617b3d86dd", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=104e4daaa53212b718cc916a0a688c06dab6a5fb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -48,7 +48,7 @@ package body Prj.Env is\n    --  and ADA_OBJECTS_PATH are stored.\n \n    Ada_Path_Length : Natural := 0;\n-   --  Index of the last valid character in Ada_Path_Buffer.\n+   --  Index of the last valid character in Ada_Path_Buffer\n \n    Ada_Prj_Include_File_Set : Boolean := False;\n    Ada_Prj_Objects_File_Set : Boolean := False;\n@@ -270,9 +270,9 @@ package body Prj.Env is\n                   if Data.Library then\n                      if Data.Object_Directory = No_Name\n                        or else\n-                         Contains_ALI_Files (Data.Library_Dir)\n+                         Contains_ALI_Files (Data.Library_ALI_Dir)\n                      then\n-                        Add_To_Path (Get_Name_String (Data.Library_Dir));\n+                        Add_To_Path (Get_Name_String (Data.Library_ALI_Dir));\n                      else\n                         Add_To_Path (Get_Name_String (Data.Object_Directory));\n                      end if;\n@@ -2121,30 +2121,36 @@ package body Prj.Env is\n                           and then\n                             (not Including_Libraries or else not Data.Library))\n                      then\n-                        --  For a library project, add the library directory\n-                        --  if there is no object directory or if the library\n-                        --  directory contains ALI files; otherwise add the\n-                        --  object directory.\n+                        --  For a library project, add the library ALI\n+                        --  directory if there is no object directory or\n+                        --  if the library ALI directory contains ALI files;\n+                        --  otherwise add the object directory.\n \n                         if Data.Library then\n                            if Data.Object_Directory = No_Name\n-                             or else Contains_ALI_Files (Data.Library_Dir)\n+                             or else Contains_ALI_Files (Data.Library_ALI_Dir)\n                            then\n-                              Add_To_Object_Path (Data.Library_Dir, In_Tree);\n+                              Add_To_Object_Path\n+                                (Data.Library_ALI_Dir, In_Tree);\n                            else\n                               Add_To_Object_Path\n                                 (Data.Object_Directory, In_Tree);\n                            end if;\n \n                         --  For a non-library project, add the object\n                         --  directory, if it is not a virtual project, and\n-                        --  if there are Ada sources. If there are no Ada\n-                        --  sources, adding the object directory could\n-                        --  disrupt the order of the object dirs in the path.\n+                        --  if there are Ada sources or if the project is an\n+                        --  extending project. if There Are No Ada sources,\n+                        --  adding the object directory could disrupt\n+                        --  the order of the object dirs in the path.\n \n                         elsif not Data.Virtual\n-                          and then In_Tree.Projects.Table\n-                                     (Project).Ada_Sources_Present\n+                          and then (In_Tree.Projects.Table\n+                                      (Project).Ada_Sources_Present\n+                                    or else\n+                                      (Data.Extends /= No_Project\n+                                       and then\n+                                       Data.Object_Directory /= No_Name))\n                         then\n                            Add_To_Object_Path\n                              (Data.Object_Directory, In_Tree);\n@@ -2230,7 +2236,7 @@ package body Prj.Env is\n          Add (Project);\n       end if;\n \n-      --  Write and close any file that has been created.\n+      --  Write and close any file that has been created\n \n       if Source_FD /= Invalid_FD then\n          for Index in Source_Path_Table.First .."}, {"sha": "959294405d0ce5957036c52f51c8b0d556501b95", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 272, "deletions": 13, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=104e4daaa53212b718cc916a0a688c06dab6a5fb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2000-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2000-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1383,12 +1383,16 @@ package body Prj.Nmsc is\n \n       Lib_Name : constant Prj.Variable_Value :=\n                    Prj.Util.Value_Of\n-                    (Snames.Name_Library_Name, Attributes, In_Tree);\n+                     (Snames.Name_Library_Name, Attributes, In_Tree);\n \n       Lib_Version : constant Prj.Variable_Value :=\n                       Prj.Util.Value_Of\n                         (Snames.Name_Library_Version, Attributes, In_Tree);\n \n+      Lib_ALI_Dir : constant Prj.Variable_Value :=\n+                      Prj.Util.Value_Of\n+                        (Snames.Name_Library_Ali_Dir, Attributes, In_Tree);\n+\n       The_Lib_Kind : constant Prj.Variable_Value :=\n                        Prj.Util.Value_Of\n                          (Snames.Name_Library_Kind, Attributes, In_Tree);\n@@ -1488,14 +1492,78 @@ package body Prj.Nmsc is\n             Data.Library_Dir := No_Name;\n             Data.Display_Library_Dir := No_Name;\n \n-         --  Display the Library directory in high verbosity\n-\n          else\n-            if Current_Verbosity = High then\n-               Write_Str (\"Library directory =\"\"\");\n-               Write_Str (Get_Name_String (Data.Display_Library_Dir));\n-               Write_Line (\"\"\"\");\n-            end if;\n+            declare\n+               OK       : Boolean := True;\n+               Dirs_Id  : String_List_Id;\n+               Dir_Elem : String_Element;\n+\n+            begin\n+               --  The library directory cannot be the same as a source\n+               --  directory of the current project.\n+\n+               Dirs_Id := Data.Source_Dirs;\n+               while Dirs_Id /= Nil_String loop\n+                  Dir_Elem := In_Tree.String_Elements.Table (Dirs_Id);\n+                  Dirs_Id  := Dir_Elem.Next;\n+\n+                  if Data.Library_Dir = Dir_Elem.Value then\n+                     Err_Vars.Error_Msg_Name_1 := Dir_Elem.Value;\n+                     Error_Msg\n+                       (Project, In_Tree,\n+                        \"library directory cannot be the same \" &\n+                        \"as source directory {\",\n+                        Lib_Dir.Location);\n+                     OK := False;\n+                     exit;\n+                  end if;\n+               end loop;\n+\n+               if OK then\n+\n+                  --  The library directory cannot be the same as a source\n+                  --  directory of another project either.\n+\n+                  Project_Loop :\n+                  for Pid in 1 .. Project_Table.Last (In_Tree.Projects) loop\n+                     if Pid /= Project then\n+                        Dirs_Id := In_Tree.Projects.Table (Pid).Source_Dirs;\n+\n+                        Dir_Loop : while Dirs_Id /= Nil_String loop\n+                           Dir_Elem := In_Tree.String_Elements.Table (Dirs_Id);\n+                           Dirs_Id  := Dir_Elem.Next;\n+\n+                           if Data.Library_Dir = Dir_Elem.Value then\n+                              Err_Vars.Error_Msg_Name_1 := Dir_Elem.Value;\n+                              Err_Vars.Error_Msg_Name_2 :=\n+                                In_Tree.Projects.Table (Pid).Name;\n+\n+                              Error_Msg\n+                                (Project, In_Tree,\n+                                 \"library directory cannot be the same \" &\n+                                 \"as source directory { of project {\",\n+                                 Lib_Dir.Location);\n+                              OK := False;\n+                              exit Project_Loop;\n+                           end if;\n+                        end loop Dir_Loop;\n+                     end if;\n+                  end loop Project_Loop;\n+               end if;\n+\n+               if not OK then\n+                  Data.Library_Dir := No_Name;\n+                  Data.Display_Library_Dir := No_Name;\n+\n+               elsif Current_Verbosity = High then\n+\n+                  --  Display the Library directory in high verbosity\n+\n+                  Write_Str (\"Library directory =\"\"\");\n+                  Write_Str (Get_Name_String (Data.Display_Library_Dir));\n+                  Write_Line (\"\"\"\");\n+               end if;\n+            end;\n          end if;\n       end if;\n \n@@ -1536,6 +1604,158 @@ package body Prj.Nmsc is\n             Data.Library := False;\n \n          else\n+            if Lib_ALI_Dir.Value = Empty_String then\n+               if Current_Verbosity = High then\n+                  Write_Line (\"No library 'A'L'I directory specified\");\n+               end if;\n+               Data.Library_ALI_Dir := Data.Library_Dir;\n+               Data.Display_Library_ALI_Dir := Data.Display_Library_Dir;\n+\n+            else\n+               --  Find path name, check that it is a directory\n+\n+               Locate_Directory\n+                 (Lib_ALI_Dir.Value, Data.Display_Directory,\n+                  Data.Library_ALI_Dir, Data.Display_Library_ALI_Dir);\n+\n+               if Data.Library_ALI_Dir = No_Name then\n+\n+                  --  Get the absolute name of the library ALI directory that\n+                  --  does not exist, to report an error.\n+\n+                  declare\n+                     Dir_Name : constant String :=\n+                                  Get_Name_String (Lib_ALI_Dir.Value);\n+\n+                  begin\n+                     if Is_Absolute_Path (Dir_Name) then\n+                        Err_Vars.Error_Msg_Name_1 := Lib_Dir.Value;\n+\n+                     else\n+                        Get_Name_String (Data.Display_Directory);\n+\n+                        if Name_Buffer (Name_Len) /= Directory_Separator then\n+                           Name_Len := Name_Len + 1;\n+                           Name_Buffer (Name_Len) := Directory_Separator;\n+                        end if;\n+\n+                        Name_Buffer\n+                          (Name_Len + 1 .. Name_Len + Dir_Name'Length) :=\n+                          Dir_Name;\n+                        Name_Len := Name_Len + Dir_Name'Length;\n+                        Err_Vars.Error_Msg_Name_1 := Name_Find;\n+                     end if;\n+\n+                     --  Report the error\n+\n+                     Error_Msg\n+                       (Project, In_Tree,\n+                        \"library 'A'L'I directory { does not exist\",\n+                        Lib_ALI_Dir.Location);\n+                  end;\n+               end if;\n+\n+               if Data.Library_ALI_Dir /= Data.Library_Dir then\n+\n+                  --  The library ALI directory cannot be the same as the\n+                  --  Object directory.\n+\n+                  if Data.Library_ALI_Dir = Data.Object_Directory then\n+                     Error_Msg\n+                       (Project, In_Tree,\n+                        \"library 'A'L'I directory cannot be the same \" &\n+                        \"as object directory\",\n+                        Lib_ALI_Dir.Location);\n+                     Data.Library_ALI_Dir := No_Name;\n+                     Data.Display_Library_ALI_Dir := No_Name;\n+\n+                  else\n+                     declare\n+                        OK       : Boolean := True;\n+                        Dirs_Id  : String_List_Id;\n+                        Dir_Elem : String_Element;\n+\n+                     begin\n+                        --  The library ALI directory cannot be the same as\n+                        --  a source directory of the current project.\n+\n+                        Dirs_Id := Data.Source_Dirs;\n+                        while Dirs_Id /= Nil_String loop\n+                           Dir_Elem := In_Tree.String_Elements.Table (Dirs_Id);\n+                           Dirs_Id  := Dir_Elem.Next;\n+\n+                           if Data.Library_ALI_Dir = Dir_Elem.Value then\n+                              Err_Vars.Error_Msg_Name_1 := Dir_Elem.Value;\n+                              Error_Msg\n+                                (Project, In_Tree,\n+                                 \"library 'A'L'I directory cannot be \" &\n+                                 \"the same as source directory {\",\n+                                 Lib_ALI_Dir.Location);\n+                              OK := False;\n+                              exit;\n+                           end if;\n+                        end loop;\n+\n+                        if OK then\n+\n+                           --  The library ALI directory cannot be the same as\n+                           --  a source directory of another project either.\n+\n+                           ALI_Project_Loop :\n+                           for\n+                             Pid in 1 .. Project_Table.Last (In_Tree.Projects)\n+                           loop\n+                              if Pid /= Project then\n+                                 Dirs_Id :=\n+                                   In_Tree.Projects.Table (Pid).Source_Dirs;\n+\n+                                 ALI_Dir_Loop :\n+                                 while Dirs_Id /= Nil_String loop\n+                                    Dir_Elem :=\n+                                      In_Tree.String_Elements.Table (Dirs_Id);\n+                                    Dirs_Id  := Dir_Elem.Next;\n+\n+                                    if\n+                                      Data.Library_ALI_Dir = Dir_Elem.Value\n+                                    then\n+                                       Err_Vars.Error_Msg_Name_1 :=\n+                                         Dir_Elem.Value;\n+                                       Err_Vars.Error_Msg_Name_2 :=\n+                                         In_Tree.Projects.Table (Pid).Name;\n+\n+                                       Error_Msg\n+                                         (Project, In_Tree,\n+                                          \"library 'A'L'I directory cannot \" &\n+                                          \"be the same as source directory \" &\n+                                          \"{ of project {\",\n+                                          Lib_ALI_Dir.Location);\n+                                       OK := False;\n+                                       exit ALI_Project_Loop;\n+                                    end if;\n+                                 end loop ALI_Dir_Loop;\n+                              end if;\n+                           end loop ALI_Project_Loop;\n+                        end if;\n+\n+                        if not OK then\n+                           Data.Library_ALI_Dir := No_Name;\n+                           Data.Display_Library_ALI_Dir := No_Name;\n+\n+                        elsif Current_Verbosity = High then\n+\n+                           --  Display the Library ALI directory in high\n+                           --  verbosity.\n+\n+                           Write_Str (\"Library ALI directory =\"\"\");\n+                           Write_Str\n+                             (Get_Name_String (Data.Display_Library_ALI_Dir));\n+                           Write_Line (\"\"\"\");\n+                        end if;\n+                     end;\n+                  end if;\n+               end if;\n+            end if;\n+\n             pragma Assert (Lib_Version.Kind = Single);\n \n             if Lib_Version.Value = Empty_String then\n@@ -2279,18 +2499,19 @@ package body Prj.Nmsc is\n                      Lib_Src_Dir.Location);\n                   Data.Library_Src_Dir := No_Name;\n \n-                  --  Check if it is same as one of the source directories\n-\n                else\n                   declare\n-                     Src_Dirs : String_List_Id := Data.Source_Dirs;\n+                     Src_Dirs : String_List_Id;\n                      Src_Dir  : String_Element;\n \n                   begin\n+                     --  Interface copy directory cannot be one of the source\n+                     --  directory of the current project.\n+\n+                     Src_Dirs := Data.Source_Dirs;\n                      while Src_Dirs /= Nil_String loop\n                         Src_Dir := In_Tree.String_Elements.Table\n                                                           (Src_Dirs);\n-                        Src_Dirs := Src_Dir.Next;\n \n                         --  Report error if it is one of the source directories\n \n@@ -2303,7 +2524,45 @@ package body Prj.Nmsc is\n                            Data.Library_Src_Dir := No_Name;\n                            exit;\n                         end if;\n+\n+                        Src_Dirs := Src_Dir.Next;\n                      end loop;\n+\n+                     if Data.Library_Src_Dir /= No_Name then\n+\n+                        --  It cannot be a source directory of any other\n+                        --  project either.\n+\n+                        Project_Loop : for Pid in 1 ..\n+                          Project_Table.Last (In_Tree.Projects)\n+                        loop\n+                           Src_Dirs :=\n+                             In_Tree.Projects.Table (Pid).Source_Dirs;\n+                           Dir_Loop : while Src_Dirs /= Nil_String loop\n+                              Src_Dir :=\n+                                In_Tree.String_Elements.Table (Src_Dirs);\n+\n+                              --  Report error if it is one of the source\n+                              --  directories\n+\n+                              if Data.Library_Src_Dir = Src_Dir.Value then\n+                                 Error_Msg_Name_1 := Src_Dir.Value;\n+                                 Error_Msg_Name_2 :=\n+                                   In_Tree.Projects.Table (Pid).Name;\n+                                 Error_Msg\n+                                   (Project, In_Tree,\n+                                    \"directory to copy interfaces cannot \" &\n+                                    \"be the same as source directory { of \" &\n+                                    \"project {\",\n+                                    Lib_Src_Dir.Location);\n+                                 Data.Library_Src_Dir := No_Name;\n+                                 exit Project_Loop;\n+                              end if;\n+\n+                              Src_Dirs := Src_Dir.Next;\n+                           end loop Dir_Loop;\n+                        end loop Project_Loop;\n+                     end if;\n                   end;\n \n                   --  In high verbosity, if there is a valid Library_Src_Dir,"}, {"sha": "4f689adc555bba5060e18c6c77b635383027eab1", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=104e4daaa53212b718cc916a0a688c06dab6a5fb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2001-2005 Free Software Foundation, Inc.       --\n+--          Copyright (C) 2001-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -102,6 +102,8 @@ package body Prj is\n       Display_Library_Dir            => No_Name,\n       Library_Src_Dir                => No_Name,\n       Display_Library_Src_Dir        => No_Name,\n+      Library_ALI_Dir                => No_Name,\n+      Display_Library_ALI_Dir        => No_Name,\n       Library_Name                   => No_Name,\n       Library_Kind                   => Static,\n       Lib_Internal_Name              => No_Name,\n@@ -121,6 +123,7 @@ package body Prj is\n       Known_Order_Of_Source_Dirs     => True,\n       Object_Directory               => No_Name,\n       Display_Object_Dir             => No_Name,\n+      Library_TS                     => Empty_Time_Stamp,\n       Exec_Directory                 => No_Name,\n       Display_Exec_Dir               => No_Name,\n       Extends                        => No_Project,\n@@ -132,6 +135,7 @@ package body Prj is\n       Default_Linker_Path            => No_Name,\n       Decl                           => No_Declarations,\n       Imported_Projects              => Empty_Project_List,\n+      All_Imported_Projects          => Empty_Project_List,\n       Ada_Include_Path               => null,\n       Ada_Objects_Path               => null,\n       Include_Path_File              => No_Name,\n@@ -485,7 +489,7 @@ package body Prj is\n          end if;\n       end loop;\n \n-      --  If none can be found, create a new one.\n+      --  If none can be found, create a new one\n \n       if not Found then\n          Element :=\n@@ -526,7 +530,7 @@ package body Prj is\n          end if;\n       end loop;\n \n-      --  If none can be found, create a new one.\n+      --  If none can be found, create a new one\n \n       if not Found then\n          Element :="}, {"sha": "e360bddb41090bd0faecc9d4a0fe2cc58728a593", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 62, "deletions": 38, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104e4daaa53212b718cc916a0a688c06dab6a5fb/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=104e4daaa53212b718cc916a0a688c06dab6a5fb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -73,9 +73,11 @@ package Prj is\n    --  Canonical_Case_File_Name is called on this variable in the body of Prj.\n \n    -----------------------------------------------------\n-   -- Multi-language stuff that will be modified soon --\n+   -- Multi-language Stuff That Will be Modified Soon --\n    -----------------------------------------------------\n \n+   --  Still should be properly commented ???\n+\n    type Language_Index is new Nat;\n \n    No_Language_Index           : constant Language_Index := 0;\n@@ -232,6 +234,7 @@ package Prj is\n \n    type Other_Source_Id is new Nat;\n    No_Other_Source : constant Other_Source_Id := 0;\n+\n    type Other_Source is record\n       Language         : Language_Index;       --  language of the source\n       File_Name        : Name_Id;              --  source file simple name\n@@ -273,10 +276,10 @@ package Prj is\n    type Policy is (Autonomous, Compliant, Controlled, Restricted);\n    --  Type to specify the symbol policy, when symbol control is supported.\n    --  See full explanation about this type in package Symbols.\n-   --  Autonomous: Create a symbol file without considering any reference\n-   --  Compliant: Try to be as compatible as possible with an existing ref\n-   --  Controlled: Fail if symbols are not the same as those in the reference\n-   --  Restricted: Restrict the symbols to those in the symbol file\n+   --    Autonomous: Create a symbol file without considering any reference\n+   --    Compliant:  Try to be as compatible as possible with an existing ref\n+   --    Controlled: Fail if symbols are not the same as those in the reference\n+   --    Restricted: Restrict the symbols to those in the symbol file\n \n    type Symbol_Record is record\n       Symbol_File   : Name_Id := No_Name;\n@@ -301,12 +304,12 @@ package Prj is\n    type String_List_Id is new Nat;\n    Nil_String : constant String_List_Id := 0;\n    type String_Element is record\n-      Value    : Name_Id        := No_Name;\n-      Index    : Int            := 0;\n+      Value         : Name_Id        := No_Name;\n+      Index         : Int            := 0;\n       Display_Value : Name_Id   := No_Name;\n-      Location : Source_Ptr     := No_Location;\n-      Flag     : Boolean        := False;\n-      Next     : String_List_Id := Nil_String;\n+      Location      : Source_Ptr     := No_Location;\n+      Flag          : Boolean        := False;\n+      Next          : String_List_Id := Nil_String;\n    end record;\n    --  To hold values for string list variables and array elements.\n    --  Component Flag may be used for various purposes. For source\n@@ -353,9 +356,9 @@ package Prj is\n    type Variable_Id is new Nat;\n    No_Variable : constant Variable_Id := 0;\n    type Variable is record\n-      Next     : Variable_Id := No_Variable;\n-      Name     : Name_Id;\n-      Value    : Variable_Value;\n+      Next  : Variable_Id := No_Variable;\n+      Name  : Name_Id;\n+      Value : Variable_Value;\n    end record;\n    --  To hold the list of variables in a project file and in packages\n \n@@ -430,7 +433,7 @@ package Prj is\n       Parent : Package_Id   := No_Package;\n       Next   : Package_Id   := No_Package;\n    end record;\n-   --  A package. Includes declarations that may include other packages\n+   --  A package (includes declarations that may include other packages)\n \n    package Package_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Package_Element,\n@@ -473,8 +476,8 @@ package Prj is\n       --  The position in the project file source where\n       --  Ada_Spec_Suffix is defined.\n \n-      Impl_Suffixes    : Impl_Suffix_Array   := No_Impl_Suffixes;\n-      Supp_Suffixes    : Supp_Language_Index := No_Supp_Language_Index;\n+      Impl_Suffixes : Impl_Suffix_Array   := No_Impl_Suffixes;\n+      Supp_Suffixes : Supp_Language_Index := No_Supp_Language_Index;\n       --  The source suffixes of the different languages\n \n       Body_Suffix : Array_Element_Id := No_Array_Element;\n@@ -553,7 +556,7 @@ package Prj is\n       Supp_Languages : Supp_Language_Index  := No_Supp_Language_Index;\n       --  Indicate the different languages of the source of this project\n \n-      First_Referred_By  : Project_Id := No_Project;\n+      First_Referred_By : Project_Id := No_Project;\n       --  The project, if any, that was the first to be known as importing or\n       --  extending this project. Set by Prj.Proc.Process.\n \n@@ -585,6 +588,7 @@ package Prj is\n       --  Directory where the project file resides. Set by Prj.Proc.Process\n \n       Display_Directory : Name_Id := No_Name;\n+      --  comment ???\n \n       Dir_Path : String_Access;\n       --  Same as Directory, but as an access to String. Set by\n@@ -603,18 +607,31 @@ package Prj is\n       --  different from Library_Dir for platforms where the file names are\n       --  case-insensitive.\n \n+      Library_TS : Time_Stamp_Type := Empty_Time_Stamp;\n+      --  The timestamp of a library file in a library project.\n+      --  Set by MLib.Prj.Check_Library.\n+\n       Library_Src_Dir : Name_Id := No_Name;\n-      --  If a library project, directory where the sources and the ALI files\n-      --  of the library are copied. By default, if attribute Library_Src_Dir\n-      --  is not specified, sources are not copied anywhere and ALI files are\n-      --  copied in the Library Directory. Set by\n-      --  Prj.Nmsc.Language_Independent_Check.\n+      --  If a Stand-Alone Library project, directory where the sources\n+      --  of the interfaces of the library are copied. By default, if\n+      --  attribute Library_Src_Dir is not specified, sources of the interfaces\n+      --  are not copied anywhere. Set by Prj.Nmsc.Check_Stand_Alone_Library.\n \n       Display_Library_Src_Dir : Name_Id := No_Name;\n       --  The name of the library source directory, for display purposes.\n       --  May be different from Library_Src_Dir for platforms where the file\n       --  names are case-insensitive.\n \n+      Library_ALI_Dir : Name_Id := No_Name;\n+      --  In a library project, directory where the ALI files are copied.\n+      --  If attribute Library_ALI_Dir is not specified, ALI files are\n+      --  copied in the Library_Dir. Set by Prj.Nmsc.Check_Library_Attributes.\n+\n+      Display_Library_ALI_Dir : Name_Id := No_Name;\n+      --  The name of the library ALI directory, for display purposes. May be\n+      --  different from Library_ALI_Dir for platforms where the file names are\n+      --  case-insensitive.\n+\n       Library_Name : Name_Id := No_Name;\n       --  If a library project, name of the library\n       --  Set by Prj.Nmsc.Language_Independent_Check.\n@@ -653,8 +670,8 @@ package Prj is\n       --  A flag that indicates that there are non-Ada sources in this project\n \n       Sources : String_List_Id := Nil_String;\n-      --  The list of all the source file names. Set by\n-      --  Prj.Nmsc.Check_Ada_Naming_Scheme.\n+      --  The list of all the source file names.\n+      --  Set by Prj.Nmsc.Check_Ada_Naming_Scheme.\n \n       First_Other_Source : Other_Source_Id := No_Other_Source;\n       Last_Other_Source  : Other_Source_Id := No_Other_Source;\n@@ -711,13 +728,14 @@ package Prj is\n       --  Set by Prj.Nmsc.Check_Naming_Scheme.\n \n       First_Language_Processing : First_Language_Processing_Data :=\n-        Default_First_Language_Processing_Data;\n+                                    Default_First_Language_Processing_Data;\n+      --  Comment needed ???\n \n-      Supp_Language_Processing      : Supp_Language_Index :=\n-                                       No_Supp_Language_Index;\n+      Supp_Language_Processing : Supp_Language_Index := No_Supp_Language_Index;\n+      --  Comment needed\n \n-      Default_Linker                : Name_Id := No_Name;\n-      Default_Linker_Path           : Name_Id := No_Name;\n+      Default_Linker      : Name_Id := No_Name;\n+      Default_Linker_Path : Name_Id := No_Name;\n \n       Decl : Declarations := No_Declarations;\n       --  The declarations (variables, attributes and packages) of this\n@@ -727,6 +745,10 @@ package Prj is\n       --  The list of all directly imported projects, if any. Set by\n       --  Prj.Proc.Process.\n \n+      All_Imported_Projects : Project_List := Empty_Project_List;\n+      --  The list of all projects imported directly or indirectly, if any.\n+      --  Set by Make.Initialize.\n+\n       Ada_Include_Path : String_Access := null;\n       --  The cached value of ADA_INCLUDE_PATH for this project file. Do not\n       --  use this field directly outside of the compiler, use\n@@ -771,7 +793,7 @@ package Prj is\n       --  A flag to avoid checking repetitively the naming scheme of\n       --  this project file. Set by Prj.Nmsc.Check_Ada_Naming_Scheme.\n \n-      Seen                           : Boolean := False;\n+      Seen : Boolean := False;\n       --  A flag to mark a project as \"visited\" to avoid processing the same\n       --  project several time.\n \n@@ -943,14 +965,14 @@ package Prj is\n       In_Project : Project_Data;\n       In_Tree    : Project_Tree_Ref) return Boolean;\n    --  Return True when Language is one of the languages used in\n-   --  project Project.\n+   --  project In_Project.\n \n    procedure Set\n      (Language   : Language_Index;\n       Present    : Boolean;\n       In_Project : in out Project_Data;\n       In_Tree    : Project_Tree_Ref);\n-   --  Indicate if Language is or not a language used in project Project\n+   --  Indicate if Language is or not a language used in project In_Project\n \n    function Language_Processing_Data_Of\n      (Language   : Language_Index;\n@@ -1018,6 +1040,7 @@ private\n       Table_Low_Bound      => 1,\n       Table_Initial        => 5,\n       Table_Increment      => 100);\n+   --  Comment ???\n \n    package Path_File_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Name_Id,\n@@ -1045,10 +1068,11 @@ private\n    --  A table to store the object dirs, before creating the object path file\n \n    type Private_Project_Tree_Data is record\n-      Namings           : Naming_Table.Instance;\n-      Path_Files        : Path_File_Table.Instance;\n-      Source_Paths      : Source_Path_Table.Instance;\n-      Object_Paths      : Object_Path_Table.Instance;\n-      Default_Naming    : Naming_Data;\n+      Namings        : Naming_Table.Instance;\n+      Path_Files     : Path_File_Table.Instance;\n+      Source_Paths   : Source_Path_Table.Instance;\n+      Object_Paths   : Object_Path_Table.Instance;\n+      Default_Naming : Naming_Data;\n    end record;\n+   --  Comment ???\n end Prj;"}]}