{"sha": "19552aa5728591fdd2913ef54422e869af46852e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk1NTJhYTU3Mjg1OTFmZGQyOTEzZWY1NDQyMmU4NjlhZjQ2ODUyZQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2000-11-13T14:14:44Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2000-11-13T14:14:44Z"}, "message": "c-common.c (boolean_increment): New function.\n\n\t* c-common.c (boolean_increment): New function.\n\t* c-common.h (enum c_tree_index): Add CTI_C_BOOL_TYPE,\n\tCTI_C_BOOL_TRUE and CTI_C_BOOL_FALSE.\n\t(c_bool_type_node, c_bool_true_node, c_bool_false_node): Define.\n\t(boolean_increment): Declare.\n\t* c-convert.c (convert): Allow for BOOLEAN_TYPE.\n\t* c-decl.c (init_decl_processing): Create boolean nodes.\n\t(finish_struct): Allow for _Bool bitfields.\n\t* c-parse.in (reswords): Add _Bool.\n\t(rid_to_yy): Allow for RID_BOOL.\n\t* c-typeck.c (default_conversion): Make booleans promote to int.\n\t(convert_arguments, build_unary_op, build_modify_expr,\n\tconvert_for_assignment): Allow for booleans.\n\t* ginclude/stdbool.h: Make conforming to C99.\n\ncp:\n\t* typeck.c (build_unary_op): Use boolean_increment from\n\tc-common.c, moving the relevant code there.\n\ntestsuite:\n\t* gcc.dg/c99-bool-1.c: New test.\n\nFrom-SVN: r37428", "tree": {"sha": "f2b5f8cbfe56d1d0cc94e1b89e38e9cb318f7ece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2b5f8cbfe56d1d0cc94e1b89e38e9cb318f7ece"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19552aa5728591fdd2913ef54422e869af46852e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19552aa5728591fdd2913ef54422e869af46852e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19552aa5728591fdd2913ef54422e869af46852e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19552aa5728591fdd2913ef54422e869af46852e/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "444ca59fa44336fbfe4744c9870bf1dd0a75093f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/444ca59fa44336fbfe4744c9870bf1dd0a75093f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/444ca59fa44336fbfe4744c9870bf1dd0a75093f"}], "stats": {"total": 448, "additions": 404, "deletions": 44}, "files": [{"sha": "08d2edfb7a64704140529cc789e237219e30a365", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19552aa5728591fdd2913ef54422e869af46852e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19552aa5728591fdd2913ef54422e869af46852e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19552aa5728591fdd2913ef54422e869af46852e", "patch": "@@ -1,3 +1,20 @@\n+2000-11-13  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-common.c (boolean_increment): New function.\n+\t* c-common.h (enum c_tree_index): Add CTI_C_BOOL_TYPE,\n+\tCTI_C_BOOL_TRUE and CTI_C_BOOL_FALSE.\n+\t(c_bool_type_node, c_bool_true_node, c_bool_false_node): Define.\n+\t(boolean_increment): Declare.\n+\t* c-convert.c (convert): Allow for BOOLEAN_TYPE.\n+\t* c-decl.c (init_decl_processing): Create boolean nodes.\n+\t(finish_struct): Allow for _Bool bitfields.\n+\t* c-parse.in (reswords): Add _Bool.\n+\t(rid_to_yy): Allow for RID_BOOL.\n+\t* c-typeck.c (default_conversion): Make booleans promote to int.\n+\t(convert_arguments, build_unary_op, build_modify_expr,\n+\tconvert_for_assignment): Allow for booleans.\n+\t* ginclude/stdbool.h: Make conforming to C99.\n+\n 2000-11-13  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* c-parse.in (c99_block_start, c99_block_end,"}, {"sha": "e0d8a45a4a5120dee87a47cca95740a1d9966933", "filename": "gcc/c-common.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=19552aa5728591fdd2913ef54422e869af46852e", "patch": "@@ -6147,3 +6147,44 @@ c_expand_builtin_printf (arglist, target, tmode, modifier, ignore)\n \t\t      (ignore ? const0_rtx : target),\n \t\t      tmode, modifier);\n }\n+\f\n+\n+/* Given a boolean expression ARG, return a tree representing an increment\n+   or decrement (as indicated by CODE) of ARG.  The front end must check for\n+   invalid cases (e.g., decrement in C++).  */\n+tree\n+boolean_increment (code, arg)\n+     enum tree_code code;\n+     tree arg;\n+{\n+  tree val;\n+  tree true_res = (c_language == clk_cplusplus\n+\t\t   ? boolean_true_node\n+\t\t   : c_bool_true_node);\n+  arg = stabilize_reference (arg);\n+  switch (code)\n+    {\n+    case PREINCREMENT_EXPR:\n+      val = build (MODIFY_EXPR, TREE_TYPE (arg), arg, true_res);\n+      break;\n+    case POSTINCREMENT_EXPR:\n+      val = build (MODIFY_EXPR, TREE_TYPE (arg), arg, true_res);\n+      arg = save_expr (arg);\n+      val = build (COMPOUND_EXPR, TREE_TYPE (arg), val, arg);\n+      val = build (COMPOUND_EXPR, TREE_TYPE (arg), arg, val);\n+      break;\n+    case PREDECREMENT_EXPR:\n+      val = build (MODIFY_EXPR, TREE_TYPE (arg), arg, invert_truthvalue (arg));\n+      break;\n+    case POSTDECREMENT_EXPR:\n+      val = build (MODIFY_EXPR, TREE_TYPE (arg), arg, invert_truthvalue (arg));\n+      arg = save_expr (arg);\n+      val = build (COMPOUND_EXPR, TREE_TYPE (arg), val, arg);\n+      val = build (COMPOUND_EXPR, TREE_TYPE (arg), arg, val);\n+      break;\n+    default:\n+      abort ();\n+    }\n+  TREE_SIDE_EFFECTS (val) = 1;\n+  return val;\n+}"}, {"sha": "06c9c61ac12998f54e409664e6f804f564f2bca1", "filename": "gcc/c-common.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=19552aa5728591fdd2913ef54422e869af46852e", "patch": "@@ -130,9 +130,14 @@ enum c_tree_index\n     CTI_STRING_TYPE,\n     CTI_CONST_STRING_TYPE,\n \n+    /* Type for boolean expressions (bool in C++, int in C).  */\n     CTI_BOOLEAN_TYPE,\n     CTI_BOOLEAN_TRUE,\n     CTI_BOOLEAN_FALSE,\n+    /* C99's _Bool type.  */\n+    CTI_C_BOOL_TYPE,\n+    CTI_C_BOOL_TRUE,\n+    CTI_C_BOOL_FALSE,\n     CTI_DEFAULT_FUNCTION_TYPE,\n     CTI_VOID_LIST,\n \n@@ -172,6 +177,10 @@ enum c_tree_index\n #define boolean_true_node\t\tc_global_trees[CTI_BOOLEAN_TRUE]\n #define boolean_false_node\t\tc_global_trees[CTI_BOOLEAN_FALSE]\n \n+#define c_bool_type_node\t\tc_global_trees[CTI_C_BOOL_TYPE]\n+#define c_bool_true_node\t\tc_global_trees[CTI_C_BOOL_TRUE]\n+#define c_bool_false_node\t\tc_global_trees[CTI_C_BOOL_FALSE]\n+\n #define char_array_type_node\t\tc_global_trees[CTI_CHAR_ARRAY_TYPE]\n #define wchar_array_type_node\t\tc_global_trees[CTI_WCHAR_ARRAY_TYPE]\n #define int_array_type_node\t\tc_global_trees[CTI_INT_ARRAY_TYPE]\n@@ -713,6 +722,10 @@ extern tree expand_tree_builtin                 PARAMS ((tree, tree, tree));\n \n extern tree decl_constant_value\t\tPARAMS ((tree));\n \n+/* Handle increment and decrement of boolean types.  */\n+extern tree boolean_increment\t\t\tPARAMS ((enum tree_code,\n+\t\t\t\t\t\t\t tree));\n+\n /* Hook currently used only by the C++ front end to reset internal state\n    after entering or leaving a header file.  */\n extern void extract_interface_info\t\tPARAMS ((void));"}, {"sha": "7f57725b7c16039551a911efcc9d1d7f40c87766", "filename": "gcc/c-convert.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-convert.c?ref=19552aa5728591fdd2913ef54422e869af46852e", "patch": "@@ -88,6 +88,8 @@ convert (type, expr)\n #endif\n   if (code == INTEGER_TYPE || code == ENUMERAL_TYPE)\n     return fold (convert_to_integer (type, e));\n+  if (code == BOOLEAN_TYPE)\n+    return fold (build1 (NOP_EXPR, type, truthvalue_conversion (expr)));\n   if (code == POINTER_TYPE || code == REFERENCE_TYPE)\n     return fold (convert_to_pointer (type, e));\n   if (code == REAL_TYPE)"}, {"sha": "d9ceac8988ef3f749fcbd60064ea53ff6214c812", "filename": "gcc/c-decl.c", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=19552aa5728591fdd2913ef54422e869af46852e", "patch": "@@ -3113,6 +3113,19 @@ init_decl_processing ()\n   boolean_true_node = integer_one_node;\n   boolean_false_node = integer_zero_node;\n \n+  /* With GCC, C99's _Bool is always of size 1.  */\n+  c_bool_type_node = make_unsigned_type (CHAR_TYPE_SIZE);\n+  TREE_SET_CODE (c_bool_type_node, BOOLEAN_TYPE);\n+  TYPE_MAX_VALUE (c_bool_type_node) = build_int_2 (1, 0);\n+  TREE_TYPE (TYPE_MAX_VALUE (c_bool_type_node)) = c_bool_type_node;\n+  TYPE_PRECISION (c_bool_type_node) = 1;\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"_Bool\"),\n+\t\t\tc_bool_type_node));\n+  c_bool_false_node = build_int_2 (0, 0);\n+  TREE_TYPE (c_bool_false_node) = c_bool_type_node;\n+  c_bool_true_node = build_int_2 (1, 0);\n+  TREE_TYPE (c_bool_true_node) = c_bool_type_node;\n+\n   string_type_node = build_pointer_type (char_type_node);\n   const_string_type_node\n     = build_pointer_type (build_type_variant (char_type_node, 1, 0));\n@@ -5431,6 +5444,7 @@ finish_struct (t, fieldlist, attributes)\n       /* Detect invalid bit-field type.  */\n       if (DECL_INITIAL (x)\n \t  && TREE_CODE (TREE_TYPE (x)) != INTEGER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (x)) != BOOLEAN_TYPE\n \t  && TREE_CODE (TREE_TYPE (x)) != ENUMERAL_TYPE)\n \t{\n \t  error_with_decl (x, \"bit-field `%s' has invalid type\");\n@@ -5440,6 +5454,7 @@ finish_struct (t, fieldlist, attributes)\n       if (DECL_INITIAL (x) && pedantic\n \t  && TYPE_MAIN_VARIANT (TREE_TYPE (x)) != integer_type_node\n \t  && TYPE_MAIN_VARIANT (TREE_TYPE (x)) != unsigned_type_node\n+\t  && TYPE_MAIN_VARIANT (TREE_TYPE (x)) != c_bool_type_node\n \t  /* Accept an enum that's equivalent to int or unsigned int.  */\n \t  && !(TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n \t       && (TYPE_PRECISION (TREE_TYPE (x))\n@@ -5450,10 +5465,14 @@ finish_struct (t, fieldlist, attributes)\n \t field widths.  */\n       if (DECL_INITIAL (x))\n \t{\n+\t  int max_width;\n+\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (x)) == c_bool_type_node)\n+\t    max_width = CHAR_TYPE_SIZE;\n+\t  else\n+\t    max_width = TYPE_PRECISION (TREE_TYPE (x));\n \t  if (tree_int_cst_sgn (DECL_INITIAL (x)) < 0)\n \t    error_with_decl (x, \"negative width in bit-field `%s'\");\n-\t  else if (0 < compare_tree_int (DECL_INITIAL (x),\n-\t\t\t\t\t TYPE_PRECISION (TREE_TYPE (x))))\n+\t  else if (0 < compare_tree_int (DECL_INITIAL (x), max_width))\n \t    pedwarn_with_decl (x, \"width of `%s' exceeds its type\");\n \t  else if (integer_zerop (DECL_INITIAL (x)) && DECL_NAME (x) != 0)\n \t    error_with_decl (x, \"zero width for bit-field `%s'\");"}, {"sha": "e4daad6d2e0ac20bb607fd8c102e1b63aaa054c1", "filename": "gcc/c-parse.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=19552aa5728591fdd2913ef54422e869af46852e", "patch": "@@ -2832,6 +2832,7 @@ struct resword\n \n static const struct resword reswords[] =\n {\n+  { \"_Bool\",\t\tRID_BOOL,\t0 },\n   { \"_Complex\",\t\tRID_COMPLEX,\t0 },\n   { \"__alignof\",\tRID_ALIGNOF,\t0 },\n   { \"__alignof__\",\tRID_ALIGNOF,\t0 },\n@@ -3007,7 +3008,7 @@ static const short rid_to_yy[RID_MAX] =\n   /* RID_PTRVALUE */\tPTR_VALUE,\n \n   /* C++ */\n-  /* RID_BOOL */\t0,\n+  /* RID_BOOL */\tTYPESPEC,\n   /* RID_WCHAR */\t0,\n   /* RID_CLASS */\t0,\n   /* RID_PUBLIC */\t0,"}, {"sha": "6705440c3e2d283bc6db8e50fb13b29742d07f28", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=19552aa5728591fdd2913ef54422e869af46852e", "patch": "@@ -947,6 +947,9 @@ default_conversion (exp)\n       return convert (integer_type_node, exp);\n     }\n \n+  if (code == BOOLEAN_TYPE)\n+    return convert (integer_type_node, exp);\n+\n   if (flag_traditional && !flag_allow_single_precision\n       && TYPE_MAIN_VARIANT (type) == float_type_node)\n     return convert (double_type_node, exp);\n@@ -1733,7 +1736,8 @@ convert_arguments (typelist, values, name, fundecl)\n \t      \n \t      if (PROMOTE_PROTOTYPES\n \t\t  && (TREE_CODE (type) == INTEGER_TYPE\n-\t\t      || TREE_CODE (type) == ENUMERAL_TYPE)\n+\t\t      || TREE_CODE (type) == ENUMERAL_TYPE\n+\t\t      || TREE_CODE (type) == BOOLEAN_TYPE)\n \t\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n \t\tparmval = default_conversion (parmval);\n \t    }\n@@ -2790,7 +2794,7 @@ build_unary_op (code, xarg, noconvert)\n \n   if (typecode == ERROR_MARK)\n     return error_mark_node;\n-  if (typecode == ENUMERAL_TYPE)\n+  if (typecode == ENUMERAL_TYPE || typecode == BOOLEAN_TYPE)\n     typecode = INTEGER_TYPE;\n \n   switch (code)\n@@ -2985,18 +2989,23 @@ build_unary_op (code, xarg, noconvert)\n \t      else\n \t\t{\n \t\t  tree incremented, modify, value;\n-\t\t  arg = stabilize_reference (arg);\n-\t\t  if (code == PREINCREMENT_EXPR || code == PREDECREMENT_EXPR)\n-\t\t    value = arg;\n+\t\t  if (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)\n+\t\t    value = boolean_increment (code, arg);\n \t\t  else\n-\t\t    value = save_expr (arg);\n-\t\t  incremented = build (((code == PREINCREMENT_EXPR\n-\t\t\t\t\t || code == POSTINCREMENT_EXPR)\n-\t\t\t\t\t? PLUS_EXPR : MINUS_EXPR),\n-\t\t\t\t       argtype, value, inc);\n-\t\t  TREE_SIDE_EFFECTS (incremented) = 1;\n-\t\t  modify = build_modify_expr (arg, NOP_EXPR, incremented);\n-\t\t  value = build (COMPOUND_EXPR, TREE_TYPE (arg), modify, value);\n+\t\t    {\n+\t\t      arg = stabilize_reference (arg);\n+\t\t      if (code == PREINCREMENT_EXPR || code == PREDECREMENT_EXPR)\n+\t\t\tvalue = arg;\n+\t\t      else\n+\t\t\tvalue = save_expr (arg);\n+\t\t      incremented = build (((code == PREINCREMENT_EXPR\n+\t\t\t\t\t     || code == POSTINCREMENT_EXPR)\n+\t\t\t\t\t    ? PLUS_EXPR : MINUS_EXPR),\n+\t\t\t\t\t   argtype, value, inc);\n+\t\t      TREE_SIDE_EFFECTS (incremented) = 1;\n+\t\t      modify = build_modify_expr (arg, NOP_EXPR, incremented);\n+\t\t      value = build (COMPOUND_EXPR, TREE_TYPE (arg), modify, value);\n+\t\t    }\n \t\t  TREE_USED (value) = 1;\n \t\t  return value;\n \t\t}\n@@ -3021,7 +3030,10 @@ build_unary_op (code, xarg, noconvert)\n \t\t\t      || code == POSTINCREMENT_EXPR)\n \t\t\t     ? \"increment\" : \"decrement\"));\n \n-\tval = build (code, TREE_TYPE (arg), arg, inc);\n+\tif (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)\n+\t  val = boolean_increment (code, arg);\n+\telse\n+\t  val = build (code, TREE_TYPE (arg), arg, inc);\n \tTREE_SIDE_EFFECTS (val) = 1;\n \tval = convert (result_type, val);\n \tif (TREE_CODE (val) != code)\n@@ -3969,6 +3981,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \n   if (TREE_CODE (lhs) == COMPONENT_REF\n       && (TREE_CODE (lhstype) == INTEGER_TYPE\n+\t  || TREE_CODE (lhstype) == BOOLEAN_TYPE\n \t  || TREE_CODE (lhstype) == REAL_TYPE\n \t  || TREE_CODE (lhstype) == ENUMERAL_TYPE))\n     lhstype = TREE_TYPE (get_unwidened (lhs, 0));\n@@ -4084,9 +4097,11 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n     }\n   /* Arithmetic types all interconvert, and enum is treated like int.  */\n   else if ((codel == INTEGER_TYPE || codel == REAL_TYPE \n-\t    || codel == ENUMERAL_TYPE || codel == COMPLEX_TYPE)\n+\t    || codel == ENUMERAL_TYPE || codel == COMPLEX_TYPE\n+\t    || codel == BOOLEAN_TYPE)\n \t   && (coder == INTEGER_TYPE || coder == REAL_TYPE \n-\t       || coder == ENUMERAL_TYPE || coder == COMPLEX_TYPE))\n+\t       || coder == ENUMERAL_TYPE || coder == COMPLEX_TYPE\n+\t       || coder == BOOLEAN_TYPE))\n     return convert_and_check (type, rhs);\n \n   /* Conversion to a transparent union from its member types.\n@@ -4266,6 +4281,8 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t\t\t   errtype, funname, parmnum);\n       return convert (type, rhs);\n     }\n+  else if (codel == BOOLEAN_TYPE && coder == POINTER_TYPE)\n+    return convert (type, rhs);\n \n   if (!errtype)\n     {"}, {"sha": "7e6d6f7e105a6dc935a3dba6d8e321f98ed602ca", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=19552aa5728591fdd2913ef54422e869af46852e", "patch": "@@ -1,3 +1,8 @@\n+2000-11-13  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* typeck.c (build_unary_op): Use boolean_increment from\n+\tc-common.c, moving the relevant code there.\n+\n 2000-11-11  Jason Merrill  <jason@redhat.com>\n \n \t* typeck.c (mark_addressable): Don't call put_var_into_stack."}, {"sha": "0c628bb4cd10946cbb918e36534edd8bf75bea1b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=19552aa5728591fdd2913ef54422e869af46852e", "patch": "@@ -4580,18 +4580,7 @@ build_unary_op (code, xarg, noconvert)\n \t       my patch to expand_increment. (jason)  */\n \t    val = build (code, TREE_TYPE (arg), arg, inc);\n #else\n-\t    if (code == POSTINCREMENT_EXPR)\n-\t      {\n-\t\targ = stabilize_reference (arg);\n-\t\tval = build (MODIFY_EXPR, TREE_TYPE (arg), arg,\n-\t\t\t     boolean_true_node);\n-\t\targ = save_expr (arg);\n-\t\tval = build (COMPOUND_EXPR, TREE_TYPE (arg), val, arg);\n-\t\tval = build (COMPOUND_EXPR, TREE_TYPE (arg), arg, val);\n-\t      }\n-\t    else\n-\t      val = build (MODIFY_EXPR, TREE_TYPE (arg), arg,\n-\t\t\t   boolean_true_node);\n+\t    val = boolean_increment (code, arg);\n #endif\n \t  }\n \telse"}, {"sha": "33f7d3d4110b843db57318b478db8a76b4f4c932", "filename": "gcc/ginclude/stdbool.h", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fginclude%2Fstdbool.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Fginclude%2Fstdbool.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fstdbool.h?ref=19552aa5728591fdd2913ef54422e869af46852e", "patch": "@@ -32,20 +32,10 @@ Boston, MA 02111-1307, USA.  */\n #define _STDBOOL_H\n \n #ifndef __cplusplus\n-/* The type `_Bool' must promote to `int' or `unsigned int'.  The constants\n-   `true' and `false' must have the value 0 and 1 respectively.  */\n-typedef enum\n-  {\n-    false = 0,\n-    true = 1\n-  } _Bool;\n-\n-/* The names `true' and `false' must also be made available as macros.  */\n-#define false\tfalse\n-#define true\ttrue\n \n-/* The macro `bool', which may be undefined, expands to _Bool.  */\n-#define bool _Bool\n+#define bool\t_Bool\n+#define true\t1\n+#define false\t0\n \n #else /* __cplusplus */\n "}, {"sha": "30345b6c9ed569299d27a1f99b7953609c4a178e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=19552aa5728591fdd2913ef54422e869af46852e", "patch": "@@ -1,3 +1,7 @@\n+2000-11-13  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* gcc.dg/c99-bool-1.c: New test.\n+\n 2000-11-13  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gcc.dg/c99-scope-1.c: Remove xfail."}, {"sha": "632c486c865afbb3d70281db948f9d9d39055616", "filename": "gcc/testsuite/gcc.dg/c99-bool-1.c", "status": "added", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-bool-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19552aa5728591fdd2913ef54422e869af46852e/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-bool-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-bool-1.c?ref=19552aa5728591fdd2913ef54422e869af46852e", "patch": "@@ -0,0 +1,262 @@\n+/* Test for _Bool and <stdbool.h> in C99.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do run } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+/* _Bool must be a builtin type.  */\n+\n+_Bool foo;\n+\n+#include <stdbool.h>\n+\n+/* Three macros must be integer constant expressions suitable for use\n+   in #if.\n+*/\n+\n+#if !defined(true) || (true != 1)\n+#error \"bad stdbool true\" /* { dg-bogus \"#error\" \"bad stdbool.h\" } */\n+#endif\n+\n+#if !defined(false) || (false != 0)\n+#error \"bad stdbool false\" /* { dg-bogus \"#error\" \"bad stdbool.h\" } */\n+#endif\n+\n+#if !defined(__bool_true_false_are_defined) || (__bool_true_false_are_defined != 1)\n+#error \"bad stdbool __bool_true_false_are_defined\" /* { dg-bogus \"#error\" \"bad stdbool.h\" } */\n+#endif\n+\n+int a = true;\n+int b = false;\n+int c = __bool_true_false_are_defined;\n+\n+struct foo\n+{\n+  _Bool a : 1;\n+  _Bool b : 2;\n+  _Bool c : 7;\n+} sf;\n+\n+#define str(x) xstr(x)\n+#define xstr(x) #x\n+\n+\n+extern void abort (void);\n+extern void exit (int);\n+extern int strcmp (const char *, const char *);\n+\n+int\n+main (void)\n+{\n+  /* The macro `bool' must expand to _Bool.  */\n+  const char *t = str (bool);\n+  _Bool u, v;\n+  if (strcmp (t, \"_Bool\"))\n+    abort ();\n+  if (a != 1 || b != 0 || c != 1)\n+    abort ();\n+  /* Casts to _Bool have a specified behaviour.  */\n+  if ((int)(_Bool)2 != 1)\n+    abort ();\n+  if ((int)(_Bool)0.2 != 1)\n+    abort ();\n+  /* Pointers may be assigned to _Bool.  */\n+  if ((u = t) != 1)\n+    abort ();\n+  /* _Bool may be used to subscript arrays.  */\n+  u = 0;\n+  if (t[u] != '_')\n+    abort ();\n+  if (u[t] != '_')\n+    abort ();\n+  u = 1;\n+  if (t[u] != 'B')\n+    abort ();\n+  if (u[t] != 'B')\n+    abort ();\n+  /* Test increment and decrement operators.  */\n+  u = 0;\n+  if (u++ != 0)\n+    abort ();\n+  if (u != 1)\n+    abort ();\n+  if (u++ != 1)\n+    abort ();\n+  if (u != 1)\n+    abort ();\n+  u = 0;\n+  if (++u != 1)\n+    abort ();\n+  if (u != 1)\n+    abort ();\n+  if (++u != 1)\n+    abort ();\n+  if (u != 1)\n+    abort ();\n+  u = 0;\n+  if (u-- != 0)\n+    abort ();\n+  if (u != 1)\n+    abort ();\n+  if (u-- != 1)\n+    abort ();\n+  if (u != 0)\n+    abort ();\n+  u = 0;\n+  if (--u != 1)\n+    abort ();\n+  if (u != 1)\n+    abort ();\n+  if (--u != 0)\n+    abort ();\n+  if (u != 0)\n+    abort ();\n+  /* Test unary + - ~ !.  */\n+  u = 0;\n+  if (+u != 0)\n+    abort ();\n+  if (-u != 0)\n+    abort ();\n+  u = 1;\n+  if (+u != 1)\n+    abort ();\n+  if (-u != -1)\n+    abort ();\n+  u = 2;\n+  if (+u != 1)\n+    abort ();\n+  if (-u != -1)\n+    abort ();\n+  u = 0;\n+  if (~u != ~(int)0)\n+    abort ();\n+  u = 1;\n+  if (~u != ~(int)1)\n+    abort ();\n+  u = 0;\n+  if (!u != 1)\n+    abort ();\n+  u = 1;\n+  if (!u != 0)\n+    abort ();\n+  /* Test arithmetic * / % + - (which all apply promotions).  */\n+  u = 0;\n+  if (u + 2 != 2)\n+    abort ();\n+  u = 1;\n+  if (u * 4 != 4)\n+    abort ();\n+  if (u % 3 != 1)\n+    abort ();\n+  if (u / 1 != 1)\n+    abort ();\n+  if (4 / u != 4)\n+    abort ();\n+  if (u - 7 != -6)\n+    abort ();\n+  /* Test bitwise shift << >>.  */\n+  u = 1;\n+  if (u << 1 != 2)\n+    abort ();\n+  if (u >> 1 != 0)\n+    abort ();\n+  /* Test relational and equality operators < > <= >= == !=.  */\n+  u = 0;\n+  v = 0;\n+  if (u < v || u > v || !(u <= v) || !(u >= v) || !(u == v) || u != v)\n+    abort ();\n+  u = 0;\n+  v = 1;\n+  if (!(u < v) || u > v || !(u <= v) || u >= v || u == v || !(u != v))\n+    abort ();\n+  /* Test bitwise operators & ^ |.  */\n+  u = 1;\n+  if ((u | 2) != 3)\n+    abort ();\n+  if ((u ^ 3) != 2)\n+    abort ();\n+  if ((u & 1) != 1)\n+    abort ();\n+  if ((u & 0) != 0)\n+    abort ();\n+  /* Test logical && ||.  */\n+  u = 0;\n+  v = 1;\n+  if (!(u || v))\n+    abort ();\n+  if (!(v || u))\n+    abort ();\n+  if (u && v)\n+    abort ();\n+  if (v && u)\n+    abort ();\n+  u = 1;\n+  v = 1;\n+  if (!(u && v))\n+    abort ();\n+  /* Test conditional ? :.  */\n+  u = 0;\n+  if ((u ? 4 : 7) != 7)\n+    abort ();\n+  u = 1;\n+  v = 0;\n+  if ((1 ? u : v) != 1)\n+    abort ();\n+  if ((1 ? 4 : u) != 4)\n+    abort ();\n+  /* Test assignment operators = *= /= %= += -= <<= >>= &= ^= |=.  */\n+  if ((u = 2) != 1)\n+    abort ();\n+  if (u != 1)\n+    abort ();\n+  if ((u *= -1) != 1)\n+    abort ();\n+  if (u != 1)\n+    abort ();\n+  if ((u /= 2) != 0)\n+    abort ();\n+  if ((u += 3) != 1)\n+    abort ();\n+  if ((u -= 1) != 0)\n+    abort ();\n+  u = 1;\n+  if ((u <<= 4) != 1)\n+    abort ();\n+  if ((u >>= 1) != 0)\n+    abort ();\n+  u = 1;\n+  if ((u &= 0) != 0)\n+    abort ();\n+  if ((u |= 2) != 1)\n+    abort ();\n+  if ((u ^= 3) != 1)\n+    abort ();\n+  /* Test comma expressions.  */\n+  u = 1;\n+  if ((4, u) != 1)\n+    abort ();\n+  /* Test bitfields.  */\n+  {\n+    int i;\n+    for (i = 0; i < sizeof (struct foo); i++)\n+      *((unsigned char *)&sf + i) = (unsigned char) -1;\n+    sf.a = 1;\n+    if (sf.a != 1)\n+      abort ();\n+    sf.b = 1;\n+    if (sf.b != 1)\n+      abort ();\n+    sf.c = 1;\n+    if (sf.c != 1)\n+      abort ();\n+    sf.a = 0;\n+    if (sf.a != 0)\n+      abort ();\n+    sf.b = 0;\n+    if (sf.b != 0)\n+      abort ();\n+    sf.c = 0;\n+    if (sf.c != 0)\n+      abort ();\n+  }\n+  exit (0);\n+}"}]}