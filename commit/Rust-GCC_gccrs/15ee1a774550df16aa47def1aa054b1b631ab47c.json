{"sha": "15ee1a774550df16aa47def1aa054b1b631ab47c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVlZTFhNzc0NTUwZGYxNmFhNDdkZWYxYWEwNTRiMWI2MzFhYjQ3Yw==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2014-05-06T19:59:44Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2014-05-06T19:59:44Z"}, "message": "macros.h [...]: Add parameter to pass the 2 instances to check allocator equality.\n\n2014-05-06  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/debug/macros.h [__glibcxx_check_equal_allocs]: Add\n\tparameter to pass the 2 instances to check allocator equality.\n\t* include/debug/safe_container.h: New, define _Safe_container<>.\n\t* include/Makefile.am: Add previous.\n\t* include/debug/deque (std::__debug::deque<>): Inherit\n\t_Safe_container<>. Use default implementation for all special\n\tfunctions.\n\t* include/debug/forward_list (std::__debug::forward_list<>):\n\tLikewise.\n\t* include/debug/list (std::__debug::list<>): Likewise.\n\t* include/debug/map.h (std::__debug::map<>): Likewise.\n\t* include/debug/multimap.h (std::__debug::multimap<>): Likewise.\n\t* include/debug/set.h (std::__debug::set<>): Likewise.\n\t* include/debug/multiset.h (std::__debug::multiset<>): Likewise.\n\t* include/debug/string (std::__debug::basic_string<>): Likewise.\n\t* include/debug/unordered_map\n\t(std::__debug::unordered_map<>): Likewise.\n\t(std::__debug::unordered_multimap<>): Likewise.\n\t* include/debug/unordered_set\n\t(std::__debug::unordered_set<>): Likewise.\n\t(std::__debug::unordered_multiset<>): Likewise.\n\t* include/debug/vector (std::__debug::vector<>): Likewise.\n\t* include/debug/safe_base.h (_Safe_sequence_base()): Add\n\tnoexcept.\n\t(_Safe_sequence_base(_Safe_sequence_base&&): Remove.\n\t(~_Safe_sequence_base()): Add noexcept.\n\t* include/debug/safe_sequence.h\n\t(std::__debug::_Safe_node_sequence<>): New.\n\t* include/debug/safe_unordered_base.h\n\t(_Safe_unordered_container_base()): Add noexcept.\n\t(~_Safe_unordered_container_base()): Likewise.\n\t(_M_swap(_Safe_unordered_container_base&)): Likewise.\n\t* include/debug/safe_unordered_container.h:\n\t(_Safe_unordered_container<>::_M_invalidate_locals()): New.\n\t(_Safe_unordered_container<>::_M_invalidate_all()): New.\n\t* src/c++11/debug.cc: Limit includes, adapt methods noexcept\n\tqualifications.\n\t* testsuite/util/debug/checks.h (check_construct1): Just implement\n\tan invalid constructor invocation  and no other operations\n\tpotentially not supported by some types of container.\n\t(check_construct2): Likewise.\n\t(check_construct3): Likewise.\n\t* testsuite/23_containers/forward_list/allocator/move.cc: Add\n\tcheck on iterators to make sure they are correctly moved in debug\n\tmode.\n\t* testsuite/23_containers/forward_list/allocator/move_assign.cc:\n\tLikewise.\n\t* testsuite/23_containers/map/allocator/move.cc: Likewise.\n\t* testsuite/23_containers/map/allocator/move_assign.cc: Likewise.\n\t* testsuite/23_containers/multimap/allocator/move.cc: Likewise.\n\t* testsuite/23_containers/multimap/allocator/move_assign.cc:\n\tLikewise.\n\t* testsuite/23_containers/multiset/allocator/move.cc: Likewise.\n\t* testsuite/23_containers/multiset/allocator/move_assign.cc:\n\tLikewise.\n\t* testsuite/23_containers/set/allocator/move.cc: Likewise.\n\t* testsuite/23_containers/set/allocator/move_assign.cc: Likewise.\n\t* testsuite/23_containers/unordered_map/allocator/move.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_map/allocator/move_assign.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_multimap/allocator/move.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_multimap/allocator/move_assign.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_multiset/allocator/move.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_multiset/allocator/move_assign.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_set/allocator/move.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_set/allocator/move_assign.cc:\n\tLikewise.\n\t* testsuite/23_containers/forward_list/debug/construct1_neg.cc:\n\tNew.\n\t* testsuite/23_containers/forward_list/debug/construct2_neg.cc:\n\tNew.\n\t* testsuite/23_containers/forward_list/debug/construct3_neg.cc:\n\tNew.\n\t* testsuite/23_containers/forward_list/debug/construct4_neg.cc:\n\tNew.\n\t* testsuite/23_containers/forward_list/debug/move_assign_neg.cc:\n\tNew.\n\t* testsuite/23_containers/forward_list/debug/move_neg.cc: New.\n\t* testsuite/23_containers/map/debug/construct5_neg.cc: New.\n\t* testsuite/23_containers/map/debug/move_assign_neg.cc: New.\n\t* testsuite/23_containers/map/debug/move_neg.cc: New.\n\t* testsuite/23_containers/multimap/debug/construct5_neg.cc: New.\n\t* testsuite/23_containers/multimap/debug/move_assign_neg.cc: New.\n\t* testsuite/23_containers/multimap/debug/move_neg.cc: New.\n\t* testsuite/23_containers/multiset/debug/construct5_neg.cc: New.\n\t* testsuite/23_containers/multiset/debug/move_assign_neg.cc: New.\n\t* testsuite/23_containers/multiset/debug/move_neg.cc: New.\n\t* testsuite/23_containers/set/debug/construct5_neg.cc: New.\n\t* testsuite/23_containers/set/debug/move_assign_neg.cc: New.\n\t* testsuite/23_containers/set/debug/move_neg.cc: New.\n\t* testsuite/23_containers/unordered_map/debug/construct5_neg.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_map/debug/move_assign_neg.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_map/debug/move_neg.cc: New.\n\t* testsuite/23_containers/unordered_multimap/debug/construct5_neg.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_multimap/debug/move_assign_neg.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_multimap/debug/move_neg.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_multiset/debug/construct5_neg.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_multiset/debug/move_assign_neg.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_multiset/debug/move_neg.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_set/debug/construct5_neg.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_set/debug/move_assign_neg.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_set/debug/move_neg.cc: New.\n\t* testsuite/23_containers/vector/debug/move_neg.cc: New.\n\nFrom-SVN: r210123", "tree": {"sha": "d4e99984d126872ab18f322fa732caabac6c62ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4e99984d126872ab18f322fa732caabac6c62ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15ee1a774550df16aa47def1aa054b1b631ab47c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15ee1a774550df16aa47def1aa054b1b631ab47c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15ee1a774550df16aa47def1aa054b1b631ab47c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15ee1a774550df16aa47def1aa054b1b631ab47c/comments", "author": null, "committer": null, "parents": [{"sha": "6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f7e0b570ab9ab1c6bbc2cb598284e2e5202e027"}], "stats": {"total": 4300, "additions": 2934, "deletions": 1366}, "files": [{"sha": "f46bdc47481b24bdbd8fea709f45aaade251a4d6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -1,3 +1,125 @@\n+2014-05-06  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/debug/macros.h [__glibcxx_check_equal_allocs]: Add\n+\tparameter to pass the 2 instances to check allocator equality.\n+\t* include/debug/safe_container.h: New, define _Safe_container<>.\n+\t* include/Makefile.am: Add previous.\n+\t* include/debug/deque (std::__debug::deque<>): Inherit\n+\t_Safe_container<>. Use default implementation for all special\n+\tfunctions.\n+\t* include/debug/forward_list (std::__debug::forward_list<>):\n+\tLikewise.\n+\t* include/debug/list (std::__debug::list<>): Likewise.\n+\t* include/debug/map.h (std::__debug::map<>): Likewise.\n+\t* include/debug/multimap.h (std::__debug::multimap<>): Likewise.\n+\t* include/debug/set.h (std::__debug::set<>): Likewise.\n+\t* include/debug/multiset.h (std::__debug::multiset<>): Likewise.\n+\t* include/debug/string (std::__debug::basic_string<>): Likewise.\n+\t* include/debug/unordered_map\n+\t(std::__debug::unordered_map<>): Likewise.\n+\t(std::__debug::unordered_multimap<>): Likewise.\n+\t* include/debug/unordered_set\n+\t(std::__debug::unordered_set<>): Likewise.\n+\t(std::__debug::unordered_multiset<>): Likewise.\n+\t* include/debug/vector (std::__debug::vector<>): Likewise.\n+\t* include/debug/safe_base.h (_Safe_sequence_base()): Add\n+\tnoexcept.\n+\t(_Safe_sequence_base(_Safe_sequence_base&&): Remove.\n+\t(~_Safe_sequence_base()): Add noexcept.\n+\t* include/debug/safe_sequence.h\n+\t(std::__debug::_Safe_node_sequence<>): New.\n+\t* include/debug/safe_unordered_base.h\n+\t(_Safe_unordered_container_base()): Add noexcept.\n+\t(~_Safe_unordered_container_base()): Likewise.\n+\t(_M_swap(_Safe_unordered_container_base&)): Likewise.\n+\t* include/debug/safe_unordered_container.h:\n+\t(_Safe_unordered_container<>::_M_invalidate_locals()): New.\n+\t(_Safe_unordered_container<>::_M_invalidate_all()): New.\n+\t* src/c++11/debug.cc: Limit includes, adapt methods noexcept\n+\tqualifications.\n+\t* testsuite/util/debug/checks.h (check_construct1): Just implement\n+\tan invalid constructor invocation  and no other operations\n+\tpotentially not supported by some types of container.\n+\t(check_construct2): Likewise.\n+\t(check_construct3): Likewise.\n+\t* testsuite/23_containers/forward_list/allocator/move.cc: Add\n+\tcheck on iterators to make sure they are correctly moved in debug\n+\tmode.\n+\t* testsuite/23_containers/forward_list/allocator/move_assign.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/map/allocator/move.cc: Likewise.\n+\t* testsuite/23_containers/map/allocator/move_assign.cc: Likewise.\n+\t* testsuite/23_containers/multimap/allocator/move.cc: Likewise.\n+\t* testsuite/23_containers/multimap/allocator/move_assign.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/multiset/allocator/move.cc: Likewise.\n+\t* testsuite/23_containers/multiset/allocator/move_assign.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/set/allocator/move.cc: Likewise.\n+\t* testsuite/23_containers/set/allocator/move_assign.cc: Likewise.\n+\t* testsuite/23_containers/unordered_map/allocator/move.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_map/allocator/move_assign.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_multimap/allocator/move.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_multimap/allocator/move_assign.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_multiset/allocator/move.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_multiset/allocator/move_assign.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_set/allocator/move.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_set/allocator/move_assign.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/forward_list/debug/construct1_neg.cc:\n+\tNew.\n+\t* testsuite/23_containers/forward_list/debug/construct2_neg.cc:\n+\tNew.\n+\t* testsuite/23_containers/forward_list/debug/construct3_neg.cc:\n+\tNew.\n+\t* testsuite/23_containers/forward_list/debug/construct4_neg.cc:\n+\tNew.\n+\t* testsuite/23_containers/forward_list/debug/move_assign_neg.cc:\n+\tNew.\n+\t* testsuite/23_containers/forward_list/debug/move_neg.cc: New.\n+\t* testsuite/23_containers/map/debug/construct5_neg.cc: New.\n+\t* testsuite/23_containers/map/debug/move_assign_neg.cc: New.\n+\t* testsuite/23_containers/map/debug/move_neg.cc: New.\n+\t* testsuite/23_containers/multimap/debug/construct5_neg.cc: New.\n+\t* testsuite/23_containers/multimap/debug/move_assign_neg.cc: New.\n+\t* testsuite/23_containers/multimap/debug/move_neg.cc: New.\n+\t* testsuite/23_containers/multiset/debug/construct5_neg.cc: New.\n+\t* testsuite/23_containers/multiset/debug/move_assign_neg.cc: New.\n+\t* testsuite/23_containers/multiset/debug/move_neg.cc: New.\n+\t* testsuite/23_containers/set/debug/construct5_neg.cc: New.\n+\t* testsuite/23_containers/set/debug/move_assign_neg.cc: New.\n+\t* testsuite/23_containers/set/debug/move_neg.cc: New.\n+\t* testsuite/23_containers/unordered_map/debug/construct5_neg.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_map/debug/move_assign_neg.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_map/debug/move_neg.cc: New.\n+\t* testsuite/23_containers/unordered_multimap/debug/construct5_neg.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_multimap/debug/move_assign_neg.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_multimap/debug/move_neg.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_multiset/debug/construct5_neg.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_multiset/debug/move_assign_neg.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_multiset/debug/move_neg.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_set/debug/construct5_neg.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_set/debug/move_assign_neg.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_set/debug/move_neg.cc: New.\n+\t* testsuite/23_containers/vector/debug/move_neg.cc: New.\n+\n 2014-05-05  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* config/abi/post/ia64-linux-gnu/baseline_symbols.txt"}, {"sha": "0d676dbdf395fad517cfb5d4da3afb9e58a98f75", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -733,6 +733,7 @@ debug_headers = \\\n \t${debug_srcdir}/multimap.h \\\n \t${debug_srcdir}/multiset.h \\\n \t${debug_srcdir}/safe_base.h \\\n+\t${debug_srcdir}/safe_container.h \\\n \t${debug_srcdir}/safe_iterator.h \\\n \t${debug_srcdir}/safe_iterator.tcc \\\n \t${debug_srcdir}/safe_local_iterator.h \\"}, {"sha": "75be7489b1a6490f5bd58fc999431334baf3a77a", "filename": "libstdc++-v3/include/debug/deque", "status": "modified", "additions": 77, "deletions": 70, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -31,6 +31,7 @@\n \n #include <deque>\n #include <debug/safe_sequence.h>\n+#include <debug/safe_container.h>\n #include <debug/safe_iterator.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -40,36 +41,59 @@ namespace __debug\n   /// Class std::deque with safety/checking/debug instrumentation.\n   template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n     class deque\n-    : public _GLIBCXX_STD_C::deque<_Tp, _Allocator>,\n-      public __gnu_debug::_Safe_sequence<deque<_Tp, _Allocator> >\n+    : public __gnu_debug::_Safe_container<\n+\tdeque<_Tp, _Allocator>, _Allocator,\n+\t__gnu_debug::_Safe_sequence, false>,\n+      public _GLIBCXX_STD_C::deque<_Tp, _Allocator>\n     {\n-      typedef  _GLIBCXX_STD_C::deque<_Tp, _Allocator> _Base;\n+      typedef  _GLIBCXX_STD_C::deque<_Tp, _Allocator>\t\t_Base;\n+      typedef __gnu_debug::_Safe_container<\n+\tdeque, _Allocator, __gnu_debug::_Safe_sequence, false>\t_Safe;\n \n-      typedef typename _Base::const_iterator _Base_const_iterator;\n-      typedef typename _Base::iterator _Base_iterator;\n+      typedef typename _Base::const_iterator\t_Base_const_iterator;\n+      typedef typename _Base::iterator\t\t_Base_iterator;\n       typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n+\n     public:\n-      typedef typename _Base::reference             reference;\n-      typedef typename _Base::const_reference       const_reference;\n+      typedef typename _Base::reference\t\t\treference;\n+      typedef typename _Base::const_reference\t\tconst_reference;\n \n-      typedef __gnu_debug::_Safe_iterator<_Base_iterator,deque>\n-\t\t\t\t\t\t    iterator;\n-      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,deque>\n-\t\t\t\t\t\t    const_iterator;\n+      typedef __gnu_debug::_Safe_iterator<_Base_iterator, deque>\n+\t\t\t\t\t\t\titerator;\n+      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator, deque>\n+\t\t\t\t\t\t\tconst_iterator;\n \n-      typedef typename _Base::size_type             size_type;\n-      typedef typename _Base::difference_type       difference_type;\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::difference_type\t\tdifference_type;\n \n-      typedef _Tp\t\t\t\t    value_type;\n-      typedef _Allocator\t\t\t    allocator_type;\n-      typedef typename _Base::pointer               pointer;\n-      typedef typename _Base::const_pointer         const_pointer;\n-      typedef std::reverse_iterator<iterator>       reverse_iterator;\n-      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+      typedef _Tp\t\t\t\t\tvalue_type;\n+      typedef _Allocator\t\t\t\tallocator_type;\n+      typedef typename _Base::pointer\t\t\tpointer;\n+      typedef typename _Base::const_pointer\t\tconst_pointer;\n+      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n \n       // 23.2.1.1 construct/copy/destroy:\n \n-      deque() : _Base() { }\n+#if __cplusplus < 201103L\n+      deque()\n+      : _Base() { }\n+\n+      deque(const deque& __x)\n+      : _Base(__x) { }\n+\n+      ~deque() { }\n+#else\n+      deque() = default;\n+      deque(const deque&) = default;\n+      deque(deque&&) = default;\n+\n+      deque(initializer_list<value_type> __l,\n+\t    const allocator_type& __a = allocator_type())\n+      : _Base(__l, __a) { }\n+\n+      ~deque() = default;\n+#endif\n \n       explicit\n       deque(const _Allocator& __a)\n@@ -96,55 +120,35 @@ namespace __debug\n #else\n       template<class _InputIterator>\n #endif\n-        deque(_InputIterator __first, _InputIterator __last,\n+\tdeque(_InputIterator __first, _InputIterator __last,\n \t      const _Allocator& __a = _Allocator())\n \t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n \t\t\t\t\t\t\t\t     __last)),\n \t\t__gnu_debug::__base(__last), __a)\n-        { }\n-\n-      deque(const deque& __x)\n-      : _Base(__x) { }\n+\t{ }\n \n       deque(const _Base& __x)\n       : _Base(__x) { }\n \n-#if __cplusplus >= 201103L\n-      deque(deque&& __x)\n-      : _Base(std::move(__x))\n-      { this->_M_swap(__x); }\n-\n-      deque(initializer_list<value_type> __l,\n-\t    const allocator_type& __a = allocator_type())\n-      : _Base(__l, __a) { }\n-#endif\n-\n-      ~deque() _GLIBCXX_NOEXCEPT { }\n-\n+#if __cplusplus < 201103L\n       deque&\n       operator=(const deque& __x)\n       {\n-\t*static_cast<_Base*>(this) = __x;\n-\tthis->_M_invalidate_all();\n+\tthis->_M_safe() = __x;\n+\t_M_base() = __x;\n \treturn *this;\n       }\n+#else\n+      deque&\n+      operator=(const deque&) = default;\n \n-#if __cplusplus >= 201103L\n       deque&\n-      operator=(deque&& __x) noexcept\n-      {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\t__glibcxx_check_self_move_assign(__x);\n-\tclear();\n-\tswap(__x);\n-\treturn *this;\n-      }\n+      operator=(deque&&) = default;\n \n       deque&\n       operator=(initializer_list<value_type> __l)\n       {\n-\t*static_cast<_Base*>(this) = __l;\n+\t_M_base() = __l;\n \tthis->_M_invalidate_all();\n \treturn *this;\n       }\n@@ -156,9 +160,9 @@ namespace __debug\n #else\n       template<class _InputIterator>\n #endif\n-        void\n-        assign(_InputIterator __first, _InputIterator __last)\n-        {\n+\tvoid\n+\tassign(_InputIterator __first, _InputIterator __last)\n+\t{\n \t  __glibcxx_check_valid_range(__first, __last);\n \t  _Base::assign(__gnu_debug::__base(__first),\n \t\t\t__gnu_debug::__base(__last));\n@@ -241,7 +245,7 @@ namespace __debug\n \ttypedef __gnu_debug::_After_nth_from<_Base_const_iterator> _After_nth;\n \tthis->_M_invalidate_if(_After_nth(__n, _Base::begin()));\n       }\n-      \n+\n     public:\n       // 23.2.1.2 capacity:\n       using _Base::size;\n@@ -369,24 +373,24 @@ namespace __debug\n       { emplace_back(std::move(__x)); }\n \n       template<typename... _Args>\n-        void\n-        emplace_front(_Args&&... __args)\n+\tvoid\n+\templace_front(_Args&&... __args)\n \t{\n \t  _Base::emplace_front(std::forward<_Args>(__args)...);\n \t  this->_M_invalidate_all();\n \t}\n \n       template<typename... _Args>\n-        void\n-        emplace_back(_Args&&... __args)\n+\tvoid\n+\templace_back(_Args&&... __args)\n \t{\n \t  _Base::emplace_back(std::forward<_Args>(__args)...);\n \t  this->_M_invalidate_all();\n \t}\n \n       template<typename... _Args>\n-        iterator\n-        emplace(const_iterator __position, _Args&&... __args)\n+\titerator\n+\templace(const_iterator __position, _Args&&... __args)\n \t{\n \t  __glibcxx_check_insert(__position);\n \t  _Base_iterator __res = _Base::emplace(__position.base(),\n@@ -447,9 +451,9 @@ namespace __debug\n       template<class _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n \titerator\n-        insert(const_iterator __position,\n+\tinsert(const_iterator __position,\n \t       _InputIterator __first, _InputIterator __last)\n-        {\n+\t{\n \t  __glibcxx_check_insert_range(__position, __first, __last);\n \t  _Base_iterator __res = _Base::insert(__position.base(),\n \t\t\t\t\t       __gnu_debug::__base(__first),\n@@ -459,10 +463,10 @@ namespace __debug\n \t}\n #else\n       template<class _InputIterator>\n-        void\n-        insert(iterator __position,\n+\tvoid\n+\tinsert(iterator __position,\n \t       _InputIterator __first, _InputIterator __last)\n-        {\n+\t{\n \t  __glibcxx_check_insert_range(__position, __first, __last);\n \t  _Base::insert(__position.base(), __gnu_debug::__base(__first),\n \t\t\t\t\t   __gnu_debug::__base(__last));\n@@ -529,7 +533,7 @@ namespace __debug\n #else\n \t  return __first;\n #endif\n-        else if (__first.base() == _Base::begin()\n+\telse if (__first.base() == _Base::begin()\n \t\t || __last.base() == _Base::end())\n \t  {\n \t    this->_M_detach_singular();\n@@ -559,10 +563,13 @@ namespace __debug\n       }\n \n       void\n-      swap(deque& __x) _GLIBCXX_NOEXCEPT\n+      swap(deque& __x)\n+#if __cplusplus >= 201103L\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n+#endif\n       {\n+\t_Safe::_M_swap(__x);\n \t_Base::swap(__x);\n-\tthis->_M_swap(__x);\n       }\n \n       void\n@@ -573,10 +580,10 @@ namespace __debug\n       }\n \n       _Base&\n-      _M_base() _GLIBCXX_NOEXCEPT       { return *this; }\n+      _M_base() _GLIBCXX_NOEXCEPT\t{ return *this; }\n \n       const _Base&\n-      _M_base() const _GLIBCXX_NOEXCEPT { return *this; }\n+      _M_base() const _GLIBCXX_NOEXCEPT\t{ return *this; }\n     };\n \n   template<typename _Tp, typename _Alloc>"}, {"sha": "c67fb464860ce5ba29b84b7addc974b3712d574e", "filename": "libstdc++-v3/include/debug/forward_list", "status": "modified", "additions": 203, "deletions": 189, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fforward_list", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fforward_list", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fforward_list?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -33,142 +33,242 @@\n \n #include <forward_list>\n #include <debug/safe_sequence.h>\n+#include <debug/safe_container.h>\n #include <debug/safe_iterator.h>\n \n+namespace __gnu_debug\n+{\n+  /// Special iterators swap and invalidation for forward_list because of the\n+  /// before_begin iterator.\n+  template<typename _SafeSequence>\n+    class _Safe_forward_list\n+    : public _Safe_sequence<_SafeSequence>\n+    {\n+      _SafeSequence&\n+      _M_this() noexcept\n+      { return *static_cast<_SafeSequence*>(this); }\n+\n+      static void\n+      _M_swap_aux(_Safe_sequence_base& __lhs,\n+\t\t  _Safe_iterator_base*& __lhs_iterators,\n+\t\t  _Safe_sequence_base& __rhs,\n+\t\t  _Safe_iterator_base*& __rhs_iterators);\n+\n+      void _M_swap_single(_Safe_sequence_base&) noexcept;\n+\n+    protected:\n+      void\n+      _M_invalidate_all()\n+      {\n+\tusing _Base_const_iterator = __decltype(_M_this()._M_base().cend());\n+\tthis->_M_invalidate_if([this](_Base_const_iterator __it)\n+\t{\n+\t  return __it != _M_this()._M_base().cbefore_begin()\n+\t    && __it != _M_this()._M_base().cend(); });\n+      }\n+\n+      void _M_swap(_Safe_sequence_base&) noexcept;\n+    };\n+\n+   template<typename _SafeSequence>\n+    void\n+    _Safe_forward_list<_SafeSequence>::\n+    _M_swap_aux(_Safe_sequence_base& __lhs,\n+\t\t_Safe_iterator_base*& __lhs_iterators,\n+\t\t_Safe_sequence_base& __rhs,\n+\t\t_Safe_iterator_base*& __rhs_iterators)\n+    {\n+      using const_iterator = typename _SafeSequence::const_iterator;\n+      _Safe_iterator_base* __bbegin_its = 0;\n+      _Safe_iterator_base* __last_bbegin = 0;\n+      _SafeSequence& __rseq = static_cast<_SafeSequence&>(__rhs);\n+\n+      for (_Safe_iterator_base* __iter = __lhs_iterators; __iter;)\n+\t{\n+\t  // Even iterator is cast to const_iterator, not a problem.\n+\t  const_iterator* __victim = static_cast<const_iterator*>(__iter);\n+\t  __iter = __iter->_M_next;\n+\t  if (__victim->base() == __rseq._M_base().cbefore_begin())\n+\t    {\n+\t      __victim->_M_unlink();\n+\t      if (__lhs_iterators == __victim)\n+\t\t__lhs_iterators = __victim->_M_next;\n+\t      if (__bbegin_its)\n+\t\t{\n+\t\t  __victim->_M_next = __bbegin_its;\n+\t\t  __bbegin_its->_M_prior = __victim;\n+\t\t}\n+\t      else\n+\t\t__last_bbegin = __victim;\n+\t      __bbegin_its = __victim;\n+\t    }\n+\t  else\n+\t    __victim->_M_sequence = &__lhs;\n+\t}\n+\n+      if (__bbegin_its)\n+\t{\n+\t  if (__rhs_iterators)\n+\t    {\n+\t      __rhs_iterators->_M_prior = __last_bbegin;\n+\t      __last_bbegin->_M_next = __rhs_iterators;\n+\t    }\n+\t  __rhs_iterators = __bbegin_its;\n+\t}\n+    }\n+\n+   template<typename _SafeSequence>\n+    void\n+    _Safe_forward_list<_SafeSequence>::\n+    _M_swap_single(_Safe_sequence_base& __other) noexcept\n+    {\n+      std::swap(_M_this()._M_iterators, __other._M_iterators);\n+      std::swap(_M_this()._M_const_iterators, __other._M_const_iterators);\n+      // Useless, always 1 on forward_list\n+      //std::swap(_M_this()_M_version, __other._M_version);\n+      _Safe_iterator_base* __this_its = _M_this()._M_iterators;\n+      _M_swap_aux(__other, __other._M_iterators,\n+\t\t  _M_this(), _M_this()._M_iterators);\n+      _Safe_iterator_base* __this_const_its = _M_this()._M_const_iterators;\n+      _M_swap_aux(__other, __other._M_const_iterators,\n+\t\t  _M_this(), _M_this()._M_const_iterators);\n+      _M_swap_aux(_M_this(), __this_its,\n+\t\t  __other, __other._M_iterators);\n+      _M_swap_aux(_M_this(), __this_const_its,\n+\t\t  __other, __other._M_const_iterators);\n+    }\n+\n+  /* Special forward_list _M_swap version that does not swap the\n+   * before-begin ownership.*/\n+   template<typename _SafeSequence>\n+    void\n+    _Safe_forward_list<_SafeSequence>::\n+    _M_swap(_Safe_sequence_base& __other) noexcept\n+    {\n+      // We need to lock both sequences to swap\n+      using namespace __gnu_cxx;\n+      __mutex *__this_mutex = &_M_this()._M_get_mutex();\n+      __mutex *__other_mutex =\n+\t&static_cast<_SafeSequence&>(__other)._M_get_mutex();\n+      if (__this_mutex == __other_mutex)\n+\t{\n+\t  __scoped_lock __lock(*__this_mutex);\n+\t  _M_swap_single(__other);\n+\t}\n+      else\n+\t{\n+\t  __scoped_lock __l1(__this_mutex < __other_mutex\n+\t\t\t     ? *__this_mutex : *__other_mutex);\n+\t  __scoped_lock __l2(__this_mutex < __other_mutex\n+\t\t\t     ? *__other_mutex : *__this_mutex);\n+\t  _M_swap_single(__other);\n+\t}\n+    }\n+}\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n namespace __debug\n {\n   /// Class std::forward_list with safety/checking/debug instrumentation.\n   template<typename _Tp, typename _Alloc = std::allocator<_Tp> >\n     class forward_list\n-    : public _GLIBCXX_STD_C::forward_list<_Tp, _Alloc>,\n-      public __gnu_debug::_Safe_sequence<forward_list<_Tp, _Alloc> >\n+    : public __gnu_debug::_Safe_container<\n+\tforward_list<_Tp, _Alloc>, _Alloc, __gnu_debug::_Safe_forward_list>,\n+      public _GLIBCXX_STD_C::forward_list<_Tp, _Alloc>\n     {\n-      typedef _GLIBCXX_STD_C::forward_list<_Tp, _Alloc> _Base;\n-\n-      typedef typename _Base::iterator       _Base_iterator;\n-      typedef typename _Base::const_iterator _Base_const_iterator;\n-\n-      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n-        rebind<_GLIBCXX_STD_C::_Fwd_list_node<_Tp>>::other _Node_alloc_type;\n+      typedef _GLIBCXX_STD_C::forward_list<_Tp, _Alloc>\t\t_Base;\n+      typedef __gnu_debug::_Safe_container<\n+\tforward_list, _Alloc, __gnu_debug::_Safe_forward_list>\t_Safe;\n \n-      typedef __gnu_cxx::__alloc_traits<_Node_alloc_type> _Node_alloc_traits;\n+      typedef typename _Base::iterator\t\t_Base_iterator;\n+      typedef typename _Base::const_iterator\t_Base_const_iterator;\n \n     public:\n-      typedef typename _Base::reference             reference;\n-      typedef typename _Base::const_reference       const_reference;\n+      typedef typename _Base::reference\t\treference;\n+      typedef typename _Base::const_reference\tconst_reference;\n \n-      typedef __gnu_debug::_Safe_iterator<_Base_iterator,\n-\t\t\t\t\t  forward_list> iterator;\n-      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n-\t\t\t\t\t  forward_list> const_iterator;\n+      typedef __gnu_debug::_Safe_iterator<\n+\t_Base_iterator, forward_list>\t\titerator;\n+      typedef __gnu_debug::_Safe_iterator<\n+\t_Base_const_iterator, forward_list>\tconst_iterator;\n \n-      typedef typename _Base::size_type             size_type;\n-      typedef typename _Base::difference_type       difference_type;\n+      typedef typename _Base::size_type\t\tsize_type;\n+      typedef typename _Base::difference_type\tdifference_type;\n \n-      typedef _Tp                                   value_type;\n-      typedef _Alloc                                allocator_type;\n-      typedef typename _Base::pointer               pointer;\n-      typedef typename _Base::const_pointer         const_pointer;\n+      typedef _Tp\t\t\t\tvalue_type;\n+      typedef typename _Base::allocator_type\tallocator_type;\n+      typedef typename _Base::pointer\t\tpointer;\n+      typedef typename _Base::const_pointer\tconst_pointer;\n \n       // 23.2.3.1 construct/copy/destroy:\n       explicit\n-      forward_list(const _Alloc& __al = _Alloc())\n+      forward_list(const allocator_type& __al = allocator_type())\n       : _Base(__al) { }\n \n-      forward_list(const forward_list& __list, const _Alloc& __al)\n+      forward_list(const forward_list& __list, const allocator_type& __al)\n       : _Base(__list, __al)\n       { }\n \n-      forward_list(forward_list&& __list, const _Alloc& __al)\n-      : _Base(std::move(__list._M_base()), __al)\n-      {\n-\tif (__list.get_allocator() == __al)\n-\t  this->_M_swap(__list);\n-\telse\n-\t  __list._M_invalidate_all();\n-      }\n+      forward_list(forward_list&& __list, const allocator_type& __al)\n+\t: _Safe(std::move(__list._M_safe()), __al),\n+\t  _Base(std::move(__list._M_base()), __al)\n+      { }\n \n       explicit\n-      forward_list(size_type __n, const _Alloc& __al = _Alloc())\n+      forward_list(size_type __n, const allocator_type& __al = allocator_type())\n       : _Base(__n, __al)\n       { }\n \n       forward_list(size_type __n, const _Tp& __value,\n-                   const _Alloc& __al = _Alloc())\n+\t\t   const allocator_type& __al = allocator_type())\n       : _Base(__n, __value, __al)\n       { }\n \n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n \tforward_list(_InputIterator __first, _InputIterator __last,\n-                     const _Alloc& __al = _Alloc())\n-        : _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n+\t\t     const allocator_type& __al = allocator_type())\n+\t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n \t\t\t\t\t\t\t\t     __last)),\n \t\t__gnu_debug::__base(__last), __al)\n-        { }\n+\t{ }\n \n-      forward_list(const forward_list& __list)\n-      : _Base(__list)\n-      { }\n+      forward_list(const forward_list&) = default;\n \n-      forward_list(forward_list&& __list) noexcept\n-      : _Base(std::move(__list._M_base()))\n-      {\n-\tthis->_M_swap(__list);\n-      }\n+      forward_list(forward_list&&) = default;\n \n       forward_list(std::initializer_list<_Tp> __il,\n-                   const _Alloc& __al = _Alloc())\n+\t\t   const allocator_type& __al = allocator_type())\n       : _Base(__il, __al)\n       { }\n \n-      ~forward_list() noexcept\n-      { }\n+      ~forward_list() = default;\n \n       forward_list&\n-      operator=(const forward_list& __list)\n-      {\n-\tstatic_cast<_Base&>(*this) = __list;\n-\tthis->_M_invalidate_all();\n-\treturn *this;\n-      }\n+      operator=(const forward_list&) = default;\n \n       forward_list&\n-      operator=(forward_list&& __list)\n-      noexcept(_Node_alloc_traits::_S_nothrow_move())\n-      {\n-\t__glibcxx_check_self_move_assign(__list);\n-\tbool __xfer_memory = _Node_alloc_traits::_S_propagate_on_move_assign()\n-\t    || __list.get_allocator() == this->get_allocator();\n-\tstatic_cast<_Base&>(*this) = std::move(__list);\n-\tif (__xfer_memory)\n-\t  this->_M_swap(__list);\n-\telse\n-\t  this->_M_invalidate_all();\n-\t__list._M_invalidate_all();\n-\treturn *this;\n-      }\n+      operator=(forward_list&&) = default;\n \n       forward_list&\n       operator=(std::initializer_list<_Tp> __il)\n       {\n-\tstatic_cast<_Base&>(*this) = __il;\n+\t_M_base() = __il;\n \tthis->_M_invalidate_all();\n-        return *this;\n+\treturn *this;\n       }\n \n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n \tvoid\n-        assign(_InputIterator __first, _InputIterator __last)\n-        {\n+\tassign(_InputIterator __first, _InputIterator __last)\n+\t{\n \t  __glibcxx_check_valid_range(__first, __last);\n \t  _Base::assign(__gnu_debug::__base(__first),\n \t\t\t__gnu_debug::__base(__last));\n \t  this->_M_invalidate_all();\n-        }\n+\t}\n \n       void\n       assign(size_type __n, const _Tp& __val)\n@@ -292,16 +392,16 @@ namespace __debug\n \n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n-        iterator\n-        insert_after(const_iterator __pos,\n-                     _InputIterator __first, _InputIterator __last)\n-        {\n+\titerator\n+\tinsert_after(const_iterator __pos,\n+\t\t     _InputIterator __first, _InputIterator __last)\n+\t{\n \t  __glibcxx_check_insert_range_after(__pos, __first, __last);\n \t  return iterator(_Base::insert_after(__pos.base(),\n \t\t\t\t\t      __gnu_debug::__base(__first),\n \t\t\t\t\t      __gnu_debug::__base(__last)),\n \t\t\t  this);\n-        }\n+\t}\n \n       iterator\n       insert_after(const_iterator __pos, std::initializer_list<_Tp> __il)\n@@ -347,12 +447,10 @@ namespace __debug\n \n       void\n       swap(forward_list& __list)\n-      noexcept(_Node_alloc_traits::_S_nothrow_swap())\n+\tnoexcept( noexcept(declval<_Base>().swap(__list)) )\n       {\n-\tif (!_Node_alloc_traits::_S_propagate_on_swap())\n-\t  __glibcxx_check_equal_allocs(__list);\n+\t_Safe::_M_swap(__list);\n \t_Base::swap(__list);\n-\tthis->_M_swap(__list);\n       }\n \n       void\n@@ -380,7 +478,7 @@ namespace __debug\n \t  {\n \t    this->_M_revalidate_singular();\n \t    __throw_exception_again;\n-          }\n+\t  }\n       }\n \n       void\n@@ -408,7 +506,7 @@ namespace __debug\n \t  {\n \t    this->_M_revalidate_singular();\n \t    __throw_exception_again;\n-          }\n+\t  }\n       }\n \n       void\n@@ -422,7 +520,7 @@ namespace __debug\n       void\n       splice_after(const_iterator __pos, forward_list&& __list)\n       {\n-        __glibcxx_check_insert_after(__pos);\n+\t__glibcxx_check_insert_after(__pos);\n \t_GLIBCXX_DEBUG_VERIFY(&__list != this,\n \t\t\t      _M_message(__gnu_debug::__msg_self_splice)\n \t\t\t      ._M_sequence(*this, \"this\"));\n@@ -477,7 +575,7 @@ namespace __debug\n       splice_after(const_iterator __pos, forward_list&& __list,\n \t\t   const_iterator __before, const_iterator __last)\n       {\n-        __glibcxx_check_insert_after(__pos);\n+\t__glibcxx_check_insert_after(__pos);\n \t__glibcxx_check_valid_range(__before, __last);\n \t_GLIBCXX_DEBUG_VERIFY(__before._M_attached_to(&__list),\n \t\t\t      _M_message(__gnu_debug::__msg_splice_other)\n@@ -508,8 +606,8 @@ namespace __debug\n \t\t\t\t  ._M_iterator(__before, \"before\")\n \t\t\t\t  ._M_iterator(__last, \"last\"));\n \t    _GLIBCXX_DEBUG_VERIFY(&__list != this || __tmp != __pos.base(),\n-                                  _M_message(__gnu_debug::__msg_splice_overlap)\n-                                  ._M_iterator(__tmp, \"position\")\n+\t\t\t\t  _M_message(__gnu_debug::__msg_splice_overlap)\n+\t\t\t\t  ._M_iterator(__tmp, \"position\")\n \t\t\t\t  ._M_iterator(__before, \"before\")\n \t\t\t\t  ._M_iterator(__last, \"last\"));\n \t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -542,8 +640,8 @@ namespace __debug\n       }\n \n       template<typename _Pred>\n-        void\n-        remove_if(_Pred __pred)\n+\tvoid\n+\tremove_if(_Pred __pred)\n \t{\n \t  _Base_iterator __x = _Base::before_begin();\n \t  _Base_iterator __old = __x++;\n@@ -574,8 +672,8 @@ namespace __debug\n       }\n \n       template<typename _BinPred>\n-        void\n-        unique(_BinPred __binary_pred)\n+\tvoid\n+\tunique(_BinPred __binary_pred)\n \t{\n \t  _Base_iterator __first = _Base::begin();\n \t  _Base_iterator __last = _Base::end();\n@@ -613,8 +711,8 @@ namespace __debug\n       { merge(std::move(__list)); }\n \n       template<typename _Comp>\n-        void\n-        merge(forward_list&& __list, _Comp __comp)\n+\tvoid\n+\tmerge(forward_list&& __list, _Comp __comp)\n \t{\n \t  if (this != &__list)\n \t  {\n@@ -624,149 +722,65 @@ namespace __debug\n \t    this->_M_transfer_from_if(__list,\n \t\t\t\t      [&__list](_Base_const_iterator __it)\n \t      {\n-\t        return __it != __list._M_base().cbefore_begin()\n+\t\treturn __it != __list._M_base().cbefore_begin()\n \t\t       && __it != __list._M_base().cend();\n \t      });\n \t    _Base::merge(std::move(__list._M_base()), __comp);\n \t  }\n \t}\n \n       template<typename _Comp>\n-        void\n-        merge(forward_list& __list, _Comp __comp)\n-        { merge(std::move(__list), __comp); }\n+\tvoid\n+\tmerge(forward_list& __list, _Comp __comp)\n+\t{ merge(std::move(__list), __comp); }\n \n       using _Base::sort;\n       using _Base::reverse;\n \n       _Base&\n-      _M_base() noexcept       { return *this; }\n+      _M_base() noexcept { return *this; }\n \n       const _Base&\n       _M_base() const noexcept { return *this; }\n-\n-    private:\n-      void\n-      _M_invalidate_all()\n-      {\n-\tthis->_M_invalidate_if([this](_Base_const_iterator __it)\n-\t  {\n-\t    return __it != this->_M_base().cbefore_begin()\n-\t\t   && __it != this->_M_base().cend();\n-\t  });\n-      }\n-      typedef __gnu_debug::_Safe_iterator_base _Safe_iterator_base;\n-      static void\n-      _M_swap_aux(forward_list& __lhs,\n-\t\t  _Safe_iterator_base*& __lhs_iterators,\n-\t\t  forward_list& __rhs,\n-\t\t  _Safe_iterator_base*& __rhs_iterators);\n-      void _M_swap(forward_list& __list);\n     };\n \n-   template<typename _Tp, typename _Alloc>\n-    void\n-    forward_list<_Tp, _Alloc>::\n-    _M_swap_aux(forward_list<_Tp, _Alloc>& __lhs,\n-\t\t__gnu_debug::_Safe_iterator_base*& __lhs_iterators,\n-\t\tforward_list<_Tp, _Alloc>& __rhs,\n-\t\t__gnu_debug::_Safe_iterator_base*& __rhs_iterators)\n-    {\n-      using __gnu_debug::_Safe_iterator_base;\n-      _Safe_iterator_base* __bbegin_its = 0;\n-      _Safe_iterator_base* __last_bbegin = 0;\n-      for (_Safe_iterator_base* __iter = __lhs_iterators; __iter;)\n-\t{\n-\t  // Even iterator are casted to const_iterator, not a problem.\n-\t  const_iterator* __victim = static_cast<const_iterator*>(__iter);\n-\t  __iter = __iter->_M_next;\n-\t  if (__victim->base() == __rhs._M_base().cbefore_begin())\n-\t    {\n-\t      __victim->_M_unlink();\n-\t      if (__lhs_iterators == __victim)\n-\t\t__lhs_iterators = __victim->_M_next;\n-\t      if (__bbegin_its)\n-\t\t{\n-\t\t  __victim->_M_next = __bbegin_its;\n-\t\t  __bbegin_its->_M_prior = __victim;\n-\t\t}\n-\t      else\n-\t\t__last_bbegin = __victim;\n-\t      __bbegin_its = __victim;\n-\t    }\n-\t  else\n-\t    __victim->_M_sequence = &__lhs;\n-\t}\n-\n-      if (__bbegin_its)\n-\t{\n-\t  if (__rhs_iterators)\n-\t    {\n-\t      __rhs_iterators->_M_prior = __last_bbegin;\n-\t      __last_bbegin->_M_next = __rhs_iterators;\n-\t    }\n-\t  __rhs_iterators = __bbegin_its;\n-\t}\n-    }\n-\n-  /* Special forward_list _M_swap version that do not swap the\n-   * before-begin ownership.*/\n-  template<typename _Tp, typename _Alloc>\n-    void\n-    forward_list<_Tp, _Alloc>::\n-    _M_swap(forward_list<_Tp, _Alloc>& __list)\n-    {\n-      __gnu_cxx::__scoped_lock sentry(this->_M_get_mutex());\n-      std::swap(this->_M_iterators, __list._M_iterators);\n-      std::swap(this->_M_const_iterators, __list._M_const_iterators);\n-      // Useless, always 1 on forward_list\n-      //std::swap(this->_M_version, __list._M_version);\n-      _Safe_iterator_base* __this_its = this->_M_iterators;\n-      _M_swap_aux(__list, __list._M_iterators, *this, this->_M_iterators);\n-      _Safe_iterator_base* __this_const_its = this->_M_const_iterators;\n-      _M_swap_aux(__list, __list._M_const_iterators, *this,\n-\t\t  this->_M_const_iterators);\n-      _M_swap_aux(*this, __this_its, __list, __list._M_iterators);\n-      _M_swap_aux(*this, __this_const_its, __list, __list._M_const_iterators);\n-    }\n-\n   template<typename _Tp, typename _Alloc>\n     bool\n     operator==(const forward_list<_Tp, _Alloc>& __lx,\n-               const forward_list<_Tp, _Alloc>& __ly)\n+\t       const forward_list<_Tp, _Alloc>& __ly)\n     { return __lx._M_base() == __ly._M_base(); }\n \n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator<(const forward_list<_Tp, _Alloc>& __lx,\n-              const forward_list<_Tp, _Alloc>& __ly)\n+\t      const forward_list<_Tp, _Alloc>& __ly)\n     { return __lx._M_base() < __ly._M_base(); }\n \n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator!=(const forward_list<_Tp, _Alloc>& __lx,\n-               const forward_list<_Tp, _Alloc>& __ly)\n+\t       const forward_list<_Tp, _Alloc>& __ly)\n     { return !(__lx == __ly); }\n \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>(const forward_list<_Tp, _Alloc>& __lx,\n-              const forward_list<_Tp, _Alloc>& __ly)\n+\t      const forward_list<_Tp, _Alloc>& __ly)\n     { return (__ly < __lx); }\n \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>=(const forward_list<_Tp, _Alloc>& __lx,\n-               const forward_list<_Tp, _Alloc>& __ly)\n+\t       const forward_list<_Tp, _Alloc>& __ly)\n     { return !(__lx < __ly); }\n \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator<=(const forward_list<_Tp, _Alloc>& __lx,\n-               const forward_list<_Tp, _Alloc>& __ly)\n+\t       const forward_list<_Tp, _Alloc>& __ly)\n     { return !(__ly < __lx); }\n \n   /// See std::forward_list::swap()."}, {"sha": "2454ecc5458f658e3bb17e8f23241d8085b4d4e3", "filename": "libstdc++-v3/include/debug/list", "status": "modified", "additions": 89, "deletions": 96, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -31,6 +31,7 @@\n \n #include <list>\n #include <debug/safe_sequence.h>\n+#include <debug/safe_container.h>\n #include <debug/safe_iterator.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -40,39 +41,61 @@ namespace __debug\n   /// Class std::list with safety/checking/debug instrumentation.\n   template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n     class list\n-    : public _GLIBCXX_STD_C::list<_Tp, _Allocator>,\n-      public __gnu_debug::_Safe_sequence<list<_Tp, _Allocator> >\n+    : public __gnu_debug::_Safe_container<\n+\tlist<_Tp, _Allocator>, _Allocator,\n+\t__gnu_debug::_Safe_node_sequence, false>,\n+      public _GLIBCXX_STD_C::list<_Tp, _Allocator>\n     {\n-      typedef _GLIBCXX_STD_C::list<_Tp, _Allocator> _Base;\n+      typedef _GLIBCXX_STD_C::list<_Tp, _Allocator>\t\t\t_Base;\n+      typedef __gnu_debug::_Safe_container<\n+\tlist, _Allocator, __gnu_debug::_Safe_node_sequence, false>\t_Safe;\n+\n+      typedef typename _Base::iterator\t\t_Base_iterator;\n+      typedef typename _Base::const_iterator\t_Base_const_iterator;\n+      typedef __gnu_debug::_Equal_to<_Base_const_iterator>\t_Equal;\n+      typedef __gnu_debug::_Not_equal_to<_Base_const_iterator>  _Not_equal;\n \n-      typedef typename _Base::iterator       _Base_iterator;\n-      typedef typename _Base::const_iterator _Base_const_iterator;\n-      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n-      typedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n     public:\n-      typedef typename _Base::reference             reference;\n-      typedef typename _Base::const_reference       const_reference;\n+      typedef typename _Base::reference\t\t\treference;\n+      typedef typename _Base::const_reference\t\tconst_reference;\n \n       typedef __gnu_debug::_Safe_iterator<_Base_iterator, list>\n-\t\t\t\t\t\t    iterator;\n+\t\t\t\t\t\t\titerator;\n       typedef __gnu_debug::_Safe_iterator<_Base_const_iterator, list>\n-\t\t\t\t\t\t    const_iterator;\n+\t\t\t\t\t\t\tconst_iterator;\n \n-      typedef typename _Base::size_type             size_type;\n-      typedef typename _Base::difference_type       difference_type;\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::difference_type\t\tdifference_type;\n \n-      typedef _Tp\t\t\t\t    value_type;\n-      typedef _Allocator\t\t\t    allocator_type;\n-      typedef typename _Base::pointer               pointer;\n-      typedef typename _Base::const_pointer         const_pointer;\n-      typedef std::reverse_iterator<iterator>       reverse_iterator;\n-      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+      typedef _Tp\t\t\t\t\tvalue_type;\n+      typedef _Allocator\t\t\t\tallocator_type;\n+      typedef typename _Base::pointer\t\t\tpointer;\n+      typedef typename _Base::const_pointer\t\tconst_pointer;\n+      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n \n       // 23.2.2.1 construct/copy/destroy:\n \n-      list() _GLIBCXX_NOEXCEPT\n+#if __cplusplus < 201103L\n+      list()\n       : _Base() { }\n \n+      list(const list& __x)\n+      : _Base(__x) { }\n+\n+      ~list() { }\n+#else\n+      list() = default;\n+      list(const list&) = default;\n+      list(list&&) = default;\n+\n+      list(initializer_list<value_type> __l,\n+\t   const allocator_type& __a = allocator_type())\n+      : _Base(__l, __a) { }\n+\n+      ~list() = default;\n+#endif\n+\n       explicit\n       list(const _Allocator& __a) _GLIBCXX_NOEXCEPT\n       : _Base(__a) { }\n@@ -103,51 +126,31 @@ namespace __debug\n \t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n \t\t\t\t\t\t\t\t     __last)),\n \t\t__gnu_debug::__base(__last), __a)\n-        { }\n-\n-      list(const list& __x)\n-      : _Base(__x) { }\n+\t{ }\n \n       list(const _Base& __x)\n       : _Base(__x) { }\n \n-#if __cplusplus >= 201103L\n-      list(list&& __x) noexcept\n-      : _Base(std::move(__x))\n-      { this->_M_swap(__x); }\n-\n-      list(initializer_list<value_type> __l,\n-           const allocator_type& __a = allocator_type())\n-        : _Base(__l, __a) { }\n-#endif\n-\n-      ~list() _GLIBCXX_NOEXCEPT { }\n-\n+#if __cplusplus < 201103L\n       list&\n       operator=(const list& __x)\n       {\n-\tstatic_cast<_Base&>(*this) = __x;\n-\tthis->_M_invalidate_all();\n+\tthis->_M_safe() = __x;\n+\t_M_base() = __x;\n \treturn *this;\n       }\n+#else\n+      list&\n+      operator=(const list&) = default;\n \n-#if __cplusplus >= 201103L\n       list&\n-      operator=(list&& __x)\n-      {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\t__glibcxx_check_self_move_assign(__x);\n-\tclear();\n-\tswap(__x);\n-      \treturn *this;\n-      }\n+      operator=(list&&) = default;\n \n       list&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tstatic_cast<_Base&>(*this) = __l;\n \tthis->_M_invalidate_all();\n+\t_M_base() = __l;\n \treturn *this;\n       }\n \n@@ -165,9 +168,9 @@ namespace __debug\n #else\n       template<class _InputIterator>\n #endif\n-        void\n-        assign(_InputIterator __first, _InputIterator __last)\n-        {\n+\tvoid\n+\tassign(_InputIterator __first, _InputIterator __last)\n+\t{\n \t  __glibcxx_check_valid_range(__first, __last);\n \t  _Base::assign(__gnu_debug::__base(__first),\n \t\t\t__gnu_debug::__base(__last));\n@@ -245,16 +248,14 @@ namespace __debug\n       {\n \tthis->_M_detach_singular();\n \n-\t// if __sz < size(), invalidate all iterators in [begin+__sz, end())\n+\t// if __sz < size(), invalidate all iterators in [begin + __sz, end())\n \t_Base_iterator __victim = _Base::begin();\n \t_Base_iterator __end = _Base::end();\n \tfor (size_type __i = __sz; __victim != __end && __i > 0; --__i)\n \t  ++__victim;\n \n \tfor (; __victim != __end; ++__victim)\n-\t  {\n-\t    this->_M_invalidate_if(_Equal(__victim));\n-\t  }\n+\t  this->_M_invalidate_if(_Equal(__victim));\n \n \t__try\n \t  {\n@@ -272,16 +273,14 @@ namespace __debug\n       {\n \tthis->_M_detach_singular();\n \n-\t// if __sz < size(), invalidate all iterators in [begin+__sz, end())\n+\t// if __sz < size(), invalidate all iterators in [begin + __sz, end())\n \t_Base_iterator __victim = _Base::begin();\n \t_Base_iterator __end = _Base::end();\n \tfor (size_type __i = __sz; __victim != __end && __i > 0; --__i)\n \t  ++__victim;\n \n \tfor (; __victim != __end; ++__victim)\n-\t  {\n-\t    this->_M_invalidate_if(_Equal(__victim));\n-\t  }\n+\t  this->_M_invalidate_if(_Equal(__victim));\n \n \t__try\n \t  {\n@@ -299,16 +298,14 @@ namespace __debug\n       {\n \tthis->_M_detach_singular();\n \n-\t// if __sz < size(), invalidate all iterators in [begin+__sz, end())\n+\t// if __sz < size(), invalidate all iterators in [begin + __sz, end())\n \t_Base_iterator __victim = _Base::begin();\n \t_Base_iterator __end = _Base::end();\n \tfor (size_type __i = __sz; __victim != __end && __i > 0; --__i)\n \t  ++__victim;\n \n \tfor (; __victim != __end; ++__victim)\n-\t  {\n-\t    this->_M_invalidate_if(_Equal(__victim));\n-\t  }\n+\t  this->_M_invalidate_if(_Equal(__victim));\n \n \t__try\n \t  {\n@@ -382,8 +379,8 @@ namespace __debug\n \n #if __cplusplus >= 201103L\n       template<typename... _Args>\n-        iterator\n-        emplace(const_iterator __position, _Args&&... __args)\n+\titerator\n+\templace(const_iterator __position, _Args&&... __args)\n \t{\n \t  __glibcxx_check_insert(__position);\n \t  return iterator(_Base::emplace(__position.base(),\n@@ -435,9 +432,9 @@ namespace __debug\n       template<class _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n \titerator\n-        insert(const_iterator __position, _InputIterator __first,\n+\tinsert(const_iterator __position, _InputIterator __first,\n \t       _InputIterator __last)\n-        {\n+\t{\n \t  __glibcxx_check_insert_range(__position, __first, __last);\n \t  return iterator(_Base::insert(__position.base(),\n \t\t\t\t\t__gnu_debug::__base(__first),\n@@ -447,9 +444,9 @@ namespace __debug\n #else\n       template<class _InputIterator>\n \tvoid\n-        insert(iterator __position, _InputIterator __first,\n+\tinsert(iterator __position, _InputIterator __first,\n \t       _InputIterator __last)\n-        {\n+\t{\n \t  __glibcxx_check_insert_range(__position, __first, __last);\n \t  _Base::insert(__position.base(), __gnu_debug::__base(__first),\n \t\t\t\t\t   __gnu_debug::__base(__last));\n@@ -494,7 +491,7 @@ namespace __debug\n \t     __victim != __last.base(); ++__victim)\n \t  {\n \t    _GLIBCXX_DEBUG_VERIFY(__victim != _Base::end(),\n-\t\t\t          _M_message(__gnu_debug::__msg_valid_range)\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n \t\t\t\t  ._M_iterator(__first, \"position\")\n \t\t\t\t  ._M_iterator(__last, \"last\"));\n \t    this->_M_invalidate_if(_Equal(__victim));\n@@ -504,9 +501,12 @@ namespace __debug\n \n       void\n       swap(list& __x)\n+#if __cplusplus >= 201103L\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n+#endif\n       {\n+\t_Safe::_M_swap(__x);\n \t_Base::swap(__x);\n-\tthis->_M_swap(__x);\n       }\n \n       void\n@@ -629,9 +629,9 @@ namespace __debug\n       }\n \n       template<class _Predicate>\n-        void\n-        remove_if(_Predicate __pred)\n-        {\n+\tvoid\n+\tremove_if(_Predicate __pred)\n+\t{\n \t  for (_Base_iterator __x = _Base::begin(); __x != _Base::end(); )\n \t    {\n \t      if (__pred(*__x))\n@@ -659,9 +659,9 @@ namespace __debug\n       }\n \n       template<class _BinaryPredicate>\n-        void\n-        unique(_BinaryPredicate __binary_pred)\n-        {\n+\tvoid\n+\tunique(_BinaryPredicate __binary_pred)\n+\t{\n \t  _Base_iterator __first = _Base::begin();\n \t  _Base_iterator __last = _Base::end();\n \t  if (__first == __last)\n@@ -701,13 +701,13 @@ namespace __debug\n #endif\n \n       template<class _Compare>\n-        void\n+\tvoid\n #if __cplusplus >= 201103L\n-        merge(list&& __x, _Compare __comp)\n+\tmerge(list&& __x, _Compare __comp)\n #else\n-        merge(list& __x, _Compare __comp)\n+\tmerge(list& __x, _Compare __comp)\n #endif\n-        {\n+\t{\n \t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t  // 300. list::merge() specification incomplete\n \t  if (this != &__x)\n@@ -723,32 +723,25 @@ namespace __debug\n \n #if __cplusplus >= 201103L\n       template<typename _Compare>\n-        void\n-        merge(list& __x, _Compare __comp)\n-        { merge(std::move(__x), __comp); }\n+\tvoid\n+\tmerge(list& __x, _Compare __comp)\n+\t{ merge(std::move(__x), __comp); }\n #endif\n \n       void\n       sort() { _Base::sort(); }\n \n       template<typename _StrictWeakOrdering>\n-        void\n-        sort(_StrictWeakOrdering __pred) { _Base::sort(__pred); }\n+\tvoid\n+\tsort(_StrictWeakOrdering __pred) { _Base::sort(__pred); }\n \n       using _Base::reverse;\n \n       _Base&\n-      _M_base() _GLIBCXX_NOEXCEPT       { return *this; }\n+      _M_base() _GLIBCXX_NOEXCEPT\t{ return *this; }\n \n       const _Base&\n-      _M_base() const _GLIBCXX_NOEXCEPT { return *this; }\n-\n-    private:\n-      void\n-      _M_invalidate_all()\n-      {\n-\tthis->_M_invalidate_if(_Not_equal(_Base::end()));\n-      }\n+      _M_base() const _GLIBCXX_NOEXCEPT\t{ return *this; }\n     };\n \n   template<typename _Tp, typename _Alloc>"}, {"sha": "8e07aec2fe1a97b6c141ed130dd32f44cce91951", "filename": "libstdc++-v3/include/debug/macros.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmacros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmacros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmacros.h?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -347,10 +347,10 @@ _GLIBCXX_DEBUG_VERIFY(_F > 0.0f,\t\t\t\t\t\\\n \t\t      _M_message(__gnu_debug::__msg_valid_load_factor)\t\\\n                       ._M_sequence(*this, \"this\"))\n \n-#define __glibcxx_check_equal_allocs(_Other)\t\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(this->get_allocator() == _Other.get_allocator(),\t\\\n+#define __glibcxx_check_equal_allocs(_This, _Other)\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_This.get_allocator() == _Other.get_allocator(),\t\\\n \t\t      _M_message(__gnu_debug::__msg_equal_allocs)\t\\\n-\t\t      ._M_sequence(*this, \"this\"))\n+\t\t      ._M_sequence(_This, \"this\"))\n \n #ifdef _GLIBCXX_DEBUG_PEDANTIC\n #  define __glibcxx_check_string(_String) _GLIBCXX_DEBUG_ASSERT(_String != 0)"}, {"sha": "8baeb6fc2e5ee32dc00072881b35c1b3e28e5cad", "filename": "libstdc++-v3/include/debug/map.h", "status": "modified", "additions": 75, "deletions": 93, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -30,6 +30,7 @@\n #define _GLIBCXX_DEBUG_MAP_H 1\n \n #include <debug/safe_sequence.h>\n+#include <debug/safe_container.h>\n #include <debug/safe_iterator.h>\n #include <utility>\n \n@@ -41,69 +42,55 @@ namespace __debug\n   template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>,\n \t   typename _Allocator = std::allocator<std::pair<const _Key, _Tp> > >\n     class map\n-    : public _GLIBCXX_STD_C::map<_Key, _Tp, _Compare, _Allocator>,\n-      public __gnu_debug::_Safe_sequence<map<_Key, _Tp, _Compare, _Allocator> >\n+    : public __gnu_debug::_Safe_container<\n+\tmap<_Key, _Tp, _Compare, _Allocator>, _Allocator,\n+\t__gnu_debug::_Safe_node_sequence>,\n+      public _GLIBCXX_STD_C::map<_Key, _Tp, _Compare, _Allocator>\n     {\n-      typedef _GLIBCXX_STD_C::map<_Key, _Tp, _Compare, _Allocator> _Base;\n+      typedef _GLIBCXX_STD_C::map<\n+\t_Key, _Tp, _Compare, _Allocator>\t\t\t_Base;\n+      typedef __gnu_debug::_Safe_container<\n+\tmap, _Allocator, __gnu_debug::_Safe_node_sequence>\t_Safe;\n \n-      typedef typename _Base::const_iterator _Base_const_iterator;\n-      typedef typename _Base::iterator _Base_iterator;\n+      typedef typename _Base::const_iterator\t_Base_const_iterator;\n+      typedef typename _Base::iterator\t\t_Base_iterator;\n       typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n \n-#if __cplusplus >= 201103L\n-      typedef __gnu_cxx::__alloc_traits<typename\n-\t\t\t\t\t_Base::allocator_type> _Alloc_traits;\n-#endif\n     public:\n       // types:\n-      typedef _Key                                  key_type;\n-      typedef _Tp                                   mapped_type;\n-      typedef std::pair<const _Key, _Tp>            value_type;\n-      typedef _Compare                              key_compare;\n-      typedef _Allocator                            allocator_type;\n-      typedef typename _Base::reference             reference;\n-      typedef typename _Base::const_reference       const_reference;\n+      typedef _Key\t\t\t\t\tkey_type;\n+      typedef _Tp\t\t\t\t\tmapped_type;\n+      typedef std::pair<const _Key, _Tp>\t\tvalue_type;\n+      typedef _Compare\t\t\t\t\tkey_compare;\n+      typedef _Allocator\t\t\t\tallocator_type;\n+      typedef typename _Base::reference\t\t\treference;\n+      typedef typename _Base::const_reference\t\tconst_reference;\n \n       typedef __gnu_debug::_Safe_iterator<_Base_iterator, map>\n-                                                    iterator;\n+\t\t\t\t\t\t\titerator;\n       typedef __gnu_debug::_Safe_iterator<_Base_const_iterator, map>\n-                                                    const_iterator;\n+\t\t\t\t\t\t\tconst_iterator;\n \n-      typedef typename _Base::size_type             size_type;\n-      typedef typename _Base::difference_type       difference_type;\n-      typedef typename _Base::pointer               pointer;\n-      typedef typename _Base::const_pointer         const_pointer;\n-      typedef std::reverse_iterator<iterator>       reverse_iterator;\n-      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::difference_type\t\tdifference_type;\n+      typedef typename _Base::pointer\t\t\tpointer;\n+      typedef typename _Base::const_pointer\t\tconst_pointer;\n+      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n \n       // 23.3.1.1 construct/copy/destroy:\n \n+#if __cplusplus < 201103L\n       map() : _Base() { }\n \n-      explicit map(const _Compare& __comp,\n-\t\t   const _Allocator& __a = _Allocator())\n-      : _Base(__comp, __a) { }\n-\n-      template<typename _InputIterator>\n-        map(_InputIterator __first, _InputIterator __last,\n-\t    const _Compare& __comp = _Compare(),\n-\t    const _Allocator& __a = _Allocator())\n-\t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n-\t\t\t\t\t\t\t\t     __last)),\n-\t\t__gnu_debug::__base(__last),\n-\t\t__comp, __a) { }\n-\n       map(const map& __x)\n       : _Base(__x) { }\n \n-      map(const _Base& __x)\n-      : _Base(__x) { }\n-\n-#if __cplusplus >= 201103L\n-      map(map&& __x)\n-      noexcept(is_nothrow_copy_constructible<_Compare>::value)\n-      : _Base(std::move(__x))\n-      { this->_M_swap(__x); }\n+      ~map() { }\n+#else\n+      map() = default;\n+      map(const map&) = default;\n+      map(map&&) = default;\n \n       map(initializer_list<value_type> __l,\n \t  const _Compare& __c = _Compare(),\n@@ -118,46 +105,53 @@ namespace __debug\n       : _Base(__m, __a) { }\n \n       map(map&& __m, const allocator_type& __a)\n-      : _Base(std::move(__m._M_base()), __a) { }\n+      : _Safe(std::move(__m._M_safe()), __a),\n+\t_Base(std::move(__m._M_base()), __a) { }\n \n       map(initializer_list<value_type> __l, const allocator_type& __a)\n       : _Base(__l, __a) { }\n \n       template<typename _InputIterator>\n-        map(_InputIterator __first, _InputIterator __last,\n+\tmap(_InputIterator __first, _InputIterator __last,\n \t    const allocator_type& __a)\n-\t  : _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n-\t\t\t\t\t\t\t\t       __last)),\n-\t\t  __gnu_debug::__base(__last), __a)\n+\t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n+\t\t\t\t\t\t\t\t     __last)),\n+\t\t__gnu_debug::__base(__last), __a)\n \t{ }\n+\n+      ~map() = default;\n #endif\n \n-      ~map() _GLIBCXX_NOEXCEPT { }\n+      map(const _Base& __x)\n+      : _Base(__x) { }\n+\n+      explicit map(const _Compare& __comp,\n+\t\t   const _Allocator& __a = _Allocator())\n+      : _Base(__comp, __a) { }\n+\n+      template<typename _InputIterator>\n+\tmap(_InputIterator __first, _InputIterator __last,\n+\t    const _Compare& __comp = _Compare(),\n+\t    const _Allocator& __a = _Allocator())\n+\t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n+\t\t\t\t\t\t\t\t     __last)),\n+\t\t__gnu_debug::__base(__last),\n+\t\t__comp, __a) { }\n \n+#if __cplusplus < 201103L\n       map&\n       operator=(const map& __x)\n       {\n+\tthis->_M_safe() = __x;\n \t_M_base() = __x;\n-\tthis->_M_invalidate_all();\n \treturn *this;\n       }\n+#else\n+      map&\n+      operator=(const map&) = default;\n \n-#if __cplusplus >= 201103L\n       map&\n-      operator=(map&& __x)\n-      noexcept(_Alloc_traits::_S_nothrow_move())\n-      {\n-\t__glibcxx_check_self_move_assign(__x);\n-\tbool __xfer_memory = _Alloc_traits::_S_propagate_on_move_assign()\n-\t    || __x.get_allocator() == this->get_allocator();\n-\t_M_base() = std::move(__x._M_base());\n-\tif (__xfer_memory)\n-\t  this->_M_swap(__x);\n-\telse\n-\t  this->_M_invalidate_all();\n-\t__x._M_invalidate_all();\n-\treturn *this;\n-      }\n+      operator=(map&&) = default;\n \n       map&\n       operator=(initializer_list<value_type> __l)\n@@ -173,7 +167,7 @@ namespace __debug\n       using _Base::get_allocator;\n \n       // iterators:\n-      iterator \n+      iterator\n       begin() _GLIBCXX_NOEXCEPT\n       { return iterator(_Base::begin(), this); }\n \n@@ -269,9 +263,9 @@ namespace __debug\n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        std::pair<iterator, bool>\n-        insert(_Pair&& __x)\n-        {\n+\tstd::pair<iterator, bool>\n+\tinsert(_Pair&& __x)\n+\t{\n \t  std::pair<_Base_iterator, bool> __res\n \t    = _Base::insert(std::forward<_Pair>(__x));\n \t  return std::pair<iterator, bool>(iterator(__res.first, this),\n@@ -300,19 +294,19 @@ namespace __debug\n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        iterator\n-        insert(const_iterator __position, _Pair&& __x)\n-        {\n+\titerator\n+\tinsert(const_iterator __position, _Pair&& __x)\n+\t{\n \t  __glibcxx_check_insert(__position);\n \t  return iterator(_Base::insert(__position.base(),\n \t\t\t\t\tstd::forward<_Pair>(__x)), this);\n \t}\n #endif\n \n       template<typename _InputIterator>\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        {\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{\n \t  __glibcxx_check_valid_range(__first, __last);\n \t  _Base::insert(__gnu_debug::__base(__first),\n \t\t\t__gnu_debug::__base(__last));\n@@ -395,15 +389,11 @@ namespace __debug\n       void\n       swap(map& __x)\n #if __cplusplus >= 201103L\n-      noexcept(_Alloc_traits::_S_nothrow_swap())\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n #endif\n       {\n-#if __cplusplus >= 201103L\n-\tif (!_Alloc_traits::_S_propagate_on_swap())\n-\t  __glibcxx_check_equal_allocs(__x);\n-#endif\n+\t_Safe::_M_swap(__x);\n \t_Base::swap(__x);\n-\tthis->_M_swap(__x);\n       }\n \n       void\n@@ -463,18 +453,10 @@ namespace __debug\n       }\n \n       _Base&\n-      _M_base() _GLIBCXX_NOEXCEPT       { return *this; }\n+      _M_base() _GLIBCXX_NOEXCEPT\t{ return *this; }\n \n       const _Base&\n-      _M_base() const _GLIBCXX_NOEXCEPT { return *this; }\n-\n-    private:\n-      void\n-      _M_invalidate_all()\n-      {\n-\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n-      }\n+      _M_base() const _GLIBCXX_NOEXCEPT\t{ return *this; }\n     };\n \n   template<typename _Key, typename _Tp,"}, {"sha": "9d9ebab35f7ee80311d156d8b0a033d975f2b755", "filename": "libstdc++-v3/include/debug/multimap.h", "status": "modified", "additions": 73, "deletions": 94, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -30,6 +30,7 @@\n #define _GLIBCXX_DEBUG_MULTIMAP_H 1\n \n #include <debug/safe_sequence.h>\n+#include <debug/safe_container.h>\n #include <debug/safe_iterator.h>\n #include <utility>\n \n@@ -41,70 +42,55 @@ namespace __debug\n   template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>,\n \t   typename _Allocator = std::allocator<std::pair<const _Key, _Tp> > >\n     class multimap\n-    : public _GLIBCXX_STD_C::multimap<_Key, _Tp, _Compare, _Allocator>,\n-      public __gnu_debug::_Safe_sequence<multimap<_Key, _Tp,\n-\t\t\t\t\t\t  _Compare, _Allocator> >\n+      : public __gnu_debug::_Safe_container<\n+\tmultimap<_Key, _Tp, _Compare, _Allocator>, _Allocator,\n+\t__gnu_debug::_Safe_node_sequence>,\n+\tpublic _GLIBCXX_STD_C::multimap<_Key, _Tp, _Compare, _Allocator>\n     {\n-      typedef _GLIBCXX_STD_C::multimap<_Key, _Tp, _Compare, _Allocator> _Base;\n+      typedef _GLIBCXX_STD_C::multimap<\n+\t_Key, _Tp, _Compare, _Allocator>\t\t\t_Base;\n+      typedef __gnu_debug::_Safe_container<\n+\tmultimap, _Allocator, __gnu_debug::_Safe_node_sequence>\t_Safe;\n \n-      typedef typename _Base::const_iterator _Base_const_iterator;\n-      typedef typename _Base::iterator _Base_iterator;\n+      typedef typename _Base::const_iterator\t_Base_const_iterator;\n+      typedef typename _Base::iterator\t\t_Base_iterator;\n       typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n \n-#if __cplusplus >= 201103L\n-      typedef __gnu_cxx::__alloc_traits<typename\n-\t\t\t\t\t_Base::allocator_type> _Alloc_traits;\n-#endif\n     public:\n       // types:\n-      typedef _Key\t\t\t\t     key_type;\n-      typedef _Tp\t\t\t\t     mapped_type;\n-      typedef std::pair<const _Key, _Tp>             value_type;\n-      typedef _Compare                               key_compare;\n-      typedef _Allocator                             allocator_type;\n-      typedef typename _Base::reference              reference;\n-      typedef typename _Base::const_reference        const_reference;\n+      typedef _Key\t\t\t\t\tkey_type;\n+      typedef _Tp\t\t\t\t\tmapped_type;\n+      typedef std::pair<const _Key, _Tp>\t\tvalue_type;\n+      typedef _Compare\t\t\t\t\tkey_compare;\n+      typedef _Allocator\t\t\t\tallocator_type;\n+      typedef typename _Base::reference\t\t\treference;\n+      typedef typename _Base::const_reference\t\tconst_reference;\n \n       typedef __gnu_debug::_Safe_iterator<_Base_iterator, multimap>\n-                                                     iterator;\n+\t\t\t\t\t\t\titerator;\n       typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n-                                           multimap> const_iterator;\n+\t\t\t\t\t  multimap>\tconst_iterator;\n \n-      typedef typename _Base::size_type              size_type;\n-      typedef typename _Base::difference_type        difference_type;\n-      typedef typename _Base::pointer                pointer;\n-      typedef typename _Base::const_pointer          const_pointer;\n-      typedef std::reverse_iterator<iterator>        reverse_iterator;\n-      typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::difference_type\t\tdifference_type;\n+      typedef typename _Base::pointer\t\t\tpointer;\n+      typedef typename _Base::const_pointer\t\tconst_pointer;\n+      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n \n       // 23.3.1.1 construct/copy/destroy:\n \n+#if __cplusplus < 201103L\n       multimap() : _Base() { }\n \n-      explicit multimap(const _Compare& __comp,\n-\t\t\tconst _Allocator& __a = _Allocator())\n-      : _Base(__comp, __a) { }\n-\n-      template<typename _InputIterator>\n-      multimap(_InputIterator __first, _InputIterator __last,\n-\t       const _Compare& __comp = _Compare(),\n-\t       const _Allocator& __a = _Allocator())\n-\t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n-\t\t\t\t\t\t\t\t     __last)),\n-\t\t__gnu_debug::__base(__last),\n-\t      __comp, __a) { }\n-\n       multimap(const multimap& __x)\n       : _Base(__x) { }\n \n-      multimap(const _Base& __x)\n-      : _Base(__x) { }\n-\n-#if __cplusplus >= 201103L\n-      multimap(multimap&& __x)\n-      noexcept(is_nothrow_copy_constructible<_Compare>::value)\n-      : _Base(std::move(__x))\n-      { this->_M_swap(__x); }\n+      ~multimap() { }\n+#else\n+      multimap() = default;\n+      multimap(const multimap&) = default;\n+      multimap(multimap&&) = default;\n \n       multimap(initializer_list<value_type> __l,\n \t       const _Compare& __c = _Compare(),\n@@ -119,47 +105,52 @@ namespace __debug\n       : _Base(__m, __a) { }\n \n       multimap(multimap&& __m, const allocator_type& __a)\n-      : _Base(std::move(__m._M_base()), __a) { }\n+      : _Safe(std::move(__m._M_safe()), __a),\n+\t_Base(std::move(__m._M_base()), __a) { }\n \n       multimap(initializer_list<value_type> __l, const allocator_type& __a)\n-      : _Base(__l, __a)\n-      { }\n+      : _Base(__l, __a) { }\n \n       template<typename _InputIterator>\n-        multimap(_InputIterator __first, _InputIterator __last,\n+\tmultimap(_InputIterator __first, _InputIterator __last,\n \t\t const allocator_type& __a)\n \t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n \t\t\t\t\t\t\t\t     __last)),\n-\t\t__gnu_debug::__base(__last), __a)\n-      { }\n+\t\t__gnu_debug::__base(__last), __a) { }\n+\n+      ~multimap() = default;\n #endif\n \n-      ~multimap() _GLIBCXX_NOEXCEPT { }\n+      explicit multimap(const _Compare& __comp,\n+\t\t\tconst _Allocator& __a = _Allocator())\n+      : _Base(__comp, __a) { }\n+\n+      template<typename _InputIterator>\n+      multimap(_InputIterator __first, _InputIterator __last,\n+\t       const _Compare& __comp = _Compare(),\n+\t       const _Allocator& __a = _Allocator())\n+\t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n+\t\t\t\t\t\t\t\t     __last)),\n+\t\t__gnu_debug::__base(__last),\n+\t      __comp, __a) { }\n+\n+      multimap(const _Base& __x)\n+      : _Base(__x) { }\n \n+#if __cplusplus < 201103L\n       multimap&\n       operator=(const multimap& __x)\n       {\n+\tthis->_M_safe() = __x;\n \t_M_base() = __x;\n-\tthis->_M_invalidate_all();\n \treturn *this;\n       }\n+#else\n+      multimap&\n+      operator=(const multimap&) = default;\n \n-#if __cplusplus >= 201103L\n       multimap&\n-      operator=(multimap&& __x)\n-      noexcept(_Alloc_traits::_S_nothrow_move())\n-      {\n-\t__glibcxx_check_self_move_assign(__x);\n-\tbool __xfer_memory = _Alloc_traits::_S_propagate_on_move_assign()\n-\t    || __x.get_allocator() == this->get_allocator();\n-\t_M_base() = std::move(__x._M_base());\n-\tif (__xfer_memory)\n-\t  this->_M_swap(__x);\n-\telse\n-\t  this->_M_invalidate_all();\n-\t__x._M_invalidate_all();\n-\treturn *this;\n-      }\n+      operator=(multimap&&) = default;\n \n       multimap&\n       operator=(initializer_list<value_type> __l)\n@@ -247,7 +238,7 @@ namespace __debug\n \t\t\t  this);\n \t}\n #endif\n-      \n+\n       iterator\n       insert(const value_type& __x)\n       { return iterator(_Base::insert(__x), this); }\n@@ -256,9 +247,9 @@ namespace __debug\n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        iterator\n-        insert(_Pair&& __x)\n-        { return iterator(_Base::insert(std::forward<_Pair>(__x)), this); }\n+\titerator\n+\tinsert(_Pair&& __x)\n+\t{ return iterator(_Base::insert(std::forward<_Pair>(__x)), this); }\n #endif\n \n #if __cplusplus >= 201103L\n@@ -282,19 +273,19 @@ namespace __debug\n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        iterator\n-        insert(const_iterator __position, _Pair&& __x)\n-        {\n+\titerator\n+\tinsert(const_iterator __position, _Pair&& __x)\n+\t{\n \t  __glibcxx_check_insert(__position);\n \t  return iterator(_Base::insert(__position.base(),\n \t\t\t\t\tstd::forward<_Pair>(__x)), this);\n \t}\n #endif\n \n       template<typename _InputIterator>\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        {\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{\n \t  __glibcxx_check_valid_range(__first, __last);\n \t  _Base::insert(__gnu_debug::__base(__first),\n \t\t\t__gnu_debug::__base(__last));\n@@ -379,15 +370,11 @@ namespace __debug\n       void\n       swap(multimap& __x)\n #if __cplusplus >= 201103L\n-      noexcept(_Alloc_traits::_S_nothrow_swap())\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n #endif\n       {\n-#if __cplusplus >= 201103L\n-\tif (!_Alloc_traits::_S_propagate_on_swap())\n-\t  __glibcxx_check_equal_allocs(__x);\n-#endif\n+\t_Safe::_M_swap(__x);\n \t_Base::swap(__x);\n-\tthis->_M_swap(__x);\n       }\n \n       void\n@@ -447,18 +434,10 @@ namespace __debug\n       }\n \n       _Base&\n-      _M_base() _GLIBCXX_NOEXCEPT       { return *this; }\n+      _M_base() _GLIBCXX_NOEXCEPT { return *this; }\n \n       const _Base&\n       _M_base() const _GLIBCXX_NOEXCEPT { return *this; }\n-\n-    private:\n-      void\n-      _M_invalidate_all()\n-      {\n-\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_Base::end()));\n-      }\n     };\n \n   template<typename _Key, typename _Tp,"}, {"sha": "ed7248d12f5318f6fe792371c79604441b48232e", "filename": "libstdc++-v3/include/debug/multiset.h", "status": "modified", "additions": 65, "deletions": 84, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -30,6 +30,7 @@\n #define _GLIBCXX_DEBUG_MULTISET_H 1\n \n #include <debug/safe_sequence.h>\n+#include <debug/safe_container.h>\n #include <debug/safe_iterator.h>\n #include <utility>\n \n@@ -41,69 +42,54 @@ namespace __debug\n   template<typename _Key, typename _Compare = std::less<_Key>,\n \t   typename _Allocator = std::allocator<_Key> >\n     class multiset\n-    : public _GLIBCXX_STD_C::multiset<_Key, _Compare, _Allocator>,\n-      public __gnu_debug::_Safe_sequence<multiset<_Key, _Compare, _Allocator> >\n+    : public __gnu_debug::_Safe_container<\n+\tmultiset<_Key, _Compare, _Allocator>, _Allocator,\n+\t__gnu_debug::_Safe_node_sequence>,\n+      public _GLIBCXX_STD_C::multiset<_Key, _Compare, _Allocator>\n     {\n-      typedef _GLIBCXX_STD_C::multiset<_Key, _Compare, _Allocator> _Base;\n+      typedef _GLIBCXX_STD_C::multiset<_Key, _Compare, _Allocator>\t_Base;\n+      typedef __gnu_debug::_Safe_container<\n+\tmultiset, _Allocator, __gnu_debug::_Safe_node_sequence>\t\t_Safe;\n \n-      typedef typename _Base::const_iterator _Base_const_iterator;\n-      typedef typename _Base::iterator _Base_iterator;\n+      typedef typename _Base::const_iterator\t_Base_const_iterator;\n+      typedef typename _Base::iterator\t\t_Base_iterator;\n       typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n \n-#if __cplusplus >= 201103L\n-      typedef __gnu_cxx::__alloc_traits<typename\n-\t\t\t\t\t_Base::allocator_type> _Alloc_traits;\n-#endif\n     public:\n       // types:\n-      typedef _Key\t\t\t\t     key_type;\n-      typedef _Key\t\t\t\t     value_type;\n-      typedef _Compare\t\t\t\t     key_compare;\n-      typedef _Compare\t\t\t\t     value_compare;\n-      typedef _Allocator\t\t\t     allocator_type;\n-      typedef typename _Base::reference\t             reference;\n-      typedef typename _Base::const_reference        const_reference;\n+      typedef _Key\t\t\t\t\tkey_type;\n+      typedef _Key\t\t\t\t\tvalue_type;\n+      typedef _Compare\t\t\t\t\tkey_compare;\n+      typedef _Compare\t\t\t\t\tvalue_compare;\n+      typedef _Allocator\t\t\t\tallocator_type;\n+      typedef typename _Base::reference\t\t\treference;\n+      typedef typename _Base::const_reference\t\tconst_reference;\n \n       typedef __gnu_debug::_Safe_iterator<_Base_iterator, multiset>\n-      iterator;\n+\t\t\t\t\t\t\titerator;\n       typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n-\t\t\t\t\t  multiset> const_iterator;\n+\t\t\t\t\t  multiset>\tconst_iterator;\n \n-      typedef typename _Base::size_type              size_type;\n-      typedef typename _Base::difference_type        difference_type;\n-      typedef typename _Base::pointer                pointer;\n-      typedef typename _Base::const_pointer          const_pointer;\n-      typedef std::reverse_iterator<iterator>        reverse_iterator;\n-      typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::difference_type\t\tdifference_type;\n+      typedef typename _Base::pointer\t\t\tpointer;\n+      typedef typename _Base::const_pointer\t\tconst_pointer;\n+      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n \n       // 23.3.3.1 construct/copy/destroy:\n \n+#if __cplusplus < 201103L\n       multiset() : _Base() { }\n \n-      explicit multiset(const _Compare& __comp,\n-\t\t\tconst _Allocator& __a = _Allocator())\n-      : _Base(__comp, __a) { }\n-\n-      template<typename _InputIterator>\n-        multiset(_InputIterator __first, _InputIterator __last,\n-\t\t const _Compare& __comp = _Compare(),\n-\t\t const _Allocator& __a = _Allocator())\n-\t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n-\t\t\t\t\t\t\t\t     __last)),\n-\t\t__gnu_debug::__base(__last),\n-\t\t__comp, __a) { }\n-\n       multiset(const multiset& __x)\n       : _Base(__x) { }\n \n-      multiset(const _Base& __x)\n-      : _Base(__x) { }\n-\n-#if __cplusplus >= 201103L\n-      multiset(multiset&& __x)\n-      noexcept(is_nothrow_copy_constructible<_Compare>::value)\n-      : _Base(std::move(__x))\n-      { this->_M_swap(__x); }\n+      ~multiset() { }\n+#else\n+      multiset() = default;\n+      multiset(const multiset&) = default;\n+      multiset(multiset&&) = default;\n \n       multiset(initializer_list<value_type> __l,\n \t       const _Compare& __comp = _Compare(),\n@@ -118,47 +104,53 @@ namespace __debug\n       : _Base(__m, __a) { }\n \n       multiset(multiset&& __m, const allocator_type& __a)\n-      : _Base(std::move(__m._M_base()), __a) { }\n+      : _Safe(std::move(__m._M_safe()), __a),\n+\t_Base(std::move(__m._M_base()), __a) { }\n \n       multiset(initializer_list<value_type> __l, const allocator_type& __a)\n \t: _Base(__l, __a)\n       { }\n \n       template<typename _InputIterator>\n-        multiset(_InputIterator __first, _InputIterator __last,\n+\tmultiset(_InputIterator __first, _InputIterator __last,\n \t\t const allocator_type& __a)\n-\t  : _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n-\t\t\t\t\t\t\t\t       __last)),\n-\t\t  __gnu_debug::__base(__last), __a)\n-        { }\n+\t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n+\t\t\t\t\t\t\t\t     __last)),\n+\t\t__gnu_debug::__base(__last), __a) { }\n+\n+      ~multiset() = default;\n #endif\n \n-      ~multiset() _GLIBCXX_NOEXCEPT { }\n+      explicit multiset(const _Compare& __comp,\n+\t\t\tconst _Allocator& __a = _Allocator())\n+      : _Base(__comp, __a) { }\n+\n+      template<typename _InputIterator>\n+\tmultiset(_InputIterator __first, _InputIterator __last,\n+\t\t const _Compare& __comp = _Compare(),\n+\t\t const _Allocator& __a = _Allocator())\n+\t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n+\t\t\t\t\t\t\t\t     __last)),\n+\t\t__gnu_debug::__base(__last),\n+\t\t__comp, __a) { }\n+\n+      multiset(const _Base& __x)\n+      : _Base(__x) { }\n \n+#if __cplusplus < 201103L\n       multiset&\n       operator=(const multiset& __x)\n       {\n+\tthis->_M_safe() = __x;\n \t_M_base() = __x;\n-\tthis->_M_invalidate_all();\n \treturn *this;\n       }\n+#else\n+      multiset&\n+      operator=(const multiset&) = default;\n \n-#if __cplusplus >= 201103L\n       multiset&\n-      operator=(multiset&& __x)\n-      noexcept(_Alloc_traits::_S_nothrow_move())\n-      {\n-\t__glibcxx_check_self_move_assign(__x);\n-\tbool __xfer_memory = _Alloc_traits::_S_propagate_on_move_assign()\n-\t    || __x.get_allocator() == this->get_allocator();\n-\t_M_base() = std::move(__x._M_base());\n-\tif (__xfer_memory)\n-\t  this->_M_swap(__x);\n-\telse\n-\t  this->_M_invalidate_all();\n-\t__x._M_invalidate_all();\n-\treturn *this;\n-      }\n+      operator=(multiset&&) = default;\n \n       multiset&\n       operator=(initializer_list<value_type> __l)\n@@ -233,7 +225,8 @@ namespace __debug\n \titerator\n \templace(_Args&&... __args)\n \t{\n-\t  return iterator(_Base::emplace(std::forward<_Args>(__args)...), this);\n+\t  return iterator(_Base::emplace(std::forward<_Args>(__args)...),\n+\t\t\t  this);\n \t}\n \n       template<typename... _Args>\n@@ -364,15 +357,11 @@ namespace __debug\n       void\n       swap(multiset& __x)\n #if __cplusplus >= 201103L\n-      noexcept(_Alloc_traits::_S_nothrow_swap())\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n #endif\n       {\n-#if __cplusplus >= 201103L\n-\tif (!_Alloc_traits::_S_propagate_on_swap())\n-\t  __glibcxx_check_equal_allocs(__x);\n-#endif\n+\t_Safe::_M_swap(__x);\n \t_Base::swap(__x);\n-\tthis->_M_swap(__x);\n       }\n \n       void\n@@ -440,18 +429,10 @@ namespace __debug\n       }\n \n       _Base&\n-      _M_base() _GLIBCXX_NOEXCEPT       { return *this; }\n+      _M_base() _GLIBCXX_NOEXCEPT { return *this; }\n \n       const _Base&\n       _M_base() const _GLIBCXX_NOEXCEPT { return *this; }\n-\n-    private:\n-      void\n-      _M_invalidate_all()\n-      {\n-\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_Base::end()));\n-      }\n     };\n \n   template<typename _Key, typename _Compare, typename _Allocator>"}, {"sha": "fc589159a37d6462eaf363402adef9127dddc90c", "filename": "libstdc++-v3/include/debug/safe_base.h", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_base.h?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -52,7 +52,7 @@ namespace __gnu_debug\n   public:\n     /** The sequence this iterator references; may be NULL to indicate\n \ta singular iterator. */\n-    _Safe_sequence_base* _M_sequence;\n+    _Safe_sequence_base*\t_M_sequence;\n \n     /** The version number of this iterator. The sentinel value 0 is\n      *  used to indicate an invalidated iterator (i.e., one that is\n@@ -61,15 +61,15 @@ namespace __gnu_debug\n      *  referenced by _M_sequence for the iterator to be\n      *  non-singular.\n      */\n-    unsigned int         _M_version;\n+    unsigned int\t\t_M_version;\n \n     /** Pointer to the previous iterator in the sequence's list of\n \titerators. Only valid when _M_sequence != NULL. */\n-    _Safe_iterator_base* _M_prior;\n+    _Safe_iterator_base*\t_M_prior;\n \n     /** Pointer to the next iterator in the sequence's list of\n \titerators. Only valid when _M_sequence != NULL. */\n-    _Safe_iterator_base* _M_next;\n+    _Safe_iterator_base*\t_M_next;\n \n   protected:\n     /** Initializes the iterator and makes it singular. */\n@@ -104,38 +104,46 @@ namespace __gnu_debug\n     ~_Safe_iterator_base() { this->_M_detach(); }\n \n     /** For use in _Safe_iterator. */\n-    __gnu_cxx::__mutex& _M_get_mutex() throw ();\n+    __gnu_cxx::__mutex&\n+    _M_get_mutex() throw ();\n \n   public:\n     /** Attaches this iterator to the given sequence, detaching it\n      *\tfrom whatever sequence it was attached to originally. If the\n      *\tnew sequence is the NULL pointer, the iterator is left\n      *\tunattached.\n      */\n-    void _M_attach(_Safe_sequence_base* __seq, bool __constant);\n+    void\n+    _M_attach(_Safe_sequence_base* __seq, bool __constant);\n \n     /** Likewise, but not thread-safe. */\n-    void _M_attach_single(_Safe_sequence_base* __seq, bool __constant) throw ();\n+    void\n+    _M_attach_single(_Safe_sequence_base* __seq, bool __constant) throw ();\n \n     /** Detach the iterator for whatever sequence it is attached to,\n      *\tif any.\n     */\n-    void _M_detach();\n+    void\n+    _M_detach();\n \n     /** Likewise, but not thread-safe. */\n-    void _M_detach_single() throw ();\n+    void\n+    _M_detach_single() throw ();\n \n     /** Determines if we are attached to the given sequence. */\n-    bool _M_attached_to(const _Safe_sequence_base* __seq) const\n+    bool\n+    _M_attached_to(const _Safe_sequence_base* __seq) const\n     { return _M_sequence == __seq; }\n \n     /** Is this iterator singular? */\n-    _GLIBCXX_PURE bool _M_singular() const throw ();\n+    _GLIBCXX_PURE bool\n+    _M_singular() const throw ();\n \n     /** Can we compare this iterator to the given iterator @p __x?\n \tReturns true if both iterators are nonsingular and reference\n \tthe same sequence. */\n-    _GLIBCXX_PURE bool _M_can_compare(const _Safe_iterator_base& __x) const throw ();\n+    _GLIBCXX_PURE bool\n+    _M_can_compare(const _Safe_iterator_base& __x) const throw ();\n \n     /** Invalidate the iterator, making it singular. */\n     void\n@@ -188,17 +196,13 @@ namespace __gnu_debug\n \n   protected:\n     // Initialize with a version number of 1 and no iterators\n-    _Safe_sequence_base()\n+    _Safe_sequence_base() _GLIBCXX_NOEXCEPT\n     : _M_iterators(0), _M_const_iterators(0), _M_version(1)\n     { }\n \n #if __cplusplus >= 201103L\n     _Safe_sequence_base(const _Safe_sequence_base&) noexcept\n-      : _Safe_sequence_base() { }\n-\n-    _Safe_sequence_base(_Safe_sequence_base&& __x) noexcept\n-      : _Safe_sequence_base()\n-    { _M_swap(__x); }\n+    : _Safe_sequence_base() { }\n #endif\n \n     /** Notify all iterators that reference this sequence that the\n@@ -231,10 +235,11 @@ namespace __gnu_debug\n      *  one container now reference the other container.\n      */\n     void\n-    _M_swap(_Safe_sequence_base& __x);\n+    _M_swap(_Safe_sequence_base& __x) _GLIBCXX_USE_NOEXCEPT;\n \n     /** For use in _Safe_sequence. */\n-    __gnu_cxx::__mutex& _M_get_mutex() throw ();\n+    __gnu_cxx::__mutex&\n+    _M_get_mutex() throw ();\n \n   public:\n     /** Invalidates all iterators. */"}, {"sha": "a429ae023435fdea065f7c7562cba2010af16aa1", "filename": "libstdc++-v3/include/debug/safe_container.h", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_container.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_container.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_container.h?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,125 @@\n+// Safe container implementation  -*- C++ -*-\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file debug/safe_container.h\n+ *  This file is a GNU debug extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_DEBUG_SAFE_CONTAINER_H\n+#define _GLIBCXX_DEBUG_SAFE_CONTAINER_H 1\n+\n+#include <ext/alloc_traits.h>\n+\n+namespace __gnu_debug\n+{\n+  /// Safe class dealing with some allocator dependent operations.\n+  template<typename _SafeContainer,\n+\t   typename _Alloc,\n+\t   template<typename> class _SafeBase,\n+\t   bool _IsCxx11AllocatorAware = true>\n+    class _Safe_container\n+    : public _SafeBase<_SafeContainer>\n+    {\n+      typedef _SafeBase<_SafeContainer> _Base;\n+\n+      _SafeContainer&\n+      _M_cont() _GLIBCXX_NOEXCEPT\n+      { return *static_cast<_SafeContainer*>(this); }\n+\n+    protected:\n+      _Safe_container&\n+      _M_safe() _GLIBCXX_NOEXCEPT\n+      { return *this; }\n+\n+#if __cplusplus >= 201103L\n+      _Safe_container() = default;\n+      _Safe_container(const _Safe_container&) = default;\n+      _Safe_container(_Safe_container&& __x) noexcept\n+      : _Safe_container()\n+      { _Base::_M_swap(__x); }\n+\n+      _Safe_container(_Safe_container&& __x,\n+\t\t      const _Alloc& __a)\n+      : _Safe_container()\n+      {\n+\tif (__x._M_cont().get_allocator() == __a)\n+\t  _Base::_M_swap(__x);\n+\telse\n+\t  __x._M_invalidate_all();\n+      }\n+#endif\n+\n+    public:\n+      // Copy assignment invalidate all iterators.\n+      _Safe_container&\n+      operator=(const _Safe_container&) _GLIBCXX_NOEXCEPT\n+      {\n+\tthis->_M_invalidate_all();\n+\treturn *this;\n+      }\n+\n+#if __cplusplus >= 201103L\n+      _Safe_container&\n+      operator=(_Safe_container&& __x) noexcept\n+      {\n+\t__glibcxx_check_self_move_assign(__x);\n+\n+\tif (_IsCxx11AllocatorAware)\n+\t  {\n+\t    typedef __gnu_cxx::__alloc_traits<_Alloc> _Alloc_traits;\n+\n+\t    bool __xfer_memory = _Alloc_traits::_S_propagate_on_move_assign()\n+\t      || _M_cont().get_allocator() == __x._M_cont().get_allocator();\n+\t    if (__xfer_memory)\n+\t      _Base::_M_swap(__x);\n+\t    else\n+\t      this->_M_invalidate_all();\n+\t  }\n+\telse\n+\t  _Base::_M_swap(__x);\n+\n+\t__x._M_invalidate_all();\n+\treturn *this;\n+      }\n+\n+      void\n+      _M_swap(_Safe_container& __x) noexcept\n+      {\n+\tif (_IsCxx11AllocatorAware)\n+\t  {\n+\t    typedef __gnu_cxx::__alloc_traits<_Alloc> _Alloc_traits;\n+\n+\t    if (!_Alloc_traits::_S_propagate_on_swap())\n+\t      __glibcxx_check_equal_allocs(this->_M_cont()._M_base(),\n+\t\t\t\t\t   __x._M_cont()._M_base());\n+\t  }\n+\n+\t_Base::_M_swap(__x);\n+      }\n+#endif\n+    };\n+\n+} // namespace __gnu_debug\n+\n+#endif"}, {"sha": "b6f136322f47414c834afda769da72e01b77ac94", "filename": "libstdc++-v3/include/debug/safe_iterator.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -58,7 +58,7 @@ namespace __gnu_debug\n   /** Iterators that derive from _Safe_iterator_base can be determined singular\n    *  or non-singular.\n    **/\n-  inline bool \n+  inline bool\n   __check_singular_aux(const _Safe_iterator_base* __x)\n   { return __x->_M_singular(); }\n \n@@ -127,12 +127,12 @@ namespace __gnu_debug\n       typedef std::iterator_traits<_Iterator> _Traits;\n \n     public:\n-      typedef _Iterator                           iterator_type;\n-      typedef typename _Traits::iterator_category iterator_category;\n-      typedef typename _Traits::value_type        value_type;\n-      typedef typename _Traits::difference_type   difference_type;\n-      typedef typename _Traits::reference         reference;\n-      typedef typename _Traits::pointer           pointer;\n+      typedef _Iterator\t\t\t\t\titerator_type;\n+      typedef typename _Traits::iterator_category\titerator_category;\n+      typedef typename _Traits::value_type\t\tvalue_type;\n+      typedef typename _Traits::difference_type\t\tdifference_type;\n+      typedef typename _Traits::reference\t\treference;\n+      typedef typename _Traits::pointer\t\t\tpointer;\n \n       /// @post the iterator is singular and unattached\n       _Safe_iterator() _GLIBCXX_NOEXCEPT : _M_current() { }\n@@ -191,13 +191,13 @@ namespace __gnu_debug\n        *  constant iterator.\n       */\n       template<typename _MutableIterator>\n-        _Safe_iterator(\n-          const _Safe_iterator<_MutableIterator,\n-          typename __gnu_cxx::__enable_if<(std::__are_same<_MutableIterator,\n-                      typename _Sequence::iterator::iterator_type>::__value),\n-                   _Sequence>::__type>& __x) _GLIBCXX_NOEXCEPT\n+\t_Safe_iterator(\n+\t  const _Safe_iterator<_MutableIterator,\n+\t  typename __gnu_cxx::__enable_if<(std::__are_same<_MutableIterator,\n+\t\t      typename _Sequence::iterator::iterator_type>::__value),\n+\t\t   _Sequence>::__type>& __x) _GLIBCXX_NOEXCEPT\n \t: _Safe_iterator_base(__x, _M_constant()), _M_current(__x.base())\n-        {\n+\t{\n \t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t  // DR 408. Is vector<reverse_iterator<char*> > forbidden?\n \t  _GLIBCXX_DEBUG_VERIFY(!__x._M_singular()\n@@ -497,7 +497,7 @@ namespace __gnu_debug\n   template<typename _Iterator, typename _Sequence>\n     inline bool\n     operator==(const _Safe_iterator<_Iterator, _Sequence>& __lhs,\n-               const _Safe_iterator<_Iterator, _Sequence>& __rhs)\n+\t       const _Safe_iterator<_Iterator, _Sequence>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     {\n       _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n@@ -531,7 +531,7 @@ namespace __gnu_debug\n   template<typename _Iterator, typename _Sequence>\n     inline bool\n     operator!=(const _Safe_iterator<_Iterator, _Sequence>& __lhs,\n-               const _Safe_iterator<_Iterator, _Sequence>& __rhs)\n+\t       const _Safe_iterator<_Iterator, _Sequence>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     {\n       _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n@@ -599,7 +599,7 @@ namespace __gnu_debug\n   template<typename _Iterator, typename _Sequence>\n     inline bool\n     operator<=(const _Safe_iterator<_Iterator, _Sequence>& __lhs,\n-               const _Safe_iterator<_Iterator, _Sequence>& __rhs)\n+\t       const _Safe_iterator<_Iterator, _Sequence>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     {\n       _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n@@ -667,7 +667,7 @@ namespace __gnu_debug\n   template<typename _Iterator, typename _Sequence>\n     inline bool\n     operator>=(const _Safe_iterator<_Iterator, _Sequence>& __lhs,\n-               const _Safe_iterator<_Iterator, _Sequence>& __rhs)\n+\t       const _Safe_iterator<_Iterator, _Sequence>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     {\n       _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),"}, {"sha": "50da161ebce50dbc43031078881768a329bb860f", "filename": "libstdc++-v3/include/debug/safe_local_iterator.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_local_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_local_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_local_iterator.h?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -69,12 +69,12 @@ namespace __gnu_debug\n       typedef std::iterator_traits<_Iterator> _Traits;\n \n     public:\n-      typedef _Iterator                           iterator_type;\n-      typedef typename _Traits::iterator_category iterator_category;\n-      typedef typename _Traits::value_type        value_type;\n-      typedef typename _Traits::difference_type   difference_type;\n-      typedef typename _Traits::reference         reference;\n-      typedef typename _Traits::pointer           pointer;\n+      typedef _Iterator\t\t\t\t\titerator_type;\n+      typedef typename _Traits::iterator_category\titerator_category;\n+      typedef typename _Traits::value_type\t\tvalue_type;\n+      typedef typename _Traits::difference_type\t\tdifference_type;\n+      typedef typename _Traits::reference\t\treference;\n+      typedef typename _Traits::pointer\t\t\tpointer;\n \n       /// @post the iterator is singular and unattached\n       _Safe_local_iterator() : _M_current() { }"}, {"sha": "8649436e4d8c6fdbfff3209f72ac4292102b380e", "filename": "libstdc++-v3/include/debug/safe_sequence.h", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.h?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -116,17 +116,36 @@ namespace __gnu_debug\n \t  true. @c __pred will be invoked with the normal iterators nested\n \t  in the safe ones. */\n       template<typename _Predicate>\n-        void\n-        _M_invalidate_if(_Predicate __pred);\n+\tvoid\n+\t_M_invalidate_if(_Predicate __pred);\n \n       /** Transfers all iterators @c x that reference @c from sequence,\n \t  are not singular, and for which @c __pred(x) returns @c\n \t  true. @c __pred will be invoked with the normal iterators nested\n \t  in the safe ones. */\n       template<typename _Predicate>\n-        void\n-        _M_transfer_from_if(_Safe_sequence& __from, _Predicate __pred);\n+\tvoid\n+\t_M_transfer_from_if(_Safe_sequence& __from, _Predicate __pred);\n     };\n+\n+  /// Like _Safe_sequence but with a special _M_invalidate_all implementation\n+  /// not invalidating past-the-end iterators. Used by node based sequence.\n+  template<typename _Sequence>\n+    class _Safe_node_sequence\n+    : public _Safe_sequence<_Sequence>\n+    {\n+    protected:\n+      void\n+      _M_invalidate_all()\n+      {\n+\ttypedef typename _Sequence::const_iterator _Const_iterator;\n+\ttypedef typename _Const_iterator::iterator_type _Base_const_iterator;\n+\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n+\tconst _Sequence& __seq = *static_cast<_Sequence*>(this);\n+\tthis->_M_invalidate_if(_Not_equal(__seq._M_base().end()));\n+      }\n+    };\n+\n } // namespace __gnu_debug\n \n #include <debug/safe_sequence.tcc>"}, {"sha": "5fef446359e90a6f7e05a388c7f16be73b195a03", "filename": "libstdc++-v3/include/debug/safe_sequence.tcc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.tcc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -37,11 +37,11 @@ namespace __gnu_debug\n       _Safe_sequence<_Sequence>::\n       _M_invalidate_if(_Predicate __pred)\n       {\n-        typedef typename _Sequence::iterator iterator;\n-        typedef typename _Sequence::const_iterator const_iterator;\n+\ttypedef typename _Sequence::iterator iterator;\n+\ttypedef typename _Sequence::const_iterator const_iterator;\n \n \t__gnu_cxx::__scoped_lock sentry(this->_M_get_mutex());\n-        for (_Safe_iterator_base* __iter = _M_iterators; __iter;)\n+\tfor (_Safe_iterator_base* __iter = _M_iterators; __iter;)\n \t  {\n \t    iterator* __victim = static_cast<iterator*>(__iter);\n \t    __iter = __iter->_M_next;\n@@ -51,7 +51,7 @@ namespace __gnu_debug\n \t      }\n \t  }\n \n-        for (_Safe_iterator_base* __iter2 = _M_const_iterators; __iter2;)\n+\tfor (_Safe_iterator_base* __iter2 = _M_const_iterators; __iter2;)\n \t  {\n \t    const_iterator* __victim = static_cast<const_iterator*>(__iter2);\n \t    __iter2 = __iter2->_M_next;\n@@ -68,8 +68,8 @@ namespace __gnu_debug\n       _Safe_sequence<_Sequence>::\n       _M_transfer_from_if(_Safe_sequence& __from, _Predicate __pred)\n       {\n-        typedef typename _Sequence::iterator iterator;\n-        typedef typename _Sequence::const_iterator const_iterator;\n+\ttypedef typename _Sequence::iterator iterator;\n+\ttypedef typename _Sequence::const_iterator const_iterator;\n \n \t_Safe_iterator_base* __transfered_iterators = 0;\n \t_Safe_iterator_base* __transfered_const_iterators = 0;\n@@ -79,7 +79,7 @@ namespace __gnu_debug\n \t  // We lock __from first and detach iterator(s) to transfer\n \t  __gnu_cxx::__scoped_lock sentry(__from._M_get_mutex());\n \n-          for (_Safe_iterator_base* __iter = __from._M_iterators; __iter;)\n+\t  for (_Safe_iterator_base* __iter = __from._M_iterators; __iter;)\n \t    {\n \t      iterator* __victim = static_cast<iterator*>(__iter);\n \t      __iter = __iter->_M_next;"}, {"sha": "31c5c894cc14a51235475140006f0d2b8ef1e151", "filename": "libstdc++-v3/include/debug/safe_unordered_base.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_base.h?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -80,7 +80,7 @@ namespace __gnu_debug\n     ~_Safe_local_iterator_base() { this->_M_detach(); }\n \n     _Safe_unordered_container_base*\n-    _M_get_container() const _GLIBCXX_NOEXCEPT;\n+    _M_get_container() const noexcept;\n \n   public:\n     /** Attaches this iterator to the given container, detaching it\n@@ -132,23 +132,24 @@ namespace __gnu_debug\n \n   protected:\n     // Initialize with a version number of 1 and no iterators\n-    _Safe_unordered_container_base()\n+    _Safe_unordered_container_base() noexcept\n     : _M_local_iterators(nullptr), _M_const_local_iterators(nullptr)\n     { }\n \n-    // Initialize with a version number of 1 and no iterators\n+    // Copy constructor does not copy iterators.\n     _Safe_unordered_container_base(const _Safe_unordered_container_base&)\n     noexcept\n     : _Safe_unordered_container_base() { }\n \n+    // When moved unordered containers iterators are swapped.\n     _Safe_unordered_container_base(_Safe_unordered_container_base&& __x)\n     noexcept\n     : _Safe_unordered_container_base()\n     { this->_M_swap(__x); }\n \n     /** Notify all iterators that reference this container that the\n \tcontainer is being destroyed. */\n-    ~_Safe_unordered_container_base()\n+    ~_Safe_unordered_container_base() noexcept\n     { this->_M_detach_all(); }\n \n     /** Detach all iterators, leaving them singular. */\n@@ -161,7 +162,7 @@ namespace __gnu_debug\n      *  one container now reference the other container.\n      */\n     void\n-    _M_swap(_Safe_unordered_container_base& __x);\n+    _M_swap(_Safe_unordered_container_base& __x) noexcept;\n \n   public:\n     /** Attach an iterator to this container. */"}, {"sha": "96933feaf3c2de6568d30a1aaf1ff40eb7c06462", "filename": "libstdc++-v3/include/debug/safe_unordered_container.h", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_container.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_container.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_container.h?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -57,7 +57,31 @@ namespace __gnu_debug\n   template<typename _Container>\n     class _Safe_unordered_container : public _Safe_unordered_container_base\n     {\n-    public:\n+    private:\n+      _Container&\n+      _M_cont() noexcept\n+      { return *static_cast<_Container*>(this); }\n+\n+    protected:\n+      void\n+      _M_invalidate_locals()\n+      {\n+\tauto __local_end = _M_cont()._M_base().end(0);\n+\tthis->_M_invalidate_local_if(\n+\t\t[__local_end](__decltype(_M_cont()._M_base().cend(0)) __it)\n+\t\t{ return __it != __local_end; });\n+      }\n+\n+      void\n+      _M_invalidate_all()\n+      {\n+\tauto __end = _M_cont()._M_base().end();\n+\tthis->_M_invalidate_if(\n+\t\t[__end](__decltype(_M_cont()._M_base().cend()) __it)\n+\t\t{ return __it != __end; });\n+\t_M_invalidate_locals();\n+      }\n+\n       /** Invalidates all iterators @c x that reference this container,\n \t  are not singular, and for which @c __pred(x) returns @c\n \t  true. @c __pred will be invoked with the normal iterators nested"}, {"sha": "d70febe5a3908a18741901d86e575a92cea79a6a", "filename": "libstdc++-v3/include/debug/set.h", "status": "modified", "additions": 71, "deletions": 91, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -30,79 +30,66 @@\n #define _GLIBCXX_DEBUG_SET_H 1\n \n #include <debug/safe_sequence.h>\n+#include <debug/safe_container.h>\n #include <debug/safe_iterator.h>\n #include <utility>\n \n-namespace std _GLIBCXX_VISIBILITY(default) \n+namespace std _GLIBCXX_VISIBILITY(default)\n {\n namespace __debug\n {\n   /// Class std::set with safety/checking/debug instrumentation.\n   template<typename _Key, typename _Compare = std::less<_Key>,\n \t   typename _Allocator = std::allocator<_Key> >\n     class set\n-    : public _GLIBCXX_STD_C::set<_Key,_Compare,_Allocator>,\n-      public __gnu_debug::_Safe_sequence<set<_Key, _Compare, _Allocator> >\n+    : public __gnu_debug::_Safe_container<\n+\tset<_Key, _Compare, _Allocator>, _Allocator,\n+\t__gnu_debug::_Safe_node_sequence>,\n+      public _GLIBCXX_STD_C::set<_Key,_Compare,_Allocator>\n     {\n-      typedef _GLIBCXX_STD_C::set<_Key, _Compare, _Allocator> _Base;\n+      typedef _GLIBCXX_STD_C::set<_Key, _Compare, _Allocator>\t_Base;\n+      typedef __gnu_debug::_Safe_container<\n+\tset, _Allocator, __gnu_debug::_Safe_node_sequence>\t_Safe;\n \n-      typedef typename _Base::const_iterator _Base_const_iterator;\n-      typedef typename _Base::iterator _Base_iterator;\n+      typedef typename _Base::const_iterator\t_Base_const_iterator;\n+      typedef typename _Base::iterator\t\t_Base_iterator;\n       typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n-#if __cplusplus >= 201103L\n-      typedef __gnu_cxx::__alloc_traits<typename\n-\t\t\t\t\t_Base::allocator_type> _Alloc_traits;\n-#endif\n+\n     public:\n       // types:\n-      typedef _Key\t\t\t\t    key_type;\n-      typedef _Key\t\t\t\t    value_type;\n-      typedef _Compare\t\t\t\t    key_compare;\n-      typedef _Compare\t\t\t\t    value_compare;\n-      typedef _Allocator\t\t\t    allocator_type;\n-      typedef typename _Base::reference             reference;\n-      typedef typename _Base::const_reference       const_reference;\n+      typedef _Key\t\t\t\t\tkey_type;\n+      typedef _Key\t\t\t\t\tvalue_type;\n+      typedef _Compare\t\t\t\t\tkey_compare;\n+      typedef _Compare\t\t\t\t\tvalue_compare;\n+      typedef _Allocator\t\t\t\tallocator_type;\n+      typedef typename _Base::reference\t\t\treference;\n+      typedef typename _Base::const_reference\t\tconst_reference;\n \n       typedef __gnu_debug::_Safe_iterator<_Base_iterator, set>\n-                                                    iterator;\n+\t\t\t\t\t\t\titerator;\n       typedef __gnu_debug::_Safe_iterator<_Base_const_iterator, set>\n-                                                    const_iterator;\n+\t\t\t\t\t\t\tconst_iterator;\n \n-      typedef typename _Base::size_type             size_type;\n-      typedef typename _Base::difference_type       difference_type;\n-      typedef typename _Base::pointer               pointer;\n-      typedef typename _Base::const_pointer         const_pointer;\n-      typedef std::reverse_iterator<iterator>       reverse_iterator;\n-      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::difference_type\t\tdifference_type;\n+      typedef typename _Base::pointer\t\t\tpointer;\n+      typedef typename _Base::const_pointer\t\tconst_pointer;\n+      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n \n       // 23.3.3.1 construct/copy/destroy:\n \n+#if __cplusplus < 201103L\n       set() : _Base() { }\n \n-      explicit set(const _Compare& __comp,\n-\t\t   const _Allocator& __a = _Allocator())\n-      : _Base(__comp, __a) { }\n-\n-      template<typename _InputIterator>\n-        set(_InputIterator __first, _InputIterator __last,\n-\t    const _Compare& __comp = _Compare(),\n-\t    const _Allocator& __a = _Allocator())\n-\t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n-\t\t\t\t\t\t\t\t     __last)),\n-\t\t__gnu_debug::__base(__last),\n-\t\t__comp, __a) { }\n-\n       set(const set& __x)\n       : _Base(__x) { }\n \n-      set(const _Base& __x)\n-      : _Base(__x) { }\n-\n-#if __cplusplus >= 201103L\n-      set(set&& __x)\n-      noexcept(is_nothrow_copy_constructible<_Compare>::value)\n-      : _Base(std::move(__x))\n-      { this->_M_swap(__x); }\n+      ~set() { }\n+#else\n+      set() = default;\n+      set(const set&) = default;\n+      set(set&&) = default;\n \n       set(initializer_list<value_type> __l,\n \t  const _Compare& __comp = _Compare(),\n@@ -117,47 +104,52 @@ namespace __debug\n       : _Base(__x, __a) { }\n \n       set(set&& __x, const allocator_type& __a)\n-      : _Base(std::move(__x._M_base()), __a) { }\n+      : _Safe(std::move(__x._M_safe()), __a),\n+\t_Base(std::move(__x._M_base()), __a) { }\n \n       set(initializer_list<value_type> __l, const allocator_type& __a)\n-\t: _Base(__l, __a)\n-      { }\n+      : _Base(__l, __a) { }\n \n       template<typename _InputIterator>\n-        set(_InputIterator __first, _InputIterator __last,\n+\tset(_InputIterator __first, _InputIterator __last,\n \t    const allocator_type& __a)\n \t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n \t\t\t\t\t\t\t\t     __last)),\n-\t\t__gnu_debug::__base(__last), __a)\n-        { }\n+\t\t__gnu_debug::__base(__last), __a) { }\n+\n+      ~set() = default;\n #endif\n \n-      ~set() _GLIBCXX_NOEXCEPT { }\n+      explicit set(const _Compare& __comp,\n+\t\t   const _Allocator& __a = _Allocator())\n+      : _Base(__comp, __a) { }\n+\n+      template<typename _InputIterator>\n+\tset(_InputIterator __first, _InputIterator __last,\n+\t    const _Compare& __comp = _Compare(),\n+\t    const _Allocator& __a = _Allocator())\n+\t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n+\t\t\t\t\t\t\t\t     __last)),\n+\t\t__gnu_debug::__base(__last),\n+\t\t__comp, __a) { }\n \n+      set(const _Base& __x)\n+      : _Base(__x) { }\n+\n+#if __cplusplus < 201103L\n       set&\n       operator=(const set& __x)\n       {\n+\tthis->_M_safe() = __x;\n \t_M_base() = __x;\n-\tthis->_M_invalidate_all();\n \treturn *this;\n       }\n+#else\n+      set&\n+      operator=(const set&) = default;\n \n-#if __cplusplus >= 201103L\n       set&\n-      operator=(set&& __x)\n-      noexcept(_Alloc_traits::_S_nothrow_move())\n-      {\n-\t__glibcxx_check_self_move_assign(__x);\n-\tbool __xfer_memory = _Alloc_traits::_S_propagate_on_move_assign()\n-\t    || __x.get_allocator() == this->get_allocator();\n-\t_M_base() = std::move(__x._M_base());\n-\tif (__xfer_memory)\n-\t  this->_M_swap(__x);\n-\telse\n-\t  this->_M_invalidate_all();\n-\t__x._M_invalidate_all();\n-\treturn *this;\n-      }\n+      operator=(set&&) = default;\n \n       set&\n       operator=(initializer_list<value_type> __l)\n@@ -285,9 +277,9 @@ namespace __debug\n #endif\n \n       template <typename _InputIterator>\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        {\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{\n \t  __glibcxx_check_valid_range(__first, __last);\n \t  _Base::insert(__gnu_debug::__base(__first),\n \t\t\t__gnu_debug::__base(__last));\n@@ -322,7 +314,7 @@ namespace __debug\n       {\n \t_Base_iterator __victim = _Base::find(__x);\n \tif (__victim == _Base::end())\n-          return 0;\n+\t  return 0;\n \telse\n \t  {\n \t    this->_M_invalidate_if(_Equal(__victim));\n@@ -372,15 +364,11 @@ namespace __debug\n       void\n       swap(set& __x)\n #if __cplusplus >= 201103L\n-      noexcept(_Alloc_traits::_S_nothrow_swap())\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n #endif\n       {\n-#if __cplusplus >= 201103L\n-\tif (!_Alloc_traits::_S_propagate_on_swap())\n-\t  __glibcxx_check_equal_allocs(__x);\n-#endif\n+\t_Safe::_M_swap(__x);\n \t_Base::swap(__x);\n-\tthis->_M_swap(__x);\n       }\n \n       void\n@@ -431,7 +419,7 @@ namespace __debug\n       equal_range(const key_type& __x)\n       {\n \tstd::pair<_Base_iterator, _Base_iterator> __res =\n-        _Base::equal_range(__x);\n+\t_Base::equal_range(__x);\n \treturn std::make_pair(iterator(__res.first, this),\n \t\t\t      iterator(__res.second, this));\n       }\n@@ -442,24 +430,16 @@ namespace __debug\n       equal_range(const key_type& __x) const\n       {\n \tstd::pair<_Base_iterator, _Base_iterator> __res =\n-        _Base::equal_range(__x);\n+\t_Base::equal_range(__x);\n \treturn std::make_pair(const_iterator(__res.first, this),\n \t\t\t      const_iterator(__res.second, this));\n       }\n \n       _Base&\n-      _M_base() _GLIBCXX_NOEXCEPT       { return *this; }\n+      _M_base() _GLIBCXX_NOEXCEPT\t{ return *this; }\n \n       const _Base&\n-      _M_base() const _GLIBCXX_NOEXCEPT { return *this; }\n-\n-    private:\n-      void\n-      _M_invalidate_all()\n-      {\n-\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n-      }\n+      _M_base() const _GLIBCXX_NOEXCEPT\t{ return *this; }\n     };\n \n   template<typename _Key, typename _Compare, typename _Allocator>"}, {"sha": "8510ee4b59abf0c60d65d54ebca162935d06ef9a", "filename": "libstdc++-v3/include/debug/string", "status": "modified", "additions": 72, "deletions": 78, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fstring", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fstring", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fstring?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -31,140 +31,136 @@\n \n #include <string>\n #include <debug/safe_sequence.h>\n+#include <debug/safe_container.h>\n #include <debug/safe_iterator.h>\n \n namespace __gnu_debug\n {\n   /// Class std::basic_string with safety/checking/debug instrumentation.\n   template<typename _CharT, typename _Traits = std::char_traits<_CharT>,\n-            typename _Allocator = std::allocator<_CharT> >\n+\t   typename _Allocator = std::allocator<_CharT> >\n     class basic_string\n-    : public std::basic_string<_CharT, _Traits, _Allocator>,\n-      public __gnu_debug::_Safe_sequence<basic_string<_CharT, _Traits,\n-\t\t\t\t\t\t      _Allocator> >\n+    : public __gnu_debug::_Safe_container<\n+\tbasic_string<_CharT, _Traits, _Allocator>,\n+\t_Allocator, _Safe_sequence, false>,\n+      public std::basic_string<_CharT, _Traits, _Allocator>\n     {\n-      typedef std::basic_string<_CharT, _Traits, _Allocator> _Base;\n-      typedef __gnu_debug::_Safe_sequence<basic_string>     _Safe_base;\n+      typedef std::basic_string<_CharT, _Traits, _Allocator>\t_Base;\n+      typedef __gnu_debug::_Safe_container<\n+\tbasic_string, _Allocator, _Safe_sequence, false>\t_Safe;\n \n   public:\n     // types:\n-    typedef _Traits\t\t\t\t       traits_type;\n-    typedef typename _Traits::char_type\t\t       value_type;\n-    typedef _Allocator\t\t\t\t       allocator_type;\n-    typedef typename _Base::size_type                  size_type;\n-    typedef typename _Base::difference_type            difference_type;\n-    typedef typename _Base::reference                  reference;\n-    typedef typename _Base::const_reference            const_reference;\n-    typedef typename _Base::pointer                    pointer;\n-    typedef typename _Base::const_pointer              const_pointer;\n-\n-    typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, basic_string>\n-                                                       iterator;\n-    typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n-                                         basic_string> const_iterator;\n-\n-    typedef std::reverse_iterator<iterator>            reverse_iterator;\n-    typedef std::reverse_iterator<const_iterator>      const_reverse_iterator;\n+    typedef _Traits\t\t\t\t\ttraits_type;\n+    typedef typename _Traits::char_type\t\t\tvalue_type;\n+    typedef _Allocator\t\t\t\t\tallocator_type;\n+    typedef typename _Base::size_type\t\t\tsize_type;\n+    typedef typename _Base::difference_type\t\tdifference_type;\n+    typedef typename _Base::reference\t\t\treference;\n+    typedef typename _Base::const_reference\t\tconst_reference;\n+    typedef typename _Base::pointer\t\t\tpointer;\n+    typedef typename _Base::const_pointer\t\tconst_pointer;\n+\n+    typedef __gnu_debug::_Safe_iterator<\n+      typename _Base::iterator, basic_string>\t\titerator;\n+    typedef __gnu_debug::_Safe_iterator<\n+      typename _Base::const_iterator, basic_string>\tconst_iterator;\n+\n+    typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n+    typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n \n     using _Base::npos;\n \n     // 21.3.1 construct/copy/destroy:\n     explicit basic_string(const _Allocator& __a = _Allocator())\n     // _GLIBCXX_NOEXCEPT\n-    : _Base(__a)\n-    { }\n-\n-    // Provides conversion from a release-mode string to a debug-mode string\n-    basic_string(const _Base& __base) : _Base(__base) { }\n+    : _Base(__a) { }\n \n-    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-    // 42. string ctors specify wrong default allocator\n+#if __cplusplus < 201103L\n     basic_string(const basic_string& __str)\n-    : _Base(__str, 0, _Base::npos, __str.get_allocator())\n+    : _Base(__str) { }\n+\n+    ~basic_string() { }\n+#else\n+    basic_string(const basic_string&) = default;\n+    basic_string(basic_string&&) = default;\n+\n+    basic_string(std::initializer_list<_CharT> __l,\n+\t\t const _Allocator& __a = _Allocator())\n+    : _Base(__l, __a)\n     { }\n \n+    ~basic_string() = default;\n+#endif // C++11\n+\n+    // Provides conversion from a normal-mode string to a debug-mode string\n+    basic_string(const _Base& __base)\n+    : _Base(__base) { }\n+\n     // _GLIBCXX_RESOLVE_LIB_DEFECTS\n     // 42. string ctors specify wrong default allocator\n     basic_string(const basic_string& __str, size_type __pos,\n-\t\t   size_type __n = _Base::npos,\n-\t\t   const _Allocator& __a = _Allocator())\n-    : _Base(__str, __pos, __n, __a)\n-    { }\n+\t\t size_type __n = _Base::npos,\n+\t\t const _Allocator& __a = _Allocator())\n+    : _Base(__str, __pos, __n, __a) { }\n \n     basic_string(const _CharT* __s, size_type __n,\n \t\t   const _Allocator& __a = _Allocator())\n-    : _Base(__gnu_debug::__check_string(__s, __n), __n, __a)\n-    { }\n+    : _Base(__gnu_debug::__check_string(__s, __n), __n, __a) { }\n \n     basic_string(const _CharT* __s, const _Allocator& __a = _Allocator())\n     : _Base(__gnu_debug::__check_string(__s), __a)\n     { this->assign(__s); }\n \n     basic_string(size_type __n, _CharT __c,\n \t\t   const _Allocator& __a = _Allocator())\n-    : _Base(__n, __c, __a)\n-    { }\n+    : _Base(__n, __c, __a) { }\n \n     template<typename _InputIterator>\n       basic_string(_InputIterator __begin, _InputIterator __end,\n \t\t   const _Allocator& __a = _Allocator())\n       : _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__begin,\n \t\t\t\t\t\t\t\t   __end)),\n-\t      __gnu_debug::__base(__end), __a)\n-      { }\n-\n-#if __cplusplus >= 201103L\n-    basic_string(basic_string&& __str) // noexcept\n-    : _Base(std::move(__str))\n-    { }\n-\n-    basic_string(std::initializer_list<_CharT> __l,\n-\t\t const _Allocator& __a = _Allocator())\n-    : _Base(__l, __a)\n-    { }\n-#endif // C++11\n-\n-    ~basic_string() _GLIBCXX_NOEXCEPT { }\n+\t      __gnu_debug::__base(__end), __a) { }\n \n+#if __cplusplus < 201103L\n     basic_string&\n     operator=(const basic_string& __str)\n     {\n-      *static_cast<_Base*>(this) = __str;\n-      this->_M_invalidate_all();\n+      this->_M_safe() = __str;\n+      _M_base() = __str;\n       return *this;\n     }\n+#else\n+    basic_string&\n+    operator=(const basic_string&) = default;\n+\n+    basic_string&\n+    operator=(basic_string&&) = default;\n+#endif\n \n     basic_string&\n     operator=(const _CharT* __s)\n     {\n       __glibcxx_check_string(__s);\n-      *static_cast<_Base*>(this) = __s;\n+      _M_base() = __s;\n       this->_M_invalidate_all();\n       return *this;\n     }\n \n     basic_string&\n     operator=(_CharT __c)\n     {\n-      *static_cast<_Base*>(this) = __c;\n+      _M_base() = __c;\n       this->_M_invalidate_all();\n       return *this;\n     }\n \n #if __cplusplus >= 201103L\n-    basic_string&\n-    operator=(basic_string&& __str)\n-    {\n-      __glibcxx_check_self_move_assign(__str);\n-      *static_cast<_Base*>(this) = std::move(__str);\n-      this->_M_invalidate_all();\n-      return *this;\n-    }\n-\n     basic_string&\n     operator=(std::initializer_list<_CharT> __l)\n     {\n-      *static_cast<_Base*>(this) = __l;\n+      _M_base() = __l;\n       this->_M_invalidate_all();\n       return *this;\n     }\n@@ -576,7 +572,7 @@ namespace __gnu_debug\n       // 151. can't currently clear() empty container\n       __glibcxx_check_erase_range(__first, __last);\n       typename _Base::iterator __res = _Base::erase(__first.base(),\n-\t\t\t\t\t\t       __last.base());\n+\t\t\t\t\t\t    __last.base());\n       this->_M_invalidate_all();\n       return iterator(__res, this);\n     }\n@@ -704,12 +700,10 @@ namespace __gnu_debug\n     }\n \n     void\n-    swap(basic_string<_CharT,_Traits,_Allocator>& __x)\n+    swap(basic_string& __x)\n     {\n+      _Safe::_M_swap(__x);\n       _Base::swap(__x);\n-      this->_M_swap(__x);\n-      this->_M_invalidate_all();\n-      __x._M_invalidate_all();\n     }\n \n     // 21.3.6 string operations:\n@@ -801,7 +795,7 @@ namespace __gnu_debug\n     { return _Base::find_first_of(__c, __pos); }\n \n     size_type\n-    find_last_of(const basic_string& __str, \n+    find_last_of(const basic_string& __str,\n \t\t size_type __pos = _Base::npos) const _GLIBCXX_NOEXCEPT\n     { return _Base::find_last_of(__str, __pos); }\n \n@@ -910,19 +904,19 @@ namespace __gnu_debug\n     //  5. string::compare specification questionable\n     int\n     compare(size_type __pos1, size_type __n1,const _CharT* __s,\n-\t      size_type __n2) const\n+\t    size_type __n2) const\n     {\n       __glibcxx_check_string_len(__s, __n2);\n       return _Base::compare(__pos1, __n1, __s, __n2);\n     }\n \n     _Base&\n-    _M_base() _GLIBCXX_NOEXCEPT       { return *this; }\n+    _M_base() _GLIBCXX_NOEXCEPT\t\t{ return *this; }\n \n     const _Base&\n-    _M_base() const _GLIBCXX_NOEXCEPT { return *this; }\n+    _M_base() const _GLIBCXX_NOEXCEPT\t{ return *this; }\n \n-    using _Safe_base::_M_invalidate_all;\n+    using _Safe::_M_invalidate_all;\n   };\n \n   template<typename _CharT, typename _Traits, typename _Allocator>"}, {"sha": "b1596e2907065c13ce309a9c9e8696bc09c27c16", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 88, "deletions": 170, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -35,6 +35,7 @@\n # include <unordered_map>\n \n #include <debug/safe_unordered_container.h>\n+#include <debug/safe_container.h>\n #include <debug/safe_iterator.h>\n #include <debug/safe_local_iterator.h>\n \n@@ -48,38 +49,38 @@ namespace __debug\n \t   typename _Pred = std::equal_to<_Key>,\n \t   typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n     class unordered_map\n-    : public _GLIBCXX_STD_C::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>,\n-      public __gnu_debug::_Safe_unordered_container<unordered_map<_Key, _Tp,\n-\t\t\t\t\t\t\t_Hash, _Pred, _Alloc> >\n+    : public __gnu_debug::_Safe_container<\n+\tunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>, _Alloc,\n+\t__gnu_debug::_Safe_unordered_container>,\n+      public _GLIBCXX_STD_C::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\n     {\n       typedef _GLIBCXX_STD_C::unordered_map<_Key, _Tp, _Hash,\n-\t\t\t\t\t    _Pred, _Alloc> _Base;\n-      typedef __gnu_debug::_Safe_unordered_container<unordered_map> _Safe_base;\n-      typedef typename _Base::const_iterator _Base_const_iterator;\n-      typedef typename _Base::iterator _Base_iterator;\n-      typedef typename _Base::const_local_iterator _Base_const_local_iterator;\n-      typedef typename _Base::local_iterator _Base_local_iterator;\n-\n-      typedef __gnu_cxx::__alloc_traits<typename\n-\t\t\t\t\t_Base::allocator_type> _Alloc_traits;\n+\t\t\t\t\t    _Pred, _Alloc>\t\t_Base;\n+      typedef __gnu_debug::_Safe_container<unordered_map,\n+\t\t   _Alloc, __gnu_debug::_Safe_unordered_container>\t_Safe;\n+      typedef typename _Base::const_iterator\t_Base_const_iterator;\n+      typedef typename _Base::iterator\t\t_Base_iterator;\n+      typedef typename _Base::const_local_iterator\n+\t\t\t\t\t\t_Base_const_local_iterator;\n+      typedef typename _Base::local_iterator\t_Base_local_iterator;\n \n     public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-\n-      typedef typename _Base::key_type        key_type;\n-      typedef typename _Base::value_type      value_type;\n-\n-      typedef __gnu_debug::_Safe_iterator<_Base_iterator,\n-\t\t\t\t\t  unordered_map> iterator;\n-      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n-\t\t\t\t\t  unordered_map> const_iterator;\n-      typedef __gnu_debug::_Safe_local_iterator<_Base_local_iterator,\n-\t\t\t\t\t  unordered_map> local_iterator;\n-      typedef __gnu_debug::_Safe_local_iterator<_Base_const_local_iterator,\n-\t\t\t\t\t  unordered_map> const_local_iterator;\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::hasher\t\t\thasher;\n+      typedef typename _Base::key_equal\t\t\tkey_equal;\n+      typedef typename _Base::allocator_type\t\tallocator_type;\n+\n+      typedef typename _Base::key_type\t\t\tkey_type;\n+      typedef typename _Base::value_type\t\tvalue_type;\n+\n+      typedef __gnu_debug::_Safe_iterator<\n+\t_Base_iterator, unordered_map>\t\t\titerator;\n+      typedef __gnu_debug::_Safe_iterator<\n+\t_Base_const_iterator, unordered_map>\t\tconst_iterator;\n+      typedef __gnu_debug::_Safe_local_iterator<\n+\t_Base_local_iterator, unordered_map>\t\tlocal_iterator;\n+      typedef __gnu_debug::_Safe_local_iterator<\n+\t_Base_const_local_iterator, unordered_map>\tconst_local_iterator;\n \n       explicit\n       unordered_map(size_type __n = 10,\n@@ -89,10 +90,10 @@ namespace __debug\n       : _Base(__n, __hf, __eql, __a) { }\n \n       template<typename _InputIterator>\n-\tunordered_map(_InputIterator __first, _InputIterator __last, \n+\tunordered_map(_InputIterator __first, _InputIterator __last,\n \t\t      size_type __n = 0,\n-\t\t      const hasher& __hf = hasher(), \n-\t\t      const key_equal& __eql = key_equal(), \n+\t\t      const hasher& __hf = hasher(),\n+\t\t      const key_equal& __eql = key_equal(),\n \t\t      const allocator_type& __a = allocator_type())\n \t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n \t\t\t\t\t\t\t\t     __last)),\n@@ -108,18 +109,16 @@ namespace __debug\n \n       explicit\n       unordered_map(const allocator_type& __a)\n-\t: _Base(__a)\n-      { }\n+      : _Base(__a) { }\n \n       unordered_map(const unordered_map& __umap,\n \t\t    const allocator_type& __a)\n-\t: _Base(__umap._M_base(), __a)\n-      { }\n+      : _Base(__umap, __a) { }\n \n       unordered_map(unordered_map&& __umap,\n \t\t    const allocator_type& __a)\n-\t: _Base(std::move(__umap._M_base()), __a)\n-      { }\n+      : _Safe(std::move(__umap._M_safe()), __a),\n+\t_Base(std::move(__umap._M_base()), __a) { }\n \n       unordered_map(initializer_list<value_type> __l,\n \t\t    size_type __n = 0,\n@@ -128,31 +127,13 @@ namespace __debug\n \t\t    const allocator_type& __a = allocator_type())\n       : _Base(__l, __n, __hf, __eql, __a) { }\n \n-      ~unordered_map() noexcept { }\n+      ~unordered_map() = default;\n \n       unordered_map&\n-      operator=(const unordered_map& __x)\n-      {\n-\t_M_base() = __x._M_base();\n-\tthis->_M_invalidate_all();\n-\treturn *this;\n-      }\n+      operator=(const unordered_map&) = default;\n \n       unordered_map&\n-      operator=(unordered_map&& __x)\n-      noexcept(_Alloc_traits::_S_nothrow_move())\n-      {\n-\t__glibcxx_check_self_move_assign(__x);\n-\tbool __xfer_memory = _Alloc_traits::_S_propagate_on_move_assign()\n-\t    || __x.get_allocator() == this->get_allocator();\n-\t_M_base() = std::move(__x._M_base());\t\n-\tif (__xfer_memory)\n-\t  this->_M_swap(__x);\n-\telse\n-\t  this->_M_invalidate_all();\n-\t__x._M_invalidate_all();\n-\treturn *this;\n-      }\n+      operator=(unordered_map&&) = default;\n \n       unordered_map&\n       operator=(initializer_list<value_type> __l)\n@@ -164,12 +145,10 @@ namespace __debug\n \n       void\n       swap(unordered_map& __x)\n-      noexcept(_Alloc_traits::_S_nothrow_swap())\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n       {\n-\tif (!_Alloc_traits::_S_propagate_on_swap())\n-\t  __glibcxx_check_equal_allocs(__x);\n+\t_Safe::_M_swap(__x);\n \t_Base::swap(__x);\n-\t_Safe_base::_M_swap(__x);\n       }\n \n       void\n@@ -179,7 +158,7 @@ namespace __debug\n \tthis->_M_invalidate_all();\n       }\n \n-      iterator \n+      iterator\n       begin() noexcept\n       { return iterator(_Base::begin(), this); }\n \n@@ -301,7 +280,7 @@ namespace __debug\n       {\n \t__glibcxx_check_insert(__hint);\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __it = _Base::insert(__hint.base(), __obj); \n+\t_Base_iterator __it = _Base::insert(__hint.base(), __obj);\n \t_M_check_rehashed(__bucket_count);\n \treturn iterator(__it, this);\n       }\n@@ -348,7 +327,7 @@ namespace __debug\n \t  __glibcxx_check_valid_range(__first, __last);\n \t  size_type __bucket_count = this->bucket_count();\n \t  _Base::insert(__gnu_debug::__base(__first),\n-\t\t\t__gnu_debug::__base(__last));\n+\t\t\t  __gnu_debug::__base(__last));\n \t  _M_check_rehashed(__bucket_count);\n \t}\n \n@@ -409,7 +388,7 @@ namespace __debug\n \t\t\t[__victim](_Base_const_local_iterator __it)\n \t\t\t{ return __it._M_curr() == __victim._M_cur; });\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __next = _Base::erase(__it.base()); \n+\t_Base_iterator __next = _Base::erase(__it.base());\n \t_M_check_rehashed(__bucket_count);\n \treturn iterator(__next, this);\n       }\n@@ -442,35 +421,17 @@ namespace __debug\n       }\n \n       _Base&\n-      _M_base() noexcept       { return *this; }\n+      _M_base() noexcept\t{ return *this; }\n \n       const _Base&\n-      _M_base() const noexcept { return *this; }\n+      _M_base() const noexcept\t{ return *this; }\n \n     private:\n-      void\n-      _M_invalidate_locals()\n-      {\n-\t_Base_local_iterator __local_end = _Base::end(0);\n-\tthis->_M_invalidate_local_if(\n-\t\t\t[__local_end](_Base_const_local_iterator __it)\n-\t\t\t{ return __it != __local_end; });\n-      }\n-\n-      void\n-      _M_invalidate_all()\n-      {\n-\t_Base_iterator __end = _Base::end();\n-\tthis->_M_invalidate_if([__end](_Base_const_iterator __it)\n-\t\t\t{ return __it != __end; });\n-\t_M_invalidate_locals();\n-      }\n-\n       void\n       _M_check_rehashed(size_type __prev_count)\n       {\n \tif (__prev_count != this->bucket_count())\n-\t  _M_invalidate_locals();\n+\t  this->_M_invalidate_locals();\n       }\n     };\n \n@@ -502,38 +463,35 @@ namespace __debug\n \t   typename _Pred = std::equal_to<_Key>,\n \t   typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n     class unordered_multimap\n-    : public _GLIBCXX_STD_C::unordered_multimap<_Key, _Tp, _Hash,\n-\t\t\t\t\t\t_Pred, _Alloc>,\n-      public __gnu_debug::_Safe_unordered_container<unordered_multimap<_Key,\n-\t\t\t\t\t\t_Tp, _Hash, _Pred, _Alloc> >\n+      : public __gnu_debug::_Safe_container<\n+\tunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>, _Alloc,\n+\t__gnu_debug::_Safe_unordered_container>,\n+\tpublic _GLIBCXX_STD_C::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\n     {\n       typedef _GLIBCXX_STD_C::unordered_multimap<_Key, _Tp, _Hash,\n-\t\t\t\t\t\t _Pred, _Alloc> _Base;\n-      typedef __gnu_debug::_Safe_unordered_container<unordered_multimap>\n-\t_Safe_base;\n-      typedef typename _Base::const_iterator _Base_const_iterator;\n-      typedef typename _Base::iterator _Base_iterator;\n+\t\t\t\t\t\t _Pred, _Alloc>\t\t_Base;\n+      typedef __gnu_debug::_Safe_container<unordered_multimap,\n+\t_Alloc, __gnu_debug::_Safe_unordered_container>\t\t\t_Safe;\n+      typedef typename _Base::const_iterator\t   _Base_const_iterator;\n+      typedef typename _Base::iterator\t\t   _Base_iterator;\n       typedef typename _Base::const_local_iterator _Base_const_local_iterator;\n-      typedef typename _Base::local_iterator _Base_local_iterator;\n-\n-      typedef __gnu_cxx::__alloc_traits<typename\n-\t\t\t\t\t_Base::allocator_type> _Alloc_traits;\n+      typedef typename _Base::local_iterator\t   _Base_local_iterator;\n \n     public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-\n-      typedef typename _Base::key_type        key_type;\n-      typedef typename _Base::value_type      value_type;\n-\n-      typedef __gnu_debug::_Safe_iterator<_Base_iterator,\n-\t\t\t\t\t  unordered_multimap> iterator;\n-      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n-\t\t\t\t\t  unordered_multimap> const_iterator;\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::hasher\t\t\thasher;\n+      typedef typename _Base::key_equal\t\t\tkey_equal;\n+      typedef typename _Base::allocator_type\t\tallocator_type;\n+\n+      typedef typename _Base::key_type\t\t\tkey_type;\n+      typedef typename _Base::value_type\t\tvalue_type;\n+\n+      typedef __gnu_debug::_Safe_iterator<\n+\t_Base_iterator, unordered_multimap>\t\titerator;\n+      typedef __gnu_debug::_Safe_iterator<\n+\t_Base_const_iterator, unordered_multimap>\tconst_iterator;\n       typedef __gnu_debug::_Safe_local_iterator<\n-\t_Base_local_iterator, unordered_multimap> local_iterator;\n+\t_Base_local_iterator, unordered_multimap>\tlocal_iterator;\n       typedef __gnu_debug::_Safe_local_iterator<\n \t_Base_const_local_iterator, unordered_multimap> const_local_iterator;\n \n@@ -545,10 +503,10 @@ namespace __debug\n       : _Base(__n, __hf, __eql, __a) { }\n \n       template<typename _InputIterator>\n-\tunordered_multimap(_InputIterator __first, _InputIterator __last, \n+\tunordered_multimap(_InputIterator __first, _InputIterator __last,\n \t\t\t   size_type __n = 0,\n-\t\t\t   const hasher& __hf = hasher(), \n-\t\t\t   const key_equal& __eql = key_equal(), \n+\t\t\t   const hasher& __hf = hasher(),\n+\t\t\t   const key_equal& __eql = key_equal(),\n \t\t\t   const allocator_type& __a = allocator_type())\n \t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n \t\t\t\t\t\t\t\t     __last)),\n@@ -557,25 +515,23 @@ namespace __debug\n \n       unordered_multimap(const unordered_multimap&) = default;\n \n-      unordered_multimap(const _Base& __x) \n+      unordered_multimap(const _Base& __x)\n       : _Base(__x) { }\n \n       unordered_multimap(unordered_multimap&&) = default;\n \n       explicit\n       unordered_multimap(const allocator_type& __a)\n-\t: _Base(__a)\n-      { }\n+      : _Base(__a) { }\n \n       unordered_multimap(const unordered_multimap& __umap,\n \t\t\t const allocator_type& __a)\n-\t: _Base(__umap._M_base(), __a)\n-      { }\n+      : _Base(__umap, __a) { }\n \n       unordered_multimap(unordered_multimap&& __umap,\n \t\t\t const allocator_type& __a)\n-\t: _Base(std::move(__umap._M_base()), __a)\n-      { }\n+      : _Safe(std::move(__umap._M_safe()), __a),\n+\t_Base(std::move(__umap._M_base()), __a) { }\n \n       unordered_multimap(initializer_list<value_type> __l,\n \t\t\t size_type __n = 0,\n@@ -584,48 +540,28 @@ namespace __debug\n \t\t\t const allocator_type& __a = allocator_type())\n       : _Base(__l, __n, __hf, __eql, __a) { }\n \n-      ~unordered_multimap() noexcept { }\n+      ~unordered_multimap() = default;\n \n       unordered_multimap&\n-      operator=(const unordered_multimap& __x)\n-      {\n-\t_M_base() = __x._M_base();\n-\tthis->_M_invalidate_all();\n-\treturn *this;\n-      }\n+      operator=(const unordered_multimap&) = default;\n \n       unordered_multimap&\n-      operator=(unordered_multimap&& __x)\n-      noexcept(_Alloc_traits::_S_nothrow_move())\n-      {\n-\t__glibcxx_check_self_move_assign(__x);\n-\tbool __xfer_memory = _Alloc_traits::_S_propagate_on_move_assign()\n-\t    || __x.get_allocator() == this->get_allocator();\n-\t_M_base() = std::move(__x._M_base());\n-\tif (__xfer_memory)\n-\t  this->_M_swap(__x);\n-\telse\n-\t  this->_M_invalidate_all();\n-\t__x._M_invalidate_all();\n-\treturn *this;\n-      }\n+      operator=(unordered_multimap&&) = default;\n \n       unordered_multimap&\n       operator=(initializer_list<value_type> __l)\n       {\n-\t_M_base() = __l;\n+\tthis->_M_base() = __l;\n \tthis->_M_invalidate_all();\n \treturn *this;\n       }\n \n       void\n       swap(unordered_multimap& __x)\n-      noexcept(_Alloc_traits::_S_nothrow_swap())\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n       {\n-\tif (!_Alloc_traits::_S_propagate_on_swap())\n-\t  __glibcxx_check_equal_allocs(__x);\n+\t_Safe::_M_swap(__x);\n \t_Base::swap(__x);\n-\t_Safe_base::_M_swap(__x);\n       }\n \n       void\n@@ -635,7 +571,7 @@ namespace __debug\n \tthis->_M_invalidate_all();\n       }\n \n-      iterator \n+      iterator\n       begin() noexcept\n       { return iterator(_Base::begin(), this); }\n \n@@ -894,35 +830,17 @@ namespace __debug\n       }\n \n       _Base&\n-      _M_base() noexcept       { return *this; }\n+      _M_base() noexcept { return *this; }\n \n       const _Base&\n       _M_base() const noexcept { return *this; }\n \n     private:\n-      void\n-      _M_invalidate_locals()\n-      {\n-\t_Base_local_iterator __local_end = _Base::end(0);\n-\tthis->_M_invalidate_local_if(\n-\t\t\t[__local_end](_Base_const_local_iterator __it)\n-\t\t\t{ return __it != __local_end; });\n-      }\n-\n-      void\n-      _M_invalidate_all()\n-      {\n-\t_Base_iterator __end = _Base::end();\n-\tthis->_M_invalidate_if([__end](_Base_const_iterator __it)\n-\t\t\t{ return __it != __end; });\n-\t_M_invalidate_locals();\n-      }\n-\n       void\n       _M_check_rehashed(size_type __prev_count)\n       {\n \tif (__prev_count != this->bucket_count())\n-\t  _M_invalidate_locals();\n+\t  this->_M_invalidate_locals();\n       }\n     };\n "}, {"sha": "63a687760849ceb29877d7fd112262b52006cc10", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 100, "deletions": 180, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -35,6 +35,7 @@\n # include <unordered_set>\n \n #include <debug/safe_unordered_container.h>\n+#include <debug/safe_container.h>\n #include <debug/safe_iterator.h>\n #include <debug/safe_local_iterator.h>\n \n@@ -48,37 +49,38 @@ namespace __debug\n \t   typename _Pred = std::equal_to<_Value>,\n \t   typename _Alloc = std::allocator<_Value> >\n     class unordered_set\n-    : public _GLIBCXX_STD_C::unordered_set<_Value, _Hash, _Pred, _Alloc>,\n-      public __gnu_debug::_Safe_unordered_container<unordered_set<_Value, _Hash,\n-\t\t\t\t\t\t       _Pred, _Alloc> >\n+    : public __gnu_debug::_Safe_container<\n+\tunordered_set<_Value, _Hash, _Pred, _Alloc>, _Alloc,\n+\t__gnu_debug::_Safe_unordered_container>,\n+      public _GLIBCXX_STD_C::unordered_set<_Value, _Hash, _Pred, _Alloc>\n     {\n-      typedef _GLIBCXX_STD_C::unordered_set<_Value, _Hash,\n-\t\t\t\t\t    _Pred, _Alloc> _Base;\n-      typedef __gnu_debug::_Safe_unordered_container<unordered_set> _Safe_base;\n-      typedef typename _Base::const_iterator _Base_const_iterator;\n-      typedef typename _Base::iterator _Base_iterator;\n+      typedef _GLIBCXX_STD_C::unordered_set<\n+\t_Value, _Hash, _Pred, _Alloc>\t\t\t\t\t_Base;\n+      typedef __gnu_debug::_Safe_container<\n+\tunordered_set, _Alloc, __gnu_debug::_Safe_unordered_container>\t_Safe;\n+\n+      typedef typename _Base::const_iterator\t   _Base_const_iterator;\n+      typedef typename _Base::iterator\t\t   _Base_iterator;\n       typedef typename _Base::const_local_iterator _Base_const_local_iterator;\n-      typedef typename _Base::local_iterator _Base_local_iterator;\n+      typedef typename _Base::local_iterator\t   _Base_local_iterator;\n \n-      typedef __gnu_cxx::__alloc_traits<typename\n-\t\t\t\t\t_Base::allocator_type> _Alloc_traits;\n     public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-\n-      typedef typename _Base::key_type        key_type;\n-      typedef typename _Base::value_type      value_type;\n-\n-      typedef __gnu_debug::_Safe_iterator<_Base_iterator,\n-\t\t\t\t\t  unordered_set> iterator;\n-      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n-\t\t\t\t\t  unordered_set> const_iterator;\n-      typedef __gnu_debug::_Safe_local_iterator<_Base_local_iterator,\n-\t\t\t\t\t  unordered_set> local_iterator;\n-      typedef __gnu_debug::_Safe_local_iterator<_Base_const_local_iterator,\n-\t\t\t\t\t  unordered_set> const_local_iterator;\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::hasher\t\t\thasher;\n+      typedef typename _Base::key_equal\t\t\tkey_equal;\n+      typedef typename _Base::allocator_type\t\tallocator_type;\n+\n+      typedef typename _Base::key_type\t\t\tkey_type;\n+      typedef typename _Base::value_type\t\tvalue_type;\n+\n+      typedef __gnu_debug::_Safe_iterator<\n+\t_Base_iterator, unordered_set>\t\t\titerator;\n+      typedef __gnu_debug::_Safe_iterator<\n+\t_Base_const_iterator, unordered_set>\t\tconst_iterator;\n+      typedef __gnu_debug::_Safe_local_iterator<\n+\t_Base_local_iterator, unordered_set>\t\tlocal_iterator;\n+      typedef __gnu_debug::_Safe_local_iterator<\n+\t_Base_const_local_iterator, unordered_set>\tconst_local_iterator;\n \n       explicit\n       unordered_set(size_type __n = 10,\n@@ -88,10 +90,10 @@ namespace __debug\n       : _Base(__n, __hf, __eql, __a) { }\n \n       template<typename _InputIterator>\n-        unordered_set(_InputIterator __first, _InputIterator __last, \n+\tunordered_set(_InputIterator __first, _InputIterator __last,\n \t\t      size_type __n = 0,\n-\t\t      const hasher& __hf = hasher(), \n-\t\t      const key_equal& __eql = key_equal(), \n+\t\t      const hasher& __hf = hasher(),\n+\t\t      const key_equal& __eql = key_equal(),\n \t\t      const allocator_type& __a = allocator_type())\n \t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n \t\t\t\t\t\t\t\t     __last)),\n@@ -101,24 +103,22 @@ namespace __debug\n       unordered_set(const unordered_set&) = default;\n \n       unordered_set(const _Base& __x)\n-\t: _Base(__x) { }\n+      : _Base(__x) { }\n \n       unordered_set(unordered_set&&) = default;\n \n       explicit\n       unordered_set(const allocator_type& __a)\n-\t: _Base(__a)\n-      { }\n+      : _Base(__a) { }\n \n       unordered_set(const unordered_set& __uset,\n \t\t    const allocator_type& __a)\n-\t: _Base(__uset._M_base(), __a)\n-      { }\n+      : _Base(__uset, __a) { }\n \n       unordered_set(unordered_set&& __uset,\n \t\t    const allocator_type& __a)\n-\t: _Base(std::move(__uset._M_base()), __a)\n-      { }\n+      : _Safe(std::move(__uset._M_safe()), __a),\n+\t_Base(std::move(__uset._M_base()), __a) { }\n \n       unordered_set(initializer_list<value_type> __l,\n \t\t    size_type __n = 0,\n@@ -127,31 +127,13 @@ namespace __debug\n \t\t    const allocator_type& __a = allocator_type())\n       : _Base(__l, __n, __hf, __eql, __a) { }\n \n-      ~unordered_set() noexcept { }\n+      ~unordered_set() = default;\n \n       unordered_set&\n-      operator=(const unordered_set& __x)\n-      {\n-\t_M_base() = __x._M_base();\n-\tthis->_M_invalidate_all();\n-\treturn *this;\n-      }\n+      operator=(const unordered_set&) = default;\n \n       unordered_set&\n-      operator=(unordered_set&& __x)\n-      noexcept(_Alloc_traits::_S_nothrow_move())\n-      {\n-\t__glibcxx_check_self_move_assign(__x);\n-\tbool __xfer_memory = _Alloc_traits::_S_propagate_on_move_assign()\n-\t    || __x.get_allocator() == this->get_allocator();\n-\t_M_base() = std::move(__x._M_base());\n-\tif (__xfer_memory)\n-\t  this->_M_swap(__x);\n-\telse\n-\t  this->_M_invalidate_all();\n-\t__x._M_invalidate_all();\n-\treturn *this;\n-      }\n+      operator=(unordered_set&&) = default;\n \n       unordered_set&\n       operator=(initializer_list<value_type> __l)\n@@ -163,12 +145,10 @@ namespace __debug\n \n       void\n       swap(unordered_set& __x)\n-      noexcept(_Alloc_traits::_S_nothrow_swap())\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n       {\n-\tif (!_Alloc_traits::_S_propagate_on_swap())\n-\t  __glibcxx_check_equal_allocs(__x);\n+\t_Safe::_M_swap(__x);\n \t_Base::swap(__x);\n-\t_Safe_base::_M_swap(__x);\n       }\n \n       void\n@@ -178,7 +158,7 @@ namespace __debug\n \tthis->_M_invalidate_all();\n       }\n \n-      iterator \n+      iterator\n       begin() noexcept\n       { return iterator(_Base::begin(), this); }\n \n@@ -290,8 +270,8 @@ namespace __debug\n       insert(const value_type& __obj)\n       {\n \tsize_type __bucket_count = this->bucket_count();\n-\ttypedef std::pair<_Base_iterator, bool> __pair_type;\n-\t  __pair_type __res = _Base::insert(__obj);\n+\tstd::pair<_Base_iterator, bool> __res\n+\t  = _Base::insert(__obj);\n \t_M_check_rehashed(__bucket_count);\n \treturn std::make_pair(iterator(__res.first, this), __res.second);\n       }\n@@ -310,8 +290,8 @@ namespace __debug\n       insert(value_type&& __obj)\n       {\n \tsize_type __bucket_count = this->bucket_count();\n-\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n-\t  __pair_type __res = _Base::insert(std::move(__obj));\n+\tstd::pair<_Base_iterator, bool> __res\n+\t  = _Base::insert(std::move(__obj));\n \t_M_check_rehashed(__bucket_count);\n \treturn std::make_pair(iterator(__res.first, this), __res.second);\n       }\n@@ -356,8 +336,8 @@ namespace __debug\n       std::pair<iterator, iterator>\n       equal_range(const key_type& __key)\n       {\n-\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n-\t__pair_type __res = _Base::equal_range(__key);\n+\tstd::pair<_Base_iterator, _Base_iterator> __res\n+\t  = _Base::equal_range(__key);\n \treturn std::make_pair(iterator(__res.first, this),\n \t\t\t      iterator(__res.second, this));\n       }\n@@ -439,36 +419,17 @@ namespace __debug\n       }\n \n       _Base&\n-      _M_base() noexcept       { return *this; }\n+      _M_base() noexcept { return *this; }\n \n       const _Base&\n       _M_base() const noexcept { return *this; }\n \n     private:\n-      void\n-      _M_invalidate_locals()\n-      {\n-\t_Base_local_iterator __local_end = _Base::end(0);\n-\tthis->_M_invalidate_local_if(\n-\t\t\t[__local_end](_Base_const_local_iterator __it)\n-\t\t\t{ return __it != __local_end; });\n-      }\n-\n-      void\n-      _M_invalidate_all()\n-      {\n-\t_Base_iterator __end = _Base::end();\n-\tthis->_M_invalidate_if(\n-\t\t\t[__end](_Base_const_iterator __it)\n-\t\t\t{ return __it != __end; });\n-\t_M_invalidate_locals();\n-      }\n-\n       void\n       _M_check_rehashed(size_type __prev_count)\n       {\n \tif (__prev_count != this->bucket_count())\n-\t  _M_invalidate_locals();\n+\t  this->_M_invalidate_locals();\n       }\n     };\n \n@@ -497,37 +458,36 @@ namespace __debug\n \t   typename _Pred = std::equal_to<_Value>,\n \t   typename _Alloc = std::allocator<_Value> >\n     class unordered_multiset\n-    : public _GLIBCXX_STD_C::unordered_multiset<_Value, _Hash, _Pred, _Alloc>,\n-      public __gnu_debug::_Safe_unordered_container<\n-\t\tunordered_multiset<_Value, _Hash, _Pred, _Alloc> >\n+    : public __gnu_debug::_Safe_container<\n+\tunordered_multiset<_Value, _Hash, _Pred, _Alloc>, _Alloc,\n+\t__gnu_debug::_Safe_unordered_container>,\n+      public _GLIBCXX_STD_C::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\n     {\n-      typedef _GLIBCXX_STD_C::unordered_multiset<_Value, _Hash,\n-\t\t\t\t\t\t _Pred, _Alloc> _Base;\n-      typedef __gnu_debug::_Safe_unordered_container<unordered_multiset>\n-\t\t_Safe_base;\n-      typedef typename _Base::const_iterator _Base_const_iterator;\n-      typedef typename _Base::iterator _Base_iterator;\n-      typedef typename _Base::const_local_iterator _Base_const_local_iterator;\n-      typedef typename _Base::local_iterator _Base_local_iterator;\n-\n-      typedef __gnu_cxx::__alloc_traits<typename\n-\t\t\t\t\t_Base::allocator_type> _Alloc_traits;\n+      typedef _GLIBCXX_STD_C::unordered_multiset<\n+\t_Value, _Hash, _Pred, _Alloc>\t\t\t\t_Base;\n+      typedef __gnu_debug::_Safe_container<unordered_multiset,\n+\t_Alloc, __gnu_debug::_Safe_unordered_container>\t\t_Safe;\n+      typedef typename _Base::const_iterator\t_Base_const_iterator;\n+      typedef typename _Base::iterator\t\t_Base_iterator;\n+      typedef typename _Base::const_local_iterator\n+\t\t\t\t\t\t_Base_const_local_iterator;\n+      typedef typename _Base::local_iterator\t_Base_local_iterator;\n \n     public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-\n-      typedef typename _Base::key_type        key_type;\n-      typedef typename _Base::value_type      value_type;\n-\n-      typedef __gnu_debug::_Safe_iterator<_Base_iterator,\n-\t\t\t\t\t  unordered_multiset> iterator;\n-      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n-\t\t\t\t\t  unordered_multiset> const_iterator;\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::hasher\t\t\thasher;\n+      typedef typename _Base::key_equal\t\t\tkey_equal;\n+      typedef typename _Base::allocator_type\t\tallocator_type;\n+\n+      typedef typename _Base::key_type\t\t\tkey_type;\n+      typedef typename _Base::value_type\t\tvalue_type;\n+\n+      typedef __gnu_debug::_Safe_iterator<\n+\t_Base_iterator, unordered_multiset>\t\titerator;\n+      typedef __gnu_debug::_Safe_iterator<\n+\t_Base_const_iterator, unordered_multiset>\tconst_iterator;\n       typedef __gnu_debug::_Safe_local_iterator<\n-\t_Base_local_iterator, unordered_multiset> local_iterator;\n+\t_Base_local_iterator, unordered_multiset>\tlocal_iterator;\n       typedef __gnu_debug::_Safe_local_iterator<\n \t_Base_const_local_iterator, unordered_multiset> const_local_iterator;\n \n@@ -539,10 +499,10 @@ namespace __debug\n       : _Base(__n, __hf, __eql, __a) { }\n \n       template<typename _InputIterator>\n-        unordered_multiset(_InputIterator __first, _InputIterator __last, \n+\tunordered_multiset(_InputIterator __first, _InputIterator __last,\n \t\t\t   size_type __n = 0,\n-\t\t\t   const hasher& __hf = hasher(), \n-\t\t\t   const key_equal& __eql = key_equal(), \n+\t\t\t   const hasher& __hf = hasher(),\n+\t\t\t   const key_equal& __eql = key_equal(),\n \t\t\t   const allocator_type& __a = allocator_type())\n \t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n \t\t\t\t\t\t\t\t     __last)),\n@@ -551,25 +511,23 @@ namespace __debug\n \n       unordered_multiset(const unordered_multiset&) = default;\n \n-      unordered_multiset(const _Base& __x) \n+      unordered_multiset(const _Base& __x)\n       : _Base(__x) { }\n \n       unordered_multiset(unordered_multiset&&) = default;\n \n       explicit\n       unordered_multiset(const allocator_type& __a)\n-\t: _Base(__a)\n-      { }\n+      : _Base(__a) { }\n \n       unordered_multiset(const unordered_multiset& __uset,\n \t\t\t const allocator_type& __a)\n-\t: _Base(__uset._M_base(), __a)\n-      { }\n-      \n+      : _Base(__uset, __a) { }\n+\n       unordered_multiset(unordered_multiset&& __uset,\n \t\t\t const allocator_type& __a)\n-\t: _Base(std::move(__uset._M_base()), __a)\n-      { }\n+      : _Safe(std::move(__uset._M_safe()), __a),\n+\t_Base(std::move(__uset._M_base()), __a) { }\n \n       unordered_multiset(initializer_list<value_type> __l,\n \t\t\t size_type __n = 0,\n@@ -578,48 +536,28 @@ namespace __debug\n \t\t\t const allocator_type& __a = allocator_type())\n       : _Base(__l, __n, __hf, __eql, __a) { }\n \n-      ~unordered_multiset() noexcept { }\n+      ~unordered_multiset() = default;\n \n       unordered_multiset&\n-      operator=(const unordered_multiset& __x)\n-      {\n-\t_M_base() = __x._M_base();\n-\tthis->_M_invalidate_all();\n-\treturn *this;\n-      }\n+      operator=(const unordered_multiset&) = default;\n \n       unordered_multiset&\n-      operator=(unordered_multiset&& __x)\n-      noexcept(_Alloc_traits::_S_nothrow_move())\n-      {\n-\t__glibcxx_check_self_move_assign(__x);\n-\tbool __xfer_memory = _Alloc_traits::_S_propagate_on_move_assign()\n-\t    || __x.get_allocator() == this->get_allocator();\n-\t_M_base() = std::move(__x._M_base());\n-\tif (__xfer_memory)\n-\t  this->_M_swap(__x);\n-\telse\n-\t  this->_M_invalidate_all();\n-\t__x._M_invalidate_all();\n-\treturn *this;\n-      }\n+      operator=(unordered_multiset&&) = default;\n \n       unordered_multiset&\n       operator=(initializer_list<value_type> __l)\n       {\n-\t_M_base() = __l;\n+\tthis->_M_base() = __l;\n \tthis->_M_invalidate_all();\n \treturn *this;\n       }\n \n       void\n       swap(unordered_multiset& __x)\n-      noexcept(_Alloc_traits::_S_nothrow_swap())\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n       {\n-\tif (!_Alloc_traits::_S_propagate_on_swap())\n-\t  __glibcxx_check_equal_allocs(__x);\n+\t_Safe::_M_swap(__x);\n \t_Base::swap(__x);\n-\t_Safe_base::_M_swap(__x);\n       }\n \n       void\n@@ -751,7 +689,7 @@ namespace __debug\n       {\n \t__glibcxx_check_insert(__hint);\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __it = _Base::insert(__hint.base(), __obj); \n+\t_Base_iterator __it = _Base::insert(__hint.base(), __obj);\n \t_M_check_rehashed(__bucket_count);\n \treturn iterator(__it, this);\n       }\n@@ -760,7 +698,7 @@ namespace __debug\n       insert(value_type&& __obj)\n       {\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __it = _Base::insert(std::move(__obj)); \n+\t_Base_iterator __it = _Base::insert(std::move(__obj));\n \t_M_check_rehashed(__bucket_count);\n \treturn iterator(__it, this);\n       }\n@@ -770,7 +708,7 @@ namespace __debug\n       {\n \t__glibcxx_check_insert(__hint);\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __it = _Base::insert(__hint.base(), std::move(__obj)); \n+\t_Base_iterator __it = _Base::insert(__hint.base(), std::move(__obj));\n \t_M_check_rehashed(__bucket_count);\n \treturn iterator(__it, this);\n       }\n@@ -805,8 +743,8 @@ namespace __debug\n       std::pair<iterator, iterator>\n       equal_range(const key_type& __key)\n       {\n-\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n-\t__pair_type __res = _Base::equal_range(__key);\n+\tstd::pair<_Base_iterator, _Base_iterator> __res\n+\t  = _Base::equal_range(__key);\n \treturn std::make_pair(iterator(__res.first, this),\n \t\t\t      iterator(__res.second, this));\n       }\n@@ -878,35 +816,17 @@ namespace __debug\n       }\n \n       _Base&\n-      _M_base() noexcept       { return *this; }\n+      _M_base() noexcept\t{ return *this; }\n \n       const _Base&\n-      _M_base() const noexcept { return *this; }\n+      _M_base() const noexcept\t{ return *this; }\n \n     private:\n-      void\n-      _M_invalidate_locals()\n-      {\n-\t_Base_local_iterator __local_end = _Base::end(0);\n-\tthis->_M_invalidate_local_if(\n-\t\t\t[__local_end](_Base_const_local_iterator __it)\n-\t\t\t{ return __it != __local_end; });\n-      }\n-\n-      void\n-      _M_invalidate_all()\n-      {\n-\t_Base_iterator __end = _Base::end();\n-\tthis->_M_invalidate_if([__end](_Base_const_iterator __it)\n-\t\t\t{ return __it != __end; });\n-\t_M_invalidate_locals();\n-      }\n-\n       void\n       _M_check_rehashed(size_type __prev_count)\n       {\n \tif (__prev_count != this->bucket_count())\n-\t  _M_invalidate_locals();\n+\t  this->_M_invalidate_locals();\n       }\n     };\n "}, {"sha": "427d19fd4a9bb04652031a7811ca97869aa0e8ad", "filename": "libstdc++-v3/include/debug/vector", "status": "modified", "additions": 172, "deletions": 144, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -32,8 +32,68 @@\n #include <vector>\n #include <utility>\n #include <debug/safe_sequence.h>\n+#include <debug/safe_container.h>\n #include <debug/safe_iterator.h>\n \n+namespace __gnu_debug\n+{\n+  /// Special vector safe base class to add a guaranteed capacity information\n+  /// useful to detect code relying on the libstdc++ reallocation management\n+  /// implementation detail.\n+  template<typename _SafeSequence,\n+\t   typename _BaseSequence>\n+    class _Safe_vector\n+    {\n+      typedef typename _BaseSequence::size_type size_type;\n+\n+      const _SafeSequence&\n+      _M_seq() const { return *static_cast<const _SafeSequence*>(this); }\n+\n+    protected:\n+      _Safe_vector() _GLIBCXX_NOEXCEPT\n+\t: _M_guaranteed_capacity(0)\n+      { _M_update_guaranteed_capacity(); }\n+\n+      _Safe_vector(const _Safe_vector&) _GLIBCXX_NOEXCEPT\n+\t: _M_guaranteed_capacity(0)\n+      { _M_update_guaranteed_capacity(); }\n+\n+      _Safe_vector(size_type __n) _GLIBCXX_NOEXCEPT\n+\t: _M_guaranteed_capacity(__n)\n+      { }\n+\n+#if __cplusplus >= 201103L\n+      _Safe_vector(_Safe_vector&& __x) noexcept\n+\t: _Safe_vector()\n+      { __x._M_guaranteed_capacity = 0; }\n+\n+      _Safe_vector&\n+      operator=(const _Safe_vector&) noexcept\n+      { _M_update_guaranteed_capacity(); }\n+\n+      _Safe_vector&\n+      operator=(_Safe_vector&& __x) noexcept\n+      {\n+\t_M_update_guaranteed_capacity();\n+\t__x._M_guaranteed_capacity = 0;\n+      }\n+#endif\n+\n+      size_type _M_guaranteed_capacity;\n+\n+      bool\n+      _M_requires_reallocation(size_type __elements) const _GLIBCXX_NOEXCEPT\n+      { return __elements > _M_seq().capacity(); }\n+\n+      void\n+      _M_update_guaranteed_capacity() _GLIBCXX_NOEXCEPT\n+      {\n+\tif (_M_seq().size() > _M_guaranteed_capacity)\n+\t  _M_guaranteed_capacity = _M_seq().size();\n+      }\n+    };\n+}\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n namespace __debug\n@@ -42,61 +102,67 @@ namespace __debug\n   template<typename _Tp,\n \t   typename _Allocator = std::allocator<_Tp> >\n     class vector\n-    : public _GLIBCXX_STD_C::vector<_Tp, _Allocator>,\n-      public __gnu_debug::_Safe_sequence<vector<_Tp, _Allocator> >\n+    : public __gnu_debug::_Safe_container<\n+\tvector<_Tp, _Allocator>, _Allocator, __gnu_debug::_Safe_sequence>,\n+      public _GLIBCXX_STD_C::vector<_Tp, _Allocator>,\n+      public __gnu_debug::_Safe_vector<\n+\tvector<_Tp, _Allocator>,\n+\t_GLIBCXX_STD_C::vector<_Tp, _Allocator> >\n     {\n-      typedef _GLIBCXX_STD_C::vector<_Tp, _Allocator> _Base;\n+      typedef _GLIBCXX_STD_C::vector<_Tp, _Allocator>\t\t_Base;\n+      typedef __gnu_debug::_Safe_container<\n+\tvector, _Allocator, __gnu_debug::_Safe_sequence>\t_Safe;\n+      typedef __gnu_debug::_Safe_vector<vector, _Base>\t\t_Safe_vector;\n \n-      typedef typename _Base::iterator _Base_iterator;\n-      typedef typename _Base::const_iterator _Base_const_iterator;\n+      typedef typename _Base::iterator\t\t_Base_iterator;\n+      typedef typename _Base::const_iterator\t_Base_const_iterator;\n       typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n \n-#if __cplusplus >= 201103L\n-      typedef __gnu_debug::_Safe_sequence<vector<_Tp, _Allocator> > _Safe_base;\n-      typedef __gnu_cxx::__alloc_traits<_Allocator>  _Alloc_traits;\n-#endif\n-\n     public:\n-      typedef typename _Base::reference             reference;\n-      typedef typename _Base::const_reference       const_reference;\n+      typedef typename _Base::reference\t\t\treference;\n+      typedef typename _Base::const_reference\t\tconst_reference;\n \n-      typedef __gnu_debug::_Safe_iterator<_Base_iterator,vector>\n-      iterator;\n-      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,vector>\n-      const_iterator;\n+      typedef __gnu_debug::_Safe_iterator<\n+\t_Base_iterator, vector>\t\t\t\titerator;\n+      typedef __gnu_debug::_Safe_iterator<\n+\t_Base_const_iterator, vector>\t\t\tconst_iterator;\n \n-      typedef typename _Base::size_type             size_type;\n-      typedef typename _Base::difference_type       difference_type;\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::difference_type\t\tdifference_type;\n \n-      typedef _Tp\t\t\t\t    value_type;\n-      typedef _Allocator\t\t\t    allocator_type;\n-      typedef typename _Base::pointer               pointer;\n-      typedef typename _Base::const_pointer         const_pointer;\n-      typedef std::reverse_iterator<iterator>       reverse_iterator;\n-      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+      typedef _Tp\t\t\t\t\tvalue_type;\n+      typedef _Allocator\t\t\t\tallocator_type;\n+      typedef typename _Base::pointer\t\t\tpointer;\n+      typedef typename _Base::const_pointer\t\tconst_pointer;\n+      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n \n       // 23.2.4.1 construct/copy/destroy:\n \n+#if __cplusplus < 201103L\n       vector() _GLIBCXX_NOEXCEPT\n-      : _Base(), _M_guaranteed_capacity(0) { }\n+      : _Base() { }\n+#else\n+      vector() = default;\n+#endif\n \n       explicit\n       vector(const _Allocator& __a) _GLIBCXX_NOEXCEPT\n-      : _Base(__a), _M_guaranteed_capacity(0) { }\n+      : _Base(__a) { }\n \n #if __cplusplus >= 201103L\n       explicit\n       vector(size_type __n, const _Allocator& __a = _Allocator())\n-      : _Base(__n, __a), _M_guaranteed_capacity(__n) { }\n+      : _Base(__n, __a), _Safe_vector(__n) { }\n \n       vector(size_type __n, const _Tp& __value,\n \t     const _Allocator& __a = _Allocator())\n-      : _Base(__n, __value, __a), _M_guaranteed_capacity(__n) { }\n+      : _Base(__n, __value, __a) { }\n #else\n       explicit\n       vector(size_type __n, const _Tp& __value = _Tp(),\n \t     const _Allocator& __a = _Allocator())\n-      : _Base(__n, __value, __a), _M_guaranteed_capacity(__n) { }\n+      : _Base(__n, __value, __a) { }\n #endif\n \n #if __cplusplus >= 201103L\n@@ -105,83 +171,62 @@ namespace __debug\n #else\n       template<class _InputIterator>\n #endif\n-        vector(_InputIterator __first, _InputIterator __last,\n+\tvector(_InputIterator __first, _InputIterator __last,\n \t       const _Allocator& __a = _Allocator())\n-        : _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n+\t: _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n \t\t\t\t\t\t\t\t     __last)),\n-\t\t__gnu_debug::__base(__last), __a),\n-\t  _M_guaranteed_capacity(0)\n-        { _M_update_guaranteed_capacity(); }\n+\t\t__gnu_debug::__base(__last), __a) { }\n \n+#if __cplusplus < 201103L\n       vector(const vector& __x)\n-      : _Base(__x), _M_guaranteed_capacity(__x.size()) { }\n+      : _Base(__x) { }\n \n-      /// Construction from a normal-mode vector\n-      vector(const _Base& __x)\n-      : _Base(__x), _M_guaranteed_capacity(__x.size()) { }\n-\n-#if __cplusplus >= 201103L\n-      vector(vector&& __x) noexcept\n-      : _Base(std::move(__x)),\n-\t_Safe_base(std::move(__x)),\n-\t_M_guaranteed_capacity(this->size())\n-      { __x._M_guaranteed_capacity = 0; }\n+      ~vector() _GLIBCXX_NOEXCEPT { }\n+#else\n+      vector(const vector&) = default;\n+      vector(vector&&) = default;\n \n       vector(const vector& __x, const allocator_type& __a)\n-      : _Base(__x, __a), _M_guaranteed_capacity(__x.size()) { }\n+      : _Base(__x, __a) { }\n \n       vector(vector&& __x, const allocator_type& __a)\n-      : _Base(std::move(__x), __a),\n-        _M_guaranteed_capacity(this->size())\n-      {\n-\tif (__x.get_allocator() == __a)\n-\t  this->_M_swap(__x);\n-\telse\n-\t  __x._M_invalidate_all();\n-\t__x._M_guaranteed_capacity = 0;\n-      }\n+      : _Safe(std::move(__x._M_safe()), __a),\n+\t_Base(std::move(__x._M_base()), __a),\n+\t_Safe_vector(std::move(__x)) { }\n \n       vector(initializer_list<value_type> __l,\n \t     const allocator_type& __a = allocator_type())\n-      : _Base(__l, __a),\n-\t_M_guaranteed_capacity(__l.size()) { }\n+      : _Base(__l, __a) { }\n+\n+      ~vector() = default;\n #endif\n \n-      ~vector() _GLIBCXX_NOEXCEPT { }\n+      /// Construction from a normal-mode vector\n+      vector(const _Base& __x)\n+      : _Base(__x) { }\n \n+#if __cplusplus < 201103L\n       vector&\n       operator=(const vector& __x)\n       {\n+\tthis->_M_safe() = __x;\n \t_M_base() = __x;\n-\tthis->_M_invalidate_all();\n-\t_M_update_guaranteed_capacity();\n+\tthis->_M_update_guaranteed_capacity();\n \treturn *this;\n       }\n+#else\n+      vector&\n+      operator=(const vector&) = default;\n \n-#if __cplusplus >= 201103L\n       vector&\n-      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n-      {\n-\t__glibcxx_check_self_move_assign(__x);\n-\tbool __xfer_memory = _Alloc_traits::_S_propagate_on_move_assign()\n-\t    || __x.get_allocator() == this->get_allocator();\n-\t_M_base() = std::move(__x._M_base());\n-\tif (__xfer_memory)\n-\t  this->_M_swap(__x);\n-\telse\n-\t  this->_M_invalidate_all();\n-\t_M_update_guaranteed_capacity();\n-\t__x._M_invalidate_all();\n-\t__x._M_guaranteed_capacity = 0;\n-\treturn *this;\n-      }\n+      operator=(vector&&) = default;\n \n       vector&\n       operator=(initializer_list<value_type> __l)\n       {\n \t_M_base() = __l;\n \tthis->_M_invalidate_all();\n-\t_M_update_guaranteed_capacity();\n+\tthis->_M_update_guaranteed_capacity();\n \treturn *this;\n       }\n #endif\n@@ -192,22 +237,22 @@ namespace __debug\n #else\n       template<typename _InputIterator>\n #endif\n-        void\n-        assign(_InputIterator __first, _InputIterator __last)\n-        {\n+\tvoid\n+\tassign(_InputIterator __first, _InputIterator __last)\n+\t{\n \t  __glibcxx_check_valid_range(__first, __last);\n \t  _Base::assign(__gnu_debug::__base(__first),\n \t\t\t__gnu_debug::__base(__last));\n \t  this->_M_invalidate_all();\n-\t  _M_update_guaranteed_capacity();\n+\t  this->_M_update_guaranteed_capacity();\n \t}\n \n       void\n       assign(size_type __n, const _Tp& __u)\n       {\n \t_Base::assign(__n, __u);\n \tthis->_M_invalidate_all();\n-\t_M_update_guaranteed_capacity();\n+\tthis->_M_update_guaranteed_capacity();\n       }\n \n #if __cplusplus >= 201103L\n@@ -216,7 +261,7 @@ namespace __debug\n       {\n \t_Base::assign(__l);\n \tthis->_M_invalidate_all();\n-\t_M_update_guaranteed_capacity();\n+\tthis->_M_update_guaranteed_capacity();\n       }\n #endif\n \n@@ -281,37 +326,37 @@ namespace __debug\n       void\n       resize(size_type __sz)\n       {\n-\tbool __realloc = _M_requires_reallocation(__sz);\n+\tbool __realloc = this->_M_requires_reallocation(__sz);\n \tif (__sz < this->size())\n \t  this->_M_invalidate_after_nth(__sz);\n \t_Base::resize(__sz);\n \tif (__realloc)\n \t  this->_M_invalidate_all();\n-\t_M_update_guaranteed_capacity();\n+\tthis->_M_update_guaranteed_capacity();\n       }\n \n       void\n       resize(size_type __sz, const _Tp& __c)\n       {\n-\tbool __realloc = _M_requires_reallocation(__sz);\n+\tbool __realloc = this->_M_requires_reallocation(__sz);\n \tif (__sz < this->size())\n \t  this->_M_invalidate_after_nth(__sz);\n \t_Base::resize(__sz, __c);\n \tif (__realloc)\n \t  this->_M_invalidate_all();\n-\t_M_update_guaranteed_capacity();\n+\tthis->_M_update_guaranteed_capacity();\n       }\n #else\n       void\n       resize(size_type __sz, _Tp __c = _Tp())\n       {\n-\tbool __realloc = _M_requires_reallocation(__sz);\n+\tbool __realloc = this->_M_requires_reallocation(__sz);\n \tif (__sz < this->size())\n \t  this->_M_invalidate_after_nth(__sz);\n \t_Base::resize(__sz, __c);\n \tif (__realloc)\n \t  this->_M_invalidate_all();\n-\t_M_update_guaranteed_capacity();\n+\tthis->_M_update_guaranteed_capacity();\n       }\n #endif\n \n@@ -321,7 +366,7 @@ namespace __debug\n       {\n \tif (_Base::_M_shrink_to_fit())\n \t  {\n-\t    _M_guaranteed_capacity = _Base::capacity();\n+\t    this->_M_guaranteed_capacity = _Base::capacity();\n \t    this->_M_invalidate_all();\n \t  }\n       }\n@@ -331,7 +376,7 @@ namespace __debug\n       capacity() const _GLIBCXX_NOEXCEPT\n       {\n #ifdef _GLIBCXX_DEBUG_PEDANTIC\n-\treturn _M_guaranteed_capacity;\n+\treturn this->_M_guaranteed_capacity;\n #else\n \treturn _Base::capacity();\n #endif\n@@ -342,10 +387,10 @@ namespace __debug\n       void\n       reserve(size_type __n)\n       {\n-\tbool __realloc = _M_requires_reallocation(__n);\n+\tbool __realloc = this->_M_requires_reallocation(__n);\n \t_Base::reserve(__n);\n-\tif (__n > _M_guaranteed_capacity)\n-\t  _M_guaranteed_capacity = __n;\n+\tif (__n > this->_M_guaranteed_capacity)\n+\t  this->_M_guaranteed_capacity = __n;\n \tif (__realloc)\n \t  this->_M_invalidate_all();\n       }\n@@ -403,29 +448,29 @@ namespace __debug\n       void\n       push_back(const _Tp& __x)\n       {\n-\tbool __realloc = _M_requires_reallocation(this->size() + 1);\n+\tbool __realloc = this->_M_requires_reallocation(this->size() + 1);\n \t_Base::push_back(__x);\n \tif (__realloc)\n \t  this->_M_invalidate_all();\n-\t_M_update_guaranteed_capacity();\n+\tthis->_M_update_guaranteed_capacity();\n       }\n \n #if __cplusplus >= 201103L\n       template<typename _Up = _Tp>\n-        typename __gnu_cxx::__enable_if<!std::__are_same<_Up, bool>::__value,\n+\ttypename __gnu_cxx::__enable_if<!std::__are_same<_Up, bool>::__value,\n \t\t\t\t\tvoid>::__type\n-        push_back(_Tp&& __x)\n+\tpush_back(_Tp&& __x)\n \t{ emplace_back(std::move(__x)); }\n \n       template<typename... _Args>\n-        void\n-        emplace_back(_Args&&... __args)\n+\tvoid\n+\templace_back(_Args&&... __args)\n \t{\n-\t  bool __realloc = _M_requires_reallocation(this->size() + 1);\n+\t  bool __realloc = this->_M_requires_reallocation(this->size() + 1);\n \t  _Base::emplace_back(std::forward<_Args>(__args)...);\n \t  if (__realloc)\n \t    this->_M_invalidate_all();\n-\t  _M_update_guaranteed_capacity();\n+\t  this->_M_update_guaranteed_capacity();\n \t}\n #endif\n \n@@ -439,19 +484,19 @@ namespace __debug\n \n #if __cplusplus >= 201103L\n       template<typename... _Args>\n-        iterator\n-        emplace(const_iterator __position, _Args&&... __args)\n+\titerator\n+\templace(const_iterator __position, _Args&&... __args)\n \t{\n \t  __glibcxx_check_insert(__position);\n-\t  bool __realloc = _M_requires_reallocation(this->size() + 1);\n+\t  bool __realloc = this->_M_requires_reallocation(this->size() + 1);\n \t  difference_type __offset = __position.base() - _Base::begin();\n \t  _Base_iterator __res = _Base::emplace(__position.base(),\n \t\t\t\t\t\tstd::forward<_Args>(__args)...);\n \t  if (__realloc)\n \t    this->_M_invalidate_all();\n \t  else\n \t    this->_M_invalidate_after_nth(__offset);\n-\t  _M_update_guaranteed_capacity();\n+\t  this->_M_update_guaranteed_capacity();\n \t  return iterator(__res, this);\n \t}\n #endif\n@@ -464,23 +509,23 @@ namespace __debug\n #endif\n       {\n \t__glibcxx_check_insert(__position);\n-\tbool __realloc = _M_requires_reallocation(this->size() + 1);\n+\tbool __realloc = this->_M_requires_reallocation(this->size() + 1);\n \tdifference_type __offset = __position.base() - _Base::begin();\n \t_Base_iterator __res = _Base::insert(__position.base(), __x);\n \tif (__realloc)\n \t  this->_M_invalidate_all();\n \telse\n \t  this->_M_invalidate_after_nth(__offset);\n-\t_M_update_guaranteed_capacity();\n+\tthis->_M_update_guaranteed_capacity();\n \treturn iterator(__res, this);\n       }\n \n #if __cplusplus >= 201103L\n       template<typename _Up = _Tp>\n-        typename __gnu_cxx::__enable_if<!std::__are_same<_Up, bool>::__value,\n+\ttypename __gnu_cxx::__enable_if<!std::__are_same<_Up, bool>::__value,\n \t\t\t\t\titerator>::__type\n-        insert(const_iterator __position, _Tp&& __x)\n-        { return emplace(__position, std::move(__x)); }\n+\tinsert(const_iterator __position, _Tp&& __x)\n+\t{ return emplace(__position, std::move(__x)); }\n \n       iterator\n       insert(const_iterator __position, initializer_list<value_type> __l)\n@@ -492,39 +537,39 @@ namespace __debug\n       insert(const_iterator __position, size_type __n, const _Tp& __x)\n       {\n \t__glibcxx_check_insert(__position);\n-\tbool __realloc = _M_requires_reallocation(this->size() + __n);\n+\tbool __realloc = this->_M_requires_reallocation(this->size() + __n);\n \tdifference_type __offset = __position.base() - _Base::cbegin();\n \t_Base_iterator __res = _Base::insert(__position.base(), __n, __x);\n \tif (__realloc)\n \t  this->_M_invalidate_all();\n \telse\n \t  this->_M_invalidate_after_nth(__offset);\n-\t_M_update_guaranteed_capacity();\n+\tthis->_M_update_guaranteed_capacity();\n \treturn iterator(__res, this);\n       }\n #else\n       void\n       insert(iterator __position, size_type __n, const _Tp& __x)\n       {\n \t__glibcxx_check_insert(__position);\n-\tbool __realloc = _M_requires_reallocation(this->size() + __n);\n+\tbool __realloc = this->_M_requires_reallocation(this->size() + __n);\n \tdifference_type __offset = __position.base() - _Base::begin();\n \t_Base::insert(__position.base(), __n, __x);\n \tif (__realloc)\n \t  this->_M_invalidate_all();\n \telse\n \t  this->_M_invalidate_after_nth(__offset);\n-\t_M_update_guaranteed_capacity();\n+\tthis->_M_update_guaranteed_capacity();\n       }\n #endif\n \n #if __cplusplus >= 201103L\n       template<class _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n-        iterator\n-        insert(const_iterator __position,\n+\titerator\n+\tinsert(const_iterator __position,\n \t       _InputIterator __first, _InputIterator __last)\n-        {\n+\t{\n \t  __glibcxx_check_insert_range(__position, __first, __last);\n \n \t  /* Hard to guess if invalidation will occur, because __last\n@@ -540,15 +585,15 @@ namespace __debug\n \t    this->_M_invalidate_all();\n \t  else\n \t    this->_M_invalidate_after_nth(__offset);\n-\t  _M_update_guaranteed_capacity();\n+\t  this->_M_update_guaranteed_capacity();\n \t  return iterator(__res, this);\n \t}\n #else\n       template<class _InputIterator>\n-        void\n-        insert(iterator __position,\n+\tvoid\n+\tinsert(iterator __position,\n \t       _InputIterator __first, _InputIterator __last)\n-        {\n+\t{\n \t  __glibcxx_check_insert_range(__position, __first, __last);\n \n \t  /* Hard to guess if invalidation will occur, because __last\n@@ -563,7 +608,7 @@ namespace __debug\n \t    this->_M_invalidate_all();\n \t  else\n \t    this->_M_invalidate_after_nth(__offset);\n-\t  _M_update_guaranteed_capacity();\n+\t  this->_M_update_guaranteed_capacity();\n \t}\n #endif\n \n@@ -611,24 +656,20 @@ namespace __debug\n       void\n       swap(vector& __x)\n #if __cplusplus >= 201103L\n-\t\t\tnoexcept(_Alloc_traits::_S_nothrow_swap())\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n #endif\n       {\n-#if __cplusplus >= 201103L\n-\tif (!_Alloc_traits::_S_propagate_on_swap())\n-\t  __glibcxx_check_equal_allocs(__x);\n-#endif\n+\t_Safe::_M_swap(__x);\n \t_Base::swap(__x);\n-\tthis->_M_swap(__x);\n-        std::swap(_M_guaranteed_capacity, __x._M_guaranteed_capacity);\n+\tstd::swap(this->_M_guaranteed_capacity, __x._M_guaranteed_capacity);\n       }\n \n       void\n       clear() _GLIBCXX_NOEXCEPT\n       {\n \t_Base::clear();\n \tthis->_M_invalidate_all();\n-        _M_guaranteed_capacity = 0;\n+\tthis->_M_guaranteed_capacity = 0;\n       }\n \n       _Base&\n@@ -638,19 +679,6 @@ namespace __debug\n       _M_base() const _GLIBCXX_NOEXCEPT { return *this; }\n \n     private:\n-      size_type _M_guaranteed_capacity;\n-\n-      bool\n-      _M_requires_reallocation(size_type __elements) _GLIBCXX_NOEXCEPT\n-      { return __elements > this->capacity(); }\n-\n-      void\n-      _M_update_guaranteed_capacity() _GLIBCXX_NOEXCEPT\n-      {\n-\tif (this->size() > _M_guaranteed_capacity)\n-\t  _M_guaranteed_capacity = this->size();\n-      }\n-\n       void\n       _M_invalidate_after_nth(difference_type __n) _GLIBCXX_NOEXCEPT\n       {"}, {"sha": "d51cbf699750e4c05c6b7d666397d0cb191cea0a", "filename": "libstdc++-v3/src/c++11/debug.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fdebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fdebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fdebug.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -23,8 +23,8 @@\n // <http://www.gnu.org/licenses/>.\n \n #include <debug/debug.h>\n-#include <debug/safe_sequence.h>\n-#include <debug/safe_unordered_container.h>\n+#include <debug/safe_base.h>\n+#include <debug/safe_unordered_base.h>\n #include <debug/safe_iterator.h>\n #include <debug/safe_local_iterator.h>\n #include <algorithm>\n@@ -235,7 +235,7 @@ namespace __gnu_debug\n \n   void\n   _Safe_sequence_base::\n-  _M_swap(_Safe_sequence_base& __x)\n+  _M_swap(_Safe_sequence_base& __x) noexcept\n   {\n     // We need to lock both sequences to swap\n     using namespace __gnu_cxx;\n@@ -382,7 +382,7 @@ namespace __gnu_debug\n \n   _Safe_unordered_container_base*\n   _Safe_local_iterator_base::\n-  _M_get_container() const _GLIBCXX_NOEXCEPT\n+  _M_get_container() const noexcept\n   { return static_cast<_Safe_unordered_container_base*>(_M_sequence); }\n \n   void\n@@ -455,7 +455,7 @@ namespace __gnu_debug\n \n   void\n   _Safe_unordered_container_base::\n-  _M_swap(_Safe_unordered_container_base& __x)\n+  _M_swap(_Safe_unordered_container_base& __x) noexcept\n   {\n     // We need to lock both containers to swap\n     using namespace __gnu_cxx;"}, {"sha": "7d91e2585fa693592cf1f2af3410189b7f247557", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/allocator/move.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fallocator%2Fmove.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -32,9 +32,11 @@ void test01()\n   typedef std::forward_list<T, alloc_type> test_type;\n   test_type v1(alloc_type(1));\n   v1 = { T() };\n+  auto it = v1.begin();\n   test_type v2(std::move(v1));\n   VERIFY(1 == v1.get_allocator().get_personality());\n   VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n }\n \n void test02()"}, {"sha": "08e8dc06c613bc45fa3fbbb8e3ff569c4808531e", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/allocator/move_assign.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fallocator%2Fmove_assign.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -46,11 +46,13 @@ void test02()\n   typedef std::forward_list<T, alloc_type> test_type;\n   test_type v1(alloc_type(1));\n   v1.push_front(T());\n+  auto it = v1.begin();\n   test_type v2(alloc_type(2));\n   v2.push_front(T());\n   v2 = std::move(v1);\n   VERIFY(0 == v1.get_allocator().get_personality());\n   VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n }\n \n int main()"}, {"sha": "241d350806b154360991682f19f115c154b2902f", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/construct1_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fconstruct1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fconstruct1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fconstruct1_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <forward_list>\n+#include <debug/checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::check_construct1<std::forward_list<int> >();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "05061f2dcd9a2ebd182bcc6d033ed4aa7dea5431", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/construct2_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fconstruct2_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fconstruct2_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fconstruct2_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <forward_list>\n+#include <debug/checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::check_construct2<std::forward_list<int> >();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "a3363f7d821eb7e7beba945bff16cd9d0d26c512", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/construct3_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fconstruct3_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fconstruct3_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fconstruct3_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2010-2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <forward_list>\n+#include <debug/checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::check_construct3<std::forward_list<int> >();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "24ed6286e3cb76414d0344f3620442ac2d32cd58", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/construct4_neg.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fconstruct4_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fconstruct4_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fconstruct4_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,44 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/forward_list>\n+\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::forward_list<int, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_front(0);\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( it == v2.begin() ); // Error, it is singular\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "91e459fd3c3ad2f7d3e38fc0cf41b516b1069b9f", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/move_assign_neg.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fmove_assign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fmove_assign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fmove_assign_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,47 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/forward_list>\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::forward_list<int, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.push_front(0);\n+  auto it = v1.begin();\n+\n+  test_type v2(alloc_type(2));\n+  v2.push_front(1);\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY( *it == 0 ); // Error, it is singular.\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "5b65cff6173ed923ccf4b9b4e6c355e4cc7f62a2", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/move_neg.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fmove_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fmove_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fmove_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/forward_list>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::forward_list<int, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1 = { 0 };\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( *it == 0 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "496ccebb6028b010f3075cbbf0fc465a740d34ad", "filename": "libstdc++-v3/testsuite/23_containers/map/allocator/move.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -38,9 +38,13 @@ void test01()\n   typedef std::map<T, U, Cmp, alloc_type> test_type;\n   test_type v1(alloc_type(1));\n   v1 = { test_type::value_type{} };\n+  auto it = v1.begin();\n+\n   test_type v2(std::move(v1));\n+\n   VERIFY(1 == v1.get_allocator().get_personality());\n   VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n }\n \n void test02()"}, {"sha": "3a8f1f1c832782274475fa999f7aa24ee1163375", "filename": "libstdc++-v3/testsuite/23_containers/map/allocator/move_assign.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove_assign.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -38,9 +38,11 @@ void test01()\n   typedef std::map<T, U, Cmp, alloc_type> test_type;\n   test_type v1(alloc_type(1));\n   v1 = { test_type::value_type{} };\n+\n   test_type v2(alloc_type(2));\n   v2 = { test_type::value_type{} };\n   v2 = std::move(v1);\n+\n   VERIFY(1 == v1.get_allocator().get_personality());\n   VERIFY(2 == v2.get_allocator().get_personality());\n }\n@@ -52,11 +54,15 @@ void test02()\n   typedef std::map<T, U, Cmp, alloc_type> test_type;\n   test_type v1(alloc_type(1));\n   v1 = { test_type::value_type{} };\n+  auto it = v1.begin();\n+\n   test_type v2(alloc_type(2));\n   v2 = { test_type::value_type{} };\n   v2 = std::move(v1);\n+\n   VERIFY(0 == v1.get_allocator().get_personality());\n   VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n }\n \n int main()"}, {"sha": "bbcf8352a3678799dc75e533f92447911f6438be", "filename": "libstdc++-v3/testsuite/23_containers/map/debug/construct5_neg.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fdebug%2Fconstruct5_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fdebug%2Fconstruct5_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fdebug%2Fconstruct5_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,45 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/map>\n+\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<std::pair<const int, int> > alloc_type;\n+  typedef __gnu_debug::map<int, int, std::less<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.insert(std::make_pair(0, 0));\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( it->first == 0 ); // Error, it is singular\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "0d63fe944bf0645d9d9296bb7cb138b358172eda", "filename": "libstdc++-v3/testsuite/23_containers/map/debug/move_assign_neg.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fdebug%2Fmove_assign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fdebug%2Fmove_assign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fdebug%2Fmove_assign_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,47 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/map>\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<std::pair<const int, int> > alloc_type;\n+  typedef __gnu_debug::map<int, int, std::less<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.insert(std::make_pair(0, 0));\n+  auto it = v1.begin();\n+\n+  test_type v2(alloc_type(2));\n+  v2.insert(std::make_pair(1, 1));\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY( it == v2.begin() ); // Error, it is singular.\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "050294f9f08c8276a0a9ad64e31cd1d9c5ed86bb", "filename": "libstdc++-v3/testsuite/23_containers/map/debug/move_neg.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fdebug%2Fmove_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fdebug%2Fmove_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fdebug%2Fmove_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/map>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef uneq_allocator<std::pair<const int, int> > alloc_type;\n+  typedef __gnu_debug::map<int, int, std::less<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1 = { { 0, 0 } };\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( it->first == 0 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "f2216bbbb06b8e2b4fa14b26804f776faf34a084", "filename": "libstdc++-v3/testsuite/23_containers/multimap/allocator/move.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -38,9 +38,13 @@ void test01()\n   typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n   test_type v1(alloc_type(1));\n   v1 = { test_type::value_type{} };\n+  auto it = v1.begin();\n+\n   test_type v2(std::move(v1));\n+\n   VERIFY(1 == v1.get_allocator().get_personality());\n   VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n }\n \n void test02()"}, {"sha": "6b1386120aca752f195bd3a958bb3cb838d8d98d", "filename": "libstdc++-v3/testsuite/23_containers/multimap/allocator/move_assign.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove_assign.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -52,11 +52,13 @@ void test02()\n   typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n   test_type v1(alloc_type(1));\n   v1 = { test_type::value_type{} };\n+  auto it = v1.begin();\n   test_type v2(alloc_type(2));\n   v2 = { test_type::value_type{} };\n   v2 = std::move(v1);\n   VERIFY(0 == v1.get_allocator().get_personality());\n   VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin()  );\n }\n \n int main()"}, {"sha": "acb358dd023879debb6230d57ff8e42ef32ef96c", "filename": "libstdc++-v3/testsuite/23_containers/multimap/debug/construct5_neg.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fdebug%2Fconstruct5_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fdebug%2Fconstruct5_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fdebug%2Fconstruct5_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,45 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/map>\n+\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<std::pair<const int, int> > alloc_type;\n+  typedef __gnu_debug::multimap<int, int, std::less<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.insert(std::make_pair(0, 0));\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( it->first == 0 ); // Error, it is singular\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "e514a28dbed704cbbd970592f37d7351a238c820", "filename": "libstdc++-v3/testsuite/23_containers/multimap/debug/move_assign_neg.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fdebug%2Fmove_assign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fdebug%2Fmove_assign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fdebug%2Fmove_assign_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,47 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/map>\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<std::pair<const int, int> > alloc_type;\n+  typedef __gnu_debug::multimap<int, int, std::less<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.insert(std::make_pair(0, 0));\n+  auto it = v1.begin();\n+\n+  test_type v2(alloc_type(2));\n+  v2.insert(std::make_pair(1, 1));\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY( it == v2.begin() ); // Error, it is singular.\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "18393785acdcc360ecfff0fa3fb31ace588db990", "filename": "libstdc++-v3/testsuite/23_containers/multimap/debug/move_neg.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fdebug%2Fmove_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fdebug%2Fmove_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fdebug%2Fmove_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/map>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef uneq_allocator<std::pair<const int, int> > alloc_type;\n+  typedef __gnu_debug::multimap<int, int, std::less<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1 = { { 0, 0 } };\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( it->first == 0 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "a65b2bb4b6846738371e64c2c8680ce7bd0e9828", "filename": "libstdc++-v3/testsuite/23_containers/multiset/allocator/move.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -36,9 +36,13 @@ void test01()\n   typedef std::multiset<T, Cmp, alloc_type> test_type;\n   test_type v1(alloc_type(1));\n   v1 = { test_type::value_type{} };\n+  auto it = v1.begin();\n+\n   test_type v2(std::move(v1));\n+\n   VERIFY(1 == v1.get_allocator().get_personality());\n   VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n }\n \n void test02()"}, {"sha": "956f885462ca19e4e7b8cdbb0839b3efd68410e6", "filename": "libstdc++-v3/testsuite/23_containers/multiset/allocator/move_assign.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove_assign.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -50,11 +50,13 @@ void test02()\n   typedef std::multiset<T, Cmp, alloc_type> test_type;\n   test_type v1(alloc_type(1));\n   v1 = { test_type::value_type{} };\n+  auto it = v1.begin();\n   test_type v2(alloc_type(2));\n   v2 = { test_type::value_type{} };\n   v2 = std::move(v1);\n   VERIFY(0 == v1.get_allocator().get_personality());\n   VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n }\n \n int main()"}, {"sha": "89c4ff2721680bf94fc15a02d5d8bbb5b40765d0", "filename": "libstdc++-v3/testsuite/23_containers/multiset/debug/construct5_neg.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fdebug%2Fconstruct5_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fdebug%2Fconstruct5_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fdebug%2Fconstruct5_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,45 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/set>\n+\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::multiset<int, std::less<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.insert(0);\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( *it == 0 ); // Error, it is singular\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "af879d94dadb0ff93380842b135e79e9c8a8b5af", "filename": "libstdc++-v3/testsuite/23_containers/multiset/debug/move_assign_neg.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fdebug%2Fmove_assign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fdebug%2Fmove_assign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fdebug%2Fmove_assign_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,47 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/set>\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::multiset<int, std::less<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.insert(0);\n+  auto it = v1.begin();\n+\n+  test_type v2(alloc_type(2));\n+  v2.insert(1);\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY( it == v2.begin() ); // Error, it is singular.\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2dab9a791e56adcf821342fc2f391fccef3b2e84", "filename": "libstdc++-v3/testsuite/23_containers/multiset/debug/move_neg.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fdebug%2Fmove_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fdebug%2Fmove_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fdebug%2Fmove_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/set>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::multiset<int, std::less<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1 = { 0 };\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( *it == 0 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "09bcd719321ed9709566f2a430583e75c07a9c01", "filename": "libstdc++-v3/testsuite/23_containers/set/allocator/move.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -38,9 +38,13 @@ void test01()\n   typedef std::set<T, Cmp, alloc_type> test_type;\n   test_type v1(alloc_type(1));\n   v1 = { test_type::value_type{} };\n+  auto it = v1.begin();\n+\n   test_type v2(std::move(v1));\n+\n   VERIFY(1 == v1.get_allocator().get_personality());\n   VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n }\n \n void test02()"}, {"sha": "416e0b443151f6616606a44a6af47d803af9c6ff", "filename": "libstdc++-v3/testsuite/23_containers/set/allocator/move_assign.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove_assign.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -50,11 +50,13 @@ void test02()\n   typedef std::set<T, Cmp, alloc_type> test_type;\n   test_type v1(alloc_type(1));\n   v1 = { test_type::value_type{} };\n+  auto it = v1.begin();\n   test_type v2(alloc_type(2));\n   v2 = { test_type::value_type{} };\n   v2 = std::move(v1);\n   VERIFY(0 == v1.get_allocator().get_personality());\n   VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n }\n \n int main()"}, {"sha": "c30066ad3dc97d2ec91b6600918b245125e8ce0e", "filename": "libstdc++-v3/testsuite/23_containers/set/debug/construct5_neg.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fdebug%2Fconstruct5_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fdebug%2Fconstruct5_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fdebug%2Fconstruct5_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,45 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/set>\n+\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::set<int, std::less<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.insert(0);\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( *it == 0 ); // Error, it is singular\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "b7f51efd3933f305daf298f4966d0b6567cec28c", "filename": "libstdc++-v3/testsuite/23_containers/set/debug/move_assign_neg.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fdebug%2Fmove_assign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fdebug%2Fmove_assign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fdebug%2Fmove_assign_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,47 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/set>\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::set<int, std::less<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.insert(0);\n+  auto it = v1.begin();\n+\n+  test_type v2(alloc_type(2));\n+  v2.insert(1);\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY( it == v2.begin() ); // Error, it is singular.\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2bbebe77e2ca144413bb769cf3c3cf015f9c9e11", "filename": "libstdc++-v3/testsuite/23_containers/set/debug/move_neg.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fdebug%2Fmove_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fdebug%2Fmove_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fdebug%2Fmove_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/set>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::set<int, std::less<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1 = { 0 };\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( *it == 0 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "534d9f82bc82f21841ab3e3a35cb584f55d5ed49", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/allocator/move.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fmove.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -45,9 +45,11 @@ void test01()\n   test_type v1(alloc_type(1));\n   v1.emplace(std::piecewise_construct,\n \t     std::make_tuple(T()), std::make_tuple(T()));\n+  auto it = v1.begin();\n   test_type v2(std::move(v1));\n   VERIFY(1 == v1.get_allocator().get_personality());\n   VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n }\n \n void test02()"}, {"sha": "0e54a231e3ceb7b1e158c67eee7b671e99c77dd1", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/allocator/move_assign.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fmove_assign.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -66,6 +66,8 @@ void test02()\n   v1.emplace(std::piecewise_construct,\n \t     std::make_tuple(1), std::make_tuple(1));\n \n+  auto it = v1.begin();\n+\n   test_type v2(alloc_type(2));\n   v2.emplace(std::piecewise_construct,\n \t     std::make_tuple(2), std::make_tuple(2));\n@@ -79,6 +81,8 @@ void test02()\n \n   VERIFY( counter_type::move_assign_count == 0 );\n   VERIFY( counter_type::destructor_count == 2 );\n+\n+  VERIFY( it == v2.begin() );\n }\n \n int main()"}, {"sha": "312b775e35611558767653c32675a6a1338da739", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/debug/construct5_neg.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fconstruct5_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fconstruct5_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fconstruct5_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,47 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/unordered_map>\n+\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<std::pair<const int, int>> alloc_type;\n+  typedef __gnu_debug::unordered_map<int, int, std::hash<int>,\n+\t\t\t\t     std::equal_to<int>,\n+\t\t\t\t     alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.insert(std::make_pair(0, 0));\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( it == v2.begin() ); // Error, it is singular.\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "ef5db1165f397c82c9debafc7b05f3f893b1b9ef", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/debug/move_assign_neg.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fmove_assign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fmove_assign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fmove_assign_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/unordered_map>\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<std::pair<const int, int> > alloc_type;\n+  typedef __gnu_debug::unordered_map<int, int,\n+\t\t\t\t     std::hash<int>, std::equal_to<int>,\n+\t\t\t\t     alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.insert(std::make_pair(0, 0));\n+  auto it = v1.begin();\n+\n+  test_type v2(alloc_type(2));\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY( it == v2.begin() ); // Error, it is singular.\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "97c1d4f306a844408f9515ea41ab6a9eb5d9975b", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/debug/move_neg.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fmove_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fmove_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fmove_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/unordered_map>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef uneq_allocator<std::pair<const int, int> > alloc_type;\n+  typedef __gnu_debug::unordered_map<\n+    int, int, std::hash<int>, std::equal_to<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1 = { { 0, 0 } };\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( it->first == 0 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "b8685d4e403abf78abb07582ce4ad08e615d69bb", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/allocator/move.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fmove.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -45,9 +45,11 @@ void test01()\n   test_type v1(alloc_type(1));\n   v1.emplace(std::piecewise_construct,\n \t     std::make_tuple(T()), std::make_tuple(T()));\n+  auto it = v1.begin();\n   test_type v2(std::move(v1));\n   VERIFY(1 == v1.get_allocator().get_personality());\n   VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n }\n \n void test02()"}, {"sha": "5d71b38daccfdbf7816dda507017fa118ee43d9b", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/allocator/move_assign.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fmove_assign.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -66,6 +66,8 @@ void test02()\n   v1.emplace(std::piecewise_construct,\n \t     std::make_tuple(1), std::make_tuple(1));\n \n+  auto it = v1.begin();\n+\n   test_type v2(alloc_type(2));\n   v2.emplace(std::piecewise_construct,\n \t     std::make_tuple(2), std::make_tuple(2));\n@@ -79,6 +81,8 @@ void test02()\n \n   VERIFY( counter_type::move_assign_count == 0 );\n   VERIFY( counter_type::destructor_count == 2 );\n+\n+  VERIFY( it == v2.begin() );\n }\n \n int main()"}, {"sha": "90a578996ecc45b250218e305b83c9683b7868da", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/debug/construct5_neg.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fconstruct5_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fconstruct5_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fconstruct5_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,47 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/unordered_map>\n+\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<std::pair<const int, int>> alloc_type;\n+  typedef __gnu_debug::unordered_multimap<int, int,\n+\t\t\t\t\t  std::hash<int>, std::equal_to<int>,\n+\t\t\t\t\t  alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.insert(std::make_pair(0, 0));\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( it == v2.begin() ); // Error, it is singular.\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "b6de1eef581e7fb30ba744ec80517e7bf1aded81", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/debug/move_assign_neg.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fmove_assign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fmove_assign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fmove_assign_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/unordered_map>\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<std::pair<const int, int>> alloc_type;\n+  typedef __gnu_debug::unordered_multimap<int, int, std::hash<int>,\n+\t\t\t\t\t  std::equal_to<int>,\n+\t\t\t\t\t  alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.insert(std::make_pair(0, 0));\n+  auto it = v1.begin();\n+\n+  test_type v2(alloc_type(2));\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY( it == v2.begin() ); // Error, it is singular.\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "0a1c6391aacc73472cf131d43065af5ae117aa48", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/debug/move_neg.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fmove_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fmove_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fmove_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/unordered_map>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef uneq_allocator<std::pair<const int, int> > alloc_type;\n+  typedef __gnu_debug::unordered_multimap<\n+    int, int, std::hash<int>, std::equal_to<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1 = { { 0, 0 } };\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( it->first == 0 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "f935f961413a347a74c232edc62af6adb1f7468a", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/allocator/move.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fmove.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -44,9 +44,11 @@ void test01()\n   typedef std::unordered_multiset<T, hash, equal_to, alloc_type> test_type;\n   test_type v1(alloc_type(1));\n   v1.insert(T());\n+  auto it = v1.begin();\n   test_type v2(std::move(v1));\n   VERIFY(1 == v1.get_allocator().get_personality());\n   VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n }\n \n void test02()"}, {"sha": "769d01fcb35cf04a6923cd2c9b1005b6ed7b565a", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/allocator/move_assign.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fmove_assign.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -63,6 +63,8 @@ void test02()\n   test_type v1(alloc_type(1));\n   v1.emplace(0);\n \n+  auto it = v1.begin();\n+\n   test_type v2(alloc_type(2));\n   v2.emplace(0);\n \n@@ -76,6 +78,8 @@ void test02()\n   VERIFY( counter_type::move_count == 0 );\n   VERIFY( counter_type::copy_count == 0 );\n   VERIFY( counter_type::destructor_count == 1 );\n+\n+  VERIFY( it == v2.begin() );\n }\n \n int main()"}, {"sha": "1a1f709ccb687de06fa2a168cfa2cb5bdcee3a39", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/debug/construct5_neg.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fconstruct5_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fconstruct5_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fconstruct5_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,47 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/unordered_set>\n+\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::unordered_multiset<int, std::hash<int>,\n+\t\t\t\t\t  std::equal_to<int>,\n+\t\t\t\t\t  alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.insert(0);\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( it == v2.begin() ); // Error, it is singular\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "52a8df2a9f2ca4144f096155311cf48aa854028b", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/debug/move_assign_neg.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fmove_assign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fmove_assign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fmove_assign_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/unordered_set>\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::unordered_multiset<int, std::hash<int>,\n+\t\t\t\t\t  std::equal_to<int>,\n+\t\t\t\t\t  alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.emplace(0);\n+  auto it = v1.begin();\n+\n+  test_type v2(alloc_type(2));\n+  v2.emplace(1);\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY( it == v2.begin() ); // Error, it is singular.\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "d8177c9354cebaedcbf9e1c5aa6090dee41219a4", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/debug/move_neg.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fmove_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fmove_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fmove_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/unordered_set>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::unordered_multiset<\n+    int, std::hash<int>, std::equal_to<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1 = { 0 };\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( *it == 0 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "fbaa522cb23cb3d6e6d9e9dc0b87cedc13c59352", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/allocator/move.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fmove.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -44,9 +44,11 @@ void test01()\n   typedef std::unordered_set<T, hash, equal_to, alloc_type> test_type;\n   test_type v1(alloc_type(1));\n   v1.insert(T());\n+  auto it = v1.begin();\n   test_type v2(std::move(v1));\n   VERIFY(1 == v1.get_allocator().get_personality());\n   VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n }\n \n void test02()"}, {"sha": "dd51e5cdd732c224be9918363673ff7988e00d88", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/allocator/move_assign.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fmove_assign.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -63,6 +63,8 @@ void test02()\n   test_type v1(alloc_type(1));\n   v1.emplace(0);\n \n+  auto it = v1.begin();\n+\n   test_type v2(alloc_type(2));\n   v2.emplace(0);\n \n@@ -76,6 +78,8 @@ void test02()\n   VERIFY( counter_type::move_count == 0 );\n   VERIFY( counter_type::copy_count == 0 );\n   VERIFY( counter_type::destructor_count == 1 );\n+\n+  VERIFY( it == v2.begin() );\n }\n \n int main()"}, {"sha": "db7eb3cc7cecce925798ae79480f78f0e109ba95", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/debug/construct5_neg.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fconstruct5_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fconstruct5_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fconstruct5_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,45 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/unordered_set>\n+\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::unordered_set<int, std::hash<int>,\n+\t\t\t\t     std::equal_to<int>, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(0);\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( it == v2.begin() ); // Error, it is singular\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "9d2a8abc4254ce013145de8feb9a2022cd82c567", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/debug/move_assign_neg.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fmove_assign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fmove_assign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fmove_assign_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/unordered_set>\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_test::uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::unordered_set<int, std::hash<int>,\n+\t\t\t\t     std::equal_to<int>,\n+\t\t\t\t     alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1.emplace(0);\n+  auto it = v1.begin();\n+\n+  test_type v2(alloc_type(2));\n+  v2.emplace(1);\n+\n+  v2 = std::move(v1);\n+\n+  VERIFY( it == v2.begin() ); // Error, it is singular.\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "af91b0c14ce52c287b832e04352f7b78e2564787", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/debug/move_neg.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fmove_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fmove_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fmove_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/unordered_set>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::unordered_set<\n+    int, std::hash<int>, std::equal_to<int>, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1 = { 0 };\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( *it == 0 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "f2e6c6187169eb8da39038dbffc5bbcefe1b68eb", "filename": "libstdc++-v3/testsuite/23_containers/vector/debug/move_neg.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fdebug%2Fmove_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fdebug%2Fmove_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fdebug%2Fmove_neg.cc?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <debug/vector>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef uneq_allocator<int> alloc_type;\n+  typedef __gnu_debug::vector<int, alloc_type> test_type;\n+\n+  test_type v1(alloc_type(1));\n+  v1 = { 0 };\n+  auto it = v1.begin();\n+\n+  test_type v2(std::move(v1), alloc_type(2));\n+\n+  VERIFY( *it == 0 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "af63c8c17d9a7f445bdb64761d45177857695e29", "filename": "libstdc++-v3/testsuite/util/debug/checks.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fdebug%2Fchecks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ee1a774550df16aa47def1aa054b1b631ab47c/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fdebug%2Fchecks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fdebug%2Fchecks.h?ref=15ee1a774550df16aa47def1aa054b1b631ab47c", "patch": "@@ -179,10 +179,8 @@ namespace __gnu_test\n \n       val_type *first = &v.front() + 1;\n       val_type *last = first + 2;\n-      cont_type c1(first, last);\n-      VERIFY(c1.size() == 2);\n \n-      cont_type c2(last, first); // Expected failure\n+      cont_type c(last, first); // Expected failure\n     } \n \n   // Check that invalid range of debug random iterators is detected\n@@ -206,10 +204,8 @@ namespace __gnu_test\n \n       typename vector_type::iterator first = v.begin() + 1;\n       typename vector_type::iterator last = first + 2;\n-      cont_type c1(first, last);\n-      VERIFY(c1.size() == 2);\n \n-      cont_type c2(last, first); // Expected failure\n+      cont_type c(last, first); // Expected failure\n     }\n \n   // Check that invalid range of debug not random iterators is detected\n@@ -233,10 +229,8 @@ namespace __gnu_test\n \n       typename list_type::iterator first = l.begin(); ++first;\n       typename list_type::iterator last = first; ++last; ++last;\n-      cont_type c1(first, last);\n-      VERIFY(c1.size() == 2);\n \n-      cont_type c2(last, first); // Expected failure\n+      cont_type c(last, first); // Expected failure\n     }\n \n   template <typename _Cont>"}]}