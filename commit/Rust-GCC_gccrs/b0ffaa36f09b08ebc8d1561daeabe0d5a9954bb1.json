{"sha": "b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBmZmFhMzZmMDliMDhlYmM4ZDE1NjFkYWVhYmUwZDVhOTk1NGJiMQ==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2013-01-22T10:05:05Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2013-01-22T10:05:05Z"}, "message": "PR c++/53609 - Wrong variadic template pack expansion in alias template\n\nConsider this example:\n\n     1\ttemplate<class...I> struct List {};\n     2\ttemplate<int T> struct Z {static const int value = T;};\n     3\ttemplate<int...T> using LZ = List<Z<T>...>;\n     4\n     5\ttemplate<class...U>\n     6\tstruct F\n     7\t{\n     8\t  using N = LZ<U::value...>; //#1 This should amount to List<Z<U::value>...>\n     9\t}\n    10\n    11\tF<Z<1>, Z<2> >::N A; //#2\n\nwhich G++ fails to compile, with this error message:\n\ntest-PR53609-3.cc: In instantiation of 'struct F<Z<1>, Z<2> >':\ntest-PR53609-3.cc:11:15:   required from here\ntest-PR53609-3.cc:3:43: error: wrong number of template arguments (2, should be 1)\n template<int...T> using LZ = List<Z<T>...>;\n                                           ^\ntest-PR53609-3.cc:2:24: error: provided for 'template<int T> struct Z'\n template<int T> struct Z {static const int value = T;};\n\nI think this is because in #1, when we substitute the argument pack\n{U::value...} into the pack expansion Z<T>..., tsubst_pack_expansion\nyields Z<U::value...>, instead of Z<U::value>..., so the instantiation\nof LZ amounts to List<Z<U::value...> >, instead of\nList<Z<U::value>...>.\n\nThe idea of this patch is to make tsubst_pack_expansion support\nsubstituting an argument pack (into a pack expansion) where one of the\narguments (let's call it the Ith argument) is itself a pack expansion\nP.  In that case, the Ith element resulting from the substituting\nshould be a pack expansion P'.\n\nThe pattern of P' is then the pattern of P into which the pattern of\nthe Ith argument of the argument pack has been substituted.\n\nTested on x86_64-unknown-linux-gnu against trunk.\n\ngcc/cp/\n\n\t* pt.c (argument_pack_element_is_expansion_p)\n\t(make_argument_pack_select, use_pack_expansion_extra_args_p)\n\t(gen_elem_of_pack_expansion_instantiation): New static functions.\n\t(tsubst): When looking through an ARGUMENT_PACK_SELECT tree node,\n\tlook through the possibly resulting pack expansion as well.\n\t(tsubst_pack_expansion): Use use_pack_expansion_extra_p to\n\tgeneralize when to use the PACK_EXPANSION_EXTRA_ARGS mechanism.\n\tUse gen_elem_of_pack_expansion_instantiation to build the\n\tinstantiation piece-wise.  Don't use arg_from_parm_pack_p anymore,\n\tas gen_elem_of_pack_expansion_instantiation and the change in\n\ttsubst above generalize this particular case.\n\t(arg_from_parm_pack_p): Remove this for it's not used by\n\ttsubst_pack_expansion anymore.\n\ngcc/testsuite/\n\n\t* g++.dg/cpp0x/variadic139.C: New test.\n\t* g++.dg/cpp0x/variadic140.C: Likewise.\n\t* g++.dg/cpp0x/variadic141.C: Likewise.\n\nFrom-SVN: r195367", "tree": {"sha": "ae5a5e22ca76c6ce9cab973f1bdaa306a1dcbc6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae5a5e22ca76c6ce9cab973f1bdaa306a1dcbc6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1/comments", "author": null, "committer": null, "parents": [{"sha": "257e81a6191507c54271466eb360b0822ff94fb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/257e81a6191507c54271466eb360b0822ff94fb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/257e81a6191507c54271466eb360b0822ff94fb9"}], "stats": {"total": 437, "additions": 291, "deletions": 146}, "files": [{"sha": "b9f68fe0e679ebddbcf206b0a0c0c127266335c6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1", "patch": "@@ -1,3 +1,20 @@\n+2013-01-22  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/53609\n+\t* pt.c (argument_pack_element_is_expansion_p)\n+\t(make_argument_pack_select, use_pack_expansion_extra_args_p)\n+\t(gen_elem_of_pack_expansion_instantiation): New static functions.\n+\t(tsubst): When looking through an ARGUMENT_PACK_SELECT tree node,\n+\tlook through the possibly resulting pack expansion as well.\n+\t(tsubst_pack_expansion): Use use_pack_expansion_extra_p to\n+\tgeneralize when to use the PACK_EXPANSION_EXTRA_ARGS mechanism.\n+\tUse gen_elem_of_pack_expansion_instantiation to build the\n+\tinstantiation piece-wise.  Don't use arg_from_parm_pack_p anymore,\n+\tas gen_elem_of_pack_expansion_instantiation and the change in\n+\ttsubst above generalize this particular case.\n+\t(arg_from_parm_pack_p): Remove this for it's not used by\n+\ttsubst_pack_expansion anymore.\n+\n 2013-01-21  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/56059"}, {"sha": "e38aca61a6c96f8068de4986519bc46965ae7529", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 209, "deletions": 146, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1", "patch": "@@ -201,7 +201,6 @@ static void append_type_to_template_for_access_check_1 (tree, tree, tree,\n static tree listify (tree);\n static tree listify_autos (tree, tree);\n static tree template_parm_to_arg (tree t);\n-static bool arg_from_parm_pack_p (tree, tree);\n static tree current_template_args (void);\n static tree tsubst_template_parm (tree, tree, tsubst_flags_t);\n static tree instantiate_alias_template (tree, tree, tsubst_flags_t);\n@@ -3816,42 +3815,6 @@ template_parm_to_arg (tree t)\n   return t;\n }\n \n-/* This function returns TRUE if PARM_PACK is a template parameter\n-   pack and if ARG_PACK is what template_parm_to_arg returned when\n-   passed PARM_PACK.  */\n-\n-static bool\n-arg_from_parm_pack_p (tree arg_pack, tree parm_pack)\n-{\n-  /* For clarity in the comments below let's use the representation\n-     argument_pack<elements>' to denote an argument pack and its\n-     elements.\n-\n-     In the 'if' block below, we want to detect cases where\n-     ARG_PACK is argument_pack<PARM_PACK...>.  I.e, we want to\n-     check if ARG_PACK is an argument pack which sole element is\n-     the expansion of PARM_PACK.  That argument pack is typically\n-     created by template_parm_to_arg when passed a parameter\n-     pack.  */\n-\n-  if (arg_pack\n-      && TREE_VEC_LENGTH (ARGUMENT_PACK_ARGS (arg_pack)) == 1\n-      && PACK_EXPANSION_P (TREE_VEC_ELT (ARGUMENT_PACK_ARGS (arg_pack), 0)))\n-    {\n-      tree expansion = TREE_VEC_ELT (ARGUMENT_PACK_ARGS (arg_pack), 0);\n-      tree pattern = PACK_EXPANSION_PATTERN (expansion);\n-      if ((TYPE_P (pattern) && same_type_p (pattern, parm_pack))\n-\t  || (!TYPE_P (pattern) && cp_tree_equal (parm_pack, pattern)))\n-\t/* The argument pack that the parameter maps to is just an\n-\t   expansion of the parameter itself, such as one would\n-\t   find in the implicit typedef of a class inside the\n-\t   class itself.  Consider this parameter \"unsubstituted\",\n-\t   so that we will maintain the outer pack expansion.  */\n-\treturn true;\n-    }\n-  return false;\n-}\n-\n /* Given a set of template parameters, return them as a set of template\n    arguments.  The template parameters are represented as a TREE_VEC, in\n    the form documented in cp-tree.h for template arguments.  */\n@@ -9148,6 +9111,168 @@ make_fnparm_pack (tree spec_parm)\n   return extract_fnparm_pack (NULL_TREE, &spec_parm);\n }\n \n+/* Return true iff the Ith element of the argument pack ARG_PACK is a\n+   pack expansion.  */\n+\n+static bool\n+argument_pack_element_is_expansion_p (tree arg_pack, int i)\n+{\n+  tree vec = ARGUMENT_PACK_ARGS (arg_pack);\n+  if (i >= TREE_VEC_LENGTH (vec))\n+    return false;\n+  return PACK_EXPANSION_P (TREE_VEC_ELT (vec, i));\n+}\n+\n+\n+/* Creates and return an ARGUMENT_PACK_SELECT tree node.  */\n+\n+static tree\n+make_argument_pack_select (tree arg_pack, unsigned index)\n+{\n+  tree aps = make_node (ARGUMENT_PACK_SELECT);\n+\n+  ARGUMENT_PACK_SELECT_FROM_PACK (aps) = arg_pack;\n+  ARGUMENT_PACK_SELECT_INDEX (aps) = index;\n+\n+  return aps;\n+}\n+\n+/*  This is a subroutine of tsubst_pack_expansion.\n+\n+    It returns TRUE if we need to use the PACK_EXPANSION_EXTRA_ARGS\n+    mechanism to store the (non complete list of) arguments of the\n+    substitution and return a non substituted pack expansion, in order\n+    to wait for when we have enough arguments to really perform the\n+    substitution.  */\n+\n+static bool\n+use_pack_expansion_extra_args_p (tree parm_packs,\n+\t\t\t\t int arg_pack_len,\n+\t\t\t\t bool has_empty_arg)\n+{\n+  if (parm_packs == NULL_TREE)\n+    return false;\n+\n+  bool has_expansion_arg = false;\n+  for (int i = 0 ; i < arg_pack_len; ++i)\n+    {\n+      bool has_non_expansion_arg = false;\n+      for (tree parm_pack = parm_packs;\n+\t   parm_pack;\n+\t   parm_pack = TREE_CHAIN (parm_pack))\n+\t{\n+\t  tree arg = TREE_VALUE (parm_pack);\n+\n+\t  if (argument_pack_element_is_expansion_p (arg, i))\n+\t    has_expansion_arg = true;\n+\t  else\n+\t    has_non_expansion_arg = true;\n+\t}\n+\n+      /* If one pack has an expansion and another pack has a normal\n+\t argument or if one pack has an empty argument another one\n+\t hasn't then tsubst_pack_expansion cannot perform the\n+\t substitution and need to fall back on the\n+\t PACK_EXPANSION_EXTRA mechanism.  */\n+      if ((has_expansion_arg && has_non_expansion_arg)\n+\t  || (has_empty_arg && (has_expansion_arg || has_non_expansion_arg)))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* [temp.variadic]/6 says that:\n+\n+       The instantiation of a pack expansion [...]\n+       produces a list E1,E2, ..., En, where N is the number of elements\n+       in the pack expansion parameters.\n+\n+   This subroutine of tsubst_pack_expansion produces one of these Ei.\n+\n+   PATTERN is the pattern of the pack expansion.  PARM_PACKS is a\n+   TREE_LIST in which each TREE_PURPOSE is a parameter pack of\n+   PATTERN, and each TREE_VALUE is its corresponding argument pack.\n+   INDEX is the index 'i' of the element Ei to produce.  ARGS,\n+   COMPLAIN, and IN_DECL are the same parameters as for the\n+   tsubst_pack_expansion function.\n+\n+   The function returns the resulting Ei upon successful completion,\n+   or error_mark_node.\n+\n+   Note that this function possibly modifies the ARGS parameter, so\n+   it's the responsibility of the caller to restore it.  */\n+\n+static tree\n+gen_elem_of_pack_expansion_instantiation (tree pattern,\n+\t\t\t\t\t  tree parm_packs,\n+\t\t\t\t\t  unsigned index,\n+\t\t\t\t\t  tree args /* This parm gets\n+\t\t\t\t\t\t       modified.  */,\n+\t\t\t\t\t  tsubst_flags_t complain,\n+\t\t\t\t\t  tree in_decl)\n+{\n+  tree t;\n+  bool ith_elem_is_expansion = false;\n+\n+  /* For each parameter pack, change the substitution of the parameter\n+     pack to the ith argument in its argument pack, then expand the\n+     pattern.  */\n+  for (tree pack = parm_packs; pack; pack = TREE_CHAIN (pack))\n+    {\n+      tree parm = TREE_PURPOSE (pack);\n+      tree arg_pack = TREE_VALUE (pack);\n+      tree aps;\t\t\t/* instance of ARGUMENT_PACK_SELECT.  */\n+\n+      ith_elem_is_expansion |=\n+\targument_pack_element_is_expansion_p (arg_pack, index);\n+\n+      /* Select the Ith argument from the pack.  */\n+      if (TREE_CODE (parm) == PARM_DECL)\n+\t{\n+\t  if (index == 0)\n+\t    {\n+\t      aps = make_argument_pack_select (arg_pack, index);\n+\t      mark_used (parm);\n+\t      register_local_specialization (aps, parm);\n+\t    }\n+\t  else\n+\t    aps = retrieve_local_specialization (parm);\n+\t}\n+      else\n+\t{\n+\t  int idx, level;\n+\t  template_parm_level_and_index (parm, &level, &idx);\n+\n+\t  if (index == 0)\n+\t    {\n+\t      aps = make_argument_pack_select (arg_pack, index);\n+\t      /* Update the corresponding argument.  */\n+\t      TMPL_ARG (args, level, idx) = aps;\n+\t    }\n+\t  else\n+\t    /* Re-use the ARGUMENT_PACK_SELECT.  */\n+\t    aps = TMPL_ARG (args, level, idx);\n+\t}\n+      ARGUMENT_PACK_SELECT_INDEX (aps) = index;\n+    }\n+\n+  /* Substitute into the PATTERN with the (possibly altered)\n+     arguments.  */\n+  if (!TYPE_P (pattern))\n+    t = tsubst_expr (pattern, args, complain, in_decl,\n+\t\t     /*integral_constant_expression_p=*/false);\n+  else\n+    t = tsubst (pattern, args, complain, in_decl);\n+\n+  /*  If the Ith argument pack element is a pack expansion, then\n+      the Ith element resulting from the substituting is going to\n+      be a pack expansion as well.  */\n+  if (ith_elem_is_expansion)\n+    t = make_pack_expansion (t);\n+\n+  return t;\n+}\n+\n /* Substitute ARGS into T, which is an pack expansion\n    (i.e. TYPE_PACK_EXPANSION or EXPR_PACK_EXPANSION). Returns a\n    TREE_VEC with the substituted arguments, a PACK_EXPANSION_* node\n@@ -9160,8 +9285,6 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n   tree pattern;\n   tree pack, packs = NULL_TREE;\n   bool unsubstituted_packs = false;\n-  bool real_packs = false;\n-  int missing_level = 0;\n   int i, len = -1;\n   tree result;\n   struct pointer_map_t *saved_local_specializations = NULL;\n@@ -9240,14 +9363,6 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \t  return result;\n \t}\n \n-      if (arg_from_parm_pack_p (arg_pack, parm_pack))\n-\t/* The argument pack that the parameter maps to is just an\n-\t   expansion of the parameter itself, such as one would find\n-\t   in the implicit typedef of a class inside the class itself.\n-\t   Consider this parameter \"unsubstituted\", so that we will\n-\t   maintain the outer pack expansion.  */\n-\targ_pack = NULL_TREE;\n-          \n       if (arg_pack)\n         {\n           int my_len = \n@@ -9275,13 +9390,6 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n               return error_mark_node;\n             }\n \n-\t  if (TREE_VEC_LENGTH (ARGUMENT_PACK_ARGS (arg_pack)) == 1\n-\t      && PACK_EXPANSION_P (TREE_VEC_ELT (ARGUMENT_PACK_ARGS (arg_pack),\n-\t\t\t\t\t\t 0)))\n-\t    /* This isn't a real argument pack yet.  */;\n-\t  else\n-\t    real_packs = true;\n-\n           /* Keep track of the parameter packs and their corresponding\n              argument packs.  */\n           packs = tree_cons (parm_pack, arg_pack, packs);\n@@ -9293,58 +9401,36 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \t     well as the missing_level counter because function parameter\n \t     packs don't have a level.  */\n \t  unsubstituted_packs = true;\n-\t  if (!missing_level || missing_level > level)\n-\t    missing_level = level;\n \t}\n     }\n \n   /* We cannot expand this expansion expression, because we don't have\n      all of the argument packs we need.  */\n-  if (unsubstituted_packs)\n+  if (use_pack_expansion_extra_args_p (packs, len, unsubstituted_packs))\n     {\n-      if (real_packs)\n-\t{\n-\t  /* We got some full packs, but we can't substitute them in until we\n-\t     have values for all the packs.  So remember these until then.  */\n-\t  tree save_args;\n-\n-\t  t = make_pack_expansion (pattern);\n-\n-\t  /* The call to add_to_template_args above assumes no overlap\n-\t     between saved args and new args, so prune away any fake\n-\t     args, i.e. those that satisfied arg_from_parm_pack_p above.  */\n-\t  if (missing_level && levels >= missing_level)\n-\t    {\n-\t      gcc_assert (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args)\n-\t\t\t  && missing_level > 1);\n-\t      TREE_VEC_LENGTH (args) = missing_level - 1;\n-\t      save_args = copy_node (args);\n-\t      TREE_VEC_LENGTH (args) = levels;\n-\t    }\n-\t  else\n-\t    save_args = args;\n+      /* We got some full packs, but we can't substitute them in until we\n+\t have values for all the packs.  So remember these until then.  */\n \n-\t  PACK_EXPANSION_EXTRA_ARGS (t) = save_args;\n-\t}\n+      t = make_pack_expansion (pattern);\n+      PACK_EXPANSION_EXTRA_ARGS (t) = args;\n+      return t;\n+    }\n+  else if (unsubstituted_packs)\n+    {\n+      /* There were no real arguments, we're just replacing a parameter\n+\t pack with another version of itself. Substitute into the\n+\t pattern and return a PACK_EXPANSION_*. The caller will need to\n+\t deal with that.  */\n+      if (TREE_CODE (t) == EXPR_PACK_EXPANSION)\n+\tt = tsubst_expr (pattern, args, complain, in_decl,\n+\t\t\t /*integral_constant_expression_p=*/false);\n       else\n-\t{\n-\t  /* There were no real arguments, we're just replacing a parameter\n-\t     pack with another version of itself. Substitute into the\n-\t     pattern and return a PACK_EXPANSION_*. The caller will need to\n-\t     deal with that.  */\n-\t  if (TREE_CODE (t) == EXPR_PACK_EXPANSION)\n-\t    t = tsubst_expr (pattern, args, complain, in_decl,\n-\t\t\t     /*integral_constant_expression_p=*/false);\n-\t  else\n-\t    t = tsubst (pattern, args, complain, in_decl);\n-\t  t = make_pack_expansion (t);\n-\t}\n+\tt = tsubst (pattern, args, complain, in_decl);\n+      t = make_pack_expansion (t);\n       return t;\n     }\n \n-  /* We could not find any argument packs that work.  */\n-  if (len < 0)\n-    return error_mark_node;\n+  gcc_assert (len >= 0);\n \n   if (need_local_specializations)\n     {\n@@ -9361,55 +9447,12 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n   result = make_tree_vec (len);\n   for (i = 0; i < len; ++i)\n     {\n-      /* For parameter pack, change the substitution of the parameter\n-         pack to the ith argument in its argument pack, then expand\n-         the pattern.  */\n-      for (pack = packs; pack; pack = TREE_CHAIN (pack))\n-        {\n-          tree parm = TREE_PURPOSE (pack);\n-\t  tree arg;\n-\n-\t  /* Select the Ith argument from the pack.  */\n-          if (TREE_CODE (parm) == PARM_DECL)\n-            {\n-\t      if (i == 0)\n-\t\t{\n-\t\t  arg = make_node (ARGUMENT_PACK_SELECT);\n-\t\t  ARGUMENT_PACK_SELECT_FROM_PACK (arg) = TREE_VALUE (pack);\n-\t\t  mark_used (parm);\n-\t\t  register_local_specialization (arg, parm);\n-\t\t}\n-\t      else\n-\t\targ = retrieve_local_specialization (parm);\n-            }\n-          else\n-            {\n-              int idx, level;\n-              template_parm_level_and_index (parm, &level, &idx);\n-\n-\t      if (i == 0)\n-\t\t{\n-\t\t  arg = make_node (ARGUMENT_PACK_SELECT);\n-\t\t  ARGUMENT_PACK_SELECT_FROM_PACK (arg) = TREE_VALUE (pack);\n-\t\t  /* Update the corresponding argument.  */\n-\t\t  TMPL_ARG (args, level, idx) = arg;\n-\t\t}\n-\t      else\n-\t\t/* Re-use the ARGUMENT_PACK_SELECT.  */\n-\t\targ = TMPL_ARG (args, level, idx);\n-            }\n-\t  ARGUMENT_PACK_SELECT_INDEX (arg) = i;\n-        }\n-\n-      /* Substitute into the PATTERN with the altered arguments.  */\n-      if (!TYPE_P (pattern))\n-        TREE_VEC_ELT (result, i) = \n-          tsubst_expr (pattern, args, complain, in_decl,\n-                       /*integral_constant_expression_p=*/false);\n-      else\n-        TREE_VEC_ELT (result, i) = tsubst (pattern, args, complain, in_decl);\n-\n-      if (TREE_VEC_ELT (result, i) == error_mark_node)\n+      t = gen_elem_of_pack_expansion_instantiation (pattern, packs,\n+\t\t\t\t\t\t    i,\n+\t\t\t\t\t\t    args, complain,\n+\t\t\t\t\t\t    in_decl);\n+      TREE_VEC_ELT (result, i) = t;\n+      if (t == error_mark_node)\n \t{\n \t  result = error_mark_node;\n \t  break;\n@@ -9427,6 +9470,10 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n       else\n         {\n           int idx, level;\n+\n+\t  if (TREE_VALUE (pack) == NULL_TREE)\n+\t    continue;\n+\n           template_parm_level_and_index (parm, &level, &idx);\n           \n           /* Update the corresponding argument.  */\n@@ -11163,8 +11210,24 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    arg = TMPL_ARG (args, level, idx);\n \n \t    if (arg && TREE_CODE (arg) == ARGUMENT_PACK_SELECT)\n-\t      /* See through ARGUMENT_PACK_SELECT arguments. */\n-\t      arg = ARGUMENT_PACK_SELECT_ARG (arg);\n+\t      {\n+\t\t/* See through ARGUMENT_PACK_SELECT arguments. */\n+\t\targ = ARGUMENT_PACK_SELECT_ARG (arg);\n+\t\t/* If the selected argument is an expansion E, that most\n+\t\t   likely means we were called from\n+\t\t   gen_elem_of_pack_expansion_instantiation during the\n+\t\t   substituting of pack an argument pack (which Ith\n+\t\t   element is a pack expansion, where I is\n+\t\t   ARGUMENT_PACK_SELECT_INDEX) into a pack expansion.\n+\t\t   In this case, the Ith element resulting from this\n+\t\t   substituting is going to be a pack expansion, which\n+\t\t   pattern is the pattern of E.  Let's return the\n+\t\t   pattern of E, and\n+\t\t   gen_elem_of_pack_expansion_instantiation will\n+\t\t   build the resulting pack expansion from it.  */\n+\t\tif (PACK_EXPANSION_P (arg))\n+\t\t  arg = PACK_EXPANSION_PATTERN (arg);\n+\t      }\n \t  }\n \n \tif (arg == error_mark_node)"}, {"sha": "c3d6f9eefe5c943df3aa207a4a6e9cc8188555d0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1", "patch": "@@ -1,3 +1,10 @@\n+2013-01-22  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/53609\n+\t* g++.dg/cpp0x/variadic139.C: New test.\n+\t* g++.dg/cpp0x/variadic140.C: Likewise.\n+\t* g++.dg/cpp0x/variadic141.C: Likewise.\n+\n 2013-01-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/warn8.adb: New test."}, {"sha": "a1c64f30f6c279be81302bfbf9309b49ad9f3b98", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic139.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic139.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic139.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic139.C?ref=b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1", "patch": "@@ -0,0 +1,14 @@\n+// Origin: PR c++/53609\n+// { dg-do compile { target c++11 } }\n+\n+template<class...I> struct List {};\n+template<int T> struct Z {static const int value = T;};\n+template<int...T> using LZ = List<Z<T>...>;\n+\n+template<class...U>\n+struct F\n+{\n+  using N = LZ<U::value...>;\n+};\n+\n+F<Z<1>, Z<2> >::N A;"}, {"sha": "17ca9e5fdfa203af08294387453d2fcea76ee79d", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic140.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic140.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic140.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic140.C?ref=b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1", "patch": "@@ -0,0 +1,22 @@\n+// Origin: PR c++/53609\n+// { dg-do compile { target c++11 } }\n+\n+template<class...I> struct List{ static const bool is_ok = false;};\n+template<int T> struct Z\n+{\n+  static const int value = T;\n+  static const int value_square = T * T;\n+};\n+\n+template<template<int> class U>\n+struct List<U<2>, U<3>, U<4>, U<9>> { static const bool is_ok = true;};\n+\n+template<int...T> using LZ = List<Z<T>...>;\n+\n+template<class...T>\n+struct F\n+{\n+  using N = LZ<T::value..., T::value_square...>;\n+};\n+\n+static_assert (F<Z<2>, Z<3>>::N::is_ok, \"\");"}, {"sha": "6b893a77c22205de21a961aa807834857c9ac908", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic141.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic141.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic141.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic141.C?ref=b0ffaa36f09b08ebc8d1561daeabe0d5a9954bb1", "patch": "@@ -0,0 +1,22 @@\n+// Origin: PR c++/53609\n+// { dg-do compile { target c++11 } }\n+\n+template<class...I> struct List{ static const bool is_ok = false;};\n+template<int T> struct Z\n+{\n+  static const int value = T;\n+  static const int value_square = T * T;\n+};\n+\n+template<template<int> class U>\n+struct List<U<2>, U<3>, U<4>, U<9>> { static const bool is_ok = true;};\n+\n+template<int...T> using LZ = List<Z<T>...>;\n+\n+template<class...T>\n+struct F\n+{\n+  using N = LZ<T::value..., Z<4>::value, Z<9>::value>;\n+};\n+\n+static_assert (F<Z<2>, Z<3>>::N::is_ok, \"\");"}]}