{"sha": "5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFhMzM5NmNkNDRjNjFkMTM0YWFiM2IxMjNiMWYyYTczYWE5ZDFhOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2002-09-04T23:24:00Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2002-09-04T23:24:00Z"}, "message": "typeck2.c (add_exception_specifier): Only pedwarn for an incomplete type.\n\n        * typeck2.c (add_exception_specifier): Only pedwarn for an\n        incomplete type.\n        (require_complete_eh_spec_types): New fn.\n        (cxx_incomplete_type_diagnostic): Also support pedwarning.\n        * typeck.c (complete_type_or_diagnostic): Likewise.\n        * call.c (build_call): Call require_complete_eh_spec_types.\n        * rtti.c (get_pseudo_ti_desc): Give an error rather than aborting\n        on an incomplete type.\n\nFrom-SVN: r56822", "tree": {"sha": "194dd3c5c6587e67721075491f09bfdb468a1934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/194dd3c5c6587e67721075491f09bfdb468a1934"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "65e32b88a6a9b4b8169e4d8fde0bc28934c4667e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65e32b88a6a9b4b8169e4d8fde0bc28934c4667e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65e32b88a6a9b4b8169e4d8fde0bc28934c4667e"}], "stats": {"total": 138, "additions": 122, "deletions": 16}, "files": [{"sha": "6cbd01ef2444a3c59ccee536466110b1427ced81", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9", "patch": "@@ -1,3 +1,14 @@\n+2002-09-05  Jason Merrill  <jason@redhat.com>\n+\n+\t* typeck2.c (add_exception_specifier): Only pedwarn for an\n+\tincomplete type.\n+\t(require_complete_eh_spec_types): New fn.\n+\t(cxx_incomplete_type_diagnostic): Also support pedwarning.\n+\t* typeck.c (complete_type_or_diagnostic): Likewise.\n+\t* call.c (build_call): Call require_complete_eh_spec_types.\n+\t* rtti.c (get_pseudo_ti_desc): Give an error rather than aborting\n+\ton an incomplete type.\n+\n 2002-09-04  Jakub Jelinek  <jakub@redhat.com>\n \n \t* decl.c (start_cleanup_fn): Clear interface_only before"}, {"sha": "36819449bc0eb5a8e85010118aaf91ea09551c5e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9", "patch": "@@ -356,6 +356,7 @@ build_call (function, parms)\n   tree tmp;\n   tree decl;\n   tree result_type;\n+  tree fntype;\n \n   function = build_addr_func (function);\n \n@@ -365,7 +366,8 @@ build_call (function, parms)\n       return error_mark_node;\n     }\n \n-  result_type = TREE_TYPE (TREE_TYPE (TREE_TYPE (function)));\n+  fntype = TREE_TYPE (TREE_TYPE (function));\n+  result_type = TREE_TYPE (fntype);\n \n   if (TREE_CODE (function) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (function, 0)) == FUNCTION_DECL)\n@@ -383,6 +385,7 @@ build_call (function, parms)\n \n   if (decl && TREE_DEPRECATED (decl))\n     warn_deprecated_use (decl);\n+  require_complete_eh_spec_types (fntype, decl);\n \n   if (decl && DECL_CONSTRUCTOR_P (decl))\n     is_constructor = 1;"}, {"sha": "3f671fc30f4fa49c6993eb4c9df8862ffe36069f", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9", "patch": "@@ -1198,7 +1198,8 @@ get_pseudo_ti_desc (type)\n \treturn ptm_desc_type_node;\n       else if (!COMPLETE_TYPE_P (type))\n \t{\n-\t  my_friendly_assert (at_eof, 20020609);\n+\t  if (!at_eof)\n+\t    cxx_incomplete_type_error (NULL_TREE, type);\n \t  return class_desc_type_node;\n \t}\n       else if (!CLASSTYPE_N_BASECLASSES (type))"}, {"sha": "80da1ed0caaa8c396f1ec9957aa5221b273915c8", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9", "patch": "@@ -155,24 +155,24 @@ complete_type (type)\n   return type;\n }\n \n-/* Like complete_type, but issue an error if the TYPE cannot be\n-   completed.  VALUE is used for informative diagnostics.  WARN_ONLY\n-   will cause a warning message to be printed, instead of an error.\n+/* Like complete_type, but issue an error if the TYPE cannot be completed.\n+   VALUE is used for informative diagnostics.  DIAG_TYPE indicates the type\n+   of diagnostic: 0 for an error, 1 for a warning, 2 for a pedwarn.\n    Returns NULL_TREE if the type cannot be made complete.  */\n \n tree\n-complete_type_or_diagnostic (type, value, warn_only)\n+complete_type_or_diagnostic (type, value, diag_type)\n      tree type;\n      tree value;\n-     int warn_only;\n+     int diag_type;\n {\n   type = complete_type (type);\n   if (type == error_mark_node)\n     /* We already issued an error.  */\n     return NULL_TREE;\n   else if (!COMPLETE_TYPE_P (type))\n     {\n-      cxx_incomplete_type_diagnostic (value, type, warn_only);\n+      cxx_incomplete_type_diagnostic (value, type, diag_type);\n       return NULL_TREE;\n     }\n   else"}, {"sha": "67d880905ddb24d7c8ecacc8f1850f7504e7951f", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9", "patch": "@@ -182,24 +182,30 @@ abstract_virtuals_error (decl, type)\n \n /* Print an error message for invalid use of an incomplete type.\n    VALUE is the expression that was used (or 0 if that isn't known)\n-   and TYPE is the type that was invalid.  If WARN_ONLY is nonzero, a\n-   warning is printed, otherwise an error is printed.  */\n+   and TYPE is the type that was invalid.  DIAG_TYPE indicates the\n+   type of diagnostic:  0 for an error, 1 for a warning, 2 for a\n+   pedwarn.  */\n \n void\n-cxx_incomplete_type_diagnostic (value, type, warn_only)\n+cxx_incomplete_type_diagnostic (value, type, diag_type)\n      tree value;\n      tree type;\n-     int warn_only;\n+     int diag_type;\n {\n   int decl = 0;\n   void (*p_msg) PARAMS ((const char *, ...));\n   void (*p_msg_at) PARAMS ((const char *, ...));\n \n-  if (warn_only)\n+  if (diag_type == 1)\n     {\n       p_msg = warning;\n       p_msg_at = cp_warning_at;\n     }\n+  else if (diag_type == 2)\n+    {\n+      p_msg = pedwarn;\n+      p_msg_at = cp_pedwarn_at;\n+    }\n   else\n     {\n       p_msg = error;\n@@ -1345,6 +1351,7 @@ add_exception_specifier (list, spec, complain)\n   int ok;\n   tree core = spec;\n   int is_ptr;\n+  int diag_type = -1; /* none */\n   \n   if (spec == error_mark_node)\n     return list;\n@@ -1366,7 +1373,15 @@ add_exception_specifier (list, spec, complain)\n   else if (processing_template_decl)\n     ok = 1;\n   else\n-    ok = COMPLETE_TYPE_P (complete_type (core));\n+    {\n+      ok = 1;\n+      /* 15.4/1 says that types in an exception specifier must be complete,\n+         but it seems more reasonable to only require this on definitions\n+         and calls.  So just give a pedwarn at this point; we will give an\n+         error later if we hit one of those two cases.  */\n+      if (!COMPLETE_TYPE_P (complete_type (core)))\n+\tdiag_type = 2; /* pedwarn */\n+    }\n \n   if (ok)\n     {\n@@ -1378,8 +1393,12 @@ add_exception_specifier (list, spec, complain)\n       if (!probe)\n \tlist = tree_cons (NULL_TREE, spec, list);\n     }\n-  else if (complain)\n-    cxx_incomplete_type_error (NULL_TREE, core);\n+  else\n+    diag_type = 0; /* error */\n+    \n+  if (diag_type >= 0 && complain)\n+    cxx_incomplete_type_diagnostic (NULL_TREE, core, diag_type);\n+\n   return list;\n }\n \n@@ -1418,3 +1437,34 @@ merge_exception_specifiers (list, add)\n     }\n   return list;\n }\n+\n+/* Subroutine of build_call.  Ensure that each of the types in the\n+   exception specification is complete.  Technically, 15.4/1 says that\n+   they need to be complete when we see a declaration of the function,\n+   but we should be able to get away with only requiring this when the\n+   function is defined or called.  See also add_exception_specifier.  */\n+\n+void\n+require_complete_eh_spec_types (fntype, decl)\n+     tree fntype, decl;\n+{\n+  tree raises;\n+  /* Don't complain about calls to op new.  */\n+  if (decl && DECL_ARTIFICIAL (decl))\n+    return;\n+  for (raises = TYPE_RAISES_EXCEPTIONS (fntype); raises;\n+       raises = TREE_CHAIN (raises))\n+    {\n+      tree type = TREE_VALUE (raises);\n+      if (type && !COMPLETE_TYPE_P (type))\n+\t{\n+\t  if (decl)\n+\t    error\n+\t      (\"call to function `%D' which throws incomplete type `%#T'\",\n+\t       decl, type);\n+\t  else\n+\t    error (\"call to function which throws incomplete type `%#T'\",\n+\t\t   decl);\n+\t}\n+    }\n+}"}, {"sha": "be8f327c0b7d5dc2dfcad73002fe84552687d64a", "filename": "gcc/testsuite/g++.dg/eh/spec5.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec5.C?ref=5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9", "patch": "@@ -0,0 +1,22 @@\n+// Test for extension to allow incomplete types in an\n+// exception-specification for a declaration.\n+\n+// { dg-do run }\n+// { dg-options \"-fpermissive -w\" }\n+\n+struct A;\n+\n+struct B\n+{\n+  void f () throw (A);\n+};\n+\n+struct A {};\n+\n+void B::f () throw (A) {}\n+\n+int main ()\n+{\n+  B b;\n+  b.f();\n+}"}, {"sha": "eb1177b07f515c017579ab5154035db031661122", "filename": "gcc/testsuite/g++.dg/eh/spec6.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec6.C?ref=5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9", "patch": "@@ -0,0 +1,19 @@\n+// Test that we don't allow incomplete types in an exception-specification\n+// for a definition, or at a call site.\n+\n+// { dg-options \"-fpermissive -w\" }\n+\n+struct A;\t\t\t// { dg-error \"\" }\n+\n+struct B\n+{\n+  void f () throw (A);\n+};\n+\n+void B::f () throw (A) {}\t// { dg-error \"A\" }\n+\n+int main ()\n+{\n+  B b;\n+  b.f();\t\t\t// { dg-error \"A\" }\n+}"}]}