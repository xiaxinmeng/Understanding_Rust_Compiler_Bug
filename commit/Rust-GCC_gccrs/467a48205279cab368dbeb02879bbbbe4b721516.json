{"sha": "467a48205279cab368dbeb02879bbbbe4b721516", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY3YTQ4MjA1Mjc5Y2FiMzY4ZGJlYjAyODc5YmJiYmU0YjcyMTUxNg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-02-12T01:31:28Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-02-12T01:32:10Z"}, "message": "analyzer: fix ICE in print_mem_ref [PR98969]\n\nPR analyzer/98969 and PR analyzer/99064 describes ICEs, in both cases\nwithin print_mem_ref, when falsely reporting memory leaks - though it\nis possible to generate the ICE on other diagnostics (which I added\nin one of the test cases).\n\nThis patch fixes the ICE, leaving the fix for the leak false positives\nas followup work.\n\nThe analyzer uses region_model::get_representative_path_var and\nregion_model::get_representative_tree to map back from its svalue\nand region classes to the tree type used by the rest of the compiler,\nand, in particular, for diagnostics.\n\nThe root cause of the ICE is sloppiness about types within those\nfunctions; specifically when casts were stripped off svalues.  To\ntrack these down I added wrapper functions that verify that the\ntypes of the results are correct, and in doing so found various\nother type-safety issues, which the patch also fixes.\n\nDoing so led to various changes in diagnostics messages due to\nmore accurate types, but I felt that these changes weren't\ndesirable.\nFor example, the warning at CVE-2005-1689-minimal.c line 48\nwhich expects:\n  double-'free' of 'inbuf.data'\nchanged fo\n  double-'free' of '(char *)inbuf.data'\n\nSo I added stripping of top-level casts where necessary to avoid\ncluttering diagnostics.\n\nFinally, the more accurate types led to worse results from\nreadability_comparator, where e.g. the event message at line 50\nof sensitive-1.c regressed from the precise:\n  passing sensitive value 'password' in call to 'called_by_test_5' from 'test_5'\nto the vaguer:\n  calling 'called_by_test_5' from 'test_5'\nThis was due to erroneously picking the initial value of \"password\"\nin the caller frame as the best value within the *callee* frame, due to\n\"char *\" vs \"const char *\", which confuses the logic for tracking values\nthat pass along callgraph edges.  The patch fixes this by combining the\nreadability tests for tree and stack depth, rather than performing\nthem in sequence, so that it favors the value in the deepest frame.\n\nAs noted above, the patch fixes the ICEs, but does not fix the\nleak false positives.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/98969\n\t* engine.cc (readability): Add names for the various arbitrary\n\tvalues.  Handle NOP_EXPR and INTEGER_CST.\n\t(readability_comparator): Combine the readability tests for\n\ttree and stack depth, rather than performing them sequentially.\n\t(impl_region_model_context::on_state_leak): Strip off top-level\n\tcasts.\n\t* region-model.cc (region_model::get_representative_path_var): Add\n\ttype-checking, moving the bulk of the implementation to...\n\t(region_model::get_representative_path_var_1): ...here.  Respect\n\ttypes in casts by recursing and re-adding the cast, rather than\n\tmerely stripping them off.  Use the correct type when handling\n\tregion_svalue.\n\t(region_model::get_representative_tree): Strip off any top-level\n\tcast.\n\t(region_model::get_representative_path_var): Add type-checking,\n\tmoving the bulk of the implementation to...\n\t(region_model::get_representative_path_var_1): ...here.\n\t* region-model.h (region_model::get_representative_path_var_1):\n\tNew decl\n\t(region_model::get_representative_path_var_1): New decl.\n\t* store.cc (append_pathvar_with_type): New.\n\t(binding_cluster::get_representative_path_vars): Cast path_vars\n\tto the correct type when adding them to *OUT_PVS.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/98969\n\t* g++.dg/analyzer/pr99064.C: New test.\n\t* gcc.dg/analyzer/pr98969.c: New test.", "tree": {"sha": "5e4231dc20a61c14c4591884117b987eb4ec969a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e4231dc20a61c14c4591884117b987eb4ec969a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/467a48205279cab368dbeb02879bbbbe4b721516", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/467a48205279cab368dbeb02879bbbbe4b721516", "html_url": "https://github.com/Rust-GCC/gccrs/commit/467a48205279cab368dbeb02879bbbbe4b721516", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/467a48205279cab368dbeb02879bbbbe4b721516/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c5cdb31bd423f650aaa3917cc21de0cde91e0fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c5cdb31bd423f650aaa3917cc21de0cde91e0fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c5cdb31bd423f650aaa3917cc21de0cde91e0fc"}], "stats": {"total": 224, "additions": 200, "deletions": 24}, "files": [{"sha": "89b3be22ecbd28855fd151b5ced2ebdc689424df", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/467a48205279cab368dbeb02879bbbbe4b721516/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/467a48205279cab368dbeb02879bbbbe4b721516/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=467a48205279cab368dbeb02879bbbbe4b721516", "patch": "@@ -456,6 +456,9 @@ class leak_stmt_finder : public stmt_finder\n static int\n readability (const_tree expr)\n {\n+  /* Arbitrarily-chosen \"high readability\" value.  */\n+  const int HIGH_READABILITY = 65536;\n+\n   gcc_assert (expr);\n   switch (TREE_CODE (expr))\n     {\n@@ -479,8 +482,7 @@ readability (const_tree expr)\n     case PARM_DECL:\n     case VAR_DECL:\n       if (DECL_NAME (expr))\n-\t/* Arbitrarily-chosen \"high readability\" value.  */\n-\treturn 65536;\n+\treturn HIGH_READABILITY;\n       else\n \t/* We don't want to print temporaries.  For example, the C FE\n \t   prints them as e.g. \"<Uxxxx>\" where \"xxxx\" is the low 16 bits\n@@ -490,7 +492,17 @@ readability (const_tree expr)\n     case RESULT_DECL:\n       /* Printing \"<return-value>\" isn't ideal, but is less awful than\n \t trying to print a temporary.  */\n-      return 32768;\n+      return HIGH_READABILITY / 2;\n+\n+    case NOP_EXPR:\n+      {\n+\t/* Impose a moderate readability penalty for casts.  */\n+\tconst int CAST_PENALTY = 32;\n+\treturn readability (TREE_OPERAND (expr, 0)) - CAST_PENALTY;\n+      }\n+\n+    case INTEGER_CST:\n+      return HIGH_READABILITY;\n \n     default:\n       return 0;\n@@ -508,14 +520,25 @@ readability_comparator (const void *p1, const void *p2)\n   path_var pv1 = *(path_var const *)p1;\n   path_var pv2 = *(path_var const *)p2;\n \n-  int r1 = readability (pv1.m_tree);\n-  int r2 = readability (pv2.m_tree);\n-  if (int cmp = r2 - r1)\n-    return cmp;\n+  const int tree_r1 = readability (pv1.m_tree);\n+  const int tree_r2 = readability (pv2.m_tree);\n \n   /* Favor items that are deeper on the stack and hence more recent;\n      this also favors locals over globals.  */\n-  if (int cmp = pv2.m_stack_depth - pv1.m_stack_depth)\n+  const int COST_PER_FRAME = 64;\n+  const int depth_r1 = pv1.m_stack_depth * COST_PER_FRAME;\n+  const int depth_r2 = pv2.m_stack_depth * COST_PER_FRAME;\n+\n+  /* Combine the scores from the tree and from the stack depth.\n+     This e.g. lets us have a slightly penalized cast in the most\n+     recent stack frame \"beat\" an uncast value in an older stack frame.  */\n+  const int sum_r1 = tree_r1 + depth_r1;\n+  const int sum_r2 = tree_r2 + depth_r2;\n+  if (int cmp = sum_r2 - sum_r1)\n+    return cmp;\n+\n+  /* Otherwise, more readable trees win.  */\n+  if (int cmp = tree_r2 - tree_r1)\n     return cmp;\n \n   /* Otherwise, if they have the same readability, then impose an\n@@ -580,6 +603,10 @@ impl_region_model_context::on_state_leak (const state_machine &sm,\n     = m_old_state->m_region_model->get_representative_path_var (sval,\n \t\t\t\t\t\t\t\t&visited);\n \n+  /* Strip off top-level casts  */\n+  if (leaked_pv.m_tree && TREE_CODE (leaked_pv.m_tree) == NOP_EXPR)\n+    leaked_pv.m_tree = TREE_OPERAND (leaked_pv.m_tree, 0);\n+\n   /* This might be NULL; the pending_diagnostic subclasses need to cope\n      with this.  */\n   tree leaked_tree = leaked_pv.m_tree;"}, {"sha": "2fc07c4964928bbc9a5e61b335a2942710289e97", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 84, "deletions": 14, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/467a48205279cab368dbeb02879bbbbe4b721516/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/467a48205279cab368dbeb02879bbbbe4b721516/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=467a48205279cab368dbeb02879bbbbe4b721516", "patch": "@@ -2202,25 +2202,33 @@ region_model::eval_condition (tree lhs,\n   return eval_condition (get_rvalue (lhs, ctxt), op, get_rvalue (rhs, ctxt));\n }\n \n-/* Attempt to return a path_var that represents SVAL, or return NULL_TREE.\n+/* Implementation of region_model::get_representative_path_var.\n+   Attempt to return a path_var that represents SVAL, or return NULL_TREE.\n    Use VISITED to prevent infinite mutual recursion with the overload for\n    regions.  */\n \n path_var\n-region_model::get_representative_path_var (const svalue *sval,\n-\t\t\t\t\t    svalue_set *visited) const\n+region_model::get_representative_path_var_1 (const svalue *sval,\n+\t\t\t\t\t     svalue_set *visited) const\n {\n-  if (sval == NULL)\n-    return path_var (NULL_TREE, 0);\n-\n-  if (const svalue *cast_sval = sval->maybe_undo_cast ())\n-    sval = cast_sval;\n+  gcc_assert (sval);\n \n   /* Prevent infinite recursion.  */\n   if (visited->contains (sval))\n     return path_var (NULL_TREE, 0);\n   visited->add (sval);\n \n+  /* Handle casts by recursion into get_representative_path_var.  */\n+  if (const svalue *cast_sval = sval->maybe_undo_cast ())\n+    {\n+      path_var result = get_representative_path_var (cast_sval, visited);\n+      tree orig_type = sval->get_type ();\n+      /* If necessary, wrap the result in a cast.  */\n+      if (result.m_tree && orig_type)\n+\tresult.m_tree = build1 (NOP_EXPR, orig_type, result.m_tree);\n+      return result;\n+    }\n+\n   auto_vec<path_var> pvs;\n   m_store.get_representative_path_vars (this, visited, sval, &pvs);\n \n@@ -2233,7 +2241,7 @@ region_model::get_representative_path_var (const svalue *sval,\n       const region *reg = ptr_sval->get_pointee ();\n       if (path_var pv = get_representative_path_var (reg, visited))\n \treturn path_var (build1 (ADDR_EXPR,\n-\t\t\t\t TREE_TYPE (sval->get_type ()),\n+\t\t\t\t sval->get_type (),\n \t\t\t\t pv.m_tree),\n \t\t\t pv.m_stack_depth);\n     }\n@@ -2261,25 +2269,63 @@ region_model::get_representative_path_var (const svalue *sval,\n   return pvs[0];\n }\n \n-/* Attempt to return a tree that represents SVAL, or return NULL_TREE.  */\n+/* Attempt to return a path_var that represents SVAL, or return NULL_TREE.\n+   Use VISITED to prevent infinite mutual recursion with the overload for\n+   regions\n+\n+   This function defers to get_representative_path_var_1 to do the work;\n+   it adds verification that get_representative_path_var_1 returned a tree\n+   of the correct type.  */\n+\n+path_var\n+region_model::get_representative_path_var (const svalue *sval,\n+\t\t\t\t\t   svalue_set *visited) const\n+{\n+  if (sval == NULL)\n+    return path_var (NULL_TREE, 0);\n+\n+  tree orig_type = sval->get_type ();\n+\n+  path_var result = get_representative_path_var_1 (sval, visited);\n+\n+  /* Verify that the result has the same type as SVAL, if any.  */\n+  if (result.m_tree && orig_type)\n+    gcc_assert (TREE_TYPE (result.m_tree) == orig_type);\n+\n+  return result;\n+}\n+\n+/* Attempt to return a tree that represents SVAL, or return NULL_TREE.\n+\n+   Strip off any top-level cast, to avoid messages like\n+     double-free of '(void *)ptr'\n+   from analyzer diagnostics.  */\n \n tree\n region_model::get_representative_tree (const svalue *sval) const\n {\n   svalue_set visited;\n-  return get_representative_path_var (sval, &visited).m_tree;\n+  tree expr = get_representative_path_var (sval, &visited).m_tree;\n+\n+  /* Strip off any top-level cast.  */\n+  if (expr && TREE_CODE (expr) == NOP_EXPR)\n+    return TREE_OPERAND (expr, 0);\n+\n+  return expr;\n }\n \n-/* Attempt to return a path_var that represents REG, or return\n+/* Implementation of region_model::get_representative_path_var.\n+\n+   Attempt to return a path_var that represents REG, or return\n    the NULL path_var.\n    For example, a region for a field of a local would be a path_var\n    wrapping a COMPONENT_REF.\n    Use VISITED to prevent infinite mutual recursion with the overload for\n    svalues.  */\n \n path_var\n-region_model::get_representative_path_var (const region *reg,\n-\t\t\t\t\t    svalue_set *visited) const\n+region_model::get_representative_path_var_1 (const region *reg,\n+\t\t\t\t\t     svalue_set *visited) const\n {\n   switch (reg->get_kind ())\n     {\n@@ -2411,6 +2457,30 @@ region_model::get_representative_path_var (const region *reg,\n     }\n }\n \n+/* Attempt to return a path_var that represents REG, or return\n+   the NULL path_var.\n+   For example, a region for a field of a local would be a path_var\n+   wrapping a COMPONENT_REF.\n+   Use VISITED to prevent infinite mutual recursion with the overload for\n+   svalues.\n+\n+   This function defers to get_representative_path_var_1 to do the work;\n+   it adds verification that get_representative_path_var_1 returned a tree\n+   of the correct type.  */\n+\n+path_var\n+region_model::get_representative_path_var (const region *reg,\n+\t\t\t\t\t   svalue_set *visited) const\n+{\n+  path_var result = get_representative_path_var_1 (reg, visited);\n+\n+  /* Verify that the result has the same type as REG, if any.  */\n+  if (result.m_tree && reg->get_type ())\n+    gcc_assert (TREE_TYPE (result.m_tree) == reg->get_type ());\n+\n+  return result;\n+}\n+\n /* Update this model for any phis in SNODE, assuming we came from\n    LAST_CFG_SUPEREDGE.  */\n "}, {"sha": "c73e39fddd96cee11f355987a21c2efa9f4829b9", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/467a48205279cab368dbeb02879bbbbe4b721516/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/467a48205279cab368dbeb02879bbbbe4b721516/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=467a48205279cab368dbeb02879bbbbe4b721516", "patch": "@@ -581,6 +581,13 @@ class region_model\n   const region *get_lvalue_1 (path_var pv, region_model_context *ctxt);\n   const svalue *get_rvalue_1 (path_var pv, region_model_context *ctxt);\n \n+  path_var\n+  get_representative_path_var_1 (const svalue *sval,\n+\t\t\t\t svalue_set *visited) const;\n+  path_var\n+  get_representative_path_var_1 (const region *reg,\n+\t\t\t\t svalue_set *visited) const;\n+\n   void add_any_constraints_from_ssa_def_stmt (tree lhs,\n \t\t\t\t\t      enum tree_code op,\n \t\t\t\t\t      tree rhs,"}, {"sha": "53b6e21aa7563060583e69e465530d8639c48ff4", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/467a48205279cab368dbeb02879bbbbe4b721516/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/467a48205279cab368dbeb02879bbbbe4b721516/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=467a48205279cab368dbeb02879bbbbe4b721516", "patch": "@@ -1375,6 +1375,21 @@ binding_cluster::redundant_p () const\n \t  && !m_touched);\n }\n \n+/* Add PV to OUT_PVS, casting it to TYPE if if is not already of that type.  */\n+\n+static void\n+append_pathvar_with_type (path_var pv,\n+\t\t\t  tree type,\n+\t\t\t  auto_vec<path_var> *out_pvs)\n+{\n+  gcc_assert (pv.m_tree);\n+\n+  if (TREE_TYPE (pv.m_tree) != type)\n+    pv.m_tree = build1 (NOP_EXPR, type, pv.m_tree);\n+\n+  out_pvs->safe_push (pv);\n+}\n+\n /* Find representative path_vars for SVAL within this binding of BASE_REG,\n    appending the results to OUT_PVS.  */\n \n@@ -1411,7 +1426,7 @@ binding_cluster::get_representative_path_vars (const region_model *model,\n \t\t  if (path_var pv\n \t\t      = model->get_representative_path_var (subregion,\n \t\t\t\t\t\t\t    visited))\n-\t\t    out_pvs->safe_push (pv);\n+\t\t    append_pathvar_with_type (pv, sval->get_type (), out_pvs);\n \t\t}\n \t    }\n \t  else\n@@ -1420,7 +1435,7 @@ binding_cluster::get_representative_path_vars (const region_model *model,\n \t      if (path_var pv\n \t\t  = model->get_representative_path_var (skey->get_region (),\n \t\t\t\t\t\t\tvisited))\n-\t\tout_pvs->safe_push (pv);\n+\t\tappend_pathvar_with_type (pv, sval->get_type (), out_pvs);\n \t    }\n \t}\n     }"}, {"sha": "a002219bf5809085de77ff9f716aee544a1e5fd9", "filename": "gcc/testsuite/g++.dg/analyzer/pr99064.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/467a48205279cab368dbeb02879bbbbe4b721516/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr99064.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/467a48205279cab368dbeb02879bbbbe4b721516/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr99064.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr99064.C?ref=467a48205279cab368dbeb02879bbbbe4b721516", "patch": "@@ -0,0 +1,39 @@\n+// { dg-do compile { target c++17 } }\n+// { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n+template <typename> struct iterator_traits;\n+template <typename _Tp> struct iterator_traits<_Tp *> {\n+  typedef _Tp &reference;\n+};\n+template <typename _Iterator> struct __normal_iterator {\n+  _Iterator _M_current;\n+  __normal_iterator(_Iterator &__i) : _M_current(__i) {}\n+  typename iterator_traits<_Iterator>::reference operator*() {\n+    return *_M_current;\n+  }\n+};\n+template <typename> struct allocator;\n+template <typename> struct allocator_traits;\n+template <typename _Tp> struct allocator_traits<allocator<_Tp>> {\n+  using pointer = _Tp *;\n+};\n+struct TPkcs11Token;\n+struct __alloc_traits : allocator_traits<allocator<TPkcs11Token>> {};\n+struct _Vector_base {\n+  typedef __alloc_traits::pointer pointer;\n+  struct {\n+    pointer _M_start;\n+  } _M_impl;\n+};\n+struct : _Vector_base {\n+  __normal_iterator<pointer> begin() { return _M_impl._M_start; }\n+} list_tokens_token_list;\n+struct TPkcs11Token {\n+  int *add_info;\n+};\n+void list_tokens() {\n+  for (__normal_iterator base = list_tokens_token_list.begin();;) {\n+    int *add_info = new int;\n+    (*base).add_info = add_info; // { dg-bogus \"leak\" \"PR analyzer/98969\" { xfail *-*-* } }\n+  }\n+}"}, {"sha": "8298f26389823a38bc96666526253f735d04c19a", "filename": "gcc/testsuite/gcc.dg/analyzer/pr98969.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/467a48205279cab368dbeb02879bbbbe4b721516/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr98969.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/467a48205279cab368dbeb02879bbbbe4b721516/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr98969.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr98969.c?ref=467a48205279cab368dbeb02879bbbbe4b721516", "patch": "@@ -0,0 +1,18 @@\n+struct foo\n+{\n+  char *expr;\n+};\n+\n+void\n+test_1 (long int i)\n+{\n+  struct foo *f = (struct foo *)i;\n+  f->expr = __builtin_malloc (1024);\n+} /* { dg-bogus \"leak\" \"PR analyzer/98969\" { xfail *-*-* } } */\n+\n+void\n+test_2 (long int i)\n+{\n+  __builtin_free (((struct foo *)i)->expr);\n+  __builtin_free (((struct foo *)i)->expr); /* { dg-warning \"double-'free' of '\\\\*\\\\(\\\\(struct foo \\\\*\\\\)i\\\\)\\\\.expr'\" } */\n+}"}]}