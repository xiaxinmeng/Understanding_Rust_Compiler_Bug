{"sha": "4b59d19ffdb4857e14328d8d783176b97ccde23e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI1OWQxOWZmZGI0ODU3ZTE0MzI4ZDhkNzgzMTc2Yjk3Y2NkZTIzZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-05-10T14:30:02Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-05-10T14:30:02Z"}, "message": "re PR target/70927 ([6 only] avx512dq instructions emitted even with -mavx512vl -mno-avx512dq)\n\n\tPR target/70927\n\t* config/i386/sse.md (<sse>_andnot<mode>3<mask_name>),\n\t*<code><mode>3<mask_name>): For !TARGET_AVX512DQ and EVEX encoding,\n\tuse vp*[dq] instead of v*p[sd] instructions and adjust mode attribute\n\taccordingly.\n\n\t* gcc.target/i386/avx512vl-logic-1.c: New test.\n\t* gcc.target/i386/avx512vl-logic-2.c: New test.\n\t* gcc.target/i386/avx512dq-logic-2.c: New test.\n\nFrom-SVN: r236083", "tree": {"sha": "2d07650232d9d348ae2623cc257cce9b7030dcaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d07650232d9d348ae2623cc257cce9b7030dcaa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b59d19ffdb4857e14328d8d783176b97ccde23e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b59d19ffdb4857e14328d8d783176b97ccde23e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b59d19ffdb4857e14328d8d783176b97ccde23e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b59d19ffdb4857e14328d8d783176b97ccde23e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b5ee426fcfe9d473edff34cd65f99c057799d7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b5ee426fcfe9d473edff34cd65f99c057799d7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b5ee426fcfe9d473edff34cd65f99c057799d7d"}], "stats": {"total": 637, "additions": 598, "deletions": 39}, "files": [{"sha": "dfbb1c3e0736245df68fd64b388916c8d7317ac8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b59d19ffdb4857e14328d8d783176b97ccde23e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b59d19ffdb4857e14328d8d783176b97ccde23e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b59d19ffdb4857e14328d8d783176b97ccde23e", "patch": "@@ -1,3 +1,11 @@\n+2016-05-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/70927\n+\t* config/i386/sse.md (<sse>_andnot<mode>3<mask_name>),\n+\t*<code><mode>3<mask_name>): For !TARGET_AVX512DQ and EVEX encoding,\n+\tuse vp*[dq] instead of v*p[sd] instructions and adjust mode attribute\n+\taccordingly.\n+\n 2016-05-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR target/70963"}, {"sha": "dd1ff960f53a12e0683fcd6b6ee26340d99643d5", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 59, "deletions": 39, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b59d19ffdb4857e14328d8d783176b97ccde23e/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b59d19ffdb4857e14328d8d783176b97ccde23e/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=4b59d19ffdb4857e14328d8d783176b97ccde23e", "patch": "@@ -2783,54 +2783,61 @@\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \n (define_insn \"<sse>_andnot<mode>3<mask_name>\"\n-  [(set (match_operand:VF_128_256 0 \"register_operand\" \"=x,v\")\n+  [(set (match_operand:VF_128_256 0 \"register_operand\" \"=x,x,v,v\")\n \t(and:VF_128_256\n \t  (not:VF_128_256\n-\t    (match_operand:VF_128_256 1 \"register_operand\" \"0,v\"))\n-\t  (match_operand:VF_128_256 2 \"vector_operand\" \"xBm,vm\")))]\n+\t    (match_operand:VF_128_256 1 \"register_operand\" \"0,x,v,v\"))\n+\t  (match_operand:VF_128_256 2 \"vector_operand\" \"xBm,xm,vm,vm\")))]\n   \"TARGET_SSE && <mask_avx512vl_condition>\"\n {\n   static char buf[128];\n   const char *ops;\n   const char *suffix;\n \n-  switch (get_attr_mode (insn))\n-    {\n-    case MODE_V8SF:\n-    case MODE_V4SF:\n-      suffix = \"ps\";\n-      break;\n-    default:\n-      suffix = \"<ssemodesuffix>\";\n-    }\n-\n   switch (which_alternative)\n     {\n     case 0:\n       ops = \"andn%s\\t{%%2, %%0|%%0, %%2}\";\n       break;\n     case 1:\n+    case 2:\n+    case 3:\n       ops = \"vandn%s\\t{%%2, %%1, %%0<mask_operand3_1>|%%0<mask_operand3_1>, %%1, %%2}\";\n       break;\n     default:\n       gcc_unreachable ();\n     }\n \n-  /* There is no vandnp[sd] in avx512f.  Use vpandn[qd].  */\n-  if (<mask_applied> && !TARGET_AVX512DQ)\n+  switch (get_attr_mode (insn))\n     {\n+    case MODE_V8SF:\n+    case MODE_V4SF:\n+      suffix = \"ps\";\n+      break;\n+    case MODE_OI:\n+    case MODE_TI:\n+      /* There is no vandnp[sd] in avx512f.  Use vpandn[qd].  */\n       suffix = GET_MODE_INNER (<MODE>mode) == DFmode ? \"q\" : \"d\";\n       ops = \"vpandn%s\\t{%%2, %%1, %%0<mask_operand3_1>|%%0<mask_operand3_1>, %%1, %%2}\";\n+      break;\n+    default:\n+      suffix = \"<ssemodesuffix>\";\n     }\n \n   snprintf (buf, sizeof (buf), ops, suffix);\n   return buf;\n }\n-  [(set_attr \"isa\" \"noavx,avx\")\n+  [(set_attr \"isa\" \"noavx,avx,avx512dq,avx512f\")\n    (set_attr \"type\" \"sselog\")\n-   (set_attr \"prefix\" \"orig,maybe_evex\")\n+   (set_attr \"prefix\" \"orig,maybe_vex,evex,evex\")\n    (set (attr \"mode\")\n-\t(cond [(and (match_test \"<MODE_SIZE> == 16\")\n+\t(cond [(and (match_test \"<mask_applied>\")\n+\t\t    (and (eq_attr \"alternative\" \"1\")\n+\t\t\t (match_test \"!TARGET_AVX512DQ\")))\n+\t\t (const_string \"<sseintvecmode2>\")\n+\t       (eq_attr \"alternative\" \"3\")\n+\t\t (const_string \"<sseintvecmode2>\")\n+\t       (and (match_test \"<MODE_SIZE> == 16\")\n \t\t    (match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\"))\n \t\t (const_string \"<ssePSmode>\")\n \t       (match_test \"TARGET_AVX\")\n@@ -2870,7 +2877,10 @@\n }\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix\" \"evex\")\n-   (set_attr \"mode\" \"<sseinsnmode>\")])\n+   (set (attr \"mode\")\n+        (if_then_else (match_test \"TARGET_AVX512DQ\")\n+\t\t      (const_string \"<sseinsnmode>\")\n+\t\t      (const_string \"XI\")))])\n \n (define_expand \"<code><mode>3<mask_name>\"\n   [(set (match_operand:VF_128_256 0 \"register_operand\")\n@@ -2889,54 +2899,61 @@\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\")\n \n (define_insn \"*<code><mode>3<mask_name>\"\n-  [(set (match_operand:VF_128_256 0 \"register_operand\" \"=x,v\")\n+  [(set (match_operand:VF_128_256 0 \"register_operand\" \"=x,x,v,v\")\n \t(any_logic:VF_128_256\n-\t  (match_operand:VF_128_256 1 \"vector_operand\" \"%0,v\")\n-\t  (match_operand:VF_128_256 2 \"vector_operand\" \"xBm,vm\")))]\n+\t  (match_operand:VF_128_256 1 \"vector_operand\" \"%0,x,v,v\")\n+\t  (match_operand:VF_128_256 2 \"vector_operand\" \"xBm,xm,vm,vm\")))]\n   \"TARGET_SSE && <mask_avx512vl_condition>\n    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n {\n   static char buf[128];\n   const char *ops;\n   const char *suffix;\n \n-  switch (get_attr_mode (insn))\n-    {\n-    case MODE_V8SF:\n-    case MODE_V4SF:\n-      suffix = \"ps\";\n-      break;\n-    default:\n-      suffix = \"<ssemodesuffix>\";\n-    }\n-\n   switch (which_alternative)\n     {\n     case 0:\n       ops = \"<logic>%s\\t{%%2, %%0|%%0, %%2}\";\n       break;\n     case 1:\n+    case 2:\n+    case 3:\n       ops = \"v<logic>%s\\t{%%2, %%1, %%0<mask_operand3_1>|%%0<mask_operand3_1>, %%1, %%2}\";\n       break;\n     default:\n       gcc_unreachable ();\n     }\n \n-  /* There is no v<logic>p[sd] in avx512f.  Use vp<logic>[dq].  */\n-  if (<mask_applied> && !TARGET_AVX512DQ)\n+  switch (get_attr_mode (insn))\n     {\n+    case MODE_V8SF:\n+    case MODE_V4SF:\n+      suffix = \"ps\";\n+      break;\n+    case MODE_OI:\n+    case MODE_TI:\n+      /* There is no v<logic>p[sd] in avx512f.  Use vp<logic>[qd].  */\n       suffix = GET_MODE_INNER (<MODE>mode) == DFmode ? \"q\" : \"d\";\n       ops = \"vp<logic>%s\\t{%%2, %%1, %%0<mask_operand3_1>|%%0<mask_operand3_1>, %%1, %%2}\";\n+      break;\n+    default:\n+      suffix = \"<ssemodesuffix>\";\n     }\n \n   snprintf (buf, sizeof (buf), ops, suffix);\n   return buf;\n }\n-  [(set_attr \"isa\" \"noavx,avx\")\n+  [(set_attr \"isa\" \"noavx,avx,avx512dq,avx512f\")\n    (set_attr \"type\" \"sselog\")\n-   (set_attr \"prefix\" \"orig,maybe_evex\")\n+   (set_attr \"prefix\" \"orig,maybe_evex,evex,evex\")\n    (set (attr \"mode\")\n-\t(cond [(and (match_test \"<MODE_SIZE> == 16\")\n+\t(cond [(and (match_test \"<mask_applied>\")\n+\t\t    (and (eq_attr \"alternative\" \"1\")\n+\t\t\t (match_test \"!TARGET_AVX512DQ\")))\n+\t\t (const_string \"<sseintvecmode2>\")\n+\t       (eq_attr \"alternative\" \"3\")\n+\t\t (const_string \"<sseintvecmode2>\")\n+\t       (and (match_test \"<MODE_SIZE> == 16\")\n \t\t    (match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\"))\n \t\t (const_string \"<ssePSmode>\")\n \t       (match_test \"TARGET_AVX\")\n@@ -2961,7 +2978,7 @@\n   ops = \"\";\n \n   /* There is no v<logic>p[sd] in avx512f.  Use vp<logic>[dq].  */\n-  if ((<MODE_SIZE> == 64 || <mask_applied>) && !TARGET_AVX512DQ)\n+  if (!TARGET_AVX512DQ)\n     {\n       suffix = GET_MODE_INNER (<MODE>mode) == DFmode ? \"q\" : \"d\";\n       ops = \"p\";\n@@ -2974,7 +2991,10 @@\n }\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix\" \"evex\")\n-   (set_attr \"mode\" \"<sseinsnmode>\")])\n+   (set (attr \"mode\")\n+        (if_then_else (match_test \"TARGET_AVX512DQ\")\n+\t\t      (const_string \"<sseinsnmode>\")\n+\t\t      (const_string \"XI\")))])\n \n (define_expand \"copysign<mode>3\"\n   [(set (match_dup 4)"}, {"sha": "deec34e8bbd74256337ac90818cd56e2f10fb6c3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b59d19ffdb4857e14328d8d783176b97ccde23e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b59d19ffdb4857e14328d8d783176b97ccde23e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4b59d19ffdb4857e14328d8d783176b97ccde23e", "patch": "@@ -1,3 +1,10 @@\n+2016-05-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/70927\n+\t* gcc.target/i386/avx512vl-logic-1.c: New test.\n+\t* gcc.target/i386/avx512vl-logic-2.c: New test.\n+\t* gcc.target/i386/avx512dq-logic-2.c: New test.\n+\n 2016-05-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR target/70963"}, {"sha": "e358ff56848d8ffeb4e6ebc37f4b4708838c2c62", "filename": "gcc/testsuite/gcc.target/i386/avx512dq-logic-2.c", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b59d19ffdb4857e14328d8d783176b97ccde23e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512dq-logic-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b59d19ffdb4857e14328d8d783176b97ccde23e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512dq-logic-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512dq-logic-2.c?ref=4b59d19ffdb4857e14328d8d783176b97ccde23e", "patch": "@@ -0,0 +1,196 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2 -mavx512vl -mavx512dq\" } */\n+\n+#include <x86intrin.h>\n+\n+__m128d\n+f1 (__m128d a, __m128d b)\n+{\n+  register __m128d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_and_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandpd\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128d\n+f2 (__m128d a, __m128d b)\n+{\n+  register __m128d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_or_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vorpd\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128d\n+f3 (__m128d a, __m128d b)\n+{\n+  register __m128d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_xor_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vxorpd\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128d\n+f4 (__m128d a, __m128d b)\n+{\n+  register __m128d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_andnot_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandnpd\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128\n+f5 (__m128 a, __m128 b)\n+{\n+  register __m128 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_and_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandps\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128\n+f6 (__m128 a, __m128 b)\n+{\n+  register __m128 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_or_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vorps\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128\n+f7 (__m128 a, __m128 b)\n+{\n+  register __m128 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_xor_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vxorps\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128\n+f8 (__m128 a, __m128 b)\n+{\n+  register __m128 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_andnot_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandnps\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m256d\n+f9 (__m256d a, __m256d b)\n+{\n+  register __m256d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_and_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandpd\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256d\n+f10 (__m256d a, __m256d b)\n+{\n+  register __m256d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_or_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vorpd\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256d\n+f11 (__m256d a, __m256d b)\n+{\n+  register __m256d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_xor_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vxorpd\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256d\n+f12 (__m256d a, __m256d b)\n+{\n+  register __m256d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_andnot_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandnpd\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256\n+f13 (__m256 a, __m256 b)\n+{\n+  register __m256 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_and_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandps\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256\n+f14 (__m256 a, __m256 b)\n+{\n+  register __m256 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_or_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vorps\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256\n+f15 (__m256 a, __m256 b)\n+{\n+  register __m256 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_xor_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vxorps\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256\n+f16 (__m256 a, __m256 b)\n+{\n+  register __m256 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_andnot_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandnps\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */"}, {"sha": "ec5f3d980c1333f589d9efa50b70bab0a707d703", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-logic-1.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b59d19ffdb4857e14328d8d783176b97ccde23e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-logic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b59d19ffdb4857e14328d8d783176b97ccde23e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-logic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-logic-1.c?ref=4b59d19ffdb4857e14328d8d783176b97ccde23e", "patch": "@@ -0,0 +1,132 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx512vl -mno-avx512dq\" } */\n+\n+#include <x86intrin.h>\n+\n+__m128d\n+f1 (__m128d a, __m128d b)\n+{\n+  return _mm_and_pd (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandpd\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128d\n+f2 (__m128d a, __m128d b)\n+{\n+  return _mm_or_pd (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vorpd\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128d\n+f3 (__m128d a, __m128d b)\n+{\n+  return _mm_xor_pd (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vxorpd\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128d\n+f4 (__m128d a, __m128d b)\n+{\n+  return _mm_andnot_pd (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandnpd\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128\n+f5 (__m128 a, __m128 b)\n+{\n+  return _mm_and_ps (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandps\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128\n+f6 (__m128 a, __m128 b)\n+{\n+  return _mm_or_ps (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vorps\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128\n+f7 (__m128 a, __m128 b)\n+{\n+  return _mm_xor_ps (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vxorps\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128\n+f8 (__m128 a, __m128 b)\n+{\n+  return _mm_andnot_ps (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandnps\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m256d\n+f9 (__m256d a, __m256d b)\n+{\n+  return _mm256_and_pd (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandpd\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256d\n+f10 (__m256d a, __m256d b)\n+{\n+  return _mm256_or_pd (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vorpd\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256d\n+f11 (__m256d a, __m256d b)\n+{\n+  return _mm256_xor_pd (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vxorpd\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256d\n+f12 (__m256d a, __m256d b)\n+{\n+  return _mm256_andnot_pd (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandnpd\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256\n+f13 (__m256 a, __m256 b)\n+{\n+  return _mm256_and_ps (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandps\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256\n+f14 (__m256 a, __m256 b)\n+{\n+  return _mm256_or_ps (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vorps\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256\n+f15 (__m256 a, __m256 b)\n+{\n+  return _mm256_xor_ps (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vxorps\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256\n+f16 (__m256 a, __m256 b)\n+{\n+  return _mm256_andnot_ps (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"vandnps\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */"}, {"sha": "7ccef279a8b1e473e3da133e2078ff9a0cacb978", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-logic-2.c", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b59d19ffdb4857e14328d8d783176b97ccde23e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-logic-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b59d19ffdb4857e14328d8d783176b97ccde23e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-logic-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-logic-2.c?ref=4b59d19ffdb4857e14328d8d783176b97ccde23e", "patch": "@@ -0,0 +1,196 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2 -mavx512vl -mno-avx512dq\" } */\n+\n+#include <x86intrin.h>\n+\n+__m128d\n+f1 (__m128d a, __m128d b)\n+{\n+  register __m128d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_and_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vpandq\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128d\n+f2 (__m128d a, __m128d b)\n+{\n+  register __m128d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_or_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vporq\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128d\n+f3 (__m128d a, __m128d b)\n+{\n+  register __m128d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_xor_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vpxorq\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128d\n+f4 (__m128d a, __m128d b)\n+{\n+  register __m128d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_andnot_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vpandnq\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128\n+f5 (__m128 a, __m128 b)\n+{\n+  register __m128 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_and_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vpandd\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128\n+f6 (__m128 a, __m128 b)\n+{\n+  register __m128 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_or_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vpord\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128\n+f7 (__m128 a, __m128 b)\n+{\n+  register __m128 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_xor_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vpxord\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m128\n+f8 (__m128 a, __m128 b)\n+{\n+  register __m128 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm_andnot_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vpandnd\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */\n+\n+__m256d\n+f9 (__m256d a, __m256d b)\n+{\n+  register __m256d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_and_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vpandq\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256d\n+f10 (__m256d a, __m256d b)\n+{\n+  register __m256d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_or_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vporq\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256d\n+f11 (__m256d a, __m256d b)\n+{\n+  register __m256d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_xor_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vpxorq\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256d\n+f12 (__m256d a, __m256d b)\n+{\n+  register __m256d c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_andnot_pd (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vpandnq\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256\n+f13 (__m256 a, __m256 b)\n+{\n+  register __m256 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_and_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vpandd\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256\n+f14 (__m256 a, __m256 b)\n+{\n+  register __m256 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_or_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vpord\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256\n+f15 (__m256 a, __m256 b)\n+{\n+  register __m256 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_xor_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vpxord\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */\n+\n+__m256\n+f16 (__m256 a, __m256 b)\n+{\n+  register __m256 c __asm (\"xmm16\") = a;\n+  asm volatile (\"\" : \"+v\" (c));\n+  c = _mm256_andnot_ps (c, b);\n+  asm volatile (\"\" : \"+v\" (c));\n+  return c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vpandnd\\[^\\n\\r\\]*ymm\\[0-9\\]\" 1 } } */"}]}