{"sha": "aac8697859d550b39baf967900578ee47259c419", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFjODY5Nzg1OWQ1NTBiMzliYWY5Njc5MDA1NzhlZTQ3MjU5YzQxOQ==", "commit": {"author": {"name": "Gary Benson", "email": "gbenson@redhat.com", "date": "2006-09-20T07:55:26Z"}, "committer": {"name": "Gary Benson", "email": "gary@gcc.gnu.org", "date": "2006-09-20T07:55:26Z"}, "message": "InetAddress.java: Mostly merged with Classpath.\n\n2006-09-20  Gary Benson  <gbenson@redhat.com>\n\n\t* java/net/InetAddress.java: Mostly merged with Classpath.\n\t* java/net/VMInetAddress.java: New file.\n\t* sources.am, Makefile.in: Rebuilt.\n\n\t* java/net/natVMNetworkInterfacePosix.cc\n\t(getInterfaces): Create InetAddress objects using\n\tInetAddress.getByAddress.\n\t* gnu/java/net/natPlainSocketImplPosix.cc\n\t(accept, getOption): Likewise.\n\t* gnu/java/net/natPlainDatagramSocketImplPosix.cc\n\t(peekData, receive, getLocalAddress): Likewise.\n\nFrom-SVN: r117075", "tree": {"sha": "0aef003fb0421fe80a9834590b2afda0c57aa5e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0aef003fb0421fe80a9834590b2afda0c57aa5e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aac8697859d550b39baf967900578ee47259c419", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac8697859d550b39baf967900578ee47259c419", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aac8697859d550b39baf967900578ee47259c419", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac8697859d550b39baf967900578ee47259c419/comments", "author": null, "committer": null, "parents": [{"sha": "884d9d372eb7518d50b6bd77d1420909a0e701cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/884d9d372eb7518d50b6bd77d1420909a0e701cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/884d9d372eb7518d50b6bd77d1420909a0e701cf"}], "stats": {"total": 777, "additions": 474, "deletions": 303}, "files": [{"sha": "0afeddee3c11e17a45f59ceaa9e271fa4889db9f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac8697859d550b39baf967900578ee47259c419/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac8697859d550b39baf967900578ee47259c419/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=aac8697859d550b39baf967900578ee47259c419", "patch": "@@ -1,3 +1,17 @@\n+2006-09-20  Gary Benson  <gbenson@redhat.com>\n+\n+\t* java/net/InetAddress.java: Mostly merged with Classpath.\n+\t* java/net/VMInetAddress.java: New file.\n+\t* sources.am, Makefile.in: Rebuilt.\n+\n+\t* java/net/natVMNetworkInterfacePosix.cc\n+\t(getInterfaces): Create InetAddress objects using\n+\tInetAddress.getByAddress.\n+\t* gnu/java/net/natPlainSocketImplPosix.cc\n+\t(accept, getOption): Likewise.\n+\t* gnu/java/net/natPlainDatagramSocketImplPosix.cc\n+\t(peekData, receive, getLocalAddress): Likewise.\n+\n 2006-09-19  Keith Seitz  <keiths@redhat.com>\n \n \t* testsuite/libjava.jvmti/jvmti.exp: New file."}, {"sha": "e81560cabc374b3119657e2e49c9ef607ab558e4", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac8697859d550b39baf967900578ee47259c419/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac8697859d550b39baf967900578ee47259c419/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=aac8697859d550b39baf967900578ee47259c419", "patch": "@@ -4136,6 +4136,7 @@ classpath/java/net/NoRouteToHostException.java \\\n classpath/java/net/PasswordAuthentication.java \\\n classpath/java/net/PortUnreachableException.java \\\n classpath/java/net/ProtocolException.java \\\n+classpath/java/net/ResolverCache.java \\\n classpath/java/net/ServerSocket.java \\\n classpath/java/net/Socket.java \\\n classpath/java/net/SocketAddress.java \\\n@@ -4156,6 +4157,7 @@ classpath/java/net/URLStreamHandler.java \\\n classpath/java/net/URLStreamHandlerFactory.java \\\n classpath/java/net/UnknownHostException.java \\\n classpath/java/net/UnknownServiceException.java \\\n+java/net/VMInetAddress.java \\\n java/net/VMNetworkInterface.java \\\n java/net/VMURLConnection.java\n "}, {"sha": "f7ffaa895c3f2f43151e4a0b221ccaaf5a1dbc9c", "filename": "libjava/gnu/java/net/natPlainDatagramSocketImplPosix.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac8697859d550b39baf967900578ee47259c419/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainDatagramSocketImplPosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac8697859d550b39baf967900578ee47259c419/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainDatagramSocketImplPosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainDatagramSocketImplPosix.cc?ref=aac8697859d550b39baf967900578ee47259c419", "patch": "@@ -290,7 +290,7 @@ gnu::java::net::PlainDatagramSocketImpl::peekData (::java::net::DatagramPacket *\n   else\n     throw new ::java::net::SocketException (JvNewStringUTF (\"invalid family\"));\n \n-  p->setAddress (new ::java::net::InetAddress (raddr, NULL));\n+  p->setAddress (::java::net::InetAddress::getByAddress (raddr));\n   p->setPort (rport);\n   p->length = (int) retlen;\n   return rport;\n@@ -430,7 +430,7 @@ gnu::java::net::PlainDatagramSocketImpl::receive (::java::net::DatagramPacket *p\n   else\n     throw new ::java::net::SocketException (JvNewStringUTF (\"invalid family\"));\n \n-  p->setAddress (new ::java::net::InetAddress (raddr, NULL));\n+  p->setAddress (::java::net::InetAddress::getByAddress (raddr));\n   p->setPort (rport);\n   p->length = (jint) retlen;\n   return;\n@@ -564,7 +564,7 @@ getLocalAddress (int native_fd)\n   else\n     throw new ::java::net::SocketException (JvNewStringUTF (\"invalid family\"));\n \n-  return new ::java::net::InetAddress (laddr, NULL);\n+  return ::java::net::InetAddress::getByAddress (laddr);\n }\n \n void"}, {"sha": "e4572fa3c375333746b199acb5a69857254a1366", "filename": "libjava/gnu/java/net/natPlainSocketImplPosix.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac8697859d550b39baf967900578ee47259c419/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac8697859d550b39baf967900578ee47259c419/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc?ref=aac8697859d550b39baf967900578ee47259c419", "patch": "@@ -308,7 +308,7 @@ gnu::java::net::PlainSocketImpl::accept (gnu::java::net::PlainSocketImpl *s)\n \n   s->native_fd = new_socket;\n   s->localport = localport;\n-  s->address = new ::java::net::InetAddress (raddr, NULL);\n+  s->address = ::java::net::InetAddress::getByAddress (raddr);\n   s->port = rport;\n   return;\n \n@@ -808,7 +808,7 @@ gnu::java::net::PlainSocketImpl::getOption (jint optID)\n           else\n             throw new ::java::net::SocketException\n               (JvNewStringUTF (\"invalid family\"));\n-          localAddress = new ::java::net::InetAddress (laddr, NULL);\n+          localAddress = ::java::net::InetAddress::getByAddress (laddr);\n         }\n \n       return localAddress;"}, {"sha": "bef9a6ecf19ae37c4408db019c34599c53e8c178", "filename": "libjava/java/net/InetAddress.java", "status": "modified", "additions": 332, "deletions": 295, "changes": 627, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac8697859d550b39baf967900578ee47259c419/libjava%2Fjava%2Fnet%2FInetAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac8697859d550b39baf967900578ee47259c419/libjava%2Fjava%2Fnet%2FInetAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInetAddress.java?ref=aac8697859d550b39baf967900578ee47259c419", "patch": "@@ -1,5 +1,6 @@\n /* InetAddress.java -- Class to model an Internet address\n-   Copyright (C) 1998, 1999, 2002, 2004, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2002, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,8 +39,6 @@\n \n package java.net;\n \n-import gnu.classpath.Configuration;\n-\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n@@ -58,6 +57,7 @@\n  *\n  * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @author Per Bothner\n+ * @author Gary Benson (gbenson@redhat.com)\n  *\n  * @specnote This class is not final since JK 1.4\n  */\n@@ -69,23 +69,44 @@ public class InetAddress implements Serializable\n    * Dummy InetAddress, used to bind socket to any (all) network interfaces.\n    */\n   static InetAddress ANY_IF;\n-    \n-  private static final byte[] loopbackAddress = { 127, 0, 0, 1 };\n-\n-  private static final InetAddress loopback \n-    = new Inet4Address(loopbackAddress, \"localhost\");\n-\n-  private static InetAddress localhost = null;\n-\n   static\n   {\n-    // load the shared library needed for name resolution\n-    if (Configuration.INIT_LOAD_LIBRARY)\n-      System.loadLibrary(\"javanet\");\n-    \n-    byte[] zeros = { 0, 0, 0, 0 };\n-    ANY_IF = new Inet4Address(zeros, \"0.0.0.0\");\n+    byte[] addr;\n+    try\n+      {\n+\taddr = VMInetAddress.lookupInaddrAny();\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\t// Make one up and hope it works.\n+\taddr = new byte[] {0, 0, 0, 0};\n+      }\n+    try\n+      {\n+\tANY_IF = getByAddress(addr);\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tthrow new RuntimeException(\"should never happen\", e);\n+      }\n+    ANY_IF.hostName = ANY_IF.getHostName();\n   }\n+  \n+  /**\n+   * Stores static localhost address object.\n+   */\n+  static InetAddress LOCALHOST;\n+  static\n+  {\n+    try\n+      {\n+\tLOCALHOST = getByAddress(\"localhost\", new byte[] {127, 0, 0, 1});\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tthrow new RuntimeException(\"should never happen\", e);\n+      }\n+  }    \n \n   /**\n    * The Serialized Form specifies that an int 'address' is saved/restored.\n@@ -105,184 +126,292 @@ public class InetAddress implements Serializable\n   String hostName;\n \n   /**\n-   * The field 'family' seems to be the AF_ value.\n-   * FIXME: Much of the code in the other java.net classes does not make\n-   * use of this family field.  A better implementation would be to make\n-   * use of getaddrinfo() and have other methods just check the family\n-   * field rather than examining the length of the address each time.\n+   * Needed for serialization.\n    */\n-  int family;\n+  private int family;\n \n   /**\n-   * Initializes this object's addr instance variable from the passed in\n-   * byte array.  Note that this constructor is protected and is called\n-   * only by static methods in this class.\n+   * Constructor.  Prior to the introduction of IPv6 support in 1.4,\n+   * methods such as InetAddress.getByName() would return InetAddress\n+   * objects.  From 1.4 such methods returned either Inet4Address or\n+   * Inet6Address objects, but for compatibility Inet4Address objects\n+   * are serialized as InetAddresses.  As such, there are only two\n+   * places where it is appropriate to invoke this constructor: within\n+   * subclasses constructors and within Inet4Address.writeReplace().\n    *\n    * @param ipaddr The IP number of this address as an array of bytes\n    * @param hostname The hostname of this IP address.\n+   * @param family The address family of this IP address.\n    */\n-  InetAddress(byte[] ipaddr, String hostname)\n+  InetAddress(byte[] ipaddr, String hostname, int family)\n   {\n     addr = (null == ipaddr) ? null : (byte[]) ipaddr.clone();\n     hostName = hostname;\n-    \n-    if (ipaddr != null)\n-      family = getFamily(ipaddr);\n+    this.family = family;\n   }\n \n   /**\n    * Returns true if this address is a multicast address, false otherwise.\n    * An address is multicast if the high four bits are \"1110\".  These are\n    * also known as \"Class D\" addresses.\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @return true if mulitcast, false if not\n    *\n    * @since 1.1\n    */\n   public boolean isMulticastAddress()\n   {\n-    // Mask against high order bits of 1110\n-    if (addr.length == 4)\n-      return (addr[0] & 0xf0) == 0xe0;\n-\n-    // Mask against high order bits of 11111111\n-    if (addr.length == 16)\n-      return addr [0] == (byte) 0xFF;\n-    \n-    return false;\n+    // This method is masked on Posix systems, where all InetAddress\n+    // objects are created using InetAddress.getByAddress() which \n+    // returns either Inet4Address or Inet6Address objects.  Certain\n+    // native methods on Win32 use \"new InetAddress\" in which case\n+    // this method will be visible.\n+    try\n+      {\n+\treturn getByAddress(hostName, addr).isMulticastAddress();\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tthrow new RuntimeException(\"should never happen\", e);\n+      }\n   }\n \n   /**\n    * Utility routine to check if the InetAddress in a wildcard address\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isAnyLocalAddress()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    return equals(ANY_IF);\n+    // This is inefficient, but certain methods on Win32 create\n+    // InetAddress objects using \"new InetAddress\" rather than\n+    // \"InetAddress.getByAddress\" so we provide a method body.\n+    // This code is never executed on Posix systems.\n+    try\n+      {\n+\treturn getByAddress(hostName, addr).isAnyLocalAddress();\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tthrow new RuntimeException(\"should never happen\", e);\n+      }\n   }\n \n   /**\n    * Utility routine to check if the InetAddress is a loopback address\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isLoopbackAddress()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    return (addr[0] & 0xff) == 0x7f;\n+    // This method is masked on Posix systems, where all InetAddress\n+    // objects are created using InetAddress.getByAddress() which \n+    // returns either Inet4Address or Inet6Address objects.  Certain\n+    // native methods on Win32 use \"new InetAddress\" in which case\n+    // this method will be visible.\n+    try\n+      {\n+\treturn getByAddress(hostName, addr).isLoopbackAddress();\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tthrow new RuntimeException(\"should never happen\", e);\n+      }\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a link local address\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isLinkLocalAddress()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    // XXX: This seems to not exist with IPv4 addresses\n-    return false;\n+    // This method is masked on Posix systems, where all InetAddress\n+    // objects are created using InetAddress.getByAddress() which \n+    // returns either Inet4Address or Inet6Address objects.  Certain\n+    // native methods on Win32 use \"new InetAddress\" in which case\n+    // this method will be visible.\n+    try\n+      {\n+\treturn getByAddress(hostName, addr).isLinkLocalAddress();\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tthrow new RuntimeException(\"should never happen\", e);\n+      }\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a site local address\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isSiteLocalAddress()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-\n-    // 10.0.0.0/8\n-    if ((addr[0] & 0xff) == 0x0a)\n-      return true;\n-\n-    // 172.16.0.0/12\n-    if ((addr[0] & 0xff) == 0xac && (addr[1] & 0xf0) == 0x10)\n-      return true;\n-\n-    // 192.168.0.0/16\n-    if ((addr[0] & 0xff) == 0xc0 && (addr[1] & 0xff) == 0xa8)\n-      return true;\n-\n-    // XXX: Do we need to check more addresses here ?\n-    return false;\n+    // This method is masked on Posix systems, where all InetAddress\n+    // objects are created using InetAddress.getByAddress() which \n+    // returns either Inet4Address or Inet6Address objects.  Certain\n+    // native methods on Win32 use \"new InetAddress\" in which case\n+    // this method will be visible.\n+    try\n+      {\n+\treturn getByAddress(hostName, addr).isSiteLocalAddress();\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tthrow new RuntimeException(\"should never happen\", e);\n+      }\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a global multicast address\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isMCGlobal()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    // XXX: This seems to not exist with IPv4 addresses\n-    return false;\n+    // This method is masked on Posix systems, where all InetAddress\n+    // objects are created using InetAddress.getByAddress() which \n+    // returns either Inet4Address or Inet6Address objects.  Certain\n+    // native methods on Win32 use \"new InetAddress\" in which case\n+    // this method will be visible.\n+    try\n+      {\n+\treturn getByAddress(hostName, addr).isMCGlobal();\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tthrow new RuntimeException(\"should never happen\", e);\n+      }\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a node local multicast address.\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isMCNodeLocal()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    // XXX: This seems to not exist with IPv4 addresses\n-    return false;\n+    // This method is masked on Posix systems, where all InetAddress\n+    // objects are created using InetAddress.getByAddress() which \n+    // returns either Inet4Address or Inet6Address objects.  Certain\n+    // native methods on Win32 use \"new InetAddress\" in which case\n+    // this method will be visible.\n+    try\n+      {\n+\treturn getByAddress(hostName, addr).isMCNodeLocal();\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tthrow new RuntimeException(\"should never happen\", e);\n+      }\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a link local multicast address.\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isMCLinkLocal()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    if (! isMulticastAddress())\n-      return false;\n-\n-    return ((addr[0] & 0xff) == 0xe0\n-\t    && (addr[1] & 0xff)  == 0x00\n-\t    && (addr[2] & 0xff)  == 0x00);\n+    // This method is masked on Posix systems, where all InetAddress\n+    // objects are created using InetAddress.getByAddress() which \n+    // returns either Inet4Address or Inet6Address objects.  Certain\n+    // native methods on Win32 use \"new InetAddress\" in which case\n+    // this method will be visible.\n+    try\n+      {\n+\treturn getByAddress(hostName, addr).isMCLinkLocal();\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tthrow new RuntimeException(\"should never happen\", e);\n+      }\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a site local multicast address.\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isMCSiteLocal()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    // XXX: This seems to not exist with IPv4 addresses\n-    return false;\n+    // This method is masked on Posix systems, where all InetAddress\n+    // objects are created using InetAddress.getByAddress() which \n+    // returns either Inet4Address or Inet6Address objects.  Certain\n+    // native methods on Win32 use \"new InetAddress\" in which case\n+    // this method will be visible.\n+    try\n+      {\n+\treturn getByAddress(hostName, addr).isMCSiteLocal();\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tthrow new RuntimeException(\"should never happen\", e);\n+      }\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a organization local\n    * multicast address.\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isMCOrgLocal()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    // XXX: This seems to not exist with IPv4 addresses\n-    return false;\n+    // This method is masked on Posix systems, where all InetAddress\n+    // objects are created using InetAddress.getByAddress() which \n+    // returns either Inet4Address or Inet6Address objects.  Certain\n+    // native methods on Win32 use \"new InetAddress\" in which case\n+    // this method will be visible.\n+    try\n+      {\n+\treturn getByAddress(hostName, addr).isMCOrgLocal();\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tthrow new RuntimeException(\"should never happen\", e);\n+      }\n   }\n \n   /**\n@@ -293,45 +422,50 @@ public boolean isMCOrgLocal()\n    */\n   public String getHostName()\n   {\n-    if (hostName != null)\n-      return hostName;\n+    if (hostName == null)\n+      hostName = getCanonicalHostName();\n \n-    // Lookup hostname and set field.\n-    lookup (null, this, false);\n-    \n     return hostName;\n   }\n \n+  /**\n+   * Returns the canonical hostname represented by this InetAddress\n+   */\n+  String internalGetCanonicalHostName()\n+  {\n+    try\n+      {\n+\treturn ResolverCache.getHostByAddr(addr);\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\treturn getHostAddress();\n+      }\n+  }\n+\n   /**\n    * Returns the canonical hostname represented by this InetAddress\n    * \n    * @since 1.4\n    */\n   public String getCanonicalHostName()\n   {\n+    String hostname = internalGetCanonicalHostName();\n+\n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n       {\n         try\n \t  {\n-            sm.checkConnect(hostName, -1);\n+            sm.checkConnect(hostname, -1);\n \t  }\n \tcatch (SecurityException e)\n \t  {\n \t    return getHostAddress();\n \t  }\n       }\n \n-    // Try to find the FDQN now\n-    InetAddress address;\n-    byte[] ipaddr = getAddress();\n-\n-    if (ipaddr.length == 16)\n-      address = new Inet6Address(getAddress(), null);\n-    else\n-      address = new Inet4Address(getAddress(), null);\n-\n-    return address.getHostName();\n+    return hostname;\n   }\n \n   /**\n@@ -346,91 +480,32 @@ public byte[] getAddress()\n     return (byte[]) addr.clone();\n   }\n \n-  /* Helper function due to a CNI limitation.  */\n-  private static InetAddress[] allocArray (int count)\n-  {\n-    return new InetAddress [count];\n-  }\n-\n-  /* Helper function due to a CNI limitation.  */\n-  private static SecurityException checkConnect (String hostname)\n-  {\n-    SecurityManager s = System.getSecurityManager();\n-    \n-    if (s == null)\n-      return null;\n-    \n-    try\n-      {\n-\ts.checkConnect (hostname, -1);\n-\treturn null;\n-      }\n-    catch (SecurityException ex)\n-      {\n-\treturn ex;\n-      }\n-  }\n-\n   /**\n-   * Returns the IP address of this object as a String.  The address is in\n-   * the dotted octet notation, for example, \"127.0.0.1\".\n+   * Returns the IP address of this object as a String.\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @return The IP address of this object in String form\n    *\n    * @since 1.0.2\n    */\n   public String getHostAddress()\n   {\n-    StringBuffer sb = new StringBuffer(40);\n-\n-    int len = addr.length;\n-    int i = 0;\n-    \n-    if (len == 16)\n-      { // An IPv6 address.\n-\tfor ( ; ; i += 2)\n-\t  {\n-\t    if (i >= 16)\n-\t      return sb.toString();\n-\t    \n-\t    int x = ((addr [i] & 0xFF) << 8) | (addr [i + 1] & 0xFF);\n-\t    boolean empty = sb.length() == 0;\n-\t    \n-\t    if (empty)\n-\t      {\n-\t\tif (i == 10 && x == 0xFFFF)\n-\t\t  { // IPv4-mapped IPv6 address.\n-\t\t    sb.append (\":FFFF:\");\n-\t\t    break;  // Continue as IPv4 address;\n-\t\t  }\n-\t\telse if (i == 12)\n-\t\t  { // IPv4-compatible IPv6 address.\n-\t\t    sb.append (':');\n-\t\t    break;  // Continue as IPv4 address.\n-\t\t  }\n-\t\telse if (i > 0)\n-\t\t  sb.append (\"::\");\n-\t      }\n-\t    else\n-\t      sb.append (':');\n-\t    \n-\t    if (x != 0 || i >= 14)\n-\t      sb.append (Integer.toHexString (x).toUpperCase());\n-\t  }\n+    // This method is masked on Posix systems, where all InetAddress\n+    // objects are created using InetAddress.getByAddress() which \n+    // returns either Inet4Address or Inet6Address objects.  Certain\n+    // native methods on Win32 use \"new InetAddress\" in which case\n+    // this method will be visible.\n+    try\n+      {\n+\treturn getByAddress(hostName, addr).getHostAddress();\n       }\n-    \n-    for ( ; ; )\n+    catch (UnknownHostException e)\n       {\n-        sb.append(addr[i] & 0xff);\n-        i++;\n-\t\n-        if (i == len)\n-          break;\n-\t\n-        sb.append('.');\n+\tthrow new RuntimeException(\"should never happen\", e);\n       }\n-\n-    return sb.toString();\n   }\n \n   /**\n@@ -555,33 +630,32 @@ public static InetAddress getByAddress(String host, byte[] addr)\n   }\n \n   /**\n-   * If hostname is a valid numeric IP address, return the numeric address.\n-   * Otherwise, return null.\n-   *\n-   * @param hostname the name of the host\n-   */\n-  private static native byte[] aton(String hostname);\n-\n-  /**\n-   * Looks up all addresses of a given host.\n+   * Returns an InetAddress object representing the IP address of\n+   * the given literal IP address in dotted decimal format such as\n+   * \"127.0.0.1\".  This is used by SocketPermission.setHostPort()\n+   * to parse literal IP addresses without performing a DNS lookup.\n    *\n-   * @param hostname the host to lookup\n-   * @param ipaddr the IP address to lookup\n-   * @param all return all known addresses for one host\n+   * @param literal The literal IP address to create the InetAddress\n+   * object from\n    *\n-   * @return an array with all found addresses\n+   * @return The address of the host as an InetAddress object, or\n+   * null if the IP address is invalid.\n    */\n-  private static native InetAddress[] lookup (String hostname,\n-\t\t                              InetAddress ipaddr, boolean all);\n-\n-  /**\n-   * Returns tha family type of an IP address.\n-   *\n-   * @param addr the IP address\n-   *\n-   * @return the family\n-   */\n-  private static native int getFamily (byte[] ipaddr);\n+  static InetAddress getByLiteral(String literal)\n+  {\n+    byte[] address = VMInetAddress.aton(literal);\n+    if (address == null)\n+      return null;\n+    \n+    try\n+      {\n+\treturn getByAddress(address);\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tthrow new RuntimeException(\"should never happen\", e);\n+      }\n+  }\n \n   /**\n    * Returns an InetAddress object representing the IP address of the given\n@@ -604,25 +678,8 @@ private static native InetAddress[] lookup (String hostname,\n   public static InetAddress getByName(String hostname)\n     throws UnknownHostException\n   {\n-    // If null or the empty string is supplied, the loopback address\n-    // is returned.\n-    if (hostname == null || hostname.length() == 0)\n-      return loopback;\n-\n-    // Assume that the host string is an IP address\n-    byte[] address = aton(hostname);\n-    if (address != null)\n-      return getByAddress(address);\n-\n-    // Perform security check before resolving\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkConnect(hostname, -1);\n-\n-    // Try to resolve the host by DNS\n-    InetAddress result = new InetAddress(null, null);\n-    lookup (hostname, result, false);\n-    return result;\n+    InetAddress[] addresses = getAllByName(hostname);\n+    return addresses[0];\n   }\n \n   /**\n@@ -648,31 +705,29 @@ public static InetAddress[] getAllByName(String hostname)\n     // If null or the empty string is supplied, the loopback address\n     // is returned.\n     if (hostname == null || hostname.length() == 0)\n-      return new InetAddress[] {loopback};\n+      return new InetAddress[] {LOCALHOST};\n \n     // Check if hostname is an IP address\n-    byte[] address = aton (hostname);\n+    InetAddress address = getByLiteral(hostname);\n     if (address != null)\n-      return new InetAddress[] {getByAddress(address)};\n+      return new InetAddress[] {address};\n \n     // Perform security check before resolving\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkConnect(hostname, -1);\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkConnect(hostname, -1);\n \n-    // Try to resolve the hostname by DNS\n-    return lookup (hostname, null, true);\n-  }\n+    // Resolve the hostname\n+    byte[][] iplist = ResolverCache.getHostByName(hostname);\n+    if (iplist.length == 0)\n+      throw new UnknownHostException(hostname);\n \n-  /**\n-   * This native method looks up the hostname of the local machine\n-   * we are on.  If the actual hostname cannot be determined, then the\n-   * value \"localhost\" will be used.  This native method wrappers the\n-   * \"gethostname\" function.\n-   *\n-   * @return The local hostname.\n-   */\n-  private static native String getLocalHostname();\n+    InetAddress[] addresses = new InetAddress[iplist.length];\n+    for (int i = 0; i < iplist.length; i++)\n+      addresses[i] = getByAddress(hostname, iplist[i]);\n+\n+    return addresses;\n+  }\n \n   /**\n    * Returns an InetAddress object representing the address of the current\n@@ -685,62 +740,24 @@ public static InetAddress[] getAllByName(String hostname)\n    */\n   public static InetAddress getLocalHost() throws UnknownHostException\n   {\n-    SecurityManager s = System.getSecurityManager();\n-    \n-    // Experimentation shows that JDK1.2 does cache the result.\n-    // However, if there is a security manager, and the cached result\n-    // is other than \"localhost\", we need to check again.\n-    if (localhost == null\n-\t|| (s != null && ! localhost.isLoopbackAddress()))\n-      getLocalHost (s);\n-    \n-    return localhost;\n-  }\n-\n-  private static synchronized void getLocalHost (SecurityManager s)\n-    throws UnknownHostException\n-  {\n-    // Check the localhost cache again, now that we've synchronized.\n-    if (s == null && localhost != null)\n-      return;\n-    \n-    String hostname = getLocalHostname();\n-    \n-    if (hostname == null || hostname.length() == 0)\n-      throw new UnknownHostException();\n-\n+    String hostname = VMInetAddress.getLocalHostname();\n     try\n       {\n-\t// \"The Java Class Libraries\" suggests that if the security\n-\t// manager disallows getting the local host name, then\n-\t// we use the loopback host.\n-\t// However, the JDK 1.2 API claims to throw SecurityException,\n-\t// which seems to suggest SecurityException is *not* caught.\n-\t// In this case, experimentation shows that former is correct.\n-\tif (s != null)\n-\t  {\n-\t    // This is wrong, if the name returned from getLocalHostname()\n-\t    // is not a fully qualified name.  FIXME.\n-\t    s.checkConnect (hostname, -1);\n-\t  }\n-\n-\tlocalhost = new InetAddress (null, null);\n-\tlookup (hostname, localhost, false);\n+\treturn getByName(hostname);\n       }\n-    catch (Exception ex)\n+    catch (SecurityException e)\n       {\n-\tUnknownHostException failure = new UnknownHostException(hostname);\n-\tfailure.initCause(ex);\n-\tthrow failure;\n+\treturn LOCALHOST;\n       }\n   }\n \n   /**\n-   * Needed for serialization\n+   * Inet4Address objects are serialized as InetAddress objects.\n+   * This deserializes them back into Inet4Address objects.\n    */\n-  private void readResolve() throws ObjectStreamException\n+  private Object readResolve() throws ObjectStreamException\n   {\n-    // FIXME: implement this\n+    return new Inet4Address(addr, hostName);\n   }\n \n   private void readObject(ObjectInputStream ois)\n@@ -752,13 +769,6 @@ private void readObject(ObjectInputStream ois)\n \n     for (int i = 2; i >= 0; --i)\n       addr[i] = (byte) (address >>= 8);\n-\n-    // Ignore family from serialized data.  Since the saved address is 32 bits\n-    // the deserialized object will have an IPv4 address i.e. AF_INET family.\n-    // FIXME: An alternative is to call the aton method on the deserialized\n-    // hostname to get a new address.  The Serialized Form doc is silent\n-    // on how these fields are used.\n-    family = getFamily (addr);\n   }\n \n   private void writeObject(ObjectOutputStream oos) throws IOException\n@@ -769,8 +779,35 @@ private void writeObject(ObjectOutputStream oos) throws IOException\n     int i = len - 4;\n \n     for (; i < len; i++)\n-      address = address << 8 | (((int) addr[i]) & 0xFF);\n+      address = address << 8 | (addr[i] & 0xff);\n \n     oos.defaultWriteObject();\n   }\n+\n+  // The native methods remain here for now;\n+  // methods in VMInetAddress map onto them.\n+  static native byte[] aton(String hostname);\n+  static native InetAddress[] lookup (String hostname,\n+\t\t\t\t      InetAddress ipaddr, boolean all);\n+  static native int getFamily (byte[] ipaddr);\n+  static native String getLocalHostname();\n+\n+  // Some soon-to-be-removed native code synchronizes on this.\n+  static InetAddress loopbackAddress = LOCALHOST;\n+  \n+  // Some soon-to-be-removed code uses this old and broken method.\n+  InetAddress(byte[] ipaddr, String hostname)\n+  {\n+    addr = (null == ipaddr) ? null : (byte[]) ipaddr.clone();\n+    hostName = hostname;\n+\n+    if (ipaddr != null)\n+      family = getFamily(ipaddr);\n+  }\n+\n+  // Some soon-to-be-removed native code uses this old method.\n+  private static InetAddress[] allocArray (int count)\n+  {\n+    return new InetAddress [count];\n+  }  \n }"}, {"sha": "b10cf252874f294850b8c0327c4e1f25cce745a7", "filename": "libjava/java/net/VMInetAddress.java", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac8697859d550b39baf967900578ee47259c419/libjava%2Fjava%2Fnet%2FVMInetAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac8697859d550b39baf967900578ee47259c419/libjava%2Fjava%2Fnet%2FVMInetAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FVMInetAddress.java?ref=aac8697859d550b39baf967900578ee47259c419", "patch": "@@ -0,0 +1,117 @@\n+/* VMInetAddress.java -- Class to model an Internet address\n+   Copyright (C) 2005  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.net;\n+\n+import gnu.classpath.Configuration;\n+\n+import java.io.Serializable;\n+\n+class VMInetAddress implements Serializable\n+{\n+  static\n+  {\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      System.loadLibrary(\"javanet\");\n+  }\n+\n+  /**\n+   * This method looks up the hostname of the local machine\n+   * we are on.  If the actual hostname cannot be determined, then the\n+   * value \"localhost\" will be used.  This native method wrappers the\n+   * \"gethostname\" function.\n+   *\n+   * @return The local hostname.\n+   */\n+  public static String getLocalHostname()\n+  {\n+    return InetAddress.getLocalHostname();\n+  }\n+\n+  /**\n+   * Returns the value of the special address INADDR_ANY\n+   */\n+  public static byte[] lookupInaddrAny() throws UnknownHostException\n+  {\n+    return new byte[] {0, 0, 0, 0};\n+  }\n+\n+  /**\n+   * This method returns the hostname for a given IP address.  It will\n+   * throw an UnknownHostException if the hostname cannot be determined.\n+   *\n+   * @param ip The IP address as a byte array\n+   *\n+   * @return The hostname\n+   *\n+   * @exception UnknownHostException If the reverse lookup fails\n+   */\n+  public static String getHostByAddr(byte[] ip) throws UnknownHostException\n+  {\n+    InetAddress addr = InetAddress.getByAddress(ip);\n+    InetAddress.lookup(null, addr, false);\n+    return addr.getHostName();\n+  }\n+\n+  /**\n+   * Returns a list of all IP addresses for a given hostname.  Will throw\n+   * an UnknownHostException if the hostname cannot be resolved.\n+   */\n+  public static byte[][] getHostByName(String hostname)\n+    throws UnknownHostException\n+  {\n+    InetAddress[] iaddrs = InetAddress.lookup(hostname, null, true);\n+    byte[][] addrs = new byte[iaddrs.length][];\n+    for (int i = 0; i < iaddrs.length; i++)\n+      addrs[i] = iaddrs[i].getAddress();\n+    return addrs;\n+  }\n+\n+  /**\n+   * Return the IP address represented by a literal address.\n+   * Will return null if the literal address is not valid.\n+   *\n+   * @param address the name of the host\n+   *\n+   * @return The IP address as a byte array\n+   */\n+  public static byte[] aton(String address)\n+  {\n+    return InetAddress.aton(address);\n+  }\n+}"}, {"sha": "bfb11d21ce764e0cf3f64f83d345137fa394bd30", "filename": "libjava/java/net/natVMNetworkInterfacePosix.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac8697859d550b39baf967900578ee47259c419/libjava%2Fjava%2Fnet%2FnatVMNetworkInterfacePosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac8697859d550b39baf967900578ee47259c419/libjava%2Fjava%2Fnet%2FnatVMNetworkInterfacePosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatVMNetworkInterfacePosix.cc?ref=aac8697859d550b39baf967900578ee47259c419", "patch": "@@ -40,7 +40,7 @@ details.  */\n \n #include <gcj/cni.h>\n #include <jvm.h>\n-#include <java/net/Inet4Address.h>\n+#include <java/net/InetAddress.h>\n #include <java/net/NetworkInterface.h>\n #include <java/net/SocketException.h>\n #include <java/net/VMNetworkInterface.h>\n@@ -148,8 +148,7 @@ java::net::VMNetworkInterface::getInterfaces ()\n       jbyteArray baddr = JvNewByteArray (len);\n       memcpy (elements (baddr), &(sa.sin_addr), len);\n       jstring if_name = JvNewStringLatin1 (if_record->ifr_name);\n-      Inet4Address* address =\n-        new java::net::Inet4Address (baddr, JvNewStringLatin1 (\"\"));\n+      InetAddress* address = java::net::InetAddress::getByAddress (baddr);\n       ht->add (new NetworkInterface (if_name, address));\n       if_record++;\n     }"}, {"sha": "d7b18f41e397231f0982f893bf8b1cc0e9639204", "filename": "libjava/sources.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac8697859d550b39baf967900578ee47259c419/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac8697859d550b39baf967900578ee47259c419/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=aac8697859d550b39baf967900578ee47259c419", "patch": "@@ -5223,6 +5223,7 @@ classpath/java/net/NoRouteToHostException.java \\\n classpath/java/net/PasswordAuthentication.java \\\n classpath/java/net/PortUnreachableException.java \\\n classpath/java/net/ProtocolException.java \\\n+classpath/java/net/ResolverCache.java \\\n classpath/java/net/ServerSocket.java \\\n classpath/java/net/Socket.java \\\n classpath/java/net/SocketAddress.java \\\n@@ -5243,6 +5244,7 @@ classpath/java/net/URLStreamHandler.java \\\n classpath/java/net/URLStreamHandlerFactory.java \\\n classpath/java/net/UnknownHostException.java \\\n classpath/java/net/UnknownServiceException.java \\\n+java/net/VMInetAddress.java \\\n java/net/VMNetworkInterface.java \\\n java/net/VMURLConnection.java\n "}]}