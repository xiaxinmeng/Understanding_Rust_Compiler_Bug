{"sha": "d4398a43f599672b414768d1316fda2e8c8ced98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQzOThhNDNmNTk5NjcyYjQxNDc2OGQxMzE2ZmRhMmU4YzhjZWQ5OA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-07-22T13:47:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-07-22T13:47:32Z"}, "message": "re PR lto/42451 ('warning: type of \"array\" does not match original declaration' with -flto/-fwhopr)\n\n2010-07-22  Richard Guenther  <rguenther@suse.de>\n\n\tPR lto/42451\n\t* gimple.c (gtc_next_dfs_num): New global.\n\t(struct sccs): Make value a union, add integer same_p member.\n\t(gtc_visit): New function.\n\t(gimple_types_compatible_p_1): New function, split out from ...\n\t(gimple_types_compatible_p): ... here.  Start a DFS walk here.\n\t(iterative_hash_gimple_type): Adjust for sccs change.\n\n\t* gcc.dg/lto/20100720-3_0.c: New testcase.\n\t* gcc.dg/lto/20100720-3_1.c: Likewise.\n\nFrom-SVN: r162415", "tree": {"sha": "a97a4a1d4527a63c29ed20ed56c74974b3689a8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a97a4a1d4527a63c29ed20ed56c74974b3689a8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4398a43f599672b414768d1316fda2e8c8ced98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4398a43f599672b414768d1316fda2e8c8ced98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4398a43f599672b414768d1316fda2e8c8ced98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4398a43f599672b414768d1316fda2e8c8ced98/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3cf8ccdf3b979989ce17ffe48a2c588606cfc5d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf8ccdf3b979989ce17ffe48a2c588606cfc5d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cf8ccdf3b979989ce17ffe48a2c588606cfc5d1"}], "stats": {"total": 378, "additions": 312, "deletions": 66}, "files": [{"sha": "0f79c0223c1534ec8b781f21b4c0002b60ed0b56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4398a43f599672b414768d1316fda2e8c8ced98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4398a43f599672b414768d1316fda2e8c8ced98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4398a43f599672b414768d1316fda2e8c8ced98", "patch": "@@ -1,3 +1,13 @@\n+2010-07-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/42451\n+\t* gimple.c (gtc_next_dfs_num): New global.\n+\t(struct sccs): Make value a union, add integer same_p member.\n+\t(gtc_visit): New function.\n+\t(gimple_types_compatible_p_1): New function, split out from ...\n+\t(gimple_types_compatible_p): ... here.  Start a DFS walk here.\n+\t(iterative_hash_gimple_type): Adjust for sccs change.\n+\n 2010-07-22  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/44891"}, {"sha": "8453be0c002d15b31845fdd75681f8cd36991234", "filename": "gcc/gimple.c", "status": "modified", "additions": 255, "deletions": 66, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4398a43f599672b414768d1316fda2e8c8ced98/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4398a43f599672b414768d1316fda2e8c8ced98/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=d4398a43f599672b414768d1316fda2e8c8ced98", "patch": "@@ -3174,6 +3174,9 @@ struct type_pair_d\n };\n typedef struct type_pair_d *type_pair_t;\n \n+DEF_VEC_P(type_pair_t);\n+DEF_VEC_ALLOC_P(type_pair_t,heap);\n+\n /* Return a hash value for the type pair pointed-to by P.  */\n \n static hashval_t\n@@ -3231,6 +3234,24 @@ lookup_type_pair (tree t1, tree t2, htab_t *visited_p, struct obstack *ob_p)\n   return p;\n }\n \n+/* Per pointer state for the SCC finding.  The on_sccstack flag\n+   is not strictly required, it is true when there is no hash value\n+   recorded for the type and false otherwise.  But querying that\n+   is slower.  */\n+\n+struct sccs\n+{\n+  unsigned int dfsnum;\n+  unsigned int low;\n+  bool on_sccstack;\n+  union {\n+    hashval_t hash;\n+    int same_p;\n+  } u;\n+};\n+\n+static unsigned int next_dfs_num;\n+static unsigned int gtc_next_dfs_num;\n \n /* Return true if T1 and T2 have the same name.  If FOR_COMPLETION_P is\n    true then if any type has no name return false, otherwise return\n@@ -3344,39 +3365,52 @@ gimple_compatible_complete_and_incomplete_subtype_p (tree t1, tree t2)\n   return false;\n }\n \n-/* Return 1 iff T1 and T2 are structurally identical.\n-   Otherwise, return 0.  */\n+static bool\n+gimple_types_compatible_p_1 (tree, tree, bool, VEC(type_pair_t, heap) **,\n+\t\t\t     struct pointer_map_t *, struct obstack *);\n \n-bool\n-gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n+/* DFS visit the edge from the callers type pair with state *STATE to\n+   the pair T1, T2 while operating in FOR_MERGING_P mode.\n+   Update the merging status if it is not part of the SCC containing the\n+   callers pair and return it.\n+   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n+\n+static bool\n+gtc_visit (tree t1, tree t2, bool for_merging_p,\n+\t   struct sccs *state,\n+\t   VEC(type_pair_t, heap) **sccstack,\n+\t   struct pointer_map_t *sccstate,\n+\t   struct obstack *sccstate_obstack)\n {\n-  type_pair_t p = NULL;\n+  struct sccs *cstate = NULL;\n+  type_pair_t p;\n+  void **slot;\n \n   /* Check first for the obvious case of pointer identity.  */\n   if (t1 == t2)\n-    return 1;\n+    return true;\n \n   /* Check that we have two types to compare.  */\n   if (t1 == NULL_TREE || t2 == NULL_TREE)\n-    return 0;\n+    return false;\n \n   /* If the types have been previously registered and found equal\n      they still are.  */\n   if (TYPE_CANONICAL (t1)\n       && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2))\n-    return 1;\n+    return true;\n \n   /* Can't be the same type if the types don't have the same code.  */\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n-    return 0;\n+    return false;\n \n   /* Can't be the same type if they have different CV qualifiers.  */\n   if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n-    return 0;\n+    return false;\n \n   /* Void types are always the same.  */\n   if (TREE_CODE (t1) == VOID_TYPE)\n-    return 1;\n+    return true;\n \n   /* Do some simple checks before doing three hashtable queries.  */\n   if (INTEGRAL_TYPE_P (t1)\n@@ -3392,23 +3426,17 @@ gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n \t  || TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n \t  || TYPE_MODE (t1) != TYPE_MODE (t2)\n \t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n-\treturn 0;\n+\treturn false;\n \n       if (TREE_CODE (t1) == INTEGER_TYPE\n \t  && (TYPE_IS_SIZETYPE (t1) != TYPE_IS_SIZETYPE (t2)\n \t      || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)))\n-\treturn 0;\n+\treturn false;\n \n       /* That's all we need to check for float and fixed-point types.  */\n       if (SCALAR_FLOAT_TYPE_P (t1)\n \t  || FIXED_POINT_TYPE_P (t1))\n-\treturn 1;\n-\n-      /* Perform cheap tail-recursion for vector and complex types.  */\n-      if (TREE_CODE (t1) == VECTOR_TYPE\n-\t  || TREE_CODE (t1) == COMPLEX_TYPE)\n-\treturn gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t\t  for_merging_p);\n+\treturn true;\n \n       /* For integral types fall thru to more complex checks.  */\n     }\n@@ -3418,17 +3446,16 @@ gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n       /* Can't be the same type if they have different alignment or mode.  */\n       if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n \t  || TYPE_MODE (t1) != TYPE_MODE (t2))\n-\treturn 0;\n+\treturn false;\n     }\n \n   /* If the hash values of t1 and t2 are different the types can't\n      possibly be the same.  This helps keeping the type-pair hashtable\n      small, only tracking comparisons for hash collisions.  */\n   if (gimple_type_hash (t1) != gimple_type_hash (t2))\n-    return 0;\n+    return false;\n \n-  /* If we've visited this type pair before (in the case of aggregates\n-     with self-referential types), and we made a decision, return it.  */\n+  /* Allocate a new cache entry for this comparison.  */\n   p = lookup_type_pair (t1, t2,\n \t\t\tfor_merging_p ? &gtc_visited : &gtc_visited2,\n \t\t\tfor_merging_p ? &gtc_ob : &gtc_ob2);\n@@ -3438,17 +3465,60 @@ gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n \t same, return the cached result.  */\n       return p->same_p == 1;\n     }\n-  else if (p->same_p == -1)\n+\n+  gcc_assert (p->same_p == -2);\n+\n+  if ((slot = pointer_map_contains (sccstate, p)) != NULL)\n+    cstate = (struct sccs *)*slot;\n+  if (!cstate)\n     {\n-      /* We are currently comparing this pair of types, assume\n-\t that they are the same and let the caller decide.  */\n-      return 1;\n+      bool res;\n+      /* Not yet visited.  DFS recurse.  */\n+      res = gimple_types_compatible_p_1 (t1, t2, for_merging_p,\n+\t\t\t\t\t sccstack, sccstate, sccstate_obstack);\n+      if (!cstate)\n+\tcstate = (struct sccs *)* pointer_map_contains (sccstate, p);\n+      state->low = MIN (state->low, cstate->low);\n+      /* If the type is no longer on the SCC stack and thus is not part\n+\t of the parents SCC mix in its hash value.  Otherwise we will\n+\t ignore the type for hashing purposes and return the unaltered\n+\t hash value.  */\n+      if (!cstate->on_sccstack)\n+\treturn res;\n     }\n+  if (cstate->dfsnum < state->dfsnum\n+      && cstate->on_sccstack)\n+    state->low = MIN (cstate->dfsnum, state->low);\n+\n+  /* We are part of our parents SCC, skip this entry and return true.  */\n+  return true;\n+}\n+\n+/* Worker for gimple_types_compatible.\n+   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n+\n+static bool\n+gimple_types_compatible_p_1 (tree t1, tree t2, bool for_merging_p,\n+\t\t\t     VEC(type_pair_t, heap) **sccstack,\n+\t\t\t     struct pointer_map_t *sccstate,\n+\t\t\t     struct obstack *sccstate_obstack)\n+{\n+  type_pair_t p;\n+  struct sccs *state;\n \n+  /* Allocate a new cache entry for this comparison.  */\n+  p = lookup_type_pair (t1, t2,\n+\t\t\tfor_merging_p ? &gtc_visited : &gtc_visited2,\n+\t\t\tfor_merging_p ? &gtc_ob : &gtc_ob2);\n   gcc_assert (p->same_p == -2);\n \n-  /* Mark the (T1, T2) comparison in progress.  */\n-  p->same_p = -1;\n+  state = XOBNEW (sccstate_obstack, struct sccs);\n+  *pointer_map_insert (sccstate, p) = state;\n+\n+  VEC_safe_push (type_pair_t, heap, *sccstack, p);\n+  state->dfsnum = gtc_next_dfs_num++;\n+  state->low = state->dfsnum;\n+  state->on_sccstack = true;\n \n   /* If their attributes are not the same they can't be the same type.  */\n   if (!attribute_list_equal (TYPE_ATTRIBUTES (t1), TYPE_ATTRIBUTES (t2)))\n@@ -3457,11 +3527,18 @@ gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n   /* Do type-specific comparisons.  */\n   switch (TREE_CODE (t1))\n     {\n+    case VECTOR_TYPE:\n+    case COMPLEX_TYPE:\n+      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), for_merging_p,\n+\t\t      state, sccstack, sccstate, sccstate_obstack))\n+\tgoto different_types;\n+      goto same_types;\n+\n     case ARRAY_TYPE:\n       /* Array types are the same if the element types are the same and\n \t the number of elements are the same.  */\n-      if (!gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t      for_merging_p)\n+      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), for_merging_p,\n+\t\t      state, sccstack, sccstate, sccstate_obstack)\n \t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)\n \t  || TYPE_NONALIASED_COMPONENT (t1) != TYPE_NONALIASED_COMPONENT (t2))\n \tgoto different_types;\n@@ -3509,8 +3586,9 @@ gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n \n     case METHOD_TYPE:\n       /* Method types should belong to the same class.  */\n-      if (!gimple_types_compatible_p (TYPE_METHOD_BASETYPE (t1),\n-\t\t\t\t      TYPE_METHOD_BASETYPE (t2), for_merging_p))\n+      if (!gtc_visit (TYPE_METHOD_BASETYPE (t1), TYPE_METHOD_BASETYPE (t2),\n+\t\t      for_merging_p,\n+\t\t      state, sccstack, sccstate, sccstate_obstack))\n \tgoto different_types;\n \n       /* Fallthru  */\n@@ -3521,8 +3599,8 @@ gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n       if ((for_merging_p\n \t   || !gimple_compatible_complete_and_incomplete_subtype_p\n \t         (TREE_TYPE (t1), TREE_TYPE (t2)))\n-\t  && !gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t\t for_merging_p))\n+\t  && !gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), for_merging_p,\n+\t\t\t state, sccstack, sccstate, sccstate_obstack))\n \tgoto different_types;\n \n       if (!targetm.comp_type_attributes (t1, t2))\n@@ -3541,9 +3619,9 @@ gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n \t      if ((for_merging_p\n \t\t   || !gimple_compatible_complete_and_incomplete_subtype_p\n \t\t         (TREE_VALUE (parms1), TREE_VALUE (parms2)))\n-\t\t  && !gimple_types_compatible_p (TREE_VALUE (parms1),\n-\t\t\t\t\t\t TREE_VALUE (parms2),\n-\t\t\t\t\t\t for_merging_p))\n+\t\t  && !gtc_visit (TREE_VALUE (parms1), TREE_VALUE (parms2),\n+\t\t\t\t for_merging_p,\n+\t\t\t\t state, sccstack, sccstate, sccstate_obstack))\n \t\tgoto different_types;\n \t    }\n \n@@ -3555,11 +3633,11 @@ gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n \n     case OFFSET_TYPE:\n       {\n-\tif (!gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t\tfor_merging_p)\n-\t    || !gimple_types_compatible_p (TYPE_OFFSET_BASETYPE (t1),\n-\t\t\t\t\t   TYPE_OFFSET_BASETYPE (t2),\n-\t\t\t\t\t   for_merging_p))\n+\tif (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), for_merging_p,\n+\t\t\tstate, sccstack, sccstate, sccstate_obstack)\n+\t    || !gtc_visit (TYPE_OFFSET_BASETYPE (t1),\n+\t\t\t   TYPE_OFFSET_BASETYPE (t2), for_merging_p,\n+\t\t\t   state, sccstack, sccstate, sccstate_obstack))\n \t  goto different_types;\n \n \tgoto same_types;\n@@ -3582,8 +3660,8 @@ gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n \n \t/* Otherwise, pointer and reference types are the same if the\n \t   pointed-to types are the same.  */\n-\tif (gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t       for_merging_p))\n+\tif (gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), for_merging_p,\n+\t\t       state, sccstack, sccstate, sccstate_obstack))\n \t  goto same_types;\n \n \tgoto different_types;\n@@ -3678,8 +3756,8 @@ gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n \t    if (DECL_NAME (f1) != DECL_NAME (f2)\n \t\t|| DECL_NONADDRESSABLE_P (f1) != DECL_NONADDRESSABLE_P (f2)\n \t\t|| !gimple_compare_field_offset (f1, f2)\n-\t\t|| !gimple_types_compatible_p (TREE_TYPE (f1),\n-\t\t\t\t\t       TREE_TYPE (f2), for_merging_p))\n+\t\t|| !gtc_visit (TREE_TYPE (f1), TREE_TYPE (f2), for_merging_p,\n+\t\t\t       state, sccstack, sccstate, sccstate_obstack))\n \t      goto different_types;\n \t  }\n \n@@ -3697,32 +3775,143 @@ gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n \n   /* Common exit path for types that are not compatible.  */\n different_types:\n-  p->same_p = 0;\n-  return 0;\n+  state->u.same_p = 0;\n+  goto pop;\n \n   /* Common exit path for types that are compatible.  */\n same_types:\n-  p->same_p = 1;\n-  return 1;\n-}\n+  state->u.same_p = 1;\n+  goto pop;\n \n+pop:\n+  if (state->low == state->dfsnum)\n+    {\n+      type_pair_t x;\n \n+      /* Pop off the SCC and set its cache values.  */\n+      do\n+\t{\n+\t  struct sccs *cstate;\n+\t  x = VEC_pop (type_pair_t, *sccstack);\n+\t  cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n+\t  cstate->on_sccstack = false;\n+\t  x->same_p = cstate->u.same_p;\n+\t}\n+      while (x != p);\n+    }\n \n+  return state->u.same_p;\n+}\n \n-/* Per pointer state for the SCC finding.  The on_sccstack flag\n-   is not strictly required, it is true when there is no hash value\n-   recorded for the type and false otherwise.  But querying that\n-   is slower.  */\n+/* Return true iff T1 and T2 are structurally identical.  When\n+   FOR_MERGING_P is true the an incomplete type and a complete type\n+   are considered different, otherwise they are considered compatible.  */\n \n-struct sccs\n+bool\n+gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n {\n-  unsigned int dfsnum;\n-  unsigned int low;\n-  bool on_sccstack;\n-  hashval_t hash;\n-};\n+  VEC(type_pair_t, heap) *sccstack = NULL;\n+  struct pointer_map_t *sccstate;\n+  struct obstack sccstate_obstack;\n+  type_pair_t p = NULL;\n+  bool res;\n+\n+  /* Before starting to set up the SCC machinery handle simple cases.  */\n+\n+  /* Check first for the obvious case of pointer identity.  */\n+  if (t1 == t2)\n+    return true;\n+\n+  /* Check that we have two types to compare.  */\n+  if (t1 == NULL_TREE || t2 == NULL_TREE)\n+    return false;\n+\n+  /* If the types have been previously registered and found equal\n+     they still are.  */\n+  if (TYPE_CANONICAL (t1)\n+      && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2))\n+    return true;\n+\n+  /* Can't be the same type if the types don't have the same code.  */\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return false;\n+\n+  /* Can't be the same type if they have different CV qualifiers.  */\n+  if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n+    return false;\n+\n+  /* Void types are always the same.  */\n+  if (TREE_CODE (t1) == VOID_TYPE)\n+    return true;\n+\n+  /* Do some simple checks before doing three hashtable queries.  */\n+  if (INTEGRAL_TYPE_P (t1)\n+      || SCALAR_FLOAT_TYPE_P (t1)\n+      || FIXED_POINT_TYPE_P (t1)\n+      || TREE_CODE (t1) == VECTOR_TYPE\n+      || TREE_CODE (t1) == COMPLEX_TYPE\n+      || TREE_CODE (t1) == OFFSET_TYPE)\n+    {\n+      /* Can't be the same type if they have different alignment,\n+\t sign, precision or mode.  */\n+      if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n+\t  || TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n+\t  || TYPE_MODE (t1) != TYPE_MODE (t2)\n+\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n+\treturn false;\n+\n+      if (TREE_CODE (t1) == INTEGER_TYPE\n+\t  && (TYPE_IS_SIZETYPE (t1) != TYPE_IS_SIZETYPE (t2)\n+\t      || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)))\n+\treturn false;\n+\n+      /* That's all we need to check for float and fixed-point types.  */\n+      if (SCALAR_FLOAT_TYPE_P (t1)\n+\t  || FIXED_POINT_TYPE_P (t1))\n+\treturn true;\n+\n+      /* For integral types fall thru to more complex checks.  */\n+    }\n+\n+  else if (AGGREGATE_TYPE_P (t1) || POINTER_TYPE_P (t1))\n+    {\n+      /* Can't be the same type if they have different alignment or mode.  */\n+      if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n+\t  || TYPE_MODE (t1) != TYPE_MODE (t2))\n+\treturn false;\n+    }\n+\n+  /* If the hash values of t1 and t2 are different the types can't\n+     possibly be the same.  This helps keeping the type-pair hashtable\n+     small, only tracking comparisons for hash collisions.  */\n+  if (gimple_type_hash (t1) != gimple_type_hash (t2))\n+    return false;\n+\n+  /* If we've visited this type pair before (in the case of aggregates\n+     with self-referential types), and we made a decision, return it.  */\n+  p = lookup_type_pair (t1, t2,\n+\t\t\tfor_merging_p ? &gtc_visited : &gtc_visited2,\n+\t\t\tfor_merging_p ? &gtc_ob : &gtc_ob2);\n+  if (p->same_p == 0 || p->same_p == 1)\n+    {\n+      /* We have already decided whether T1 and T2 are the\n+\t same, return the cached result.  */\n+      return p->same_p == 1;\n+    }\n+\n+  /* Now set up the SCC machinery for the comparison.  */\n+  gtc_next_dfs_num = 1;\n+  sccstate = pointer_map_create ();\n+  gcc_obstack_init (&sccstate_obstack);\n+  res = gimple_types_compatible_p_1 (t1, t2, for_merging_p,\n+\t\t\t\t     &sccstack, sccstate, &sccstate_obstack);\n+  VEC_free (type_pair_t, heap, sccstack);\n+  pointer_map_destroy (sccstate);\n+  obstack_free (&sccstate_obstack, NULL);\n+\n+  return res;\n+}\n \n-static unsigned int next_dfs_num;\n \n static hashval_t\n iterative_hash_gimple_type (tree, hashval_t, VEC(tree, heap) **,\n@@ -3950,7 +4139,7 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n     }\n \n   /* Record hash for us.  */\n-  state->hash = v;\n+  state->u.hash = v;\n \n   /* See if we found an SCC.  */\n   if (state->low == state->dfsnum)\n@@ -3966,7 +4155,7 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n \t  cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n \t  cstate->on_sccstack = false;\n \t  slot = pointer_map_insert (type_hash_cache, x);\n-\t  *slot = (void *) (size_t) cstate->hash;\n+\t  *slot = (void *) (size_t) cstate->u.hash;\n \t}\n       while (x != type);\n     }"}, {"sha": "2fb2a1ea19f807bfb7a68cfd1cd4025d7b03a555", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4398a43f599672b414768d1316fda2e8c8ced98/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4398a43f599672b414768d1316fda2e8c8ced98/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d4398a43f599672b414768d1316fda2e8c8ced98", "patch": "@@ -1,3 +1,9 @@\n+2010-07-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/42451\n+\t* gcc.dg/lto/20100720-3_0.c: New testcase.\n+\t* gcc.dg/lto/20100720-3_1.c: Likewise.\n+\n 2010-07-22  Richard Guenther  <rguenther@suse.de>\n \n \t* lib/target-supports-dg.exp (dg-require-linker-plugin): New proc."}, {"sha": "99c89ebd7fdd39b98c0c26911fc19fa9a6363836", "filename": "gcc/testsuite/gcc.dg/lto/20100720-3_0.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4398a43f599672b414768d1316fda2e8c8ced98/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20100720-3_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4398a43f599672b414768d1316fda2e8c8ced98/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20100720-3_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20100720-3_0.c?ref=d4398a43f599672b414768d1316fda2e8c8ced98", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-lto-do run } */\n+\n+struct X {\n+  int a;\n+};\n+\n+struct link {\n+  struct list_node *next;\n+};\n+\n+struct list_node {\n+  struct link lnk;\n+  struct X *value;\n+};\n+\n+void f(struct list_node *lst)\n+{\n+  lst->lnk.next = 0;\n+}\n+\n+int main(void)\n+{\n+  return 0;\n+}"}, {"sha": "3d323813edd00e86198cfb121ffffe31a15764cc", "filename": "gcc/testsuite/gcc.dg/lto/20100720-3_1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4398a43f599672b414768d1316fda2e8c8ced98/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20100720-3_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4398a43f599672b414768d1316fda2e8c8ced98/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20100720-3_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20100720-3_1.c?ref=d4398a43f599672b414768d1316fda2e8c8ced98", "patch": "@@ -0,0 +1,17 @@\n+struct X {\n+  int b;\n+};\n+\n+struct link {\n+  struct list_node *next;\n+};\n+\n+struct list_node {\n+  struct link lnk;\n+  struct X *value;\n+};\n+\n+void g(struct list_node *lst)\n+{\n+  lst->lnk.next = 0;\n+}"}]}