{"sha": "44c068aecb0ba30a25e3086e1c2dad7f6a3f8303", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRjMDY4YWVjYjBiYTMwYTI1ZTMwODZlMWMyZGFkN2Y2YTNmODMwMw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-12-16T13:51:36Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-12-16T13:51:36Z"}, "message": "nvptx-protos.h (nvptx_hard_regno_mode_ok): Delete.\n\n\t* config/nvptx/nvptx-protos.h (nvptx_hard_regno_mode_ok): Delete.\n\t* config/nvptx/nvptx.h (struct machine_function):\n\tReimplement. Adjust all users.\n\t* config/nvptx/nvptx.c (nvptx_declare_function_name): Move stack\n\tand frame array generation earlier.\n\t(nvptx_call_args): Reimplement.\n\t(nvptx_expand_call): Adjust.\n\t(nvptx_hard_reno_mode_ok): Delete.\n\t(nvptx_reorg): Revert scan of hard regs.\n\nFrom-SVN: r231691", "tree": {"sha": "2e335f774b171bb7d3e900b338fdd24e11a2a80d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e335f774b171bb7d3e900b338fdd24e11a2a80d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44c068aecb0ba30a25e3086e1c2dad7f6a3f8303", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44c068aecb0ba30a25e3086e1c2dad7f6a3f8303", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44c068aecb0ba30a25e3086e1c2dad7f6a3f8303", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44c068aecb0ba30a25e3086e1c2dad7f6a3f8303/comments", "author": null, "committer": null, "parents": [{"sha": "597a8ab9c6f57c416c2b0a734c2098fa0335e628", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/597a8ab9c6f57c416c2b0a734c2098fa0335e628", "html_url": "https://github.com/Rust-GCC/gccrs/commit/597a8ab9c6f57c416c2b0a734c2098fa0335e628"}], "stats": {"total": 151, "additions": 75, "deletions": 76}, "files": [{"sha": "c04c01f86ead172d6c93fc401c4fd788e5d84bdb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c068aecb0ba30a25e3086e1c2dad7f6a3f8303/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c068aecb0ba30a25e3086e1c2dad7f6a3f8303/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44c068aecb0ba30a25e3086e1c2dad7f6a3f8303", "patch": "@@ -1,11 +1,24 @@\n+2015-12-16  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* config/nvptx/nvptx-protos.h (nvptx_hard_regno_mode_ok): Delete.\n+\t* config/nvptx/nvptx.h (struct machine_function):\n+\tReimplement. Adjust all users.\n+\t* config/nvptx/nvptx.c (nvptx_declare_function_name): Move stack\n+\tand frame array generation earlier.\n+\t(nvptx_call_args): Reimplement.\n+\t(nvptx_expand_call): Adjust.\n+\t(nvptx_hard_reno_mode_ok): Delete.\n+\t(nvptx_reorg): Revert scan of hard regs.\n+\n 2015-12-16  Tom de Vries  <tom@codesourcery.com>\n \n-\t* opts.c (default_options_optimization): Set fipa-pta on by default for\n-\tfopenacc.\n+\t* opts.c (default_options_optimization): Set fipa-pta on by\n+\tdefault for fopenacc.\n \t* passes.def: Move kernels pass group to pass_ipa_oacc.\n \t* tree-pass.h (make_pass_oacc_kernels2): Remove.\n \t(make_pass_ipa_oacc, make_pass_ipa_oacc_kernels): Declare.\n-\t* tree-ssa-loop.c (pass_oacc_kernels2, make_pass_oacc_kernels2): Remove.\n+\t* tree-ssa-loop.c (pass_oacc_kernels2, make_pass_oacc_kernels2):\n+\tRemove.\n \t(pass_ipa_oacc, pass_ipa_oacc_kernels): New pass.\n \t(make_pass_ipa_oacc, make_pass_ipa_oacc_kernels): New function.\n \t* tree-ssa-structalias.c (pass_ipa_pta::clone): New function."}, {"sha": "084ff8e9aded6645e99ff340a50835ded402e3b5", "filename": "gcc/config/nvptx/nvptx-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c068aecb0ba30a25e3086e1c2dad7f6a3f8303/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c068aecb0ba30a25e3086e1c2dad7f6a3f8303/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h?ref=44c068aecb0ba30a25e3086e1c2dad7f6a3f8303", "patch": "@@ -41,7 +41,6 @@ extern const char *nvptx_ptx_type_from_mode (machine_mode, bool);\n extern const char *nvptx_output_mov_insn (rtx, rtx);\n extern const char *nvptx_output_call_insn (rtx_insn *, rtx, rtx);\n extern const char *nvptx_output_return (void);\n-extern bool nvptx_hard_regno_mode_ok (int, machine_mode);\n extern rtx nvptx_maybe_convert_symbolic_operand (rtx);\n #endif\n #endif"}, {"sha": "131a45ed4e36f9f931ec50842d60c93e0227e6aa", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 50, "deletions": 64, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c068aecb0ba30a25e3086e1c2dad7f6a3f8303/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c068aecb0ba30a25e3086e1c2dad7f6a3f8303/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=44c068aecb0ba30a25e3086e1c2dad7f6a3f8303", "patch": "@@ -147,7 +147,7 @@ static struct machine_function *\n nvptx_init_machine_status (void)\n {\n   struct machine_function *p = ggc_cleared_alloc<machine_function> ();\n-  p->ret_reg_mode = VOIDmode;\n+  p->return_mode = VOIDmode;\n   return p;\n }\n \n@@ -487,7 +487,7 @@ nvptx_strict_argument_naming (cumulative_args_t cum_v)\n static rtx\n nvptx_libcall_value (machine_mode mode, const_rtx)\n {\n-  if (cfun->machine->start_call == NULL_RTX)\n+  if (!cfun->machine->doing_call)\n     /* Pretend to return in a hard reg for early uses before pseudos can be\n        generated.  */\n     return gen_rtx_REG (mode, NVPTX_RETURN_REGNUM);\n@@ -506,7 +506,7 @@ nvptx_function_value (const_tree type, const_tree ARG_UNUSED (func),\n \n   if (outgoing)\n     {\n-      cfun->machine->ret_reg_mode = mode;\n+      cfun->machine->return_mode = mode;\n       return gen_rtx_REG (mode, NVPTX_RETURN_REGNUM);\n     }\n \n@@ -678,14 +678,14 @@ write_return_type (std::stringstream &s, bool for_proto, tree type)\n \t optimization-level specific, so no caller can make use of\n \t this data, but more importantly for us, we must ensure it\n \t doesn't change the PTX prototype.  */\n-      mode = (machine_mode) cfun->machine->ret_reg_mode;\n+      mode = (machine_mode) cfun->machine->return_mode;\n \n       if (mode == VOIDmode)\n \treturn return_in_mem;\n \n-      /* Clear ret_reg_mode to inhibit copy of retval to non-existent\n+      /* Clear return_mode to inhibit copy of retval to non-existent\n \t retval parameter.  */\n-      cfun->machine->ret_reg_mode = VOIDmode;\n+      cfun->machine->return_mode = VOIDmode;\n     }\n   else\n     mode = promote_return (mode);\n@@ -989,7 +989,18 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n \n   fprintf (file, \"%s\", s.str().c_str());\n \n-  if (regno_reg_rtx[OUTGOING_STATIC_CHAIN_REGNUM] != const0_rtx)\n+  /* Declare a local var for outgoing varargs.  */\n+  if (cfun->machine->has_varadic)\n+    init_frame (file, STACK_POINTER_REGNUM,\n+\t\tUNITS_PER_WORD, crtl->outgoing_args_size);\n+\n+  /* Declare a local variable for the frame.  */\n+  HOST_WIDE_INT sz = get_frame_size ();\n+  if (sz || cfun->machine->has_chain)\n+    init_frame (file, FRAME_POINTER_REGNUM,\n+\t\tcrtl->stack_alignment_needed / BITS_PER_UNIT, sz);\n+\n+  if (cfun->machine->has_chain)\n     fprintf (file, \"\\t.reg.u%d %s;\\n\", GET_MODE_BITSIZE (Pmode),\n \t     reg_names[OUTGOING_STATIC_CHAIN_REGNUM]);\n \n@@ -1010,17 +1021,6 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n \t}\n     }\n \n-  /* Declare a local var for outgoing varargs.  */\n-  if (cfun->machine->has_call_with_varargs)\n-    init_frame (file, STACK_POINTER_REGNUM,\n-\t\tUNITS_PER_WORD, crtl->outgoing_args_size);\n-\n-  /* Declare a local variable for the frame.  */\n-  HOST_WIDE_INT sz = get_frame_size ();\n-  if (sz || cfun->machine->has_call_with_sc)\n-    init_frame (file, FRAME_POINTER_REGNUM,\n-\t\tcrtl->stack_alignment_needed / BITS_PER_UNIT, sz);\n-\n   /* Emit axis predicates. */\n   if (cfun->machine->axis_predicate[0])\n     nvptx_init_axis_predicate (file,\n@@ -1036,7 +1036,7 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n const char *\n nvptx_output_return (void)\n {\n-  machine_mode mode = (machine_mode)cfun->machine->ret_reg_mode;\n+  machine_mode mode = (machine_mode)cfun->machine->return_mode;\n \n   if (mode != VOIDmode)\n     fprintf (asm_out_file, \"\\tst.param%s\\t[%s_out], %s;\\n\",\n@@ -1076,20 +1076,28 @@ nvptx_get_drap_rtx (void)\n    argument to the next call.  */\n \n static void\n-nvptx_call_args (rtx arg, tree funtype)\n+nvptx_call_args (rtx arg, tree fntype)\n {\n-  if (cfun->machine->start_call == NULL_RTX)\n+  if (!cfun->machine->doing_call)\n     {\n-      cfun->machine->call_args = NULL;\n-      cfun->machine->funtype = funtype;\n-      cfun->machine->start_call = const0_rtx;\n+      cfun->machine->doing_call = true;\n+      cfun->machine->is_varadic = false;\n+      cfun->machine->num_args = 0;\n+\n+      if (fntype && stdarg_p (fntype))\n+\t{\n+\t  cfun->machine->is_varadic = true;\n+\t  cfun->machine->has_varadic = true;\n+\t  cfun->machine->num_args++;\n+\t}\n     }\n-  if (arg == pc_rtx)\n-    return;\n \n-  rtx_expr_list *args_so_far = cfun->machine->call_args;\n-  if (REG_P (arg))\n-    cfun->machine->call_args = alloc_EXPR_LIST (VOIDmode, arg, args_so_far);\n+  if (REG_P (arg) && arg != pc_rtx)\n+    {\n+      cfun->machine->num_args++;\n+      cfun->machine->call_args = alloc_EXPR_LIST (VOIDmode, arg,\n+\t\t\t\t\t\t  cfun->machine->call_args);\n+    }\n }\n \n /* Implement the corresponding END_CALL_ARGS hook.  Clear and free the\n@@ -1098,7 +1106,7 @@ nvptx_call_args (rtx arg, tree funtype)\n static void\n nvptx_end_call_args (void)\n {\n-  cfun->machine->start_call = NULL_RTX;\n+  cfun->machine->doing_call = false;\n   free_EXPR_LIST_list (&cfun->machine->call_args);\n }\n \n@@ -1111,16 +1119,10 @@ nvptx_end_call_args (void)\n void\n nvptx_expand_call (rtx retval, rtx address)\n {\n-  int nargs = 0;\n   rtx callee = XEXP (address, 0);\n-  rtx pat, t;\n-  rtvec vec;\n   rtx varargs = NULL_RTX;\n   unsigned parallel = 0;\n \n-  for (t = cfun->machine->call_args; t; t = XEXP (t, 1))\n-    nargs++;\n-\n   if (!call_insn_operand (callee, Pmode))\n     {\n       callee = force_reg (Pmode, callee);\n@@ -1133,7 +1135,7 @@ nvptx_expand_call (rtx retval, rtx address)\n       if (decl != NULL_TREE)\n \t{\n \t  if (DECL_STATIC_CHAIN (decl))\n-\t    cfun->machine->has_call_with_sc = true;\n+\t    cfun->machine->has_chain = true;\n \n \t  tree attr = get_oacc_fn_attrib (decl);\n \t  if (attr)\n@@ -1154,35 +1156,31 @@ nvptx_expand_call (rtx retval, rtx address)\n \t}\n     }\n \n-  if (cfun->machine->funtype\n-      && stdarg_p (cfun->machine->funtype))\n+  unsigned nargs = cfun->machine->num_args;\n+  if (cfun->machine->is_varadic)\n     {\n       varargs = gen_reg_rtx (Pmode);\n       emit_move_insn (varargs, stack_pointer_rtx);\n-      cfun->machine->has_call_with_varargs = true;\n     }\n-  vec = rtvec_alloc (nargs + 1 + (varargs ? 1 : 0));\n-  pat = gen_rtx_PARALLEL (VOIDmode, vec);\n \n+  rtvec vec = rtvec_alloc (nargs + 1);\n+  rtx pat = gen_rtx_PARALLEL (VOIDmode, vec);\n   int vec_pos = 0;\n-  \n+\n+  rtx call = gen_rtx_CALL (VOIDmode, address, const0_rtx);\n   rtx tmp_retval = retval;\n-  t = gen_rtx_CALL (VOIDmode, address, const0_rtx);\n-  if (retval != NULL_RTX)\n+  if (retval)\n     {\n       if (!nvptx_register_operand (retval, GET_MODE (retval)))\n \ttmp_retval = gen_reg_rtx (GET_MODE (retval));\n-      t = gen_rtx_SET (tmp_retval, t);\n+      call = gen_rtx_SET (tmp_retval, call);\n     }\n-  XVECEXP (pat, 0, vec_pos++) = t;\n+  XVECEXP (pat, 0, vec_pos++) = call;\n \n   /* Construct the call insn, including a USE for each argument pseudo\n      register.  These will be used when printing the insn.  */\n   for (rtx arg = cfun->machine->call_args; arg; arg = XEXP (arg, 1))\n-    {\n-      rtx this_arg = XEXP (arg, 0);\n-      XVECEXP (pat, 0, vec_pos++) = gen_rtx_USE (VOIDmode, this_arg);\n-    }\n+    XVECEXP (pat, 0, vec_pos++) = gen_rtx_USE (VOIDmode, XEXP (arg, 0));\n \n   if (varargs)\n     XVECEXP (pat, 0, vec_pos++) = gen_rtx_USE (VOIDmode, varargs);\n@@ -1477,18 +1475,6 @@ nvptx_legitimate_address_p (machine_mode, rtx x, bool)\n       return false;\n     }\n }\n-\n-/* Implement HARD_REGNO_MODE_OK.  We barely use hard regs, but we want\n-   to ensure that the return register's mode isn't changed.  */\n-\n-bool\n-nvptx_hard_regno_mode_ok (int regno, machine_mode mode)\n-{\n-  if (regno != NVPTX_RETURN_REGNUM\n-      || cfun == NULL || cfun->machine->ret_reg_mode == VOIDmode)\n-    return true;\n-  return mode == cfun->machine->ret_reg_mode;\n-}\n \f\n /* Machinery to output constant initializers.  When beginning an\n    initializer, we decide on a fragment size (which is visible in ptx\n@@ -3773,7 +3759,7 @@ nvptx_reorg (void)\n   \n   /* Mark unused regs as unused.  */\n   int max_regs = max_reg_num ();\n-  for (int i = 0; i < max_regs; i++)\n+  for (int i = LAST_VIRTUAL_REGISTER + 1; i < max_regs; i++)\n     if (REG_N_SETS (i) == 0 && REG_N_REFS (i) == 0)\n       regno_reg_rtx[i] = const0_rtx;\n "}, {"sha": "f7230b70b7c35fe22615619793a60dd0d7cf25eb", "filename": "gcc/config/nvptx/nvptx.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c068aecb0ba30a25e3086e1c2dad7f6a3f8303/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c068aecb0ba30a25e3086e1c2dad7f6a3f8303/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.h?ref=44c068aecb0ba30a25e3086e1c2dad7f6a3f8303", "patch": "@@ -220,14 +220,15 @@ struct nvptx_args {\n #if defined HOST_WIDE_INT\n struct GTY(()) machine_function\n {\n-  rtx_expr_list *call_args;\n-  rtx start_call;\n-  tree funtype;\n-  bool has_call_with_varargs;\n-  bool has_call_with_sc;\n-  HOST_WIDE_INT outgoing_stdarg_size;\n-  int ret_reg_mode; /* machine_mode not defined yet. */\n-  rtx axis_predicate[2];\n+  rtx_expr_list *call_args;  /* Arg list for the current call.  */\n+  bool doing_call; /* Within a CALL_ARGS ... CALL_ARGS_END sequence.  */\n+  bool is_varadic;  /* This call is varadic  */\n+  bool has_varadic;  /* Current function has a varadic call.  */\n+  bool has_chain; /* Current function has outgoing static chain.  */\n+  int num_args;\t/* Number of args of current call.  */\n+  int return_mode; /* Return mode of current fn.\n+\t\t      (machine_mode not defined yet.) */\n+  rtx axis_predicate[2]; /* Neutering predicates.  */\n };\n #endif\n \f"}]}