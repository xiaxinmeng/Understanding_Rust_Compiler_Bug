{"sha": "b60fe4a75b7db33d3639ce7996579f729503b9d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYwZmU0YTc1YjdkYjMzZDM2MzljZTc5OTY1NzlmNzI5NTAzYjlkOQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-10-19T17:52:52Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-10-19T17:52:52Z"}, "message": "cplus-dem.c (INTBUF_SIZE): New macro.\n\n\t* cplus-dem.c (INTBUF_SIZE): New macro.\n\t(string_append_template_idx): New function.\n\t(demangle_expression): Likewise.\n\t(demangle_integral_value): Use it.\n\t(demangle_real_value): New function, split out from ...\n\t(demangle_template_value_parm): ... here.  Use\n\tstring_append_template_idx.  Use demangle_real_value.\n\t(demangle_template): Use string_append_template_idx.\n\t(demangle_qualified): Use consume_count_with_underscores.\n\t(get_count): Tweak formatting.\n\t(do_type): Use string_append_template_idx.\n\nFrom-SVN: r30091", "tree": {"sha": "141e7c3425e353850b39b1f55c3e8880a181d7ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/141e7c3425e353850b39b1f55c3e8880a181d7ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b60fe4a75b7db33d3639ce7996579f729503b9d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b60fe4a75b7db33d3639ce7996579f729503b9d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b60fe4a75b7db33d3639ce7996579f729503b9d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b60fe4a75b7db33d3639ce7996579f729503b9d9/comments", "author": null, "committer": null, "parents": [{"sha": "858a0ff1099497775acf5446b54e2eeeb19caae3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/858a0ff1099497775acf5446b54e2eeeb19caae3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/858a0ff1099497775acf5446b54e2eeeb19caae3"}], "stats": {"total": 279, "additions": 172, "deletions": 107}, "files": [{"sha": "78180af2d5dc826eede2918ab07127e1311184f8", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60fe4a75b7db33d3639ce7996579f729503b9d9/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60fe4a75b7db33d3639ce7996579f729503b9d9/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=b60fe4a75b7db33d3639ce7996579f729503b9d9", "patch": "@@ -1,3 +1,17 @@\n+1999-10-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cplus-dem.c (INTBUF_SIZE): New macro.\n+\t(string_append_template_idx): New function.\n+\t(demangle_expression): Likewise.\n+\t(demangle_integral_value): Use it.\n+\t(demangle_real_value): New function, split out from ...\n+\t(demangle_template_value_parm): ... here.  Use\n+\tstring_append_template_idx.  Use demangle_real_value.\n+\t(demangle_template): Use string_append_template_idx.\n+\t(demangle_qualified): Use consume_count_with_underscores.\n+\t(get_count): Tweak formatting.\n+\t(do_type): Use string_append_template_idx.\n+\t\n 1999-10-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* calloc.c: Add a public domain notice."}, {"sha": "7e8c74f6b13518a75f0cc06369961a9433ca4134", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 146, "deletions": 107, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60fe4a75b7db33d3639ce7996579f729503b9d9/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60fe4a75b7db33d3639ce7996579f729503b9d9/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=b60fe4a75b7db33d3639ce7996579f729503b9d9", "patch": "@@ -53,6 +53,10 @@ char * realloc ();\n \n #define min(X,Y) (((X) < (Y)) ? (X) : (Y))\n \n+/* A value at least one greater than the maximum number of characters\n+   that will be output when using the `%d' format with `printf'.  */\n+#define INTBUF_SIZE 32\n+\n extern void fancy_abort PARAMS ((void)) ATTRIBUTE_NORETURN;\n \n static const char *mystrstr PARAMS ((const char *, const char *));\n@@ -347,6 +351,9 @@ string_prepend PARAMS ((string *, const char *));\n static void\n string_prependn PARAMS ((string *, const char *, int));\n \n+static void\n+string_append_template_idx PARAMS ((string *, int));\n+\n static int\n get_count PARAMS ((const char **, int *));\n \n@@ -424,10 +431,17 @@ qualifier_string PARAMS ((int));\n static const char*\n demangle_qualifier PARAMS ((int));\n \n+static int\n+demangle_expression PARAMS ((struct work_stuff *, const char **, string *, \n+\t\t\t     type_kind_t));\n+\n static int\n demangle_integral_value PARAMS ((struct work_stuff *, const char **,\n \t\t\t\t string *));\n \n+static int\n+demangle_real_value PARAMS ((struct work_stuff *, const char **, string *));\n+\n static void\n demangle_arm_hp_template PARAMS ((struct work_stuff *, const char **, int,\n \t\t\t\t  string *));\n@@ -1348,87 +1362,155 @@ demangle_template_template_parm (work, mangled, tname)\n }\n \n static int\n-demangle_integral_value (work, mangled, s)\n+demangle_expression (work, mangled, s, tk)\n      struct work_stuff *work;\n      const char** mangled;\n      string* s;\n+     type_kind_t tk;\n {\n+  int need_operator = 0;\n   int success;\n \n-  if (**mangled == 'E')\n+  success = 1;\n+  string_appendn (s, \"(\", 1);\n+  (*mangled)++;\n+  while (success && **mangled != 'W' && **mangled != '\\0')\n     {\n-      int need_operator = 0;\n-\n-      success = 1;\n-      string_appendn (s, \"(\", 1);\n-      (*mangled)++;\n-      while (success && **mangled != 'W' && **mangled != '\\0')\n+      if (need_operator)\n \t{\n-\t  if (need_operator)\n-\t    {\n-\t      size_t i;\n-\t      size_t len;\n+\t  size_t i;\n+\t  size_t len;\n \n-\t      success = 0;\n+\t  success = 0;\n \n-\t      len = strlen (*mangled);\n+\t  len = strlen (*mangled);\n \n-\t      for (i = 0;\n-\t\t   i < sizeof (optable) / sizeof (optable [0]);\n-\t\t   ++i)\n-\t\t{\n-\t\t  size_t l = strlen (optable[i].in);\n+\t  for (i = 0;\n+\t       i < sizeof (optable) / sizeof (optable [0]);\n+\t       ++i)\n+\t    {\n+\t      size_t l = strlen (optable[i].in);\n \n-\t\t  if (l <= len\n-\t\t      && memcmp (optable[i].in, *mangled, l) == 0)\n-\t\t    {\n-\t\t      string_appendn (s, \" \", 1);\n-\t\t      string_append (s, optable[i].out);\n-\t\t      string_appendn (s, \" \", 1);\n-\t\t      success = 1;\n-\t\t      (*mangled) += l;\n-\t\t      break;\n-\t\t    }\n+\t      if (l <= len\n+\t\t  && memcmp (optable[i].in, *mangled, l) == 0)\n+\t\t{\n+\t\t  string_appendn (s, \" \", 1);\n+\t\t  string_append (s, optable[i].out);\n+\t\t  string_appendn (s, \" \", 1);\n+\t\t  success = 1;\n+\t\t  (*mangled) += l;\n+\t\t  break;\n \t\t}\n-\n-\t      if (!success)\n-\t\tbreak;\n \t    }\n-\t  else\n-\t    need_operator = 1;\n \n-\t  success = demangle_template_value_parm (work, mangled, s,\n-\t\t\t\t\t\t  tk_integral);\n+\t  if (!success)\n+\t    break;\n \t}\n-\n-      if (**mangled != 'W')\n-\t  success = 0;\n       else\n-\t{\n-\t  string_appendn (s, \")\", 1);\n-\t  (*mangled)++;\n-\t}\n+\tneed_operator = 1;\n+\n+      success = demangle_template_value_parm (work, mangled, s, tk);\n+    }\n+\n+  if (**mangled != 'W')\n+    success = 0;\n+  else\n+    {\n+      string_appendn (s, \")\", 1);\n+      (*mangled)++;\n     }\n+\n+  return success;\n+}\n+\n+static int\n+demangle_integral_value (work, mangled, s)\n+     struct work_stuff *work;\n+     const char** mangled;\n+     string* s;\n+{\n+  int success;\n+\n+  if (**mangled == 'E')\n+    success = demangle_expression (work, mangled, s, tk_integral);\n   else if (**mangled == 'Q' || **mangled == 'K')\n     success = demangle_qualified (work, mangled, s, 0, 1);\n   else\n     {\n+      int value;\n+\n       success = 0;\n \n+      /* Negative numbers are indicated with a leading `m'.  */\n       if (**mangled == 'm')\n \t{\n \t  string_appendn (s, \"-\", 1);\n \t  (*mangled)++;\n \t}\n+\n+      /* Read the rest of the number.  */\n+      value = consume_count_with_underscores (mangled);\n+      if (value != -1)\n+\t{\n+\t  char buf[INTBUF_SIZE];\n+\t  sprintf (buf, \"%d\", value);\n+\t  string_append (s, buf);\n+\n+\t  /* If the next character is an underscore, skip it.  */\n+\t  if (**mangled == '_')\n+\t    (*mangled)++;\n+\n+\t  /* All is well.  */\n+\t  success = 1;\n+\t}\n+    }\n+\n+  return success;\n+}\n+\n+/* Demangle the real value in MANGLED.  */\n+\n+static int\n+demangle_real_value (work, mangled, s)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string* s;\n+{\n+  if (**mangled == 'E')\n+    return demangle_expression (work, mangled, s, tk_real);\n+\n+  if (**mangled == 'm')\n+    {\n+      string_appendn (s, \"-\", 1);\n+      (*mangled)++;\n+    }\n+  while (isdigit ((unsigned char)**mangled))\n+    {\n+      string_appendn (s, *mangled, 1);\n+      (*mangled)++;\n+    }\n+  if (**mangled == '.') /* fraction */\n+    {\n+      string_appendn (s, \".\", 1);\n+      (*mangled)++;\n+      while (isdigit ((unsigned char)**mangled))\n+\t{\n+\t  string_appendn (s, *mangled, 1);\n+\t  (*mangled)++;\n+\t}\n+    }\n+  if (**mangled == 'e') /* exponent */\n+    {\n+      string_appendn (s, \"e\", 1);\n+      (*mangled)++;\n       while (isdigit ((unsigned char)**mangled))\n \t{\n \t  string_appendn (s, *mangled, 1);\n \t  (*mangled)++;\n-\t  success = 1;\n \t}\n     }\n \n-  return success;\n+  return 1;\n }\n \n static int\n@@ -1454,11 +1536,7 @@ demangle_template_value_parm (work, mangled, s, tk)\n       if (work->tmpl_argvec)\n \tstring_append (s, work->tmpl_argvec[idx]);\n       else\n-\t{\n-\t  char buf[10];\n-\t  sprintf(buf, \"T%d\", idx);\n-\t  string_append (s, buf);\n-\t}\n+\tstring_append_template_idx (s, idx);\n     }\n   else if (tk == tk_integral)\n     success = demangle_integral_value (work, mangled, s);\n@@ -1494,38 +1572,7 @@ demangle_template_value_parm (work, mangled, s, tk)\n \tsuccess = 0;\n     }\n   else if (tk == tk_real)\n-    {\n-      if (**mangled == 'm')\n-\t{\n-\t  string_appendn (s, \"-\", 1);\n-\t  (*mangled)++;\n-\t}\n-      while (isdigit ((unsigned char)**mangled))\n-\t{\n-\t  string_appendn (s, *mangled, 1);\n-\t  (*mangled)++;\n-\t}\n-      if (**mangled == '.') /* fraction */\n-\t{\n-\t  string_appendn (s, \".\", 1);\n-\t  (*mangled)++;\n-\t  while (isdigit ((unsigned char)**mangled))\n-\t    {\n-\t      string_appendn (s, *mangled, 1);\n-\t      (*mangled)++;\n-\t    }\n-\t}\n-      if (**mangled == 'e') /* exponent */\n-\t{\n-\t  string_appendn (s, \"e\", 1);\n-\t  (*mangled)++;\n-\t  while (isdigit ((unsigned char)**mangled))\n-\t    {\n-\t      string_appendn (s, *mangled, 1);\n-\t      (*mangled)++;\n-\t    }\n-\t}\n-    }\n+    success = demangle_real_value (work, mangled, s);\n   else if (tk == tk_pointer || tk == tk_reference)\n     {\n       if (**mangled == 'Q')\n@@ -1623,11 +1670,9 @@ demangle_template (work, mangled, tname, trawname, is_type, remember)\n \t    }\n \t  else\n \t    {\n-\t      char buf[10];\n-\t      sprintf(buf, \"T%d\", idx);\n-\t      string_append (tname, buf);\n+\t      string_append_template_idx (tname, idx);\n \t      if (trawname)\n-\t\tstring_append (trawname, buf);\n+\t\tstring_append_template_idx (trawname, idx);\n \t    }\n \t}\n       else\n@@ -2696,7 +2741,6 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n {\n   int qualifiers = 0;\n   int success = 1;\n-  const char *p;\n   char num[2];\n   string temp;\n   string last_name;\n@@ -2728,19 +2772,10 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n       /* GNU mangled name with more than 9 classes.  The count is preceded\n \t by an underscore (to distinguish it from the <= 9 case) and followed\n \t by an underscore.  */\n-      p = *mangled + 2;\n-      qualifiers = atoi (p);\n-      if (!isdigit ((unsigned char)*p) || *p == '0')\n-\tsuccess = 0;\n-\n-      /* Skip the digits.  */\n-      while (isdigit ((unsigned char)*p))\n-\t++p;\n-\n-      if (*p != '_')\n+      (*mangled)++;\n+      qualifiers = consume_count_with_underscores (mangled);\n+      if (qualifiers == -1)\n \tsuccess = 0;\n-\n-      *mangled = p + 1;\n       break;\n \n     case '1':\n@@ -2931,9 +2966,7 @@ get_count (type, count)\n   int n;\n \n   if (!isdigit ((unsigned char)**type))\n-    {\n-      return (0);\n-    }\n+    return (0);\n   else\n     {\n       *count = **type - '0';\n@@ -3230,11 +3263,7 @@ do_type (work, mangled, result)\n \tif (work->tmpl_argvec)\n \t  string_append (result, work->tmpl_argvec[idx]);\n \telse\n-\t  {\n-\t    char buf[10];\n-\t    sprintf(buf, \"T%d\", idx);\n-\t    string_append (result, buf);\n-\t  }\n+\t  string_append_template_idx (result, idx);\n \n \tsuccess = 1;\n       }\n@@ -4353,6 +4382,16 @@ string_prependn (p, s, n)\n     }\n }\n \n+static void\n+string_append_template_idx (s, idx)\n+     string *s;\n+     int idx;\n+{\n+  char buf[INTBUF_SIZE + 1 /* 'T' */];\n+  sprintf(buf, \"T%d\", idx);\n+  string_append (s, buf);\n+}\n+\n /* To generate a standalone demangler program for testing purposes,\n    just compile and link this file with -DMAIN and libiberty.a.  When\n    run, it demangles each command line arg, or each stdin string, and"}, {"sha": "d3a1fe43890d992690a98bfbdf57dbaf215da055", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60fe4a75b7db33d3639ce7996579f729503b9d9/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60fe4a75b7db33d3639ce7996579f729503b9d9/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=b60fe4a75b7db33d3639ce7996579f729503b9d9", "patch": "@@ -2474,3 +2474,15 @@ C<Test, Test::output> call<Test>(Test &)\n --format=gnu\n fn__FPQ21n1cPMQ21n1cFPQ21n1c_i\n fn(n::c *, int (n::c::*)(n::c *))\n+#\n+--format=gnu\n+f__FGt3Bar1i21i\n+f(Bar<2>, i)\n+#\n+--format=gnu\n+f__FGt3Bar1i_21_i\n+f(Bar<21>, int)\n+#\n+--format=gnu\n+f__FGt3Bar1i24XY_t\n+f(Bar<2>, XY_t)"}]}