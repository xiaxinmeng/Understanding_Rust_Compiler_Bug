{"sha": "39da8a7ba9a3a643e6318a5534d5d7c85a3bedfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlkYThhN2JhOWEzYTY0M2U2MzE4YTU1MzRkNWQ3Yzg1YTNiZWRmYQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-30T07:48:37Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-30T09:14:12Z"}, "message": "tree-optimization/101264 - rework SLP \"any\" permute forward prop\n\nThis integrates the forward propagation of SLP \"any\" permutes into\nthe main propagation stage as a separate single-pass propagation\ndidn't work out.\n\n2021-06-30  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/101264\n\t* tree-vect-slp.c (vect_optimize_slp): Propagate the\n\tcomputed perm_in to all \"any\" permute successors\n\twe cannot de-duplicate immediately.\n\n\t* gfortran.dg/pr101264.f90: New testcase.", "tree": {"sha": "b8edb06e09ca7a09b052581428ad5fd1b8fd9efb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8edb06e09ca7a09b052581428ad5fd1b8fd9efb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39da8a7ba9a3a643e6318a5534d5d7c85a3bedfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39da8a7ba9a3a643e6318a5534d5d7c85a3bedfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39da8a7ba9a3a643e6318a5534d5d7c85a3bedfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39da8a7ba9a3a643e6318a5534d5d7c85a3bedfa/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35da8a98026849bd20d16bbf9210ac1d0b44ea6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35da8a98026849bd20d16bbf9210ac1d0b44ea6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35da8a98026849bd20d16bbf9210ac1d0b44ea6a"}], "stats": {"total": 173, "additions": 115, "deletions": 58}, "files": [{"sha": "5602a709a36d52050b6dd4d78feb770d34e7603a", "filename": "gcc/testsuite/gfortran.dg/pr101264.f90", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39da8a7ba9a3a643e6318a5534d5d7c85a3bedfa/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr101264.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39da8a7ba9a3a643e6318a5534d5d7c85a3bedfa/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr101264.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr101264.f90?ref=39da8a7ba9a3a643e6318a5534d5d7c85a3bedfa", "patch": "@@ -0,0 +1,94 @@\n+! { dg-do compile }\n+! { dg-options \"-Ofast\" }\n+  SUBROUTINE foo (a,b,c,d,trigs,inc1,inc2,inc3,inc4,lot,n,la)\n+    IMPLICIT NONE (type, external)\n+    INTEGER, PARAMETER ::   wp = 8\n+    INTEGER, PARAMETER ::  iwp = 4\n+    INTEGER(iwp) ::  inc1\n+    INTEGER(iwp) ::  inc2\n+    INTEGER(iwp) ::  inc3\n+    INTEGER(iwp) ::  inc4\n+    INTEGER(iwp) ::  la\n+    INTEGER(iwp) ::  lot\n+    INTEGER(iwp) ::  n\n+\n+    REAL(wp) ::  a(*)\n+    REAL(wp) ::  b(*)\n+    REAL(wp) ::  c(*)\n+    REAL(wp) ::  d(*)\n+    REAL(wp) ::  trigs(*)\n+\n+    REAL(wp) ::  c1\n+    REAL(wp) ::  c2\n+    REAL(wp) ::  s1\n+    REAL(wp) ::  s2\n+    REAL(wp) ::  sin60\n+\n+    INTEGER(iwp) ::  i\n+    INTEGER(iwp) ::  ia\n+    INTEGER(iwp) ::  ib\n+    INTEGER(iwp) ::  ibase\n+    INTEGER(iwp) ::  ic\n+    INTEGER(iwp) ::  iink\n+    INTEGER(iwp) ::  ijk\n+    INTEGER(iwp) ::  j\n+    INTEGER(iwp) ::  ja\n+    INTEGER(iwp) ::  jb\n+    INTEGER(iwp) ::  jbase\n+    INTEGER(iwp) ::  jc\n+    INTEGER(iwp) ::  jink\n+    INTEGER(iwp) ::  jump\n+    INTEGER(iwp) ::  k\n+    INTEGER(iwp) ::  kb\n+    INTEGER(iwp) ::  kc\n+    INTEGER(iwp) ::  kstop\n+    INTEGER(iwp) ::  l\n+    INTEGER(iwp) ::  m\n+\n+    sin60=0.866025403784437_wp\n+\n+    ia = 1\n+    ib = ia + (2*m-la)*inc1\n+    ic = ib\n+    ja = 1\n+    jb = ja + jink\n+    jc = jb + jink\n+\n+    DO k = la, kstop, la\n+       kb = k + k\n+       kc = kb + kb\n+       c1 = trigs(kb+1)\n+       s1 = trigs(kb+2)\n+       c2 = trigs(kc+1)\n+       s2 = trigs(kc+2)\n+       ibase = 0\n+       DO l = 1, la\n+          i = ibase\n+          j = jbase\n+          DO ijk = 1, lot\n+             c(ja+j) = a(ia+i) + (a(ib+i)+a(ic+i))\n+             d(ja+j) = b(ia+i) + (b(ib+i)-b(ic+i))\n+             c(jb+j) = c1*((a(ia+i)-0.5_wp*(a(ib+i)+a(ic+i)))-(sin60*(b(ib+i)+ &\n+                  &            b(ic+i))))                                      &\n+                  &    - s1*((b(ia+i)-0.5_wp*(b(ib+i)-b(ic+i)))+(sin60*(a(ib+i)- &\n+                  &            a(ic+i))))\n+             d(jb+j) = s1*((a(ia+i)-0.5_wp*(a(ib+i)+a(ic+i)))-(sin60*(b(ib+i)+ &\n+                  &            b(ic+i))))                                      &\n+                  &    + c1*((b(ia+i)-0.5_wp*(b(ib+i)-b(ic+i)))+(sin60*(a(ib+i)- &\n+                  &            a(ic+i))))\n+             c(jc+j) = c2*((a(ia+i)-0.5_wp*(a(ib+i)+a(ic+i)))+(sin60*(b(ib+i)+ &\n+                  &            b(ic+i))))                                      &\n+                  &    - s2*((b(ia+i)-0.5_wp*(b(ib+i)-b(ic+i)))-(sin60*(a(ib+i)- &\n+                  &            a(ic+i))))\n+             i = i + inc3\n+             j = j + inc4\n+          END DO\n+          ibase = ibase + inc1\n+          jbase = jbase + inc2\n+       END DO\n+       ia = ia + iink\n+       ib = ib + iink\n+       ic = ic - iink\n+       jbase = jbase + jump\n+    END DO\n+  END"}, {"sha": "10195d3629fb147e25d3c103c3c3eb2b01efaf8e", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 21, "deletions": 58, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39da8a7ba9a3a643e6318a5534d5d7c85a3bedfa/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39da8a7ba9a3a643e6318a5534d5d7c85a3bedfa/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=39da8a7ba9a3a643e6318a5534d5d7c85a3bedfa", "patch": "@@ -3729,6 +3729,7 @@ vect_optimize_slp (vec_info *vinfo)\n \t    perm = vertices[idx].perm_out;\n \t  else\n \t    {\n+\t      bool any_succ_perm_out_m1 = false;\n \t      perm = vertices[idx].get_perm_in ();\n \t      for (graph_edge *succ = slpg->vertices[idx].succ;\n \t\t   succ; succ = succ->succ_next)\n@@ -3742,7 +3743,15 @@ vect_optimize_slp (vec_info *vinfo)\n \t\t     For example see gcc.dg/vect/bb-slp-14.c for a case\n \t\t     that would break.  */\n \t\t  if (succ_perm == -1)\n-\t\t    continue;\n+\t\t    {\n+\t\t      /* When we handled a non-leaf optimistically, note\n+\t\t\t that so we can adjust its outgoing permute below.  */\n+\t\t      slp_tree succ_node = vertices[succ_idx].node;\n+\t\t      if (SLP_TREE_DEF_TYPE (succ_node) != vect_external_def\n+\t\t\t  && SLP_TREE_DEF_TYPE (succ_node) != vect_constant_def)\n+\t\t\tany_succ_perm_out_m1 = true;\n+\t\t      continue;\n+\t\t    }\n \t\t  if (perm == -1)\n \t\t    perm = succ_perm;\n \t\t  else if (succ_perm == 0\n@@ -3753,25 +3762,19 @@ vect_optimize_slp (vec_info *vinfo)\n \t\t    }\n \t\t}\n \n-\t      /* If this is a node we do not want to eventually unshare\n-\t\t but it can be permuted at will, verify all users have\n-\t\t the same permutations registered and otherwise drop to\n-\t\t zero.  */\n-\t      if (perm == -1\n-\t\t  && SLP_TREE_DEF_TYPE (node) != vect_external_def\n-\t\t  && SLP_TREE_DEF_TYPE (node) != vect_constant_def)\n+\t      /* Adjust any incoming permutes we treated optimistically.  */\n+\t      if (perm != -1 && any_succ_perm_out_m1)\n \t\t{\n-\t\t  int preds_perm = -1;\n-\t\t  for (graph_edge *pred = slpg->vertices[idx].pred;\n-\t\t       pred; pred = pred->pred_next)\n+\t\t  for (graph_edge *succ = slpg->vertices[idx].succ;\n+\t\t       succ; succ = succ->succ_next)\n \t\t    {\n-\t\t      int pred_perm = vertices[pred->src].get_perm_in ();\n-\t\t      if (preds_perm == -1)\n-\t\t\tpreds_perm = pred_perm;\n-\t\t      else if (!vect_slp_perms_eq (perms,\n-\t\t\t\t\t\t   pred_perm, preds_perm))\n-\t\t\tperm = 0;\n+\t\t      slp_tree succ_node = vertices[succ->dest].node;\n+\t\t      if (vertices[succ->dest].perm_out == -1\n+\t\t\t  && SLP_TREE_DEF_TYPE (succ_node) != vect_external_def\n+\t\t\t  && SLP_TREE_DEF_TYPE (succ_node) != vect_constant_def)\n+\t\t\tvertices[succ->dest].perm_out = perm;\n \t\t    }\n+\t\t  changed = true;\n \t\t}\n \n \t      if (!vect_slp_perms_eq (perms, perm,\n@@ -3840,47 +3843,7 @@ vect_optimize_slp (vec_info *vinfo)\n \t}\n     }\n   while (changed);\n-  statistics_counter_event (cfun, \"SLP optimize perm iterations\", iteration);\n-\n-  /* Compute pre-order.  */\n-  auto_vec<int> heads;\n-  heads.reserve (vinfo->slp_instances.length ());\n-  for (slp_instance inst : vinfo->slp_instances)\n-    heads.quick_push (SLP_INSTANCE_TREE (inst)->vertex);\n-  auto_vec<int> po;\n-  graphds_dfs (slpg, &heads[0], heads.length (), &po, true, NULL, NULL);\n-\n-  /* Propagate materialized permutes to \"any\" permute nodes.  For heads\n-     ending up as \"any\" (reductions with just invariants), set them to\n-     no permute.  */\n-  for (int idx : heads)\n-    if (vertices[idx].perm_out == -1)\n-      vertices[idx].perm_out = 0;\n-  for (i = po.length (); i > 0; --i)\n-    {\n-      int idx = po[i-1];\n-      int perm_in = vertices[idx].get_perm_in ();\n-      slp_tree node = vertices[idx].node;\n-      if (SLP_TREE_DEF_TYPE (node) == vect_external_def\n-\t  || SLP_TREE_DEF_TYPE (node) == vect_constant_def)\n-\tcontinue;\n-      gcc_assert (perm_in != -1);\n-      for (graph_edge *succ = slpg->vertices[idx].succ;\n-\t   succ; succ = succ->succ_next)\n-\t{\n-\t  slp_tree succ_node = vertices[succ->dest].node;\n-\t  if (SLP_TREE_DEF_TYPE (succ_node) == vect_external_def\n-\t      || SLP_TREE_DEF_TYPE (succ_node) == vect_constant_def)\n-\t    continue;\n-\t  if (vertices[succ->dest].perm_out == -1)\n-\t    vertices[succ->dest].perm_out = perm_in;\n-\t  else\n-\t    /* Propagation should have ensured that all preds have the same\n-\t       permutation.  */\n-\t    gcc_assert (vect_slp_perms_eq (perms, perm_in,\n-\t\t\t\t\t   vertices[succ->dest].perm_out));\n-\t}\n-    }\n+  statistics_histogram_event (cfun, \"SLP optimize perm iterations\", iteration);\n \n   /* Materialize.  */\n   for (i = 0; i < vertices.length (); ++i)"}]}