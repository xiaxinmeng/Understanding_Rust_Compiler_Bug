{"sha": "51ddb82e4604cfdcc15d6a7b87b4bb713037205c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFkZGI4MmU0NjA0Y2ZkY2MxNWQ2YTdiODdiNGJiNzEzMDM3MjA1Yw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-08-25T01:48:47Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-08-25T01:48:47Z"}, "message": "typeck.c (convert_for_assignment): Converting from pm of vbase to derived is an error, not a sorry.\n\n\t* typeck.c (convert_for_assignment): Converting from pm of vbase\n\tto derived is an error, not a sorry.\n\t* call.c (build_over_call): Use convert_pointer_to_real for 'this'.\n\t* class.c (fixed_type_or_null): Rename from\n\tresolves_to_fixed_type_p.  Return the dynamic type of the\n\texpression, if fixed, or null.\n\t(resolves_to_fixed_type_p): Use it.  Return 0 if the dynamic type\n\tdoes not match the static type.\n\t(build_vbase_path): Rename 'alias_this' to 'nonnull'.  Use\n\tresolves_to_fixed_type_p again.\n\nFrom-SVN: r21958", "tree": {"sha": "47603192b7fb5369e59eeb8e210c6872a63bf58c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47603192b7fb5369e59eeb8e210c6872a63bf58c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51ddb82e4604cfdcc15d6a7b87b4bb713037205c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51ddb82e4604cfdcc15d6a7b87b4bb713037205c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51ddb82e4604cfdcc15d6a7b87b4bb713037205c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51ddb82e4604cfdcc15d6a7b87b4bb713037205c/comments", "author": null, "committer": null, "parents": [{"sha": "1dd503e847be6268eb3e85504e34c06f26d135f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dd503e847be6268eb3e85504e34c06f26d135f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dd503e847be6268eb3e85504e34c06f26d135f0"}], "stats": {"total": 138, "additions": 90, "deletions": 48}, "files": [{"sha": "eeb2490ea6782392d444941c779ac7f2924f2017", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ddb82e4604cfdcc15d6a7b87b4bb713037205c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ddb82e4604cfdcc15d6a7b87b4bb713037205c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=51ddb82e4604cfdcc15d6a7b87b4bb713037205c", "patch": "@@ -1,3 +1,17 @@\n+1998-08-25  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (convert_for_assignment): Converting from pm of vbase\n+\tto derived is an error, not a sorry.\n+\n+\t* call.c (build_over_call): Use convert_pointer_to_real for 'this'.\n+\t* class.c (fixed_type_or_null): Rename from\n+\tresolves_to_fixed_type_p.  Return the dynamic type of the\n+\texpression, if fixed, or null.\n+\t(resolves_to_fixed_type_p): Use it.  Return 0 if the dynamic type\n+\tdoes not match the static type.\n+\t(build_vbase_path): Rename 'alias_this' to 'nonnull'.  Use\n+\tresolves_to_fixed_type_p again.\n+\n 1998-08-24  Mark Mitchell  <mark@markmitchell.com>\n \n \t* pt.c (tsubst_decl): Move special case code for dealing with"}, {"sha": "5564fa3a535e5b412309e03256b7a26c949b04a8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ddb82e4604cfdcc15d6a7b87b4bb713037205c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ddb82e4604cfdcc15d6a7b87b4bb713037205c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=51ddb82e4604cfdcc15d6a7b87b4bb713037205c", "patch": "@@ -3291,6 +3291,7 @@ build_over_call (cand, args, flags)\n     {\n       tree parmtype = TREE_VALUE (parm);\n       tree argtype = TREE_TYPE (TREE_VALUE (arg));\n+      tree t;\n       if (ICS_BAD_FLAG (TREE_VEC_ELT (convs, i)))\n \t{\n \t  int dv = (TYPE_VOLATILE (TREE_TYPE (parmtype))\n@@ -3303,9 +3304,18 @@ build_over_call (cand, args, flags)\n \t  cp_pedwarn (\"passing `%T' as `this' argument of `%#D' discards %s\",\n \t\t      TREE_TYPE (argtype), fn, p);\n \t}\n-      converted_args = expr_tree_cons\n-\t(NULL_TREE, convert_force (TREE_VALUE (parm), TREE_VALUE (arg), CONV_C_CAST),\n-\t converted_args);\n+      /* [class.mfct.nonstatic]: If a nonstatic member function of a class\n+\t X is called for an object that is not of type X, or of a type\n+\t derived from X, the behavior is undefined.\n+\n+         So we can assume that anything passed as 'this' is non-null, and\n+\t optimize accordingly.  */\n+      if (TREE_CODE (parmtype) == POINTER_TYPE)\n+\tt = convert_pointer_to_real (TREE_TYPE (parmtype), TREE_VALUE (arg));\n+      else\n+\t/* This happens with signatures.  */\n+\tt = convert_force (parmtype, TREE_VALUE (arg), CONV_C_CAST);\n+      converted_args = expr_tree_cons (NULL_TREE, t, converted_args);\n       parm = TREE_CHAIN (parm);\n       arg = TREE_CHAIN (arg);\n       ++i;"}, {"sha": "d799f63593197cdd219e3d33715ab7e7fcfd20a3", "filename": "gcc/cp/class.c", "status": "modified", "additions": 62, "deletions": 44, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ddb82e4604cfdcc15d6a7b87b4bb713037205c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ddb82e4604cfdcc15d6a7b87b4bb713037205c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=51ddb82e4604cfdcc15d6a7b87b4bb713037205c", "patch": "@@ -229,17 +229,17 @@ complete_type_p (expr)\n \n    TYPE is the type we want this path to have on exit.\n \n-   ALIAS_THIS is non-zero if EXPR in an expression involving `this'.  */\n+   NONNULL is non-zero if  we know (for any reason) that EXPR is\n+   not, in fact, zero.  */\n \n tree\n-build_vbase_path (code, type, expr, path, alias_this)\n+build_vbase_path (code, type, expr, path, nonnull)\n      enum tree_code code;\n      tree type, expr, path;\n-     int alias_this;\n+     int nonnull;\n {\n   register int changed = 0;\n   tree last = NULL_TREE, last_virtual = NULL_TREE;\n-  int nonnull = 0;\n   int fixed_type_p;\n   tree null_expr = 0, nonnull_expr;\n   tree basetype;\n@@ -248,20 +248,16 @@ build_vbase_path (code, type, expr, path, alias_this)\n   if (BINFO_INHERITANCE_CHAIN (path) == NULL_TREE)\n     return build1 (NOP_EXPR, type, expr);\n \n-  if (nonnull == 0 && (alias_this && flag_this_is_variable <= 0))\n-    nonnull = 1;\n+  /* If -fthis-is-variable, we might have set nonnull incorrectly.  We\n+     don't care enough to get this right, so just clear it.  */\n+  if (flag_this_is_variable > 0)\n+    nonnull = 0;\n \n-#if 0\n-  /* We need additional logic to convert back to the unconverted type\n-     (the static type of the complete object), and then convert back\n-     to the type we want.  Until that is done, or until we can\n-     recognize when that is, we cannot do the short cut logic. (mrs) */\n+  /* We could do better if we had additional logic to convert back to the\n+     unconverted type (the static type of the complete object), and then\n+     convert back to the type we want.  Until that is done, we only optimize\n+     if the complete type is the same type as expr has.  */\n   fixed_type_p = resolves_to_fixed_type_p (expr, &nonnull);\n-#else\n-  /* Do this, until we can undo any previous conversions.  See net35.C\n-     for a testcase.  */\n-  fixed_type_p = complete_type_p (expr);\n-#endif\n \n   if (!fixed_type_p && TREE_SIDE_EFFECTS (expr))\n     expr = save_expr (expr);\n@@ -382,12 +378,7 @@ build_vbase_path (code, type, expr, path, alias_this)\n       expr = build1 (NOP_EXPR, type, expr);\n #endif\n \n-      /* For multiple inheritance: if `this' can be set by any\n-\t function, then it could be 0 on entry to any function.\n-\t Preserve such zeroness here.  Otherwise, only in the\n-\t case of constructors need we worry, and in those cases,\n-\t it will be zero, or initialized to some valid value to\n-\t which we may add.  */\n+      /* If expr might be 0, we need to preserve that zeroness.  */\n       if (nonnull == 0)\n \t{\n \t  if (null_expr)\n@@ -4485,15 +4476,15 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n   return t;\n }\n \f\n-/* Return non-zero if the effective type of INSTANCE is static.\n+/* Return the dynamic type of INSTANCE, if known.\n    Used to determine whether the virtual function table is needed\n    or not.\n \n    *NONNULL is set iff INSTANCE can be known to be nonnull, regardless\n    of our knowledge of its type.  */\n \n-int\n-resolves_to_fixed_type_p (instance, nonnull)\n+tree\n+fixed_type_or_null (instance, nonnull)\n      tree instance;\n      int *nonnull;\n {\n@@ -4511,43 +4502,43 @@ resolves_to_fixed_type_p (instance, nonnull)\n \t{\n \t  if (nonnull)\n \t    *nonnull = 1;\n-\t  return 1;\n+\t  return TREE_TYPE (instance);\n \t}\n-      return 0;\n+      return NULL_TREE;\n \n     case SAVE_EXPR:\n       /* This is a call to a constructor, hence it's never zero.  */\n       if (TREE_HAS_CONSTRUCTOR (instance))\n \t{\n \t  if (nonnull)\n \t    *nonnull = 1;\n-\t  return 1;\n+\t  return TREE_TYPE (instance);\n \t}\n-      return resolves_to_fixed_type_p (TREE_OPERAND (instance, 0), nonnull);\n+      return fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull);\n \n     case RTL_EXPR:\n-      return 0;\n+      return NULL_TREE;\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n       if (TREE_CODE (TREE_OPERAND (instance, 1)) == INTEGER_CST)\n \t/* Propagate nonnull.  */\n-\tresolves_to_fixed_type_p (TREE_OPERAND (instance, 0), nonnull);\n+\tfixed_type_or_null (TREE_OPERAND (instance, 0), nonnull);\n       if (TREE_CODE (TREE_OPERAND (instance, 0)) == ADDR_EXPR)\n-\treturn resolves_to_fixed_type_p (TREE_OPERAND (instance, 0), nonnull);\n-      return 0;\n+\treturn fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull);\n+      return NULL_TREE;\n \n     case NOP_EXPR:\n     case CONVERT_EXPR:\n-      return resolves_to_fixed_type_p (TREE_OPERAND (instance, 0), nonnull);\n+      return fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull);\n \n     case ADDR_EXPR:\n       if (nonnull)\n \t*nonnull = 1;\n-      return resolves_to_fixed_type_p (TREE_OPERAND (instance, 0), nonnull);\n+      return fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull);\n \n     case COMPONENT_REF:\n-      return resolves_to_fixed_type_p (TREE_OPERAND (instance, 1), nonnull);\n+      return fixed_type_or_null (TREE_OPERAND (instance, 1), nonnull);\n \n     case VAR_DECL:\n     case FIELD_DECL:\n@@ -4556,7 +4547,7 @@ resolves_to_fixed_type_p (instance, nonnull)\n \t{\n \t  if (nonnull)\n \t    *nonnull = 1;\n-\t  return 1;\n+\t  return TREE_TYPE (TREE_TYPE (instance));\n \t}\n       /* fall through...  */\n     case TARGET_EXPR:\n@@ -4565,29 +4556,56 @@ resolves_to_fixed_type_p (instance, nonnull)\n \t{\n \t  if (nonnull)\n \t    *nonnull = 1;\n-\t  return 1;\n+\t  return TREE_TYPE (instance);\n \t}\n       else if (nonnull)\n \t{\n \t  if (instance == current_class_ptr\n \t      && flag_this_is_variable <= 0)\n \t    {\n-\t      /* Some people still use `this = 0' inside destructors.  */\n-\t      *nonnull = ! DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (current_function_decl));\n-\t      /* In a constructor, we know our type.  */\n+\t      /* Normally, 'this' must be non-null.  */\n+\t      if (flag_this_is_variable == 0)\n+\t\t*nonnull = 1;\n+\n+\t      /* <0 means we're in a constructor and we know our type.  */\n \t      if (flag_this_is_variable < 0)\n-\t\treturn 1;\n+\t\treturn TREE_TYPE (TREE_TYPE (instance));\n \t    }\n \t  else if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n \t    /* Reference variables should be references to objects.  */\n \t    *nonnull = 1;\n \t}\n-      return 0;\n+      return NULL_TREE;\n \n     default:\n-      return 0;\n+      return NULL_TREE;\n     }\n }\n+\n+/* Return non-zero if the dynamic type of INSTANCE is known, and equivalent\n+   to the static type.  We also handle the case where INSTANCE is really\n+   a pointer.\n+\n+   Used to determine whether the virtual function table is needed\n+   or not.\n+\n+   *NONNULL is set iff INSTANCE can be known to be nonnull, regardless\n+   of our knowledge of its type.  */\n+\n+int\n+resolves_to_fixed_type_p (instance, nonnull)\n+     tree instance;\n+     int *nonnull;\n+{\n+  tree t = TREE_TYPE (instance);\n+  tree fixed = fixed_type_or_null (instance, nonnull);\n+  if (fixed == NULL_TREE)\n+    return 0;\n+  if (POINTER_TYPE_P (t))\n+    t = TREE_TYPE (t);\n+  return comptypes (TYPE_MAIN_VARIANT (t), TYPE_MAIN_VARIANT (fixed), 1);\n+}\n+\n \f\n void\n init_class_processing ()"}, {"sha": "c7530f06d7ba056a051e08610d7df45b643a7093", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ddb82e4604cfdcc15d6a7b87b4bb713037205c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ddb82e4604cfdcc15d6a7b87b4bb713037205c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=51ddb82e4604cfdcc15d6a7b87b4bb713037205c", "patch": "@@ -6830,7 +6830,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\t  && binfo_member (TYPE_OFFSET_BASETYPE (ttr),\n \t\t\t\t   CLASSTYPE_VBASECLASSES (TYPE_OFFSET_BASETYPE (ttl))))\n \t\t{\n-\t\t  sorry (\"%s between pointer to members converting across virtual baseclasses\", errtype);\n+\t\t  error (\"%s between pointer to members converting across virtual baseclasses\", errtype);\n \t\t  return error_mark_node;\n \t\t}\n \t      else if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))"}]}