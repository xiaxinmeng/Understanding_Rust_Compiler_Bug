{"sha": "f7ca1d041c1766a16a016d959395370bea93d069", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdjYTFkMDQxYzE3NjZhMTZhMDE2ZDk1OTM5NTM3MGJlYTkzZDA2OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-15T09:32:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-15T09:32:23Z"}, "message": "[multiple changes]\n\n2009-04-15  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Use_One_Type): If both clauses appear on the same unit,\n\tthe second is redundant, regardless of scopes.\n\n2009-04-15  Vincent Celier  <celier@adacore.com>\n\n\t* prj-nmsc.adb (Get_Directories): Check for sources before checking\n\tthe object directory as when there are no sources, they may not be any\n\tobject directory.\n\n\t* make.adb (Gnatmake): Do not attempt to get the path name of the exec\n\tdirectory, when there are no exec directory.\n\n2009-04-15  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_type.adb (Remove_Conversions): In order to resolve spurious\n\tambiguities, refine removal of universal interpretations from complex\n\texpressions with literal arguments, when some numeric operators have\n\tbeen declared abstract.\n\n2009-04-15  Ed Falis  <falis@adacore.com>\n\n\t* init.c: Map SIGSEGV to Storage_Error for all targets for uniformity\n\tand backward compatibility for targets using probing for stack overflow\n\n2009-04-15  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma, case 'Obsolescent): Pragma is legal\n\tafter any declaration, including renaming declarations.\n\nFrom-SVN: r146091", "tree": {"sha": "d8a346fa47ffce2855ae47458ed9f8678fe6c311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8a346fa47ffce2855ae47458ed9f8678fe6c311"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7ca1d041c1766a16a016d959395370bea93d069", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7ca1d041c1766a16a016d959395370bea93d069", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7ca1d041c1766a16a016d959395370bea93d069", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7ca1d041c1766a16a016d959395370bea93d069/comments", "author": null, "committer": null, "parents": [{"sha": "4bffd4e061048a522f8080b2ad54bc35a658c5e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bffd4e061048a522f8080b2ad54bc35a658c5e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bffd4e061048a522f8080b2ad54bc35a658c5e1"}], "stats": {"total": 449, "additions": 260, "deletions": 189}, "files": [{"sha": "4400d98ce26a07d873b9cd0eb6cf1f3d560ccf7c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ca1d041c1766a16a016d959395370bea93d069/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ca1d041c1766a16a016d959395370bea93d069/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f7ca1d041c1766a16a016d959395370bea93d069", "patch": "@@ -1,3 +1,34 @@\n+2009-04-15  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Use_One_Type): If both clauses appear on the same unit,\n+\tthe second is redundant, regardless of scopes.\n+\n+2009-04-15  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-nmsc.adb (Get_Directories): Check for sources before checking\n+\tthe object directory as when there are no sources, they may not be any\n+\tobject directory.\n+\n+\t* make.adb (Gnatmake): Do not attempt to get the path name of the exec\n+\tdirectory, when there are no exec directory.\n+\n+2009-04-15  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_type.adb (Remove_Conversions): In order to resolve spurious\n+\tambiguities, refine removal of universal interpretations from complex\n+\texpressions with literal arguments, when some numeric operators have\n+\tbeen declared abstract.\n+\n+2009-04-15  Ed Falis  <falis@adacore.com>\n+\n+\t* init.c: Map SIGSEGV to Storage_Error for all targets for uniformity\n+\tand backward compatibility for targets using probing for stack overflow\n+\n+2009-04-15  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma, case 'Obsolescent): Pragma is legal\n+\tafter any declaration, including renaming declarations.\n+\n 2009-04-15  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gcc-interface/Make-lang.in: Update dependencies."}, {"sha": "8476daca115dc2e69a9da4aadca60f309dc8b4e1", "filename": "gcc/ada/init.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ca1d041c1766a16a016d959395370bea93d069/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ca1d041c1766a16a016d959395370bea93d069/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=f7ca1d041c1766a16a016d959395370bea93d069", "patch": "@@ -1816,7 +1816,7 @@ __gnat_map_signal (int sig)\n       break;\n     case SIGSEGV:\n       exception = &storage_error;\n-      msg = \"SIGSEGV: possible stack overflow\";\n+      msg = \"SIGSEGV\";\n       break;\n     case SIGBUS:\n       exception = &storage_error;\n@@ -1841,7 +1841,7 @@ __gnat_map_signal (int sig)\n #else\n       /* VxWorks 6 kernel mode with probing. SIGBUS for guard page hit */\n     case SIGSEGV:\n-      exception = &program_error;\n+      exception = &storage_error;\n       msg = \"SIGSEGV\";\n       break;\n     case SIGBUS:\n@@ -1857,7 +1857,7 @@ __gnat_map_signal (int sig)\n       msg = \"SIGILL: possible stack overflow\";\n       break;\n     case SIGSEGV:\n-      exception = &program_error;\n+      exception = &storage_error;\n       msg = \"SIGSEGV\";\n       break;\n     case SIGBUS:"}, {"sha": "d7d1e3794bcdb91eb7d64413e61a9886190f9b6b", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ca1d041c1766a16a016d959395370bea93d069/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ca1d041c1766a16a016d959395370bea93d069/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=f7ca1d041c1766a16a016d959395370bea93d069", "patch": "@@ -5718,7 +5718,11 @@ package body Make is\n             end if;\n          end if;\n \n-         if Main_Project /= No_Project then\n+         if Main_Project /= No_Project\n+           and then\n+             Project_Tree.Projects.Table\n+               (Main_Project).Exec_Directory /= No_Path_Information\n+         then\n             declare\n                Exec_File_Name : constant String :=\n                                   Get_Name_String (Executable);"}, {"sha": "8a9a09b8e30ec5b2ab83c5511743284bd6fd24d8", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 144, "deletions": 142, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ca1d041c1766a16a016d959395370bea93d069/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ca1d041c1766a16a016d959395370bea93d069/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=f7ca1d041c1766a16a016d959395370bea93d069", "patch": "@@ -6209,151 +6209,11 @@ package body Prj.Nmsc is\n          Write_Line (\"Starting to look for directories\");\n       end if;\n \n-      --  Check the object directory\n-\n-      pragma Assert (Object_Dir.Kind = Single,\n-                     \"Object_Dir is not a single string\");\n-\n-      --  We set the object directory to its default\n+      --  We set the object directory to its default. It may be set to nil, if\n+      --  there is no sources in the project.\n \n       Data.Object_Directory := Data.Directory;\n \n-      if Object_Dir.Value /= Empty_String then\n-         Get_Name_String (Object_Dir.Value);\n-\n-         if Name_Len = 0 then\n-            Error_Msg\n-              (Project, In_Tree,\n-               \"Object_Dir cannot be empty\",\n-               Object_Dir.Location);\n-\n-         else\n-            --  We check that the specified object directory does exist\n-\n-            Locate_Directory\n-              (Project,\n-               In_Tree,\n-               File_Name_Type (Object_Dir.Value),\n-               Data.Directory.Display_Name,\n-               Data.Object_Directory.Name,\n-               Data.Object_Directory.Display_Name,\n-               Create           => \"object\",\n-               Location         => Object_Dir.Location,\n-               Current_Dir      => Current_Dir,\n-               Externally_Built => Data.Externally_Built);\n-\n-            if Data.Object_Directory = No_Path_Information then\n-\n-               --  The object directory does not exist, report an error if the\n-               --  project is not externally built.\n-\n-               if not Data.Externally_Built then\n-                  Err_Vars.Error_Msg_File_1 :=\n-                    File_Name_Type (Object_Dir.Value);\n-                  Error_Msg\n-                    (Project, In_Tree,\n-                     \"the object directory { cannot be found\",\n-                     Data.Location);\n-               end if;\n-\n-               --  Do not keep a nil Object_Directory. Set it to the specified\n-               --  (relative or absolute) path. This is for the benefit of\n-               --  tools that recover from errors; for example, these tools\n-               --  could create the non existent directory.\n-\n-               Data.Object_Directory.Display_Name :=\n-                 Path_Name_Type (Object_Dir.Value);\n-\n-               if Osint.File_Names_Case_Sensitive then\n-                  Data.Object_Directory.Name :=\n-                    Path_Name_Type (Object_Dir.Value);\n-               else\n-                  Get_Name_String (Object_Dir.Value);\n-                  Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-                  Data.Object_Directory.Name := Name_Find;\n-               end if;\n-            end if;\n-         end if;\n-\n-      elsif Subdirs /= null then\n-         Name_Len := 1;\n-         Name_Buffer (1) := '.';\n-         Locate_Directory\n-           (Project,\n-            In_Tree,\n-            Name_Find,\n-            Data.Directory.Display_Name,\n-            Data.Object_Directory.Name,\n-            Data.Object_Directory.Display_Name,\n-            Create           => \"object\",\n-            Location         => Object_Dir.Location,\n-            Current_Dir      => Current_Dir,\n-            Externally_Built => Data.Externally_Built);\n-      end if;\n-\n-      if Current_Verbosity = High then\n-         if Data.Object_Directory = No_Path_Information then\n-            Write_Line (\"No object directory\");\n-         else\n-            Write_Str (\"Object directory: \"\"\");\n-            Write_Str (Get_Name_String (Data.Object_Directory.Display_Name));\n-            Write_Line (\"\"\"\");\n-         end if;\n-      end if;\n-\n-      --  Check the exec directory\n-\n-      pragma Assert (Exec_Dir.Kind = Single,\n-                     \"Exec_Dir is not a single string\");\n-\n-      --  We set the object directory to its default\n-\n-      Data.Exec_Directory   := Data.Object_Directory;\n-\n-      if Exec_Dir.Value /= Empty_String then\n-         Get_Name_String (Exec_Dir.Value);\n-\n-         if Name_Len = 0 then\n-            Error_Msg\n-              (Project, In_Tree,\n-               \"Exec_Dir cannot be empty\",\n-               Exec_Dir.Location);\n-\n-         else\n-            --  We check that the specified exec directory does exist\n-\n-            Locate_Directory\n-              (Project,\n-               In_Tree,\n-               File_Name_Type (Exec_Dir.Value),\n-               Data.Directory.Display_Name,\n-               Data.Exec_Directory.Name,\n-               Data.Exec_Directory.Display_Name,\n-               Create           => \"exec\",\n-               Location         => Exec_Dir.Location,\n-               Current_Dir      => Current_Dir,\n-               Externally_Built => Data.Externally_Built);\n-\n-            if Data.Exec_Directory = No_Path_Information then\n-               Err_Vars.Error_Msg_File_1 := File_Name_Type (Exec_Dir.Value);\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"the exec directory { cannot be found\",\n-                  Data.Location);\n-            end if;\n-         end if;\n-      end if;\n-\n-      if Current_Verbosity = High then\n-         if Data.Exec_Directory = No_Path_Information then\n-            Write_Line (\"No exec directory\");\n-         else\n-            Write_Str (\"Exec directory: \"\"\");\n-            Write_Str (Get_Name_String (Data.Exec_Directory.Display_Name));\n-            Write_Line (\"\"\"\");\n-         end if;\n-      end if;\n-\n       --  Look for the source directories\n \n       if Current_Verbosity = High then\n@@ -6492,6 +6352,148 @@ package body Prj.Nmsc is\n          end loop;\n       end;\n \n+      --  Check the object directory\n+\n+      pragma Assert (Object_Dir.Kind = Single,\n+                     \"Object_Dir is not a single string\");\n+\n+      if Object_Dir.Value /= Empty_String then\n+         Get_Name_String (Object_Dir.Value);\n+\n+         if Name_Len = 0 then\n+            Error_Msg\n+              (Project, In_Tree,\n+               \"Object_Dir cannot be empty\",\n+               Object_Dir.Location);\n+\n+         else\n+            --  We check that the specified object directory does exist\n+\n+            Locate_Directory\n+              (Project,\n+               In_Tree,\n+               File_Name_Type (Object_Dir.Value),\n+               Data.Directory.Display_Name,\n+               Data.Object_Directory.Name,\n+               Data.Object_Directory.Display_Name,\n+               Create           => \"object\",\n+               Location         => Object_Dir.Location,\n+               Current_Dir      => Current_Dir,\n+               Externally_Built => Data.Externally_Built);\n+\n+            if Data.Object_Directory = No_Path_Information then\n+\n+               --  The object directory does not exist, report an error if the\n+               --  project is not externally built.\n+\n+               if not Data.Externally_Built then\n+                  Err_Vars.Error_Msg_File_1 :=\n+                    File_Name_Type (Object_Dir.Value);\n+                  Error_Msg\n+                    (Project, In_Tree,\n+                     \"the object directory { cannot be found\",\n+                     Data.Location);\n+               end if;\n+\n+               --  Do not keep a nil Object_Directory. Set it to the specified\n+               --  (relative or absolute) path. This is for the benefit of\n+               --  tools that recover from errors; for example, these tools\n+               --  could create the non existent directory.\n+\n+               Data.Object_Directory.Display_Name :=\n+                 Path_Name_Type (Object_Dir.Value);\n+\n+               if Osint.File_Names_Case_Sensitive then\n+                  Data.Object_Directory.Name :=\n+                    Path_Name_Type (Object_Dir.Value);\n+               else\n+                  Get_Name_String (Object_Dir.Value);\n+                  Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n+                  Data.Object_Directory.Name := Name_Find;\n+               end if;\n+            end if;\n+         end if;\n+\n+      elsif Data.Object_Directory /= No_Path_Information and then\n+        Subdirs /= null\n+      then\n+         Name_Len := 1;\n+         Name_Buffer (1) := '.';\n+         Locate_Directory\n+           (Project,\n+            In_Tree,\n+            Name_Find,\n+            Data.Directory.Display_Name,\n+            Data.Object_Directory.Name,\n+            Data.Object_Directory.Display_Name,\n+            Create           => \"object\",\n+            Location         => Object_Dir.Location,\n+            Current_Dir      => Current_Dir,\n+            Externally_Built => Data.Externally_Built);\n+      end if;\n+\n+      if Current_Verbosity = High then\n+         if Data.Object_Directory = No_Path_Information then\n+            Write_Line (\"No object directory\");\n+         else\n+            Write_Str (\"Object directory: \"\"\");\n+            Write_Str (Get_Name_String (Data.Object_Directory.Display_Name));\n+            Write_Line (\"\"\"\");\n+         end if;\n+      end if;\n+\n+      --  Check the exec directory\n+\n+      pragma Assert (Exec_Dir.Kind = Single,\n+                     \"Exec_Dir is not a single string\");\n+\n+      --  We set the object directory to its default\n+\n+      Data.Exec_Directory   := Data.Object_Directory;\n+\n+      if Exec_Dir.Value /= Empty_String then\n+         Get_Name_String (Exec_Dir.Value);\n+\n+         if Name_Len = 0 then\n+            Error_Msg\n+              (Project, In_Tree,\n+               \"Exec_Dir cannot be empty\",\n+               Exec_Dir.Location);\n+\n+         else\n+            --  We check that the specified exec directory does exist\n+\n+            Locate_Directory\n+              (Project,\n+               In_Tree,\n+               File_Name_Type (Exec_Dir.Value),\n+               Data.Directory.Display_Name,\n+               Data.Exec_Directory.Name,\n+               Data.Exec_Directory.Display_Name,\n+               Create           => \"exec\",\n+               Location         => Exec_Dir.Location,\n+               Current_Dir      => Current_Dir,\n+               Externally_Built => Data.Externally_Built);\n+\n+            if Data.Exec_Directory = No_Path_Information then\n+               Err_Vars.Error_Msg_File_1 := File_Name_Type (Exec_Dir.Value);\n+               Error_Msg\n+                 (Project, In_Tree,\n+                  \"the exec directory { cannot be found\",\n+                  Data.Location);\n+            end if;\n+         end if;\n+      end if;\n+\n+      if Current_Verbosity = High then\n+         if Data.Exec_Directory = No_Path_Information then\n+            Write_Line (\"No exec directory\");\n+         else\n+            Write_Str (\"Exec directory: \"\"\");\n+            Write_Str (Get_Name_String (Data.Exec_Directory.Display_Name));\n+            Write_Line (\"\"\"\");\n+         end if;\n+      end if;\n    end Get_Directories;\n \n    ---------------"}, {"sha": "d075a23f0442b59117bce65d75a5ef9a87192263", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 45, "deletions": 34, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ca1d041c1766a16a016d959395370bea93d069/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ca1d041c1766a16a016d959395370bea93d069/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=f7ca1d041c1766a16a016d959395370bea93d069", "patch": "@@ -6130,12 +6130,12 @@ package body Sem_Ch8 is\n \n       Prev_Use   : Node_Id := Empty;\n       Redundant  : Node_Id := Empty;\n-      --  The Use_Clause which is actually redundant. In the simplest case\n-      --  it is Pack itself, but when we compile a body we install its\n-      --  context before that of its spec, in which case it is the use_clause\n-      --  in the spec that will appear to be redundant, and we want the\n-      --  warning to be placed on the body. Similar complications appear when\n-      --  the redundancy is between a child unit and one of its ancestors.\n+      --  The Use_Clause which is actually redundant. In the simplest case it\n+      --  is Pack itself, but when we compile a body we install its context\n+      --  before that of its spec, in which case it is the use_clause in the\n+      --  spec that will appear to be redundant, and we want the warning to be\n+      --  placed on the body. Similar complications appear when the redundancy\n+      --  is between a child unit and one of its ancestors.\n \n    begin\n       Set_Redundant_Use (Clause, True);\n@@ -6149,12 +6149,12 @@ package body Sem_Ch8 is\n \n       if not Is_Compilation_Unit (Current_Scope) then\n \n-         --  If the use_clause is in an inner scope, it is made redundant\n-         --  by some clause in the current context, with one exception:\n-         --  If we're compiling a nested package body, and the use_clause\n-         --  comes from the corresponding spec, the clause is not necessarily\n-         --  fully redundant, so we should not warn.  If a warning was\n-         --  warranted, it would have been given when the spec was processed.\n+         --  If the use_clause is in an inner scope, it is made redundant by\n+         --  some clause in the current context, with one exception: If we're\n+         --  compiling a nested package body, and the use_clause comes from the\n+         --  corresponding spec, the clause is not necessarily fully redundant,\n+         --  so we should not warn. If a warning was warranted, it would have\n+         --  been given when the spec was processed.\n \n          if Nkind (Parent (Decl)) = N_Package_Specification then\n             declare\n@@ -6249,12 +6249,12 @@ package body Sem_Ch8 is\n       elsif Nkind (Unit (Cunit (Current_Sem_Unit))) = N_Package_Declaration\n         and then Present (Parent_Spec (Unit (Cunit (Current_Sem_Unit))))\n       then\n-         --  Use_clause is in child unit of current unit, and the child\n-         --  unit appears in the context of the body of the parent, so it\n-         --  has been installed first, even though it is the redundant one.\n-         --  Depending on their placement in the context, the visible or the\n-         --  private parts of the two units, either might appear as redundant,\n-         --  but the message has to be on the current unit.\n+         --  Use_clause is in child unit of current unit, and the child unit\n+         --  appears in the context of the body of the parent, so it has been\n+         --  installed first, even though it is the redundant one. Depending on\n+         --  their placement in the context, the visible or the private parts\n+         --  of the two units, either might appear as redundant, but the\n+         --  message has to be on the current unit.\n \n          if Get_Source_Unit (Cur_Use) = Current_Sem_Unit then\n             Redundant := Cur_Use;\n@@ -6367,9 +6367,9 @@ package body Sem_Ch8 is\n       if Ekind (S) = E_Void then\n          null;\n \n-      --  Set scope depth if not a non-concurrent type, and we have not\n-      --  yet set the scope depth. This means that we have the first\n-      --  occurrence of the scope, and this is where the depth is set.\n+      --  Set scope depth if not a non-concurrent type, and we have not yet set\n+      --  the scope depth. This means that we have the first occurrence of the\n+      --  scope, and this is where the depth is set.\n \n       elsif (not Is_Type (S) or else Is_Concurrent_Type (S))\n         and then not Scope_Depth_Set (S)\n@@ -6427,9 +6427,9 @@ package body Sem_Ch8 is\n          Write_Eol;\n       end if;\n \n-      --  Deal with copying flags from the previous scope to this one. This\n-      --  is not necessary if either scope is standard, or if the new scope\n-      --  is a child unit.\n+      --  Deal with copying flags from the previous scope to this one. This is\n+      --  not necessary if either scope is standard, or if the new scope is a\n+      --  child unit.\n \n       if S /= Standard_Standard\n         and then Scope (S) /= Standard_Standard\n@@ -6711,6 +6711,7 @@ package body Sem_Ch8 is\n                   if not From_With_Type (E) then\n                      Set_Is_Immediately_Visible (E,\n                        Is_Visible_Child_Unit (E) or else In_Open_Scopes (E));\n+\n                   else\n                      pragma Assert\n                        (Nkind (Parent (E)) = N_Defining_Program_Unit_Name\n@@ -7124,10 +7125,10 @@ package body Sem_Ch8 is\n       elsif In_Open_Scopes (Scope (T)) then\n          null;\n \n-      --  A limited view cannot appear in a use_type clause. However, an\n-      --  access type whose designated type is limited has the flag but\n-      --  is not itself a limited view unless we only have a limited view\n-      --  of its enclosing package.\n+      --  A limited view cannot appear in a use_type clause. However, an access\n+      --  type whose designated type is limited has the flag but is not itself\n+      --  a limited view unless we only have a limited view of its enclosing\n+      --  package.\n \n       elsif From_With_Type (T)\n         and then From_With_Type (Scope (T))\n@@ -7172,8 +7173,8 @@ package body Sem_Ch8 is\n          --  as use visible. The analysis then reinstalls the spec along with\n          --  its context. The use clause P.T is now recognized as redundant,\n          --  but in the wrong context. Do not emit a warning in such cases.\n-         --  Do not emit a warning either if we are in an instance, there\n-         --  is no redundancy between an outer use_clause and one that appears\n+         --  Do not emit a warning either if we are in an instance, there is\n+         --  no redundancy between an outer use_clause and one that appears\n          --  within the generic.\n \n         and then not Spec_Reloaded_For_Body\n@@ -7219,10 +7220,10 @@ package body Sem_Ch8 is\n                --  Start of processing for Use_Clause_Known\n \n                begin\n-                  --  If both current use type clause and the use type\n-                  --  clause for the type are at the compilation unit level,\n-                  --  one of the units must be an ancestor of the other, and\n-                  --  the warning belongs on the descendant.\n+                  --  If both current use type clause and the use type clause\n+                  --  for the type are at the compilation unit level, one of\n+                  --  the units must be an ancestor of the other, and the\n+                  --  warning belongs on the descendant.\n \n                   if Nkind (Parent (Clause1)) = N_Compilation_Unit\n                        and then\n@@ -7240,6 +7241,16 @@ package body Sem_Ch8 is\n                      Unit1 := Unit (Parent (Clause1));\n                      Unit2 := Unit (Parent (Clause2));\n \n+                     --  If both clauses are on same unit, report redundancy\n+\n+                     if Unit1 = Unit2 then\n+                        Error_Msg_Sloc := Sloc (Current_Use_Clause (T));\n+                        Error_Msg_NE\n+                          (\"& is already use-visible through previous \"\n+                           & \"use_type_clause #?\", Clause1, T);\n+                        return;\n+                     end if;\n+\n                      --  There is a redundant use type clause in a child unit.\n                      --  Determine which of the units is more deeply nested.\n                      --  If a unit is a package instance, retrieve the entity"}, {"sha": "37b6727dc045f0d2ae1767924db46bfd897d8eb4", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ca1d041c1766a16a016d959395370bea93d069/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ca1d041c1766a16a016d959395370bea93d069/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=f7ca1d041c1766a16a016d959395370bea93d069", "patch": "@@ -9229,6 +9229,7 @@ package body Sem_Prag is\n                if Nkind (Decl) not in N_Declaration\n                  and then Nkind (Decl) not in N_Later_Decl_Item\n                  and then Nkind (Decl) not in N_Generic_Declaration\n+                 and then Nkind (Decl) not in N_Renaming_Declaration\n                then\n                   Error_Pragma\n                     (\"pragma% misplaced, \""}, {"sha": "1e909a2e8f84077d0b31f46f2f81d986013cb36d", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ca1d041c1766a16a016d959395370bea93d069/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ca1d041c1766a16a016d959395370bea93d069/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=f7ca1d041c1766a16a016d959395370bea93d069", "patch": "@@ -885,7 +885,7 @@ package body Sem_Type is\n       then\n          return True;\n \n-      --  An aggregate is compatible with an array or record type\n+      --  An aggregate is compatible with an array or record type.\n \n       elsif T2 = Any_Composite\n         and then Ekind (T1) in E_Array_Type .. E_Record_Subtype\n@@ -1423,15 +1423,37 @@ package body Sem_Type is\n                   end if;\n \n                elsif Is_Numeric_Type (Etype (F1))\n-                 and then\n-                   (Has_Abstract_Interpretation (Act1)\n-                     or else Has_Abstract_Interpretation (Act2))\n+                 and then Has_Abstract_Interpretation (Act1)\n                then\n-                  if It = Disambiguate.It1 then\n-                     return Disambiguate.It2;\n-                  elsif It = Disambiguate.It2 then\n-                     return Disambiguate.It1;\n-                  end if;\n+\n+                  --  Current interpretation is not the right one because\n+                  --  it expects a numeric operand. Examine all the other\n+                  --  ones.\n+\n+                  declare\n+                     I : Interp_Index;\n+                     It : Interp;\n+\n+                  begin\n+                     Get_First_Interp (N, I, It);\n+\n+                     while Present (It.Typ) loop\n+                        if\n+                          not Is_Numeric_Type (Etype (First_Formal (It.Nam)))\n+                        then\n+                           if No (Act2)\n+                             or else not Has_Abstract_Interpretation (Act2)\n+                             or else not Is_Numeric_Type\n+                               (Etype (Next_Formal (First_Formal (It.Nam))))\n+                           then\n+                              return It;\n+                           end if;\n+                        end if;\n+                        Get_Next_Interp (I, It);\n+                     end loop;\n+\n+                     return No_Interp;\n+                  end;\n                end if;\n             end if;\n "}]}