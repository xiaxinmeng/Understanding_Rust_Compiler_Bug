{"sha": "31f8e4f306e9ef25c534afb1601fb9547801ae90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFmOGU0ZjMwNmU5ZWYyNWM1MzRhZmIxNjAxZmI5NTQ3ODAxYWU5MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-06-23T01:14:40Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-23T01:14:40Z"}, "message": "cp-tree.h (BV_USE_VCALL_INDEX_P): New macro.\n\n\t* cp-tree.h (BV_USE_VCALL_INDEX_P): New macro.\n\t(BV_GENERATE_THUNK_WITH_VTABLE_P): Likewise.\n\t(lang_decl_flags): Add generate_with_vtable_p.  Make vcall_offset\n\ta tree, not an int.\n\t(THUNK_GENERATE_WITH_VTABLE_P): New macro.\n\t(make_thunk): Change prototype.\n\t(emit_thunk): Rename to use_thunk.\n\t(mangle_thunk): Change prototype.\n\t* class.c (get_derived_offset): Simplify.\n\t(copy_virtuals): Clear BV_USE_VCALL_INDEX_P and\n\tBV_GENERATE_THUNK_WITH_VTABLE_P.\n\t(build_primary_vtable): Simplify.\n\t(add_virtual_function): Use BV_FN, rather than TREE_VALUE.\n\t(dfs_find_base): Remove.\n\t(update_vtable_entry_for_fn): Correct bug in finding the base\n\twhere a virtual function was first declared.  Figure out whether\n\tor not to emit a vcall-thunk with the vtables in which it appears.\n\tCorrect logic for deciding whether to use an ordinary thunk, or a\n\tvcall thunk.\n\t(finish_struct_1): Remove unnecssary code.\n\t(build_vtbl_initializer): Use ssize_int for the running counter of\n\tnegative indices.\n\t(build_vtbl_initializer): Only use vcall thunks where necessary.\n\tMark thunks as needing to be emitted with their vtables, or not.\n\t(build_vbase_offset_vtbl_entries): Adjust for use of ssize_int in\n\tindices.  Use size_binop.\n\t(dfs_build_vcall_offset_vtbl_entries): Don't rely on\n\tBINFO_PRIMARY_MARKED_P here.  Use BV_FN consistently.  Use\n\tsize_binop.\n\t(build_rtti_vtbl_entries): Adjust call to build_vtable_entry.\n\t(build_vtable_entry): Mark thunks as needing to be emitted with\n\ttheir vtables, or not.\n\t* decl.c (lang_mark_tree): Mark the vcall_offset in a thunk.\n\t* decl2.c (mark_vtable_entries): Use use_thunk instead of\n\temit_thunk.\n\t* dump.c (dequeue_and_dump): Remove dead code.  Dump new thunk\n\tinformation.\n\t* error.c (dump_expr): Use BV_FN.\n\t* mangle.c (mangle_thunk): Adjust now that vcall_offset is a tree,\n\tnot an int.\n\t* method.c (make_thunk): Likewise.\n\t(emit_thunk): Rename to use_thunk.  Allow callers to decide\n\twhether or not to actually emit the thunk.  Adjust for changes in\n\trepresentation of vcall offsets.\n\t* search.c (dfs_get_pure_virtuals): Use BV_FN.\n\t* semantics.c (emit_associated_thunks): New function.\n\t(expand_body): Use it.\n\t* ir.texi: Adjust decriptions of thunks.\n\nFrom-SVN: r34656", "tree": {"sha": "d353106ea48473adbbbe826b110e6044aa4595b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d353106ea48473adbbbe826b110e6044aa4595b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31f8e4f306e9ef25c534afb1601fb9547801ae90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31f8e4f306e9ef25c534afb1601fb9547801ae90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31f8e4f306e9ef25c534afb1601fb9547801ae90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31f8e4f306e9ef25c534afb1601fb9547801ae90/comments", "author": null, "committer": null, "parents": [{"sha": "11fc1858a0850253a8487eae391b9ea3fd24ea5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11fc1858a0850253a8487eae391b9ea3fd24ea5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11fc1858a0850253a8487eae391b9ea3fd24ea5d"}], "stats": {"total": 507, "additions": 356, "deletions": 151}, "files": [{"sha": "0cebeac3dc9b5b15ced851a3caa69c3ce3c112c6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=31f8e4f306e9ef25c534afb1601fb9547801ae90", "patch": "@@ -1,3 +1,54 @@\n+2000-06-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (BV_USE_VCALL_INDEX_P): New macro.\n+\t(BV_GENERATE_THUNK_WITH_VTABLE_P): Likewise.\n+\t(lang_decl_flags): Add generate_with_vtable_p.  Make vcall_offset\n+\ta tree, not an int.\n+\t(THUNK_GENERATE_WITH_VTABLE_P): New macro.\n+\t(make_thunk): Change prototype.\n+\t(emit_thunk): Rename to use_thunk.\n+\t(mangle_thunk): Change prototype.\n+\t* class.c (get_derived_offset): Simplify.\n+\t(copy_virtuals): Clear BV_USE_VCALL_INDEX_P and\n+\tBV_GENERATE_THUNK_WITH_VTABLE_P.\n+\t(build_primary_vtable): Simplify.\n+\t(add_virtual_function): Use BV_FN, rather than TREE_VALUE.\n+\t(dfs_find_base): Remove.\n+\t(update_vtable_entry_for_fn): Correct bug in finding the base\n+\twhere a virtual function was first declared.  Figure out whether\n+\tor not to emit a vcall-thunk with the vtables in which it appears.\n+\tCorrect logic for deciding whether to use an ordinary thunk, or a\n+\tvcall thunk.\n+\t(finish_struct_1): Remove unnecssary code.\n+\t(build_vtbl_initializer): Use ssize_int for the running counter of\n+\tnegative indices.\n+\t(build_vtbl_initializer): Only use vcall thunks where necessary.\n+\tMark thunks as needing to be emitted with their vtables, or not.\n+\t(build_vbase_offset_vtbl_entries): Adjust for use of ssize_int in\n+\tindices.  Use size_binop.\n+\t(dfs_build_vcall_offset_vtbl_entries): Don't rely on\n+\tBINFO_PRIMARY_MARKED_P here.  Use BV_FN consistently.  Use\n+\tsize_binop.\n+\t(build_rtti_vtbl_entries): Adjust call to build_vtable_entry.\n+\t(build_vtable_entry): Mark thunks as needing to be emitted with\n+\ttheir vtables, or not.\n+\t* decl.c (lang_mark_tree): Mark the vcall_offset in a thunk.\n+\t* decl2.c (mark_vtable_entries): Use use_thunk instead of\n+\temit_thunk.\n+\t* dump.c (dequeue_and_dump): Remove dead code.  Dump new thunk\n+\tinformation.\n+\t* error.c (dump_expr): Use BV_FN.\n+\t* mangle.c (mangle_thunk): Adjust now that vcall_offset is a tree,\n+\tnot an int.\n+\t* method.c (make_thunk): Likewise.\n+\t(emit_thunk): Rename to use_thunk.  Allow callers to decide\n+\twhether or not to actually emit the thunk.  Adjust for changes in\n+\trepresentation of vcall offsets.\n+\t* search.c (dfs_get_pure_virtuals): Use BV_FN.\n+\t* semantics.c (emit_associated_thunks): New function.\n+\t(expand_body): Use it.\n+\t* ir.texi: Adjust decriptions of thunks.\n+\t\n 2000-06-22  Jason Merrill  <jason@redhat.com>\n \n \t* pt.c (tsubst_decl, case FUNCTION_DECL): Clear DECL_SAVED_TREE."}, {"sha": "71a5aef57cf07c9a8e89cec8f5c32e418fca9ee1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 118, "deletions": 90, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=31f8e4f306e9ef25c534afb1601fb9547801ae90", "patch": "@@ -96,7 +96,7 @@ varray_type local_classes;\n static tree get_vfield_name PARAMS ((tree));\n static void finish_struct_anon PARAMS ((tree));\n static tree build_vbase_pointer PARAMS ((tree, tree));\n-static tree build_vtable_entry PARAMS ((tree, tree, tree));\n+static tree build_vtable_entry PARAMS ((tree, tree, tree, int));\n static tree get_vtable_name PARAMS ((tree));\n static tree get_derived_offset PARAMS ((tree, tree));\n static tree get_basefndecls PARAMS ((tree, tree));\n@@ -162,7 +162,6 @@ static void build_vcall_offset_vtbl_entries PARAMS ((tree, vcall_offset_data *))\n static void layout_vtable_decl PARAMS ((tree, int));\n static tree dfs_find_final_overrider PARAMS ((tree, void *));\n static tree find_final_overrider PARAMS ((tree, tree, tree));\n-static tree dfs_find_base PARAMS ((tree, void *));\n static int make_new_vtable PARAMS ((tree, tree));\n static void dump_class_hierarchy_r PARAMS ((tree, tree, int));\n extern void dump_class_hierarchy PARAMS ((tree));\n@@ -685,16 +684,9 @@ get_derived_offset (binfo, type)\n {\n   tree offset1 = get_vfield_offset (TYPE_BINFO (BINFO_TYPE (binfo)));\n   tree offset2;\n-  int i;\n \n-  while (BINFO_BASETYPES (binfo)\n-\t && (i = CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo))) != -1)\n-    {\n-      tree binfos = BINFO_BASETYPES (binfo);\n-      if (BINFO_TYPE (binfo) == type)\n-\tbreak;\n-      binfo = TREE_VEC_ELT (binfos, i);\n-    }\n+  while (!same_type_p (BINFO_TYPE (binfo), type))\n+    binfo = BINFO_PRIMARY_BINFO (binfo);\n \n   offset2 = get_vfield_offset (TYPE_BINFO (BINFO_TYPE (binfo)));\n   return size_binop (MINUS_EXPR, offset1, offset2);\n@@ -778,7 +770,11 @@ copy_virtuals (binfo)\n \n   copies = copy_list (BINFO_VIRTUALS (binfo));\n   for (t = copies; t; t = TREE_CHAIN (t))\n-    BV_VCALL_INDEX (t) = NULL_TREE;\n+    {\n+      BV_VCALL_INDEX (t) = NULL_TREE;\n+      BV_USE_VCALL_INDEX_P (t) = 0;\n+      BV_GENERATE_THUNK_WITH_VTABLE_P (t) = 0;\n+    }\n \n   return copies;\n }\n@@ -793,7 +789,8 @@ static int\n build_primary_vtable (binfo, type)\n      tree binfo, type;\n {\n-  tree virtuals, decl;\n+  tree decl;\n+  tree virtuals;\n \n   decl = get_vtable_decl (type, /*complete=*/0);\n   \n@@ -825,9 +822,7 @@ build_primary_vtable (binfo, type)\n      on our first approximation.  */\n   TYPE_BINFO_VTABLE (type) = decl;\n   TYPE_BINFO_VIRTUALS (type) = virtuals;\n-\n-  binfo = TYPE_BINFO (type);\n-  SET_BINFO_NEW_VTABLE_MARKED (binfo, type);\n+  SET_BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (type), type);\n   return 1;\n }\n \n@@ -1126,7 +1121,8 @@ add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n     /* We've already dealt with this function.  */\n     return;\n \n-  new_virtual = build_tree_list (NULL_TREE, fndecl);\n+  new_virtual = make_node (TREE_LIST);\n+  BV_FN (new_virtual) = fndecl;\n   BV_DELTA (new_virtual) = integer_zero_node;\n \n   if (DECL_VINDEX (fndecl) == error_mark_node)\n@@ -2590,18 +2586,6 @@ find_final_overrider (t, binfo, fn)\n   return build_tree_list (ffod.overriding_fn, ffod.overriding_base);\n }\n \n-/* Called via dfs_walk.  Returns BINFO if BINFO has the same type as\n-   DATA (which is really an _TYPE node).  */\n-\n-static tree\n-dfs_find_base (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  return (same_type_p (BINFO_TYPE (binfo), (tree) data)\n-\t  ? binfo : NULL_TREE);\n-}\n-\n /* Update a entry in the vtable for BINFO, which is in the hierarchy\n    dominated by T.  FN has been overridden in BINFO; VIRTUALS points\n    to the corresponding position in the BINFO_VIRTUALS list.  */\n@@ -2615,26 +2599,36 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n {\n   tree b;\n   tree overrider;\n-  tree vindex;\n   tree delta;\n-  HOST_WIDE_INT vindex_val;\n-  HOST_WIDE_INT i;\n+  tree virtual_base;\n+  int generate_thunk_with_vtable_p;\n \n   /* Find the function which originally caused this vtable\n      entry to be present.  */\n-  vindex = DECL_VINDEX (fn);\n-  b = dfs_walk (binfo, dfs_find_base, NULL, DECL_VIRTUAL_CONTEXT (fn));\n-  fn = BINFO_VIRTUALS (TYPE_BINFO (BINFO_TYPE (b)));\n-  i = first_vfun_index (BINFO_TYPE (b));\n-  vindex_val = tree_low_cst (vindex, 0);\n-  while (i < vindex_val)\n+  b = binfo;\n+  while (1)\n     {\n-      fn = TREE_CHAIN (fn);\n-      ++i;\n+      tree primary_base;\n+      tree f;\n+\n+      primary_base = BINFO_PRIMARY_BINFO (b);\n+      if (!primary_base)\n+\tbreak;\n+\n+      for (f = BINFO_VIRTUALS (TYPE_BINFO (BINFO_TYPE (primary_base)));\n+\t   f;\n+\t   f = TREE_CHAIN (f))\n+\tif (same_signature_p (BV_FN (f), fn))\n+\t  break;\n+\n+      if (!f)\n+\tbreak;\n+\n+      fn = BV_FN (f);\n+      b = primary_base;\n     }\n-  fn = BV_FN (fn);\n \n-  /* Handle the case of a virtual function defined in BINFO itself.  */\n+  /* Find the final overrider.  */\n   overrider = find_final_overrider (t, b, fn);\n   if (overrider == error_mark_node)\n     return;\n@@ -2646,27 +2640,53 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n \t\t      get_derived_offset (binfo,\n \t\t\t\t\t  DECL_VIRTUAL_CONTEXT (fn)),\n \t\t      BINFO_OFFSET (binfo));\n+\n+  /* Assume that we will produce a thunk that convert all the way to\n+     the final overrider, and not to an intermediate virtual base.  */\n+  virtual_base  = NULL_TREE;\n+\n+  /* Assume that we will always generate thunks with the vtables that\n+     reference them.  */\n+  generate_thunk_with_vtable_p = 1;\n+\n+  /* Under the new ABI, we will convert to an intermediate virtual\n+     base first, and then use the vcall offset located there to finish\n+     the conversion.  */\n   if (flag_new_abi)\n     {\n-      /* Under the new ABI, we only need to adjust as far as the\n-\t nearest virtual base.  Then we use the vcall offset in the\n-\t virtual bases vtable.  */\n-      for (b = binfo; b; b = BINFO_INHERITANCE_CHAIN (b))\n+      while (b)\n \t{\n-\t  if (TREE_VIA_VIRTUAL (b))\n-\t    break;\n+\t  /* If we find BINFO, then the final overrider is in a class\n+\t     derived from BINFO, so the thunks can be generated with\n+\t     the final overrider.  */\n+\t  if (same_type_p (BINFO_TYPE (b), BINFO_TYPE (binfo)))\n+\t    generate_thunk_with_vtable_p = 0;\n+\n+\t  /* If we find the final overrider, then we can stop\n+\t     walking.  */\n \t  if (same_type_p (BINFO_TYPE (b), \n \t\t\t   BINFO_TYPE (TREE_VALUE (overrider))))\n \t    break;\n+\n+\t  /* If we find a virtual base, and we haven't yet found the\n+\t     overrider, then there is a virtual base between the\n+\t     declaring base and the final overrider.  */\n+\t  if (!virtual_base && TREE_VIA_VIRTUAL (b))\n+\t    {\n+\t      generate_thunk_with_vtable_p = 1;\n+\t      virtual_base = b;\n+\t    }\n+\n+\t  b = BINFO_INHERITANCE_CHAIN (b);\n \t}\n     }\n   else\n-    b = NULL_TREE;\n+    virtual_base = NULL_TREE;\n \n-  if (b && TREE_VIA_VIRTUAL (b))\n+  if (virtual_base)\n     /* The `this' pointer needs to be adjusted to the nearest virtual\n        base.  */\n-    delta = size_diffop (BINFO_OFFSET (b), delta);\n+    delta = size_diffop (BINFO_OFFSET (virtual_base), delta);\n   else\n     /* The `this' pointer needs to be adjusted from pointing to\n        BINFO to pointing at the base where the final overrider\n@@ -2678,6 +2698,11 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n \t\t       TREE_PURPOSE (overrider),\n \t\t       delta,\n \t\t       virtuals);\n+\n+  if (virtual_base)\n+    BV_USE_VCALL_INDEX_P (*virtuals) = 1;\n+  if (generate_thunk_with_vtable_p)\n+    BV_GENERATE_THUNK_WITH_VTABLE_P (*virtuals) = 1;\n }\n \n /* Called from modify_all_vtables via dfs_walk.  */\n@@ -5074,17 +5099,9 @@ finish_struct_1 (t)\n     {\n       tree binfo = CLASSTYPE_PRIMARY_BINFO (t);\n \n-      /* This class contributes nothing new to the virtual function\n-\t table.  However, it may have declared functions which\n-\t went into the virtual function table \"inherited\" from the\n-\t base class.  If so, we grab a copy of those updated functions,\n-\t and pretend they are ours.  */\n-\n-      /* See if we should steal the virtual info from base class.  */\n-      if (TYPE_BINFO_VTABLE (t) == NULL_TREE)\n-\tTYPE_BINFO_VTABLE (t) = BINFO_VTABLE (binfo);\n-      if (TYPE_BINFO_VIRTUALS (t) == NULL_TREE)\n-\tTYPE_BINFO_VIRTUALS (t) = BINFO_VIRTUALS (binfo);\n+      /* If this class uses a different vtable than its primary base\n+\t then when we will need to initialize our vptr after the base\n+\t class constructor runs.  */\n       if (TYPE_BINFO_VTABLE (t) != BINFO_VTABLE (binfo))\n \tCLASSTYPE_NEEDS_VIRTUAL_REINIT (t) = 1;\n     }\n@@ -6992,7 +7009,7 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n   vod.last_init = &vod.inits;\n   vod.primary_p = (binfo == TYPE_BINFO (t));\n   /* The first vbase or vcall offset is at index -3 in the vtable.  */\n-  vod.index = build_int_2 (-3, -1);\n+  vod.index = ssize_int (-3);\n \n   /* Add entries to the vtable for RTTI.  */\n   build_rtti_vtbl_entries (binfo, rtti_binfo, &vod);\n@@ -7023,7 +7040,15 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n       /* Pull the offset for `this', and the function to call, out of\n \t the list.  */\n       delta = BV_DELTA (v);\n-      vcall_index = BV_VCALL_INDEX (v);\n+\n+      if (BV_USE_VCALL_INDEX_P (v))\n+\t{\n+\t  vcall_index = BV_VCALL_INDEX (v);\n+\t  my_friendly_assert (vcall_index != NULL_TREE, 20000621);\n+\t}\n+      else\n+\tvcall_index = NULL_TREE;\n+\n       fn = BV_FN (v);\n       my_friendly_assert (TREE_CODE (delta) == INTEGER_CST, 19990727);\n       my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 19990727);\n@@ -7039,7 +7064,8 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n       /* The address of a function can't change.  */\n       TREE_CONSTANT (pfn) = 1;\n       /* Enter it in the vtable.  */\n-      init = build_vtable_entry (delta, vcall_index, pfn);\n+      init = build_vtable_entry (delta, vcall_index, pfn,\n+\t\t\t\t BV_GENERATE_THUNK_WITH_VTABLE_P (v));\n       /* And add it to the chain of initializers.  */\n       vfun_inits = tree_cons (NULL_TREE, init, vfun_inits);\n     }\n@@ -7125,7 +7151,7 @@ build_vbase_offset_vtbl_entries (binfo, vod)\n \n       /* Figure out where we can find this vbase offset.  */\n       delta = size_binop (MULT_EXPR, \n-\t\t\t  convert (ssizetype, vod->index),\n+\t\t\t  vod->index,\n \t\t\t  convert (ssizetype,\n \t\t\t\t   TYPE_SIZE_UNIT (vtable_entry_type)));\n       if (vod->primary_p)\n@@ -7146,8 +7172,7 @@ build_vbase_offset_vtbl_entries (binfo, vod)\n \t}\n \n       /* The next vbase will come at a more negative offset.  */\n-      vod->index = fold (build (MINUS_EXPR, integer_type_node,\n-\t\t\t\tvod->index, integer_one_node));\n+      vod->index = size_binop (MINUS_EXPR, vod->index, ssize_int (1));\n \n       /* The initializer is the delta from BINFO to this virtual base.\n \t The vbase offsets go in reverse inheritance-graph order, and\n@@ -7174,8 +7199,11 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n   tree derived_virtuals;\n   tree base_virtuals;\n   tree binfo_inits;\n+  /* If BINFO is a primary base, this is the least derived class of\n+     BINFO that is not a primary base.  */\n   tree non_primary_binfo;\n-  tree b;\n+  /* The primary base of BINFO.  */\n+  tree primary_binfo;\n   int i;\n \n   vod = (vcall_offset_data *) data;\n@@ -7185,16 +7213,21 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n      hierarchy until we find the class of which we are a primary base:\n      it is the BINFO_VIRTUALS there that we need to consider.  */\n   non_primary_binfo = binfo;\n-  while (BINFO_PRIMARY_MARKED_P (non_primary_binfo))\n-    non_primary_binfo = BINFO_INHERITANCE_CHAIN (non_primary_binfo);\n+  while (BINFO_INHERITANCE_CHAIN (non_primary_binfo))\n+    {\n+      tree b = BINFO_INHERITANCE_CHAIN (non_primary_binfo);\n+      if (BINFO_PRIMARY_BINFO (b) != non_primary_binfo)\n+\tbreak;\n+      non_primary_binfo = b;\n+    }\n \n   /* Skip virtuals that we have already handled in a primary base\n      class.  */\n   base_virtuals = BINFO_VIRTUALS (binfo);\n   derived_virtuals = BINFO_VIRTUALS (non_primary_binfo);\n-  b = BINFO_PRIMARY_BINFO (binfo);\n-  if (b)\n-    for (i = 0; i < CLASSTYPE_VSIZE (BINFO_TYPE (b)); ++i)\n+  primary_binfo = BINFO_PRIMARY_BINFO (binfo);\n+  if (primary_binfo)\n+    for (i = 0; i < CLASSTYPE_VSIZE (BINFO_TYPE (primary_binfo)); ++i)\n       {\n \tbase_virtuals = TREE_CHAIN (base_virtuals);\n \tderived_virtuals = TREE_CHAIN (derived_virtuals);\n@@ -7206,7 +7239,7 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n \t base_virtuals = TREE_CHAIN (base_virtuals))\n     {\n       /* Figure out what function we're looking at.  */\n-      tree fn = TREE_VALUE (derived_virtuals);\n+      tree fn = BV_FN (derived_virtuals);\n       tree base;\n       tree base_binfo;\n       size_t i;\n@@ -7220,7 +7253,7 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n \t  tree derived_entry;\n \n \t  derived_entry = VARRAY_TREE (vod->fns, i);\n-\t  if (same_signature_p (TREE_VALUE (derived_entry), fn))\n+\t  if (same_signature_p (BV_FN (derived_entry), fn))\n \t    {\n \t      BV_VCALL_INDEX (derived_virtuals) \n \t\t= BV_VCALL_INDEX (derived_entry);\n@@ -7259,8 +7292,7 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n \n       /* The next vcall offset will be found at a more negative\n \t offset.  */\n-      vod->index = fold (build (MINUS_EXPR, integer_type_node,\n-\t\t\t\tvod->index, integer_one_node));\n+      vod->index = size_binop (MINUS_EXPR, vod->index, ssize_int (1));\n \n       /* Keep track of this function.  */\n       VARRAY_PUSH_TREE (vod->fns, derived_virtuals);\n@@ -7383,7 +7415,8 @@ build_rtti_vtbl_entries (binfo, rtti_binfo, vod)\n \t vtable.  */\n       init = build1 (ADDR_EXPR, vfunc_ptr_type_node, decl);\n       TREE_CONSTANT (init) = 1;\n-      init = build_vtable_entry (offset, integer_zero_node, init);\n+      init = build_vtable_entry (offset, NULL_TREE, init, \n+\t\t\t\t /*generate_with_vtable_p=*/0);\n     }\n   *vod->last_init = build_tree_list (NULL_TREE, init);\n   vod->last_init = &TREE_CHAIN (*vod->last_init);\n@@ -7410,28 +7443,23 @@ build_rtti_vtbl_entries (binfo, rtti_binfo, vod)\n    ABI.)  */\n \n static tree\n-build_vtable_entry (delta, vcall_index, entry)\n+build_vtable_entry (delta, vcall_index, entry, generate_with_vtable_p)\n      tree delta;\n      tree vcall_index;\n      tree entry;\n+     int generate_with_vtable_p;\n {\n-  if (!vcall_index)\n-    vcall_index = integer_zero_node;\n-\n   if (flag_vtable_thunks)\n     {\n-      HOST_WIDE_INT idelta;\n-      HOST_WIDE_INT ivindex;\n       tree fn;\n \n-      idelta = tree_low_cst (delta, 0);\n-      ivindex = tree_low_cst (vcall_index, 0);\n       fn = TREE_OPERAND (entry, 0);\n-      if ((idelta || ivindex) \n+      if ((!integer_zerop (delta) || vcall_index != NULL_TREE)\n \t  && fn != abort_fndecl\n \t  && !DECL_TINFO_FN_P (fn))\n \t{\n-\t  entry = make_thunk (entry, idelta, ivindex);\n+\t  entry = make_thunk (entry, delta, vcall_index,\n+\t\t\t      generate_with_vtable_p);\n \t  entry = build1 (ADDR_EXPR, vtable_entry_type, entry);\n \t  TREE_READONLY (entry) = 1;\n \t  TREE_CONSTANT (entry) = 1;\n@@ -7449,7 +7477,7 @@ build_vtable_entry (delta, vcall_index, entry)\n       tree entry = build (CONSTRUCTOR, vtable_entry_type, NULL_TREE, elems);\n \n       /* We don't use vcall offsets when not using vtable thunks.  */\n-      my_friendly_assert (integer_zerop (vcall_index), 20000125);\n+      my_friendly_assert (vcall_index == NULL_TREE, 20000125);\n \n       /* DELTA used to be constructed by `size_int' and/or size_binop,\n \t which caused overflow problems when it was negative.  That should"}, {"sha": "89e637eaa9a51eb8ea2215398a0ad886e1b67760", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=31f8e4f306e9ef25c534afb1601fb9547801ae90", "patch": "@@ -45,6 +45,7 @@ Boston, MA 02111-1307, USA.  */\n       SCOPE_BEGIN_P (in SCOPE_STMT)\n       CTOR_BEGIN_P (in CTOR_STMT)\n       DECL_PRETTY_FUNCTION_P (in VAR_DECL)\n+      BV_USE_VCALL_INDEX_P (in the BINFO_VIRTUALS TREE_LIST)\n    1: IDENTIFIER_VIRTUAL_P.\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -57,6 +58,7 @@ Boston, MA 02111-1307, USA.  */\n       ICS_ELLIPSIS_FLAG (in _CONV)\n       STMT_IS_FULL_EXPR_P (in _STMT)\n       BINFO_ACCESS (in BINFO)\n+      BV_GENERATE_THUNK_WITH_VTABLE_P (in TREE_LIST)\n    2: IDENTIFIER_OPNAME_P.\n       TYPE_POLYMORHPIC_P (in _TYPE)\n       ICS_THIS_FLAG (in _CONV)\n@@ -128,7 +130,9 @@ Boston, MA 02111-1307, USA.  */\n      the this pointer points to an object of the base class.\n \n      The BV_VCALL_INDEX of each node, if non-NULL, gives the vtable\n-     index of the vcall offset for this entry.\n+     index of the vcall offset for this entry.  If\n+     BV_USE_VCALL_INDEX_P then the corresponding vtable entry should\n+     use a virtual thunk, as opposed to an ordinary thunk.\n \n      The BV_FN is the declaration for the virtual function itself.\n      When CLASSTYPE_COM_INTERFACE_P does not hold, the first entry\n@@ -1841,6 +1845,15 @@ struct lang_type\n /* The function to call.  */\n #define BV_FN(NODE) (TREE_VALUE (NODE))\n \n+/* Nonzero if we should use a virtual thunk for this entry.  */\n+#define BV_USE_VCALL_INDEX_P(NODE) \\\n+   (TREE_LANG_FLAG_0 (NODE))\n+\n+/* Nonzero if we should generate this thunk when the vtable that\n+   references it is emitted, rather than with the final overrider.  */\n+#define BV_GENERATE_THUNK_WITH_VTABLE_P(NODE) \\\n+  (TREE_LANG_FLAG_1 (NODE))\n+\n /* The most derived class.  */\n \n \f\n@@ -1901,7 +1914,8 @@ struct lang_decl_flags\n   unsigned tinfo_fn_p : 1;\n   unsigned assignment_operator_p : 1;\n   unsigned anticipated_p : 1;\n-  unsigned dummy : 2;\n+  unsigned generate_with_vtable_p : 1;\n+  unsigned dummy : 1;\n \n   tree context;\n \n@@ -1924,7 +1938,7 @@ struct lang_decl_flags\n \n     /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n        THUNK_VCALL_OFFSET.  */\n-    HOST_WIDE_INT vcall_offset;\n+    tree vcall_offset;\n   } u2;\n };\n \n@@ -3141,6 +3155,10 @@ extern int flag_new_for_scope;\n #define THUNK_VCALL_OFFSET(DECL) \\\n   (DECL_LANG_SPECIFIC (DECL)->decl_flags.u2.vcall_offset)\n \n+/* Nonzero if this thunk should be generated with the vtable that\n+   references it.  */\n+#define THUNK_GENERATE_WITH_VTABLE_P(DECL) \\\n+  (DECL_LANG_SPECIFIC (DECL)->decl_flags.generate_with_vtable_p)\n \n /* These macros provide convenient access to the various _STMT nodes\n    created when parsing template declarations.  */\n@@ -4244,8 +4262,8 @@ extern tree build_overload_with_type\t\tPARAMS ((tree, tree));\n extern tree build_destructor_name\t\tPARAMS ((tree));\n extern tree build_opfncall\t\t\tPARAMS ((enum tree_code, int, tree, tree, tree));\n extern tree hack_identifier\t\t\tPARAMS ((tree, tree));\n-extern tree make_thunk\t\t\t\tPARAMS ((tree, int, int));\n-extern void emit_thunk\t\t\t\tPARAMS ((tree));\n+extern tree make_thunk\t\t\t\tPARAMS ((tree, tree, tree, int));\n+extern void use_thunk\t\t\t\tPARAMS ((tree, int));\n extern void synthesize_method\t\t\tPARAMS ((tree));\n extern tree get_id_2\t\t\t\tPARAMS ((const char *, tree));\n extern tree implicitly_declare_fn               PARAMS ((special_function_kind, tree, int));\n@@ -4718,7 +4736,7 @@ extern tree mangle_typeinfo_string_for_type     PARAMS ((tree));\n extern tree mangle_vtbl_for_type                PARAMS ((tree));\n extern tree mangle_vtt_for_type                 PARAMS ((tree));\n extern tree mangle_ctor_vtbl_for_type           PARAMS ((tree, tree));\n-extern tree mangle_thunk                        PARAMS ((tree, int, int)); \n+extern tree mangle_thunk                        PARAMS ((tree, tree, tree)); \n extern tree mangle_conv_op_name_for_type        PARAMS ((tree));\n extern tree mangle_guard_variable               PARAMS ((tree));\n "}, {"sha": "10d9d08d51d38be4bba22dbcf057a494ff12ce32", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=31f8e4f306e9ef25c534afb1601fb9547801ae90", "patch": "@@ -15063,6 +15063,8 @@ lang_mark_tree (t)\n \t      && !DECL_GLOBAL_DTOR_P (t)\n \t      && !DECL_THUNK_P (t))\n \t    ggc_mark_tree (ld->decl_flags.u2.access);\n+\t  else if (DECL_THUNK_P (t))\n+\t    ggc_mark_tree (ld->decl_flags.u2.vcall_offset);\n \t  ggc_mark_tree (ld->decl_flags.context);\n \t  if (TREE_CODE (t) != NAMESPACE_DECL)\n \t    ggc_mark_tree (ld->decl_flags.u.template_info);"}, {"sha": "8fe160ea889aabac45513e35e74dec88beb6c2c5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=31f8e4f306e9ef25c534afb1601fb9547801ae90", "patch": "@@ -2425,11 +2425,12 @@ mark_vtable_entries (decl)\n \n       fn = TREE_OPERAND (fnaddr, 0);\n       TREE_ADDRESSABLE (fn) = 1;\n-      if (DECL_THUNK_P (fn) && DECL_EXTERNAL (fn))\n-\t{\n-\t  DECL_EXTERNAL (fn) = 0;\n-\t  emit_thunk (fn);\n-\t}\n+      /* When we don't have vcall offsets, we output thunks whenever\n+\t we output the vtables that contain them.  With vcall offsets,\n+\t we know all the thunks we'll need when we emit a virtual\n+\t function, so we emit the thunks there instead.  */\n+      if (DECL_THUNK_P (fn)) \n+\tuse_thunk (fn, THUNK_GENERATE_WITH_VTABLE_P (fn));\n       mark_used (fn);\n     }\n }"}, {"sha": "9b711062070639eb66b2f5298c9269719b44b5bc", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=31f8e4f306e9ef25c534afb1601fb9547801ae90", "patch": "@@ -566,7 +566,7 @@ dequeue_and_dump (di)\n \tdump_string(di, \"extern\");\n       else\n \tdump_string (di, \"static\");\n-      if (TREE_CODE (t) == FUNCTION_DECL)\n+      if (!DECL_THUNK_P (t))\n \t{\n \t  if (DECL_FUNCTION_MEMBER_P (t))\n \t    dump_string (di, \"member\");\n@@ -578,13 +578,6 @@ dequeue_and_dump (di)\n \t    dump_string (di, \"operator\");\n \t  if (DECL_CONV_FN_P (t))\n \t    dump_string (di, \"conversion\");\n-\t  if (DECL_THUNK_P (t))\n-\t    {\n-\t      dump_string (di, \"thunk\");\n-\t      dump_int (di, \"dlta\", THUNK_DELTA (t));\n-\t      dump_int (di, \"vcll\", THUNK_VCALL_OFFSET (t));\n-\t      dump_child (\"fn\", DECL_INITIAL (t));\n-\t    }\n \t  if (DECL_GLOBAL_CTOR_P (t) || DECL_GLOBAL_DTOR_P (t))\n \t    {\n \t      if (DECL_GLOBAL_CTOR_P (t))\n@@ -600,8 +593,10 @@ dequeue_and_dump (di)\n \t}\n       else\n \t{\n+\t  dump_string (di, \"thunk\");\n \t  dump_int (di, \"dlta\", THUNK_DELTA (t));\n-\t  dump_child (\"init\", DECL_INITIAL (t));\n+\t  dump_child (\"vcll\", THUNK_VCALL_OFFSET (t));\n+\t  dump_child (\"fn\", DECL_INITIAL (t));\n \t}\n       break;\n "}, {"sha": "37c8dd625234a4992020d6eba866a3c7434a21d5", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=31f8e4f306e9ef25c534afb1601fb9547801ae90", "patch": "@@ -1867,7 +1867,7 @@ dump_expr (t, flags)\n \t\t}\n \t      if (virtuals)\n \t\t{\n-\t\t  dump_expr (TREE_VALUE (virtuals),\n+\t\t  dump_expr (BV_FN (virtuals),\n \t                     flags | TS_EXPR_PARENS);\n \t\t  break;\n \t\t}"}, {"sha": "343dfc86408d0eadee081857a3698a68e3f31230", "filename": "gcc/cp/ir.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fir.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fir.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fir.texi?ref=31f8e4f306e9ef25c534afb1601fb9547801ae90", "patch": "@@ -1040,8 +1040,8 @@ returning to the thunk.  The first parameter to the thunk is always the\n value.  (The @code{THUNK_DELTA} is an @code{int}, not an\n @code{INTEGER_CST}.)  \n \n-Then, if @code{THUNK_VCALL_OFFSET} (also an @code{int}) is non-zero the\n-adjusted @code{this} pointer must be adjusted again.  The complete\n+Then, if @code{THUNK_VCALL_OFFSET} (an @code{INTEGER_CST}) is non-zero\n+the adjusted @code{this} pointer must be adjusted again.  The complete\n calculation is given by the following pseudo-code:\n \n @example"}, {"sha": "a1d1d552dd08b69b71fbe330db7c8b01a793a8ee", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=31f8e4f306e9ef25c534afb1601fb9547801ae90", "patch": "@@ -2076,7 +2076,7 @@ mangle_ctor_vtbl_for_type (type, binfo)\n \n /* Return an identifier for the mangled name of a thunk to FN_DECL.\n    OFFSET is the initial adjustment to this used to find the vptr.  If\n-   VCALL_OFFSET is non-zero, this is a virtual thunk, and it is the\n+   VCALL_OFFSET is non-NULL, this is a virtual thunk, and it is the\n    vtbl offset in bytes.  \n \n     <special-name> ::= Th <offset number> _ <base encoding>\n@@ -2087,8 +2087,8 @@ mangle_ctor_vtbl_for_type (type, binfo)\n tree\n mangle_thunk (fn_decl, offset, vcall_offset)\n      tree fn_decl;\n-     int offset;\n-     int vcall_offset;\n+     tree offset;\n+     tree vcall_offset;\n {\n   const char *result;\n   \n@@ -2104,14 +2104,14 @@ mangle_thunk (fn_decl, offset, vcall_offset)\n     write_char ('h');\n \n   /* For either flavor, write the offset to this.  */\n-  write_signed_number (offset);\n+  write_integer_cst (offset);\n   write_char ('_');\n \n   /* For a virtual thunk, add the vcall offset.  */\n-  if (vcall_offset != 0)\n+  if (vcall_offset)\n     {\n       /* Virtual thunk.  Write the vcall offset and base type name.  */\n-      write_signed_number (vcall_offset);\n+      write_integer_cst (vcall_offset);\n       write_char ('_');\n     }\n "}, {"sha": "33ad29a8211795e04b510bcebb4ee2cc0d223bc4", "filename": "gcc/cp/method.c", "status": "modified", "additions": 57, "deletions": 29, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=31f8e4f306e9ef25c534afb1601fb9547801ae90", "patch": "@@ -2063,15 +2063,29 @@ hack_identifier (value, name)\n    DELTA is the offset to this and VCALL_INDEX is zero.  */\n \n tree\n-make_thunk (function, delta, vcall_index)\n+make_thunk (function, delta, vcall_index, generate_with_vtable_p)\n      tree function;\n-     int delta;\n-     int vcall_index;\n+     tree delta;\n+     tree vcall_index;\n+     int generate_with_vtable_p;\n {\n   tree thunk_id;\n   tree thunk;\n   tree func_decl;\n-  int vcall_offset = vcall_index * int_size_in_bytes (vtable_entry_type);\n+  tree vcall_offset;\n+  HOST_WIDE_INT d;\n+\n+  /* Scale the VCALL_INDEX to be in terms of bytes.  */\n+  if (vcall_index)\n+    vcall_offset \n+      = size_binop (MULT_EXPR,\n+\t\t    vcall_index,\n+\t\t    convert (ssizetype,\n+\t\t\t     TYPE_SIZE_UNIT (vtable_entry_type)));\n+  else\n+    vcall_offset = NULL_TREE;\n+\n+  d = tree_low_cst (delta, 0);\n \n   if (TREE_CODE (function) != ADDR_EXPR)\n     abort ();\n@@ -2080,22 +2094,23 @@ make_thunk (function, delta, vcall_index)\n     abort ();\n \n   if (flag_new_abi) \n-    thunk_id = mangle_thunk (TREE_OPERAND (function, 0),  delta, vcall_offset);\n+    thunk_id = mangle_thunk (TREE_OPERAND (function, 0), \n+\t\t\t     delta, vcall_offset);\n   else\n     {\n       OB_INIT ();\n       OB_PUTS (\"__thunk_\");\n-      if (delta > 0)\n+      if (d > 0)\n \t{\n \t  OB_PUTC ('n');\n-\t  icat (delta);\n+\t  icat (d);\n \t}\n       else\n-\ticat (-delta);\n+\ticat (-d);\n       OB_PUTC ('_');\n       if (vcall_index)\n \t{\n-\t  icat (vcall_index);\n+\t  icat (tree_low_cst (vcall_index, 0));\n \t  OB_PUTC ('_');\n \t}\n       OB_PUTID (DECL_ASSEMBLER_NAME (func_decl));\n@@ -2121,8 +2136,9 @@ make_thunk (function, delta, vcall_index)\n       comdat_linkage (thunk);\n       SET_DECL_THUNK_P (thunk);\n       DECL_INITIAL (thunk) = function;\n-      THUNK_DELTA (thunk) = delta;\n+      THUNK_DELTA (thunk) = d;\n       THUNK_VCALL_OFFSET (thunk) = vcall_offset;\n+      THUNK_GENERATE_WITH_VTABLE_P (thunk) = generate_with_vtable_p;\n       /* The thunk itself is not a constructor or destructor, even if\n        the thing it is thunking to is.  */\n       DECL_INTERFACE_KNOWN (thunk) = 1;\n@@ -2142,56 +2158,69 @@ make_thunk (function, delta, vcall_index)\n       DECL_DEFERRED_FN (thunk) = 0;\n       /* So that finish_file can write out any thunks that need to be: */\n       pushdecl_top_level (thunk);\n+      /* Create RTL for this thunk so that its address can be taken.  */\n+      make_function_rtl (thunk);\n     }\n   return thunk;\n }\n \n /* Emit the definition of a C++ multiple inheritance vtable thunk.  */\n \n void\n-emit_thunk (thunk_fndecl)\n+use_thunk (thunk_fndecl, emit_p)\n      tree thunk_fndecl;\n+     int emit_p;\n+     \n {\n   tree fnaddr;\n   tree function;\n-  int delta;\n-  int vcall_offset;\n+  tree vcall_offset;\n+  HOST_WIDE_INT delta;\n \n   if (TREE_ASM_WRITTEN (thunk_fndecl))\n     return;\n-\n+  \n+  fnaddr = DECL_INITIAL (thunk_fndecl);\n   if (TREE_CODE (DECL_INITIAL (thunk_fndecl)) != ADDR_EXPR)\n     /* We already turned this thunk into an ordinary function.\n        There's no need to process this thunk again.  (We can't just\n        clear DECL_THUNK_P because that will confuse\n        FNADDR_FROM_VTABLE_ENTRY and friends.)  */\n     return;\n \n-  fnaddr = DECL_INITIAL (thunk_fndecl);\n-  function = TREE_OPERAND (fnaddr, 0);\n-  delta = THUNK_DELTA (thunk_fndecl);\n-  vcall_offset = THUNK_VCALL_OFFSET (thunk_fndecl);\n+  /* Thunks are always addressable; they only appear in vtables.  */\n+  TREE_ADDRESSABLE (thunk_fndecl) = 1;\n \n+  /* Figure out what function is being thunked to.  It's referenced in\n+     this translation unit.  */\n+  function = TREE_OPERAND (fnaddr, 0);\n   TREE_ADDRESSABLE (function) = 1;\n   mark_used (function);\n+  TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (function)) = 1;\n+  if (!emit_p)\n+    return;\n \n-  if (current_function_decl)\n-    abort ();\n+  delta = THUNK_DELTA (thunk_fndecl);\n+  vcall_offset = THUNK_VCALL_OFFSET (thunk_fndecl);\n+\n+  /* And, if we need to emit the thunk, it's used.  */\n+  mark_used (thunk_fndecl);\n+  /* This thunk is actually defined.  */\n+  DECL_EXTERNAL (thunk_fndecl) = 0;\n \n   if (flag_syntax_only)\n     {\n       TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n       return;\n     }\n \n+  push_to_top_level ();\n+\n #ifdef ASM_OUTPUT_MI_THUNK\n-  if (vcall_offset == 0)\n+  if (!vcall_offset)\n     {\n       const char *fnname;\n       current_function_decl = thunk_fndecl;\n-      /* Make sure we build up its RTL before we go onto the\n-\t temporary obstack.  */\n-      make_function_rtl (thunk_fndecl);\n       DECL_RESULT (thunk_fndecl)\n \t= build_decl (RESULT_DECL, 0, integer_type_node);\n       fnname = XSTR (XEXP (DECL_RTL (thunk_fndecl), 0), 0);\n@@ -2230,17 +2259,15 @@ emit_thunk (thunk_fndecl)\n     DECL_ARGUMENTS (thunk_fndecl) = a;\n     DECL_RESULT (thunk_fndecl) = NULL_TREE;\n \n-    push_to_top_level ();\n     start_function (NULL_TREE, thunk_fndecl, NULL_TREE, SF_PRE_PARSED);\n     store_parm_decls ();\n \n     /* Adjust the this pointer by the constant.  */\n     t = ssize_int (delta);\n-    TREE_TYPE (t) = signed_type (sizetype);\n     t = fold (build (PLUS_EXPR, TREE_TYPE (a), a, t));\n     /* If there's a vcall offset, look up that value in the vtable and\n        adjust the `this' pointer again.  */\n-    if (vcall_offset != 0)\n+    if (!integer_zerop (vcall_offset))\n       {\n \ttree orig_this;\n \n@@ -2254,7 +2281,7 @@ emit_thunk (thunk_fndecl)\n \t/* Form the vtable address.  */\n \tt = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (t)), t);\n \t/* Find the entry with the vcall offset.  */\n-\tt = build (PLUS_EXPR, TREE_TYPE (t), t, ssize_int (vcall_offset));\n+\tt = build (PLUS_EXPR, TREE_TYPE (t), t, vcall_offset);\n \t/* Calculate the offset itself.  */\n \tt = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (t)), t);\n \t/* Adjust the `this' pointer.  */\n@@ -2281,8 +2308,9 @@ emit_thunk (thunk_fndecl)\n     BLOCK_VARS (DECL_INITIAL (thunk_fndecl)) \n       = DECL_ARGUMENTS (thunk_fndecl);\n     expand_body (finish_function (0));\n-    pop_from_top_level ();\n   }\n+\n+  pop_from_top_level ();\n }\n \f\n /* Code for synthesizing methods which have default semantics defined.  */"}, {"sha": "78fb5a44e82adb257e1a4e7ee58ed9156ffec36a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=31f8e4f306e9ef25c534afb1601fb9547801ae90", "patch": "@@ -2295,9 +2295,9 @@ dfs_get_pure_virtuals (binfo, data)\n       for (virtuals = BINFO_VIRTUALS (binfo);\n \t   virtuals;\n \t   virtuals = TREE_CHAIN (virtuals))\n-\tif (DECL_PURE_VIRTUAL_P (TREE_VALUE (virtuals)))\n+\tif (DECL_PURE_VIRTUAL_P (BV_FN (virtuals)))\n \t  CLASSTYPE_PURE_VIRTUALS (type) \n-\t    = tree_cons (NULL_TREE, TREE_VALUE (virtuals),\n+\t    = tree_cons (NULL_TREE, BV_FN (virtuals),\n \t\t\t CLASSTYPE_PURE_VIRTUALS (type));\n     }\n   \n@@ -2341,7 +2341,7 @@ get_pure_virtuals (type)\n \t   virtuals;\n \t   virtuals = TREE_CHAIN (virtuals))\n \t{\n-\t  tree base_fndecl = TREE_VALUE (virtuals);\n+\t  tree base_fndecl = BV_FN (virtuals);\n \t  if (DECL_NEEDS_FINAL_OVERRIDER_P (base_fndecl))\n \t    cp_error (\"`%#D' needs a final overrider\", base_fndecl);\n \t}"}, {"sha": "68dac42219d9d2572eedf559592416114356b90b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=31f8e4f306e9ef25c534afb1601fb9547801ae90", "patch": "@@ -50,6 +50,7 @@ static tree expand_cond PARAMS ((tree));\n static tree maybe_convert_cond PARAMS ((tree));\n static tree simplify_aggr_init_exprs_r PARAMS ((tree *, int *, void *));\n static void deferred_type_access_control PARAMS ((void));\n+static void emit_associated_thunks PARAMS ((tree));\n \n /* Record the fact that STMT was the last statement added to the\n    statement tree.  */\n@@ -2962,6 +2963,53 @@ simplify_aggr_init_exprs_r (tp, walk_subtrees, data)\n   return NULL_TREE;\n }\n \n+/* Emit all thunks to FN that should be emitted when FN is emitted.  */\n+\n+static void\n+emit_associated_thunks (fn)\n+     tree fn;\n+{\n+  /* When we use vcall offsets, we emit thunks with the virtual\n+     functions to which they thunk. The whole point of vcall offsets\n+     is so that you can know statically the entire set of thunks that\n+     will ever be needed for a given virtual function, thereby\n+     enabling you to output all the thunks with the function itself.  */\n+  if (vcall_offsets_in_vtable_p () && DECL_VIRTUAL_P (fn))\n+    {\n+      tree binfo;\n+      tree v;\n+\n+      for (binfo = TYPE_BINFO (DECL_CONTEXT (fn));\n+\t   binfo;\n+\t   binfo = TREE_CHAIN (binfo))\n+\tfor (v = BINFO_VIRTUALS (binfo); v; v = TREE_CHAIN (v))\n+\t  if (BV_FN (v) == fn\n+\t      && (!integer_zerop (BV_DELTA (v))\n+\t\t  || BV_VCALL_INDEX (v)))\n+\t    {\n+\t      tree thunk;\n+\t      tree vcall_index;\n+\n+\t      if (BV_USE_VCALL_INDEX_P (v))\n+\t\t{\n+\t\t  vcall_index = BV_VCALL_INDEX (v);\n+\t\t  my_friendly_assert (vcall_index != NULL_TREE, 20000621);\n+\t\t}\n+\t      else\n+\t\tvcall_index = NULL_TREE;\n+\n+\t      thunk = make_thunk (build1 (ADDR_EXPR,\n+\t\t\t\t\t  vfunc_ptr_type_node,\n+\t\t\t\t\t  fn),\n+\t\t\t\t  BV_DELTA (v),\n+\t\t\t\t  vcall_index,\n+\t\t\t\t  /*generate_with_vtable_p=*/0);\n+\t      use_thunk (thunk, /*emit_p=*/1);\n+\t    }\n+    }\n+}\n+\n+\n /* Generate RTL for FN.  */\n \n void\n@@ -3037,6 +3085,9 @@ expand_body (fn)\n       return;\n     }\n \n+  /* Emit any thunks that should be emitted at the same time as FN.  */\n+  emit_associated_thunks (fn);\n+\n   timevar_push (TV_INTEGRATION);\n \n   /* Optimize the body of the function before expanding it.  */"}, {"sha": "9f32ca082fc201ee09c18facd27e81994d25deb9", "filename": "gcc/testsuite/g++.old-deja/g++.other/virtual8.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvirtual8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f8e4f306e9ef25c534afb1601fb9547801ae90/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvirtual8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvirtual8.C?ref=31f8e4f306e9ef25c534afb1601fb9547801ae90", "patch": "@@ -0,0 +1,31 @@\n+extern \"C\" void printf (const char*, ...);\n+\n+struct A\n+{\n+  virtual void f () {\n+    printf (\"%x\\n\", this);\n+  }\n+};\n+\n+struct B : public A\n+{\n+};\n+\n+struct C : public A\n+{\n+};\n+\n+struct D : virtual public B, public C\n+{\n+};\n+\n+int main ()\n+{\n+  D d;\n+\n+  A* a1 = (A*) (B*) &d;\n+  A* a2 = (A*) (C*) &d;\n+\n+  a1->f ();\n+  a2->f ();\n+}"}]}