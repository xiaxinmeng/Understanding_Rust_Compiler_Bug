{"sha": "2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNmYzYyNzZkYWRjNTRhZWE5ZjhjZTJhOGNmZWZhZWU0NTZmMzgwZQ==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-12-10T17:59:21Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2020-12-17T17:23:46Z"}, "message": "Add AST->HIR lowering pass\n\nThis is the initial pass to move the AST to HIR. It is very extensible and\neasy to maintain now.", "tree": {"sha": "67633b1e63cc40f7df5fef1048401754a4f361f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67633b1e63cc40f7df5fef1048401754a4f361f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f2dd6de5bf2dc58a075aa0fe3c8ddf75eba8004"}], "stats": {"total": 1057, "additions": 1052, "deletions": 5}, "files": [{"sha": "b9b2345de3b3d79c5f533ed20bb462dbaeb18781", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "patch": "@@ -74,8 +74,9 @@ GRS_OBJS = \\\n     rust/rust-scan.o \\\n     rust/rust-compile.o \\\n     rust/rust-macro-expand.o \\\n-    rust/rust-hir-map.o \\\n     rust/rust-hir-full-test.o \\\n+    rust/rust-hir-map.o \\\n+    rust/rust-ast-lower.o \\\n     $(END)\n # removed object files from here\n \n@@ -275,8 +276,14 @@ rust/%.o: rust/util/%.cc\n \t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n \n+# build rust/hir files in rust folder\n+rust/%.o: rust/hir/%.cc\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n+\t$(POSTCOMPILE)\n+\n # build rust/hir/tree files in rust folder\n rust/%.o: rust/hir/tree/%.cc\n \t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n \n+"}, {"sha": "550d104b2ffe349982226c4a147346971e5f9f5f", "filename": "gcc/rust/hir/README.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2FREADME.md?ref=2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "patch": "@@ -0,0 +1,40 @@\n+# GCCRS HIR\n+\n+Working with the AST has proved to become difficult. To overcome non lexical scoping\n+a toplevel scan pass was added to provide lookups for functioins. To get ready for the\n+gimple conversion pass, type resolution scanned blocks to create the list of locals per\n+block. Type Conversion had to create awkward getters/setters on LetStmts to have a Type or\n+InferedType which was more of a hack that what should really be there. ArrayExprs get checked\n+and create their own type to be checked against a possible LetStmt type. All of these things\n+started to become hard to manage.\n+\n+HIR from the RFC defines how they create lookups and IDs for all the nodes which solves the toplevel\n+scan pass. The lowering to HIR allows for cleanup in how types are resolved. Without using\n+the HIR and IDs implementing the shadowing rules was going to become very difficult.\n+\n+\n+## IMPL:\n+\n+* AST-lower - move down to HIR classes - generate mappings and IDs\n+\n+* Name Resolution - Check for path segments naming and map to HirIDS\n+  This should in theory map for example a call expression to already have the HirID to the function ready\n+  Dyn dispatch may need some help here if its a method the receiver could be bound the local name hirid\n+  the resoltion would need to be fixed up in type resolution pass\n+  \n+* Expand - Gather locals per block and fix up returns is it possible to generate return expressions\n+  at this pass?\n+  \n+* Type Resolution - Port over work from AST Type resolver\n+  generate mir from this pass?\n+\n+\n+For now this can then port over to the existing GIMPLE conversion faily easily. But after more\n+of the core data structures work MIR will be needed for all the glue that will need to be generated.\n+\n+\n+## Returns\n+\n+looks like its implemented by an implicit mutable return variable for the function. If were processing\n+a block expression and the last element on the block is an expression we can try to bind it to the mutable\n+return variable."}, {"sha": "093129e4d22d02bc9513d9fbca7a8f72ff5d3dc1", "filename": "gcc/rust/hir/rust-ast-lower-base.h", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h?ref=2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "patch": "@@ -0,0 +1,251 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_BASE\n+#define RUST_AST_LOWER_BASE\n+\n+#include \"rust-system.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+// base class to allow derivatives to overload as needed\n+class ASTLoweringBase : public AST::ASTVisitor\n+{\n+public:\n+  virtual ~ASTLoweringBase () {}\n+\n+  // visitor impl\n+  // rust-ast.h\n+  //  virtual void visit(AttrInput& attr_input);\n+  //  virtual void visit(TokenTree& token_tree);\n+  //  virtual void visit(MacroMatch& macro_match);\n+  virtual void visit (AST::Token &tok) {}\n+  virtual void visit (AST::DelimTokenTree &delim_tok_tree) {}\n+  virtual void visit (AST::AttrInputMetaItemContainer &input) {}\n+  //  virtual void visit(MetaItem& meta_item) {}\n+  //  void vsit(Stmt& stmt) {}\n+  //  virtual void visit(Expr& expr) {}\n+  virtual void visit (AST::IdentifierExpr &ident_expr) {}\n+  //  virtual void visit(Pattern& pattern) {}\n+  //  virtual void visit(Type& type) {}\n+  //  virtual void visit(TypeParamBound& type_param_bound) {}\n+  virtual void visit (AST::Lifetime &lifetime) {}\n+  //  virtual void visit(GenericParam& generic_param) {}\n+  virtual void visit (AST::LifetimeParam &lifetime_param) {}\n+  //  virtual void visit(TraitItem& trait_item) {}\n+  //  virtual void visit(InherentImplItem& inherent_impl_item) {}\n+  //  virtual void visit(TraitImplItem& trait_impl_item) {}\n+  virtual void visit (AST::MacroInvocationSemi &macro) {}\n+\n+  // rust-path.h\n+  virtual void visit (AST::PathInExpression &path) {}\n+  virtual void visit (AST::TypePathSegment &segment) {}\n+  virtual void visit (AST::TypePathSegmentGeneric &segment) {}\n+  virtual void visit (AST::TypePathSegmentFunction &segment) {}\n+  virtual void visit (AST::TypePath &path) {}\n+  virtual void visit (AST::QualifiedPathInExpression &path) {}\n+  virtual void visit (AST::QualifiedPathInType &path) {}\n+\n+  // rust-expr.h\n+  virtual void visit (AST::LiteralExpr &expr) {}\n+  virtual void visit (AST::AttrInputLiteral &attr_input) {}\n+  virtual void visit (AST::MetaItemLitExpr &meta_item) {}\n+  virtual void visit (AST::MetaItemPathLit &meta_item) {}\n+  virtual void visit (AST::BorrowExpr &expr) {}\n+  virtual void visit (AST::DereferenceExpr &expr) {}\n+  virtual void visit (AST::ErrorPropagationExpr &expr) {}\n+  virtual void visit (AST::NegationExpr &expr) {}\n+  virtual void visit (AST::ArithmeticOrLogicalExpr &expr) {}\n+  virtual void visit (AST::ComparisonExpr &expr) {}\n+  virtual void visit (AST::LazyBooleanExpr &expr) {}\n+  virtual void visit (AST::TypeCastExpr &expr) {}\n+  virtual void visit (AST::AssignmentExpr &expr) {}\n+  virtual void visit (AST::CompoundAssignmentExpr &expr) {}\n+  virtual void visit (AST::GroupedExpr &expr) {}\n+  //  virtual void visit(ArrayElems& elems) {}\n+  virtual void visit (AST::ArrayElemsValues &elems) {}\n+  virtual void visit (AST::ArrayElemsCopied &elems) {}\n+  virtual void visit (AST::ArrayExpr &expr) {}\n+  virtual void visit (AST::ArrayIndexExpr &expr) {}\n+  virtual void visit (AST::TupleExpr &expr) {}\n+  virtual void visit (AST::TupleIndexExpr &expr) {}\n+  virtual void visit (AST::StructExprStruct &expr) {}\n+  //  virtual void visit(StructExprField& field) {}\n+  virtual void visit (AST::StructExprFieldIdentifier &field) {}\n+  virtual void visit (AST::StructExprFieldIdentifierValue &field) {}\n+  virtual void visit (AST::StructExprFieldIndexValue &field) {}\n+  virtual void visit (AST::StructExprStructFields &expr) {}\n+  virtual void visit (AST::StructExprStructBase &expr) {}\n+  virtual void visit (AST::StructExprTuple &expr) {}\n+  virtual void visit (AST::StructExprUnit &expr) {}\n+  //  virtual void visit(EnumExprField& field) {}\n+  virtual void visit (AST::EnumExprFieldIdentifier &field) {}\n+  virtual void visit (AST::EnumExprFieldIdentifierValue &field) {}\n+  virtual void visit (AST::EnumExprFieldIndexValue &field) {}\n+  virtual void visit (AST::EnumExprStruct &expr) {}\n+  virtual void visit (AST::EnumExprTuple &expr) {}\n+  virtual void visit (AST::EnumExprFieldless &expr) {}\n+  virtual void visit (AST::CallExpr &expr) {}\n+  virtual void visit (AST::MethodCallExpr &expr) {}\n+  virtual void visit (AST::FieldAccessExpr &expr) {}\n+  virtual void visit (AST::ClosureExprInner &expr) {}\n+  virtual void visit (AST::BlockExpr &expr) {}\n+  virtual void visit (AST::ClosureExprInnerTyped &expr) {}\n+  virtual void visit (AST::ContinueExpr &expr) {}\n+  virtual void visit (AST::BreakExpr &expr) {}\n+  virtual void visit (AST::RangeFromToExpr &expr) {}\n+  virtual void visit (AST::RangeFromExpr &expr) {}\n+  virtual void visit (AST::RangeToExpr &expr) {}\n+  virtual void visit (AST::RangeFullExpr &expr) {}\n+  virtual void visit (AST::RangeFromToInclExpr &expr) {}\n+  virtual void visit (AST::RangeToInclExpr &expr) {}\n+  virtual void visit (AST::ReturnExpr &expr) {}\n+  virtual void visit (AST::UnsafeBlockExpr &expr) {}\n+  virtual void visit (AST::LoopExpr &expr) {}\n+  virtual void visit (AST::WhileLoopExpr &expr) {}\n+  virtual void visit (AST::WhileLetLoopExpr &expr) {}\n+  virtual void visit (AST::ForLoopExpr &expr) {}\n+  virtual void visit (AST::IfExpr &expr) {}\n+  virtual void visit (AST::IfExprConseqElse &expr) {}\n+  virtual void visit (AST::IfExprConseqIf &expr) {}\n+  virtual void visit (AST::IfExprConseqIfLet &expr) {}\n+  virtual void visit (AST::IfLetExpr &expr) {}\n+  virtual void visit (AST::IfLetExprConseqElse &expr) {}\n+  virtual void visit (AST::IfLetExprConseqIf &expr) {}\n+  virtual void visit (AST::IfLetExprConseqIfLet &expr) {}\n+  //  virtual void visit(MatchCase& match_case) {}\n+  // virtual void visit (AST::MatchCaseBlockExpr &match_case) {}\n+  // virtual void visit (AST::MatchCaseExpr &match_case) {}\n+  virtual void visit (AST::MatchExpr &expr) {}\n+  virtual void visit (AST::AwaitExpr &expr) {}\n+  virtual void visit (AST::AsyncBlockExpr &expr) {}\n+\n+  // rust-item.h\n+  virtual void visit (AST::TypeParam &param) {}\n+  //  virtual void visit(WhereClauseItem& item) {}\n+  virtual void visit (AST::LifetimeWhereClauseItem &item) {}\n+  virtual void visit (AST::TypeBoundWhereClauseItem &item) {}\n+  virtual void visit (AST::Method &method) {}\n+  virtual void visit (AST::ModuleBodied &module) {}\n+  virtual void visit (AST::ModuleNoBody &module) {}\n+  virtual void visit (AST::ExternCrate &crate) {}\n+  //  virtual void visit(UseTree& use_tree) {}\n+  virtual void visit (AST::UseTreeGlob &use_tree) {}\n+  virtual void visit (AST::UseTreeList &use_tree) {}\n+  virtual void visit (AST::UseTreeRebind &use_tree) {}\n+  virtual void visit (AST::UseDeclaration &use_decl) {}\n+  virtual void visit (AST::Function &function) {}\n+  virtual void visit (AST::TypeAlias &type_alias) {}\n+  virtual void visit (AST::StructStruct &struct_item) {}\n+  virtual void visit (AST::TupleStruct &tuple_struct) {}\n+  virtual void visit (AST::EnumItem &item) {}\n+  virtual void visit (AST::EnumItemTuple &item) {}\n+  virtual void visit (AST::EnumItemStruct &item) {}\n+  virtual void visit (AST::EnumItemDiscriminant &item) {}\n+  virtual void visit (AST::Enum &enum_item) {}\n+  virtual void visit (AST::Union &union_item) {}\n+  virtual void visit (AST::ConstantItem &const_item) {}\n+  virtual void visit (AST::StaticItem &static_item) {}\n+  virtual void visit (AST::TraitItemFunc &item) {}\n+  virtual void visit (AST::TraitItemMethod &item) {}\n+  virtual void visit (AST::TraitItemConst &item) {}\n+  virtual void visit (AST::TraitItemType &item) {}\n+  virtual void visit (AST::Trait &trait) {}\n+  virtual void visit (AST::InherentImpl &impl) {}\n+  virtual void visit (AST::TraitImpl &impl) {}\n+  //  virtual void visit(ExternalItem& item) {}\n+  virtual void visit (AST::ExternalStaticItem &item) {}\n+  virtual void visit (AST::ExternalFunctionItem &item) {}\n+  virtual void visit (AST::ExternBlock &block) {}\n+\n+  // rust-macro.h\n+  virtual void visit (AST::MacroMatchFragment &match) {}\n+  virtual void visit (AST::MacroMatchRepetition &match) {}\n+  virtual void visit (AST::MacroMatcher &matcher) {}\n+  virtual void visit (AST::MacroRulesDefinition &rules_def) {}\n+  virtual void visit (AST::MacroInvocation &macro_invoc) {}\n+  virtual void visit (AST::MetaItemPath &meta_item) {}\n+  virtual void visit (AST::MetaItemSeq &meta_item) {}\n+  virtual void visit (AST::MetaWord &meta_item) {}\n+  virtual void visit (AST::MetaNameValueStr &meta_item) {}\n+  virtual void visit (AST::MetaListPaths &meta_item) {}\n+  virtual void visit (AST::MetaListNameValueStr &meta_item) {}\n+\n+  // rust-pattern.h\n+  virtual void visit (AST::LiteralPattern &pattern) {}\n+  virtual void visit (AST::IdentifierPattern &pattern) {}\n+  virtual void visit (AST::WildcardPattern &pattern) {}\n+  //  virtual void visit(RangePatternBound& bound) {}\n+  virtual void visit (AST::RangePatternBoundLiteral &bound) {}\n+  virtual void visit (AST::RangePatternBoundPath &bound) {}\n+  virtual void visit (AST::RangePatternBoundQualPath &bound) {}\n+  virtual void visit (AST::RangePattern &pattern) {}\n+  virtual void visit (AST::ReferencePattern &pattern) {}\n+  //  virtual void visit(StructPatternField& field) {}\n+  virtual void visit (AST::StructPatternFieldTuplePat &field) {}\n+  virtual void visit (AST::StructPatternFieldIdentPat &field) {}\n+  virtual void visit (AST::StructPatternFieldIdent &field) {}\n+  virtual void visit (AST::StructPattern &pattern) {}\n+  //  virtual void visit(TupleStructItems& tuple_items) {}\n+  virtual void visit (AST::TupleStructItemsNoRange &tuple_items) {}\n+  virtual void visit (AST::TupleStructItemsRange &tuple_items) {}\n+  virtual void visit (AST::TupleStructPattern &pattern) {}\n+  //  virtual void visit(TuplePatternItems& tuple_items) {}\n+  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items) {}\n+  virtual void visit (AST::TuplePatternItemsRanged &tuple_items) {}\n+  virtual void visit (AST::TuplePattern &pattern) {}\n+  virtual void visit (AST::GroupedPattern &pattern) {}\n+  virtual void visit (AST::SlicePattern &pattern) {}\n+\n+  // rust-stmt.h\n+  virtual void visit (AST::EmptyStmt &stmt) {}\n+  virtual void visit (AST::LetStmt &stmt) {}\n+  virtual void visit (AST::ExprStmtWithoutBlock &stmt) {}\n+  virtual void visit (AST::ExprStmtWithBlock &stmt) {}\n+\n+  // rust-type.h\n+  virtual void visit (AST::TraitBound &bound) {}\n+  virtual void visit (AST::ImplTraitType &type) {}\n+  virtual void visit (AST::TraitObjectType &type) {}\n+  virtual void visit (AST::ParenthesisedType &type) {}\n+  virtual void visit (AST::ImplTraitTypeOneBound &type) {}\n+  virtual void visit (AST::TraitObjectTypeOneBound &type) {}\n+  virtual void visit (AST::TupleType &type) {}\n+  virtual void visit (AST::NeverType &type) {}\n+  virtual void visit (AST::RawPointerType &type) {}\n+  virtual void visit (AST::ReferenceType &type) {}\n+  virtual void visit (AST::ArrayType &type) {}\n+  virtual void visit (AST::SliceType &type) {}\n+  virtual void visit (AST::InferredType &type) {}\n+  virtual void visit (AST::BareFunctionType &type) {}\n+\n+protected:\n+  ASTLoweringBase () : mappings (Analysis::Mappings::get ()) {}\n+\n+  Analysis::Mappings *mappings;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_BASE"}, {"sha": "6454a78ab62a4dd9f127184f3472fb1e134ad4c9", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "patch": "@@ -0,0 +1,240 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_EXPR\n+#define RUST_AST_LOWER_EXPR\n+\n+#include \"rust-diagnostics.h\"\n+\n+#include \"rust-ast-lower-base.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringExpr : public ASTLoweringBase\n+{\n+public:\n+  static HIR::Expr *translate (AST::Expr *expr)\n+  {\n+    ASTLoweringExpr resolver;\n+    expr->accept_vis (resolver);\n+    if (resolver.translated != nullptr)\n+      {\n+\tresolver.mappings->insert_hir_expr (\n+\t  resolver.translated->get_mappings ().get_crate_num (),\n+\t  resolver.translated->get_mappings ().get_hirid (),\n+\t  resolver.translated);\n+      }\n+\n+    return resolver.translated;\n+  }\n+\n+  virtual ~ASTLoweringExpr () {}\n+\n+  void visit (AST::PathInExpression &expr)\n+  {\n+    std::vector<HIR::PathExprSegment> path_segments;\n+    expr.iterate_path_segments ([&] (AST::PathExprSegment &s) mutable -> bool {\n+      rust_assert (s.has_generic_args () == false); // TODO\n+\n+      HIR::PathIdentSegment is (s.get_ident_segment ().as_string ());\n+      HIR::PathExprSegment seg (is, s.get_locus ());\n+      path_segments.push_back (seg);\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::PathInExpression (mapping, std::move (path_segments),\n+\t\t\t\t\t    expr.get_locus (),\n+\t\t\t\t\t    expr.opening_scope_resolution ());\n+  }\n+\n+  void visit (AST::ReturnExpr &expr)\n+  {\n+    HIR::Expr *return_expr = expr.has_return_expr ()\n+\t\t\t       ? ASTLoweringExpr::translate (expr.get_expr ())\n+\t\t\t       : nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::ReturnExpr (mapping, expr.get_locus (),\n+\t\t\t\t      std::unique_ptr<HIR::Expr> (return_expr));\n+  }\n+\n+  void visit (AST::CallExpr &expr)\n+  {\n+    std::vector<HIR::Attribute> outer_attribs;\n+    HIR::Expr *func = ASTLoweringExpr::translate (expr.function.get ());\n+    std::vector<std::unique_ptr<HIR::Expr> > params;\n+    expr.iterate_params ([&] (AST::Expr *p) mutable -> bool {\n+      auto trans = ASTLoweringExpr::translate (p);\n+      params.push_back (std::unique_ptr<HIR::Expr> (trans));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (\n+      crate_num, UNKNOWN_NODEID /* this can map back to the AST*/,\n+      mappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::CallExpr (mapping, std::unique_ptr<HIR::Expr> (func),\n+\t\t\t   std::move (params), std::move (outer_attribs),\n+\t\t\t   expr.get_locus ());\n+  }\n+\n+  void visit (AST::AssignmentExpr &expr)\n+  {\n+    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_lhs ());\n+    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_rhs ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::AssignmentExpr (mapping, std::unique_ptr<HIR::Expr> (lhs),\n+\t\t\t\t std::unique_ptr<HIR::Expr> (rhs),\n+\t\t\t\t expr.get_locus ());\n+  }\n+\n+  void visit (AST::IdentifierExpr &expr)\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    translated\n+      = new HIR::IdentifierExpr (mapping, expr.as_string (), expr.get_locus ());\n+  }\n+\n+  void visit (AST::LiteralExpr &expr)\n+  {\n+    HIR::Literal::LitType type = HIR::Literal::LitType::CHAR;\n+    switch (expr.get_lit_type ())\n+      {\n+      case AST::Literal::LitType::CHAR:\n+\ttype = HIR::Literal::LitType::CHAR;\n+\tbreak;\n+      case AST::Literal::LitType::STRING:\n+\ttype = HIR::Literal::LitType::STRING;\n+\tbreak;\n+      case AST::Literal::LitType::RAW_STRING:\n+\ttype = HIR::Literal::LitType::RAW_STRING;\n+\tbreak;\n+      case AST::Literal::LitType::BYTE:\n+\ttype = HIR::Literal::LitType::BYTE;\n+\tbreak;\n+      case AST::Literal::LitType::BYTE_STRING:\n+\ttype = HIR::Literal::LitType::BYTE_STRING;\n+\tbreak;\n+      case AST::Literal::LitType::RAW_BYTE_STRING:\n+\ttype = HIR::Literal::LitType::RAW_BYTE_STRING;\n+\tbreak;\n+      case AST::Literal::LitType::INT:\n+\ttype = HIR::Literal::LitType::INT;\n+\tbreak;\n+      case AST::Literal::LitType::FLOAT:\n+\ttype = HIR::Literal::LitType::FLOAT;\n+\tbreak;\n+      case AST::Literal::LitType::BOOL:\n+\ttype = HIR::Literal::LitType::BOOL;\n+\tbreak;\n+      }\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::LiteralExpr (mapping, expr.as_string (), type,\n+\t\t\t\t       expr.get_locus ());\n+  }\n+\n+  void visit (AST::ArithmeticOrLogicalExpr &expr)\n+  {\n+    HIR::ArithmeticOrLogicalExpr::ExprType kind\n+      = HIR::ArithmeticOrLogicalExpr::ExprType::ADD;\n+    switch (expr.get_expr_type ())\n+      {\n+      case AST::ArithmeticOrLogicalExpr::ExprType::ADD:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::ADD;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::SUBTRACT:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::SUBTRACT;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::MULTIPLY:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::MULTIPLY;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::DIVIDE:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::DIVIDE;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::MODULUS:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::MODULUS;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::BITWISE_AND:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::BITWISE_AND;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::BITWISE_OR:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::BITWISE_OR;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::BITWISE_XOR:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::BITWISE_XOR;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::LEFT_SHIFT:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::LEFT_SHIFT;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::RIGHT_SHIFT:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::RIGHT_SHIFT;\n+\tbreak;\n+      }\n+\n+    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_lhs ());\n+    rust_assert (lhs != nullptr);\n+    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.right_expr.get ());\n+    rust_assert (rhs != nullptr);\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::ArithmeticOrLogicalExpr (mapping,\n+\t\t\t\t\t  std::unique_ptr<HIR::Expr> (lhs),\n+\t\t\t\t\t  std::unique_ptr<HIR::Expr> (rhs),\n+\t\t\t\t\t  kind, expr.get_locus ());\n+  }\n+\n+private:\n+  ASTLoweringExpr () : translated (nullptr) {}\n+\n+  HIR::Expr *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_EXPR"}, {"sha": "5983e88b7575e844bb181fa5a8fea17f418ed536", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "patch": "@@ -0,0 +1,134 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_ITEM\n+#define RUST_AST_LOWER_ITEM\n+\n+#include \"rust-diagnostics.h\"\n+\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-stmt.h\"\n+#include \"rust-ast-lower-pattern.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringItem : public ASTLoweringBase\n+{\n+public:\n+  static HIR::Item *translate (AST::Item *item)\n+  {\n+    ASTLoweringItem resolver;\n+    item->accept_vis (resolver);\n+    return resolver.translated;\n+  }\n+\n+  virtual ~ASTLoweringItem () {}\n+\n+  void visit (AST::Function &function)\n+  {\n+    // ignore for now and leave empty\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<HIR::Attribute> outer_attrs;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::FunctionQualifiers qualifiers (\n+      HIR::FunctionQualifiers::AsyncConstStatus::NONE, false);\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    // need\n+    Identifier function_name = function.function_name;\n+    Location locus = function.get_locus ();\n+\n+    std::unique_ptr<HIR::Type> return_type\n+      = function.has_function_return_type () ? std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (function.return_type.get ()))\n+\t\t\t\t\t     : nullptr;\n+\n+    std::vector<HIR::FunctionParam> function_params;\n+    for (auto &param : function.function_params)\n+      {\n+\tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\t  ASTLoweringPattern::translate (param.param_name.get ()));\n+\tauto translated_type = std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (param.type.get ()));\n+\n+\tfunction_params.push_back (\n+\t  HIR::FunctionParam (std::move (translated_pattern),\n+\t\t\t      std::move (translated_type), param.get_locus ()));\n+      }\n+\n+    std::unique_ptr<HIR::BlockExpr> function_body\n+      = std::unique_ptr<HIR::BlockExpr> (\n+\ttranslate (function.function_body.get ()));\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, function.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated\n+      = new HIR::Function (mapping, std::move (function_name),\n+\t\t\t   std::move (qualifiers), std::move (generic_params),\n+\t\t\t   std::move (function_params), std::move (return_type),\n+\t\t\t   std::move (where_clause), std::move (function_body),\n+\t\t\t   std::move (vis), std::move (outer_attrs), locus);\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+  }\n+\n+  // Helpers\n+\n+  HIR::BlockExpr *translate (AST::BlockExpr *function_body)\n+  {\n+    std::vector<std::unique_ptr<HIR::Stmt> > block_stmts;\n+    std::unique_ptr<HIR::ExprWithoutBlock> block_expr;\n+    std::vector<HIR::Attribute> inner_attribs;\n+    std::vector<HIR::Attribute> outer_attribs;\n+\n+    function_body->iterate_stmts ([&] (AST::Stmt *s) mutable -> bool {\n+      auto translated_stmt = ASTLoweringStmt::translate (s);\n+      block_stmts.push_back (std::unique_ptr<HIR::Stmt> (translated_stmt));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, function_body->get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    return new HIR::BlockExpr (mapping, std::move (block_stmts),\n+\t\t\t       std::move (block_expr),\n+\t\t\t       std::move (inner_attribs),\n+\t\t\t       std::move (outer_attribs),\n+\t\t\t       function_body->get_locus ());\n+  }\n+\n+private:\n+  ASTLoweringItem () : translated (nullptr) {}\n+\n+  HIR::Item *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_ITEM"}, {"sha": "b69c9d9b33397bcd649ee76d638bff91328878e7", "filename": "gcc/rust/hir/rust-ast-lower-pattern.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h?ref=2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_PATTERN\n+#define RUST_AST_LOWER_PATTERN\n+\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-diagnostics.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringPattern : public ASTLoweringBase\n+{\n+public:\n+  static HIR::Pattern *translate (AST::Pattern *pattern)\n+  {\n+    ASTLoweringPattern resolver;\n+    pattern->accept_vis (resolver);\n+    return resolver.translated;\n+  }\n+\n+  virtual ~ASTLoweringPattern () {}\n+\n+  void visit (AST::IdentifierPattern &pattern)\n+  {\n+    std::unique_ptr<Pattern> to_bind;\n+    translated\n+      = new HIR::IdentifierPattern (pattern.variable_ident,\n+\t\t\t\t    pattern.get_locus (), pattern.is_ref,\n+\t\t\t\t    pattern.is_mut, std::move (to_bind));\n+  }\n+\n+private:\n+  ASTLoweringPattern () : translated (nullptr) {}\n+\n+  HIR::Pattern *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_PATTERN"}, {"sha": "d21b49dc2f5e9fdaeae7649b6fe1a0e03efc0074", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "patch": "@@ -0,0 +1,96 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_STMT\n+#define RUST_AST_LOWER_STMT\n+\n+#include \"rust-diagnostics.h\"\n+\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-expr.h\"\n+#include \"rust-ast-lower-pattern.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringStmt : public ASTLoweringBase\n+{\n+public:\n+  static HIR::Stmt *translate (AST::Stmt *stmt)\n+  {\n+    ASTLoweringStmt resolver;\n+    stmt->accept_vis (resolver);\n+    if (resolver.translated == nullptr)\n+      {\n+\tprintf (\"Failing translating: %s\\n\", stmt->as_string ().c_str ());\n+\trust_assert (resolver.translated != nullptr);\n+      }\n+    return resolver.translated;\n+  }\n+\n+  virtual ~ASTLoweringStmt () {}\n+\n+  void visit (AST::ExprStmtWithoutBlock &stmt)\n+  {\n+    HIR::Expr *expr = ASTLoweringExpr::translate (stmt.expr.get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, stmt.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    translated\n+      = new HIR::ExprStmtWithoutBlock (mapping,\n+\t\t\t\t       std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t       stmt.get_locus ());\n+  }\n+\n+  void visit (AST::LetStmt &stmt)\n+  {\n+    std::vector<HIR::Attribute> outer_attrs;\n+    HIR::Pattern *variables\n+      = ASTLoweringPattern::translate (stmt.variables_pattern.get ());\n+    HIR::Type *type = stmt.has_type ()\n+\t\t\t? ASTLoweringType::translate (stmt.type.get ())\n+\t\t\t: nullptr;\n+    HIR::Expr *init_expression\n+      = stmt.has_init_expr ()\n+\t  ? ASTLoweringExpr::translate (stmt.init_expr.get ())\n+\t  : nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, stmt.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    translated\n+      = new HIR::LetStmt (mapping, std::unique_ptr<HIR::Pattern> (variables),\n+\t\t\t  std::unique_ptr<HIR::Expr> (init_expression),\n+\t\t\t  std::unique_ptr<HIR::Type> (type),\n+\t\t\t  std::move (outer_attrs), stmt.get_locus ());\n+  }\n+\n+private:\n+  ASTLoweringStmt () : translated (nullptr) {}\n+\n+  HIR::Stmt *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_PATTERN"}, {"sha": "9611ca0a2464b5a3314deb9c8ccc2af922695ea5", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "patch": "@@ -0,0 +1,84 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_TYPE\n+#define RUST_AST_LOWER_TYPE\n+\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-diagnostics.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringType : public ASTLoweringBase\n+{\n+public:\n+  static HIR::Type *translate (AST::Type *type)\n+  {\n+    ASTLoweringType resolver;\n+    type->accept_vis (resolver);\n+    return resolver.translated;\n+  }\n+\n+  virtual ~ASTLoweringType () {}\n+\n+  virtual void visit (AST::TypePathSegment &segment)\n+  {\n+    HIR::PathIdentSegment ident (segment.get_ident_segment ().as_string ());\n+    translated_segment\n+      = new HIR::TypePathSegment (ident,\n+\t\t\t\t  segment.get_separating_scope_resolution (),\n+\t\t\t\t  segment.get_locus ());\n+  }\n+\n+  virtual void visit (AST::TypePath &path)\n+  {\n+    std::vector<std::unique_ptr<HIR::TypePathSegment> > translated_segments;\n+\n+    path.iterate_segments ([&] (AST::TypePathSegment *seg) mutable -> bool {\n+      translated_segment = nullptr;\n+      seg->accept_vis (*this);\n+      if (translated_segment == nullptr)\n+\t{\n+\t  rust_fatal_error (seg->get_locus (),\n+\t\t\t    \"failed to translate AST TypePathSegment\");\n+\t  return false;\n+\t}\n+\n+      translated_segments.push_back (\n+\tstd::unique_ptr<HIR::TypePathSegment> (translated_segment));\n+      return true;\n+    });\n+\n+    translated\n+      = new HIR::TypePath (std::move (translated_segments), path.get_locus (),\n+\t\t\t   path.has_opening_scope_resolution_op ());\n+  }\n+\n+private:\n+  ASTLoweringType () : translated (nullptr) {}\n+\n+  HIR::Type *translated;\n+\n+  HIR::TypePathSegment *translated_segment;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_TYPE"}, {"sha": "8a514ce7eb3b21692a0e29e91f8c31e4fb96fc66", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "patch": "@@ -0,0 +1,62 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-lower.h\"\n+#include \"rust-ast-lower-item.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+ASTLowering::ASTLowering (AST::Crate &astCrate) : astCrate (astCrate) {}\n+\n+ASTLowering::~ASTLowering () {}\n+\n+HIR::Crate\n+ASTLowering::Resolve (AST::Crate &astCrate)\n+{\n+  ASTLowering resolver (astCrate);\n+  return resolver.go ();\n+}\n+\n+HIR::Crate\n+ASTLowering::go ()\n+{\n+  std::vector<std::unique_ptr<HIR::Item> > items;\n+  std::vector<HIR::Attribute> inner_attrs;\n+  bool has_utf8bom = false;\n+  bool has_shebang = false;\n+\n+  for (auto it = astCrate.items.begin (); it != astCrate.items.end (); it++)\n+    {\n+      auto translated = ASTLoweringItem::translate (it->get ());\n+      if (translated != nullptr)\n+\titems.push_back (std::unique_ptr<HIR::Item> (translated));\n+    }\n+\n+  auto mappings = Analysis::Mappings::get ();\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  return HIR::Crate (std::move (items), std::move (inner_attrs), mapping,\n+\t\t     has_utf8bom, has_shebang);\n+}\n+\n+} // namespace HIR\n+} // namespace Rust"}, {"sha": "bdc21ba486b5f9234153ca989260d18664cfabbf", "filename": "gcc/rust/hir/rust-ast-lower.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Fhir%2Frust-ast-lower.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.h?ref=2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "patch": "@@ -0,0 +1,46 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_LOWER\n+#define RUST_HIR_LOWER\n+\n+#include \"rust-system.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLowering\n+{\n+public:\n+  static HIR::Crate Resolve (AST::Crate &astCrate);\n+  ~ASTLowering ();\n+\n+private:\n+  ASTLowering (AST::Crate &astCrate);\n+  HIR::Crate go ();\n+\n+  AST::Crate &astCrate;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_HIR_LOWER"}, {"sha": "f526da16c49d2cd3709a78ea98c8000258af7ade", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "patch": "@@ -1,5 +1,23 @@\n-#include \"rust-session-manager.h\"\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n \n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+// #include \"rust-session-manager.h\"\n+\n+#include \"rust-session-manager.h\"\n #include \"rust-diagnostics.h\"\n #include \"diagnostic.h\"\n #include \"input.h\"\n@@ -13,13 +31,13 @@\n #include \"rust-scan.h\"\n #include \"rust-name-resolution.h\"\n #include \"rust-type-resolution.h\"\n-#include \"rust-compile.h\"\n #include \"rust-macro-expand.h\"\n+#include \"rust-compile.h\"\n \n+// hir passes wip\n+#include \"rust-ast-lower.h\"\n #include \"rust-target.h\"\n \n-#include <algorithm>\n-\n extern Linemap *\n rust_get_linemap ();\n \n@@ -405,6 +423,7 @@ Session::parse_files (int num_files, const char **files)\n {\n   for (int i = 0; i < num_files; i++)\n     {\n+      printf (\"Attempting to parse file: %s\\n\", files[i]);\n       parse_file (files[i]);\n     }\n   /* TODO: should semantic analysis be dealed with here? or per file? for now,\n@@ -431,6 +450,10 @@ Session::parse_file (const char *filename)\n   // generate crate from parser\n   auto parsed_crate = parser.parse_crate ();\n \n+  // setup the mappings for this AST\n+  auto mappings = Analysis::Mappings::get ();\n+  mappings->insert_ast_crate (&parsed_crate);\n+\n   // give a chance to give some debug\n   switch (options.dump_option)\n     {\n@@ -740,6 +763,12 @@ Session::resolution (AST::Crate &crate)\n   // Name resolution must be in front of type resolution\n   Analysis::NameResolution::Resolve (crate, toplevel);\n   Analysis::TypeResolution::Resolve (crate, toplevel);\n+\n+  // inject hir passes\n+  HIR::Crate hir = HIR::ASTLowering::Resolve (crate);\n+  fprintf (stderr, \"HIR PASSES:\\n\");\n+  fprintf (stderr, \"%s\", hir.as_string ().c_str ());\n+  fprintf (stderr, \"HIR PASSES - DONE:\\n\");\n   fprintf (stderr, \"finished name resolution\\n\");\n }\n "}]}