{"sha": "3ec926d36fbf7cb3ff45759471139f3a71d1c4de", "node_id": "C_kwDOANBUbNoAKDNlYzkyNmQzNmZiZjdjYjNmZjQ1NzU5NDcxMTM5ZjNhNzFkMWM0ZGU", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-10-06T13:13:50Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-10-06T13:16:29Z"}, "message": "Fix wrong code generated by unroll-and-jam pass\n\nThere is a loophole in the unroll-and-jam pass that can quickly result in\nwrong code generation.  The code reads:\n\n    if (!compute_data_dependences_for_loop (outer, true, &loop_nest,\n                                &datarefs, &dependences))\n        {\n          if (dump_file && (dump_flags & TDF_DETAILS))\n            fprintf (dump_file, \"Cannot analyze data dependencies\\n\");\n          free_data_refs (datarefs);\n          free_dependence_relations (dependences);\n          continue;\n        }\n\nbut compute_data_dependences_for_loop may return true even if the analysis\nis reported as failing by compute_affine_dependence for a dependence pair:\n\n(compute_affine_dependence\n  ref_a: data[_14], stmt_a: data[_14] = i_59;\n  ref_b: data[_14], stmt_b: data[_14] = i_59;\nData ref a:\nData ref b:\naffine dependence test not usable: access function not affine or constant.\n) -> dependence analysis failed\n\nNote that this is a self-dependence pair and the code for them reads:\n\n          /* Nothing interesting for the self dependencies. */\n          if (dra == drb)\n            continue;\n\nThis means that the pass may reorder \"complex\" accesses to the same memory\nlocation in successive iterations, which is OK for reads but not for writes.\n\ngcc/\n\t* gimple-loop-jam.cc (tree_loop_unroll_and_jam): Bail out for a self\n\tdependency that is a write-after-write if the access function is not\n\taffine or constant.\n\ngcc/testsuite/\n\t* gcc.c-torture/execute/20221006-1.c: New test.", "tree": {"sha": "038eb343866568a2a1fcc078210bcd8ef7adb271", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/038eb343866568a2a1fcc078210bcd8ef7adb271"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ec926d36fbf7cb3ff45759471139f3a71d1c4de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec926d36fbf7cb3ff45759471139f3a71d1c4de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ec926d36fbf7cb3ff45759471139f3a71d1c4de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec926d36fbf7cb3ff45759471139f3a71d1c4de/comments", "author": null, "committer": null, "parents": [{"sha": "b9d04e915fe0f4cdcca40e6de65ae384ba82a429", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9d04e915fe0f4cdcca40e6de65ae384ba82a429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9d04e915fe0f4cdcca40e6de65ae384ba82a429"}], "stats": {"total": 47, "additions": 45, "deletions": 2}, "files": [{"sha": "4f7a6e5bbae587c9b715818ac30802df2daddb02", "filename": "gcc/gimple-loop-jam.cc", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec926d36fbf7cb3ff45759471139f3a71d1c4de/gcc%2Fgimple-loop-jam.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec926d36fbf7cb3ff45759471139f3a71d1c4de/gcc%2Fgimple-loop-jam.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-jam.cc?ref=3ec926d36fbf7cb3ff45759471139f3a71d1c4de", "patch": "@@ -545,11 +545,25 @@ tree_loop_unroll_and_jam (void)\n \t  /* If the refs are independend there's nothing to do.  */\n \t  if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n \t    continue;\n+\n \t  dra = DDR_A (ddr);\n \t  drb = DDR_B (ddr);\n-\t  /* Nothing interesting for the self dependencies.  */\n+\n+\t  /* Nothing interesting for the self dependencies, except for WAW if\n+\t     the access function is not affine or constant because we may end\n+\t     up reordering writes to the same location.  */\n \t  if (dra == drb)\n-\t    continue;\n+\t    {\n+\t      if (DR_IS_WRITE (dra)\n+\t\t  && !DR_ACCESS_FNS (dra).is_empty ()\n+\t\t  && DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n+\t\t{\n+\t\t  unroll_factor = 0;\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\tcontinue;\n+\t    }\n \n \t  /* Now check the distance vector, for determining a sensible\n \t     outer unroll factor, and for validity of merging the inner"}, {"sha": "80deb3a148fda7ba72ff0edd025538ca89703412", "filename": "gcc/testsuite/gcc.c-torture/execute/20221006-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ec926d36fbf7cb3ff45759471139f3a71d1c4de/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20221006-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ec926d36fbf7cb3ff45759471139f3a71d1c4de/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20221006-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20221006-1.c?ref=3ec926d36fbf7cb3ff45759471139f3a71d1c4de", "patch": "@@ -0,0 +1,29 @@\n+#include <stdlib.h>\n+\n+int\n+main (int argc, char** argv)\n+{\n+  const int len = argc == 2 ? atoi(argv[1]) : 4;\n+\n+  int count;\n+  int data[64];\n+  int M1[len][len];\n+  int M2[len][len];\n+\n+  for (int i = 0; i < len; i++)\n+    for (int j = 0 ; j < len ; j++)\n+      M1[i][j] = M2[i][j] = i*len + j;\n+\n+  M2[1][0] = M2[0][1];\n+\n+  /* This writes successively 0 and 1 into data[M2[0][1]].  */\n+  for (int i = 0; i < len - 1; i++)\n+    for (int j = 0 ; j < len ; j++)\n+      if (M1[i+1][j] > M1[i][j]) \n+        data[M2[i][j]] = i;\n+\n+  if (data [M2[0][1]] != 1)\n+    abort ();\n+\n+  return 0;\n+}"}]}