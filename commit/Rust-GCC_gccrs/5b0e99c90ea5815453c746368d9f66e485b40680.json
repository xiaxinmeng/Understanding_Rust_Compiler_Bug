{"sha": "5b0e99c90ea5815453c746368d9f66e485b40680", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIwZTk5YzkwZWE1ODE1NDUzYzc0NjM2OGQ5ZjY2ZTQ4NWI0MDY4MA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-14T19:35:58Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-14T19:35:58Z"}, "message": "Don't crash on erroneous receiver or parameters.\n\nFrom-SVN: r167812", "tree": {"sha": "b2c04d7ab2a859d213441783890952236d901ce4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2c04d7ab2a859d213441783890952236d901ce4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b0e99c90ea5815453c746368d9f66e485b40680", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0e99c90ea5815453c746368d9f66e485b40680", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b0e99c90ea5815453c746368d9f66e485b40680", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0e99c90ea5815453c746368d9f66e485b40680/comments", "author": null, "committer": null, "parents": [{"sha": "cd96b4e2dbe471bbf3e743cd571b9a16f002a8a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd96b4e2dbe471bbf3e743cd571b9a16f002a8a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd96b4e2dbe471bbf3e743cd571b9a16f002a8a7"}], "stats": {"total": 34, "additions": 26, "deletions": 8}, "files": [{"sha": "d9bf69af0b52706936692b01001b8942c870387c", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0e99c90ea5815453c746368d9f66e485b40680/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0e99c90ea5815453c746368d9f66e485b40680/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=5b0e99c90ea5815453c746368d9f66e485b40680", "patch": "@@ -1388,6 +1388,8 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n tree\n Function::make_receiver_parm_decl(Gogo* gogo, Named_object* no, tree var_decl)\n {\n+  if (var_decl == error_mark_node)\n+    return error_mark_node;\n   // If the function takes the address of a receiver which is passed\n   // by value, then we will have an INDIRECT_REF here.  We need to get\n   // the real variable.\n@@ -1402,6 +1404,8 @@ Function::make_receiver_parm_decl(Gogo* gogo, Named_object* no, tree var_decl)\n     {\n       gcc_assert(is_in_heap);\n       var_decl = TREE_OPERAND(var_decl, 0);\n+      if (var_decl == error_mark_node)\n+\treturn error_mark_node;\n       gcc_assert(POINTER_TYPE_P(TREE_TYPE(var_decl)));\n       val_type = TREE_TYPE(TREE_TYPE(var_decl));\n     }\n@@ -1460,9 +1464,14 @@ Function::make_receiver_parm_decl(Gogo* gogo, Named_object* no, tree var_decl)\n tree\n Function::copy_parm_to_heap(Gogo* gogo, Named_object* no, tree ref)\n {\n+  if (ref == error_mark_node)\n+    return error_mark_node;\n+\n   gcc_assert(TREE_CODE(ref) == INDIRECT_REF);\n \n   tree var_decl = TREE_OPERAND(ref, 0);\n+  if (var_decl == error_mark_node)\n+    return error_mark_node;\n   gcc_assert(TREE_CODE(var_decl) == VAR_DECL);\n   source_location loc = DECL_SOURCE_LOCATION(var_decl);\n \n@@ -1523,21 +1532,30 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \t      tree var = *pp;\n \t      if (TREE_CODE(var) == INDIRECT_REF)\n \t\tvar = TREE_OPERAND(var, 0);\n-\t      gcc_assert(TREE_CODE(var) == VAR_DECL);\n-\t      DECL_CHAIN(var) = declare_vars;\n-\t      declare_vars = var;\n+\t      if (var != error_mark_node)\n+\t\t{\n+\t\t  gcc_assert(TREE_CODE(var) == VAR_DECL);\n+\t\t  DECL_CHAIN(var) = declare_vars;\n+\t\t  declare_vars = var;\n+\t\t}\n \t      *pp = parm_decl;\n \t    }\n \t  else if ((*p)->var_value()->is_in_heap())\n \t    {\n \t      // If we take the address of a parameter, then we need\n \t      // to copy it into the heap.\n \t      tree parm_decl = this->copy_parm_to_heap(gogo, *p, *pp);\n-\t      gcc_assert(TREE_CODE(*pp) == INDIRECT_REF);\n-\t      tree var_decl = TREE_OPERAND(*pp, 0);\n-\t      gcc_assert(TREE_CODE(var_decl) == VAR_DECL);\n-\t      DECL_CHAIN(var_decl) = declare_vars;\n-\t      declare_vars = var_decl;\n+\t      if (*pp != error_mark_node)\n+\t\t{\n+\t\t  gcc_assert(TREE_CODE(*pp) == INDIRECT_REF);\n+\t\t  tree var_decl = TREE_OPERAND(*pp, 0);\n+\t\t  if (var_decl != error_mark_node)\n+\t\t    {\n+\t\t      gcc_assert(TREE_CODE(var_decl) == VAR_DECL);\n+\t\t      DECL_CHAIN(var_decl) = declare_vars;\n+\t\t      declare_vars = var_decl;\n+\t\t    }\n+\t\t}\n \t      *pp = parm_decl;\n \t    }\n "}]}