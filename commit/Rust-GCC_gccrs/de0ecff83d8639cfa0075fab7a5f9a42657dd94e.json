{"sha": "de0ecff83d8639cfa0075fab7a5f9a42657dd94e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUwZWNmZjgzZDg2MzljZmEwMDc1ZmFiN2E1ZjlhNDI2NTdkZDk0ZQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2018-01-22T19:36:18Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2018-01-22T19:36:18Z"}, "message": "re PR target/83862 (powerpc: ICE in signbit testcase)\n\n[gcc]\n2018-01-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/83862\n\t* config/rs6000/rs6000-protos.h (rs6000_split_signbit): Delete,\n\tno longer used.\n\t* config/rs6000/rs6000.c (rs6000_split_signbit): Likewise.\n\t* config/rs6000/rs6000.md (signbit<mode>2): Change code for IEEE\n\t128-bit to produce an UNSPEC move to get the double word with the\n\tsignbit and then a shift directly to do signbit.\n\t(signbit<mode>2_dm): Replace old IEEE 128-bit signbit\n\timplementation with a new version that just does either a direct\n\tmove or a regular move.  Move memory interface to separate insns.\n\tMove insns so they are next to the expander.\n\t(signbit<mode>2_dm_mem_be): New combiner insns to combine load\n\twith signbit move.  Split big and little endian case.\n\t(signbit<mode>2_dm_mem_le): Likewise.\n\t(signbit<mode>2_dm_<su>ext): Delete, no longer used.\n\t(signbit<mode>2_dm2): Likewise.\n\n[gcc/testsuite]\n2018-01-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/83862\n\t* gcc.target/powerpc/pr83862.c: New test.\n\nFrom-SVN: r256959", "tree": {"sha": "95c285569c28af1b5a5b74b11206c8095f905878", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95c285569c28af1b5a5b74b11206c8095f905878"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de0ecff83d8639cfa0075fab7a5f9a42657dd94e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de0ecff83d8639cfa0075fab7a5f9a42657dd94e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de0ecff83d8639cfa0075fab7a5f9a42657dd94e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de0ecff83d8639cfa0075fab7a5f9a42657dd94e/comments", "author": null, "committer": null, "parents": [{"sha": "bc8b0d04284de4288cae4e4ab3bc2d6c36d36245", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc8b0d04284de4288cae4e4ab3bc2d6c36d36245", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc8b0d04284de4288cae4e4ab3bc2d6c36d36245"}], "stats": {"total": 221, "additions": 127, "deletions": 94}, "files": [{"sha": "bfcf4dada09b003ed888d8ba94b88ebf89f2b7b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de0ecff83d8639cfa0075fab7a5f9a42657dd94e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de0ecff83d8639cfa0075fab7a5f9a42657dd94e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de0ecff83d8639cfa0075fab7a5f9a42657dd94e", "patch": "@@ -1,3 +1,22 @@\n+2018-01-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/83862\n+\t* config/rs6000/rs6000-protos.h (rs6000_split_signbit): Delete,\n+\tno longer used.\n+\t* config/rs6000/rs6000.c (rs6000_split_signbit): Likewise.\n+\t* config/rs6000/rs6000.md (signbit<mode>2): Change code for IEEE\n+\t128-bit to produce an UNSPEC move to get the double word with the\n+\tsignbit and then a shift directly to do signbit.\n+\t(signbit<mode>2_dm): Replace old IEEE 128-bit signbit\n+\timplementation with a new version that just does either a direct\n+\tmove or a regular move.  Move memory interface to separate insns.\n+\tMove insns so they are next to the expander.\n+\t(signbit<mode>2_dm_mem_be): New combiner insns to combine load\n+\twith signbit move.  Split big and little endian case.\n+\t(signbit<mode>2_dm_mem_le): Likewise.\n+\t(signbit<mode>2_dm_<su>ext): Delete, no longer used.\n+\t(signbit<mode>2_dm2): Likewise.\n+\n 2018-01-22  Sebastian Perta  <sebastian.perta@renesas.com>\n \n \t* config/rl78/rl78.md: New define_expand \"anddi3\"."}, {"sha": "3cb5ee8d82ce05c22d388bc62c8bdfc4d16c1f07", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de0ecff83d8639cfa0075fab7a5f9a42657dd94e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de0ecff83d8639cfa0075fab7a5f9a42657dd94e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=de0ecff83d8639cfa0075fab7a5f9a42657dd94e", "patch": "@@ -132,7 +132,6 @@ extern int rs6000_emit_cmove (rtx, rtx, rtx, rtx);\n extern int rs6000_emit_int_cmove (rtx, rtx, rtx, rtx);\n extern int rs6000_emit_vector_cond_expr (rtx, rtx, rtx, rtx, rtx, rtx);\n extern void rs6000_emit_minmax (rtx, enum rtx_code, rtx, rtx);\n-extern void rs6000_split_signbit (rtx, rtx);\n extern void rs6000_expand_atomic_compare_and_swap (rtx op[]);\n extern rtx swap_endian_selector_for_mode (machine_mode mode);\n "}, {"sha": "b457b2a986f4e4737ca6ed3adbefad4422c21ed0", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de0ecff83d8639cfa0075fab7a5f9a42657dd94e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de0ecff83d8639cfa0075fab7a5f9a42657dd94e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=de0ecff83d8639cfa0075fab7a5f9a42657dd94e", "patch": "@@ -23424,49 +23424,6 @@ rs6000_emit_minmax (rtx dest, enum rtx_code code, rtx op0, rtx op1)\n     emit_move_insn (dest, target);\n }\n \n-/* Split a signbit operation on 64-bit machines with direct move.  Also allow\n-   for the value to come from memory or if it is already loaded into a GPR.  */\n-\n-void\n-rs6000_split_signbit (rtx dest, rtx src)\n-{\n-  machine_mode d_mode = GET_MODE (dest);\n-  machine_mode s_mode = GET_MODE (src);\n-  rtx dest_di = (d_mode == DImode) ? dest : gen_lowpart (DImode, dest);\n-  rtx shift_reg = dest_di;\n-\n-  gcc_assert (FLOAT128_IEEE_P (s_mode) && TARGET_POWERPC64);\n-\n-  if (MEM_P (src))\n-    {\n-      rtx mem = (WORDS_BIG_ENDIAN\n-\t\t ? adjust_address (src, DImode, 0)\n-\t\t : adjust_address (src, DImode, 8));\n-      emit_insn (gen_rtx_SET (dest_di, mem));\n-    }\n-\n-  else\n-    {\n-      unsigned int r = reg_or_subregno (src);\n-\n-      if (INT_REGNO_P (r))\n-\tshift_reg = gen_rtx_REG (DImode, r + (BYTES_BIG_ENDIAN == 0));\n-\n-      else\n-\t{\n-\t  /* Generate the special mfvsrd instruction to get it in a GPR.  */\n-\t  gcc_assert (VSX_REGNO_P (r));\n-\t  if (s_mode == KFmode)\n-\t    emit_insn (gen_signbitkf2_dm2 (dest_di, src));\n-\t  else\n-\t    emit_insn (gen_signbittf2_dm2 (dest_di, src));\n-\t}\n-    }\n-\n-  emit_insn (gen_lshrdi3 (dest_di, shift_reg, GEN_INT (63)));\n-  return;\n-}\n-\n /* A subroutine of the atomic operation splitters.  Jump to LABEL if\n    COND is true.  Mark the jump as unlikely to be taken.  */\n "}, {"sha": "37075667e1270d9c2634e538e38e1e7f5ff49ed5", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 69, "deletions": 50, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de0ecff83d8639cfa0075fab7a5f9a42657dd94e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de0ecff83d8639cfa0075fab7a5f9a42657dd94e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=de0ecff83d8639cfa0075fab7a5f9a42657dd94e", "patch": "@@ -4779,12 +4779,19 @@\n {\n   if (FLOAT128_IEEE_P (<MODE>mode))\n     {\n+      rtx dest = operands[0];\n+      rtx src = operands[1];\n+      rtx tmp = gen_reg_rtx (DImode);\n+      rtx dest_di = gen_lowpart (DImode, dest);\n+\n       if (<MODE>mode == KFmode)\n-\temit_insn (gen_signbitkf2_dm (operands[0], operands[1]));\n+\temit_insn (gen_signbitkf2_dm (tmp, src));\n       else if (<MODE>mode == TFmode)\n-\temit_insn (gen_signbittf2_dm (operands[0], operands[1]));\n+\temit_insn (gen_signbittf2_dm (tmp, src));\n       else\n \tgcc_unreachable ();\n+\n+      emit_insn (gen_lshrdi3 (dest_di, tmp, GEN_INT (63)));\n       DONE;\n     }\n   operands[2] = gen_reg_rtx (DFmode);\n@@ -4805,6 +4812,66 @@\n     }\n })\n \n+;; Optimize IEEE 128-bit signbit on 64-bit systems with direct move to avoid\n+;; multiple direct moves.  If we used a SUBREG:DI of the Floa128 type, the\n+;; register allocator would typically move the entire _Float128 item to GPRs (2\n+;; instructions on ISA 3.0, 3-4 instructions on ISA 2.07).\n+;;\n+;; After register allocation, if the _Float128 had originally been in GPRs, the\n+;; split allows the post reload phases to eliminate the move, and do the shift\n+;; directly with the register that contains the signbit.\n+(define_insn_and_split \"signbit<mode>2_dm\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(unspec:DI [(match_operand:SIGNBIT 1 \"gpc_reg_operand\" \"wa,r\")]\n+\t\t   UNSPEC_SIGNBIT))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"@\n+   mfvsrd %0,%x1\n+   #\"\n+  \"&& reload_completed && int_reg_operand (operands[1], <MODE>mode)\"\n+  [(set (match_dup 0)\n+\t(match_dup 2))]\n+{\n+  operands[2] = gen_highpart (DImode, operands[1]);\n+}\n+ [(set_attr \"type\" \"mftgpr,*\")])\n+\n+;; Optimize IEEE 128-bit signbit on to avoid loading the value into a vector\n+;; register and then doing a direct move if the value comes from memory.  On\n+;; little endian, we have to load the 2nd double-word to get the sign bit.\n+(define_insn_and_split \"*signbit<mode>2_dm_mem\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=b\")\n+\t(unspec:DI [(match_operand:SIGNBIT 1 \"memory_operand\" \"m\")]\n+\t\t   UNSPEC_SIGNBIT))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0)\n+\t(match_dup 2))]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx addr = XEXP (src, 0);\n+\n+  if (WORDS_BIG_ENDIAN)\n+    operands[2] = adjust_address (src, DImode, 0);\n+\n+  else if (REG_P (addr) || SUBREG_P (addr))\n+    operands[2] = adjust_address (src, DImode, 8);\n+\n+  else if (GET_CODE (addr) == PLUS && REG_P (XEXP (addr, 0))\n+\t   && CONST_INT_P (XEXP (addr, 1)) && mem_operand_gpr (src, DImode))\n+    operands[2] = adjust_address (src, DImode, 8);\n+\n+  else\n+    {\n+      rtx tmp = can_create_pseudo_p () ? gen_reg_rtx (DImode) : dest;\n+      emit_insn (gen_rtx_SET (tmp, addr));\n+      operands[2] = change_address (src, DImode,\n+\t\t\t\t    gen_rtx_PLUS (DImode, tmp, GEN_INT (8)));\n+    }\n+})\n+\n (define_expand \"copysign<mode>3\"\n   [(set (match_dup 3)\n         (abs:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))\n@@ -4834,54 +4901,6 @@\n    operands[5] = CONST0_RTX (<MODE>mode);\n   })\n \n-;; Optimize signbit on 64-bit systems with direct move to avoid doing the store\n-;; and load.\n-(define_insn_and_split \"signbit<mode>2_dm\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r\")\n-\t(unspec:SI\n-\t [(match_operand:SIGNBIT 1 \"input_operand\" \"wa,m,r\")]\n-\t UNSPEC_SIGNBIT))]\n-  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-{\n-  rs6000_split_signbit (operands[0], operands[1]);\n-  DONE;\n-}\n- [(set_attr \"length\" \"8,8,4\")\n-  (set_attr \"type\" \"mftgpr,load,integer\")])\n-\n-(define_insn_and_split \"*signbit<mode>2_dm_<su>ext\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r\")\n-\t(any_extend:DI\n-\t (unspec:SI\n-\t  [(match_operand:SIGNBIT 1 \"input_operand\" \"wa,m,r\")]\n-\t  UNSPEC_SIGNBIT)))]\n-  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-{\n-  rs6000_split_signbit (operands[0], operands[1]);\n-  DONE;\n-}\n- [(set_attr \"length\" \"8,8,4\")\n-  (set_attr \"type\" \"mftgpr,load,integer\")])\n-\n-;; TARGET_MODES_TIEABLE_P doesn't allow DImode to be tied with the various\n-;; floating point types, which makes normal SUBREG's problematical.  Instead\n-;; use a special pattern to avoid using a normal movdi.\n-(define_insn \"signbit<mode>2_dm2\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(unspec:DI [(match_operand:SIGNBIT 1 \"gpc_reg_operand\" \"wa\")\n-\t\t    (const_int 0)]\n-\t\t   UNSPEC_SIGNBIT))]\n-  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n-  \"mfvsrd %0,%x1\"\n- [(set_attr \"type\" \"mftgpr\")])\n-\n-\n ;; Use an unspec rather providing an if-then-else in RTL, to prevent the\n ;; compiler from optimizing -0.0\n (define_insn \"copysign<mode>3_fcpsgn\""}, {"sha": "485079a7cb159f744730ea1b6d6d84cdc9229fdf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de0ecff83d8639cfa0075fab7a5f9a42657dd94e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de0ecff83d8639cfa0075fab7a5f9a42657dd94e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=de0ecff83d8639cfa0075fab7a5f9a42657dd94e", "patch": "@@ -1,3 +1,8 @@\n+2018-01-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/83862\n+\t* gcc.target/powerpc/pr83862.c: New test.\n+\n 2018-01-22  Carl Love  <cel@us.ibm.com>\n \t* gcc.target/powerpc/powerpc.exp: Add torture tests for\n \tbuiltins-4-runnable.c, builtins-6-runnable.c,"}, {"sha": "3cadb57962b59e2df40e6749ba90820be35d4da0", "filename": "gcc/testsuite/gcc.target/powerpc/pr83862.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de0ecff83d8639cfa0075fab7a5f9a42657dd94e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr83862.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de0ecff83d8639cfa0075fab7a5f9a42657dd94e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr83862.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr83862.c?ref=de0ecff83d8639cfa0075fab7a5f9a42657dd94e", "patch": "@@ -0,0 +1,34 @@\n+/* PR target/83862.c */\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-require-effective-target ppc_float128_sw } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mpower8-vector -O2 -mabi=ieeelongdouble -Wno-psabi\" } */\n+\n+/* On little endian systems, optimizing signbit of IEEE 128-bit values from\n+   memory could abort if the memory address was indexed (reg+reg).  The\n+   optimization is only on 64-bit machines with direct move.\n+\n+   Compile with -g -O2 -mabi=ieeelongdouble -Wno-psabi.  */\n+\n+#ifndef TYPE\n+#define TYPE long double\n+#endif\n+\n+int sbr (TYPE a) { return __builtin_signbit (a); }\n+int sbm (TYPE *a) { return __builtin_signbit (*a); }\n+int sbo (TYPE *a) { return __builtin_signbit (a[4]); }\n+int sbi (TYPE *a, unsigned long n) { return __builtin_signbit (a[n]); }\n+void sbs (int *p, TYPE a) { *p = __builtin_signbit (a); }\n+\n+/* On big endian systems, this will generate 2 LDs and 1 LDX, while on\n+   little endian systems, this will generate 3 LDs and an ADD.  */\n+\n+/* { dg-final { scan-assembler-times {\\mldx?\\M}    3 } } */\n+/* { dg-final { scan-assembler-times {\\mmfvsrd\\M}  2 } } */\n+/* { dg-final { scan-assembler-times {\\msrdi\\M}    5 } } */\n+/* { dg-final { scan-assembler-not   {\\mmfvsrld\\M}   } } */\n+/* { dg-final { scan-assembler-not   {\\mstxvx?\\M}    } } */\n+/* { dg-final { scan-assembler-not   {\\mstxvw4x\\M}   } } */\n+/* { dg-final { scan-assembler-not   {\\mstxvd2x\\M}   } } */\n+/* { dg-final { scan-assembler-not   {\\mstvx\\M}      } } */\n+"}]}