{"sha": "da226db23cdd083ccebaadf5cf71f525decbd20e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGEyMjZkYjIzY2RkMDgzY2NlYmFhZGY1Y2Y3MWY1MjVkZWNiZDIwZQ==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2013-05-04T21:19:08Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2013-05-04T21:19:08Z"}, "message": "predicates.md (reg_or_add_cint_operand, [...]): Delete \"HOST_BITS_PER_WIDE_INT == 32\" case.\n\n       * config/rs6000/predicates.md (reg_or_add_cint_operand,\n       reg_or_sub_cint_operand): Delete \"HOST_BITS_PER_WIDE_INT == 32\" case.\n       (reg_or_logical_cint_operand, easy_fp_constant,\n       logical_const_operand): Delete \"CONST_DOUBLE\" case.\n       * config/rs6000/rs6000.c (num_insns_constant_wide): Delete\n       \"HOST_BITS_PER_WIDE_INT == 64\" test.\n       (num_insns_constant): Ditto.  Delete CONST_DOUBLE DImode/VOIDmode\n       case.\n       (build_mask64_2_operands): Delete \"HOST_BITS_PER_WIDE_INT >= 64\" test.\n       (rs6000_emit_set_const): Delete CONST_DOUBLE case.\n       (rs6000_emit_set_long_const): Delete \"HOST_BITS_PER_WIDE_INT >= 64\"\n       test.\n       (includes_rldic_lshift_p, includes_rldicr_lshift_p): Delete\n       CONST_DOUBLE DImode/VOIDmode case.\n       (INT_P, INT_LOWPART): Delete CONST_DOUBLE case.\n       (print_operand): Delete \"HOST_BITS_PER_WIDE_INT == 32\" case.  Delete\n       CONST_DOUBLE VOIDmode case.\n       (output_toc): Delete \"HOST_BITS_PER_WIDE_INT == 32\" case.\n       (rs6000_rtx_costs): Delete CONST_DOUBLE DImode/VOIDmode case.\n       * config/rs6000/rs6000.md (iordi3, xordi3, splitter for these):\n       Delete CONST_DOUBLE case.\n       (splitters for mov FMOVE64 const_double): Delete\n       \"HOST_BITS_PER_WIDE_INT == 32\" case.  Delete\n       \"HOST_BITS_PER_WIDE_INT >= 64\" test.\n       (splitter for mov DI const_int): Delete \"HOST_BITS_PER_WIDE_INT == 32\"\n       case.\n       (mov DI const_double): Delete.\n\nFrom-SVN: r198601", "tree": {"sha": "7a312f590dc0ad38fc894e6514c90a29df98fe0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a312f590dc0ad38fc894e6514c90a29df98fe0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da226db23cdd083ccebaadf5cf71f525decbd20e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da226db23cdd083ccebaadf5cf71f525decbd20e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da226db23cdd083ccebaadf5cf71f525decbd20e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da226db23cdd083ccebaadf5cf71f525decbd20e/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "efa5b9b314a6e833980952147449d63128c29999", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efa5b9b314a6e833980952147449d63128c29999", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efa5b9b314a6e833980952147449d63128c29999"}], "stats": {"total": 363, "additions": 63, "deletions": 300}, "files": [{"sha": "8db037d8e374608289f3097eafd9466e24e52e2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da226db23cdd083ccebaadf5cf71f525decbd20e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da226db23cdd083ccebaadf5cf71f525decbd20e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da226db23cdd083ccebaadf5cf71f525decbd20e", "patch": "@@ -1,3 +1,33 @@\n+2013-05-04  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/predicates.md (reg_or_add_cint_operand,\n+\treg_or_sub_cint_operand): Delete \"HOST_BITS_PER_WIDE_INT == 32\" case.\n+\t(reg_or_logical_cint_operand, easy_fp_constant,\n+\tlogical_const_operand): Delete \"CONST_DOUBLE\" case.\n+\t* config/rs6000/rs6000.c (num_insns_constant_wide): Delete\n+\t\"HOST_BITS_PER_WIDE_INT == 64\" test.\n+\t(num_insns_constant): Ditto.  Delete CONST_DOUBLE DImode/VOIDmode\n+\tcase.\n+\t(build_mask64_2_operands): Delete \"HOST_BITS_PER_WIDE_INT >= 64\" test.\n+\t(rs6000_emit_set_const): Delete CONST_DOUBLE case.\n+\t(rs6000_emit_set_long_const): Delete \"HOST_BITS_PER_WIDE_INT >= 64\"\n+\ttest.\n+\t(includes_rldic_lshift_p, includes_rldicr_lshift_p): Delete\n+\tCONST_DOUBLE DImode/VOIDmode case.\n+\t(INT_P, INT_LOWPART): Delete CONST_DOUBLE case.\n+\t(print_operand): Delete \"HOST_BITS_PER_WIDE_INT == 32\" case.  Delete\n+\tCONST_DOUBLE VOIDmode case.\n+\t(output_toc): Delete \"HOST_BITS_PER_WIDE_INT == 32\" case.\n+\t(rs6000_rtx_costs): Delete CONST_DOUBLE DImode/VOIDmode case.\n+\t* config/rs6000/rs6000.md (iordi3, xordi3, splitter for these):\n+\tDelete CONST_DOUBLE case.\n+\t(splitters for mov FMOVE64 const_double): Delete\n+\t\"HOST_BITS_PER_WIDE_INT == 32\" case.  Delete\n+\t\"HOST_BITS_PER_WIDE_INT >= 64\" test.\n+\t(splitter for mov DI const_int): Delete \"HOST_BITS_PER_WIDE_INT == 32\"\n+\tcase.\n+\t(mov DI const_double): Delete.\n+\n 2013-05-04  Jakub Jelinek  <jakub@redhat.com>\n \n \t* combine.c (combine_simplify_rtx) <case SUBREG>: If nonzero_bits"}, {"sha": "78ec1b209130a77905487730143892fa8fd7dec6", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 10, "deletions": 39, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da226db23cdd083ccebaadf5cf71f525decbd20e/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da226db23cdd083ccebaadf5cf71f525decbd20e/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=da226db23cdd083ccebaadf5cf71f525decbd20e", "patch": "@@ -279,22 +279,17 @@\n ;; or non-special register.\n (define_predicate \"reg_or_add_cint_operand\"\n   (if_then_else (match_code \"const_int\")\n-    (match_test \"(HOST_BITS_PER_WIDE_INT == 32\n-\t\t  && (mode == SImode || INTVAL (op) < 0x7fff8000))\n-\t\t || ((unsigned HOST_WIDE_INT) (INTVAL (op) + 0x80008000)\n-\t\t     < (unsigned HOST_WIDE_INT) 0x100000000ll)\")\n+    (match_test \"(unsigned HOST_WIDE_INT) (INTVAL (op) + 0x80008000)\n+\t\t < (unsigned HOST_WIDE_INT) 0x100000000ll\")\n     (match_operand 0 \"gpc_reg_operand\")))\n \n ;; Return 1 if op is a constant integer valid for subtraction\n ;; or non-special register.\n (define_predicate \"reg_or_sub_cint_operand\"\n   (if_then_else (match_code \"const_int\")\n-    (match_test \"(HOST_BITS_PER_WIDE_INT == 32\n-\t\t  && (mode == SImode || - INTVAL (op) < 0x7fff8000))\n-\t\t || ((unsigned HOST_WIDE_INT) (- INTVAL (op) \n-\t\t\t\t\t       + (mode == SImode\n-\t\t\t\t\t\t  ? 0x80000000 : 0x80008000))\n-\t\t     < (unsigned HOST_WIDE_INT) 0x100000000ll)\")\n+    (match_test \"(unsigned HOST_WIDE_INT)\n+\t\t   (- INTVAL (op) + (mode == SImode ? 0x80000000 : 0x80008000))\n+\t\t < (unsigned HOST_WIDE_INT) 0x100000000ll\")\n     (match_operand 0 \"gpc_reg_operand\")))\n \n ;; Return 1 if op is any 32-bit unsigned constant integer\n@@ -305,11 +300,7 @@\n \t\t  && INTVAL (op) >= 0)\n \t\t || ((INTVAL (op) & GET_MODE_MASK (mode)\n \t\t      & (~ (unsigned HOST_WIDE_INT) 0xffffffff)) == 0)\")\n-    (if_then_else (match_code \"const_double\")\n-      (match_test \"GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT\n-\t\t   && mode == DImode\n-\t\t   && CONST_DOUBLE_HIGH (op) == 0\")\n-      (match_operand 0 \"gpc_reg_operand\"))))\n+    (match_operand 0 \"gpc_reg_operand\")))\n \n ;; Return 1 if operand is a CONST_DOUBLE that can be set in a register\n ;; with no more than one instruction per word.\n@@ -403,9 +394,7 @@\n       return num_insns_constant_wide (k[0]) == 1;\n \n   case DImode:\n-    return ((TARGET_POWERPC64\n-\t     && GET_CODE (op) == CONST_DOUBLE && CONST_DOUBLE_LOW (op) == 0)\n-\t    || (num_insns_constant (op, DImode) <= 2));\n+    return (num_insns_constant (op, DImode) <= 2);\n \n   case SImode:\n     return 1;\n@@ -605,29 +594,11 @@\n ;; Return 1 if the operand is a constant that can be used as the operand\n ;; of an OR or XOR.\n (define_predicate \"logical_const_operand\"\n-  (match_code \"const_int,const_double\")\n+  (match_code \"const_int\")\n {\n-  HOST_WIDE_INT opl, oph;\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      opl = INTVAL (op) & GET_MODE_MASK (mode);\n-\n-      if (HOST_BITS_PER_WIDE_INT <= 32\n-\t  && GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT && opl < 0)\n-\treturn 0;\n-    }\n-  else if (GET_CODE (op) == CONST_DOUBLE)\n-    {\n-      gcc_assert (GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT);\n+  HOST_WIDE_INT opl;\n \n-      opl = CONST_DOUBLE_LOW (op);\n-      oph = CONST_DOUBLE_HIGH (op);\n-      if (oph != 0)\n-\treturn 0;\n-    }\n-  else\n-    return 0;\n+  opl = INTVAL (op) & GET_MODE_MASK (mode);\n \n   return ((opl & ~ (unsigned HOST_WIDE_INT) 0xffff) == 0\n \t  || (opl & ~ (unsigned HOST_WIDE_INT) 0xffff0000) == 0);"}, {"sha": "28f316080f8b75896b1342b83c0bed098bdece97", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 15, "deletions": 192, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da226db23cdd083ccebaadf5cf71f525decbd20e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da226db23cdd083ccebaadf5cf71f525decbd20e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=da226db23cdd083ccebaadf5cf71f525decbd20e", "patch": "@@ -4258,7 +4258,6 @@ num_insns_constant_wide (HOST_WIDE_INT value)\n \t   && (value >> 31 == -1 || value >> 31 == 0))\n     return 1;\n \n-#if HOST_BITS_PER_WIDE_INT == 64\n   else if (TARGET_POWERPC64)\n     {\n       HOST_WIDE_INT low  = ((value & 0xffffffff) ^ 0x80000000) - 0x80000000;\n@@ -4277,7 +4276,6 @@ num_insns_constant_wide (HOST_WIDE_INT value)\n \treturn (num_insns_constant_wide (high)\n \t\t+ num_insns_constant_wide (low) + 1);\n     }\n-#endif\n \n   else\n     return 2;\n@@ -4291,12 +4289,10 @@ num_insns_constant (rtx op, enum machine_mode mode)\n   switch (GET_CODE (op))\n     {\n     case CONST_INT:\n-#if HOST_BITS_PER_WIDE_INT == 64\n       if ((INTVAL (op) >> 31) != 0 && (INTVAL (op) >> 31) != -1\n \t  && mask64_operand (op, mode))\n \treturn 2;\n       else\n-#endif\n \treturn num_insns_constant_wide (INTVAL (op));\n \n       case CONST_DOUBLE:\n@@ -4313,24 +4309,16 @@ num_insns_constant (rtx op, enum machine_mode mode)\n \t    return num_insns_constant_wide ((HOST_WIDE_INT) l);\n \t  }\n \n-\tif (mode == VOIDmode || mode == DImode)\n-\t  {\n-\t    high = CONST_DOUBLE_HIGH (op);\n-\t    low  = CONST_DOUBLE_LOW (op);\n-\t  }\n-\telse\n-\t  {\n-\t    long l[2];\n-\t    REAL_VALUE_TYPE rv;\n+\tlong l[2];\n+\tREAL_VALUE_TYPE rv;\n \n-\t    REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-\t    if (DECIMAL_FLOAT_MODE_P (mode))\n-\t      REAL_VALUE_TO_TARGET_DECIMAL64 (rv, l);\n-\t    else\n-\t      REAL_VALUE_TO_TARGET_DOUBLE (rv, l);\n-\t    high = l[WORDS_BIG_ENDIAN == 0];\n-\t    low  = l[WORDS_BIG_ENDIAN != 0];\n-\t  }\n+\tREAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n+\tif (DECIMAL_FLOAT_MODE_P (mode))\n+\t  REAL_VALUE_TO_TARGET_DECIMAL64 (rv, l);\n+\telse\n+\t  REAL_VALUE_TO_TARGET_DOUBLE (rv, l);\n+\thigh = l[WORDS_BIG_ENDIAN == 0];\n+\tlow  = l[WORDS_BIG_ENDIAN != 0];\n \n \tif (TARGET_32BIT)\n \t  return (num_insns_constant_wide (low)\n@@ -5031,7 +5019,6 @@ rs6000_expand_vector_extract (rtx target, rtx vec, int elt)\n void\n build_mask64_2_operands (rtx in, rtx *out)\n {\n-#if HOST_BITS_PER_WIDE_INT >= 64\n   unsigned HOST_WIDE_INT c, lsb, m1, m2;\n   int shift;\n \n@@ -5088,11 +5075,6 @@ build_mask64_2_operands (rtx in, rtx *out)\n   out[1] = GEN_INT (m1);\n   out[2] = GEN_INT (shift);\n   out[3] = GEN_INT (m2);\n-#else\n-  (void)in;\n-  (void)out;\n-  gcc_unreachable ();\n-#endif\n }\n \n /* Return TRUE if OP is an invalid SUBREG operation on the e500.  */\n@@ -7051,16 +7033,6 @@ rs6000_emit_set_const (rtx dest, enum machine_mode mode,\n \t  c1 = -(c0 < 0);\n \t  break;\n \n-\tcase CONST_DOUBLE:\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-\t  c0 = CONST_DOUBLE_LOW (source);\n-\t  c1 = -(c0 < 0);\n-#else\n-\t  c0 = CONST_DOUBLE_LOW (source);\n-\t  c1 = CONST_DOUBLE_HIGH (source);\n-#endif\n-\t  break;\n-\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -7104,9 +7076,7 @@ rs6000_emit_set_long_const (rtx dest, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n \n       ud1 = c1 & 0xffff;\n       ud2 = (c1 & 0xffff0000) >> 16;\n-#if HOST_BITS_PER_WIDE_INT >= 64\n       c2 = c1 >> 32;\n-#endif\n       ud3 = c2 & 0xffff;\n       ud4 = (c2 & 0xffff0000) >> 16;\n \n@@ -13560,60 +13530,6 @@ includes_rldic_lshift_p (rtx shiftop, rtx andop)\n       lsb = c & -c;\n       return c == -lsb;\n     }\n-  else if (GET_CODE (andop) == CONST_DOUBLE\n-\t   && (GET_MODE (andop) == VOIDmode || GET_MODE (andop) == DImode))\n-    {\n-      HOST_WIDE_INT low, high, lsb;\n-      HOST_WIDE_INT shift_mask_low, shift_mask_high;\n-\n-      low = CONST_DOUBLE_LOW (andop);\n-      if (HOST_BITS_PER_WIDE_INT < 64)\n-\thigh = CONST_DOUBLE_HIGH (andop);\n-\n-      if ((low == 0 && (HOST_BITS_PER_WIDE_INT >= 64 || high == 0))\n-\t  || (low == ~0 && (HOST_BITS_PER_WIDE_INT >= 64 || high == ~0)))\n-\treturn 0;\n-\n-      if (HOST_BITS_PER_WIDE_INT < 64 && low == 0)\n-\t{\n-\t  shift_mask_high = ~0;\n-\t  if (INTVAL (shiftop) > 32)\n-\t    shift_mask_high <<= INTVAL (shiftop) - 32;\n-\n-\t  lsb = high & -high;\n-\n-\t  if (-lsb != shift_mask_high || INTVAL (shiftop) < 32)\n-\t    return 0;\n-\n-\t  high = ~high;\n-\t  high &= -lsb;\n-\n-\t  lsb = high & -high;\n-\t  return high == -lsb;\n-\t}\n-\n-      shift_mask_low = ~0;\n-      shift_mask_low <<= INTVAL (shiftop);\n-\n-      lsb = low & -low;\n-\n-      if (-lsb != shift_mask_low)\n-\treturn 0;\n-\n-      if (HOST_BITS_PER_WIDE_INT < 64)\n-\thigh = ~high;\n-      low = ~low;\n-      low &= -lsb;\n-\n-      if (HOST_BITS_PER_WIDE_INT < 64 && low == 0)\n-\t{\n-\t  lsb = high & -high;\n-\t  return high == -lsb;\n-\t}\n-\n-      lsb = low & -low;\n-      return low == -lsb && (HOST_BITS_PER_WIDE_INT >= 64 || high == ~0);\n-    }\n   else\n     return 0;\n }\n@@ -13644,46 +13560,6 @@ includes_rldicr_lshift_p (rtx shiftop, rtx andop)\n       /* Check we have all 1's above the transition, and reject all 1's.  */\n       return c == -lsb && lsb != 1;\n     }\n-  else if (GET_CODE (andop) == CONST_DOUBLE\n-\t   && (GET_MODE (andop) == VOIDmode || GET_MODE (andop) == DImode))\n-    {\n-      HOST_WIDE_INT low, lsb, shift_mask_low;\n-\n-      low = CONST_DOUBLE_LOW (andop);\n-\n-      if (HOST_BITS_PER_WIDE_INT < 64)\n-\t{\n-\t  HOST_WIDE_INT high, shift_mask_high;\n-\n-\t  high = CONST_DOUBLE_HIGH (andop);\n-\n-\t  if (low == 0)\n-\t    {\n-\t      shift_mask_high = ~0;\n-\t      if (INTVAL (shiftop) > 32)\n-\t\tshift_mask_high <<= INTVAL (shiftop) - 32;\n-\n-\t      lsb = high & -high;\n-\n-\t      if ((lsb & shift_mask_high) == 0)\n-\t\treturn 0;\n-\n-\t      return high == -lsb;\n-\t    }\n-\t  if (high != ~0)\n-\t    return 0;\n-\t}\n-\n-      shift_mask_low = ~0;\n-      shift_mask_low <<= INTVAL (shiftop);\n-\n-      lsb = low & -low;\n-\n-      if ((lsb & shift_mask_low) == 0)\n-\treturn 0;\n-\n-      return low == -lsb && lsb != 1;\n-    }\n   else\n     return 0;\n }\n@@ -14977,11 +14853,9 @@ rs6000_init_machine_status (void)\n \f\n /* These macros test for integers and extract the low-order bits.  */\n #define INT_P(X)  \\\n-((GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE)\t\\\n- && GET_MODE (X) == VOIDmode)\n+(GET_CODE (X) == CONST_INT && GET_MODE (X) == VOIDmode)\n \n-#define INT_LOWPART(X) \\\n-  (GET_CODE (X) == CONST_INT ? INTVAL (X) : CONST_DOUBLE_LOW (X))\n+#define INT_LOWPART(X) INTVAL (X)\n \n int\n extract_MB (rtx op)\n@@ -15544,15 +15418,7 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'W':\n       /* MB value for a PowerPC64 rldic operand.  */\n-      i = clz_hwi (GET_CODE (x) == CONST_INT\n-\t\t   ? INTVAL (x) : CONST_DOUBLE_HIGH (x));\n-\n-#if HOST_BITS_PER_WIDE_INT == 32\n-      if (GET_CODE (x) == CONST_INT && i > 0)\n-\ti += 32;  /* zero-extend high-part was all 0's */\n-      else if (GET_CODE (x) == CONST_DOUBLE && i == 32)\n-\ti = clz_hwi (CONST_DOUBLE_LOW (x)) + 32;\n-#endif\n+      i = clz_hwi (INTVAL (x));\n \n       fprintf (file, \"%d\", i);\n       return;\n@@ -22511,29 +22377,13 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n \t  return;\n \t}\n     }\n-  else if (GET_MODE (x) == VOIDmode\n-\t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE))\n+  else if (GET_MODE (x) == VOIDmode && GET_CODE (x) == CONST_INT)\n     {\n       unsigned HOST_WIDE_INT low;\n       HOST_WIDE_INT high;\n \n-      if (GET_CODE (x) == CONST_DOUBLE)\n-\t{\n-\t  low = CONST_DOUBLE_LOW (x);\n-\t  high = CONST_DOUBLE_HIGH (x);\n-\t}\n-      else\n-#if HOST_BITS_PER_WIDE_INT == 32\n-\t{\n-\t  low = INTVAL (x);\n-\t  high = (low & 0x80000000) ? ~0 : 0;\n-\t}\n-#else\n-\t{\n-\t  low = INTVAL (x) & 0xffffffff;\n-\t  high = (HOST_WIDE_INT) INTVAL (x) >> 32;\n-\t}\n-#endif\n+      low = INTVAL (x) & 0xffffffff;\n+      high = (HOST_WIDE_INT) INTVAL (x) >> 32;\n \n       /* TOC entries are always Pmode-sized, so when big-endian\n \t smaller integer constants in the TOC need to be padded.\n@@ -22549,15 +22399,10 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n \n       if (WORDS_BIG_ENDIAN && POINTER_SIZE > GET_MODE_BITSIZE (mode))\n \t{\n-#if HOST_BITS_PER_WIDE_INT == 32\n-\t  lshift_double (low, high, POINTER_SIZE - GET_MODE_BITSIZE (mode),\n-\t\t\t POINTER_SIZE, &low, &high, 0);\n-#else\n \t  low |= high << 32;\n \t  low <<= POINTER_SIZE - GET_MODE_BITSIZE (mode);\n \t  high = (HOST_WIDE_INT) low >> 32;\n \t  low &= 0xffffffff;\n-#endif\n \t}\n \n       if (TARGET_64BIT)\n@@ -26352,28 +26197,6 @@ rs6000_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       /* FALLTHRU */\n \n     case CONST_DOUBLE:\n-      if (mode == DImode && code == CONST_DOUBLE)\n-\t{\n-\t  if ((outer_code == IOR || outer_code == XOR)\n-\t      && CONST_DOUBLE_HIGH (x) == 0\n-\t      && (CONST_DOUBLE_LOW (x)\n-\t\t  & ~ (unsigned HOST_WIDE_INT) 0xffff) == 0)\n-\t    {\n-\t      *total = 0;\n-\t      return true;\n-\t    }\n-\t  else if ((outer_code == AND && and64_2_operand (x, DImode))\n-\t\t   || ((outer_code == SET\n-\t\t\t|| outer_code == IOR\n-\t\t\t|| outer_code == XOR)\n-\t\t       && CONST_DOUBLE_HIGH (x) == 0))\n-\t    {\n-\t      *total = COSTS_N_INSNS (1);\n-\t      return true;\n-\t    }\n-\t}\n-      /* FALLTHRU */\n-\n     case CONST:\n     case HIGH:\n     case SYMBOL_REF:"}, {"sha": "bdf19f8df471af0e5b3ebb99311115729c85293b", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 8, "deletions": 69, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da226db23cdd083ccebaadf5cf71f525decbd20e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da226db23cdd083ccebaadf5cf71f525decbd20e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=da226db23cdd083ccebaadf5cf71f525decbd20e", "patch": "@@ -8018,20 +8018,9 @@\n \t\t  || rtx_equal_p (operands[0], operands[1]))\n \t\t ? operands[0] : gen_reg_rtx (DImode));\n \n-      if (GET_CODE (operands[2]) == CONST_INT)\n-        {\n-          value = INTVAL (operands[2]);\n-\t  emit_insn (gen_iordi3 (tmp, operands[1],\n-\t\t\t\t GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n-\t}\n-      else\n-        {\n-\t  value = CONST_DOUBLE_LOW (operands[2]);\n-\t  emit_insn (gen_iordi3 (tmp, operands[1],\n-\t\t\t\t immed_double_const (value\n-\t\t\t\t\t\t     & (~ (HOST_WIDE_INT) 0xffff),\n-\t\t\t\t\t\t     0, DImode)));\n-\t}\n+      value = INTVAL (operands[2]);\n+      emit_insn (gen_iordi3 (tmp, operands[1],\n+\t\t\t     GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n \n       emit_insn (gen_iordi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n       DONE;\n@@ -8052,20 +8041,9 @@\n \t\t  || rtx_equal_p (operands[0], operands[1]))\n \t\t ? operands[0] : gen_reg_rtx (DImode));\n \n-      if (GET_CODE (operands[2]) == CONST_INT)\n-        {\n-          value = INTVAL (operands[2]);\n-\t  emit_insn (gen_xordi3 (tmp, operands[1],\n-\t\t\t\t GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n-\t}\n-      else\n-        {\n-\t  value = CONST_DOUBLE_LOW (operands[2]);\n-\t  emit_insn (gen_xordi3 (tmp, operands[1],\n-\t\t\t\t immed_double_const (value\n-\t\t\t\t\t\t     & (~ (HOST_WIDE_INT) 0xffff),\n-\t\t\t\t\t\t     0, DImode)));\n-\t}\n+      value = INTVAL (operands[2]);\n+      emit_insn (gen_xordi3 (tmp, operands[1],\n+\t\t\t     GEN_INT (value & (~ (HOST_WIDE_INT) 0xffff))));\n \n       emit_insn (gen_xordi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n       DONE;\n@@ -8156,19 +8134,8 @@\n {\n   rtx i3,i4;\n \n-  if (GET_CODE (operands[2]) == CONST_DOUBLE)\n-    {\n-      HOST_WIDE_INT value = CONST_DOUBLE_LOW (operands[2]);\n-      i3 = immed_double_const (value & (~ (HOST_WIDE_INT) 0xffff),\n-\t\t\t\t\t0, DImode);\n-      i4 = GEN_INT (value & 0xffff);\n-    }\n-  else\n-    {\n-      i3 = GEN_INT (INTVAL (operands[2])\n-\t\t\t     & (~ (HOST_WIDE_INT) 0xffff));\n-      i4 = GEN_INT (INTVAL (operands[2]) & 0xffff);\n-    }\n+  i3 = GEN_INT (INTVAL (operands[2]) & (~ (HOST_WIDE_INT) 0xffff));\n+  i4 = GEN_INT (INTVAL (operands[2]) & 0xffff);\n   operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[3]), DImode,\n \t\t\t\toperands[1], i3);\n   operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[3]), DImode,\n@@ -8827,12 +8794,8 @@\n \n   operands[2] = operand_subword (operands[0], endian, 0, <MODE>mode);\n   operands[3] = operand_subword (operands[0], 1 - endian, 0, <MODE>mode);\n-#if HOST_BITS_PER_WIDE_INT == 32\n-  operands[4] = (value & 0x80000000) ? constm1_rtx : const0_rtx;\n-#else\n   operands[4] = GEN_INT (value >> 32);\n   operands[1] = GEN_INT (((value & 0xffffffff) ^ 0x80000000) - 0x80000000);\n-#endif\n }\")\n \n (define_split\n@@ -8874,23 +8837,17 @@\n   int endian = (WORDS_BIG_ENDIAN == 0);\n   long l[2];\n   REAL_VALUE_TYPE rv;\n-#if HOST_BITS_PER_WIDE_INT >= 64\n   HOST_WIDE_INT val;\n-#endif\n \n   REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n   <real_value_to_target> (rv, l);\n \n   operands[2] = gen_lowpart (DImode, operands[0]);\n   /* HIGHPART is lower memory address when WORDS_BIG_ENDIAN.  */\n-#if HOST_BITS_PER_WIDE_INT >= 64\n   val = ((HOST_WIDE_INT)(unsigned long)l[endian] << 32\n          | ((HOST_WIDE_INT)(unsigned long)l[1 - endian]));\n \n   operands[3] = gen_int_mode (val, DImode);\n-#else\n-  operands[3] = immed_double_const (l[1 - endian], l[endian], DImode);\n-#endif\n }\")\n \n ;; Don't have reload use general registers to load a constant.  It is\n@@ -9508,12 +9465,8 @@\n \t\t\t\t       DImode);\n   operands[3] = operand_subword_force (operands[0], WORDS_BIG_ENDIAN != 0,\n \t\t\t\t       DImode);\n-#if HOST_BITS_PER_WIDE_INT == 32\n-  operands[4] = (value & 0x80000000) ? constm1_rtx : const0_rtx;\n-#else\n   operands[4] = GEN_INT (value >> 32);\n   operands[1] = GEN_INT (((value & 0xffffffff) ^ 0x80000000) - 0x80000000);\n-#endif\n }\")\n \n (define_split\n@@ -9600,20 +9553,6 @@\n        (const_string \"mffgpr\")])\n    (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4,4,4,4,4,4\")])\n \n-;; immediate value valid for a single instruction hiding in a const_double\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(match_operand:DI 1 \"const_double_operand\" \"F\"))]\n-  \"HOST_BITS_PER_WIDE_INT == 32 && TARGET_POWERPC64\n-   && GET_CODE (operands[1]) == CONST_DOUBLE\n-   && num_insns_constant (operands[1], DImode) == 1\"\n-  \"*\n-{\n-  return ((unsigned HOST_WIDE_INT)\n-\t  (CONST_DOUBLE_LOW (operands[1]) + 0x8000) < 0x10000)\n-\t ? \\\"li %0,%1\\\" : \\\"lis %0,%v1\\\";\n-}\")\n-\n ;; Generate all one-bits and clear left or right.\n ;; Use (and:DI (rotate:DI ...)) to avoid anddi3 unnecessary clobber.\n (define_split"}]}