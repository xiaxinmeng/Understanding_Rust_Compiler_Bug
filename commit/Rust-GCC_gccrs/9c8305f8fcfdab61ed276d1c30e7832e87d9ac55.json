{"sha": "9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM4MzA1ZjhmY2ZkYWI2MWVkMjc2ZDFjMzBlNzgzMmU4N2Q5YWM1NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-04-25T16:31:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-04-25T16:31:42Z"}, "message": "cgraphunit.c: Update toplevel comment.\n\n\n\t* cgraphunit.c: Update toplevel comment.\n\t(tree_rest_of_compilation): Merge into cgraph_expand_function.\n\t(cgraph_analyze_function): Make static.\n\t(cgraph_decide_is_function_needed): Make static.\n\t(cgraph_add_new_function): Use expand_function instead of\n\trest_of_compilation.\n\t(clone_of_p, verify_edge_count_and_frequency, cgraph_debug_gimple_stmt,\n\tverify_edge_corresponds_to_fndecl, verify_cgraph_node, verify_cgraph):\n\tMove to cgraph.c\n\t(cgraph_inline_p): Remove.\n\t(cgraph_preserve_function_body_p): Move to ipa-inline-transform.\n\t(init_cgraph): Add comment.\n\t* cgraphbuild.c (record_reference, mark_address, mark_load,\n\tmark_store): Do not call analyze_expr hook.\n\t* cgraph.c: Update toplevel comment.\n\t(clone_of_p, verify_edge_count_and_frequency, cgraph_debug_gimple_stmt,\n\tverify_edge_corresponds_to_fndecl, verify_cgraph_node, verify_cgraph):\n\tMove fere from cgraphunit.c\n\t(cgraph_mark_force_output_node): Move to cgraph.h\n\t* cgraph.h: Reorder so the comments match the function placement.\n\t(cgraph_analyze_function, cgraph_decide_is_function_needed): Remove.\n\t(cgraph_mark_force_output_node): Move here from cgraph.c\n\t* tree.c (free_lang_data): Do not clear analyze_expr hook.\n\t* ipa-inline-transform.c (preserve_function_body_p): New function.\n\t(inline_transform): Update.\n\t* langhooks.c (lhd_callgraph_analyze_expr): Remove.\n\t* langhooks.h (lang_hooks_for_callgraph): Remove.\n\t(lang_hooks): Remove callgraph.\n\t* tree-inline.c (expand_call_inline): Do not use cgraph_inline_p.\n\t* varpool.c: Remove out of date comment.\n\t* langhooks-def.h (lhd_callgraph_analyze_expr): Remove.\n\t(LANG_HOOKS_CALLGRAPH_ANALYZE_EXPR): Remove.\n\nFrom-SVN: r186832", "tree": {"sha": "59428eb8af21f903b36ff6bf0614f87d9cb27f0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59428eb8af21f903b36ff6bf0614f87d9cb27f0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/comments", "author": null, "committer": null, "parents": [{"sha": "95e5b9a43acdccb2e47196b3be05b5df51619d77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95e5b9a43acdccb2e47196b3be05b5df51619d77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95e5b9a43acdccb2e47196b3be05b5df51619d77"}], "stats": {"total": 1265, "additions": 613, "deletions": 652}, "files": [{"sha": "51fefab463b659bae532878d1ddd7b309bdeace0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "patch": "@@ -1,3 +1,38 @@\n+2012-04-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphunit.c: Update toplevel comment.\n+\t(tree_rest_of_compilation): Merge into cgraph_expand_function.\n+\t(cgraph_analyze_function): Make static.\n+\t(cgraph_decide_is_function_needed): Make static.\n+\t(cgraph_add_new_function): Use expand_function instead of\n+\trest_of_compilation.\n+\t(clone_of_p, verify_edge_count_and_frequency, cgraph_debug_gimple_stmt,\n+\tverify_edge_corresponds_to_fndecl, verify_cgraph_node, verify_cgraph):\n+\tMove to cgraph.c\n+\t(cgraph_inline_p): Remove.\n+\t(cgraph_preserve_function_body_p): Move to ipa-inline-transform.\n+\t(init_cgraph): Add comment.\n+\t* cgraphbuild.c (record_reference, mark_address, mark_load,\n+\tmark_store): Do not call analyze_expr hook.\n+\t* cgraph.c: Update toplevel comment.\n+\t(clone_of_p, verify_edge_count_and_frequency, cgraph_debug_gimple_stmt,\n+\tverify_edge_corresponds_to_fndecl, verify_cgraph_node, verify_cgraph):\n+\tMove fere from cgraphunit.c\n+\t(cgraph_mark_force_output_node): Move to cgraph.h\n+\t* cgraph.h: Reorder so the comments match the function placement.\n+\t(cgraph_analyze_function, cgraph_decide_is_function_needed): Remove.\n+\t(cgraph_mark_force_output_node): Move here from cgraph.c\n+\t* tree.c (free_lang_data): Do not clear analyze_expr hook.\n+\t* ipa-inline-transform.c (preserve_function_body_p): New function.\n+\t(inline_transform): Update.\n+\t* langhooks.c (lhd_callgraph_analyze_expr): Remove.\n+\t* langhooks.h (lang_hooks_for_callgraph): Remove.\n+\t(lang_hooks): Remove callgraph.\n+\t* tree-inline.c (expand_call_inline): Do not use cgraph_inline_p.\n+\t* varpool.c: Remove out of date comment.\n+\t* langhooks-def.h (lhd_callgraph_analyze_expr): Remove.\n+\t(LANG_HOOKS_CALLGRAPH_ANALYZE_EXPR): Remove.\n+\n 2012-04-25  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/53089 "}, {"sha": "e689d1083caddcb108d5e651a690ddefd66d64be", "filename": "gcc/cgraph.c", "status": "modified", "additions": 400, "deletions": 60, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "patch": "@@ -21,56 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n \n /*  This file contains basic routines manipulating call graph\n \n-The callgraph:\n-\n-    The call-graph is data structure designed for intra-procedural optimization\n-    but it is also used in non-unit-at-a-time compilation to allow easier code\n-    sharing.\n-\n-    The call-graph consist of nodes and edges represented via linked lists.\n-    Each function (external or not) corresponds to the unique node.\n-\n-    The mapping from declarations to call-graph nodes is done using hash table\n-    based on DECL_UID.  The call-graph nodes are created lazily using\n-    cgraph_node function when called for unknown declaration.\n-\n-    The callgraph at the moment does not represent all indirect calls or calls\n-    from other compilation units.  Flag NEEDED is set for each node that may be\n-    accessed in such an invisible way and it shall be considered an entry point\n-    to the callgraph.\n-\n-    On the other hand, the callgraph currently does contain some edges for\n-    indirect calls with unknown callees which can be accessed through\n-    indirect_calls field of a node.  It should be noted however that at the\n-    moment only calls which are potential candidates for indirect inlining are\n-    added there.\n-\n-    Interprocedural information:\n-\n-      Callgraph is place to store data needed for interprocedural optimization.\n-      All data structures are divided into three components: local_info that\n-      is produced while analyzing the function, global_info that is result\n-      of global walking of the callgraph on the end of compilation and\n-      rtl_info used by RTL backend to propagate data from already compiled\n-      functions to their callers.\n-\n-      Moreover, each node has a uid which can be used to keep information in\n-      on-the-side arrays.  UIDs are reused and therefore reasonably dense.\n-\n-    Inlining plans:\n-\n-      The function inlining information is decided in advance and maintained\n-      in the callgraph as so called inline plan.\n-      For each inlined call, the callee's node is cloned to represent the\n-      new function copy produced by inliner.\n-      Each inlined call gets a unique corresponding clone node of the callee\n-      and the data structure is updated while inlining is performed, so\n-      the clones are eliminated and their callee edges redirected to the\n-      caller.\n-\n-      Each edge has \"inline_failed\" field.  When the field is set to NULL,\n-      the call will be inlined.  When it is non-NULL it contains a reason\n-      why inlining wasn't performed.  */\n+    The call-graph is a data structure designed for intra-procedural optimization.\n+    It represents a multi-graph where nodes are functions and edges are call sites. */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -100,6 +52,7 @@ The callgraph:\n #include \"lto-streamer.h\"\n #include \"ipa-inline.h\"\n #include \"cfgloop.h\"\n+#include \"gimple-pretty-print.h\"\n \n const char * const ld_plugin_symbol_resolution_names[]=\n {\n@@ -1472,16 +1425,6 @@ cgraph_remove_node_and_inline_clones (struct cgraph_node *node, struct cgraph_no\n   return found;\n }\n \n-/* Likewise indicate that a node is needed, i.e. reachable via some\n-   external means.  */\n-\n-void\n-cgraph_mark_force_output_node (struct cgraph_node *node)\n-{\n-  node->symbol.force_output = 1;\n-  gcc_assert (!node->global.inlined_to);\n-}\n-\n /* Likewise indicate that a node is having address taken.  */\n \n void\n@@ -2672,4 +2615,401 @@ collect_callers_of_node (struct cgraph_node *node)\n   return redirect_callers;\n }\n \n+/* Return TRUE if NODE2 is equivalent to NODE or its clone.  */\n+static bool\n+clone_of_p (struct cgraph_node *node, struct cgraph_node *node2)\n+{\n+  node = cgraph_function_or_thunk_node (node, NULL);\n+  node2 = cgraph_function_or_thunk_node (node2, NULL);\n+  while (node != node2 && node2)\n+    node2 = node2->clone_of;\n+  return node2 != NULL;\n+}\n+\n+/* Verify edge E count and frequency.  */\n+\n+static bool\n+verify_edge_count_and_frequency (struct cgraph_edge *e)\n+{\n+  bool error_found = false;\n+  if (e->count < 0)\n+    {\n+      error (\"caller edge count is negative\");\n+      error_found = true;\n+    }\n+  if (e->frequency < 0)\n+    {\n+      error (\"caller edge frequency is negative\");\n+      error_found = true;\n+    }\n+  if (e->frequency > CGRAPH_FREQ_MAX)\n+    {\n+      error (\"caller edge frequency is too large\");\n+      error_found = true;\n+    }\n+  if (gimple_has_body_p (e->caller->symbol.decl)\n+      && !e->caller->global.inlined_to\n+      /* FIXME: Inline-analysis sets frequency to 0 when edge is optimized out.\n+\t Remove this once edges are actualy removed from the function at that time.  */\n+      && (e->frequency\n+\t  || (inline_edge_summary_vec\n+\t      && ((VEC_length(inline_edge_summary_t, inline_edge_summary_vec)\n+\t\t  <= (unsigned) e->uid)\n+\t          || !inline_edge_summary (e)->predicate)))\n+      && (e->frequency\n+\t  != compute_call_stmt_bb_frequency (e->caller->symbol.decl,\n+\t\t\t\t\t     gimple_bb (e->call_stmt))))\n+    {\n+      error (\"caller edge frequency %i does not match BB frequency %i\",\n+\t     e->frequency,\n+\t     compute_call_stmt_bb_frequency (e->caller->symbol.decl,\n+\t\t\t\t\t     gimple_bb (e->call_stmt)));\n+      error_found = true;\n+    }\n+  return error_found;\n+}\n+\n+/* Switch to THIS_CFUN if needed and print STMT to stderr.  */\n+static void\n+cgraph_debug_gimple_stmt (struct function *this_cfun, gimple stmt)\n+{\n+  /* debug_gimple_stmt needs correct cfun */\n+  if (cfun != this_cfun)\n+    set_cfun (this_cfun);\n+  debug_gimple_stmt (stmt);\n+}\n+\n+/* Verify that call graph edge E corresponds to DECL from the associated\n+   statement.  Return true if the verification should fail.  */\n+\n+static bool\n+verify_edge_corresponds_to_fndecl (struct cgraph_edge *e, tree decl)\n+{\n+  struct cgraph_node *node;\n+\n+  if (!decl || e->callee->global.inlined_to)\n+    return false;\n+  node = cgraph_get_node (decl);\n+\n+  /* We do not know if a node from a different partition is an alias or what it\n+     aliases and therefore cannot do the former_clone_of check reliably.  */\n+  if (!node || node->symbol.in_other_partition)\n+    return false;\n+  node = cgraph_function_or_thunk_node (node, NULL);\n+\n+  if ((e->callee->former_clone_of != node->symbol.decl\n+       && (!node->same_body_alias\n+\t   || e->callee->former_clone_of != node->thunk.alias))\n+      /* IPA-CP sometimes redirect edge to clone and then back to the former\n+\t function.  This ping-pong has to go, eventually.  */\n+      && (node != cgraph_function_or_thunk_node (e->callee, NULL))\n+      && !clone_of_p (node, e->callee)\n+      /* If decl is a same body alias of some other decl, allow e->callee to be\n+\t a clone of a clone of that other decl too.  */\n+      && (!node->same_body_alias\n+\t  || !clone_of_p (cgraph_get_node (node->thunk.alias), e->callee)))\n+    return true;\n+  else\n+    return false;\n+}\n+\n+/* Verify cgraph nodes of given cgraph node.  */\n+DEBUG_FUNCTION void\n+verify_cgraph_node (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *e;\n+  struct function *this_cfun = DECL_STRUCT_FUNCTION (node->symbol.decl);\n+  basic_block this_block;\n+  gimple_stmt_iterator gsi;\n+  bool error_found = false;\n+\n+  if (seen_error ())\n+    return;\n+\n+  timevar_push (TV_CGRAPH_VERIFY);\n+  error_found |= verify_symtab_base ((symtab_node) node);\n+  for (e = node->callees; e; e = e->next_callee)\n+    if (e->aux)\n+      {\n+\terror (\"aux field set for edge %s->%s\",\n+\t       identifier_to_locale (cgraph_node_name (e->caller)),\n+\t       identifier_to_locale (cgraph_node_name (e->callee)));\n+\terror_found = true;\n+      }\n+  if (node->count < 0)\n+    {\n+      error (\"execution count is negative\");\n+      error_found = true;\n+    }\n+  if (node->global.inlined_to && node->symbol.externally_visible)\n+    {\n+      error (\"externally visible inline clone\");\n+      error_found = true;\n+    }\n+  if (node->global.inlined_to && node->symbol.address_taken)\n+    {\n+      error (\"inline clone with address taken\");\n+      error_found = true;\n+    }\n+  if (node->global.inlined_to && node->symbol.force_output)\n+    {\n+      error (\"inline clone is forced to output\");\n+      error_found = true;\n+    }\n+  for (e = node->indirect_calls; e; e = e->next_callee)\n+    {\n+      if (e->aux)\n+\t{\n+\t  error (\"aux field set for indirect edge from %s\",\n+\t\t identifier_to_locale (cgraph_node_name (e->caller)));\n+\t  error_found = true;\n+\t}\n+      if (!e->indirect_unknown_callee\n+\t  || !e->indirect_info)\n+\t{\n+\t  error (\"An indirect edge from %s is not marked as indirect or has \"\n+\t\t \"associated indirect_info, the corresponding statement is: \",\n+\t\t identifier_to_locale (cgraph_node_name (e->caller)));\n+\t  cgraph_debug_gimple_stmt (this_cfun, e->call_stmt);\n+\t  error_found = true;\n+\t}\n+    }\n+  for (e = node->callers; e; e = e->next_caller)\n+    {\n+      if (verify_edge_count_and_frequency (e))\n+\terror_found = true;\n+      if (!e->inline_failed)\n+\t{\n+\t  if (node->global.inlined_to\n+\t      != (e->caller->global.inlined_to\n+\t\t  ? e->caller->global.inlined_to : e->caller))\n+\t    {\n+\t      error (\"inlined_to pointer is wrong\");\n+\t      error_found = true;\n+\t    }\n+\t  if (node->callers->next_caller)\n+\t    {\n+\t      error (\"multiple inline callers\");\n+\t      error_found = true;\n+\t    }\n+\t}\n+      else\n+\tif (node->global.inlined_to)\n+\t  {\n+\t    error (\"inlined_to pointer set for noninline callers\");\n+\t    error_found = true;\n+\t  }\n+    }\n+  for (e = node->indirect_calls; e; e = e->next_callee)\n+    if (verify_edge_count_and_frequency (e))\n+      error_found = true;\n+  if (!node->callers && node->global.inlined_to)\n+    {\n+      error (\"inlined_to pointer is set but no predecessors found\");\n+      error_found = true;\n+    }\n+  if (node->global.inlined_to == node)\n+    {\n+      error (\"inlined_to pointer refers to itself\");\n+      error_found = true;\n+    }\n+\n+  if (node->clone_of)\n+    {\n+      struct cgraph_node *n;\n+      for (n = node->clone_of->clones; n; n = n->next_sibling_clone)\n+        if (n == node)\n+\t  break;\n+      if (!n)\n+\t{\n+\t  error (\"node has wrong clone_of\");\n+\t  error_found = true;\n+\t}\n+    }\n+  if (node->clones)\n+    {\n+      struct cgraph_node *n;\n+      for (n = node->clones; n; n = n->next_sibling_clone)\n+        if (n->clone_of != node)\n+\t  break;\n+      if (n)\n+\t{\n+\t  error (\"node has wrong clone list\");\n+\t  error_found = true;\n+\t}\n+    }\n+  if ((node->prev_sibling_clone || node->next_sibling_clone) && !node->clone_of)\n+    {\n+       error (\"node is in clone list but it is not clone\");\n+       error_found = true;\n+    }\n+  if (!node->prev_sibling_clone && node->clone_of && node->clone_of->clones != node)\n+    {\n+      error (\"node has wrong prev_clone pointer\");\n+      error_found = true;\n+    }\n+  if (node->prev_sibling_clone && node->prev_sibling_clone->next_sibling_clone != node)\n+    {\n+      error (\"double linked list of clones corrupted\");\n+      error_found = true;\n+    }\n+\n+  if (node->analyzed && node->alias)\n+    {\n+      bool ref_found = false;\n+      int i;\n+      struct ipa_ref *ref;\n+\n+      if (node->callees)\n+\t{\n+\t  error (\"Alias has call edges\");\n+          error_found = true;\n+\t}\n+      for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list,\n+\t\t\t\t\t\t  i, ref); i++)\n+\tif (ref->use != IPA_REF_ALIAS)\n+\t  {\n+\t    error (\"Alias has non-alias reference\");\n+\t    error_found = true;\n+\t  }\n+\telse if (ref_found)\n+\t  {\n+\t    error (\"Alias has more than one alias reference\");\n+\t    error_found = true;\n+\t  }\n+\telse\n+\t  ref_found = true;\n+\tif (!ref_found)\n+\t  {\n+\t    error (\"Analyzed alias has no reference\");\n+\t    error_found = true;\n+\t  }\n+    }\n+  if (node->analyzed && node->thunk.thunk_p)\n+    {\n+      if (!node->callees)\n+\t{\n+\t  error (\"No edge out of thunk node\");\n+          error_found = true;\n+\t}\n+      else if (node->callees->next_callee)\n+\t{\n+\t  error (\"More than one edge out of thunk node\");\n+          error_found = true;\n+\t}\n+      if (gimple_has_body_p (node->symbol.decl))\n+        {\n+\t  error (\"Thunk is not supposed to have body\");\n+          error_found = true;\n+        }\n+    }\n+  else if (node->analyzed && gimple_has_body_p (node->symbol.decl)\n+           && !TREE_ASM_WRITTEN (node->symbol.decl)\n+           && (!DECL_EXTERNAL (node->symbol.decl) || node->global.inlined_to)\n+           && !flag_wpa)\n+    {\n+      if (this_cfun->cfg)\n+\t{\n+\t  /* The nodes we're interested in are never shared, so walk\n+\t     the tree ignoring duplicates.  */\n+\t  struct pointer_set_t *visited_nodes = pointer_set_create ();\n+\t  /* Reach the trees by walking over the CFG, and note the\n+\t     enclosing basic-blocks in the call edges.  */\n+\t  FOR_EACH_BB_FN (this_block, this_cfun)\n+\t    for (gsi = gsi_start_bb (this_block);\n+                 !gsi_end_p (gsi);\n+                 gsi_next (&gsi))\n+\t      {\n+\t\tgimple stmt = gsi_stmt (gsi);\n+\t\tif (is_gimple_call (stmt))\n+\t\t  {\n+\t\t    struct cgraph_edge *e = cgraph_edge (node, stmt);\n+\t\t    tree decl = gimple_call_fndecl (stmt);\n+\t\t    if (e)\n+\t\t      {\n+\t\t\tif (e->aux)\n+\t\t\t  {\n+\t\t\t    error (\"shared call_stmt:\");\n+\t\t\t    cgraph_debug_gimple_stmt (this_cfun, stmt);\n+\t\t\t    error_found = true;\n+\t\t\t  }\n+\t\t\tif (!e->indirect_unknown_callee)\n+\t\t\t  {\n+\t\t\t    if (verify_edge_corresponds_to_fndecl (e, decl))\n+\t\t\t      {\n+\t\t\t\terror (\"edge points to wrong declaration:\");\n+\t\t\t\tdebug_tree (e->callee->symbol.decl);\n+\t\t\t\tfprintf (stderr,\" Instead of:\");\n+\t\t\t\tdebug_tree (decl);\n+\t\t\t\terror_found = true;\n+\t\t\t      }\n+\t\t\t  }\n+\t\t\telse if (decl)\n+\t\t\t  {\n+\t\t\t    error (\"an indirect edge with unknown callee \"\n+\t\t\t\t   \"corresponding to a call_stmt with \"\n+\t\t\t\t   \"a known declaration:\");\n+\t\t\t    error_found = true;\n+\t\t\t    cgraph_debug_gimple_stmt (this_cfun, e->call_stmt);\n+\t\t\t  }\n+\t\t\te->aux = (void *)1;\n+\t\t      }\n+\t\t    else if (decl)\n+\t\t      {\n+\t\t\terror (\"missing callgraph edge for call stmt:\");\n+\t\t\tcgraph_debug_gimple_stmt (this_cfun, stmt);\n+\t\t\terror_found = true;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t  pointer_set_destroy (visited_nodes);\n+\t}\n+      else\n+\t/* No CFG available?!  */\n+\tgcc_unreachable ();\n+\n+      for (e = node->callees; e; e = e->next_callee)\n+\t{\n+\t  if (!e->aux)\n+\t    {\n+\t      error (\"edge %s->%s has no corresponding call_stmt\",\n+\t\t     identifier_to_locale (cgraph_node_name (e->caller)),\n+\t\t     identifier_to_locale (cgraph_node_name (e->callee)));\n+\t      cgraph_debug_gimple_stmt (this_cfun, e->call_stmt);\n+\t      error_found = true;\n+\t    }\n+\t  e->aux = 0;\n+\t}\n+      for (e = node->indirect_calls; e; e = e->next_callee)\n+\t{\n+\t  if (!e->aux)\n+\t    {\n+\t      error (\"an indirect edge from %s has no corresponding call_stmt\",\n+\t\t     identifier_to_locale (cgraph_node_name (e->caller)));\n+\t      cgraph_debug_gimple_stmt (this_cfun, e->call_stmt);\n+\t      error_found = true;\n+\t    }\n+\t  e->aux = 0;\n+\t}\n+    }\n+  if (error_found)\n+    {\n+      dump_cgraph_node (stderr, node);\n+      internal_error (\"verify_cgraph_node failed\");\n+    }\n+  timevar_pop (TV_CGRAPH_VERIFY);\n+}\n+\n+/* Verify whole cgraph structure.  */\n+DEBUG_FUNCTION void\n+verify_cgraph (void)\n+{\n+  struct cgraph_node *node;\n+\n+  if (seen_error ())\n+    return;\n+\n+  FOR_EACH_FUNCTION (node)\n+    verify_cgraph_node (node);\n+}\n #include \"gt-cgraph.h\""}, {"sha": "652556f9df16cc22802fef43c23874e7b506333c", "filename": "gcc/cgraph.h", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "patch": "@@ -574,37 +574,9 @@ bool cgraph_for_node_and_aliases (struct cgraph_node *,\n \t\t                  bool (*) (struct cgraph_node *, void *),\n \t\t\t          void *, bool);\n VEC (cgraph_edge_p, heap) * collect_callers_of_node (struct cgraph_node *node);\n-\n-\n-/* In cgraphunit.c  */\n-extern FILE *cgraph_dump_file;\n-void cgraph_finalize_function (tree, bool);\n-void cgraph_analyze_function (struct cgraph_node *);\n-void cgraph_finalize_compilation_unit (void);\n-void cgraph_optimize (void);\n-void cgraph_mark_force_output_node (struct cgraph_node *);\n-void cgraph_mark_address_taken_node (struct cgraph_node *);\n-bool cgraph_inline_p (struct cgraph_edge *, cgraph_inline_failed_t *reason);\n-bool cgraph_preserve_function_body_p (struct cgraph_node *);\n void verify_cgraph (void);\n void verify_cgraph_node (struct cgraph_node *);\n-void cgraph_build_static_cdtor (char which, tree body, int priority);\n-void cgraph_reset_static_var_maps (void);\n-void init_cgraph (void);\n-struct cgraph_node * cgraph_copy_node_for_versioning (struct cgraph_node *,\n-\t\ttree, VEC(cgraph_edge_p,heap)*, bitmap);\n-struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n-\t\t\t\t\t\tVEC(cgraph_edge_p,heap)*,\n-\t\t\t\t\t\tVEC(ipa_replace_map_p,gc)*,\n-\t\t\t\t\t\tbitmap, bool, bitmap,\n-\t\t\t\t\t\tbasic_block, const char *);\n-void tree_function_versioning (tree, tree, VEC (ipa_replace_map_p,gc)*,\n-\t\t\t       bool, bitmap, bool, bitmap, basic_block);\n-void record_references_in_initializer (tree, bool);\n-bool cgraph_process_new_functions (void);\n-void cgraph_process_same_body_aliases (void);\n-\n-bool cgraph_decide_is_function_needed (struct cgraph_node *, tree);\n+void cgraph_mark_address_taken_node (struct cgraph_node *);\n \n typedef void (*cgraph_edge_hook)(struct cgraph_edge *, void *);\n typedef void (*cgraph_node_hook)(struct cgraph_node *, void *);\n@@ -631,10 +603,31 @@ struct cgraph_2node_hook_list *cgraph_add_node_duplication_hook (cgraph_2node_ho\n void cgraph_remove_node_duplication_hook (struct cgraph_2node_hook_list *);\n gimple cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *);\n bool cgraph_propagate_frequency (struct cgraph_node *node);\n+\n+/* In cgraphunit.c  */\n+extern FILE *cgraph_dump_file;\n+void cgraph_finalize_function (tree, bool);\n+void cgraph_finalize_compilation_unit (void);\n+void cgraph_optimize (void);\n+void init_cgraph (void);\n+struct cgraph_node * cgraph_copy_node_for_versioning (struct cgraph_node *,\n+\t\ttree, VEC(cgraph_edge_p,heap)*, bitmap);\n+struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n+\t\t\t\t\t\tVEC(cgraph_edge_p,heap)*,\n+\t\t\t\t\t\tVEC(ipa_replace_map_p,gc)*,\n+\t\t\t\t\t\tbitmap, bool, bitmap,\n+\t\t\t\t\t\tbasic_block, const char *);\n+void tree_function_versioning (tree, tree, VEC (ipa_replace_map_p,gc)*,\n+\t\t\t       bool, bitmap, bool, bitmap, basic_block);\n+bool cgraph_process_new_functions (void);\n+void cgraph_process_same_body_aliases (void);\n+\n+\n /* In cgraphbuild.c  */\n unsigned int rebuild_cgraph_edges (void);\n void cgraph_rebuild_references (void);\n int compute_call_stmt_bb_frequency (tree, basic_block bb);\n+void record_references_in_initializer (tree, bool);\n \n /* In ipa.c  */\n bool cgraph_remove_unreachable_nodes (bool, FILE *);\n@@ -646,6 +639,7 @@ void cgraph_node_set_remove (cgraph_node_set, struct cgraph_node *);\n void dump_cgraph_node_set (FILE *, cgraph_node_set);\n void debug_cgraph_node_set (cgraph_node_set);\n void free_cgraph_node_set (cgraph_node_set);\n+void cgraph_build_static_cdtor (char which, tree body, int priority);\n \n varpool_node_set varpool_node_set_new (void);\n varpool_node_set_iterator varpool_node_set_find (varpool_node_set,\n@@ -1284,4 +1278,14 @@ decl_is_tm_clone (const_tree fndecl)\n     return n->tm_clone;\n   return false;\n }\n+\n+/* Likewise indicate that a node is needed, i.e. reachable via some\n+   external means.  */\n+\n+static inline void\n+cgraph_mark_force_output_node (struct cgraph_node *node)\n+{\n+  node->symbol.force_output = 1;\n+  gcc_checking_assert (!node->global.inlined_to);\n+}\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "a847980c663ae1b2da270adf64e194b0b44569a3", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "patch": "@@ -85,8 +85,6 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n       if (TREE_CODE (decl) == VAR_DECL)\n \t{\n \t  struct varpool_node *vnode = varpool_node (decl);\n-\t  if (lang_hooks.callgraph.analyze_expr)\n-\t    lang_hooks.callgraph.analyze_expr (&decl, walk_subtrees);\n \t  ipa_record_reference ((symtab_node)ctx->varpool_node,\n \t\t\t\t(symtab_node)vnode,\n \t\t\t\tIPA_REF_ADDR, NULL);\n@@ -102,9 +100,6 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n \t  *walk_subtrees = 0;\n \t  break;\n \t}\n-\n-      if ((unsigned int) TREE_CODE (t) >= LAST_AND_UNUSED_TREE_CODE)\n-\treturn lang_hooks.callgraph.analyze_expr (tp, walk_subtrees);\n       break;\n     }\n \n@@ -239,10 +234,7 @@ mark_address (gimple stmt, tree addr, void *data)\n \t   && (TREE_STATIC (addr) || DECL_EXTERNAL (addr)))\n     {\n       struct varpool_node *vnode = varpool_node (addr);\n-      int walk_subtrees;\n \n-      if (lang_hooks.callgraph.analyze_expr)\n-\tlang_hooks.callgraph.analyze_expr (&addr, &walk_subtrees);\n       ipa_record_reference ((symtab_node)data,\n \t\t\t    (symtab_node)vnode,\n \t\t\t    IPA_REF_ADDR, stmt);\n@@ -271,10 +263,7 @@ mark_load (gimple stmt, tree t, void *data)\n \t   && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n       struct varpool_node *vnode = varpool_node (t);\n-      int walk_subtrees;\n \n-      if (lang_hooks.callgraph.analyze_expr)\n-\tlang_hooks.callgraph.analyze_expr (&t, &walk_subtrees);\n       ipa_record_reference ((symtab_node)data,\n \t\t\t    (symtab_node)vnode,\n \t\t\t    IPA_REF_LOAD, stmt);\n@@ -292,10 +281,7 @@ mark_store (gimple stmt, tree t, void *data)\n       && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n       struct varpool_node *vnode = varpool_node (t);\n-      int walk_subtrees;\n \n-      if (lang_hooks.callgraph.analyze_expr)\n-\tlang_hooks.callgraph.analyze_expr (&t, &walk_subtrees);\n       ipa_record_reference ((symtab_node)data,\n \t\t\t    (symtab_node)vnode,\n \t\t\t    IPA_REF_STORE, stmt);"}, {"sha": "60ccc82591dcc789a728371af6e7015095a75302", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 129, "deletions": 511, "changes": 640, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "patch": "@@ -1,4 +1,4 @@\n-/* Callgraph based interprocedural optimizations.\n+/* Driver of optimization process\n    Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n    2011, 2012 Free Software Foundation, Inc.\n    Contributed by Jan Hubicka\n@@ -19,11 +19,10 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* This module implements main driver of compilation process as well as\n-   few basic interprocedural optimizers.\n+/* This module implements main driver of compilation process.\n \n    The main scope of this file is to act as an interface in between\n-   tree based frontends and the backend (and middle end)\n+   tree based frontends and the backend.\n \n    The front-end is supposed to use following functionality:\n \n@@ -45,66 +44,115 @@ along with GCC; see the file COPYING3.  If not see\n       This function is called once (source level) compilation unit is finalized\n       and it will no longer change.\n \n-      In the call-graph construction and local function analysis takes\n-      place here.  Bodies of unreachable functions are released to\n-      conserve memory usage.\n+      The symbol table is constructed starting from the trivially needed\n+      symbols finalized by the frontend.  Functions are lowered into\n+      GIMPLE representation and callgraph/reference lists are constructed.\n+      Those are used to discover other neccesary functions and variables.\n+\n+      At the end the bodies of unreachable functions are removed.\n \n       The function can be called multiple times when multiple source level\n-      compilation units are combined (such as in C frontend)\n+      compilation units are combined.\n \n     - cgraph_optimize\n \n-      In this unit-at-a-time compilation the intra procedural analysis takes\n-      place here.  In particular the static functions whose address is never\n-      taken are marked as local.  Backend can then use this information to\n-      modify calling conventions, do better inlining or similar optimizations.\n+      This passes control to the back-end.  Optimizations are performed and\n+      final assembler is generated.  This is done in the following way. Note\n+      that with link time optimization the process is split into three\n+      stages (compile time, linktime analysis and parallel linktime as\n+      indicated bellow).\n+\n+      Compile time:\n+\n+\t1) Inter-procedural optimization.\n+\t   (ipa_passes)\n+\n+\t   This part is further split into:\n+\n+\t   a) early optimizations. These are local passes executed in\n+\t      the topological order on the callgraph.\n+\n+\t      The purpose of early optimiations is to optimize away simple\n+\t      things that may otherwise confuse IP analysis. Very simple\n+\t      propagation across the callgraph is done i.e. to discover\n+\t      functions without side effects and simple inlining is performed.\n+\n+\t   b) early small interprocedural passes.\n+\n+\t      Those are interprocedural passes executed only at compilation\n+\t      time.  These include, for exmaple, transational memory lowering,\n+\t      unreachable code removal and other simple transformations.\n+\n+\t   c) IP analysis stage.  All interprocedural passes do their\n+\t      analysis.\n+\n+\t      Interprocedural passes differ from small interprocedural\n+\t      passes by their ability to operate across whole program\n+\t      at linktime.  Their analysis stage is performed early to\n+\t      both reduce linking times and linktime memory usage by\t\n+\t      not having to represent whole program in memory.\n+\n+\t   d) LTO sreaming.  When doing LTO, everything important gets\n+\t      streamed into the object file.\n+\n+       Compile time and or linktime analysis stage (WPA):\n+\n+\t      At linktime units gets streamed back and symbol table is\n+\t      merged.  Function bodies are not streamed in and not\n+\t      available.\n+\t   e) IP propagation stage.  All IP passes execute their\n+\t      IP propagation. This is done based on the earlier analysis\n+\t      without having function bodies at hand.\n+\t   f) Ltrans streaming.  When doing WHOPR LTO, the program\n+\t      is partitioned and streamed into multple object files.\n+\n+       Compile time and/or parallel linktime stage (ltrans)\n \n-    - cgraph_mark_needed_node\n-    - varpool_mark_needed_node\n+\t      Each of the object files is streamed back and compiled\n+\t      separately.  Now the function bodies becomes available\n+\t      again.\n \n-      When function or variable is referenced by some hidden way the call-graph\n-      data structure must be updated accordingly by this function.\n-      There should be little need to call this function and all the references\n-      should be made explicit to cgraph code.  At present these functions are\n-      used by C++ frontend to explicitly mark the keyed methods.\n+\t 2) Virtual clone materialization\n+\t    (cgraph_materialize_clone)\n \n-    - analyze_expr callback\n+\t    IP passes can produce copies of existing functoins (such\n+\t    as versioned clones or inline clones) without actually\n+\t    manipulating their bodies by creating virtual clones in\n+\t    the callgraph. At this time the virtual clones are\n+\t    turned into real functions\n+\t 3) IP transformation\n \n-      This function is responsible for lowering tree nodes not understood by\n-      generic code into understandable ones or alternatively marking\n-      callgraph and varpool nodes referenced by the as needed.\n+\t    All IP passes transform function bodies based on earlier\n+\t    decision of the IP propagation.\n \n-      ??? On the tree-ssa genericizing should take place here and we will avoid\n-      need for these hooks (replacing them by genericizing hook)\n+\t 4) late small IP passes\n \n-        Analyzing of all functions is deferred\n-\tto cgraph_finalize_compilation_unit and expansion into cgraph_optimize.\n+\t    Simple IP passes working within single program partition.\n \n-\tIn cgraph_finalize_compilation_unit the reachable functions are\n-\tanalyzed.  During analysis the call-graph edges from reachable\n-\tfunctions are constructed and their destinations are marked as\n-\treachable.  References to functions and variables are discovered too\n-\tand variables found to be needed output to the assembly file.  Via\n-\tmark_referenced call in assemble_variable functions referenced by\n-\tstatic variables are noticed too.\n+\t 5) Expansion\n+\t    (cgraph_expand_all_functions)\n \n-\tThe intra-procedural information is produced and its existence\n-\tindicated by global_info_ready.  Once this flag is set it is impossible\n-\tto change function from !reachable to reachable and thus\n-\tassemble_variable no longer call mark_referenced.\n+\t    At this stage functions that needs to be output into\n+\t    assembler are identified and compiled in topological order\n+\t 6) Output of variables and aliases\n+\t    Now it is known what variable references was not optimized\n+\t    out and thus all variables are output to the file.\n \n-\tFinally the call-graph is topologically sorted and all reachable functions\n-\tthat has not been completely inlined or are not external are output.\n+\t    Note that with -fno-toplevel-reorder passes 5 and 6\n+\t    are combined together in cgraph_output_in_order.  \n \n-\t??? It is possible that reference to function or variable is optimized\n-\tout.  We can not deal with this nicely because topological order is not\n-\tsuitable for it.  For tree-ssa we may consider another pass doing\n-\toptimization and re-discovering reachable functions.\n+   Finally there are functions to manipulate the callgraph from\n+   backend.\n+    - cgraph_add_new_function is used to add backend produced\n+      functions introduced after the unit is finalized.\n+      The functions are enqueue for later processing and inserted\n+      into callgraph with cgraph_process_new_functions.\n \n-\t??? Reorganize code so variables are output very last and only if they\n-\treally has been referenced by produced code, so we catch more cases\n-\twhere reference has been optimized out.  */\n+    - cgraph_function_versioning\n \n+      produces a copy of function into new one (a version)\n+      and apply simple transformations\n+*/\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -124,8 +172,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"cgraph.h\"\n #include \"diagnostic.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"gimple-pretty-print.h\"\n #include \"timevar.h\"\n #include \"params.h\"\n #include \"fibheap.h\"\n@@ -136,6 +182,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"tree-pass.h\"\n #include \"tree-dump.h\"\n+#include \"gimple-pretty-print.h\"\n #include \"output.h\"\n #include \"coverage.h\"\n #include \"plugin.h\"\n@@ -154,7 +201,7 @@ static void cgraph_expand_all_functions (void);\n static void cgraph_mark_functions_to_output (void);\n static void cgraph_expand_function (struct cgraph_node *);\n static void cgraph_output_pending_asms (void);\n-static void tree_rest_of_compilation (struct cgraph_node *);\n+static void cgraph_analyze_function (struct cgraph_node *);\n \n FILE *cgraph_dump_file;\n \n@@ -166,7 +213,7 @@ static GTY (()) tree vtable_entry_type;\n    and differs from later logic removing unnecesary functions that can\n    take into account results of analysis, whole program info etc.  */\n \n-bool\n+static bool\n cgraph_decide_is_function_needed (struct cgraph_node *node, tree decl)\n {\n   /* If the user told us it is used, then it must be so.  */\n@@ -470,8 +517,8 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \tif (!gimple_in_ssa_p (DECL_STRUCT_FUNCTION (fndecl)))\n \t  execute_pass_list (pass_early_local_passes.pass.sub);\n \tbitmap_obstack_release (NULL);\n-\ttree_rest_of_compilation (node);\n \tpop_cfun ();\n+\tcgraph_expand_function (node);\n \tcurrent_function_decl = NULL;\n \tbreak;\n \n@@ -486,404 +533,6 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n     DECL_FUNCTION_PERSONALITY (fndecl) = lang_hooks.eh_personality ();\n }\n \n-/* Return TRUE if NODE2 is equivalent to NODE or its clone.  */\n-static bool\n-clone_of_p (struct cgraph_node *node, struct cgraph_node *node2)\n-{\n-  node = cgraph_function_or_thunk_node (node, NULL);\n-  node2 = cgraph_function_or_thunk_node (node2, NULL);\n-  while (node != node2 && node2)\n-    node2 = node2->clone_of;\n-  return node2 != NULL;\n-}\n-\n-/* Verify edge E count and frequency.  */\n-\n-static bool\n-verify_edge_count_and_frequency (struct cgraph_edge *e)\n-{\n-  bool error_found = false;\n-  if (e->count < 0)\n-    {\n-      error (\"caller edge count is negative\");\n-      error_found = true;\n-    }\n-  if (e->frequency < 0)\n-    {\n-      error (\"caller edge frequency is negative\");\n-      error_found = true;\n-    }\n-  if (e->frequency > CGRAPH_FREQ_MAX)\n-    {\n-      error (\"caller edge frequency is too large\");\n-      error_found = true;\n-    }\n-  if (gimple_has_body_p (e->caller->symbol.decl)\n-      && !e->caller->global.inlined_to\n-      /* FIXME: Inline-analysis sets frequency to 0 when edge is optimized out.\n-\t Remove this once edges are actualy removed from the function at that time.  */\n-      && (e->frequency\n-\t  || (inline_edge_summary_vec\n-\t      && ((VEC_length(inline_edge_summary_t, inline_edge_summary_vec)\n-\t\t  <= (unsigned) e->uid)\n-\t          || !inline_edge_summary (e)->predicate)))\n-      && (e->frequency\n-\t  != compute_call_stmt_bb_frequency (e->caller->symbol.decl,\n-\t\t\t\t\t     gimple_bb (e->call_stmt))))\n-    {\n-      error (\"caller edge frequency %i does not match BB frequency %i\",\n-\t     e->frequency,\n-\t     compute_call_stmt_bb_frequency (e->caller->symbol.decl,\n-\t\t\t\t\t     gimple_bb (e->call_stmt)));\n-      error_found = true;\n-    }\n-  return error_found;\n-}\n-\n-/* Switch to THIS_CFUN if needed and print STMT to stderr.  */\n-static void\n-cgraph_debug_gimple_stmt (struct function *this_cfun, gimple stmt)\n-{\n-  /* debug_gimple_stmt needs correct cfun */\n-  if (cfun != this_cfun)\n-    set_cfun (this_cfun);\n-  debug_gimple_stmt (stmt);\n-}\n-\n-/* Verify that call graph edge E corresponds to DECL from the associated\n-   statement.  Return true if the verification should fail.  */\n-\n-static bool\n-verify_edge_corresponds_to_fndecl (struct cgraph_edge *e, tree decl)\n-{\n-  struct cgraph_node *node;\n-\n-  if (!decl || e->callee->global.inlined_to)\n-    return false;\n-  node = cgraph_get_node (decl);\n-\n-  /* We do not know if a node from a different partition is an alias or what it\n-     aliases and therefore cannot do the former_clone_of check reliably.  */\n-  if (!node || node->symbol.in_other_partition)\n-    return false;\n-  node = cgraph_function_or_thunk_node (node, NULL);\n-\n-  if ((e->callee->former_clone_of != node->symbol.decl\n-       && (!node->same_body_alias\n-\t   || e->callee->former_clone_of != node->thunk.alias))\n-      /* IPA-CP sometimes redirect edge to clone and then back to the former\n-\t function.  This ping-pong has to go, eventually.  */\n-      && (node != cgraph_function_or_thunk_node (e->callee, NULL))\n-      && !clone_of_p (node, e->callee)\n-      /* If decl is a same body alias of some other decl, allow e->callee to be\n-\t a clone of a clone of that other decl too.  */\n-      && (!node->same_body_alias\n-\t  || !clone_of_p (cgraph_get_node (node->thunk.alias), e->callee)))\n-    return true;\n-  else\n-    return false;\n-}\n-\n-/* Verify cgraph nodes of given cgraph node.  */\n-DEBUG_FUNCTION void\n-verify_cgraph_node (struct cgraph_node *node)\n-{\n-  struct cgraph_edge *e;\n-  struct function *this_cfun = DECL_STRUCT_FUNCTION (node->symbol.decl);\n-  basic_block this_block;\n-  gimple_stmt_iterator gsi;\n-  bool error_found = false;\n-\n-  if (seen_error ())\n-    return;\n-\n-  timevar_push (TV_CGRAPH_VERIFY);\n-  error_found |= verify_symtab_base ((symtab_node) node);\n-  for (e = node->callees; e; e = e->next_callee)\n-    if (e->aux)\n-      {\n-\terror (\"aux field set for edge %s->%s\",\n-\t       identifier_to_locale (cgraph_node_name (e->caller)),\n-\t       identifier_to_locale (cgraph_node_name (e->callee)));\n-\terror_found = true;\n-      }\n-  if (node->count < 0)\n-    {\n-      error (\"execution count is negative\");\n-      error_found = true;\n-    }\n-  if (node->global.inlined_to && node->symbol.externally_visible)\n-    {\n-      error (\"externally visible inline clone\");\n-      error_found = true;\n-    }\n-  if (node->global.inlined_to && node->symbol.address_taken)\n-    {\n-      error (\"inline clone with address taken\");\n-      error_found = true;\n-    }\n-  if (node->global.inlined_to && node->symbol.force_output)\n-    {\n-      error (\"inline clone is forced to output\");\n-      error_found = true;\n-    }\n-  for (e = node->indirect_calls; e; e = e->next_callee)\n-    {\n-      if (e->aux)\n-\t{\n-\t  error (\"aux field set for indirect edge from %s\",\n-\t\t identifier_to_locale (cgraph_node_name (e->caller)));\n-\t  error_found = true;\n-\t}\n-      if (!e->indirect_unknown_callee\n-\t  || !e->indirect_info)\n-\t{\n-\t  error (\"An indirect edge from %s is not marked as indirect or has \"\n-\t\t \"associated indirect_info, the corresponding statement is: \",\n-\t\t identifier_to_locale (cgraph_node_name (e->caller)));\n-\t  cgraph_debug_gimple_stmt (this_cfun, e->call_stmt);\n-\t  error_found = true;\n-\t}\n-    }\n-  for (e = node->callers; e; e = e->next_caller)\n-    {\n-      if (verify_edge_count_and_frequency (e))\n-\terror_found = true;\n-      if (!e->inline_failed)\n-\t{\n-\t  if (node->global.inlined_to\n-\t      != (e->caller->global.inlined_to\n-\t\t  ? e->caller->global.inlined_to : e->caller))\n-\t    {\n-\t      error (\"inlined_to pointer is wrong\");\n-\t      error_found = true;\n-\t    }\n-\t  if (node->callers->next_caller)\n-\t    {\n-\t      error (\"multiple inline callers\");\n-\t      error_found = true;\n-\t    }\n-\t}\n-      else\n-\tif (node->global.inlined_to)\n-\t  {\n-\t    error (\"inlined_to pointer set for noninline callers\");\n-\t    error_found = true;\n-\t  }\n-    }\n-  for (e = node->indirect_calls; e; e = e->next_callee)\n-    if (verify_edge_count_and_frequency (e))\n-      error_found = true;\n-  if (!node->callers && node->global.inlined_to)\n-    {\n-      error (\"inlined_to pointer is set but no predecessors found\");\n-      error_found = true;\n-    }\n-  if (node->global.inlined_to == node)\n-    {\n-      error (\"inlined_to pointer refers to itself\");\n-      error_found = true;\n-    }\n-\n-  if (node->clone_of)\n-    {\n-      struct cgraph_node *n;\n-      for (n = node->clone_of->clones; n; n = n->next_sibling_clone)\n-        if (n == node)\n-\t  break;\n-      if (!n)\n-\t{\n-\t  error (\"node has wrong clone_of\");\n-\t  error_found = true;\n-\t}\n-    }\n-  if (node->clones)\n-    {\n-      struct cgraph_node *n;\n-      for (n = node->clones; n; n = n->next_sibling_clone)\n-        if (n->clone_of != node)\n-\t  break;\n-      if (n)\n-\t{\n-\t  error (\"node has wrong clone list\");\n-\t  error_found = true;\n-\t}\n-    }\n-  if ((node->prev_sibling_clone || node->next_sibling_clone) && !node->clone_of)\n-    {\n-       error (\"node is in clone list but it is not clone\");\n-       error_found = true;\n-    }\n-  if (!node->prev_sibling_clone && node->clone_of && node->clone_of->clones != node)\n-    {\n-      error (\"node has wrong prev_clone pointer\");\n-      error_found = true;\n-    }\n-  if (node->prev_sibling_clone && node->prev_sibling_clone->next_sibling_clone != node)\n-    {\n-      error (\"double linked list of clones corrupted\");\n-      error_found = true;\n-    }\n-\n-  if (node->analyzed && node->alias)\n-    {\n-      bool ref_found = false;\n-      int i;\n-      struct ipa_ref *ref;\n-\n-      if (node->callees)\n-\t{\n-\t  error (\"Alias has call edges\");\n-          error_found = true;\n-\t}\n-      for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list,\n-\t\t\t\t\t\t  i, ref); i++)\n-\tif (ref->use != IPA_REF_ALIAS)\n-\t  {\n-\t    error (\"Alias has non-alias reference\");\n-\t    error_found = true;\n-\t  }\n-\telse if (ref_found)\n-\t  {\n-\t    error (\"Alias has more than one alias reference\");\n-\t    error_found = true;\n-\t  }\n-\telse\n-\t  ref_found = true;\n-\tif (!ref_found)\n-\t  {\n-\t    error (\"Analyzed alias has no reference\");\n-\t    error_found = true;\n-\t  }\n-    }\n-  if (node->analyzed && node->thunk.thunk_p)\n-    {\n-      if (!node->callees)\n-\t{\n-\t  error (\"No edge out of thunk node\");\n-          error_found = true;\n-\t}\n-      else if (node->callees->next_callee)\n-\t{\n-\t  error (\"More than one edge out of thunk node\");\n-          error_found = true;\n-\t}\n-      if (gimple_has_body_p (node->symbol.decl))\n-        {\n-\t  error (\"Thunk is not supposed to have body\");\n-          error_found = true;\n-        }\n-    }\n-  else if (node->analyzed && gimple_has_body_p (node->symbol.decl)\n-           && !TREE_ASM_WRITTEN (node->symbol.decl)\n-           && (!DECL_EXTERNAL (node->symbol.decl) || node->global.inlined_to)\n-           && !flag_wpa)\n-    {\n-      if (this_cfun->cfg)\n-\t{\n-\t  /* The nodes we're interested in are never shared, so walk\n-\t     the tree ignoring duplicates.  */\n-\t  struct pointer_set_t *visited_nodes = pointer_set_create ();\n-\t  /* Reach the trees by walking over the CFG, and note the\n-\t     enclosing basic-blocks in the call edges.  */\n-\t  FOR_EACH_BB_FN (this_block, this_cfun)\n-\t    for (gsi = gsi_start_bb (this_block);\n-                 !gsi_end_p (gsi);\n-                 gsi_next (&gsi))\n-\t      {\n-\t\tgimple stmt = gsi_stmt (gsi);\n-\t\tif (is_gimple_call (stmt))\n-\t\t  {\n-\t\t    struct cgraph_edge *e = cgraph_edge (node, stmt);\n-\t\t    tree decl = gimple_call_fndecl (stmt);\n-\t\t    if (e)\n-\t\t      {\n-\t\t\tif (e->aux)\n-\t\t\t  {\n-\t\t\t    error (\"shared call_stmt:\");\n-\t\t\t    cgraph_debug_gimple_stmt (this_cfun, stmt);\n-\t\t\t    error_found = true;\n-\t\t\t  }\n-\t\t\tif (!e->indirect_unknown_callee)\n-\t\t\t  {\n-\t\t\t    if (verify_edge_corresponds_to_fndecl (e, decl))\n-\t\t\t      {\n-\t\t\t\terror (\"edge points to wrong declaration:\");\n-\t\t\t\tdebug_tree (e->callee->symbol.decl);\n-\t\t\t\tfprintf (stderr,\" Instead of:\");\n-\t\t\t\tdebug_tree (decl);\n-\t\t\t\terror_found = true;\n-\t\t\t      }\n-\t\t\t  }\n-\t\t\telse if (decl)\n-\t\t\t  {\n-\t\t\t    error (\"an indirect edge with unknown callee \"\n-\t\t\t\t   \"corresponding to a call_stmt with \"\n-\t\t\t\t   \"a known declaration:\");\n-\t\t\t    error_found = true;\n-\t\t\t    cgraph_debug_gimple_stmt (this_cfun, e->call_stmt);\n-\t\t\t  }\n-\t\t\te->aux = (void *)1;\n-\t\t      }\n-\t\t    else if (decl)\n-\t\t      {\n-\t\t\terror (\"missing callgraph edge for call stmt:\");\n-\t\t\tcgraph_debug_gimple_stmt (this_cfun, stmt);\n-\t\t\terror_found = true;\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t  pointer_set_destroy (visited_nodes);\n-\t}\n-      else\n-\t/* No CFG available?!  */\n-\tgcc_unreachable ();\n-\n-      for (e = node->callees; e; e = e->next_callee)\n-\t{\n-\t  if (!e->aux)\n-\t    {\n-\t      error (\"edge %s->%s has no corresponding call_stmt\",\n-\t\t     identifier_to_locale (cgraph_node_name (e->caller)),\n-\t\t     identifier_to_locale (cgraph_node_name (e->callee)));\n-\t      cgraph_debug_gimple_stmt (this_cfun, e->call_stmt);\n-\t      error_found = true;\n-\t    }\n-\t  e->aux = 0;\n-\t}\n-      for (e = node->indirect_calls; e; e = e->next_callee)\n-\t{\n-\t  if (!e->aux)\n-\t    {\n-\t      error (\"an indirect edge from %s has no corresponding call_stmt\",\n-\t\t     identifier_to_locale (cgraph_node_name (e->caller)));\n-\t      cgraph_debug_gimple_stmt (this_cfun, e->call_stmt);\n-\t      error_found = true;\n-\t    }\n-\t  e->aux = 0;\n-\t}\n-    }\n-  if (error_found)\n-    {\n-      dump_cgraph_node (stderr, node);\n-      internal_error (\"verify_cgraph_node failed\");\n-    }\n-  timevar_pop (TV_CGRAPH_VERIFY);\n-}\n-\n-/* Verify whole cgraph structure.  */\n-DEBUG_FUNCTION void\n-verify_cgraph (void)\n-{\n-  struct cgraph_node *node;\n-\n-  if (seen_error ())\n-    return;\n-\n-  FOR_EACH_FUNCTION (node)\n-    verify_cgraph_node (node);\n-}\n-\n /* Output all asm statements we have stored up to be output.  */\n \n static void\n@@ -900,11 +549,13 @@ cgraph_output_pending_asms (void)\n }\n \n /* Analyze the function scheduled to be output.  */\n-void\n+static void\n cgraph_analyze_function (struct cgraph_node *node)\n {\n   tree save = current_function_decl;\n   tree decl = node->symbol.decl;\n+  location_t saved_loc = input_location;\n+  input_location = DECL_SOURCE_LOCATION (decl);\n \n   if (node->alias && node->thunk.alias)\n     {\n@@ -917,6 +568,7 @@ cgraph_analyze_function (struct cgraph_node *node)\n \t  {\n \t    error (\"function %q+D part of alias cycle\", node->symbol.decl);\n \t    node->alias = false;\n+\t    input_location = saved_loc;\n \t    return;\n \t  }\n       if (!VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n@@ -1002,6 +654,7 @@ cgraph_analyze_function (struct cgraph_node *node)\n   node->analyzed = true;\n \n   current_function_decl = save;\n+  input_location = saved_loc;\n }\n \n /* C++ frontend produce same body aliases all over the place, even before PCH\n@@ -1888,15 +1541,23 @@ assemble_thunks_and_aliases (struct cgraph_node *node)\n       }\n }\n \n-/* Perform IPA transforms and all further optimizations and compilation\n-   for FNDECL.  */\n+/* Expand function specified by NODE.  */\n \n static void\n-tree_rest_of_compilation (struct cgraph_node *node)\n+cgraph_expand_function (struct cgraph_node *node)\n {\n-  tree fndecl = node->symbol.decl;\n+  tree decl = node->symbol.decl;\n   location_t saved_loc;\n \n+  /* We ought to not compile any inline clones.  */\n+  gcc_assert (!node->global.inlined_to);\n+\n+  announce_function (decl);\n+  node->process = 0;\n+  gcc_assert (node->lowered);\n+\n+  /* Generate RTL for the body of DECL.  */\n+\n   timevar_push (TV_REST_OF_COMPILATION);\n \n   gcc_assert (cgraph_global_info_ready);\n@@ -1905,10 +1566,10 @@ tree_rest_of_compilation (struct cgraph_node *node)\n   bitmap_obstack_initialize (NULL);\n \n   /* Initialize the RTL code for the function.  */\n-  current_function_decl = fndecl;\n+  current_function_decl = decl;\n   saved_loc = input_location;\n-  input_location = DECL_SOURCE_LOCATION (fndecl);\n-  init_function_start (fndecl);\n+  input_location = DECL_SOURCE_LOCATION (decl);\n+  init_function_start (decl);\n \n   gimple_register_cfg_hooks ();\n \n@@ -1936,9 +1597,9 @@ tree_rest_of_compilation (struct cgraph_node *node)\n   /* If requested, warn about function definitions where the function will\n      return a value (usually of some struct or union type) which itself will\n      take up a lot of stack space.  */\n-  if (warn_larger_than && !DECL_EXTERNAL (fndecl) && TREE_TYPE (fndecl))\n+  if (warn_larger_than && !DECL_EXTERNAL (decl) && TREE_TYPE (decl))\n     {\n-      tree ret_type = TREE_TYPE (TREE_TYPE (fndecl));\n+      tree ret_type = TREE_TYPE (TREE_TYPE (decl));\n \n       if (ret_type && TYPE_SIZE_UNIT (ret_type)\n \t  && TREE_CODE (TYPE_SIZE_UNIT (ret_type)) == INTEGER_CST\n@@ -1950,53 +1611,34 @@ tree_rest_of_compilation (struct cgraph_node *node)\n \n \t  if (compare_tree_int (TYPE_SIZE_UNIT (ret_type), size_as_int) == 0)\n \t    warning (OPT_Wlarger_than_, \"size of return value of %q+D is %u bytes\",\n-                     fndecl, size_as_int);\n+                     decl, size_as_int);\n \t  else\n \t    warning (OPT_Wlarger_than_, \"size of return value of %q+D is larger than %wd bytes\",\n-                     fndecl, larger_than_size);\n+                     decl, larger_than_size);\n \t}\n     }\n \n-  gimple_set_body (fndecl, NULL);\n-  if (DECL_STRUCT_FUNCTION (fndecl) == 0\n-      && !cgraph_get_node (fndecl)->origin)\n+  gimple_set_body (decl, NULL);\n+  if (DECL_STRUCT_FUNCTION (decl) == 0\n+      && !cgraph_get_node (decl)->origin)\n     {\n       /* Stop pointing to the local nodes about to be freed.\n \t But DECL_INITIAL must remain nonzero so we know this\n \t was an actual function definition.\n \t For a nested function, this is done in c_pop_function_context.\n \t If rest_of_compilation set this to 0, leave it 0.  */\n-      if (DECL_INITIAL (fndecl) != 0)\n-\tDECL_INITIAL (fndecl) = error_mark_node;\n+      if (DECL_INITIAL (decl) != 0)\n+\tDECL_INITIAL (decl) = error_mark_node;\n     }\n \n   input_location = saved_loc;\n \n   ggc_collect ();\n   timevar_pop (TV_REST_OF_COMPILATION);\n-}\n-\n-/* Expand function specified by NODE.  */\n-\n-static void\n-cgraph_expand_function (struct cgraph_node *node)\n-{\n-  tree decl = node->symbol.decl;\n-\n-  /* We ought to not compile any inline clones.  */\n-  gcc_assert (!node->global.inlined_to);\n-\n-  announce_function (decl);\n-  node->process = 0;\n-  gcc_assert (node->lowered);\n-\n-  /* Generate RTL for the body of DECL.  */\n-  tree_rest_of_compilation (node);\n \n   /* Make sure that BE didn't give up on compiling.  */\n   gcc_assert (TREE_ASM_WRITTEN (decl));\n   current_function_decl = NULL;\n-  gcc_assert (!cgraph_preserve_function_body_p (node));\n \n   /* It would make a lot more sense to output thunks before function body to get more\n      forward and lest backwarding jumps.  This is however would need solving problem\n@@ -2011,16 +1653,6 @@ cgraph_expand_function (struct cgraph_node *node)\n   cgraph_node_remove_callees (node);\n }\n \n-/* Return true when CALLER_DECL should be inlined into CALLEE_DECL.  */\n-\n-bool\n-cgraph_inline_p (struct cgraph_edge *e, cgraph_inline_failed_t *reason)\n-{\n-  *reason = e->inline_failed;\n-  return !e->inline_failed;\n-}\n-\n-\n \n /* Expand all functions that must be output.\n \n@@ -2166,20 +1798,6 @@ cgraph_output_in_order (void)\n   free (nodes);\n }\n \n-/* Return true when function body of DECL still needs to be kept around\n-   for later re-use.  */\n-bool\n-cgraph_preserve_function_body_p (struct cgraph_node *node)\n-{\n-  gcc_assert (cgraph_global_info_ready);\n-  gcc_assert (!node->alias && !node->thunk.thunk_p);\n-\n-  /* Look if there is any clone around.  */\n-  if (node->clones)\n-    return true;\n-  return false;\n-}\n-\n static void\n ipa_passes (void)\n {\n@@ -2277,7 +1895,7 @@ output_weakrefs (void)\n \t\t      : get_alias_symbol (vnode->symbol.decl));\n }\n \n-\n+/* Initialize callgraph dump file.  */\n \n void\n init_cgraph (void)"}, {"sha": "e07468ae84f9cfb8732f3f6ef404116b9e8b6c52", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "patch": "@@ -353,6 +353,19 @@ save_inline_function_body (struct cgraph_node *node)\n   return first_clone;\n }\n \n+/* Return true when function body of DECL still needs to be kept around\n+   for later re-use.  */\n+bool\n+preserve_function_body_p (struct cgraph_node *node)\n+{\n+  gcc_assert (cgraph_global_info_ready);\n+  gcc_assert (!node->alias && !node->thunk.thunk_p);\n+\n+  /* Look if there is any clone around.  */\n+  if (node->clones)\n+    return true;\n+  return false;\n+}\n \n /* Apply inline plan to function.  */\n \n@@ -369,7 +382,7 @@ inline_transform (struct cgraph_node *node)\n \n   /* We might need the body of this function so that we can expand\n      it inline somewhere else.  */\n-  if (cgraph_preserve_function_body_p (node))\n+  if (preserve_function_body_p (node))\n     save_inline_function_body (node);\n \n   for (e = node->callees; e; e = e->next_callee)"}, {"sha": "d8f479f3f5dc0c291d4656d28ba904a0a3e992e0", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "patch": "@@ -69,7 +69,6 @@ extern void lhd_init_options (unsigned int,\n extern bool lhd_complain_wrong_lang_p (const struct cl_option *);\n extern bool lhd_handle_option (size_t, const char *, int, int, location_t,\n \t\t\t       const struct cl_option_handlers *);\n-extern tree lhd_callgraph_analyze_expr (tree *, int *);\n \n \n /* Declarations for tree gimplification hooks.  */\n@@ -132,12 +131,6 @@ extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,\n   LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P, \\\n }\n \n-#define LANG_HOOKS_CALLGRAPH_ANALYZE_EXPR lhd_callgraph_analyze_expr\n-\n-#define LANG_HOOKS_CALLGRAPH_INITIALIZER { \\\n-  LANG_HOOKS_CALLGRAPH_ANALYZE_EXPR \\\n-}\n-\n /* Hooks for tree gimplification.  */\n #define LANG_HOOKS_GIMPLIFY_EXPR lhd_gimplify_expr\n \n@@ -292,7 +285,6 @@ extern void lhd_end_section (void);\n   LANG_HOOKS_COMMON_ATTRIBUTE_TABLE, \\\n   LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE, \\\n   LANG_HOOKS_TREE_INLINING_INITIALIZER, \\\n-  LANG_HOOKS_CALLGRAPH_INITIALIZER, \\\n   LANG_HOOKS_TREE_DUMP_INITIALIZER, \\\n   LANG_HOOKS_DECLS, \\\n   LANG_HOOKS_FOR_TYPES_INITIALIZER, \\"}, {"sha": "9d0e25e0689c6f8b25e7b5ebd0f450ef7e536261", "filename": "gcc/langhooks.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "patch": "@@ -471,13 +471,6 @@ lhd_print_error_function (diagnostic_context *context, const char *file,\n     }\n }\n \n-tree\n-lhd_callgraph_analyze_expr (tree *tp ATTRIBUTE_UNUSED,\n-\t\t\t    int *walk_subtrees ATTRIBUTE_UNUSED)\n-{\n-  return NULL;\n-}\n-\n tree\n lhd_make_node (enum tree_code code)\n {"}, {"sha": "76b1fe260137480daaa5c8133be215fd83976ce4", "filename": "gcc/langhooks.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "patch": "@@ -43,13 +43,6 @@ struct lang_hooks_for_tree_inlining\n   bool (*var_mod_type_p) (tree, tree);\n };\n \n-struct lang_hooks_for_callgraph\n-{\n-  /* The node passed is a language-specific tree node.  If its contents\n-     are relevant to use of other declarations, mark them.  */\n-  tree (*analyze_expr) (tree *, int *);\n-};\n-\n /* The following hooks are used by tree-dump.c.  */\n \n struct lang_hooks_for_tree_dump\n@@ -407,8 +400,6 @@ struct lang_hooks\n \n   struct lang_hooks_for_tree_inlining tree_inlining;\n \n-  struct lang_hooks_for_callgraph callgraph;\n-\n   struct lang_hooks_for_tree_dump tree_dump;\n \n   struct lang_hooks_for_decls decls;"}, {"sha": "2ba95f509fe32d4329d9a269ca46cbaff6f98b8b", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "patch": "@@ -3807,8 +3807,9 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n     fn = DECL_ABSTRACT_ORIGIN (fn);\n \n   /* Don't try to inline functions that are not well-suited to inlining.  */\n-  if (!cgraph_inline_p (cg_edge, &reason))\n+  if (cg_edge->inline_failed)\n     {\n+      reason = cg_edge->inline_failed;\n       /* If this call was originally indirect, we do not want to emit any\n \t inlining related warnings or sorry messages because there are no\n \t guarantees regarding those.  */"}, {"sha": "4623d3765e4261c94d50800b318712532b1f17d0", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "patch": "@@ -5244,7 +5244,6 @@ free_lang_data (void)\n \n   /* Reset some langhooks.  Do not reset types_compatible_p, it may\n      still be used indirectly via the get_alias_set langhook.  */\n-  lang_hooks.callgraph.analyze_expr = NULL;\n   lang_hooks.dwarf_name = lhd_dwarf_name;\n   lang_hooks.decl_printable_name = gimple_decl_printable_name;\n   /* We do not want the default decl_assembler_name implementation,"}, {"sha": "75e546d2bc0a9ac39b0431a93b22bee483956b7e", "filename": "gcc/varpool.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c8305f8fcfdab61ed276d1c30e7832e87d9ac55/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=9c8305f8fcfdab61ed276d1c30e7832e87d9ac55", "patch": "@@ -37,17 +37,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"flags.h\"\n \n-/*  This file contains basic routines manipulating variable pool.\n-\n-    Varpool acts as interface in between the front-end and middle-end\n-    and drives the decision process on what variables and when are\n-    going to be compiled.\n-\n-    The varpool nodes are allocated lazily for declarations\n-    either by frontend or at callgraph construction time.\n-    All variables supposed to be output into final file needs to be\n-    explicitly marked by frontend via VARPOOL_FINALIZE_DECL function.  */\n-\n /* Return varpool node assigned to DECL.  Create new one when needed.  */\n struct varpool_node *\n varpool_node (tree decl)"}]}