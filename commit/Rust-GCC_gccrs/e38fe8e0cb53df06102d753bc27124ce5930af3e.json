{"sha": "e38fe8e0cb53df06102d753bc27124ce5930af3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM4ZmU4ZTBjYjUzZGYwNjEwMmQ3NTNiYzI3MTI0Y2U1OTMwYWYzZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2001-01-01T17:20:09Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2001-01-01T17:20:09Z"}, "message": "Extra arg for rtx_varies_p\n\nFrom-SVN: r38590", "tree": {"sha": "80546867210a76704105233dd832200764c92fe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80546867210a76704105233dd832200764c92fe5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e38fe8e0cb53df06102d753bc27124ce5930af3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e38fe8e0cb53df06102d753bc27124ce5930af3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e38fe8e0cb53df06102d753bc27124ce5930af3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e38fe8e0cb53df06102d753bc27124ce5930af3e/comments", "author": null, "committer": null, "parents": [{"sha": "7d797311fb4c1883b6b32fe9d72ed8fe5f002a3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d797311fb4c1883b6b32fe9d72ed8fe5f002a3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d797311fb4c1883b6b32fe9d72ed8fe5f002a3b"}], "stats": {"total": 90, "additions": 56, "deletions": 34}, "files": [{"sha": "d3d1c0984652671db55bafdeafb2c5157f5e50ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e38fe8e0cb53df06102d753bc27124ce5930af3e", "patch": "@@ -1,3 +1,16 @@\n+2001-01-01  Bernd Schmidt  <bernds@redhat.com>\n+\n+\t* alias.c (fixed_scalar_and_varying_struct): Adjust prototype of\n+\targ VARIES_P.  Call it with extra arg.\n+\t(true_dependence): Likewise.\n+\t* rtl.h (rtx_addr_can_trap_p): Declare.\n+\t(rtx_varies_p, rtx_addr_varies_p, true_dependence): Update\n+\tprototypes.\n+\t* rtlanal.c (rtx_addr_can_trap_p): No longer static.\n+\t(rtx_varies_p): Accept extra arg FOR_ALIAS; only disallow\n+\tpic offset table register if it's zero.  All callers changed.\n+\t(rtx_addr_varies_p): Accept extra arg FOR_ALIAS; all callers changed.\n+\n Mon Jan  1 07:38:33 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* explow.c (convert_memory_address, case SYMBOL_REF): Copy"}, {"sha": "be29fc29d78572c3d32eb99316bf5d217da7865d", "filename": "gcc/alias.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=e38fe8e0cb53df06102d753bc27124ce5930af3e", "patch": "@@ -101,7 +101,7 @@ static int insert_subset_children       PARAMS ((splay_tree_node, void*));\n static tree find_base_decl            PARAMS ((tree));\n static alias_set_entry get_alias_set_entry PARAMS ((HOST_WIDE_INT));\n static rtx fixed_scalar_and_varying_struct_p PARAMS ((rtx, rtx, rtx, rtx,\n-\t\t\t\t\t\t      int (*) (rtx)));\n+\t\t\t\t\t\t      int (*) (rtx, int)));\n static int aliases_everything_p         PARAMS ((rtx));\n static int write_dependence_p           PARAMS ((rtx, rtx, int));\n static int nonlocal_mentioned_p         PARAMS ((rtx));\n@@ -1602,19 +1602,19 @@ static rtx\n fixed_scalar_and_varying_struct_p (mem1, mem2, mem1_addr, mem2_addr, varies_p)\n      rtx mem1, mem2;\n      rtx mem1_addr, mem2_addr;\n-     int (*varies_p) PARAMS ((rtx));\n+     int (*varies_p) PARAMS ((rtx, int));\n {  \n   if (! flag_strict_aliasing)\n     return NULL_RTX;\n \n   if (MEM_SCALAR_P (mem1) && MEM_IN_STRUCT_P (mem2) \n-      && !varies_p (mem1_addr) && varies_p (mem2_addr))\n+      && !varies_p (mem1_addr, 1) && varies_p (mem2_addr, 1))\n     /* MEM1 is a scalar at a fixed address; MEM2 is a struct at a\n        varying address.  */\n     return mem1;\n \n   if (MEM_IN_STRUCT_P (mem1) && MEM_SCALAR_P (mem2) \n-      && varies_p (mem1_addr) && !varies_p (mem2_addr))\n+      && varies_p (mem1_addr, 1) && !varies_p (mem2_addr, 1))\n     /* MEM2 is a scalar at a fixed address; MEM1 is a struct at a\n        varying address.  */\n     return mem2;\n@@ -1644,7 +1644,7 @@ true_dependence (mem, mem_mode, x, varies)\n      rtx mem;\n      enum machine_mode mem_mode;\n      rtx x;\n-     int (*varies) PARAMS ((rtx));\n+     int (*varies) PARAMS ((rtx, int));\n {\n   register rtx x_addr, mem_addr;\n   rtx base;"}, {"sha": "d998e42de9901dd7e406c4d16490aa516355bc2a", "filename": "gcc/config/a29k/a29k.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2Fconfig%2Fa29k%2Fa29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2Fconfig%2Fa29k%2Fa29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.h?ref=e38fe8e0cb53df06102d753bc27124ce5930af3e", "patch": "@@ -995,7 +995,7 @@ extern const char *a29k_function_name;\n    && ! (needs_regstack_p () && uses_local_reg_p (PATTERN (INSN)))\t\\\n    && (GET_CODE (PATTERN (INSN)) != SET\t\t\t\t\t\\\n        || GET_CODE (SET_SRC (PATTERN (INSN))) != MEM\t\t\t\\\n-       || ! rtx_varies_p (XEXP (SET_SRC (PATTERN (INSN)), 0))))\n+       || ! rtx_varies_p (XEXP (SET_SRC (PATTERN (INSN)), 0), 0)))\n \f\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts."}, {"sha": "591ba579cb9d33abb11a881e5a73b7f9bb4aa0df", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=e38fe8e0cb53df06102d753bc27124ce5930af3e", "patch": "@@ -2745,7 +2745,7 @@ cse_rtx_varies_p (x)\n \treturn 0;\n     }\n \n-  return rtx_varies_p (x);\n+  return rtx_varies_p (x, 0);\n }\n \f\n /* Canonicalize an expression:"}, {"sha": "1abe902015ca5bb57e34a06308dee29f063422a2", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=e38fe8e0cb53df06102d753bc27124ce5930af3e", "patch": "@@ -540,7 +540,7 @@ equiv_init_varies_p (x)\n       return 0;\n \n     case REG:\n-      return reg_equiv[REGNO (x)].replace == 0 && rtx_varies_p (x);\n+      return reg_equiv[REGNO (x)].replace == 0 && rtx_varies_p (x, 0);\n \n     case ASM_OPERANDS:\n       if (MEM_VOLATILE_P (x))\n@@ -604,7 +604,7 @@ equiv_init_movable_p (x, regno)\n     case REG:\n       return (reg_equiv[REGNO (x)].loop_depth >= reg_equiv[regno].loop_depth\n \t      && reg_equiv[REGNO (x)].replace)\n-\t     || (REG_BASIC_BLOCK (REGNO (x)) < 0 && ! rtx_varies_p (x));\n+\t     || (REG_BASIC_BLOCK (REGNO (x)) < 0 && ! rtx_varies_p (x, 0));\n \n     case UNSPEC_VOLATILE:\n       return 0;\n@@ -933,7 +933,7 @@ update_equiv_regs ()\n       /* cse sometimes generates function invariants, but doesn't put a\n \t REG_EQUAL note on the insn.  Since this note would be redundant,\n          there's no point creating it earlier than here.  */\n-      if (! note && ! rtx_varies_p (src))\n+      if (! note && ! rtx_varies_p (src, 0))\n \tREG_NOTES (insn)\n \t  = note = gen_rtx_EXPR_LIST (REG_EQUAL, src, REG_NOTES (insn));\n \n@@ -944,7 +944,7 @@ update_equiv_regs ()\n \n       if (REG_N_SETS (regno) != 1\n \t  && (! note\n-\t      || rtx_varies_p (XEXP (note, 0))\n+\t      || rtx_varies_p (XEXP (note, 0), 0)\n \t      || (reg_equiv[regno].replacement\n \t\t  && ! rtx_equal_p (XEXP (note, 0),\n \t\t\t\t    reg_equiv[regno].replacement))))\n@@ -958,7 +958,7 @@ update_equiv_regs ()\n \n       /* If this register is known to be equal to a constant, record that\n \t it is always equivalent to the constant.  */\n-      if (note && ! rtx_varies_p (XEXP (note, 0)))\n+      if (note && ! rtx_varies_p (XEXP (note, 0), 0))\n \tPUT_MODE (note, (enum machine_mode) REG_EQUIV);\n \n       /* If this insn introduces a \"constant\" register, decrease the priority"}, {"sha": "833ff5055f16b85ce7dfd70255c0736c73c577b7", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=e38fe8e0cb53df06102d753bc27124ce5930af3e", "patch": "@@ -4431,7 +4431,7 @@ make_memloc (ad, regno)\n \n   /* If TEM might contain a pseudo, we must copy it to avoid\n      modifying it when we do the substitution for the reload.  */\n-  if (rtx_varies_p (tem))\n+  if (rtx_varies_p (tem, 0))\n     tem = copy_rtx (tem);\n \n   tem = gen_rtx_MEM (GET_MODE (ad), tem);"}, {"sha": "c3878774d2fca6784138c0d749d6f71f35ed11cc", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e38fe8e0cb53df06102d753bc27124ce5930af3e", "patch": "@@ -1352,9 +1352,10 @@ extern void set_unique_reg_note         PARAMS ((rtx, enum reg_note, rtx));\n \t\t       : NULL_RTX)\n #define single_set_1(I) single_set_2 (I, PATTERN (I))\n \n+extern int rtx_addr_can_trap_p\t\tPARAMS ((rtx));\n extern int rtx_unstable_p\t\tPARAMS ((rtx));\n-extern int rtx_varies_p\t\t\tPARAMS ((rtx));\n-extern int rtx_addr_varies_p\t\tPARAMS ((rtx));\n+extern int rtx_varies_p\t\t\tPARAMS ((rtx, int));\n+extern int rtx_addr_varies_p\t\tPARAMS ((rtx, int));\n extern HOST_WIDE_INT get_integer_term\tPARAMS ((rtx));\n extern rtx get_related_value\t\tPARAMS ((rtx));\n extern int reg_mentioned_p\t\tPARAMS ((rtx, rtx));\n@@ -1986,7 +1987,7 @@ extern void fancy_abort PARAMS ((const char *, int, const char *))\n /* In alias.c */\n extern rtx canon_rtx                    PARAMS ((rtx));\n extern int true_dependence\t\tPARAMS ((rtx, enum machine_mode, rtx,\n-\t\t\t\t\t\tint (*)(rtx)));\n+\t\t\t\t\t\tint (*)(rtx, int)));\n extern int read_dependence\t\tPARAMS ((rtx, rtx));\n extern int anti_dependence\t\tPARAMS ((rtx, rtx));\n extern int output_dependence\t\tPARAMS ((rtx, rtx));"}, {"sha": "67c5319dfbf6791802f4c8a897bd2f0672383246", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38fe8e0cb53df06102d753bc27124ce5930af3e/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=e38fe8e0cb53df06102d753bc27124ce5930af3e", "patch": "@@ -25,7 +25,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"rtl.h\"\n \n-static int rtx_addr_can_trap_p\tPARAMS ((rtx));\n static void reg_set_p_1\t\tPARAMS ((rtx, rtx, void *));\n static void insn_dependent_p_1\tPARAMS ((rtx, rtx, void *));\n static void reg_set_last_1\tPARAMS ((rtx, rtx, void *));\n@@ -113,11 +112,14 @@ rtx_unstable_p (x)\n /* Return 1 if X has a value that can vary even between two\n    executions of the program.  0 means X can be compared reliably\n    against certain constants or near-constants.\n+   FOR_ALIAS is nonzero if we are called from alias analysis; if it is\n+   zero, we are slightly more conservative.\n    The frame pointer and the arg pointer are considered constant.  */\n \n int\n-rtx_varies_p (x)\n+rtx_varies_p (x, for_alias)\n      rtx x;\n+     int for_alias;\n {\n   register RTX_CODE code = GET_CODE (x);\n   register int i;\n@@ -126,7 +128,7 @@ rtx_varies_p (x)\n   switch (code)\n     {\n     case MEM:\n-      return ! RTX_UNCHANGING_P (x) || rtx_varies_p (XEXP (x, 0));\n+      return ! RTX_UNCHANGING_P (x) || rtx_varies_p (XEXP (x, 0), for_alias);\n \n     case QUEUED:\n       return 1;\n@@ -146,19 +148,22 @@ rtx_varies_p (x)\n       if (x == frame_pointer_rtx || x == hard_frame_pointer_rtx\n \t  || x == arg_pointer_rtx)\n \treturn 0;\n-#ifndef PIC_OFFSET_TABLE_REG_CALL_CLOBBERED\n-      /* ??? When call-clobbered, the value is stable modulo the restore\n-\t that must happen after a call.  This currently screws up local-alloc\n-\t into believing that the restore is not needed.  */\n-      if (x == pic_offset_table_rtx)\n-\treturn 0;\n+      if (x == pic_offset_table_rtx\n+#ifdef PIC_OFFSET_TABLE_REG_CALL_CLOBBERED\n+\t  /* ??? When call-clobbered, the value is stable modulo the restore\n+\t     that must happen after a call.  This currently screws up\n+\t     local-alloc into believing that the restore is not needed, so we\n+\t     must return 0 only if we are called from alias analysis.  */\n+\t  && for_alias\n #endif\n+\t  )\n+\treturn 0;\n       return 1;\n \n     case LO_SUM:\n       /* The operand 0 of a LO_SUM is considered constant\n \t (in fact is it related specifically to operand 1).  */\n-      return rtx_varies_p (XEXP (x, 1));\n+      return rtx_varies_p (XEXP (x, 1), for_alias);\n       \n     case ASM_OPERANDS:\n       if (MEM_VOLATILE_P (x))\n@@ -174,14 +179,14 @@ rtx_varies_p (x)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     if (fmt[i] == 'e')\n       {\n-\tif (rtx_varies_p (XEXP (x, i)))\n+\tif (rtx_varies_p (XEXP (x, i), for_alias))\n \t  return 1;\n       }\n     else if (fmt[i] == 'E')\n       {\n \tint j;\n \tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  if (rtx_varies_p (XVECEXP (x, i, j)))\n+\t  if (rtx_varies_p (XVECEXP (x, i, j), for_alias))\n \t    return 1;\n       }\n \n@@ -190,7 +195,7 @@ rtx_varies_p (x)\n \n /* Return 0 if the use of X as an address in a MEM can cause a trap.  */\n \n-static int\n+int\n rtx_addr_can_trap_p (x)\n      register rtx x;\n {\n@@ -236,11 +241,14 @@ rtx_addr_can_trap_p (x)\n \n /* Return 1 if X refers to a memory location whose address \n    cannot be compared reliably with constant addresses,\n-   or if X refers to a BLKmode memory object.  */\n+   or if X refers to a BLKmode memory object. \n+   FOR_ALIAS is nonzero if we are called from alias analysis; if it is\n+   zero, we are slightly more conservative.  */\n \n int\n-rtx_addr_varies_p (x)\n+rtx_addr_varies_p (x, for_alias)\n      rtx x;\n+     int for_alias;\n {\n   register enum rtx_code code;\n   register int i;\n@@ -251,20 +259,20 @@ rtx_addr_varies_p (x)\n \n   code = GET_CODE (x);\n   if (code == MEM)\n-    return GET_MODE (x) == BLKmode || rtx_varies_p (XEXP (x, 0));\n+    return GET_MODE (x) == BLKmode || rtx_varies_p (XEXP (x, 0), for_alias);\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     if (fmt[i] == 'e')\n       {\n-\tif (rtx_addr_varies_p (XEXP (x, i)))\n+\tif (rtx_addr_varies_p (XEXP (x, i), for_alias))\n \t  return 1;\n       }\n     else if (fmt[i] == 'E')\n       {\n \tint j;\n \tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  if (rtx_addr_varies_p (XVECEXP (x, i, j)))\n+\t  if (rtx_addr_varies_p (XVECEXP (x, i, j), for_alias))\n \t    return 1;\n       }\n   return 0;"}]}