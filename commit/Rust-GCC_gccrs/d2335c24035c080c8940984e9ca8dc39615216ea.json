{"sha": "d2335c24035c080c8940984e9ca8dc39615216ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDIzMzVjMjQwMzVjMDgwYzg5NDA5ODRlOWNhOGRjMzk2MTUyMTZlYQ==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@cygnus.com", "date": "2000-08-06T08:15:28Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-08-06T08:15:28Z"}, "message": "loop.c (try_swap_copy_prop): New function.\n\n \t* loop.c (try_swap_copy_prop): New function.\n\t(load_mems): Rename copies to load_copies and add new regset\n\tstore_copies.  Check for sets of shadow registers and mark\n\tin store_copies.   Call try_swap_copy_prop for registers\n\tmarked in store_copies.\n\nFrom-SVN: r35520", "tree": {"sha": "308e499744e892d3fc4cb95e9100f415d3360dfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/308e499744e892d3fc4cb95e9100f415d3360dfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2335c24035c080c8940984e9ca8dc39615216ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2335c24035c080c8940984e9ca8dc39615216ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2335c24035c080c8940984e9ca8dc39615216ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2335c24035c080c8940984e9ca8dc39615216ea/comments", "author": null, "committer": null, "parents": [{"sha": "837179cfd8907b9952e4c19ca0831ae716e0e26c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/837179cfd8907b9952e4c19ca0831ae716e0e26c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/837179cfd8907b9952e4c19ca0831ae716e0e26c"}], "stats": {"total": 146, "additions": 136, "deletions": 10}, "files": [{"sha": "c9a85a838c559891c2e5b57b7ddfe91333fee405", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2335c24035c080c8940984e9ca8dc39615216ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2335c24035c080c8940984e9ca8dc39615216ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2335c24035c080c8940984e9ca8dc39615216ea", "patch": "@@ -1,3 +1,11 @@\n+2000-08-07  Michael Hayes  <mhayes@cygnus.com>\n+\n+ \t* loop.c (try_swap_copy_prop): New function.\n+\t(load_mems): Rename copies to load_copies and add new regset\n+\tstore_copies.  Check for sets of shadow registers and mark\n+\tin store_copies.   Call try_swap_copy_prop for registers\n+\tmarked in store_copies.\n+\n Sun Aug  6 00:54:42 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n \n \t* objc/objc-act.c: New command line option -fconstant-string-class"}, {"sha": "5f08416b5873f894fcf8e712d2a572a4f25a6043", "filename": "gcc/loop.c", "status": "modified", "additions": 128, "deletions": 10, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2335c24035c080c8940984e9ca8dc39615216ea/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2335c24035c080c8940984e9ca8dc39615216ea/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=d2335c24035c080c8940984e9ca8dc39615216ea", "patch": "@@ -307,6 +307,8 @@ static int replace_loop_mem PARAMS ((rtx *, void *));\n static int replace_loop_reg PARAMS ((rtx *, void *));\n static void note_reg_stored PARAMS ((rtx, rtx, void *));\n static void try_copy_prop PARAMS ((const struct loop *, rtx, unsigned int));\n+static void try_swap_copy_prop PARAMS ((const struct loop *, rtx,\n+\t\t\t\t\t unsigned int));\n static int replace_label PARAMS ((rtx *, void *));\n static rtx check_insn_for_givs PARAMS((struct loop *, rtx, int, int));\n static rtx check_insn_for_bivs PARAMS((struct loop *, rtx, int, int));\n@@ -9462,7 +9464,8 @@ load_mems (loop)\n   /* Actually move the MEMs.  */\n   for (i = 0; i < loop_mems_idx; ++i) \n     {\n-      regset_head copies;\n+      regset_head load_copies;\n+      regset_head store_copies;\n       int written = 0;\n       rtx reg;\n       rtx mem = loop_mems[i].mem;\n@@ -9528,7 +9531,8 @@ load_mems (loop)\n \t   loop, but later discovered that we could not.  */\n \tcontinue;\n \n-      INIT_REG_SET (&copies);\n+      INIT_REG_SET (&load_copies);\n+      INIT_REG_SET (&store_copies);\n \n       /* Allocate a pseudo for this MEM.  We set REG_USERVAR_P in\n \t order to keep scan_loop from moving stores to this MEM\n@@ -9546,23 +9550,41 @@ load_mems (loop)\n \t   p = next_insn_in_loop (loop, p))\n \t{\n \t  rtx_and_int ri;\n-\t  rtx set;\n \n \t  if (INSN_P (p))\n \t    {\n+\t      rtx set;\n+\n+\t      set = single_set (p);\n+\n \t      /* See if this copies the mem into a register that isn't\n \t\t modified afterwards.  We'll try to do copy propagation\n \t\t a little further on.  */\n-\t      set = single_set (p);\n \t      if (set\n \t\t  /* @@@ This test is _way_ too conservative.  */\n \t\t  && ! maybe_never\n \t\t  && GET_CODE (SET_DEST (set)) == REG\n \t\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n \t\t  && REGNO (SET_DEST (set)) < last_max_reg\n-\t\t  && VARRAY_INT (n_times_set, REGNO (SET_DEST (set))) == 1\n-\t\t  && rtx_equal_p (SET_SRC (set), loop_mems[i].mem))\n-\t\tSET_REGNO_REG_SET (&copies, REGNO (SET_DEST (set)));\n+\t\t  && VARRAY_INT (n_times_set, REGNO (SET_DEST (set))) == 1U\n+\t\t  && rtx_equal_p (SET_SRC (set), mem))\n+\t\tSET_REGNO_REG_SET (&load_copies, REGNO (SET_DEST (set)));\n+\n+ \t      /* See if this copies the mem from a register that isn't\n+\t\t modified afterwards.  We'll try to remove the\n+\t\t redundant copy later on by doing a little register\n+\t\t renaming and copy propagation.   This will help\n+\t\t to untangle things for the BIV detection code.  */\n+ \t      if (set\n+ \t\t  && ! maybe_never\n+ \t\t  && GET_CODE (SET_SRC (set)) == REG\n+ \t\t  && REGNO (SET_SRC (set)) >= FIRST_PSEUDO_REGISTER\n+ \t\t  && REGNO (SET_SRC (set)) < last_max_reg\n+ \t\t  && VARRAY_INT (n_times_set, REGNO (SET_SRC (set))) == 1U\n+ \t\t  && rtx_equal_p (SET_DEST (set), mem))\n+ \t\tSET_REGNO_REG_SET (&store_copies, REGNO (SET_SRC (set)));\n+ \t      \n+ \t      /* Replace the memory reference with the shadow register.  */\n \t      ri.r = p;\n \t      ri.i = i;\n \t      for_each_rtx (&p, replace_loop_mem, &ri);\n@@ -9658,11 +9680,18 @@ load_mems (loop)\n \t     data flow, and enables {basic,general}_induction_var to find\n \t     more bivs/givs.  */\n \t  EXECUTE_IF_SET_IN_REG_SET\n-\t    (&copies, FIRST_PSEUDO_REGISTER, j,\n+\t    (&load_copies, FIRST_PSEUDO_REGISTER, j,\n \t     {\n-\t       try_copy_prop (loop, loop_mems[i].reg, j);\n+\t       try_copy_prop (loop, reg, j);\n \t     });\n-\t  CLEAR_REG_SET (&copies);\n+\t  CLEAR_REG_SET (&load_copies);\n+\n+\t  EXECUTE_IF_SET_IN_REG_SET\n+\t    (&store_copies, FIRST_PSEUDO_REGISTER, j,\n+\t     {\n+\t       try_swap_copy_prop (loop, reg, j);\n+\t     });\n+\t  CLEAR_REG_SET (&store_copies);\n \t}\n     }\n \n@@ -9798,6 +9827,95 @@ try_copy_prop (loop, replacement, regno)\n     }\n }\n \n+\n+/* Try to replace occurrences of pseudo REGNO with REPLACEMENT within\n+   loop LOOP if the order of the sets of these registers can be\n+   swapped.  There must be exactly one insn within the loop that sets\n+   this pseudo followed immediately by a move insn that sets\n+   REPLACEMENT with REGNO.  */\n+static void\n+try_swap_copy_prop (loop, replacement, regno)\n+     const struct loop *loop;\n+     rtx replacement;\n+     unsigned int regno;\n+{\n+  rtx insn;\n+  rtx set;\n+  unsigned int new_regno;\n+\n+  new_regno = REGNO (replacement);\n+\n+  for (insn = next_insn_in_loop (loop, loop->scan_start);\n+       insn != NULL_RTX;\n+       insn = next_insn_in_loop (loop, insn))\n+    {\n+      /* Search for the insn that copies REGNO to NEW_REGNO?  */\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t  && (set = single_set (insn))\n+\t  && GET_CODE (SET_DEST (set)) == REG\n+\t  && REGNO (SET_DEST (set)) == new_regno\n+\t  && GET_CODE (SET_SRC (set)) == REG\n+\t  && REGNO (SET_SRC (set)) == regno)\n+\tbreak;\n+    }\n+\n+  if (insn != NULL_RTX)\n+    {\n+      rtx prev_insn;\n+      rtx prev_set;\n+      \n+      /* Some DEF-USE info would come in handy here to make this\n+\t function more general.  For now, just check the previous insn\n+\t which is the most likely candidate for setting REGNO.  */\n+      \n+      prev_insn = PREV_INSN (insn);\n+      \n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t  && (prev_set = single_set (prev_insn))\n+\t  && GET_CODE (SET_DEST (prev_set)) == REG\n+\t  && REGNO (SET_DEST (prev_set)) == regno)\n+\t{\n+\t  /* We have:\n+\t     (set (reg regno) (expr))\n+\t     (set (reg new_regno) (reg regno))\n+\t     \n+\t     so try converting this to:\n+\t     (set (reg new_regno) (expr))\n+\t     (set (reg regno) (reg new_regno))\n+\n+\t     The former construct is often generated when a global\n+\t     variable used for an induction variable is shadowed by a\n+\t     register (NEW_REGNO).  The latter construct improves the\n+\t     chances of GIV replacement and BIV elimination.  */\n+\n+\t  validate_change (prev_insn, &SET_DEST (prev_set),\n+\t\t\t   replacement, 1);\n+\t  validate_change (insn, &SET_DEST (set),\n+\t\t\t   SET_SRC (set), 1);\n+\t  validate_change (insn, &SET_SRC (set),\n+\t\t\t   replacement, 1);\n+\n+\t  if (apply_change_group ())\n+\t    {\n+\t      if (loop_dump_stream)\n+\t\tfprintf (loop_dump_stream, \n+\t\t\t \"  Swapped set of reg %d at %d with reg %d at %d.\\n\", \n+\t\t\t regno, INSN_UID (insn), \n+\t\t\t new_regno, INSN_UID (prev_insn));\n+\n+\t      /* Update first use of REGNO.  */\n+\t      if (REGNO_FIRST_UID (regno) == INSN_UID (prev_insn))\n+\t\tREGNO_FIRST_UID (regno) = INSN_UID (insn);\n+\n+\t      /* Now perform copy propagation to hopefully\n+\t\t remove all uses of REGNO within the loop.  */\n+\t      try_copy_prop (loop, replacement, regno);\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n /* Replace MEM with its associated pseudo register.  This function is\n    called from load_mems via for_each_rtx.  DATA is actually an\n    rtx_and_int * describing the instruction currently being scanned"}]}