{"sha": "01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFkZjVjOGFlMmIwZDhiMmJmN2NmYTQ2MjNiMzE4NjYxNDFlNGFkMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-05-25T15:18:21Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-05-25T15:18:21Z"}, "message": "re PR tree-optimization/36327 (SCCVN should look through struct copies)\n\n2009-05-25  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/36327\n\t* tree-ssa-alias.c (walk_non_aliased_vuses): Add second walker\n\tcallback for reference translation or lookup at the point\n\tof may-defs.\n\t* tree-ssa-alias.h (walk_non_aliased_vuses): Adjust prototype.\n\t* tree-ssa-sccvn.c (get_ref_from_reference_ops): Bail out\n\tfor union COMPONENT_REFs.\n\t(vn_reference_lookup_3): New callback.  Lookup from memset\n\tand CONSTRUCTOR assignment, translate through struct copies.\n\t(vn_reference_lookup_pieces): Make sure to not free the\n\tpassed operands array.  Adjust walk_non_aliased_vuses call.\n\t(vn_reference_lookup): Adjust walk_non_aliased_vuses call,\n\tmake sure we do not leak memory.\n\n\t* gcc.dg/tree-ssa/ssa-fre-24.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-fre-25.c: Likewise.\n\t* gcc.dg/tree-ssa/sra-2.c: Disable FRE.\n\t* gcc.dg/vect/no-vfa-vect-43.c: Adjust.\n\t* gcc.dg/vect/vect-40.c: Likewise.\n\t* gcc.dg/vect/vect-42.c: Likewise.\n\t* gcc.dg/vect/vect-46.c: Likewise.\n\t* gcc.dg/vect/vect-76.c: Likewise.\n\nFrom-SVN: r147851", "tree": {"sha": "870d4d98bd4ce2f44cd8355355fe3b936ee09108", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/870d4d98bd4ce2f44cd8355355fe3b936ee09108"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c74b74a8b2f8a5996943128e574f429670537361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c74b74a8b2f8a5996943128e574f429670537361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c74b74a8b2f8a5996943128e574f429670537361"}], "stats": {"total": 367, "additions": 328, "deletions": 39}, "files": [{"sha": "689967941910ead47835ed711dcea9a607844503", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "patch": "@@ -1,3 +1,19 @@\n+2009-05-25  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/36327\n+\t* tree-ssa-alias.c (walk_non_aliased_vuses): Add second walker\n+\tcallback for reference translation or lookup at the point\n+\tof may-defs.\n+\t* tree-ssa-alias.h (walk_non_aliased_vuses): Adjust prototype.\n+\t* tree-ssa-sccvn.c (get_ref_from_reference_ops): Bail out\n+\tfor union COMPONENT_REFs.\n+\t(vn_reference_lookup_3): New callback.  Lookup from memset\n+\tand CONSTRUCTOR assignment, translate through struct copies.\n+\t(vn_reference_lookup_pieces): Make sure to not free the\n+\tpassed operands array.  Adjust walk_non_aliased_vuses call.\n+\t(vn_reference_lookup): Adjust walk_non_aliased_vuses call,\n+\tmake sure we do not leak memory.\n+\n 2009-05-25  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-alias.h (dump_points_to_solution): Declare."}, {"sha": "578bbeeb8d21d50bdb2cabc908acee4d4e73a003", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "patch": "@@ -1,3 +1,15 @@\n+2009-05-25  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/36327\n+\t* gcc.dg/tree-ssa/ssa-fre-24.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-fre-25.c: Likewise.\n+\t* gcc.dg/tree-ssa/sra-2.c: Disable FRE.\n+\t* gcc.dg/vect/no-vfa-vect-43.c: Adjust.\n+\t* gcc.dg/vect/vect-40.c: Likewise.\n+\t* gcc.dg/vect/vect-42.c: Likewise.\n+\t* gcc.dg/vect/vect-46.c: Likewise.\n+\t* gcc.dg/vect/vect-76.c: Likewise.\n+\n 2009-05-25  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/40176"}, {"sha": "177c4bcace4d85b6d40dda764b23f96b519e220f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/sra-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-2.c?ref=01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O1 -fdump-tree-optimized --param sra-max-structure-size=32\" } */\n+/* { dg-options \"-O1 -fno-tree-fre -fdump-tree-optimized --param sra-max-structure-size=32\" } */\n \n /* Test for SRA. */\n "}, {"sha": "705993a4fb3ed0d600b4017fc57c6baa2b78b549", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-24.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-24.c?ref=01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fno-tree-sra -fdump-tree-fre\" } */\n+\n+int foo(void)\n+{\n+  int a[16] = {};\n+  return a[3];\n+}\n+\n+int bar(void)\n+{\n+  int a[16];\n+  __builtin_memset (a, 0, sizeof(a));\n+  return a[3];\n+}\n+\n+struct X { int i; };\n+int baz(void)\n+{\n+  struct X a,b;\n+  a.i = 0;\n+  b = a;\n+  return b.i;\n+}\n+\n+int bazzoo (void)\n+{\n+  struct X b, a = {};\n+  b = a;\n+  return b.i;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"= 0;\" 5 \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "f7f99bf74f5de19f7c1253297f2fd63d7a20bad5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-25.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-25.c?ref=01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fno-tree-sra -fdump-tree-fre\" } */\n+\n+struct X { int i; int j; };\n+void bar (struct X *);\n+int foo (struct X *p)\n+{\n+  struct X x;\n+  p->i = 1;\n+  x = *p;\n+  x.j = 2;\n+  return p->i - x.i;\n+}\n+\n+/* We should optimize this to return 0.  */\n+\n+/* { dg-final { scan-tree-dump \"= 0;\" \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "65e36fe80158fbf66b2cedd939f78cfe1c222cc2", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-43.c", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-43.c?ref=01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "patch": "@@ -22,41 +22,53 @@ void bar (float *pa, float *pb, float *pc)\n \n \n __attribute__ ((noinline)) int\n-main1 (float *pa)\n+main1 (float *pa, float *pb, float *pc)\n {\n   int i;\n-  float pb[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__))) = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};\n-  float pc[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__))) = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n+  float b[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+  float c[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      b[i] = pb[i];\n+      c[i] = pc[i];\n+    }\n \n   /* Vectorizable: pa may not alias pb and/or pc, even though their\n      addresses escape.  &pa would need to escape to point to escaped memory.  */\n   for (i = 0; i < N; i++)\n     {\n-      pa[i] = pb[i] * pc[i];\n+      pa[i] = b[i] * c[i];\n     }\n \n-  bar (pa,pb,pc);\n+  bar (pa,b,c);\n \n   return 0;\n }\n \n __attribute__ ((noinline)) int\n-main2 (float * pa)\n+main2 (float *pa, float *pb, float *pc)\n {\n   int i;\n-  float pb[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};\n-  float pc[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n+  float b[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+  float c[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      b[i] = pb[i];\n+      c[i] = pc[i];\n+    }\n \n   /* Vectorizable: pb and pc addresses do not escape.  */\n   for (i = 0; i < N; i++)\n     {\n-      pa[i] = pb[i] * pc[i];\n+      pa[i] = b[i] * c[i];\n     }   \n   \n   /* check results:  */\n   for (i = 0; i < N; i++)\n     {\n-      if (pa[i] != (pb[i] * pc[i]))\n+      if (pa[i] != (b[i] * c[i]))\n         abort ();\n     }\n   \n@@ -67,14 +79,16 @@ int main (void)\n {\n   int i;\n   float a[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+  float b[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};\n+  float c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n \n   check_vect ();\n \n-  main1 (a);\n-  main2 (a);\n+  main1 (a,b,c);\n+  main2 (a,b,c);\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 2 \"vect\" } } */\n /*  { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 2 \"vect\" { target vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "d2c17d1d97df2b55a178230ed44e87ca6d8d8bee", "filename": "gcc/testsuite/gcc.dg/vect/vect-40.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-40.c?ref=01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "patch": "@@ -26,13 +26,16 @@ void bar (float *pa, float *pb, float *pc)\n    vect-46.c is similar to this one with one difference: \n         the loop bound is unknown.  */\n \n+float b[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)))\n+     = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};\n+float c[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)))\n+     = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n+\n __attribute__ ((noinline)) int\n main1 ()\n {\n   int i;\n   float a[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n-  float b[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__))) = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};\n-  float c[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__))) = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n   float *pa = a;\n   float *pb = b;\n   float *pc = c;"}, {"sha": "296886386033fd5137c728f76e1c04037b516571", "filename": "gcc/testsuite/gcc.dg/vect/vect-42.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c?ref=01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "patch": "@@ -27,15 +27,22 @@ void bar (float *pa, float *pb, float *pc)\n    No aliasing problems.  */\n \n __attribute__ ((noinline)) int\n-main1 (float * __restrict__ pa)\n+main1 (float * __restrict__ pa, float *pb, float *pc)\n {\n+  float b[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+  float c[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n   int i;\n-  float pb[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__))) = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};\n-  float pc[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__))) = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n \n+  /* We also vectorize this loop.  */\n   for (i = 0; i < N; i++)\n     {\n-      pa[i] = pb[i] * pc[i];\n+      b[i] = pb[i];\n+      c[i] = pc[i];\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      pa[i] = b[i] * c[i];\n     }\n \n   return 0;\n@@ -45,18 +52,18 @@ int main (void)\n {\n   int i;\n   float a[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n-  float b[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__))) = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};\n-  float c[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__))) = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n+  float b[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};\n+  float c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n \n   check_vect ();\n \n-  main1 (a);\n+  main1 (a,b,c);\n   bar (a,b,c);\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n /*  { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { vect_no_align || { ! vector_alignment_reachable } } } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || { ! vector_alignment_reachable } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail { vect_no_align || { ! vector_alignment_reachable } } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail {vect_no_align || { ! vector_alignment_reachable } } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "d506d4329c04e501839195953e116a859daac9ff", "filename": "gcc/testsuite/gcc.dg/vect/vect-46.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-46.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-46.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-46.c?ref=01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "patch": "@@ -26,11 +26,16 @@ void bar (float *pa, float *pb, float *pc)\n    vect-40.c is similar to this one with one difference:\n         the loop bound is known.  */\n \n+float b[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)))\n+     = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};\n+float c[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)))\n+     = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n+\n __attribute__ ((noinline)) int\n main1 (int n)\n {\n   int i;\n-  float a[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));  float b[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__))) = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};  float c[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__))) = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n+  float a[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n   float *pa = a;\n   float *pb = b;\n   float *pc = c;"}, {"sha": "d771302422426cac39d9a7e57ccc8613432548f1", "filename": "gcc/testsuite/gcc.dg/vect/vect-76.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-76.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-76.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-76.c?ref=01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "patch": "@@ -11,13 +11,13 @@\n    more involved than just an ssa_name.  */\n \n int ib[N+OFF] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__))) = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n+int ic[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n \n __attribute__ ((noinline))\n int main1 (int *pib)\n {\n   int i;\n   int ia[N+OFF];\n-  int ic[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n \n   for (i = OFF; i < N; i++)\n     {"}, {"sha": "5bb1f82ad9ba2279c26b310ec6708431d63ae8ac", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "patch": "@@ -1086,11 +1086,19 @@ get_continuation_for_phi (gimple phi, tree ref, bitmap *visited)\n    WALKER returns non-NULL the walk stops and its result is returned.\n    At the end of a non-successful walk NULL is returned.\n \n+   TRANSLATE if non-NULL is called with a pointer to REF, the virtual\n+   use which definition is a statement that may clobber REF and DATA.\n+   If TRANSLATE returns (void *)-1 the walk stops and NULL is returned.\n+   If TRANSLATE returns non-NULL the walk stops and its result is returned.\n+   If TRANSLATE returns NULL the walk continues and TRANSLATE is supposed\n+   to adjust REF and *DATA to make that valid.\n+\n    TODO: Cache the vector of equivalent vuses per ref, vuse pair.  */\n \n void *\n walk_non_aliased_vuses (tree ref, tree vuse,\n-\t\t\tvoid *(*walker)(tree, tree, void *), void *data)\n+\t\t\tvoid *(*walker)(tree, tree, void *),\n+\t\t\tvoid *(*translate)(tree *, tree, void *),void *data)\n {\n   bitmap visited = NULL;\n   void *res;\n@@ -1114,7 +1122,21 @@ walk_non_aliased_vuses (tree ref, tree vuse,\n       else\n \t{\n \t  if (stmt_may_clobber_ref_p (def_stmt, ref))\n-\t    break;\n+\t    {\n+\t      if (!translate)\n+\t\tbreak;\n+\t      res = (*translate) (&ref, vuse, data);\n+\t      /* Failed lookup and translation.  */\n+\t      if (res == (void *)-1)\n+\t\t{\n+\t\t  res = NULL;\n+\t\t  break;\n+\t\t}\n+\t      /* Lookup succeeded.  */\n+\t      else if (res != NULL)\n+\t\tbreak;\n+\t      /* Translation succeeded, continue walking.  */\n+\t    }\n \t  vuse = gimple_vuse (def_stmt);\n \t}\n     }"}, {"sha": "bc96712f790b74759374197ccd1dfe60889d9875", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "patch": "@@ -83,7 +83,8 @@ extern bool refs_output_dependent_p (tree, tree);\n extern bool ref_maybe_used_by_stmt_p (gimple, tree);\n extern bool stmt_may_clobber_ref_p (gimple, tree);\n extern void *walk_non_aliased_vuses (tree, tree,\n-\t\t\t\t     void *(*)(tree, tree, void *), void *);\n+\t\t\t\t     void *(*)(tree, tree, void *),\n+\t\t\t\t     void *(*)(tree *, tree, void *), void *);\n extern unsigned int walk_aliased_vdefs (tree, tree,\n \t\t\t\t\tbool (*)(tree, tree, void *), void *,\n \t\t\t\t\tbitmap *);"}, {"sha": "d2dafb3023fbb50d9b027b26db7f4639e2548b5f", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 166, "deletions": 9, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "patch": "@@ -649,6 +649,9 @@ get_ref_from_reference_ops (VEC(vn_reference_op_s, heap) *ops)\n \t  break;\n \n \tcase COMPONENT_REF:\n+\t  /* We cannot re-construct our fancy union reference handling.  */\n+\t  if (TREE_CODE (op->op0) == INTEGER_CST)\n+\t    return NULL_TREE;\n \t  *op0_p = build3 (COMPONENT_REF, TREE_TYPE (op->op0), NULL_TREE,\n \t\t\t   op->op0, op->op1);\n \t  op0_p = &TREE_OPERAND (*op0_p, 0);\n@@ -940,6 +943,146 @@ vn_reference_lookup_2 (tree op ATTRIBUTE_UNUSED, tree vuse, void *vr_)\n   return NULL;\n }\n \n+/* Callback for walk_non_aliased_vuses.  Tries to perform a lookup\n+   from the statement defining VUSE and if not successful tries to\n+   translate *REFP and VR_ through an aggregate copy at the defintion\n+   of VUSE.  */\n+\n+static void *\n+vn_reference_lookup_3 (tree *refp, tree vuse, void *vr_)\n+{\n+  vn_reference_t vr = (vn_reference_t)vr_;\n+  gimple def_stmt = SSA_NAME_DEF_STMT (vuse);\n+  tree fndecl;\n+  tree ref = *refp;\n+  tree base;\n+  HOST_WIDE_INT offset, size, maxsize;\n+\n+  base = get_ref_base_and_extent (ref, &offset, &size, &maxsize);\n+\n+  /* If we cannot constrain the size of the reference we cannot\n+     test if anything kills it.  */\n+  if (maxsize == -1)\n+    return (void *)-1;\n+\n+  /* def_stmt may-defs *ref.  See if we can derive a value for *ref\n+     from that defintion.\n+     1) Memset.  */\n+  if (is_gimple_reg_type (TREE_TYPE (ref))\n+      && is_gimple_call (def_stmt)\n+      && (fndecl = gimple_call_fndecl (def_stmt))\n+      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_MEMSET\n+      && integer_zerop (gimple_call_arg (def_stmt, 1))\n+      && host_integerp (gimple_call_arg (def_stmt, 2), 1)\n+      && TREE_CODE (gimple_call_arg (def_stmt, 0)) == ADDR_EXPR)\n+    {\n+      tree ref2 = TREE_OPERAND (gimple_call_arg (def_stmt, 0), 0);\n+      tree base2;\n+      HOST_WIDE_INT offset2, size2, maxsize2;\n+      base2 = get_ref_base_and_extent (ref2, &offset2, &size2, &maxsize2);\n+      size2 = TREE_INT_CST_LOW (gimple_call_arg (def_stmt, 2)) * 8;\n+      if ((unsigned HOST_WIDE_INT)size2 / 8\n+\t  == TREE_INT_CST_LOW (gimple_call_arg (def_stmt, 2))\n+\t  && operand_equal_p (base, base2, 0)\n+\t  && offset2 <= offset\n+\t  && offset2 + size2 >= offset + maxsize)\n+\treturn vn_reference_insert (ref,\n+\t\t\t\t    fold_convert (TREE_TYPE (ref),\n+\t\t\t\t\t\t  integer_zero_node), vuse);\n+    }\n+\n+  /* 2) Assignment from an empty CONSTRUCTOR.  */\n+  else if (is_gimple_reg_type (TREE_TYPE (ref))\n+\t   && gimple_assign_single_p (def_stmt)\n+\t   && gimple_assign_rhs_code (def_stmt) == CONSTRUCTOR\n+\t   && CONSTRUCTOR_NELTS (gimple_assign_rhs1 (def_stmt)) == 0)\n+    {\n+      tree base2;\n+      HOST_WIDE_INT offset2, size2, maxsize2;\n+      base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),\n+\t\t\t\t       &offset2, &size2, &maxsize2);\n+      if (operand_equal_p (base, base2, 0)\n+\t  && offset2 <= offset\n+\t  && offset2 + size2 >= offset + maxsize)\n+\treturn vn_reference_insert (ref,\n+\t\t\t\t    fold_convert (TREE_TYPE (ref),\n+\t\t\t\t\t\t  integer_zero_node), vuse);\n+    }\n+\n+  /* For aggregate copies translate the reference through them if\n+     the copy kills ref.  */\n+  else if (gimple_assign_single_p (def_stmt)\n+\t   && (DECL_P (gimple_assign_rhs1 (def_stmt))\n+\t       || INDIRECT_REF_P (gimple_assign_rhs1 (def_stmt))\n+\t       || handled_component_p (gimple_assign_rhs1 (def_stmt))))\n+    {\n+      tree base2;\n+      HOST_WIDE_INT offset2, size2, maxsize2;\n+      int i, j;\n+      VEC (vn_reference_op_s, heap) *lhs = NULL, *rhs = NULL;\n+      vn_reference_op_t vro;\n+\n+      /* See if the assignment kills REF.  */\n+      base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),\n+\t\t\t\t       &offset2, &size2, &maxsize2);\n+      if (!operand_equal_p (base, base2, 0)\n+\t  || offset2 > offset\n+\t  || offset2 + size2 < offset + maxsize)\n+\treturn (void *)-1;\n+\n+      /* Find the common base of ref and the lhs.  */\n+      copy_reference_ops_from_ref (gimple_assign_lhs (def_stmt), &lhs);\n+      i = VEC_length (vn_reference_op_s, vr->operands) - 1;\n+      j = VEC_length (vn_reference_op_s, lhs) - 1;\n+      while (j >= 0\n+\t     && vn_reference_op_eq (VEC_index (vn_reference_op_s,\n+\t\t\t\t\t       vr->operands, i),\n+\t\t\t\t    VEC_index (vn_reference_op_s, lhs, j)))\n+\t{\n+\t  i--;\n+\t  j--;\n+\t}\n+      /* i now points to the first additional op.\n+\t ???  LHS may not be completely contained in VR, one or more\n+\t VIEW_CONVERT_EXPRs could be in its way.  We could at least\n+\t try handling outermost VIEW_CONVERT_EXPRs.  */\n+      if (j != -1)\n+\treturn (void *)-1;\n+      VEC_free (vn_reference_op_s, heap, lhs);\n+\n+      /* Now re-write REF to be based on the rhs of the assignment.  */\n+      copy_reference_ops_from_ref (gimple_assign_rhs1 (def_stmt), &rhs);\n+      /* We need to pre-pend vr->operands[0..i] to rhs.  */\n+      if (i + 1 + VEC_length (vn_reference_op_s, rhs)\n+\t  > VEC_length (vn_reference_op_s, vr->operands))\n+\t{\n+\t  VEC (vn_reference_op_s, heap) *old = vr->operands;\n+\t  VEC_safe_grow (vn_reference_op_s, heap, vr->operands,\n+\t\t\t i + 1 + VEC_length (vn_reference_op_s, rhs));\n+\t  if (old == shared_lookup_references\n+\t      && vr->operands != old)\n+\t    shared_lookup_references = NULL;\n+\t}\n+      else\n+\tVEC_truncate (vn_reference_op_s, vr->operands,\n+\t\t      i + 1 + VEC_length (vn_reference_op_s, rhs));\n+      for (j = 0; VEC_iterate (vn_reference_op_s, rhs, j, vro); ++j)\n+\tVEC_replace (vn_reference_op_s, vr->operands, i + 1 + j, vro);\n+      VEC_free (vn_reference_op_s, heap, rhs);\n+      vr->hashcode = vn_reference_compute_hash (vr);\n+      *refp = get_ref_from_reference_ops (vr->operands);\n+      if (!*refp)\n+\treturn (void *)-1;\n+\n+      /* Keep looking for the adjusted *REF / VR pair.  */\n+      return NULL;\n+    }\n+\n+  /* Bail out and stop walking.  */\n+  return (void *)-1;\n+}\n+\n /* Lookup a reference operation by it's parts, in the current hash table.\n    Returns the resulting value number if it exists in the hash table,\n    NULL_TREE otherwise.  VNRESULT will be filled in with the actual\n@@ -956,9 +1099,17 @@ vn_reference_lookup_pieces (tree vuse,\n   if (!vnresult)\n     vnresult = &tmp;\n   *vnresult = NULL;\n-  \n+\n   vr1.vuse = vuse ? SSA_VAL (vuse) : NULL_TREE;\n-  vr1.operands = valueize_refs (operands);\n+  VEC_truncate (vn_reference_op_s, shared_lookup_references, 0);\n+  VEC_safe_grow (vn_reference_op_s, heap, shared_lookup_references,\n+\t\t VEC_length (vn_reference_op_s, operands));\n+  memcpy (VEC_address (vn_reference_op_s, shared_lookup_references),\n+\t  VEC_address (vn_reference_op_s, operands),\n+\t  sizeof (vn_reference_op_s)\n+\t  * VEC_length (vn_reference_op_s, operands));\n+  vr1.operands = operands = shared_lookup_references\n+    = valueize_refs (shared_lookup_references);\n   vr1.hashcode = vn_reference_compute_hash (&vr1);\n   vn_reference_lookup_1 (&vr1, vnresult);\n \n@@ -967,11 +1118,13 @@ vn_reference_lookup_pieces (tree vuse,\n       && vr1.vuse)\n     {\n       tree ref = get_ref_from_reference_ops (operands);\n-      if (!ref)\n-\treturn NULL_TREE;\n-      *vnresult =\n-\t(vn_reference_t)walk_non_aliased_vuses (ref, vr1.vuse,\n-\t\t\t\t\t\tvn_reference_lookup_2, &vr1);\n+      if (ref)\n+\t*vnresult =\n+\t  (vn_reference_t)walk_non_aliased_vuses (ref, vr1.vuse,\n+\t\t\t\t\t\t  vn_reference_lookup_2,\n+\t\t\t\t\t\t  vn_reference_lookup_3, &vr1);\n+      if (vr1.operands != operands)\n+\tVEC_free (vn_reference_op_s, heap, vr1.operands);\n     }\n \n   if (*vnresult)\n@@ -990,13 +1143,14 @@ tree\n vn_reference_lookup (tree op, tree vuse, bool maywalk,\n \t\t     vn_reference_t *vnresult)\n {\n+  VEC (vn_reference_op_s, heap) *operands;\n   struct vn_reference_s vr1;\n \n   if (vnresult)\n     *vnresult = NULL;\n \n   vr1.vuse = vuse ? SSA_VAL (vuse) : NULL_TREE;\n-  vr1.operands = valueize_shared_reference_ops_from_ref (op);\n+  vr1.operands = operands = valueize_shared_reference_ops_from_ref (op);\n   vr1.hashcode = vn_reference_compute_hash (&vr1);\n \n   if (maywalk\n@@ -1005,7 +1159,10 @@ vn_reference_lookup (tree op, tree vuse, bool maywalk,\n       vn_reference_t wvnresult;\n       wvnresult =\n \t(vn_reference_t)walk_non_aliased_vuses (op, vr1.vuse,\n-\t\t\t\t\t\tvn_reference_lookup_2, &vr1);\n+\t\t\t\t\t\tvn_reference_lookup_2,\n+\t\t\t\t\t\tvn_reference_lookup_3, &vr1);\n+      if (vr1.operands != operands)\n+\tVEC_free (vn_reference_op_s, heap, vr1.operands);\n       if (wvnresult)\n \t{\n \t  if (vnresult)"}]}