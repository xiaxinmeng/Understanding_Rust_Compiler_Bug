{"sha": "d853a20e6cf622329c8f005cc97be8813f935323", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg1M2EyMGU2Y2Y2MjIzMjljOGYwMDVjYzk3YmU4ODEzZjkzNTMyMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-09-09T00:31:39Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-09-09T00:31:39Z"}, "message": "cgraph.c (cgraph_varpool_finalize_decl): Sanity check duplicated finalization.\n\n\t* cgraph.c (cgraph_varpool_finalize_decl): Sanity check duplicated\n\tfinalization.\n\t* cgraphunit.c (decide_is_fnction_needed): Avoid special case of nested\n\tfunctions, check for COMDAT.\n\t(cgraph_assemble_pending_functions): Break out from...\n\t(cgraph_finalize_function): ... here; allow redefinig of extern inline\n\tfunctions.\n\t(record_call_1): Record function references only in non-unit-at-a-time\n\tmode.\n\t(cgraph_analyze_function): Reset current_function_decl.\n\t(cgraph_finalize_compilation_unit):  Assemble pending functions.\n\nFrom-SVN: r71221", "tree": {"sha": "623ba3114b93c04e4e5929e3ff36073432517a82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/623ba3114b93c04e4e5929e3ff36073432517a82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d853a20e6cf622329c8f005cc97be8813f935323", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d853a20e6cf622329c8f005cc97be8813f935323", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d853a20e6cf622329c8f005cc97be8813f935323", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d853a20e6cf622329c8f005cc97be8813f935323/comments", "author": null, "committer": null, "parents": [{"sha": "c05e3efaa4bf6c6ad3ebad148a44d84b4054c799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c05e3efaa4bf6c6ad3ebad148a44d84b4054c799", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c05e3efaa4bf6c6ad3ebad148a44d84b4054c799"}], "stats": {"total": 102, "additions": 87, "deletions": 15}, "files": [{"sha": "21ca4af5cc6024cbca46f1d57b52df2cd157d147", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d853a20e6cf622329c8f005cc97be8813f935323/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d853a20e6cf622329c8f005cc97be8813f935323/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d853a20e6cf622329c8f005cc97be8813f935323", "patch": "@@ -1,3 +1,17 @@\n+Tue Sep  9 02:18:06 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_varpool_finalize_decl): Sanity check duplicated\n+\tfinalization.\n+\t* cgraphunit.c (decide_is_fnction_needed): Avoid special case of nested\n+\tfunctions, check for COMDAT.\n+\t(cgraph_assemble_pending_functions): Break out from...\n+\t(cgraph_finalize_function): ... here; allow redefinig of extern inline\n+\tfunctions.\n+\t(record_call_1): Record function references only in non-unit-at-a-time\n+\tmode.\n+\t(cgraph_analyze_function): Reset current_function_decl.\n+\t(cgraph_finalize_compilation_unit):  Assemble pending functions.\n+\n 2003-09-08  Mark Mitchell  <mark@codesourcery.com>\n \n \t* mklibgcc.in (libcc.a): Depend on stmp-dirs."}, {"sha": "52a3bf631becd1d7b77735c8766b3c3199bba647", "filename": "gcc/cgraph.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d853a20e6cf622329c8f005cc97be8813f935323/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d853a20e6cf622329c8f005cc97be8813f935323/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=d853a20e6cf622329c8f005cc97be8813f935323", "patch": "@@ -481,8 +481,14 @@ void\n cgraph_varpool_finalize_decl (tree decl)\n {\n   struct cgraph_varpool_node *node = cgraph_varpool_node (decl);\n-\n-  if (node->needed && !node->finalized)\n+ \n+  /* The first declaration of a variable that comes through this function\n+     decides whether it is global (in C, has external linkage)\n+     or local (in C, has internal linkage).  So do nothing more\n+     if this function has already run.  */\n+  if (node->finalized)\n+    return;\n+  if (node->needed)\n     {\n       node->next_needed = cgraph_varpool_nodes_queue;\n       cgraph_varpool_nodes_queue = node;"}, {"sha": "a41182f7d3e4a5160091a4c319db36ee036b057a", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 65, "deletions": 13, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d853a20e6cf622329c8f005cc97be8813f935323/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d853a20e6cf622329c8f005cc97be8813f935323/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=d853a20e6cf622329c8f005cc97be8813f935323", "patch": "@@ -106,8 +106,8 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n   /* \"extern inline\" functions are never output locally.  */\n   if (DECL_EXTERNAL (decl))\n     return false;\n-  /* ??? */\n-  if (node->origin)\n+  /* We want to emit COMDAT functions only when they turns out to be neccesary.  */\n+  if (DECL_COMDAT (decl))\n     return false;\n   if (!DECL_INLINE (decl)\n       || (!node->local.disregard_inline_limits\n@@ -120,6 +120,28 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n   return false;\n }\n \n+/* When not doing unit-at-a-time, output all functions enqueued.\n+   Return true when such a functions were found.  */\n+static bool\n+cgraph_assemble_pending_functions (void)\n+{\n+  bool output = false;\n+\n+  if (flag_unit_at_a_time)\n+    return false;\n+\n+  while (cgraph_nodes_queue)\n+    {\n+      struct cgraph_node *n = cgraph_nodes_queue;\n+\n+      cgraph_nodes_queue = cgraph_nodes_queue->next_needed;\n+      if (!n->origin && !DECL_EXTERNAL (n->decl))\n+\tcgraph_expand_function (n);\n+      output = true;\n+    }\n+  return output;\n+}\n+\n /* Analyze function once it is parsed.  Set up the local information\n    available - create cgraph edges for function calls via BODY.  */\n \n@@ -128,6 +150,38 @@ cgraph_finalize_function (tree decl, tree body ATTRIBUTE_UNUSED)\n {\n   struct cgraph_node *node = cgraph_node (decl);\n \n+  if (node->local.finalized)\n+    {\n+      /* As an GCC extension we allow redefinition of the function.  The\n+\t semantics when both copies of bodies differ is not well defined.  We\n+\t replace the old body with new body so in unit at a time mode we always\n+\t use new body, while in normal mode we may end up with old body inlined\n+\t into some functions and new body expanded and inlined in others.\n+\t \n+\t ??? It may make more sense to use one body for inlining and other body\n+\t for expanding the function but this is dificult to do.  */\n+      if (!node->needed)\n+\t{\n+\t  /* Reset our datastructures so we can analyze the function body\n+\t     again.  */\n+\t  memset (&node->local, 0, sizeof (node->local));\n+\t  memset (&node->global, 0, sizeof (node->global));\n+\t  memset (&node->rtl, 0, sizeof (node->rtl));\n+\t  node->lowered = false;\n+\t  if (node->output)\n+\t    abort ();\n+\t  while (node->callees)\n+\t    cgraph_remove_call (node->decl, node->callees->callee->decl);\n+\t}\n+      else\n+      /* Frontend may call finalize_function twice when it is incorrectly\n+         redefined.  */\n+      if (errorcount || sorrycount)\n+\treturn;\n+      else\n+        abort ();\n+    }\n+  notice_global_symbol (decl);\n   node->decl = decl;\n   node->local.finalized = true;\n \n@@ -140,15 +194,9 @@ cgraph_finalize_function (tree decl, tree body ATTRIBUTE_UNUSED)\n     cgraph_mark_needed_node (node);\n \n   /* If not unit at a time, go ahead and emit everything we've\n-     found to be reachable at this time.  */\n-  if (!flag_unit_at_a_time)\n-    while (cgraph_nodes_queue)\n-      {\n-\t struct cgraph_node *n = cgraph_nodes_queue;\n-\t cgraph_nodes_queue = cgraph_nodes_queue->next_needed;\n-\t if (!n->origin)\n-\t   cgraph_expand_function (n);\n-      }\n+     found to be reachable at this time.  Do this only at top-level.  */\n+  if (!node->origin)\n+    cgraph_assemble_pending_functions ();\n \n   /* If we've not yet emitted decl, tell the debug info about it.  */\n   if (flag_unit_at_a_time || !node->reachable)\n@@ -163,7 +211,7 @@ record_call_1 (tree *tp, int *walk_subtrees, void *data)\n     cgraph_varpool_mark_needed_node (cgraph_varpool_node (*tp));\n   /* Record dereferences to the functions.  This makes the functions\n      reachable unconditionally.  */\n-  else if (TREE_CODE (*tp) == ADDR_EXPR)\n+  else if (TREE_CODE (*tp) == ADDR_EXPR && flag_unit_at_a_time)\n     {\n       tree decl = TREE_OPERAND (*tp, 0);\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n@@ -243,6 +291,7 @@ cgraph_analyze_function (struct cgraph_node *node)\n     }\n \n   node->lowered = true;\n+  current_function_decl = NULL;\n }\n \n /* Analyze the whole compilation unit once it is parsed completely.  */\n@@ -253,7 +302,10 @@ cgraph_finalize_compilation_unit (void)\n   struct cgraph_node *node;\n \n   if (!flag_unit_at_a_time)\n-    return;\n+    {\n+      cgraph_assemble_pending_functions ();\n+      return;\n+    }\n \n   cgraph_varpool_assemble_pending_decls ();\n   if (!quiet_flag)"}]}