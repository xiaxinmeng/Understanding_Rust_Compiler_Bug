{"sha": "1b78f5757ac38afb7c5acc14e95f12fef41adc84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI3OGY1NzU3YWMzOGFmYjdjNWFjYzE0ZTk1ZjEyZmVmNDFhZGM4NA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2010-04-17T12:43:40Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2010-04-17T12:43:40Z"}, "message": "arm-protos.h (tune_params): New structure.\n\n\t* arm-protos.h (tune_params): New structure.\n\t* arm.c (current_tune): New variable.\n\t(arm_constant_limit): Delete.\n\t(struct processors): Add pointer to the tune parameters.\n\t(arm_slowmul_tune): New tuning option.\n\t(arm_fastmul_tune, arm_xscale_tune, arm_9e_tune): Likewise.\n\t(all_cores): Adjust to pick up the tuning model.\n\t(arm_constant_limit): New function.\n\t(arm_override_options): Select the appropriate tuning model.  Delete\n\tinitialization of arm_const_limit.\n\t(arm_split_constant): Use the new constant-limit model.\n\t(arm_rtx_costs): Pick up the current tuning model.\n\t* arm.md (is_strongarm, is_xscale): Delete.\n\t* arm-generic.md (load_ldsched_x, load_ldsched): Test explicitly\n\tfor Xscale variant architectures.\n\t(mult_ldsched_strongarm, mult_ldsched): Similarly for StrongARM.\n\nFrom-SVN: r158463", "tree": {"sha": "874622440c9d9f5887b2698d720f3513d1ae92ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/874622440c9d9f5887b2698d720f3513d1ae92ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b78f5757ac38afb7c5acc14e95f12fef41adc84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b78f5757ac38afb7c5acc14e95f12fef41adc84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b78f5757ac38afb7c5acc14e95f12fef41adc84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b78f5757ac38afb7c5acc14e95f12fef41adc84/comments", "author": null, "committer": null, "parents": [{"sha": "6936c61a5cb4cf17d8badafa6d547305cdef63ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6936c61a5cb4cf17d8badafa6d547305cdef63ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6936c61a5cb4cf17d8badafa6d547305cdef63ee"}], "stats": {"total": 121, "additions": 84, "deletions": 37}, "files": [{"sha": "700faedc68d4cbb76607acf71e713fcd87a12e22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b78f5757ac38afb7c5acc14e95f12fef41adc84/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b78f5757ac38afb7c5acc14e95f12fef41adc84/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b78f5757ac38afb7c5acc14e95f12fef41adc84", "patch": "@@ -1,6 +1,26 @@\n+2010-04-17  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm-protos.h (tune_params): New structure.\n+\t* arm.c (current_tune): New variable.\n+\t(arm_constant_limit): Delete.\n+\t(struct processors): Add pointer to the tune parameters.\n+\t(arm_slowmul_tune): New tuning option.\n+\t(arm_fastmul_tune, arm_xscale_tune, arm_9e_tune): Likewise.\n+\t(all_cores): Adjust to pick up the tuning model.\n+\t(arm_constant_limit): New function.\n+\t(arm_override_options): Select the appropriate tuning model.  Delete\n+\tinitialization of arm_const_limit.\n+\t(arm_split_constant): Use the new constant-limit model.\n+\t(arm_rtx_costs): Pick up the current tuning model.\n+\t* arm.md (is_strongarm, is_xscale): Delete.\n+\t* arm-generic.md (load_ldsched_x, load_ldsched): Test explicitly\n+\tfor Xscale variant architectures.\n+\t(mult_ldsched_strongarm, mult_ldsched): Similarly for StrongARM.\n+\n 2010-04-17  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n-\t* config/arm/arm.c (arm_gen_constant): Remove unused variable can_shift.\n+\t* config/arm/arm.c (arm_gen_constant): Remove unused variable\n+\tcan_shift.\n \t(arm_rtx_costs_1): Remove unused variable extra_cost.\n \t(arm_unwind_emit_set): Use variable offset.\n \t(thumb1_output_casesi): Remove unused variable flags."}, {"sha": "cb553a064868965f4d0bc959994b0219e9fdd5d3", "filename": "gcc/config/arm/arm-generic.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b78f5757ac38afb7c5acc14e95f12fef41adc84/gcc%2Fconfig%2Farm%2Farm-generic.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b78f5757ac38afb7c5acc14e95f12fef41adc84/gcc%2Fconfig%2Farm%2Farm-generic.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-generic.md?ref=1b78f5757ac38afb7c5acc14e95f12fef41adc84", "patch": "@@ -104,14 +104,14 @@\n   (and (eq_attr \"generic_sched\" \"yes\")\n        (and (eq_attr \"ldsched\" \"yes\") \n \t    (and (eq_attr \"type\" \"load_byte,load1\")\n-\t         (eq_attr \"is_xscale\" \"yes\"))))\n+\t         (eq_attr \"tune\" \"xscale,iwmmxt,iwmmxt2\"))))\n   \"core\")\n \n (define_insn_reservation \"load_ldsched\" 2\n   (and (eq_attr \"generic_sched\" \"yes\")\n        (and (eq_attr \"ldsched\" \"yes\") \n \t    (and (eq_attr \"type\" \"load_byte,load1\")\n-\t         (eq_attr \"is_xscale\" \"no\"))))\n+\t         (eq_attr \"tune\" \"!xscale,iwmmxt,iwmmxt2\"))))\n   \"core\")\n \n (define_insn_reservation \"load_or_store\" 2\n@@ -128,14 +128,16 @@\n (define_insn_reservation \"mult_ldsched_strongarm\" 3\n   (and (eq_attr \"generic_sched\" \"yes\")\n        (and (eq_attr \"ldsched\" \"yes\") \n-\t    (and (eq_attr \"is_strongarm\" \"yes\")\n+\t    (and (eq_attr \"tune\"\n+\t\t  \"strongarm,strongarm110,strongarm1100,strongarm1110\")\n \t         (eq_attr \"type\" \"mult\"))))\n   \"core*2\")\n \n (define_insn_reservation \"mult_ldsched\" 4\n   (and (eq_attr \"generic_sched\" \"yes\")\n        (and (eq_attr \"ldsched\" \"yes\") \n-\t    (and (eq_attr \"is_strongarm\" \"no\")\n+\t    (and (eq_attr \"tune\"\n+\t\t  \"!strongarm,strongarm110,strongarm1100,strongarm1110\")\n \t         (eq_attr \"type\" \"mult\"))))\n   \"core*4\")\n "}, {"sha": "5a42a259df5bf63d791f14c03ba9e1bf26a00a07", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b78f5757ac38afb7c5acc14e95f12fef41adc84/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b78f5757ac38afb7c5acc14e95f12fef41adc84/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=1b78f5757ac38afb7c5acc14e95f12fef41adc84", "patch": "@@ -213,4 +213,16 @@ extern const char *arm_mangle_type (const_tree);\n \n extern void arm_order_regs_for_local_alloc (void);\n \n+#ifdef RTX_CODE\n+/* This needs to be here because we need RTX_CODE and similar.  */\n+\n+struct tune_params\n+{\n+  bool (*rtx_costs) (rtx, RTX_CODE, RTX_CODE, int *, bool);\n+  int constant_limit;\n+};\n+\n+extern const struct tune_params *current_tune;\n+#endif /* RTX_CODE */\n+\n #endif /* ! GCC_ARM_PROTOS_H */"}, {"sha": "8d21b8782f028d88c131e783c3a105a80431cb01", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b78f5757ac38afb7c5acc14e95f12fef41adc84/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b78f5757ac38afb7c5acc14e95f12fef41adc84/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=1b78f5757ac38afb7c5acc14e95f12fef41adc84", "patch": "@@ -526,6 +526,9 @@ int making_const_table;\n /* The processor for which instructions should be scheduled.  */\n enum processor_type arm_tune = arm_none;\n \n+/* The current tuning set.  */\n+const struct tune_params *current_tune;\n+\n /* The default processor used if not overridden by commandline.  */\n static enum processor_type arm_default_cpu = arm_none;\n \n@@ -698,9 +701,6 @@ unsigned arm_pic_register = INVALID_REGNUM;\n    the next function.  */\n static int after_arm_reorg = 0;\n \n-/* The maximum number of insns to be used when loading a constant.  */\n-static int arm_constant_limit = 3;\n-\n static enum arm_pcs arm_pcs_default;\n \n /* For an explanation of these variables, see final_prescan_insn below.  */\n@@ -739,7 +739,31 @@ struct processors\n   enum processor_type core;\n   const char *arch;\n   const unsigned long flags;\n-  bool (* rtx_costs) (rtx, enum rtx_code, enum rtx_code, int *, bool);\n+  const struct tune_params *const tune;\n+};\n+\n+const struct tune_params arm_slowmul_tune =\n+{\n+  arm_slowmul_rtx_costs,\n+  3\n+};\n+\n+const struct tune_params arm_fastmul_tune =\n+{\n+  arm_fastmul_rtx_costs,\n+  1\n+};\n+\n+const struct tune_params arm_xscale_tune =\n+{\n+  arm_xscale_rtx_costs,\n+  2\n+};\n+\n+const struct tune_params arm_9e_tune =\n+{\n+  arm_9e_rtx_costs,\n+  1\n };\n \n /* Not all of these give usefully different compilation alternatives,\n@@ -748,7 +772,7 @@ static const struct processors all_cores[] =\n {\n   /* ARM Cores */\n #define ARM_CORE(NAME, IDENT, ARCH, FLAGS, COSTS) \\\n-  {NAME, arm_none, #ARCH, FLAGS | FL_FOR_ARCH##ARCH, arm_##COSTS##_rtx_costs},\n+  {NAME, arm_none, #ARCH, FLAGS | FL_FOR_ARCH##ARCH, &arm_##COSTS##_tune},\n #include \"arm-cores.def\"\n #undef ARM_CORE\n   {NULL, arm_none, NULL, 0, NULL}\n@@ -757,7 +781,7 @@ static const struct processors all_cores[] =\n static const struct processors all_architectures[] =\n {\n   /* ARM Architectures */\n-  /* We don't specify rtx_costs here as it will be figured out\n+  /* We don't specify tuning costs here as it will be figured out\n      from the core.  */\n \n   {\"armv2\",   arm2,       \"2\",   FL_CO_PROC | FL_MODE26 | FL_FOR_ARCH2, NULL},\n@@ -906,6 +930,13 @@ enum tls_reloc {\n   TLS_LE32\n };\n \n+/* The maximum number of insns to be used when loading a constant.  */\n+inline static int\n+arm_constant_limit (bool size_p)\n+{\n+  return size_p ? 1 : current_tune->constant_limit;\n+}\n+\n /* Emit an insn that's a simple single-set.  Both the operands must be known\n    to be valid.  */\n inline static rtx\n@@ -1446,6 +1477,7 @@ arm_override_options (void)\n   gcc_assert (arm_tune != arm_none);\n \n   tune_flags = all_cores[(int)arm_tune].flags;\n+  current_tune = all_cores[(int)arm_tune].tune;\n \n   if (target_fp16_format_name)\n     {\n@@ -1842,26 +1874,12 @@ arm_override_options (void)\n \n   if (optimize_size)\n     {\n-      arm_constant_limit = 1;\n-\n       /* If optimizing for size, bump the number of instructions that we\n          are prepared to conditionally execute (even on a StrongARM).  */\n       max_insns_skipped = 6;\n     }\n   else\n     {\n-      /* For processors with load scheduling, it never costs more than\n-         2 cycles to load a constant, and the load scheduler may well\n-\t reduce that to 1.  */\n-      if (arm_ld_sched)\n-        arm_constant_limit = 1;\n-\n-      /* On XScale the longer latency of a load makes it more difficult\n-         to achieve a good schedule, so it's faster to synthesize\n-\t constants that can be done in two insns.  */\n-      if (arm_tune_xscale)\n-        arm_constant_limit = 2;\n-\n       /* StrongARM has early execution of branches, so a sequence\n          that is worth skipping is shorter.  */\n       if (arm_tune_strongarm)\n@@ -2362,7 +2380,8 @@ arm_split_constant (enum rtx_code code, enum machine_mode mode, rtx insn,\n \t  && !cond\n \t  && (arm_gen_constant (code, mode, NULL_RTX, val, target, source,\n \t\t\t\t1, 0)\n-\t      > arm_constant_limit + (code != SET)))\n+\t      > (arm_constant_limit (optimize_function_for_size_p (cfun))\n+\t\t + (code != SET))))\n \t{\n \t  if (code == SET)\n \t    {\n@@ -7294,9 +7313,9 @@ arm_rtx_costs (rtx x, int code, int outer_code, int *total,\n     return arm_size_rtx_costs (x, (enum rtx_code) code,\n \t\t\t       (enum rtx_code) outer_code, total);\n   else\n-    return all_cores[(int)arm_tune].rtx_costs (x, (enum rtx_code) code,\n-\t\t\t\t\t       (enum rtx_code) outer_code,\n-\t\t\t\t\t       total, speed);\n+    return current_tune->rtx_costs (x, (enum rtx_code) code,\n+\t\t\t\t    (enum rtx_code) outer_code,\n+\t\t\t\t    total, speed);\n }\n \n /* RTX costs for cores with a slow MUL implementation.  Thumb-2 is not\n@@ -7441,7 +7460,8 @@ arm_fastmul_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n    so it can be ignored.  */\n \n static bool\n-arm_xscale_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code, int *total, bool speed)\n+arm_xscale_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n+\t\t      int *total, bool speed)\n {\n   enum machine_mode mode = GET_MODE (x);\n "}, {"sha": "2d5003bcfee277d2235eb3b791bef99b2be9b728", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b78f5757ac38afb7c5acc14e95f12fef41adc84/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b78f5757ac38afb7c5acc14e95f12fef41adc84/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=1b78f5757ac38afb7c5acc14e95f12fef41adc84", "patch": "@@ -148,13 +148,6 @@\n ; patterns that share the same RTL in both ARM and Thumb code.\n (define_attr \"is_thumb\" \"no,yes\" (const (symbol_ref \"thumb_code\")))\n \n-; IS_STRONGARM is set to 'yes' when compiling for StrongARM, it affects\n-; scheduling decisions for the load unit and the multiplier.\n-(define_attr \"is_strongarm\" \"no,yes\" (const (symbol_ref \"arm_tune_strongarm\")))\n-\n-; IS_XSCALE is set to 'yes' when compiling for XScale.\n-(define_attr \"is_xscale\" \"no,yes\" (const (symbol_ref \"arm_tune_xscale\")))\n-\n ;; Operand number of an input operand that is shifted.  Zero if the\n ;; given instruction does not shift one of its input operands.\n (define_attr \"shift\" \"\" (const_int 0))"}]}