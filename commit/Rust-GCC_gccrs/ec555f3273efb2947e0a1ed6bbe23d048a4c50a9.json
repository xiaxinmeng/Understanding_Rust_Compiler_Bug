{"sha": "ec555f3273efb2947e0a1ed6bbe23d048a4c50a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM1NTVmMzI3M2VmYjI5NDdlMGExZWQ2YmJlMjNkMDQ4YTRjNTBhOQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2002-12-12T17:11:13Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2002-12-12T17:11:13Z"}, "message": "sh.c (reg_class_from_letter): No longer const.\n\n\t* sh.c (reg_class_from_letter): No longer const.  Add 'e' entry.\n\t(sh_register_move_cost): Add clause for SImode fp-fp moves.\n\tIncrease cost for moves involving multiple general purpose registers.\n\t* sh.h (OVERRIDE_OPTIONS): Set reg_class_from_letter['e'] according to\n\tTARGET_FMOVD.\n\t(HARD_REGNO_MODE_OK): Allow V2SFmode and V4SFmode in general purpose\n\tregisters, and SImode in fp registers, for ! TARGET_SHMEDIA.\n\t(enum reg_class reg_class_from_letter): No longer const.\n\t(SECONDARY_OUTPUT_RELOAD_CLASS): Use REGCLASS_HAS_FP_REG /\n\tREGCLASS_HAS_GENERAL_REG.\n\tHandle SImode moves from/to fp registers.\n\t! TARGET_SHMEDIA && TARGET_FMOVD.\n\t(SECONDARY_INPUT_RELOAD_CLASS): Use REGCLASS_HAS_FP_REG.\n\t* sh.md (movsi_ie): Add alternatives to move from / to fp regisyters.\n\nFrom-SVN: r60076", "tree": {"sha": "dbf9c797639fc0b20546440999f16b2bed59edc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbf9c797639fc0b20546440999f16b2bed59edc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec555f3273efb2947e0a1ed6bbe23d048a4c50a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec555f3273efb2947e0a1ed6bbe23d048a4c50a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec555f3273efb2947e0a1ed6bbe23d048a4c50a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec555f3273efb2947e0a1ed6bbe23d048a4c50a9/comments", "author": null, "committer": null, "parents": [{"sha": "95c0af870b3e3adbe8dab92be1759dada4c6848b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c0af870b3e3adbe8dab92be1759dada4c6848b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95c0af870b3e3adbe8dab92be1759dada4c6848b"}], "stats": {"total": 106, "additions": 71, "deletions": 35}, "files": [{"sha": "79def92e588575db2bfa54db6b8e445ad14440c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec555f3273efb2947e0a1ed6bbe23d048a4c50a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec555f3273efb2947e0a1ed6bbe23d048a4c50a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec555f3273efb2947e0a1ed6bbe23d048a4c50a9", "patch": "@@ -1,3 +1,20 @@\n+Thu Dec 12 16:24:59 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* sh.c (reg_class_from_letter): No longer const.  Add 'e' entry.\n+\t(sh_register_move_cost): Add clause for SImode fp-fp moves.\n+\tIncrease cost for moves involving multiple general purpose registers.\n+\t* sh.h (OVERRIDE_OPTIONS): Set reg_class_from_letter['e'] according to\n+\tTARGET_FMOVD.\n+\t(HARD_REGNO_MODE_OK): Allow V2SFmode and V4SFmode in general purpose\n+\tregisters, and SImode in fp registers, for ! TARGET_SHMEDIA.\n+\t(enum reg_class reg_class_from_letter): No longer const.\n+\t(SECONDARY_OUTPUT_RELOAD_CLASS): Use REGCLASS_HAS_FP_REG /\n+\tREGCLASS_HAS_GENERAL_REG.\n+\tHandle SImode moves from/to fp registers.\n+\t! TARGET_SHMEDIA && TARGET_FMOVD.\n+\t(SECONDARY_INPUT_RELOAD_CLASS): Use REGCLASS_HAS_FP_REG.\n+\t* sh.md (movsi_ie): Add alternatives to move from / to fp regisyters.\n+\n 2002-12-12  Andreas Schwab  <schwab@suse.de>\n \n \t* config/ia64/ia64.c (ia64_hpux_asm_file_end): Fix typo in last"}, {"sha": "824914c42d2232106525983d504d4a91c4c2312f", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec555f3273efb2947e0a1ed6bbe23d048a4c50a9/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec555f3273efb2947e0a1ed6bbe23d048a4c50a9/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=ec555f3273efb2947e0a1ed6bbe23d048a4c50a9", "patch": "@@ -154,16 +154,17 @@ char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n   = SH_ADDITIONAL_REGISTER_NAMES_INITIALIZER;\n \n /* Provide reg_class from a letter such as appears in the machine\n-   description.  */\n+   description.  *: target independently reserved letter.\n+   reg_class_from_letter['e'] is set to NO_REGS for TARGET_FMOVD.  */\n \n-const enum reg_class reg_class_from_letter[] =\n+enum reg_class reg_class_from_letter[] =\n {\n-  /* a */ ALL_REGS, /* b */ TARGET_REGS, /* c */ FPSCR_REGS, /* d */ DF_REGS,\n-  /* e */ NO_REGS, /* f */ FP_REGS, /* g */ NO_REGS, /* h */ NO_REGS,\n-  /* i */ NO_REGS, /* j */ NO_REGS, /* k */ SIBCALL_REGS, /* l */ PR_REGS,\n-  /* m */ NO_REGS, /* n */ NO_REGS, /* o */ NO_REGS, /* p */ NO_REGS,\n-  /* q */ NO_REGS, /* r */ NO_REGS, /* s */ NO_REGS, /* t */ T_REGS,\n-  /* u */ NO_REGS, /* v */ NO_REGS, /* w */ FP0_REGS, /* x */ MAC_REGS,\n+  /* a */ ALL_REGS,  /* b */ TARGET_REGS, /* c */ FPSCR_REGS, /* d */ DF_REGS,\n+  /* e */ FP_REGS,   /* f */ FP_REGS,  /* g **/ NO_REGS,     /* h */ NO_REGS,\n+  /* i **/ NO_REGS,  /* j */ NO_REGS,  /* k */ SIBCALL_REGS, /* l */ PR_REGS,\n+  /* m **/ NO_REGS,  /* n **/ NO_REGS, /* o **/ NO_REGS,     /* p **/ NO_REGS,\n+  /* q */ NO_REGS,   /* r **/ NO_REGS, /* s **/ NO_REGS,     /* t */ T_REGS,\n+  /* u */ NO_REGS,   /* v */ NO_REGS,  /* w */ FP0_REGS,     /* x */ MAC_REGS,\n   /* y */ FPUL_REGS, /* z */ R0_REGS\n };\n \n@@ -7784,9 +7785,8 @@ sh_mark_label (address, nuses)\n /* Compute extra cost of moving data between one register class\n    and another.  */\n \n-/* Regclass always uses 2 for moves in the same register class;\n-   If SECONDARY*_RELOAD_CLASS says something about the src/dst pair,\n-   it uses this information.  Hence, the general register <-> floating point\n+/* If SECONDARY*_RELOAD_CLASS says something about the src/dst pair, regclass\n+   uses this information.  Hence, the general register <-> floating point\n    register information here is not used for SFmode.  */\n \n int\n@@ -7797,6 +7797,11 @@ sh_register_move_cost (mode, srcclass, dstclass)\n   if (dstclass == T_REGS || dstclass == PR_REGS)\n     return 10;\n \n+  if (mode == SImode && ! TARGET_SHMEDIA && TARGET_FMOVD\n+      && REGCLASS_HAS_FP_REG (srcclass)\n+      && REGCLASS_HAS_FP_REG (dstclass))\n+    return 4;\n+\n   if ((REGCLASS_HAS_FP_REG (dstclass)\n        && REGCLASS_HAS_GENERAL_REG (srcclass))\n       || (REGCLASS_HAS_GENERAL_REG (dstclass)\n@@ -7824,7 +7829,13 @@ sh_register_move_cost (mode, srcclass, dstclass)\n       || (dstclass == FPSCR_REGS && ! REGCLASS_HAS_GENERAL_REG (srcclass)))\n   return 4;\n \n-  return 2 * ((GET_MODE_SIZE (mode) + 7) / 8U);\n+  if (TARGET_SHMEDIA\n+      || (TARGET_FMOVD\n+\t  && ! REGCLASS_HAS_GENERAL_REG (srcclass)\n+\t  && ! REGCLASS_HAS_GENERAL_REG (dstclass)))\n+    return 2 * ((GET_MODE_SIZE (mode) + 7) / 8U);\n+\n+  return 2 * ((GET_MODE_SIZE (mode) + 3) / 4U);\n }\n \n #include \"gt-sh.h\""}, {"sha": "f84e6fb8956f13ed4949ac143c7d082b75bd9aa9", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec555f3273efb2947e0a1ed6bbe23d048a4c50a9/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec555f3273efb2947e0a1ed6bbe23d048a4c50a9/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=ec555f3273efb2947e0a1ed6bbe23d048a4c50a9", "patch": "@@ -444,6 +444,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n        targetm.asm_out.aligned_op.di = NULL;\t\t\t\t\\\n        targetm.asm_out.unaligned_op.di = NULL;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_FMOVD)\t\t\t\t\t\t\t\\\n+    reg_class_from_letter['e'] = NO_REGS;\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\t\\\n     if (! VALID_REGISTER_P (regno))\t\t\t\t\t\\\n@@ -912,16 +914,16 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n    ? 1 \\\n    : (MODE) == V2SFmode \\\n    ? ((FP_REGISTER_P (REGNO) && ((REGNO) - FIRST_FP_REG) % 2 == 0) \\\n-      || (TARGET_SHMEDIA && GENERAL_REGISTER_P (REGNO))) \\\n+      || GENERAL_REGISTER_P (REGNO)) \\\n    : (MODE) == V4SFmode \\\n-   ? (FP_REGISTER_P (REGNO) && ((REGNO) - FIRST_FP_REG) % 4 == 0) \\\n+   ? ((FP_REGISTER_P (REGNO) && ((REGNO) - FIRST_FP_REG) % 4 == 0) \\\n+      || (! TARGET_SHMEDIA && GENERAL_REGISTER_P (REGNO))) \\\n    : (MODE) == V16SFmode \\\n    ? (TARGET_SHMEDIA \\\n       ? (FP_REGISTER_P (REGNO) && ((REGNO) - FIRST_FP_REG) % 16 == 0) \\\n       : (REGNO) == FIRST_XD_REG) \\\n    : FP_REGISTER_P (REGNO) \\\n-   ? ((MODE) == SFmode \\\n-      || (TARGET_SHMEDIA && (MODE) == SImode) \\\n+   ? ((MODE) == SFmode || (MODE) == SImode \\\n       || ((TARGET_SH3E || TARGET_SHMEDIA) && (MODE) == SCmode) \\\n       || (((TARGET_SH4 && (MODE) == DFmode) || (MODE) == DCmode \\\n \t   || (TARGET_SHMEDIA && ((MODE) == DFmode || (MODE) == DImode \\\n@@ -1237,7 +1239,7 @@ extern int regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n /* Get reg_class from a letter such as appears in the machine\n    description.  */\n-extern const enum reg_class reg_class_from_letter[];\n+extern enum reg_class reg_class_from_letter[];\n \n #define REG_CLASS_FROM_LETTER(C) \\\n    ( ISLOWER (C) ? reg_class_from_letter[(C)-'a'] : NO_REGS )\n@@ -1302,16 +1304,20 @@ extern const enum reg_class reg_class_from_letter[];\n    : (CLASS)) \\\n \n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,X) \\\n-  ((((((CLASS) == FP_REGS || (CLASS) == FP0_REGS\t\t\t\\\n-\t|| (CLASS) == DF_REGS || (CLASS) == DF_HI_REGS)\t\t\t\\\n-      && (GET_CODE (X) == REG && GENERAL_OR_AP_REGISTER_P (REGNO (X))))\t\\\n-     || (((CLASS) == GENERAL_REGS || (CLASS) == R0_REGS)\t\t\\\n+  ((((REGCLASS_HAS_FP_REG (CLASS) \t\t\t\t\t\\\n+      && (GET_CODE (X) == REG\t\t\t\t\t\t\\\n+      && (GENERAL_OR_AP_REGISTER_P (REGNO (X))\t\t\t\t\\\n+\t  || (FP_REGISTER_P (REGNO (X)) && (MODE) == SImode\t\t\\\n+\t      && TARGET_FMOVD))))\t\t\t\t\t\\\n+     || (REGCLASS_HAS_GENERAL_REG (CLASS) \t\t\t\t\\\n \t && GET_CODE (X) == REG\t\t\t\t\t\t\\\n \t && FP_REGISTER_P (REGNO (X))))\t\t\t\t\t\\\n     && ! TARGET_SHMEDIA\t\t\t\t\t\t\t\\\n-    && MODE == SFmode)\t\t\t\t\t\t\t\\\n+    && ((MODE) == SFmode || (MODE) == SImode))\t\t\t\t\\\n    ? FPUL_REGS\t\t\t\t\t\t\t\t\\\n-   : ((CLASS) == FPUL_REGS\t\t\t\t\t\t\\\n+   : (((CLASS) == FPUL_REGS\t\t\t\t\t\t\\\n+       || (REGCLASS_HAS_FP_REG (CLASS)\t\t\t\t\t\\\n+\t   && ! TARGET_SHMEDIA && MODE == SImode))\t\t\t\\\n       && (GET_CODE (X) == MEM\t\t\t\t\t\t\\\n \t  || (GET_CODE (X) == REG\t\t\t\t\t\\\n \t      && (REGNO (X) >= FIRST_PSEUDO_REGISTER\t\t\t\\\n@@ -1332,8 +1338,7 @@ extern const enum reg_class reg_class_from_letter[];\n    ? GENERAL_REGS : NO_REGS)\n \n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,X)  \\\n-  ((((CLASS) == FP_REGS || (CLASS) == FP0_REGS || (CLASS) == DF_REGS\t\\\n-     || (CLASS) == DF_HI_REGS)\t\t\t\t\t\t\\\n+  ((REGCLASS_HAS_FP_REG (CLASS) \t\t\t\t\t\\\n     && ! TARGET_SHMEDIA\t\t\t\t\t\t\t\\\n     && immediate_operand ((X), (MODE))\t\t\t\t\t\\\n     && ! ((fp_zero_operand (X) || fp_one_operand (X))\t\t\t\\\n@@ -1352,7 +1357,7 @@ extern const enum reg_class reg_class_from_letter[];\n       && ((GET_CODE (X) == REG && REGNO (X) >= FIRST_PSEUDO_REGISTER)\t\\\n \t  || (GET_CODE (X) == MEM && GET_CODE (XEXP ((X), 0)) == PLUS)))\\\n    ? GENERAL_REGS\t\t\t\t\t\t\t\\\n-   : (((CLASS) == FP_REGS || (CLASS) == DF_REGS || (CLASS) == DF_HI_REGS)\\\n+   : (REGCLASS_HAS_FP_REG (CLASS) \t\t\t\t\t\\\n       && TARGET_SHMEDIA\t\t\t\t\t\t\t\\\n       && immediate_operand ((X), (MODE))\t\t\t\t\\\n       && (X) != CONST0_RTX (GET_MODE (X))\t\t\t\t\\\n@@ -2807,15 +2812,13 @@ while (0)\n /* Compute extra cost of moving data between one register class\n    and another.  */\n \n-/* Regclass always uses 2 for moves in the same register class;\n-   If SECONDARY*_RELOAD_CLASS says something about the src/dst pair,\n-   it uses this information.  Hence, the general register <-> floating point\n+/* If SECONDARY*_RELOAD_CLASS says something about the src/dst pair, regclass\n+   uses this information.  Hence, the general register <-> floating point\n    register information here is not used for SFmode.  */\n \n #define REGCLASS_HAS_GENERAL_REG(CLASS) \\\n   ((CLASS) == GENERAL_REGS || (CLASS) == R0_REGS \\\n     || (! TARGET_SHMEDIA && (CLASS) == SIBCALL_REGS))\n-/* NB SIBCALL_REGS are not strictly general, as they include TR0-TR4 */\n \n #define REGCLASS_HAS_FP_REG(CLASS) \\\n   ((CLASS) == FP0_REGS || (CLASS) == FP_REGS \\"}, {"sha": "1df69d194958d47dbec803f223efa32827876efa", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec555f3273efb2947e0a1ed6bbe23d048a4c50a9/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec555f3273efb2947e0a1ed6bbe23d048a4c50a9/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=ec555f3273efb2947e0a1ed6bbe23d048a4c50a9", "patch": "@@ -3408,9 +3408,11 @@\n ;; (subreg:SI (reg:SF FR14_REG) 0) into T (compiling stdlib/strtod.c -m3e -O2)\n ;; ??? This allows moves from macl to fpul to be recognized, but these moves\n ;; will require a reload.\n+;; ??? We can't include f/f because we need the proper FPSCR setting when\n+;; TARGET_FMOVD is in effect, and mode switching is done before reload.\n (define_insn \"movsi_ie\"\n-  [(set (match_operand:SI 0 \"general_movdst_operand\" \"=r,r,t,r,r,r,r,m,<,<,x,l,x,l,y,<,r,y,r,y\")\n-\t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,rI,r,mr,x,l,t,r,x,l,r,r,>,>,>,y,i,r,y,y\"))]\n+  [(set (match_operand:SI 0 \"general_movdst_operand\" \"=r,r,t,r,r,r,r,m,<,<,x,l,x,l,y,<,r,y,r,*f,y,*f,y\")\n+\t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,rI,r,mr,x,l,t,r,x,l,r,r,>,>,>,y,i,r,y,y,*f,*f,y\"))]\n   \"TARGET_SH3E\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n@@ -3434,10 +3436,13 @@\n \tfake\t%1,%0\n \tlds\t%1,%0\n \tsts\t%1,%0\n+\tfsts\tfpul,%0\n+\tflds\t%1,fpul\n+\tfmov\t%1,%0\n \t! move optimized away\"\n-  [(set_attr \"type\" \"pcload_si,move,*,load_si,mac_gp,prget,move,store,store,pstore,move,prset,load,pload,load,store,pcload_si,gp_fpul,fpul_gp,nil\")\n-   (set_attr \"late_fp_use\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,yes,*,*,yes,*\")\n-   (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,0\")])\n+  [(set_attr \"type\" \"pcload_si,move,*,load_si,mac_gp,prget,move,store,store,pstore,move,prset,load,pload,load,store,pcload_si,gp_fpul,fpul_gp,fmove,fmove,fmove,nil\")\n+   (set_attr \"late_fp_use\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,yes,*,*,yes,*,*,*,*\")\n+   (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,0\")])\n \n (define_insn \"movsi_i_lowpart\"\n   [(set (strict_low_part (match_operand:SI 0 \"general_movdst_operand\" \"+r,r,r,r,r,r,m,r\"))"}]}